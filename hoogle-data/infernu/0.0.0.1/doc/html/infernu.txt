-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Type inference and checker for JavaScript (experimental)
--   
@package infernu
@version 0.0.0.1

module Infernu.Options
data Options
Options :: Bool -> Bool -> Bool -> [String] -> Options
optQuiet :: Options -> Bool
optShowCore :: Options -> Bool
optShowParsed :: Options -> Bool
optFileNames :: Options -> [String]
defaultOptions :: Options
opts :: ParserInfo Options

module Infernu.Fix
newtype Fix f
Fix :: f (Fix f) -> Fix f
unFix :: Fix f -> f (Fix f)
fmapReplace :: (Functor f, Eq (f a)) => (f a -> f b -> a -> b) -> f a -> f b -> f a -> f b
replaceFix :: (Functor f, Eq (f (Fix f))) => f (Fix f) -> f (Fix f) -> Fix f -> Fix f

-- | Flattens a fix-type to a list of all tree nodes
--   
--   <pre>
--   &gt;&gt;&gt; fixToList $ (Fix $ TCons TArray [Fix $ TCons TArray [Fix $ TBody TNumber]])
--   [Fix (TCons TArray [Fix (TCons TArray [Fix (TBody TNumber)])]),Fix (TCons TArray [Fix (TBody TNumber)]),Fix (TBody TNumber)]
--   
--   &gt;&gt;&gt; fixToList $ (Fix $ TRow $ TRowProp "x" (TScheme [] $ Fix $ TBody TNumber) (TRowEnd Nothing))
--   [Fix (TRow (TRowProp "x" (TScheme {schemeVars = [], schemeType = Fix (TBody TNumber)}) (TRowEnd Nothing))),Fix (TBody TNumber)]
--   </pre>
fixToList :: Foldable t => Fix t -> [Fix t]
instance Ord (f (Fix f)) => Ord (Fix f)
instance Eq (f (Fix f)) => Eq (Fix f)
instance Show (f (Fix f)) => Show (Fix f)


-- | The sole purpose of this module is to fix pre/post ghc 7.10
--   compatibility issues
module Infernu.Prelude


-- | copied from
--   <a>https://raw.githubusercontent.com/Peaker/lamdu/wip_integration/bottlelib/Data/Function/Decycle.hs</a>
module Infernu.Decycle

-- | A fix for functions that terminates recursive cycles
decycleOn :: Ord b => (a -> b) -> (Maybe (a -> res) -> a -> res) -> a -> res
decycle :: Ord a => (Maybe (a -> res) -> a -> res) -> a -> res
decycle2 :: (Ord b, Ord a) => (Maybe (a -> b -> c) -> a -> b -> c) -> a -> b -> c
decycle3 :: (Ord b, Ord a, Ord c) => (Maybe (a -> b -> c -> res) -> a -> b -> c -> res) -> a -> b -> c -> res

module Infernu.Lib
matchZip :: [a] -> [b] -> Maybe [(a, b)]
safeLookup :: Eq a => [(a, a)] -> a -> a

-- | Creates an inverse map. Multiple keys mapping to the same values are
--   collected into Sets.
--   
--   <pre>
--   &gt;&gt;&gt; flipMap $ Map.fromList [(1,2),(2,2)]
--   fromList [(2,fromList [1,2])]
--   </pre>
flipMap :: (Ord k, Ord v) => Map k v -> Map v (Set k)
splatMap :: Ord k => Map (Set k) a -> Map k a

module Infernu.Types
data GenInfo
GenInfo :: Bool -> Maybe String -> GenInfo
isGen :: GenInfo -> Bool
declName :: GenInfo -> Maybe String
newtype Source
Source :: (GenInfo, SourcePos) -> Source
emptySource :: Source
data Exp a
EVar :: a -> EVarName -> Exp a
EApp :: a -> (Exp a) -> [Exp a] -> Exp a
EAbs :: a -> [EVarName] -> (Exp a) -> Exp a
ELet :: a -> EVarName -> (Exp a) -> (Exp a) -> Exp a
ELit :: a -> LitVal -> Exp a
EAssign :: a -> EVarName -> (Exp a) -> (Exp a) -> Exp a
EPropAssign :: a -> (Exp a) -> EPropName -> (Exp a) -> (Exp a) -> Exp a
EIndexAssign :: a -> (Exp a) -> (Exp a) -> (Exp a) -> (Exp a) -> Exp a
EArray :: a -> [Exp a] -> Exp a
ETuple :: a -> [Exp a] -> Exp a
ERow :: a -> Bool -> [(EPropName, Exp a)] -> Exp a
EStringMap :: a -> [(String, Exp a)] -> Exp a
ECase :: a -> (Exp a) -> [(LitVal, Exp a)] -> Exp a
EProp :: a -> (Exp a) -> EPropName -> Exp a
EIndex :: a -> (Exp a) -> (Exp a) -> Exp a
ENew :: a -> (Exp a) -> [Exp a] -> Exp a
data LitVal
LitNumber :: Double -> LitVal
LitBoolean :: Bool -> LitVal
LitString :: String -> LitVal
LitRegex :: String -> Bool -> Bool -> LitVal
LitUndefined :: LitVal
LitNull :: LitVal
type EVarName = String
type TVarName = Int
data TBody
TVar :: TVarName -> TBody
TNumber :: TBody
TBoolean :: TBody
TString :: TBody
TRegex :: TBody
TUndefined :: TBody
TNull :: TBody
data TConsName
TArray :: TConsName
TTuple :: TConsName
TName :: TypeId -> TConsName
TStringMap :: TConsName
newtype TypeId
TypeId :: TVarName -> TypeId
type Type = Fix FType
newtype Fix f
Fix :: f (Fix f) -> Fix f
unFix :: Fix f -> f (Fix f)
replaceFix :: (Functor f, Eq (f (Fix f))) => f (Fix f) -> f (Fix f) -> Fix f -> Fix f
data FType t
TBody :: TBody -> FType t
TCons :: TConsName -> [t] -> FType t

-- | TFunc (functions) are Profunctor-types. Arguments could have been a
--   single <tt>t</tt> and always wrapped in a Tuple - but are expanded to
--   a list here for convenience
TFunc :: [t] -> t -> FType t
TRow :: (TRowList t) -> FType t
data TypeError
TypeError :: Source -> String -> TypeError
source :: TypeError -> Source
message :: TypeError -> String
data InferState
InferState :: NameSource -> TSubst -> Map VarId TypeScheme -> Gr QualType () -> Map TypeId (Type, TypeScheme) -> Map ClassName (Class Type) -> Set (Source, Type, (ClassName, Set TypeScheme)) -> InferState
nameSource :: InferState -> NameSource
mainSubst :: InferState -> TSubst
varSchemes :: InferState -> Map VarId TypeScheme
varInstances :: InferState -> Gr QualType ()
namedTypes :: InferState -> Map TypeId (Type, TypeScheme)
classes :: InferState -> Map ClassName (Class Type)
pendingUni :: InferState -> Set (Source, Type, (ClassName, Set TypeScheme))
newtype RowTVar
RowTVar :: TVarName -> RowTVar
getRowTVar :: RowTVar -> TVarName
liftRowTVar :: (TVarName -> TVarName) -> RowTVar -> RowTVar
data FlatRowEnd t
FlatRowEndTVar :: (Maybe RowTVar) -> FlatRowEnd t
FlatRowEndRec :: TypeId -> [t] -> FlatRowEnd t

-- | Row type.
data TRowList t
TRowProp :: EPropName -> (TScheme t) -> (TRowList t) -> TRowList t
TRowEnd :: (Maybe RowTVar) -> TRowList t
TRowRec :: TypeId -> [t] -> TRowList t
newtype ClassName
ClassName :: String -> ClassName
data Class t
Class :: [TScheme t] -> Class t
classInstances :: Class t -> [TScheme t]
data TPred t
TPredIsIn :: ClassName -> t -> TPred t
predClass :: TPred t -> ClassName
predType :: TPred t -> t
data TQual t
TQual :: [TPred t] -> t -> TQual t
qualPred :: TQual t -> [TPred t]
qualType :: TQual t -> t
qualEmpty :: t -> TQual t
type QualType = TQual Type
data TScheme t
TScheme :: [TVarName] -> TQual t -> TScheme t
schemeVars :: TScheme t -> [TVarName]
schemeType :: TScheme t -> TQual t
schemeEmpty :: t -> TScheme t
schemeFromQual :: TQual t -> TScheme t
type TypeScheme = TScheme Type

-- | Type environment: maps AST variables (not type variables!) to
--   quantified type schemes.
--   
--   Note: instance of Substable
type TypeEnv = Map EVarName VarId
class Substable a where applySubst' s = fmap $ applySubst s
applySubst :: Substable a => TSubst -> a -> a
applySubst' :: (Substable a, Functor f, Substable a) => TSubst -> f a -> f a
flattenRow :: TRowList t -> (Map EPropName (TScheme t), FlatRowEnd t)
unflattenRow :: Map EPropName (TScheme t) -> FlatRowEnd t -> (EPropName -> Bool) -> TRowList t
type TSubst = Map TVarName Type
nullSubst :: TSubst

-- | composeSubst should obey the law: applySubst (composeSubst new old) t
--   = applySubst new (applySubst old t) &gt;&gt;&gt; composeSubst
--   (Map.fromList []) (Map.fromList []) fromList [] &gt;&gt;&gt;
--   composeSubst (Map.fromList [(0,Fix (TBody (TVar 1)))]) (Map.fromList
--   []) fromList [(0,Fix (TBody (TVar 1)))] &gt;&gt;&gt; composeSubst
--   (Map.fromList []) (Map.fromList [(0,Fix (TBody (TVar 1)))]) fromList
--   [(0,Fix (TBody (TVar 1)))] &gt;&gt;&gt; composeSubst (Map.fromList
--   [(1,Fix (TBody (TVar 2)))]) (Map.fromList [(0,Fix (TBody (TVar 1)))])
--   fromList [(0,Fix (TBody (TVar 2))),(1,Fix (TBody (TVar 2)))]
--   &gt;&gt;&gt; composeSubst (Map.fromList [(0,Fix (TBody (TVar 1)))])
--   (Map.fromList [(1,Fix (TBody (TVar 2)))]) fromList [(0,Fix (TBody
--   (TVar 2))),(1,Fix (TBody (TVar 2)))]
composeSubst :: TSubst -> TSubst -> TSubst
singletonSubst :: TVarName -> Type -> TSubst
newtype VarId
VarId :: Int -> VarId
data NameSource
NameSource :: TVarName -> NameSource
lastName :: NameSource -> TVarName

-- | Adds a pair of equivalent items to an equivalence map. &gt;&gt;&gt;
--   import Infernu.Pretty &gt;&gt;&gt; let m1 = addEquivalence 1 2
--   Map.empty &gt;&gt;&gt; pretty m1 "Map (b =&gt; Set {b, c}, c =&gt; Set
--   {b, c})" &gt;&gt;&gt; pretty $ addEquivalence 1 3 m1 "Map (b =&gt; Set
--   {b, c, d}, c =&gt; Set {b, c, d}, d =&gt; Set {b, c, d})" &gt;&gt;&gt;
--   pretty $ addEquivalence 3 1 m1 "Map (b =&gt; Set {b, c, d}, c =&gt;
--   Set {b, c, d}, d =&gt; Set {b, c, d})" &gt;&gt;&gt; pretty $
--   addEquivalence 4 5 m1 "Map (b =&gt; Set {b, c}, c =&gt; Set {b, c}, e
--   =&gt; Set {e, f}, f =&gt; Set {e, f})" &gt;&gt;&gt; pretty $
--   addEquivalence 1 4 $ addEquivalence 4 5 m1 "Map (b =&gt; Set {b, c, e,
--   f}, c =&gt; Set {b, c, e, f}, e =&gt; Set {b, c, e, f}, f =&gt; Set
--   {b, c, e, f})"
addEquivalence :: TVarName -> TVarName -> Gr QualType () -> Gr QualType ()
class VarNames a where freeTypeVars' = foldr (union . freeTypeVars) empty mapVarNames' f = fmap (mapVarNames f)
freeTypeVars :: VarNames a => a -> Set TVarName
mapVarNames :: VarNames a => (TVarName -> TVarName) -> a -> a
type EPropName = String
mapTopAnnotation :: (a -> a) -> Exp a -> Exp a
instance Show GenInfo
instance Eq GenInfo
instance Ord GenInfo
instance Show LitVal
instance Eq LitVal
instance Ord LitVal
instance Show a => Show (Exp a)
instance Eq a => Eq (Exp a)
instance Ord a => Ord (Exp a)
instance Functor Exp
instance Foldable Exp
instance Show TBody
instance Eq TBody
instance Ord TBody
instance Show TypeId
instance Eq TypeId
instance Ord TypeId
instance Show TConsName
instance Eq TConsName
instance Ord TConsName
instance Show RowTVar
instance Eq RowTVar
instance Ord RowTVar
instance Show Source
instance Eq Source
instance Ord Source
instance Show TypeError
instance Eq TypeError
instance Ord TypeError
instance Show ClassName
instance Eq ClassName
instance Ord ClassName
instance Show t => Show (TPred t)
instance Eq t => Eq (TPred t)
instance Ord t => Ord (TPred t)
instance Functor TPred
instance Foldable TPred
instance Traversable TPred
instance Show t => Show (TQual t)
instance Eq t => Eq (TQual t)
instance Ord t => Ord (TQual t)
instance Functor TQual
instance Foldable TQual
instance Traversable TQual
instance Show t => Show (TScheme t)
instance Eq t => Eq (TScheme t)
instance Ord t => Ord (TScheme t)
instance Functor TScheme
instance Foldable TScheme
instance Traversable TScheme
instance Show t => Show (Class t)
instance Eq t => Eq (Class t)
instance Ord t => Ord (Class t)
instance Functor Class
instance Foldable Class
instance Traversable Class
instance Show t => Show (TRowList t)
instance Eq t => Eq (TRowList t)
instance Ord t => Ord (TRowList t)
instance Functor TRowList
instance Foldable TRowList
instance Traversable TRowList
instance Show t => Show (FType t)
instance Eq t => Eq (FType t)
instance Ord t => Ord (FType t)
instance Functor FType
instance Foldable FType
instance Traversable FType
instance Show VarId
instance Eq VarId
instance Ord VarId
instance Show NameSource
instance Eq NameSource
instance Show InferState
instance Eq InferState
instance Substable InferState
instance VarNames InferState
instance (VarNames t, Substable t) => Substable (TScheme t)
instance VarNames t => VarNames (TScheme t)
instance Substable t => Substable (TPred t)
instance VarNames t => VarNames (TPred t)
instance (Substable t, VarNames t) => Substable (TQual t)
instance VarNames t => VarNames (TQual t)
instance Substable (TRowList Type)
instance Substable Type
instance (Ord a, Substable a) => Substable (Set a)
instance Substable b => Substable (a, b)
instance Substable a => Substable (Map b a)
instance Substable a => Substable [a]
instance Substable a => Substable (Maybe a)
instance VarNames (FType (Fix FType))
instance VarNames Type
instance VarNames t => VarNames (TRowList t)
instance VarNames t => VarNames (Exp (a, t))
instance VarNames t => VarNames (a, t)
instance VarNames t => VarNames [t]
instance VarNames t => VarNames (Map a t)
instance VarNames TBody
instance VarNames TVarName

module Infernu.Builtins.Operators
builtins :: Map EVarName TypeScheme

module Infernu.Builtins.TypeClasses
typeClasses :: [(ClassName, Class (Fix FType))]

module Infernu.Pretty
tab :: Int -> String
class Pretty a
prettyTab :: Pretty a => Int -> a -> String
prettyList :: Pretty a => [a] -> String
pretty :: Pretty a => a -> String
nakedSingleOrTuple :: [String] -> String
toChr :: Int -> Char

-- | <pre>
--   &gt;&gt;&gt; prettyTab 0 (0 :: TVarName)
--   "a"
--   
--   &gt;&gt;&gt; prettyTab 0 (26 :: TVarName)
--   "aa"
--   </pre>
prettyType :: Int -> FType Type -> String
instance Pretty InferState
instance (Show a, Show b) => Pretty (Gr a b)
instance (Ord t, VarNames t, Pretty t) => Pretty (Class t)
instance Pretty VarId
instance Pretty NameSource
instance Pretty TypeError
instance Pretty GenInfo
instance Pretty SourcePos
instance Pretty k => Pretty (Set k)
instance (Pretty k, Pretty v) => Pretty (Map k v)
instance (Pretty a, Pretty b) => Pretty (Either a b)
instance (Ord t, VarNames t, Pretty t) => Pretty (TScheme t)
instance (VarNames t, Pretty t) => Pretty (TQual t)
instance Pretty t => Pretty [TPred t]
instance Pretty t => Pretty (TPred t)
instance Pretty ClassName
instance Pretty (FType Type)
instance Pretty Type
instance Pretty RowTVar
instance Pretty TConsName
instance Pretty TBody
instance Pretty TypeId
instance Pretty Bool
instance Pretty TVarName
instance Pretty (Exp a)
instance Pretty EVarName
instance Pretty LitVal
instance Pretty Source
instance (Pretty a, Pretty b) => Pretty [(a, b)]
instance Pretty [Type]
instance Pretty [String]
instance (Pretty a, Pretty b, Pretty c) => Pretty (a, b, c)
instance (Pretty a, Pretty b) => Pretty (a, b)
instance Pretty a => Pretty (Maybe a)

module Infernu.Log
trace :: a -> b -> b
tracePretty :: Pretty a => String -> a -> a
traceLog :: Applicative f => String -> f ()
traceLogVal :: Applicative f => String -> a -> f a

module Infernu.InferState

-- | Inference monad. Used as a stateful context for generating fresh type
--   variable names.
type Infer a = StateT InferState (EitherT TypeError Identity) a
emptyInferState :: InferState
runInferWith :: InferState -> Infer a -> Either TypeError a
runSubInfer :: Infer a -> Infer (Either TypeError a)
getState :: Infer InferState
setState :: InferState -> Infer ()
runInfer :: Infer a -> Either TypeError a
fresh :: Infer TVarName
freshVarId :: Infer VarId
throwError :: Source -> String -> Infer a
failWith :: Maybe a -> Infer a -> Infer a
failWithM :: Infer (Maybe a) -> Infer a -> Infer a
mapError :: (TypeError -> TypeError) -> Infer a -> Infer a
getVarSchemeByVarId :: VarId -> Infer (Maybe TypeScheme)
getVarId :: EVarName -> TypeEnv -> Maybe VarId
getVarScheme :: Source -> EVarName -> TypeEnv -> Infer (Maybe TypeScheme)
setVarScheme :: TypeEnv -> EVarName -> TypeScheme -> VarId -> Infer TypeEnv
addVarScheme :: TypeEnv -> EVarName -> TypeScheme -> Infer TypeEnv
addPendingUnification :: (Source, Type, (ClassName, Set TypeScheme)) -> Infer ()
getPendingUnifications :: Infer (Set (Source, Type, (ClassName, Set TypeScheme)))
setPendingUnifications :: (Set (Source, Type, (ClassName, Set TypeScheme))) -> Infer ()
addVarInstance :: TVarName -> TVarName -> Infer ()
getFreeTVars :: TypeEnv -> Infer (Set TVarName)
addNamedType :: TypeId -> Type -> TypeScheme -> Infer ()

-- | Compares schemes up to alpha equivalence including named type
--   constructors equivalence (TCons TName...).
--   
--   <pre>
--   &gt;&gt;&gt; let mkNamedType tid ts = Fix $ TCons (TName (TypeId tid)) ts
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; areEquivalentNamedTypes (mkNamedType 0 [], schemeEmpty (Fix $ TBody TNumber)) (mkNamedType 1 [], schemeEmpty (Fix $ TBody TString))
--   False
--   
--   &gt;&gt;&gt; areEquivalentNamedTypes (mkNamedType 0 [], schemeEmpty (mkNamedType 0 [])) (mkNamedType 1 [], schemeEmpty (mkNamedType 1 []))
--   True
--   
--   &gt;&gt;&gt; :{
--       areEquivalentNamedTypes (mkNamedType 0 [], schemeEmpty (Fix $ TFunc [Fix $ TBody TNumber] (mkNamedType 0 [])))
--                               (mkNamedType 1 [], schemeEmpty (Fix $ TFunc [Fix $ TBody TNumber] (mkNamedType 1 [])))
--   :}
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--       areEquivalentNamedTypes (mkNamedType 0 [Fix $ TBody $ TVar 10], TScheme [10] (qualEmpty $ Fix $ TFunc [Fix $ TBody $ TVar 10] (mkNamedType 0 [Fix $ TBody $ TVar 10])))
--                               (mkNamedType 1 [Fix $ TBody $ TVar 11], TScheme [11] (qualEmpty $ Fix $ TFunc [Fix $ TBody $ TVar 11] (mkNamedType 1 [Fix $ TBody $ TVar 11])))
--   :}
--   True
--   </pre>
areEquivalentNamedTypes :: (Type, TypeScheme) -> (Type, TypeScheme) -> Bool

-- | Returns a TQual with the <tt>src</tt> type replaced everywhere with
--   the <tt>dest</tt> type.
replaceFixQual :: (Functor f, Eq (f (Fix f))) => f (Fix f) -> f (Fix f) -> TQual (Fix f) -> TQual (Fix f)
isRecParamOnly :: (Num t, Enum t) => TVarName -> Maybe (TypeId, t) -> Type -> Maybe [(TypeId, t)]
dropAt :: Integral a => a -> [b] -> [b]
replaceRecType :: TypeId -> TypeId -> Int -> Type -> Type
allocNamedType :: TVarName -> Type -> Infer Type
resolveSimpleMutualRecursion :: TVarName -> Type -> TypeId -> Int -> Infer Type
getNamedType :: TVarName -> Type -> Infer Type
unrollNameByScheme :: Substable a => [Type] -> [TVarName] -> a -> a

-- | Unrolls (expands) a TName recursive type by plugging in the holes from
--   the given list of types. Similar to instantiation, but uses a
--   pre-defined set of type instances instead of using fresh type
--   variables.
unrollName :: Source -> TypeId -> [Type] -> Infer QualType

-- | Applies a subsitution onto the state (basically on the variable -&gt;
--   scheme map).
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   runInfer $ do
--       let t = TScheme [0] (TQual [] (Fix $ TFunc [Fix $ TBody (TVar 0)] (Fix $ TBody (TVar 1))))
--       let tenv = Map.empty
--       tenv' &lt;- addVarScheme tenv "x" t
--       applySubstInfer $ Map.singleton 0 (Fix $ TBody TString)
--       varSchemes &lt;$&gt; get
--   :}
--   Right (fromList [(VarId 3,TScheme {schemeVars = [], schemeType = TQual {qualPred = [], qualType = Fix (TFunc [Fix (TBody TString)] Fix (TBody (TVar 1)))}})])
--   </pre>
applySubstInfer :: TSubst -> Infer ()

-- | Instantiate a type scheme by giving fresh names to all quantified type
--   variables.
--   
--   For example:
--   
--   <pre>
--   &gt;&gt;&gt; runInferWith (emptyInferState { nameSource = NameSource 2 }) . instantiate $ TScheme [0] (TQual { qualPred = [], qualType = Fix $ TFunc [Fix $ TBody (TVar 0)] (Fix $ TBody (TVar 1)) })
--   Right (TQual {qualPred = [], qualType = Fix (TFunc [Fix (TBody (TVar 3))] Fix (TBody (TVar 1)))})
--   </pre>
--   
--   In the above example, type variable 0 has been replaced with a fresh
--   one (3), while the unqualified free type variable 1 has been left
--   as-is.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   runInfer $ do
--       let t = TScheme [0] (TQual [] (Fix $ TFunc [Fix $ TBody (TVar 0)] (Fix $ TBody (TVar 1))))
--       let tenv = Map.empty
--       tenv' &lt;- addVarScheme tenv "x" t
--       instantiateVar emptySource "x" tenv'
--   :}
--   Right (TQual {qualPred = [], qualType = Fix (TFunc [Fix (TBody (TVar 4))] Fix (TBody (TVar 1)))})
--   </pre>
instantiateScheme :: Bool -> TypeScheme -> Infer QualType
instantiate :: TypeScheme -> Infer QualType
instantiateVar :: Source -> EVarName -> TypeEnv -> Infer QualType

-- | Generalizes a type to a type scheme, i.e. wraps it in a "forall" that
--   quantifies over all type variables that are free in the given type,
--   but are not free in the type environment.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; runInfer $ generalize (ELit "bla" LitUndefined) Map.empty $ qualEmpty $ Fix $ TFunc [Fix $ TBody (TVar 0)] (Fix $ TBody (TVar 1))
--   Right (TScheme {schemeVars = [0,1], schemeType = TQual {qualPred = [], qualType = Fix (TFunc [Fix (TBody (TVar 0))] Fix (TBody (TVar 1)))}})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   runInfer $ do
--       let t = TScheme [1] (TQual [] (Fix $ TFunc [Fix $ TBody (TVar 0)] (Fix $ TBody (TVar 1))))
--       tenv &lt;- addVarScheme Map.empty "x" t
--       generalize (ELit "bla" LitUndefined) tenv (qualEmpty $ Fix $ TFunc [Fix $ TBody (TVar 0)] (Fix $ TBody (TVar 2)))
--   :}
--   Right (TScheme {schemeVars = [2], schemeType = TQual {qualPred = [], qualType = Fix (TFunc [Fix (TBody (TVar 0))] Fix (TBody (TVar 2)))}})
--   </pre>
--   
--   In this example the steps were:
--   
--   <ol>
--   <li>Environment: { x :: forall 0. 0 -&gt; 1 }</li>
--   <li>generalize (1 -&gt; 2)</li>
--   <li>result: forall 2. 1 -&gt; 2</li>
--   </ol>
--   
--   <pre>
--   &gt;&gt;&gt; let expr = ELit "foo" LitUndefined
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runInfer $ generalize expr Map.empty (qualEmpty $ Fix $ TFunc [Fix $ TBody (TVar 0)] (Fix $ TBody (TVar 0)))
--   Right (TScheme {schemeVars = [0], schemeType = TQual {qualPred = [], qualType = Fix (TFunc [Fix (TBody (TVar 0))] Fix (TBody (TVar 0)))}})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runInfer $ generalize expr Map.empty (TQual [TPredIsIn (ClassName "Bla") (Fix $ TBody (TVar 1))] (Fix $ TBody (TVar 0)))
--   Right (TScheme {schemeVars = [0,1], schemeType = TQual {qualPred = [TPredIsIn {predClass = ClassName "Bla", predType = Fix (TBody (TVar 1))}], qualType = Fix (TBody (TVar 0))}})
--   </pre>
--   
--   TODO add tests for monotypes
unsafeGeneralize :: TypeEnv -> QualType -> Infer TypeScheme
isExpansive :: Exp a -> Bool
generalize :: Exp a -> TypeEnv -> QualType -> Infer TypeScheme
minifyVarsFunc :: VarNames a => a -> TVarName -> TVarName
minifyVars :: VarNames a => a -> a
getVarInstances :: Infer (Gr QualType ())
getMainSubst :: Infer TSubst
applyMainSubst :: Substable b => b -> Infer b
substVar :: TSubst -> TVarName -> TVarName
lookupClass :: ClassName -> Infer (Maybe (Class Type))

module Infernu.Builtins.Regex
regexRowType :: Infer (TRowList Type)

module Infernu.Builtins.String
stringRowType :: Infer (TRowList Type)

module Infernu.Parse
translate :: [Statement SourcePos] -> Exp (GenInfo, SourcePos)

module Infernu.Builtins.Array
arrayRowType :: Type -> Infer (TRowList Type)

module Infernu.Unify
unify :: UnifyF
unifyAll :: Source -> [Type] -> Infer ()

-- | Unifies pairs of types, accumulating the substs
unifyl :: UnifyF -> Source -> [(Type, Type)] -> Infer ()
unifyRowPropertyBiased :: Source -> Infer () -> (TypeScheme, TypeScheme) -> Infer ()
unifyPredsL :: Source -> [TPred Type] -> Infer [TPred Type]
unifyPending :: Infer ()

module Infernu.Infer
runTypeInference :: Exp Source -> Either TypeError (Exp (Source, QualType))

-- | Mutable variable being assigned incompatible types:
--   
--   <pre>
--   &gt;&gt;&gt; let p = emptySource
--   
--   &gt;&gt;&gt; let fun args = EAbs p ("this":args)
--   
--   &gt;&gt;&gt; let var = EVar p
--   
--   &gt;&gt;&gt; let let' = ELet p
--   
--   &gt;&gt;&gt; let tuple = ETuple p
--   
--   &gt;&gt;&gt; let lit = ELit p
--   
--   &gt;&gt;&gt; let app a b = EApp p a [lit LitUndefined, b]
--   
--   &gt;&gt;&gt; let assign = EAssign p
--   
--   &gt;&gt;&gt; let array = EArray p
--   </pre>
--   
--   x is known to have type forall a. a -&gt; a, and to have been used in
--   a context requiring bool -&gt; bool (e.g. `x True`)
--   
--   we now try to assign x := y -&gt; 2
--   
--   This should fail because it "collapses" x to be Number -&gt; Number
--   which is not compatible with bool -&gt; bool
--   
--   <pre>
--   &gt;&gt;&gt; test $ let' "x" (fun ["z"] (var "z")) (let' "y" (tuple [app (var "x") (lit (LitNumber 2)), app (var "x") (lit (LitBoolean True))]) (assign "x" (fun ["y"] (lit (LitNumber 0))) (tuple [var "x", var "y"])))
--   ":1:1*: Error: Could not unify: Number with Boolean"
--   </pre>
--   
--   The following should succeed because x is immutable and thus
--   polymorphic:
--   
--   <pre>
--   &gt;&gt;&gt; test $ let' "x" (fun ["z"] (var "z")) (let' "y" (tuple [app (var "x") (lit (LitNumber 2)), app (var "x") (lit (LitBoolean True))]) (tuple [var "x", var "y"]))
--   "(c.(d -&gt; d), (Number, Boolean))"
--   </pre>
--   
--   The following should fail because x is mutable and therefore a
--   monotype:
--   
--   <pre>
--   &gt;&gt;&gt; test $ let' "x" (fun ["z"] (var "z")) (let' "y" (tuple [app (var "x") (lit (LitNumber 2)), app (var "x") (lit (LitBoolean True))]) (assign "x" (fun ["z1"] (var "z1")) (tuple [var "x", var "y"])))
--   ":1:1*: Error: Could not unify: Number with Boolean"
--   </pre>
--   
--   The following should also succeed because "x" is only ever used like
--   this: (x True). The second assignment to x is: x := z1 -&gt; False,
--   which is specific but matches the usage. Note that x's type is
--   collapsed to: Boolean -&gt; Boolean.
--   
--   <pre>
--   &gt;&gt;&gt; test $ let' "x" (fun ["z"] (var "z")) (let' "y" (app (var "x") (lit (LitBoolean True))) (assign "x" (fun ["z1"] (lit (LitBoolean False))) (tuple [var "x", var "y"])))
--   "((Boolean -&gt; Boolean), Boolean)"
--   </pre>
--   
--   | Tests a setter for x being called with something more specific than
--   x's original definition: &gt;&gt;&gt; :{ &gt;&gt;&gt; test $ let'
--   &gt;&gt;&gt; "x" (fun ["a"] (var "a")) &gt;&gt;&gt; (let' "setX"
--   &gt;&gt;&gt; (fun ["v"] &gt;&gt;&gt; (let' &gt;&gt;&gt; "_" (assign
--   "x" (var "v") (var "x")) (lit (LitBoolean False)))) &gt;&gt;&gt; (let'
--   &gt;&gt;&gt; "_" (app (var "setX") (fun ["a"] (lit (LitString "a"))))
--   &gt;&gt;&gt; (app (var "x") (lit (LitBoolean True))))) &gt;&gt;&gt; :}
--   ":1:1*: Error: Could not unify: String with Boolean"
--   
--   <pre>
--   &gt;&gt;&gt; test $ tuple [lit (LitBoolean True), lit (LitNumber 2)]
--   "(Boolean, Number)"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; test $ let' "id" (fun ["x"] (var "x")) (assign "id" (fun ["y"] (var "y")) (var "id"))
--   "a.(b -&gt; b)"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; test $ let' "id" (fun ["x"] (var "x")) (assign "id" (lit (LitBoolean True)) (var "id"))
--   ":1:1*: Error: Could not unify: a.(b -&gt; b) with Boolean"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; test $ let' "x" (lit (LitBoolean True)) (assign "x" (lit (LitBoolean False)) (var "x"))
--   "Boolean"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; test $ let' "x" (lit (LitBoolean True)) (assign "x" (lit (LitNumber 3)) (var "x"))
--   ":1:1*: Error: Could not unify: Boolean with Number"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; test $ let' "x" (array [lit (LitBoolean True)]) (var "x")
--   "[Boolean]"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; test $ let' "x" (array [lit $ LitBoolean True, lit $ LitBoolean False]) (var "x")
--   "[Boolean]"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; test $ let' "x" (array []) (assign "x" (array []) (var "x"))
--   "[a]"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; test $ let' "x" (array [lit $ LitBoolean True, lit $ LitNumber 2]) (var "x")
--   ":1:1*: Error: Could not unify: Number with Boolean"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; test $ let' "id" (fun ["x"] (let' "y" (var "x") (var "y"))) (app (var "id") (var "id"))
--   "c.(d -&gt; d)"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; test $ let' "id" (fun ["x"] (let' "y" (var "x") (var "y"))) (app (app (var "id") (var "id")) (lit (LitNumber 2)))
--   "Number"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; test $ let' "id" (fun ["x"] (app (var "x") (var "x"))) (var "id")
--   ":1:1*: Error: Occurs check failed: a in (a -&gt; b)"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; test $ fun ["m"] (let' "y" (var "m") (let' "x" (app (var "y") (lit (LitBoolean True))) (var "x")))
--   "a.((Boolean -&gt; b) -&gt; b)"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; test $ app (lit (LitNumber 2)) (lit (LitNumber 2))
--   ":1:1*: Error: Could not unify: Number with (Number -&gt; a)"
--   </pre>
--   
--   EAssign tests &gt;&gt;&gt; test $ let' "x" (fun ["y"] (lit (LitNumber
--   0))) (assign "x" (fun ["y"] (var "y")) (var "x")) "a.(Number -&gt;
--   Number)"
--   
--   <pre>
--   &gt;&gt;&gt; test $ let' "x" (fun ["y"] (var "y")) (assign "x" (fun ["y"] (lit (LitNumber 0))) (var "x"))
--   "a.(Number -&gt; Number)"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; test $ let' "x" (fun ["y"] (var "y")) (tuple [app (var "x") (lit (LitNumber 2)), app (var "x") (lit (LitBoolean True))])
--   "(Number, Boolean)"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; test $ let' "x" (fun ["y"] (var "y")) (app (var "x") (var "x"))
--   "c.(d -&gt; d)"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; test $ let' "x" (fun ["a"] (var "a")) (let' "getX" (fun ["v"] (var "x")) (let' "setX" (fun ["v"] (let' "_" (assign "x" (var "v") (var "x")) (lit (LitBoolean True)))) (let' "_" (app (var "setX") (fun ["a"] (lit (LitString "a")))) (var "getX"))))
--   "e.(f -&gt; d.(String -&gt; String))"
--   </pre>
test :: Exp Source -> String
class Pretty a
prettyTab :: Pretty a => Int -> a -> String
pretty :: Pretty a => a -> String
getAnnotations :: Exp a -> [a]
minifyVars :: VarNames a => a -> a
data TypeError

module Infernu.Util
checkFiles :: Options -> [String] -> IO (Either TypeError [(Source, QualType)])
annotatedSource :: [(Source, QualType)] -> [String] -> String
checkSource :: String -> Either TypeError [(Source, QualType)]
