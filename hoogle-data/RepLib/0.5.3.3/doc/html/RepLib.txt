-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generic programming library with representation types
--   
@package RepLib
@version 0.5.3.3


-- | Basic data structure and class for representation types
module Generics.RepLib.R

-- | A value of type <tt>R a</tt> is a representation of a type <tt>a</tt>.
data R a
Int :: R Int
Char :: R Char
Integer :: R Integer
Float :: R Float
Double :: R Double
Rational :: R Rational
IOError :: R IOError
IO :: R a -> R (IO a)
Arrow :: R a -> R b -> R (a -> b)
Data :: DT -> [Con R a] -> R a
Abstract :: DT -> R a
Equal :: R a -> R b -> R (a :~: b)

-- | Representation of a data constructor includes an embedding between the
--   datatype and a list of other types as well as the representation of
--   that list of other types.
data Con r a
Con :: Emb l a -> MTup r l -> Con r a

-- | An embedding between a list of types <tt>l</tt> and a datatype
--   <tt>a</tt>, based on a particular data constructor. The to function is
--   a wrapper for the constructor, the from function pattern matches on
--   the constructor.
data Emb l a
Emb :: (l -> a) -> (a -> Maybe l) -> Maybe [String] -> String -> Fixity -> Emb l a
to :: Emb l a -> l -> a
from :: Emb l a -> a -> Maybe l
labels :: Emb l a -> Maybe [String]
name :: Emb l a -> String
fixity :: Emb l a -> Fixity
data Fixity
Nonfix :: Fixity
Infix :: Int -> Fixity
prec :: Fixity -> Int
Infixl :: Int -> Fixity
prec :: Fixity -> Int
Infixr :: Int -> Fixity
prec :: Fixity -> Int

-- | Information about a datatype, including its fully qualified name and
--   representation of its type arguments.
data DT
DT :: String -> (MTup R l) -> DT

-- | An empty list of types
data Nil
Nil :: Nil

-- | Cons for a list of types
data (:*:) a l
(:*:) :: a -> l -> (:*:) a l

-- | A heterogeneous list
data MTup r l
MNil :: MTup r Nil
(:+:) :: r a -> MTup r l -> MTup r (a :*: l)

-- | A class of representable types
class Rep a
rep :: Rep a => R a
rUnitEmb :: Emb Nil ()
rUnit :: R ()
rTup2 :: (Rep a, Rep b) => R (a, b)
rPairEmb :: Emb (a :*: (b :*: Nil)) (a, b)
rList :: Rep a => R [a]
rNilEmb :: Emb Nil [a]
rConsEmb :: Emb (a :*: ([a] :*: Nil)) [a]
instance Rep a => Rep [a]
instance (Rep a, Rep b) => Rep (a, b)
instance Rep ()
instance (Rep a, Rep b) => Rep (a :~: b)
instance (Rep a, Rep b) => Rep (a -> b)
instance Rep a => Rep (IO a)
instance Rep IOError
instance Rep Rational
instance Rep Double
instance Rep Float
instance Rep Integer
instance Rep Char
instance Rep Int
instance Ord (R a)
instance Eq (R a)
instance Show (MTup R l)
instance Show DT
instance Show (R a)


module Generics.RepLib.R1
data R1 ctx a
Int1 :: R1 ctx Int
Char1 :: R1 ctx Char
Integer1 :: R1 ctx Integer
Float1 :: R1 ctx Float
Double1 :: R1 ctx Double
Rational1 :: R1 ctx Rational
IOError1 :: R1 ctx IOError
IO1 :: ctx a -> R1 ctx (IO a)
Arrow1 :: ctx a -> ctx b -> R1 ctx (a -> b)
Data1 :: DT -> [Con ctx a] -> R1 ctx a
Abstract1 :: DT -> R1 ctx a
Equal1 :: ctx a -> ctx b -> R1 ctx (a :~: b)
class Sat a
dict :: Sat a => a
class Rep a => Rep1 ctx a
rep1 :: Rep1 ctx a => R1 ctx a

-- | Access a representation, given a proxy
getRepC :: Rep b => c b -> R b

-- | Transform a parameterized rep to a vanilla rep
toR :: R1 c a -> R a
rTup2_1 :: (Rep a, Rep b) => ctx a -> ctx b -> R1 ctx (a, b)
rList1 :: Rep a => ctx a -> ctx [a] -> R1 ctx [a]
instance (Rep a, Sat (ctx a), Sat (ctx [a])) => Rep1 ctx [a]
instance (Rep a, Sat (ctx a), Rep b, Sat (ctx b)) => Rep1 ctx (a, b)
instance Rep1 ctx ()
instance (Rep a, Rep b, Sat (ctx a), Sat (ctx b)) => Rep1 ctx (a :~: b)
instance (Rep a, Rep b, Sat (ctx a), Sat (ctx b)) => Rep1 ctx (a -> b)
instance (Rep a, Sat (ctx a)) => Rep1 ctx (IO a)
instance Rep1 ctx Rational
instance Rep1 ctx IOError
instance Rep1 ctx Double
instance Rep1 ctx Float
instance Rep1 ctx Integer
instance Rep1 ctx Char
instance Rep1 ctx Int
instance Show (R1 c a)


-- | Automatically derive representations and instance declarations for
--   user defined datatypes. The typical use is <tt> $(derive [''MyType1,
--   ''MyType2]) </tt>
module Generics.RepLib.Derive

-- | Generate representations (both basic and parameterized) for a list of
--   types.
derive :: [Name] -> Q [Dec]

-- | Generate abstract representations for a list of types.
derive_abstract :: [Name] -> Q [Dec]
instance Applicative QN
instance Functor QN
instance Monad QN
instance MonadWriter (Set Int) QN
instance Quasi QN


-- | Representations for Prelude types, necessary to (automatically) derive
--   representations of user defined types.
module Generics.RepLib.PreludeReps
rTup7_1 :: (Rep a_12, Rep b_13, Rep c_14, Rep d_15, Rep e_16, Rep f_17, Rep g_18) => (ctx_adfD a_12, ctx_adfD b_13, ctx_adfD c_14, ctx_adfD d_15, ctx_adfD e_16, ctx_adfD f_17, ctx_adfD g_18) -> R1 ctx_adfD ((,,,,,,) a_12 b_13 c_14 d_15 e_16 f_17 g_18)
rTup7 :: (Rep a_12, Rep b_13, Rep c_14, Rep d_15, Rep e_16, Rep f_17, Rep g_18) => R ((,,,,,,) a_12 b_13 c_14 d_15 e_16 f_17 g_18)
rTup6_1 :: (Rep a_12, Rep b_13, Rep c_14, Rep d_15, Rep e_16, Rep f_17) => (ctx_adf5 a_12, ctx_adf5 b_13, ctx_adf5 c_14, ctx_adf5 d_15, ctx_adf5 e_16, ctx_adf5 f_17) -> R1 ctx_adf5 ((,,,,,) a_12 b_13 c_14 d_15 e_16 f_17)
rTup6 :: (Rep a_12, Rep b_13, Rep c_14, Rep d_15, Rep e_16, Rep f_17) => R ((,,,,,) a_12 b_13 c_14 d_15 e_16 f_17)
rTup5_1 :: (Rep a_12, Rep b_13, Rep c_14, Rep d_15, Rep e_16) => (ctx_adeC a_12, ctx_adeC b_13, ctx_adeC c_14, ctx_adeC d_15, ctx_adeC e_16) -> R1 ctx_adeC ((,,,,) a_12 b_13 c_14 d_15 e_16)
rTup5 :: (Rep a_12, Rep b_13, Rep c_14, Rep d_15, Rep e_16) => R ((,,,,) a_12 b_13 c_14 d_15 e_16)
rTup4_1 :: (Rep a_12, Rep b_13, Rep c_14, Rep d_15) => (ctx_adee a_12, ctx_adee b_13, ctx_adee c_14, ctx_adee d_15) -> R1 ctx_adee ((,,,) a_12 b_13 c_14 d_15)
rTup4 :: (Rep a_12, Rep b_13, Rep c_14, Rep d_15) => R ((,,,) a_12 b_13 c_14 d_15)
rTup3_1 :: (Rep a_12, Rep b_13, Rep c_14) => (ctx_addV a_12, ctx_addV b_13, ctx_addV c_14) -> R1 ctx_addV ((,,) a_12 b_13 c_14)
rTup3 :: (Rep a_12, Rep b_13, Rep c_14) => R ((,,) a_12 b_13 c_14)
rOrdering1 :: () -> () -> () -> R1 ctx_addL Ordering
rOrdering :: R Ordering
rEither1 :: (Rep a_adde, Rep b_addf) => ctx_addu a_adde -> ctx_addu b_addf -> R1 ctx_addu (Either a_adde b_addf)
rEither :: (Rep a_adde, Rep b_addf) => R (Either a_adde b_addf)
rMaybe1 :: Rep a_a2IU => () -> ctx_add2 a_a2IU -> R1 ctx_add2 (Maybe a_a2IU)
rMaybe :: Rep a_a2IU => R (Maybe a_a2IU)
rBool1 :: () -> () -> R1 ctx_adcV Bool
rBool :: R Bool
instance (Rep a0, Rep b0, Rep c0, Rep d0, Rep e0, Rep f0, Rep g0, Sat (ctx0 a0), Sat (ctx0 b0), Sat (ctx0 c0), Sat (ctx0 d0), Sat (ctx0 e0), Sat (ctx0 f0), Sat (ctx0 g0)) => Rep1 ctx0 (a0, b0, c0, d0, e0, f0, g0)
instance (Rep a0, Rep b0, Rep c0, Rep d0, Rep e0, Rep f0, Rep g0) => Rep (a0, b0, c0, d0, e0, f0, g0)
instance (Rep a0, Rep b0, Rep c0, Rep d0, Rep e0, Rep f0, Sat (ctx0 a0), Sat (ctx0 b0), Sat (ctx0 c0), Sat (ctx0 d0), Sat (ctx0 e0), Sat (ctx0 f0)) => Rep1 ctx0 (a0, b0, c0, d0, e0, f0)
instance (Rep a0, Rep b0, Rep c0, Rep d0, Rep e0, Rep f0) => Rep (a0, b0, c0, d0, e0, f0)
instance (Rep a0, Rep b0, Rep c0, Rep d0, Rep e0, Sat (ctx0 a0), Sat (ctx0 b0), Sat (ctx0 c0), Sat (ctx0 d0), Sat (ctx0 e0)) => Rep1 ctx0 (a0, b0, c0, d0, e0)
instance (Rep a0, Rep b0, Rep c0, Rep d0, Rep e0) => Rep (a0, b0, c0, d0, e0)
instance (Rep a0, Rep b0, Rep c0, Rep d0, Sat (ctx0 a0), Sat (ctx0 b0), Sat (ctx0 c0), Sat (ctx0 d0)) => Rep1 ctx0 (a0, b0, c0, d0)
instance (Rep a0, Rep b0, Rep c0, Rep d0) => Rep (a0, b0, c0, d0)
instance (Rep a0, Rep b0, Rep c0, Sat (ctx0 a0), Sat (ctx0 b0), Sat (ctx0 c0)) => Rep1 ctx0 (a0, b0, c0)
instance (Rep a0, Rep b0, Rep c0) => Rep (a0, b0, c0)
instance Rep1 ctx0 Ordering
instance Rep Ordering
instance (Rep a0, Rep b0, Sat (ctx0 a0), Sat (ctx0 b0)) => Rep1 ctx0 (Either a0 b0)
instance (Rep a0, Rep b0) => Rep (Either a0 b0)
instance (Rep a0, Sat (ctx0 a0)) => Rep1 ctx0 (Maybe a0)
instance Rep a0 => Rep (Maybe a0)
instance Rep1 ctx0 Bool
instance Rep Bool


-- | Auxiliary operations to aid in the definition of type-indexed
--   functions
module Generics.RepLib.RepAux

-- | Determine if two reps are for the same type
eqR :: R a -> R b -> Bool

-- | The type-safe cast operation, implicit arguments
cast :: (Rep a, Rep b) => a -> Maybe b

-- | The type-safe cast operation, explicit arguments
castR :: R a -> R b -> a -> Maybe b

-- | Leibniz equality between types, implicit representations
gcast :: (Rep a, Rep b) => c a -> Maybe (c b)

-- | Leibniz equality between types, explicit representations
gcastR :: R a -> R b -> c a -> Maybe (c b)

-- | Heterogeneous Ordering
compareR :: R a -> R b -> Ordering

-- | Given a list of constructor representations for a datatype, determine
--   which constructor formed the datatype.
findCon :: [Con ctx a] -> a -> Val ctx a

-- | A datastructure to store the results of findCon
data Val ctx a
Val :: Emb l a -> MTup ctx l -> l -> Val ctx a

-- | A fold left for heterogeneous lists
foldl_l :: (forall a. Rep a => ctx a -> b -> a -> b) -> b -> (MTup ctx l) -> l -> b

-- | A fold right operation for heterogeneous lists, that folds a function
--   expecting a type type representation across each element of the list.
foldr_l :: (forall a. Rep a => ctx a -> a -> b -> b) -> b -> (MTup ctx l) -> l -> b

-- | A map for heterogeneous lists
map_l :: (forall a. Rep a => ctx a -> a -> a) -> (MTup ctx l) -> l -> l

-- | Transform a heterogeneous list in to a standard list
mapQ_l :: (forall a. Rep a => ctx a -> a -> r) -> MTup ctx l -> l -> [r]

-- | mapM for heterogeneous lists
mapM_l :: Monad m => (forall a. Rep a => ctx a -> a -> m a) -> MTup ctx l -> l -> m l

-- | Generate a heterogeneous list from metadata
fromTup :: (forall a. Rep a => ctx a -> a) -> MTup ctx l -> l

-- | Generate a heterogeneous list from metadata, in a monad
fromTupM :: Monad m => (forall a. Rep a => ctx a -> m a) -> MTup ctx l -> m l

-- | Generate a normal lists from metadata
toList :: (forall a. Rep a => ctx a -> b) -> MTup ctx l -> [b]

-- | A SYB style traversal
type Traversal = forall a. Rep a => a -> a

-- | SYB style query type
type Query r = forall a. Rep a => a -> r

-- | SYB style monadic map type
type MapM m = forall a. Rep a => a -> m a

-- | Map a traversal across the kids of a data structure
gmapT :: Rep a => Traversal -> a -> a
gmapQ :: Rep a => Query r -> a -> [r]
gmapM :: (Rep a, Monad m) => MapM m -> a -> m a
type Traversal1 ctx = forall a. Rep a => ctx a -> a -> a
type Query1 ctx r = forall a. Rep a => ctx a -> a -> r
type MapM1 ctx m = forall a. Rep a => ctx a -> a -> m a
gmapT1 :: Rep1 ctx a => Traversal1 ctx -> a -> a
gmapQ1 :: Rep1 ctx a => Query1 ctx r -> a -> [r]
gmapM1 :: (Rep1 ctx a, Monad m) => MapM1 ctx m -> a -> m a
data Typed a
(:::) :: a -> R a -> Typed a
data Spine a
Constr :: a -> Spine a
(:<>) :: Spine (a -> b) -> Typed a -> Spine b
toSpine :: Rep a => a -> Spine a
fromSpine :: Spine a -> a
instance Ord DT
instance Eq DT
instance TestEquality R


module Generics.RepLib.SYB.Aliases

-- | Make a generic transformation; start from a type-specific case;
--   preserve the term otherwise
mkT :: (Rep a, Rep b) => (b -> b) -> a -> a

-- | Make a generic query; start from a type-specific case; return a
--   constant otherwise
mkQ :: (Rep a, Rep b) => r -> (b -> r) -> a -> r

-- | Make a generic monadic transformation; start from a type-specific
--   case; resort to return otherwise
mkM :: (Monad m, Rep a, Rep b) => (b -> m b) -> a -> m a

-- | Make a generic monadic transformation for MonadPlus; use "const mzero"
--   (i.e., failure) instead of return as default.
mkMp :: (MonadPlus m, Rep a, Rep b) => (b -> m b) -> a -> m a

-- | Make a generic builder; start from a type-specific ase; resort to no
--   build (i.e., mzero) otherwise
mkR :: (MonadPlus m, Rep a, Rep b) => m b -> m a

-- | Flexible type extension
ext0 :: (Rep a, Rep b) => c a -> c b -> c a

-- | Extend a generic transformation by a type-specific case
extT :: (Rep a, Rep b) => (a -> a) -> (b -> b) -> a -> a

-- | Extend a generic query by a type-specific case
extQ :: (Rep a, Rep b) => (a -> q) -> (b -> q) -> a -> q

-- | Extend a generic monadic transformation by a type-specific case
extM :: (Monad m, Rep a, Rep b) => (a -> m a) -> (b -> m b) -> a -> m a

-- | Extend a generic MonadPlus transformation by a type-specific case
extMp :: (MonadPlus m, Rep a, Rep b) => (a -> m a) -> (b -> m b) -> a -> m a

-- | Extend a generic builder
extB :: (Rep a, Rep b) => a -> b -> a

-- | Extend a generic reader
extR :: (Monad m, Rep a, Rep b) => m a -> m b -> m a

-- | Generic transformations, i.e., take an "a" and return an "a"
type GenericT = forall a. Rep a => a -> a

-- | Generic queries of type "r", i.e., take any "a" and return an "r"
type GenericQ r = forall a. Rep a => a -> r

-- | Generic monadic transformations, i.e., take an "a" and compute an "a"
type GenericM m = forall a. Rep a => a -> m a

-- | Generic builders i.e., produce an "a".
type GenericB = forall a. Rep a => a

-- | Generic readers, say monadic builders, i.e., produce an "a" with the
--   help of a monad "m".
type GenericR m = forall a. Rep a => m a

-- | The general scheme underlying generic functions assumed by gfoldl;
--   there are isomorphisms such as GenericT = Generic T.
type Generic c = forall a. Rep a => a -> c a

-- | Wrapped generic functions; recall: [Generic c] would be legal but
--   [Generic' c] not.
data Generic' c
Generic' :: Generic c -> Generic' c
unGeneric' :: Generic' c -> Generic c

-- | Other first-class polymorphic wrappers
newtype GenericT'
GT :: (forall a. Rep a => a -> a) -> GenericT'
unGT :: GenericT' -> forall a. Rep a => a -> a
newtype GenericQ' r
GQ :: GenericQ r -> GenericQ' r
unGQ :: GenericQ' r -> GenericQ r
newtype GenericM' m
GM :: (forall a. Rep a => a -> m a) -> GenericM' m
unGM :: GenericM' m -> forall a. Rep a => a -> m a

-- | Left-biased choice on maybies
orElse :: Maybe a -> Maybe a -> Maybe a

-- | Recover from the failure of monadic transformation by identity
recoverMp :: MonadPlus m => GenericM m -> GenericM m

-- | Recover from the failure of monadic query by a constant
recoverQ :: MonadPlus m => r -> GenericQ (m r) -> GenericQ (m r)

-- | Choice for monadic transformations
choiceMp :: MonadPlus m => GenericM m -> GenericM m -> GenericM m

-- | Choice for monadic queries
choiceQ :: MonadPlus m => GenericQ (m r) -> GenericQ (m r) -> GenericQ (m r)


-- | Derived from Data.Generics.Schemes Only modification: <a>Data</a>
--   class becomes <a>Rep</a> class otherwise import our version of the
--   libraries For now, missing "somewhere" (lacking mapMp)
module Generics.RepLib.SYB.Schemes

-- | Apply a transformation everywhere in bottom-up manner
everywhere :: (forall a. Rep a => a -> a) -> (forall a. Rep a => a -> a)

-- | Apply a transformation everywhere in top-down manner
everywhere' :: (forall a. Rep a => a -> a) -> (forall a. Rep a => a -> a)

-- | Variation on everywhere with an extra stop condition
everywhereBut :: GenericQ Bool -> GenericT -> GenericT

-- | Monadic variation on everywhere
everywhereM :: Monad m => GenericM m -> GenericM m

-- | Apply a monadic transformation at least somewhere somewhere ::
--   MonadPlus m =&gt; GenericM m -&gt; GenericM m
--   
--   Summarise all nodes in top-down, left-to-right order
everything :: (r -> r -> r) -> GenericQ r -> GenericQ r

-- | Get a list of all entities that meet a predicate
listify :: Rep r => (r -> Bool) -> GenericQ [r]

-- | Look up a subterm by means of a maybe-typed filter
something :: GenericQ (Maybe u) -> GenericQ (Maybe u)

-- | Bottom-up synthesis of a data structure; 1st argument z is the initial
--   element for the synthesis; 2nd argument o is for reduction of results
--   from subterms; 3rd argument f updates the synthesised data according
--   to the given term
synthesize :: s -> (s -> s -> s) -> GenericQ (s -> s) -> GenericQ s

-- | Compute size of an arbitrary data structure
gsize :: Rep a => a -> Int

-- | Count the number of immediate subterms of the given term
glength :: GenericQ Int

-- | Determine depth of the given term
gdepth :: GenericQ Int

-- | Determine the number of all suitable nodes in a given term
gcount :: GenericQ Bool -> GenericQ Int

-- | Determine the number of all nodes in a given term
gnodecount :: GenericQ Int

-- | Determine the number of nodes of a given type in a given term
gtypecount :: Rep a => a -> GenericQ Int

-- | Find (unambiguously) an immediate subterm of a given type
gfindtype :: (Rep x, Rep y) => x -> Maybe y


-- | The module PreludeLib contains generic operations to derive members of
--   the standard prelude classess: Eq, Bounded, Compare, Show (TODO: add
--   Enum and Read)
--   
--   Although these classes may already be automatically derived via the
--   "deriving" mechanism, this module is included for two reasons:
--   
--   <ul>
--   <li>Deriving only works when datatypes are defined. This library
--   allows instances of these classes to be generated anywhere. For
--   example, suppose some other module contains the definition of the
--   datatype T and exposes all of its constructors, but, frustratingly,
--   does not derive an instance of the Show class.</li>
--   </ul>
--   
--   You could define a Show instance of <tt>T</tt> in your own module with
--   the following code:
--   
--   <pre>
--   import RepLib
--   
--   (repr1 ''T)  -- make the Rep1 instance of T available
--   
--   instance Show T where
--     showsPrec = showsPrecR1 rep1   -- showsPrecR1 is defined in this module
--   </pre>
--   
--   <ul>
--   <li>This library also serves as a model for generic functions that are
--   slight modifications to these prelude operations. For example, if you
--   wanted to define reverse lexicographic ordering or an XML pretty
--   printer for datatypes, you might start here. This library is also a
--   good place to start learning how to define your own generic
--   operations, because the behavior of these operations should match the
--   deriving mechanism specified by Haskell 98.</li>
--   </ul>
module Generics.RepLib.PreludeLib
data EqD a

-- | Polymorphic equality, given an R1 representation
eqR1 :: R1 EqD a -> a -> a -> Bool
data OrdD a

-- | Minimal completion of the Ord class
compareR1 :: R1 OrdD a -> a -> a -> Ordering
data BoundedD a

-- | To generate the Bounded class
minBoundR1 :: R1 BoundedD a -> a

-- | To generate the Bounded class
maxBoundR1 :: R1 BoundedD a -> a
data ShowD a

-- | Minimal completion of the show class
showsPrecR1 :: R1 ShowD a -> Int -> a -> ShowS
instance Show a => Sat (ShowD a)
instance Bounded a => Sat (BoundedD a)
instance Ord a => Sat (OrdD a)
instance Eq a => Sat (EqD a)


-- | Abstract Reps for Common Abstract Datatypes
module Generics.RepLib.AbstractReps
rSet1 :: Rep a_a6AF => R1 ctx_ajyF (Set a_a6AF)
rSet :: Rep a_a6AF => R (Set a_a6AF)
rMap1 :: (Rep k_ajyb, Rep a_ajyc) => R1 ctx_ajyr (Map k_ajyb a_ajyc)
rMap :: (Rep k_ajyb, Rep a_ajyc) => R (Map k_ajyb a_ajyc)
instance Rep a0 => Rep1 ctx0 (Set a0)
instance Rep a0 => Rep (Set a0)
instance (Rep k0, Rep a0) => Rep1 ctx0 (Map k0 a0)
instance (Rep k0, Rep a0) => Rep (Map k0 a0)


-- | A library of type-indexed functions
module Generics.RepLib.Lib

-- | Produce all children of a datastructure with the same type. Note that
--   subtrees is available for all representable types. For those that are
--   not recursive datatypes, subtrees will always return the empty list.
--   But, these trivial instances are convenient to have for the Shrink
--   operation below.
subtrees :: Rep a => a -> [a]

-- | Recursively force the evaluation of the first argument. For example,
--   <tt> deepSeq ( x , y ) z where x = ... y = ... </tt> will evaluate
--   both <tt>x</tt> and <tt>y</tt> then return <tt>z</tt>
deepSeq :: Rep a => a -> b -> b

-- | Force the evaluation of *datatypes* to their normal forms. Other types
--   are left alone and not forced.
rnf :: Rep a => a -> a

-- | Add together all of the <tt>Int</tt>s in a datastructure For example:
--   gsum ( 1 , True, ("a", Maybe 3, []) , Nothing) 4
class Rep1 GSumD a => GSum a where gsum = gsumR1 rep1
gsum :: GSum a => a -> Int

-- | Create a zero element of a type <tt> ( zero :: ((Int, Maybe Int),
--   Float)) ((0, Nothing), 0.0) </tt>
class Rep1 ZeroD a => Zero a where zero = zeroR1 rep1
zero :: Zero a => a

-- | Generate elements of a type up to a certain depth
class Rep1 GenerateD a => Generate a where generate = generateR1 rep1
generate :: Generate a => Int -> [a]

-- | enumerate the elements of a type, in DFS order.
class Rep1 EnumerateD a => Enumerate a where enumerate = enumerateR1 rep1
enumerate :: Enumerate a => [a]

-- | Given an element, return smaller elements of the same type for
--   example, to automatically find small counterexamples when testing
class Rep1 ShrinkD a => Shrink a where shrink a = subtrees a ++ shrinkStep a where shrinkStep _t = let M _ ts = gmapM1 m a in ts m :: forall b. ShrinkD b -> b -> M b m d x = M x (shrinkD d x)
shrink :: Shrink a => a -> [a]

-- | A general version of fold left, use for Fold class below
class Rep1 (LreduceD b) a => Lreduce b a where lreduce = lreduceR1 rep1
lreduce :: Lreduce b a => b -> a -> b

-- | A general version of fold right, use for Fold class below
class Rep1 (RreduceD b) a => Rreduce b a where rreduce = rreduceR1 rep1
rreduce :: Rreduce b a => a -> b -> b

-- | All of the functions below are defined using instances of the
--   following class
class Fold f
foldRight :: (Fold f, Rep a) => (a -> b -> b) -> f a -> b -> b
foldLeft :: (Fold f, Rep a) => (b -> a -> b) -> b -> f a -> b

-- | Fold a bindary operation left over a datastructure
crush :: (Rep a, Fold t) => (a -> a -> a) -> a -> t a -> a

-- | Multiply all elements together
gproduct :: (Rep a, Num a, Fold t) => t a -> a

-- | Ensure all booleans are true
gand :: Fold t => t Bool -> Bool

-- | Ensure at least one boolean is true
gor :: Fold t => t Bool -> Bool

-- | Convert to list
flatten :: (Rep a, Fold t) => t a -> [a]

-- | Count number of <tt>a</tt>s that appear in the argument
count :: (Rep a, Fold t) => t a -> Int

-- | Compose all functions in the datastructure together
comp :: (Rep a, Fold t) => t (a -> a) -> a -> a

-- | Concatenate all lists in the datastructure together
gconcat :: (Rep a, Fold t) => t [a] -> [a]

-- | Ensure property holds of all data
gall :: (Rep a, Fold t) => (a -> Bool) -> t a -> Bool

-- | Ensure property holds of some element
gany :: (Rep a, Fold t) => (a -> Bool) -> t a -> Bool

-- | Is an element stored in a datastructure
gelem :: (Rep a, Eq a, Fold t) => a -> t a -> Bool
data GSumD a
GSumD :: (a -> Int) -> GSumD a
gsumD :: GSumD a -> a -> Int
data ZeroD a
ZD :: a -> ZeroD a
zeroD :: ZeroD a -> a
data GenerateD a
GenerateD :: (Int -> [a]) -> GenerateD a
generateD :: GenerateD a -> Int -> [a]
data EnumerateD a
EnumerateD :: [a] -> EnumerateD a
enumerateD :: EnumerateD a -> [a]
data ShrinkD a
ShrinkD :: (a -> [a]) -> ShrinkD a
shrinkD :: ShrinkD a -> a -> [a]
data LreduceD b a
LreduceD :: (b -> a -> b) -> LreduceD b a
lreduceD :: LreduceD b a -> b -> a -> b
data RreduceD b a
RreduceD :: (a -> b -> b) -> RreduceD b a
rreduceD :: RreduceD b a -> a -> b -> b
rnfR :: R a -> a -> a
deepSeqR :: R a -> a -> b -> b
gsumR1 :: R1 GSumD a -> a -> Int
zeroR1 :: R1 ZeroD a -> a
generateR1 :: R1 GenerateD a -> Int -> [a]
enumerateR1 :: R1 EnumerateD a -> [a]
lreduceR1 :: R1 (LreduceD b) a -> b -> a -> b
rreduceR1 :: R1 (RreduceD b) a -> a -> b -> b
instance Fold (Map k)
instance Fold Set
instance Fold []
instance (Ord a, Rreduce b a) => Rreduce b (Set a)
instance Rreduce c a => Rreduce c [a]
instance (Rreduce c a, Rreduce c b) => Rreduce c (a, b)
instance Rreduce b Bool
instance Rreduce b Char
instance Rreduce b ()
instance Rreduce b Int
instance (Ord a, Lreduce b a) => Lreduce b (Set a)
instance Lreduce c a => Lreduce c [a]
instance (Lreduce c a, Lreduce c b) => Lreduce c (a, b)
instance Lreduce b Bool
instance Lreduce b Char
instance Lreduce b ()
instance Lreduce b Int
instance Lreduce b a => Sat (LreduceD b a)
instance Rreduce b a => Sat (RreduceD b a)
instance (Ord k, Shrink k, Shrink a) => Shrink (Map k a)
instance (Ord a, Shrink a) => Shrink (Set a)
instance (Shrink a, Shrink b) => Shrink (a, b)
instance Shrink ()
instance Shrink Char
instance Shrink a => Shrink [a]
instance Shrink Int
instance Monad M
instance Applicative M
instance Functor M
instance Shrink a => Sat (ShrinkD a)
instance (Ord k, Enumerate k, Enumerate a) => Enumerate (Map k a)
instance (Ord a, Enumerate a) => Enumerate (Set a)
instance Enumerate a => Enumerate [a]
instance (Enumerate a, Enumerate b) => Enumerate (a, b)
instance Enumerate ()
instance Enumerate Bool
instance Enumerate Double
instance Enumerate Float
instance Enumerate Integer
instance Enumerate Char
instance Enumerate Int
instance Enumerate a => Sat (EnumerateD a)
instance (Ord k, Generate k, Generate a) => Generate (Map k a)
instance (Ord a, Generate a) => Generate (Set a)
instance Generate a => Generate [a]
instance (Generate a, Generate b) => Generate (a, b)
instance Generate ()
instance Generate Double
instance Generate Float
instance Generate Integer
instance Generate Char
instance Generate Int
instance Generate a => Sat (GenerateD a)
instance Rep a => Zero (Set a)
instance (Rep k, Rep a) => Zero (Map k a)
instance Zero a => Zero [a]
instance (Zero a, Zero b) => Zero (a, b)
instance Zero Bool
instance Zero ()
instance Zero IOError
instance Zero Double
instance Zero Float
instance Zero Integer
instance (Zero a, Zero b) => Zero (a -> b)
instance Zero Char
instance Zero Int
instance Zero a => Sat (ZeroD a)
instance GSum a => GSum (Set a)
instance (Rep k, GSum a) => GSum (Map k a)
instance GSum a => GSum [a]
instance (GSum a, GSum b) => GSum (a, b)
instance GSum Double
instance GSum Char
instance GSum Integer
instance GSum ()
instance GSum Bool
instance GSum Int
instance GSum Float
instance GSum a => Sat (GSumD a)

module Generics.RepLib.Unify
data Proxy a
type UnifyError = String
type UM n a b = ErrorT UnifyError (State (UnificationState n a)) b
data UnifySubD n a b
UnifySubD :: (Proxy (n, a) -> b -> b -> UM n a ()) -> (n -> a -> b -> b) -> (n -> Proxy a -> b -> Bool) -> UnifySubD n a b
unifyStepD :: UnifySubD n a b -> Proxy (n, a) -> b -> b -> UM n a ()
substD :: UnifySubD n a b -> n -> a -> b -> b
occursCheckD :: UnifySubD n a b -> n -> Proxy a -> b -> Bool
data UConstraint n a
UC :: (UnifySubD n a b) -> b -> b -> UConstraint n a
data UnificationState n a
UState :: [UConstraint n a] -> [(n, a)] -> UnificationState n a
uConstraints :: UnificationState n a -> [UConstraint n a]
uSubst :: UnificationState n a -> [(n, a)]
class (Eq n, Show n, Show a, Show b, HasVar n a) => Unify n a b
unifyStep :: Unify n a b => Proxy (n, a) -> b -> b -> UM n a ()

-- | Generic unifyStep. almost identical to polymorphic equality
unifyStepR1 :: (Eq n, Show n, Show a, Show b, HasVar n a) => R1 (UnifySubD n a) b -> Proxy (n, a) -> b -> b -> UM n a ()
addConstraintsRL1 :: MTup (UnifySubD n a) l -> Proxy (n, a) -> l -> l -> UM n a ()
unifyStepEq :: (Eq b, Show b) => b -> b -> UM n a ()
dequeueConstraint :: UM n a (Maybe (UConstraint n a))
queueConstraint :: UConstraint n a -> UM n a ()
extendSubstitution :: (HasVar n a, Eq n, Show n, Show a, Rep1 (UnifySubD n a) a) => (n, a) -> UM n a ()
solveUnification :: (HasVar n a, Eq n, Show n, Show a, Rep1 (UnifySubD n a) a) => [(a, a)] -> Maybe [(n, a)]
solveUnification' :: (HasVar n a, Eq n, Show n, Show a, Show b, Rep1 (UnifySubD n a) b) => Proxy (n, a) -> [(b, b)] -> Maybe [(n, a)]
class HasVar a b
is_var :: HasVar a b => b -> Maybe a
var :: HasVar a b => a -> b
class Subst a t t'
subst :: Subst a t t' => a -> t -> t' -> t'
substR1 :: Rep1 (UnifySubD a t) t' => R1 (UnifySubD a t) t' -> a -> t -> t' -> t'
class Occurs n a b
occursCheck :: Occurs n a b => n -> Proxy a -> b -> Bool
occursCheckR1 :: Rep1 (UnifySubD n a) b => R1 (UnifySubD n a) b -> n -> Proxy a -> b -> Bool
instance [incoherent] (Eq n, HasVar n a, Rep1 (UnifySubD n a) a) => Occurs n a a
instance [incoherent] Rep1 (UnifySubD n a) b => Occurs n a b
instance [incoherent] (Eq a, HasVar a t, Rep1 (UnifySubD a t) t) => Subst a t t
instance [incoherent] Rep1 (UnifySubD a t) t' => Subst a t t'
instance [incoherent] (Eq n, Show n, Show a, HasVar n a, Rep1 (UnifySubD n a) a) => Unify n a a
instance [incoherent] (Eq n, Show n, Show a, Show b, HasVar n a, Rep1 (UnifySubD n a) b) => Unify n a b
instance [incoherent] (Unify n a b, Subst n a b, Occurs n a b) => Sat (UnifySubD n a b)


module Generics.RepLib

-- | Propositional equality. If <tt>a :~: b</tt> is inhabited by some
--   terminating value, then the type <tt>a</tt> is the same as the type
--   <tt>b</tt>. To use this equality in practice, pattern-match on the
--   <tt>a :~: b</tt> to get out the <tt>Refl</tt> constructor; in the body
--   of the pattern-match, the compiler knows that <tt>a ~ b</tt>.
--   
--   <i>Since: 4.7.0.0</i>
data (:~:) (a :: k) (b :: k) :: k -> k -> *
Refl :: (:~:) k a1 a1

-- | This class contains types where you can learn the equality of two
--   types from information contained in <i>terms</i>. Typically, only
--   singleton types should inhabit this class.
class TestEquality (f :: k -> *)
testEquality :: TestEquality f => f a -> f b -> Maybe ((:~:) k a b)
