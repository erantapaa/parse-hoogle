-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An interactive terminal user interface library for Vty
--   
@package vty-ui
@version 1.9


-- | This module provides a type and a type class for expressing alignment.
--   For concrete uses, see the Table and ProgressBar modules.
module Graphics.Vty.Widgets.Alignment

-- | Column alignment values.
data Alignment
AlignCenter :: Alignment
AlignLeft :: Alignment
AlignRight :: Alignment

-- | The class of types whose values or contents can be aligned.
class Alignable a
align :: Alignable a => a -> Alignment -> a
instance Show Alignment


-- | This module provides infrastructure for widgets that need to produce
--   events and provide event handler registration functionality.
module Graphics.Vty.Widgets.Events

-- | The type of event handler collections of parameter type <tt>a</tt>.
data Handlers a

-- | The type of event handlers which take a parameter of type <tt>a</tt>.
type Handler a = a -> IO ()

-- | Create a new event handler collection.
newHandlers :: IO (Handlers a)

-- | Given an event handler collection projection combinator, a target, and
--   a handler, add the handler to the target's event handler collection.
addHandler :: (w -> IO (Handlers a)) -> w -> Handler a -> IO ()

-- | Fire an event by extracting an event handler collection from a target
--   and invoking all of its handlers with the specified parameter value.
fireEvent :: w -> (w -> IO (Handlers a)) -> a -> IO ()


-- | This module provides ''skins'' for line-drawing widgets such as
--   borders. Different skins may be suitable for terminals with different
--   capabilities, but they are provided for greatest flexibility. Unicode
--   skins must be used with care, as not all terminals support unicode
--   characters (but most do, these days).
module Graphics.Vty.Widgets.Skins
data Skin
Skin :: Char -> Char -> Char -> Char -> Char -> Char -> Char -> Char -> Char -> Char -> Char -> Skin
skinCornerTL :: Skin -> Char
skinCornerTR :: Skin -> Char
skinCornerBR :: Skin -> Char
skinCornerBL :: Skin -> Char
skinIntersectionFull :: Skin -> Char
skinIntersectionL :: Skin -> Char
skinIntersectionR :: Skin -> Char
skinIntersectionT :: Skin -> Char
skinIntersectionB :: Skin -> Char
skinHorizontal :: Skin -> Char
skinVertical :: Skin -> Char

-- | An ASCII skin which will work in any terminal.
asciiSkin :: Skin
unicodeSkin :: Skin
unicodeBoldSkin :: Skin
unicodeRoundedSkin :: Skin

module Graphics.Vty.Widgets.Util

-- | Infix attribute constructor. Use: foregroundColor <a>on</a>
--   backgroundColor.
on :: Color -> Color -> Attr

-- | Foreground-only attribute constructor. Background color and style are
--   defaulted.
fgColor :: Color -> Attr

-- | Background-only attribute constructor. Foreground color and style are
--   defaulted.
bgColor :: Color -> Attr

-- | Style-only attribute constructor. Colors are defaulted.
style :: Style -> Attr

-- | Merge two attributes. Leftmost attribute takes precedence where it
--   specifies any of the foreground color, background color, or style.
--   Note that the style precedence is total: all bits of the style mask
--   will take precedence if any are set.
mergeAttr :: Attr -> Attr -> Attr

-- | List fold version of <a>mergeAttr</a>.
mergeAttrs :: [Attr] -> Attr

-- | Modify the width component of a <a>DisplayRegion</a>.
withWidth :: DisplayRegion -> Int -> DisplayRegion

-- | Modify the height component of a <a>DisplayRegion</a>.
withHeight :: DisplayRegion -> Int -> DisplayRegion

-- | Modify the width component of a <a>DisplayRegion</a>.
plusWidth :: DisplayRegion -> Int -> DisplayRegion

-- | Modify the height component of a <a>DisplayRegion</a>.
plusHeight :: DisplayRegion -> Int -> DisplayRegion
remove :: Int -> [a] -> [a]
inject :: Int -> a -> [a] -> [a]
repl :: Int -> a -> [a] -> [a]
takeMaxText :: Phys -> Text -> Text
takeMaxChars :: Phys -> [Char] -> [Char]
chWidth :: Char -> Phys
strWidth :: String -> Phys
textWidth :: Text -> Phys
regionWidth :: DisplayRegion -> Int
regionHeight :: DisplayRegion -> Int
newtype Phys
Phys :: Int -> Phys
instance Num Phys
instance Eq Phys
instance Show Phys
instance Ord Phys
instance Integral Phys
instance Enum Phys
instance Real Phys


-- | This module provides functionality for tokenizing text streams to
--   differentiate between printed characters and structural elements such
--   as newlines. Once tokenized, such text streams can be manipulated with
--   the functions in this module.
module Text.Trans.Tokenize

-- | A text stream is a list of text stream entities. A text stream
--   |combines structural elements of the text (e.g., newlines) with the
--   |text itself (words, whitespace, etc.).
data TextStream a
TS :: ![TextStreamEntity a] -> TextStream a

-- | A text stream entity is either a token or a structural element.
data TextStreamEntity a

-- | Constructor for ordinary tokens.
T :: !(Token a) -> TextStreamEntity a

-- | Newline.
NL :: TextStreamEntity a

-- | The type of text tokens. These should consist of printable characters
--   and NOT presentation characters (e.g., newlines). Each type of token
--   should have as its contents a string of characters all of the same
--   type. Tokens are generalized over an attribute type which can be used
--   to annotate each token.
data Token a

-- | Non-whitespace tokens.
S :: !Text -> !a -> Token a

-- | The token's string.
tokenStr :: Token a -> !Text

-- | The token's attribute.
tokenAttr :: Token a -> !a

-- | Whitespace tokens.
WS :: !Text -> !a -> Token a

-- | The token's string.
tokenStr :: Token a -> !Text

-- | The token's attribute.
tokenAttr :: Token a -> !a

-- | Tokenize a string and apply a default attribute to every token in the
--   resulting text stream.
tokenize :: Text -> a -> TextStream a

-- | Given a text stream, serialize the stream to its original textual
--   representation. This discards token attribute metadata.
serialize :: TextStream a -> Text

-- | Get the length of a token's string.
tokenLen :: Token a -> Int

-- | Gets a <a>Token</a> from an entity or raises an exception if the
--   entity does not contain a token. Used primarily for convenience
--   transformations in which the parameter is known to be a token entity.
entityToken :: TextStreamEntity a -> Token a

-- | Get the entities in a stream.
streamEntities :: TextStream a -> [TextStreamEntity a]

-- | Given a list of tokens, truncate the list so that its underlying
--   string representation does not exceed the specified column width.
truncateLine :: Phys -> [Token a] -> [Token a]

-- | Same as <a>truncateLine</a> but for <tt>Text</tt> values.
truncateText :: Phys -> Text -> Text

-- | Given a text stream and a wrapping width, return a new
--   <a>TextStream</a> with newlines inserted in appropriate places to wrap
--   the text at the specified column (not character position).
--   
--   This function results in text wrapped without leading or trailing
--   whitespace on wrapped lines, although it preserves leading whitespace
--   in the text which was not the cause of the wrapping transformation.
wrapStream :: Eq a => Phys -> TextStream a -> TextStream a

-- | Given a list of text stream entities, split up the list wherever
--   newlines occur. Returns a list of lines of entities, such that all
--   entities wrap tokens and none are newlines. (Safe for use with
--   <a>entityToken</a>.)
findLines :: [TextStreamEntity a] -> [[TextStreamEntity a]]
instance Eq a => Eq (TextStream a)
instance Eq a => Eq (TextStreamEntity a)
instance Eq a => Eq (Token a)
instance Show a => Show (Token a)
instance Show a => Show (TextStreamEntity a)
instance Show a => Show (TextStream a)


-- | This module provides a two-dimensional text zipper data structure.
--   This structure represents a body of text and an editing cursor which
--   can be moved throughout the text, along with a set of editing
--   transformations.
--   
--   Text zippers are generalized over the set of data types that might be
--   used to store lists of characters (e.g., <a>String</a>, <a>Text</a>,
--   etc.). As a result, the most general way to create a text zipper is to
--   use <a>mkZipper</a> and provide all of the functions required to
--   manipulate the underlying text data.
--   
--   A default implementation using <a>Text</a> is provided and is used
--   elsewhere in this library.
module Graphics.Vty.Widgets.TextZipper
data TextZipper a

-- | Create a zipper using a custom text storage type. Takes the initial
--   text as well as all of the functions necessary to manipulate the
--   underlying text values.
mkZipper :: Monoid a => (Char -> a) -> (Int -> a -> a) -> (Int -> a -> a) -> (a -> Int) -> (a -> Char) -> (a -> a) -> (a -> Bool) -> [a] -> TextZipper a

-- | Construct a zipper from <a>Text</a> values.
textZipper :: [Text] -> TextZipper Text

-- | Get the text contents of the zipper.
getText :: Monoid a => TextZipper a -> [a]

-- | The line of text on which the zipper's cursor currently resides.
currentLine :: Monoid a => TextZipper a -> a

-- | Get the cursor position of the zipper; returns <tt>(row, col)</tt>.
--   <tt>row</tt> ranges from <tt>[0..num_rows-1]</tt> inclusive;
--   <tt>col</tt> ranges from <tt>[0..length of current line]</tt>
--   inclusive. Column values equal to line width indicate a cursor that is
--   just past the end of a line of text.
cursorPosition :: TextZipper a -> (Int, Int)

-- | Return the lengths of the lines in the zipper.
lineLengths :: Monoid a => TextZipper a -> [Int]

-- | Move the cursor to the specified row and column. Invalid cursor
--   positions will be ignored. Valid cursor positions range as described
--   for <a>cursorPosition</a>.
moveCursor :: Monoid a => (Int, Int) -> TextZipper a -> TextZipper a

-- | Insert a character at the current cursor position. Move the cursor one
--   position to the right.
insertChar :: Monoid a => Char -> TextZipper a -> TextZipper a

-- | Insert a line break at the current cursor position.
breakLine :: Monoid a => TextZipper a -> TextZipper a

-- | Remove all text from the cursor position to the end of the current
--   line. If the cursor is at the beginning of a line and the line is
--   empty, the entire line will be removed.
killToEOL :: Monoid a => TextZipper a -> TextZipper a

-- | Move the cursor to the end of the current line.
gotoEOL :: Monoid a => TextZipper a -> TextZipper a

-- | Move the cursor to the beginning of the current line.
gotoBOL :: Monoid a => TextZipper a -> TextZipper a

-- | Delete the character preceding the cursor position, and move the
--   cursor backwards by one character.
deletePrevChar :: (Eq a, Monoid a) => TextZipper a -> TextZipper a

-- | Delete the character at the cursor position. Leaves the cursor
--   position unchanged. If the cursor is at the end of a line of text,
--   this combines the line with the line below.
deleteChar :: Monoid a => TextZipper a -> TextZipper a

-- | Move the cursor right by one position. If the cursor is at the end of
--   a line, the cursor is moved to the first position of the following
--   line (if any).
moveRight :: Monoid a => TextZipper a -> TextZipper a

-- | Move the cursor left by one position. If the cursor is at the
--   beginning of a line, the cursor is moved to the last position of the
--   preceding line (if any).
moveLeft :: Monoid a => TextZipper a -> TextZipper a

-- | Move the cursor up by one row. If there no are rows above the current
--   one, move to the first position of the current row. If the row above
--   is shorter, move to the end of that row.
moveUp :: Monoid a => TextZipper a -> TextZipper a

-- | Move the cursor down by one row. If there are no rows below the
--   current one, move to the last position of the current row. If the row
--   below is shorter, move to the end of that row.
moveDown :: Monoid a => TextZipper a -> TextZipper a
instance Show a => Show (TextZipper a)
instance Eq a => Eq (TextZipper a)


-- | This module provides "text clipping" routines. These routines are
--   responsible for ensuring that logical characters are clipped properly
--   when being laid out in a given physical region. This is a bit tricky
--   because some Unicode characters use two terminal columns and others
--   (most) use one. We have to take this into account when truncating text
--   to fit into rendering regions, so we concentrate that logic here under
--   the name of a "clipping rectangle" and functions to apply it.
--   
--   Clipping functionality is provided in two forms: one- and
--   two-dimensional clipping. The former is useful for clipping a single
--   line of text at a given offset and up to a given width. The latter is
--   useful for clipping a list of lines with respect to a 2-D clipping
--   rectangle.
module Graphics.Vty.Widgets.TextClip

-- | The type of clipping rectangles for 2-D clipping operations. All
--   values are <a>Phys</a> values to indicate that we are dealing
--   explicitly with physical column measurements rather than logical
--   character positions.
data ClipRect
ClipRect :: Phys -> Phys -> Phys -> Phys -> ClipRect

-- | The left margin of the clipping rectangle.
clipLeft :: ClipRect -> Phys

-- | The top row of the clipping rectangle.
clipTop :: ClipRect -> Phys

-- | The width, in columns, of the clipping rectangle.
clipWidth :: ClipRect -> Phys

-- | The height, in rows, of the clipping rectangle.
clipHeight :: ClipRect -> Phys

-- | One-dimensional text clipping. Takes the left clipping margin, a
--   clipping width, and a text string. For example, <tt>clip1d n w s</tt>
--   clips the string <tt>s</tt> so that the result includes characters in
--   <tt>s</tt> starting at position <tt>n</tt> and including characters
--   using no more than <tt>w</tt> columns in width. Returns the clipped
--   text plus <a>Bool</a>s indicating whether wide characters were
--   "sliced" on either side (left and right, respectively) of the clipping
--   region. This function guarantees that the text returned will always
--   fit within the specified clipping region. Since wide characters may be
--   sliced during clipping, this may return a text string smaller than the
--   clipping region.
clip1d :: Phys -> Phys -> Text -> (Text, Bool, Bool)

-- | Two-dimensional text clipping. Returns clipping data for each line as
--   returned by <a>clip1d</a>, with the added behavior that it returns at
--   most <a>clipHeight</a> lines of text and uses <a>clipTop</a> as the
--   offset when clipping rows.
clip2d :: ClipRect -> [Text] -> [(Text, Bool, Bool)]

-- | Given a physical point and a clipping rectangle, adjust the clipping
--   rectangle so that the point falls just inside the rectangle. If the
--   point is already within the rectangle, return the rectangle
--   unmodified. NB: this assumes that the physical position given has
--   passed whatever validation checks are relevant for the user of the
--   <a>ClipRect</a>. This function just performs a rectangle
--   transformation.
updateRect :: (Phys, Phys) -> ClipRect -> ClipRect
instance Eq ClipRect
instance Show ClipRect


-- | This module is the core of this library; it provides infrastructure
--   for creating new types of widgets and extending their functionality.
--   This module provides various bits of infrastructure, including:
--   
--   <ul>
--   <li>modeling user interface widgets</li>
--   <li>managing changes in focus between widgets</li>
--   <li>managing widget state</li>
--   </ul>
--   
--   This module does not provide any concrete widget types. For in-depth
--   discussion on this module's API and widget implementation in
--   particular, see the Vty-ui User's Manual.
module Graphics.Vty.Widgets.Core

-- | The type of widget implementations, parameterized on the type of the
--   widget's state.
data WidgetImpl a
WidgetImpl :: !a -> !Bool -> !(Widget a -> DisplayRegion -> RenderContext -> IO Image) -> !(a -> IO Bool) -> !(a -> IO Bool) -> !DisplayRegion -> !DisplayRegion -> !Attr -> !Attr -> !(Widget a -> DisplayRegion -> IO ()) -> !(Widget a -> Key -> [Modifier] -> IO Bool) -> !(Handlers (Widget a)) -> !(Handlers (DisplayRegion, DisplayRegion)) -> !(Handlers (Widget a)) -> !Bool -> !(Widget a -> IO (Maybe DisplayRegion)) -> WidgetImpl a

-- | The state of the widget.
state :: WidgetImpl a -> !a

-- | Whether the widget is visible.
visible :: WidgetImpl a -> !Bool

-- | The rendering routine of the widget. Takes the widget itself, a region
--   indicating how much space the rendering process has to work with, and
--   a rendering context to be used to determine attribute and skin
--   settings. This MUST return an image which is no larger than the
--   specified rendering region.
render_ :: WidgetImpl a -> !(Widget a -> DisplayRegion -> RenderContext -> IO Image)

-- | Returns whether the widget will automatically grow to fill available
--   horizontal space.
growHorizontal_ :: WidgetImpl a -> !(a -> IO Bool)

-- | Returns whether the widget will automatically grow to fill available
--   vertical space.
growVertical_ :: WidgetImpl a -> !(a -> IO Bool)

-- | The size of the widget after its most recent rendering pass.
currentSize :: WidgetImpl a -> !DisplayRegion

-- | The position of the widget after its most recent rendering pass.
currentPosition :: WidgetImpl a -> !DisplayRegion

-- | The normal (unfocused) attribute of the wiget.
normalAttribute :: WidgetImpl a -> !Attr

-- | The focused attribute of the widget.
focusAttribute :: WidgetImpl a -> !Attr

-- | Sets the current position of the widget. Takes a widget reference and
--   a display region indicating the coordinates of the widget's upper left
--   corner.
setCurrentPosition_ :: WidgetImpl a -> !(Widget a -> DisplayRegion -> IO ())

-- | The widget's key event handler. Takes a widget reference, a key event,
--   and a list of keyboard modifiers. Returns whether the keyboard event
--   was handled. True indicates that the event was handled and that event
--   processing should halt; False indicates that other event handlers, if
--   present, may handle the event.
keyEventHandler :: WidgetImpl a -> !(Widget a -> Key -> [Modifier] -> IO Bool)

-- | List of handlers to be invoked when the widget gains focus.
gainFocusHandlers :: WidgetImpl a -> !(Handlers (Widget a))

-- | List of handlers to be invoked when the widget's size changes.
resizeHandlers :: WidgetImpl a -> !(Handlers (DisplayRegion, DisplayRegion))

-- | List of handlers to be invoked when the widget loses focus.
loseFocusHandlers :: WidgetImpl a -> !(Handlers (Widget a))

-- | Whether the widget is focused.
focused :: WidgetImpl a -> !Bool

-- | Returns the current terminal cursor position. Should return Nothing if
--   the widget does not need to show a cursor, or Just if it does. (For
--   example, widgets receiving keyboard input for text editing would
--   should a cursor, but most won't need to.)
getCursorPosition_ :: WidgetImpl a -> !(Widget a -> IO (Maybe DisplayRegion))
type Widget a = IORef (WidgetImpl a)

-- | Get the normal attribute of a rendering context.
getNormalAttr :: RenderContext -> Attr

-- | Default context settings.
defaultContext :: RenderContext

-- | Given a widget and an implementation transformer, apply the
--   transformer to the widget's implementation.
updateWidget :: Widget a -> (WidgetImpl a -> WidgetImpl a) -> IO ()

-- | Apply a state transformation function to a widget's state.
updateWidgetState :: Widget a -> (a -> a) -> IO ()

-- | Create a new widget. Takes an initial state value and a widget
--   implementation transformation and passes it an implementation with
--   default values.
newWidget :: a -> (WidgetImpl a -> WidgetImpl a) -> IO (Widget a)

-- | Get the state value of a widget.
getState :: Widget a -> IO a

-- | Get the current size of the widget (its size after its most recent
--   rendering).
getCurrentSize :: Widget a -> IO DisplayRegion

-- | Set the current position of a widget. Exported for internal use.
setCurrentPosition :: Widget a -> DisplayRegion -> IO ()

-- | Set the current position of a widget.
getCurrentPosition :: Widget a -> IO DisplayRegion

-- | Does a widget grow vertically?
growVertical :: Widget a -> IO Bool

-- | Does a widget grow horizontally?
growHorizontal :: Widget a -> IO Bool

-- | Get the desired cursor position, if any, for a widget.
getCursorPosition :: Widget a -> IO (Maybe DisplayRegion)

-- | Show a widget. Most widget show instances aren't going to contain all
--   of the widget state, but this at least gives an indication of the
--   widget type, which can be crucial for debugging.
showWidget :: Show a => Widget a -> IO String

-- | Get the visibility of a widget.
getVisible :: Widget a -> IO Bool

-- | Set the visibility of a widget. Invisible widgets do not grow in
--   either direction, always render to an empty image, and never declare a
--   cursor position.
setVisible :: Widget a -> Bool -> IO ()

-- | Convenience projection on the contents of an <a>IORef</a>.
(<~) :: (a -> b) -> IORef a -> IO b

-- | Convenience projection on the state of a widget.
(<~~) :: (a -> b) -> Widget a -> IO b

-- | Context information used during the rendering process.
data RenderContext
RenderContext :: Attr -> Attr -> Attr -> Skin -> RenderContext

-- | The default normal attribute to use unless overridden by a given
--   widget.
normalAttr :: RenderContext -> Attr

-- | The default focused attribute to use for a focused widget unless
--   overridden by a given widget.
focusAttr :: RenderContext -> Attr

-- | An override attribute to be used to override both the normal and focus
--   attributes in effect during rendering. Usually defAttr, this attribute
--   is used when child widgets need to have their attributes overridden by
--   a parent widget.
overrideAttr :: RenderContext -> Attr

-- | The skin to use for rendering borders and other interface elements
--   which use the skin for their representations.
skin :: RenderContext -> Skin

-- | Render errors.
data RenderError

-- | An error indicating that a widget rendered to an image which exceeded
--   the available space. Provides a representation of the violating
--   widget, the size of the available space, and the size of the image
--   which the widget's rendering routine produced.
ImageTooBig :: String -> DisplayRegion -> DisplayRegion -> RenderError

-- | Render a widget. This function should be called by widget
--   implementations, since it does more than <a>render_</a>; this function
--   takes care of setting up attributes in the rendering context, setting
--   the size of the widget after it has been rendered, and checking for
--   size violations. May throw a <a>RenderError</a>.
render :: Show a => Widget a -> DisplayRegion -> RenderContext -> IO Image

-- | Render a widget and set its position after rendering is complete. This
--   is exported for internal use; widget implementations should call
--   <a>render</a> instead.
renderAndPosition :: Show a => Widget a -> DisplayRegion -> DisplayRegion -> RenderContext -> IO Image

-- | The class of types with a ''normal'' attribute.
class HasNormalAttr w
setNormalAttribute :: HasNormalAttr w => w -> Attr -> IO ()

-- | The class of types with a ''focus'' attribute, i.e., a way of visually
--   indicating that the object has input focus.
class HasFocusAttr w
setFocusAttribute :: HasFocusAttr w => w -> Attr -> IO ()

-- | Set the normal attribute on a value.
withNormalAttribute :: HasNormalAttr w => Attr -> w -> IO w

-- | Set the focus attribute on a value.
withFocusAttribute :: HasFocusAttr w => Attr -> w -> IO w

-- | Given a widget and key event information, invoke the widget's key
--   event handler with the event information. Returns whether the event
--   was handled.
handleKeyEvent :: Widget a -> Key -> [Modifier] -> IO Bool

-- | Given a widget and a key event handler, add the handler to the
--   widget's key event handler structure. The event handler is added last,
--   so any preexisting handlers will run before this one.
onKeyPressed :: Widget a -> (Widget a -> Key -> [Modifier] -> IO Bool) -> IO ()

-- | Given a widget and a focus gain event handler, add the handler to the
--   widget. The handler will be invoked when the widget receives focus.
onGainFocus :: Widget a -> (Widget a -> IO ()) -> IO ()

-- | Given a widget and a focus loss event handler, add the handler to the
--   widget. The handler will be invoked when the widget loses focus.
onLoseFocus :: Widget a -> (Widget a -> IO ()) -> IO ()

-- | Given a widget and a resize event handler, add the handler to the
--   widget. The handler will be invoked when the widget's size changes.
--   This includes the first rendering, at which point its size changes
--   from (0, 0). Note that if the resize handler needs to change the
--   visual appearance of the widget when its size changes, be sure to use
--   <tt>schedule</tt> to ensure that visual changes are reflected
--   immediately, and be absolutely sure that those changes will not cause
--   further size changes; that will cause a resize event handler loop that
--   will consume your CPU!
onResize :: Widget a -> ((DisplayRegion, DisplayRegion) -> IO ()) -> IO ()

-- | Given widgets A and B, causes any key events on widget A to be relayed
--   to widget B. Note that this does behavior constitutes an ordinary key
--   event handler from A's perspective, so if B does not handle a given
--   key event, subsequent key event handlers on A will still get a chance
--   to handle the event. This function is mostly useful for wrapper
--   widgets which don't do any event handling of their own but want to
--   ensure that all key events are relayed to the wrapped widget.
relayKeyEvents :: Widget a -> Widget b -> IO ()

-- | Given widgets A and B, cause all focus gain and loss events on A to
--   cause focus gain and loss for B.
relayFocusEvents :: Widget a -> Widget b -> IO ()

-- | Focus group. Represents an cycle of widgets which receive input focus.
data FocusGroup

-- | Focus group handling errors.
data FocusGroupError

-- | Thrown when the desired operation could not be completed because the
--   focus group is empty.
FocusGroupEmpty :: FocusGroupError

-- | Thrown when the specified focus group entry index was invalid.
FocusGroupBadIndex :: Int -> FocusGroupError

-- | Create a new focus group. Note that the focus group is itself a
--   widget; any input event handlers added to the focus group will fire
--   before input events are handled by the currently-focused widget.
newFocusGroup :: IO (Widget FocusGroup)

-- | Merge two focus groups. Given two focus groups A and B, this returns a
--   new focus group with all of the entries from A and B added to it, in
--   that order. At least one A and B must be non-empty or
--   <a>FocusGroupEmpty</a> will be thrown.
mergeFocusGroups :: Widget FocusGroup -> Widget FocusGroup -> IO (Widget FocusGroup)

-- | Given two focus groups A and B, append the entries of B to A, mutating
--   A in the process. Throws <a>FocusGroupEmpty</a> if B is empty.
appendFocusGroup :: Widget FocusGroup -> Widget FocusGroup -> IO ()

-- | Reset a focus group. This ensures that the focus group's state is
--   coherent by calling <a>focus</a> on the group's focused entry and
--   <a>unfocus</a> on all the rest. This is for internal use, but is used
--   by the <tt>Collection</tt> switching implementation to ensure that
--   focus state is sane.
resetFocusGroup :: Widget FocusGroup -> IO ()

-- | Add a widget to a focus group. This returns a focus group entry which
--   wraps the specified widget; the focus group entry is also a widget and
--   can take key event handlers and the like. During input event
--   processing, the focus group entry receives keyboard events and passes
--   them on to the wrapped widget. If you want a widget to have specific
--   event handling in a particular interface, add event handlers to its
--   focus entry/entries instead of the widget itself.
addToFocusGroup :: Show a => Widget FocusGroup -> Widget a -> IO (Widget FocusEntry)

-- | Focus the next widget in a focus group.
focusNext :: Widget FocusGroup -> IO ()

-- | Focus the previous widget in a focus group.
focusPrevious :: Widget FocusGroup -> IO ()

-- | Set the keyboard event information used to change focus to the next
--   widget in a focus group.
setFocusGroupNextKey :: Widget FocusGroup -> Key -> [Modifier] -> IO ()

-- | Set the keyboard event information used to change focus to the
--   previous widget in a focus group.
setFocusGroupPrevKey :: Widget FocusGroup -> Key -> [Modifier] -> IO ()

-- | Focus a widget. Causes its focus gain event handlers to run. If the
--   widget is in a <a>FocusGroup</a> and if that group's currently-focused
--   widget is some other widget, that widget will lose the focus and its
--   focus loss event handlers will be called.
focus :: Widget a -> IO ()

-- | Unfocus a widget. Causes its focus loss event handlers to run.
unfocus :: Widget a -> IO ()
instance Typeable RenderError
instance Typeable FocusGroupError
instance Show RenderError
instance Show FocusGroupError
instance Exception FocusGroupError
instance Show a => Show (WidgetImpl a)
instance Exception RenderError
instance HasFocusAttr (Widget a)
instance HasNormalAttr (Widget a)


-- | This module provides vertical and horizontal box layout widgets using
--   the <a>Box</a> type. Box widgets use their child widgets' size
--   policies and their space allocation settings to determine layout.
--   
--   Box widgets propagate key and focus events to their children.
--   
--   For more details, see the Vty-ui User's Manual.
module Graphics.Vty.Widgets.Box
data Box a b

-- | Child size policy applied to a box.
data ChildSizePolicy

-- | A per-child policy.
PerChild :: IndividualPolicy -> IndividualPolicy -> ChildSizePolicy

-- | Percentage, p, of space given to first child, which implies that (100
--   - p) percent given to the second.
Percentage :: Int -> ChildSizePolicy

-- | Individual child widget policy applied to a child widget contained in
--   a box.
data IndividualPolicy

-- | The child's growth policy will be used to determine layout. The child
--   widget layout will also be affected by the policy of the other widget
--   in the box.
BoxAuto :: IndividualPolicy

-- | A fixed number of rows or columns, depending on box type, will be
--   allocated to the child.
BoxFixed :: Int -> IndividualPolicy
data BoxError

-- | Indicates that a given percentage value was invalid.
BadPercentage :: BoxError

-- | Create a horizontal box widget containing two widgets side by side.
--   Space consumed by the box will depend on its contents, available
--   space, and the box child size policy.
hBox :: (Show a, Show b) => Widget a -> Widget b -> IO (Widget (Box a b))

-- | Create a vertical box widget containing two widgets, one above the
--   other. Space consumed by the box will depend on its contents,
--   available space, and the box child size policy.
vBox :: (Show a, Show b) => Widget a -> Widget b -> IO (Widget (Box a b))

-- | Create a horizontal box widget using monadic widget constructors.
(<++>) :: (Show a, Show b) => IO (Widget a) -> IO (Widget b) -> IO (Widget (Box a b))

-- | Create a vertical box widget using monadic widget constructors.
(<-->) :: (Show a, Show b) => IO (Widget a) -> IO (Widget b) -> IO (Widget (Box a b))

-- | Set the spacing in between a box's child widgets in rows or columns,
--   depending on the box type.
setBoxSpacing :: Widget (Box a b) -> Int -> IO ()
withBoxSpacing :: Int -> Widget (Box a b) -> IO (Widget (Box a b))

-- | The default box child size policy, which defers to the children to
--   determine layout.
defaultChildSizePolicy :: ChildSizePolicy

-- | Set the box child size policy. Throws <a>BadPercentage</a> if the size
--   policy uses an invalid percentage value, which must be between 0 and
--   100 inclusive.
setBoxChildSizePolicy :: Widget (Box a b) -> ChildSizePolicy -> IO ()

-- | Get the child size policy for a box.
getBoxChildSizePolicy :: Widget (Box a b) -> IO ChildSizePolicy

-- | Get a reference to the first (left or top) widget in a box.
getFirstChild :: Widget (Box a b) -> IO (Widget a)

-- | Get a reference to the second (right or bottom) widget in a box.
getSecondChild :: Widget (Box a b) -> IO (Widget b)
instance Typeable BoxError
instance Eq BoxError
instance Show BoxError
instance Eq Orientation
instance Show Orientation
instance Show IndividualPolicy
instance Eq IndividualPolicy
instance Show ChildSizePolicy
instance Eq ChildSizePolicy
instance Show (Box a b)
instance Exception BoxError


-- | This module provides functionality for rendering <tt>Text</tt> as
--   <a>Widget</a>s, including functionality to make structural and/or
--   visual changes at rendering time. To get started, use
--   <a>plainText</a>; for more control, use <a>textWidget</a>.
module Graphics.Vty.Widgets.Text

-- | The type of formatted text widget state. Stores the text itself and
--   the formatter used to apply attributes to the text.
data FormattedText

-- | Construct a Widget directly from a Text value. This is recommended if
--   you don't need to use a <a>Formatter</a>.
plainText :: Text -> IO (Widget FormattedText)

-- | Construct a Widget directly from a list of strings and their
--   attributes.
plainTextWithAttrs :: [(Text, Attr)] -> IO (Widget FormattedText)

-- | Construct a text widget formatted with the specified formatters and
--   initial content. The formatters will be applied in the order given
--   here (and, depending on the formatter, order might matter).
textWidget :: Formatter -> Text -> IO (Widget FormattedText)

-- | Set the text value of a <a>FormattedText</a> widget. The specified
--   string will be <a>tokenize</a>d.
setText :: Widget FormattedText -> Text -> IO ()

-- | Append the text value to the text contained in a <a>FormattedText</a>
--   widget. The specified string will be <a>tokenize</a>d.
appendText :: Widget FormattedText -> Text -> IO ()

-- | Prepend the text value to the text contained in a <a>FormattedText</a>
--   widget. The specified string will be <a>tokenize</a>d.
prependText :: Widget FormattedText -> Text -> IO ()

-- | Set the text value of a <a>FormattedText</a> widget directly, in case
--   you have done formatting elsewhere and already have text with
--   attributes. The specified strings will each be <a>tokenize</a>d, and
--   tokens resulting from each <a>tokenize</a> operation will be given the
--   specified attribute in the tuple.
setTextWithAttrs :: Widget FormattedText -> [(Text, Attr)] -> IO ()

-- | Append text to the text value of a <a>FormattedText</a> widget
--   directly, in case you have done formatting elsewhere and already have
--   text with attributes. The specified strings will each be
--   <a>tokenize</a>d, and tokens resulting from each <a>tokenize</a>
--   operation will be given the specified attribute in the tuple.
appendTextWithAttrs :: Widget FormattedText -> [(Text, Attr)] -> IO ()

-- | Prepend text to the text value of a <a>FormattedText</a> widget
--   directly, in case you have done formatting elsewhere and already have
--   text with attributes. The specified strings will each be
--   <a>tokenize</a>d, and tokens resulting from each <a>tokenize</a>
--   operation will be given the specified attribute in the tuple.
prependTextWithAttrs :: Widget FormattedText -> [(Text, Attr)] -> IO ()

-- | Set the formatter for the text.
setTextFormatter :: Widget FormattedText -> Formatter -> IO ()

-- | Set whether a text widget can appear focused by using the
--   context-specific focus attribute when the widget has the focus. This
--   setting defaults to False; some widgets which embed text widgets may
--   need to turn this on.
setTextAppearFocused :: Widget FormattedText -> Bool -> IO ()

-- | A formatter makes changes to text at rendering time. Some formatting
--   use cases involve knowing the size of the rendering area, which is not
--   known until render time (e.g., text wrapping). Thus, a formatter takes
--   a <a>DisplayRegion</a> which indicates the size of screen area
--   available for formatting.
newtype Formatter
Formatter :: (DisplayRegion -> TextStream Attr -> IO (TextStream Attr)) -> Formatter
applyFormatter :: Formatter -> DisplayRegion -> TextStream Attr -> IO (TextStream Attr)

-- | Get the formatter for the text.
getTextFormatter :: Widget FormattedText -> IO Formatter

-- | The null formatter which has no effect on text streams.
nullFormatter :: Formatter

-- | A formatter for wrapping text into the available space. This formatter
--   will insert line breaks where appropriate so if you want to use other
--   structure-sensitive formatters, run this formatter last.
wrap :: Formatter
instance Show FormattedText
instance Monoid Formatter


-- | This module provides visual borders to be placed between and around
--   widgets. Border widgets in this module use the active <a>Skin</a> in
--   the <a>RenderContext</a>.
module Graphics.Vty.Widgets.Borders

-- | The class of types with a border attribute, which differs from the
--   normal and focused attributes.
class HasBorderAttr a
setBorderAttribute :: HasBorderAttr a => a -> Attr -> IO ()
data Bordered a
data HBorder
data VBorder

-- | Create a single-column vertical border using the specified attribute
--   and character.
vBorder :: IO (Widget VBorder)

-- | Create a single-row horizontal border using the specified attribute
--   and character.
hBorder :: IO (Widget HBorder)

-- | Wrap a widget in a bordering box.
bordered :: Show a => Widget a -> IO (Widget (Bordered a))

-- | Sets the border attribute of a thing with a border attribute.
withBorderAttribute :: HasBorderAttr a => Attr -> a -> IO a

-- | Adds a label to a horizontal border. The label will be horizontally
--   centered.
withHBorderLabel :: Text -> Widget HBorder -> IO (Widget HBorder)

-- | Adds a label to the top border of a bordered widget. The label will be
--   horizontally centered.
withBorderedLabel :: Text -> Widget (Bordered a) -> IO (Widget (Bordered a))

-- | Adds a label to a horizontal border. The label will be horizontally
--   centered.
setHBorderLabel :: Widget HBorder -> Text -> IO ()

-- | Adds a label to the top border of a bordered widget. The label will be
--   horizontally centered.
setBorderedLabel :: Widget (Bordered a) -> Text -> IO ()
instance Show HBorder
instance Show VBorder
instance HasBorderAttr (Widget (Bordered a))
instance Show (Bordered a)
instance HasBorderAttr (Widget VBorder)
instance HasBorderAttr (Widget HBorder)


-- | This module provides a text-editing widget. Edit widgets can operate
--   in single- and multi-line modes.
--   
--   Edit widgets support the following special keystrokes:
--   
--   <ul>
--   <li>Arrow keys to navigate the text</li>
--   <li><tt>Enter</tt> - Activate single-line edit widgets or insert new
--   lines into multi-line widgets</li>
--   <li><tt>Home</tt> / <tt>Control-a</tt> - Go to beginning of the
--   current line</li>
--   <li><tt>End</tt> / <tt>Control-e</tt> - Go to end of the current
--   line</li>
--   <li><tt>Control-k</tt> - Remove text from the cursor to the end of the
--   line, or remove the line if it is empty</li>
--   <li><tt>Del</tt> / <tt>Control-d</tt> - delete the current
--   character</li>
--   <li><tt>Backspace</tt> - delete the previous character</li>
--   </ul>
--   
--   Edit widgets may be configured with a line limit which limits the
--   number of lines of text the widget will store. It does not provide any
--   limit control on the length of its lines, though.
--   
--   Edit widgets support multi-column characters. (For some information,
--   see <a>http://www.unicode.org/reports/tr11/</a>.) When the edit widget
--   scrolling reaches a point where a wide character cannot be drawn
--   because it is bisected by the editing window's boundary, it will be
--   replaced with an indicator ("$") until the scrolling window is moved
--   enough to reveal the character. This is done to preserve the relative
--   alignment of all of the rows in the widget in the presence of
--   characters of different widths. Note that this is a visual aid only
--   and does not affect the underlying text content of the widget.
module Graphics.Vty.Widgets.Edit
data Edit

-- | Construct a text widget for editing a single line of text. Single-line
--   edit widgets will send activation events when the user presses
--   <tt>Enter</tt> (see <a>onActivate</a>).
editWidget :: IO (Widget Edit)

-- | Construct a text widget for editing multi-line documents. Multi-line
--   edit widgets never send activation events, since the <tt>Enter</tt>
--   key inserts a new line at the cursor position.
multiLineEditWidget :: IO (Widget Edit)

-- | Get the current contents of the edit widget. This returns all of the
--   lines of text in the widget, separated by newlines.
getEditText :: Widget Edit -> IO Text

-- | Get the contents of the current line of the edit widget (the line on
--   which the cursor is positioned).
getEditCurrentLine :: Widget Edit -> IO Text

-- | Set the contents of the edit widget. Newlines will be used to break up
--   the text in multiline widgets. If the edit widget has a line limit,
--   only those lines within the limit will be set. If the edit widget has
--   a line length limit, lines will be truncated.
setEditText :: Widget Edit -> Text -> IO ()

-- | Set the function which rewrites all characters at rendering time.
--   Defaults to <a>id</a>. Does not affect text stored in the editor.
setEditRewriter :: Widget Edit -> (Char -> Char) -> IO ()

-- | Set the function which allows typed characters in the edit widget.
--   Defaults to <a>const</a> <a>True</a>, allowing all characters. For
--   example, setting the filter to (<a>elem</a> "0123456789") will only
--   allow numbers in the edit widget.
setCharFilter :: Widget Edit -> (Char -> Bool) -> IO ()

-- | Get the edit widget's current cursor position (row, column).
getEditCursorPosition :: Widget Edit -> IO (Int, Int)

-- | Set the cursor position to the specified row and column. Invalid
--   cursor positions will be ignored.
setEditCursorPosition :: (Int, Int) -> Widget Edit -> IO ()

-- | Set the limit on the number of lines for the edit widget.
--   <a>Nothing</a> indicates no limit, while <a>Just</a> indicates a limit
--   of the specified number of lines.
setEditLineLimit :: Widget Edit -> Maybe Int -> IO ()

-- | Get the current line limit, if any, for the edit widget.
getEditLineLimit :: Widget Edit -> IO (Maybe Int)

-- | Set the maximum length of the contents of an edit widget. Applies to
--   every line of text in the editor. <a>Nothing</a> indicates no limit,
--   while <a>Just</a> indicates a limit of the specified number of
--   characters.
setEditMaxLength :: Widget Edit -> Maybe Int -> IO ()

-- | Get the current maximum length, if any, for the edit widget.
getEditMaxLength :: Widget Edit -> IO (Maybe Int)

-- | Apply an editing transformation to the edit widget's text. If the
--   transformation modifies the text or the cursor, the appropriate event
--   handlers will be notified. If a line limit is in effect and the
--   transformation violates it, the transformation will be ignored.
applyEdit :: (TextZipper Text -> TextZipper Text) -> Widget Edit -> IO ()

-- | Register handlers to be invoked when the edit widget has been
--   ''activated'' (when the user presses Enter while the widget is
--   focused). These handlers will only be invoked when a single-line edit
--   widget is activated; multi-line widgets never generate these events.
onActivate :: Widget Edit -> (Widget Edit -> IO ()) -> IO ()

-- | Register handlers to be invoked when the edit widget's contents
--   change. Handlers will be passed the new contents.
onChange :: Widget Edit -> (Text -> IO ()) -> IO ()

-- | Register handlers to be invoked when the edit widget's cursor position
--   changes. Handlers will be passed the new cursor position, relative to
--   the beginning of the text (position (0, 0)).
onCursorMove :: Widget Edit -> ((Int, Int) -> IO ()) -> IO ()
instance Show Edit


-- | This module provides ''check box'' widgets and ''radio button''
--   widgets. In addition, this module provides a generalized
--   ''multi-state'' check box type which allows you to set multiple states
--   in the checkbox, each with its own character representation.
--   
--   All of these types of widgets are toggled with the Spacebar and Enter
--   keys.
module Graphics.Vty.Widgets.CheckBox
data CheckBox a
type RadioGroup = IORef RadioGroupData

-- | Create a new checkbox with the specified text label.
newCheckbox :: Text -> IO (Widget (CheckBox Bool))

-- | Set a binary checkbox to unchecked.
setCheckboxUnchecked :: Widget (CheckBox Bool) -> IO ()

-- | Set a binary checkbox to checked.
setCheckboxChecked :: Widget (CheckBox Bool) -> IO ()

-- | Toggle a binary checkbox.
toggleCheckbox :: Widget (CheckBox Bool) -> IO ()

-- | Register a handler for a checkbox state change. The handler will be
--   passed the new state value.
onCheckboxChange :: Widget (CheckBox a) -> (a -> IO ()) -> IO ()

-- | Create a new multi-state checkbox.
newMultiStateCheckbox :: Eq a => Text -> [(a, Char)] -> IO (Widget (CheckBox a))

-- | Set the state of a checkbox. May throw <a>BadCheckboxState</a>.
setCheckboxState :: Eq a => Widget (CheckBox a) -> a -> IO ()

-- | Cycle a checkbox's state to the next value in its state list.
cycleCheckbox :: Eq a => Widget (CheckBox a) -> IO ()

-- | Set the visual representation for a state in a checkbox. May throw
--   <a>BadStateArgument</a>.
setStateChar :: Eq a => Widget (CheckBox a) -> a -> Char -> IO ()

-- | Set the checkbox's bracketing characters for the left and right
--   brackets around the state character.
setBracketChars :: Widget (CheckBox a) -> Char -> Char -> IO ()

-- | Get a checkbox's text label.
getCheckboxLabel :: Widget (CheckBox a) -> IO Text

-- | Get a checkbox's current state value.
getCheckboxState :: Widget (CheckBox a) -> IO a

-- | Create a new radio button group. This is used to guarantee exclusivity
--   among the check boxes in the group so that they behave like radio
--   buttons.
newRadioGroup :: IO RadioGroup

-- | Register a handler to be notified when the currently-selected check
--   box in a radio group changes.
onRadioChange :: RadioGroup -> (Widget (CheckBox Bool) -> IO ()) -> IO ()

-- | Add a check box to a radio group. The check box's apperance will be
--   changed so that it resembles a radio button.
addToRadioGroup :: RadioGroup -> Widget (CheckBox Bool) -> IO ()

-- | Get the currently-selected checkbox in a radio group, if any.
getCurrentRadio :: RadioGroup -> IO (Maybe (Widget (CheckBox Bool)))
instance Typeable CheckBoxError
instance Show CheckBoxError
instance Show a => Show (CheckBox a)
instance Exception CheckBoxError


-- | This module provides a ''padding'' mechanism for adding padding to a
--   widget on one or more sides.
module Graphics.Vty.Widgets.Padding
data Padded

-- | The type of padding on widgets.
data Padding

-- | The class of types to which we can add padding.
class Paddable a
pad :: Paddable a => a -> Padding -> a
(+++) :: Monoid a => a -> a -> a

-- | Create a <a>Padded</a> wrapper to add padding.
padded :: Show a => Widget a -> Padding -> IO (Widget Padded)

-- | Monadic combinator to construct a <a>Padded</a> wrapper.
withPadding :: Show a => Padding -> Widget a -> IO (Widget Padded)

-- | Padding constructor with no padding.
padNone :: Padding

-- | Padding constructor with left padding in columns.
padLeft :: Int -> Padding

-- | Padding constructor with right padding in columns.
padRight :: Int -> Padding

-- | Padding constructor with top padding in rows.
padTop :: Int -> Padding

-- | Padding constructor with bottom padding in rows.
padBottom :: Int -> Padding

-- | Padding constructor with padding on left and right in columns.
padLeftRight :: Int -> Padding

-- | Padding constructor with padding on top and bottom in rows.
padTopBottom :: Int -> Padding

-- | Padding constructor with padding on all sides in rows and columns.
padAll :: Int -> Padding
instance Show Padding
instance Paddable Padding
instance Monoid Padding
instance Show Padded


-- | This module provides wrapper widgets for enforcing an upper bound on
--   the size of child widgets in one or more dimensions in rows or
--   columns, respectively. This differs from the ''fixed'' widgets in the
--   Fixed module in that Fixed widgets enforce a fixed size regardless of
--   how big or small the child widget is, and add padding to guarantee
--   that the fixed size is honored.
module Graphics.Vty.Widgets.Limits
data VLimit a
data HLimit a

-- | Impose a maximum horizontal size, in columns, on a <a>Widget</a>.
hLimit :: Show a => Int -> Widget a -> IO (Widget (HLimit a))

-- | Impose a maximum vertical size, in columns, on a <a>Widget</a>.
vLimit :: Show a => Int -> Widget a -> IO (Widget (VLimit a))

-- | Impose a horizontal and vertical upper bound on the size of a widget.
boxLimit :: Show a => Int -> Int -> Widget a -> IO (Widget (VLimit (HLimit a)))

-- | Set the vertical limit of a child widget's size.
setVLimit :: Widget (VLimit a) -> Int -> IO ()

-- | Set the horizontal limit of a child widget's size.
setHLimit :: Widget (HLimit a) -> Int -> IO ()

-- | Add to the vertical limit of a child widget's size.
addToVLimit :: Widget (VLimit a) -> Int -> IO ()

-- | Add to the horizontal limit of a child widget's size.
addToHLimit :: Widget (HLimit a) -> Int -> IO ()

-- | Get the vertical limit of a child widget's size.
getVLimit :: Widget (VLimit a) -> IO Int

-- | Get the horizontal limit of a child widget's size.
getHLimit :: Widget (HLimit a) -> IO Int
instance Show (VLimit a)
instance Show (HLimit a)


-- | This module provides wrapper widgets for fixing the size of child
--   widgets in one or more dimensions in rows or columns, respectively.
--   This differs from the ''limit'' widgets in the Limits module in that
--   Limits enforce an upper bound on size.
module Graphics.Vty.Widgets.Fixed
data VFixed a
data HFixed a

-- | Impose a fixed horizontal size, in columns, on a <a>Widget</a>.
hFixed :: Show a => Int -> Widget a -> IO (Widget (HFixed a))

-- | Impose a fixed vertical size, in columns, on a <a>Widget</a>.
vFixed :: Show a => Int -> Widget a -> IO (Widget (VFixed a))

-- | Impose a fixed horizontal and vertical size on a widget.
boxFixed :: Show a => Int -> Int -> Widget a -> IO (Widget (VFixed (HFixed a)))

-- | Set the vertical fixed size of a child widget.
setVFixed :: Widget (VFixed a) -> Int -> IO ()

-- | Set the horizontal fixed size of a child widget.
setHFixed :: Widget (HFixed a) -> Int -> IO ()

-- | Add to the vertical fixed size of a child widget.
addToVFixed :: Widget (VFixed a) -> Int -> IO ()

-- | Add to the horizontal fixed size of a child widget.
addToHFixed :: Widget (HFixed a) -> Int -> IO ()

-- | Get the vertical fixed size of a child widget.
getVFixedSize :: Widget (VFixed a) -> IO Int

-- | Get the horizontal fixed size of a child widget.
getHFixedSize :: Widget (HFixed a) -> IO Int
instance Show (VFixed a)
instance Show (HFixed a)


-- | This module provides a <a>List</a> widget for rendering a list of
--   arbitrary widgets. A <a>List</a> shows a number of elements and
--   highlights the currently-selected widget. It supports key events to
--   navigate the list and will automatically scroll based on the space
--   available to the list along with the size of the widgets in the list.
module Graphics.Vty.Widgets.List

-- | The list widget type. Lists are parameterized over the <i>internal</i>
--   <i>value type</i> <tt>a</tt>, the type of internal values used to
--   refer to the visible representations of the list contents, and the
--   <i>widget type</i> <tt>b</tt>, the type of widgets used to represent
--   the list visually.
data List a b

-- | A list item. Each item contains an arbitrary internal value <tt>a</tt>
--   and a <a>Widget</a> representing it.
type ListItem a b = (a, Widget b)
data ListError

-- | The specified position could not be used to remove an item from the
--   list.
BadItemIndex :: Int -> ListError
ResizeError :: ListError

-- | A new item was added to the list at the specified position with the
--   specified value and widget.
data NewItemEvent a b
NewItemEvent :: Int -> a -> (Widget b) -> NewItemEvent a b

-- | An item was removed from the list at the specified position with the
--   specified value and widget.
data RemoveItemEvent a b
RemoveItemEvent :: Int -> a -> (Widget b) -> RemoveItemEvent a b
data SelectionEvent a b

-- | An item at the specified position with the specified internal value
--   and widget was selected.
SelectionOn :: Int -> a -> (Widget b) -> SelectionEvent a b

-- | No item was selected, which means the list is empty.
SelectionOff :: SelectionEvent a b

-- | An item in the list was activated at the specified position with the
--   specified value and widget.
data ActivateItemEvent a b
ActivateItemEvent :: Int -> a -> (Widget b) -> ActivateItemEvent a b

-- | A convenience function to create a new list using <tt>Text</tt> values
--   as the internal values and <a>FormattedText</a> widgets to represent
--   those strings.
newTextList :: [Text] -> Int -> IO (Widget (List Text FormattedText))

-- | Create a new list. The list's item widgets will be rendered using the
--   specified height in rows.
newList :: Show b => Int -> IO (Widget (List a b))

-- | Add an item to the list. Its widget will be constructed from the
--   specified internal value using the widget constructor passed to
--   <a>newList</a>.
addToList :: Show b => Widget (List a b) -> a -> Widget b -> IO ()

-- | Insert an element into the list at the specified position. If the
--   position exceeds the length of the list, it is inserted at the end.
insertIntoList :: Show b => Widget (List a b) -> a -> Widget b -> Int -> IO ()

-- | Remove an element from the list at the specified position. May throw
--   <a>BadItemIndex</a>.
removeFromList :: Widget (List a b) -> Int -> IO (ListItem a b)

-- | Sets the attributes to be merged on the selected list item when the
--   list widget has the focus.
setSelectedFocusedAttr :: Widget (List a b) -> Maybe Attr -> IO ()

-- | Sets the attributes to be merged on the selected list item when the
--   list widget does not have the focus.
setSelectedUnfocusedAttr :: Widget (List a b) -> Maybe Attr -> IO ()

-- | Scroll a list up or down by the specified number of positions.
--   Scrolling by a positive amount scrolls downward and scrolling by a
--   negative amount scrolls upward. This automatically takes care of
--   managing internal list state and invoking event handlers.
scrollBy :: Widget (List a b) -> Int -> IO ()

-- | Scroll a list up by one position.
scrollUp :: Widget (List a b) -> IO ()

-- | Scroll a list down by one position.
scrollDown :: Widget (List a b) -> IO ()

-- | Scroll to the last list position.
scrollToEnd :: Widget (List a b) -> IO ()

-- | Scroll to the first list position.
scrollToBeginning :: Widget (List a b) -> IO ()

-- | Scroll a list up by one page from the current cursor position.
pageUp :: Widget (List a b) -> IO ()

-- | Scroll a list down by one page from the current cursor position.
pageDown :: Widget (List a b) -> IO ()

-- | Register event handlers to be invoked when the list's selected item
--   changes.
onSelectionChange :: Widget (List a b) -> (SelectionEvent a b -> IO ()) -> IO ()

-- | Register event handlers to be invoked when a new item is added to the
--   list.
onItemAdded :: Widget (List a b) -> (NewItemEvent a b -> IO ()) -> IO ()

-- | Register event handlers to be invoked when an item is removed from the
--   list.
onItemRemoved :: Widget (List a b) -> (RemoveItemEvent a b -> IO ()) -> IO ()

-- | Register event handlers to be invoked when an item is activated, which
--   happens when the user presses Enter on a selected element while the
--   list has the focus.
onItemActivated :: Widget (List a b) -> (ActivateItemEvent a b -> IO ()) -> IO ()

-- | Programmatically activate the currently-selected item in the list, if
--   any.
activateCurrentItem :: Widget (List a b) -> IO ()

-- | Clear the list, removing all elements. Does not invoke any handlers.
clearList :: Widget (List a b) -> IO ()

-- | Set the currently-selected list index.
setSelected :: Widget (List a b) -> Int -> IO ()

-- | Find the first index of the specified key in the list. If the key does
--   not exist, return Nothing.
listFindFirst :: Eq a => Widget (List a b) -> a -> IO (Maybe Int)

-- | Find the first index in the list for which the predicate is true. If
--   no item in the list matches the given predicate, return Nothing.
listFindFirstBy :: (a -> Bool) -> Widget (List a b) -> IO (Maybe Int)

-- | Find all indicies of the specified key in the list.
listFindAll :: Eq a => Widget (List a b) -> a -> IO [Int]

-- | Find all indices in the list matching the given predicate.
listFindAllBy :: (a -> Bool) -> Widget (List a b) -> IO [Int]

-- | Get the length of the list in elements.
getListSize :: Widget (List a b) -> IO Int

-- | Get the currently-selected list item.
getSelected :: Widget (List a b) -> IO (Maybe (Int, ListItem a b))

-- | Get the list item at the specified position.
getListItem :: Widget (List a b) -> Int -> IO (Maybe (ListItem a b))
instance Typeable ListError
instance Show ListError
instance Show (List a b)
instance Exception ListError


-- | This module provides ''space-filling'' widgets used to control layout.
module Graphics.Vty.Widgets.Fills
data VFill
data HFill

-- | A horizontal fill widget. Fills the available horizontal space using
--   the specified character. The integer parameter specifies the height,
--   in rows, of the fill.
hFill :: Char -> Int -> IO (Widget HFill)

-- | A vertical fill widget. Fills all available space with the specified
--   character and attribute.
vFill :: Char -> IO (Widget VFill)
instance Show VFill
instance Show HFill


-- | This module provides widgets to center other widgets horizontally and
--   vertically. These centering widgets relay focus and key events to
--   their children.
module Graphics.Vty.Widgets.Centering
data HCentered a
data VCentered a

-- | Wrap another widget to center it horizontally.
hCentered :: Show a => Widget a -> IO (Widget (HCentered a))

-- | Wrap another widget to center it vertically.
vCentered :: Show a => Widget a -> IO (Widget (VCentered a))

-- | Wrap another widget to center it both vertically and horizontally.
centered :: Show a => Widget a -> IO (Widget (VCentered (HCentered a)))
instance Show (VCentered a)
instance Show (HCentered a)


-- | This module provides a table layout widget capable of laying out
--   columns of widgets with various padding and alignment properties. For
--   complete details, please see the Vty-ui User's Manual.
module Graphics.Vty.Widgets.Table
data Table

-- | The wrapper type for all table cells; stores the widgets themselves in
--   addition to alignment and padding settings. Alignment and padding
--   settings on a cell override the column- and table-wide defaults.
data TableCell

-- | The type of column size policies.
data ColumnSize

-- | The column has the specified fixed width in columns.
ColFixed :: Int -> ColumnSize

-- | The column's width is a function of space available to the table at
--   rendering time.
ColAuto :: ColumnSize

-- | The border configuration of a table.
data BorderStyle
BorderPartial :: [BorderFlag] -> BorderStyle

-- | A partial set of border flags.
BorderFull :: BorderStyle

-- | Don't draw any borders anywhere.
BorderNone :: BorderStyle

-- | The types of borders we can have in a table.
data BorderFlag

-- | Borders between rows.
Rows :: BorderFlag

-- | Borders between columns.
Columns :: BorderFlag

-- | Borders around the outside edges of the table.
Edges :: BorderFlag

-- | The class of types whose values can be used to construct table rows.
class RowLike a
mkRow :: RowLike a => a -> TableRow
data TableError

-- | A row added to the table did not have the same number of widgets as
--   the table has columns.
ColumnCountMismatch :: TableError

-- | The image rendered by a cell widget exceeded the size permitted by the
--   cell.
CellImageTooBig :: TableError

-- | A table cell contains a widget which grows vertically, which is not
--   permitted.
BadTableWidgetSizePolicy :: Int -> TableError

-- | The specification of a column's settings. The alignment and padding of
--   a column specification override the table-wide default.
data ColumnSpec
ColumnSpec :: ColumnSize -> Maybe Alignment -> Maybe Padding -> ColumnSpec
columnSize :: ColumnSpec -> ColumnSize
columnAlignment :: ColumnSpec -> Maybe Alignment
columnPadding :: ColumnSpec -> Maybe Padding

-- | Row constructor using <a>RowLike</a> instances.
(.|.) :: (RowLike a, RowLike b) => a -> b -> TableRow

-- | Create a table widget using a list of column specifications and a
--   border style.
newTable :: [ColumnSpec] -> BorderStyle -> IO (Widget Table)

-- | Set the default table-wide cell alignment.
setDefaultCellAlignment :: Widget Table -> Alignment -> IO ()

-- | Set the default table-wide cell padding.
setDefaultCellPadding :: Widget Table -> Padding -> IO ()

-- | Add a row to the table. Use <a>RowLike</a> instances to populate the
--   row. Throws <a>BadTableWidgetSizePolicy</a> if any widgets in the row
--   grow vertically; throws <a>ColumnCountMismatch</a> if the row's number
--   of columns does not match the table's column count.
addRow :: RowLike a => Widget Table -> a -> IO ()

-- | Add a heading row to a table. Adds a row using the specified |labels
--   and attribute. Returns the widgets it constructed as a |side-effect in
--   case you want to do something with them.
addHeadingRow :: Widget Table -> Attr -> [Text] -> IO [Widget FormattedText]

-- | Add a heading row to a table. Adds a row using the specified |labels
--   and attribute.
addHeadingRow_ :: Widget Table -> Attr -> [Text] -> IO ()

-- | Create a column.
column :: ColumnSize -> ColumnSpec

-- | Create a custom <a>TableCell</a> to set its alignment and/or padding
--   settings.
customCell :: Show a => Widget a -> TableCell

-- | Create an empty table cell.
emptyCell :: TableCell
instance Typeable TableError
instance Show TableError
instance Eq BorderFlag
instance Show BorderFlag
instance Eq BorderStyle
instance Show BorderStyle
instance Eq ColumnSize
instance Show ColumnSize
instance Show ColumnSpec
instance Show Table
instance HasBorderAttr (Widget Table)
instance Monoid TableRow
instance RowLike a => RowLike [a]
instance Show a => RowLike (Widget a)
instance RowLike TableCell
instance RowLike TableRow
instance Alignable TableCell
instance Paddable TableCell
instance Alignable ColumnSpec
instance Paddable ColumnSpec
instance Show TableCell
instance Exception TableError


-- | This module provides a ''button'' widget type which has a button-like
--   appearance and generates ''press'' events. <a>Button</a>s are pressed
--   when a user presses Enter while the button has focus.
module Graphics.Vty.Widgets.Button
data Button

-- | Create a button. Get its underlying widget with <a>buttonWidget</a>.
newButton :: Text -> IO Button

-- | Get a reference to the button's widget to lay it out.
buttonWidget :: Button -> Widget Padded

-- | Register a handler for the button press event.
onButtonPressed :: Button -> (Button -> IO ()) -> IO ()

-- | Programmatically press a button to trigger its event handlers.
pressButton :: Button -> IO ()

-- | Set the text label on a button.
setButtonText :: Button -> Text -> IO ()
instance HasFocusAttr Button
instance HasNormalAttr Button


-- | This module provides a simple ''dialog'' interface with an ''OK''
--   button and a ''Cancel'' button. The dialog itself is capable of
--   embedding an arbitrary interface and it exposes ''accept'' and
--   ''cancel'' events which are triggered by the dialog's buttons.
module Graphics.Vty.Widgets.Dialog
data Dialog

-- | Create a new dialog with the specified embedded interface and title.
--   Returns the dialog itself and the <a>FocusGroup</a> to which its
--   buttons were added, for use in your application.
newDialog :: Show a => Widget a -> Text -> IO (Dialog, Widget FocusGroup)

-- | Register an event handler for the dialog's acceptance event.
onDialogAccept :: Dialog -> (Dialog -> IO ()) -> IO ()

-- | Register an event handler for the dialog's cancellation event.
onDialogCancel :: Dialog -> (Dialog -> IO ()) -> IO ()

-- | Programmatically accept the dialog.
acceptDialog :: Dialog -> IO ()

-- | Programmatically cancel the dialog.
cancelDialog :: Dialog -> IO ()
instance HasNormalAttr Dialog


-- | This module provides a ''progress bar'' widget which stores a progress
--   value between 0 and 100 inclusive and supports a text label. Use the
--   <tt>schedule</tt> function to modify the progress bar's state from a
--   thread.
module Graphics.Vty.Widgets.ProgressBar
data ProgressBar

-- | Create a new progress bar with the specified completed and uncompleted
--   attributes, respectively. The foreground of the attributes will be
--   used to show the progress bar's label, if any.
newProgressBar :: Attr -> Attr -> IO (Widget ProgressBar)

-- | Set the progress bar's progress value. Values outside the allowed
--   range will be ignored.
setProgress :: Widget ProgressBar -> Int -> IO ()

-- | Set the progress bar's text label alignment.
setProgressTextAlignment :: Widget ProgressBar -> Alignment -> IO ()

-- | Set the progress bar's text label.
setProgressText :: Widget ProgressBar -> Text -> IO ()

-- | Add a delta value to the progress bar's current value.
addProgress :: Widget ProgressBar -> Int -> IO ()

-- | Get the progress bar's current progress value.
getProgress :: Widget ProgressBar -> IO Int

-- | Register a handler to be invoked when the progress bar's progress
--   value changes. The handler will be passed the new progress value.
onProgressChange :: Widget ProgressBar -> (Int -> IO ()) -> IO ()
instance Show ProgressBar


-- | This module provides a directory browser interface widget. For full
--   details, please see the Vty-ui User's Manual.
module Graphics.Vty.Widgets.DirBrowser
data DirBrowser

-- | The collection of attributes and annotations used to determine the
--   browser's visual appearance.
data BrowserSkin
BrowserSkin :: Attr -> Attr -> Attr -> Attr -> Attr -> Attr -> Attr -> Attr -> Attr -> Bool -> Bool -> [(FilePath -> FileStatus -> Bool, FilePath -> FileStatus -> IO Text, Attr)] -> (FilePath -> FileStatus -> Bool) -> BrowserSkin

-- | Used for the header and footer areas of the interface.
browserHeaderAttr :: BrowserSkin -> Attr

-- | Used for the selected entry when the browser does not have focus.
browserUnfocusedSelAttr :: BrowserSkin -> Attr

-- | Used for the browser's error-reporting area.
browserErrorAttr :: BrowserSkin -> Attr

-- | Used for directory entries.
browserDirAttr :: BrowserSkin -> Attr

-- | Used for symbolic link entries.
browserLinkAttr :: BrowserSkin -> Attr

-- | Used for block device entries.
browserBlockDevAttr :: BrowserSkin -> Attr

-- | Used for named pipe entries.
browserNamedPipeAttr :: BrowserSkin -> Attr

-- | Used for device entries.
browserCharDevAttr :: BrowserSkin -> Attr

-- | Used for socket entries.
browserSockAttr :: BrowserSkin -> Attr

-- | Whether the browser header should be shown.
browserShowHeader :: BrowserSkin -> Bool

-- | Whether the browser footer should be shown.
browserShowFooter :: BrowserSkin -> Bool

-- | File annotations.
browserCustomAnnotations :: BrowserSkin -> [(FilePath -> FileStatus -> Bool, FilePath -> FileStatus -> IO Text, Attr)]

-- | The predicate which determines which entries get listed in the
--   browser.
browserIncludeEntry :: BrowserSkin -> FilePath -> FileStatus -> Bool
type DirBrowserWidgetType = Box (Box (Box FormattedText FormattedText) HFill) (Box (List [Char] (Box FormattedText FormattedText)) (Box (Box (Box FormattedText FormattedText) HFill) FormattedText))

-- | Create a directory browser widget with the specified skin. Returns the
--   browser itself along with its focus group.
newDirBrowser :: BrowserSkin -> IO (DirBrowser, Widget FocusGroup)

-- | Apply annotations to a browser skin.
withAnnotations :: BrowserSkin -> [(FilePath -> FileStatus -> Bool, FilePath -> FileStatus -> IO Text, Attr)] -> BrowserSkin

-- | Set the browser's current path.
setDirBrowserPath :: DirBrowser -> FilePath -> IO ()

-- | Get the browser's current path.
getDirBrowserPath :: DirBrowser -> IO FilePath

-- | The default browser skin with (hopefully) sane attribute defaults.
defaultBrowserSkin :: BrowserSkin

-- | Register handlers to be invoked when the user makes a selection.
onBrowseAccept :: DirBrowser -> (FilePath -> IO ()) -> IO ()

-- | Register handlers to be invoked when the user cancels browsing.
onBrowseCancel :: DirBrowser -> (FilePath -> IO ()) -> IO ()

-- | Register handlers to be invoked when the browser's path changes.
onBrowserPathChange :: DirBrowser -> (FilePath -> IO ()) -> IO ()

-- | Report an error in the browser's error-reporting area. Useful for
--   reporting application-specific errors with the user's file selection.
reportBrowserError :: DirBrowser -> Text -> IO ()

-- | Refresh the browser by reloading and displaying the contents of the
--   browser's current path.
refreshBrowser :: DirBrowser -> IO ()


-- | Widget groups. Useful for when you need to swap out many instances of
--   the same widget type in a specific location in an interface. A group
--   has a currently active widget which can be changed with
--   <a>setCurrentGroupEntry</a>. Add a widget to a group with
--   <a>addToGroup</a>; <a>addToGroup</a> returns an action which can be
--   used to set the specified widget as the group's active widget.
module Graphics.Vty.Widgets.Group

-- | A group of widgets of a specified type.
data Group a

-- | Create a new empty widget group.
newGroup :: Show a => IO (Widget (Group a))

-- | Add a widget to a group. Returns an action which, when evaluated, will
--   update the group state so that its currently-active widget is the one
--   passed to this function.
addToGroup :: Widget (Group a) -> Widget a -> IO (IO ())

-- | Set a group's current entry to the specified index. Use with care.
setCurrentGroupEntry :: Widget (Group a) -> Int -> IO ()
instance Show (Group a)


-- | This module provides the main event loop functionality for this
--   library. All vty-ui applications must use runUi to get anything done
--   usefully.
module Graphics.Vty.Widgets.EventLoop

-- | The type of user interface collections.
type Collection = IORef CollectionData
data CollectionError
BadCollectionIndex :: Int -> CollectionError

-- | Run the main vty-ui event loop using the specified interface
--   collection and initial rendering context. The rendering context
--   provides the default attributes and <tt>Skin</tt> to use for the
--   application. Throws <a>BadCollectionIndex</a> if the specified
--   <a>Collection</a> is empty.
runUi :: Collection -> RenderContext -> IO ()

-- | Schedule a widget-mutating <a>IO</a> action to be run by the main
--   event loop. Use of this function is required to guarantee consistency
--   between interface presentation and internal state.
schedule :: IO () -> IO ()

-- | Schedule a vty-ui event loop shutdown. This event will preempt others
--   so that it will be processed next.
shutdownUi :: IO ()

-- | Create a new collection.
newCollection :: IO Collection

-- | Add a widget and its focus group to a collection. Returns an action
--   which, when invoked, will switch to the interface specified in the
--   call.
addToCollection :: Show a => Collection -> Widget a -> Widget FocusGroup -> IO (IO ())

-- | Add a widget and its focus group to a collection. In addition, two
--   callbacks -- one to call when showing the widget and one to call when
--   hiding it (i.e. showing some other widget) -- must be provided.
--   Returns an action which, when invoked, will switch to the interface
--   specified.
addToCollectionWithCallbacks :: Show a => Collection -> Widget a -> Widget FocusGroup -> EntryShow -> EntryHide -> IO (IO ())
setCurrentEntry :: Collection -> Int -> IO ()
type EntryHide = IO ()
type EntryShow = IO ()
instance Typeable CollectionError
instance Show CollectionError
instance Show CollectionData
instance Exception CollectionError


-- | A convenience module exporting everything in this library.
module Graphics.Vty.Widgets.All
