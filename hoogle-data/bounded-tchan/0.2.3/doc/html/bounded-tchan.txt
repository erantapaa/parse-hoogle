-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Bounded Transactional channels (queues)
--   
--   Bounded TChan's, or BTChan's, are a transactional queue with a limit
--   to the number of elements (further calls to <tt>writeBTChan</tt> or
--   <tt>unGetBTChan</tt> call STM retry). Users are strongly encouraged to
--   consider using the more complete 'stm-chans' packages, which includes
--   a bounded TChan designed on this package.
@package bounded-tchan
@version 0.2.3

module Control.Concurrent.STM.BTChan

-- | A <a>BTChan</a> is a bounded <a>TChan</a> - a FIFO channel using
--   <a>TChan</a> and a transactional variable to limit the number of
--   elements on the channel.
data BTChan a

-- | <tt>newBTChan m</tt> make a new bounded TChan of max size <tt>m</tt>.
newBTChan :: Int -> STM (BTChan a)

-- | An IO version of <a>newBTChanIO</a>. This should be useful with
--   unsafePerformIO in the same manner as <a>newTVarIO</a> and
--   <a>newTChanIO</a> are used.
newBTChanIO :: Int -> IO (BTChan a)

-- | Writes the value to the <a>BTChan</a> or blocks if the channel is
--   full.
writeBTChan :: BTChan a -> a -> STM ()

-- | Reads the next value from the <a>BTChan</a>
readBTChan :: BTChan a -> STM a

-- | A non-blocking write that returns <a>True</a> if the write succeeded,
--   <a>False</a> otherwise.
tryWriteBTChan :: BTChan a -> a -> STM Bool

-- | A non-blocking read that returns 'Just a' on success and
--   <a>Nothing</a> when the channel is empty.
tryReadBTChan :: BTChan a -> STM (Maybe a)
unGetBTChan :: BTChan a -> a -> STM ()

-- | Returns <a>True</a> if the supplied <a>TChan</a> is empty.
isEmptyBTChan :: BTChan a -> STM Bool

-- | Get the current number of elements in the <a>BTChan</a>.
sizeOfBTChan :: BTChan a -> STM Int

-- | <tt>let c2 = setMaxOfBTChan c1 mx</tt> Using the same underlying
--   <a>TChan</a>, set a new maximum number of messages, <tt>mx</tt>. If
--   the current size is greater than <tt>mx</tt> then no messages are
--   dropped, but writes will block till the size goes lower than
--   <tt>mx</tt>. Using <tt>c2</tt> and <tt>c1</tt> concurrently is
--   possible, but <tt>c2</tt> writes will block at the new maximum while
--   writes to <tt>c1</tt> will block at the new, making it biased against
--   whichever writer has the channel with the smaller bound.
setMaxOfBTChan :: BTChan a -> Int -> BTChan a

-- | Get the bound of the <a>BTChan</a>.
maxOfBTChan :: BTChan a -> Int
