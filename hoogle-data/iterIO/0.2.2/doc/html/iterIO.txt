-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Iteratee-based IO with pipe operators
--   
--   Iteratee-based IO is an alternative to lazy IO that offers better
--   error handling, referential transparency, and convenient composition
--   of protocol layers or parsers. This package provides iteratees based
--   around <i>pipe</i> operators for hooking together application
--   components and directing data flow. New users should see the tutorial
--   in the <a>Data.IterIO</a> module documentation. Highlights of the
--   library include:
--   
--   <ul>
--   <li>Heavy emphasis on ease of use, ease of learning, and uniformity of
--   mechanism.</li>
--   <li>Copious documentation.</li>
--   <li>Consistent EOF and error handling to avoid resource leaks and
--   other issues in corner cases.</li>
--   <li>A set of iteratee parsing combinators providing LL(*) parsing
--   while generally not consuming large amounts of memory for
--   backtracking.</li>
--   <li>Seamless integration with attoparsec for LL(1) parsing.</li>
--   </ul>
--   
--   See <a>Data.IterIO</a> for a discussion of the differences between
--   iterIO and the two previous iteratee implementations (iteratee and
--   enumerator).
@package iterIO
@version 0.2.2

module Data.IterIO.Iter

-- | <tt>ChunkData</tt> is the class of data types that can be output by an
--   enumerator and iterated on with an iteratee. A <tt>ChunkData</tt> type
--   must be a <a>Monoid</a>, but must additionally provide a predicate,
--   <tt>null</tt>, for testing whether an object is equal to
--   <a>mempty</a>. Feeding a <tt>null</tt> chunk to an iteratee followed
--   by any other chunk should have the same effect as just feeding the
--   second chunk. To simplify debugging, there is an additional
--   requirement that <tt>ChunkData</tt> be convertable to a String with
--   the <tt>chunkShow</tt> method.
--   
--   Note that because the <a>Prelude</a> contains a function <a>null</a>
--   for lists, you may wish to include the import:
--   
--   <pre>
--   import Prelude hiding (null)
--   </pre>
class Monoid t => ChunkData t
null :: ChunkData t => t -> Bool
chunkShow :: ChunkData t => t -> String

-- | <tt>Chunk</tt> is a wrapper around a <a>ChunkData</a> type that also
--   includes an EOF flag that is <a>True</a> if the data is followed by an
--   end-of-file condition. An <a>Iter</a> that receives a <tt>Chunk</tt>
--   with EOF <a>True</a> must return a result (or failure); it is an error
--   to demand more data (return <a>IterF</a>) after an EOF.
data Chunk t
Chunk :: !t -> !Bool -> Chunk t

-- | Constructor function that builds a chunk containing data and a
--   <a>False</a> EOF flag.
chunk :: t -> Chunk t

-- | An chunk with <a>mempty</a> data and the EOF flag <a>True</a>.
chunkEOF :: Monoid t => Chunk t

-- | The basic Iteratee type is <tt>Iter t m a</tt>, where <tt>t</tt> is
--   the type of input (in class <a>ChunkData</a>), <tt>m</tt> is a monad
--   in which the iteratee may execute actions (using the <a>MonadTrans</a>
--   <a>lift</a> method), and <tt>a</tt> is the result type of the
--   iteratee.
--   
--   Internally, an <tt>Iter</tt> is a function from an input <a>Chunk</a>
--   to a result of type <a>IterR</a>.
newtype Iter t m a
Iter :: (Chunk t -> IterR t m a) -> Iter t m a
runIter :: Iter t m a -> Chunk t -> IterR t m a

-- | Class of control commands for enclosing enumerators. The class binds
--   each control argument type to a unique result type.
class (Typeable carg, Typeable cres) => CtlCmd carg cres | carg -> cres

-- | The outcome of an <a>IterC</a> request.
data CtlRes a

-- | The request type was not supported by the enumerator.
CtlUnsupp :: CtlRes a

-- | The request was supported, and executing it caused an exception to be
--   thrown.
CtlFail :: !SomeException -> CtlRes a

-- | The result of the control operation.
CtlDone :: !a -> CtlRes a

-- | Used when an <a>Iter</a> is issuing a control request to an enclosing
--   enumerator. Note that unlike <a>IterF</a> or <a>IterM</a>, control
--   requests expose the residual data, which is ordinarily fed right back
--   to the continuation upon execution of the request. This allows certain
--   control operations (such as seek and tell) to flush, check the length
--   of, or adjust the residual data.
data CtlArg t m a
CtlArg :: !carg -> (CtlRes cres -> Iter t m a) -> (Chunk t) -> CtlArg t m a

-- | Contains information about a failed <a>Iter</a>. Failures of type
--   <a>IterException</a> must be caught by <a>catchI</a> (or <a>tryI</a>,
--   etc.). However, any other type of failure is considered a parse error,
--   and will be caught by <a>multiParse</a>, <a>ifParse</a>, and
--   <a>mplus</a>.
data IterFail

-- | An actual error occured that is not a parse error, EOF, etc.
IterException :: !SomeException -> IterFail

-- | List of <tt>(input_seen, input_expected)</tt> pairs.
IterExpected :: [(String, String)] -> IterFail

-- | An EOF error occurred, either in some IO action wrapped by
--   <a>liftIO</a>, or in some <a>Iter</a> that called <a>throwEOFI</a>.
IterEOFErr :: IOError -> IterFail

-- | A miscellaneous parse error occured.
IterParseErr :: String -> IterFail

-- | What you get from <a>mzero</a>. Useful if you don't want to specify
--   any information about the failure.
IterMzero :: IterFail

-- | An <tt>IterR</tt> is the result of feeding a chunk of data to an
--   <a>Iter</a>. An <tt>IterR</tt> is in one of several states: it may
--   require more input (<a>IterF</a>), it may wish to execute monadic
--   actions in the transformed monad (<a>IterM</a>), it may have a control
--   request for an enclosing enumerator (<a>IterC</a>), it may have
--   produced a result (<a>Done</a>), or it may have failed (<a>Fail</a>).
data IterR t m a

-- | The iteratee requires more input.
IterF :: !Iter t m a -> IterR t m a

-- | The iteratee must execute monadic bind in monad <tt>m</tt>
IterM :: !m (IterR t m a) -> IterR t m a

-- | A control request (see <a>CtlArg</a>).
IterC :: !CtlArg t m a -> IterR t m a

-- | Sufficient input was received; the <a>Iter</a> is returning a result
--   of type <tt>a</tt>. In adition, the <a>IterR</a> has a <a>Chunk</a>
--   containing any residual input that was not consumed in producing the
--   result.
Done :: a -> (Chunk t) -> IterR t m a

-- | The <a>Iter</a> failed. If it was an enumerator, the target
--   <a>Iter</a> that the enumerator was feeding likely has not failed, in
--   which case its current state is returned in the <tt>Maybe a</tt>. If
--   it makes sense to preserve the state of the input stream (which it
--   does for most errors except parse errors), then the third parameter
--   includes the residual <a>Chunk</a> at the time of the failure.
Fail :: !IterFail -> !Maybe a -> !Maybe (Chunk t) -> IterR t m a

-- | Builds an <a>Iter</a> that keeps requesting input until it receives a
--   non-<a>null</a> <a>Chunk</a>. In other words, the <a>Chunk</a> fed to
--   the argument function is guaranteed either to contain data or to have
--   the EOF flag true (or both).
iterF :: ChunkData t => (Chunk t -> IterR t m a) -> Iter t m a

-- | True if an <a>IterR</a> is requesting something from an
--   enumerator--i.e., the <a>IterR</a> is not <a>Done</a> or <a>Fail</a>.
isIterActive :: IterR t m a -> Bool

-- | Show the current state of an <a>IterR</a>, prepending it to some
--   remaining input (the standard <a>ShowS</a> optimization), when
--   <tt>a</tt> is in class <a>Show</a>. Note that if <tt>a</tt> is not in
--   <a>Show</a>, you can simply use the <a>shows</a> function.
iterShows :: (ChunkData t, Show a) => IterR t m a -> ShowS

-- | Show the current state of an <a>Iter</a> if type <tt>a</tt> is in the
--   <a>Show</a> class. (Otherwise, you can simply use the ordinary
--   <a>show</a> function.)
iterShow :: (ChunkData t, Show a) => IterR t m a -> String

-- | Feed an EOF to an <a>Iter</a> and return the result. Throws an
--   exception if there has been a failure.
run :: (ChunkData t, Monad m) => Iter t m a -> m a

-- | Runs an <a>Iter</a> from within a different <a>Iter</a> monad. If
--   successful, <tt>runI iter</tt> will produce the same result as
--   <tt><a>lift</a> (<a>run</a> iter)</tt>. However, if <tt>iter</tt>
--   fails, <a>run</a> throws a language-level exception, which cannot be
--   caught within other <a>Iter</a> monads. By contrast, <tt>runI</tt>
--   throws a monadic exception that can be caught. In short, use
--   <tt>runI</tt> in preference to <tt>run</tt> in situations where both
--   are applicable. See a more detailed discussion of the same issue with
--   examples in the documentation for <tt><tt>.|$</tt></tt> in
--   <a>Data.IterIO.Inum</a>.
runI :: (ChunkData t1, ChunkData t2, Monad m) => Iter t1 m a -> Iter t2 m a

-- | Make an <a>IterEOFErr</a> from a String.
mkIterEOF :: String -> IterFail

-- | Exception thrown by <tt>CtlI</tt> when the type of the control request
--   is not supported by the enclosing enumerator.
data IterCUnsupp
IterCUnsupp :: carg -> IterCUnsupp

-- | Throw an exception from an Iteratee. The exception will be propagated
--   properly through nested Iteratees, which will allow it to be
--   categorized properly and avoid situations in which resources such as
--   file handles are not released. (Most iteratee code does not assume the
--   Monad parameter <tt>m</tt> is in the <a>MonadIO</a> class, and hence
--   cannot use <a>catch</a> or <tt><tt>onException</tt></tt> to clean up
--   after exceptions.) Use <a>throwI</a> in preference to <a>throw</a>
--   whenever possible.
--   
--   Do not use <tt>throwI</tt> to throw parse errors or EOF errors. Use
--   <a>throwEOFI</a> and <a>throwParseI</a> instead. For performance
--   reasons, the <a>IterFail</a> type segregates EOF and parse errors from
--   other types of failures.
throwI :: Exception e => e -> Iter t m a

-- | Throw an exception of type <tt>IterEOF</tt>. This will be interpreted
--   by <tt>mkInum</tt> as an end of file chunk when thrown by the codec.
--   It will also be interpreted by <a>ifParse</a> and <a>multiParse</a> as
--   parsing failure. If not caught within the <a>Iter</a> monad, the
--   exception will be rethrown by <a>run</a> (and hence <tt>|$</tt>) as an
--   <a>IOError</a> of type EOF.
throwEOFI :: String -> Iter t m a

-- | Throw a miscellaneous parse error (after which input is assumed to be
--   unsynchronized and thus is discarded). Parse errors may be caught as
--   exception type <a>IterFail</a>, but they can also be caught more
--   efficiently by the functions <a>multiParse</a>, <a>ifParse</a>, and
--   <a>mplus</a>.
throwParseI :: String -> Iter t m a

-- | Catch an exception thrown by an <a>Iter</a>, including exceptions
--   thrown by any <tt>Inum</tt>s fused to the <a>Iter</a> (or applied to
--   it with <tt>.|$</tt>). If you wish to catch just errors thrown within
--   <tt>Inum</tt>s, see the function <tt><tt>inumCatch</tt></tt> in
--   <a>Data.IterIO.Inum</a>.
--   
--   On exceptions, <tt>catchI</tt> invokes a handler passing it both the
--   exception thrown and the state of the failing <a>IterR</a>, which may
--   contain more information than just the exception. In particular, if
--   the exception occured in an <tt>Inum</tt>, the returned <a>IterR</a>
--   will also contain the <a>IterR</a> being fed by that <tt>Inum</tt>,
--   which likely will not have failed. To avoid discarding this extra
--   information, you should not re-throw exceptions with <a>throwI</a>.
--   Rather, you should re-throw an exception by re-executing the failed
--   <a>IterR</a> with <a>reRunIter</a>. For example, a possible definition
--   of <a>onExceptionI</a> is:
--   
--   <pre>
--   onExceptionI iter cleanup =
--       iter `catchI` \(<a>SomeException</a> _) r -&gt; cleanup &gt;&gt; <a>reRunIter</a> r
--   </pre>
--   
--   Note that <tt>catchI</tt> only works for <i>synchronous</i>
--   exceptions, such as IO errors (thrown within <a>liftIO</a> blocks),
--   the monadic <a>fail</a> operation, and exceptions raised by
--   <a>throwI</a>. It is not possible to catch <i>asynchronous</i>
--   exceptions, such as lazily evaluated divide-by-zero errors, the
--   <a>throw</a> function, or exceptions raised by other threads using
--   <tt><tt>throwTo</tt></tt> if those exceptions might arrive anywhere
--   outside of a <a>liftIO</a> call.
--   
--   <tt>`catchI`</tt> has the default infix precedence (<tt>infixl 9
--   `catchI`</tt>), which binds more tightly than any concatenation or
--   fusing operators.
catchI :: (Exception e, ChunkData t, Monad m) => Iter t m a -> (e -> IterR t m a -> Iter t m a) -> Iter t m a

-- | Like catchI, but catches only what are considered to be parse
--   errors--that is, every constructor of <a>IterFail</a> except
--   <a>IterException</a>.
catchPI :: (ChunkData t, Monad m) => Iter t m a -> (IterFail -> Iter t m a) -> Iter t m a

-- | If an <a>Iter</a> succeeds and returns <tt>a</tt>, returns
--   <tt><a>Right</a> a</tt>. If the <a>Iter</a> fails and throws an
--   exception <tt>e</tt> (of type <tt>e</tt>), returns <tt><a>Left</a> (e,
--   r)</tt> where <tt>r</tt> is the state of the failing <a>Iter</a>.
tryI :: (ChunkData t, Monad m, Exception e) => Iter t m a -> Iter t m (Either (e, IterR t m a) a)

-- | A varient of <a>tryI</a> that returns the <a>IterFail</a> state rather
--   than trying to match a particular exception.
tryFI :: (ChunkData t, Monad m) => Iter t m a -> Iter t m (Either IterFail a)

-- | A version of <a>tryI</a> that catches all exceptions. Instead of
--   returning the exception caught, it returns the failing <a>IterR</a>
--   (from which you can extract the exception if you really want it). The
--   main use of this is for doing some kind of clean-up action, then
--   re-throwing the exception with <a>reRunIter</a>.
--   
--   For example, the following is a possible implementation of
--   <a>finallyI</a>:
--   
--   <pre>
--   finallyI iter cleanup = do
--     er &lt;- tryRI iter
--     cleanup
--     either reRunIter return er
--   </pre>
tryRI :: (ChunkData t, Monad m) => Iter t m a -> Iter t m (Either (IterR t m a) a)

-- | A variant of <a>tryI</a> that just catches EOF errors. Returns
--   <a>Nothing</a> after an EOF error, and <a>Just</a> the result
--   otherwise. Should be much faster than trying to catch an EOF error of
--   type <a>Exception</a>.
tryEOFI :: (ChunkData t, Monad m) => Iter t m a -> Iter t m (Maybe a)

-- | Execute an <a>Iter</a>, then perform a cleanup action regardless of
--   whether the <a>Iter</a> threw an exception or not. Analogous to the
--   standard library function <tt><tt>finally</tt></tt>.
finallyI :: (ChunkData t, Monad m) => Iter t m a -> Iter t m b -> Iter t m a

-- | Execute an <a>Iter</a> and perform a cleanup action if the <a>Iter</a>
--   threw an exception. Analogous to the standard library function
--   <tt><tt>onException</tt></tt>.
onExceptionI :: (ChunkData t, Monad m) => Iter t m a -> Iter t m b -> Iter t m a

-- | Simlar to <a>tryI</a>, but saves all data that has been fed to the
--   <a>Iter</a>, and rewinds the input if the <a>Iter</a> fails. (The
--   <tt>B</tt> in <tt>tryBI</tt> stands for "backtracking".) Thus, if
--   <tt>tryBI</tt> returns <tt><a>Left</a> exception</tt>, the next
--   <a>Iter</a> to be invoked will see the same input that caused the
--   previous <a>Iter</a> to fail. (For this reason, it makes no sense ever
--   to call <tt><tt>resumeI</tt></tt> on the <a>Iter</a> you get back from
--   <tt>tryBI</tt>, which is why <tt>tryBI</tt> does not return the
--   failing Iteratee the way <a>tryI</a> does.)
--   
--   Because <tt>tryBI</tt> saves a copy of all input, it can consume a lot
--   of memory and should only be used when the <a>Iter</a> argument is
--   known to consume a bounded amount of data.
tryBI :: (ChunkData t, Monad m, Exception e) => Iter t m a -> Iter t m (Either e a)

-- | A variant of <a>tryBI</a> that, also rewinds input on failure, but
--   returns the raw <a>IterFail</a> structure, rather than mapping it to a
--   particular exception. This is much faster because it requires no
--   dynamic casts. However, the same warning applies that <tt>tryFBI</tt>
--   should not be applied to <a>Iter</a>s that could take unbounded input.
tryFBI :: (ChunkData t, Monad m) => Iter t m a -> Iter t m (Either IterFail a)

-- | <tt>ifParse iter success failure</tt> runs <tt>iter</tt>, but saves a
--   copy of all input consumed using <a>tryFBI</a>. (This means
--   <tt>iter</tt> must not consume unbounded amounts of input! See
--   <a>multiParse</a> for such cases.) If <tt>iter</tt> succeeds, its
--   result is passed to the function <tt>success</tt>. If <tt>iter</tt>
--   throws a parse error (with <a>throwParseI</a>), throws an EOF error
--   (with <a>throwEOFI</a>), or executes <a>mzero</a>, then
--   <tt>failure</tt> is executed with the input re-wound (so that
--   <tt>failure</tt> is fed the same input that <tt>iter</tt> was). If
--   <tt>iter</tt> throws any other type of exception, <tt>ifParse</tt>
--   passes the exception back and does not execute <tt>failure</tt>.
--   
--   See <a>Data.IterIO.Parse</a> for a discussion of this function and the
--   related infix operator <tt>\/</tt> (which is a synonym for
--   <a>ifNoParse</a>).
ifParse :: (ChunkData t, Monad m) => Iter t m a -> (a -> Iter t m b) -> Iter t m b -> Iter t m b

-- | <tt>ifNoParse</tt> is just <a>ifParse</a> with the second and third
--   arguments reversed.
ifNoParse :: (ChunkData t, Monad m) => Iter t m a -> Iter t m b -> (a -> Iter t m b) -> Iter t m b

-- | Try two Iteratees and return the result of executing the second if the
--   first one throws a parse, EOF, or <a>mzero</a> error. Note that
--   <a>Data.IterIO.Parse</a> defines <tt><tt>&lt;|&gt;</tt></tt> as an
--   infix synonym for this function.
--   
--   The statement <tt>multiParse a b</tt> is similar to <tt><a>ifParse</a>
--   a return b</tt>, but the two functions operate differently. Depending
--   on the situation, only one of the two formulations may be correct.
--   Specifically:
--   
--   <ul>
--   <li><tt><a>ifParse</a> a f b</tt> works by first executing <tt>a</tt>,
--   saving a copy of all input consumed by <tt>a</tt>. If <tt>a</tt>
--   throws a parse error, the saved input is used to backtrack and execute
--   <tt>b</tt> on the same input that <tt>a</tt> just rejected. If
--   <tt>a</tt> succeeds, <tt>b</tt> is never run; <tt>a</tt>'s result is
--   fed to <tt>f</tt>, and the resulting action is executed without
--   backtracking (so any error thrown within <tt>f</tt> will not be caught
--   by this <a>ifParse</a> expression).</li>
--   <li>Instead of saving input, <tt>multiParse a b</tt> executes both
--   <tt>a</tt> and <tt>b</tt> concurrently as input chunks arrive. If
--   <tt>a</tt> throws a parse error, then the result of executing
--   <tt>b</tt> is returned. If <tt>a</tt> either succeeds or throws an
--   exception that is not a parse error/EOF/<a>mzero</a>, then the result
--   of running <tt>a</tt> is returned.</li>
--   <li>With <tt>multiParse a b</tt>, if <tt>b</tt> returns a value,
--   executes a monadic action via <a>lift</a>, or issues a control request
--   via <a>ctlI</a>, then further processing of <tt>b</tt> will be
--   suspended until <tt>a</tt> experiences a parse error, and thus the
--   behavior will be equivalent to <tt><a>ifParse</a> a return
--   b</tt>.</li>
--   </ul>
--   
--   The main restriction on <a>ifParse</a> is that <tt>a</tt> must not
--   consume unbounded amounts of input, or the program may exhaust memory
--   saving the input for backtracking. Note that the second argument to
--   <a>ifParse</a> (i.e., <a>return</a> in <tt>ifParse a return b</tt>) is
--   a continuation for <tt>a</tt> when <tt>a</tt> succeeds.
--   
--   The advantage of <tt>multiParse</tt> is that it can avoid storing
--   unbounded amounts of input for backtracking purposes if both
--   <a>Iter</a>s consume data. Another advantage is that with an
--   expression such as <tt><a>ifParse</a> a f b</tt>, sometimes it is not
--   convenient to break the parse target into an action to execute with
--   backtracking (<tt>a</tt>) and a continuation to execute without
--   backtracking (<tt>f</tt>). The equivalent <tt>multiParse (a &gt;&gt;=
--   f) b</tt> avoids the need to do this, since it does not do
--   backtracking.
--   
--   However, it is important to note that it is still possible to end up
--   storing unbounded amounts of input with <tt>multiParse</tt>. For
--   example, consider the following code:
--   
--   <pre>
--   total :: (Monad m) =&gt; Iter String m Int
--   total = multiParse parseAndSumIntegerList (return -1) -- Bad
--   </pre>
--   
--   Here the intent is for <tt>parseAndSumIntegerList</tt> to parse a
--   (possibly huge) list of integers and return their sum. If there is a
--   parse error at any point in the input, then the result is identical to
--   having defined <tt>total = return -1</tt>. But <tt>return -1</tt>
--   succeeds immediately, consuming no input, which means that
--   <tt>total</tt> must return all left-over input for the next action
--   (i.e., <tt>next</tt> in <tt>total &gt;&gt;= next</tt>). Since
--   <tt>total</tt> has to look arbitrarily far into the input to determine
--   that <tt>parseAndSumIntegerList</tt> fails, in practice <tt>total</tt>
--   will have to save all input until it knows that
--   <tt>parseAndSumIntegerList</tt> succeeds.
--   
--   A better approach might be:
--   
--   <pre>
--   total = multiParse parseAndSumIntegerList (<a>nullI</a> &gt;&gt; return -1)
--   </pre>
--   
--   Here <a>nullI</a> discards all input until an EOF is encountered, so
--   there is no need to keep a copy of the input around. This makes sense
--   so long as <tt>total</tt> is the last or only Iteratee run on the
--   input stream. (Otherwise, <a>nullI</a> would have to be replaced with
--   an Iteratee that discards input up to some end-of-list marker.)
--   
--   Another approach might be to avoid parsing combinators entirely and
--   use:
--   
--   <pre>
--   total = parseAndSumIntegerList `<a>catchPI</a>` handler
--       where handler _ = return -1
--   </pre>
--   
--   This last definition of <tt>total</tt> may leave the input in some
--   partially consumed state. This is fine so long as <tt>total</tt> is
--   the last <a>Iter</a> executed on the input stream. Otherwise, before
--   throwing the parse error, <tt>parseAndSumIntegerList</tt> would need
--   to ensure the input is at some reasonable boundary point for whatever
--   comes next. (The <a>ungetI</a> function is sometimes helpful for this
--   purpose.)
multiParse :: (ChunkData t, Monad m) => Iter t m a -> Iter t m a -> Iter t m a

-- | Sinks data like <tt>/dev/null</tt>, returning <tt>()</tt> on EOF.
nullI :: (Monad m, ChunkData t) => Iter t m ()

-- | Returns a non-empty amount of input data if there is any input left.
--   Returns <a>mempty</a> on an EOF condition.
data0I :: ChunkData t => Iter t m t

-- | Like <a>data0I</a>, but always returns non-empty data. Throws an
--   exception on an EOF condition.
dataI :: ChunkData t => Iter t m t

-- | A variant of <a>data0I</a> that reads the whole input up to an EOF and
--   returns it.
pureI :: (Monad m, ChunkData t) => Iter t m t

-- | Returns the next <a>Chunk</a> that either contains non-<a>null</a>
--   data or has the EOF bit set.
chunkI :: (Monad m, ChunkData t) => Iter t m (Chunk t)

-- | Run an <a>Iter</a> returning data of class <a>ChunkData</a> and throw
--   an EOF exception if the data is <a>null</a>. (Note that this is
--   different from the <tt><tt>some</tt></tt> method of the
--   <tt><tt>Alternative</tt></tt> class in <a>Control.Applicative</a>,
--   which executes a computation one <i>or more</i> times. The iterIO
--   library does not use <tt><tt>Alternative</tt></tt>, in part because
--   <tt><tt>Alternative</tt></tt>'s <tt>&lt;|&gt;</tt> operator has left
--   rather than right fixity, which would make parsing less efficient. See
--   <a>Data.IterIO.Parse</a> for information about iterIO's
--   <tt>&lt;|&gt;</tt> operator.)
someI :: (ChunkData tOut, Monad m) => Iter tIn m tOut -> Iter tIn m tOut

-- | Keep running an <a>Iter</a> until either its output is not <a>null</a>
--   or we have reached EOF. Return the the <a>Iter</a>'s value on the last
--   (i.e., usually non-<a>null</a>) iteration.
whileNullI :: (ChunkData tIn, ChunkData tOut, Monad m) => Iter tIn m tOut -> Iter tIn m tOut

-- | Runs an <a>Iter</a> then rewinds the input state, so that the effect
--   is to parse lookahead data. (See <a>tryBI</a> if you want to rewind
--   the input only when the <a>Iter</a> fails.)
peekI :: (ChunkData t, Monad m) => Iter t m a -> Iter t m a

-- | Does not actually consume any input, but returns <a>True</a> if there
--   is no more input data to be had.
atEOFI :: (Monad m, ChunkData t) => Iter t m Bool

-- | Place data back onto the input stream, where it will be the next data
--   consumed by subsequent <a>Iter</a>s.
ungetI :: ChunkData t => t -> Iter t m ()

-- | Issue a control request. Returns <a>CtlUnsupp</a> if the request type
--   is unsupported. Otherwise, returns <a>CtlDone</a> with the result if
--   the request succeeds, or return <tt><a>CtlFail</a></tt> if the request
--   type is supported but attempting to execute the request caused an
--   exception.
safeCtlI :: (CtlCmd carg cres, Monad m) => carg -> Iter t m (CtlRes cres)

-- | Issue a control request and return the result. Throws an exception of
--   type <a>IterCUnsupp</a> if the operation type was not supported by an
--   enclosing enumerator.
ctlI :: (CtlCmd carg cres, ChunkData t, Monad m) => carg -> Iter t m cres

-- | Run an <a>Iter</a> until it enters the <a>Done</a> or <a>Fail</a>
--   state, then use a function to transform the <a>IterR</a>.
onDone :: Monad m => (IterR t m a -> IterR t m b) -> Iter t m a -> Iter t m b

-- | <tt>fmapI</tt> is like <a>liftM</a>, but differs in one important
--   respect: it preserves the failed result of an enumerator (and in fact
--   applies the function to the non-failed target <a>Iter</a> state). By
--   contrast, <a>liftM</a>, which is equivalent to <tt><a>liftM</a> f i =
--   i <a>&gt;&gt;=</a> <a>return</a> . f</tt>, transforms the
--   <tt><a>Maybe</a> a</tt> component of all <a>Fail</a> states to
--   <a>Nothing</a> because of its use of <a>&gt;&gt;=</a>.
fmapI :: Monad m => (a -> b) -> Iter t m a -> Iter t m b

-- | The equivalent of <a>onDone</a> for <a>IterR</a>s.
onDoneR :: Monad m => (IterR t m a -> IterR t m b) -> IterR t m a -> IterR t m b

-- | Step an active <a>IterR</a> (i.e., one in the <a>IterF</a>,
--   <a>IterM</a>, or <a>IterC</a> state) to its next state, and pass the
--   result through a function.
stepR :: Monad m => IterR t m a -> (IterR t m a -> IterR t m b) -> IterR t m b -> IterR t m b

-- | A variant of <a>stepR</a> that only works for the <a>IterF</a> and
--   <a>IterC</a> states, not the <a>IterM</a> state. (Because of this
--   additional restriction, the input and output <a>Monad</a> types
--   <tt>m1</tt> and <tt>m2</tt> do not need to be the same.)
stepR' :: IterR t m1 a -> (IterR t m1 a -> IterR t m2 b) -> IterR t m2 b -> IterR t m2 b

-- | The equivalent for <a>runI</a> for <a>IterR</a>s.
runR :: (ChunkData t1, ChunkData t2, Monad m) => IterR t1 m a -> IterR t2 m a

-- | Maps the result of an <a>IterR</a> like <a>fmap</a>, but only if the
--   <a>IterR</a> is no longer active. It is an error to call this function
--   on an <a>IterR</a> in the <a>IterF</a>, <a>IterM</a>, or <a>IterC</a>
--   state. Because of this restriction, <tt>fmapR</tt> does not require
--   the input and output <a>Monad</a> types (<tt>m1</tt> and <tt>m2</tt>)
--   to be the same.
fmapR :: (a -> b) -> IterR t m1 a -> IterR t m2 b

-- | Turn an <a>IterR</a> back into an <a>Iter</a>.
reRunIter :: (ChunkData t, Monad m) => IterR t m a -> Iter t m a

-- | Feed more input to an <a>Iter</a> that has already been run (and hence
--   is already an <a>IterR</a>). In the event that the <a>IterR</a> is
--   requesting more input (i.e., is in the <a>IterF</a> state), this is
--   straight forward. However, if the <a>Iter</a> is in some other state
--   such as <a>IterM</a>, this function needs to save the input until such
--   time as the <a>IterR</a> is stepped to a new state (e.g., with
--   <a>stepR</a> or <a>reRunIter</a>).
runIterR :: (ChunkData t, Monad m) => IterR t m a -> Chunk t -> IterR t m a

-- | Get the residual data for an <a>IterR</a> that is in no longer active
--   or that is in the <a>IterC</a> state. (It is an error to call this
--   function on an <a>IterR</a> in the <a>IterF</a> or <a>IterM</a>
--   state.)
getResid :: ChunkData t => IterR t m a -> Chunk t

-- | Set residual data for an <a>IterR</a> that is not active. (It is an
--   error to call this on an <a>IterR</a> in the <a>Done</a>,
--   <a>IterM</a>, or <a>IterC</a> states.)
setResid :: IterR t1 m1 a -> Chunk t2 -> IterR t2 m2 a
instance Typeable1 Chunk
instance Typeable1 CtlRes
instance Typeable IterFail
instance Typeable IterCUnsupp
instance Eq t => Eq (Chunk t)
instance Exception IterCUnsupp
instance Show IterCUnsupp
instance MonadIO m => MonadFix (Iter t m)
instance MonadIO m => MonadIO (Iter t m)
instance MonadTrans (Iter t)
instance (ChunkData t, Monad m) => MonadPlus (Iter t m)
instance Monad m => Monad (Iter t m)
instance Monad m => Applicative (Iter t m)
instance Monad m => Functor (IterR t m)
instance Monad m => Functor (Iter t m)
instance (Typeable t, Typeable1 m, Typeable a) => Typeable (Iter t m a)
instance (Typeable t, Typeable1 m) => Typeable1 (Iter t m)
instance ChunkData t => Show (IterR t m a)
instance Exception IterFail
instance Show IterFail
instance ChunkData t => ChunkData (Chunk t)
instance ChunkData t => Monoid (Chunk t)
instance Functor Chunk
instance ChunkData t => Show (Chunk t)
instance ChunkData ()
instance ChunkData ByteString
instance ChunkData ByteString
instance Show a => ChunkData [a]


-- | This module contains various helper functions and instances for using
--   <a>Iter</a>s of different <a>Monad</a>s together in the same pipeline.
--   For example, as-is the following code is illegal:
--   
--   <pre>
--   iter1 :: <a>Iter</a> String IO Bool
--   iter1 = ...
--   
--   iter2 :: <a>Iter</a> String (<a>StateT</a> MyState IO) ()
--   iter2 = do ...
--              s &lt;- iter1 -- ILLEGAL: iter1 is in wrong monad
--              ...
--   </pre>
--   
--   You can't invoke <tt>iter1</tt> from within <tt>iter2</tt> because the
--   <a>Iter</a> type is wrapped around a different <a>Monad</a> in each
--   case. However, the function <a>liftI</a> exactly solves this problem:
--   
--   <pre>
--   s &lt;- liftI iter1
--   </pre>
--   
--   Conversely, you may be in a <a>Monad</a> like <tt><a>Iter</a> String
--   IO</tt> and need to invoke a computation that requires some other
--   monad functionality, such as a reader. There are a number of
--   iteratee-specific runner functions that help you run other
--   <a>MonadTrans</a> transformers inside the <a>Iter</a> monad. These
--   typically use the names of the runner functions in the mtl library,
--   but with an <tt>I</tt> appended--for instance <a>runReaderTI</a>,
--   <a>runStateTI</a>, <a>runWriterTI</a>. Here's a fuller example of
--   adapting the inner <a>Iter</a> <a>Monad</a>. The example also
--   illustrates that <tt><a>Iter</a> t m</tt> is member any mtl classes
--   (such as <a>MonadReader</a> and <a>MonadState</a>) that <tt>m</tt> is.
--   
--   <pre>
--   iter1 :: Iter String (<a>ReaderT</a> MyState IO) Bool
--   iter1 = do
--     s &lt;- <a>ask</a>
--     liftIO $ (<a>putStrLn</a> (<a>show</a> s) &gt;&gt; return True)
--           `<a>catch</a>` (<tt>SomeException</tt> _) -&gt; return False
--   
--   iter2 :: Iter String (<a>StateT</a> MyState IO) ()
--   iter2 = do
--     s &lt;- <a>get</a>
--     ok &lt;- <a>liftI</a> $ <a>runReaderTI</a> iter1 s
--     if ok then return () else fail "iter1 failed"
--   </pre>
module Data.IterIO.Trans

-- | Run an <tt><a>Iter</a> s m</tt> computation from witin the
--   <tt><a>Iter</a> s (t m)</tt> monad, where <tt>t</tt> is a
--   <a>MonadTrans</a>.
liftI :: (MonadTrans t, Monad m, Monad (t m), ChunkData s) => Iter s m a -> Iter s (t m) a

-- | Run an <tt><a>Iter</a> t IO</tt> computation from within an
--   <tt><a>Iter</a> t m</tt> monad where <tt>m</tt> is in class
--   <a>MonadIO</a>.
liftIterIO :: (ChunkData t, MonadIO m) => Iter t IO a -> Iter t m a

-- | Turn a computation of type <tt><a>Iter</a> t (<a>ContT</a>
--   (<a>Iter</a> t m a) m) a</tt> into one of type <tt><a>Iter</a> t m
--   a</tt>. Note the continuation has to return type <tt><a>Iter</a> t m
--   a</tt> and not <tt>a</tt> so that runContTI can call itself
--   recursively.
runContTI :: (ChunkData t, Monad m) => Iter t (ContT (Iter t m a) m) a -> Iter t m a

-- | Run a computation of type <tt><a>Iter</a> t (<a>ErrorT</a> e m)</tt>
--   from within the <tt><a>Iter</a> t m</tt> monad. This function is here
--   for completeness, but please consider using <a>throwI</a> instead,
--   since the <a>Iter</a> monad already has built-in exception handling
--   and it's best to have a single, uniform approach to error reporting.
runErrorTI :: (Monad m, ChunkData t, Error e) => Iter t (ErrorT e m) a -> Iter t m (Either e a)

-- | Run an <tt><a>Iter</a> t (<a>ListT</a> m)</tt> computation from within
--   the <tt><a>Iter</a> t m</tt> monad.
runListTI :: (Monad m, ChunkData t) => Iter t (ListT m) a -> Iter t m [a]

-- | Run an <tt><a>Iter</a> t (<a>ReaderT</a> r m)</tt> computation from
--   within the <tt><a>Iter</a> t m</tt> monad.
runReaderTI :: (ChunkData t, Monad m) => Iter t (ReaderT r m) a -> r -> Iter t m a

-- | Run an <tt><a>Iter</a> t (<a>RWST</a> r w s m)</tt> computation from
--   within the <tt><a>Iter</a> t m</tt> monad.
runRWSI :: (ChunkData t, Monoid w, Monad m) => Iter t (RWST r w s m) a -> r -> s -> Iter t m (a, s, w)

-- | Run an <tt><a>Iter</a> t (<a>RWST</a> r w s m)</tt> computation from
--   within the <tt><a>Iter</a> t m</tt> monad. Just like <a>runRWSI</a>,
--   execpt this function is for <i>Lazy</i> <a>RWST</a> rather than strict
--   <a>RWST</a>.
runRWSLI :: (ChunkData t, Monoid w, Monad m) => Iter t (RWST r w s m) a -> r -> s -> Iter t m (a, s, w)

-- | Run an <tt><a>Iter</a> t (<a>StateT</a> m)</tt> computation from
--   within the <tt><a>Iter</a> t m</tt> monad.
runStateTI :: (ChunkData t, Monad m) => Iter t (StateT s m) a -> s -> Iter t m (a, s)

-- | Run an <tt><a>Iter</a> t (<a>StateT</a> m)</tt> computation from
--   within the <tt><a>Iter</a> t m</tt> monad. Just like
--   <a>runStateTI</a>, except this function works on <i>Lazy</i>
--   <a>StateT</a> rather than strict <a>StateT</a>.
runStateTLI :: (ChunkData t, Monad m) => Iter t (StateT s m) a -> s -> Iter t m (a, s)

-- | Run an <tt><a>Iter</a> t (<a>WriterT</a> w m)</tt> computation from
--   within the <tt><a>Iter</a> t m</tt> monad.
runWriterTI :: (ChunkData t, Monoid w, Monad m) => Iter t (WriterT w m) a -> Iter t m (a, w)

-- | Run an <tt><a>Iter</a> t (<a>WriterT</a> w m)</tt> computation from
--   within the <tt><a>Iter</a> t m</tt> monad. This is the same as
--   <a>runWriterT</a> but for the <i>Lazy</i> <a>WriterT</a>, rather than
--   the strict one.
runWriterTLI :: (ChunkData t, Monoid w, Monad m) => Iter t (WriterT w m) a -> Iter t m (a, w)

-- | Adapt an <a>Iter</a> from one monad to another. This function is the
--   lowest-level monad adapter function, upon which all of the other
--   adapters are built. <tt>adaptIter</tt> requires two functions as
--   arguments. One adapts the result to a new type (if required). The
--   second adapts monadic computations from one monad to the other. For
--   example, <a>liftI</a> could be implemented as:
--   
--   <pre>
--   liftI :: (<a>MonadTrans</a> t, Monad m, Monad (t m), <a>ChunkData</a> s) =&gt;
--            <a>Iter</a> s m a -&gt; <a>Iter</a> s (t m) a
--   liftI = adaptIter <a>id</a> (\m -&gt; <a>lift</a> (<a>lift</a> m) &gt;&gt;= liftI)
--   </pre>
--   
--   Here <tt><a>lift</a> (<a>lift</a> m)</tt> executes a computation
--   <tt>m</tt> of type <tt>m (<a>Iter</a> s m a)</tt> from within the
--   <tt><a>Iter</a> s (t m)</tt> monad. The result, of type
--   <tt><a>Iter</a> s m a</tt>, can then be fed back into <tt>liftI</tt>
--   recursively.
--   
--   Note that in general a computation adapters must invoke the outer
--   adapter function recursively. <tt>adaptIter</tt> is designed this way
--   because the result adapter function may need to change. An example is
--   <a>runStateTI</a>, which could be implemented as follows:
--   
--   <pre>
--   runStateTI :: (ChunkData t, Monad m) =&gt;
--                 Iter t (StateT s m) a -&gt; s -&gt; Iter t m (a, s)
--   runStateTI iter s = adaptIter adaptResult adaptComputation iter
--       where adaptResult a = (a, s)
--             adaptComputation m = do (r', s') &lt;- lift (runStateT m s)
--                                     runStateTI r' s'
--   </pre>
--   
--   Here, after executing <a>runStateT</a>, the state may be modified.
--   Thus, <tt>adaptComputation</tt> invokes <tt>runStateTI</tt>
--   recursively with the modified state, <tt>s'</tt>, to ensure that
--   subsequent <a>IterM</a> computations will be run on the latest state,
--   and that eventually <tt>adaptResult</tt> will pair the result
--   <tt>a</tt> with the newest state.
adaptIter :: (ChunkData t, Monad m1) => (a -> b) -> (m1 (Iter t m1 a) -> Iter t m2 b) -> Iter t m1 a -> Iter t m2 b

-- | Simplified adapter function to translate <a>Iter</a> computations from
--   one monad to another. This only works on monads <tt>m</tt> for which
--   running <tt>m a</tt> returns a result of type <tt>a</tt>. For more
--   complex scenarios (such as <a>ListT</a> or <a>StateT</a>), you need to
--   use the more general <a>adaptIter</a>.
--   
--   As an example, the <a>liftIterIO</a> function is implemented as
--   follows:
--   
--   <pre>
--   liftIterIO :: (ChunkData t, <a>MonadIO</a> m) =&gt; Iter t IO a -&gt; Iter t m a
--   liftIterIO = adaptIterM <a>liftIO</a>
--   </pre>
adaptIterM :: (ChunkData t, Monad m1, Monad m2) => (m1 (Iter t m1 a) -> m2 (Iter t m1 a)) -> Iter t m1 a -> Iter t m2 a

-- | <tt>IterStateT</tt> is a variant of the <a>StateT</a> monad
--   transformer specifically designed for use inside <a>Iter</a>s. The
--   <a>IterStateT</a> Monad itself is the same as <a>StateT</a>. However,
--   the <a>runIterStateT</a> function works differently from
--   <a>runStateT</a>--it returns an <a>IterR</a> and the result state
--   separately. The advantage of this approach is that you can still
--   recover the state at the point of the excaption even after an
--   <a>IterFail</a> or <tt>InumFail</tt> condition.
newtype IterStateT s m a
IterStateT :: (s -> m (a, s)) -> IterStateT s m a

-- | Runs an <tt><a>IterStateT</a> s m</tt> computation on some state
--   <tt>s</tt>. Returns the result (<a>IterR</a>) of the <a>Iter</a> and
--   the state of <tt>s</tt> as a pair. Pulls residual input up to the
--   enclosing <a>Iter</a> monad (as with <tt><tt>pullupResid</tt></tt> in
--   <a>Data.IterIO.Inum</a>).
runIterStateT :: (ChunkData t, Monad m) => Iter t (IterStateT s m) a -> s -> Iter t m (IterR t m a, s)

-- | Returns the state in an <tt><a>Iter</a> t (<a>IterStateT</a> s m)</tt>
--   monad. Analogous to <tt><a>get</a></tt> for a <tt><a>StateT</a> s
--   m</tt> monad.
iget :: Monad m => Iter t (IterStateT s m) s

-- | Returns a particular field of the <a>IterStateT</a> state, analogous
--   to <tt><a>gets</a></tt> for <tt><a>StateT</a></tt>.
igets :: Monad m => (s -> a) -> Iter t (IterStateT s m) a

-- | Sets the <a>IterStateT</a> state. Analogous to <tt><a>put</a></tt> for
--   <tt><a>StateT</a></tt>.
iput :: Monad m => s -> Iter t (IterStateT s m) ()

-- | Modifies the <a>IterStateT</a> state. Analogous to
--   <tt><a>modify</a></tt> for <tt><a>StateT</a></tt>.
imodify :: Monad m => (s -> s) -> Iter t (IterStateT s m) ()
instance MonadWriter w m => MonadWriter w (IterStateT s m)
instance MonadReader r m => MonadReader r (IterStateT s m)
instance MonadError e m => MonadError e (IterStateT s m)
instance MonadCont m => MonadCont (IterStateT s m)
instance (Monoid w, MonadWriter w m, ChunkData t) => MonadWriter w (Iter t m)
instance (MonadState s m, ChunkData t) => MonadState s (Iter t m)
instance (MonadReader r m, ChunkData t) => MonadReader r (Iter t m)
instance (Error e, MonadError e m, ChunkData t) => MonadError e (Iter t m)
instance (ChunkData t, MonadCont m) => MonadCont (Iter t m)
instance MonadIO m => MonadIO (IterStateT s m)
instance MonadTrans (IterStateT s)
instance Monad m => Monad (IterStateT s m)

module Data.IterIO.Inum

-- | The type of an <i>iterator-enumerator</i>, which transcodes data from
--   some input type <tt>tIn</tt> to some output type <tt>tOut</tt>. An
--   <tt>Inum</tt> acts as an <a>Iter</a> when consuming data, then acts as
--   an enumerator when feeding transcoded data to another <a>Iter</a>.
--   
--   At a high level, one can think of an <tt>Inum</tt> as a function from
--   <a>Iter</a>s to <a>IterR</a>s, where an <tt>Inum</tt>'s input and
--   output types are different. A simpler-seeming alternative to
--   <tt>Inum</tt> might have been:
--   
--   <pre>
--   type Inum' tIn tOut m a = Iter tOut m a -&gt; Iter tIn m a
--   </pre>
--   
--   In fact, given an <tt>Inum</tt> object <tt>inum</tt>, it is possible
--   to construct a function of type <tt>Inum'</tt> with <tt>(inum
--   <a>.|</a>)</tt>. But sometimes one might like to concatenate
--   <tt>Inum</tt>s. For instance, consider a network protocol that changes
--   encryption or compression modes midstream. Transcoding is done by
--   <tt>Inum</tt>s. To change transcoding methods after applying an
--   <tt>Inum</tt> to an iteratee requires the ability to "pop" the
--   iteratee back out of the <tt>Inum</tt> so as to be able to hand it to
--   another <tt>Inum</tt>. <tt>Inum</tt>'s return type (<tt>Iter tIn m
--   (IterR tOut m a)</tt> as opposed to <tt>Iter tIn m a</tt>) allows the
--   monadic bind operator <a>&gt;&gt;=</a> to accomplish this popping in
--   conjunction with the <a>tryRI</a> and <a>reRunIter</a> functions.
--   
--   All <tt>Inum</tt>s must obey the following two rules.
--   
--   <ol>
--   <li><i>An</i> <tt>Inum</tt> <i>may never feed a chunk with the EOF
--   flag set to</i> <i>it's target</i> <a>Iter</a>. Instead, upon
--   receiving EOF, the <tt>Inum</tt> should simply return the state of the
--   inner <a>Iter</a> (this is how "popping" the iteratee back out
--   works--If the <tt>Inum</tt> passed the EOF through to the <a>Iter</a>,
--   the <a>Iter</a> would stop requesting more input and could not be
--   handed off to a new <tt>Inum</tt>).</li>
--   <li><i>An</i> <tt>Inum</tt> <i>must always return the state of its
--   target</i> <a>Iter</a>. This is true even when the <tt>Inum</tt>
--   fails, and is why the <a>Fail</a> state contains a <tt><a>Maybe</a>
--   a</tt> field.</li>
--   </ol>
--   
--   In addition to returning when it receives an EOF or fails, an
--   <tt>Inum</tt> should return when the target <a>Iter</a> returns a
--   result or fails. An <tt>Inum</tt> may also unilaterally return the
--   state of the iteratee at any earlier point, for instance if it has
--   reached some logical message boundary (e.g., many protocols finish
--   processing headers upon reading a blank line).
--   
--   <tt>Inum</tt>s are generally constructed with one of the <a>mkInum</a>
--   or <a>mkInumM</a> functions, which hide most of the error handling
--   details and ensure the above rules are obeyed. Most <tt>Inum</tt>s are
--   polymorphic in the last type, <tt>a</tt>, in order to work with
--   iteratees returning any type. There isn't much reason for an
--   <tt>Inum</tt> to care about the type <tt>a</tt>. Had this module used
--   the Rank2Types Haskell extension, it would define <tt>Inum</tt> as:
--   
--   <pre>
--   type Inum tIn tOut m = forall a. Iter tOut m a
--                                 -&gt; Iter tIn m (IterR tOut m a)
--   </pre>
type Inum tIn tOut m a = Iter tOut m a -> Iter tIn m (IterR tOut m a)

-- | An <tt>Onum t m a</tt> is just an <a>Inum</a> in which the input is
--   <tt>()</tt>--i.e., <tt><a>Inum</a> () t m a</tt>--so that there is no
--   meaningful input data to transcode. Such an enumerator is called an
--   <i>outer enumerator</i>, because it must produce the data it feeds to
--   <a>Iter</a>s by either executing actions in monad <tt>m</tt>, or from
--   its own internal pure state (as for <a>enumPure</a>).
--   
--   As with <a>Inum</a>s, an <tt>Onum</tt> should under no circumstances
--   ever feed a chunk with the EOF bit set to its <a>Iter</a> argument.
--   When the <tt>Onum</tt> runs out of data, it must simply return the
--   current state of the <a>Iter</a>. This way more data from another
--   source can still be fed to the iteratee, as happens when enumerators
--   are concatenated with the <a>cat</a> function.
--   
--   <tt>Onum</tt>s should generally be constructed using the <a>mkInum</a>
--   or <a>mkInumM</a> function, just like <a>Inum</a>s, the only
--   difference being that for an <tt>Onum</tt> the input type is
--   <tt>()</tt>, so executing <a>Iter</a>s to consume input will be of
--   little use.
type Onum t m a = Inum () t m a

-- | Run an <a>Onum</a> on an <a>Iter</a>. This is the main way of actually
--   executing IO with <a>Iter</a>s. <tt>|$</tt> is a type-restricted
--   version of the following code, in which <tt>inum</tt> must be an
--   <a>Onum</a>:
--   
--   <pre>
--   inum |$ iter = <a>run</a> (inum .| iter)
--   infixr 2 |$
--   </pre>
(|$) :: (ChunkData t, Monad m) => Onum t m a -> Iter t m a -> m a

-- | <tt>.|$</tt> is a variant of <a>|$</a> that allows you to apply an
--   <a>Onum</a> from within an <a>Iter</a> monad. This is often useful in
--   conjuction with <a>enumPure</a>, if you want to parse at some
--   coarse-granularity (such as lines), and then re-parse the contents of
--   some coarser-grained parse unit. For example:
--   
--   <pre>
--   rawcommand &lt;- lineI
--   command &lt;- enumPure rawcommand .|$ parseCommandI
--   return Request { cmd = command, rawcmd = rawcommand }
--   </pre>
--   
--   <tt>.|$</tt> has the same fixity as <tt>|$</tt>, namely:
--   
--   <pre>
--   infixr 2 .|$
--   </pre>
--   
--   Note the important distinction between <tt>(.|$)</tt> and
--   <tt>(<a>.|</a>)</tt>. <tt>(.|$)</tt> runs an <a>Onum</a> and does not
--   touch the current input, while (<a>.|</a>) pipes the current input
--   through an <a>Inum</a>. For instance, to send the contents of a file
--   to standard output (regardless of the current input), you must say
--   <tt><tt>enumFile</tt> ".signature" .|$ <tt>stdoutI</tt></tt>. But to
--   take the current input, compress it, and send the result to standard
--   output, you must use <a>.|</a>, as in <tt><tt>inumGzip</tt> <a>.|</a>
--   <tt>stdoutI</tt></tt>.
--   
--   As suggested by the types, <tt>enum .|$ iter</tt> is sort of
--   equivalent to <tt><a>lift</a> (enum |$ iter)</tt>, except that the
--   latter will call <tt>throw</tt> on failures, causing language-level
--   exceptions that cannot be caught within the outer <a>Iter</a>. Thus,
--   it is better to use <tt>.|$</tt> than <tt><a>lift</a> (... <a>|$</a>
--   ...)</tt>, though in the less general case of the IO monad, <tt>enum
--   .|$ iter</tt> is equivalent to <tt><a>liftIO</a> (enum <a>|$</a>
--   iter)</tt> as illustrated by the following examples:
--   
--   <pre>
--   -- Catches exception, because .|$ propagates failure through the outer
--   -- Iter Monad, where it can still be caught.
--   apply1 :: IO String
--   apply1 = enumPure "test1" |$ iter `catchI` handler
--       where
--         iter = enumPure "test2" .|$ fail "error"
--         handler (SomeException _) _ = return "caught error"
--   
--   -- Does not catch error.  |$ turns the Iter failure into a language-
--   -- level exception, which can only be caught in the IO Monad.
--   apply2 :: IO String
--   apply2 = enumPure "test1" |$ iter `catchI` handler
--       where
--         iter = lift (enumPure "test2" |$ fail "error")
--         handler (SomeException _) _ = return "caught error"
--   
--   -- Catches the exception, because liftIO uses the IO catch function to
--   -- turn language-level exceptions into monadic Iter failures.  (By
--   -- contrast, lift works in any Monad, so cannot do this in apply2.)
--   -- This example illustrates how liftIO is not equivalent to lift.
--   apply3 :: IO String
--   apply3 = enumPure "test1" |$ iter `catchI` handler
--       where
--         iter = liftIO (enumPure "test2" |$ fail "error")
--         handler (SomeException _) _ = return "caught error"
--   </pre>
(.|$) :: (ChunkData tIn, ChunkData tOut, Monad m) => Onum tOut m a -> Iter tOut m a -> Iter tIn m a

-- | Concatenate the outputs of two enumerators. For example,
--   <tt><tt>enumFile</tt> "file1" `cat` <tt>enumFile</tt> "file2"</tt>
--   produces an <a>Onum</a> that outputs the concatenation of files
--   "file1" and "file2". Unless the first <a>Inum</a> fails, <tt>cat</tt>
--   always invokes the second <a>Inum</a>, as the second <a>Inum</a> may
--   have monadic side-effects that must be executed even when the
--   <a>Iter</a> has already finished. See <a>lcat</a> if you want to stop
--   when the <a>Iter</a> no longer requires input. If you want to continue
--   executing even in the event of an <tt>InumFail</tt> condition, you can
--   wrap the first <a>Inum</a> with <a>inumCatch</a> and invoke
--   <a>resumeI</a> from within the exception handler.
--   
--   <tt>cat</tt> (and <a>lcat</a>, described below) are useful in right
--   folds. Say, for instance, that <tt>files</tt> is a list of files you
--   wish to concatenate. You can use a construct such as:
--   
--   <pre>
--   catFiles :: (<a>MonadIO</a> m) =&gt; [<a>FilePath</a>] -&gt; <a>Onum</a> <a>ByteString</a> m a
--   catFiles files = <a>foldr</a> (<a>cat</a> . <tt>enumFile</tt>) <a>inumNull</a> files
--   </pre>
--   
--   Note the use of <a>inumNull</a> as the starting value for
--   <a>foldr</a>. This is not to be confused with <a>inumNop</a>.
--   <a>inumNull</a> acts as a no-op for concatentation, producing no
--   output analogously to <tt>/dev/null</tt>. By contrast <a>inumNop</a>
--   is the no-op for fusing (see <a>|.</a> and <a>.|</a> below) because it
--   passes all data through untouched.
--   
--   <tt>cat</tt> has fixity:
--   
--   <pre>
--   infixr 3 `cat`
--   </pre>
cat :: (ChunkData tIn, ChunkData tOut, Monad m) => Inum tIn tOut m a -> Inum tIn tOut m a -> Inum tIn tOut m a

-- | Lazy cat. Like <a>cat</a>, except that it does not run the second
--   <a>Inum</a> if the <a>Iter</a> is no longer active after completion of
--   the first <a>Inum</a>. Also has fixity <tt>infixr 3 `lcat`</tt>.
lcat :: (ChunkData tIn, ChunkData tOut, Monad m) => Inum tIn tOut m a -> Inum tIn tOut m a -> Inum tIn tOut m a

-- | Left-associative pipe operator. Fuses two <a>Inum</a>s when the output
--   type of the first <a>Inum</a> is the same as the input type of the
--   second. More specifically, if <tt>inum1</tt> transcodes type
--   <tt>tIn</tt> to <tt>tOut</tt> and <tt>inum2</tt> transcodes
--   <tt>tOut</tt> to <tt>tOut2</tt>, then <tt>inum1 |. inum2</tt> produces
--   a new <a>Inum</a> that transcodes from <tt>tIn</tt> to <tt>tOut2</tt>.
--   
--   Typically types <tt>i</tt> and <tt>iR</tt> are <tt><a>Iter</a> tOut2 m
--   a</tt> and <tt><a>IterR</a> tOut2 m a</tt>, respectively, in which
--   case the second argument and result of <tt>|.</tt> are also
--   <a>Inum</a>s.
--   
--   This function is equivalent to:
--   
--   <pre>
--   outer |. inner = \iter -&gt; outer <a>.|</a> inner iter
--   infixl 4 |.
--   </pre>
--   
--   But if you like point-free notation, think of it as <tt>outer |. inner
--   = (outer <a>.|</a>) . inner</tt>, or better yet <tt>(|.) = (.) .
--   (<a>.|</a>)</tt>.
(|.) :: (ChunkData tIn, ChunkData tOut, Monad m) => Inum tIn tOut m iR -> (i -> Iter tOut m iR) -> (i -> Iter tIn m iR)

-- | Right-associative pipe operator. Fuses an <a>Inum</a> that transcodes
--   <tt>tIn</tt> to <tt>tOut</tt> with an <a>Iter</a> taking input type
--   <tt>tOut</tt> to produce an <a>Iter</a> taking input type
--   <tt>tIn</tt>. If the <a>Iter</a> is still active when the <a>Inum</a>
--   terminates (either normally or through an exception), then <tt>.|</tt>
--   sends it an EOF.
--   
--   Has fixity:
--   
--   <pre>
--   infixr 4 .|
--   </pre>
(.|) :: (ChunkData tIn, ChunkData tOut, Monad m) => Inum tIn tOut m a -> Iter tOut m a -> Iter tIn m a

-- | Catches errors thrown by an <a>Inum</a>, or a set of fused
--   <a>Inum</a>s. Note that only errors in <a>Inum</a>s that are lexically
--   within the scope of the argument to <a>inumCatch</a> will be caught.
--   For example:
--   
--   <pre>
--   inumBad :: (ChunkData t, Monad m) =&gt; Inum t t m a
--   inumBad = mkInum $ fail "inumBad"
--   
--   skipError :: (ChunkData tIn, MonadIO m) =&gt;
--                SomeException
--             -&gt; IterR tIn m (IterR tOut m a)
--             -&gt; Iter tIn m (IterR tOut m a)
--   skipError e iter = do
--     liftIO $ hPutStrLn stderr $ "skipping error: " ++ show e
--     resumeI iter
--   
--   -- Throws an exception, because inumBad was fused outside the argument
--   -- to inumCatch.
--   test1 :: IO ()
--   test1 = inumCatch (enumPure "test") skipError |. inumBad |$ nullI
--   
--   -- Does not throw an exception, because inumBad fused within the
--   -- argument to inumCatch.
--   test2 :: IO ()
--   test2 = inumCatch (enumPure "test" |. inumBad) skipError |$ nullI
--   
--   -- Again no exception, because inumCatch is wrapped around inumBad.
--   test3 :: IO ()
--   test3 = enumPure "test" |. inumCatch inumBad skipError |$ nullI
--   </pre>
--   
--   Note that <tt>`inumCatch`</tt> has the default infix precedence
--   (<tt>infixl 9 `inumcatch`</tt>), which binds more tightly than any
--   concatenation or fusing operators.
--   
--   As noted for <a>catchI</a>, exception handlers receive both the
--   exception thrown and the failed <a>IterR</a>. Particularly in the case
--   of <tt>inumCatch</tt>, it is important to re-throw exceptions by
--   re-executing the failed <a>Iter</a> with <a>reRunIter</a>, not passing
--   the exception itself to <a>throwI</a>. That way, if the exception is
--   re-caught, <a>resumeI</a> will continue to work properly. For example,
--   to copy two files to standard output and ignore file not found errors
--   but re-throw any other kind of error, you could use the following:
--   
--   <pre>
--   resumeTest :: IO ()
--   resumeTest = doFile "file1" `<a>cat</a>` doFile "file2" |$ <tt>stdoutI</tt>
--       where
--         doFile path = inumCatch (<tt>enumFile'</tt> path) $ \err r -&gt;
--                         if <tt>isDoesNotExistError</tt> err
--                           then <a>verboseResumeI</a> r
--                           else <a>reRunIter</a> r
--   </pre>
inumCatch :: (Exception e, ChunkData tIn, Monad m) => Inum tIn tOut m a -> (e -> IterR tIn m (IterR tOut m a) -> Iter tIn m (IterR tOut m a)) -> Inum tIn tOut m a

-- | Execute some cleanup action when an <a>Inum</a> finishes.
inumFinally :: (ChunkData tIn, Monad m) => Inum tIn tOut m a -> Iter tIn m b -> Inum tIn tOut m a

-- | Execute some cleanup action if an <a>Inum</a> fails. Does not execute
--   the action if the <a>Iter</a> (or some inner <a>Inum</a>) fails. Has
--   the same scoping rules as <a>inumCatch</a>.
inumOnException :: (ChunkData tIn, Monad m) => Inum tIn tOut m a -> Iter tIn m b -> Inum tIn tOut m a

-- | Used in an exception handler, after an <a>Inum</a> failure, to resume
--   processing of the <a>Iter</a> by the next enumerator in a <a>cat</a>ed
--   series. See <a>inumCatch</a> for an example.
resumeI :: (ChunkData tIn, Monad m) => IterR tIn m (IterR tOut m a) -> Iter tIn m (IterR tOut m a)

-- | Like <a>resumeI</a>, but if the <a>Iter</a> is resumable, also prints
--   an error message to standard error before resuming.
verboseResumeI :: (ChunkData tIn, MonadIO m) => IterR tIn m (IterR tOut m a) -> Iter tIn m (IterR tOut m a)

-- | A <tt>ResidHandler</tt> specifies how to handle residual data in an
--   <a>Inum</a>. Typically, when an <a>Inum</a> finishes executing, there
--   are two kinds of residual data. First, the <a>Inum</a> itself (in its
--   role as an iteratee) may have left some unconsumed data. Second, the
--   target <a>Iter</a> being fed by the <a>Inum</a> may have some resitual
--   data, and this data may be of a different type. A
--   <tt>ResidHandler</tt> allows this residual data to be adjusted by
--   untranslating the residual data of the target <a>Iter</a> and sticking
--   the result back into the <a>Inum</a>'s residual data.
--   
--   The two most common <tt>ResidHandler</tt>s are <a>pullupResid</a> (to
--   pull the target <a>Iter</a>'s residual data back up to the <a>Inum</a>
--   as is), and <a>id</a> (to do no adjustment of residual data).
--   
--   <tt>ResidHandler</tt>s are used by the <a>mkInumC</a> function, and by
--   the <a>passCtl</a> <a>CtlHandler</a>.
type ResidHandler tIn tOut = (tIn, tOut) -> (tIn, tOut)

-- | A control handler maps control requests to <a>IterR</a> results.
--   Generally the type parameter <tt>m1</tt> is <tt><a>Iter</a> t' m</tt>.
type CtlHandler m1 t m a = CtlArg t m a -> m1 (IterR t m a)

-- | Create a stateless <a>Inum</a> from a "codec" <a>Iter</a> that
--   transcodes the input type to the output type. The codec is invoked
--   repeately until one of the following occurs:
--   
--   <ol>
--   <li>The input is at an EOF marker AND the codec returns <a>null</a>
--   data. (<a>Onum</a>s are always fed EOF, but other <a>Inum</a>s might
--   have reason to return <a>mempty</a> data.)</li>
--   <li>The codec throws an exception. If the exception is an EOF
--   exception--thrown either by <a>throwEOFI</a>, or by some IO action
--   inside <a>liftIO</a>--this is considered normal termination, and is
--   the normal way for a codec to cause the <a>Inum</a> to return. If the
--   exception is of any other type, then the <a>Inum</a> will further
--   propagate the exception as an <a>Inum</a> failure.</li>
--   <li>The underlying target <a>Iter</a> either returns a result or
--   throws an exception.</li>
--   </ol>
--   
--   <tt>mkInumC</tt> requires two other arguments before the codec. First,
--   a <a>ResidHandler</a> allows residual data to be adjusted between the
--   input and output <a>Iter</a> monads. Second, a <a>CtlHandler</a>
--   specifies a handler for control requests. For example, to pass up
--   control requests and ensure no residual data is lost when the
--   <a>Inum</a> is fused to an <a>Iter</a>, the <tt>inumConcat</tt>
--   function given previously for <a>mkInum</a> at <a>#mkInumExample</a>
--   could be re-written:
--   
--   <pre>
--   inumConcat :: (Monad m) =&gt; Inum [L.ByteString] L.ByteString m a
--   inumConcat = mkInumC reList (passCtl reList) iterConcat
--       where reList (a, b) = (b:a, mempty)
--   </pre>
mkInumC :: (ChunkData tIn, ChunkData tOut, Monad m) => ResidHandler tIn tOut -> CtlHandler (Iter tIn m) tOut m a -> Iter tIn m tOut -> Inum tIn tOut m a

-- | Create an <a>Inum</a> based on an <a>Iter</a> that transcodes the
--   input to the output type. This is a simplified version of
--   <a>mkInumC</a> that rejects all control requests and does not adjust
--   residual data.
--   
--   <pre>
--   mkInum = mkInumC id noCtl
--   </pre>
mkInum :: (ChunkData tIn, ChunkData tOut, Monad m) => Iter tIn m tOut -> Inum tIn tOut m a

-- | A simplified version of <a>mkInum</a> that passes all control requests
--   to enclosing enumerators. It requires a <a>ResidHandler</a> to
--   describe how to adjust residual data. (E.g., use <a>pullupResid</a>
--   when <tt>tIn</tt> and <tt>tOut</tt> are the same type.)
--   
--   <pre>
--   mkInumP adj = mkInumC adj (passCtl adj)
--   </pre>
mkInumP :: (ChunkData tIn, ChunkData tOut, Monad m) => ResidHandler tIn tOut -> Iter tIn m tOut -> Inum tIn tOut m a

-- | Bracket an <a>Inum</a> with a start and end function, which can be
--   used to acquire and release a resource, must like the IO monad's
--   <tt><tt>bracket</tt></tt> function. For example:
--   
--   <pre>
--   enumFile :: (MonadIO m, ChunkData t, LL.ListLikeIO t e) =&gt;
--               FilePath -&gt; Onum t m a
--   enumFile path = inumBracket (liftIO $ openBinaryFile path ReadMode)
--                               (liftIO . hClose)
--                               enumHandle
--   </pre>
inumBracket :: (ChunkData tIn, Monad m) => Iter tIn m b -> (b -> Iter tIn m c) -> (b -> Inum tIn tOut m a) -> Inum tIn tOut m a

-- | <tt>pullupResid (a, b) = (mappend a b, mempty)</tt>. See
--   <a>ResidHandler</a>.
pullupResid :: ChunkData t => (t, t) -> (t, t)

-- | Reject all control requests.
noCtl :: Monad m1 => CtlHandler m1 t m a

-- | Pass all control requests through to the enclosing <a>Iter</a> monad.
--   The <a>ResidHandler</a> argument says how to adjust residual data, in
--   case some enclosing <a>CtlHandler</a> decides to flush pending input
--   data, it is advisable to un-translate any data in the output type
--   <tt>tOut</tt> back to the input type <tt>tIn</tt>.
passCtl :: Monad mIn => ResidHandler tIn tOut -> CtlHandler (Iter tIn mIn) tOut m a

-- | Create a <a>CtlHandler</a> given a function of a particular control
--   argument type and a fallback <a>CtlHandler</a> to run if the argument
--   type does not match. <tt>consCtl</tt> is used to chain handlers, with
--   the rightmost handler being either <a>noCtl</a> or <a>passCtl</a>.
--   
--   For example, to create a control handler that implements seek on
--   <tt><tt>SeekC</tt></tt> requests, returns the size of the file on
--   <tt><tt>SizeC</tt></tt> requests, and passes everything else out to
--   the enclosing enumerator (if any), you could use the following:
--   
--   <pre>
--   fileCtl :: (ChunkData t, MonadIO m) =&gt; Handle -&gt; CtlHandler (Iter () m) t m a
--   fileCtl h = (<a>mkFlushCtl</a> $ (SeekC mode pos) -&gt; liftIO (hSeek h mode pos))
--               `consCtl` (<a>mkCtl</a> $ SizeC -&gt; liftIO (hFileSize h))
--               `consCtl` <a>passCtl</a> <a>id</a>
--   </pre>
--   
--   Has fixity:
--   
--   <pre>
--   infixr 9 `consCtl`
--   </pre>
consCtl :: (CtlCmd carg cres, ChunkData tIn, Monad mIn) => (carg -> (cres -> Iter t m a) -> Chunk t -> Iter tIn mIn (IterR t m a)) -> CtlHandler (Iter tIn mIn) t m a -> CtlHandler (Iter tIn mIn) t m a

-- | Make a control function suitable for use as the first argument to
--   <a>consCtl</a>.
mkCtl :: (CtlCmd carg cres, Monad m1) => (carg -> Iter t1 m1 cres) -> carg -> (cres -> Iter t m a) -> Chunk t -> Iter t1 m1 (IterR t m a)

-- | Like <a>mkCtl</a>, except that it flushes all input and clears the EOF
--   flag in both <a>Iter</a> monads after executing the control function.
mkFlushCtl :: (CtlCmd carg cres, Monad mIn, ChunkData tIn, ChunkData t) => (carg -> Iter tIn mIn cres) -> carg -> (cres -> Iter t m a) -> Chunk t -> Iter tIn mIn (IterR t m a)

-- | Like <a>runIterMC</a>, but only for <a>IterM</a>--may return
--   <a>IterC</a>.
runIterM :: (Monad m, MonadTrans mt, Monad (mt m)) => Iter t m a -> Chunk t -> mt m (IterR t m a)

-- | Run an <a>Iter</a> just like <a>runIter</a>, but then keep stepping
--   the result for as long as it is in the <a>IterM</a> or <a>IterC</a>
--   state (using the supplied <a>CtlHandler</a> for <a>IterC</a> states).
--   <a>Inum</a>s should generally use this function or <a>runIterM</a> in
--   preference to <a>runIter</a>, as it is convenient if <a>Inum</a>s
--   avoid ever returning <a>IterR</a>s in the <a>IterM</a> state.
runIterMC :: Monad m => CtlHandler (Iter tIn m) tOut m a -> Iter tOut m a -> Chunk tOut -> Iter tIn m (IterR tOut m a)

-- | Takes an <a>Inum</a> that might return <a>IterR</a>s in the
--   <a>IterM</a> state (which is considered impolite--see
--   <a>runIterMC</a>) and transforms it into an <a>Inum</a> that never
--   returns <a>IterR</a>s in the <a>IterM</a> state.
runInum :: (ChunkData tIn, Monad m) => Inum tIn tOut m a -> Inum tIn tOut m a

-- | <tt>inumNop</tt> passes all data through to the underlying
--   <a>Iter</a>. It acts as a no-op when fused to other <a>Inum</a>s with
--   <a>|.</a> or when fused to <a>Iter</a>s with <a>.|</a>.
--   
--   <tt>inumNop</tt> is particularly useful for conditionally fusing
--   <a>Inum</a>s together. Even though most <a>Inum</a>s are polymorphic
--   in the return type, this library does not use the Rank2Types
--   extension, which means any given <a>Inum</a> must have a specific
--   return type. Here is an example of incorrect code:
--   
--   <pre>
--   let enum = if debug then base_enum <a>|.</a> <tt>inumStderr</tt> else base_enum -- Error
--   </pre>
--   
--   This doesn't work because <tt>base_enum</tt> cannot have the same type
--   as <tt>(base_enum |. inumStderr)</tt>. Instead, you can use the
--   following:
--   
--   <pre>
--   let enum = base_enum <a>|.</a> if debug then <tt>inumStderr</tt> else inumNop
--   </pre>
inumNop :: (ChunkData t, Monad m) => Inum t t m a

-- | <tt>inumNull</tt> feeds empty data to the underlying <a>Iter</a>. It
--   pretty much acts as a no-op when concatenated to other <a>Inum</a>s
--   with <a>cat</a> or <a>lcat</a>.
--   
--   There may be cases where <tt>inumNull</tt> is required to avoid
--   deadlock. In an expression such as <tt>enum <a>|$</a> iter</tt>, if
--   <tt>enum</tt> immediately blocks waiting for some event, and
--   <tt>iter</tt> immediately starts out triggering that event before
--   reading any input, then to break the deadlock you can re-write the
--   code as <tt>cat inumNull enum <a>|$</a> iter</tt>.
inumNull :: (ChunkData tOut, Monad m) => Inum tIn tOut m a

-- | Feed pure data to an <a>Iter</a>.
inumPure :: Monad m => tOut -> Inum tIn tOut m a

-- | Type-restricted version of <a>inumPure</a>.
enumPure :: Monad m => tOut -> Onum tOut m a

-- | Repeat an <a>Inum</a> until the input receives an EOF condition, the
--   <a>Iter</a> no longer requires input, or the <a>Iter</a> is in an
--   unhandled <a>IterC</a> state (which presumably will continue to be
--   unhandled by the same <a>Inum</a>, so no point in executing it again).
inumRepeat :: (ChunkData tIn, Monad m) => Inum tIn tOut m a -> Inum tIn tOut m a

-- | An <a>Inum</a> that acts like <a>inumNop</a>, except that before
--   passing data on, it feeds a copy to a "tee" <a>Iter</a> (by analogy
--   with the Unix <tt>tee</tt> utility), which may, for instance,
--   transform and log the data.
--   
--   The tee <a>Iter</a>'s return value is ignored. If the tee <a>Iter</a>
--   returns before an EOF is received and before the target <a>Iter</a>
--   has finished processing input, then <tt>inumTee</tt> will continue to
--   pass data to the target <a>Iter</a>. However, if the tee <a>Iter</a>
--   fails, then this will cause <tt>inumTee</tt> to fail immediately.
--   
--   As an example, one could implement something close to
--   <tt><tt>inumStderr</tt></tt> (from <a>Data.IterIO.ListLike</a>) as
--   follows:
--   
--   <pre>
--   inumStderr = inumTee $ handleI stderr
--   </pre>
--   
--   (Except note that the real <tt><tt>inumStderr</tt></tt> does not close
--   its file descriptor, while the above implementation will send an EOF
--   to <tt><tt>handleI</tt></tt>, causing <tt>stderr</tt> to be closed.)
inumTee :: (ChunkData t, Monad m) => Iter t m b -> Inum t t m a

-- | A <tt>Codec</tt> produces some input to feed to an <a>Iter</a>, and
--   optionally returns an <a>Inum</a> that will produce the rest of the
--   input. The funciton <a>runCodec</a> can be used to build an
--   <a>Inum</a> out of a <a>Codec</a>. Using <a>runCodec</a> is much
--   simpler than <a>mkInumM</a>, but more expressive than <a>mkInum</a>.
--   For example, a possible implementation of <a>mkInum</a> would be:
--   
--   <pre>
--   mkInum :: (<a>ChunkData</a> tIn, <a>ChunkData</a> tOut, <a>Monad</a> m) =&gt;
--             <a>Iter</a> tIn m tOut -&gt; <a>Inum</a> tIn tOut m a
--   mkInum trans = inum
--       where inum = <a>runCodec</a> <a>id</a> $
--                    <a>tryEOFI</a> trans &gt;&gt;= <a>maybe</a> (return (mempty, Nothing)) doinput
--             doinput input = do
--               eof &lt;- if null input then return False else <a>atEOFI</a>
--               return (input, if eof then Nothing else Just inum)
--   </pre>
type Codec tIn tOut m a = Iter tIn m (tOut, Maybe (Inum tIn tOut m a))

-- | Build an <a>Inum</a> from a <a>Codec</a>.
runCodec :: (ChunkData tIn, ChunkData tOut, Monad m) => ResidHandler tIn tOut -> Codec tIn tOut m a -> Inum tIn tOut m a

-- | A generalized version of <a>runCodec</a> that allows a
--   <a>CtlHandler</a> to be specified.
--   
--   <pre>
--   runCodec adj = runCodecC adj (passCtl adj)
--   </pre>
runCodecC :: (ChunkData tIn, ChunkData tOut, Monad m) => ResidHandler tIn tOut -> CtlHandler (Iter tIn m) tOut m a -> Codec tIn tOut m a -> Inum tIn tOut m a

-- | A monad in which to define the actions of an <tt><a>Inum</a> tIn tOut
--   m a</tt>. Note <tt>InumM tIn tOut m a</tt> is a <a>Monad</a> of kind
--   <tt>* -&gt; *</tt>, where <tt>a</tt> is the (almost always parametric)
--   return type of the <a>Inum</a>. A fifth type argument is required for
--   monadic computations of kind <tt>*</tt>, e.g.:
--   
--   <pre>
--   seven :: InumM tIn tOut m a Int
--   seven = return 7
--   </pre>
--   
--   Another important thing to note about the <a>InumM</a> monad, as
--   described in the documentation for <a>mkInumM</a>, is that you must
--   call <tt><a>lift</a></tt> twice to execute actions in monad
--   <tt>m</tt>, and you must use the <a>liftI</a> function to execute
--   actions in monad <tt><a>Iter</a> t m a</tt>.
type InumM tIn tOut m a = Iter tIn (IterStateT (InumState tIn tOut m a) m)

-- | Build an <a>Inum</a> out of an <a>InumM</a> computation. If you run
--   <a>mkInumM</a> inside the <tt><a>Iter</a> tIn m</tt> monad (i.e., to
--   create an enumerator of type <tt><a>Inum</a> tIn tOut m a</tt>), then
--   the <a>InumM</a> computation will be in a Monad of type
--   <tt><a>Iter</a> t tm</tt> where <tt>tm</tt> is a transformed version
--   of <tt>m</tt>. This has the following two consequences:
--   
--   <ul>
--   <li>If you wish to execute actions in monad <tt>m</tt> from within
--   your <a>InumM</a> computation, you will have to apply
--   <tt><a>lift</a></tt> twice (as in <tt><a>lift</a> $ <a>lift</a>
--   action_in_m</tt>) rather than just once.</li>
--   <li>If you need to execute actions in the <tt><a>Iter</a> t m</tt>
--   monad, you will have to lift them with the <a>liftI</a> function.</li>
--   </ul>
--   
--   The <a>InumM</a> computation you construct can feed output of type
--   <tt>tOut</tt> to the target <a>Iter</a> (which is implicitly contained
--   in the monad state), using the <a>ifeed</a>, <a>ipipe</a>, and
--   <a>irun</a> functions.
mkInumM :: (ChunkData tIn, ChunkData tOut, Monad m) => InumM tIn tOut m a b -> Inum tIn tOut m a

-- | A variant of <a>mkInumM</a> that sets <i>AutoEOF</i> and
--   <i>AutoDone</i> to <a>True</a> by default. (Equivalent to calling
--   <tt><a>setAutoEOF</a> <a>True</a> &gt;&gt; <a>setAutoDone</a>
--   <a>True</a></tt> as the first thing inside <a>mkInumM</a>.)
mkInumAutoM :: (ChunkData tIn, ChunkData tOut, Monad m) => InumM tIn tOut m a b -> Inum tIn tOut m a

-- | Set the control handler an <a>Inum</a> should use from within an
--   <a>InumM</a> computation. (The default is <a>noCtl</a>.)
setCtlHandler :: (ChunkData tIn, Monad m) => CtlHandler (Iter tIn m) tOut m a -> InumM tIn tOut m a ()

-- | Set the <i>AutoEOF</i> flag within an <a>InumM</a> computation. If
--   this flag is <a>True</a>, handle <tt>IterEOF</tt> exceptions like a
--   normal but immediate termination of the <a>Inum</a>. If this flag is
--   <tt><a>False</a></tt> (the default), then <tt>IterEOF</tt> exceptions
--   must be manually caught or they will terminate the thread.
setAutoEOF :: (ChunkData tIn, Monad m) => Bool -> InumM tIn tOut m a ()

-- | Set the <i>AutoDone</i> flag within an <a>InumM</a> computation. When
--   <tt><a>True</a></tt>, the <a>Inum</a> will immediately terminate as
--   soon as the <a>Iter</a> it is feeding enters a non-active state (i.e.,
--   <a>Done</a> or a failure state). If this flag is <tt><a>False</a></tt>
--   (the default), the <a>InumM</a> computation will need to monitor the
--   results of the <a>ifeed</a>, <a>ipipe</a>, and <a>irun</a> functions
--   to ensure the <a>Inum</a> terminates when one of these functions
--   returns <tt><a>False</a></tt>.
setAutoDone :: (ChunkData tIn, Monad m) => Bool -> InumM tIn tOut m a ()

-- | Add a cleanup action to be executed when the <a>Inum</a> finishes, or,
--   if used in conjunction with the <a>withCleanup</a> function, when the
--   innermost enclosing <a>withCleanup</a> action finishes.
addCleanup :: (ChunkData tIn, Monad m) => InumM tIn tOut m a () -> InumM tIn tOut m a ()

-- | Run an <a>InumM</a> with some cleanup action in effect. The cleanup
--   action specified will be executed when the main action returns,
--   whether normally, through an exception, because of the <i>AutoDone</i>
--   or <i>AutoEOF</i> flags, or because <a>idone</a> is invoked.
--   
--   Note <tt>withCleanup</tt> also defines the scope of actions added by
--   the <a>addCleanup</a> function. In other words, given a call such as
--   <tt>withCleanup cleaner1 main</tt>, if <tt>main</tt> invokes
--   <tt><a>addCleanup</a> cleaner2</tt>, then both <tt>cleaner1</tt> and
--   <tt>cleaner2</tt> will be executed upon <tt>main</tt>'s return, even
--   if the overall <a>Inum</a> has not finished yet.
withCleanup :: (ChunkData tIn, Monad m) => InumM tIn tOut m a () -> InumM tIn tOut m a b -> InumM tIn tOut m a b

-- | Used from within the <a>InumM</a> monad to feed data to the target
--   <a>Iter</a>. Returns <tt><a>False</a></tt> if the target <a>Iter</a>
--   is still active and <tt><a>True</a></tt> if the iter has finished and
--   the <a>Inum</a> should also return. (If the <tt>autoDone</tt> flag is
--   <tt><a>True</a></tt>, then <tt>ifeed</tt>, <tt>ipipe</tt>, and
--   <tt>irun</tt> will never actually return <tt><a>True</a></tt>, but
--   instead just immediately run cleanup functions and exit the
--   <a>Inum</a> when the target <a>Iter</a> stops being active.)
ifeed :: (ChunkData tIn, ChunkData tOut, Monad m) => tOut -> InumM tIn tOut m a Bool

-- | A variant of <a>ifeed</a> that throws an exception of type
--   <tt>IterEOF</tt> if the data being fed is <a>null</a>. Convenient when
--   reading input with a function (such as <a>Data.ListLike</a>'s
--   <tt>hget</tt>) that returns 0 bytes instead of throwing an EOF
--   exception to indicate end of file. For instance, the main loop of
--   <tt><tt>enumFile</tt></tt> could be implemented as:
--   
--   <pre>
--   <a>irepeat</a> $ <a>liftIO</a> (<a>hGet</a> h <tt>defaultChunkSize</tt>) &gt;&gt;= <a>ifeed1</a>
--   </pre>
ifeed1 :: (ChunkData tIn, ChunkData tOut, Monad m) => tOut -> InumM tIn tOut m a Bool

-- | Apply another <a>Inum</a> to the target <a>Iter</a> from within the
--   <a>InumM</a> monad. As with <a>ifeed</a>, returns <tt><a>True</a></tt>
--   when the <a>Iter</a> is finished.
--   
--   Note that the applied <a>Inum</a> must handle all control requests.
--   (In other words, ones it passes on are not caught by whatever handler
--   is installed by <a>setCtlHandler</a>, but if the <a>Inum</a> returns
--   the <a>IterR</a> in the <a>IterC</a> state, as <a>inumPure</a> does,
--   then requests will be handled.)
ipipe :: (ChunkData tIn, ChunkData tOut, Monad m) => Inum tIn tOut m a -> InumM tIn tOut m a Bool

-- | Apply an <a>Onum</a> (or <a>Inum</a> of an arbitrary, unused input
--   type) to the <a>Iter</a> from within the <a>InumM</a> monad. As with
--   <a>ifeed</a>, returns <tt><a>True</a></tt> when the <a>Iter</a> is
--   finished.
irun :: (ChunkData tAny, ChunkData tIn, ChunkData tOut, Monad m) => Inum tAny tOut m a -> InumM tIn tOut m a Bool

-- | Repeats an action until the <a>Iter</a> is done or an EOF error is
--   thrown. (Also stops if a different kind of exception is thrown, in
--   which case the exception propagates further and may cause the
--   <a>Inum</a> to fail.) <tt>irepeat</tt> sets both the <i>AutoEOF</i>
--   and <i>AutoDone</i> flags to <tt><a>True</a></tt>.
irepeat :: (ChunkData tIn, Monad m) => InumM tIn tOut m a b -> InumM tIn tOut m a ()

-- | If the target <a>Iter</a> being fed by the <a>Inum</a> is no longer
--   active (i.e., if it is in the <a>Done</a> state or in an error state),
--   this funciton pops the residual data out of the <a>Iter</a> and
--   returns it. If the target is in any other state, returns
--   <a>mempty</a>.
ipopresid :: (ChunkData tIn, ChunkData tOut, Monad m) => InumM tIn tOut m a tOut

-- | Immediately perform a successful exit from an <a>InumM</a> monad,
--   terminating the <a>Inum</a> and returning the current state of the
--   target <a>Iter</a>. Can be used to end an <a>irepeat</a> loop. (Use
--   <tt><a>throwI</a> ...</tt> for an unsuccessful exit.)
idone :: (ChunkData tIn, Monad m) => InumM tIn tOut m a b


-- | This module contains miscellaneous functions plus a few pieces of
--   functionality that are missing from the standard Haskell libraries.
module Data.IterIO.Extra

-- | Create a loopback <tt>(<a>Iter</a>, <a>Onum</a>)</tt> pair. The
--   iteratee and enumerator can be used in different threads. Any data fed
--   into the <a>Iter</a> will in turn be fed by the <a>Onum</a> into
--   whatever <a>Iter</a> it is given. This is useful for testing a
--   protocol implementation against itself.
iterLoop :: (MonadIO m, ChunkData t, Show t) => m (Iter t m (), Onum t m a)

-- | Returns an <a>Iter</a> that always returns itself until a result is
--   produced. You can fuse <tt>inumSplit</tt> to an <a>Iter</a> to produce
--   an <a>Iter</a> that can safely be fed (e.g., with <a>enumPure</a>)
--   from multiple threads.
inumSplit :: (MonadIO m, ChunkData t) => Inum t t m a

-- | <tt>SendRecvString</tt> is the class of string-like objects that can
--   be used with datagram sockets.
class Show t => SendRecvString t
genRecv :: SendRecvString t => Socket -> Int -> IO t
genSend :: SendRecvString t => Socket -> t -> IO ()
genRecvFrom :: SendRecvString t => Socket -> Int -> IO (t, SockAddr)
genSendTo :: SendRecvString t => Socket -> t -> SockAddr -> IO ()

-- | Flushes a file handle and calls the <i>shutdown</i> system call so as
--   to write an EOF to a socket while still being able to read from it.
--   This is very important when the same file handle is being used to to
--   read data in an <a>Onum</a> and to write data in an <a>Iter</a>.
--   Proper protocol functioning may require the <a>Iter</a> to send an EOF
--   (e.g., a TCP FIN segment), but the <a>Onum</a> may still be reading
--   from the socket in a different thread.
hShutdown :: Handle -> CInt -> IO Int

-- | For debugging, print a tag along with the current residual input. Not
--   referentially transparent.
traceInput :: (ChunkData t, Monad m) => String -> Iter t m ()

-- | For debugging. Print the current thread ID and a message. Not
--   referentially transparent.
traceI :: (ChunkData t, Monad m) => String -> Iter t m ()
instance SendRecvString ByteString
instance SendRecvString ByteString
instance SendRecvString [Char]


-- | This module contains basic iteratees and enumerators for working with
--   strings, <a>ListLike</a> objects, file handles, and stream and
--   datagram sockets.
module Data.IterIO.ListLike

-- | An Iteratee that puts data to a consumer function, then calls an eof
--   function. For instance, <tt><a>handleI</a></tt> could be defined as:
--   
--   <pre>
--   handleI :: (MonadIO m) =&gt; <a>Handle</a> -&gt; <a>Iter</a> <a>ByteString</a> m ()
--   handleI h = putI (<a>liftIO</a> . <a>hPut</a> h) (<a>liftIO</a> $ <a>hShutdown</a> h 1)
--   </pre>
putI :: (ChunkData t, Monad m) => (t -> Iter t m a) -> Iter t m b -> Iter t m ()

-- | Send datagrams using a supplied function. The datagrams are fed as a
--   list of packets, where each element of the list should be a separate
--   datagram. For example, to create an <a>Iter</a> from a connected UDP
--   socket:
--   
--   <pre>
--   udpI :: (<a>SendRecvString</a> s, <a>MonadIO</a> m) =&gt; <a>Socket</a> -&gt; <a>Iter</a> s m ()
--   udpI sock = sendI $ <a>liftIO</a> . <a>genSend</a> sock
--   </pre>
sendI :: (Show t, Monad m) => (t -> Iter [t] m a) -> Iter [t] m ()

-- | Return the first element when the Iteratee data type is a list.
headLI :: (Show a, Monad m) => Iter [a] m a

-- | Return <a>Just</a> the first element when the Iteratee data type is a
--   list, or <a>Nothing</a> on EOF.
safeHeadLI :: (Show a, Monad m) => Iter [a] m (Maybe a)

-- | Like <a>headLI</a>, but works for any <a>ListLike</a> data type.
headI :: (ChunkData t, ListLike t e, Monad m) => Iter t m e

-- | Like <a>safeHeadLI</a>, but works for any <a>ListLike</a> data type.
safeHeadI :: (ChunkData t, ListLike t e, Monad m) => Iter t m (Maybe e)

-- | Return a line delimited by \r, \n, or \r\n.
lineI :: (Monad m, ChunkData t, ListLike t e, Eq t, Enum e, Eq e) => Iter t m t

-- | Like <a>lineI</a>, but returns <a>Nothing</a> on EOF.
safeLineI :: (ChunkData t, Monad m, ListLike t e, Eq t, Enum e, Eq e) => Iter t m (Maybe t)

-- | Return <a>ListLike</a> data that is at most the number of elements
--   specified by the first argument, and at least one element (as long as
--   a positive number is requested). Throws an exception if a positive
--   number of items is requested and an EOF is encountered.
dataMaxI :: (ChunkData t, ListLike t e, Monad m) => Int -> Iter t m t

-- | Return <a>ListLike</a> data that is at most the number of elements
--   specified by the first argument, and at least one element unless EOF
--   is encountered or 0 elements are requested, in which case
--   <a>mempty</a> is returned.
data0MaxI :: (ChunkData t, ListLike t e, Monad m) => Int -> Iter t m t

-- | Return the next <tt>len</tt> elements of a <a>ListLike</a> data
--   stream, unless an EOF is encountered, in which case fewer may be
--   returned. Note the difference from <a>data0MaxI</a>: <tt><a>takeI</a>
--   n</tt> will keep reading input until it has accumulated <tt>n</tt>
--   elements or seen an EOF, then return the data; <tt><a>data0MaxI</a>
--   n</tt> will keep reading only until it has received any non-empty
--   amount of data, even if the amount received is less than <tt>n</tt>
--   elements and there is no EOF.
takeI :: (ChunkData t, ListLike t e, Monad m) => Int -> Iter t m t

-- | Puts strings (or <a>ListLikeIO</a> data) to a file <a>Handle</a>, then
--   writes an EOF to the handle.
--   
--   Note that this does not put the handle into binary mode. To do this,
--   you may need to call <tt><a>hSetBinaryMode</a> h <a>True</a></tt> on
--   the handle before using it with <tt>handleI</tt>. Otherwise, Haskell
--   by default will treat the data as UTF-8. (On the other hand, if the
--   <a>Handle</a> corresponds to a socket and the socket is being read in
--   another thread, calling <a>hSetBinaryMode</a> can cause deadlock, so
--   in this case it is better to have the thread handling reads call
--   <a>hSetBinaryMode</a>.)
--   
--   Also note that Haskell by default buffers data written to
--   <a>Handle</a>s. For many network protocols this is a problem. Don't
--   forget to call <tt><a>hSetBuffering</a> h <a>NoBuffering</a></tt>
--   before passing a handle to <a>handleI</a>.
handleI :: (MonadIO m, ChunkData t, ListLikeIO t e) => Handle -> Iter t m ()

-- | Sends a list of packets to a datagram socket.
sockDgramI :: (MonadIO m, SendRecvString t) => Socket -> Maybe SockAddr -> Iter [t] m ()

-- | Sends output to a stream socket. Calls shutdown (e.g., to send a TCP
--   FIN packet) upon receiving EOF.
sockStreamI :: (ChunkData t, SendRecvString t, MonadIO m) => Socket -> Iter t m ()

-- | An <a>Iter</a> that uses <a>hPutStr</a> to write all output to
--   <a>stdout</a>.
stdoutI :: (ListLikeIO t e, ChunkData t, MonadIO m) => Iter t m ()

-- | A mode that determines the effect of <tt>hSeek</tt> <tt>hdl mode
--   i</tt>.
data SeekMode :: *

-- | the position of <tt>hdl</tt> is set to <tt>i</tt>.
AbsoluteSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the
--   current position.
RelativeSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the end
--   of the file.
SeekFromEnd :: SeekMode

-- | A control command (issued with <tt><a>ctlI</a> SizeC</tt>) requesting
--   the size of the current file being enumerated.
data SizeC
SizeC :: SizeC

-- | A control command for seeking within a file, when a file is being
--   enumerated. Flushes the residual input data.
data SeekC
SeekC :: !SeekMode -> !Integer -> SeekC

-- | A control command for determining the current offset within a file.
--   Note that this subtracts the size of the residual input data from the
--   offset in the file. Thus, it will only be accurate when all left-over
--   input data is from the current file.
data TellC
TellC :: TellC

-- | A handler function for the <a>SizeC</a>, <a>SeekC</a>, and
--   <a>TellC</a> control requests. <tt>fileCtl</tt> is used internally by
--   <a>enumFile</a> and <a>enumHandle</a>, and is exposed for similar
--   enumerators to use.
fileCtl :: (ChunkData t, ListLike t e, MonadIO m) => Handle -> CtlHandler (Iter () m) t m a

-- | A control request that returns the <a>Socket</a> from an enclosing
--   socket enumerator.
data GetSocketC
GetSocketC :: GetSocketC

-- | A handler for the <a>GetSocketC</a> control request.
socketCtl :: (ChunkData t, MonadIO m) => Socket -> CtlHandler (Iter () m) t m a

-- | Read datagrams (of up to 64KiB in size) from a socket and feed a list
--   of strings (one for each datagram) into an Iteratee.
enumDgram :: (MonadIO m, SendRecvString t) => Socket -> Onum [t] m a

-- | Read datagrams from a socket and feed a list of (Bytestring, SockAddr)
--   pairs (one for each datagram) into an Iteratee.
enumDgramFrom :: (MonadIO m, SendRecvString t) => Socket -> Onum [(t, SockAddr)] m a

-- | Read data from a stream (e.g., TCP) socket.
enumStream :: (MonadIO m, ChunkData t, SendRecvString t) => Socket -> Onum t m a

-- | Puts a handle into binary mode with <a>hSetBinaryMode</a>, then
--   enumerates data read from the handle to feed an <a>Iter</a> with any
--   <a>ListLikeIO</a> input type.
enumHandle :: (MonadIO m, ChunkData t, ListLikeIO t e) => Handle -> Onum t m a

-- | A variant of <a>enumHandle</a> type restricted to input in the Lazy
--   <a>ByteString</a> format.
enumHandle' :: MonadIO m => Handle -> Onum ByteString m a

-- | Feeds an <a>Iter</a> with data from a file handle, using any input
--   type in the <a>ListLikeIO</a> class. Note that
--   <tt>enumNonBinHandle</tt> uses the handle as is, unlike
--   <a>enumHandle</a>, and so can be used if you want to read the data in
--   non-binary form.
enumNonBinHandle :: (MonadIO m, ChunkData t, ListLikeIO t e) => Handle -> Onum t m a

-- | Enumerate the contents of a file for an <a>Iter</a> taking input in
--   any <a>ListLikeIO</a> type. Note that the file is opened with
--   <a>openBinaryFile</a> to ensure binary mode.
enumFile :: (MonadIO m, ChunkData t, ListLikeIO t e) => FilePath -> Onum t m a

-- | Enumerate the contents of a file as a series of lazy
--   <a>ByteString</a>s. (This is a type-restricted version of
--   <a>enumFile</a>.)
enumFile' :: MonadIO m => FilePath -> Onum ByteString m a

-- | Enumerate standard input.
enumStdin :: (MonadIO m, ChunkData t, ListLikeIO t e) => Onum t m a

-- | Feed up to some number of list elements (bytes in the case of
--   <a>ByteString</a>s) to an <a>Iter</a>, or feed fewer if the
--   <a>Iter</a> returns or an EOF is encountered. The formulation
--   <tt>inumMax n <a>.|</a> iter</tt> can be used to prevent <tt>iter</tt>
--   from consuming unbounded amounts of input.
inumMax :: (ChunkData t, ListLike t e, Monad m) => Int -> Inum t t m a

-- | Feed exactly some number of bytes to an <a>Iter</a>. Throws an error
--   if that many bytes are not available.
inumTakeExact :: (ChunkData t, ListLike t e, Monad m) => Int -> Inum t t m a

-- | This inner enumerator is like <a>inumNop</a> in that it passes
--   unmodified <a>Chunk</a>s straight through to an iteratee. However, it
--   also logs the <a>Chunk</a>s to a file (which can optionally be
--   truncated or appended to, based on the second argument).
inumLog :: (MonadIO m, ChunkData t, ListLikeIO t e) => FilePath -> Bool -> Inum t t m a

-- | Like <a>inumLog</a>, but takes a writeable file handle rather than a
--   file name. Does not close the handle when done.
inumhLog :: (MonadIO m, ChunkData t, ListLikeIO t e) => Handle -> Inum t t m a

-- | Log a copy of everything to standard error. (<tt>inumStderr =
--   <a>inumhLog</a> <a>stderr</a></tt>)
inumStderr :: (MonadIO m, ChunkData t, ListLikeIO t e) => Inum t t m a

-- | An <a>Inum</a> that converts input in the lazy <a>ByteString</a>
--   format to strict <a>ByteString</a>s.
inumLtoS :: Monad m => Inum ByteString ByteString m a

-- | The dual of <a>inumLtoS</a>--converts input from strict
--   <a>ByteString</a>s to lazy <a>ByteString</a>s.
inumStoL :: Monad m => Inum ByteString ByteString m a

-- | Add a finalizer to run when an <a>Iter</a> has received an EOF and an
--   <a>Inum</a> has finished. This works regardless of the order in which
--   the two events happen.
pairFinalizer :: (ChunkData t, ChunkData t1, ChunkData t2, MonadIO m, MonadIO m1) => Iter t m a -> Inum t1 t2 m1 b -> IO () -> IO (Iter t m a, Inum t1 t2 m1 b)

-- | "Iterizes" a file <a>Handle</a> by turning into an <a>Onum</a> (for
--   reading) and an <a>Iter</a> (for writing). Uses <a>pairFinalizer</a>
--   to <a>hClose</a> the <a>Handle</a> when both the <a>Iter</a> and
--   <a>Onum</a> are finished. Puts the handle into binary mode, but does
--   not change the buffering. As mentioned for <a>handleI</a>, Haskell's
--   default buffering can cause problems for many network protocols.
--   Hence, you may wish to call <tt><a>hSetBuffering</a> h
--   <a>NoBuffering</a></tt> before <tt>iterHandle h</tt>.
iterHandle :: (ListLikeIO t e, ChunkData t, MonadIO m) => Handle -> IO (Iter t m (), Onum t m a)

-- | "Iterizes" a stream <a>Socket</a> by turning into an <a>Onum</a> (for
--   reading) and an <a>Iter</a> (for writing). Uses <a>pairFinalizer</a>
--   to <a>sClose</a> the <a>Socket</a> when both the <a>Iter</a> and
--   <a>Onum</a> are finished.
iterStream :: (SendRecvString t, ChunkData t, MonadIO m) => Socket -> IO (Iter t m (), Onum t m a)
instance Typeable SizeC
instance Typeable SeekC
instance Typeable TellC
instance Typeable GetSocketC
instance CtlCmd GetSocketC Socket
instance CtlCmd TellC Integer
instance CtlCmd SeekC ()
instance CtlCmd SizeC Integer


-- | This module contains functions to help parsing input from within
--   <a>Iter</a>s. Many of the operators are either imported from
--   <a>Data.Applicative</a> or inspired by <a>Text.Parsec</a>.
module Data.IterIO.Parse

-- | An infix synonym for <a>multiParse</a> that allows LL(*) parsing of
--   alternatives by executing both Iteratees on input chunks as they
--   arrive. This is similar to the <tt>&lt;|&gt;</tt> method of the
--   <tt><tt>Alternative</tt></tt> class in <a>Control.Applicative</a>, but
--   the <tt><tt>Alternative</tt></tt> operator has left fixity, while for
--   efficiency this one has:
--   
--   <pre>
--   infixr 3 &lt;|&gt;
--   </pre>
(<|>) :: (ChunkData t, Monad m) => Iter t m a -> Iter t m a -> Iter t m a

-- | An infix synonym for <a>ifNoParse</a> that allows LL(*) parsing of
--   alternatives by keeping a copy of input data consumed by the first
--   Iteratee so as to backtrack and execute the second Iteratee if the
--   first one fails. Returns a function that takes a continuation for the
--   first <a>Iter</a>, should it succeed. The code:
--   
--   <pre>
--   iter1 \/ iter2 $ \iter1Result -&gt; doSomethingWith iter1Result
--   </pre>
--   
--   Executes <tt>iter1</tt> (saving a copy of the input for backtracking).
--   If <tt>iter1</tt> fails with an exception of class
--   <tt>IterNoParse</tt>, then the input is re-wound and fed to
--   <tt>iter2</tt>. On the other hand, if <tt>iter1</tt> succeeds and
--   returns <tt>iter1Result</tt>, then the saved input is discarded (as
--   <tt>iter2</tt> will not need to be run) and the result of
--   <tt>iter1</tt> is fed to function <tt>doSomethingWith</tt>.
--   
--   For example, to build up a list of results of executing <tt>iter</tt>,
--   one could implement a type-restricted version of <a>many</a> as
--   follows:
--   
--   <pre>
--   myMany :: (ChunkData t, Monad m) =&gt; Iter t m a -&gt; Iter t m [a]
--   myMany iter = iter \/ return [] <a>$</a> \r -&gt; <a>fmap</a> ((:) r) (myMany iter)
--   </pre>
--   
--   In other words, <tt>myMany</tt> tries running <tt>iter</tt>. If
--   <tt>iter</tt> fails, then <tt>myMany</tt> returns the empty list. If
--   <tt>iter</tt> succeeds, its result <tt>r</tt> is added to the head of
--   the list returned by calling <tt>myMany</tt> recursively. This idiom
--   of partially applying a binary funciton to a result and then applying
--   the resulting function to an <a>Iter</a> via <a>fmap</a> is so common
--   that there is an infix operator for it, <tt><a>&gt;$&gt;</a></tt>.
--   Thus, the above code can be written:
--   
--   <pre>
--   myMany iter = iter \/ return [] <a>$</a> (:) <a>&gt;$&gt;</a> myMany iter
--   </pre>
--   
--   Of course, using <a>fmap</a> is not the most efficient way to
--   implement <tt>myMany</tt>. If you are going to use this pattern for
--   something performance critical, you should use an accumulator rather
--   than build up long chains of <a>fmap</a>s. A faster implementation
--   would be:
--   
--   <pre>
--   myMany iter = loop id
--       where loop ac = iter \/ return (acc []) <a>$</a> a -&gt; loop (acc . (a :))
--   </pre>
--   
--   <tt>\/</tt> has fixity:
--   
--   <pre>
--   infix 2 \/
--   </pre>
(\/) :: (ChunkData t, Monad m) => Iter t m a -> Iter t m b -> (a -> Iter t m b) -> Iter t m b

-- | Defined as <tt>orEmpty = (<a>\/</a> return <a>mempty</a>)</tt>, and
--   useful when parse failures should just return an empty <a>Monoid</a>.
--   For example, a type-restricted <a>many</a> can be implemented as:
--   
--   <pre>
--   myMany :: (ChunkData t, Monad m) =&gt; Iter t m a -&gt; Iter t m [a]
--   myMany iter = iter `<a>orEmpty</a>` (:) <a>&gt;$&gt;</a> myMany iter
--   </pre>
--   
--   Has fixity:
--   
--   <pre>
--   infixr 3 `orEmpty`
--   </pre>
orEmpty :: (ChunkData t, Monad m, Monoid b) => Iter t m a -> (a -> Iter t m b) -> Iter t m b

-- | <tt>iter &lt;?&gt; token</tt> replaces any kind of parse failure in
--   <tt>iter</tt> with an exception equivalent to calling
--   <tt><a>expectedI</a> prefix token</tt> where <tt>prefix</tt> is a
--   prefix of the input that was fed to <tt>iter</tt> and caused it to
--   fail.
--   
--   Has fixity:
--   
--   <pre>
--   infix 0 &lt;?&gt;
--   </pre>
(<?>) :: (ChunkData t, Monad m) => Iter t m a -> String -> Iter t m a

-- | Throw an <a>Iter</a> exception that describes expected input not
--   found.
expectedI :: ChunkData t => String -> String -> Iter t m a

-- | Repeatedly invoke an <a>Iter</a> and right-fold a function over the
--   results.
foldrI :: (ChunkData t, Monad m) => (a -> b -> b) -> b -> Iter t m a -> Iter t m b

-- | A variant of <a>foldrI</a> that requires the <a>Iter</a> to succeed at
--   least once.
foldr1I :: (ChunkData t, Monad m) => (a -> b -> b) -> b -> Iter t m a -> Iter t m b

-- | A variant of <a>foldrI</a> that requires the <a>Iter</a> to succeed at
--   least a minimum number of items and stops parsing after executing the
--   <a>Iter</a> some maximum number of times.
foldrMinMaxI :: (ChunkData t, Monad m) => Int -> Int -> (a -> b -> b) -> b -> Iter t m a -> Iter t m b

-- | Strict left fold over an <a>Iter</a> (until it throws an
--   <tt>IterNoParse</tt> exception). <tt>foldlI f z iter</tt> is sort of
--   equivalent to:
--   
--   <pre>
--   ... (f &lt;$&gt; (f &lt;$&gt; (f z &lt;$&gt; iter) &lt;*&gt; iter) &lt;*&gt; iter) ...
--   </pre>
foldlI :: (ChunkData t, Monad m) => (b -> a -> b) -> b -> Iter t m a -> Iter t m b

-- | A version of <a>foldlI</a> that fails if the <a>Iter</a> argument does
--   not succeed at least once.
foldl1I :: (ChunkData t, Monad m) => (b -> a -> b) -> b -> Iter t m a -> Iter t m b

-- | <tt>foldMI</tt> is a left fold in which the folding function can
--   execute monadic actions. Essentially <tt>foldMI</tt> is to
--   <a>foldlI</a> as <a>foldM</a> is to <tt><tt>foldl'</tt></tt> in the
--   standard libraries.
foldMI :: (ChunkData t, Monad m) => (b -> a -> Iter t m b) -> b -> Iter t m a -> Iter t m b

-- | A variant of <a>foldMI</a> that requires the <a>Iter</a> to succeed at
--   least once.
foldM1I :: (ChunkData t, Monad m) => (b -> a -> Iter t m b) -> b -> Iter t m a -> Iter t m b

-- | Discard the result of executing an Iteratee once. Throws an error if
--   the Iteratee fails. (Like <tt>skip x = x &gt;&gt; return ()</tt>.)
skipI :: Applicative f => f a -> f ()

-- | Execute an iteratee. Discard the result if it succeeds. Rewind the
--   input and suppress the error if it fails.
optionalI :: (ChunkData t, Monad m) => Iter t m a -> Iter t m ()

-- | Ensures the next input element satisfies a predicate or throws a parse
--   error. Does not consume any input.
ensureI :: (ChunkData t, ListLike t e, Monad m) => (e -> Bool) -> Iter t m ()

-- | A variant of the standard library <a>ord</a> function, but that
--   translates a <a>Char</a> into any <a>Enum</a> type, not just
--   <a>Int</a>. Particularly useful for <a>Iter</a>s that must work with
--   both <a>String</a>s (which consist of <a>Char</a>s) and ASCII
--   <tt><tt>ByteString</tt></tt>s (which consist of
--   <tt><tt>Word8</tt></tt>s). For example, to skip one or more space or
--   TAB characters, you can use:
--   
--   <pre>
--   skipSpace :: (<a>ListLike</a> t e, ChunkData t, <a>Eq</a> e, <a>Enum</a> e, Monad m) =&gt;
--                <a>Iter</a> t m ()
--   skipSpace = <a>skipWhile1I</a> (\c -&gt; c == eord ' ' || c == eord '\t')
--   </pre>
eord :: Enum e => Char -> e

-- | Skip all input elements encountered until an element is found that
--   does not match the specified predicate.
skipWhileI :: (ChunkData t, ListLike t e, Monad m) => (e -> Bool) -> Iter t m ()

-- | Like <a>skipWhileI</a>, but fails if at least one element does not
--   satisfy the predicate.
skipWhile1I :: (ChunkData t, ListLike t e, Monad m) => (e -> Bool) -> Iter t m ()

-- | Return all input elements up to the first one that does not match the
--   specified predicate.
whileI :: (ChunkData t, ListLike t e, Monad m) => (e -> Bool) -> Iter t m t

-- | Like <a>whileI</a>, but fails if at least one element does not satisfy
--   the predicate.
while1I :: (ChunkData t, ListLike t e, Monad m) => (e -> Bool) -> Iter t m t

-- | A variant of <a>whileI</a> with a maximum number matches.
whileMaxI :: (ChunkData t, ListLike t e, Monad m) => Int -> (e -> Bool) -> Iter t m t

-- | A variant of <a>whileI</a> with a minimum and maximum number matches.
whileMinMaxI :: (ChunkData t, ListLike t e, Monad m) => Int -> Int -> (e -> Bool) -> Iter t m t

-- | Repeatedly execute an <a>Iter</a> returning a <a>Monoid</a> and
--   <a>mappend</a> all the results in a right fold.
concatI :: (ChunkData t, Monoid s, Monad m) => Iter t m s -> Iter t m s

-- | Like <a>concatI</a>, but fails if the <a>Iter</a> doesn't return at
--   least once.
concat1I :: (ChunkData t, Monoid s, Monad m) => Iter t m s -> Iter t m s

-- | A version of <a>concatI</a> that takes a minimum and maximum number of
--   items to parse.
concatMinMaxI :: (ChunkData t, Monoid s, Monad m) => Int -> Int -> Iter t m s -> Iter t m s

-- | This <a>Iter</a> parses a <a>StringLike</a> argument. It does not
--   consume any Iteratee input. The only reason it is an Iteratee is so
--   that it can throw an Iteratee parse error should it fail to parse the
--   argument string (or should the argument yield an ambiguous parse).
readI :: (ChunkData t, Monad m, StringLike s, Read a) => s -> Iter t m a

-- | Ensures the input is at the end-of-file marker, or else throws an
--   exception.
eofI :: (ChunkData t, Monad m, Show t) => Iter t m ()

-- | An infix synonym for <a>fmap</a>.
(<$>) :: Functor f => (a -> b) -> f a -> f b

-- | Replace all locations in the input with the same value. The default
--   definition is <tt><a>fmap</a> . <a>const</a></tt>, but this may be
--   overridden with a more efficient version.
(<$) :: Functor f => forall a b. a -> f b -> f a

-- | <tt>fa $&gt; b = b &lt;$ fa</tt> -- replaces the output value of a
--   functor with some pure value. Has the same fixity as <a>&lt;$&gt;</a>
--   and <a>&lt;$</a>, namely:
--   
--   <pre>
--   infixl 4 $&gt;
--   </pre>
($>) :: Functor f => f a -> b -> f b

-- | <tt>(f &gt;$&gt; a) t</tt> is equivalent to <tt>f t <a>&lt;$&gt;</a>
--   a</tt> (where <a>&lt;$&gt;</a> is and infix alias for <a>fmap</a>).
--   Particularly useful with infix combinators such as <a>\/</a> and
--   `<a>orEmpty</a>` when chaining parse actions. See examples at
--   <a>\/</a> and <a>orEmpty</a>. Note <a>fmap</a> is not always the most
--   efficient solution (see an example in the description of <a>\/</a>).
--   
--   Has fixity:
--   
--   <pre>
--   infixl 3 &gt;$&gt;
--   </pre>
(>$>) :: Functor f => (t -> a -> b) -> f a -> t -> f b

-- | A functor with application, providing operations to
--   
--   <ul>
--   <li>embed pure expressions (<a>pure</a>), and</li>
--   <li>sequence computations and combine their results
--   (<a>&lt;*&gt;</a>).</li>
--   </ul>
--   
--   A minimal complete definition must include implementations of these
--   functions satisfying the following laws:
--   
--   <ul>
--   <li><i><i>identity</i></i> <tt><a>pure</a> <a>id</a> <a>&lt;*&gt;</a>
--   v = v</tt></li>
--   <li><i><i>composition</i></i> <tt><a>pure</a> (.) <a>&lt;*&gt;</a> u
--   <a>&lt;*&gt;</a> v <a>&lt;*&gt;</a> w = u <a>&lt;*&gt;</a> (v
--   <a>&lt;*&gt;</a> w)</tt></li>
--   <li><i><i>homomorphism</i></i> <tt><a>pure</a> f <a>&lt;*&gt;</a>
--   <a>pure</a> x = <a>pure</a> (f x)</tt></li>
--   <li><i><i>interchange</i></i> <tt>u <a>&lt;*&gt;</a> <a>pure</a> y =
--   <a>pure</a> (<a>$</a> y) <a>&lt;*&gt;</a> u</tt></li>
--   </ul>
--   
--   The other methods have the following default definitions, which may be
--   overridden with equivalent specialized implementations:
--   
--   <pre>
--   u <a>*&gt;</a> v = <a>pure</a> (<a>const</a> <a>id</a>) <a>&lt;*&gt;</a> u <a>&lt;*&gt;</a> v
--   u <a>&lt;*</a> v = <a>pure</a> <a>const</a> <a>&lt;*&gt;</a> u <a>&lt;*&gt;</a> v
--   </pre>
--   
--   As a consequence of these laws, the <a>Functor</a> instance for
--   <tt>f</tt> will satisfy
--   
--   <pre>
--   <a>fmap</a> f x = <a>pure</a> f <a>&lt;*&gt;</a> x
--   </pre>
--   
--   If <tt>f</tt> is also a <a>Monad</a>, it should satisfy
--   <tt><a>pure</a> = <a>return</a></tt> and <tt>(<a>&lt;*&gt;</a>) =
--   <a>ap</a></tt> (which implies that <a>pure</a> and <a>&lt;*&gt;</a>
--   satisfy the applicative functor laws).
class Functor f => Applicative (f :: * -> *)
pure :: Applicative f => a -> f a
(<*>) :: Applicative f => f (a -> b) -> f a -> f b
(*>) :: Applicative f => f a -> f b -> f b
(<*) :: Applicative f => f a -> f b -> f a

-- | A variant of <a>&lt;*&gt;</a> with the arguments reversed.
(<**>) :: Applicative f => f a -> f (a -> b) -> f b

-- | <a>mappend</a> the result of two <a>Applicative</a> types returning
--   <a>Monoid</a> types (<tt>&lt;++&gt; = <a>liftA2</a>
--   <a>mappend</a></tt>). Has the same fixity as <a>++</a>, namely:
--   
--   <pre>
--   infixr 5 &lt;++&gt;
--   </pre>
(<++>) :: (Applicative f, Monoid t) => f t -> f t -> f t

-- | <a>cons</a> an <a>Applicative</a> type onto an an <a>Applicative</a>
--   <a>ListLike</a> type (<tt>&lt;:&gt; = <a>liftA2</a> <a>cons</a></tt>).
--   Has the same fixity as <tt>:</tt>, namely:
--   
--   <pre>
--   infixr 5 &lt;:&gt;
--   </pre>
(<:>) :: (ListLike t e, Applicative f) => f e -> f t -> f t

-- | <tt>nil = <a>pure</a> <a>mempty</a></tt>--An empty <a>Monoid</a>
--   injected into an <a>Applicative</a> type.
nil :: (Applicative f, Monoid t) => f t

-- | Run an <a>Iter</a> zero or more times (until it fails) and return a
--   list-like container of the results.
many :: (ChunkData t, ListLike f a, Monad m) => Iter t m a -> Iter t m f

-- | Repeatedly run an <a>Iter</a> until it fails and discard all the
--   results.
skipMany :: (ChunkData t, Monad m) => Iter t m a -> Iter t m ()

-- | Parses a sequence of the form <i>Item1 Separator Item2 Separator ...
--   Separator ItemN</i> and returns the list
--   <tt>[</tt><i>Item1</i><tt>,</tt> <i>Item2</i><tt>,</tt> ...<tt>,</tt>
--   <i>ItemN</i><tt>]</tt> or a <a>ListLike</a> equivalent.
sepBy :: (ChunkData t, ListLike f a, Monad m) => Iter t m a -> Iter t m b -> Iter t m f

-- | Like <a>sepBy</a>, but expects a separator after the final item. In
--   other words, parses a sequence of the form <i>Item1 Separator Item2
--   Separator ... Separator ItemN Separator</i> and returns the list
--   <tt>[</tt><i>Item1</i><tt>,</tt> <i>Item2</i><tt>,</tt> ...<tt>,</tt>
--   <i>ItemN</i><tt>]</tt> or a <a>ListLike</a> equivalent.
endBy :: (ChunkData t, ListLike f a, Monad m) => Iter t m a -> Iter t m b -> Iter t m f

-- | Accepts items that would be parsed by either <a>sepBy</a> or
--   <a>endBy</a>. Essentially a version of <a>endBy</a> in which the final
--   separator is optional.
sepEndBy :: (ChunkData t, ListLike f a, Monad m) => Iter t m a -> Iter t m b -> Iter t m f

-- | Run an <a>Iter</a> one or more times (until it fails) and return a
--   list-like container of the results.
many1 :: (ChunkData t, ListLike f a, Monad m) => Iter t m a -> Iter t m f

-- | A variant of <a>skipMany</a> that throws a parse error if the
--   <a>Iter</a> does not succeed at least once.
skipMany1 :: (ChunkData t, Monad m) => Iter t m a -> Iter t m ()

-- | A variant of <a>sepBy</a> that throws a parse error if it cannot
--   return at least one item.
sepBy1 :: (ChunkData t, ListLike f a, Monad m) => Iter t m a -> Iter t m b -> Iter t m f

-- | A variant of <a>endBy</a> that throws a parse error if it cannot
--   return at least one item.
endBy1 :: (ChunkData t, ListLike f a, Monad m) => Iter t m a -> Iter t m b -> Iter t m f

-- | A variant of <a>sepEndBy</a> that throws a parse error if it cannot
--   return at least one item.
sepEndBy1 :: (ChunkData t, ListLike f a, Monad m) => Iter t m a -> Iter t m b -> Iter t m f

-- | Read the next input element if it satisfies some predicate. Otherwise
--   throw an error.
satisfy :: (ChunkData t, ListLike t e, Enum e, Monad m) => (e -> Bool) -> Iter t m e

-- | Read input that exactly matches a character.
char :: (ChunkData t, ListLike t e, Eq e, Enum e, Monad m) => Char -> Iter t m e

-- | Read input that exactly matches some target.
match :: (ChunkData t, ListLike t e, Eq e, Monad m) => t -> Iter t m t

-- | Read input that exactly matches a string.
string :: (ChunkData t, ListLike t e, StringLike t, Eq e, Monad m) => String -> Iter t m t

-- | Read input that matches a string up to case.
stringCase :: (ChunkData t, ListLike t e, Enum e, Eq e, Monad m) => String -> Iter t m t

module Data.IterIO.Search

-- | Feeds input to an Iteratee until some boundary string is found. The
--   boundary string is neither consumed nor passed through to the target
--   <a>Iter</a>. (Thus, if the input is at end-of-file after
--   inumStopString returns, it means the boundary string was never
--   encountered.)
inumStopString :: Monad m => ByteString -> Inum ByteString ByteString m a

-- | Reads input until it can uniquely determine the longest key in a
--   <a>Map</a> that is a prefix of the input. Consumes the input that
--   matches the key, and returns the corresponding value in the
--   <a>Map</a>, along with the residual input that follows the key.
mapI :: (ChunkData t, ListLike t e, Ord t, Eq e, Monad m) => Map t a -> Iter t m a

-- | <tt>mapLI</tt> is a variant of <a>mapI</a> that takes a list of
--   <tt>(key, value)</tt> pairs instead of a <a>Map</a>. <tt>mapLI =
--   <a>mapI</a> . <a>fromList</a></tt>.
mapLI :: (ChunkData t, ListLike t e, Ord t, Eq e, Monad m) => [(t, a)] -> Iter t m a

module Data.IterIO.SSL

-- | A wrapper around the type <a>SSL</a> to make it an instance of the
--   <a>Typeable</a> class.
newtype SslConnection
SslConnection :: SSL -> SslConnection
unSslConnection :: SslConnection -> SSL

-- | Control request to fetch the <tt>SSL</tt> object associated with an
--   enumerator.
data SslC
SslC :: SslC

-- | Simple OpenSSL <a>Onum</a>.
enumSsl :: MonadIO m => SSL -> Onum ByteString m a

-- | Simple OpenSSL <a>Iter</a>. Does a uni-directional SSL shutdown when
--   it receives a <a>Chunk</a> with the EOF bit <a>True</a>.
sslI :: MonadIO m => SSL -> Iter ByteString m ()

-- | Turn a socket into an <a>Iter</a> and <a>Onum</a> that use OpenSSL to
--   write to and read from the socket, respectively. Does an SSL
--   bi-directional shutdown and closes the socket when both a) the enum
--   completes and b) the iter has received an EOF chunk.
--   
--   If the SSL handshake fails, then <tt>iterSSL</tt> closes the socket
--   before throwing an exception.
--   
--   This funciton must only be invoked from within a call to
--   <tt>withOpenSSL</tt>.
iterSSL :: MonadIO m => SSLContext -> Socket -> Bool -> IO (Iter ByteString m (), Onum ByteString m a)

-- | Simplest possible SSL context, loads cert and unencrypted private key
--   from a single file.
simpleContext :: FilePath -> IO SSLContext

-- | Quick and dirty funciton to generate a self signed certificate for
--   testing and stick it in a file. E.g.:
--   
--   <pre>
--   genSelfSigned "testkey.pem" "localhost"
--   </pre>
genSelfSigned :: FilePath -> String -> IO ()
instance Typeable SslConnection
instance Typeable SslC
instance CtlCmd SslC SslConnection

module Data.IterIO.Zlib

-- | State used by <a>inumZState</a>, the most generic zlib <a>Inum</a>.
--   Create the state using <a>deflateInit2</a> or <a>inflateInit2</a>.
data ZState

-- | Create a <a>ZState</a> for compression. See the description of
--   <tt>deflateInit2</tt> in the zlib.h C header file for a more detailed
--   description of the arguments. Note in particular that the value of
--   <tt>windowBits</tt> determines the encapsulation format of the
--   compressed data:
--   
--   <ul>
--   <li>8..15 = zlib format</li>
--   <li>24..31 = gzip format</li>
--   <li>-8..-15 = means raw zlib format with no header</li>
--   </ul>
deflateInit2 :: CInt -> ZMethod -> CInt -> CInt -> ZStrategy -> IO ZState

-- | Create a <tt>Zstate</tt> for uncompression. See the description of
--   <tt>inflateInit2</tt> in the zlib.h C header file for a more detailed
--   description of the arguments. Note in particular that the value of
--   <tt>windowBits</tt> determines the encapsulation format of the
--   compressed data:
--   
--   <ul>
--   <li>8..15 = zlib format</li>
--   <li>24..31 = gzip format</li>
--   <li>40..47 = automatically determine zlib/gzip format</li>
--   <li>-8..-15 = means raw zlib format with no header</li>
--   </ul>
inflateInit2 :: CInt -> IO ZState

-- | The most general zlib <a>Inum</a>, which can take any <a>ZState</a>
--   created by <a>deflateInit2</a> or <a>inflateInit2</a>.
inumZState :: MonadIO m => ZState -> Inum ByteString ByteString m a

-- | An <a>Inum</a> that compresses in zlib format. To uncompress, use
--   <a>inumGunzip</a>.
inumZlib :: MonadIO m => Inum ByteString ByteString m a

-- | An <a>Inum</a> that compresses in gzip format.
inumGzip :: MonadIO m => Inum ByteString ByteString m a

-- | An <a>Inum</a> that uncompresses a data in either the zlib or gzip
--   format. Note that this only uncompresses one gzip stream. Thus, if you
--   feed in the concatenation of multiple gzipped files,
--   <tt>inumGunzip</tt> will stop after the first one. If this is not what
--   you want, then use <tt><a>inumRepeat</a> inumGunzip</tt> to decode
--   repeated gzip streams.
inumGunzip :: MonadIO m => Inum ByteString ByteString m a

-- | Use this value for zlib format. Add 16 for gzip format. Negate for raw
--   zlib format. When uncompressing, add 32 to determine zlib/gzip format
--   automatically.
max_wbits :: CInt
max_mem_level :: CInt
def_mem_level :: CInt
zlib_version :: CString
z_DEFAULT_COMPRESSION :: CInt
data ZStrategy
z_FILTERED :: ZStrategy
z_HUFFMAN_ONLY :: ZStrategy
z_RLE :: ZStrategy
z_FIXED :: ZStrategy
z_DEFAULT_STRATEGY :: ZStrategy
data ZMethod
z_DEFLATED :: ZMethod


-- | This is the main module to import for the IterIO package. It
--   re-exports several other modules and mostly consists of
--   documentation--first a high-level overview of the iteratee model, then
--   a more detailed tutorial, finally a discussion of the differences from
--   other iteratee packages and acknowledgments.
--   
--   See the <a>Data.IterIO.Iter</a>, <a>Data.IterIO.Inum</a>, and
--   <a>Data.IterIO.ListLike</a> modules for more detailed documentation of
--   data structures and functions. In addition, <a>Data.IterIO.Trans</a>
--   (also re-exported by this module) supplies functions that help you
--   invoke monad transformers from the mtl library from within the
--   <a>Iter</a> monad.
--   
--   Several other potentially useful modules in the package are not
--   exported by default:
--   
--   <ul>
--   <li><a>Data.IterIO.Parse</a> includes parsec-like parsing combinators
--   for iteratee input.</li>
--   <li><a>Data.IterIO.Zlib</a> provides zlib and gzip format compression
--   and decompression.</li>
--   <li><a>Data.IterIO.SSL</a> provides support for SSL.</li>
--   <li><a>Data.IterIO.Http</a> provides support for parsing and
--   formatting HTTP, including handling form and file uploads (which can
--   be processed in constant space). This may be useful in conjunction
--   with <a>Data.IterIO.HttpRoute</a>, which provides simple request
--   routing support for web servers.</li>
--   <li><a>Data.IterIO.Atto</a> provides support for running attoparsec
--   parsers on iteratee input (see
--   <a>http://hackage.haskell.org/package/attoparsec/</a>).</li>
--   <li><a>Data.IterIO.Extra</a> provides debugging functions, as well as
--   a loopback iteratee that can be used to test a protocol implementation
--   against itself.</li>
--   </ul>
module Data.IterIO


-- | This module contains an adapter function to run attoparsec
--   <a>Parser</a>s from within the <a>Iter</a> monad.
module Data.IterIO.Atto

-- | Class of types whose <a>Iter</a>s can be converted to strict
--   <a>ByteString</a>s. Basically just strict <a>ByteString</a>s and lazy
--   <a>ByteString</a>s. This class mostly exists so that the <a>atto</a>
--   function can work with either type of ByteString.
class ChunkData t => IterStrictByteString t
fromIterStrictByteString :: (IterStrictByteString t, Monad m) => Iter ByteString m a -> Iter t m a

-- | Run an attoparsec parser in an <a>Iter</a> monad. Throws an
--   <a>IterFail</a> exception with constructor <a>IterParseErr</a> if the
--   parse fails. (This exception can be handled with <a>multiParse</a> and
--   <a>ifParse</a>.)
atto :: (IterStrictByteString t, Monad m) => Parser a -> Iter t m a

-- | Try running an attoparsec parser. Returns <tt><a>Right</a> a</tt> if
--   the parser succeeds with result <tt>a</tt>. Returns <tt><a>Left</a>
--   err</tt> where <tt>err</tt> is an error message otherwise. Note that
--   the input stream will be in an indeterminate state should the parser
--   fail. (If you need to keep parsing input from some known state, it may
--   be better to use <a>atto</a> in conjunction with <a>multiParse</a>.)
tryAtto :: (IterStrictByteString t, Monad m) => Parser a -> Iter t m (Either String a)
instance IterStrictByteString ByteString
instance IterStrictByteString ByteString

module Data.IterIO.Http

-- | Data structure representing an HTTP request message.
data HttpReq s
HttpReq :: !ByteString -> !ByteString -> !ByteString -> ![ByteString] -> ![ByteString] -> ![ByteString] -> !ByteString -> !ByteString -> !Maybe Int -> !(Int, Int) -> ![(ByteString, ByteString)] -> ![(ByteString, ByteString)] -> !Maybe (ByteString, [(ByteString, ByteString)]) -> !Maybe Int -> !ByteString -> !Maybe UTCTime -> s -> HttpReq s

-- | Scheme (e.g., 'http', 'https', ...)
reqScheme :: HttpReq s -> !ByteString

-- | Method (e.g., GET, POST, ...).
reqMethod :: HttpReq s -> !ByteString

-- | Raw path from the URL (not needed if you use <tt>reqPathList</tt> and
--   <tt>reqPathParams</tt>).
reqPath :: HttpReq s -> !ByteString

-- | URL request path, broken into a list of directory components, and
--   normalized to remove <tt>"."</tt> and process <tt>".."</tt>.
reqPathLst :: HttpReq s -> ![ByteString]

-- | Used by <tt>routeVar</tt> to save pathname components that are
--   variables (used as a stack, so the last variable saved is the first
--   one in the list).
reqPathParams :: HttpReq s -> ![ByteString]

-- | Stores pathname components that have been stripped off of
--   <tt>reqPathLst</tt> during routing.
reqPathCtx :: HttpReq s -> ![ByteString]

-- | The portion of the URL after the <tt>?</tt> character (if any).
reqQuery :: HttpReq s -> !ByteString

-- | Lower-case host header (or the host from the request line, if the
--   request is for an absolute URI).
reqHost :: HttpReq s -> !ByteString

-- | Port number if supplied in Host header.
reqPort :: HttpReq s -> !Maybe Int

-- | HTTP version major and minor number from the request line.
reqVers :: HttpReq s -> !(Int, Int)

-- | List of all header field names and values in the HTTP request. Field
--   names are converted to lowercase to allow easier searching.
reqHeaders :: HttpReq s -> ![(ByteString, ByteString)]

-- | List of Cookies supplied in the request.
reqCookies :: HttpReq s -> ![(ByteString, ByteString)]

-- | Parsed version of the Content-Type header, if any. The first
--   <a>ByteString</a> is the actual content type. Following this is a list
--   of parameter names and values. The most useful parameter is
--   <tt>"boundary"</tt>, used with the <tt>multipart/form-data</tt>
--   content type.
reqContentType :: HttpReq s -> !Maybe (ByteString, [(ByteString, ByteString)])

-- | Value of the content-Length header, if any.
reqContentLength :: HttpReq s -> !Maybe Int

-- | The Transfer-Encoding header.
reqTransferEncoding :: HttpReq s -> !ByteString

-- | Time from the If-Modified-Since header (if present)
reqIfModifiedSince :: HttpReq s -> !Maybe UTCTime

-- | Application-specific session information
reqSession :: HttpReq s -> s
defaultHttpReq :: HttpReq ()

-- | Returns a normalized version of the full requested path (including all
--   context in <tt>reqCtx</tt>) in the URL (e.g., where <tt>"."</tt> has
--   been eliminated, <tt>".."</tt> has been processed, there is exactly
--   one <tt>'/'</tt> between each directory component, and the query has
--   been stripped off).
reqNormalPath :: HttpReq s -> ByteString

-- | Parse an HTTP header, returning an <a>HttpReq</a> data structure.
httpReqI :: Monad m => Iter ByteString m (HttpReq ())

-- | This <a>Inum</a> reads to the end of an HTTP message body (and not
--   beyond) and decodes the Transfer-Encoding. It handles straight content
--   of a size specified by the Content-Length header and chunk-encoded
--   content.
inumHttpBody :: Monad m => HttpReq s -> Inum ByteString ByteString m a

-- | An HTTP Chunk encoder (as specified by RFC 2616).
inumToChunks :: Monad m => Inum ByteString ByteString m a

-- | An HTTP Chunk decoder (as specified by RFC 2616).
inumFromChunks :: Monad m => Inum ByteString ByteString m a

-- | Formats a time in the format specified by RFC 2616.
http_fmt_time :: UTCTime -> String

-- | Parses a Date/Time string in any one of the three formats specified by
--   RFC 2616.
dateI :: Monad m => Iter ByteString m UTCTime

-- | Data structure representing the name and metadata of a control in a
--   submitted form.
data FormField
FormField :: !ByteString -> ![(ByteString, ByteString)] -> ![(ByteString, ByteString)] -> FormField

-- | Name of the form control being processed
ffName :: FormField -> !ByteString

-- | Parameters from the <tt>Content-Disposition:</tt> header. This only
--   applies to <tt>Content-Type: multipart/form-data</tt>, and will be
--   empty for forms of type application/x-www-form-urlencoded or forms
--   submitted in the URL parameters of a GET request.
ffParams :: FormField -> ![(ByteString, ByteString)]

-- | Extra headers following the <tt>Content-Disposition:</tt> header of a
--   <tt>multipart/form-data</tt> post. Empty for other kinds of form
--   submission.
ffHeaders :: FormField -> ![(ByteString, ByteString)]

-- | Parses a form, and folds a function over each control. The value of
--   each control is available through Iteratee input. Thus, you can
--   extract the submitted value with <a>pureI</a>, or redirect it
--   elsewhere by executing another <a>Iter</a>. For example, to parse a
--   form and print it to standard output (without buffering possibly large
--   file uploads in memory):
--   
--   <pre>
--   do let docontrol _ field = do
--            liftIO $ putStrLn $
--                "The value of " ++ (S8.unpack $ ffName field) ++ " is:"
--            stdoutI                   -- Send form value to standard output
--            liftIO $ putStrLn "\n"
--      foldForm req docontrol ()
--   </pre>
--   
--   Or to produce a list of (field, value) pairs, you can say something
--   like:
--   
--   <pre>
--   do let docontrol acc field = do
--            val &lt;- pureI
--            return $ (ffName field, val) : acc
--      foldForm req docontrol []
--   </pre>
--   
--   Note that for POSTed forms of enctype
--   <tt>application/x-www-form-urlencoded</tt>, <tt>foldForm</tt> will
--   read to the end of its input. Thus, it is important to ensure
--   <tt>foldForm</tt> is called from within an <a>inumHttpBody</a>
--   enumerator (which is guaranteed by <a>inumHttpServer</a>).
foldForm :: Monad m => HttpReq s -> (a -> FormField -> Iter ByteString m a) -> a -> Iter ByteString m a

-- | Enumerate a request, and body.
enumHttpReq :: Monad m => HttpReq s -> L -> Onum L m a

-- | HTTP status code and text description of response, for the first line
--   of an HTTP response message. A bunch of pre-defined statuses from RFC
--   2616 are supplied under the names <a>stat200</a>, <a>stat404</a>,
--   <a>stat500</a>, etc.
data HttpStatus
HttpStatus :: !Int -> !ByteString -> HttpStatus
stat100, stat501, stat500, stat405, stat404, stat403, stat401, stat400, stat307, stat304, stat303, stat302, stat301, stat200 :: HttpStatus

-- | A data structure describing an HTTP response message to be sent,
--   parameterized by the Monad in which the response will be written to
--   the network.
data HttpResp m
HttpResp :: !HttpStatus -> ![(ByteString, ByteString)] -> !Bool -> !Onum ByteString m (IterR ByteString m ()) -> HttpResp m

-- | The response status.
respStatus :: HttpResp m -> !HttpStatus

-- | Headers to send back
respHeaders :: HttpResp m -> ![(ByteString, ByteString)]

-- | True if the message body should be passed through <a>inumToChunks</a>
--   and a "<tt>Transfer-Encoding: chunked</tt>" header should be added.
--   Generally this should be <a>True</a> unless you have added a
--   <tt>Content-Length</tt> header, manually set up chunk encoding by
--   fusing it in <a>respBody</a>, or are not returning a message body with
--   the reply.
respChunk :: HttpResp m -> !Bool

-- | <a>Onum</a> producing the message body. Use <a>inumNull</a> (which is
--   an empty <a>Inum</a>) to produce an empty body for responses that do
--   not contain a body.
respBody :: HttpResp m -> !Onum ByteString m (IterR ByteString m ())

-- | An empty HTTP response, to which you must add headers and possibly a
--   message body.
defaultHttpResp :: Monad m => HttpResp m

-- | Add header to the HTTP response.
respAddHeader :: (ByteString, ByteString) -> HttpResp m -> HttpResp m

-- | Generate an <a>HttpResp</a> without a body.
mkHttpHead :: Monad m => HttpStatus -> HttpResp m

-- | Generate an <a>HttpResp</a> with a body of type <tt>text/html</tt>.
mkHtmlResp :: Monad m => HttpStatus -> ByteString -> HttpResp m

-- | Make an <a>HttpResp</a> of an arbitrary content-type based on a pure
--   lazy <a>ByteString</a>. Since the result is pure, this function first
--   measures its length so as to set a Content-Length header instead of
--   using HTTP chunk encoding.
mkContentLenResp :: Monad m => HttpStatus -> String -> ByteString -> HttpResp m

-- | Make an <a>HttpResp</a> of an arbitrary content-type based on an
--   <a>Onum</a> that will dynamically generate the message body. Since the
--   message body is generated dynamically, the reply will use an HTTP
--   chunk encoding.
mkOnumResp :: Monad m => HttpStatus -> String -> Onum ByteString m (IterR ByteString m ()) -> HttpResp m

-- | Generate a 301 (redirect) response.
resp301 :: Monad m => String -> HttpResp m

-- | Generate a 303 (see other) response.
resp303 :: Monad m => String -> HttpResp m

-- | Generate a 403 (forbidden) response.
resp403 :: Monad m => HttpReq s -> HttpResp m

-- | Generate a 404 (not found) response.
resp404 :: Monad m => HttpReq s -> HttpResp m

-- | Generate a 405 (method not allowed) response.
resp405 :: Monad m => HttpReq s -> HttpResp m

-- | Generate a 500 (internal server error) response.
resp500 :: Monad m => String -> HttpResp m

-- | Format and enumerate a response header and body.
enumHttpResp :: Monad m => HttpResp m -> Onum ByteString m ()

-- | Return a response. If the 'Trasnfer-Encoding' header is set to
--   'chunked', it is removed from the headers and the <a>respChunk</a>
--   field is set. <a>enumHttpResp</a> to enumerate the headers and body.
httpRespI :: MonadIO m => Iter L m (HttpResp m)

-- | Given the headers of an HTTP request, provides an iteratee that will
--   process the request body (if any) and return a response.
type HttpRequestHandler m s = HttpReq s -> Iter ByteString m (HttpResp m)

-- | Data structure describing the configuration of an HTTP server for
--   <a>inumHttpServer</a>.
data HttpServerConf m
HttpServerConf :: !String -> Iter ByteString m () -> !Iter ByteString m (Maybe UTCTime) -> !HttpRequestHandler m () -> HttpServerConf m
srvLogger :: HttpServerConf m -> !String -> Iter ByteString m ()
srvDate :: HttpServerConf m -> !Iter ByteString m (Maybe UTCTime)
srvHandler :: HttpServerConf m -> !HttpRequestHandler m ()

-- | Generate a null <a>HttpServerConf</a> structure with no logging and no
--   Date header.
nullHttpServer :: Monad m => HttpRequestHandler m () -> HttpServerConf m

-- | Generate an <a>HttpServerConf</a> structure that uses IO calls to log
--   to standard error and get the current time for the Date header.
ioHttpServer :: MonadIO m => HttpRequestHandler m () -> HttpServerConf m

-- | An <a>Inum</a> that behaves like an HTTP server. The file
--   <tt>Examples/httptest.hs</tt> that comes with the iterIO distribution
--   gives an example of how to use this function.
inumHttpServer :: Monad m => HttpServerConf m -> Inum ByteString ByteString m ()

-- | Parses an absoluteURI, returning (scheme, host, path, query)
absUri :: Monad m => Iter L m (S, S, Maybe Int, S, S)

-- | Parses a Request-URI, defined by RFC2616, and returns (scheme, host,
--   path, query).
uri :: Monad m => Iter L m (S, S, Maybe Int, S, S)

-- | Turn a path into a list of components. Used to set the
--   <a>reqPathLst</a> field in a request.
path2list :: S -> [S]
instance Typeable1 HttpReq
instance Show s => Show (HttpReq s)
instance Show FormField
instance Show HttpStatus
instance Show (HttpResp m)
instance Eq HttpStatus

module Data.IterIO.HttpClient

-- | Perform a simple HTTP request, given the the request header, body and
--   SSL context, if any.
simpleHttp :: MonadIO m => HttpReq () -> L -> Maybe SSLContext -> m (HttpResp m)

-- | Make a general HTTP request to host specified in the request. If the
--   request is over HTTPS, the SSL context must be provided. The redirect
--   count is used to limit the number of redirects followed (when
--   receiving a 3xx response); use 0 to return the direct response. The
--   <tt>passCookies</tt> flag is used to guard cookies on redirects:
--   because <tt>genSimpleHttp</tt> performs a "single request" it does not
--   parse "Set-Cookie" headers and so is unaware of the cookie domain.
--   Hence, the flag is used for the decision in passing the cookie to the
--   location of a redirect.
genSimpleHttp :: MonadIO m => HttpReq () -> L -> Maybe SSLContext -> Int -> Bool -> m (HttpResp m)

-- | Create a simple HEAD request. The <tt>url</tt> must be an
--   <tt>absoluteURI</tt>.
headRequest :: String -> HttpReq ()

-- | Create a simple GET request. The <tt>url</tt> must be an
--   <tt>absoluteURI</tt>.
getRequest :: String -> HttpReq ()

-- | Given a URL, Content-Type, and message body, perform a simple POST
--   request. Note: message body must be properly encoded (e.g.,
--   URL-encoded if the Content-Type is
--   "application/x-www-form-urlencoded").
postRequest :: String -> String -> L -> HttpReq ()

-- | Perform a simple HTTP GET request. No SSL support.
simpleGetHttp :: MonadIO m => String -> m (HttpResp m)

-- | Perform a simple HTTPS GET request.
simpleGetHttps :: MonadIO m => String -> SSLContext -> m (HttpResp m)

-- | Perform a simple HTTP HEAD request. No SSL support.
simpleHeadHttp :: MonadIO m => String -> m (HttpResp m)

-- | Perform a simple HTTPS HEAD request.
simpleHeadHttps :: MonadIO m => String -> SSLContext -> m (HttpResp m)

-- | An HTTP client.
data HttpClient
HttpClient :: !Socket -> !SockAddr -> !Maybe SSLContext -> !Bool -> HttpClient

-- | Socket
hcSock :: HttpClient -> !Socket

-- | Socket address
hcSockAddr :: HttpClient -> !SockAddr

-- | SSL context
hcSslCtx :: HttpClient -> !Maybe SSLContext

-- | Use SSL
hcIsHttps :: HttpClient -> !Bool

-- | Given the host, port, context, and "is-https" flag, create a client
--   value. The returned value can be used with <a>httpConnect</a> to get
--   raw pipes to/from the server.
--   
--   <i>Note:</i> Some of this code is from the <a>HTTP</a> package.
mkHttpClient :: S -> Int -> Maybe SSLContext -> Bool -> IO HttpClient

-- | Given an HTTP client configuration, make the actual connection to
--   server.
httpConnect :: MonadIO m => HttpClient -> IO (Iter L m (), Onum L m a)

-- | Given an initial request, and a response handler, create an inum that
--   provides underlying functionality of an http client.
inumHttpClient :: MonadIO m => (HttpReq s, L) -> HttpResponseHandler m s -> Inum L L m a

-- | An HTTP response handler used by HTTP clients.
type HttpResponseHandler m s = HttpResp m -> Iter L m (Maybe (HttpReq s, L))

-- | User agent corresponding to this library.
userAgent :: String

-- | Maximum number of redirects. Defult: no redirect (0).
maxNrRedirects :: Int

-- | Createa generic HTTP request, given an absoluteURI: If the URI is not
--   absolute, the parser will fail.
mkRequestToAbsUri :: Monad m => L -> S -> m (HttpReq ())

module Data.IterIO.HttpRoute

-- | Simple HTTP request routing structure for <a>inumHttpServer</a>. This
--   is a wrapper around a function on <a>HttpReq</a> structures. If the
--   function accepts the <a>HttpReq</a>, it returns <a>Just</a> a response
--   action. Otherwise it returns <a>Nothing</a>.
--   
--   <tt>HttpRoute</tt> is a <a>Monoid</a>, and hence can be concatenated
--   with <a>mappend</a> or <a>mconcat</a>. For example, you can say
--   something like:
--   
--   <pre>
--   simpleServer :: Iter L.ByteString IO ()  -- Output to web browser
--                -&gt; Onum L.ByteString IO ()  -- Input from web browser
--                -&gt; IO ()
--   simpleServer iter enum = enum |$ inumHttpServer server .| iter
--       where htdocs = "/var/www/htdocs"
--             server = ioHttpServer $ runHttpRoute routing
--             routing = mconcat [ routeTop $ routeConst $ resp301 "/start.html"
--                               , routeName "apps" $ routeMap apps
--                               , routeFileSys mimeMap "index.html" htdocs
--                               ]
--             apps = [ ("app1", routeFn app1)
--                    , ("app2", routeFn app2) ]
--   
--   app1 :: (Monad m) =&gt; HttpReq -&gt; Iter L.ByteString m (HttpResp m)
--   app1 = ...
--   </pre>
--   
--   The above function will redirect requests for <tt>/</tt> to the URL
--   <tt>/start.html</tt> using an HTTP 301 (Moved Permanently) response.
--   Any request for a path under <tt><i>apps</i></tt> will be redirected
--   to the functions <tt>app1</tt>, <tt>app2</tt>, etc. Finally, any other
--   file name will be served out of the file system under the
--   <tt>"/var/www/htdocs"</tt> directory. (This example assumes
--   <tt>mimeMap</tt> has been constructed as discussed for
--   <a>mimeTypesI</a>.)
newtype HttpRoute m s
HttpRoute :: (HttpReq s -> Maybe (Iter ByteString m (HttpResp m))) -> HttpRoute m s
runHttpRoute :: Monad m => HttpRoute m s -> HttpReq s -> Iter ByteString m (HttpResp m)

-- | Prepend a header field to the response produced by an <a>HttpRoute</a>
--   if that <a>HttpRoute</a> is successful. For example, to let clients
--   cache static data for an hour, you might use:
--   
--   <pre>
--   addHeader (<a>pack</a> "Cache-control", <a>pack</a> "max-age=3600") $
--       <a>routeFileSys</a> mime (<a>dirRedir</a> "index.html") "/var/www/htdocs"
--   </pre>
addHeader :: Monad m => (ByteString, ByteString) -> HttpRoute m s -> HttpRoute m s

-- | Route all requests to a constant response action that does not depend
--   on the request. This route always succeeds, so anything
--   <a>mappend</a>ed will never be used.
routeConst :: Monad m => HttpResp m -> HttpRoute m s

-- | Route all requests to a particular function. This route always
--   succeeds, so anything <a>mappend</a>ed will never be used.
routeFn :: (HttpReq s -> Iter ByteString m (HttpResp m)) -> HttpRoute m s

-- | Select a route based on some arbitrary function of the request. For
--   most purposes, the existing predicates (<a>routeName</a>,
--   <a>routePath</a>, etc.) should be fine, but occationally you might
--   want to define a custom predicate. For example, to reject methods
--   other then "GET" or "POST" at the top of your route, you could say:
--   
--   <pre>
--         myRoute = <a>mconcat</a> [ rejectBadMethod
--                           , otherRoute1
--                           , ...
--                           ]
--         ...
--   
--   rejectBadMethod :: <a>HttpRoute</a> m
--   rejectBadMethod =
--         routeReq $ req -&gt;
--             case <a>reqMethod</a> req of
--               s | s == <a>pack</a> "GET" || s == <a>pack</a> "PUT" -&gt;
--                     <a>mempty</a>                   {- reject route, falling through
--                                                         to rest of myRoute -}
--               _ -&gt; <a>routeConst</a> $ <a>resp405</a> req  {- reject request -}
--   </pre>
routeReq :: (HttpReq s -> HttpRoute m s) -> HttpRoute m s

-- | Route based on the method (GET, POST, HEAD, etc.) in a request.
routeMethod :: String -> HttpRoute m s -> HttpRoute m s

-- | Route requests whose "Host:" header matches a particular string.
routeHost :: String -> HttpRoute m s -> HttpRoute m s

-- | Route the root directory (/).
routeTop :: HttpRoute m s -> HttpRoute m s

-- | Type alias for the argument of <a>routeMap</a>.
type HttpMap m s = [(String, HttpRoute m s)]

-- | <tt>routeMap</tt> builds an efficient map out of a list of
--   <tt>(directory_name, <a>HttpRoute</a>)</tt> pairs. If a name is not in
--   the map, the request is not matched. Note that only the next directory
--   component in the URL is matched.
routeMap :: HttpMap m s -> HttpRoute m s

-- | <tt>routeAlwaysMap</tt> is like <tt>routeMap</tt>, but matches all
--   requests and returns a 404 error for names that do not appear in the
--   map.
routeAlwaysMap :: Monad m => HttpMap m s -> HttpRoute m s

-- | Routes a specific directory name, like <a>routeMap</a> for a singleton
--   map.
routeName :: String -> HttpRoute m s -> HttpRoute m s

-- | Routes a specific path, like <a>routeName</a>, except that the path
--   can include several directories.
routePath :: String -> HttpRoute m s -> HttpRoute m s

-- | Matches any directory name, but additionally pushes it onto the front
--   of the <a>reqPathParams</a> list in the <a>HttpReq</a> structure. This
--   allows the name to serve as a variable argument to the eventual
--   handling function.
routeVar :: HttpRoute m s -> HttpRoute m s

-- | Parses <tt>mime.types</tt> file data. Returns a function mapping file
--   suffixes to mime types. The argument is a default mime type for
--   suffixes that do not match any in the mime.types data. (Reasonable
--   defaults might be <tt>"text/html"</tt>, <tt>"text/plain"</tt>, or,
--   more pedantically but less usefully,
--   <tt>"application/octet-stream"</tt>.)
--   
--   Since this likely doesn't change, it is convenient just to define it
--   once in your program, for instance with something like:
--   
--   <pre>
--   mimeMap :: String -&gt; S8.ByteString
--   mimeMap = unsafePerformIO $ do
--               path &lt;- findMimeTypes ["mime.types"
--                                     , "/etc/mime.types"
--                                     , "/var/www/conf/mime.types"]
--               enumFile path |$ mimeTypesI "application/octet-stream"
--       where
--         findMimeTypes (h:t) = do exist &lt;- fileExist h
--                                  if exist then return h else findMimeTypes t
--         findMimeTypes []    = return "mime.types" -- cause error
--   </pre>
mimeTypesI :: Monad m => String -> Iter ByteString m (String -> ByteString)

-- | <tt>dirRedir indexFileName</tt> redirects requests to the URL formed
--   by appending <tt>"/" ++ indexFileName</tt> to the requested URL.
dirRedir :: Monad m => FilePath -> FilePath -> HttpRoute m s

-- | Route a request to a directory tree in the file system. It gets the
--   Content-Length from the target file's attributes (after opening the
--   file). Thus, overwriting files on an active server could cause
--   problems, while renaming new files into place should be safe.
routeFileSys :: MonadIO m => (String -> ByteString) -> (FilePath -> HttpRoute m s) -> FilePath -> HttpRoute m s

-- | An abstract representation of file system calls returning an opaque
--   handle type <tt>h</tt> in an <a>Iter</a> parameterized by an arbitrary
--   <a>Monad</a> <tt>m</tt>. This representation allows one to use
--   <a>routeGenFileSys</a> in a monad that is not an instance of
--   <a>MonadIO</a>.
data FileSystemCalls h m
FileSystemCalls :: !FilePath -> Iter ByteString m FileStatus -> !FilePath -> Iter ByteString m h -> !h -> Iter ByteString m () -> !h -> Iter ByteString m FileStatus -> !h -> Iter ByteString m (Onum ByteString m (IterR ByteString m ())) -> FileSystemCalls h m

-- | Return file attributes.
fs_stat :: FileSystemCalls h m -> !FilePath -> Iter ByteString m FileStatus

-- | Open file and return an opaque handle of type <tt>h</tt>.
fs_open :: FileSystemCalls h m -> !FilePath -> Iter ByteString m h

-- | Close an open file. You must call this unless you apply the enumerator
--   returned by <tt>fs_enum</tt>.
fs_close :: FileSystemCalls h m -> !h -> Iter ByteString m ()

-- | Return the attributes of an open file.
fs_fstat :: FileSystemCalls h m -> !h -> Iter ByteString m FileStatus

-- | Enumerate the contents of an open file, then close the file. If you
--   apply the <a>Onum</a> returned by <tt>fs_enum</tt>, you do not need to
--   call <tt>fs_close</tt>.
fs_enum :: FileSystemCalls h m -> !h -> Iter ByteString m (Onum ByteString m (IterR ByteString m ()))

-- | A generalized version of <a>routeFileSys</a> that takes a
--   <a>FileSystemCalls</a> object and can therefore work outside of the
--   <a>MonadIO</a> monad. Other than the <a>FileSystemCalls</a> object,
--   the arguments and their meaning are identical to <a>routeFileSys</a>.
routeGenFileSys :: Monad m => FileSystemCalls h m -> (String -> ByteString) -> (FilePath -> HttpRoute m s) -> FilePath -> HttpRoute m s
instance Monoid (HttpRoute m s)
