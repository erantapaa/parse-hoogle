-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A library of queuelike data structures, both functional and stateful.
--   
--   Contains several implementations of data structures implementing a
--   <i>single-in, single-out</i> paradigm. Intended to be a better, more
--   useful replacement for pqueue-mtl. In particular, includes an
--   experimental and possibly genuinely new trie-based priority queue on
--   strings. Feedback is appreciated.
@package queuelike
@version 1.0.9

module Data.MQueue.Class
class Monad m => MQueue q m where { type family MQueueKey q :: *; { pushAll = mapM_ . push pop q = peek q >>= maybe (return Nothing) (\ key -> pop_ q >> return (Just key)) pop_ q = pop q >> return () isEmpty = liftM isNothing . peek } }
newQueue :: MQueue q m => m q
push :: MQueue q m => q -> MQueueKey q -> m ()
pushAll :: MQueue q m => q -> [MQueueKey q] -> m ()
pop :: MQueue q m => q -> m (Maybe (MQueueKey q))
pop_ :: MQueue q m => q -> m ()
peek :: MQueue q m => q -> m (Maybe (MQueueKey q))
isEmpty :: MQueue q m => q -> m Bool


-- | Array-based implementation of an entirely traditional binary heap.
module Data.MQueue.Heap
data Heap s e
getSize :: (Monad m, MonadST m, (StateThread m) ~ s) => Heap s e -> m Int
instance (StateThread m ~ s, Monad m, MonadST m, Ord e) => MQueue (Heap s e) m


-- | Defines a Chan-like structure and makes it an MQueue instance.
module Data.MQueue.Chan
blockingPop :: Chan a -> IO a
instance MonadIO m => MQueue (Chan a) m


-- | Abstracts the implementation details of a single-insertion,
--   single-extraction queuelike structure.
module Data.Queue.Class

-- | Type that only orders on the key, ignoring the value completely;
--   frequently useful in priority queues, so made available here.
data (:->) e f
(:->) :: e -> f -> :-> e f

-- | A generic type class encapsulating a generic queuelike structure, that
--   supports single-insertion and single-extraction; this abstraction
--   includes priority queues, stacks, and FIFO queues. There are many
--   minimal implementations, so each method lists the prerequisites for
--   its default implementation. Most implementations will implement
--   <a>empty</a>, (<a>singleton</a> and <a>merge</a>) or <a>insert</a>,
--   (<tt>peek</tt> and <a>delete</a>) or <a>extract</a>, and <a>size</a>.
--   (The absolute minimal implementation is <a>empty</a>, <a>insert</a>,
--   <a>extract</a>, and <a>size</a>.)
class IQueue q where { type family QueueKey q; { insert x q = q `merge` singleton x insertAll = flip (foldr insert) extract = liftM2 (liftM2 (,)) top delete top = liftM fst . extract delete = liftM snd . extract empty = fromList [] singleton x = insert x empty fromList xs = insertAll xs empty size = length . toList_ null = isNothing . top toList = unfoldr extract toList_ = toList q1 merge q2 = insertAll (toList q2) q1 mergeAll = foldr merge empty } }
insert :: IQueue q => QueueKey q -> q -> q
insertAll :: IQueue q => [QueueKey q] -> q -> q
extract :: IQueue q => q -> Maybe (QueueKey q, q)
top :: IQueue q => q -> Maybe (QueueKey q)
delete :: IQueue q => q -> Maybe q
empty :: IQueue q => q
singleton :: IQueue q => QueueKey q -> q
fromList :: IQueue q => [QueueKey q] -> q
size :: IQueue q => q -> Int
null :: IQueue q => q -> Bool
toList :: IQueue q => q -> [QueueKey q]
toList_ :: IQueue q => q -> [QueueKey q]
merge :: IQueue q => q -> q -> q
mergeAll :: IQueue q => [q] -> q
instance Ord f => Ord (e :-> f)
instance Eq f => Eq (e :-> f)


-- | An efficient implementation of a priority queue.
--   
--   The implementation of <a>PQueue</a> is based on a <i>pairing heap</i>,
--   a simple and efficient implementation of a general-purpose priority
--   queue. <a>PQueue</a> supports <a>insert</a>, <a>merge</a>, and
--   <tt>peek</tt> in constant time, and <a>extract</a> and <a>delete</a>
--   in logarithmic time.
module Data.Queue.PQueue
data PQueue e
drawQueue :: Show e => PQueue e -> String
instance Ord e => Monoid (PQueue e)
instance Ord e => IQueue (PQueue e)
instance Ord e => Semigroup (Tree e)
instance Show e => Show (PQueue e)


-- | A basic implementation of a stack implementing the <tt>Queue</tt>
--   abstraction.
module Data.Queue.Stack
data Stack e
instance IQueue (Stack e)


-- | A basic first-in, first-out queue implementation implementing the
--   <tt>Queuelike</tt> abstraction. Bootstrapped from
--   <a>Data.Sequence</a>.
module Data.Queue.Queue
data Queue e
cons :: e -> Queue e -> Queue e
instance IQueue (Queue e)
instance Functor Queue


-- | <tt>TrieQueue e</tt> is a priority queue <tt>IQueue</tt> instance
--   satisfying <tt>QueueKey (TrieQueue e) ~ [e]</tt>, with the property
--   that this queue frequently performs better than any other queue
--   implementation in this package for keys of type <tt>[e]</tt>.
--   
--   This particular implementation is highly experimental and possibly a
--   genuinely new data structure. See the source code for details.
--   However, for many cases this priority queue may be used for a heap
--   sort that runs faster than the <a>Data.List</a> implementation, or the
--   vanilla <a>Data.Queue.PQueue</a> implementation.
module Data.Queue.TrieQueue
data TrieQueue e
instance Ord e => Monoid (TrieQueue e)
instance Show e => Show (TrieQueue e)
instance Show e => Show (Trie e)
instance Ord e => IQueue (TrieQueue e)
instance Ord e => Semigroup (Trie e)


-- | In the IO monad, provides thread-safe <a>MVar</a>-based wrappers for
--   <tt>Queuelike</tt> and <a>MQueue</a> instances.
module Data.MQueue.SyncQueue
data SyncQ q
data SyncMQ q
instance (MonadIO m, MQueue q IO) => MQueue (SyncMQ q) m
instance (MonadIO m, IQueue q) => MQueue (SyncQ q) m

module Data.MQueue

module Data.Queue.Instances

module Data.Queue
