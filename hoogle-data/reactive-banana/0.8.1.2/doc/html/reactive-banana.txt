-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Library for functional reactive programming (FRP).
--   
@package reactive-banana
@version 0.8.1.2

module Reactive.Banana.Prim.Cached

-- | Type class for monads that have a lazy <tt>Vault</tt> that can be used
--   as a cache.
--   
--   The cache has to be lazy in the values in order to be useful for
--   recursion.
class (Monad m, MonadFix m) => HasCache m
retrieve :: HasCache m => Key a -> m (Maybe a)
write :: HasCache m => Key a -> a -> m ()
data Cached m a
runCached :: Cached m a -> m a

-- | An action whose result will be cached. Executing the action the first
--   time in the monad will execute the side effects. From then on, only
--   the generated value will be returned.
cache :: HasCache m => m a -> Cached m a

-- | Return a pure value. Doesn't make use of the cache.
fromPure :: HasCache m => a -> Cached m a

-- | Lift an action that is <i>not</i> chached, for instance because it is
--   idempotent.
don'tCache :: HasCache m => m a -> Cached m a
liftCached1 :: HasCache m => (a -> m b) -> Cached m a -> Cached m b
liftCached2 :: HasCache m => (a -> b -> m c) -> Cached m a -> Cached m b -> Cached m c

module Reactive.Banana.Prim
type Step = EvalNetwork (IO ())

-- | A <a>Network</a> represents the state of a pulse/latch network, which
--   consists of a <a>Graph</a> and the values of all accumulated latches
--   in the network.
data Network

-- | The <a>Network</a> that contains no pulses or latches.
emptyNetwork :: Network
type Build = BuildT Identity
liftIOLater :: IO () -> Build ()
type BuildIO = BuildT IO
type BuildT = RWST () BuildConf Network
liftBuild :: Monad m => Build a -> BuildT m a

-- | Change a <a>Network</a> of pulses and latches by executing a
--   <a>BuildIO</a> action.
compile :: BuildIO a -> Network -> IO (a, Network)

-- | Simple interpreter for pulse/latch networks.
--   
--   Mainly useful for testing functionality
--   
--   Note: The result is not computed lazily, for similar reasons that the
--   <a>sequence</a> function does not compute its result lazily.
interpret :: (Pulse a -> BuildIO (Pulse b)) -> [Maybe a] -> IO [Maybe b]

-- | <tt>mapAccum</tt> for a monad.
mapAccumM :: Monad m => (a -> s -> m (b, s)) -> s -> [a] -> m [b]

-- | Strict <tt>mapAccum</tt> for a monad. Discards results.
mapAccumM_ :: Monad m => (a -> s -> m (b, s)) -> s -> [a] -> m ()

-- | Execute an FRP network with a sequence of inputs, but discard results.
--   
--   Mainly useful for testing whether there are space leaks.
runSpaceProfile :: (Pulse a -> BuildIO void) -> [a] -> IO ()

-- | Create a new pulse in the network and a function to trigger it.
--   
--   Together with <a>addHandler</a>, this function can be used to operate
--   with pulses as with standard callback-based events.
newInput :: Key a -> Build (Pulse a, a -> Step)

-- | Register a handler to be executed whenever a pulse occurs.
--   
--   The pulse may refer to future latch values.
addHandler :: Pulse (Future a) -> (a -> IO ()) -> Build ()

-- | Read the value of a <a>Latch</a> at a particular moment in time.
readLatch :: Latch a -> Build a
data Pulse a

-- | <a>Pulse</a> that never fires.
neverP :: Build (Pulse a)
alwaysP :: Build (Pulse ())
mapP :: (a -> b) -> Pulse a -> Build (Pulse b)
type Future = Dated

-- | Tag a <a>Pulse</a> with future values of a <a>Latch</a>.
--   
--   This is in contrast to <a>applyP</a> which applies the current value
--   of a <a>Latch</a> to a pulse.
tagFuture :: Latch a -> Pulse b -> Build (Pulse (Future a))
unsafeMapIOP :: (a -> IO b) -> Pulse a -> Build (Pulse b)
filterJustP :: Pulse (Maybe a) -> Build (Pulse a)
unionWithP :: (a -> a -> a) -> Pulse a -> Pulse a -> Build (Pulse a)
data Latch a
pureL :: a -> Latch a
mapL :: (a -> b) -> Latch a -> Latch b
applyL :: Latch (a -> b) -> Latch a -> Latch b
accumL :: a -> Pulse (a -> a) -> Build (Latch a, Pulse a)
applyP :: Latch (a -> b) -> Pulse a -> Build (Pulse b)
switchL :: Latch a -> Pulse (Latch a) -> Build (Latch a)
executeP :: Pulse (b -> BuildIO a) -> b -> Build (Pulse a)
switchP :: Pulse (Pulse a) -> Build (Pulse a)

module Reactive.Banana.Model
type Event a = [Maybe a]
data Behavior a
never :: Event a
filterJust :: Event (Maybe a) -> Event a
unionWith :: (a -> a -> a) -> Event a -> Event a -> Event a
mapE :: (a -> b) -> Event a -> Event b
accumE :: a -> Event (a -> a) -> Event a
applyE :: Behavior (a -> b) -> Event a -> Event b
stepperB :: a -> Event a -> Behavior a
pureB :: a -> Behavior a
applyB :: Behavior (a -> b) -> Behavior a -> Behavior b
mapB :: (a -> b) -> Behavior a -> Behavior b
type Moment a = Time -> a
initialB :: Behavior a -> Moment a
trimE :: Event a -> Moment (Moment (Event a))
trimB :: Behavior a -> Moment (Moment (Behavior a))
observeE :: Event (Moment a) -> Event a
switchE :: Event (Moment (Event a)) -> Event a
switchB :: Behavior a -> Event (Moment (Behavior a)) -> Behavior a
interpret :: (Event a -> Moment (Event b)) -> [Maybe a] -> [Maybe b]

module Control.Event.Handler

-- | An <i>event handler</i> is a function that takes an <i>event value</i>
--   and performs some computation.
type Handler a = a -> IO ()

-- | A value of type <tt>Addhandler a</tt> is a facility for registering
--   event handlers. These will be called whenever the event occurs.
--   
--   When registering an event handler, you will also be given an action
--   that unregisters this handler again.
--   
--   <pre>
--   do unregisterMyHandler &lt;- register addHandler myHandler
--   </pre>
newtype AddHandler a
AddHandler :: (Handler a -> IO (IO ())) -> AddHandler a
register :: AddHandler a -> Handler a -> IO (IO ())

-- | Build a facility to register and unregister event handlers. Also
--   yields a function that takes an event handler and runs all the
--   registered handlers.
--   
--   Example:
--   
--   <pre>
--   do
--       (addHandler, fire) &lt;- newAddHandler
--       register addHandler putStrLn
--       fire "Hello!"
--   </pre>
newAddHandler :: IO (AddHandler a, Handler a)

-- | Map the event value with an <a>IO</a> action.
mapIO :: (a -> IO b) -> AddHandler a -> AddHandler b

-- | Filter event values that don't return <a>True</a>.
filterIO :: (a -> IO Bool) -> AddHandler a -> AddHandler a
instance Functor AddHandler

module Reactive.Banana.Combinators

-- | <tt>Event t a</tt> represents a stream of events as they occur in
--   time. Semantically, you can think of <tt>Event t a</tt> as an infinite
--   list of values that are tagged with their corresponding time of
--   occurence,
--   
--   <pre>
--   type Event t a = [(Time,a)]
--   </pre>
data Event t a

-- | <tt>Behavior t a</tt> represents a value that varies in time. Think of
--   it as
--   
--   <pre>
--   type Behavior t a = Time -&gt; a
--   </pre>
data Behavior t a

-- | Interpret an event processing function. Useful for testing.
interpret :: (forall t. Event t a -> Event t b) -> [[a]] -> IO [[b]]

-- | Event that never occurs. Think of it as <tt>never = []</tt>.
never :: Event t a

-- | Merge two event streams of the same type. In case of simultaneous
--   occurrences, the left argument comes first. Think of it as
--   
--   <pre>
--   union ((timex,x):xs) ((timey,y):ys)
--      | timex &lt;= timey = (timex,x) : union xs ((timey,y):ys)
--      | timex &gt;  timey = (timey,y) : union ((timex,x):xs) ys
--   </pre>
union :: Event t a -> Event t a -> Event t a

-- | Merge several event streams of the same type.
--   
--   <pre>
--   unions = foldr union never
--   </pre>
unions :: [Event t a] -> Event t a

-- | Allow all events that fulfill the predicate, discard the rest. Think
--   of it as
--   
--   <pre>
--   filterE p es = [(time,a) | (time,a) &lt;- es, p a]
--   </pre>
filterE :: (a -> Bool) -> Event t a -> Event t a

-- | Collect simultaneous event occurences. The result will never contain
--   an empty list. Example:
--   
--   <pre>
--   collect [(time1, e1), (time1, e2)] = [(time1, [e1,e2])]
--   </pre>
collect :: Event t a -> Event t [a]

-- | Emit simultaneous event occurrences. The first element in the list
--   will be emitted first, and so on.
--   
--   Up to strictness, we have
--   
--   <pre>
--   spill . collect = id
--   </pre>
spill :: Event t [a] -> Event t a

-- | The <a>accumE</a> function accumulates a stream of events. Example:
--   
--   <pre>
--   accumE "x" [(time1,(++"y")),(time2,(++"z"))]
--      = [(time1,"xy"),(time2,"xyz")]
--   </pre>
--   
--   Note that the output events are simultaneous with the input events,
--   there is no "delay" like in the case of <a>accumB</a>.
accumE :: a -> Event t (a -> a) -> Event t a

-- | Apply a time-varying function to a stream of events. Think of it as
--   
--   <pre>
--   apply bf ex = [(time, bf time x) | (time, x) &lt;- ex]
--   </pre>
--   
--   This function is generally used in its infix variant <a>&lt;@&gt;</a>.
apply :: Behavior t (a -> b) -> Event t a -> Event t b

-- | Construct a time-varying function from an initial value and a stream
--   of new values. Think of it as
--   
--   <pre>
--   stepper x0 ex = \time -&gt; last (x0 : [x | (timex,x) &lt;- ex, timex &lt; time])
--   </pre>
--   
--   Note that the smaller-than-sign in the comparision <tt>timex &lt;
--   time</tt> means that the value of the behavior changes "slightly
--   after" the event occurrences. This allows for recursive definitions.
--   
--   Also note that in the case of simultaneous occurrences, only the last
--   one is kept.
stepper :: a -> Event t a -> Behavior t a

-- | Infix synonym for the <a>apply</a> combinator. Similar to
--   <a>&lt;*&gt;</a>.
--   
--   <pre>
--   infixl 4 &lt;@&gt;
--   </pre>
(<@>) :: Behavior t (a -> b) -> Event t a -> Event t b

-- | Tag all event occurrences with a time-varying value. Similar to
--   <a>&lt;*</a>.
--   
--   <pre>
--   infixl 4 &lt;@
--   </pre>
(<@) :: Behavior t b -> Event t a -> Event t b

-- | Allow all event occurrences that are <a>Just</a> values, discard the
--   rest. Variant of <a>filterE</a>.
filterJust :: Event t (Maybe a) -> Event t a

-- | Allow all events that fulfill the time-varying predicate, discard the
--   rest. Generalization of <a>filterE</a>.
filterApply :: Behavior t (a -> Bool) -> Event t a -> Event t a

-- | Allow events only when the behavior is <a>True</a>. Variant of
--   <a>filterApply</a>.
whenE :: Behavior t Bool -> Event t a -> Event t a

-- | Split event occurrences according to a tag. The <a>Left</a> values go
--   into the left component while the <a>Right</a> values go into the
--   right component of the result.
split :: Event t (Either a b) -> (Event t a, Event t b)

-- | The <a>accumB</a> function is similar to a <i>strict</i> left fold,
--   <tt>foldl'</tt>. It starts with an initial value and combines it with
--   incoming events. For example, think
--   
--   <pre>
--   accumB "x" [(time1,(++"y")),(time2,(++"z"))]
--      = stepper "x" [(time1,"xy"),(time2,"xyz")]
--   </pre>
--   
--   Note that the value of the behavior changes "slightly after" the
--   events occur. This allows for recursive definitions.
accumB :: a -> Event t (a -> a) -> Behavior t a

-- | Efficient combination of <a>accumE</a> and <a>accumB</a>.
mapAccum :: acc -> Event t (acc -> (x, acc)) -> (Event t x, Behavior t acc)

-- | Keep only the last occurrence when simultaneous occurrences happen.
calm :: Event t a -> Event t a

-- | Combine simultaneous event occurrences into a single occurrence.
--   
--   <pre>
--   unionWith f e1 e2 = fmap (foldr1 f) &lt;$&gt; collect (e1 `union` e2)
--   </pre>
unionWith :: (a -> a -> a) -> Event t a -> Event t a -> Event t a
instance Functor (Behavior t)
instance Applicative (Behavior t)
instance Functor (Event t)

module Reactive.Banana.Experimental.Calm
data Event t a
type Behavior t = Behavior t

-- | Convert event with possible simultaneous occurrences into an
--   <a>Event</a> with a single occurrence.
collect :: Event t a -> Event t [a]

-- | Convert event with single occurrences into event with possible
--   simultaneous occurrences
fromCalm :: Event t a -> Event t a

-- | Interpretation function. Useful for testing.
interpret :: (forall t. Event t a -> Event t b) -> [a] -> IO [Maybe b]

-- | Event that never occurs. Think of it as <tt>never = []</tt>.
never :: Event t a

-- | Merge two event streams of the same type. Combine simultaneous values
--   if necessary.
unionWith :: (a -> a -> a) -> Event t a -> Event t a -> Event t a

-- | Allow all events that fulfill the predicate, discard the rest.
filterE :: (a -> Bool) -> Event t a -> Event t a

-- | The <a>accumE</a> function accumulates a stream of events.
accumE :: a -> Event t (a -> a) -> Event t a

-- | Apply a time-varying function to a stream of events.
apply :: Behavior t (a -> b) -> Event t a -> Event t b

-- | Construct a time-varying function from an initial value and a stream
--   of new values.
stepper :: a -> Event t a -> Behavior t a

-- | Keep only the <a>Just</a> values. Variant of <a>filterE</a>.
filterJust :: Event t (Maybe a) -> Event t a

-- | The <a>accumB</a> function is similar to a <i>strict</i> left fold,
--   <tt>foldl'</tt>. It starts with an initial value and combines it with
--   incoming events.
accumB :: a -> Event t (a -> a) -> Behavior t a

-- | Efficient combination of <a>accumE</a> and <a>accumB</a>.
mapAccum :: acc -> Event t (acc -> (x, acc)) -> (Event t x, Behavior t acc)

-- | Infix synonym for the <a>apply</a> combinator. Similar to
--   <a>&lt;*&gt;</a>.
(<@>) :: Behavior t (a -> b) -> Event t a -> Event t b

-- | Tag all event occurrences with a time-varying value. Similar to
--   <a>&lt;*</a>.
(<@) :: Behavior t a -> Event t b -> Event t a
instance Functor (Event t)

module Reactive.Banana.Switch

-- | The <a>Moment</a> monad denotes a value at a particular <i>moment in
--   time</i>.
--   
--   This monad is not very interesting, it is mainly used for
--   book-keeping. In particular, the type parameter <tt>t</tt> is used to
--   disallow various unhealthy programs.
--   
--   This monad is also used to describe event networks in the
--   <a>Reactive.Banana.Frameworks</a> module. This only happens when the
--   type parameter <tt>t</tt> is constrained by the <a>Frameworks</a>
--   class.
--   
--   To be precise, an expression of type <tt>Moment t a</tt> denotes a
--   value of type <tt>a</tt> that is observed at a moment in time which is
--   indicated by the type parameter <tt>t</tt>.
data Moment t a

-- | Value present at any/every moment in time.
data AnyMoment f a
anyMoment :: (forall t. Moment t (f t a)) -> AnyMoment f a
now :: AnyMoment f a -> forall t. Moment t (f t a)

-- | Trim an <a>Event</a> to a variable start time.
trimE :: Event t a -> Moment t (AnyMoment Event a)

-- | Trim a <a>Behavior</a> to a variable start time.
trimB :: Behavior t a -> Moment t (AnyMoment Behavior a)

-- | Dynamically switch between <a>Event</a>.
switchE :: Event t (AnyMoment Event a) -> Event t a

-- | Dynamically switch between <a>Behavior</a>.
switchB :: Behavior t a -> Event t (AnyMoment Behavior a) -> Behavior t a

-- | Observe a value at those moments in time where event occurrences
--   happen.
observeE :: Event t (AnyMoment Identity a) -> Event t a

-- | Obtain the value of the <a>Behavior</a> at moment <tt>t</tt>.
valueB :: Behavior t a -> Moment t a

-- | Identity functor with a dummy argument. Unlike <a>Constant</a>, this
--   functor is constant in the <i>second</i> argument.
newtype Identity t a
Identity :: a -> Identity t a
getIdentity :: Identity t a -> a
instance Functor (AnyMoment Event)
instance Applicative (AnyMoment Behavior)
instance Functor (AnyMoment Behavior)
instance Monad (AnyMoment Identity)
instance Applicative (AnyMoment Identity)
instance Functor (AnyMoment Identity)
instance Functor (Identity t)

module Reactive.Banana.Frameworks

-- | Simple way to write a single event handler with functional reactive
--   programming.
interpretAsHandler :: (forall t. Event t a -> Event t b) -> AddHandler a -> AddHandler b

-- | Compile the description of an event network into an
--   <a>EventNetwork</a> that you can <a>actuate</a>, <a>pause</a> and so
--   on.
--   
--   Event networks are described in the <a>Moment</a> monad and use the
--   <a>Frameworks</a> class constraint.
compile :: (forall t. Frameworks t => Moment t ()) -> IO EventNetwork

-- | Class constraint on the type parameter <tt>t</tt> of the
--   <tt>Moment</tt> monad.
--   
--   Indicates that we can add input and output to an event network.
class Frameworks t

-- | Input, obtain an <a>Event</a> from an <a>AddHandler</a>.
--   
--   When the event network is actuated, this will register a callback
--   function such that an event will occur whenever the callback function
--   is called.
fromAddHandler :: Frameworks t => AddHandler a -> Moment t (Event t a)

-- | Input, obtain a <a>Behavior</a> from an <a>AddHandler</a> that
--   notifies changes.
--   
--   This is essentially just an application of the <a>stepper</a>
--   combinator.
fromChanges :: Frameworks t => a -> AddHandler a -> Moment t (Behavior t a)

-- | Input, obtain a <a>Behavior</a> by frequently polling mutable data,
--   like the current time.
--   
--   The resulting <a>Behavior</a> will be updated on whenever the event
--   network processes an input event.
--   
--   This function is occasionally useful, but the recommended way to
--   obtain <tt>Behaviors</tt> is by using <a>fromChanges</a>.
--   
--   Ideally, the argument IO action just polls a mutable variable, it
--   should not perform expensive computations. Neither should its side
--   effects affect the event network significantly.
fromPoll :: Frameworks t => IO a -> Moment t (Behavior t a)

-- | Output. Execute the <a>IO</a> action whenever the event occurs.
--   
--   Note: If two events occur very close to each other, there is no
--   guarantee that the <tt>reactimate</tt>s for one event will have
--   finished before the ones for the next event start executing. This does
--   <i>not</i> affect the values of events and behaviors, it only means
--   that the <tt>reactimate</tt> for different events may interleave.
--   Fortuantely, this is a very rare occurrence, and only happens if
--   
--   <ul>
--   <li>you call an event handler from inside <a>reactimate</a>,</li>
--   <li>or you use concurrency.</li>
--   </ul>
--   
--   In these cases, the <tt>reactimate</tt>s follow the control flow of
--   your event-based framework.
--   
--   Note: An event network essentially behaves like a single, huge
--   callback function. The <a>IO</a> action are not run in a separate
--   thread. The callback function will throw an exception if one of your
--   <a>IO</a> actions does so as well. Your event-based framework will
--   have to handle this situation.
reactimate :: Frameworks t => Event t (IO ()) -> Moment t ()

-- | The <a>Future</a> monad is just a helper type for the <tt>changes</tt>
--   function.
--   
--   A value of type <tt>Future a</tt> is only available in the context of
--   a <tt>reactimate</tt> but not during event processing.
data Future a

-- | Output. Execute the <a>IO</a> action whenever the event occurs.
--   
--   This version of <a>reactimate</a> can deal with values obtained from
--   the <a>changes</a> function.
reactimate' :: Frameworks t => Event t (Future (IO ())) -> Moment t ()

-- | Output, observe the initial value contained in a <a>Behavior</a>.
initial :: Behavior t a -> Moment t a

-- | Output, observe when a <a>Behavior</a> changes.
--   
--   Strictly speaking, a <a>Behavior</a> denotes a value that varies
--   <i>continuously</i> in time, so there is no well-defined event which
--   indicates when the behavior changes.
--   
--   Still, for reasons of efficiency, the library provides a way to
--   observe changes when the behavior is a step function, for instance as
--   created by <a>stepper</a>. There are no formal guarantees, but the
--   idea is that
--   
--   <pre>
--   changes (stepper x e) = return (calm e)
--   </pre>
--   
--   Note: The values of the event will not become available until event
--   processing is complete. It can be used only in the context of
--   <a>reactimate'</a>.
changes :: Frameworks t => Behavior t a -> Moment t (Event t (Future a))

-- | Impose a different sampling event on a <a>Behavior</a>.
--   
--   The <a>Behavior</a> will vary continuously as before, but the event
--   returned by the <a>changes</a> function will now happen simultaneously
--   with the imposed event.
--   
--   Note: This function is useful only in very specific circumstances.
imposeChanges :: Frameworks t => Behavior t a -> Event t () -> Behavior t a

-- | Dummy type needed to simulate impredicative polymorphism.
newtype FrameworksMoment a
FrameworksMoment :: (forall t. Frameworks t => Moment t a) -> FrameworksMoment a
runFrameworksMoment :: FrameworksMoment a -> forall t. Frameworks t => Moment t a

-- | Dynamically add input and output to an existing event network.
--   
--   Note: You can even do <a>IO</a> actions here, but there is no
--   guarantee about the order in which they are executed.
execute :: Frameworks t => Event t (FrameworksMoment a) -> Moment t (Event t a)

-- | Lift an <a>IO</a> action into the <a>Moment</a> monad, but defer its
--   execution until compilation time. This can be useful for recursive
--   definitions using <tt>MonadFix</tt>.
liftIOLater :: Frameworks t => IO () -> Moment t ()

-- | Data type that represents a compiled event network. It may be paused
--   or already running.
data EventNetwork

-- | Actuate an event network. The inputs will register their event
--   handlers, so that the networks starts to produce outputs in response
--   to input events.
actuate :: EventNetwork -> IO ()

-- | Pause an event network. Immediately stop producing output. (In a
--   future version, it will also unregister all event handlers for
--   inputs.) Hence, the network stops responding to input events, but it's
--   state will be preserved.
--   
--   You can resume the network with <a>actuate</a>.
--   
--   Note: You can stop a network even while it is processing events, i.e.
--   you can use <a>pause</a> as an argument to <a>reactimate</a>. The
--   network will <i>not</i> stop immediately though, only after the
--   current event has been processed completely.
pause :: EventNetwork -> IO ()

-- | Build an <a>Event</a> together with an <a>IO</a> action that can fire
--   occurrences of this event. Variant of <a>newAddHandler</a>.
--   
--   This function is mainly useful for passing callback functions inside a
--   <a>reactimate</a>.
newEvent :: Frameworks t => Moment t (Event t a, Handler a)

-- | Interpret by using a framework internally. Only useful for testing
--   library internals.
interpretFrameworks :: (forall t. Event t a -> Event t b) -> [a] -> IO [[b]]

-- | A multiline description of the current <tt>Latch</tt>es and
--   <tt>Pulse</tt>s in the <a>EventNetwork</a>.
--   
--   Incidentally, evaluation the returned string to normal form will also
--   force the <a>EventNetwork</a> to some kind of normal form. This may be
--   useful for benchmarking purposes.
showNetwork :: EventNetwork -> IO String

module Reactive.Banana

-- | Compile the description of an event network into an
--   <a>EventNetwork</a> that you can <a>actuate</a>, <a>pause</a> and so
--   on.
--   
--   Event networks are described in the <a>Moment</a> monad and use the
--   <a>Frameworks</a> class constraint.
compile :: (forall t. Frameworks t => Moment t ()) -> IO EventNetwork
