-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Representable functors
--   
--   Representable functors
@package representable-functors
@version 3.1


-- | Representable endofunctors over the category of Haskell types are
--   isomorphic to the reader monad and so inherit a very large number of
--   properties for free.
module Data.Functor.Representable

-- | A <a>Functor</a> <tt>f</tt> is <a>Representable</a> if <a>tabulate</a>
--   and <a>index</a> witness an isomorphism to <tt>(-&gt;) x</tt>.
--   
--   <pre>
--   tabulate . index = id
--   index . tabulate = id
--   tabulate . return f = return f
--   </pre>
class (Distributive f, Indexable f) => Representable f
tabulate :: Representable f => (Key f -> a) -> f a
newtype Rep f a
Rep :: f a -> Rep f a
unrep :: Rep f a -> f a
fmapRep :: Representable f => (a -> b) -> f a -> f b
distributeRep :: (Representable f, Functor w) => w (f a) -> f (w a)
mapWithKeyRep :: Representable f => (Key f -> a -> b) -> f a -> f b
apRep :: Representable f => f (a -> b) -> f a -> f b
pureRep :: Representable f => a -> f a
liftR2 :: Representable f => (a -> b -> c) -> f a -> f b -> f c
liftR3 :: Representable f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
bindRep :: Representable f => f a -> (a -> f b) -> f b
bindWithKeyRep :: Representable f => f a -> (Key f -> a -> f b) -> f b
zipWithRep :: Representable f => (a -> b -> c) -> f a -> f b -> f c
zipWithKeyRep :: Representable f => (Key f -> a -> b -> c) -> f a -> f b -> f c
askRep :: Representable f => f (Key f)
localRep :: Representable f => (Key f -> Key f) -> f a -> f a
duplicatedRep :: (Representable f, Semigroup (Key f)) => f a -> f (f a)
extendedRep :: (Representable f, Semigroup (Key f)) => (f a -> b) -> f a -> f b
duplicateRep :: (Representable f, Monoid (Key f)) => f a -> f (f a)
extendRep :: (Representable f, Monoid (Key f)) => (f a -> b) -> f a -> f b
extractRep :: (Indexable f, Monoid (Key f)) => f a -> a
instance ComonadTrans Rep
instance (Representable f, Monoid (Key f)) => Comonad (Rep f)
instance (Representable f, Semigroup (Key f)) => Extend (Rep f)
instance Representable f => ZipWithKey (Rep f)
instance Representable f => Zip (Rep f)
instance (Representable f, Key f ~ a) => MonadReader a (Rep f)
instance Representable f => Monad (Rep f)
instance Representable f => Bind (Rep f)
instance Representable f => Distributive (Rep f)
instance Representable f => Applicative (Rep f)
instance Representable f => Apply (Rep f)
instance Representable f => Functor (Rep f)
instance Indexable f => Lookup (Rep f)
instance Representable f => Keyed (Rep f)
instance Indexable f => Indexable (Rep f)
instance Representable f => Representable (Rep f)
instance Representable f => Representable (Cofree f)
instance (Representable f, Representable g) => Representable (Product f g)
instance Representable w => Representable (TracedT s w)
instance (Representable f, Representable g) => Representable (Compose f g)
instance Representable m => Representable (ReaderT e m)
instance Representable ((->) e)
instance Representable m => Representable (IdentityT m)
instance Representable Identity


-- | Representable functors on Hask all monads, being isomorphic to a
--   reader monad.
module Control.Monad.Representable.Reader
type Reader f = ReaderT f Identity
runReader :: Indexable f => Reader f b -> Key f -> b
newtype ReaderT f m b
ReaderT :: f (m b) -> ReaderT f m b
getReaderT :: ReaderT f m b -> f (m b)
readerT :: Representable f => (Key f -> m b) -> ReaderT f m b
runReaderT :: Indexable f => ReaderT f m b -> Key f -> m b

-- | Retrieves the monad environment.
ask :: MonadReader r m => m r

-- | Executes a computation in a modified environment.
local :: MonadReader r m => forall a. (r -> r) -> m a -> m a
instance (Representable f, TraversableWithKey1 f, TraversableWithKey1 m) => TraversableWithKey1 (ReaderT f m)
instance (Representable f, TraversableWithKey f, TraversableWithKey m) => TraversableWithKey (ReaderT f m)
instance (Traversable1 f, Traversable1 m) => Traversable1 (ReaderT f m)
instance (Traversable f, Traversable m) => Traversable (ReaderT f m)
instance (FoldableWithKey1 f, FoldableWithKey1 m) => FoldableWithKey1 (ReaderT f m)
instance (FoldableWithKey f, FoldableWithKey m) => FoldableWithKey (ReaderT f m)
instance (Foldable1 f, Foldable1 m) => Foldable1 (ReaderT f m)
instance (Foldable f, Foldable m) => Foldable (ReaderT f m)
instance (Adjustable f, Adjustable m) => Adjustable (ReaderT f m)
instance (Representable f, MonadWriter w m) => MonadWriter w (ReaderT f m)
instance (Representable f, MonadIO m) => MonadIO (ReaderT f m)
instance (Representable f, Representable m, Monoid (Key f), Monoid (Key m)) => Comonad (ReaderT f m)
instance (Representable f, ZipWithKey m) => ZipWithKey (ReaderT f m)
instance (Representable f, Zip m) => Zip (ReaderT f m)
instance (Representable f, Representable m, Semigroup (Key f), Semigroup (Key m)) => Extend (ReaderT f m)
instance (Indexable f, Lookup m) => Lookup (ReaderT f m)
instance (Representable f, Keyed m) => Keyed (ReaderT f m)
instance (Representable f, Distributive m) => Distributive (ReaderT f m)
instance Representable f => MonadTrans (ReaderT f)
instance (Representable f, Monad m) => Monad (ReaderT f m)
instance (Representable f, Bind m) => Bind (ReaderT f m)
instance (Representable f, Applicative m) => Applicative (ReaderT f m)
instance (Representable f, Apply m) => Apply (ReaderT f m)
instance (Representable f, Representable m) => Representable (ReaderT f m)
instance (Indexable f, Indexable m) => Indexable (ReaderT f m)
instance (Functor f, Functor m) => Functor (ReaderT f m)


-- | A generalized State monad, parameterized by a Representable functor.
--   The representation of that functor serves as the state.
module Control.Monad.Representable.State

-- | A memoized state monad parameterized by a representable functor
--   <tt>g</tt>, where the representatation of <tt>g</tt>, <tt>Key g</tt>
--   is the state to carry.
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
type State g = StateT g Identity

-- | Unwrap a state monad computation as a function. (The inverse of
--   <a>state</a>.)
runState :: Indexable g => State g a -> Key g -> (a, Key g)

-- | Evaluate a state computation with the given initial state and return
--   the final value, discarding the final state.
--   
--   <ul>
--   <li><pre><a>evalState</a> m s = <a>fst</a> (<a>runState</a> m
--   s)</pre></li>
--   </ul>
evalState :: Indexable g => State g a -> Key g -> a

-- | Evaluate a state computation with the given initial state and return
--   the final state, discarding the final value.
--   
--   <ul>
--   <li><pre><a>execState</a> m s = <a>snd</a> (<a>runState</a> m
--   s)</pre></li>
--   </ul>
execState :: Indexable g => State g a -> Key g -> Key g

-- | Map both the return value and final state of a computation using the
--   given function.
--   
--   <ul>
--   <li><pre><a>runState</a> (<a>mapState</a> f m) = f . <a>runState</a>
--   m</pre></li>
--   </ul>
mapState :: Functor g => ((a, Key g) -> (b, Key g)) -> State g a -> State g b

-- | A state transformer monad parameterized by:
--   
--   <ul>
--   <li><tt>g</tt> - A representable functor used to memoize results for a
--   state <tt>Key g</tt></li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
newtype StateT g m a
StateT :: g (m (a, Key g)) -> StateT g m a
getStateT :: StateT g m a -> g (m (a, Key g))
stateT :: Representable g => (Key g -> m (a, Key g)) -> StateT g m a
runStateT :: Indexable g => StateT g m a -> Key g -> m (a, Key g)

-- | Evaluate a state computation with the given initial state and return
--   the final value, discarding the final state.
--   
--   <ul>
--   <li><pre><a>evalStateT</a> m s = <a>liftM</a> <a>fst</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
evalStateT :: (Indexable g, Monad m) => StateT g m a -> Key g -> m a

-- | Evaluate a state computation with the given initial state and return
--   the final state, discarding the final value.
--   
--   <ul>
--   <li><pre><a>execStateT</a> m s = <a>liftM</a> <a>snd</a>
--   (<a>runStateT</a> m s)</pre></li>
--   </ul>
execStateT :: (Indexable g, Monad m) => StateT g m a -> Key g -> m (Key g)
mapStateT :: Functor g => (m (a, Key g) -> n (b, Key g)) -> StateT g m a -> StateT g n b

-- | Uniform lifting of a <tt>callCC</tt> operation to the new monad. This
--   version rolls back to the original state on entering the continuation.
liftCallCC :: Representable g => ((((a, Key g) -> m (b, Key g)) -> m (a, Key g)) -> m (a, Key g)) -> ((a -> StateT g m b) -> StateT g m a) -> StateT g m a

-- | In-situ lifting of a <tt>callCC</tt> operation to the new monad. This
--   version uses the current state on entering the continuation. It does
--   not satisfy the laws of a monad transformer.
liftCallCC' :: Representable g => ((((a, Key g) -> m (b, Key g)) -> m (a, Key g)) -> m (a, Key g)) -> ((a -> StateT g m b) -> StateT g m a) -> StateT g m a

-- | Return the state from the internals of the monad.
get :: MonadState s m => m s

-- | Gets specific component of the state, using a projection function
--   supplied.
gets :: MonadState s m => (s -> a) -> m a

-- | Replace the state inside the monad.
put :: MonadState s m => s -> m ()

-- | Monadic state transformer.
--   
--   Maps an old state to a new state inside a state monad. The old state
--   is thrown away.
--   
--   <pre>
--   Main&gt; :t modify ((+1) :: Int -&gt; Int)
--   modify (...) :: (MonadState Int a) =&gt; a ()
--   </pre>
--   
--   This says that <tt>modify (+1)</tt> acts over any Monad that is a
--   member of the <tt>MonadState</tt> class, with an <tt>Int</tt> state.
modify :: MonadState s m => (s -> s) -> m ()
instance (Functor f, Representable g, MonadFree f m) => MonadFree f (StateT g m)
instance (Representable g, MonadCont m) => MonadCont (StateT g m)
instance (Representable g, MonadWriter w m) => MonadWriter w (StateT g m)
instance (Representable g, MonadReader e m) => MonadReader e (StateT g m)
instance (Representable g, Monad m, Key g ~ s) => MonadState s (StateT g m)
instance Representable f => MonadTrans (StateT f)
instance Representable f => BindTrans (StateT f)
instance (Representable g, Monad m) => Monad (StateT g m)
instance (Functor g, Indexable g, Bind m) => Bind (StateT g m)
instance (Representable g, Functor m, Monad m) => Applicative (StateT g m)
instance (Functor g, Indexable g, Bind m) => Apply (StateT g m)
instance (Functor g, Functor m) => Functor (StateT g m)


-- | A generalized Store comonad, parameterized by a Representable functor.
--   The representation of that functor serves as the index of the store.
module Control.Comonad.Representable.Store

-- | A memoized store comonad parameterized by a representable functor
--   <tt>g</tt>, where the representatation of <tt>g</tt>, <tt>Key g</tt>
--   is the index of the store.
type Store g = StoreT g Identity

-- | Construct a store comonad computation from a function and a current
--   index. (The inverse of <a>runStore</a>.)
store :: Representable g => (Key g -> a) -> Key g -> Store g a

-- | Unwrap a state monad computation as a function. (The inverse of
--   <tt>state</tt>.)
runStore :: Indexable g => Store g a -> (Key g -> a, Key g)

-- | A store transformer comonad parameterized by:
--   
--   <ul>
--   <li><tt>g</tt> - A representable functor used to memoize results for
--   an index <tt>Key g</tt></li>
--   <li><tt>w</tt> - The inner comonad.</li>
--   </ul>
data StoreT g w a
StoreT :: (w (g a)) -> (Key g) -> StoreT g w a
storeT :: (Functor w, Representable g) => w (Key g -> a) -> Key g -> StoreT g w a
runStoreT :: (Functor w, Indexable g) => StoreT g w a -> (w (Key g -> a), Key g)
pos :: ComonadStore s w => forall a. w a -> s
peek :: ComonadStore s w => forall a. s -> w a -> a
peeks :: ComonadStore s w => forall a. (s -> s) -> w a -> a
seek :: ComonadStore s w => forall a. s -> w a -> w a
seeks :: ComonadStore s w => forall a. (s -> s) -> w a -> w a
instance (Representable g, ComonadCofree f w) => ComonadCofree f (StoreT g w)
instance (ComonadEnv m w, Representable g) => ComonadEnv m (StoreT g w)
instance (ComonadTraced m w, Representable g) => ComonadTraced m (StoreT g w)
instance ComonadHoist (StoreT g)
instance Indexable g => ComonadTrans (StoreT g)
instance (Comonad w, Representable g) => Comonad (StoreT g w)
instance (Extend w, Representable g) => Extend (StoreT g w)
instance (Applicative w, Semigroup (Key g), Monoid (Key g), Representable g) => Applicative (StoreT g w)
instance (ComonadApply w, Semigroup (Key g), Representable g) => ComonadApply (StoreT g w)
instance (Apply w, Semigroup (Key g), Representable g) => Apply (StoreT g w)
instance (Functor w, Functor g) => Functor (StoreT g w)
instance (Comonad w, Representable g, Key g ~ s) => ComonadStore s (StoreT g w)


-- | Representable contravariant endofunctors over the category of Haskell
--   types are isomorphic to <tt>(_ -&gt; r)</tt> and resemble mappings to
--   a fixed range.
module Data.Functor.Contravariant.Representable

-- | Dual to <tt>Keyed</tt>.
class Contravariant f => Valued f
contramapWithValue :: Valued f => (b -> Either a (Value f)) -> f a -> f b

-- | Dual to <tt>Indexed</tt>.
class Coindexed f
coindex :: Coindexed f => f a -> a -> Value f

-- | A <a>Contravariant</a> functor <tt>f</tt> is <a>Representable</a> if
--   <a>contrarep</a> and <a>coindex</a> witness an isomorphism to <tt>(_
--   -&gt; Value f)</tt>.
class (Coindexed f, Valued f) => Representable f
contrarep :: Representable f => (a -> Value f) -> f a
contramapDefault :: Representable f => (a -> b) -> f b -> f a
contramapWithValueDefault :: Representable f => (b -> Either a (Value f)) -> f a -> f b
instance (Coindexed f, Coindexed g) => Coindexed (Coproduct f g)
instance (Representable f, Representable g) => Representable (Product f g)
instance (Coindexed f, Coindexed g) => Coindexed (Product f g)
instance (Valued f, Valued g) => Valued (Product f g)
instance Representable Predicate
instance Coindexed Predicate
instance Valued Predicate
instance Representable (Op r)
instance Coindexed (Op r)
instance Valued (Op r)
