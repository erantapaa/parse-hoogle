-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Provides free functors that are adjoint to functors that forget class constraints.
--   
@package free-functors
@version 0.6.3.3


-- | A free functor is left adjoint to a forgetful functor. In this package
--   the forgetful functor forgets class constraints.
--   
--   Compared to <tt>Data.Functor.Free</tt> we're going up a level. These
--   free functors go between categories of functors and the natural
--   transformations between them.
module Data.Functor.HFree

-- | Natural transformations.
type (:~>) f g = forall b. f b -> g b

-- | The higher order free functor for constraint <tt>c</tt>.
newtype HFree c f a
HFree :: (forall g. (c g, Functor g) => (f :~> g) -> g a) -> HFree c f a
runHFree :: HFree c f a -> forall g. (c g, Functor g) => (f :~> g) -> g a
unit :: f :~> HFree c f
rightAdjunct :: (c g, Functor g) => (f :~> g) -> HFree c f :~> g

-- | <pre>
--   counit = rightAdjunct id
--   </pre>
counit :: (c f, Functor f) => HFree c f :~> f

-- | <pre>
--   leftAdjunct f = f . unit
--   </pre>
leftAdjunct :: (HFree c f :~> g) -> f :~> g
hfmap :: (f :~> g) -> HFree c f :~> HFree c g
liftFree :: f a -> HFree c f a
lowerFree :: (c f, Functor f) => HFree c f a -> f a
convert :: (c (t f), Functor (t f), Monad f, MonadTrans t) => HFree c f a -> t f a
iter :: c Identity => (forall b. f b -> b) -> HFree c f a -> a

-- | The free monad of a functor.
wrap :: f (HFree Monad f a) -> HFree Monad f a
instance Alternative (HFree Alternative f)
instance Applicative (HFree Alternative f)
instance Applicative (HFree Applicative f)
instance Monad (HFree Monad f)
instance Applicative (HFree Monad f)
instance Functor (HFree c f)


-- | A cofree functor is right adjoint to a forgetful functor. In this
--   package the forgetful functor forgets class constraints.
--   
--   Compared to <tt>Data.Functor.Cofree</tt> we're going up a level. These
--   free functors go between categories of functors and the natural
--   transformations between them.
module Data.Functor.HCofree

-- | Natural transformations.
type (:~>) f g = forall b. f b -> g b

-- | The higher order cofree functor for constraint <tt>c</tt>.
data HCofree c g a
HCofree :: (f :~> g) -> f a -> HCofree c g a
counit :: HCofree c g :~> g
leftAdjunct :: (c f, Functor f) => (f :~> g) -> f :~> HCofree c g

-- | <pre>
--   unit = leftAdjunct id
--   </pre>
unit :: (c g, Functor g) => g :~> HCofree c g

-- | <pre>
--   rightAdjunct f = counit . f
--   </pre>
rightAdjunct :: (f :~> HCofree c g) -> f :~> g
hfmap :: (f :~> g) -> HCofree c f :~> HCofree c g
liftCofree :: (c f, Functor f) => f a -> HCofree c f a
lowerCofree :: HCofree c f a -> f a
convert :: (c (t f), Functor (t f), Comonad f, ComonadTrans t) => t f a -> HCofree c f a
coiter :: c Identity => (forall b. b -> f b) -> a -> HCofree c f a

-- | The cofree comonad of a functor.
unwrap :: HCofree Comonad g a -> g (HCofree Comonad g a)
instance Comonad (HCofree Comonad g)
instance Traversable (HCofree Traversable g)
instance Foldable (HCofree Traversable g)
instance Foldable (HCofree Foldable g)
instance Functor (HCofree c g)


-- | A free functor is left adjoint to a forgetful functor. In this package
--   the forgetful functor forgets class constraints.
module Data.Functor.Free

-- | The free functor for class <tt>c</tt>.
--   
--   <tt>Free c a</tt> is basically an expression tree with operations from
--   class <tt>c</tt> and variables/placeholders of type <tt>a</tt>,
--   created with <a>unit</a>. Monadic bind allows you to replace each of
--   these variables with another sub-expression.
newtype Free c a
Free :: (forall b. c b => (a -> b) -> b) -> Free c a
runFree :: Free c a -> forall b. c b => (a -> b) -> b

-- | Derive the instances of <tt><a>Free</a> c a</tt> for the class
--   <tt>c</tt>, <a>Show</a>, <a>Foldable</a> and <a>Traversable</a>.
--   
--   For example:
--   
--   <pre>
--   deriveInstances ''Num
--   </pre>
deriveInstances :: Name -> Q [Dec]

-- | <a>unit</a> allows you to create `Free c` values, together with the
--   operations from the class <tt>c</tt>.
unit :: a -> Free c a

-- | <a>rightAdjunct</a> is the destructor of `Free c` values.
rightAdjunct :: c b => (a -> b) -> Free c a -> b
rightAdjunctF :: ForallF c f => (a -> f b) -> Free c a -> f b
rightAdjunctT :: ForallT c t => (a -> t f b) -> Free c a -> t f b

-- | <pre>
--   counit = rightAdjunct id
--   </pre>
counit :: c a => Free c a -> a

-- | <pre>
--   leftAdjunct f = f . unit
--   </pre>
leftAdjunct :: (Free c a -> b) -> a -> b

-- | <pre>
--   transform f as = as &gt;&gt;= f unit
--   </pre>
--   
--   <pre>
--   transform f . transform g = transform (g . f)
--   </pre>
transform :: (forall r. c r => (b -> r) -> a -> r) -> Free c a -> Free c b

-- | <pre>
--   unfold f = coproduct (unfold f) unit . f
--   </pre>
--   
--   <a>inL</a> and <a>inR</a> are useful here. For example, the following
--   creates the list <tt>[1..10]</tt> as a <tt>Free Monoid</tt>:
--   
--   <pre>
--   unfold (b -&gt; if b == 0 then mempty else <a>inL</a> (b - 1) &lt;&gt; <a>inR</a> b) 10
--   </pre>
unfold :: (b -> Coproduct c b a) -> b -> Free c a

-- | <pre>
--   convert = rightAdjunct pure
--   </pre>
convert :: (c (f a), Applicative f) => Free c a -> f a

-- | <pre>
--   convertClosed = rightAdjunct absurd
--   </pre>
convertClosed :: c r => Free c Void -> r

-- | Products of <tt>Monoid</tt>s are <tt>Monoid</tt>s themselves. But
--   coproducts of <tt>Monoid</tt>s are not. However, the free
--   <tt>Monoid</tt> applied to the coproduct <i>is</i> a <tt>Monoid</tt>,
--   and it is the coproduct in the category of <tt>Monoid</tt>s. This is
--   also called the free product, and generalizes to any algebraic class.
type Coproduct c m n = Free c (Either m n)
coproduct :: c r => (m -> r) -> (n -> r) -> Coproduct c m n -> r
inL :: m -> Coproduct c m n
inR :: n -> Coproduct c m n
type InitialObject c = Free c Void
initial :: c r => InitialObject c -> r
instance (Show a, Show (Signature c (ShowHelper (Signature c) a)), c (ShowHelper (Signature c) a)) => Show (Free c a)
instance (Show a, Show (f (ShowHelper f a))) => Show (ShowHelper f a)
instance Algebra f (ShowHelper f a)
instance (ForallT c (LiftAFree c)) => Traversable (Free c)
instance (ForallT c (LiftAFree c)) => Foldable (Free c)
instance (Applicative f, c ~ Class s) => Algebra s (LiftAFree c f a)
instance c ~ Class f => Algebra f (Free c a)
instance (ForallF c Identity, ForallF c (Compose (Free c) (Free c))) => Comonad (Free c)
instance Monad (Free c)
instance Applicative (Free c)
instance Functor (Free c)


-- | A cofree functor is right adjoint to a forgetful functor. In this
--   package the forgetful functor forgets class constraints.
module Data.Functor.Cofree

-- | The cofree functor for constraint <tt>c</tt>.
data Cofree c b
Cofree :: (a -> b) -> a -> Cofree c b
counit :: Cofree c b -> b
leftAdjunct :: c a => (a -> b) -> a -> Cofree c b
leftAdjunctF :: ForallF c f => (f a -> b) -> f a -> Cofree c b

-- | <pre>
--   unit = leftAdjunct id
--   </pre>
unit :: c b => b -> Cofree c b

-- | <pre>
--   rightAdjunct f = counit . f
--   </pre>
rightAdjunct :: (a -> Cofree c b) -> a -> b
convert :: (c (w a), Comonad w) => w a -> Cofree c a
type Product c m n = Cofree c (m, n)
product :: c a => (a -> m) -> (a -> n) -> a -> Product c m n
outL :: Product c m n -> m
outR :: Product c m n -> n
type TerminalObject c = Cofree c ()
terminal :: c a => a -> TerminalObject c
instance (ForallF c Identity, ForallF c (Cofree c), ForallF c (Compose (Cofree c) (Cofree c))) => Monad (Cofree c)
instance (ForallF c Identity, ForallF c (Cofree c), ForallF c (Compose (Cofree c) (Cofree c))) => Applicative (Cofree c)
instance (ForallF c (Cofree c)) => Comonad (Cofree c)
instance Functor (Cofree c)
