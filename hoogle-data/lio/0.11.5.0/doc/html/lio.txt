-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Labeled IO Information Flow Control Library
--   
--   The <i>Labeled IO</i> (LIO) library is an information flow control
--   (IFC) library. IFC is a mechanism that enforces security policies by
--   tracking and controlling the flow of information within a system.
--   Unlike discretionary access control (such as UNIX file permissions),
--   IFC permits scenarios in which untrusted computation may have the
--   ability to manipulate secret data without having the ability to
--   further disclose that data.
--   
--   LIO is an IFC library that can be used to implement such untrusted
--   computations. LIO provides combinators similar to those of <a>IO</a>
--   for performing side-effecting computations (e.g., modifying mutable
--   references, forking threads, throwing and catching exceptions, etc.)
--   To track and control the flow of information, LIO associates a
--   security policy, called a <i>label</i>, with every piece of data. A
--   label may, for example, impose a restriction on who can observe,
--   propagate, or modify the data to which it applies. Unlike standard IO
--   operations, the LIO counterparts check the vailidity of labels before
--   performing the (underlying IO) side-effecting computation. For
--   example, before writing to a labeled variable, LIO asserts that the
--   write will not violate any security policies associated with the data
--   to be written.
--   
--   Most code should import module <a>LIO</a> and whichever label format
--   the application is using (e.g., <a>LIO.DCLabel</a> to use the format
--   that ships with the library). Side-effecting code should be specified
--   as actions in the <a>LIO</a> monad. See <a>LIO.Core</a> for a
--   description of the core library API, <a>LIO.Label</a> for a discussion
--   of labels, and <a>LIO.Run</a> for functions allowing one to run an
--   <a>LIO</a> computation from the <a>IO</a> monad.
--   
--   WARNING: For security, untrusted code must always be compiled with the
--   <tt>-XSafe</tt> and <tt>-fpackage-trust</tt> <i>SafeHaskell</i> flags.
--   See
--   <a>http://www.haskell.org/ghc/docs/latest/html/users_guide/safe-haskell.html</a>
--   for more details on the guarantees provided by SafeHaskell.
@package lio
@version 0.11.5.0


-- | This module exports symbols that must be accessible only to trusted
--   code. By convention, the names of such symbols always end
--   "<tt>...TCB</tt>" (short for "trusted computing base"). In many cases,
--   a type is safe to export while its constructor is not. Hence, only the
--   constructor ends "<tt>TCB</tt>", while the type is re-exported to safe
--   code (without constructors) from <a>LIO.Core</a>.
--   
--   Security rests on the fact that untrusted code must be compiled with
--   <tt>-XSafe</tt>. Because this module is flagged unsafe, it cannot be
--   imported from safe modules.
module LIO.TCB

-- | Internal state of an <a>LIO</a> computation.
data LIOState l
LIOState :: !l -> !l -> LIOState l

-- | Current label.
lioLabel :: LIOState l -> !l

-- | Current clearance.
lioClearance :: LIOState l -> !l

-- | The <tt>LIO</tt> monad is a wrapper around <a>IO</a> that keeps track
--   of a <i>current label</i> and <i>current clearance</i>. Safe code
--   cannot execute arbitrary <a>IO</a> actions from the <a>LIO</a> monad.
--   However, trusted runtime functions can use <a>ioTCB</a> to perform
--   <a>IO</a> actions (which they should only do after appropriately
--   checking labels).
newtype LIO l a
LIOTCB :: (IORef (LIOState l) -> IO a) -> LIO l a

-- | Get internal state. This function is not actually unsafe, but to avoid
--   future security bugs we leave all direct access to the internal state
--   to trusted code.
getLIOStateTCB :: LIO l (LIOState l)

-- | Set internal state.
putLIOStateTCB :: LIOState l -> LIO l ()

-- | Update the internal state given some function.
modifyLIOStateTCB :: (LIOState l -> LIOState l) -> LIO l ()

-- | Lifts an <a>IO</a> computation into the <a>LIO</a> monad. This
--   function is dangerous and should only be called after appropriate
--   checks ensure the <a>IO</a> computation will not violate IFC policy.
ioTCB :: IO a -> LIO l a

-- | A newtype wrapper that can be used by trusted code to transform a
--   powerless description of privileges into actual privileges. The
--   constructor, <a>PrivTCB</a>, is dangerous as it allows creation of
--   arbitrary privileges. Hence it is only exported by the unsafe module
--   <a>LIO.TCB</a>. A safe way to create arbitrary privileges is to call
--   <tt>privInit</tt> (see <a>LIO.Run#v:privInit</a>) from the <a>IO</a>
--   monad before running your <a>LIO</a> computation.
newtype Priv a
PrivTCB :: a -> Priv a

-- | <tt>Labeled l a</tt> is a value that associates a label of type
--   <tt>l</tt> with a pure value of type <tt>a</tt>. Labeled values allow
--   users to label data with a label other than the current label. Note
--   that <a>Labeled</a> is an instance of <a>LabelOf</a>, which means that
--   only the <i>contents</i> of a labeled value (the type <tt>t</tt>) is
--   kept secret, not the label. Of course, if you have a <tt>Labeled</tt>
--   within a <tt>Labeled</tt>, then the label on the inner value will be
--   protected by the outer label.
data Labeled l t
LabeledTCB :: !l -> t -> Labeled l t

-- | Generic class used to get the type of labeled objects. For, instance,
--   if you wish to associate a label with a pure value (as in
--   <a>LIO.Labeled</a>), you may create a data type:
--   
--   <pre>
--   data LVal l a = LValTCB l a
--   </pre>
--   
--   Then, you may wish to allow untrusted code to read the label of any
--   <tt>LVal</tt>s but not necessarily the actual value. To do so, simply
--   provide an instance for <tt>LabelOf</tt>:
--   
--   <pre>
--   instance LabelOf LVal where
--     labelOf (LValTCB l a) = l
--   </pre>
class LabelOf t
labelOf :: LabelOf t => t l a -> l

-- | An uncatchable exception hierarchy is used to terminate an untrusted
--   thread. Wrap the uncatchable exception in <a>UncatchableTCB</a> before
--   throwing it to the thread. <tt>runLIO</tt> will subsequently unwrap
--   the <a>UncatchableTCB</a> constructor.
--   
--   Note this can be circumvented by <a>mapException</a>, which should be
--   made unsafe. In the interim, auditing untrusted code for this is
--   necessary.
data UncatchableTCB
UncatchableTCB :: e -> UncatchableTCB

-- | Simple utility function that strips <a>UncatchableTCB</a> from around
--   an exception.
makeCatchable :: SomeException -> SomeException

-- | It would be a security issue to make certain objects members of the
--   <a>Show</a> class. Nonetheless it is useful to be able to examine such
--   objects when debugging. The <a>showTCB</a> method can be used to
--   examine such objects.
class ShowTCB a
showTCB :: ShowTCB a => a -> String

-- | A <tt>LabeledResult</tt> encapsulates a future result from a
--   computation spawned by <tt>lFork</tt> or <tt>lForkP</tt>. See
--   <a>LIO.Concurrent</a> for a description of the concurrency
--   abstractions of LIO.
data LabeledResult l a
LabeledResultTCB :: !ThreadId -> !l -> !(MVar ()) -> !(IORef (LResStatus l a)) -> LabeledResult l a

-- | Thread executing the computation
lresThreadIdTCB :: LabeledResult l a -> !ThreadId

-- | Label of the tresult
lresLabelTCB :: LabeledResult l a -> !l

-- | This <tt>MVar</tt> is empty until such point as <a>lresStatusTCB</a>
--   is no longer <a>LResEmpty</a>. Hence, calling <tt>readMVar</tt> on
--   this field allows one to wait for the thread to terminate.
lresBlockTCB :: LabeledResult l a -> !(MVar ())

-- | Result (when it is ready), or the label at which the thread
--   terminated, if that label could not flow to <a>lresLabelTCB</a>.
lresStatusTCB :: LabeledResult l a -> !(IORef (LResStatus l a))

-- | Status of a <a>LabeledResult</a>.
data LResStatus l a
LResEmpty :: LResStatus l a
LResLabelTooHigh :: !l -> LResStatus l a
LResResult :: a -> LResStatus l a
instance Typeable2 LIO
instance Typeable UncatchableTCB
instance Typeable1 Priv
instance Typeable2 Labeled
instance Eq l => Eq (LIOState l)
instance Show l => Show (LIOState l)
instance Read l => Read (LIOState l)
instance Show a => Show (Priv a)
instance Eq a => Eq (Priv a)
instance (Show l, Show a) => Show (LResStatus l a)
instance LabelOf LabeledResult
instance LabelOf Labeled
instance (Show l, Show a) => ShowTCB (Labeled l a)
instance Monoid p => Monoid (Priv p)
instance Exception UncatchableTCB
instance Show UncatchableTCB
instance Applicative (LIO l)
instance Functor (LIO l)
instance Monad (LIO l)

module LIO.Label

-- | This class defines the operations necessary to make a label into a
--   lattice (see <a>http://en.wikipedia.org/wiki/Lattice_(order)</a>).
--   <a>canFlowTo</a> partially orders labels. <a>lub</a> and <a>glb</a>
--   compute the least upper bound and greatest lower bound of two labels,
--   respectively.
class (Eq l, Show l, Read l, Typeable l) => Label l
lub :: Label l => l -> l -> l
glb :: Label l => l -> l -> l
canFlowTo :: Label l => l -> l -> Bool

-- | Every privilege type must be an instance of <a>SpeaksFor</a>, which is
--   a partial order specifying when one privilege value is at least as
--   powerful as another. If <tt><a>canFlowToP</a> p1 l1 l2</tt> and <tt>p2
--   <a>speaksFor</a> p1</tt>, then it should also be true that
--   <tt><a>canFlowToP</a> p2 l1 l2</tt>.
--   
--   As a partial order, <a>SpeaksFor</a> should obey the reflexivity,
--   antisymmetry and transitivity laws. However, if you do not wish to
--   allow delegation of a particular privilege type, you can define
--   <tt><a>speaksFor</a> _ _ = False</tt> (which violates the reflexivity
--   law, but is reasonable when you don't want the partial order).
class (Typeable p, Show p) => SpeaksFor p
speaksFor :: SpeaksFor p => p -> p -> Bool

-- | This class represents privilege descriptions, which define a pre-order
--   on labels in which distinct labels become equivalent. The pre-oder
--   implied by a privilege description is specified by the method
--   <a>canFlowToP</a>. In addition, this this class defines a method
--   <a>downgradeP</a>, which is important for finding least labels
--   satisfying a privilege equivalence.
--   
--   Minimal complete definition: <a>downgradeP</a>.
--   
--   (The <a>downgradeP</a> requirement represents the fact that a generic
--   <a>canFlowToP</a> can be implemented efficiently in terms of
--   <a>downgradeP</a>, but not vice-versa.)
class (Label l, SpeaksFor p) => PrivDesc l p where canFlowToP p l1 l2 = downgradeP p l1 `canFlowTo` l2
downgradeP :: PrivDesc l p => p -> l -> l
canFlowToP :: PrivDesc l p => p -> l -> l -> Bool

-- | A newtype wrapper that can be used by trusted code to transform a
--   powerless description of privileges into actual privileges. The
--   constructor, <a>PrivTCB</a>, is dangerous as it allows creation of
--   arbitrary privileges. Hence it is only exported by the unsafe module
--   <a>LIO.TCB</a>. A safe way to create arbitrary privileges is to call
--   <tt>privInit</tt> (see <a>LIO.Run#v:privInit</a>) from the <a>IO</a>
--   monad before running your <a>LIO</a> computation.
data Priv a

-- | Turns privileges into a powerless description of the privileges by
--   unwrapping the <a>Priv</a> newtype.
privDesc :: Priv a -> a

-- | Uses dynamic typing to return <a>True</a> iff the type of the argument
--   is <tt><a>Priv</a> a</tt> (for any <tt>a</tt>). Mostly useful to
--   prevent users from accidentally wrapping <a>Priv</a> objects inside
--   other <a>Priv</a> objects or accidentally including real privileges in
--   an exception.
isPriv :: Typeable p => p -> Bool

-- | Generic <a>PrivDesc</a> used to denote the lack of privileges. Works
--   with any <a>Label</a> type. This is only a privilege description; a
--   more useful symbol is <a>noPrivs</a>, which actually embodies the
--   <tt>NoPrivs</tt> privilege.
data NoPrivs
NoPrivs :: NoPrivs

-- | <a>Priv</a> object corresponding to <a>NoPrivs</a>.
noPrivs :: Priv NoPrivs
instance Typeable NoPrivs
instance Show NoPrivs
instance Read NoPrivs
instance Monoid NoPrivs
instance Label l => PrivDesc l NoPrivs
instance SpeaksFor NoPrivs
instance PrivDesc l p => PrivDesc l (Priv p)
instance SpeaksFor p => SpeaksFor (Priv p)


-- | This module contains functions to launch <a>LIO</a> computations from
--   within the <a>IO</a> monad. These functions are not useful from within
--   <a>LIO</a> code (but not harmful either, since their types are in the
--   <a>IO</a> monad).
--   
--   This module is intended to be imported into your Main module, for use
--   in invoking <a>LIO</a> code. The functions are also available via
--   <a>LIO</a> and <a>LIO.Core</a>, but those modules will clutter your
--   namespace with symbols you don't need in the <a>IO</a> monad.
module LIO.Run

-- | Internal state of an <a>LIO</a> computation.
data LIOState l
LIOState :: !l -> !l -> LIOState l

-- | Current label.
lioLabel :: LIOState l -> !l

-- | Current clearance.
lioClearance :: LIOState l -> !l

-- | Execute an <a>LIO</a> action, returning its result and the final label
--   state as a pair. Note that it returns a pair whether or not the
--   <a>LIO</a> action throws an exception. Forcing the result value will
--   re-throw the exception, but the label state will always be valid.
--   
--   See also <a>evalLIO</a>.
runLIO :: LIO l a -> LIOState l -> IO (a, LIOState l)

-- | A variant of <a>runLIO</a> that returns results in <a>Right</a> and
--   exceptions in <a>Left</a>, much like the standard library <a>try</a>
--   function.
tryLIO :: LIO l a -> LIOState l -> IO (Either SomeException a, LIOState l)

-- | Given an <a>LIO</a> computation and some initial state, return an IO
--   action which, when executed, will perform the IFC-safe LIO
--   computation.
--   
--   Because untrusted code cannot execute <a>IO</a> computations, this
--   function should only be useful within trusted code. No harm is done
--   from exposing the <tt>evalLIO</tt> symbol to untrusted code. (In
--   general, untrusted code is free to produce <a>IO</a> computations, but
--   it cannot execute them.)
--   
--   Unlike <a>runLIO</a>, this function throws an exception if the
--   underlying <a>LIO</a> action terminates with an exception.
evalLIO :: LIO l a -> LIOState l -> IO a

-- | Initialize some privileges (within the <a>IO</a> monad) that can be
--   passed to <a>LIO</a> computations run with <a>runLIO</a> or
--   <a>evalLIO</a>. This is a pure function, but the result is
--   encapsulated in <a>IO</a> to make the return value inaccessible from
--   <a>LIO</a> computations.
--   
--   Note the same effect can be achieved using the <a>PrivTCB</a>
--   constructor, but <a>PrivTCB</a> is easier to misuse and is only
--   available by importing <a>LIO.TCB</a>.
privInit :: SpeaksFor p => p -> IO (Priv p)


-- | Exception routines much like the <tt>IO</tt> ones in
--   <a>Control.Exception</a> (we duplicate the documentation below). There
--   are two differences, however. First, LIO does not allow masking of
--   asynchronous exceptions (since these are relied upon to kill a
--   misbehaving thread). Hence, routines like <a>onException</a> are not
--   guaranteed to run if a thread is unconditionally killed. Second, in a
--   few cases (such as <tt>lWait</tt>) it is possible for the current
--   label to be raised above the current clearance as an exception is
--   thrown, in which case these functions do not catch the exception,
--   either, since code cannot run under such circumstances.
module LIO.Exception

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving (Show, Typeable)
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--       deriving Typeable
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--       deriving Typeable
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving (Typeable, Show)
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e

-- | The <tt>SomeException</tt> type is the root of the exception type
--   hierarchy. When an exception of type <tt>e</tt> is thrown, behind the
--   scenes it is encapsulated in a <tt>SomeException</tt>.
data SomeException :: *
SomeException :: e -> SomeException

-- | Throw an exception.
throwLIO :: Exception e => e -> LIO l a

-- | A simple wrapper around IO catch. The only subtlety is that code is
--   not allowed to run unless the current label can flow to the current
--   clearance. Hence, if the label exceeds the clearance, the exception is
--   not caught. (Only a few conditions such as <tt>lWait</tt> or raising
--   the clearance within <tt>scopeClearance</tt> can lead to the label
--   exceeding the clarance, and an exception is always thrown at the time
--   this happens.)
catch :: (Label l, Exception e) => LIO l a -> (e -> LIO l a) -> LIO l a

-- | A version of <a>catch</a> with the arguments swapped around.
handle :: (Label l, Exception e) => (e -> LIO l a) -> LIO l a -> LIO l a

-- | Similar to catch, but returns an <a>Either</a> result which is
--   (<a>Right</a> <tt>a</tt>) if no exception of type <tt>e</tt> was
--   raised, or (<a>Left</a> <tt>ex</tt>) if an exception of type
--   <tt>e</tt> was raised and its value is <tt>ex</tt>. If any other type
--   of exception is raised than it will be propogated up to the next
--   enclosing exception handler.
try :: (Label l, Exception a1) => LIO l a -> LIO l (Either a1 a)

-- | Like <a>finally</a>, but only performs the final action if there was
--   an exception raised by the computation.
onException :: Label l => LIO l a -> LIO l b -> LIO l a

-- | A variant of <a>bracket</a> where the return value from the first
--   computation is not required.
finally :: Label l => LIO l a -> LIO l b -> LIO l a

-- | When you want to acquire a resource, do some work with it, and then
--   release the resource, it is a good idea to use <tt>bracket</tt>,
--   because bracket will install the necessary exception handler to
--   release the resource in the event that an exception is raised during
--   the computation. If an exception is raised, then bracket will re-raise
--   the exception (after performing the release).
bracket :: Label l => LIO l a -> (a -> LIO l c) -> (a -> LIO l b) -> LIO l b

-- | Forces its argument to be evaluated to weak head normal form when the
--   resultant <a>LIO</a> action is executed.
evaluate :: a -> LIO l a


-- | This module exports exception types thrown in response to label
--   failures. In addition, it provides <a>withContext</a>, a function that
--   annotates any exceptions in the <a>AnyLabelError</a> hierarchy that
--   are thrown within a given scope. These annotations should be used to
--   add function names to exceptions, so as to make it easier to pinpoint
--   the cause of a label error.
module LIO.Error

-- | Class of error messages that can be annotated with context.
class Annotatable e
annotate :: Annotatable e => String -> e -> e

-- | Executes an action with a context string, which will be added to any
--   label exception thrown.
--   
--   Note: this function wraps an action with a <a>catch</a>, and thus may
--   incur a small runtime cost (though it is well under 100 ns on machines
--   we benchmarked).
withContext :: String -> LIO l a -> LIO l a

-- | Parent of all label-related exceptions.
data AnyLabelError
AnyLabelError :: e -> AnyLabelError

-- | Definition of <a>toException</a> for children of <a>AnyLabelError</a>
--   in the exception hierarchy.
lerrToException :: (Exception e, Annotatable e) => e -> SomeException

-- | Definition of <a>fromException</a> for children of
--   <a>AnyLabelError</a> in the exception hierarchy.
lerrFromException :: Exception e => SomeException -> Maybe e

-- | A generic privilege description for recording relevant privileges in
--   exceptions.
data GenericPrivDesc l
GenericPrivDesc :: p -> GenericPrivDesc l

-- | Main error type thrown by label failures in the <a>LIO</a> monad.
data LabelError l
LabelError :: [String] -> String -> l -> l -> [GenericPrivDesc l] -> [l] -> LabelError l

-- | Annotation of where the failure happened.
lerrContext :: LabelError l -> [String]

-- | Actual function that failed.
lerrFailure :: LabelError l -> String

-- | Current label at time of error.
lerrCurLabel :: LabelError l -> l

-- | Current clearance at time of error.
lerrCurClearance :: LabelError l -> l

-- | Any privileges involved in error.
lerrPrivs :: LabelError l -> [GenericPrivDesc l]

-- | Any labels involved in error.
lerrLabels :: LabelError l -> [l]

-- | Throw a label-error exception.
labelError :: Label l => String -> [l] -> LIO l a

-- | Throw a label-error exception.
labelErrorP :: (Label l, PrivDesc l p) => String -> Priv p -> [l] -> LIO l a

-- | Error indicating insufficient privileges (independent of the current
--   label). This exception is thrown by <tt>delegate</tt>, and should also
--   be thrown by gates that receive insufficient privilege descriptions
--   (see <a>LIO.Delegate</a>).
data InsufficientPrivs
InsufficientPrivs :: [String] -> String -> p -> p -> InsufficientPrivs
inspContext :: InsufficientPrivs -> [String]
inspFailure :: InsufficientPrivs -> String
inspSupplied :: InsufficientPrivs -> p
inspNeeded :: InsufficientPrivs -> p

-- | Raise <a>InsufficientPrivs</a> error.
insufficientPrivs :: SpeaksFor p => String -> p -> p -> a

-- | Error raised when a computation spawned by <tt>lFork</tt> terminates
--   with its current label above the label of the result.
data ResultExceedsLabel l
ResultExceedsLabel :: [String] -> String -> l -> Maybe l -> ResultExceedsLabel l
relContext :: ResultExceedsLabel l -> [String]
relLocation :: ResultExceedsLabel l -> String
relDeclaredLabel :: ResultExceedsLabel l -> l
relActualLabel :: ResultExceedsLabel l -> Maybe l
instance Typeable AnyLabelError
instance Typeable1 LabelError
instance Typeable InsufficientPrivs
instance Typeable1 ResultExceedsLabel
instance Show l => Show (LabelError l)
instance Show l => Show (ResultExceedsLabel l)
instance Label l => Exception (ResultExceedsLabel l)
instance Annotatable (ResultExceedsLabel l)
instance Exception InsufficientPrivs
instance Annotatable InsufficientPrivs
instance Show InsufficientPrivs
instance Label l => Exception (LabelError l)
instance Annotatable (LabelError l)
instance Show (GenericPrivDesc l)
instance Exception AnyLabelError
instance Annotatable AnyLabelError
instance Show AnyLabelError


-- | This module provides two functions useful for delegating privileges.
--   The <a>delegate</a> function creates a <a>Priv</a> value less powerful
--   than an existing one. <a>Gate</a>s provide a mechanism for
--   authenticating calls to closures that embed privileges.
module LIO.Delegate

-- | <tt>delegate</tt> allows you to create a new privilege object that is
--   less powerful than an existing privilege object. The first argument
--   supplies actual privileges. The second argument is a <a>PrivDesc</a>
--   describing the desired new privileges. The call throws an exception
--   unless the privilege object supplied <a>speaksFor</a> the privilege
--   object requested.
--   
--   Note: If you are looking for a way to create privileges <i>more</i>
--   powerful than ones you already have, you can use the <tt>mappend</tt>
--   function to combine existing privileges.
delegate :: SpeaksFor p => Priv p -> p -> Priv p

-- | A Gate is a lambda abstraction from a privilege description to an
--   arbitrary type <tt>a</tt>. Applying the gate is accomplished with
--   <a>callGate</a> which takes a privilege argument that is converted to
--   a description before invoking the gate computation.
data Gate p a

-- | Create a gate given a computation from a privilege description. Note
--   that because of currying type <tt>a</tt> may itself be a function type
--   and thus gates can take arguments in addition to the privilege
--   descriptoin.
gate :: (p -> a) -> Gate p a

-- | <tt>guardGate name minPriv a</tt> creates a simple gate that requires
--   privileges at least as high as <tt>minPriv</tt> to return the payload
--   or function <tt>a</tt>. If the privileges supplied are insufficient,
--   an exception of type <a>InsufficientPrivs</a> is thrown. The argument
--   <tt>name</tt> is used only when an exception is thrown, to make the
--   source of the exception more easily traceable.
--   
--   <pre>
--   guardGate name minPriv a = gate $ \pd -&gt;
--     if pd `speaksFor` minPriv then a
--     else insufficientPrivs name pd minPriv
--   </pre>
guardGate :: SpeaksFor p => String -> p -> a -> Gate p a

-- | Given a gate and privilege, execute the gate computation. It is
--   important to note that <tt>callGate</tt> invokes the gate computation
--   with the privilege description and <i>NOT</i> the privilege itself.
--   
--   Note that, in general, code should <i>not</i> provide privileges to
--   functions other than <tt>callGate</tt> when wishing to call a gate.
--   This function is provided by LIO since it can be easily inspected by
--   both the gate creator and caller to be doing the "right" thing:
--   provide the privilege description corresponding to the supplied
--   privilege as "proof" without explicitly passing in the privilege.
callGate :: Gate p a -> Priv p -> a
instance Typeable2 Gate


-- | This module implements the core of the Labeled IO (LIO) information
--   flow control (IFC) library. It provides a monad, <a>LIO</a>, that is
--   intended to be used as a replacement for the <a>IO</a> monad in
--   untrusted code. The idea is for untrusted code to provide a
--   computation in the <a>LIO</a> monad, which trusted code can then
--   safely execute through <a>evalLIO</a> and similar functions (e.g.,
--   <tt>evalDC</tt> in <a>LIO.DCLabel#v:evalDC</a>).
--   
--   Unlike <a>IO</a>, the <a>LIO</a> monad keeps track of a <i>current
--   label</i> (accessible via the <a>getLabel</a> function) during each
--   computation. The current label effectively tracks the sensitivity of
--   all the data that the computation has observed. For example, if the
--   computation has read a "secret" mutable reference (see
--   <a>LIO.LIORef</a>) and then the result of a "top-secret" thread (see
--   <a>LIO.Concurrent</a>) then the current label will be at least
--   "top-secret". Labels are described in more detail in the documentation
--   for <a>LIO.Label</a>, as well as the documentation for particular
--   label formats (such as <a>LIO.DCLabel</a>).
--   
--   The role of the current label is two-fold: First, the current label
--   protects all pure values currently in scope. For example, the current
--   label is the label on constants (such as <tt>3</tt> and <tt>"tis a
--   string"</tt>) as well as function arguments. More interestingly,
--   consider reading a secret reference:
--   
--   <pre>
--   val &lt;- readLIORef secret
--   </pre>
--   
--   Though the label of <tt>secret</tt> may be "secret", <tt>val</tt> is
--   not explicitly labeled. Hence, to protect the contents of the
--   <tt>LIORef</tt> that has been read into <tt>val</tt>, the current
--   label must be at least "secret" before returning from
--   <tt>readLIORef</tt>. More generally, if the current label is
--   <tt>l_cur</tt>, then it is only permissible to read data labeled
--   <tt>l_r</tt> if <tt>l_r `<a>canFlowTo</a>` l_cur</tt>. Note that,
--   instead of throwing an exception, reading data often just increases
--   the current label to ensure that <tt>l_r `<a>canFlowTo</a>`
--   l_cur</tt>. This is acomplished using a function such as <a>taint</a>.
--   
--   The second purpose of the current label is to prevent inforation leaks
--   into public channels. Specifically, it is only permissible to modify
--   or write to data labeled <tt>l_w</tt> when <tt>l_cur`<a>canFlowTo</a>`
--   l_w</tt>. Thus, the following attempt to leak the <tt>val</tt> after
--   reading it from a secret <tt>LIORef</tt> would fail:
--   
--   <pre>
--   writeLIORef public val
--   </pre>
--   
--   In addition to the current label, the LIO monad keeps a second label,
--   the <i>current clearance</i> (accessible via the <a>getClearance</a>
--   function). The clearance can be used to enforce a "need-to-know"
--   policy, since it represents the highest value the current label can be
--   raised to. In other words, if the current clearance is
--   <tt>l_clear</tt> then the computation cannot create, read or write to
--   objects labeled <tt>l</tt> such that <tt>(l `<a>canFlowTo</a>`
--   l_clear) == False</tt>.
module LIO.Core

-- | The <tt>LIO</tt> monad is a wrapper around <a>IO</a> that keeps track
--   of a <i>current label</i> and <i>current clearance</i>. Safe code
--   cannot execute arbitrary <a>IO</a> actions from the <a>LIO</a> monad.
--   However, trusted runtime functions can use <a>ioTCB</a> to perform
--   <a>IO</a> actions (which they should only do after appropriately
--   checking labels).
data LIO l a

-- | Synonym for monad in which <a>LIO</a> is the base monad.
class (Label l, Monad m) => MonadLIO l m | m -> l
liftLIO :: MonadLIO l m => LIO l a -> m a

-- | Internal state of an <a>LIO</a> computation.
data LIOState l
LIOState :: !l -> !l -> LIOState l

-- | Current label.
lioLabel :: LIOState l -> !l

-- | Current clearance.
lioClearance :: LIOState l -> !l

-- | Given an <a>LIO</a> computation and some initial state, return an IO
--   action which, when executed, will perform the IFC-safe LIO
--   computation.
--   
--   Because untrusted code cannot execute <a>IO</a> computations, this
--   function should only be useful within trusted code. No harm is done
--   from exposing the <tt>evalLIO</tt> symbol to untrusted code. (In
--   general, untrusted code is free to produce <a>IO</a> computations, but
--   it cannot execute them.)
--   
--   Unlike <a>runLIO</a>, this function throws an exception if the
--   underlying <a>LIO</a> action terminates with an exception.
evalLIO :: LIO l a -> LIOState l -> IO a

-- | Execute an <a>LIO</a> action, returning its result and the final label
--   state as a pair. Note that it returns a pair whether or not the
--   <a>LIO</a> action throws an exception. Forcing the result value will
--   re-throw the exception, but the label state will always be valid.
--   
--   See also <a>evalLIO</a>.
runLIO :: LIO l a -> LIOState l -> IO (a, LIOState l)

-- | Returns the value of the thread's current label.
getLabel :: Label l => LIO l l

-- | Raises the current label to the provided label, which must be between
--   the current label and clearance. See <a>taint</a>.
setLabel :: Label l => l -> LIO l ()

-- | If the current label is <tt>oldLabel</tt> and the current clearance is
--   <tt>clearance</tt>, this function allows code to raise the current
--   label to any value <tt>newLabel</tt> such that <tt><a>canFlowToP</a>
--   priv oldLabel newLabel &amp;&amp; <a>canFlowTo</a> newLabel
--   clearance</tt>. (Note the privilege argument affects the label check,
--   not the clearance check; call <a>setClearanceP</a> first to raise the
--   clearance.)
setLabelP :: PrivDesc l p => Priv p -> l -> LIO l ()

-- | Returns the thread's current clearance.
getClearance :: Label l => LIO l l

-- | Lowers the current clearance. The new clerance must be between the
--   current label and previous current clerance. One cannot raise the
--   current label or create object with labels higher than the current
--   clearance.
setClearance :: Label l => l -> LIO l ()

-- | Raises the current clearance (undoing the effects of
--   <a>setClearance</a>) by exercising privileges. If the current label is
--   <tt>l</tt> and current clearance is <tt>c</tt>, then <tt>setClearanceP
--   p cnew</tt> succeeds only if the new clearance is can flow to the
--   current clearance (modulo privileges), i.e., <tt><a>canFlowToP</a> p
--   cnew c == True</tt>. Additionally, the current label must flow to the
--   new clearance, i.e., <tt>l `<a>canFlowTo</a>` cnew</tt> == True.
--   
--   Since LIO guards that are used when reading/writing data (e.g.,
--   <a>guardAllocP</a>) do not use privileges when comparing labels with
--   the current clearance, code must always raise the current clearance,
--   to read/write data above the current clearance.
setClearanceP :: PrivDesc l p => Priv p -> l -> LIO l ()

-- | Runs an <a>LIO</a> action and re-sets the current clearance to its
--   previous value once the action returns. In particular, if the action
--   lowers the current clearance, the clearance will be restored upon
--   return.
--   
--   Note that <tt>scopeClearance</tt> always restores the clearance. If
--   that causes the clearance to drop below the current label, a
--   <tt>ClearanceViolation</tt> exception is thrown. That exception can
--   only be caught outside a second <tt>scopeClearance</tt> that restores
--   the clearance to higher than the current label.
scopeClearance :: Label l => LIO l a -> LIO l a

-- | Temporarily lowers the clearance for a computation, then restores it.
--   Equivalent to:
--   
--   <pre>
--   withClearance c lio = <a>scopeClearance</a> $ <a>setClearance</a> c &gt;&gt; lio
--   </pre>
--   
--   Note that if the computation inside <tt>withClearance</tt> acquires
--   any <a>Priv</a>s, it may still be able to raise its clearance above
--   the supplied argument using <a>setClearanceP</a>.
withClearance :: Label l => l -> LIO l a -> LIO l a

-- | A variant of <a>withClearance</a> that takes privileges. Equivalent
--   to:
--   
--   <pre>
--   withClearanceP p c lio = <a>scopeClearance</a> $ <a>setClearanceP</a> p c &gt;&gt; lio
--   </pre>
withClearanceP :: PrivDesc l p => Priv p -> l -> LIO l a -> LIO l a

-- | Parent of all label-related exceptions.
data AnyLabelError
AnyLabelError :: e -> AnyLabelError

-- | Main error type thrown by label failures in the <a>LIO</a> monad.
data LabelError l
LabelError :: [String] -> String -> l -> l -> [GenericPrivDesc l] -> [l] -> LabelError l

-- | Annotation of where the failure happened.
lerrContext :: LabelError l -> [String]

-- | Actual function that failed.
lerrFailure :: LabelError l -> String

-- | Current label at time of error.
lerrCurLabel :: LabelError l -> l

-- | Current clearance at time of error.
lerrCurClearance :: LabelError l -> l

-- | Any privileges involved in error.
lerrPrivs :: LabelError l -> [GenericPrivDesc l]

-- | Any labels involved in error.
lerrLabels :: LabelError l -> [l]

-- | Error indicating insufficient privileges (independent of the current
--   label). This exception is thrown by <tt>delegate</tt>, and should also
--   be thrown by gates that receive insufficient privilege descriptions
--   (see <a>LIO.Delegate</a>).
data InsufficientPrivs
InsufficientPrivs :: [String] -> String -> p -> p -> InsufficientPrivs
inspContext :: InsufficientPrivs -> [String]
inspFailure :: InsufficientPrivs -> String
inspSupplied :: InsufficientPrivs -> p
inspNeeded :: InsufficientPrivs -> p

-- | Ensures the label argument is between the current IO label and current
--   IO clearance. Use this function in code that allocates
--   objects--untrusted code shouldn't be able to create an object labeled
--   <tt>l</tt> unless <tt>guardAlloc l</tt> does not throw an exception.
--   Similarly use this guard in any code that writes to an object labeled
--   <tt>l</tt> for which the write has no observable side-effects.
guardAlloc :: Label l => l -> LIO l ()

-- | Like <a>guardAlloc</a>, but takes a privilege argument to be more
--   permissive. Note: privileges are <i>only</i> used when checking that
--   the current label can flow to the target label; <tt>guardAllocP</tt>
--   still always throws an exception when the target label is higher than
--   the current clearance.
guardAllocP :: PrivDesc l p => Priv p -> l -> LIO l ()

-- | Use <tt>taint l</tt> in trusted code before observing an object
--   labeled <tt>l</tt>. This will raise the current label to a value
--   <tt>l'</tt> such that <tt>l `<a>canFlowTo</a>` l'</tt>, or throw a
--   <a>LabelError</a> exception if <tt>l'</tt> would have to be higher
--   than the current clearance.
taint :: Label l => l -> LIO l ()

-- | Like <a>taint</a>, but use privileges to reduce the amount of taint
--   required. Note that <tt>taintP</tt> will never lower the current
--   label. It simply uses privileges to avoid raising the label as high as
--   <a>taint</a> would raise it.
taintP :: PrivDesc l p => Priv p -> l -> LIO l ()

-- | Use <tt>guardWrite l</tt> in any (trusted) code before modifying an
--   object labeled <tt>l</tt>, for which the modification can be observed,
--   i.e., the write implies a read.
--   
--   The implementation of <tt>guardWrite</tt> is straight forward:
--   
--   <pre>
--   guardWrite l = guardAlloc l &gt;&gt; taint l
--   </pre>
--   
--   This guarantees that <tt>l</tt> `<a>canFlowTo</a>` the current label
--   (and clearance), and that the current label `<a>canFlowTo</a>`
--   <tt>l</tt>.
guardWrite :: Label l => l -> LIO l ()

-- | Like <a>guardWrite</a>, but takes a privilege argument to be more
--   permissive.
guardWriteP :: PrivDesc l p => Priv p -> l -> LIO l ()
instance Label l => MonadLIO l (LIO l)


-- | A data type <a>Labeled</a> protects access to pure values (hence, we
--   refer to values of type <tt><a>Label</a> a</tt> as <i>labeled
--   values</i>). The role of labeled values is to allow users to associate
--   heterogeneous labels (see <a>LIO.Label</a>) with values. Although
--   LIO's current label protects all values in scope with the current
--   label, <a>Labeled</a> values allow for more fine grained protection.
--   Moreover, trusted code may easily inspect <a>Labeled</a> values, for
--   instance, when inserting values into a database.
--   
--   Without the appropriate privileges, one cannot produce a pure
--   <i>unlabeled</i> value that depends on a secret <a>Labeled</a> value,
--   or conversely produce a high-integrity <a>Labeled</a> value based on
--   pure data. This module exports functions for creating labeled values
--   (<a>label</a>), using the values protected by <a>Labeled</a> by
--   unlabeling them (<a>unlabel</a>), and changing the value of a labeled
--   value without inspection (<a>relabelLabeledP</a>,
--   <a>taintLabeled</a>).
--   
--   Two <tt>Applicative</tt> <a>Functor</a>-like operations are also
--   defined for <a>Labeled</a> data, namely <a>lFmap</a> and <a>lAp</a>.
module LIO.Labeled

-- | <tt>Labeled l a</tt> is a value that associates a label of type
--   <tt>l</tt> with a pure value of type <tt>a</tt>. Labeled values allow
--   users to label data with a label other than the current label. Note
--   that <a>Labeled</a> is an instance of <a>LabelOf</a>, which means that
--   only the <i>contents</i> of a labeled value (the type <tt>t</tt>) is
--   kept secret, not the label. Of course, if you have a <tt>Labeled</tt>
--   within a <tt>Labeled</tt>, then the label on the inner value will be
--   protected by the outer label.
data Labeled l t

-- | Generic class used to get the type of labeled objects. For, instance,
--   if you wish to associate a label with a pure value (as in
--   <a>LIO.Labeled</a>), you may create a data type:
--   
--   <pre>
--   data LVal l a = LValTCB l a
--   </pre>
--   
--   Then, you may wish to allow untrusted code to read the label of any
--   <tt>LVal</tt>s but not necessarily the actual value. To do so, simply
--   provide an instance for <tt>LabelOf</tt>:
--   
--   <pre>
--   instance LabelOf LVal where
--     labelOf (LValTCB l a) = l
--   </pre>
class LabelOf t
labelOf :: LabelOf t => t l a -> l

-- | Function to construct a <a>Labeled</a> value from a label and a pure
--   value. If the current label is <tt>lcurrent</tt> and the current
--   clearance is <tt>ccurrent</tt>, then the label <tt>l</tt> specified
--   must satisfy <tt>lcurrent `<a>canFlowTo</a>` l &amp;&amp; l
--   `<a>canFlowTo</a>` ccurrent</tt>. Otherwise an exception is thrown
--   (see <a>guardAlloc</a>).
label :: Label l => l -> a -> LIO l (Labeled l a)

-- | Constructs a <a>Labeled</a> value using privilege to allow the value's
--   label to be below the current label. If the current label is
--   <tt>lcurrent</tt> and the current clearance is <tt>ccurrent</tt>, then
--   the privilege <tt>p</tt> and label <tt>l</tt> specified must satisfy
--   <tt>canFlowTo p lcurrent l</tt> and <tt>l `<a>canFlowTo</a>`
--   ccurrent</tt>. Note that privilege is not used to bypass the
--   clearance. You must use <a>setClearanceP</a> to raise the clearance
--   first if you wish to create a <a>Labeled</a> value at a higher label
--   than the current clearance.
labelP :: PrivDesc l p => Priv p -> l -> a -> LIO l (Labeled l a)

-- | Within the <a>LIO</a> monad, this function takes a <a>Labeled</a>
--   value and returns it as an unprotected value of the inner type. For
--   instance, in the <a>LIO</a> monad one can say:
--   
--   <pre>
--   x &lt;- unlabel (lx :: Labeled SomeLabelType Int)
--   </pre>
--   
--   And now it is possible to use the pure value <tt>x :: Int</tt>, which
--   was previously protected by a label in <tt>lx</tt>.
--   
--   <tt>unlabel</tt> raises the current label as needed to reflect the
--   fact that the thread's behavior can now depend on the contents of
--   <tt>lx</tt>. If <tt>unlabel</tt>ing a value would require raising the
--   current label above the current clearance, then <tt>unlabel</tt>
--   throws an exception of type <a>LabelError</a>. You can use
--   <a>labelOf</a> to check beforehand whether <a>unlabel</a> will
--   succeed.
unlabel :: Label l => Labeled l a -> LIO l a

-- | Extracts the contents of a <a>Labeled</a> value just like
--   <a>unlabel</a>, but takes a privilege argument to minimize the amount
--   the current label must be raised. The privilege is used to raise the
--   current label less than might be required otherwise, but this function
--   does not change the current clarance and still throws a
--   <a>LabelError</a> if the privileges supplied are insufficient to save
--   the current label from needing to exceed the current clearance.
unlabelP :: PrivDesc l p => Priv p -> Labeled l a -> LIO l a

-- | Relabels a <a>Labeled</a> value to the supplied label if the given
--   privileges permit it. An exception is thrown unless the following two
--   conditions hold:
--   
--   <ol>
--   <li>The new label must be below the current clearance.</li>
--   <li>The old label and new label must be equal (modulo privileges), as
--   enforced by <a>canFlowToP</a>.</li>
--   </ol>
relabelLabeledP :: PrivDesc l p => Priv p -> l -> Labeled l a -> LIO l (Labeled l a)

-- | Raises the label of a <a>Labeled</a> value to the <a>lub</a> of it's
--   current label and the value supplied. The label supplied must be
--   bounded by the current label and clearance, though the resulting label
--   may not be if the <a>Labeled</a> value's label is already above the
--   current thread's clearance. If the supplied label is not bounded then
--   <tt>taintLabeled</tt> will throw an exception (see <a>guardAlloc</a>).
taintLabeled :: Label l => l -> Labeled l a -> LIO l (Labeled l a)

-- | Same as <a>taintLabeled</a>, but uses privileges when comparing the
--   current label to the supplied label. In other words, this function can
--   be used to lower the label of the labeled value by leveraging the
--   supplied privileges.
taintLabeledP :: PrivDesc l p => Priv p -> l -> Labeled l a -> LIO l (Labeled l a)

-- | A function similar to <a>fmap</a> for <a>Labeled</a> values. Applies a
--   function to a <a>Labeled</a> value without <a>unlabel</a>ing the value
--   or changing the thread's current label. The label of the result is the
--   <a>lub</a> of the current label and that of the supplied
--   <a>Labeled</a> value. Because of laziness, the actual computation on
--   the value of type <tt>a</tt> will be deferred until a thread with a
--   higher label actually <a>unlabel</a>s the result.
lFmap :: Label l => Labeled l a -> (a -> b) -> LIO l (Labeled l b)

-- | Similar to <a>ap</a>, apply function (wrapped by <a>Labeled</a>) to
--   the labeld value. The label of the returned value is the <a>lub</a> of
--   the thread's current label, the label of the supplied function, and
--   the label of the supplied value.
lAp :: Label l => Labeled l (a -> b) -> Labeled l a -> LIO l (Labeled l b)


-- | This module provides routines for safely exposing IO functions in the
--   <a>LIO</a> monad. At a high level, certain IO objects such as handles
--   can be associated with a label via <a>LObj</a>, while certain
--   operations can then be blessed (via <a>blessTCB</a>) to operate on
--   such <a>LObj</a> objects.
--   
--   For example, trusted code might define the following:
--   
--   <pre>
--   import qualified System.IO as IO
--   
--   type Handle = LObj DCLabel IO.Handle
--   
--   hPutStrLn :: LObj DCLabel IO.Handle -&gt; String -&gt; LIO DCLabel ()
--   hPutStrLn h = blessTCB "hPutStrLn" IO.hPutStrLn h
--   
--   hPutStrLnP :: DCPriv -&gt; LObj DCLabel IO.Handle -&gt; String -&gt; LIO DCLabel ()
--   hPutStrLnP h = blessPTCB "hPutStrLnP" IO.hPutStrLn h
--   
--   hGetLine :: LObj DCLabel IO.Handle -&gt; LIO DCLabel String
--   hGetLine h = blessTCB "hGetLine" IO.hGetLine h
--   </pre>
--   
--   Then application-specific trusted code can wrap a specific label
--   around each <tt>Handle</tt> using the <a>LObjTCB</a> constructor.
module LIO.TCB.LObj

-- | A "<tt>LObj label object</tt>" is a wrapper around an IO abstraction
--   of type <tt>object</tt> (such as a file handle or socket) on which it
--   is safe to do <tt>IO</tt> operations in the <a>LIO</a> monad when the
--   caller can read and write a the label <tt>label</tt>. It is the job of
--   the trusted code constructing such a <tt>LObj</tt> object to ensure
--   both that the same IO object is only ever associated with a single
--   label, and that the abstraction combined with its blessed IO
--   operations (see <a>blessTCB</a>) cannot be used to communicate with
--   code running at different labels.
data LObj label object
LObjTCB :: !label -> !object -> LObj label object

-- | This function can be used to turn an <a>IO</a> function into an
--   <a>LIO</a> one. The <a>LIO</a> version expects a <a>LObj</a> argument,
--   and before performing any IO uses <a>guardWrite</a> to check that the
--   current label can write the label in the <a>LObj</a> object.
--   
--   The first argument should be the name of the function being defined
--   with <tt>blessTCB</tt>. Its purpose is to enhance error reporting.
--   
--   Note that <tt>io</tt> and <tt>lio</tt> are function types (of up to
--   nine arguments), which must be the same in all types except the monad.
--   For example, if <tt>io</tt> is <tt>Int -&gt; String -&gt; IO ()</tt>,
--   then <tt>lio</tt> must be <tt>Int -&gt; String -&gt; LIO l ()</tt>.
blessTCB :: (GuardIO l io lio, Label l) => String -> (a -> io) -> (LObj l a) -> lio

-- | A variant of <a>blessTCB</a> that produces an <a>LIO</a> function
--   taking a privilege argument.
blessPTCB :: (GuardIO l io lio, PrivDesc l p) => String -> (a -> io) -> Priv p -> (LObj l a) -> lio

-- | Similar to <a>blessTCB</a>, but enforces the weaker restriction that
--   the action is write-only. When in doubt use <a>blessTCB</a>.
blessWriteOnlyTCB :: (GuardIO l io lio, Label l) => String -> (a -> io) -> (LObj l a) -> lio
blessWriteOnlyPTCB :: (GuardIO l io lio, PrivDesc l p) => String -> (a -> io) -> Priv p -> (LObj l a) -> lio

-- | Similar to <a>blessTCB</a>, but enforces the weaker restriction that
--   the action is read-only. When in doubt use <a>blessTCB</a>.
blessReadOnlyTCB :: (GuardIO l io lio, Label l) => String -> (a -> io) -> (LObj l a) -> lio
blessReadOnlyPTCB :: (GuardIO l io lio, PrivDesc l p) => String -> (a -> io) -> Priv p -> (LObj l a) -> lio

-- | Class for lifting <a>IO</a> actions.
class GuardIO l io lio | l io -> lio
guardIOTCB :: GuardIO l io lio => (LIO l ()) -> io -> lio
instance Typeable2 LObj
instance GuardIO l (a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> a8 -> a9 -> a10 -> IO r) (a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> a8 -> a9 -> a10 -> LIO l r)
instance GuardIO l (a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> a8 -> a9 -> IO r) (a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> a8 -> a9 -> LIO l r)
instance GuardIO l (a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> a8 -> IO r) (a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> a8 -> LIO l r)
instance GuardIO l (a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> IO r) (a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> LIO l r)
instance GuardIO l (a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> IO r) (a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> LIO l r)
instance GuardIO l (a1 -> a2 -> a3 -> a4 -> a5 -> IO r) (a1 -> a2 -> a3 -> a4 -> a5 -> LIO l r)
instance GuardIO l (a1 -> a2 -> a3 -> a4 -> IO r) (a1 -> a2 -> a3 -> a4 -> LIO l r)
instance GuardIO l (a1 -> a2 -> a3 -> IO r) (a1 -> a2 -> a3 -> LIO l r)
instance GuardIO l (a1 -> a2 -> IO r) (a1 -> a2 -> LIO l r)
instance GuardIO l (a1 -> IO r) (a1 -> LIO l r)
instance GuardIO l (IO r) (LIO l r)
instance (Label l, Show t) => ShowTCB (LObj l t)
instance LabelOf LObj


-- | Mutable reference in the <a>LIO</a> monad. As with other objects in
--   LIO, mutable references have an associated label that is used to
--   impose restrictions on its operations. In fact, labeled references
--   (<a>LIORef</a>s) are simply labeled <a>IORef</a>s with read and write
--   access restricted according to the label. This module is analogous to
--   <a>Data.IORef</a>, but the operations take place in the <a>LIO</a>
--   monad.
module LIO.LIORef

-- | An <tt>LIORef</tt> is an <tt>IORef</tt> with an associated, fixed
--   label. The restriction to an immutable label comes from the fact that
--   it is possible to leak information through the label itself, since we
--   wish to allow <tt>LIORef</tt> to be an instance of <tt>LabelOf</tt>.
--   Of course, you can create an <tt>LIORef</tt> of <tt>Labeled</tt> to
--   get a limited form of flow-sensitivity.
type LIORef l a = LObj l (IORef a)

-- | Create a new reference with a particularlabel. The label specified
--   must be between the thread's current label and clearance, as enforced
--   by <a>guardAlloc</a>.
newLIORef :: Label l => l -> a -> LIO l (LIORef l a)

-- | Same as <a>newLIORef</a> except <tt>newLIORefP</tt> takes privileges
--   which make the comparison to the current label more permissive, as
--   enforced by <a>guardAllocP</a>.
newLIORefP :: PrivDesc l p => Priv p -> l -> a -> LIO l (LIORef l a)

-- | Read the value of a labeled reference. A read succeeds only if the
--   label of the reference is below the current clearance. Moreover, the
--   current label is raised to the <a>lub</a> of the current label and the
--   reference label. To avoid failures (introduced by the <a>taint</a>
--   guard) use <tt>labelOf</tt> to check that a read will succeed.
readLIORef :: Label l => LIORef l a -> LIO l a

-- | Same as <a>readLIORef</a>, except <tt>readLIORefP</tt> takes a
--   privilege object which is used when the current label is raised (using
--   <a>taintP</a> instead of <a>taint</a>).
readLIORefP :: PrivDesc l p => Priv p -> LIORef l a -> LIO l a

-- | Write a new value into a labeled reference. A write succeeds if the
--   current label can-flow-to the label of the reference, and the label of
--   the reference can-flow-to the current clearance. Otherwise, an
--   exception is raised by the underlying <a>guardAlloc</a> guard.
writeLIORef :: Label l => LIORef l a -> a -> LIO l ()

-- | Same as <a>writeLIORef</a> except <tt>writeLIORefP</tt> takes a set of
--   privileges which are accounted for in comparing the label of the
--   reference to the current label.
writeLIORefP :: PrivDesc l p => Priv p -> LIORef l a -> a -> LIO l ()

-- | Mutate the contents of a labeled reference. The mutation is performed
--   by a a pure function, which, because of laziness, is not actually
--   evaluated until such point as a (possibly higher-labeled) thread
--   actually reads the <a>LIORef</a>. The caller of <tt>modifyLIORef</tt>
--   learns no information about the previous contents the <a>LIORef</a>.
--   For that reason, there is no need to raise the current label. The
--   <a>LIORef</a>'s label must still lie between the current label and
--   clearance, however (as enforced by <a>guardAlloc</a>).
modifyLIORef :: Label l => LIORef l a -> (a -> a) -> LIO l ()

-- | Like <a>modifyLIORef</a>, but takes a privilege argument and guards
--   execution with <a>guardAllocP</a> instead of <a>guardAlloc</a>.
modifyLIORefP :: PrivDesc l p => Priv p -> LIORef l a -> (a -> a) -> LIO l ()

-- | Atomically modifies the contents of an <a>LIORef</a>. It is required
--   that the label of the reference be above the current label, but below
--   the current clearance. Moreover, since this function can be used to
--   directly read the value of the stored reference, the computation is
--   "tainted" by the reference label (i.e., the current label is raised to
--   the <tt>join</tt> of the current and reference labels). These checks
--   and label raise are done by <a>guardWrite</a>, which will raise a
--   <a>LabelError</a> exception if any of the IFC conditions cannot be
--   satisfied.
atomicModifyLIORef :: Label l => LIORef l a -> (a -> (a, b)) -> LIO l b

-- | Same as <a>atomicModifyLIORef</a> except <tt>atomicModifyLIORefP</tt>
--   takes a set of privileges and uses <a>guardWriteP</a> instead of
--   <a>guardWrite</a>.
atomicModifyLIORefP :: PrivDesc l p => Priv p -> LIORef l a -> (a -> (a, b)) -> LIO l b


-- | This module implements labeled <a>MVar</a>s. The interface is
--   analogous to <a>Control.Concurrent.MVar</a>, but the operations take
--   place in the <a>LIO</a> monad. A labeled MVar, of type
--   <tt><a>LMVar</a> l a</tt>, is a mutable location that can be in one of
--   two states; an <a>LMVar</a> can be empty, or it can be full (with a
--   value of type <tt>a</tt>). The location is protected by a label of
--   type <tt>l</tt>. As in the case of <tt>LIORef</tt>s (see
--   <a>LIO.LIORef</a>), this label is fixed and does not change according
--   to the content placed into the location. Unlike <tt>LIORef</tt>s, most
--   operations use <a>guardWrite</a> or <a>guardWriteP</a>, reflecting the
--   fact that there is no such thing as read-only or write-only operations
--   on an <a>LMVar</a>.
--   
--   <a>LMVar</a>s can be used to build synchronization primitives and
--   communication channels (<a>LMVar</a>s themselves are single-place
--   channels). We refer to <a>Control.Concurrent.MVar</a> for the full
--   documentation on MVars.
module LIO.Concurrent.LMVar

-- | An <tt>LMVar</tt> is a labeled synchronization variable (an
--   <a>MVar</a>) that can be used by concurrent threads to communicate.
type LMVar l a = LObj l (MVar a)

-- | Create a new labeled MVar, in an empty state. Note that the supplied
--   label must be above the current label and below the current clearance.
--   An exception will be thrown by the underlying <a>guardAlloc</a> if
--   this is not the case.
newEmptyLMVar :: Label l => l -> LIO l (LMVar l a)

-- | Same as <a>newEmptyLMVar</a> except it takes a set of privileges which
--   are accounted for in comparing the label of the MVar to the current
--   label and clearance.
newEmptyLMVarP :: PrivDesc l p => Priv p -> l -> LIO l (LMVar l a)

-- | Create a new labeled MVar, in an filled state with the supplied value.
--   Note that the supplied label must be above the current label and below
--   the current clearance.
newLMVar :: Label l => l -> a -> LIO l (LMVar l a)

-- | Same as <a>newLMVar</a> except it takes a set of privileges which are
--   accounted for in comparing the label of the MVar to the current label.
newLMVarP :: PrivDesc l p => Priv p -> l -> a -> LIO l (LMVar l a)

-- | Return contents of the <a>LMVar</a>. Note that a take consists of a
--   read and a write, since it observes whether or not the <a>LMVar</a> is
--   full, and thus the current label must be the same as that of the
--   <a>LMVar</a> (of course, this is not the case when using privileges).
--   Hence, if the label of the <a>LMVar</a> is below the current
--   clearance, we raise the current label to the join of the current label
--   and the label of the MVar and read the contents of the <tt>MVar</tt>.
--   The underlying guard <a>guardWrite</a> will throw an exception if any
--   of the IFC checks fail. Finally, like <tt>MVars</tt> if the
--   <a>LMVar</a> is empty, <tt>takeLMVar</tt> blocks.
takeLMVar :: Label l => LMVar l a -> LIO l a

-- | Same as <a>takeLMVar</a> except <tt>takeLMVarP</tt> takes a privilege
--   object which is used when the current label is raised.
takeLMVarP :: PrivDesc l p => Priv p -> LMVar l a -> LIO l a

-- | Non-blocking version of <a>takeLMVar</a>. It returns <tt>Nothing</tt>
--   if the <a>LMVar</a> is empty, otherwise it returns <tt>Just</tt>
--   value, emptying the <a>LMVar</a>.
tryTakeLMVar :: Label l => LMVar l a -> LIO l (Maybe a)

-- | Same as <a>tryTakeLMVar</a>, but uses priviliges when raising current
--   label.
tryTakeLMVarP :: PrivDesc l p => Priv p -> LMVar l a -> LIO l (Maybe a)

-- | Puts a value into an <a>LMVar</a>. Note that a put consists of a read
--   and a write, since it observes whether or not the <a>LMVar</a> is
--   empty, and so the current label must be the same as that of the
--   <a>LMVar</a> (of course, this is not the case when using privileges).
--   As in the <a>takeLMVar</a> case, if the label of the <a>LMVar</a> is
--   below the current clearance, we raise the current label to the join of
--   the current label and the label of the MVar and put the value into the
--   <tt>MVar</tt>. Moreover if these IFC restrictions fail, the underlying
--   <a>guardWrite</a> throws an exception. If the <a>LMVar</a> is full,
--   <tt>putLMVar</tt> blocks.
putLMVar :: Label l => LMVar l a -> a -> LIO l ()

-- | Same as <a>putLMVar</a> except <tt>putLMVarP</tt> takes a privilege
--   object which is used when the current label is raised.
putLMVarP :: PrivDesc l p => Priv p -> LMVar l a -> a -> LIO l ()

-- | Non-blocking version of <a>putLMVar</a>. It returns <tt>True</tt> if
--   the <a>LMVar</a> was empty and the put succeeded, otherwise it returns
--   <tt>False</tt>.
tryPutLMVar :: Label l => LMVar l a -> a -> LIO l Bool

-- | Same as <a>tryPutLMVar</a>, but uses privileges when raising current
--   label.
tryPutLMVarP :: PrivDesc l p => Priv p -> LMVar l a -> a -> LIO l Bool

-- | Combination of <a>takeLMVar</a> and <a>putLMVar</a>. Read the value,
--   and just put it back. This operation is not atomic, and can can result
--   in unexpected outcomes if another thread is simultaneously calling a
--   function such as <a>putLMVar</a>, <a>tryTakeLMVarP</a>, or
--   <a>isEmptyLMVar</a> for this <a>LMVar</a>.
readLMVar :: Label l => LMVar l a -> LIO l a

-- | Same as <a>readLMVar</a> except <tt>readLMVarP</tt> takes a privilege
--   object which is used when the current label is raised.
readLMVarP :: PrivDesc l p => Priv p -> LMVar l a -> LIO l a

-- | Takes a value from an <a>LMVar</a>, puts a new value into the
--   <tt>LMvar</tt>, and returns the taken value. Like the other
--   <a>LMVar</a> operations it is required that the label of the
--   <a>LMVar</a> be above the current label and below the current
--   clearance. Moreover, the current label is raised to accommodate for
--   the observation. The underlying <a>guardWrite</a> throws an exception
--   if this cannot be accomplished. This operation is atomic iff there is
--   no other thread calling <a>putLMVar</a> for this <a>LMVar</a>.
swapLMVar :: Label l => LMVar l a -> a -> LIO l a

-- | Same as <a>swapLMVar</a> except <tt>swapLMVarP</tt> takes a privilege
--   object which is used when the current label is raised.
swapLMVarP :: PrivDesc l p => Priv p -> LMVar l a -> a -> LIO l a

-- | Check the status of an <a>LMVar</a>, i.e., whether it is empty. The
--   function succeeds if the label of the <a>LMVar</a> is below the
--   current clearance -- the current label is raised to the join of the
--   <a>LMVar</a> label and the current label.
isEmptyLMVar :: Label l => LMVar l a -> LIO l Bool

-- | Same as <a>isEmptyLMVar</a>, but uses privileges when raising current
--   label.
isEmptyLMVarP :: PrivDesc l p => Priv p -> LMVar l a -> LIO l Bool


-- | This module provides concurrency abstractions for <a>LIO</a>. The most
--   basic function, <a>forkLIO</a>, spawns a computation in a new
--   light-weight thread (analogous to <tt>forkIO</tt>).
--   
--   <a>lFork</a> spawns a forked thread that returns a result other
--   threads can wait for (using <a>lWait</a>). The label of such a
--   thread's result must be specified at the time the thread is spawned
--   with <a>lFork</a>. Should the <a>lFork</a>ed thread terminate with its
--   current label be above the specified result label, <a>lWait</a> will
--   throw an exception of type <a>ResultExceedsLabel</a> in any thread
--   waiting for the result.
--   
--   Learing that a spawned thread has terminated by catching a
--   <a>ResultExceedsLabel</a> may cause the label of the waiting thread to
--   rise, possibly above the current clearance (in which case the
--   exception cannot be caught). As an alternative, <a>timedlWait</a>
--   unconditionally kills a spawned thread if it has not terminated at an
--   observable label within a certain time period. <a>timedlWait</a> is
--   guaranteed both to terminate and not to throw exceptions that cannot
--   be caught at the current label.
module LIO.Concurrent

-- | Execute an <a>LIO</a> computation in a new lightweight thread.
forkLIO :: LIO l () -> LIO l ()

-- | A <tt>LabeledResult</tt> encapsulates a future result from a
--   computation spawned by <tt>lFork</tt> or <tt>lForkP</tt>. See
--   <a>LIO.Concurrent</a> for a description of the concurrency
--   abstractions of LIO.
data LabeledResult l a

-- | Labeled fork. <tt>lFork</tt> allows one to invoke computations that
--   would otherwise raise the current label, but without actually raising
--   the label. The computation is executed in a separate thread and writes
--   its result into a labeled result (whose label is supplied). To observe
--   the result of the computation, or if the computation has terminated,
--   one will have to call <a>lWait</a> and raise the current label. Of
--   couse, this can be postponed until the result is needed.
--   
--   <tt>lFork</tt> takes a label, which corresponds to the label of the
--   result. It is required that this label be between the current label
--   and clearance as enforced by a call to <a>guardAlloc</a>. Moreover,
--   the supplied computation must not terminate with its label above the
--   result label; doing so will result in an exception being thrown in the
--   thread reading the result.
--   
--   Note that <tt>lFork</tt> immediately returns a <a>LabeledResult</a>,
--   which is essentially a "future", or "promise". This prevents
--   timing/termination attacks in which the duration of the forked
--   computation affects the duration of the <tt>lFork</tt>.
--   
--   To guarantee that the computation has completed, it is important that
--   some thread actually touch the future, i.e., perform an <a>lWait</a>.
lFork :: Label l => l -> LIO l a -> LIO l (LabeledResult l a)

-- | Same as <a>lFork</a>, but the supplied set of priviliges are accounted
--   for when performing label comparisons.
lForkP :: PrivDesc l p => Priv p -> l -> LIO l a -> LIO l (LabeledResult l a)

-- | Error raised when a computation spawned by <tt>lFork</tt> terminates
--   with its current label above the label of the result.
data ResultExceedsLabel l
ResultExceedsLabel :: [String] -> String -> l -> Maybe l -> ResultExceedsLabel l
relContext :: ResultExceedsLabel l -> [String]
relLocation :: ResultExceedsLabel l -> String
relDeclaredLabel :: ResultExceedsLabel l -> l
relActualLabel :: ResultExceedsLabel l -> Maybe l

-- | Given a <a>LabeledResult</a> (a future), <tt>lWait</tt> returns the
--   unwrapped result (blocks, if necessary). For <tt>lWait</tt> to
--   succeed, the label of the result must be above the current label and
--   below the current clearance. Moreover, before block-reading,
--   <tt>lWait</tt> raises the current label to the join of the current
--   label and label of result. An exception is thrown by the underlying
--   <a>taint</a> if this is not the case. Additionally, if the thread
--   terminates with an exception (for example if it violates clearance),
--   the exception is rethrown by <tt>lWait</tt>. Similarly, if the thread
--   reads values above the result label, an exception is thrown in place
--   of the result.
lWait :: Label l => LabeledResult l a -> LIO l a

-- | Same as <a>lWait</a>, but uses priviliges in label checks and raises.
lWaitP :: PrivDesc l p => Priv p -> LabeledResult l a -> LIO l a

-- | Same as <a>lWait</a>, but does not block waiting for result.
trylWait :: Label l => LabeledResult l a -> LIO l (Maybe a)

-- | Same as <a>trylWait</a>, but uses priviliges in label checks and
--   raises.
trylWaitP :: PrivDesc l p => Priv p -> LabeledResult l a -> LIO l (Maybe a)

-- | Like <a>lWait</a>, with two differences. First, a timeout is specified
--   and the thread is unconditionally killed after this timeout (if it has
--   not yet returned a value). Second, if the thread's result exceeds what
--   the calling thread can observe, <tt>timedlWait</tt> consumes the whole
--   timeout and throws a <a>ResultExceedsLabel</a> exception you can catch
--   (i.e., it never raises the label above the clearance).
--   
--   Because this function can alter the result by killing a thread, it
--   requires the label of the <a>LabeledResult</a> to be both readable and
--   writable at the current label.
timedlWait :: Label l => LabeledResult l a -> Int -> LIO l a

-- | A version of <a>timedlWait</a> that takes privileges. The privileges
--   are used both to downgrade the result (if necessary), and to try
--   catching any <a>ResultExceedsLabel</a> before the timeout period (if
--   possible).
timedlWaitP :: PrivDesc l p => Priv p -> LabeledResult l a -> Int -> LIO l a


-- | Unbounded FIFO channels in the <a>LIO</a> monad. As with other objects
--   in LIO, a channel has an associated label that is used to impose
--   restrictions on its operations. In fact, labeled channels
--   (<a>LChan</a>s) are simply labeled <a>Chan</a>s with read and write
--   access restricted according to the label. This module is analogous to
--   <a>Control.Concurrent.Chan</a>, but the operations take place in the
--   <a>LIO</a> monad.
module LIO.Concurrent.LChan

-- | A <tt>LChan</tt> is a labeled channel, i.e., an unbounded FIFO
--   channel.
type LChan l a = LObj l (Chan a)

-- | Create a new labeled channel. Note that the supplied label must be
--   above the current label and below the current clearance. An exception
--   will be thrown by the underlying <a>guardAlloc</a> if this is not the
--   case.
newLChan :: Label l => l -> LIO l (LChan l a)

-- | Same as <a>newLChan</a> except it takes a set of privileges which are
--   accounted for in comparing the label of the Chan to the current label.
newLChanP :: PrivDesc l p => Priv p -> l -> LIO l (LChan l a)

-- | Read the next value from the channel. The current label is raised to
--   join of the channel label and current label. Howerver, the label of
--   the channel must be below the current clearance.
readLChan :: Label l => LChan l a -> LIO l a

-- | Same as <a>readLChan</a>, but takes a privilege object which is used
--   when the current label is raised to avoid over-taining the context.
readLChanP :: PrivDesc l p => Priv p -> LChan l a -> LIO l a

-- | Write value to the labeled channel. The label of the channel must be
--   bounded by the current label and clearance.
writeLChan :: Label l => LChan l a -> a -> LIO l ()

-- | Same as <a>writeLChan</a>, but uses privileges when comparing the
--   current label to the label of the channel.
writeLChanP :: PrivDesc l p => Priv p -> LChan l a -> a -> LIO l ()

-- | Duplicate labeled channel. The label of the channel must be bounded by
--   the current label and clearance.
dupLChan :: Label l => LChan l a -> LIO l (LChan l a)

-- | Same as <a>dupLChan</a>, but uses privileges when comparing the
--   current label to the label of the channel.
dupLChanP :: PrivDesc l p => Priv p -> LChan l a -> LIO l (LChan l a)


-- | <i>Disjunction Category Labels</i> (<a>DCLabel</a>s) are a label
--   format that encodes authority, secrecy restrictions, and integrity
--   properties using propositional logic.
--   
--   A <a>DCLabel</a> consists of two boolean formulas over
--   <a>Principal</a>s. Each formula is in conjunctive normal form,
--   represented by type <a>CNF</a>. The first <a>CNF</a>
--   (<a>dcSecrecy</a>) specifies what combinations of principals are
--   allowed to make data public. The second <a>CNF</a>
--   (<a>dcIntegrity</a>) specifies which combinations of principals have
--   endorsed the integrity of the data.
--   
--   The <a>%%</a> operator allows one to construct a <a>DCLabel</a> by
--   joining a secrecy <a>CNF</a> on the left with an integrity <a>CNF</a>
--   on the right. A <a>DCLabel</a> can also be directly constructed with
--   the constructor <a>DCLabel</a>. However, <a>%%</a> has the added
--   convenience of accepting any argument types that are instances of
--   <a>ToCNF</a>.
--   
--   For example, the following expresses data that can be exported by the
--   principal "Alice" and may have been written by anybody: <tt>"Alice"
--   <a>%%</a> <a>True</a></tt>. (<tt><a>toCNF</a> <a>True</a></tt>
--   indicates a trivially satisfiable label component, which in this case
--   means a label conveying no integrity properties.)
--   
--   A <a>CNF</a> is created using the (<a>\/</a>) and (<a>/\</a>)
--   operators. The disjunction operator (<a>\/</a>) is used to compute a
--   <a>CNF</a> equivalent to the disjunciton of two <a>Principal</a>s,
--   <tt>Strings</tt>, or <a>CNF</a>s. For example:
--   
--   <pre>
--   p1 = <a>principal</a> "p1"
--   p2 = <a>principal</a> "p2"
--   p3 = <a>principal</a> "p3"
--   e1 = p1 <a>\/</a> p2
--   e2 = e1 <a>\/</a> "p4"
--   </pre>
--   
--   Similarly, the conjunction operator (<a>/\</a>) creates a <a>CNF</a>
--   as a conjunction of <a>Principal</a>s, <a>String</a>s,
--   <a>Disjunction</a>s, or <a>CNF</a>s.
--   
--   <pre>
--   e3 = p1 <a>\/</a> p2
--   e4 = e1 <a>/\</a> "p4" <a>/\</a> p3
--   </pre>
--   
--   Note that because a <a>CNF</a> formula is stored as a conjunction of
--   <a>Disjunction</a>s, it is much more efficient to apply <a>/\</a> to
--   the result of <a>\/</a> than vice versa. It would be logical for
--   <a>/\</a> to have higher fixity than <a>\/</a>. Unfortunately, this
--   makes formulas harder to read (given the convention of AND binding
--   more tightly than OR). Hence <a>\/</a> and <a>/\</a> have been given
--   the same fixity but different associativities, preventing the two from
--   being mixed in the same expression without explicit parentheses.
--   
--   Consider the following, example:
--   
--   <pre>
--   cnf1 = ("Alice" <a>\/</a> "Bob") <a>/\</a> "Carla"
--   cnf2 = "Alice" <a>/\</a> "Carla"
--   dc1 = cnf1 <a>%%</a> cnf2
--   dc2 = "Djon" <a>%%</a> "Alice"
--   pr = PrivTCB $ "Alice" <a>/\</a> "Carla"
--   </pre>
--   
--   This will result in the following:
--   
--   <pre>
--   &gt;&gt;&gt; dc1
--   "Carla" /\ ("Alice" \/ "Bob") %% "Alice" /\ "Carla"
--   
--   &gt;&gt;&gt; dc2
--   "Djon" %% "Alice"
--   
--   &gt;&gt;&gt; canFlowTo dc1 dc2
--   False
--   
--   &gt;&gt;&gt; canFlowToP pr dc1 dc2
--   True
--   </pre>
--   
--   Because the <a>\/</a> and <a>/\</a> operators accept strings and
--   <a>Principal</a>s as well as <a>CNF</a>s, it is sometimes easy to
--   forget that strings and <a>Principal</a>s are not actually
--   <a>CNF</a>s. For example:
--   
--   <pre>
--   &gt;&gt;&gt; "Alice" /\ "Bob" `speaksFor` "Alice" \/ "Bob"
--   True
--   
--   &gt;&gt;&gt; "Alice" `speaksFor` "Alice" \/ "Bob"
--   &lt;interactive&gt;:12:21:
--       Couldn't match expected type `[Char]' with actual type `CNF'
--   </pre>
--   
--   To convert a single string or <a>Principal</a> to a <a>CNF</a>, you
--   must use the <a>toCNF</a> method:
--   
--   <pre>
--   &gt;&gt;&gt; toCNF "Alice" `speaksFor` "Alice" \/ "Bob"
--   True
--   </pre>
module LIO.DCLabel

-- | The main monad type alias to use for <a>LIO</a> computations that are
--   specific to <a>DCLabel</a>s.
type DC = LIO DCLabel

-- | <a>DCLabel</a> privileges are expressed as a <a>CNF</a> of the
--   principals whose authority is being exercised.
type DCPriv = Priv CNF

-- | An alias for <a>Labeled</a> values labeled with a <a>DCLabel</a>.
type DCLabeled = Labeled DCLabel

-- | A common default starting state, where <tt><a>lioLabel</a> =
--   <a>dcPublic</a></tt> and <tt><a>lioClearance</a> = False <a>%%</a>
--   True</tt> (i.e., the highest possible clearance).
dcDefaultState :: LIOState DCLabel

-- | Wrapper function for running <tt><a>LIO</a> <a>DCLabel</a></tt>
--   computations.
--   
--   <pre>
--   evalDC dc = <a>evalLIO</a> dc <a>dcDefaultState</a>
--   </pre>
evalDC :: DC a -> IO a

-- | <a>DCLabel</a> wrapper for <a>tryLIO</a>:
--   
--   <pre>
--   tryDC dc = <a>tryLIO</a> dc <a>dcDefaultState</a>
--   </pre>
tryDC :: DC a -> IO (Either SomeException a, LIOState DCLabel)

-- | A <tt>Principal</tt> is a primitive source of authority, represented
--   as a string. The interpretation of principal strings is up to the
--   application. Reasonable schemes include encoding user names, domain
--   names, and/or URLs in the <a>Principal</a> type.
data Principal

-- | Create a principal from a strict <a>ByteString</a>.
principalBS :: ByteString -> Principal

-- | Create a principal from a <a>String</a>. The <a>String</a> is packed
--   into a <a>ByteString</a> using <a>fromString</a>, which will almost
--   certainly give unexpected results for non-ASCII unicode code points.
principal :: String -> Principal

-- | Main DCLabel type. <tt>DCLabel</tt>s use <a>CNF</a> boolean formulas
--   over principals to express authority exercised by a combination of
--   principals. A <tt>DCLabel</tt> contains two <a>CNF</a>s. One,
--   <a>dcSecrecy</a>, specifies the minimum authority required to make
--   data with the label completely public. The second, <a>dcIntegrity</a>,
--   expresses the minimum authority that was used to endorse data with the
--   label, or, for mutable objects, the minimum authority required to
--   modify the object.
--   
--   <tt>DCLabel</tt>s are more conveniently expressed using the <a>%%</a>
--   operator, with <a>dcSecrecy</a> on the left and <a>dcIntegrity</a> on
--   the right, i.e.: <tt>(</tt><i>dcSecrecyValue</i> <a>%%</a>
--   <i>dcIntegrityValue</i><tt>)</tt>.
--   
--   <tt>DCLabel</tt>s enforce the following relations:
--   
--   <ul>
--   <li>If <tt>cnf1</tt> and <tt>cnf2</tt> are <a>CNF</a>s describing
--   authority, then <tt>cnf1 `<a>speaksFor</a>` cnf2</tt> if and only if
--   <tt>cnf1</tt> logically implies <tt>cnf2</tt> (often written <tt>cnf1
--    cnf2</tt>). For example, <tt>("A" <a>/\</a> "B") `<a>speaksFor</a>`
--   <a>toCNF</a> "A"</tt>, while <tt><a>toCNF</a> "A" `<a>speaksFor</a>`
--   ("A" <a>\/</a> "C")</tt>.</li>
--   <li>Given two <tt>DCLabel</tt>s <tt>dc1 = (s1 <a>%%</a> i1)</tt> and
--   <tt>dc2 = (s2 <a>%%</a> i2)</tt>, <tt>dc1 `<a>canFlowTo</a>` dc2</tt>
--   (often written <tt>dc1</tt>  <tt>dc2</tt>) if and only if <tt>s2
--   `<a>speaksFor</a>` s1 &amp;&amp; i1 `<a>speaksFor</a>` i2</tt>. In
--   other words, data can flow in the direction of requiring more
--   authority to make it public or removing integrity endorsements.</li>
--   <li>Given two <tt>DCLabel</tt>s <tt>dc1 = (s1 <a>%%</a> i1)</tt> and
--   <tt>dc2 = (s2 <a>%%</a> i2)</tt>, and a <tt>p::<a>CNF</a></tt>
--   representing privileges, <tt><a>canFlowToP</a> p dc1 dc2</tt> (often
--   written <tt>dc1</tt>  <tt>dc2</tt>) if and only if <tt>(p <a>/\</a>
--   s2) `<a>speaksFor</a>` s2 &amp;&amp; (p <a>/\</a> i1)
--   `<a>speaksFor</a>` i2</tt>.</li>
--   </ul>
data DCLabel
DCLabel :: !CNF -> !CNF -> DCLabel

-- | Describes the authority required to make the data public.
dcSecrecy :: DCLabel -> !CNF

-- | Describes the authority with which immutable data was endorsed, or the
--   authority required to modify mutable data.
dcIntegrity :: DCLabel -> !CNF

-- | <pre>
--   dcPublic = True %% True
--   </pre>
--   
--   This label corresponds to public data with no integrity guarantees.
--   For instance, an unrestricted Internet socket should be labeled
--   <tt>dcPublic</tt>. The significance of <tt>dcPublic</tt> is that given
--   data labeled <tt>(s %% i)</tt>, <tt>s</tt> is the exact minimum
--   authority such that <tt>(s %% i)  dcPublic</tt>, while <tt>i</tt> is
--   the exact minimum authority such that <tt>dcPublic  (s %% i)</tt>.
dcPublic :: DCLabel

-- | The primary way of creating a <a>DCLabel</a>. The secrecy component
--   goes on the left, while the integrity component goes on the right,
--   e.g.:
--   
--   <pre>
--   label = secrecyCNF %% integrityCNF
--   </pre>
--   
--   Unlike the <a>DCLabel</a> constructor, the arguments can be any
--   instance of <a>ToCNF</a>. <tt>%%</tt> has fixity:
--   
--   <pre>
--   infix 6 %%
--   </pre>
(%%) :: (ToCNF a, ToCNF b) => a -> b -> DCLabel

-- | Compute a conjunction of two <a>CNF</a>s or <a>ToCNF</a> instances.
--   
--   Has fixity:
--   
--   <pre>
--   infixr 7 /\
--   </pre>
(/\) :: (ToCNF a, ToCNF b) => a -> b -> CNF

-- | Compute a disjunction of two <a>CNF</a>s or <a>ToCNF</a> instances.
--   Note that this can be an expensive operation if the inputs have many
--   conjunctions.
--   
--   The fixity is specifically chosen so that <tt>\/</tt> and <a>/\</a>
--   cannot be mixed in the same expression without parentheses:
--   
--   <pre>
--   infixl 7 \/
--   </pre>
(\/) :: (ToCNF a, ToCNF b) => a -> b -> CNF

-- | A boolean formula in Conjunctive Normal Form. <tt>CNF</tt> is used to
--   describe <a>DCLabel</a> privileges, as well to provide each of the two
--   halves of a <a>DCLabel</a>.
data CNF

-- | As a type, a <a>CNF</a> is always a conjunction of <a>Disjunction</a>s
--   of <a>Principal</a>s. However, mathematically speaking, a single
--   <a>Principal</a> or single <a>Disjunction</a> is also a degenerate
--   example of conjunctive normal form. Class <a>ToCNF</a> abstracts over
--   the differences between these types, promoting them all to <a>CNF</a>.
class ToCNF c
toCNF :: ToCNF c => c -> CNF

-- | Extract the name of a principal as a strict <a>ByteString</a>. (Use
--   <a>show</a> to get it as a regular <a>String</a>.)
principalName :: Principal -> ByteString

-- | Represents a disjunction of <a>Principal</a>s, or one clause of a
--   <a>CNF</a>. There is generally not much need to work directly with
--   <tt>Disjunction</tt>s unless you need to serialize and de-serialize
--   them (by means of <a>dToSet</a> and <a>dFromList</a>).
data Disjunction

-- | Expose the set of <a>Principal</a>s being ORed together in a
--   <a>Disjunction</a>.
dToSet :: Disjunction -> Set Principal

-- | Convert a list of <a>Principal</a>s into a <a>Disjunction</a>.
dFromList :: [Principal] -> Disjunction

-- | A <a>CNF</a> that is always <tt>True</tt>--i.e., trivially
--   satisfiable. When <tt><a>dcSecrecy</a> = cTrue</tt>, it means data is
--   public. When <tt><a>dcIntegrity</a> = cTrue</tt>, it means data
--   carries no integrity guarantees. As a description of privileges,
--   <tt>cTrue</tt> conveys no privileges; <tt><a>canFlowToP</a> cTrue l1
--   l2</tt> is equivalent to <tt><a>canFlowTo</a> l1 l2</tt>.
--   
--   Note that <tt><a>toCNF</a> <a>True</a> = cTrue</tt>. Hence
--   <tt><a>dcPublic</a> = <a>DCLabel</a> cTrue cTrue</tt>.
cTrue :: CNF

-- | A <a>CNF</a> that is always <tt>False</tt>. If <tt><a>dcSecrecy</a> =
--   cFalse</tt>, then no combination of principals is powerful enough to
--   make the data public. For that reason, <tt>cFalse</tt> generally
--   shouldn't appear in a data label. However, it is convenient to include
--   as the <a>dcSecrecy</a> component of <a>lioClearance</a> to indicate a
--   thread may arbitrarily raise its label.
--   
--   <tt><a>dcIntegrity</a> = cFalse</tt> indicates impossibly much
--   integrity--i.e., data that no combination of principals is powerful
--   enough to modify or have created. Generally this is not a useful
--   concept.
--   
--   As a privilege description, <tt>cFalse</tt> indicates impossibly high
--   privileges (i.e., higher than could be achieved through any
--   combination of <a>Principal</a>s). <tt>cFalse `<a>speaksFor</a>`
--   p</tt> for any <a>CNF</a> <tt>p</tt>. This can be a useful concept for
--   bootstrapping privileges within the <a>DC</a> monad itself. For
--   instance, the result of <tt><a>privInit</a> cFalse</tt> can be passed
--   to fully-trusted <a>DC</a> code, which can in turn use
--   <tt>delegate</tt> to create arbitrary finite privileges to pass to
--   less privileged code.
cFalse :: CNF

-- | Convert a <a>CNF</a> to a <a>Set</a> of <a>Disjunction</a>s. Mostly
--   useful if you wish to serialize a <a>DCLabel</a>.
cToSet :: CNF -> Set Disjunction

-- | Convert a list of <a>Disjunction</a>s into a <a>CNF</a>. Mostly useful
--   if you wish to de-serialize a <a>CNF</a>.
cFromList :: [Disjunction] -> CNF
instance Typeable Principal
instance Typeable Disjunction
instance Typeable CNF
instance Typeable DCLabel
instance Ord Principal
instance Eq CNF
instance Ord CNF
instance Eq DCLabel
instance Ord DCLabel
instance PrivDesc DCLabel CNF
instance SpeaksFor CNF
instance Label DCLabel
instance ToCNF Bool
instance ToCNF [Char]
instance ToCNF Principal
instance ToCNF Disjunction
instance ToCNF (Priv CNF)
instance ToCNF CNF
instance Read DCLabel
instance Show DCLabel
instance Monoid CNF
instance Read CNF
instance Show CNF
instance Monoid Disjunction
instance Read Disjunction
instance Show Disjunction
instance Ord Disjunction
instance Eq Disjunction
instance Eq Principal
instance Read Principal
instance Show Principal


-- | Helper routines for exposing <tt>IO</tt> operations on objects with
--   mutable labels. The mutable labels are implemented by type
--   <a>MLabel</a>, and have an immutable meta-label (or "label label")
--   protecting the mutable label.
--   
--   It is reasonable to allow untrusted code to modify labels by exporting
--   a type-restricted version of <a>modifyMLObjLabelP</a>. When this
--   happens, asynchronous exceptions are sent to any other threads inside
--   <a>mblessTCB</a> or <a>mblessPTCB</a> if the new label revokes their
--   access.
module LIO.TCB.MLObj

-- | IO Object with a mutable label. By contrast with <a>LObj</a>, the
--   label on an <a>MLObj</a> can change over time. If this happens, the
--   internal <a>MLabel</a> ensures that threads accessing the object
--   receive an asynchronous exception.
data MLObj policy l object
MLObjTCB :: !(MLabel policy l) -> !object -> MLObj policy l object

-- | <tt><a>mlObjTCB</a> ll l a</tt> creates an <a>MLObj</a> wrapping some
--   <tt>IO</tt> object <tt>a</tt>. Here <tt>ll</tt> is the label on the
--   label, which remains immutable over the lifetime of the <a>MLObj</a>.
--   <tt>l</tt> is the initial value of the mutable lable.
mlObjTCB :: MLabelPolicyDefault policy => l -> l -> a -> LIO l (MLObj policy l a)

-- | Like <a>mlObjTCB</a>, but create an <a>MLObj</a> with a particular
--   policy value. Note that you don't need to use this for
--   <a>ExternalML</a> and <a>InternalML</a>, as these don't have anything
--   interesting in the policy value, only the type matters. This might be
--   useful if, for instance, you wished to design a new policy type that
--   embeds a clearance.
mlPolicyObjTCB :: policy -> l -> l -> a -> LIO l (MLObj policy l a)

-- | Modify the <a>MLabel</a> within an <a>MLObj</a>.
modifyMLObjLabelP :: (PrivDesc l p, MLabelPolicy policy l) => Priv p -> MLObj policy l a -> (l -> LIO l l) -> LIO l ()

-- | The <a>MLObj</a> equivalent of <tt>blessTCB</tt> in
--   <a>LIO.TCB.LObj#v:blessTCB</a>. Use this for conveniently providing
--   <tt>LIO</tt> versions of standard <tt>IO</tt> functions.
mblessTCB :: (LabelIO l io lio, Label l) => String -> (a -> io) -> MLObj policy l a -> lio

-- | The <a>MLObj</a> equivalent of <tt>blessPTCB</tt> in
--   <a>LIO.TCB.LObj#v:blessPTCB</a>. Use this for conveniently providing
--   <tt>LIO</tt> versions of standard <tt>IO</tt> functions.
mblessPTCB :: (LabelIO l io lio, Label l, PrivDesc l p) => String -> (a -> io) -> Priv p -> MLObj policy l a -> lio

-- | A mutable label. Consists of a static label on the label, a mutable
--   label, and a list of threads currently accessing the label. This is
--   intended to be used by privileged code implementing <tt>IO</tt>
--   abstractions with mutable labels. Routines for accessing such an
--   <tt>IO</tt> abstraction should perform tne <tt>IO</tt> from within a
--   call to <a>withMLabelP</a>, to ensure an exception is raised if
--   another thread revokes access with <a>modifyMLabelP</a>.
data MLabel policy l
MLabelTCB :: !l -> !(IORef l) -> !(MVar (Map Unique (l -> IO Bool))) -> policy -> MLabel policy l
mlLabelLabel :: MLabel policy l -> !l
mlLabel :: MLabel policy l -> !(IORef l)
mlUsers :: MLabel policy l -> !(MVar (Map Unique (l -> IO Bool)))
mlPolicy :: MLabel policy l -> policy

-- | Create an <a>MLabel</a>, performing access control checks to ensure
--   that the labels are within the range allowed given the current label
--   and clearance, and the supplied privileges.
newMLabelP :: PrivDesc l p => Priv p -> policy -> l -> l -> LIO l (MLabel policy l)

-- | Returns the immutable label that controls access to the mutable label
--   value of an <a>MLabel</a>.
labelOfMlabel :: MLabel policy l -> l

-- | Retreive a snapshot of the value of a mutable label. Of course, it may
--   already have changed by the time you process it.
readMLabelP :: PrivDesc l p => Priv p -> MLabel policy l -> LIO l l

-- | Run an action that should be protected by a mutable label. An
--   exception is thrown if the invoking thread cannot write to the mutable
--   label given the privileges. No attempt is made to adjust the current
--   label, even if doing so would make the permissions acceptable.
--   
--   Note that if the label changes after this function has been invoked,
--   an exception may be raised in the middle of the protected action.
withMLabelP :: PrivDesc l p => Priv p -> MLabel policy l -> LIO l a -> LIO l a

-- | Change the mutable label in an <a>MLabel</a>. Raises asynchronous
--   exceptions in other threads that are inside <a>withMLabelP</a> if the
--   new label revokes their access.
modifyMLabelP :: (PrivDesc l p, MLabelPolicy policy l) => Priv p -> MLabel policy l -> (l -> LIO l l) -> LIO l ()

-- | Class of objects with mutable labels.
class MLabelOf t
mLabelOf :: MLabelOf t => t policy l a -> MLabel policy l

-- | Class for <a>MLabelPolicy</a>s that don't encode any interesting
--   values. This allows <a>mlObjTCB</a> to create an <a>MLObj</a> without
--   requiring a policy argument.
class MLabelPolicyDefault policy
mlabelPolicyDefault :: MLabelPolicyDefault policy => policy

-- | Class of policies for when it is permissible to update an
--   <a>MLabel</a>.
class MLabelPolicy policy l
mlabelPolicy :: (MLabelPolicy policy l, PrivDesc l p) => policy -> p -> l -> l -> LIO l ()

-- | <a>InternalML</a> is for objects contained entirely within Haskell,
--   such as a variable. Raising the label can't cause data to leak.
data InternalML
InternalML :: InternalML

-- | <a>ExternalML</a> is for objects that communicate to the outside
--   world, where extra privileges are required since once data gets out,
--   so as to vouch for the fact that the other end of a socket won't
--   arbitrarily downgrade data.
data ExternalML
ExternalML :: ExternalML

-- | Takes a <tt><tt>liftIO</tt></tt>-like function and an <tt>IO</tt>
--   function of an arbitrary number of arguments (up to 10). Applies the
--   arguments to the <tt>IO</tt> function, then passed the result to its
--   argument funciton to transform it into an <tt>LIO</tt> function.
class LabelIO l io lio | l io -> lio
labelIO :: LabelIO l io lio => (forall r. IO r -> LIO l r) -> io -> lio
instance Typeable InternalML
instance Typeable ExternalML
instance Typeable2 MLabel
instance Typeable3 MLObj
instance Show InternalML
instance Show ExternalML
instance LabelIO l (a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> a8 -> a9 -> a10 -> IO r) (a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> a8 -> a9 -> a10 -> LIO l r)
instance LabelIO l (a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> a8 -> a9 -> IO r) (a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> a8 -> a9 -> LIO l r)
instance LabelIO l (a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> a8 -> IO r) (a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> a8 -> LIO l r)
instance LabelIO l (a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> IO r) (a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> a7 -> LIO l r)
instance LabelIO l (a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> IO r) (a1 -> a2 -> a3 -> a4 -> a5 -> a6 -> LIO l r)
instance LabelIO l (a1 -> a2 -> a3 -> a4 -> a5 -> IO r) (a1 -> a2 -> a3 -> a4 -> a5 -> LIO l r)
instance LabelIO l (a1 -> a2 -> a3 -> a4 -> IO r) (a1 -> a2 -> a3 -> a4 -> LIO l r)
instance LabelIO l (a1 -> a2 -> a3 -> IO r) (a1 -> a2 -> a3 -> LIO l r)
instance LabelIO l (a1 -> a2 -> IO r) (a1 -> a2 -> LIO l r)
instance LabelIO l (a1 -> IO r) (a1 -> LIO l r)
instance LabelIO l (IO r) (LIO l r)
instance MLabelOf MLObj
instance MLabelPolicyDefault ExternalML
instance MLabelPolicy ExternalML l
instance MLabelPolicyDefault InternalML
instance MLabelPolicy InternalML l


-- | This is the main module to be included by code using the Labeled IO
--   (LIO) library. This module exports the core library (documented in
--   <a>LIO.Core</a>), with support for labels and privileges (documented
--   in <a>LIO.Label</a>) and labeled values (documented in
--   <a>LIO.Labeled</a>).
--   
--   Certain symbols in the LIO library, particularly those in
--   <a>LIO.Exception</a>, use the same names as their <a>IO</a>
--   equivalents in the system libraries. Hence main modules consisting
--   mostly of <a>IO</a> code that simply need to run <a>LIO</a> code
--   should import <a>LIO.Run</a> (or <a>LIO.DCLabel</a>) to avoid
--   polluting their namespaces.
--   
--   Most code will need to use a particular label format, which needs to
--   be imported separately. Hence, a typical set of imports for an
--   untrusted LIO module is:
--   
--   <pre>
--   import <a>LIO</a>
--   import <a>LIO.DCLabel</a>
--   </pre>
module LIO
