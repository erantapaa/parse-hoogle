-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A Haskell neo4j client
--   
@package hypher
@version 0.1.5


-- | Module to handle <a>Graph</a> objects. These have information about a
--   group of nodes, relationships, and information about labels per node
--   and nodes per label. Notice a graph can have relationships and at the
--   same time not have some of the nodes of those relationships, see the
--   section called handling orphaned relationships. This is so because
--   commands in a batch might retrieve relationships but might not create
--   or retrieve their respective nodes.
module Database.Neo4j.Graph
data Graph
type LabelSet = HashSet Label

-- | Create an empty graph
empty :: Graph

-- | Add a node to the graph
addNode :: Node -> Graph -> Graph

-- | Whether a node is present in the graph
hasNode :: NodeIdentifier a => a -> Graph -> Bool

-- | Delete a node from the graph
deleteNode :: NodeIdentifier a => a -> Graph -> Graph

-- | Get a list with all the nodes in the graph
getNodes :: Graph -> [Node]

-- | Get a node in the graph
getNode :: NodeIdentifier a => a -> Graph -> Maybe Node

-- | Get outgoing relationships from a node
getNodeFrom :: NodeIdentifier a => a -> Graph -> Maybe [Relationship]

-- | Get incoming relationships from a node
getNodeTo :: NodeIdentifier a => a -> Graph -> Maybe [Relationship]

-- | Get a list with all the relationships in the graph
getRelationships :: Graph -> [Relationship]

-- | Whether a relationship is present in the graph
hasRelationship :: RelIdentifier a => a -> Graph -> Bool

-- | Add a relationship to the graph
addRelationship :: Relationship -> Graph -> Graph

-- | Delete a relationship from the graph
deleteRelationship :: RelIdentifier a => a -> Graph -> Graph

-- | Get the "node from" from a relationship
getRelationshipNodeFrom :: Relationship -> Graph -> Maybe Node

-- | Get the "node to" from a relationship
getRelationshipNodeTo :: Relationship -> Graph -> Maybe Node

-- | Get a relationship in the graph
getRelationship :: RelIdentifier a => a -> Graph -> Maybe Relationship

-- | Get relationships missing their "from" node
getOrphansFrom :: Graph -> [Relationship]

-- | Get relationships missing their "to" node
getOrphansTo :: Graph -> [Relationship]

-- | Remove all relationships with a missing node
cleanOrphanRelationships :: Graph -> Graph

-- | Set the properties of a node or relationship in the graph, if not
--   present it won't do anything
setProperties :: EntityIdentifier a => a -> Properties -> Graph -> Graph

-- | Set a property of a node or relationship in the graph, if not present
--   it won't do anything
setProperty :: EntityIdentifier a => a -> Text -> PropertyValue -> Graph -> Graph

-- | Delete all the properties of a node or relationship, if the entity is
--   not present it won't do anything
deleteProperties :: EntityIdentifier a => a -> Graph -> Graph

-- | Delete a property of a node or relationship, if the entity is not
--   present it won't do anything
deleteProperty :: EntityIdentifier a => a -> Text -> Graph -> Graph

-- | Set what labels a node has
setNodeLabels :: NodeIdentifier a => a -> [Label] -> Graph -> Graph

-- | Add a label to a node
addNodeLabel :: NodeIdentifier a => a -> Label -> Graph -> Graph

-- | Get the labels of a node
getNodeLabels :: NodeIdentifier a => a -> Graph -> LabelSet

-- | Remove a label from a node
deleteNodeLabel :: NodeIdentifier a => a -> Label -> Graph -> Graph

-- | Filter the nodes of a graph
nodeFilter :: (Node -> Bool) -> Graph -> Graph

-- | Filter the relationships of a graph
relationshipFilter :: (Relationship -> Bool) -> Graph -> Graph

-- | Add two graphs resulting in a graph with all the nodes, labels and
--   relationships of both | If a node/entity is present in both the second
--   one will be chosen
union :: Graph -> Graph -> Graph

-- | Remove the nodes and relationships in the first graph that appear in
--   the second
difference :: Graph -> Graph -> Graph

-- | Have a graph that only has nodes and relationships that are present in
--   both
intersection :: Graph -> Graph -> Graph
instance Eq Graph
instance Show Graph

module Database.Neo4j.Batch
type Batch a = State BatchState a
runBatch :: Batch a -> Neo4j Graph
newtype BatchFuture a
BatchFuture :: Int -> BatchFuture a
class NodeBatchIdentifier a
class RelBatchIdentifier a
class BatchEntity a

-- | Batch operation to create a node
createNode :: Properties -> Batch (BatchFuture Node)

-- | Batch operation to get a node from the DB
getNode :: NodeBatchIdentifier a => a -> Batch (BatchFuture Node)

-- | Batch operation to delete a node
deleteNode :: NodeBatchIdentifier a => a -> Batch (BatchFuture ())

-- | Create a new relationship with a type and a set of properties
createRelationship :: (NodeBatchIdentifier a, NodeBatchIdentifier b) => RelationshipType -> Properties -> a -> b -> Batch (BatchFuture Relationship)

-- | Refresh a relationship entity with the contents in the DB
getRelationship :: RelBatchIdentifier r => r -> Batch (BatchFuture Relationship)

-- | Get the "node from" from a relationship from the DB
getRelationshipFrom :: Relationship -> Batch (BatchFuture Node)

-- | Get the "node to" from a relationship from the DB
getRelationshipTo :: Relationship -> Batch (BatchFuture Node)

-- | Delete a relationship
deleteRelationship :: RelBatchIdentifier r => r -> Batch (BatchFuture ())

-- | Get all relationships for a node
getRelationships :: NodeBatchIdentifier n => n -> Direction -> [RelationshipType] -> Batch (BatchFuture [Relationship])

-- | Set all relationship/node properties
setProperties :: BatchEntity a => a -> Properties -> Batch (BatchFuture ())

-- | Set a relationship/node property
setProperty :: BatchEntity a => a -> Text -> PropertyValue -> Batch (BatchFuture ())

-- | Delete all relationship/node properties
deleteProperties :: BatchEntity a => a -> Batch (BatchFuture ())

-- | Delete a relationship/node property
deleteProperty :: BatchEntity a => a -> Text -> Batch (BatchFuture ())

-- | Retrieve all labels for a node, if the node doesn't exist already it
--   will raise an exception | Raises Neo4jNoEntityException if the node
--   doesn't exist
getLabels :: NodeBatchIdentifier a => a -> Batch (BatchFuture [Label])

-- | Get all nodes using a label and a property
getNodesByLabelAndProperty :: Label -> Maybe (Text, PropertyValue) -> Batch (BatchFuture [Node])

-- | Add labels to a node | Raises Neo4jNoEntityException if the node
--   doesn't exist
addLabels :: NodeBatchIdentifier a => [Label] -> a -> Batch (BatchFuture ())

-- | Change node labels | Raises Neo4jNoEntityException if the node doesn't
--   exist
changeLabels :: NodeBatchIdentifier a => [Label] -> a -> Batch (BatchFuture ())

-- | Remove a label for a node | Raises Neo4jNoEntityException if the node
--   doesn't exist
removeLabel :: NodeBatchIdentifier a => Label -> a -> Batch (BatchFuture ())


-- | Module to provide Cypher support using the transactional endpoint.
--   
--   Example:
--   
--   <pre>
--   import qualified Database.Neo4j.Transactional.Cypher as T
--   
--   withConnection host port $ do
--      ...
--      res &lt;- TC.runTransaction $ do
--              -- Queries return a result with columns, rows, a list of graphs and stats
--              result &lt;- TC.cypher "CREATE (pere: PERSON {age: {age}}) CREATE (pau: PERSON {props}) \
--                                \CREATE p1 = (pere)-[:KNOWS]-&gt;(pau) RETURN pere, pau, p1, pere.age" $
--                                  M.fromList [("age", TC.newparam (78 :: Int64)),
--                                              ("props", TC.ParamProperties $ M.fromList["age" |: (99 :: Int64)])]
--              -- if any of the commands returns an error the transaction is rollbacked and leaves
--              result 2 &lt;- T.cypher "not a command" M.empty
--              void $ TC.cypher "CREATE (pep: PERSON {age: 55})" M.empty
--              -- Transactions are implicitly commited/rollbacked (in case of exception)
--              -- but can be explicitly committed and rollbacked
--              return (result, result2)
--   </pre>
module Database.Neo4j.Transactional.Cypher

-- | Type for a Cypher response with tuples containing column name and
--   their values
data Result
Result :: [Text] -> [[Value]] -> [Graph] -> Stats -> Result
cols :: Result -> [Text]
vals :: Result -> [[Value]]
graph :: Result -> [Graph]
stats :: Result -> Stats

-- | Holds the connection stats
data Stats
Stats :: Bool -> Integer -> Integer -> Integer -> Integer -> Integer -> Integer -> Integer -> Integer -> Integer -> Integer -> Integer -> Stats
containsUpdates :: Stats -> Bool
nodesCreated :: Stats -> Integer
nodesDeleted :: Stats -> Integer
propsSet :: Stats -> Integer
relsCreated :: Stats -> Integer
relsDeleted :: Stats -> Integer
lblsAdded :: Stats -> Integer
lblsRemoved :: Stats -> Integer
idxAdded :: Stats -> Integer
idxRemoved :: Stats -> Integer
constAdded :: Stats -> Integer
constRemoved :: Stats -> Integer

-- | Value for a cypher parmeter value, might be a literal, a property map
--   or a list of property maps
data ParamValue
ParamLiteral :: PropertyValue -> ParamValue
ParamProperties :: Properties -> ParamValue
ParamPropertiesArray :: [Properties] -> ParamValue

-- | We use hashmaps to represent Cypher parameters
type Params = HashMap Text ParamValue
newparam :: PropertyValueConstructor a => a -> ParamValue

-- | Default stats
emptyStats :: Stats

-- | Error code and message for a transaction error
type TransError = (Text, Text)
type Transaction a = ExceptT TransError (ReaderT Connection (StateT TransState (ResourceT IO))) a
loneQuery :: Text -> Params -> Neo4j (Either TransError Result)

-- | Run a transaction and get its final result, has an implicit commit
--   request (or rollback if an exception occurred). This implicit
--   commit/rollback will only be executed if it hasn't before because of
--   an explicit one
runTransaction :: Transaction a -> Neo4j (Either TransError a)

-- | Run a cypher query in a transaction, if an error occurs the
--   transaction will stop and rollback
cypher :: Text -> Params -> Transaction Result

-- | Rollback a transaction. After this, executing rollback, commit,
--   keepalive, cypher in the transaction will result in an exception
rollback :: Transaction ()

-- | Commit a transaction. After this, executing rollback, commit,
--   keepalive, cypher in the transaction will result in an exception
commit :: Transaction ()

-- | Send a keep alive message to an open transaction
keepalive :: Transaction ()

-- | Send a cypher query and commit at the same time, if an error occurs
--   the transaction will be rolled back. After this, executing rollback,
--   commit, keepalive, cypher in the transaction will result in an
--   exception
commitWith :: Text -> Params -> Transaction Result

-- | Rollback a transaction and stop processing it, set the message that
--   runTransaction will return as error
rollbackAndLeave :: Text -> Transaction ()

-- | True if the operation succeeded
isSuccess :: Either TransError Result -> Bool

-- | Get the result of the response or a default value
fromResult :: Result -> Either TransError Result -> Result

-- | Get the result of the response or a default value
fromSuccess :: Either TransError Result -> Result
instance Show ParamValue
instance Eq ParamValue
instance Eq Stats
instance Show Stats
instance Show Result
instance Eq Result
instance Eq CypherNode
instance Show CypherNode
instance Eq CypherRel
instance Show CypherRel
instance Eq DataElem
instance Show DataElem
instance Show Response
instance Eq Response
instance FromJSON Response
instance FromJSON Result
instance FromJSON DataElem
instance FromJSON CypherRel
instance FromJSON CypherNode
instance FromJSON Stats
instance ToJSON ParamValue


-- | Library to interact with the Neo4j REST API.
module Database.Neo4j

-- | Type for a connection
data Connection
type Hostname = ByteString
type Port = Int

-- | Create a new connection that can be manually closed with runResourceT
newConnection :: Hostname -> Port -> IO Connection

-- | Run a set of Neo4j commands in a single connection
withConnection :: Hostname -> Port -> Neo4j a -> IO a

-- | Neo4j monadic type to be able to sequence neo4j commands in a
--   connection
newtype Neo4j a
Neo4j :: (Connection -> IO a) -> Neo4j a
runNeo4j :: Neo4j a -> Connection -> IO a

-- | Type for a single value of a Neo4j property
data Val
IntVal :: Int64 -> Val
BoolVal :: Bool -> Val
TextVal :: Text -> Val
DoubleVal :: Double -> Val

-- | Wrapping type for a Neo4j single property or array of properties Using
--   these types allows type checking for only correct properties that is
--   int, double, string, boolean and single typed arrays of these, also
--   nulls are not allowed
data PropertyValue
ValueProperty :: Val -> PropertyValue
ArrayProperty :: [Val] -> PropertyValue
newval :: PropertyValueConstructor a => a -> PropertyValue

-- | This operator allows easy construction of property value types from
--   literals
(|:) :: PropertyValueConstructor a => Text -> a -> (Text, PropertyValue)

-- | We use hashmaps to represent Neo4j properties
type Properties = HashMap Text PropertyValue

-- | Shortcut for emtpy properties
emptyProperties :: HashMap Text PropertyValue

-- | Retrieve relationship/node properties from the DB, if the entity is
--   not present it will raise an exception If the entity doesn't exist it
--   will raise a Neo4jNoEntity exception
getProperties :: Entity a => a -> Neo4j Properties

-- | Get a relationship/node property If the 404 is because the parent
--   entity doesn't exist we'll raise the corresponding Neo4jNoEntity If
--   the 404 is because there is no property just return Nothing
getProperty :: Entity a => a -> Text -> Neo4j (Maybe PropertyValue)

-- | Set all relationship/node properties If the entity doesn't exist it
--   will raise a Neo4jNoEntity exception
setProperties :: Entity a => a -> Properties -> Neo4j a

-- | Set a relationship/node property If the entity doesn't exist it will
--   raise a Neo4jNoEntity exception
setProperty :: Entity a => a -> Text -> PropertyValue -> Neo4j a

-- | Delete all relationship/node properties If the entity doesn't exist it
--   will raise a Neo4jNoEntity exception
deleteProperties :: Entity a => a -> Neo4j a

-- | Delete a relationship/node property If the entity doesn't exist it
--   will raise a Neo4jNoEntity exception
deleteProperty :: Entity a => a -> Text -> Neo4j a

-- | Representation of a Neo4j node, has a location URI and a set of
--   properties
data Node

-- | Get the properties of a node
getNodeProperties :: Node -> Properties

-- | Create a new node with a set of properties
createNode :: Properties -> Neo4j Node

-- | Refresh a node entity with the contents in the DB
getNode :: NodeIdentifier a => a -> Neo4j (Maybe Node)

-- | Delete a node, if the node has relationships it will raise a
--   Neo4jNonOrphanNodeDeletion
deleteNode :: NodeIdentifier a => a -> Neo4j ()

-- | Get the ID of a node
nodeId :: Node -> ByteString
nodePath :: Node -> NodePath
runNodeIdentifier :: NodeIdentifier a => a -> ByteString
class NodeIdentifier a
getNodePath :: NodeIdentifier a => a -> NodePath
newtype NodePath
NodePath :: Text -> NodePath
runNodePath :: NodePath -> Text

-- | Type for a Neo4j relationship, has a location URI, a relationship
--   type, a starting node and a destination node
data Relationship

-- | Relationship direction
data Direction
Outgoing :: Direction
Incoming :: Direction
Any :: Direction

-- | Type for a relationship type description
type RelationshipType = Text

-- | Create a new relationship with a type and a set of properties
createRelationship :: RelationshipType -> Properties -> Node -> Node -> Neo4j Relationship

-- | Refresh a relationship entity with the contents in the DB
getRelationship :: RelIdentifier a => a -> Neo4j (Maybe Relationship)

-- | Delete a relationship
deleteRelationship :: RelIdentifier a => a -> Neo4j ()

-- | Get all relationships for a node, if the node has disappeared it will
--   raise an exception
getRelationships :: Node -> Direction -> [RelationshipType] -> Neo4j [Relationship]

-- | Get the ID of a relationship
relId :: Relationship -> ByteString
relPath :: Relationship -> RelPath

-- | Gets all relationship types in the DB
allRelationshipTypes :: Neo4j [RelationshipType]

-- | Get the properties of a relationship
getRelProperties :: Relationship -> Properties

-- | Get the type of a relationship
getRelType :: Relationship -> RelationshipType
runRelIdentifier :: RelIdentifier a => a -> ByteString

-- | Get the "node from" from a relationship from the DB | Raises
--   Neo4jNoEntityException if the node (and thus the relationship) does
--   not exist any more
getRelationshipFrom :: Relationship -> Neo4j Node

-- | Get the "node to" from a relationship from the DB | Raises
--   Neo4jNoEntityException if the node (and thus the relationship) does
--   not exist any more
getRelationshipTo :: Relationship -> Neo4j Node
class RelIdentifier a
getRelPath :: RelIdentifier a => a -> RelPath
newtype RelPath
RelPath :: Text -> RelPath
runRelPath :: RelPath -> Text
class EntityIdentifier a
getEntityPath :: EntityIdentifier a => a -> EntityPath

-- | Type for a label
type Label = Text

-- | Get all labels in the DB
allLabels :: Neo4j [Label]

-- | Retrieve all labels for a node, if the node doesn't exist already it
--   will raise an exception | Raises Neo4jNoEntityException if the node
--   doesn't exist
getLabels :: Node -> Neo4j [Label]

-- | Get all nodes using a label and a property
getNodesByLabelAndProperty :: Label -> Maybe (Text, PropertyValue) -> Neo4j [Node]

-- | Add labels to a node | Raises Neo4jNoEntityException if the node
--   doesn't exist
addLabels :: [Label] -> Node -> Neo4j ()

-- | Change node labels | Raises Neo4jNoEntityException if the node doesn't
--   exist
changeLabels :: [Label] -> Node -> Neo4j ()

-- | Remove a label for a node | Raises Neo4jNoEntityException if the node
--   doesn't exist
removeLabel :: Label -> Node -> Neo4j ()

-- | Type for an index
data Index
Index :: Label -> [Text] -> Index
indexLabel :: Index -> Label
indexProperties :: Index -> [Text]

-- | Creates an index for a label and a property
createIndex :: Label -> Text -> Neo4j Index

-- | Gets all indexes for a label
getIndexes :: Label -> Neo4j [Index]

-- | Drop and index
dropIndex :: Label -> Text -> Neo4j ()

-- | Exceptions this library can raise
data Neo4jException
Neo4jHttpException :: String -> Neo4jException
Neo4jNonOrphanNodeDeletionException :: ByteString -> Neo4jException
Neo4jNoEntityException :: ByteString -> Neo4jException
Neo4jUnexpectedResponseException :: Status -> Neo4jException
Neo4jNoSuchProperty :: Text -> Neo4jException
Neo4jBatchException :: ByteString -> Neo4jException
Neo4jParseException :: String -> Neo4jException
TransactionEndedExc :: Neo4jException
