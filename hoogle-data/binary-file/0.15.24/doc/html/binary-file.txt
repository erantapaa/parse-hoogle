-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | read/write binary file
--   
--   See example directory's sample code.
--   
--   <pre>
--   runghc -XQuasiQuotes -XTypeFamilies -XFlexibleInstances exam.hs some.bmp
--   </pre>
--   
--   exam.hs:
--   
--   <pre>
--   import File.Binary
--   import File.Binary.Instances
--   import File.Binary.Instances.LittleEndian
--   import System.Environment
--   import Data.ByteString.Lazy as BSL
--   
--   main = do
--   [inf] &lt;- getArgs
--     cnt &lt;- BS.readFile inf
--   let Right (bmp, rest) = fromBinary () cnt :: (Bitmap, String)
--   print bmp
--   
--   instance Field (Int, Int, Int) where
--      type FieldArgument (Int, Int, Int) = ()
--      fromBinary _ s = do
--          (b, rest) &lt;- fromBinary 1 s
--          (g, rest') &lt;- fromBinary 1 rest
--          (r, rest'') &lt;- fromBinary 1 rest' in
--          return ((b, g, r), snd $ getBytes 1 1 rest'')
--      toBinary _ (b, g, r) = do
--          b' &lt;- toBinary 1 b
--          g' &lt;- toBinary 1 g
--          r' &lt;- toBinary 1 r
--          return $ concatBinary [b', g', r', makeBinary $ BSL.singleton 0]
--   
--   [binary|
--   
--   Bitmap
--   
--   deriving Show
--   
--   2: "BM"
--   4: file_size
--   2: 0
--   2: 0
--   4: offset
--   
--   4: 40
--   4: width
--   4: height
--   2: 1
--   2: bits_per_pixel
--   4: compression
--   4: image_size
--   4: resolutionH
--   4: resolutionV
--   4: color_num
--   4: important_color_num
--   replicate color_num ()[OPENBRACKET][(Int, Int, Int)][CLOSEBRACKET]: colors
--   replicate image_size ()[OPENBRACKET]String[CLOSEBRACKET]: image
--   
--   |]
--   </pre>
@package binary-file
@version 0.15.24

module File.Binary.Instances.LittleEndian
instance Field Integer
instance Field Word32
instance Field Int

module File.Binary.Instances.BigEndian
instance Field Word32
instance Field Int
instance Field Integer

module File.Binary.Instances.LSB0
data BitsInt
bitsInt :: BitsInt -> Int
instance Show BitsInt
instance Field BitsInt
instance Num BitsInt
instance Eq BitsInt
instance Field Bool

module File.Binary.Instances.MSB0
data BitsInt
instance Show BitsInt
instance Field BitsInt
instance Num BitsInt
instance Eq BitsInt
instance Field Bool

module File.Binary.Instances
instance Binary ByteString
instance Binary ByteString
instance Binary String
instance Field r => Field [r]
instance Field Word8
instance Field Char
instance Field ByteString
instance Field ByteString

module File.Binary
class Field f where type family FieldArgument f fromBits a ([], b) = second ([],) `liftM` fromBinary a b fromBits _ _ = error "fromBits: not bytes (1 byte = 8 bits)" consToBits a f ([], b) = do { ret <- (`mappend` b) <$> toBinary a f; return ([], ret) } consToBits _ _ _ = fail "consToBits: not bytes (1 byte = 8 bits)" fromBinary a b = do { ret <- fromBits a ([], b); case ret of { (f, ([], rest)) -> return (f, rest) _ -> fail "fromBinary: not bytes (1 byte = 8 bits)" } } toBinary a f = do { ret <- consToBits a f ([], mempty); case ret of { ([], bin) -> return bin _ -> fail "toBinary: not bytes (1 byte = 8 bits)" } }
fromBinary :: (Field f, Binary b, Applicative m, Monad m) => FieldArgument f -> b -> m (f, b)
toBinary :: (Field f, Binary b, Applicative m, Monad m) => FieldArgument f -> f -> m b
fromBits :: (Field f, Binary b, Applicative m, Monad m) => FieldArgument f -> AddBits b -> m (f, AddBits b)
consToBits :: (Field f, Binary b, Applicative m, Monad m) => FieldArgument f -> f -> AddBits b -> m (AddBits b)
class (Eq b, Monoid b) => Binary b where getBytes 0 b = ("", b) getBytes n b = let (h, t) = unconsByte b (r, b') = getBytes (n - 1) t in (h `cons'` r, b') spanBytes p b | b == makeBinary "" = ("", b) | p h = let (ret, rest) = spanBytes p t in (h `cons'` ret, rest) | otherwise = ("", b) where (h, t) = unconsByte b
getBytes :: Binary b => Int -> b -> (ByteString, b)
spanBytes :: Binary b => (Word8 -> Bool) -> b -> (ByteString, b)
unconsByte :: Binary b => b -> (Word8, b)
makeBinary :: Binary b => ByteString -> b
binary :: QuasiQuoter
readBinaryFile :: FilePath -> IO String
writeBinaryFile :: FilePath -> String -> IO ()
