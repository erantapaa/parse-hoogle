-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Discrete constraint satisfaction problem (CSP) solvers.
--   
--   Constraint satisfaction problem (CSP) solvers
@package csp
@version 1.0

module Control.Monad.CSP

-- | Create a variable with the given domain
mkDV :: [a] -> CSP r (DV r a)

-- | Assert a unary constraint.
constraint1 :: (a -> Bool) -> DV r1 a -> CSP r ()

-- | Assert a binary constraint with arc consistency.
constraint2 :: (a -> t1 -> Bool) -> DV t a -> DV t t1 -> CSP r ()

-- | Assert an n-ary constraint with arc consistency. One day this will
--   allow for a heterogeneous list of variables, but at the moment they
--   must all be of the same type.
constraint :: ([a] -> Bool) -> [DV r1 a] -> CSP r ()

-- | Return a single solution to the CSP. <a>solveCSP</a> running with
--   <a>oneValueT</a>
oneCSPSolution :: CSPResult a1 => CSP (Result a1) a1 -> Result a1

-- | Return all solutions to the CSP. <a>solveCSP</a> running with
--   <a>allValuesT</a>
allCSPSolutions :: CSPResult a1 => CSP (Result a1) a1 -> [Result a1]

-- | Solve the given CSP. The CSP solver is a nondeterministic function in
--   IO and this is the generic interface which specifies how the
--   nondeterministic computation should be carried out.
solveCSP :: CSPResult a1 => (AmbT r IO (Result a1) -> IO a) -> CSP r a1 -> a

-- | This extracts results from a CSP.
class CSPResult a where type family Result a
result :: CSPResult a => a -> IO (Result a)

-- | Lift an IO computation into the CSP monad. CSPs are only in IO
--   temporarily.
csp :: IO x -> CSP r x

-- | Extract the current domain of a variable.
domain :: DV t t1 -> IO [t1]

-- | Extract the current constraints of a variable.
demons :: DV r a -> IO [Constraint r]

-- | Is the variable currently bound?
isBound :: DV t t1 -> IO Bool

-- | Compute the size of the current domain of variable.
domainSize :: DV t t1 -> IO Int

-- | This performs a side-effect, writing to the given IORef but records
--   this in the nondeterministic computation so that it can be undone when
--   backtracking.
localWriteIORef :: IORef a -> a -> AmbT r IO ()

-- | Retrieve the current binding of a variable.
binding :: DV t b -> IO b

-- | Add a constraint to the given variable.
addConstraint :: DV r1 a -> Constraint r1 -> CSP r ()

-- | The low-level function out of which constraints are constructed. It
--   modifies the domain of a variable.
restrictDomain :: DV r a -> ([a] -> IO [a]) -> AmbT r IO ()
data DV r a
DV :: IORef [a] -> IORef [Constraint r] -> DV r a
dvDomain :: DV r a -> IORef [a]
dvConstraints :: DV r a -> IORef [Constraint r]
data DVContainer r
DVContainer :: AmbT r IO Bool -> AmbT r IO () -> AmbT r IO () -> DVContainer r
dvcIsBound :: DVContainer r -> AmbT r IO Bool
dvcConstraints :: DVContainer r -> AmbT r IO ()
dvcABinding :: DVContainer r -> AmbT r IO ()
type Constraint r = AmbT r IO ()
data CSP r x
CSP :: (IORef [DVContainer r] -> IO x) -> CSP r x
unCSP :: CSP r x -> IORef [DVContainer r] -> IO x
instance CSPResult a => CSPResult [a]
instance (CSPResult a, CSPResult b) => CSPResult (a, b)
instance CSPResult (DV r a)
instance Monad (CSP r)
