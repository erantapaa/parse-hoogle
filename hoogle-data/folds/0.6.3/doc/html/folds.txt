-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Beautiful Folding
--   
@package folds
@version 0.6.3

module Data.Fold.Internal

-- | Reversed '[]'
data SnocList a
Snoc :: (SnocList a) -> a -> SnocList a
Nil :: SnocList a
data SnocList1 a
Snoc1 :: (SnocList1 a) -> a -> SnocList1 a
First :: a -> SnocList1 a
data List1 a
Cons1 :: a -> (List1 a) -> List1 a
Last :: a -> List1 a

-- | Strict <a>Maybe</a>
data Maybe' a
Nothing' :: Maybe' a
Just' :: !a -> Maybe' a
maybe' :: b -> (a -> b) -> Maybe' a -> b

-- | Strict Pair
data Pair' a b
Pair' :: !a -> !b -> Pair' a b

-- | A reified <a>Monoid</a>.
newtype N a s
N :: a -> N a s
runN :: N a s -> a

-- | The shape of a <a>foldMap</a>
data Tree a
Zero :: Tree a
One :: a -> Tree a
Two :: (Tree a) -> (Tree a) -> Tree a
data Tree1 a
Bin1 :: (Tree1 a) -> (Tree1 a) -> Tree1 a
Tip1 :: a -> Tree1 a
newtype An a
An :: a -> An a
data Box a
Box :: a -> Box a
instance Typeable SnocList
instance Typeable SnocList1
instance Typeable Maybe'
instance Typeable N
instance Typeable Tree
instance Typeable Pair'
instance Typeable An
instance Typeable Box
instance Eq a => Eq (SnocList a)
instance Ord a => Ord (SnocList a)
instance Show a => Show (SnocList a)
instance Read a => Read (SnocList a)
instance Data a => Data (SnocList a)
instance Eq a => Eq (SnocList1 a)
instance Ord a => Ord (SnocList1 a)
instance Show a => Show (SnocList1 a)
instance Read a => Read (SnocList1 a)
instance Data a => Data (SnocList1 a)
instance Eq a => Eq (Maybe' a)
instance Ord a => Ord (Maybe' a)
instance Show a => Show (Maybe' a)
instance Read a => Read (Maybe' a)
instance Data a => Data (Maybe' a)
instance Eq a => Eq (N a s)
instance Ord a => Ord (N a s)
instance Show a => Show (N a s)
instance Read a => Read (N a s)
instance (Data a, Data s) => Data (N a s)
instance Eq a => Eq (Tree a)
instance Ord a => Ord (Tree a)
instance Show a => Show (Tree a)
instance Read a => Read (Tree a)
instance Data a => Data (Tree a)
instance (Eq a, Eq b) => Eq (Pair' a b)
instance (Ord a, Ord b) => Ord (Pair' a b)
instance (Show a, Show b) => Show (Pair' a b)
instance (Read a, Read b) => Read (Pair' a b)
instance (Data a, Data b) => Data (Pair' a b)
instance Eq a => Eq (An a)
instance Ord a => Ord (An a)
instance Show a => Show (An a)
instance Read a => Read (An a)
instance Data a => Data (An a)
instance Eq a => Eq (Box a)
instance Ord a => Ord (Box a)
instance Show a => Show (Box a)
instance Read a => Read (Box a)
instance Data a => Data (Box a)
instance Traversable Tree1
instance Foldable Tree1
instance Functor Tree1
instance Traversable List1
instance Foldable List1
instance Functor List1
instance Traversable Box
instance Foldable Box
instance Functor Box
instance Traversable An
instance Foldable An
instance Functor An
instance (Monoid a, Monoid b) => Monoid (Pair' a b)
instance Traversable Tree
instance Foldable Tree
instance Functor Tree
instance Reifies s (a -> a -> a, a) => Monoid (N a s)
instance Foldable Maybe'
instance Traversable SnocList1
instance Foldable SnocList1
instance Functor SnocList1
instance Traversable SnocList
instance Foldable SnocList
instance Functor SnocList

module Data.Fold.Class
class Choice p => Scan p where prefix1 = prefix . An postfix1 p = postfix p . An run1 = run . An
prefix1 :: Scan p => a -> p a b -> p a b
postfix1 :: Scan p => p a b -> a -> p a b
run1 :: Scan p => a -> p a b -> b
interspersing :: Scan p => a -> p a b -> p a b
class Scan p => Folding p where prefix = prefixOf folded postfix = postfixOf folded run = runOf folded
prefix :: (Folding p, Foldable t) => t a -> p a b -> p a b
prefixOf :: Folding p => Fold s a -> s -> p a b -> p a b
postfix :: (Folding p, Foldable t) => p a b -> t a -> p a b
postfixOf :: Folding p => Fold s a -> p a b -> s -> p a b
run :: (Folding p, Foldable t) => t a -> p a b -> b
runOf :: Folding p => Fold s a -> s -> p a b -> b
filtering :: Folding p => (a -> Bool) -> p a b -> p a b

-- | Lift a <a>Folding</a> into a <a>Prism</a>.
--   
--   This acts like a generalized notion of "costrength", when applied to a
--   <a>Folding</a>, causing it to return the left-most value that fails to
--   match the Prism, or the result of accumulating rewrapped in the
--   <a>Prism</a> if everything matches.
--   
--   <pre>
--   &gt;&gt;&gt; run [Left 1, Left 2, Left 3] $ beneath _Left $ R id (+) 0
--   Left 6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; run [Left 1, Right 2, Right 3] $ beneath _Left $ R id (+) 0
--   Right 2
--   </pre>
--   
--   <pre>
--   beneath :: Prism s t a b -&gt; p a b -&gt; p s t
--   beneath :: Iso s t a b   -&gt; p a b -&gt; p s t
--   </pre>
beneath :: Profunctor p => Optic p Identity s t a b -> p a b -> p s t

module Data.Fold.L

-- | A Moore Machine
data L a b
L :: (r -> b) -> (r -> a -> r) -> r -> L a b

-- | Construct a Moore machine from a state valuation and transition
--   function
unfoldL :: (s -> (b, a -> s)) -> s -> L a b
instance ComonadApply (L a)
instance Apply (L a)
instance Extend (L a)
instance MonadZip (L a)
instance Monad (L a)
instance Bind (L a)
instance Applicative (L a)
instance Comonad (L a)
instance Functor (L a)
instance Choice L
instance Profunctor L
instance Folding L
instance Scan L

module Data.Fold.L'

-- | A strict left fold / strict Moore machine
data L' a b
L' :: (r -> b) -> (r -> a -> r) -> r -> L' a b

-- | Construct a strict Moore machine from a state valuation and transition
--   function
unfoldL' :: (s -> (b, a -> s)) -> s -> L' a b
instance ComonadApply (L' a)
instance Apply (L' a)
instance Extend (L' a)
instance MonadZip (L' a)
instance Monad (L' a)
instance Bind (L' a)
instance Applicative (L' a)
instance Comonad (L' a)
instance Functor (L' a)
instance Choice L'
instance Profunctor L'
instance Folding L'
instance Scan L'

module Data.Fold.L1

-- | A Mealy Machine
data L1 a b
L1 :: (c -> b) -> (c -> a -> c) -> (a -> c) -> L1 a b
instance ArrowChoice L1
instance Choice L1
instance Strong L1
instance Profunctor L1
instance Arrow L1
instance Category L1
instance Semigroupoid L1
instance MonadZip (L1 a)
instance Monad (L1 a)
instance Applicative (L1 a)
instance Apply (L1 a)
instance Pointed (L1 a)
instance Functor (L1 a)
instance Scan L1

module Data.Fold.L1'

-- | A strict Mealy Machine
data L1' a b
L1' :: (c -> b) -> (c -> a -> c) -> (a -> c) -> L1' a b
instance ArrowChoice L1'
instance Choice L1'
instance Strong L1'
instance Profunctor L1'
instance Arrow L1'
instance Category L1'
instance Semigroupoid L1'
instance Monad (L1' a)
instance Applicative (L1' a)
instance Apply (L1' a)
instance Pointed (L1' a)
instance Functor (L1' a)
instance Scan L1'


-- | Unlike <a>L</a> and <a>R</a> this <a>Comonad</a> is based on a
--   <tt>(-&gt;) r</tt> <a>Comonad</a> for a <tt>Monoid</tt> <tt>r</tt>
--   rather than than on the <tt><tt>Store</tt> r</tt> <a>Comonad</a>.
module Data.Fold.M

-- | A <a>foldMap</a> caught in amber. a.k.a. a monoidal reducer
data M a b
M :: (m -> b) -> (a -> m) -> (m -> m -> m) -> m -> M a b
instance ComonadApply (M a)
instance Apply (M a)
instance Extend (M a)
instance MonadZip (M a)
instance Monad (M a)
instance Bind (M a)
instance Applicative (M a)
instance Comonad (M a)
instance Functor (M a)
instance Choice M
instance Profunctor M
instance Folding M
instance Scan M

module Data.Fold.M1

-- | A semigroup reducer
data M1 a b
M1 :: (m -> b) -> (a -> m) -> (m -> m -> m) -> M1 a b
instance ArrowChoice M1
instance Choice M1
instance Strong M1
instance Profunctor M1
instance Arrow M1
instance Category M1
instance Semigroupoid M1
instance MonadZip (M1 a)
instance Monad (M1 a)
instance Applicative (M1 a)
instance Apply (M1 a)
instance Pointed (M1 a)
instance Functor (M1 a)
instance Scan M1

module Data.Fold.R

-- | right folds / a reversed Moore machine
data R a b
R :: (r -> b) -> (a -> r -> r) -> r -> R a b
instance ComonadApply (R a)
instance Apply (R a)
instance Extend (R a)
instance Applicative (R a)
instance MonadZip (R a)
instance Monad (R a)
instance Bind (R a)
instance Comonad (R a)
instance Functor (R a)
instance Choice R
instance Profunctor R
instance Folding R
instance Scan R

module Data.Fold.R1

-- | A reversed Mealy machine
data R1 a b
R1 :: (c -> b) -> (a -> c -> c) -> (a -> c) -> R1 a b
instance ArrowChoice R1
instance Choice R1
instance Strong R1
instance Profunctor R1
instance Arrow R1
instance Category R1
instance Semigroupoid R1
instance MonadZip (R1 a)
instance Monad (R1 a)
instance Applicative (R1 a)
instance Apply (R1 a)
instance Pointed (R1 a)
instance Functor (R1 a)
instance Scan R1


module Data.Fold
class Choice p => Scan p where prefix1 = prefix . An postfix1 p = postfix p . An run1 = run . An
prefix1 :: Scan p => a -> p a b -> p a b
postfix1 :: Scan p => p a b -> a -> p a b
run1 :: Scan p => a -> p a b -> b
interspersing :: Scan p => a -> p a b -> p a b
class Scan p => Folding p where prefix = prefixOf folded postfix = postfixOf folded run = runOf folded
prefix :: (Folding p, Foldable t) => t a -> p a b -> p a b
prefixOf :: Folding p => Fold s a -> s -> p a b -> p a b
postfix :: (Folding p, Foldable t) => p a b -> t a -> p a b
postfixOf :: Folding p => Fold s a -> p a b -> s -> p a b
run :: (Folding p, Foldable t) => t a -> p a b -> b
runOf :: Folding p => Fold s a -> s -> p a b -> b
filtering :: Folding p => (a -> Bool) -> p a b -> p a b

-- | Lift a <a>Folding</a> into a <a>Prism</a>.
--   
--   This acts like a generalized notion of "costrength", when applied to a
--   <a>Folding</a>, causing it to return the left-most value that fails to
--   match the Prism, or the result of accumulating rewrapped in the
--   <a>Prism</a> if everything matches.
--   
--   <pre>
--   &gt;&gt;&gt; run [Left 1, Left 2, Left 3] $ beneath _Left $ R id (+) 0
--   Left 6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; run [Left 1, Right 2, Right 3] $ beneath _Left $ R id (+) 0
--   Right 2
--   </pre>
--   
--   <pre>
--   beneath :: Prism s t a b -&gt; p a b -&gt; p s t
--   beneath :: Iso s t a b   -&gt; p a b -&gt; p s t
--   </pre>
beneath :: Profunctor p => Optic p Identity s t a b -> p a b -> p s t

-- | A Mealy Machine
data L1 a b
L1 :: (c -> b) -> (c -> a -> c) -> (a -> c) -> L1 a b

-- | A strict Mealy Machine
data L1' a b
L1' :: (c -> b) -> (c -> a -> c) -> (a -> c) -> L1' a b

-- | A semigroup reducer
data M1 a b
M1 :: (m -> b) -> (a -> m) -> (m -> m -> m) -> M1 a b

-- | A reversed Mealy machine
data R1 a b
R1 :: (c -> b) -> (a -> c -> c) -> (a -> c) -> R1 a b

-- | A Moore Machine
data L a b
L :: (r -> b) -> (r -> a -> r) -> r -> L a b

-- | A strict left fold / strict Moore machine
data L' a b
L' :: (r -> b) -> (r -> a -> r) -> r -> L' a b

-- | A <a>foldMap</a> caught in amber. a.k.a. a monoidal reducer
data M a b
M :: (m -> b) -> (a -> m) -> (m -> m -> m) -> m -> M a b

-- | right folds / a reversed Moore machine
data R a b
R :: (r -> b) -> (a -> r -> r) -> r -> R a b
class AsRM1 p where asM1 = asM1 . asR1 asR1 = asR1 . asM1
asM1 :: AsRM1 p => p a b -> M1 a b
asR1 :: AsRM1 p => p a b -> R1 a b
class AsRM1 p => AsL1' p where asL1' = asL1' . asL'
asL1' :: AsL1' p => p a b -> L1' a b
class AsRM1 p => AsRM p where asM = asM . asR asR = asR . asM
asM :: AsRM p => p a b -> M a b
asR :: AsRM p => p a b -> R a b
class (AsRM p, AsL1' p) => AsL' p
asL' :: AsL' p => p a b -> L' a b
instance AsL' L
instance AsL' L'
instance AsL1' L'
instance AsL1' L
instance AsL1' L1
instance AsL1' L1'
instance AsRM L'
instance AsRM L
instance AsRM M
instance AsRM R
instance AsRM1 R1
instance AsRM1 R
instance AsRM1 M1
instance AsRM1 M
instance AsRM1 L1'
instance AsRM1 L1
instance AsRM1 L'
instance AsRM1 L
