-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Combinators for parsing indentation based syntatic structures
--   
--   This package exposes two modules,
--   <a>Text.ParserCombinators.Parsec.IndentParser</a> and
--   <a>Text.ParserCombinators.Parsec.IndentToken</a>, for constructing
--   parser combinators for indentation based syntactic structures. The
--   former exports the basic indentation parser combinators and the later
--   together with <a>Text.ParserCombinators.Parsec.Language</a> and
--   <a>Text.ParserCombinators.Parsec.Token</a> can be used to define
--   tokenisers for programming languages.
@package IndentParser
@version 0.2.1


-- | A module to construct indentation aware parsers. Many programming
--   language have indentation based syntax rules e.g. python and Haskell.
--   This module exports combinators to create such parsers.
--   
--   The input source can be thought of as a list of tokens. Abstractly
--   each token occurs at a line and a column and has a width. The column
--   number of a token measures is indentation. If t1 and t2 are two tokens
--   then we say that indentation of t1 is more than t2 if the column
--   number of occurrence of t1 is greater than that of t2.
--   
--   Currently this module supports two kind of indentation based syntactic
--   structures which we now describe:
--   
--   <ul>
--   <li><i>Block</i> A block of indentation <i>c</i> is a sequence of
--   tokens with indentation at least <i>c</i>. Examples for a block is a
--   where clause of Haskell with no explicit braces.</li>
--   <li><i>Line fold</i> A line fold starting at line <i>l</i> and
--   indentation <i>c</i> is a sequence of tokens that start at line
--   <i>l</i> and possibly continue to subsequent lines as long as the
--   indentation is greater than <i>c</i>. Such a sequence of lines need to
--   be <i>folded</i> to a single line. An example is MIME headers. Line
--   folding based binding separation is used in Haskell as well.</li>
--   </ul>
--   
--   The module exports three combinators are <tt><a>indentParser</a></tt>,
--   <tt><a>block</a></tt> and <tt><a>lineFold</a></tt>. To construct
--   parsers for indentation based grammars one typically applies the
--   <tt><a>indentParser</a></tt>. A block can then be parsed using the
--   combinator <tt><a>block</a></tt> and a line fold using
--   <tt><a>lineFold</a></tt>. Generating indentation aware tokenisers
--   could be tricky. Given a language description via the
--   <tt>Text.ParserCombinators.Parsec.Language.LanguageDef</tt> record use
--   module
--   <tt><tt>Text.ParserCombinators.Parsec.IndentParser.Token</tt></tt> to
--   generate its tokeiser (this will apply <tt><a>indentParser</a></tt> on
--   all tokenisers and then the user can forget about
--   <tt><a>indentParser</a></tt> combinator).
--   
--   Warning:
--   
--   Internally indentations are implemented using Parser states. If one
--   wants to use parser states as well then use the <a>getState</a> and
--   <a>setState</a> functions exported by this module instead of those
--   exported from the parsec library. Also use the <a>parseTest</a> and
--   <a>runParser</a> function exported from this module instead of the one
--   exported from Parsec.
module Text.ParserCombinators.Parsec.IndentParser

-- | An indentation aware parser.
type IndentParser tok st a = GenParser tok (st, IndentState) a
type IndentCharParser st a = IndentParser Char st a

-- | The mode of the indentation parser.
data IndentMode

-- | Ignore indentation
NoIndent :: IndentMode

-- | In block mode
Block :: IndentMode

-- | In line fold mode
LineFold :: IndentMode

-- | The combinator indentParser makes its input parser indentation aware.
--   Usually one would want to make all the tokenisers indentation aware.
indentParser :: IndentParser tok st a -> IndentParser tok st a

-- | The parser <tt><a>noIndent</a> p</tt> runs <tt>p</tt> ignoring any
--   indentation based structure. This can be used to parse for example an
--   explicitly braced where clause in Haskell.
noIndent :: IndentParser tok st a -> IndentParser tok st a

-- | The parser <tt><a>block</a> p</tt> parses a <i>block</i> of
--   <tt>p</tt>.
block :: IndentParser tok st a -> IndentParser tok st a

-- | The parser <tt>lineFold p</tt> parses a folded line of <tt>p</tt>.
lineFold :: IndentParser tok st a -> IndentParser tok st a

-- | The parser <tt>betweenOrBlock open close p</tt> parses <tt>p</tt>
--   between <tt>open</tt> and <tt>close</tt>. If open is matched
--   <tt>p</tt> is parsed in <a>NoIndent</a> mode otherwise a block
--   <tt>p</tt> is parsed in <a>Block</a> mode. For eg. the parser for
--   parsing haskell where clause would look like
--   
--   <pre>
--   whereClause = do reserved where; betweenOrBlock bindings
--   </pre>
betweenOrBlock :: IndentParser tok st open -> IndentParser tok st close -> IndentParser tok st a -> IndentParser tok st a

-- | Similar to betweenOrBlock but uses lineFold instead of block.
betweenOrLineFold :: IndentParser tok st open -> IndentParser tok st close -> IndentParser tok st a -> IndentParser tok st a

-- | Gets the current user state.
getState :: IndentParser tok st st

-- | Sets the user state.
setState :: st -> IndentParser tok st ()

-- | The most generic way to run an IndentParser. Use <tt>parseTest</tt>
--   for testing your parser instead.
runParser :: IndentParser tok st a -> st -> IndentMode -> SourceName -> [tok] -> Either ParseError a

-- | Runs the given parser on a given input stream and returns either the
--   result or parse error.
parse :: IndentParser tok () a -> SourceName -> [tok] -> Either ParseError a

-- | Like <tt><a>parse</a></tt> but use the contents of <tt>SourceName</tt>
--   as the input tokens.
parseFromFile :: IndentCharParser () a -> SourceName -> IO (Either ParseError a)

-- | Runs the input parser on the given stream and prints the result.
--   Useful for testing parsers.
parseTest :: Show a => IndentParser tok () a -> [tok] -> IO ()


-- | A module for constructing indentation aware tokeniser that can be used
--   in conjuction with
--   <tt><tt>Text.ParserCombinators.Parsec.Token</tt></tt>. All the
--   combinator takes a
--   <tt><tt>Text.ParserCombinators.Parsec.Token.TokenParser</tt></tt> as
--   its first argument. For every field <tt>foo</tt> of
--   <tt><tt>Text.ParserCombinators.Parsec.Token.TokenParser</tt></tt> this
--   module exports a combinator <tt>foo</tt>. To define a tokeniser for an
--   indentation based language a user first defines the appropriate
--   <tt><tt>Text.ParserCombinators.Parsec.Language.LanguageDef</tt></tt>
--   record, applies the combinator
--   <tt><tt>Text.ParserCombinators.Parsec.Token.makeTokenParser</tt></tt>
--   to get a
--   <tt><tt>Text.ParserCombinators.Parsec.Token.TokenParser</tt></tt>
--   record say <tt>tokP</tt> and then, instead of selecting the field
--   <tt>foo</tt> of <tt>tokP</tt>, applies the combinator <tt>foo</tt>
--   exported from this module to <tt>tokP</tt>. The semantics of the
--   combinator <tt>foo</tt> is essentially same as that of the field
--   <tt>foo</tt> of
--   <tt><tt>Text.ParserCombinators.Parsec.Token.TokenParser</tt></tt> but
--   the returned parsers are indentation aware. Apart from these there are
--   certain new combinators that are defined specifically for parsing
--   certain indentation based syntactic constructs. (We have not defined
--   squares use brackets instead)
--   
--   There are two important classes of parser combinator exported by this
--   module:
--   
--   <ul>
--   <li><i>Grouping Parser Combinator</i> A grouping parser combinator
--   takes as input a parser say <tt>p</tt> and returns a parser that
--   parses <tt>p</tt> between two <i>grouping delimiters</i>. There are
--   three flavours of grouping parsers: <tt>foo</tt>, <tt>fooOrBlock</tt>
--   and <tt>fooOrLineFold</tt> where <tt>foo</tt> can be one of
--   <tt>angles</tt>, <tt>braces</tt>, <tt>parens</tt>, <tt>brackets</tt>.
--   To illustrate we take <tt>foo</tt> to be <tt>braces</tt>. The parser
--   <tt><a>braces</a> tokP p</tt> parses <tt>p</tt> delimited by '{' and
--   '}'. In this case <tt>p</tt> does not care about indentation (i.e. the
--   parser <tt>p</tt> is run in <tt><a>NoIndent</a></tt> mode). The parser
--   <tt><a>bracesOrBlock</a> tokP p</tt> is like <tt>braces tokP p</tt>
--   but if no explicit delimiting braces are given parses <tt>p</tt>
--   within an indented block. Similarly <tt><a>bracesOrLineFold</a> tokP
--   p</tt> parses <tt>p</tt> between '{' and '}' and uses line fold when
--   no explicit braces are given. These can be two varients can be defined
--   as follows</li>
--   </ul>
--   
--   <pre>
--   bracesOrBlock tokP p    = braces tokP p &lt;|&gt; block p
--   bracesOrLineFold tokP p = braces tokP p &lt;|&gt; lineFold p
--   </pre>
--   
--   <ul>
--   <li><i>Seperator Parser Combinator</i> A seperator parser combinator
--   takes as input a parser say <tt>p</tt> and returns a parser that
--   parses a list of <tt>p</tt> seperated by a seperator. The module
--   exports the combinators <tt>fooSep</tt>, <tt>fooSep1</tt>,
--   <tt>fooOrNewLineSep</tt> and <tt>fooOrNewLineSep1</tt>, where
--   <tt>foo</tt> is either <tt>semi</tt> (in which case the seperator is a
--   semicolon ';') or <tt>comma</tt> (in which case the seperator is a
--   comma ',').</li>
--   </ul>
--   
--   To illustrate the use of this module we now give, as an incomplete
--   example, a parser that parses a where clause in Haskell which
--   illustrates the use of this module.
--   
--   <pre>
--   import qualified Text.ParserCombinators.Parsec.Language as L
--   import qualified Text.ParserCombinators.Parsec.Toke as T
--   import qualified Text.ParserCombinator.Parsec.IndentToken as IT
--   </pre>
--   
--   <pre>
--   tokP = T.makeTokenParser L.haskellDef
--   semiOrNewLineSep = IT.semiOrNewLineSep tokP
--   bracesOrBlock = IT.bracesOrBlock tokP
--   identifier = IT.identifier tokP
--   ....
--   symbol = IT.symbol tokP
--   </pre>
--   
--   <pre>
--    binding = semiOrNewLineSep bind
--    bind    = do id &lt;- identifier
--                 symbol (char '=')
--                 e &lt;- expr
--                 return (id,e)
--   whereClause = do reserved "where"; braceOrBlock binding
--   </pre>
module Text.ParserCombinators.Parsec.IndentParser.Token
type IndentCharParser st a = IndentParser Char st a
type TokenParser st = TokenParser (st, IndentState)

-- | Indentation aware parser to match a valid identifier of the language.
identifier :: TokenParser st -> IndentCharParser st String

-- | Indentation aware parser to match a reserved word of the language.
reserved :: TokenParser st -> String -> IndentCharParser st ()

-- | The parser <tt>reserved tokP keyword</tt> parses the reserved word
--   keyword. The string keyword should have been declared as a reserved
--   word in the
--   <tt><tt>Text.ParserCombinator.Parserc.Language.LanguageDef</tt></tt>
--   -record.
operator :: TokenParser st -> IndentCharParser st String

-- | Indentation aware parser to match a reserved operator of the language.
reservedOp :: TokenParser st -> String -> IndentCharParser st ()

-- | Indentation aware parser to match a character literal (the syntax is
--   assumend to be that of Hasekell which matches that of most programming
--   language).
charLiteral :: TokenParser st -> IndentCharParser st Char

-- | Indentation aware parser to match a string literal (the syntax is
--   assumend to be that of Hasekell which matches that of most programming
--   language).
stringLiteral :: TokenParser st -> IndentCharParser st String

-- | Indentation aware parser to match a natural number.
natural :: TokenParser st -> IndentCharParser st Integer

-- | Indentation aware parser to match an integer.
integer :: TokenParser st -> IndentCharParser st Integer

-- | Indentation aware parser to match a floating point number.
float :: TokenParser st -> IndentCharParser st Double

-- | Indentation aware parser to match either a natural number or Floating
--   point number.
naturalOrFloat :: TokenParser st -> IndentCharParser st (Either Integer Double)

-- | Indentation aware parser to match an integer in decimal.
decimal :: TokenParser st -> IndentCharParser st Integer

-- | Indentation aware parser to match an integer in hexadecimal.
hexadecimal :: TokenParser st -> IndentCharParser st Integer

-- | Indentation aware parser to match an integer in ocatal.
octal :: TokenParser st -> IndentCharParser st Integer

-- | Matches a semicolon and returns ';'.
semi :: TokenParser st -> IndentCharParser st String

-- | Matches a colon and returns <a>:</a>.
colon :: TokenParser st -> IndentCharParser st String

-- | Matches a dot and returns <a>.</a>
dot :: TokenParser st -> IndentCharParser st String

-- | Matches a comma and returns <a>,</a>.
comma :: TokenParser st -> IndentCharParser st String

-- | Creates a lexeme parser. The resultant parser skips trailing spaces
--   and is indentation aware.
lexeme :: TokenParser st -> IndentCharParser st a -> IndentCharParser st a

-- | Indentation aware parser that is equvalent to string str.
symbol :: TokenParser st -> String -> IndentCharParser st String

-- | The parser whiteSpace skips spaces and comments. This does not care
--   about indentation as skipping spaces should be done irrespective of
--   the indentation.
whiteSpace :: TokenParser st -> IndentCharParser st ()

-- | Given an indentation aware parser <tt>p</tt> as argument <tt>semiSep
--   tokP</tt> returns a parser that parses zero or more occurances of
--   <tt>p</tt> seperated by semicolon (';')
semiSep :: TokenParser st -> IndentCharParser st a -> IndentCharParser st [a]

-- | Given an indentation aware parser <tt>p</tt> as argument <tt>semiSep1
--   tokP</tt> returns a parser that parses one or more occurances of
--   <tt>p</tt> seperated by semicolon (';')
semiSep1 :: TokenParser st -> IndentCharParser st a -> IndentCharParser st [a]

-- | Given an indentation aware parser <tt>p</tt> as argument <tt>commaSep
--   tokP</tt> returns a parser that parses zero or more occurances of
--   <tt>p</tt> seperated by comma (',')
commaSep :: TokenParser st -> IndentCharParser st a -> IndentCharParser st [a]

-- | Given an indentation aware parser <tt>p</tt> as argument <tt>commaSep1
--   tokP</tt> returns a parser that parses one or more occurances of
--   <tt>p</tt> seperated by comma (',')
commaSep1 :: TokenParser st -> IndentCharParser st a -> IndentCharParser st [a]

-- | Given an indentation aware parser <tt>p</tt> as argument
--   <tt>semiOrNewLineSep tokP</tt> returns a parser that parses zero or
--   more occurances of <tt>p</tt> seperated by either semicolons (';') or
--   newlines. To seperate multiple occurance of <tt>p</tt> in the same
--   line use an explicit semicolon (';').
semiOrNewLineSep :: TokenParser st -> IndentCharParser st a -> IndentCharParser st [a]

-- | Given an indentation aware parser <tt>p</tt> as argument
--   <tt>semiOrNewLineSep1 tokP</tt> returns a parser that parses one or
--   more occurances of <tt>p</tt> seperated by either semicolons (';') or
--   newline. To seperate multiple occurance of <tt>p</tt> in the same line
--   use an explicit semicolon (';').
semiOrNewLineSep1 :: TokenParser st -> IndentCharParser st a -> IndentCharParser st [a]

-- | Given an indentation aware parser <tt>p</tt> as argument
--   <tt>commaOrNewLineSep tokP</tt> returns a parser that parses zero or
--   more occurances of <tt>p</tt> seperated by either comma (',') or
--   newlines. To seperate multiple occurance of <tt>p</tt> in the same
--   line use an explicit comma (',').
commaOrNewLineSep :: TokenParser st -> IndentCharParser st a -> IndentCharParser st [a]

-- | Given an indentation aware parser <tt>p</tt> as argument
--   <tt>commaOrNewLineSep1 tokP</tt> returns a parser that parses one or
--   more occurances of <tt>p</tt> seperated by either comma (',') or
--   newline. To seperate multiple occurance of <tt>p</tt> in the same line
--   use an explicit comma (',').
commaOrNewLineSep1 :: TokenParser st -> IndentCharParser st a -> IndentCharParser st [a]

-- | The parser <tt>parens tokP p</tt> parses <tt>p</tt> between '(' and
--   ')'. The parser <tt>p</tt> does not care about indentation i.e.
--   <tt>p</tt> is run in <tt><a>NoIndent</a></tt> mode.
parens :: TokenParser st -> IndentCharParser st a -> IndentCharParser st a

-- | Similar to <tt><a>parens</a></tt> but when no explicit '(' and ')' are
--   given, groups <tt>p</tt> by block indentation.
parensOrBlock :: TokenParser st -> IndentCharParser st a -> IndentCharParser st a

-- | Similar to <tt><a>parens</a></tt> but when no explicit '(' and ')' are
--   given, groups <tt>p</tt> by a line fold.
parensOrLineFold :: TokenParser st -> IndentCharParser st a -> IndentCharParser st a

-- | The parser <tt>braces tokP p</tt> parses <tt>p</tt> between '{' and
--   '}'. The parser <tt>p</tt> does not care about indentation i.e.
--   <tt>p</tt> is run in <tt><a>NoIndent</a></tt> mode.
braces :: TokenParser st -> IndentCharParser st a -> IndentCharParser st a

-- | Similar to <tt><a>braces</a></tt> but when no explicit '{' and '}' are
--   given, groups <tt>p</tt> by block indentation.
bracesOrBlock :: TokenParser st -> IndentCharParser st a -> IndentCharParser st a

-- | Similar to <tt><a>braces</a></tt> but when no explicit '{' and '}' are
--   given, groups <tt>p</tt> by a line fold.
bracesOrLineFold :: TokenParser st -> IndentCharParser st a -> IndentCharParser st a

-- | The parser <tt>angles tokP p</tt> parses <tt>p</tt> between angles.
--   The parser <tt>p</tt> does not care about indentation i.e. <tt>p</tt>
--   is run in <tt><a>NoIndent</a></tt> mode.
angles :: TokenParser st -> IndentCharParser st a -> IndentCharParser st a

-- | Similar to <tt><a>angles</a></tt> but when no explicit angles are
--   given, groups <tt>p</tt> by block indentation.
anglesOrBlock :: TokenParser st -> IndentCharParser st a -> IndentCharParser st a

-- | Similar to <tt><a>angles</a></tt> but when no explicit angles are
--   given, groups <tt>p</tt> by a line fold.
anglesOrLineFold :: TokenParser st -> IndentCharParser st a -> IndentCharParser st a

-- | The parser <tt>brackets tokP p</tt> parses <tt>p</tt> between '[' and
--   ']'. The parser <tt>p</tt> does not care about indentation i.e.
--   <tt>p</tt> is run in <tt><a>NoIndent</a></tt> mode.
brackets :: TokenParser st -> IndentCharParser st a -> IndentCharParser st a

-- | Similar to <tt><a>brackets</a></tt> but when no explicit '[' and ']'
--   are given, groups <tt>p</tt> by block indentation.
bracketsOrBlock :: TokenParser st -> IndentCharParser st a -> IndentCharParser st a

-- | Similar to <tt><a>brackets</a></tt> but when no explicit '[' and ']'
--   are given, groups <tt>p</tt> by a line fold.
bracketsOrLineFold :: TokenParser st -> IndentCharParser st a -> IndentCharParser st a
