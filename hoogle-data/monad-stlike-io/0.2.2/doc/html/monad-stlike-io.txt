-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | ST-like monad capturing variables to regions and supporting IO.
--   
--   ST-like monad capturing variables to regions and supporting IO.
@package monad-stlike-io
@version 0.2.2


-- | Unsafe interface for implementators. Purposefully not documented.
module Control.Monad.STLike.Unsafe

module Control.Monad.STLike.IO

-- | Monad for scoped IO computations The underlying monad must be strict
--   here.
type IOS s t = STLike IO s t

-- | Lift IO computations into IOS. liftIO also works.
io :: IO t -> IOS s t

-- | Run an IOS computation in the IO monad.
runIOS :: (forall s. IOS s t) -> IO t

-- | Regioned variables. A regioned variable is <i>safe</i> i.e. no
--   references to it may escape the current IOS.
data Regioned s t

-- | Run a computation on regioned data and return the result in a strict
--   fashion.
runRegion :: (NotShared ty, RegionMonad m region s) => Regioned s ty -> STLike m region ty

-- | Regions a value. Synonym for <i>return</i>.
region :: t -> Regioned s t
unfoldRegion :: Foldable t => Regioned s (t a) -> [Regioned s a]
class STLikeImpl m => RegionMonad m :: (* -> *) region s
data (:<) a b

-- | Use a resource with IOS. Like <i>bracket</i>.
withRIOR :: IOS o resource -> (resource -> IOS o ()) -> (forall s. Regioned (s :< o) resource -> IOS (s :< o) result) -> IOS o result
try :: IOS s t -> IOS s (Either SomeException t)

-- | Create a ByteString representing the pointer and length. No copying
--   done, O(1).
rbsFromPtr :: Ptr a -> Int -> IOS s (Regioned s ByteString)

-- | Create a copy of a regioned ByteString as a normal ByteString. O(n).
rbsToBS :: RegionMonad m s reg => Regioned s ByteString -> STLike m reg ByteString

-- | Use a regioned ByteString as a pointer. O(1). The pointer points to
--   the region contents, so be cafeful with it.
withRbsPtr :: Regioned s ByteString -> (Ptr any -> Int -> IOS s t) -> IOS s t

-- | Lookup inside a Map with a regioned ByteString.
rbsMapLookup :: (RegionMonad m s reg, Ord key) => Regioned s key -> Map key value -> STLike m reg (Maybe value)
instance [overlap ok] MonadIO (STLike IO s)
instance [overlap ok] STLikeImpl IO
