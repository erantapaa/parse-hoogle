-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Data.Map with multiple, unique keys
--   
@package data-map-multikey
@version 0.0.1.2


-- | Data.Map with multiple, unique keys. IxSet without the Sets.
--   
--   <pre>
--   module Main where
--   
--   import Data.Map.MultiKey
--   import Data.Typeable
--   import Prelude hiding (lookup, null)
--   
--   data Record = Record
--     { rIntKey :: Int
--     , rStringKey :: String
--     , rData :: String
--     } deriving (Show, Typeable)
--   
--   instance MultiKeyable Record where 
--     empty = MultiKey [key rIntKey, key rStringKey]
--   
--   records :: [Record]
--   records =
--     [ Record 1 "key 1" "data 1"
--     , Record 20 "key 20" "data 20"
--     , Record 3 "key 3" "data 3"
--     ]
--   
--   mk :: MultiKey Record
--   mk = fromList records
--   </pre>
--   
--   <pre>
--   &gt; lookup (1::Int) mk
--   Just (Record {rIntKey = 1, rStringKey = "key 1", rData = "data 1"})
--   it :: Maybe Record
--   </pre>
--   
--   <pre>
--   &gt; lookup "key 20" mk
--   Just (Record {rIntKey = 20, rStringKey = "key 20", rData = "data 20"})
--   it :: Maybe Record
--   </pre>
--   
--   <pre>
--   &gt; lookup 2.0 mk
--   *** Exception: MultiKey: there is no key of type Double in MultiKey Record
--   </pre>
module Data.Map.MultiKey
data MultiKey a
MultiKey :: [Key a] -> MultiKey a
class MultiKeyable a
empty :: MultiKeyable a => MultiKey a
delete :: a -> MultiKey a -> MultiKey a
deleteKey :: (Typeable a, Typeable k) => k -> MultiKey a -> MultiKey a
fromList :: MultiKeyable a => [a] -> MultiKey a
insert :: a -> MultiKey a -> MultiKey a
insertList :: MultiKeyable a => [a] -> MultiKey a -> MultiKey a
key :: (Typeable k, Ord k) => (a -> k) -> Key a
lookup :: (Typeable a, Typeable k) => k -> MultiKey a -> Maybe a
null :: MultiKey a -> Bool
toList :: MultiKey a -> [a]
updateKey :: (Typeable a, Typeable k) => k -> a -> MultiKey a -> MultiKey a
instance Typeable Key
instance Typeable MultiKey
