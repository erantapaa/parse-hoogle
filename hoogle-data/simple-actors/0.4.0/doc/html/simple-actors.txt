-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A library for more structured concurrent programming, based
on the Actor Model
--   
--   simple-actors is an EDSL-style library for writing more structured
--   concurrent programs, based on the Actor Model. Computations are
--   structured as <a>Behaviors</a> which take a single input value,
--   perform some <a>Action</a>s, and return the Behavior to process the
--   next input message it receives.
--   
--   We also extend the strict actor model in various elegant ways. See
--   source for this type of discussion.
--   
--   <i>CHANGES</i>: 0.3.0 - 0.4
--   
--   <ul>
--   <li>extend <a>Control.Concurrent.Actors.spawn</a> to transparently
--   support <a>joined mailboxes</a>, i.e. join-patterns, supporting
--   synchronization between actors. <a>Control.Concurrent.Actors.spawn</a>
--   becomes polymorphic in new <a>Control.Concurrent.Actors.Sources</a>
--   class</li>
--   <li>old <tt>spawn_</tt> subsumed by polymorphic <tt>spawn</tt>, with
--   <tt>()</tt></li>
--   <li><tt>send</tt> and other send-like functions restricted to
--   Mailboxes, use <a>out</a> to convert arbitrary chans to Mailboxes</li>
--   <li>productMb, faninMb, and fanoutMb renamed
--   <a>Control.Concurrent.Actors.contraProduct</a>,
--   <a>Control.Concurrent.Actors.contraFanin</a>, and
--   <a>Control.Concurrent.Actors.contraFanout</a>, and given more general
--   types</li>
--   <li>old <tt>spawnReading</tt> removed</li>
--   </ul>
@package simple-actors
@version 0.4.0

module Control.Concurrent.Actors

-- | In the Actor Model, at each step an actor...
--   
--   <ul>
--   <li>processes a single <a>received</a> message</li>
--   <li>may <a>spawn</a> new actors</li>
--   <li>may <a>send</a> messages to other actors</li>
--   <li><a>return</a>s the <a>Behavior</a> for processing the <i>next</i>
--   message</li>
--   </ul>
--   
--   These actions take place within the <tt>Action i</tt> monad, where
--   <tt>i</tt> is the type of the input message the actor receives.
--   
--   <i>N.B.:</i> the MonadIO instance here is an abstraction leak. An
--   example of a good use of <a>liftIO</a> might be to give an
--   <tt>Action</tt> access to a source of randomness.
data Action i a

-- | An actor is created by <a>spawn</a>ing a <tt>Behavior</tt>. Behaviors
--   consist of a composed <a>Action</a> that is executed when a message is
--   <a>received</a> and returns the <tt>Behavior</tt> for processing the
--   next input.
newtype Behavior i
Receive :: Action i (Behavior i) -> Behavior i
headAction :: Behavior i -> Action i (Behavior i)

-- | Sequence two <tt>Behavior</tt>s. After the first <a>yield</a>s the
--   second takes over, discarding the message the former was processing.
--   See also the <a>Monoid</a> instance for <tt>Behavior</tt>.
--   
--   <pre>
--   b &lt;.|&gt; b' = b `mappend` constB b'
--   </pre>
(<.|>) :: Behavior i -> Behavior i -> Behavior i

-- | One can <a>send</a> a messages to a <tt>Mailbox</tt> where it will be
--   processed according to an actor's defined <a>Behavior</a>
--   
--   <pre>
--   type Joined (Mailbox a) = a
--   </pre>
data Mailbox a

-- | Convert the input side of a <tt>SplitChan</tt> to a <tt>Mailbox</tt>.
--   Useful for sending data out from an actor system via a channel created
--   in IO.
out :: SplitChan i x => i a -> Mailbox a

-- | Send a message asynchronously to an actor receiving from Mailbox. See
--   also <a>out</a> for converting other types of chans to <a>Mailbox</a>.
--   
--   <pre>
--   send b = liftIO . writeChan b
--   </pre>
send :: MonadIO m => Mailbox a -> a -> m ()

-- | A strict <a>send</a>:
--   
--   <pre>
--   send' b a = a `seq` send b a
--   </pre>
send' :: MonadIO m => Mailbox a -> a -> m ()

-- | Like <a>send</a> but supports chaining sends by returning the Mailbox.
--   Convenient for initializing an Actor with its first input after
--   spawning, e.g.
--   
--   <pre>
--   do mb &lt;- 0 &lt;-&gt; spawn foo
--   </pre>
(<->) :: MonadIO m => a -> m (Mailbox a) -> m (Mailbox a)

-- | Return the message received to start this <a>Action</a> block.
--   <i>N.B</i> the value returned here does not change between calls in
--   the same <a>Action</a>.
--   
--   <pre>
--   received = ask
--   </pre>
received :: Action i i

-- | Return <a>received</a> message matching predicate, otherwise
--   <a>yield</a>.
--   
--   <pre>
--   guardReceived p = ask &gt;&gt;= \i-&gt; guard (p i) &gt;&gt; return i
--   </pre>
guardReceived :: (i -> Bool) -> Action i i

-- | We extend the actor model to support joining (or synchronizing)
--   multiple <a>Mailbox</a>es to a single <a>Behavior</a> input type,
--   using a new class with an associated type. Functionality is best
--   explained by example:
--   
--   Spawn an actor returning it's <a>Mailbox</a>, and send it its first
--   message:
--   
--   <pre>
--   sumTuple :: Behavior (Int, Int)
--   
--   do b &lt;- spawn sumTuple
--      send b (4, 1) 
--      ...
--   </pre>
--   
--   But now we would like our <tt>sumTuple</tt> actor to receive each
--   number from a different concurrent actor:
--   
--   <pre>
--   do (b1, b2) &lt;- spawn sumTuple
--      b3 &lt;- spawn (multipliesBy2AndSendsTo b1)
--      send b3 2
--      send b2 1
--      ...
--   </pre>
--   
--   Lastly spawn an actor that starts immediately on an infinite supply of
--   <tt>()</tt>s, and supplies an endless stream of <tt>Int</tt>s to
--   <tt>sumTuple</tt>
--   
--   <pre>
--   do (b1, b2) &lt;- spawn sumTuple
--      () &lt;- spawn (sendsIntsTo b2)
--      send b1 4
--      ...
--   </pre>
class Sources s where type family Joined s

-- | Fork an actor performing the specified <a>Behavior</a>. <i>N.B.</i> an
--   actor begins execution of its <tt>headBehavior</tt> only after a
--   message becomes available to process; for sending an initial message
--   to an actor right after <a>spawn</a>ing it, (<a>&lt;|&gt;</a>) can be
--   convenient.
spawn :: (MonadIO m, Sources s) => Behavior (Joined s) -> m s

-- | Immediately give up processing an input, perhaps relinquishing the
--   input to an <a>Alternative</a> computation or exiting the actor.
--   
--   <pre>
--   yield = mzero
--   </pre>
yield :: Action i a

-- | Useful to make defining a continuing Behavior more readable as a
--   "receive block", e.g.
--   
--   <pre>
--   pairUpAndSendTo mb = Receive $ do
--       a &lt;- received
--       receive $ do
--           b &lt;- received
--           send mb (b,a)
--           return (pairUpAndSendTo mb)
--   </pre>
--   
--   Defined as:
--   
--   <pre>
--   receive = return . Receive
--   </pre>
receive :: Action i (Behavior i) -> Action i (Behavior i)
coproductMb :: Mailbox a -> Mailbox b -> Mailbox (Either a b)

-- | <pre>
--   contraProduct = contramap Left &amp;&amp;&amp; contramap Right
--   </pre>
contraProduct :: Contravariant f => f (Either a b) -> (f a, f b)
zipMb :: Mailbox a -> Mailbox b -> Mailbox (a, b)

-- | <pre>
--   contraFanin f g = contramap (f ||| g)
--   </pre>
contraFanin :: Contravariant f => (b -> a) -> (c -> a) -> f a -> f (Either b c)

-- | <pre>
--   contraFanout f g = contramap (f &amp;&amp;&amp; g)
--   </pre>
contraFanout :: Contravariant f => (a -> b) -> (a -> c) -> f (b, c) -> f a

-- | Run a <tt>Behavior ()</tt> in the main thread, returning when the
--   computation exits.
runBehavior_ :: Behavior () -> IO ()

-- | run a <a>Behavior</a> in the IO monad, taking its "messages" from the
--   list.
runBehavior :: Behavior a -> [a] -> IO ()

-- | Prints all messages to STDOUT in the order they are received,
--   <a>yield</a>-ing <i>immediately</i> after <tt>n</tt> inputs are
--   printed.
printB :: (Show s, Eq n, Num n) => n -> Behavior s

-- | Like <a>printB</a> but using <tt>putStr</tt>.
putStrB :: (Eq n, Num n) => n -> Behavior String

-- | Sends a <tt>()</tt> to the passed chan. This is useful with
--   <a>mappend</a> for signalling the end of some other <a>Behavior</a>.
--   
--   <pre>
--   signalB c = Receive (send c () &gt;&gt; yield)
--   </pre>
signalB :: Mailbox () -> Behavior i

-- | A <tt>Behavior</tt> that discard its first input, returning the passed
--   Behavior for processing subsequent inputs. Useful with
--   <a>Alternative</a> or <a>Monoid</a> compositions when one wants to
--   ignore the leftover <a>yield</a>ed message.
--   
--   <pre>
--   constB = Receive . return
--   </pre>
constB :: Behavior i -> Behavior i
instance Contravariant Mailbox
instance Functor Messages
instance Sources ()
instance (Sources a, Sources b, Sources c) => Sources (a, b, c)
instance (Sources a, Sources b, Sources c, Sources d) => Sources (a, b, c, d)
instance (Sources a, Sources b, Sources c, Sources d, Sources e) => Sources (a, b, c, d, e)
instance (Sources a, Sources b, Sources c, Sources d, Sources e, Sources f) => Sources (a, b, c, d, e, f)
instance (Sources a, Sources b, Sources c, Sources d, Sources e, Sources f, Sources g) => Sources (a, b, c, d, e, f, g)
instance (Sources a, Sources b) => Sources (a, b)
instance Sources (Mailbox a)
instance NewSplitChan Mailbox Messages
instance SplitChan Mailbox Messages
