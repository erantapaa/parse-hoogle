-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generalization of filter and catMaybes
--   
@package witherable
@version 0.1.3


module Data.Witherable

-- | Like <tt>traverse</tt>, but you can remove elements instead of
--   updating them.
--   
--   <pre>
--   <tt>traverse</tt> f ≡ <a>wither</a> (<a>fmap</a> <a>Just</a> . f)
--   </pre>
--   
--   A definition of <a>wither</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i><i>identity</i></i> <tt><a>wither</a> (<a>pure</a> . Just) ≡
--   <a>pure</a></tt></li>
--   <li><i><i>composition</i></i> <tt>Compose . fmap (<a>wither</a> f) .
--   <a>wither</a> g ≡ <a>wither</a> (Compose . fmap (<a>wither</a> f) .
--   g)</tt></li>
--   </ul>
--   
--   Parametricity implies the naturality law:
--   
--   <pre>
--   t . <a>wither</a> f = <a>wither</a> (t . f)
--   </pre>
class Traversable t => Witherable t where wither f = fmap catMaybes . traverse f mapMaybe = mapMaybeOf wither catMaybes = catMaybesOf wither filterA = filterAOf wither filter = filterOf wither
wither :: (Witherable t, Applicative f) => (a -> f (Maybe b)) -> t a -> f (t b)
mapMaybe :: Witherable t => (a -> Maybe b) -> t a -> t b
catMaybes :: Witherable t => t (Maybe a) -> t a
filterA :: (Witherable t, Applicative f) => (a -> f Bool) -> t a -> f (t a)
filter :: Witherable t => (a -> Bool) -> t a -> t a

-- | Removes duplicate elements from a list, keeping only the first
--   occurrence. This is exponentially quicker than using <a>nub</a> from
--   <a>List</a>.
ordNub :: (Witherable t, Ord a) => t a -> t a

-- | Removes duplicate elements from a list, keeping only the first
--   occurrence. This is usually faster than <a>ordNub</a>, especially for
--   things that have a slow comparion (like <a>String</a>) hashNubOf ::
--   (Witherable t, Eq a, Hashable a) =&gt; t a -&gt; t a
hashNub :: (Witherable t, Eq a, Hashable a) => t a -> t a
type FilterLike f s t a b = (a -> f (Maybe b)) -> s -> f t
type Filter s t a b = forall f. Applicative f => FilterLike f s t a b
type FilterLike' f s a = FilterLike f s s a a
type Filter' s a = forall f. Applicative f => FilterLike' f s a

-- | <a>witherOf</a> is actually <a>id</a>, but left for consistency.
witherOf :: FilterLike f s t a b -> (a -> f (Maybe b)) -> s -> f t

-- | <a>mapMaybe</a> through a filter.
mapMaybeOf :: FilterLike Identity s t a b -> (a -> Maybe b) -> s -> t

-- | <a>catMaybes</a> through a filter.
catMaybesOf :: FilterLike Identity s t (Maybe a) a -> s -> t
filterAOf :: Functor f => FilterLike' f s a -> (a -> f Bool) -> s -> f s

-- | Filter each element of a structure targeted by a <a>Filter</a>.
filterOf :: FilterLike' Identity s a -> (a -> Bool) -> s -> s

-- | Remove the duplicate elements through a filter.
ordNubOf :: Ord a => FilterLike' (State (Set a)) s a -> s -> s

-- | Remove the duplicate elements through a filter. It is often faster
--   than <a>ordNubOf</a>, especially when the comparison is expensive.
hashNubOf :: (Eq a, Hashable a) => FilterLike' (State (HashSet a)) s a -> s -> s
cloneFilter :: FilterLike (Dungeon a b) s t a b -> Filter s t a b
newtype Dungeon a b t
Dungeon :: (forall f. Applicative f => (a -> f (Maybe b)) -> f t) -> Dungeon a b t
runDungeon :: Dungeon a b t -> forall f. Applicative f => (a -> f (Maybe b)) -> f t

-- | Traversable containers which hold <a>Maybe</a> are witherable.
newtype Chipped t a
Chipped :: t (Maybe a) -> Chipped t a
getChipped :: Chipped t a -> t (Maybe a)
instance Ord (t (Maybe a)) => Ord (Chipped t a)
instance Eq (t (Maybe a)) => Eq (Chipped t a)
instance Read (t (Maybe a)) => Read (Chipped t a)
instance Show (t (Maybe a)) => Show (Chipped t a)
instance Functor t => Functor (Chipped t)
instance Foldable t => Foldable (Chipped t)
instance Traversable t => Traversable (Chipped t)
instance Traversable t => Witherable (Chipped t)
instance Applicative t => Applicative (Chipped t)
instance Witherable Seq
instance Witherable Vector
instance Witherable (Const r)
instance Witherable Proxy
instance (Eq k, Hashable k) => Witherable (HashMap k)
instance Ord k => Witherable (Map k)
instance Witherable IntMap
instance Witherable []
instance Monoid e => Witherable (Either e)
instance Witherable Maybe
instance Applicative (Dungeon a b)
instance Functor (Dungeon a b)
