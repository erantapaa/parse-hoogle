-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell implementation of the Nix language
--   
@package hnix
@version 0.2.0

module Nix.Types

-- | Atoms are values that evaluate to themselves. This means that they
--   appear in both the parsed AST (in the form of literals) and the
--   evaluated form.
data NAtom

-- | An integer. The c nix implementation currently only supports integers
--   that fit in the range of <tt>Int64</tt>.
NInt :: Integer -> NAtom

-- | The first argument of <a>NPath</a> is <a>True</a> if the path must be
--   looked up in the Nix search path. For example,
--   <tt><a>nixpkgs/pkgs</a></tt> is represented by <tt>NPath True
--   "nixpkgs/pkgs"</tt>, while <tt>foo/bar</tt> is represented by
--   <tt>NPath False "foo/bar</tt>.
NPath :: Bool -> FilePath -> NAtom
NBool :: Bool -> NAtom
NNull :: NAtom
atomText :: NAtom -> Text

-- | <a>Antiquoted</a> represents an expression that is either antiquoted
--   (surrounded by ${...}) or plain (not antiquoted).
data Antiquoted v r
Plain :: v -> Antiquoted v r
Antiquoted :: r -> Antiquoted v r

-- | Merge adjacent <a>Plain</a> values with <a>mappend</a>.
mergePlain :: Monoid v => [Antiquoted v r] -> [Antiquoted v r]

-- | Remove <a>Plain</a> values equal to <a>mempty</a>.
removePlainEmpty :: (Eq v, Monoid v) => [Antiquoted v r] -> [Antiquoted v r]
runAntiquoted :: (v -> a) -> (r -> a) -> Antiquoted v r -> a
data StringKind
DoubleQuoted :: StringKind
Indented :: StringKind

-- | A <tt>NixString</tt> is a list of things that are either a plain
--   string or an antiquoted expression. After the antiquotes have been
--   evaluated, the final string is constructed by concating all the parts.
data NString r
NString :: StringKind -> [Antiquoted Text r] -> NString r
NUri :: Text -> NString r

-- | Split a stream representing a string with antiquotes on line breaks.
splitLines :: [Antiquoted Text r] -> [[Antiquoted Text r]]

-- | Join a stream of strings containing antiquotes again. This is the
--   inverse of <a>splitLines</a>.
unsplitLines :: [[Antiquoted Text r]] -> [Antiquoted Text r]

-- | Form an indented string by stripping spaces equal to the minimal
--   indent.
stripIndent :: [Antiquoted Text r] -> NString r
escapeCodes :: [(Char, Char)]
fromEscapeCode :: Char -> Maybe Char
toEscapeCode :: Char -> Maybe Char

-- | A <tt>KeyName</tt> is something that can appear at the right side of
--   an equals sign. For example, <tt>a</tt> is a <tt>KeyName</tt> in <tt>{
--   a = 3; }</tt>, <tt>let a = 3; in ...</tt>, <tt>{}.a</tt> or <tt>{} ?
--   a</tt>.
--   
--   Nix supports both static keynames (just an identifier) and dynamic
--   identifiers. Dynamic identifiers can be either a string (e.g.: <tt>{
--   "a" = 3; }</tt>) or an antiquotation (e.g.: <tt>let a = "example"; in
--   { ${a} = 3; }.example</tt>).
--   
--   Note: There are some places where a dynamic keyname is not allowed. In
--   particular, those include:
--   
--   <ul>
--   <li>the RHS of a <tt>binding</tt> inside <tt>let</tt>: <tt>let ${"a"}
--   = 3; in ...</tt> produces a syntax error.</li>
--   <li>the attribute names of an <tt>inherit</tt>: <tt>inherit
--   ${"a"};</tt> is forbidden.</li>
--   </ul>
--   
--   Note: In Nix, a simple string without antiquotes such as
--   <tt>"foo"</tt> is allowed even if the context requires a static
--   keyname, but the parser still considers it a <a>DynamicKey</a> for
--   simplicity.
data NKeyName r
DynamicKey :: (Antiquoted (NString r) r) -> NKeyName r
StaticKey :: Text -> NKeyName r
type NSelector r = [NKeyName r]
data NOperF r
NUnary :: NUnaryOp -> r -> NOperF r
NBinary :: NBinaryOp -> r -> r -> NOperF r
data NUnaryOp
NNeg :: NUnaryOp
NNot :: NUnaryOp
data NSpecialOp
NHasAttrOp :: NSpecialOp
NSelectOp :: NSpecialOp
NAppOp :: NSpecialOp
data NBinaryOp
NEq :: NBinaryOp
NNEq :: NBinaryOp
NLt :: NBinaryOp
NLte :: NBinaryOp
NGt :: NBinaryOp
NGte :: NBinaryOp
NAnd :: NBinaryOp
NOr :: NBinaryOp
NImpl :: NBinaryOp
NUpdate :: NBinaryOp
NPlus :: NBinaryOp
NMinus :: NBinaryOp
NMult :: NBinaryOp
NDiv :: NBinaryOp
NConcat :: NBinaryOp
data NAssoc
NAssocNone :: NAssoc
NAssocLeft :: NAssoc
NAssocRight :: NAssoc
data NOperatorDef
NUnaryDef :: String -> NUnaryOp -> NOperatorDef
NBinaryDef :: NAssoc -> [(String, NBinaryOp)] -> NOperatorDef
nixOperators :: [Either NSpecialOp NOperatorDef]
data OperatorInfo
OperatorInfo :: Int -> NAssoc -> String -> OperatorInfo
precedence :: OperatorInfo -> Int
associativity :: OperatorInfo -> NAssoc
operatorName :: OperatorInfo -> String
getUnaryOperator :: NUnaryOp -> OperatorInfo
getBinaryOperator :: NBinaryOp -> OperatorInfo
getSpecialOperatorPrec :: NSpecialOp -> Int
selectOp :: OperatorInfo
hasAttrOp :: OperatorInfo
appOp :: OperatorInfo
data NSetBind
Rec :: NSetBind
NonRec :: NSetBind

-- | A single line of the bindings section of a let expression or of a set.
data Binding r
NamedVar :: (NSelector r) -> r -> Binding r
Inherit :: (Maybe r) -> [NSelector r] -> Binding r
data FormalParamSet r
FormalParamSet :: (Map Text (Maybe r)) -> FormalParamSet r

-- | <tt>Formals</tt> represents all the ways the formal parameters to a
--   function can be represented.
data Formals r
FormalName :: Text -> Formals r
FormalSet :: (FormalParamSet r) -> Formals r
FormalLeftAt :: Text -> (FormalParamSet r) -> Formals r
FormalRightAt :: (FormalParamSet r) -> Text -> Formals r
data NExprF r
NConstant :: NAtom -> NExprF r
NStr :: (NString r) -> NExprF r
NList :: [r] -> NExprF r
NSet :: NSetBind -> [Binding r] -> NExprF r
NAbs :: (Formals r) -> r -> NExprF r
NOper :: (NOperF r) -> NExprF r
NSelect :: r -> (NSelector r) -> (Maybe r) -> NExprF r
NHasAttr :: r -> (NSelector r) -> NExprF r
NApp :: r -> r -> NExprF r

-- | A <a>NSym</a> is a reference to a variable. For example, <tt>f</tt> is
--   represented as <tt>NSym "f"</tt> and <tt>a</tt> as <tt>NSym "a" in
--   </tt>f a@.
NSym :: Text -> NExprF r
NLet :: [Binding r] -> r -> NExprF r
NIf :: r -> r -> r -> NExprF r
NWith :: r -> r -> NExprF r
NAssert :: r -> r -> NExprF r
type NExpr = Fix NExprF
mkInt :: Integer -> NExpr
mkStr :: StringKind -> Text -> NExpr
mkUri :: Text -> NExpr
mkPath :: Bool -> FilePath -> NExpr
mkSym :: Text -> NExpr
mkSelector :: Text -> NSelector NExpr
mkBool :: Bool -> NExpr
mkNull :: NExpr
mkOper :: NUnaryOp -> NExpr -> NExpr
mkOper2 :: NBinaryOp -> NExpr -> NExpr -> NExpr
mkFormalSet :: [(Text, Maybe NExpr)] -> Formals NExpr
mkApp :: NExpr -> NExpr -> NExpr
mkRecSet :: [Binding NExpr] -> NExpr
mkNonRecSet :: [Binding NExpr] -> NExpr
mkLet :: [Binding NExpr] -> NExpr -> NExpr
mkList :: [NExpr] -> NExpr
mkWith :: NExpr -> NExpr -> NExpr
mkAssert :: NExpr -> NExpr -> NExpr
mkIf :: NExpr -> NExpr -> NExpr -> NExpr
mkFunction :: Formals NExpr -> NExpr -> NExpr

-- | Shorthand for producing a binding of a name to an expression.
bindTo :: Text -> NExpr -> Binding NExpr

-- | Append a list of bindings to a set or let expression. For example,
--   adding `[a = 1, b = 2]` to `let c = 3; in 4` produces `let a = 1; b =
--   2; c = 3; in 4`.
appendBindings :: [Binding NExpr] -> NExpr -> NExpr

-- | Applies a transformation to the body of a nix function.
modifyFunctionBody :: (NExpr -> NExpr) -> NExpr -> NExpr

-- | An <a>NValue</a> is the most reduced form of an <a>NExpr</a> after
--   evaluation is completed.
data NValueF r
NVConstant :: NAtom -> NValueF r
NVStr :: Text -> NValueF r
NVList :: [r] -> NValueF r
NVSet :: (Map Text r) -> NValueF r
NVFunction :: (Formals r) -> (NValue -> IO r) -> NValueF r
type NValue = Fix NValueF
valueText :: NValue -> Text
instance Typeable NAtom
instance Typeable Antiquoted
instance Typeable StringKind
instance Typeable NString
instance Typeable NKeyName
instance Typeable NUnaryOp
instance Typeable NSpecialOp
instance Typeable NBinaryOp
instance Typeable NOperF
instance Typeable NAssoc
instance Typeable NOperatorDef
instance Typeable OperatorInfo
instance Typeable NSetBind
instance Typeable Binding
instance Typeable FormalParamSet
instance Typeable Formals
instance Typeable NExprF
instance Typeable NValueF
instance Eq NAtom
instance Ord NAtom
instance Generic NAtom
instance Data NAtom
instance Show NAtom
instance (Ord v, Ord r) => Ord (Antiquoted v r)
instance (Eq v, Eq r) => Eq (Antiquoted v r)
instance Generic (Antiquoted v r)
instance (Data v, Data r) => Data (Antiquoted v r)
instance Functor (Antiquoted v)
instance (Show v, Show r) => Show (Antiquoted v r)
instance Eq StringKind
instance Ord StringKind
instance Generic StringKind
instance Data StringKind
instance Show StringKind
instance Eq r => Eq (NString r)
instance Ord r => Ord (NString r)
instance Generic (NString r)
instance Data r => Data (NString r)
instance Functor NString
instance Show r => Show (NString r)
instance Eq r => Eq (NKeyName r)
instance Ord r => Ord (NKeyName r)
instance Generic (NKeyName r)
instance Data r => Data (NKeyName r)
instance Show r => Show (NKeyName r)
instance Eq NUnaryOp
instance Ord NUnaryOp
instance Generic NUnaryOp
instance Data NUnaryOp
instance Show NUnaryOp
instance Eq NSpecialOp
instance Ord NSpecialOp
instance Generic NSpecialOp
instance Data NSpecialOp
instance Show NSpecialOp
instance Eq NBinaryOp
instance Ord NBinaryOp
instance Generic NBinaryOp
instance Data NBinaryOp
instance Show NBinaryOp
instance Eq r => Eq (NOperF r)
instance Ord r => Ord (NOperF r)
instance Generic (NOperF r)
instance Data r => Data (NOperF r)
instance Functor NOperF
instance Show r => Show (NOperF r)
instance Eq NAssoc
instance Ord NAssoc
instance Generic NAssoc
instance Data NAssoc
instance Show NAssoc
instance Eq NOperatorDef
instance Ord NOperatorDef
instance Generic NOperatorDef
instance Data NOperatorDef
instance Show NOperatorDef
instance Eq OperatorInfo
instance Ord OperatorInfo
instance Generic OperatorInfo
instance Data OperatorInfo
instance Show OperatorInfo
instance Ord NSetBind
instance Eq NSetBind
instance Generic NSetBind
instance Data NSetBind
instance Show NSetBind
instance Data r => Data (Binding r)
instance Ord r => Ord (Binding r)
instance Eq r => Eq (Binding r)
instance Functor Binding
instance Show r => Show (Binding r)
instance Eq r => Eq (FormalParamSet r)
instance Ord r => Ord (FormalParamSet r)
instance Generic (FormalParamSet r)
instance Data r => Data (FormalParamSet r)
instance Functor FormalParamSet
instance Show r => Show (FormalParamSet r)
instance Foldable FormalParamSet
instance Traversable FormalParamSet
instance Ord r => Ord (Formals r)
instance Eq r => Eq (Formals r)
instance Generic (Formals r)
instance Data r => Data (Formals r)
instance Functor Formals
instance Show r => Show (Formals r)
instance Foldable Formals
instance Traversable Formals
instance Ord r => Ord (NExprF r)
instance Eq r => Eq (NExprF r)
instance Generic (NExprF r)
instance Data r => Data (NExprF r)
instance Functor NExprF
instance Show r => Show (NExprF r)
instance Generic (NValueF r)
instance Functor NValueF
instance Datatype D1NAtom
instance Constructor C1_0NAtom
instance Constructor C1_1NAtom
instance Constructor C1_2NAtom
instance Constructor C1_3NAtom
instance Datatype D1Antiquoted
instance Constructor C1_0Antiquoted
instance Constructor C1_1Antiquoted
instance Datatype D1StringKind
instance Constructor C1_0StringKind
instance Constructor C1_1StringKind
instance Datatype D1NString
instance Constructor C1_0NString
instance Constructor C1_1NString
instance Datatype D1NKeyName
instance Constructor C1_0NKeyName
instance Constructor C1_1NKeyName
instance Datatype D1NUnaryOp
instance Constructor C1_0NUnaryOp
instance Constructor C1_1NUnaryOp
instance Datatype D1NSpecialOp
instance Constructor C1_0NSpecialOp
instance Constructor C1_1NSpecialOp
instance Constructor C1_2NSpecialOp
instance Datatype D1NBinaryOp
instance Constructor C1_0NBinaryOp
instance Constructor C1_1NBinaryOp
instance Constructor C1_2NBinaryOp
instance Constructor C1_3NBinaryOp
instance Constructor C1_4NBinaryOp
instance Constructor C1_5NBinaryOp
instance Constructor C1_6NBinaryOp
instance Constructor C1_7NBinaryOp
instance Constructor C1_8NBinaryOp
instance Constructor C1_9NBinaryOp
instance Constructor C1_10NBinaryOp
instance Constructor C1_11NBinaryOp
instance Constructor C1_12NBinaryOp
instance Constructor C1_13NBinaryOp
instance Constructor C1_14NBinaryOp
instance Datatype D1NOperF
instance Constructor C1_0NOperF
instance Constructor C1_1NOperF
instance Datatype D1NAssoc
instance Constructor C1_0NAssoc
instance Constructor C1_1NAssoc
instance Constructor C1_2NAssoc
instance Datatype D1NOperatorDef
instance Constructor C1_0NOperatorDef
instance Constructor C1_1NOperatorDef
instance Datatype D1OperatorInfo
instance Constructor C1_0OperatorInfo
instance Selector S1_0_0OperatorInfo
instance Selector S1_0_1OperatorInfo
instance Selector S1_0_2OperatorInfo
instance Datatype D1NSetBind
instance Constructor C1_0NSetBind
instance Constructor C1_1NSetBind
instance Datatype D1FormalParamSet
instance Constructor C1_0FormalParamSet
instance Datatype D1Formals
instance Constructor C1_0Formals
instance Constructor C1_1Formals
instance Constructor C1_2Formals
instance Constructor C1_3Formals
instance Datatype D1NExprF
instance Constructor C1_0NExprF
instance Constructor C1_1NExprF
instance Constructor C1_2NExprF
instance Constructor C1_3NExprF
instance Constructor C1_4NExprF
instance Constructor C1_5NExprF
instance Constructor C1_6NExprF
instance Constructor C1_7NExprF
instance Constructor C1_8NExprF
instance Constructor C1_9NExprF
instance Constructor C1_10NExprF
instance Constructor C1_11NExprF
instance Constructor C1_12NExprF
instance Constructor C1_13NExprF
instance Datatype D1NValueF
instance Constructor C1_0NValueF
instance Constructor C1_1NValueF
instance Constructor C1_2NValueF
instance Constructor C1_3NValueF
instance Constructor C1_4NValueF
instance Show f => Show (NValueF f)
instance Functor NKeyName
instance IsString (NString r)

module Nix.Parser
parseNixFile :: MonadIO m => FilePath -> m (Result NExpr)
parseNixString :: String -> Result NExpr

-- | The result of parsing. Either we succeeded or something went wrong.
data Result a :: * -> *
Success :: a -> Result a
Failure :: Doc -> Result a

module Nix.Pretty

-- | This type represents a pretty printed nix expression together with
--   some information about the expression.
data NixDoc
NixDoc :: Doc -> OperatorInfo -> NixDoc

-- | The rendered expression, without any parentheses.
withoutParens :: NixDoc -> Doc

-- | The root operator is the operator at the root of the expression tree.
--   For example, in '(a * b) + c', <a>+</a> would be the root operator. It
--   is needed to determine if we need to wrap the expression in
--   parentheses.
rootOp :: NixDoc -> OperatorInfo

-- | A simple expression is never wrapped in parentheses. The expression
--   behaves as if its root operator had a precedence higher than all other
--   operators (including function application).
simpleExpr :: Doc -> NixDoc

-- | An expression that behaves as if its root operator had a precedence
--   lower than all other operators. That ensures that the expression is
--   wrapped in parantheses in almost always, but it's still rendered
--   without parentheses in cases where parentheses are never required
--   (such as in the LHS of a binding).
leastPrecedence :: Doc -> NixDoc
appOpNonAssoc :: OperatorInfo
wrapParens :: OperatorInfo -> NixDoc -> Doc
prettyString :: NString NixDoc -> Doc
prettyFormals :: Formals NixDoc -> Doc
prettyParamSet :: FormalParamSet NixDoc -> Doc
prettyBind :: Binding NixDoc -> Doc
prettyKeyName :: NKeyName NixDoc -> Doc
prettySelector :: NSelector NixDoc -> Doc
prettySetArg :: (Text, Maybe NixDoc) -> Doc
prettyOper :: NOperF NixDoc -> NixDoc
prettyAtom :: NAtom -> NixDoc
prettyNix :: NExpr -> Doc

module Nix.Eval
buildArgument :: Formals NValue -> NValue -> NValue
evalExpr :: NExpr -> NValue -> IO NValue
evalString :: NValue -> NString (NValue -> IO NValue) -> IO Text
evalBinds :: Bool -> NValue -> [Binding (NValue -> IO NValue)] -> IO (Map Text NValue)
