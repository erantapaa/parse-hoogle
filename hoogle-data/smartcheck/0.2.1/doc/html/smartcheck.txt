-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A smarter QuickCheck.
--   
--   See the README.md.
@package smartcheck
@version 0.2.1

module Test.SmartCheck.Types
data SubT
SubT :: a -> SubT
unSubT :: SubT -> a
subT :: (Arbitrary a, SubTypes a) => a -> SubT

-- | Possible results of iterateArb.
data Result a

-- | Base type. Won't analyze.
BaseType :: Result a

-- | Couldn't satisfy the precondition of a QuickCheck property
FailedPreCond :: Result a

-- | Failed the property---either we expect failure and it passes or we
--   expect to pass it and we fail.
FailedProp :: Result a

-- | Satisfied it, with the satisfying value.
Result :: a -> Result a

-- | This class covers algebraic datatypes that can be transformed into
--   Trees. subTypes is the main method, placing values into trees.
--   
--   for a datatype with constructors A and C,
--   
--   <pre>
--   subTypes (A (C 0) 1)
--   [Node {rootLabel = C 0, subForest = []}]
--   </pre>
class (Arbitrary a, Show a, Typeable a) => SubTypes a where subTypes = gst . from baseType _ = False replaceChild a forest b = fmap to $ grc (from a) forest b toConstr = gtc . from showForest = gsf . from
subTypes :: SubTypes a => a -> Forest SubT
baseType :: SubTypes a => a -> Bool
replaceChild :: (SubTypes a, Typeable b) => a -> Forest Subst -> b -> Maybe a
toConstr :: SubTypes a => a -> String
showForest :: SubTypes a => a -> Forest String

-- | Index into a Tree/Forest, where level is the depth from the root and
--   column is the distance d is the dth value on the same level. Thus, all
--   left-most nodes are in column 0. This is a <a>matrix view</a> of
--   tree-structured data.
data Idx
Idx :: Int -> Int -> Idx
level :: Idx -> Int
column :: Idx -> Int

-- | Keep or substitue a value in the tree.
data Subst
Keep :: Subst
Subst :: Subst

-- | Nominally, a list for value generalization indexes and existential
--   generalization.
data Replace a
Replace :: [a] -> [a] -> Replace a
unVals :: Replace a -> [a]
unConstrs :: Replace a -> [a]
errorMsg :: String -> a
gst :: GST f => f a -> Forest SubT
grc :: (GST f, Typeable b) => f a -> Forest Subst -> b -> Maybe (f a)
gtc :: GST f => f a -> String
gsf :: GST f => f a -> Forest String
instance [overlap ok] Show a => Show (Replace a)
instance [overlap ok] Read a => Read (Replace a)
instance [overlap ok] Eq a => Eq (Replace a)
instance [overlap ok] Show a => Show (Result a)
instance [overlap ok] Read a => Read (Result a)
instance [overlap ok] Eq a => Eq (Result a)
instance [overlap ok] Eq Idx
instance [overlap ok] Show Subst
instance [overlap ok] Eq Subst
instance [overlap ok] Read Subst
instance [overlap ok] (Arbitrary a, SubTypes a, Typeable a, Arbitrary b, SubTypes b, Typeable b, Arbitrary c, SubTypes c, Typeable c, Arbitrary d, SubTypes d, Typeable d, Arbitrary e, SubTypes e, Typeable e) => SubTypes (a, b, c, d, e)
instance [overlap ok] (Arbitrary a, SubTypes a, Typeable a, Arbitrary b, SubTypes b, Typeable b, Arbitrary c, SubTypes c, Typeable c, Arbitrary d, SubTypes d, Typeable d) => SubTypes (a, b, c, d)
instance [overlap ok] (Arbitrary a, SubTypes a, Typeable a, Arbitrary b, SubTypes b, Typeable b, Arbitrary c, SubTypes c, Typeable c) => SubTypes (a, b, c)
instance [overlap ok] (Arbitrary a, SubTypes a, Typeable a, Arbitrary b, SubTypes b, Typeable b) => SubTypes (a, b)
instance [overlap ok] (Arbitrary a, SubTypes a, Typeable a, Arbitrary b, SubTypes b, Typeable b) => SubTypes (Either a b)
instance [overlap ok] (Arbitrary a, SubTypes a, Typeable a) => SubTypes (Maybe a)
instance [overlap ok] (RealFloat a, Arbitrary a, SubTypes a, Typeable a) => SubTypes (Complex a)
instance [overlap ok] (Integral a, Arbitrary a, SubTypes a, Typeable a) => SubTypes (Ratio a)
instance [overlap ok] (Arbitrary a, SubTypes a, Typeable a) => SubTypes [a]
instance [overlap ok] SubTypes ()
instance [overlap ok] SubTypes Word64
instance [overlap ok] SubTypes Word32
instance [overlap ok] SubTypes Word16
instance [overlap ok] SubTypes Word8
instance [overlap ok] SubTypes Word
instance [overlap ok] SubTypes Int64
instance [overlap ok] SubTypes Int32
instance [overlap ok] SubTypes Int16
instance [overlap ok] SubTypes Int8
instance [overlap ok] SubTypes Integer
instance [overlap ok] SubTypes Int
instance [overlap ok] SubTypes Float
instance [overlap ok] SubTypes Double
instance [overlap ok] SubTypes Char
instance [overlap ok] SubTypes Bool
instance [overlap ok] (Show a, Arbitrary a, SubTypes a, Typeable a) => GST (K1 i a)
instance [overlap ok] GST a => GST (M1 i k a)
instance [overlap ok] (Constructor c, GST a) => GST (M1 C c a)
instance [overlap ok] (GST a, GST b) => GST (a :+: b)
instance [overlap ok] (GST a, GST b) => GST (a :*: b)
instance [overlap ok] GST U1
instance [overlap ok] Show SubT
instance [overlap ok] Ord Idx
instance [overlap ok] Show Idx
instance [overlap ok] Applicative Result
instance [overlap ok] Monad Result
instance [overlap ok] Functor Result

module Test.SmartCheck.DataToTree
forestReplaceChildren :: Forest a -> Idx -> a -> Forest a

-- | Returns the value at index idx. Returns nothing if the index is out of
--   bounds.
getAtIdx :: SubTypes a => a -> Idx -> Maybe Int -> Maybe SubT

-- | Replace a value at index idx generically in a Tree/Forest generically.
replaceAtIdx :: (SubTypes a, Typeable b) => a -> Idx -> b -> Maybe a

-- | Get the tree at idx in a forest. Nothing if the index is
--   out-of-bounds.
getIdxForest :: Forest a -> Idx -> Maybe (Tree a)

-- | Return the list of values at each level in a Forest Not like levels in
--   Data.Tree (but what I imagined it should have done!).
breadthLevels :: Forest a -> [[a]]

-- | Make a substitution Forest (all proper children). Initially we don't
--   replace anything.
mkSubstForest :: SubTypes a => a -> b -> Forest b

-- | Get the depth of a Forest. 0-based (an empty Forest has depth 0).
depth :: Forest a -> Int
tooDeep :: Int -> Maybe Int -> Bool
instance Show SubStrat
instance Read SubStrat
instance Eq SubStrat

module Test.SmartCheck.SmartGen

-- | Driver for iterateArb.
iterateArbIdx :: SubTypes a => a -> (Idx, Maybe Int) -> Int -> Int -> (a -> Property) -> IO (Int, Result a)

-- | Replace the hole in d indexed by idx with a bunch of random values,
--   and test the new d against the property. Returns the first new d (the
--   full d but with the hole replaced) that succeeds. <a>Succeeds</a> is
--   determined by the call to resultify---if we're expecting failure, then
--   we succeed by getting a value that passes the precondition but fails
--   the property; otherwise we succeed by getting a value that passes the
--   precondition and satisfies the property. If no value ever satisfies
--   the precondition, then we return FailedPreCond. (Thus, there's an
--   implied linear order on the Result type: FailedPreCond &lt; FailedProp
--   &lt; Result a.)
iterateArb :: SubTypes a => a -> SubT -> Idx -> Int -> Int -> (a -> Property) -> IO (Int, Result a)

-- | Make a QuickCheck Result by applying a property function to a value
--   and then get out the Result using our result type.
resultify :: (a -> Property) -> a -> IO (Result a)

-- | Put a value v into a another value d at a hole idx, if v is
--   well-typed. Return Nothing if dynamic typing fails.
replace :: SubTypes a => a -> Idx -> SubT -> Maybe a
iter :: SubTypes a => a -> Test a b -> Next a b -> (a -> Property) -> Maybe Int -> Forest Bool -> Idx -> [Idx] -> IO (a, [Idx])


-- | SmartCheck's interface to QuickCheck.
module Test.SmartCheck.Test

-- | Our SmartCheck reimplementation of the main QuickCheck driver. We want
--   to distinguish the first argument to a <a>Testable</a> property to be
--   SmartChecked. In particular: the first argument will not be shrunk
--   (even if there are default shrink instances for the type). However,
--   the argument will be grown according to the the <a>maxSize</a>
--   argument to QuickCheck, in accordance with its generator. Other
--   arguments will be shrunk, if they have shrinking instances.
scQuickCheckWithResult :: (Show a, Arbitrary a, Testable prop) => Args -> (a -> prop) -> IO (Maybe a, Result)

-- | The default test arguments
stdArgs :: Args

module Test.SmartCheck.Matches

-- | True if d matches any ds. Assume all ds are unequal to each other.
matchesShapes :: SubTypes a => a -> [(a, Replace Idx)] -> Bool


-- | SmartCheck arguments.
module Test.SmartCheck.Args
data ScArgs
ScArgs :: Format -> Args -> Int -> Maybe Int -> Int -> Bool -> Int -> Int -> Bool -> Int -> ScArgs

-- | How to show extrapolated formula
format :: ScArgs -> Format

-- | QuickCheck arguments
qcArgs :: ScArgs -> Args

-- | Maximum size of data to generate, in terms of the size parameter of
--   QuickCheck's Arbitrary instance for your data.
scMaxSize :: ScArgs -> Int

-- | How many levels into the structure of the failed value should we
--   descend when reducing or generalizing? Nothing means we go down to
--   base types.
scMaxDepth :: ScArgs -> Maybe Int

-- | How hard (number of rounds) to look for failure in the reduction
--   stage.
scMaxReduce :: ScArgs -> Int

-- | Should we extrapolate?
runForall :: ScArgs -> Bool

-- | How hard (number of rounds) to look for failures during the
--   extrapolation stage.
scMaxForall :: ScArgs -> Int

-- | Minimum number of times a property's precondition must be passed to
--   generalize it.
scMinForall :: ScArgs -> Int

-- | Should we try to generalize constructors?
runExists :: ScArgs -> Bool

-- | How hard (number of rounds) to look for failing values with each
--   constructor. For <a>wide</a> sum types, this value should be
--   increased.
scMaxExists :: ScArgs -> Int
scStdArgs :: ScArgs
data Format
PrintTree :: Format
PrintString :: Format
instance Eq Format
instance Read Format
instance Show Format
instance Show ScArgs
instance Read ScArgs


-- | Rendering arbitrary data, and filling in holes in the data with
--   variables.
module Test.SmartCheck.Render
renderWithVars :: SubTypes a => Format -> a -> Replace Idx -> IO ()
smartPrtLn :: String -> IO ()

module Test.SmartCheck.ConstructorGen

-- | Entry point to generalize constructors. We pass in a list of indexes
--   from value generalizations so we don't try to generalize those
--   constructors (or anything below).
constrsGen :: (SubTypes a, Generic a, ConNames (Rep a)) => ScArgs -> a -> (a -> Property) -> [Idx] -> IO [Idx]

module Test.SmartCheck.Extrapolate

-- | Test d with arbitrary values replacing its children. For anything we
--   get 100% failure for, we claim we can generalize it---any term in that
--   hole fails.
--   
--   We extrapolate if there exists at least one test that satisfies the
--   precondition, and for all tests that satisfy the precondition, they
--   fail.
extrapolate :: SubTypes a => ScArgs -> a -> (a -> Property) -> IO ([Idx])

module Test.SmartCheck.Reduce
smartRun :: SubTypes a => ScArgs -> a -> (a -> Property) -> IO a


-- | Interface module.
module Test.SmartCheck

-- | Main interface function.
smartCheck :: (SubTypes a, Generic a, ConNames (Rep a), Testable prop) => ScArgs -> (a -> prop) -> IO ()
smartCheckInput :: (SubTypes a, Generic a, ConNames (Rep a), Testable prop, Read a) => ScArgs -> (a -> prop) -> IO ()

-- | Run QuickCheck, to get a counterexamples for each argument, including
--   the one we want to focus on for SmartCheck, which is the first
--   argument. That argument is never shrunk by QuickCheck, but others may
--   be shrunk by QuickCheck. Returns the value (if it exists) and a
--   <tt>Property</tt> (by applying the <tt>property</tt> method to the
--   <tt>Testable</tt> value). In each iteration of <a>runQC</a>,
--   non-SmartCheck arguments are not necessarily held constant
runQC :: (Show a, Arbitrary a, Testable prop) => Args -> (a -> prop) -> IO (Maybe a, a -> Property)

-- | This class covers algebraic datatypes that can be transformed into
--   Trees. subTypes is the main method, placing values into trees.
--   
--   for a datatype with constructors A and C,
--   
--   <pre>
--   subTypes (A (C 0) 1)
--   [Node {rootLabel = C 0, subForest = []}]
--   </pre>
class (Arbitrary a, Show a, Typeable a) => SubTypes a where subTypes = gst . from baseType _ = False replaceChild a forest b = fmap to $ grc (from a) forest b toConstr = gtc . from showForest = gsf . from
subTypes :: SubTypes a => a -> Forest SubT
baseType :: SubTypes a => a -> Bool
replaceChild :: (SubTypes a, Typeable b) => a -> Forest Subst -> b -> Maybe a
toConstr :: SubTypes a => a -> String
showForest :: SubTypes a => a -> Forest String
gst :: GST f => f a -> Forest SubT
grc :: (GST f, Typeable b) => f a -> Forest Subst -> b -> Maybe (f a)
gtc :: GST f => f a -> String
gsf :: GST f => f a -> Forest String
