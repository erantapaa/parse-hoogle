-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell on Rails - Reactive Values
--   
@package keera-hails-reactivevalues
@version 0.0.3.4

module Control.GFunctor
class GFunctor f m
gmap :: GFunctor f m => m a b -> f a -> f b
(<$$>) :: GFunctor f m => m a b -> f a -> f b
instance Functor a => GFunctor a (->)


-- | This is a more general, cleaner interface that allows Model to Model
--   synchronization and view to view.
--   
--   It is meant to replace Hails.MVC.Controller.Reactive as soon as we do
--   not need to provide an undefined value for the function
--   reactiveValueOnCanRead.
module Data.ReactiveValue

-- | Readable reactive values
class ReactiveValueRead a b m | a -> b
reactiveValueOnCanRead :: ReactiveValueRead a b m => a -> m () -> m ()
reactiveValueRead :: ReactiveValueRead a b m => a -> m b

-- | Writable reactive values
class ReactiveValueWrite a b m
reactiveValueWrite :: ReactiveValueWrite a b m => a -> b -> m ()

-- | Read-write reactive values
class (ReactiveValueRead a b m, ReactiveValueWrite a b m) => ReactiveValueReadWrite a b m

-- | Priorities so that we can write them infix without parenthesising
--   
--   Left to right
(=:>) :: Monad m => (ReactiveValueRead a b m, ReactiveValueWrite c b m) => a -> c -> m ()

-- | Right-to-left
(<:=) :: Monad m => (ReactiveValueRead a b m, ReactiveValueWrite c b m) => c -> a -> m ()

-- | Bidirectional
(=:=) :: Monad m => (ReactiveValueReadWrite a b m, ReactiveValueReadWrite c b m) => a -> c -> m ()
type FieldGetter m a = m a
type FieldSetter m a = a -> m ()
type FieldNotifier m a = m () -> m ()
data ReactiveFieldRead m a
ReactiveFieldRead :: (FieldGetter m a) -> (FieldNotifier m a) -> ReactiveFieldRead m a
data ReactiveFieldWrite m a
ReactiveFieldWrite :: (FieldSetter m a) -> ReactiveFieldWrite m a
data ReactiveFieldReadWrite m a
ReactiveFieldReadWrite :: (FieldSetter m a) -> (FieldGetter m a) -> (FieldNotifier m a) -> ReactiveFieldReadWrite m a
type ReactiveFieldActivatable m = ReactiveFieldRead m ()
mkActivatable :: Monad m => (m () -> m ()) -> ReactiveFieldActivatable m
class ReactiveValueActivatable m a
defaultActivation :: ReactiveValueActivatable m a => a -> ReactiveFieldActivatable m
constR :: Monad m => a -> ReactiveFieldRead m a
initRW :: Monad m => a -> ReactiveFieldRead m a
liftR :: (Monad m, ReactiveValueRead a b m) => a -> (b -> c) -> ReactiveFieldRead m c
liftR2 :: (Monad m, ReactiveValueRead a b m, ReactiveValueRead c d m) => a -> c -> (b -> d -> e) -> ReactiveFieldRead m e
liftMR :: (Monad m, ReactiveValueRead a b m) => a -> (b -> m c) -> ReactiveFieldRead m c
liftW :: (Monad m, ReactiveValueWrite a b m) => a -> (c -> b) -> ReactiveFieldWrite m c
liftW2 :: (Monad m, ReactiveValueWrite a b m, ReactiveValueWrite d e m) => a -> d -> (c -> (b, e)) -> ReactiveFieldWrite m c
liftMW :: (Monad m, ReactiveValueWrite a b m) => a -> (c -> m b) -> ReactiveFieldWrite m c
readOnly :: ReactiveValueRead r a m => r -> ReactiveFieldRead m a
writeOnly :: ReactiveValueWrite r a m => r -> ReactiveFieldWrite m a
wrapMW :: (a -> m ()) -> ReactiveFieldWrite m a
wrapMRPassive :: Monad m => m a -> ReactiveFieldRead m a
wrapMR :: m a -> (m () -> m ()) -> ReactiveFieldRead m a
newtype BijectiveFunc a b
BijectiveFunc :: (a -> b, b -> a) -> BijectiveFunc a b
unBijectiveFunc :: BijectiveFunc a b -> (a -> b, b -> a)
bijection :: (a -> b, b -> a) -> BijectiveFunc a b
direct :: BijectiveFunc a b -> (a -> b)
inverse :: BijectiveFunc a b -> (b -> a)
type Involution a = BijectiveFunc a a
involution :: (a -> a) -> Involution a
liftRW :: (Monad m, ReactiveValueReadWrite a b m) => a -> BijectiveFunc b c -> ReactiveFieldReadWrite m c
liftRW2 :: (Monad m, ReactiveValueReadWrite a b m, ReactiveValueReadWrite c d m) => a -> c -> BijectiveFunc e (b, d) -> ReactiveFieldReadWrite m e
pairRW :: (Monad m, ReactiveValueReadWrite a b m, ReactiveValueReadWrite c d m) => a -> c -> ReactiveFieldReadWrite m (b, d)
eqCheck :: (Eq v, Monad m) => ReactiveFieldReadWrite m v -> ReactiveFieldReadWrite m v

-- | Lifting modification functions
modRW :: (Monad m, ReactiveValueReadWrite a b m) => (b -> c -> b) -> a -> ReactiveFieldWrite m c
reactiveValueModify :: (Monad m, ReactiveValueReadWrite a b m) => a -> (b -> b) -> m ()

-- | Turning an active RV into a passive one (does not propagate changes)
--   Note that this does not really affect the RV itself, only produces a
--   new RV that will not propagate changes. So, if used in a reactive
--   relation, values will not get propagated when they change. It is
--   useful in combination with lifts, to achieve things similar to Yampa's
--   tagging, but this might be more general.
passivelyR :: (Monad m, ReactiveValueRead a b m) => a -> ReactiveFieldRead m b
passivelyRW :: (Monad m, ReactiveValueReadWrite a b m) => a -> ReactiveFieldReadWrite m b
ifRW_ :: (Monad m, ReactiveValueRead c Bool m, ReactiveValueReadWrite v a m) => c -> v -> ReactiveFieldReadWrite m a
ifRW :: (Monad m, ReactiveValueRead c Bool m, ReactiveValueReadWrite v a m) => c -> v -> ReactiveFieldReadWrite m a
guardRO :: (Monad m, ReactiveValueRead c Bool m) => c -> ReactiveFieldRead m Bool

-- | Temporary: will be moved to Keera Hails' Reactive Values library.
governingR :: (ReactiveValueRead a b m, ReactiveValueRead c d m) => a -> c -> ReactiveFieldRead m d
instance Monad m => GFunctor (ReactiveFieldReadWrite m) BijectiveFunc
instance Monad m => Contravariant (ReactiveFieldWrite m)
instance (Functor m, Monad m) => Functor (ReactiveFieldRead m)
instance ReactiveValueReadWrite (ReactiveFieldReadWrite m a) a m
instance ReactiveValueWrite (ReactiveFieldReadWrite m a) a m
instance ReactiveValueRead (ReactiveFieldReadWrite m a) a m
instance ReactiveValueWrite (ReactiveFieldWrite m a) a m
instance ReactiveValueRead (ReactiveFieldRead m a) a m
