-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell NSQ client.
--   
--   Currently a primitive NSQ client, it implements the very basics of an
--   NSQ client for communicating with single NSQ servers. For example
--   usage refer to <a>benchmark</a>
@package hsnsq
@version 0.1.2.0


module Network.NSQ.Types

-- | Message Id, it is a 16-byte hexdecimal string encoded as ASCII
type MsgId = ByteString

-- | NSQ Topic, the only allowed character in a topic is
--   <tt>\.a-zA-Z0-9_-</tt>
type Topic = Text

-- | NSQ Channel, the only allowed character in a channel is
--   <tt>\.a-zA-Z0-9_-</tt> A channel can be marked as ephemeral by
--   toggling the <a>Bool</a> value to true in <a>Sub</a>
type Channel = Text

-- | Logger Name for a connection (hslogger format)
type LogName = String

-- | The message and replies back from the server.
data Message

-- | Everything is allright.
OK :: Message

-- | Heartbeat, reply with the <a>NOP</a> <a>Command</a>.
Heartbeat :: Message

-- | Server has closed the connection.
CloseWait :: Message

-- | The server sent back an error.
Error :: ErrorType -> Message

-- | A message to be processed. The values are: Nanosecond Timestamp,
--   number of attempts, Message Id, and the content of the message to be
--   processed.
Message :: Int64 -> Word16 -> MsgId -> ByteString -> Message

-- | Catch-all message for future expansion. This currently includes the
--   reply from <a>Identify</a> if feature negotiation is set.
CatchAllMessage :: FrameType -> ByteString -> Message

-- | NSQ Command
data Command

-- | The protocol version
Protocol :: Command

-- | No-op, usually used in reply to a <a>Heartbeat</a> request from the
--   server.
NOP :: Command

-- | Client Identification + possible features negotiation.
Identify :: IdentifyMetadata -> Command

-- | Subscribe to a specified 'Topic'/'Channel', use <a>True</a> if its an
--   ephemeral channel.
Sub :: Topic -> Channel -> Bool -> Command

-- | Publish a message to the specified <a>Topic</a>.
Pub :: Topic -> ByteString -> Command

-- | Publish multiple messages to a specified <a>Topic</a>.
MPub :: Topic -> [ByteString] -> Command

-- | Update <tt>RDY</tt> state (ready to recieve messages). Number of
--   message you can process at once.
Rdy :: Word64 -> Command

-- | Finish a message.
Fin :: MsgId -> Command

-- | Re-queue a message (failure to process), Timeout is in milliseconds.
Req :: MsgId -> Word64 -> Command

-- | Reset the timeout for an in-flight message.
Touch :: MsgId -> Command

-- | Cleanly close the connection to the NSQ daemon.
Cls :: Command

-- | Catch-all command for future expansion/custom commands.
Command :: ByteString -> Command

-- | Frame Type of the incoming data from the NSQ daemon.
data FrameType

-- | Response to a <a>Command</a> from the server.
FTResponse :: FrameType

-- | An error in response to a <a>Command</a>.
FTError :: FrameType

-- | Messages.
FTMessage :: FrameType

-- | For future extension for handling new Frame Types.
FTUnknown :: Int32 -> FrameType

-- | Types of error that the server can return in response to an
--   <a>Command</a>
data ErrorType

-- | Something went wrong with the command (IDENTIFY, SUB, PUB, MPUB, RDY,
--   FIN, REQ, TOUCH, CLS)
Invalid :: ErrorType

-- | Bad Body (IDENTIFY, MPUB)
BadBody :: ErrorType

-- | Bad Topic (most likely used disallowed characters) (SUB, PUB, MPUB)
BadTopic :: ErrorType

-- | Bad channel (Like <a>BadTopic</a> probably used an disallowed
--   character) (SUB)
BadChannel :: ErrorType

-- | Bad Message (PUB, MPUB)
BadMessage :: ErrorType

-- | Publishing a message failed (PUB)
PubFailed :: ErrorType

-- | Same as <a>PubFailed</a> (MPUB)
MPubFailed :: ErrorType

-- | Finish failed (Probably already finished or non-existant message-id)
--   (FIN)
FinFailed :: ErrorType

-- | Requeue failed (REQ)
ReqFailed :: ErrorType

-- | Touch failed (TOUCH)
TouchFailed :: ErrorType

-- | New unknown type of error (ANY)
Unknown :: ByteString -> ErrorType

-- | Optional settings, if <a>Disabled</a> then this setting will be put in
--   the json as disabled specifically vs "not being listed".
data OptionalSetting
Disabled :: OptionalSetting
Custom :: Word64 -> OptionalSetting

-- | TLS version supported
data TLS
NoTLS :: TLS
TLSV1 :: TLS

-- | For <a>Deflate</a> its the compression level from 0-9
data Compression
NoCompression :: Compression
Snappy :: Compression
Deflate :: Word8 -> Compression

-- | The client identification
data Identification
Identification :: Text -> Text -> Maybe Text -> Maybe Text -> Maybe Text -> Identification

-- | An identifier of this consumer, something specific to this consumer
clientId :: Identification -> Text

-- | Hostname of the machine the client is running on
hostname :: Identification -> Text

-- | Deprecated in favor of client_id
shortId :: Identification -> Maybe Text

-- | Deprecated in favor of hostname
longId :: Identification -> Maybe Text

-- | Default (client_library_name/version)
userAgent :: Identification -> Maybe Text

-- | Metadata for feature negotiation, if any of the values are set it will
--   be sent to the server otherwise they will be omitted. If the setting
--   is set to <a>Nothing</a> it will not be sent to the server, and if its
--   set to <a>Just</a> <a>Disabled</a> it will be sent to the server as
--   disabled explicitly.
data IdentifyMetadata
IdentifyMetadata :: Identification -> Maybe TLS -> Maybe Compression -> Maybe OptionalSetting -> Maybe OptionalSetting -> Maybe OptionalSetting -> Maybe OptionalSetting -> Maybe (Map Text Text) -> Bool -> IdentifyMetadata

-- | Client identification
ident :: IdentifyMetadata -> Identification

-- | TLS
tls :: IdentifyMetadata -> Maybe TLS

-- | Compression
compression :: IdentifyMetadata -> Maybe Compression

-- | The time between each heartbeat (disabled = -1)
heartbeatInterval :: IdentifyMetadata -> Maybe OptionalSetting

-- | The size of the buffer (disabled = -1)
outputBufferSize :: IdentifyMetadata -> Maybe OptionalSetting

-- | The timeout for the buffer (disabled = -1)
outputBufferTimeout :: IdentifyMetadata -> Maybe OptionalSetting

-- | Sampling of the message will be sent to the client (disabled = 0)
sampleRate :: IdentifyMetadata -> Maybe OptionalSetting

-- | Map of possible key -&gt; value for future protocol expansion
custom :: IdentifyMetadata -> Maybe (Map Text Text)

-- | Set if there are any <a>custom</a> values to send
customNegotiation :: IdentifyMetadata -> Bool

-- | Per Connection configuration such as: per nsqd state (rdy, load
--   balance), per topic state (channel)
data NSQConnection
NSQConnection :: String -> PortNumber -> LogName -> IdentifyMetadata -> NSQConnection
server :: NSQConnection -> String
port :: NSQConnection -> PortNumber
logName :: NSQConnection -> LogName
identConf :: NSQConnection -> IdentifyMetadata
instance Show FrameType
instance Show ErrorType
instance Show Message
instance Show OptionalSetting
instance Show TLS
instance Show Compression
instance Show Identification
instance Show IdentifyMetadata
instance Show Command


module Network.NSQ.Identify

-- | Build a default <a>IdentifyMetadata</a> that makes sense which is
--   basically just setting the client <a>Identification</a> and leaving
--   the rest of the settings up to the server to determine.
defaultIdentify :: Text -> Text -> IdentifyMetadata

-- | The default user agent to send, for identifying what client library is
--   connecting to the nsqd.
defaultUserAgent :: Text

-- | Encode the metadata from <a>IdentifyMetadata</a> into a
--   <tt>ByteString</tt> for feeding the <a>Identify</a> <a>Command</a> for
--   sending the metadata to the nsq daemon as part of the feature
--   negotiation.
encodeMetadata :: IdentifyMetadata -> ByteString
instance ToJSON IdentifyMetadata


module Network.NSQ.Parser

-- | Parse the low level message frames into a <a>Message</a> type.
message :: Parser Message

-- | Decode the <tt>ByteString</tt> to an <a>Message</a>
decode :: ByteString -> Maybe Message

-- | Encode a <a>Command</a> into raw <tt>ByteString</tt> to send to the
--   network to the nsqd daemon. There are a few gotchas here; You can only
--   have one <a>Sub</a> (topic/channel) per nsqld connection, any other
--   will yield <a>Invalid</a>. Also you can publish to any number of topic
--   without limitation.
encode :: Command -> ByteString


-- | This is the low level client connection to the nsqd. It is recommended
--   to use the higher level library when those come out.
module Network.NSQ.Connection

-- | Attempt to come up with an intelligent default <a>NSQConnection</a>
--   default by discovering your client's hostname and reusing it for the
--   client id for the <tt>IdentifyMetadata</tt>
defaultConfig :: String -> IO NSQConnection

-- | Establish a session with the specified nsqd using the provided
--   <a>TQueue</a> so that the actual data processing can be done in a
--   decoupled manner from the hsnsq stack.
--   
--   This supports connecting to a specific nsqd, it is however recommended
--   in the future when the feature comes out to user a higher layer that
--   handles the load balancing between multiple nsqd.
establish :: NSQConnection -> TQueue Message -> TQueue Command -> IO ()


-- | This is a haskell client for the <a>NSQ</a> message queue service.
--   
--   TODO:
--   
--   <ul>
--   <li>Start implementing a more through client<ul><li>Write some form of
--   tests</li><li>More through docs, the initial docs
--   sucks.</li></ul></li>
--   </ul>
module Network.NSQ

-- | Message Id, it is a 16-byte hexdecimal string encoded as ASCII
type MsgId = ByteString

-- | NSQ Topic, the only allowed character in a topic is
--   <tt>\.a-zA-Z0-9_-</tt>
type Topic = Text

-- | NSQ Channel, the only allowed character in a channel is
--   <tt>\.a-zA-Z0-9_-</tt> A channel can be marked as ephemeral by
--   toggling the <a>Bool</a> value to true in <a>Sub</a>
type Channel = Text

-- | The message and replies back from the server.
data Message

-- | Everything is allright.
OK :: Message

-- | Heartbeat, reply with the <a>NOP</a> <a>Command</a>.
Heartbeat :: Message

-- | Server has closed the connection.
CloseWait :: Message

-- | The server sent back an error.
Error :: ErrorType -> Message

-- | A message to be processed. The values are: Nanosecond Timestamp,
--   number of attempts, Message Id, and the content of the message to be
--   processed.
Message :: Int64 -> Word16 -> MsgId -> ByteString -> Message

-- | Catch-all message for future expansion. This currently includes the
--   reply from <a>Identify</a> if feature negotiation is set.
CatchAllMessage :: FrameType -> ByteString -> Message

-- | NSQ Command
data Command

-- | The protocol version
Protocol :: Command

-- | No-op, usually used in reply to a <a>Heartbeat</a> request from the
--   server.
NOP :: Command

-- | Client Identification + possible features negotiation.
Identify :: IdentifyMetadata -> Command

-- | Subscribe to a specified 'Topic'/'Channel', use <a>True</a> if its an
--   ephemeral channel.
Sub :: Topic -> Channel -> Bool -> Command

-- | Publish a message to the specified <a>Topic</a>.
Pub :: Topic -> ByteString -> Command

-- | Publish multiple messages to a specified <a>Topic</a>.
MPub :: Topic -> [ByteString] -> Command

-- | Update <tt>RDY</tt> state (ready to recieve messages). Number of
--   message you can process at once.
Rdy :: Word64 -> Command

-- | Finish a message.
Fin :: MsgId -> Command

-- | Re-queue a message (failure to process), Timeout is in milliseconds.
Req :: MsgId -> Word64 -> Command

-- | Reset the timeout for an in-flight message.
Touch :: MsgId -> Command

-- | Cleanly close the connection to the NSQ daemon.
Cls :: Command

-- | Catch-all command for future expansion/custom commands.
Command :: ByteString -> Command

-- | Frame Type of the incoming data from the NSQ daemon.
data FrameType

-- | Response to a <a>Command</a> from the server.
FTResponse :: FrameType

-- | An error in response to a <a>Command</a>.
FTError :: FrameType

-- | Messages.
FTMessage :: FrameType

-- | For future extension for handling new Frame Types.
FTUnknown :: Int32 -> FrameType

-- | Types of error that the server can return in response to an
--   <a>Command</a>
data ErrorType

-- | Something went wrong with the command (IDENTIFY, SUB, PUB, MPUB, RDY,
--   FIN, REQ, TOUCH, CLS)
Invalid :: ErrorType

-- | Bad Body (IDENTIFY, MPUB)
BadBody :: ErrorType

-- | Bad Topic (most likely used disallowed characters) (SUB, PUB, MPUB)
BadTopic :: ErrorType

-- | Bad channel (Like <a>BadTopic</a> probably used an disallowed
--   character) (SUB)
BadChannel :: ErrorType

-- | Bad Message (PUB, MPUB)
BadMessage :: ErrorType

-- | Publishing a message failed (PUB)
PubFailed :: ErrorType

-- | Same as <a>PubFailed</a> (MPUB)
MPubFailed :: ErrorType

-- | Finish failed (Probably already finished or non-existant message-id)
--   (FIN)
FinFailed :: ErrorType

-- | Requeue failed (REQ)
ReqFailed :: ErrorType

-- | Touch failed (TOUCH)
TouchFailed :: ErrorType

-- | New unknown type of error (ANY)
Unknown :: ByteString -> ErrorType

-- | Optional settings, if <a>Disabled</a> then this setting will be put in
--   the json as disabled specifically vs "not being listed".
data OptionalSetting
Disabled :: OptionalSetting
Custom :: Word64 -> OptionalSetting

-- | TLS version supported
data TLS
NoTLS :: TLS
TLSV1 :: TLS

-- | For <a>Deflate</a> its the compression level from 0-9
data Compression
NoCompression :: Compression
Snappy :: Compression
Deflate :: Word8 -> Compression

-- | The client identification
data Identification
Identification :: Text -> Text -> Maybe Text -> Maybe Text -> Maybe Text -> Identification

-- | An identifier of this consumer, something specific to this consumer
clientId :: Identification -> Text

-- | Hostname of the machine the client is running on
hostname :: Identification -> Text

-- | Deprecated in favor of client_id
shortId :: Identification -> Maybe Text

-- | Deprecated in favor of hostname
longId :: Identification -> Maybe Text

-- | Default (client_library_name/version)
userAgent :: Identification -> Maybe Text

-- | Metadata for feature negotiation, if any of the values are set it will
--   be sent to the server otherwise they will be omitted. If the setting
--   is set to <a>Nothing</a> it will not be sent to the server, and if its
--   set to <a>Just</a> <a>Disabled</a> it will be sent to the server as
--   disabled explicitly.
data IdentifyMetadata
IdentifyMetadata :: Identification -> Maybe TLS -> Maybe Compression -> Maybe OptionalSetting -> Maybe OptionalSetting -> Maybe OptionalSetting -> Maybe OptionalSetting -> Maybe (Map Text Text) -> Bool -> IdentifyMetadata

-- | Client identification
ident :: IdentifyMetadata -> Identification

-- | TLS
tls :: IdentifyMetadata -> Maybe TLS

-- | Compression
compression :: IdentifyMetadata -> Maybe Compression

-- | The time between each heartbeat (disabled = -1)
heartbeatInterval :: IdentifyMetadata -> Maybe OptionalSetting

-- | The size of the buffer (disabled = -1)
outputBufferSize :: IdentifyMetadata -> Maybe OptionalSetting

-- | The timeout for the buffer (disabled = -1)
outputBufferTimeout :: IdentifyMetadata -> Maybe OptionalSetting

-- | Sampling of the message will be sent to the client (disabled = 0)
sampleRate :: IdentifyMetadata -> Maybe OptionalSetting

-- | Map of possible key -&gt; value for future protocol expansion
custom :: IdentifyMetadata -> Maybe (Map Text Text)

-- | Set if there are any <a>custom</a> values to send
customNegotiation :: IdentifyMetadata -> Bool

-- | Per Connection configuration such as: per nsqd state (rdy, load
--   balance), per topic state (channel)
data NSQConnection
NSQConnection :: String -> PortNumber -> LogName -> IdentifyMetadata -> NSQConnection
server :: NSQConnection -> String
port :: NSQConnection -> PortNumber
logName :: NSQConnection -> LogName
identConf :: NSQConnection -> IdentifyMetadata

-- | Parse the low level message frames into a <a>Message</a> type.
message :: Parser Message

-- | Decode the <tt>ByteString</tt> to an <a>Message</a>
decode :: ByteString -> Maybe Message

-- | Encode a <a>Command</a> into raw <tt>ByteString</tt> to send to the
--   network to the nsqd daemon. There are a few gotchas here; You can only
--   have one <a>Sub</a> (topic/channel) per nsqld connection, any other
--   will yield <a>Invalid</a>. Also you can publish to any number of topic
--   without limitation.
encode :: Command -> ByteString

-- | Build a default <a>IdentifyMetadata</a> that makes sense which is
--   basically just setting the client <a>Identification</a> and leaving
--   the rest of the settings up to the server to determine.
defaultIdentify :: Text -> Text -> IdentifyMetadata

-- | The default user agent to send, for identifying what client library is
--   connecting to the nsqd.
defaultUserAgent :: Text

-- | Encode the metadata from <a>IdentifyMetadata</a> into a
--   <tt>ByteString</tt> for feeding the <a>Identify</a> <a>Command</a> for
--   sending the metadata to the nsq daemon as part of the feature
--   negotiation.
encodeMetadata :: IdentifyMetadata -> ByteString

-- | Attempt to come up with an intelligent default <a>NSQConnection</a>
--   default by discovering your client's hostname and reusing it for the
--   client id for the <tt>IdentifyMetadata</tt>
defaultConfig :: String -> IO NSQConnection

-- | Establish a session with the specified nsqd using the provided
--   <a>TQueue</a> so that the actual data processing can be done in a
--   decoupled manner from the hsnsq stack.
--   
--   This supports connecting to a specific nsqd, it is however recommended
--   in the future when the feature comes out to user a higher layer that
--   handles the load balancing between multiple nsqd.
establish :: NSQConnection -> TQueue Message -> TQueue Command -> IO ()
