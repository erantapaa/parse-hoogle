-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Orchestration-style co-ordination EDSL
--   
--   Provides an EDSL with Orc primitives.
@package orc
@version 1.2.1.4


-- | Hierarchical concurrent threads, which kill all of their descendants
--   when they are killed.
module Control.Concurrent.Hierarchical

-- | The <a>HIO</a> monad is simply the <a>IO</a> monad augmented with an
--   environment that tracks the current thread <a>Group</a>. This permits
--   us to keep track of forked threads and kill them en mass when an
--   ancestor is killed. The <a>HIO</a> monad is an instance of
--   <a>MonadIO</a>, so arbitrary <a>IO</a> actions may be embedded in it;
--   however, the user is advised that any action may be summarily killed,
--   and thus it is of extra importance that appropriate bracketing
--   functions are used.
data HIO a

-- | Runs a <a>HIO</a> operation inside a new thread group that has no
--   parent, and blocks until all subthreads of the operation are done
--   executing. If <tt>countingThreads</tt> is <tt>True</tt>, it then
--   prints some debugging information about the threads run (XXX: this
--   seems suboptimal.)
runHIO :: HIO b -> IO ()

-- | Creates a new, empty thread group.
newPrimGroup :: IO Group

-- | Creates a new thread group and registers the current environment's
--   thread group in it. If the current group is closed, immediately
--   terminates execution of the current thread.
newGroup :: HIO Group

-- | Explicitly sets the current <a>Group</a> environment for a <a>HIO</a>
--   monad.
local :: Group -> HIO a -> HIO a

-- | Kill all threads which are descendants of a <a>Group</a> and closes
--   the group, disallowing new threads or groups to be added to the group.
--   Doesn't do anything if the group is already closed.
close :: Group -> HIO ()

-- | A thread <a>Group</a> keeps tracks of its inhabitants, which may be
--   threads or other <a>Group</a>s.
type Group = (TVar Int, TVar Inhabitants)

-- | Blocks until the <a>Group</a> <tt>w</tt> is finished executing.
finished :: Group -> HIO ()
instance HasFork HIO
instance MonadIO HIO
instance Applicative HIO
instance Monad HIO
instance Functor HIO


-- | Primitive combinators for the Orc EDSL in Haskell.
module Orc.Monad

-- | A monad for many-valued concurrency, external actions and managed
--   resources. An expression of type <tt>Orc a</tt> may perform many
--   actions and return many results of type <tt>a</tt>. The
--   <a>MonadPlus</a> instance does not obey the Right-Zero law (<tt>p
--   &gt;&gt; stop /= stop</tt>).
data Orc a

-- | Finish the local thread of operations, so that anything sequenced
--   afterwards is not executed. It satisfies the following law: <tt>stop
--   &gt;&gt;= k == stop</tt>
stop :: Orc a

-- | Immediately fires up a thread for <tt>p</tt>, and then returns a
--   handle to the first result of that thread which is also of type
--   <tt>Orc a</tt>. An invocation to <a>eagerly</a> is non-blocking, while
--   an invocation of the resulting handle is blocking. <a>eagerly</a>
--   satisfies the following laws:
--   
--   Par-eagerly:
--   
--   <pre>
--   eagerly p &gt;&gt;= (\x -&gt; k x &lt;|&gt; h)
--   == (eagerly p &gt;&gt;= k) &lt;|&gt; h
--   </pre>
--   
--   Eagerly-swap:
--   
--   <pre>
--   do y &lt;- eagerly p
--      x &lt;- eagerly q
--      k x y
--   == do x &lt;- eagerly q
--         y &lt;- eagerly p
--         k x y
--   </pre>
--   
--   Eagerly-IO:
--   
--   <pre>
--   eagerly (liftIO m) &gt;&gt; p == (liftIO m &gt;&gt; stop) &lt;|&gt; p
--   </pre>
eagerly :: Orc a -> Orc (Orc a)

-- | An alternate mechanism for <a>eagerly</a>, it fires up a thread for
--   <tt>p</tt> and returns a lazy thunk that contains the single (trimmed)
--   result of the computation. Be careful to use this function with
--   <tt>publish</tt> when these lazy values need to be fully evaluated
--   before proceeding further. For example, the following code succeeds
--   immediately:
--   
--   <pre>
--   do x &lt;- val p
--      return x
--   </pre>
--   
--   Whereas this code waits until <tt>p</tt> has generated one result
--   before returning:
--   
--   <pre>
--   do x &lt;- val p
--      publish p
--   </pre>
val :: Orc a -> Orc a

-- | Biased choice operator (pronounced and-then) that performs the action
--   (and returns all the results) of <tt>p</tt> first, and then once done
--   performs the action of <tt>q</tt>.
(<+>) :: Orc a -> Orc a -> Orc a

-- | Runs an Orc computation, discarding the (many) results of the
--   computation. See <tt>collect</tt> on a mechanism for collecting the
--   results of a computation into a list, which may then be passed to
--   another IO thread.
runOrc :: Orc a -> IO ()
instance MonadPlus Orc
instance Applicative Orc
instance MonadIO Orc
instance Alternative Orc
instance Monad Orc
instance Functor Orc


module Orc.Combinators

-- | Alternate phrasing of <tt>return ()</tt>, which can be placed at the
--   end of an Orc computation to signal that it has no more values to
--   produce.
signal :: Orc ()

-- | Cut executes an orc expression, waits for the first result, and then
--   suppresses the rest, including killing any threads involved in
--   computing the remainder.
cut :: Orc a -> Orc a

-- | Executes the computation <tt>p</tt> and <tt>done</tt>. Once
--   <tt>done</tt> returns its first result, kill both computations and
--   returns that result. This discards the results of <tt>p</tt>.
onlyUntil :: Orc a -> Orc b -> Orc b

-- | Immediately executes the computation <tt>p</tt>, but if it hasn't
--   returned a result in <tt>t</tt> seconds, execute the computation
--   <tt>q</tt> and return whichever computations returns a result first
--   (killing the other thread).
butAfter :: Orc a -> (Float, Orc a) -> Orc a

-- | Executes a computation <tt>p</tt>, but if it hasn't returned a result
--   in <tt>n</tt> seconds return <tt>a</tt> instead (killing the
--   <tt>p</tt> computation).
timeout :: Float -> a -> Orc a -> Orc a

-- | Executes the computation <tt>p</tt> but suppresses its results.
silent :: Orc a -> Orc b

-- | Lifts a list into an Orc monad.
liftList :: MonadPlus list => [a] -> list a

-- | Repeatedly executes the computation <tt>p</tt> and returns its
--   results. <a>repeating</a> works best when <tt>p</tt> is single-valued:
--   if <tt>p</tt> is multivalued Orc will spawn a repeating thread for
--   every result returned, resulting in an exponential blow-up of threads
--   (XXX: I don't think this was actually intended.)
repeating :: Orc a -> Orc a

-- | Runs a computation <tt>p</tt> and writes its results to the channel
--   <tt>ch</tt>.
runChan :: Chan a -> Orc a -> IO ()

-- | Takes the first result of <tt>p</tt>, the first result of <tt>q</tt>,
--   and applies them to <tt>f</tt>. The computations for <tt>p</tt> and
--   <tt>q</tt> are run in parallel.
sync :: (a -> b -> c) -> Orc a -> Orc b -> Orc c

-- | Runs the computation <tt>p</tt> and returns its first result, but
--   doesn't return before <tt>w</tt> seconds have elapsed.
notBefore :: Orc a -> Float -> Orc a

-- | Runs a list of Orc computations <tt>ps</tt> in parallel until they
--   produce their first result, and returns a list of all these results.
syncList :: [Orc a] -> Orc [a]

-- | Wait for a period of w seconds, then continue processing.
delay :: (RealFrac a, Show a) => a -> Orc ()

-- | Runs an Orc computation, eagerly printing out the results of an Orc
--   computation line-by-line.
printOrc :: Show a => Orc a -> IO ()

-- | Prompts the user for a string. Concurrency-safe.
prompt :: String -> Orc String

-- | Writes a string and newline to standard output. Concurrency-safe.
putStrLine :: String -> Orc ()

-- | Analogous to the list scan function, but the order in which the
--   combining function is applied to the results produced by <tt>p</tt> is
--   nondeterministic.
scan :: (a -> s -> s) -> s -> Orc a -> Orc s

-- | A variant of <a>&lt;+&gt;</a>, pronounced or-else, which performs and
--   returns the results of <tt>p</tt>, and if <tt>p</tt> produced no
--   answers go on and performa dn return the results of <tt>q</tt>.
(<?>) :: Orc a -> Orc a -> Orc a

-- | For each value produced by <tt>p</tt>, return a <tt>Left a</tt>. Once
--   <tt>p</tt> has finished, return a <tt>Right Int</tt> containing the
--   number of results produced.
count :: Orc a -> Orc (Either a Int)

-- | Collects all of the values of the computation <tt>p</tt> and delivers
--   them as a list when <tt>p</tt> is completed.
collect :: Orc a -> Orc [a]

-- | List-like functions
--   
--   Runs the computation <tt>p</tt> and returns the first <tt>n</tt>
--   results.
takeOrc :: Int -> Orc a -> Orc a

-- | Drops the first <tt>n</tt> results of the computation <tt>p</tt>, and
--   then returns the rest of the results.
dropOrc :: Int -> Orc a -> Orc a

-- | Zips the results of two computations <tt>p</tt> and <tt>q</tt>. When
--   one computation finishes, kill the other.
zipOrc :: Orc a -> Orc b -> Orc (a, b)

-- | Runs the computation <tt>p</tt>, and repeatedly puts its results
--   (tagged with <a>Just</a> into the <tt>vals</tt> <a>MVar</a>. Puts
--   <a>Nothing</a> if there are no results left. Stops executing when the
--   <tt>end</tt> MVar is filled.
sandbox :: Orc a -> MVar (Maybe a) -> MVar () -> Orc ()

-- | The rough inverse of <a>sandbox</a>, repeatedly reads values from the
--   <tt>vals</tt> <a>MVar</a> until <tt>j</tt> values have been read or
--   the <tt>vals</tt> MVar is exhausted (a <a>Nothing</a> is passed). When
--   there are no more values to be returned, fills the <tt>end</tt> MVar.
echo :: Int -> MVar (Maybe a) -> MVar () -> Orc a

-- | Like <a>echo</a>, repeatedly reads values from the <tt>pvals</tt> and
--   <tt>qvals</tt> <a>MVar</a>, returning tuples of the values until one
--   <a>MVar</a> is exhausted. When there are no more values to be
--   returned, fills the <tt>end</tt> MVar.
zipp :: MVar (Maybe a) -> MVar (Maybe b) -> MVar () -> Orc (a, b)

-- | Publish is a hyperstrict form of return. It is useful for combining
--   results from multiple <a>val</a> computations, providing a
--   synchronization point.
publish :: NFData a => a -> Orc a


module Orc
