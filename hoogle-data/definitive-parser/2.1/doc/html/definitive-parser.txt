-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A parser combinator library for the Definitive framework
--   
@package definitive-parser
@version 2.1

module Data.Syntax
newtype Lambda n m
Lambda :: (Maybe String, ThunkT n m () -> ThunkT n m ()) -> Lambda n m
class (Foldable (n (Lambda n m)), Traversable (n (Lambda n m))) => NodeFunctor n m
newtype SyntaxT n m a
SyntaxT :: (Free (n (Lambda n m)) a) -> SyntaxT n m a
newtype ThunkT n m a
ThunkT :: (Free (m :.: SyntaxT n m) a) -> ThunkT n m a
type Thunk n a = ThunkT n Id a
type NodeT n m a = n (Lambda n m) (ThunkT n m a)
force :: (NodeFunctor n m, Monad m) => ThunkT n m a -> ThunkT n m (NodeT n m a)
forcing :: (NodeFunctor n m, Monad m) => (NodeT n m a -> ThunkT n m a) -> ThunkT n m a -> ThunkT n m a
liftN :: (NodeFunctor n m, Unit m) => NodeT n m a -> SyntaxT n m (ThunkT n m a)
liftS :: (NodeFunctor n m, Unit m) => SyntaxT n m (ThunkT n m a) -> ThunkT n m a
liftNS :: (NodeFunctor n m, Unit m) => NodeT n m a -> ThunkT n m a
instance (NodeFunctor n m, MonadWriter w m) => MonadWriter w (ThunkT n m)
instance (NodeFunctor n m, MonadState s m) => MonadState s (ThunkT n m)
instance (NodeFunctor n m, MonadReader r m) => MonadReader r (ThunkT n m)
instance (NodeFunctor n m, Foldable m) => Foldable (ThunkT n m)
instance (NodeFunctor n m, Functor m) => Applicative (ThunkT n m)
instance (NodeFunctor n m, Functor m) => Functor (ThunkT n m)
instance NodeFunctor n m => Foldable (SyntaxT n m)
instance NodeFunctor n m => Applicative (SyntaxT n m)
instance NodeFunctor n m => Functor (SyntaxT n m)
instance Unit (ThunkT n m)
instance Unit (SyntaxT n m)
instance (NodeFunctor n m, Monad m) => MonadFree (m :.: SyntaxT n m) (ThunkT n m)
instance (NodeFunctor n m, Traversable m) => Traversable (ThunkT n m)
instance (NodeFunctor n m, Monad m) => Monad (ThunkT n m)
instance MonadFree (n (Lambda n m)) (SyntaxT n m)
instance NodeFunctor n m => Traversable (SyntaxT n m)
instance NodeFunctor n m => Monad (SyntaxT n m)
instance Semigroup (Lambda n m)
instance Show (Lambda n m)


-- | A module providing simple Parser combinator functionality. Useful for
--   small parsing tasks such as identifier parsing or command-line
--   argument parsing
module Language.Parser
newtype ParserT s m a
ParserT :: (StateT s (LogicT m) a) -> ParserT s m a
type Parser c a = ParserT c Id a
newtype ParserA m s a
ParserA :: (ParserT s m a) -> ParserA m s a
i'ParserA :: Iso (ParserA m s a) (ParserA m' s' a') (ParserT s m a) (ParserT s' m' a')
class Stream c s | s -> c
uncons :: Stream c s => s -> Maybe (c, s)
cons :: Stream c s => c -> s -> s

-- | Test if a Stream is empty
emptyStream :: Stream c s => s -> Bool
parserT :: (Monad n, Monad m) => Iso (ParserT s m a) (ParserT t n b) (s -> m [(s, a)]) (t -> n [(t, b)])
parser :: Iso (Parser s a) (Parser t b) (s -> [(s, a)]) (t -> [(t, b)])
ioParser :: Parser a b -> (a -> IO b)

-- | The <tt>(+)</tt> operator with lower priority
(<+>) :: Semigroup m => m -> m -> m
(>*>) :: Monad m => ParserT a m b -> ParserT b m c -> ParserT a m c
(<*<) :: Monad m => ParserT b m c -> ParserT a m b -> ParserT a m c
cut :: Monad m => ParserT s m a -> ParserT s m a

-- | Consume a token from the Stream
token :: (Monad m, Stream c s) => ParserT s m c

-- | Consume a token and succeed if it verifies a predicate
satisfy :: (Monad m, Stream c s) => (c -> Bool) -> ParserT s m c

-- | Parse a member of a set of values
oneOf :: (Eq c, Monad m, Foldable t, Stream c s) => t c -> ParserT s m c

-- | Parse anything but a member of a set
noneOf :: (Eq c, Monad m, Foldable t, Stream c s) => t c -> ParserT s m c

-- | Consume a single fixed token or fail.
single :: (Eq c, Monad m, Stream c s) => c -> ParserT s m ()

-- | Consume a structure of characters or fail
several :: (Eq c, Monad m, Foldable t, Stream c s) => t c -> ParserT s m ()

-- | The remaining Stream to parse
remaining :: Monad m => ParserT s m s

-- | Succeed only at the End Of Input.
eoi :: (Monad m, Stream c s) => ParserT s m ()
readable :: (Monad m, Read a) => ParserT String m a

-- | Parse a litteral decimal number
number :: (Monad m, Stream Char s, Num n) => ParserT s m n

-- | Parse a single decimal digit
digit :: (Monad m, Stream Char s) => ParserT s m Char
letter :: (Monad m, Stream Char s) => ParserT s m Char
alNum :: (Monad m, Stream Char s) => ParserT s m Char

-- | Parse a delimited string, using <tt>\\</tt> as the quoting character
quotedString :: (Monad m, Stream Char s) => Char -> ParserT s m String

-- | A single space
space :: (Monad m, Stream Char s) => ParserT s m Char

-- | Many spaces
spaces :: (Monad m, Stream Char s) => ParserT s m String

-- | The end of a line
eol :: (Monad m, Stream Char s) => ParserT s m ()

-- | Parse zero, one or more successive occurences of a parser.
many :: Monad m => ParserT c m a -> ParserT c m [a]

-- | Parse one or more successiveÃ© occurences of a parser.
many1 :: Monad m => ParserT c m a -> ParserT c m [a]

-- | Parse zero or more successive occurences of a parser separated by
--   occurences of a second parser.
sepBy :: Monad m => ParserT c m a -> ParserT c m b -> ParserT c m [a]

-- | Parse one or more successive occurences of a parser separated by
--   occurences of a second parser.
sepBy1 :: Monad m => ParserT c m a -> ParserT c m b -> ParserT c m [a]

-- | Skip many occurences of a parser
skipMany :: Monad m => ParserT c m a -> ParserT c m ()

-- | Skip multiple occurences of a parser
skipMany1 :: Monad m => ParserT c m a -> ParserT c m ()

-- | Chain an operator with an initial value
chainl :: (Stream c s, Monad m) => ParserT s m a -> ParserT s m (a -> b -> a) -> ParserT s m b -> ParserT s m a

-- | Chain an operator with an initial value and several tail values.
chainr :: (Stream c s, Monad m) => ParserT s m a -> ParserT s m (b -> a -> a) -> ParserT s m b -> ParserT s m a

-- | Try to consume a parser. Return a default value when it fails.
option :: Monad m => a -> ParserT s m a -> ParserT s m a
instance Unit (ParserT s m)
instance Functor (ParserT s m)
instance Semigroup (ParserT s m a)
instance Monoid (ParserT s m a)
instance Applicative (ParserT s m)
instance Monad m => MonadFix (ParserT s m)
instance Monad m => MonadState s (ParserT s m)
instance Monad m => Arrow (ParserA m)
instance Monad m => Choice (ParserA m)
instance Monad m => Split (ParserA m)
instance Monad m => Category (ParserA m)
instance Monad m => Deductive (ParserA m)
instance ConcreteMonad (ParserT s)
instance MonadTrans (ParserT s)
instance Monad m => Monad (ParserT s m)
instance (Monad m, Stream Char s) => IsString (ParserT s m a)

module Language.Syntax.CmdArgs

-- | Each <a>OptDescr</a> describes a single option.
--   
--   The arguments to <a>Option</a> are:
--   
--   <ul>
--   <li>list of short option characters</li>
--   <li>list of long option strings (without "--")</li>
--   <li>argument descriptor</li>
--   <li>explanation of option for user</li>
--   </ul>
data OptDescr a :: * -> *
Option :: [Char] -> [String] -> ArgDescr a -> String -> OptDescr a

-- | Describes whether an option takes an argument or not, and if so how
--   the argument is injected into a value of type <tt>a</tt>.
data ArgDescr a :: * -> *

-- | no argument expected
NoArg :: a -> ArgDescr a

-- | option requires argument
ReqArg :: (String -> a) -> String -> ArgDescr a

-- | optional argument
OptArg :: (Maybe String -> a) -> String -> ArgDescr a

-- | Return a string describing the usage of a command, derived from the
--   header (first argument) and the options described by the second
--   argument.
usageInfo :: String -> [OptDescr a] -> String

-- | Create a Parser that preprocesses the command-line arguments,
--   splitting options and their arguments into a user-defined data type.
tokenize :: Monad m => [OptDescr a] -> (String -> a) -> ParserT [String] m [a]

module Language.Syntax.Regex
regex :: Parser String (Parser String ([(String, String)], String))
runRegex :: String -> String -> [([(String, String)], String)]

module Data.Syntax.Node
data Node k b a
ValList :: [a] -> Node k b a
Dictionary :: (Map k a) -> Node k b a
Quote :: (Node k b a) -> Node k b a
Text :: k -> Node k b a
Function :: b -> Node k b a
type ThunkN k m = ThunkT (Node k) m ()
type Env k m = Map k (ThunkT (Node k) m ())
nil :: SyntaxT (Node k) m a
shape :: Node k b a -> String
dict :: Traversal' (Node k b a) (Map k a)
funcall :: (Eq k, Unit m) => ThunkT (Node k) m a -> ThunkT (Node k) m a -> ThunkT (Node k) m a
builtin :: (Eq k, Unit m) => (ThunkN k m -> ThunkN k m) -> ThunkN k m
builtin2 :: (Eq k, Unit m) => (ThunkN k m -> ThunkN k m -> ThunkN k m) -> ThunkN k m
builtin3 :: (Eq k, Unit m) => (ThunkN k m -> ThunkN k m -> ThunkN k m -> ThunkN k m) -> ThunkN k m
lambda :: (Matching k, MonadReader (Env k m) m) => ThunkN k m -> ThunkN k m -> ThunkN k m
lambdaSum :: (Eq k, Monad m) => [ThunkN k m -> ThunkN k m] -> ThunkN k m -> ThunkN k m
reduce :: (Ord k, MonadReader (Env k m) m) => ThunkN k m -> ThunkN k m
instance Matching String
instance (Show k, Show b, Show a) => Show (Node k b a)
instance Eq k => NodeFunctor (Node k) m
instance Eq k => Traversable (Node k b)
instance Foldable (Node k b)
instance Functor (Node k b)

module Data.Serialize
class Serializable t
encode :: Serializable t => t -> Builder
serializable :: Serializable t => Parser Bytes t

-- | <a>Builder</a>s denote sequences of bytes. They are <a>Monoid</a>s
--   where <a>mempty</a> is the zero-length sequence and <a>mappend</a> is
--   concatenation, which runs in <i>O(1)</i>.
data Builder :: *
bytesBuilder :: Bytes :<->: Builder
chunkBuilder :: Chunk :<->: Builder
serialize :: Serializable t => t -> Bytes
serial :: (Serializable t, Serializable t') => Traversal t t' Bytes Bytes

-- | Encode a single unsigned byte as-is.
word8 :: Word8 -> Builder

-- | 8-bit unsigned integer type
data Word8 :: *

-- | 32-bit unsigned integer type
data Word32 :: *

-- | 64-bit unsigned integer type
data Word64 :: *
data Either3 a b c
Alt3l'1 :: a -> Either3 a b c
Alt3l'2 :: b -> Either3 a b c
Alt3l'3 :: c -> Either3 a b c
coerceEncode :: Serializable t => (t -> t') -> (t' -> Builder)
coerceSerializable :: Serializable t => (t -> t') -> (Parser Bytes t')
instance (Serializable a, Serializable b, Serializable c) => Serializable (Either3 a b c)
instance (Serializable a, Serializable b) => Serializable (a :+: b)
instance (Serializable a, Serializable b, Serializable c, Serializable d, Serializable e) => Serializable (a, b, c, d, e)
instance (Serializable a, Serializable b, Serializable c, Serializable d) => Serializable (a, b, c, d)
instance (Serializable a, Serializable b, Serializable c) => Serializable (a, b, c)
instance (Serializable a, Serializable b) => Serializable (a :*: b)
instance Serializable a => Serializable (Range a)
instance (Ord a, Serializable a) => Serializable (Set a)
instance (Ord k, Ord a, Serializable k, Serializable a) => Serializable (Bimap k a)
instance (Ord k, Serializable k, Serializable a) => Serializable (Map k a)
instance Serializable a => Serializable [a]
instance Serializable a => Serializable (Maybe a)
instance Serializable Integer
instance Serializable Int
instance Serializable Word64
instance Serializable Word32
instance Serializable Word8
instance Serializable Char
instance Monoid Builder
instance Semigroup Builder
instance Disjonctive Word64
instance Disjonctive Word32
instance Disjonctive Word8
instance Ring Word64
instance Semiring Word64
instance Ring Word32
instance Semiring Word32
instance Ring Word8
instance Semiring Word8
instance Monoid Word64
instance Semigroup Word64
instance Monoid Word32
instance Semigroup Word32
instance Monoid Word8
instance Semigroup Word8
