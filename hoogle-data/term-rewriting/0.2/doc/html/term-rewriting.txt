-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Term Rewriting Library
--   
@package term-rewriting
@version 0.2

module Data.Rewriting.Pos

-- | A position in a term. Arguments are counted from 0.
--   
--   A position describes a path in the tree representation of a term. The
--   empty position <tt>[]</tt> denotes the root of the term. A position
--   <tt>[0,1]</tt> denotes the 2nd child of the 1st child of the root
--   (counting children from left to right).
type Pos = [Int]

-- | <tt>p `above` q</tt> checks whether <tt>p</tt> is above <tt>q</tt> (in
--   the tree representation of a term). A position <tt>p</tt> is above a
--   position <tt>q</tt>, whenever <tt>p</tt> is a prefix of <tt>q</tt>.
above :: Pos -> Pos -> Bool

-- | <tt>p `below` q</tt> checks whether <tt>p</tt> is below <tt>q</tt>,
--   that is to say that <tt>q</tt> is above <tt>p</tt>.
below :: Pos -> Pos -> Bool

-- | <tt>p `parallelTo` q</tt> checks whether <tt>p</tt> is parallel to
--   <tt>q</tt>, that is to say that <tt>p</tt> and <tt>q</tt> do not lie
--   on the same path.
parallelTo :: Pos -> Pos -> Bool

-- | <tt>p `leftOf` q</tt> checks whether <tt>p</tt> is left of <tt>q</tt>.
--   This is only possible if <tt>p</tt> and <tt>q</tt> do not lie on the
--   same path (i.e., are parallel to each other).
leftOf :: Pos -> Pos -> Bool

-- | <tt>p `rightOf` q</tt> checks whether <tt>p</tt> is right of
--   <tt>q</tt>.
rightOf :: Pos -> Pos -> Bool

module Data.Rewriting.Term.Type
data Term f v

-- | Variable
Var :: v -> Term f v

-- | Function application
Fun :: f -> [Term f v] -> Term f v

-- | Folding terms.
--   
--   <pre>
--   &gt;&gt;&gt; fold (\v -&gt; 1) (\f xs -&gt; 1 + sum xs) (Fun 'f' [Var 1, Fun 'g' []])
--   3 -- size of the given term
--   </pre>
fold :: (v -> a) -> (f -> [a] -> a) -> Term f v -> a

-- | Mapping terms: Rename function symbols and variables.
--   
--   <pre>
--   &gt;&gt;&gt; map succ pred (Fun 'f' [Var 2, Fun 'g' []])
--   Fun 'e' [Var 3,Fun 'f' []]
--   </pre>
map :: (f -> f') -> (v -> v') -> Term f v -> Term f' v'
instance (Show f, Show v) => Show (Term f v)
instance (Eq f, Eq v) => Eq (Term f v)
instance (Ord f, Ord v) => Ord (Term f v)

module Data.Rewriting.Term.Pretty

-- | Given a pretty printer <tt>f</tt> for function symbols and pretty
--   printer <tt>v</tt> for variables <tt>prettyTerm f v</tt> produces a
--   pretty printer for terms
prettyTerm :: (f -> Doc) -> (v -> Doc) -> Term f v -> Doc
instance (Pretty f, Pretty v) => Pretty (Term f v)

module Data.Rewriting.Term.Parse

-- | <tt>fromString xs s</tt> parsers a term from the string <tt>s</tt>,
--   where elements of <tt>xs</tt> are considered as variables.
fromString :: [String] -> String -> Either ParseError (Term String String)

-- | <tt>parse fun var</tt> is a parser for terms, where <tt>fun</tt> and
--   <tt>var</tt> are parsers for function symbols and variables,
--   respectively. The <tt>var</tt> parser has a higher priority than the
--   <tt>fun</tt> parser. Hence, whenever <tt>var</tt> succeeds, the token
--   is treated as a variable.
--   
--   Note that the user has to take care of handling trailing white space
--   in <tt>fun</tt> and <tt>var</tt>.
parse :: Stream s m Char => ParsecT s u m f -> ParsecT s u m v -> ParsecT s u m (Term f v)

-- | Like <a>fromString</a>, but the result is wrapped in the IO monad,
--   making this function useful for interactive testing.
--   
--   <pre>
--   &gt;&gt;&gt; parseIO ["x","y"] "f(x,c)"
--   Fun "f" [Var "x",Fun "c" []]
--   </pre>
parseIO :: [String] -> String -> IO (Term String String)

-- | <tt>parseFun ident</tt> parses function symbols defined by
--   <tt>ident</tt>.
parseFun :: Stream s m Char => ParsecT s u m String -> ParsecT s u m String

-- | <tt>parseVar ident vars</tt> parses variables as defined by
--   <tt>ident</tt> and with the additional requirement that the result is
--   a member of <tt>vars</tt>.
parseVar :: Stream s m Char => ParsecT s u m String -> [String] -> ParsecT s u m String

-- | <tt>parseWST xs</tt> is a parser for terms following the conventions
--   of the ancient ASCII input format of the termination competition:
--   every <tt>Char</tt> that is neither a white space (according to
--   <a>isSpace</a>) nor one of '<tt>(</tt>', '<tt>)</tt>', or
--   '<tt>,</tt>', is considered a letter. An identifier is a non-empty
--   sequence of letters and it is treated as variable iff it is contained
--   in <tt>xs</tt>.
parseWST :: Stream s m Char => [String] -> ParsecT s u m (Term String String)

module Data.Rewriting.Rule.Type

-- | Rewrite rule with left-hand side and right-hand side.
data Rule f v
Rule :: Term f v -> Term f v -> Rule f v
lhs :: Rule f v -> Term f v
rhs :: Rule f v -> Term f v
instance (Ord f, Ord v) => Ord (Rule f v)
instance (Eq f, Eq v) => Eq (Rule f v)
instance (Show f, Show v) => Show (Rule f v)

module Data.Rewriting.Substitution.Type

-- | A substitution, mapping variables to terms. Substitutions are equal to
--   the identity almost everywhere.
type Subst f v = GSubst v f v

-- | A generalised? substitution: a finite, partial map from variables to
--   terms with a different variable type.
data GSubst v f v'
fromMap :: Map v (Term f v') -> GSubst v f v'
toMap :: GSubst v f v' -> Map v (Term f v')
instance (Show v, Show f, Show v') => Show (GSubst v f v')

module Data.Rewriting.Substitution.Match

-- | Match two terms. If matching succeeds, return the resulting
--   subtitution. We have the following property:
--   
--   <pre>
--   match t u == Just s   ==&gt;   apply s t == gapply s t == u
--   </pre>
match :: (Eq f, Ord v, Eq v') => Term f v -> Term f v' -> Maybe (GSubst v f v')

module Data.Rewriting.Term.Ops

-- | Return the list of all function symbols in the term, from left to
--   right.
--   
--   <pre>
--   &gt;&gt;&gt; funs (Fun 'f' [Var 3, Fun 'g' [Fun 'f' []]])
--   "fgf"
--   </pre>
funs :: Term f v -> [f]

-- | Difference List version of <a>funs</a>. We have <tt>funsDL t vs = funs
--   t ++ vs</tt>.
funsDL :: Term f v -> [f] -> [f]

-- | Return the list of all variables in the term, from left to right.
--   
--   <pre>
--   &gt;&gt;&gt; vars (Fun 'g' [Var 3, Fun 'f' [Var 1, Var 2, Var 3]])
--   [3,1,2,3]
--   </pre>
vars :: Term f v -> [v]

-- | Difference List version of <a>vars</a>. We have <tt>varsDL t vs = vars
--   t ++ vs</tt>.
varsDL :: Term f v -> [v] -> [v]

-- | Return the root symbol of the given term.
--   
--   <pre>
--   &gt;&gt;&gt; root (Fun 'f' [Var 1, Fun 'g' []])
--   Right 'f'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; root (Var 1)
--   Left 1
--   </pre>
root :: Term f v -> Either v f

-- | Annotate each occurrence of a function symbol with its actual arity,
--   i.e., its number of arguments.
--   
--   <pre>
--   &gt;&gt;&gt; withArity (Fun 'f' [Var 1, Fun 'f' []])
--   Fun ('f',2) [Var 1,Fun ('f',0) []]
--   </pre>
withArity :: Term f v -> Term (f, Int) v

-- | Return the subterm at a given position.
subtermAt :: Term f v -> Pos -> Maybe (Term f v)

-- | Return the list of all proper subterms.
--   
--   <pre>
--   &gt;&gt;&gt; properSubterms (Fun 'g' [Fun 'f' [Var 1], Fun 'f' [Var 1]])
--   [Fun 'f' [Var 1],Var 1,Fun 'f' [Var 1],Var 1]
--   </pre>
properSubterms :: Term f v -> [Term f v]

-- | Return the list of all subterms.
--   
--   <pre>
--   subterms t = t : properSubterms t
--   </pre>
subterms :: Term f v -> [Term f v]

-- | replace a subterm at a given position.
replaceAt :: Term f v -> Pos -> Term f v -> Maybe (Term f v)

-- | Rename the variables in a term.
--   
--   <pre>
--   &gt;&gt;&gt; rename (+ 1) (Fun 'f' [Var 1, Fun 'g' [Var 2]])
--   (Fun 'f' [Var 2, Fun 'g' [Var 3]])
--   </pre>
rename :: (v -> v') -> Term f v -> Term f v'

-- | Return <a>True</a> if the term is a variable, <a>False</a> otherwise.
isVar :: Term f v -> Bool

-- | Return <a>True</a> if the term is a function application, <a>False</a>
--   otherwise.
isFun :: Term f v -> Bool

-- | Check whether the term is a ground term, i.e., contains no variables.
isGround :: Term f v -> Bool

-- | Check whether the term is linear, i.e., contains each variable at most
--   once.
isLinear :: Ord v => Term f v -> Bool

-- | Check whether the first term is an instance of the second term.
isInstanceOf :: (Eq f, Ord v, Ord v') => Term f v -> Term f v' -> Bool

-- | Check whether two terms are variants of each other.
isVariantOf :: (Eq f, Ord v, Ord v') => Term f v -> Term f v' -> Bool

module Data.Rewriting.Substitution.Parse
fromString :: [String] -> String -> Either ParseError (Subst String String)
parse :: Ord v => Parsec String u f -> Parsec String u v -> Parsec String u (Subst f v)
parseIO :: [String] -> String -> IO (Subst String String)

module Data.Rewriting.Term
data Term f v

-- | Variable
Var :: v -> Term f v

-- | Function application
Fun :: f -> [Term f v] -> Term f v

-- | Folding terms.
--   
--   <pre>
--   &gt;&gt;&gt; fold (\v -&gt; 1) (\f xs -&gt; 1 + sum xs) (Fun 'f' [Var 1, Fun 'g' []])
--   3 -- size of the given term
--   </pre>
fold :: (v -> a) -> (f -> [a] -> a) -> Term f v -> a

-- | Mapping terms: Rename function symbols and variables.
--   
--   <pre>
--   &gt;&gt;&gt; map succ pred (Fun 'f' [Var 2, Fun 'g' []])
--   Fun 'e' [Var 3,Fun 'f' []]
--   </pre>
map :: (f -> f') -> (v -> v') -> Term f v -> Term f' v'

-- | Return the list of all variables in the term, from left to right.
--   
--   <pre>
--   &gt;&gt;&gt; vars (Fun 'g' [Var 3, Fun 'f' [Var 1, Var 2, Var 3]])
--   [3,1,2,3]
--   </pre>
vars :: Term f v -> [v]

-- | Return the list of all function symbols in the term, from left to
--   right.
--   
--   <pre>
--   &gt;&gt;&gt; funs (Fun 'f' [Var 3, Fun 'g' [Fun 'f' []]])
--   "fgf"
--   </pre>
funs :: Term f v -> [f]

module Data.Rewriting.Rule.Pretty
prettyRule :: Doc -> (f -> Doc) -> (v -> Doc) -> Rule f v -> Doc
instance (Pretty f, Pretty v) => Pretty (Rule f v)

module Data.Rewriting.Substitution.Pretty
prettySubst :: (f -> Doc) -> (v -> Doc) -> Subst f v -> Doc
instance (Pretty f, Pretty v) => Pretty (Subst f v)
instance (Pretty v, Pretty f, Pretty v') => Pretty (GSubst v f v')

module Data.Rewriting.Context.Type
data Ctxt f v

-- | Hole
Hole :: Ctxt f v

-- | Non-empty context
Ctxt :: f -> [Term f v] -> (Ctxt f v) -> [Term f v] -> Ctxt f v
instance (Show f, Show v) => Show (Ctxt f v)
instance (Eq f, Eq v) => Eq (Ctxt f v)
instance (Ord f, Ord v) => Ord (Ctxt f v)

module Data.Rewriting.Substitution.Ops

-- | Apply a substitution, assuming that it's the identity on variables not
--   mentionend in the substitution.
apply :: Ord v => Subst f v -> Term f v -> Term f v

-- | Liftting of <a>apply</a> to rules: applies the given substitution to
--   left- and right-hand side.
applyRule :: Ord v => Subst f v -> Rule f v -> Rule f v

-- | Liftting of <a>apply</a> to contexts.
applyCtxt :: Ord v => Subst f v -> Ctxt f v -> Ctxt f v

-- | Apply a substitution, assuming that it's total. If the term contains a
--   variable not defined by the substitution, return <a>Nothing</a>.
gApply :: Ord v => GSubst v f v' -> Term f v -> Maybe (Term f v')

-- | Compose substitutions. We have
--   
--   <pre>
--   (s1 `compose` s2) `apply` t = s1 `apply` (s2 `apply` t).
--   </pre>
compose :: Ord v => Subst f v -> Subst f v -> Subst f v

-- | Merge two substitutions. The operation fails if some variable is
--   different terms by the substitutions.
merge :: (Ord v, Eq f, Eq v') => GSubst v f v' -> GSubst v f v' -> Maybe (GSubst v f v')

module Data.Rewriting.Substitution.Unify

-- | Unify two terms. If unification succeeds, return a most general
--   unifier of the given terms. We have the following property:
--   
--   <pre>
--   unify t u == Just s   ==&gt;   apply s t == apply s u
--   </pre>
--   
--   <i>O(n log(n))</i>, where <i>n</i> is the apparent size of the
--   arguments. Note that the apparent size of the result may be
--   exponential due to shared subterms.
unify :: (Eq f, Ord v) => Term f v -> Term f v -> Maybe (Subst f v)

-- | Unify two terms. This is a simple implementation for testing purposes,
--   and may be removed in future versions of this library.
unifyRef :: (Eq f, Ord v) => Term f v -> Term f v -> Maybe (Subst f v)

module Data.Rewriting.Substitution

-- | A generalised? substitution: a finite, partial map from variables to
--   terms with a different variable type.
data GSubst v f v'

-- | A substitution, mapping variables to terms. Substitutions are equal to
--   the identity almost everywhere.
type Subst f v = GSubst v f v

-- | Apply a substitution, assuming that it's total. If the term contains a
--   variable not defined by the substitution, return <a>Nothing</a>.
gApply :: Ord v => GSubst v f v' -> Term f v -> Maybe (Term f v')

-- | Apply a substitution, assuming that it's the identity on variables not
--   mentionend in the substitution.
apply :: Ord v => Subst f v -> Term f v -> Term f v

-- | Compose substitutions. We have
--   
--   <pre>
--   (s1 `compose` s2) `apply` t = s1 `apply` (s2 `apply` t).
--   </pre>
compose :: Ord v => Subst f v -> Subst f v -> Subst f v

module Data.Rewriting.Rule.Ops

-- | Lifting of <a>funs</a> to <a>Rule</a>: returns the list of function
--   symbols in left- and right-hand sides.
--   
--   <pre>
--   &gt;&gt;&gt; funs $ Rule {lhs = Fun 'f' [Var 3, Fun 'g' [Fun 'f' []]], rhs = Fun 'h' [Fun 'f' []]}
--   "fgfhf"
--   </pre>
funs :: Rule f v -> [f]

-- | Difference List version of <a>funs</a>. We have <tt>funsDL r vs = funs
--   r ++ vs</tt>.
funsDL :: Rule f v -> [f] -> [f]

-- | Lifting of <a>vars</a> to <a>Rule</a>: returns the list of variables
--   in left- and right-hand sides.
--   
--   <pre>
--   &gt;&gt;&gt; vars $ Rule {lhs = Fun 'g' [Var 3, Fun 'f' [Var 1, Var 2, Var 3]], rhs = Fun 'g' [Var 4, Var 3]}
--   [3,1,2,3,4,3]
--   </pre>
vars :: Rule f v -> [v]

-- | Difference List version of <a>vars</a>. We have <tt>varsDL r vs = vars
--   r ++ vs</tt>.
varsDL :: Rule f v -> [v] -> [v]

-- | Apply a function to the lhs of a rule.
left :: (Term f v -> a) -> Rule f v -> a

-- | Apply a function to the rhs of a rule.
right :: (Term f v -> a) -> Rule f v -> a

-- | Lifting of <a>rename</a> to <a>Rule</a>: renames left- and right-hand
--   sides. &gt;&gt;&gt; rename (+ 1) $ Rule {lhs = (Fun <tt>f</tt> [Var 1,
--   Fun <tt>g</tt> [Var 2]]), rhs = Fun <tt>g</tt> [Var 1]} Rule {lhs =
--   (Fun <tt>f</tt> [Var 2, Fun <tt>g</tt> [Var 3]]), rhs = Fun <tt>g</tt>
--   [Var 2]}
rename :: (v -> v') -> Rule f v -> Rule f v'

-- | Test whether the given predicate is true for both sides of a rule.
both :: (Term f v -> Bool) -> Rule f v -> Bool

-- | Check whether both sides of the given rule are linear.
isLinear :: Ord v => Rule f v -> Bool

-- | Check whether the left hand side of the given rule is linear.
isLeftLinear :: Ord v => Rule f v -> Bool

-- | Check whether the right hand side of the given rule is linear.
isRightLinear :: Ord v => Rule f v -> Bool

-- | Check whether both sides of the given rule is are ground terms.
isGround :: Rule f v -> Bool

-- | Check whether the left hand side of the given rule is a ground term.
isLeftGround :: Rule f v -> Bool

-- | Check whether the right hand side of the given rule is a ground term.
isRightGround :: Rule f v -> Bool

-- | Check whether the given rule is erasing, i.e., if some variable occurs
--   in the left hand side but not in the right hand side.
isErasing :: Ord v => Rule f v -> Bool

-- | Check whether the given rule is creating, i.e., if some variable
--   occurs in its right hand side that does not occur in its left hand
--   side.
--   
--   This is the dual of <a>isErasing</a>. The term <i>creating</i> is
--   non-standard. Creating rules are usually forbidden. See also
--   <a>isValid</a>.
isCreating :: Ord v => Rule f v -> Bool

-- | Check whether the given rule is duplicating, i.e., if some variable
--   occurs more often in its right hand side than in its left hand side.
isDuplicating :: Ord v => Rule f v -> Bool

-- | Check whether the given rule is collapsing, i.e., if its right hand
--   side is a variable.
isCollapsing :: Rule f v -> Bool

-- | Check whether the given rule is expanding, i.e., if its left hand
--   sides is a variable.
--   
--   This is the dual of <a>isCollapsing</a>. The term <i>expanding</i> is
--   non-standard. Expanding rules are usually forbidden. See also
--   <a>isValid</a>.
isExpanding :: Rule f v -> Bool

-- | Check whether the given rule is non-creating and non-expanding. See
--   also <a>isCreating</a> and <a>isExpanding</a>
isValid :: Ord v => Rule f v -> Bool

-- | Check whether the first rule is an instance of the second rule.
isInstanceOf :: (Eq f, Ord v, Ord v') => Rule f v -> Rule f v' -> Bool

-- | Check whether two rules are variants of each other.
isVariantOf :: (Eq f, Ord v, Ord v') => Rule f v -> Rule f v' -> Bool

module Data.Rewriting.Rule

-- | Rewrite rule with left-hand side and right-hand side.
data Rule f v
Rule :: Term f v -> Term f v -> Rule f v
lhs :: Rule f v -> Term f v
rhs :: Rule f v -> Term f v

module Data.Rewriting.Problem.Type
data StartTerms
AllTerms :: StartTerms
BasicTerms :: StartTerms
data Strategy
Innermost :: Strategy
Full :: Strategy
Outermost :: Strategy
data RulesPair f v
RulesPair :: [Rule f v] -> [Rule f v] -> RulesPair f v
strictRules :: RulesPair f v -> [Rule f v]
weakRules :: RulesPair f v -> [Rule f v]
data Problem f v
Problem :: StartTerms -> Strategy -> Maybe [Theory f v] -> RulesPair f v -> [v] -> [f] -> Maybe String -> Problem f v
startTerms :: Problem f v -> StartTerms
strategy :: Problem f v -> Strategy
theory :: Problem f v -> Maybe [Theory f v]
rules :: Problem f v -> RulesPair f v
variables :: Problem f v -> [v]
symbols :: Problem f v -> [f]
comment :: Problem f v -> Maybe String
data Theory f v
SymbolProperty :: String -> [f] -> Theory f v
Equations :: [Rule f v] -> Theory f v
allRules :: RulesPair f v -> [Rule f v]
instance Eq StartTerms
instance Show StartTerms
instance Eq Strategy
instance Show Strategy
instance (Eq f, Eq v) => Eq (RulesPair f v)
instance (Show f, Show v) => Show (RulesPair f v)
instance (Eq f, Eq v) => Eq (Theory f v)
instance (Show f, Show v) => Show (Theory f v)
instance (Show f, Show v) => Show (Problem f v)

module Data.Rewriting.Problem.Pretty
prettyProblem :: (Eq f, Eq v) => (f -> Doc) -> (v -> Doc) -> Problem f v -> Doc
prettyWST :: (f -> Doc) -> (v -> Doc) -> Problem f v -> Doc
prettyWST' :: (Pretty f, Pretty v) => Problem f v -> Doc
instance (Eq f, Eq v, Pretty f, Pretty v) => Pretty (Problem f v)


-- | Simple rewriting.
--   
--   Note: The rules are assumed to be non-creating, i.e., variables on the
--   rhs should also occur on the lhs. Rules violating this constraint will
--   have no effect.
module Data.Rewriting.Rules.Rewrite

-- | A reduct. It contains the resulting term, the position that the term
--   was rewritten at, and the applied rule.
data Reduct f v v'
Reduct :: Term f v -> Pos -> Rule f v' -> GSubst v' f v -> Reduct f v v'
result :: Reduct f v v' -> Term f v
pos :: Reduct f v v' -> Pos
rule :: Reduct f v v' -> Rule f v'
subst :: Reduct f v v' -> GSubst v' f v

-- | A rewrite strategy.
type Strategy f v v' = Term f v -> [Reduct f v v']

-- | Full rewriting: Apply rules anywhere in the term.
--   
--   Reducts are returned in pre-order: the first is a leftmost, outermost
--   redex.
fullRewrite :: (Ord v', Eq v, Eq f) => [Rule f v'] -> Strategy f v v'

-- | Outer rewriting: Apply rules at outermost redexes.
--   
--   Reducts are returned in left to right order.
outerRewrite :: (Ord v', Eq v, Eq f) => [Rule f v'] -> Strategy f v v'

-- | Inner rewriting: Apply rules at innermost redexes.
--   
--   Reducts are returned in left to right order.
innerRewrite :: (Ord v', Eq v, Eq f) => [Rule f v'] -> Strategy f v v'

-- | Root rewriting: Apply rules only at the root of the term.
--   
--   This is mainly useful as a building block for various rewriting
--   strategies.
rootRewrite :: (Ord v', Eq v, Eq f) => [Rule f v'] -> Strategy f v v'

-- | Nested rewriting: Apply a rewriting strategy to all arguments of a
--   function symbol, left to right. For variables, the result will be
--   empty.
--   
--   This is another building block for rewriting strategies.
nested :: Strategy f v v' -> Strategy f v v'

-- | Return a list of contexts of a list. Each returned element is an
--   element index (starting from 0), a function that replaces the list
--   element by a new one, and the original element.
listContexts :: [a] -> [(Int, a -> [a], a)]

module Data.Rewriting.CriticalPair.Type

-- | A critical pair. Critical pairs (should) have the following
--   properties:
--   
--   <pre>
--   top   == Context.ofTerm top pos (Term.map Left id (Rule.lhs leftRule))
--   left  == Context.ofTerm top pos (Term.map Left id (Rule.rhs leftRule))
--   top   == Substitution.apply subst (Term.map Right id (Rule.lhs rightRule))
--   right == Substitution.apply subst (Term.map Right id (Rule.rhs rightRule))
--   </pre>
--   
--   Furthermore, <tt>pos</tt> is a non-variable position of <tt>(lhs
--   rightRule)</tt> and <tt>subst</tt> is a most general substitution with
--   these properties.
data CP f v v'
CP :: Term f (Either v v') -> Term f (Either v v') -> Term f (Either v v') -> Rule f v -> Pos -> Rule f v' -> Subst f (Either v v') -> CP f v v'

-- | left reduct
left :: CP f v v' -> Term f (Either v v')

-- | source
top :: CP f v v' -> Term f (Either v v')

-- | right reduct
right :: CP f v v' -> Term f (Either v v')

-- | rule applied on left side
leftRule :: CP f v v' -> Rule f v

-- | position of left rule application
leftPos :: CP f v v' -> Pos

-- | rule applied on right side
rightRule :: CP f v v' -> Rule f v'

-- | common substitution of the rewrite steps
subst :: CP f v v' -> Subst f (Either v v')

module Data.Rewriting.Context.Ops

-- | Apply a context to a term (i.e., replace the hole in the context by
--   the term).
apply :: Ctxt f v -> Term f v -> Term f v

-- | Compose two contexts (i.e., replace the hole in the left context by
--   the right context).
compose :: Ctxt f v -> Ctxt f v -> Ctxt f v

-- | Create a context from a term by placing the hole at a specific
--   position.
ofTerm :: Term f v -> Pos -> Maybe (Ctxt f v)

module Data.Rewriting.Context
data Ctxt f v

-- | Hole
Hole :: Ctxt f v

-- | Non-empty context
Ctxt :: f -> [Term f v] -> (Ctxt f v) -> [Term f v] -> Ctxt f v

-- | Create a context from a term by placing the hole at a specific
--   position.
ofTerm :: Term f v -> Pos -> Maybe (Ctxt f v)

-- | Apply a context to a term (i.e., replace the hole in the context by
--   the term).
apply :: Ctxt f v -> Term f v -> Term f v

module Data.Rewriting.Rules.Ops

-- | Lifting of Term.<a>funs</a> to list of rules.
funs :: [Rule f v] -> [f]

-- | Difference List version of <a>funs</a>. We have <tt>funsDL r vs = funs
--   r ++ vs</tt>.
funsDL :: [Rule f v] -> [f] -> [f]

-- | Lifting of Term.<a>vars</a> to list of rules.
vars :: [Rule f v] -> [v]

-- | Difference List version of <a>vars</a>. We have <tt>varsDL r vs = vars
--   r ++ vs</tt>.
varsDL :: [Rule f v] -> [v] -> [v]

-- | <tt>lhss rs</tt> returns the list of left-hand sides of <tt>rs</tt>
lhss :: [Rule f v] -> [Term f v]

-- | <tt>lhss rs</tt> returns the list of right-hand sides of <tt>rs</tt>
rhss :: [Rule f v] -> [Term f v]

-- | Restrict the rules to those only using function symbols satisfying the
--   given predicate.
restrictFuns :: (f -> Bool) -> [Rule f v] -> [Rule f v]

-- | Returns <a>True</a> iff all given rules satisfy <a>isLinear</a>
isLinear :: Ord v => [Rule f v] -> Bool

-- | Returns <a>True</a> iff all given rules satisfy <a>isLeftLinear</a>
isLeftLinear :: Ord v => [Rule f v] -> Bool

-- | Returns <a>True</a> iff all given rules satisfy <a>isRightLinear</a>
isRightLinear :: Ord v => [Rule f v] -> Bool

-- | Returns <a>True</a> iff all given rules satisfy <a>isGroundLinear</a>
isGround :: [Rule f v] -> Bool

-- | Returns <a>True</a> iff all given rules satisfy <a>isLeftGround</a>
isLeftGround :: [Rule f v] -> Bool

-- | Returns <a>True</a> iff all given rules satisfy <a>isRightGround</a>
isRightGround :: [Rule f v] -> Bool

-- | Returns <a>True</a> iff any of the given rules satisfy
--   <a>isErasing</a>
isErasing :: Ord v => [Rule f v] -> Bool

-- | Returns <a>True</a> iff any of the given rules satisfy
--   <a>isCreating</a>
isCreating :: Ord v => [Rule f v] -> Bool

-- | Returns <a>True</a> iff any of the given rules satisfy
--   <a>isDuplicating</a>
isDuplicating :: Ord v => [Rule f v] -> Bool

-- | Returns <a>True</a> iff any of the given rules satisfy
--   <a>isCollapsing</a>
isCollapsing :: [Rule f v] -> Bool

-- | Returns <a>True</a> iff all rules satisfy <a>isValid</a>
isValid :: Ord v => [Rule f v] -> Bool


-- | Operations on lists of rules.
--   
--   See also <a>Data.Rewriting.CriticalPair</a>
module Data.Rewriting.Rules

-- | Full rewriting: Apply rules anywhere in the term.
--   
--   Reducts are returned in pre-order: the first is a leftmost, outermost
--   redex.
fullRewrite :: (Ord v', Eq v, Eq f) => [Rule f v'] -> Strategy f v v'

module Data.Rewriting.Problem.Parse
parseIO :: String -> IO (Problem String String)
parseFileIO :: FilePath -> IO (Problem String String)
fromString :: String -> Either ProblemParseError (Problem String String)
fromFile :: FilePath -> IO (Either ProblemParseError (Problem String String))
fromCharStream :: Stream s (Either ProblemParseError) Char => SourceName -> s -> Either ProblemParseError (Problem String String)
data ProblemParseError
UnknownParseError :: String -> ProblemParseError
UnsupportedStrategy :: String -> ProblemParseError
FileReadError :: IOError -> ProblemParseError
UnsupportedDeclaration :: String -> ProblemParseError
SomeParseError :: ParseError -> ProblemParseError
instance Show ProblemParseError
instance Error ProblemParseError


-- | Termination problem type, based on WST format.
module Data.Rewriting.Problem
data Problem f v
Problem :: StartTerms -> Strategy -> Maybe [Theory f v] -> RulesPair f v -> [v] -> [f] -> Maybe String -> Problem f v
startTerms :: Problem f v -> StartTerms
strategy :: Problem f v -> Strategy
theory :: Problem f v -> Maybe [Theory f v]
rules :: Problem f v -> RulesPair f v
variables :: Problem f v -> [v]
symbols :: Problem f v -> [f]
comment :: Problem f v -> Maybe String

module Data.Rewriting.CriticalPair.Ops

-- | Determine all critical pairs for a pair of TRSs.
cps :: (Ord v, Ord v', Eq f) => [Rule f v] -> [Rule f v'] -> [(CP f v v')]

-- | Determine all inner critical pairs for a pair of TRSs.
--   
--   A critical pair is <i>inner</i> if the left rewrite step is not a root
--   step.
cpsIn :: (Ord v, Ord v', Eq f) => [Rule f v] -> [Rule f v'] -> [(CP f v v')]

-- | Determine outer critical pairs for a pair of TRSs.
--   
--   A critical pair is <i>outer</i> if the left rewrite step is a root
--   step.
cpsOut :: (Ord v, Ord v', Eq f) => [Rule f v] -> [Rule f v'] -> [(CP f v v')]

-- | Determine all critical pairs of a single TRS with itself.
--   
--   Unlike <tt>cps</tt>, <tt>cps'</tt> takes symmetries into account. See
--   <a>cpsIn'</a> and <a>cpsOut'</a> for details.
cps' :: (Ord v, Eq f) => [Rule f v] -> [(CP f v v)]

-- | Determine all inner critical pairs of a single TRS with itself.
--   
--   The result of <tt>cpsIn' trs</tt> differs from <tt>cpsIn trs trs</tt>
--   in that overlaps of a rule with itself are returned once, not twice.
cpsIn' :: (Ord v, Eq f) => [Rule f v] -> [(CP f v v)]

-- | Determine all outer critical pairs of a single TRS with itself.
--   
--   The result of <tt>cpsOut' trs</tt> differs from <tt>cpsOut trs
--   trs</tt> in two aspects:
--   
--   <ul>
--   <li>The trivial overlaps of rules with themselves are omitted.</li>
--   <li>Symmetry is taken into account: Overlaps between distinct rules
--   are returned once instead of twice.</li>
--   </ul>
cpsOut' :: (Ord v, Eq f) => [Rule f v] -> [(CP f v v)]

module Data.Rewriting.CriticalPair

-- | A critical pair. Critical pairs (should) have the following
--   properties:
--   
--   <pre>
--   top   == Context.ofTerm top pos (Term.map Left id (Rule.lhs leftRule))
--   left  == Context.ofTerm top pos (Term.map Left id (Rule.rhs leftRule))
--   top   == Substitution.apply subst (Term.map Right id (Rule.lhs rightRule))
--   right == Substitution.apply subst (Term.map Right id (Rule.rhs rightRule))
--   </pre>
--   
--   Furthermore, <tt>pos</tt> is a non-variable position of <tt>(lhs
--   rightRule)</tt> and <tt>subst</tt> is a most general substitution with
--   these properties.
data CP f v v'
CP :: Term f (Either v v') -> Term f (Either v v') -> Term f (Either v v') -> Rule f v -> Pos -> Rule f v' -> Subst f (Either v v') -> CP f v v'

-- | left reduct
left :: CP f v v' -> Term f (Either v v')

-- | source
top :: CP f v v' -> Term f (Either v v')

-- | right reduct
right :: CP f v v' -> Term f (Either v v')

-- | rule applied on left side
leftRule :: CP f v v' -> Rule f v

-- | position of left rule application
leftPos :: CP f v v' -> Pos

-- | rule applied on right side
rightRule :: CP f v v' -> Rule f v'

-- | common substitution of the rewrite steps
subst :: CP f v v' -> Subst f (Either v v')

-- | Determine all critical pairs of a single TRS with itself.
--   
--   Unlike <tt>cps</tt>, <tt>cps'</tt> takes symmetries into account. See
--   <a>cpsIn'</a> and <a>cpsOut'</a> for details.
cps' :: (Ord v, Eq f) => [Rule f v] -> [(CP f v v)]

-- | Determine all critical pairs for a pair of TRSs.
cps :: (Ord v, Ord v', Eq f) => [Rule f v] -> [Rule f v'] -> [(CP f v v')]
