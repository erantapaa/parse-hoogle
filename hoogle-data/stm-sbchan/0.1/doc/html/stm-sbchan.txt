-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Bounded channel for STM where item sizes can vary
--   
--   This library provides a bounded first-in first-out channel type for
--   use in STM. It supports a limit on the <i>total size</i> of items in
--   the channel.
--   
--   stm-sbchan also provides a few features not found in other bounded
--   channel libraries, such as:
--   
--   <ul>
--   <li>Alternative overflow strategies <tt>cramSBChan</tt> and
--   <tt>rollSBChan</tt>. <tt>cramSBChan</tt> ignores the channel's size
--   limit, and <tt>rollSBChan</tt> removes old items from the beginning of
--   the channel when it fills up.</li>
--   <li>The channel limit can be adjusted at runtime.</li>
--   </ul>
@package stm-sbchan
@version 0.1


-- | FIFO queue for STM, bounded by the total "size" of the items.
module Data.STM.SBChan
data SBChan a

-- | Create a new, empty <a>SBChan</a>, with the given size limit.
--   
--   To change the size limit later, use <a>setLimitSBChan</a>.
newSBChan :: Int -> STM (SBChan a)

-- | <tt>IO</tt> variant of <a>newSBChan</a>. This is useful for creating
--   top-level <a>SBChan</a>s using <a>unsafePerformIO</a>, because
--   performing <a>atomically</a> inside a pure computation is extremely
--   dangerous (can lead to <a>NestedAtomically</a> errors and even
--   segfaults, see GHC ticket #5866).
--   
--   Example:
--   
--   <pre>
--   logChannel :: <a>SBChan</a> LogEntry
--   logChannel = <a>unsafePerformIO</a> (<a>newSBChanIO</a> 500000)
--   {-# NOINLINE logChannel #-}
--   </pre>
newSBChanIO :: Int -> IO (SBChan a)
class ItemSize a
itemSize :: ItemSize a => a -> Int

-- | Wrapper for items where <tt><a>itemSize</a> item = 1</tt>. This helps
--   you use <a>SBChan</a> as a channel with a maximum <i>number</i> of
--   items.
newtype SBCItem a
SBCItem :: a -> SBCItem a
unSBCItem :: SBCItem a -> a

-- | Read the next item from the channel. <a>retry</a> if the channel is
--   empty.
readSBChan :: ItemSize a => SBChan a -> STM a

-- | Write an item to the channel. <a>retry</a> if the item does not fit.
--   
--   As an exception, if the channel is currently empty, but the item's
--   size exceeds the channel limit all by itself, it will be written to
--   the channel anyway. This is to prevent a large item from causing the
--   application to deadlock.
writeSBChan :: ItemSize a => SBChan a -> a -> STM ()

-- | Get the next item from the channel without removing it. <a>retry</a>
--   if the channel is empty.
peekSBChan :: SBChan a -> STM a

-- | Put an item back on the channel, where it will be the next item read.
--   
--   This will always succeed, even if it causes the channel's size limit
--   to be exceeded. The rationale is that the size limit can be exceeded
--   in some cases (e.g. by writing an oversized item to an empty channel).
--   If we allow <a>writeSBChan</a> to exceed the limit, but don't allow
--   <a>unGetSBChan</a> to exceed the limit, then we can't always read an
--   item and put it back.
--   
--   Note that <a>unGetTBQueue</a> in <a>Control.Concurrent.STM.TBQueue</a>
--   is different: it will <a>retry</a> if the queue is full.
unGetSBChan :: ItemSize a => SBChan a -> a -> STM ()

-- | Return <a>True</a> if the channel is empty.
isEmptySBChan :: SBChan a -> STM Bool

-- | Variant of <a>readSBChan</a> which does not <a>retry</a>. Instead, it
--   returns <a>Nothing</a> if the channel is empty.
tryReadSBChan :: ItemSize a => SBChan a -> STM (Maybe a)

-- | Variant of <a>writeSBChan</a> which does not <a>retry</a>. Instead, it
--   returns <a>False</a> if the item does not fit.
tryWriteSBChan :: ItemSize a => SBChan a -> a -> STM Bool

-- | Variant of <a>peekSBChan</a> which does not <a>retry</a>. Instead, it
--   returns <a>Nothing</a> if the channel is empty.
tryPeekSBChan :: SBChan a -> STM (Maybe a)

-- | Like <a>writeSBChan</a>, but ignore the channel size limit. This will
--   always succeed, and will not <a>retry</a>.
cramSBChan :: ItemSize a => SBChan a -> a -> STM ()

-- | Like <a>writeSBChan</a>, but if the channel is full, drop items from
--   the beginning of the channel until there is enough room for the new
--   item (or until the channel is empty). This will always succeed, and
--   will not <a>retry</a>.
--   
--   Return the number of items dropped.
rollSBChan :: ItemSize a => SBChan a -> a -> STM Int

-- | Get the current limit on total size of items in the channel.
getLimitSBChan :: SBChan a -> STM Int

-- | Set the total size limit. If the channel exceeds the new limit, too
--   bad.
setLimitSBChan :: SBChan a -> Int -> STM ()

-- | Drop items from the beginning of the channel until the channel's size
--   limit is satisfied, or until there is only one item left in the
--   channel.
--   
--   Return the number of items dropped.
satisfyLimitSBChan :: ItemSize a => SBChan a -> STM Int

-- | Remove all items from the <a>SBChan</a>.
clearSBChan :: SBChan a -> STM ()
instance Typeable1 SBChan
instance Typeable1 SBCItem
instance ItemSize (SBCItem a)
instance Eq (SBChan a)
