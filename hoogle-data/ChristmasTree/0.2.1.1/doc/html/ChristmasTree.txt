-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Alternative approach of 'read' that composes grammars instead of parsers.
--   
--   ChristmasTree (Changing Haskell's Read Implementation Such That by
--   Mainpulating ASTs it Reads Expressions Efficiently) is an alternative
--   approach of <a>read</a> that composes grammars instead of parsers. It
--   reads data in linear time, while the function <a>read</a> has an
--   exponential behavior in some cases of data types with infix operators.
@package ChristmasTree
@version 0.2.1.1


-- | Module used internally by the <a>Derive</a> module for binding group
--   calculation.
module Text.GRead.Derive.BindingGroup

-- | Mapping from types to the list of types (with specific constructor
--   instantiations, the '[[Type]]') in the same binding group.
type BindingGroup = [(Name, [(Name, [[Type]])])]

-- | Find cyclic type dependencies (binding groups)
getBindingGroup :: Name -> Q BindingGroup
showBindingGroup :: Name -> Q Exp

-- | Uniform representation of 'data' and 'newtype'
data UserType
UserD :: Name -> [Name] -> [Con] -> UserType

-- | Get a unified type for 'data' and 'newtype'
getUserType :: Name -> Q UserType

-- | Get the types of a type application
unrollApp :: Type -> [Type]
instance Show EdgeType
instance Eq EdgeType

module Text.GShow
class GShow a
gshow :: GShow a => a -> String
gshowsPrec :: GShow a => Int -> a -> ShowS
deriveShow :: Name -> Q [Dec]
app_prec :: Int


-- | Representation of Data Type Grammars.
module Text.GRead.Grammar

-- | Class of data types with typed grammar representation. It has to be
--   instantiated in order to use the function <a>gread</a>.
--   
--   Instances can be derived automatically using the functions defined in
--   the module <a>Text.GRead.Derive</a>.
--   
--   For example, given the declarations
--   
--   <pre>
--   infixl 5 :&lt;:
--   infixr 6 :&gt;:, :*:
--   
--   data T1  =  T1 :&lt;: T1
--            |  T1 :&gt;: T1
--            |  C1
--   
--   data T2 a  =  a :*: T2 a
--              |  C2
--   </pre>
--   
--   the instances of <a>Gram</a> can be
--   
--   <pre>
--   _0 = Zero
--   _1 = Suc _0
--   
--   instance Gram T1 where
--    grammar = DGrammar   _0 envT1
--   
--   envT1 :: Env DGram ((),T1) ((),T1) 
--   envT1 =  consD (nonts _0) Empty 
--        where
--         nonts _T1 = DLNontDefs
--          [  (  DRef (_T1, 5) 
--             ,  DPS  [  dNont (_T1, 5) .#. dTerm ":&lt;:" .#.
--                        dNont (_T1, 6) .#. dEnd infixL ]
--             )
--          ,  (  DRef (_T1, 6) 
--             ,  DPS  [  dNont (_T1, 7) .#. dTerm ":&gt;:" .#.
--                        dNont (_T1, 6) .#. dEnd infixR ] 
--             ) 
--          ,  (  DRef (_T1,10) 
--             ,  DPS  [  dTerm "C1"   .#. dEnd (const C1)
--                     ,  dTerm "(" .#. dNont (_T1,0) .#. 
--                        dTerm ")" .#. dEnd parenT ] 
--             )
--          ]
--         infixL e1 _ e2   = e2 :&lt;: e1
--         infixR e1 _ e2   = e2 :&gt;: e1 
--   
--   instance Gram a =&gt; Gram (T2 a) where
--    grammar = DGrammar   _0  envT2 
--   
--   envT2 :: (Gram a) =&gt; Env DGram  (((),a),T2 a)
--                                   (((),a),T2 a)
--   envT2 =  consD (nonts  _0 _1) $ 
--            consG grammar Empty
--        where
--         nonts _T2 _A = DLNontDefs
--          [  (  DRef (_T2, 6)
--             ,  DPS  [  dNont (_A,   7)  .#. dTerm ":*:" .#. 
--                        dNont (_T2,  7)  .#. dEnd infixT ] 
--             )
--          ,  (  DRef (_T2,10) 
--             ,  DPS  [  dTerm "C2"   .#. dEnd (const C2)
--                     ,  dTerm "("    .#. dNont (_T2,0) .#. 
--                        dTerm ")"    .#. dEnd parenT ] 
--             )
--          ]
--         infixP   e1 _ e2  = e2 :+: e1
--         infixT   e1 _ e2  = e2 :*: e1 
--   </pre>
--   
--   In case of mutually recursive datatypes, their definitions have to be
--   tupled together into a single environment.
class Gram a
grammar :: Gram a => DGrammar a

-- | Data type describing grammatical structures of data types, including
--   information about precedences. The type <tt>DGrammar a</tt> describes
--   the grammar of the data type <tt>a</tt>.
data DGrammar a

-- | A grammar consists of an environment (<a>Env</a>) with the defined
--   non-terminals and a reference (<a>Ref</a>) to the <i>main
--   non-terminal</i> in the environment.
DGrammar :: (Ref a env) -> (Env DGram env env) -> DGrammar a
data DGram a env
DGD :: (DLNontDefs a env) -> DGram a env
DGG :: (DGrammar a) -> DGram a env
newtype DRef a env
DRef :: (Ref a env, Int) -> DRef a env
newtype DLNontDefs a env
DLNontDefs :: [(DRef a env, DProductions a env)] -> DLNontDefs a env
newtype DProductions a env
DPS :: [DProd a env] -> DProductions a env
unDPS :: DProductions a env -> [DProd a env]
data DProd a env
DSeq :: DSymbol b env -> DProd (b -> a) env -> DProd a env
DEnd :: a -> DProd a env
data DSymbol a env
DNont :: DRef a env -> DSymbol a env
DTerm :: Token -> DSymbol Token env
(.#.) :: DSymbol b env -> DProd (b -> a) env -> DProd a env
consG :: DGrammar a -> Env DGram use def' -> Env DGram use (def', a)
consD :: DLNontDefs a env -> Env DGram env def' -> Env DGram env (def', a)
dNont :: (Ref a env, Int) -> DSymbol a env
dTerm :: [Char] -> DSymbol Token env
dEnd :: a -> DProd a env
parenT :: t -> t1 -> t2 -> t1
data Grammar a
Grammar :: (Ref a env) -> (Env Productions env env) -> Grammar a
newtype Productions a env
PS :: [Prod a env] -> Productions a env
unPS :: Productions a env -> [Prod a env]
data Prod a env
Seq :: Symbol b env -> Prod (b -> a) env -> Prod a env
End :: a -> Prod a env
data Symbol a env
Nont :: Ref a env -> Symbol a env
Term :: Token -> Symbol Token env
data Token
Keyw :: String -> Token
Open :: Token
Close :: Token
ext :: Env Productions env def' -> [Prod a env] -> Env Productions env (def', a)
(.*.) :: Symbol b env -> Prod (b -> a) env -> Prod a env
matchSym :: Symbol a env -> Symbol b env -> Maybe (Equal a b)
append :: (a -> b -> c) -> Prod a env -> Symbol b env -> Prod c env
instance Ord Token
instance Eq Token

module Text.GRead.Transformations.Group
newtype DT env1 env2
DT :: (forall a. DRef a env1 -> Ref a env2) -> DT env1 env2
unDT :: DT env1 env2 -> forall a. DRef a env1 -> Ref a env2
mapDP2Prod :: DT env1 env2 -> DProd a env1 -> Prod a env2
type GTrafo = Trafo Unit Productions
dp2prod :: DProd a env -> GTrafo s (DT env s) (Prod a s)
ld2nt :: (DRef a env, DProductions a env) -> GTrafo s (DT env s) (DRef a s)
newtype ListDR a s
ListDR :: [DRef a s] -> ListDR a s
unListDR :: ListDR a s -> [DRef a s]
newtype DMapping o n
DMapping :: Env ListDR n o -> DMapping o n
unDMapping :: DMapping o n -> Env ListDR n o
dmap2trans :: DMapping env s -> DT env s
plookup :: Int -> [DRef a s] -> Ref a s
group :: DGrammar a -> Grammar a
gGrammar :: DGrammar a -> GTrafo s t (ListDR a s)
gDGrams :: Env DGram env env' -> GTrafo s (DT env s) (DMapping env' s)


-- | Automatically derive <a>Gram</a> instances for data types.
--   
--   <i>Note!</i> This is not a complete implementation and will not work
--   for all datatypes.
--   
--   Unsupported are
--   
--   <ul>
--   <li>Multiple type arguments</li>
--   <li>Tuple, Function, List types</li>
--   <li>All primitive types (also when used in user defined types!)</li>
--   </ul>
--   
--   Use with care.
module Text.GRead.Derive

-- | Derive a <a>Gram</a> instance. This is a Template Haskell function.
--   Usage example:
--   
--   <pre>
--   data T1 = C1 | C2 | C3
--   
--   $(deriveGrammar ''T1)
--   </pre>
deriveGrammar :: Name -> Q [Dec]

-- | Simpler version of <a>deriveGrammar</a> that doesn't do binding group
--   calculations. Use this for large types without cyclic references to
--   other types.
--   
--   For example, if you want to derive the <a>Gram</a> for <tt>T3</tt> and
--   <tt>T4</tt> below, you will need the normal <a>deriveGrammar</a>.
--   
--   <pre>
--   data T3 = T3 T4 | C3
--   data T4 = T4 T3 | C4
--   </pre>
deriveSimpleGrammar :: Name -> Q [Dec]

module Text.GRead.Transformations.GramTrafo
newtype MapA_X env a env'
MapA_X :: (forall x. Symbol x env -> Maybe (Ref (x -> a) env')) -> MapA_X env a env'
emptyMap :: MapA_X env a env'
extendMap :: Symbol x env -> MapA_X env a env' -> MapA_X env a (env', x -> a)
type GramTrafo env a = Trafo (MapA_X env a) Productions
initMap :: GramTrafo env a s c d -> Trafo Unit Productions s c d
newNontR :: Symbol x env -> GramTrafo env a s (Productions (x -> a) s) (Ref (x -> a) s)
newtype Mapping old new
Mapping :: (Env Ref new old) -> Mapping old new
map2trans :: Mapping env s -> T env s
mapProd :: T env1 env2 -> Prod a env1 -> Prod a env2

module Text.GRead.Transformations.LeftFact
leftfactoring :: Grammar a -> Grammar a

module Text.GRead.Transformations.LeftCorner
leftcorner :: Grammar a -> Grammar a


-- | Alternative approach of <a>read</a> that composes grammars instead of
--   parsers. Grammars describing the data types are composed dynamically,
--   removing possible left-recursion and combining common prefixes of
--   alternatives.
--   
--   The function <a>gread</a> defined here is able to handle the
--   associativities defined for infix operators.
--   
--   The function <a>gread</a> reads data in linear time, while the
--   function <a>read</a> has an exponential behavior in some cases of data
--   types with infix operators.
--   
--   Non uniform data types are not supported, because they generate
--   infinite grammars.
--   
--   The library is documented in the paper: <i>Haskell, do you read me?:
--   constructing and composing efficient top-down parsers at runtime</i>
--   
--   Bibtex entry:
--   <a>http://www.cs.uu.nl/wiki/bin/viewfile/Center/TTTAS?rev=1;filename=GRead.bib</a>
--   
--   For more documentation see the TTTAS webpage:
--   <a>http://www.cs.uu.nl/wiki/bin/view/Center/TTTAS</a> .
module Text.GRead

-- | The <a>gread</a> reads input from a string, which must be completely
--   consumed by the input process. Returns <tt>Ok value</tt> on a
--   successful parse. Otherwise returns <tt>Rep value msgs</tt>, where the
--   <tt>value</tt> results of parsing a repaired input. The list
--   <tt>msgs</tt> contains the "corrections" done to the input.
--   
--   For example, a <a>read</a>-like implementation can be:
--   
--   <pre>
--   read :: (Gram a) =&gt; String -&gt; a
--   read input = case gread input of
--                    Ok  a       -&gt; a
--                    Rep _ (m:_) -&gt; error $ show m
--   </pre>
gread :: Gram a => String -> GReadResult a

-- | Type of error repair messages.
type GReadMsg = Message Token (Maybe Token)

-- | Type of <a>gread</a> results.
data GReadResult a
Ok :: a -> GReadResult a
Rep :: a -> [GReadMsg] -> GReadResult a
instance Show a => Show (GReadResult a)
instance Symbol Token
instance Show Token
