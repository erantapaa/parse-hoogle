-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Choose between the return value of an STM operation and an IO action.
--   
--   While tinkering on a project, I frequently found myself wanting to
--   wait for an IO operation <i>unless</i> something more important came
--   up. The <a>Control.Concurrent.STM.OrElseIO</a> module is meant to
--   reduce the boilerplate needed when choosing between IO actions and STM
--   operations.
--   
--   You must use the threaded runtime with this package.
--   
--   TODO:
--   
--   <ul>
--   <li>Kill off IO threads whose return values will never be needed.</li>
--   <li>Possibly rename <tt>runOrElse</tt> and friends to
--   <tt>orElseIO</tt> or similar.</li>
--   </ul>
@package stm-orelse-io
@version 0.1


-- | Perform an IO action, and place its result in a <a>TMVar</a>. See also
--   <a>Control.Concurrent.MVarIO</a> for an <a>MVar</a> version.
module Control.Concurrent.STM.TMVarIO

-- | <tt><a>run</a> action</tt> returns a <a>TMVar</a> immediately. The
--   result of <tt>action</tt> will be placed in said <a>TMVar</a>. If the
--   <a>TMVar</a> is full when <tt>action</tt> completes, the return value
--   is lost (i.e. we do not wait for an empty <a>TMVar</a>).
run :: IO a -> IO (TMVar a)


-- | Choose between the return value of an IO action and an STM operation,
--   depending on which is available first.
module Control.Concurrent.STM.OrElseIO

-- | <tt><a>runOrElse</a> io stm</tt> runs the IO action <tt>io</tt>. If
--   its result is available when <tt><a>runOrElse</a></tt> itself returns,
--   then that value is used as the function's return value. If not, the
--   STM operation <tt>stm</tt> is attempted. Then, whichever of
--   <tt>io</tt>'s and <tt>stm</tt>'s return value is then available first
--   is returned from <tt><a>runOrElse</a></tt>, with a preference to that
--   of <tt>io</tt> if both are available. <tt><a>runOrElse'</a></tt>
--   reverses this priority.
--   
--   It can happen that <tt>stm</tt> is never attempted. If it is, however,
--   its result is used as return value <i>only</i> if it is available
--   before that of <tt>io</tt>. Note that in that case, a long-running
--   <tt>io</tt> will keep running until completed, even if
--   <tt><a>runOrElse</a></tt> has already returned with the result of
--   <tt>stm</tt>. A future version will probably kill off the <tt>io</tt>
--   thread if its value is not needed (i.e. if that of <tt>stm</tt> value
--   is used), but that is <i>not</i> currently the case.
runOrElse :: IO a -> STM b -> IO (Either a b)

-- | A version of <a>runOrElse</a> that prefers the STM operation to the IO
--   action. In this case, the IO action is <i>always</i> run, but its
--   value is only used if the return value of the STM operation is not
--   available when the function returns.
--   
--   The same caveat regarding long-running IO operations as for
--   <a>runOrElse</a> also applies here.
runOrElse' :: STM a -> IO b -> IO (Either a b)

-- | <tt><a>runOrTakeTMVar</a> io tm = <a>runOrElse</a> io
--   (<a>takeTMVar</a> tm)</tt>.
runOrTakeTMVar :: IO a -> TMVar b -> IO (Either a b)

-- | <tt><a>runOrTakeTMVar'</a> tm io = <a>runOrElse'</a> (<a>takeTMVar</a>
--   tm) io</tt>.
runOrTakeTMVar' :: TMVar a -> IO b -> IO (Either a b)

-- | A version of <tt><a>runOrElse</a></tt> where the STM operation is to
--   <tt><a>run</a></tt> another IO action and <tt><a>takeTMVar</a></tt>
--   the associated <a>TMVar</a> holding its return value. The first is
--   preferred to the second.
runOrRun :: IO a -> IO b -> IO (Either a b)


-- | Perform an IO action, and place its result in an <a>MVar</a>. See also
--   <a>Control.Concurrent.STM.TMVarIO</a> for a <tt>TMVar</tt> version.
module Control.Concurrent.MVarIO

-- | <tt><a>run</a> action</tt> returns an <a>MVar</a> immediately. The
--   result of <tt>action</tt> will be placed in said <a>MVar</a>. If the
--   <a>MVar</a> is full when <tt>action</tt> completes, the return value
--   is lost (the action does not wait for an empty <a>MVar</a>).
run :: IO a -> IO (MVar a)
