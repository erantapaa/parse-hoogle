-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A Skip List Implementation in Software Transactional Memory (STM)
--   
--   This package provides an implementation of a skip list in STM. A skip
--   list is a probabilistic data structure with dictionary operations and
--   support for efficient range-queries (similarly to <i>Data.Map</i>). In
--   contrast to tree data structures, a skip list does not need any
--   rebalancing, which makes it particularly suitable for concurrent
--   programming. See: William Pugh. Skip Lists: A Probabilistic
--   Alternative to Balanced Trees.
--   
--   Feedback appreciated!
@package tskiplist
@version 1.0.0


module Control.Concurrent.STM.TSkipList.Internal

-- | A skip list data type.
data TSkipList k a
TSkipList :: Int -> Float -> TVar Int -> ForwardPtrs k a -> TSkipList k a

-- | The maximal height of the skip list.
maxLevel :: TSkipList k a -> Int

-- | Probability parameter.
probability :: TSkipList k a -> Float

-- | The current max level.
curLevel :: TSkipList k a -> TVar Int

-- | Pointer to the first element in the highest level.
listHead :: TSkipList k a -> ForwardPtrs k a

-- | Creates a skiplist. Default values for storing up to 2^16 elements.
newIO :: IO (TSkipList k a)

-- | Creates a skiplist.
newIO' :: Float -> Int -> IO (TSkipList k a)

-- | Creates a skiplist. Default values for storing up to 2^16 elements.
new :: STM (TSkipList k a)

-- | Creates a skiplist.
new' :: Float -> Int -> STM (TSkipList k a)

-- | Traversal strategy.
data Traversal k a b
Traversal :: (Node k a -> Int -> STM b) -> (Node k a -> Int -> STM b) -> (Node k a -> Int -> STM b) -> (Node k a -> Int -> STM b) -> Maybe (Node k a -> Int -> STM b) -> Traversal k a b
onLT :: Traversal k a b -> Node k a -> Int -> STM b
onGT :: Traversal k a b -> Node k a -> Int -> STM b
onEQ :: Traversal k a b -> Node k a -> Int -> STM b
onNil :: Traversal k a b -> Node k a -> Int -> STM b
onSuccSuccNil :: Traversal k a b -> Maybe (Node k a -> Int -> STM b)
type ForwardPtrs k a = TArray Int (Node k a)

-- | An entry of the skip list.
data Node k a
Nil :: Node k a
Node :: k -> TVar a -> ForwardPtrs k a -> Node k a
key :: Node k a -> k
contentTVar :: Node k a -> TVar a
forwardPtrs :: Node k a -> ForwardPtrs k a

-- | Inserts<i>updates the value for a specific key. </i>O(log n)/.
insert :: Ord k => k -> a -> TSkipList k a -> STM ()

-- | Searches for a given entry. <i>O(log n)</i>.
lookup :: Ord k => k -> TSkipList k a -> STM (Maybe a)

-- | Updates an element. Throws <a>AssertionFailed</a> if the element is
--   not in the list. <i>O(log n)</i>.
update :: Ord k => k -> a -> TSkipList k a -> STM ()

-- | Deletes an element. Does nothing if the element is not found. <i>O(log
--   n)</i>.
delete :: Ord k => k -> TSkipList k a -> STM ()

-- | Returns all elements that satisfy the predicate on keys. <i>O(n)</i>.
filter :: Ord k => (k -> Bool) -> TSkipList k a -> STM (Map k a)

-- | Returns all elements greater than the key. TODO: currently in O(n),
--   should be made more efficient (like <tt>leq</tt>)
filterGT :: Ord k => k -> TSkipList k a -> STM (Map k a)

-- | Returns all elements less than the key. Takes <i>O(m)</i> where
--   <i>m</i> is the number of elements that have a smaller key.
filterLT :: Ord k => k -> TSkipList k a -> STM (Map k a)

-- | Returns all elements that satisfy the predicate on keys and values.
--   <i>O(n)</i>.
filterElems :: Ord k => (k -> a -> Bool) -> TSkipList k a -> STM (Map k a)

-- | Returns the minimum entry. <i>O(1)</i>.
minimum :: Ord k => TSkipList k a -> STM (k, a)

-- | Returns the maximum entry. <i>O(log n)</i>.
maximum :: Ord k => TSkipList k a -> STM (k, a)

-- | Finds all elements within a specific key range (k1,k2). <i>O(log n +
--   k2 - k1)</i>.
filterRange :: Ord k => (k, k) -> TSkipList k a -> STM [(k, a)]
traverse :: Ord k => k -> ForwardPtrs k a -> Int -> Traversal k a b -> b -> STM b
lookupNode :: Ord k => k -> TSkipList k a -> STM (Maybe (Node k a))
insertNode :: Ord k => k -> Node k a -> TSkipList k a -> STM ()

-- | Returns a randomly chosen level. Used for inserting new elements. For
--   performance reasons, this function uses <a>unsafePerformIO</a> to
--   access the random number generator. (It would be possible to store the
--   random number generator in a <a>TVar</a> and thus be able to access it
--   safely from within the STM monad. This, however, might cause high
--   contention among threads.)
chooseLevel :: TSkipList k a -> Int

-- | Returns the skip list as a string.
toString :: (Show k, Ord k) => TSkipList k a -> STM String


-- | This module provides an implementation of a skip list in the
--   <tt>STM</tt> monad. The elements of the skip list are stored in a
--   <tt>TVar</tt>.
--   
--   A skip list is a probabilistic data structure with dictionary
--   operations (similar to <a>Map</a>). In contrast to a balanced tree, a
--   skip list does not need any (expensive) rebalancing operation, which
--   makes it particularly suitable for concurrent programming.
--   
--   See: <i>William Pugh. Skip Lists: A Probabilistic Alternative to
--   Balanced Trees.</i>
--   
--   This module should be imported qualified.
--   
--   <i>Example (GHCi):</i>
--   
--   <pre>
--   t &lt;- newIO :: IO (TSkipList Int String) 
--   atomically $ sequence_ [ insert i (show i) t | i &lt;- [1..10] ]
--   
--   putStrLn =&lt;&lt; atomically (toString t)
--   9
--   9
--   3 7 9
--   1 3 7 9
--   1 2 3 4 5 6 7 8 9 10
--   
--   atomically $ delete  7 t
--   putStrLn =&lt;&lt; atomically (toString t)
--   9
--   9
--   3 9
--   1 3 9
--   1 2 3 4 5 6 8 9 10
--   
--   atomically $ sequence [ lookup i t | i &lt;- [5..10] ]
--   [Just "5",Just "6",Nothing,Just "8",Just "9",Just "10"]
--   
--   atomically $ update 8 "X" t
--   atomically $ filterRange (5,10) t 
--   ["5","6","X","9","10"]
--   
--   atomically $ maximum t
--   (10,"10")
--   </pre>
module Control.Concurrent.STM.TSkipList

-- | A skip list data type.
data TSkipList k a

-- | Creates a skiplist. Default values for storing up to 2^16 elements.
newIO :: IO (TSkipList k a)

-- | Creates a skiplist.
newIO' :: Float -> Int -> IO (TSkipList k a)

-- | Creates a skiplist. Default values for storing up to 2^16 elements.
new :: STM (TSkipList k a)

-- | Creates a skiplist.
new' :: Float -> Int -> STM (TSkipList k a)

-- | Inserts<i>updates the value for a specific key. </i>O(log n)/.
insert :: Ord k => k -> a -> TSkipList k a -> STM ()

-- | Searches for a given entry. <i>O(log n)</i>.
lookup :: Ord k => k -> TSkipList k a -> STM (Maybe a)

-- | Updates an element. Throws <a>AssertionFailed</a> if the element is
--   not in the list. <i>O(log n)</i>.
update :: Ord k => k -> a -> TSkipList k a -> STM ()

-- | Deletes an element. Does nothing if the element is not found. <i>O(log
--   n)</i>.
delete :: Ord k => k -> TSkipList k a -> STM ()

-- | Returns all elements that satisfy the predicate on keys. <i>O(n)</i>.
filter :: Ord k => (k -> Bool) -> TSkipList k a -> STM (Map k a)

-- | Returns all elements greater than the key. TODO: currently in O(n),
--   should be made more efficient (like <tt>leq</tt>)
filterGT :: Ord k => k -> TSkipList k a -> STM (Map k a)

-- | Returns all elements less than the key. Takes <i>O(m)</i> where
--   <i>m</i> is the number of elements that have a smaller key.
filterLT :: Ord k => k -> TSkipList k a -> STM (Map k a)

-- | Returns all elements that satisfy the predicate on keys and values.
--   <i>O(n)</i>.
filterElems :: Ord k => (k -> a -> Bool) -> TSkipList k a -> STM (Map k a)

-- | Finds all elements within a specific key range (k1,k2). <i>O(log n +
--   k2 - k1)</i>.
filterRange :: Ord k => (k, k) -> TSkipList k a -> STM [(k, a)]

-- | Returns the minimum entry. <i>O(1)</i>.
minimum :: Ord k => TSkipList k a -> STM (k, a)

-- | Returns the maximum entry. <i>O(log n)</i>.
maximum :: Ord k => TSkipList k a -> STM (k, a)

-- | Returns a randomly chosen level. Used for inserting new elements. For
--   performance reasons, this function uses <a>unsafePerformIO</a> to
--   access the random number generator. (It would be possible to store the
--   random number generator in a <a>TVar</a> and thus be able to access it
--   safely from within the STM monad. This, however, might cause high
--   contention among threads.)
chooseLevel :: TSkipList k a -> Int

-- | Returns the skip list as a string.
toString :: (Show k, Ord k) => TSkipList k a -> STM String
