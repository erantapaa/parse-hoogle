-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Indexed Types
--   
@package index-core
@version 1.0.2


-- | This module provides the core (<a>:-&gt;</a>) type operator, which
--   links the world of indexed types and the world of unindexed types.
--   
--   You can use this type operator with the following extension:
--   
--   <pre>
--   {-# LANGUAGE TypeOperators #-}
--   </pre>
--   
--   Sometimes you may also need the <tt>Rank2Types</tt> extension.
module Control.Category.Index

-- | An index-preserving function from <tt>a</tt> to <tt>b</tt>
type (:->) a b = forall i. a i -> b i


-- | This module provides the <a>IFunctor</a> and <a>IMonad</a> classes
--   which are the indexed counterparts to <a>Functor</a> and <a>Monad</a>
--   from <tt>Control.Monad</tt>.
module Control.IMonad.Core

-- | An endofunctor within the category of index-preserving functions
--   
--   All instances must satisfy the functor laws:
--   
--   <pre>
--   fmapI id == id
--   
--   fmapI (f . g) == fmapI f . fmapI g
--   </pre>
class IFunctor f
fmapI :: IFunctor f => (a :-> b) -> (f a :-> f b)

-- | An indexed monad
--   
--   All instances must satisfy the monad laws:
--   
--   <pre>
--   returnI &gt;?&gt; f = f
--   
--   f &gt;?&gt; returnI = f
--   
--   (f &gt;?&gt; g) &gt;?&gt; h = f &gt;?&gt; (g &gt;?&gt; h)
--   </pre>
class IFunctor m => IMonad m
returnI :: IMonad m => a :-> m a
bindI :: IMonad m => (a :-> m b) -> (m a :-> m b)

-- | An infix <a>bindI</a> with arguments flipped
(?>=) :: IMonad m => m a i -> (a :-> m b) -> m b i

-- | An infix <a>bindI</a>
(=<?) :: IMonad m => (a :-> m b) -> (m a :-> m b)

-- | Composition of indexed Kleisli arrows
--   
--   This is equivalent to (<a>&gt;&gt;&gt;</a>) from
--   <tt>Control.Category</tt>.
(>?>) :: IMonad m => (a :-> m b) -> (b :-> m c) -> (a :-> m c)

-- | Composition of indexed Kleisli arrows
--   
--   This is equivalent to (<a>&lt;&lt;&lt;</a>) from
--   <tt>Control.Category</tt>.
(<?<) :: IMonad m => (b :-> m c) -> (a :-> m b) -> (a :-> m c)


-- | Restricted monads are a subset of indexed monads where the return
--   value is restricted to a single index. They build on top of
--   <a>IMonad</a> using the (<a>:=</a>) type constructor which restricts
--   the index of the return value.
module Control.IMonad.Restrict

-- | <tt>(a := i)</tt> represents a locked value of type <tt>a</tt> that
--   you can only access at the index <tt>i</tt>.
--   
--   <a>V</a> seals values of type <tt>a</tt>, restricting them to a single
--   index <tt>i</tt>.
data (:=) a i j
V :: a -> (a := i) i

-- | An indexed monad where the final index, <tt>j</tt>, is 'R'estricted
type R m i j a = m (a := j) i

-- | A <a>returnI</a> that restricts the final index
returnR :: IMonad m => a -> m (a := i) i

-- | A flipped <a>bindI</a> that restricts the intermediate and final
--   index. Called "angelic bind" in Conor McBride's paper. The type of
--   this function has the following specialization:
--   
--   <pre>
--   (!&gt;=) :: IMonad m =&gt; m (a := j) i -&gt; (a -&gt; m (b := k) j) -&gt; m (b := k) i
--   </pre>
(!>=) :: IMonad m => m (a := j) i -> (a -> m b j) -> m b i

-- | All restricted monads are ordinary functors
fmapR :: IMonad m => (a -> b) -> m (a := j) i -> m (b := j) i

-- | Infix <a>fmapR</a>
(<!>) :: IMonad m => (a -> b) -> m (a := j) i -> m (b := j) i

-- | All restricted monads are restricted applicatives
(<.>) :: IMonad m => m ((a -> b) := j) i -> m (a := k) j -> m (b := k) i

-- | A <a>bindI</a> that restricts the intermediate and final index. The
--   type of this function has the following specialization:
--   
--   <pre>
--   (=&lt;!) :: IMonad m =&gt; (a -&gt; m (b := k) j) -&gt; m (a := j) i -&gt; m (b := k) i
--   </pre>
(=<!) :: IMonad m => (a -> m b j) -> m (a := j) i -> m b i

-- | Sequence two indexed monads. The type of this function has the
--   following specialization:
--   
--   <pre>
--   (!&gt;) :: IMonad m =&gt; m (a := j) i -&gt; m (b := k) j -&gt; m (b := k) i
--   </pre>
(!>) :: IMonad m => m (a := j) i -> m b j -> m b i

-- | Composition of restricted Kleisli arrows
--   
--   This is equivalent to (<a>&gt;&gt;&gt;</a>) from
--   <tt>Control.Category</tt>.
--   
--   The type of this function has the following specialization:
--   
--   <pre>
--   IMonad m =&gt; (a -&gt; m (b:= j) i) -&gt; (b -&gt; m (c := k) j) -&gt; (a -&gt; m (c := k) i)
--   </pre>
(>!>) :: IMonad m => (a -> m (b := j) i) -> (b -> m c j) -> (a -> m c i)

-- | Composition of restricted Kleisli arrows
--   
--   This is equivalent to (<a>&lt;&lt;&lt;</a>) from
--   <tt>Control.Category</tt>.
--   
--   The type of this function has the following specialization:
--   
--   <pre>
--   (&lt;!&lt;) :: IMonad m =&gt; (b -&gt; m (c := k) j) -&gt; (a -&gt; m (b := j) i) -&gt; a -&gt; m (c := k) i
--   </pre>
(<!<) :: IMonad m => (b -> m c j) -> (a -> m (b := j) i) -> (a -> m c i)

-- | <a>joinR</a> joins two monad layers into one. The type of this
--   function has the following specialization:
--   
--   <pre>
--   joinR :: IMonad m =&gt; m (m (a := k) j := j) i -&gt; m (a := k) i
--   </pre>
joinR :: IMonad m => m (m a j := j) i -> m a i

-- | Discard the result of evaluation
voidR :: IMonad m => m (a := i) i -> m (() := i) i

-- | <a>foreverR</a> repeats the action indefinitely
foreverR :: IMonad m => m (a := i) i -> m (b := j) i

-- | "<tt>mapMR f</tt>" is equivalent to "<tt>sequenceR . map f</tt>"
mapMR :: IMonad m => (a -> m (b := i) i) -> [a] -> m ([b] := i) i

-- | "<tt>mapMR_ f</tt>" is equivalent to "<tt>sequenceR_ . map f</tt>"
mapMR_ :: IMonad m => (a -> m (b := i) i) -> [a] -> m (() := i) i

-- | <a>mapMR</a> with its arguments flipped
forMR :: IMonad m => [a] -> (a -> m (b := i) i) -> m ([b] := i) i

-- | <a>mapMR_</a> with its arguments flipped
forMR_ :: IMonad m => [a] -> (a -> m (b := i) i) -> m (() := i) i

-- | "<tt>replicateMR n m</tt>" performs <tt>m</tt> <tt>n</tt> times and
--   collects the results
replicateMR :: IMonad m => Int -> m (a := i) i -> m ([a] := i) i

-- | "<tt>replicateMR_ n m</tt>" performs <tt>m</tt> <tt>n</tt> times and
--   ignores the results
replicateMR_ :: IMonad m => Int -> m (a := i) i -> m (() := i) i

-- | Evaluate each action from left to right and collect the results
sequenceR :: IMonad m => [m (a := i) i] -> m ([a] := i) i

-- | Evaluate each action from left to right and ignore the results
sequenceR_ :: IMonad m => [m (a := i) i] -> m (() := i) i

-- | "<tt>whenR p m</tt>" executes <tt>m</tt> if <tt>p</tt> is <a>True</a>
whenR :: IMonad m => Bool -> m (() := i) i -> m (() := i) i

-- | "<tt>unlessR p m</tt>" executes <tt>m</tt> if <tt>p</tt> is
--   <a>False</a>
unlessR :: IMonad m => Bool -> m (() := i) i -> m (() := i) i

-- | The <a>U</a> type 'U'pgrades ordinary monads to restricted monads
data U m a i
U :: m (a i) -> U m a i
unU :: U m a i -> m (a i)

-- | <a>u</a> transforms an ordinary monad into a restricted monad
u :: Monad m => m a -> (U m) (a := i) i

-- | The <a>D</a> type 'D'owngrades index-preserving restricted monads to
--   ordinary monads
data D i m r
D :: m (r := i) i -> D i m r
unD :: D i m r -> m (r := i) i
instance IMonad m => Functor (D i m)
instance IMonad m => Applicative (D i m)
instance IMonad m => Monad (D i m)
instance Monad m => IMonad (U m)
instance Monad m => IFunctor (U m)


-- | This module provides a common interface to both indexed monads and
--   restricted monads. I split them into two separate modules for
--   organizational purposes and to simplify the presentation of each type
--   of indexed monad.
module Control.IMonad


-- | This module rebinds <tt>do</tt> notation to work with restricted
--   monads in conjunction with the <tt>RebindableSyntax</tt> extension.
--   This module re-exports <a>Control.IMonad</a>, so it only requires the
--   following minimum file header:
--   
--   <pre>
--   {-# LANGUAGE RebindableSyntax #-}
--   
--   import Control.IMonad.Do
--   import Prelude hiding (Monad(..))
--   </pre>
--   
--   The Prelude is reimported since <tt>RebindableSyntax</tt> also
--   includes the <tt>NoImplicitPrelude</tt> extension, otherwise the
--   Prelude's <tt>Monad</tt> bindings would conflict with these bindings.
module Control.IMonad.Do

-- | <a>return</a> replaces <tt>return</tt> from <tt>Control.Monad</tt>.
return :: IMonad m => a -> m (a := i) i

-- | (<a>&gt;&gt;=</a>) replaces (<tt>&gt;&gt;=</tt>) from
--   <tt>Control.Monad</tt>.
(>>=) :: IMonad m => m (a := j) i -> (a -> m (b := k) j) -> m (b := k) i

-- | (<a>&gt;&gt;</a>) replaces (<tt>&gt;&gt;</tt>) from
--   <tt>Control.Monad</tt>.
(>>) :: IMonad m => m (a := j) i -> m (b := k) j -> m (b := k) i

-- | <a>fail</a> replaces <tt>fail</tt> from <tt>Control.Monad</tt>
fail :: String -> m (a := j) i


-- | This module is the indexed equivalent to
--   <tt>Control.Monad.Trans.Class</tt> from the <tt>transformers</tt>
--   package.
module Control.IMonad.Trans

-- | An indexed monad transformer.
--   
--   All instances must satisfy the monad transformer laws:
--   
--   <pre>
--   liftI . returnI = returnI
--   
--   liftI . (f &gt;?&gt; g) = (liftI . f) &gt;?&gt; (liftI . g)
--   </pre>
class IMonadTrans t
liftI :: (IMonadTrans t, IMonad m) => m a :-> t m a

-- | Lifts ordinary monads for restricted monad transformers
--   
--   <pre>
--   liftU = liftI . u
--   </pre>
liftU :: (Monad m, IMonadTrans t) => m a -> t (U m) (a := i) i
