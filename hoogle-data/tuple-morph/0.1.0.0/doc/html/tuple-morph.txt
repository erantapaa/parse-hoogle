-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Morph between tuples with the same "flattened" representation
--   
--   Morph between tuples with the same "flattened" representation. Convert
--   tuples from and to heterogenous lists.
--   
--   See <a>Data.Tuple.Morph</a>.
@package tuple-morph
@version 0.1.0.0


-- | Appending type lists and HLists.
module Data.Tuple.Morph.Append

-- | Appends two type lists.

-- | Proof (by unsafeCoerce) that appending is associative.
appendAssoc :: Proxy a -> Proxy b -> Proxy c -> ((a ++ b) ++ c) :~: (a ++ (b ++ c))

-- | Proof (by unsafeCoerce) that '[] is a right identity of (++).
appendRightId :: Proxy a -> (a ++ []) :~: a

-- | Appends two HLists.
(++@) :: HList a -> HList b -> HList (a ++ b)


-- | Allows you to flatten, unflatten and morph tuples of matching types.
--   
--   Note: by design units are ignored. For example <tt>(Int, (),
--   Char)</tt> is the same as <tt>(Int, Char)</tt>.
module Data.Tuple.Morph

-- | Morph a tuple to some isomorphic tuple with the same order of types.
--   
--   Works with arbitrary nested tuples, each tuple can have size up to
--   <a>sizeLimit</a>.
--   
--   <pre>
--   &gt;&gt;&gt; morph ("a", ("b", "c")) :: (String, String, String)
--   ("a","b","c")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; morph ((1 :: Int, 2 :: Int), 3 :: Double) :: (Int, (Int, Double))
--   (1,(2,3.0))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; morph ("a", (), (5 :: Int, (), "c")) :: ((), (String, Int), String)
--   ((),("a",5),"c")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; morph (((("a", "b"), "c"), "d"), "e") :: ((String, String), (String, (String, String)))
--   (("a","b"),("c",("d","e")))
--   </pre>
morph :: (HFoldable a, HUnfoldable b, Rep a ~ Rep b) => a -> b

-- | Size of the largest tuple that this library will work with. Equal to
--   13.
--   
--   Note that size of ((((((1, 1), 1), 1), 1), 1), 1) is 2, not 7.
sizeLimit :: Int

-- | Recurisvely break down a tuple type, representing it as a type list.

-- | Types that can be flattened to a heterogenous list.
class HFoldable t
toHList :: HFoldable t => t -> HList (Rep t)

-- | Types that can be built from a heterogenous list.
class HUnfoldable t where fromHList = case appendRightId (Proxy :: Proxy (Rep t)) of { Refl -> let parser :: HList (Rep t ++ []) -> (t, HList []) parser = runHParser hListParser in fst . parser }
fromHList :: HUnfoldable t => HList (Rep t) -> t
hListParser :: HUnfoldable t => HParser (Rep t) t

-- | A function that parses some value <tt>val</tt> with representation
--   <tt>rep</tt> from a heterogenous list and returns the parsed value and
--   leftovers.
newtype HParser (rep :: [*]) val
HParser :: (forall (leftover :: [*]). HList (rep ++ leftover) -> (val, HList leftover)) -> HParser val

-- | Run the parser.
runHParser :: HParser val -> forall (leftover :: [*]). HList (rep ++ leftover) -> (val, HList leftover)

-- | An indexed monad on a monoid.
class MonoidIndexedMonad (m :: k -> * -> *) where type family Empty :: k type family Append (x :: k) (y :: k) :: k
returnMI :: MonoidIndexedMonad m => a -> m Empty a
bindMI :: MonoidIndexedMonad m => m x a -> (a -> m y b) -> m (Append x y) b
instance [overlap ok] (HUnfoldable a, HUnfoldable b, HUnfoldable c, HUnfoldable d, HUnfoldable e, HUnfoldable f, HUnfoldable g, HUnfoldable h, HUnfoldable i, HUnfoldable j, HUnfoldable k, HUnfoldable l, HUnfoldable m) => HUnfoldable (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance [overlap ok] (HUnfoldable a, HUnfoldable b, HUnfoldable c, HUnfoldable d, HUnfoldable e, HUnfoldable f, HUnfoldable g, HUnfoldable h, HUnfoldable i, HUnfoldable j, HUnfoldable k, HUnfoldable l) => HUnfoldable (a, b, c, d, e, f, g, h, i, j, k, l)
instance [overlap ok] (HUnfoldable a, HUnfoldable b, HUnfoldable c, HUnfoldable d, HUnfoldable e, HUnfoldable f, HUnfoldable g, HUnfoldable h, HUnfoldable i, HUnfoldable j, HUnfoldable k) => HUnfoldable (a, b, c, d, e, f, g, h, i, j, k)
instance [overlap ok] (HUnfoldable a, HUnfoldable b, HUnfoldable c, HUnfoldable d, HUnfoldable e, HUnfoldable f, HUnfoldable g, HUnfoldable h, HUnfoldable i, HUnfoldable j) => HUnfoldable (a, b, c, d, e, f, g, h, i, j)
instance [overlap ok] (HUnfoldable a, HUnfoldable b, HUnfoldable c, HUnfoldable d, HUnfoldable e, HUnfoldable f, HUnfoldable g, HUnfoldable h, HUnfoldable i) => HUnfoldable (a, b, c, d, e, f, g, h, i)
instance [overlap ok] (HUnfoldable a, HUnfoldable b, HUnfoldable c, HUnfoldable d, HUnfoldable e, HUnfoldable f, HUnfoldable g, HUnfoldable h) => HUnfoldable (a, b, c, d, e, f, g, h)
instance [overlap ok] (HUnfoldable a, HUnfoldable b, HUnfoldable c, HUnfoldable d, HUnfoldable e, HUnfoldable f, HUnfoldable g) => HUnfoldable (a, b, c, d, e, f, g)
instance [overlap ok] (HUnfoldable a, HUnfoldable b, HUnfoldable c, HUnfoldable d, HUnfoldable e, HUnfoldable f) => HUnfoldable (a, b, c, d, e, f)
instance [overlap ok] (HUnfoldable a, HUnfoldable b, HUnfoldable c, HUnfoldable d, HUnfoldable e) => HUnfoldable (a, b, c, d, e)
instance [overlap ok] (HUnfoldable a, HUnfoldable b, HUnfoldable c, HUnfoldable d) => HUnfoldable (a, b, c, d)
instance [overlap ok] (HUnfoldable a, HUnfoldable b, HUnfoldable c) => HUnfoldable (a, b, c)
instance [overlap ok] (HUnfoldable a, HUnfoldable b) => HUnfoldable (a, b)
instance [overlap ok] Rep a ~ '[a] => HUnfoldable a
instance [overlap ok] HUnfoldable ()
instance [overlap ok] (HFoldable a, HFoldable b, HFoldable c, HFoldable d, HFoldable e, HFoldable f, HFoldable g, HFoldable h, HFoldable i, HFoldable j, HFoldable k, HFoldable l, HFoldable m) => HFoldable (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance [overlap ok] (HFoldable a, HFoldable b, HFoldable c, HFoldable d, HFoldable e, HFoldable f, HFoldable g, HFoldable h, HFoldable i, HFoldable j, HFoldable k, HFoldable l) => HFoldable (a, b, c, d, e, f, g, h, i, j, k, l)
instance [overlap ok] (HFoldable a, HFoldable b, HFoldable c, HFoldable d, HFoldable e, HFoldable f, HFoldable g, HFoldable h, HFoldable i, HFoldable j, HFoldable k) => HFoldable (a, b, c, d, e, f, g, h, i, j, k)
instance [overlap ok] (HFoldable a, HFoldable b, HFoldable c, HFoldable d, HFoldable e, HFoldable f, HFoldable g, HFoldable h, HFoldable i, HFoldable j) => HFoldable (a, b, c, d, e, f, g, h, i, j)
instance [overlap ok] (HFoldable a, HFoldable b, HFoldable c, HFoldable d, HFoldable e, HFoldable f, HFoldable g, HFoldable h, HFoldable i) => HFoldable (a, b, c, d, e, f, g, h, i)
instance [overlap ok] (HFoldable a, HFoldable b, HFoldable c, HFoldable d, HFoldable e, HFoldable f, HFoldable g, HFoldable h) => HFoldable (a, b, c, d, e, f, g, h)
instance [overlap ok] (HFoldable a, HFoldable b, HFoldable c, HFoldable d, HFoldable e, HFoldable f, HFoldable g) => HFoldable (a, b, c, d, e, f, g)
instance [overlap ok] (HFoldable a, HFoldable b, HFoldable c, HFoldable d, HFoldable e, HFoldable f) => HFoldable (a, b, c, d, e, f)
instance [overlap ok] (HFoldable a, HFoldable b, HFoldable c, HFoldable d, HFoldable e) => HFoldable (a, b, c, d, e)
instance [overlap ok] (HFoldable a, HFoldable b, HFoldable c, HFoldable d) => HFoldable (a, b, c, d)
instance [overlap ok] (HFoldable a, HFoldable b, HFoldable c) => HFoldable (a, b, c)
instance [overlap ok] (HFoldable a, HFoldable b) => HFoldable (a, b)
instance [overlap ok] Rep a ~ '[a] => HFoldable a
instance [overlap ok] HFoldable ()
instance [overlap ok] MonoidIndexedMonad HParser
