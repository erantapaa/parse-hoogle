-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Multi-set rewrite rules with guards and a parallel execution scheme
--   
--   Multi-set rewrite rules with guards and a parallel execution scheme
@package multisetrewrite
@version 0.6

module MultiSetRewrite.RuleSyntax
data MatchTask a
Prop :: a -> MatchTask a
Simp :: a -> MatchTask a
Guard :: (IO Bool) -> MatchTask a
AtomicGuard :: (STM Bool) -> MatchTask a
data WITHGUARD a
WITHGUARD :: a -> (IO Bool) -> WITHGUARD a
data WITHATOMICGUARD a
WITHATOMICGUARD :: a -> (STM Bool) -> WITHATOMICGUARD a
class ConvertHead a b | a -> b
convertHead :: ConvertHead a b => a -> [MatchTask b]
instance ConvertHead b a => ConvertHead (WITHATOMICGUARD b) a
instance ConvertHead b a => ConvertHead (WITHGUARD b) a
instance ConvertHead [a] a
instance ConvertHead ([a], [a]) a

module MultiSetRewrite.Base
type Tag = IORef ()
newTag :: IO (IORef ())
lookupTag :: [Tag] -> Tag -> Bool
data VAR a
VAR :: (IORef a) -> Tag -> VAR a
variable :: VAR a -> (IORef a)
var_tag :: VAR a -> Tag
DontCare :: VAR a
data L a
Val :: a -> L a
Var :: (VAR a) -> L a
dontCareVar :: IO (VAR a)
newVar :: IO (VAR a)
readVar :: VAR a -> IO a
writeVar :: VAR a -> a -> IO ()
class EMatch a
match :: EMatch a => [Tag] -> a -> a -> IO (Bool, [Tag])
class Match a
internal_match :: Match a => [Tag] -> (InternalMsg a) -> a -> IO (Bool, [Tag])
data InternalMsg a
InternalMsg :: a -> Tag -> InternalMsg a
message :: InternalMsg a -> a
msg_tag :: InternalMsg a -> Tag
instance Eq a => Eq (InternalMsg a)
instance Eq a => Eq (L a)
instance Eq (VAR a)
instance EMatch a => Match a
instance Show a => Show (InternalMsg a)
instance (Eq a, EMatch a, Show a) => EMatch (L a)

module MultiSetRewrite.RuleCompiler
class EMatch m => RuleCompiler a m rm idx st | a -> m rm idx st, rm -> a
atomicVerifyAndDeleteCnt :: RuleCompiler a m rm idx st => a -> Code_RHS c -> [(Check rm, IO (Maybe (Code_RHS c)))] -> IO (Maybe (Code_RHS c))
getIndex :: RuleCompiler a m rm idx st => a -> m -> IO idx
initSearch :: RuleCompiler a m rm idx st => a -> idx -> IO st
nextMsg :: RuleCompiler a m rm idx st => a -> st -> IO (Maybe rm)
extractMsg :: RuleCompiler a m rm idx st => rm -> IO (Maybe (InternalMsg m))
printMsg :: RuleCompiler a m rm idx st => a -> rm -> IO String
printReachMsg :: RuleCompiler a m rm idx st => a -> st -> IO String
type Code_RHS a = IO a
type CompClause store rmsg code = rmsg -> store -> IO (Maybe (Code_RHS code))
data Check a
Verify :: a -> Check a
VerifyAndDelete :: a -> Check a
AtomicGuardVerify :: (STM Bool) -> Check a
select :: RuleCompiler a m rm idx st => a -> rm -> [CompClause a rm c] -> IO (Maybe (Code_RHS c))
optimize :: [[MatchTask msg]] -> [[MatchTask msg]]
type Cnt a = IO (Maybe (Code_RHS a))
compileCnt :: (RuleCompiler act msg rmsg idx st, Show msg) => Code_RHS () -> [MatchTask msg] -> [CompClause act rmsg ()]
compileSingleCnt :: (RuleCompiler act msg rmsg idx st, Show msg) => act -> Cnt a -> ([(Check rmsg, Cnt a)], Code_RHS a) -> [Tag] -> [MatchTask msg] -> IO (Maybe (Code_RHS a))

module MultiSetRewrite.StoreRepresentation
type HashIdx = Int
data HashOp msg
HashOp :: HashIdx -> (msg -> HashIdx) -> HashOp msg
numberOfTables :: HashOp msg -> HashIdx
hashMsg :: HashOp msg -> msg -> HashIdx
data Store msg
Store :: [Bag (InternalMsg msg)] -> HashOp msg -> Store msg
msgTable :: Store msg -> [Bag (InternalMsg msg)]
hashOp :: Store msg -> HashOp msg
type Location msg = IORef (List (InternalMsg msg))
newStore :: (EMatch msg, Eq msg, Show msg) => HashOp msg -> IO (Store msg)
compileRulePattern :: (EMatch msg, Eq msg, Show msg) => [([MatchTask msg], Code_RHS ())] -> [CompClause (Store msg) (Location msg) ()]
addMsg :: (EMatch msg, Eq msg, Show msg) => (Store msg) -> msg -> IO (Location msg)
executeRules :: (EMatch msg, Eq msg, Show msg) => Store msg -> Location msg -> [CompClause (Store msg) (Location msg) ()] -> IO (Maybe (Code_RHS ()))
instance (EMatch msg, Eq msg, Show msg) => RuleCompiler (Store msg) msg (Location msg) HashIdx (Iterator (InternalMsg msg))

module MultiSetRewrite.StorePrettyPrinter
retrieveList :: ListHandle a -> IO [a]
retrieveBag :: Bag a -> IO [a]
class PrettyPrint a
prettyIt :: PrettyPrint a => a -> IO String
prettyItList :: PrettyPrint a => [a] -> String -> IO String
instance PrettyPrint a => PrettyPrint (Store a)
instance PrettyPrint a => PrettyPrint (Bag a)
instance PrettyPrint a => PrettyPrint (InternalMsg a)
instance PrettyPrint a => PrettyPrint (TVar a)
instance PrettyPrint a => PrettyPrint (MVar a)
instance PrettyPrint Bool
instance PrettyPrint Char
instance PrettyPrint Int
instance PrettyPrint a => PrettyPrint [a]
instance PrettyPrint a => PrettyPrint (L a)
instance PrettyPrint a => PrettyPrint (VAR a)
