-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | SPDX license expression language
--   
@package spdx
@version 0.2.0.0


-- | Inspired by <a>Simple SMT Solver</a>.
--   
--   In future this module will probably be moved into separate package.
module Data.SPDX.LatticeSyntax
data LatticeSyntax a
LVar :: a -> LatticeSyntax a
LBound :: Bool -> LatticeSyntax a
LJoin :: (LatticeSyntax a) -> (LatticeSyntax a) -> LatticeSyntax a
LMeet :: (LatticeSyntax a) -> (LatticeSyntax a) -> LatticeSyntax a
dual :: LatticeSyntax a -> LatticeSyntax a
freeVars :: LatticeSyntax a -> [a]

-- | Test for equivalence.
--   
--   <pre>
--   &gt;&gt;&gt; equivalent (LMeet (LVar 'a') (LVar 'b')) (LMeet (LVar 'b') (LVar 'a'))
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; equivalent (LVar 'a') (LMeet (LVar 'a') (LVar 'a'))
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; equivalent (LMeet (LVar 'a') (LVar 'b')) (LMeet (LVar 'b') (LVar 'b'))
--   False
--   </pre>
equivalent :: Eq a => LatticeSyntax a -> LatticeSyntax a -> Bool

-- | Test for preorder.
--   
--   <pre>
--   a ≤ b ⇔ a ∨ b ≡ b ⇔ a ≡ a ∧ b
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; preorder (LVar 'a' `LMeet` LVar 'b') (LVar 'a')
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; preorder (LVar 'a') (LVar 'a' `LMeet` LVar 'b')
--   False
--   </pre>
preorder :: Eq a => LatticeSyntax a -> LatticeSyntax a -> Bool

-- | Return <a>True</a> if for some variable assigment expression evaluates
--   to <a>True</a>.
satisfiable :: Eq a => LatticeSyntax a -> Bool
instance Typeable LatticeSyntax
instance Eq a => Eq (LatticeSyntax a)
instance Ord a => Ord (LatticeSyntax a)
instance Read a => Read (LatticeSyntax a)
instance Show a => Show (LatticeSyntax a)
instance Functor LatticeSyntax
instance Foldable LatticeSyntax
instance Traversable LatticeSyntax
instance Data a => Data (LatticeSyntax a)
instance Functor (Eval v)
instance Applicative (Eval v)
instance Alternative (Eval v)
instance Monad (Eval v)
instance MonadPlus (Eval v)
instance Monad LatticeSyntax
instance Applicative LatticeSyntax


module Data.SPDX

-- | Opaque license identifier type.
data LicenseId
getLicenseId :: LicenseId -> String

-- | Opaque license exception identifier type.
data LicenseExceptionId
getLicenseExceptionId :: LicenseExceptionId -> String
data LicenseRef
LicenseRef :: !(Maybe String) -> !String -> LicenseRef
lrDocument :: LicenseRef -> !(Maybe String)
lrLicense :: LicenseRef -> !String
data LicenseExpression
ELicense :: !Bool -> !(Either LicenseRef LicenseId) -> !(Maybe LicenseExceptionId) -> LicenseExpression
EConjunction :: !LicenseExpression -> !LicenseExpression -> LicenseExpression
EDisjunction :: !LicenseExpression -> !LicenseExpression -> LicenseExpression

-- | A list of <a>LicenseId</a>, license name and whether the license is
--   OSI approved.
--   
--   See <a>http://spdx.org/licenses/</a>.
licenses :: [(LicenseId, String, Bool)]

-- | A list of SPDX licenses identifiers.
--   
--   See <a>http://spdx.org/licenses/</a>.
licenseIdentifiers :: [LicenseId]

-- | Lookup <a>LicenseId</a> by string representation
mkLicenseId :: String -> Maybe LicenseId

-- | Whether license is OSI approved
--   
--   See <a>http://opensource.org/licenses/alphabetical</a>
isOsiApproved :: LicenseId -> Bool
licenseExceptions :: [LicenseExceptionId]
licenseRanges :: [[LicenseId]]

-- | Lookup newer licenses we know about
--   
--   <pre>
--   &gt;&gt;&gt; lookupLicenseRange $ fromJust $ mkLicenseId "MIT"
--   [LicenseId "MIT"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lookupLicenseRange $ fromJust $ mkLicenseId "GPL-2.0"
--   [LicenseId "GPL-2.0",LicenseId "GPL-3.0"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lookupLicenseRange $ fromJust $ mkLicenseId "LGPL-2.0"
--   [LicenseId "LGPL-2.0",LicenseId "LGPL-2.1",LicenseId "LGPL-3.0"]
--   </pre>
lookupLicenseRange :: LicenseId -> [LicenseId]

-- | Parse SPDX License Expression
--   
--   <pre>
--   &gt;&gt;&gt; parseExpression "LGPL-2.1 OR MIT"
--   [EDisjunction (ELicense False (Right (LicenseId "LGPL-2.1")) Nothing) (ELicense False (Right (LicenseId "MIT")) Nothing)]
--   </pre>
parseExpression :: String -> [LicenseExpression]
unsafeParseExpr :: String -> LicenseExpression
prettyLicenseId :: LicenseId -> String
prettyLicenseExceptionId :: LicenseExceptionId -> String
prettyLicenseRef :: LicenseRef -> String
prettyLicenseExpression :: LicenseExpression -> String

-- | <pre>
--   ⟦ satisfies a b ⟧ ≡ a ≥ b ≡ a ∧ b = b
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unsafeParseExpr "GPL-3.0" `satisfies` unsafeParseExpr "ISC AND MIT"
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unsafeParseExpr "Zlib" `satisfies` unsafeParseExpr "ISC AND MIT AND Zlib"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unsafeParseExpr "(MIT OR GPL-2.0)" `satisfies` unsafeParseExpr "(ISC AND MIT)"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unsafeParseExpr "(MIT AND GPL-2.0)" `satisfies` unsafeParseExpr "(MIT AND GPL-2.0)"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unsafeParseExpr "(MIT AND GPL-2.0)" `satisfies` unsafeParseExpr "(ISC AND GPL-2.0)"
--   False
--   </pre>
satisfies :: LicenseExpression -> LicenseExpression -> Bool

-- | Check wheather two <a>LicenseExpression</a> are equivalent.
--   
--   <pre>
--   &gt;&gt;&gt; unsafeParseExpr "(MIT AND GPL-2.0)" `equivalent` unsafeParseExpr "(GPL-2.0 AND MIT)"
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unsafeParseExpr "MIT" `equivalent` unsafeParseExpr "MIT OR BSD-3-Clause"
--   False
--   </pre>
equivalent :: LicenseExpression -> LicenseExpression -> Bool
instance Eq Lic
instance Ord Lic
instance Show Lic
instance Read Lic
