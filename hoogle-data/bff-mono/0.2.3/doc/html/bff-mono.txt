-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | "Bidirectionalization for Free" for Monomorphic Transformations
--   
--   This package provides a way to make a bidirectional transformation (a
--   getter/setter pair, or so-called lens) from a description of
--   unidirectional transformation. Like <a>bff</a> package, the package
--   constructs bidirectional transformations based on the free theorem.
--   Unlike <a>bff</a> package, the package supports some of monomorphic
--   transformations.
@package bff-mono
@version 0.2.3


-- | The module provides counterparts of <tt>..By</tt> functions in
--   <a>Data.List</a> for monadic observations.
module Data.BffMono.Utility
ifM :: Monad m => m Bool -> m a -> m a -> m a
nubByM :: Monad m => (a -> a -> m Bool) -> [a] -> m [a]
deleteByM :: Monad m => (a -> a -> m Bool) -> a -> [a] -> m [a]
deleteFirstByM :: Monad m => (a -> a -> m Bool) -> a -> [a] -> m [a]
unionByM :: Monad m => (a -> a -> m Bool) -> [a] -> [a] -> m [a]
intersectByM :: Monad m => (a -> a -> m Bool) -> [a] -> [a] -> m [a]
elemByM :: Monad m => (a -> a -> m Bool) -> a -> [a] -> m Bool
groupByM :: Monad m => (a -> a -> m Bool) -> [a] -> m [[a]]
traceM :: Monad m => m String -> m a -> m a
sortByM :: Monad m => (a -> a -> m Ordering) -> [a] -> m [a]
insertByM :: Monad m => (a -> a -> m Ordering) -> a -> [a] -> m [a]
maximumByM :: Monad m => (a -> a -> m Ordering) -> [a] -> m a
minimumByM :: Monad m => (a -> a -> m Ordering) -> [a] -> m a


-- | The module provides an automatic way to construct a bidirectional
--   transformation (rougly speaking, a getter/setter pair) from a
--   uni-directional transformation (or, a getter function).
--   
--   The module provides a class <a>PackM</a>. Once we write a
--   transformation of type
--   
--   <pre>
--   h :: (Traversable src, Traversable tgt) =&gt; forall a m.PackM c a m =&gt; src a -&gt; m (tgt a)
--   </pre>
--   
--   then applying <a>fwd</a> to obtain a forward transformation (so-called
--   "get" or "getter")
--   
--   <pre>
--   fwd h :: src c -&gt; tgt c 
--   </pre>
--   
--   and applying <a>bwd</a> to obtain a backward transformation (so-called
--   "put" or "setter").
--   
--   <pre>
--   bwd h :: (MonadError e m, Error e) =&gt; src c -&gt; tgt c -&gt; m (src c)
--   </pre>
--   
--   assuming that <tt>c</tt> is some concrete type and <tt>src</tt> and
--   <tt>tgt</tt> are some concrete containers (<a>Traversable</a>
--   instances) with <tt>Eq c</tt> and <tt>Eq (tgt ())</tt>.
--   
--   The correctness of the obtained bidirectional transformation (GetPut
--   and PutGet) is guaranted for free. That is, the following laws hold
--   (assuming that we use <tt><a>Either</a> <a>String</a></tt> for the
--   result of <a>bwd</a>).
--   
--   <pre>
--   bwd h s (fwd h s) = Right s
--   </pre>
--   
--   <pre>
--   bwd h s v = Right s'  implies fwd h s' = v
--   </pre>
module Data.BffMono

-- | <tt>Pack conc abs</tt> provides a way to abstract <tt>conc</tt> by
--   <tt>abs</tt>. The class is used just as an interface. Thus, no
--   instances are provided by this package.
class Pack conc abs | abs -> conc
new :: Pack conc abs => conc -> abs

-- | <tt>PackM</tt> is the interface for our bidirectionalization. See also
--   <a>fwd</a> and <a>bwd</a>.
--   
--   <tt>PackM conc abs monad</tt> provides a way to abstract <tt>conc</tt>
--   by <tt>abs</tt>, with recording <a>observations</a> through
--   <tt>monad</tt>. Similarly to <tt>Pack</tt>, this class is also used
--   just as an interface. Thus, no instances are provided by this package.
class (Pack conc abs, Monad m, Functor m) => PackM conc abs m
liftO :: (PackM conc abs m, Eq r) => ([conc] -> r) -> ([abs] -> m r)
eqSync :: (PackM conc abs m, Eq conc) => abs -> abs -> m Bool
compareSync :: (PackM conc abs m, Ord conc) => abs -> abs -> m Ordering

-- | A special version of <a>liftO</a> for unary observations.
liftO1 :: (PackM conc abs m, Eq r) => (conc -> r) -> abs -> m r

-- | A special version of <a>liftO</a> for binary observations.
liftO2 :: (PackM conc abs m, Eq r) => (conc -> conc -> r) -> abs -> abs -> m r

-- | Constructs a forward transformation (or, "get" or "getter") from a
--   given function.
fwd :: (Traversable vf, Traversable sf) => (forall a m. PackM c a m => sf a -> m (vf a)) -> sf c -> vf c

-- | Constructs a backward transformation (or, "put" or "setter") from a
--   given function.
bwd :: (Eq (vf ()), Traversable vf, Traversable sf, Eq c, MonadError e n, Error e) => (forall a m. PackM c a m => sf a -> m (vf a)) -> sf c -> vf c -> n (sf c)
