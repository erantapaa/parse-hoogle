-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Functions for working with strings, including Text, ByteString, etc.
--   
--   This package provides various functions for working with strings, such
--   as <tt>join</tt>, <tt>split</tt>, <tt>toUppercase</tt>, etc.
--   
--   The functions in this package work with all kinds of strings such as
--   Text, ByteString, String, and their respective lazy counter parts.
--   There is also an interface which is agnostic of the underlying string
--   type.
--   
--   <ul>
--   <li><i><tt>v1.0.2</tt></i> Fixed an issue with <tt>strSplitAll</tt>.
--   Applied to the empty string it should return an empty list, but it
--   returned a list containing a single empty string. It now returns
--   correctly the empty list.</li>
--   <li><i><tt>v1.1</tt></i> Added <tt>strToUpper</tt>,
--   <tt>strToLower</tt>, <tt>strCapitalize</tt>, <tt>strCons</tt>, and
--   <tt>strMap</tt>. Also <tt>sCapitalize</tt>, <tt>sCons</tt>, and
--   <tt>sMap</tt>.</li>
--   </ul>
@package strings
@version 1.1


-- | Functions for working with strings, including <a>Text</a>,
--   <a>ByteString</a>, etc.
--   
--   This module aims at offering a consistent interface across all the
--   available string types. It currently offers instances for the ordinary
--   Haskell <a>String</a> type, <a>Text</a>, lazy <a>Text</a>,
--   <a>ByteString</a>, and lazy <a>ByteString</a>.
--   
--   It especially provides functions for some types, which are otherwise
--   not available nativly (such as <tt>breakOnSubstring</tt> which is not
--   available for the lazy <a>Text</a> type, is offered by <a>sBreak</a>
--   and <a>strBreak</a>).
module Data.Strings

-- | Create a <a>Text</a> object form an ordinary Haskell <a>String</a>.
text :: String -> Text

-- | Create a lazy <a>Text</a> object from an ordinary Haskell
--   <a>String</a>.
lazyText :: String -> Text

-- | Create a <a>ByteString</a> object form an ordinary Haskell
--   <a>String</a>. This function will encode a String using the UTF-8
--   character encoding.
bytes :: String -> ByteString

-- | Create a lazy <a>ByteString</a> object from an ordinary Haskell
--   <a>String</a>. This function will encode a String using the UTF-8
--   character encoding.
lazyBytes :: String -> ByteString

-- | Convert a <a>Char</a> into a <a>Word8</a>.
charToByte :: Char -> Word8

-- | Convert a <a>Word8</a> into a <a>Char</a>.
byteToChar :: Word8 -> Char

-- | The <a>Str</a> class provides functions for working with arbitrary
--   Strings. It is basically the same interface as provided by the
--   <a>Strings</a> class. However, every input string is a Haskell String
--   here, thus easing the usage of different string types with native
--   Haskell String literals.
--   
--   For example <tt>strAppend <a>suffix</a></tt> works with any string
--   type for which an instance of <tt>Str</tt> is defined. In order to
--   maximize the ease of use of this library, the functions are prefixed
--   with <tt>str</tt>.
--   
--   The complexity and efficiency of these functions depends on the
--   underlying string type being used.
--   
--   Minimal complete definition: It suffices to provide instances for
--   <a>Eq</a> and <a>Strings</a>.
class (Eq a, Strings a) => Str a where strNull = sNull strLen = sLen strHead = sHead strLast = sLast strInit = sInit strTail = sTail strTake = sTake strDrop = sDrop strReplace n r = sReplace (fromString n) (fromString r) strBreak n = sBreak (fromString n) strSplit d s = (a, b) where (a, b, _) = sSplit (fromString d) s strSplitAll n = sSplitAll (fromString n) strToLower = strMap toLower strToUpper = strMap toUpper strCapitalize str = strCons (toUpper (strHead str)) (strTail str) strCons = sCons strMap = sMap strConcat = sConcat strJoin d = let d' = fromUnicodeString d in strConcat . intersperse d' strAppend x xs = sConcat [xs, fromString x] strTrim = sTrim strPadLeft = sPadLeft strPadRight = sPadRight strPadBoth = sPadBoth strReverse = sReverse strStartsWith s pref = sStartsWith s (fromString pref) strEndsWith s suff = sEndsWith s (fromString suff) strEq s1 s2 = fromUnicodeString s1 == s2 fromString = sFromString fromUnicodeString = sFromUnicodeString toString = sToString toWord8 = sToWord8
strNull :: Str a => a -> Bool
strLen :: Str a => a -> Int
strHead :: Str a => a -> Char
strLast :: Str a => a -> Char
strInit :: Str a => a -> a
strTail :: Str a => a -> a
strTake :: Str a => Int -> a -> a
strDrop :: Str a => Int -> a -> a
strReplace :: Str a => String -> String -> a -> a
strBreak :: Str a => String -> a -> (a, a)
strSplit :: Str a => String -> a -> (a, a)
strSplitAll :: Str a => String -> a -> [a]
strToUpper :: Str a => a -> a
strToLower :: Str a => a -> a
strCapitalize :: Str a => a -> a
strMap :: Str a => (Char -> Char) -> a -> a
strConcat :: Str a => [a] -> a
strJoin :: Str a => String -> [a] -> a
strAppend :: Str a => String -> a -> a
strCons :: Str a => Char -> a -> a
strTrim :: Str a => a -> a
strPadLeft :: Str a => Char -> Int -> a -> a
strPadRight :: Str a => Char -> Int -> a -> a
strPadBoth :: Str a => Char -> Int -> a -> a
strReverse :: Str a => a -> a
strEq :: Str a => String -> a -> Bool
strStartsWith :: Str a => a -> String -> Bool
strEndsWith :: Str a => a -> String -> Bool
fromString :: Str a => String -> a
fromUnicodeString :: Str a => String -> a
toString :: Str a => a -> String
toWord8 :: Str a => a -> [Word8]

-- | The goal of this class is to offer the same interface for various
--   types of strings (<a>ByteString</a>, <a>Text</a>, Haskell
--   <a>String</a>, etc.). If a certain type offers a native implementation
--   for a given function, <a>Strings</a> uses it. If not, a default
--   implementation is given.
--   
--   All of these functions are prefixed with <tt>s</tt> to avoid
--   nameclashes with existing functions from the prelude.
--   
--   The complexity and efficiency of these functions depends on the
--   underlying string type being used.
class Strings a where sCapitalize xs | sNull xs = xs | otherwise = sCons (toUpper (sHead xs)) (sTail xs) sBreak d src = search 0 src where search a b | a `seq` b `seq` False = undefined search n s | sNull s = (src, sEmpty) | sStartsWith s d = (sTake n src, s) | otherwise = search (n + 1) (sTail s) sReplace n r = sConcat . replace n r where replace n r h = if sNull b then (if c then [a, r] else [a]) else a : r : replace n r b where (a, b, c) = sSplit n h sSplit d s = (a, sDrop (sLen d) b, not $ sNull b) where (a, b) = sBreak d s sSplitAll d s = if sNull b then (if c then [a, b] else [a]) else a : sSplitAll d b where (a, b, c) = sSplit d s sPadLeft c n s = let len = sLen s padLen = max 0 (n - len) padStr = sFromString $ replicate padLen c in sConcat [padStr, s] sPadRight c n s = let len = sLen s padLen = max 0 (n - len) padStr = sFromString $ replicate padLen c in sConcat [s, padStr] sPadBoth c n s = let len = sLen s padLen = (max 0 (n - len)) padLenR = padLen `quot` 2 padLenL = padLen - padLenR padStrL = sFromString $ replicate padLenL c padStrR = sFromString $ replicate padLenR c in sConcat [padStrL, s, padStrR] sFromString = sFromUnicodeString sToWord8 = sToWord8 . sToString
sNull :: Strings a => a -> Bool
sEmpty :: Strings a => a
sLen :: Strings a => a -> Int
sHead :: Strings a => a -> Char
sLast :: Strings a => a -> Char
sInit :: Strings a => a -> a
sTail :: Strings a => a -> a
sTake :: Strings a => Int -> a -> a
sDrop :: Strings a => Int -> a -> a
sTakeWhile :: Strings a => (Char -> Bool) -> a -> a
sDropWhile :: Strings a => (Char -> Bool) -> a -> a
sReplace :: Strings a => a -> a -> a -> a
sBreak :: Strings a => a -> a -> (a, a)
sSplit :: Strings a => a -> a -> (a, a, Bool)
sSplitAll :: Strings a => a -> a -> [a]
sStartsWith :: Strings a => a -> a -> Bool
sEndsWith :: Strings a => a -> a -> Bool
sCons :: Strings a => Char -> a -> a
sCapitalize :: Strings a => a -> a
sMap :: Strings a => (Char -> Char) -> a -> a
sConcat :: Strings a => [a] -> a
sTrim :: Strings a => a -> a
sPadLeft :: Strings a => Char -> Int -> a -> a
sPadRight :: Strings a => Char -> Int -> a -> a
sPadBoth :: Strings a => Char -> Int -> a -> a
sReverse :: Strings a => a -> a
sFromString :: Strings a => String -> a
sFromUnicodeString :: Strings a => String -> a
sToString :: Strings a => a -> String
sToWord8 :: Strings a => a -> [Word8]
instance Chars Integer
instance Chars Int64
instance Chars Int32
instance Chars Int16
instance Chars Int8
instance Chars Word64
instance Chars Word32
instance Chars Word16
instance Chars Word8
instance Chars Int
instance Strings String
instance Strings Text
instance Strings Text
instance Strings ByteString
instance Strings ByteString
instance Str String
instance Str ByteString
instance Str ByteString
instance Str Text
instance Str Text
