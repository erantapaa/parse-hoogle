-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A library providing safe lazy IO features.
--   
--   Provides a safer API for incremental IO processing in a way very close
--   to standard lazy IO.
@package safe-lazy-io
@version 0.1


-- | This code is extracted from GHC sources and changed to no longer
--   discards I/O errors.
module System.IO.Unsafe.GetContents

-- | <a>unsafeHGetContents</a> is pretty much like hGetContents but does
--   not discards I/O errors get during the lazy reading.
--   
--   This code was copy/pasted from the GHC version of hGetContents.
unsafeHGetContents :: Handle -> IO String
lazyRead :: Handle -> IO String


module System.IO.Lazy.Input.Internals

-- | Values with their finalizer.
data Finalized a
Finally :: a -> IO () -> Finalized a
finalized :: Finalized a -> a
finalizer :: Finalized a -> IO ()

-- | Run a <i>finalized</i> computation.
finalize :: Finalized (IO a) -> IO a

-- | This the type lazy input data.
--   
--   Note that the lazy input type (<a>LI</a>) is a member of
--   <a>Functor</a>, this means that one can update the contents of the
--   input with any pure function.
--   
--   <a>LI</a> could be a strict monad and a strict applicative functor.
--   However it is not a lazy monad nor a lazy applicative functor as
--   required Haskell. Hopefully it is a lazy (pointed) functor at least.
newtype LI a
LI :: IO (Finalized a) -> LI a
startLI :: LI a -> IO (Finalized a)

-- | Build lazy input (<a>LI</a>) from an <a>IO</a> computation. Use this
--   function when the computation does not require a finalizer.
nonFinalized :: IO a -> LI a

-- | Build lazy input (<a>LI</a>) from an <a>IO</a> computation and a
--   <a>finalizer</a>.
finallyLI :: IO a -> IO () -> LI a

-- | Update the underlying <a>Finalized</a> value.
mapFinalized :: (Finalized a -> Finalized b) -> LI a -> LI b

-- | <tt>x `catchEOF` y</tt> performs <tt>x</tt> and if it fails due to the
--   EOF error then performs <tt>y</tt>.
catchEOF :: IO a -> IO a -> IO a

-- | Take a list and returns a new channel the list written in it.
chanFromList :: [a] -> IO (Chan a)

-- | This function lazily returns an element strict list. It is lazier than
--   <tt>rnf</tt> and stricter than <tt>map (\x-&gt; rnf x <a>seq</a>
--   x)</tt>.
rnfList :: (NFData sa) => [sa] -> [sa]
instance Functor LI
instance Applicative Finalized
instance Functor Finalized

module System.IO.Lazy.Input

-- | This the type lazy input data.
--   
--   Note that the lazy input type (<a>LI</a>) is a member of
--   <a>Functor</a>, this means that one can update the contents of the
--   input with any pure function.
--   
--   <a>LI</a> could be a strict monad and a strict applicative functor.
--   However it is not a lazy monad nor a lazy applicative functor as
--   required Haskell. Hopefully it is a lazy (pointed) functor at least.
data LI a

-- | Extract the data from a lazy input, this is commonly used to actually
--   run the given process over lazy inputs. As in all the functions that
--   requires a <a>NFData</a> instance this means the result will forced
--   using <a>rnf</a>.
run :: (NFData sa) => LI sa -> IO sa

-- | Pretty much as <a>run</a> expect that one can use strict <i>IO</i>s
--   (<a>System.IO.Strict</a>) to produce the final result.
run' :: (NFData sa) => LI (SIO sa) -> IO sa

-- | Pretty much as <a>run</a> but live in the <a>SIO</a> monad instead of
--   <a>IO</a>.
runAsSIO :: (NFData sa) => LI sa -> SIO sa

-- | Pretty much as <a>run'</a> but live in the <a>SIO</a> monad instead of
--   <a>IO</a>.
runAsSIO' :: (NFData sa) => LI (SIO sa) -> SIO sa

-- | Any pure data can lifted as lazy input.
pureLI :: a -> LI a

-- | Returns the contents of the given handle lazily.
hGetContents :: Handle -> LI String

-- | Returns the contents of standard input lazily.
getContents :: LI String

-- | Like <a>hGetContents</a> but it takes a <a>FilePath</a>.
readFile :: FilePath -> LI String

-- | Return a lazy list representing the contents of the supplied
--   <a>Chan</a>, much like System.IO.hGetContents.
getChanContents :: Chan a -> LI [a]

-- | Sequence two lazy inputs that produces lists as one only list. Note
--   that the resource management is precise. As soon as the beginning of
--   the second input is required, the resource of the first input is
--   released and the the second resource is acquired.
append :: (NFData sa) => LI [sa] -> LI [sa] -> LI [sa]

-- | Same as <a>append</a> but for a list of inputs.
concat :: (NFData sa) => [LI [sa]] -> LI [sa]

-- | Takes two lazy inputs and returns a single interleaved lazy input.
--   Note that this function is left biased, this is always the left canal
--   that is read first. This function is rarely used directly with file
--   contents since it mixes the two contents, one generally use some
--   tagging to separate them back. Look at <a>interleaveEither</a> for
--   such a function.
interleave :: (NFData sa) => LI [sa] -> LI [sa] -> LI [sa]

-- | Like <a>interleave</a> but it starts by tagging the left input by
--   <a>Left</a> and right input by <a>Right</a> leading to lazy input of
--   <a>Either</a>s.
interleaveEither :: (NFData sa, NFData sb) => LI [sa] -> LI [sb] -> LI [Either sa sb]

-- | Combine two lazy inputs as a single lazy input of pairs.
--   
--   Note that if one input list is short, excess elements of the longer
--   list are discarded.
zip :: (NFData sa, NFData sb) => LI [sa] -> LI [sb] -> LI [(sa, sb)]

-- | <a>zipWith</a> generalize <a>zip</a> with any combining function.
zipWith :: (NFData sa, NFData sb) => (sa -> sb -> c) -> LI [sa] -> LI [sb] -> LI [c]
zipMaybesWith :: (NFData sa, NFData sb) => (Maybe sa -> Maybe sb -> c) -> LI [sa] -> LI [sb] -> LI [c]

-- | A shorthand for <tt>\h1 h2-&gt; zip (hGetContents h1) (hGetContents
--   h2)</tt>.
zipHandles :: Handle -> Handle -> LI [(Char, Char)]

-- | Add debugging messages using the given string. This will returns the
--   same lazy input but more verbose.
trace :: String -> LI a -> LI a

module System.IO.Lazy.Input.Extra

-- | Lift a pure two arguments function, to a function over lazy inputs.
--   
--   Note that the only the first argument <i>may</i> be deeply forced. In
--   particular it is deeply forced if the function use its second
--   argument.
--   
--   The strictness is here to enforce the evaluation order of reading
--   inputs.
--   
--   Since too much strictness breaks the interest of lazy inputs, one
--   provides more specific but lazier combinators like <a>append</a>,
--   <a>interleave</a>, and <a>zip</a>.
lift2MayForceFirst :: (NFData sa) => (sa -> b -> c) -> LI sa -> LI b -> LI c

-- | Lift a pure two arguments function, to a function over lazy inputs.
--   
--   Note that the only the first argument is deeply forced before calling
--   the function.
--   
--   The strictness is here to enforce the evaluation order of reading
--   inputs.
--   
--   This lifting function can be generalized to n-ary functions, all
--   arguments but the last one will be deeply forced.
--   
--   <pre>
--   liftN f mx1 mx2 ... mxN = mx1 !&gt;&gt;= x1 -&gt; mx2 !&gt;&gt;= x2 -&gt; ... f x1 x2 <a>$</a> mxN
--   </pre>
lift2ForceFirst :: (NFData sa) => (sa -> b -> c) -> LI sa -> LI b -> LI c
lift2ForceSecond :: (NFData sb) => (a -> sb -> c) -> LI a -> LI sb -> LI c

-- | Lift a pure two arguments function, to a function over lazy inputs.
--   
--   Note that both arguments are deeply forced before calling the
--   function. See <a>lift2ForceFirst</a> and <a>lift2ForceSecond</a> for
--   lazier versions.
--   
--   This one can also be generalized to n-ary functions:
--   
--   <pre>
--   liftN f mx1 mx2 ... mxN = pureLI f <a>ap'</a> mx1 <a>ap'</a> mx2 <a>ap'</a> ... <a>ap'</a> mxN
--   </pre>
lift2ForceBoth :: (NFData sa, NFData sb) => (sa -> sb -> c) -> LI sa -> LI sb -> LI c

-- | A kind of strict <i>bind</i> over lazy inputs.
(!>>=) :: (NFData sa) => LI sa -> (sa -> LI b) -> LI b

-- | Same as <a>!&gt;&gt;=</a> but with arguments flipped.
(=<<!) :: (NFData sa) => (sa -> LI b) -> LI sa -> LI b

-- | Combines a function wrapped as a lazy input and an argument. This is
--   like <a>ap</a> or <a>&lt;*&gt;</a> but stricter.
--   
--   Note that since functions types are not member of <a>NFData</a>, this
--   function is the only one dealing with functions wrapped as lazy
--   inputs.
--   
--   However as with <a>ap</a> or <a>&lt;*&gt;</a>, this function
--   generalize <a>lift2ForceSecond</a>, lift3Fst...
--   
--   Example: <tt> lift3Fst f x y z = f <a>$</a> x <a>ap'</a> y <a>ap'</a>
--   z lift3strict f x y z = pureLI f <a>ap'</a> x <a>ap'</a> y <a>ap'</a>
--   z </tt>
--   
--   The <a>ap'</a> function only deeply force the second argument, so in
--   the case of chaining, the arguments will be forced from left to right.
--   Note that if one starts the chain by lifting the function using
--   <a>pureLI</a>, then all the arguments will be forced. One can let one
--   of the arguments lazy by using note however that if one start the
--   chain with <a>&lt;$&gt;</a> (same as <a>fmap</a> or <a>liftM</a>) then
--   the first argument would not be forced, but one can start with
--   <a>pureLI</a>
ap' :: (NFData sa) => LI (sa -> b) -> LI sa -> LI b

-- | Turns a list of lazy inputs as an input of list.
sequence :: (NFData sa) => [LI sa] -> LI [sa]
