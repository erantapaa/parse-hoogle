-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An engine for text-based dungeons.
--   
@package antisplice
@version 0.17.1.0


-- | Provides the error datatype for Antisplice
module Game.Antisplice.Errors

-- | Antisplice errors
data SplErr
UnknownError :: SplErr

-- | Triggers program termination
QuitError :: SplErr

-- | Escape the waiter loop
DoneError :: SplErr

-- | "I don't understand that."
UnintellegibleError :: SplErr

-- | "Please start with a verb."
VerbMustFirstError :: SplErr

-- | "I can't see one here."
CantSeeOneError :: SplErr

-- | "You don't carry one."
DontCarryOneError :: SplErr

-- | "Which one do you mean?"
WhichOneError :: SplErr

-- | "I can't equip that."
CantEquipThatError :: SplErr

-- | "I can't wear that there. You might want to try some other place?"
CantEquipThatThereError :: SplErr

-- | "Where?"
WhereToEquipError :: SplErr

-- | "Sorry, I can't cast that now. Check you health, mana and cooldowns."
CantCastThatNowError :: SplErr

-- | "I can't walk there."
CantWalkThereError :: SplErr

-- | "I can't take that."
CantAcquireThatError :: SplErr

-- | "I won't hit that."
WontHitThatError :: SplErr

-- | "Wrong method for creating that."
WrongMethodError :: SplErr

-- | To embed ReErrors
ReError :: ReError -> SplErr

-- | Antisplice new errors
data ReError
Unint :: Int -> String -> ReError
Uncon :: String -> ReError
Forward :: String -> ReError
Bye :: ReError

-- | Alias for <a>FailT</a> <a>SplErr</a>
type SplErrT m = FailT SplErr m
instance Eq ReError
instance Ord ReError
instance Show ReError
instance Show SplErr


-- | Provides a monad that collects vocab during dungeon construction and
--   reproduces it later.
module Game.Antisplice.Monad.Vocab

-- | Algebraic type for primitive and complex tokens.
data Token
Unintellegible :: String -> Token
Verb :: String -> Token
Prep :: String -> Token
Noun :: String -> Token
Adj :: String -> Token
Ordn :: Int -> String -> Token
Fixe :: String -> Token
Skilln :: String -> Token

-- | Complex noun, with attributes and maybe ordinal index.
Nounc :: [String] -> (Maybe Int) -> String -> Token

-- | The vocab monad. Carries the currently noun vocab as its state.
newtype VocabT m a
Vocab :: (TST Token -> m (a, TST Token)) -> VocabT m a
runVocabT :: VocabT m a -> TST Token -> m (a, TST Token)

-- | Tyepclass for all vocab-memorizing monads.
class Monad m => MonadVocab m
lookupVocab :: MonadVocab m => String -> m Token
insertVocab :: MonadVocab m => String -> (String -> Token) -> m ()
vocabKnown :: MonadVocab m => String -> m Bool
instance Eq Token
instance Monad m => MonadVocab (VocabT m)
instance MonadIO m => MonadIO (VocabT m)
instance MonadTrans VocabT
instance Monad m => Monad (VocabT m)
instance (Functor m, Monad m) => Applicative (VocabT m)
instance Functor m => Functor (VocabT m)
instance Tuplify Token Token
instance Show Token


-- | Provides the basic data types and monads for Antisplice.
module Game.Antisplice.Monad.Dungeon

-- | Matches any <a>SomeDungeon</a> context
type DungeonM a = forall m. SomeDungeon m => m a

-- | Matches any <a>SomeChattyDungeon</a> context
type ChattyDungeonM a = forall m. SomeChattyDungeon m => m a

-- | The common type of all event handlers.
type Handler = ChattyDungeonM ()

-- | A boxed <a>Handler</a> to avoid ImpredicativeTypes
newtype HandlerBox
Handler :: Handler -> HandlerBox
runHandler :: HandlerBox -> Handler

-- | The common type of all prerequisites.
type Prerequisite = ChattyDungeonM Bool

-- | A boxed <a>Prerequisite</a> to avoid ImpredicativeTypes
newtype PrerequisiteBox
Prerequisite :: Prerequisite -> PrerequisiteBox
runPrerequisite :: PrerequisiteBox -> Prerequisite

-- | The common type for all predicates.
type Predicate = ChattyDungeonM (Maybe ReError)

-- | A boxed <a>Predicate</a> to avoid ImpredicativeTypes
newtype PredicateBox
Predicate :: ChattyDungeonM (Maybe ReError) -> PredicateBox
runPredicate :: PredicateBox -> ChattyDungeonM (Maybe ReError)

-- | Typeclass for all types that are convertible to or from <a>Text</a>
class IsText t
toText :: IsText t => t -> Text
fromText :: IsText t => Text -> t

-- | 10 directions to go
data Direction
North :: Direction
NorthEast :: Direction
East :: Direction
SouthEast :: Direction
South :: Direction
SouthWest :: Direction
West :: Direction
NorthWest :: Direction
Up :: Direction
Down :: Direction

-- | State type for RoomT
data RoomState
RoomState :: !Text -> AVL ObjectState -> Handler -> Handler -> Handler -> Handler -> Handler -> RoomState
roomTitleOf :: RoomState -> !Text
roomObjectsOf :: RoomState -> AVL ObjectState
roomTriggerOnFirstEnterOf :: RoomState -> Handler
roomTriggerOnEachEnterOf :: RoomState -> Handler
roomTriggerOnLeaveOf :: RoomState -> Handler
roomTriggerOnLookOf :: RoomState -> Handler
roomTriggerOnAnnounceOf :: RoomState -> Handler

-- | The room monad. Used to create or modify room data.
newtype RoomT m a
Room :: (RoomState -> m (a, RoomState)) -> RoomT m a
runRoomT :: RoomT m a -> RoomState -> m (a, RoomState)

-- | Typeclass for all room monads.
class Monad m => MonadRoom m
getRoomState :: MonadRoom m => m RoomState
putRoomState :: MonadRoom m => RoomState -> m ()

-- | State type for a path from one room to another
data PathState
PathState :: Prerequisite -> Handler -> Handler -> PathState
pathPrerequisiteOf :: PathState -> Prerequisite
pathTriggerBeforeWalkOf :: PathState -> Handler
pathTriggerAfterWalkOf :: PathState -> Handler

-- | Key for item or player statistics
data StatKey
Strength :: StatKey
Agility :: StatKey
Stamina :: StatKey
Intelligence :: StatKey
Spirit :: StatKey
Armor :: StatKey
Haste :: StatKey
CooldownDuration :: StatKey
AttackPower :: StatKey

-- | Key for equipment slot
data EquipKey
MainHand :: EquipKey
OffHand :: EquipKey
Chest :: EquipKey
Feet :: EquipKey
Wrists :: EquipKey
Waist :: EquipKey
Head :: EquipKey
Legs :: EquipKey
Back :: EquipKey
Hands :: EquipKey
Neck :: EquipKey
Finger1 :: EquipKey
Finger2 :: EquipKey

-- | Relation between the player and the object.
data Relation
Near :: Relation
Carried :: Relation
Worn :: Relation

-- | Object features.
data Feature

-- | May take damage.
Damagable :: Feature

-- | May be acquired.
Acquirable :: Feature

-- | May be used.
Usable :: Feature

-- | May be drunk.
Drinkable :: Feature

-- | May be eaten.
Eatable :: Feature

-- | May be equipped at the given slot.
Equipable :: EquipKey -> Feature

-- | May be redeemed for the given currency.
Redeemable :: Currency -> Int -> Feature

-- | Redeem automatically for a given currency.
AutoRedeem :: Currency -> Int -> Feature

-- | Has a known weight.
Weighty :: Int -> Feature

-- | Is connected to a real player.
Played :: PlayerId -> Feature

-- | May move around.
Mobile :: Feature

-- | Implies an additional stereotype for the near<i>carrying</i>wearing
--   player
Stereo :: Relation -> (Atom PlayerStereo) -> Feature

-- | Implies an additional particle for the room description
Described :: (Atom String) -> Feature

-- | Phantom ID type for objects.
data ObjectId
ObjectId :: Int -> ObjectId
FalseObject :: ObjectId

-- | Phantom ID type for object kinds.
data KindId
KindId :: Int -> KindId
FalseKind :: KindId

-- | State type for ObjectT
data ObjectState
ObjectState :: !ObjectId -> !KindId -> !Text -> !Text -> ![String] -> ![String] -> !Bool -> !Bool -> !Bool -> !Bool -> !Int -> !Int -> ![NodeId] -> AVL Feature -> !(Maybe (Atom Faction)) -> Handler -> Handler -> Handler -> Handler -> Handler -> Handler -> Handler -> Handler -> Handler -> Handler -> Handler -> Handler -> Handler -> Handler -> Handler -> Handler -> Handler -> Handler -> Handler -> Handler -> Handler -> Handler -> ObjectState
objectIdOf :: ObjectState -> !ObjectId
objectKindOf :: ObjectState -> !KindId
objectTitleOf :: ObjectState -> !Text
objectDescOf :: ObjectState -> !Text
objectNamesOf :: ObjectState -> ![String]
objectAttributesOf :: ObjectState -> ![String]
objectOnceSeenOf :: ObjectState -> !Bool
objectOnceAcquiredOf :: ObjectState -> !Bool
objectOnceInspectedOf :: ObjectState -> !Bool
objectOnceEquippedOf :: ObjectState -> !Bool
objectMaxHealthOf :: ObjectState -> !Int
objectCurHealthOf :: ObjectState -> !Int
objectRouteOf :: ObjectState -> ![NodeId]
objectFeaturesOf :: ObjectState -> AVL Feature
objectFactionOf :: ObjectState -> !(Maybe (Atom Faction))
objectTriggerOnFirstSightOf :: ObjectState -> Handler
objectTriggerOnEachSightOf :: ObjectState -> Handler
objectTriggerOnFirstAcquireOf :: ObjectState -> Handler
objectTriggerOnEachAcquireOf :: ObjectState -> Handler
objectTriggerOnFirstInspectionOf :: ObjectState -> Handler
objectTriggerOnEachInspectionOf :: ObjectState -> Handler
objectTriggerOnLookAtOf :: ObjectState -> Handler
objectTriggerOnLookIntoOf :: ObjectState -> Handler
objectTriggerOnReadOf :: ObjectState -> Handler
objectTriggerOnEnterOf :: ObjectState -> Handler
objectTriggerOnRoomEnterOf :: ObjectState -> Handler
objectTriggerOnRoomLeaveOf :: ObjectState -> Handler
objectTriggerOnAnnounceOf :: ObjectState -> Handler
objectTriggerOnDropOf :: ObjectState -> Handler
objectTriggerOnFirstEquipOf :: ObjectState -> Handler
objectTriggerOnEachEquipOf :: ObjectState -> Handler
objectTriggerOnUnequipOf :: ObjectState -> Handler
objectTriggerOnDieOf :: ObjectState -> Handler
objectTriggerOnTakeDamageOf :: ObjectState -> Handler
objectTriggerOnUseOf :: ObjectState -> Handler
objectTriggerOnEatOf :: ObjectState -> Handler
objectTriggerOnDrinkOf :: ObjectState -> Handler

-- | The object monad. Used to create or modify objects.
newtype ObjectT m a
Object :: (ObjectState -> m (a, ObjectState)) -> ObjectT m a
runObjectT :: ObjectT m a -> ObjectState -> m (a, ObjectState)

-- | Typeclass for all object monads
class Monad m => MonadObject m
getObjectState :: MonadObject m => m ObjectState
putObjectState :: MonadObject m => ObjectState -> m ()

-- | A faction
data Faction
Faction :: !Text -> Handler -> Handler -> Handler -> Faction
factionName :: Faction -> !Text
factionTriggerOnHostileOf :: Faction -> Handler
factionTriggerOnFriendlyOf :: Faction -> Handler
factionTriggerOnExaltedOf :: Faction -> Handler
data Attitude
Hostile :: Attitude
Friendly :: Attitude
Exalted :: Attitude

-- | Currency descriptor (description and expander name)
data Currency
Currency :: CurrencyId -> String -> String -> Currency
currencyIdOf :: Currency -> CurrencyId
currencyDescOf :: Currency -> String
currencyNameOf :: Currency -> String

-- | Phantom ID type for currencies
data CurrencyId
Health :: CurrencyId
CurrencyId :: Int -> CurrencyId

-- | Target for attacks. May be a player or an object.
data DamageTarget
TargetPlayer :: PlayerId -> DamageTarget
TargetObject :: ObjectId -> DamageTarget

-- | Phantom ID type for players
newtype PlayerId
PlayerId :: Int -> PlayerId

-- | State type for PlayerT
data PlayerState
PlayerState :: !PlayerId -> !NodeId -> !Int -> AVL ObjectState -> AVL (EquipKey, ObjectState) -> AVL (StatKey, Int) -> [Atom PlayerStereo] -> AVL (Atom Faction, Int) -> AVL (CurrencyId, Int) -> AVL CooldownId -> !ObjectId -> AVL (Atom Quest, QuestRel) -> Int -> Bool -> PlayerState
playerIdOf :: PlayerState -> !PlayerId
playerRoomOf :: PlayerState -> !NodeId
playerMaxHealthOf :: PlayerState -> !Int
playerInventoryOf :: PlayerState -> AVL ObjectState
playerEquipOf :: PlayerState -> AVL (EquipKey, ObjectState)
playerBaseStatsOf :: PlayerState -> AVL (StatKey, Int)
playerStereosOf :: PlayerState -> [Atom PlayerStereo]
playerReputationOf :: PlayerState -> AVL (Atom Faction, Int)
playerCurrenciesOf :: PlayerState -> AVL (CurrencyId, Int)
playerCooldownsOf :: PlayerState -> AVL CooldownId
playerOpponentOf :: PlayerState -> !ObjectId
playerActiveQuestsOf :: PlayerState -> AVL (Atom Quest, QuestRel)
playerAlcoholOf :: PlayerState -> Int
playerSoberingActiveOf :: PlayerState -> Bool

-- | The player monad. Used to create or modify players.
newtype PlayerT m a
Player :: (PlayerState -> m (a, PlayerState)) -> PlayerT m a
runPlayerT :: PlayerT m a -> PlayerState -> m (a, PlayerState)

-- | Typeclass for all player monads.
class Monad m => MonadPlayer m where modifyPlayerState f = do { s <- getPlayerState; putPlayerState $ f s }
getPlayerState :: MonadPlayer m => m PlayerState
putPlayerState :: MonadPlayer m => PlayerState -> m ()
modifyPlayerState :: MonadPlayer m => (PlayerState -> PlayerState) -> m ()

-- | A player stereotype
data PlayerStereo
PlayerStereo :: ((StatKey -> Int) -> StatKey -> Int) -> (String -> Maybe Invokable) -> (String -> Maybe (RecipeMethod -> Invokable)) -> PlayerStereo
stereoCalcStatBonus :: PlayerStereo -> (StatKey -> Int) -> StatKey -> Int
stereoSkillBonus :: PlayerStereo -> String -> Maybe Invokable
stereoRecipeBonus :: PlayerStereo -> String -> Maybe (RecipeMethod -> Invokable)

-- | Phantom ID type for cooldowns
data CooldownId
GlobalCooldown :: CooldownId
CooldownId :: Int -> CooldownId

-- | Response of an object getter
data GetterResponse
Found :: ObjectState -> GetterResponse
TooMany :: GetterResponse
NoneFound :: GetterResponse

-- | Some handler that may be invoked by the user
type Invokable = [String] -> HandlerBox

-- | Some prerequisite that may be invoked by the user
type InvokableP = [String] -> PredicateBox

-- | Method of using recipes
data RecipeMethod
RecipeMethod :: Int -> RecipeMethod

-- | State type for DungeonT
data DungeonState
DungeonState :: Graph RoomState Direction PathState -> Focus PlayerState -> AVL (NominalDiffTime, HandlerBox) -> AVL Currency -> DungeonState
roomsOf :: DungeonState -> Graph RoomState Direction PathState
playersOf :: DungeonState -> Focus PlayerState
timeTriggersOf :: DungeonState -> AVL (NominalDiffTime, HandlerBox)
currenciesOf :: DungeonState -> AVL Currency

-- | For compatibility. Earlier versions of DungeonT had a field for that.
currentRoomOf :: DungeonState -> Maybe NodeId

-- | For compatibility. Earlier versions of DungeonT had a field for that.
playerOf :: DungeonState -> Maybe PlayerState

-- | The dungeon monad. Everything runs inside this.
newtype DungeonT m a
Dungeon :: (DungeonState -> m (a, DungeonState)) -> DungeonT m a
runDungeonT :: DungeonT m a -> DungeonState -> m (a, DungeonState)

-- | Typeclass for all dungeon monads.
class (MonadRoom m, MonadPlayer m) => MonadDungeon m where lowerDungeon m = do { s <- getDungeonState; (a, s') <- runDungeonT m s; putDungeonState s'; return a }
getDungeonState :: MonadDungeon m => m DungeonState
putDungeonState :: MonadDungeon m => DungeonState -> m ()
lowerDungeon :: MonadDungeon m => DungeonT m a -> m a
instance Typeable PlayerStereo
instance Typeable ObjectState
instance Ord StatKey
instance Eq StatKey
instance Ord EquipKey
instance Eq EquipKey
instance Eq Attitude
instance Ord Attitude
instance Ord Relation
instance Eq Relation
instance Eq ObjectId
instance Ord ObjectId
instance Eq KindId
instance Ord KindId
instance Eq PlayerId
instance Ord PlayerId
instance Eq CooldownId
instance Ord CooldownId
instance Ord CurrencyId
instance Eq CurrencyId
instance Ord Currency
instance Eq Currency
instance Eq RecipeMethod
instance Ord RecipeMethod
instance Ord QuestRel
instance Eq QuestRel
instance Eq Direction
instance Show Direction
instance Ord Feature
instance Eq Feature
instance Monad m => MonadDungeon (DungeonT m)
instance Monad m => MonadPlayer (DungeonT m)
instance Monad m => MonadRoom (DungeonT m)
instance MonadTrans DungeonT
instance (Functor m, Monad m) => Applicative (DungeonT m)
instance Monad m => Monad (DungeonT m)
instance Functor m => Functor (DungeonT m)
instance None DungeonState
instance Tuplify Direction Direction
instance None PathState
instance Monad m => MonadPlayer (PlayerT m)
instance MonadTrans PlayerT
instance (Functor m, Monad m) => Applicative (PlayerT m)
instance Monad m => Monad (PlayerT m)
instance Functor m => Functor (PlayerT m)
instance Indexable Currency CurrencyId Currency
instance Indexable CooldownId CooldownId CooldownId
instance Indexable PlayerState PlayerId PlayerState
instance None GetterResponse
instance Tuplify PlayerId PlayerId
instance Monad m => MonadObject (ObjectT m)
instance MonadTrans ObjectT
instance (Functor m, Monad m) => Applicative (ObjectT m)
instance Monad m => Monad (ObjectT m)
instance Functor m => Functor (ObjectT m)
instance Indexable ObjectState ObjectId ObjectState
instance Tuplify ObjectState ObjectState
instance None KindId
instance None ObjectId
instance Tuplify KindId KindId
instance Tuplify ObjectId ObjectId
instance Indexable Feature Feature Feature
instance Tuplify Feature Feature
instance Tuplify Relation Relation
instance Tuplify Attitude Attitude
instance Tuplify Faction Faction
instance IsText String
instance IsText Text
instance Monad m => MonadRoom (RoomT m)
instance MonadTrans RoomT
instance (Functor m, Monad m) => Applicative (RoomT m)
instance Monad m => Monad (RoomT m)
instance Functor m => Functor (RoomT m)
instance Tuplify RoomState RoomState
instance Indexable EquipKey EquipKey EquipKey
instance Tuplify EquipKey EquipKey
instance Tuplify StatKey StatKey
instance None PredicateBox
instance None PrerequisiteBox
instance None HandlerBox


-- | Provides (chatty-compatible) templates for automatical instance
--   derivation.
module Game.Antisplice.Templates
type PlayerFilterT = FilterT PlayerId

-- | Automatically derive an instance for <a>MonadRoom</a>
mkRoom :: Name -> DecsQ

-- | Automatically derive an instance for 'MonadError e'
mkFail :: Name -> Name -> DecsQ

-- | Automatically derive an instance for <a>MonadDungeon</a>
mkDungeon :: Name -> DecsQ

-- | Automatically derive an instance for <a>MonadObject</a>
mkObject :: Name -> DecsQ

-- | Automatically derive an instance for <a>MonadPlayer</a>
mkPlayer :: Name -> DecsQ

-- | Automatically derive an instance for <a>MonadIO</a>
mkIO :: Name -> DecsQ

-- | Automatically derive an instance for <a>MonadVocab</a>
mkVocab :: Name -> DecsQ


-- | Provides a powerful language for user input evaluation
module Game.Antisplice.Call

-- | Use a mask on a list of tokens and tuplify the result. Dispatch errors
--   to the underlying monad.
processMask :: (Append m (Cons EnsureLineEnd Nil) s, CallMask s r, Append r Nil r, Tuplify r t) => m -> [String] -> DungeonM t

-- | Try to use a mask on a list of tokens.
tryMask :: (Append m (Cons EnsureLineEnd Nil) s, Append r Nil r, CallMask s r) => m -> [String] -> DungeonM (Either ReError r)

-- | Typeclass for input masks (either single modules or lists of modules)
class CallMask cm l | cm -> l
usemask :: (CallMask cm l, MonadRoom m, MonadPlayer m) => cm -> StateT [(String, Token)] m (Either ReError l)
verbosemask :: CallMask cm l => cm -> String

-- | Typeclass for evaluation result predicate masks
class PredMask rm im
usepmask :: PredMask rm im => rm -> im -> ChattyDungeonM (Maybe ReError)

-- | Typeclass for evaluation result post-processing masks
class PostMask pm im rm | pm im -> rm
usepost :: PostMask pm im rm => pm -> im -> ChattyDungeonM rm

-- | Typeclass for evaluation result combi masks
class CombiMask cm rm pm pom | cm rm -> pm pom
ctopred :: CombiMask cm rm pm pom => cm -> rm -> pm
ctopost :: CombiMask cm rm pm pom => cm -> rm -> pom

-- | Ensures that the end of the input is reached
data EnsureLineEnd
EnsureLineEnd :: EnsureLineEnd

-- | Catches the string of a token matching the given token type
data CatchByType
CatchVerb :: CatchByType
CatchPrep :: CatchByType
CatchNoun :: CatchByType
CatchAdj :: CatchByType
CatchOrdn :: Int -> CatchByType
CatchFixe :: CatchByType
CatchSkilln :: CatchByType
CatchUnint :: CatchByType
CatchAny :: CatchByType

-- | Catches an entire token
data CatchToken
CatchToken :: CatchToken
CatchNounc :: CatchToken

-- | Catches the number of an Ordn token
data CatchOrd
CatchOrd :: CatchOrd

-- | Catches the remaining part of the line
data Remaining
Remaining :: Remaining

-- | Catches an available, carried or seen object
data CatchObj
AvailableObject :: CatchObj
SeenObject :: CatchObj
CarriedObject :: CatchObj

-- | Provide multiple alternatives and catch the first matching one as well
--   as its result
data Which a
Which :: [a] -> Which a

-- | Provide an optional mask part
data Optional a
Optional :: a -> Optional a

-- | Ignore a token or result
data Ignore
Ignore :: Ignore

-- | Pass-through a result
data Pass
Pass :: Pass
instance CombiMask Pass a Ignore Pass
instance CombiMask (a -> Either ReError b) a (a -> Maybe ReError) (a -> b)
instance CombiMask (a -> Maybe b, String) a (a -> Bool, String) (a -> b)
instance CombiMask Ignore a Ignore Ignore
instance (CombiMask m i p po, CombiMask ms is ps pos) => CombiMask (Cons m ms) (Cons i is) (Cons p ps) (Cons po pos)
instance CombiMask Nil Nil Nil Nil
instance PostMask Pass a (Cons a Nil)
instance PostMask (a -> b) (Titled a) (Cons b Nil)
instance PostMask (a -> b) a (Cons b Nil)
instance PostMask Ignore a Nil
instance (PostMask m i r, PostMask ms is rs, Append r rs rx) => PostMask (Cons m ms) (Cons i is) rx
instance PostMask Nil Nil Nil
instance PredMask Feature (Titled ObjectState)
instance PredMask Ignore a
instance PredMask String String
instance PredMask (x -> PrerequisiteBox, String) x
instance PredMask (x -> Maybe ReError) x
instance PredMask (x -> Bool, String) x
instance (PredMask r i, PredMask rs is) => PredMask (Cons r rs) (Cons i is)
instance PredMask Nil Nil
instance (CallMask x r, CallMask xs rs, Append r rs rx) => CallMask (Cons x xs) rx
instance CallMask Nil Nil
instance CallMask Remaining (Cons [String] Nil)
instance CallMask CatchObj (Cons (Titled ObjectState) Nil)
instance CallMask CatchToken (Cons Token Nil)
instance CallMask CatchOrd (Cons Int Nil)
instance CallMask CatchByType (Cons String Nil)
instance CallMask EnsureLineEnd Nil
instance CallMask String Nil
instance CallMask Ignore Nil
instance CallMask Token Nil
instance (CallMask a r, Append (Cons a Nil) r ar) => CallMask (Which a) ar
instance (CallMask a ar, IntoMaybe ar am, Append am Nil am) => CallMask (Optional a) am


-- | Provides operators for composing masked consumers
module Game.Antisplice.MaskedSkills

-- | A special consumer whose conditions and actions rely on evaluation
--   result masks
data MaskedConsumer r
MasCon :: [PredMaskCond r] -> [PostMaskHandler r] -> MaskedConsumer r

-- | A special handler that relies on an evaluation result post-processing
--   mask
data PostMaskHandler r
PMHandler :: po -> (pt -> Handler) -> PostMaskHandler r

-- | A special condition that relies on an evaluation result predicate mask
data PredMaskCond r
PMCond :: p -> PredMaskCond r

-- | Composes a masked consumer from an evaluation result post-processing
--   mask and a handler that relies on its result
(&->) :: (PostMask po r pr, Tuplify pr pt) => po -> (pt -> Handler) -> MaskedConsumer r

-- | Composes a masked consumer from an evaluation result combi mask and a
--   handler that relies on its possible result. Takes a third parameter
--   for the correct type. In most cases you'll want <a>&amp;?-&gt;</a>
--   instead.
(-&?->) :: (CombiMask cm r pm pom, PredMask pm r, PostMask pom r por, Tuplify por pot) => cm -> (pot -> Handler) -> r -> MaskedConsumer r

-- | Composes a masked consumer from an evaluation result combi mask and a
--   handler that relies on its possible result.
(&?->) :: (CombiMask cm r pm pom, PredMask pm r, PostMask pom r por, Tuplify por pot) => cm -> (pot -> Handler) -> MaskedConsumer r

-- | Adds an evaluation result predicate mask to a masked consumer.
(+?) :: PredMask p r => MaskedConsumer r -> p -> MaskedConsumer r

-- | Concatenates two masked consumers.
(+&) :: MaskedConsumer r -> MaskedConsumer r -> MaskedConsumer r
instance None (MaskedConsumer r)
instance Monoid (MaskedConsumer r)


-- | Provides some class instances. Nothing really interesting here.
module Game.Antisplice.Monad
instance ChChannelPrinter PlayerId m => ChBroadcaster PlayerId (DungeonT m)
instance MonadError SplErr m0 => MonadError SplErr (RecorderT m0)
instance MonadRoom m0 => MonadRoom (RecorderT m0)
instance MonadPlayer m0 => MonadPlayer (RecorderT m0)
instance (MonadDungeon m0, ChChannelPrinter PlayerId m0) => ChBroadcaster PlayerId (RecorderT m0)
instance MonadDungeon m0 => MonadDungeon (RecorderT m0)
instance ChChannelPrinter PlayerId m0 => ChChannelPrinter PlayerId (RecorderT m0)
instance MonadError SplErr m0 => MonadError SplErr (NullExpanderT m0)
instance MonadRoom m0 => MonadRoom (NullExpanderT m0)
instance MonadPlayer m0 => MonadPlayer (NullExpanderT m0)
instance (MonadDungeon m0, ChChannelPrinter PlayerId m0) => ChBroadcaster PlayerId (NullExpanderT m0)
instance MonadDungeon m0 => MonadDungeon (NullExpanderT m0)
instance ChChannelPrinter PlayerId m0 => ChChannelPrinter PlayerId (NullExpanderT m0)
instance MonadError SplErr m0 => MonadError SplErr (ExpanderT m0)
instance MonadRoom m0 => MonadRoom (ExpanderT m0)
instance MonadPlayer m0 => MonadPlayer (ExpanderT m0)
instance (MonadDungeon m0, ChChannelPrinter PlayerId m0) => ChBroadcaster PlayerId (ExpanderT m0)
instance MonadDungeon m0 => MonadDungeon (ExpanderT m0)
instance ChChannelPrinter PlayerId m0 => ChChannelPrinter PlayerId (ExpanderT m0)
instance MonadError SplErr m0 => MonadError SplErr (HtmlPrinterT m0)
instance MonadRoom m0 => MonadRoom (HtmlPrinterT m0)
instance MonadPlayer m0 => MonadPlayer (HtmlPrinterT m0)
instance (MonadDungeon m0, ChChannelPrinter PlayerId m0) => ChBroadcaster PlayerId (HtmlPrinterT m0)
instance MonadDungeon m0 => MonadDungeon (HtmlPrinterT m0)
instance ChChannelPrinter PlayerId m0 => ChChannelPrinter PlayerId (HtmlPrinterT m0)
instance MonadError SplErr m0 => MonadError SplErr (AnsiPrinterT m0)
instance MonadRoom m0 => MonadRoom (AnsiPrinterT m0)
instance MonadPlayer m0 => MonadPlayer (AnsiPrinterT m0)
instance (MonadDungeon m0, ChChannelPrinter PlayerId m0) => ChBroadcaster PlayerId (AnsiPrinterT m0)
instance MonadDungeon m0 => MonadDungeon (AnsiPrinterT m0)
instance ChChannelPrinter PlayerId m0 => ChChannelPrinter PlayerId (AnsiPrinterT m0)
instance MonadVocab m0 => MonadVocab (PlayerFilterT m0)
instance CanMount m0 n0 => CanMount (PlayerFilterT m0) n0
instance CanSave m0 n0 => CanSave (PlayerFilterT m0) n0
instance CanLoad m0 n0 => CanLoad (PlayerFilterT m0) n0
instance (ChAtoms (PlayerFilterT m0), ChFilesystem m0) => ChFilesystem (PlayerFilterT m0)
instance ChAtoms m0 => ChAtoms (PlayerFilterT m0)
instance ChCounter m0 => ChCounter (PlayerFilterT m0)
instance ChClock m0 => ChClock (PlayerFilterT m0)
instance ChRandom m0 => ChRandom (PlayerFilterT m0)
instance ChSpawn m0 => ChSpawn (PlayerFilterT m0)
instance ChFinalizer m0 => ChFinalizer (PlayerFilterT m0)
instance ChHistoryEnv m0 => ChHistoryEnv (PlayerFilterT m0)
instance ChExpanderEnv m0 => ChExpanderEnv (PlayerFilterT m0)
instance ChExpand m0 => ChExpand (PlayerFilterT m0)
instance ChScanner m0 => ChScanner (PlayerFilterT m0)
instance ChChannelPrinter PlayerId m0 => ChChannelPrinter PlayerId (AtomStoreT m0)
instance MonadPlayer m0 => MonadPlayer (AtomStoreT m0)
instance MonadVocab m0 => MonadVocab (AtomStoreT m0)
instance MonadRoom m0 => MonadRoom (AtomStoreT m0)
instance (MonadDungeon m0, ChChannelPrinter PlayerId m0) => ChBroadcaster PlayerId (AtomStoreT m0)
instance MonadDungeon m0 => MonadDungeon (AtomStoreT m0)
instance MonadError SplErr m0 => MonadError SplErr (AtomStoreT m0)
instance ChChannelPrinter PlayerId m0 => ChChannelPrinter PlayerId (VocabT m0)
instance MonadPlayer m0 => MonadPlayer (VocabT m0)
instance MonadRoom m0 => MonadRoom (VocabT m0)
instance (MonadDungeon m0, ChChannelPrinter PlayerId m0) => ChBroadcaster PlayerId (VocabT m0)
instance MonadDungeon m0 => MonadDungeon (VocabT m0)
instance MonadError SplErr m0 => MonadError SplErr (VocabT m0)
instance CanMount m0 n0 => CanMount (VocabT m0) n0
instance CanSave m0 n0 => CanSave (VocabT m0) n0
instance CanLoad m0 n0 => CanLoad (VocabT m0) n0
instance (ChAtoms (VocabT m0), ChFilesystem m0) => ChFilesystem (VocabT m0)
instance ChAtoms m0 => ChAtoms (VocabT m0)
instance ChCounter m0 => ChCounter (VocabT m0)
instance ChBufferedScanner m0 => ChBufferedScanner (VocabT m0)
instance ChExtendedPrinter m0 => ChExtendedPrinter (VocabT m0)
instance ChChannelPrinter Handle m0 => ChChannelPrinter Handle (VocabT m0)
instance ChChannelPrinter Bool m0 => ChChannelPrinter Bool (VocabT m0)
instance ChChannelPrinter Int m0 => ChChannelPrinter Int (VocabT m0)
instance ChHistoryEnv m0 => ChHistoryEnv (VocabT m0)
instance ChExpanderEnv m0 => ChExpanderEnv (VocabT m0)
instance ChClock m0 => ChClock (VocabT m0)
instance ChRandom m0 => ChRandom (VocabT m0)
instance ChSpawn m0 => ChSpawn (VocabT m0)
instance ChExpand m0 => ChExpand (VocabT m0)
instance ChFinalizer m0 => ChFinalizer (VocabT m0)
instance ChScanner m0 => ChScanner (VocabT m0)
instance ChPrinter m0 => ChPrinter (VocabT m0)
instance ChChannelPrinter PlayerId m0 => ChChannelPrinter PlayerId (PlayerT m0)
instance MonadVocab m0 => MonadVocab (PlayerT m0)
instance MonadIO m0 => MonadIO (PlayerT m0)
instance MonadError SplErr m0 => MonadError SplErr (PlayerT m0)
instance CanMount m0 n0 => CanMount (PlayerT m0) n0
instance CanSave m0 n0 => CanSave (PlayerT m0) n0
instance CanLoad m0 n0 => CanLoad (PlayerT m0) n0
instance (ChAtoms (PlayerT m0), ChFilesystem m0) => ChFilesystem (PlayerT m0)
instance ChAtoms m0 => ChAtoms (PlayerT m0)
instance ChCounter m0 => ChCounter (PlayerT m0)
instance ChBufferedScanner m0 => ChBufferedScanner (PlayerT m0)
instance ChExtendedPrinter m0 => ChExtendedPrinter (PlayerT m0)
instance ChChannelPrinter Handle m0 => ChChannelPrinter Handle (PlayerT m0)
instance ChChannelPrinter Bool m0 => ChChannelPrinter Bool (PlayerT m0)
instance ChChannelPrinter Int m0 => ChChannelPrinter Int (PlayerT m0)
instance ChHistoryEnv m0 => ChHistoryEnv (PlayerT m0)
instance ChExpanderEnv m0 => ChExpanderEnv (PlayerT m0)
instance ChClock m0 => ChClock (PlayerT m0)
instance ChRandom m0 => ChRandom (PlayerT m0)
instance ChSpawn m0 => ChSpawn (PlayerT m0)
instance ChExpand m0 => ChExpand (PlayerT m0)
instance ChFinalizer m0 => ChFinalizer (PlayerT m0)
instance ChScanner m0 => ChScanner (PlayerT m0)
instance ChPrinter m0 => ChPrinter (PlayerT m0)
instance ChChannelPrinter PlayerId m0 => ChChannelPrinter PlayerId (CounterT m0)
instance MonadVocab m0 => MonadVocab (CounterT m0)
instance MonadIO m0 => MonadIO (CounterT m0)
instance MonadPlayer m0 => MonadPlayer (CounterT m0)
instance (MonadDungeon m0, ChChannelPrinter PlayerId m0) => ChBroadcaster PlayerId (CounterT m0)
instance MonadDungeon m0 => MonadDungeon (CounterT m0)
instance MonadObject m0 => MonadObject (CounterT m0)
instance MonadRoom m0 => MonadRoom (CounterT m0)
instance MonadError SplErr m0 => MonadError SplErr (CounterT m0)
instance ChChannelPrinter PlayerId m0 => ChChannelPrinter PlayerId (ObjectT m0)
instance MonadVocab m0 => MonadVocab (ObjectT m0)
instance MonadIO m0 => MonadIO (ObjectT m0)
instance MonadError SplErr m0 => MonadError SplErr (ObjectT m0)
instance CanMount m0 n0 => CanMount (ObjectT m0) n0
instance CanSave m0 n0 => CanSave (ObjectT m0) n0
instance CanLoad m0 n0 => CanLoad (ObjectT m0) n0
instance (ChAtoms (ObjectT m0), ChFilesystem m0) => ChFilesystem (ObjectT m0)
instance ChAtoms m0 => ChAtoms (ObjectT m0)
instance ChCounter m0 => ChCounter (ObjectT m0)
instance ChBufferedScanner m0 => ChBufferedScanner (ObjectT m0)
instance ChExtendedPrinter m0 => ChExtendedPrinter (ObjectT m0)
instance ChChannelPrinter Handle m0 => ChChannelPrinter Handle (ObjectT m0)
instance ChChannelPrinter Bool m0 => ChChannelPrinter Bool (ObjectT m0)
instance ChChannelPrinter Int m0 => ChChannelPrinter Int (ObjectT m0)
instance ChHistoryEnv m0 => ChHistoryEnv (ObjectT m0)
instance ChExpanderEnv m0 => ChExpanderEnv (ObjectT m0)
instance ChClock m0 => ChClock (ObjectT m0)
instance ChRandom m0 => ChRandom (ObjectT m0)
instance ChSpawn m0 => ChSpawn (ObjectT m0)
instance ChExpand m0 => ChExpand (ObjectT m0)
instance ChFinalizer m0 => ChFinalizer (ObjectT m0)
instance ChScanner m0 => ChScanner (ObjectT m0)
instance ChPrinter m0 => ChPrinter (ObjectT m0)
instance ChChannelPrinter PlayerId m0 => ChChannelPrinter PlayerId (RoomT m0)
instance MonadVocab m0 => MonadVocab (RoomT m0)
instance MonadIO m0 => MonadIO (RoomT m0)
instance MonadError SplErr m0 => MonadError SplErr (RoomT m0)
instance CanMount m0 n0 => CanMount (RoomT m0) n0
instance CanSave m0 n0 => CanSave (RoomT m0) n0
instance CanLoad m0 n0 => CanLoad (RoomT m0) n0
instance (ChAtoms (RoomT m0), ChFilesystem m0) => ChFilesystem (RoomT m0)
instance ChAtoms m0 => ChAtoms (RoomT m0)
instance ChCounter m0 => ChCounter (RoomT m0)
instance ChBufferedScanner m0 => ChBufferedScanner (RoomT m0)
instance ChExtendedPrinter m0 => ChExtendedPrinter (RoomT m0)
instance ChChannelPrinter Handle m0 => ChChannelPrinter Handle (RoomT m0)
instance ChChannelPrinter Bool m0 => ChChannelPrinter Bool (RoomT m0)
instance ChChannelPrinter Int m0 => ChChannelPrinter Int (RoomT m0)
instance ChHistoryEnv m0 => ChHistoryEnv (RoomT m0)
instance ChExpanderEnv m0 => ChExpanderEnv (RoomT m0)
instance ChClock m0 => ChClock (RoomT m0)
instance ChRandom m0 => ChRandom (RoomT m0)
instance ChSpawn m0 => ChSpawn (RoomT m0)
instance ChExpand m0 => ChExpand (RoomT m0)
instance ChFinalizer m0 => ChFinalizer (RoomT m0)
instance ChScanner m0 => ChScanner (RoomT m0)
instance ChPrinter m0 => ChPrinter (RoomT m0)
instance ChChannelPrinter PlayerId m0 => ChChannelPrinter PlayerId (DungeonT m0)
instance MonadVocab m0 => MonadVocab (DungeonT m0)
instance MonadIO m0 => MonadIO (DungeonT m0)
instance ChAtoms m0 => ChAtoms (DungeonT m0)
instance ChCounter m0 => ChCounter (DungeonT m0)
instance MonadError SplErr m0 => MonadError SplErr (DungeonT m0)
instance ChRandom m0 => ChRandom (DungeonT m0)
instance ChHistoryEnv m0 => ChHistoryEnv (DungeonT m0)
instance ChExpanderEnv m0 => ChExpanderEnv (DungeonT m0)
instance ChClock m0 => ChClock (DungeonT m0)
instance ChFinalizer m0 => ChFinalizer (DungeonT m0)
instance ChScanner m0 => ChScanner (DungeonT m0)
instance ChExtendedPrinter m0 => ChExtendedPrinter (DungeonT m0)
instance ChChannelPrinter Handle m0 => ChChannelPrinter Handle (DungeonT m0)
instance ChChannelPrinter Bool m0 => ChChannelPrinter Bool (DungeonT m0)
instance ChChannelPrinter Int m0 => ChChannelPrinter Int (DungeonT m0)
instance ChPrinter m0 => ChPrinter (DungeonT m0)
instance ChChannelPrinter PlayerId m0 => ChChannelPrinter PlayerId (SplErrT m0)
instance MonadVocab m0 => MonadVocab (SplErrT m0)
instance MonadIO m0 => MonadIO (SplErrT m0)
instance MonadPlayer m0 => MonadPlayer (SplErrT m0)
instance MonadObject m0 => MonadObject (SplErrT m0)
instance (MonadDungeon m0, ChChannelPrinter PlayerId m0) => ChBroadcaster PlayerId (SplErrT m0)
instance MonadDungeon m0 => MonadDungeon (SplErrT m0)
instance MonadRoom m0 => MonadRoom (SplErrT m0)
instance CanMount m0 n0 => CanMount (SplErrT m0) n0
instance CanSave m0 n0 => CanSave (SplErrT m0) n0
instance CanLoad m0 n0 => CanLoad (SplErrT m0) n0
instance (ChAtoms (SplErrT m0), ChFilesystem m0) => ChFilesystem (SplErrT m0)
instance ChAtoms m0 => ChAtoms (SplErrT m0)
instance ChCounter m0 => ChCounter (SplErrT m0)
instance ChBufferedScanner m0 => ChBufferedScanner (SplErrT m0)
instance ChExtendedPrinter m0 => ChExtendedPrinter (SplErrT m0)
instance ChChannelPrinter Handle m0 => ChChannelPrinter Handle (SplErrT m0)
instance ChChannelPrinter Bool m0 => ChChannelPrinter Bool (SplErrT m0)
instance ChChannelPrinter Int m0 => ChChannelPrinter Int (SplErrT m0)
instance ChHistoryEnv m0 => ChHistoryEnv (SplErrT m0)
instance ChExpanderEnv m0 => ChExpanderEnv (SplErrT m0)
instance ChClock m0 => ChClock (SplErrT m0)
instance ChRandom m0 => ChRandom (SplErrT m0)
instance ChSpawn m0 => ChSpawn (SplErrT m0)
instance ChExpand m0 => ChExpand (SplErrT m0)
instance ChFinalizer m0 => ChFinalizer (SplErrT m0)
instance ChScanner m0 => ChScanner (SplErrT m0)
instance ChPrinter m0 => ChPrinter (SplErrT m0)


-- | A huge pile of utility functions for building our dungeon.
module Game.Antisplice.Rooms

-- | Modify the room state.
modifyRoomState :: MonadRoom m => (RoomState -> RoomState) -> m ()

-- | Get the current room's description
getRoomDesc :: (MonadRoom m, ChAtoms m) => m String

-- | Get the current room's title
getRoomTitle :: (MonadRoom m, IsText t) => m t

-- | Set the current room's description setRoomDesc :: (MonadRoom m,IsText
--   t) =&gt; t -&gt; m () setRoomDesc t = modifyRoomState $ s -&gt;
--   s{roomDescOf=toText t}
--   
--   Set the current room's title
setRoomTitle :: (MonadRoom m, IsText t) => t -> m ()

-- | Mark the current room as visited
markRoom :: MonadDungeon m => m ()

-- | Enter the given room and trigger most events, but don't announce it.
--   Result tells whether this room is visited the first time.
enterRoom :: NodeId -> ChattyDungeonM Bool

-- | Reenter the current room and trigger all events (but don't announce
--   it).
reenterCurrentRoom :: ChattyDungeonM ()

-- | Enter the given room, trigger all events and announce it. On the first
--   visit, look around.
enterAndAnnounce :: NodeId -> ChattyDungeonM ()

-- | Enter a neighbouring room by its direction.
changeRoom :: Direction -> ChattyDungeonM ()

-- | Construct a new room using the room monad.
constructRoom :: MonadDungeon m => RoomT m a -> m NodeId

-- | Establish a path from one room to another one (one-way only).
establishWay :: MonadDungeon m => NodeId -> NodeId -> Direction -> PathState -> m ()

-- | Add a new object to the current room. It is contructed using the
--   object monad.
addRoomObject :: (ChCounter m, MonadRoom m) => ObjectT m a -> m ObjectId

-- | Remove an object from the current room and return its state.
removeRoomObject :: MonadRoom m => ObjectId -> m ObjectState

-- | Insert an already constructed object to the current room.
insertRoomObject :: MonadRoom m => ObjectState -> m ()

-- | Construct a room object (but don't add it)
constructObject :: Monad m => ObjectT m a -> Maybe ObjectId -> KindId -> m ObjectState

-- | Modify the object state
modifyObjectState :: MonadObject m => (ObjectState -> ObjectState) -> m ()

-- | Set the object's description
setObjectDesc :: (MonadObject m, IsText t) => t -> m ()

-- | Set the object's title
setObjectTitle :: (MonadObject m, IsText t) => t -> m ()

-- | Add a name for the current object
addObjectName :: MonadObject m => String -> m ()

-- | Add an attribute for the current object
addObjectAttr :: MonadObject m => String -> m ()

-- | Set whether the current object is a mob.
setObjectIsMob :: MonadObject m => Bool -> m ()

-- | Set whether the current object is acquirable.
setObjectIsAcquirable :: MonadObject m => Bool -> m ()

-- | Add an object feature to the current object
addFeature :: MonadObject m => Feature -> m ()

-- | Add a room description segment to the current object
addDescSeg :: (MonadObject m, ChAtoms m) => String -> m ()

-- | Add equippable slot
addEquipSlot :: MonadObject m => EquipKey -> m ()

-- | Register an object form and return its atom
registerForm :: ChAtoms m => ObjectT m () -> m (Atom ObjectState)

-- | Instanciate a registered form
instanciateForm :: (ChAtoms m, MonadRoom m) => Atom ObjectState -> m ObjectId

-- | Register an object kind.
registerKind :: ChCounter m => m KindId

-- | Set object kind.
setObjectKind :: MonadObject m => KindId -> m ()

-- | Get the object's title
getObjectTitle :: (MonadObject m, IsText t) => m t

-- | Get the object's description
getObjectDesc :: (MonadObject m, IsText t) => m t

-- | Get the object's names
getObjectNames :: MonadObject m => m [String]

-- | Check if the given name matches our current object
matchObjectName :: MonadObject m => String -> m Bool

-- | Check if the current object is a mob.
getObjectIsMob :: (MonadObject m, Functor m) => m Bool

-- | Check if the current object is acquirable.
getObjectIsAcquirable :: (MonadObject m, Functor m) => m Bool

-- | Determine which rooms contain the given object (won't be more than
--   one, but we're careful)
roomOfObject :: MonadDungeon m => ObjectId -> m [NodeId]

-- | Set the current mob's route
setMobRoute :: MonadObject m => [NodeId] -> m ()

-- | The given object may continue its route
continueMobRoute :: ObjectId -> Handler

-- | Schedule an event for a given time offset (in milliseconds).
schedule :: (MonadDungeon m, ChClock m) => Integer -> Handler -> m ()

-- | Create a new player using the player monad
subscribePlayer :: (MonadDungeon m, ChCounter m) => PlayerT m a -> m ()

-- | Move the current player to the given room, but don't trigger anything.
setPlayerRoom :: MonadPlayer m => NodeId -> m ()

-- | Acquire the given object and put it in the player's inventory
acquireObject :: ObjectId -> ChattyDungeonM ()

-- | Drop the given object and remove it from the player's inventory
dropObject :: ObjectId -> ChattyDungeonM ()

-- | Equip the given object somewhere
equipObject :: (MonadPlayer m, MonadError SplErr m) => ObjectState -> m (Maybe ObjectState)

-- | Equip the given object at a given key
equipObjectAt :: (MonadPlayer m, MonadError SplErr m) => EquipKey -> ObjectState -> m (Maybe ObjectState)

-- | Get equipped object
getEquipment :: MonadPlayer m => EquipKey -> m (Maybe ObjectState)

-- | Get cooldown state
getCooldown :: MonadPlayer m => CooldownId -> m Bool

-- | Set/unset cooldown
setCooldown :: MonadPlayer m => CooldownId -> Bool -> m ()

-- | Consume alcohol.
consumeAlcohol :: (ChPrinter m, ChRandom m, MonadPlayer m, MonadDungeon m, ChClock m) => Int -> m ()

-- | Register a currency
registerCurrency :: (ChCounter m, MonadDungeon m) => String -> String -> m CurrencyId

-- | Get currency state
getCurrency :: MonadPlayer m => CurrencyId -> m Int

-- | Modify currency state
modifyCurrency :: MonadPlayer m => CurrencyId -> (Int -> Int) -> m ()

-- | Damage a target (no matter whether player or mob) without setting
--   focus
damage :: DamageTarget -> Int -> ChattyDungeonM ()

-- | Focus an opponent
focusOpponent :: ObjectId -> ChattyDungeonM ()

-- | Deal damage to an opponent. Real damage is influenced by random.
dealDamage :: Int -> ChattyDungeonM ()

-- | Run a function in the context of the given room.
withRoom :: MonadDungeon m => NodeId -> RoomT m a -> m a

-- | Run a function in the context of a given player
withPlayer :: MonadDungeon m => PlayerId -> PlayerT (RoomT m) a -> m a

-- | Run a function in the context of a given object
withObject :: MonadDungeon m => ObjectId -> ObjectT (RoomT m) a -> m a

-- | Only run the given function if the player is inside the also given
--   room.
guardRoom :: MonadDungeon m => NodeId -> m () -> m ()

-- | Only run the given function if the given object exists
guardObject :: MonadDungeon m => ObjectId -> m () -> m ()

-- | Only run the given function if the given object is in the also given
--   room
guardObjectInRoom :: MonadDungeon m => ObjectId -> NodeId -> m () -> m ()

-- | Only run the given function if the given object is not in the also
--   given room
guardObjectNotInRoom :: MonadDungeon m => ObjectId -> NodeId -> m () -> m ()

-- | Only run the given function if an object of the given kind is in the
--   also given room
guardKindInRoom :: MonadDungeon m => KindId -> NodeId -> m () -> m ()

-- | Only run the given function if no object of the given kind is in the
--   also given room
guardKindNotInRoom :: MonadDungeon m => KindId -> NodeId -> m () -> m ()

-- | Consider the player's alcohol rate and mask the string with random
--   underscores.
drunken :: (ChRandom m, MonadPlayer m) => String -> m String
instance (Functor m, ChExpand m) => ChExpand (DungeonT m)


-- | Provides utility functions for dealing with stats and stereotypes
module Game.Antisplice.Stats

-- | Typeclass for every pure data that saves stats
class HasStats s
setStat :: HasStats s => StatKey -> Int -> s -> s
getStat :: HasStats s => StatKey -> s -> Int

-- | Typeclass for every monad that saves stats
class HasStatsM m
setStatM :: HasStatsM m => StatKey -> Int -> m ()
getStatM :: HasStatsM m => StatKey -> m Int

-- | Calculates the stats of the objects the player carries
calcStat :: (MonadPlayer m, ChAtoms m, MonadRoom m) => StatKey -> m Int

-- | Calculates the total stereotype the player carries
totalStereo :: (ChAtoms m, MonadPlayer m, MonadRoom m) => m PlayerStereo
instance None PlayerStereo
instance Monoid PlayerStereo
instance Monad m => HasStatsM (PlayerT m)
instance HasStats PlayerState


-- | Provides brick-by-brick composition for general actions, which may be
--   used for skills and gates.
module Game.Antisplice.Action

-- | A typeclass for all action types carrying an execution condition.
class IsAction a
(#&&) :: IsAction a => a -> a -> a
(#||) :: IsAction a => a -> a -> a
(!&&) :: IsAction a => a -> a -> a
(!||) :: IsAction a => a -> a -> a

-- | A general action, which may be used for skills and gates.
data Action
Action :: Predicate -> Handler -> Action
askAction :: Action -> Predicate
runAction :: Action -> Handler

-- | An action that is run <i>after</i> a specific event.
newtype ActionAfter
ActionAfter :: Action -> ActionAfter
runActionAfter :: ActionAfter -> Action

-- | An action that is run <i>before</i> a specific event.
newtype ActionBefore
ActionBefore :: Action -> ActionBefore
runActionBefore :: ActionBefore -> Action
ands :: (None a, IsAction a) => [a] -> a
andl :: (None a, IsAction a) => [a] -> a
ors :: (None a, IsAction a) => [a] -> a
orl :: (None a, IsAction a) => [a] -> a

-- | Use for actions that consume a given currency.
consumeCurrencyA :: CurrencyId -> Int -> Action

-- | Use for actions that consume an object of the given kind.
consumeKindA :: KindId -> Int -> Action

-- | Deal damage to opponent
dealDamageA :: ChattyDungeonM Int -> Action

-- | Use for actions that require a cooldown time.
implyCooldownA :: ChCounter m => Integer -> m Action

-- | Use for actions that suffer from global cooldown.
implyGlobalCooldownA :: Action
instance IsAction (Maybe ReError)
instance IsAction ActionBefore
instance IsAction ActionAfter
instance Monoid ActionBefore
instance Monoid ActionAfter
instance None ActionBefore
instance None ActionAfter
instance IsAction Action
instance Monoid Action
instance None Action
instance IsAction PredicateBox
instance Monoid PredicateBox
instance IsAction PrerequisiteBox
instance Monoid PrerequisiteBox


-- | Provides utility functions for composing skills
module Game.Antisplice.Skills

-- | A wrapper type for skill execution preconditions.
newtype Condition
Condition :: InvokableP -> Condition
runCondition' :: Condition -> InvokableP

-- | A single consumer. Build it using <tt>bareAction</tt>,
--   <tt>bareCondition</tt> and monoid concatenation.
data Consumer
Consumer :: !Condition -> !Invokable -> Consumer

-- | A skill. Build it using the <a>!+</a> compositor and the <a>skill</a>
--   function.
data Skill
Skill :: !Condition -> !Invokable -> !String -> Skill
skillConditionOf :: Skill -> !Condition
skillActionOf :: Skill -> !Invokable
skillNameOf :: Skill -> !String

-- | A recipe. Build it using the <a>!+</a> compositor and the
--   <a>recipe</a> function.
data Recipe
Recipe :: !Condition -> !Invokable -> !RecipeMethod -> !String -> Recipe
recipeConditionOf :: Recipe -> !Condition
recipeActionOf :: Recipe -> !Invokable
recipeMethodOf :: Recipe -> !RecipeMethod
recipeNameOf :: Recipe -> !String

-- | Typeclass for everything that may act as a consumer.
class ToConsumer c
toConsumer :: ToConsumer c => c -> Consumer

-- | Typeclass for everything that may be extended by consumers using !+
class Extensible e
(!+) :: (Extensible e, ToConsumer c) => e -> c -> e

-- | Add a consumer to the monadic extensible
(>!+) :: (ToConsumer c, Monad m, Extensible e) => m e -> c -> m e

-- | Add a monadic consumer to the extensible
(!+>) :: (ToConsumer c, Monad m, Extensible e) => e -> m c -> m e

-- | Add a monadic consumer to the monadic extensible
(>!+>) :: (ToConsumer c, Monad m, Extensible e) => m e -> m c -> m e

-- | Build a bogus skill that does nothing but has a name. Use this with
--   <a>!+</a> to build powerful skills.
skill :: String -> Skill

-- | Build a bogus recipe that does nothing has a name and a usage method.
--   Use this with <a>!+</a> to build powerful recipes.
recipe :: RecipeMethod -> String -> Recipe

-- | Build a consumer using new-style input validation
validConsumer :: (Append m (Cons EnsureLineEnd Nil) s, Append r Nil r, CallMask s r, Tuplify r t) => m -> (t -> Handler) -> Consumer

-- | Build a condition using new-style input validation
validCondition :: (Append m (Cons EnsureLineEnd Nil) s, Append r Nil r, CallMask s r, Tuplify r t) => m -> (t -> Predicate) -> Condition

-- | Map a masked consumer to a call mask
(#-) :: (Append m (Cons EnsureLineEnd Nil) s, Append r Nil r, CallMask s r) => m -> MaskedConsumer r -> Consumer

-- | Infix version of validConsumer
(#->) :: (Append m (Cons EnsureLineEnd Nil) s, Append r Nil r, CallMask s r, Tuplify r t) => m -> (t -> Handler) -> Consumer

-- | Infix version of validConsumer, swallowing the empty handler parameter
(#->>) :: (Append m (Cons EnsureLineEnd Nil) s, CallMask s Nil) => m -> Handler -> Consumer

-- | Focus direct object
focusDirectC :: Consumer

-- | Optionally ocus direct object (obligatory if none is focused yet)
optionallyFocusDirectC :: Consumer

-- | Dispatch the remaining part of the line as a recipe call
callRecipe :: RecipeMethod -> Consumer

-- | Run the given consumer
runConsumer :: ToConsumer c => c -> Invokable

-- | Wrap the skills into a form that is accepted by stereotypes.
wrapSkills :: [Skill] -> String -> Maybe Invokable

-- | Wrap the recipes into a form that is accepted by stereotypes.
wrapRecipes :: [Recipe] -> String -> Maybe (RecipeMethod -> Invokable)
instance Extensible Consumer
instance Extensible Recipe
instance Extensible Skill
instance ToConsumer Action
instance ToConsumer PredicateBox
instance ToConsumer Condition
instance ToConsumer HandlerBox
instance ToConsumer Recipe
instance ToConsumer Skill
instance ToConsumer Consumer
instance None Consumer
instance IsAction Consumer
instance Monoid Consumer
instance None Condition
instance IsAction Condition
instance Monoid Condition

module Game.Antisplice.Stereos

-- | Create a stereotype that carries a stats modifier
statsStereo :: ((StatKey -> Int) -> StatKey -> Int) -> PlayerStereo

-- | Create a stereotype that carries skills
skillsStereo :: [Skill] -> PlayerStereo

-- | Create a stereotype that carries a skill from a monadic composition
skillStereoM :: Monad m => m Skill -> m PlayerStereo

-- | Add the given stereotype to the current player.
addStereo :: MonadPlayer m => Atom PlayerStereo -> m ()

-- | Remove one stereotype and add another
replaceStereo :: MonadPlayer m => Atom PlayerStereo -> Atom PlayerStereo -> m ()

-- | Register the given stereotype and return its atom.
registerStereo :: ChAtoms m => PlayerStereo -> m (Atom PlayerStereo)

-- | Process the builder chain and register the resulting stereotype
registerStereoM :: ChAtoms m => StereoBuilderT m () -> m (Atom PlayerStereo)

-- | For monadic stereotype construction
newtype StereoBuilderT m a
StereoBuilder :: (PlayerStereo -> m (a, PlayerStereo)) -> StereoBuilderT m a
runStereoBuilderT :: StereoBuilderT m a -> PlayerStereo -> m (a, PlayerStereo)

-- | Merge the given pure stereotype into the built one
mergeStereo :: Monad m => PlayerStereo -> StereoBuilderT m ()

-- | Merge the given monadic stereotype into the built one
mergeStereoM :: Monad m => m PlayerStereo -> StereoBuilderT m ()

-- | Merge the given pure skill into the built stereotype
mergeSkill :: MonadVocab m => Skill -> StereoBuilderT m ()

-- | Merge the given pure recipe into the built stereotype
mergeRecipe :: MonadVocab m => Recipe -> StereoBuilderT m ()

-- | Merge the given monadic skill into the built stereotype
mergeSkillM :: MonadVocab m => m Skill -> StereoBuilderT m ()

-- | Merge the given monadic recipe into the built stereotype
mergeRecipeM :: MonadVocab m => m Recipe -> StereoBuilderT m ()

-- | Default stereotype.
defaultStereo :: MonadVocab m => m PlayerStereo
visualStereo :: MonadVocab m => m PlayerStereo
manualStereo :: MonadVocab m => m PlayerStereo
consumeStereo :: MonadVocab m => m PlayerStereo
instance ChChannelPrinter PlayerId m0 => ChChannelPrinter PlayerId (StereoBuilderT m0)
instance MonadObject m0 => MonadObject (StereoBuilderT m0)
instance MonadIO m0 => MonadIO (StereoBuilderT m0)
instance MonadPlayer m0 => MonadPlayer (StereoBuilderT m0)
instance MonadVocab m0 => MonadVocab (StereoBuilderT m0)
instance MonadRoom m0 => MonadRoom (StereoBuilderT m0)
instance (MonadDungeon m0, ChChannelPrinter PlayerId m0) => ChBroadcaster PlayerId (StereoBuilderT m0)
instance MonadDungeon m0 => MonadDungeon (StereoBuilderT m0)
instance MonadError SplErr m0 => MonadError SplErr (StereoBuilderT m0)
instance CanMount m0 n0 => CanMount (StereoBuilderT m0) n0
instance CanSave m0 n0 => CanSave (StereoBuilderT m0) n0
instance CanLoad m0 n0 => CanLoad (StereoBuilderT m0) n0
instance (ChAtoms (StereoBuilderT m0), ChFilesystem m0) => ChFilesystem (StereoBuilderT m0)
instance ChAtoms m0 => ChAtoms (StereoBuilderT m0)
instance ChCounter m0 => ChCounter (StereoBuilderT m0)
instance ChBufferedScanner m0 => ChBufferedScanner (StereoBuilderT m0)
instance ChExtendedPrinter m0 => ChExtendedPrinter (StereoBuilderT m0)
instance ChChannelPrinter Handle m0 => ChChannelPrinter Handle (StereoBuilderT m0)
instance ChChannelPrinter Bool m0 => ChChannelPrinter Bool (StereoBuilderT m0)
instance ChChannelPrinter Int m0 => ChChannelPrinter Int (StereoBuilderT m0)
instance ChHistoryEnv m0 => ChHistoryEnv (StereoBuilderT m0)
instance ChExpanderEnv m0 => ChExpanderEnv (StereoBuilderT m0)
instance ChClock m0 => ChClock (StereoBuilderT m0)
instance ChRandom m0 => ChRandom (StereoBuilderT m0)
instance ChSpawn m0 => ChSpawn (StereoBuilderT m0)
instance ChExpand m0 => ChExpand (StereoBuilderT m0)
instance ChFinalizer m0 => ChFinalizer (StereoBuilderT m0)
instance ChScanner m0 => ChScanner (StereoBuilderT m0)
instance ChPrinter m0 => ChPrinter (StereoBuilderT m0)
instance MonadTrans StereoBuilderT
instance (Functor m, Monad m) => Applicative (StereoBuilderT m)
instance Monad m => Monad (StereoBuilderT m)
instance Functor m => Functor (StereoBuilderT m)


-- | Some utility functions for constructing paths between rooms.
module Game.Antisplice.Paths

-- | A one-way path from <tt>f</tt> to <tt>t</tt>.
unipath :: MonadDungeon m => NodeId -> NodeId -> Direction -> m ()

-- | A mutual path. The specified direction is for the path from <tt>f</tt>
--   to <tt>t</tt>, the opposite one is chosen for <tt>t</tt> to
--   <tt>f</tt>.
bipath :: MonadDungeon m => NodeId -> NodeId -> Direction -> m ()

-- | A unipath that is guarded by a prerequisite.
guardedPath :: MonadDungeon m => NodeId -> NodeId -> Direction -> Prerequisite -> m ()

-- | A composable wrapper for a path state
newtype Gate
Gate :: PathState -> Gate
runGate :: Gate -> PathState

-- | Typeclass for everything that may be converted to a gate.
class Gatifiable g
toGate :: Gatifiable g => g -> Gate
gatedPath :: (Gatifiable g, MonadDungeon m) => NodeId -> NodeId -> Direction -> g -> m ()
instance Gatifiable ActionAfter
instance Gatifiable ActionBefore
instance Gatifiable PathState
instance Gatifiable PrerequisiteBox
instance Gatifiable Gate
instance IsAction Gate
instance Monoid Gate
instance None Gate


-- | Provides setters for the various events
module Game.Antisplice.Events

-- | Triggered when the user enters a room or object.
class OnEnter e
onEnter :: OnEnter e => Handler -> e ()

-- | Triggered when the user enters a room the first time.
class OnFirstEnter e
onFirstEnter :: OnFirstEnter e => Handler -> e ()

-- | Triggered when the user looks around or looks at a specific object.
class OnLook e
onLook :: OnLook e => Handler -> e ()

-- | Triggered when (a) the room is announced (e.g. when entered), (b) the
--   user looks around in the room containing the object.
class OnAnnounce e
onAnnounce :: OnAnnounce e => Handler -> e ()

-- | Triggered when the user sees the object (e.g. he enters its room).
class OnSight e
onSight :: OnSight e => Handler -> e ()

-- | Triggered when the user sees the object the first time.
class OnFirstSight e
onFirstSight :: OnFirstSight e => Handler -> e ()

-- | Triggered when the user acquires the object.
class OnAcquire e
onAcquire :: OnAcquire e => Handler -> e ()

-- | Triggered when the user acquires the object the first time.
class OnFirstAcquire e
onFirstAcquire :: OnFirstAcquire e => Handler -> e ()

-- | Triggered when the user inspects the object (looks at/into it, listens
--   to it, ...)
class OnInspection e
onInspection :: OnInspection e => Handler -> e ()

-- | Triggered when the user inspects the object the first time.
class OnFirstInspection e
onFirstInspection :: OnFirstInspection e => Handler -> e ()

-- | Triggered when the user looks into a specific object.
class OnLookInto e
onLookInto :: OnLookInto e => Handler -> e ()

-- | Triggered when the user reads the object.
class OnRead e
onRead :: OnRead e => Handler -> e ()

-- | Triggered when the object (e.g. a mob with a route) enters the room of
--   the user.
class OnRoomEnter e
onRoomEnter :: OnRoomEnter e => Handler -> e ()

-- | Triggered when the object (e.g. a mob with a route) leaves the room of
--   the user.
class OnRoomLeave e
onRoomLeave :: OnRoomLeave e => Handler -> e ()

-- | Triggered when the object takes damage.
class OnTakeDamage e
onTakeDamage :: OnTakeDamage e => Handler -> e ()

-- | Triggered when the object dies.
class OnDie e
onDie :: OnDie e => Handler -> e ()

-- | Triggered when the object is eaten
class OnEat e
onEat :: OnEat e => Handler -> e ()

-- | Triggered when the object is drunk.
class OnDrink e
onDrink :: OnDrink e => Handler -> e ()

-- | Triggered when the object is used
class OnUse e
onUse :: OnUse e => Handler -> e ()
instance Monad m => OnUse (ObjectT m)
instance Monad m => OnEat (ObjectT m)
instance Monad m => OnDrink (ObjectT m)
instance Monad m => OnDie (ObjectT m)
instance Monad m => OnTakeDamage (ObjectT m)
instance Monad m => OnRoomLeave (ObjectT m)
instance Monad m => OnRoomEnter (ObjectT m)
instance Monad m => OnRead (ObjectT m)
instance Monad m => OnFirstInspection (ObjectT m)
instance Monad m => OnInspection (ObjectT m)
instance Monad m => OnFirstAcquire (ObjectT m)
instance Monad m => OnAcquire (ObjectT m)
instance Monad m => OnFirstSight (ObjectT m)
instance Monad m => OnSight (ObjectT m)
instance Monad m => OnAnnounce (ObjectT m)
instance Monad m => OnAnnounce (RoomT m)
instance Monad m => OnLookInto (ObjectT m)
instance Monad m => OnLook (ObjectT m)
instance Monad m => OnLook (RoomT m)
instance Monad m => OnFirstEnter (RoomT m)
instance Monad m => OnEnter (ObjectT m)
instance Monad m => OnEnter (RoomT m)


-- | Provides all methods for language intellection.
module Game.Antisplice.Lang

-- | Run a given input line.
act :: String -> ChattyDungeonM ()
defVocab :: TST Token


-- | Provides a haskeline-based Read Eval Print Loop.
module Game.Antisplice.Terminal.Repl

-- | Read Eval Print Loop for Antisplice.
repl :: (Applicative m, ChExtendedPrinter m, ChScanner m, MonadError SplErr m, MonadIO m, ChExpand m, ChExpanderEnv m, MonadDungeon m, ChAtoms m, MonadRoom m, ChClock m, MonadVocab m, ChHistoryEnv m, ChRandom m, ChBroadcaster PlayerId m) => m ()

module Game.Antisplice.SingleUser
singleUser :: DungeonT (FailT SplErr (VocabT (AtomStoreT (CounterT (AnsiPrinterT (JoinerT (HistoryT (ExpanderT (NullExpanderT (HandleCloserT IO)))))))))) () -> IO ()


-- | Provides prototypes for common entities (rooms, objects, mobs).
module Game.Antisplice.Prototypes

-- | Construct a simple room from a title and a description.
ctorRoom :: ChAtoms m => String -> String -> RoomT m ()

-- | Construct a sign from a text and some attributes.
ctorSign :: (ChAtoms m, MonadVocab m, MonadError SplErr m) => String -> [String] -> ObjectT m ()

-- | Construct a mob from a title, some names, a description and some
--   attributes.
ctorMob :: MonadVocab m => String -> [String] -> String -> [String] -> ObjectT m ()

-- | Construct a mob route from some room IDs and a time delay in
--   milliseconds.
ctorRoute :: (Monad m, Functor m) => [NodeId] -> Integer -> ObjectT m ()

-- | Construct a room nesting object from a title, a description, some
--   names, some attributes and the target room ID.
ctorRoomNesting :: MonadVocab m => String -> String -> [String] -> [String] -> NodeId -> ObjectT m ()

-- | Construct an acquirable object from a title, a description, some names
--   and some attributes.
ctorAcq :: MonadVocab m => String -> String -> [String] -> [String] -> ObjectT m ()

-- | Add a room descriptor object to the current room
addRoomDesc :: ChAtoms m => String -> RoomT m ObjectId


-- | Reexports all relevant modules
module Game.Antisplice

-- | A dungeon constructor function
type Constructor a = forall m. (Functor m, ChExtendedPrinter m, ChExpand m, ChExpanderEnv m, ChAtoms m, ChClock m, MonadVocab m, MonadError SplErr m, MonadDungeon m) => m a
