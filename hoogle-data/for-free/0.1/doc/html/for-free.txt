-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Functor, Monad, MonadPlus, etc for free
--   
--   Plus, OpT, Yoneda, CoYoneda, Free, Cofree, Density, Codensity, CoT,
--   CodensityAsk, Initialize, Finalize, Decompose, Recompose
@package for-free
@version 0.1

module Control.ForFree

-- | <a>zero</a> and <a>plus</a> should form a monoid.
class Plus f
zero :: Plus f => f x
plus :: Plus f => f x -> f x -> f x

-- | Like <a>Op</a> but apply another type.
newtype OpT f a b
OpT :: (f b -> a) -> OpT f a b
getOpT :: OpT f a b -> f b -> a

-- | Right Yoneda lemma
newtype Yoneda f x
Yoneda :: (forall z. (x -> z) -> f z) -> Yoneda f x
runYoneda :: Yoneda f x -> forall z. (x -> z) -> f z

-- | Build the right Yoneda by specifying the translation from a functor to
--   anything.
unreduceYoneda :: Functor w => (forall z. w z -> f z) -> w x -> Yoneda f x

-- | Left Yoneda lemma
data CoYoneda f x
CoYoneda :: (z -> x) -> (f z) -> CoYoneda f x

-- | Lower the left Yoneda by specifying the translation from the inner
--   type to any functor.
reduceCoYoneda :: Functor m => (forall z. f z -> m z) -> CoYoneda f x -> m x

-- | Free monad from a functor
data Free f x
Pure :: x -> Free f x
Free :: (f (Free f x)) -> Free f x

-- | Lowers the free monad to another monad by giving the translation from
--   the functor to the monad.
reduceFree :: Monad m => (forall z. f z -> m z) -> Free f x -> m x

-- | Affect each level of the structure and pass a result of reading them
--   to the leaf nodes.
affectFree :: Functor g => (forall z. (s, f z) -> g (s, z)) -> (s, Free f x) -> Free g (s, x)

-- | Transformer of free monad.
newtype FreeT f m r
FreeT :: m (Either r (f (FreeT f m r))) -> FreeT f m r
runFreeT :: FreeT f m r -> m (Either r (f (FreeT f m r)))

-- | As <a>reduceFree</a> for transformers (you must reduce to the monad
--   being transformed).
reduceFreeT :: Monad m => (forall z. f z -> m z) -> FreeT f m x -> m x

-- | Free comonad from a functor
data Cofree f x
(:<) :: x -> f (Cofree f x) -> Cofree f x

-- | Build the free comonad from a comonad by giving the translation from
--   the comonad to a functor.
unreduceCofree :: Comonad w => (forall z. w z -> f z) -> w x -> Cofree f x

-- | Affect each level of the structure and pass a result of reading them
--   to each node.
affectCofree :: Functor g => (forall z. (s, f z) -> g (s, z)) -> (s, Cofree f x) -> Cofree g (s, x)
data CofreeT f w x
CofreeT :: (w x) -> (f (CofreeT f w x)) -> CofreeT f w x

-- | As <a>unreduceCofree</a> for transformers (you must unreduce from the
--   comonad being transformed).
unreduceCofreeT :: Comonad w => (forall z. w z -> f z) -> w x -> CofreeT f w x

-- | Codensity monad from anything (it doesn't have to be a functor)
newtype Codensity f x
Codensity :: (forall z. (x -> f z) -> f z) -> Codensity f x
runCodensity :: Codensity f x -> forall z. (x -> f z) -> f z

-- | You can reduce the codensity monad of any applicative functor to that
--   applicative functor.
lowerCodensity :: Applicative f => Codensity f x -> f x

-- | Density comonad from anything (it doesn't have to be a functor)
data Density f x
Density :: (f z -> x) -> (f z) -> Density f x

-- | You can make the density comonad from any copointed functor.
liftDensity :: Comonad w => w a -> Density w a

-- | Make a monad transformer from any comonad as Edward Kmett described.
newtype CoT w m a
CoT :: (forall r. w (a -> m r) -> m r) -> CoT w m a
runCoT :: CoT w m a -> forall r. w (a -> m r) -> m r
type Co w = CoT w Identity
runCo :: Functor w => Co w a -> w (a -> r) -> r
liftCoT0 :: Comonad w => (forall a. w a -> s) -> CoT w m s
lowerCoT0 :: (Functor w, Applicative m) => CoT w m s -> w a -> m s
lowerCo0 :: Functor w => Co w s -> w a -> s
liftCoT1 :: (forall a. w a -> a) -> CoT w m ()
lowerCoT1 :: (Functor w, Applicative m) => CoT w m z -> w a -> m a
lowerCo1 :: Functor w => Co w z -> w a -> a

-- | Codensity monad taking a parameter holding something related to the
--   output type. If this parameter is a comonad, you get a
--   <a>MonadPlus</a>.
newtype CodensityAsk w x
CodensityAsk :: (forall z. w z -> (x -> z) -> z) -> CodensityAsk w x
runCodensityAsk :: CodensityAsk w x -> forall z. w z -> (x -> z) -> z

-- | Access the result of some <a>CodensityAsk</a> by specifying an input
--   which corresponds to the result.
peekCodensityAsk :: w x -> CodensityAsk w x -> x
newtype CodensityAskT w m x
CodensityAskT :: (forall z. w (m z) -> (x -> m z) -> m z) -> CodensityAskT w m x
runCodensityAskT :: CodensityAskT w m x -> forall z. w (m z) -> (x -> m z) -> m z
peekCodensityAskT :: Applicative m => w (m x) -> CodensityAskT w m x -> m x
lowerCodensityAskT :: (Plus w, Applicative m) => CodensityAskT w m x -> m x
catchCodensityAsk :: w (CodensityAsk w x) -> CodensityAsk w x -> CodensityAsk w x
catchCodensityAskT :: (Functor w, Monad m) => w (CodensityAskT w m x) -> CodensityAskT w m x -> CodensityAskT w m x
data DensityAskT p f x
DensityAskT :: (p z -> f z -> x) -> (f z) -> DensityAskT p f x

-- | Density comonad taking a parameter holding something related to the
--   output type. If this parameter is a <a>Plus</a>, you get a comonad.
type DensityAsk p = DensityAskT p Identity
liftDensityAsk :: Comonad w => w x -> DensityAskT p w x

-- | Finalize monad on '(-&gt;)' category. (The Finalize monad is the only
--   possible monad of a endofunctor taking all objects to one final object
--   of the category.)
data Finalize x
Finalize :: Finalize x

-- | Initialize comonad on '(-&gt;)' category. (The Initialize comonad is
--   dual to the Finalize monad.)
data Initialize x
data Decompose :: (* -> *) -> (* -> *) -> * -> *
Decompose :: y z -> Decompose x y (x z)
data Recompose :: ((* -> *) -> (* -> *) -> * -> *) -> (* -> *) -> * -> *
Recompose :: w x y (x z) -> Recompose w y z

-- | Dual function arrows.
newtype Op a b :: * -> * -> *
Op :: (b -> a) -> Op a b
getOp :: Op a b -> b -> a

-- | The monoid of endomorphisms under composition.
newtype Endo a :: * -> *
Endo :: (a -> a) -> Endo a
appEndo :: Endo a -> a -> a
newtype Const a b :: * -> * -> *
Const :: a -> Const a b
getConst :: Const a b -> a
instance (Show (f (Cofree f a)), Show a) => Show (Cofree f a)
instance (Read (f (Cofree f a)), Read a) => Read (Cofree f a)
instance (Ord (f (Cofree f a)), Ord a) => Ord (Cofree f a)
instance (Eq (f (Cofree f a)), Eq a) => Eq (Cofree f a)
instance (Show (f (Free f a)), Show a) => Show (Free f a)
instance (Read (f (Free f a)), Read a) => Read (Free f a)
instance (Ord (f (Free f a)), Ord a) => Ord (Free f a)
instance (Eq (f (Free f a)), Eq a) => Eq (Free f a)
instance MonadPlus m => Plus (StateT s m)
instance Plus f => Plus (WriterT x f)
instance Plus f => Plus (ReaderT x f)
instance (Monoid w, Functor m, MonadPlus m) => Plus (RWST r w s m)
instance (ArrowZero a, ArrowPlus a) => Plus (WrappedArrow a b)
instance (Functor m, Monad m) => Plus (MaybeT m)
instance Plus IntMap
instance Ord k => Plus (Map k)
instance Plus Seq
instance Plus Maybe
instance Plus []
instance ComonadHoist (Decompose f)
instance Comonad Initialize
instance Extend Initialize
instance Contravariant Initialize
instance Functor Initialize
instance Monoid (Finalize x)
instance MonadPlus Finalize
instance Alternative Finalize
instance Monad Finalize
instance Applicative Finalize
instance Contravariant Finalize
instance Functor Finalize
instance Comonad w => MonadTrans (CoT w)
instance (Comonad w, Plus m) => MonadPlus (CoT w m)
instance (Comonad w, Plus m) => Alternative (CoT w m)
instance Comonad w => Monad (CoT w m)
instance Comonad w => Applicative (CoT w m)
instance Functor w => Functor (CoT w m)
instance Plus p => ComonadTrans (DensityAskT p)
instance Plus p => Comonad (DensityAskT p f)
instance Plus p => Extend (DensityAskT p f)
instance Functor (DensityAskT p f)
instance Comonad w => Plus (CodensityAsk w)
instance Comonad w => Alternative (CodensityAsk w)
instance Applicative (CodensityAsk w)
instance Comonad w => MonadPlus (CodensityAsk w)
instance Monad (CodensityAsk w)
instance Functor (CodensityAsk w)
instance MonadTrans (CodensityAskT w)
instance Comonad w => Plus (CodensityAskT w f)
instance Comonad w => Alternative (CodensityAskT w f)
instance Applicative (CodensityAskT w f)
instance Comonad w => MonadPlus (CodensityAskT w m)
instance Monad (CodensityAskT w m)
instance Functor (CodensityAskT w m)
instance ComonadTrans Density
instance Applicative f => Applicative (Density f)
instance Comonad (Density f)
instance Extend (Density f)
instance Functor (Density f)
instance MonadTrans Codensity
instance Plus f => Plus (Codensity f)
instance Plus f => MonadPlus (Codensity f)
instance Plus f => Alternative (Codensity f)
instance Applicative (Codensity f)
instance Monad (Codensity f)
instance Functor (Codensity f)
instance ComonadTrans (CofreeT f)
instance (Functor f, Comonad w) => Comonad (CofreeT f w)
instance (Functor f, Extend w) => Extend (CofreeT f w)
instance (Functor f, Functor w) => Functor (CofreeT f w)
instance MonadTrans (FreeT f)
instance Plus m => Plus (FreeT f m)
instance (Functor f, Monad m, Alternative m) => Alternative (FreeT f m)
instance (Functor f, MonadPlus m) => MonadPlus (FreeT f m)
instance (Functor f, Applicative m, Monad m) => Applicative (FreeT f m)
instance (Functor f, Monad m) => Monad (FreeT f m)
instance (Functor f, Functor m) => Functor (FreeT f m)
instance ComonadHoist Cofree
instance Applicative f => Applicative (Cofree f)
instance Functor f => Comonad (Cofree f)
instance Functor f => Extend (Cofree f)
instance Functor f => Functor (Cofree f)
instance ComonadHoist Free
instance Plus f => Plus (Free f)
instance (Functor f, Plus f) => MonadPlus (Free f)
instance (Functor f, Plus f) => Alternative (Free f)
instance Functor f => Monad (Free f)
instance Functor f => Applicative (Free f)
instance Functor f => Functor (Free f)
instance Functor (CoYoneda f)
instance Plus f => Plus (Yoneda f)
instance Functor (Yoneda f)
instance Plus Comparison
instance Monoid x => Plus (OpT f x)
instance Monoid x => Plus (Op x)
instance Plus Endo
instance Comonad f => Category (OpT f)
instance Functor f => Contravariant (OpT f x)
instance Monoid x => Plus (Const x)
instance Monoid x => Alternative (Const x)
