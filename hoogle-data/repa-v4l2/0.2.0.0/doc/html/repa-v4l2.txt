-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Provides high-level access to webcams.
--   
--   The current state is that the library provides a monad for grabbing
--   images from a webcam under Linux. In the future, more functionality
--   like image processing functions and other input devices may be added.
--   If anyone wants to help, please contact me!
@package repa-v4l2
@version 0.2.0.0


-- | The Linux interface for accessing webcams via video4linux. This module
--   uses the lower-level bindings to v4l to provide for a simple way to
--   access a web camera from Haskell code using repa. The module is meant
--   to be used like shown in the file <i>example.hs</i> in the root of the
--   package. For example:
--   
--   <pre>
--   main = runCam (Webcam 0) $ 
--                  grab &gt;&gt;= saveBmp "1.bmp" &gt;&gt; 
--                  grab &gt;&gt;= saveBmp "2.bmp" &gt;&gt; 
--                  grab &gt;&gt;= saveBmp "3.bmp"
--   </pre>
--   
--   This example would take three pictures from the first webcam and store
--   them in three files.
module Graphics.Webcam.Linux
data Webcam
Webcam :: Int -> Webcam

-- | An image data type. This uses the Array type Data.Array.Repa.Array.
type Image r a = Array r DIM3 a
data V4lCamT m a
data CamState

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => forall a. IO a -> m a

-- | Given a <a>Webcam</a>, runs a <a>V4lCamT</a> action with it. All
--   actions may <a>throwError</a>, which can be caught with
--   <a>catchError</a>. In case of an error, <a>runCam</a> returns
--   <a>Left</a> with an errormessage. Otherwise, it returns a <a>Right</a>
--   with the result.
--   
--   This function sets a <a>reasonable</a> image format using
--   <a>findImageFormat</a> after opening the webcam. Then, the supplied
--   action is run and the camera is closed again.
--   
--   You may want to set a different image size or image format, when that
--   is supported.
runCam :: MonadIO m => Webcam -> V4lCamT m a -> m (Either String a)

-- | Like <a>runCam</a>, but runs with a given state.
runCamWith :: MonadIO m => CamState -> V4lCamT m a -> m (Either String a)

-- | Grab a new image from the currently open camera. May <a>throwError</a>
--   if something goes wrong.
grab :: MonadIO m => V4lCamT m (Image U Word8)

-- | Like <a>grab</a>, but applies the given function to the captured
--   image.
grabF :: MonadIO m => (Image D Word8 -> Image D Word8) -> V4lCamT m (Image F Word8)

-- | This function sets the size to the next fitting size the connected web
--   camera supports. You can query the actual size with <a>getSize</a>.
setSize :: MonadIO m => (Int, Int) -> V4lCamT m ()

-- | Returns the image with and height of the images captured by the
--   currently open web cam.
getSize :: Monad m => V4lCamT m (Int, Int)

-- | Get the state data. Internal.
getState :: Monad m => V4lCamT m CamState

-- | Save the given <a>Image</a> as BMP in the file with the given name.
--   This function currently takes a detour via lists when converting the
--   image to a <tt>ByteString</tt>, and is therefore probably slower than
--   necessary (FIXME).
saveBmp :: (MonadIO m, Source r Word8) => FilePath -> Image r Word8 -> V4lCamT m ()

-- | Get the currently used image format. May <a>throwError</a> if the
--   format has not been set.
getImageFormat :: Monad m => V4lCamT m ImageFormat

-- | Finds an image format, sets the current device to it and sets it so it
--   can be retrieved with <a>getImageFormat</a>. Currently this function
--   will set a <a>PixelRGB24</a> format. Add more intelligence to this if
--   needed.
findImageFormat :: MonadIO m => V4lCamT m ()
rgbaToAbgr :: Source r a => Image r a -> Image D a

-- | Flips the Y axis of a given image.
flipY :: Source r a => Image r a -> Image D a
