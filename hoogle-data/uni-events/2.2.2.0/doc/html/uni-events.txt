-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Event handling for the uniform workbench
--   
@package uni-events
@version 2.2.2.0

module Events.Synchronized
class Synchronized a
synchronize :: Synchronized a => a -> IO b -> IO b


-- | A Cell is a container for a value. It is created with the value in it.
--   The only change we can make is to remove the value, and we cannot put
--   it back again.
module Events.Cells
data Cell a
newCell :: a -> IO (Cell a)
emptyCell :: Cell a -> IO ()
inspectCell :: Cell a -> IO (Maybe a)


-- | A DeleteQueue is a queue where entries can be deleted by an IO action.
--   This is a fairly specialised implementation, designed for event
--   handling.
--   
--   Queue entries are either active or invalid. Once invalid, removeQueue
--   will not return them, but they still take up (a little) memory.
--   
--   addQueue, removeQueue, isEmptyQueue, cleanQueue all take a delete
--   queue as argument. We assume that this argument is not used again.
--   
--   Either removeQueue or isEmptyQueue or cleanQueue should be run
--   occasionally, to remove invalid entries.
module Events.DeleteQueue
data DeleteQueue v
emptyQueue :: DeleteQueue v
addQueue :: DeleteQueue v -> v -> IO (DeleteQueue v, IO ())
removeQueue :: DeleteQueue v -> IO (Maybe (v, DeleteQueue v, DeleteQueue v))
isEmptyQueue :: DeleteQueue v -> IO (Maybe (DeleteQueue v))
cleanQueue :: DeleteQueue v -> IO (DeleteQueue v)


-- | FMQueue handles finite maps of delete queues, so that we can implement
--   EqGuard.
module Events.FMQueue
data Ord key => FMQueue key contents
emptyFMQueue :: Ord key => FMQueue key contents
addFMQueue :: Ord key => FMQueue key contents -> key -> contents -> IO (FMQueue key contents, IO ())
removeFMQueue :: Ord key => FMQueue key contents -> key -> IO (Maybe (contents, FMQueue key contents), FMQueue key contents)
removeFMQueueAny :: Ord key => FMQueue key contents -> IO (Maybe (key, contents, FMQueue key contents), FMQueue key contents)


-- | RefQueue are standard non-functional queues using pointers (aka
--   IORefs). Events can be deleted asynchronously, but this is done only
--   by nulling the cell they are contained in, otherwise we would need to
--   double-link. Other operations, IE the push and pop function must not
--   occur on the same queue concurrently.
--   
--   Although the queues are impure, we return the new queue to be used in
--   future after push and search operations.
--   
--   RefQueue are intended for use for queues of guarded strings, hence the
--   specialised implementation.
module Events.RefQueue
data RefQueue a
newRefQueue :: IO (RefQueue a)
pushRefQueue :: RefQueue a -> a -> IO (RefQueue a, IO ())
searchRefQueue :: RefQueue a -> (a -> Bool) -> IO (Maybe (a, IO (RefQueue a)), RefQueue a)


-- | Spawn provides an interface to Concurrent.forkIO which is supposed to
--   be implementable for both Hugs and GHC.
--   
--   This is the GHC implementation.
module Events.Spawn

-- | Do a fork, returning an action which may attempt to kill the forked
--   thread. (Or may not . . .)
spawn :: IO () -> IO (IO ())


-- | A toggle is a switch initially True, which can only be made false
--   (when some action is performed, say). This module implements toggles,
--   allowing atomic switching to false of 1 toggle, or 2 toggles together.
--   To avoid deadlock we use a supply of unique integers.
module Events.Toggle
data Toggle
newToggle :: IO Toggle
toggle1 :: Toggle -> IO Bool
toggle2 :: Toggle -> Toggle -> IO (Maybe (Bool, Bool))
ifToggle :: Toggle -> IO () -> IO ()
peekToggle :: Toggle -> IO Bool
data SimpleToggle
newSimpleToggle :: IO SimpleToggle
simpleToggle :: SimpleToggle -> IO Bool
ifSimpleToggle :: SimpleToggle -> IO () -> IO ()


-- | <a>Event</a>s and combinators for them.
module Events.Events
data Result
Immediate :: Result
Awaiting :: (IO ()) -> Result
AwaitingAlways :: (IO ()) -> Result
newtype Event a
Event :: (Toggle -> (IO a -> IO ()) -> IO Result) -> Event a

-- | HasEvent represents those event-like things which can be converted to
--   an event.
class HasEvent eventType
toEvent :: HasEvent eventType => eventType a -> Event a

-- | The event that never happens
never :: Event a

-- | The event that always happens, immediately
always :: IO a -> Event a

-- | Synchronise on an event, waiting on it until it happens, then
--   returning the attached value.
sync :: Event a -> IO a

-- | Synchronise on an event, but return immediately with Nothing if it
--   can't be satisfied at once.
poll :: Event a -> IO (Maybe a)

-- | Attach an action to be done after the event occurs.
(>>>=) :: Event a -> (a -> IO b) -> Event b

-- | Attach an action to be done after the event occurs.
(>>>) :: Event a -> IO b -> Event b

-- | Choose between two events. The first one takes priority.
(+>) :: Event a -> Event a -> Event a

-- | Choose between a list of events.
choose :: [Event a] -> Event a

-- | Catch an error if it occurs during an action attached to an event.
tryEV :: Event a -> Event (Either SomeException a)

-- | Construct a new event using an action which is called at each
--   synchronisation
computeEvent :: IO (Event a) -> Event a

-- | When we synchronise on wrapAbort preAction preAction is evaluated to
--   yield (event,postAction). Then exactly one of the following: (1) thr
--   event is satisfied, and postAction is not done. (2) some other event
--   in this synchronisation is satisfied (so this one isn't), and
--   postAction is done. (3) no event is satisfied (and so we will
--   deadlock).
wrapAbort :: IO (Event a, IO ()) -> Event a

-- | Turns an event into one which is always satisfied at once but
--   registers the value to be done later. WARNING - only to be used with
--   events without actions attached, as any actions will not get done.
--   noWait is typically used with send events, where we don't want to wait
--   for someone to pick up the value.
noWait :: Event a -> Event ()

-- | HasSend represents things like channels on which we can send values
class HasSend chan
send :: HasSend chan => chan a -> a -> Event ()

-- | HasReceive represents things like channels from which we can take
--   values.
class HasReceive chan
receive :: HasReceive chan => chan a -> Event a

-- | Send a value along a channel (as an IO action)
sendIO :: HasSend chan => chan a -> a -> IO ()

-- | Get a value from a channel (as an IO action)
receiveIO :: HasReceive chan => chan a -> IO a

-- | allowWhile event1 event2 waits for event2, while handling event1.
allowWhile :: Event () -> Event a -> Event a
data Request a b
Request :: (a -> IO (Event b, IO ())) -> Request a b
request :: Request a b -> a -> IO b
doRequest :: Request a b -> a -> IO (Event b, IO ())

-- | Synchronise on an event in a different thread. The kill action it
--   returns is unsafe since it can cause deadlocks if it occurs at an
--   awkward moment. To avoid this use spawnEvent, if possible.
spawnEvent :: Event () -> IO (IO ())

-- | get all we can get from the event without waiting.
getAllQueued :: Event a -> IO [a]
thenGetEvent :: Event a -> (a -> Event b) -> Event b
thenEvent :: Event a -> Event b -> Event b
doneEvent :: a -> Event a

-- | Register an event as synchronised but don't wait for it to complete.
--   WARNING - only to be used with events without actions attached, as any
--   actions will not get done. noWait is typically used with send events,
--   where we don't want to wait for someone to pick up the value.
--   synchronise on something without waiting
syncNoWait :: Event a -> IO ()
instance Functor Event
instance Applicative Event
instance Monad Event
instance HasEvent Event


-- | In GuardedEvents we extend the notion of PrimEvents to allow Guarded
--   Events, which can be guarded with the new (|&gt;) operator.
--   GuardedChannels will implement guarded events on channels, which will
--   hopefully be the only guarded event we will ever need.
module Events.GuardedEvents

-- | A GuardedEvent guard a represents a source of values of type a, which
--   may be selected from according to guards of type guard.
data Guard guard => GuardedEvent guard a
GuardedEvent :: !(guard -> Event a) -> !guard -> GuardedEvent guard a
class Guard guard => HasGuard eventType guard
(|>) :: HasGuard eventType guard => eventType a -> guard -> eventType a

-- | A Guard represents some condition on a value which we impose on a
--   channel, selecting those values we are interested in.
class Guard guard
nullGuard :: Guard guard => guard
andGuard :: Guard guard => guard -> guard -> guard

-- | Class of those channels which have guarded events.
class HasListen chan
listen :: (HasListen chan, Guard guard) => chan guard a -> GuardedEvent guard a
instance Guard guard => HasEvent (GuardedEvent guard)
instance Guard guard => HasGuard (GuardedEvent guard) guard


-- | GuardedEvents implements guarded events for channels.
module Events.GuardedChannels
data GuardedChannel guard value
type GQ guardQueue value = guardQueue (GuardInfo value)
type VQ valueQueue = valueQueue ValueInfo
newGuardedChannel :: HasGuardedChannel guardQueue valueQueue guard value => GQ guardQueue value -> VQ valueQueue -> IO (GuardedChannel guard value)
sneak :: Guard guard => GuardedChannel guard value -> GuardedEvent guard (Maybe value)
replace :: Guard guard => GuardedChannel guard value -> value -> GuardedEvent guard (Maybe value)
class HasEmpty xQueue
newEmpty :: HasEmpty xQueue => IO (xQueue xData)
class HasRemove yQueue x y
remove :: HasRemove yQueue x y => yQueue yData -> x -> IO (Maybe (y, yData, IO (yQueue yData)), yQueue yData)
class HasAdd xQueue x
add :: HasAdd xQueue x => xQueue xData -> x -> xData -> IO (xQueue xData, IO ())
class (HasRemove yQueue x y, HasAdd xQueue x) => CanSendX xQueue yQueue x y
class (Guard guard, HasEmpty guardQueue, HasEmpty valueQueue, CanSendX guardQueue valueQueue guard value, CanSendX valueQueue guardQueue value guard) => HasGuardedChannel guardQueue valueQueue guard value
instance (Guard guard, HasEmpty guardQueue, HasEmpty valueQueue, CanSendX guardQueue valueQueue guard value, CanSendX valueQueue guardQueue value guard) => HasGuardedChannel guardQueue valueQueue guard value
instance (HasRemove yQueue x y, HasAdd xQueue x) => CanSendX xQueue yQueue x y
instance HasSend (GuardedChannel guard)
instance Guard guard => HasReceive (GuardedChannel guard)
instance HasListen GuardedChannel


-- | Here we implement a null guard channel that provides no guards, but is
--   hopefully useful as an example.
module Events.NullGuard
type NullGuardedChannel value = GuardedChannel () value
newNullGuardedChannel :: IO (NullGuardedChannel value)
instance HasRemove NullGuardQueue value ()
instance HasAdd NullGuardQueue ()
instance HasEmpty NullGuardQueue
instance HasRemove (NullValueQueue value) () value
instance HasAdd (NullValueQueue value) value
instance HasEmpty (NullValueQueue value)
instance Guard ()


-- | Here we create a simple guarded queue which allows guarding by
--   equality according to an ordered key. Thus guards have three values,
--   match anything, match nothing, and match this value.
--   
--   To simplify the implementation, we specify that an Eq match has higher
--   priority than a MatchAnything match, and when we must choose between
--   values for MatchAnything, do not necessarily choose the first (more
--   likely the one with the lowest key value). But we do respect FIFO
--   order when only Eq guards are involved.
module Events.EqGuard
type EqGuardedChannel key value = GuardedChannel (EqMatch key) (key, value)
data EqMatch key
Eq :: !key -> EqMatch key
EqMatchAny :: EqMatch key
EqMatchNone :: EqMatch key
newEqGuardedChannel :: Ord key => IO (EqGuardedChannel key value)
instance Ord key => HasRemove (EqGuardQueue key) (key, value) (EqMatch key)
instance Ord key => HasAdd (EqGuardQueue key) (EqMatch key)
instance Ord key => HasEmpty (EqGuardQueue key)
instance Ord key => HasRemove (EqValueQueue key value) (EqMatch key) (key, value)
instance Ord key => HasAdd (EqValueQueue key value) (key, value)
instance Ord key => HasEmpty (EqValueQueue key value)
instance Ord key => Guard (EqMatch key)


-- | Things which instance Destroyable and Destructible can be destroyed.
module Events.Destructible
class Destroyable o
destroy :: Destroyable o => o -> IO ()
class Destroyable o => Destructible o
destroyed :: Destructible o => o -> Event ()

-- | doOnce can be used to produce an action which is identical to its
--   argument, except that if it's already been called, it does nothing.
doOnce :: IO () -> IO (IO ())


-- | This is a bare-bones implementation of CML-style channels, IE no
--   guards. Why not use NullGuardChannel you might ask? Because all the
--   gunge we add to do guards makes it too inefficient.
--   
--   To avoid memory-leaks we need to clean out superannuated registrations
--   occasionally, as otherwise we will gradually run out of memory if the
--   user continually polls a receive channel event, but no-one is sending
--   anything. (The memory lost is potentially quite big, since it includes
--   all the continuations we will never need.)
--   
--   Although this is not expressed by the type, there are three possible
--   states for the channel (1) we have &gt;=0 queued send events and no
--   queued receive events. (2) we have &gt;=0 queued receive events and no
--   queued send events. (3) we have both send and receive events queued,
--   but they all come from the same synchronisation. When we have a new
--   send event, and there are queued receive events not from the same
--   synchronisation, we can match. Otherwise the send event must be
--   queued. For receive events the situation is exactly the same in
--   reverse.
--   
--   Our quick and dirty strategy is to maintain an integer counter for the
--   channel. This is initially 0 and on each send or receive registration
--   changes as follows: 1) If we match an event set counter to 0. 2) If we
--   try to match an event, but fail because the event was already matched
--   by someone else (Anticipated), leave counter as it is. 3) If finally
--   we have to queue an event, look at counter. If it exceeds 10, clean
--   the queue and set counter to 0, otherwise increment it. "cleaning"
--   means removing all items from the front of the queue which have
--   flipped toggles.
module Events.Channels

-- | A synchronous channel
data Channel a

-- | Create a new channel
newChannel :: IO (Channel a)
instance HasReceive Channel
instance HasSend Channel


-- | Examples is meant to contain examples of using events which are too
--   small to go into their own module.
module Events.Examples
data EventSet a
emptyEventSet :: EventSet a
addToEventSet :: EventSet a -> Event a -> EventSet a
fromEventSet :: EventSet a -> Event (a, EventSet a)
isEmptyEventSet :: EventSet a -> Bool

-- | watch is used for events like mouse motion events where if we can't
--   find time we don't want them queued. The event returned waits until
--   the original event next happens and returns it. A worker thread is
--   needed to run this; the attached action should be used to stop that
--   thread when we are no longer interested.
watch :: Event a -> IO (Event a, IO ())

-- | spawnRepeatedEvent concurrently syncs on the event until the given
--   action is used; it is somewhat safer than spawnEvent. It also never
--   interrupts the handler event attached to the event.
spawnRepeatedEvent :: Event () -> IO (IO ())
