-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Behaviour Driven Development like Cucumber for Haskell
--   
--   Chuchu is a system similar to Ruby's Cucumber for Behaviour Driven
--   Development. It works with a language similar to Cucumber's Gherkin,
--   which is parsed using package abacate.
@package chuchu
@version 0.4.2


module Test.Chuchu.Types

-- | <tt>newtype</tt> for Parsec's <tt>Parser</tt> used on this library.
--   The main reason for not using <tt>Parser</tt> directly is to be able
--   to define the <a>IsString</a> instance.
newtype ChuchuParser a
ChuchuParser :: (Parser a) -> ChuchuParser a

-- | The most common use case where the return value of the Monad is
--   ignored.
type Chuchu m = ChuchuM m ()

-- | The Monad on which the step rules are constructed. <a>Given</a>,
--   <a>When</a>, <a>Then</a>, <a>And</a> and <a>But</a> are interpreted in
--   the same way by the program. All of them receive a parser and an
--   action to run if the parser finishes correctly.
data ChuchuM m a
Given :: ChuchuParser a -> (a -> m ()) -> ChuchuM m ()
When :: ChuchuParser a -> (a -> m ()) -> ChuchuM m ()
Then :: ChuchuParser a -> (a -> m ()) -> ChuchuM m ()
And :: ChuchuParser a -> (a -> m ()) -> ChuchuM m ()
But :: ChuchuParser a -> (a -> m ()) -> ChuchuM m ()

-- | Converts the Monad into a single <tt>Parser</tt> that executes the
--   specified action if the parser is executed correctly. It includes an
--   <tt>eof</tt> on the parser of each step to avoid it from accepting
--   prefixes of the desired rule.
runChuchu :: ChuchuM m a -> Parser (m ())
instance Functor ChuchuParser
instance Applicative ChuchuParser
instance Alternative ChuchuParser
instance Monad ChuchuParser
instance MonadPlus ChuchuParser
instance Monad (ChuchuM m)
instance a ~ () => IsString (ChuchuParser a)


-- | This modules provides some utility parsers for creating step rules.
module Test.Chuchu.Parser

-- | <tt>newtype</tt> for Parsec's <tt>Parser</tt> used on this library.
--   The main reason for not using <tt>Parser</tt> directly is to be able
--   to define the <a>IsString</a> instance.
data ChuchuParser a

-- | Parses a floating point number, with the same syntax as accepted by
--   Haskell.
number :: ChuchuParser Double

-- | Parses an integer.
int :: ChuchuParser Integer

-- | Parses a quoted string, with the same syntax as accepted by Haskell.
text :: ChuchuParser Text

-- | Parses anything until the string passed as parameter, and also the
--   string.
wildcard :: Text -> ChuchuParser Text

-- | Parses a simplified e-mail address and return everything that was
--   parsed as a simple <a>Text</a>. This is a very simplified parser for
--   e-mail, which does not follow RFC5322. Basically, it parses
--   <tt>TEXT@TEXT</tt>, where TEXT is <tt>alphaNum &lt;|&gt; oneOf
--   "!#$%&amp;'*+-/=?^_`{|}~."</tt>.
email :: ChuchuParser Text

-- | Same as Parsec's <a>try</a> but for <a>ChuchuParser</a>.
try :: ChuchuParser a -> ChuchuParser a


-- | Chuchu is a system similar to Ruby's Cucumber for Behaviour Driven
--   Development. It works with a language similar to Cucumber's Gherkin,
--   which is parsed using package abacate.
--   
--   This module provides the main function for a test file based on
--   Behaviour Driven Development for Haskell.
--   
--   Example for a Stack calculator:
--   
--   <tt>calculator.feature</tt>:
--   
--   <pre>
--   Feature: Division
--     In order to avoid silly mistakes
--     Cashiers must be able to calculate a fraction
--   
--   Scenario: Regular numbers
--       Given that I have entered 3 into the calculator
--       And that I have entered 2 into the calculator
--       When I press divide
--       Then the result should be 1.5 on the screen
--   </pre>
--   
--   <tt>calculator.hs</tt>:
--   
--   <pre>
--   import Control.Applicative
--   import Control.Monad.IO.Class
--   import Control.Monad.Trans.State
--   import Test.Chuchu
--   import Test.HUnit
--   
--   type CalculatorT m = StateT [Double] m
--   
--   enterNumber :: Monad m =&gt; Double -&gt; CalculatorT m ()
--   enterNumber = modify . (:)
--   
--   getDisplay :: Monad m =&gt; CalculatorT m Double
--   getDisplay
--     = do
--       ns &lt;- get
--       return $ head $ ns ++ [0]
--   
--   divide :: Monad m =&gt; CalculatorT m ()
--   divide = do
--     (n1:n2:ns) &lt;- get
--     put $ (n2 / n1) : ns
--   
--   defs :: Chuchu (CalculatorT IO)
--   defs
--     = do
--       Given
--         ("that I have entered " *&gt; number &lt;* " into the calculator")
--         enterNumber
--       When "I press divide" $ const divide
--       Then ("the result should be " *&gt; number &lt;* " on the screen")
--         $ \n
--           -&gt; do
--             d &lt;- getDisplay
--             liftIO $ d @?= n
--   
--   main :: IO ()
--   main = chuchuMain defs (`evalStateT` [])
--   </pre>
module Test.Chuchu

-- | The main function for the test file. It expects one or more
--   <tt>.feature</tt> file as parameters on the command line. If you want
--   to use it inside a library, consider using <tt>withArgs</tt>.
chuchuMain :: (MonadBaseControl IO m, MonadIO m, Applicative m) => Chuchu m -> (m () -> IO ()) -> IO ()
instance Typeable Options
instance Show ExecutionPlan
instance Eq Options
instance Show Options
instance Data Options
