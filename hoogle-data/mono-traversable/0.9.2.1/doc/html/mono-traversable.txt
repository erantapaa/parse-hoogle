-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Type classes for mapping, folding, and traversing monomorphic containers
--   
@package mono-traversable
@version 0.9.2.1


-- | Provides conversion functions between strict <a>ByteString</a>s and
--   storable <a>Vector</a>s.
module Data.ByteVector

-- | Convert a <a>ByteString</a> into a storable <a>Vector</a>.
--   
--   Since 0.6.1
toByteVector :: ByteString -> Vector Word8

-- | Convert a storable <a>Vector</a> into a <a>ByteString</a>.
--   
--   Since 0.6.1
fromByteVector :: Vector Word8 -> ByteString


-- | Type classes mirroring standard typeclasses, but working with
--   monomorphic containers.
--   
--   The motivation is that some commonly used data types (i.e.,
--   <tt>ByteString</tt> and <tt>Text</tt>) do not allow for instances of
--   typeclasses like <a>Functor</a> and <tt>Foldable</tt>, since they are
--   monomorphic structures. This module allows both monomorphic and
--   polymorphic data types to be instances of the same typeclasses.
--   
--   All of the laws for the polymorphic typeclasses apply to their
--   monomorphic cousins. Thus, even though a <a>MonoFunctor</a> instance
--   for <a>Set</a> could theoretically be defined, it is omitted since it
--   could violate the functor law of <tt><a>omap</a> f . <a>omap</a> g =
--   <a>omap</a> (f . g)</tt>.
--   
--   Note that all typeclasses have been prefixed with <tt>Mono</tt>, and
--   functions have been prefixed with <tt>o</tt>. The mnemonic for
--   <tt>o</tt> is "only one", or alternatively "it's mono, but m is
--   overused in Haskell, so we'll use the second letter instead." (Agreed,
--   it's not a great mangling scheme, input is welcome!)
module Data.MonoTraversable

-- | Type family for getting the type of the elements of a monomorphic
--   container.

-- | Monomorphic containers that can be mapped over.
class MonoFunctor mono where omap = fmap
omap :: MonoFunctor mono => (Element mono -> Element mono) -> mono -> mono

-- | Monomorphic containers that can be folded.
class MonoFoldable mono where ofoldMap = foldMap ofoldr = foldr ofoldl' = foldl' otoList t = build (\ mono n -> ofoldr mono n t) oall f = getAll . ofoldMap (All . f) oany f = getAny . ofoldMap (Any . f) onull = oall (const False) olength = ofoldl' (\ i _ -> i + 1) 0 olength64 = ofoldl' (\ i _ -> i + 1) 0 ocompareLength c0 i0 = olength c0 `compare` fromIntegral i0 otraverse_ f = ofoldr ((*>) . f) (pure ()) ofor_ = flip otraverse_ omapM_ f = ofoldr ((>>) . f) (return ()) oforM_ = flip omapM_ ofoldlM f z0 xs = ofoldr f' return xs z0 where f' x k z = f z x >>= k ofoldMap1Ex f = fromMaybe (error "Data.MonoTraversable.ofoldMap1Ex") . getOption . ofoldMap (Option . Just . f) ofoldr1Ex = foldr1 ofoldl1Ex' = foldl1 headEx = ofoldr const (error "Data.MonoTraversable.headEx: empty") lastEx = ofoldl1Ex' (flip const) unsafeHead = headEx unsafeLast = lastEx maximumByEx f = ofoldl1Ex' go where go x y = case f x y of { LT -> y _ -> x } minimumByEx f = ofoldl1Ex' go where go x y = case f x y of { GT -> y _ -> x }
ofoldMap :: (MonoFoldable mono, Monoid m) => (Element mono -> m) -> mono -> m
ofoldr :: MonoFoldable mono => (Element mono -> b -> b) -> b -> mono -> b
ofoldl' :: MonoFoldable mono => (a -> Element mono -> a) -> a -> mono -> a
otoList :: MonoFoldable mono => mono -> [Element mono]
oall :: MonoFoldable mono => (Element mono -> Bool) -> mono -> Bool
oany :: MonoFoldable mono => (Element mono -> Bool) -> mono -> Bool
onull :: MonoFoldable mono => mono -> Bool
olength :: MonoFoldable mono => mono -> Int
olength64 :: MonoFoldable mono => mono -> Int64
ocompareLength :: (MonoFoldable mono, Integral i) => mono -> i -> Ordering
otraverse_ :: (MonoFoldable mono, MonoFoldable mono, Applicative f) => (Element mono -> f b) -> mono -> f ()
ofor_ :: (MonoFoldable mono, MonoFoldable mono, Applicative f) => mono -> (Element mono -> f b) -> f ()
omapM_ :: (MonoFoldable mono, MonoFoldable mono, Monad m) => (Element mono -> m ()) -> mono -> m ()
oforM_ :: (MonoFoldable mono, MonoFoldable mono, Monad m) => mono -> (Element mono -> m ()) -> m ()
ofoldlM :: (MonoFoldable mono, MonoFoldable mono, Monad m) => (a -> Element mono -> m a) -> a -> mono -> m a
ofoldMap1Ex :: (MonoFoldable mono, Semigroup m) => (Element mono -> m) -> mono -> m
ofoldr1Ex :: MonoFoldable mono => (Element mono -> Element mono -> Element mono) -> mono -> Element mono
ofoldl1Ex' :: MonoFoldable mono => (Element mono -> Element mono -> Element mono) -> mono -> Element mono
headEx :: MonoFoldable mono => mono -> Element mono
lastEx :: MonoFoldable mono => mono -> Element mono
unsafeHead :: MonoFoldable mono => mono -> Element mono
unsafeLast :: MonoFoldable mono => mono -> Element mono
maximumByEx :: MonoFoldable mono => (Element mono -> Element mono -> Ordering) -> mono -> Element mono
minimumByEx :: MonoFoldable mono => (Element mono -> Element mono -> Ordering) -> mono -> Element mono

-- | Safe version of <a>headEx</a>.
--   
--   Returns <a>Nothing</a> instead of throwing an exception when
--   encountering an empty monomorphic container.
headMay :: MonoFoldable mono => mono -> Maybe (Element mono)

-- | Safe version of <a>lastEx</a>.
--   
--   Returns <a>Nothing</a> instead of throwing an exception when
--   encountering an empty monomorphic container.
lastMay :: MonoFoldable mono => mono -> Maybe (Element mono)

-- | <a>osum</a> computes the sum of the numbers of a monomorphic
--   container.
osum :: (MonoFoldable mono, Num (Element mono)) => mono -> Element mono

-- | <a>oproduct</a> computes the product of the numbers of a monomorphic
--   container.
oproduct :: (MonoFoldable mono, Num (Element mono)) => mono -> Element mono

-- | Are <b>all</b> of the elements <a>True</a>?
--   
--   Since 0.6.0
oand :: (Element mono ~ Bool, MonoFoldable mono) => mono -> Bool

-- | Are <b>any</b> of the elements <a>True</a>?
--   
--   Since 0.6.0
oor :: (Element mono ~ Bool, MonoFoldable mono) => mono -> Bool

-- | A typeclass for monomorphic containers that are <a>Monoid</a>s.
class (MonoFoldable mono, Monoid mono) => MonoFoldableMonoid mono where oconcatMap = ofoldMap
oconcatMap :: MonoFoldableMonoid mono => (Element mono -> mono) -> mono -> mono

-- | A typeclass for monomorphic containers whose elements are an instance
--   of <a>Eq</a>.
class (MonoFoldable mono, Eq (Element mono)) => MonoFoldableEq mono where oelem e = elem e . otoList onotElem e = notElem e . otoList
oelem :: MonoFoldableEq mono => Element mono -> mono -> Bool
onotElem :: MonoFoldableEq mono => Element mono -> mono -> Bool

-- | A typeclass for monomorphic containers whose elements are an instance
--   of <a>Ord</a>.
class (MonoFoldable mono, Ord (Element mono)) => MonoFoldableOrd mono where maximumEx = maximumByEx compare minimumEx = minimumByEx compare
maximumEx :: MonoFoldableOrd mono => mono -> Element mono
minimumEx :: MonoFoldableOrd mono => mono -> Element mono

-- | Safe version of <a>maximumEx</a>.
--   
--   Returns <a>Nothing</a> instead of throwing an exception when
--   encountering an empty monomorphic container.
maximumMay :: MonoFoldableOrd mono => mono -> Maybe (Element mono)

-- | Safe version of <a>maximumByEx</a>.
--   
--   Returns <a>Nothing</a> instead of throwing an exception when
--   encountering an empty monomorphic container.
maximumByMay :: MonoFoldable mono => (Element mono -> Element mono -> Ordering) -> mono -> Maybe (Element mono)

-- | Safe version of <a>minimumEx</a>.
--   
--   Returns <a>Nothing</a> instead of throwing an exception when
--   encountering an empty monomorphic container.
minimumMay :: MonoFoldableOrd mono => mono -> Maybe (Element mono)

-- | Safe version of <a>minimumByEx</a>.
--   
--   Returns <a>Nothing</a> instead of throwing an exception when
--   encountering an empty monomorphic container.
minimumByMay :: MonoFoldable mono => (Element mono -> Element mono -> Ordering) -> mono -> Maybe (Element mono)

-- | Monomorphic containers that can be traversed from left to right.
class (MonoFunctor mono, MonoFoldable mono) => MonoTraversable mono where otraverse = traverse omapM = mapM
otraverse :: (MonoTraversable mono, Applicative f) => (Element mono -> f (Element mono)) -> mono -> f mono
omapM :: (MonoTraversable mono, Monad m) => (Element mono -> m (Element mono)) -> mono -> m mono

-- | <a>ofor</a> is <a>otraverse</a> with its arguments flipped.
ofor :: (MonoTraversable mono, Applicative f) => mono -> (Element mono -> f (Element mono)) -> f mono

-- | <a>oforM</a> is <a>omapM</a> with its arguments flipped.
oforM :: (MonoTraversable mono, Monad f) => mono -> (Element mono -> f (Element mono)) -> f mono

-- | A strict left fold, together with an unwrap function.
--   
--   This is convenient when the accumulator value is not the same as the
--   final expected type. It is provided mainly for integration with the
--   <tt>foldl</tt> package, to be used in conjunction with
--   <tt>purely</tt>.
--   
--   Since 0.3.1
ofoldlUnwrap :: MonoFoldable mono => (x -> Element mono -> x) -> x -> (x -> b) -> mono -> b

-- | A monadic strict left fold, together with an unwrap function.
--   
--   Similar to <tt>foldlUnwrap</tt>, but allows monadic actions. To be
--   used with <tt>impurely</tt> from <tt>foldl</tt>.
--   
--   Since 0.3.1
ofoldMUnwrap :: (Monad m, MonoFoldable mono) => (x -> Element mono -> m x) -> m x -> (x -> m b) -> mono -> m b

-- | Typeclass for monomorphic containers that an element can be lifted
--   into.
--   
--   For any <a>MonoFunctor</a>, the following law holds:
--   
--   <pre>
--   <a>omap</a> f . <a>opoint</a> = <a>opoint</a> . f
--   </pre>
class MonoPointed mono where opoint = pure
opoint :: MonoPointed mono => Element mono -> mono

-- | Typeclass for monomorphic containers where it is always okay to
--   "extract" a value from with <a>oextract</a>, and where you can
--   extrapolate any "extracting" function to be a function on the whole
--   part with <a>oextend</a>.
--   
--   <a>oextend</a> and <a>oextract</a> should work together following the
--   laws:
--   
--   <pre>
--   <a>oextend</a> <a>oextract</a>      = <a>id</a>
--   <a>oextract</a> . <a>oextend</a> f  = f
--   <a>oextend</a> f . <a>oextend</a> g = <a>oextend</a> (f . <a>oextend</a> g)
--   </pre>
--   
--   As an intuition, <tt><a>oextend</a> f</tt> uses <tt>f</tt> to "build
--   up" a new <tt>mono</tt> with pieces from the old one received by
--   <tt>f</tt>.
class MonoFunctor mono => MonoComonad mono where oextract = extract oextend = extend
oextract :: MonoComonad mono => mono -> Element mono
oextend :: MonoComonad mono => (mono -> Element mono) -> mono -> mono
instance MonoComonad (ViewR a)
instance MonoComonad (ViewL a)
instance (Comonad f, Comonad g) => MonoComonad (Coproduct f g a)
instance (Comonad w, Monoid m) => MonoComonad (TracedT m w a)
instance Comonad w => MonoComonad (StoreT s w a)
instance Comonad w => MonoComonad (EnvT e w a)
instance Comonad w => MonoComonad (IdentityT w a)
instance MonoComonad (Arg a b)
instance MonoComonad (e, a)
instance Monoid m => MonoComonad (m -> a)
instance MonoComonad (Identity a)
instance MonoComonad (NonEmpty a)
instance MonoComonad (Tree a)
instance MonoPointed (Tree a)
instance MonoPointed (ViewR a)
instance MonoPointed (ViewL a)
instance Applicative m => MonoPointed (StateT s m a)
instance Applicative m => MonoPointed (StateT s m a)
instance (Monoid w, Applicative m) => MonoPointed (RWST r w s m a)
instance (Monoid w, Applicative m) => MonoPointed (RWST r w s m a)
instance Applicative f => MonoPointed (MaybeT f a)
instance MonoPointed (MaybeApply f a)
instance Applicative m => MonoPointed (ErrorT e m a)
instance Hashable a => MonoPointed (HashSet a)
instance MonoPointed (Set a)
instance MonoPointed IntSet
instance MonoPointed (Either a b)
instance Storable a => MonoPointed (Vector a)
instance Unbox a => MonoPointed (Vector a)
instance MonoPointed (Seq a)
instance Applicative f => MonoPointed (Static f a b)
instance MonoPointed (Cokleisli w a b)
instance (Applicative f, Applicative g) => MonoPointed (Product f g a)
instance (Applicative f, Applicative g) => MonoPointed (Compose f g a)
instance MonoPointed (ContT r m a)
instance Applicative m => MonoPointed (ReaderT r m a)
instance (Monoid w, Applicative m) => MonoPointed (WriterT w m a)
instance (Monoid w, Applicative m) => MonoPointed (WriterT w m a)
instance Arrow a => MonoPointed (WrappedArrow a b c)
instance Applicative f => MonoPointed (WrappedApplicative f a)
instance Applicative m => MonoPointed (IdentityT m a)
instance Applicative m => MonoPointed (ListT m a)
instance Monad m => MonoPointed (WrappedMonad m a)
instance Monoid m => MonoPointed (Const m a)
instance Monoid a => MonoPointed (a, b)
instance MonoPointed (r -> a)
instance MonoPointed (ZipList a)
instance MonoPointed (IO a)
instance MonoPointed (DList a)
instance MonoPointed (Vector a)
instance MonoPointed (Identity a)
instance MonoPointed (NonEmpty a)
instance MonoPointed (Option a)
instance MonoPointed (Maybe a)
instance MonoPointed [a]
instance MonoPointed Text
instance MonoPointed Text
instance MonoPointed ByteString
instance MonoPointed ByteString
instance (Traversable f, Traversable g) => MonoTraversable (Product f g a)
instance (Traversable f, Traversable g) => MonoTraversable (Compose f g a)
instance Traversable f => MonoTraversable (ErrorT e f a)
instance Traversable f => MonoTraversable (WriterT w f a)
instance Traversable f => MonoTraversable (WriterT w f a)
instance Traversable f => MonoTraversable (IdentityT f a)
instance Traversable f => MonoTraversable (ListT f a)
instance Traversable f => MonoTraversable (MaybeT f a)
instance MonoTraversable (Const m a)
instance MonoTraversable (a, b)
instance MonoTraversable (Either a b)
instance Storable a => MonoTraversable (Vector a)
instance Unbox a => MonoTraversable (Vector a)
instance MonoTraversable (Vector a)
instance MonoTraversable (HashMap k v)
instance MonoTraversable (Map k v)
instance MonoTraversable (Identity a)
instance MonoTraversable (DList a)
instance MonoTraversable (NonEmpty a)
instance MonoTraversable (Option a)
instance MonoTraversable (IntMap a)
instance MonoTraversable (ViewR a)
instance MonoTraversable (ViewL a)
instance MonoTraversable (Seq a)
instance MonoTraversable (Tree a)
instance MonoTraversable (Maybe a)
instance MonoTraversable [a]
instance MonoTraversable Text
instance MonoTraversable Text
instance MonoTraversable ByteString
instance MonoTraversable ByteString
instance (Ord a, Foldable f, Foldable g) => MonoFoldableOrd (Product f g a)
instance (Ord a, Foldable f, Foldable g) => MonoFoldableOrd (Compose f g a)
instance (Ord a, Foldable f) => MonoFoldableOrd (ErrorT e f a)
instance (Ord a, Foldable f) => MonoFoldableOrd (WriterT w f a)
instance (Ord a, Foldable f) => MonoFoldableOrd (WriterT w f a)
instance (Ord a, Foldable f) => MonoFoldableOrd (IdentityT f a)
instance (Ord a, Foldable f) => MonoFoldableOrd (ListT f a)
instance (Ord a, Foldable f) => MonoFoldableOrd (MaybeT f a)
instance Ord a => MonoFoldableOrd (Const m a)
instance Ord b => MonoFoldableOrd (a, b)
instance Ord a => MonoFoldableOrd (DList a)
instance Ord b => MonoFoldableOrd (Either a b)
instance (Ord a, Storable a) => MonoFoldableOrd (Vector a)
instance (Unbox a, Ord a) => MonoFoldableOrd (Vector a)
instance Ord e => MonoFoldableOrd (HashSet e)
instance Ord e => MonoFoldableOrd (Set e)
instance Ord a => MonoFoldableOrd (Vector a)
instance Ord v => MonoFoldableOrd (HashMap k v)
instance Ord v => MonoFoldableOrd (Map k v)
instance Ord a => MonoFoldableOrd (Identity a)
instance Ord a => MonoFoldableOrd (NonEmpty a)
instance Ord a => MonoFoldableOrd (Option a)
instance Ord a => MonoFoldableOrd (IntMap a)
instance Ord a => MonoFoldableOrd (ViewR a)
instance Ord a => MonoFoldableOrd (ViewL a)
instance Ord a => MonoFoldableOrd (Seq a)
instance Ord a => MonoFoldableOrd (Tree a)
instance Ord a => MonoFoldableOrd (Maybe a)
instance Ord a => MonoFoldableOrd [a]
instance MonoFoldableOrd IntSet
instance MonoFoldableOrd Text
instance MonoFoldableOrd Text
instance MonoFoldableOrd ByteString
instance MonoFoldableOrd ByteString
instance (Eq a, Ord a) => MonoFoldableEq (Set a)
instance MonoFoldableEq ByteString
instance MonoFoldableEq ByteString
instance Eq a => MonoFoldableEq [a]
instance (Eq a, Foldable f, Foldable g) => MonoFoldableEq (Product f g a)
instance (Eq a, Foldable f, Foldable g) => MonoFoldableEq (Compose f g a)
instance (Eq a, Foldable f) => MonoFoldableEq (ErrorT e f a)
instance (Eq a, Foldable f) => MonoFoldableEq (WriterT w f a)
instance (Eq a, Foldable f) => MonoFoldableEq (WriterT w f a)
instance (Eq a, Foldable f) => MonoFoldableEq (IdentityT f a)
instance (Eq a, Foldable f) => MonoFoldableEq (ListT f a)
instance (Eq a, Foldable f) => MonoFoldableEq (MaybeT f a)
instance Eq a => MonoFoldableEq (Const m a)
instance Eq b => MonoFoldableEq (a, b)
instance Eq b => MonoFoldableEq (Either a b)
instance Eq a => MonoFoldableEq (DList a)
instance Eq a => MonoFoldableEq (HashSet a)
instance Eq v => MonoFoldableEq (HashMap k v)
instance Eq v => MonoFoldableEq (Map k v)
instance Eq a => MonoFoldableEq (Identity a)
instance Eq a => MonoFoldableEq (Option a)
instance Eq a => MonoFoldableEq (IntMap a)
instance Eq a => MonoFoldableEq (ViewR a)
instance Eq a => MonoFoldableEq (ViewL a)
instance Eq a => MonoFoldableEq (Tree a)
instance Eq a => MonoFoldableEq (Maybe a)
instance MonoFoldableEq IntSet
instance MonoFoldableEq Text
instance MonoFoldableEq Text
instance Eq a => MonoFoldableEq (NonEmpty a)
instance (Eq a, Storable a) => MonoFoldableEq (Vector a)
instance (Eq a, Unbox a) => MonoFoldableEq (Vector a)
instance Eq a => MonoFoldableEq (Vector a)
instance Eq a => MonoFoldableEq (Seq a)
instance MonoFoldableMonoid Text
instance MonoFoldableMonoid Text
instance MonoFoldableMonoid ByteString
instance MonoFoldableMonoid ByteString
instance (MonoFoldable (t a), Monoid (t a)) => MonoFoldableMonoid (t a)
instance (Foldable f, Foldable g) => MonoFoldable (Product f g a)
instance (Foldable f, Foldable g) => MonoFoldable (Compose f g a)
instance Foldable f => MonoFoldable (ErrorT e f a)
instance Foldable f => MonoFoldable (WriterT w f a)
instance Foldable f => MonoFoldable (WriterT w f a)
instance Foldable f => MonoFoldable (IdentityT f a)
instance Foldable f => MonoFoldable (ListT f a)
instance Foldable f => MonoFoldable (MaybeT f a)
instance MonoFoldable (Const m a)
instance MonoFoldable (a, b)
instance MonoFoldable (Either a b)
instance Storable a => MonoFoldable (Vector a)
instance Unbox a => MonoFoldable (Vector a)
instance MonoFoldable (DList a)
instance MonoFoldable (HashSet e)
instance MonoFoldable (Set e)
instance MonoFoldable (Vector a)
instance MonoFoldable (HashMap k v)
instance MonoFoldable (Map k v)
instance MonoFoldable (Identity a)
instance MonoFoldable (NonEmpty a)
instance MonoFoldable (Option a)
instance MonoFoldable (IntMap a)
instance MonoFoldable (ViewR a)
instance MonoFoldable (ViewL a)
instance MonoFoldable (Seq a)
instance MonoFoldable (Tree a)
instance MonoFoldable (Maybe a)
instance MonoFoldable [a]
instance MonoFoldable IntSet
instance MonoFoldable Text
instance MonoFoldable Text
instance MonoFoldable ByteString
instance MonoFoldable ByteString
instance Storable a => MonoFunctor (Vector a)
instance Unbox a => MonoFunctor (Vector a)
instance Functor f => MonoFunctor (Static f a b)
instance (Functor f, Functor g) => MonoFunctor (Product f g a)
instance (Functor f, Functor g) => MonoFunctor (Compose f g a)
instance Functor m => MonoFunctor (ContT r m a)
instance Functor m => MonoFunctor (ErrorT e m a)
instance Functor m => MonoFunctor (ReaderT r m a)
instance Functor m => MonoFunctor (RWST r w s m a)
instance Functor m => MonoFunctor (RWST r w s m a)
instance Functor m => MonoFunctor (StateT s m a)
instance Functor m => MonoFunctor (StateT s m a)
instance Functor m => MonoFunctor (WriterT w m a)
instance Functor m => MonoFunctor (WriterT w m a)
instance Functor m => MonoFunctor (IdentityT m a)
instance Functor m => MonoFunctor (ListT m a)
instance Functor m => MonoFunctor (MaybeT m a)
instance MonoFunctor (Cokleisli w a b)
instance Functor f => MonoFunctor (WrappedApplicative f a)
instance Functor f => MonoFunctor (MaybeApply f a)
instance Arrow a => MonoFunctor (WrappedArrow a b c)
instance (Functor f, Functor g) => MonoFunctor (Coproduct f g a)
instance Functor w => MonoFunctor (TracedT m w a)
instance Functor w => MonoFunctor (StoreT s w a)
instance Functor w => MonoFunctor (EnvT e w a)
instance MonoFunctor (Arg a b)
instance MonoFunctor (Vector a)
instance MonoFunctor (HashMap k v)
instance MonoFunctor (Map k v)
instance Monad m => MonoFunctor (WrappedMonad m a)
instance MonoFunctor (Const m a)
instance MonoFunctor (a, b)
instance MonoFunctor (Either a b)
instance MonoFunctor (r -> a)
instance MonoFunctor (Identity a)
instance MonoFunctor (NonEmpty a)
instance MonoFunctor (Option a)
instance MonoFunctor (IntMap a)
instance MonoFunctor (ViewR a)
instance MonoFunctor (ViewL a)
instance MonoFunctor (DList a)
instance MonoFunctor (Seq a)
instance MonoFunctor (Tree a)
instance MonoFunctor (Maybe a)
instance MonoFunctor (ZipList a)
instance MonoFunctor (IO a)
instance MonoFunctor [a]
instance MonoFunctor Text
instance MonoFunctor Text
instance MonoFunctor ByteString
instance MonoFunctor ByteString


-- | Warning: This module should be considered highly experimental.
module Data.Containers

-- | A container whose values are stored in Key-Value pairs.
class (Monoid set, Semigroup set, MonoFoldable set, Eq (ContainerKey set), GrowingAppend set) => SetContainer set where type family ContainerKey set
member :: SetContainer set => ContainerKey set -> set -> Bool
notMember :: SetContainer set => ContainerKey set -> set -> Bool
union :: SetContainer set => set -> set -> set
difference :: SetContainer set => set -> set -> set
intersection :: SetContainer set => set -> set -> set
keys :: SetContainer set => set -> [ContainerKey set]

-- | This instance uses the functions from <a>Data.Map.Strict</a>.

-- | This instance uses the functions from <a>Data.HashMap.Strict</a>.

-- | This instance uses the functions from <a>Data.IntMap.Strict</a>.

-- | A guaranteed-polymorphic <tt>Map</tt>, which allows for more
--   polymorphic versions of functions.
class PolyMap map
differenceMap :: PolyMap map => map value1 -> map value2 -> map value1
intersectionMap :: PolyMap map => map value1 -> map value2 -> map value1
intersectionWithMap :: PolyMap map => (value1 -> value2 -> value3) -> map value1 -> map value2 -> map value3

-- | This instance uses the functions from <a>Data.Map.Strict</a>.

-- | This instance uses the functions from <a>Data.HashMap.Strict</a>.

-- | This instance uses the functions from <a>Data.IntMap.Strict</a>.

-- | A <tt>Map</tt> type polymorphic in both its key and value.
class BiPolyMap map where type family BPMKeyConstraint map key :: Constraint
mapKeysWith :: (BiPolyMap map, BPMKeyConstraint map k1, BPMKeyConstraint map k2) => (v -> v -> v) -> (k1 -> k2) -> map k1 v -> map k2 v

-- | Polymorphic typeclass for interacting with different map types
class (MonoTraversable map, SetContainer map) => IsMap map where type family MapValue map findWithDefault def key = fromMaybe def . lookup key insertWith f k v m = v' `seq` insertMap k v' m where v' = case lookup k m of { Nothing -> v Just vold -> f v vold } insertWithKey f k v m = v' `seq` insertMap k v' m where v' = case lookup k m of { Nothing -> v Just vold -> f k v vold } insertLookupWithKey f k v m = v' `seq` (mold, insertMap k v' m) where (mold, v') = case lookup k m of { Nothing -> (Nothing, v) Just vold -> (Just vold, f k v vold) } adjustMap f k m = case lookup k m of { Nothing -> m Just v -> let v' = f v in v' `seq` insertMap k v' m } adjustWithKey f k m = case lookup k m of { Nothing -> m Just v -> let v' = f k v in v' `seq` insertMap k v' m } updateMap f k m = case lookup k m of { Nothing -> m Just v -> case f v of { Nothing -> deleteMap k m Just v' -> v' `seq` insertMap k v' m } } updateWithKey f k m = case lookup k m of { Nothing -> m Just v -> case f k v of { Nothing -> deleteMap k m Just v' -> v' `seq` insertMap k v' m } } updateLookupWithKey f k m = case lookup k m of { Nothing -> (Nothing, m) Just v -> case f k v of { Nothing -> (Just v, deleteMap k m) Just v' -> v' `seq` (Just v', insertMap k v' m) } } alterMap f k m = case f mold of { Nothing -> case mold of { Nothing -> m Just _ -> deleteMap k m } Just v -> insertMap k v m } where mold = lookup k m unionWith f x y = mapFromList $ loop $ mapToList x ++ mapToList y where loop [] = [] loop ((k, v) : rest) = case lookup k rest of { Nothing -> (k, v) : loop rest Just v' -> (k, f v v') : loop (deleteMap k rest) } unionWithKey f x y = mapFromList $ loop $ mapToList x ++ mapToList y where loop [] = [] loop ((k, v) : rest) = case lookup k rest of { Nothing -> (k, v) : loop rest Just v' -> (k, f k v v') : loop (deleteMap k rest) } unionsWith _ [] = mempty unionsWith _ [x] = x unionsWith f (x : y : z) = unionsWith f (unionWith f x y : z) mapWithKey f = mapFromList . map go . mapToList where go (k, v) = (k, f k v) omapKeysWith g f = mapFromList . unionsWith g . map go . mapToList where go (k, v) = [(f k, v)]
lookup :: IsMap map => ContainerKey map -> map -> Maybe (MapValue map)
insertMap :: IsMap map => ContainerKey map -> MapValue map -> map -> map
deleteMap :: IsMap map => ContainerKey map -> map -> map
singletonMap :: IsMap map => ContainerKey map -> MapValue map -> map
mapFromList :: IsMap map => [(ContainerKey map, MapValue map)] -> map
mapToList :: IsMap map => map -> [(ContainerKey map, MapValue map)]
findWithDefault :: IsMap map => MapValue map -> ContainerKey map -> map -> MapValue map
insertWith :: IsMap map => (MapValue map -> MapValue map -> MapValue map) -> ContainerKey map -> MapValue map -> map -> map
insertWithKey :: IsMap map => (ContainerKey map -> MapValue map -> MapValue map -> MapValue map) -> ContainerKey map -> MapValue map -> map -> map
insertLookupWithKey :: IsMap map => (ContainerKey map -> MapValue map -> MapValue map -> MapValue map) -> ContainerKey map -> MapValue map -> map -> (Maybe (MapValue map), map)
adjustMap :: IsMap map => (MapValue map -> MapValue map) -> ContainerKey map -> map -> map
adjustWithKey :: IsMap map => (ContainerKey map -> MapValue map -> MapValue map) -> ContainerKey map -> map -> map
updateMap :: IsMap map => (MapValue map -> Maybe (MapValue map)) -> ContainerKey map -> map -> map
updateWithKey :: IsMap map => (ContainerKey map -> MapValue map -> Maybe (MapValue map)) -> ContainerKey map -> map -> map
updateLookupWithKey :: IsMap map => (ContainerKey map -> MapValue map -> Maybe (MapValue map)) -> ContainerKey map -> map -> (Maybe (MapValue map), map)
alterMap :: IsMap map => (Maybe (MapValue map) -> Maybe (MapValue map)) -> ContainerKey map -> map -> map
unionWith :: IsMap map => (MapValue map -> MapValue map -> MapValue map) -> map -> map -> map
unionWithKey :: IsMap map => (ContainerKey map -> MapValue map -> MapValue map -> MapValue map) -> map -> map -> map
unionsWith :: IsMap map => (MapValue map -> MapValue map -> MapValue map) -> [map] -> map
mapWithKey :: IsMap map => (ContainerKey map -> MapValue map -> MapValue map) -> map -> map
omapKeysWith :: IsMap map => (MapValue map -> MapValue map -> MapValue map) -> (ContainerKey map -> ContainerKey map) -> map -> map

-- | This instance uses the functions from <a>Data.Map.Strict</a>.

-- | This instance uses the functions from <a>Data.HashMap.Strict</a>.

-- | This instance uses the functions from <a>Data.IntMap.Strict</a>.

-- | Polymorphic typeclass for interacting with different set types
class (SetContainer set, Element set ~ ContainerKey set) => IsSet set
insertSet :: IsSet set => Element set -> set -> set
deleteSet :: IsSet set => Element set -> set -> set
singletonSet :: IsSet set => Element set -> set
setFromList :: IsSet set => [Element set] -> set
setToList :: IsSet set => set -> [Element set]

-- | Zip operations on <a>MonoFunctor</a>s.
class MonoFunctor mono => MonoZip mono
ozipWith :: MonoZip mono => (Element mono -> Element mono -> Element mono) -> mono -> mono -> mono
ozip :: MonoZip mono => mono -> mono -> [(Element mono, Element mono)]
ounzip :: MonoZip mono => [(Element mono, Element mono)] -> (mono, mono)

-- | Type class for maps whose keys can be converted into sets.
class SetContainer set => HasKeysSet set where type family KeySet set
keysSet :: HasKeysSet set => set -> KeySet set
instance (Hashable k, Eq k) => HasKeysSet (HashMap k v)
instance HasKeysSet (IntMap v)
instance Ord k => HasKeysSet (Map k v)
instance MonoZip Text
instance MonoZip Text
instance MonoZip ByteString
instance MonoZip ByteString
instance IsSet IntSet
instance (Eq element, Hashable element) => IsSet (HashSet element)
instance Ord element => IsSet (Set element)
instance Eq key => IsMap [(key, value)]
instance IsMap (IntMap value)
instance (Eq key, Hashable key) => IsMap (HashMap key value)
instance Ord key => IsMap (Map key value)
instance BiPolyMap HashMap
instance BiPolyMap Map
instance PolyMap IntMap
instance (Eq key, Hashable key) => PolyMap (HashMap key)
instance Ord key => PolyMap (Map key)
instance Eq key => SetContainer [(key, value)]
instance SetContainer IntSet
instance (Eq element, Hashable element) => SetContainer (HashSet element)
instance Ord element => SetContainer (Set element)
instance SetContainer (IntMap value)
instance (Eq key, Hashable key) => SetContainer (HashMap key value)
instance Ord k => SetContainer (Map k v)


-- | Warning: This module should be considered highly experimental.
module Data.Sequences

-- | <a>SemiSequence</a> was created to share code between
--   <a>IsSequence</a> and <tt>MinLen</tt>.
--   
--   <tt>Semi</tt> means <tt>SemiGroup</tt> A <a>SemiSequence</a> can
--   accomodate a <tt>SemiGroup</tt> such as <tt>NonEmpty</tt> or
--   <tt>MinLen</tt> A Monoid should be able to fill out <a>IsSequence</a>.
--   
--   <a>SemiSequence</a> operations maintain the same type because they all
--   maintain the same number of elements or increase them. However, a
--   decreasing function such as filter may change they type. For example,
--   from <tt>NonEmpty</tt> to '[]' This type-changing function exists on
--   <tt>NonNull</tt> as <tt>nfilter</tt>
--   
--   <a>filter</a> and other such functions are placed in <a>IsSequence</a>
class (Integral (Index seq), GrowingAppend seq) => SemiSequence seq where type family Index seq
intersperse :: SemiSequence seq => Element seq -> seq -> seq
reverse :: SemiSequence seq => seq -> seq
find :: SemiSequence seq => (Element seq -> Bool) -> seq -> Maybe (Element seq)
sortBy :: SemiSequence seq => (Element seq -> Element seq -> Ordering) -> seq -> seq
cons :: SemiSequence seq => Element seq -> seq -> seq
snoc :: SemiSequence seq => seq -> Element seq -> seq

-- | Create a sequence from a single element.
--   
--   <pre>
--   &gt; <a>singleton</a> <tt>a</tt> :: <tt>String</tt>
--   "a"
--   &gt; <a>singleton</a> <tt>a</tt> :: <tt>Vector</tt> <a>Char</a>
--   <a>fromList</a> "a"
--   </pre>
singleton :: IsSequence seq => Element seq -> seq

-- | Sequence Laws:
--   
--   <pre>
--   <a>fromList</a> . <a>otoList</a> = <a>id</a>
--   <a>fromList</a> (x &lt;&gt; y) = <a>fromList</a> x &lt;&gt; <a>fromList</a> y
--   <a>otoList</a> (<a>fromList</a> x &lt;&gt; <a>fromList</a> y) = x &lt;&gt; y
--   </pre>
class (Monoid seq, MonoTraversable seq, SemiSequence seq, MonoPointed seq) => IsSequence seq where fromList = mconcat . fmap singleton break f = (fromList *** fromList) . break f . otoList span f = (fromList *** fromList) . span f . otoList dropWhile f = fromList . dropWhile f . otoList takeWhile f = fromList . takeWhile f . otoList splitAt i = (fromList *** fromList) . genericSplitAt i . otoList unsafeSplitAt i seq = (unsafeTake i seq, unsafeDrop i seq) take i = fst . splitAt i unsafeTake = take drop i = snd . splitAt i unsafeDrop = drop partition f = (fromList *** fromList) . partition f . otoList uncons = fmap (second fromList) . uncons . otoList unsnoc = fmap (first fromList) . unsnoc . otoList filter f = fromList . filter f . otoList filterM f = liftM fromList . filterM f . otoList replicate i = fromList . genericReplicate i replicateM i = liftM fromList . replicateM (fromIntegral i) groupBy f = fmap fromList . groupBy f . otoList groupAllOn f = fmap fromList . groupAllOn f . otoList subsequences = map fromList . subsequences . otoList permutations = map fromList . permutations . otoList tailEx = snd . maybe (error "Data.Sequences.tailEx") id . uncons initEx = fst . maybe (error "Data.Sequences.initEx") id . unsnoc unsafeTail = tailEx unsafeInit = initEx index seq' idx = headMay (drop idx seq') indexEx seq' idx = maybe (error "Data.Sequences.indexEx") id (index seq' idx) unsafeIndex = indexEx
fromList :: IsSequence seq => [Element seq] -> seq
break :: IsSequence seq => (Element seq -> Bool) -> seq -> (seq, seq)
span :: IsSequence seq => (Element seq -> Bool) -> seq -> (seq, seq)
dropWhile :: IsSequence seq => (Element seq -> Bool) -> seq -> seq
takeWhile :: IsSequence seq => (Element seq -> Bool) -> seq -> seq
splitAt :: IsSequence seq => Index seq -> seq -> (seq, seq)
unsafeSplitAt :: IsSequence seq => Index seq -> seq -> (seq, seq)
take :: IsSequence seq => Index seq -> seq -> seq
unsafeTake :: IsSequence seq => Index seq -> seq -> seq
drop :: IsSequence seq => Index seq -> seq -> seq
unsafeDrop :: IsSequence seq => Index seq -> seq -> seq
partition :: IsSequence seq => (Element seq -> Bool) -> seq -> (seq, seq)
uncons :: IsSequence seq => seq -> Maybe (Element seq, seq)
unsnoc :: IsSequence seq => seq -> Maybe (seq, Element seq)
filter :: IsSequence seq => (Element seq -> Bool) -> seq -> seq
filterM :: (IsSequence seq, Monad m) => (Element seq -> m Bool) -> seq -> m seq
replicate :: IsSequence seq => Index seq -> Element seq -> seq
replicateM :: (IsSequence seq, Monad m) => Index seq -> m (Element seq) -> m seq
groupBy :: IsSequence seq => (Element seq -> Element seq -> Bool) -> seq -> [seq]
groupAllOn :: (IsSequence seq, Eq b) => (Element seq -> b) -> seq -> [seq]
subsequences :: IsSequence seq => seq -> [seq]
permutations :: IsSequence seq => seq -> [seq]
tailEx :: IsSequence seq => seq -> seq
initEx :: IsSequence seq => seq -> seq
unsafeTail :: IsSequence seq => seq -> seq
unsafeInit :: IsSequence seq => seq -> seq
index :: IsSequence seq => seq -> Index seq -> Maybe (Element seq)
indexEx :: IsSequence seq => seq -> Index seq -> Element seq
unsafeIndex :: IsSequence seq => seq -> Index seq -> Element seq

-- | Use <a>Data.List</a>'s implementation of <a>find</a>.
defaultFind :: MonoFoldable seq => (Element seq -> Bool) -> seq -> Maybe (Element seq)

-- | Use <a>Data.List</a>'s implementation of <a>intersperse</a>.
defaultIntersperse :: IsSequence seq => Element seq -> seq -> seq

-- | Use <a>Data.List</a>'s implementation of <a>reverse</a>.
defaultReverse :: IsSequence seq => seq -> seq

-- | Use <a>Data.List</a>'s implementation of <a>sortBy</a>.
defaultSortBy :: IsSequence seq => (Element seq -> Element seq -> Ordering) -> seq -> seq

-- | Sort a vector using an supplied element ordering function.
vectorSortBy :: Vector v e => (e -> e -> Ordering) -> v e -> v e

-- | Sort a vector.
vectorSort :: (Vector v e, Ord e) => v e -> v e

-- | Use <a>Data.List</a>'s <a>:</a> to prepend an element to a sequence.
defaultCons :: IsSequence seq => Element seq -> seq -> seq

-- | Use <a>Data.List</a>'s <a>++</a> to append an element to a sequence.
defaultSnoc :: IsSequence seq => seq -> Element seq -> seq

-- | like Data.List.tail, but an input of <a>mempty</a> returns
--   <a>mempty</a>
tailDef :: IsSequence seq => seq -> seq

-- | like Data.List.init, but an input of <a>mempty</a> returns
--   <a>mempty</a>
initDef :: IsSequence seq => seq -> seq

-- | A typeclass for sequences whose elements have the <a>Eq</a> typeclass
class (MonoFoldableEq seq, IsSequence seq, Eq (Element seq)) => EqSequence seq where stripPrefix x y = fmap fromList (otoList x `stripPrefix` otoList y) stripSuffix x y = fmap fromList (otoList x `stripSuffix` otoList y) isPrefixOf x y = otoList x `isPrefixOf` otoList y isSuffixOf x y = otoList x `isSuffixOf` otoList y isInfixOf x y = otoList x `isInfixOf` otoList y group = groupBy (==) groupAll = groupAllOn id
stripPrefix :: EqSequence seq => seq -> seq -> Maybe seq
stripSuffix :: EqSequence seq => seq -> seq -> Maybe seq
isPrefixOf :: EqSequence seq => seq -> seq -> Bool
isSuffixOf :: EqSequence seq => seq -> seq -> Bool
isInfixOf :: EqSequence seq => seq -> seq -> Bool
group :: EqSequence seq => seq -> [seq]
groupAll :: EqSequence seq => seq -> [seq]

-- | <i>Deprecated: use oelem</i>
elem :: EqSequence seq => Element seq -> seq -> Bool

-- | <i>Deprecated: use onotElem</i>
notElem :: EqSequence seq => Element seq -> seq -> Bool

-- | A typeclass for sequences whose elements have the <a>Ord</a> typeclass
class (EqSequence seq, MonoFoldableOrd seq) => OrdSequence seq where sort = fromList . sort . otoList
sort :: OrdSequence seq => seq -> seq

-- | A typeclass for sequences whose elements are <a>Char</a>s.
class (IsSequence t, IsString t, Element t ~ Char) => Textual t where breakWord = fmap (dropWhile isSpace) . break isSpace breakLine = (killCR *** drop 1) . break (== '\n') where killCR t = case unsnoc t of { Just (t', '\r') -> t' _ -> t }
words :: Textual t => t -> [t]
unwords :: Textual t => [t] -> t
lines :: Textual t => t -> [t]
unlines :: Textual t => [t] -> t
toLower :: Textual t => t -> t
toUpper :: Textual t => t -> t
toCaseFold :: Textual t => t -> t
breakWord :: Textual t => t -> (t, t)
breakLine :: Textual t => t -> (t, t)

-- | Takes all of the <a>Just</a> values from a sequence of <tt>Maybe
--   t</tt>s and concatenates them into an unboxed sequence of <tt>t</tt>s.
--   
--   Since 0.6.2
catMaybes :: (IsSequence (f (Maybe t)), Functor f, Element (f (Maybe t)) ~ Maybe t) => f (Maybe t) -> f t

-- | Same as <tt>sortBy . comparing</tt>.
--   
--   Since 0.7.0
sortOn :: (Ord o, SemiSequence seq) => (Element seq -> o) -> seq -> seq
instance Textual Text
instance Textual Text
instance c ~ Char => Textual [c]
instance (Ord a, Storable a) => OrdSequence (Vector a)
instance (Ord a, Unbox a) => OrdSequence (Vector a)
instance Ord a => OrdSequence (Vector a)
instance Ord a => OrdSequence (Seq a)
instance OrdSequence Text
instance OrdSequence Text
instance OrdSequence ByteString
instance OrdSequence ByteString
instance Ord a => OrdSequence [a]
instance (Eq a, Storable a) => EqSequence (Vector a)
instance (Eq a, Unbox a) => EqSequence (Vector a)
instance Eq a => EqSequence (Vector a)
instance Eq a => EqSequence (Seq a)
instance EqSequence Text
instance EqSequence Text
instance EqSequence ByteString
instance EqSequence ByteString
instance Eq a => EqSequence [a]
instance Storable a => IsSequence (Vector a)
instance Storable a => SemiSequence (Vector a)
instance Unbox a => IsSequence (Vector a)
instance Unbox a => SemiSequence (Vector a)
instance IsSequence (Vector a)
instance SemiSequence (Vector a)
instance IsSequence (DList a)
instance SemiSequence (DList a)
instance IsSequence (Seq a)
instance SemiSequence (Seq a)
instance IsSequence Text
instance SemiSequence Text
instance IsSequence ByteString
instance SemiSequence ByteString
instance IsSequence Text
instance SemiSequence Text
instance IsSequence ByteString
instance SemiSequence ByteString
instance SemiSequence (NonEmpty a)
instance IsSequence [a]
instance SemiSequence [a]

module Data.MinLen

-- | <a>Zero</a> is the base value for the Peano numbers.
data Zero
Zero :: Zero

-- | <a>Succ</a> represents the next number in the sequence of natural
--   numbers.
--   
--   It takes a <tt>nat</tt> (a natural number) as an argument.
--   
--   <a>Zero</a> is a <tt>nat</tt>, allowing <tt><a>Succ</a>
--   <a>Zero</a></tt> to represent 1.
--   
--   <a>Succ</a> is also a <tt>nat</tt>, so it can be applied to itself,
--   allowing <tt><a>Succ</a> (<a>Succ</a> <a>Zero</a>)</tt> to represent
--   2, <tt><a>Succ</a> (<a>Succ</a> (<a>Succ</a> <a>Zero</a>))</tt> to
--   represent 3, and so on.
data Succ nat
Succ :: nat -> Succ nat

-- | Type-level natural number utility typeclass
class TypeNat nat
toValueNat :: (TypeNat nat, Num i) => nat -> i
typeNat :: TypeNat nat => nat

-- | Adds two type-level naturals.
--   
--   See the <a>mlappend</a> type signature for an example.
--   
--   <pre>
--   &gt; :t <a>typeNat</a> :: <a>AddNat</a> (<a>Succ</a> (<a>Succ</a> <a>Zero</a>)) (<a>Succ</a> <a>Zero</a>)
--   
--   <a>typeNat</a> :: <a>AddNat</a> (<a>Succ</a> (<a>Succ</a> <a>Zero</a>)) (<a>Succ</a> <a>Zero</a>)
--     :: <a>Succ</a> (<a>Succ</a> (<a>Succ</a> <a>Zero</a>))
--   </pre>

-- | Calculates the maximum of two type-level naturals.
--   
--   See the <a>mlunion</a> type signature for an example.
--   
--   <pre>
--   &gt; :t <a>typeNat</a> :: <a>MaxNat</a> (<a>Succ</a> (<a>Succ</a> <a>Zero</a>)) (<a>Succ</a> <a>Zero</a>)
--   
--   <a>typeNat</a> :: <a>MaxNat</a> (<a>Succ</a> (<a>Succ</a> <a>Zero</a>)) (<a>Succ</a> <a>Zero</a>)
--     :: <a>Succ</a> (<a>Succ</a> <a>Zero</a>)
--   </pre>

-- | A wrapper around a container which encodes its minimum length in the
--   type system. This allows functions like <a>head</a> and <a>maximum</a>
--   to be made safe without using <a>Maybe</a>.
--   
--   The length, <tt>nat</tt>, is encoded as a <a>Peano number</a>, which
--   starts with the <a>Zero</a> constructor and is made one larger with
--   each application of <a>Succ</a> (<a>Zero</a> for 0, <tt><a>Succ</a>
--   <a>Zero</a></tt> for 1, <tt><a>Succ</a> (<a>Succ</a> <a>Zero</a>)</tt>
--   for 2, etc.). Functions which require at least one element, then, are
--   typed with <tt>Succ nat</tt>, where <tt>nat</tt> is either <a>Zero</a>
--   or any number of applications of <a>Succ</a>:
--   
--   <pre>
--   <a>head</a> :: <a>MonoTraversable</a> mono =&gt; <a>MinLen</a> (<a>Succ</a> nat) mono -&gt; <a>Element</a> mono
--   </pre>
--   
--   The length is also a <a>phantom type</a>, i.e. it is only used on the
--   left hand side of the type and doesn't exist at runtime. Notice how
--   <tt><a>Succ</a> <a>Zero</a></tt> isn't included in the printed output:
--   
--   <pre>
--   &gt; <a>toMinLen</a> [1,2,3] :: <a>Maybe</a> (<a>MinLen</a> (<a>Succ</a> <a>Zero</a>) [<a>Int</a>])
--   <a>Just</a> (<a>MinLen</a> {unMinLen = [1,2,3]})
--   </pre>
--   
--   You can still use GHCI's <tt>:i</tt> command to see the phantom type
--   information:
--   
--   <pre>
--   &gt; let xs = <a>mlcons</a> 1 $ <a>toMinLenZero</a> []
--   &gt; :i xs
--   xs :: <a>Num</a> t =&gt; <a>MinLen</a> (<a>Succ</a> <a>Zero</a>) [t]
--   </pre>
data MinLen nat mono

-- | Get the monomorphic container out of a <a>MinLen</a> wrapper.
unMinLen :: MinLen nat mono -> mono

-- | Types a container as having a minimum length of zero. This is useful
--   when combined with other <a>MinLen</a> functions that increase the
--   size of the container.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; 1 `mlcons` <a>toMinLenZero</a> []
--   <a>MinLen</a> {unMinLen = [1]}
--   </pre>
toMinLenZero :: MonoFoldable mono => mono -> MinLen Zero mono

-- | Attempts to add a <a>MinLen</a> constraint to a monomorphic container.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = <a>toMinLen</a> [1,2,3] :: <a>Maybe</a> (<a>MinLen</a> (<a>Succ</a> <a>Zero</a>) [<a>Int</a>])
--   &gt; xs
--   <a>Just</a> (<a>MinLen</a> {unMinLen = [1,2,3]})
--   
--   &gt; :i xs
--   xs :: <a>Maybe</a> (<a>MinLen</a> (<a>Succ</a> <a>Zero</a>) [<a>Int</a>])
--   </pre>
--   
--   <pre>
--   &gt; <a>toMinLen</a> [] :: <a>Maybe</a> (<a>MinLen</a> (<a>Succ</a> <a>Zero</a>) [<a>Int</a>])
--   <a>Nothing</a>
--   </pre>
toMinLen :: (MonoFoldable mono, TypeNat nat) => mono -> Maybe (MinLen nat mono)

-- | <b>Unsafe</b>
--   
--   Although this function itself cannot cause a segfault, it breaks the
--   safety guarantees of <a>MinLen</a> and can lead to a segfault when
--   using otherwise safe functions.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = <a>unsafeToMinLen</a> [] :: <a>MinLen</a> (<a>Succ</a> <a>Zero</a>) [<a>Int</a>]
--   &gt; <a>olength</a> xs
--   0
--   &gt; <a>head</a> xs
--   *** Exception: Data.MonoTraversable.headEx: empty
--   </pre>
unsafeToMinLen :: mono -> MinLen nat mono

-- | Adds an element to the front of a list, increasing its minimum length
--   by 1.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = <a>unsafeToMinLen</a> [1,2,3] :: <a>MinLen</a> (<a>Succ</a> <a>Zero</a>) [<a>Int</a>]
--   &gt; 0 `mlcons` xs
--   <a>MinLen</a> {unMinLen = [0,1,2,3]}
--   </pre>
mlcons :: IsSequence seq => Element seq -> MinLen nat seq -> MinLen (Succ nat) seq

-- | Concatenate two sequences, adding their minimum lengths together.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = <a>unsafeToMinLen</a> [1,2,3] :: <a>MinLen</a> (<a>Succ</a> <a>Zero</a>) [<a>Int</a>]
--   &gt; xs `mlappend` xs
--   <a>MinLen</a> {unMinLen = [1,2,3,1,2,3]}
--   </pre>
mlappend :: IsSequence seq => MinLen x seq -> MinLen y seq -> MinLen (AddNat x y) seq

-- | Joins two semigroups, keeping the larger <a>MinLen</a> of the two.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = <a>unsafeToMinLen</a> [1] :: <a>MinLen</a> (<a>Succ</a> <a>Zero</a>) [<a>Int</a>]
--   &gt; let ys = xs `mlunion` xs
--   &gt; ys
--   <a>MinLen</a> {unMinLen = [1,1]}
--   
--   &gt; :i ys
--   ys :: <a>MinLen</a> (<a>Succ</a> <a>Zero</a>) [<a>Int</a>]
--   </pre>
mlunion :: GrowingAppend mono => MinLen x mono -> MinLen y mono -> MinLen (MaxNat x y) mono

-- | Return the first element of a monomorphic container.
--   
--   Safe version of <a>headEx</a>, only works on monomorphic containers
--   wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
head :: MonoFoldable mono => MinLen (Succ nat) mono -> Element mono

-- | Return the last element of a monomorphic container.
--   
--   Safe version of <a>lastEx</a>, only works on monomorphic containers
--   wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
last :: MonoFoldable mono => MinLen (Succ nat) mono -> Element mono

-- | Returns all but the first element of a sequence, reducing its
--   <a>MinLen</a> by 1.
--   
--   Safe, only works on sequences wrapped in a <tt><a>MinLen</a>
--   (<a>Succ</a> nat)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = <a>toMinLen</a> [1,2,3] :: <a>Maybe</a> (<a>MinLen</a> (<a>Succ</a> <a>Zero</a>) [<a>Int</a>])
--   &gt; <a>fmap</a> <a>tailML</a> xs
--   <a>Just</a> (<a>MinLen</a> {unMinLen = [2,3]})
--   </pre>
tailML :: IsSequence seq => MinLen (Succ nat) seq -> MinLen nat seq

-- | Returns all but the last element of a sequence, reducing its
--   <a>MinLen</a> by 1.
--   
--   Safe, only works on sequences wrapped in a <tt><a>MinLen</a>
--   (<a>Succ</a> nat)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = <a>toMinLen</a> [1,2,3] :: <a>Maybe</a> (<a>MinLen</a> (<a>Succ</a> <a>Zero</a>) [<a>Int</a>])
--   &gt; <a>fmap</a> <a>initML</a> xs
--   <a>Just</a> (<a>MinLen</a> {unMinLen = [1,2]})
--   </pre>
initML :: IsSequence seq => MinLen (Succ nat) seq -> MinLen nat seq

-- | olength (x &lt;&gt; y) &gt;= olength x + olength y
class (Semigroup mono, MonoFoldable mono) => GrowingAppend mono

-- | Map each element of a monomorphic container to a semigroup, and
--   combine the results.
--   
--   Safe version of <a>ofoldMap1Ex</a>, only works on monomorphic
--   containers wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = ("hello", 1 :: <tt>Integer</tt>) `mlcons` (" world", 2) `mlcons` (<a>toMinLenZero</a> [])
--   &gt; <a>ofoldMap1</a> <tt>fst</tt> xs
--   "hello world"
--   </pre>
ofoldMap1 :: (MonoFoldable mono, Semigroup m) => (Element mono -> m) -> MinLen (Succ nat) mono -> m

-- | Join a monomorphic container, whose elements are <a>Semigroup</a>s,
--   together.
--   
--   Safe, only works on monomorphic containers wrapped in a
--   <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = "a" `mlcons` "b" `mlcons` "c" `mlcons` (<a>toMinLenZero</a> [])
--   &gt; xs
--   <a>MinLen</a> {unMinLen = ["a","b","c"]}
--   
--   &gt; <a>ofold1</a> xs
--   "abc"
--   </pre>
ofold1 :: (MonoFoldable mono, Semigroup (Element mono)) => MinLen (Succ nat) mono -> Element mono

-- | Right-associative fold of a monomorphic container with no base
--   element.
--   
--   Safe version of <a>ofoldr1Ex</a>, only works on monomorphic containers
--   wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
--   
--   <pre>
--   <tt>foldr1</tt> f = <a>Prelude</a>.<a>foldr1</a> f . <a>otoList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = "a" `mlcons` "b" `mlcons` "c" `mlcons` (<a>toMinLenZero</a> [])
--   &gt; <a>ofoldr1</a> (++) xs
--   "abc"
--   </pre>
ofoldr1 :: MonoFoldable mono => (Element mono -> Element mono -> Element mono) -> MinLen (Succ nat) mono -> Element mono

-- | Strict left-associative fold of a monomorphic container with no base
--   element.
--   
--   Safe version of <a>ofoldl1Ex'</a>, only works on monomorphic
--   containers wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
--   
--   <pre>
--   <tt>foldl1'</tt> f = <a>Prelude</a>.<a>foldl1'</a> f . <a>otoList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = "a" `mlcons` "b" `mlcons` "c" `mlcons` (<a>toMinLenZero</a> [])
--   &gt; <a>ofoldl1'</a> (++) xs
--   "abc"
--   </pre>
ofoldl1' :: MonoFoldable mono => (Element mono -> Element mono -> Element mono) -> MinLen (Succ nat) mono -> Element mono

-- | Get the maximum element of a monomorphic container.
--   
--   Safe version of <a>maximumEx</a>, only works on monomorphic containers
--   wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = <a>toMinLen</a> [1,2,3] :: <a>Maybe</a> (<a>MinLen</a> (<a>Succ</a> <a>Zero</a>) [<a>Int</a>])
--   &gt; <a>fmap</a> <a>maximum</a> xs
--   <a>Just</a> 3
--   </pre>
maximum :: MonoFoldableOrd mono => MinLen (Succ nat) mono -> Element mono

-- | Get the minimum element of a monomorphic container.
--   
--   Safe version of <a>minimumEx</a>, only works on monomorphic containers
--   wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = <a>toMinLen</a> [1,2,3] :: <a>Maybe</a> (<a>MinLen</a> (<a>Succ</a> <a>Zero</a>) [<a>Int</a>])
--   &gt; <a>fmap</a> <a>minimum</a> xs
--   <a>Just</a> 1
--   </pre>
minimum :: MonoFoldableOrd mono => MinLen (Succ nat) mono -> Element mono

-- | Get the maximum element of a monomorphic container, using a supplied
--   element ordering function.
--   
--   Safe version of <a>maximumByEx</a>, only works on monomorphic
--   containers wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
maximumBy :: MonoFoldable mono => (Element mono -> Element mono -> Ordering) -> MinLen (Succ nat) mono -> Element mono

-- | Get the minimum element of a monomorphic container, using a supplied
--   element ordering function.
--   
--   Safe version of <a>minimumByEx</a>, only works on monomorphic
--   containers wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
minimumBy :: MonoFoldable mono => (Element mono -> Element mono -> Ordering) -> MinLen (Succ nat) mono -> Element mono
instance Typeable MinLen
instance GrowingAppend mono => GrowingAppend (MinLen nat mono)
instance MonoFoldableOrd mono => MonoFoldableOrd (MinLen nat mono)
instance MonoFoldableEq mono => MonoFoldableEq (MinLen nat mono)
instance MonoFoldable mono => MonoFoldable (MinLen nat mono)
instance MonoFunctor mono => MonoFunctor (MinLen nat mono)
instance Eq mono => Eq (MinLen nat mono)
instance Ord mono => Ord (MinLen nat mono)
instance Read mono => Read (MinLen nat mono)
instance Show mono => Show (MinLen nat mono)
instance (Data nat, Data mono) => Data (MinLen nat mono)
instance Functor (MinLen nat)
instance IsSequence mono => MonoComonad (MinLen (Succ Zero) mono)
instance MonoPointed mono => MonoPointed (MinLen (Succ Zero) mono)
instance MonoPointed mono => MonoPointed (MinLen Zero mono)
instance SemiSequence seq => SemiSequence (MinLen nat seq)
instance GrowingAppend mono => Semigroup (MinLen nat mono)
instance MonoTraversable mono => MonoTraversable (MinLen nat mono)
instance TypeNat nat => TypeNat (Succ nat)
instance TypeNat Zero


-- | Warning, this is Experimental!
--   
--   <a>Data.NonNull</a> attempts to extend the concepts from
--   <a>Data.List.NonEmpty</a> to any <a>MonoFoldable</a>.
--   
--   <a>NonNull</a> is a typeclass for a container with 1 or more elements.
--   <a>Data.List.NonEmpty</a> and 'NotEmpty a' are members of the
--   typeclass
module Data.NonNull

-- | A monomorphic container that is not null.
type NonNull mono = MinLen (Succ Zero) mono

-- | <b>Safely</b> convert from an <b>unsafe</b> monomorphic container to a
--   <b>safe</b> non-null monomorphic container.
fromNullable :: MonoFoldable mono => mono -> Maybe (NonNull mono)

-- | <b>Unsafely</b> convert from an <b>unsafe</b> monomorphic container to
--   a <b>safe</b> non-null monomorphic container.
--   
--   Throws an exception if the monomorphic container is empty.
nonNull :: MonoFoldable mono => mono -> NonNull mono

-- | <b>Safely</b> convert from a non-null monomorphic container to a
--   nullable monomorphic container.
toNullable :: NonNull mono -> mono

-- | <b>Safely</b> convert from a <tt>NonEmpty</tt> list to a non-null
--   monomorphic container.
fromNonEmpty :: IsSequence seq => NonEmpty (Element seq) -> NonNull seq

-- | Prepend an element to a <a>SemiSequence</a>, creating a non-null
--   <a>SemiSequence</a>.
--   
--   Generally this uses cons underneath. cons is not efficient for most
--   data structures.
--   
--   Alternatives:
--   
--   <ul>
--   <li>if you don't need to cons, use <a>fromNullable</a> or
--   <a>nonNull</a> if you can create your structure in one go.</li>
--   <li>if you need to cons, you might be able to start off with an
--   efficient data structure such as a <tt>NonEmpty</tt> List.
--   <tt>fronNonEmpty</tt> will convert that to your data structure using
--   the structure's fromList function.</li>
--   </ul>
ncons :: SemiSequence seq => Element seq -> seq -> NonNull seq

-- | Extract the first element of a sequnce and the rest of the non-null
--   sequence if it exists.
nuncons :: IsSequence seq => NonNull seq -> (Element seq, Maybe (NonNull seq))

-- | Same as <a>nuncons</a> with no guarantee that the rest of the sequence
--   is non-null.
splitFirst :: IsSequence seq => NonNull seq -> (Element seq, seq)

-- | Equivalent to <tt><a>Data.Sequence</a>.<a>filter</a></tt>, but works
--   on non-nullable sequences.
nfilter :: IsSequence seq => (Element seq -> Bool) -> NonNull seq -> seq

-- | Equivalent to <tt><a>Data.Sequence</a>.<a>filterM</a></tt>, but works
--   on non-nullable sequences.
nfilterM :: (Monad m, IsSequence seq) => (Element seq -> m Bool) -> NonNull seq -> m seq

-- | Equivalent to <tt><a>Data.Sequence</a>.<a>replicate</a></tt>
--   
--   <tt>i</tt> must be <tt>&gt; 0</tt>
--   
--   <tt>i &lt;= 0</tt> is treated the same as providing <tt>1</tt>
nReplicate :: IsSequence seq => Index seq -> Element seq -> NonNull seq

-- | Return the first element of a monomorphic container.
--   
--   Safe version of <a>headEx</a>, only works on monomorphic containers
--   wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
head :: MonoFoldable mono => MinLen (Succ nat) mono -> Element mono

-- | <b>Safe</b> version of <a>tailEx</a>, only working on non-nullable
--   sequences.
tail :: IsSequence seq => NonNull seq -> seq

-- | Return the last element of a monomorphic container.
--   
--   Safe version of <a>lastEx</a>, only works on monomorphic containers
--   wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
last :: MonoFoldable mono => MinLen (Succ nat) mono -> Element mono

-- | <b>Safe</b> version of <a>initEx</a>, only working on non-nullable
--   sequences.
init :: IsSequence seq => NonNull seq -> seq

-- | Map each element of a monomorphic container to a semigroup, and
--   combine the results.
--   
--   Safe version of <a>ofoldMap1Ex</a>, only works on monomorphic
--   containers wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = ("hello", 1 :: <tt>Integer</tt>) `mlcons` (" world", 2) `mlcons` (<a>toMinLenZero</a> [])
--   &gt; <a>ofoldMap1</a> <tt>fst</tt> xs
--   "hello world"
--   </pre>
ofoldMap1 :: (MonoFoldable mono, Semigroup m) => (Element mono -> m) -> MinLen (Succ nat) mono -> m

-- | Join a monomorphic container, whose elements are <a>Semigroup</a>s,
--   together.
--   
--   Safe, only works on monomorphic containers wrapped in a
--   <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = "a" `mlcons` "b" `mlcons` "c" `mlcons` (<a>toMinLenZero</a> [])
--   &gt; xs
--   <a>MinLen</a> {unMinLen = ["a","b","c"]}
--   
--   &gt; <a>ofold1</a> xs
--   "abc"
--   </pre>
ofold1 :: (MonoFoldable mono, Semigroup (Element mono)) => MinLen (Succ nat) mono -> Element mono

-- | Right-associative fold of a monomorphic container with no base
--   element.
--   
--   Safe version of <a>ofoldr1Ex</a>, only works on monomorphic containers
--   wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
--   
--   <pre>
--   <tt>foldr1</tt> f = <a>Prelude</a>.<a>foldr1</a> f . <a>otoList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = "a" `mlcons` "b" `mlcons` "c" `mlcons` (<a>toMinLenZero</a> [])
--   &gt; <a>ofoldr1</a> (++) xs
--   "abc"
--   </pre>
ofoldr1 :: MonoFoldable mono => (Element mono -> Element mono -> Element mono) -> MinLen (Succ nat) mono -> Element mono

-- | Strict left-associative fold of a monomorphic container with no base
--   element.
--   
--   Safe version of <a>ofoldl1Ex'</a>, only works on monomorphic
--   containers wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
--   
--   <pre>
--   <tt>foldl1'</tt> f = <a>Prelude</a>.<a>foldl1'</a> f . <a>otoList</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = "a" `mlcons` "b" `mlcons` "c" `mlcons` (<a>toMinLenZero</a> [])
--   &gt; <a>ofoldl1'</a> (++) xs
--   "abc"
--   </pre>
ofoldl1' :: MonoFoldable mono => (Element mono -> Element mono -> Element mono) -> MinLen (Succ nat) mono -> Element mono

-- | Get the maximum element of a monomorphic container.
--   
--   Safe version of <a>maximumEx</a>, only works on monomorphic containers
--   wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = <a>toMinLen</a> [1,2,3] :: <a>Maybe</a> (<a>MinLen</a> (<a>Succ</a> <a>Zero</a>) [<a>Int</a>])
--   &gt; <a>fmap</a> <a>maximum</a> xs
--   <a>Just</a> 3
--   </pre>
maximum :: MonoFoldableOrd mono => MinLen (Succ nat) mono -> Element mono

-- | Get the maximum element of a monomorphic container, using a supplied
--   element ordering function.
--   
--   Safe version of <a>maximumByEx</a>, only works on monomorphic
--   containers wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
maximumBy :: MonoFoldable mono => (Element mono -> Element mono -> Ordering) -> MinLen (Succ nat) mono -> Element mono

-- | Get the minimum element of a monomorphic container.
--   
--   Safe version of <a>minimumEx</a>, only works on monomorphic containers
--   wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
--   
--   <h4><b>Examples</b></h4>
--   
--   <pre>
--   &gt; let xs = <a>toMinLen</a> [1,2,3] :: <a>Maybe</a> (<a>MinLen</a> (<a>Succ</a> <a>Zero</a>) [<a>Int</a>])
--   &gt; <a>fmap</a> <a>minimum</a> xs
--   <a>Just</a> 1
--   </pre>
minimum :: MonoFoldableOrd mono => MinLen (Succ nat) mono -> Element mono

-- | Get the minimum element of a monomorphic container, using a supplied
--   element ordering function.
--   
--   Safe version of <a>minimumByEx</a>, only works on monomorphic
--   containers wrapped in a <tt><a>MinLen</a> (<a>Succ</a> nat)</tt>.
minimumBy :: MonoFoldable mono => (Element mono -> Element mono -> Ordering) -> MinLen (Succ nat) mono -> Element mono

-- | Prepend an element to a non-null <a>SemiSequence</a>.
(<|) :: SemiSequence seq => Element seq -> NonNull seq -> NonNull seq

-- | Specializes <a>fromNonEmpty</a> to lists only.
toMinList :: NonEmpty a -> NonNull [a]
instance Typeable NullError
instance Show NullError
instance Exception NullError
