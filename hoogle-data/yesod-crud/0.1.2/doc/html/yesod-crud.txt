-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generic administrative CRUD operations as a Yesod subsite
--   
@package yesod-crud
@version 0.1.2


-- | This package helps you build administrative CRUD operations (Create,
--   Retrieve, Update, Delete) into your web site, as Yesod subsites. There
--   is a demo site in the <tt>example</tt> directory in the distribution.
--   
--   To begin, add subsites to your <tt>routes</tt> file, like these:
--   
--   <pre>
--   /users         UserCrudR  CrudSubsite-UserCrud  mkUserCrud
--   /pubs/#UserId  PubCrudR   CrudSubsite-PubCrud   mkPubCrud
--   </pre>
--   
--   Now, in your Foundation module, you must define the subsite foundation
--   types and functions. Here we have one foundation type that is nullary,
--   and another that carries a piece of data.
--   
--   <pre>
--   data UserCrud = UserCrud
--   mkUserCrud :: a -&gt; CrudSubsite UserCrud
--   mkUserCrud _ = CrudSubsite UserCrud
--   
--   data PubCrud = PubCrud UserId
--   mkPubCrud :: a -&gt; UserId -&gt; CrudSubsite PubCrud
--   mkPubCrud _ = CrudSubsite . PubCrud
--   </pre>
--   
--   Next, define the type families on which these will operate. The
--   simplest case is that <a>ObjId</a> is a Persistent database
--   <tt>Key</tt> and <a>Obj</a> is one of your model types, but yesod-crud
--   supports other types and non-Persistent databases too.
--   
--   <pre>
--   instance CrudTypes UserCrud where
--     type Site UserCrud = App
--     type ObjId UserCrud = UserId
--     type Obj UserCrud = User
--   
--   instance CrudTypes PubCrud where
--     type Site PubCrud = App
--     type ObjId PubCrud = PublicationId
--     type Obj PubCrud = Publication
--   </pre>
--   
--   The above generally must go within the Foundation.hs of a scaffolded
--   site, because it relies on the <tt>App</tt> type, and is in turn used
--   in the routes file. The remaining CRUD operations can be defined
--   elsewhere and then imported into Application.hs for the dispatcher to
--   access.
--   
--   <pre>
--   instance RenderMessage (CrudSubsite UserCrud) CrudMessage where
--     renderMessage _ _ CrudMsgEntity = "User"
--     renderMessage _ _ CrudMsgEntities = "Users"
--     renderMessage _ _ m = defaultCrudMessage m
--   
--   instance Crud UserCrud where
--     crudDB = return crudPersistDefaults
--     crudShow = return . userIdent
--     crudEq u v = return $ u == v
--     crudMakeForm uOpt =
--       return $ renderDivs $ User
--       &lt;$&gt; areq textField "User name" (userIdent &lt;$&gt; uOpt)
--       &lt;*&gt; aopt passwordField "Password" (userPassword &lt;$&gt; uOpt)
--   </pre>
--   
--   The minimal definition above will provide pages to list users, add a
--   new user, update existing users, and delete users (with a confirmation
--   step). Various aspects of the look and functionality can be
--   overridden, and the CRUD widgets can be mixed and matched on other
--   pages too.
--   
--   Comments and critiques are welcome. Please use the <i>Issues</i>
--   feature at <a>https://github.com/league/yesod-crud</a>
module Yesod.Contrib.League.Crud

-- | Define the types used by your CRUD subsite.
class (Eq (ObjId sub), PathPiece (ObjId sub)) => CrudTypes sub where type family Site sub :: * type family ObjId sub :: * type family Obj sub :: *

-- | The foundation type for a CRUD subsite, wrapped around your own type
--   <i>sub</i> that determines the entity and carries any contextual data
--   from the route.
newtype CrudSubsite sub
CrudSubsite :: sub -> CrudSubsite sub
unCrud :: CrudSubsite sub -> sub

-- | The type of a subsite handler.
type CrudHandler sub = HandlerT (CrudSubsite sub) (SiteHandler sub)

-- | The type of the (parent) site handler.
type SiteHandler sub = HandlerT (Site sub) IO

-- | Widgets are relative to the parent site, not the subsite. This makes
--   it a little more convenient to use messages and routes from the
--   parent.
type CrudWidget sub = WidgetT (Site sub) IO ()

-- | Forms are also defined relative to the parent site.
type CrudForm sub = Html -> MForm (SiteHandler sub) (FormResult (Obj sub), CrudWidget sub)

-- | Like the Persistent <tt>Entity</tt> type, but just a simple pair.
type Ent sub = (ObjId sub, Obj sub)

-- | The required database operations are packaged into this record type.
--   This makes it straightforward to inherit the operations wholesale into
--   different CRUD subsites (whether you are using Persistent or another
--   mechanism), but they can still be overridden by the similarly-named
--   methods in the <a>Crud</a> class.
data CrudDB sub
CrudDB :: CrudM sub [Ent sub] -> (Obj sub -> CrudM sub (ObjId sub)) -> (ObjId sub -> CrudM sub (Maybe (Obj sub))) -> (ObjId sub -> Obj sub -> CrudM sub ()) -> (ObjId sub -> CrudM sub ()) -> CrudDB sub
crudSelect' :: CrudDB sub -> CrudM sub [Ent sub]
crudInsert' :: CrudDB sub -> Obj sub -> CrudM sub (ObjId sub)
crudGet' :: CrudDB sub -> ObjId sub -> CrudM sub (Maybe (Obj sub))
crudReplace' :: CrudDB sub -> ObjId sub -> Obj sub -> CrudM sub ()
crudDelete' :: CrudDB sub -> ObjId sub -> CrudM sub ()

-- | All the necessary CRUD handlers and operations are defined in this
--   class, and can be overridden as necessary for each CRUD subsite.
class (CrudTypes sub, Yesod (Site sub), RenderMessage (Site sub) FormMessage, RenderMessage (CrudSubsite sub) CrudMessage) => Crud sub where crudSelect = crudDB >>= crudSelect' crudInsert obj = crudDB >>= flip crudInsert' obj crudGet k = crudDB >>= flip crudGet' k crudReplace k obj = do { db <- crudDB; crudReplace' db k obj } crudDelete k = crudDB >>= flip crudDelete' k crudShowHtml = fmap toHtml . crudShow crudNextPage _ = getRouter <*> pure CrudListR crudAlert route response = setMessage =<< defaultCrudAlertMessage route response crudListWidget = do { mr <- getMessenger; r2p <- getRouter; objects <- crudSelect; let kv (objId, obj) = (objId,) <$> crudShowHtml obj; pairs <- mapM kv objects; return (do { condH [((==) (length pairs) 0,  do { (asWidgetT . toWidget) ((preEscapedText . pack) "<p>"); (asWidgetT . toWidget) (toHtml (mr CrudMsgNoEntities)); (asWidgetT . toWidget) ((preEscapedText . pack) "</p>") })] (Just (do { (asWidgetT . toWidget) ((preEscapedText . pack) "<ol>"); mapM_ (\ (k_afzh, s_afzi) -> do { (asWidgetT . toWidget) ((preEscapedText . pack) "<li>"); (asWidgetT . toWidget) (toHtml s_afzi); (asWidgetT . toWidget) ((preEscapedText . pack) "\n\ \<a href=\""); (getUrlRenderParams >>= (\ urender_afzj -> (asWidgetT . toWidget) (toHtml (\ u_afzk -> urender_afzj u_afzk [] (r2p (CrudUpdateR k_afzh)))))); (asWidgetT . toWidget) ((preEscapedText . pack) "\">"); (asWidgetT . toWidget) (toHtml (mr CrudMsgLinkUpdate)); (asWidgetT . toWidget) ((preEscapedText . pack) "</a>\n\ \<a href=\""); (getUrlRenderParams >>= (\ urender_afzl -> (asWidgetT . toWidget) (toHtml (\ u_afzm -> urender_afzl u_afzm [] (r2p (CrudDeleteR k_afzh)))))); (asWidgetT . toWidget) ((preEscapedText . pack) "\">"); (asWidgetT . toWidget) (toHtml (mr CrudMsgLinkDelete)); (asWidgetT . toWidget) ((preEscapedText . pack) "</a>\n\ \<a href=\""); (getUrlRenderParams >>= (\ urender_afzn -> (asWidgetT . toWidget) (toHtml (\ u_afzo -> urender_afzn u_afzo [] (r2p (CrudViewR k_afzh)))))); (asWidgetT . toWidget) ((preEscapedText . pack) "\">"); (asWidgetT . toWidget) (toHtml (mr CrudMsgLinkView)); (asWidgetT . toWidget) ((preEscapedText . pack) "</a>\n\ \</li>") }) pairs; (asWidgetT . toWidget) ((preEscapedText . pack) "</ol>") })); (asWidgetT . toWidget) ((preEscapedText . pack) "<p><a href=\""); (getUrlRenderParams >>= (\ urender_afzp -> (asWidgetT . toWidget) (toHtml (\ u_afzq -> urender_afzp u_afzq [] (r2p CrudCreateR))))); (asWidgetT . toWidget) ((preEscapedText . pack) "\">"); (asWidgetT . toWidget) (toHtml (mr CrudMsgLinkCreate)); (asWidgetT . toWidget) ((preEscapedText . pack) "</a>\n\ \</p>") }) } crudFormWidget action (w, enc) = do { mr <- getMessenger; r2p <- getRouter; return (do { (asWidgetT . toWidget) ((preEscapedText . pack) "<form method=\"post\" action=\""); (getUrlRenderParams >>= (\ urender_afzz -> (asWidgetT . toWidget) (toHtml (\ u_afzA -> urender_afzz u_afzA [] (r2p action))))); (asWidgetT . toWidget) ((preEscapedText . pack) "\" enctype=\""); (asWidgetT . toWidget) (toHtml enc); (asWidgetT . toWidget) ((preEscapedText . pack) "\">"); (asWidgetT . toWidget) w; (asWidgetT . toWidget) ((preEscapedText . pack) "\n\ \<input type=\"submit\" value=\""); (asWidgetT . toWidget) (toHtml (mr CrudMsgButtonSubmit)); (asWidgetT . toWidget) ((preEscapedText . pack) "\">\n\ \</form>") }) } crudCreateWidget = do { form <- crudMakeForm Nothing; widgetEnc <- liftHandlerT $ generateFormPost form; crudFormWidget CrudCreateR widgetEnc } crudViewWidget ent = do { objW <- crudShowHtml $ snd ent; return (do { (asWidgetT . toWidget) ((preEscapedText . pack) "<p>"); (asWidgetT . toWidget) objW; (asWidgetT . toWidget) ((preEscapedText . pack) "</p>") }) } crudDeleteWidget ent = do { txt <- crudShow $ snd ent; mr <- getMessenger; return (do { (asWidgetT . toWidget) ((preEscapedText . pack) "<p>"); (asWidgetT . toWidget) (toHtml (mr (CrudMsgConfirmDelete txt))); (asWidgetT . toWidget) ((preEscapedText . pack) "</p>\n\ \<input type=\"submit\" value=\""); (asWidgetT . toWidget) (toHtml (mr CrudMsgButtonDelete)); (asWidgetT . toWidget) ((preEscapedText . pack) "\">") }) } crudFormLayout action widgetEnc = do { mr <- getMessenger; fw <- crudFormWidget action widgetEnc; crudLayout $ do { setTitle . toHtml . mr . routeToTitle action $ mr CrudMsgEntity; fw } } crudLayout = liftHandlerT . defaultLayout getCrudListR = runCrudSubsite $ do { mr <- getMessenger; lw <- crudListWidget; res <- crudLayout $ do { setTitle . toHtml $ mr CrudMsgEntities; lw }; return $ toTypedContent res } getCrudCreateR = runCrudSubsite $ do { form <- crudMakeForm Nothing; widgetEnc <- liftHandlerT $ generateFormPost form; res <- crudFormLayout CrudCreateR widgetEnc; return $ toTypedContent res } postCrudCreateR = runCrudSubsite $ do { form <- crudMakeForm Nothing; ((result, w), enc) <- liftHandlerT $ runFormPost form; case result of { FormSuccess obj -> do { kOpt <- try $ crudInsert obj; case kOpt of { Left e -> crudAlert CrudCreateR (Left e) Right objId -> do { crudAlert CrudCreateR (Right obj); crudNextPage (Just objId) >>= redirect } } } _ -> pure () }; res <- crudFormLayout CrudCreateR (w, enc); return $ toTypedContent res } getCrudViewR objId = runCrudSubsite $ do { mr <- getMessenger; obj <- crudGet objId >>= maybe404; objW <- crudViewWidget (objId, obj); r2p <- getRouter; res <- crudLayout $ do { setTitle . toHtml . mr . CrudMsgTitleView $ mr CrudMsgEntity; (do { (asWidgetT . toWidget) objW; (asWidgetT . toWidget) ((preEscapedText . pack) "\n\ \<p><a href="); (getUrlRenderParams >>= (\ urender_afDL -> (asWidgetT . toWidget) (toHtml (\ u_afDM -> urender_afDL u_afDM [] (r2p CrudListR))))); (asWidgetT . toWidget) ((preEscapedText . pack) ">"); (asWidgetT . toWidget) (toHtml (mr CrudMsgViewLinkNext)); (asWidgetT . toWidget) ((preEscapedText . pack) "</p>") }) }; return $ toTypedContent res } getCrudDeleteR objId = runCrudSubsite $ do { mr <- getMessenger; r2p <- getRouter; obj <- crudGet objId >>= maybe404; (tokenW, enc) <- generateFormPost . renderDivs $ pure (); confirmW <- crudDeleteWidget (objId, obj); res <- crudLayout $ do { setTitle . toHtml . mr . CrudMsgTitleDelete $ mr CrudMsgEntity; (do { (asWidgetT . toWidget) ((preEscapedText . pack) "<form method=\"post\" action=\""); (getUrlRenderParams >>= (\ urender_afDY -> (asWidgetT . toWidget) (toHtml (\ u_afDZ -> urender_afDY u_afDZ [] (r2p (CrudDeleteR objId)))))); (asWidgetT . toWidget) ((preEscapedText . pack) "\" enctype=\""); (asWidgetT . toWidget) (toHtml enc); (asWidgetT . toWidget) ((preEscapedText . pack) "\">"); (asWidgetT . toWidget) tokenW; (asWidgetT . toWidget) ((preEscapedText . pack) ""); (asWidgetT . toWidget) confirmW; (asWidgetT . toWidget) ((preEscapedText . pack) "</form>") }) }; return $ toTypedContent res } postCrudDeleteR objId = runCrudSubsite $ do { obj <- crudGet objId >>= maybe404; crudDelete objId; crudAlert (CrudDeleteR objId) (Right obj); crudNextPage Nothing >>= redirect } getCrudUpdateR objId = runCrudSubsite $ do { obj <- crudGet objId >>= maybe404; form <- crudMakeForm (Just obj); widgetEnc <- liftHandlerT $ generateFormPost form; res <- crudFormLayout (CrudUpdateR objId) widgetEnc; return $ toTypedContent res } postCrudUpdateR objId = runCrudSubsite $ do { obj <- crudGet objId >>= maybe404; form <- crudMakeForm (Just obj); ((result, w), enc) <- liftHandlerT $ runFormPost form; case result of { FormSuccess newObj -> do { eq <- crudEq obj newObj; if eq then do { crudAlert CrudListR (Right obj); crudNextPage (Just objId) >>= redirect } else do { unitOrExn <- try $ crudReplace objId newObj; crudAlert (CrudUpdateR objId) (const newObj <$> unitOrExn); when (isRight unitOrExn) $ crudNextPage (Just objId) >>= redirect } } _ -> pure () }; res <- crudFormLayout (CrudUpdateR objId) (w, enc); return $ toTypedContent res }
crudDB :: Crud sub => CrudM sub (CrudDB sub)
crudSelect :: Crud sub => CrudM sub [Ent sub]
crudInsert :: Crud sub => Obj sub -> CrudM sub (ObjId sub)
crudGet :: Crud sub => ObjId sub -> CrudM sub (Maybe (Obj sub))
crudReplace :: Crud sub => ObjId sub -> Obj sub -> CrudM sub ()
crudDelete :: Crud sub => ObjId sub -> CrudM sub ()
crudShow :: Crud sub => Obj sub -> CrudM sub Text
crudShowHtml :: Crud sub => Obj sub -> CrudM sub Html
crudEq :: Crud sub => Obj sub -> Obj sub -> CrudM sub Bool
crudMakeForm :: Crud sub => Maybe (Obj sub) -> CrudM sub (CrudForm sub)
crudNextPage :: Crud sub => Maybe (ObjId sub) -> CrudM sub (Route (Site sub))
crudAlert :: Crud sub => Route (CrudSubsite sub) -> Either SomeException (Obj sub) -> CrudM sub ()
crudListWidget :: Crud sub => CrudM sub (CrudWidget sub)
crudFormWidget :: Crud sub => Route (CrudSubsite sub) -> (CrudWidget sub, Enctype) -> CrudM sub (CrudWidget sub)
crudCreateWidget :: Crud sub => CrudM sub (CrudWidget sub)
crudViewWidget :: Crud sub => Ent sub -> CrudM sub (CrudWidget sub)
crudDeleteWidget :: Crud sub => Ent sub -> CrudM sub (CrudWidget sub)
crudFormLayout :: Crud sub => Route (CrudSubsite sub) -> (CrudWidget sub, Enctype) -> CrudM sub Html
crudLayout :: Crud sub => CrudWidget sub -> CrudM sub Html
getCrudListR :: Crud sub => CrudHandler sub TypedContent
getCrudCreateR :: Crud sub => CrudHandler sub TypedContent
postCrudCreateR :: Crud sub => CrudHandler sub TypedContent
getCrudViewR :: Crud sub => ObjId sub -> CrudHandler sub TypedContent
getCrudDeleteR :: Crud sub => ObjId sub -> CrudHandler sub TypedContent
postCrudDeleteR :: Crud sub => ObjId sub -> CrudHandler sub TypedContent
getCrudUpdateR :: Crud sub => ObjId sub -> CrudHandler sub TypedContent
postCrudUpdateR :: Crud sub => ObjId sub -> CrudHandler sub TypedContent

-- | A custom monad that can run either in the site or subsite handler. It
--   carries the subsite foundation object (retrieved with <a>getCrud</a>)
--   and appropriate converters for routes (<a>getRouter</a>) and messages
--   (<a>getMessenger</a>).
data CrudM sub a

-- | Retrieve the value of the foundation type. This is needed if your CRUD
--   paths contain parameters, such as
--   <tt>/customer/31/donut/15/update</tt>. The 31 is stored in the
--   foundation, and the 15 in the subsite route.
getCrud :: CrudM sub sub

-- | Run a <a>CrudM</a> action within the subsite handler.
runCrudSubsite :: RenderMessage (CrudSubsite sub) CrudMessage => CrudM sub a -> CrudHandler sub a

-- | Run a <a>CrudM</a> action within the global site handler. You must
--   provide the foundation value and a route translator.
runCrudSite :: RenderMessage (CrudSubsite sub) CrudMessage => sub -> (Route (CrudSubsite sub) -> Route (Site sub)) -> CrudM sub a -> SiteHandler sub a

-- | All titles, links, alerts, and button labels emitted by the default
--   implementations of Crud operations are represented by constructors of
--   this type. See <a>defaultCrudMessage</a> for basic conversion to
--   English text. When you implement <a>RenderMessage</a> for this type,
--   consider overriding at least the first two or three constructors to
--   customize your entity name:
--   
--   <pre>
--   instance <a>RenderMessage</a> (<a>CrudSubsite</a> DonutCrud) CrudMessage where
--     renderMessage _ _ CrudMsgEntity = "Donut"
--     renderMessage _ _ CrudMsgEntities = "Donuts"
--     renderMessage _ _ CrudMsgNoEntities = "Sorry, there are no more donuts."
--     renderMessage _ _ m = <a>defaultCrudMessage</a> m
--   </pre>
data CrudMessage

-- | The singular name for your entity
CrudMsgEntity :: CrudMessage

-- | The plural name for your entity
CrudMsgEntities :: CrudMessage

-- | Message when no entities are found
CrudMsgNoEntities :: CrudMessage

-- | The message "Created [object]"
CrudMsgAlertCreated :: Text -> CrudMessage

-- | The message "Deleted [object]"
CrudMsgAlertDeleted :: Text -> CrudMessage

-- | The message "No changes to [object]"
CrudMsgAlertNoChanges :: Text -> CrudMessage

-- | The message "Updated [object]"
CrudMsgAlertUpdated :: Text -> CrudMessage

-- | The label on button to confirm delete
CrudMsgButtonDelete :: CrudMessage

-- | The label on button to save/submit
CrudMsgButtonSubmit :: CrudMessage

-- | The message "Really delete [object]?"
CrudMsgConfirmDelete :: Text -> CrudMessage

-- | The link text leading to the create page
CrudMsgLinkCreate :: CrudMessage

-- | The link text leading to the delete page
CrudMsgLinkDelete :: CrudMessage

-- | The link text leading to the update form
CrudMsgLinkUpdate :: CrudMessage

-- | The link text leading to the details page
CrudMsgLinkView :: CrudMessage

-- | The title "Create [entity]"
CrudMsgTitleCreate :: Text -> CrudMessage

-- | The title "Delete [entity]"
CrudMsgTitleDelete :: Text -> CrudMessage

-- | The title "Update [entity]"
CrudMsgTitleUpdate :: Text -> CrudMessage

-- | The title "Show [entity]"
CrudMsgTitleView :: Text -> CrudMessage

-- | The link text to return from object details page
CrudMsgViewLinkNext :: CrudMessage

-- | Basic conversion of CRUD messages to English text.
defaultCrudMessage :: CrudMessage -> Text

-- | Choose and render an appropriate alert message after a CRUD operation.
defaultCrudAlertMessage :: Crud sub => Route (CrudSubsite sub) -> Either SomeException (Obj sub) -> CrudM sub Html

-- | Retrieve the message translator and renderer in the CRUD monad. Uses
--   <a>getMessageRender</a> behind the scenes, which calls your
--   <a>RenderMessage</a> instance with the appropriate language headers.
getMessenger :: CrudM sub (CrudMessage -> Text)

-- | The <a>type-safe URLs</a> associated with a site argument.

-- | Retrieve a child-to-parent route translator in the CRUD monad. Uses
--   <a>getRouteToParent</a> behind the scenes, but it adapts based on
--   whether we're being run in the site handler or a subsite handler.
getRouter :: CrudM sub (Route (CrudSubsite sub) -> Route (Site sub))
instance Show (ObjId sub) => Show (Route (CrudSubsite sub))
instance Read (ObjId sub) => Read (Route (CrudSubsite sub))
instance Eq (ObjId sub) => Eq (Route (CrudSubsite sub))
instance Functor (CrudM sub)
instance Applicative (CrudM sub)
instance Monad (CrudM sub)
instance MonadIO (CrudM sub)
instance MonadLogger (CrudM sub)
instance MonadBase IO (CrudM sub)
instance MonadThrow (CrudM sub)
instance MonadResource (CrudM sub)
instance (Crud sub, Site sub ~ site) => YesodSubDispatch (CrudSubsite sub) (HandlerT site IO)
instance CrudTypes sub => ParseRoute (CrudSubsite sub)
instance CrudTypes sub => RenderRoute (CrudSubsite sub)
instance MonadBaseControl IO (CrudM sub)
instance MonadHandler (CrudM sub)


-- | This module provides default database operations using <a>Persist</a>.
--   Start out by setting <tt>crudDB = return crudPersistDefaults</tt> and
--   then you can override any operations within your <a>Crud</a> instance.
module Yesod.Contrib.League.Crud.Persist

-- | Retrieve a record of database operations that use <a>Persist</a>. By
--   default, the select is limited to returning 1000 entities, so we don't
--   end up retrieving entire large tables.
crudPersistDefaults :: CrudPersist sub => CrudDB sub

-- | Run a database query within the <a>CrudM</a> monad.
crudRunDB :: CrudPersist sub => YesodDB (Site sub) a -> CrudM sub a

-- | Run a <a>selectList</a> on the CRUD type, using the given filters and
--   options. Return the entities as a plain pair of <a>ObjId</a> and
--   <a>Obj</a>.
crudSelectList :: CrudPersist sub => [Filter (Obj sub)] -> [SelectOpt (Obj sub)] -> CrudM sub [Ent sub]

-- | Helper function to convert a Persist <a>Entity</a> into a plain pair.
crudEntPair :: Entity t -> (Key t, t)

module Yesod.Contrib.League.Crud.Sort
data Sort k
Sort :: k -> Bool -> Sort k
sortKey :: Sort k -> k
sortAsc :: Sort k -> Bool
newtype Sorts k
Sorts :: [Sort k] -> Sorts k
sortsList :: Sorts k -> [Sort k]
type SortC k = (Eq k, Enum k, Bounded k)
type ToEntityField k f = forall a. k -> (forall t. EntityField f t -> a) -> a
cancelLink :: (SortC k, Crud sub) => k -> Sorts k -> (Route (CrudSubsite sub) -> Route (Site sub)) -> (Route (Site sub), [(Text, Text)])
cancelSort :: SortC k => k -> Sorts k -> Sorts k
getSorts :: (SortC k, Crud sub) => CrudM sub (Sorts k)
isSortedBy :: SortC k => k -> Sorts k -> Maybe (Int, Bool)
sortIndicator :: (SortC k, Crud sub) => k -> Sorts k -> (Route (CrudSubsite sub) -> Route (Site sub)) -> CrudWidget sub
sortToSelectOpt :: ToEntityField k f -> Sort k -> SelectOpt f
sortsQuery :: SortC k => Sorts k -> [(Text, Text)]
sortsToSelectOpts :: ToEntityField k f -> Sorts k -> [SelectOpt f]
toggleLink :: (SortC k, Crud sub) => k -> Bool -> Sorts k -> (Route (CrudSubsite sub) -> Route (Site sub)) -> (Route (Site sub), [(Text, Text)])
toggleSort :: SortC k => k -> Bool -> Sorts k -> Sorts k
instance Eq k => Eq (Sort k)
instance Show k => Show (Sort k)
instance Eq k => Eq (Sorts k)
instance Show k => Show (Sorts k)
instance Bounded k => Bounded (Sort k)
instance Enum k => Enum (Sort k)


-- | This is a proof of concept for implementing CRUD operations that are
--   not based on Database.Persist. It uses a <a>TVar</a> and a <a>Map</a>
--   from <a>UUID</a> keys to the CRUD entity.
module Yesod.Contrib.League.Crud.TVarMap

-- | The key type. A wrapper for <a>UUID</a> that implements all the
--   necessary classes, including <a>PathPiece</a>.
data CrudTVarKey

-- | Synonym for the map type.
type CrudTVarMap sub = Map CrudTVarKey (Obj sub)

-- | Retrieve a record of database operations for using a
--   <a>CrudTVarMap</a>.
crudTVarMapDefaults :: ObjId sub ~ CrudTVarKey => CrudM sub (TVar (CrudTVarMap sub)) -> CrudDB sub
instance Eq CrudTVarKey
instance Ord CrudTVarKey
instance Read CrudTVarKey
instance Show CrudTVarKey
instance Random CrudTVarKey
instance PathPiece CrudTVarKey
