-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Control synthesizer effects via ALSA/MIDI
--   
--   This package allows to read MIDI events and to convert them to control
--   signals that can be used for audio effects. As demonstration there is
--   a keyboard controlled music synthesizer.
@package synthesizer-alsa
@version 0.5.0.2


-- | Play audio signals via ALSA. The module could also be called
--   <tt>Output</tt>, because with a <tt>file</tt> sink, data can also be
--   written to disk.
module Synthesizer.ALSA.Storable.Play
type Device = String
defaultDevice :: Device

-- | A suggested default chunk size. It is not used by the functions in
--   this module.
defaultChunkSize :: ChunkSize

-- | Useful values for the output device are
--   
--   <ul>
--   <li><tt>"default"</tt> for mixing with the output of other
--   applications.</li>
--   <li><tt>"plughw:0,0"</tt> for accessing sound output in an exclusive
--   way.</li>
--   <li><tt>"tee:default,'output.raw',raw"</tt> for playing and
--   simultaneously writing raw data to disk.</li>
--   <li><tt>"tee:default,'output.wav',wav"</tt> for playing and writing to
--   WAVE file format. Note that the length cannot be written, when the
--   program is terminated, leaving the file in an invalid format.</li>
--   </ul>
makeSink :: (SampleFmt y, C t) => Device -> t -> SampleFreq -> SoundSink Pcm y
write :: Storable y => SoundSink handle y -> handle y -> Vector y -> IO ()
writeLazy :: Storable y => SoundSink handle y -> handle y -> Vector y -> IO ()
auto :: SampleFmt y => SoundSink handle y -> T y -> IO ()

-- | Play a signal and write it to disk via SoX simultaneously. Consider
--   using <a>auto</a> with <tt>tee</tt> device.
autoAndRecord :: (SampleFmt y, C y) => FilePath -> SoundFmt y -> SoundSink handle y -> T y -> IO ExitCode

-- | Play a signal and write it to multiple files. The Functor <tt>f</tt>
--   may be <tt>Maybe</tt> for no or one file to write, or <tt>[]</tt> for
--   many files to write.
autoAndRecordMany :: (SampleFmt y, C y, Traversable f) => f FilePath -> SoundFmt y -> SoundSink handle y -> T y -> IO (f ExitCode)
monoToInt16 :: (Storable y, C y) => SoundSink handle Int16 -> T y -> IO ()
stereoToInt16 :: (Storable y, C y) => SoundSink handle (T Int16) -> T (T y) -> IO ()

module Synthesizer.ALSA.Dimensional.Play
type Device = String
type RenderedStorableSignal u t v y yv = T (Dimensional u t) (Dimensional v y) (T yv)
type StorableSignal s v y yv = T (Phantom s) (Dimensional v y) (T yv)
makeSink :: (SampleFmt y, C t) => Device -> Time t -> Frequency t -> SoundSink Pcm y
timeVoltageStorable :: (C y yv, SampleFmt yv, C t) => Device -> Time t -> RenderedStorableSignal Time t Voltage y yv -> IO ()
timeVoltageMonoStorableToInt16 :: (Storable y, C y, C t) => Device -> Time t -> RenderedStorableSignal Time t Voltage y y -> IO ()
timeVoltageStereoStorableToInt16 :: (Storable y, C y y, C y, C t) => Device -> Time t -> RenderedStorableSignal Time t Voltage y (T y) -> IO ()
renderTimeVoltageStorable :: (C y yv, SampleFmt yv, C t) => Device -> Time t -> T Frequency t -> (forall s. T s Time t (StorableSignal s Voltage y yv)) -> IO ()
renderTimeVoltageMonoStorableToInt16 :: (Storable y, C y, C t) => Device -> Time t -> T Frequency t -> (forall s. T s Time t (StorableSignal s Voltage y y)) -> IO ()
renderTimeVoltageStereoStorableToInt16 :: (Storable y, C y y, C y, C t) => Device -> Time t -> T Frequency t -> (forall s. T s Time t (StorableSignal s Voltage y (T y))) -> IO ()

module Synthesizer.ALSA.EventList

-- | The <tt>time</tt> type needs high precision, so you will certainly
--   have to instantiate it with <a>Double</a>. <a>Float</a> has definitely
--   not enough bits.
getTimeSeconds :: C time => IO time
clockTimeToSeconds :: C time => ClockTime -> time
wait :: C time => time -> IO ()
type StampedEvent time = (time, T)

-- | only use it for non-blocking sequencers
--   
--   We ignore ALSA time stamps and use the time of fetching the event,
--   because I don't know whether the ALSA time stamps are in sync with
--   getClockTime.
getStampedEvent :: (C time, AllowInput mode) => T mode -> IO (StampedEvent time)

-- | only use it for non-blocking sequencers
getWaitingStampedEvents :: (C time, AllowInput mode) => T mode -> IO [StampedEvent time]

-- | RealTime.toFractional for NumericPrelude.
realTimeToField :: C a => T -> a
addStamp :: C time => T -> StampedEvent time

-- | only use it for blocking sequencers
getStampedEventsUntilTime :: (C time, AllowInput mode, AllowOutput mode) => T mode -> T -> T -> time -> IO [StampedEvent time]

-- | The client id may differ from the receiving sequencer. I do not know,
--   whether there are circumstances, where this is useful.
getEventsUntilEcho :: AllowInput mode => T -> T mode -> IO [T]

-- | Get events until a certain point in time. It sends itself an Echo
--   event in order to measure time.
getEventsUntilTime :: (C time, AllowInput mode, AllowOutput mode) => T mode -> T -> T -> time -> IO [T]
getWaitingEvents :: AllowInput mode => T mode -> IO [T]
type StrictTime = Integer
newtype ClientName
ClientName :: String -> ClientName
withMIDIEvents :: C time => ClientName -> time -> time -> (T StrictTime [T] -> IO a) -> IO a
withMIDIEventsNonblockWaitGrouped :: C time => ClientName -> time -> time -> (T StrictTime [T] -> IO a) -> IO a
withMIDIEventsNonblockWaitDefer :: C time => ClientName -> time -> time -> (T StrictTime (Maybe T) -> IO a) -> IO a
withMIDIEventsNonblockWaitSkip :: C time => ClientName -> time -> time -> (T StrictTime (Maybe T) -> IO a) -> IO a
withMIDIEventsNonblockWaitMin :: C time => ClientName -> time -> time -> (T StrictTime (Maybe T) -> IO a) -> IO a
withMIDIEventsNonblockConstantPause :: C time => ClientName -> time -> time -> (T StrictTime (Maybe T) -> IO a) -> IO a
withMIDIEventsNonblockSimple :: C time => ClientName -> time -> time -> (T StrictTime T -> IO a) -> IO a
setTimestamping :: T mode -> T -> T -> IO ()
withMIDIEventsBlockEcho :: C time => ClientName -> time -> time -> (T StrictTime [T] -> IO a) -> IO a

-- | This is like withMIDIEventsBlockEcho but collects all events at the
--   beginning of the beats. This way, further processing steps may
--   collapse all controller events within one beat to one event.
withMIDIEventsBlockEchoQuantised :: C time => ClientName -> time -> time -> (T StrictTime [T] -> IO a) -> IO a

-- | Make sure, that <tt>beat</tt> is an integer multiple of <tt>recip
--   rate</tt>. Since we round time within each chunk, we would otherwise
--   accumulate rounding errors over time.
withMIDIEventsChunked :: C time => ClientName -> time -> time -> ([IO (T StrictTime [T])] -> IO a) -> IO a
withMIDIEventsChunkedQuantised :: C time => ClientName -> time -> time -> ([IO (T StrictTime [T])] -> IO a) -> IO a
makeEcho :: C time => T -> T -> T -> time -> Custom -> T
withMIDIEventsBlock :: C time => ClientName -> time -> (T StrictTime T -> IO a) -> IO a
withInPort :: ClientName -> BlockMode -> (T DuplexMode -> T -> IO t) -> IO t

-- | We first discretize the absolute time values, then we compute
--   differences, in order to avoid rounding errors in further
--   computations.
discretizeTime :: C time => time -> T time a -> T StrictTime a
ioToLazyList :: IO a -> IO [a]
lazySequence :: [IO a] -> IO [a]
instance Show ClientName

module Synthesizer.ALSA.CausalIO.Process
type Events = T StrictTime [T]
playFromEvents :: (C time, SampleFmt a, C a) => Device -> ClientName -> time -> time -> SampleFreq -> T Events (Vector a) -> IO ()
type Output handle signal a = (IO ((Size, SampleFreq), handle), handle -> IO (), handle -> signal -> IO a)
playFromEventsWithParams :: Output handle signal () -> ClientName -> ((Size, SampleFreq) -> T Events signal) -> IO ()
