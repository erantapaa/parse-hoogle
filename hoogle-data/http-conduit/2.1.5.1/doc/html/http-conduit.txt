-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | HTTP client package with conduit interface and HTTPS support.
--   
@package http-conduit
@version 2.1.5.1


-- | A new, experimental API to replace <a>Network.HTTP.Conduit</a>.
--   
--   For more information, please be sure to read the documentation in the
--   <a>Network.HTTP.Client</a> module.
module Network.HTTP.Client.Conduit

-- | Conduit powered version of <a>withResponse</a>. Differences are:
--   
--   <ul>
--   <li>Response body is represented as a <tt>Producer</tt>.</li>
--   <li>Generalized to any instance of <tt>MonadBaseControl</tt>, not just
--   <tt>IO</tt>.</li>
--   <li>The <tt>Manager</tt> is contained by a <tt>MonadReader</tt>
--   context.</li>
--   </ul>
--   
--   Since 2.1.0
withResponse :: (MonadBaseControl IO m, MonadIO n, MonadReader env m, HasHttpManager env) => Request -> (Response (ConduitM i ByteString n ()) -> m a) -> m a

-- | Conduit-powered version of <a>responseOpen</a>.
--   
--   See <a>withResponse</a> for the differences with <a>responseOpen</a>.
--   
--   Since 2.1.0
responseOpen :: (MonadIO m, MonadIO n, MonadReader env m, HasHttpManager env) => Request -> m (Response (ConduitM i ByteString n ()))

-- | Generalized version of <a>responseClose</a>.
--   
--   Since 2.1.0
responseClose :: MonadIO m => Response body -> m ()

-- | An <tt>Acquire</tt> for getting a <tt>Response</tt>.
--   
--   Since 2.1.0
acquireResponse :: (MonadIO n, MonadReader env m, HasHttpManager env) => Request -> m (Acquire (Response (ConduitM i ByteString n ())))

-- | TLS-powered manager settings.
--   
--   Since 2.1.0
defaultManagerSettings :: ManagerSettings

-- | Get a new manager using <a>defaultManagerSettings</a>.
--   
--   Since 2.1.0
newManager :: MonadIO m => m Manager

-- | Get a new manager with <a>defaultManagerSettings</a> and construct a
--   <tt>ReaderT</tt> containing it.
--   
--   Since 2.1.0
withManager :: MonadIO m => (ReaderT Manager m a) -> m a

-- | Get a new manager with the given settings and construct a
--   <tt>ReaderT</tt> containing it.
--   
--   Since 2.1.0
withManagerSettings :: MonadIO m => ManagerSettings -> (ReaderT Manager m a) -> m a

-- | Get a new manager using the given settings.
--   
--   Since 2.1.0
newManagerSettings :: MonadIO m => ManagerSettings -> m Manager
class HasHttpManager a
getHttpManager :: HasHttpManager a => a -> Manager

-- | Same as <a>httpLbs</a>, except it uses the <tt>Manager</tt> in the
--   reader environment.
--   
--   Since 2.1.1
httpLbs :: (MonadIO m, HasHttpManager env, MonadReader env m) => Request -> m (Response ByteString)

-- | Same as <a>httpNoBody</a>, except it uses the <tt>Manager</tt> in the
--   reader environment.
--   
--   This can be more convenient that using <a>withManager</a> as it avoids
--   the need to specify the base monad for the response body.
--   
--   Since 2.1.2
httpNoBody :: (MonadIO m, HasHttpManager env, MonadReader env m) => Request -> m (Response ())
requestBodySource :: Int64 -> Source IO ByteString -> RequestBody
requestBodySourceChunked :: Source IO ByteString -> RequestBody
bodyReaderSource :: MonadIO m => BodyReader -> Producer m ByteString
instance HasHttpManager Manager


-- | This module contains everything you need to initiate HTTP connections.
--   If you want a simple interface based on URLs, you can use
--   <a>simpleHttp</a>. If you want raw power, <a>http</a> is the
--   underlying workhorse of this package. Some examples:
--   
--   <pre>
--   -- Just download an HTML document and print it.
--   import Network.HTTP.Conduit
--   import qualified Data.ByteString.Lazy as L
--   
--   main = simpleHttp "http://www.haskell.org/" &gt;&gt;= L.putStr
--   </pre>
--   
--   This example uses interleaved IO to write the response body to a file
--   in constant memory space.
--   
--   <pre>
--   import Data.Conduit.Binary (sinkFile) -- Exported from the package conduit-extra
--   import Network.HTTP.Conduit
--   import qualified Data.Conduit as C
--   
--   main :: IO ()
--   main = do
--        request &lt;- parseUrl "http://google.com/"
--        withManager $ \manager -&gt; do
--            response &lt;- http request manager
--            responseBody response C.$$+- sinkFile "google.html"
--   </pre>
--   
--   The following headers are automatically set by this module, and should
--   not be added to <a>requestHeaders</a>:
--   
--   <ul>
--   <li>Cookie</li>
--   <li>Content-Length</li>
--   <li>Transfer-Encoding</li>
--   </ul>
--   
--   Note: In previous versions, the Host header would be set by this
--   module in all cases. Starting from 1.6.1, if a Host header is present
--   in <tt>requestHeaders</tt>, it will be used in place of the header
--   this module would have generated. This can be useful for calling a
--   server which utilizes virtual hosting.
--   
--   Use <a>cookieJar</a> If you want to supply cookies with your request:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   import Network.HTTP.Conduit
--   import Network
--   import Data.Time.Clock
--   import Data.Time.Calendar
--   import qualified Control.Exception as E
--   import Network.HTTP.Types.Status (statusCode)
--   
--   past :: UTCTime
--   past = UTCTime (ModifiedJulianDay 56200) (secondsToDiffTime 0)
--   
--   future :: UTCTime
--   future = UTCTime (ModifiedJulianDay 562000) (secondsToDiffTime 0)
--   
--   cookie :: Cookie
--   cookie = Cookie { cookie_name = "password_hash"
--                   , cookie_value = "abf472c35f8297fbcabf2911230001234fd2"
--                   , cookie_expiry_time = future
--                   , cookie_domain = "example.com"
--                   , cookie_path = "/"
--                   , cookie_creation_time = past
--                   , cookie_last_access_time = past
--                   , cookie_persistent = False
--                   , cookie_host_only = False
--                   , cookie_secure_only = False
--                   , cookie_http_only = False
--                   }
--   
--   main = withSocketsDo $ do
--        request' &lt;- parseUrl "http://example.com/secret-page"
--        let request = request' { cookieJar = Just $ createCookieJar [cookie] }
--        (fmap Just (withManager $ httpLbs request)) `E.catch`
--                (\(StatusCodeException s _ _) -&gt;
--                  if statusCode s==403 then (putStrLn "login failed" &gt;&gt; return Nothing) else return Nothing)
--   </pre>
--   
--   Any network code on Windows requires some initialization, and the
--   network library provides withSocketsDo to perform it. Therefore,
--   proper usage of this library will always involve calling that function
--   at some point. The best approach is to simply call them at the
--   beginning of your main function, such as:
--   
--   <pre>
--   import Network.HTTP.Conduit
--   import qualified Data.ByteString.Lazy as L
--   import Network (withSocketsDo)
--   
--   main = withSocketsDo
--        $ simpleHttp "http://www.haskell.org/" &gt;&gt;= L.putStr
--   </pre>
--   
--   Cookies are implemented according to RFC 6265.
--   
--   Note that by default, the functions in this package will throw
--   exceptions for non-2xx status codes. If you would like to avoid this,
--   you should use <a>checkStatus</a>, e.g.:
--   
--   <pre>
--   import Data.Conduit.Binary (sinkFile)
--   import Network.HTTP.Conduit
--   import qualified Data.Conduit as C
--   import Network
--   
--   main :: IO ()
--   main = withSocketsDo $ do
--        request' &lt;- parseUrl "http://www.yesodweb.com/does-not-exist"
--        let request = request' { checkStatus = \_ _ _ -&gt; Nothing }
--        res &lt;- withManager $ httpLbs request
--        print res
--   </pre>
--   
--   By default, when connecting to websites using HTTPS, functions in this
--   package will throw an exception if the TLS certificate doesn't
--   validate. To continue the HTTPS transaction even if the TLS cerficate
--   validation fails, you should use <tt>mkManagerSetttings</tt> as
--   follows:
--   
--   <pre>
--   import Network.Connection (TLSSettings (..))
--   import Network.HTTP.Conduit
--   
--   main :: IO ()
--   main = do
--       request &lt;- parseUrl "https://github.com/"
--       let settings = mkManagerSettings (TLSSettingsSimple True False False) Nothing
--       res &lt;- withManagerSettings settings $ httpLbs request
--       print res
--   </pre>
--   
--   For more information, please be sure to read the documentation in the
--   <a>Network.HTTP.Client</a> module.
module Network.HTTP.Conduit

-- | Download the specified URL, following any redirects, and return the
--   response body.
--   
--   This function will <tt>throwIO</tt> an <a>HttpException</a> for any
--   response with a non-2xx status code (besides 3xx redirects up to a
--   limit of 10 redirects). It uses <a>parseUrl</a> to parse the input.
--   This function essentially wraps <a>httpLbs</a>.
--   
--   Note: Even though this function returns a lazy bytestring, it does
--   <i>not</i> utilize lazy I/O, and therefore the entire response body
--   will live in memory. If you want constant memory usage, you'll need to
--   use the <tt>conduit</tt> package and <a>http</a> directly.
--   
--   Note: This function creates a new <a>Manager</a>. It should be avoided
--   in production code.
simpleHttp :: MonadIO m => String -> m ByteString

-- | Download the specified <a>Request</a>, returning the results as a
--   <a>Response</a>.
--   
--   This is a simplified version of <a>http</a> for the common case where
--   you simply want the response data as a simple datatype. If you want
--   more power, such as interleaved actions on the response body during
--   download, you'll need to use <a>http</a> directly. This function is
--   defined as:
--   
--   <pre>
--   httpLbs = <a>lbsResponse</a> &lt;=&lt; <a>http</a>
--   </pre>
--   
--   Even though the <a>Response</a> contains a lazy bytestring, this
--   function does <i>not</i> utilize lazy I/O, and therefore the entire
--   response body will live in memory. If you want constant memory usage,
--   you'll need to use <tt>conduit</tt> packages's <a>Source</a> returned
--   by <a>http</a>.
--   
--   This function will <tt>throwIO</tt> an <a>HttpException</a> for any
--   response with a non-2xx status code (besides 3xx redirects up to a
--   limit of 10 redirects). This behavior can be modified by changing the
--   <a>checkStatus</a> field of your request.
--   
--   Note: Unlike previous versions, this function will perform redirects,
--   as specified by the <a>redirectCount</a> setting.
httpLbs :: MonadIO m => Request -> Manager -> m (Response ByteString)
http :: MonadResource m => Request -> Manager -> m (Response (ResumableSource m ByteString))

-- | Define a HTTP proxy, consisting of a hostname and port number.
data Proxy :: *
Proxy :: ByteString -> Int -> Proxy

-- | The host name of the HTTP proxy.
proxyHost :: Proxy -> ByteString

-- | The port number of the HTTP proxy.
proxyPort :: Proxy -> Int

-- | When using one of the <a>RequestBodyStream</a> /
--   <a>RequestBodyStreamChunked</a> constructors, you must ensure that the
--   <a>GivesPopper</a> can be called multiple times. Usually this is not a
--   problem.
--   
--   The <a>RequestBodyStreamChunked</a> will send a chunked request body.
--   Note that not all servers support this. Only use
--   <a>RequestBodyStreamChunked</a> if you know the server you're sending
--   to supports chunked request bodies.
--   
--   Since 0.1.0
data RequestBody :: *
RequestBodyLBS :: ByteString -> RequestBody
RequestBodyBS :: ByteString -> RequestBody
RequestBodyBuilder :: Int64 -> Builder -> RequestBody
RequestBodyStream :: Int64 -> GivesPopper () -> RequestBody
RequestBodyStreamChunked :: GivesPopper () -> RequestBody

-- | All information on how to connect to a host and what should be sent in
--   the HTTP request.
--   
--   If you simply wish to download from a URL, see <tt>parseUrl</tt>.
--   
--   The constructor for this data type is not exposed. Instead, you should
--   use either the <a>def</a> method to retrieve a default instance, or
--   <tt>parseUrl</tt> to construct from a URL, and then use the records
--   below to make modifications. This approach allows http-client to add
--   configuration options without breaking backwards compatibility.
--   
--   For example, to construct a POST request, you could do something like:
--   
--   <pre>
--   initReq &lt;- parseUrl "http://www.example.com/path"
--   let req = initReq
--               { method = "POST"
--               }
--   </pre>
--   
--   For more information, please see
--   <a>http://www.yesodweb.com/book/settings-types</a>.
--   
--   Since 0.1.0
data Request :: *

-- | HTTP request method, eg GET, POST.
--   
--   Since 0.1.0
method :: Request -> Method

-- | Whether to use HTTPS (ie, SSL).
--   
--   Since 0.1.0
secure :: Request -> Bool

-- | Requested host name, used for both the IP address to connect to and
--   the <tt>host</tt> request header.
--   
--   Since 0.1.0
host :: Request -> ByteString

-- | The port to connect to. Also used for generating the <tt>host</tt>
--   request header.
--   
--   Since 0.1.0
port :: Request -> Int

-- | Everything from the host to the query string.
--   
--   Since 0.1.0
path :: Request -> ByteString

-- | Query string appended to the path.
--   
--   Since 0.1.0
queryString :: Request -> ByteString

-- | Custom HTTP request headers
--   
--   The Content-Length and Transfer-Encoding headers are set automatically
--   by this module, and shall not be added to <tt>requestHeaders</tt>.
--   
--   If not provided by the user, <tt>Host</tt> will automatically be set
--   based on the <tt>host</tt> and <tt>port</tt> fields.
--   
--   Moreover, the Accept-Encoding header is set implicitly to gzip for
--   convenience by default. This behaviour can be overridden if needed, by
--   setting the header explicitly to a different value. In order to omit
--   the Accept-Header altogether, set it to the empty string "". If you
--   need an empty Accept-Header (i.e. requesting the identity encoding),
--   set it to a non-empty white-space string, e.g. " ". See RFC 2616
--   section 14.3 for details about the semantics of the Accept-Header
--   field. If you request a content-encoding not supported by this module,
--   you will have to decode it yourself (see also the <a>decompress</a>
--   field).
--   
--   Note: Multiple header fields with the same field-name will result in
--   multiple header fields being sent and therefore it's the
--   responsibility of the client code to ensure that the rules from RFC
--   2616 section 4.2 are honoured.
--   
--   Since 0.1.0
requestHeaders :: Request -> RequestHeaders

-- | Request body to be sent to the server.
--   
--   Since 0.1.0
requestBody :: Request -> RequestBody

-- | Optional HTTP proxy.
--   
--   Since 0.1.0
proxy :: Request -> Maybe Proxy

-- | Optional resolved host address. May not be used by all backends.
--   
--   Since 0.1.0
hostAddress :: Request -> Maybe HostAddress

-- | If <tt>True</tt>, a chunked and/or gzipped body will not be decoded.
--   Use with caution.
--   
--   Since 0.1.0
rawBody :: Request -> Bool

-- | Predicate to specify whether gzipped data should be decompressed on
--   the fly (see <tt>alwaysDecompress</tt> and
--   <tt>browserDecompress</tt>). Argument is the mime type. Default:
--   browserDecompress.
--   
--   Since 0.1.0
decompress :: Request -> ByteString -> Bool

-- | How many redirects to follow when getting a resource. 0 means follow
--   no redirects. Default value: 10.
--   
--   Since 0.1.0
redirectCount :: Request -> Int

-- | Check the status code. Note that this will run after all redirects are
--   performed. Default: return a <tt>StatusCodeException</tt> on non-2XX
--   responses.
--   
--   Since 0.1.0
checkStatus :: Request -> Status -> ResponseHeaders -> CookieJar -> Maybe SomeException

-- | Number of microseconds to wait for a response. If <tt>Nothing</tt>,
--   will wait indefinitely. Default: use <a>managerResponseTimeout</a>
--   (which by default is 30 seconds).
--   
--   Since 0.1.0
responseTimeout :: Request -> Maybe Int

-- | A user-defined cookie jar. If <a>Nothing</a>, no cookie handling will
--   take place, "Cookie" headers in <a>requestHeaders</a> will be sent
--   raw, and <a>responseCookieJar</a> will be empty.
--   
--   Since 0.1.0
cookieJar :: Request -> Maybe CookieJar

-- | HTTP version to send to server.
--   
--   Default: HTTP 1.1
--   
--   Since 0.4.3
requestVersion :: Request -> HttpVersion

-- | Wraps the calls for getting new connections. This can be useful for
--   instituting some kind of timeouts. The first argument is the value of
--   <tt>responseTimeout</tt>. Second argument is the exception to be
--   thrown on failure.
--   
--   Default: If <tt>responseTimeout</tt> is <tt>Nothing</tt>, does
--   nothing. Otherwise, institutes timeout, and returns remaining time for
--   <tt>responseTimeout</tt>.
--   
--   Since 0.1.0
getConnectionWrapper :: Request -> Maybe Int -> HttpException -> IO (ConnRelease, Connection, ManagedConn) -> IO (Maybe Int, (ConnRelease, Connection, ManagedConn))

-- | Set the query string to the given key/value pairs.
--   
--   Since 0.3.6
setQueryString :: [(ByteString, Maybe ByteString)] -> Request -> Request
requestBodySource :: Int64 -> Source (ResourceT IO) ByteString -> RequestBody
requestBodySourceChunked :: Source (ResourceT IO) ByteString -> RequestBody
requestBodySourceIO :: Int64 -> Source IO ByteString -> RequestBody
requestBodySourceChunkedIO :: Source IO ByteString -> RequestBody

-- | A simple representation of the HTTP response.
--   
--   Since 0.1.0
data Response body :: * -> *

-- | Status code of the response.
--   
--   Since 0.1.0
responseStatus :: Response body -> Status

-- | HTTP version used by the server.
--   
--   Since 0.1.0
responseVersion :: Response body -> HttpVersion

-- | Response headers sent by the server.
--   
--   Since 0.1.0
responseHeaders :: Response body -> ResponseHeaders

-- | Response body sent by the server.
--   
--   Since 0.1.0
responseBody :: Response body -> body

-- | Cookies set on the client after interacting with the server. If
--   cookies have been disabled by setting <a>cookieJar</a> to
--   <tt>Nothing</tt>, then this will always be empty.
--   
--   Since 0.1.0
responseCookieJar :: Response body -> CookieJar

-- | Keeps track of open connections for keep-alive.
--   
--   If possible, you should share a single <a>Manager</a> between multiple
--   threads and requests.
--   
--   Since 0.1.0
data Manager :: *

-- | Create a <a>Manager</a>. You may manually call <a>closeManager</a> to
--   shut it down, or allow the <tt>Manager</tt> to be shut down
--   automatically based on garbage collection.
--   
--   Creating a new <a>Manager</a> is a relatively expensive operation, you
--   are advised to share a single <a>Manager</a> between requests instead.
--   
--   The first argument to this function is often
--   <a>defaultManagerSettings</a>, though add-on libraries may provide a
--   recommended replacement.
--   
--   Since 0.1.0
newManager :: ManagerSettings -> IO Manager

-- | Close all connections in a <a>Manager</a>.
--   
--   Note that this doesn't affect currently in-flight connections, meaning
--   you can safely use it without hurting any queries you may have
--   concurrently running.
--   
--   Since 0.1.0
closeManager :: Manager -> IO ()
withManager :: (MonadIO m, MonadBaseControl IO m) => (Manager -> ResourceT m a) -> m a
withManagerSettings :: (MonadIO m, MonadBaseControl IO m) => ManagerSettings -> (Manager -> ResourceT m a) -> m a

-- | Settings for a <tt>Manager</tt>. Please use the
--   <tt>defaultManagerSettings</tt> function and then modify individual
--   settings. For more information, see
--   <a>http://www.yesodweb.com/book/settings-types</a>.
--   
--   Since 0.1.0
data ManagerSettings :: *
conduitManagerSettings :: ManagerSettings
mkManagerSettings :: TLSSettings -> Maybe SockSettings -> ManagerSettings

-- | Number of connections to a single host to keep alive. Default: 10.
--   
--   Since 0.1.0
managerConnCount :: ManagerSettings -> Int

-- | Default timeout (in microseconds) to be applied to requests which do
--   not provide a timeout value.
--   
--   Default is 30 seconds
--   
--   Since 0.1.0
managerResponseTimeout :: ManagerSettings -> Maybe Int

-- | Create a TLS connection. Default behavior: throw an exception that TLS
--   is not supported.
--   
--   Since 0.1.0
managerTlsConnection :: ManagerSettings -> IO (Maybe HostAddress -> String -> Int -> IO Connection)
data Cookie :: *
Cookie :: ByteString -> ByteString -> UTCTime -> ByteString -> ByteString -> UTCTime -> UTCTime -> Bool -> Bool -> Bool -> Bool -> Cookie
cookie_name :: Cookie -> ByteString
cookie_value :: Cookie -> ByteString
cookie_expiry_time :: Cookie -> UTCTime
cookie_domain :: Cookie -> ByteString
cookie_path :: Cookie -> ByteString
cookie_creation_time :: Cookie -> UTCTime
cookie_last_access_time :: Cookie -> UTCTime
cookie_persistent :: Cookie -> Bool
cookie_host_only :: Cookie -> Bool
cookie_secure_only :: Cookie -> Bool
cookie_http_only :: Cookie -> Bool
data CookieJar :: *
createCookieJar :: [Cookie] -> CookieJar
destroyCookieJar :: CookieJar -> [Cookie]

-- | Convert a URL into a <a>Request</a>.
--   
--   This defaults some of the values in <a>Request</a>, such as setting
--   <a>method</a> to GET and <a>requestHeaders</a> to <tt>[]</tt>.
--   
--   Since this function uses <a>MonadThrow</a>, the return monad can be
--   anything that is an instance of <a>MonadThrow</a>, such as <a>IO</a>
--   or <a>Maybe</a>.
--   
--   Since 0.1.0
parseUrl :: MonadThrow m => String -> m Request

-- | Add a Basic Auth header (with the specified user name and password) to
--   the given Request. Ignore error handling:
--   
--   <pre>
--   applyBasicAuth "user" "pass" $ fromJust $ parseUrl url
--   </pre>
--   
--   Since 0.1.0
applyBasicAuth :: ByteString -> ByteString -> Request -> Request

-- | Add a proxy to the Request so that the Request when executed will use
--   the provided proxy.
--   
--   Since 0.1.0
addProxy :: ByteString -> Int -> Request -> Request
lbsResponse :: Monad m => Response (ResumableSource m ByteString) -> m (Response ByteString)

-- | If a request is a redirection (status code 3xx) this function will
--   create a new request from the old request, the server headers returned
--   with the redirection, and the redirection code itself. This function
--   returns <a>Nothing</a> if the code is not a 3xx, there is no
--   <tt>location</tt> header included, or if the redirected response
--   couldn't be parsed with <a>parseUrl</a>.
--   
--   If a user of this library wants to know the url chain that results
--   from a specific request, that user has to re-implement the
--   redirect-following logic themselves. An example of that might look
--   like this:
--   
--   <pre>
--   myHttp req man = do
--      (res, redirectRequests) &lt;- (`runStateT` []) $
--           'httpRedirect'
--               9000
--               (\req' -&gt; do
--                  res &lt;- http req'{redirectCount=0} man
--                  modify (\rqs -&gt; req' : rqs)
--                  return (res, getRedirectedRequest req' (responseHeaders res) (responseCookieJar res) (W.statusCode (responseStatus res))
--                  )
--               'lift'
--               req
--      applyCheckStatus (checkStatus req) res
--      return redirectRequests
--   </pre>
getRedirectedRequest :: Request -> ResponseHeaders -> CookieJar -> Int -> Maybe Request

-- | Always decompress a compressed stream.
alwaysDecompress :: ByteString -> Bool

-- | Decompress a compressed stream unless the content-type is
--   'application/x-tar'.
browserDecompress :: ByteString -> Bool

-- | Add url-encoded parameters to the <a>Request</a>.
--   
--   This sets a new <a>requestBody</a>, adds a content-type request header
--   and changes the <a>method</a> to POST.
--   
--   Since 0.1.0
urlEncodedBody :: [(ByteString, ByteString)] -> Request -> Request
data HttpException :: *
StatusCodeException :: Status -> ResponseHeaders -> CookieJar -> HttpException
InvalidUrlException :: String -> String -> HttpException

-- | List of encountered responses containing redirects in reverse
--   chronological order; including last redirect, which triggered the
--   exception and was not followed.
TooManyRedirects :: [Response ByteString] -> HttpException

-- | Response containing unparseable redirect.
UnparseableRedirect :: Response ByteString -> HttpException
TooManyRetries :: HttpException
HttpParserException :: String -> HttpException
HandshakeFailed :: HttpException
OverlongHeaders :: HttpException
ResponseTimeout :: HttpException

-- | host/port
--   
--   Note that in old versions of http-client and http-conduit, this
--   exception would indicate a failed attempt to create a connection.
--   However, since (at least) http-client 0.4, it indicates a timeout
--   occurred while trying to establish the connection. For more
--   information on this, see:
--   
--   
--   <a>https://github.com/snoyberg/http-client/commit/b86b1cdd91e56ee33150433dedb32954d2082621#commitcomment-10718689</a>
FailedConnectionException :: String -> Int -> HttpException

-- | host<i>port</i>secure
FailedConnectionException2 :: String -> Int -> Bool -> SomeException -> HttpException
ExpectedBlankAfter100Continue :: HttpException
InvalidStatusLine :: ByteString -> HttpException
InvalidHeader :: ByteString -> HttpException
InternalIOException :: IOException -> HttpException

-- | host/port
ProxyConnectException :: ByteString -> Int -> Either ByteString HttpException -> HttpException
NoResponseDataReceived :: HttpException
TlsException :: SomeException -> HttpException
TlsNotSupported :: HttpException

-- | Expected size/actual size.
--   
--   Since 1.9.4
ResponseBodyTooShort :: Word64 -> Word64 -> HttpException

-- | Since 1.9.4
InvalidChunkHeaders :: HttpException
IncompleteHeaders :: HttpException
InvalidDestinationHost :: ByteString -> HttpException

-- | Since 0.3
HttpZlibException :: ZlibException -> HttpException

-- | Environment name and value
--   
--   Since 0.4.7
InvalidProxyEnvironmentVariable :: Text -> Text -> HttpException

-- | Detect a case where both the <tt>content-length</tt> header and
--   <tt>transfer-encoding: chunked</tt> are used. Since 0.4.8.
--   
--   Since 0.4.11 this exception isn't thrown anymore.
ResponseLengthAndChunkingBothUsed :: HttpException
