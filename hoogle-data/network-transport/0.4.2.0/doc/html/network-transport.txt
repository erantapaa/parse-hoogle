-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Network abstraction layer
--   
@package network-transport
@version 0.4.2.0


-- | Internal functions
module Network.Transport.Internal

-- | Serialize 32-bit to network byte order
encodeInt32 :: Enum a => a -> ByteString

-- | Deserialize 32-bit from network byte order Throws an IO exception if
--   this is not a valid integer.
decodeInt32 :: Num a => ByteString -> a

-- | Serialize 16-bit to network byte order
encodeInt16 :: Enum a => a -> ByteString

-- | Deserialize 16-bit from network byte order Throws an IO exception if
--   this is not a valid integer
decodeInt16 :: Num a => ByteString -> a

-- | Prepend a list of bytestrings with their total length
prependLength :: [ByteString] -> [ByteString]

-- | Translate exceptions that arise in IO computations
mapIOException :: Exception e => (IOException -> e) -> IO a -> IO a

-- | Like <a>try</a>, but lifted and specialized to IOExceptions
tryIO :: MonadIO m => IO a -> m (Either IOException a)

-- | Safe version of <a>toEnum</a>
tryToEnum :: (Enum a, Bounded a) => Int -> Maybe a

-- | If the timeout value is not Nothing, wrap the given computation with a
--   timeout and it if times out throw the specified exception. Identity
--   otherwise.
timeoutMaybe :: Exception e => Maybe Int -> e -> IO a -> IO a

-- | <tt>asyncWhenCancelled g f</tt> runs f in a separate thread and waits
--   for it to complete. If f throws an exception we catch it and rethrow
--   it in the current thread. If the current thread is interrupted before
--   f completes, we run the specified clean up handler (if f throws an
--   exception we assume that no cleanup is necessary).
asyncWhenCancelled :: (a -> IO ()) -> IO a -> IO a

-- | Not all versions of "base" export <a>void</a>
void :: Monad m => m a -> m ()

-- | This was introduced in "base" some time after 7.0.4
forkIOWithUnmask :: ((forall a. IO a -> IO a) -> IO ()) -> IO ThreadId

-- | Logging (for debugging)
tlog :: MonadIO m => String -> m ()


-- | Network Transport
module Network.Transport

-- | To create a network abstraction layer, use one of the
--   <tt>Network.Transport.*</tt> packages.
data Transport
Transport :: IO (Either (TransportError NewEndPointErrorCode) EndPoint) -> IO () -> Transport

-- | Create a new end point (heavyweight operation)
newEndPoint :: Transport -> IO (Either (TransportError NewEndPointErrorCode) EndPoint)

-- | Shutdown the transport completely
closeTransport :: Transport -> IO ()

-- | Network endpoint.
data EndPoint
EndPoint :: IO Event -> EndPointAddress -> (EndPointAddress -> Reliability -> ConnectHints -> IO (Either (TransportError ConnectErrorCode) Connection)) -> IO (Either (TransportError NewMulticastGroupErrorCode) MulticastGroup) -> (MulticastAddress -> IO (Either (TransportError ResolveMulticastGroupErrorCode) MulticastGroup)) -> IO () -> EndPoint

-- | Endpoints have a single shared receive queue.
receive :: EndPoint -> IO Event

-- | EndPointAddress of the endpoint.
address :: EndPoint -> EndPointAddress

-- | Create a new lightweight connection.
--   
--   <a>connect</a> should be as asynchronous as possible; for instance, in
--   Transport implementations based on some heavy-weight underlying
--   network protocol (TCP, ssh), a call to <a>connect</a> should be
--   asynchronous when a heavyweight connection has already been
--   established.
connect :: EndPoint -> EndPointAddress -> Reliability -> ConnectHints -> IO (Either (TransportError ConnectErrorCode) Connection)

-- | Create a new multicast group.
newMulticastGroup :: EndPoint -> IO (Either (TransportError NewMulticastGroupErrorCode) MulticastGroup)

-- | Resolve an address to a multicast group.
resolveMulticastGroup :: EndPoint -> MulticastAddress -> IO (Either (TransportError ResolveMulticastGroupErrorCode) MulticastGroup)

-- | Close the endpoint
closeEndPoint :: EndPoint -> IO ()

-- | Lightweight connection to an endpoint.
data Connection
Connection :: ([ByteString] -> IO (Either (TransportError SendErrorCode) ())) -> IO () -> Connection

-- | Send a message on this connection.
--   
--   <a>send</a> provides vectored I/O, and allows multiple data segments
--   to be sent using a single call (cf. <a>sendMany</a>). Note that this
--   segment structure is entirely unrelated to the segment structure
--   <i>returned</i> by a <a>Received</a> event.
send :: Connection -> [ByteString] -> IO (Either (TransportError SendErrorCode) ())

-- | Close the connection.
close :: Connection -> IO ()

-- | Event on an endpoint.
data Event

-- | Received a message
Received :: {-# UNPACK #-} !ConnectionId -> [ByteString] -> Event

-- | Connection closed
ConnectionClosed :: {-# UNPACK #-} !ConnectionId -> Event

-- | Connection opened
--   
--   <a>ConnectionId</a>s need not be allocated contiguously.
ConnectionOpened :: {-# UNPACK #-} !ConnectionId -> Reliability -> EndPointAddress -> Event

-- | Received multicast
ReceivedMulticast :: MulticastAddress -> [ByteString] -> Event

-- | The endpoint got closed (manually, by a call to closeEndPoint or
--   closeTransport)
EndPointClosed :: Event

-- | An error occurred
ErrorEvent :: (TransportError EventErrorCode) -> Event

-- | Connection data ConnectHintsIDs enable receivers to distinguish one
--   connection from another.
type ConnectionId = Word64

-- | Reliability guarantees of a connection.
data Reliability
ReliableOrdered :: Reliability
ReliableUnordered :: Reliability
Unreliable :: Reliability

-- | Multicast group.
data MulticastGroup
MulticastGroup :: MulticastAddress -> IO () -> Maybe Int -> ([ByteString] -> IO ()) -> IO () -> IO () -> IO () -> MulticastGroup

-- | EndPointAddress of the multicast group.
multicastAddress :: MulticastGroup -> MulticastAddress

-- | Delete the multicast group completely.
deleteMulticastGroup :: MulticastGroup -> IO ()

-- | Maximum message size that we can send to this group.
maxMsgSize :: MulticastGroup -> Maybe Int

-- | Send a message to the group.
multicastSend :: MulticastGroup -> [ByteString] -> IO ()

-- | Subscribe to the given multicast group (to start receiving messages
--   from the group).
multicastSubscribe :: MulticastGroup -> IO ()

-- | Unsubscribe from the given multicast group (to stop receiving messages
--   from the group).
multicastUnsubscribe :: MulticastGroup -> IO ()

-- | Close the group (that is, indicate you no longer wish to send to the
--   group).
multicastClose :: MulticastGroup -> IO ()

-- | EndPointAddress of an endpoint.
newtype EndPointAddress
EndPointAddress :: ByteString -> EndPointAddress
endPointAddressToByteString :: EndPointAddress -> ByteString

-- | EndPointAddress of a multicast group.
newtype MulticastAddress
MulticastAddress :: ByteString -> MulticastAddress
multicastAddressToByteString :: MulticastAddress -> ByteString

-- | Hints used by <a>connect</a>
data ConnectHints
ConnectHints :: Maybe Int -> ConnectHints
connectTimeout :: ConnectHints -> Maybe Int

-- | Default hints for connecting
defaultConnectHints :: ConnectHints

-- | Errors returned by Network.Transport API functions consist of an error
--   code and a human readable description of the problem
data TransportError error
TransportError :: error -> String -> TransportError error

-- | Errors during the creation of an endpoint
data NewEndPointErrorCode

-- | Not enough resources
NewEndPointInsufficientResources :: NewEndPointErrorCode

-- | Failed for some other reason
NewEndPointFailed :: NewEndPointErrorCode

-- | Connection failure
data ConnectErrorCode

-- | Could not resolve the address
ConnectNotFound :: ConnectErrorCode

-- | Insufficient resources (for instance, no more sockets available)
ConnectInsufficientResources :: ConnectErrorCode

-- | Timeout
ConnectTimeout :: ConnectErrorCode

-- | Failed for other reasons (including syntax error)
ConnectFailed :: ConnectErrorCode

-- | Failure during the creation of a new multicast group
data NewMulticastGroupErrorCode

-- | Insufficient resources
NewMulticastGroupInsufficientResources :: NewMulticastGroupErrorCode

-- | Failed for some other reason
NewMulticastGroupFailed :: NewMulticastGroupErrorCode

-- | Not all transport implementations support multicast
NewMulticastGroupUnsupported :: NewMulticastGroupErrorCode

-- | Failure during the resolution of a multicast group
data ResolveMulticastGroupErrorCode

-- | Multicast group not found
ResolveMulticastGroupNotFound :: ResolveMulticastGroupErrorCode

-- | Failed for some other reason (including syntax error)
ResolveMulticastGroupFailed :: ResolveMulticastGroupErrorCode

-- | Not all transport implementations support multicast
ResolveMulticastGroupUnsupported :: ResolveMulticastGroupErrorCode

-- | Failure during sending a message
data SendErrorCode

-- | Connection was closed
SendClosed :: SendErrorCode

-- | Send failed for some other reason
SendFailed :: SendErrorCode

-- | Error codes used when reporting errors to endpoints (through receive)
data EventErrorCode

-- | Failure of the entire endpoint
EventEndPointFailed :: EventErrorCode

-- | Transport-wide fatal error
EventTransportFailed :: EventErrorCode

-- | We lost connection to another endpoint
--   
--   Although <a>Network.Transport</a> provides multiple independent
--   lightweight connections between endpoints, those connections cannot
--   <i>fail</i> independently: once one connection has failed, <i>all</i>
--   connections, in both directions, must now be considered to have
--   failed; they fail as a "bundle" of connections, with only a single
--   "bundle" of connections per endpoint at any point in time.
--   
--   That is, suppose there are multiple connections in either direction
--   between endpoints A and B, and A receives a notification that it has
--   lost contact with B. Then A must not be able to send any further
--   messages to B on existing connections.
--   
--   Although B may not realize <i>immediately</i> that its connection to A
--   has been broken, messages sent by B on existing connections should not
--   be delivered, and B must eventually get an EventConnectionLost
--   message, too.
--   
--   Moreover, this event must be posted before A has successfully
--   reconnected (in other words, if B notices a reconnection attempt from
--   A, it must post the EventConnectionLost before acknowledging the
--   connection from A) so that B will not receive events about new
--   connections or incoming messages from A without realizing that it got
--   disconnected.
--   
--   If B attempts to establish another connection to A before it realized
--   that it got disconnected from A then it's okay for this connection
--   attempt to fail, and the EventConnectionLost to be posted at that
--   point, or for the EventConnectionLost to be posted and for the new
--   connection to be considered the first connection of the "new bundle".
EventConnectionLost :: EndPointAddress -> EventErrorCode
instance Typeable Reliability
instance Typeable EndPointAddress
instance Typeable TransportError
instance Typeable NewEndPointErrorCode
instance Typeable ConnectErrorCode
instance Typeable NewMulticastGroupErrorCode
instance Typeable ResolveMulticastGroupErrorCode
instance Typeable SendErrorCode
instance Typeable EventErrorCode
instance Show Reliability
instance Eq Reliability
instance Eq EndPointAddress
instance Ord EndPointAddress
instance Data EndPointAddress
instance Hashable EndPointAddress
instance Eq MulticastAddress
instance Ord MulticastAddress
instance Show error => Show (TransportError error)
instance Show NewEndPointErrorCode
instance Eq NewEndPointErrorCode
instance Show ConnectErrorCode
instance Eq ConnectErrorCode
instance Show NewMulticastGroupErrorCode
instance Eq NewMulticastGroupErrorCode
instance Show ResolveMulticastGroupErrorCode
instance Eq ResolveMulticastGroupErrorCode
instance Show SendErrorCode
instance Eq SendErrorCode
instance Show EventErrorCode
instance Eq EventErrorCode
instance Show Event
instance Eq Event
instance Eq error => Eq (TransportError error)
instance (Typeable err, Show err) => Exception (TransportError err)
instance Show MulticastAddress
instance NFData EndPointAddress
instance Show EndPointAddress
instance Binary EndPointAddress
instance Binary Reliability


-- | Utility functions
--   
--   Note: this module is bound to change even more than the rest of the
--   API :)
module Network.Transport.Util

-- | Fork a new thread, create a new end point on that thread, and run the
--   specified IO operation on that thread.
--   
--   Returns the address of the new end point.
spawn :: Transport -> (EndPoint -> IO ()) -> IO EndPointAddress
