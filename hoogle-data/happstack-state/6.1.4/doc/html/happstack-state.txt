-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Event-based distributed state.
--   
--   Unplug your machine and restart and have your app recover to exactly
--   where it left off. Happstack-State spares you the need to deal with
--   all the marshalling, consistency, and configuration headache that you
--   would have if you used an external DBMS for this purpose. Its
--   component model makes it easy to compose big applications from smaller
--   reliable parts. Use event subscription to trigger IO actions and
--   support comet-style or irc-bot applications.
@package happstack-state
@version 6.1.4

module Happstack.State.Saver.Types
data ReaderStream a
ReaderStream :: IO () -> IO ([a], Int) -> IO [a] -> ReaderStream a
readerClose :: ReaderStream a -> IO ()
readerGet :: ReaderStream a -> IO ([a], Int)
readerGetUncut :: ReaderStream a -> IO [a]
data WriterStream a
WriterStream :: IO () -> (a -> IO () -> IO ()) -> (a -> IO ()) -> IO Int -> WriterStream a
writerClose :: WriterStream a -> IO ()
writerAdd :: WriterStream a -> a -> IO () -> IO ()
writerAtomicReplace :: WriterStream a -> a -> IO ()
writerCut :: WriterStream a -> IO Int

module Happstack.State.Saver.Impl.File
data PrefixLock
fileReader :: Serialize a => FilePath -> String -> Int -> IO (ReaderStream a)
fileWriter :: Serialize a => FilePath -> String -> Int -> IO (WriterStream a)
obtainPrefixLock :: FilePath -> IO PrefixLock

-- | Relinquish the lock by removing it and then verifying the removal.
releasePrefixLock :: PrefixLock -> IO ()

module Happstack.State.Saver.Impl.Memory
type Store = Map String (Map Int ByteString)
newMemoryStore :: IO (MVar Store)
memoryReader :: Serialize a => MVar Store -> String -> Int -> IO (ReaderStream a)
memoryWriter :: Serialize a => MVar Store -> String -> Int -> IO (WriterStream a)
parseAll :: Serialize a => ByteString -> [a]
addToStore :: (Ord a, Ord b) => a -> b -> ByteString -> Map a (Map b ByteString) -> Map a (Map b ByteString)
setStore :: Ord a => a -> b -> c -> Map a (Map b c) -> Map a (Map b c)

module Happstack.State.Saver.Impl.Queue
queueReader :: ReaderStream a -> IO (ReaderStream a)

-- | A saver that bunches writes.
queueWriter :: Serialize a => WriterStream Encoded -> IO (WriterStream a)
instance [overlap ok] Typeable Encoded
instance [overlap ok] Serialize Encoded
instance [overlap ok] Version Encoded

module Happstack.State.Saver
data PrefixLock
data Saver

-- | A saver that discards all output
NullSaver :: Saver

-- | A saver that operates on files. The parameter is the prefix for the
--   files.
FileSaver :: String -> Saver

-- | Enable queueing.
Queue :: Saver -> Saver
Memory :: (MVar Store) -> Saver

-- | Dispatches over the Saver type provided to return a
--   <a>ReaderStream</a> for the inferred type.
createReader :: Serialize a => Saver -> String -> Int -> IO (ReaderStream a)

-- | Dispatches over the Saver type provided to return a WriterStream for
--   the inferred type.
createWriter :: Serialize a => Saver -> String -> Int -> IO (WriterStream a)
obtainLock :: Saver -> IO (Maybe PrefixLock)
releaseLock :: Maybe PrefixLock -> IO ()

module Happstack.State.ComponentSystem

-- | Equivalent of [] for type level lists. Used for Components that have
--   no dependencies
data End
End :: End

-- | Type level Cons for enumerating type dependencies of a Component
data (:+:) h t
(:+:) :: h -> t -> :+: h t
class (Serialize ev, Serialize res) => UpdateEvent ev res | ev -> res
class (Serialize ev, Serialize res) => QueryEvent ev res | ev -> res

-- | Method is the actual type that all Updates and Querys eventually get
--   lifted into via <tt>mkMethods</tt>.
data Method st
Update :: (ev -> Update st res) -> Method st
Query :: (ev -> Query st res) -> Method st

-- | Displays the type of a Method
methodType :: Method t -> String

-- | Class for enumerating the set of defined methods by the type of the
--   state. Instances should not be defined directly, but using
--   <tt>mkMethods</tt>
class Methods a
methods :: Methods a => Proxy a -> [Method a]
data MethodMap
MethodMap :: Map String (Method st) -> MethodMap

-- | State type -&gt; method map
type ComponentTree = Map String MethodMap

-- | State type -&gt; all versions
type ComponentVersions = Map String [ByteString]

-- | In order to be used as a part of Happstack's MACID state, a data type
--   needs to be an instance of Component. The minimal definition is an
--   initialValue and the type corresponding to the set of Dependencies.
--   Note that the SubHandlers condition will be automatically met if the
--   Dependencies is built from <a>End</a> and <a>:+:</a> with other
--   instances of Component and Methods
class (SubHandlers (Dependencies a), Serialize a) => Component a where type family Dependencies a onLoad _ = return ()
initialValue :: Component a => a
onLoad :: Component a => Proxy a -> IO ()

-- | SubHandlers is used to build up the set of components corresponding to
--   the instance type.
class SubHandlers a
subHandlers :: SubHandlers a => a -> Collect ()
data Collection
Collection :: ComponentTree -> ComponentVersions -> [IO ()] -> Collection
addItem :: MonadState Collection m => String -> MethodMap -> [ByteString] -> IO () -> m ()
type Collect = State Collection
collectHandlers :: (Methods a, Component a) => Proxy a -> (ComponentTree, ComponentVersions, [IO ()])
collectHandlers' :: (Methods a, Component a) => Proxy a -> Collect ()

-- | An error is thrown when this is evaluated.
dup :: String -> b
instance [overlap ok] (Methods a, Component a, SubHandlers b) => SubHandlers (a :+: b)
instance [overlap ok] SubHandlers End
instance [overlap ok] Show MethodMap
instance [overlap ok] Show (Method st)

module Happstack.State.ComponentTH

-- | This function will derive, for the provided type name and the provided
--   list of methods, an instance of Methods for the given type and
--   necessary instance of UpdateEvent and QueryEvent to make the provided
--   list of functions into Methods. This TH splice needs to be executed
--   for any MACID state type in order to have the necessary code for event
--   handling generated. Ex: <tt>$(mkMethods ''Foo
--   ['fooUpdate,<tt>fooQuery</tt>])</tt>
mkMethods :: Name -> [Name] -> Q [Dec]

module Happstack.State.Transaction
type ExceptionT = SomeException
logMT :: Priority -> String -> IO ()
getTime :: Integral epochTime => AnyEv epochTime
getEventClockTime :: AnyEv ClockTime
getEventId :: Integral txId => AnyEv txId
data GetCheckpointState
GetCheckpointState :: GetCheckpointState
newtype SetCheckpointState
SetCheckpointState :: ByteString -> SetCheckpointState
type TypeString = String
data EventHandler
UpdateHandler :: (TxContext -> ev -> IO res) -> (ev -> IO res) -> (Object -> ev) -> EventHandler
QueryHandler :: (ev -> IO res) -> (Object -> ev) -> EventHandler
type EventMap = Map TypeString EventHandler
data EmitInternal
EmitInternal :: EventMap -> EmitInternal
emitRef :: IORef EmitInternal
emitFunc :: (Serialize ev, Typeable res) => EventMap -> TypeString -> ev -> IO res
emitEvent' :: (Serialize ev, Typeable res) => TypeString -> ev -> IO res
emitEvent :: (Serialize ev, Typeable res) => ev -> IO res
setNewEventMap :: EventMap -> IO ()
data EventItem
EventItem :: TxContext -> Dynamic -> EventItem
eventContext :: EventItem -> TxContext
eventData :: EventItem -> Dynamic
eventStreamRef :: MVar (Chan EventItem)
initEventStream :: IO ()
pushEventItem :: Serialize ev => TxContext -> ev -> IO ()
getEventStream :: IO (IO EventItem)
createEventMap :: (Methods st, Component st) => MVar TxControl -> Proxy st -> IO EventMap
extraEvents :: Serialize st => TxRun st -> EventMap
allStateTypes :: (Methods a, Component a) => Proxy a -> [TypeString]
componentVersions :: (Methods a, Component a) => Proxy a -> Map String [ByteString]
componentIO :: (Methods a, Component a) => Proxy a -> [IO ()]
createNewTxRun :: IO (TxRun st)
setNewStateType :: String -> String
getStateType :: String -> String
setNewState :: TypeString -> ByteString -> IO ()
setNewState' :: EventMap -> TypeString -> ByteString -> IO ()
getState :: TypeString -> IO ByteString
data SetNewState st
SetNewState :: ByteString -> SetNewState st
data GetState st
GetState :: GetState st

-- | Schedule an update and wait for it to complete. When this function
--   returns, you're guaranteed the update will be persistent.
update :: (MonadIO m, UpdateEvent ev res) => ev -> m res

-- | Emit a state query and wait for the result.
query :: (MonadIO m, QueryEvent ev res) => ev -> m res
quickQuery' :: Serialize st => TxRun st -> HR st -> IO ()
type Runner ev res = IO (IO ev, res -> IO ())
type EH i o = i -> IO o
data Event
Event :: ev -> Event
data IHR st
IHR :: TxContext -> ev -> (RunHandler st ev) -> IHR st
data HR st
HR :: ev -> (RunHandler st ev) -> HR st
type RunHandler st ev = TxContext -> st -> IO (Maybe st, IO ())
data Res a
Ok :: a -> Res a
Error :: ExceptionT -> Res a
type EventQueue st = TChan (HR st)
type ProcessQueue st = TChan (IHR st)
data TxRun st
TxRun :: !ProcessQueue st -> !TVar TxContext -> TxRun st
txProcessQueue :: TxRun st -> !ProcessQueue st
txLastTxContext :: TxRun st -> !TVar TxContext
type EvLoaders' st = Map String (ProcessQueue st -> ByteString -> IO (TxId, ByteString))
type EvLoaders = Map String (ByteString -> IO (TxId, ByteString))
setEvLoadersQueue :: ProcessQueue st -> EvLoaders' st -> EvLoaders
runObjectEvent :: Object -> IO Object
runObjectEventFunc :: Object -> EventMap -> IO Object
runColdEvent :: TxContext -> Object -> IO Object
runColdEventFunc :: TxContext -> Object -> EventMap -> IO Object
lookupEventHandler :: TypeString -> EventMap -> IO EventHandler
eventTString :: Serialize ev => ev -> TypeString
handleEvent :: (st -> Env -> Ev m res -> STM intermediate) -> (st -> intermediate -> IO (Maybe st, res)) -> (Either ExceptionT res -> IO ()) -> Ev m res -> RunHandler st ev
handleQuery :: (Either ExceptionT res -> IO ()) -> Query st res -> RunHandler st ev
handleUpdate :: (Either ExceptionT res -> IO ()) -> Update st res -> RunHandler st ev
checkDiff :: a -> a -> IO (Maybe a)
getEpochMilli :: IO EpochMilli
newTxContext :: IO TxContext
addTxId :: TxRun st -> TxContext -> STM TxContext
globalRandomGen :: MVar StdGen
data TxControl
TxControl :: Saver -> MVar (WriterStream EventLogEntry) -> [String] -> Map String [ByteString] -> [(ThreadId, MVar ())] -> Maybe PrefixLock -> IO () -> TxControl

-- | Saver given by the user.
ctlSaver :: TxControl -> Saver
ctlEventSaver :: TxControl -> MVar (WriterStream EventLogEntry)

-- | Types of each component used.
ctlAllComponents :: TxControl -> [String]

-- | Map listing all versions of a component
ctlComponentVersions :: TxControl -> Map String [ByteString]
ctlChildren :: TxControl -> [(ThreadId, MVar ())]

-- | Stores exclusive prefix lock (implemented in filesystem)
ctlPrefixLock :: TxControl -> Maybe PrefixLock
ctlCreateCheckpoint :: TxControl -> IO ()
data EventLogEntry
EventLogEntry :: TxContext -> Object -> EventLogEntry
runTxLoop :: MVar (WriterStream EventLogEntry) -> ProcessQueue st -> st -> IO ()
instance [overlap ok] Typeable1 SetNewState
instance [overlap ok] Typeable1 GetState
instance [overlap ok] Typeable EventLogEntry
instance [overlap ok] Show EventLogEntry
instance [overlap ok] Serialize EventLogEntry
instance [overlap ok] Version EventLogEntry
instance [overlap ok] Typeable st => QueryEvent (GetState st) ByteString
instance [overlap ok] Typeable st => UpdateEvent (SetNewState st) ()
instance [overlap ok] Typeable st => Serialize (GetState st)
instance [overlap ok] Version (GetState st)
instance [overlap ok] Typeable st => Serialize (SetNewState st)
instance [overlap ok] Version (SetNewState st)
instance [overlap ok] UpdateEvent SetCheckpointState ()
instance [overlap ok] QueryEvent GetCheckpointState ByteString
instance [overlap ok] Serialize StdGen
instance [overlap ok] Version StdGen
instance [overlap ok] Serialize SetCheckpointState
instance [overlap ok] Typeable SetCheckpointState
instance [overlap ok] Version SetCheckpointState
instance [overlap ok] Serialize GetCheckpointState
instance [overlap ok] Typeable GetCheckpointState
instance [overlap ok] Version GetCheckpointState
instance [overlap ok] Serialize TxContext
instance [overlap ok] Version TxContext

module Happstack.State.Control

-- | Starts the MACID system without replication support. Uses the default
--   behavior of saving the state into the _local directory.
startSystemState :: (Methods a, Component a) => Proxy a -> IO (MVar TxControl)
startSystemStateAmazon :: (Methods a, Component a) => ApplicationName -> Proxy a -> IO (MVar TxControl)
processLoggingFlags :: IO a -> IO a

-- | Returns the default Saver. It will save the application state into the
--   _local directory.
stdSaver :: IO Saver

-- | Wait for a signal. On unix, a signal is sigINT or sigTERM. On windows,
--   the signal is entering <tt>e</tt>.
waitForTermination :: IO ()
instance [overlap ok] Read Target
instance [overlap ok] Show Target
instance [overlap ok] Eq Target
instance [overlap ok] Ord Target
instance [overlap ok] Show Flag
instance [overlap ok] LogHandler NullLogger

module Happstack.State

-- | Monad for ACID event handlers.
data Ev m t

-- | ACID computations that work with any state and event types.
type AnyEv a = forall t. (Monad (t STM), MonadTrans t) => Ev (t STM) a
data TxControl

-- | Emit a state query and wait for the result.
query :: (MonadIO m, QueryEvent ev res) => ev -> m res

-- | Schedule an update and wait for it to complete. When this function
--   returns, you're guaranteed the update will be persistent.
update :: (MonadIO m, UpdateEvent ev res) => ev -> m res
type Update state = Ev (StateT state STM)
type Query state = Ev (ReaderT state STM)
type TxId = Int64
type EpochMilli = Int64
data Saver

-- | A saver that discards all output
NullSaver :: Saver

-- | A saver that operates on files. The parameter is the prefix for the
--   files.
FileSaver :: String -> Saver

-- | Enable queueing.
Queue :: Saver -> Saver
Memory :: (MVar Store) -> Saver

-- | Use a proxy to force the type of an update action.
setUpdateType :: Proxy t -> Update t ()

-- | Forces the type of the proxy and update to match
proxyUpdate :: Update t b -> Proxy t -> Update t b

-- | Use a proxy to force the type of a query action.
setQueryType :: Proxy t -> Query t ()

-- | Forces the type of proxy and query to match
proxyQuery :: Query t b -> Proxy t -> Query t b

-- | Currying version of <a>setUpdateType</a>.
asUpdate :: Update t a -> Proxy t -> Update t a

-- | Currying version of <a>setQueryType</a>.
asQuery :: Query t a -> Proxy t -> Query t a

-- | Specialized version of <a>ask</a>
askState :: Query st st

-- | Specialized version of <a>get</a>
getState :: Update st st

-- | Specialized version of <a>put</a>.
putState :: st -> Update st ()

-- | Lift an STM action into Ev.
liftSTM :: STM a -> AnyEv a
class CatchEv m
catchEv :: (CatchEv m, Exception e) => Ev m a -> (e -> a) -> Ev m a

-- | Select a part of the environment.
sel :: (Env -> b) -> AnyEv b

-- | Run a computation with local state. Changes to state will be visible
--   to outside.
localState :: (outer -> inner) -> (inner -> outer -> outer) -> Ev (StateT inner STM) a -> Ev (StateT outer STM) a

-- | Run a computation with local state.
localStateReader :: (outer -> inner) -> Ev (ReaderT inner STM) a -> Ev (ReaderT outer STM) a

-- | Execute a Query action in the Update monad.
runQuery :: Query st a -> Update st a
getEventId :: Integral txId => AnyEv txId
getTime :: Integral epochTime => AnyEv epochTime
getEventClockTime :: AnyEv ClockTime
getEventStream :: IO (IO EventItem)
data EventItem
EventItem :: TxContext -> Dynamic -> EventItem
eventContext :: EventItem -> TxContext
eventData :: EventItem -> Dynamic

-- | Get a random number.
getRandom :: Random a => AnyEv a

-- | Get a random number inside the range.
getRandomR :: Random a => (a, a) -> AnyEv a

-- | Infer updating functions for a record. Given a data declaration of
--   <tt>data Foo = Foo {bar :: String, baz :: Int}</tt> then
--   <tt>$(inferRecordUpdaters ''Foo)</tt> will define functions <tt>a_bar
--   :: String -&gt; Foo -&gt; Foo</tt>, <tt>withBar :: Update String a
--   -&gt; Update Foo a</tt>, etc. that can be used as convenience
--   updaters.
inferRecordUpdaters :: Name -> Q [Dec]

-- | Run the MACID system without multimaster support and with the given
--   Saver.
runTxSystem :: (Methods st, Component st) => Saver -> Proxy st -> IO (MVar TxControl)
createCheckpoint :: MVar TxControl -> IO ()

-- | Shuts down a transaction system
shutdownSystem :: MVar TxControl -> IO ()
unsafeIOToEv :: IO a -> AnyEv a


-- | instances of Typeable, Data, Serialize, Version, and Default for
--   ClockTime
module Happstack.State.ClockTime

-- | A representation of the internal clock time. Clock times may be
--   compared, converted to strings, or converted to an external calendar
--   time <a>CalendarTime</a> for I/O or other manipulations.
data ClockTime :: *

-- | Construct a clock time. The arguments are a number of seconds since
--   00:00:00 (UTC) on 1 January 1970, and an additional number of
--   picoseconds.
--   
--   In Haskell 98, the <a>ClockTime</a> type is abstract.
TOD :: Integer -> Integer -> ClockTime
instance [overlap ok] Default ClockTime
instance [overlap ok] (Data ctx Integer, Sat (ctx ClockTime), Sat (ctx Integer)) => Data ctx ClockTime
instance [overlap ok] Serialize ClockTime
instance [overlap ok] Data ClockTime
instance [overlap ok] Typeable ClockTime
instance [overlap ok] Version ClockTime
