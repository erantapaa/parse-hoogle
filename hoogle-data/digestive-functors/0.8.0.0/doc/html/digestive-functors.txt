-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A practical formlet library
--   
@package digestive-functors
@version 0.8.0.0


-- | Utilities for safe failable parsing
module Text.Digestive.Util

-- | <a>read</a> in the <a>Maybe</a> monad.
readMaybe :: Read a => String -> Maybe a


-- | Functionality related to index storage and the DefaultList type.
module Text.Digestive.Form.List

-- | Key used to store list indices
indicesRef :: Text

-- | Parse a string of comma-delimited integers to a list. Unparseable
--   substrings are left out of the result.
parseIndices :: Text -> [Int]

-- | Serialize a list of integers as a comma-delimited Text
unparseIndices :: [Int] -> Text

-- | A list which, when indexed on non-existant positions, returns a
--   default value.
data DefaultList a
DefaultList :: a -> [a] -> DefaultList a

-- | Safe indexing of a DefaultList - returns the default value if the
--   given index is out of bounds.
defaultListIndex :: DefaultList a -> Int -> a
instance Traversable DefaultList
instance Foldable DefaultList
instance Functor DefaultList


-- | Core types used internally
module Text.Digestive.Types

-- | A mostly internally used type for representing Success/Error, with a
--   special applicative instance
data Result v a
Success :: a -> Result v a
Error :: v -> Result v a

-- | Map over the error type of a <a>Result</a>
resultMapError :: (v -> w) -> Result v a -> Result w a

-- | Describes a path to a subform
type Path = [Text]

-- | Create a <a>Path</a> from some text
toPath :: Text -> Path

-- | Serialize a <a>Path</a> to <a>Text</a>
fromPath :: Path -> Text

-- | The HTTP methods
data Method
Get :: Method
Post :: Method

-- | The different input types sent by the browser
data FormInput
TextInput :: Text -> FormInput
FileInput :: FilePath -> FormInput

-- | An environment (e.g. a server) from which we can read input
--   parameters. A single key might be associated with multiple text values
--   (multi-select).
type Env m = Path -> m [FormInput]
instance (Show v, Show a) => Show (Result v a)
instance Eq Method
instance Ord Method
instance Show Method
instance Show FormInput
instance Monoid v => Monad (Result v)
instance Monoid v => Applicative (Result v)
instance Functor (Result v)


-- | Internal embedding of form fields with associated functions.
module Text.Digestive.Form.Internal.Field

-- | A single input field. This usually maps to a single HTML
--   <tt><a>input</a></tt> element.
data Field v a
Singleton :: a -> Field v a
Text :: Text -> Field v Text
Choice :: [(Text, [(Text, (a, v))])] -> Int -> Field v (a, Int)
Bool :: Bool -> Field v Bool
File :: Field v (Maybe FilePath)

-- | Value agnostic <a>Field</a>
data SomeField v
SomeField :: (Field v a) -> SomeField v

-- | Evaluate a field to retrieve a value, using the given method and a
--   list of input.
evalField :: Method -> [FormInput] -> Field v a -> a

-- | Map on the error message type of a Field.
fieldMapView :: (v -> w) -> Field v a -> Field w a
instance Show (Field v a)


-- | This module mostly meant for internal usage, and might change between
--   minor releases.
module Text.Digestive.Form.Internal

-- | Base type for a form.
--   
--   The three type parameters are:
--   
--   <ul>
--   <li><tt>v</tt>: the type for textual information, displayed to the
--   user. For example, error messages are of this type. <tt>v</tt> stands
--   for "view".</li>
--   <li><tt>m</tt>: the monad in which validators operate. The classical
--   example is when validating input requires access to a database, in
--   which case this <tt>m</tt> should be an instance of
--   <tt>MonadIO</tt>.</li>
--   <li><tt>a</tt>: the type of the value returned by the form, used for
--   its Applicative instance.</li>
--   </ul>
type Form v m a = FormTree m v m a

-- | Embedded tree structure for forms - the basis for deferred evaluation
--   and the applicative interface.
data FormTree t v m a
Ref :: Ref -> FormTree t v m a -> FormTree t v m a
Pure :: Field v a -> FormTree t v m a
App :: FormTree t v m (b -> a) -> FormTree t v m b -> FormTree t v m a
Map :: (b -> m (Result v a)) -> FormTree t v m b -> FormTree t v m a
Monadic :: t (FormTree t v m a) -> FormTree t v m a
List :: DefaultList (FormTree t v m a) -> FormTree t v m [Int] -> FormTree t v m [a]
Metadata :: [Metadata] -> FormTree t v m a -> FormTree t v m a

-- | Value-agnostic Form
data SomeForm v m
SomeForm :: (FormTree Identity v m a) -> SomeForm v m

-- | Compact type for form labelling
type Ref = Text
data Metadata
Disabled :: Metadata

-- | Map on the value type
transform :: (Monad m, Monoid v) => (a -> m (Result v b)) -> FormTree t v m a -> FormTree t v m b

-- | Hide a monadic wrapper
monadic :: m (Form v m a) -> Form v m a

-- | Normalize a Form to allow operations on the contents
toFormTree :: Monad m => Form v m a -> m (FormTree Identity v m a)

-- | Returns the topmost applicative or index trees if either exists
--   otherwise returns an empty list
children :: FormTree Identity v m a -> [SomeForm v m]

-- | Operator to set a name for a subform.
(.:) :: Monad m => Text -> Form v m a -> Form v m a

-- | Return the first/topmost label of a form
getRef :: FormTree Identity v m a -> Maybe Ref

-- | Retrieve the form(s) at the given path
lookupForm :: Path -> FormTree Identity v m a -> [SomeForm v m]

-- | A variant of <a>lookupForm</a> which also returns all metadata
--   associated with the form.
lookupFormMetadata :: Path -> FormTree Identity v m a -> [(SomeForm v m, [Metadata])]

-- | Always returns a List - fails if path does not directly reference a
--   list
lookupList :: Path -> FormTree Identity v m a -> SomeForm v m

-- | Returns the topmost untransformed single field, if one exists
toField :: FormTree Identity v m a -> Maybe (SomeField v)

-- | Retrieve the field at the given path of the tree and apply the
--   evaluation. Used in field evaluation functions in <a>View</a>.
queryField :: Path -> FormTree Identity v m a -> (forall b. Field v b -> c) -> c

-- | Evaluate a formtree with a given method and environment. Incrementally
--   builds the path based on the set labels and evaluates recursively -
--   applying transformations and applications with a bottom-up strategy.
eval :: Monad m => Method -> Env m -> FormTree Identity v m a -> m (Result [(Path, v)] a, [(Path, FormInput)])

-- | Map on the error type of a FormTree - used to define the Functor
--   instance of <a>View.View</a>
formMapView :: Monad m => (v -> w) -> FormTree Identity v m a -> FormTree Identity w m a

-- | Combinator that lifts input and output of valiation function used by
--   <tt>validate</tt> to from (a -&gt; Result v b) to (Maybe a -&gt;
--   Result v (Maybe b)).
forOptional :: (a -> Result v b) -> Maybe a -> Result v (Maybe b)

-- | Debugging purposes
debugFormPaths :: (Monad m, Monoid v) => FormTree Identity v m a -> [Path]
instance Eq Metadata
instance Ord Metadata
instance Show Metadata
instance Show (SomeForm v m)
instance Show (FormTree Identity v m a)
instance (Monad m, Monoid v) => Applicative (FormTree t v m)
instance (Monad m, Monoid v) => Functor (FormTree t v m)


-- | This module contains utilities for creating text fragments to identify
--   forms.
module Text.Digestive.Ref

-- | Convert an arbitrary text value (possibly containing spaces, dots etc.
--   to a text value that can safely be used as an identifier in forms.
makeRef :: Text -> Text

-- | Create an infinite list of refs.
makeRefs :: [Text]


-- | Provides a datatype to differentiate between regular urlencoding and
--   multipart encoding for the content of forms and functions to determine
--   the content types of forms.
module Text.Digestive.Form.Encoding

-- | Content type encoding of the form, either url encoded
--   (percent-encoding) or multipart encoding. For details, see:
--   <a>http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4</a>
data FormEncType
UrlEncoded :: FormEncType
MultiPart :: FormEncType

-- | Determines the encoding type of a <a>FormTree</a>
formTreeEncType :: FormTree Identity v m a -> FormEncType
instance Eq FormEncType
instance Monoid FormEncType
instance Show FormEncType


-- | Provides functionality for frontend and backend integration.
--   
--   This module contains functions used to glue form handling to
--   particular server implementations and view libraries, defining the
--   standard behaviour for handling GET and POST requests.
--   
--   Field accessors can be used to write frontend libraries, mapping field
--   values to concrete elements.
module Text.Digestive.View

-- | Finalized form - handles the form, error messages and input.
--   Internally handles the addressing of individual fields.
data View v
View :: Text -> Path -> FormTree Identity v m a -> [(Path, FormInput)] -> [(Path, v)] -> Method -> View v
viewName :: View v -> Text
viewContext :: View v -> Path
viewForm :: View v -> FormTree Identity v m a
viewInput :: View v -> [(Path, FormInput)]
viewErrors :: View v -> [(Path, v)]
viewMethod :: View v -> Method

-- | Serve up a form for a GET request - no form input
getForm :: Monad m => Text -> Form v m a -> m (View v)

-- | Handle a form for a POST request - evaluate with the given environment
--   and return the result.
postForm :: Monad m => Text -> Form v m a -> (FormEncType -> m (Env m)) -> m (View v, Maybe a)

-- | Returns the subview of a view matching the given serialized
--   <a>Path</a>
subView :: Text -> View v -> View v

-- | Returns all immediate subviews of a view
subViews :: View v -> [View v]

-- | Determine an absolute <a>Path</a> for a field in the form
absolutePath :: Text -> View v -> Path

-- | Determine an absolute path and call <a>fromPath</a> on it. Useful if
--   you're writing a view library...
absoluteRef :: Text -> View v -> Text

-- | Returns the content type of the View - depends on contained fields
viewEncType :: View v -> FormEncType

-- | Return the text data at the position referred to by the given
--   serialized Path.
fieldInputText :: Text -> View v -> Text

-- | Returns a list of (identifier, view, selected?)
fieldInputChoice :: Text -> View v -> [(Text, v, Bool)]

-- | Returns a list of (groupName, [(identifier, view, selected?)])
fieldInputChoiceGroup :: Text -> View v -> [(Text, [(Text, v, Bool)])]

-- | Returns True/False based on the field referred to by the given
--   serialized Path.
fieldInputBool :: Text -> View v -> Bool

-- | Return the FilePath referred to by the given serialized path, if set.
fieldInputFile :: Text -> View v -> Maybe FilePath

-- | Returns sub views referred to by dynamic list indices at the given
--   serialized path.
listSubViews :: Text -> View v -> [View v]

-- | Creates a sub view
makeListSubView :: Text -> Int -> View v -> View v

-- | Returns all errors related to the form corresponding to the given
--   serialized Path
errors :: Text -> View v -> [v]

-- | Returns all errors related to the form, and its children, pointed to
--   by the given serialized Path.
childErrors :: Text -> View v -> [v]
viewDisabled :: Text -> View v -> Bool

-- | Retrieve all paths of the contained form
debugViewPaths :: Monoid v => View v -> [Path]
instance Show v => Show (View v)
instance Functor View


-- | End-user interface - provides the main functionality for form creation
--   and validation. For an interface for front-end implementation, see
--   <a>View</a>.
module Text.Digestive.Form

-- | A <a>Form</a> with a set, optional default value
type Formlet v m a = Maybe a -> Form v m a

-- | Base type for a form.
--   
--   The three type parameters are:
--   
--   <ul>
--   <li><tt>v</tt>: the type for textual information, displayed to the
--   user. For example, error messages are of this type. <tt>v</tt> stands
--   for "view".</li>
--   <li><tt>m</tt>: the monad in which validators operate. The classical
--   example is when validating input requires access to a database, in
--   which case this <tt>m</tt> should be an instance of
--   <tt>MonadIO</tt>.</li>
--   <li><tt>a</tt>: the type of the value returned by the form, used for
--   its Applicative instance.</li>
--   </ul>
type Form v m a = FormTree m v m a

-- | Value-agnostic Form
data SomeForm v m
SomeForm :: (FormTree Identity v m a) -> SomeForm v m

-- | Operator to set a name for a subform.
(.:) :: Monad m => Text -> Form v m a -> Form v m a

-- | Returns a <a>Formlet</a> which may optionally take a default text
text :: (Monad m, Monoid v) => Formlet v m Text

-- | Identical to "text" but takes a String
string :: (Monad m, Monoid v) => Formlet v m String

-- | Returns a <a>Formlet</a> for a parseable and serializable value type
stringRead :: (Monad m, Monoid v, Read a, Show a) => v -> Formlet v m a

-- | Returns a <a>Formlet</a> for a value restricted to the provided list
--   of value-message tuples
choice :: (Eq a, Monad m, Monoid v) => [(a, v)] -> Formlet v m a

-- | Sometimes there is no good <a>Eq</a> instance for <a>choice</a>. In
--   this case, you can use this function, which takes an index in the list
--   as default.
choice' :: (Monad m, Monoid v) => [(a, v)] -> Maybe Int -> Form v m a

-- | Allows you to assign your own values: these values will be used in the
--   resulting HTML instead of the default <tt>[0 ..]</tt>. This fixes some
--   race conditions that might otherwise appear, e.g. if new choice items
--   are added to some database while a user views and submits the form...
choiceWith :: (Eq a, Monad m, Monoid v) => [(Text, (a, v))] -> Formlet v m a

-- | A version of <a>choiceWith</a> for when there is no good <a>Eq</a>
--   instance.
choiceWith' :: (Monad m, Monoid v) => [(Text, (a, v))] -> Maybe Int -> Form v m a

-- | Returns a <a>Formlet</a> for named groups of choices.
groupedChoice :: (Eq a, Monad m, Monoid v) => [(Text, [(a, v)])] -> Formlet v m a

-- | Sometimes there is no good <a>Eq</a> instance for <a>choice</a>. In
--   this case, you can use this function, which takes an index in the list
--   as default.
groupedChoice' :: (Monad m, Monoid v) => [(Text, [(a, v)])] -> Maybe Int -> Form v m a

-- | Allows you to assign your own values: these values will be used in the
--   resulting HTML instead of the default <tt>[0 ..]</tt>. This fixes some
--   race conditions that might otherwise appear, e.g. if new choice items
--   are added to some database while a user views and submits the form...
groupedChoiceWith :: (Eq a, Monad m, Monoid v) => [(Text, [(Text, (a, v))])] -> Formlet v m a

-- | Low-level support for grouped choice.
groupedChoiceWith' :: (Monad m, Monoid v) => [(Text, [(Text, (a, v))])] -> Maybe Int -> Form v m a

-- | Returns a <a>Formlet</a> for binary choices
bool :: (Monad m, Monoid v) => Formlet v m Bool

-- | Returns a <a>Formlet</a> for file selection
file :: (Monad m, Monoid v) => Form v m (Maybe FilePath)

-- | Create a text form with an optional default text which returns nothing
--   if no optional text was set, and no input was retrieved.
optionalText :: (Monad m, Monoid v) => Maybe Text -> Form v m (Maybe Text)

-- | Identical to <a>optionalText</a>, but uses Strings
optionalString :: (Monad m, Monoid v) => Maybe String -> Form v m (Maybe String)

-- | Identical to <a>optionalText</a> for parseable and serializable
--   values.
optionalStringRead :: (Monad m, Monoid v, Read a, Show a) => v -> Maybe a -> Form v m (Maybe a)
utcTimeFormlet :: Monad m => String -> String -> TimeZone -> Formlet Text m UTCTime
localTimeFormlet :: Monad m => String -> String -> Formlet Text m LocalTime
dateFormlet :: Monad m => String -> Formlet Text m Day
timeFormlet :: Monad m => String -> Formlet Text m TimeOfDay
optionalUtcTimeFormlet :: Monad m => String -> String -> TimeZone -> Maybe UTCTime -> Form Text m (Maybe UTCTime)
optionalLocalTimeFormlet :: Monad m => String -> String -> Maybe LocalTime -> Form Text m (Maybe LocalTime)
optionalDateFormlet :: Monad m => String -> Maybe Day -> Form Text m (Maybe Day)
optionalTimeFormlet :: Monad m => String -> Maybe TimeOfDay -> Form Text m (Maybe TimeOfDay)

-- | Validate the results of a form with a simple predicate
--   
--   Example:
--   
--   <pre>
--   check "Can't be empty" (not . null) (string Nothing)
--   </pre>
check :: (Monad m, Monoid v) => v -> (a -> Bool) -> Form v m a -> Form v m a

-- | Version of <a>check</a> which allows monadic validations
checkM :: (Monad m, Monoid v) => v -> (a -> m Bool) -> Form v m a -> Form v m a

-- | This is an extension of <a>check</a> that can be used to apply
--   transformations that optionally fail
--   
--   Example: taking the first character of an input string
--   
--   <pre>
--   head' :: String -&gt; Result String Char
--   head' []      = Error "Is empty"
--   head' (x : _) = Success x
--   
--   char :: Monad m =&gt; Form m String Char
--   char = validate head' (string Nothing)
--   </pre>
validate :: (Monad m, Monoid v) => (a -> Result v b) -> Form v m a -> Form v m b

-- | Same as <a>validate</a>, but works with forms of the form:
--   
--   <pre>
--   Form v m (Maybe a)
--   </pre>
--   
--   .
--   
--   Example: taking the first character of an optional input string
--   
--   <pre>
--   head' :: String -&gt; Result String Char
--   head' []      = Error "Is empty"
--   head' (x : _) = Success x
--   
--   char :: Monad m =&gt; Form m String (Maybe Char)
--   char = validateOptional head' (optionalString Nothing)
--   </pre>
validateOptional :: (Monad m, Monoid v) => (a -> Result v b) -> Form v m (Maybe a) -> Form v m (Maybe b)

-- | Version of <a>validate</a> which allows monadic validations
validateM :: (Monad m, Monoid v) => (a -> m (Result v b)) -> Form v m a -> Form v m b

-- | Allows for the composition of independent validation functions.
--   
--   For example, let's validate an even integer between 0 and 100:
--   
--   <pre>
--   form :: Monad m =&gt; Form Text m FormData
--   ... -- some fields
--   &lt;*&gt; "smallEvenInteger" .: validate (notEmpty &gt;=&gt; integer &gt;=&gt; even &gt;=&gt; greaterThan 0 &gt;=&gt; lessThanOrEq 100) (text Nothing)
--   ... -- more fields
--   </pre>
--   
--   where
--   
--   <pre>
--   notEmpty       :: IsString v =&gt; Text -&gt; Result v Text
--   integer        :: (Integral a, IsString v) =&gt; Text -&gt; Result v a
--   greaterThan  0 :: (Num a, Ord a, Show a) =&gt; a -&gt; Result Text a
--   lessThanOrEq 0 :: (Num a, Ord a, Show a) =&gt; a -&gt; Result Text a
--   even           :: Integer -&gt; Result Text Integer
--   </pre>
--   
--   .
--   
--   This will validate our smallEvenInteger correctly, but there is a
--   problem. If a user enters an odd number greater than 100, only
--   
--   <pre>
--   "number must be even"
--   </pre>
--   
--   will be returned. It would make for a better user experience if
--   
--   <pre>
--   ["number must be even", "number must be less than 100"]
--   </pre>
--   
--   was returned instead. This can be accomplished by rewriting our form
--   to be:
--   
--   <pre>
--   form :: Monad m =&gt; Form [Text] m FormData
--   ... -- some fields
--   &lt;*&gt; "smallEvenInteger" .: validate (notEmpty &gt;=&gt; integer &gt;=&gt; conditions [even, greaterThan 0, lessThanOrEq 100]) (text Nothing)
--   ... -- more fields
--   </pre>
--   
--   .
--   
--   If we want to collapse our list of errors into a single <a>Text</a>,
--   we can do something like:
--   
--   <pre>
--   form :: Monad m =&gt; Form Text m FormData
--   ... -- some fields
--   &lt;*&gt; "smallEvenInteger" .: validate (notEmpty &gt;=&gt; integer &gt;=&gt; commaSeperated . conditions [even, greaterThan 0, lessThanOrEq 100]) (text Nothing)
--   ... -- more fields
--   </pre>
--   
--   where
--   
--   <pre>
--   commaSeperated :: (Result [Text] a) -&gt; (Result Text a)
--   </pre>
--   
--   .
conditions :: [(a -> Result e b)] -> a -> (Result [e] a)

-- | Disables a form
disable :: Form v m a -> Form v m a

-- | Hide a monadic wrapper
monadic :: m (Form v m a) -> Form v m a

-- | Dynamic lists
listOf :: (Monad m, Monoid v) => Formlet v m a -> Formlet v m [a]


-- | Tutorial:
--   <a>http://github.com/jaspervdj/digestive-functors/blob/master/examples/tutorial.lhs</a>
module Text.Digestive
