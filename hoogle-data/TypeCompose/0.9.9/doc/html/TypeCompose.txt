-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Type composition classes & instances
--   
--   TypeCompose provides some classes &amp; instances for forms of type
--   composition, as well as some modules who haven't yet found a home.
--   
--   Please see the project wiki page:
--   <a>http://haskell.org/haskellwiki/TypeCompose</a>
--   
--   Copyright 2007-2012 by Conal Elliott; BSD3 license.
@package TypeCompose
@version 0.9.9


-- | Some (orphan) instances that belong elsewhere (where they wouldn't be
--   orphans). Add the following line to get these instances
--   
--   <pre>
--   import Control.Instances ()
--   </pre>
module Control.Instances
instance Monoid o => Monoid (IO o)


-- | Monads with references, taken from John Hughes's <a>Global Variables
--   in Haskell</a> (<a>http://citeseer.ist.psu.edu/473734.html</a>).
module Data.RefMonad

-- | Class of monads with references.
class Monad m => RefMonad m r | m -> r
newRef :: RefMonad m r => a -> m (r a)
readRef :: RefMonad m r => r a -> m a
writeRef :: RefMonad m r => r a -> a -> m ()

-- | Change the contents of a ref
modifyRef :: RefMonad m r => r a -> (a -> a) -> m ()
instance RefMonad (ST s) (STRef s)
instance RefMonad IO IORef


-- | Bijections. For a more general setting, see also [1] <i>There and Back
--   Again: Arrows for Invertible Programming</i>,
--   <a>http://citeseer.ist.psu.edu/alimarine05there.html</a>.
module Data.Bijection

-- | A type of bijective arrows
data Bijection j a b
Bi :: a j b -> b j a -> Bijection j a b
biTo :: Bijection j a b -> a j b
biFrom :: Bijection j a b -> b j a

-- | Bijective functions
type (:<->:) a b = Bijection (->) a b

-- | Bijective identity arrow. Warning: uses <a>arr</a> on
--   <tt>(~&gt;)</tt>. If you have no <a>arr</a>, but you have a
--   <tt>DeepArrow</tt>, you can instead use <tt>Bi idA idA</tt>.
idb :: Arrow j => Bijection j a a

-- | Inverse bijection
inverse :: Bijection j a b -> Bijection j b a

-- | Bijections on functors
bimap :: Functor f => (a :<->: b) -> (f a :<->: f b)

-- | Bijections on arrows.
(--->) :: Arrow j => Bijection j a b -> Bijection j c d -> (a j c) :<->: (b j d)

-- | Apply a function in an alternative (monomorphic) representation.
inBi :: Arrow j => Bijection j a b -> (a j a) -> (b j b)
instance Arrow j => Arrow (Bijection j)
instance Category j => Category (Bijection j)


-- | Various type constructor compositions and instances for them. Some
--   come from "Applicative Programming with Effects"
--   <a>http://www.soi.city.ac.uk/~ross/papers/Applicative.html</a>
module Control.Compose

-- | Unary functions
type Unop a = a -> a

-- | Binary functions
type Binop a = a -> a -> a

-- | Add post-processing
result :: Category cat => (b cat b') -> ((a cat b) -> (a cat b'))

-- | Add pre-processing argument :: (a' -&gt; a) -&gt; ((a -&gt; b) -&gt;
--   (a' -&gt; b))
argument :: Category cat => (a' cat a) -> ((a cat b) -> (a' cat b))

-- | Add pre- and post processing
(~>) :: Category cat => (a' cat a) -> (b cat b') -> ((a cat b) -> (a' cat b'))

-- | Like '(~&gt;)' but specialized to functors and functions.
(~>*) :: (Functor p, Functor q) => (a' -> a) -> (b -> b') -> (p a -> q b) -> (p a' -> q b')
(<~) :: Category cat => (b cat b') -> (a' cat a) -> ((a cat b) -> (a' cat b'))
(*<~) :: (Functor p, Functor q) => (b -> b') -> (a' -> a) -> (p a -> q b) -> (p a' -> q b')

-- | Contravariant functors. often useful for <i>acceptors</i> (consumers,
--   sinks) of values.
class ContraFunctor h
contraFmap :: ContraFunctor h => (a -> b) -> (h b -> h a)

-- | Bijections on contravariant functors
bicomap :: ContraFunctor f => (a :<->: b) -> (f a :<->: f b)

-- | Composition of unary type constructors
--   
--   There are (at least) two useful <a>Monoid</a> instances, so you'll
--   have to pick one and type-specialize it (filling in all or parts of
--   <tt>g</tt> and/or <tt>f</tt>).
--   
--   <pre>
--   -- standard Monoid instance for Applicative applied to Monoid
--   instance (Applicative (g :. f), Monoid a) =&gt; Monoid ((g :. f) a) where
--     { mempty = pure mempty; mappend = liftA2 mappend }
--   -- Especially handy when g is a Monoid_f.
--   instance Monoid (g (f a)) =&gt; Monoid ((g :. f) a) where
--     { mempty = O mempty; mappend = inO2 mappend }
--   </pre>
--   
--   Corresponding to the first and second definitions above,
--   
--   <pre>
--   instance (Applicative g, Monoid_f f) =&gt; Monoid_f (g :. f) where
--     { mempty_f = O (pure mempty_f); mappend_f = inO2 (liftA2 mappend_f) }
--   instance Monoid_f g =&gt; Monoid_f (g :. f) where
--     { mempty_f = O mempty_f; mappend_f = inO2 mappend_f }
--   </pre>
--   
--   Similarly, there are two useful <a>Functor</a> instances and two
--   useful <a>ContraFunctor</a> instances.
--   
--   <pre>
--   instance (      Functor g,       Functor f) =&gt; Functor (g :. f) where fmap = fmapFF
--   instance (ContraFunctor g, ContraFunctor f) =&gt; Functor (g :. f) where fmap = fmapCC
--   
--   instance (      Functor g, ContraFunctor f) =&gt; ContraFunctor (g :. f) where contraFmap = contraFmapFC
--   instance (ContraFunctor g,       Functor f) =&gt; ContraFunctor (g :. f) where contraFmap = contraFmapCF
--   </pre>
--   
--   However, it's such a bother to define the Functor instances per
--   composition type, I've left the fmapFF case in. If you want the fmapCC
--   one, you're out of luck for now. I'd love to hear a good solution.
--   Maybe someday Haskell will do Prolog-style search for instances,
--   subgoaling the constraints, rather than just matching instance heads.
newtype (:.) g f a
O :: (g (f a)) -> :. g f a

-- | Compatibility synonym
type O = :.

-- | Unwrap a '(:.)'.
unO :: (g :. f) a -> g (f a)

-- | <tt>newtype</tt> bijection
biO :: g (f a) :<->: (g :. f) a

-- | Compose a bijection, Functor style
convO :: Functor g => (b :<->: g c) -> (c :<->: f a) -> (b :<->: (g :. f) a)

-- | Compose a bijection, ContraFunctor style
coconvO :: ContraFunctor g => (b :<->: g c) -> (c :<->: f a) -> (b :<->: (g :. f) a)

-- | Apply a unary function within the <a>O</a> constructor.
inO :: (g (f a) -> g' (f' a')) -> ((g :. f) a -> (g' :. f') a')

-- | Apply a binary function within the <a>O</a> constructor.
inO2 :: (g (f a) -> g' (f' a') -> g'' (f'' a'')) -> ((g :. f) a -> (g' :. f') a' -> (g'' :. f'') a'')

-- | Apply a ternary function within the <a>O</a> constructor.
inO3 :: (g (f a) -> g' (f' a') -> g'' (f'' a'') -> g''' (f''' a''')) -> ((g :. f) a -> (g' :. f') a' -> (g'' :. f'') a'' -> (g''' :. f''') a''')

-- | Handy combination of <a>O</a> and <a>pure</a>.
oPure :: Applicative g => f a -> (g :. f) a

-- | Handy combination of <a>inO</a> and <a>fmap</a>.
oFmap :: Functor g' => (f a -> f' a') -> (g' :. f) a -> (g' :. f') a'

-- | Handy combination of <a>inO2</a> and <a>liftA2</a>.
oLiftA2 :: Applicative g'' => (f a -> f' a' -> f'' a'') -> (g'' :. f) a -> (g'' :. f') a' -> (g'' :. f'') a''

-- | Handy combination of <a>inO3</a> and <a>liftA3</a>.
oLiftA3 :: Applicative g''' => (f a -> f' a' -> f'' a'' -> f''' a''') -> (g''' :. f) a -> (g''' :. f') a' -> (g''' :. f'') a'' -> (g''' :. f''') a'''

-- | Used for the <tt>Functor :. Functor</tt> instance of <a>Functor</a>
fmapFF :: (Functor g, Functor f) => (a -> b) -> (g :. f) a -> (g :. f) b

-- | Used for the <tt>ContraFunctor :. ContraFunctor</tt> instance of
--   <a>Functor</a>
fmapCC :: (ContraFunctor g, ContraFunctor f) => (a -> b) -> (g :. f) a -> (g :. f) b

-- | Used for the <tt>Functor :. ContraFunctor</tt> instance of
--   <a>Functor</a>
contraFmapFC :: (Functor g, ContraFunctor f) => (b -> a) -> (g :. f) a -> (g :. f) b

-- | Used for the <tt>ContraFunctor :. Functor</tt> instance of
--   <a>Functor</a>
contraFmapCF :: (ContraFunctor g, Functor f) => (b -> a) -> (g :. f) a -> (g :. f) b

-- | Monad distributivity.
--   
--   TODO: what conditions are required so that <tt>(m :. n)</tt> satisfies
--   the monad laws?
class DistribM m n
distribM :: DistribM m n => n (m a) -> m (n a)

-- | A candidate <a>join</a> for <tt>(m :. n)</tt>
joinDistribM :: (Monad m, Monad n, DistribM m n) => (m :. n) ((m :. n) a) -> (m :. n) a

-- | A candidate '(&gt;&gt;=)' for <tt>(m :. n)</tt>
bindDistribM :: (Functor m, Functor n, Monad m, Monad n, DistribM m n) => (m :. n) a -> (a -> (m :. n) b) -> (m :. n) b
returnDistribM :: (Monad m, Monad n) => a -> (m :. n) a

-- | <a>join</a>-like function for implicitly composed monads
joinMMT :: (Monad m, Monad n, Traversable n, Applicative m) => m (n (m (n a))) -> m (n a)

-- | <a>join</a>-like function for explicitly composed monads
joinComposeT :: (Monad m, Monad n, Traversable n, Applicative m) => (m :. n) ((m :. n) a) -> (m :. n) a

-- | Composition of type constructors: unary with binary. Called
--   <a>StaticArrow</a> in [1].
newtype OO f j a b
OO :: f (a j b) -> OO f j a b
unOO :: OO f j a b -> f (a j b)

-- | Common pattern for <a>Arrow</a>s.
newtype FunA h a b
FunA :: (h a -> h b) -> FunA h a b
unFunA :: FunA h a b -> h a -> h b

-- | Apply unary function in side a <a>FunA</a> representation.
inFunA :: ((h a -> h b) -> (h' a' -> h' b')) -> (FunA h a b -> FunA h' a' b')

-- | Apply binary function in side a <a>FunA</a> representation.
inFunA2 :: ((h a -> h b) -> (h' a' -> h' b') -> (h'' a'' -> h'' b'')) -> (FunA h a b -> FunA h' a' b' -> FunA h'' a'' b'')

-- | Support needed for a <a>FunA</a> to be an <a>Arrow</a>.
class FunAble h where f ***% g = firstFun f >>> secondFun g f &&&% g = arrFun (\ b -> (b, b)) >>> f ***% g
arrFun :: FunAble h => (a -> b) -> (h a -> h b)
firstFun :: FunAble h => (h a -> h a') -> (h (a, b) -> h (a', b))
secondFun :: FunAble h => (h b -> h b') -> (h (a, b) -> h (a, b'))
(***%) :: FunAble h => (h a -> h b) -> (h a' -> h b') -> (h (a, a') -> h (b, b'))
(&&&%) :: FunAble h => (h a -> h b) -> (h a -> h b') -> (h a -> h (b, b'))

-- | Simulates universal constraint <tt>forall a. Monoid (f a)</tt>.
--   
--   See Simulating Quantified Class Constraints
--   (<a>http://flint.cs.yale.edu/trifonov/papers/sqcc.pdf</a>) Instantiate
--   this schema wherever necessary:
--   
--   <pre>
--   instance Monoid_f f where { mempty_f = mempty ; mappend_f = mappend }
--   </pre>
class Monoid_f m
mempty_f :: Monoid_f m => m a
mappend_f :: Monoid_f m => m a -> m a -> m a

-- | Flip type arguments
newtype Flip j b a
Flip :: a j b -> Flip j b a
unFlip :: Flip j b a -> a j b

-- | <tt>newtype</tt> bijection
biFlip :: (a j b) :<->: Flip j b a
inFlip :: ((a j b) -> (a' k b')) -> (Flip j b a -> Flip k b' a')
inFlip2 :: ((a j b) -> (a' k b') -> (a'' l b'')) -> (Flip j b a -> Flip k b' a' -> Flip l b'' a'')
inFlip3 :: ((a j b) -> (a' k b') -> (a'' l b'') -> (a''' m b''')) -> (Flip j b a -> Flip k b' a' -> Flip l b'' a'' -> Flip m b''' a''')

-- | (-&gt; IO ()) as a <a>Flip</a>. A ContraFunctor.
type OI = Flip (->) (IO ())

-- | Convert to an <a>OI</a>.
class ToOI sink
toOI :: ToOI sink => sink b -> OI b

-- | Type application We can also drop the <tt>App</tt> constructor, but
--   then we overlap with many other instances, like <tt>[a]</tt>. Here's a
--   template for <tt>App</tt>-free instances.
--   
--   <pre>
--   instance (Applicative f, Monoid a) =&gt; Monoid (f a) where
--     mempty  = pure mempty
--     mappend = liftA2 mappend
--   </pre>
newtype (:$) f a
App :: f a -> :$ f a
unApp :: :$ f a -> f a

-- | Compatibility synonym for (:$).
type App = :$

-- | <tt>newtype</tt> bijection
biApp :: f a :<->: App f a
inApp :: (f a -> f' a') -> (App f a -> App f' a')
inApp2 :: (f a -> f' a' -> f'' a'') -> (App f a -> App f' a' -> App f'' a'')

-- | Identity type constructor. Until there's a better place to find it.
--   I'd use <a>Control.Monad.Identity</a>, but I don't want to introduce a
--   dependency on mtl just for Id.
newtype Id a
Id :: a -> Id a
unId :: Id a -> a

-- | <tt>newtype</tt> bijection
biId :: a :<->: Id a
inId :: (a -> b) -> (Id a -> Id b)
inId2 :: (a -> b -> c) -> (Id a -> Id b -> Id c)

-- | Pairing of unary type constructors
newtype (:*:) f g a
Prod :: (f a, g a) -> :*: f g a
unProd :: :*: f g a -> (f a, g a)

-- | Handy infix &amp; curried <a>Prod</a>
(*:*) :: f a -> g a -> (f :*: g) a

-- | <tt>newtype</tt> bijection
biProd :: (f a, g a) :<->: (f :*: g) a

-- | Compose a bijection
convProd :: (b :<->: f a) -> (c :<->: g a) -> (b, c) :<->: (f :*: g) a

-- | Combine two binary functions into a binary function on pairs
(***#) :: (a -> b -> c) -> (a' -> b' -> c') -> (a, a') -> (b, b') -> (c, c')

-- | A handy combining form. See '(***#)' for an sample use.
($*) :: (a -> b, a' -> b') -> (a, a') -> (b, b')

-- | Apply unary function inside of <tt>f :*: g</tt> representation.
inProd :: ((f a, g a) -> (f' a', g' a')) -> ((f :*: g) a -> (f' :*: g') a')

-- | Apply binary function inside of <tt>f :*: g</tt> representation.
inProd2 :: ((f a, g a) -> (f' a', g' a') -> (f'' a'', g'' a'')) -> ((f :*: g) a -> (f' :*: g') a' -> (f'' :*: g'') a'')

-- | Apply ternary function inside of <tt>f :*: g</tt> representation.
inProd3 :: ((f a, g a) -> (f' a', g' a') -> (f'' a'', g'' a'') -> (f''' a''', g''' a''')) -> ((f :*: g) a -> (f' :*: g') a' -> (f'' :*: g'') a'' -> (f''' :*: g''') a''')

-- | Pairing of binary type constructors
newtype (::*::) f g a b
Prodd :: (f a b, g a b) -> ::*:: f g a b
unProdd :: ::*:: f g a b -> (f a b, g a b)

-- | Handy infix &amp; curried <a>Prodd</a>
(*::*) :: f a b -> g a b -> (f ::*:: g) a b

-- | Apply binary function inside of <tt>f :*: g</tt> representation.
inProdd :: ((f a b, g a b) -> (f' a' b', g' a' b')) -> ((f ::*:: g) a b -> (f' ::*:: g') a' b')

-- | Apply binary function inside of <tt>f :*: g</tt> representation.
inProdd2 :: ((f a b, g a b) -> (f' a' b', g' a' b') -> (f'' a'' b'', g'' a'' b'')) -> ((f ::*:: g) a b -> (f' ::*:: g') a' b' -> (f'' ::*:: g'') a'' b'')

-- | Arrow-like type between type constructors (doesn't enforce <tt>Arrow
--   (~&gt;)</tt> here).
newtype Arrw j f g a
Arrw :: f a j g a -> Arrw j f g a
unArrw :: Arrw j f g a -> f a j g a
type (:->:) = Arrw (->)

-- | <tt>newtype</tt> bijection
biFun :: (f a -> g a) :<->: (f :->: g) a

-- | Compose a bijection
convFun :: (b :<->: f a) -> (c :<->: g a) -> ((b -> c) :<->: (f :->: g) a)

-- | Apply unary function inside of <tt>Arrw</tt> representation.
inArrw :: ((f a j g a) -> (f' a' j g' a')) -> ((Arrw j f g) a -> (Arrw j f' g') a')

-- | Apply binary function inside of <tt>Arrw j f g</tt> representation.
inArrw2 :: ((f a j g a) -> (f' a' j g' a') -> (f'' a'' j g'' a'')) -> (Arrw j f g a -> Arrw j f' g' a' -> Arrw j f'' g'' a'')

-- | Apply ternary function inside of <tt>Arrw j f g</tt> representation.
inArrw3 :: ((f a j g a) -> (f' a' j g' a') -> (f'' a'' j g'' a'') -> (f''' a''' j g''' a''')) -> ((Arrw j f g) a -> (Arrw j f' g') a' -> (Arrw j f'' g'') a'' -> (Arrw j f''' g''') a''')

-- | <tt>newtype</tt> bijection
biConst :: a :<->: Const a b
inConst :: (a -> b) -> (Const a u -> Const b v)
inConst2 :: (a -> b -> c) -> Const a u -> Const b v -> Const c w
inConst3 :: (a -> b -> c -> d) -> Const a u -> Const b v -> Const c w -> Const d x

-- | <tt>newtype</tt> bijection
biEndo :: (a -> a) :<->: Endo a

-- | Convenience for partial-manipulating functions
inEndo :: (Unop a -> Unop a') -> (Endo a -> Endo a')
instance Monoid (j (f a) (g a)) => Monoid (Arrw j f g a)
instance Eq (g (f a)) => Eq ((:.) g f a)
instance Show (g (f a)) => Show ((:.) g f a)
instance Show a => Show (Id a)
instance (Show (f a b), Show (g a b)) => Show ((::*::) f g a b)
instance (Eq (f a b), Eq (g a b)) => Eq ((::*::) f g a b)
instance (Ord (f a b), Ord (g a b)) => Ord ((::*::) f g a b)
instance Monoid_f Endo
instance Monoid o => Monoid (Const o a)
instance (Arrow j, Functor f, ContraFunctor g) => ContraFunctor (Arrw j f g)
instance (Arrow j, ContraFunctor f, Functor g) => Functor (Arrw j f g)
instance (Arrow f, Arrow f') => Arrow (f ::*:: f')
instance (Category f, Category f') => Category (f ::*:: f')
instance (Applicative f, Applicative g) => Applicative (f :*: g)
instance (Functor f, Functor g) => Functor (f :*: g)
instance (Monoid_f f, Monoid_f g) => Monoid_f (f :*: g)
instance Ord (f a, g a) => Ord ((:*:) f g a)
instance Eq (f a, g a) => Eq ((:*:) f g a)
instance Show (f a, g a) => Show ((:*:) f g a)
instance Traversable Id
instance Foldable Id
instance Monad Id
instance Applicative Id
instance Functor Id
instance (Applicative f, Monoid m) => Monoid (App f m)
instance ToOI OI
instance Monoid o => Monoid_f (Flip (->) o)
instance (Applicative (j a), Monoid o) => Monoid (Flip j o a)
instance Arrow arr => ContraFunctor (Flip arr b)
instance Monoid_f []
instance FunAble h => Arrow (FunA h)
instance FunAble h => Category (FunA h)
instance (Applicative f, Arrow arr) => Arrow (OO f arr)
instance (Applicative f, Category cat) => Category (OO f cat)
instance (Applicative g, Applicative f) => Applicative (g :. f)
instance (Traversable g, Traversable f) => Traversable (g :. f)
instance (Foldable g, Foldable f, Functor g) => Foldable (g :. f)
instance (Functor g, Functor f) => Functor (g :. f)


-- | Generic titling (labeling).
module Data.Title

-- | Provide a title on a value. If you can title polymorphically, please
--   instantiate <a>Title_f</a> instead of Title. Then you'll automatically
--   get a <a>Title</a> for each type instance, thanks to this rule.
--   
--   <pre>
--   instance Title_f f =&gt; Title (f a) where title = title_f
--   </pre>
--   
--   To handle ambiguity for types like <tt>([] Char)</tt> -- aka
--   <a>String</a>, this module is compiled with
--   <tt>OverlappingInstances</tt> and <tt>UndecidableInstances</tt>. The
--   more specific instance (yours) wins.
--   
--   In defining your instance, you might want to use the String instance,
--   e.g., <tt>title ttl ""</tt>.
class Title u
title :: Title u => String -> u -> u
class Title_f f
title_f :: Title_f f => String -> f a -> f a
instance [overlap ok] Title o => Title_f (Flip (->) o)
instance [overlap ok] Title b => Title (a -> b)
instance [overlap ok] Title_f IO
instance [overlap ok] Title String
instance [overlap ok] Title_f f => Title (f a)
instance [overlap ok] Title_f g => Title_f (g :. f)


-- | Context-dependent monoids
module Data.CxMonoid

-- | Dictionary for <a>CxMonoid</a>.
type MonoidDict a = (a, a -> a -> a)

-- | Type of context-dependent monoid. Includes an explicit dictionary.
newtype CxMonoid a
CxMonoid :: (MonoidDict a -> a) -> CxMonoid a
unCxMonoid :: CxMonoid a -> MonoidDict a -> a

-- | <tt>newtype</tt> bijection
biCxMonoid :: (MonoidDict a -> a) :<->: CxMonoid a
instance Title a => Title (CxMonoid a)
instance Monoid (CxMonoid a)


-- | Pair-related type constructor classes.
--   
--   This module is similar to <tt>Control.Functor.Pair</tt> in the
--   <tt>category-extras</tt> package, but it does not require a
--   <a>Functor</a> superclass.
--   
--   Temporarily, there is also Data.Zip, which contains the same
--   functionality with different naming. I'm unsure which I prefer.
module Data.Pair

-- | Type of <a>pair</a> method
type PairTy f = forall a b. f a -> f b -> f (a, b)

-- | Type constructor class for <a>pair</a>-like things. Here are some
--   standard instance templates you can fill in. They're not defined in
--   the general forms below, because they would lead to a lot of overlap.
--   
--   <pre>
--   instance Applicative f =&gt; Pair f where
--       pair = liftA2 (,)
--   instance (Applicative h, Pair f) =&gt; Pair (h :. f) where
--       pair = apPair
--   instance (Functor g, Pair g, Pair f) =&gt; Pair (g :. f)
--       where pair = ppPair
--   instance (Arrow (~&gt;), Unpair f, Pair g) =&gt; Pair (Arrw (~&gt;) f g) where
--       pair = arPair
--   instance (Monoid_f h, Copair h) =&gt; Pair h where
--       pair = copair
--   </pre>
--   
--   Also, if you have a type constructor that's a <a>Functor</a> and a
--   <a>Pair</a>, here is a way to define '(<a>*</a>)' for
--   <a>Applicative</a>:
--   
--   <pre>
--   (&lt;*&gt;) = pairWith ($)
--   </pre>
--   
--   Minimum definitions for instances.
class Pair f
pair :: Pair f => PairTy f

-- | Handy for <a>Pair</a> instances
apPair :: (Applicative h, Pair f) => PairTy (h :. f)

-- | Handy for <a>Pair</a> instances
ppPair :: (Functor g, Pair g, Pair f) => PairTy (g :. f)

-- | Pairing of <a>Arrw</a> values. <i>Warning</i>: definition uses
--   <a>arr</a>, so only use if your arrow has a working <a>arr</a>.
arPair :: (Arrow j, Unpair f, Pair g) => PairTy (Arrw j f g)

-- | Type of <a>unpair</a> method. Generalizes <a>unpair</a>.
type UnpairTy f = forall a b. f (a, b) -> (f a, f b)

-- | Unpairpable. Minimal instance definition: either (a) <a>unpair</a>
--   <i>or</i> (b) both of <a>fsts</a> <i>and</i> <a>snds</a>. A standard
--   template to substitute any <a>Functor</a> <tt>f.</tt> But watch out
--   for effects!
--   
--   <pre>
--   instance Functor f =&gt; Unpair f where {fsts = fmap fst; snds = fmap snd}
--   </pre>
class Unpair f where unpair = fsts &&& snds fsts = fst . unpair snds = snd . unpair
unpair :: Unpair f => UnpairTy f
fsts :: Unpair f => f (a, b) -> f a
snds :: Unpair f => f (a, b) -> f b

-- | Dual to <a>Unpair</a>. Especially handy for contravariant functors
--   (<a>ContraFunctor</a>) . Use this template (filling in <tt>f</tt>) :
--   
--   <pre>
--   instance ContraFunctor f =&gt; Copair f where
--     { cofsts = cofmap fst ; cosnds = cofmap snd }
--   </pre>
class Copair f
cofsts :: Copair f => f a -> f (a, b)
cosnds :: Copair f => f b -> f (a, b)

-- | Pairing of <a>Copair</a> values. Combines contribution of each.
copair :: (Copair f, Monoid_f f) => PairTy f

-- | Turn a pair of sources into a source of pair-editors. See
--   <a>http://conal.net/blog/posts/pairs-sums-and-reactivity/</a>.
--   'Functor'\/'Monoid' version. See also <a>pairEditM</a>.
pairEdit :: (Functor m, Monoid (m ((c, d) -> (c, d)))) => (m c, m d) -> m ((c, d) -> (c, d))

-- | Turn a pair of sources into a source of pair-editors. See
--   <a>http://conal.net/blog/posts/pairs-sums-and-reactivity/</a>. Monad
--   version. See also <a>pairEdit</a>.
pairEditM :: MonadPlus m => (m c, m d) -> m ((c, d) -> (c, d))
instance Pair Endo
instance Copair Endo
instance Unpair Endo
instance (Copair f, Copair g) => Copair (f :*: g)
instance (Functor h, Copair f) => Copair (h :. f)
instance Arrow j => Copair (Flip j o)
instance Copair (Const e)
instance Unpair Id
instance Unpair (Const a)
instance Unpair ((,) a)
instance Unpair ((->) a)
instance Unpair []
instance (Pair f, Pair g) => Pair (f :*: g)
instance (Arrow j, Unpair f, Pair g) => Pair (Arrw j f g)
instance (Arrow j, Monoid_f (Flip j o)) => Pair (Flip j o)
instance Pair Id
instance Monoid o => Pair (Const o)
instance Pair IO
instance Pair ((->) u)
instance Monoid u => Pair ((,) u)
instance Pair []


-- | Zip-related type constructor classes.
--   
--   This module is similar to <tt>Control.Functor.Zip</tt> in the
--   <tt>category-extras</tt> package, but it does not require a
--   <a>Functor</a> superclass.
--   
--   This module defines generalized <a>zip</a> and <a>unzip</a>, so if you
--   use it, you'll have to
--   
--   <pre>
--   import Prelude hiding (zip,zipWith,zipWith3,unzip)
--   </pre>
--   
--   Temporarily, there is also Data.Pair, which contains the same
--   functionality with different naming. I'm unsure which I prefer.
module Data.Zip

-- | Type of <a>zip</a> method
type ZipTy f = forall a b. f a -> f b -> f (a, b)

-- | Type constructor class for <a>zip</a>-like things. Here are some
--   standard instance templates you can fill in. They're not defined in
--   the general forms below, because they would lead to a lot of overlap.
--   
--   <pre>
--   instance Applicative f =&gt; Zip f where
--       zip = liftA2 (,)
--   instance (Applicative h, Zip f) =&gt; Zip (h :. f) where
--       zip = apZip
--   instance (Functor g, Zip g, Zip f) =&gt; Zip (g :. f)
--       where zip = ppZip
--   instance (Arrow (~&gt;), Unzip f, Zip g) =&gt; Zip (Arrw (~&gt;) f g) where
--       zip = arZip
--   instance (Monoid_f h, Cozip h) =&gt; Zip h where
--       zip = cozip
--   </pre>
--   
--   Also, if you have a type constructor that's a <a>Functor</a> and a
--   <a>Zip</a>, here is a way to define '(<a>*</a>)' for
--   <a>Applicative</a>:
--   
--   <pre>
--   (&lt;*&gt;) = zipWith ($)
--   </pre>
--   
--   Minimum definitions for instances.
class Zip f
zip :: Zip f => ZipTy f

-- | Generalized <a>zipWith</a>
zipWith :: (Functor f, Zip f) => (a -> b -> c) -> (f a -> f b -> f c)

-- | Generalized <a>zipWith</a>
zipWith3 :: (Functor f, Zip f) => (a -> b -> c -> d) -> (f a -> f b -> f c -> f d)

-- | Handy for <a>Zip</a> instances
apZip :: (Applicative h, Zip f) => ZipTy (h :. f)

-- | Handy for <a>Zip</a> instances
ppZip :: (Functor g, Zip g, Zip f) => ZipTy (g :. f)

-- | Ziping of <a>Arrw</a> values. <i>Warning</i>: definition uses
--   <a>arr</a>, so only use if your arrow has a working <a>arr</a>.
arZip :: (Arrow j, Unzip f, Zip g) => ZipTy (Arrw j f g)

-- | Type of <a>unzip</a> method. Generalizes <a>unzip</a>.
type UnzipTy f = forall a b. f (a, b) -> (f a, f b)

-- | Unzippable. Minimal instance definition: either (a) <a>unzip</a>
--   <i>or</i> (b) both of <a>fsts</a> <i>and</i> <a>snds</a>. A standard
--   template to substitute any <a>Functor</a> <tt>f.</tt> But watch out
--   for effects!
--   
--   <pre>
--   instance Functor f =&gt; Unzip f where {fsts = fmap fst; snds = fmap snd}
--   </pre>
class Unzip f where unzip = fsts &&& snds fsts = fst . unzip snds = snd . unzip
unzip :: Unzip f => UnzipTy f
fsts :: Unzip f => f (a, b) -> f a
snds :: Unzip f => f (a, b) -> f b

-- | Dual to <a>Unzip</a>. Especially handy for contravariant functors
--   (<tt>Cofunctor</tt>) . Use this template (filling in <tt>f</tt>) :
--   
--   <pre>
--   instance Cofunctor f =&gt; Cozip f where
--     { cofsts = cofmap fst ; cosnds = cofmap snd }
--   </pre>
class Cozip f
cofsts :: Cozip f => f a -> f (a, b)
cosnds :: Cozip f => f b -> f (a, b)

-- | Ziping of <a>Cozip</a> values. Combines contribution of each.
cozip :: (Cozip f, Monoid_f f) => ZipTy f

-- | Turn a pair of sources into a source of pair-editors. See
--   <a>http://conal.net/blog/posts/pairs-sums-and-reactivity/</a>.
--   'Functor'\/'Monoid' version. See also <a>pairEditM</a>.
pairEdit :: (Functor m, Monoid (m ((c, d) -> (c, d)))) => (m c, m d) -> m ((c, d) -> (c, d))

-- | Turn a pair of sources into a source of pair-editors. See
--   <a>http://conal.net/blog/posts/pairs-sums-and-reactivity/</a>. Monad
--   version. See also <a>pairEdit</a>.
pairEditM :: MonadPlus m => (m c, m d) -> m ((c, d) -> (c, d))
instance Zip Endo
instance Cozip Endo
instance Unzip Endo
instance (Cozip f, Cozip g) => Cozip (f :*: g)
instance (Functor h, Cozip f) => Cozip (h :. f)
instance Arrow j => Cozip (Flip j o)
instance Cozip (Const e)
instance Unzip Id
instance Unzip (Const a)
instance Unzip ((,) a)
instance Unzip ((->) a)
instance Unzip []
instance (Zip f, Zip g) => Zip (f :*: g)
instance (Arrow j, Unzip f, Zip g) => Zip (Arrw j f g)
instance (Arrow j, Monoid_f (Flip j o)) => Zip (Flip j o)
instance Zip Id
instance Monoid o => Zip (Const o)
instance Zip IO
instance Zip ((->) u)
instance Monoid u => Zip ((,) u)
instance Zip []


-- | A monoid <a>Partial</a> of partial values. See the [Teaser] and
--   [Solution] blog posts.
--   
--   <ul>
--   <li><i>Teaser</i> :
--   <a>http://conal.net/blog/posts/a-type-for-partial-values</a>
--   [Solution]:
--   <a>http://conal.net/blog/posts/implementing-a-type-for-partial-values</a></li>
--   </ul>
--   
--   Also defines a <a>FunAble</a> instance, so that <tt>FunA Partial</tt>
--   is an arrow.
module Data.Partial

-- | Partial value. Represented an endomorphism, which is a <a>Monoid</a>
--   under <a>id</a> and '(.)'. Then <a>mempty</a> is the completely
--   undefined value, and in <tt>u `@'mappend'@` v</tt>, <tt>v</tt>
--   selectively replaces parts of <tt>u</tt>. The <a>Endo</a> instances
--   for <tt>Pair</tt>, <tt>Unpair</tt>, <tt>Copair</tt>, <tt>Unfun</tt>,
--   and <tt>Cofun</tt> are all very useful on partial values.
type Partial = Endo
type PartialX a b = Partial a -> Partial b

-- | Treat a full value as a partial one. Fully overrides any "previous"
--   (earlier argument to <tt>mappend</tt>) partial value.
valp :: c -> Partial c

-- | Force a partial value into a full one, filling in bottom for any
--   missing parts.
pval :: Partial c -> c

-- | Inverse to "element" access, on all elements. A way to inject some
--   info about every element. For <tt>f</tt>, consider '[]', <tt>(-&gt;)
--   a</tt>, <tt>Event</tt>, etc.
pUnElt :: Functor f => PartialX a (f a)

-- | Provide in info about a function argument
pUnArg :: PartialX u (u -> v)

-- | Provide info about a function result
pUnRes :: PartialX v (u -> v)

-- | Inject a partial argument-source into a partial function-sink.
pUnSrc :: PartialX a ((a -> b) -> o)
instance FunAble Partial


-- | Some function-like classes, having lambda-like construction. See
--   <a>LambdaTy</a> for why <a>lambda</a>. See <a>Data.Pair</a> for
--   similar classes.
module Data.Lambda

-- | Type of <a>lambda</a> method. Think of <tt>src</tt> as the bound
--   variable (or pattern) part of a lambda and <tt>snk</tt> as the
--   expression part. They combine to form a function-typed expression.
--   Instance template:
--   
--   <pre>
--   instance (Applicative f, Lambda src snk)
--     =&gt; Lambda (f :. src) (f :. snk) where
--       lambda = apLambda
--   </pre>
type LambdaTy src snk = forall a b. src a -> snk b -> snk (a -> b)

-- | Type constructor class for function-like things having lambda-like
--   construction.
class Lambda src snk
lambda :: Lambda src snk => LambdaTy src snk

-- | Like <tt>Unpair</tt>, but for functions. Minimal instance definition:
--   either (a) <a>unlambda</a> <i>or</i> (b) both of <a>fsrc</a>
--   <i>and</i> <a>fres</a>.
class Unlambda src snk | snk -> src where unlambda = fsrc &&& fres fsrc = fst . unlambda fres = snd . unlambda
unlambda :: Unlambda src snk => snk (a -> b) -> (src a, snk b)
fsrc :: Unlambda src snk => snk (a -> b) -> src a
fres :: Unlambda src snk => snk (a -> b) -> snk b

-- | Like <tt>Copair</tt>, but for functions
class Colambda f
cores :: Colambda f => f b -> f (a -> b)
instance Colambda Endo
instance Unlambda Endo Endo
instance (Arrow j, Unlambda f f', Lambda g g') => Lambda (Arrw j f g) (Arrw j f' g')
instance (Lambda src snk, Lambda dom' ran') => Lambda (src :*: dom') (snk :*: ran')
instance Applicative f => Lambda f (f :->: Const o)
instance Applicative f => Lambda f (Flip (->) o :. f)
instance Applicative f => Lambda f (f :. Flip (->) o)
instance Lambda IO OI
instance Lambda Id (Flip (->) o)
