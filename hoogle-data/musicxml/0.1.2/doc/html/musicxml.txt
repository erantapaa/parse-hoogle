-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | MusicXML format encoded as Haskell type and functions of reading
and writting.
--   
--   This package presents MusicXML format typed at Haskell language to be
--   interface between MusicXML format and MusicXML applications developed
--   using Haskell. This package allows read and write MusicXML documents
--   at least 2.0 version as partwise or timewise format besides opus and
--   container specification.
@package musicxml
@version 0.1.2


module Text.XML.MusicXML.Util
data Result a
Ok :: a -> Result a
Error :: String -> Result a
isOK :: Result a -> Bool
isError :: Result a -> Bool
fromOK :: Result a -> a
fromError :: Result a -> String
newtype State s a
State :: (s -> (s, a)) -> State s a
state :: State s a -> s -> (s, a)
liftState :: (s -> a) -> State s a
newtype StateT m s a
StateT :: (s -> m (s, a)) -> StateT m s a
stateT :: StateT m s a -> s -> m (s, a)
liftStateT :: (Monad m) => State s (m a) -> StateT m s a
returnStateT :: (Monad m) => m a -> StateT m s a
type CDATA = String
read_CDATA :: String -> Result CDATA
show_CDATA :: CDATA -> String
type ID = String
read_ID :: String -> Result ID
show_ID :: ID -> String
read_IMPLIED' :: String -> (String -> Result a) -> [Attribute] -> Maybe a
read_IMPLIED :: (Monad m) => String -> (String -> Result a) -> StateT m [Attribute] (Maybe a)
show_IMPLIED :: String -> (a -> String) -> Maybe a -> [Attribute]
read_REQUIRED :: (Monad m) => String -> (String -> Result a) -> StateT m [Attribute] a
show_REQUIRED :: String -> (a -> String) -> a -> [Attribute]
read_DEFAULT :: (Monad m) => String -> (String -> Result a) -> a -> StateT m [Attribute] a
show_DEFAULT :: String -> (a -> String) -> a -> [Attribute]
show_FIXED :: String -> (a -> String) -> a -> [Attribute]
read_FIXED :: (Monad m) => String -> (String -> Result a) -> a -> StateT m [Attribute] a
read_ELEMENT' :: String -> [Content i] -> ([Content i], Result (Element i))
read_ELEMENT :: String -> StateT Result [Content i] (Element i)
show_ELEMENT :: String -> [Attribute] -> [Content ()] -> [Content ()]
attributes :: Element i -> [Attribute]
childs :: Element i -> [Content i]
type PCDATA = String
read_PCDATA' :: [Content i] -> ([Content i], Result PCDATA)
read_REF :: Reference -> PCDATA
read_PCDATA :: StateT Result [Content i] PCDATA
show_PCDATA :: PCDATA -> [Content ()]
read_MAYBE :: StateT Result [Content i] a -> StateT Result [Content i] (Maybe a)
show_MAYBE :: (a -> [Content ()]) -> Maybe a -> [Content ()]
read_LIST :: (Eq i) => StateT Result [Content i] a -> StateT Result [Content i] [a]
show_LIST :: (a -> [Content ()]) -> [a] -> [Content ()]
read_LIST1 :: (Eq i) => StateT Result [Content i] a -> StateT Result [Content i] [a]
show_LIST1 :: (a -> [Content ()]) -> [a] -> [Content ()]
read_1 :: (Monad m) => StateT m s a -> s -> StateT m s' a
read_2 :: (Monad m) => StateT m s a -> StateT m s b -> s -> StateT m s' (a, b)
read_3 :: (Monad m) => StateT m s a -> StateT m s b -> StateT m s c -> s -> StateT m s' (a, b, c)
read_4 :: (Monad m) => StateT m s a -> StateT m s b -> StateT m s c -> StateT m s d -> s -> StateT m s' (a, b, c, d)
read_5 :: (Monad m) => StateT m s a -> StateT m s b -> StateT m s c -> StateT m s d -> StateT m s e -> s -> StateT m s' (a, b, c, d, e)
read_6 :: (Monad m) => StateT m s a -> StateT m s b -> StateT m s c -> StateT m s d -> StateT m s e -> StateT m s f -> s -> StateT m s' (a, b, c, d, e, f)
read_7 :: (Monad m) => StateT m s a -> StateT m s b -> StateT m s c -> StateT m s d -> StateT m s e -> StateT m s f -> StateT m s g -> s -> StateT m s' (a, b, c, d, e, f, g)
read_8 :: (Monad m) => StateT m s a -> StateT m s b -> StateT m s c -> StateT m s d -> StateT m s e -> StateT m s f -> StateT m s g -> StateT m s h -> s -> StateT m s' (a, b, c, d, e, f, g, h)
read_9 :: (Monad m) => StateT m s a -> StateT m s b -> StateT m s c -> StateT m s d -> StateT m s e -> StateT m s f -> StateT m s g -> StateT m s h -> StateT m s i -> s -> StateT m s' (a, b, c, d, e, f, g, h, i)
read_10 :: (Monad m) => StateT m s a -> StateT m s b -> StateT m s c -> StateT m s d -> StateT m s e -> StateT m s f -> StateT m s g -> StateT m s h -> StateT m s i -> StateT m s j -> s -> StateT m s' (a, b, c, d, e, f, g, h, i, j)
read_11 :: (Monad m) => StateT m s a -> StateT m s b -> StateT m s c -> StateT m s d -> StateT m s e -> StateT m s f -> StateT m s g -> StateT m s h -> StateT m s i -> StateT m s j -> StateT m s k -> s -> StateT m s' (a, b, c, d, e, f, g, h, i, j, k)
read_12 :: (Monad m) => StateT m s a -> StateT m s b -> StateT m s c -> StateT m s d -> StateT m s e -> StateT m s f -> StateT m s g -> StateT m s h -> StateT m s i -> StateT m s j -> StateT m s k -> StateT m s l -> s -> StateT m s' (a, b, c, d, e, f, g, h, i, j, k, l)
read_13 :: (Monad m) => StateT m s a -> StateT m s b -> StateT m s c -> StateT m s d -> StateT m s e -> StateT m s f -> StateT m s g -> StateT m s h -> StateT m s i -> StateT m s j -> StateT m s k -> StateT m s l -> StateT m s n -> s -> StateT m s' (a, b, c, d, e, f, g, h, i, j, k, l, n)
read_17 :: (Monad m) => StateT m s a -> StateT m s b -> StateT m s c -> StateT m s d -> StateT m s e -> StateT m s f -> StateT m s g -> StateT m s h -> StateT m s i -> StateT m s j -> StateT m s k -> StateT m s l -> StateT m s n -> StateT m s o -> StateT m s p -> StateT m s q -> StateT m s r -> s -> StateT m s' (a, b, c, d, e, f, g, h, i, j, k, l, n, o, p, q, r)
instance (Eq a) => Eq (Result a)
instance (Show a) => Show (Result a)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k, Eq l, Eq m, Eq n, Eq o, Eq p, Eq q) => Eq (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i, Show j, Show k, Show l, Show m, Show n, Show o, Show p, Show q) => Show (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
instance (Monad m) => Functor (StateT m s)
instance (MonadPlus m) => MonadPlus (StateT m s)
instance (Monad m) => Monad (StateT m s)
instance Functor (State s)
instance Monad (State s)
instance MonadPlus Result
instance Functor Result
instance Monad Result


module Text.XML.MusicXML.Common
type YYYY_MM_DD = PCDATA
read_YYYY_MM_DD :: StateT Result [Content i] YYYY_MM_DD
show_YYYY_MM_DD :: YYYY_MM_DD -> [Content ()]
type Tenths = CDATA
read_Tenths :: String -> Result Tenths
show_Tenths :: Tenths -> String
type Layout_Tenths = PCDATA
read_Layout_Tenths :: StateT Result [Content i] Layout_Tenths
show_Layout_Tenths :: Layout_Tenths -> [Content ()]
data Start_Stop
Start_Stop_1 :: Start_Stop
Start_Stop_2 :: Start_Stop
read_Start_Stop :: String -> Result Start_Stop
show_Start_Stop :: Start_Stop -> String
data Start_Stop_Continue
Start_Stop_Continue_1 :: Start_Stop_Continue
Start_Stop_Continue_2 :: Start_Stop_Continue
Start_Stop_Continue_3 :: Start_Stop_Continue
read_Start_Stop_Continue :: String -> Result Start_Stop_Continue
show_Start_Stop_Continue :: Start_Stop_Continue -> String
data Start_Stop_Single
Start_Stop_Single_1 :: Start_Stop_Single
Start_Stop_Single_2 :: Start_Stop_Single
Start_Stop_Single_3 :: Start_Stop_Single
read_Start_Stop_Single :: String -> Result Start_Stop_Single
show_Start_Stop_Single :: Start_Stop_Single -> String

-- | The yes-no entity is used for boolean-like attributes.
type Yes_No = Bool
read_Yes_No :: String -> Result Yes_No
show_Yes_No :: Yes_No -> String
type Yes_No_Number = CDATA
read_Yes_No_Number :: String -> Result Yes_No_Number
show_Yes_No_Number :: Yes_No_Number -> String
data Symbol_Size
Symbol_Size_1 :: Symbol_Size
Symbol_Size_2 :: Symbol_Size
Symbol_Size_3 :: Symbol_Size
read_Symbol_Size :: String -> Result Symbol_Size
show_Symbol_Size :: Symbol_Size -> String
data Up_Down
Up_Down_1 :: Up_Down
Up_Down_2 :: Up_Down
read_Up_Down :: String -> Result Up_Down
show_Up_Down :: Up_Down -> String
data Top_Bottom
Top_Bottom_1 :: Top_Bottom
Top_Bottom_2 :: Top_Bottom
read_Top_Bottom :: String -> Result Top_Bottom
show_Top_Bottom :: Top_Bottom -> String
data Left_Right
Left_Right_1 :: Left_Right
Left_Right_2 :: Left_Right
read_Left_Right :: String -> Result Left_Right
show_Left_Right :: Left_Right -> String
data Number_Of_Lines
Number_Of_Lines_0 :: Number_Of_Lines
Number_Of_Lines_1 :: Number_Of_Lines
Number_Of_Lines_2 :: Number_Of_Lines
Number_Of_Lines_3 :: Number_Of_Lines
read_Number_Of_Lines :: String -> Result Number_Of_Lines
show_Number_Of_Lines :: Number_Of_Lines -> String
data Number_Level
Number_Level_1 :: Number_Level
Number_Level_2 :: Number_Level
Number_Level_3 :: Number_Level
Number_Level_4 :: Number_Level
Number_Level_5 :: Number_Level
Number_Level_6 :: Number_Level
read_Number_Level :: String -> Result Number_Level
show_Number_Level :: Number_Level -> String
data Beam_Level
Beam_Level_1 :: Beam_Level
Beam_Level_2 :: Beam_Level
Beam_Level_3 :: Beam_Level
Beam_Level_4 :: Beam_Level
Beam_Level_5 :: Beam_Level
Beam_Level_6 :: Beam_Level
read_Beam_Level :: String -> Result Beam_Level
show_Beam_Level :: Beam_Level -> String
type Position = (Maybe Tenths, Maybe Tenths, Maybe Tenths, Maybe Tenths)
read_Position :: StateT Result [Attribute] Position
show_Position :: Position -> [Attribute]
type Placement = Maybe Placement_
read_Placement :: StateT Result [Attribute] Placement
show_Placement :: Placement -> [Attribute]
data Placement_
Placement_1 :: Placement_
Placement_2 :: Placement_
read_Placement_ :: String -> Result Placement_
show_Placement_ :: Placement_ -> String
type Orientation = Maybe Orientation_
read_Orientation :: StateT Result [Attribute] Orientation
show_Orientation :: Orientation -> [Attribute]
data Orientation_
Orientation_1 :: Orientation_
Orientation_2 :: Orientation_
read_Orientation_ :: String -> Result Orientation_
show_Orientation_ :: Orientation_ -> String
type Directive = Maybe Yes_No
read_Directive :: StateT Result [Attribute] Directive
show_Directive :: Directive -> [Attribute]
type Bezier = (Maybe CDATA, Maybe CDATA, Maybe Tenths, Maybe Tenths, Maybe Tenths, Maybe Tenths)
read_Bezier :: StateT Result [Attribute] Bezier
show_Bezier :: Bezier -> [Attribute]
type Font = (Maybe CDATA, Maybe CDATA, Maybe CDATA, Maybe CDATA)
read_Font :: StateT Result [Attribute] Font
show_Font :: Font -> [Attribute]
type Color = Maybe CDATA
read_Color :: StateT Result [Attribute] Color
show_Color :: Color -> [Attribute]
type Text_Decoration = (Maybe Number_Of_Lines, Maybe Number_Of_Lines, Maybe Number_Of_Lines)
read_Text_Decoration :: StateT Result [Attribute] Text_Decoration
show_Text_Decoration :: Text_Decoration -> [Attribute]
type Justify = Maybe Justify_
read_Justify :: StateT Result [Attribute] Justify
show_Justify :: Justify -> [Attribute]
data Justify_
Justify_1 :: Justify_
Justify_2 :: Justify_
Justify_3 :: Justify_
read_Justify_ :: String -> Result Justify_
show_Justify_ :: Justify_ -> String
type Halign = Maybe Halign_
read_Halign :: StateT Result [Attribute] Halign
show_Halign :: Halign -> [Attribute]
data Halign_
Halign_1 :: Halign_
Halign_2 :: Halign_
Halign_3 :: Halign_
read_Halign_ :: String -> Result Halign_
show_Halign_ :: Halign_ -> String
type Valign = Maybe Valign_
read_Valign :: StateT Result [Attribute] Valign
show_Valign :: Valign -> [Attribute]
data Valign_
Valign_1 :: Valign_
Valign_2 :: Valign_
Valign_3 :: Valign_
Valign_4 :: Valign_
read_Valign_ :: String -> Result Valign_
show_Valign_ :: Valign_ -> String
type Valign_Image = Maybe Valign_Image_
read_Valign_Image :: StateT Result [Attribute] Valign_Image
show_Valign_Image :: Valign_Image -> [Attribute]
data Valign_Image_
Valign_Image_1 :: Valign_Image_
Valign_Image_2 :: Valign_Image_
Valign_Image_3 :: Valign_Image_
read_Valign_Image_ :: String -> Result Valign_Image_
show_Valign_Image_ :: Valign_Image_ -> String
type Letter_Spacing = Maybe CDATA
read_Letter_Spacing :: StateT Result [Attribute] Letter_Spacing
show_Letter_Spacing :: Letter_Spacing -> [Attribute]
type Line_Height = Maybe CDATA
read_Line_Height :: StateT Result [Attribute] Line_Height
show_Line_Height :: Line_Height -> [Attribute]
type Text_Direction = Maybe Text_Direction_
read_Text_Direction :: StateT Result [Attribute] Text_Direction
show_Text_Direction :: Text_Direction -> [Attribute]
data Text_Direction_
Text_Direction_1 :: Text_Direction_
Text_Direction_2 :: Text_Direction_
Text_Direction_3 :: Text_Direction_
Text_Direction_4 :: Text_Direction_
read_Text_Direction_ :: String -> Result Text_Direction_
show_Text_Direction_ :: Text_Direction_ -> String
type Text_Rotation = Maybe CDATA
read_Text_Rotation :: StateT Result [Attribute] Text_Rotation
show_Text_Rotation :: Text_Rotation -> [Attribute]
type Print_Style = (Position, Font, Color)
read_Print_Style :: StateT Result [Attribute] Print_Style
show_Print_Style :: Print_Style -> [Attribute]
type Line_Shape = Maybe Line_Shape_
read_Line_Shape :: StateT Result [Attribute] Line_Shape
show_Line_Shape :: Line_Shape -> [Attribute]
data Line_Shape_
Line_Shape_1 :: Line_Shape_
Line_Shape_2 :: Line_Shape_
read_Line_Shape_ :: String -> Result Line_Shape_
show_Line_Shape_ :: Line_Shape_ -> String
type Line_Type = Maybe Line_Type_
read_Line_Type :: StateT Result [Attribute] Line_Type
show_Line_Type :: Line_Type -> [Attribute]
data Line_Type_
Line_Type_1 :: Line_Type_
Line_Type_2 :: Line_Type_
Line_Type_3 :: Line_Type_
Line_Type_4 :: Line_Type_
read_Line_Type_ :: String -> Result Line_Type_
show_Line_Type_ :: Line_Type_ -> String
type Print_Object = Maybe Yes_No
read_Print_Object :: StateT Result [Attribute] Print_Object
show_Print_Object :: Print_Object -> [Attribute]
type Print_Spacing = Maybe Yes_No
read_Print_Spacing :: StateT Result [Attribute] Print_Spacing
show_Print_Spacing :: Print_Spacing -> [Attribute]
type Printout = (Print_Object, Maybe Yes_No, Print_Spacing, Maybe Yes_No)
read_Printout :: StateT Result [Attribute] Printout
show_Printout :: Printout -> [Attribute]
type Text_Formatting = (Justify, Halign, Valign, Print_Style, Text_Decoration, Text_Rotation, Letter_Spacing, Line_Height, Maybe CDATA, Text_Direction, Maybe Text_Formatting_)
read_Text_Formatting :: StateT Result [Attribute] Text_Formatting
show_Text_Formatting :: Text_Formatting -> [Attribute]
data Text_Formatting_
Text_Formatting_1 :: Text_Formatting_
Text_Formatting_2 :: Text_Formatting_
Text_Formatting_3 :: Text_Formatting_
read_Text_Formatting_ :: String -> Result Text_Formatting_
show_Text_Formatting_ :: Text_Formatting_ -> String
type Level_Display = (Maybe Yes_No, Maybe Yes_No, Maybe Symbol_Size)
read_Level_Display :: StateT Result [Attribute] Level_Display
show_Level_Display :: Level_Display -> [Attribute]
type Trill_Sound = (Maybe Trill_Sound_A, Maybe Trill_Sound_B, Maybe Trill_Sound_C, Maybe Bool, Maybe CDATA, Maybe CDATA, Maybe CDATA)
read_Trill_Sound :: StateT Result [Attribute] Trill_Sound
show_Trill_Sound :: Trill_Sound -> [Attribute]
data Trill_Sound_A
Trill_Sound_1 :: Trill_Sound_A
Trill_Sound_2 :: Trill_Sound_A
Trill_Sound_3 :: Trill_Sound_A
read_Trill_Sound_A :: String -> Result Trill_Sound_A
show_Trill_Sound_A :: Trill_Sound_A -> String
data Trill_Sound_B
Trill_Sound_4 :: Trill_Sound_B
Trill_Sound_5 :: Trill_Sound_B
Trill_Sound_6 :: Trill_Sound_B
read_Trill_Sound_B :: String -> Result Trill_Sound_B
show_Trill_Sound_B :: Trill_Sound_B -> String
data Trill_Sound_C
Trill_Sound_7 :: Trill_Sound_C
Trill_Sound_8 :: Trill_Sound_C
Trill_Sound_9 :: Trill_Sound_C
read_Trill_Sound_C :: String -> Result Trill_Sound_C
show_Trill_Sound_C :: Trill_Sound_C -> String
type Bend_Sound = (Maybe Yes_No, Maybe CDATA, Maybe CDATA, Maybe CDATA)
read_Bend_Sound :: StateT Result [Attribute] Bend_Sound
show_Bend_Sound :: Bend_Sound -> [Attribute]
type Document_Attributes = CDATA
read_Document_Attributes :: StateT Result [Attribute] Document_Attributes
show_Document_Attributes :: Document_Attributes -> [Attribute]
type Editorial = (Maybe Footnote, Maybe Level)
read_Editorial :: StateT Result [Content i] (Editorial)
show_Editorial :: Editorial -> [Content ()]
type Editorial_Voice = (Maybe Footnote, Maybe Level, Maybe Voice)
read_Editorial_Voice :: StateT Result [Content i] Editorial_Voice
show_Editorial_Voice :: Editorial_Voice -> [Content ()]
type Footnote = (Text_Formatting, PCDATA)
read_Footnote :: StateT Result [Content i] Footnote
show_Footnote :: Footnote -> [Content ()]
type Level = ((Maybe Yes_No, Level_Display), PCDATA)
read_Level :: StateT Result [Content i] Level
show_Level :: Level -> [Content ()]
type Voice = PCDATA
read_Voice :: StateT Result [Content i] Voice
show_Voice :: Voice -> [Content ()]
type Fermata = ((Maybe Fermata_, Print_Style), PCDATA)
data Fermata_
Fermata_1 :: Fermata_
Fermata_2 :: Fermata_
read_Fermata_ :: String -> Result Fermata_
show_Fermata_ :: Fermata_ -> String
read_Fermata :: StateT Result [Content i] Fermata
show_Fermata :: Fermata -> [Content ()]
type Wavy_Line = ((Start_Stop_Continue, Maybe Number_Level, Position, Placement, Color, Trill_Sound), ())
read_Wavy_Line :: StateT Result [Content i] Wavy_Line
show_Wavy_Line :: Wavy_Line -> [Content ()]
type Staff = PCDATA
read_Staff :: StateT Result [Content i] Staff
show_Staff :: Staff -> [Content ()]
type Segno = (Print_Style, ())
read_Segno :: StateT Result [Content i] Segno
show_Segno :: Segno -> [Content ()]
type Coda = (Print_Style, ())
read_Coda :: StateT Result [Content i] Coda
show_Coda :: Coda -> [Content ()]
type Actual_Notes = PCDATA
read_Actual_Notes :: StateT Result [Content i] Actual_Notes
show_Actual_Notes :: Actual_Notes -> [Content ()]
type Normal_Notes = PCDATA
read_Normal_Notes :: StateT Result [Content i] Normal_Notes
show_Normal_Notes :: Normal_Notes -> [Content ()]
type Normal_Type = PCDATA
read_Normal_Type :: StateT Result [Content i] Normal_Type
show_Normal_Type :: Normal_Type -> [Content ()]
type Normal_Dot = ()
read_Normal_Dot :: StateT Result [Content i] Normal_Dot
show_Normal_Dot :: Normal_Dot -> [Content ()]
type Dynamics = ((Print_Style, Placement), [Dynamics_])
read_Dynamics :: (Eq i) => StateT Result [Content i] Dynamics
show_Dynamics :: Dynamics -> [Content ()]
data Dynamics_
Dynamics_1 :: P -> Dynamics_
Dynamics_2 :: PP -> Dynamics_
Dynamics_3 :: PPP -> Dynamics_
Dynamics_4 :: PPPP -> Dynamics_
Dynamics_5 :: PPPPP -> Dynamics_
Dynamics_6 :: PPPPPP -> Dynamics_
Dynamics_7 :: F -> Dynamics_
Dynamics_8 :: FF -> Dynamics_
Dynamics_9 :: FFF -> Dynamics_
Dynamics_10 :: FFFF -> Dynamics_
Dynamics_11 :: FFFFF -> Dynamics_
Dynamics_12 :: FFFFFF -> Dynamics_
Dynamics_13 :: MP -> Dynamics_
Dynamics_14 :: MF -> Dynamics_
Dynamics_15 :: SF -> Dynamics_
Dynamics_16 :: SFP -> Dynamics_
Dynamics_17 :: SFPP -> Dynamics_
Dynamics_18 :: FP -> Dynamics_
Dynamics_19 :: RF -> Dynamics_
Dynamics_20 :: RFZ -> Dynamics_
Dynamics_21 :: SFZ -> Dynamics_
Dynamics_22 :: SFFZ -> Dynamics_
Dynamics_23 :: FZ -> Dynamics_
Dynamics_24 :: Other_Dynamics -> Dynamics_
read_Dynamics_ :: StateT Result [Content i] Dynamics_
show_Dynamics_ :: Dynamics_ -> [Content ()]
type P = ()
read_P :: StateT Result [Content i] P
show_P :: P -> [Content ()]
type PP = ()
read_PP :: StateT Result [Content i] PP
show_PP :: PP -> [Content ()]
type PPP = ()
read_PPP :: StateT Result [Content i] PPP
show_PPP :: PPP -> [Content ()]
type PPPP = ()
read_PPPP :: StateT Result [Content i] PPPP
show_PPPP :: PPPP -> [Content ()]
type PPPPP = ()
read_PPPPP :: StateT Result [Content i] PPPPP
show_PPPPP :: PPPPP -> [Content ()]
type PPPPPP = ()
read_PPPPPP :: StateT Result [Content i] PPPPPP
show_PPPPPP :: PPPPPP -> [Content ()]
type FFFFFF = ()
read_FFFFFF :: StateT Result [Content i] FFFFFF
show_FFFFFF :: FFFFFF -> [Content ()]
type FFFFF = ()
read_FFFFF :: StateT Result [Content i] FFFFF
show_FFFFF :: FFFFF -> [Content ()]
type FFFF = ()
read_FFFF :: StateT Result [Content i] FFFF
show_FFFF :: FFFF -> [Content ()]
type FFF = ()
read_FFF :: StateT Result [Content i] FFF
show_FFF :: FFF -> [Content ()]
type FF = ()
read_FF :: StateT Result [Content i] FF
show_FF :: FF -> [Content ()]
type F = ()
read_F :: StateT Result [Content i] F
show_F :: F -> [Content ()]
type MP = ()
read_MP :: StateT Result [Content i] MP
show_MP :: MP -> [Content ()]
type MF = ()
read_MF :: StateT Result [Content i] MF
show_MF :: MF -> [Content ()]
type SF = ()
read_SF :: StateT Result [Content i] SF
show_SF :: SF -> [Content ()]
type SFP = ()
read_SFP :: StateT Result [Content i] SFP
show_SFP :: SFP -> [Content ()]
type SFPP = ()
read_SFPP :: StateT Result [Content i] SFPP
show_SFPP :: SFPP -> [Content ()]
type FP = ()
read_FP :: StateT Result [Content i] FP
show_FP :: FP -> [Content ()]
type RF = ()
read_RF :: StateT Result [Content i] RF
show_RF :: RF -> [Content ()]
type RFZ = ()
read_RFZ :: StateT Result [Content i] RFZ
show_RFZ :: RFZ -> [Content ()]
type SFZ = ()
read_SFZ :: StateT Result [Content i] SFZ
show_SFZ :: SFZ -> [Content ()]
type SFFZ = ()
read_SFFZ :: StateT Result [Content i] SFFZ
show_SFFZ :: SFFZ -> [Content ()]
type FZ = ()
read_FZ :: StateT Result [Content i] FZ
show_FZ :: FZ -> [Content ()]
type Other_Dynamics = PCDATA
read_Other_Dynamics :: StateT Result [Content i] Other_Dynamics
show_Other_Dynamics :: Other_Dynamics -> [Content ()]
type Fingering = ((Maybe Yes_No, Maybe Yes_No, Print_Style, Placement), PCDATA)
read_Fingering :: StateT Result [Content i] Fingering
show_Fingering :: Fingering -> [Content ()]
type Fret = ((Font, Color), PCDATA)
read_Fret :: StateT Result [Content i] Fret
show_Fret :: Fret -> [Content ()]
type String = ((Print_Style, Placement), PCDATA)
read_String :: StateT Result [Content i] String
show_String :: String -> [Content ()]
type Tuning_Step = PCDATA
read_Tuning_Step :: StateT Result [Content i] Tuning_Step
show_Tuning_Step :: Tuning_Step -> [Content ()]
type Tuning_Alter = PCDATA
read_Tuning_Alter :: StateT Result [Content i] Tuning_Alter
show_Tuning_Alter :: Tuning_Alter -> [Content ()]
type Tuning_Octave = PCDATA
read_Tuning_Octave :: StateT Result [Content i] Tuning_Octave
show_Tuning_Octave :: Tuning_Octave -> [Content ()]
type Display_Text = (Text_Formatting, PCDATA)
read_Display_Text :: StateT Result [Content i] Display_Text
show_Display_Text :: Display_Text -> [Content ()]
type Accidental_Text = (Text_Formatting, PCDATA)
read_Accidental_Text :: StateT Result [Content i] Accidental_Text
show_Accidental_Text :: Accidental_Text -> [Content ()]
type Part_Name_Display = (Print_Object, [Part_Name_Display_])
read_Part_Name_Display :: (Eq i) => StateT Result [Content i] Part_Name_Display
show_Part_Name_Display :: Part_Name_Display -> [Content ()]
data Part_Name_Display_
Part_Name_Display_1 :: Display_Text -> Part_Name_Display_
Part_Name_Display_2 :: Accidental_Text -> Part_Name_Display_
read_Part_Name_Display_ :: StateT Result [Content i] Part_Name_Display_
show_Part_Name_Display_ :: Part_Name_Display_ -> [Content ()]
type Part_Abbreviation_Display = (Print_Object, [Part_Abbreviation_Display_])
read_Part_Abbreviation_Display :: (Eq i) => StateT Result [Content i] Part_Abbreviation_Display
show_Part_Abbreviation_Display :: Part_Abbreviation_Display -> [Content ()]
data Part_Abbreviation_Display_
Part_Abbreviation_Display_1 :: Display_Text -> Part_Abbreviation_Display_
Part_Abbreviation_Display_2 :: Accidental_Text -> Part_Abbreviation_Display_
read_Part_Abbreviation_Display_ :: StateT Result [Content i] Part_Abbreviation_Display_
show_Part_Abbreviation_Display_ :: Part_Abbreviation_Display_ -> [Content ()]
type Midi_Instrument = (ID, (Maybe Midi_Channel, Maybe Midi_Name, Maybe Midi_Bank, Maybe Midi_Program, Maybe Midi_Unpitched, Maybe Volume, Maybe Pan, Maybe Elevation))
read_Midi_Instrument :: StateT Result [Content i] Midi_Instrument
show_Midi_Instrument :: Midi_Instrument -> [Content ()]
type Midi_Channel = PCDATA
read_Midi_Channel :: StateT Result [Content i] Midi_Channel
show_Midi_Channel :: Midi_Channel -> [Content ()]
type Midi_Name = PCDATA
read_Midi_Name :: StateT Result [Content i] Midi_Name
show_Midi_Name :: Midi_Name -> [Content ()]
type Midi_Bank = PCDATA
read_Midi_Bank :: StateT Result [Content i] Midi_Bank
show_Midi_Bank :: Midi_Bank -> [Content ()]
type Midi_Program = PCDATA
read_Midi_Program :: StateT Result [Content i] Midi_Program
show_Midi_Program :: Midi_Program -> [Content ()]
type Midi_Unpitched = PCDATA
read_Midi_Unpitched :: StateT Result [Content i] Midi_Unpitched
show_Midi_Unpitched :: Midi_Unpitched -> [Content ()]
type Volume = PCDATA
read_Volume :: StateT Result [Content i] Volume
show_Volume :: Volume -> [Content ()]
type Pan = PCDATA
read_Pan :: StateT Result [Content i] Pan
show_Pan :: Pan -> [Content ()]
type Elevation = PCDATA
read_Elevation :: StateT Result [Content i] Elevation
show_Elevation :: Elevation -> [Content ()]
instance Eq Part_Abbreviation_Display_
instance Show Part_Abbreviation_Display_
instance Eq Part_Name_Display_
instance Show Part_Name_Display_
instance Eq Dynamics_
instance Show Dynamics_
instance Eq Fermata_
instance Show Fermata_
instance Eq Trill_Sound_C
instance Show Trill_Sound_C
instance Eq Trill_Sound_B
instance Show Trill_Sound_B
instance Eq Trill_Sound_A
instance Show Trill_Sound_A
instance Eq Text_Formatting_
instance Show Text_Formatting_
instance Eq Line_Type_
instance Show Line_Type_
instance Eq Line_Shape_
instance Show Line_Shape_
instance Eq Text_Direction_
instance Show Text_Direction_
instance Eq Valign_Image_
instance Show Valign_Image_
instance Eq Valign_
instance Show Valign_
instance Eq Halign_
instance Show Halign_
instance Eq Justify_
instance Show Justify_
instance Eq Orientation_
instance Show Orientation_
instance Eq Placement_
instance Show Placement_
instance Eq Beam_Level
instance Show Beam_Level
instance Eq Number_Level
instance Show Number_Level
instance Eq Number_Of_Lines
instance Show Number_Of_Lines
instance Eq Left_Right
instance Show Left_Right
instance Eq Top_Bottom
instance Show Top_Bottom
instance Eq Up_Down
instance Show Up_Down
instance Eq Symbol_Size
instance Show Symbol_Size
instance Eq Start_Stop_Single
instance Show Start_Stop_Single
instance Eq Start_Stop_Continue
instance Show Start_Stop_Continue
instance Eq Start_Stop
instance Show Start_Stop


module Text.XML.MusicXML.Attributes
type Attributes = (Editorial, Maybe Divisions, [Key], [Time], Maybe Staves, Maybe Part_Symbol, Maybe Instruments, [Clef], [Staff_Details], Maybe Transpose, [Directive], [Measure_Style])
read_Attributes :: (Eq i) => StateT Result [Content i] Attributes
show_Attributes :: Attributes -> [Content ()]
type Key = ((Maybe CDATA, Print_Style, Print_Object), (Key_, [Key_Octave]))
read_Key :: (Eq i) => StateT Result [Content i] Key
show_Key :: Key -> [Content ()]
data Key_
Key_1 :: (Maybe Cancel, Fifths, Maybe Mode) -> Key_
Key_2 :: [(Key_Step, Key_Alter)] -> Key_
read_Key_ :: (Eq i) => StateT Result [Content i] Key_
show_Key_ :: Key_ -> [Content ()]
read_Key_aux1 :: (Eq i) => StateT Result [Content i] (Maybe Cancel, Fifths, Maybe Mode)
read_Key_aux2 :: (Eq i) => StateT Result [Content i] (Key_Step, Key_Alter)
show_Key_aux1 :: (Key_Step, Key_Alter) -> [Content ()]
type Cancel = (Maybe Left_Right, PCDATA)
read_Cancel :: StateT Result [Content i] Cancel
show_Cancel :: Cancel -> [Content ()]
type Fifths = PCDATA
read_Fifths :: StateT Result [Content i] Fifths
show_Fifths :: Fifths -> [Content ()]
type Mode = PCDATA
read_Mode :: StateT Result [Content i] Mode
show_Mode :: Mode -> [Content ()]
type Key_Step = PCDATA
read_Key_Step :: StateT Result [Content i] Key_Step
show_Key_Step :: Key_Step -> [Content ()]
type Key_Alter = PCDATA
read_Key_Alter :: StateT Result [Content i] Key_Alter
show_Key_Alter :: Key_Alter -> [Content ()]
type Key_Octave = ((CDATA, Maybe Yes_No), PCDATA)
read_Key_Octave :: StateT Result [Content i] Key_Octave
show_Key_Octave :: Key_Octave -> [Content ()]
type Divisions = PCDATA
read_Divisions :: StateT Result [Content i] Divisions
show_Divisions :: Divisions -> [Content ()]
type Time = ((Maybe CDATA, Maybe Time_A, Print_Style, Print_Object), Time_B)
read_Time :: (Eq i) => StateT Result [Content i] Time
show_Time :: Time -> [Content ()]
data Time_A
Time_1 :: Time_A
Time_2 :: Time_A
Time_3 :: Time_A
Time_4 :: Time_A
read_Time_A :: String -> Result Time_A
show_Time_A :: Time_A -> String
data Time_B
Time_5 :: [(Beats, Beat_Type)] -> Time_B
Time_6 :: Senza_Misura -> Time_B
read_Time_B :: (Eq i) => StateT Result [Content i] Time_B
show_Time_B :: Time_B -> [Content ()]
read_Time_B_aux1 :: StateT Result [Content i] (Beats, Beat_Type)
show_Time_B_aux1 :: (Beats, Beat_Type) -> [Content ()]
type Beats = PCDATA
read_Beats :: StateT Result [Content i] Beats
show_Beats :: Beats -> [Content ()]
type Beat_Type = PCDATA
read_Beat_Type :: StateT Result [Content i] Beat_Type
show_Beat_Type :: Beat_Type -> [Content ()]
type Senza_Misura = ()
read_Senza_Misura :: StateT Result [Content i] Senza_Misura
show_Senza_Misura :: Senza_Misura -> [Content ()]
type Staves = PCDATA
read_Staves :: StateT Result [Content i] Staves
show_Staves :: Staves -> [Content ()]
type Part_Symbol = ((Maybe CDATA, Maybe CDATA, Position, Color), PCDATA)
read_Part_Symbol :: StateT Result [Content i] Part_Symbol
show_Part_Symbol :: Part_Symbol -> [Content ()]
type Instruments = PCDATA
read_Instruments :: StateT Result [Content i] Instruments
show_Instruments :: Instruments -> [Content ()]
type Clef = ((Maybe CDATA, Maybe Yes_No, Maybe Symbol_Size, Print_Style, Print_Object), (Sign, Maybe Line, Maybe Clef_Octave_Change))
read_Clef :: (Eq i) => StateT Result [Content i] Clef
show_Clef :: Clef -> [Content ()]
type Sign = PCDATA
read_Sign :: StateT Result [Content i] Sign
show_Sign :: Sign -> [Content ()]
type Line = PCDATA
read_Line :: StateT Result [Content i] Line
show_Line :: Line -> [Content ()]
type Clef_Octave_Change = PCDATA
read_Clef_Octave_Change :: StateT Result [Content i] Clef_Octave_Change
show_Clef_Octave_Change :: Clef_Octave_Change -> [Content ()]
type Staff_Details = ((Maybe CDATA, Maybe Staff_Details_, Print_Object, Print_Spacing), (Maybe Staff_Type, Maybe Staff_Lines, [Staff_Tuning], Maybe Capo, Maybe Staff_Size))
read_Staff_Details :: (Eq i) => StateT Result [Content i] Staff_Details
show_Staff_Details :: Staff_Details -> [Content ()]
data Staff_Details_
Staff_Details_1 :: Staff_Details_
Staff_Details_2 :: Staff_Details_
read_Staff_Details_ :: String -> Result Staff_Details_
show_Staff_Details_ :: Staff_Details_ -> String
type Staff_Type = PCDATA
read_Staff_Type :: StateT Result [Content i] Staff_Type
show_Staff_Type :: Staff_Type -> [Content ()]
type Staff_Lines = PCDATA
read_Staff_Lines :: StateT Result [Content i] Staff_Lines
show_Staff_Lines :: Staff_Lines -> [Content ()]
type Staff_Tuning = (CDATA, (Tuning_Step, Maybe Tuning_Alter, Tuning_Octave))
read_Staff_Tuning :: (Eq i) => StateT Result [Content i] Staff_Tuning
show_Staff_Tuning :: Staff_Tuning -> [Content ()]
type Capo = PCDATA
read_Capo :: StateT Result [Content i] Capo
show_Capo :: Capo -> [Content ()]
type Staff_Size = PCDATA
read_Staff_Size :: StateT Result [Content i] Staff_Size
show_Staff_Size :: Staff_Size -> [Content ()]
type Transpose = (Maybe Diatonic, Chromatic, Maybe Octave_Change, Maybe Double)
read_Transpose :: (Eq i) => StateT Result [Content i] Transpose
show_Transpose :: Transpose -> [Content ()]
type Diatonic = PCDATA
read_Diatonic :: StateT Result [Content i] Diatonic
show_Diatonic :: Diatonic -> [Content ()]
type Chromatic = PCDATA
read_Chromatic :: StateT Result [Content i] Chromatic
show_Chromatic :: Chromatic -> [Content ()]
type Octave_Change = PCDATA
read_Octave_Change :: StateT Result [Content i] Octave_Change
show_Octave_Change :: Octave_Change -> [Content ()]
type Double = ()
read_Double :: StateT Result [Content i] Double
show_Double :: Double -> [Content ()]
type Directive = ((Print_Style, Maybe CDATA), CDATA)
read_Directive :: StateT Result [Content i] Directive
show_Directive :: Directive -> [Content ()]
type Measure_Style = ((Maybe CDATA, Font, Color), Measure_Style_)
read_Measure_Style :: (Eq i) => StateT Result [Content i] Measure_Style
show_Measure_Style :: Measure_Style -> [Content ()]
data Measure_Style_
Measure_Style_1 :: Multiple_Rest -> Measure_Style_
Measure_Style_2 :: Measure_Repeat -> Measure_Style_
Measure_Style_3 :: Beat_Repeat -> Measure_Style_
Measure_Style_4 :: Slash -> Measure_Style_
read_Measure_Style_ :: (Eq i) => StateT Result [Content i] Measure_Style_
show_Measure_Style_ :: Measure_Style_ -> [Content ()]
type Slash_Type = PCDATA
read_Slash_Type :: StateT Result [Content i] Slash_Type
show_Slash_Type :: Slash_Type -> [Content ()]
type Slash_Dot = ()
read_Slash_Dot :: StateT Result [Content i] Slash_Dot
show_Slash_Dot :: Slash_Dot -> [Content ()]
type Multiple_Rest = (Maybe Yes_No, PCDATA)
read_Multiple_Rest :: StateT Result [Content i] Multiple_Rest
show_Multiple_Rest :: Multiple_Rest -> [Content ()]
type Measure_Repeat = ((Start_Stop, Maybe CDATA), PCDATA)
read_Measure_Repeat :: StateT Result [Content i] Measure_Repeat
show_Measure_Repeat :: Measure_Repeat -> [Content ()]
type Beat_Repeat = ((Start_Stop, Maybe CDATA, Maybe Yes_No), Maybe (Slash_Type, [Slash_Dot]))
read_Beat_Repeat :: (Eq i) => StateT Result [Content i] Beat_Repeat
show_Beat_Repeat :: Beat_Repeat -> [Content ()]
read_Beat_Repeat_aux1 :: (Eq i) => StateT Result [Content i] (Slash_Type, [Slash_Dot])
show_Beat_Repeat_aux1 :: (Slash_Type, [Slash_Dot]) -> [Content ()]
type Slash = ((Start_Stop, Maybe Yes_No, Maybe Yes_No), Maybe (Slash_Type, [Slash_Dot]))
read_Slash :: (Eq i) => StateT Result [Content i] Slash
show_Slash :: Slash -> [Content ()]
read_Slash_aux1 :: (Eq i) => StateT Result [Content i] (Slash_Type, [Slash_Dot])
show_Slash_aux1 :: (Slash_Type, [Slash_Dot]) -> [Content ()]
instance Eq Measure_Style_
instance Show Measure_Style_
instance Eq Staff_Details_
instance Show Staff_Details_
instance Eq Time_B
instance Show Time_B
instance Eq Time_A
instance Show Time_A
instance Eq Key_
instance Show Key_


module Text.XML.MusicXML.Identity
type Identification = ([Creator], [Rights], Maybe Encoding, Maybe Source, [Relation], Maybe Miscellaneous)
read_Identification :: (Eq i) => StateT Result [Content i] Identification
show_Identification :: Identification -> [Content ()]
update_Identification :: ([Software], Encoding_Date) -> Identification -> Identification
type Creator = (Maybe CDATA, PCDATA)
read_Creator :: (Eq i) => StateT Result [Content i] Creator
show_Creator :: Creator -> [Content ()]
type Rights = (Maybe CDATA, CDATA)
read_Rights :: (Eq i) => StateT Result [Content i] Rights
show_Rights :: Rights -> [Content ()]
type Encoding = [Encoding_]
read_Encoding :: (Eq i) => StateT Result [Content i] Encoding
show_Encoding :: Encoding -> [Content ()]
update_Encoding :: ([Software], Encoding_Date) -> Encoding -> Encoding
data Encoding_
Encoding_1 :: Encoding_Date -> Encoding_
Encoding_2 :: Encoder -> Encoding_
Encoding_3 :: Software -> Encoding_
Encoding_4 :: Encoding_Description -> Encoding_
Encoding_5 :: Supports -> Encoding_
read_Encoding_ :: (Eq i) => StateT Result [Content i] Encoding_
show_Encoding_ :: Encoding_ -> [Content ()]
type Encoding_Date = YYYY_MM_DD
read_Encoding_Date :: (Eq i) => StateT Result [Content i] Encoding_Date
show_Encoding_Date :: Encoding_Date -> [Content ()]
type Encoder = (Maybe CDATA, PCDATA)
read_Encoder :: (Eq i) => StateT Result [Content i] Encoder
show_Encoder :: Encoder -> [Content ()]
type Software = PCDATA
read_Software :: (Eq i) => StateT Result [Content i] Software
show_Software :: Software -> [Content ()]
type Encoding_Description = PCDATA
read_Encoding_Description :: StateT Result [Content i] Encoding_Description
show_Encoding_Description :: Encoding_Description -> [Content ()]
type Supports = ((Yes_No, CDATA, Maybe CDATA, Maybe CDATA), ())
read_Supports :: (Eq i) => StateT Result [Content i] Supports
show_Supports :: Supports -> [Content ()]
type Source = PCDATA
read_Source :: StateT Result [Content i] Source
show_Source :: Source -> [Content ()]
type Relation = (Maybe CDATA, CDATA)
read_Relation :: StateT Result [Content i] Relation
show_Relation :: Relation -> [Content ()]
type Miscellaneous = [Miscellaneous_Field]
read_Miscellaneous :: (Eq i) => StateT Result [Content i] Miscellaneous
show_Miscellaneous :: Miscellaneous -> [Content ()]
type Miscellaneous_Field = (CDATA, PCDATA)
read_Miscellaneous_Field :: StateT Result [Content i] Miscellaneous_Field
show_Miscellaneous_Field :: Miscellaneous_Field -> [Content ()]
instance Eq Encoding_
instance Show Encoding_


module Text.XML.MusicXML.Barline
type Barline = ((Barline_, Maybe CDATA, Maybe CDATA, Maybe CDATA), (Maybe Bar_Style, Editorial, Maybe Wavy_Line, Maybe Segno, Maybe Coda, Maybe (Fermata, Maybe Fermata), Maybe Ending, Maybe Repeat))
read_Barline :: (Eq i) => StateT Result [Content i] Barline
show_Barline :: Barline -> [Content ()]
read_Barline_aux1 :: StateT Result [Content i] (Fermata, Maybe Fermata)
show_Barline_aux1 :: (Fermata, Maybe Fermata) -> [Content ()]
data Barline_
Barline_1 :: Barline_
Barline_2 :: Barline_
Barline_3 :: Barline_
read_Barline_ :: String -> Result Barline_
show_Barline_ :: Barline_ -> String
type Bar_Style = (Color, PCDATA)
read_Bar_Style :: StateT Result [Content i] Bar_Style
show_Bar_Style :: Bar_Style -> [Content ()]
type Ending = ((CDATA, Ending_, Print_Object, Print_Style, Maybe Tenths, Maybe Tenths, Maybe Tenths), PCDATA)
read_Ending :: (Eq i) => StateT Result [Content i] Ending
show_Ending :: Ending -> [Content ()]
data Ending_
Ending_1 :: Ending_
Ending_2 :: Ending_
Ending_3 :: Ending_
read_Ending_ :: String -> Result Ending_
show_Ending_ :: Ending_ -> String
type Repeat = ((Repeat_, Maybe CDATA), ())
read_Repeat :: StateT Result [Content i] Repeat
show_Repeat :: Repeat -> [Content ()]
data Repeat_
Repeat_1 :: Repeat_
Repeat_2 :: Repeat_
read_Repeat_ :: String -> Result Repeat_
show_Repeat_ :: Repeat_ -> String
instance Eq Repeat_
instance Show Repeat_
instance Eq Ending_
instance Show Ending_
instance Eq Barline_
instance Show Barline_


module Text.XML.MusicXML.Link
type Link_Attributes = (CDATA, CDATA, CDATA, Maybe CDATA, Maybe CDATA, Link_Attributes_A, Link_Attributes_B)
read_Link_Attributes :: StateT Result [Attribute] Link_Attributes
show_Link_Attributes :: Link_Attributes -> [Attribute]
data Link_Attributes_A
Link_Attributes_1 :: Link_Attributes_A
Link_Attributes_2 :: Link_Attributes_A
Link_Attributes_3 :: Link_Attributes_A
Link_Attributes_4 :: Link_Attributes_A
Link_Attributes_5 :: Link_Attributes_A
read_Link_Attributes_A :: String -> Result Link_Attributes_A
show_Link_Attributes_A :: Link_Attributes_A -> String
data Link_Attributes_B
Link_Attributes_6 :: Link_Attributes_B
Link_Attributes_7 :: Link_Attributes_B
Link_Attributes_8 :: Link_Attributes_B
Link_Attributes_9 :: Link_Attributes_B
read_Link_Attributes_B :: String -> Result Link_Attributes_B
show_Link_Attributes_B :: Link_Attributes_B -> String
type Link = ((Link_Attributes, Maybe CDATA, Maybe CDATA, Maybe CDATA, Position), ())
read_Link :: (Eq i) => StateT Result [Content i] Link
show_Link :: Link -> [Content ()]
type Bookmark = ((ID, Maybe CDATA, Maybe CDATA, Maybe CDATA), ())
read_Bookmark :: (Eq i) => StateT Result [Content i] Bookmark
show_Bookmark :: Bookmark -> [Content ()]
instance Eq Link_Attributes_B
instance Show Link_Attributes_B
instance Eq Link_Attributes_A
instance Show Link_Attributes_A


module Text.XML.MusicXML.Layout
type Scaling = (Millimeters, Tenths)
read_Scaling :: (Eq i) => StateT Result [Content i] Scaling
show_Scaling :: Scaling -> [Content ()]
type Millimeters = PCDATA
read_Millimeters :: (Eq i) => StateT Result [Content i] Millimeters
show_Millimeters :: Millimeters -> [Content ()]
type Tenths = Layout_Tenths
read_Tenths :: (Eq i) => StateT Result [Content i] Tenths
show_Tenths :: Tenths -> [Content ()]
type Left_Margin = Layout_Tenths
read_Left_Margin :: StateT Result [Content i] Left_Margin
show_Left_Margin :: Left_Margin -> [Content ()]
type Right_Margin = Layout_Tenths
read_Right_Margin :: StateT Result [Content i] Right_Margin
show_Right_Margin :: Right_Margin -> [Content ()]
type Top_Margin = Layout_Tenths
read_Top_Margin :: StateT Result [Content i] Top_Margin
show_Top_Margin :: Top_Margin -> [Content ()]
type Bottom_Margin = Layout_Tenths
read_Bottom_Margin :: StateT Result [Content i] Bottom_Margin
show_Bottom_Margin :: Bottom_Margin -> [Content ()]
type Page_Layout = (Maybe (Page_Height, Page_Width), Maybe (Page_Margins, Maybe Page_Margins))
read_Page_Layout :: (Eq i) => StateT Result [Content i] Page_Layout
show_Page_Layout :: Page_Layout -> [Content ()]
read_Page_Layout_aux1 :: (Eq i) => StateT Result [Content i] (Page_Height, Page_Width)
show_Page_Layout_aux1 :: (Page_Height, Page_Width) -> [Content ()]
read_Page_Layout_aux2 :: (Eq i) => StateT Result [Content i] (Page_Margins, Maybe Page_Margins)
show_Page_Layout_aux2 :: (Page_Margins, Maybe Page_Margins) -> [Content ()]
type Page_Height = Layout_Tenths
read_Page_Height :: (Eq i) => StateT Result [Content i] Page_Height
show_Page_Height :: Page_Height -> [Content ()]
type Page_Width = Layout_Tenths
read_Page_Width :: (Eq i) => StateT Result [Content i] Page_Width
show_Page_Width :: Page_Width -> [Content ()]
type Page_Margins = (Maybe Page_Margins_, (Left_Margin, Right_Margin, Top_Margin, Bottom_Margin))
read_Page_Margins :: (Eq i) => StateT Result [Content i] Page_Margins
show_Page_Margins :: Page_Margins -> [Content ()]
data Page_Margins_
Page_Margins_1 :: Page_Margins_
Page_Margins_2 :: Page_Margins_
Page_Margins_3 :: Page_Margins_
read_Page_Margins_ :: String -> Result Page_Margins_
show_Page_Margins_ :: Page_Margins_ -> String
type System_Layout = (Maybe System_Margins, Maybe System_Distance, Maybe Top_System_Distance)
read_System_Layout :: StateT Result [Content i] System_Layout
show_System_Layout :: System_Layout -> [Content ()]
type System_Margins = (Left_Margin, Right_Margin)
read_System_Margins :: StateT Result [Content i] System_Margins
show_System_Margins :: System_Margins -> [Content ()]
type System_Distance = Layout_Tenths
read_System_Distance :: StateT Result [Content i] System_Distance
show_System_Distance :: System_Distance -> [Content ()]
type Top_System_Distance = Layout_Tenths
read_Top_System_Distance :: StateT Result [Content i] Top_System_Distance
show_Top_System_Distance :: Top_System_Distance -> [Content ()]
type Staff_Layout = (Maybe CDATA, Maybe Staff_Distance)
read_Staff_Layout :: StateT Result [Content i] Staff_Layout
show_Staff_Layout :: Staff_Layout -> [Content ()]
type Staff_Distance = Layout_Tenths
read_Staff_Distance :: StateT Result [Content i] Staff_Distance
show_Staff_Distance :: Staff_Distance -> [Content ()]
type Measure_Layout = Maybe Measure_Distance
read_Measure_Layout :: (Eq i) => StateT Result [Content i] Measure_Layout
show_Measure_Layout :: Measure_Layout -> [Content ()]
type Measure_Distance = Layout_Tenths
read_Measure_Distance :: (Eq i) => StateT Result [Content i] Measure_Distance
show_Measure_Distance :: Measure_Distance -> [Content ()]
type Appearance = ([Line_Width], [Note_Size], [Other_Appearance])
read_Appearance :: (Eq i) => StateT Result [Content i] Appearance
show_Appearance :: Appearance -> [Content ()]
type Line_Width = (CDATA, Layout_Tenths)
read_Line_Width :: StateT Result [Content i] Line_Width
show_Line_Width :: Line_Width -> [Content ()]
type Note_Size = (Note_Size_, PCDATA)
read_Note_Size :: StateT Result [Content i] Note_Size
show_Note_Size :: Note_Size -> [Content ()]
data Note_Size_
Note_Size_1 :: Note_Size_
Note_Size_2 :: Note_Size_
Note_Size_3 :: Note_Size_
read_Note_Size_ :: String -> Result Note_Size_
show_Note_Size_ :: Note_Size_ -> String
type Other_Appearance = (CDATA, PCDATA)
read_Other_Appearance :: StateT Result [Content i] Other_Appearance
show_Other_Appearance :: Other_Appearance -> [Content ()]
instance Eq Note_Size_
instance Show Note_Size_
instance Eq Page_Margins_
instance Show Page_Margins_


module Text.XML.MusicXML.Direction
type Direction = ((Placement, Directive), ([Direction_Type], Maybe Offset, Editorial_Voice, Maybe Staff, Maybe Sound))
read_Direction :: (Eq i) => StateT Result [Content i] Direction
show_Direction :: Direction -> [Content ()]
type Direction_Type = Direction_Type_
read_Direction_Type :: (Eq i) => StateT Result [Content i] Direction_Type
show_Direction_Type :: Direction_Type -> [Content ()]
data Direction_Type_
Direction_Type_1 :: [Rehearsal] -> Direction_Type_
Direction_Type_2 :: [Segno] -> Direction_Type_
Direction_Type_3 :: [Words] -> Direction_Type_
Direction_Type_4 :: [Coda] -> Direction_Type_
Direction_Type_5 :: Wedge -> Direction_Type_
Direction_Type_6 :: [Dynamics] -> Direction_Type_
Direction_Type_7 :: Dashes -> Direction_Type_
Direction_Type_8 :: Bracket -> Direction_Type_
Direction_Type_9 :: Pedal -> Direction_Type_
Direction_Type_10 :: Metronome -> Direction_Type_
Direction_Type_11 :: Octave_Shift -> Direction_Type_
Direction_Type_12 :: Harp_Pedals -> Direction_Type_
Direction_Type_13 :: Damp -> Direction_Type_
Direction_Type_14 :: Damp_All -> Direction_Type_
Direction_Type_15 :: Eyeglasses -> Direction_Type_
Direction_Type_16 :: Scordatura -> Direction_Type_
Direction_Type_17 :: Image -> Direction_Type_
Direction_Type_18 :: Accordion_Registration -> Direction_Type_
Direction_Type_19 :: Other_Direction -> Direction_Type_
read_Direction_Type_ :: (Eq i) => StateT Result [Content i] Direction_Type_
show_Direction_Type_ :: Direction_Type_ -> [Content ()]
type Rehearsal = ((Print_Style, Text_Decoration, Maybe CDATA, Text_Direction, Text_Rotation, Maybe Rehearsal_), PCDATA)
read_Rehearsal :: StateT Result [Content i] Rehearsal
show_Rehearsal :: Rehearsal -> [Content ()]
data Rehearsal_
Rehearsal_1 :: Rehearsal_
Rehearsal_2 :: Rehearsal_
Rehearsal_3 :: Rehearsal_
read_Rehearsal_ :: String -> Result Rehearsal_
show_Rehearsal_ :: Rehearsal_ -> String
type Words = (Text_Formatting, PCDATA)
read_Words :: StateT Result [Content i] Words
show_Words :: Words -> [Content ()]
type Wedge = ((Wedge_, Maybe Number_Level, Maybe CDATA, Position, Color), ())
read_Wedge :: StateT Result [Content i] Wedge
show_Wedge :: Wedge -> [Content ()]
data Wedge_
Wedge_1 :: Wedge_
Wedge_2 :: Wedge_
Wedge_3 :: Wedge_
read_Wedge_ :: String -> Result Wedge_
show_Wedge_ :: Wedge_ -> String
type Dashes = ((Start_Stop, Maybe Number_Level, Position, Color), ())
read_Dashes :: StateT Result [Content i] Dashes
show_Dashes :: Dashes -> [Content ()]
type Bracket = ((Start_Stop, Maybe Number_Level, Bracket_, Maybe Tenths, Line_Type, Position, Color), ())
read_Bracket :: StateT Result [Content i] Bracket
show_Bracket :: Bracket -> [Content ()]
data Bracket_
Bracket_1 :: Bracket_
Bracket_2 :: Bracket_
Bracket_3 :: Bracket_
Bracket_4 :: Bracket_
Bracket_5 :: Bracket_
read_Bracket_ :: String -> Result Bracket_
show_Bracket_ :: Bracket_ -> String
type Pedal = ((Pedal_, Maybe Yes_No, Print_Style), ())
read_Pedal :: StateT Result [Content i] Pedal
show_Pedal :: Pedal -> [Content ()]
data Pedal_
Pedal_1 :: Pedal_
Pedal_2 :: Pedal_
Pedal_3 :: Pedal_
read_Pedal_ :: String -> Result Pedal_
show_Pedal_ :: Pedal_ -> String
type Metronome = ((Print_Style, Maybe Yes_No), Metronome_A)
read_Metronome :: (Eq i) => StateT Result [Content i] Metronome
show_Metronome :: Metronome -> [Content ()]
data Metronome_A
Metronome_1 :: (Beat_Unit, [Beat_Unit_Dot], Metronome_B) -> Metronome_A
Metronome_2 :: ([Metronome_Note], Maybe (Metronome_Relation, [Metronome_Note])) -> Metronome_A
read_Metronome_A :: (Eq i) => StateT Result [Content i] Metronome_A
show_Metronome_A :: Metronome_A -> [Content ()]
read_Metronome_A_aux1 :: (Eq i) => StateT Result [Content i] (Beat_Unit, [Beat_Unit_Dot], Metronome_B)
read_Metronome_A_aux2 :: (Eq i) => StateT Result [Content i] ([Metronome_Note], Maybe (Metronome_Relation, [Metronome_Note]))
read_Metronome_A_aux3 :: (Eq i) => StateT Result [Content i] (Metronome_Relation, [Metronome_Note])
show_Metronome_A_aux1 :: (Metronome_Relation, [Metronome_Note]) -> [Content ()]
data Metronome_B
Metronome_3 :: Per_Minute -> Metronome_B
Metronome_4 :: (Beat_Unit, [Beat_Unit_Dot]) -> Metronome_B
read_Metronome_B :: (Eq i) => StateT Result [Content i] Metronome_B
show_Metronome_B :: Metronome_B -> [Content ()]
read_Metronome_B_aux1 :: (Eq i) => StateT Result [Content i] (Beat_Unit, [Beat_Unit_Dot])
type Beat_Unit = PCDATA
read_Beat_Unit :: StateT Result [Content i] Beat_Unit
show_Beat_Unit :: Beat_Unit -> [Content ()]
type Beat_Unit_Dot = ()
read_Beat_Unit_Dot :: StateT Result [Content i] Beat_Unit_Dot
show_Beat_Unit_Dot :: Beat_Unit_Dot -> [Content ()]
type Per_Minute = (Font, PCDATA)
read_Per_Minute :: StateT Result [Content i] Per_Minute
show_Per_Minute :: Per_Minute -> [Content ()]
type Metronome_Note = (Metronome_Type, [Metronome_Dot], [Metronome_Beam], Maybe Metronome_Tuplet)
read_Metronome_Note :: (Eq i) => StateT Result [Content i] Metronome_Note
show_Metronome_Note :: Metronome_Note -> [Content ()]
type Metronome_Relation = PCDATA
read_Metronome_Relation :: StateT Result [Content i] Metronome_Relation
show_Metronome_Relation :: Metronome_Relation -> [Content ()]
type Metronome_Type = PCDATA
read_Metronome_Type :: StateT Result [Content i] Metronome_Type
show_Metronome_Type :: Metronome_Type -> [Content ()]
type Metronome_Dot = ()
read_Metronome_Dot :: StateT Result [Content i] Metronome_Dot
show_Metronome_Dot :: Metronome_Dot -> [Content ()]
type Metronome_Beam = (Beam_Level, PCDATA)
read_Metronome_Beam :: StateT Result [Content i] Metronome_Beam
show_Metronome_Beam :: Metronome_Beam -> [Content ()]
type Metronome_Tuplet = ((Start_Stop, Maybe Yes_No, Maybe Metronome_Tuplet_), (Actual_Notes, Normal_Notes, Maybe (Normal_Type, [Normal_Dot])))
read_Metronome_Tuplet :: (Eq i) => StateT Result [Content i] Metronome_Tuplet
show_Metronome_Tuplet :: Metronome_Tuplet -> [Content ()]
read_Metronome_Tuplet_aux1 :: (Eq i) => StateT Result [Content i] (Normal_Type, [Normal_Dot])
show_Metronome_Tuplet_aux1 :: (Normal_Type, [Normal_Dot]) -> [Content ()]
data Metronome_Tuplet_
Metronome_Tuplet_1 :: Metronome_Tuplet_
Metronome_Tuplet_2 :: Metronome_Tuplet_
Metronome_Tuplet_3 :: Metronome_Tuplet_
read_Metronome_Tuplet_ :: String -> Result Metronome_Tuplet_
show_Metronome_Tuplet_ :: Metronome_Tuplet_ -> String
type Octave_Shift = ((Octave_Shift_, Maybe Number_Level, CDATA, Print_Style), ())
read_Octave_Shift :: StateT Result [Content i] Octave_Shift
show_Octave_Shift :: Octave_Shift -> [Content ()]
data Octave_Shift_
Octave_Shift_1 :: Octave_Shift_
Octave_Shift_2 :: Octave_Shift_
Octave_Shift_3 :: Octave_Shift_
read_Octave_Shift_ :: String -> Result Octave_Shift_
show_Octave_Shift_ :: Octave_Shift_ -> String
type Harp_Pedals = (Print_Style, [Pedal_Tuning])
read_Harp_Pedals :: (Eq i) => StateT Result [Content i] Harp_Pedals
show_Harp_Pedals :: Harp_Pedals -> [Content ()]
type Pedal_Tuning = (Pedal_Step, Pedal_Alter)
read_Pedal_Tuning :: StateT Result [Content i] Pedal_Tuning
show_Pedal_Tuning :: Pedal_Tuning -> [Content ()]
type Pedal_Step = PCDATA
read_Pedal_Step :: StateT Result [Content i] Pedal_Step
show_Pedal_Step :: Pedal_Step -> [Content ()]
type Pedal_Alter = PCDATA
read_Pedal_Alter :: StateT Result [Content i] Pedal_Alter
show_Pedal_Alter :: Pedal_Alter -> [Content ()]
type Damp = (Print_Style, ())
read_Damp :: StateT Result [Content i] Damp
show_Damp :: Damp -> [Content ()]
type Damp_All = (Print_Style, ())
read_Damp_All :: StateT Result [Content i] Damp_All
show_Damp_All :: Damp_All -> [Content ()]
type Eyeglasses = (Print_Style, ())
read_Eyeglasses :: StateT Result [Content i] Eyeglasses
show_Eyeglasses :: Eyeglasses -> [Content ()]
type Scordatura = [Accord]
read_Scordatura :: (Eq i) => StateT Result [Content i] Scordatura
show_Scordatura :: Scordatura -> [Content ()]
type Accord = (CDATA, (Tuning_Step, Maybe Tuning_Alter, Tuning_Octave))
read_Accord :: StateT Result [Content i] Accord
show_Accord :: Accord -> [Content ()]
type Image = ((CDATA, CDATA, Position, Halign, Valign_Image), ())
read_Image :: StateT Result [Content i] Image
show_Image :: Image -> [Content ()]
type Accordion_Registration = (Print_Style, (Maybe Accordion_High, Maybe Accordion_Middle, Maybe Accordion_Low))
read_Accordion_Registration :: StateT Result [Content i] Accordion_Registration
show_Accordion_Registration :: Accordion_Registration -> [Content ()]
type Accordion_High = ()
read_Accordion_High :: StateT Result [Content i] Accordion_High
show_Accordion_High :: Accordion_High -> [Content ()]
type Accordion_Middle = PCDATA
read_Accordion_Middle :: StateT Result [Content i] Accordion_Middle
show_Accordion_Middle :: Accordion_Middle -> [Content ()]
type Accordion_Low = ()
read_Accordion_Low :: StateT Result [Content i] Accordion_Low
show_Accordion_Low :: Accordion_Low -> [Content ()]
type Other_Direction = ((Print_Object, Print_Style), PCDATA)
read_Other_Direction :: StateT Result [Content i] Other_Direction
show_Other_Direction :: Other_Direction -> [Content ()]
type Offset = (Maybe Yes_No, PCDATA)
read_Offset :: StateT Result [Content i] Offset
show_Offset :: Offset -> [Content ()]
type Harmony_Chord = (Harmony_Chord_, Kind, Maybe Inversion, Maybe Bass, [Degree])
read_Harmony_Chord :: (Eq i) => StateT Result [Content i] Harmony_Chord
show_Harmony_Chord :: Harmony_Chord -> [Content ()]
data Harmony_Chord_
Harmony_Chord_1 :: Root -> Harmony_Chord_
Harmony_Chord_2 :: Function -> Harmony_Chord_
read_Harmony_Chord_ :: StateT Result [Content i] Harmony_Chord_
show_Harmony_Chord_ :: Harmony_Chord_ -> [Content ()]
type Harmony = ((Maybe Harmony_, Print_Object, Maybe Yes_No, Print_Style, Placement), ([Harmony_Chord], Maybe Frame, Maybe Offset, Editorial, Maybe Staff))
read_Harmony :: (Eq i) => StateT Result [Content i] Harmony
show_Harmony :: Harmony -> [Content ()]
data Harmony_
Harmony_1 :: Harmony_
Harmony_2 :: Harmony_
Harmony_3 :: Harmony_
read_Harmony_ :: String -> Result Harmony_
show_Harmony_ :: Harmony_ -> String
type Root = (Root_Step, Maybe Root_Alter)
read_Root :: StateT Result [Content i] Root
show_Root :: Root -> [Content ()]
type Root_Step = ((Maybe CDATA, Print_Style), PCDATA)
read_Root_Step :: StateT Result [Content i] Root_Step
show_Root_Step :: Root_Step -> [Content ()]
type Root_Alter = ((Print_Object, Print_Style, Maybe Left_Right), PCDATA)
read_Root_Alter :: StateT Result [Content i] Root_Alter
show_Root_Alter :: Root_Alter -> [Content ()]
type Function = (Print_Style, PCDATA)
read_Function :: StateT Result [Content i] Function
show_Function :: Function -> [Content ()]
type Kind = ((Maybe Yes_No, Maybe CDATA, Maybe Yes_No, Maybe Yes_No, Maybe Yes_No, Print_Style, Halign, Valign), PCDATA)
read_Kind :: StateT Result [Content i] Kind
show_Kind :: Kind -> [Content ()]
type Inversion = (Print_Style, PCDATA)
read_Inversion :: StateT Result [Content i] Inversion
show_Inversion :: Inversion -> [Content ()]
type Bass = (Bass_Step, Maybe Bass_Alter)
read_Bass :: StateT Result [Content i] Bass
show_Bass :: Bass -> [Content ()]
type Bass_Step = ((Maybe CDATA, Print_Style), PCDATA)
read_Bass_Step :: StateT Result [Content i] Bass_Step
show_Bass_Step :: Bass_Step -> [Content ()]
type Bass_Alter = ((Print_Object, Print_Style, Maybe Bass_Alter_), PCDATA)
read_Bass_Alter :: StateT Result [Content i] Bass_Alter
show_Bass_Alter :: Bass_Alter -> [Content ()]

-- | This is equivalent to left-right entity
data Bass_Alter_
Bass_Alter_1 :: Bass_Alter_
Bass_Alter_2 :: Bass_Alter_
read_Bass_Alter_ :: String -> Result Bass_Alter_
show_Bass_Alter_ :: Bass_Alter_ -> String
type Degree = (Print_Object, (Degree_Value, Degree_Alter, Degree_Type))
read_Degree :: StateT Result [Content i] Degree
show_Degree :: Degree -> [Content ()]
type Degree_Value = ((Maybe CDATA, Print_Style), PCDATA)
read_Degree_Value :: StateT Result [Content i] Degree_Value
show_Degree_Value :: Degree_Value -> [Content ()]
type Degree_Alter = ((Print_Style, Maybe Yes_No), PCDATA)
read_Degree_Alter :: StateT Result [Content i] Degree_Alter
show_Degree_Alter :: Degree_Alter -> [Content ()]
type Degree_Type = ((Maybe CDATA, Print_Style), PCDATA)
read_Degree_Type :: StateT Result [Content i] Degree_Type
show_Degree_Type :: Degree_Type -> [Content ()]
type Frame = ((Position, Color, Halign, Valign, Maybe Tenths, Maybe Tenths), (Frame_Strings, Frame_Frets, Maybe First_Fret, [Frame_Note]))
read_Frame :: (Eq i) => StateT Result [Content i] Frame
show_Frame :: Frame -> [Content ()]
type Frame_Strings = PCDATA
read_Frame_Strings :: StateT Result [Content i] Frame_Strings
show_Frame_Strings :: Frame_Strings -> [Content ()]
type Frame_Frets = PCDATA
read_Frame_Frets :: StateT Result [Content i] Frame_Frets
show_Frame_Frets :: Frame_Frets -> [Content ()]
type First_Fret = ((Maybe CDATA, Maybe Left_Right), PCDATA)
read_First_Fret :: StateT Result [Content i] First_Fret
show_First_Fret :: First_Fret -> [Content ()]
type Frame_Note = (String, Fret, Maybe Fingering, Maybe Barre)
read_Frame_Note :: StateT Result [Content i] Frame_Note
show_Frame_Note :: Frame_Note -> [Content ()]
type Barre = ((Start_Stop, Color), ())
read_Barre :: StateT Result [Content i] Barre
show_Barre :: Barre -> [Content ()]
type Grouping = ((Start_Stop_Single, CDATA, Maybe CDATA), [Feature])
read_Grouping :: (Eq i) => StateT Result [Content i] Grouping
show_Grouping :: Grouping -> [Content ()]
type Feature = (Maybe CDATA, PCDATA)
read_Feature :: StateT Result [Content i] Feature
show_Feature :: Feature -> [Content ()]
type Print = ((Maybe Tenths, Maybe Yes_No, Maybe Yes_No, Maybe CDATA, Maybe CDATA), (Maybe Page_Layout, Maybe System_Layout, [Staff_Layout], Maybe Measure_Layout, Maybe Measure_Numbering, Maybe Part_Name_Display, Maybe Part_Abbreviation_Display))
read_Print :: (Eq i) => StateT Result [Content i] Print
show_Print :: Print -> [Content ()]
type Measure_Numbering = (Print_Style, PCDATA)
read_Measure_Numbering :: (Eq i) => StateT Result [Content i] Measure_Numbering
show_Measure_Numbering :: Measure_Numbering -> [Content ()]
type Sound = ((Maybe CDATA, Maybe CDATA, Maybe Yes_No, Maybe CDATA, Maybe CDATA, Maybe CDATA, Maybe CDATA, Maybe CDATA, Maybe Yes_No, Maybe CDATA, Maybe CDATA, Maybe Yes_No, Maybe CDATA, Maybe CDATA, Maybe Yes_No_Number, Maybe Yes_No_Number, Maybe Yes_No_Number), ([Midi_Instrument], Maybe Offset))
read_Sound :: (Eq i) => StateT Result [Content i] Sound
show_Sound :: Sound -> [Content ()]
instance Eq Bass_Alter_
instance Show Bass_Alter_
instance Eq Harmony_
instance Show Harmony_
instance Eq Harmony_Chord_
instance Show Harmony_Chord_
instance Eq Octave_Shift_
instance Show Octave_Shift_
instance Eq Metronome_Tuplet_
instance Show Metronome_Tuplet_
instance Eq Metronome_B
instance Show Metronome_B
instance Eq Metronome_A
instance Show Metronome_A
instance Eq Pedal_
instance Show Pedal_
instance Eq Bracket_
instance Show Bracket_
instance Eq Wedge_
instance Show Wedge_
instance Eq Rehearsal_
instance Show Rehearsal_
instance Eq Direction_Type_
instance Show Direction_Type_


module Text.XML.MusicXML.Note
type Full_Note = (Maybe Chord, Full_Note_)
read_Full_Note :: StateT Result [Content i] Full_Note
show_Full_Note :: Full_Note -> [Content ()]
data Full_Note_
Full_Note_1 :: Pitch -> Full_Note_
Full_Note_2 :: Unpitched -> Full_Note_
Full_Note_3 :: Rest -> Full_Note_
read_Full_Note_ :: StateT Result [Content i] Full_Note_
show_Full_Note_ :: Full_Note_ -> [Content ()]
type Note = ((Print_Style, Printout, Maybe CDATA, Maybe CDATA, Maybe CDATA, Maybe CDATA, Maybe CDATA, Maybe Yes_No), (Note_, Maybe Instrument, Editorial_Voice, Maybe Type, [Dot], Maybe Accidental, Maybe Time_Modification, Maybe Stem, Maybe Notehead, Maybe Staff, [Beam], [Notations], [Lyric]))
read_Note :: (Eq i) => StateT Result [Content i] Note
show_Note :: Note -> [Content ()]
data Note_
Note_1 :: (Grace, Full_Note, Maybe (Tie, Maybe Tie)) -> Note_
Note_2 :: (Cue, Full_Note, Duration) -> Note_
Note_3 :: (Full_Note, Duration, Maybe (Tie, Maybe Tie)) -> Note_
read_Note_ :: StateT Result [Content i] Note_
read_Note_aux1 :: StateT Result [Content i] (Grace, Full_Note, Maybe (Tie, Maybe Tie))
read_Note_aux2 :: StateT Result [Content i] (Cue, Full_Note, Duration)
read_Note_aux3 :: StateT Result [Content i] (Full_Note, Duration, Maybe (Tie, Maybe Tie))
read_Note_aux4 :: StateT Result [Content i] (Tie, Maybe Tie)
show_Note_ :: Note_ -> [Content ()]
show_Note_aux1 :: (Tie, Maybe Tie) -> [Content ()]
type Pitch = (Step, Maybe Alter, Octave)
read_Pitch :: StateT Result [Content i] Pitch
show_Pitch :: Pitch -> [Content ()]
type Step = PCDATA
read_Step :: StateT Result [Content i] Step
show_Step :: Step -> [Content ()]
type Alter = PCDATA
read_Alter :: StateT Result [Content i] Alter
show_Alter :: Alter -> [Content ()]
type Octave = PCDATA
read_Octave :: StateT Result [Content i] Octave
show_Octave :: Octave -> [Content ()]
type Cue = ()
read_Cue :: StateT Result [Content i] Cue
show_Cue :: Cue -> [Content ()]
type Grace = ((Maybe CDATA, Maybe CDATA, Maybe CDATA, Maybe Yes_No), ())
read_Grace :: StateT Result [Content i] Grace
show_Grace :: Grace -> [Content ()]
type Chord = ()
read_Chord :: StateT Result [Content i] Chord
show_Chord :: Chord -> [Content ()]
type Unpitched = Maybe (Display_Step, Display_Octave)
read_Unpitched :: StateT Result [Content i] Unpitched
read_Unpitched_aux1 :: StateT Result [Content i] (Display_Step, Display_Octave)
show_Unpitched :: Unpitched -> [Content ()]
type Display_Step = PCDATA
read_Display_Step :: StateT Result [Content i] Display_Step
show_Display_Step :: Display_Step -> [Content ()]
type Display_Octave = PCDATA
read_Display_Octave :: StateT Result [Content i] Display_Octave
show_Display_Octave :: Display_Octave -> [Content ()]
type Rest = Maybe (Display_Step, Display_Octave)
read_Rest :: StateT Result [Content i] Rest
read_Rest_aux1 :: StateT Result [Content i] (Display_Step, Display_Octave)
show_Rest :: Rest -> [Content ()]
type Duration = PCDATA
read_Duration :: StateT Result [Content i] Duration
show_Duration :: Duration -> [Content ()]
type Tie = (Start_Stop, ())
read_Tie :: StateT Result [Content i] Tie
show_Tie :: Tie -> [Content ()]
type Instrument = (ID, ())
read_Instrument :: StateT Result [Content i] Instrument
show_Instrument :: Instrument -> [Content ()]
type Type = (Maybe Symbol_Size, PCDATA)
read_Type :: StateT Result [Content i] Type
show_Type :: Type -> [Content ()]
type Dot = ((Print_Style, Placement), ())
read_Dot :: StateT Result [Content i] Dot
show_Dot :: Dot -> [Content ()]
type Accidental = ((Maybe Yes_No, Maybe Yes_No, Level_Display, Print_Style), PCDATA)
read_Accidental :: StateT Result [Content i] Accidental
show_Accidental :: Accidental -> [Content ()]
type Time_Modification = (Actual_Notes, Normal_Notes, Maybe (Normal_Type, [Normal_Dot]))
read_Time_Modification :: (Eq i) => StateT Result [Content i] Time_Modification
read_Time_Modification_aux1 :: (Eq i) => StateT Result [Content i] (Normal_Type, [Normal_Dot])
show_Time_Modification :: Time_Modification -> [Content ()]
type Stem = ((Position, Color), PCDATA)
read_Stem :: StateT Result [Content i] Stem
show_Stem :: Stem -> [Content ()]
type Notehead = ((Maybe Yes_No, Maybe Yes_No, Font, Color), PCDATA)
read_Notehead :: StateT Result [Content i] Notehead
show_Notehead :: Notehead -> [Content ()]
type Beam = ((Beam_Level, Maybe Yes_No, Maybe Beam_, Color), PCDATA)
read_Beam :: StateT Result [Content i] Beam
show_Beam :: Beam -> [Content ()]
data Beam_
Beam_Accel :: Beam_
Beam_Rit :: Beam_
Beam_None :: Beam_
read_Beam_ :: String -> Result Beam_
show_Beam_ :: Beam_ -> String
type Notations = (Editorial, [Notations_])
read_Notations :: (Eq i) => StateT Result [Content i] Notations
show_Notations :: Notations -> [Content ()]
data Notations_
Notations_1 :: Tied -> Notations_
Notations_2 :: Slur -> Notations_
Notations_3 :: Tuplet -> Notations_
Notations_4 :: Glissando -> Notations_
Notations_5 :: Slide -> Notations_
Notations_6 :: Ornaments -> Notations_
Notations_7 :: Technical -> Notations_
Notations_8 :: Articulations -> Notations_
Notations_9 :: Dynamics -> Notations_
Notations_10 :: Fermata -> Notations_
Notations_11 :: Arpeggiate -> Notations_
Notations_12 :: Non_Arpeggiate -> Notations_
Notations_13 :: Accidental_Mark -> Notations_
Notations_14 :: Other_Notation -> Notations_
read_Notations_ :: (Eq i) => StateT Result [Content i] Notations_
show_Notations_ :: Notations_ -> [Content ()]
type Tied = ((Start_Stop, Maybe Number_Level, Line_Type, Position, Placement, Orientation, Bezier, Color), ())
read_Tied :: StateT Result [Content i] Tied
show_Tied :: Tied -> [Content ()]
type Slur = ((Start_Stop_Continue, Number_Level, Line_Type, Position, Placement, Orientation, Bezier, Color), ())
read_Slur :: StateT Result [Content i] Slur
show_Slur :: Slur -> [Content ()]
type Tuplet = ((Start_Stop, Maybe Number_Level, Maybe Yes_No, Maybe Tuplet_, Maybe Tuplet_, Line_Shape, Position, Placement), (Maybe Tuplet_Actual, Maybe Tuplet_Normal))
read_Tuplet :: (Eq i) => StateT Result [Content i] Tuplet
show_Tuplet :: Tuplet -> [Content ()]
data Tuplet_
Tuplet_1 :: Tuplet_
Tuplet_2 :: Tuplet_
Tuplet_3 :: Tuplet_
read_Tuplet_ :: String -> Result Tuplet_
show_Tuplet_ :: Tuplet_ -> String
type Tuplet_Actual = (Maybe Tuplet_Number, Maybe Tuplet_Type, [Tuplet_Dot])
read_Tuplet_Actual :: (Eq i) => StateT Result [Content i] Tuplet_Actual
show_Tuplet_Actual :: Tuplet_Actual -> [Content ()]
type Tuplet_Normal = (Maybe Tuplet_Number, Maybe Tuplet_Type, [Tuplet_Dot])
read_Tuplet_Normal :: (Eq i) => StateT Result [Content i] Tuplet_Normal
show_Tuplet_Normal :: Tuplet_Normal -> [Content ()]
type Tuplet_Number = ((Font, Color), PCDATA)
read_Tuplet_Number :: StateT Result [Content i] Tuplet_Number
show_Tuplet_Number :: Tuplet_Number -> [Content ()]
type Tuplet_Type = ((Font, Color), PCDATA)
read_Tuplet_Type :: StateT Result [Content i] Tuplet_Type
show_Tuplet_Type :: Tuplet_Type -> [Content ()]
type Tuplet_Dot = ((Font, Color), ())
read_Tuplet_Dot :: StateT Result [Content i] Tuplet_Dot
show_Tuplet_Dot :: Tuplet_Dot -> [Content ()]
type Glissando = ((Start_Stop, Number_Level, Line_Type, Print_Style), PCDATA)
read_Glissando :: StateT Result [Content i] Glissando
show_Glissando :: Glissando -> [Content ()]
type Slide = ((Start_Stop, Number_Level, Line_Type, Print_Style, Bend_Sound), PCDATA)
read_Slide :: StateT Result [Content i] Slide
show_Slide :: Slide -> [Content ()]
type Other_Notation = ((Start_Stop_Single, Number_Level, Print_Object, Print_Style, Placement), PCDATA)
read_Other_Notation :: StateT Result [Content i] Other_Notation
show_Other_Notation :: Other_Notation -> [Content ()]
type Ornaments = [(Ornaments_, [Accidental_Mark])]
read_Ornaments :: (Eq i) => StateT Result [Content i] Ornaments
read_Ornaments_aux1 :: (Eq i) => StateT Result [Content i] (Ornaments_, [Accidental_Mark])
show_Ornaments :: Ornaments -> [Content ()]
show_Ornaments_aux1 :: (Ornaments_, [Accidental_Mark]) -> [Content ()]
data Ornaments_
Ornaments_1 :: Trill_Mark -> Ornaments_
Ornaments_2 :: Turn -> Ornaments_
Ornaments_3 :: Delayed_Turn -> Ornaments_
Ornaments_4 :: Inverted_Turn -> Ornaments_
Ornaments_5 :: Shake -> Ornaments_
Ornaments_6 :: Wavy_Line -> Ornaments_
Ornaments_7 :: Mordent -> Ornaments_
Ornaments_8 :: Inverted_Mordent -> Ornaments_
Ornaments_9 :: Schleifer -> Ornaments_
Ornaments_10 :: Tremolo -> Ornaments_
Ornaments_11 :: Other_Ornament -> Ornaments_
read_Ornaments_ :: StateT Result [Content i] Ornaments_
show_Ornaments_ :: Ornaments_ -> [Content ()]
type Trill_Mark = ((Print_Style, Placement, Trill_Sound), ())
read_Trill_Mark :: StateT Result [Content i] Trill_Mark
show_Trill_Mark :: Trill_Mark -> [Content ()]
type Turn = ((Print_Style, Placement, Trill_Sound), ())
read_Turn :: StateT Result [Content i] Turn
show_Turn :: Turn -> [Content ()]
type Delayed_Turn = ((Print_Style, Placement, Trill_Sound), ())
read_Delayed_Turn :: StateT Result [Content i] Delayed_Turn
show_Delayed_Turn :: Delayed_Turn -> [Content ()]
type Inverted_Turn = ((Print_Style, Placement, Trill_Sound), ())
read_Inverted_Turn :: StateT Result [Content i] Inverted_Turn
show_Inverted_Turn :: Inverted_Turn -> [Content ()]
type Shake = ((Print_Style, Placement, Trill_Sound), ())
read_Shake :: StateT Result [Content i] Shake
show_Shake :: Shake -> [Content ()]
type Mordent = ((Maybe Yes_No, Print_Style, Placement, Trill_Sound), ())
read_Mordent :: StateT Result [Content i] Mordent
show_Mordent :: Mordent -> [Content ()]
type Inverted_Mordent = ((Maybe Yes_No, Print_Style, Placement, Trill_Sound), ())
read_Inverted_Mordent :: StateT Result [Content i] Inverted_Mordent
show_Inverted_Mordent :: Inverted_Mordent -> [Content ()]
type Schleifer = ((Print_Style, Placement), ())
read_Schleifer :: StateT Result [Content i] Schleifer
show_Schleifer :: Schleifer -> [Content ()]
type Tremolo = ((Start_Stop_Single, Print_Style, Placement), PCDATA)
read_Tremolo :: StateT Result [Content i] Tremolo
show_Tremolo :: Tremolo -> [Content ()]
type Other_Ornament = ((Print_Style, Placement), PCDATA)
read_Other_Ornament :: StateT Result [Content i] Other_Ornament
show_Other_Ornament :: Other_Ornament -> [Content ()]
type Accidental_Mark = ((Print_Style, Placement), CDATA)
read_Accidental_Mark :: StateT Result [Content i] Accidental_Mark
show_Accidental_Mark :: Accidental_Mark -> [Content ()]
type Technical = [Technical_]
read_Technical :: (Eq i) => StateT Result [Content i] Technical
show_Technical :: Technical -> [Content ()]
data Technical_
Technical_1 :: Up_Bow -> Technical_
Technical_2 :: Down_Bow -> Technical_
Technical_3 :: Harmonic -> Technical_
Technical_4 :: Open_String -> Technical_
Technical_5 :: Thumb_Position -> Technical_
Technical_6 :: Fingering -> Technical_
Technical_7 :: Pluck -> Technical_
Technical_8 :: Double_Tongue -> Technical_
Technical_9 :: Triple_Tongue -> Technical_
Technical_10 :: Stopped -> Technical_
Technical_11 :: Snap_Pizzicato -> Technical_
Technical_12 :: Fret -> Technical_
Technical_13 :: String -> Technical_
Technical_14 :: Hammer_On -> Technical_
Technical_15 :: Pull_Off -> Technical_
Technical_16 :: Bend -> Technical_
Technical_17 :: Tap -> Technical_
Technical_18 :: Heel -> Technical_
Technical_19 :: Toe -> Technical_
Technical_20 :: Fingernails -> Technical_
Technical_21 :: Other_Technical -> Technical_
read_Technical_ :: StateT Result [Content i] Technical_
show_Technical_ :: Technical_ -> [Content ()]
type Up_Bow = ((Print_Style, Placement), ())
read_Up_Bow :: StateT Result [Content i] Up_Bow
show_Up_Bow :: Up_Bow -> [Content ()]
type Down_Bow = ((Print_Style, Placement), ())
read_Down_Bow :: StateT Result [Content i] Down_Bow
show_Down_Bow :: Down_Bow -> [Content ()]
type Harmonic = ((Print_Object, Print_Style, Placement), (Maybe Harmonic_A, Maybe Harmonic_B))
read_Harmonic :: StateT Result [Content i] Harmonic
show_Harmonic :: Harmonic -> [Content ()]
data Harmonic_A
Harmonic_1 :: Natural -> Harmonic_A
Harmonic_2 :: Artificial -> Harmonic_A
read_Harmonic_A :: StateT Result [Content i] Harmonic_A
show_Harmonic_A :: Harmonic_A -> [Content ()]
data Harmonic_B
Harmonic_3 :: Base_Pitch -> Harmonic_B
Harmonic_4 :: Touching_Pitch -> Harmonic_B
Harmonic_5 :: Sounding_Pitch -> Harmonic_B
read_Harmonic_B :: StateT Result [Content i] Harmonic_B
show_Harmonic_B :: Harmonic_B -> [Content ()]
type Natural = ()
read_Natural :: StateT Result [Content i] Natural
show_Natural :: Natural -> [Content ()]
type Artificial = ()
read_Artificial :: StateT Result [Content i] Artificial
show_Artificial :: Artificial -> [Content ()]
type Base_Pitch = ()
read_Base_Pitch :: StateT Result [Content i] Base_Pitch
show_Base_Pitch :: Base_Pitch -> [Content ()]
type Touching_Pitch = ()
read_Touching_Pitch :: StateT Result [Content i] Touching_Pitch
show_Touching_Pitch :: Touching_Pitch -> [Content ()]
type Sounding_Pitch = ()
read_Sounding_Pitch :: StateT Result [Content i] Sounding_Pitch
show_Sounding_Pitch :: Sounding_Pitch -> [Content ()]
type Open_String = ((Print_Style, Placement), ())
read_Open_String :: StateT Result [Content i] Open_String
show_Open_String :: Open_String -> [Content ()]
type Thumb_Position = ((Print_Style, Placement), ())
read_Thumb_Position :: StateT Result [Content i] Thumb_Position
show_Thumb_Position :: Thumb_Position -> [Content ()]
type Pluck = ((Print_Style, Placement), PCDATA)
read_Pluck :: StateT Result [Content i] Pluck
show_Pluck :: Pluck -> [Content ()]
type Double_Tongue = ((Print_Style, Placement), ())
read_Double_Tongue :: StateT Result [Content i] Double_Tongue
show_Double_Tongue :: Double_Tongue -> [Content ()]
type Triple_Tongue = ((Print_Style, Placement), ())
read_Triple_Tongue :: StateT Result [Content i] Triple_Tongue
show_Triple_Tongue :: Triple_Tongue -> [Content ()]
type Stopped = ((Print_Style, Placement), ())
read_Stopped :: StateT Result [Content i] Stopped
show_Stopped :: Stopped -> [Content ()]
type Snap_Pizzicato = ((Print_Style, Placement), ())
read_Snap_Pizzicato :: StateT Result [Content i] Snap_Pizzicato
show_Snap_Pizzicato :: Snap_Pizzicato -> [Content ()]
type Hammer_On = ((Start_Stop, Number_Level, Print_Style, Placement), PCDATA)
read_Hammer_On :: StateT Result [Content i] Hammer_On
show_Hammer_On :: Hammer_On -> [Content ()]
type Pull_Off = ((Start_Stop, Number_Level, Print_Style, Placement), PCDATA)
read_Pull_Off :: StateT Result [Content i] Pull_Off
show_Pull_Off :: Pull_Off -> [Content ()]
type Bend = ((Print_Style, Bend_Sound), (Bend_Alter, Maybe Bend_, Maybe With_Bar))
read_Bend :: StateT Result [Content i] Bend
show_Bend :: Bend -> [Content ()]
data Bend_
Bend_1 :: Pre_Bend -> Bend_
Bend_2 :: Release -> Bend_
read_Bend_ :: StateT Result [Content i] Bend_
show_Bend_ :: Bend_ -> [Content ()]
type Bend_Alter = PCDATA
read_Bend_Alter :: StateT Result [Content i] Bend_Alter
show_Bend_Alter :: Bend_Alter -> [Content ()]
type Pre_Bend = ()
read_Pre_Bend :: StateT Result [Content i] Pre_Bend
show_Pre_Bend :: Pre_Bend -> [Content ()]
type Release = ()
read_Release :: StateT Result [Content i] Release
show_Release :: Release -> [Content ()]
type With_Bar = ((Print_Style, Placement), CDATA)
read_With_Bar :: StateT Result [Content i] With_Bar
show_With_Bar :: With_Bar -> [Content ()]
type Tap = ((Print_Style, Placement), CDATA)
read_Tap :: StateT Result [Content i] Tap
show_Tap :: Tap -> [Content ()]
type Heel = ((Maybe Yes_No, Print_Style, Placement), ())
read_Heel :: StateT Result [Content i] Heel
show_Heel :: Heel -> [Content ()]
type Toe = ((Maybe Yes_No, Print_Style, Placement), ())
read_Toe :: StateT Result [Content i] Toe
show_Toe :: Toe -> [Content ()]
type Fingernails = ((Print_Style, Placement), ())
read_Fingernails :: StateT Result [Content i] Fingernails
show_Fingernails :: Fingernails -> [Content ()]
type Other_Technical = ((Print_Style, Placement), CDATA)
read_Other_Technical :: StateT Result [Content i] Other_Technical
show_Other_Technical :: Other_Technical -> [Content ()]
type Articulations = [Articulations_]
read_Articulations :: (Eq i) => StateT Result [Content i] Articulations
show_Articulations :: Articulations -> [Content ()]
data Articulations_
Articulations_1 :: Accent -> Articulations_
Articulations_2 :: Strong_Accent -> Articulations_
Articulations_3 :: Staccato -> Articulations_
Articulations_4 :: Tenuto -> Articulations_
Articulations_5 :: Detached_Legato -> Articulations_
Articulations_6 :: Staccatissimo -> Articulations_
Articulations_7 :: Spiccato -> Articulations_
Articulations_8 :: Scoop -> Articulations_
Articulations_9 :: Plop -> Articulations_
Articulations_10 :: Doit -> Articulations_
Articulations_11 :: Falloff -> Articulations_
Articulations_12 :: Breath_Mark -> Articulations_
Articulations_13 :: Caesura -> Articulations_
Articulations_14 :: Stress -> Articulations_
Articulations_15 :: Unstress -> Articulations_
Articulations_16 :: Other_Articulation -> Articulations_
read_Articulations_ :: StateT Result [Content i] Articulations_
show_Articulations_ :: Articulations_ -> [Content ()]
type Accent = ((Print_Style, Placement), ())
read_Accent :: StateT Result [Content i] Accent
show_Accent :: Accent -> [Content ()]
type Strong_Accent = ((Print_Style, Placement, Up_Down), ())
read_Strong_Accent :: StateT Result [Content i] Strong_Accent
show_Strong_Accent :: Strong_Accent -> [Content ()]
type Staccato = ((Print_Style, Placement), ())
read_Staccato :: StateT Result [Content i] Staccato
show_Staccato :: Staccato -> [Content ()]
type Tenuto = ((Print_Style, Placement), ())
read_Tenuto :: StateT Result [Content i] Tenuto
show_Tenuto :: Tenuto -> [Content ()]
type Detached_Legato = ((Print_Style, Placement), ())
read_Detached_Legato :: StateT Result [Content i] Detached_Legato
show_Detached_Legato :: Detached_Legato -> [Content ()]
type Staccatissimo = ((Print_Style, Placement), ())
read_Staccatissimo :: StateT Result [Content i] Staccato
show_Staccatissimo :: Staccatissimo -> [Content ()]
type Spiccato = ((Print_Style, Placement), ())
read_Spiccato :: StateT Result [Content i] Spiccato
show_Spiccato :: Spiccato -> [Content ()]
type Scoop = ((Line_Shape, Line_Type, Print_Style, Placement), ())
read_Scoop :: StateT Result [Content i] Scoop
show_Scoop :: Scoop -> [Content ()]
type Plop = ((Line_Shape, Line_Type, Print_Style, Placement), ())
read_Plop :: StateT Result [Content i] Plop
show_Plop :: Plop -> [Content ()]
type Doit = ((Line_Shape, Line_Type, Print_Style, Placement), ())
read_Doit :: StateT Result [Content i] Doit
show_Doit :: Doit -> [Content ()]
type Falloff = ((Line_Shape, Line_Type, Print_Style, Placement), ())
read_Falloff :: StateT Result [Content i] Falloff
show_Falloff :: Falloff -> [Content ()]
type Breath_Mark = ((Print_Style, Placement), ())
read_Breath_Mark :: StateT Result [Content i] Breath_Mark
show_Breath_Mark :: Breath_Mark -> [Content ()]
type Caesura = ((Print_Style, Placement), ())
read_Caesura :: StateT Result [Content i] Caesura
show_Caesura :: Caesura -> [Content ()]
type Stress = ((Print_Style, Placement), ())
read_Stress :: StateT Result [Content i] Stress
show_Stress :: Stress -> [Content ()]
type Unstress = ((Print_Style, Placement), ())
read_Unstress :: StateT Result [Content i] Unstress
show_Unstress :: Staccato -> [Content ()]
type Other_Articulation = ((Print_Style, Placement), ())
read_Other_Articulation :: StateT Result [Content i] Other_Articulation
show_Other_Articulation :: Other_Articulation -> [Content ()]
type Arpeggiate = ((Maybe Number_Level, Maybe Up_Down, Position, Placement, Color), ())
read_Arpeggiate :: StateT Result [Content i] Arpeggiate
show_Arpeggiate :: Arpeggiate -> [Content ()]
type Non_Arpeggiate = ((Top_Bottom, Maybe Number_Level, Position, Placement, Color), ())
read_Non_Arpeggiate :: StateT Result [Content i] Non_Arpeggiate
show_Non_Arpeggiate :: Non_Arpeggiate -> [Content ()]
type Lyric = ((Maybe CDATA, Maybe CDATA, Justify, Position, Placement, Color), (Lyric_, Maybe End_Line, Maybe End_Paragraph, Editorial))
read_Lyric :: (Eq i) => StateT Result [Content i] Lyric
show_Lyric :: Lyric -> [Content ()]
data Lyric_
Lyric_1 :: ((Maybe Syllabic, Text), [(Maybe Elision, Maybe Syllabic, Text)], Maybe Extend) -> Lyric_
Lyric_2 :: Extend -> Lyric_
Lyric_3 :: Laughing -> Lyric_
Lyric_4 :: Humming -> Lyric_
read_Lyric_ :: (Eq i) => StateT Result [Content i] Lyric_
read_Lyric_aux1 :: (Eq i) => StateT Result [Content i] ((Maybe Syllabic, Text), [(Maybe Elision, Maybe Syllabic, Text)], Maybe Extend)
read_Lyric_aux2 :: StateT Result [Content i] (Maybe Elision, Maybe Syllabic, Text)
show_Lyric_ :: Lyric_ -> [Content ()]
show_Lyric_aux1 :: (Maybe Elision, Maybe Syllabic, Text) -> [Content ()]
type Text = ((Font, Color, Text_Decoration, Text_Rotation, Letter_Spacing, Maybe CDATA, Text_Direction), CDATA)
read_Text :: StateT Result [Content i] Text
show_Text :: Text -> [Content ()]
type Syllabic = PCDATA
read_Syllabic :: StateT Result [Content i] Syllabic
show_Syllabic :: Syllabic -> [Content ()]
type Elision = ((Font, Color), CDATA)
read_Elision :: StateT Result [Content i] Elision
show_Elision :: Elision -> [Content ()]
type Extend = ((Font, Color), ())
read_Extend :: StateT Result [Content i] Extend
show_Extend :: Extend -> [Content ()]
type Laughing = ()
read_Laughing :: StateT Result [Content i] Laughing
show_Laughing :: Laughing -> [Content ()]
type Humming = ()
read_Humming :: StateT Result [Content i] Humming
show_Humming :: Humming -> [Content ()]
type End_Line = ()
read_End_Line :: StateT Result [Content i] End_Line
show_End_Line :: End_Line -> [Content ()]
type End_Paragraph = ()
read_End_Paragraph :: StateT Result [Content i] End_Paragraph
show_End_Paragraph :: End_Paragraph -> [Content ()]
type Figured_Bass = ((Print_Style, Printout, Maybe Yes_No), ([Figure], Maybe Duration, Editorial))
read_Figured_Bass :: (Eq i) => StateT Result [Content i] Figured_Bass
show_Figured_Bass :: Figured_Bass -> [Content ()]
type Figure = (Maybe Prefix, Maybe Figure_Number, Maybe Suffix, Maybe Extend)
read_Figure :: StateT Result [Content i] Figure
show_Figure :: Figure -> [Content ()]
type Prefix = (Print_Style, CDATA)
read_Prefix :: StateT Result [Content i] Prefix
show_Prefix :: Prefix -> [Content ()]
type Figure_Number = (Print_Style, PCDATA)
read_Figure_Number :: StateT Result [Content i] Figure_Number
show_Figure_Number :: Figure_Number -> [Content ()]
type Suffix = (Print_Style, PCDATA)
read_Suffix :: StateT Result [Content i] Suffix
show_Suffix :: Suffix -> [Content ()]
type Backup = (Duration, Editorial)
read_Backup :: StateT Result [Content i] Backup
show_Backup :: Backup -> [Content ()]
type Forward = (Duration, Editorial_Voice, Maybe Staff)
read_Forward :: StateT Result [Content i] Forward
show_Forward :: Forward -> [Content ()]
instance Eq Lyric_
instance Show Lyric_
instance Eq Articulations_
instance Show Articulations_
instance Eq Bend_
instance Show Bend_
instance Eq Harmonic_B
instance Show Harmonic_B
instance Eq Harmonic_A
instance Show Harmonic_A
instance Eq Technical_
instance Show Technical_
instance Eq Ornaments_
instance Show Ornaments_
instance Eq Tuplet_
instance Show Tuplet_
instance Eq Notations_
instance Show Notations_
instance Eq Beam_
instance Show Beam_
instance Eq Note_
instance Show Note_
instance Eq Full_Note_
instance Show Full_Note_


module Text.XML.MusicXML.Score
type Work = (Maybe Work_Number, Maybe Work_Title, Maybe Opus)
read_Work :: StateT Result [Content i] Work
show_Work :: Work -> [Content ()]
type Work_Number = PCDATA
read_Work_Number :: StateT Result [Content i] Work_Number
show_Work_Number :: Work_Number -> [Content ()]
type Work_Title = PCDATA
read_Work_Title :: StateT Result [Content i] Work_Title
show_Work_Title :: Work_Title -> [Content ()]
type Opus = (Link_Attributes, ())
read_Opus :: StateT Result [Content i] Opus
show_Opus :: Opus -> [Content ()]
type Movement_Number = PCDATA
read_Movement_Number :: StateT Result [Content i] Movement_Number
show_Movement_Number :: Movement_Number -> [Content ()]
type Movement_Title = PCDATA
read_Movement_Title :: StateT Result [Content i] Movement_Title
show_Movement_Title :: Movement_Title -> [Content ()]
type Defaults = (Maybe Scaling, Maybe Page_Layout, Maybe System_Layout, [Staff_Layout], Maybe Appearance, Maybe Music_Font, Maybe Word_Font, [Lyric_Font], [Lyric_Language])
read_Defaults :: (Eq i) => StateT Result [Content i] Defaults
show_Defaults :: Defaults -> [Content ()]
type Music_Font = (Font, ())
read_Music_Font :: (Eq i) => StateT Result [Content i] Music_Font
show_Music_Font :: Music_Font -> [Content ()]
type Word_Font = (Font, ())
read_Word_Font :: (Eq i) => StateT Result [Content i] Word_Font
show_Word_Font :: Word_Font -> [Content ()]
type Lyric_Font = ((Maybe CDATA, Maybe CDATA, Font), ())
read_Lyric_Font :: (Eq i) => StateT Result [Content i] Lyric_Font
show_Lyric_Font :: Lyric_Font -> [Content ()]
type Lyric_Language = ((Maybe CDATA, Maybe CDATA, CDATA), ())
read_Lyric_Language :: (Eq i) => StateT Result [Content i] Lyric_Language
show_Lyric_Language :: Lyric_Language -> [Content ()]
type Credit = (Maybe CDATA, ([Link], [Bookmark], Credit_))
read_Credit :: (Eq i) => StateT Result [Content i] Credit
show_Credit :: Credit -> [Content ()]
data Credit_
Credit_1 :: Credit_Image -> Credit_
Credit_2 :: (Credit_Words, [([Link], [Bookmark], Credit_Words)]) -> Credit_
read_Credit_ :: (Eq i) => StateT Result [Content i] Credit_
show_Credit_ :: Credit_ -> [Content ()]
read_Credit_aux1 :: (Eq i) => StateT Result [Content i] (Credit_Words, [([Link], [Bookmark], Credit_Words)])
read_Credit_aux2 :: (Eq i) => StateT Result [Content i] ([Link], [Bookmark], Credit_Words)
show_Credit_aux1 :: ([Link], [Bookmark], Credit_Words) -> [Content ()]
type Credit_Words = (Text_Formatting, PCDATA)
read_Credit_Words :: StateT Result [Content i] Credit_Words
show_Credit_Words :: Credit_Words -> [Content ()]
type Credit_Image = ((CDATA, CDATA, Position, Halign, Valign_Image), ())
read_Credit_Image :: StateT Result [Content i] Credit_Image
show_Credit_Image :: Credit_Image -> [Content ()]
type Part_List = ([Part_Group], Score_Part, [Part_List_])
read_Part_List :: (Eq i) => StateT Result [Content i] Part_List
show_Part_List :: Part_List -> [Content ()]
data Part_List_
Part_List_1 :: Part_Group -> Part_List_
Part_List_2 :: Score_Part -> Part_List_
read_Part_List_ :: (Eq i) => StateT Result [Content i] Part_List_
show_Part_List_ :: Part_List_ -> [Content ()]
type Score_Part = (ID, (Maybe Identification, Part_Name, Maybe Part_Name_Display, Maybe Part_Abbreviation, Maybe Part_Abbreviation_Display, [Group], [Score_Instrument], Maybe Midi_Device, [Midi_Instrument]))
read_Score_Part :: (Eq i) => StateT Result [Content i] Score_Part
show_Score_Part :: Score_Part -> [Content ()]
type Part_Name = ((Print_Style, Print_Object, Justify), PCDATA)
read_Part_Name :: StateT Result [Content i] Part_Name
show_Part_Name :: Part_Name -> [Content ()]
type Part_Abbreviation = ((Print_Style, Print_Object, Justify), PCDATA)
read_Part_Abbreviation :: StateT Result [Content i] Part_Abbreviation
show_Part_Abbreviation :: Part_Abbreviation -> [Content ()]
type Part_Group = ((Start_Stop, CDATA), (Maybe Group_Name, Maybe Group_Name_Display, Maybe Group_Abbreviation, Maybe Group_Abbreviation_Display, Maybe Group_Symbol, Maybe Group_Barline, Maybe Group_Time, Editorial))
read_Part_Group :: (Eq i) => StateT Result [Content i] Part_Group
show_Part_Group :: Part_Group -> [Content ()]
type Group_Name = ((Print_Style, Justify), PCDATA)
read_Group_Name :: StateT Result [Content i] Group_Name
show_Group_Name :: Group_Name -> [Content ()]
type Group_Name_Display = (Print_Object, [Group_Name_Display_])
read_Group_Name_Display :: (Eq i) => StateT Result [Content i] Group_Name_Display
show_Group_Name_Display :: Group_Name_Display -> [Content ()]
data Group_Name_Display_
Group_Name_Display_1 :: Display_Text -> Group_Name_Display_
Group_Name_Display_2 :: Accidental_Text -> Group_Name_Display_
read_Group_Name_Display_ :: StateT Result [Content i] Group_Name_Display_
show_Group_Name_Display_ :: Group_Name_Display_ -> [Content ()]
type Group_Abbreviation = ((Print_Style, Justify), PCDATA)
read_Group_Abbreviation :: StateT Result [Content i] Group_Abbreviation
show_Group_Abbreviation :: Group_Abbreviation -> [Content ()]
type Group_Abbreviation_Display = (Print_Object, [Group_Abbreviation_Display_])
read_Group_Abbreviation_Display :: (Eq i) => StateT Result [Content i] Group_Abbreviation_Display
show_Group_Abbreviation_Display :: Group_Abbreviation_Display -> [Content ()]
data Group_Abbreviation_Display_
Group_Abbreviation_Display_1 :: Display_Text -> Group_Abbreviation_Display_
Group_Abbreviation_Display_2 :: Accidental_Text -> Group_Abbreviation_Display_
read_Group_Abbreviation_Display_ :: StateT Result [Content i] Group_Abbreviation_Display_
show_Group_Abbreviation_Display_ :: Group_Abbreviation_Display_ -> [Content ()]
type Group_Symbol = ((Position, Color), PCDATA)
read_Group_Symbol :: StateT Result [Content i] Group_Symbol
show_Group_Symbol :: Group_Symbol -> [Content ()]
type Group_Barline = (Color, PCDATA)
read_Group_Barline :: StateT Result [Content i] Group_Barline
show_Group_Barline :: Group_Barline -> [Content ()]
type Group_Time = ()
read_Group_Time :: StateT Result [Content i] Group_Time
show_Group_Time :: Group_Time -> [Content ()]
type Score_Instrument = (ID, (Instrument_Name, Maybe Instrument_Abbreviation, Maybe Score_Instrument_))
read_Score_Instrument :: StateT Result [Content i] Score_Instrument
show_Score_Instrument :: Score_Instrument -> [Content ()]
data Score_Instrument_
Score_Instrument_1 :: Solo -> Score_Instrument_
Score_Instrument_2 :: Ensemble -> Score_Instrument_
read_Score_Instrument_ :: StateT Result [Content i] Score_Instrument_
show_Score_Instrument_ :: Score_Instrument_ -> [Content ()]
type Instrument_Name = PCDATA
read_Instrument_Name :: StateT Result [Content i] Instrument_Name
show_Instrument_Name :: Instrument_Name -> [Content ()]
type Instrument_Abbreviation = PCDATA
read_Instrument_Abbreviation :: StateT Result [Content i] Instrument_Abbreviation
show_Instrument_Abbreviation :: Instrument_Abbreviation -> [Content ()]
type Solo = ()
read_Solo :: StateT Result [Content i] Solo
show_Solo :: Solo -> [Content ()]
type Ensemble = PCDATA
read_Ensemble :: StateT Result [Content i] Ensemble
show_Ensemble :: Ensemble -> [Content ()]
type Midi_Device = (Maybe CDATA, PCDATA)
read_Midi_Device :: StateT Result [Content i] Midi_Device
show_Midi_Device :: Midi_Device -> [Content ()]
type Group = PCDATA
read_Group :: StateT Result [Content i] Group
show_Group :: Group -> [Content ()]
type Music_Data = [Music_Data_]
read_Music_Data :: (Eq i) => StateT Result [Content i] Music_Data
show_Music_Data :: Music_Data -> [Content ()]
data Music_Data_
Music_Data_1 :: Note -> Music_Data_
Music_Data_2 :: Backup -> Music_Data_
Music_Data_3 :: Forward -> Music_Data_
Music_Data_4 :: Direction -> Music_Data_
Music_Data_5 :: Attributes -> Music_Data_
Music_Data_6 :: Harmony -> Music_Data_
Music_Data_7 :: Figured_Bass -> Music_Data_
Music_Data_8 :: Print -> Music_Data_
Music_Data_9 :: Sound -> Music_Data_
Music_Data_10 :: Barline -> Music_Data_
Music_Data_11 :: Grouping -> Music_Data_
Music_Data_12 :: Link -> Music_Data_
Music_Data_13 :: Bookmark -> Music_Data_
read_Music_Data_ :: (Eq i) => StateT Result [Content i] Music_Data_
show_Music_Data_ :: Music_Data_ -> [Content ()]
type Score_Header = (Maybe Work, Maybe Movement_Number, Maybe Movement_Title, Maybe Identification, Maybe Defaults, [Credit], Part_List)
read_Score_Header :: (Eq i) => StateT Result [Content i] Score_Header
show_Score_Header :: Score_Header -> [Content ()]
update_Score_Header :: ([Software], Encoding_Date) -> Score_Header -> Score_Header
instance Eq Music_Data_
instance Show Music_Data_
instance Eq Score_Instrument_
instance Show Score_Instrument_
instance Eq Group_Abbreviation_Display_
instance Show Group_Abbreviation_Display_
instance Eq Group_Name_Display_
instance Show Group_Name_Display_
instance Eq Part_List_
instance Show Part_List_
instance Eq Credit_
instance Show Credit_


module Text.XML.MusicXML.Partwise
doctype :: DocTypeDecl
type Score_Partwise = (Document_Attributes, (Score_Header, [Part]))
read_Score_Partwise :: (Eq i) => StateT Result [Content i] Score_Partwise
show_Score_Partwise :: Score_Partwise -> [Content ()]
update_Score_Partwise :: ([Software], Encoding_Date) -> Score_Partwise -> Score_Partwise
type Part = (ID, [Measure])
read_Part :: (Eq i) => StateT Result [Content i] Part
show_Part :: Part -> [Content ()]
type Measure = ((CDATA, Maybe Yes_No, Maybe Yes_No, Maybe Tenths), Music_Data)
read_Measure :: (Eq i) => StateT Result [Content i] Measure
show_Measure :: Measure -> [Content ()]


module Text.XML.MusicXML.Timewise
doctype :: DocTypeDecl
type Score_Timewise = (Document_Attributes, (Score_Header, [Measure]))
read_Score_Timewise :: (Eq i) => StateT Result [Content i] Score_Timewise
show_Score_Timewise :: Score_Timewise -> [Content ()]
update_Score_Timewise :: ([Software], Encoding_Date) -> Score_Timewise -> Score_Timewise
type Measure = ((CDATA, Maybe Yes_No, Maybe Yes_No, Maybe Tenths), [Part])
read_Measure :: (Eq i) => StateT Result [Content i] Measure
show_Measure :: Measure -> [Content ()]
type Part = (ID, Music_Data)
read_Part :: (Eq i) => StateT Result [Content i] Part
show_Part :: Part -> [Content ()]


module Text.XML.MusicXML.Opus
doctype :: DocTypeDecl
getFiles :: Opus -> [FilePath]
type Opus = (Document_Attributes, (Maybe Title, [Opus_]))
read_Opus :: (Eq i) => StateT Result [Content i] Opus
show_Opus :: Opus -> [Content ()]
data Opus_
Opus_1 :: Opus -> Opus_
Opus_2 :: Opus_Link -> Opus_
Opus_3 :: Score -> Opus_
read_Opus_ :: (Eq i) => StateT Result [Content i] Opus_
show_Opus_ :: Opus_ -> [Content ()]
type Score = ((Link_Attributes, Maybe Yes_No), ())
read_Score :: StateT Result [Content i] Score
show_Score :: Score -> [Content ()]
type Opus_Link = (Link_Attributes, ())
read_Opus_Link :: StateT Result [Content i] Opus_Link
show_Opus_Link :: Opus_Link -> [Content ()]
type Title = PCDATA
read_Title :: StateT Result [Content i] Title
show_Title :: Title -> [Content ()]
instance Eq Opus_
instance Show Opus_


module Text.XML.MusicXML.Container
doctype :: DocTypeDecl
getFiles :: Container -> [FilePath]
type Container = Rootfiles
read_Container :: (Eq i) => StateT Result [Content i] Container
show_Container :: Container -> [Content ()]
type Rootfiles = [Rootfile]
read_Rootfiles :: (Eq i) => StateT Result [Content i] Rootfiles
show_Rootfiles :: Rootfiles -> [Content ()]
type Rootfile = ((CDATA, Maybe CDATA), ())
read_Rootfile :: (Eq i) => StateT Result [Content i] Rootfile
show_Rootfile :: Rootfile -> [Content ()]


module Text.XML.MusicXML
data ScoreDoc
Partwise :: Score_Partwise -> ScoreDoc
Timewise :: Score_Timewise -> ScoreDoc
data MusicXMLDoc
Score :: ScoreDoc -> MusicXMLDoc
Opus :: Opus -> MusicXMLDoc
Container :: Container -> MusicXMLDoc
data MusicXMLRec
MusicXMLRec :: (Map FilePath MusicXMLDoc) -> MusicXMLRec
read_DOCUMENT :: StateT Result [Content Posn] a -> Document Posn -> Result a
read_MusicXML_Partwise :: Document Posn -> Result Score_Partwise
read_MusicXML_Timewise :: Document Posn -> Result Score_Timewise
read_MusicXML_Opus :: Document Posn -> Result Opus
read_MusicXML_Container :: Document Posn -> Result Container
show_DOCUMENT :: DocTypeDecl -> (t -> [Content i]) -> t -> Result (Document i)
show_MusicXML_Partwise :: Score_Partwise -> Result (Document ())
show_MusicXML_Timewise :: Score_Timewise -> Result (Document ())
show_MusicXML_Opus :: Opus -> Result (Document ())
show_MusicXML_Container :: Container -> Result (Document ())
update_MusicXML_Partwise :: ([Software], Encoding_Date) -> Score_Partwise -> Score_Partwise
update_MusicXML_Timewise :: ([Software], Encoding_Date) -> Score_Timewise -> Score_Timewise
read_MusicXMLDoc :: Document Posn -> Result MusicXMLDoc
show_MusicXMLDoc :: MusicXMLDoc -> Result (Document ())
update_MusicXMLDoc :: ([Software], Encoding_Date) -> MusicXMLDoc -> MusicXMLDoc
read_MusicXMLRec :: FilePath -> IO (Map FilePath MusicXMLDoc)
read_CONTENTS :: (Document Posn -> Result a) -> FilePath -> String -> Result a
show_CONTENTS :: (a -> Result (Document i)) -> a -> String
read_FILE :: (Document Posn -> Result a) -> FilePath -> IO (Result a)
show_FILE :: (a -> Result (Document i)) -> FilePath -> a -> IO ()
xmldecl :: XMLDecl
getFiles :: MusicXMLDoc -> [FilePath]
toMaybe :: Result a -> Maybe a

-- | getTime uses old-time library. At future versions can be defined as:
--   <tt>getTime :: IO Prelude.String</tt> <tt>getTime = getCurrentTime
--   &gt;&gt;= return . show . utctDay</tt>
getTime :: IO Encoding_Date
show3 :: Int -> String
show4 :: Int -> String
show2 :: Int -> String
instance Eq MusicXMLRec
instance Show MusicXMLRec
instance Eq MusicXMLDoc
instance Show MusicXMLDoc
instance Eq ScoreDoc
instance Show ScoreDoc
