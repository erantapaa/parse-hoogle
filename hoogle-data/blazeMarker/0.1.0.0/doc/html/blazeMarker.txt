-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | ...
--   
--   ...
@package blazeMarker
@version 0.1.0.0


-- | Following the shell monad (
--   http:/<i>hackage.haskell.org</i>package<i>shell-monad ) the ASM monad
--   ( http:</i><i>wall.org</i>~lewis<i>2013</i>10<i>15</i>asm-monad.html )
--   and the brainfuck monad (
--   http:/<i>hackage.haskell.org</i>package/brainfuck-monad ) here is a
--   very experimental FreeMarker monad.
--   
--   Example use:
--   
--   <pre>
--   test = FM.renderFM $ do
--       bar &lt;- FM.dec $ FM.litS "string blablabla"
--       lol &lt;- FM.und "varName" $ FM.litN 123
--       FM.exlitl
--       FM.litH $ do
--           B5.div $ do
--               R$&lt;&lt; bar
--               th "test2"
--       FM.lit "test"
--       foo &lt;- FM.dec $ FM.true
--       FM.ifel (foo =~ FM.false)
--           (do
--               FM.litH $ do
--                   B5.div $ do
--                       th "ok true div"
--           )
--           (FM.lit "false")
--       FM.list ( FM.litL $ litN 123 &gt;: litN 321 &gt;: [] ) $ \vi -&gt; do
--           D$&lt; vi
--       FM.list ( FM.litNL [12,321,32] ) $ \vi -&gt; do
--           D$&lt; vi
--   </pre>
module Control.Monad.FreeMarker
litH :: Html -> FM ()
type VarCounter = Int
data FM a
FM :: (VarCounter -> (String, VarCounter, a)) -> FM a
data FEX a b
FEX :: String -> FEX a b
data ENum
data EString
data EBool
data EList a
data EDate
data EHash
data EName
data E
true :: FEX E EBool
false :: FEX E EBool
now :: FEX E EDate
usF :: String -> FEX a b -> FEX c d
usM :: FEX a b -> String -> FEX c d
parShow :: FEX a b -> String
(>~) :: FEX a b -> FEX c b -> FEX E EBool
(>=~) :: FEX a b -> FEX c b -> FEX E EBool
(<~) :: FEX a b -> FEX c b -> FEX E EBool
(<=~) :: FEX a b -> FEX c b -> FEX E EBool
(=~) :: FEX a b -> FEX c b -> FEX E EBool
(&~) :: FEX a EBool -> FEX b EBool -> FEX E EBool
renderFM :: FM a -> String
renderFMW :: FM a -> VarCounter -> String
lit :: String -> FM ()
lite :: String -> FEX a b
size :: FEX a (EList b) -> FEX E ENum
has :: FEX a EHash -> String -> FEX E EBool
data LC b
LC :: (FEX a b) -> LC b
type LitLET a = FEX E (EList a)
litLEmpty :: FEX E (EList a)
litL :: [LC b] -> FEX E (EList b)
litNL :: (Num a, Show a) => [a] -> FEX E (EList ENum)
litSL :: [String] -> FEX E (EList EString)
litBL :: [Bool] -> FEX E (EList EBool)
(>:) :: FEX a b -> [LC b] -> [LC b]
exlitl :: FM ()
list :: FEX a (EList lt) -> (FEX EName lt -> FM b) -> FM ()
if_ :: FEX a EBool -> FM b -> FM ()
ifel :: FEX a EBool -> FM b -> FM c -> FM ()
getVarCounter :: FM VarCounter
dec :: FEX a b -> FM (FEX EName b)
namedDec :: String -> FEX a b -> FM (FEX EName b)
und :: String -> FEX a b -> FM (FEX EName b)
unsafeNamedDeclaration :: String -> FEX a b -> FM (FEX EName b)
assign :: FEX EName a -> FEX b a -> FM ()
urlEncode :: FEX a EString -> FEX E EString
def :: FEX a b -> FEX a b -> FEX a b
data D
D :: D
data R
R :: R
($<) :: D -> FEX a b -> FM ()
($<<) :: R -> FEX a b -> Html
(-~) :: FEX a ENum -> FEX a ENum -> FEX E ENum
(+~) :: FEX a ENum -> FEX a ENum -> FEX E ENum
litN :: (Show a, Num a) => a -> FEX E ENum
litS :: String -> FEX E EString
litB :: Bool -> FEX E EBool
test :: FM ()
instance Monad FM
instance Applicative FM
instance Functor FM
instance Show (LC b)
instance IsString (FM a)
instance Show (FEX a b)
