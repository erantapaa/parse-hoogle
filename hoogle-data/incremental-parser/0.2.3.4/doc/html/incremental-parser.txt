-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generic parser library capable of providing partial results from partial input.
--   
--   This package defines yet another parser library. This one is
--   implemented using the concept of Brzozowski derivatives, tweaked and
--   optimized to work with any monoidal input type. Lists, ByteString, and
--   Text are supported out of the box, as well as any other data type for
--   which the monoid-subclasses package defines instances. If the parser
--   result is also a monoid, the parser can provide it incrementally,
--   before the complete input is parsed.
@package incremental-parser
@version 0.2.3.4


-- | This module defines the AlternativeMonoid class
module Control.Applicative.Monoid
class Applicative f => MonoidApplicative f where (><) = liftA2 mappend
(><) :: (MonoidApplicative f, Monoid a) => f a -> f a -> f a
class (Alternative f, MonoidApplicative f) => MonoidAlternative f where moptional x = x <|> pure mempty concatMany = fmap mconcat . many concatSome = fmap mconcat . some
moptional :: (MonoidAlternative f, Monoid a) => f a -> f a
concatMany :: (MonoidAlternative f, Monoid a) => f a -> f a
concatSome :: (MonoidAlternative f, Monoid a) => f a -> f a


-- | This module defines incremental parsers.
--   
--   The exported <a>Parser</a> type can provide partial parsing results
--   from partial input, as long as the output is a <a>Monoid</a>.
--   Construct a parser using the primitives and combinators, supply it
--   with input using functions <a>feed</a> and <a>feedEof</a>, and extract
--   the parsed output using <a>results</a>.
--   
--   Implementation is based on Brzozowski derivatives.
module Text.ParserCombinators.Incremental

-- | The central parser type. Its first parameter is the input monoid, the
--   second the output.
data Parser a s r

-- | Feeds a chunk of the input to the parser.
feed :: Monoid s => s -> Parser a s r -> Parser a s r

-- | Signals the end of the input.
feedEof :: Monoid s => Parser a s r -> Parser a s r

-- | Like <a>results</a>, but more general: doesn't assume that the result
--   type is a <a>Monoid</a>.
inspect :: Parser a s r -> ([(r, s)], Maybe (Maybe (r -> r), Parser a s r))

-- | Extracts all available parsing results from a <a>Parser</a>. The first
--   component of the result pair is a list of complete results together
--   with the unconsumed remainder of the input. If the parsing can
--   continue further, the second component of the pair provides the
--   partial result prefix together with the parser for the rest of the
--   input.
results :: Monoid r => Parser a s r -> ([(r, s)], Maybe (r, Parser a s r))

-- | Like <a>results</a>, but returns only the complete results with the
--   corresponding unconsumed inputs.
completeResults :: Parser a s r -> [(r, s)]

-- | Like <a>results</a>, but returns only the partial result prefix.
resultPrefix :: Monoid r => Parser a s r -> (r, Parser a s r)
failure :: Parser a s r
more :: (s -> Parser a s r) -> Parser a s r

-- | A parser that fails on any input and succeeds at its end.
eof :: (MonoidNull s, Monoid r) => Parser a s r

-- | A parser that accepts any single input atom.
anyToken :: FactorialMonoid s => Parser a s s

-- | A parser that accepts a specific input atom.
token :: (Eq s, FactorialMonoid s) => s -> Parser a s s

-- | A parser that accepts an input atom only if it satisfies the given
--   predicate.
satisfy :: FactorialMonoid s => (s -> Bool) -> Parser a s s

-- | A parser that accepts all input.
acceptAll :: Monoid s => Parser a s s

-- | A parser that consumes and returns the given prefix of the input.
string :: (LeftReductiveMonoid s, MonoidNull s) => s -> Parser a s s

-- | A parser accepting the longest sequence of input atoms that match the
--   given predicate; an optimized version of 'concatMany . satisfy'.
takeWhile :: (FactorialMonoid s, MonoidNull s) => (s -> Bool) -> Parser a s s

-- | A parser accepting the longest non-empty sequence of input atoms that
--   match the given predicate; an optimized version of 'concatSome .
--   satisfy'.
takeWhile1 :: (FactorialMonoid s, MonoidNull s) => (s -> Bool) -> Parser a s s

-- | Specialization of <a>satisfy</a> on <a>TextualMonoid</a> inputs,
--   accepting an input character only if it satisfies the given predicate.
satisfyChar :: TextualMonoid s => (Char -> Bool) -> Parser a s s

-- | Specialization of <a>takeWhile</a> on <a>TextualMonoid</a> inputs,
--   accepting the longest sequence of input characters that match the
--   given predicate; an optimized version of 'concatMany . satisfyChar'.
takeCharsWhile :: (TextualMonoid s, MonoidNull s) => (Char -> Bool) -> Parser a s s

-- | Specialization of <a>takeWhile1</a> on <a>TextualMonoid</a> inputs,
--   accepting the longest non-empty sequence of input atoms that match the
--   given predicate; an optimized version of 'concatSome . satisfyChar'.
takeCharsWhile1 :: (TextualMonoid s, MonoidNull s) => (Char -> Bool) -> Parser a s s

-- | Accepts the given number of occurrences of the argument parser.
count :: (Monoid s, Monoid r) => Int -> Parser a s r -> Parser a s r

-- | Discards the results of the argument parser.
skip :: (Monoid s, Monoid r) => Parser a s r' -> Parser a s r

-- | Like <tt>optional</tt>, but restricted to <a>Monoid</a> results.
moptional :: (MonoidAlternative f, Monoid a) => f a -> f a

-- | Zero or more argument occurrences like <a>many</a>, but concatenated.
concatMany :: (MonoidAlternative f, Monoid a) => f a -> f a

-- | One or more argument occurrences like <a>some</a>, but concatenated.
concatSome :: (MonoidAlternative f, Monoid a) => f a -> f a

-- | Repeats matching the first argument until the second one succeeds.
manyTill :: (Alternative (Parser a s), Monoid s, Monoid r) => Parser a s r -> Parser a s r' -> Parser a s r
mapType :: (Parser a s r -> Parser b s r) -> Parser a s r -> Parser b s r

-- | Like <a>fmap</a>, but capable of mapping partial results, being
--   restricted to <a>Monoid</a> types only.
mapIncremental :: (Monoid s, Monoid a, Monoid b) => (a -> b) -> Parser p s a -> Parser p s b
(<||>) :: Parser a s r -> Parser a s r -> Parser a s r
(<<|>) :: Monoid s => Parser a s r -> Parser a s r -> Parser a s r

-- | Lifted and potentially optimized monoid <a>mappend</a> operation from
--   the parameter type.
(><) :: (MonoidApplicative f, Monoid a) => f a -> f a -> f a

-- | Behaves like the argument parser, but without consuming any input.
lookAhead :: Monoid s => Parser a s r -> Parser a s r

-- | Does not consume any input; succeeds (with <a>mempty</a> result) iff
--   the argument parser fails.
notFollowedBy :: (Monoid s, Monoid r) => Parser a s r' -> Parser a s r

-- | Parallel parser conjunction: the combined parser keeps accepting input
--   as long as both arguments do.
and :: (Monoid s, Monoid r1, Monoid r2) => Parser a s r1 -> Parser a s r2 -> Parser a s (r1, r2)

-- | A sequence parser that preserves incremental results, otherwise
--   equivalent to <a>liftA2</a> (,)
andThen :: (Monoid s, Monoid r1, Monoid r2) => Parser a s r1 -> Parser a s r2 -> Parser a s (r1, r2)
isInfallible :: Parser a s r -> Bool
showWith :: (Monoid s, Monoid r, Show s) => ((s -> Parser a s r) -> String) -> (r -> String) -> Parser a s r -> String
instance (Alternative (Parser a s), Monoid s) => MonoidAlternative (Parser a s)
instance (Monoid s, Monoid r) => Monoid (Parser a s r)
instance Monoid s => MonoidApplicative (Parser a s)
instance Monoid s => Monad (Parser a s)
instance Monoid s => Applicative (Parser a s)
instance Monoid s => Functor (Parser a s)


-- | This module defines incremental parsers.
--   
--   The exported <a>Parser</a> type can provide partial parsing results
--   from partial input, as long as the output is a <a>Monoid</a>.
--   Construct a parser using the primitives and combinators, supply it
--   with input using functions <a>feed</a> and <a>feedEof</a>, and extract
--   the parsed output using <a>results</a>.
--   
--   Implementation is based on Brzozowski derivatives.
module Text.ParserCombinators.Incremental.LeftBiasedLocal
type Parser s r = Parser LeftBiasedLocal s r

-- | An empty type to specialize <a>Parser</a> for the left-biased
--   <a>Alternative</a> instance.
data LeftBiasedLocal
leftmost :: Parser s r -> Parser a s r
instance Monoid s => MonadPlus (Parser LeftBiasedLocal s)
instance Monoid s => Alternative (Parser LeftBiasedLocal s)


-- | This module defines incremental parsers.
--   
--   The exported <a>Parser</a> type can provide partial parsing results
--   from partial input, as long as the output is a <a>Monoid</a>.
--   Construct a parser using the primitives and combinators, supply it
--   with input using functions <a>feed</a> and <a>feedEof</a>, and extract
--   the parsed output using <a>results</a>.
--   
--   Implementation is based on Brzozowski derivatives.
module Text.ParserCombinators.Incremental.Symmetric
type Parser s r = Parser Symmetric s r

-- | An empty type to specialize <a>Parser</a> for the symmetric
--   <a>Alternative</a> instance.
data Symmetric
allOf :: Parser s r -> Parser a s r
instance Monoid s => MonadPlus (Parser Symmetric s)
instance Monoid s => Alternative (Parser Symmetric s)
