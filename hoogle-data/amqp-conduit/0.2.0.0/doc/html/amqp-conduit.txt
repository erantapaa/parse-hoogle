-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Conduit bindings for AMQP (see amqp package)
--   
@package amqp-conduit
@version 0.2.0.0


-- | Conduit bindings for AMQP (see amqp package)
--   <a>https://hackage.haskell.org/package/amqp</a>
--   
--   Create a AMQP connection, a channel, declare a queue and an exchange
--   and run the given action.
--   
--   <i>Example</i>:
--   
--   Connect to a server, declare a queue and an exchange and setup a
--   callback for messages coming in on the queue. Then publish a single
--   message to our new exchange
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   import           Control.Concurrent           (threadDelay)
--   import           Control.Monad.IO.Class       (MonadIO, liftIO)
--   import           Control.Monad.Trans.Resource (runResourceT)
--   import qualified Data.ByteString.Lazy.Char8   as BL
--   import           Data.Conduit
--   import           Network.AMQP
--   import           Network.AMQP.Conduit
--   import           Test.Hspec
--   
--   
--   main :: IO ()
--   main = hspec $ do
--       describe "produce and consume test" $ do
--           it "send a message and recieve the message" $ do
--               runResourceT $ withChannel config $ \conn -&gt; do
--                   sendMsg str $$ amqpSendSink conn "myExchange" "myKey"
--               amqp &lt;- createChannel config
--               amqp' &lt;- createConsumer amqp "myQueue" Ack $ \(msg,env) -&gt; do
--                   amqpReceiveSource (msg,env) $$ printMsg
--               -- | NOTE: RabbitMQ 1.7 doesn't implement this command.
--               -- amqp'' &lt;- pauseConsumers amqp'
--               -- amqp''' &lt;- resumeConsumers amqp''
--               threadDelay $ 15  * 1000000
--               _ &lt;- deleteConsumer amqp'
--               return ()
--   
--   str :: String
--   str = "This is a test message"
--   
--   config :: AmqpConf
--   config = AmqpConf "amqp://guest:guest@localhost:5672/" queue exchange "myKey"
--       where
--           exchange = newExchange {exchangeName = "myExchange", exchangeType = "direct"}
--           queue = newQueue {queueName = "myQueue"}
--   
--   sendMsg :: (Monad m, MonadIO m) =&gt; String -&gt; Source m Message
--   sendMsg msg = do
--       yield (newMsg {msgBody = (BL.pack msg),msgDeliveryMode = Just Persistent} )
--   
--   printMsg :: (Monad m, MonadIO m) =&gt; Sink (Message, Envelope) m ()
--   printMsg = do
--       m &lt;- await
--       case m of
--          Nothing -&gt; printMsg
--          Just (msg,env) -&gt; do
--              liftIO $ ackEnv env
--              liftIO $ (BL.unpack $ msgBody msg) `shouldBe` str
--              liftIO $ putStrLn $ "received message: " ++ (BL.unpack $ msgBody msg)
--              -
--   </pre>
module Network.AMQP.Conduit

-- | Source as consuming data pushed.
amqpReceiveSource :: MonadIO m => (Message, Envelope) -> Source m (Message, Envelope)

-- | Sink as sending data.
amqpSendSink :: MonadIO m => AmqpConn -> Exchange -> ExchangeKey -> Sink Message m ()

-- | Amqp connection configuration. queue name, exchange name, exchange key
--   name, and amqp URI.
data AmqpConf
AmqpConf :: AmqpURI -> QueueOpts -> ExchangeOpts -> ExchangeKey -> AmqpConf

-- | Connection string to the database.
amqpUri :: AmqpConf -> AmqpURI
amqpQueue :: AmqpConf -> QueueOpts
amqpExchange :: AmqpConf -> ExchangeOpts
amqpExchanKey :: AmqpConf -> ExchangeKey

-- | Amqp Connection and Channel
data AmqpConn
AmqpConn :: Connection -> (Channel, Maybe ConsumerTag) -> AmqpConn
amqpConn :: AmqpConn -> Connection
amqpChan :: AmqpConn -> (Channel, Maybe ConsumerTag)
type ExchangeKey = Text
type Exchange = Text
type QueueName = Text
type AmqpURI = String

-- | Create a AMQP connection and a channel and run the given action. The
--   connetion and channnel are properly released after the action finishes
--   using it. Note that you should not use the given Connection, channel
--   outside the action since it may be already been released.
withChannel :: (MonadIO m, MonadBaseControl IO m) => AmqpConf -> (AmqpConn -> m a) -> m a

-- | Create a connection and a channel. Note that it's your responsability
--   to properly close the connection and the channels when unneeded. Use
--   withAMQPChannels for an automatic resource control.
createConnectionChannel :: AmqpConf -> IO AmqpConn

-- | Close a connection
destoryConnection :: AmqpConn -> IO ()
createQueue :: AmqpConf -> AmqpConn -> IO (QueueName, Int, Int)
createExchange :: AmqpConf -> AmqpConn -> IO ()
bindQueueExchange :: AmqpConf -> AmqpConn -> IO ()
createConsumer :: AmqpConn -> QueueName -> Ack -> ((Message, Envelope) -> IO ()) -> IO AmqpConn
deleteConsumer :: AmqpConn -> IO AmqpConn
pauseConsumer :: AmqpConn -> IO AmqpConn
resumeConsumer :: AmqpConn -> IO AmqpConn
