-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Efficient manipulating of 2D cubic bezier curves.
--   
@package cubicbezier
@version 0.3.0

module Math.BernsteinPoly
data BernsteinPoly
BernsteinPoly :: !Int -> ![Double] -> BernsteinPoly
bernsteinDegree :: BernsteinPoly -> !Int
bernsteinCoeffs :: BernsteinPoly -> ![Double]

-- | Return the subsegment between the two parameters.
bernsteinSubsegment :: BernsteinPoly -> Double -> Double -> BernsteinPoly

-- | Create a bernstein polynomail from a list of coÃ«fficients.
listToBernstein :: [Double] -> BernsteinPoly

-- | The constant zero.
zeroPoly :: BernsteinPoly

-- | Multiply two bernstein polynomials. The final degree will be the sum
--   of either degrees. This operation takes O((n+m)^2) with n and m the
--   degree of the beziers.
(~*) :: BernsteinPoly -> BernsteinPoly -> BernsteinPoly

-- | Scale a bernstein polynomial by a constant.
(*~) :: Double -> BernsteinPoly -> BernsteinPoly

-- | Sum two bernstein polynomials. The final degree will be the maximum of
--   either degrees.
(~+) :: BernsteinPoly -> BernsteinPoly -> BernsteinPoly

-- | Subtract two bernstein polynomials. The final degree will be the
--   maximum of either degrees.
(~-) :: BernsteinPoly -> BernsteinPoly -> BernsteinPoly

-- | Degree elevate a bernstein polynomail a number of times.
degreeElevate :: BernsteinPoly -> Int -> BernsteinPoly

-- | Split a bernstein polynomial
bernsteinSplit :: BernsteinPoly -> Double -> (BernsteinPoly, BernsteinPoly)

-- | Evaluate the bernstein polynomial.
bernsteinEval :: BernsteinPoly -> Double -> Double

-- | Evaluate the bernstein polynomial and its derivatives.
bernsteinEvalDerivs :: BernsteinPoly -> Double -> [Double]

-- | Find the derivative of a bernstein polynomial.
bernsteinDeriv :: BernsteinPoly -> BernsteinPoly
instance Show BernsteinPoly


-- | Basic 2 dimensional geometry functions.
module Geom2D
data Point
Point :: {-# UNPACK #-} !Double -> {-# UNPACK #-} !Double -> Point
pointX :: Point -> {-# UNPACK #-} !Double
pointY :: Point -> {-# UNPACK #-} !Double

-- | A transformation (x, y) -&gt; (ax + by + c, dx + ey + d)
data Transform
Transform :: {-# UNPACK #-} !Double -> {-# UNPACK #-} !Double -> {-# UNPACK #-} !Double -> {-# UNPACK #-} !Double -> {-# UNPACK #-} !Double -> {-# UNPACK #-} !Double -> Transform
xformA :: Transform -> {-# UNPACK #-} !Double
xformB :: Transform -> {-# UNPACK #-} !Double
xformC :: Transform -> {-# UNPACK #-} !Double
xformD :: Transform -> {-# UNPACK #-} !Double
xformE :: Transform -> {-# UNPACK #-} !Double
xformF :: Transform -> {-# UNPACK #-} !Double
data Line
Line :: Point -> Point -> Line
data Polygon
Polygon :: [Point] -> Polygon
class AffineTransform a
transform :: AffineTransform a => Transform -> a -> a

-- | Operator for applying a transformation.
($*) :: AffineTransform a => Transform -> a -> a

-- | Calculate the inverse of a transformation.
inverse :: Transform -> Maybe Transform

-- | Return the parameters (a, b, c) for the normalised equation of the
--   line: <tt>a*x + b*y + c = 0</tt>.
lineEquation :: Line -> (Double, Double, Double)

-- | Return the signed distance from a point to the line. If the distance
--   is negative, the point lies to the right of the line
lineDistance :: Line -> Point -> Double

-- | The lenght of the vector.
vectorMag :: Point -> Double

-- | The angle of the vector, in the range <tt>(-<a>pi</a>,
--   <a>pi</a>]</tt>.
vectorAngle :: Point -> Double

-- | The unitvector with the given angle.
dirVector :: Double -> Point

-- | The unit vector with the same direction.
normVector :: Point -> Point

-- | Scale vector by constant.
(*^) :: Double -> Point -> Point

-- | Scale vector by reciprocal of constant.
(^/) :: Point -> Double -> Point

-- | Scale vector by constant, with the arguments swapped.
(^*) :: Point -> Double -> Point

-- | Add two vectors.
(^+^) :: Point -> Point -> Point

-- | Subtract two vectors.
(^-^) :: Point -> Point -> Point

-- | Dot product of two vectors.
(^.^) :: Point -> Point -> Double

-- | Cross product of two vectors.
vectorCross :: Point -> Point -> Double

-- | Distance between two vectors.
vectorDistance :: Point -> Point -> Double

-- | Interpolate between two vectors.
interpolateVector :: Point -> Point -> Double -> Point

-- | Create a transform that rotates by the angle of the given vector with
--   the x-axis
rotateVec :: Point -> Transform

-- | Create a transform that rotates by the given angle (radians).
rotate :: Double -> Transform

-- | Rotate vector 90 degrees left.
rotate90L :: Transform

-- | Rotate vector 90 degrees right.
rotate90R :: Transform

-- | Create a transform that translates by the given vector.
translate :: Point -> Transform
instance Eq Point
instance Show Transform
instance AffineTransform Polygon
instance AffineTransform Point
instance AffineTransform Transform
instance Show Point

module Geom2D.CubicBezier.Basic
data CubicBezier
CubicBezier :: Point -> Point -> Point -> Point -> CubicBezier
bezierC0 :: CubicBezier -> Point
bezierC1 :: CubicBezier -> Point
bezierC2 :: CubicBezier -> Point
bezierC3 :: CubicBezier -> Point
data PathJoin
JoinLine :: PathJoin
JoinCurve :: Point -> Point -> PathJoin
data Path
OpenPath :: [(Point, PathJoin)] -> Point -> Path
ClosedPath :: [(Point, PathJoin)] -> Path
class AffineTransform a
transform :: AffineTransform a => Transform -> a -> a

-- | Return True if the param lies on the curve, iff it's in the interval
--   <tt>[0, 1]</tt>.
bezierParam :: Double -> Bool

-- | Convert a tolerance from the codomain to the domain of the bezier
--   curve. Should be good enough, but may not hold for high very tolerance
--   values.
bezierParamTolerance :: CubicBezier -> Double -> Double

-- | Reorient to the curve B(1-t).
reorient :: CubicBezier -> CubicBezier

-- | Give the bernstein polynomial for each coordinate.
bezierToBernstein :: CubicBezier -> (BernsteinPoly, BernsteinPoly)

-- | Calculate a value on the curve.
evalBezier :: CubicBezier -> Double -> Point

-- | Calculate a value and the first derivative on the curve.
evalBezierDeriv :: CubicBezier -> Double -> (Point, Point)

-- | Calculate a value and all derivatives on the curve.
evalBezierDerivs :: CubicBezier -> Double -> [Point]

-- | <tt>findBezierTangent p b</tt> finds the parameters where the tangent
--   of the bezier curve <tt>b</tt> has the same direction as vector p.
findBezierTangent :: Point -> CubicBezier -> [Double]

-- | Find the parameter where the bezier curve is horizontal.
bezierHoriz :: CubicBezier -> [Double]

-- | Find the parameter where the bezier curve is vertical.
bezierVert :: CubicBezier -> [Double]

-- | Find inflection points on the curve.
findBezierInflection :: CubicBezier -> [Double]

-- | Find the cusps of a bezier.
findBezierCusp :: CubicBezier -> [Double]

-- | @arcLength c t tol finds the arclength of the bezier c at t, within
--   given tolerance tol.
arcLength :: CubicBezier -> Double -> Double -> Double

-- | arcLengthParam c len tol finds the parameter where the curve c has the
--   arclength len, within tolerance tol.
arcLengthParam :: CubicBezier -> Double -> Double -> Double

-- | Split a bezier curve into two curves.
splitBezier :: CubicBezier -> Double -> (CubicBezier, CubicBezier)

-- | Return the subsegment between the two parameters.
bezierSubsegment :: CubicBezier -> Double -> Double -> CubicBezier

-- | Split a bezier curve into a list of beziers The parameters should be
--   in ascending order or the result is unpredictable.
splitBezierN :: CubicBezier -> [Double] -> [CubicBezier]

-- | Return False if some points fall outside a line with a thickness of
--   the given tolerance.
colinear :: CubicBezier -> Double -> Bool
instance Show CubicBezier
instance Show PathJoin
instance Show Path
instance AffineTransform CubicBezier

module Geom2D.CubicBezier.Approximate

-- | Approximate a function with piecewise cubic bezier splines using a
--   least-squares fit, within the given tolerance. Each subcurve is
--   approximated by using a finite number of samples. It is recommended to
--   avoid changes in direction by subdividing the original function at
--   points of inflection.
approximatePath :: (Double -> (Point, Point)) -> Double -> Double -> Double -> Double -> [CubicBezier]

-- | Like approximatePath, but limit the number of subcurves.
approximatePathMax :: Int -> (Double -> (Point, Point)) -> Double -> Double -> Double -> Double -> [CubicBezier]

-- | <tt>approximateCurve b pts eps</tt> finds the least squares fit of a
--   bezier curve to the points <tt>pts</tt>. The resulting bezier has the
--   same first and last control point as the curve <tt>b</tt>, and have
--   tangents colinear with <tt>b</tt>. return the curve, the parameter
--   with maximum error, and maximum error. Calculate to withing eps
--   tolerance.
approximateCurve :: CubicBezier -> [Point] -> Double -> (CubicBezier, Double, Double)

-- | Like approximateCurve, but also takes an initial guess of the
--   parameters closest to the points. This might be faster if a good guess
--   can be made.
approximateCurveWithParams :: CubicBezier -> [Point] -> [Double] -> Double -> (CubicBezier, Double, Double)


-- | Intersection routines using Bezier Clipping. Provides also functions
--   for finding the roots of onedimensional bezier curves. This can be
--   used as a general polynomial root solver by converting from the power
--   basis to the bernstein basis.
module Geom2D.CubicBezier.Intersection

-- | Find the intersections between two Bezier curves, using the Bezier
--   Clip algorithm. Returns the parameters for both curves.
bezierIntersection :: CubicBezier -> CubicBezier -> Double -> [(Double, Double)]

-- | Find the intersections of the curve with a line.
bezierLineIntersections :: CubicBezier -> Line -> Double -> [Double]

-- | Find the zero of a 1D bezier curve of any degree. Note that this can
--   be used as a bernstein polynomial root solver by converting from the
--   power basis to the bernstein basis.
bezierFindRoot :: BernsteinPoly -> Double -> Double -> Double -> [Double]

-- | Find the closest value(s) on the bezier to the given point, within
--   tolerance.
closest :: CubicBezier -> Point -> Double -> [Double]

module Geom2D.CubicBezier.Curvature

-- | Curvature of the Bezier curve. A negative curvature means the curve
--   curves to the right.
curvature :: CubicBezier -> Double -> Double

-- | Radius of curvature of the Bezier curve. This is the reciprocal of the
--   curvature.
radiusOfCurvature :: CubicBezier -> Double -> Double

-- | Find extrema of the curvature, but not inflection points.
curvatureExtrema :: CubicBezier -> Double -> [Double]

-- | Find points on the curve that have a certain radius of curvature.
--   Values to the left and to the right of the curve are returned.
findRadius :: CubicBezier -> Double -> Double -> [Double]


-- | Offsetting bezier curves and stroking curves.
module Geom2D.CubicBezier.Outline

-- | Calculate an offset path from the bezier curve to within tolerance. If
--   the distance is positive offset to the left, otherwise to the right. A
--   smaller tolerance may require more bezier curves in the path to
--   approximate the offset curve
bezierOffset :: CubicBezier -> Double -> Double -> [CubicBezier]

-- | Like bezierOffset, but limit the number of subpaths for each smooth
--   subsegment. The number should not be smaller than one.
bezierOffsetMax :: Int -> CubicBezier -> Double -> Double -> [CubicBezier]


-- | This module implements an extension to paths as used in D.E.Knuth's
--   <i>Metafont</i>. Metafont gives an alternate way to specify paths
--   using bezier curves. I'll give a brief overview of the metafont
--   curves. A more in depth explanation can be found in <i>The
--   MetafontBook</i>.
--   
--   Each spline has a tension parameter, which is a relative measure of
--   the length of the curve. You can specify the tension for the left side
--   and the right side of the spline separately. By default metafont gives
--   a tension of 1, which gives a good looking curve. Tensions shouldn't
--   be less than 3/4, but this implementation doesn't check for it. If you
--   want to avoid points of inflection on the spline, you can use
--   <tt>TensionAtLeast</tt> instead of <tt>Tension</tt>, which will adjust
--   the length of the control points so they fall into the <i>bounding
--   triangle</i>, if such a triangle exist.
--   
--   You can either give directions for each node, or let metafont find
--   them. Metafont will solve a set of equations to find the directions.
--   You can also let metafont find directions at corner points by setting
--   the <i>curl</i>, which is how much the point <i>curls</i> at that
--   point. At endpoints a curl of 1 is implied when it is not given.
--   
--   Metafont will then find the control points from the path for you. You
--   can also specify the control points explicitly.
--   
--   Here is an example path from the metafont program text:
--   
--   <pre>
--   z0..z1..tension atleast 1..{curl 2}z2..z3{-1,-2}..tension 3 and 4..z4..controls z45 and z54..z5
--   </pre>
--   
--   This path is equivalent to:
--   
--   <pre>
--   z0{curl 1}..tension atleast 1 and atleast 1..{curl 2}z2{curl 2}..tension 1 and 1..
--   {-1,-2}z3{-1,-2}..tension 3 and 4..z4..controls z45 and z54..z5
--   </pre>
--   
--   This path can be used with the following datatype:
--   
--   <pre>
--   OpenMetaPath [ (z0, MetaJoin Open (Tension 1) (Tension 1) Open)
--                , (z1, MetaJoin Open (TensionAtLeast 1) (TensionAtLeast 1) (Curl 2))
--                , (z2, MetaJoin Open (Tension 1) (Tension 1) Open)
--                , (z3, MetaJoin (Direction (Point (-1) (-2))) (Tension 3) (Tension 4) Open)
--                , (z4, Controls z45 z54)
--                ] z5
--   </pre>
--   
--   Cyclic paths are similar, but use the <tt>CyclicMetaPath</tt>
--   contructor. There is no ending point, since the ending point will be
--   the same as the first point.
module Geom2D.CubicBezier.MetaPath

-- | Create a normal path from a metapath.
unmeta :: MetaPath -> Path
data MetaPath
OpenMetaPath :: [(Point, MetaJoin)] -> Point -> MetaPath
CyclicMetaPath :: [(Point, MetaJoin)] -> MetaPath
data MetaJoin
MetaJoin :: MetaNodeType -> Tension -> Tension -> MetaNodeType -> MetaJoin
metaTypeL :: MetaJoin -> MetaNodeType
tensionL :: MetaJoin -> Tension
tensionR :: MetaJoin -> Tension
metaTypeR :: MetaJoin -> MetaNodeType
Controls :: Point -> Point -> MetaJoin
data MetaNodeType
Open :: MetaNodeType
Curl :: Double -> MetaNodeType
curlgamma :: MetaNodeType -> Double
Direction :: Point -> MetaNodeType
nodedir :: MetaNodeType -> Point
data Tension
Tension :: Double -> Tension
tensionValue :: Tension -> Double
TensionAtLeast :: Double -> Tension
tensionValue :: Tension -> Double
instance Eq MetaNodeType
instance Show MetaNodeType
instance Eq Tension
instance Show Tension
instance Show MetaJoin
instance Show MetaPath


-- | Export all the cubic bezier functions.
module Geom2D.CubicBezier
