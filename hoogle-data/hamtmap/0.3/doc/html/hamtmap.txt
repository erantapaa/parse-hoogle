-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A purely functional and persistent hash map
--   
--   A port of Clojure's efficient persistent and hash map data structure
--   to Haskell
@package hamtmap
@version 0.3


-- | An implementation of maps from keys to values (dictionaries) based on
--   the hash array mapped trie.
--   
--   Since many function names (but not the type name) clash with
--   <a>Prelude</a> names, this module is usually imported
--   <tt>qualified</tt>, e.g.
--   
--   <pre>
--   import qualified Data.HamtMap as HM
--   </pre>
--   
--   This data structure is based on Phil Bagwell's hash array mapped trie,
--   which is described by his original paper:
--   
--   <ul>
--   <li><a>http://lampwww.epfl.ch/papers/idealhashtrees.pdf</a></li>
--   </ul>
module Data.HamtMap

-- | A HamtMap from keys <tt>k</tt> to values <tt>v</tt>
data (Eq k, Hashable k) => HamtMap k v

-- | Find the value at a key. Calls <a>error</a> when the element can not
--   be found.
(!) :: (Eq k, Hashable k) => HamtMap k v -> k -> v

-- | Is the key a member of the map? See also <a>notMember</a>.
member :: (Eq k, Hashable k) => k -> HamtMap k v -> Bool

-- | Is the key a member of the map? See also <a>member</a>.
notMember :: (Eq k, Hashable k) => k -> HamtMap k v -> Bool

-- | Lookup the value at a key in the map.
--   
--   The function will return the corresponding value as <tt>(<a>Just</a>
--   value)</tt>, or <a>Nothing</a> if the key isn't in the map.
lookup :: (Eq k, Hashable k) => k -> HamtMap k v -> Maybe v

-- | The empty HamtMap.
empty :: (Eq k, Hashable k) => HamtMap k v

-- | <tt>(<a>singleton</a> key value)</tt> is a single-element HamtMap
--   holding <tt>(key, value)</tt>
singleton :: (Eq k, Hashable k) => k -> v -> HamtMap k v

-- | Insert a new key and value in the map. If the key is already present
--   in the map, the associated value is replaced with the supplied value.
--   <a>insert</a> is equivalent to <tt><a>insertWith</a>
--   <a>const</a></tt>.
insert :: (Eq k, Hashable k) => k -> v -> HamtMap k v -> HamtMap k v

-- | Insert with a function, combining new value and old value.
--   <tt><a>insertWith</a> f key value mp</tt> will insert the pair (key,
--   value) into <tt>mp</tt> if key does not exist in the map. If the key
--   does exist, the function will insert the pair <tt>(key, f new_value
--   old_value)</tt>.
insertWith :: (Eq k, Hashable k) => (v -> v -> v) -> k -> v -> HamtMap k v -> HamtMap k v

-- | Delete a key and its value from the map. When the key is not a member
--   of the map, the original map is returned.
delete :: (Eq k, Hashable k) => k -> HamtMap k v -> HamtMap k v

-- | Update a value at a specific key with the result of the provided
--   function. When the key is not a member of the map, the original map is
--   returned.
adjust :: (Eq k, Hashable k) => (v -> v) -> k -> HamtMap k v -> HamtMap k v

-- | The expression (<tt><a>update</a> f k map</tt>) updates the value
--   <tt>x</tt> at <tt>k</tt> (if it is in the map). If (<tt>f x</tt>) is
--   <a>Nothing</a>, the element is deleted. If it is (<tt><a>Just</a>
--   y</tt>), the key <tt>k</tt> is bound to the new value <tt>y</tt>.
update :: (Eq k, Hashable k) => (v -> Maybe v) -> k -> HamtMap k v -> HamtMap k v

-- | The expression (<tt><a>alter</a> f k map</tt>) alters the value
--   <tt>x</tt> at <tt>k</tt>, or absence thereof. <a>alter</a> can be used
--   to insert, delete, or update a value in a <tt>Map</tt>. In short :
--   <tt><a>lookup</a> k (<a>alter</a> f k m) = f (<a>lookup</a> k m)</tt>.
alter :: (Eq k, Hashable k) => (Maybe v -> Maybe v) -> k -> HamtMap k v -> HamtMap k v

-- | Map a function over all values in the map.
map :: (Eq k, Hashable k) => (v -> v) -> HamtMap k v -> HamtMap k v

-- | Map a function over all values in the map.
mapWithKey :: (Eq k, Hashable k) => (k -> v -> v) -> HamtMap k v -> HamtMap k v

-- | Filter for all values that satisify a predicate.
filter :: (Eq k, Hashable k) => (v -> Bool) -> HamtMap k v -> HamtMap k v

-- | Filter for all values that satisify a predicate.
filterWithKey :: (Eq k, Hashable k) => (k -> v -> Bool) -> HamtMap k v -> HamtMap k v

-- | Return all elements of the map.
elems :: (Eq k, Hashable k) => HamtMap k v -> [v]

-- | Return all keys of the map.
keys :: (Eq k, Hashable k) => HamtMap k v -> [k]

-- | Convert to a list of key/value pairs.
toList :: (Eq k, Hashable k) => HamtMap k v -> [(k, v)]

-- | Build a map from a list of key/value pairs with a combining function.
fromListWith :: (Eq k, Hashable k) => (v -> v -> v) -> [(k, v)] -> HamtMap k v

-- | Build a map from a list of key/value pairs. If the list contains more
--   than one value for the same key, the last value for the key is
--   retained.
fromList :: (Eq k, Hashable k) => [(k, v)] -> HamtMap k v
instance Eq Change
instance (Eq k, Hashable k, Show k, Show v) => Show (HamtMap k v)
instance (Eq k, Hashable k, NFData k, NFData v) => NFData (HamtMap k v)
