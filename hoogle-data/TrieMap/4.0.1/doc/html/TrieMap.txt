-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Automatic type inference of generalized tries with Template Haskell.
--   
--   Provides a efficient and compact implementation of generalized tries,
--   and Template Haskell tools to generate the necessary translation code.
--   This is meant as a drop-in replacement for Data.Map, and can be used
--   anywhere <tt>Data.Map</tt> can be used.
--   
--   The most recent release combines zipper-based ideas from recently
--   proposed changes to Data.Map, as well as heavily optimized ByteString
--   and Vector instances based on the vector package. For best
--   performance, use <tt>cabal install -fllvm -O2</tt>.
@package TrieMap
@version 4.0.1


-- | Operators for use in <a>Repr</a> instances for types.
module Data.TrieMap.Modifiers

-- | Denotes that maps on this type should be implemented with traditional
--   binary search trees.
newtype Ordered a
Ord :: a -> Ordered a
unOrd :: Ordered a -> a

-- | Denotes that maps on this type should be treated as reversed. For
--   instance, <tt><a>Rep</a> <a>Int</a></tt> might be implemented as
--   <tt><a>Either</a> (<a>Rev</a> Word) Word</tt>, to handle negative
--   numbers properly.
newtype Rev k
Rev :: k -> Rev k
getRev :: Rev k -> k

-- | Indicates that the map for this type should be bootstrapped from its
--   <tt>TKey</tt> instance. This modifier is necessary to define a
--   <tt>TKey</tt> instance for a recursively defined type. For example:
--   
--   <pre>
--   data Tree = Node Char [Tree]
--   
--   instance 'Repr' Tree where
--   	type 'Rep' Tree = ('Rep' 'Char', ['Key' Tree])
--   	'toRep' (Node label children) = ('toRep' label, 'map' 'Key' children)
--   	...
--   </pre>
newtype Key k
Key :: k -> Key k
getKey :: Key k -> k
instance Eq k => Eq (Rev k)
instance Eq a => Eq (Ordered a)
instance Ord a => Ord (Ordered a)
instance Repr k => Repr (Key k)
instance (Repr k, Ord (Rep k)) => Ord (Key k)
instance (Repr k, Eq (Rep k)) => Eq (Key k)
instance Functor Rev
instance Functor Ordered
instance Ord k => Ord (Rev k)

module Data.TrieMap.Representation

-- | The <tt>Repr</tt> type class denotes that a type can be decomposed to
--   a representation built out of pieces for which the <tt>TrieKey</tt>
--   class defines a generalized trie structure.
--   
--   It is required that, if <tt>(<a>Repr</a> a, <a>Eq</a> a)</tt>, and
--   <tt>x, y :: a</tt>, then <tt>x <a>==</a> y</tt> if and only if
--   <tt><a>toRep</a> x <a>==</a> <a>toRep</a> y</tt>. It is typically the
--   case that <tt><a>compare</a> x y == <a>compare</a> (<a>toRep</a> x)
--   (<a>toRep</a> y)</tt>, as well, but this is not strictly required. (It
--   is, however, the case for all instances built into the package.)
--   
--   As an additional note, the <tt>Key</tt> modifier is used for
--   "bootstrapping" <a>Repr</a> instances, allowing a type to be used in
--   its own <a>Repr</a> definition when wrapped in a <tt>Key</tt>
--   modifier.
class Repr a where { type family Rep a; type family RepList a; }
toRep :: Repr a => a -> Rep a
toRepList :: Repr a => [a] -> RepList a

-- | Given the name of a type constructor, automatically generates an
--   efficient <a>Repr</a> instance. If you have several mutually dependent
--   (or even mutually recursive) types, <a>genRepr</a> will construct
--   instances for all of them.
--   
--   <a>genRepr</a> guarantees that any instances it generates are
--   consistent with the ordering that would be generated by <tt>deriving
--   (<a>Ord</a>)</tt> in the data declaration. That is, if <a>genRepr</a>
--   generates an instance <tt>Repr a</tt>, then it is guaranteed that if
--   <tt>x, y :: a</tt>, and <tt>a</tt> has a derived <a>Ord</a> instance,
--   then <tt>compare x y == compare (toRep x) (toRep y)</tt>.
genRepr :: Name -> Q [Dec]

-- | Given the name of a type constructor, automatically generates an
--   efficient <a>Repr</a> instance. If you have several mutually dependent
--   (or even mutually recursive) types, <a>genOptRepr</a> will construct
--   instances for all of them. The instance generated by <a>genOptRepr</a>
--   may, in some cases, be more efficient than the instance generated by
--   <a>genRepr</a> -- in particular, arguments common to several
--   constructors may be factored out, reducing the complexity of the
--   associated <tt>TrieKey</tt> instance, but leaving an ordering
--   inconsistent with <a>Ord</a>.
--   
--   Therefore, <a>genOptRepr</a> guarantees that any instances it
--   generates are consistent with the ordering that would be generated by
--   <tt>deriving (<a>Eq</a>)</tt> in the data declaration. That is, if
--   <a>genOptRepr</a> generates an instance <tt>Repr a</tt>, then it is
--   guaranteed that if <tt>x, y :: a</tt>, and <tt>a</tt> has a derived
--   <a>Eq</a> instance, then <tt>(x == y) == (toRep x == toRep y)</tt>.
genOptRepr :: Name -> Q [Dec]

-- | Given a type with an associated <a>Ord</a> instance, generates a
--   representation that will cause its <tt>TMap</tt> implementation to be
--   essentially equivalent to <a>Data.Map</a>.
genOrdRepr :: Name -> Q [Dec]

module Data.TrieMap.Class

-- | A map from keys <tt>k</tt> to values <tt>a</tt>, backed by a trie.
newtype TMap k a
TMap :: TrieMap (Rep k) (Assoc k a) -> TMap k a
getTMap :: TMap k a -> TrieMap (Rep k) (Assoc k a)

-- | A set of values <tt>a</tt>, backed by a trie.
newtype TSet a
TSet :: TrieMap (Rep a) (Elem a) -> TSet a
getTSet :: TSet a -> TrieMap (Rep a) (Elem a)

-- | <tt><a>TKey</a> k</tt> is a handy alias for <tt>(<a>Repr</a> k,
--   <a>TrieKey</a> (<a>Rep</a> k))</tt>. To make a type an instance of
--   <a>TKey</a>, create a <a>Repr</a> instance that will satisfy
--   <tt><a>TrieKey</a> (<a>Rep</a> k)</tt>, possibly using the Template
--   Haskell methods provided by <a>Data.TrieMap.Representation</a>.
class (Repr k, TrieKey (Rep k)) => TKey k

-- | A <tt>TrieKey k</tt> instance implies that <tt>k</tt> is a
--   standardized representation for which a generalized trie structure can
--   be derived.
class (Ord k, Buildable (TrieMap k) k, Subset (TrieMap k), Traversable (TrieMap k), SetOp (TrieMap k), Project (TrieMap k)) => TrieKey k where { data family TrieMap k :: * -> *; { sizeM# m = unbox (inline sizeM m) firstHoleM m = inline extractHoleM m lastHoleM m = inline extractHoleM m insertWithM f k a m = inline searchMC k m (assignM a) (assignM . f) unifierM k' k a = Lookup $ \ no yes -> searchMC k' (singletonM k a) yes (\ _ _ -> no) unifyM k1 a1 k2 a2 = assignM a1 <$> unifierM k1 k2 a2 } }
instance TKey k => Traversable (TMap k)
instance TKey k => Foldable (TMap k)
instance TKey k => Functor (TMap k)
instance (Repr k, TrieKey (Rep k)) => TKey k

module Data.TrieSet

-- | A set of values <tt>a</tt>, backed by a trie.
data TSet a

-- | See <a>difference</a>.
(\\) :: TKey a => TSet a -> TSet a -> TSet a

-- | <i>O(1)</i>. Is this the empty set?
null :: TKey a => TSet a -> Bool

-- | <i>O(1)</i>. The number of elements in the set.
size :: TKey a => TSet a -> Int

-- | Is the element in the set?
member :: TKey a => a -> TSet a -> Bool

-- | Is the element not in the set?
notMember :: TKey a => a -> TSet a -> Bool

-- | Is this a subset? <tt>(s1 <a>isSubsetOf</a> s2)</tt> tells whether
--   <tt>s1</tt> is a subset of <tt>s2</tt>.
isSubsetOf :: TKey a => TSet a -> TSet a -> Bool

-- | Is this a proper subset? (ie. a subset but not equal).
isProperSubsetOf :: TKey a => TSet a -> TSet a -> Bool

-- | The empty <a>TSet</a>.
empty :: TKey a => TSet a

-- | <i>O(1)</i>. Create a singleton set.
singleton :: TKey a => a -> TSet a

-- | Insert an element into the <a>TSet</a>.
insert :: TKey a => a -> TSet a -> TSet a

-- | Delete an element from the <a>TSet</a>.
delete :: TKey a => a -> TSet a -> TSet a

-- | The union of two <a>TSet</a>s, preferring the first set when equal
--   elements are encountered.
union :: TKey a => TSet a -> TSet a -> TSet a

-- | The symmetric difference of two <a>TSet</a>s.
symmetricDifference :: TKey a => TSet a -> TSet a -> TSet a

-- | Intersection of two <a>TSet</a>s. Elements of the result come from the
--   first set.
intersection :: TKey a => TSet a -> TSet a -> TSet a

-- | Difference of two <a>TSet</a>s.
difference :: TKey a => TSet a -> TSet a -> TSet a

-- | Filter all elements that satisfy the predicate.
filter :: TKey a => (a -> Bool) -> TSet a -> TSet a

-- | Partition the set into two sets, one with all elements that satisfy
--   the predicate and one with all elements that don't satisfy the
--   predicate. See also <a>split</a>.
partition :: TKey a => (a -> Bool) -> TSet a -> (TSet a, TSet a)

-- | The expression (<tt><a>split</a> x set</tt>) is a pair
--   <tt>(set1,set2)</tt> where <tt>set1</tt> comprises the elements of
--   <tt>set</tt> less than <tt>x</tt> and <tt>set2</tt> comprises the
--   elements of <tt>set</tt> greater than <tt>x</tt>.
split :: TKey a => a -> TSet a -> (TSet a, TSet a)

-- | Performs a <a>split</a> but also returns whether the pivot element was
--   found in the original set.
splitMember :: TKey a => a -> TSet a -> (TSet a, Bool, TSet a)

-- | <tt><a>map</a> f s</tt> is the set obtained by applying <tt>f</tt> to
--   each element of <tt>s</tt>.
--   
--   It's worth noting that the size of the result may be smaller if, for
--   some <tt>(x,y)</tt>, <tt>x /= y &amp;&amp; f x == f y</tt>
map :: (TKey a, TKey b) => (a -> b) -> TSet a -> TSet b

-- | <tt><a>mapMonotonic</a> f s == <a>map</a> f s</tt>, but works only
--   when <tt>f</tt> is strictly monotonic. <i>The precondition is not
--   checked.</i> Semi-formally, we have:
--   
--   <pre>
--   and [x &lt; y ==&gt; f x &lt; f y | x &lt;- ls, y &lt;- ls] 
--                       ==&gt; mapMonotonic f s == map f s
--       where ls = toList s
--   </pre>
mapMonotonic :: (TKey a, TKey b) => (a -> b) -> TSet a -> TSet b

-- | Pre-order fold.
foldl :: TKey b => (a -> b -> a) -> a -> TSet b -> a

-- | Post-order fold.
foldr :: TKey a => (a -> b -> b) -> b -> TSet a -> b

-- | The minimal element of the set.
findMin :: TKey a => TSet a -> a

-- | The maximal element of the set.
findMax :: TKey a => TSet a -> a

-- | Delete the minimal element.
deleteMin :: TKey a => TSet a -> TSet a

-- | Delete the maximal element.
deleteMax :: TKey a => TSet a -> TSet a

-- | Delete and find the minimal element.
--   
--   <pre>
--   'deleteFindMin' set = ('findMin' set, 'deleteMin' set)
--   </pre>
deleteFindMin :: TKey a => TSet a -> (a, TSet a)

-- | Delete and find the maximal element.
--   
--   <pre>
--   'deleteFindMax' set = ('findMax' set, 'deleteMax' set)
--   </pre>
deleteFindMax :: TKey a => TSet a -> (a, TSet a)

-- | Retrieves the minimal key of the set, and the set stripped of that
--   element, or <a>Nothing</a> if passed an empty set.
minView :: TKey a => TSet a -> Maybe (a, TSet a)

-- | Retrieves the maximal key of the set, and the set stripped of that
--   element, or <a>Nothing</a> if passed an empty set.
maxView :: TKey a => TSet a -> Maybe (a, TSet a)

-- | Returns the element at the specified index. Throws an error if an
--   invalid index is specified.
elemAt :: TKey a => Int -> TSet a -> a

-- | Deletes the element at the specified index. Throws an error if an
--   invalid index is specified.
deleteAt :: TKey a => Int -> TSet a -> TSet a

-- | If the specified element is in the set, returns <a>Just</a> the index
--   of the element, otherwise returns <a>Nothing</a>.
lookupIndex :: TKey a => a -> TSet a -> Maybe Int

-- | Generate a <a>TMap</a> by mapping on the elements of a <a>TSet</a>.
mapSet :: TKey a => (a -> b) -> TSet a -> TMap a b

-- | See <a>toAscList</a>.
elems :: TKey a => TSet a -> [a]

-- | See <a>toAscList</a>.
toList :: TKey a => TSet a -> [a]

-- | Create a set from a list of elements.
fromList :: TKey a => [a] -> TSet a

-- | <i>O(n)</i>. Construct a vector from the elements of this set. Does
--   not currently fuse.
toVector :: (TKey a, Vector v a) => TSet a -> v a

-- | Create a set from a vector of elements.
fromVector :: (TKey a, Vector v a) => v a -> TSet a

-- | Convert the set to an ascending list of elements.
toAscList :: TKey a => TSet a -> [a]

-- | Build a set from an ascending list in linear time. <i>The precondition
--   (input list is ascending) is not checked.</i>
fromAscList :: TKey a => [a] -> TSet a

-- | <i>O(n)</i>. Build a set from an ascending list of distinct elements
--   in linear time. <i>The precondition (input list is strictly ascending)
--   is not checked.</i>
fromDistinctAscList :: TKey a => [a] -> TSet a

-- | Build a set from an ascending vector in linear time. <i>The
--   precondition (input vector is ascending) is not checked.</i>
fromAscVector :: (TKey a, Vector v a) => v a -> TSet a

-- | <i>O(n)</i>. Build a set from an ascending vector of distinct elements
--   in linear time. <i>The precondition (input vector is strictly
--   ascending) is not checked.</i>
fromDistinctAscVector :: (TKey a, Vector v a) => v a -> TSet a
instance TKey a => Monoid (TSet a)
instance (TKey a, Show a) => Show (TSet a)
instance (TKey a, Ord a) => Ord (TSet a)
instance TKey a => Eq (TSet a)

module Data.TrieMap

-- | <tt><a>TKey</a> k</tt> is a handy alias for <tt>(<a>Repr</a> k,
--   <a>TrieKey</a> (<a>Rep</a> k))</tt>. To make a type an instance of
--   <a>TKey</a>, create a <a>Repr</a> instance that will satisfy
--   <tt><a>TrieKey</a> (<a>Rep</a> k)</tt>, possibly using the Template
--   Haskell methods provided by <a>Data.TrieMap.Representation</a>.
class (Repr k, TrieKey (Rep k)) => TKey k

-- | A map from keys <tt>k</tt> to values <tt>a</tt>, backed by a trie.
data TMap k a

-- | A <a>TLocation</a> represents a <a>TMap</a> with a "hole" at a
--   particular key position.
--   
--   <a>TLocation</a>s are used for element-wise operations on maps
--   (insertion, deletion and update) in a two-stage process:
--   
--   <ol>
--   <li>A <a>TLocation</a> (and the value at that position, if any) is
--   obtained from a <a>TMap</a> by searching or indexing. 2. A new
--   <a>TMap</a> is made from a <a>TLocation</a> by either filling the hole
--   with a value (<a>assign</a>) or erasing it (<a>clear</a>).</li>
--   </ol>
data TLocation k a

-- | <i>O(1)</i>. The key marking the position of the "hole" in the map.
key :: TKey k => TLocation k a -> k

-- | <tt><a>before</a> loc</tt> is the submap with keys less than
--   <tt><a>key</a> loc</tt>.
before :: TKey k => TLocation k a -> TMap k a

-- | <tt><a>beforeWith</a> a loc</tt> is equivalent to <tt><a>insert</a>
--   (<a>key</a> loc) a (<a>before</a> loc)</tt>.
beforeWith :: TKey k => a -> TLocation k a -> TMap k a

-- | <tt><a>after</a> loc</tt> is the submap with keys greater than
--   <tt><a>key</a> loc</tt>.
after :: TKey k => TLocation k a -> TMap k a

-- | <tt><a>afterWith</a> a loc</tt> is equivalent to <tt><a>insert</a>
--   (<a>key</a> loc) a (<a>after</a> loc)</tt>.
afterWith :: TKey k => a -> TLocation k a -> TMap k a

-- | Search the map for the given key, returning the corresponding value
--   (if any) and an updatable location for that key.
--   
--   Properties:
--   
--   <pre>
--   case <a>search</a> k m of
--       (Nothing, loc) -&gt; <a>key</a> loc == k &amp;&amp; <a>clear</a> loc == m
--       (Just v,  loc) -&gt; <a>key</a> loc == k &amp;&amp; <a>assign</a> v loc == m
--   </pre>
--   
--   <pre>
--   <a>lookup</a> k m == <a>fst</a> (<a>search</a> k m)
--   </pre>
search :: TKey k => k -> TMap k a -> (Maybe a, TLocation k a)

-- | Return the value and an updatable location for the <i>i</i>th key in
--   the map. Calls <a>error</a> if <i>i</i> is out of range.
--   
--   Properties:
--   
--   <pre>
--   0 &lt;= i &amp;&amp; i &lt; <a>size</a> m ==&gt;
--       let (v, loc) = <a>index</a> i m in
--           <a>size</a> (<a>before</a> loc) == i &amp;&amp; <a>assign</a> v loc == m
--   </pre>
--   
--   <pre>
--   <a>elemAt</a> i m == let (v, loc) = <a>index</a> i m in (<a>key</a> loc, v)
--   </pre>
index :: TKey k => Int -> TMap k a -> (a, TLocation k a)

-- | <i>O(log n)</i>. Return the value and an updatable location for the
--   least key in the map, or <a>Nothing</a> if the map is empty.
--   
--   Properties:
--   
--   <pre>
--   <a>size</a> m &gt; 0 ==&gt;
--       let Just (v, loc) = <a>minLocation</a> i m in
--           <a>size</a> (<a>before</a> loc) == 0 &amp;&amp; <a>assign</a> v loc == m
--   </pre>
--   
--   <pre>
--   <a>findMin</a> m == let Just (v, loc) = <a>minLocation</a> i m in (<a>key</a> loc, v)
--   </pre>
minLocation :: TKey k => TMap k a -> Maybe (a, TLocation k a)

-- | Return the value and an updatable location for the greatest key in the
--   map, or <a>Nothing</a> if the map is empty.
--   
--   Properties:
--   
--   <pre>
--   <a>size</a> m &gt; 0 ==&gt;
--       let Just (v, loc) = <a>maxLocation</a> i m in
--           <a>size</a> (<a>after</a> loc) == 0 &amp;&amp; <a>assign</a> v loc == m
--   </pre>
--   
--   <pre>
--   <a>findMax</a> m == let Just (v, loc) = <a>maxLocation</a> i m in (<a>key</a> loc, v)
--   </pre>
maxLocation :: TKey k => TMap k a -> Maybe (a, TLocation k a)

-- | Return a map obtained by placing the given value at the location
--   (replacing an existing value, if any).
--   
--   <pre>
--   <a>assign</a> v loc == <a>before</a> loc <a>union</a> <a>singleton</a> (<a>key</a> loc) v <a>union</a> <a>after</a> loc
--   </pre>
assign :: TKey k => a -> TLocation k a -> TMap k a

-- | Return a map obtained by erasing the location.
--   
--   <pre>
--   <a>clear</a> loc == <a>before</a> loc <a>union</a> <a>after</a> loc
--   </pre>
clear :: TKey k => TLocation k a -> TMap k a

-- | Find the value at a key. Calls <a>error</a> when the element can not
--   be found.
(!) :: TKey k => TMap k a -> k -> a

-- | Same as <a>difference</a>.
(\\) :: TKey k => TMap k a -> TMap k b -> TMap k a

-- | <i>O(1)</i>. Is the map empty?
null :: TKey k => TMap k a -> Bool

-- | <i>O(1)</i>. The number of elements in the map.
--   
--   <pre>
--   size empty                                   == 0
--   size (singleton 1 'a')                       == 1
--   size (fromList([(1,'a'), (2,'c'), (3,'b')])) == 3
--   </pre>
size :: TKey k => TMap k a -> Int

-- | Is the key a member of the map? See also <a>notMember</a>.
--   
--   <pre>
--   member 5 (fromList [(5,'a'), (3,'b')]) == True
--   member 1 (fromList [(5,'a'), (3,'b')]) == False
--   </pre>
member :: TKey k => k -> TMap k a -> Bool

-- | Is the key not a member of the map? See also <a>member</a>.
--   
--   <pre>
--   notMember 5 (fromList [(5,'a'), (3,'b')]) == False
--   notMember 1 (fromList [(5,'a'), (3,'b')]) == True
--   </pre>
notMember :: TKey k => k -> TMap k a -> Bool

-- | Lookup the value at a key in the map.
--   
--   The function will return the corresponding value as <tt>(<a>Just</a>
--   value)</tt>, or <a>Nothing</a> if the key isn't in the map.
lookup :: TKey k => k -> TMap k a -> Maybe a

-- | The expression <tt>(<a>findWithDefault</a> def k map)</tt> returns the
--   value at key <tt>k</tt> or returns default value <tt>def</tt> when the
--   key is not in the map.
findWithDefault :: TKey k => a -> k -> TMap k a -> a

-- | <i>O(1)</i>. The empty map.
empty :: TKey k => TMap k a

-- | <i>O(1)</i>. A map with a single element.
singleton :: TKey k => k -> a -> TMap k a

-- | Insert a new key and value in the map. If the key is already present
--   in the map, the associated value is replaced with the supplied value.
--   <a>insert</a> is equivalent to <tt><a>insertWith</a>
--   <a>const</a></tt>.
--   
--   <pre>
--   insert 5 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'x')]
--   insert 7 'x' (fromList [(5,'a'), (3,'b')]) == fromList [(3, 'b'), (5, 'a'), (7, 'x')]
--   insert 5 'x' empty                         == singleton 5 'x'
--   </pre>
insert :: TKey k => k -> a -> TMap k a -> TMap k a

-- | Insert with a function, combining new value and old value.
--   <tt><a>insertWith</a> f key value mp</tt> will insert the pair (key,
--   value) into <tt>mp</tt> if key does not exist in the map. If the key
--   does exist, the function will insert the pair <tt>(key, f new_value
--   old_value)</tt>.
--   
--   <pre>
--   insertWith (++) 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "xxxa")]
--   insertWith (++) 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]
--   insertWith (++) 5 "xxx" empty                         == singleton 5 "xxx"
--   </pre>
insertWith :: TKey k => (a -> a -> a) -> k -> a -> TMap k a -> TMap k a

-- | Insert with a function, combining key, new value and old value.
--   <tt><a>insertWithKey</a> f key value mp</tt> will insert the pair
--   (key, value) into <tt>mp</tt> if key does not exist in the map. If the
--   key does exist, the function will insert the pair <tt>(key,f key
--   new_value old_value)</tt>. Note that the key passed to f is the same
--   key passed to <a>insertWithKey</a>.
--   
--   <pre>
--   let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
--   insertWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:xxx|a")]
--   insertWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a"), (7, "xxx")]
--   insertWithKey f 5 "xxx" empty                         == singleton 5 "xxx"
--   </pre>
insertWithKey :: TKey k => (k -> a -> a -> a) -> k -> a -> TMap k a -> TMap k a

-- | Combines insert operation with old value retrieval. The expression
--   (<tt><a>insertLookupWithKey</a> f k x map</tt>) is a pair where the
--   first element is equal to (<tt><a>lookup</a> k map</tt>) and the
--   second element equal to (<tt><a>insertWithKey</a> f k x map</tt>).
--   
--   <pre>
--   let f key new_value old_value = (show key) ++ ":" ++ new_value ++ "|" ++ old_value
--   insertLookupWithKey f 5 "xxx" (fromList [(5,"a"), (3,"b")]) == (Just "a", fromList [(3, "b"), (5, "5:xxx|a")])
--   insertLookupWithKey f 7 "xxx" (fromList [(5,"a"), (3,"b")]) == (Nothing,  fromList [(3, "b"), (5, "a"), (7, "xxx")])
--   insertLookupWithKey f 5 "xxx" empty                         == (Nothing,  singleton 5 "xxx")
--   </pre>
insertLookupWithKey :: TKey k => (k -> a -> a -> a) -> k -> a -> TMap k a -> (Maybe a, TMap k a)

-- | Delete a key and its value from the map. When the key is not a member
--   of the map, the original map is returned.
--   
--   <pre>
--   delete 5 (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   delete 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   delete 5 empty                         == empty
--   </pre>
delete :: TKey k => k -> TMap k a -> TMap k a

-- | Update a value at a specific key with the result of the provided
--   function. When the key is not a member of the map, the original map is
--   returned.
--   
--   <pre>
--   adjust ("new " ++) 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "new a")]
--   adjust ("new " ++) 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   adjust ("new " ++) 7 empty                         == empty
--   </pre>
adjust :: TKey k => (a -> a) -> k -> TMap k a -> TMap k a

-- | Adjust a value at a specific key. When the key is not a member of the
--   map, the original map is returned.
--   
--   <pre>
--   let f key x = (show key) ++ ":new " ++ x
--   adjustWithKey f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:new a")]
--   adjustWithKey f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   adjustWithKey f 7 empty                         == empty
--   </pre>
adjustWithKey :: TKey k => (k -> a -> a) -> k -> TMap k a -> TMap k a

-- | The expression (<tt><a>update</a> f k map</tt>) updates the value
--   <tt>x</tt> at <tt>k</tt> (if it is in the map). If (<tt>f x</tt>) is
--   <a>Nothing</a>, the element is deleted. If it is (<tt><a>Just</a>
--   y</tt>), the key <tt>k</tt> is bound to the new value <tt>y</tt>.
--   
--   <pre>
--   let f x = if x == "a" then Just "new a" else Nothing
--   update f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "new a")]
--   update f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   update f 3 (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
update :: TKey k => (a -> Maybe a) -> k -> TMap k a -> TMap k a

-- | The expression (<tt><a>updateWithKey</a> f k map</tt>) updates the
--   value <tt>x</tt> at <tt>k</tt> (if it is in the map). If (<tt>f k
--   x</tt>) is <a>Nothing</a>, the element is deleted. If it is
--   (<tt><a>Just</a> y</tt>), the key <tt>k</tt> is bound to the new value
--   <tt>y</tt>.
--   
--   <pre>
--   let f k x = if x == "a" then Just ((show k) ++ ":new a") else Nothing
--   updateWithKey f 5 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "5:new a")]
--   updateWithKey f 7 (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "a")]
--   updateWithKey f 3 (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
updateWithKey :: TKey k => (k -> a -> Maybe a) -> k -> TMap k a -> TMap k a

-- | The expression <tt>(<a>alter</a> f k map)</tt> alters the value
--   <tt>x</tt> at <tt>k</tt>, or absence thereof. <a>alter</a> can be used
--   to insert, delete, or update a value in a <a>TMap</a>. In short:
--   <tt><a>lookup</a> k (<a>alter</a> f k m) = f (<a>lookup</a> k m)</tt>.
alter :: TKey k => (Maybe a -> Maybe a) -> k -> TMap k a -> TMap k a

-- | The expression (<tt><a>union</a> t1 t2</tt>) takes the left-biased
--   union of <tt>t1</tt> and <tt>t2</tt>. It prefers <tt>t1</tt> when
--   duplicate keys are encountered, i.e. (<tt><a>union</a> ==
--   <a>unionWith</a> <a>const</a></tt>). The implementation uses the
--   efficient <i>hedge-union</i> algorithm. Hedge-union is more efficient
--   on (bigset `<a>union</a>` smallset).
--   
--   <pre>
--   union (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "a"), (7, "C")]
--   </pre>
union :: TKey k => TMap k a -> TMap k a -> TMap k a

-- | <i>O(n+m)</i>. Union with a combining function. The implementation
--   uses the efficient <i>hedge-union</i> algorithm.
--   
--   <pre>
--   unionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "aA"), (7, "C")]
--   </pre>
unionWith :: TKey k => (a -> a -> a) -> TMap k a -> TMap k a -> TMap k a
unionWithKey :: TKey k => (k -> a -> a -> a) -> TMap k a -> TMap k a -> TMap k a

-- | Union with a combining function. The implementation uses the efficient
--   <i>hedge-union</i> algorithm.
unionMaybeWith :: TKey k => (a -> a -> Maybe a) -> TMap k a -> TMap k a -> TMap k a

-- | Union with a combining function. The implementation uses the efficient
--   <i>hedge-union</i> algorithm. Hedge-union is more efficient on (bigset
--   `<a>union</a>` smallset).
--   
--   <pre>
--   let f key left_value right_value = Just ((show key) ++ ":" ++ left_value ++ "|" ++ right_value)
--   unionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == fromList [(3, "b"), (5, "5:a|A"), (7, "C")]
--   </pre>
unionMaybeWithKey :: TKey k => (k -> a -> a -> Maybe a) -> TMap k a -> TMap k a -> TMap k a

-- | <a>symmetricDifference</a> is equivalent to <tt><a>unionMaybeWith</a>
--   ( _ _ -&gt; Nothing)</tt>.
symmetricDifference :: TKey k => TMap k a -> TMap k a -> TMap k a

-- | Difference of two maps. Return elements of the first map not existing
--   in the second map. The implementation uses an efficient <i>hedge</i>
--   algorithm comparable with <i>hedge-union</i>.
--   
--   <pre>
--   difference (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 3 "b"
--   </pre>
difference :: TKey k => TMap k a -> TMap k b -> TMap k a

-- | Difference with a combining function. When two equal keys are
--   encountered, the combining function is applied to the values of these
--   keys. If it returns <a>Nothing</a>, the element is discarded (proper
--   set difference). If it returns (<tt><a>Just</a> y</tt>), the element
--   is updated with a new value <tt>y</tt>. The implementation uses an
--   efficient <i>hedge</i> algorithm comparable with <i>hedge-union</i>.
--   
--   <pre>
--   let f al ar = if al == "b" then Just (al ++ ":" ++ ar) else Nothing
--   differenceWith f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (7, "C")])
--       == singleton 3 "b:B"
--   </pre>
differenceWith :: TKey k => (a -> b -> Maybe a) -> TMap k a -> TMap k b -> TMap k a

-- | Difference with a combining function. When two equal keys are
--   encountered, the combining function is applied to the key and both
--   values. If it returns <a>Nothing</a>, the element is discarded (proper
--   set difference). If it returns (<tt><a>Just</a> y</tt>), the element
--   is updated with a new value <tt>y</tt>. The implementation uses an
--   efficient <i>hedge</i> algorithm comparable with <i>hedge-union</i>.
--   
--   <pre>
--   let f k al ar = if al == "b" then Just ((show k) ++ ":" ++ al ++ "|" ++ ar) else Nothing
--   differenceWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (3, "B"), (10, "C")])
--       == singleton 3 "3:b|B"
--   </pre>
differenceWithKey :: TKey k => (k -> a -> b -> Maybe a) -> TMap k a -> TMap k b -> TMap k a

-- | Intersection of two maps. Return data in the first map for the keys
--   existing in both maps. (<tt><a>intersection</a> m1 m2 ==
--   <a>intersectionWith</a> <a>const</a> m1 m2</tt>).
--   
--   <pre>
--   intersection (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "a"
--   </pre>
intersection :: TKey k => TMap k a -> TMap k b -> TMap k a

-- | Intersection with a combining function.
--   
--   <pre>
--   intersectionWith (++) (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "aA"
--   </pre>
intersectionWith :: TKey k => (a -> b -> c) -> TMap k a -> TMap k b -> TMap k c

-- | Intersection with a combining function. Intersection is more efficient
--   on (bigset `<a>intersection</a>` smallset).
--   
--   <pre>
--   let f k al ar = (show k) ++ ":" ++ al ++ "|" ++ ar
--   intersectionWithKey f (fromList [(5, "a"), (3, "b")]) (fromList [(5, "A"), (7, "C")]) == singleton 5 "5:a|A"
--   </pre>
intersectionWithKey :: TKey k => (k -> a -> b -> c) -> TMap k a -> TMap k b -> TMap k c

-- | <tt><a>intersectionMaybeWith</a> f m1 m2</tt> is equivalent to
--   <tt><a>mapMaybe</a> <a>id</a> (<a>intersectionWith</a> f m1 m2)</tt>.
intersectionMaybeWith :: TKey k => (a -> b -> Maybe c) -> TMap k a -> TMap k b -> TMap k c

-- | <tt><a>intersectionMaybeWithKey</a> f m1 m2</tt> is equivalent to
--   <tt><a>mapMaybe</a> <a>id</a> (<a>intersectionWithKey</a> f m1
--   m2)</tt>.
intersectionMaybeWithKey :: TKey k => (k -> a -> b -> Maybe c) -> TMap k a -> TMap k b -> TMap k c

-- | Map a function over all values in the map.
--   
--   <pre>
--   map (++ "x") (fromList [(5,"a"), (3,"b")]) == fromList [(3, "bx"), (5, "ax")]
--   </pre>
map :: TKey k => (a -> b) -> TMap k a -> TMap k b

-- | Map a function over all values in the map.
--   
--   <pre>
--   let f key x = (show key) ++ ":" ++ x
--   mapWithKey f (fromList [(5,"a"), (3,"b")]) == fromList [(3, "3:b"), (5, "5:a")]
--   </pre>
mapWithKey :: TKey k => (k -> a -> b) -> TMap k a -> TMap k b

-- | <tt><a>mapKeys</a> f s</tt> is the map obtained by applying <tt>f</tt>
--   to each key of <tt>s</tt>.
--   
--   The size of the result may be smaller if <tt>f</tt> maps two or more
--   distinct keys to the same new key. In this case the value at the
--   smallest of these keys is retained.
--   
--   <pre>
--   mapKeys (+ 1) (fromList [(5,"a"), (3,"b")])                        == fromList [(4, "b"), (6, "a")]
--   mapKeys (\ _ -&gt; 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 1 "c"
--   mapKeys (\ _ -&gt; 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 3 "c"
--   </pre>
mapKeys :: (TKey k, TKey k') => (k -> k') -> TMap k a -> TMap k' a

-- | <tt><a>mapKeysWith</a> c f s</tt> is the map obtained by applying
--   <tt>f</tt> to each key of <tt>s</tt>.
--   
--   The size of the result may be smaller if <tt>f</tt> maps two or more
--   distinct keys to the same new key. In this case the associated values
--   will be combined using <tt>c</tt>.
--   
--   <pre>
--   mapKeysWith (++) (\ _ -&gt; 1) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 1 "cdab"
--   mapKeysWith (++) (\ _ -&gt; 3) (fromList [(1,"b"), (2,"a"), (3,"d"), (4,"c")]) == singleton 3 "cdab"
--   </pre>
mapKeysWith :: (TKey k, TKey k') => (a -> a -> a) -> (k -> k') -> TMap k a -> TMap k' a

-- | <tt><a>mapKeysMonotonic</a> f s == <a>mapKeys</a> f s</tt>, but works
--   only when <tt>f</tt> is strictly monotonic. That is, for any values
--   <tt>x</tt> and <tt>y</tt>, if <tt>x</tt> &lt; <tt>y</tt> then <tt>f
--   x</tt> &lt; <tt>f y</tt>. <i>The precondition is not checked.</i>
--   Semi-formally, we have:
--   
--   <pre>
--   and [x &lt; y ==&gt; f x &lt; f y | x &lt;- ls, y &lt;- ls] 
--                       ==&gt; mapKeysMonotonic f s == mapKeys f s
--       where ls = keys s
--   </pre>
--   
--   This means that <tt>f</tt> maps distinct original keys to distinct
--   resulting keys. This function has better performance than
--   <a>mapKeys</a>.
--   
--   <pre>
--   mapKeysMonotonic (\ k -&gt; k * 2) (fromList [(5,"a"), (3,"b")]) == fromList [(6, "b"), (10, "a")]
--   </pre>
mapKeysMonotonic :: (TKey k, TKey k') => (k -> k') -> TMap k a -> TMap k' a

-- | Map each key/element pair to an action, evaluate these actions from
--   left to right, and collect the results.
traverseWithKey :: (TKey k, Applicative f) => (k -> a -> f b) -> TMap k a -> f (TMap k b)

-- | Post-order fold. The function will be applied from the lowest value to
--   the highest.
foldrWithKey :: TKey k => (k -> a -> b -> b) -> b -> TMap k a -> b

-- | Pre-order fold. The function will be applied from the highest value to
--   the lowest.
foldlWithKey :: TKey k => (b -> k -> a -> b) -> b -> TMap k a -> b

-- | The set of all keys of the map.
--   
--   <pre>
--   keysSet (fromList [(5,"a"), (3,"b")]) == Data.TrieSet.fromList [3,5]
--   keysSet empty == Data.TrieSet.empty
--   </pre>
keysSet :: TKey k => TMap k a -> TSet k

-- | Return all elements of the map in the ascending order of their keys.
--   
--   <pre>
--   elems (fromList [(5,"a"), (3,"b")]) == ["b","a"]
--   elems empty == []
--   </pre>
elems :: TKey k => TMap k a -> [a]

-- | Return all keys of the map in ascending order.
--   
--   <pre>
--   keys (fromList [(5,"a"), (3,"b")]) == [3,5]
--   keys empty == []
--   </pre>
keys :: TKey k => TMap k a -> [k]

-- | Return all key/value pairs in the map in ascending key order.
--   
--   <pre>
--   assocs (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
--   assocs empty == []
--   </pre>
assocs :: TKey k => TMap k a -> [(k, a)]

-- | Build a map from a list of key/value pairs. See also
--   <a>fromAscList</a>. If the list contains more than one value for the
--   same key, the last value for the key is retained.
--   
--   <pre>
--   fromList [] == empty
--   fromList [(5,"a"), (3,"b"), (5, "c")] == fromList [(5,"c"), (3,"b")]
--   fromList [(5,"c"), (3,"b"), (5, "a")] == fromList [(5,"a"), (3,"b")]
--   </pre>
fromList :: TKey k => [(k, a)] -> TMap k a

-- | Build a map from a list of key/value pairs with a combining function.
--   See also <a>fromAscListWith</a>.
--   
--   <pre>
--   fromListWith (++) [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"a")] == fromList [(3, "ab"), (5, "aba")]
--   fromListWith (++) [] == empty
--   </pre>
fromListWith :: TKey k => (a -> a -> a) -> [(k, a)] -> TMap k a

-- | Build a map from a list of key/value pairs with a combining function.
--   See also <a>fromAscListWith</a>.
--   
--   <pre>
--   fromListWith (++) [(5,"a"), (5,"b"), (3,"b"), (3,"a"), (5,"a")] == fromList [(3, "ab"), (5, "aba")]
--   fromListWith (++) [] == empty
--   </pre>
fromListWithKey :: TKey k => (k -> a -> a -> a) -> [(k, a)] -> TMap k a

-- | Return all elements of the map in the ascending order of their keys.
--   Does not currently fuse.
elemsVector :: (TKey k, Vector v a) => TMap k a -> v a

-- | Return all keys of the map in ascending order. Does not currently
--   fuse.
keysVector :: (TKey k, Vector v k) => TMap k a -> v k

-- | Return all key/value pairs in the map in ascending key order. Does not
--   currently fuse.
assocsVector :: (TKey k, Vector v (k, a)) => TMap k a -> v (k, a)

-- | Equivalent to <tt><a>fromList</a> (<a>toList</a> xs)</tt>.
fromVector :: (TKey k, Vector v (k, a)) => v (k, a) -> TMap k a

-- | Equivalent to <tt><a>fromListWith</a> f (<a>toList</a> xs)</tt>.
fromVectorWith :: (TKey k, Vector v (k, a)) => (a -> a -> a) -> v (k, a) -> TMap k a

-- | Equivalent to <tt><a>fromListWithKey</a> f (<a>toList</a> xs)</tt>.
fromVectorWithKey :: (TKey k, Vector v (k, a)) => (k -> a -> a -> a) -> v (k, a) -> TMap k a

-- | Build a map from an ascending list in linear time. <i>The precondition
--   (input list is ascending) is not checked.</i>
--   
--   <pre>
--   fromAscList [(3,"b"), (5,"a")]          == fromList [(3, "b"), (5, "a")]
--   fromAscList [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "b")]
--   </pre>
fromAscList :: TKey k => [(k, a)] -> TMap k a

-- | Build a map from an ascending list in linear time with a combining
--   function for equal keys. <i>The precondition (input list is ascending)
--   is not checked.</i>
--   
--   <pre>
--   fromAscListWith (++) [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "ba")]
--   </pre>
fromAscListWith :: TKey k => (a -> a -> a) -> [(k, a)] -> TMap k a

-- | Build a map from an ascending list in linear time. <i>The precondition
--   (input list is ascending) is not checked.</i>
--   
--   <pre>
--   fromAscList [(3,"b"), (5,"a")]          == fromList [(3, "b"), (5, "a")]
--   fromAscList [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "b")]
--   </pre>
fromAscListWithKey :: TKey k => (k -> a -> a -> a) -> [(k, a)] -> TMap k a

-- | Build a map from an ascending list of distinct elements in linear
--   time. <i>The precondition is not checked.</i>
--   
--   <pre>
--   fromDistinctAscList [(3,"b"), (5,"a")] == fromList [(3, "b"), (5, "a")]
--   </pre>
fromDistinctAscList :: TKey k => [(k, a)] -> TMap k a

-- | Equivalent to <tt><a>fromAscList</a> (<a>toList</a> xs)</tt>.
fromAscVector :: (TKey k, Vector v (k, a)) => v (k, a) -> TMap k a

-- | Equivalent to <tt><a>fromAscListWith</a> f (<a>toList</a> xs)</tt>.
fromAscVectorWith :: (TKey k, Vector v (k, a)) => (a -> a -> a) -> v (k, a) -> TMap k a

-- | Equivalent to <tt><a>fromAscListWithKey</a> f (<a>toList</a> xs)</tt>.
fromAscVectorWithKey :: (TKey k, Vector v (k, a)) => (k -> a -> a -> a) -> v (k, a) -> TMap k a

-- | Equivalent to <tt><a>fromDistinctAscList</a> (<a>toList</a> xs)</tt>.
fromDistinctAscVector :: (TKey k, Vector v (k, a)) => v (k, a) -> TMap k a

-- | Filter all values that satisfy the predicate.
--   
--   <pre>
--   filter (&gt; "a") (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   filter (&gt; "x") (fromList [(5,"a"), (3,"b")]) == empty
--   filter (&lt; "a") (fromList [(5,"a"), (3,"b")]) == empty
--   </pre>
filter :: TKey k => (a -> Bool) -> TMap k a -> TMap k a

-- | Filter all keys/values that satisfy the predicate.
--   
--   <pre>
--   filterWithKey (\k _ -&gt; k &gt; 4) (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
filterWithKey :: TKey k => (k -> a -> Bool) -> TMap k a -> TMap k a

-- | Partition the map according to a predicate. The first map contains all
--   elements that satisfy the predicate, the second all elements that fail
--   the predicate. See also <a>split</a>.
--   
--   <pre>
--   partition (&gt; "a") (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", singleton 5 "a")
--   partition (&lt; "x") (fromList [(5,"a"), (3,"b")]) == (fromList [(3, "b"), (5, "a")], empty)
--   partition (&gt; "x") (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3, "b"), (5, "a")])
--   </pre>
partition :: TKey k => (a -> Bool) -> TMap k a -> (TMap k a, TMap k a)

-- | Partition the map according to a predicate. The first map contains all
--   elements that satisfy the predicate, the second all elements that fail
--   the predicate. See also <a>split</a>.
--   
--   <pre>
--   partition (&gt; "a") (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", singleton 5 "a")
--   partition (&lt; "x") (fromList [(5,"a"), (3,"b")]) == (fromList [(3, "b"), (5, "a")], empty)
--   partition (&gt; "x") (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3, "b"), (5, "a")])
--   </pre>
partitionWithKey :: TKey k => (k -> a -> Bool) -> TMap k a -> (TMap k a, TMap k a)

-- | <i>O(n)</i>. Map values and collect the <a>Just</a> results.
--   
--   <pre>
--   let f x = if x == "a" then Just "new a" else Nothing
--   mapMaybe f (fromList [(5,"a"), (3,"b")]) == singleton 5 "new a"
--   </pre>
mapMaybe :: TKey k => (a -> Maybe b) -> TMap k a -> TMap k b

-- | Map keys/values and collect the <a>Just</a> results.
--   
--   <pre>
--   let f k _ = if k &lt; 5 then Just ("key : " ++ (show k)) else Nothing
--   mapMaybeWithKey f (fromList [(5,"a"), (3,"b")]) == singleton 3 "key : 3"
--   </pre>
mapMaybeWithKey :: TKey k => (k -> a -> Maybe b) -> TMap k a -> TMap k b

-- | Map values and separate the <a>Left</a> and <a>Right</a> results.
--   
--   <pre>
--   let f a = if a &lt; "c" then Left a else Right a
--   mapEither f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (fromList [(3,"b"), (5,"a")], fromList [(1,"x"), (7,"z")])
--   
--   mapEither (\ a -&gt; Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (empty, fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--   </pre>
mapEither :: TKey k => (a -> Either b c) -> TMap k a -> (TMap k b, TMap k c)

-- | Map keys/values and separate the <a>Left</a> and <a>Right</a> results.
--   
--   <pre>
--   let f k a = if k &lt; 5 then Left (k * 2) else Right (a ++ a)
--   mapEitherWithKey f (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (fromList [(1,2), (3,6)], fromList [(5,"aa"), (7,"zz")])
--   
--   mapEitherWithKey (\_ a -&gt; Right a) (fromList [(5,"a"), (3,"b"), (1,"x"), (7,"z")])
--       == (empty, fromList [(1,"x"), (3,"b"), (5,"a"), (7,"z")])
--   </pre>
mapEitherWithKey :: TKey k => (k -> a -> Either b c) -> TMap k a -> (TMap k b, TMap k c)

-- | The expression (<tt><a>split</a> k map</tt>) is a pair
--   <tt>(map1,map2)</tt> where the keys in <tt>map1</tt> are smaller than
--   <tt>k</tt> and the keys in <tt>map2</tt> larger than <tt>k</tt>. Any
--   key equal to <tt>k</tt> is found in neither <tt>map1</tt> nor
--   <tt>map2</tt>.
--   
--   <pre>
--   split 2 (fromList [(5,"a"), (3,"b")]) == (empty, fromList [(3,"b"), (5,"a")])
--   split 3 (fromList [(5,"a"), (3,"b")]) == (empty, singleton 5 "a")
--   split 4 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", singleton 5 "a")
--   split 5 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", empty)
--   split 6 (fromList [(5,"a"), (3,"b")]) == (fromList [(3,"b"), (5,"a")], empty)
--   </pre>
split :: TKey k => k -> TMap k a -> (TMap k a, TMap k a)

-- | The expression (<tt><a>splitLookup</a> k map</tt>) splits a map just
--   like <a>split</a> but also returns <tt><a>lookup</a> k map</tt>.
--   
--   <pre>
--   splitLookup 2 (fromList [(5,"a"), (3,"b")]) == (empty, Nothing, fromList [(3,"b"), (5,"a")])
--   splitLookup 3 (fromList [(5,"a"), (3,"b")]) == (empty, Just "b", singleton 5 "a")
--   splitLookup 4 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", Nothing, singleton 5 "a")
--   splitLookup 5 (fromList [(5,"a"), (3,"b")]) == (singleton 3 "b", Just "a", empty)
--   splitLookup 6 (fromList [(5,"a"), (3,"b")]) == (fromList [(3,"b"), (5,"a")], Nothing, empty)
--   </pre>
splitLookup :: TKey k => k -> TMap k a -> (TMap k a, Maybe a, TMap k a)

-- | This function is defined as (<tt><a>isSubmapOf</a> =
--   <a>isSubmapOfBy</a> (==)</tt>).
isSubmapOf :: (TKey k, Eq a) => TMap k a -> TMap k a -> Bool

-- | The expression (<tt><a>isSubmapOfBy</a> f t1 t2</tt>) returns
--   <a>True</a> if all keys in <tt>t1</tt> are in tree <tt>t2</tt>, and
--   when <tt>f</tt> returns <a>True</a> when applied to their respective
--   values. For example, the following expressions are all <a>True</a>:
--   
--   <pre>
--   isSubmapOfBy (==) (fromList [('a',1)]) (fromList [('a',1),('b',2)])
--   isSubmapOfBy (&lt;=) (fromList [('a',1)]) (fromList [('a',1),('b',2)])
--   isSubmapOfBy (==) (fromList [('a',1),('b',2)]) (fromList [('a',1),('b',2)])
--   </pre>
--   
--   But the following are all <a>False</a>:
--   
--   <pre>
--   isSubmapOfBy (==) (fromList [('a',2)]) (fromList [('a',1),('b',2)])
--   isSubmapOfBy (&lt;)  (fromList [('a',1)]) (fromList [('a',1),('b',2)])
--   isSubmapOfBy (==) (fromList [('a',1),('b',2)]) (fromList [('a',1)])
--   </pre>
isSubmapOfBy :: TKey k => (a -> b -> Bool) -> TMap k a -> TMap k b -> Bool

-- | Lookup the <i>index</i> of a key. The index is a number from <i>0</i>
--   up to, but not including, the <a>size</a> of the map.
--   
--   <pre>
--   lookupIndex 2 (fromList [(5,"a"), (3,"b")]) == Nothing
--   lookupIndex 3 (fromList [(5,"a"), (3,"b")]) == Just 0
--   lookupIndex 5 (fromList [(5,"a"), (3,"b")]) == Just 1
--   lookupIndex 6 (fromList [(5,"a"), (3,"b")]) == Nothing
--   </pre>
lookupIndex :: TKey k => k -> TMap k a -> Maybe Int

-- | Return the <i>index</i> of a key. The index is a number from <i>0</i>
--   up to, but not including, the <a>size</a> of the map. Calls
--   <a>error</a> when the key is not a <a>member</a> of the map.
--   
--   <pre>
--   findIndex 2 (fromList [(5,"a"), (3,"b")])    Error: element is not in the map
--   findIndex 3 (fromList [(5,"a"), (3,"b")]) == 0
--   findIndex 5 (fromList [(5,"a"), (3,"b")]) == 1
--   findIndex 6 (fromList [(5,"a"), (3,"b")])    Error: element is not in the map
--   </pre>
findIndex :: TKey k => k -> TMap k a -> Int

-- | Retrieve an element by <i>index</i>. Calls <a>error</a> when an
--   invalid index is used.
--   
--   <pre>
--   elemAt 0 (fromList [(5,"a"), (3,"b")]) == (3,"b")
--   elemAt 1 (fromList [(5,"a"), (3,"b")]) == (5, "a")
--   elemAt 2 (fromList [(5,"a"), (3,"b")])    Error: index out of range
--   </pre>
elemAt :: TKey k => Int -> TMap k a -> (k, a)

-- | Update the element at <i>index</i>. Calls <a>error</a> when an invalid
--   index is used.
--   
--   <pre>
--   updateAt (\ _ _ -&gt; Just "x") 0    (fromList [(5,"a"), (3,"b")]) == fromList [(3, "x"), (5, "a")]
--   updateAt (\ _ _ -&gt; Just "x") 1    (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "x")]
--   updateAt (\ _ _ -&gt; Just "x") 2    (fromList [(5,"a"), (3,"b")])    Error: index out of range
--   updateAt (\ _ _ -&gt; Just "x") (-1) (fromList [(5,"a"), (3,"b")])    Error: index out of range
--   updateAt (\_ _  -&gt; Nothing)  0    (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   updateAt (\_ _  -&gt; Nothing)  1    (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   updateAt (\_ _  -&gt; Nothing)  2    (fromList [(5,"a"), (3,"b")])    Error: index out of range
--   updateAt (\_ _  -&gt; Nothing)  (-1) (fromList [(5,"a"), (3,"b")])    Error: index out of range
--   </pre>
updateAt :: TKey k => (k -> a -> Maybe a) -> Int -> TMap k a -> TMap k a

-- | Delete the element at <i>index</i>. Defined as (<tt><a>deleteAt</a> i
--   map = <a>updateAt</a> (k x -&gt; <a>Nothing</a>) i map</tt>).
--   
--   <pre>
--   deleteAt 0  (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   deleteAt 1  (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   deleteAt 2 (fromList [(5,"a"), (3,"b")])     Error: index out of range
--   deleteAt (-1) (fromList [(5,"a"), (3,"b")])  Error: index out of range
--   </pre>
deleteAt :: TKey k => Int -> TMap k a -> TMap k a

-- | The minimal key of the map. Calls <a>error</a> if the map is empty.
--   
--   <pre>
--   findMin (fromList [(5,"a"), (3,"b")]) == (3,"b")
--   findMin empty                            Error: empty map has no minimal element
--   </pre>
findMin :: TKey k => TMap k a -> (k, a)

-- | The maximal key of the map. Calls <a>error</a> if the map is empty.
--   
--   <pre>
--   findMax (fromList [(5,"a"), (3,"b")]) == (5,"a")
--   findMax empty                            Error: empty map has no maximal element
--   </pre>
findMax :: TKey k => TMap k a -> (k, a)

-- | Delete the minimal key. Returns an empty map if the map is empty.
--   
--   <pre>
--   deleteMin (fromList [(5,"a"), (3,"b"), (7,"c")]) == fromList [(5,"a"), (7,"c")]
--   deleteMin empty == empty
--   </pre>
deleteMin :: TKey k => TMap k a -> TMap k a

-- | Delete the maximal key. Returns an empty map if the map is empty.
--   
--   <pre>
--   deleteMax (fromList [(5,"a"), (3,"b"), (7,"c")]) == fromList [(3,"b"), (5,"a")]
--   deleteMax empty == empty
--   </pre>
deleteMax :: TKey k => TMap k a -> TMap k a

-- | Delete and find the minimal element.
--   
--   <pre>
--   deleteFindMin (fromList [(5,"a"), (3,"b"), (10,"c")]) == ((3,"b"), fromList[(5,"a"), (10,"c")]) 
--   deleteFindMin                                            Error: can not return the minimal element of an empty map
--   </pre>
deleteFindMin :: TKey k => TMap k a -> ((k, a), TMap k a)

-- | Delete and find the maximal element.
--   
--   <pre>
--   deleteFindMax (fromList [(5,"a"), (3,"b"), (10,"c")]) == ((10,"c"), fromList[(3,"b"),(5,"a")]) 
--   deleteFindMax                                            Error: can not return the maximal element of an empty map
--   </pre>
deleteFindMax :: TKey k => TMap k a -> ((k, a), TMap k a)

-- | Update the value at the minimal key.
--   
--   <pre>
--   updateMin (\ a -&gt; Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3, "Xb"), (5, "a")]
--   updateMin (\ _ -&gt; Nothing)         (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
updateMin :: TKey k => (a -> Maybe a) -> TMap k a -> TMap k a

-- | Update the value at the maximal key.
--   
--   <pre>
--   updateMax (\ a -&gt; Just ("X" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3, "b"), (5, "Xa")]
--   updateMax (\ _ -&gt; Nothing)         (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   </pre>
updateMax :: TKey k => (a -> Maybe a) -> TMap k a -> TMap k a

-- | Update the value at the minimal key.
--   
--   <pre>
--   updateMinWithKey (\ k a -&gt; Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3,"3:b"), (5,"a")]
--   updateMinWithKey (\ _ _ -&gt; Nothing)                     (fromList [(5,"a"), (3,"b")]) == singleton 5 "a"
--   </pre>
updateMinWithKey :: TKey k => (k -> a -> Maybe a) -> TMap k a -> TMap k a

-- | Update the value at the maximal key.
--   
--   <pre>
--   updateMaxWithKey (\ k a -&gt; Just ((show k) ++ ":" ++ a)) (fromList [(5,"a"), (3,"b")]) == fromList [(3,"b"), (5,"5:a")]
--   updateMaxWithKey (\ _ _ -&gt; Nothing)                     (fromList [(5,"a"), (3,"b")]) == singleton 3 "b"
--   </pre>
updateMaxWithKey :: TKey k => (k -> a -> Maybe a) -> TMap k a -> TMap k a

-- | Retrieves the value associated with minimal key of the map, and the
--   map stripped of that element, or <a>Nothing</a> if passed an empty
--   map.
--   
--   <pre>
--   minView (fromList [(5,"a"), (3,"b")]) == Just ("b", singleton 5 "a")
--   minView empty == Nothing
--   </pre>
minView :: TKey k => TMap k a -> Maybe (a, TMap k a)

-- | Retrieves the value associated with maximal key of the map, and the
--   map stripped of that element, or <a>Nothing</a> if passed an
--   
--   <pre>
--   maxView (fromList [(5,"a"), (3,"b")]) == Just ("a", singleton 3 "b")
--   maxView empty == Nothing
--   </pre>
maxView :: TKey k => TMap k a -> Maybe (a, TMap k a)

-- | Retrieves the minimal (key,value) pair of the map, and the map
--   stripped of that element, or <a>Nothing</a> if passed an empty map.
--   
--   <pre>
--   minViewWithKey (fromList [(5,"a"), (3,"b")]) == Just ((3,"b"), singleton 5 "a")
--   minViewWithKey empty == Nothing
--   </pre>
minViewWithKey :: TKey k => TMap k a -> Maybe ((k, a), TMap k a)

-- | <i>O(log n)</i>. Retrieves the maximal (key,value) pair of the map,
--   and the map stripped of that element, or <a>Nothing</a> if passed an
--   empty map.
--   
--   <pre>
--   maxViewWithKey (fromList [(5,"a"), (3,"b")]) == Just ((5,"a"), singleton 3 "b")
--   maxViewWithKey empty == Nothing
--   </pre>
maxViewWithKey :: TKey k => TMap k a -> Maybe ((k, a), TMap k a)
instance TKey k => Monoid (TMap k a)
instance (Ord k, TKey k, Ord a) => Ord (TMap k a)
instance (Eq k, TKey k, Eq a) => Eq (TMap k a)
instance (Show k, Show a, TKey k) => Show (TMap k a)
