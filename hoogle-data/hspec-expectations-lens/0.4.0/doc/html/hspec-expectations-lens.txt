-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Hspec expectations for the lens stuff
--   
--   Package adds hspec expectations (<tt>`shouldX`</tt> things) that work
--   nicely with the "lens" library
@package hspec-expectations-lens
@version 0.4.0


-- | Hspec expectations for the lens stuff
module Test.Hspec.Expectations.Lens

-- | <tt>s `shouldHave` l</tt> sets the expectation that <a>Fold</a>
--   <tt>l</tt> has non-zero number of targets in the structure <tt>s</tt>
--   
--   <pre>
--   s `shouldBe` t ≡ s `shouldHave` only t
--   </pre>
--   
--   <pre>
--   shouldHave :: <a>Show</a> s =&gt; s -&gt; <a>Getter</a>     s a -&gt; <a>Expectation</a>
--   shouldHave :: <a>Show</a> s =&gt; s -&gt; <a>Fold</a>       s a -&gt; <a>Expectation</a>
--   shouldHave :: <a>Show</a> s =&gt; s -&gt; <a>Iso'</a>       s a -&gt; <a>Expectation</a>
--   shouldHave :: <a>Show</a> s =&gt; s -&gt; <a>Lens'</a>      s a -&gt; <a>Expectation</a>
--   shouldHave :: <a>Show</a> s =&gt; s -&gt; <a>Traversal'</a> s a -&gt; <a>Expectation</a>
--   shouldHave :: <a>Show</a> s =&gt; s -&gt; <a>Prism'</a>     s a -&gt; <a>Expectation</a>
--   </pre>
shouldHave :: Show s => s -> Getting Any s a -> Expectation

-- | <tt>s `shouldNotHave` l</tt> sets the expectation that <a>Fold</a>
--   <tt>l</tt> has exactly zero targets in the structue <tt>s</tt>
--   
--   <pre>
--   shouldNotHave :: <a>Show</a> s =&gt; s -&gt; <a>Getter</a>     s a -&gt; <a>Expectation</a>
--   shouldNotHave :: <a>Show</a> s =&gt; s -&gt; <a>Fold</a>       s a -&gt; <a>Expectation</a>
--   shouldNotHave :: <a>Show</a> s =&gt; s -&gt; <a>Iso'</a>       s a -&gt; <a>Expectation</a>
--   shouldNotHave :: <a>Show</a> s =&gt; s -&gt; <a>Lens'</a>      s a -&gt; <a>Expectation</a>
--   shouldNotHave :: <a>Show</a> s =&gt; s -&gt; <a>Traversal'</a> s a -&gt; <a>Expectation</a>
--   shouldNotHave :: <a>Show</a> s =&gt; s -&gt; <a>Prism'</a>     s a -&gt; <a>Expectation</a>
--   </pre>
shouldNotHave :: Show s => s -> Getting All s a -> Expectation

-- | <tt>s `shouldView` t `through` l</tt> sets the expectation that you
--   can see target <tt>t</tt> in the structure <tt>s</tt> though a
--   <a>Getter</a> <tt>l</tt>
--   
--   <pre>
--   shouldView ::           (<a>Show</a> s, <a>Show</a> a, <a>Eq</a> a) =&gt; s -&gt; a -&gt; <a>Getter</a>     s a -&gt; <a>Expectation</a>
--   shouldView :: (<a>Monoid</a> m, <a>Show</a> s, <a>Show</a> a, <a>Eq</a> a) =&gt; s -&gt; a -&gt; <a>Fold</a>       s m -&gt; <a>Expectation</a>
--   shouldView ::           (<a>Show</a> s, <a>Show</a> a, <a>Eq</a> a) =&gt; s -&gt; a -&gt; <a>Iso'</a>       s a -&gt; <a>Expectation</a>
--   shouldView ::           (<a>Show</a> s, <a>Show</a> a, <a>Eq</a> a) =&gt; s -&gt; a -&gt; <a>Lens'</a>      s a -&gt; <a>Expectation</a>
--   shouldView :: (<a>Monoid</a> m, <a>Show</a> s, <a>Show</a> a, <a>Eq</a> a) =&gt; s -&gt; a -&gt; <a>Traversal'</a> s m -&gt; <a>Expectation</a>
--   shouldView :: (<a>Monoid</a> m, <a>Show</a> s, <a>Show</a> a, <a>Eq</a> a) =&gt; s -&gt; a -&gt; <a>Prism'</a>     s m -&gt; <a>Expectation</a>
--   </pre>
shouldView :: (Show s, Show a, Eq a) => s -> a -> Getting a s a -> Expectation

-- | <tt>s `shouldPreview` t `through` l</tt> sets the expectation that you
--   <tt>y</tt> is the first target of the <a>Fold</a> <tt>l</tt> in
--   <tt>s</tt>
--   
--   <pre>
--   shouldPreview :: (<a>Show</a> s, <a>Show</a> a, <a>Eq</a> a) =&gt; s -&gt; a -&gt; <a>Getter</a>     s a -&gt; <a>Expectation</a>
--   shouldPreview :: (<a>Show</a> s, <a>Show</a> a, <a>Eq</a> a) =&gt; s -&gt; a -&gt; <a>Fold</a>       s a -&gt; <a>Expectation</a>
--   shouldPreview :: (<a>Show</a> s, <a>Show</a> a, <a>Eq</a> a) =&gt; s -&gt; a -&gt; <a>Lens'</a>      s a -&gt; <a>Expectation</a>
--   shouldPreview :: (<a>Show</a> s, <a>Show</a> a, <a>Eq</a> a) =&gt; s -&gt; a -&gt; <a>Iso'</a>       s a -&gt; <a>Expectation</a>
--   shouldPreview :: (<a>Show</a> s, <a>Show</a> a, <a>Eq</a> a) =&gt; s -&gt; a -&gt; <a>Traversal'</a> s a -&gt; <a>Expectation</a>
--   shouldPreview :: (<a>Show</a> s, <a>Show</a> a, <a>Eq</a> a) =&gt; s -&gt; a -&gt; <a>Prism'</a>     s a -&gt; <a>Expectation</a>
--   </pre>
shouldPreview :: (Show s, Show a, Eq a) => s -> a -> Getting (First a) s a -> Expectation

-- | <tt>s `shouldList` ts `through` l</tt> sets the expectation that
--   <tt>ts</tt> is a list of the Fold <tt>l</tt> targets in <tt>x</tt>
--   
--   <pre>
--   shouldList :: (<a>Show</a> s, <a>Show</a> a, <a>Eq</a> a) =&gt; s -&gt; [a] -&gt; <a>Getter</a>     s a -&gt; <a>Expectation</a>
--   shouldList :: (<a>Show</a> s, <a>Show</a> a, <a>Eq</a> a) =&gt; s -&gt; [a] -&gt; <a>Fold</a>       s a -&gt; <a>Expectation</a>
--   shouldList :: (<a>Show</a> s, <a>Show</a> a, <a>Eq</a> a) =&gt; s -&gt; [a] -&gt; <a>Lens'</a>      s a -&gt; <a>Expectation</a>
--   shouldList :: (<a>Show</a> s, <a>Show</a> a, <a>Eq</a> a) =&gt; s -&gt; [a] -&gt; <a>Iso'</a>       s a -&gt; <a>Expectation</a>
--   shouldList :: (<a>Show</a> s, <a>Show</a> a, <a>Eq</a> a) =&gt; s -&gt; [a] -&gt; <a>Traversal'</a> s a -&gt; <a>Expectation</a>
--   shouldList :: (<a>Show</a> s, <a>Show</a> a, <a>Eq</a> a) =&gt; s -&gt; [a] -&gt; <a>Prism'</a>     s a -&gt; <a>Expectation</a>
--   </pre>
shouldList :: (Show s, Show a, Eq a) => s -> [a] -> Getting (Endo [a]) s a -> Expectation

-- | <tt>a `shouldThrow` l</tt> sets the expectation that <tt>a</tt> throws
--   an exception that <a>Fold</a> <tt>l</tt> can catch
--   
--   <a>Test.Hspec</a> exports <a>shouldThrow</a> too; it only allows <tt>e
--   -&gt; Bool</tt> selectors, which is less general and often less
--   convenient
--   
--   <pre>
--   shouldThrow :: <a>IO</a> a -&gt; <a>Getter</a>     <a>SomeException</a> b -&gt; <a>Expectation</a>
--   shouldThrow :: <a>IO</a> a -&gt; <a>Fold</a>       <a>SomeException</a> b -&gt; <a>Expectation</a>
--   shouldThrow :: <a>IO</a> a -&gt; <a>Lens'</a>      <a>SomeException</a> b -&gt; <a>Expectation</a>
--   shouldThrow :: <a>IO</a> a -&gt; <a>Iso'</a>       <a>SomeException</a> b -&gt; <a>Expectation</a>
--   shouldThrow :: <a>IO</a> a -&gt; <a>Traversal'</a> <a>SomeException</a> b -&gt; <a>Expectation</a>
--   shouldThrow :: <a>IO</a> a -&gt; <a>Prism'</a>     <a>SomeException</a> b -&gt; <a>Expectation</a>
--   </pre>
shouldThrow :: IO a -> Getting (First b) SomeException b -> Expectation

-- | <a>through</a> fights parentheses
--   
--   <pre>
--   through ≡ id
--   </pre>
--   
--   <pre>
--   through :: <a>Int</a> -&gt; <a>Int</a>
--   through :: <a>Char</a> -&gt; <a>Char</a>
--   </pre>
through :: a -> a


-- | Module is designed to be conveniently imported instead of
--   <a>Test.Hspec</a>
--   
--   It reexports <a>Test.Hspec</a> without expectations (except for
--   <a>shouldBe</a>) and <a>Test.Hspec.Expectations.Lens</a> expectations
module Test.Hspec.Lens
type Spec = SpecWith ()

-- | A type class for examples
class Example e

-- | <tt>actual `shouldBe` expected</tt> sets the expectation that
--   <tt>actual</tt> is equal to <tt>expected</tt> (this is just an alias
--   for <a>@?=</a>).
shouldBe :: (Show a, Eq a) => a -> a -> Expectation

-- | The <tt>describe</tt> function combines a list of specs into a larger
--   spec.
describe :: String -> SpecWith a -> SpecWith a

-- | <tt>context</tt> is an alias for <a>describe</a>.
context :: String -> SpecWith a -> SpecWith a

-- | The <tt>it</tt> function creates a spec item.
--   
--   A spec item consists of:
--   
--   <ul>
--   <li>a textual description of a desired behavior</li>
--   <li>an example for that behavior</li>
--   </ul>
--   
--   <pre>
--   describe "absolute" $ do
--     it "returns a positive number when given a negative number" $
--       absolute (-1) == 1
--   </pre>
it :: Example a => String -> a -> SpecWith (Arg a)

-- | <tt>example</tt> is a type restricted version of <a>id</a>. It can be
--   used to get better error messages on type mismatches.
--   
--   Compare e.g.
--   
--   <pre>
--   it "exposes some behavior" $ example $ do
--     putStrLn
--   </pre>
--   
--   with
--   
--   <pre>
--   it "exposes some behavior" $ do
--     putStrLn
--   </pre>
example :: Expectation -> Expectation

-- | <a>pending</a> can be used to indicate that an example is
--   <i>pending</i>.
--   
--   If you want to textually specify a behavior but do not have an example
--   yet, use this:
--   
--   <pre>
--   describe "fancyFormatter" $ do
--     it "can format text in a way that everyone likes" $
--       pending
--   </pre>
pending :: Expectation

-- | <a>pendingWith</a> is similar to <a>pending</a>, but it takes an
--   additional string argument that can be used to specify the reason for
--   why it's pending.
pendingWith :: String -> Expectation

-- | Run a custom action before every spec item.
before :: IO a -> SpecWith a -> Spec

-- | Run a custom action after every spec item.
after :: ActionWith a -> SpecWith a -> SpecWith a

-- | Run a custom action before and/or after every spec item.
around :: (ActionWith a -> IO ()) -> SpecWith a -> Spec

-- | <a>parallel</a> marks all spec items of the given spec to be safe for
--   parallel evaluation.
parallel :: SpecWith a -> SpecWith a

-- | Run given spec and write a report to <a>stdout</a>. Exit with
--   <a>exitFailure</a> if at least one spec item fails.
hspec :: Spec -> IO ()
