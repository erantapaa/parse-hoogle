-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Push-pull implementation of discrete-time FRP
--   
--   This is an FRP library with the following characteristics:
--   
--   <ul>
--   <li>classical: it has first-class signals</li>
--   <li>synchronous: it has a clear notion of simultaneous events</li>
--   <li>higher-order: signals inside signals can be flattened to get a
--   switching behavior</li>
--   <li>push-based: inactive events has zero runtime costs</li>
--   </ul>
--   
--   This package is in the alpha stage.
@package ordrea
@version 0.3.0.0

module FRP.Ordrea
data SignalGen a
data Behavior a
data Event a
data Discrete a

-- | Push-based asynchronous events.
data ExternalEvent a
newExternalEvent :: IO (ExternalEvent a)
triggerExternalEvent :: ExternalEvent a -> a -> IO ()
generatorE :: Event (SignalGen a) -> SignalGen (Event a)
filterE :: (a -> Bool) -> Event a -> Event a
stepClockE :: Event ()
dropStepE :: Event a -> SignalGen (Event a)
eventFromList :: [[a]] -> SignalGen (Event a)
scanE :: a -> Event (a -> a) -> SignalGen (Event a)
mapAccumE :: s -> Event (s -> (s, a)) -> SignalGen (Event a)
mapAccumEM :: s -> Event (s -> SignalGen (s, a)) -> SignalGen (Event a)

-- | <i>Deprecated: accumE has been renamed to scanE </i>
accumE :: a -> Event (a -> a) -> SignalGen (Event a)

-- | <i>Deprecated: scanAccumE has been renamed to mapAccumE </i>
scanAccumE :: s -> Event (s -> (s, a)) -> SignalGen (Event a)

-- | <i>Deprecated: scanAccumEM has been renamed to mapAccumEM </i>
scanAccumEM :: s -> Event (s -> SignalGen (s, a)) -> SignalGen (Event a)
mapMaybeE :: (a -> Maybe b) -> Event a -> Event b
justE :: Event (Maybe a) -> Event a
flattenE :: Event [a] -> Event a
expandE :: Event a -> Event [a]

-- | Create a new event that occurs every time the given external event
--   occurs.
externalE :: ExternalEvent a -> SignalGen (Event a)
takeWhileE :: (a -> Bool) -> Event a -> SignalGen (Event a)

-- | <tt>delayE evt</tt> creates an event whose occurrences at step N is
--   equal to the ocurrences of <tt>evt</tt> at step N-1.
delayE :: Event a -> SignalGen (Event a)
withPrevE :: a -> Event a -> SignalGen (Event (a, a))
dropE :: Int -> Event a -> SignalGen (Event a)
dropWhileE :: (a -> Bool) -> Event a -> SignalGen (Event a)
takeE :: Int -> Event a -> SignalGen (Event a)
partitionEithersE :: Event (Either a b) -> (Event a, Event b)
leftsE :: Event (Either a b) -> Event a
rightsE :: Event (Either a b) -> Event b
joinDD :: Discrete (Discrete a) -> SignalGen (Discrete a)
joinDE :: Discrete (Event a) -> SignalGen (Event a)
joinDB :: Discrete (Behavior a) -> SignalGen (Behavior a)
start :: SignalGen (Behavior a) -> IO (IO a)
externalB :: IO a -> SignalGen (Behavior a)
joinB :: Behavior (Behavior a) -> SignalGen (Behavior a)
delayB :: a -> Behavior a -> SignalGen (Behavior a)
behaviorFromList :: [a] -> SignalGen (Behavior a)
networkToList :: Int -> SignalGen (Behavior a) -> IO [a]
networkToListGC :: Int -> SignalGen (Behavior a) -> IO [a]
scanD :: a -> Event (a -> a) -> SignalGen (Discrete a)
changesD :: Discrete a -> Event a
preservesD :: Discrete a -> SignalGen (Event a)
delayD :: a -> Discrete a -> SignalGen (Discrete a)
stepperD :: a -> Event a -> SignalGen (Discrete a)
eventToBehavior :: Event a -> Behavior [a]
behaviorToEvent :: Behavior [a] -> Event a
applyBE :: Behavior (a -> b) -> Event a -> Event b
discreteToBehavior :: Discrete a -> Behavior a
class Functor s => TimeFunction s
toBehavior :: TimeFunction s => s a -> Behavior a
(<@>) :: TimeFunction s => s (a -> b) -> Event a -> Event b
(<@) :: TimeFunction s => s b -> Event a -> Event b
data OrderingViolation
OrderingViolation :: String -> OrderingViolation
