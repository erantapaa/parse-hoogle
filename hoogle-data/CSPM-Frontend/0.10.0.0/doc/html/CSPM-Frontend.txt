-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A CSP-M parser compatible with FDR-2.91
--   
@package CSPM-Frontend
@version 0.10.0.0


-- | The FDR supports some CSPM-built-ins that are NOT part of the
--   CSPM-syntax.
--   
--   Currently those built-ins are hard-coded in CSPM-Frontend. We use
--   Language.CSPM.BuiltIn as a compatibility layer to migrate to FDR-style
--   built-ins.
module Language.CSPM.BuiltIn

-- | INCOMPLETE list of built-ins that are not CSPM-syntax. | Todo: add
--   more BuiltIns here are migrate the AST.
builtIns :: [String]


-- | This module contains the data type PrimToken.
module Language.CSPM.TokenClasses

-- | The token classes of the CSP-M lexer
data PrimToken
L_Newline :: PrimToken
T_WhiteSpace :: PrimToken
L_LComment :: PrimToken
L_BComment :: PrimToken
L_Pragma :: PrimToken
L_Include :: PrimToken
L_EOF :: PrimToken
L_Integer :: PrimToken
L_String :: PrimToken
L_Ident :: PrimToken
T_channel :: PrimToken
T_datatype :: PrimToken
T_nametype :: PrimToken
T_subtype :: PrimToken
T_assert :: PrimToken
T_pragma :: PrimToken
T_transparent :: PrimToken
T_external :: PrimToken
T_print :: PrimToken
T_if :: PrimToken
T_then :: PrimToken
T_else :: PrimToken
T_let :: PrimToken
T_within :: PrimToken
T_true :: PrimToken
T_false :: PrimToken
T_not :: PrimToken
T_and :: PrimToken
T_or :: PrimToken
T_union :: PrimToken
T_inter :: PrimToken
T_diff :: PrimToken
T_Union :: PrimToken
T_Inter :: PrimToken
T_member :: PrimToken
T_card :: PrimToken
T_empty :: PrimToken
T_set :: PrimToken
T_Set :: PrimToken
T_Seq :: PrimToken
T_null :: PrimToken
T_head :: PrimToken
T_tail :: PrimToken
T_concat :: PrimToken
T_elem :: PrimToken
T_length :: PrimToken
T_STOP :: PrimToken
T_SKIP :: PrimToken
T_Events :: PrimToken
T_Int :: PrimToken
T_Bool :: PrimToken
T_CHAOS :: PrimToken
T_hat :: PrimToken
T_hash :: PrimToken
T_times :: PrimToken
T_slash :: PrimToken
T_percent :: PrimToken
T_plus :: PrimToken
T_minus :: PrimToken
T_eq :: PrimToken
T_neq :: PrimToken
T_ge :: PrimToken
T_le :: PrimToken
T_lt :: PrimToken
T_gt :: PrimToken
T_amp :: PrimToken
T_semicolon :: PrimToken
T_comma :: PrimToken
T_triangle :: PrimToken
T_box :: PrimToken
T_rhd :: PrimToken
T_exp :: PrimToken
T_sqcap :: PrimToken
T_interleave :: PrimToken
T_backslash :: PrimToken
T_parallel :: PrimToken
T_mid :: PrimToken
T_at :: PrimToken
T_atat :: PrimToken
T_rightarrow :: PrimToken
T_leftarrow :: PrimToken
T_leftrightarrow :: PrimToken
T_dot :: PrimToken
T_dotdot :: PrimToken
T_exclamation :: PrimToken
T_questionmark :: PrimToken
T_colon :: PrimToken
T_openParen :: PrimToken
T_closeParen :: PrimToken
T_openBrace :: PrimToken
T_closeBrace :: PrimToken
T_openBrack :: PrimToken
T_closeBrack :: PrimToken
T_openAssertBrack :: PrimToken
T_closeAssertBrack :: PrimToken
T_closeSpecialBrack :: PrimToken
T_openOxBrack :: PrimToken
T_closeOxBrack :: PrimToken
T_openBrackBrack :: PrimToken
T_closeBrackBrack :: PrimToken
T_openPBrace :: PrimToken
T_closePBrace :: PrimToken
T_underscore :: PrimToken
T_is :: PrimToken
T_Refine :: PrimToken
T_trace :: PrimToken
T_failure :: PrimToken
T_failureDivergence :: PrimToken
T_refusalTesting :: PrimToken
T_refusalTestingDiv :: PrimToken
T_revivalTesting :: PrimToken
T_revivalTestingDiv :: PrimToken
T_tauPriorityOp :: PrimToken
T_tau :: PrimToken
T_priority :: PrimToken
T_over :: PrimToken
T_deadlock :: PrimToken
T_deterministic :: PrimToken
T_livelock :: PrimToken
T_free :: PrimToken
T_F :: PrimToken
T_T :: PrimToken
T_FD :: PrimToken
instance Typeable PrimToken
instance Show PrimToken
instance Eq PrimToken
instance Ord PrimToken
instance Enum PrimToken
instance Ix PrimToken
instance Bounded PrimToken
instance Data PrimToken
instance Generic PrimToken
instance Datatype D1PrimToken
instance Constructor C1_0PrimToken
instance Constructor C1_1PrimToken
instance Constructor C1_2PrimToken
instance Constructor C1_3PrimToken
instance Constructor C1_4PrimToken
instance Constructor C1_5PrimToken
instance Constructor C1_6PrimToken
instance Constructor C1_7PrimToken
instance Constructor C1_8PrimToken
instance Constructor C1_9PrimToken
instance Constructor C1_10PrimToken
instance Constructor C1_11PrimToken
instance Constructor C1_12PrimToken
instance Constructor C1_13PrimToken
instance Constructor C1_14PrimToken
instance Constructor C1_15PrimToken
instance Constructor C1_16PrimToken
instance Constructor C1_17PrimToken
instance Constructor C1_18PrimToken
instance Constructor C1_19PrimToken
instance Constructor C1_20PrimToken
instance Constructor C1_21PrimToken
instance Constructor C1_22PrimToken
instance Constructor C1_23PrimToken
instance Constructor C1_24PrimToken
instance Constructor C1_25PrimToken
instance Constructor C1_26PrimToken
instance Constructor C1_27PrimToken
instance Constructor C1_28PrimToken
instance Constructor C1_29PrimToken
instance Constructor C1_30PrimToken
instance Constructor C1_31PrimToken
instance Constructor C1_32PrimToken
instance Constructor C1_33PrimToken
instance Constructor C1_34PrimToken
instance Constructor C1_35PrimToken
instance Constructor C1_36PrimToken
instance Constructor C1_37PrimToken
instance Constructor C1_38PrimToken
instance Constructor C1_39PrimToken
instance Constructor C1_40PrimToken
instance Constructor C1_41PrimToken
instance Constructor C1_42PrimToken
instance Constructor C1_43PrimToken
instance Constructor C1_44PrimToken
instance Constructor C1_45PrimToken
instance Constructor C1_46PrimToken
instance Constructor C1_47PrimToken
instance Constructor C1_48PrimToken
instance Constructor C1_49PrimToken
instance Constructor C1_50PrimToken
instance Constructor C1_51PrimToken
instance Constructor C1_52PrimToken
instance Constructor C1_53PrimToken
instance Constructor C1_54PrimToken
instance Constructor C1_55PrimToken
instance Constructor C1_56PrimToken
instance Constructor C1_57PrimToken
instance Constructor C1_58PrimToken
instance Constructor C1_59PrimToken
instance Constructor C1_60PrimToken
instance Constructor C1_61PrimToken
instance Constructor C1_62PrimToken
instance Constructor C1_63PrimToken
instance Constructor C1_64PrimToken
instance Constructor C1_65PrimToken
instance Constructor C1_66PrimToken
instance Constructor C1_67PrimToken
instance Constructor C1_68PrimToken
instance Constructor C1_69PrimToken
instance Constructor C1_70PrimToken
instance Constructor C1_71PrimToken
instance Constructor C1_72PrimToken
instance Constructor C1_73PrimToken
instance Constructor C1_74PrimToken
instance Constructor C1_75PrimToken
instance Constructor C1_76PrimToken
instance Constructor C1_77PrimToken
instance Constructor C1_78PrimToken
instance Constructor C1_79PrimToken
instance Constructor C1_80PrimToken
instance Constructor C1_81PrimToken
instance Constructor C1_82PrimToken
instance Constructor C1_83PrimToken
instance Constructor C1_84PrimToken
instance Constructor C1_85PrimToken
instance Constructor C1_86PrimToken
instance Constructor C1_87PrimToken
instance Constructor C1_88PrimToken
instance Constructor C1_89PrimToken
instance Constructor C1_90PrimToken
instance Constructor C1_91PrimToken
instance Constructor C1_92PrimToken
instance Constructor C1_93PrimToken
instance Constructor C1_94PrimToken
instance Constructor C1_95PrimToken
instance Constructor C1_96PrimToken
instance Constructor C1_97PrimToken
instance Constructor C1_98PrimToken
instance Constructor C1_99PrimToken
instance Constructor C1_100PrimToken
instance Constructor C1_101PrimToken
instance Constructor C1_102PrimToken
instance Constructor C1_103PrimToken
instance Constructor C1_104PrimToken
instance Constructor C1_105PrimToken
instance Constructor C1_106PrimToken
instance Constructor C1_107PrimToken
instance Constructor C1_108PrimToken
instance Constructor C1_109PrimToken
instance Constructor C1_110PrimToken
instance Constructor C1_111PrimToken
instance Constructor C1_112PrimToken
instance Constructor C1_113PrimToken
instance Constructor C1_114PrimToken
instance Constructor C1_115PrimToken
instance Constructor C1_116PrimToken
instance Constructor C1_117PrimToken
instance Constructor C1_118PrimToken
instance Constructor C1_119PrimToken
instance Constructor C1_120PrimToken
instance Constructor C1_121PrimToken
instance Constructor C1_122PrimToken


-- | Unicode symbols for CPSM operators
module Language.CSPM.UnicodeSymbols
unicodeSymbols :: [(Char, PrimToken, String)]
lookupDefaultSymbol :: PrimToken -> (Maybe (Char, String))
lookupToken :: Char -> Maybe PrimToken


-- | This module contains the data type Tokens and some helper functions
module Language.CSPM.Token
newtype TokenId
TokenId :: Int -> TokenId
unTokenId :: TokenId -> Int
mkTokenId :: Int -> TokenId
data AlexPosn
AlexPn :: !Int -> !Int -> !Int -> AlexPosn
alexPos :: AlexPosn -> !Int
alexLine :: AlexPosn -> !Int
alexCol :: AlexPosn -> !Int
pprintAlexPosn :: AlexPosn -> String
alexStartPos :: AlexPosn
alexMove :: AlexPosn -> Char -> AlexPosn
data LexError
LexError :: !AlexPosn -> !String -> LexError
lexEPos :: LexError -> !AlexPosn
lexEMsg :: LexError -> !String
data Token
Token :: TokenId -> AlexPosn -> Int -> PrimToken -> String -> Token
tokenId :: Token -> TokenId
tokenStart :: Token -> AlexPosn
tokenLen :: Token -> Int
tokenClass :: Token -> PrimToken
tokenString :: Token -> String
tokenSentinel :: Token
showPosn :: AlexPosn -> String
showToken :: Token -> String
instance Typeable TokenId
instance Typeable AlexPosn
instance Typeable LexError
instance Typeable Token
instance Show TokenId
instance Eq TokenId
instance Ord TokenId
instance Enum TokenId
instance Ix TokenId
instance Data TokenId
instance Generic TokenId
instance Show AlexPosn
instance Eq AlexPosn
instance Ord AlexPosn
instance Data AlexPosn
instance Generic AlexPosn
instance Show LexError
instance Show Token
instance Eq Token
instance Ord Token
instance Data Token
instance Generic Token
instance Datatype D1TokenId
instance Constructor C1_0TokenId
instance Selector S1_0_0TokenId
instance Datatype D1AlexPosn
instance Constructor C1_0AlexPosn
instance Selector S1_0_0AlexPosn
instance Selector S1_0_1AlexPosn
instance Selector S1_0_2AlexPosn
instance Datatype D1Token
instance Constructor C1_0Token
instance Selector S1_0_0Token
instance Selector S1_0_1Token
instance Selector S1_0_2Token
instance Selector S1_0_3Token
instance Selector S1_0_4Token
instance Exception LexError


-- | This module contains the datatype for sourcelocations and some utility
--   functions.
module Language.CSPM.SrcLoc
data SrcLoc
TokIdPos :: TokenId -> SrcLoc
TokIdSpan :: TokenId -> TokenId -> SrcLoc
TokSpan :: Token -> Token -> SrcLoc
TokPos :: Token -> SrcLoc
NoLocation :: SrcLoc
FixedLoc :: !Int -> !Int -> !Int -> !Int -> !Int -> !Int -> !Int -> SrcLoc
fixedStartLine :: SrcLoc -> !Int
fixedStartCol :: SrcLoc -> !Int
fixedStartOffset :: SrcLoc -> !Int
fixedLen :: SrcLoc -> !Int
fixedEndLine :: SrcLoc -> !Int
fixedEndCol :: SrcLoc -> !Int
fixedEndOffset :: SrcLoc -> !Int
mkTokSpan :: Token -> Token -> SrcLoc
mkTokPos :: Token -> SrcLoc
type SrcLine = Int
type SrcCol = Int
type SrcOffset = Int
getStartLine :: SrcLoc -> SrcLine
getStartCol :: SrcLoc -> SrcCol
getStartOffset :: SrcLoc -> SrcOffset
getTokenLen :: SrcLoc -> SrcOffset
getEndLine :: SrcLoc -> SrcLine
getEndCol :: SrcLoc -> SrcCol
getEndOffset :: SrcLoc -> SrcOffset
getStartTokenId :: SrcLoc -> TokenId
getEndTokenId :: SrcLoc -> TokenId
getStartToken :: SrcLoc -> Token
getEndToken :: SrcLoc -> Token
computeEndPos :: Token -> AlexPosn

-- | <i>Deprecated: sourceLoc arithmetics is not reliable</i>
srcLocFromTo :: SrcLoc -> SrcLoc -> SrcLoc

-- | <i>Deprecated: sourceLoc arithmetics is not reliable</i>
srcLocBetween :: SrcLoc -> SrcLoc -> SrcLoc
instance Typeable SrcLoc
instance Show SrcLoc
instance Eq SrcLoc
instance Ord SrcLoc
instance Data SrcLoc
instance Generic SrcLoc
instance Datatype D1SrcLoc
instance Constructor C1_0SrcLoc
instance Constructor C1_1SrcLoc
instance Constructor C1_2SrcLoc
instance Constructor C1_3SrcLoc
instance Constructor C1_4SrcLoc
instance Constructor C1_5SrcLoc
instance Selector S1_5_0SrcLoc
instance Selector S1_5_1SrcLoc
instance Selector S1_5_2SrcLoc
instance Selector S1_5_3SrcLoc
instance Selector S1_5_4SrcLoc
instance Selector S1_5_5SrcLoc
instance Selector S1_5_6SrcLoc


-- | This module defines an Abstract Syntax Tree for CSPM. This is the AST
--   that is computed by the parser. For historical reasons, it is rather
--   unstructured.
module Language.CSPM.AST
type AstAnnotation x = IntMap x
type Bindings = Map String UniqueIdent
type FreeNames = IntMap UniqueIdent
newtype NodeId
NodeId :: Int -> NodeId
unNodeId :: NodeId -> Int
mkNodeId :: Int -> NodeId
data Labeled t
Labeled :: NodeId -> SrcLoc -> t -> Labeled t
nodeId :: Labeled t -> NodeId
srcLoc :: Labeled t -> SrcLoc
unLabel :: Labeled t -> t

-- | Wrap a node with a dummyLabel. todo: Redo we need a specal case in
--   DataConstructor Labeled.
labeled :: t -> Labeled t
setNode :: Labeled t -> y -> Labeled y
type LIdent = Labeled Ident
data Ident
Ident :: String -> Ident
unIdent :: Ident -> String
UIdent :: UniqueIdent -> Ident
unUIdent :: Ident -> UniqueIdent
identId :: LIdent -> Int
data UniqueIdent
UniqueIdent :: Int -> NodeId -> SrcLoc -> IDType -> String -> String -> PrologMode -> BindType -> UniqueIdent
uniqueIdentId :: UniqueIdent -> Int
bindingSide :: UniqueIdent -> NodeId
bindingLoc :: UniqueIdent -> SrcLoc
idType :: UniqueIdent -> IDType
realName :: UniqueIdent -> String
newName :: UniqueIdent -> String
prologMode :: UniqueIdent -> PrologMode
bindType :: UniqueIdent -> BindType
data IDType
VarID :: IDType
ChannelID :: IDType
NameTypeID :: IDType
FunID :: IDType
ConstrID :: IDType
DataTypeID :: IDType
TransparentID :: IDType
BuiltInID :: IDType
data PrologMode
PrologGround :: PrologMode
PrologVariable :: PrologMode
data BindType
LetBound :: BindType
NotLetBound :: BindType
isLetBound :: BindType -> Bool
data Module a
Module :: [LDecl] -> Maybe [Token] -> SrcLoc -> [LocComment] -> [Pragma] -> Module a
moduleDecls :: Module a -> [LDecl]
moduleTokens :: Module a -> Maybe [Token]
moduleSrcLoc :: Module a -> SrcLoc
moduleComments :: Module a -> [LocComment]
modulePragmas :: Module a -> [Pragma]
data FromParser
castModule :: Module a -> Module b
type ModuleFromParser = Module FromParser
type LExp = Labeled Exp
type LProc = LExp
data Exp
Var :: LIdent -> Exp
IntExp :: Integer -> Exp
SetExp :: LRange -> (Maybe [LCompGen]) -> Exp
ListExp :: LRange -> (Maybe [LCompGen]) -> Exp
ClosureComprehension :: ([LExp], [LCompGen]) -> Exp
Let :: [LDecl] -> LExp -> Exp
Ifte :: LExp -> LExp -> LExp -> Exp
CallFunction :: LExp -> [[LExp]] -> Exp
CallBuiltIn :: LBuiltIn -> [[LExp]] -> Exp
Lambda :: [LPattern] -> LExp -> Exp
Stop :: Exp
Skip :: Exp
CTrue :: Exp
CFalse :: Exp
Events :: Exp
BoolSet :: Exp
IntSet :: Exp
TupleExp :: [LExp] -> Exp
Parens :: LExp -> Exp
AndExp :: LExp -> LExp -> Exp
OrExp :: LExp -> LExp -> Exp
NotExp :: LExp -> Exp
NegExp :: LExp -> Exp
Fun1 :: LBuiltIn -> LExp -> Exp
Fun2 :: LBuiltIn -> LExp -> LExp -> Exp
DotTuple :: [LExp] -> Exp
Closure :: [LExp] -> Exp
ProcSharing :: LExp -> LProc -> LProc -> Exp
ProcAParallel :: LExp -> LExp -> LProc -> LProc -> Exp
ProcLinkParallel :: LLinkList -> LProc -> LProc -> Exp
ProcRenaming :: [LRename] -> (Maybe LCompGenList) -> LProc -> Exp
ProcException :: LExp -> LProc -> LProc -> Exp
ProcRepSequence :: LCompGenList -> LProc -> Exp
ProcRepInternalChoice :: LCompGenList -> LProc -> Exp
ProcRepExternalChoice :: LCompGenList -> LProc -> Exp
ProcRepInterleave :: LCompGenList -> LProc -> Exp
ProcRepAParallel :: LCompGenList -> LExp -> LProc -> Exp
ProcRepLinkParallel :: LCompGenList -> LLinkList -> LProc -> Exp
ProcRepSharing :: LCompGenList -> LExp -> LProc -> Exp
PrefixExp :: LExp -> [LCommField] -> LProc -> Exp
PrefixI :: FreeNames -> LExp -> [LCommField] -> LProc -> Exp
LetI :: [LDecl] -> FreeNames -> LExp -> Exp
LambdaI :: FreeNames -> [LPattern] -> LExp -> Exp
ExprWithFreeNames :: FreeNames -> LExp -> Exp
type LRange = Labeled Range
data Range
RangeEnum :: [LExp] -> Range
RangeClosed :: LExp -> LExp -> Range
RangeOpen :: LExp -> Range
type LCommField = Labeled CommField
data CommField
InComm :: LPattern -> CommField
InCommGuarded :: LPattern -> LExp -> CommField
OutComm :: LExp -> CommField
type LLinkList = Labeled LinkList
data LinkList
LinkList :: [LLink] -> LinkList
LinkListComprehension :: [LCompGen] -> [LLink] -> LinkList
type LLink = Labeled Link
data Link
Link :: LExp -> LExp -> Link
type LRename = Labeled Rename
data Rename
Rename :: LExp -> LExp -> Rename
type LBuiltIn = Labeled BuiltIn
data BuiltIn
BuiltIn :: Const -> BuiltIn
lBuiltInToConst :: LBuiltIn -> Const
type LCompGenList = Labeled [LCompGen]
type LCompGen = Labeled CompGen
data CompGen
Generator :: LPattern -> LExp -> CompGen
Guard :: LExp -> CompGen
type LPattern = Labeled Pattern
data Pattern
IntPat :: Integer -> Pattern
TruePat :: Pattern
FalsePat :: Pattern
WildCard :: Pattern
Also :: [LPattern] -> Pattern
Append :: [LPattern] -> Pattern
DotPat :: [LPattern] -> Pattern
SingleSetPat :: LPattern -> Pattern
EmptySetPat :: Pattern
ListEnumPat :: [LPattern] -> Pattern
TuplePat :: [LPattern] -> Pattern
ConstrPat :: LIdent -> Pattern
VarPat :: LIdent -> Pattern
Selectors :: Array Int Selector -> Array Int (Maybe LIdent) -> Pattern
selectors :: Pattern -> Array Int Selector
idents :: Pattern -> Array Int (Maybe LIdent)
Selector :: Selector -> (Maybe LIdent) -> Pattern
data Selector
IntSel :: Integer -> Selector
TrueSel :: Selector
FalseSel :: Selector
SelectThis :: Selector
ConstrSel :: UniqueIdent -> Selector
DotSel :: Int -> Selector -> Selector
SingleSetSel :: Selector -> Selector
EmptySetSel :: Selector
TupleLengthSel :: Int -> Selector -> Selector
TupleIthSel :: Int -> Selector -> Selector
ListLengthSel :: Int -> Selector -> Selector
ListIthSel :: Int -> Selector -> Selector
HeadSel :: Selector -> Selector
HeadNSel :: Int -> Selector -> Selector
PrefixSel :: Int -> Int -> Selector -> Selector
TailSel :: Selector -> Selector
SliceSel :: Int -> Int -> Selector -> Selector
SuffixSel :: Int -> Int -> Selector -> Selector
type LDecl = Labeled Decl
data Decl
PatBind :: LPattern -> LExp -> Decl
FunBind :: LIdent -> [FunCase] -> Decl
Assert :: LAssertDecl -> Decl
Transparent :: [LIdent] -> Decl
SubType :: LIdent -> [LConstructor] -> Decl
DataType :: LIdent -> [LConstructor] -> Decl
NameType :: LIdent -> LTypeDef -> Decl
Channel :: [LIdent] -> (Maybe LTypeDef) -> Decl
Print :: LExp -> Decl
type FunArgs = [[LPattern]]
data FunCase
FunCase :: FunArgs -> LExp -> FunCase
FunCaseI :: [LPattern] -> LExp -> FunCase
type LTypeDef = Labeled TypeDef
data TypeDef
TypeTuple :: [LExp] -> TypeDef
TypeDot :: [LExp] -> TypeDef
type LConstructor = Labeled Constructor
data Constructor
Constructor :: LIdent -> (Maybe LTypeDef) -> Constructor
withLabel :: (NodeId -> a -> b) -> Labeled a -> Labeled b
type LAssertDecl = Labeled AssertDecl
data AssertDecl
AssertBool :: LExp -> AssertDecl
AssertRefine :: Bool -> LExp -> LRefineOp -> LExp -> AssertDecl
AssertTauPrio :: Bool -> LExp -> LTauRefineOp -> LExp -> LExp -> AssertDecl
AssertModelCheck :: Bool -> LExp -> LFDRModels -> (Maybe LFdrExt) -> AssertDecl
type LFDRModels = Labeled FDRModels
data FDRModels
DeadlockFree :: FDRModels
Deterministic :: FDRModels
LivelockFree :: FDRModels
type LFdrExt = Labeled FdrExt
data FdrExt
F :: FdrExt
FD :: FdrExt
T :: FdrExt
type LTauRefineOp = Labeled TauRefineOp
data TauRefineOp
TauTrace :: TauRefineOp
TauRefine :: TauRefineOp
type LRefineOp = Labeled RefineOp
data RefineOp
Trace :: RefineOp
Failure :: RefineOp
FailureDivergence :: RefineOp
RefusalTesting :: RefineOp
RefusalTestingDiv :: RefineOp
RevivalTesting :: RefineOp
RevivalTestingDiv :: RefineOp
TauPriorityOp :: RefineOp
data Const
F_true :: Const
F_false :: Const
F_not :: Const
F_and :: Const
F_or :: Const
F_union :: Const
F_inter :: Const
F_diff :: Const
F_Union :: Const
F_Inter :: Const
F_member :: Const
F_card :: Const
F_empty :: Const
F_set :: Const
F_Set :: Const
F_Seq :: Const
F_null :: Const
F_head :: Const
F_tail :: Const
F_concat :: Const
F_elem :: Const
F_length :: Const
F_STOP :: Const
F_SKIP :: Const
F_Events :: Const
F_Int :: Const
F_Bool :: Const
F_CHAOS :: Const
F_Concat :: Const
F_Len2 :: Const
F_Mult :: Const
F_Div :: Const
F_Mod :: Const
F_Add :: Const
F_Sub :: Const
F_Eq :: Const
F_NEq :: Const
F_GE :: Const
F_LE :: Const
F_LT :: Const
F_GT :: Const
F_Guard :: Const
F_Sequential :: Const
F_Interrupt :: Const
F_ExtChoice :: Const
F_IntChoice :: Const
F_Hiding :: Const
F_Timeout :: Const
F_Interleave :: Const
type Pragma = String
type LocComment = (Comment, SrcLoc)
data Comment
LineComment :: String -> Comment
BlockComment :: String -> Comment
PragmaComment :: Pragma -> Comment
instance Typeable NodeId
instance Typeable Labeled
instance Typeable IDType
instance Typeable PrologMode
instance Typeable BindType
instance Typeable UniqueIdent
instance Typeable Ident
instance Typeable FromParser
instance Typeable Selector
instance Typeable Pattern
instance Typeable FDRModels
instance Typeable FdrExt
instance Typeable TauRefineOp
instance Typeable RefineOp
instance Typeable Const
instance Typeable BuiltIn
instance Typeable Exp
instance Typeable Decl
instance Typeable AssertDecl
instance Typeable Constructor
instance Typeable TypeDef
instance Typeable FunCase
instance Typeable CompGen
instance Typeable Rename
instance Typeable LinkList
instance Typeable Link
instance Typeable CommField
instance Typeable Range
instance Typeable Comment
instance Typeable Module
instance Eq NodeId
instance Ord NodeId
instance Show NodeId
instance Enum NodeId
instance Ix NodeId
instance Data NodeId
instance Generic NodeId
instance Eq t => Eq (Labeled t)
instance Ord t => Ord (Labeled t)
instance Data t => Data (Labeled t)
instance Show t => Show (Labeled t)
instance Generic (Labeled t)
instance Eq IDType
instance Ord IDType
instance Show IDType
instance Data IDType
instance Generic IDType
instance Eq PrologMode
instance Ord PrologMode
instance Show PrologMode
instance Data PrologMode
instance Generic PrologMode
instance Eq BindType
instance Ord BindType
instance Show BindType
instance Data BindType
instance Generic BindType
instance Eq UniqueIdent
instance Ord UniqueIdent
instance Show UniqueIdent
instance Data UniqueIdent
instance Generic UniqueIdent
instance Eq Ident
instance Ord Ident
instance Show Ident
instance Data Ident
instance Generic Ident
instance Generic FromParser
instance Eq Selector
instance Ord Selector
instance Show Selector
instance Data Selector
instance Generic Selector
instance Eq Pattern
instance Ord Pattern
instance Show Pattern
instance Data Pattern
instance Generic Pattern
instance Eq FDRModels
instance Ord FDRModels
instance Show FDRModels
instance Data FDRModels
instance Generic FDRModels
instance Eq FdrExt
instance Ord FdrExt
instance Show FdrExt
instance Data FdrExt
instance Generic FdrExt
instance Eq TauRefineOp
instance Ord TauRefineOp
instance Show TauRefineOp
instance Data TauRefineOp
instance Generic TauRefineOp
instance Eq RefineOp
instance Ord RefineOp
instance Show RefineOp
instance Data RefineOp
instance Generic RefineOp
instance Eq Const
instance Ord Const
instance Show Const
instance Data Const
instance Generic Const
instance Eq BuiltIn
instance Ord BuiltIn
instance Show BuiltIn
instance Data BuiltIn
instance Generic BuiltIn
instance Eq Exp
instance Ord Exp
instance Show Exp
instance Data Exp
instance Generic Exp
instance Show Decl
instance Eq Decl
instance Ord Decl
instance Data Decl
instance Generic Decl
instance Eq AssertDecl
instance Ord AssertDecl
instance Show AssertDecl
instance Data AssertDecl
instance Generic AssertDecl
instance Eq Constructor
instance Ord Constructor
instance Show Constructor
instance Data Constructor
instance Generic Constructor
instance Eq TypeDef
instance Ord TypeDef
instance Show TypeDef
instance Data TypeDef
instance Generic TypeDef
instance Eq FunCase
instance Ord FunCase
instance Show FunCase
instance Data FunCase
instance Generic FunCase
instance Eq CompGen
instance Ord CompGen
instance Show CompGen
instance Data CompGen
instance Generic CompGen
instance Eq Rename
instance Ord Rename
instance Show Rename
instance Data Rename
instance Generic Rename
instance Eq LinkList
instance Ord LinkList
instance Show LinkList
instance Data LinkList
instance Generic LinkList
instance Eq Link
instance Ord Link
instance Show Link
instance Data Link
instance Generic Link
instance Eq CommField
instance Ord CommField
instance Show CommField
instance Data CommField
instance Generic CommField
instance Eq Range
instance Ord Range
instance Show Range
instance Data Range
instance Generic Range
instance Eq Comment
instance Ord Comment
instance Show Comment
instance Data Comment
instance Generic Comment
instance Eq (Module a)
instance Ord (Module a)
instance Show (Module a)
instance Data a => Data (Module a)
instance Generic (Module a)
instance Datatype D1NodeId
instance Constructor C1_0NodeId
instance Selector S1_0_0NodeId
instance Datatype D1Labeled
instance Constructor C1_0Labeled
instance Selector S1_0_0Labeled
instance Selector S1_0_1Labeled
instance Selector S1_0_2Labeled
instance Datatype D1IDType
instance Constructor C1_0IDType
instance Constructor C1_1IDType
instance Constructor C1_2IDType
instance Constructor C1_3IDType
instance Constructor C1_4IDType
instance Constructor C1_5IDType
instance Constructor C1_6IDType
instance Constructor C1_7IDType
instance Datatype D1PrologMode
instance Constructor C1_0PrologMode
instance Constructor C1_1PrologMode
instance Datatype D1BindType
instance Constructor C1_0BindType
instance Constructor C1_1BindType
instance Datatype D1UniqueIdent
instance Constructor C1_0UniqueIdent
instance Selector S1_0_0UniqueIdent
instance Selector S1_0_1UniqueIdent
instance Selector S1_0_2UniqueIdent
instance Selector S1_0_3UniqueIdent
instance Selector S1_0_4UniqueIdent
instance Selector S1_0_5UniqueIdent
instance Selector S1_0_6UniqueIdent
instance Selector S1_0_7UniqueIdent
instance Datatype D1Ident
instance Constructor C1_0Ident
instance Constructor C1_1Ident
instance Selector S1_0_0Ident
instance Datatype D1FromParser
instance Datatype D1Selector
instance Constructor C1_0Selector
instance Constructor C1_1Selector
instance Constructor C1_2Selector
instance Constructor C1_3Selector
instance Constructor C1_4Selector
instance Constructor C1_5Selector
instance Constructor C1_6Selector
instance Constructor C1_7Selector
instance Constructor C1_8Selector
instance Constructor C1_9Selector
instance Constructor C1_10Selector
instance Constructor C1_11Selector
instance Constructor C1_12Selector
instance Constructor C1_13Selector
instance Constructor C1_14Selector
instance Constructor C1_15Selector
instance Constructor C1_16Selector
instance Constructor C1_17Selector
instance Datatype D1Pattern
instance Constructor C1_0Pattern
instance Constructor C1_1Pattern
instance Constructor C1_2Pattern
instance Constructor C1_3Pattern
instance Constructor C1_4Pattern
instance Constructor C1_5Pattern
instance Constructor C1_6Pattern
instance Constructor C1_7Pattern
instance Constructor C1_8Pattern
instance Constructor C1_9Pattern
instance Constructor C1_10Pattern
instance Constructor C1_11Pattern
instance Constructor C1_12Pattern
instance Constructor C1_13Pattern
instance Constructor C1_14Pattern
instance Selector S1_13_0Pattern
instance Selector S1_13_1Pattern
instance Datatype D1FDRModels
instance Constructor C1_0FDRModels
instance Constructor C1_1FDRModels
instance Constructor C1_2FDRModels
instance Datatype D1FdrExt
instance Constructor C1_0FdrExt
instance Constructor C1_1FdrExt
instance Constructor C1_2FdrExt
instance Datatype D1TauRefineOp
instance Constructor C1_0TauRefineOp
instance Constructor C1_1TauRefineOp
instance Datatype D1RefineOp
instance Constructor C1_0RefineOp
instance Constructor C1_1RefineOp
instance Constructor C1_2RefineOp
instance Constructor C1_3RefineOp
instance Constructor C1_4RefineOp
instance Constructor C1_5RefineOp
instance Constructor C1_6RefineOp
instance Constructor C1_7RefineOp
instance Datatype D1Const
instance Constructor C1_0Const
instance Constructor C1_1Const
instance Constructor C1_2Const
instance Constructor C1_3Const
instance Constructor C1_4Const
instance Constructor C1_5Const
instance Constructor C1_6Const
instance Constructor C1_7Const
instance Constructor C1_8Const
instance Constructor C1_9Const
instance Constructor C1_10Const
instance Constructor C1_11Const
instance Constructor C1_12Const
instance Constructor C1_13Const
instance Constructor C1_14Const
instance Constructor C1_15Const
instance Constructor C1_16Const
instance Constructor C1_17Const
instance Constructor C1_18Const
instance Constructor C1_19Const
instance Constructor C1_20Const
instance Constructor C1_21Const
instance Constructor C1_22Const
instance Constructor C1_23Const
instance Constructor C1_24Const
instance Constructor C1_25Const
instance Constructor C1_26Const
instance Constructor C1_27Const
instance Constructor C1_28Const
instance Constructor C1_29Const
instance Constructor C1_30Const
instance Constructor C1_31Const
instance Constructor C1_32Const
instance Constructor C1_33Const
instance Constructor C1_34Const
instance Constructor C1_35Const
instance Constructor C1_36Const
instance Constructor C1_37Const
instance Constructor C1_38Const
instance Constructor C1_39Const
instance Constructor C1_40Const
instance Constructor C1_41Const
instance Constructor C1_42Const
instance Constructor C1_43Const
instance Constructor C1_44Const
instance Constructor C1_45Const
instance Constructor C1_46Const
instance Constructor C1_47Const
instance Constructor C1_48Const
instance Datatype D1BuiltIn
instance Constructor C1_0BuiltIn
instance Datatype D1Exp
instance Constructor C1_0Exp
instance Constructor C1_1Exp
instance Constructor C1_2Exp
instance Constructor C1_3Exp
instance Constructor C1_4Exp
instance Constructor C1_5Exp
instance Constructor C1_6Exp
instance Constructor C1_7Exp
instance Constructor C1_8Exp
instance Constructor C1_9Exp
instance Constructor C1_10Exp
instance Constructor C1_11Exp
instance Constructor C1_12Exp
instance Constructor C1_13Exp
instance Constructor C1_14Exp
instance Constructor C1_15Exp
instance Constructor C1_16Exp
instance Constructor C1_17Exp
instance Constructor C1_18Exp
instance Constructor C1_19Exp
instance Constructor C1_20Exp
instance Constructor C1_21Exp
instance Constructor C1_22Exp
instance Constructor C1_23Exp
instance Constructor C1_24Exp
instance Constructor C1_25Exp
instance Constructor C1_26Exp
instance Constructor C1_27Exp
instance Constructor C1_28Exp
instance Constructor C1_29Exp
instance Constructor C1_30Exp
instance Constructor C1_31Exp
instance Constructor C1_32Exp
instance Constructor C1_33Exp
instance Constructor C1_34Exp
instance Constructor C1_35Exp
instance Constructor C1_36Exp
instance Constructor C1_37Exp
instance Constructor C1_38Exp
instance Constructor C1_39Exp
instance Constructor C1_40Exp
instance Constructor C1_41Exp
instance Constructor C1_42Exp
instance Constructor C1_43Exp
instance Datatype D1Decl
instance Constructor C1_0Decl
instance Constructor C1_1Decl
instance Constructor C1_2Decl
instance Constructor C1_3Decl
instance Constructor C1_4Decl
instance Constructor C1_5Decl
instance Constructor C1_6Decl
instance Constructor C1_7Decl
instance Constructor C1_8Decl
instance Datatype D1AssertDecl
instance Constructor C1_0AssertDecl
instance Constructor C1_1AssertDecl
instance Constructor C1_2AssertDecl
instance Constructor C1_3AssertDecl
instance Datatype D1Constructor
instance Constructor C1_0Constructor
instance Datatype D1TypeDef
instance Constructor C1_0TypeDef
instance Constructor C1_1TypeDef
instance Datatype D1FunCase
instance Constructor C1_0FunCase
instance Constructor C1_1FunCase
instance Datatype D1CompGen
instance Constructor C1_0CompGen
instance Constructor C1_1CompGen
instance Datatype D1Rename
instance Constructor C1_0Rename
instance Datatype D1LinkList
instance Constructor C1_0LinkList
instance Constructor C1_1LinkList
instance Datatype D1Link
instance Constructor C1_0Link
instance Datatype D1CommField
instance Constructor C1_0CommField
instance Constructor C1_1CommField
instance Constructor C1_2CommField
instance Datatype D1Range
instance Constructor C1_0Range
instance Constructor C1_1Range
instance Constructor C1_2Range
instance Datatype D1Comment
instance Constructor C1_0Comment
instance Constructor C1_1Comment
instance Constructor C1_2Comment
instance Datatype D1Module
instance Constructor C1_0Module
instance Selector S1_0_0Module
instance Selector S1_0_1Module
instance Selector S1_0_2Module
instance Selector S1_0_3Module
instance Selector S1_0_4Module
instance Eq FromParser
instance Data FromParser


-- | This module defines functions for pretty-printing the Abstract Syntax
--   Tree to CSPM syntax.
module Language.CSPM.PrettyPrinter
pPrint :: Pretty a => a -> Doc
instance Pretty Const
instance Pretty TauRefineOp
instance Pretty RefineOp
instance Pretty FDRModels
instance Pretty FdrExt
instance Pretty AssertDecl
instance Pretty Pattern
instance Pretty CommField
instance Pretty BuiltIn
instance Pretty Range
instance Pretty Rename
instance Pretty Link
instance Pretty LinkList
instance Pretty Exp
instance Pretty Decl
instance Pretty (Module a)
instance Pretty x => Pretty (Labeled x)


-- | Some utility functions for converting the AST
module Language.CSPM.AstUtils

-- | <a>removeSourceLocations</a> sets all locationsInfos to
--   <tt>NoLocation</tt>
removeSourceLocations :: Data a => a -> a

-- | <a>removeParens</a> removes all occurences of of Parens, i.e. explicit
--   parentheses from the AST
removeParens :: Data a => a -> a

-- | Remove assert declarations from a module.
removeModuleAsserts :: Module a -> Module a

-- | unUniqueIdent replaces the all UIdent with the Ident of the the new
--   name, thus forgetting additional information like the bindingside,
--   etc. Usefull to get a smaller AST.
unUniqueIdent :: Data a => a -> a

-- | Compute the <a>FreeNames</a> of an Expression. This function does only
--   work after renaming has been done. This implementation is inefficient.
computeFreeNames :: Data a => a -> FreeNames

-- | Get the assert declarations of a module.
getModuleAsserts :: Module a -> [LAssertDecl]

-- | Set all NodeIds to zero.
setNodeIdsZero :: Data a => a -> a

module Language.CSPM.LexHelper

-- | lex a String .
lexPlain :: String -> Either LexError [Token]

-- | Convert a token to a String. If the tokenClasss has a Unicode symbol
--   return the default Unicode string.
unicodeTokenString :: Token -> String

-- | Convert a token to a String. If the tokenClasss has a Unicode symbol
--   return the default ASCII string.
asciiTokenString :: Token -> String
type Chunk = [Token]
type Chunks = DList Chunk
data FilePart
Toks :: Chunk -> FilePart
Include :: FilePath -> FilePart

-- | lex input-string and inport all includes files
lexInclude :: String -> IO (Either LexError [Token])
lexInclude2 :: String -> EitherT LexError IO Chunks
processPart :: FilePart -> EitherT LexError IO Chunks

-- | micro-parser for include-statements
splitIncludes :: [Token] -> [Token] -> Either LexError [FilePart]
scanInclude :: Token -> [Token] -> Either LexError [FilePart]

-- | Remove comments, whitespaces and unneeded newlines.
removeIgnoredToken :: [Token] -> [Token]

-- | Is the token a line-comment, block-comment or a Pragma?
tokenIsComment :: Token -> Bool

-- | remove newlines, that do not end a declaration from the token stream.
--   For example newlines next to binary operators. Remove all trailing
--   newlines.
soakNewlines :: [Token] -> [Token]
instance Show FilePart


-- | Compute the mapping between the using occurences and the defining
--   occurences of all Identifier in a Module Also decide whether to use
--   ground or non-ground- representaions for the translation to Prolog.
module Language.CSPM.Rename

-- | <a>renameModule</a> renames a <a>Module</a>. | (also calls
--   mergeFunBinds)
renameModule :: ModuleFromParser -> Either RenameError (ModuleFromRenaming, RenameInfo)
data RenameError
RenameError :: String -> SrcLoc -> RenameError
renameErrorMsg :: RenameError -> String
renameErrorLoc :: RenameError -> SrcLoc

-- | Gather all information about an renaming.
data RenameInfo
RenameInfo :: Int -> Map String UniqueIdent -> Map String UniqueIdent -> AstAnnotation UniqueIdent -> AstAnnotation UniqueIdent -> Set String -> PrologMode -> BindType -> RenameInfo
nameSupply :: RenameInfo -> Int
localBindings :: RenameInfo -> Map String UniqueIdent
visible :: RenameInfo -> Map String UniqueIdent
identDefinition :: RenameInfo -> AstAnnotation UniqueIdent
identUse :: RenameInfo -> AstAnnotation UniqueIdent
usedNames :: RenameInfo -> Set String
prologMode :: RenameInfo -> PrologMode
bindType :: RenameInfo -> BindType

-- | A module that has gone through renaming
type ModuleFromRenaming = Module FromRenaming

-- | Tag that a module has gone through renaming.
data FromRenaming
instance Typeable FromRenaming
instance Typeable RenameError
instance Show RenameInfo
instance Show RenameError
instance Error RenameError
instance Exception RenameError
instance Data FromRenaming


-- | This modules defines a Parser for CSP-M
module Language.CSPM.Parser

-- | The <a>parse</a> function parses a List of <a>Token</a>. It returns a
--   <a>ParseError</a> or a <tt>Labled</tt> <a>Module</a>. The
--   <a>SourceName</a> argument is currently not used.
parse :: SourceName -> [Token] -> Either ParseError ModuleFromParser

-- | ParseError data type. This is an instance of Excpetion
data ParseError
ParseError :: String -> Token -> AlexPosn -> ParseError
parseErrorMsg :: ParseError -> String
parseErrorToken :: ParseError -> Token
parseErrorPos :: ParseError -> AlexPosn

-- | Wrapper for testing sub parsers
testParser :: PT a -> [Token] -> Either ParseError a

-- | Parser for CSP-M expressions
parseExp :: PT LExp

-- | Parser for CSP-M patterns
parsePattern :: PT LPattern

-- | <a>PT</a> is an alias for the ParserType
type PT a = GenParser Token PState a
instance Typeable ParseError
instance Show ParseError
instance Show PState
instance Exception ParseError


-- | Some Utilities
module Language.CSPM.Utils

-- | "eitherToExe" returns the Right part of <a>Either</a> or throws the
--   Left part as an dynamic exception.
eitherToExc :: Exception a => Either a b -> IO b

-- | Handle a dymanic exception of type <a>LexError</a>.
handleLexError :: (LexError -> IO a) -> IO a -> IO a

-- | Handle a dymanic exception of type <a>ParseError</a>.
handleParseError :: (ParseError -> IO a) -> IO a -> IO a

-- | Handle a dymanic exception of type <a>RenameError</a>.
handleRenameError :: (RenameError -> IO a) -> IO a -> IO a

-- | Lex and parse a file and return a <a>LModule</a>, throw an exception
--   in case of an error
parseFile :: FilePath -> IO ModuleFromParser

-- | Lex and parse File. | Return the module and print some timing infos
benchmarkFrontend :: FilePath -> IO (ModuleFromParser, ModuleFromRenaming)

-- | Small test function which just parses a String.
parseString :: String -> IO ModuleFromParser


-- | Frontend contains some reexports from other modules
module Language.CSPM.Frontend

-- | The <a>parse</a> function parses a List of <a>Token</a>. It returns a
--   <a>ParseError</a> or a <tt>Labled</tt> <a>Module</a>. The
--   <a>SourceName</a> argument is currently not used.
parse :: SourceName -> [Token] -> Either ParseError ModuleFromParser

-- | ParseError data type. This is an instance of Excpetion
data ParseError
ParseError :: String -> Token -> AlexPosn -> ParseError
parseErrorMsg :: ParseError -> String
parseErrorToken :: ParseError -> Token
parseErrorPos :: ParseError -> AlexPosn

-- | Lex and parse a file and return a <a>LModule</a>, throw an exception
--   in case of an error
parseFile :: FilePath -> IO ModuleFromParser

-- | Lex and parse File. | Return the module and print some timing infos
benchmarkFrontend :: FilePath -> IO (ModuleFromParser, ModuleFromRenaming)

-- | "eitherToExe" returns the Right part of <a>Either</a> or throws the
--   Left part as an dynamic exception.
eitherToExc :: Exception a => Either a b -> IO b

-- | Handle a dymanic exception of type <a>LexError</a>.
handleLexError :: (LexError -> IO a) -> IO a -> IO a

-- | Handle a dymanic exception of type <a>ParseError</a>.
handleParseError :: (ParseError -> IO a) -> IO a -> IO a

-- | Handle a dymanic exception of type <a>RenameError</a>.
handleRenameError :: (RenameError -> IO a) -> IO a -> IO a
data Token
data LexError
LexError :: !AlexPosn -> !String -> LexError
lexEPos :: LexError -> !AlexPosn
lexEMsg :: LexError -> !String

-- | lex input-string and inport all includes files
lexInclude :: String -> IO (Either LexError [Token])

-- | lex a String .
lexPlain :: String -> Either LexError [Token]

-- | Remove comments, whitespaces and unneeded newlines.
removeIgnoredToken :: [Token] -> [Token]
data Module a
type ModuleFromParser = Module FromParser

-- | A module that has gone through renaming
type ModuleFromRenaming = Module FromRenaming
data Labeled t
Labeled :: NodeId -> SrcLoc -> t -> Labeled t
nodeId :: Labeled t -> NodeId
srcLoc :: Labeled t -> SrcLoc
unLabel :: Labeled t -> t
castModule :: Module a -> Module b
type Bindings = Map String UniqueIdent
data SrcLoc
TokIdPos :: TokenId -> SrcLoc
TokIdSpan :: TokenId -> TokenId -> SrcLoc
TokSpan :: Token -> Token -> SrcLoc
TokPos :: Token -> SrcLoc
NoLocation :: SrcLoc
FixedLoc :: !Int -> !Int -> !Int -> !Int -> !Int -> !Int -> !Int -> SrcLoc
fixedStartLine :: SrcLoc -> !Int
fixedStartCol :: SrcLoc -> !Int
fixedStartOffset :: SrcLoc -> !Int
fixedLen :: SrcLoc -> !Int
fixedEndLine :: SrcLoc -> !Int
fixedEndCol :: SrcLoc -> !Int
fixedEndOffset :: SrcLoc -> !Int

-- | <a>renameModule</a> renames a <a>Module</a>. | (also calls
--   mergeFunBinds)
renameModule :: ModuleFromParser -> Either RenameError (ModuleFromRenaming, RenameInfo)

-- | Gather all information about an renaming.
data RenameInfo
RenameInfo :: Int -> Map String UniqueIdent -> Map String UniqueIdent -> AstAnnotation UniqueIdent -> AstAnnotation UniqueIdent -> Set String -> PrologMode -> BindType -> RenameInfo
nameSupply :: RenameInfo -> Int
localBindings :: RenameInfo -> Map String UniqueIdent
visible :: RenameInfo -> Map String UniqueIdent
identDefinition :: RenameInfo -> AstAnnotation UniqueIdent
identUse :: RenameInfo -> AstAnnotation UniqueIdent
usedNames :: RenameInfo -> Set String
prologMode :: RenameInfo -> PrologMode
bindType :: RenameInfo -> BindType
data RenameError
RenameError :: String -> SrcLoc -> RenameError
renameErrorMsg :: RenameError -> String
renameErrorLoc :: RenameError -> SrcLoc

-- | <a>removeSourceLocations</a> sets all locationsInfos to
--   <tt>NoLocation</tt>
removeSourceLocations :: Data a => a -> a

-- | <a>removeParens</a> removes all occurences of of Parens, i.e. explicit
--   parentheses from the AST
removeParens :: Data a => a -> a

-- | unUniqueIdent replaces the all UIdent with the Ident of the the new
--   name, thus forgetting additional information like the bindingside,
--   etc. Usefull to get a smaller AST.
unUniqueIdent :: Data a => a -> a

-- | Compute the <a>FreeNames</a> of an Expression. This function does only
--   work after renaming has been done. This implementation is inefficient.
computeFreeNames :: Data a => a -> FreeNames

-- | Set all NodeIds to zero.
setNodeIdsZero :: Data a => a -> a

-- | The version of the CSPM-Frontend library
frontendVersion :: Version
