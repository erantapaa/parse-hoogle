-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A type for integers modulo some constant.
--   
@package modular-arithmetic
@version 1.2.1.1


-- | Types for working with integers modulo some constant.
module Data.Modular

-- | Wraps an underlying <tt>Integeral</tt> type <tt>i</tt> in a newtype
--   annotated with the bound <tt>n</tt>.
data Mod i (n :: Nat)

-- | Extract the underlying integral value from a modular type.
unMod :: i `Mod` n -> i

-- | Injects a value of the underlying type into the modulus type, wrapping
--   as appropriate.
toMod :: (Integral i, KnownNat n) => i -> i `Mod` n

-- | Wraps an integral number, converting between integral types.
toMod' :: (Integral i, Integral j, KnownNat n) => i -> j `Mod` n

-- | The modular inverse.
--   
--   <pre>
--   &gt;&gt;&gt; inv 3 :: ℤ/7
--   5
--   
--   &gt;&gt;&gt; 3 * 5 :: ℤ/7
--   1
--   </pre>
--   
--   Note that only numbers coprime to <tt>n</tt> have an inverse modulo
--   <tt>n</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; inv 6 :: ℤ/15
--   *** Exception: divide by 6 (mod 15), non-coprime to modulus
--   </pre>
inv :: (KnownNat n, Integral i) => Mod i n -> Mod i n

-- | A synonym for <tt>Mod</tt>, inspired by the ℤ/n syntax from
--   mathematics.
type (/) = Mod

-- | A synonym for Integer, also inspired by the ℤ/n syntax.
type ℤ = Integer

-- | Convert an integral number <tt>i</tt> into a <tt><a>Mod</a></tt> value
--   given modular bound <tt>n</tt> at type level.
modVal :: (Integral i, KnownNat n) => i -> proxy n -> Mod i n

-- | A modular number with an unknown bound.
data SomeMod i

-- | Convert an integral number <tt>i</tt> into a <tt><a>Mod</a></tt> value
--   with an unknown modulus.
someModVal :: Integral i => i -> Integer -> Maybe (SomeMod i)
instance Eq i => Eq (Mod i n)
instance Ord i => Ord (Mod i n)
instance Show i => Show (SomeMod i)
instance (Integral i, KnownNat n) => Integral (Mod i n)
instance (Integral i, KnownNat n) => Real (Mod i n)
instance (Integral i, KnownNat n) => Bounded (Mod i n)
instance (Integral i, KnownNat n) => Enum (Mod i n)
instance (Integral i, KnownNat n) => Num (Mod i n)
instance (Read i, Integral i, KnownNat n) => Read (Mod i n)
instance Show i => Show (Mod i n)
