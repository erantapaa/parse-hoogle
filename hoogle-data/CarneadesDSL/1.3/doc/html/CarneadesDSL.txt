-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An implementation and DSL for the Carneades argumentation model.
--   
--   An implementation and domain specific language for the Carneades
--   argumentation model. See <a>Haskell Gets Argumentative</a> in the
--   Proceedings of Symposium on Trends in Functional Programming (TFP
--   2012) by Bas van Gijzel and Henrik Nilsson or the package's homepage.
--   Thanks to Stefan Sabev for providing initial code for the cyclicity
--   check.
@package CarneadesDSL
@version 1.3

module Language.Carneades.Cyclic
cyclic :: DynGraph g => g a b -> Bool

module Language.Carneades.CarneadesDSL
type PropLiteral = (Bool, String)
negate :: PropLiteral -> PropLiteral
newtype Argument
Arg :: ([PropLiteral], [PropLiteral], PropLiteral) -> Argument
showProp :: PropLiteral -> String
type ArgSet = Gr (PropLiteral, [Argument]) ()
newtype CAES
CAES :: (ArgSet, Audience, PropStandard) -> CAES
type Audience = (Assumptions, ArgWeight)
type Assumptions = [PropLiteral]
type ArgWeight = Argument -> Weight
type Weight = Double
type PropStandard = PropLiteral -> PSName
data PSName
Scintilla :: PSName
Preponderance :: PSName
ClearAndConvincing :: PSName
BeyondReasonableDoubt :: PSName
DialecticalValidity :: PSName
type ProofStandard = PropLiteral -> CAES -> Bool
newtype ProofStandardNamed
P :: (String, PropLiteral -> CAES -> Bool) -> ProofStandardNamed
applicable :: Argument -> CAES -> Bool
acceptable :: PropLiteral -> CAES -> Bool
scintilla :: ProofStandard
maxWeightApplicable :: [Argument] -> CAES -> Weight
maxWeightPro :: PropLiteral -> CAES -> Weight
maxWeightCon :: PropLiteral -> CAES -> Weight
preponderance :: ProofStandard
clear_and_convincing :: ProofStandard
beyond_reasonable_doubt :: ProofStandard
dialectical_validity :: ProofStandard
psMap :: PSName -> ProofStandard
getAllArgs :: ArgSet -> [Argument]
getProps :: ArgSet -> [PropLiteral]
applicableArgs :: CAES -> [Argument]
nonApplicableArgs :: CAES -> [Argument]
acceptableProps :: CAES -> [PropLiteral]
nonAcceptableProps :: CAES -> [PropLiteral]
contextP :: PropLiteral -> AGraph -> [Context (PropLiteral, [Argument]) ()]
getArgs :: PropLiteral -> AGraph -> [Argument]
type AGraph = ArgSet
type PropNode = LNode (PropLiteral, [Argument])
type AssociatedGraph = (AGraph, Map PropLiteral Node)
mkArgSet :: [Argument] -> ArgSet
mkArgGraph :: [Argument] -> AGraph
addArgument :: Argument -> AssociatedGraph -> AssociatedGraph
addToContext :: Argument -> (Context (PropLiteral, [Argument]) (), AGraph) -> AGraph
unsafeMatch :: Graph gr => Node -> gr a b -> (Context a b, gr a b)
addArgument' :: Argument -> AssociatedGraph -> (AssociatedGraph, Node)
addNode :: PropLiteral -> AssociatedGraph -> (AssociatedGraph, Node)
addEdges :: Node -> [PropLiteral] -> AssociatedGraph -> AssociatedGraph
addEdges' :: Node -> [Node] -> AssociatedGraph -> AssociatedGraph
propsToNodes :: [PropLiteral] -> Node -> [PropNode]
checkCycle :: AGraph -> Bool
mkProp :: String -> PropLiteral
mkAssumptions :: [String] -> [PropLiteral]
mkArg :: [String] -> [String] -> String -> Argument
alpha :: Double
gamma :: Double
beta :: Double
instance Ord Argument
instance Show PSName
instance Eq PSName
instance Eq ProofStandardNamed
instance Show Argument
instance Eq Argument


-- | This is the input module accompanying the implementation of Carneades.
--   It defines a simple parser for a Carneades Argument Evaluation
--   Structure (CAES).
--   
--   Files are assumed to have the following order of content: one argument
--   or attack on each line, ending in a dot. (Our parser is slightly more
--   relaxed than this and doesn't care about whitespace.)
--   
--   <tt>att(a1,a2).</tt> or <tt>arg(a1).</tt>
--   
--   Argument names are assumed to consist only of letters and numbers.
--   Arguments used in attacks should be declared separately as well.
--   
--   For a complete example see
--   <a>http://www.cs.nott.ac.uk/~bmv/Code/examplecaes.txt</a> (also
--   included as an additional source file) or see the accompanying
--   ExampleCAES module.
module Language.Carneades.Input

-- | Parses a <a>String</a> containing a CAES. If parsing fails, it
--   propagates the parse error.
parseCAES :: String -> Either ParseError CAES

-- | Parses the definition of a complete Carneades Argument Evaluation
--   Structure (CAES).
--   
--   A CAES is parsed in multiple stages:
--   
--   First parsing zero or more arguments: where a complete argument
--   consists of <tt>arg</tt> or <tt>argument</tt> followed by an
--   <tt>argName</tt> (a letter followed by one or more letters and digits,
--   underscore or '; alternatively, a string literal), two lists of
--   propositions, and a conclusion.
--   
--   Then, zero or more weights, where a weight is declared by the string
--   <tt>weight</tt> followed by the name of a previously declared
--   argument, and a <a>Double</a> assigned to that argument.
--   
--   Then, a list of assumptions, where a list of assumptions is just the
--   keyword <tt>assumptions</tt> followed by a list of propositions.
--   
--   Then a list of proof standard declarations, where a proof standard is
--   declared by the string <tt>standard</tt> followed by a proposition and
--   the name of a proof standard.
--   
--   This is followed by an end of file token.
pCAES :: Parser CAES
instance Eq Argument'
instance Show Argument'

module Language.Carneades.ExampleCAES

-- | mkArgSet| respectively:
arg1 :: Argument

-- | mkArgSet| respectively:
arg3 :: Argument

-- | mkArgSet| respectively:
arg2 :: Argument
argSet :: ArgSet

-- | mkAssumptions| on the propositions which are to be assumed. The
--   audience is just a pair of these:
weight :: ArgWeight
assumptions :: [PropLiteral]
audience :: Audience
standard :: PropStandard
caes :: CAES
testAppIntent :: [Argument]
testAppNotIntent :: [Argument]
testAppMurder :: [Argument]
testAppNotMurder :: [Argument]
testMurder :: Bool
testNotMurder :: Bool
parse :: IO ()
