-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Bijective mappings between values and possibly infinite prefixes of [0..]
--   
--   Combinators and a class for creating bijective functions between
--   conceivably any data type definable and prefixes of the list of
--   natural numbers.
@package count
@version 0.0.1

module Data.Count.Counter

-- | A <tt><a>Counter</a> a</tt> maps bijectively between a subset of
--   values of type <tt>a</tt> and some possibly empty or infinite prefix
--   of <tt>[0..]</tt>.
--   
--   <a>cCount</a> is <tt><a>Just</a> n</tt> when the counter is finite and
--   manages <tt>n</tt> values, or <tt><a>Nothing</a></tt> when infinite.
--   
--   <a>cToPos</a> converts a managed value to its natural number (starting
--   from 0).
--   
--   <a>cFromPos</a> converts a natural number to its managed value.
--   
--   <tt><a>cToPos</a> c . <a>cFromPos</a> c</tt> must be the identity
--   function. This invariant is maintained using the combinators below.
data Counter a
UnsafeMkCounter :: Maybe Integer -> (a -> Integer) -> (Integer -> a) -> Counter a
cCount :: Counter a -> Maybe Integer
cToPos :: Counter a -> a -> Integer
cFromPos :: Counter a -> Integer -> a

-- | A counter for the single unit value.
unitCounter :: Counter ()

-- | A counter for an empty set of values, for any type.
voidCounter :: Counter a

-- | Counts through the natural numbers: <tt>[0..]</tt> maps simply to
--   <tt>[0..]</tt>.
natCounter :: Counter Integer

-- | <tt><a>dropCounter</a> n c</tt> drops the first <tt>n</tt> elements
--   from the given counter. <tt><a>cToPos</a> (<a>dropCounter</a> n c)
--   0</tt> is equivalent to <tt><a>cToPos</a> c 0</tt>.
dropCounter :: Integer -> Counter a -> Counter a

-- | Given two counters, <tt>a</tt> and <tt>b</tt>, creates a counter for
--   all <a>Left</a>-tagged <tt>a</tt> values and <a>Right</a>-tagged
--   <tt>b</tt> values.
sumCounter :: Counter a -> Counter b -> Counter (Either a b)

-- | Creates a counter for the Cartesian product of values in two given
--   counters.
prodCounter :: Counter a -> Counter b -> Counter (a, b)

-- | A counter for any <tt>Bounded</tt> <tt>Enum</tt>. <tt>[<a>minBound</a>
--   :: a ..]</tt> maps to <tt>[0..]</tt>.
boundedEnumCounter :: (Bounded a, Enum a) => Counter a
isoCounter :: Counter a -> (b -> a) -> (a -> b) -> Counter b
maybeCounter :: Counter a -> Counter (Maybe a)

-- | Counter for all lists of all values in given counter.
--   
--   The count is 1 (the only value being the empty list) if the given
--   counter is empty, infinite otherwise.
listCounter :: Counter a -> Counter [a]

-- | Maps [0,1,-1,2,-2,..] to [0..]
integerCounter :: Counter Integer

-- | All values in the given counter, from the <tt>0</tt> correspondent
--   upwards.
allValuesFor :: Counter a -> [a]

module Data.Count

-- | Class and instances for producing <a>Counter</a>s by type.
class Countable a
counter :: Countable a => Counter a

-- | Overloaded <a>cToPos</a>.
toPos :: Countable a => a -> Integer

-- | Overloaded <a>cFromPos</a>.
fromPos :: Countable a => Integer -> a

-- | Overloaded <a>cCount</a>. Doesn't attempt to reduce the dummy value
--   given.
count :: Countable a => a -> Maybe Integer

-- | Overloaded <a>allValuesFor</a>.
allValues :: Countable a => [a]
instance Countable a => Countable (Maybe a)
instance Countable a => Countable [a]
instance (Countable a, Countable b, Countable c, Countable d) => Countable (a, b, c, d)
instance (Countable a, Countable b, Countable c) => Countable (a, b, c)
instance (Countable a, Countable b) => Countable (a, b)
instance (Countable a, Countable b) => Countable (Either a b)
instance Countable ()
instance Countable Int64
instance Countable Int32
instance Countable Int16
instance Countable Int8
instance Countable Int
instance Countable Char
instance Countable Bool
instance Countable Integer
