-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A library wrapping standard IO modules to provide strict IO.
--   
--   This library is a thin layer on top standard IO modules like System.IO
--   and Data.IORef that re-expose these functions under a different type,
--   namely SIO.
@package strict-io
@version 0.2.1


-- | This module exports the internals of <a>System.IO.Strict</a> so that
--   other packages can extend the <a>SIO</a> monad. This module has to be
--   used with great care: by lifting a lazy function or a function that
--   let leaks its lazy arguments, one breaks the only purpose of the
--   <a>System.IO.Strict</a> module.
module System.IO.Strict.Internals
newtype SIO a
SIO :: IO a -> SIO a
rawRun :: SIO a -> IO a

-- | <a>run</a> allows to return to the wider world of <a>IO</a>s.
run :: NFData sa => SIO sa -> IO sa

-- | A stricter version of <a>return</a>, that works for every monad.
return' :: (Monad m, NFData sa) => sa -> m sa

-- | Wraps a strict <i>IO</i> computation without arguments.
wrap0 :: IO a -> SIO a

-- | Wraps a lazy <i>IO</i> computation without arguments and forces its
--   contents.
wrap0' :: NFData sa => IO sa -> SIO sa

-- | Wraps a strict <i>IO</i> computation with a single argument.
wrap1 :: (a -> IO b) -> a -> SIO b

-- | Wraps a lazy <i>IO</i> computation with a single argument and forces
--   its contents.
wrap1' :: NFData sb => (a -> IO sb) -> a -> SIO sb

-- | Wraps a strict <i>IO</i> computation with two arguments.
wrap2 :: (a -> b -> IO c) -> a -> b -> SIO c

-- | Wraps a strict <i>IO</i> computation with two arguments and forces its
--   contents.
wrap2' :: NFData sc => (a -> b -> IO sc) -> a -> b -> SIO sc

-- | Wraps a strict <i>IO</i> computation with two arguments.
wrap3 :: (a -> b -> c -> IO d) -> a -> b -> c -> SIO d

-- | Wraps a strict <i>IO</i> computation with two arguments and forces its
--   contents.
wrap3' :: NFData sd => (a -> b -> c -> IO sd) -> a -> b -> c -> SIO sd
instance Functor SIO
instance Applicative SIO
instance Monad SIO
instance MonadFix SIO


-- | Mutable references of strict values in the <a>SIO</a> monad.
--   
--   The type of references remains the same as in the <a>IO</a> monad and
--   is just re-exported here.
module Data.IORef.Strict

-- | A mutable variable in the <a>IO</a> monad
data IORef a :: * -> *

-- | Build a new <a>IORef</a>, but force the value before storing it.
newIORef :: NFData sa => sa -> SIO (IORef sa)

-- | Read the value of an <a>IORef</a>
readIORef :: IORef a -> SIO a

-- | Deeply force a value and write it into an <a>IORef</a>
writeIORef :: NFData sa => IORef sa -> sa -> SIO ()

-- | Mutate the contents of an <a>IORef</a>
modifyIORef :: NFData sa => IORef sa -> (sa -> sa) -> SIO ()

-- | Atomically modifies the contents of an <a>IORef</a>.
--   
--   This function is useful for using <a>IORef</a> in a safe way in a
--   multithreaded program. If you only have one <a>IORef</a>, then using
--   <a>atomicModifyIORef</a> to access and modify it will prevent race
--   conditions.
--   
--   Extending the atomicity to multiple <a>IORef</a>s is problematic, so
--   it is recommended that if you need to do anything more complicated
--   then using <a>Control.Concurrent.MVar.MVar</a> instead is a good idea.
atomicModifyIORef :: (NFData sa, NFData sb) => IORef sa -> (sa -> (sa, sb)) -> SIO sb

-- | Make a <a>Weak</a> pointer to an <a>IORef</a>
mkWeakIORef :: IORef a -> SIO () -> SIO (Weak (IORef a))


-- | This module wraps the functions of the <a>System.IO</a> module at a
--   different type namely <a>SIO</a>.
--   
--   The purpose of this module is to export only strict <i>IO</i>
--   functions, by strict we mean strict in the result. The arguments of
--   these functions may only by partially forced, but when the function
--   returns, the arguments can no longer be forced by the function. When
--   the type of the value to be forced is polymorphic, a <a>NFData</a>
--   constraint is added since we (internally) use <a>rnf</a> to force the
--   value. Then we rely on the behavior of <a>NFData</a> instances to
--   provide the fact that any lazy argument passed to a <a>SIO</a>
--   function will not leak-out after the call.
--   
--   These functions do not necessarily use their arguments completely but
--   they do not hold or return any value that could depend on these
--   arguments. If the original functions from <a>System.IO</a> module were
--   already strict, then this module just provides them at another type.
--   Some functions from the original module are famously lazy like the
--   <a>getContents</a> like functions: in this module their results are
--   deeply forced.
--   
--   In Haskell, monad operations (<tt>return</tt> and <tt>&gt;&gt;=</tt>)
--   have to be lazy. Therefore the <a>SIO</a> monad is not completely
--   strict (i.e. pure values can still be lazy). So in this module we
--   expose the <a>return'</a> function that forces the given value before
--   putting it into the monad.
--   
--   Since this module uses the same names as <a>System.IO</a>, it is
--   designed to be imported <i>qualified</i>.
--   
--   <pre>
--   import System.IO.Strict (SIO)
--   import qualified System.IO.Strict as SIO
--   </pre>
module System.IO.Strict
data SIO a

-- | <a>run</a> allows to return to the wider world of <a>IO</a>s.
run :: NFData sa => SIO sa -> IO sa

-- | A stricter version of <a>return</a>, that works for every monad.
return' :: (Monad m, NFData sa) => sa -> m sa

-- | Note that <a>getContents</a> is stricter than its counterpart in
--   <a>System.IO</a>.
getContents :: SIO String

-- | Note that <a>hGetContents</a> is stricter than its counterpart in
--   <a>System.IO</a>.
hGetContents :: Handle -> SIO String

-- | Note that <a>readFile</a> is stricter than its counterpart in
--   <a>System.IO</a>.
readFile :: FilePath -> SIO String

-- | Note that <a>read</a> is stricter than its counterpart in
--   <a>System.IO</a>.
read :: (NFData sa, Read sa) => String -> SIO sa

-- | Note that <a>readLn</a> is stricter than its counterpart in
--   <a>System.IO</a>.
readLn :: (NFData sa, Read sa) => SIO sa

-- | Note that <a>fix</a> is stricter than its counterpart in
--   <a>System.IO</a>.
fix :: NFData sa => (sa -> SIO sa) -> SIO sa

-- | Note that <a>withBinaryFile</a> is stricter than its counterpart in
--   <a>System.IO</a>.
withBinaryFile :: NFData sr => FilePath -> IOMode -> (Handle -> SIO sr) -> SIO sr

-- | Note that <a>withFile</a> is stricter than its counterpart in
--   <a>System.IO</a>.
withFile :: NFData sr => FilePath -> IOMode -> (Handle -> SIO sr) -> SIO sr
appendFile :: FilePath -> String -> SIO ()
getChar :: SIO Char
getLine :: SIO String
hPrint :: Show a => Handle -> a -> SIO ()
hPutStrLn :: Handle -> String -> SIO ()
hReady :: Handle -> SIO Bool
interact :: (String -> String) -> SIO ()
openBinaryTempFile :: FilePath -> String -> SIO (FilePath, Handle)
openTempFile :: FilePath -> String -> SIO (FilePath, Handle)
print :: Show a => a -> SIO ()
putChar :: Char -> SIO ()
putStr :: String -> SIO ()
putStrLn :: String -> SIO ()
writeFile :: FilePath -> String -> SIO ()
hClose :: Handle -> SIO ()
hFileSize :: Handle -> SIO Integer
hFlush :: Handle -> SIO ()
hGetBuf :: Handle -> Ptr a -> Int -> SIO Int
hGetBufNonBlocking :: Handle -> Ptr a -> Int -> SIO Int
hGetBuffering :: Handle -> SIO BufferMode
hGetChar :: Handle -> SIO Char
hGetEcho :: Handle -> SIO Bool
hGetLine :: Handle -> SIO String
hGetPosn :: Handle -> SIO HandlePosn
hIsClosed :: Handle -> SIO Bool
hIsEOF :: Handle -> SIO Bool
hIsOpen :: Handle -> SIO Bool
hIsReadable :: Handle -> SIO Bool
hIsSeekable :: Handle -> SIO Bool
hIsTerminalDevice :: Handle -> SIO Bool
hIsWritable :: Handle -> SIO Bool
hLookAhead :: Handle -> SIO Char
hPutBuf :: Handle -> Ptr a -> Int -> SIO ()
hPutBufNonBlocking :: Handle -> Ptr a -> Int -> SIO Int
hPutChar :: Handle -> Char -> SIO ()
hPutStr :: Handle -> String -> SIO ()
hSeek :: Handle -> SeekMode -> Integer -> SIO ()
hSetBinaryMode :: Handle -> Bool -> SIO ()
hSetBuffering :: Handle -> BufferMode -> SIO ()
hSetEcho :: Handle -> Bool -> SIO ()
hSetFileSize :: Handle -> Integer -> SIO ()
hSetPosn :: HandlePosn -> SIO ()
hShow :: Handle -> SIO String
hTell :: Handle -> SIO Integer
hWaitForInput :: Handle -> Int -> SIO Bool
isEOF :: SIO Bool
openBinaryFile :: FilePath -> IOMode -> SIO Handle
openFile :: FilePath -> IOMode -> SIO Handle
stderr :: Handle
stdin :: Handle
stdout :: Handle
