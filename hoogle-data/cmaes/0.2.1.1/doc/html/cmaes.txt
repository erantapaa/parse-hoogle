-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | CMA-ES wrapper in Haskell
--   
--   <tt>cmaes</tt> is a wrapper for Covariance Matrix Adaptation Evolution
--   Strategy(CMA-ES), an evolutionary algorithm for difficult non-linear
--   non-convex optimization problems in continuous domain. To use this
--   package you need python2 with numpy available on your system. The
--   package includes <tt>cma.py</tt> , Nikolaus Hansen's production-level
--   CMA library:
--   <a>http://www.lri.fr/~hansen/cmaes_inmatlab.html#python</a>.
--   
--   This package is an aggregate of programs. cma.py (c) Nikolaus Hansen,
--   2008-2012 is redistributed under GPL 2 or 3. All the other components
--   (c) Takayuki Muranushi are licensed under MIT license. See the files
--   LICENSE.GPL2, LICENSE.GPL3 and LICENSE.MIT for more details.
@package cmaes
@version 0.2.1.1


-- | Usage:
--   
--   <ol>
--   <li>create an optimization problem of type <a>Config</a> by one of
--   <a>minimize</a>, <a>minimizeIO</a> etc.</li>
--   <li><a>run</a> it.</li>
--   </ol>
--   
--   Let's optimize the following function <i>f(xs)</i>. <tt>xs</tt> is a
--   list of Double and <tt>f</tt> has its minimum at <tt>xs !! i =
--   sqrt(i)</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; import Test.DocTest.Prop
--   
--   &gt;&gt;&gt; let f = sum . zipWith (\i x -&gt; (x*abs x - i)**2) [0..] :: [Double] -&gt; Double
--   
--   &gt;&gt;&gt; let initXs = replicate 10 0                            :: [Double]
--   
--   &gt;&gt;&gt; bestXs &lt;- run $ minimize f initXs
--   
--   &gt;&gt;&gt; assert $ f bestXs &lt; 1e-10
--   </pre>
--   
--   If your optimization is not working well, try:
--   
--   <ul>
--   <li>Set <a>scaling</a> in the <a>Config</a> to the appropriate search
--   range of each parameter.</li>
--   <li>Set <a>tolFun</a> in the <a>Config</a> to the appropriate scale of
--   the function values.</li>
--   </ul>
--   
--   An example for scaling the function value:
--   
--   <pre>
--   &gt;&gt;&gt; let f2 xs = (/1e100) $ sum $ zipWith (\i x -&gt; (x*abs x - i)**2) [0..] xs
--   
--   &gt;&gt;&gt; bestXs &lt;- run $ (minimize f2 $ replicate 10 0) {tolFun = Just 1e-111}
--   
--   &gt;&gt;&gt; assert $ f2 bestXs &lt; 1e-110
--   </pre>
--   
--   An example for scaling the input values:
--   
--   <pre>
--   &gt;&gt;&gt; let f3 xs = sum $ zipWith (\i x -&gt; (x*abs x - i)**2) [0,1e100..] xs
--   
--   &gt;&gt;&gt; let xs30 = replicate 10 0 :: [Double]
--   
--   &gt;&gt;&gt; let m3 = (minimize f3 xs30) {scaling = Just (repeat 1e50)}
--   
--   &gt;&gt;&gt; xs31 &lt;- run $ m3
--   
--   &gt;&gt;&gt; assert $ f3 xs31 / f3 xs30 &lt; 1e-10
--   </pre>
--   
--   Use <a>minimizeT</a> to optimize functions on traversable structures.
--   
--   <pre>
--   &gt;&gt;&gt; import qualified Data.Vector as V
--   
--   &gt;&gt;&gt; let f4 = V.sum . V.imap (\i x -&gt; (x*abs x - fromIntegral i)**2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :t f4
--   f4 :: V.Vector Double -&gt; Double
--   
--   &gt;&gt;&gt; bestVx &lt;- run $ minimizeT f4 $ V.replicate 10 0
--   
--   &gt;&gt;&gt; assert $ f4 bestVx &lt; 1e-10
--   </pre>
--   
--   Or use <a>minimizeG</a> to optimize functions of any type that is Data
--   and that contains <a>Double</a>s. Here is an example that deal with
--   Triangles.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDeriveDataTypeable
--   
--   &gt;&gt;&gt; import Data.Data
--   
--   &gt;&gt;&gt; data Pt = Pt Double Double deriving (Typeable,Data)
--   
--   &gt;&gt;&gt; let dist (Pt ax ay) (Pt bx by) = ((ax-bx)**2 + (ay-by)**2)**0.5
--   
--   &gt;&gt;&gt; data Triangle = Triangle Pt Pt Pt deriving (Typeable,Data)
--   </pre>
--   
--   Let us create a triangle ABC so that AB = 3, AC = 4, BC = 5.
--   
--   <pre>
--   &gt;&gt;&gt; let f5 (Triangle a b c) = (dist a b - 3.0)**2 + (dist a c - 4.0)**2 + (dist b c - 5.0)**2
--   
--   &gt;&gt;&gt; let triangle0 = Triangle o o o where o = Pt 0 0
--   
--   &gt;&gt;&gt; :t f5
--   f5 :: Triangle -&gt; Double
--   
--   &gt;&gt;&gt; bestTriangle &lt;- run $ (minimizeG f5 triangle0){tolFun = Just 1e-20}
--   
--   &gt;&gt;&gt; assert $ f5 bestTriangle &lt; 1e-10
--   </pre>
--   
--   Then the angle BAC should be orthogonal.
--   
--   <pre>
--   &gt;&gt;&gt; let (Triangle (Pt ax ay) (Pt bx by) (Pt cx cy)) = bestTriangle
--   
--   &gt;&gt;&gt; assert $ abs ((bx-ax)*(cx-ax) + (by-ay)*(cy-ay)) &lt; 1e-10
--   </pre>
--   
--   When optimizing noisy functions, set <a>noiseHandling</a> =
--   <tt>True</tt> (and increase <a>noiseReEvals</a>) for better results.
--   
--   <pre>
--   &gt;&gt;&gt; import System.Random
--   
--   &gt;&gt;&gt; let noise = randomRIO (0,1e-2)
--   
--   &gt;&gt;&gt; let f6Pure = sum . zipWith (\i x -&gt; (x*abs x - i)**2) [0..]
--   
--   &gt;&gt;&gt; let f6 xs = fmap (f6Pure xs +) noise
--   
--   &gt;&gt;&gt; :t f6
--   f6 :: [Double] -&gt; IO Double
--   
--   &gt;&gt;&gt; xs60 &lt;- run $ (minimizeIO f6 $ replicate 10 0) {noiseHandling = False}
--   
--   &gt;&gt;&gt; xs61 &lt;- run $ (minimizeIO f6 $ replicate 10 0) {noiseHandling = True,noiseReEvals=Just 10}
--   
--   &gt;&gt;&gt; -- assert $ f6Pure xs61 &lt; f6Pure xs60
--   </pre>
--   
--   (note : the above assertion holds with probability of about 70%.)
module Numeric.Optimization.Algorithms.CMAES

-- | Execute the optimizer and get the solution.
run :: Config tgt -> IO tgt

-- | Optimizer configuration. <tt>tgt</tt> is the type of the value to be
--   optimized.
data Config tgt
Config :: (tgt -> IO Double) -> (tgt -> [Double]) -> ([Double] -> tgt) -> [Double] -> Double -> Maybe [Double] -> Maybe [Double] -> Bool -> Maybe Int -> Maybe Double -> Maybe Double -> Maybe Double -> Maybe Double -> Maybe Int -> Maybe Double -> Bool -> [(String, String)] -> Config tgt

-- | The Function to be optimized.
funcIO :: Config tgt -> tgt -> IO Double

-- | Extract the parameters to be tuned from <tt>tgt</tt>.
projection :: Config tgt -> tgt -> [Double]

-- | Create a value of type <tt>tgt</tt> from the parameters.
embedding :: Config tgt -> [Double] -> tgt

-- | An initial guess of the parameters.
initXs :: Config tgt -> [Double]

-- | The global scaling factor.
sigma0 :: Config tgt -> Double

-- | Typical deviation of each input parameters. The length of the list is
--   adjusted to be the same as initXs, e.g. you can lazily use an infinite
--   list here.
scaling :: Config tgt -> Maybe [Double]

-- | Typical mean of each input parameters. The length of this list too, is
--   adjusted to be the same as initXs.
typicalXs :: Config tgt -> Maybe [Double]

-- | Assume the function to be rugged and/or noisy
noiseHandling :: Config tgt -> Bool

-- | How many re-evaluation to make to estimate the noise.
noiseReEvals :: Config tgt -> Maybe Int

-- | Perturb the parameters by this amount (relative to sigma) to estimate
--   the noise
noiseEps :: Config tgt -> Maybe Double

-- | Terminate when one of the scaling grew too big (initial scaling was
--   too small.)
tolFacUpX :: Config tgt -> Maybe Double

-- | Terminate when the global scaling grew too big.
tolUpSigma :: Config tgt -> Maybe Double

-- | Terminate when the function value diversity in the current and last
--   few generations is smaller than this value
tolFun :: Config tgt -> Maybe Double

-- | Terminate when the improvement is not seen for this number of
--   iterations.
tolStagnation :: Config tgt -> Maybe Int

-- | Terminate when the deviations in the solutions are smaller than this
--   value.
tolX :: Config tgt -> Maybe Double

-- | Repeat the CMA-ES output into stderr.
verbose :: Config tgt -> Bool

-- | Interfaces for passing other configuration arguments directly to
--   <tt>cma.py</tt>
otherArgs :: Config tgt -> [(String, String)]

-- | The default <tt>Config</tt> values. Also consult the original document
--   <a>http://www.lri.fr/~hansen/pythoncma.html#-fmin</a> for default
--   values of the parameters not listed here.
defaultConfig :: Config a

-- | Create a minimizing problem, given a pure function and an initial
--   guess.
minimize :: ([Double] -> Double) -> [Double] -> Config [Double]

-- | Create a minimizing problem, given an <tt>IO</tt> function and an
--   initial guess.
minimizeIO :: ([Double] -> IO Double) -> [Double] -> Config [Double]

-- | Create a minimizing problem for a function on traversable structure
--   <tt>t</tt>.
minimizeT :: Traversable t => (t Double -> Double) -> t Double -> Config (t Double)

-- | Create a minimizing problem for an effectful function on a traversable
--   structure <tt>t</tt>.
minimizeTIO :: Traversable t => (t Double -> IO Double) -> t Double -> Config (t Double)

-- | Create a minimizing problem for a function on almost any type
--   <tt>a</tt> which contain Doubles.
minimizeG :: Data a => (a -> Double) -> a -> Config a

-- | Create a minimizing problem for an effectful function of almost any
--   type.
minimizeGIO :: Data a => (a -> IO Double) -> a -> Config a

-- | getDoubles and putDoubles are generic functions used to put [Double]
--   in and out of generic data types. Let's test them.
--   
--   <pre>
--   &gt;&gt;&gt; let d3 = (1,2,3) :: (Double,Int,Double)
--   
--   &gt;&gt;&gt; getDoubles d3
--   [1.0,3.0]
--   
--   &gt;&gt;&gt; putDoubles [4,5] d3
--   (4.0,2,5.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let complicated = ([0,1],(2,[3,4])) :: ([Double],(Double,[Double]))
--   
--   &gt;&gt;&gt; getDoubles complicated
--   [0.0,1.0,2.0,3.0,4.0]
--   
--   &gt;&gt;&gt; putDoubles [5,6,7,8,9] complicated
--   ([5.0,6.0],(7.0,[8.0,9.0]))
--   </pre>
--   
--   Putting back the obtained values should not change the data.
--   
--   <pre>
--   &gt;&gt;&gt; import Test.DocTest.Prop
--   
--   &gt;&gt;&gt; type Complicated = ([[Double]],(),(([(Double,String)]),[Double]))
--   
--   &gt;&gt;&gt; prop ((\x -&gt; putDoubles (getDoubles x) x == x) :: Complicated -&gt; Bool)
--   </pre>
--   
--   You can get the original list back after putting it.
--   
--   <pre>
--   &gt;&gt;&gt; let make3 xs = take 3 $ xs ++ [0..]
--   
--   &gt;&gt;&gt; prop ((\xs' y -&gt; let xs = make3 xs' in getDoubles (putDoubles xs y)==xs) :: [Double] -&gt; (Double,Double,Double) -&gt; Bool)
--   </pre>
getDoubles :: Data a => a -> [Double]
putDoubles :: Data a => [Double] -> a -> a
