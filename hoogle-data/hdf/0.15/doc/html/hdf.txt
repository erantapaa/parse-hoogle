-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | HDF: Uniform Rate Audio Signal Processing in Haskell
--   
@package hdf
@version 0.15


-- | Unique identifiers.
module Sound.DF.Uniform.LL.UId

-- | Identifiers are integers.
type Id = Int

-- | Class of monads generating identifers
class Monad m => UId m
generateId :: UId m => m Id

-- | Evaluate <i>m</i> <tt>DF</tt>.
evalId :: State Id a -> a
instance UId (State Id)
instance UId IO


-- | Data flow wire values.
module Sound.DF.Uniform.LL.K

-- | Vector identifier.
data V_Id
V_Id :: Id -> V_Id

-- | Vector type.
data Vec a
Vec :: V_Id -> Int -> [a] -> Vec a

-- | <a>Id</a> of <a>V_Id</a> of <a>Vec</a>.
vec_id :: Vec t -> Id

-- | Concise pretty printer and <a>Show</a> instance for <a>Vec</a>.
--   
--   <pre>
--   vec_concise (Vec (V_Id 0) 1 [0]) == "vec(0,1)"
--   </pre>
vec_concise :: Vec a -> String

-- | Sum type for wire values. N = nil, B = boolean, I = integer, F =
--   floating point, V = vector (array).
data K
N :: () -> K
B :: Bool -> K
I :: Int32 -> K
F :: Float -> K
V :: (Vec Float) -> K

-- | <a>Typeable</a> instance for <a>K</a>.
--   
--   map k_typeOf [B False,I 0,F 0.0] == [bool_t,int32_t,float_t]
k_typeOf :: K -> TypeRep

-- | Concise pretty printer and <a>Show</a> instance for <a>K</a>.
k_concise :: K -> String

-- | <a>typeOf</a> <tt>()</tt>.
nil_t :: TypeRep

-- | <a>typeOf</a> of <a>Bool</a>.
bool_t :: TypeRep

-- | <a>typeOf</a> of <a>Int32</a>.
int32_t :: TypeRep

-- | <a>typeOf</a> of <a>Float</a>.
float_t :: TypeRep

-- | <a>typeOf</a> of (<a>Vec</a> <a>Float</a>).
vec_float_t :: TypeRep

-- | Class for values that can be lifted to <a>K</a>.
class (Typeable a, Eq a, Ord a, Show a) => K' a
to_k :: K' a => a -> K

-- | Composite of <a>Ord</a> and <a>K'</a>.
class (K' a, Ord a) => K_Ord a

-- | Composite of <a>K_Ord</a> and <a>Num</a>.
class (K_Ord a, Num a) => K_Num a
instance Typeable Vec
instance Typeable K
instance Eq V_Id
instance Ord V_Id
instance Show V_Id
instance Eq a => Eq (Vec a)
instance Ord a => Ord (Vec a)
instance Show a => Show (Vec a)
instance Eq K
instance K_Num Float
instance K_Num Int32
instance K_Ord Float
instance K_Ord Int32
instance K_Ord Bool
instance K' (Vec Float)
instance K' Float
instance K' Int32
instance K' Bool
instance K' ()
instance Show K


-- | Elementary dot.
module Sound.DF.Uniform.LL.Dot

-- | Map from <a>TypeRep</a> to colour name.
--   
--   <pre>
--   map (ty_colour . Just) [int32_t,float_t] == ["orange","blue"]
--   </pre>
ty_colour :: Maybe TypeRep -> String

-- | Left &amp; right bracket.
--   
--   <pre>
--   w_bracket '(' ')' "parentheses" == "(parentheses)"
--   </pre>
w_bracket :: a -> a -> [a] -> [a]

-- | Dot notation for <i>key,value</i> attributes.
dot_attr :: [(String, String)] -> String

-- | Dot node as <i>record</i>. Constant values are drawn directly into
--   input ports. The <i>nm</i> <a>String</a> has the <tt>df_</tt> prefix
--   removed for printing.
--   
--   <pre>
--   dot_rec 0 "nm" [] (Just float_t)
--   </pre>
dot_rec :: Id -> String -> [Either Int K] -> Maybe TypeRep -> String

-- | Make arguments input for <a>dot_rec</a> from arity.
dot_rec_ar :: Int -> [Either Int K]

-- | Variant where <a>nil_t</a> indicates no output.
dot_rec' :: Id -> String -> [Either Int K] -> TypeRep -> String


-- | OSC graph commands.
module Sound.DF.Uniform.LL.Command

-- | Load graph.
g_load :: String -> Message

-- | Unload graph.
g_unload :: Message


-- | C code generator
module Sound.DF.Uniform.LL.CGen

-- | C comment.
type C_Comment = String

-- | Add comment markers.
--   
--   <pre>
--   c_comment "c" == "/* c */"
--   </pre>
c_comment :: String -> C_Comment

-- | C type.
type C_Type = String

-- | Translate <a>TypeRep</a> to <a>C_Type</a>.
--   
--   <pre>
--   c_typerep_ctype bool_t == "bool"
--   c_typerep_ctype (typeOf (0.0::Float)) == "float"
--   </pre>
c_typerep_ctype :: TypeRep -> C_Type

-- | Qualified name, (structure,access,member).
type C_QName = (String, String, String)
var_fld_initialiser :: Var_Fld -> String

-- | Initialise <a>C_QName</a> to value.
--   
--   <pre>
--   c_init_atom ("s",".","r") 5 == "s.m = 5;"
--   </pre>
c_init_atom :: C_QName -> Var_Fld -> String

-- | Initialise <a>C_QName</a> to array. Generates loop code for sequences
--   of equal initial values.
--   
--   <pre>
--   c_init_vec ("s",".","r") [0,1] == ["s.r[0] = 0;"
--                                     ,"s.r[1] = 1;"]
--   </pre>
--   
--   <pre>
--   let r = ["for(int i=0;i &lt; 2;i++) {s.r[i] = 0;}"]
--   in c_init_vec ("s",".","r") [0,0] == r
--   </pre>
c_init_vec :: (Eq a, Show a) => C_QName -> [a] -> [String]

-- | Initialise <a>C_QName</a> to value or array.
--   
--   <pre>
--   let {qn = ("s","-&gt;","r")
--       ;r = ["for(int i=0;i &lt; 2;i++) {s-&gt;r[i] = 0;}","s-&gt;r[2] = 1;"]}
--   in c_init_var qn (Right [0,0,1]) == r
--   </pre>
c_init_var :: C_QName -> Var_Fld -> [String]

-- | Qualify name if required. The <i>rf</i> flag indicates if array is a
--   reference or an allocation.
--   
--   <pre>
--   c_array_qual (Vec_Port float_t 3) "a" True == "*a"
--   c_array_qual (Vec_Port float_t 3) "a" False == "a[3]"
--   </pre>
c_array_qual :: Maybe Int -> String -> Bool -> String

-- | C function call. (comment?,function,arguments)
type C_Call = (Maybe String, String, [(Var_Ty, Id)])

-- | Construct a function/macro call.
--   
--   <pre>
--   c_call (Nothing,"f",["0","1"]) == "f(0,1);"
--   c_call ("c","f",["0","1"]) == "f(0,1); /* c */"
--   </pre>
c_call :: C_Call -> String

-- | Enumeration of variable types.
data Var_Ty
Rec_Var :: Var_Ty
Std_Var :: Var_Ty
Buf_Var :: Int -> Var_Ty

-- | The character prefix for a <a>Var</a> name is given by the
--   <a>Var_Ty</a>.
var_ty_char :: Var_Ty -> Char
data Var_Fld
Var_F :: Float -> Var_Fld
Var_V :: [Float] -> Var_Fld
Var_B :: Bool -> Var_Fld
Var_I :: Int32 -> Var_Fld

-- | (Type,Array,Label,Initialised)
type Var = (Var_Ty, TypeRep, Id, Maybe Var_Fld)

-- | <a>Var</a> name.
var_nm :: Var -> String

-- | Non-<a>Std_Var</a> are stateful, ie. <a>Rec_Var</a> and
--   <a>Buf_Var</a>.
is_stateful :: Var -> Bool

-- | <a>Rec_Var</a> are stateful and <i>atom</i>s.
is_stateful_atom :: Var -> Bool

-- | Generate <a>Var</a> from <a>K</a>.
k_var :: Id -> Var_Ty -> K -> Var

-- | Generate <a>Buf_Var</a> from <a>Vec</a>.
buffer_var :: Id -> Vec Float -> Var

-- | <a>c_init_var</a> of <a>Var</a>.
var_init :: String -> String -> Var -> [String]

-- | <a>Var</a> C declaration, <i>rf</i> determines <a>c_array_qual</a>
--   form.
var_decl :: Bool -> Var -> String

-- | Generate a C <tt>struct</tt> for <a>Var</a>, predicate determines if
--   array variables are refernces or allocations.
gen_var_struct :: String -> (Var -> Bool) -> [Var] -> [String]

-- | Construct an identifier.
--   
--   <pre>
--   clabel (Std_Var,0) == "n_0"
--   </pre>
clabel :: (Var_Ty, Id) -> String

-- | <a>clabel</a> of <a>Std_Var</a>.
--   
--   <pre>
--   std_clabel 0 == "n_0"
--   </pre>
std_clabel :: Id -> String

-- | Variant with <tt>m.</tt> prefix.
m_clabel :: (Var_Ty, Id) -> String

-- | <a>c_init_var</a> for constant.
--   
--   <pre>
--   c_const (0,I 1) == ["m.n_0 = 1;"]
--   </pre>
c_const :: (Id, K) -> [String]

-- | C declarations for DSP functions (memreq,init and step).
dsp_fun_decl :: [String]

-- | The structure for all memory stores. In the uniform model this is a
--   notational convenience only. In a partioned model it is functional.
cmem :: [Var] -> [String]

-- | The structure for stateful <a>Var</a>.
cstate :: [Var] -> [String]

-- | Generate dsp_memreq function.
dsp_memreq :: [String]

-- | Generate dsp_init function.
dsp_init :: [Var] -> [String]

-- | List of constants, list of variables, list of c-calls.
type Instructions = ([(Id, K)], [Var], [C_Call])

-- | Generate <tt>dsp_step</tt> function.
dsp_step :: Instructions -> [String]

-- | Generate C code for graph.
code_gen :: Host -> Instructions -> String

-- | Enumeration of code hosts.
data Host
JACK :: Host
SC3 :: Host
Text :: Host

-- | Host specific <tt>#include</tt> file.
host_include :: Host -> String

-- | Host specific form of <a>dsp_fun_decl</a> (<tt>extern C</tt> where
--   required).
host_dsp_fun_decl :: Host -> [String]

-- | Generate compiler command for <a>Host</a> given <tt>include</tt>
--   directory prefix.
host_compiler_cmd :: (Host, FilePath) -> (String, [String])

-- | Format <a>host_compiler_cmd</a> as <a>String</a>.
--   
--   <pre>
--   host_compiler_cmd_str (JACK,"/home/rohan/opt")
--   host_compiler_cmd_str (SC3,"/home/rohan/opt")
--   host_compiler_cmd_str (Text,"/home/rohan/opt")
--   </pre>
host_compiler_cmd_str :: (Host, FilePath) -> String

-- | Generate C code, write file to disk and call the GNU C compiler to
--   build shared library.
dl_gen :: FilePath -> (Host, FilePath) -> Instructions -> IO ()

-- | Bracket list with elements.
--   
--   <pre>
--   bracket ('&lt;','&gt;') "float" == "&lt;float&gt;"
--   </pre>
bracket :: (a, a) -> [a] -> [a]

-- | Integrate, with implicit <tt>0</tt>.
--   
--   <pre>
--   dx_d [5,6] == [0,5,11]
--   </pre>
dx_d :: Num n => [n] -> [n]
instance Eq Var_Ty
instance Show Var_Ty


-- | Interaction with <tt>jack-dl</tt>, <tt>scsynth</tt> and
--   <tt>text-dl</tt>. See <a>http://rd.slavepianos.org/?t=rju</a>.
module Sound.DF.Uniform.LL.Audition

-- | Local definition of RDL UGen, to avoid dependency on sc3-rdu.
rdl :: Int -> UGen -> UGen

-- | Run action with <tt>UDP</tt> link to <tt>jack-dl</tt>.
with_jack_dl :: Connection UDP a -> IO a

-- | Audition graph after sending initialisation messages.
audition_rju :: [Message] -> Instructions -> IO ()

-- | Load graph.
u_cmd_g_load :: Int -> Int -> String -> Message

-- | Audition graph after sending initialisation messages.
audition_sc3 :: [Message] -> Instructions -> IO ()

-- | Audition at <tt>text-dl</tt>.
audition_text :: Int -> Instructions -> IO ()


-- | Untyped <i>DF</i>.
module Sound.DF.Uniform.UDF

-- | Recursion identifier.
data R_Id
R_Id :: Id -> R_Id
from_r_id :: R_Id -> Id

-- | Un-typed data-flow node. K = constant, A = array, R = recursion, P =
--   primitive, MRG = multiple root graph.
data UDF
UDF_K :: K -> UDF
udf_k :: UDF -> K
UDF_A :: Vec Float -> UDF
udf_a :: UDF -> Vec Float
UDF_R :: R_Id -> (Either K (UDF, UDF)) -> UDF
UDF_P :: String -> TypeRep -> [UDF] -> UDF
UDF_MRG :: UDF -> UDF -> UDF

-- | Concise pretty printer for <a>UDF</a>.
udf_concise :: UDF -> String

-- | Maybe variant of <a>udf_k</a>.
udf_k' :: UDF -> Maybe K

-- | List elements in left biased order.
udf_elem :: UDF -> [UDF]

-- | Output type of <a>UDF</a>.
udf_typeOf :: UDF -> TypeRep

-- | Traversal with state, signature as <a>mapAccumL</a>.
udf_traverse :: (st -> UDF -> (st, UDF)) -> st -> UDF -> (st, UDF)

-- | Index for input port.
type Port_Index = Int

-- | A node is a <a>UDF</a> with associated <a>Id</a>.
type Node = (Id, UDF)

-- | Enumeration of <a>Edge</a> types.
data Edge_Ty
Normal_Edge :: Edge_Ty

-- | Edge <i>to</i> recWr node
Rec_Wr_Edge :: Id -> Edge_Ty

-- | Edge <i>from</i> recRd node
Rec_Rd_Edge :: Id -> Edge_Ty

-- | Edge <i>to</i> recRd node (from recWr)
Implicit_Edge :: Int -> Edge_Ty

-- | Pretty printer for <a>Edge_Ty</a>, and <a>Show</a> instance.
edge_ty_concise :: Edge_Ty -> String

-- | Edge from left hand side node to right hand side port.
type Edge = (Id, Id, (Port_Index, Edge_Ty))

-- | A graph is a list of <a>Node</a>s and <a>Edge</a>s.
type Graph = ([Node], [Edge])

-- | A variant graph form associating the list of <i>in</i> edges with each
--   <a>Node</a>.
type Analysis = [(Node, [Edge])]

-- | <a>Id</a> of <a>Node</a>.
node_id :: Node -> Id

-- | <a>UDF</a> of <a>Node</a>.
node_udf :: Node -> UDF

-- | Read label of node.
label :: [Node] -> UDF -> Id

-- | Transform node to source, see through <a>UDF_R</a> (rec) and
--   <a>UDF_MRG</a> (mrg).
source :: [Node] -> UDF -> Id

-- | Type of <i>out</i> edge of <a>UDF</a>.
udf_edge_ty :: UDF -> Edge_Ty

-- | List <i>incoming</i> node edges.
edges :: [Node] -> UDF -> [Edge]

-- | True if <a>Node</a> is <a>Right</a> form of <a>UDF_R</a> with
--   indicated <a>R_Id</a>.
match_rec :: R_Id -> Node -> Bool

-- | Implicit edge from wR to rW.
implicit_edge :: [Node] -> Node -> Maybe Edge

-- | Is <a>Node</a> <a>UDF_K</a>.
is_k_node :: Node -> Bool

-- | An <a>Edge</a> is orphaned if it refers to a <a>Node</a> that is not
--   in the node list.
is_orphan_edge :: [Node] -> Edge -> Bool

-- | Transform the actual graph into a viewing graph by adding implicit
--   edges from <i>recWr</i> to <i>recRd</i> nodes.
vgraph_impl :: Graph -> Graph

-- | Find edge with indicated right hand side port.
find_in_edge_m :: [Edge] -> (Id, Port_Index) -> Maybe Edge

-- | Variant of <a>find_in_edge_m</a> that <a>error</a>s.
find_in_edge :: [Edge] -> (Id, Port_Index) -> Edge

-- | Trace in edges until arrival at a <a>Rec_Wr_Edge</a> that is not
--   proceeded by an <a>Implicit_Edge</a>. This traces the <i>depth</i> of
--   the chain, however that is not currently drawn.
solve_rec_edge :: Int -> [Edge] -> (Id, Port_Index) -> (Int, Id)

-- | Transform <a>Rec_Rd_Edge</a> to resolved <a>Implicit_Edge</a>.
implicit_edge' :: [Edge] -> Edge -> Maybe Edge

-- | Is <a>Node</a> <a>UDF_R</a>.
is_rec_node :: Node -> Bool

-- | Transform the actual graph into a viewing graph by deleting
--   <i>recWr</i> and <i>recRd</i> nodes and drawing a direct backward
--   edge.
vgraph_direct :: Graph -> Graph

-- | Label nodes and list incoming edges. Multiple-root and
--   multiple-channel nodes are erased.
--   
--   <pre>
--   analyse (udf_elem c)
--   </pre>
analyse :: [UDF] -> Analysis

-- | Generate graph (node list and edge list).
--   
--   <pre>
--   import Sound.DF.Uniform.GADT
--   import qualified Sound.DF.Uniform.UDF as U
--   </pre>
--   
--   <pre>
--   let g = iir1 (0.0::Float) (+) 1
--   let c = df_erase g
--   </pre>
--   
--   <pre>
--   map U.udf_concise (U.udf_elem c)
--   &gt; [recWr,df_add:Float,1.0,recRd:0.0,df_add:Float,1.0,recRd:0.0]
--   </pre>
--   
--   <pre>
--   U.vgraph_direct (U.graph c)
--   &gt; ([(1,wR_1),(2,df_add:Float),(3,1.0),(4,rR_1:0.0)]
--   &gt; ,[(2,1,0),(3,2,0),(4,2,1)])
--   </pre>
--   
--   <pre>
--   U.draw c
--   </pre>
graph :: UDF -> Graph

-- | FGL graph with <a>UDF</a> label.
type Gr = Gr UDF (Port_Index, Edge_Ty)

-- | FGL graph with pretty-printed <a>UDF</a> label.
type Gr' = Gr String (Port_Index, Edge_Ty)

-- | Generate <a>Gr</a>.
udf_gr :: Graph -> Gr

-- | Generate <a>Gr'</a>.
udf_gr' :: Graph -> Gr'

-- | Topological sort of nodes (via <a>udf_gr</a>).
tsort :: UDF -> [UDF]

-- | List of required variable declarations.
node_vars :: Node -> [Var]

-- | Possible c-call code statement.
node_c_call :: (Node, [Edge]) -> Maybe C_Call

-- | Constant nodes.
k_nodes :: [Node] -> [(Id, K)]

-- | Generate <a>Instructions</a> from <a>UDF</a>.
udf_instructions :: UDF -> Instructions

-- | <a>dl_gen</a> of <a>udf_instructions</a>.
udf_dl_gen :: FilePath -> (Host, FilePath) -> UDF -> IO ()

-- | Make <a>dot_rec</a> <i>arguments</i> input.
dot_ar :: [UDF] -> [Either Int K]

-- | Dot notation of <a>Node</a>.
dot_node :: Node -> String

-- | Edges are coloured according to their type.
edge_ty_colour :: Edge_Ty -> String

-- | Dot notation of <a>Edge</a>.
dot_edge :: Edge -> String

-- | Dot notation of <a>Graph</a>.
dot_graph :: Graph -> [String]

-- | View dot graph.
dot_draw :: String -> IO ()

-- | Draw graph, transformed by <a>vgraph_direct</a>.
draw :: UDF -> IO ()

-- | Draw graph, transformed by <a>vgraph_impl</a>.
draw' :: UDF -> IO ()

-- | Make <tt>dot</tt> rendering of graph at <a>Node</a>, via
--   <a>vgraph_direct</a>.
gr_dot :: UDF -> String

-- | Make <tt>dot</tt> rendering of graph at <a>Node</a>, via
--   <a>vgraph_impl</a>.
gr_dot' :: UDF -> String

-- | Draw graph, via <a>gr_dot</a>.
gr_draw :: UDF -> IO ()

-- | Draw graph, via <a>gr_dot'</a>.
gr_draw' :: UDF -> IO ()

-- | Audition graph after sending initialisation messages.
audition :: [Message] -> UDF -> IO ()

-- | Audition graph after sending initialisation messages.
audition_sc3 :: [Message] -> UDF -> IO ()

-- | Audition at <tt>text-dl</tt>.
audition_text :: Int -> UDF -> IO ()
instance Eq R_Id
instance Show R_Id
instance Eq UDF
instance Show UDF
instance Show Edge_Ty


-- | Faust signal processing block diagram model.
module Sound.DF.Uniform.Faust

-- | The <i>write</i> and <i>read</i> <a>Id</a>s, and the wire type.
type Rec_Id = (Id, Id, TypeRep)

-- | Block diagram.
data BD
Constant :: (Maybe Id) -> K -> BD
Prim :: (Maybe Id) -> String -> [TypeRep] -> (Maybe TypeRep) -> BD
Par :: BD -> BD -> BD
Seq :: BD -> BD -> BD
Split :: BD -> BD -> BD
Rec :: (Maybe [Rec_Id]) -> BD -> BD -> BD

-- | Read identifier.
bd_id :: BD -> Maybe Id

-- | Erroring <a>bd_id</a>.
bd_req_id :: BD -> Id

-- | Pretty printer for <a>BD</a>.
bd_pp :: BD -> String

-- | Diagram type signature, ie. <a>port_ty</a> at <a>ports</a>.
bd_signature :: BD -> ([TypeRep], [TypeRep])

-- | Type of <i>output</i> ports of <a>BD</a>.
bd_ty :: BD -> [TypeRep]

-- | Type of <i>uniform</i> output ports of <a>BD</a>.
bd_ty_uniform :: BD -> Maybe TypeRep

-- | Type of <i>singular</i> output port of <a>BD</a>.
bd_ty1 :: BD -> Maybe TypeRep

-- | Faust uses single tilde, which is reserved by <a>GHC.Exts</a>.
(~~) :: BD -> BD -> BD

-- | Faust uses comma, which is reserved by <a>Data.Tuple</a>, and indeed
--   <tt>~,</tt> is not legal either.
(~.) :: BD -> BD -> BD

-- | Faust uses <tt>:</tt>, which is reserved by <a>Data.List</a>.
(~:) :: BD -> BD -> BD

-- | Faust uses <tt>&lt;:</tt>, which is legal, however see <a>~:&gt;</a>.
(~<:) :: BD -> BD -> BD

-- | Faust uses <tt>:&gt;</tt>, however <tt>:</tt> is not allowed as a
--   prefix.
--   
--   <pre>
--   draw (graph (par_l [1,2,3,4] ~:&gt; i_mul))
--   draw (graph (par_l [1,2,3] ~:&gt; i_negate))
--   </pre>
(~:>) :: BD -> BD -> BD

-- | Fold over <a>BD</a>, signature as <a>foldl</a>.
bd_foldl :: (t -> BD -> t) -> t -> BD -> t

-- | Traversal with state, signature as <a>mapAccumL</a>.
bd_traverse :: (st -> BD -> (st, BD)) -> st -> BD -> (st, BD)

-- | <a>Rec</a> nodes introduce identifiers for each backward arc. <i>k</i>
--   is the initial <a>Id</a>, <i>n</i> the number of arcs, and <i>ty</i>
--   the arc types.
--   
--   <pre>
--   rec_ids 5 2 [int32_t,float_t] == [(5,6,int32_t),(7,8,float_t)]
--   </pre>
rec_ids :: Id -> Int -> [TypeRep] -> [Rec_Id]

-- | Set identifiers at <a>Constant</a>, <a>Prim</a>, and <a>Rec</a> nodes.
bd_set_id :: BD -> (Id, BD)

-- | Node degree as <i>(input,output)</i> pair.
type Degree = (Int, Int)

-- | <a>Degree</a> of block diagram <a>BD</a>.
degree :: BD -> Degree

-- | <a>fst</a> of <a>degree</a>.
in_degree :: BD -> Int

-- | <a>snd</a> of <a>degree</a>.
out_degree :: BD -> Int

-- | The index of an <a>Input_Port</a>, all outputs are unary.
type Port_Index = Int

-- | Port (input or output) at block diagram.
data Port
Input_Port :: BD -> Port_Index -> Port
port_bd :: Port -> BD
port_index :: Port -> Port_Index
Output_Port :: BD -> Port
port_bd :: Port -> BD

-- | The left and right <i>outer</i> ports of a block diagram.
ports :: BD -> ([Port], [Port])

-- | Type of <a>Port</a>.
port_ty :: Port -> TypeRep

-- | Enumeration of wire types.
data Wire_Ty

-- | Normal forward edge.
Normal :: Wire_Ty

-- | Backward edge.
Backward :: Rec_Id -> Wire_Ty

-- | Implicit wire from <i>recRd</i> to node.
Implicit_Normal :: Wire_Ty

-- | Implicit wire from node to <i>recWr</i>.
Implicit_Rec :: Wire_Ty

-- | Implicit wire from <i>recWr</i> to <i>recRd</i>.
Implicit_Backward :: Wire_Ty

-- | A <a>Wire</a> runs between two <tt>Ports</tt>.
type Wire = (Port, Port, Wire_Ty)

-- | Set of <a>Normal</a> wires between <a>Port</a>s.
normal_wires :: [Port] -> [Port] -> [Wire]

-- | Set of <a>Backward</a> wires between <a>Port</a>s.
rec_back_wires :: [Rec_Id] -> [Port] -> [Port] -> [Wire]

-- | Immediate internal wires of a block diagram.
wires_immed :: BD -> [Wire]

-- | Internal wires of a block diagram.
wires :: BD -> [Wire]

-- | A wire coheres if the <a>port_ty</a> of the left and right hand sides
--   are equal.
wire_coheres :: Wire -> Bool

-- | The set of non-coherent wires at diagram.
bd_non_coherent :: BD -> [Wire]

-- | Coherence predicate, ie. is <a>bd_non_coherent</a> empty.
bd_is_coherent :: BD -> Bool

-- | Primitive block diagram elements.
data Node
N_Constant :: Id -> K -> Node
n_constant_id :: Node -> Id
n_constant_k :: Node -> K
N_Prim :: Either Id (Id, Id) -> String -> Int -> Maybe TypeRep -> Node
n_prim_id :: Node -> Either Id (Id, Id)
n_prim_name :: Node -> String
n_prim_in_degree :: Node -> Int
n_prim_ty :: Node -> Maybe TypeRep

-- | Extract the current <i>actual</i> node <i>id</i> from
--   <a>n_prim_id</a>.
actual_id :: Either Id (Id, Id) -> Id

-- | Output type of <a>Node</a>, if out degree non-zero.
node_ty :: Node -> Maybe TypeRep

-- | Either <a>n_constant_id</a> or <a>actual_id</a> of <a>n_prim_id</a>.
node_id :: Node -> Id

-- | Pair <a>Node</a> <a>Id</a> with node.
node_lift_id :: Node -> (Id, Node)

-- | Pretty printer, and <a>Show</a> instance.
node_pp :: Node -> String

-- | Primitive edge, left hand <a>Id</a>, right hand side <a>Id</a>, right
--   hand <a>Port_Index</a> and edge <i>type</i>.
type Edge = (Id, Id, (Port_Index, Wire_Ty))

-- | A graph is a list of <a>Node</a> and a list of <a>Edge</a>s.
type Graph = ([Node], [Edge])

-- | Is <a>Wire_Ty</a> of <a>Edge</a> <a>Implicit_Backward</a>.
edge_is_implicit_backward :: Edge -> Bool

-- | Implicit <i>rec</i> nodes.
rec_nodes :: [Rec_Id] -> [Node]

-- | Collect all primitive nodes at a block diagram.
nodes :: Bool -> BD -> [Node]

-- | A backward <a>Wire</a> will introduce three <i>implicit</i> edges, a
--   <a>Normal</a> wire introduces one <a>Normal</a> edge.
wire_to_edges :: Bool -> Wire -> [Edge]

-- | <a>concatMap</a> of <a>wire_to_edges</a>.
wires_to_edges :: Bool -> [Wire] -> [Edge]

-- | <a>wires_to_edges</a> of <a>wires</a>.
edges :: Bool -> BD -> [Edge]

-- | Construct <a>Graph</a> of block diagram, either with or without
--   <i>implicit</i> edges.
graph' :: Bool -> BD -> Graph

-- | Construct <a>Graph</a> of block diagram without <i>implicit</i> edges.
--   This graph will include backward arcs if the graph contains
--   <i>rec</i>s.
graph :: BD -> Graph

-- | FGL graph of <a>BD</a>.
type Gr = Gr Node (Port_Index, Wire_Ty)

-- | Transform <a>BD</a> to <a>Gr</a>.
gr :: BD -> Gr

-- | Topological sort of nodes (via <a>gr</a>).
tsort :: BD -> Graph

-- | Make <tt>dot</tt> rendering of graph at <a>Node</a>.
gr_dot :: BD -> String

-- | <a>draw_dot</a> of <a>gr_dot</a>.
gr_draw :: BD -> IO ()

-- | Dot description of <a>Node</a>.
dot_node :: Node -> String

-- | Wires are coloured according to type.
wire_colour :: Wire_Ty -> String

-- | Dot description of <a>Edge</a>.
dot_edge :: Edge -> String

-- | Dot description of <a>Graph</a>.
dot_graph :: Graph -> [String]

-- | Draw dot graph.
draw_dot :: String -> IO ()

-- | <a>draw_dot</a> of <a>dot_graph</a>.
draw :: Graph -> IO ()

-- | Fold of <a>Par</a>.
--   
--   <pre>
--   degree (par_l [1,2,3,4]) == (0,4)
--   draw (graph (par_l [1,2,3,4] ~:&gt; i_mul))
--   </pre>
par_l :: [BD] -> BD

-- | Type-directed sum.
--   
--   <pre>
--   draw (graph (bd_sum [1,2,3,4]))
--   </pre>
bd_sum :: [BD] -> BD

-- | Predicate to determine if <i>p</i> can be <i>split</i> onto <i>q</i>.
split_r :: BD -> BD -> Bool

-- | <i>split</i> if diagrams cohere.
split_m :: BD -> BD -> Maybe BD

-- | <i>split</i> if diagrams cohere, else <a>error</a>. Synonym of
--   <a>~&lt;:</a>.
split :: BD -> BD -> BD

-- | If merge is legal, the number of in-edges per port at <i>q</i>.
--   
--   <pre>
--   merge_degree (par_l [1,2,3]) i_negate == Just 3
--   merge_degree (par_l [1,2,3,4]) i_mul == Just 2
--   </pre>
merge_degree :: BD -> BD -> Maybe Int

-- | <i>merge</i> if diagrams cohere.
--   
--   <pre>
--   merge_m (par_l [1,2,3]) i_negate
--   merge_m (par_l [1,2,3,4]) i_mul
--   </pre>
merge_m :: BD -> BD -> Maybe BD

-- | <i>merge</i> if diagrams cohere, else <a>error</a>. Synonym of
--   <a>~:&gt;</a>.
merge :: BD -> BD -> BD

-- | Predicate to determine if <i>p</i> can be <i>rec</i> onto <i>q</i>.
rec_r :: BD -> BD -> Bool

-- | <i>rec</i> if diagrams cohere.
rec_m :: BD -> BD -> Maybe BD

-- | <i>rec</i> if diagrams cohere, else <a>error</a>. Synonym of
--   <a>~~</a>.
rec :: BD -> BD -> BD

-- | Integer constant.
i_constant :: Int -> BD

-- | Real constant.
r_constant :: Float -> BD

-- | Construct uniform <i>type</i> primitive diagram.
u_prim :: TypeRep -> String -> Int -> BD

-- | <a>u_prim</a> of <a>int32_t</a>.
i_prim :: String -> Int -> BD

-- | <a>u_prim</a> of <a>float_t</a>.
r_prim :: String -> Int -> BD

-- | Adddition, ie. <a>+</a> of <a>Num</a>.
--   
--   <pre>
--   (1 ~. 2) ~: i_add
--   (1 :: BD) + 2
--   </pre>
i_add :: BD

-- | Adddition, ie. <a>+</a> of <a>Num</a>.
--   
--   <pre>
--   (1 ~. 2) ~: i_add
--   (1 :: BD) + 2
--   </pre>
r_add :: BD

-- | Subtraction, ie. <a>-</a> of <a>Num</a>.
i_sub :: BD

-- | Subtraction, ie. <a>-</a> of <a>Num</a>.
r_sub :: BD

-- | Multiplication, ie. <a>*</a> of <a>Num</a>.
i_mul :: BD

-- | Multiplication, ie. <a>*</a> of <a>Num</a>.
r_mul :: BD

-- | Division, ie. <a>div</a> of <a>Integral</a>.
i_div :: BD

-- | Division, ie. <a>/</a> of <a>Fractional</a>.
r_div :: BD

-- | Absolute value, ie. <a>abs</a> of <a>Num</a>.
i_abs :: BD

-- | Absolute value, ie. <a>abs</a> of <a>Num</a>.
r_abs :: BD

-- | Negation, ie. <a>negate</a> of <a>Num</a>.
i_negate :: BD

-- | Negation, ie. <a>negate</a> of <a>Num</a>.
r_negate :: BD

-- | Identity diagram.
i_identity :: BD

-- | Identity diagram.
r_identity :: BD

-- | Coerce <a>float_t</a> to <a>int32_t</a>.
float_to_int32 :: BD

-- | Coerce <a>int32_t</a> to <a>float_t</a>.
int32_to_float :: BD

-- | <a>int32_to_float</a> and then scale to be in (-1,1).
i32_to_normal_f32 :: BD

-- | Single channel output.
--   
--   <pre>
--   degree out1 == (1,0)
--   bd_signature out1 == ([float_t],[])
--   </pre>
out1 :: BD

-- | Type following unary operator.
ty_uop :: (BD -> Maybe TypeRep) -> t -> t -> BD -> t

-- | Type following binary operator.
ty_binop :: (BD -> Maybe TypeRep) -> t -> t -> BD -> BD -> t

-- | Type following math operator, uniform types.
--   
--   <pre>
--   1.0 `ty_add` 2.0 == r_add
--   (1 ~. 2) `ty_add` (3 ~. 4) == i_add
--   1.0 `ty_add` 2 == _|_
--   draw (graph ((1 ~. 2) - (3 ~. 4)))
--   </pre>
ty_add :: BD -> BD -> BD

-- | Type following math operator, uniform types.
--   
--   <pre>
--   1.0 `ty_add` 2.0 == r_add
--   (1 ~. 2) `ty_add` (3 ~. 4) == i_add
--   1.0 `ty_add` 2 == _|_
--   draw (graph ((1 ~. 2) - (3 ~. 4)))
--   </pre>
ty_div :: BD -> BD -> BD

-- | Type following math operator, uniform types.
--   
--   <pre>
--   1.0 `ty_add` 2.0 == r_add
--   (1 ~. 2) `ty_add` (3 ~. 4) == i_add
--   1.0 `ty_add` 2 == _|_
--   draw (graph ((1 ~. 2) - (3 ~. 4)))
--   </pre>
ty_mul :: BD -> BD -> BD

-- | Type following math operator, uniform types.
--   
--   <pre>
--   1.0 `ty_add` 2.0 == r_add
--   (1 ~. 2) `ty_add` (3 ~. 4) == i_add
--   1.0 `ty_add` 2 == _|_
--   draw (graph ((1 ~. 2) - (3 ~. 4)))
--   </pre>
ty_sub :: BD -> BD -> BD

-- | Type following math operator, singular types.
--   
--   <pre>
--   1.0 `ty_add1` 2.0 == r_add
--   1.0 `ty_add1` 2 == _|_
--   </pre>
ty_add1 :: BD -> BD -> BD

-- | Type following math operator, singular types.
--   
--   <pre>
--   1.0 `ty_add1` 2.0 == r_add
--   1.0 `ty_add1` 2 == _|_
--   </pre>
ty_div1 :: BD -> BD -> BD

-- | Type following math operator, singular types.
--   
--   <pre>
--   1.0 `ty_add1` 2.0 == r_add
--   1.0 `ty_add1` 2 == _|_
--   </pre>
ty_mul1 :: BD -> BD -> BD

-- | List of constants for CGen.
cg_k :: [Node] -> [(Id, K)]

-- | <a>Var</a> of <a>Node</a>.
cg_node_var :: Node -> Maybe Var

-- | Output reference for <a>Node</a>.
node_output :: Node -> Maybe (Var_Ty, Id)

-- | Input references for <a>Node</a>.
node_inputs :: [Edge] -> Node -> [(Var_Ty, Id)]

-- | <a>C_Call</a> of <a>Node</a>.
cg_node_c_call :: [Edge] -> Node -> Maybe C_Call

-- | Generate CGen <a>Instructions</a> for <a>BD</a>.
bd_instructions :: BD -> Instructions

-- | Audition graph after sending initialisation messages.
audition_rju :: [Message] -> BD -> IO ()

-- | Figure illustrating <a>~.</a>.
--   
--   <pre>
--   degree fig_3_2 == (2,2)
--   draw (graph fig_3_2)
--   </pre>
fig_3_2 :: BD

-- | Figure illustrating <a>~:</a>.
--   
--   <pre>
--   degree fig_3_3 == (4,1)
--   bd_signature fig_3_3
--   draw (graph fig_3_3)
--   </pre>
fig_3_3 :: BD

-- | Figure illustrating <a>~&lt;:</a>.
--   
--   <pre>
--   degree fig_3_4 == (0,3)
--   draw (graph fig_3_4)
--   </pre>
fig_3_4 :: BD

-- | Figure illustrating <a>~:&gt;</a>.
--   
--   <pre>
--   degree fig_3_5 == (0,1)
--   draw (graph fig_3_5)
--   </pre>
fig_3_5 :: BD

-- | Figure illustrating <a>~~</a>.
--   
--   <pre>
--   degree fig_3_6 == (0,1)
--   draw (graph fig_3_6)
--   </pre>
fig_3_6 :: BD

-- | Variant generating audible graph.
--   
--   <pre>
--   draw (graph fig_3_6')
--   gr_draw fig_3_6'
--   audition [] fig_3_6'
--   </pre>
fig_3_6' :: BD

-- | A counter, illustrating <i>identity</i> diagram.
--   
--   <pre>
--   draw (graph (i_counter ~: i_negate))
--   gr_draw (i_counter ~: i_negate)
--   </pre>
i_counter :: BD

-- | Adjacent elements of list.
--   
--   <pre>
--   adjacent [1..4] == [(1,2),(3,4)]
--   </pre>
adjacent :: [t] -> [(t, t)]

-- | Bimap at tuple.
--   
--   <pre>
--   bimap abs negate (-1,1) == (1,-1)
--   </pre>
bimap :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
instance Eq BD
instance Show BD
instance Eq Port
instance Show Port
instance Eq Wire_Ty
instance Show Wire_Ty
instance Eq Node
instance Show Node
instance Fractional BD
instance Num BD


-- | Composite of all low-level modules.
module Sound.DF.Uniform.LL


-- | Data flow nodes.
module Sound.DF.Uniform.PhT.Node

-- | Constant with phantom type.
data KT ty
KT :: K -> KT ty
kt_k :: KT ty -> K

-- | Data flow node with phantom type.
data DF ty
DF :: UDF -> DF ty
df_udf :: DF ty -> UDF

-- | Lift <a>Int32</a> to constant, ie. <a>KT</a> of <a>I</a>.
k_Int32 :: Int32 -> KT Int32

-- | Lift <a>Float</a> to constant, ie. <a>KT</a> of <a>F</a>.
k_Float :: Float -> KT Float

-- | A zero with unresolved type, ie. <a>KT</a> of <a>F</a> of <tt>0</tt>.
k_zero :: KT ty

-- | Lift <a>Int32</a> to <a>DF</a>.
df_Int32 :: Int32 -> DF Int32

-- | Lift <a>Float</a> to <a>DF</a>.
df_Float :: Float -> DF Float

-- | Tables have a guard point.
df_tbl_size :: DF a -> Maybe Int

-- | Multiple root graph.
mrg :: DF a -> DF () -> DF a

-- | <a>typeOf</a> <a>DF</a>.
df_type :: DF a -> TypeRep

-- | <a>DF</a> of <a>UDF_P</a>.
mk_a :: String -> [DF a] -> TypeRep -> DF ty

-- | Primitive unary operator.
unary_operator :: String -> DF a -> DF a

-- | Primitive binary operator.
binary_operator :: String -> DF a -> DF a -> DF a

-- | Primitive comparator.
comparison_operator :: String -> DF a -> DF a -> DF Bool

-- | Primitive sink.
sink_node :: String -> [DF a] -> DF ()

-- | Primitive unary operator with separate primitives for integral and
--   floating types.
alt_unary_operator :: (String, String) -> DF a -> DF a

-- | Lift list of float to <a>DF</a> <a>Vec</a>.
df_vec_m :: UId m => [Float] -> m (DF (Vec Float))

-- | <a>==</a>, equal to.
df_eq :: DF a -> DF a -> DF Bool

-- | <a>&lt;</a>, less than.
df_lt :: Num a => DF a -> DF a -> DF Bool

-- | <a>&gt;=</a>, greater than or equal to.
df_gte :: Num a => DF a -> DF a -> DF Bool

-- | <a>&gt;</a>, greater than.
df_gt :: Num a => DF a -> DF a -> DF Bool

-- | <a>&lt;=</a>, less than or equal to.
n_lte :: Num a => DF a -> DF a -> DF Bool

-- | ceilf(3)
df_ceilingf :: DF Float -> DF Float

-- | floorf(3)
df_floorf :: DF Float -> DF Float

-- | lrintf(3)
df_lrintf :: DF Float -> DF Int32

-- | roundf(3)
df_roundf :: DF Float -> DF Float

-- | Single channel output.
out1 :: DF Float -> DF ()

-- | Two channel output.
out2 :: DF Float -> DF Float -> DF ()

-- | Three channel output.
out3 :: DF Float -> DF Float -> DF Float -> DF ()

-- | Single control input.
ctl1 :: DF Int32 -> DF Float

-- | If <i>p</i> then <i>q</i> else <i>r</i>. <i>p</i> must have type bool,
--   and <i>q</i> and <i>r</i> must have equal types.
select2 :: DF Bool -> DF a -> DF a -> DF a

-- | Operating sample rate.
w_sample_rate :: DF Float

-- | Buffer read, read from buffer <i>p</i> at index <i>q</i>.
b_read :: DF Int32 -> DF Int32 -> DF Float

-- | Buffer write, write to buffer <i>p</i> at index <i>q</i> value
--   <i>r</i>.
b_write :: DF Int32 -> DF Int32 -> DF Float -> DF ()

-- | Array read.
a_read :: DF (Vec Float) -> DF Int32 -> DF Float

-- | Array write.
a_write :: DF (Vec Float) -> DF Int32 -> DF Float -> DF ()

-- | Introduce backward arc with implicit unit delay.
rec_r :: R_Id -> KT a -> (DF a -> (DF a, DF a)) -> DF a

-- | Monadic variant of rec_r.
rec :: UId m => KT a -> (DF a -> (DF a, DF a)) -> m (DF a)

-- | Variant or rec with monadic action in backward arc.
recm :: UId m => KT a -> (DF a -> m (DF a, DF a)) -> m (DF a)
instance Eq (KT ty)
instance Eq (DF ty)
instance Eq a => Ord (DF a)
instance Eq a => Bits (DF a)
instance Floating (DF Float)
instance Fractional (DF Float)
instance Num n => Num (DF n)


-- | Interaction with <tt>jack-dl</tt>, <tt>scsynth</tt> and
--   <tt>text-dl</tt>.
module Sound.DF.Uniform.PhT.Audition

-- | Audition graph after sending initialisation messages.
audition :: [Message] -> DF () -> IO ()

-- | Audition graph after sending initialisation messages.
audition_sc3 :: [Message] -> DF () -> IO ()

-- | Audition at <tt>text-dl</tt>.
audition_text :: Int -> DF () -> IO ()


-- | Graph drawing
module Sound.DF.Uniform.PhT.Draw

-- | View graph using graphviz.
draw :: DF a -> IO ()
drawM :: State Id (DF a) -> IO ()


-- | Top level module for <i>PhT</i> uniform rate model <tt>hdf</tt>.
module Sound.DF.Uniform.PhT


-- | Data flow nodes.
module Sound.DF.Uniform.GADT.DF

-- | Data flow node. K = constant, A = array, R = recursion, P = primitive,
--   MRG = mrg.
data DF a
K :: a -> DF a
A :: Vec Float -> DF (Vec Float)
R :: R_Id -> TypeRep -> Either a (DF b, DF a) -> DF b
P0 :: String -> TypeRep -> DF a
P1 :: String -> TypeRep -> DF a -> DF b
P2 :: String -> TypeRep -> DF a -> DF b -> DF c
P3 :: String -> TypeRep -> DF a -> DF b -> DF c -> DF d
MCE :: [DF a] -> DF a
MRG :: DF a -> DF () -> DF a

-- | Typeable instance for <a>DF</a>.
--   
--   <pre>
--   df_typeOf (K (undefined::Int32)) == int32_t
--   df_typeOf (K (undefined::Float)) == float_t
--   df_typeOf (A undefined) == vec_float_t
--   df_typeOf (0::DF Int32) == int32_t
--   df_typeOf (0.0::DF Float) == float_t
--   </pre>
df_typeOf :: K' a => DF a -> TypeRep

-- | Name of primitive if <a>DF</a> is <a>P0</a> or <a>P1</a> etc.
df_primitive :: DF a -> Maybe String

-- | Multiple root graph (alias for M).
mrg :: K' a => DF a -> DF () -> DF a

-- | <a>DF</a> <a>Vec</a> constructor.
df_vec :: V_Id -> [Float] -> DF (Vec Float)

-- | Monadic <a>DF</a> <a>Vec</a> constructor.
df_vec_m :: UId m => [Float] -> m (DF (Vec Float))

-- | <a>DF</a> <a>Vec</a> size.
df_vec_size :: DF a -> Maybe Int

-- | <a>df_vec_size</a> variant, tables have a guard point.
df_tbl_size :: DF a -> Maybe Int

-- | Unary operator.
type Unary_Op a = a -> a

-- | Binary operator.
type Binary_Op a = a -> a -> a

-- | Ternary operator.
type Ternary_Op a = a -> a -> a -> a

-- | Quaternary operator.
type Quaternary_Op a = a -> a -> a -> a -> a

-- | Quinary operator.
type Quinary_Op a = a -> a -> a -> a -> a -> a

-- | Senary operator.
type Senary_Op a = a -> a -> a -> a -> a -> a -> a

-- | Binary function.
type Binary_Fn i o = i -> i -> o

-- | MCE predicate, sees into MRG.
is_mce :: DF t -> Bool

-- | MCE degree, sees into MRG.
mce_degree :: DF t -> Int

-- | MCE extension, sees into MRG, will not reduce.
mce_extend :: Int -> DF t -> [DF t]
mce2 :: DF a -> DF a -> DF a
unmce :: DF t -> [DF t]
unmce2 :: Show t => DF t -> (DF t, DF t)
lift_mce :: (DF a -> DF b) -> DF a -> DF b
lift_mce2 :: (DF a -> DF b -> DF c) -> DF a -> DF b -> DF c
mce_extend3 :: DF a -> DF b -> DF c -> ([DF a], [DF b], [DF c])
lift_mce3 :: (DF a -> DF b -> DF c -> DF d) -> DF a -> DF b -> DF c -> DF d

-- | <a>lift_mce</a> of <a>P1</a>.
mk_p1 :: (K' a, K' b) => String -> TypeRep -> DF a -> DF b

-- | Unary operator.
mk_uop :: K' a => String -> Unary_Op (DF a)

-- | <a>lift_mce2</a> of <a>P2</a>.
mk_p2 :: (K' a, K' b, K' c) => String -> TypeRep -> DF a -> DF b -> DF c

-- | Binary operator.
mk_binop :: K' a => String -> Binary_Op (DF a)

-- | <a>lift_mce3</a> of <a>P3</a>.
mk_p3 :: (K' a, K' b, K' c, K' d) => String -> TypeRep -> DF a -> DF b -> DF c -> DF d

-- | Binary operator.
mk_ternaryop :: K' a => String -> Ternary_Op (DF a)

-- | <a>DF</a> multiply and add.
df_mul_add :: K_Num a => DF a -> DF a -> DF a -> DF a

-- | Optimising addition primitive. If either input is a multiplier node,
--   unfold to a multiplier-add node.
--   
--   <pre>
--   df_add_optimise (2 * 3) (4::DF Int32)
--   df_add_optimise (2::DF Int32) (3 * 4)
--   </pre>
df_add_optimise :: K_Num a => DF a -> DF a -> DF a

-- | <a>Data.Bits</a> <tt>.&amp;.</tt>.
df_bw_and :: DF Int32 -> DF Int32 -> DF Int32

-- | <a>Data.Bits</a> <tt>.|.</tt>.
df_bw_or :: DF Int32 -> DF Int32 -> DF Int32

-- | <a>Data.Bits</a> <tt>complement</tt>.
df_bw_not :: DF Int32 -> DF Int32

-- | <a>==</a>, equal to.
df_eq :: K_Ord a => DF a -> DF a -> DF Bool

-- | <a>&lt;</a>, less than.
df_lt :: K_Ord a => DF a -> DF a -> DF Bool

-- | <a>&gt;=</a>, greater than or equal to.
df_gte :: K_Ord a => DF a -> DF a -> DF Bool

-- | <a>&gt;</a>, greater than.
df_gt :: K_Ord a => DF a -> DF a -> DF Bool

-- | <a>&lt;=</a>, less than or equal to.
df_lte :: K_Ord a => DF a -> DF a -> DF Bool

-- | <a>max</a>, select maximum.
df_max :: K_Ord a => DF a -> DF a -> DF a

-- | <a>min</a>, select minimum.
df_min :: K_Ord a => DF a -> DF a -> DF a

-- | Cast floating point to integer.
df_float_to_int32 :: DF Float -> DF Int32

-- | Cast integer to floating point.
df_int32_to_float :: DF Int32 -> DF Float

-- | Scale <a>Int32</a> to (-1,1) normalised <a>Float</a>.
--   
--   <pre>
--   maxBound == (2147483647::Int32)
--   </pre>
i32_to_normal_f32 :: DF Int32 -> DF Float

-- | Integral modulo, ie. <a>mod</a>.
df_mod :: Binary_Op (DF Int32)

-- | Floating point modulo, ie. <a>Foreign.C.Math</a> <i>fmodf</i>.
df_fmodf :: Binary_Op (DF Float)

-- | ceilf(3)
df_ceilf :: DF Float -> DF Float

-- | floorf(3)
df_floorf :: DF Float -> DF Float

-- | lrintf(3), ie. round to nearest integer.
df_lrintf :: DF Float -> DF Int32

-- | roundf(3)
df_roundf :: DF Float -> DF Float

-- | Introduce backward arc with implicit unit delay.
--   
--   The function receives the previous output as input, initially
--   <tt>y0</tt>, and returns a <i>(feed-forward,feed-backward)</i> pair.
--   
--   <pre>
--   rec_r (R_Id 0) (0::Int32) ((\i-&gt;(i,i)) . (+) 1)
--   rec_r (R_Id 0) (0.0::Float) ((\i-&gt;(i,i)) . (+) 1.0)
--   </pre>
rec_r :: K' a => R_Id -> a -> (DF a -> (DF b, DF a)) -> DF b

-- | Monadic variant of <a>rec_r</a>.
rec_m :: (K' a, UId m) => a -> (DF a -> (DF b, DF a)) -> m (DF b)

-- | Hash-eq variant of <a>rec_r</a>.
rec_h :: (K' a, Show b) => a -> (DF a -> (DF b, DF a)) -> DF b

-- | Variant of <a>rec_m</a> with monadic action in backward arc.
rec_mM :: (K' a, UId m) => a -> (DF a -> m (DF b, DF a)) -> m (DF b)

-- | Single channel input (channel 0).
in1 :: DF Float

-- | Single channel output (channel 0).
out1 :: DF Float -> DF ()

-- | Two channel output (channels 1 &amp; 2).
out2 :: DF Float -> DF Float -> DF ()

-- | Three channel output.
out3 :: DF Float -> DF Float -> DF Float -> DF ()

-- | MCE collapsing output.
out :: DF Float -> DF ()

-- | Single control input.
ctl1 :: DF Int32 -> DF Float

-- | Logical <a>&amp;&amp;</a>.
df_and :: DF Bool -> DF Bool -> DF Bool

-- | Logical <a>||</a>.
df_or :: DF Bool -> DF Bool -> DF Bool

-- | Logical <a>not</a>.
df_not :: DF Bool -> DF Bool

-- | If <i>p</i> then <i>q</i> else <i>r</i>. <i>p</i> must have type bool,
--   and <i>q</i> and <i>r</i> must have equal types.
select2 :: K' a => DF Bool -> DF a -> DF a -> DF a

-- | Operating sample rate.
w_sample_rate :: DF Float

-- | Number of frames in current control period.
w_kr_nframes :: DF Int32

-- | <a>True</a> at first frame of each control period.
w_kr_edge :: DF Bool

-- | Buffer read, read from buffer <i>p</i> at index <i>q</i>.
b_read :: DF Int32 -> DF Int32 -> DF Float

-- | Buffer write, write to buffer <i>p</i> at index <i>q</i> value
--   <i>r</i>.
b_write :: DF Int32 -> DF Int32 -> DF Float -> DF ()

-- | Array read.
a_read :: DF (Vec Float) -> DF Int32 -> DF Float

-- | Array write.
a_write :: DF (Vec Float) -> DF Int32 -> DF Float -> DF ()

-- | Transform typed <a>DF</a> to un-typed <a>UDF</a>.
df_erase :: K' a => DF a -> UDF
instance Typeable DF
instance Show a => Show (DF a)
instance Floating (DF Float)
instance Fractional (DF Float)
instance K_Num a => Num (DF a)


-- | Interaction with <tt>jack-dl</tt>, <tt>scsynth</tt> and
--   <tt>text-dl</tt>.
module Sound.DF.Uniform.GADT.Audition

-- | Transform <a>DF</a> to <a>Instructions</a>.
df_instructions :: DF () -> Instructions

-- | Audition graph at <tt>jack-dl</tt> after sending initialisation
--   messages.
audition_rju :: [Message] -> DF () -> IO ()

-- | Audition graph at <tt>SC3</tt> after sending initialisation messages.
audition_sc3 :: [Message] -> DF () -> IO ()

-- | Audition graph at <tt>text-dl</tt>.
audition_text :: Int -> DF () -> IO ()


-- | Data flow node functions, or unit generators.
module Sound.DF.Uniform.GADT.UGen

-- | Duplicate a value into a tuple.
--   
--   <pre>
--   split 1 == (1,1)
--   </pre>
split :: a -> (a, a)

-- | Reversed tuple constructor, (ie. <tt>flip (,)</tt>)
--   
--   <pre>
--   swap 2 1 == (1,2)
--   </pre>
swap :: a -> b -> (b, a)

-- | Two pi.
--   
--   <pre>
--   two_pi == 6.283185307179586
--   </pre>
two_pi :: Floating a => a

-- | Midi note number to cycles per second.
--   
--   <pre>
--   midi_cps 69 == 440
--   </pre>
midi_cps :: Floating a => a -> a

-- | Multiply and add.
--   
--   <pre>
--   map (mul_add 2 3) [1,2] == [5,7] &amp;&amp; map (mul_add 3 4) [1,2] == [7,10]
--   </pre>
mul_add :: Num a => a -> a -> a -> a

-- | Calculate feedback multipler in comb filter circuit given <i>delay</i>
--   and <i>decay</i> times.
--   
--   <pre>
--   calc_fb 0.2 3.0 == 0.6309573444801932
--   </pre>
calc_fb :: Floating a => a -> a -> a

-- | Linear range conversion.
--   
--   <pre>
--   map (\i -&gt; lin_lin i (-1) 1 0 1) [-1,-0.9 .. 1.0]
--   </pre>
--   
--   <pre>
--   import Sound.DF.Uniform.GADT {- hdf -}
--   </pre>
--   
--   <pre>
--   let {s = lf_saw 1.0 0.0
--       ;o = sin_osc (lin_lin s (-1.0) 1.0 220.0 440.0) 0.0}
--   in audition_rju [] (out1 (o * 0.1))
--   </pre>
lin_lin :: Fractional a => a -> a -> a -> a -> a -> a

-- | Exponential range conversion.
--   
--   <pre>
--   map (\i -&gt; lin_exp i 1 2 1 3) [1,1.1 .. 2]
--   </pre>
--   
--   <pre>
--   let {s = lf_saw 0.25 0.0
--       ;o = sin_osc (lin_exp (s + 1.0) 0.0 2.0 220.0 440.0) 0.0}
--   in audition_rju [] (out1 (o * 0.1))
--   </pre>
lin_exp :: Floating a => a -> a -> a -> a -> a -> a

-- | Constrain p in (-q,q).
--   
--   <pre>
--   let r = -10 : -10 : [-10,-9 .. 10]
--   in map (flip clip2 10) [-12,-11 .. 12] == r
--   </pre>
clip2 :: (Num a, Ord a) => a -> a -> a

-- | <i>sr</i> = sample rate, <i>r</i> = cycle (two-pi), <i>hz</i> =
--   frequency
--   
--   <pre>
--   hz_to_incr 48000 128 375 == 1
--   hz_to_incr 48000 two_pi 458.3662361046586 == 6e-2
--   </pre>
hz_to_incr :: Fractional a => a -> a -> a -> a

-- | Inverse of <a>hz_to_incr</a>.
--   
--   <pre>
--   incr_to_hz 48000 128 1 == 375
--   </pre>
incr_to_hz :: Fractional a => a -> a -> a -> a

-- | Linear pan.
--   
--   <pre>
--   map (lin_pan2 1) [-1,0,1] == [(1,0),(0.5,0.5),(0,1)]
--   </pre>
--   
--   <pre>
--   let {o = sin_osc 440.0 0.0
--       ;l = sin_osc 0.5 0.0
--       ;(p,q) = lin_pan2 (o * 0.1) l}
--   in audition_rju [] (out2 p q)
--   </pre>
lin_pan2 :: Fractional t => t -> t -> (t, t)

-- | Compile time sample rate constant.
k_sample_rate :: Fractional n => n

-- | Compile time sample duration (in seconds) constant.
k_sample_dur :: Fractional n => n

-- | Environment value, <a>recip</a> of <a>w_sample_rate</a>.
w_sample_dur :: DF Float

-- | Environment value, equal to <tt><a>two_pi</a> /
--   <a>w_sample_rate</a></tt>.
w_radians_per_sample :: DF Float

-- | Add guard point.
--   
--   <pre>
--   tbl_guard [1,2,3] == [1,2,3,1]
--   </pre>
tbl_guard :: [a] -> [a]

-- | Generate guarded sin table.
--   
--   <pre>
--   map (round . (* 100)) (tbl_sin 12) == [0,50,87,100,87,50,0,-50,-87,-100,-87,-50,0]
--   </pre>
tbl_sin :: Floating n => Int -> [n]

-- | If 'q &gt;= p' then 'q - p' else <tt>q</tt>.
clipr :: K_Num a => DF a -> DF a -> DF a

-- | <a>clip2</a> variant.
--   
--   <pre>
--   let o = sin_osc 440 0
--   in audition_rju [] (out1 (df_clip2 (o * 2) 0.1))
--   </pre>
df_clip2 :: K_Num a => DF a -> DF a -> DF a

-- | Single place infinite impulse response filter with indicated initial
--   value.
--   
--   <pre>
--   import Data.Int
--   import Sound.DF.Uniform.GADT
--   import Sound.DF.Uniform.LL.K
--   </pre>
--   
--   <pre>
--   draw (iir1 (0::Int32) (+) 1)
--   draw (iir1 (0::Float) (+) 1)
--   </pre>
iir1 :: K' a => a -> (Binary_Op (DF a)) -> DF a -> DF a

-- | <i>r</i> = right hand edge, <i>ip</i> = initial phase, <i>x</i> =
--   increment
--   
--   <pre>
--   draw (phasor 9.0 (4.5::Float) 0.5)
--   draw (phasor 9 (0::Int32) 1)
--   audition_text 10 (out1 (phasor' 5.0 0.0 1.0))
--   </pre>
phasor' :: K_Num a => DF a -> a -> DF a -> DF a

-- | <a>lift_mce2</a> of <a>phasor'</a>.
phasor :: K_Num a => DF a -> a -> DF a -> DF a

-- | Allocate <i>n</i> second array, variant of <a>df_vec</a>.
a_alloc_sec :: V_Id -> Float -> DF (Vec Float)

-- | Array delay with <i>phasor</i> argument for write index.
a_delay_ph :: DF (Vec Float) -> DF Float -> DF Int32 -> DF Int32 -> DF Float

-- | Array delay. a = array, s = signal, n = number of frames.
--   
--   <pre>
--   do {a &lt;- df_vec_m [0,1,2]
--      ;draw (a_delay a 0.0 0)}
--   </pre>
--   
--   <pre>
--   let {f = sin_osc 0.1 0.0
--       ;o = sin_osc (f * 200.0 + 600.0) 0.0
--       ;a = df_vec (V_Id 0) (replicate 48000 0)
--       ;d = a_delay a o 24000}
--   in audition_rju [] (out2 (o * 0.1) (d * 0.05))
--   </pre>
a_delay :: DF (Vec Float) -> DF Float -> DF Int32 -> DF Float

-- | SC3 UGen.
delay_n :: Int -> DF Float -> Float -> DF Float -> DF Float

-- | Array fill function (sin).
--   
--   <pre>
--   let {i = phasor 64 0 1
--       ;a = a_tbl_sin (V_Id 0) 64
--       ;s = a_read a i}
--   in audition_rju [] (out1 (s * 0.2))
--   </pre>
a_tbl_sin :: V_Id -> Int -> DF (Vec Float)

-- | Linear interpolating variant of <a>a_read</a>.
--   
--   <pre>
--   let {i = phasor 64.0 0 (hz_to_incr k_sample_rate 64.0 330.0)
--       ;a = a_tbl_sin (V_Id 0) 64
--       ;s = a_lerp a i}
--   in audition_rju [] (out1 (s * 0.2))
--   </pre>
a_lerp :: DF (Vec Float) -> DF Float -> DF Float
a_tbl :: Int -> [Float] -> DF (Vec Float)

-- | <a>phasor</a> for table of <i>z</i> places. <i>ip</i> is in (0,1).
--   
--   <pre>
--   draw (phasor 64.0 (0.0::Float) (hz_to_incr k_sample_rate 64.0 330.0))
--   draw (tbl_phasor 64 0.0 330.0)
--   </pre>
tbl_phasor :: Int -> Float -> DF Float -> DF Float

-- | Table lookup oscillator. <i>ip</i> is in (0,1).
--   
--   <pre>
--   let {a = a_tbl_sin (V_Id 0) 256
--       ;f = a_osc a 4.0 0.0
--       ;o = a_osc a (f * 200.0 + 400.0) 0.0}
--   in audition_rju [] (out1 (o * 0.1))
--   </pre>
--   
--   Cancellation:
--   
--   <pre>
--   let {a = a_tbl_sin (V_Id 0) 256
--       ;o1 = a_osc a 440.0 0.0
--       ;o2 = a_osc a 440.0 0.5}
--   in audition_rju [] (out1 (o1 + o2))
--   </pre>
a_osc :: DF (Vec Float) -> DF Float -> Float -> DF Float

-- | Single sample delay with indicated initial value.
--   
--   <pre>
--   draw (unit_delay (0::Int32) 1)
--   draw (unit_delay (0.0::Float) 1.0)
--   </pre>
--   
--   <pre>
--   let {c = counter 0.0 1.0
--       ;d = unit_delay 0.0 c}
--   in audition_text 12 (out2 c d)
--   </pre>
unit_delay :: K' a => a -> DF a -> DF a

-- | Signal that is initially <a>True</a> then always <a>False</a>.
--   
--   <pre>
--   audition_text 5 (out1 (latch (white_noise 812875317) unit_trigger))
--   </pre>
unit_trigger :: DF Bool

-- | Two place infinite impulse response filter. Inputs are: <i>f</i>=
--   function <tt>(x0 y1 y2 -&gt; y0)</tt>, <i>i</i> = input signal.
--   
--   <pre>
--   let {c1 = iir2 (\x y1 _ -&gt; x + y1) 0.001
--       ;o1 = sin_osc (c1 + 220.0) 0
--       ;c2 = iir2 (\x _ y2 -&gt; x + y2) 0.001
--       ;o2 = sin_osc (c2 + 220.0) 0}
--   in audition_rju [] (out2 (o1 * 0.1) (o2 * 0.1))
--   </pre>
iir2 :: K_Num a => (Ternary_Op (DF a)) -> DF a -> DF a

-- | Single place finite impulse response filter.
fir1 :: K' a => a -> (DF a -> DF a -> DF b) -> DF a -> DF b

-- | Two place finite impulse response filter.
fir2 :: (Ternary_Op (DF Float)) -> DF Float -> DF Float

-- | Ordinary biquad filter section.
biquad :: (Quinary_Op (DF Float)) -> DF Float -> DF Float

-- | Counter from indicated initial value by indicated step.
--   
--   <pre>
--   draw (counter (0::Int32) 1)
--   draw (counter (0.0::Float) 1.0)
--   </pre>
--   
--   <pre>
--   audition_text 10 (out1 (counter 0.0 1.0))
--   audition_text 10 (out1 (counter 0.0 (white_noise 165876521 * 0.25)))
--   </pre>
counter :: K_Num a => a -> DF a -> DF a

-- | <a>counter</a> that resets to the initial phase at trigger.
--   
--   <pre>
--   let tr = trigger (impulse (k_sample_rate / 3) 0.0)
--   in audition_text 10 (out1 (counter_reset 0.0 1.0 tr))
--   </pre>
counter_reset :: K_Num a => a -> DF a -> DF Bool -> DF a

-- | Counter from 0 to 1 over duration (in seconds). Holds end value.
unit_line :: DF Float -> DF Float

-- | <a>lin_lin</a> of <a>unit_line</a>.
--   
--   <pre>
--   audition_rju [] (out1 (sin_osc (line 110 440 100) 0 * 0.1))
--   </pre>
line :: DF Float -> DF Float -> DF Float -> DF Float

-- | SC3 UGen.
--   
--   <pre>
--   audition_text 20 (out1 (counter 30 10))
--   audition_text 20 (out1 (ramp (counter 30 10) (3 / k_sample_rate)))
--   </pre>
ramp :: DF Float -> DF Float -> DF Float

-- | Buffer delay.
--   
--   <pre>
--   draw (buf_delay 0 0.0 0)
--   </pre>
buf_delay :: DF Int32 -> DF Float -> DF Int32 -> DF Float

-- | Non-interpolating comb filter. Inputs are: <i>b</i> = buffer index,
--   <i>i</i> = input signal, <i>dl</i> = delay time, <i>dc</i> = decay
--   time.
--   
--   All times are in seconds. The decay time is the time for the echoes to
--   decay by <tt>60</tt> decibels. If this time is negative then the
--   feedback coefficient will be negative, thus emphasizing only odd
--   harmonics at an octave lower.
--   
--   <pre>
--   draw (out1 (buf_comb_n 0 0.0 0.0 0.0))
--   </pre>
--   
--   Comb used as a resonator. The resonant fundamental is equal to
--   reciprocal of the delay time.
--   
--   <pre>
--   import qualified Sound.SC3 as S
--   </pre>
--   
--   <pre>
--   let {n = white_noise 0
--       ;dt = let f x = lin_exp (x + 2.0) 1.0 2.0 0.0001 0.01
--             in f (lf_saw 0.1 0.0)
--       ;c = buf_comb_n 0 (n * 0.1) dt 0.2}
--   in audition_rju [S.b_alloc 0 48000 1] (out1 c)
--   </pre>
--   
--   Comb used as an echo.
--   
--   <pre>
--   let {i = impulse 0.5 0.0
--       ;n = white_noise 0
--       ;e = decay (i * 0.5) 0.2
--       ;c = buf_comb_n 0 (e * n) 0.2 3.0}
--   in audition_rju [S.b_alloc 0 48000 1] (out1 c)
--   </pre>
buf_comb_n :: DF Int32 -> DF Float -> DF Float -> DF Float -> DF Float

-- | Array variant of <a>buf_comb_n</a>. Max delay time is in seconds.
--   
--   <pre>
--   let {n = white_noise 0
--       ;dt = let f x = lin_exp (x + 2.0) 1.0 2.0 0.0001 0.01
--             in f (lf_saw 0.1 0.0)
--       ;c = comb_n [0] 0.1 (n * 0.1) dt 0.2}
--   in audition_rju [] (out c)
--   </pre>
--   
--   <pre>
--   let {i = impulse 0.5 0.0
--       ;n = white_noise 0
--       ;e = decay (i * 0.5) 0.2
--       ;c = comb_n [0] 0.2 (e * n) 0.2 3.0}
--   in audition_rju [] (out c)
--   </pre>
comb_n' :: V_Id -> Float -> DF Float -> DF Float -> DF Float -> DF Float

-- | Allow MCE.
comb_n :: [Int] -> Float -> DF Float -> DF Float -> DF Float -> DF Float
allpass_n' :: V_Id -> Float -> DF Float -> DF Float -> DF Float -> DF Float
silent :: DF Float

-- | <a>Int32</a> linear congruential generator, hence signed modulo of
--   <tt>2^32</tt>. Note that the state and all internal math is 32bit.
--   
--   See <a>http://en.wikipedia.org/wiki/Linear_congruential_generator</a>
--   for possible parameters.
lcg_i32 :: Int32 -> Int32 -> Int32 -> DF Int32

-- | <a>lcg_i32</a> 1103515245 12345, so in (minBound,maxBound).
lcg_glibc :: Int32 -> DF Int32

-- | <a>abs</a> of 'lcg_glibc, so in (0,maxBound).
randi :: Int32 -> DF Int32

-- | <a>i32_to_normal_f32</a> of <a>randi</a>, so in (0,1).
--   
--   <pre>
--   audition_text 24 (out1 (randf 0))
--   </pre>
randf :: Int32 -> DF Float

-- | White noise (-1,1). Generates noise whose spectrum has equal power at
--   all frequencies.
--   
--   <pre>
--   audition_text 24 (out1 (white_noise 0))
--   </pre>
--   
--   <pre>
--   let n = white_noise 0 * 0.1
--   in draw (out1 (n - n))
--   </pre>
--   
--   <pre>
--   let {n = white_noise 0 * 0.1
--       ;m = white_noise 5 * 0.1}
--   in audition_rju [] (out1 (n - m))
--   </pre>
white_noise :: Int32 -> DF Float

-- | SC3 UGen.
--   
--   <pre>
--   let freq = lin_lin (lf_noise1 0 1) (-1) 1 220 440
--   in audition_rju [] (out1 (sin_osc freq 0 * 0.1))
--   </pre>
lf_noise1 :: Int32 -> DF Float -> DF Float

-- | <a>iir1</a> brown noise function.
brown_noise_f :: Binary_Op (DF Float)

-- | Brown noise (-1,1). Generates noise whose spectrum falls off in power
--   by 6 dB per octave.
--   
--   <pre>
--   let n = brown_noise 0
--   in audition_rju [] (out1 (n * 0.1))
--   </pre>
--   
--   <pre>
--   let {n = brown_noise 0
--       ;f = lin_exp n (-1.0) 1.0 64.0 9600.0
--       ;o = sin_osc f 0}
--   in audition_rju [] (out1 (o * 0.1))
--   </pre>
brown_noise :: Int32 -> DF Float

-- | SC3 UGen.
--   
--   <pre>
--   audition_rju [] (out1 (dust 0 200 * 0.25))
--   audition_rju [] (out1 (dust 0 (sin_osc 0.1 0 * 500 + 550) * 0.25))
--   </pre>
dust :: Int32 -> DF Float -> DF Float

-- | SC3 UGen.
--   
--   <pre>
--   audition_rju [] (out1 (sin_osc (rand 6987612487 220.0 600.0) 0.0 * 0.1))
--   </pre>
rand :: Int32 -> DF Float -> DF Float -> DF Float

-- | Sine oscillator. Inputs are: <i>f</i> = frequency (in hz), <i>ip</i> =
--   initial phase.
--   
--   <pre>
--   let o = sin_osc 440.0 0.0
--   in audition_rju [] (out1 (o * 0.1))
--   </pre>
--   
--   Used as both Oscillator and LFO.
--   
--   <pre>
--   let {f = sin_osc 4.0 0.0
--       ;o = sin_osc (f * 200.0 + 400.0) 0.0}
--   in audition_rju [] (out1 (o * 0.1))
--   </pre>
--   
--   Cancellation.
--   
--   <pre>
--   let {o1 = sin_osc 440.0 0.0
--       ;o2 = sin_osc 440.0 pi}
--   in audition_rju [] (out1 (o1 + o2))
--   </pre>
sin_osc :: DF Float -> Float -> DF Float

-- | Impulse oscillator (non band limited). Outputs non band limited single
--   sample impulses. Inputs are: <i>f</i> = frequency (in hertz),
--   <i>ip</i> = phase offset (0..1)
--   
--   <pre>
--   let o = impulse 800.0 0.0
--   in audition_rju [] (out1 (o * 0.1))
--   </pre>
--   
--   <pre>
--   let {f = sin_osc 0.25 0.0 * 2500.0 + 2505.0
--       ;o = impulse f 0.0}
--   in audition_rju [] (out1 (o * 0.1))
--   </pre>
--   
--   <pre>
--   audition_text 10 (out1 (impulse (w_sample_rate / 5.0) 0.0))
--   audition_text 10 (out1 (impulse (k_sample_rate / 5.0) 0.0))
--   </pre>
impulse :: DF Float -> Float -> DF Float

-- | Non-band limited sawtooth oscillator. Output ranges from -1 to +1.
--   Inputs are: <i>f</i> = frequency (in hertz), <i>ip</i> = initial phase
--   (0,2).
--   
--   <pre>
--   let o = lf_saw 500.0 1.0
--   in audition_rju [] (out1 (o * 0.1))
--   </pre>
--   
--   Used as both Oscillator and LFO.
--   
--   <pre>
--   let {f = lf_saw 4.0 0.0
--       ;o = lf_saw (f * 400.0 + 400.0) 0.0}
--   in audition_rju [] (out1 (o * 0.1))
--   </pre>
lf_saw :: DF Float -> Float -> DF Float

-- | Non-band-limited pulse oscillator. Outputs a high value of one and a
--   low value of zero. Inputs are: <i>f</i> = frequency (in hertz),
--   <i>ip</i> = initial phase (0,1), <i>w</i> = pulse width duty cycle
--   (0,1).
--   
--   <pre>
--   let {o1 = lf_pulse 3.0 0.0 0.3 * 200.0 + 200.0
--       ;o2 = lf_pulse o1 0.0 0.2 * 0.1}
--   in audition_rju [] (out1 o2)
--   </pre>
lf_pulse :: DF Float -> Float -> DF Float -> DF Float

-- | Two zero fixed midpass filter.
bpz2 :: DF Float -> DF Float

-- | Two zero fixed midcut filter.
brz2 :: DF Float -> DF Float

-- | Two point difference filter
hpz1 :: DF Float -> DF Float

-- | Two zero fixed highpass filter
hpz2 :: DF Float -> DF Float

-- | Two point average filter
lpz1 :: DF Float -> DF Float

-- | Two zero fixed lowpass filter
lpz2 :: DF Float -> DF Float

-- | Given <i>cf</i> construct <a>iir1</a> one-pole function.
one_pole_f :: Fractional a => a -> Binary_Op a

-- | One pole filter.
--   
--   <pre>
--   let {n = white_noise 0
--       ;f = one_pole (n * 0.5) 0.95}
--   in audition_rju [] (out1 f)
--   </pre>
one_pole :: DF Float -> DF Float -> DF Float

-- | Given <i>cf</i> construct <a>fir1</a> one-zero function.
one_zero_f :: Fractional a => a -> Binary_Op a

-- | One zero filter.
--   
--   <pre>
--   let {n = white_noise 0
--       ;f = one_zero (n * 0.5) 0.5}
--   in audition_rju [] (out1 f)
--   </pre>
one_zero :: DF Float -> DF Float -> DF Float

-- | Given coefficients construct <a>biquad</a> <a>sos</a> function.
sos_f :: Num a => a -> a -> a -> a -> a -> Quinary_Op a

-- | Second order filter section.
sos :: DF Float -> DF Float -> DF Float -> DF Float -> DF Float -> DF Float -> DF Float

-- | Given <i>f</i> and <i>rq</i> construct <a>iir2</a> <a>resonz</a>
--   function.
resonz_f :: DF Float -> DF Float -> Ternary_Op (DF Float)
resonz' :: DF Float -> DF Float -> DF Float -> DF Float

-- | A two pole resonant filter with zeroes at z = +/- 1. Based on K.
--   Steiglitz, "A Note on Constant-Gain Digital Resonators", <i>Computer
--   Music Journal</i>, vol 18, no. 4, pp. 8-10, Winter 1994. The
--   reciprocal of Q is used rather than Q because it saves a divide
--   operation inside the unit generator.
--   
--   Inputs are: <i>i</i> = input signal, <i>f</i> = resonant frequency (in
--   hertz), <i>rq</i> = bandwidth ratio (reciprocal of Q);where <i>rq</i>
--   = bandwidth / centerFreq.
--   
--   <pre>
--   let {n = white_noise 0
--       ;r = resonz (n * 0.5) 440.0 0.1}
--   in audition_rju [] (out1 r)
--   </pre>
--   
--   Modulate frequency
--   
--   <pre>
--   let {n = white_noise 0
--       ;f = lf_saw 0.1 0.0 * 3500.0 + 4500.0
--       ;r = resonz (n * 0.5) f 0.05}
--   in audition_rju [] (out1 r)
--   </pre>
resonz :: DF Float -> DF Float -> DF Float -> DF Float

-- | Given <i>f</i> and <i>r</i> construct <a>iir2</a> <a>rlpf</a>
--   function.
rlpf_f :: DF Float -> DF Float -> Ternary_Op (DF Float)

-- | Resonant low pass filter. Inputs are: <i>i</i> = input signal,
--   <i>f</i> = frequency (hertz), <i>rq</i> = reciprocal of Q (resonance).
--   
--   <pre>
--   let {n = white_noise 0
--       ;f = sin_osc 0.5 0.0  * 40.0 + 220.0
--       ;r = rlpf n f 0.1}
--   in audition_rju [] (out1 r)
--   </pre>
rlpf' :: DF Float -> DF Float -> DF Float -> DF Float

-- | Allow MCE.
rlpf :: DF Float -> DF Float -> DF Float -> DF Float

-- | 5-tuple
type T5 t = (t, t, t, t, t)

-- | 2nd order Butterworth high-pass filter coefficients.
--   
--   <pre>
--   hpf_c 48000.0 (440.0 :: DF Float)
--   </pre>
lpf_or_hpf_c :: Floating t => Bool -> t -> t -> T5 t

-- | High pass filter.
hpf :: DF Float -> DF Float -> DF Float

-- | Low pass filter.
lpf :: DF Float -> DF Float -> DF Float

-- | <a>df_gt</a> <tt>0</tt>.
positive :: K_Num a => DF a -> DF Bool

-- | <a>df_not</a> of <a>positive</a>.
non_positive :: K_Num a => DF a -> DF Bool

-- | <a>fir1</a> <i>trigger</i> function.
trigger_f :: K_Num a => DF a -> DF a -> DF Bool

-- | True on non-positive to positive transition.
trigger :: K_Num a => DF a -> DF Bool

-- | Count <a>True</a> values at input.
--   
--   <pre>
--   let n = white_noise 0
--   in audition_text 12 (out2 n (count_true (trigger n)))
--   </pre>
count_true :: K_Num a => DF Bool -> DF a

-- | Pulse divider at <a>Bool</a>.
pulse_divider :: DF Bool -> DF Int32 -> DF Int32 -> DF Bool

-- | SC3 <tt>PulseDivider</tt>.
--   
--   <pre>
--   let n = white_noise 0
--   in audition_text 12 (out2 n (pulse_divider' n 2 1))
--   </pre>
pulse_divider' :: K_Num a => DF a -> DF Int32 -> DF Int32 -> DF a

-- | Sample and hold. Holds input signal value when triggered. Inputs are:
--   <i>i</i> = input signal, <i>t</i> = trigger.
--   
--   <pre>
--   let {n = white_noise 0
--       ;i = impulse 9.0 0.0
--       ;l = latch n (trigger i)
--       ;o = sin_osc (l * 400.0 + 500.0) 0.0}
--   in audition_rju [] (out1 (o * 0.2))
--   </pre>
latch :: K_Num a => DF a -> DF Bool -> DF a

-- | Given <i>dt</i> construct <a>iir1</a> <a>decay</a> function.
decay_f :: DF Float -> Binary_Op (DF Float)

-- | Exponential decay. Inputs are: <i>i</i> = input signal, <i>t</i> =
--   decay time. This is essentially the same as Integrator except that
--   instead of supplying the coefficient directly, it is caculated from a
--   60 dB decay time. This is the time required for the integrator to lose
--   99.9 % of its value or -60dB. This is useful for exponential decaying
--   envelopes triggered by impulses.
--   
--   Used as an envelope.
--   
--   <pre>
--   let {n = brown_noise 0
--       ;f = lf_saw 0.1 0.0
--       ;i = impulse (lin_lin f (-1.0) 1.0 2.0 5.0) 0.25
--       ;e = decay i 0.2}
--   in audition_rju [] (out1 (e * n))
--   </pre>
decay :: DF Float -> DF Float -> DF Float

-- | Exponential decay (equivalent to <tt>decay dcy - decay atk</tt>).
decay2 :: DF Float -> DF Float -> DF Float -> DF Float

-- | Single sample delay.
delay1 :: DF Float -> DF Float

-- | Two sample delay.
--   
--   <pre>
--   audition_text 10 (out1 (delay2 (counter 0 1)))
--   </pre>
delay2 :: DF Float -> DF Float

-- | Given <i>t</i> construct <a>iir1</a> <a>lag</a> function.
lag_f :: DF Float -> Binary_Op (DF Float)

-- | Simple averaging filter. Inputs are: <i>i</i> = input signal, <i>t</i>
--   = lag time.
--   
--   <pre>
--   let {s = sin_osc 0.05 0.0
--       ;f = lin_lin s (-1.0) 1.0 220.0 440.0
--       ;o = sin_osc f 0.0
--       ;f' = lag f 1.0
--       ;o' = sin_osc f' 0.0}
--   in audition_rju [] (out2 (o * 0.2) (o' * 0.2))
--   </pre>
lag :: DF Float -> DF Float -> DF Float

-- | Nested lag filter.
lag2 :: DF Float -> DF Float -> DF Float

-- | Twice nested lag filter.
lag3 :: DF Float -> DF Float -> DF Float


-- | Data flow node functions, or unit generators.
module Sound.DF.Uniform.GADT.UGen.Monadic

-- | Single place infinite impulse response filter with indicated initial
--   value.
--   
--   <pre>
--   import Data.Int
--   import Sound.DF.Uniform.GADT
--   draw =&lt;&lt; iir1_m (0::Int32) (+) 1
--   draw =&lt;&lt; iir1_m (0::Float) (+) 1
--   </pre>
iir1_m :: (K' a, UId m) => a -> (Binary_Op (DF a)) -> DF a -> m (DF a)

-- | <i>r</i> = right hand edge, <i>ip</i> = initial phase, <i>x</i> =
--   increment
--   
--   <pre>
--   draw =&lt;&lt; phasor_m 9.0 (4.5::Float) 0.5
--   drawM (phasor_m 9 (0::Int32) 1)
--   </pre>
phasor_m :: (K_Num a, UId m) => DF a -> a -> DF a -> m (DF a)

-- | Allocate <i>n</i> second array, variant of <a>df_vec</a>.
a_alloc_sec_m :: UId m => Float -> m (DF (Vec Float))

-- | Array delay.
--   
--   <pre>
--   do {a &lt;- df_vec_m [0,1,2]
--      ;d &lt;- a_delay a 0.0 0
--      ;draw (a_delay a 0.0 0)}
--   </pre>
--   
--   <pre>
--   do {f &lt;- sin_osc 0.1 0.0
--      ;o &lt;- sin_osc (f * 200.0 + 600.0) 0.0
--      ;a &lt;- df_vec_m (replicate 48000 0)
--      ;d &lt;- a_delay a o 24000
--      ;audition [] (out2 (o * 0.1) (d * 0.05))}
--   </pre>
a_delay_m :: UId m => DF (Vec Float) -> DF Float -> DF Int32 -> m (DF Float)

-- | Array fill function (sin).
a_tbl_sin_m :: UId m => Int -> m (DF (Vec Float))

-- | <a>phasor</a> for table of <i>z</i> places. <i>ip</i> is in (0,1).
--   
--   <pre>
--   drawM (phasor 64.0 (0.0::Float) (hz_to_incr k_sample_rate 64.0 330.0))
--   drawM (tbl_phasor 64 0.0 330.0)
--   </pre>
tbl_phasor_m :: UId m => Int -> Float -> DF Float -> m (DF Float)

-- | Table lookup oscillator. <i>ip</i> is in (0,1).
--   
--   <pre>
--   do {a &lt;- a_tbl_sin 256
--      ;f &lt;- a_osc a 4.0 0.0
--      ;o &lt;- a_osc a (f * 200.0 + 400.0) 0.0
--      ;audition [] (out1 (o * 0.1))}
--   </pre>
--   
--   Cancellation:
--   
--   <pre>
--   do {a &lt;- a_tbl_sin 256
--      ;o1 &lt;- a_osc a 440.0 0.0
--      ;o2 &lt;- a_osc a 440.0 0.5
--      ;audition [] (out1 (o1 + o2))}
--   </pre>
a_osc_m :: UId m => DF (Vec Float) -> DF Float -> Float -> m (DF Float)

-- | Single sample delay with indicated initial value.
--   
--   <pre>
--   drawM (unit_delay_m (0::Int32) 1)
--   drawM (unit_delay_m (0.0::Float) 1.0)
--   </pre>
--   
--   <pre>
--   do {c &lt;- counter_m 0 1.0
--      ;d &lt;- unit_delay_m 0 c
--      ;audition_text 12 (out2 c d)}
--   </pre>
unit_delay_m :: (K' a, UId m) => a -> DF a -> m (DF a)

-- | Two place infinite impulse response filter. Inputs are: <i>f</i>=
--   function <tt>(x0 y1 y2 -&gt; y0)</tt>, <i>i</i> = input signal.
--   
--   <pre>
--   do {c1 &lt;- iir2 (\x y1 _ -&gt; x + y1) 0.001
--      ;o1 &lt;- sin_osc (c1 + 220.0) 0
--      ;c2 &lt;- iir2 (\x _ y2 -&gt; x + y2) 0.001
--      ;o2 &lt;- sin_osc (c2 + 220.0) 0
--      ;audition [] (out2 (o1 * 0.1) (o2 * 0.1))}
--   </pre>
iir2_m :: (K_Num a, UId m) => (Ternary_Op (DF a)) -> DF a -> m (DF a)

-- | Single place finite impulse response filter.
fir1_m :: UId m => (Binary_Op (DF Float)) -> DF Float -> m (DF Float)

-- | Two place finite impulse response filter.
fir2_m :: UId m => (Ternary_Op (DF Float)) -> DF Float -> m (DF Float)

-- | Ordinary biquad filter section.
biquad_m :: UId m => (Quinary_Op (DF Float)) -> DF Float -> m (DF Float)

-- | Counter from indicated initial value.
--   
--   <pre>
--   draw =&lt;&lt; counter (0::Int32) 1
--   drawM (counter (0.0::Float) 1.0)
--   </pre>
--   
--   <pre>
--   audition_text 10 . out1 =&lt;&lt; counter_m 0.0 1.0
--   </pre>
counter_m :: (K_Num a, UId m) => a -> DF a -> m (DF a)

-- | Buffer delay.
--   
--   <pre>
--   drawM (buf_delay 0 0.0 0)
--   </pre>
buf_delay_m :: UId m => DF Int32 -> DF Float -> DF Int32 -> m (DF Float)

-- | Non-interpolating comb filter. Inputs are: <i>b</i> = buffer index,
--   <i>i</i> = input signal, <i>dl</i> = delay time, <i>dc</i> = decay
--   time.
--   
--   All times are in seconds. The decay time is the time for the echoes to
--   decay by <tt>60</tt> decibels. If this time is negative then the
--   feedback coefficient will be negative, thus emphasizing only odd
--   harmonics at an octave lower.
--   
--   <pre>
--   drawM (fmap out1 (buf_comb_n 0 0.0 0.0 0.0))
--   </pre>
--   
--   Comb used as a resonator. The resonant fundamental is equal to
--   reciprocal of the delay time.
--   
--   <pre>
--   import qualified Sound.SC3 as S
--   </pre>
--   
--   <pre>
--   do {n &lt;- white_noise_m
--      ;dt &lt;- let f x = lin_exp (x + 2.0) 1.0 2.0 0.0001 0.01
--             in fmap f (lf_saw 0.1 0.0)
--      ;c &lt;- buf_comb_n 0 (n * 0.1) dt 0.2
--      ;audition [S.b_alloc 0 48000 1] (out1 c)}
--   </pre>
--   
--   Comb used as an echo.
--   
--   <pre>
--   do {i &lt;- impulse 0.5 0.0
--      ;n &lt;- white_noise_m
--      ;e &lt;- decay (i * 0.5) 0.2
--      ;c &lt;- buf_comb_n 0 (e * n) 0.2 3.0
--      ;audition [S.b_alloc 0 48000 1] (out1 c)}
--   </pre>
buf_comb_n_m :: UId m => DF Int32 -> DF Float -> DF Float -> DF Float -> m (DF Float)

-- | Array variant of <a>buf_comb_n</a>. Max delay time is in seconds.
--   
--   <pre>
--   do {n &lt;- white_noise_m
--      ;dt &lt;- let f x = lin_exp (x + 2.0) 1.0 2.0 0.0001 0.01
--             in fmap f (lf_saw 0.1 0.0)
--      ;c &lt;- comb_n 0.1 (n * 0.1) dt 0.2
--      ;audition [] (out1 c)}
--   </pre>
--   
--   <pre>
--   do {i &lt;- impulse 0.5 0.0
--      ;n &lt;- white_noise_m
--      ;e &lt;- decay (i * 0.5) 0.2
--      ;c &lt;- comb_n 0.2 (e * n) 0.2 3.0
--      ;audition [] (out1 c)}
--   </pre>
comb_n_m :: UId m => Float -> DF Float -> DF Float -> DF Float -> m (DF Float)

-- | White noise (-1,1). Generates noise whose spectrum has equal power at
--   all frequencies.
--   
--   <pre>
--   do {n &lt;- white_noise_m
--      ;audition [] (out1 (n * 0.1))}
--   </pre>
white_noise_m :: UId m => m (DF Float)

-- | Brown noise (-1,1). Generates noise whose spectrum falls off in power
--   by 6 dB per octave.
--   
--   <pre>
--   do {n &lt;- brown_noise_m
--      ;audition [] (out1 (n * 0.1))}
--   </pre>
--   
--   <pre>
--   do {n &lt;- brown_noise_m
--      ;let f = lin_exp n (-1.0) 1.0 64.0 9600.0
--       in do {o &lt;- sin_osc f 0
--             ;audition [] (out1 (o * 0.1))}}
--   </pre>
brown_noise_m :: UId m => m (DF Float)

-- | Sine oscillator. Inputs are: <i>f</i> = frequency (in hz), <i>ip</i> =
--   initial phase.
--   
--   <pre>
--   do {o &lt;- sin_osc 440.0 0.0
--      ;audition [] (out1 (o * 0.1))}
--   </pre>
--   
--   Used as both Oscillator and LFO.
--   
--   <pre>
--   do {f &lt;- sin_osc 4.0 0.0
--      ;o &lt;- sin_osc (f * 200.0 + 400.0) 0.0
--      ;audition [] (out1 (o * 0.1))}
--   </pre>
--   
--   Cancellation.
--   
--   <pre>
--   do {o1 &lt;- sin_osc 440.0 0.0
--      ;o2 &lt;- sin_osc 440.0 pi
--      ;audition [] (out1 (o1 + o2))}
--   </pre>
sin_osc_m :: UId m => DF Float -> Float -> m (DF Float)

-- | Impulse oscillator (non band limited). Outputs non band limited single
--   sample impulses. Inputs are: <i>f</i> = frequency (in hertz),
--   <i>ip</i> = phase offset (0..1)
--   
--   <pre>
--   do {o &lt;- impulse 800.0 0.0
--      ;audition [] (out1 (o * 0.1))}
--   </pre>
--   
--   <pre>
--   do {f &lt;- fmap (\x -&gt; x * 2500.0 + 2505.0) (sin_osc 0.25 0.0)
--      ;o &lt;- impulse f 0.0
--      ;audition [] (out1 (o * 0.1))}
--   </pre>
impulse_m :: UId m => DF Float -> Float -> m (DF Float)

-- | Non-band limited sawtooth oscillator. Output ranges from -1 to +1.
--   Inputs are: <i>f</i> = frequency (in hertz), <i>ip</i> = initial phase
--   (0,2).
--   
--   <pre>
--   do {o &lt;- lf_saw 500.0 1.0
--      ;audition [] (out1 (o * 0.1))}
--   </pre>
--   
--   Used as both Oscillator and LFO.
--   
--   <pre>
--   do {f &lt;- lf_saw 4.0 0.0
--      ;o &lt;- lf_saw (f * 400.0 + 400.0) 0.0
--      ;audition [] (out1 (o * 0.1))}
--   </pre>
lf_saw_m :: UId m => DF Float -> Float -> m (DF Float)

-- | Non-band-limited pulse oscillator. Outputs a high value of one and a
--   low value of zero. Inputs are: <i>f</i> = frequency (in hertz),
--   <i>ip</i> = initial phase (0,1), <i>w</i> = pulse width duty cycle
--   (0,1).
--   
--   <pre>
--   do {o1 &lt;- fmap (\x -&gt; x * 200.0 + 200.0) (lf_pulse 3.0 0.0 0.3)
--      ;o2 &lt;- fmap (\x -&gt; x * 0.1) (lf_pulse o1 0.0 0.2)
--      ;audition [] (out1 o2)}
--   </pre>
lf_pulse_m :: UId m => DF Float -> Float -> DF Float -> m (DF Float)

-- | Two zero fixed midpass filter.
bpz2_m :: UId m => DF Float -> m (DF Float)

-- | Two zero fixed midcut filter.
brz2_m :: UId m => DF Float -> m (DF Float)

-- | Two point average filter
lpz1_m :: UId m => DF Float -> m (DF Float)

-- | Two zero fixed lowpass filter
lpz2_m :: UId m => DF Float -> m (DF Float)

-- | One pole filter.
--   
--   <pre>
--   do {n &lt;- white_noise_m
--      ;f &lt;- one_pole (n * 0.5) 0.95
--      ;audition [] (out1 f)}
--   </pre>
one_pole_m :: UId m => DF Float -> DF Float -> m (DF Float)

-- | One zero filter.
--   
--   <pre>
--   do {n &lt;- white_noise_m
--      ;f &lt;- one_zero (n * 0.5) 0.5
--      ;audition [] (out1 f)}
--   </pre>
one_zero_m :: UId m => DF Float -> DF Float -> m (DF Float)

-- | Second order filter section.
sos_m :: UId m => DF Float -> DF Float -> DF Float -> DF Float -> DF Float -> DF Float -> m (DF Float)

-- | A two pole resonant filter with zeroes at z = +/- 1. Based on K.
--   Steiglitz, "A Note on Constant-Gain Digital Resonators", <i>Computer
--   Music Journal</i>, vol 18, no. 4, pp. 8-10, Winter 1994. The
--   reciprocal of Q is used rather than Q because it saves a divide
--   operation inside the unit generator.
--   
--   Inputs are: <i>i</i> = input signal, <i>f</i> = resonant frequency (in
--   hertz), <i>rq</i> = bandwidth ratio (reciprocal of Q);where <i>rq</i>
--   = bandwidth / centerFreq.
--   
--   <pre>
--   do {n &lt;- white_noise_m
--      ;r &lt;- resonz (n * 0.5) 440.0 0.1
--      ;audition [] (out1 r)}
--   </pre>
--   
--   Modulate frequency
--   
--   <pre>
--   do {n &lt;- white_noise_m
--      ;f &lt;- fmap (\x -&gt; x * 3500.0 + 4500.0) (lf_saw 0.1 0.0)
--      ;r &lt;- resonz (n * 0.5) f 0.05
--      ;audition [] (out1 r)}
--   </pre>
resonz_m :: UId m => DF Float -> DF Float -> DF Float -> m (DF Float)

-- | Resonant low pass filter. Inputs are: <i>i</i> = input signal,
--   <i>f</i> = frequency (hertz), <i>rq</i> = reciprocal of Q (resonance).
--   
--   <pre>
--   do {n &lt;- white_noise_m
--      ;f &lt;- fmap (\x -&gt; x * 40.0 + 220.0) (sin_osc 0.5 0.0)
--      ;r &lt;- rlpf n f 0.1
--      ;audition [] (out1 r)}
--   </pre>
rlpf_m :: UId m => DF Float -> DF Float -> DF Float -> m (DF Float)

-- | Sample and hold. Holds input signal value when triggered. Inputs are:
--   <i>i</i> = input signal, <i>t</i> = trigger.
--   
--   <pre>
--   do {n &lt;- white_noise_m
--      ;i &lt;- impulse_m 9.0 0.0
--      ;l &lt;- latch_m n (trigger i)
--      ;o &lt;- sin_osc (l * 400.0 + 500.0) 0.0
--      ;audition [] (out1 (o * 0.2))}
--   </pre>
latch_m :: (K_Num a, UId m) => DF a -> DF Bool -> m (DF a)

-- | Exponential decay. Inputs are: <i>i</i> = input signal, <i>t</i> =
--   decay time. This is essentially the same as Integrator except that
--   instead of supplying the coefficient directly, it is caculated from a
--   60 dB decay time. This is the time required for the integrator to lose
--   99.9 % of its value or -60dB. This is useful for exponential decaying
--   envelopes triggered by impulses.
--   
--   Used as an envelope.
--   
--   <pre>
--   do {n &lt;- brown_noise_m
--      ;f &lt;- lf_saw 0.1 0.0
--      ;i &lt;- impulse (lin_lin f (-1.0) 1.0 2.0 5.0) 0.25
--      ;e &lt;- decay i 0.2
--      ;audition [] (out1 (e * n))}
--   </pre>
decay_m :: UId m => DF Float -> DF Float -> m (DF Float)

-- | Exponential decay (equivalent to <tt>decay dcy - decay atk</tt>).
decay2_m :: UId m => DF Float -> DF Float -> DF Float -> m (DF Float)

-- | Single sample delay.
delay1_m :: (K_Num a, UId m) => DF a -> m (DF a)

-- | Two sample delay.
delay2_m :: (K_Num a, UId m) => DF a -> m (DF a)

-- | Simple averaging filter. Inputs are: <i>i</i> = input signal, <i>t</i>
--   = lag time.
--   
--   <pre>
--   do {s &lt;- sin_osc 0.05 0.0
--      ;let f = lin_lin s (-1.0) 1.0 220.0 440.0
--       in do {o &lt;- sin_osc f 0.0
--             ;f' &lt;- lag f 1.0
--             ;o' &lt;- sin_osc f' 0.0
--             ;audition [] (out2 (o * 0.2) (o' * 0.2))}}
--   </pre>
lag_m :: UId m => DF Float -> DF Float -> m (DF Float)

-- | Nested lag filter.
lag2_m :: UId m => DF Float -> DF Float -> m (DF Float)

-- | Twice nested lag filter.
lag3_m :: UId m => DF Float -> DF Float -> m (DF Float)


-- | Graph drawing
module Sound.DF.Uniform.GADT.Draw

-- | <a>draw</a> of <a>df_erase</a>.
draw :: K' a => DF a -> IO ()

-- | <a>draw'</a> of <a>df_erase</a>.
draw' :: K' a => DF a -> IO ()

-- | <a>draw</a> of <a>df_erase</a> of <a>evalId</a>.
drawM :: K' a => State Id (DF a) -> IO ()

-- | <a>gr_draw</a> of <a>df_erase</a>.
gr_draw :: K' a => DF a -> IO ()

-- | <a>gr_draw'</a> of <a>df_erase</a>.
gr_draw' :: K' a => DF a -> IO ()

-- | <a>gr_draw</a> of <a>df_erase</a> of <a>evalId</a>.
gr_drawM :: K' a => State Id (DF a) -> IO ()


-- | Top level module for uniform rate model <tt>hdf</tt>.
--   
--   <pre>
--   import Sound.DF.Uniform.GADT
--   draw (lf_pulse 0.09 0.0 0.16)
--   </pre>
module Sound.DF.Uniform.GADT
