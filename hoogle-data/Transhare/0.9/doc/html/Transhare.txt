-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A library to apply transformation to containers so as to maximize sharing of unchanged subcomponents.
--   
--   A library to apply transformation to containers so as to maximize
--   sharing of unchanged subcomponents.
@package Transhare
@version 0.9


-- | This module is my answer to the pattern discussed in
--   http:<i></i>blog.ezyang.com<i>2011</i>06<i>a-pattern-for-increasing-sharing</i>
--   about maximizing sharing when transforming an algebraic data type.
--   
--   The' <a>Transhare</a> class is a kind of degerate case of
--   <tt>Traverse</tt> building on a new <a>Applicative</a> data type
--   called <a>TransResult</a> defined below. The result <a>transM</a> is a
--   way to lift a parsimonious transformer 'a -&gt; Maybe a', which
--   indicates identity with <a>Nothing</a>, to work on a container with
--   maximized sharing.
module Data.Transhare
data TransResult a
Original :: a -> TransResult a
getTrans :: TransResult a -> a
Transformed :: a -> TransResult a
getTrans :: TransResult a -> a

-- | <a>TransM</a> is a parsimonious transformer that can return
--   <a>Nothing</a> when the transformation is an identity.
--   
--   If the result is <a>Just</a> <tt>t</tt> then the result <tt>t</tt>
--   might or might not be identical to the argument.
type TransM a = a -> Maybe a

-- | <a>TransR</a> is a parsimonious transformer that returns (Original x)
--   only if x is the original argument.
--   
--   This must follow the law that TransMR . TransRM . t = t
--   
--   The disadvantage of <a>TransR</a> compared to <a>TransM</a> is
--   ensuring the above law and that sharing for Original results is
--   actually being done.
--   
--   <a>TransR</a> which implement sharing correctly are <a>proper
--   implementations</a> of <a>TransR</a>
type TransR a = a -> TransResult a

-- | <a>transMR</a> creates a proper implementation of <a>transR</a> from
--   any <a>transM</a>
transMR :: TransM a -> TransR a

-- | <a>transRM</a> creates a proper implementation of <a>transM</a> only
--   from a proper implementation of <a>transR</a>
transRM :: TransR a -> TransM a

-- | <a>fromO</a> is a helper function used with Applicative to ensure the
--   <a>TransR</a> computed by <a>transR</a> are proper implementations.
fromO :: a -> TransResult a -> TransResult a
class Transhare f
transM :: Transhare f => TransM a -> TransM (f a)
transR :: Transhare f => TransR a -> TransR (f a)
transResult_laws :: Bool
instance Show a => Show (TransResult a)
instance Eq a => Eq (TransResult a)
instance Transhare TransResult
instance Transhare Tree
instance Transhare []
instance Transhare (Either a)
instance Transhare ((,) a)
instance Applicative TransResult
instance Functor TransResult
