-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Tools to parse and evaluate the Puppet DSL.
--   
--   This is a set of tools that is supposed to fill all your Puppet needs
--   : syntax checks, catalog compilation, PuppetDB queries, simulationg of
--   complex interactions between nodes, Puppet master replacement, and
--   more !
@package language-puppet
@version 1.0.1


-- | Base types for the internal ruby parser (<a>Erb.Parser</a>).
module Erb.Ruby
data Value
Literal :: !Text -> Value
Interpolable :: ![Expression] -> Value
Symbol :: !Text -> Value
Array :: ![Expression] -> Value
data Expression
LookupOperation :: !Expression -> !Expression -> Expression
PlusOperation :: !Expression -> !Expression -> Expression
MinusOperation :: !Expression -> !Expression -> Expression
DivOperation :: !Expression -> !Expression -> Expression
MultiplyOperation :: !Expression -> !Expression -> Expression
ShiftLeftOperation :: !Expression -> !Expression -> Expression
ShiftRightOperation :: !Expression -> !Expression -> Expression
AndOperation :: !Expression -> !Expression -> Expression
OrOperation :: !Expression -> !Expression -> Expression
EqualOperation :: !Expression -> !Expression -> Expression
DifferentOperation :: !Expression -> !Expression -> Expression
AboveOperation :: !Expression -> !Expression -> Expression
AboveEqualOperation :: !Expression -> !Expression -> Expression
UnderEqualOperation :: !Expression -> !Expression -> Expression
UnderOperation :: !Expression -> !Expression -> Expression
RegexpOperation :: !Expression -> !Expression -> Expression
NotRegexpOperation :: !Expression -> !Expression -> Expression
NotOperation :: !Expression -> Expression
NegOperation :: !Expression -> Expression
ConditionalValue :: !Expression -> !Expression -> Expression
Object :: !Expression -> Expression
MethodCall :: !Expression -> !Expression -> Expression
BlockOperation :: !Text -> Expression
Value :: !Value -> Expression
BTrue :: Expression
BFalse :: Expression
Error :: !String -> Expression
data RubyStatement
Puts :: !Expression -> RubyStatement
DropPrevSpace :: !RubyStatement -> RubyStatement
DropPrevSpace' :: RubyStatement
DropNextSpace :: !RubyStatement -> RubyStatement
instance Show Expression
instance Ord Expression
instance Eq Expression
instance Show Value
instance Ord Value
instance Eq Value
instance Show RubyStatement
instance Eq RubyStatement
instance Pretty Expression

module Erb.Parser
def :: GenLanguageDef String u Identity
lexer :: GenTokenParser String u Identity
parens :: Parser a -> Parser a
braces :: Parser a -> Parser a
operator :: Parser String
symbol :: String -> Parser String
reservedOp :: String -> Parser ()
whiteSpace :: Parser ()
naturalOrFloat :: Parser (Either Integer Double)
identifier :: Parser String
rubyexpression :: Parser Expression
table :: [[Operator String () Identity Expression]]
term :: Parser Expression
scopeLookup :: Parser Expression
stringLiteral :: Parser Expression
doubleQuoted :: Parser Value
singleQuoted :: Parser Value
objectterm :: Parser Expression
variablereference :: Parser Expression
rubystatement :: Parser RubyStatement
textblockW :: Maybe Char -> Parser [RubyStatement]
textblock :: Parser [RubyStatement]
rubyblock :: Parser [RubyStatement]
erbparser :: Parser [RubyStatement]
parseErbFile :: FilePath -> IO (Either ParseError [RubyStatement])
parseErbString :: String -> Either ParseError [RubyStatement]

module SafeProcess
safeReadProcessTimeout :: String -> [String] -> Text -> Int -> IO (Maybe (Either String Text))
safeCreateProcess :: String -> [String] -> StdStream -> StdStream -> StdStream -> ((Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle) -> IO a) -> IO a
safeReadProcess :: String -> [String] -> Text -> IO (Either String Text)
terminateProcessGroup :: ProcessHandle -> IO ()

module Puppet.PP
ttext :: Text -> Doc
tshow :: Show a => a -> Text
pshow :: Doc -> String

-- | A rendering function that drops colors:
displayNocolor :: Doc -> String


-- | A quickly done module that exports utility functions used to collect
--   various statistics. All statistics are stored in a MVar holding a
--   HashMap.
--   
--   This is not accurate in the presence of lazy evaluation. Nothing is
--   forced.
module Puppet.Stats

-- | Wraps a computation, and measures related execution statistics.
measure :: MStats -> Text -> IO a -> IO a

-- | Just like <a>measure</a>, discarding the result value.
measure_ :: MStats -> Text -> IO a -> IO ()

-- | Create a new statistical container.
newStats :: IO MStats

-- | Returns the actual statistical values.
getStats :: MStats -> IO StatsTable

-- | A table where keys are the names of the computations, and values are
--   <a>StatsPoint</a>s.
type StatsTable = HashMap Text StatsPoint
data StatsPoint
StatsPoint :: !Int -> !Double -> !Double -> !Double -> StatsPoint

-- | Total number of calls to a computation
_statspointCount :: StatsPoint -> !Int

-- | Total time spent during this computation
_statspointTotal :: StatsPoint -> !Double

-- | Minimum execution time
_statspointMin :: StatsPoint -> !Double

-- | Maximum execution time
_statspointMax :: StatsPoint -> !Double
data MStats
instance Show StatsPoint


-- | All the types used for parsing, and helpers working on these types.
module Puppet.Parser.Types

-- | Position in a puppet file. Currently an alias to <a>SourcePos</a>.
type Position = SourcePos

-- | A pair containing the start and end of a given token.
type PPosition = Pair Position Position

-- | Generates an initial position based on a filename.
initialPPos :: Text -> PPosition

-- | Generates a <a>PPosition</a> based on a filename and line number.
toPPos :: Text -> Int -> PPosition
lSourceName :: Lens' Position SourceName
lSourceLine :: Lens' Position Line
lSourceColumn :: Lens' Position Column
capitalize' :: Text -> Text

-- | Properly capitalizes resource types
capitalizeRT :: Text -> Text

-- | A helper function for writing <a>array</a>s.
array :: [Expression] -> UValue

-- | Tries to turn an unresolved value into a <a>Bool</a> without any
--   context.
toBool :: UValue -> Bool
rel2text :: LinkType -> Text

-- | The <a>Expression</a>s
data Expression
Equal :: !Expression -> !Expression -> Expression
Different :: !Expression -> !Expression -> Expression
Not :: !Expression -> Expression
And :: !Expression -> !Expression -> Expression
Or :: !Expression -> !Expression -> Expression
LessThan :: !Expression -> !Expression -> Expression
MoreThan :: !Expression -> !Expression -> Expression
LessEqualThan :: !Expression -> !Expression -> Expression
MoreEqualThan :: !Expression -> !Expression -> Expression
RegexMatch :: !Expression -> !Expression -> Expression
NotRegexMatch :: !Expression -> !Expression -> Expression
Contains :: !Expression -> !Expression -> Expression
Addition :: !Expression -> !Expression -> Expression
Substraction :: !Expression -> !Expression -> Expression
Division :: !Expression -> !Expression -> Expression
Multiplication :: !Expression -> !Expression -> Expression
Modulo :: !Expression -> !Expression -> Expression
RightShift :: !Expression -> !Expression -> Expression
LeftShift :: !Expression -> !Expression -> Expression
Lookup :: !Expression -> !Expression -> Expression
Negate :: !Expression -> Expression

-- | All conditionals are stored in this format.
ConditionalValue :: !Expression -> !(Vector (Pair SelectorCase Expression)) -> Expression

-- | This is for <i>higher order functions</i>.
FunctionApplication :: !Expression -> !Expression -> Expression
Terminal :: !UValue -> Expression
data SelectorCase
SelectorValue :: UValue -> SelectorCase
SelectorDefault :: SelectorCase

-- | An unresolved value, typically the parser's output.
data UValue

-- | Special tokens generated when parsing the <tt>true</tt> or
--   <tt>false</tt> literals.
UBoolean :: !Bool -> UValue

-- | Raw string.
UString :: !Text -> UValue

-- | A string that might contain variable references. The type should be
--   refined at one point.
UInterpolable :: !(Vector Expression) -> UValue

-- | Special token that is generated when parsing the <tt>undef</tt>
--   literal.
UUndef :: UValue

-- | A Resource[reference]
UResourceReference :: !Text -> !Expression -> UValue
UArray :: !(Vector Expression) -> UValue
UHash :: !(Vector (Pair Expression Expression)) -> UValue

-- | The regular expression compilation is performed during parsing.
URegexp :: !CompRegex -> UValue
UVariableReference :: !Text -> UValue
UFunctionCall :: !Text -> !(Vector Expression) -> UValue
UHFunctionCall :: !HFunctionCall -> UValue
UNumber :: Scientific -> UValue

-- | The distinct Puppet <i>higher order functions</i>
data HigherFuncType
HFEach :: HigherFuncType
HFMap :: HigherFuncType
HFReduce :: HigherFuncType
HFFilter :: HigherFuncType
HFSlice :: HigherFuncType
data HFunctionCall
HFunctionCall :: !HigherFuncType -> !(Maybe Expression) -> !BlockParameters -> !(Vector Statement) -> !(Maybe Expression) -> HFunctionCall
_hftype :: HFunctionCall -> !HigherFuncType
_hfexpr :: HFunctionCall -> !(Maybe Expression)
_hfparams :: HFunctionCall -> !BlockParameters
_hfstatements :: HFunctionCall -> !(Vector Statement)
_hfexpression :: HFunctionCall -> !(Maybe Expression)
class HasHFunctionCall c_a19gN where hfexpr = (hFunctionCall . hfexpr) hfexpression = (hFunctionCall . hfexpression) hfparams = (hFunctionCall . hfparams) hfstatements = (hFunctionCall . hfstatements) hftype = (hFunctionCall . hftype)
hFunctionCall :: HasHFunctionCall c_a19gN => Lens' c_a19gN HFunctionCall
hfexpr :: HasHFunctionCall c_a19gN => Lens' c_a19gN (Maybe Expression)
hfexpression :: HasHFunctionCall c_a19gN => Lens' c_a19gN (Maybe Expression)
hfparams :: HasHFunctionCall c_a19gN => Lens' c_a19gN BlockParameters
hfstatements :: HasHFunctionCall c_a19gN => Lens' c_a19gN (Vector Statement)
hftype :: HasHFunctionCall c_a19gN => Lens' c_a19gN HigherFuncType

-- | Currently only two types of block parameters are supported, single
--   values and pairs.
data BlockParameters

-- | <pre>
--   |k|
--   </pre>
BPSingle :: !Text -> BlockParameters

-- | <pre>
--   |k,v|
--   </pre>
BPPair :: !Text -> !Text -> BlockParameters
data CompRegex
CompRegex :: !Text -> !Regex -> CompRegex
data CollectorType
Collector :: CollectorType
ExportedCollector :: CollectorType
data Virtuality

-- | Normal resource, that will be included in the catalog
Normal :: Virtuality

-- | Type for virtual resources
Virtual :: Virtuality

-- | Type for exported resources
Exported :: Virtuality

-- | These are resources that are exported AND included in the catalog
ExportedRealized :: Virtuality
data NodeDesc
NodeName :: !Text -> NodeDesc
NodeMatch :: !CompRegex -> NodeDesc
NodeDefault :: NodeDesc

-- | Relationship link type.
data LinkType
RNotify :: LinkType
RRequire :: LinkType
RBefore :: LinkType
RSubscribe :: LinkType
data SearchExpression
EqualitySearch :: !Text -> !Expression -> SearchExpression
NonEqualitySearch :: !Text -> !Expression -> SearchExpression
AndSearch :: !SearchExpression -> !SearchExpression -> SearchExpression
OrSearch :: !SearchExpression -> !SearchExpression -> SearchExpression
AlwaysTrue :: SearchExpression

-- | All the possible statements
data Statement
ResourceDeclaration :: !ResDec -> Statement
DefaultDeclaration :: !DefaultDec -> Statement
ResourceOverride :: !ResOver -> Statement
ConditionalStatement :: !CondStatement -> Statement
ClassDeclaration :: !ClassDecl -> Statement
DefineDeclaration :: !DefineDec -> Statement
Node :: !Nd -> Statement
VariableAssignment :: !VarAss -> Statement
MainFunctionCall :: !MFC -> Statement
SHFunctionCall :: !SFC -> Statement
ResourceCollection :: !RColl -> Statement
Dependency :: !Dep -> Statement

-- | This is a special statement that is used to include the expressions
--   that are top level. This is certainly buggy, but probably just like
--   the original implementation.
TopContainer :: !(Vector Statement) -> !Statement -> Statement
data ResDec
ResDec :: !Text -> !Expression -> !(Vector (Pair Text Expression)) -> !Virtuality -> !PPosition -> ResDec
data DefaultDec
DefaultDec :: !Text -> !(Vector (Pair Text Expression)) -> !PPosition -> DefaultDec
data ResOver
ResOver :: !Text -> !Expression -> !(Vector (Pair Text Expression)) -> !PPosition -> ResOver

-- | All types of conditional statements are stored that way
--   (<tt>case</tt>, <tt>if</tt>, etc.)
data CondStatement
CondStatement :: !(Vector (Pair Expression (Vector Statement))) -> !PPosition -> CondStatement
data ClassDecl
ClassDecl :: !Text -> !(Vector (Pair Text (Maybe Expression))) -> !(Maybe Text) -> !(Vector Statement) -> !PPosition -> ClassDecl
data DefineDec
DefineDec :: !Text -> !(Vector (Pair Text (Maybe Expression))) -> !(Vector Statement) -> !PPosition -> DefineDec
data Nd
Nd :: !NodeDesc -> !(Vector Statement) -> !(Maybe NodeDesc) -> !PPosition -> Nd
data VarAss
VarAss :: !Text -> !Expression -> !PPosition -> VarAss
data MFC
MFC :: !Text -> !(Vector Expression) -> !PPosition -> MFC

-- | <i>Higher order function</i> call.
data SFC
SFC :: !HFunctionCall -> !PPosition -> SFC

-- | For all types of collectors.
data RColl
RColl :: !CollectorType -> !Text -> !SearchExpression -> !(Vector (Pair Text Expression)) -> !PPosition -> RColl
data Dep
Dep :: !(Pair Text Expression) -> !(Pair Text Expression) -> !LinkType -> !PPosition -> Dep
instance HasHFunctionCall HFunctionCall
instance Eq HigherFuncType
instance Show HigherFuncType
instance Eq BlockParameters
instance Show BlockParameters
instance Eq CollectorType
instance Show CollectorType
instance Generic Virtuality
instance Eq Virtuality
instance Show Virtuality
instance Show NodeDesc
instance Eq NodeDesc
instance Show LinkType
instance Eq LinkType
instance Generic LinkType
instance Eq Statement
instance Show Statement
instance Eq Dep
instance Show Dep
instance Eq Expression
instance Show Expression
instance Eq SelectorCase
instance Show SelectorCase
instance Show UValue
instance Eq UValue
instance Eq HFunctionCall
instance Show HFunctionCall
instance Eq RColl
instance Show RColl
instance Eq SearchExpression
instance Show SearchExpression
instance Eq SFC
instance Show SFC
instance Eq MFC
instance Show MFC
instance Eq VarAss
instance Show VarAss
instance Eq Nd
instance Show Nd
instance Eq DefineDec
instance Show DefineDec
instance Eq ClassDecl
instance Show ClassDecl
instance Eq CondStatement
instance Show CondStatement
instance Eq ResOver
instance Show ResOver
instance Eq DefaultDec
instance Show DefaultDec
instance Eq ResDec
instance Show ResDec
instance Datatype D1Virtuality
instance Constructor C1_0Virtuality
instance Constructor C1_1Virtuality
instance Constructor C1_2Virtuality
instance Constructor C1_3Virtuality
instance Datatype D1LinkType
instance Constructor C1_0LinkType
instance Constructor C1_1LinkType
instance Constructor C1_2LinkType
instance Constructor C1_3LinkType
instance ToJSON LinkType
instance FromJSON LinkType
instance Hashable LinkType
instance IsString Expression
instance Fractional Expression
instance Num Expression
instance IsString UValue
instance Eq CompRegex
instance Show CompRegex

module Puppet.Parser.PrettyPrinter
capitalize :: Text -> Doc
parensList :: Pretty a => Vector a -> Doc
hashComma :: (Pretty a, Pretty b) => Vector (Pair a b) -> Doc
stringEscape :: Text -> Text
showPos :: Position -> Doc
showPPos :: PPosition -> Doc
showAss :: Vector (Pair Text Expression) -> Doc
showArgs :: Vector (Pair Text (Maybe Expression)) -> Doc
showFunc :: Text -> Vector Expression -> Doc
braceStatements :: Vector Statement -> Doc
ppStatements :: Vector Statement -> Doc
instance Pretty Statement
instance Pretty NodeDesc
instance Pretty LinkType
instance Pretty SelectorCase
instance Pretty HFunctionCall
instance Pretty UValue
instance Pretty SearchExpression
instance Pretty BlockParameters
instance Pretty HigherFuncType
instance Pretty Expression

module Puppet.Interpreter.Types
metaparameters :: HashSet Text
type Nodename = Text
type Container = HashMap Text
newtype PrettyError
PrettyError :: Doc -> PrettyError
getError :: PrettyError -> Doc
data PValue
PBoolean :: !Bool -> PValue
PUndef :: PValue
PString :: !Text -> PValue
PResourceReference :: !Text -> !Text -> PValue
PArray :: !(Vector PValue) -> PValue
PHash :: !(Container PValue) -> PValue
PNumber :: !Scientific -> PValue

-- | The different kind of hiera queries
data HieraQueryType

-- | standard hiera query
Priority :: HieraQueryType

-- | hiera_array
ArrayMerge :: HieraQueryType

-- | hiera_hash
HashMerge :: HieraQueryType

-- | The type of the Hiera API function
type HieraQueryFunc m = Container Text -> Text -> HieraQueryType -> m (Either PrettyError (Pair InterpreterWriter (Maybe PValue)))
data RSearchExpression
REqualitySearch :: !Text -> !PValue -> RSearchExpression
RNonEqualitySearch :: !Text -> !PValue -> RSearchExpression
RAndSearch :: !RSearchExpression -> !RSearchExpression -> RSearchExpression
ROrSearch :: !RSearchExpression -> !RSearchExpression -> RSearchExpression
RAlwaysTrue :: RSearchExpression
data ClassIncludeType
IncludeStandard :: ClassIncludeType
IncludeResource :: ClassIncludeType
type Scope = Text
type Facts = Container PValue

-- | This type is used to differenciate the distinct top level types that
--   are exposed by the DSL.
data TopLevelType

-- | This is for node entries.
TopNode :: TopLevelType

-- | This is for defines.
TopDefine :: TopLevelType

-- | This is for classes.
TopClass :: TopLevelType

-- | This one is special. It represents top level statements that are not
--   part of a node, define or class. It is defined as spurious because it
--   is not what you are supposed to be. Also the caching system doesn't
--   like them too much right now.
TopSpurious :: TopLevelType
data ResDefaults
ResDefaults :: !Text -> !Text -> !(Container PValue) -> !PPosition -> ResDefaults
_defType :: ResDefaults -> !Text
_defSrcScope :: ResDefaults -> !Text
_defValues :: ResDefaults -> !(Container PValue)
_defPos :: ResDefaults -> !PPosition
data CurContainerDesc

-- | Contained at node or root level
ContRoot :: CurContainerDesc

-- | Contained in a class
ContClass :: !Text -> CurContainerDesc

-- | Contained in a define, along with the position where this define was
--   ... defined
ContDefine :: !Text -> !Text -> !PPosition -> CurContainerDesc

-- | Dummy container for imported resources, so that we know we must update
--   the nodename
ContImported :: !CurContainerDesc -> CurContainerDesc

-- | This one is used when finalizing imported resources, and contains the
--   current node name
ContImport :: !Nodename -> !CurContainerDesc -> CurContainerDesc
data CurContainer
CurContainer :: !CurContainerDesc -> !(HashSet Text) -> CurContainer
_cctype :: CurContainer -> !CurContainerDesc
_cctags :: CurContainer -> !(HashSet Text)
data ResRefOverride
ResRefOverride :: !RIdentifier -> !(Container PValue) -> !PPosition -> ResRefOverride
_rrid :: ResRefOverride -> !RIdentifier
_rrparams :: ResRefOverride -> !(Container PValue)
_rrpos :: ResRefOverride -> !PPosition
data ScopeInformation
ScopeInformation :: !(Container (Pair (Pair PValue PPosition) CurContainerDesc)) -> !(Container ResDefaults) -> !(HashSet Text) -> !CurContainer -> !(HashMap RIdentifier ResRefOverride) -> !(Maybe Text) -> ScopeInformation
_scopeVariables :: ScopeInformation -> !(Container (Pair (Pair PValue PPosition) CurContainerDesc))
_scopeDefaults :: ScopeInformation -> !(Container ResDefaults)
_scopeExtraTags :: ScopeInformation -> !(HashSet Text)
_scopeContainer :: ScopeInformation -> !CurContainer
_scopeOverrides :: ScopeInformation -> !(HashMap RIdentifier ResRefOverride)
_scopeParent :: ScopeInformation -> !(Maybe Text)
data InterpreterState
InterpreterState :: !(Container ScopeInformation) -> !(Container (Pair ClassIncludeType PPosition)) -> !(HashMap RIdentifier Resource) -> ![CurContainerDesc] -> !PPosition -> !(HashMap (TopLevelType, Text) Statement) -> ![LinkInformation] -> ![ResourceModifier] -> InterpreterState
_scopes :: InterpreterState -> !(Container ScopeInformation)
_loadedClasses :: InterpreterState -> !(Container (Pair ClassIncludeType PPosition))
_definedResources :: InterpreterState -> !(HashMap RIdentifier Resource)
_curScope :: InterpreterState -> ![CurContainerDesc]
_curPos :: InterpreterState -> !PPosition
_nestedDeclarations :: InterpreterState -> !(HashMap (TopLevelType, Text) Statement)
_extraRelations :: InterpreterState -> ![LinkInformation]
_resMod :: InterpreterState -> ![ResourceModifier]
data InterpreterReader m
InterpreterReader :: !(Container NativeTypeMethods) -> (TopLevelType -> Text -> m (Either PrettyError Statement)) -> (Either Text Text -> Text -> Container ScopeInformation -> m (Either PrettyError Text)) -> PuppetDBAPI m -> Container ([PValue] -> InterpreterMonad PValue) -> Text -> HieraQueryFunc m -> ImpureMethods m -> HashSet Text -> InterpreterReader m
_nativeTypes :: InterpreterReader m -> !(Container NativeTypeMethods)
_getStatement :: InterpreterReader m -> TopLevelType -> Text -> m (Either PrettyError Statement)
_computeTemplateFunction :: InterpreterReader m -> Either Text Text -> Text -> Container ScopeInformation -> m (Either PrettyError Text)
_pdbAPI :: InterpreterReader m -> PuppetDBAPI m
_externalFunctions :: InterpreterReader m -> Container ([PValue] -> InterpreterMonad PValue)
_thisNodename :: InterpreterReader m -> Text
_hieraQuery :: InterpreterReader m -> HieraQueryFunc m
_ioMethods :: InterpreterReader m -> ImpureMethods m

-- | The set of modules we will not include or whatsoever.
_ignoredModules :: InterpreterReader m -> HashSet Text
data ImpureMethods m
ImpureMethods :: m [String] -> ([Text] -> m (Either String Text)) -> (String -> m ()) -> (MVar LuaState -> Text -> [PValue] -> m (Either String PValue)) -> ImpureMethods m
_imGetCurrentCallStack :: ImpureMethods m -> m [String]
_imReadFile :: ImpureMethods m -> [Text] -> m (Either String Text)
_imTraceEvent :: ImpureMethods m -> String -> m ()
_imCallLua :: ImpureMethods m -> MVar LuaState -> Text -> [PValue] -> m (Either String PValue)
data InterpreterInstr a
GetNativeTypes :: InterpreterInstr (Container NativeTypeMethods)
GetStatement :: TopLevelType -> Text -> InterpreterInstr Statement
ComputeTemplate :: Either Text Text -> Text -> Container ScopeInformation -> InterpreterInstr Text
ExternalFunction :: Text -> [PValue] -> InterpreterInstr PValue
GetNodeName :: InterpreterInstr Text
HieraQuery :: Container Text -> Text -> HieraQueryType -> InterpreterInstr (Pair InterpreterWriter (Maybe PValue))
GetCurrentCallStack :: InterpreterInstr [String]
IsIgnoredModule :: Text -> InterpreterInstr Bool
ErrorThrow :: PrettyError -> InterpreterInstr a
ErrorCatch :: InterpreterMonad a -> (PrettyError -> InterpreterMonad a) -> InterpreterInstr a
WriterTell :: InterpreterWriter -> InterpreterInstr ()
WriterPass :: InterpreterMonad (a, InterpreterWriter -> InterpreterWriter) -> InterpreterInstr a
WriterListen :: InterpreterMonad a -> InterpreterInstr (a, InterpreterWriter)
PDBInformation :: InterpreterInstr Doc
PDBReplaceCatalog :: WireCatalog -> InterpreterInstr ()
PDBReplaceFacts :: [(Nodename, Facts)] -> InterpreterInstr ()
PDBDeactivateNode :: Nodename -> InterpreterInstr ()
PDBGetFacts :: Query FactField -> InterpreterInstr [PFactInfo]
PDBGetResources :: Query ResourceField -> InterpreterInstr [Resource]
PDBGetNodes :: Query NodeField -> InterpreterInstr [PNodeInfo]
PDBCommitDB :: InterpreterInstr ()
PDBGetResourcesOfNode :: Nodename -> Query ResourceField -> InterpreterInstr [Resource]
ReadFile :: [Text] -> InterpreterInstr Text
TraceEvent :: String -> InterpreterInstr ()
CallLua :: MVar LuaState -> Text -> [PValue] -> InterpreterInstr PValue
newtype Warning
Warning :: Doc -> Warning
type InterpreterLog = Pair Priority Doc
type InterpreterWriter = [InterpreterLog]
warn :: (Monad m, MonadWriter InterpreterWriter m) => Doc -> m ()
debug :: (Monad m, MonadWriter InterpreterWriter m) => Doc -> m ()
logWriter :: (Monad m, MonadWriter InterpreterWriter m) => Priority -> Doc -> m ()

-- | The main monad
type InterpreterMonad = ProgramT InterpreterInstr (State InterpreterState)
data RIdentifier
RIdentifier :: !Text -> !Text -> RIdentifier
_itype :: RIdentifier -> !Text
_iname :: RIdentifier -> !Text
data ModifierType

-- | For collectors, optional resources
ModifierCollector :: ModifierType

-- | For stuff like realize
ModifierMustMatch :: ModifierType
data OverrideType

-- | Overriding forbidden, will throw an error
CantOverride :: OverrideType

-- | Can silently replace
Replace :: OverrideType

-- | Silently ignore errors
CantReplace :: OverrideType
data ResourceCollectorType
RealizeVirtual :: ResourceCollectorType
RealizeCollected :: ResourceCollectorType
DontRealize :: ResourceCollectorType
data ResourceModifier
ResourceModifier :: !Text -> !ModifierType -> !ResourceCollectorType -> !RSearchExpression -> !(Resource -> InterpreterMonad Resource) -> !PPosition -> ResourceModifier
_rmResType :: ResourceModifier -> !Text
_rmModifierType :: ResourceModifier -> !ModifierType
_rmType :: ResourceModifier -> !ResourceCollectorType
_rmSearch :: ResourceModifier -> !RSearchExpression
_rmMutation :: ResourceModifier -> !(Resource -> InterpreterMonad Resource)
_rmDeclaration :: ResourceModifier -> !PPosition
data LinkInformation
LinkInformation :: !RIdentifier -> !RIdentifier -> !LinkType -> !PPosition -> LinkInformation
_linksrc :: LinkInformation -> !RIdentifier
_linkdst :: LinkInformation -> !RIdentifier
_linkType :: LinkInformation -> !LinkType
_linkPos :: LinkInformation -> !PPosition
type EdgeMap = HashMap RIdentifier [LinkInformation]

-- | This is a fully resolved resource that will be used in the
--   <a>FinalCatalog</a>.
data Resource
Resource :: !RIdentifier -> !(HashSet Text) -> !(Container PValue) -> !(HashMap RIdentifier (HashSet LinkType)) -> ![CurContainerDesc] -> !Virtuality -> !(HashSet Text) -> !PPosition -> !Nodename -> Resource

-- | Resource name.
_rid :: Resource -> !RIdentifier

-- | All the resource aliases
_ralias :: Resource -> !(HashSet Text)

-- | Resource parameters.
_rattributes :: Resource -> !(Container PValue)

-- | Resource relations.
_rrelations :: Resource -> !(HashMap RIdentifier (HashSet LinkType))

-- | Resource scope when it was defined, the real container will be the
--   first item
_rscope :: Resource -> ![CurContainerDesc]
_rvirtuality :: Resource -> !Virtuality
_rtags :: Resource -> !(HashSet Text)

-- | Source code position of the resource definition.
_rpos :: Resource -> !PPosition

-- | The node were this resource was created, if remote
_rnode :: Resource -> !Nodename
type NativeTypeValidate = Resource -> Either PrettyError Resource

-- | Attributes (and providers) of a puppet resource type bundled with
--   validation rules
data NativeTypeMethods
NativeTypeMethods :: NativeTypeValidate -> HashSet Text -> NativeTypeMethods
_puppetValidate :: NativeTypeMethods -> NativeTypeValidate
_puppetFields :: NativeTypeMethods -> HashSet Text
type FinalCatalog = HashMap RIdentifier Resource
data DaemonMethods
DaemonMethods :: (Text -> Facts -> IO (Either PrettyError (FinalCatalog, EdgeMap, FinalCatalog, [Resource]))) -> MStats -> MStats -> MStats -> DaemonMethods

-- | The most important function, computing catalogs. Given a node name and
--   a list of facts, it returns the result of the catalog compilation :
--   either an error, or a tuple containing all the resources in this
--   catalog, the dependency map, the exported resources, and a list of
--   known resources, that might not be up to date, but are here for code
--   coverage tests.
_dGetCatalog :: DaemonMethods -> Text -> Facts -> IO (Either PrettyError (FinalCatalog, EdgeMap, FinalCatalog, [Resource]))
_dParserStats :: DaemonMethods -> MStats
_dCatalogStats :: DaemonMethods -> MStats
_dTemplateStats :: DaemonMethods -> MStats
data PuppetEdge
PuppetEdge :: RIdentifier -> RIdentifier -> LinkType -> PuppetEdge

-- | Wire format, see
--   <a>http://docs.puppetlabs.com/puppetdb/1.5/api/wire_format/catalog_format.html</a>.
data WireCatalog
WireCatalog :: !Nodename -> !Text -> !(Vector PuppetEdge) -> !(Vector Resource) -> !Text -> WireCatalog
_wirecatalogNodename :: WireCatalog -> !Nodename
_wirecatalogWVersion :: WireCatalog -> !Text
_wirecatalogWEdges :: WireCatalog -> !(Vector PuppetEdge)
_wirecatalogWResources :: WireCatalog -> !(Vector Resource)
_wirecatalogTransactionUUID :: WireCatalog -> !Text
data PFactInfo
PFactInfo :: !Text -> !Text -> !PValue -> PFactInfo
_pfactinfoNodename :: PFactInfo -> !Text
_pfactinfoFactname :: PFactInfo -> !Text
_pfactinfoFactval :: PFactInfo -> !PValue
data PNodeInfo
PNodeInfo :: !Nodename -> !Bool -> !(Maybe UTCTime) -> !(Maybe UTCTime) -> !(Maybe UTCTime) -> PNodeInfo
_pnodeinfoNodename :: PNodeInfo -> !Nodename
_pnodeinfoDeactivated :: PNodeInfo -> !Bool
_pnodeinfoCatalogT :: PNodeInfo -> !(Maybe UTCTime)
_pnodeinfoFactsT :: PNodeInfo -> !(Maybe UTCTime)
_pnodeinfoReportT :: PNodeInfo -> !(Maybe UTCTime)
data PuppetDBAPI m
PuppetDBAPI :: m Doc -> (WireCatalog -> m (Either PrettyError ())) -> ([(Nodename, Facts)] -> m (Either PrettyError ())) -> (Nodename -> m (Either PrettyError ())) -> (Query FactField -> m (Either PrettyError [PFactInfo])) -> (Query ResourceField -> m (Either PrettyError [Resource])) -> (Query NodeField -> m (Either PrettyError [PNodeInfo])) -> m (Either PrettyError ()) -> (Nodename -> Query ResourceField -> m (Either PrettyError [Resource])) -> PuppetDBAPI m
pdbInformation :: PuppetDBAPI m -> m Doc

-- | 
--   <a>http://docs.puppetlabs.com/puppetdb/1.5/api/commands.html#replace-catalog-version-3</a>
replaceCatalog :: PuppetDBAPI m -> WireCatalog -> m (Either PrettyError ())

-- | 
--   <a>http://docs.puppetlabs.com/puppetdb/1.5/api/commands.html#replace-facts-version-1</a>
replaceFacts :: PuppetDBAPI m -> [(Nodename, Facts)] -> m (Either PrettyError ())

-- | 
--   <a>http://docs.puppetlabs.com/puppetdb/1.5/api/commands.html#deactivate-node-version-1</a>
deactivateNode :: PuppetDBAPI m -> Nodename -> m (Either PrettyError ())

-- | 
--   <a>http://docs.puppetlabs.com/puppetdb/1.5/api/query/v3/facts.html#get-v3facts</a>
getFacts :: PuppetDBAPI m -> Query FactField -> m (Either PrettyError [PFactInfo])

-- | 
--   <a>http://docs.puppetlabs.com/puppetdb/1.5/api/query/v3/resources.html#get-v3resources</a>
getResources :: PuppetDBAPI m -> Query ResourceField -> m (Either PrettyError [Resource])
getNodes :: PuppetDBAPI m -> Query NodeField -> m (Either PrettyError [PNodeInfo])

-- | This is only here to tell the test PuppetDB to save its content to
--   disk.
commitDB :: PuppetDBAPI m -> m (Either PrettyError ())
getResourcesOfNode :: PuppetDBAPI m -> Nodename -> Query ResourceField -> m (Either PrettyError [Resource])

-- | Pretty straightforward way to define the various PuppetDB queries
data Query a
QEqual :: a -> Text -> Query a
QG :: a -> Integer -> Query a
QL :: a -> Integer -> Query a
QGE :: a -> Integer -> Query a
QLE :: a -> Integer -> Query a
QMatch :: Text -> Text -> Query a
QAnd :: [Query a] -> Query a
QOr :: [Query a] -> Query a
QNot :: (Query a) -> Query a
QEmpty :: Query a

-- | Fields for the fact endpoint
data FactField
FName :: FactField
FValue :: FactField
FCertname :: FactField

-- | Fields for the node endpoint
data NodeField
NName :: NodeField
NFact :: Text -> NodeField

-- | Fields for the resource endpoint
data ResourceField
RTag :: ResourceField
RCertname :: ResourceField
RParameter :: Text -> ResourceField
RType :: ResourceField
RTitle :: ResourceField
RExported :: ResourceField
RFile :: ResourceField
RLine :: ResourceField
class HasRIdentifier c_a21XZ where iname = (rIdentifier . iname) itype = (rIdentifier . itype)
rIdentifier :: HasRIdentifier c_a21XZ => Lens' c_a21XZ RIdentifier
iname :: HasRIdentifier c_a21XZ => Lens' c_a21XZ Text
itype :: HasRIdentifier c_a21XZ => Lens' c_a21XZ Text
class HasResRefOverride c_a2208 where rrid = (resRefOverride . rrid) rrparams = (resRefOverride . rrparams) rrpos = (resRefOverride . rrpos)
resRefOverride :: HasResRefOverride c_a2208 => Lens' c_a2208 ResRefOverride
rrid :: HasResRefOverride c_a2208 => Lens' c_a2208 RIdentifier
rrparams :: HasResRefOverride c_a2208 => Lens' c_a2208 (Container PValue)
rrpos :: HasResRefOverride c_a2208 => Lens' c_a2208 PPosition
class HasLinkInformation c_a2238 where linkPos = (linkInformation . linkPos) linkType = (linkInformation . linkType) linkdst = (linkInformation . linkdst) linksrc = (linkInformation . linksrc)
linkInformation :: HasLinkInformation c_a2238 => Lens' c_a2238 LinkInformation
linkPos :: HasLinkInformation c_a2238 => Lens' c_a2238 PPosition
linkType :: HasLinkInformation c_a2238 => Lens' c_a2238 LinkType
linkdst :: HasLinkInformation c_a2238 => Lens' c_a2238 RIdentifier
linksrc :: HasLinkInformation c_a2238 => Lens' c_a2238 RIdentifier
class HasResDefaults c_a226X where defPos = (resDefaults . defPos) defSrcScope = (resDefaults . defSrcScope) defType = (resDefaults . defType) defValues = (resDefaults . defValues)
resDefaults :: HasResDefaults c_a226X => Lens' c_a226X ResDefaults
defPos :: HasResDefaults c_a226X => Lens' c_a226X PPosition
defSrcScope :: HasResDefaults c_a226X => Lens' c_a226X Text
defType :: HasResDefaults c_a226X => Lens' c_a226X Text
defValues :: HasResDefaults c_a226X => Lens' c_a226X (Container PValue)
class HasResourceModifier c_a22aO where rmDeclaration = (resourceModifier . rmDeclaration) rmModifierType = (resourceModifier . rmModifierType) rmMutation = (resourceModifier . rmMutation) rmResType = (resourceModifier . rmResType) rmSearch = (resourceModifier . rmSearch) rmType = (resourceModifier . rmType)
resourceModifier :: HasResourceModifier c_a22aO => Lens' c_a22aO ResourceModifier
rmDeclaration :: HasResourceModifier c_a22aO => Lens' c_a22aO PPosition
rmModifierType :: HasResourceModifier c_a22aO => Lens' c_a22aO ModifierType
rmMutation :: HasResourceModifier c_a22aO => Lens' c_a22aO (Resource -> InterpreterMonad Resource)
rmResType :: HasResourceModifier c_a22aO => Lens' c_a22aO Text
rmSearch :: HasResourceModifier c_a22aO => Lens' c_a22aO RSearchExpression
rmType :: HasResourceModifier c_a22aO => Lens' c_a22aO ResourceCollectorType
class HasDaemonMethods c_a22gt where dCatalogStats = (daemonMethods . dCatalogStats) dGetCatalog = (daemonMethods . dGetCatalog) dParserStats = (daemonMethods . dParserStats) dTemplateStats = (daemonMethods . dTemplateStats)
daemonMethods :: HasDaemonMethods c_a22gt => Lens' c_a22gt DaemonMethods
dCatalogStats :: HasDaemonMethods c_a22gt => Lens' c_a22gt MStats
dGetCatalog :: HasDaemonMethods c_a22gt => Lens' c_a22gt (Text -> Facts -> IO (Either PrettyError (FinalCatalog, EdgeMap, FinalCatalog, [Resource])))
dParserStats :: HasDaemonMethods c_a22gt => Lens' c_a22gt MStats
dTemplateStats :: HasDaemonMethods c_a22gt => Lens' c_a22gt MStats
class HasNativeTypeMethods c_a22km where puppetFields = (nativeTypeMethods . puppetFields) puppetValidate = (nativeTypeMethods . puppetValidate)
nativeTypeMethods :: HasNativeTypeMethods c_a22km => Lens' c_a22km NativeTypeMethods
puppetFields :: HasNativeTypeMethods c_a22km => Lens' c_a22km (HashSet Text)
puppetValidate :: HasNativeTypeMethods c_a22km => Lens' c_a22km NativeTypeValidate
class HasScopeInformation c_a22mx where scopeContainer = (scopeInformation . scopeContainer) scopeDefaults = (scopeInformation . scopeDefaults) scopeExtraTags = (scopeInformation . scopeExtraTags) scopeOverrides = (scopeInformation . scopeOverrides) scopeParent = (scopeInformation . scopeParent) scopeVariables = (scopeInformation . scopeVariables)
scopeInformation :: HasScopeInformation c_a22mx => Lens' c_a22mx ScopeInformation
scopeContainer :: HasScopeInformation c_a22mx => Lens' c_a22mx CurContainer
scopeDefaults :: HasScopeInformation c_a22mx => Lens' c_a22mx (Container ResDefaults)
scopeExtraTags :: HasScopeInformation c_a22mx => Lens' c_a22mx (HashSet Text)
scopeOverrides :: HasScopeInformation c_a22mx => Lens' c_a22mx (HashMap RIdentifier ResRefOverride)
scopeParent :: HasScopeInformation c_a22mx => Lens' c_a22mx (Maybe Text)
scopeVariables :: HasScopeInformation c_a22mx => Lens' c_a22mx (Container (Pair (Pair PValue PPosition) CurContainerDesc))
class HasResource c_a22so where ralias = (resource . ralias) rattributes = (resource . rattributes) rid = (resource . rid) rnode = (resource . rnode) rpos = (resource . rpos) rrelations = (resource . rrelations) rscope = (resource . rscope) rtags = (resource . rtags) rvirtuality = (resource . rvirtuality)
resource :: HasResource c_a22so => Lens' c_a22so Resource
ralias :: HasResource c_a22so => Lens' c_a22so (HashSet Text)
rattributes :: HasResource c_a22so => Lens' c_a22so (Container PValue)
rid :: HasResource c_a22so => Lens' c_a22so RIdentifier
rnode :: HasResource c_a22so => Lens' c_a22so Nodename
rpos :: HasResource c_a22so => Lens' c_a22so PPosition
rrelations :: HasResource c_a22so => Lens' c_a22so (HashMap RIdentifier (HashSet LinkType))
rscope :: HasResource c_a22so => Lens' c_a22so [CurContainerDesc]
rtags :: HasResource c_a22so => Lens' c_a22so (HashSet Text)
rvirtuality :: HasResource c_a22so => Lens' c_a22so Virtuality
class HasInterpreterState c_a22B8 where curPos = (interpreterState . curPos) curScope = (interpreterState . curScope) definedResources = (interpreterState . definedResources) extraRelations = (interpreterState . extraRelations) loadedClasses = (interpreterState . loadedClasses) nestedDeclarations = (interpreterState . nestedDeclarations) resMod = (interpreterState . resMod) scopes = (interpreterState . scopes)
interpreterState :: HasInterpreterState c_a22B8 => Lens' c_a22B8 InterpreterState
curPos :: HasInterpreterState c_a22B8 => Lens' c_a22B8 PPosition
curScope :: HasInterpreterState c_a22B8 => Lens' c_a22B8 [CurContainerDesc]
definedResources :: HasInterpreterState c_a22B8 => Lens' c_a22B8 (HashMap RIdentifier Resource)
extraRelations :: HasInterpreterState c_a22B8 => Lens' c_a22B8 [LinkInformation]
loadedClasses :: HasInterpreterState c_a22B8 => Lens' c_a22B8 (Container (Pair ClassIncludeType PPosition))
nestedDeclarations :: HasInterpreterState c_a22B8 => Lens' c_a22B8 (HashMap (TopLevelType, Text) Statement)
resMod :: HasInterpreterState c_a22B8 => Lens' c_a22B8 [ResourceModifier]
scopes :: HasInterpreterState c_a22B8 => Lens' c_a22B8 (Container ScopeInformation)
class HasInterpreterReader c_a22IR m_a20Jw | c_a22IR -> m_a20Jw where computeTemplateFunction = (interpreterReader . computeTemplateFunction) externalFunctions = (interpreterReader . externalFunctions) getStatement = (interpreterReader . getStatement) hieraQuery = (interpreterReader . hieraQuery) ignoredModules = (interpreterReader . ignoredModules) ioMethods = (interpreterReader . ioMethods) nativeTypes = (interpreterReader . nativeTypes) pdbAPI = (interpreterReader . pdbAPI) thisNodename = (interpreterReader . thisNodename)
interpreterReader :: HasInterpreterReader c_a22IR m_a20Jw => Lens' c_a22IR (InterpreterReader m_a20Jw)
computeTemplateFunction :: HasInterpreterReader c_a22IR m_a20Jw => Lens' c_a22IR (Either Text Text -> Text -> Container ScopeInformation -> m_a20Jw (Either PrettyError Text))
externalFunctions :: HasInterpreterReader c_a22IR m_a20Jw => Lens' c_a22IR (Container ([PValue] -> InterpreterMonad PValue))
getStatement :: HasInterpreterReader c_a22IR m_a20Jw => Lens' c_a22IR (TopLevelType -> Text -> m_a20Jw (Either PrettyError Statement))
hieraQuery :: HasInterpreterReader c_a22IR m_a20Jw => Lens' c_a22IR (HieraQueryFunc m_a20Jw)
ignoredModules :: HasInterpreterReader c_a22IR m_a20Jw => Lens' c_a22IR (HashSet Text)
ioMethods :: HasInterpreterReader c_a22IR m_a20Jw => Lens' c_a22IR (ImpureMethods m_a20Jw)
nativeTypes :: HasInterpreterReader c_a22IR m_a20Jw => Lens' c_a22IR (Container NativeTypeMethods)
pdbAPI :: HasInterpreterReader c_a22IR m_a20Jw => Lens' c_a22IR (PuppetDBAPI m_a20Jw)
thisNodename :: HasInterpreterReader c_a22IR m_a20Jw => Lens' c_a22IR Text
class HasImpureMethods c_a22SE m_a20Jv | c_a22SE -> m_a20Jv where imCallLua = (impureMethods . imCallLua) imGetCurrentCallStack = (impureMethods . imGetCurrentCallStack) imReadFile = (impureMethods . imReadFile) imTraceEvent = (impureMethods . imTraceEvent)
impureMethods :: HasImpureMethods c_a22SE m_a20Jv => Lens' c_a22SE (ImpureMethods m_a20Jv)
imCallLua :: HasImpureMethods c_a22SE m_a20Jv => Lens' c_a22SE (MVar LuaState -> Text -> [PValue] -> m_a20Jv (Either String PValue))
imGetCurrentCallStack :: HasImpureMethods c_a22SE m_a20Jv => Lens' c_a22SE (m_a20Jv [String])
imReadFile :: HasImpureMethods c_a22SE m_a20Jv => Lens' c_a22SE ([Text] -> m_a20Jv (Either String Text))
imTraceEvent :: HasImpureMethods c_a22SE m_a20Jv => Lens' c_a22SE (String -> m_a20Jv ())
class HasCurContainer c_a22X9 where cctags = (curContainer . cctags) cctype = (curContainer . cctype)
curContainer :: HasCurContainer c_a22X9 => Lens' c_a22X9 CurContainer
cctags :: HasCurContainer c_a22X9 => Lens' c_a22X9 (HashSet Text)
cctype :: HasCurContainer c_a22X9 => Lens' c_a22X9 CurContainerDesc
class HasNodename s a | s -> a
nodename :: HasNodename s a => Lens' s a
class HasTransactionUUID s a | s -> a
transactionUUID :: HasTransactionUUID s a => Lens' s a
class HasWEdges s a | s -> a
wEdges :: HasWEdges s a => Lens' s a
class HasWResources s a | s -> a
wResources :: HasWResources s a => Lens' s a
class HasWVersion s a | s -> a
wVersion :: HasWVersion s a => Lens' s a
class HasFactname s a | s -> a
factname :: HasFactname s a => Lens' s a
class HasFactval s a | s -> a
factval :: HasFactval s a => Lens' s a
class HasCatalogT s a | s -> a
catalogT :: HasCatalogT s a => Lens' s a
class HasDeactivated s a | s -> a
deactivated :: HasDeactivated s a => Lens' s a
class HasFactsT s a | s -> a
factsT :: HasFactsT s a => Lens' s a
class HasReportT s a | s -> a
reportT :: HasReportT s a => Lens' s a
rcurcontainer :: Resource -> CurContainerDesc
class MonadThrowPos m
throwPosError :: MonadThrowPos m => Doc -> m a
class MonadStack m
getCallStack :: MonadStack m => m [String]
getCurContainer :: InterpreterMonad CurContainer
scopeName :: CurContainerDesc -> Text
getScopeName :: InterpreterMonad Text
getScope :: InterpreterMonad CurContainerDesc
eitherDocIO :: IO (Either PrettyError a) -> IO (Either PrettyError a)
interpreterIO :: (MonadThrowPos m, MonadIO m) => IO (Either PrettyError a) -> m a
mightFail :: (MonadError PrettyError m, MonadThrowPos m) => m (Either PrettyError a) -> m a
safeDecodeUtf8 :: ByteString -> InterpreterMonad Text
interpreterError :: InterpreterMonad (Either PrettyError a) -> InterpreterMonad a
resourceRelations :: Resource -> [(RIdentifier, LinkType)]

-- | helper for hashmap, in case we want another kind of map ..
ifromList :: (Monoid m, At m, Foldable f) => f (Index m, IxValue m) -> m
ikeys :: (Eq k, Hashable k) => HashMap k v -> HashSet k
isingleton :: (Monoid b, At b) => Index b -> IxValue b -> b
ifromListWith :: (Monoid m, At m, Foldable f) => (IxValue m -> IxValue m -> IxValue m) -> f (Index m, IxValue m) -> m
iinsertWith :: At m => (IxValue m -> IxValue m -> IxValue m) -> Index m -> IxValue m -> m -> m
iunionWith :: (Hashable k, Eq k) => (v -> v -> v) -> HashMap k v -> HashMap k v -> HashMap k v
fnull :: (Eq x, Monoid x) => x -> Bool
rid2text :: RIdentifier -> Text
text2Scientific :: Text -> Maybe Scientific
initialState :: Facts -> InterpreterState
dummypos :: PPosition
instance AsNumber PValue
instance FromJSON PNodeInfo
instance ToJSON PNodeInfo
instance FromJSON PFactInfo
instance ToJSON PFactInfo
instance ToJSON WireCatalog
instance FromJSON WireCatalog
instance ToJSON PuppetEdge
instance FromJSON PuppetEdge
instance ToJSON RIdentifier
instance FromJSON RIdentifier
instance FromJSON ResourceField
instance ToJSON ResourceField
instance FromJSON NodeField
instance ToJSON NodeField
instance FromJSON FactField
instance ToJSON FactField
instance FromJSON a => FromJSON (Query a)
instance ToJSON a => ToJSON (Query a)
instance FromJSON Resource
instance ToJSON Resource
instance FromRuby PValue
instance ToRuby PValue
instance ToJSON PValue
instance FromJSON PValue
instance MonadThrowPos InterpreterMonad
instance MonadStack InterpreterMonad
instance HasReportT PNodeInfo (Maybe UTCTime)
instance HasNodename PNodeInfo Nodename
instance HasFactsT PNodeInfo (Maybe UTCTime)
instance HasDeactivated PNodeInfo Bool
instance HasCatalogT PNodeInfo (Maybe UTCTime)
instance HasNodename PFactInfo Text
instance HasFactval PFactInfo PValue
instance HasFactname PFactInfo Text
instance HasWVersion WireCatalog Text
instance HasWResources WireCatalog (Vector Resource)
instance HasWEdges WireCatalog (Vector PuppetEdge)
instance HasTransactionUUID WireCatalog Text
instance HasNodename WireCatalog Nodename
instance HasCurContainer CurContainer
instance HasImpureMethods (ImpureMethods m0) m0
instance HasInterpreterReader (InterpreterReader m0) m0
instance HasInterpreterState InterpreterState
instance HasResource Resource
instance HasScopeInformation ScopeInformation
instance HasNativeTypeMethods NativeTypeMethods
instance HasDaemonMethods DaemonMethods
instance HasResourceModifier ResourceModifier
instance HasResDefaults ResDefaults
instance HasLinkInformation LinkInformation
instance HasResRefOverride ResRefOverride
instance HasRIdentifier RIdentifier
instance Eq PValue
instance Show PValue
instance Eq RSearchExpression
instance Eq ClassIncludeType
instance Generic TopLevelType
instance Eq TopLevelType
instance Eq CurContainerDesc
instance Generic CurContainerDesc
instance Ord CurContainerDesc
instance Eq CurContainer
instance Show RIdentifier
instance Eq RIdentifier
instance Generic RIdentifier
instance Ord RIdentifier
instance Eq ResRefOverride
instance Eq ModifierType
instance Eq ResourceCollectorType
instance Eq Resource
instance Datatype D1TopLevelType
instance Constructor C1_0TopLevelType
instance Constructor C1_1TopLevelType
instance Constructor C1_2TopLevelType
instance Constructor C1_3TopLevelType
instance Datatype D1CurContainerDesc
instance Constructor C1_0CurContainerDesc
instance Constructor C1_1CurContainerDesc
instance Constructor C1_2CurContainerDesc
instance Constructor C1_3CurContainerDesc
instance Constructor C1_4CurContainerDesc
instance Datatype D1RIdentifier
instance Constructor C1_0RIdentifier
instance Selector S1_0_0RIdentifier
instance Selector S1_0_1RIdentifier
instance Hashable RIdentifier
instance Error PrettyError
instance MonadWriter InterpreterWriter InterpreterMonad
instance MonadError PrettyError InterpreterMonad
instance Hashable TopLevelType
instance IsString PValue
instance IsString PrettyError
instance Show PrettyError


-- | A dummy implementation of <a>PuppetDBAPI</a>, that will return empty
--   responses.
module PuppetDB.Dummy
dummyPuppetDB :: Monad m => PuppetDBAPI m


-- | This module runs a Hiera server that caches Hiera data. There is a
--   huge caveat : only the data files are watched for changes, not the
--   main configuration file.
--   
--   A minor bug is that interpolation will not work for inputs containing
--   the % character when it isn't used for interpolation.
module Hiera.Server

-- | The only method you'll ever need. It runs a Hiera server and gives you
--   a querying function. The <tt>Nil</tt> output is explicitely given as a
--   Maybe type.
startHiera :: FilePath -> IO (Either String (HieraQueryFunc IO))

-- | A dummy hiera function that will be used when hiera is not detected
dummyHiera :: Monad m => HieraQueryFunc m

-- | The type of the Hiera API function
type HieraQueryFunc m = Container Text -> Text -> HieraQueryType -> m (Either PrettyError (Pair InterpreterWriter (Maybe PValue)))
instance FromJSON ConfigFile
instance FromJSON InterpolableHieraString
instance HasConfigFile ConfigFile
instance Show Backend
instance Show HieraStringPart
instance Show InterpolableHieraString
instance Show ConfigFile
instance Pretty HieraStringPart

module Facter
storageunits :: [(String, Int)]
getPrefix :: Int -> String
getOrder :: String -> Int
normalizeUnit :: (Double, Int) -> Double -> (Double, Int)
storagedesc :: (String, String) -> String
factRAM :: IO [(String, String)]
factNET :: IO [(String, String)]
factOS :: IO [(String, String)]
factOSDebian :: IO [(String, String)]
factOSLSB :: IO [(String, String)]
factMountPoints :: IO [(String, String)]
fversion :: IO [(String, String)]
factUser :: IO [(String, String)]
factUName :: IO [(String, String)]
fenv :: IO [(String, String)]
factProcessor :: IO [(String, String)]
puppetDBFacts :: Text -> PuppetDBAPI IO -> IO (Container PValue)

module PuppetDB.Remote

-- | Given an URL (ie. <tt><a>http://localhost:8080</a></tt>), will return
--   an incomplete <a>PuppetDBAPI</a>.
pdbConnect :: Text -> IO (Either PrettyError (PuppetDBAPI IO))

module Puppet.Interpreter.PrettyPrinter
containerComma :: Pretty a => Container a -> Doc
instance Pretty LinkInformation
instance Pretty (InterpreterInstr a)
instance Pretty RSearchExpression
instance Pretty ResourceModifier
instance Pretty ResDefaults
instance Pretty CurContainerDesc
instance Pretty Resource
instance Pretty RIdentifier
instance Pretty TopLevelType
instance Pretty PValue


-- | These are the function and data types that are used to define the
--   Puppet native types.
module Puppet.NativeTypes.Helpers
ipaddr :: Text -> NativeTypeValidate
nativetypemethods :: [(Text, [Text -> NativeTypeValidate])] -> NativeTypeValidate -> NativeTypeMethods
paramname :: Text -> Doc
rarray :: Text -> NativeTypeValidate

-- | This checks that a given parameter is a string. If it is a
--   <tt>ResolvedInt</tt> or <tt>ResolvedBool</tt> it will convert them to
--   strings.
string :: Text -> NativeTypeValidate
strings :: Text -> NativeTypeValidate
noTrailingSlash :: Text -> NativeTypeValidate
fullyQualified :: Text -> NativeTypeValidate
fullyQualifieds :: Text -> NativeTypeValidate

-- | Makes sure that the parameter, if defined, has a value among this
--   list.
values :: [Text] -> Text -> NativeTypeValidate

-- | This fills the default values of unset parameters.
defaultvalue :: Text -> Text -> NativeTypeValidate
concattype :: NativeTypeName -> (NativeTypeName, NativeTypeMethods)

-- | Copies the "name" value into the parameter if this is not set. It
--   implies the <a>string</a> validator.
nameval :: Text -> NativeTypeValidate

-- | Validate resources given a list of valid parameters:
--   
--   <ul>
--   <li>checks that no unknown parameters have been set (except
--   metaparameters)</li>
--   </ul>
defaultValidate :: HashSet Text -> NativeTypeValidate
type NativeTypeName = Text

-- | Helper that takes a list of stuff and will generate a validator.
parameterFunctions :: [(Text, [Text -> NativeTypeValidate])] -> NativeTypeValidate

-- | Checks that a given parameter, if set, is a <tt>ResolvedInt</tt>. If
--   it is a <a>PString</a> it will attempt to parse it.
integer :: Text -> NativeTypeValidate
integers :: Text -> NativeTypeValidate

-- | Checks that a given parameter is set.
mandatory :: Text -> NativeTypeValidate

-- | Checks that a given parameter is set unless the resources "ensure" is
--   set to absent
mandatoryIfNotAbsent :: Text -> NativeTypeValidate
inrange :: Integer -> Integer -> Text -> NativeTypeValidate
faketype :: NativeTypeName -> (NativeTypeName, NativeTypeMethods)
defaulttype :: NativeTypeName -> (NativeTypeName, NativeTypeMethods)

-- | Helper function that runs a validor on a PArray
runarray :: Text -> (Text -> PValue -> NativeTypeValidate) -> NativeTypeValidate

-- | Useful helper for buiding error messages
perror :: Doc -> Either PrettyError Resource
validateSourceOrContent :: NativeTypeValidate


-- | This module holds the <i>native</i> Puppet resource types.
module Puppet.NativeTypes

-- | The map of native types. They are described in
--   <a>Puppet.NativeTypes.Helpers</a>.
baseNativeTypes :: Container NativeTypeMethods

-- | Contrary to the previous iteration, this will let non native types
--   pass.
validateNativeType :: Resource -> InterpreterMonad Resource


-- | This is an internal module.
module Puppet.Interpreter.IO
bs :: ByteString -> PrettyError
defaultImpureMethods :: (Functor m, MonadIO m) => ImpureMethods m
evalInstrGen :: (Functor m, Monad m) => InterpreterReader m -> InterpreterState -> ProgramViewT InterpreterInstr (State InterpreterState) a -> m (Either PrettyError a, InterpreterState, InterpreterWriter)
interpretMonad :: (Functor m, Monad m) => InterpreterReader m -> InterpreterState -> InterpreterMonad a -> m (Either PrettyError a, InterpreterState, InterpreterWriter)


-- | This module is all about converting and resolving foreign data into
--   the fully exploitable corresponding data type. The main use case is
--   the conversion of <a>Expression</a> to <a>PValue</a>.
module Puppet.Interpreter.Resolve

-- | A pure function for resolving variables.
getVariable :: Container ScopeInformation -> Text -> Text -> Either Doc PValue

-- | Turns a <a>PValue</a> into a <a>Bool</a>, as explained in the
--   reference documentation.
pValue2Bool :: PValue -> Bool

-- | Resolves a variable, or throws an error if it can't.
resolveVariable :: Text -> InterpreterMonad PValue

-- | The main resolution function : turns an <a>Expression</a> into a
--   <a>PValue</a>, if possible.
resolveExpression :: Expression -> InterpreterMonad PValue

-- | Resolves an <a>UValue</a> (terminal for the <a>Expression</a> data
--   type) into a <a>PValue</a>
resolveValue :: UValue -> InterpreterMonad PValue

-- | Turns strings, numbers and booleans into <a>Text</a>, or throws an
--   error.
resolvePValueString :: PValue -> InterpreterMonad Text

-- | <pre>
--   resolveExpressionString = resolveExpression &gt;=&gt; resolvePValueString
--   </pre>
resolveExpressionString :: Expression -> InterpreterMonad Text

-- | Just like <a>resolveExpressionString</a>, but accepts arrays.
resolveExpressionStrings :: Expression -> InterpreterMonad [Text]

-- | A special helper function for argument like argument like pairs.
resolveArgument :: Pair Text Expression -> InterpreterMonad (Pair Text PValue)

-- | A hiera helper function, that will throw all Hiera errors and log
--   messages to the main monad.
runHiera :: Text -> HieraQueryType -> InterpreterMonad (Maybe PValue)

-- | A simple helper that checks if a given type is native or a define.
isNativeType :: Text -> InterpreterMonad Bool

-- | Turns an unresolved <a>SearchExpression</a> from the parser into a
--   fully resolved <a>RSearchExpression</a>.
resolveSearchExpression :: SearchExpression -> InterpreterMonad RSearchExpression

-- | Checks whether a given <a>Resource</a> matches a
--   <a>RSearchExpression</a>. Note that the expression doesn't check for
--   type, so you must filter the resources by type beforehand, if needs
--   be.
checkSearchExpression :: RSearchExpression -> Resource -> Bool

-- | Turns a resource type and <a>RSearchExpression</a> into something that
--   can be used in a PuppetDB query.
searchExpressionToPuppetDB :: Text -> RSearchExpression -> Query ResourceField

-- | Generates variable associations for evaluation of blocks. Each item
--   corresponds to an iteration in the calling block.
hfGenerateAssociations :: HFunctionCall -> InterpreterMonad [[(Text, PValue)]]

-- | Sets the proper variables, and returns the scope variables the way
--   they were before being modified. This is a hack that ensures that
--   variables are local to the new scope.
--   
--   It doesn't work at all like other Puppet parts, but consistency isn't
--   really expected here ...
hfSetvars :: [(Text, PValue)] -> InterpreterMonad (Container (Pair (Pair PValue PPosition) CurContainerDesc))

-- | Restores what needs restoring. This will erase all allocations.
hfRestorevars :: Container (Pair (Pair PValue PPosition) CurContainerDesc) -> InterpreterMonad ()

-- | Tries to convert a pair of <a>PValue</a>s into <a>Number</a>s, as
--   defined in attoparsec. If the two values can be converted, it will
--   convert them so that they are of the same type
toNumbers :: PValue -> PValue -> Maybe NumberPair

-- | Converts class resource names to lowercase (fix for the jenkins
--   plugin).
fixResourceName :: Text -> Text -> Text


-- | Evaluates a ruby template from what's generated by <a>Erb.Parser</a>.
module Erb.Evaluate
rubyEvaluate :: Container ScopeInformation -> Text -> [RubyStatement] -> Either Doc Text

-- | A pure function for resolving variables.
getVariable :: Container ScopeInformation -> Text -> Text -> Either Doc PValue


-- | This is a set of pure helpers for evaluation the
--   <a>InterpreterMonad</a> function that can be found in
--   <a>Puppet.Interpreter</a> and <a>Puppet.Interpreter.Resolve</a>. They
--   are used to power some prisms from <a>Puppet.Lens</a>.
--   
--   <pre>
--   &gt; dummyEval (resolveExpression (Addition "1" "2"))
--   Right (PString "3")
--   </pre>
module Puppet.Interpreter.Pure

-- | Worst name ever, this is a set of pure stub for the
--   <a>ImpureMethods</a> type.
impurePure :: ImpureMethods Identity

-- | A pure <a>InterpreterReader</a>, that can only evaluate a subset of
--   the templates, and that can include only the supplied top level
--   statements.
pureReader :: HashMap (TopLevelType, Text) Statement -> InterpreterReader Identity

-- | Evaluates an interpreter expression in a pure context.
pureEval :: Facts -> HashMap (TopLevelType, Text) Statement -> InterpreterMonad a -> (Either PrettyError a, InterpreterState, InterpreterWriter)

-- | A bunch of facts that can be used for pure evaluation.
dummyFacts :: Facts

-- | A default evaluation function for arbitrary interpreter actions.
dummyEval :: InterpreterMonad a -> Either PrettyError a

module Puppet.Parser
expression :: Parser Expression
puppetParser :: Parser (Vector Statement)
runPParser :: Parser a -> SourceName -> Text -> Either ParseError a
instance LookAheadParsing Parser
instance CharParsing Parser
instance Parsing Parser
instance Monad Parser
instance Functor Parser
instance Applicative Parser
instance Alternative Parser
instance Foldable OperatorChain
instance TokenParsing Parser

module Puppet.Lens

-- | Incomplete
_PResolveExpression :: Prism' Expression PValue
_PResolveValue :: Prism' UValue PValue
_PHash :: Prism' PValue (Container PValue)
_PBoolean :: Prism' PValue Bool
_PString :: Prism' PValue Text
_PNumber :: Prism' PValue Scientific
_PResourceReference :: Prism' PValue (Text, Text)
_PUndef :: Prism' PValue ()
_PArray :: Prism' PValue (Vector PValue)
_PParse :: Prism' Text (Vector Statement)
_ResourceDeclaration :: Prism' Statement (Text, Expression, Vector (Pair Text Expression), Virtuality, PPosition)
_DefaultDeclaration :: Prism' Statement (Text, Vector (Pair Text Expression), PPosition)
_ResourceOverride :: Prism' Statement (Text, Expression, Vector (Pair Text Expression), PPosition)
_ConditionalStatement :: Prism' Statement (Vector (Pair Expression (Vector Statement)), PPosition)
_ClassDeclaration :: Prism' Statement (Text, Vector (Pair Text (Maybe Expression)), Maybe Text, Vector Statement, PPosition)
_DefineDeclaration :: Prism' Statement (Text, Vector (Pair Text (Maybe Expression)), Vector Statement, PPosition)
_Node :: Prism' Statement (NodeDesc, Vector Statement, Maybe NodeDesc, PPosition)
_VariableAssignment :: Prism' Statement (Text, Expression, PPosition)
_MainFunctionCall :: Prism' Statement (Text, Vector Expression, PPosition)
_SHFunctionCall :: Prism' Statement (HFunctionCall, PPosition)
_ResourceCollection :: Prism' Statement (CollectorType, Text, SearchExpression, Vector (Pair Text Expression), PPosition)
_Dependency :: Prism' Statement (Pair Text Expression, Pair Text Expression, LinkType, PPosition)
_TopContainer :: Prism' Statement (Vector Statement, Statement)

-- | Extracts the statements from <a>ClassDeclaration</a>,
--   <a>DefineDeclaration</a>, <a>Node</a> and the spurious statements of
--   <a>TopContainer</a>.
_Statements :: Lens' Statement [Statement]
_ResourceDeclaration' :: Prism' Statement ResDec
_DefaultDeclaration' :: Prism' Statement DefaultDec
_ResourceOverride' :: Prism' Statement ResOver
_ConditionalStatement' :: Prism' Statement CondStatement
_ClassDeclaration' :: Prism' Statement ClassDecl
_DefineDeclaration' :: Prism' Statement DefineDec
_Node' :: Prism' Statement Nd
_VariableAssignment' :: Prism' Statement VarAss
_MainFunctionCall' :: Prism' Statement MFC
_SHFunctionCall' :: Prism' Statement SFC
_ResourceCollection' :: Prism' Statement RColl
_Dependency' :: Prism' Statement Dep
_Equal :: Prism' Expression (Expression, Expression)
_Different :: Prism' Expression (Expression, Expression)
_Not :: Prism' Expression Expression
_And :: Prism' Expression (Expression, Expression)
_Or :: Prism' Expression (Expression, Expression)
_LessThan :: Prism' Expression (Expression, Expression)
_MoreThan :: Prism' Expression (Expression, Expression)
_LessEqualThan :: Prism' Expression (Expression, Expression)
_MoreEqualThan :: Prism' Expression (Expression, Expression)
_RegexMatch :: Prism' Expression (Expression, Expression)
_NotRegexMatch :: Prism' Expression (Expression, Expression)
_Contains :: Prism' Expression (Expression, Expression)
_Addition :: Prism' Expression (Expression, Expression)
_Substraction :: Prism' Expression (Expression, Expression)
_Division :: Prism' Expression (Expression, Expression)
_Multiplication :: Prism' Expression (Expression, Expression)
_Modulo :: Prism' Expression (Expression, Expression)
_RightShift :: Prism' Expression (Expression, Expression)
_LeftShift :: Prism' Expression (Expression, Expression)
_Lookup :: Prism' Expression (Expression, Expression)
_Negate :: Prism' Expression Expression
_ConditionalValue :: Prism' Expression (Expression, Vector (Pair SelectorCase Expression))
_FunctionApplication :: Prism' Expression (Expression, Expression)
_Terminal :: Prism' Expression UValue

module Puppet.Interpreter
vmapM :: (Monad m, Foldable t) => (a -> m b) -> t a -> m [b]
getModulename :: RIdentifier -> Text

-- | This is the main function for computing catalogs. It returns the
--   result of the compulation (either an error, or a tuple containing all
--   the resources, dependency map, exported resources, and defined
--   resources (this last one might not be up to date and is only useful
--   for code coverage tests)) along with all messages that have been
--   generated by the compilation process.
getCatalog :: Monad m => (forall a. InterpreterReader m -> InterpreterState -> InterpreterMonad a -> m (Either PrettyError a, InterpreterState, InterpreterWriter)) -> (TopLevelType -> Text -> m (Either PrettyError Statement)) -> (Either Text Text -> Text -> Container ScopeInformation -> m (Either PrettyError Text)) -> PuppetDBAPI m -> Text -> Facts -> Container NativeTypeMethods -> Container ([PValue] -> InterpreterMonad PValue) -> HieraQueryFunc m -> ImpureMethods m -> HashSet Text -> m (Pair (Either PrettyError (FinalCatalog, EdgeMap, FinalCatalog, [Resource])) [Pair Priority Doc])
isParent :: Text -> CurContainerDesc -> InterpreterMonad Bool
finalize :: [Resource] -> InterpreterMonad [Resource]
popScope :: InterpreterMonad ()
pushScope :: CurContainerDesc -> InterpreterMonad ()
evalTopLevel :: Statement -> InterpreterMonad ([Resource], Statement)
getstt :: TopLevelType -> Text -> InterpreterMonad ([Resource], Statement)
extractPrism :: Prism' a b -> Doc -> a -> InterpreterMonad b
computeCatalog :: Text -> InterpreterMonad (FinalCatalog, EdgeMap, FinalCatalog, [Resource])
makeEdgeMap :: FinalCatalog -> InterpreterMonad EdgeMap
realize :: [Resource] -> InterpreterMonad (Pair FinalCatalog FinalCatalog)
evaluateNode :: Nd -> InterpreterMonad [Resource]
evaluateStatementsVector :: Foldable f => f Statement -> InterpreterMonad [Resource]

-- | Converts a list of pairs into a container, checking there is no
--   duplicate
fromArgumentList :: [Pair Text a] -> InterpreterMonad (Container a)
evaluateStatement :: Statement -> InterpreterMonad [Resource]
loadVariable :: Text -> PValue -> InterpreterMonad ()

-- | This function loads class and define parameters into scope. It checks
--   that all mandatory parameters are set, that no extra parameter is
--   declared.
--   
--   It is able to fill unset parameters with values from Hiera (for
--   classes only) or default values.
loadParameters :: Foldable f => Container PValue -> f (Pair Text (Maybe Expression)) -> PPosition -> Maybe Text -> InterpreterMonad ()
data ScopeEnteringContext
SENormal :: ScopeEnteringContext

-- | We enter the scope as the child of another class
SEChild :: !Text -> ScopeEnteringContext

-- | We enter the scope as the parent of another class
SEParent :: !Text -> ScopeEnteringContext

-- | Enters a new scope, checks it is not already defined, and inherits the
--   defaults from the current scope
--   
--   Inheriting the defaults is necessary for non native types, because
--   they will be expanded in "finalize", so if this was not done, we would
--   be expanding the defines without the defaults applied
enterScope :: ScopeEnteringContext -> CurContainerDesc -> Text -> PPosition -> InterpreterMonad Text
dropInitialColons :: Text -> Text
expandDefine :: Resource -> InterpreterMonad [Resource]
loadClass :: Text -> Maybe Text -> Container PValue -> ClassIncludeType -> InterpreterMonad [Resource]
addRelationship :: LinkType -> PValue -> Resource -> InterpreterMonad Resource
addTagResource :: Resource -> Text -> Resource
addAttribute :: OverrideType -> Text -> Resource -> PValue -> InterpreterMonad Resource
registerResource :: Text -> Text -> Container PValue -> Virtuality -> PPosition -> InterpreterMonad [Resource]
logWithModifier :: Priority -> (Doc -> Doc) -> [PValue] -> InterpreterMonad [Resource]
mainFunctionCall :: Text -> [PValue] -> InterpreterMonad [Resource]
evaluateHFC :: HFunctionCall -> InterpreterMonad [Resource]

module Puppet.Stdlib

-- | Contains the implementation of the StdLib functions.
stdlibFunctions :: Container ([PValue] -> InterpreterMonad PValue)

module Puppet.Preferences

-- | Setup preferences from external/custom params k is set through lenses
--   (ie: hieraPath.~mypath)
setupPreferences :: FilePath -> (Preferences IO -> Preferences IO) -> IO (Preferences IO)
class HasPreferences c_a92Qo m_a92PD | c_a92Qo -> m_a92PD where hieraPath = (preferences . hieraPath) ignoredmodules = (preferences . ignoredmodules) manifestPath = (preferences . manifestPath) modulesPath = (preferences . modulesPath) natTypes = (preferences . natTypes) prefExtFuncs = (preferences . prefExtFuncs) prefPDB = (preferences . prefPDB) templatesPath = (preferences . templatesPath)
preferences :: HasPreferences c_a92Qo m_a92PD => Lens' c_a92Qo (Preferences m_a92PD)
hieraPath :: HasPreferences c_a92Qo m_a92PD => Lens' c_a92Qo (Maybe FilePath)
ignoredmodules :: HasPreferences c_a92Qo m_a92PD => Lens' c_a92Qo (HashSet Text)
manifestPath :: HasPreferences c_a92Qo m_a92PD => Lens' c_a92Qo FilePath
modulesPath :: HasPreferences c_a92Qo m_a92PD => Lens' c_a92Qo FilePath
natTypes :: HasPreferences c_a92Qo m_a92PD => Lens' c_a92Qo (Container NativeTypeMethods)
prefExtFuncs :: HasPreferences c_a92Qo m_a92PD => Lens' c_a92Qo (Container ([PValue] -> InterpreterMonad PValue))
prefPDB :: HasPreferences c_a92Qo m_a92PD => Lens' c_a92Qo (PuppetDBAPI m_a92PD)
templatesPath :: HasPreferences c_a92Qo m_a92PD => Lens' c_a92Qo FilePath
data Preferences m
Preferences :: FilePath -> FilePath -> FilePath -> PuppetDBAPI m -> Container NativeTypeMethods -> Container ([PValue] -> InterpreterMonad PValue) -> Maybe FilePath -> HashSet Text -> Preferences m
instance HasPreferences (Preferences m0) m0

module Puppet.Daemon

-- | This is a high level function, that will initialize the parsing and
--   interpretation infrastructure from the <tt>Prefs</tt> structure, and
--   will return a function that will take a node name, <a>Facts</a> and
--   return either an error or the <a>FinalCatalog</a>, along with the
--   dependency graph and catalog of exported resources. It also return a
--   few IO functions that can be used in order to query the daemon for
--   statistics, following the format in <a>Puppet.Stats</a>.
--   
--   It will internaly initialize a thread for the LUA interpreter, and a
--   thread for the Ruby one. It should cache the AST of every .pp file,
--   and could use a bit of memory. As a comparison, it fits in 60 MB with
--   the author's manifests, but really breathes when given 300 MB of heap
--   space. In this configuration, even if it spawns a ruby process for
--   every template evaluation, it is way faster than the puppet stack.
--   
--   It can optionnaly talk with PuppetDB, by setting an URL in the
--   <tt>Prefs</tt> data structure. The recommended way to set it to
--   http://localhost:8080 and set a SSH tunnel :
--   
--   <pre>
--   ssh -L 8080:localhost:8080 puppet.host
--   </pre>
--   
--   Canveats :
--   
--   <ul>
--   <li>It might be buggy when top level statements that are not
--   class/define/nodes are altered, or when files loaded with require are
--   changed.</li>
--   <li>The catalog is not computed exactly the same way Puppet does. Some
--   good practices are enforced. As an example querying a dictionary with
--   a non existent key returns undef in puppet, whereas it throws an error
--   with language-puppet.</li>
--   </ul>
initDaemon :: Preferences IO -> IO DaemonMethods


-- | A stub implementation of PuppetDB, backed by a YAML file.
module PuppetDB.TestDB

-- | Initializes the test DB using a file to back its content
loadTestDB :: FilePath -> IO (Either PrettyError (PuppetDBAPI IO))

-- | Starts a new PuppetDB, without any backing file.
initTestDB :: IO (PuppetDBAPI IO)
instance ToJSON DBContent
instance FromJSON DBContent
instance HasResources DBContent (Container WireCatalog)
instance HasFacts DBContent (Container Facts)
instance HasBackingFile DBContent (Maybe FilePath)


-- | Common data types for PuppetDB.
module PuppetDB.Common

-- | The supported PuppetDB implementations.
data PDBType

-- | Your standard PuppetDB, queried through the HTTP interface.
PDBRemote :: PDBType

-- | A stupid stub, this is the default choice.
PDBDummy :: PDBType

-- | A slow but handy PuppetDB implementation that is backed by a YAML
--   file.
PDBTest :: PDBType

-- | Given a <a>PDBType</a>, will try return a sane default implementation.
getDefaultDB :: PDBType -> IO (Either PrettyError (PuppetDBAPI IO))

-- | Turns a <a>FinalCatalog</a> and <a>EdgeMap</a> into a document that
--   can be serialized and fed to <tt>puppet apply</tt>.
generateWireCatalog :: Nodename -> FinalCatalog -> EdgeMap -> WireCatalog
instance Eq PDBType
instance Read PDBType

module Puppet.Testing

-- | Run given spec and write a report to <a>stdout</a>. Exit with
--   <a>exitFailure</a> if at least one spec item fails.
hspec :: Spec -> IO ()

-- | This tests that file sources are valid.
basicTest :: PSpec

-- | This tests that all users and groups used as resource parameters are
--   defined
usersGroupsDefined :: PSpec

-- | Initializes a daemon made for running tests, using the specific test
--   puppetDB
testingDaemon :: PuppetDBAPI IO -> FilePath -> (Text -> IO Facts) -> IO (Text -> IO (Either PrettyError (FinalCatalog, EdgeMap, FinalCatalog, [Resource])))

-- | A default testing daemon.
defaultDaemon :: FilePath -> IO (Text -> IO (Either PrettyError (FinalCatalog, EdgeMap, FinalCatalog, [Resource])))
testCatalog :: Nodename -> FilePath -> FinalCatalog -> PSpec -> IO Summary
describeCatalog :: Nodename -> FilePath -> FinalCatalog -> PSpec -> Spec
it :: Example a => String -> PSpecM a -> PSpec
shouldBe :: (Show a, Eq a) => a -> a -> PSpecM Expectation
type PSpec = PSpecM ()
type PSpecM = ReaderT TestEnv SpecM
lCatalog :: HasTestEnv c_a9V7a => Lens' c_a9V7a FinalCatalog
lModuledir :: HasTestEnv c_a9V7a => Lens' c_a9V7a FilePath
lPuppetdir :: HasTestEnv c_a9V7a => Lens' c_a9V7a FilePath

-- | Run tests on a specific resource
withResource :: String -> Text -> Text -> (Resource -> Expectation) -> PSpec

-- | Tests a specific parameter
withParameter :: Text -> Resource -> (PValue -> Expectation) -> Expectation

-- | Test a serie of parameters
withParameters :: [(Text, PValue)] -> Resource -> Expectation

-- | Retrieves a given file content, and runs a test on it. It works on the
--   explicit "content" parameter, or can resolve the "source" parameter to
--   open the file.
withFileContent :: String -> Text -> (Text -> Expectation) -> PSpec
instance HasTestEnv TestEnv
