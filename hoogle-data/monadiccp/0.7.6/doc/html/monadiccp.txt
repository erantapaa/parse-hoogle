-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Constraint Programming
--   
--   Monadic Constraint Programming framework
@package monadiccp
@version 0.7.6

module Language.CPP.Syntax.AST
data CPPFile
CPPFile :: [CPPMacroStm] -> [String] -> CPPNamespace -> CPPFile
cppMacroStm :: CPPFile -> [CPPMacroStm]
cppUsing :: CPPFile -> [String]
cppTranslUnit :: CPPFile -> CPPNamespace
data CPPMacroStm
CPPMacroIncludeUser :: String -> CPPMacroStm
CPPMacroIncludeSys :: String -> CPPMacroStm
CPPMacroDefine :: String -> Maybe [String] -> String -> CPPMacroStm
cppMacroDefName :: CPPMacroStm -> String
cppMacroDefArgs :: CPPMacroStm -> Maybe [String]
cppMacroDefExpr :: CPPMacroStm -> String
data CPPElement
CPPElemNamespace :: (String, CPPNamespace) -> CPPElement
CPPElemDecl :: CPPDecl -> CPPElement
CPPElemDef :: CPPDef -> CPPElement
CPPElemClass :: CPPClass -> CPPElement
data CPPNamespace
CPPNamespace :: [CPPElement] -> CPPNamespace
data CPPClass
CPPClass :: String -> [(CPPVisibility, CPPType)] -> [(CPPVisibility, CPPDecl)] -> [(CPPVisibility, CPPDef)] -> [(CPPVisibility, CPPConstr)] -> CPPClass
cppClassName :: CPPClass -> String
cppClassInherit :: CPPClass -> [(CPPVisibility, CPPType)]
cppClassDecls :: CPPClass -> [(CPPVisibility, CPPDecl)]
cppClassDefs :: CPPClass -> [(CPPVisibility, CPPDef)]
cppClassConstrs :: CPPClass -> [(CPPVisibility, CPPConstr)]
data CPPVisibility
CPPPublic :: CPPVisibility
CPPProtected :: CPPVisibility
CPPPrivate :: CPPVisibility
data CPPType
CPPTypePrim :: String -> CPPType
CPPArray :: [CPPQual] -> CPPType -> (Maybe CPPExpr) -> CPPType
CPPPtr :: [CPPQual] -> CPPType -> CPPType
CPPRef :: [CPPQual] -> CPPType -> CPPType
CPPTempl :: String -> [CPPType] -> CPPType
data CPPStorSpec
CPPAuto :: CPPStorSpec
CPPRegister :: CPPStorSpec
CPPStatic :: CPPStorSpec
CPPExtern :: CPPStorSpec
CPPTypedef :: CPPStorSpec
CPPInline :: CPPStorSpec
CPPVirtual :: CPPStorSpec
data CPPQual
CPPQualConst :: CPPQual
CPPQualVolatile :: CPPQual
data CPPInit
CPPInitValue :: CPPExpr -> CPPInit
CPPInitCall :: [CPPExpr] -> CPPInit
CPPInitArray :: [CPPExpr] -> CPPInit
data CPPDecl
CPPDecl :: Maybe String -> CPPType -> [CPPQual] -> [CPPStorSpec] -> Maybe CPPInit -> CPPDecl
cppDeclName :: CPPDecl -> Maybe String
cppType :: CPPDecl -> CPPType
cppTypeQual :: CPPDecl -> [CPPQual]
cppTypeStor :: CPPDecl -> [CPPStorSpec]
cppDeclInit :: CPPDecl -> Maybe CPPInit
data CPPDef
CPPDef :: String -> CPPType -> [CPPStorSpec] -> [CPPQual] -> [CPPDecl] -> Maybe CPPStat -> CPPDef
cppDefName :: CPPDef -> String
cppDefRetType :: CPPDef -> CPPType
cppDefStor :: CPPDef -> [CPPStorSpec]
cppDefQual :: CPPDef -> [CPPQual]
cppDefArgs :: CPPDef -> [CPPDecl]
cppDefBody :: CPPDef -> Maybe CPPStat
data CPPConstr
CPPConstr :: [CPPStorSpec] -> [CPPDecl] -> Maybe CPPStat -> [(Either CPPExpr CPPType, [CPPExpr])] -> CPPConstr
cppConstrStor :: CPPConstr -> [CPPStorSpec]
cppConstrArgs :: CPPConstr -> [CPPDecl]
cppConstrBody :: CPPConstr -> Maybe CPPStat
cppConstrInit :: CPPConstr -> [(Either CPPExpr CPPType, [CPPExpr])]
data CPPStat
CPPLabel :: String -> CPPStat -> CPPStat
CPPCase :: CPPExpr -> CPPStat -> CPPStat
CPPDefault :: CPPStat -> CPPStat
CPPSimple :: CPPExpr -> CPPStat
CPPCompound :: [CPPBlockItem] -> CPPStat
CPPVerbStat :: [String] -> CPPStat
CPPIf :: CPPExpr -> CPPStat -> (Maybe CPPStat) -> CPPStat
CPPSwitch :: CPPExpr -> CPPStat -> CPPStat
CPPWhile :: CPPExpr -> Bool -> CPPStat -> CPPStat
CPPFor :: (Either (Maybe CPPExpr) CPPDecl) -> (Maybe CPPExpr) -> (Maybe CPPExpr) -> CPPStat -> CPPStat
CPPGoto :: String -> CPPStat
CPPCont :: CPPStat
CPPBreak :: CPPStat
CPPReturn :: (Maybe CPPExpr) -> CPPStat
CPPDelete :: CPPExpr -> CPPStat
data CPPBlockItem
CPPStatement :: CPPStat -> CPPBlockItem
CPPBlockDecl :: CPPDecl -> CPPBlockItem
CPPComment :: String -> CPPBlockItem
data CPPExpr
CPPComma :: [CPPExpr] -> CPPExpr
CPPAssign :: CPPExpr -> CPPAssignOp -> CPPExpr -> CPPExpr
CPPBinary :: CPPExpr -> CPPBinaryOp -> CPPExpr -> CPPExpr
CPPUnary :: CPPUnaryOp -> CPPExpr -> CPPExpr
CPPCond :: CPPExpr -> (Maybe CPPExpr) -> CPPExpr -> CPPExpr
CPPCast :: CPPType -> CPPExpr -> CPPExpr
CPPSizeOfExpr :: CPPExpr -> CPPExpr
CPPSizeOfType :: CPPType -> CPPExpr
CPPIndex :: CPPExpr -> CPPExpr -> CPPExpr
CPPCall :: CPPExpr -> [CPPExpr] -> CPPExpr
CPPMember :: CPPExpr -> String -> Bool -> CPPExpr
CPPVar :: String -> CPPExpr
CPPConst :: CPPConst -> CPPExpr
CPPNew :: CPPType -> [CPPExpr] -> CPPExpr
data CPPConst
CPPConstInt :: Integer -> CPPConst
CPPConstChar :: String -> CPPConst
CPPConstFloat :: String -> CPPConst
CPPConstString :: String -> CPPConst
data CPPAssignOp
CPPAssOp :: CPPAssignOp
CPPAssOpMul :: CPPAssignOp
CPPAssOpDiv :: CPPAssignOp
CPPAssOpRmd :: CPPAssignOp
CPPAssOpAdd :: CPPAssignOp
CPPAssOpSub :: CPPAssignOp
CPPAssOpShl :: CPPAssignOp
CPPAssOpShr :: CPPAssignOp
CPPAssOpAnd :: CPPAssignOp
CPPAssOpOr :: CPPAssignOp
CPPAssOpXor :: CPPAssignOp
data CPPUnaryOp
CPPOpPreInc :: CPPUnaryOp
CPPOpPostInc :: CPPUnaryOp
CPPOpPreDec :: CPPUnaryOp
CPPOpPostDec :: CPPUnaryOp
CPPOpAdr :: CPPUnaryOp
CPPOpInd :: CPPUnaryOp
CPPOpPlus :: CPPUnaryOp
CPPOpMinus :: CPPUnaryOp
CPPOpComp :: CPPUnaryOp
CPPOpNeg :: CPPUnaryOp
data CPPBinaryOp
CPPOpMul :: CPPBinaryOp
CPPOpDiv :: CPPBinaryOp
CPPOpRmd :: CPPBinaryOp
CPPOpAdd :: CPPBinaryOp
CPPOpSub :: CPPBinaryOp
CPPOpShl :: CPPBinaryOp
CPPOpShr :: CPPBinaryOp
CPPOpLe :: CPPBinaryOp
CPPOpGr :: CPPBinaryOp
CPPOpLeq :: CPPBinaryOp
CPPOpGeq :: CPPBinaryOp
CPPOpEq :: CPPBinaryOp
CPPOpNeq :: CPPBinaryOp
CPPOpAnd :: CPPBinaryOp
CPPOpOr :: CPPBinaryOp
CPPOpXor :: CPPBinaryOp
CPPOpLAnd :: CPPBinaryOp
CPPOpLOr :: CPPBinaryOp
instance Eq CPPMacroStm
instance Ord CPPMacroStm
instance Show CPPMacroStm
instance Eq CPPVisibility
instance Ord CPPVisibility
instance Show CPPVisibility
instance Eq CPPStorSpec
instance Ord CPPStorSpec
instance Show CPPStorSpec
instance Eq CPPQual
instance Ord CPPQual
instance Show CPPQual
instance Eq CPPConst
instance Ord CPPConst
instance Show CPPConst
instance Eq CPPAssignOp
instance Ord CPPAssignOp
instance Show CPPAssignOp
instance Eq CPPUnaryOp
instance Ord CPPUnaryOp
instance Show CPPUnaryOp
instance Eq CPPBinaryOp
instance Ord CPPBinaryOp
instance Show CPPBinaryOp
instance Eq CPPExpr
instance Ord CPPExpr
instance Show CPPExpr
instance Eq CPPType
instance Ord CPPType
instance Show CPPType
instance Eq CPPInit
instance Ord CPPInit
instance Show CPPInit
instance Eq CPPDecl
instance Ord CPPDecl
instance Show CPPDecl
instance Eq CPPStat
instance Ord CPPStat
instance Show CPPStat
instance Eq CPPBlockItem
instance Ord CPPBlockItem
instance Show CPPBlockItem
instance Eq CPPConstr
instance Ord CPPConstr
instance Show CPPConstr
instance Eq CPPDef
instance Ord CPPDef
instance Show CPPDef
instance Eq CPPClass
instance Ord CPPClass
instance Show CPPClass
instance Eq CPPElement
instance Ord CPPElement
instance Show CPPElement
instance Eq CPPNamespace
instance Ord CPPNamespace
instance Show CPPNamespace
instance Eq CPPFile
instance Ord CPPFile
instance Show CPPFile

module Language.CPP.Pretty
codegen :: Pretty x => x -> String
instance Pretty CPPFile
instance Pretty CPPClass
instance Pretty CPPNamespace
instance Pretty CPPElement
instance Pretty CPPMacroStm
instance Pretty CPPBlockItem
instance Pretty (CPPConstr, String)
instance Pretty CPPDef
instance Pretty CPPDecl
instance Pretty CPPType
instance Pretty (CPPType, Doc)
instance Pretty (CPPType, Doc, Int, [CPPQual])
instance Pretty CPPVisibility
instance Pretty a => Pretty [a]
instance Pretty CPPStorSpec
instance Pretty CPPQual
instance Pretty CPPStat
instance (Pretty a, Pretty b) => Pretty (Either a b)
instance Pretty s => Pretty (Maybe s)
instance Pretty CPPExpr
instance Pretty CPPConst
instance ToString CPPAssignOp

module Control.Search.SStateT
data SStateT s m a
sstateT :: (s -> m (Tup2 a s)) -> SStateT s m a
runSStateT :: s -> SStateT s m a -> m (Tup2 a s)
data Tup2 a b
Tup2 :: a -> !b -> Tup2 a b
snd2 :: Tup2 t t1 -> t1
fst2 :: Tup2 t t1 -> t
instance Monad m => StateM z (SStateT z m)
instance MMonadT (SStateT s)
instance FMonadT (SStateT s)
instance MonadFix m => MonadFix (SStateT s m)
instance MonadT (SStateT s)

module Control.Search.Language
spacetype :: GenMode -> [Char]
xsspace :: PrettyFlags -> Value -> String -> Doc
data GenMode
ModeUnk :: GenMode
ModeGecode :: GenMode
ModeFZ :: GenMode
ModeMCP :: GenMode
data PrettyFlags
PrettyFlags :: GenMode -> PrettyFlags
genMode :: PrettyFlags -> GenMode
renderVar :: PrettyFlags -> Value -> Doc
class Pretty x where prettyX _ = pretty pretty = prettyX (PrettyFlags {genMode = ModeUnk})
prettyX :: Pretty x => PrettyFlags -> x -> Doc
pretty :: Pretty x => x -> Doc
data Struct
Struct :: String -> [(Type, String)] -> Struct
data Type
Pointer :: Type -> Type
SpaceType :: Type
Int :: Type
Bool :: Type
Union :: [(Type, String)] -> Type
SType :: Struct -> Type
THook :: String -> Type
data Value
IVal :: Int32 -> Value
BVal :: Bool -> Value
RootSpace :: Value
Minus :: Value -> Value -> Value
Plus :: Value -> Value -> Value
Mult :: Value -> Value -> Value
Div :: Value -> Value -> Value
Mod :: Value -> Value -> Value
Abs :: Value -> Value
Var :: String -> Value
Ref :: Value -> Value
Deref :: Value -> Value
Clone :: Value -> Value
Field :: String -> String -> Value
Field' :: Value -> String -> Value
PField :: Value -> String -> Value
Lt :: Value -> Value -> Value
Gq :: Value -> Value -> Value
Gt :: Value -> Value -> Value
Eq :: Value -> Value -> Value
BaseContinue :: Value
And :: Value -> Value -> Value
Or :: Value -> Value -> Value
Not :: Value -> Value
VHook :: String -> Value
Max :: Value -> Value -> Value
AVarElem :: String -> Value -> Value -> Value
AVarSize :: String -> Value -> Value
BAVarElem :: String -> Value -> Value -> Value
BAVarSize :: String -> Value -> Value
IVar :: String -> Value -> Value
MinDom :: Value -> Value
MaxDom :: Value -> Value
Degree :: Value -> Value
WDegree :: Value -> Value
UbRegret :: Value -> Value
LbRegret :: Value -> Value
Median :: Value -> Value
Random :: Value
Null :: Value
New :: Struct -> Value
Base :: Value
Cond :: Value -> Value -> Value -> Value
Assigned :: Value -> Value
Dummy :: Int -> Value
MaxVal :: Value
MinVal :: Value
divValue :: Value -> Value -> Value
true :: Value
false :: Value
(&&&) :: Value -> Value -> Value
(|||) :: Value -> Value -> Value
(@>) :: Value -> Value -> Value
(@>=) :: Value -> Value -> Value
(@<=) :: Value -> Value -> Value
(@==) :: Value -> Value -> Value
(@->) :: Value -> String -> Value
(@=>) :: Value -> String -> Value
(@<) :: Value -> Value -> Value
lex :: [Value -> Value -> Value] -> [Value] -> [Value] -> Value
simplValue :: Value -> Value
data Constraint
EqC :: Value -> Value -> Constraint
NqC :: Value -> Value -> Constraint
LtC :: Value -> Value -> Constraint
LqC :: Value -> Value -> Constraint
GtC :: Value -> Value -> Constraint
GqC :: Value -> Value -> Constraint
TrueC :: Constraint
FalseC :: Constraint
($==) :: Value -> Value -> Constraint
($/=) :: Value -> Value -> Constraint
($<) :: Value -> Value -> Constraint
($<=) :: Value -> Value -> Constraint
($>) :: Value -> Value -> Constraint
($>=) :: Value -> Value -> Constraint
neg :: Constraint -> Constraint
data Statement
IfThenElse :: Value -> Statement -> Statement -> Statement
Push :: Value -> Statement
Skip :: Statement
Seq :: Statement -> Statement -> Statement
Assign :: Value -> Value -> Statement
Abort :: Statement
Print :: Value -> [String] -> Statement
SHook :: String -> Statement
Post :: Value -> Constraint -> Statement
Fold :: String -> Value -> Value -> Value -> (Value -> Value) -> (Value -> Value -> Value) -> Statement
IFold :: String -> Value -> Value -> Value -> (Value -> Value) -> (Value -> Value -> Value) -> Statement
BFold :: String -> Value -> Value -> Value -> (Value -> Value) -> (Value -> Value -> Value) -> Statement
BIFold :: String -> Value -> Value -> Value -> (Value -> Value) -> (Value -> Value -> Value) -> Statement
Delete :: Value -> Statement
Block :: Statement -> Statement -> Statement
DebugOutput :: String -> Statement
DebugValue :: String -> Value -> Statement
inliner :: (Statement -> Maybe Statement) -> Statement -> Statement
comment :: [Char] -> Statement
dec :: Value -> Statement
inc :: Value -> Statement
(>>>) :: Statement -> Statement -> Statement
(<==) :: Value -> Value -> Statement
assign :: Value -> Value -> Statement
ifthen :: Value -> Statement -> Statement
seqs :: [Statement] -> Statement
simplStmt :: Statement -> Statement
class Simplifiable a
simplify :: Simplifiable a => a -> a
instance Eq GenMode
instance Eq PrettyFlags
instance Show Type
instance Eq Type
instance Ord Type
instance Show Struct
instance Eq Struct
instance Ord Struct
instance Show Value
instance Eq Value
instance Ord Value
instance Eq Constraint
instance Ord Constraint
instance Show Constraint
instance Eq Statement
instance Ord Statement
instance Show Statement
instance Simplifiable Value
instance Simplifiable Statement
instance Pretty Statement
instance Show (Value -> Value -> Value)
instance Eq (Value -> Value -> Value)
instance Ord (Value -> Value -> Value)
instance Show (Value -> Value)
instance Eq (Value -> Value)
instance Ord (Value -> Value)
instance Pretty Constraint
instance Pretty Value
instance Pretty Type
instance Num Value
instance Pretty Struct
instance Monoid Statement

module Control.Search.GeneratorInfo
type TreeState = Value
type EvalState = Value
space :: Info -> Value
data Info
Info :: TreeState -> (TreeState -> TreeState) -> [Statement -> Statement] -> [Statement -> Statement] -> Info -> (Info -> Statement) -> (String -> Value) -> [(String, String)] -> Type -> Type -> Info
baseTstate :: Info -> TreeState
path :: Info -> TreeState -> TreeState
abort_ :: Info -> [Statement -> Statement]
commit_ :: Info -> [Statement -> Statement]
old :: Info -> Info
clone :: Info -> Info -> Statement
field :: Info -> String -> Value
stackField :: Info -> [(String, String)]
treeStateType :: Info -> Type
evalStateType :: Info -> Type
(@@) :: Ordering -> Ordering -> Ordering
type Field = String
tstate :: Info -> TreeState
tstate_type :: Info -> Type
estate :: Info -> Value
estate_type :: Info -> Type
withCommit :: Info -> (Statement -> Statement) -> Info
onAbort :: Info -> Statement -> Info
onCommit :: Info -> Statement -> Info
onCommit' :: Info -> Statement -> Info
withPath :: Info -> (TreeState -> TreeState) -> Type -> Type -> Info
withBase :: Info -> String -> Info
withClone :: Info -> (Info -> Statement) -> Info
withField :: Info -> (String, Info -> Value) -> Info
resetPath :: Info -> Info
resetCommit :: Info -> Info
shiftCommit :: Info -> Info
resetAbort :: Info -> Info
shiftAbort :: Info -> Info
resetClone :: Info -> Info
resetInfo :: Info -> Info
mkInfo :: [Char] -> Info
info :: Info
newinfo :: Info -> [Char] -> Info
commit :: Info -> Statement
abort :: Info -> Statement
primClone :: Info -> Info -> Statement
cloneIt :: Info -> Info -> Statement
instance Eq Info
instance Ord Info

module Control.Search.Memo
data MemoKey
MemoKey :: String -> Maybe Info -> Maybe String -> Maybe (Map Int String) -> Maybe Statement -> [String] -> MemoKey
memoFn :: MemoKey -> String
memoInfo :: MemoKey -> Maybe Info
memoStack :: MemoKey -> Maybe String
memoExtra :: MemoKey -> Maybe (Map Int String)
memoStatement :: MemoKey -> Maybe Statement
memoParams :: MemoKey -> [String]
data MemoValue
MemoValue :: Int -> Statement -> Int -> [(String, String)] -> MemoValue
memoId :: MemoValue -> Int
memoCode :: MemoValue -> Statement
memoUsed :: MemoValue -> Int
memoFields :: MemoValue -> [(String, String)]
data MemoInfo
MemoInfo :: Map MemoKey MemoValue -> Int -> Map Int String -> MemoInfo
memoMap :: MemoInfo -> Map MemoKey MemoValue
memoCount :: MemoInfo -> Int
memoRead :: MemoInfo -> Map Int String
initMemoInfo :: MemoInfo
newtype MemoT m a
MemoT :: SStateT MemoInfo m a -> MemoT m a
unMemoT :: MemoT m a -> SStateT MemoInfo m a
runMemoT :: Monad m => MemoT m t -> m (t, [(MemoKey, MemoValue)])
class Monad m => MemoM m
getMemo :: MemoM m => m MemoInfo
setMemo :: MemoM m => MemoInfo -> m ()
instance [overlap ok] Eq MemoKey
instance [overlap ok] Ord MemoKey
instance [overlap ok] MonadT MemoT
instance [overlap ok] Monad m => StateM MemoInfo (MemoT m)
instance [overlap ok] FMonadT MemoT
instance [overlap ok] (MemoM m, FMonadT t) => MemoM (t m)
instance [overlap ok] Monad m => MemoM (MemoT m)
instance [overlap ok] MonadInfoT MemoT

module Control.Search.MemoReader
newtype MemoReaderT r m a
MemoReaderT :: (Int -> ReaderT r m a) -> MemoReaderT r m a
unMemoReaderT :: MemoReaderT r m a -> Int -> ReaderT r m a
memoReaderT :: MemoM m => (e -> Int -> m a) -> MemoReaderT e m a
deMemoReaderT :: MemoM m => e -> Int -> MemoReaderT e m a -> m a
runMemoReaderT :: (MemoM m, Show s) => s -> MemoReaderT s m a -> m a
modelMemoReaderT :: (Show s, MemoM m) => Model (ReaderOp s) (MemoReaderT s m)
instance (MemoM m, Show s) => ReaderM s (MemoReaderT s m)
instance FMonadT (MemoReaderT s)
instance MonadInfoT (MemoReaderT r)
instance MonadT (MemoReaderT r)

module Control.Search.Generator
(<@>) :: Search -> Search -> Search
mmap :: (FMonadT t, MonadInfoT t, Monad m, Monad n, MonadInfo m) => (forall x. m x -> n x) -> t m a -> t n a
search :: Search -> String
($==) :: Value -> Value -> Constraint
($/=) :: Value -> Value -> Constraint
($<) :: Value -> Value -> Constraint
($<=) :: Value -> Value -> Constraint
($>) :: Value -> Value -> Constraint
($>=) :: Value -> Value -> Constraint
(@>) :: Value -> Value -> Value
newtype VarId
VarId :: Int -> VarId
mapE :: (HookStatsM m, HookStatsM n) => (forall x. m x -> n x) -> Eval m -> Eval n
data Eval m
Eval :: ([Struct], [Struct]) -> [(String, Type, Info -> m Statement)] -> [(String, Type, Info -> m Value)] -> (Info -> m Statement) -> (Info -> m Statement) -> (Info -> m Statement) -> (Info -> m Statement) -> (Info -> m Statement) -> (Info -> m Statement) -> (Info -> m Statement) -> (Info -> m Statement) -> (Info -> m Statement) -> (Info -> m Statement) -> (Info -> m Statement) -> (Info -> m Statement) -> [String] -> [String] -> [String] -> (Info -> m Statement) -> String -> m Bool -> (Info -> m Value) -> Eval m
structs :: Eval m -> ([Struct], [Struct])
treeState_ :: Eval m -> [(String, Type, Info -> m Statement)]
evalState_ :: Eval m -> [(String, Type, Info -> m Value)]
nextSameH :: Eval m -> Info -> m Statement
nextDiffH :: Eval m -> Info -> m Statement
pushLeftH :: Eval m -> Info -> m Statement
pushRightH :: Eval m -> Info -> m Statement
bodyH :: Eval m -> Info -> m Statement
initH :: Eval m -> Info -> m Statement
addH :: Eval m -> Info -> m Statement
returnH :: Eval m -> Info -> m Statement
failH :: Eval m -> Info -> m Statement
tryH :: Eval m -> Info -> m Statement
tryLH :: Eval m -> Info -> m Statement
startTryH :: Eval m -> Info -> m Statement
intArraysE :: Eval m -> [String]
boolArraysE :: Eval m -> [String]
intVarsE :: Eval m -> [String]
deleteH :: Eval m -> Info -> m Statement
toString :: Eval m -> String
canBranch :: Eval m -> m Bool
complete :: Eval m -> Info -> m Value
inite :: Monad m => [(String, Info -> m Value)] -> Info -> m Statement
seqSwitch :: ReaderM SeqPos m => m a -> m a -> m a
class Monad m => VarInfoM m
lookupVarInfo :: VarInfoM m => VarId -> m Info
setVarInfo :: VarInfoM m => VarId -> Info -> m ()
type MkEval m = Evalable m => Eval m -> State Int (Eval m)
class (VarInfoM m, HookStatsM m, MonadInfo m, MemoM m, GenModeM m, Functor m) => Evalable m
data SeqPos
OutS :: SeqPos
FirstS :: SeqPos
SecondS :: SeqPos
data Search
Search :: (forall m t1. (HookStatsM m, MonadInfoT t1, FMonadT t1, Evalable m) => MkEval ((t1 :> t2) m)) -> (forall m x. Evalable m => t2 m x -> m x) -> Search
mkeval :: Search -> forall m t1. (HookStatsM m, MonadInfoT t1, FMonadT t1, Evalable m) => MkEval ((t1 :> t2) m)
runsearch :: Search -> forall m x. Evalable m => t2 m x -> m x
(@.) :: Monad m => m (a -> b) -> m a -> m b
(@$) :: Monad m => (a -> b) -> m a -> m b
(@>>>@) :: Evalable m => m Statement -> m Statement -> m Statement
ref_count :: Info -> Value
ref_countx :: Info -> [Char] -> Value
ref_count_type :: Type
commentEval :: Evalable m => Eval m -> Eval m
(@++@) :: ([a], [a1]) -> ([a], [a1]) -> ([a], [a1])
entry :: Monad m => (String, Type, Value -> Statement) -> (String, Type, Info -> m Statement)
numSwitch :: ReaderM t m => (t -> m b) -> m b
data SearchCombiner
SearchCombiner :: (forall m x. Evalable m => ((t1 :> t2) m) x -> m x) -> [SearchCombinerElem t1 t2] -> SearchCombiner
runner :: SearchCombiner -> forall m x. Evalable m => ((t1 :> t2) m) x -> m x
elems :: SearchCombiner -> [SearchCombinerElem t1 t2]
buildCombiner :: [Search] -> SearchCombiner
extractCombiners :: (Evalable m, FMonadT t', MonadInfoT t', FMonadT t1, MonadInfoT t1, FMonadT t2, MonadInfoT t2) => [SearchCombinerElem t1 t2] -> Eval (t' ((t1 :> t2) m)) -> State Int [(Eval (t' ((t1 :> t2) m)))]
memo :: Memoable m => String -> Info -> m -> m
memoLoop :: (Functor m, MonadInfo m, MemoM m, HookStatsM m, VarInfoM m, GenModeM m) => Eval m -> Eval m
rReaderT :: (Show s, MemoM m) => s -> MemoReaderT s m a -> m a
cacheStatement :: Evalable m => String -> Statement -> Info -> m Statement
cloneBase :: Info -> Info
mkCopy :: Info -> String -> Statement
mkUpdate :: Info -> String -> (Value -> Value) -> Statement
rp :: Pretty a => Int -> a -> String
inits :: Evalable m => Eval m -> Info -> m Statement
mseqs :: Monad m => [m Statement] -> m Statement
cachedCommit :: Evalable m => Info -> m Statement
cachedAbort :: Evalable m => Info -> m Statement
cachedClone :: (Functor m, MonadInfo m, MemoM m, HookStatsM m, VarInfoM m, GenModeM m) => Info -> Info -> m Statement
nextSame :: HookStatsM m => Eval m -> Info -> m Statement
nextDiff :: HookStatsM m => Eval m -> Info -> m Statement
pushLeft :: HookStatsM m => Eval m -> Info -> m Statement
pushRight :: HookStatsM m => Eval m -> Info -> m Statement
bodyE :: HookStatsM m => Eval m -> Info -> m Statement
addE :: HookStatsM m => Eval m -> Info -> m Statement
returnE :: HookStatsM m => Eval m -> Info -> m Statement
initE :: HookStatsM m => Eval m -> Info -> m Statement
failE :: HookStatsM m => Eval m -> Info -> m Statement
tryE :: HookStatsM m => Eval m -> Info -> m Statement
startTryE :: HookStatsM m => Eval m -> Info -> m Statement
tryE_ :: HookStatsM m => Eval m -> Info -> m Statement
deleteE :: HookStatsM m => Eval m -> Info -> m Statement
instance [incoherent] MonadT GenModeT
instance [incoherent] Monad m => ReaderM GenMode (GenModeT m)
instance [incoherent] FMonadT GenModeT
instance [incoherent] Ord VarId
instance [incoherent] Eq VarId
instance [incoherent] Show VarId
instance [incoherent] MonadT VarInfoT
instance [incoherent] Monad m => StateM VarInfo (VarInfoT m)
instance [incoherent] FMonadT VarInfoT
instance [incoherent] Monad m => Monad (HookStatsT m)
instance [incoherent] Monad m => StateM HookStat (HookStatsT m)
instance [incoherent] FMonadT HookStatsT
instance [incoherent] MonadT HookStatsT
instance [incoherent] Show SeqPos
instance [incoherent] Monoid ProgramString
instance [incoherent] Evalable m => Memoable (m Statement)
instance [incoherent] Memoable m => Memoable ((Type, Value) -> m)
instance [incoherent] (MonadT t, HookStatsM m) => HookStatsM (t m)
instance [incoherent] Monad m => HookStatsM (HookStatsT m)
instance [incoherent] MonadInfoT HookStatsT
instance [incoherent] (VarInfoM m, HookStatsM m, MonadInfo m, MemoM m, GenModeM m, Functor m) => Evalable m
instance [incoherent] (VarInfoM m, FMonadT t) => VarInfoM (t m)
instance [incoherent] Monad m => VarInfoM (VarInfoT m)
instance [incoherent] MonadInfoT VarInfoT
instance [incoherent] (GenModeM m, FMonadT t) => GenModeM (t m)
instance [incoherent] Monad m => GenModeM (GenModeT m)
instance [incoherent] MonadInfoT GenModeT

module Control.Search.Stat
appStat :: (Value -> Value) -> Stat -> Stat
constStat :: IValue -> Stat
depthStat :: Stat
nodesStat :: Stat
discrepancyStat :: Stat
solutionsStat :: Stat
failsStat :: Stat
timeStat :: Stat
notStat :: Stat -> Stat
data Stat
Stat :: (forall m. Evalable m => Eval m -> Eval m) -> (forall m. Evalable m => m IValue) -> Stat
type IValue = Info -> Value
varStat :: VarId -> Stat
(#>) :: Stat -> Stat -> Stat
(#<) :: Stat -> Stat -> Stat
(#>=) :: Stat -> Stat -> Stat
(#<=) :: Stat -> Stat -> Stat
(#=) :: Stat -> Stat -> Stat
(#/) :: Stat -> Stat -> Stat
readStat :: Evalable m => Stat -> m IValue
evalStat :: Evalable m => Stat -> Eval m -> Eval m
instance Bounded Stat
instance Num Stat
instance Eq Stat
instance Show Stat
instance Num (Info -> Value)
instance Eq (Info -> Value)
instance Show (Info -> Value)

module Control.Search.Combinator.For
for :: Int32 -> Search -> Search
foreach :: Int32 -> ((Info -> Value) -> Search) -> Search

module Control.Search.Combinator.Failure
failure :: Search

module Control.Search.Combinator.Until
until :: Stat -> Search -> Search -> Search
limit :: Int32 -> Stat -> Search -> Search
glimit :: Stat -> Search -> Search

module Control.Search.Combinator.If
if' :: Stat -> Search -> Search -> Search

module Control.Search.Combinator.OrRepeat
orRepeat :: Stat -> Search -> Search

module Control.Search.Combinator.Let
let' :: VarId -> Stat -> Search -> Search
set' :: VarId -> Stat -> Search -> Search

module Control.Search.Combinator.Success
dummy :: Search

module Control.Search.Combinator.Base
label :: String -> (Value -> Value) -> (Value -> Value -> Value, Value) -> (Value -> Value) -> (Value -> Value -> Constraint) -> Search
vlabel :: String -> (Value -> Value) -> (Value -> Value -> Constraint) -> Search
glabel :: String -> VarSel -> (Value -> Value) -> (Value -> Value -> Constraint) -> Search
gblabel :: String -> VarSel -> (Value -> Value) -> (Value -> Value -> Constraint) -> Search
int_assign :: String -> VarSel -> (Value -> Value) -> (Value -> Value -> Constraint) -> Search
ilabel :: String -> (Value -> Value) -> (Value -> Value -> Value, Value) -> (Value -> Value) -> (Value -> Value -> Constraint) -> Search
maxV :: (Value -> Value -> Value, Value)
minV :: (Value -> Value -> Value, Value)
lbV :: Value -> Value
ubV :: Value -> Value
domsizeV :: Value -> Value
lbRegretV :: Value -> Value
ubRegretV :: Value -> Value
degreeV :: Value -> Value
domSizeDegreeV :: Value -> Value
wDegreeV :: Value -> Value
domSizeWDegreeV :: Value -> Value
randomV :: b -> Value
minD :: Value -> Value
maxD :: Value -> Value
meanD :: Value -> Value
medianD :: Value -> Value
randomD :: Value -> Value
foldVarSel :: (Value -> Value) -> (Value -> Value -> Value, Value) -> Info -> String -> Statement -> Statement -> Statement
ifoldVarSel :: (Value -> Value) -> (Value -> Value -> Value, Value) -> Info -> String -> Statement -> Statement -> Statement
bfoldVarSel :: (Value -> Value) -> (Value -> Value -> Value, Value) -> Info -> String -> Statement -> Statement -> Statement
bifoldVarSel :: (Value -> Value) -> (Value -> Value -> Value, Value) -> Info -> String -> Statement -> Statement -> Statement

module Control.Search.Combinator.Once
once :: Search
onceOld :: Search -> Search

module Control.Search.Combinator.And
andN :: [Search] -> Search
(<&>) :: Search -> Search -> Search

module Control.Search.Combinator.Repeat
repeat :: Search -> Search

module Control.Search.Combinator.Or
(<|>) :: Search -> Search -> Search

module Control.Search.Constraints
clvar :: VarId -> ConstraintExpr
cvar :: String -> ConstraintExpr
cvars :: String -> Integer -> ConstraintExpr
cbvars :: String -> Integer -> ConstraintExpr
cval :: Integer -> ConstraintExpr
cop :: ConstraintExpr -> (Value -> Value -> Constraint) -> ConstraintExpr -> ConstraintGen
ctrue :: ConstraintGen
cfalse :: ConstraintGen
cexprStatVal :: ConstraintExpr -> Stat
cexprStatMed :: ConstraintExpr -> Stat
cexprStatMin :: ConstraintExpr -> Stat
cexprStatMax :: ConstraintExpr -> Stat
data ConstraintExpr
ConstraintExpr :: (forall m. VarInfoM m => m IValue) -> Bool -> [String] -> ConstraintExpr
data ConstraintGen
ConstraintGen :: (forall m. VarInfoM m => Info -> m Constraint) -> [String] -> ConstraintGen

module Control.Search.Combinator.Post
post :: ConstraintGen -> Search -> Search

module Control.Search.Combinator.Misc
dbs :: Int32 -> Search
lds :: Stat -> Search
bbmin :: String -> Search

module Control.Search.Combinator.Print
prt :: [String] -> Search
dbg :: String -> Search

module Control.CP.PriorityQueue
data Ord k => PriorityQueue k a
empty :: Ord k => PriorityQueue k a
is_empty :: PriorityQueue t t1 -> Bool
minKey :: Ord k => PriorityQueue k a -> k
minKeyValue :: Ord k => PriorityQueue k a -> (k, a)
insert :: Ord k => k -> a -> PriorityQueue k a -> PriorityQueue k a
deleteMin :: Ord k => PriorityQueue k a -> ((k, a), PriorityQueue k a)
deleteMinAndInsert :: Ord k => k -> a -> PriorityQueue k a -> PriorityQueue k a

module Control.CP.Debug
debug :: String -> a -> a
imdebug :: Show a => String -> a -> a

module Control.CP.FD.OvertonFD.Domain
data Domain
class ToDomain a
toDomain :: ToDomain a => a -> Domain
member :: Int -> Domain -> Bool
isSubsetOf :: Domain -> Domain -> Bool
elems :: Domain -> [Int]
intersection :: Domain -> Domain -> Domain
difference :: Domain -> Domain -> Domain
union :: Domain -> Domain -> Domain
empty :: Domain
null :: Domain -> Bool
singleton :: Int -> Domain
isSingleton :: Domain -> Bool
filterLessThan :: Int -> Domain -> Domain
filterGreaterThan :: Int -> Domain -> Domain
findMax :: Domain -> Int
findMin :: Domain -> Int
size :: Domain -> Int
shiftDomain :: Domain -> Int -> Domain
mapDomain :: Domain -> (Int -> [Int]) -> Domain
absDomain :: Domain -> Domain
instance [incoherent] Show Domain
instance [incoherent] Eq Domain
instance [incoherent] Integral a => ToDomain a
instance [incoherent] ToDomain ()
instance [incoherent] (Integral a, Integral b) => ToDomain (a, b)
instance [incoherent] Integral a => ToDomain [a]
instance [incoherent] ToDomain IntSet
instance [incoherent] ToDomain Domain

module Control.CP.Queue
class Queue q where type family Elem q :: *
emptyQ :: Queue q => q -> q
isEmptyQ :: Queue q => q -> Bool
popQ :: Queue q => q -> (Elem q, q)
pushQ :: Queue q => Elem q -> q -> q
instance Ord a => Queue (PriorityQueue a (a, b, c))
instance Queue (Seq a)
instance Queue [a]


-- | Module with basic infrastructure for function inheritance based on
--   open rercusion.
--   
--   See the work of William Cook.
--   
--   We use the following terminology.
--   
--   <ul>
--   <li>A <i>closed</i> function is an ordinary function.</li>
--   <li>A <i>mixin</i> function is an open function that can be inherited
--   from, or that extends another open function.</li>
--   </ul>
--   
--   We obtain a closed function from a base mixin <tt>base</tt> and a
--   number of mixin extensions <tt>e1</tt>,...,<tt>en</tt> as follows:
--   
--   <pre>
--   mixin (en &lt;@&gt; ... &lt;@&gt; e1 &lt;@&gt; base)
--   </pre>
module Control.Mixin.Mixin

-- | Type of mixin functions.
type Mixin a = a -> a -> a

-- | Mixin composition.
(<@>) :: Mixin a -> Mixin a -> Mixin a

-- | Turn a mixin into a closed function.
mixin :: Mixin a -> a

-- | Mixin identity function.
--   
--   Identity for mixin composition:
--   
--   <pre>
--   mixinId &lt;@&gt; f  ==  f
--   f &lt;@&gt; mixinId  ==  f
--   </pre>
mixinId :: Mixin a

-- | Mixin lift function
--   
--   <pre>
--   mixin . mixinLift = id
--   </pre>
mixinLift :: (a -> b) -> Mixin (a -> b)

module Control.CP.Solver
class Monad solver => Solver solver where type family Constraint solver :: * type family Label solver :: * markn _ = mark
add :: Solver solver => Constraint solver -> solver Bool
run :: Solver solver => solver a -> a
mark :: Solver solver => solver (Label solver)
markn :: Solver solver => Int -> solver (Label solver)
goto :: Solver solver => Label solver -> solver ()
class Solver solver => Term solver term where type family Help solver term
newvar :: Term solver term => solver term
help :: Term solver term => solver () -> term -> Help solver term
instance (Monoid w, Term s t) => Term (WriterT w s) t
instance (Monoid w, Solver s) => Solver (WriterT w s)

module Control.CP.SearchTree
data Tree s a
Fail :: Tree s a
Return :: a -> Tree s a
Try :: Tree s a -> Tree s a -> Tree s a
Add :: Constraint s -> Tree s a -> Tree s a
NewVar :: (t -> Tree s a) -> Tree s a
Label :: s (Tree s a) -> Tree s a
transformTree :: Solver s => Mixin (Tree s a -> Tree s a)
bindTree :: Solver s => Tree s a -> (a -> Tree s b) -> Tree s b
insertTree :: Solver s => Tree s a -> Tree s () -> Tree s a
(/\) :: MonadTree tree => tree a -> tree b -> tree b
true :: MonadTree tree => tree ()
disj :: MonadTree tree => [tree a] -> tree a
conj :: MonadTree tree => [tree ()] -> tree ()
disj2 :: MonadTree tree => [tree a] -> tree a
prim :: MonadTree tree => TreeSolver tree a -> tree a
addC :: MonadTree tree => Constraint (TreeSolver tree) -> tree ()
addT :: MonadTree tree => Constraint (TreeSolver tree) -> tree Bool
exist :: (MonadTree tree, Term (TreeSolver tree) t) => Int -> ([t] -> tree a) -> tree a
forall :: (MonadTree tree, Term (TreeSolver tree) t) => [t] -> (t -> tree ()) -> tree ()

-- | show
indent :: Int -> String
showTree :: (Show (Constraint s), Show a, Solver s) => Int -> Tree s a -> s String
mapTree :: (Solver s1, Solver s2, MonadTree m, TreeSolver m ~ s2) => (forall t. s1 t -> s2 t) -> Tree s1 a -> m a

-- | Generalization of the search tree data type, allowing monad
--   transformer decoration.
class (Monad m, Solver (TreeSolver m)) => MonadTree m where type family TreeSolver m :: * -> *
addTo :: MonadTree m => Constraint (TreeSolver m) -> m a -> m a
false :: MonadTree m => m a
(\/) :: MonadTree m => m a -> m a -> m a
exists :: (MonadTree m, Term (TreeSolver m) t) => (t -> m a) -> m a
label :: MonadTree m => (TreeSolver m) (m a) -> m a
untree :: Solver s => v -> Tree s v -> s v
instance MonadTree t => MonadTree (StateT s t)
instance (Monoid w, MonadTree t) => MonadTree (WriterT w t)
instance MonadTree t => MonadTree (ReaderT env t)
instance Show (Tree s a)
instance (MonadTree m, Solver (TreeSolver m)) => MonadTree (ContT r m)
instance Solver solver => MonadTree (Tree solver)
instance Solver s => Monad (Tree s)
instance Solver s => Functor (Tree s)

module Control.CP.Transformers
eval :: (Solver solver, Queue q, Elem q ~ (Label solver, Tree solver (ForResult t), TreeState t), Transformer t, ForSolver t ~ solver) => Tree solver (ForResult t) -> q -> t -> solver (Int, [ForResult t])
eval' :: SearchSig solver q t (ForResult t)
continue :: ContinueSig solver q t (ForResult t)
data NodeBoundedST (solver :: * -> *) a
data DepthBoundedST (solver :: * -> *) a
class Transformer t where type family EvalState t :: * type family TreeState t :: * type family ForSolver t :: * -> * type family ForResult t :: * leftT _ _ = id rightT = leftT nextT = eval' returnT i wl t es = continue i wl t es endT i wl t es = return (i, [])
leftT, rightT :: Transformer t => t -> EvalState t -> TreeState t -> TreeState t
nextT :: Transformer t => SearchSig (ForSolver t) q t (ForResult t)
initT :: Transformer t => t -> Tree (ForSolver t) (ForResult t) -> (ForSolver t) (EvalState t, TreeState t)
returnT :: Transformer t => ContinueSig solver q t (ForResult t)
endT :: Transformer t => ContinueSig solver q t (ForResult t)
instance Solver solver => Transformer (NodeBoundedST solver a)
instance Solver solver => Transformer (DepthBoundedST solver a)

module Control.CP.ComposableTransformers
solve :: (Queue q, Solver solver, CTransformer c, CForSolver c ~ solver, Elem q ~ (Label solver, Tree solver (CForResult c), CTreeState c)) => q -> c -> Tree solver (CForResult c) -> (Int, [CForResult c])
restart :: (Queue q, Solver solver, CTransformer c, CForSolver c ~ solver, Elem q ~ (Label solver, Tree solver (CForResult c), CTreeState c)) => q -> [c] -> Tree solver (CForResult c) -> (Int, [CForResult c])
type NewBound solver = solver (Bound solver)
newtype Bound solver
Bound :: (forall a. Tree solver a -> Tree solver a) -> Bound solver
data Composition es ts solver a
(:-) :: c1 -> c2 -> Composition (CEvalState c1, CEvalState c2) (CTreeState c1, CTreeState c2) solver a
class Solver (CForSolver c) => CTransformer c where type family CTreeState c :: * type family CForSolver c :: * -> * type family CForResult c :: * leftCT _ = id rightCT = leftCT nextCT = evalCT returnCT = continueCT completeCT _ _ = True
data RestartST es ts (solver :: * -> *) a
RestartST :: [SealedCST es ts solver a] -> (Tree solver a -> solver (Tree solver a)) -> RestartST es ts a
data SealedCST es ts solver a
Seal :: c -> SealedCST (CEvalState c) (CTreeState c) (CForSolver c) (CForResult c)
newtype CNodeBoundedST (solver :: * -> *) a
CNBST :: Int -> CNodeBoundedST a
newtype CDepthBoundedST (solver :: * -> *) a
CDBST :: Int -> CDepthBoundedST a
newtype CBranchBoundST (solver :: * -> *) a
CBBST :: (NewBound solver) -> CBranchBoundST a
data CFirstSolutionST (solver :: * -> *) a
CFSST :: CFirstSolutionST a
data CSolutionBoundST (solver :: * -> *) a
CSBST :: Int -> CSolutionBoundST a
data CIdentityCST (solver :: * -> *) a
CIST :: CIdentityCST a
newtype CRandomST (solver :: * -> *) a
CRST :: Int -> CRandomST a
newtype CLimitedDiscrepancyST (solver :: * -> *) a
CLDST :: Int -> CLimitedDiscrepancyST a
instance Solver solver => Transformer (RestartST es ts solver a)
instance Solver solver => CTransformer (SealedCST es ts solver a)
instance Solver solver => CTransformer (CBranchBoundST solver a)
instance Solver solver => CTransformer (Composition es ts solver a)
instance Solver solver => CTransformer (CSolutionBoundST solver a)
instance Solver solver => CTransformer (CFirstSolutionST solver a)
instance Solver solver => CTransformer (CIdentityCST solver a)
instance Solver solver => CTransformer (CRandomST solver a)
instance Solver solver => CTransformer (CLimitedDiscrepancyST solver a)
instance Solver solver => CTransformer (CDepthBoundedST solver a)
instance Solver solver => CTransformer (CNodeBoundedST solver a)
instance Solver solver => Transformer (TStack es ts solver a)

module Control.CP.EnumTerm
class (Solver s, Term s t, Show (TermBaseType s t)) => EnumTerm s t where type family TermBaseType s t :: * getDomainSize x = do { r <- getDomain x; return $ length r } getValue x = do { d <- getDomain x; return $ case d of { [v] -> Just v _ -> Nothing } } splitDomain x = do { d <- getDomain x; case d of { [] -> return ([], True) [_] -> return ([[]], True) _ -> do { rr <- mapM (setValue x) d; return (rr, True) } } } splitDomains [] = return ([[]], []) splitDomains (a@(x : b)) = do { s <- getDomainSize x; if s == 0 then return ([], []) else if s == 1 then splitDomains b else do { (r, v) <- splitDomain x; if v then return (r, b) else return (r, a) } } defaultOrder = firstFail enumerator = Nothing
getDomainSize :: EnumTerm s t => t -> s (Int)
getDomain :: EnumTerm s t => t -> s [TermBaseType s t]
setValue :: EnumTerm s t => t -> TermBaseType s t -> s [Constraint s]
splitDomain :: EnumTerm s t => t -> s ([[Constraint s]], Bool)
splitDomains :: EnumTerm s t => [t] -> s ([[Constraint s]], [t])
getValue :: EnumTerm s t => t -> s (Maybe (TermBaseType s t))
defaultOrder :: EnumTerm s t => [t] -> s [t]
enumerator :: (EnumTerm s t, MonadTree m, TreeSolver m ~ s) => Maybe ([t] -> m ())
assignment :: (EnumTerm s t, MonadTree m, TreeSolver m ~ s) => t -> m (TermBaseType s t)
assignments :: (EnumTerm s t, MonadTree m, TreeSolver m ~ s) => [t] -> m [TermBaseType s t]
inOrder :: EnumTerm s t => [t] -> s [t]
firstFail :: EnumTerm s t => [t] -> s [t]
middleOut :: EnumTerm s t => [t] -> s [t]
endsOut :: EnumTerm s t => [t] -> s [t]
labelling :: (MonadTree m, TreeSolver m ~ s, EnumTerm s t) => ([t] -> s [t]) -> [t] -> m ()
levelList :: (Solver s, MonadTree m, TreeSolver m ~ s) => [m ()] -> m ()
enumerate :: (MonadTree m, TreeSolver m ~ s, EnumTerm s t) => [t] -> m ()

module Data.Linear
data (Ord t, Num v) => Linear t v
integerToLinear :: (Num v, Ord t) => Integer -> Linear t v
constToLinear :: (Num v, Ord t) => v -> Linear t v
termToLinear :: (Num v, Ord t) => t -> Linear t v
linearToConst :: (Num v, Ord t) => Linear t v -> Maybe v
linearToTerm :: (Num v, Eq v, Ord t) => Linear t v -> Maybe t
linearMultiply :: (Num v, Eq v, Ord t) => Linear t v -> Linear t v -> Maybe (Linear t v)
linearMult :: (Num v, Eq v, Ord t) => v -> Linear t v -> Linear t v
linearToList :: (Ord t, Num v) => Linear t v -> [(Maybe t, v)]
linearToListEx :: (Ord t, Num v) => Linear t v -> (v, [(t, v)])
getCoef :: (Num v, Ord t) => Maybe t -> Linear t v -> v
instance (Num v, Show v, Ord t, Show t) => Show (Linear t v)
instance (Num v, Ord v, Ord t, Eq t) => Ord (Linear t v)
instance (Num v, Eq v, Ord t, Eq t) => Eq (Linear t v)
instance (Num v, Eq v, Ord t, Eq t, Show t) => Num (Linear t v)

module Data.Expr.Data

-- | Data types | --
data Expr t c b
Term :: t -> Expr t c b
ExprHole :: Int -> Expr t c b
Const :: Integer -> Expr t c b
Plus :: (Expr t c b) -> (Expr t c b) -> Expr t c b
Minus :: (Expr t c b) -> (Expr t c b) -> Expr t c b
Mult :: (Expr t c b) -> (Expr t c b) -> Expr t c b
Div :: (Expr t c b) -> (Expr t c b) -> Expr t c b
Mod :: (Expr t c b) -> (Expr t c b) -> Expr t c b
Abs :: (Expr t c b) -> Expr t c b
At :: (ColExpr t c b) -> (Expr t c b) -> Expr t c b
Fold :: (Expr t c b -> Expr t c b -> Expr t c b) -> (Expr t c b) -> (ColExpr t c b) -> Expr t c b
Cond :: (BoolExpr t c b) -> (Expr t c b) -> (Expr t c b) -> Expr t c b
ColSize :: (ColExpr t c b) -> Expr t c b
Channel :: (BoolExpr t c b) -> Expr t c b
data ColExpr t c b
ColTerm :: c -> ColExpr t c b
ColList :: [Expr t c b] -> ColExpr t c b
ColRange :: (Expr t c b) -> (Expr t c b) -> ColExpr t c b
ColMap :: (Expr t c b -> Expr t c b) -> (ColExpr t c b) -> ColExpr t c b
ColSlice :: (Expr t c b -> Expr t c b) -> (Expr t c b) -> (ColExpr t c b) -> ColExpr t c b
ColCat :: (ColExpr t c b) -> (ColExpr t c b) -> ColExpr t c b
data BoolExpr t c b
BoolTerm :: b -> BoolExpr t c b
BoolConst :: Bool -> BoolExpr t c b
BoolAnd :: (BoolExpr t c b) -> (BoolExpr t c b) -> BoolExpr t c b
BoolOr :: (BoolExpr t c b) -> (BoolExpr t c b) -> BoolExpr t c b
BoolNot :: (BoolExpr t c b) -> BoolExpr t c b
BoolCond :: (BoolExpr t c b) -> (BoolExpr t c b) -> (BoolExpr t c b) -> BoolExpr t c b
Rel :: (Expr t c b) -> ExprRel -> (Expr t c b) -> BoolExpr t c b
BoolAll :: (Expr t c b -> BoolExpr t c b) -> (ColExpr t c b) -> BoolExpr t c b
BoolAny :: (Expr t c b -> BoolExpr t c b) -> (ColExpr t c b) -> BoolExpr t c b
ColEqual :: (ColExpr t c b) -> (ColExpr t c b) -> BoolExpr t c b
BoolEqual :: (BoolExpr t c b) -> (BoolExpr t c b) -> BoolExpr t c b
AllDiff :: Bool -> (ColExpr t c b) -> BoolExpr t c b
Sorted :: Bool -> (ColExpr t c b) -> BoolExpr t c b
Dom :: (Expr t c b) -> (ColExpr t c b) -> BoolExpr t c b
data ExprRel
EREqual :: ExprRel
ERDiff :: ExprRel
ERLess :: ExprRel

-- | ExprKey: Provides ordering over expressions | --
(<<>>) :: Ordering -> Ordering -> Ordering
instance Show ExprRel
instance Eq ExprRel
instance Ord ExprRel
instance (Ord s, Ord c, Ord b) => Ord (BoolExpr s c b)
instance (Ord s, Ord c, Ord b) => Ord (ColExpr s c b)
instance (Ord s, Ord c, Ord b) => Ord (Expr s c b)
instance (Eq t, Eq c, Eq b) => Eq (BoolExpr t c b)
instance (Eq t, Eq c, Eq b) => Eq (ColExpr t c b)
instance (Eq t, Eq c, Eq b) => Eq (Expr t c b)
instance (Show t, Show c, Show b) => Show (BoolExpr t c b)
instance (Show t, Show c, Show b) => Show (ColExpr t c b)
instance (Show t, Show c, Show b) => Show (Expr t c b)
instance (Show t, Show c, Show b, ShowFn e) => ShowFn (Expr t c b -> e)
instance (Show t, Show c, Show b) => ShowFn (BoolExpr t c b)
instance (Show t, Show c, Show b) => ShowFn (ColExpr t c b)
instance ShowFn l => ShowFn [l]
instance (Show t, Show c, Show b) => ShowFn (Expr t c b)

module Data.Expr.Util

-- | Data types | --
data Expr t c b
data BoolExpr t c b
data ColExpr t c b

-- | Transform expressions over one type to expressions over another | --
transform :: (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f) => (a -> b, c -> d, e -> f, b -> a, d -> c, f -> e) -> Expr a c e -> Expr b d f
colTransform :: (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f) => (a -> b, c -> d, e -> f, b -> a, d -> c, f -> e) -> ColExpr a c e -> ColExpr b d f
boolTransform :: (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f) => (a -> b, c -> d, e -> f, b -> a, d -> c, f -> e) -> BoolExpr a c e -> BoolExpr b d f
transformEx :: (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f) => (a -> Expr b d f, c -> ColExpr b d f, e -> BoolExpr b d f, b -> Expr a c e, d -> ColExpr a c e, f -> BoolExpr a c e) -> Expr a c e -> Expr b d f
colTransformEx :: (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f) => (a -> Expr b d f, c -> ColExpr b d f, e -> BoolExpr b d f, b -> Expr a c e, d -> ColExpr a c e, f -> BoolExpr a c e) -> ColExpr a c e -> ColExpr b d f
boolTransformEx :: (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f) => (a -> Expr b d f, c -> ColExpr b d f, e -> BoolExpr b d f, b -> Expr a c e, d -> ColExpr a c e, f -> BoolExpr a c e) -> BoolExpr a c e -> BoolExpr b d f
property :: (a -> Bool) -> (b -> Bool) -> (c -> Bool) -> Expr a b c -> Bool
colProperty :: (a -> Bool) -> (b -> Bool) -> (c -> Bool) -> ColExpr a b c -> Bool
boolProperty :: (a -> Bool) -> (b -> Bool) -> (c -> Bool) -> BoolExpr a b c -> Bool

-- | Check whether an expression is possibly referring to terms with a
--   given property | --
propertyEx :: (Expr a b c -> Maybe Bool, ColExpr a b c -> Maybe Bool, BoolExpr a b c -> Maybe Bool) -> Expr a b c -> Bool
colPropertyEx :: (Expr a b c -> Maybe Bool, ColExpr a b c -> Maybe Bool, BoolExpr a b c -> Maybe Bool) -> ColExpr a b c -> Bool
boolPropertyEx :: (Expr a b c -> Maybe Bool, ColExpr a b c -> Maybe Bool, BoolExpr a b c -> Maybe Bool) -> BoolExpr a b c -> Bool

-- | Turn expressions over expressions into simply expressions | --
collapse :: (Eq t, Eq c, Eq b) => Expr (Expr t c b) (ColExpr t c b) (BoolExpr t c b) -> Expr t c b
colCollapse :: (Eq t, Eq c, Eq b) => ColExpr (Expr t c b) (ColExpr t c b) (BoolExpr t c b) -> ColExpr t c b
boolCollapse :: (Eq t, Eq c, Eq b) => BoolExpr (Expr t c b) (ColExpr t c b) (BoolExpr t c b) -> BoolExpr t c b

-- | Simplify expressions | --
simplify :: (Eq s, Eq c, Eq b) => Expr s c b -> Expr s c b
colSimplify :: (Eq s, Eq c, Eq b) => ColExpr s c b -> ColExpr s c b
boolSimplify :: (Eq s, Eq c, Eq b) => BoolExpr s c b -> BoolExpr s c b

-- | walk through expressions
data WalkPhase
WalkPre :: WalkPhase
WalkSingle :: WalkPhase
WalkPost :: WalkPhase
data WalkResult
WalkSkip :: WalkResult
WalkDescend :: WalkResult
walk :: (Eq t, Eq c, Eq b, Monad m) => Expr t c b -> (Expr t c b -> WalkPhase -> m WalkResult, ColExpr t c b -> WalkPhase -> m WalkResult, BoolExpr t c b -> WalkPhase -> m WalkResult) -> m ()
colWalk :: (Eq t, Eq c, Eq b, Monad m) => ColExpr t c b -> (Expr t c b -> WalkPhase -> m WalkResult, ColExpr t c b -> WalkPhase -> m WalkResult, BoolExpr t c b -> WalkPhase -> m WalkResult) -> m ()
boolWalk :: (Eq t, Eq c, Eq b, Monad m) => BoolExpr t c b -> (Expr t c b -> WalkPhase -> m WalkResult, ColExpr t c b -> WalkPhase -> m WalkResult, BoolExpr t c b -> WalkPhase -> m WalkResult) -> m ()
instance Ord WalkPhase
instance Eq WalkPhase
instance Enum WalkPhase
instance Show WalkPhase
instance Ord WalkResult
instance Eq WalkResult
instance Enum WalkResult
instance Show WalkResult

module Control.CP.FD.Graph
data EGConstraintSpec
EGIntValue :: EGPar -> EGConstraintSpec
EGBoolValue :: EGBoolPar -> EGConstraintSpec
EGColValue :: EGColPar -> EGConstraintSpec
EGIntExtern :: Int -> EGConstraintSpec
EGBoolExtern :: Int -> EGConstraintSpec
EGColExtern :: Int -> EGConstraintSpec
EGPlus :: EGConstraintSpec
EGMinus :: EGConstraintSpec
EGMult :: EGConstraintSpec
EGDiv :: EGConstraintSpec
EGMod :: EGConstraintSpec
EGAbs :: EGConstraintSpec
EGAt :: EGConstraintSpec
EGFold :: EGModel -> (Int, Int, Int) -> EGConstraintSpec
EGSize :: EGConstraintSpec
EGChannel :: EGConstraintSpec
EGList :: Int -> EGConstraintSpec
EGRange :: EGConstraintSpec
EGMap :: EGModel -> (Int, Int, Int) -> EGConstraintSpec
EGSlice :: EGModel -> (Int, Int, Int) -> EGConstraintSpec
EGCat :: EGConstraintSpec
EGAnd :: EGConstraintSpec
EGOr :: EGConstraintSpec
EGEquiv :: EGConstraintSpec
EGNot :: EGConstraintSpec
EGEqual :: EGConstraintSpec
EGDiff :: EGConstraintSpec
EGLess :: Bool -> EGConstraintSpec
EGAll :: EGModel -> (Int, Int, Int) -> Bool -> EGConstraintSpec
EGAny :: EGModel -> (Int, Int, Int) -> Bool -> EGConstraintSpec
EGSorted :: Bool -> EGConstraintSpec
EGAllDiff :: Bool -> EGConstraintSpec
EGDom :: EGConstraintSpec
EGCondEqual :: EGConstraintSpec
EGCondInt :: EGConstraintSpec
data EGParTerm
EGPTParam :: Int -> EGParTerm
data EGParBoolTerm
EGPTBoolParam :: Int -> EGParBoolTerm
data EGParColTerm
EGPTColParam :: Int -> EGParColTerm
type EGPar = Expr EGParTerm EGParColTerm EGParBoolTerm
type EGBoolPar = BoolExpr EGParTerm EGParColTerm EGParBoolTerm
type EGColPar = ColExpr EGParTerm EGParColTerm EGParBoolTerm
type EGConsArgs = (Int, Int, Int)
data EGEdgeId
data EGVarId
EGVarId :: Int -> EGVarId
unVarId :: EGVarId -> Int
data EGVarType
EGBoolType :: EGVarType
EGIntType :: EGVarType
EGColType :: EGVarType
data EGTypeData x
EGTypeData :: x -> x -> x -> EGTypeData x
boolData :: EGTypeData x -> x
intData :: EGTypeData x -> x
colData :: EGTypeData x -> x
data EGEdge
EGEdge :: EGConstraintSpec -> EGTypeData [EGVarId] -> EGEdge
egeCons :: EGEdge -> EGConstraintSpec
egeLinks :: EGEdge -> EGTypeData [EGVarId]
data EGModel
EGModel :: EGTypeData Int -> EGTypeData Int -> Int -> Map EGEdgeId EGEdge -> EGTypeData (Map EGVarId [(EGEdgeId, Int)]) -> EGModel
egmParams :: EGModel -> EGTypeData Int
egmVars :: EGModel -> EGTypeData Int
egmNEdges :: EGModel -> Int
egmEdges :: EGModel -> Map EGEdgeId EGEdge
egmLinks :: EGModel -> EGTypeData (Map EGVarId [(EGEdgeId, Int)])
addEdge :: EGConstraintSpec -> EGTypeData [EGVarId] -> EGModel -> EGModel
addNode :: EGVarType -> EGModel -> (EGVarId, EGModel)
delNode :: EGVarType -> EGVarId -> EGModel -> EGModel
findEdge :: EGModel -> EGVarType -> EGVarId -> (Int -> Bool) -> (EGConstraintSpec -> Bool) -> Maybe (EGEdgeId, EGEdge)
unifyNodes :: EGVarType -> EGVarId -> EGVarId -> EGModel -> EGModel
unifyIds :: EGVarId -> EGVarId -> EGVarId -> EGVarId
baseGraph :: EGModel
baseTypeData :: x -> EGTypeData x
egTypeDataMap :: ((forall a. EGTypeData a -> a) -> b) -> EGTypeData b
egTypeGet :: EGVarType -> EGTypeData a -> a
egTypeMod :: EGVarType -> EGTypeData a -> (a -> a) -> EGTypeData a
present :: Display a => a -> String
getConnectedEdges :: EGModel -> EGVarType -> EGVarId -> [(EGEdge, Int)]
externMap :: EGModel -> EGTypeData (Map Int EGVarId)
filterModel :: EGModel -> (EGEdge -> Maybe a) -> (EGModel, [a])
emptyModel :: EGModel -> Bool
pruneNodes :: EGModel -> EGModel
instance Eq x => Eq (EGTypeData x)
instance Show x => Show (EGTypeData x)
instance Eq EGVarType
instance Show EGVarType
instance Show EGParTerm
instance Eq EGParTerm
instance Ord EGParTerm
instance Show EGParBoolTerm
instance Eq EGParBoolTerm
instance Ord EGParBoolTerm
instance Show EGParColTerm
instance Eq EGParColTerm
instance Ord EGParColTerm
instance Eq EGEdgeId
instance Ord EGEdgeId
instance Show EGEdgeId
instance Eq EGVarId
instance Ord EGVarId
instance Show EGVarId
instance Eq EGModel
instance Show EGModel
instance Eq EGEdge
instance Show EGEdge
instance Eq EGConstraintSpec
instance Show EGConstraintSpec
instance Display DisplayData
instance Display EGModel
instance Display EGEdge
instance Show (EGPar -> EGPar)
instance Eq (EGPar -> EGPar)
instance Ord (EGPar -> EGPar)

module Data.Expr.Sugar

-- | integer operators/functions | --
(@+) :: (Eq t, Eq c, Eq b, ToExpr t c b p, ToExpr t c b q) => p -> q -> Expr t c b
(@-) :: (Eq t, Eq c, Eq b, ToExpr t c b p, ToExpr t c b q) => p -> q -> Expr t c b
(@*) :: (Eq t, Eq c, Eq b, ToExpr t c b p, ToExpr t c b q) => p -> q -> Expr t c b
(@/) :: (Eq t, Eq c, Eq b, ToExpr t c b p, ToExpr t c b q) => p -> q -> Expr t c b
(@%) :: (Eq t, Eq c, Eq b, ToExpr t c b p, ToExpr t c b q) => p -> q -> Expr t c b
(@?) :: (Eq t, Eq c, Eq b) => BoolExpr t c b -> (Expr t c b, Expr t c b) -> Expr t c b
(@??) :: (Eq t, Eq c, Eq b) => BoolExpr t c b -> (BoolExpr t c b, BoolExpr t c b) -> BoolExpr t c b

-- | list operators/functions | --
(!) :: (Eq t, Eq c, Eq b) => ColExpr t c b -> Expr t c b -> Expr t c b
(@!!) :: (Eq t, Eq c, Eq b) => ColExpr t c b -> Integer -> Expr t c b
(@++) :: (Eq t, Eq c, Eq b) => ColExpr t c b -> ColExpr t c b -> ColExpr t c b
(@..) :: (Eq t, Eq c, Eq b) => Expr t c b -> Expr t c b -> ColExpr t c b
size :: (Eq t, Eq c, Eq b) => ColExpr t c b -> Expr t c b
slice :: (Eq t, Eq c, Eq b) => ColExpr t c b -> ColExpr t c b -> ColExpr t c b
xhead :: (Eq t, Eq c, Eq b, ToColExpr t c b p) => p -> Expr t c b
xtail :: (Eq t, Eq c, Eq b, ToColExpr t c b p) => p -> ColExpr t c b
xmap :: (Eq t, Eq c, Eq b) => (Expr t c b -> Expr t c b) -> ColExpr t c b -> ColExpr t c b
xfold :: (Eq t, Eq c, Eq b) => (Expr t c b -> Expr t c b -> Expr t c b) -> Expr t c b -> ColExpr t c b -> Expr t c b
list :: (Eq t, Eq c, Eq b) => [Expr t c b] -> ColExpr t c b
channel :: (Eq t, Eq c, Eq b) => BoolExpr t c b -> Expr t c b
xsum :: (Num (Expr t c b), Eq t, Eq c, Eq b) => ColExpr t c b -> Expr t c b
(@||) :: (Eq s, Eq c, Eq b, ToBoolExpr s c b b1, ToBoolExpr s c b b2) => b1 -> b2 -> BoolExpr s c b
(@&&) :: (Eq s, Eq c, Eq b, ToBoolExpr s c b b1, ToBoolExpr s c b b2) => b1 -> b2 -> BoolExpr s c b

-- | boolean operators/functions | --
inv :: (Eq t, Eq c, Eq b, ToBoolExpr t c b p) => p -> BoolExpr t c b
(@>) :: (Eq t, Eq c, Eq b) => Expr t c b -> Expr t c b -> BoolExpr t c b
(@<) :: (Eq t, Eq c, Eq b) => Expr t c b -> Expr t c b -> BoolExpr t c b
(@>=) :: (Eq t, Eq c, Eq b) => Expr t c b -> Expr t c b -> BoolExpr t c b
(@<=) :: (Eq t, Eq c, Eq b) => Expr t c b -> Expr t c b -> BoolExpr t c b
loopall :: (Eq t, Eq c, Eq b) => (Expr t c b, Expr t c b) -> (Expr t c b -> BoolExpr t c b) -> BoolExpr t c b
loopany :: (Eq t, Eq c, Eq b) => (Expr t c b, Expr t c b) -> (Expr t c b -> BoolExpr t c b) -> BoolExpr t c b
forall :: (Eq t, Eq c, Eq b) => (ColExpr t c b) -> (Expr t c b -> BoolExpr t c b) -> BoolExpr t c b
forany :: (Eq t, Eq c, Eq b) => (ColExpr t c b) -> (Expr t c b -> BoolExpr t c b) -> BoolExpr t c b

-- | Data types | --
data Expr t c b
data ColExpr t c b
data BoolExpr t c b

-- | convertion from/to expression types | --
class ToExpr tt cc bb t
toExpr :: ToExpr tt cc bb t => t -> Expr tt cc bb
class ToColExpr tt cc bb c
toColExpr :: ToColExpr tt cc bb c => c -> ColExpr tt cc bb
class ToBoolExpr tt cc bb b
toBoolExpr :: ToBoolExpr tt cc bb b => b -> BoolExpr tt cc bb
sorted :: (Eq s, Eq c, Eq b) => ColExpr s c b -> BoolExpr s c b
sSorted :: (Eq s, Eq c, Eq b) => ColExpr s c b -> BoolExpr s c b
allDiff :: (Eq s, Eq c, Eq b) => ColExpr s c b -> BoolExpr s c b
allDiffD :: (Eq s, Eq c, Eq b) => ColExpr s c b -> BoolExpr s c b
class (Eq tt, Eq cc, Eq bb) => ExprClass tt cc bb a where a @/= b = boolSimplify $ BoolNot $ a @= b
(@=) :: ExprClass tt cc bb a => a -> a -> BoolExpr tt cc bb
(@/=) :: ExprClass tt cc bb a => a -> a -> BoolExpr tt cc bb
class (Eq tt, Eq cc, Eq bb) => ExprRange tt cc bb r
(@:) :: ExprRange tt cc bb r => Expr tt cc bb -> r -> BoolExpr tt cc bb
instance (Eq t, Eq c, Eq b) => ExprRange t c b (ColExpr t c b)
instance (Eq t, Eq c, Eq b) => ExprRange t c b (Expr t c b, Expr t c b)
instance (Eq t, Eq c, Eq b) => ExprClass t c b (ColExpr t c b)
instance (Eq t, Eq c, Eq b) => ExprClass t c b (BoolExpr t c b)
instance (Eq t, Eq c, Eq b) => ExprClass t c b (Expr t c b)
instance ToBoolExpr t a b b
instance ToColExpr t a b a
instance ToExpr t a b t
instance ToBoolExpr t a b (BoolExpr t a b)
instance ToBoolExpr tt cc bb Bool
instance (Eq b, Eq a, Eq t) => ToColExpr t a b [Expr t a b]
instance (Eq t, Eq a, Eq b) => ToColExpr t a b (Expr t a b)
instance ToColExpr t a b (ColExpr t a b)
instance (Eq t, Eq a, Eq b) => ToExpr t a b (BoolExpr t a b)
instance ToExpr tt cc bb Int
instance ToExpr t a b (Expr t a b)
instance ToExpr tt cc bb Integer
instance (Ord s, Ord c, Ord b, Eq s, Eq c, Eq b, Show s, Show c, Show b) => Integral (Expr s c b)
instance (Eq s, Eq c, Eq b) => Enum (Expr s c b)
instance (Ord s, Ord c, Ord b, Eq s, Eq c, Eq b, Show s, Show c, Show b) => Real (Expr s c b)
instance (Eq s, Eq c, Eq b, Show s, Show c, Show b) => Num (Expr s c b)

module Control.CP.FD.Model
type Model = ModelBool
data ModelIntTerm t
ModelIntVar :: Int -> ModelIntTerm t
ModelIntPar :: Int -> ModelIntTerm t
data ModelBoolTerm t
ModelBoolVar :: Int -> ModelBoolTerm t
ModelBoolPar :: Int -> ModelBoolTerm t
ModelExtra :: t -> ModelBoolTerm t
data ModelColTerm t
ModelColVar :: Int -> ModelColTerm t
ModelColPar :: Int -> ModelColTerm t
data ModelFunctions
ForNewBool :: (ModelBoolExpr ModelFunctions -> Model) -> ModelFunctions
ForNewInt :: (ModelIntExpr ModelFunctions -> Model) -> ModelFunctions
ForNewCol :: (ModelColExpr ModelFunctions -> Model) -> ModelFunctions
type ModelInt = ModelIntExpr ModelFunctions
class ToModelInt t
asExpr :: ToModelInt t => t -> ModelInt
type ModelIntArg = ModelIntTerm ModelFunctions
type ModelCol = ModelColExpr ModelFunctions
class ToModelCol t
asCol :: ToModelCol t => t -> ModelCol
type ModelColArg = ModelColTerm ModelFunctions
type ModelBool = ModelBoolExpr ModelFunctions
class ToModelBool t
asBool :: ToModelBool t => t -> ModelBool
type ModelBoolArg = ModelBoolTerm ModelFunctions
modelVariantInt :: ModelIntExpr x -> Bool
modelVariantBool :: ModelBoolExpr x -> Bool
modelVariantCol :: ModelColExpr x -> Bool
class ModelTermType s
newModelTerm :: ModelTermType s => (s -> Model) -> Model
showModel :: Model -> String
cte :: Integral a => a -> ModelInt
instance Ord t => Ord (ModelColTerm t)
instance Eq t => Eq (ModelColTerm t)
instance Ord t => Ord (ModelIntTerm t)
instance Eq t => Eq (ModelIntTerm t)
instance Ord t => Ord (ModelBoolTerm t)
instance Eq t => Eq (ModelBoolTerm t)
instance Show (ModelIntTerm t)
instance Show (ModelColTerm t)
instance Show t => Show (ModelBoolTerm t)
instance Show ModelIntros
instance Eq ModelIntros
instance ToColExpr (ModelIntTerm ModelFunctions) (ModelColTerm ModelFunctions) (ModelBoolTerm ModelFunctions) t => ToModelCol t
instance ToBoolExpr (ModelIntTerm ModelFunctions) (ModelColTerm ModelFunctions) (ModelBoolTerm ModelFunctions) t => ToModelBool t
instance ToExpr (ModelIntTerm ModelFunctions) (ModelColTerm ModelFunctions) (ModelBoolTerm ModelFunctions) t => ToModelInt t
instance ModelTermType ModelCol
instance ModelTermType ModelInt
instance ModelTermType ModelBool
instance Ord ModelFunctions
instance Eq ModelFunctions
instance Show ModelFunctions
instance Ord ModelIntros

module Control.CP.FD.Decompose
data DecompData

-- | base instance of DecompData
baseDecompData :: DecompData

-- | easier version of decomposeEx that does not require or return a state
decompose :: Model -> EGModel

-- | transform an expression into a graph, taking and returning an updated
--   state
decomposeEx :: DecompData -> Int -> Model -> ([ModelBool], [ModelInt], [ModelCol]) -> Maybe EGModel -> (DecompData, EGModel, Int)
decompBoolLookup :: DecompData -> ModelBool -> Maybe EGVarId
decompIntLookup :: DecompData -> ModelInt -> Maybe EGVarId
decompColLookup :: DecompData -> ModelCol -> Maybe EGVarId
instance Monad DCMonad
instance MonadState DCState DCMonad

module Control.CP.FD.FD

-- | definition of FDInstance, a Solver wrapper that adds power to post
--   boolean expressions as constraints
data FDSolver s => FDInstance s a

-- | A solver needs to be an instance of this FDSolver class in order to
--   create an FDInstance around it.
class (Solver s, Term s (FDIntTerm s), Term s (FDBoolTerm s), Eq (FDBoolSpecType s), Ord (FDBoolSpecType s), Enum (FDBoolSpecType s), Bounded (FDBoolSpecType s), Show (FDBoolSpecType s), Eq (FDIntSpecType s), Ord (FDIntSpecType s), Enum (FDIntSpecType s), Bounded (FDIntSpecType s), Show (FDIntSpecType s), Eq (FDColSpecType s), Ord (FDColSpecType s), Enum (FDColSpecType s), Bounded (FDColSpecType s), Show (FDColSpecType s), Show (FDIntSpec s), Show (FDColSpec s), Show (FDBoolSpec s)) => FDSolver s where type family FDIntTerm s :: * type family FDBoolTerm s :: * type family FDIntSpec s :: * type family FDBoolSpec s :: * type family FDColSpec s :: * type family FDIntSpecType s :: * type family FDBoolSpecType s :: * type family FDColSpecType s :: * fdTypeReqBool = return (\ (EGEdge {egeLinks = EGTypeData {boolData = l}}) -> map (\ x -> (x, fromList [minBound .. maxBound])) l) fdTypeReqInt = return (\ (EGEdge {egeLinks = EGTypeData {intData = l}}) -> map (\ x -> (x, fromList [minBound .. maxBound])) l) fdTypeReqCol = return (\ (EGEdge {egeLinks = EGTypeData {colData = l}}) -> map (\ x -> (x, fromList [minBound .. maxBound])) l) fdTypeVarInt = return $ singleton maxBound fdTypeVarBool = return $ singleton maxBound fdSpecify = mixinId
fdIntSpec_const :: FDSolver s => EGPar -> (FDIntSpecType s, s (FDIntSpec s))
fdBoolSpec_const :: FDSolver s => EGBoolPar -> (FDBoolSpecType s, s (FDBoolSpec s))
fdColSpec_const :: FDSolver s => EGColPar -> (FDColSpecType s, s (FDColSpec s))
fdColSpec_list :: FDSolver s => [FDIntSpec s] -> (FDColSpecType s, s (FDColSpec s))
fdIntSpec_term :: FDSolver s => FDIntTerm s -> (FDIntSpecType s, s (FDIntSpec s))
fdBoolSpec_term :: FDSolver s => FDBoolTerm s -> (FDBoolSpecType s, s (FDBoolSpec s))
fdColSpec_size :: FDSolver s => EGPar -> (FDColSpecType s, s (FDColSpec s))
fdIntVarSpec :: FDSolver s => FDIntSpec s -> s (Maybe (FDIntTerm s))
fdBoolVarSpec :: FDSolver s => FDBoolSpec s -> s (Maybe (FDBoolTerm s))
fdTypeReqBool :: FDSolver s => s (EGEdge -> [(EGVarId, FDBoolSpecTypeSet s)])
fdTypeReqInt :: FDSolver s => s (EGEdge -> [(EGVarId, FDIntSpecTypeSet s)])
fdTypeReqCol :: FDSolver s => s (EGEdge -> [(EGVarId, FDColSpecTypeSet s)])
fdTypeVarInt :: FDSolver s => s (Set (FDIntSpecType s))
fdTypeVarBool :: FDSolver s => s (Set (FDBoolSpecType s))
fdSpecify :: FDSolver s => Mixin (SpecFn s)
fdColInspect :: FDSolver s => FDColSpec s -> s [FDIntTerm s]
fdProcess :: FDSolver s => Mixin (EGConstraintSpec -> FDSpecInfo s -> FDInstance s ())
fdEqualBool :: FDSolver s => FDBoolSpec s -> FDBoolSpec s -> FDInstance s ()
fdEqualInt :: FDSolver s => FDIntSpec s -> FDIntSpec s -> FDInstance s ()
fdEqualCol :: FDSolver s => FDColSpec s -> FDColSpec s -> FDInstance s ()
fdConstrainIntTerm :: FDSolver s => FDIntTerm s -> Integer -> s (Constraint s)
fdSplitIntDomain :: FDSolver s => FDIntTerm s -> s ([Constraint s], Bool)
fdSplitBoolDomain :: FDSolver s => FDBoolTerm s -> s ([Constraint s], Bool)
type FDSpecInfo s = ([FDSpecInfoBool s], [FDSpecInfoInt s], [FDSpecInfoCol s])
data FDSpecInfoBool s
FDSpecInfoBool :: (Maybe (FDBoolSpecType s) -> Maybe (FDBoolSpec s)) -> Maybe EGVarId -> Maybe EGBoolPar -> Set (FDBoolSpecType s) -> FDSpecInfoBool s
fdspBoolSpec :: FDSpecInfoBool s -> Maybe (FDBoolSpecType s) -> Maybe (FDBoolSpec s)
fdspBoolVar :: FDSpecInfoBool s -> Maybe EGVarId
fdspBoolVal :: FDSpecInfoBool s -> Maybe EGBoolPar
fdspBoolTypes :: FDSpecInfoBool s -> Set (FDBoolSpecType s)
data FDSpecInfoInt s
FDSpecInfoInt :: (Maybe (FDIntSpecType s) -> Maybe (FDIntSpec s)) -> Maybe EGVarId -> Maybe EGPar -> Set (FDIntSpecType s) -> FDSpecInfoInt s
fdspIntSpec :: FDSpecInfoInt s -> Maybe (FDIntSpecType s) -> Maybe (FDIntSpec s)
fdspIntVar :: FDSpecInfoInt s -> Maybe EGVarId
fdspIntVal :: FDSpecInfoInt s -> Maybe EGPar
fdspIntTypes :: FDSpecInfoInt s -> Set (FDIntSpecType s)
data FDSpecInfoCol s
FDSpecInfoCol :: (Maybe (FDColSpecType s) -> Maybe (FDColSpec s)) -> Maybe EGVarId -> Maybe EGColPar -> Set (FDColSpecType s) -> FDSpecInfoCol s
fdspColSpec :: FDSpecInfoCol s -> Maybe (FDColSpecType s) -> Maybe (FDColSpec s)
fdspColVar :: FDSpecInfoCol s -> Maybe EGVarId
fdspColVal :: FDSpecInfoCol s -> Maybe EGColPar
fdspColTypes :: FDSpecInfoCol s -> Set (FDColSpecType s)

-- | lift a monad action for the underlying solver to a monad action for an
--   FDInstance around it
liftFD :: FDSolver s => s a -> FDInstance s a
addFD :: (Show (Constraint s), FDSolver s) => Constraint s -> FDInstance s ()
type SpecFn s = EGEdge -> SpecFnRes s
type SpecFnRes s = ([(Int, EGVarId, Bool, SpecBool s)], [(Int, EGVarId, Bool, SpecInt s)], [(Int, EGVarId, Bool, SpecCol s)])
data SpecResult t
SpecResNone :: SpecResult t
SpecResSpec :: t -> SpecResult t
SpecResUnify :: EGVarId -> SpecResult t
getBoolSpec_ :: FDSolver s => EGVarId -> FDBoolSpecTypeSet s -> FDInstance s (Maybe (FDBoolSpecType s, FDBoolSpec s))
getIntSpec_ :: FDSolver s => EGVarId -> FDIntSpecTypeSet s -> FDInstance s (Maybe (FDIntSpecType s, FDIntSpec s))
getColSpec_ :: FDSolver s => EGVarId -> FDColSpecTypeSet s -> FDInstance s (Maybe (FDColSpecType s, FDColSpec s))
getBoolSpec :: FDSolver s => EGVarId -> FDInstance s (Maybe (FDBoolSpec s))
getIntSpec :: FDSolver s => EGVarId -> FDInstance s (Maybe (FDIntSpec s))
getColSpec :: (Show (FDColSpec s), FDSolver s) => EGVarId -> FDInstance s (Maybe (FDColSpec s))
getEdge :: FDSolver s => EGEdgeId -> FDInstance s (Maybe EGEdge)
markEdge :: FDSolver s => EGEdgeId -> FDInstance s ()
setFailed :: FDSolver s => FDInstance s ()
getLevel :: FDSolver s => FDInstance s Int
getIntVal :: FDSolver s => EGVarId -> FDInstance s (Maybe EGPar)
getBoolVal :: FDSolver s => EGVarId -> FDInstance s (Maybe EGBoolPar)
getColVal :: FDSolver s => EGVarId -> FDInstance s (Maybe EGColPar)
getIntTerm :: FDSolver s => [ModelInt] -> FDInstance s [FDIntTerm s]
getBoolTerm :: FDSolver s => [ModelBool] -> FDInstance s [FDBoolTerm s]
getColTerm :: FDSolver s => [ModelCol] -> FDColSpecType s -> FDInstance s [FDColSpec s]
getSingleIntTerm :: FDSolver s => ModelInt -> FDInstance s (FDIntTerm s)
getDefBoolSpec :: FDSolver s => FDSpecInfoBool s -> FDBoolSpec s
getDefIntSpec :: FDSolver s => FDSpecInfoInt s -> FDIntSpec s
getDefColSpec :: FDSolver s => FDSpecInfoCol s -> FDColSpec s
getFullBoolSpec :: (MonadState (FDState s) m, FDSolver s) => EGVarId -> m (FDSpecInfoBool s)
getFullIntSpec :: (MonadState (FDState s) m, FDSolver s) => EGVarId -> m (FDSpecInfoInt s)
getFullColSpec :: (MonadState (FDState s) m, FDSolver s) => EGVarId -> m (FDSpecInfoCol s)
getColItems :: FDSolver s => ModelCol -> FDColSpecType s -> FDInstance s [FDIntTerm s]
fdSpecInfo_spec :: FDSolver s => ([Either (FDSpecInfoBool s) (FDBoolSpecType s, FDBoolSpec s)], [Either (FDSpecInfoInt s) (FDIntSpecType s, FDIntSpec s)], [Either (FDSpecInfoCol s) (FDColSpecType s, FDColSpec s)]) -> FDSpecInfo s
specInfoBoolTerm :: FDSolver s => FDBoolTerm s -> s (FDSpecInfoBool s)
specInfoIntTerm :: FDSolver s => FDIntTerm s -> s (FDSpecInfoInt s)
newInt :: FDSolver s => FDInstance s ModelInt
newBool :: FDSolver s => FDInstance s ModelBool
newCol :: FDSolver s => FDInstance s ModelCol
procSubModel :: FDSolver s => EGModel -> (Int -> FDSpecInfoBool s, Int -> FDSpecInfoInt s, Int -> FDSpecInfoCol s) -> FDInstance s ()
procSubModelEx :: FDSolver s => EGModel -> (Int -> Maybe (FDSpecInfoBool s), Int -> Maybe (FDSpecInfoInt s), Int -> Maybe (FDSpecInfoCol s)) -> FDInstance s ()
specSubModelEx :: FDSolver s => EGModel -> (Int -> Maybe (FDSpecInfoBool s), Int -> Maybe (FDSpecInfoInt s), Int -> Maybe (FDSpecInfoCol s)) -> FDInstance s (Map EGVarId (FDSpecInfoBool s), Map EGVarId (FDSpecInfoInt s), Map EGVarId (FDSpecInfoCol s))
runFD :: FDSolver s => FDInstance s a -> s a
setMinimizeVar :: (Show (FDIntTerm s), FDSolver s) => ModelInt -> FDInstance s ()
boundMinimize :: (Show (FDIntTerm s), FDSolver s, EnumTerm s (FDIntTerm s), Integral (TermBaseType s (FDIntTerm s))) => NewBound (FDInstance s)
getMinimizeTerm :: (Show (FDIntTerm s), FDSolver s) => FDInstance s (Maybe (FDIntTerm s))
getMinimizeVar :: (Show (FDIntTerm s), FDSolver s) => FDInstance s (Maybe ModelInt)
fdNewvar :: (FDSolver s, Term s t) => FDInstance s (Maybe t)
instance Eq TermType
instance Ord TermType
instance Bounded TermType
instance Enum TermType
instance Show TermType
instance Monad s => Monad (FDInstance s)
instance Monad s => MonadState (FDState s) (FDInstance s)
instance (FDSolver s, EnumTerm s (FDBoolTerm s)) => EnumTerm (FDInstance s) ModelBool
instance (FDSolver s, EnumTerm s (FDIntTerm s)) => EnumTerm (FDInstance s) ModelInt
instance FDSolver s => Term (FDInstance s) ModelCol
instance FDSolver s => Term (FDInstance s) ModelBool
instance FDSolver s => Term (FDInstance s) ModelInt
instance FDSolver s => Solver (FDInstance s)
instance Show (FDColSpec s) => Show (FDSpecInfoCol s)
instance Show (FDIntSpec s) => Show (FDSpecInfoInt s)
instance Show (FDBoolSpec s) => Show (FDSpecInfoBool s)
instance (Ord (FDColSpec s), Ord (FDColSpecType s)) => Ord (FDSpecInfoCol s)
instance (Ord (FDColSpec s), Ord (FDColSpecType s)) => Eq (FDSpecInfoCol s)
instance (Ord (FDIntSpec s), Ord (FDIntSpecType s)) => Ord (FDSpecInfoInt s)
instance (Ord (FDIntSpec s), Ord (FDIntSpecType s)) => Eq (FDSpecInfoInt s)
instance (Ord (FDBoolSpec s), Ord (FDBoolSpecType s)) => Ord (FDSpecInfoBool s)
instance (Ord (FDBoolSpec s), Ord (FDBoolSpecType s)) => Eq (FDSpecInfoBool s)
instance Show (TermTypeSpec s)

module Control.CP.FD.Interface

-- | A solver needs to be an instance of this FDSolver class in order to
--   create an FDInstance around it.
class (Solver s, Term s (FDIntTerm s), Term s (FDBoolTerm s), Eq (FDBoolSpecType s), Ord (FDBoolSpecType s), Enum (FDBoolSpecType s), Bounded (FDBoolSpecType s), Show (FDBoolSpecType s), Eq (FDIntSpecType s), Ord (FDIntSpecType s), Enum (FDIntSpecType s), Bounded (FDIntSpecType s), Show (FDIntSpecType s), Eq (FDColSpecType s), Ord (FDColSpecType s), Enum (FDColSpecType s), Bounded (FDColSpecType s), Show (FDColSpecType s), Show (FDIntSpec s), Show (FDColSpec s), Show (FDBoolSpec s)) => FDSolver s where fdTypeReqBool = return (\ (EGEdge {egeLinks = EGTypeData {boolData = l}}) -> map (\ x -> (x, fromList [minBound .. maxBound])) l) fdTypeReqInt = return (\ (EGEdge {egeLinks = EGTypeData {intData = l}}) -> map (\ x -> (x, fromList [minBound .. maxBound])) l) fdTypeReqCol = return (\ (EGEdge {egeLinks = EGTypeData {colData = l}}) -> map (\ x -> (x, fromList [minBound .. maxBound])) l) fdTypeVarInt = return $ singleton maxBound fdTypeVarBool = return $ singleton maxBound fdSpecify = mixinId

-- | definition of FDInstance, a Solver wrapper that adds power to post
--   boolean expressions as constraints
data FDSolver s => FDInstance s a

-- | integer operators/functions | --
(@+) :: (Eq t, Eq c, Eq b, ToExpr t c b p, ToExpr t c b q) => p -> q -> Expr t c b
(@-) :: (Eq t, Eq c, Eq b, ToExpr t c b p, ToExpr t c b q) => p -> q -> Expr t c b
(@*) :: (Eq t, Eq c, Eq b, ToExpr t c b p, ToExpr t c b q) => p -> q -> Expr t c b
(@/) :: (Eq t, Eq c, Eq b, ToExpr t c b p, ToExpr t c b q) => p -> q -> Expr t c b
(@%) :: (Eq t, Eq c, Eq b, ToExpr t c b p, ToExpr t c b q) => p -> q -> Expr t c b

-- | list operators/functions | --
(!) :: (Eq t, Eq c, Eq b) => ColExpr t c b -> Expr t c b -> Expr t c b
(@!!) :: (Eq t, Eq c, Eq b) => ColExpr t c b -> Integer -> Expr t c b
(@..) :: (Eq t, Eq c, Eq b) => Expr t c b -> Expr t c b -> ColExpr t c b
(@++) :: (Eq t, Eq c, Eq b) => ColExpr t c b -> ColExpr t c b -> ColExpr t c b
size :: (Eq t, Eq c, Eq b) => ColExpr t c b -> Expr t c b
xfold :: (Eq t, Eq c, Eq b) => (Expr t c b -> Expr t c b -> Expr t c b) -> Expr t c b -> ColExpr t c b -> Expr t c b
xsum :: (Num (Expr t c b), Eq t, Eq c, Eq b) => ColExpr t c b -> Expr t c b
xhead :: (Eq t, Eq c, Eq b, ToColExpr t c b p) => p -> Expr t c b
xtail :: (Eq t, Eq c, Eq b, ToColExpr t c b p) => p -> ColExpr t c b
list :: (Eq t, Eq c, Eq b) => [Expr t c b] -> ColExpr t c b
slice :: (Eq t, Eq c, Eq b) => ColExpr t c b -> ColExpr t c b -> ColExpr t c b
xmap :: (Eq t, Eq c, Eq b) => (Expr t c b -> Expr t c b) -> ColExpr t c b -> ColExpr t c b
cte :: Integral a => a -> ModelInt
(@||) :: (Constraint s ~ Either Model q, MonadTree m, TreeSolver m ~ s) => Tree DummySolver () -> Tree DummySolver () -> m ()
(@&&) :: (Constraint s ~ Either Model q, MonadTree m, TreeSolver m ~ s) => Tree DummySolver () -> Tree DummySolver () -> m ()
inv :: (Constraint s ~ Either Model q, MonadTree m, TreeSolver m ~ s) => Tree DummySolver () -> m ()
(@=) :: (ModelExprClass a, Constraint s ~ Either Model q, MonadTree m, TreeSolver m ~ s) => a -> a -> m ()
(@/=) :: (ModelExprClass a, Constraint s ~ Either Model q, MonadTree m, TreeSolver m ~ s) => a -> a -> m ()
(@<) :: (Constraint s ~ Either Model q, MonadTree m, TreeSolver m ~ s) => ModelInt -> ModelInt -> m ()
(@>) :: (Constraint s ~ Either Model q, MonadTree m, TreeSolver m ~ s) => ModelInt -> ModelInt -> m ()
(@<=) :: (Constraint s ~ Either Model q, MonadTree m, TreeSolver m ~ s) => ModelInt -> ModelInt -> m ()
(@>=) :: (Constraint s ~ Either Model q, MonadTree m, TreeSolver m ~ s) => ModelInt -> ModelInt -> m ()
(@:) :: (Constraint s ~ Either Model q, MonadTree m, TreeSolver m ~ s, ExprRange ModelIntArg ModelColArg ModelBoolArg r, Term s ModelInt, Term s ModelBool, Term s ModelCol) => ModelInt -> r -> m ()
(@?) :: Tree DummySolver () -> (Expr (ModelIntTerm ModelFunctions) (ModelColTerm ModelFunctions) (ModelBoolTerm ModelFunctions), Expr (ModelIntTerm ModelFunctions) (ModelColTerm ModelFunctions) (ModelBoolTerm ModelFunctions)) -> Expr (ModelIntTerm ModelFunctions) (ModelColTerm ModelFunctions) (ModelBoolTerm ModelFunctions)
(@??) :: (MonadTree m, ~ * (Constraint (TreeSolver m)) (Either Model q)) => Tree DummySolver () -> (Tree DummySolver (), Tree DummySolver ()) -> m ()
channel :: Tree DummySolver () -> ModelInt
val :: Tree DummySolver () -> ModelInt
sorted :: (Constraint s ~ Either Model q, MonadTree m, TreeSolver m ~ s) => ModelCol -> m ()
sSorted :: (Constraint s ~ Either Model q, MonadTree m, TreeSolver m ~ s) => ModelCol -> m ()
forall :: (Term s ModelInt, Term s ModelBool, Term s ModelCol, Constraint s ~ Either Model q, MonadTree m, TreeSolver m ~ s) => ModelCol -> (ModelInt -> Tree DummySolver ()) -> m ()
forany :: (Term s ModelInt, Term s ModelBool, Term s ModelCol, Constraint s ~ Either Model q, MonadTree m, TreeSolver m ~ s) => ModelCol -> (ModelInt -> Tree DummySolver ()) -> m ()
loopall :: (Term s ModelInt, Term s ModelBool, Term s ModelCol, Constraint s ~ Either Model q, MonadTree m, TreeSolver m ~ s) => (ModelInt, ModelInt) -> (ModelInt -> Tree DummySolver ()) -> m ()
allDiff :: (Constraint s ~ Either Model q, MonadTree m, TreeSolver m ~ s) => ModelCol -> m ()
allDiffD :: (Constraint s ~ Either Model q, MonadTree m, TreeSolver m ~ s) => ModelCol -> m ()
loopany :: (Term s ModelInt, Term s ModelBool, Term s ModelCol, Constraint s ~ Either Model q, MonadTree m, TreeSolver m ~ s) => (ModelInt, ModelInt) -> (ModelInt -> Tree DummySolver ()) -> m ()
allin :: (Constraint s ~ Either Model q, MonadTree m, TreeSolver m ~ s, ExprRange ModelIntArg ModelColArg ModelBoolArg r, Term s ModelInt, Term s ModelBool, Term s ModelCol) => ModelCol -> r -> m ()
asExpr :: ToModelInt t => t -> ModelInt
asCol :: ToModelCol t => t -> ModelCol
asBool :: (FDSolver s, MonadTree m, TreeSolver m ~ FDInstance s, ToModelBool t) => t -> m ()
colList :: (Constraint s ~ Either Model q, MonadTree m, TreeSolver m ~ s) => ModelCol -> Int -> m [ModelInt]
labelCol :: (FDSolver s, MonadTree m, TreeSolver m ~ FDInstance s, EnumTerm s (FDIntTerm s)) => ModelCol -> m [TermBaseType s (FDIntTerm s)]
type ModelInt = ModelIntExpr ModelFunctions
type ModelCol = ModelColExpr ModelFunctions
type ModelBool = ModelBoolExpr ModelFunctions
exists :: (MonadTree m, Term (TreeSolver m) t) => (t -> m a) -> m a
true :: MonadTree tree => tree ()
false :: MonadTree m => m a
instance ModelExprClass (Tree DummySolver ())
instance ModelExprClass ModelBool
instance ModelExprClass ModelCol
instance ModelExprClass ModelInt
instance Solver DummySolver
instance ModelTermType t => Term DummySolver t
instance Monad DummySolver

module Control.CP.FD.OvertonFD.OvertonFD
data OvertonFD a
fd_objective :: OvertonFD FDVar
fd_domain :: FDVar -> OvertonFD [Int]
data FDVar
data OConstraint
OHasValue :: FDVar -> Int -> OConstraint
OSame :: FDVar -> FDVar -> OConstraint
ODiff :: FDVar -> FDVar -> OConstraint
OLess :: FDVar -> FDVar -> OConstraint
OLessEq :: FDVar -> FDVar -> OConstraint
OAdd :: FDVar -> FDVar -> FDVar -> OConstraint
OSub :: FDVar -> FDVar -> FDVar -> OConstraint
OMult :: FDVar -> FDVar -> FDVar -> OConstraint
OAbs :: FDVar -> FDVar -> OConstraint
lookup :: FDVar -> OvertonFD Domain
instance Ord FDVar
instance Eq FDVar
instance Show FDVar
instance Show OConstraint
instance Eq OConstraint
instance Show FDState
instance Monad OvertonFD
instance MonadState FDState OvertonFD
instance Ord FDState
instance Eq FDState
instance Show VarInfo
instance EnumTerm OvertonFD FDVar
instance Term OvertonFD FDVar
instance Solver OvertonFD

module Control.CP.FD.SimpleFD
simple_fdSpecify :: (FDSolver s, FDColSpec s ~ [FDIntTerm s], FDIntSpec s ~ FDIntTerm s, FDBoolSpec s ~ FDBoolTerm s) => Mixin (SpecFn s)
simple_fdProcess :: (FDSolver s, FDColSpec s ~ [FDIntTerm s], FDIntSpec s ~ FDIntTerm s, FDBoolSpec s ~ FDBoolTerm s) => Mixin (EGConstraintSpec -> FDSpecInfo s -> FDInstance s ())

module Control.CP.FD.Solvers
dfs :: [a]
bfs :: Seq a
pfs :: Ord a => PriorityQueue a (a, b, c)
nb :: Int -> CNodeBoundedST s a
db :: Int -> CDepthBoundedST s a
bb :: NewBound s -> CBranchBoundST s a
sb :: Int -> CSolutionBoundST s a
fs :: CFirstSolutionST s a
it :: CIdentityCST s a
ra :: Int -> CRandomST s a
ld :: Int -> CLimitedDiscrepancyST s a

module Control.CP.FD.SearchSpec.Data
data OptimDirection
Maximize :: OptimDirection
Minimize :: OptimDirection
type VarExpr = Expr VarStat () ()
data VarStat
DLowerBound :: VarStat
DUpperBound :: VarStat
DDomSize :: VarStat
DLowerRegret :: VarStat
DUpperRegret :: VarStat
DDegree :: VarStat
DWDregree :: VarStat
DRandom :: VarStat
DMedian :: VarStat
DDummy :: Int -> VarStat
data Labelling v a b
LabelInt :: v -> VarExpr -> (ConstraintExpr -> ConstraintExpr -> ConstraintBoolExpr) -> Labelling v a b
LabelCol :: a -> VarExpr -> OptimDirection -> VarExpr -> (ConstraintExpr -> ConstraintExpr -> ConstraintBoolExpr) -> Labelling v a b
LabelBool :: b -> VarExpr -> Labelling v a b
data SearchSpec v a b
Labelling :: (Labelling v a b) -> SearchSpec v a b
CombineSeq :: (SearchSpec v a b) -> (SearchSpec v a b) -> SearchSpec v a b
CombinePar :: (SearchSpec v a b) -> (SearchSpec v a b) -> SearchSpec v a b
TryOnce :: (SearchSpec v a b) -> SearchSpec v a b
LimitSolCount :: Integer -> (SearchSpec v a b) -> SearchSpec v a b
LimitDepth :: Integer -> (SearchSpec v a b) -> SearchSpec v a b
LimitNodeCount :: Integer -> (SearchSpec v a b) -> SearchSpec v a b
LimitDiscrepancy :: Integer -> (SearchSpec v a b) -> SearchSpec v a b
BranchBound :: v -> OptimDirection -> (SearchSpec v a b) -> SearchSpec v a b
PrintSol :: [v] -> [a] -> [b] -> (SearchSpec v a b) -> SearchSpec v a b
type ConstraintExpr = Expr ConstraintRefs () ()
data ConstraintRefs
VarRef :: ConstraintRefs
ValRef :: ConstraintRefs
mmapSearch :: Monad m => SearchSpec v1 a1 b1 -> (v1 -> m v2) -> (a1 -> m a2) -> (b1 -> m b2) -> m (SearchSpec v2 a2 b2)
instance (Show v, Show a, Show b) => Show (SearchSpec v a b)
instance Eq VarStat
instance Ord VarStat
instance Show VarStat
instance Eq OptimDirection
instance Ord OptimDirection
instance Show OptimDirection
instance Eq ConstraintRefs
instance Ord ConstraintRefs
instance Show ConstraintRefs
instance (Show v, Show a, Show b) => Show (Labelling v a b)

module Control.CP.FD.OvertonFD.Sugar
instance FDSolver OvertonFD

module Control.CP.FD.Example
example_main :: ExampleModel [String] -> ExampleModel ModelInt -> ExampleModel ModelCol -> Bool -> IO ()
example_sat_main :: ExampleModel [String] -> ExampleModel ModelInt -> ExampleModel ModelCol -> IO ()
example_sat_main_void :: ExampleModel () -> IO ()
example_sat_main_single :: Read n => ExampleModel n -> IO ()
example_sat_main_single_expr :: ExampleModel ModelInt -> IO ()
example_sat_main_coll_expr :: ExampleModel ModelCol -> IO ()
example_min_main :: ExampleMinModel [String] -> ExampleMinModel ModelInt -> ExampleMinModel ModelCol -> IO ()
example_min_main_void :: ExampleMinModel () -> IO ()
example_min_main_single :: Read n => ExampleMinModel n -> IO ()
example_min_main_single_expr :: ExampleMinModel ModelInt -> IO ()
example_min_main_coll_expr :: ExampleMinModel ModelCol -> IO ()
runSolve :: (Integral (TermBaseType s (FDIntTerm s)), Show (FDIntTerm s), EnumTerm s (FDIntTerm s), FDSolver s) => Bool -> Tree (FDInstance s) a -> (Int, [a])
labeller :: (Show (FDIntTerm s), MonadTree m, EnumTerm s (FDIntTerm s), FDSolver s, ~ (* -> *) (TreeSolver m) (FDInstance s)) => ModelCol -> m [TermBaseType s (FDIntTerm s)]
postMinimize :: ExampleMinModel t -> ExampleModel t
type ExampleModel t = forall s m. (Show (FDIntTerm s), FDSolver s, MonadTree m, TreeSolver m ~ (FDInstance s)) => t -> m (ModelCol)
type ExampleMinModel t = forall s m. (Show (FDIntTerm s), FDSolver s, MonadTree m, TreeSolver m ~ (FDInstance s)) => t -> m (ModelInt, ModelCol)
