-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Line oriented editor
--   
--   Haskell line editor. Cloned from ed manual.
@package Hedi
@version 0.1.1

module Paths_Hedi
version :: Version
getBinDir :: IO FilePath
getLibDir :: IO FilePath
getDataDir :: IO FilePath
getLibexecDir :: IO FilePath
getDataFileName :: FilePath -> IO FilePath


-- | This code has been taken from <a>http://haskell.org</a> A Monad
--   transformer UndoT on a state supporting undo , redo and hput to push
--   the last state on history. Redo stack is blanked on hput
module Undo

-- | State stacks wrapping states in time
data History s
History :: s -> [s] -> [s] -> History s

-- | last state putted
current :: History s -> s

-- | the history of putted states (reversed) without the redos
undos :: History s -> [s]

-- | history of the undo
redos :: History s -> [s]

-- | a state monad transformer with the state history
type HStateT s m = StateT (History s) m

-- | facility to write signatures context
class (Monad m, MonadState (History s) (HStateT s m)) => HCtx m s

-- | a wrapper around HStateT to derive his classes and add an instance
newtype (Monad m) => UndoT s m a
UndoT :: (HStateT s m a) -> UndoT s m a

-- | tries to get back one step the state
undo :: (HCtx m s) => UndoT s m Bool

-- | tries to get back the undo operation
redo :: (HCtx m s) => UndoT s m Bool

-- | push the old state in the undo stack and set the new state
--   (alternative to put)
hput :: (HCtx m s) => s -> UndoT s m ()

-- | an History of one state
blank :: s -> History s

-- | run the UndoT monad transformer spitting out the computation result in
--   the inner monad
evalUndoT :: (Monad m) => UndoT s m a -> s -> m a

-- | run the UndoT monad transformer spitting out the final state in the
--   inner monad
execUndoT :: (Monad m) => UndoT s m a -> s -> m s
instance (Monad m) => Functor (UndoT s m)
instance (Monad m) => Monad (UndoT s m)
instance MonadTrans (UndoT s)
instance (MonadIO m) => MonadIO (UndoT s m)
instance (Show s) => Show (History s)
instance (Monad m) => MonadState s (UndoT s m)
instance (Monad m, MonadState (History s) (HStateT s m)) => HCtx m s


-- | Parse and pretty print the string of help of commands
module Helper

-- | structure for the help of a command
data CommandHelp
CommandHelp :: String -> String -> [String] -> [String] -> String -> CommandHelp

-- | the command name
name :: CommandHelp -> String

-- | how to run it
synopsis :: CommandHelp -> String

-- | aspects
descriptions :: CommandHelp -> [String]

-- | errors explanations
errors :: CommandHelp -> [String]

-- | implementation state
implementation :: CommandHelp -> String

-- | parses a CommandHelp
parseACommandHelp :: CharParser () CommandHelp

-- | parses all commands help
parseCommandsHelp :: CharParser () [CommandHelp]

-- | run the parser against a string
run :: String -> GenParser Char () a -> (a -> Maybe b) -> Either String (Maybe b)

-- | create a nice table from lines of words
tabulate :: [[String]] -> String

-- | parse a prettyprint of a list of command helps from a string
listOfCommands :: String -> Either String (Maybe String)

-- | parse a prettyprint of a list of command helps from a string
helpCommand :: String -> String -> Either String (Maybe String)
instance Show CommandHelp


-- | A zipped list with special cursor at the ends. In fact it handles
--   inserting at start and appending at end where the cursor is pointing
--   to non existing lines.
module Engine

-- | represent an action, which can fail with Nothing , an index error
type Change a = a -> Maybe a

-- | Pos represent the position addressed in the engine
data Pos

-- | the engine addresses a real line
Line :: Int -> Pos

-- | The index of the line starting from 1
nth :: Pos -> Int

-- | the engine addresses before first line , if ever present
Begin :: Pos

-- | the engine addresses after last line
End :: Int -> Pos

-- | The number of lines in the engine
lns :: Pos -> Int

-- | relative distance between two positions
data Engine

-- | the cursor when its pointing to a real line (eg line function doesn't
--   fail)
Inside :: [String] -> String -> [String] -> Engine

-- | lines before the cursor (reversed order)
left :: Engine -> [String]

-- | addressed line
cursor :: Engine -> String

-- | lines after the cursor
right :: Engine -> [String]

-- | the cursor is pointing either to insert at the front of the file or
--   append at the end of the file.
Corner :: Either [String] [String] -> Engine

-- | Left lines is in append mode, Right is in insert at front mode.
elems :: Engine -> Either [String] [String]

-- | An empty engine
empty :: Engine

-- | An engine is isomorphic to Engine list
listIn :: [String] -> Engine

-- | Extract the list from the engine
listOut :: Engine -> Maybe [String]

-- | Extract n lines from the position addressed
linen :: Int -> Engine -> Maybe [String]

-- | Extract the addressed line
line :: Engine -> Maybe String

-- | Possibly set the addressed line to the nth line
jump :: Int -> Change Engine

-- | Insert some lines before the addressed line
ins :: [String] -> Change Engine

-- | Insert some lines after the addressed line
add :: [String] -> Change Engine

-- | Delete the addressed line , address the next one
del :: Change Engine

-- | Delete n lines from the addressed position
deln :: Int -> Change Engine

-- | Address an append position
end :: Change Engine

-- | Address before the first line
start :: Change Engine

-- | The number of the addressed line
pos :: Engine -> Pos

-- | Address the next line
next :: Change Engine

-- | Address the prev line
prev :: Change Engine

-- | Jump back n lines
prevn :: Int -> Change Engine

-- | Jump ahead n lines
nextn :: Int -> Change Engine

-- | Jump n lines relative to the addredded line
rjump :: Int -> Change Engine

-- | Create all the engines from the addressed one to the last one
tillend :: Engine -> [Engine]

-- | all the next engines from the addressed next to itself , wrapping
--   around
fwdcycle :: Engine -> [Engine]

-- | Create all the engines from the start to the addressed one included
fromstart :: Engine -> [Engine]

-- | all the prev engines from the addressed prev to itself , wrapping
--   around
bwdcycle :: Engine -> [Engine]

-- | last element if present
last :: Change Engine

-- | first element if present
first :: Change Engine
isInside :: Engine -> Bool
runner :: Change Engine -> Engine -> [Engine]
instance Show Engine
instance Eq Engine
instance Show Pos


-- | Main datas and types for the editor
module Editor

-- | Stato is parametrized on an Engine instance and hold the engine with
--   the last regex entered , regex G and g are not implemented now
data Stato
Stato :: Engine -> String -> Maybe String -> Maybe Command -> Maybe Engine -> Stato

-- | data holding the file
file :: Stato -> Engine

-- | a regex
lastre :: Stato -> String

-- | the file we are editing
filename :: Stato -> Maybe String

-- | a sensible state for data lost
pending :: Stato -> Maybe Command
lastsaved :: Stato -> Maybe Engine

-- | the core editor runs under the state monad with state (Stato) .
--   Wrapped around a monad (IO mainly) to permit console input and output
--   of commands with IO and testing with State
type StatoE m = UndoT Stato m
liftStatoE :: (Ctx m) => StatoE m a -> Editor m a

-- | push a new file (data <a>Engine</a> instance) in the core State,
--   pushing the old state in the undo stack
hputfile :: (Ctx m) => Engine -> Editor m ()

-- | placeholder for the two constraints
class (SIO m, HCtx m (Stato)) => Ctx m

-- | the errors (monad failers) which can break the monad flow
data Err

-- | issued on ctrl-d or q command (q not implemented)
StopErr :: Err

-- | command line was not parsed to a CompleteCommand
ParserErr :: String -> Err

-- | the regex doesn't match a line
RegexUnmatched :: Err

-- | something bad happened in the evaluation process
EvalErr :: Err -> Err

-- | lines were addressed out of file (see <a>Engine</a>)
BackendErr :: Err

-- | uncontrolled errors
Ahi :: String -> Err

-- | io error trying to load a file
FileReadErr :: String -> Err

-- | filename is not set
FileNameMissing :: Err

-- | io error trying to write the file
FileWriteErr :: String -> Err

-- | io error executing an external program
ExternalCommandErr :: String -> Err

-- | a sensible data discarding command has been entered
PendingState :: Command -> Err

-- | reached the first state remembered
NoMoreUndo :: Err

-- | reached the last state remembered
NoMoreRedo :: Err

-- | a help for a missing command was asked
CommandHelpMissing :: Err

-- | error parsing the help for commands
CommandHelpParseErr :: String -> Err

-- | a layer for IO simulation, see <a>Main</a> for the real program one
--   and <a>Test</a> for tests
class (Monad m) => SIO m
inputSio :: (SIO m) => String -> m (Maybe String)
outputSio :: (SIO m) => String -> m ()
historySio :: (SIO m) => String -> m ()
errorSIO :: (SIO m) => String -> m ()
readfileSio :: (SIO m) => String -> ErrorT String m String
writefileSio :: (SIO m) => String -> String -> ErrorT String m ()
externalSio :: (SIO m) => String -> ErrorT String m String
commandhelpSIO :: (SIO m) => m FilePath
liftSio :: (Ctx m) => m a -> Editor m a

-- | commands for the editor
data Command

-- | get some text and add it after the addressed line
Append :: Command

-- | get some text and add it before the addressed line
Insert :: Command

-- | get some text and add it in place of some deleted lines
Change :: Command

-- | delete some lines
Delete :: Command

-- | print some lines
Print :: Command

-- | get some commands and execute them on each line matching a regex
SmallG :: String -> Command

-- | interactively execute commands on each line matching a regex
BigG :: String -> Command

-- | Change the addressed line
NoCommand :: Command

-- | Load a file
Edit :: String -> Command

-- | Write the file
Write :: Command

-- | Write a new file
WriteNew :: String -> Command

-- | Set filename
SetFilename :: String -> Command

-- | Print filename
GetFilename :: Command

-- | Load the output of an external command
EditExternal :: String -> Command

-- | Revert the last change if ever
UndoChange :: Command

-- | Restore via the last change
RedoChange :: Command

-- | Asking help
HelpList :: Command

-- | Spedific help
HelpTopic :: String -> Command

-- | represents a line position in the file
data Offset

-- | beyond last line, the append line
LastLine :: Offset

-- | the nth line
Absolute :: Int -> Offset

-- | the line addressed by the engine
Current :: Offset

-- | the nth line before the addressed one
Prev :: Int -> Offset

-- | the nth line aftor the addressed one
Next :: Int -> Offset

-- | the next line (wrapping around) matching a regex
ReNext :: String -> Offset

-- | the next line matching the last learned regex
LastReNext :: Offset

-- | the previous line (wrapping around) matching a regex
RePrev :: String -> Offset

-- | the previous matching the last learned regex
LastRePrev :: Offset

-- | the line marked previously with a char
MarkedAs :: Char -> Offset

-- | a couple of Offsets
data Range
Range :: Offset -> Offset -> Range

-- | wrapper a round the two possible addressing for a command Offset and
--   Range
data OffsetOrRange
ORO :: Offset -> OffsetOrRange
ORR :: Range -> OffsetOrRange
ORN :: OffsetOrRange

-- | a complete command is a Command coupled with a Range or an Offset
data CompleteCommand
CC :: Command -> OffsetOrRange -> CompleteCommand

-- | main datatype for the program-- beyond the core state, a simulation
--   layer <a>SIO</a> can be read and errors <a>Err</a> can be thrown to
--   kill the monad flow
type Editor m = ErrorT Err (StatoE m)

-- | wrap a maybe action and throw a backend error on a Nothing
backend :: (Ctx m) => Maybe a -> Editor m a

-- | execute an action on the file
through :: (Ctx m) => (Engine -> Maybe a) -> Editor m a

-- | the inputSio action lifted to Editor
pinput :: (Ctx m) => String -> Editor m (Maybe String)

-- | the inputSio action lifted to Editor with empty prompt
input :: (Ctx m) => Editor m (Maybe String)

-- | the outputSio action lifted to Editor
output :: (Ctx m) => String -> Editor m ()

-- | the historySIO action lifted to Editor
history :: (Ctx m) => String -> Editor m ()

-- | the errorSIO action lifted to Editor
errorlog :: (Ctx m) => String -> Editor m ()

-- | editor runner . resolve the all monad from a core state to another
run :: (Ctx m) => Editor m a -> Stato -> m (Stato)
instance Show CompleteCommand
instance Show OffsetOrRange
instance Show Range
instance Show Offset
instance Show Command
instance Eq Command
instance Show Err
instance Show Stato
instance Eq Stato
instance Error Err
instance (SIO m, HCtx m Stato) => Ctx m


-- | Operations involving Offset and Range through an Engine
module Offset

-- | move the cursor in the engine
jumpE :: (Ctx m) => Offset -> Editor m Engine

-- | From a range to the tuple (nelements,starting range element)
rangeResolve :: (Ctx m) => Range -> Editor m (Int, Engine)

-- | a complete backend + Editor action on an Offset
doOffset :: (Ctx m) => Offset -> (a -> Editor m b) -> (Engine -> Maybe a) -> Editor m b

-- | a backend action ending in a save state for the file
editOffset :: (Ctx m) => Offset -> (Engine -> Maybe Engine) -> Editor m ()

-- | a complete backend + Editor action on a Range
doRange :: (Ctx m) => Range -> (a -> Editor m b) -> (Int -> Engine -> Maybe a) -> Editor m b
editRange :: (Ctx m) => Range -> (Int -> Engine -> Maybe Engine) -> Editor m ()

module Parser

-- | shortcut for a parser of chars with no state
type ParseE = GenParser Char ()

-- | parse an integer number
numero :: ParseE Integer

-- | parse an Offset
parseOffset :: ParseE Offset

-- | parse a Range
parseRange :: ParseE Range

-- | defaults Offset or Range for the commands
defaultOR :: Command -> OffsetOrRange

-- | forces a failure for a command if a Range was parsed
acceptOffsetOnly :: Command -> OffsetOrRange -> ParseE ()

-- | parse an OffsetOrRange
parseOffsetOrRange :: ParseE OffsetOrRange

-- | helper for skipping a filter
rconst :: Command -> ParseE (OffsetOrRange -> ParseE Command)

-- | parse a function from OffsetOrRange to a parse Command
parseCommand :: ParseE (OffsetOrRange -> ParseE Command)

-- | parse a CompleteCommand made of an OffsetOrRange and a Command
parser :: ParseE CompleteCommand

-- | the parser from a String to either a String representing an error or a
--   CompleteCommand
parse :: String -> Either String CompleteCommand


-- | Functions for read-eval-do managing
module Operation

-- | a real check for file modification
modified :: (Ctx m) => Editor m Bool
resetpending :: (Ctx m) => Editor m ()

-- | a wrapper for commands evaluation which can discard changes
evalSensible :: (Ctx m) => Command -> Editor m () -> Editor m ()

-- | a wrapper for commands evaluation which cannot discard changes
checkPendings :: (Ctx m) => Editor m () -> Editor m ()

-- | a step in main mode for the editor
commandMode :: (Ctx m) => (String -> Either String CompleteCommand) -> (CompleteCommand -> Editor m ()) -> Editor m ()

-- | looping in main mode with error log on output
commandLoop :: (Ctx m) => (String -> Either String CompleteCommand) -> (CompleteCommand -> Editor m ()) -> Editor m ()

-- | the secondary mode for the editor where lines are inserted as input.
--   It returns the lines.Use CTRL-D to exit
inputMode :: (Ctx m) => Editor m [String]


-- | The logic of each of the available commands
module Eval

-- | every command is run with eval. See <a>Command</a> datatype for docs
eval :: (Ctx m) => CompleteCommand -> Editor m ()

-- | throw a writerSio error to Editor
writefail :: (Ctx m) => Either String () -> Editor m ()

-- | dump the engine content to a file via writefileSio
write :: (Ctx m) => String -> Editor m ()

-- | get the filename defaulting to some other action to produce one
getname :: (Ctx m) => Editor m String -> Editor m String

module Main
handleWith :: (IOError -> k) -> IO a -> ErrorT k IO a
strictReadFile :: String -> IO String

-- | launches an external program , catching output and errors, return on
--   exit
externalCommand :: String -> ErrorT String IO String

-- | the greetings
greetings :: IO ()
main :: IO ()
instance SIO IO


-- | some framework to test Editor m w functions, intercepting the console
--   part of the IO
module Test
type Line = String
data Emulator
Emulator :: [Line] -> [Line] -> [Line] -> [Line] -> Emulator
cinput :: Emulator -> [Line]
coutput :: Emulator -> [Line]
cerror :: Emulator -> [Line]
chistory :: Emulator -> [Line]
type CState = State Emulator
outputT :: String -> CState ()
errorT :: String -> CState ()
inputT :: String -> CState (Maybe String)
instance Show Emulator
instance SIO CState
