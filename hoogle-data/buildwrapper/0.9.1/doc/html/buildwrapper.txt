-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A library and an executable that provide an easy API for a Haskell IDE
--   
--   Buildwrapper is an alternative to scion. It provides services to
--   configure, build and give information on source files to help IDEs
--   manage Haskell projects. You can use buildwrapper to build project and
--   retrieve errors, get outline for each module source, get the type of
--   something inside a source file, get lexer tokens, etc. Buildwrapper is
--   used in the EclipseFP project (Eclipse plugins for Haskell
--   development)
@package buildwrapper
@version 0.9.1


-- | Data types, State Monad, utility functions
module Language.Haskell.BuildWrapper.Base

-- | State type
type BuildWrapper = StateT BuildWrapperState IO

-- | the state we keep
data BuildWrapperState
BuildWrapperState :: String -> FilePath -> FilePath -> Verbosity -> String -> [String] -> Bool -> BuildWrapperState

-- | name of temporary folder
tempFolder :: BuildWrapperState -> String

-- | path to the cabal executable
cabalPath :: BuildWrapperState -> FilePath

-- | path of the project cabal file
cabalFile :: BuildWrapperState -> FilePath

-- | verbosity of logging
verbosity :: BuildWrapperState -> Verbosity

-- | flags to pass cabal
cabalFlags :: BuildWrapperState -> String

-- | extra arguments to cabal configure
cabalOpts :: BuildWrapperState -> [String]

-- | log call to cabal
logCabalArgs :: BuildWrapperState -> Bool

-- | status of notes: error or warning
data BWNoteStatus
BWError :: BWNoteStatus
BWWarning :: BWNoteStatus

-- | read an object from a String, with a given error message if it fails
readObj :: Read a => String -> String -> a

-- | location of a note/error (lines and columns start at 1)
data BWLocation
BWLocation :: FilePath -> Int -> Int -> Int -> Int -> BWLocation

-- | source file
bwlSrc :: BWLocation -> FilePath

-- | line
bwlLine :: BWLocation -> Int

-- | column
bwlCol :: BWLocation -> Int

-- | end line
bwlEndLine :: BWLocation -> Int

-- | end line
bwlEndCol :: BWLocation -> Int

-- | build an empty span in a given file at a given location
mkEmptySpan :: FilePath -> Int -> Int -> BWLocation

-- | a note on a source file
data BWNote
BWNote :: BWNoteStatus -> String -> BWLocation -> BWNote

-- | status of the note
bwnStatus :: BWNote -> BWNoteStatus

-- | message
bwnTitle :: BWNote -> String

-- | where the note is
bwnLocation :: BWNote -> BWLocation

-- | is a note an error?
isBWNoteError :: BWNote -> Bool

-- | simple type encapsulating the fact the operations return along with
--   notes generated on files
type OpResult a = (a, [BWNote])

-- | result: success + files impacted
data BuildResult
BuildResult :: Bool -> [FilePath] -> BuildResult

-- | result for building one file: success + names data
--   Build1Result=Build1Result Bool [NameDef] deriving (Show,Read,Eq)
--   
--   instance ToJSON Build1Result where toJSON (Build1Result b ns)= object
--   ["r" .= b, "ns" .= map toJSON ns]
--   
--   instance FromJSON Build1Result where parseJSON (Object v)
--   =Build1Result <a>$</a> v .: "r" <a>*</a> v .: "ns" parseJSON _= mzero
--   
--   which cabal file to use operations
data WhichCabal

-- | use proper file
Source :: WhichCabal

-- | use temporary file that was saved in temp folder
Target :: WhichCabal

-- | type of elements for the outline
data OutlineDefType
Class :: OutlineDefType
Data :: OutlineDefType
Family :: OutlineDefType
Function :: OutlineDefType
Pattern :: OutlineDefType
Syn :: OutlineDefType
Type :: OutlineDefType
Instance :: OutlineDefType
Field :: OutlineDefType
Constructor :: OutlineDefType
Splice :: OutlineDefType

-- | Location inside a file, the file is known and doesn't need to be
--   repeated
data InFileLoc
InFileLoc :: Int -> Int -> InFileLoc

-- | line
iflLine :: InFileLoc -> Int

-- | column
iflColumn :: InFileLoc -> Int

-- | Span inside a file, the file is known and doesn't need to be repeated
data InFileSpan
InFileSpan :: InFileLoc -> InFileLoc -> InFileSpan

-- | start location
ifsStart :: InFileSpan -> InFileLoc

-- | end location
ifsEnd :: InFileSpan -> InFileLoc

-- | do spans overlap?
ifsOverlap :: InFileSpan -> InFileSpan -> Bool

-- | does span overlap location?
iflOverlap :: InFileSpan -> InFileLoc -> Bool

-- | construct a file span
mkFileSpan :: Int -> Int -> Int -> Int -> InFileSpan

-- | definition of a name
data NameDef
NameDef :: Text -> [OutlineDefType] -> Maybe Text -> NameDef

-- | name
ndName :: NameDef -> Text

-- | types: can have several to combine
ndType :: NameDef -> [OutlineDefType]

-- | type signature if any
ndSignature :: NameDef -> Maybe Text

-- | element of the outline result
data OutlineDef
OutlineDef :: Text -> [OutlineDefType] -> InFileSpan -> [OutlineDef] -> Maybe Text -> Maybe Text -> Maybe Int -> OutlineDef

-- | name
odName :: OutlineDef -> Text

-- | types: can have several to combine
odType :: OutlineDef -> [OutlineDefType]

-- | span in source
odLoc :: OutlineDef -> InFileSpan

-- | children (constructors...)
odChildren :: OutlineDef -> [OutlineDef]

-- | type signature if any
odSignature :: OutlineDef -> Maybe Text

-- | comment if any,
odComment :: OutlineDef -> Maybe Text

-- | comment start line if any,
odStartLineComment :: OutlineDef -> Maybe Int

-- | constructs an OutlineDef with no children and no type signature
mkOutlineDef :: Text -> [OutlineDefType] -> InFileSpan -> OutlineDef

-- | constructs an OutlineDef with children and no type signature
mkOutlineDefWithChildren :: Text -> [OutlineDefType] -> InFileSpan -> [OutlineDef] -> OutlineDef

-- | Lexer token
data TokenDef
TokenDef :: Text -> InFileSpan -> TokenDef

-- | type of token
tdName :: TokenDef -> Text

-- | location
tdLoc :: TokenDef -> InFileSpan

-- | Type of import/export directive
data ImportExportType

-- | Var
IEVar :: ImportExportType

-- | Abs
IEAbs :: ImportExportType

-- | import/export everything
IEThingAll :: ImportExportType

-- | specific import/export list
IEThingWith :: ImportExportType

-- | reexport module
IEModule :: ImportExportType

-- | definition of export
data ExportDef
ExportDef :: Text -> ImportExportType -> InFileSpan -> [Text] -> ExportDef

-- | name
eName :: ExportDef -> Text

-- | type
eType :: ExportDef -> ImportExportType

-- | location in source file
eLoc :: ExportDef -> InFileSpan

-- | children (constructor names, etc.)
eChildren :: ExportDef -> [Text]

-- | definition of an import element
data ImportSpecDef
ImportSpecDef :: Text -> ImportExportType -> InFileSpan -> [Text] -> ImportSpecDef

-- | name
isName :: ImportSpecDef -> Text

-- | type
isType :: ImportSpecDef -> ImportExportType

-- | location in source file
isLoc :: ImportSpecDef -> InFileSpan

-- | children (constructor names, etc.)
isChildren :: ImportSpecDef -> [Text]

-- | definition of an import statement
data ImportDef
ImportDef :: Text -> Maybe Text -> InFileSpan -> Bool -> Bool -> Text -> Maybe [ImportSpecDef] -> ImportDef

-- | module name
iModule :: ImportDef -> Text

-- | package name
iPackage :: ImportDef -> Maybe Text

-- | location in source file
iLoc :: ImportDef -> InFileSpan

-- | is the import qualified
iQualified :: ImportDef -> Bool

-- | is the import element list for hiding or exposing
iHiding :: ImportDef -> Bool

-- | alias name
iAlias :: ImportDef -> Text

-- | specific import elements
iChildren :: ImportDef -> Maybe [ImportSpecDef]

-- | complete result for outline
data OutlineResult
OutlineResult :: [OutlineDef] -> [ExportDef] -> [ImportDef] -> OutlineResult

-- | outline contents
orOutline :: OutlineResult -> [OutlineDef]

-- | exports
orExports :: OutlineResult -> [ExportDef]

-- | imports
orImports :: OutlineResult -> [ImportDef]

-- | build flags for a specific file
data BuildFlags
BuildFlags :: [String] -> [String] -> Maybe String -> Maybe String -> BuildFlags

-- | flags for GHC
bfAst :: BuildFlags -> [String]

-- | flags for preprocessor
bfPreproc :: BuildFlags -> [String]

-- | module name if known
bfModName :: BuildFlags -> Maybe String

-- | component used to get flags, if known
bfComponent :: BuildFlags -> Maybe String

-- | information about the thing at a given point in the source
data ThingAtPoint
ThingAtPoint :: String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> Maybe String -> ThingAtPoint
tapName :: ThingAtPoint -> String
tapModule :: ThingAtPoint -> Maybe String
tapType :: ThingAtPoint -> Maybe String
tapQType :: ThingAtPoint -> Maybe String
tapHType :: ThingAtPoint -> Maybe String
tapGType :: ThingAtPoint -> Maybe String

-- | get the full path for the temporary directory
getFullTempDir :: BuildWrapper FilePath

-- | get the full path for the temporary dist directory (where cabal will
--   write its output)
getDistDir :: BuildWrapper FilePath

-- | get full path in temporary folder for source file (i.e. where we're
--   going to write the temporary contents of an edited file)
getTargetPath :: FilePath -> BuildWrapper FilePath

-- | get full path in temporary folder for source file (i.e. where we're
--   going to write the temporary contents of an edited file)
getTargetPath' :: FilePath -> FilePath -> IO FilePath

-- | get the full, canonicalized path of a source
canonicalizeFullPath :: FilePath -> BuildWrapper FilePath

-- | get the full path of a source
getFullSrc :: FilePath -> BuildWrapper FilePath

-- | copy a file from the normal folders to the temp folder
copyFromMain :: Bool -> FilePath -> BuildWrapper (Maybe FilePath)

-- | is the source file more recent than the target file?
isSourceMoreRecent :: FilePath -> FilePath -> IO Bool

-- | replace relative file path by module name
fileToModule :: FilePath -> String

-- | Verbosity settings
data Verbosity
Silent :: Verbosity
Normal :: Verbosity
Verbose :: Verbosity
Deafening :: Verbosity

-- | component in cabal file
data CabalComponent

-- | library
CCLibrary :: Bool -> CabalComponent

-- | is the library buildable
ccBuildable :: CabalComponent -> Bool

-- | executable
CCExecutable :: String -> Bool -> CabalComponent

-- | executable name
ccExeName :: CabalComponent -> String

-- | is the library buildable
ccBuildable :: CabalComponent -> Bool

-- | test suite
CCTestSuite :: String -> Bool -> CabalComponent

-- | test suite name
ccTestName :: CabalComponent -> String

-- | is the library buildable
ccBuildable :: CabalComponent -> Bool

-- | test suite
CCBenchmark :: String -> Bool -> CabalComponent

-- | benchmark name
ccBenchName :: CabalComponent -> String

-- | is the library buildable
ccBuildable :: CabalComponent -> Bool

-- | get the cabal component name
cabalComponentName :: CabalComponent -> String

-- | a cabal package
data CabalPackage
CabalPackage :: String -> String -> Bool -> [CabalComponent] -> [String] -> CabalPackage

-- | name of package
cpName :: CabalPackage -> String

-- | version
cpVersion :: CabalPackage -> String

-- | is the package exposed or hidden
cpExposed :: CabalPackage -> Bool

-- | components in the cabal file that use this package
cpDependent :: CabalPackage -> [CabalComponent]

-- | all modules. We keep all modules so that we can try to open non
--   exposed but imported modules directly
cpModules :: CabalPackage -> [String]

-- | import clean operation: the span of text to change, the new text
data ImportClean
ImportClean :: InFileSpan -> Text -> ImportClean
icSpan :: ImportClean -> InFileSpan
icText :: ImportClean -> Text

-- | information about files to load (single file or multiple files)
data LoadContents
SingleFile :: FilePath -> String -> LoadContents
lmFile :: LoadContents -> FilePath
lmModule :: LoadContents -> String
MultipleFile :: [(FilePath, String)] -> LoadContents
lmFiles :: LoadContents -> [(FilePath, String)]

-- | get files to load
getLoadFiles :: LoadContents -> [(FilePath, String)]

-- | 
--   <a>http://book.realworldhaskell.org/read/io-case-study-a-library-for-searching-the-filesystem.html</a>
getRecursiveContents :: FilePath -> IO [FilePath]

-- | 
--   <a>http://book.realworldhaskell.org/read/io-case-study-a-library-for-searching-the-filesystem.html</a>
getRecursiveContentsHidden :: FilePath -> IO [FilePath]

-- | delete files in temp folder but not in real folder anymore
deleteGhosts :: [FilePath] -> BuildWrapper [FilePath]

-- | delete all temporary files
deleteTemp :: BuildWrapper ()

-- | delete generated files
deleteGenerated :: BuildWrapper ()

-- | debug method: fromJust with a message to display when we get Nothing
fromJustDebug :: String -> Maybe a -> a

-- | remove a base directory from a string representing a full path
removeBaseDir :: FilePath -> String -> String

-- | nub for Ord objects: use a set
nubOrd :: Ord a => [a] -> [a]

-- | debug method to vaguely format JSON result to dump them
formatJSON :: String -> String

-- | Usage structure
data Usage
Usage :: Maybe Text -> Text -> Text -> Text -> Bool -> Value -> Bool -> Usage
usPackage :: Usage -> Maybe Text
usModule :: Usage -> Text
usName :: Usage -> Text
usSection :: Usage -> Text
usType :: Usage -> Bool
usLoc :: Usage -> Value
usDef :: Usage -> Bool

-- | read a string from a file, forcing the read and closing the handle
readFile :: FilePath -> IO String

-- | write string to file
writeFile :: FilePath -> String -> IO ()

-- | perform operation on a binary opened file
withBinaryFile :: FilePath -> IOMode -> (Handle -> IO a) -> IO a

-- | Evaluation of result using String since we get them from GHC API this
--   can be fully evaluated via deepseq to make sure any side effect are
--   evaluated
data EvalResult
EvalResult :: Maybe String -> Maybe String -> Maybe String -> EvalResult
erType :: EvalResult -> Maybe String
erResult :: EvalResult -> Maybe String
erError :: EvalResult -> Maybe String

-- | splits a string at the first occurence of prefix
splitString :: Eq a => [a] -> [a] -> ([a], [a])

-- | run a program, writing the output/error to standard output as we go
runAndPrint :: FilePath -> [String] -> IO (ExitCode, String, String)
instance Typeable WhichCabal
instance Typeable BuildFlags
instance Typeable ThingAtPoint
instance Typeable Verbosity
instance Show BWNoteStatus
instance Read BWNoteStatus
instance Eq BWNoteStatus
instance Show BWLocation
instance Read BWLocation
instance Eq BWLocation
instance Show BWNote
instance Read BWNote
instance Eq BWNote
instance Show BuildResult
instance Read BuildResult
instance Eq BuildResult
instance Show WhichCabal
instance Read WhichCabal
instance Eq WhichCabal
instance Enum WhichCabal
instance Data WhichCabal
instance Show OutlineDefType
instance Read OutlineDefType
instance Eq OutlineDefType
instance Ord OutlineDefType
instance Enum OutlineDefType
instance Show InFileLoc
instance Read InFileLoc
instance Eq InFileLoc
instance Ord InFileLoc
instance Show InFileSpan
instance Read InFileSpan
instance Eq InFileSpan
instance Ord InFileSpan
instance Show NameDef
instance Read NameDef
instance Eq NameDef
instance Ord NameDef
instance Show OutlineDef
instance Read OutlineDef
instance Eq OutlineDef
instance Ord OutlineDef
instance Show TokenDef
instance Eq TokenDef
instance Show ImportExportType
instance Read ImportExportType
instance Eq ImportExportType
instance Ord ImportExportType
instance Enum ImportExportType
instance Show ExportDef
instance Eq ExportDef
instance Show ImportSpecDef
instance Eq ImportSpecDef
instance Show ImportDef
instance Eq ImportDef
instance Show OutlineResult
instance Eq OutlineResult
instance Show BuildFlags
instance Read BuildFlags
instance Eq BuildFlags
instance Data BuildFlags
instance Show ThingAtPoint
instance Read ThingAtPoint
instance Eq ThingAtPoint
instance Data ThingAtPoint
instance Show Verbosity
instance Read Verbosity
instance Eq Verbosity
instance Ord Verbosity
instance Enum Verbosity
instance Bounded Verbosity
instance Data Verbosity
instance Eq CabalComponent
instance Show CabalComponent
instance Read CabalComponent
instance Ord CabalComponent
instance Eq CabalPackage
instance Show CabalPackage
instance Show ImportClean
instance Read ImportClean
instance Eq ImportClean
instance Ord ImportClean
instance Show LoadContents
instance Read LoadContents
instance Show Usage
instance Eq Usage
instance Show EvalResult
instance Read EvalResult
instance Eq EvalResult
instance Ord EvalResult
instance FromJSON EvalResult
instance ToJSON EvalResult
instance NFData EvalResult
instance FromJSON ImportClean
instance ToJSON ImportClean
instance FromJSON CabalPackage
instance ToJSON CabalPackage
instance FromJSON CabalComponent
instance ToJSON CabalComponent
instance FromJSON ThingAtPoint
instance ToJSON ThingAtPoint
instance FromJSON BuildFlags
instance ToJSON BuildFlags
instance FromJSON OutlineResult
instance ToJSON OutlineResult
instance FromJSON ImportDef
instance ToJSON ImportDef
instance FromJSON ImportSpecDef
instance ToJSON ImportSpecDef
instance FromJSON ExportDef
instance ToJSON ExportDef
instance FromJSON ImportExportType
instance ToJSON ImportExportType
instance FromJSON TokenDef
instance ToJSON TokenDef
instance FromJSON OutlineDef
instance ToJSON OutlineDef
instance FromJSON NameDef
instance ToJSON NameDef
instance FromJSON InFileSpan
instance ToJSON InFileSpan
instance FromJSON OutlineDefType
instance ToJSON OutlineDefType
instance FromJSON BuildResult
instance ToJSON BuildResult
instance FromJSON BWNote
instance ToJSON BWNote
instance NFData BWNote
instance FromJSON BWLocation
instance ToJSON BWLocation
instance NFData BWLocation
instance FromJSON BWNoteStatus
instance ToJSON BWNoteStatus


-- | Cabal operations: configure, build, retrieve information from build
--   info, parse errors and warnings
module Language.Haskell.BuildWrapper.Cabal

-- | get the version of the cabal library
getCabalLibraryVersion :: String

-- | get all files to copy to temp folder
getFilesToCopy :: BuildWrapper (OpResult [FilePath])

-- | get cabal verbose level
cabalV :: BuildWrapper Verbosity

-- | run cabal build
cabalBuild :: Bool -> WhichCabal -> BuildWrapper (OpResult BuildResult)

-- | run cabal build
cabalBuild' :: Bool -> Bool -> WhichCabal -> BuildWrapper (OpResult BuildResult)

-- | the file where we save the targets
targetFile :: String

-- | run cabal configure
cabalConfigure :: WhichCabal -> BuildWrapper (OpResult (Maybe [Target]))

-- | get the full path to the cabal file
getCabalFile :: WhichCabal -> BuildWrapper FilePath

-- | get package name from cabal file
getPackageName :: BuildWrapper String

-- | get Cabal build info, running configure if needed
cabalInit :: WhichCabal -> BuildWrapper (OpResult (Maybe [Target]))

-- | run a action with the cabal build info
withCabal :: WhichCabal -> ([Target] -> BuildWrapper a) -> BuildWrapper (OpResult (Maybe a))

-- | parse cabal error messages and transform them in notre
parseCabalMessages :: FilePath -> FilePath -> String -> [BWNote]

-- | get the setup exe file name
setupExe :: FilePath -> FilePath

-- | get cabal executable from cabal-dev
fromCabalDevExe :: FilePath -> FilePath

-- | drop all potential prefixes from the given string
dropPrefixes :: [String] -> String -> Maybe String

-- | stop prefix if the given string starts by it
stripPrefixIfNeeded :: String -> String -> Maybe String -> Maybe String

-- | add a note with a potential additional message
addCurrent :: Maybe (BWNote, [String]) -> [BWNote] -> [BWNote]

-- | parse a Cabal error line
cabalErrorLine :: FilePath -> FilePath -> String -> Bool -> Maybe (BWNote, [String])

-- | parse messages from build
parseBuildMessages :: FilePath -> FilePath -> FilePath -> String -> [BWNote]

-- | get a valid path
validLoc :: FilePath -> FilePath -> FilePath -> FilePath

-- | read an integer and return a default value if not readable
readInt :: String -> Int -> Int

-- | read a list and return the empty list if not readable
tryReadList :: Read a => String -> [a]

-- | add a message to the note
makeNote :: BWNote -> [String] -> BWNote

-- | get the path of a file getting compiled
getBuiltPath :: String -> Maybe FilePath

-- | the cabal build info for a specific component
data CabalBuildInfo
CabalBuildInfo :: Target -> FilePath -> Bool -> [(Maybe ModuleName, FilePath)] -> CabalComponent -> CabalBuildInfo

-- | the target
cbiTarget :: CabalBuildInfo -> Target

-- | the folder to build that component into
cbiBuildFolder :: CabalBuildInfo -> FilePath

-- | is the component the library
cbiIsLibrary :: CabalBuildInfo -> Bool

-- | the module name and corresponding source file for each contained
--   Haskell module
cbiModulePaths :: CabalBuildInfo -> [(Maybe ModuleName, FilePath)]

-- | the component handle
cbiComponent :: CabalBuildInfo -> CabalComponent

-- | canonicalize the paths in the build info
canonicalizeBuildInfo :: CabalBuildInfo -> BuildWrapper CabalBuildInfo

-- | apply a function on the build info modules and paths, in a monad
onModulePathsM :: Monad a => ([(Maybe ModuleName, FilePath)] -> a [(Maybe ModuleName, FilePath)]) -> CabalBuildInfo -> a CabalBuildInfo

-- | apply a function on the build info modules and paths
onModulePaths :: ([(Maybe ModuleName, FilePath)] -> [(Maybe ModuleName, FilePath)]) -> CabalBuildInfo -> CabalBuildInfo

-- | get the build info for a given source file if a source file is in
--   several component, get the first one
getBuildInfo :: FilePath -> Maybe String -> BuildWrapper (OpResult (Maybe ([Target], CabalBuildInfo)))

-- | set the GHC options on targets
setOptions :: FilePath -> Maybe FilePath -> [Target] -> IO [Target]

-- | get GHC options for a file
fileGhcOptions :: CabalBuildInfo -> BuildWrapper [String]

-- | get CPP options for a file
fileCppOptions :: CabalBuildInfo -> [String]

-- | get the cabal extensions
cabalExtensions :: CabalBuildInfo -> (ModuleName, [String])

-- | get the source directory from a build info
getSourceDirs :: Target -> [FilePath]

-- | get all components, referencing all the files found in the source
--   folders
getAllFiles :: [Target] -> BuildWrapper [CabalBuildInfo]

-- | get build dir for a target
getBuildDir :: FilePath -> Target -> FilePath

-- | get all components, referencing only the files explicitely indicated
--   in the cabal file
getReferencedFiles :: [Target] -> BuildWrapper [CabalBuildInfo]

-- | parse a string into a module name
stringToModuleName :: String -> Maybe ModuleName

-- | convert a ModuleName to a String
moduleToString :: ModuleName -> String

-- | get all components in the Cabal file
cabalComponents :: BuildWrapper (OpResult [CabalComponent])

-- | get all the dependencies in the cabal file
cabalDependencies :: Maybe FilePath -> BuildWrapper (OpResult [(FilePath, [CabalPackage])])

-- | get all dependencies from the package description and the list of
--   installed packages
dependencies :: [Target] -> [(FilePath, [InstalledPackageInfo])] -> [(FilePath, [CabalPackage])]

-- | get all components from the package description
cabalComponentsFromDescription :: [Target] -> [CabalComponent]

-- | get dependencies for all stanzas
cabalComponentsDependencies :: [Target] -> Map CabalComponent [(String, Maybe Version)]

-- | convert a dynamic cabla target into a CabalComponent
cabalComponentFromTarget :: Target -> CabalComponent

-- | transform a library target into a CabalComponent
cabalComponentFromLibrary :: Target -> CabalComponent

-- | transform an executable target into a CabalComponent
cabalComponentFromExecutable :: Target -> CabalComponent

-- | transform a test suite target into a CabalComponent
cabalComponentFromTestSuite :: Target -> CabalComponent

-- | transform a benchmark target into a CabalComponent
cabalComponentFromBenchmark :: Target -> CabalComponent
instance Read CabalBuildInfo
instance Show CabalBuildInfo


-- | Load relevant module in the GHC AST and get GHC messages and thing at
--   point info. Also use the GHC lexer for syntax highlighting.
module Language.Haskell.BuildWrapper.GHC

-- | a function taking the file name and typechecked module as parameters
type GHCApplyFunction a = FilePath -> TypecheckedModule -> Ghc a

-- | get the GHC typechecked AST
getAST :: FilePath -> FilePath -> String -> [String] -> IO (OpResult (Maybe TypecheckedSource))

-- | perform an action on the GHC Typechecked module
withAST :: (TypecheckedModule -> Ghc a) -> FilePath -> FilePath -> String -> [String] -> IO (Maybe a)

-- | perform an action on the GHC JSON AST
withJSONAST :: (Value -> IO a) -> FilePath -> FilePath -> String -> [String] -> IO (Maybe a)

-- | the main method loading the source contents into GHC
withASTNotes :: GHCApplyFunction a -> (FilePath -> FilePath) -> FilePath -> LoadContents -> [String] -> IO (OpResult [a])

-- | init GHC session
initGHC :: Ghc a -> [String] -> IO a

-- | run a GHC action and get results with notes
ghcWithASTNotes :: GHCApplyFunction a -> (FilePath -> FilePath) -> FilePath -> LoadContents -> Bool -> Ghc (OpResult [a])

-- | do we have -Werror
isWarnIsError :: DynFlags -> Bool

-- | Convert <a>Messages</a> to '[BWNote]'.
--   
--   This will mix warnings and errors, but you can split them back up by
--   filtering the '[BWNote]' based on the <tt>bw_status</tt>.
ghcMessagesToNotes :: DynFlags -> FilePath -> Messages -> [BWNote]

-- | get all names in scope
getGhcNamesInScope :: FilePath -> FilePath -> String -> [String] -> IO [String]

-- | get all names in scope, packaged in NameDefs
getGhcNameDefsInScope :: FilePath -> FilePath -> String -> [String] -> IO (OpResult (Maybe [NameDef]))

-- | get all names in scope, packaged in NameDefs, and keep running a loop
--   listening to commands
getGhcNameDefsInScopeLongRunning :: FilePath -> FilePath -> String -> [String] -> IO ()

-- | evaluate expression in the GHC monad
getEvalResults :: GhcMonad m => String -> m [EvalResult]

-- | convert a Name int a NameDef
name2nd :: GhcMonad m => DynFlags -> Name -> m NameDef

-- | get the "thing" at a particular point (line/column) in the source this
--   is using the saved JSON info if available
getThingAtPointJSON :: Int -> Int -> FilePath -> FilePath -> String -> [String] -> IO (Maybe ThingAtPoint)

-- | get the "thing" at a particular point (line/column) in the source this
--   is using the saved JSON info if available
getLocalsJSON :: Int -> Int -> Int -> Int -> FilePath -> FilePath -> String -> [String] -> IO [ThingAtPoint]

-- | evaluate an expression
eval :: String -> FilePath -> FilePath -> String -> [String] -> IO [EvalResult]

-- | convert a GHC SrcSpan to a Span, ignoring the actual file info
ghcSpanToLocation :: SrcSpan -> InFileSpan

-- | convert a GHC SrcSpan to a BWLocation
ghcSpanToBWLocation :: FilePath -> SrcSpan -> BWLocation

-- | convert a column info from GHC to our system (1 based)
ghcColToScionCol :: Int -> Int

-- | convert a column info from our system (1 based) to GHC
scionColToGhcCol :: Int -> Int

-- | Get a stream of tokens generated by the GHC lexer from the current
--   document
ghctokensArbitrary :: FilePath -> String -> [String] -> IO (Either BWNote [Located Token])

-- | Get a stream of tokens generated by the GHC lexer from the current
--   document
ghctokensArbitrary' :: FilePath -> String -> Ghc (Either BWNote [Located Token])

-- | like lexTokenStream, but keep Haddock flag
lexTokenStreamH :: StringBuffer -> RealSrcLoc -> DynFlags -> ParseResult [Located Token]

-- | get lexer initial location
lexLoc :: RealSrcLoc

-- | get lexer flags
lexerFlags :: [ExtensionFlag]

-- | Filter tokens whose span appears legitimate (start line is less than
--   end line, start column is less than end column.)
ofInterest :: Located Token -> Bool

-- | Convert a GHC token to an interactive token (abbreviated token type)
tokenToType :: Located Token -> TokenDef

-- | Generate the interactive token list used by EclipseFP for syntax
--   highlighting, in the IO monad
tokenTypesArbitrary :: FilePath -> String -> Bool -> [String] -> IO (Either BWNote [TokenDef])

-- | Generate the interactive token list used by EclipseFP for syntax
--   highlighting, when already in a GHC session
tokenTypesArbitrary' :: FilePath -> String -> Bool -> Ghc (Either BWNote [TokenDef])

-- | Extract occurrences based on lexing
occurrences :: FilePath -> String -> Text -> Bool -> [String] -> IO (Either BWNote [TokenDef])

-- | Extract occurrences based on lexing
occurrences' :: FilePath -> String -> Text -> Bool -> Ghc (Either BWNote [TokenDef])

-- | Parse the current document, generating a TokenDef list, filtered by a
--   function
generateTokens :: FilePath -> String -> Bool -> [String] -> ([Located Token] -> [TokenDef]) -> ([TokenDef] -> a) -> IO (Either BWNote a)

-- | Parse the current document, generating a TokenDef list, filtered by a
--   function
generateTokens' :: FilePath -> String -> Bool -> ([Located Token] -> [TokenDef]) -> ([TokenDef] -> a) -> Ghc (Either BWNote a)

-- | Preprocess some source, returning the literate and Haskell source as
--   tuple.
preprocessSource :: String -> Bool -> ([TokenDef], String)

-- | preprocessor behavior data
data PPBehavior
Continue :: Int -> PPBehavior
Indent :: Int -> PPBehavior
Start :: PPBehavior
ContinuePragma :: PPBehavior -> PPBehavior

-- | convert a GHC error message to our note type
ghcErrMsgToNote :: DynFlags -> FilePath -> ErrMsg -> BWNote

-- | convert a GHC warning message to our note type
ghcWarnMsgToNote :: DynFlags -> FilePath -> WarnMsg -> BWNote

-- | convert a GHC message to our note type Note that we do *not* include
--   the extra info, since that information is only useful in the case
--   where we do not show the error location directly in the source.
ghcMsgToNote :: DynFlags -> BWNoteStatus -> FilePath -> ErrMsg -> BWNote

-- | remove the initial status text from a message
removeStatus :: BWNoteStatus -> String -> String

-- | make unqualified token
mkUnqualTokenValue :: FastString -> Text

-- | make qualified token: join the qualifier and the name by a dot
mkQualifiedTokenValue :: FastString -> FastString -> Text

-- | make a text name from a token
mkTokenName :: Token -> Text

-- | get token type from Token
tokenType :: Token -> Text

-- | a dot as a FastString
dotFS :: FastString

-- | generate a token value
tokenValue :: Bool -> Token -> Text

-- | extract start line and column from SrcSpan
start :: SrcSpan -> (Int, Int)

-- | extract end line and column from SrcSpan
end :: SrcSpan -> (Int, Int)

-- | map of module aliases
type AliasMap = Map ModuleName [ModuleName]

-- | get usages from GHC imports
ghcImportToUsage :: Text -> LImportDecl Name -> ([Usage], AliasMap) -> Ghc ([Usage], AliasMap)

-- | get usages from GHC IE
ghcLIEToUsage :: DynFlags -> Maybe Text -> Text -> Text -> LIE Name -> [Usage]

-- | get usage from GHC exports
ghcExportToUsage :: DynFlags -> Text -> Text -> AliasMap -> LIE Name -> Ghc [Usage]

-- | generate a usage for a name
ghcNameToUsage :: DynFlags -> Maybe Text -> Text -> Text -> Name -> SrcSpan -> Bool -> Usage

-- | map of imports
type ImportMap = Map Text (LImportDecl Name, [Text])

-- | build an import map from all imports
ghcImportMap :: LImportDecl Name -> Ghc ImportMap

-- | module, function/type, constructors
type TypeMap = Map Text (Map Text (Set Text))

-- | mapping to import declaration to actually needed names
type FinalImportValue = (LImportDecl Name, Map Text (Set Text))

-- | map from original text to needed names
type FinalImportMap = Map Text FinalImportValue

-- | clean imports
ghcCleanImports :: FilePath -> FilePath -> String -> [String] -> Bool -> IO (OpResult [ImportClean])
instance Data Token
instance Typeable Token
instance Eq PPBehavior
instance Monoid (Bag a)


-- | API entry point, with all exposed methods
module Language.Haskell.BuildWrapper.API

-- | copy all files from the project to the temporary folder
synchronize :: Bool -> BuildWrapper (OpResult ([FilePath], [FilePath]))

-- | synchronize one file only
synchronize1 :: Bool -> FilePath -> BuildWrapper (Maybe FilePath)

-- | write contents to temporary file
write :: FilePath -> String -> BuildWrapper ()

-- | run cabal configure
configure :: WhichCabal -> BuildWrapper (OpResult Bool)

-- | run cabal build
build :: Bool -> WhichCabal -> BuildWrapper (OpResult BuildResult)

-- | generate usage information files
generateUsage :: Bool -> String -> BuildWrapper (OpResult (Maybe [FilePath]))

-- | build one source file in GHC
build1 :: FilePath -> Maybe String -> BuildWrapper (OpResult (Maybe [NameDef]))

-- | build one source file in GHC
build1LongRunning :: FilePath -> Maybe String -> BuildWrapper (OpResult (Maybe ()))

-- | preprocess a file
preproc :: BuildFlags -> FilePath -> IO String

-- | get the build flags for a source file
getBuildFlags :: FilePath -> Maybe String -> BuildWrapper (OpResult BuildFlags)

-- | get haskell-src-exts commented AST for source file
getAST :: FilePath -> Maybe String -> BuildWrapper (OpResult (Maybe (ParseResult (Module SrcSpanInfo, [Comment]))))

-- | get GHC typechecked AST for source file
getGHCAST :: FilePath -> Maybe String -> BuildWrapper (OpResult (Maybe TypecheckedSource))

-- | perform an action on the GHC AST
withGHCAST :: FilePath -> Maybe String -> (FilePath -> FilePath -> String -> [String] -> IO a) -> BuildWrapper (OpResult (Maybe a))

-- | perform an action on the GHC AST, returning notes alonside with the
--   result
withGHCAST' :: FilePath -> Maybe String -> (FilePath -> FilePath -> String -> [String] -> IO (OpResult (Maybe a))) -> BuildWrapper (OpResult (Maybe a))

-- | get outline for source file
getOutline :: FilePath -> Maybe String -> BuildWrapper (OpResult OutlineResult)

-- | get lexer token types for source file
getTokenTypes :: FilePath -> BuildWrapper (OpResult [TokenDef])

-- | get all occurrences of a token in the file
getOccurrences :: FilePath -> String -> Maybe String -> BuildWrapper (OpResult [TokenDef])

-- | get thing at point
getThingAtPoint :: FilePath -> Int -> Int -> Maybe String -> BuildWrapper (OpResult (Maybe ThingAtPoint))

-- | get locals identifiers
getLocals :: FilePath -> Int -> Int -> Int -> Int -> Maybe String -> BuildWrapper (OpResult [ThingAtPoint])

-- | evaluate an expression
evalExpression :: FilePath -> String -> Maybe String -> BuildWrapper (OpResult [EvalResult])

-- | get all names in scope (GHC API)
getNamesInScope :: FilePath -> Maybe String -> BuildWrapper (OpResult (Maybe [String]))

-- | get cabal dependencies
getCabalDependencies :: FilePath -> BuildWrapper (OpResult [(FilePath, [CabalPackage])])

-- | get cabal components
getCabalComponents :: BuildWrapper (OpResult [CabalComponent])

-- | clean imports in a source file
cleanImports :: FilePath -> Bool -> Maybe String -> BuildWrapper (OpResult [ImportClean])

-- | clean generated and copied files
clean :: Bool -> BuildWrapper Bool
