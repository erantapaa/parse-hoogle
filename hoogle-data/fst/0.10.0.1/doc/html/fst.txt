-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Finite state transducers
--   
@package fst
@version 0.10.0.1


-- | fstStudio takes a program consisting of regular relations that denotes
--   the relation between two regular languages and constructs a
--   transducer. If a regular expression, not a relation, is given, then it
--   is interpreted as the identity relation. The syntax is very similar to
--   Xerox's finite state transducer syntax with two fundamental
--   differences: a distinction is made between functions (definitions) and
--   strings, and fststudio allows functional definitions.
--   
--   <ul>
--   <li><i><tt>"a"</tt></i> A symbol. Example: <tt>["b"]</tt> denotes the
--   language <tt>{"b"}</tt>.</li>
--   <li><i><tt>a</tt></i> A variable. A symbol without quotes is a
--   variable.</li>
--   <li><i><tt>"a":"b"</tt></i> Describes a relation between the symbol
--   <tt>a</tt> and <tt>b</tt>. This relation is ordered and <tt>a</tt> is
--   said to be a part of the /upper language<i> and <tt>b</tt> is said to
--   be part of the </i>lower language/. Example: <tt>["a":"b"]</tt>
--   denotes the relation <tt>{("a","b")}</tt>.</li>
--   <li><i><tt>0</tt></i> Epsilon symbol. The epsilon symbol denotes the
--   string with no symbols. Example: <tt>[0]</tt> denotes the language
--   <tt>{""}</tt>.</li>
--   <li><i><tt>?</tt></i> All symbol. The all symbol denotes the union of
--   all symbols in the alphabet. Example: <tt>[?]</tt> and an alphabet
--   <tt>{a,b,c}</tt> denotes the language <tt>{"a","b","c"}</tt>.</li>
--   <li><i><tt>""</tt></i> quotes cancel every special meaning of the
--   symbols. Example: <tt>["? 0"]</tt> denotes the language <tt>{"?
--   0"}</tt>.</li>
--   <li><i>@[A\</i> @] brackets are used to change the precedence of a
--   regular relation.</li>
--   <li><i><tt>(A)</tt></i> parenthesis expresses optionality, and has the
--   same meaning as <tt>[A|0]</tt>.</li>
--   <li><i><tt>A B</tt></i> Concatenation of the expressions or relations
--   A and B. Example: <tt>[[a b] [c d]]</tt> denotes the language
--   <tt>{"ac", "ad", "bc", "bd"}</tt></li>
--   <li><i><tt>A^n</tt></i> Concatenation of <tt>A</tt> <i>n</i> times.
--   <tt>A^0</tt> is defined as the empty string. Example: <tt>[a]^3</tt>
--   describes the language <tt>{"aaa"}</tt>.</li>
--   <li><i><tt>A|B</tt></i> Union of the languages or relations <tt>A</tt>
--   and <tt>B</tt>. Example: <tt>[a|b]</tt> describes the language
--   <tt>{"a","b"}</tt>.</li>
--   <li><i><tt>A &amp; B</tt></i> Intersection of the languages <tt>A</tt>
--   and <tt>B</tt>. Example: <tt>[a b] &amp; [a]</tt> describes the
--   language <tt>{"a"}</tt>.</li>
--   <li><i><tt>A - B</tt></i> Minus of the languages <tt>A</tt> and
--   <tt>B</tt>, and has the same meaning as <tt>[A &amp; B]</tt>. Example:
--   <tt>[a b] - [a]</tt> describes the language <tt>{"b"}</tt>.</li>
--   <li><i><tt>~A</tt></i> Describes the complement of an expression, and
--   has the same meaning as <tt>[?* - A]</tt>. Note that complement is
--   always defined over an alphabet. The expression <tt>[A]</tt> is only
--   unambiguous with respect to an alphabet. Example: <tt>[a]</tt> denotes
--   the language that doesn't contain the string <tt>"a"</tt>. If the
--   alphabet is <tt>{"a","b"}</tt> then <tt>[a]</tt> denotes the language
--   <tt>{"","b","aa","ba",...}</tt>.</li>
--   <li><i><tt>A+</tt></i> Repetition (Kleenes plus). A concatenated with
--   itself an arbitrary number of times, including zero times. Example:
--   <tt>[a]+</tt> denotes the infinite language
--   <tt>{"a","aa","aaa",...}</tt></li>
--   <li><i><tt>A*</tt></i> Kleene’s star: <tt>[A+ | 0]</tt>. Example:
--   <tt>[a]*</tt> denotes the infinite language
--   <tt>{"","a","aa",...}</tt></li>
--   <li><i><tt>$A</tt></i> Containment. The set of strings where
--   <tt>A</tt> appear at least once as a substring. Containment is the
--   same thing as <tt>[?* A ?*]</tt>.</li>
--   <li><i><tt>A .x. B</tt></i> Cross product of the languages <tt>A</tt>
--   and <tt>B</tt>. Example: <tt>[[a b] .x. c]</tt> describes the
--   relations <tt>{("a","c"), ("b","c")}</tt>.</li>
--   <li><i><tt>A .o. B</tt></i> Composition of the relations <tt>A</tt>
--   and <tt>B</tt>. Example: <tt>[a:b c:d] .o. [d:e]</tt> describes the
--   relation <tt>{("c","e")}</tt>.</li>
--   </ul>
--   
--   The precedence of the operators is as follows, where 4 is the highest
--   precedence:
--   
--   <ol>
--   <li><tt>.x.</tt> <tt>.o.</tt></li>
--   <li><tt>&amp;</tt> <tt>-</tt></li>
--   <li><i>Concatenation</i></li>
--   <li><tt>~</tt> <tt>^</tt> <tt>*</tt> <tt>+</tt> <tt>$</tt></li>
--   </ol>
--   
--   A file containing a program must end with <tt>.fst</tt>, and an input
--   file mustend with <tt>.dat</tt>. A program is a collection of
--   functions defining regular relations. A function with zero arguments
--   is called a definition or a macro. A definition, or a macro, can for
--   example look like this:
--   
--   <pre>
--   &lt;digits&gt; ::= "1" | "2" | "3" | "4" | "5" |
--                "6" | "7" | "8" | "9" | "0" ;
--   </pre>
--   
--   and a function can look like this:
--   
--   <pre>
--   &lt;swap,a,b&gt; ::= b a ;
--   </pre>
--   
--   Note that strings are marked with quotes, and variables have no
--   quotes. Every program must contain a <tt>&lt;main&gt;</tt> definition
--   (a program without one will result in a parse error).
--   
--   <pre>
--   &lt;main&gt; ::= ... ;
--   </pre>
--   
--   The alphabet of a program is the symbols in the regular relation
--   defined in the program.
--   
--   <i>Example program</i>
--   
--   <pre>
--   &lt;nickel&gt;  ::= ["n" .x. "c"^5];
--   &lt;dime&gt;    ::= ["d" .x. "c"^10];
--   &lt;quarter&gt; ::= ["q" .x. "c"^25];
--   &lt;cent&gt;    ::= ["c" .x. "c"];
--   &lt;money&gt;   ::= [ &lt;nickel&gt; | &lt;dime&gt; | &lt;quarter&gt; | &lt;cent&gt;]*;
--   &lt;drink&gt;   ::= ["c"^65 .x. "PLONK"];
--   &lt;main&gt;    ::= [ &lt;money&gt; .o. &lt;drink&gt; ];
--   </pre>
--   
--   <i>Batch mode</i>
--   
--   Usage: <tt>fst FILE [Options]</tt>. FILE must end with <tt>.fst</tt>,
--   which defines an FstStudio program, or <tt>.net</tt>, which defines a
--   saved transducer. If no options are given, then input is taken from
--   standard input, the transducer is applied down, and the output, if
--   any, is produced on standard output.
--   
--   <ul>
--   <li><i><tt>-u</tt></i> Apply the transducer up</li>
--   <li><i><tt>-d</tt></i> Apply the transducer down</li>
--   <li><i><tt>-i FILE</tt></i> Take input from FILE</li>
--   <li><i><tt>-o FILE</tt></i> Write output to FILE</li>
--   </ul>
--   
--   <i>Interactive mode - list of commands</i>
--   
--   <ul>
--   <li><i><tt>r REG</tt></i> Read a regular relation from standard input.
--   If a regular expression is typed, then it is interpreted as the
--   identity relation.</li>
--   <li><i><tt>b</tt></i> Build an epsilon-free, deterministic, minimal
--   transducer from a loaded/typed regular relation.</li>
--   <li><i><tt>bn</tt></i> Build an epsilon-free, possibly
--   non-deterministic, non-minimal transducer from a load/typed regular
--   relation.</li>
--   <li><i><tt>m</tt></i> Minimize a built transducer.</li>
--   <li><i><tt>det</tt></i> Determinize a built transducer.</li>
--   <li><i><tt>s FILE</tt></i> Save to <tt>FILE</tt>. If <tt>FILE</tt>
--   ends with <tt>.net</tt>, then the built transducer is saved. Any other
--   suffix saves the produced output in the system to <tt>FILE</tt>, if
--   any.</li>
--   <li><i><tt>l FILE</tt></i> Load from <tt>FILE</tt>. <tt>FILE</tt> must
--   end with <tt>.fst</tt>, <tt>.net</tt> or <tt>.dat</tt>. If
--   <tt>FILE</tt> ends with <tt>.fst</tt>, then a FstStudio program is
--   loaded into FstStudio. If <tt>FILE</tt> ends with <tt>.net</tt>, then
--   a transducer is loaded into FstStudio. If <tt>FILE</tt> ends with
--   <tt>.dat</tt>, then input is loaded into FstStudio.</li>
--   <li><i><tt>l a | b</tt></i> Load and union two transducers. a and b
--   must either be a file ending with <tt>.net</tt> or the symbol
--   <tt>*</tt>, which refers to the interior transducer. The produced
--   transducer is possibly non-deterministic and non-minimal.</li>
--   <li><i><tt>l a b</tt></i> Load and concatenate two transducers. a and
--   b must either be ale ending with <tt>.net</tt> or the symbol
--   <tt>*</tt>, which refers to the interior transducer. The produced
--   transducer is possibly non-deterministicand non-minimal.</li>
--   <li><i><tt>l a*</tt></i> Load and apply Kleene’s star on a transducer.
--   a must either be a file ending with <tt>.net</tt> or the symbol
--   <tt>*</tt>, which refers to the interior transducer. The produced
--   transducer is possibly non-deterministicand non-minimal.</li>
--   <li><i><tt>l a .o. b</tt></i> Load and compose two transducers. a and
--   b must either be a file ending with <tt>.net</tt> or the symbol
--   <tt>*</tt>, which refers to the interior transducer. The produced
--   transducer is possibly non-deterministic andnon-minimal.</li>
--   <li><i><tt>vt</tt></i> View loaded/built transducer.</li>
--   <li><i><tt>vr</tt></i> View loaded/typed regular relation.</li>
--   <li><i><tt>vi</tt></i> View loaded input.</li>
--   <li><i><tt>vo</tt></i> View produced output.</li>
--   <li><i><tt>d</tt></i> Apply transducer down with loaded input.</li>
--   <li><i><tt>u</tt></i> Apply transducer up with loaded input.</li>
--   <li><i><tt>d SYMBOLS</tt></i> Apply tranducer down with
--   <tt>SYMBOLS</tt>.</li>
--   <li><i><tt>u SYMBOLS</tt></i> Apply transducer up with
--   <tt>SYMBOLS</tt>.</li>
--   <li><i><tt>c</tt></i> Clear memory.</li>
--   <li><i><tt>h</tt></i> List commands.</li>
--   <li><i><tt>q</tt></i> End session.</li>
--   </ul>
module FST.FSTStudio


-- | Functions for constructing a simplified regular expression.
module FST.RegTypes

-- | Combinators. The regular expressions are simplified while combined.
class Combinators a
(<|>) :: Combinators a => a -> a -> a
(|>) :: Combinators a => a -> a -> a
star :: Combinators a => a -> a
plus :: Combinators a => a -> a
empty :: Combinators a => a

-- | Type class for the collection of symbols in an expression.
class Symbols f
symbols :: (Symbols f, Eq a) => f a -> [a]

-- | Data type for a regular expression.
data Reg a

-- | <ul>
--   <li><i> </i></li>
--   </ul>
Empty :: Reg a

-- | 0
Epsilon :: Reg a

-- | ?
All :: Reg a

-- | a
Symbol :: a -> Reg a

-- | <ul>
--   <li><i> r1 | r2 </i></li>
--   </ul>
(:|:) :: Reg a -> Reg a -> Reg a

-- | <ul>
--   <li><i> r1 r2 </i></li>
--   </ul>
(:.:) :: Reg a -> Reg a -> Reg a

-- | <ul>
--   <li><i> r1 &amp; r2 </i></li>
--   </ul>
(:&:) :: Reg a -> Reg a -> Reg a

-- | ~[ r1 ]
Complement :: (Reg a) -> Reg a

-- | <ul>
--   <li><i> r2 </i> *</li>
--   </ul>
Star :: (Reg a) -> Reg a

-- | Intersection
(<&>) :: Eq a => Reg a -> Reg a -> Reg a

-- | Minus. Definition A - B = A &amp; ~B
(<->) :: Eq a => Reg a -> Reg a -> Reg a

-- | Complement
complement :: Eq a => Reg a -> Reg a

-- | Reverse the language denoted by the regular expression.
reversal :: Eq a => Reg a -> Reg a

-- | Construct a ?-free regular expression with respect to an alphabet [a]
allFree :: Eq a => Reg a -> [a] -> Reg a

-- | Symbol
s :: a -> Reg a

-- | Epsilon
eps :: Reg a

-- | All symbol
allS :: Reg a

-- | Transform the <a>all</a> symbol to union over alphabet. ? -&gt; [a|..]
--   with respect to an alphabet [a]
allToSymbols :: Eq a => [a] -> Reg a

-- | Examines if a regular expression accepts the empty string.
acceptEps :: Eq a => Reg a -> Bool
instance Eq a => Eq (Reg a)
instance Show a => Show (Reg a)
instance Symbols Reg
instance Eq a => Combinators (Reg a)


-- | Types for Automaton
module FST.AutomatonTypes

-- | A state
type StateTy = Int

-- | First state
type FirstState = Int

-- | Last state
type LastState = Int

-- | Initial states
type InitialStates = [StateTy]

-- | Final states
type FinalStates = [StateTy]

-- | Transitions
type Transitions a = [(a, StateTy)]

-- | Table of transitions
type TransitionTable a = [(StateTy, Transitions a)]

-- | The alphabet of an automaton
type Sigma a = [a]

-- | Class of AutomatonFunctions
class AutomatonFunctions f
states :: AutomatonFunctions f => f a -> [StateTy]
isFinal :: AutomatonFunctions f => f a -> StateTy -> Bool
finals :: AutomatonFunctions f => f a -> FinalStates
initials :: AutomatonFunctions f => f a -> InitialStates
transitionList :: AutomatonFunctions f => f a -> StateTy -> Transitions a
transitionTable :: AutomatonFunctions f => f a -> TransitionTable a
transitions :: (AutomatonFunctions f, Eq a) => f a -> (StateTy, a) -> [StateTy]
firstState :: (AutomatonFunctions f, Eq a) => f a -> StateTy
lastState :: (AutomatonFunctions f, Eq a) => f a -> StateTy
alphabet :: AutomatonFunctions f => f a -> Sigma a


-- | Type system for transducers
module FST.TransducerTypes

-- | A state
type StateTy = Int

-- | Final states
type FinalStates = [StateTy]

-- | First state
type FirstState = Int

-- | Last state
type LastState = Int

-- | The alphabet of an automaton
type Sigma a = [a]

-- | A relation between upper/lower languages
type Relation a = (Upper a, Lower a)

-- | Upper language
type Upper a = Symbol a

-- | Lower language
type Lower a = Symbol a

-- | A symbol
data Symbol a
S :: a -> Symbol a
Eps :: Symbol a

-- | Transducer transitions
type TTransitions a = [(Relation a, StateTy)]

-- | Transducer transition table
type TTransitionTable a = [(StateTy, [(Relation a, StateTy)])]

-- | Initial states
type InitialStates = [StateTy]

-- | Class of TransducerFunctions
class TransducerFunctions f
states :: TransducerFunctions f => f a -> [StateTy]
isFinal :: TransducerFunctions f => f a -> StateTy -> Bool
initials :: TransducerFunctions f => f a -> InitialStates
finals :: TransducerFunctions f => f a -> FinalStates
transitionTable :: TransducerFunctions f => f a -> TTransitionTable a
transitionList :: TransducerFunctions f => f a -> StateTy -> TTransitions a
transitionsU :: (TransducerFunctions f, Eq a) => f a -> (StateTy, Symbol a) -> [(Symbol a, StateTy)]
transitionsD :: (TransducerFunctions f, Eq a) => f a -> (StateTy, Symbol a) -> [(Symbol a, StateTy)]
firstState :: TransducerFunctions f => f a -> StateTy
lastState :: TransducerFunctions f => f a -> StateTy
alphabet :: TransducerFunctions f => f a -> Sigma a
instance Show a => Show (Symbol a)
instance Read a => Read (Symbol a)
instance Eq a => Eq (Symbol a)


-- | Transducers and their functions
module FST.Transducer

-- | Data type for a transducer
data Transducer a

-- | Type class TConvertable
class TConvertable f
encode :: (TConvertable f, Eq a) => f a -> Transducer a
decode :: (TConvertable f, Eq a) => Transducer a -> f a

-- | Construct a transducer
construct :: (StateTy, StateTy) -> TTransitionTable a -> Sigma a -> InitialStates -> FinalStates -> Transducer a

-- | Convert transducer labelled with something other than states to a
--   Transducer
rename :: Eq b => [(b, [(Relation a, b)])] -> Sigma a -> [b] -> [b] -> StateTy -> Transducer a

-- | Initial state
initial :: Transducer a -> StateTy

-- | Get transition as a list of states
transitions :: Eq a => Transducer a -> (StateTy, Relation a) -> [StateTy]

-- | Set first state to null
nullFirstState :: Transducer a -> Transducer a

-- | Product of two transducers
productT :: Eq a => Transducer a -> Transducer a -> Transducer a

-- | Union of two transducers
unionT :: Eq a => Transducer a -> Transducer a -> Transducer a

-- | Kleene star of two transducers
starT :: Eq a => Transducer a -> Transducer a

-- | Compose two transducers
compositionT :: Eq a => Transducer a -> Transducer a -> Transducer a

-- | Show a transducer
showTransducer :: Show a => Transducer a -> String
instance Show a => Show (Transducer a)
instance Read a => Read (Transducer a)
instance TransducerFunctions Transducer


-- | Function for making transducers deterministic
module FST.DeterministicT

-- | Construct a deterministic, usefulS transducer
determinize :: Ord a => Transducer a -> Transducer a
instance Eq SubSet


-- | Function for constructing an epsilon-free transducer
module FST.EpsilonFreeT

-- | Construct an epsilon-free, usefulS transducer
epsilonfree :: Eq a => Transducer a -> Transducer a


-- | Reverse an transducer
module FST.ReversalT

-- | Reverse a transducer
reversal :: Eq a => Transducer a -> Transducer a


-- | Running a transducer with some input
module FST.RunTransducer

-- | Apply a transducer upwards
applyUp :: Eq a => Transducer a -> [a] -> Maybe [[a]]

-- | Apply a transducer downwards
applyDown :: Eq a => Transducer a -> [a] -> Maybe [[a]]


-- | Functions for constructing a simplified regular relation.
module FST.RRegTypes

-- | Datatype for a regular relations
data RReg a

-- | Cross product
Cross :: (Reg a) -> (Reg a) -> RReg a

-- | Composition
Comp :: (RReg a) -> (RReg a) -> RReg a

-- | Concatenation
ProductR :: (RReg a) -> (RReg a) -> RReg a

-- | Union
UnionR :: (RReg a) -> (RReg a) -> RReg a

-- | Kleene star
StarR :: (RReg a) -> RReg a

-- | Identity relation
Identity :: (Reg a) -> RReg a

-- | (a:b)
Relation :: (Symbol a) -> (Symbol a) -> RReg a

-- | Empty language
EmptyR :: RReg a

-- | Cross product operator
(<*>) :: Eq a => Reg a -> Reg a -> RReg a

-- | Composition operator
(<.>) :: Eq a => RReg a -> RReg a -> RReg a

-- | Identity relation
idR :: Eq a => Reg a -> RReg a

-- | Relation
r :: Eq a => a -> a -> RReg a
instance Eq a => Eq (RReg a)
instance Show a => Show (RReg a)
instance Symbols RReg
instance Eq a => Combinators (RReg a)


-- | Neutral regular expressions
module FST.NReg

-- | Neutral regular expressions
data NReg a
NCross :: (NReg a) -> (NReg a) -> NReg a
NComp :: (NReg a) -> (NReg a) -> NReg a
NUnion :: (NReg a) -> (NReg a) -> NReg a
NProduct :: (NReg a) -> (NReg a) -> NReg a
NIntersect :: (NReg a) -> (NReg a) -> NReg a
NStar :: (NReg a) -> NReg a
NComplement :: (NReg a) -> NReg a
NSymbol :: a -> NReg a
NRelation :: a -> a -> NReg a
NEpsilon :: NReg a
NEmptySet :: NReg a
NVar :: String -> NReg a
Fun :: String -> [NReg a] -> NReg a
NAll :: NReg a

-- | If possible, build a regular expression instead of a regular relation
toRReg :: Eq a => NReg a -> Maybe (RReg a)

-- | If possible, converts NReg to Reg
toReg :: Eq a => NReg a -> Maybe (Reg a)

-- | Convert variables to symbols
nVarToSymbol :: NReg String -> NReg String


-- | Finite state automatons
module FST.Automaton

-- | Data type for an automaton
data Automaton a

-- | Type class for conversion to/from an automaton
class Convertable f
encode :: (Convertable f, Eq a) => f a -> Automaton a
decode :: (Convertable f, Eq a) => Automaton a -> f a

-- | Construct an automaton
construct :: (FirstState, LastState) -> TransitionTable a -> Sigma a -> InitialStates -> FinalStates -> Automaton a

-- | Convert automaton labelled with something other than states to an
--   <a>Automaton</a>.
rename :: Eq b => [(b, [(a, b)])] -> Sigma a -> [b] -> [b] -> StateTy -> Automaton a

-- | Display the automaton
showAutomaton :: Show a => Automaton a -> String
instance Show a => Show (Automaton a)
instance Read a => Read (Automaton a)
instance AutomatonFunctions Automaton


-- | Function for making an automaton complete (transition on every symbol
--   at every state)
module FST.Complete

-- | Make a automaton complete (transition on every symbol at every state)
complete :: Eq a => Automaton a -> Automaton a


-- | Function for making automatons deterministic
module FST.Deterministic

-- | Make an automaton deterministic and usefulS
determinize :: Ord a => Automaton a -> Automaton a
instance Eq SubSet


-- | Left-biased finite automata
module FST.LBFA

-- | Data type for LBFA (left-biased finite automata)
data LBFA a

-- | Get the initial state of a LBFA
initial :: LBFA a -> StateTy

-- | Compile a regular expression to a LBFA
compileToLBFA :: Ord a => Reg a -> Sigma a -> StateTy -> LBFA a

-- | Compile a regular expression to an minimal, useful and deterministic
--   automaton, using the LBFA algorithm while building.
compileToAutomaton :: Ord a => Reg a -> Sigma a -> StateTy -> Automaton a
instance (Eq a, Show a) => Show (LBFA a)
instance Convertable LBFA
instance AutomatonFunctions LBFA


-- | Reverse an automaton
module FST.Reversal

-- | Reverse an automaton
reversal :: Eq a => Automaton a -> Automaton a


-- | API for finite state automatons
module FST.AutomatonInterface

-- | Data type for an automaton
data Automaton a

-- | Compile a minimized non-deterministic finite-state automaton
compile :: Ord a => Reg a -> Sigma a -> StateTy -> Automaton a

-- | Compile a non-deterministic finite-state automaton
compileNFA :: Ord a => Reg a -> Sigma a -> StateTy -> Automaton a

-- | Make a non-deterministic finite-state automaton deterministic
determinize :: Ord a => Automaton a -> Automaton a

-- | Minimize an automaton using the Brzozowski algorithm. Note that the
--   determinize function must construct an automaton with the usefulS
--   property.
minimize :: Ord a => Automaton a -> Automaton a

-- | Make a automaton complete (transition on every symbol at every state)
complete :: Eq a => Automaton a -> Automaton a

-- | Get the initial state of a finite-state automaton
initial :: Automaton a -> StateTy

-- | Count the number of states in a finite-state automaton
numberOfStates :: Ord a => Automaton a -> Int

-- | Count the number of transitions in a finite-state automaton
numberOfTransitions :: Ord a => Automaton a -> Int

-- | Display the automaton
showAutomaton :: Show a => Automaton a -> String


-- | Left-biased finite transducers
module FST.LBFT

-- | Data type for a LBFT (left-biased finite transducer)
data LBFT a
LBFT :: TTransitionTable a -> StateTy -> [StateTy] -> Sigma a -> StateTy -> LBFT a
trans :: LBFT a -> TTransitionTable a
initS :: LBFT a -> StateTy
finalS :: LBFT a -> [StateTy]
alpha :: LBFT a -> Sigma a
lastS :: LBFT a -> StateTy

-- | Compile a regular relation to a LBFT
compileToLBFT :: Ord a => RReg a -> Sigma a -> LBFT a

-- | Compile a regular relation to an minimal, useful and deterministic
--   transducer, using the LBFT algorithm while building.
compileToTransducer :: Ord a => RReg a -> Sigma a -> Transducer a
instance (Eq a, Show a) => Show (LBFT a)
instance TConvertable LBFT
instance TransducerFunctions LBFT


-- | Main API for finite-state transducer library. Importing this module
--   gives you access to the folllowing functions.
--   
--   <i>Regular expressions</i>
--   
--   Functions for constructing a simplified regular expression.
--   
--   <pre>
--   s          :: a -&gt; Reg a              -- symbol
--   eps        :: Reg a                   -- epsilon
--   empty      :: Reg a                   -- empty set
--   allS       :: Reg a                   -- all symbol
--   star       :: Reg a -&gt; Reg a          -- kleene’s star
--   plus       :: Reg a -&gt; Reg a          -- kleene’s plus
--   complement :: Reg a -&gt; Reg a          -- complement
--   (&lt;|&gt;)      :: Reg a -&gt; Reg a -&gt; Reg a -- union
--   (|&gt;)       :: Reg a -&gt; Reg a -&gt; Reg a -- product
--   (&lt;&amp;&gt;)      :: Reg a -&gt; Reg a -&gt; Reg a -- intersection
--   (&lt;-&gt;)      :: Reg a -&gt; Reg a -&gt; Reg a -- set minus
--   symbols    :: Reg a -&gt; a              -- collect all symbols.
--   </pre>
--   
--   <i>Regular relations</i>
--   
--   Functions for constructing a simplified regular relation.
--   
--   <pre>
--   r       :: a -&gt; a -&gt; Reg a            -- relation
--   empty   :: RReg a                     -- empty set
--   idR     :: Reg a -&gt; RReg a            -- identity
--   star    :: RReg a -&gt; RReg a           -- kleene’s star
--   plus    :: RReg a -&gt; RReg a           -- kleene’s plus
--   (&lt;|&gt;)   :: RReg a -&gt; RReg a -&gt; RReg a -- union
--   (|&gt;)    :: RReg a -&gt; RReg a -&gt; RReg a -- product
--   (&lt;*&gt;)   :: Reg a -&gt; Reg a -&gt; RReg a   -- cross product
--   (&lt;.&gt;)   :: RReg a -&gt; RReg a -&gt; RReg a -- composition
--   symbols :: RReg a -&gt; a                -- collect all symbols
--   </pre>
--   
--   <i>Parsing regular relations</i>
--   
--   Functions for parsing regular relations.
--   
--   <a>parseProgram</a> takes a string containing a fstStudio program, and
--   try to parse it - if unsuccessful, it returns a error message.
--   <a>parseExp</a> parses a string containing a regular relation.
--   
--   <pre>
--   parseProgram :: String -&gt; Either String (RReg String)
--   parseExp     :: String -&gt; Either String (RReg String)
--   </pre>
--   
--   <i>Construction and running</i>
--   
--   Functions for constructing and running a nite state transducer. The
--   function <a>compile</a> construct a deterministic, epsilonfree,
--   minimal transducer, and <a>compileN</a> construct a epsilonfree,
--   possibly non-deterministic, non-minimal transducer. The <a>Sigma</a>
--   type provides a way to add symbols that is not present in the regular
--   relation. <a>applyDown</a> and <a>applyUp</a> are used to run the
--   transducer.
--   
--   <pre>
--   type Sigma a = [a]
--   
--   compile         :: Ord a =&gt; RReg a -&gt; Sigma a -&gt; Transducer a
--   compileN        :: Ord a =&gt; RReg a -&gt; Sigma a -&gt; Transducer a
--   determinize     :: Ord a =&gt; Transducer a -&gt; Transducer a
--   minimize        :: Ord a =&gt; Transducer a -&gt; Transducer a
--   unionT          :: Ord a =&gt; Transducer a -&gt; Transducer a -&gt; Transducer a
--   productT        :: Ord a =&gt; Transducer a -&gt; Transducer a -&gt; Transducer a
--   starT           :: Ord a =&gt; Transducer a -&gt; Transducer a
--   compositionT    :: Ord a =&gt; Transducer a -&gt; Transducer a -&gt; Transducer a
--   emptyTransducer :: Transducer a
--   applyDown       :: Ord a =&gt; Transducer a -&gt; [a] -&gt; Maybe [[a]]
--   applyUp         :: Ord a =&gt; Transducer a -&gt; [a] -&gt; Maybe [[a]]
--   load            :: FilePath -&gt; IO (Either String (Transducer String))
--   save            :: FilePath -&gt; Transducer String -&gt; IO (Either String ())
--   </pre>
--   
--   <i>Transducer Information</i>
--   
--   Functions for getting information about a built transducer.
--   
--   type StateTy = Int
--   
--   <pre>
--   states              :: Transducer a -&gt; [StateTy]
--   isFinal             :: Transducer a -&gt; StateTy -&gt; Bool
--   initial             :: Transducer a -&gt; StateTy
--   finals              :: Transducer a -&gt; [StateTy]
--   transitonsU         :: Transducer a -&gt; (StateTy,a) -&gt; [(a,StateTy)]
--   transitionsD        :: Transducer a -&gt; (StateTy,a) -&gt; [(a,StateTy)]
--   showTransducer      :: Transducer a -&gt; String
--   numberOfStates      :: Transducer a -&gt; Int
--   numberOfTransitions :: Transducer a -&gt; Int
--   </pre>
module FST.TransducerInterface

-- | Data type for a transducer
data Transducer a

-- | Construct a deterministic, epsilon-free, minimal transducer
compile :: Ord a => RReg a -> Sigma a -> Transducer a

-- | Construct an epsilon-free, possibly non-deterministic, non-minimal
--   transducer
compileN :: Ord a => RReg a -> Sigma a -> Transducer a

-- | Make a transducer minimal
minimize :: Ord a => Transducer a -> Transducer a

-- | Make a transducer deterministic
determinize :: Ord a => Transducer a -> Transducer a

-- | The empty transucer
emptyTransducer :: Ord a => Transducer a

-- | Return the number of states in a transducer
numberOfStates :: Ord a => Transducer a -> Int

-- | Return the number of transitions in a transducer
numberOfTransitions :: Ord a => Transducer a -> Int

-- | Get transition as a list of states
transitions :: Eq a => Transducer a -> (StateTy, Relation a) -> [StateTy]

-- | Show a transducer
showTransducer :: Show a => Transducer a -> String

-- | Union of two transducers
unionT :: Eq a => Transducer a -> Transducer a -> Transducer a

-- | Product of two transducers
productT :: Eq a => Transducer a -> Transducer a -> Transducer a

-- | Kleene star of two transducers
starT :: Eq a => Transducer a -> Transducer a

-- | Compose two transducers
compositionT :: Eq a => Transducer a -> Transducer a -> Transducer a

-- | Load a transducer from file
load :: FilePath -> ErrorT String IO (Transducer String)

-- | Save a transducer from file
save :: FilePath -> Transducer String -> ErrorT String IO ()

-- | Open a file and return contents as string
open :: FilePath -> ErrorT String IO String

-- | Save contents (as string) to a file
saveToFile :: FilePath -> String -> ErrorT String IO ()

-- | Parse a program from a string
parseProgram :: String -> Either String (RReg String)

-- | Parse a regular expression from a string
parseExp :: String -> Either String (RReg String)

-- | Apply a transducer upwards
applyUp :: Eq a => Transducer a -> [a] -> Maybe [[a]]

-- | Apply a transducer downwards
applyDown :: Eq a => Transducer a -> [a] -> Maybe [[a]]
