-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A simple grammar for building linear equations and inclusive inequalities.
--   
--   This library provides some simple tools for building abstract syntax
--   trees, representing linear equations and (inclusive) inequalities. As
--   an example:
--   
--   <pre>
--   12x + 3y - 4z + 12 &lt;= 43x - 7b + 8q
--   </pre>
--   
--   Would look like...
--   
--   <pre>
--   f = (12 :: Rational) .*. EVar "x" .+.
--       (3 :: Rational) .*. EVar "y" .+.
--       (-4 :: Rational) .*. EVar "z" .+.
--       ELit 12
--       .&lt;=.
--       (43 :: Rational) .*. EVar "x" .+.
--       (-7 :: Rational) .*. EVar "b" .+.
--       (8 :: Rational) .*. EVar "q"
--   </pre>
--   
--   I've added some overloading functionality, to help ease the verbosity
--   of the above statements - an <tt>IsString</tt> instance, and some
--   other utilities. To pack the equation into <a>standard form</a>, use
--   the <tt>sandardForm</tt> function:
--   
--   <pre>
--   stdF = standardForm f
--   </pre>
@package linear-grammar
@version 0.0.2.1

module Linear.Grammar

-- | User-facing abstract syntax tree
data LinAst
[EVar] :: String -> LinAst
[ELit] :: Rational -> LinAst
[ECoeff] :: LinAst -> Rational -> LinAst
[EAdd] :: LinAst -> LinAst -> LinAst

-- | Doesn't solve the ridde, but it helps.
(.+.) :: LinAst -> LinAst -> LinAst
class Coefficient x y
(.*.) :: Coefficient x y => x -> y -> LinAst

-- | Pushes <tt>ECoeff</tt> down the tree, leaving <tt>EAdd</tt> at the top
--   level. After using this funciton, all <tt>ECoeff</tt> constructors
--   <tt>LinAst</tt> parameter will be <tt>EVar</tt>.
multLin :: LinAst -> LinAst
data LinVar
[LinVar] :: String -> Rational -> LinVar
[varName] :: LinVar -> String
[varCoeff] :: LinVar -> Rational

-- | For sorting tableaus
hasName :: String -> LinVar -> Bool
mapName :: (String -> String) -> LinVar -> LinVar
hasCoeff :: Rational -> LinVar -> Bool
mapCoeff :: (Rational -> Rational) -> LinVar -> LinVar

-- | Linear expressions suited for normal and standard form.
data LinExpr
[LinExpr] :: [LinVar] -> Rational -> LinExpr
[exprVars] :: LinExpr -> [LinVar]
[exprConst] :: LinExpr -> Rational
mergeLinExpr :: LinExpr -> LinExpr -> LinExpr

-- | Turns <tt>LinAst</tt> to <tt>LinExpr</tt> - should be done
--   <i>after</i> <tt>multLin</tt>.
addLin :: LinAst -> LinExpr

-- | Merged duplicate <tt>LinVar</tt>s in a <tt>LinExpr</tt>. Should be
--   used <i>after</i> <tt>addLin</tt>.
removeDupLin :: LinExpr -> LinExpr
makeLinExpr :: LinAst -> LinExpr
data Ineq
[Equ] :: LinExpr -> LinExpr -> Ineq
[Lte] :: LinExpr -> LinExpr -> Ineq
(.==.) :: LinAst -> LinAst -> Ineq
(.<=.) :: LinAst -> LinAst -> Ineq
(.=>.) :: LinAst -> LinAst -> Ineq
data IneqStdForm
[EquStd] :: [LinVar] -> Rational -> IneqStdForm
[LteStd] :: [LinVar] -> Rational -> IneqStdForm
[GteStd] :: [LinVar] -> Rational -> IneqStdForm
getStdVars :: IneqStdForm -> [LinVar]
mapStdVars :: ([LinVar] -> [LinVar]) -> IneqStdForm -> IneqStdForm
getStdConst :: IneqStdForm -> Rational
mapStdConst :: (Rational -> Rational) -> IneqStdForm -> IneqStdForm

-- | Turns a user-level AST to a structurally standard from inequality.
standardForm :: Ineq -> IneqStdForm

-- | Standardizes user-level inequalities - to be used before
--   <tt>standardForm</tt>.
standardize :: Ineq -> Ineq
hasNoDups :: (Ord a) => [a] -> Bool
between1000Rational :: Gen Rational
instance Eq IneqStdForm
instance Show IneqStdForm
instance Eq Ineq
instance Show Ineq
instance Eq LinExpr
instance Show LinExpr
instance Eq LinVar
instance Show LinVar
instance Eq LinAst
instance Show LinAst
instance Arbitrary LinAst
instance IsString LinAst
instance Coefficient LinAst Rational
instance Coefficient Rational LinAst
instance Arbitrary LinVar
instance Ord LinVar
instance Arbitrary LinExpr
instance Arbitrary Ineq
instance Arbitrary IneqStdForm
