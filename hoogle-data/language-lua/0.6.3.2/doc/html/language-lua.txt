-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lua parser and pretty-printer
--   
@package language-lua
@version 0.6.3.2


-- | Lua 5.2 syntax tree, as specified in
--   <a>http://www.lua.org/manual/5.2/manual.html#9</a>. Annotation
--   implementation is inspired by haskell-src-exts.
module Language.Lua.Annotated.Syntax
data Name a
Name :: a -> String -> Name a
data Stat a

-- | var1, var2 .. = exp1, exp2 ..
Assign :: a -> [Var a] -> [Exp a] -> Stat a

-- | function call
FunCall :: a -> (FunCall a) -> Stat a

-- | label for goto
Label :: a -> (Name a) -> Stat a

-- | break
Break :: a -> Stat a

-- | goto label
Goto :: a -> (Name a) -> Stat a

-- | do .. end
Do :: a -> (Block a) -> Stat a

-- | while .. do .. end
While :: a -> (Exp a) -> (Block a) -> Stat a

-- | repeat .. until ..
Repeat :: a -> (Block a) -> (Exp a) -> Stat a

-- | if .. then .. [elseif ..] [else ..] end
If :: a -> [(Exp a, Block a)] -> (Maybe (Block a)) -> Stat a

-- | for x=start, end [, step] do .. end
ForRange :: a -> (Name a) -> (Exp a) -> (Exp a) -> (Maybe (Exp a)) -> (Block a) -> Stat a

-- | for x in .. do .. end
ForIn :: a -> [Name a] -> [Exp a] -> (Block a) -> Stat a

-- | function &lt;var&gt; (..) .. end
FunAssign :: a -> (FunName a) -> (FunBody a) -> Stat a

-- | local function &lt;var&gt; (..) .. end
LocalFunAssign :: a -> (Name a) -> (FunBody a) -> Stat a

-- | local var1, var2 .. = exp1, exp2 ..
LocalAssign :: a -> [Name a] -> (Maybe [Exp a]) -> Stat a

-- | <i>;</i>
EmptyStat :: a -> Stat a
data Exp a
Nil :: a -> Exp a
Bool :: a -> Bool -> Exp a
Number :: a -> String -> Exp a
String :: a -> String -> Exp a

-- | <i>...</i>
Vararg :: a -> Exp a

-- | <i>function (..) .. end</i>
EFunDef :: a -> (FunDef a) -> Exp a
PrefixExp :: a -> (PrefixExp a) -> Exp a

-- | table constructor
TableConst :: a -> (Table a) -> Exp a

-- | binary operators, <i>+ - * ^ % .. <a>&lt;=</a> &gt;= == ~= and or</i>
Binop :: a -> (Binop a) -> (Exp a) -> (Exp a) -> Exp a

-- | unary operators, <i>- not #</i>
Unop :: a -> (Unop a) -> (Exp a) -> Exp a
data Var a

-- | variable
VarName :: a -> (Name a) -> Var a

-- | <i>table[exp]</i>
Select :: a -> (PrefixExp a) -> (Exp a) -> Var a

-- | <i>table.variable</i>
SelectName :: a -> (PrefixExp a) -> (Name a) -> Var a
data Binop a
Add :: a -> Binop a
Sub :: a -> Binop a
Mul :: a -> Binop a
Div :: a -> Binop a
Exp :: a -> Binop a
Mod :: a -> Binop a
Concat :: a -> Binop a
LT :: a -> Binop a
LTE :: a -> Binop a
GT :: a -> Binop a
GTE :: a -> Binop a
EQ :: a -> Binop a
NEQ :: a -> Binop a
And :: a -> Binop a
Or :: a -> Binop a
data Unop a
Neg :: a -> Unop a
Not :: a -> Unop a
Len :: a -> Unop a
data PrefixExp a
PEVar :: a -> (Var a) -> PrefixExp a
PEFunCall :: a -> (FunCall a) -> PrefixExp a
Paren :: a -> (Exp a) -> PrefixExp a
data Table a

-- | list of table fields
Table :: a -> [TableField a] -> Table a
data TableField a

-- | <i>[exp] = exp</i>
ExpField :: a -> (Exp a) -> (Exp a) -> TableField a

-- | <i>name = exp</i>
NamedField :: a -> (Name a) -> (Exp a) -> TableField a
Field :: a -> (Exp a) -> TableField a

-- | A block is list of statements with optional return statement.
data Block a
Block :: a -> [Stat a] -> (Maybe [Exp a]) -> Block a
data FunName a
FunName :: a -> (Name a) -> [Name a] -> (Maybe (Name a)) -> FunName a
data FunDef a
FunDef :: a -> (FunBody a) -> FunDef a
data FunBody a

-- | (args, vararg, block)
FunBody :: a -> [Name a] -> (Maybe a) -> (Block a) -> FunBody a
data FunCall a

-- | <i>prefixexp ( funarg )</i>
NormalFunCall :: a -> (PrefixExp a) -> (FunArg a) -> FunCall a

-- | <i>prefixexp : name ( funarg )</i>
MethodCall :: a -> (PrefixExp a) -> (Name a) -> (FunArg a) -> FunCall a
data FunArg a

-- | list of args
Args :: a -> [Exp a] -> FunArg a

-- | table constructor
TableArg :: a -> (Table a) -> FunArg a

-- | string
StringArg :: a -> String -> FunArg a
class Functor ast => Annotated ast
ann :: Annotated ast => ast l -> l
amap :: Annotated ast => (l -> l) -> ast l -> ast l
instance Typeable Name
instance Typeable Binop
instance Typeable Unop
instance Typeable FunName
instance Typeable FunArg
instance Typeable Table
instance Typeable TableField
instance Typeable Exp
instance Typeable FunDef
instance Typeable FunBody
instance Typeable Block
instance Typeable Stat
instance Typeable FunCall
instance Typeable PrefixExp
instance Typeable Var
instance Show a => Show (Name a)
instance Eq a => Eq (Name a)
instance Functor Name
instance Data a => Data (Name a)
instance Generic (Name a)
instance Show a => Show (Binop a)
instance Eq a => Eq (Binop a)
instance Functor Binop
instance Data a => Data (Binop a)
instance Generic (Binop a)
instance Show a => Show (Unop a)
instance Eq a => Eq (Unop a)
instance Functor Unop
instance Data a => Data (Unop a)
instance Generic (Unop a)
instance Show a => Show (FunName a)
instance Eq a => Eq (FunName a)
instance Functor FunName
instance Data a => Data (FunName a)
instance Generic (FunName a)
instance Show a => Show (FunArg a)
instance Eq a => Eq (FunArg a)
instance Functor FunArg
instance Data a => Data (FunArg a)
instance Generic (FunArg a)
instance Show a => Show (Table a)
instance Eq a => Eq (Table a)
instance Functor Table
instance Data a => Data (Table a)
instance Generic (Table a)
instance Show a => Show (TableField a)
instance Eq a => Eq (TableField a)
instance Functor TableField
instance Data a => Data (TableField a)
instance Generic (TableField a)
instance Show a => Show (Exp a)
instance Eq a => Eq (Exp a)
instance Functor Exp
instance Data a => Data (Exp a)
instance Generic (Exp a)
instance Show a => Show (FunDef a)
instance Eq a => Eq (FunDef a)
instance Functor FunDef
instance Data a => Data (FunDef a)
instance Generic (FunDef a)
instance Show a => Show (FunBody a)
instance Eq a => Eq (FunBody a)
instance Functor FunBody
instance Data a => Data (FunBody a)
instance Generic (FunBody a)
instance Show a => Show (Block a)
instance Eq a => Eq (Block a)
instance Functor Block
instance Data a => Data (Block a)
instance Generic (Block a)
instance Show a => Show (Stat a)
instance Eq a => Eq (Stat a)
instance Functor Stat
instance Data a => Data (Stat a)
instance Generic (Stat a)
instance Show a => Show (FunCall a)
instance Eq a => Eq (FunCall a)
instance Functor FunCall
instance Data a => Data (FunCall a)
instance Generic (FunCall a)
instance Show a => Show (PrefixExp a)
instance Eq a => Eq (PrefixExp a)
instance Functor PrefixExp
instance Data a => Data (PrefixExp a)
instance Generic (PrefixExp a)
instance Show a => Show (Var a)
instance Eq a => Eq (Var a)
instance Functor Var
instance Data a => Data (Var a)
instance Generic (Var a)
instance Datatype D1Name
instance Constructor C1_0Name
instance Datatype D1Binop
instance Constructor C1_0Binop
instance Constructor C1_1Binop
instance Constructor C1_2Binop
instance Constructor C1_3Binop
instance Constructor C1_4Binop
instance Constructor C1_5Binop
instance Constructor C1_6Binop
instance Constructor C1_7Binop
instance Constructor C1_8Binop
instance Constructor C1_9Binop
instance Constructor C1_10Binop
instance Constructor C1_11Binop
instance Constructor C1_12Binop
instance Constructor C1_13Binop
instance Constructor C1_14Binop
instance Datatype D1Unop
instance Constructor C1_0Unop
instance Constructor C1_1Unop
instance Constructor C1_2Unop
instance Datatype D1FunName
instance Constructor C1_0FunName
instance Datatype D1FunArg
instance Constructor C1_0FunArg
instance Constructor C1_1FunArg
instance Constructor C1_2FunArg
instance Datatype D1Table
instance Constructor C1_0Table
instance Datatype D1TableField
instance Constructor C1_0TableField
instance Constructor C1_1TableField
instance Constructor C1_2TableField
instance Datatype D1Exp
instance Constructor C1_0Exp
instance Constructor C1_1Exp
instance Constructor C1_2Exp
instance Constructor C1_3Exp
instance Constructor C1_4Exp
instance Constructor C1_5Exp
instance Constructor C1_6Exp
instance Constructor C1_7Exp
instance Constructor C1_8Exp
instance Constructor C1_9Exp
instance Datatype D1FunDef
instance Constructor C1_0FunDef
instance Datatype D1FunBody
instance Constructor C1_0FunBody
instance Datatype D1Block
instance Constructor C1_0Block
instance Datatype D1Stat
instance Constructor C1_0Stat
instance Constructor C1_1Stat
instance Constructor C1_2Stat
instance Constructor C1_3Stat
instance Constructor C1_4Stat
instance Constructor C1_5Stat
instance Constructor C1_6Stat
instance Constructor C1_7Stat
instance Constructor C1_8Stat
instance Constructor C1_9Stat
instance Constructor C1_10Stat
instance Constructor C1_11Stat
instance Constructor C1_12Stat
instance Constructor C1_13Stat
instance Constructor C1_14Stat
instance Datatype D1FunCall
instance Constructor C1_0FunCall
instance Constructor C1_1FunCall
instance Datatype D1PrefixExp
instance Constructor C1_0PrefixExp
instance Constructor C1_1PrefixExp
instance Constructor C1_2PrefixExp
instance Datatype D1Var
instance Constructor C1_0Var
instance Constructor C1_1Var
instance Constructor C1_2Var
instance NFData a => NFData (FunArg a)
instance NFData a => NFData (FunCall a)
instance NFData a => NFData (FunBody a)
instance NFData a => NFData (FunDef a)
instance NFData a => NFData (FunName a)
instance NFData a => NFData (Block a)
instance NFData a => NFData (TableField a)
instance NFData a => NFData (Table a)
instance NFData a => NFData (PrefixExp a)
instance NFData a => NFData (Unop a)
instance NFData a => NFData (Binop a)
instance NFData a => NFData (Var a)
instance NFData a => NFData (Exp a)
instance NFData a => NFData (Stat a)
instance NFData a => NFData (Name a)
instance Annotated FunArg
instance Annotated FunCall
instance Annotated FunBody
instance Annotated FunDef
instance Annotated FunName
instance Annotated Block
instance Annotated TableField
instance Annotated Table
instance Annotated PrefixExp
instance Annotated Unop
instance Annotated Binop
instance Annotated Var
instance Annotated Exp
instance Annotated Stat

module Language.Lua.Token

-- | Lua tokens
data LToken

-- | +
LTokPlus :: LToken

-- | -
LTokMinus :: LToken

-- | *
LTokStar :: LToken

-- | /
LTokSlash :: LToken

-- | %
LTokPercent :: LToken

-- | ^
LTokExp :: LToken

-- | #
LTokSh :: LToken

-- | ==
LTokEqual :: LToken

-- | ~=
LTokNotequal :: LToken

-- | &lt;=
LTokLEq :: LToken

-- | &gt;=
LTokGEq :: LToken

-- | &lt;
LTokLT :: LToken

-- | &gt;
LTokGT :: LToken

-- | =
LTokAssign :: LToken

-- | (
LTokLParen :: LToken

-- | )
LTokRParen :: LToken

-- | {
LTokLBrace :: LToken

-- | }
LTokRBrace :: LToken

-- | [
LTokLBracket :: LToken

-- | ]
LTokRBracket :: LToken

-- | ::
LTokDColon :: LToken

-- | ;
LTokSemic :: LToken

-- | :
LTokColon :: LToken

-- | ,
LTokComma :: LToken

-- | .
LTokDot :: LToken

-- | ..
LTokDDot :: LToken

-- | ...
LTokEllipsis :: LToken

-- | and
LTokAnd :: LToken

-- | break
LTokBreak :: LToken

-- | do
LTokDo :: LToken

-- | else
LTokElse :: LToken

-- | elseif
LTokElseIf :: LToken

-- | end
LTokEnd :: LToken

-- | false
LTokFalse :: LToken

-- | for
LTokFor :: LToken

-- | function
LTokFunction :: LToken

-- | goto
LTokGoto :: LToken

-- | if
LTokIf :: LToken

-- | in
LTokIn :: LToken

-- | local
LTokLocal :: LToken

-- | nil
LTokNil :: LToken

-- | not
LTokNot :: LToken

-- | or
LTokOr :: LToken

-- | repeat
LTokRepeat :: LToken

-- | return
LTokReturn :: LToken

-- | then
LTokThen :: LToken

-- | true
LTokTrue :: LToken

-- | until
LTokUntil :: LToken

-- | while
LTokWhile :: LToken

-- | number constant
LTokNum :: String -> LToken

-- | string constant
LTokSLit :: String -> LToken

-- | identifier
LTokIdent :: String -> LToken

-- | end of file
LTokEof :: LToken
instance Eq LToken
instance Show LToken

module Language.Lua.Annotated.Lexer

-- | Lua lexer.
llex :: String -> [LTok]

-- | Run Lua lexer on a file.
llexFile :: FilePath -> IO [LTok]

-- | Lua token with position information.
type LTok = (LToken, AlexPosn)
data AlexPosn
AlexPn :: !Int -> !Int -> !Int -> AlexPosn
instance Eq AlexPosn
instance Show AlexPosn
instance Show EOF
instance Functor AlexLastAcc
instance Monad Alex


-- | Lexer/Parsec interface
module Text.Parsec.LTok

-- | Parses given <a>LToken</a>.
tok :: Stream [LTok] m LTok => LToken -> ParsecT [LTok] u m LToken

-- | Parses a <a>LTokIdent</a>.
anyIdent :: Monad m => ParsecT [LTok] u m String

-- | Parses a <a>LTokNum</a>.
number :: Monad m => ParsecT [LTok] u m String

-- | Parses a <a>LTokSLit</a>.
stringlit :: Monad m => ParsecT [LTok] u m String
type Parser = Parsec [LTok] ()

module Language.Lua.Annotated.Parser

-- | Runs Lua lexer before parsing. Use <tt>parseText stat</tt> to parse
--   statements, and <tt>parseText exp</tt> to parse expressions.
parseText :: Parser a -> String -> Either ParseError a

-- | Runs Lua lexer before parsing. Use <tt>parseNamedText stat "name"</tt>
--   to parse statements, and <tt>parseText exp "name"</tt> to parse
--   expressions.
parseNamedText :: Parser a -> String -> String -> Either ParseError a

-- | Parse a Lua file. You can use <tt>parseText chunk</tt> to parse a file
--   from a string.
parseFile :: FilePath -> IO (Either ParseError (Block SourcePos))

-- | Statement parser.
stat :: Parser (Stat SourcePos)

-- | Expression parser.
exp :: Parser (Exp SourcePos)

-- | Lua file parser.
chunk :: Parser (Block SourcePos)
instance Show a => Show (PrimaryExp a)
instance Eq a => Eq (PrimaryExp a)
instance Show a => Show (SuffixExp a)
instance Eq a => Eq (SuffixExp a)
instance Show a => Show (SuffixedExp a)
instance Eq a => Eq (SuffixedExp a)

module Language.Lua.Annotated

-- | Runs Lua lexer before parsing. Use <tt>parseText stat</tt> to parse
--   statements, and <tt>parseText exp</tt> to parse expressions.
parseText :: Parser a -> String -> Either ParseError a

-- | Runs Lua lexer before parsing. Use <tt>parseNamedText stat "name"</tt>
--   to parse statements, and <tt>parseText exp "name"</tt> to parse
--   expressions.
parseNamedText :: Parser a -> String -> String -> Either ParseError a

-- | Parse a Lua file. You can use <tt>parseText chunk</tt> to parse a file
--   from a string.
parseFile :: FilePath -> IO (Either ParseError (Block SourcePos))

-- | Statement parser.
stat :: Parser (Stat SourcePos)

-- | Expression parser.
exp :: Parser (Exp SourcePos)

-- | Lua file parser.
chunk :: Parser (Block SourcePos)


-- | Lua 5.2 syntax tree, as specified in
--   <a>http://www.lua.org/manual/5.2/manual.html#9</a>.
module Language.Lua.Syntax
type Name = String
data Stat

-- | var1, var2 .. = exp1, exp2 ..
Assign :: [Var] -> [Exp] -> Stat

-- | function call
FunCall :: FunCall -> Stat

-- | label for goto
Label :: Name -> Stat

-- | break
Break :: Stat

-- | goto label
Goto :: Name -> Stat

-- | do .. end
Do :: Block -> Stat

-- | while .. do .. end
While :: Exp -> Block -> Stat

-- | repeat .. until ..
Repeat :: Block -> Exp -> Stat

-- | if .. then .. [elseif ..] [else ..] end
If :: [(Exp, Block)] -> (Maybe Block) -> Stat

-- | for x=start, end [, step] do .. end
ForRange :: Name -> Exp -> Exp -> (Maybe Exp) -> Block -> Stat

-- | for x in .. do .. end
ForIn :: [Name] -> [Exp] -> Block -> Stat

-- | function &lt;var&gt; (..) .. end
FunAssign :: FunName -> FunBody -> Stat

-- | local function &lt;var&gt; (..) .. end
LocalFunAssign :: Name -> FunBody -> Stat

-- | local var1, var2 .. = exp1, exp2 ..
LocalAssign :: [Name] -> (Maybe [Exp]) -> Stat

-- | <i>;</i>
EmptyStat :: Stat
data Exp
Nil :: Exp
Bool :: Bool -> Exp
Number :: String -> Exp
String :: String -> Exp

-- | <i>...</i>
Vararg :: Exp

-- | <i>function (..) .. end</i>
EFunDef :: FunBody -> Exp
PrefixExp :: PrefixExp -> Exp

-- | table constructor
TableConst :: [TableField] -> Exp

-- | binary operators, <i>+ - * ^ % .. <a>&lt;=</a> &gt;= == ~= and or</i>
Binop :: Binop -> Exp -> Exp -> Exp

-- | unary operators, <i>- not #</i>
Unop :: Unop -> Exp -> Exp
data Var

-- | variable
VarName :: Name -> Var

-- | <i>table[exp]</i>
Select :: PrefixExp -> Exp -> Var

-- | <i>table.variable</i>
SelectName :: PrefixExp -> Name -> Var
data Binop
Add :: Binop
Sub :: Binop
Mul :: Binop
Div :: Binop
Exp :: Binop
Mod :: Binop
Concat :: Binop
LT :: Binop
LTE :: Binop
GT :: Binop
GTE :: Binop
EQ :: Binop
NEQ :: Binop
And :: Binop
Or :: Binop
data Unop
Neg :: Unop
Not :: Unop
Len :: Unop
data PrefixExp
PEVar :: Var -> PrefixExp
PEFunCall :: FunCall -> PrefixExp
Paren :: Exp -> PrefixExp
data TableField

-- | <i>[exp] = exp</i>
ExpField :: Exp -> Exp -> TableField

-- | <i>name = exp</i>
NamedField :: Name -> Exp -> TableField
Field :: Exp -> TableField

-- | A block is list of statements with optional return statement.
data Block
Block :: [Stat] -> (Maybe [Exp]) -> Block
data FunName
FunName :: Name -> [Name] -> (Maybe Name) -> FunName
data FunBody

-- | (args, vararg, block)
FunBody :: [Name] -> Bool -> Block -> FunBody
data FunCall

-- | <i>prefixexp ( funarg )</i>
NormalFunCall :: PrefixExp -> FunArg -> FunCall

-- | <i>prefixexp : name ( funarg )</i>
MethodCall :: PrefixExp -> Name -> FunArg -> FunCall
data FunArg

-- | list of args
Args :: [Exp] -> FunArg

-- | table constructor
TableArg :: [TableField] -> FunArg

-- | string
StringArg :: String -> FunArg
instance Typeable Binop
instance Typeable Unop
instance Typeable FunName
instance Typeable FunArg
instance Typeable TableField
instance Typeable Exp
instance Typeable FunBody
instance Typeable Block
instance Typeable Stat
instance Typeable FunCall
instance Typeable PrefixExp
instance Typeable Var
instance Show Binop
instance Eq Binop
instance Data Binop
instance Generic Binop
instance Show Unop
instance Eq Unop
instance Data Unop
instance Generic Unop
instance Show FunName
instance Eq FunName
instance Data FunName
instance Generic FunName
instance Show FunArg
instance Eq FunArg
instance Data FunArg
instance Generic FunArg
instance Show TableField
instance Eq TableField
instance Data TableField
instance Generic TableField
instance Show Exp
instance Eq Exp
instance Data Exp
instance Generic Exp
instance Show FunBody
instance Eq FunBody
instance Data FunBody
instance Generic FunBody
instance Show Block
instance Eq Block
instance Data Block
instance Generic Block
instance Show Stat
instance Eq Stat
instance Data Stat
instance Generic Stat
instance Show FunCall
instance Eq FunCall
instance Data FunCall
instance Generic FunCall
instance Show PrefixExp
instance Eq PrefixExp
instance Data PrefixExp
instance Generic PrefixExp
instance Show Var
instance Eq Var
instance Data Var
instance Generic Var
instance Datatype D1Binop
instance Constructor C1_0Binop
instance Constructor C1_1Binop
instance Constructor C1_2Binop
instance Constructor C1_3Binop
instance Constructor C1_4Binop
instance Constructor C1_5Binop
instance Constructor C1_6Binop
instance Constructor C1_7Binop
instance Constructor C1_8Binop
instance Constructor C1_9Binop
instance Constructor C1_10Binop
instance Constructor C1_11Binop
instance Constructor C1_12Binop
instance Constructor C1_13Binop
instance Constructor C1_14Binop
instance Datatype D1Unop
instance Constructor C1_0Unop
instance Constructor C1_1Unop
instance Constructor C1_2Unop
instance Datatype D1FunName
instance Constructor C1_0FunName
instance Datatype D1FunArg
instance Constructor C1_0FunArg
instance Constructor C1_1FunArg
instance Constructor C1_2FunArg
instance Datatype D1TableField
instance Constructor C1_0TableField
instance Constructor C1_1TableField
instance Constructor C1_2TableField
instance Datatype D1Exp
instance Constructor C1_0Exp
instance Constructor C1_1Exp
instance Constructor C1_2Exp
instance Constructor C1_3Exp
instance Constructor C1_4Exp
instance Constructor C1_5Exp
instance Constructor C1_6Exp
instance Constructor C1_7Exp
instance Constructor C1_8Exp
instance Constructor C1_9Exp
instance Datatype D1FunBody
instance Constructor C1_0FunBody
instance Datatype D1Block
instance Constructor C1_0Block
instance Datatype D1Stat
instance Constructor C1_0Stat
instance Constructor C1_1Stat
instance Constructor C1_2Stat
instance Constructor C1_3Stat
instance Constructor C1_4Stat
instance Constructor C1_5Stat
instance Constructor C1_6Stat
instance Constructor C1_7Stat
instance Constructor C1_8Stat
instance Constructor C1_9Stat
instance Constructor C1_10Stat
instance Constructor C1_11Stat
instance Constructor C1_12Stat
instance Constructor C1_13Stat
instance Constructor C1_14Stat
instance Datatype D1FunCall
instance Constructor C1_0FunCall
instance Constructor C1_1FunCall
instance Datatype D1PrefixExp
instance Constructor C1_0PrefixExp
instance Constructor C1_1PrefixExp
instance Constructor C1_2PrefixExp
instance Datatype D1Var
instance Constructor C1_0Var
instance Constructor C1_1Var
instance Constructor C1_2Var
instance NFData FunArg
instance NFData FunCall
instance NFData FunBody
instance NFData FunName
instance NFData Block
instance NFData TableField
instance NFData PrefixExp
instance NFData Unop
instance NFData Binop
instance NFData Var
instance NFData Exp
instance NFData Stat


-- | Lua pretty-printer.
module Language.Lua.PrettyPrinter

-- | This is the default pretty printer which is used by <a>show</a>,
--   <a>putDoc</a> and <a>hPutDoc</a>. <tt>(renderPretty ribbonfrac width
--   x)</tt> renders document <tt>x</tt> with a page width of
--   <tt>width</tt> and a ribbon width of <tt>(ribbonfrac * width)</tt>
--   characters. The ribbon width is the maximal amount of non-indentation
--   characters on a line. The parameter <tt>ribbonfrac</tt> should be
--   between <tt>0.0</tt> and <tt>1.0</tt>. If it is lower or higher, the
--   ribbon width will be 0 or <tt>width</tt> respectively.
renderPretty :: Float -> Int -> Doc -> SimpleDoc

-- | <tt>(displayS simpleDoc)</tt> takes the output <tt>simpleDoc</tt> from
--   a rendering function and transforms it to a <a>ShowS</a> type (for use
--   in the <a>Show</a> class).
--   
--   <pre>
--   showWidth :: Int -&gt; Doc -&gt; String
--   showWidth w x   = displayS (renderPretty 0.4 w x) ""
--   </pre>
displayS :: SimpleDoc -> ShowS

-- | <tt>(displayIO handle simpleDoc)</tt> writes <tt>simpleDoc</tt> to the
--   file handle <tt>handle</tt>. This function is used for example by
--   <a>hPutDoc</a>:
--   
--   <pre>
--   hPutDoc handle doc  = displayIO handle (renderPretty 0.4 100 doc)
--   </pre>
displayIO :: Handle -> SimpleDoc -> IO ()
class LPretty a where pprint = pprint' 0 pprint' _ = pprint
pprint :: LPretty a => a -> Doc
instance LPretty Stat
instance LPretty FunArg
instance LPretty FunCall
instance LPretty FunBody
instance LPretty FunName
instance LPretty Block
instance LPretty TableField
instance LPretty [TableField]
instance LPretty PrefixExp
instance LPretty Unop
instance LPretty Binop
instance LPretty Var
instance LPretty Exp
instance LPretty Bool
instance LPretty [Char]


-- | Remove annotations.
module Language.Lua.Annotated.Simplify
sName :: Name a -> Name
sStat :: Stat a -> Stat
sExp :: Exp a -> Exp
sBlock :: Block a -> Block
sVar :: Var a -> Var
sFunCall :: FunCall a -> FunCall
sFunName :: FunName a -> FunName
sFunBody :: FunBody a -> FunBody
sFunDef :: FunDef a -> FunBody
sPrefixExp :: PrefixExp a -> PrefixExp
sTable :: Table a -> [TableField]
sBinop :: Binop a -> Binop
sUnop :: Unop a -> Unop
sFunArg :: FunArg a -> FunArg
sTableField :: TableField a -> TableField

module Language.Lua.Parser

-- | Runs Lua lexer before parsing. Use <tt>parseText stat</tt> to parse
--   statements, and <tt>parseText exp</tt> to parse expressions.
parseText :: Parser a -> String -> Either ParseError a

-- | Runs Lua lexer before parsing. Use <tt>parseNamedText stat "name"</tt>
--   to parse statements, and <tt>parseText exp "name"</tt> to parse
--   expressions.
parseNamedText :: Parser a -> String -> String -> Either ParseError a
parseFile :: FilePath -> IO (Either ParseError Block)
stat :: Parser Stat
exp :: Parser Exp
chunk :: Parser Block

module Language.Lua

-- | Runs Lua lexer before parsing. Use <tt>parseText stat</tt> to parse
--   statements, and <tt>parseText exp</tt> to parse expressions.
parseText :: Parser a -> String -> Either ParseError a

-- | Runs Lua lexer before parsing. Use <tt>parseNamedText stat "name"</tt>
--   to parse statements, and <tt>parseText exp "name"</tt> to parse
--   expressions.
parseNamedText :: Parser a -> String -> String -> Either ParseError a
parseFile :: FilePath -> IO (Either ParseError Block)
stat :: Parser Stat
exp :: Parser Exp
chunk :: Parser Block
pprint :: LPretty a => a -> Doc
