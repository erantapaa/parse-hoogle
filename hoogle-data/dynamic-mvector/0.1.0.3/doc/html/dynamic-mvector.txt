-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A wrapper around MVector that enables pushing, popping and extending.
--   
@package dynamic-mvector
@version 0.1.0.3


-- | A wrapper around MVector that enables pushing, popping and extending.
module Data.Vector.Mutable.Dynamic

-- | Mutable vector with dynamic behaviour living in the ST or IO monad.
data MVector s a
type STVector = MVector
type IOVector = MVector RealWorld

-- | Create a new vector of given length. The elements are uninitialized
--   and throw error upon accessing. The <a>Int</a> argument must be
--   positive.
new :: PrimMonad m => Int -> m (MVector (PrimState m) a)

-- | Returns a vector consisting of a value repeated the given times.
--   Throws an error if the <a>Int</a> argument is negative.
replicate :: PrimMonad m => Int -> a -> m (MVector (PrimState m) a)

-- | <a>New</a> with the <a>Int</a> argument unchecked.
unsafeNew :: PrimMonad m => Int -> m (MVector (PrimState m) a)

-- | Replicate without checking the <a>Int</a> argument.
unsafeReplicate :: PrimMonad m => Int -> a -> m (MVector (PrimState m) a)

-- | Read a value from a location. Preforms bounds checking.
read :: PrimMonad m => MVector (PrimState m) a -> Int -> m a

-- | Write a value to a location. Performs bounds checking.
write :: PrimMonad m => MVector (PrimState m) a -> Int -> a -> m ()

-- | Read the front value. Throws an error if the vector is empty.
readFront :: PrimMonad m => MVector (PrimState m) a -> m a

-- | Read the back value. Throws an error if the vector is empty.
readBack :: PrimMonad m => MVector (PrimState m) a -> m a

-- | Read without bounds checking.
unsafeRead :: PrimMonad m => MVector (PrimState m) a -> Int -> m a

-- | Write without bounds checking.
unsafeWrite :: PrimMonad m => MVector (PrimState m) a -> Int -> a -> m ()

-- | Read the front value without checking.
unsafeReadFront :: PrimMonad m => MVector (PrimState m) a -> m a

-- | Read the back value without checking.
unsafeReadBack :: PrimMonad m => MVector (PrimState m) a -> m a

-- | Set all the elements to a value.
set :: PrimMonad m => MVector (PrimState m) a -> a -> m ()

-- | Create an immutable copy of the vector.
freeze :: PrimMonad m => MVector (PrimState m) a -> m (Vector a)

-- | Create a mutable copy from an immutable vector.
thaw :: PrimMonad m => Vector a -> m (MVector (PrimState m) a)

-- | Apply a function to an immutable copy of the vector.
frozen :: PrimMonad m => MVector (PrimState m) a -> (Vector a -> b) -> m b

-- | Convert a mutable vector to an immutable one without copying. The
--   mutable vector shouldn't be accessed afterwards.
unsafeFreeze :: PrimMonad m => MVector (PrimState m) a -> m (Vector a)

-- | Convert an immutable vector to a mutable one wihout copying.
unsafeThaw :: PrimMonad m => Vector a -> m (MVector (PrimState m) a)

-- | Apply a function to the vector recast as immutable. This is usually
--   unsafe if we later modify the vector.
unsafeFrozen :: PrimMonad m => MVector (PrimState m) a -> (Vector a -> b) -> m b

-- | Number of elements in the vector.
length :: PrimMonad m => MVector (PrimState m) a -> m Int

-- | Check whether the vector is empty.
null :: PrimMonad m => MVector (PrimState m) a -> m Bool

-- | Number of elements that the vector currently have reserved space for.
capacity :: PrimMonad m => MVector (PrimState m) a -> m Int

-- | Create a copy from a mutable vector.
clone :: PrimMonad m => MVector (PrimState m) a -> m (MVector (PrimState m) a)

-- | Move the contents of the right vector to the left one. Inputs must
--   have the same length and must not overlap.
copy :: PrimMonad m => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | Move the contents of the right vector to the left one. The vectors
--   must be the same length but may overlap.
move :: PrimMonad m => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | Copy the contents of the right vector to the left one without checking
--   length and overlapping.
unsafeCopy :: PrimMonad m => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | Move the contents of the right vector to the left one. The vectors
--   must have the same length and may overlap. Input lengths are
--   unchecked.
unsafeMove :: PrimMonad m => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()

-- | Clear the vector of its contents, setting its length to 0.
clear :: PrimMonad m => MVector (PrimState m) a -> m ()

-- | Ensure that an amount of capacity is reserved in the vector. A no-op
--   if there is already enough capacity. Throws an error if the argument
--   is negative.
reserve :: PrimMonad m => MVector (PrimState m) a -> Int -> m ()

-- | Ensure that an amount of capacity is reserved in the vector. A no-op
--   if there is already enough capacity. The argument is unchecked.
unsafeReserve :: PrimMonad m => MVector (PrimState m) a -> Int -> m ()

-- | Set reserved capacity to 0.
trim :: PrimMonad m => MVector (PrimState m) a -> m ()

-- | Increment the size of the vector and write a value to the back.
--   Pushing to a slice will potentially overwrite the original vector's
--   elements.
pushBack :: PrimMonad m => MVector (PrimState m) a -> a -> m ()

-- | Read the back value and remove it from the vector. Throws an error if
--   the vector is empty.
popBack :: PrimMonad m => MVector (PrimState m) a -> m a

-- | Read the back value and remove it from the vector, without checking.
unsafePopBack :: PrimMonad m => MVector (PrimState m) a -> m a

-- | Extend the vector on the left with the elements of the vector on
--   right. | Extending a slice will potentially overwrite the original
--   vector's elements.
extend :: PrimMonad m => MVector (PrimState m) a -> MVector (PrimState m) a -> m ()
instance Typeable MVectorData
instance Typeable MVector
