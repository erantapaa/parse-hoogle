-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Kansas Lava is a hardware simulator and VHDL generator.
--   
@package kansas-lava
@version 0.2.4.3


-- | This implementation of the Stream data type. It's defined similarly to
--   other implementation of infinite streams found on hackage, except the
--   elements of the stream are strict to prevent some space leaks.
module Language.KansasLava.Stream

-- | Set the precedence of infix <a>Cons</a>.
--   
--   A stream is an infinite sequence of values.
data Stream a

-- | Cons takes a head and an optional tail. If the tail is empty, then the
--   last value is repeated.
Cons :: !a -> (Maybe (Stream a)) -> Stream a

-- | Lift a value to be a constant stream. repeat :: a -&gt; Stream a
--   repeat a = a <a>Cons</a> repeat a
--   
--   Zip two streams together.
zipWith :: (a -> b -> c) -> Stream a -> Stream b -> Stream c

-- | Zip three streams together.
zipWith3 :: (a -> b -> c -> d) -> Stream a -> Stream b -> Stream c -> Stream d

-- | Convert a list to a stream. If the list is finite, then the last
--   element of the stream will be an error.
fromFiniteList :: [a] -> a -> Stream a
fromList :: [a] -> Stream a

-- | Convert a Stream to a lazy list.
toList :: Stream a -> [a]
observeStream :: Show a => String -> Stream a -> Stream a
instance Typeable Stream
instance Traversable Stream
instance Foldable Stream
instance Functor Stream
instance Applicative Stream
instance Show a => Show (Stream a)


-- | This module contains the key internal types for Kansas Lava, and some
--   basic utilities (like Show instances) for these types.
module Language.KansasLava.Types

-- | Type captures HDL-representable types.
data Type

-- | Bit
B :: Type

-- | Signed vector, with a width.
S :: Int -> Type

-- | Unsigned vector, with a width.
U :: Int -> Type

-- | std_logic_vector, with a width.
V :: Int -> Type

-- | Clock Signal
ClkTy :: Type

-- | generics in VHDL, argument must be integer
GenericTy :: Type

-- | a constant array of values.
RomTy :: Int -> Type

-- | Tuple, represented as a larger std_logic_vector
TupleTy :: [Type] -> Type

-- | Matrix, for example a vhdl array.
MatrixTy :: Int -> Type -> Type

-- | Our "floating" values. The first number is the precision<i>scale
--   (+</i>- N) The second number is the bits used to represent this number
SampledTy :: Int -> Int -> Type

-- | <a>typeWidth</a> returns the width of a type when represented in VHDL.
typeWidth :: Type -> Int

-- | <a>isTypeSigned</a> determines if a type has a signed representation.
--   This is necessary for the implementation of <tt>isSigned</tt> in the
--   <tt>Bits</tt> type class.
isTypeSigned :: Type -> Bool

-- | <a>StdLogicType</a> is the type for std_logic things, typically
--   input/output arguments to VHDL entities.
data StdLogicType

-- | std_logic
SL :: StdLogicType

-- | std_logic_vector (n-1 downto 0)
SLV :: Int -> StdLogicType

-- | std_logic_vector (n-1 downto 0) (m-1 downto 0)
SLVA :: Int -> Int -> StdLogicType

-- | generic (inward) argument
G :: StdLogicType

-- | toStdLogic maps Lava Types to a StdLogicType
toStdLogicType :: Type -> StdLogicType

-- | fromStdLogic maps StdLogicTypes to Lava types.
fromStdLogicType :: StdLogicType -> Type

-- | Id is the name/tag of a block of compuation.
data Id

-- | built in thing
Prim :: String -> Id

-- | VHDL entity
External :: String -> Id

-- | anonymous function
Function :: [(RepValue, RepValue)] -> Id

-- | An environment box
ClockId :: String -> Id

-- | An identity; also a multi-line comments
Comment :: [String] -> Id

-- | <a>BlackBox</a> can be removed without harm The rule is you can only
--   insert you own types in here (or use newtype). Prelude or other
--   peoples types are not allowed (because typecase becomes ambigious)
BlackBox :: (Box Dynamic) -> Id

-- | Box wraps a dynamic, so that we can define custom Eq/Ord instances.
newtype Box a
Box :: a -> Box a

-- | An <a>Entity</a> Entity is our central <a>BOX</a> of computation,
--   round an <a>Id</a>.
data Entity s
Entity :: Id -> [(String, Type)] -> [(String, Type, Driver s)] -> Entity s

-- | <a>E</a> is the knot-tyed version of Entity.
newtype E
E :: (Entity E) -> E

-- | entityFind finds an input in a list, avoiding the need to have
--   ordering.
entityFind :: Show a => String -> Entity a -> (Type, Driver a)

-- | A <a>Driver</a> is a specific driven <tt>wire</tt> (signal in VHDL),
--   which types contains a value that changes over time.
data Driver s

-- | a specific port on the entity
Port :: String -> s -> Driver s

-- | an input pad
Pad :: String -> Driver s

-- | the clock domain (the clock enable, resolved via context)
ClkDom :: String -> Driver s

-- | A representable Value (including unknowns, aka X in VHDL)
Lit :: RepValue -> Driver s

-- | A generic argument, always fully defined
Generic :: Integer -> Driver s

-- | A list of values, typically constituting a ROM initialization.
Lits :: [RepValue] -> Driver s

-- | A call to err, in Datatype format for reification purposes
Error :: String -> Driver s

-- | The <a>D</a> type adds a phantom type to a driver.
newtype D a
D :: Driver E -> D a
unD :: D a -> Driver E

-- | class <a>Clock</a> is a type that can be be used to represent a clock.
class Clock clk

-- | generic<i>default</i>board<i>standard</i>vanilla clock.
data CLK

-- | A RepValue is a value that can be represented using a bit encoding.
--   The least significant bit is at the front of the list.
newtype RepValue
RepValue :: [Maybe Bool] -> RepValue
unRepValue :: RepValue -> [Maybe Bool]
showRepValue :: Type -> RepValue -> String

-- | <a>appendRepValue</a> joins two <a>RepValue</a>; the least significant
--   value first. TODO: reverse this!
appendRepValue :: RepValue -> RepValue -> RepValue

-- | <a>isValidRepValue</a> checks to see is a <a>RepValue</a> is
--   completely valid.
isValidRepValue :: RepValue -> Bool

-- | <a>getValidRepValue</a> Returns a binary rep, or Nothing is *any* bits
--   are <tt>X</tt>.
getValidRepValue :: RepValue -> Maybe [Bool]

-- | <a>chooseRepValue</a> turns a RepValue with (optional) unknow values,
--   and chooses a representation for the RepValue.
chooseRepValue :: RepValue -> RepValue

-- | <a>cmpRepValue</a> compares a golden value with another value,
--   returning the bits that are different. The first value may contain
--   <tt>X</tt>, in which case *any* value in that bit location will match.
--   This means that <a>cmpRepValue</a> is not commutative.
cmpRepValue :: RepValue -> RepValue -> Bool
data BitPat w
BitPat :: RepValue -> BitPat w
bitPatToRepValue :: BitPat w -> RepValue

-- | <a>&amp;</a> is a sized append for BitPat.
(&) :: (Size w1, Size w2, Size w, w ~ ADD w1 w2, w1 ~ SUB w w2, w2 ~ SUB w w1) => BitPat w1 -> BitPat w2 -> BitPat w
bits :: String -> BitPat w
bool :: BitPat X1 -> Bool
every :: Size w => [BitPat w]
bitPatToInteger :: BitPat w -> Maybe Integer

-- | <a>KLEG</a> (Kansas Lava Entity Graph) is our primary way of
--   representing a graph of entities.
data KLEG
KLEG :: [(Unique, Entity Unique)] -> [(String, Type)] -> [(String, Type, Driver Unique)] -> KLEG

-- | This the main graph. There is no actual node for the source or sink.
theCircuit :: KLEG -> [(Unique, Entity Unique)]

-- | this is a (convenience) list of the src values.
theSrcs :: KLEG -> [(String, Type)]

-- | these are the sinks; all values are generated from here.
theSinks :: KLEG -> [(String, Type, Driver Unique)]

-- | Map a function across all of the entities in a KLEG, accumulating the
--   results in a list.
visitEntities :: KLEG -> (Unique -> Entity Unique -> Maybe a) -> [a]

-- | Map a function across a KLEG, modifying each Entity for which the
--   function returns a Just. Any entities that the function returns
--   Nothing for will be removed from the resulting KLEG.
mapEntities :: KLEG -> (Unique -> Entity Unique -> Maybe (Entity Unique)) -> KLEG

-- | Generate a list of Unique ids that are guaranteed not to conflict with
--   any ids already in the KLEG.
allocEntities :: KLEG -> [Unique]

-- | A <a>Signature</a> is the structure-level type of a KLEG.
data Signature
Signature :: [(String, Type)] -> [(String, Type)] -> [(String, Integer)] -> Signature
sigInputs :: Signature -> [(String, Type)]
sigOutputs :: Signature -> [(String, Type)]
sigGenerics :: Signature -> [(String, Integer)]

-- | Calculate a signature from a KLEG.
circuitSignature :: KLEG -> Signature

-- | Create a type witness, to help resolve some of the type issues.
--   Really, we are using this in a system-F style. (As suggested by an
--   anonymous TFP referee, as a better alternative to using 'error
--   "witness"').
data Witness w
Witness :: Witness w

-- | Select the shallow embedding from one circuit, and the deep embedding
--   from another.
class Dual a
dual :: Dual a => a -> a -> a

-- | Alternative definition for (,). Constructor is right-associative.
data (:>) a b
(:>) :: a -> b -> (:>) a b

-- | How to balance our circuits. Typically use <a>Sweet</a>(spot), but
--   <a>Small</a> has permission to take longer, and <a>Fast</a> has
--   permission use extra gates.
data Synthesis
Small :: Synthesis
Sweet :: Synthesis
Fast :: Synthesis
instance Eq Type
instance Ord Type
instance Eq StdLogicType
instance Ord StdLogicType
instance Eq RepValue
instance Ord RepValue
instance Eq s => Eq (Driver s)
instance Ord s => Ord (Driver s)
instance Eq Id
instance Ord Id
instance Show s => Show (Entity s)
instance Eq s => Eq (Entity s)
instance Ord s => Ord (Entity s)
instance Show (D a)
instance Eq (BitPat w)
instance Ord (BitPat w)
instance Show (BitPat w)
instance Show Signature
instance Read Signature
instance Eq Signature
instance (Eq a, Eq b) => Eq (a :> b)
instance (Ord a, Ord b) => Ord (a :> b)
instance (Show a, Show b) => Show (a :> b)
instance (Read a, Read b) => Read (a :> b)
instance Dual b => Dual (a -> b)
instance (Dual a, Dual b, Dual c) => Dual (a, b, c)
instance (Dual a, Dual b) => Dual (a, b)
instance Show KLEG
instance IsString (BitPat w)
instance Size w => Integral (BitPat w)
instance Size w => Enum (BitPat w)
instance Size w => Real (BitPat w)
instance Size w => Num (BitPat w)
instance Read RepValue
instance Show RepValue
instance Clock CLK
instance Functor Driver
instance Foldable Driver
instance Traversable Driver
instance Show i => Show (Driver i)
instance Eq E
instance Show E
instance MuRef E
instance Functor Entity
instance Foldable Entity
instance Traversable Entity
instance Ord (Box a)
instance Eq (Box a)
instance Show Id
instance Show StdLogicType
instance Read Type
instance Show Type


-- | Convert a reified Lava <a>KLEG</a> into a graphical Graphviz format.
module Language.KansasLava.DOT

-- | The <a>writeDotCircuit</a> function converts a Lava circuit into a
--   graphviz output.
writeDotCircuit :: FilePath -> KLEG -> IO ()


-- | The Optimization module performs a number of safe optimizations, such
--   as copy elimination, CSE, and combinatorial identity artifacts: e.g.
--   fst(x,y)--&gt;x. The optimizer is *supposed* to be timing invariant;
--   however, it may change circuit properties such as fanout.
module Language.KansasLava.Optimization

-- | Basic optimizations, and assumes reaching a fixpoint. Cleans things
--   up, but does not work too hard, because the VHDL compiler get many of
--   the combinatorial optimizations anyway.
optimizeCircuit :: OptimizationOpts -> KLEG -> IO KLEG

-- | Data structure for passing optimization parameters.
data OptimizationOpts
OptimizationOpts :: Int -> OptimizationOpts
optDebugLevel :: OptimizationOpts -> Int
instance Default OptimizationOpts
instance Monad Opt
instance Applicative Opt
instance Functor Opt


-- | KansasLava is designed for generating hardware circuits. This module
--   provides a <a>Rep</a> class that allows us to model, in the shallow
--   embedding of KL, two important features of hardware signals. First,
--   all signals must have some static width, as they will be synthsized to
--   a collection of hardware wires. Second, a value represented by a
--   signal may be unknown, in part or in whole.
module Language.KansasLava.Rep

-- | Check to see if all bits in a bitvector (represented as a Matrix) are
--   valid. Returns Nothing if any of the bits are unknown.
allOkayRep :: Size w => Matrix w (X Bool) -> Maybe (Matrix w Bool)

-- | Integers are unbounded in size. We use the type <a>IntegerWidth</a> as
--   the associated type representing this size in the instance of Rep for
--   Integers.
data IntegerWidth
IntegerWidth :: IntegerWidth

-- | Calculate the base-2 logrithim of a integral value.
log2 :: Integral a => a -> a

-- | This is a version of fromRepToIntegral that check to see if the result
--   is inside the size bounds.
sizedFromRepToIntegral :: (Rep w, Integral w, Size w) => RepValue -> X w
repIntegral :: Name -> Type -> Q [Dec]
repBitRep :: Name -> Int -> Q [Dec]

-- | A 'Rep a' is an <tt>a</tt> value that we <a>Rep</a>resent, aka we can
--   push it over a wire. The general idea is that instances of Rep should
--   have a width (for the corresponding bitvector representation) and that
--   Rep instances should be able to represent the "unknown" -- X -- value.
--   For example, Bools can be represented with one bit, and the inclusion
--   of the unknown X value corresponds to three-valued logic.
class Rep w where type family W w data family X w showRep x = showRepValue (repType (Witness :: Witness w)) (toRep x)
unX :: Rep w => X w -> Maybe w
optX :: Rep w => Maybe w -> X w
toRep :: Rep w => X w -> RepValue
fromRep :: Rep w => RepValue -> X w
repType :: Rep w => Witness w -> Type
showRep :: Rep w => X w -> String

-- | <tt>Bitrep</tt> is list of values, and their bitwise representation.
--   It is used to derive (via Template Haskell) the Rep for user Haskell
--   datatypes.
class (Size (W a), Eq a, Rep a) => BitRep a
bitRep :: BitRep a => [(a, BitPat (W a))]

-- | Given a witness of a representable type, generate all (2^n) possible
--   values of that type.
allReps :: Rep w => Witness w -> [RepValue]

-- | Figure out the width in bits of a type.
repWidth :: Rep w => Witness w -> Int

-- | unknownRepValue returns a RepValue that is completely filled with
--   <a>X</a>.
unknownRepValue :: Rep w => Witness w -> RepValue

-- | pureX lifts a value to a (known) representable value.
pureX :: Rep w => w -> X w

-- | unknownX is an unknown value of every representable type.
unknownX :: Rep w => X w

-- | liftX converts a function over values to a function over possibly
--   unknown values.
liftX :: (Rep a, Rep b) => (a -> b) -> X a -> X b

-- | showRepDefault will print a Representable value, with "?" for unknown.
--   This is not wired into the class because of the extra <a>Show</a>
--   requirement.
showRepDefault :: (Show w, Rep w) => X w -> String

-- | Convert an integral value to a RepValue -- its bitvector
--   representation.
toRepFromIntegral :: (Rep v, Integral v) => X v -> RepValue

-- | Convert a RepValue representing an integral value to a representable
--   value of that integral type.
fromRepToIntegral :: (Rep v, Integral v) => RepValue -> X v

-- | fromRepToInteger always a positve number, unknowns defin
fromRepToInteger :: RepValue -> Integer

-- | Compare a golden value with a generated value.
cmpRep :: Rep a => X a -> X a -> Bool

-- | Helper for generating the bit pattern mappings.
bitRepEnum :: (Rep a, Enum a, Bounded a, Size (W a)) => [(a, BitPat (W a))]
bitRepToRep :: (BitRep w, Ord w) => X w -> RepValue
bitRepToRep' :: (BitRep w, Ord w) => Map w RepValue -> X w -> RepValue
bitRepFromRep :: (Ord w, BitRep w) => RepValue -> X w
bitRepFromRep' :: (Ord w, BitRep w) => Map RepValue w -> RepValue -> X w
bitRepMap :: (BitRep w, Ord w) => Map RepValue w
expandBitRep :: RepValue -> [RepValue]
instance (Enum ix, Size m, Size ix) => Rep (Sampled m ix)
instance (Integral x, Size x) => Rep (X1_ x)
instance (Integral x, Size x) => Rep (X0_ x)
instance Rep X0
instance (Size ix, Rep a, Rep ix) => Rep (ix -> a)
instance Size ix => Rep (Signed ix)
instance Size ix => Rep (Unsigned ix)
instance (Size ix, Rep a) => Rep (Matrix ix a)
instance Rep a => Rep (Maybe a)
instance (Rep a, Rep b, Rep c) => Rep (a, b, c)
instance (Rep a, Rep b) => Rep (a, b)
instance (Rep a, Rep b) => Rep (a :> b)
instance Rep Integer
instance Rep ()
instance Rep Word32
instance Rep Word8
instance Rep Int
instance Rep Bool


-- | The Signal module serves as a representation for the combined shallow
--   and deep embeddings of sequential circuits. The shallow portion is
--   reprented as a stream, the deep portion as a (typed) entity. To allow
--   for multiple clock domains, the Signal type includes an extra type
--   parameter. The type alias <a>Seq</a> is for sequential logic in some
--   implicit global clock domain.
module Language.KansasLava.Signal

-- | These are sequences of values over time. We assume edge triggered
--   logic (checked at (typically) rising edge of clock) This clock is
--   assumed known, based on who is consuming the list. Right now, it is
--   global, but we think we can support multiple clocks with a bit of
--   work.
data Signal (c :: *) a
Signal :: (Stream (X a)) -> (D a) -> Signal a

-- | Signal in some implicit clock domain.
type Seq a = Signal CLK a

-- | Extract the shallow portion of a <a>Signal</a>.
shallowS :: Signal c a -> Stream (X a)

-- | Extract the deep portion of a <a>Signal</a>.
deepS :: Signal c a -> D a
deepMapS :: (D a -> D a) -> Signal c a -> Signal c a
shallowMapS :: (Stream (X a) -> Stream (X a)) -> Signal c a -> Signal c a

-- | A pure <a>Signal</a>.
pureS :: Rep a => a -> Signal i a

-- | A <a>Signal</a> witness identity function. Useful when typing things.
witnessS :: Rep a => Witness a -> Signal i a -> Signal i a

-- | Inject a deep value into a Signal. The shallow portion of the Signal
--   will be an error, if it is every used.
mkDeepS :: D a -> Signal c a

-- | Inject a shallow value into a Signal. The deep portion of the Signal
--   will be an Error if it is ever used.
mkShallowS :: Clock c => Stream (X a) -> Signal c a

-- | Create a Signal with undefined for both the deep and shallow elements.
undefinedS :: (Rep a, sig ~ Signal clk) => sig a

-- | Attach a comment to a <a>Signal</a>.
commentS :: (Rep a, sig ~ Signal clk) => String -> sig a -> sig a

-- | <a>idS</a> create an identity function, with a given <a>Id</a> tag.
idS :: (Rep a, sig ~ Signal clk) => Id -> sig a -> sig a

-- | create a zero-arity Signal value from an <a>X</a> value.
primXS :: Rep a => X a -> String -> Signal i a

-- | create an arity-1 Signal function from an <a>X</a> function.
primXS1 :: (Rep a, Rep b) => (X a -> X b) -> String -> Signal i a -> Signal i b

-- | create an arity-2 Signal function from an <a>X</a> function.
primXS2 :: (Rep a, Rep b, Rep c) => (X a -> X b -> X c) -> String -> Signal i a -> Signal i b -> Signal i c

-- | create an arity-3 Signal function from an <a>X</a> function.
primXS3 :: (Rep a, Rep b, Rep c, Rep d) => (X a -> X b -> X c -> X d) -> String -> Signal i a -> Signal i b -> Signal i c -> Signal i d

-- | create a zero-arity Signal value from a value.
primS :: Rep a => a -> String -> Signal i a

-- | create an arity-1 Signal function from a function.
primS1 :: (Rep a, Rep b) => (a -> b) -> String -> Signal i a -> Signal i b

-- | create an arity-2 Signal function from a function.
primS2 :: (Rep a, Rep b, Rep c) => (a -> b -> c) -> String -> Signal i a -> Signal i b -> Signal i c

-- | create an arity-3 Signal function from a function.
primS3 :: (Rep a, Rep b, Rep c, Rep d) => (a -> b -> c -> d) -> String -> Signal i a -> Signal i b -> Signal i c -> Signal i d

-- | Convert a list of values into a Signal. The shallow portion of the
--   resulting Signal will begin with the input list, then an infinite
--   stream of X unknowns.
toS :: (Clock c, Rep a) => [a] -> Signal c a

-- | Convert a list of values into a Signal. The input list is wrapped with
--   a Maybe, and any Nothing elements are mapped to X's unknowns.
toS' :: (Clock c, Rep a) => [Maybe a] -> Signal c a

-- | Convert a list of X values to a Signal. Pad the end with an infinite
--   list of X unknowns.
toSX :: (Clock c, Rep a) => [X a] -> Signal c a

-- | Convert a Signal of values into a list of Maybe values.
fromS :: Rep a => Signal c a -> [Maybe a]

-- | Convret a Signal of values into a list of representable values.
fromSX :: Rep a => Signal c a -> [X a]

-- | take the first n elements of a <a>Signal</a>; the rest is undefined.
takeS :: (Rep a, Clock c) => Int -> Signal c a -> Signal c a

-- | Compare the first depth elements of two Signals.
cmpSignalRep :: Rep a => Int -> Signal c a -> Signal c a -> Bool

-- | Return the Lava type of a representable signal.
typeOfS :: (Rep w, sig ~ Signal clk) => sig w -> Type

-- | The Pack class allows us to move between signals containing compound
--   data and signals containing the elements of the compound data. This is
--   done by commuting the signal type constructor with the type
--   constructor representing the compound data. For example, if we have a
--   value x :: Signal sig =&gt; sig (a,b), then 'unpack x' converts this
--   to a (sig a, sig b). Dually, pack takes (sig a,sig b) to sig (a,b).
class Pack clk a where type family Unpacked clk a
pack :: Pack clk a => Unpacked clk a -> Signal clk a
unpack :: Pack clk a => Signal clk a -> Unpacked clk a

-- | Given a function over unpacked (composite) signals, turn it into a
--   function over packed signals.
mapPacked :: (Pack i a, Pack i b, sig ~ Signal i) => (Unpacked i a -> Unpacked i b) -> sig a -> sig b

-- | Lift a binary function operating over unpacked signals into a function
--   over a pair of packed signals.
zipPacked :: (Pack i a, Pack i b, Pack i c, sig ~ Signal i) => (Unpacked i a -> Unpacked i b -> Unpacked i c) -> sig a -> sig b -> sig c
unpackMatrix :: (Rep a, Size x, sig ~ Signal clk) => sig (Matrix x a) -> Matrix x (sig a)
packMatrix :: (Rep a, Size x, sig ~ Signal clk) => Matrix x (sig a) -> sig (Matrix x a)

-- | a delay is a register with no defined default / initial value.
delay :: (Rep a, Clock clk) => Signal clk a -> Signal clk a

-- | delays generates a serial sequence of n delays.
delays :: (Rep a, Clock clk) => Int -> Signal clk a -> Signal clk a

-- | A register is a state element with a reset. The reset is supplied by
--   the clock domain in the Signal.
register :: (Rep a, Clock clk) => a -> Signal clk a -> Signal clk a

-- | registers generates a serial sequence of n registers, all with the
--   same initial value.
registers :: (Rep a, Clock clk) => Int -> a -> Signal clk a -> Signal clk a
entityD :: Rep a => String -> D a
entityD1 :: (Rep a, Rep a1) => String -> D a1 -> D a
entityD2 :: (Rep a, Rep a1, Rep a2) => String -> D a1 -> D a2 -> D a
entityD3 :: (Rep a, Rep a1, Rep a2, Rep a3) => String -> D a1 -> D a2 -> D a3 -> D a
pureD :: Rep a => a -> D a
pureXD :: Rep a => X a -> D a
instance (Rep a, Size ix) => Pack clk (Matrix ix a)
instance Rep a => Pack i (Maybe a)
instance (Rep a, Rep b, Rep c) => Pack i (a, b, c)
instance (Rep a, Rep b) => Pack i (a, b)
instance Dual (Signal c a)
instance (Rep a, Integral a) => Integral (Signal i a)
instance (Rep a, Real a) => Real (Signal i a)
instance (Ord a, Rep a) => Ord (Signal i a)
instance (Rep a, Enum a) => Enum (Signal i a)
instance (Eq a, Show a, Fractional a, Rep a) => Fractional (Signal i a)
instance (Show a, Bits a, Rep a) => Bits (Signal i a)
instance (Bounded a, Rep a) => Bounded (Signal i a)
instance (Num a, Rep a) => Num (Signal i a)
instance (Rep a, Eq a) => Eq (Signal c a)
instance Rep a => Show (Signal c a)


-- | This module contains a number of primitive circuits, and instance
--   definitions for standard type classes for circuits.
module Language.KansasLava.Utils

-- | The <a>Signal</a> representing True.
high :: sig ~ Signal i => sig Bool

-- | The <a>Signal</a> representing False.
low :: sig ~ Signal i => sig Bool

-- | 1-bit and gate.
and2 :: sig ~ Signal i => sig Bool -> sig Bool -> sig Bool

-- | 1-bit or gate.
or2 :: sig ~ Signal i => sig Bool -> sig Bool -> sig Bool

-- | 1-bit xor gate.
xor2 :: sig ~ Signal i => sig Bool -> sig Bool -> sig Bool

-- | 1-bit nand gate.
nand2 :: sig ~ Signal i => sig Bool -> sig Bool -> sig Bool

-- | 1-bit nor gate.
nor2 :: sig ~ Signal i => sig Bool -> sig Bool -> sig Bool

-- | 1 bit inverter.
bitNot :: sig ~ Signal i => sig Bool -> sig Bool

-- | Extract the n'th bit of a signal that can be represented as Bits.
testABit :: (Bits a, Rep a, Size w, Rep w, w ~ (W a), sig ~ Signal i) => sig a -> sig w -> sig Bool

-- | Predicate to see if a Signed value is positive.
isPositive :: (sig ~ Signal i, Size ix, Integral ix, Rep ix) => sig (Signed ix) -> sig Bool

-- | Alias for <a>and2</a>.
(.&&.) :: sig ~ Signal i => sig Bool -> sig Bool -> sig Bool

-- | Alias for <a>or2</a>.
(.||.) :: sig ~ Signal i => sig Bool -> sig Bool -> sig Bool

-- | Alias for <a>xor2</a>.
(.^.) :: sig ~ Signal i => sig Bool -> sig Bool -> sig Bool

-- | Given a function over a finite domain, generate a ROM representing the
--   function. To make this feasible to implement, we assume that the
--   domain is small (&lt; 2^8 values).
funMap :: (sig ~ Signal i, Rep a, Rep b) => (a -> Maybe b) -> sig a -> sig b

-- | Multiplexer with a 1-bit selector and arbitrary width data inputs.
--   zero (false) selects the first argument of the tuple, one (true)
--   selects the second.
mux :: (sig ~ Signal i, Rep a) => sig Bool -> (sig a, sig a) -> sig a

-- | Shallow definition of a multiplexer. Deals with 3-value logic.
muxShallow :: Rep a => X Bool -> X a -> X a -> X a

-- | TODO: Document this. And move it.
eval :: Rep a => a -> ()

-- | TODO: Document this.
evalX :: Rep a => X a -> ()

-- | Alias for <a>.!.</a>
muxMatrix :: (sig ~ Signal i, Size x, Rep x, Rep a) => sig (Matrix x a) -> sig x -> sig a

-- | Extract the n'th element of a vector.
(.!.) :: (sig ~ Signal i, Size x, Rep x, Rep a) => sig (Matrix x a) -> sig x -> sig a

-- | Lift a (named) binary function over bools to be over <a>Signal</a>s.
boolOp :: (Rep a, sig ~ Signal i) => (a -> a -> Bool) -> String -> sig a -> sig a -> sig Bool

-- | N-bit equality.
(.==.) :: (Rep a, Eq a, sig ~ Signal i) => sig a -> sig a -> sig Bool

-- | N-bit not-equals.
(./=.) :: (Rep a, Eq a, sig ~ Signal i) => sig a -> sig a -> sig Bool

-- | N-bit greater-than-or-equals.
(.>=.) :: (Rep a, Ord a, sig ~ Signal i) => sig a -> sig a -> sig Bool

-- | N-bit less-than-or-equals.
(.<=.) :: (Rep a, Ord a, sig ~ Signal i) => sig a -> sig a -> sig Bool

-- | N-bit less-than.
(.<.) :: (Rep a, Ord a, sig ~ Signal i) => sig a -> sig a -> sig Bool

-- | N-bit greater-than.
(.>.) :: (Rep a, Ord a, sig ~ Signal i) => sig a -> sig a -> sig Bool

-- | The identity function, lifted to <a>Signal</a>s.
lavaId :: (sig ~ Signal i, Rep a) => sig a -> sig a

-- | <a>ignoring</a> is used to make sure a value is reified. TODO: is this
--   used?
ignoring :: (sig ~ Signal i, Rep a, Rep b) => sig a -> sig b -> sig a

-- | Given a representable value for a discirminant and a list of input
--   signals, generate a n-ary mux.
cASE :: (Rep b, sig ~ Signal i) => [(sig Bool, sig b)] -> sig b -> sig b

-- | translate using raw underlying bits, Width *must* be the same.
bitwise :: (sig ~ Signal i, Rep a, Rep b, W a ~ W b) => sig a -> sig b

-- | translate using raw underlying bits for deep, but given function for
--   shallow, Width *must* be the same.
coerce :: (sig ~ Signal i, Rep a, Rep b, W a ~ W b) => (a -> b) -> sig a -> sig b

-- | Coerce a value from on type to another, interpreting the bits as a
--   signed value. Do not sign extend.
signedX :: (Rep a, Rep b) => X a -> X b

-- | consider the bits as signed number (sign extend)
signed :: (Rep a, Rep b, Num b, sig ~ Signal i) => sig a -> sig b

-- | Consider the value as an unsigned value.
unsignedX :: (Rep a, Rep b) => X a -> X b

-- | consider the bits an unsigned number (zero extend)
unsigned :: (Rep a, Rep b, Num b, sig ~ Signal i) => sig a -> sig b

-- | force the representation of the incoming argument to be a
--   StdLogicVector. Assumes the argument is an entity; a real hack. We
--   need a type checking pass, instead.
mustAssignSLV :: (Rep a, sig ~ Signal i) => sig a -> sig a

-- | translate using raw underlying bits, type *must* be the same, but is
--   not statically checked.
unsafeId :: (sig ~ Signal i, Rep a, Rep b) => sig a -> sig b

-- | given a signal of a1 + a2 width, yield a signal with a pair of values
--   of width a1 and a2 respectively.
unappendS :: (sig ~ Signal clk, Rep a, Rep a1, Rep a2, W a ~ ADD (W a1) (W a2)) => sig a -> (sig a1, sig a2)

-- | given two signals of a1 and a2 width, respectively, pack them into a
--   signal of a1 + a2 width.
appendS :: (sig ~ Signal clk, Rep a, Rep b, Rep c, W c ~ ADD (W a) (W b)) => sig a -> sig b -> sig c

-- | The first argument is the value is our value under test; the second is
--   our reference value. If the reference is undefined, then the VUT *can*
--   also be under test. This only works for shallow circuits, and is used
--   when creating test benches.
refinesFrom :: (Clock i, sig ~ Signal i, Rep a) => sig a -> sig a -> sig Bool

-- | Create a register, pass the output of the register through some
--   combinational logic, then pass the result back into the register
--   input.
iterateS :: (Rep a, Clock c, seq ~ Signal c) => (forall j. Signal j a -> Signal j a) -> a -> seq a
loopingIncS :: (Bounded a, Eq a, Num a, Rep a, sig ~ Signal i) => sig a -> sig a
loopingDecS :: (Bounded a, Eq a, Num a, Rep a, sig ~ Signal i) => sig a -> sig a


-- | The Fabric module is used for generating a top-level VHDL entity for a
--   Lava circuit, with inputs and outputs.
module Language.KansasLava.Fabric

-- | The <a>Fabric</a> structure, which is also a monad.
--   
--   <pre>
--   fabric_example :: Fabric ()
--   fabric_example = do
--          i0 &lt;- inStdLogic "i0"
--          i1 &lt;- inStdLogic "i1"
--          let (c,s) = halfAdder i0 i1
--          outStdLogic "carry" c
--          outStdLogic "sum" s
--    where
--            halfAdder :: Seq Bool -&gt; Seq Bool -&gt; (Seq Bool,Seq Bool)
--            halfAdder a b = (carry,sum_)
--                  where carry = and2 a b
--                        sum_  = xor2 a b
--   </pre>
--   
--   A Fabric consists of a list of input ports, and yields a list of
--   output ports and generics.
data Fabric a
Fabric :: ([(String, Pad)] -> (a, [(String, Pad)], [(String, Pad)])) -> Fabric a
unFabric :: Fabric a -> [(String, Pad)] -> (a, [(String, Pad)], [(String, Pad)])

-- | A Pad represents the type of a top-level input/output port.
data Pad
StdLogic :: (Seq Bool) -> Pad
StdLogicVector :: (Seq a) -> Pad
GenericPad :: Integer -> Pad
TheClk :: Pad
TheRst :: Pad
TheClkEn :: Pad

-- | Reify a fabric, returning the output ports and the result of the
--   Fabric monad.
runFabric :: Fabric a -> [(String, Pad)] -> (a, [(String, Pad)])

-- | Generate a named std_logic input port.
inStdLogic :: (Rep a, Show a, W a ~ X1) => String -> Fabric (Seq a)

-- | Generate a named std_logic_vector port input.
inStdLogicVector :: (Rep a, Show a, Size (W a)) => String -> Fabric (Seq a)

-- | Generate a named generic.
inGeneric :: String -> Fabric Integer

-- | Generate a named std_logic output port, given a Lava circuit.
outStdLogic :: (Rep a, Show a, W a ~ X1) => String -> Seq a -> Fabric ()

-- | Generate a named std_logic_vector output port, given a Lava circuit.
outStdLogicVector :: (Rep a, Show a, Size (W a)) => String -> Seq a -> Fabric ()

-- | Get the type of a pad.
padStdLogicType :: Pad -> StdLogicType

-- | theClk gives the external name for the clock.
theClk :: String -> Fabric ()

-- | theRst gives the external name for the reset signal [default = low].
theRst :: String -> Fabric ()

-- | theClkEn gives the external name for the clock enable signal [default
--   = high].
theClkEn :: String -> Fabric ()

-- | <a>reifyFabric</a> does reification of a 'Fabric ()' into a
--   <a>KLEG</a>.
reifyFabric :: Fabric () -> IO KLEG

-- | <a>runFabric</a> runs a Fabric a with arguments, and gives a value
--   result. must have no (monadic) outputs.
runFabricWithResult :: Fabric a -> [(String, Pad)] -> a

-- | <a>runFabricWithDriver</a> runs a Fabric () using a driver Fabric.
runFabricWithDriver :: Fabric () -> Fabric a -> a
instance Eq EntityClock
instance Ord EntityClock
instance Show EntityClock
instance Show (ExternalStdLogicVector x)
instance Size ix => Rep (ExternalStdLogicVector ix)
instance MonadFix Fabric
instance Monad Fabric
instance Applicative Fabric
instance Functor Fabric
instance Show Pad


-- | This module contains functions for generating VCD debug traces. It
--   also provides functionality for (de)serializing Traces.
module Language.KansasLava.VCD

-- | <a>VCD</a> is a primary bit-wise record of an interactive session with
--   some circuit Map from module/name to stream.
newtype VCD
VCD :: [(String, VC)] -> VCD

-- | Convert a <a>VCD</a> to a VCD file.
writeVCDFile :: Bool -> Integer -> FilePath -> VCD -> IO ()

-- | Convert a VCD file to a VCD object.
readVCDFile :: FilePath -> Signature -> IO VCD
addEvent :: Rep w => String -> Int -> (X w) -> VCD -> VCD

-- | Generate a signature from a trace. TODO: support generics in both
--   these functions?
toSignature :: VCD -> Signature

-- | Creates an (empty) trace from a signature
fromSignature :: Signature -> VCD

-- | Compare two trace objects. First argument is the golden value. See
--   notes for cmpRepValue
cmpVCD :: VCD -> VCD -> Bool
ioOnly :: VCD -> VCD

-- | Make a <a>VCD</a> from a <a>Fabric</a> and its input.
mkVCD :: Int -> Fabric () -> [(String, Pad)] -> IO VCD

-- | Version of <a>mkVCD</a> that accepts arbitrary circuit mods.
mkVCDCM :: Int -> Fabric () -> [(String, Pad)] -> (KLEG -> IO KLEG) -> IO (VCD, KLEG)

-- | Inverse of showTBF, needs a signature for the shape of the desired
--   VCD. Creates a VCD from testbench signal files.
readTBF :: [String] -> Signature -> VCD

-- | Convert the inputs and outputs of a VCD to the textual format expected
--   by a testbench.
writeTBF :: String -> VCD -> IO ()

-- | Convert string representation used in testbench files to a RepValue
--   Note the reverse here is crucial due to way vhdl indexes stuff
tbw2rep :: String -> RepValue

-- | Convert a RepValue to the string representation used in testbench
--   files
rep2tbw :: RepValue -> String
instance Eq VC
instance Ord VC
instance Read VC
instance Show VC
instance Eq VCD
instance Show VCD


-- | Probes log the shallow-embedding signals of a Lava circuit in the |
--   deep embedding, so that the results can be observed post-mortem.
module Language.KansasLava.Probes

-- | <a>probeS</a> adds a named probe to the front of a signal.
probeS :: Rep a => String -> Signal c a -> Signal c a

-- | <a>unpackedProbe</a> is an unpacked version of <a>probeS</a>.
unpackedProbe :: (Rep a, Pack c a, p ~ Unpacked c a) => String -> p -> p
resetProbesForVCD :: IO ()
snapProbesAsVCD :: IO VCD

-- | A simplified API, where each internal probe event is represented as a
--   newline-terminated String, and can be printed, or appended to a file.
--   
--   To append to a debugging file, use
--   
--   <pre>
--   ghci&gt; setProbesAsTrace $ appendFile "DEBUG.out"
--   </pre>
--   
--   To write to the screen, use
--   
--   <pre>
--   ghci&gt; setProbesAsTrace $ putStr
--   </pre>
--   
--   You will need to re-execute your program after calling any probe
--   function, so typically this done on the command line, or by puting
--   setProbeAsTrace inside main.
setProbesAsTrace :: (String -> IO ()) -> IO ()

-- | The callback is called for every element of every probed value, in
--   evaluation order. The arguments are fully evaluted (so printing them
--   will not cause any side-effects of evaluation.
setShallowProbes :: (forall a. Rep a => String -> Integer -> X a -> X a) -> IO ()

-- | Used internally for initializing debugging hooks, replaces all future
--   calls to probe with the given function.
setProbes :: (forall a i. Rep a => String -> Signal i a -> Signal i a) -> IO ()


-- | This module contains convenience functions for building deep embedding
--   entities.
module Language.KansasLava.Entity

-- | A zero-input Entity.
entity0 :: Rep o => Id -> D o

-- | A one-input Entity
entity1 :: (Rep a, Rep o) => Id -> D a -> D o

-- | A two-input entity.
entity2 :: (Rep a, Rep b, Rep o) => Id -> D a -> D b -> D o

-- | A three-input entity.
entity3 :: (Rep a, Rep b, Rep c, Rep o) => Id -> D a -> D b -> D c -> D o

-- | An n-ary entity, with all of the inputs having the same type, passed
--   in as a list.
entityN :: (Rep a, Rep o) => Id -> [D a] -> D o

module Language.KansasLava.Protocols

-- | Enabled is a synonym for Maybe.
type Enabled a = Maybe a

-- | Combine a boolean control signal and an data signal into an enabled
--   signal.
packEnabled :: (Rep a, sig ~ Signal clk) => sig Bool -> sig a -> sig (Enabled a)

-- | Break the representation of an Enabled signal into a Bool signal (for
--   whether the value is valid) and a signal for the data.
unpackEnabled :: (Rep a, sig ~ Signal clk) => sig (Enabled a) -> (sig Bool, sig a)

-- | Drop the Enabled control from the signal. The output signal will be
--   Rep unknown if the input signal is not enabled.
enabledVal :: (Rep a, sig ~ Signal clk) => sig (Enabled a) -> sig a

-- | Determine if the the circuit is enabled.
isEnabled :: (Rep a, sig ~ Signal clk) => sig (Enabled a) -> sig Bool

-- | This is lifting *Comb* because Comb is stateless, and the <tt>en</tt>
--   Bool being passed on assumes no history, in the 'a -&gt; b' function.
mapEnabled :: (Rep a, Rep b, sig ~ Signal clk) => (forall clk'. Signal clk' a -> Signal clk' b) -> sig (Enabled a) -> sig (Enabled b)

-- | Lift a data signal to be an Enabled signal, that's always enabled.
enabledS :: (Rep a, sig ~ Signal clk) => sig a -> sig (Enabled a)

-- | Create a signal that's never enabled.
disabledS :: (Rep a, sig ~ Signal clk) => sig (Enabled a)

-- | Optionally updatable register, based on the value of the enabled
--   signal.
registerEnabled :: (Rep a, Clock clk, sig ~ Signal clk) => a -> sig (Enabled a) -> sig a

-- | A Pipe combines an address, data, and an Enabled control line.
type Pipe a d = Enabled (a, d)

-- | A Memory takes in a sequence of addresses, and returns a sequence of
--   data at that address.
type Memory clk a d = Signal clk a -> Signal clk d

-- | Write the input pipe to memory, return a circuit that does reads.
writeMemory :: (Clock clk1, sig ~ Signal clk1, Size a, Rep a, Rep d) => sig (Pipe a d) -> sig (a -> d)

-- | Read a series of addresses. Respects the latency of Xilinx BRAMs.
syncRead :: (Clock clk, sig ~ Signal clk, Size a, Rep a, Rep d) => sig (a -> d) -> sig a -> sig d

-- | Read a series of addresses.
asyncRead :: (Clock clk, sig ~ Signal clk, Size a, Rep a, Rep d) => sig (a -> d) -> sig a -> sig d

-- | memoryToMatrix should be used with caution/simulation only, because
--   this actually clones the memory to allow this to work, generating lots
--   of LUTs and BRAMS.
memoryToMatrix :: (Integral a, Size a, Rep a, Rep d, Clock clk, sig ~ Signal clk) => sig (a -> d) -> sig (Matrix a d)

-- | Apply a function to the Enabled input signal producing a Pipe.
enabledToPipe :: (Rep x, Rep y, Rep z, sig ~ Signal clk) => (forall j. Signal j x -> Signal j (y, z)) -> sig (Enabled x) -> sig (Pipe y z)

-- | Generate a read-only memory.
rom :: (Rep a, Rep b, Clock clk) => Signal clk a -> (a -> Maybe b) -> Signal clk b

-- | Take a list of shallow values and create a stream which can be sent
--   into a FIFO, respecting the write-ready flag that comes out of the
--   FIFO.
toAckBox :: (Rep a, Clock c, sig ~ Signal c) => Patch [Maybe a] (sig (Enabled a)) () (sig Ack)

-- | An AckBox producer that will go through a series of wait states after
--   each time it drives the data output.
toAckBox' :: (Rep a, Clock c, sig ~ Signal c) => [Int] -> Patch [Maybe a] (sig (Enabled a)) () (sig Ack)

-- | Take stream from a FIFO and return an asynchronous read-ready flag,
--   which is given back to the FIFO, and a shallow list of values. I'm
--   sure this space-leaks.
fromAckBox :: (Rep a, Clock c, sig ~ Signal c) => Patch (sig (Enabled a)) [Maybe a] (sig Ack) ()

-- | An ackBox that goes through a series of intermediate states each time
--   consumes a value from the input stream and then issues an Ack.
fromAckBox' :: (Rep a, Clock c, sig ~ Signal c) => [Int] -> Patch (sig (Enabled a)) [Maybe a] (sig Ack) ()

-- | <tt>enableToAckBox</tt> turns an Enabled signal into a (1-sided)
--   Patch.
enabledToAckBox :: (Rep a, Clock c, sig ~ Signal c) => Patch (sig (Enabled a)) (sig (Enabled a)) () (sig Ack)

-- | <a>ackBoxToEnabled</a> turns the AckBox protocol into the Enabled
--   protocol. The assumptions is the circuit on the right is fast enough
--   to handle the streamed data.
ackBoxToEnabled :: (Rep a, Clock c, sig ~ Signal c) => Patch (sig (Enabled a)) (sig (Enabled a)) (sig Ack) ()

-- | This introduces protocol-compliant delays (in the shallow embedding)
shallowAckBoxBridge :: (Rep a, Clock c, sig ~ Signal c, Show a) => ([Int], [Int]) -> Patch (sig (Enabled a)) (sig (Enabled a)) (sig Ack) (sig Ack)

-- | <tt>probeAckBoxPatch</tt> creates a patch with a named probe, probing
--   the data and ack signals in an Ack interface.
probeAckBoxP :: (Rep a, Clock c, sig ~ Signal c) => String -> Patch (sig (Enabled a)) (sig (Enabled a)) (sig Ack) (sig Ack)
runAckBoxP :: (c ~ CLK, sig ~ Signal c, Rep a, Rep b) => Patch (sig (Enabled a)) (sig (Enabled b)) (sig Ack) (sig Ack) -> [a] -> [b]

-- | A sink patch throws away its data input (generating a () data output).
--   <tt>sinkReadyP</tt> uses an enabled/ack protocol.
sinkAckP :: (Rep a, Clock c, sig ~ Signal c) => Patch (sig (Enabled a)) () (sig Ack) ()

-- | A source patch takes no input and generates a stream of values. It
--   corresponds to a top-level input port. <tt>sourceReadyP</tt> uses the
--   enabled/ack protocol.
alwaysAckP :: (Rep a, Clock c, sig ~ Signal c) => a -> Patch () (sig (Enabled a)) () (sig Ack)

-- | stub, no data ever sent.
neverAckP :: (Rep a, Clock c, sig ~ Signal c) => Patch () (sig (Enabled a)) () (sig Ack)

-- | Take a list of shallow values and create a stream which can be sent
--   into a FIFO, respecting the write-ready flag that comes out of the
--   FIFO.
toReadyBox :: (Rep a, Clock c, sig ~ Signal c) => Patch [Maybe a] (sig (Enabled a)) () (sig Ready)

-- | A readybox that goes through a sequence of intermediate states after
--   issuing each enable, and before it looks for the next Ready.
toReadyBox' :: (Rep a, Clock c, sig ~ Signal c) => [Int] -> Patch [Maybe a] (sig (Enabled a)) () (sig Ready)

-- | Take stream from a FIFO and return an asynchronous read-ready flag,
--   which is given back to the FIFO, and a shallow list of values. I'm
--   sure this space-leaks.
fromReadyBox :: (Rep a, Clock c, sig ~ Signal c) => Patch (sig (Enabled a)) [Maybe a] (sig Ready) ()

-- | Like fromReadyBox, but which goes through a series of intermediate
--   states after receiving an enable before issuing another Ready.
fromReadyBox' :: (Rep a, Clock c, sig ~ Signal c) => [Int] -> Patch (sig (Enabled a)) [Maybe a] (sig Ready) ()

-- | Introduces protocol-compliant delays (in the shallow embedding)
shallowReadyBoxBridge :: (Rep a, Clock c, sig ~ Signal c, Show a) => ([Int], [Int]) -> Patch (sig (Enabled a)) (sig (Enabled a)) (sig Ready) (sig Ready)

-- | <tt>probeReadyBoxPatch</tt> creates a patch with a named probe,
--   probing the data and ready signals in a Ready interface.
probeReadyBoxP :: (Rep a, Clock c, sig ~ Signal c) => String -> Patch (sig (Enabled a)) (sig (Enabled a)) (sig Ready) (sig Ready)
runReadyBoxP :: (c ~ CLK, sig ~ Signal c, Rep a, Rep b) => Patch (sig (Enabled a)) (sig (Enabled b)) (sig Ready) (sig Ready) -> [a] -> [b]

-- | A sink patch throws away its data input (generating a () data output).
--   <a>sinkReadyP</a> uses an enabled/ready protocol.
sinkReadyP :: (Rep a, Clock c, sig ~ Signal c) => Patch (sig (Enabled a)) () (sig Ready) ()

-- | A source patch takes no input and generates a stream of values. It
--   corresponds to a top-level input port. <a>alwaysReadyP</a> uses the
--   ready/enabled protocol.
alwaysReadyP :: (Rep a, Clock c, sig ~ Signal c) => a -> Patch () (sig (Enabled a)) () (sig Ready)

-- | stub, no data ever sent.
neverReadyP :: (Rep a, Clock c, sig ~ Signal c) => Patch () (sig (Enabled a)) () (sig Ready)

-- | An Ack is always in response to an incoming packet or message.
newtype Ack
Ack :: Bool -> Ack
unAck :: Ack -> Bool

-- | Convert a <a>Bool</a> signal to an <a>Ack</a> signal.
toAck :: sig ~ Signal clk => sig Bool -> sig Ack

-- | Convert an <a>Ack</a> to a <a>Bool</a> signal.
fromAck :: sig ~ Signal clk => sig Ack -> sig Bool

-- | An Ready is always in response to an incoming packet or message
newtype Ready
Ready :: Bool -> Ready
unReady :: Ready -> Bool

-- | Convert a Bool signal to a <a>Ready</a> signal.
toReady :: sig ~ Signal clk => sig Bool -> sig Ready

-- | Convert a <a>Ready</a> signal to a Bool signal.
fromReady :: sig ~ Signal clk => sig Ready -> sig Bool

-- | A Patch is a data signal with an associated control signal. The
--   <tt>lhs_in</tt> type parameter is the type of the data input, the
--   <tt>rhs_out</tt> type parameter is the type of the data output. The
--   <tt>rhs_in</tt> is the type of the control input (e.g. a
--   <tt>ready</tt> signal), and the <tt>lhs_out</tt> is the type of the
--   control output (e.g. <tt>ack</tt>).
type Patch lhs_in rhs_out lhs_out rhs_in = (lhs_in, rhs_in) -> (lhs_out, rhs_out)

-- | outputP produces a constant data output. The control inputs/outputs
--   are unit, so they contain no data.
outputP :: a -> Patch () a () ()
runP :: (Unit u1, Unit u2) => Patch u1 a u2 () -> a
execP :: Patch a b c d -> (a, d) -> (c, b)

-- | A patch that passes through data and control.
emptyP :: Patch a a b b

-- | Given a patch, add to the data and control inputs/outputs a second set
--   of signals that are passed-through. The signals of the argument patch
--   to fstP will appear as the first element of the pair in the resulting
--   patch.
fstP :: Patch a b c e -> Patch (a :> f) (b :> f) (c :> g) (e :> g)

-- | Given a patch, add to the data and control inputs/outputs a second set
--   of signals that are passed-through. The signals of the argument patch
--   to sndP will appear as the second element of the pair in the resulting
--   patch.
sndP :: Patch a b c d -> Patch (f :> a) (f :> b) (g :> c) (g :> d)

-- | Lift a function to a patch, applying the function to the data input.
forwardP :: (li -> ro) -> Patch li ro b b

-- | Lift a function to a patch, applying the function to the control
--   input.
backwardP :: (ri -> lo) -> Patch a a lo ri

-- | Given two patches, tuple their data/control inputs and outputs.
stackP :: Patch li1 ro1 lo1 ri1 -> Patch li2 ro2 lo2 ri2 -> Patch (li1 :> li2) (ro1 :> ro2) (lo1 :> lo2) (ri1 :> ri2)

-- | Given a homogeneous list (Matrix) of patches, combine them into a
--   single patch, collecting the data<i>control inputs</i>outputs into
--   matrices.
matrixStackP :: (m ~ (Matrix x), Size x) => m (Patch li ro lo ri) -> Patch (m li) (m ro) (m lo) (m ri)

-- | loopP is a fixpoint style combinator, for backedges.
loopP :: Patch (a :> b) (a :> c) (d :> e) (d :> f) -> Patch b c e f
openP :: Patch c (() :> c) d (() :> d)
mapP :: (Rep a, Rep b, Clock c, sig ~ Signal c) => (forall clk'. Signal clk' a -> Signal clk' b) -> Patch (sig (Enabled a)) (sig (Enabled b)) (ack) (ack)

-- | An instance of the Unit type contains a value that carries no
--   information.
class Unit unit
unit :: Unit unit => unit
unUnit :: Unit unit => unit -> ()

-- | <a>rawReadP</a> reads a binary file into Patch, which will become the
--   lefthand side of a chain of patches.
rawReadP :: FilePath -> IO (Patch () [Maybe U8] () ())

-- | <tt>readPatch</tt> reads an encoded file into Patch, which will become
--   the lefthand side of a chain of patches.
readP :: Read a => FilePath -> IO (Patch () [Maybe a] () ())

-- | <a>rawWriteP</a> runs a complete circuit for the given number of
--   cycles, writing the result to a given file in binary format.
rawWriteP :: (Unit u1, Unit u2) => FilePath -> Int -> Patch u1 [Maybe U8] u2 () -> IO ()

-- | <a>writeP</a> runs a complete circuit for the given number of cycles,
--   writing the result to a given file in string format.
writeP :: (Show a, Unit u1, Unit u2) => FilePath -> Int -> Patch u1 [Maybe a] u2 () -> IO ()

-- | ($$) composes two patches serially, sharing a common control protocol.
--   The data output of the first patch is fed to the data input of the
--   second patch. The control output of the second patch is fed to the
--   control input of the first patch, and the control output of the first
--   patch is fed to the control input of the second patch.
($$) :: Patch li1 o lo1 i -> Patch o ro2 i ri2 -> Patch li1 ro2 lo1 ri2

-- | <a>readyToAckBridge</a> converts from a ready interface to an ACK
--   interface by preemptively giving the ready signal, and holding the
--   resulting data from the device on the input side if no ACK is received
--   by the device on the output side. If data is currently being held,
--   then the ready signal will not be given. This bridge is fine for deep
--   embedding (can be represented in hardware).
readyToAckBridge :: (Rep a, Clock c, sig ~ Signal c) => Patch (sig (Enabled a)) (sig (Enabled a)) (sig Ready) (sig Ack)

-- | <a>ackToReadyBridge</a> converts from a Ack interface to an Ready
--   interface by ANDing the ready signal from the receiving component with
--   the input enable from the sending component. This may not be necessary
--   at times if the sending component ignores ACKs when no data is sent.
--   This bridge is fine for deep embedding (can be represented in
--   hardware).
ackToReadyBridge :: (Rep a, Clock c, sig ~ Signal c) => Patch (sig (Enabled a)) (sig (Enabled a)) (sig Ack) (sig Ready)

-- | This duplicates the incomming datum. This has the behavior that
--   neither branch sees the value until both can recieve it.
dupP :: (Clock c, sig ~ Signal c, Rep a) => Patch (sig (Enabled a)) (sig (Enabled a) :> sig (Enabled a)) (sig Ack) (sig Ack :> sig Ack)

-- | This duplicate the incoming datam over many handshaken streams.
matrixDupP :: (Clock c, sig ~ Signal c, Rep a, Size x) => Patch (sig (Enabled a)) (Matrix x (sig (Enabled a))) (sig Ack) (Matrix x (sig Ack))

-- | unzipP creates a patch that takes in an Enabled data pair, and
--   produces a pair of Enabled data outputs.
unzipP :: (Clock c, sig ~ Signal c, Rep a, Rep b) => Patch (sig (Enabled (a, b))) (sig (Enabled a) :> sig (Enabled b)) (sig Ack) (sig Ack :> sig Ack)

-- | matrixUnzipP is the generalization of unzipP to homogeneous matrices.
matrixUnzipP :: (Clock c, sig ~ Signal c, Rep a, Rep x, Size x) => Patch (sig (Enabled (Matrix x a))) (Matrix x (sig (Enabled a))) (sig Ack) (Matrix x (sig Ack))

-- | TODO: Andy write docs for this.
deMuxP :: (Clock c, sig ~ Signal c, Rep a) => Patch (sig (Enabled Bool) :> sig (Enabled a)) (sig (Enabled a) :> sig (Enabled a)) (sig Ack :> sig Ack) (sig Ack :> sig Ack)

-- | matrixDeMuxP is the generalization of deMuxP to a matrix of signals.
matrixDeMuxP :: (Clock c, sig ~ Signal c, Rep a, Rep x, Size x) => Patch (sig (Enabled x) :> sig (Enabled a)) (Matrix x (sig (Enabled a))) (sig Ack :> sig Ack) (Matrix x (sig Ack))

-- | Combine two enabled data inputs into a single Enabled tupled data
--   input.
zipP :: (Clock c, sig ~ Signal c, Rep a, Rep b) => Patch (sig (Enabled a) :> sig (Enabled b)) (sig (Enabled (a, b))) (sig Ack :> sig Ack) (sig Ack)

-- | Extension of zipP to homogeneous matrices.
matrixZipP :: (Clock c, sig ~ Signal c, Rep a, Rep x, Size x) => Patch (Matrix x (sig (Enabled a))) (sig (Enabled (Matrix x a))) (Matrix x (sig Ack)) (sig Ack)

-- | <a>muxP</a> chooses a the 2nd or 3rd value, based on the Boolean
--   value.
muxP :: (Clock c, sig ~ Signal c, Rep a) => Patch (sig (Enabled Bool) :> (sig (Enabled a) :> sig (Enabled a))) (sig (Enabled a)) (sig Ack :> (sig Ack :> sig Ack)) (sig Ack)

-- | <a>matrixMuxP</a> chooses the n-th value, based on the index value.
matrixMuxP :: (Clock c, sig ~ Signal c, Rep a, Rep x, Size x) => Patch (sig (Enabled x) :> Matrix x (sig (Enabled a))) (sig (Enabled a)) (sig Ack :> Matrix x (sig Ack)) (sig Ack)

-- | FIFO with depth 1.
fifo1 :: (Clock c, sig ~ Signal c, Rep a) => Patch (sig (Enabled a)) (sig (Enabled a)) (sig Ack) (sig Ack)

-- | FIFO with depth 2.
fifo2 :: (Clock c, sig ~ Signal c, Rep a) => Patch (sig (Enabled a)) (sig (Enabled a)) (sig Ack) (sig Ack)

-- | <a>matrixToElementsP</a> turns a matrix into a sequences of elements
--   from the array, in ascending order.
matrixToElementsP :: (Clock c, sig ~ Signal c, Rep a, Rep x, Size x, Num x, Enum x) => Patch (sig (Enabled (Matrix x a))) (sig (Enabled a)) (sig Ack) (sig Ack)

-- | <a>matrixFromElementsP</a> turns a sequence of elements (in ascending
--   order) into a matrix. ascending order.
matrixFromElementsP :: (Clock c, sig ~ Signal c, Rep a, Rep x, Size x, Num x, Enum x) => Patch (sig (Enabled a)) (sig (Enabled (Matrix x a))) (sig Ack) (sig Ack)

-- | globalClockP forces the handshaking to use the CLK clock. Which is
--   useful for testing.
globalClockP :: (clk ~ CLK, sig ~ Signal clk) => Patch (sig a) (sig a) (sig b) (sig b)

-- | cycleP cycles through a constant list (actually a matrix) of values.
--   Generates an async ROM on hardware.
cycleP :: (Size ix, Rep a, Rep ix, Num ix, Clock c, sig ~ Signal c) => Matrix ix a -> Patch () (sig (Enabled a)) () (sig Ack)
constP :: (Size ix, Rep a, Rep ix, Num ix, Clock c, sig ~ Signal c) => Matrix ix a -> Patch () (sig (Enabled a)) () (sig Ack)
prependP :: (Size ix, Rep a, Rep ix, Num ix, Clock c, sig ~ Signal c) => Matrix ix a -> Patch (sig (Enabled a)) (sig (Enabled a)) (sig Ack) (sig Ack)
data MergePlan

-- | The first element always has priority
PriorityMerge :: MergePlan

-- | Turn about, can be slower
RoundRobinMerge :: MergePlan
mergeP :: (Clock c, sig ~ Signal c, Rep a) => MergePlan -> Patch ((sig (Enabled a)) :> (sig (Enabled a))) (sig (Enabled a)) ((sig Ack) :> (sig Ack)) (sig Ack)
matrixMergeP :: (Clock c, sig ~ Signal c, Rep a, Rep x, Size x, Num x, Enum x) => MergePlan -> Patch (Matrix x (sig (Enabled a))) (sig (Enabled a)) (Matrix x (sig Ack)) (sig Ack)
type FabricPatch fab lhs_in rhs_out lhs_out rhs_in = (lhs_in, rhs_in) -> fab (lhs_out, rhs_out)
patchF :: MonadFix fab => Patch a b c d -> FabricPatch fab a b c d
(|$|) :: MonadFix fab => FabricPatch fab a b d e -> FabricPatch fab b c e f -> FabricPatch fab a c d f
runF :: MonadFix fab => FabricPatch fab () a () () -> fab a
buildF :: MonadFix fab => ((a, d) -> fab (c, b)) -> FabricPatch fab a b c d

-- | A fabric patch that passes through data and control.
emptyF :: MonadFix fab => FabricPatch fab a a b b

-- | Given two fabric patches, tuple their data/control inputs and outputs.
stackF :: MonadFix fab => FabricPatch fab li1 ro1 lo1 ri1 -> FabricPatch fab li2 ro2 lo2 ri2 -> FabricPatch fab (li1 :> li2) (ro1 :> ro2) (lo1 :> lo2) (ri1 :> ri2)


-- | The RTL module provides a small DSL that's useful for control-oriented
--   -- stateful -- computations.
module Language.KansasLava.RTL

-- | RTL Monad; s == the runST state; c is governing clock, and a is the
--   result
data RTL s c a
RTL :: (Pred c -> STRef s Int -> ST s (a, [Int])) -> RTL s c a
(:=) :: Reg s c b -> Signal c b -> RTL s c ()
CASE :: [Cond s c] -> RTL s c ()
WHEN :: Signal c Bool -> RTL s c () -> RTL s c ()
DEBUG :: String -> Reg s c b -> RTL s c ()

-- | A register is used internally to represent a register or memory
--   element.
data Reg s c a

-- | A conditional statement.
data Cond s c
IF :: (Signal c Bool) -> (RTL s c ()) -> Cond s c
OTHERWISE :: (RTL s c ()) -> Cond s c

-- | Run the RTL monad.
runRTL :: Clock c => (forall s. RTL s c a) -> a

-- | reg is the value of a register, as set by the start of the cycle.
reg :: Reg s c a -> Signal c a

-- | var is the value of a register, as will be set in the next cycle, so
--   intra-cycle changes are observed. The is simular to a *variable* in
--   VHDL.
var :: Reg s c a -> Signal c a

-- | Declare a new register.
newReg :: (Clock c, Rep a) => a -> RTL s c (Reg s c a)

-- | Declare an array. Arrays support partual updates.
newArr :: (Size ix, Clock c, Rep a, Num ix, Rep ix) => Witness ix -> RTL s c (Signal c ix -> Reg s c a)

-- | match checks for a enabled value, and if so, executes the given RTL in
--   context, by constructing the correct <a>Cond</a>-itional.
match :: Rep a => Signal c (Enabled a) -> (Signal c a -> RTL s c ()) -> Cond s c
instance Monad (RTL s c)
instance Applicative (RTL s c)
instance Functor (RTL s c)


-- | This module converts a Lava circuit to a synthesizable VHDL netlist.
module Language.KansasLava.VHDL

-- | The <a>netlistCircuit</a> function converts a Lava circuit into a
--   Netlist AST The circuit type must implement the <tt>Ports</tt> class.
--   If the circuit type is a function, the function arguments will be
--   exposed as input ports, and the result will be exposed as an output
--   port (or ports, if it is a compound type).
netlistCircuit :: String -> KLEG -> IO Module

-- | The <tt>vhdlCircuit</tt> function converts a Lava KLEG into a VHDL
--   entity/architecture pair.
writeVhdlCircuit :: String -> FilePath -> KLEG -> IO ()

-- | Write the Lava Prelude into this file. For example:
--   
--   <pre>
--   writeVhdlPrelude "Lava.vhd" 
--   </pre>
writeVhdlPrelude :: FilePath -> IO ()
mkTestbench :: String -> FilePath -> KLEG -> IO ()

module Language.KansasLava.Test
testMe :: String -> Maybe [String] -> Bool
neverTestMe :: String -> [String] -> Bool
verbose :: Int -> String -> Int -> String -> IO ()
fileReporter :: FilePath -> FilePath -> Result -> IO ()
data TestSeq
TestSeq :: (String -> Int -> Fabric () -> (Fabric (Int -> Maybe String)) -> IO ()) -> () -> TestSeq
testFabrics :: Options -> SimMods -> String -> Int -> Fabric () -> (Fabric (Int -> Maybe String)) -> IO ()
data Gen a
Gen :: Integer -> (Integer -> Maybe a) -> Gen a
arbitrary :: Rep w => Gen w

-- | <a>allCases</a> returns all values of type w, in a non-random order.
allCases :: Rep w => [w]

-- | <a>finiteCases</a> returns finite values, perhaps many times, in a
--   random order.
finiteCases :: Rep w => Int -> [w]
testDriver :: Options -> [TestSeq -> IO ()] -> IO ()
generateReport :: FilePath -> IO ()
data Options
Options :: Bool -> Bool -> String -> FilePath -> Bool -> Int -> Maybe [String] -> [String] -> Int -> Int -> Options

-- | Generate modelsim testbenches for each test?
genSim :: Options -> Bool

-- | Run the tests after generation?
runSim :: Options -> Bool

-- | Command to call with runSim is True
simCmd :: Options -> String

-- | Path into which we place all our simulation directories.
simPath :: Options -> FilePath

-- | False: Run each mod separately. True: Run all possible permutations of
--   the mods to see if they affect each other.
permuteMods :: Options -> Bool

-- | See verbose table below.
verboseOpt :: Options -> Int

-- | Lists of tests to execute. Can match either end. Nothing means all
--   tests.
testOnly :: Options -> Maybe [String]

-- | List of tests to never execute. Can match either end.
testNever :: Options -> [String]

-- | cut off for random testing
testData :: Options -> Int

-- | how may tests to run in parallel
parTest :: Options -> Int

-- | matchExpected reads a named input port from a Fabric, and checks to
--   see that it is a refinement of a given "specification" of the output.
--   If there is a problem, issue an error message.
matchExpected :: (Rep a, Size (W a), Show a) => String -> Seq a -> Fabric (Int -> Maybe String)
data StreamTest w1 w2
StreamTest :: Patch (Seq (Enabled w1)) (Seq (Enabled w2)) (Seq Ack) (Seq Ack) -> ([w1] -> [w2] -> Maybe String) -> Int -> Int -> String -> StreamTest w1 w2
theStream :: StreamTest w1 w2 -> Patch (Seq (Enabled w1)) (Seq (Enabled w2)) (Seq Ack) (Seq Ack)
correctnessCondition :: StreamTest w1 w2 -> [w1] -> [w2] -> Maybe String
theStreamTestCount :: StreamTest w1 w2 -> Int
theStreamTestCycles :: StreamTest w1 w2 -> Int
theStreamName :: StreamTest w1 w2 -> String
testStream :: (Eq w1, Rep w1, Show w1, Size (W w1), Eq w2, Rep w2, Show w2, Size (W w2)) => TestSeq -> String -> StreamTest w1 w2 -> IO ()
instance Typeable Options
instance Data Options
instance Show Result
instance Read Result
instance Default Options
instance Show Options
instance Show Summary
instance Show Report


-- | This module provides some basic support for co-opting an identity
--   entity block as a box containing some <a>Dynamic</a> data. Any
--   optimization pass will assume these blocks are identities, and perhaps
--   remove them.
module Language.KansasLava.Dynamic

-- | We use identity "black boxes" as arbitary tags in the syntax, for
--   extentablity.
addDynamic :: (sig ~ Signal i, Rep a) => Dynamic -> sig a -> sig a

-- | Get any chain of (deep) black boxes on this signal.
getDynamics :: (sig ~ Signal i, Rep a) => sig a -> [Dynamic]


-- | A top-level module that re-exports the relevent parts of the library's
--   internal modules.
module Language.KansasLava

-- | The <a>Fabric</a> structure, which is also a monad.
--   
--   <pre>
--   fabric_example :: Fabric ()
--   fabric_example = do
--          i0 &lt;- inStdLogic "i0"
--          i1 &lt;- inStdLogic "i1"
--          let (c,s) = halfAdder i0 i1
--          outStdLogic "carry" c
--          outStdLogic "sum" s
--    where
--            halfAdder :: Seq Bool -&gt; Seq Bool -&gt; (Seq Bool,Seq Bool)
--            halfAdder a b = (carry,sum_)
--                  where carry = and2 a b
--                        sum_  = xor2 a b
--   </pre>
--   
--   A Fabric consists of a list of input ports, and yields a list of
--   output ports and generics.
data Fabric a

-- | <a>reifyFabric</a> does reification of a 'Fabric ()' into a
--   <a>KLEG</a>.
reifyFabric :: Fabric () -> IO KLEG

-- | Generate a named std_logic input port.
inStdLogic :: (Rep a, Show a, W a ~ X1) => String -> Fabric (Seq a)

-- | Generate a named std_logic_vector port input.
inStdLogicVector :: (Rep a, Show a, Size (W a)) => String -> Fabric (Seq a)

-- | Generate a named generic.
inGeneric :: String -> Fabric Integer

-- | Generate a named std_logic output port, given a Lava circuit.
outStdLogic :: (Rep a, Show a, W a ~ X1) => String -> Seq a -> Fabric ()

-- | Generate a named std_logic_vector output port, given a Lava circuit.
outStdLogicVector :: (Rep a, Show a, Size (W a)) => String -> Seq a -> Fabric ()

-- | theClk gives the external name for the clock.
theClk :: String -> Fabric ()

-- | theRst gives the external name for the reset signal [default = low].
theRst :: String -> Fabric ()

-- | theClkEn gives the external name for the clock enable signal [default
--   = high].
theClkEn :: String -> Fabric ()

-- | These are sequences of values over time. We assume edge triggered
--   logic (checked at (typically) rising edge of clock) This clock is
--   assumed known, based on who is consuming the list. Right now, it is
--   global, but we think we can support multiple clocks with a bit of
--   work.
data Signal (c :: *) a

-- | Signal in some implicit clock domain.
type Seq a = Signal CLK a

-- | Convert a list of values into a Signal. The shallow portion of the
--   resulting Signal will begin with the input list, then an infinite
--   stream of X unknowns.
toS :: (Clock c, Rep a) => [a] -> Signal c a

-- | Convert a list of values into a Signal. The input list is wrapped with
--   a Maybe, and any Nothing elements are mapped to X's unknowns.
toS' :: (Clock c, Rep a) => [Maybe a] -> Signal c a

-- | Create a Signal with undefined for both the deep and shallow elements.
undefinedS :: (Rep a, sig ~ Signal clk) => sig a

-- | Convert a Signal of values into a list of Maybe values.
fromS :: Rep a => Signal c a -> [Maybe a]

-- | take the first n elements of a <a>Signal</a>; the rest is undefined.
takeS :: (Rep a, Clock c) => Int -> Signal c a -> Signal c a

-- | A pure <a>Signal</a>.
pureS :: Rep a => a -> Signal i a

-- | A <a>Signal</a> witness identity function. Useful when typing things.
witnessS :: Rep a => Witness a -> Signal i a -> Signal i a

-- | Attach a comment to a <a>Signal</a>.
commentS :: (Rep a, sig ~ Signal clk) => String -> sig a -> sig a

-- | Push the sign type *into* the compound data type.
pack :: Pack clk a => Unpacked clk a -> Signal clk a
unpack :: Pack clk a => Signal clk a -> Unpacked clk a
packMatrix :: (Rep a, Size x, sig ~ Signal clk) => Matrix x (sig a) -> sig (Matrix x a)
unpackMatrix :: (Rep a, Size x, sig ~ Signal clk) => sig (Matrix x a) -> Matrix x (sig a)

-- | A register is a state element with a reset. The reset is supplied by
--   the clock domain in the Signal.
register :: (Rep a, Clock clk) => a -> Signal clk a -> Signal clk a

-- | registers generates a serial sequence of n registers, all with the
--   same initial value.
registers :: (Rep a, Clock clk) => Int -> a -> Signal clk a -> Signal clk a

-- | a delay is a register with no defined default / initial value.
delay :: (Rep a, Clock clk) => Signal clk a -> Signal clk a

-- | delays generates a serial sequence of n delays.
delays :: (Rep a, Clock clk) => Int -> Signal clk a -> Signal clk a

-- | The <a>writeDotCircuit</a> function converts a Lava circuit into a
--   graphviz output.
writeDotCircuit :: FilePath -> KLEG -> IO ()

-- | Data structure for passing optimization parameters.
data OptimizationOpts
OptimizationOpts :: Int -> OptimizationOpts
optDebugLevel :: OptimizationOpts -> Int

-- | Basic optimizations, and assumes reaching a fixpoint. Cleans things
--   up, but does not work too hard, because the VHDL compiler get many of
--   the combinatorial optimizations anyway.
optimizeCircuit :: OptimizationOpts -> KLEG -> IO KLEG

-- | The <tt>vhdlCircuit</tt> function converts a Lava KLEG into a VHDL
--   entity/architecture pair.
writeVhdlCircuit :: String -> FilePath -> KLEG -> IO ()

-- | Write the Lava Prelude into this file. For example:
--   
--   <pre>
--   writeVhdlPrelude "Lava.vhd" 
--   </pre>
writeVhdlPrelude :: FilePath -> IO ()

-- | <a>VCD</a> is a primary bit-wise record of an interactive session with
--   some circuit Map from module/name to stream.
data VCD

-- | Convert a <a>VCD</a> to a VCD file.
writeVCDFile :: Bool -> Integer -> FilePath -> VCD -> IO ()

-- | Convert a VCD file to a VCD object.
readVCDFile :: FilePath -> Signature -> IO VCD
