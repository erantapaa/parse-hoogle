-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Prelude counterpart
--   
--   Excessive Prelude styled imports.
@package pregame
@version 0.1.4.3

module Pregame

-- | Continuation monad. <tt>Cont r a</tt> is a CPS computation that
--   produces an intermediate result of type <tt>a</tt> within a CPS
--   computation whose final result type is <tt>r</tt>.
--   
--   The <tt>return</tt> function simply creates a continuation which
--   passes the value on.
--   
--   The <tt>&gt;&gt;=</tt> operator adds the bound function into the
--   continuation chain.
type Cont r = ContT r Identity

-- | The continuation monad transformer. Can be used to add continuation
--   handling to other monads.
data ContT r (m :: * -> *) a :: * -> (* -> *) -> * -> *

-- | An exception to be thrown.
--   
--   Minimal complete definition: <a>noMsg</a> or <a>strMsg</a>.
class Error a

-- | The error monad transformer. It can be used to add error handling to
--   other monads.
--   
--   The <tt>ErrorT</tt> Monad structure is parameterized over two things:
--   
--   <ul>
--   <li>e - The error type.</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function yields a successful computation, while
--   <tt>&gt;&gt;=</tt> sequences two subcomputations, failing on the first
--   error.
data ErrorT e (m :: * -> *) a :: * -> (* -> *) -> * -> *

-- | The trivial monad transformer, which maps a monad to an equivalent
--   monad.
data IdentityT (m :: * -> *) a :: (* -> *) -> * -> *

-- | A state monad parameterized by the type <tt>s</tt> of the state to
--   carry.
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
type State s = StateT s Identity

-- | A state transformer monad parameterized by:
--   
--   <ul>
--   <li><tt>s</tt> - The state.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
data StateT s (m :: * -> *) a :: * -> (* -> *) -> * -> *

-- | Parameterizable list monad, with an inner monad.
--   
--   <i>Note:</i> this does not yield a monad unless the argument monad is
--   commutative.
data ListT (m :: * -> *) a :: (* -> *) -> * -> *

-- | The parameterizable maybe monad, obtained by composing an arbitrary
--   monad with the <a>Maybe</a> monad.
--   
--   Computations are actions that may produce a value or fail.
--   
--   The <a>return</a> function yields a successful computation, while
--   <tt>&gt;&gt;=</tt> sequences two subcomputations, failing on the first
--   error.
data MaybeT (m :: * -> *) a :: (* -> *) -> * -> *

-- | The parameterizable reader monad.
--   
--   Computations are functions of a shared environment.
--   
--   The <a>return</a> function ignores the environment, while
--   <tt>&gt;&gt;=</tt> passes the inherited environment to both
--   subcomputations.
type Reader r = ReaderT r Identity

-- | The reader monad transformer, which adds a read-only environment to
--   the given monad.
--   
--   The <a>return</a> function ignores the environment, while
--   <tt>&gt;&gt;=</tt> passes the inherited environment to both
--   subcomputations.
data ReaderT r (m :: * -> *) a :: * -> (* -> *) -> * -> *

-- | A monad containing an environment of type <tt>r</tt>, output of type
--   <tt>w</tt> and an updatable state of type <tt>s</tt>.
type RWS r w s = RWST r w s Identity

-- | A monad transformer adding reading an environment of type <tt>r</tt>,
--   collecting an output of type <tt>w</tt> and updating a state of type
--   <tt>s</tt> to an inner monad <tt>m</tt>.
data RWST r w s (m :: * -> *) a :: * -> * -> * -> (* -> *) -> * -> *

-- | A writer monad parameterized by the type <tt>w</tt> of output to
--   accumulate.
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <tt>&gt;&gt;=</tt> combines the outputs of the subcomputations using
--   <a>mappend</a>.
type Writer w = WriterT w Identity

-- | A writer monad parameterized by:
--   
--   <ul>
--   <li><tt>w</tt> - the output to accumulate.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <tt>&gt;&gt;=</tt> combines the outputs of the subcomputations using
--   <a>mappend</a>.
data WriterT w (m :: * -> *) a :: * -> (* -> *) -> * -> *

-- | A Map from keys <tt>k</tt> to values <tt>a</tt>.
data Map k a :: * -> * -> *

-- | General-purpose finite sequences.
data Seq a :: * -> *

-- | A set of values <tt>a</tt>.
data Set a :: * -> *

-- | A space efficient, packed, unboxed Unicode text type.
data Text :: *

-- | Multi-way trees, also known as <i>rose trees</i>.
data Tree a :: * -> *
Node :: a -> Forest a -> Tree a

-- | label value
rootLabel :: Tree a -> a

-- | zero or more child trees
subForest :: Tree a -> Forest a
type Forest a = [Tree a]

-- | A space-efficient representation of a <a>Word8</a> vector, supporting
--   many efficient operations.
--   
--   A <a>ByteString</a> contains 8-bit bytes, or by using the operations
--   from <a>Data.ByteString.Char8</a> it can be interpreted as containing
--   8-bit characters.
data ByteString :: *

-- | Boxed vectors, supporting efficient slicing.
data Vector a :: * -> *
($!) :: (a -> b) -> a -> b
fi :: (Num b, Integral a) => a -> b
io :: MonadIO m => IO a -> m a
done :: Monad m => m ()
eq :: Eq a => a -> a -> Bool
ne :: Eq a => a -> a -> Bool
lt :: Ord a => a -> a -> Bool
lte :: Ord a => a -> a -> Bool
gt :: Ord a => a -> a -> Bool
gte :: Ord a => a -> a -> Bool
