-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Semigroups, specialized containers and a general map/reduce framework
--   
@package reducers
@version 3.10.3.2

module Data.Semigroup.Instances
instance Measured v a => Semigroup (FingerTree v a)


-- | A <tt>c</tt>-<a>Reducer</a> is a <a>Semigroup</a> with a canonical
--   mapping from <tt>c</tt> to the Semigroup.
module Data.Semigroup.Reducer

-- | This type may be best read infix. A <tt>c <a>Reducer</a> m</tt> is a
--   <a>Semigroup</a> <tt>m</tt> that maps values of type <tt>c</tt>
--   through <tt>unit</tt> to values of type <tt>m</tt>. A
--   <tt>c</tt>-<a>Reducer</a> may also supply operations which tack-on
--   another <tt>c</tt> to an existing <a>Monoid</a> <tt>m</tt> on the left
--   or right. These specialized reductions may be more efficient in some
--   scenarios and are used when appropriate by a <tt>Generator</tt>. The
--   names <a>cons</a> and <a>snoc</a> work by analogy to the synonymous
--   operations in the list monoid.
--   
--   This class deliberately avoids functional-dependencies, so that () can
--   be a <tt>c</tt>-Reducer for all <tt>c</tt>, and so many common
--   reducers can work over multiple types, for instance, First and Last
--   may reduce both <tt>a</tt> and <a>Maybe</a> <tt>a</tt>. Since a
--   <tt>Generator</tt> has a fixed element type, the input to the reducer
--   is generally known and extracting from the monoid usually is
--   sufficient to fix the result type. Combinators are available for most
--   scenarios where this is not the case, and the few remaining cases can
--   be handled by using an explicit type annotation.
--   
--   Minimal definition: <a>unit</a>
class Semigroup m => Reducer c m where snoc m = (<>) m . unit cons = (<>) . unit
unit :: Reducer c m => c -> m
snoc :: Reducer c m => m -> c -> m
cons :: Reducer c m => c -> m -> m

-- | Apply a <a>Reducer</a> to a <a>Foldable</a> container, after mapping
--   the contents into a suitable form for reduction.
foldMapReduce :: (Foldable f, Monoid m, Reducer e m) => (a -> e) -> f a -> m
foldMapReduce1 :: (Foldable1 f, Reducer e m) => (a -> e) -> f a -> m

-- | Apply a <a>Reducer</a> to a <a>Foldable</a> mapping each element
--   through <a>unit</a>
foldReduce :: (Foldable f, Monoid m, Reducer e m) => f e -> m

-- | Apply a <a>Reducer</a> to a <a>Foldable1</a> mapping each element
--   through <a>unit</a>
foldReduce1 :: (Foldable1 f, Reducer e m) => f e -> m
pureUnit :: (Applicative f, Reducer c n) => c -> f n
returnUnit :: (Monad m, Reducer c n) => c -> m n
newtype Count
Count :: Int -> Count
getCount :: Count -> Int
instance Typeable Count
instance Eq Count
instance Ord Count
instance Show Count
instance Read Count
instance Data Count
instance Monoid m => Reducer m (WrappedMonoid m)
instance Ord k => Reducer (k, v) (Map k v)
instance Reducer (Int, v) (IntMap v)
instance Ord a => Reducer a (Set a)
instance Reducer Int IntSet
instance Reducer a (Seq a)
instance Measured v a => Reducer a (FingerTree v a)
instance Reducer a (Last a)
instance Reducer (Maybe a) (Last a)
instance Reducer a (First a)
instance Reducer (Maybe a) (First a)
instance Ord a => Reducer a (Max a)
instance Ord a => Reducer a (Min a)
instance Num a => Reducer a (Product a)
instance Num a => Reducer a (Sum a)
instance Semigroup a => Reducer a (Dual a)
instance Reducer (a -> a) (Endo a)
instance Reducer Bool All
instance Reducer Bool Any
instance Reducer c ()
instance Reducer c [c]
instance (Reducer c m, Reducer c n, Reducer c o, Reducer c p) => Reducer c (m, n, o, p)
instance (Reducer c m, Reducer c n, Reducer c o) => Reducer c (m, n, o)
instance (Reducer c m, Reducer c n) => Reducer c (m, n)
instance Reducer a Count
instance Monoid Count
instance Semigroup Count
instance Hashable Count


-- | Semigroups for working with <a>Applicative</a> <a>Functor</a>s.
module Data.Semigroup.Applicative

-- | A <a>Traversal</a> uses an glues together <a>Applicative</a> actions
--   with (*&gt;) in the manner of <tt>traverse_</tt> from
--   <a>Data.Foldable</a>. Any values returned by reduced actions are
--   discarded.
newtype Traversal f
Traversal :: f () -> Traversal f
getTraversal :: Traversal f -> f ()
newtype Ap f m
Ap :: f m -> Ap f m
getApp :: Ap f m -> f m
instance Functor f => Functor (Ap f)
instance Applicative f => Applicative (Ap f)
instance (Applicative f, Reducer c m) => Reducer (f c) (Ap f m)
instance (Applicative f, Monoid m) => Monoid (Ap f m)
instance (Applicative f, Semigroup m) => Semigroup (Ap f m)
instance Applicative f => Reducer (f a) (Traversal f)
instance Applicative f => Monoid (Traversal f)
instance Applicative f => Semigroup (Traversal f)


-- | A semigroup for working with <a>Alternative</a> <a>Functor</a>s.
module Data.Semigroup.Alternative

-- | A <a>Alternate</a> turns any <a>Alternative</a> instance into a
--   <a>Monoid</a>.
newtype Alternate f a
Alternate :: f a -> Alternate f a
getAlternate :: Alternate f a -> f a
instance Functor f => Functor (Alternate f)
instance Applicative f => Applicative (Alternate f)
instance Alternative f => Alternative (Alternate f)
instance Alternative f => Reducer (f a) (Alternate f a)
instance Alternative f => Monoid (Alternate f a)
instance Alternative f => Semigroup (Alternate f a)


-- | Semigroups for working with <a>Monad</a>s.
module Data.Semigroup.Monad

-- | A <a>Action</a> uses an glues together monadic actions with (&gt;&gt;)
--   in the manner of <a>mapM_</a> from <a>Data.Foldable</a>. Any values
--   returned by reduced actions are discarded.
newtype Action f
Action :: f () -> Action f
getAction :: Action f -> f ()
newtype Mon f m
Mon :: f m -> Mon f m
getMon :: Mon f m -> f m
instance Functor f => Functor (Mon f)
instance Applicative f => Applicative (Mon f)
instance Monad f => Monad (Mon f)
instance (Monad f, Reducer c m) => Reducer (f c) (Mon f m)
instance (Monad f, Monoid m) => Monoid (Mon f m)
instance (Monad f, Semigroup m) => Semigroup (Mon f m)
instance Monad f => Reducer (f a) (Action f)
instance Monad f => Monoid (Action f)
instance Monad f => Semigroup (Action f)


-- | A semigroup for working with instances of <a>MonadPlus</a>
module Data.Semigroup.MonadPlus

-- | A <a>MonadSum</a> turns any <a>MonadPlus</a> instance into a
--   <a>Monoid</a>.
newtype MonadSum f a
MonadSum :: f a -> MonadSum f a
getMonadSum :: MonadSum f a -> f a
instance Functor f => Functor (MonadSum f)
instance Applicative f => Applicative (MonadSum f)
instance Alternative f => Alternative (MonadSum f)
instance Monad f => Monad (MonadSum f)
instance MonadPlus f => MonadPlus (MonadSum f)
instance MonadPlus f => Reducer (f a) (MonadSum f a)
instance MonadPlus f => Monoid (MonadSum f a)
instance MonadPlus f => Semigroup (MonadSum f a)


module Data.Semigroup.Reducer.With

-- | If <tt>m</tt> is a <tt>c</tt>-<a>Reducer</a>, then m is <tt>(c
--   <a>WithReducer</a> m)</tt>-<a>Reducer</a> This can be used to quickly
--   select a <a>Reducer</a> for use as a <a>FingerTree</a> <a>measure</a>.
newtype WithReducer m c
WithReducer :: c -> WithReducer m c
withoutReducer :: WithReducer m c -> c
instance Eq c => Eq (WithReducer m c)
instance Ord c => Ord (WithReducer m c)
instance Show c => Show (WithReducer m c)
instance Read c => Read (WithReducer m c)
instance (Monoid m, Reducer c m) => Measured m (WithReducer m c)
instance Reducer c m => Reducer (WithReducer m c) m
instance Traversable1 (WithReducer m)
instance Foldable1 (WithReducer m)
instance Traversable (WithReducer m)
instance Foldable (WithReducer m)
instance Functor (WithReducer m)
instance Hashable c => Hashable (WithReducer m c)

module Data.Semigroup.Union

-- | A Container suitable for the <a>Union</a> <a>Monoid</a>
class HasUnion f
union :: HasUnion f => f -> f -> f
class HasUnion f => HasUnion0 f
empty :: HasUnion0 f => f

-- | The <a>Monoid</a> <tt>(<a>union</a>,<a>empty</a>)</tt>
newtype Union f
Union :: f -> Union f
getUnion :: Union f -> f

-- | Polymorphic containers that we can supply an operation to handle
--   unions with
class Functor f => HasUnionWith f
unionWith :: HasUnionWith f => (a -> a -> a) -> f a -> f a -> f a
class HasUnionWith f => HasUnionWith0 f
emptyWith :: HasUnionWith0 f => f a

-- | The <a>Monoid</a> <tt>('unionWith mappend',<a>empty</a>)</tt> for
--   containers full of monoids.
newtype UnionWith f m
UnionWith :: f m -> UnionWith f m
getUnionWith :: UnionWith f m -> f m
instance Eq f => Eq (Union f)
instance Ord f => Ord (Union f)
instance Show f => Show (Union f)
instance Read f => Read (Union f)
instance (HasUnionWith f, Semigroup m, Monoid m) => Reducer (f m) (UnionWith f m)
instance (HasUnionWith0 f, Monoid m) => Monoid (UnionWith f m)
instance (HasUnionWith f, Semigroup m) => Semigroup (UnionWith f m)
instance Ord k => HasUnionWith0 (Map k)
instance Ord k => HasUnionWith (Map k)
instance HasUnionWith0 IntMap
instance HasUnionWith IntMap
instance Traversable1 Union
instance Foldable1 Union
instance Traversable Union
instance Foldable Union
instance Functor Union
instance HasUnion f => Reducer f (Union f)
instance HasUnion0 f => Monoid (Union f)
instance HasUnion f => Semigroup (Union f)
instance (Eq a, Hashable a) => HasUnion0 (HashSet a)
instance (Eq a, Hashable a) => HasUnion (HashSet a)
instance HasUnion0 IntSet
instance HasUnion IntSet
instance Ord a => HasUnion0 (Set a)
instance Ord a => HasUnion (Set a)
instance Eq a => HasUnion0 [a]
instance Eq a => HasUnion [a]
instance Ord k => HasUnion0 (Map k a)
instance Ord k => HasUnion (Map k a)
instance (Eq k, Hashable k) => HasUnion0 (HashMap k a)
instance (Eq k, Hashable k) => HasUnion (HashMap k a)
instance HasUnion0 (IntMap a)
instance HasUnion (IntMap a)


-- | Semigroups for working with <a>Apply</a>
module Data.Semigroup.Apply

-- | A <a>Trav</a> uses an glues together <tt>Applicative</tt> actions with
--   (*&gt;) in the manner of <tt>traverse_</tt> from <a>Data.Foldable</a>.
--   Any values returned by reduced actions are discarded.
newtype Trav f
Trav :: f () -> Trav f
getTrav :: Trav f -> f ()

-- | A <a>App</a> turns any <a>Apply</a> wrapped around a <a>Semigroup</a>
--   into a <a>Semigroup</a>
newtype App f m
App :: f m -> App f m
getApp :: App f m -> f m
instance Functor f => Functor (App f)
instance Apply f => Apply (App f)
instance (Apply f, Reducer c m) => Reducer (f c) (App f m)
instance (Apply f, Semigroup m) => Semigroup (App f m)
instance Apply f => Reducer (f a) (Trav f)
instance Apply f => Semigroup (Trav f)


-- | A semigroup for working <a>Alt</a> or <a>Plus</a>
module Data.Semigroup.Alt

-- | A <a>Alter</a> turns any <a>Alt</a> instance into a <a>Semigroup</a>.
newtype Alter f a
Alter :: f a -> Alter f a
getAlter :: Alter f a -> f a
instance Functor f => Functor (Alter f)
instance Plus f => Plus (Alter f)
instance Alt f => Reducer (f a) (Alter f a)
instance Plus f => Monoid (Alter f a)
instance Alt f => Semigroup (Alter f a)
instance Alt f => Alt (Alter f)


-- | A simple <a>Monoid</a> transformer that takes a <a>Monoid</a> m and
--   produces a new <tt>m</tt>-Reducer named <a>Self</a> <tt>m</tt>
--   
--   This is useful when you have a generator that already contains
--   monoidal values or someone supplies the map to the monoid in the form
--   of a function rather than as a <a>Reducer</a> instance. You can just
--   <tt><a>getSelf</a> . <tt>reduce</tt></tt> or <tt><a>getSelf</a> .
--   <tt>mapReduce</tt> f</tt> in those scenarios. These behaviors are
--   encapsulated into the <a>fold</a> and <a>foldMap</a> combinators in
--   <a>Data.Monoid.Combinators</a> respectively.
module Data.Semigroup.Self
newtype Self m
Self :: m -> Self m
getSelf :: Self m -> m
instance Semigroup m => Semigroup (Self m)
instance Monoid m => Monoid (Self m)
instance Traversable1 Self
instance Foldable1 Self
instance Traversable Self
instance Foldable Self
instance Functor Self
instance Semigroup m => Reducer m (Self m)


-- | A <a>Generator</a> <tt>c</tt> is a possibly-specialized container,
--   which contains values of type <a>Elem</a> <tt>c</tt>, and which knows
--   how to efficiently apply a <a>Reducer</a> to extract an answer.
--   
--   Since a <a>Generator</a> is not polymorphic in its contents, it is
--   more specialized than <a>Data.Foldable.Foldable</a>, and a
--   <a>Reducer</a> may supply efficient left-to-right and right-to-left
--   reduction strategies that a <a>Generator</a> may avail itself of.
module Data.Generator

-- | minimal definition <a>mapReduce</a> or <a>mapTo</a>
class Generator c where type family Elem c mapReduce f = mapTo f mempty mapTo f m = mappend m . mapReduce f mapFrom f = mappend . mapReduce f
mapReduce :: (Generator c, Reducer e m, Monoid m) => (Elem c -> e) -> c -> m
mapTo :: (Generator c, Reducer e m, Monoid m) => (Elem c -> e) -> m -> c -> m
mapFrom :: (Generator c, Reducer e m, Monoid m) => (Elem c -> e) -> c -> m -> m

-- | a <a>Generator</a> transformer that asks only for the keys of an
--   indexed container
newtype Keys c
Keys :: c -> Keys c
getKeys :: Keys c -> c

-- | a <a>Generator</a> transformer that asks only for the values contained
--   in an indexed container
newtype Values c
Values :: c -> Values c
getValues :: Values c -> c

-- | a <a>Generator</a> transformer that treats <a>Word8</a> as <a>Char</a>
--   This lets you use a <tt>ByteString</tt> as a <a>Char</a> source
--   without going through a <a>Monoid</a> transformer like <tt>UTF8</tt>
newtype Char8 c
Char8 :: c -> Char8 c
getChar8 :: Char8 c -> c

-- | Apply a <a>Reducer</a> directly to the elements of a <a>Generator</a>
reduce :: (Generator c, Reducer (Elem c) m, Monoid m) => c -> m
mapReduceWith :: (Generator c, Reducer e m, Monoid m) => (m -> n) -> (Elem c -> e) -> c -> n
reduceWith :: (Generator c, Reducer (Elem c) m, Monoid m) => (m -> n) -> c -> n
instance Generator (Char8 ByteString)
instance Generator (Char8 ByteString)
instance Ix i => Generator (Values (Array i e))
instance Generator (Values (Map k v))
instance Generator (Values (IntMap v))
instance Ix i => Generator (Keys (Array i e))
instance Generator (Keys (Map k v))
instance Generator (Keys (IntMap v))
instance Ix i => Generator (Array i e)
instance Generator (HashMap k v)
instance Generator (Map k v)
instance Generator (IntMap v)
instance Generator (Set a)
instance Generator (HashSet a)
instance Generator IntSet
instance Generator (Seq c)
instance Measured v e => Generator (FingerTree v e)
instance Generator (NonEmpty c)
instance Generator [c]
instance Generator Text
instance Generator ByteString
instance Generator ByteString


-- | Utilities for working with Monoids that conflict with names from the
--   <a>Prelude</a>, <a>Data.Foldable</a>, <a>Control.Monad</a> or
--   elsewhere. Intended to be imported qualified.
--   
--   <pre>
--   import Data.Generator.Combinators as Generator
--   </pre>
module Data.Generator.Combinators

-- | Efficiently <a>mapReduce</a> a <a>Generator</a> using the
--   <a>Action</a> monoid. A specialized version of its namesake from
--   <a>Data.Foldable</a> and <a>Control.Monad</a>
--   
--   <pre>
--   <a>mapReduceWith</a> <a>getAction</a>
--   </pre>
mapM_ :: (Generator c, Monad m) => (Elem c -> m b) -> c -> m ()

-- | Convenience function as found in <a>Data.Foldable</a> and
--   <a>Control.Monad</a>
--   
--   <pre>
--   <a>flip</a> <a>mapM_</a>
--   </pre>
forM_ :: (Generator c, Monad m) => c -> (Elem c -> m b) -> m ()

-- | The sum of a collection of actions, generalizing <a>concat</a>
--   
--   <pre>
--   <a>reduceWith</a> <a>getMonadSum</a>
--   </pre>
msum :: (Generator c, MonadPlus m, m a ~ Elem c) => c -> m a

-- | Efficiently <a>mapReduce</a> a <a>Generator</a> using the
--   <a>Traversal</a> monoid. A specialized version of its namesake from
--   <a>Data.Foldable</a>
--   
--   <pre>
--   <a>mapReduce</a> <a>getTraversal</a>
--   </pre>
traverse_ :: (Generator c, Applicative f) => (Elem c -> f b) -> c -> f ()

-- | Convenience function as found in <a>Data.Foldable</a>
--   
--   <pre>
--   <a>flip</a> <a>traverse_</a>
--   </pre>
for_ :: (Generator c, Applicative f) => c -> (Elem c -> f b) -> f ()

-- | The sum of a collection of actions, generalizing <a>concat</a>
--   
--   <pre>
--   <a>reduceWith</a> <tt>getAlt</tt>
--   </pre>
asum :: (Generator c, Alternative f, f a ~ Elem c) => c -> f a

-- | Efficiently <a>reduce</a> a <a>Generator</a> that contains values of
--   type <a>Bool</a>
--   
--   <pre>
--   <a>reduceWith</a> <a>getAll</a>
--   </pre>
and :: (Generator c, Elem c ~ Bool) => c -> Bool

-- | Efficiently <a>reduce</a> a <a>Generator</a> that contains values of
--   type <a>Bool</a>
--   
--   <pre>
--   <a>reduceWith</a> <a>getAny</a>
--   </pre>
or :: (Generator c, Elem c ~ Bool) => c -> Bool

-- | Efficiently <a>mapReduce</a> any <a>Generator</a> checking to see if
--   any of its values match the supplied predicate
--   
--   <pre>
--   <a>mapReduceWith</a> <a>getAny</a>
--   </pre>
any :: Generator c => (Elem c -> Bool) -> c -> Bool

-- | Efficiently <a>mapReduce</a> any <a>Generator</a> checking to see if
--   all of its values match the supplied predicate
--   
--   <pre>
--   <a>mapReduceWith</a> <a>getAll</a>
--   </pre>
all :: Generator c => (Elem c -> Bool) -> c -> Bool

-- | Efficiently <a>mapReduce</a> a <a>Generator</a> using the
--   <a>WrappedMonoid</a> monoid. A specialized version of its namesake
--   from <a>Data.Foldable</a>
--   
--   <pre>
--   <a>mapReduceWith</a> <a>unwrapMonoid</a>
--   </pre>
foldMap :: (Monoid m, Generator c) => (Elem c -> m) -> c -> m

-- | Efficiently <a>reduce</a> a <a>Generator</a> using the
--   <a>WrappedMonoid</a> monoid. A specialized version of its namesake
--   from <a>Data.Foldable</a>
--   
--   <pre>
--   <a>reduceWith</a> <a>unwrapMonoid</a>
--   </pre>
fold :: (Monoid m, Generator c, Elem c ~ m) => c -> m

-- | Convert any <a>Generator</a> to a list of its contents. Specialization
--   of <a>reduce</a>
toList :: Generator c => c -> [Elem c]

-- | Type specialization of "foldMap" above
concatMap :: Generator c => (Elem c -> [b]) -> c -> [b]

-- | Check to see if <a>any</a> member of the <a>Generator</a> matches the
--   supplied value
elem :: (Generator c, Eq (Elem c)) => Elem c -> c -> Bool

-- | Efficiently <a>mapReduce</a> a subset of the elements in a
--   <a>Generator</a>
filter :: (Generator c, Reducer (Elem c) m, Monoid m) => (Elem c -> Bool) -> c -> m

-- | Allows idiomatic specialization of filter by proving a function that
--   will be used to transform the output
filterWith :: (Generator c, Reducer (Elem c) m, Monoid m) => (m -> n) -> (Elem c -> Bool) -> c -> n

-- | Efficiently sum over the members of any <a>Generator</a>
--   
--   <pre>
--   <a>reduceWith</a> <a>getSum</a>
--   </pre>
sum :: (Generator c, Num (Elem c)) => c -> Elem c

-- | Efficiently take the product of every member of a <a>Generator</a>
--   
--   <pre>
--   <a>reduceWith</a> <a>getProduct</a>
--   </pre>
product :: (Generator c, Num (Elem c)) => c -> Elem c

-- | Check to make sure that the supplied value is not a member of the
--   <a>Generator</a>
notElem :: (Generator c, Eq (Elem c)) => Elem c -> c -> Bool


-- | A <a>Generator1</a> <tt>c</tt> is a possibly-specialized container,
--   which contains values of type <a>Elem</a> <tt>c</tt>, and which knows
--   how to efficiently apply a <a>Reducer</a> to extract an answer.
--   
--   <a>Generator1</a> is to <a>Generator</a> as <a>Foldable1</a> is to
--   <tt>Foldable</tt>.
module Data.Semigroup.Generator

-- | minimal definition <a>mapReduce1</a> or <a>mapTo1</a>
class Generator c => Generator1 c where mapTo1 f m = (<>) m . mapReduce1 f mapFrom1 f = (<>) . mapReduce1 f
mapReduce1 :: (Generator1 c, Reducer e m) => (Elem c -> e) -> c -> m
mapTo1 :: (Generator1 c, Reducer e m) => (Elem c -> e) -> m -> c -> m
mapFrom1 :: (Generator1 c, Reducer e m) => (Elem c -> e) -> c -> m -> m

-- | Apply a <a>Reducer</a> directly to the elements of a <a>Generator</a>
reduce1 :: (Generator1 c, Reducer (Elem c) m) => c -> m
mapReduceWith1 :: (Generator1 c, Reducer e m) => (m -> n) -> (Elem c -> e) -> c -> n
reduceWith1 :: (Generator1 c, Reducer (Elem c) m) => (m -> n) -> c -> n
instance Generator1 (NonEmpty e)
