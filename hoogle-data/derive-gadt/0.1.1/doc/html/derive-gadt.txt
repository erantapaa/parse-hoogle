-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Instance deriving for (a subset of) GADTs.
--   
--   Very preliminary. Haddock-generated documentation in located at
--   <a>http://moonpatio.com/repos/derive-gadt/haddocks</a>.
@package derive-gadt
@version 0.1.1


-- | A clusterfrolick at the moment. Among other things, the
--   <tt>Exists</tt> con in the <tt>Type</tt> type isn't handled correctly
--   (or at all really, it's just pretended that it's <tt>Forall</tt>
--   because I don't know how to handle it).
module Language.Haskell.Derive.Gadt.Unify

-- | .
unify :: Type -> Type -> Q (Either String (Substs, Substs))
type Substs = Map Name [Type]
type SubstMap = Map Name [Name]
type UnifyMap = Map Name [Type]
data UnifyEnv
UnifyEnv :: (SubstMap, SubstMap) -> (SubstMap, SubstMap) -> Either String (Map Name (Name, Name)) -> Either String (Map Name Name) -> (UnifyMap, UnifyMap) -> [(Type, Type)] -> UnifyEnv
substMaps :: UnifyEnv -> (SubstMap, SubstMap)
isubstMaps :: UnifyEnv -> (SubstMap, SubstMap)
noDupsMap :: UnifyEnv -> Either String (Map Name (Name, Name))
finalMap :: UnifyEnv -> Either String (Map Name Name)
unifyMap :: UnifyEnv -> (UnifyMap, UnifyMap)
stragglers :: UnifyEnv -> [(Type, Type)]
varT :: String -> Type
tupT :: [Type] -> Type
listT :: Type -> Type
invertSubstMap :: SubstMap -> SubstMap
invertSubsts :: SubstMap -> SubstMap -> Map Name ([Name], [Name])
checkForDups :: Map Name ([Name], [Name]) -> Either String (Map Name (Name, Name))
extractSubsts :: UnifyEnv -> Either String (Substs, Substs)
(|.|) :: (Ord a, Ord b) => Map b c -> Map a b -> Map a c
renameT :: Type -> Type
noDupsMapToFinalSubsts :: Map Name (Name, Name) -> Either String (Map Name Name)
buildUMap :: [(Type, Type)] -> ((UnifyMap, UnifyMap), [(Type, Type)])
splitSubsts :: [(Type, Type)] -> Q UnifyEnv
matchTypes :: Type -> Type -> [(Type, Type)]
typeViaT :: ViaT Type Type Type
typeToT :: Type -> T Type
typeFromT :: T Type -> Type
firstNameMap :: Map Name [Name] -> [(Name, Type)]
isInf :: Name -> Type -> Bool
bothVars :: (Type, Type) -> Bool
varOnLeft :: (Type, Type) -> Bool
varOnRight :: (Type, Type) -> Bool
data Name
NameG :: String -> Name
NameL :: String -> Name
NameU :: String -> !Int -> Name
data Type
ArrowT :: Type
VarT :: Name -> Type
ConT :: Name -> Type
AppT :: Type -> Type -> Type
ForallT :: [Name] -> Type -> Type
ExistsT :: [Name] -> Type -> Type
ftvs :: Type -> Set Name
btvs :: Type -> Set Name
closeT :: Type -> Type
openT :: Type -> Type
(.->.) :: Type -> Type -> Type
unwindFunT :: Type -> (Type, [Type])
unwindAppT :: Type -> (Type, [Type])
substT :: [(Name, Type)] -> Type -> Type
listName :: Name
tupName :: Int -> Name
listCon :: Type
tupCon :: Int -> Type
testType0 :: Type
idType :: Type -> Type
testType1 :: Type
testType2 :: Type
pprName :: Name -> Doc
pprType :: Type -> Doc
pprParenType :: Type -> Doc
newtype Q a
Q :: (IO a) -> Q a
runQ :: Q a -> IO a
runIO :: IO a -> Q a
unQ :: Q a -> a
newName :: String -> Q Name
mkName :: String -> Name
mkNameG :: String -> Name
mkNameL :: String -> Name
mkNameU :: String -> Int -> Name
newUniq :: Q Int
gensymQ :: IORef Int
tick :: IORef Int -> Q Int
reset :: IORef Int -> Q ()
resetQ :: Q ()
newtype S s a
S :: (forall o. (a -> s -> o) -> s -> o) -> S s a
unS :: S s a -> forall o. (a -> s -> o) -> s -> o
get :: S s s
gets :: (s -> a) -> S s a
set :: s -> S s ()
modify :: (s -> s) -> S s ()
runS :: S s a -> s -> (a, s)
evalS :: S s a -> s -> a
execS :: S s a -> s -> s
type SubstM a = S SubstEnv a
data SubstEnv
SubstEnv :: Set Name -> Map Name Type -> SubstEnv
boundSet :: SubstEnv -> Set Name
substMap :: SubstEnv -> Map Name Type
initSubstEnv :: [(Name, Type)] -> SubstEnv
runSubstM :: SubstM a -> SubstEnv -> a
bindM :: Name -> SubstM ()
substM :: Name -> SubstM Type
localM :: SubstM a -> SubstM a
data T a
Tip :: a -> T a
T :: (T a) -> (T a) -> T a
toListT :: T a -> [a]
fromListT :: [a] -> [T a]
toTreeT :: (Maybe a -> b) -> T a -> Tree b
foldrT :: (a -> b -> b) -> b -> T a -> b
foldlT :: (a -> b -> a) -> a -> T b -> a
foldl'T :: (a -> b -> a) -> a -> T b -> a
sumT :: (Num a) => T a -> a
prodT :: (Num a) => T a -> a
andT :: T Bool -> Bool
orT :: T Bool -> Bool
unifyT :: (Either a (T a) -> c) -> (Either b (T b) -> d) -> (c -> d -> e) -> (T a -> T b -> T e)
zipT :: (T a -> T b -> c) -> (T a -> T b -> T c)
matchT :: (a -> T x) -> (b -> T y) -> (T x -> c) -> (T y -> d) -> (c -> d -> e) -> (a -> b -> T e)
data ViaT a b c
ViaT :: (a -> T b) -> (T b -> c) -> ViaT a b c
toT :: ViaT a b c -> a -> T b
fromT :: ViaT a b c -> T b -> c
match :: ViaT a x c -> ViaT b y d -> (c -> d -> e) -> (a -> b -> [e])
instance (Eq a) => Eq (T a)
instance (Ord a) => Ord (T a)
instance (Show a) => Show (T a)
instance (Read a) => Read (T a)
instance Eq SubstEnv
instance Ord SubstEnv
instance Read SubstEnv
instance Show SubstEnv
instance Eq Type
instance Ord Type
instance Read Type
instance Show Type
instance Eq Name
instance Ord Name
instance Read Name
instance Show Name
instance Eq UnifyEnv
instance Show UnifyEnv
instance Functor T
instance Applicative (S s)
instance MonadFix (S s)
instance Monad (S s)
instance Functor (S s)
instance Applicative Q
instance Monad Q
instance Functor Q

module Language.Haskell.Derive.Gadt.Common
data GadtInfo
GadtInfo :: Name -> Int -> [GadtConInfo] -> GadtInfo
gadtName :: GadtInfo -> Name
gadtArity :: GadtInfo -> Int
gadtCons :: GadtInfo -> [GadtConInfo]
data GadtConInfo
GadtConInfo :: Name -> Type -> [Type] -> [Name] -> [Name] -> GadtConInfo
gadtConName :: GadtConInfo -> Name
gadtConType :: GadtConInfo -> Type
gadtConArgs :: GadtConInfo -> [Type]
gadtConBound :: GadtConInfo -> [Name]
gadtConFree :: GadtConInfo -> [Name]
instanceGroups :: GadtInfo -> [(Type, [(Name, Int)])]
groupCons :: GadtInfo -> [(Name, [Name])]
unifiedGroups :: [GadtConInfo] -> [(Name, [(Name, (Substs, Substs))])]
isExistential :: GadtConInfo -> Bool
existentials :: GadtConInfo -> [Name]
gadtInfo :: Decl -> [GadtInfo]
gadtConInfo :: GadtDecl -> GadtConInfo
arityGadt :: [TyVarBind] -> Maybe Kind -> Int
parseModuleGadts :: String -> Either String [GadtInfo]
kindArity :: Kind -> Int
tvbName :: TyVarBind -> Name
unwindType :: Type -> (Type, [Type])
splitTypeApps :: Type -> (Type, [Type])
isTyVar :: Type -> Bool
getTopTyVars :: [Type] -> [(Name, Int)]
ftvs :: Type -> Set Name
isMono :: Type -> Bool
srcExtsTypeToUnifyType :: Type -> Type
myParseType :: String -> Type
nameToUName :: Name -> Name
qnameToUName :: QName -> Name
myParseModule :: String -> Either String Module
myParseMode :: ParseMode
myExtensions :: [Extension]
mkFunD :: Name -> [Pat] -> Exp -> Dec
mkClauseQ :: [PatQ] -> ExpQ -> ClauseQ
instance Show GadtConInfo
instance Show GadtInfo

module Language.Haskell.Derive.Gadt.Class.Ord
deriveOrdGadts :: String -> Q [Dec]
deriveOrdGadtInfo :: GadtInfo -> Q [Dec]
deriveOrdConsQ :: Type -> [(String, Int)] -> Q [Dec]
mkCompareE :: Type -> [(String, Int)] -> Name -> Name -> ExpQ
mkGo :: [(String, Int)] -> Q [Dec]
mkTagMap :: [String] -> Q [Dec]
mkCompareSame :: String -> Int -> ClauseQ
mkCompareDiff :: ClauseQ

module Language.Haskell.Derive.Gadt.Class.Read
deriveReadGadts :: String -> Q [Dec]
deriveReadGadtInfo :: GadtInfo -> Q [Dec]
deriveReadConsQ :: Type -> [(String, Int)] -> Q [Dec]

module Language.Haskell.Derive.Gadt.Class.Eq
deriveEqGadts :: String -> Q [Dec]
deriveEqGadtInfo :: GadtInfo -> Q [Dec]
deriveEqConsQ :: Type -> [(String, Int)] -> Q [Dec]
mkEqFunD :: String -> Int -> Q Dec

module Language.Haskell.Derive.Gadt.Class.Show
deriveShowGadts :: String -> Q [Dec]
deriveShowGadtInfo :: GadtInfo -> Q [Dec]
data GadtShowInfo
GadtShowInfo :: Name -> Int -> [Int] -> [(Name, Int)] -> GadtShowInfo
gadtShowName :: GadtShowInfo -> Name
gadtShowArity :: GadtShowInfo -> Int
gadtShowCxt :: GadtShowInfo -> [Int]
gadtShowCons :: GadtShowInfo -> [(Name, Int)]
gadtShowInfo :: GadtInfo -> GadtShowInfo
collectShowCxt :: GadtConInfo -> [Int]
deriveShowGadtShowInfo :: GadtShowInfo -> Q [Dec]
mkShowFunDs :: [(Name, Int)] -> Q [Dec]
instance Show GadtShowInfo

module Language.Haskell.Derive.Gadt
