-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | library to make electronic music, brings together temporal-music-notation and csound-expression packages
--   
@package temporal-csound
@version 0.4.3.1


-- | Defines instance of <a>CsdSco</a> for <a>Score</a> and reexports all
--   functions from packages csound-expression and
--   temporal-music-notation-western.
--   
--   We can trigger Csound orchestra with <a>Score</a>.
--   
--   How to put the values in the container <a>Score</a>? There are many
--   functions to construct the <a>Score</a>.
--   
--   They live in the module <a>Temporal.Music.Score</a>. If you are not
--   familiar with it, you can start with six basic functions.
--   
--   <ul>
--   <li><a>rest</a> -- makes a pause that lasts for some time (in
--   seconds).</li>
--   <li><a>temp</a> -- makes a score of one note that lasts for one
--   second.</li>
--   <li><a>mel</a> -- plays a list of notes in sequence (one after the
--   other, short for <tt>melody</tt>).</li>
--   <li><a>har</a> -- plays a list of notes in parallel (at the same time,
--   short for <tt>harmony</tt>).</li>
--   <li><a>del</a> -- delays all notes for some time (short for
--   <tt>delay</tt>).</li>
--   <li><a>str</a> -- change the tempo for all notes by the given ratio
--   (short for <tt>stretch</tt>).</li>
--   </ul>
--   
--   Let's play something:
--   
--   <pre>
--   res = str 0.5 $ mel [ temp a, str 2 $ temp b, rest 1, har [temp a, temp b] ]
--   </pre>
--   
--   There are two handy infix operators for delay and stretch:
--   <tt>(+|)</tt> and <tt>(*|)</tt>. So we can write the previous score:
--   
--   <pre>
--   res = 0.5 *| mel [ temp a, 2 *| temp b, 1 +| har [temp a, temp b] ]
--   </pre>
--   
--   There are shortcuts for notes in western notation (a is 440 Hz).
--   
--   <pre>
--   a, b, c, d, e, f, g
--   </pre>
--   
--   Notes reside in the same octave. To get the notes in higher or lower
--   octaves we can apply the functions:
--   
--   <ul>
--   <li><a>high</a>, <a>low</a> -- take note an octaver higher or
--   lower</li>
--   <li><a>higher</a> n, <a>lower</a> n -- take note for <tt>n</tt>
--   octaves higher or lower</li>
--   </ul>
--   
--   There are shortcuts for stretching the notes and rests:
--   
--   <pre>
--   bn, wn, qn, en, sn -- brevis, whole, quarter, eight, sixteenth notes
--   </pre>
--   
--   and for rests
--   
--   <pre>
--   bnr, wnr, qnr, enr, snr
--   </pre>
--   
--   These functions transform the melodies with given factors. We can
--   construct melodies:
--   
--   <pre>
--   melody = mel [qn $ mel [c, e, g], bn $ har [c, e, g, high c], wnr]
--   </pre>
--   
--   Then we can apply a csound instrument to the melody to get the signal.
--   
--   <pre>
--   res = notes someInstr melody
--   </pre>
--   
--   Now let's mix it to the signal and send the output to speakers:
--   
--   <pre>
--   dac $ mix res 
--   </pre>
--   
--   WARNING: The function <a>dac</a> spawns a csound process in the
--   background which can run forever. If your haskell build tool doesn't
--   kills the child processes with haskell-runing process (As far as I
--   know Sublime Editor doesn't, but vim does) it's better to run the
--   program from ghci and to stop it press <tt>Ctrl+C</tt>:
--   
--   <pre>
--   % ghci MyMusic
--   MyMusic&gt; main 
--   
--      ... The programm runs ... press Ctrl+C to stop it
--   </pre>
--   
--   <tt>runhaskell</tt> doesn't stop the child process. So it's better to
--   use the <tt>dac</tt> function with terminal.
--   
--   If signal is to loud or to quiet we can scale it:
--   
--   <pre>
--   dac $ mul factor $ mix res 
--   </pre>
--   
--   We can make it brighter with reverb (<a>smallRoom</a>,
--   <a>smallHall</a>, <a>largeHall</a>, <a>reverTime</a>)
--   
--   <pre>
--   dac $ mul 0.2 $ smallHall $ mix res 
--   </pre>
module Csound

-- | Contains amplitude, frequency and auxiliary parameters.
--   
--   <pre>
--   (amplitude, frequencyInHz, timbralParameters)
--   </pre>
type CsdNote a = (D, D, a)

-- | Converts the <tt>Note</tt> to low level <tt>CsdNote</tt>.
csdNote :: Default a => Note a -> CsdNote a

-- | Contains amplitude and auxiliary parameters.
--   
--   <pre>
--   (amplitude, timbralParameters)
--   </pre>
type CsdDrum a = (D, a)

-- | Converts the <tt>Note</tt> to low level <tt>CsdNote</tt>.
csdDrum :: Default a => Drum a -> CsdDrum a
type N = CsdNote Unit
type Dr = CsdDrum Unit

-- | Plays the notes with csound instrument.
notes :: (Arg a, Default a, Outs b) => (CsdNote a -> b) -> Score (Note a) -> Score (Mix (SigOuts b))

-- | Plays the drum notes with csound instrument.
drums :: (Arg a, Default a, Outs b) => (CsdDrum a -> b) -> Score (Drum a) -> Score (Mix (SigOuts b))

-- | Triggers an instrument on all midi-channels.
onMidi :: (Default a, Outs b, Num (SigOuts b)) => (CsdNote a -> b) -> SE (SigOuts b)

-- | Triggers an instrument on the given midi-channel.
onMidin :: (Default a, Outs b, Num (SigOuts b)) => Channel -> (CsdNote a -> b) -> SE (SigOuts b)

-- | Triggers an instrument on channel and programm bank.
onPgmidi :: (Default a, Outs b, Num (SigOuts b)) => Maybe Int -> Channel -> (CsdNote a -> b) -> SE (SigOuts b)

-- | Just like <tt>onMidi</tt> but takes a value for default auxiliary
--   parameters.
onMidiWith :: (Outs b, Num (SigOuts b)) => a -> (CsdNote a -> b) -> SE (SigOuts b)

-- | Just like <tt>onMidin</tt> but takes a value for default auxiliary
--   parameters.
onMidinWith :: (Outs b, Num (SigOuts b)) => a -> Channel -> (CsdNote a -> b) -> SE (SigOuts b)

-- | Just like <tt>onPgmidi</tt> but takes a value for default auxiliary
--   parameters.
onPgmidiWith :: (Outs b, Num (SigOuts b)) => a -> Maybe Int -> Channel -> (CsdNote a -> b) -> SE (SigOuts b)
instance CsdSco (Track Double)


-- | Converters for the instruments.
module Csound.Converter
fromF :: SigSpace a => (D -> a) -> CsdNote Unit -> a
fromFs :: SigSpace a => (Sig -> a) -> CsdNote Unit -> a
fromAF :: (D -> D -> a) -> CsdNote Unit -> a
fromAsFs :: (Sig -> Sig -> a) -> CsdNote Unit -> a
fromAFs :: (D -> Sig -> a) -> CsdNote Unit -> a
fromAsF :: (Sig -> D -> a) -> CsdNote Unit -> a
fromDrum :: SigSpace a => a -> Dr -> a


-- | Ready to use instruments.
--   
--   An instrument takes in a note (<tt>N</tt> which is shortcut for
--   <tt>CsdNote Unit</tt> or <tt>Dr</tt> which is shortcut for <tt>CsdDrum
--   Unit</tt>) and procuces a signal. We can use instruments with
--   functions <a>notes</a> and <a>drums</a>.
--   
--   <pre>
--   import Csound 
--   import Csound.Patch(stringPad)
--   
--   -- | Plays C-major chord.
--   main = dac $ mul 0.2 $ smallHall $ mix $ notes stringPad $	
--   	 str 0.5 $ mel [c, e, g, str 4 $ har [c, e, g, high c], rest 4]
--   </pre>
--   
--   Let's explain the functions:
--   
--   <pre>
--   -- dac -- sends signal to speakers
--   -- 
--   -- mul -- scales the signal
--   -- 
--   -- smallHall -- adds a reverb
--   --
--   -- mix -- mixes several tracks to a single signal
--   --
--   -- notes -- applies an instrument to the notes
--   --
--   -- stringPad -- predefined instrument
--   -- 
--   -- str -- stretch the notes in time domain
--   --
--   -- mel, har -- sequential and parallel composition of the notes
--   --
--   -- c, e, g -- notes in western notation (a, b, c, d, ...), a is 440 Hz 
--   --
--   -- high -- an octave higher
--   --
--   -- rest -- pause for a given amount of time
--   </pre>
module Csound.Patch
stringPad :: N -> Sig
phasingSynth :: N -> Sig
pulseWidthPad :: N -> Sig
melodica :: N -> SE Sig

-- | Parameter is time of fade out in seconds.
tibetan :: D -> N -> Sig
sparkles :: N -> SE Sig
xanaduHarp :: N -> SE Sig
delaySaw :: N -> Sig
pulseWidth :: N -> Sig
toneWheel :: N -> Sig
okComp :: CsdDrum OkCompParam -> SE Sig
newtype OkCompParam
OkCompParam :: D -> OkCompParam
unOkCompParam :: OkCompParam -> D
fmMod :: N -> Sig
delayedStringLong :: N -> Sig
delayedStringShort :: N -> Sig
plucked :: N -> Sig
xanadu1 :: N -> SE Sig
xanadu2 :: N -> SE Sig
guitar :: N -> Sig
harpsichord :: N -> Sig
harpsichordHarp :: N -> Sig
plainString :: N -> Sig
plainStringHarp :: N -> Sig
noisyMarimba :: N -> SE Sig
dahina :: N -> Sig
banyan :: N -> Sig
xylophone :: N -> Sig
spinelSphere :: N -> Sig
aluminumBar :: N -> Sig
vibraphone1 :: N -> Sig
vibraphone2 :: N -> Sig
wineGlass :: N -> Sig
xing :: N -> Sig
amBell :: N -> Sig
fmTubularBell :: N -> Sig
tubularBell :: N -> Sig
albertClockBellBelfast :: N -> Sig
dumb :: Dr -> SE Sig
dumbBass :: Dr -> SE Sig
pluckSnare :: Dr -> Sig
knockSweep :: Dr -> SE Sig
metalBoink :: Dr -> Sig
snare :: Dr -> SE Sig
openHihat :: Dr -> SE Sig
closedHihat :: Dr -> SE Sig
bassDrum :: D -> Dr -> Sig

-- | Recommended values for frequency parameter <tt>cpspch(13.03) -
--   cpspch(13.10)</tt>
crash :: D -> Dr -> SE Sig
handClap :: D -> Dr -> SE Sig
bambooDr :: Dr -> Sig
guiroDr :: Dr -> Sig
tambourineDr :: Dr -> Sig
cabasaDr :: Dr -> Sig
crunchDr :: Dr -> Sig
sleighbellsDr :: Dr -> Sig
sekereDr :: Dr -> Sig
sandpaperDr :: Dr -> Sig
instance Default OkCompParam
instance Arg OkCompParam
instance Tuple OkCompParam
