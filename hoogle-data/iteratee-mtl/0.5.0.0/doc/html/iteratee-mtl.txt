-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Iteratee-based I/O
--   
--   The Iteratee monad provides strict, safe, and functional I/O. In
--   addition to pure Iteratee processors, file IO and combinator functions
--   are provided.
@package iteratee-mtl
@version 0.5.0.0


-- | Monadic Iteratees: incremental input parsers, processors, and
--   transformers
--   
--   Maps over restricted-element containers
module Data.Iteratee.Base.LooseMap

-- | Enable map functions for containers that require class contexts on the
--   element types. For lists, this is identical to plain <a>map</a>.
class LooseMap c el el'
lMap :: LooseMap c el el' => (el -> el') -> c el -> c el'
instance LooseMap [] el el'


-- | NullPoint: Pointed types (usually containers) that can be empty.
--   Corresponds to Data.Monoid.mempty
module Data.NullPoint

-- | NullPoint class. Containers that have a null representation,
--   corresponding to Data.Monoid.mempty.
class NullPoint c
empty :: NullPoint c => c
instance NullPoint ByteString
instance NullPoint [a]


-- | Nullable: test if a type (container) is null.
module Data.Nullable

-- | Nullable container class
class NullPoint c => Nullable c
null :: Nullable c => c -> Bool
instance Nullable ByteString
instance Nullable [a]


-- | Monadic Iteratees: incremental input parsers, processors and
--   transformers
--   
--   Support for IO enumerators
module Data.Iteratee.Base.ReadableChunk

-- | Class of streams which can be filled from a <a>Ptr</a>. Typically
--   these are streams which can be read from a file, <tt>Handle</tt>, or
--   similar resource.
class Storable el => ReadableChunk s el | s -> el
readFromPtr :: (ReadableChunk s el, MonadIO m) => Ptr el -> Int -> m s
instance ReadableChunk ByteString Word8
instance ReadableChunk [Word] Word
instance ReadableChunk [Word32] Word32
instance ReadableChunk [Word16] Word16
instance ReadableChunk [Word8] Word8
instance ReadableChunk [Char] Char

module Data.Iteratee.IO.Posix
type FileOffset = COff

-- | Alas, GHC provides no function to read from Fd to an allocated buffer.
--   The library function fdRead is not appropriate as it returns a string
--   already. I'd rather get data from a buffer. Furthermore, fdRead (at
--   least in GHC) allocates a new buffer each time it is called. This is a
--   waste. Yet another problem with fdRead is in raising an exception on
--   any IOError or even EOF. I'd rather avoid exceptions altogether.
myfdRead :: Fd -> Ptr CChar -> ByteCount -> IO (Either Errno ByteCount)

-- | The following fseek procedure throws no exceptions.
myfdSeek :: Fd -> SeekMode -> FileOffset -> IO (Either Errno FileOffset)

-- | Haskell representation for <tt>errno</tt> values. The implementation
--   is deliberately exposed, to allow users to add their own definitions
--   of <a>Errno</a> values.
newtype Errno :: *
Errno :: CInt -> Errno

-- | poll if file descriptors have something to read Return the list of
--   read-pending descriptors
select'read'pending :: [Fd] -> IO (Either Errno [Fd])


-- | Monadic and General Iteratees: Messaging and exception handling.
--   
--   Iteratees use an internal exception handling mechanism that is
--   parallel to that provided by <tt>Control.Exception</tt>. This allows
--   the iteratee framework to handle its own exceptions outside
--   <tt>IO</tt>.
--   
--   Iteratee exceptions are divided into two categories,
--   <a>IterException</a> and <a>EnumException</a>. <tt>IterExceptions</tt>
--   are exceptions within an iteratee, and <tt>EnumExceptions</tt> are
--   exceptions within an enumerator.
--   
--   Enumerators can be constructed to handle an <a>IterException</a> with
--   <tt>Data.Iteratee.Iteratee.enumFromCallbackCatch</tt>. If the
--   enumerator detects an <tt>iteratee exception</tt>, the enumerator
--   calls the provided exception handler. The enumerator is then able to
--   continue feeding data to the iteratee, provided the exception was
--   successfully handled. If the handler could not handle the exception,
--   the <a>IterException</a> is converted to an <a>EnumException</a> and
--   processing aborts.
--   
--   Exceptions can also be cleared by
--   <tt>Data.Iteratee.Iteratee.checkErr</tt>, although in this case the
--   iteratee continuation cannot be recovered.
--   
--   When viewed as Resumable Exceptions, iteratee exceptions provide a
--   means for iteratees to send control messages to enumerators. The
--   <tt>seek</tt> implementation provides an example.
--   <tt>Data.Iteratee.Iteratee.seek</tt> stores the current iteratee
--   continuation and throws a <a>SeekException</a>, which inherits from
--   <a>IterException</a>. <tt>Data.Iteratee.IO.enumHandleRandom</tt> is
--   constructed with <tt>enumFromCallbackCatch</tt> and a handler that
--   performs an <tt>hSeek</tt>. Upon receiving the <a>SeekException</a>,
--   <tt>enumHandleRandom</tt> calls the handler, checks that it executed
--   properly, and then continues with the stored continuation.
--   
--   As the exception hierarchy is open, users can extend it with custom
--   exceptions and exception handlers to implement sophisticated messaging
--   systems based upon resumable exceptions.
module Data.Iteratee.Exception

-- | Root of the Iteratee exception hierarchy. <tt>IFException</tt> derives
--   from <tt>Control.Exception.SomeException</tt>. <a>EnumException</a>,
--   <a>IterException</a>, and all inheritants are descendents of
--   <a>IFException</a>.
data IFException
IFException :: e -> IFException
data EnumException
EnumException :: e -> EnumException

-- | The <tt>iteratee</tt> diverged upon receiving <tt>EOF</tt>.
data DivergentException
DivergentException :: DivergentException

-- | Create an enumerator exception from a <tt>String</tt>.
data EnumStringException
EnumStringException :: String -> EnumStringException

-- | The enumerator received an <a>IterException</a> it could not handle.
data EnumUnhandledIterException
EnumUnhandledIterException :: IterException -> EnumUnhandledIterException

-- | A class for <tt>iteratee exceptions</tt>. Only inheritants of
--   <tt>IterException</tt> should be instances of this class.
class Exception e => IException e
toIterException :: IException e => e -> IterException
fromIterException :: IException e => IterException -> Maybe e

-- | Root of iteratee exceptions.
data IterException
IterException :: e -> IterException

-- | A seek request within an <tt>Iteratee</tt>.
data SeekException
SeekException :: FileOffset -> SeekException

-- | The <tt>Iteratee</tt> needs more data but received <tt>EOF</tt>.
data EofException
EofException :: EofException

-- | An <tt>Iteratee exception</tt> specified by a <tt>String</tt>.
data IterStringException
IterStringException :: String -> IterStringException

-- | Create an <a>EnumException</a> from a string.
enStrExc :: String -> EnumException

-- | Create an <tt>iteratee exception</tt> from a string. This convenience
--   function wraps <a>IterStringException</a> and <a>toException</a>.
iterStrExc :: String -> SomeException

-- | Convert an <a>IterException</a> to an <a>EnumException</a>. Meant to
--   be used within an <tt>Enumerator</tt> to signify that it could not
--   handle the <tt>IterException</tt>.
wrapIterExc :: IterException -> EnumException
instance Typeable IterStringException
instance Typeable EofException
instance Typeable SeekException
instance Typeable IterException
instance Typeable EnumUnhandledIterException
instance Typeable EnumStringException
instance Typeable DivergentException
instance Typeable EnumException
instance Typeable IFException
instance Show IterStringException
instance Show EofException
instance Show SeekException
instance Show EnumUnhandledIterException
instance Show EnumStringException
instance Show DivergentException
instance IException IterStringException
instance Exception IterStringException
instance IException EofException
instance Exception EofException
instance IException SeekException
instance Exception SeekException
instance IException IterException
instance Exception IterException
instance Show IterException
instance Exception EnumUnhandledIterException
instance Exception EnumStringException
instance Exception DivergentException
instance Exception EnumException
instance Show EnumException
instance Exception IFException
instance Show IFException


-- | Monadic Iteratees: incremental input parsers, processors and
--   transformers
module Data.Iteratee.Base

-- | A stream is a (continuing) sequence of elements bundled in Chunks. The
--   first variant indicates termination of the stream. Chunk a gives the
--   currently available part of the stream. The stream is not terminated
--   yet. The case (null Chunk) signifies a stream with no currently
--   available data but which is still continuing. A stream processor
--   should, informally speaking, ``suspend itself'' and wait for more data
--   to arrive.
data Stream c
EOF :: (Maybe SomeException) -> Stream c
Chunk :: c -> Stream c

-- | Describe the status of a stream of data.
data StreamStatus
DataRemaining :: StreamStatus
EofNoError :: StreamStatus
EofError :: SomeException -> StreamStatus

-- | Monadic iteratee
newtype Iteratee s m a
Iteratee :: (forall r. (a -> Stream s -> m r) -> ((Stream s -> Iteratee s m a) -> Maybe SomeException -> m r) -> m r) -> Iteratee s m a
runIter :: Iteratee s m a -> forall r. (a -> Stream s -> m r) -> ((Stream s -> Iteratee s m a) -> Maybe SomeException -> m r) -> m r

-- | Send <a>EOF</a> to the <tt>Iteratee</tt> and disregard the unconsumed
--   part of the stream. If the iteratee is in an exception state, that
--   exception is thrown with <tt>Control.Exception.throw</tt>. Iteratees
--   that do not terminate on <tt>EOF</tt> will throw <a>EofException</a>.
run :: Monad m => Iteratee s m a -> m a

-- | Run an iteratee, returning either the result or the iteratee
--   exception. Note that only internal iteratee exceptions will be
--   returned; exceptions thrown with <tt>Control.Exception.throw</tt> or
--   <tt>Control.Monad.CatchIO.throw</tt> will not be returned. See
--   <a>IFException</a> for details.
tryRun :: (Exception e, Monad m) => Iteratee s m a -> m (Either e a)

-- | Transform a computation inside an <tt>Iteratee</tt>.
mapIteratee :: (NullPoint s, Monad n, Monad m) => (m a -> n b) -> Iteratee s m a -> Iteratee s n b
idone :: Monad m => a -> Stream s -> Iteratee s m a
icont :: (Stream s -> Iteratee s m a) -> Maybe SomeException -> Iteratee s m a
liftI :: Monad m => (Stream s -> Iteratee s m a) -> Iteratee s m a
idoneM :: Monad m => a -> Stream s -> m (Iteratee s m a)
icontM :: Monad m => (Stream s -> Iteratee s m a) -> Maybe SomeException -> m (Iteratee s m a)

-- | Produce the <a>EOF</a> error message. If the stream was terminated
--   because of an error, keep the error message.
setEOF :: Stream c -> SomeException
instance Typeable StreamStatus
instance Typeable1 Stream
instance Show StreamStatus
instance Show c => Show (Stream c)
instance (MonadCatchIO m, Nullable s, NullPoint s) => MonadCatchIO (Iteratee s m)
instance (MonadIO m, Nullable s, NullPoint s) => MonadIO (Iteratee s m)
instance NullPoint s => MonadTrans (Iteratee s)
instance (Monad m, Nullable s) => Monad (Iteratee s m)
instance (Functor m, Monad m, Nullable s) => Applicative (Iteratee s m)
instance (Functor m, Monad m) => Functor (Iteratee s m)
instance Functor Stream
instance Monoid c => Monoid (Stream c)
instance Eq c => Eq (Stream c)


-- | Monadic and General Iteratees: incremental input parsers, processors
--   and transformers
module Data.Iteratee.Iteratee

-- | Report and propagate an unrecoverable error. Disregard the input first
--   and then propagate the error. This error cannot be handled by
--   <a>enumFromCallbackCatch</a>, although it can be cleared by
--   <a>checkErr</a>.
throwErr :: Monad m => SomeException -> Iteratee s m a

-- | Report and propagate a recoverable error. This error can be handled by
--   both <a>enumFromCallbackCatch</a> and <a>checkErr</a>.
throwRecoverableErr :: Monad m => SomeException -> (Stream s -> Iteratee s m a) -> Iteratee s m a

-- | Check if an iteratee produces an error. Returns <tt>Right a</tt> if it
--   completes without errors, otherwise <tt>Left SomeException</tt>.
--   <a>checkErr</a> is useful for iteratees that may not terminate, such
--   as <tt>Data.Iteratee.head</tt> with an empty stream.
checkErr :: (Monad m, NullPoint s) => Iteratee s m a -> Iteratee s m (Either SomeException a)

-- | The identity iteratee. Doesn't do any processing of input.
identity :: (Monad m, NullPoint s) => Iteratee s m ()

-- | Skip the rest of the stream
skipToEof :: Monad m => Iteratee s m ()

-- | Get the stream status of an iteratee.
isStreamFinished :: Monad m => Iteratee s m (Maybe SomeException)

-- | Convert one stream into another, not necessarily in lockstep. The
--   transformer mapStream maps one element of the outer stream to one
--   element of the nested stream. The transformer below is more general:
--   it may take several elements of the outer stream to produce one
--   element of the inner stream, or the other way around. The
--   transformation from one stream to the other is specified as Iteratee s
--   el s'.
convStream :: (Monad m, Nullable s) => Iteratee s m s' -> Enumeratee s s' m a

-- | The most general stream converter. Given a function to produce
--   iteratee transformers and an initial state, convert the stream using
--   iteratees generated by the function while continually updating the
--   internal state.
unfoldConvStream :: (Monad m, Nullable s) => (acc -> Iteratee s m (acc, s')) -> acc -> Enumeratee s s' m a
joinI :: (Monad m, Nullable s) => Iteratee s m (Iteratee s' m a) -> Iteratee s m a
joinIM :: Monad m => m (Iteratee s m a) -> Iteratee s m a

-- | Each enumerator takes an iteratee and returns an iteratee an
--   Enumerator is an iteratee transformer. The enumerator normally stops
--   when the stream is terminated or when the iteratee moves to the done
--   state, whichever comes first. When to stop is of course up to the
--   enumerator...
type Enumerator s m a = Iteratee s m a -> m (Iteratee s m a)
type Enumeratee sFrom sTo m :: (* -> *) a = Iteratee sTo m a -> Iteratee sFrom m (Iteratee sTo m a)

-- | Applies the iteratee to the given stream. This wraps <a>enumEof</a>,
--   <a>enumErr</a>, and <a>enumPure1Chunk</a>, calling the appropriate
--   enumerator based upon <a>Stream</a>.
enumChunk :: Monad m => Stream s -> Enumerator s m a

-- | The most primitive enumerator: applies the iteratee to the terminated
--   stream. The result is the iteratee in the Done state. It is an error
--   if the iteratee does not terminate on EOF.
enumEof :: Monad m => Enumerator s m a

-- | Another primitive enumerator: tell the Iteratee the stream terminated
--   with an error.
enumErr :: (Exception e, Monad m) => e -> Enumerator s m a

-- | The pure 1-chunk enumerator It passes a given list of elements to the
--   iteratee in one chunk This enumerator does no IO and is useful for
--   testing of base parsing
enumPure1Chunk :: Monad m => s -> Enumerator s m a

-- | Checks if an iteratee has finished. This enumerator runs the iteratee,
--   performing any monadic actions. If the result is True, the returned
--   iteratee is done.
enumCheckIfDone :: Monad m => Iteratee s m a -> m (Bool, Iteratee s m a)

-- | Create an enumerator from a callback function
enumFromCallback :: (Monad m, NullPoint s) => (st -> m (Either SomeException ((Bool, st), s))) -> st -> Enumerator s m a

-- | Create an enumerator from a callback function with an exception
--   handler. The exception handler is called if an iteratee reports an
--   exception.
enumFromCallbackCatch :: (IException e, Monad m, NullPoint s) => (st -> m (Either SomeException ((Bool, st), s))) -> (e -> m (Maybe EnumException)) -> st -> Enumerator s m a

-- | The composition of two enumerators: essentially the functional
--   composition It is convenient to flip the order of the arguments of the
--   composition though: in e1 &gt;&gt;&gt; e2, e1 is executed first
(>>>) :: Monad m => Enumerator s m a -> Enumerator s m a -> Enumerator s m a
eneeCheckIfDone :: (Monad m, NullPoint elo) => ((Stream eli -> Iteratee eli m a) -> Iteratee elo m (Iteratee eli m a)) -> Enumeratee elo eli m a

-- | Seek to a position in the stream
seek :: (Monad m, NullPoint s) => FileOffset -> Iteratee s m ()
type FileOffset = COff
instance Typeable NotAnException
instance Show NotAnException
instance IException NotAnException
instance Exception NotAnException


-- | Monadic Iteratees: incremental input parsers, processors and
--   transformers
--   
--   This module provides many basic iteratees from which more complicated
--   iteratees can be built. In general these iteratees parallel those in
--   <tt>Data.List</tt>, with some additions.
module Data.Iteratee.ListLike

-- | Check if a stream has received <a>EOF</a>.
isFinished :: (Monad m, Nullable s) => Iteratee s m Bool

-- | Read a stream to the end and return all of its elements as a list.
--   This iteratee returns all data from the stream *strictly*.
stream2list :: (Monad m, Nullable s, ListLike s el) => Iteratee s m [el]

-- | Read a stream to the end and return all of its elements as a stream.
--   This iteratee returns all data from the stream *strictly*.
stream2stream :: (Monad m, Nullable s, Monoid s) => Iteratee s m s

-- | Takes an element predicate and returns the (possibly empty) prefix of
--   the stream. None of the characters in the string satisfy the character
--   predicate. If the stream is not terminated, the first character of the
--   remaining stream satisfies the predicate.
--   
--   The analogue of <tt>List.break</tt>
break :: (Monad m, ListLike s el) => (el -> Bool) -> Iteratee s m s

-- | Skip all elements while the predicate is true.
--   
--   The analogue of <tt>List.dropWhile</tt>
dropWhile :: (Monad m, ListLike s el) => (el -> Bool) -> Iteratee s m ()

-- | Drop n elements of the stream, if there are that many.
--   
--   The analogue of <tt>List.drop</tt>
drop :: (Monad m, Nullable s, ListLike s el) => Int -> Iteratee s m ()

-- | Attempt to read the next element of the stream and return it Raise a
--   (recoverable) error if the stream is terminated
--   
--   The analogue of <tt>List.head</tt>
head :: (Monad m, ListLike s el) => Iteratee s m el

-- | Given a sequence of characters, attempt to match them against the
--   characters on the stream. Return the count of how many characters
--   matched. The matched characters are removed from the stream. For
--   example, if the stream contains <a>abd</a>, then (heads <a>abc</a>)
--   will remove the characters <a>ab</a> and return 2.
heads :: (Monad m, Nullable s, ListLike s el, Eq el) => s -> Iteratee s m Int

-- | Look ahead at the next element of the stream, without removing it from
--   the stream. Return <tt>Just c</tt> if successful, return
--   <tt>Nothing</tt> if the stream is terminated by EOF.
peek :: (Monad m, ListLike s el) => Iteratee s m (Maybe el)

-- | Return a chunk of <tt>t</tt> elements length, while consuming
--   <tt>d</tt> elements from the stream. Useful for creating a <a>rolling
--   average</a> with convStream.
roll :: (Monad m, Functor m, Nullable s, ListLike s el, ListLike s' s) => Int -> Int -> Iteratee s m s'

-- | Return the total length of the remaining part of the stream. This
--   forces evaluation of the entire stream.
--   
--   The analogue of <tt>List.length</tt>
length :: (Monad m, Num a, ListLike s el) => Iteratee s m a

-- | Read n elements from a stream and apply the given iteratee to the
--   stream of the read elements. Unless the stream is terminated early, we
--   read exactly n elements, even if the iteratee has accepted fewer.
--   
--   The analogue of <tt>List.take</tt>
take :: (Monad m, Nullable s, ListLike s el) => Int -> Enumeratee s s m a

-- | Read n elements from a stream and apply the given iteratee to the
--   stream of the read elements. If the given iteratee accepted fewer
--   elements, we stop. This is the variation of <a>take</a> with the early
--   termination of processing of the outer stream once the processing of
--   the inner stream finished early.
--   
--   N.B. If the inner iteratee finishes early, remaining data within the
--   current chunk will be dropped.
takeUpTo :: (Monad m, Nullable s, ListLike s el) => Int -> Enumeratee s s m a

-- | Map the stream: another iteratee transformer Given the stream of
--   elements of the type <tt>el</tt> and the function <tt>el-&gt;el'</tt>,
--   build a nested stream of elements of the type <tt>el'</tt> and apply
--   the given iteratee to it.
--   
--   The analog of <tt>List.map</tt>
mapStream :: (Monad m, ListLike (s el) el, ListLike (s el') el', NullPoint (s el), LooseMap s el el') => (el -> el') -> Enumeratee (s el) (s el') m a

-- | Map the stream rigidly.
--   
--   Like <a>mapStream</a>, but the element type cannot change. This
--   function is necessary for <tt>ByteString</tt> and similar types that
--   cannot have <a>LooseMap</a> instances, and may be more efficient.
rigidMapStream :: (Monad m, ListLike s el, NullPoint s) => (el -> el) -> Enumeratee s s m a

-- | Creates an <tt>enumeratee</tt> with only elements from the stream that
--   satisfy the predicate function. The outer stream is completely
--   consumed.
--   
--   The analogue of <tt>List.filter</tt>
filter :: (Monad m, Nullable s, ListLike s el) => (el -> Bool) -> Enumeratee s s m a

-- | Left-associative fold.
--   
--   The analogue of <tt>List.foldl</tt>
foldl :: (Monad m, ListLike s el, FoldableLL s el) => (a -> el -> a) -> a -> Iteratee s m a

-- | Left-associative fold that is strict in the accumulator. This function
--   should be used in preference to <a>foldl</a> whenever possible.
--   
--   The analogue of <tt>List.foldl'</tt>.
foldl' :: (Monad m, ListLike s el, FoldableLL s el) => (a -> el -> a) -> a -> Iteratee s m a

-- | Variant of foldl with no base case. Requires at least one element in
--   the stream.
--   
--   The analogue of <tt>List.foldl1</tt>.
foldl1 :: (Monad m, ListLike s el, FoldableLL s el) => (el -> el -> el) -> Iteratee s m el

-- | Strict variant of <a>foldl1</a>.
foldl1' :: (Monad m, ListLike s el, FoldableLL s el) => (el -> el -> el) -> Iteratee s m el

-- | Sum of a stream.
sum :: (Monad m, ListLike s el, Num el) => Iteratee s m el

-- | Product of a stream.
product :: (Monad m, ListLike s el, Num el) => Iteratee s m el

-- | The pure n-chunk enumerator It passes a given stream of elements to
--   the iteratee in <tt>n</tt>-sized chunks.
enumPureNChunk :: (Monad m, ListLike s el) => s -> Int -> Enumerator s m a

-- | Enumerate two iteratees over a single stream simultaneously.
--   
--   Compare to <tt>zip</tt>.
enumPair :: (Monad m, Nullable s, ListLike s el) => Iteratee s m a -> Iteratee s m b -> Iteratee s m (a, b)


-- | Utilities for Char-based iteratee processing.
module Data.Iteratee.Char

-- | Print lines as they are received. This is the first <tt>impure</tt>
--   iteratee with non-trivial actions during chunk processing
printLines :: Iteratee String IO ()

-- | Convert the stream of characters to the stream of lines, and apply the
--   given iteratee to enumerate the latter. The stream of lines is
--   normally terminated by the empty line. When the stream of characters
--   is terminated, the stream of lines is also terminated. This is the
--   first proper iteratee-enumerator: it is the iteratee of the character
--   stream and the enumerator of the line stream.
enumLines :: (ListLike s el, StringLike s, Nullable s, Monad m) => Enumeratee s [s] m a
enumLinesBS :: Monad m => Enumeratee ByteString [ByteString] m a

-- | Convert the stream of characters to the stream of words, and apply the
--   given iteratee to enumerate the latter. Words are delimited by white
--   space. This is the analogue of List.words
enumWords :: (ListLike s Char, Nullable s, Monad m) => Enumeratee s [s] m a
enumWordsBS :: Monad m => Enumeratee ByteString [ByteString] m a


-- | Monadic Iteratees: incremental input parsers, processors, and
--   transformers
--   
--   Iteratees for parsing binary data.
module Data.Iteratee.Binary

-- | Indicate endian-ness.
data Endian

-- | Most Significant Byte is first (big-endian)
MSB :: Endian

-- | Least Significan Byte is first (little-endian)
LSB :: Endian
endianRead2 :: (Nullable s, ListLike s Word8, Monad m) => Endian -> Iteratee s m Word16
endianRead3 :: (Nullable s, ListLike s Word8, Monad m) => Endian -> Iteratee s m Word32

-- | Read 3 bytes in an endian manner. If the first bit is set (negative),
--   set the entire first byte so the Int32 will be negative as well.
endianRead3i :: (Nullable s, ListLike s Word8, Monad m) => Endian -> Iteratee s m Int32
endianRead4 :: (Nullable s, ListLike s Word8, Monad m) => Endian -> Iteratee s m Word32
instance Eq Endian
instance Ord Endian
instance Show Endian
instance Enum Endian


-- | Random and Binary IO with generic Iteratees, using File Descriptors
--   for IO. when available, these are the preferred functions for
--   performing IO as they run in constant space and function properly with
--   sockets, pipes, etc.
module Data.Iteratee.IO.Fd

-- | The enumerator of a POSIX File Descriptor. This version enumerates
--   over the entire contents of a file, in order, unless stopped by the
--   iteratee. In particular, seeking is not supported.
enumFd :: (NullPoint s, ReadableChunk s el, MonadIO m) => Int -> Fd -> Enumerator s m a

-- | A variant of enumFd that catches exceptions raised by the
--   <tt>Iteratee</tt>.
enumFdCatch :: (IException e, NullPoint s, ReadableChunk s el, MonadIO m) => Int -> Fd -> (e -> m (Maybe EnumException)) -> Enumerator s m a

-- | The enumerator of a POSIX File Descriptor: a variation of
--   <tt>enumFd</tt> that supports RandomIO (seek requests).
enumFdRandom :: (NullPoint s, ReadableChunk s el, MonadIO m) => Int -> Fd -> Enumerator s m a

-- | Process a file using the given <tt>Iteratee</tt>.
fileDriverFd :: (NullPoint s, MonadCatchIO m, ReadableChunk s el) => Int -> Iteratee s m a -> FilePath -> m a

-- | A version of fileDriverFd that supports seeking.
fileDriverRandomFd :: (NullPoint s, MonadCatchIO m, ReadableChunk s el) => Int -> Iteratee s m a -> FilePath -> m a


-- | Random and Binary IO with generic Iteratees. These functions use
--   Handles for IO operations, and are provided for compatibility. When
--   available, the File Descriptor based functions are preferred as these
--   wastefully allocate memory rather than running in constant space.
module Data.Iteratee.IO.Handle

-- | The (monadic) enumerator of a file Handle. This version enumerates
--   over the entire contents of a file, in order, unless stopped by the
--   iteratee. In particular, seeking is not supported. Data is read into a
--   buffer of the specified size.
enumHandle :: (NullPoint s, ReadableChunk s el, MonadCatchIO m) => Int -> Handle -> Enumerator s m a

-- | An enumerator of a file handle that catches exceptions raised by the
--   Iteratee.
enumHandleCatch :: (IException e, NullPoint s, ReadableChunk s el, MonadCatchIO m) => Int -> Handle -> (e -> m (Maybe EnumException)) -> Enumerator s m a

-- | The enumerator of a Handle: a variation of enumHandle that supports
--   RandomIO (seek requests). Data is read into a buffer of the specified
--   size.
enumHandleRandom :: (NullPoint s, ReadableChunk s el, MonadCatchIO m) => Int -> Handle -> Enumerator s m a

-- | Process a file using the given <tt>Iteratee</tt>. This function wraps
--   <tt>enumHandle</tt> as a convenience.
fileDriverHandle :: (NullPoint s, MonadCatchIO m, ReadableChunk s el) => Int -> Iteratee s m a -> FilePath -> m a

-- | A version of <tt>fileDriverHandle</tt> that supports seeking.
fileDriverRandomHandle :: (NullPoint s, MonadCatchIO m, ReadableChunk s el) => Int -> Iteratee s m a -> FilePath -> m a


-- | Random and Binary IO with generic Iteratees.
module Data.Iteratee.IO

-- | The (monadic) enumerator of a file Handle. This version enumerates
--   over the entire contents of a file, in order, unless stopped by the
--   iteratee. In particular, seeking is not supported. Data is read into a
--   buffer of the specified size.
enumHandle :: (NullPoint s, ReadableChunk s el, MonadCatchIO m) => Int -> Handle -> Enumerator s m a

-- | The enumerator of a Handle: a variation of enumHandle that supports
--   RandomIO (seek requests). Data is read into a buffer of the specified
--   size.
enumHandleRandom :: (NullPoint s, ReadableChunk s el, MonadCatchIO m) => Int -> Handle -> Enumerator s m a

-- | The enumerator of a POSIX File Descriptor. This version enumerates
--   over the entire contents of a file, in order, unless stopped by the
--   iteratee. In particular, seeking is not supported.
enumFd :: (NullPoint s, ReadableChunk s el, MonadIO m) => Int -> Fd -> Enumerator s m a

-- | The enumerator of a POSIX File Descriptor: a variation of
--   <tt>enumFd</tt> that supports RandomIO (seek requests).
enumFdRandom :: (NullPoint s, ReadableChunk s el, MonadIO m) => Int -> Fd -> Enumerator s m a

-- | Process a file using the given Iteratee. This function wraps enumFd as
--   a convenience.
fileDriver :: (MonadCatchIO m, NullPoint s, ReadableChunk s el) => Iteratee s m a -> FilePath -> m a

-- | A version of fileDriver with a user-specified buffer size (in
--   elements).
fileDriverVBuf :: (MonadCatchIO m, NullPoint s, ReadableChunk s el) => Int -> Iteratee s m a -> FilePath -> m a

-- | Process a file using the given Iteratee. This function wraps
--   enumFdRandom as a convenience.
fileDriverRandom :: (MonadCatchIO m, NullPoint s, ReadableChunk s el) => Iteratee s m a -> FilePath -> m a
fileDriverRandomVBuf :: (MonadCatchIO m, NullPoint s, ReadableChunk s el) => Int -> Iteratee s m a -> FilePath -> m a


-- | Provide iteratee-based IO as described in Oleg Kiselyov's paper
--   http:<i></i>okmij.org<i>ftp</i>Haskell<i>Iteratee</i>.
--   
--   Oleg's original code uses lists to store buffers of data for reading
--   in the iteratee. This package allows the use of arbitrary types
--   through use of the StreamChunk type class. See
--   Data.Iteratee.WrappedByteString for implementation details.
module Data.Iteratee

-- | Process a file using the given Iteratee. This function wraps enumFd as
--   a convenience.
fileDriver :: (MonadCatchIO m, NullPoint s, ReadableChunk s el) => Iteratee s m a -> FilePath -> m a

-- | A version of fileDriver with a user-specified buffer size (in
--   elements).
fileDriverVBuf :: (MonadCatchIO m, NullPoint s, ReadableChunk s el) => Int -> Iteratee s m a -> FilePath -> m a

-- | Process a file using the given Iteratee. This function wraps
--   enumFdRandom as a convenience.
fileDriverRandom :: (MonadCatchIO m, NullPoint s, ReadableChunk s el) => Iteratee s m a -> FilePath -> m a
fileDriverRandomVBuf :: (MonadCatchIO m, NullPoint s, ReadableChunk s el) => Int -> Iteratee s m a -> FilePath -> m a
