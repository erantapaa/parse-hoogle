-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Simple command line argument parsing
--   
@package ReadArgs
@version 1.2.2

module ReadArgs

-- | parse the desired argument tuple from the command line or print a
--   simple usage statment and quit
readArgs :: ArgumentTuple a => IO a

-- | read args from the given strings or print a simple usage statment and
--   quit (so you can do option parsing first)
readArgsFrom :: ArgumentTuple a => [String] -> IO a

-- | a class for types that can be parsed from exactly one command line
--   argument
class Arguable a
parse :: Arguable a => String -> Maybe a
name :: Arguable a => a -> String

-- | all types that are typeable and readable can be used as simple
--   arguments

-- | string is a special case, so that we don't force the user to
--   double-quote their input

-- | Text is a special case, so that we don't force the user to
--   double-quote their input

-- | FilePath is a special case, so that we don't force the user to
--   double-quote their input

-- | char is a special case, so that we don't force the user to
--   single-quote their input

-- | a class for types that can be parsed from some number of command line
--   arguments
class Argument a
parseArg :: Argument a => [String] -> [(a, [String])]
argName :: Argument a => a -> String

-- | use the arguable tyep to just parse a single argument

-- | use Maybe when it should be parsed from one or zero (greedily)

-- | use a list when it should be parsed from zero or more (greedily)

-- | a wrapper type to indicate a non-greedy list or maybe
newtype NonGreedy m a
NonGreedy :: m a -> NonGreedy m a
unNonGreedy :: NonGreedy m a -> m a

-- | use NonGreedy when it should be parsed non-greedily (e.g.
--   <tt>(NonGreedy xs :: NonGreedy [] Int, x :: Maybe Float) &lt;-
--   readArgs</tt>)

-- | make sure strings are handled as a separate type, not a list of chars

-- | a class for tuples of types that can be parsed from the entire list of
--   arguments
class ArgumentTuple a
parseArgsFrom :: ArgumentTuple a => [String] -> Maybe a
usageFor :: ArgumentTuple a => a -> String

-- | use () for no arguments

-- | use :&amp; to construct arbitrary length tuples of any parsable
--   arguments
data (:&) a b
(:&) :: a -> b -> (:&) a b
instance [overlap ok] Show (m a) => Show (NonGreedy m a)
instance [overlap ok] Eq (m a) => Eq (NonGreedy m a)
instance [overlap ok] (Show a, Show b) => Show (a :& b)
instance [overlap ok] (Eq a, Eq b) => Eq (a :& b)
instance [overlap ok] (Argument o, Argument n, Argument m, Argument l, Argument k, Argument j, Argument i, Argument h, Argument g, Argument f, Argument e, Argument d, Argument c, Argument b, Argument a) => ArgumentTuple (o, n, m, l, k, j, i, h, g, f, e, d, c, b, a)
instance [overlap ok] (Argument n, Argument m, Argument l, Argument k, Argument j, Argument i, Argument h, Argument g, Argument f, Argument e, Argument d, Argument c, Argument b, Argument a) => ArgumentTuple (n, m, l, k, j, i, h, g, f, e, d, c, b, a)
instance [overlap ok] (Argument m, Argument l, Argument k, Argument j, Argument i, Argument h, Argument g, Argument f, Argument e, Argument d, Argument c, Argument b, Argument a) => ArgumentTuple (m, l, k, j, i, h, g, f, e, d, c, b, a)
instance [overlap ok] (Argument l, Argument k, Argument j, Argument i, Argument h, Argument g, Argument f, Argument e, Argument d, Argument c, Argument b, Argument a) => ArgumentTuple (l, k, j, i, h, g, f, e, d, c, b, a)
instance [overlap ok] (Argument k, Argument j, Argument i, Argument h, Argument g, Argument f, Argument e, Argument d, Argument c, Argument b, Argument a) => ArgumentTuple (k, j, i, h, g, f, e, d, c, b, a)
instance [overlap ok] (Argument j, Argument i, Argument h, Argument g, Argument f, Argument e, Argument d, Argument c, Argument b, Argument a) => ArgumentTuple (j, i, h, g, f, e, d, c, b, a)
instance [overlap ok] (Argument i, Argument h, Argument g, Argument f, Argument e, Argument d, Argument c, Argument b, Argument a) => ArgumentTuple (i, h, g, f, e, d, c, b, a)
instance [overlap ok] (Argument h, Argument g, Argument f, Argument e, Argument d, Argument c, Argument b, Argument a) => ArgumentTuple (h, g, f, e, d, c, b, a)
instance [overlap ok] (Argument g, Argument f, Argument e, Argument d, Argument c, Argument b, Argument a) => ArgumentTuple (g, f, e, d, c, b, a)
instance [overlap ok] (Argument f, Argument e, Argument d, Argument c, Argument b, Argument a) => ArgumentTuple (f, e, d, c, b, a)
instance [overlap ok] (Argument e, Argument d, Argument c, Argument b, Argument a) => ArgumentTuple (e, d, c, b, a)
instance [overlap ok] (Argument d, Argument c, Argument b, Argument a) => ArgumentTuple (d, c, b, a)
instance [overlap ok] (Argument c, Argument b, Argument a) => ArgumentTuple (c, b, a)
instance [overlap ok] (Argument b, Argument a) => ArgumentTuple (b, a)
instance [overlap ok] Argument a => ArgumentTuple a
instance [overlap ok] (Argument a, ArgumentTuple y) => ArgumentTuple (a :& y)
instance [overlap ok] ArgumentTuple ()
instance [overlap ok] Argument String
instance [overlap ok] Argument (m a) => Argument (NonGreedy m a)
instance [overlap ok] Arguable a => Argument [a]
instance [overlap ok] Arguable a => Argument (Maybe a)
instance [overlap ok] Arguable a => Argument a
instance [overlap ok] Arguable Char
instance [overlap ok] Arguable FilePath
instance [overlap ok] Arguable Text
instance [overlap ok] Arguable String
instance [overlap ok] (Typeable t, Read t) => Arguable t
