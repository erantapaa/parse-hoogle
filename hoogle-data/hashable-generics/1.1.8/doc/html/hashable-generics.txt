-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Automatically generates Hashable instances with GHC.Generics.
--   
--   This package provides a <a>GHC.Generics</a>-based
--   <a>Data.Hashable.Generic.gHashWithSalt</a> function which can be used
--   for providing a <a>hashWithSalt</a> implementation. See the
--   documentation for the <a>gHashWithSalt</a> function in the
--   <a>Data.Hashable.Generic</a> module to get started.
--   
--   This package is heavily inspired by deepseq-generics, which you may
--   also find useful.
@package hashable-generics
@version 1.1.8


module Data.Hashable.Generic

-- | <a>GHC.Generics</a>-based <a>hashWithSalt</a> implementation
--   
--   This provides a generic <a>hashWithSalt</a> implementation for one
--   type at a time. If the type of the value <a>gHashWithSalt</a> is asked
--   to hash contains values of other types, those types have to provide
--   <a>Hashable</a> instances. This also means that recursive types can
--   only be used with <a>gHashWithSalt</a> if a <a>Hashable</a> instance
--   has been defined as well (see examples below).
--   
--   The typical usage for <a>gHashWithSalt</a> is for reducing boilerplate
--   code when defining <a>Hashable</a> instances for ordinary algebraic
--   datatypes. See the code below for some simple usage examples:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import Data.Hashable
--   import Data.Hashable.Generic ( gHashWithSalt )
--   import GHC.Generics
--   
--   -- simple record
--   data Foo = Foo AccountId Name Address
--            deriving Generic
--   
--   type Address      = [String]
--   type Name         = String
--   newtype AccountId = AccountId Int
--   
--   -- Note: Even though gHashWithSalt could be curried, we explicitly list
--   --       the parameters. If you don't do this, GHC will not inline the
--   --       definition of gHashWithSalt, and the performance will not match
--   --       a non-generic implementation. If you use this method, the generic
--   --       hashWithSalt will generate the exact same code as a hand-rolled
--   --       one.
--   --
--   --       Also, the INLINEABLE pragma is there to help hashable data
--   --       structures in other modules write more efficient generic hashable
--   --       instances too. This is the best way to get extremely performant,
--   --       fully generic hash functions.
--   instance Hashable AccountId
--   instance Hashable Foo where
--       hashWithSalt s x = gHashWithSalt s x
--       {-# INLINEABLE hashWithSalt #-}
--   
--   -- recursive list-like type
--   data N = Z | S N deriving Generic
--   
--   instance Hashable N where
--       hashWithSalt s x = gHashWithSalt s x
--       {-# INLINEABLE hashWithSalt #-}
--   
--   -- parametric and recursive type
--   data Bar a = Bar0 | Bar1 a | Bar2 (Bar a)
--              deriving Generic
--   
--   instance Hashable a =&gt; Hashable (Bar a) where
--       hashWithSalt s x = gHashWithSalt s x
--       {-# INLINEABLE hashWithSalt #-}
--   </pre>
--   
--   Note: The <a>GHashable</a> type-class showing up in the type-signature
--   is used internally and not exported on purpose.
gHashWithSalt :: (Generic a, GHashable (Rep a)) => Int -> a -> Int

-- | The class of types that can be converted to a hash value.
--   
--   Minimal implementation: <a>hash</a> or <a>hashWithSalt</a>.
class Hashable a
hash :: Hashable a => a -> Int
hashWithSalt :: Hashable a => Int -> a -> Int
instance (GHashable a, GHashable b) => GHashable (a :+: b)
instance (GHashable a, GHashable b) => GHashable (a :*: b)
instance GHashable a => GHashable (M1 i c a)
instance Hashable a => GHashable (K1 i a)
instance GHashable U1
