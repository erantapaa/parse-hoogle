-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A Library for the manipulation of images
--   
--   The University of New Mexico's Haskell Image Processing library
--   contains functionality for performing manipulations on binary,
--   grayscale, color, and complex images. The library was designed for use
--   in UNM's Digital Image Processing class but it can be used for a wide
--   range of image processing purposes.
--   
--   <ul>
--   <li><i>Changes</i></li>
--   </ul>
--   
--   <ul>
--   <li>Modified shrink such that it now will work with Images that have a
--   ComplexPixel type and return the same type of image. This seems more
--   intuitive and allow users to use it with GrayImages and get GrayImages
--   back. If the user want to use it specifically with Complex values,
--   they will already have a ComplexImage and thus it is a non issue and
--   the type does not need to be coerced.</li>
--   </ul>
@package unm-hip
@version 0.3.1.5

module Data.Image.Internal

-- | An Image can be thought of as a 2 dimensional array of pixel values
class Image i where type family Pixel i :: * pixelList i = [ref i r c | r <- [0 .. (rows i - 1)], c <- [0 .. (cols i - 1)]] imageOp op i0 i1 = makeImage (rows i0) (cols i0) operate where operate r c = op (ref i0 r c) (ref i1 r c)
makeImage :: Image i => Int -> Int -> PixelOp (Pixel i) -> i
ref :: Image i => i -> Int -> Int -> (Pixel i)
rows :: Image i => i -> Int
cols :: Image i => i -> Int
pixelList :: Image i => i -> [Pixel i]
imageOp :: Image i => (Pixel i -> Pixel i -> Pixel i) -> i -> i -> i

-- | A function of a row and column that returns a pixel at that location
type PixelOp px = Int -> Int -> px
class MaxMin m
maximal :: MaxMin m => [m] -> m
minimal :: MaxMin m => [m] -> m

-- | Something is Listable if it can be converted to a list. This type
--   class is mostly for convenience when using leftToRight' and
--   topToBottom'.
class Listable a where type family Elem a :: *
toList :: Listable a => a -> [Elem a]

-- | Given an Image i, return a pair (rows i, cols i)
--   
--   <pre>
--   &gt;&gt;&gt; dimensions gradient
--   (128, 128)
--   </pre>
dimensions :: Image i => i -> (Int, Int)

-- | Given an Image i, returns the value of the Pixel with the maximal
--   intensity
--   
--   <pre>
--   &gt;&gt;&gt; maxIntensity gradient
--   16129.0
--   
--   &gt;&gt;&gt; maxIntensity cactii
--   RGB (254.0, 254.0, 254.0)
--   </pre>
maxIntensity :: (Image img, MaxMin (Pixel img)) => img -> Pixel img

-- | Given an Image i, returns the value of the Pixel with the minimal
--   intensity
--   
--   <pre>
--   &gt;&gt;&gt; minIntensity gradient
--   0.0
--   
--   &gt;&gt;&gt; minIntensity cactii
--   RGB (18.0, 18.0, 18.0)
--   </pre>
minIntensity :: (Image img, MaxMin (Pixel img)) => img -> Pixel img

-- | Given an Image i, returns an Image created by interchanging the rows
--   and columns of i, i.e., the pixel value at location (i, j) of the
--   resulting Image is the value of i at location (j, i).
--   
--   <pre>
--   &gt;&gt;&gt; transpose frog
--   &lt; Image 242x225 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/transposefrog.jpg</a>
transpose :: Image img => img -> img

-- | Given an image X1 and an image X2, where the number of columns of X1
--   equals the number of rows of X2, matrixProduct returns an image
--   representing the matrix product of X1 and X2.
--   
--   <pre>
--   &gt;&gt;&gt; let cropped = crop 64 64 128 128 frog
--   
--   &gt;&gt;&gt; matrixProduct cropped cropped
--   &lt; Image 128x128 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/matrixproduct.jpg</a>
matrixProduct :: (Image img, Num (Pixel img)) => img -> img -> img

-- | Given two positive integers, m and n and a an image, medianFilter
--   returns an image with the same dimensions where each pixel (i, j) in
--   <a>image</a> is replaced by the pixel with median value in the
--   neighborhood of size m times n centered on (i, j).
--   
--   <pre>
--   &gt;&gt;&gt; medianFilter 5 5 frog
--   &lt; Image 225x242 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/medianfilter.jpg</a>
medianFilter :: (Image img, Ord (Pixel img)) => Int -> Int -> img -> img

-- | Given img, normalize returns an image with the same dimensions where
--   the values have been normalized to lie in the interval [0, 1].
--   
--   <pre>
--   &gt;&gt;&gt; let normalfrog = normalize frog
--   
--   &gt;&gt;&gt; ref frog 0 0
--   151.0
--   
--   &gt;&gt;&gt; ref normalfrog 0 0
--   0.592156862745098
--   </pre>
normalize :: (Image img, MaxMin (Pixel img), RealFloat (Pixel img)) => img -> img

-- | Folds over the pixels of the provided image
--   
--   <pre>
--   &gt;&gt;&gt; imageFold (+) 0 frog
--   6948219.0
--   </pre>
imageFold :: Image img => (Pixel img -> b -> b) -> b -> img -> b

-- | Maps a function over each pixel in the provided image. When using
--   Boxed images, you should use fmap instead.
--   
--   <pre>
--   &gt;&gt;&gt; imageMap ((-1) *) frog :: GrayImage
--   &lt; Image 225x242 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/invertfrog.jpg</a>
imageMap :: (Image img, Image img') => (Pixel img -> Pixel img') -> img -> img'

-- | Given m, n, and img, pad returns an Image with m rows and n columns
--   where the value at location (i, j) of the result image is the value of
--   img at location (i, j) if i is less than m and j is less than n and
--   mempty otherwise.
--   
--   <pre>
--   &gt;&gt;&gt; pad 256 256 frog
--   &lt; Image 256x256 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/padfrog.jpg</a>
pad :: (Image img, Monoid (Pixel img)) => Int -> Int -> img -> img

-- | Given a i0, j0, m, n, and img, crop returns an image with m rows and n
--   columns where the value at location (i, j) of the result image is the
--   value of img at location (i0 + i, j0 + j).
--   
--   <pre>
--   &gt;&gt;&gt; crop 64 64 128 128 frog
--   &lt; Image 128x128 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/cropfrog.jpg</a>
crop :: Image img => Int -> Int -> Int -> Int -> img -> img

-- | Given img, downsampleRows returns the image created by discarding the
--   odd numbered columns, i.e., the value at location (i, j) is the value
--   of img at location (i, 2j).
--   
--   <pre>
--   &gt;&gt;&gt; downsampleRows frog
--   &lt; Image 225x121 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/downsamplerowsfrog.jpg</a>
downsampleRows :: Image img => img -> img

-- | Given img, downsampleCols returns the image created by discarding the
--   odd numbered rows, i.e., the value at location (i, j) of the result
--   image is the value of img at location (2i, j).
--   
--   <pre>
--   &gt;&gt;&gt; downsampleCols frog
--   &lt; Image 112x242 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/downsamplecolsfrog.jpg</a>
downsampleCols :: Image img => img -> img

-- | Given img, downsample returns the image created by discarding the odd
--   numbered rows and columns, i.e., the value at location (i, j) is the
--   value of img at location (2i, 2j)
--   
--   <pre>
--   &gt;&gt;&gt; let smallfrog = downsample frog
--   
--   &gt;&gt;&gt; smallfrog
--   &lt; Image 112x121 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/downsamplefrog.jpg</a>
downsample :: Image img => img -> img

-- | Given img, upsampleRows returns an image with twice the number of
--   columns where the value at location (i, j) of the result image is the
--   value of img at location (i, j/2) if j is even and mempty otherwise.
--   
--   <pre>
--   &gt;&gt;&gt; upsampleRows smallfrog
--   &lt; Image 112x242 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/upsamplerows.jpg</a>
upsampleRows :: (Image img, Monoid (Pixel img)) => img -> img

-- | Given img, upsampleCols returns an image with twice the number of rows
--   where the value at location (i, j) of the result image is the value of
--   img at location (i/2, j) if i is even and mempty otherwise.
--   
--   <pre>
--   &gt;&gt;&gt; upsampleCols smallfrog
--   &lt; Image 224x121 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/upsamplecols.jpg</a>
upsampleCols :: (Image img, Monoid (Pixel img)) => img -> img

-- | Given img, upsample returns an image with twice the number of rows and
--   columns where the value at location (i, j) of the resulting image is
--   the value of img at location (i<i>2, j</i>2) if i and jare are even
--   and mempty otherwise.
--   
--   <pre>
--   &gt;&gt;&gt; upsample smallfrog
--   &lt; Image 224x242 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/upsample.jpg</a>
upsample :: (Image img, Monoid (Pixel img)) => img -> img

-- | Given two images with the same number of rows X and Y, returns an
--   image that is the concatenation of the two images from left to right.
--   
--   <pre>
--   &gt;&gt;&gt; leftToRight frog frog
--   &lt; Image 225x484 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/lefttoright.jpg</a>
leftToRight :: Image img => img -> img -> img

-- | Given a Listable of images each of which have the same number of rows,
--   returns an image that is the concatenation of all of the images from
--   left to Right.
--   
--   <pre>
--   &gt;&gt;&gt; leftToRight' . replicate 3 $ frog
--   &lt; Image 225x726 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/lefttoright3.jpg</a>
leftToRight' :: (Listable a, Image img, Image (Elem a), Elem a ~ img) => a -> img

-- | Given two images with the same number of columns X and Y, returns an
--   image that is the concatenation of the two images from top to bottom.
--   
--   <pre>
--   &gt;&gt;&gt; topToBottom frog frog
--   &lt; Image 450x242 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/toptobottom.jpg</a>
topToBottom :: Image img => img -> img -> img

-- | Given a Listable of images all of which have the same number of
--   columns, returns an image that is the concatenation of all of
--   theimages from top to bottom.
--   
--   <pre>
--   &gt;&gt;&gt; topToBottom' . replicate 3 $ frog
--   &lt; Image 675x242 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/toptobottom3.jpg</a>
topToBottom' :: (Listable a, Image img, Image (Elem a), Elem a ~ img) => a -> img

-- | Given img, returns an two dimensional array of Pixel values indexed by
--   pairs of Ints where the fst is the row and snd is the column.
--   
--   <pre>
--   &gt;&gt;&gt; let frogArr = imageToArray frog
--   
--   &gt;&gt;&gt; frogArr ! (0, 0)
--   151.0
--   </pre>
imageToArray :: Image img => img -> Array (Int, Int) (Pixel img)

-- | Given a two dimensional array of Pixel values indexed by pairs of Ints
--   where the fst is the row and snd is the column, returns an Image.
--   
--   <pre>
--   &gt;&gt;&gt; let img = arrayToImage (listArray ((0,0) (127,127)) [0..]) :: GrayImage
--   
--   &gt;&gt;&gt; img
--   &lt; Image 128x128 &gt;
--   
--   &gt;&gt;&gt; ref img 0 0
--   0.0
--   
--   &gt;&gt;&gt; ref img 0 10
--   10.0
--   
--   &gt;&gt;&gt; ref img 10 0
--   1280.0
--   
--   &gt;&gt;&gt; ref img 10 10
--   1290.0
--   </pre>
arrayToImage :: Image img => Array (Int, Int) (Pixel img) -> img
instance Listable (a, a, a)
instance Listable (a, a)
instance Listable [a]

module Data.Image.Convolution

-- | Given a list consisting solely of pixel values representing a 1D
--   convolution kernel and an image, convolveRows returns the 1D discrete
--   periodic convolution of the rows of the image with the kernel.
--   
--   <pre>
--   &gt;&gt;&gt; frog &lt;- readImage "images/frog.pgm"
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/frog.jpg</a>
--   
--   <pre>
--   &gt;&gt;&gt; convolveRows [1,-1] frog
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/convolverows.jpg</a>
convolveRows :: (Image img, Num (Pixel img)) => [Pixel img] -> img -> img

-- | Given a list consisting solely of pixel values representing a 1D
--   convolution kernel and an image, convolveCols returns the 1D discrete
--   periodic convolution of the columns of the image with the kernel.
--   
--   <pre>
--   &gt;&gt;&gt; convolveCols [1,-1] frog
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/convolvecols.jpg</a>
--   
--   <pre>
--   &gt;&gt;&gt; let dx = convolveRows [1, -1] frog
--   
--   &gt;&gt;&gt; let dy = convolveCols [1, -1] frog
--   
--   &gt;&gt;&gt; imageMap sqrt (dx*dx + dy*dy) :: GrayImage
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/convolvedxdy.jpg</a>
convolveCols :: (Image img, Num (Pixel img)) => [Pixel img] -> img -> img

-- | Given a 2D list consisting solely of pixels representing a 2D
--   convolution kernel and an image, convolve returns the 2D discrete
--   periodic convolution of the image with the kernel.
--   
--   <pre>
--   &gt;&gt;&gt; convolve [[1,1,1],[1,-8,1],[1,1,1]] frog
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/convolve.jpg</a>
convolve :: (Image img, Num (Pixel img)) => [[Pixel img]] -> img -> img

module Data.Image.Binary

-- | A BinaryPixel can be in one of two states, on or off.
class BinaryPixel px
toBinary :: BinaryPixel px => px -> Bool
off :: BinaryPixel px => px
on :: BinaryPixel px => px

-- | Given a function of a pixel to a boolean and an image, returns the
--   Binary version of that image.
--   
--   <pre>
--   &gt;&gt;&gt; stop &lt;- readColorImage "images/stop.ppm"
--   
--   &gt;&gt;&gt; let binaryStop = toBinaryImage (\(RGB (r, g, b)) -&gt; r &gt; 196 &amp;&amp; g &gt; 0 &amp;&amp; b &gt; 0) stop
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/stop.jpg</a>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/binarystop.jpg</a>
toBinaryImage :: (Image img, BinaryPixel (Pixel img)) => (Pixel img -> Bool) -> img -> img

-- | Given a Pixel p and an image img, return a Binary image where the
--   pixel at (i, j) is on if p is less than the corresponding pixel in img
--   at (i,j) and off otherwise.
--   
--   <pre>
--   &gt;&gt;&gt; frog &lt;. 50
--   &lt; Image 225x242 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/greaterthanfrog.jpg</a>
(<.) :: (Image img, BinaryPixel (Pixel img), Ord (Pixel img), Pixel img ~ a) => a -> img -> img

-- | Given an image, img, and a Pixel p, return a Binary image where the
--   pixel at (i, j) is on if the corresponding pixel in img at (i,j) is
--   less than p and off otherwise.
--   
--   <pre>
--   &gt;&gt;&gt; frog &lt;- readImage "images/frog.pgm"
--   
--   &gt;&gt;&gt; frog .&lt; 50
--   &lt; Image 225x242 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/lessthanfrog.jpg</a>
(.<) :: (Image img, BinaryPixel (Pixel img), Ord (Pixel img), Pixel img ~ a) => img -> a -> img

-- | Given a Pixel p and an image img, return a Binary image where the
--   pixel at (i, j) is on if p is greater than the corresponding pixel in
--   img at (i,j) and off otherwise.
--   
--   <pre>
--   &gt;&gt;&gt; 50 &gt;. frog
--   &lt; Image 225x242 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/lessthanfrog.jpg</a>
(>.) :: (Image img, BinaryPixel (Pixel img), Ord (Pixel img), Pixel img ~ a) => a -> img -> img

-- | Given an image, img, and a Pixel p, return a Binary image where the
--   pixel at (i, j) is on if the corresponding pixel in img at (i,j) is
--   greater than p and off otherwise.
--   
--   <pre>
--   &gt;&gt;&gt; 50 &lt;. frog
--   &lt; Image 225x242 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/greaterthanfrog.jpg</a>
(.>) :: (Image img, BinaryPixel (Pixel img), Ord (Pixel img), Pixel img ~ a) => img -> a -> img

-- | Given a Pixel p and an image img, return a Binary image where the
--   pixel at (i, j) is on if the corresponding pixel in img at (i,j) is
--   equal to p and off otherwise.
--   
--   <pre>
--   &gt;&gt;&gt; 50 ==. frog
--   &lt; Image 225x242 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/frogequals.jpg</a>
(==.) :: (Image img, BinaryPixel (Pixel img), Eq (Pixel img), Pixel img ~ a) => a -> img -> img

-- | Given an image, img, and a Pixel p, return a Binary image where the
--   pixel at (i, j) is on if the corresponding pixel in img at (i,j) is
--   equal to p and off otherwise.
--   
--   <pre>
--   &gt;&gt;&gt; frog .== 50
--   &lt; Image 225x242 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/frogequals.jpg</a>
(.==) :: (Image img, BinaryPixel (Pixel img), Eq (Pixel img), Pixel img ~ a) => img -> a -> img

-- | Given a Pixel p and an image img, return a Binary image where the
--   pixel at (i, j) is on if the corresponding pixel in img at (i,j) is
--   equal to p and off otherwise.
--   
--   <pre>
--   &gt;&gt;&gt; 50 /=. frog
--   &lt; Image 225x242 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/notequals.jpg</a>
(/=.) :: (Image img, BinaryPixel (Pixel img), Eq (Pixel img), Pixel img ~ a) => a -> img -> img

-- | Given an image, img, and a Pixel p, return a Binary image where the
--   pixel at (i, j) is on if the corresponding pixel in img at (i,j) is
--   equal to p and off otherwise.
--   
--   <pre>
--   &gt;&gt;&gt; frog ./= 50
--   &lt; Image 225x242 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/notequals.jpg</a>
(./=) :: (Image img, BinaryPixel (Pixel img), Eq (Pixel img), Pixel img ~ a) => img -> a -> img

-- | Given a function of two pixels to a boolean pred and two images X and
--   Y, return a binary image that for each pixel (i,j) is on if the pixel
--   pred X(i,j) Y(i,j) return True and off otherwise.
--   
--   <pre>
--   &gt;&gt;&gt; let fade = makeImage 225 242 (\ r _ -&gt; fromIntegral r) :: GrayImage
--   
--   &gt;&gt;&gt; let fademask = compareImage (&gt;) frog fade
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/fade.jpg</a>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/fademask.jpg</a>
compareImage :: (Image img, BinaryPixel (Pixel img), Ord (Pixel img)) => ((Pixel img) -> (Pixel img) -> Bool) -> img -> img -> img

-- | Given two images X and Y, return a binary image that for each pixel
--   (i, j) is on if X(i,j) &lt; Y(i,j) and off otherwise.
--   
--   <pre>
--   &gt;&gt;&gt; let fademask2 = frog .&lt;. fade
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/fademask2.jpg</a>
(.<.) :: (Image img, BinaryPixel (Pixel img), Ord (Pixel img)) => img -> img -> img

-- | Given two images X and Y, return a binary image that for each pixel
--   (i, j) is on if X(i,j) &gt; Y(i,j) and off otherwise.
--   
--   <pre>
--   &gt;&gt;&gt; let fademask = frog .&gt;. fade
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/fademask.jpg</a>
(.>.) :: (Image img, BinaryPixel (Pixel img), Ord (Pixel img)) => img -> img -> img

-- | Given two images X and Y, return a binray image that for each pixel
--   (i, j) is on if X(i,j) == Y(i,j) and off otherwise.
--   
--   <pre>
--   &gt;&gt;&gt; let fademask3 = frog .==. fade
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/fademask3.jpg</a>
(.==.) :: (Image img, BinaryPixel (Pixel img), Eq (Pixel img)) => img -> img -> img

-- | Given two images X and Y, return a bniry image that for each pixel (i,
--   j) is on if X(i,j) == Y(i,j) and off otherwise.
--   
--   <pre>
--   &gt;&gt;&gt; let fademask4 = frog ./=. fade
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/fademask4.jpg</a>
(./=.) :: (Image img, BinaryPixel (Pixel img), Eq (Pixel img)) => img -> img -> img

-- | Given a binary image to use as a mask and an image to mask, mask
--   applies the mask to the image.
--   
--   <pre>
--   &gt;&gt;&gt; let fmask = frog .&lt; 150
--   
--   &gt;&gt;&gt; applyMask fmask frog
--   &lt; Image 225x242 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/fmask.jpg</a>
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/applyMask.jpg</a>
applyMask :: (Image img, Monoid (Pixel img), Image mask, BinaryPixel (Pixel mask)) => mask -> img -> img

-- | Given a 2D list consisting solely of pixels representing a structuring
--   element, and a binary image, erode returns the morphological erosion
--   of the <a>image</a> with the structuring element.
--   
--   <pre>
--   &gt;&gt;&gt; stop &lt;- readColorImage "images/stop.ppm"
--   
--   &gt;&gt;&gt; let binaryStop = toBinaryImage (\(RGB (r, g, b)) -&gt; r &gt; 196 &amp;&amp; g &gt; 0 &amp;&amp; b &gt; 0) stop
--   
--   &gt;&gt;&gt; let erosion = erode [[1,1],[1,1]] binaryStop
--   
--   &gt;&gt;&gt; binaryStop - erosion
--   &lt; Image 86x159 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/stop.jpg</a>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/binarystop.jpg</a>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/erode.jpg</a>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/erosion.jpg</a>
erode :: (Image img, BinaryPixel (Pixel img), Num (Pixel img), Eq (Pixel img)) => [[Pixel img]] -> img -> img

-- | For convenience erode' = erode [[1,1],[1,1]]
--   
--   <pre>
--   &gt;&gt;&gt; erode' binaryStop
--   &lt; Image 86x159 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/erode.jpg</a>
erode' :: (Image img, BinaryPixel (Pixel img), Num (Pixel img), Eq (Pixel img)) => img -> img

-- | Given a 2D list consisting solely of pixels representing a structuring
--   element, and a binary image, dilate returns the morphological dilation
--   of the <a>image</a> with the structuring element.
--   
--   <pre>
--   &gt;&gt;&gt; let dilated = dilate [[1,1],[1,1]] binaryStop
--   
--   &gt;&gt;&gt; dilate - binaryStop
--   &lt; Image 86x159 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/dilate.jpg</a>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/dilated.jpg</a>
dilate :: (Image img, BinaryPixel (Pixel img), Num (Pixel img), Eq (Pixel img)) => [[Pixel img]] -> img -> img

-- | For convenience dilate' = dilate [[1,1],[1,1]]
--   
--   <pre>
--   &gt;&gt;&gt; dilate' binaryStop
--   &lt; Image 86x159 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/dilate.jpg</a>
dilate' :: (Image img, BinaryPixel (Pixel img), Num (Pixel img), Eq (Pixel img)) => img -> img

-- | Given a 2D list consisting solely of pixels representing a structuring
--   element, and a binary image, dilate returns the morphological opening
--   of the <a>image</a> with the structuring element.
--   
--   <pre>
--   &gt;&gt;&gt; noise &lt;- readColorImage "images/noise.ppm"
--   
--   &gt;&gt;&gt; let noisyStop = binaryStop ./=. noise
--   
--   &gt;&gt;&gt; open noisyStop
--   &lt; Image 86x159 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/noise.jpg</a>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/noisystop.jpg</a>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/open.jpg</a>
open :: (Image img, BinaryPixel (Pixel img), Num (Pixel img), Eq (Pixel img)) => [[Pixel img]] -> img -> img

-- | For convenience open' = open [[1,1],[1,1]]
--   
--   <pre>
--   &gt;&gt;&gt; open' noisyStop
--   &lt; Image 86x159 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/open.jpg</a>
open' :: (Image img, BinaryPixel (Pixel img), Num (Pixel img), Eq (Pixel img)) => img -> img

-- | Given a 2D list consisting solely of pixels representing a structuring
--   element, and a binary image, dilate returns the morphological closing
--   of the <a>image</a> with the structuring element.
--   
--   <pre>
--   &gt;&gt;&gt; close [[1,1],[1,1]] noisyStop
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/close.jpg</a>
close :: (Image img, BinaryPixel (Pixel img), Num (Pixel img), Eq (Pixel img)) => [[Pixel img]] -> img -> img

-- | For convenience close' = close [[1,1],[1,1]]
--   
--   <pre>
--   &gt;&gt;&gt; close' noisyStop
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/close.jpg</a>
close' :: (Image img, BinaryPixel (Pixel img), Num (Pixel img), Eq (Pixel img)) => img -> img

-- | Given a binary image, label returns an image where pixels in distinct
--   connected components (based on 4-neighbor connectivity) have distinct
--   integer values. These values range from 1 to n where n is the number
--   of connected components in image.
--   
--   <pre>
--   &gt;&gt;&gt; label binaryStop
--   &lt; Image 86x159 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/label.jpg</a>
label :: (Image img, BinaryPixel (Pixel img), Image img', Pixel img' ~ Double) => img -> img'

-- | Given an image, areas returns a vector where the n-th component equals
--   the number of pixels with value n. If image is the result of applying
--   label to a binary image, then the vector represents the areas of the
--   connected-components of the binary-image. If not, areas returns the
--   histogram of the image.
--   
--   <pre>
--   &gt;&gt;&gt; areas . label $ binaryStop
--   fromList [9241.0,1149.0,1323.0,809.0,1144.0]
--   </pre>
areas :: (Image img, MaxMin (Pixel img), RealFrac (Pixel img)) => img -> Vector Double

-- | Given an image, perimeters returns a vector where the n-th component
--   equals the number of pixels with value n which are adjacent to pixels
--   of value 0 and the 0-th component equals the sum of the other
--   components. If image is the result of applying label to a binary
--   image, then the vector represents the perimeters of the
--   connected-components of the binary-image.
--   
--   <pre>
--   &gt;&gt;&gt; perimeters . label $ binaryStop
--   fromList [1082.0,312.0,326.0,184.0,260.0]
--   </pre>
perimeters :: (Image img, MaxMin (Pixel img), Pixel img ~ Double) => img -> Vector Double

-- | Given an image, the result of applying label to a binary-image,
--   boundingBoxes returns a vector where the n-th component is a four
--   element tuple representing the minimum and maximum row and column
--   indices of pixels of the n-th connected-component of the image.
--   
--   <pre>
--   &gt;&gt;&gt; boundingBoxes . label $ binaryStop
--   [(10,8,73,41),(10,75,74,110),(11,42,72,73),(11,117,72,150)]
--   </pre>
boundingBoxes :: (Image img, MaxMin (Pixel img), Pixel img ~ Double) => img -> [(Int, Int, Int, Int)]

-- | Given an image, the result of applying label to a binary-image,
--   centersOfMass returns a vector where the n-th component is a tuple
--   representing the average row and column indices of pixels of the n-th
--   connected-component of the image.
--   
--   <pre>
--   &gt;&gt;&gt; centersOfMass . label $ binaryStop
--   [(42.2686308492201,24.657712305025996),(41.74660633484163,92.20889894419307),(35.31025957972806,57.595797280593324),(35.583406113537116,129.9170305676856)]
--   </pre>
centersOfMass :: (Image img, MaxMin (Pixel img), Pixel img ~ Double) => img -> [(Double, Double)]

-- | Given a binary image, distanceTransform returns an image representing
--   the 2D distance transform of the image. The distance transform is
--   accurate to within a 2% error for euclidean distance.
--   
--   <pre>
--   &gt;&gt;&gt; distanceTransform binaryStop :: GrayImage
--   &lt; Image 86x159 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/distancetransform.jpg</a>
distanceTransform :: (Image img, BinaryPixel (Pixel img), Image img', Pixel img' ~ Double) => img -> img'

-- | Given an image, outline returns an image where edge pixels are set to
--   the value on and non-edge pixels are set to the value off. Pixel (i,
--   j) is an edge pixel iff its value is different than the value of
--   either pixel (i, j+1) or pixel (i+1, j).
--   
--   <pre>
--   &gt;&gt;&gt; outline binaryStop
--   &lt; Image 86x159 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/outline.jpg</a>
outline :: (Image img, BinaryPixel (Pixel img), Eq (Pixel img)) => img -> img

-- | Given two doubles nonEdge and edge, and an image, outline' returns an
--   image where edge pixels are set to the value edge and non-edge pixels
--   are set to the value nonEdge. Pixel (i, j) is an edge pixel iff its
--   value is different than the value of either pixel (i, j+1) or pixel
--   (i+1, j).
--   
--   <pre>
--   &gt;&gt;&gt; outline' (RGB (255, 255, 255)) (RGB (0, 0, 255)) binaryStop
--   &lt; Image 86x159 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/outline2.jpg</a>
outline' :: (Image img, BinaryPixel (Pixel img), Eq (Pixel img)) => Pixel img -> Pixel img -> img -> img

module Data.Image.IO

-- | A DisplayFormat for writing to a file
class DisplayFormat df
format :: DisplayFormat df => df -> String

-- | GrayPixels will be converted using this class
class RealFrac (GrayVal px) => GrayPixel px where type family GrayVal px :: *
toGray :: GrayPixel px => px -> GrayVal px

-- | RGBPixels will be converted using this class
class RealFrac (ColorVal px) => RGBPixel px where type family ColorVal px :: *
toRGB :: RGBPixel px => px -> (ColorVal px, ColorVal px, ColorVal px)

-- | Given a file name and a formatable image, writes the image to that
--   file with the format.
--   
--   <pre>
--   &gt;&gt;&gt; frog &lt;- readImage "images/frog.pgm"
--   
--   &gt;&gt;&gt; writeImage "transposeFrog.pgm" (transpose frog)
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/frog.jpg</a>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/transposefrog.jpg</a>
--   
--   <pre>
--   &gt;&gt;&gt; cactii &lt;- readColorImage "images/cactii.ppm"
--   
--   &gt;&gt;&gt; writeImage "inverseCactii.ppm" (imageMap (*(-1)) cactii)
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/cactii.jpg</a>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/inversecactii.jpg</a>
writeImage :: DisplayFormat df => FilePath -> df -> IO ()

-- | Converts an image an ASCII PPM scaled between pixel values of 0 and
--   255
toPGM :: (Image img, GrayPixel (Pixel img)) => img -> [Char]

-- | Converts an image to an ASCII PPM scaled between pixel values of 0 and
--   255
toPPM :: (Image img, RGBPixel (Pixel img)) => img -> [Char]

module Data.Image.Complex
class RealFloat (Value px) => ComplexPixel px where type family Value px :: *
toComplex :: ComplexPixel px => px -> Complex (Value px)
fromComplex :: ComplexPixel px => Complex (Value px) -> px

-- | Given a positive integer m, a positive integer n, and a function
--   returning a pixel value, makeFilter returns an image with m rows and n
--   columns. Let x equal i if i is less than m/2 and i - m otherwise and
--   let y equal j if j is less than n/2 and j - n otherwise. To match the
--   periodicity of the 2D discrete Fourier spectrum, the value of the
--   result image at location (i, j) is computed by applying the function
--   to x and y, e.g., the value at location (0, 0) is the result of
--   applying the function to 0 and 0, the value at (m-1, n-1) is the
--   result of applying function to -1 and -1.
--   
--   <pre>
--   &gt;&gt;&gt; makeFilter 128 128 (\ r c -&gt; fromIntegral (r + c)) :: GrayImage
--   &lt; Image 128x128 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/makefilter.jpg</a>
--   
--   <pre>
--   laplacianOfGaussian :: Double -&gt; Int -&gt; Int -&gt; Double
--   laplacianOfGaussian stddev i j = ((-pi) / (stddev*stddev)) * (1 - x) * (exp (-x)) where
--     r = fromIntegral $ i*i + j*j
--     x = r / (2.0*stddev)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let d2g = makeFilter 128 128 (laplacianOfGaussian 8) :: GrayImage
--   </pre>
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/d2g.jpg</a>
--   
--   <pre>
--   gaussian :: Double -&gt; Int -&gt; Int -&gt; Double 
--   gaussian variance i j = exp (-x) where
--     r = fromIntegral $ i*i + j*j
--     x = r / (2.0*pi*variance)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let g = makeFilter 128 128 (gaussian 8) :: GrayImage
--   </pre>
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/g.jpg</a>
makeFilter :: Image img => Int -> Int -> (PixelOp (Pixel img)) -> img

-- | Given an image whose pixels can be converted to a complex value, fft
--   returns an image with complex pixels representing its 2D discrete
--   Fourier transform (DFT). Because the DFT is computed using the Fast
--   Fourier Transform (FFT) algorithm, the number of rows and columns of
--   the image must both be powers of two, i.e., 2K where K is an integer.
--   
--   <pre>
--   &gt;&gt;&gt; frog &lt;- readImage "images/frog.pgm"
--   
--   &gt;&gt;&gt; let frogpart = crop 64 64 128 128 frog
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/frog.jpg</a>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/frogpart.jpg</a>
--   
--   <pre>
--   &gt;&gt;&gt; magnitude . imageMap log . fft $ frogpart
--   </pre>
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/fft.jpg</a>
--   
--   <pre>
--   &gt;&gt;&gt; fft d2g
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/fftd2g.jpg</a>
--   
--   <pre>
--   &gt;&gt;&gt; fft g
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/fftg.jpg</a>
fft :: (Image img, ComplexPixel (Pixel img), Image img', Pixel img' ~ Complex (Value (Pixel img))) => img -> img'

-- | Given an image, ifft returns a complex image representing its 2D
--   inverse discrete Fourier transform (DFT). Because the inverse DFT is
--   computed using the Fast Fourier Transform (FFT) algorithm, the number
--   of rows and columns of <a>image</a> must both be powers of two, i.e.,
--   2K where K is an integer.
--   
--   <pre>
--   &gt;&gt;&gt; ifft ((fft frogpart) * (fft d2g))
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/ifft.jpg</a>
--   
--   <pre>
--   &gt;&gt;&gt; ifft ((fft frogpart) * (fft g))
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/ifft2.jpg</a>
ifft :: (Image img, ComplexPixel (Pixel img), Image img', Pixel img' ~ Complex (Value (Pixel img))) => img -> img'

-- | Given an image representing the real part of a complex image, and an
--   image representing the imaginary part of a complex image, returns a
--   complex image.
--   
--   <pre>
--   &gt;&gt;&gt; complex cosine sine
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/signal.jpg</a>
complex :: (Image img, Image img', Pixel img' ~ Complex (Pixel img)) => img -> img -> img'

-- | Given a complex image, returns a real image representing the real part
--   of the image.
--   
--   <pre>
--   harmonicSignal :: Double -&gt; Double -&gt; Int -&gt; Int -&gt; C.Complex Double
--   harmonicSignal u v m n = exp (-pii*2.0 * var) where 
--     pii = 0.0 C.:+ pi
--     var = (u*m' + v*n') C.:+ 0.0
--     [m',n'] = map fromIntegral [m, n]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let signal = makeImage 128 128 (harmonicSignal (3/128) (2/128)) :: ComplexImage
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/signal.jpg</a>
--   
--   <pre>
--   &gt;&gt;&gt; let cosine = realPart signal
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/cosine.jpg</a>
--   
--   <pre>
--   &gt;&gt;&gt; realPart . ifft $ (fft frogpart) * (fft d2g)
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/realpart.jpg</a>
--   
--   <pre>
--   &gt;&gt;&gt; realPart . ifft $ (fft frogpart) * (fft g)
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/realpart2.jpg</a>
realPart :: (Image img, ComplexPixel (Pixel img), Image img', Pixel img' ~ Value (Pixel img)) => img -> img'

-- | Given a complex image, returns a real image representing the imaginary
--   part of the image
--   
--   <pre>
--   &gt;&gt;&gt; let sine = imagPart signal
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/sine.jpg</a>
imagPart :: (Image img, ComplexPixel (Pixel img), Image img', Pixel img' ~ Value (Pixel img)) => img -> img'

-- | Given a complex image, returns a real image representing the magnitude
--   of the image.
--   
--   <pre>
--   &gt;&gt;&gt; magnitude signal
--   </pre>
magnitude :: (Image img, ComplexPixel (Pixel img), Image img', Pixel img' ~ Value (Pixel img)) => img -> img'

-- | Given a complex image, returns a real image representing the angle of
--   the image
--   
--   <pre>
--   &gt;&gt;&gt; angle signal
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/angle.jpg</a>
angle :: (Image img, ComplexPixel (Pixel img), Image img', Pixel img' ~ Value (Pixel img)) => img -> img'

-- | Given a complex image and a real positive number x, shrink returns a
--   complex image with the same dimensions. Let z be the value of the
--   image at location (i, j). The value of the complex result image at
--   location (i, j) is zero if |z| &lt; x, otherwise the result has the
--   same phase as z but the amplitude is decreased by x.
shrink :: (Image img, ComplexPixel (Pixel img)) => (Value (Pixel img)) -> img -> img

-- | Given a complex image, return a pair of real images each representing
--   a component of the complex image (real, imaginary).
--   
--   <pre>
--   &gt;&gt;&gt; leftToRight' . complexImageToRectangular $ signal
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/complexsignaltorectangular.jpg</a>
complexImageToRectangular :: (Image img, ComplexPixel (Pixel img), Image img', Pixel img' ~ Value (Pixel img)) => img -> (img', img')

-- | Given a complex image, returns a pair of real images each representing
--   the component (magnitude, phase) of the image
--   
--   <pre>
--   &gt;&gt;&gt; leftToRight' . complexImageToPolar $ signal
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/compleximagetopolar.jpg</a>
complexImageToPolar :: (Image img, ComplexPixel (Pixel img), Image img', Pixel img' ~ Value (Pixel img)) => img -> (img', img')

module Data.Image.Interactive

-- | Makes a call to the current display program to be displayed. If the
--   program cannot read from standard in, a file named <a>.tmp-img</a> is
--   created and used as an argument to the program.
--   
--   <pre>
--   &gt;&gt;&gt; frog &lt;- readImage "images/frog.pgm"
--   
--   &gt;&gt;&gt; display frog
--   </pre>
display :: DisplayFormat df => df -> IO (Handle, Handle, Handle, ProcessHandle)

-- | Sets the program to use when making a call to display and specifies if
--   the program can accept an image via stdin. If it cannot, then a
--   temporary file will be created and passed as an argument instead. By
--   default, ImageMagick (<a>display</a>) is the default program to use
--   and it is read using stdin.
--   
--   <pre>
--   &gt;&gt;&gt; setDisplayProgram "gimp" False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; setDisplayProgram "xv" False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; setDisplayProgram "display" True
--   </pre>
setDisplayProgram :: String -> Bool -> IO ()

-- | Takes a list, pair, or triple of images and passes them to gnuplot to
--   be displayed as histograms.
--   
--   <pre>
--   &gt;&gt;&gt; frog &lt;- readImage "images/frog.pgm"
--   
--   &gt;&gt;&gt; plotHistograms $ [frog]
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/frog.jpg</a>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/frogplot.jpg</a>
--   
--   <pre>
--   &gt;&gt;&gt; cactii &lt;- readColorImage "images/cactii.ppm"
--   
--   &gt;&gt;&gt; plotHistograms . colorImageToRGB $ cactii
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/cactii.jpg</a>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/cactiiplot.jpg</a>
plotHistograms :: (RealFrac (Pixel (Elem a)), MaxMin (Pixel (Elem a)), Listable a, Image (Elem a)) => a -> IO (Handle, Handle, Handle, ProcessHandle)

module Data.Image.Arithmetic

-- | Performs scalar addition to each pixel in an image
(+.) :: (Num (Pixel i), Image i) => Pixel i -> i -> i

-- | Performs scalar addition to each pixel in an image
(.+) :: (Num (Pixel i), Image i) => i -> Pixel i -> i

-- | Performs scalar multiplication to each pixel in an image
(*.) :: (Num (Pixel i), Image i) => Pixel i -> i -> i

-- | Performs scalar multiplication to each pixel in an image
(.*) :: (Num (Pixel i), Image i) => i -> Pixel i -> i

-- | Performs scalar subtraction to each pixel in an image
(-.) :: (Num (Pixel i), Image i) => Pixel i -> i -> i

-- | Performs scalar subtraction to each pixel in an image
(.-) :: (Num (Pixel i), Image i) => i -> Pixel i -> i

-- | Performs scalar division to each pixel in an image
(/.) :: (Fractional (Pixel i), Image i) => Pixel i -> i -> i

-- | Performs scalar division to each pixel in an image
(./) :: (Fractional (Pixel i), Image i) => i -> Pixel i -> i

module Data.Image.Boxed

-- | BoxedImage is a concrete implementation of Image using a boxed
--   internal structure. This allows for it to be installed nicely in
--   Functor and Applicative.
data BoxedImage a

-- | A concrete instance of Image representing a gray scale image. This
--   instance is installed in DisplayFormat as a gray PGM.
type GrayImage = BoxedImage Gray
type Gray = Double

-- | Reads in a ASCII PGM image located at fileName as a GrayImage
--   
--   <pre>
--   &gt;&gt;&gt; frog &lt;- readImage "images/frog.pgm"
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/frog.jpg</a>
readImage :: FilePath -> IO GrayImage

-- | Coerces a GrayImage to a ComplexImage where the imaginary part for all
--   pixels is 0.
--   
--   <pre>
--   &gt;&gt;&gt; grayToComplex frog
--   </pre>
grayToComplex :: GrayImage -> ComplexImage

-- | Given a GrayImage, makeHotImage returns a ColorImage with the same
--   dimensions. The R, G, B values of the result image at (i, j) are
--   determined by using the value of the ColorImage at (i, j) to index
--   three lookup tables. These lookup tables implement a false coloring
--   scheme which maps small values to black, large values to white, and
--   intermediate values to shades of red, orange, and yellow (in that
--   order).
--   
--   <pre>
--   &gt;&gt;&gt; makeHotImage frog
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/makehotimage.jpg</a>
makeHotImage :: GrayImage -> ColorImage

-- | Performs bilinear interpolation of a GrayImage at the coordinates
--   provided.
ref' :: GrayImage -> Double -> Double -> Double

-- | A concrete instance of Image that represents images with color values.
--   This instance is installed in DisplayFormat and can be written to a
--   color PPM
type ColorImage = BoxedImage Color

-- | A color encoding scheme
data Color

-- | Red, Green, Blue encoding
RGB :: (Double, Double, Double) -> Color

-- | Hue, Saturation, Intensity encoding
HSI :: (Double, Double, Double) -> Color

-- | Reads in an ASCI PPM file as a ColorImage
--   
--   <pre>
--   &gt;&gt;&gt; cactii &lt;- readColorImage "images/cactii.ppm"
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/cactii.jpg</a>
readColorImage :: FilePath -> IO ColorImage

-- | Given a ColorImage, returns a GrayImage representing the Red color
--   component
--   
--   <pre>
--   &gt;&gt;&gt; let red = colorImageRed cactii
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/colorimagered.jpg</a>
colorImageRed :: ColorImage -> GrayImage

-- | Given a ColorImage, returns a GrayImage representing the Green color
--   component
--   
--   <pre>
--   &gt;&gt;&gt; let green = colorImageGreen cactii
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/colorimagegreen.jpg</a>
colorImageGreen :: ColorImage -> GrayImage

-- | Given a ColorImage, returns a GrayImage representing the Blue color
--   component
--   
--   <pre>
--   &gt;&gt;&gt; let blue = colorImageBlue cactii
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/colorimageblue.jpg</a>
colorImageBlue :: ColorImage -> GrayImage

-- | Given a ColorImage, returns a triple containing three GrayImages each
--   containing one of the color components (red, green, blue)
--   
--   <pre>
--   &gt;&gt;&gt; leftToRight' . colorImageToRGB $ cactii
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/colorimagetorgb.jpg</a>
colorImageToRGB :: ColorImage -> (GrayImage, GrayImage, GrayImage)

-- | Given a triple containing three GrayImages each containing one of the
--   color components (red, green, blue), returns a ColorImage
--   
--   <pre>
--   &gt;&gt;&gt; rgbToColorImage (red,green,blue)
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/cactii.jpg</a>
rgbToColorImage :: (GrayImage, GrayImage, GrayImage) -> ColorImage

-- | Given a ColorImage, returns a GrayImage representing the Hue component
--   
--   <pre>
--   &gt;&gt;&gt; let h = colorImageHue cactii
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/colorimagehue.jpg</a>
colorImageHue :: ColorImage -> GrayImage

-- | Given a ColorImage, returns a GrayImage representing the Saturation
--   component
--   
--   <pre>
--   &gt;&gt;&gt; let s = colorImageSaturation cactii
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/colorimagesaturation.jpg</a>
colorImageSaturation :: ColorImage -> GrayImage

-- | Given a ColorImage, returns a GrayImage representing the Intensity
--   component
--   
--   <pre>
--   &gt;&gt;&gt; let i = colorImageIntensity cactii
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/colorimageintensity.jpg</a>
colorImageIntensity :: ColorImage -> GrayImage

-- | Given a ColorImage, returns a triple containing three GrayImages each
--   containing one of the components (hue, saturation, intensity)
--   
--   <pre>
--   &gt;&gt;&gt; let (h, s, i) = colorImageToHSI $ cactii
--   </pre>
colorImageToHSI :: ColorImage -> (GrayImage, GrayImage, GrayImage)

-- | Given a triple containing three GrayImages each containing one of the
--   color components (hue, saturation, ), returns a ColorImage
--   
--   <pre>
--   &gt;&gt;&gt; hsiToColorImage (h, s, i)
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/cactii.jpg</a>
hsiToColorImage :: (GrayImage, GrayImage, GrayImage) -> ColorImage

-- | A concrete instance of Image representing pixels as complex values.
--   This instance can be written to file as a color PPM.
type ComplexImage = BoxedImage Complex
type Complex = Complex Double

-- | Given a positive integer m, a positive integer n, and a function
--   returning a pixel value, makeFilter returns an image with m rows and n
--   columns. Let x equal i if i is less than m/2 and i - m otherwise and
--   let y equal j if j is less than n/2 and j - n otherwise. To match the
--   periodicity of the 2D discrete Fourier spectrum, the value of the
--   result image at location (i, j) is computed by applying the function
--   to x and y, e.g., the value at location (0, 0) is the result of
--   applying the function to 0 and 0, the value at (m-1, n-1) is the
--   result of applying function to -1 and -1.
--   
--   <pre>
--   &gt;&gt;&gt; makeFilter 128 128 (\ r c -&gt; fromIntegral (r + c)) :: GrayImage
--   &lt; Image 128x128 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/makefilter.jpg</a>
--   
--   <pre>
--   laplacianOfGaussian :: Double -&gt; Int -&gt; Int -&gt; Double
--   laplacianOfGaussian stddev i j = ((-pi) / (stddev*stddev)) * (1 - x) * (exp (-x)) where
--     r = fromIntegral $ i*i + j*j
--     x = r / (2.0*stddev)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let d2g = makeFilter 128 128 (laplacianOfGaussian 8) :: GrayImage
--   </pre>
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/d2g.jpg</a>
--   
--   <pre>
--   gaussian :: Double -&gt; Int -&gt; Int -&gt; Double 
--   gaussian variance i j = exp (-x) where
--     r = fromIntegral $ i*i + j*j
--     x = r / (2.0*pi*variance)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let g = makeFilter 128 128 (gaussian 8) :: GrayImage
--   </pre>
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/g.jpg</a>
makeFilter :: Image img => Int -> Int -> (PixelOp (Pixel img)) -> img

-- | Given an image whose pixels can be converted to a complex value, fft
--   returns an image with complex pixels representing its 2D discrete
--   Fourier transform (DFT). Because the DFT is computed using the Fast
--   Fourier Transform (FFT) algorithm, the number of rows and columns of
--   the image must both be powers of two, i.e., 2K where K is an integer.
--   
--   <pre>
--   &gt;&gt;&gt; frog &lt;- readImage "images/frog.pgm"
--   
--   &gt;&gt;&gt; let frogpart = crop 64 64 128 128 frog
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/frog.jpg</a>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/frogpart.jpg</a>
--   
--   <pre>
--   &gt;&gt;&gt; imageMap log . fft $ frogpart :: ComplexImage
--   </pre>
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/fft.jpg</a>
--   
--   <pre>
--   &gt;&gt;&gt; fft d2g
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/fftd2g.jpg</a>
--   
--   <pre>
--   &gt;&gt;&gt; fft g
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/fftg.jpg</a>
fft :: (Image img, ComplexPixel (Pixel img), Value (Pixel img) ~ Double) => img -> ComplexImage

-- | Given an image, ifft returns a complex image representing its 2D
--   inverse discrete Fourier transform (DFT). Because the inverse DFT is
--   computed using the Fast Fourier Transform (FFT) algorithm, the number
--   of rows and columns of <a>image</a> must both be powers of two, i.e.,
--   2K where K is an integer.
--   
--   <pre>
--   &gt;&gt;&gt; ifft ((fft frogpart) * (fft d2g))
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/ifft.jpg</a>
--   
--   <pre>
--   &gt;&gt;&gt; ifft ((fft frogpart) * (fft g))
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/ifft2.jpg</a>
ifft :: (Image img, ComplexPixel (Pixel img), Value (Pixel img) ~ Double) => img -> ComplexImage

-- | Given a complex image, returns a real image representing the real part
--   of the image.
--   
--   <pre>
--   harmonicSignal :: Double -&gt; Double -&gt; Int -&gt; Int -&gt; C.Complex Double
--   harmonicSignal u v m n = exp (-pii*2.0 * var) where 
--     pii = 0.0 C.:+ pi
--     var = (u*m' + v*n') C.:+ 0.0
--     [m',n'] = map fromIntegral [m, n]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let signal = makeImage 128 128 (harmonicSignal (3/128) (2/128)) :: ComplexImage
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/signal.jpg</a>
--   
--   <pre>
--   &gt;&gt;&gt; let cosine = realPart signal
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/cosine.jpg</a>
--   
--   <pre>
--   &gt;&gt;&gt; realPart realPart . ifft $ (fft frogpart) * (fft d2g)
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/realpart.jpg</a>
--   
--   <pre>
--   &gt;&gt;&gt; realPart realPart . ifft $ (fft frogpart) * (fft g)
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/realpart2.jpg</a>
realPart :: ComplexImage -> GrayImage

-- | Given a complex image, returns a real image representing the imaginary
--   part of the image
--   
--   <pre>
--   &gt;&gt;&gt; let sine = imagPart signal
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/sine.jpg</a>
imagPart :: ComplexImage -> GrayImage

-- | Given a complex image, returns a real image representing the magnitude
--   of the image.
--   
--   <pre>
--   &gt;&gt;&gt; magnitude signal
--   </pre>
magnitude :: ComplexImage -> GrayImage

-- | Given a complex image, returns a real image representing the angle of
--   the image
--   
--   <pre>
--   &gt;&gt;&gt; angle signal
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/angle.jpg</a>
angle :: ComplexImage -> GrayImage

-- | Given an image representing the real part of a complex image, and an
--   image representing the imaginary part of a complex image, returns a
--   complex image.
--   
--   <pre>
--   &gt;&gt;&gt; complex cosine sine
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/signal.jpg</a>
complex :: GrayImage -> GrayImage -> ComplexImage

-- | Given a complex image, return a pair of real images each representing
--   a component of the complex image (real, imaginary).
--   
--   <pre>
--   &gt;&gt;&gt; leftToRight' . complexImageToRectangular $ signal
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/complexsignaltorectangular.jpg</a>
complexImageToRectangular :: ComplexImage -> (GrayImage, GrayImage)

-- | Given a complex image, returns a pair of real images each representing
--   the component (magnitude, phase) of the image
--   
--   <pre>
--   &gt;&gt;&gt; leftToRight' . complexImageToPolar $ signal
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/compleximagetopolar.jpg</a>
complexImageToPolar :: ComplexImage -> (GrayImage, GrayImage)

-- | Given a complex image and a real positive number x, shrink returns a
--   complex image with the same dimensions. Let z be the value of the
--   image at location (i, j). The value of the complex result image at
--   location (i, j) is zero if |z| &lt; x, otherwise the result has the
--   same phase as z but the amplitude is decreased by x.
shrink :: (Image img, ComplexPixel (Pixel img)) => (Value (Pixel img)) -> img -> img

-- | Given a binary image, distanceTransform returns an image representing
--   the 2D distance transform of the image. The distance transform is
--   accurate to within a 2% error for euclidean distance.
--   
--   <pre>
--   &gt;&gt;&gt; distanceTransform binaryStop :: GrayImage
--   &lt; Image 86x159 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/distancetransform.jpg</a>
distanceTransform :: (Image img, BinaryPixel (Pixel img)) => img -> GrayImage

-- | Given a binary image, label returns an image where pixels in distinct
--   connected components (based on 4-neighbor connectivity) have distinct
--   integer values. These values range from 1 to n where n is the number
--   of connected components in image.
--   
--   <pre>
--   &gt;&gt;&gt; label binaryStop
--   &lt; Image 86x159 &gt;
--   </pre>
--   
--   
--   <a>https://raw.github.com/jcollard/unm-hip/master/examples/label.jpg</a>
label :: (Image img, BinaryPixel (Pixel img)) => img -> GrayImage
instance Show Color
instance Eq Color
instance ComplexPixel Complex
instance DisplayFormat ComplexImage
instance BinaryPixel Complex
instance RealFloat a => Ord (Complex a)
instance Fractional Color
instance Num Color
instance MaxMin Color
instance Monoid Color
instance BinaryPixel Color
instance HSIPixel Color
instance RGBPixel Color
instance GrayPixel Color
instance DisplayFormat ColorImage
instance MaxMin Gray
instance Monoid Gray
instance ComplexPixel Gray
instance BinaryPixel Gray
instance HSIPixel Gray
instance RGBPixel Gray
instance GrayPixel Gray
instance DisplayFormat GrayImage
instance Eq a => Eq (BoxedImage a)
instance Ord a => Ord (BoxedImage a)
instance Fractional a => Fractional (BoxedImage a)
instance Num a => Num (BoxedImage a)
instance Show (BoxedImage a)
instance Applicative BoxedImage
instance Functor BoxedImage
instance Image (BoxedImage a)


-- | The Univeristy of New Mexico's Haskell Image Processing library
--   contains functionality for performing manipulation gray, color, and
--   complex images.
--   
--   If you want to jump right in, simply import this module and view the
--   examples at the following URL:
--   
--   <a>https://github.com/jcollard/unm-hip</a>
module Data.Image
