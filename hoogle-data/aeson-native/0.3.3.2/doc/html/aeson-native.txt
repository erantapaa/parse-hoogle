-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Fast JSON parsing and encoding (deprecated)
--   
--   A JSON parsing and encoding library optimized for ease of use and high
--   performance.
--   
--   <i>Note</i>: if you use GHCi or Template Haskell, please see the
--   <tt>README</tt> file for important details about building this
--   package, and other packages that depend on it:
--   <a>https://github.com/mailrank/aeson#readme</a>
--   
--   Parsing performance on a late 2010 MacBook Pro (2.66GHz Core i7), for
--   mostly-English tweets from Twitter's JSON search API:
--   
--   <ul>
--   <li>0.8 KB, 32-bit GHC 6.12.3: 30538 msg/sec (24.9 MB/sec)</li>
--   <li>0.8 KB, 64-bit GHC 7.0.3: 31204 msg/sec (25.4 MB/sec)</li>
--   <li>6.4 KB, 32-bit GHC 6.12.3: 6731 msg/sec (42.3 MB/sec)</li>
--   <li>6.4 KB, 64-bit GHC 7.0.3: 6627 msg/sec (41.7 MB/sec)</li>
--   <li>11.8 KB, 32-bit GHC 6.12.3: 3751 msg/sec (43.2 MB/sec)</li>
--   <li>11.8 KB, 64-bit GHC 7.0.3: 3381 msg/sec (38.9 MB/sec)</li>
--   <li>31.2 KB, 32-bit GHC 6.12.3: 1306 msg/sec (39.8 MB/sec)</li>
--   <li>31.2 KB, 64-bit GHC 7.0.3: 1132 msg/sec (34.5 MB/sec)</li>
--   <li>61.5 KB, 32-bit GHC 6.12.3: 616 msg/sec (37.0 MB/sec)</li>
--   <li>61.5 KB, 64-bit GHC 7.0.3: 534 msg/sec (32.1 MB/sec)</li>
--   </ul>
--   
--   Handling heavily-escaped text is a little more work. Here is parsing
--   performance with Japanese tweets, where much of the text is entirely
--   Unicode-escaped.
--   
--   <ul>
--   <li>14.6 KB, 32-bit GHC 6.12.3: 2315 msg/sec (33.1 MB/sec)</li>
--   <li>14.6 KB, 64-bit GHC 7.0.3: 1986 msg/sec (28.4 MB/sec)</li>
--   <li>44.1 KB, 32-bit GHC 6.12.3: 712 msg/sec (30.7 MB/sec)</li>
--   <li>44.1 KB, 64-bit GHC 7.0.3: 634 msg/sec (27.3 MB/sec)</li>
--   <li>82.9 KB, 32-bit GHC 6.12.3: 377 msg/sec (30.5 MB/sec)</li>
--   <li>82.9 KB, 64-bit GHC 7.0.3: 332 msg/sec (26.9 MB/sec)</li>
--   </ul>
--   
--   Encoding performance on the same machine and data:
--   
--   <ul>
--   <li>English, 854 bytes: 43439 msg/sec (35.4 MB/sec)</li>
--   <li>English, 6.4 KB: 7127 msg/sec (44.8 MB/sec)</li>
--   <li>Engish, 61.5 KB: 765 msg/sec (46.0 MB/sec)</li>
--   <li>Japanese, 14.6 KB: 4727 msg/sec (67.5 MB/sec)</li>
--   <li>Japanese, 44.1 KB: 1505 msg/sec (64.8 MB/sec)</li>
--   </ul>
--   
--   (A note on naming: in Greek mythology, Aeson was the father of Jason.)
@package aeson-native
@version 0.3.3.2


-- | Types for working with JSON data.
module Data.Aeson.Types

-- | A JSON value represented as a Haskell value.
data Value
Object :: Object -> Value
Array :: Array -> Value
String :: Text -> Value
Number :: Number -> Value
Bool :: !Bool -> Value
Null :: Value

-- | A JSON "array" (sequence).
type Array = Vector Value

-- | The empty array.
emptyArray :: Value

-- | A key/value pair for an <a>Object</a>.
type Pair = (Text, Value)

-- | A JSON "object" (key/value map).
type Object = Map Text Value

-- | The empty object.
emptyObject :: Value

-- | A newtype wrapper for <a>UTCTime</a> that uses the same non-standard
--   serialization format as Microsoft .NET, whose <tt>System.DateTime</tt>
--   type is by default serialized to JSON as in the following example:
--   
--   <pre>
--   /Date(1302547608878)/
--   </pre>
--   
--   The number represents milliseconds since the Unix epoch.
newtype DotNetTime
DotNetTime :: UTCTime -> DotNetTime
fromDotNetTime :: DotNetTime -> UTCTime

-- | Fail parsing due to a type mismatch, with a descriptive message.
typeMismatch :: String -> Value -> Parser a

-- | A continuation-based parser type.
data Parser a

-- | The result of running a <a>Parser</a>.
data Result a
Error :: String -> Result a
Success :: a -> Result a

-- | A type that can be converted from JSON, with the possibility of
--   failure.
--   
--   When writing an instance, use <a>mzero</a> or <a>fail</a> to make a
--   conversion fail, e.g. if an <a>Object</a> is missing a required key,
--   or the value is of the wrong type.
--   
--   An example type and instance:
--   
--   <pre>
--   data Coord { x :: Double, y :: Double }
--   
--   instance FromJSON Coord where
--      parseJSON (<a>Object</a> v) = Coord <a>&lt;$&gt;</a>
--                            v <a>.:</a> "x" <a>&lt;*&gt;</a>
--                            v <a>.:</a> "y"
--   
--   -- A non-<a>Object</a> value is of the wrong type, so use <a>mzero</a> to fail.
--      parseJSON _          = <a>mzero</a>
--   </pre>
class FromJSON a
parseJSON :: FromJSON a => Value -> Parser a

-- | Convert a value from JSON, failing if the types do not match.
fromJSON :: FromJSON a => Value -> Result a

-- | Run a <a>Parser</a>.
parse :: (a -> Parser b) -> a -> Result b

-- | Run a <a>Parser</a> with an <a>Either</a> result type.
parseEither :: (a -> Parser b) -> a -> Either String b

-- | Run a <a>Parser</a> with a <a>Maybe</a> result type.
parseMaybe :: (a -> Parser b) -> a -> Maybe b

-- | A type that can be converted to JSON.
--   
--   An example type and instance:
--   
--   <pre>
--   data Coord { x :: Double, y :: Double }
--   
--   instance ToJSON Coord where
--      toJSON (Coord x y) = <a>object</a> ["x" <a>.=</a> x, "y" <a>.=</a> y]
--   </pre>
class ToJSON a
toJSON :: ToJSON a => a -> Value

-- | Construct a <a>Pair</a> from a key and a value.
(.=) :: ToJSON a => Text -> a -> Pair

-- | Retrieve the value associated with the given key of an <a>Object</a>.
--   The result is <a>empty</a> if the key is not present or the value
--   cannot be converted to the desired type.
--   
--   This accessor is appropriate if the key and value <i>must</i> be
--   present in an object for it to be valid. If the key and value are
--   optional, use '(.:?)' instead.
(.:) :: FromJSON a => Object -> Text -> Parser a

-- | Retrieve the value associated with the given key of an <a>Object</a>.
--   The result is <a>Nothing</a> if the key is not present, or
--   <a>empty</a> if the value cannot be converted to the desired type.
--   
--   This accessor is most useful if the key and value can be absent from
--   an object without affecting its validity. If the key and value are
--   mandatory, use '(.:)' instead.
(.:?) :: FromJSON a => Object -> Text -> Parser (Maybe a)

-- | Create a <a>Value</a> from a list of name/value <a>Pair</a>s. If
--   duplicate keys arise, earlier keys and their associated values win.
object :: [Pair] -> Value
instance [incoherent] Typeable1 Result
instance [incoherent] Typeable Value
instance [incoherent] Typeable DotNetTime
instance [incoherent] Eq a => Eq (Result a)
instance [incoherent] Show a => Show (Result a)
instance [incoherent] Eq Value
instance [incoherent] Show Value
instance [incoherent] Data Value
instance [incoherent] Eq DotNetTime
instance [incoherent] Ord DotNetTime
instance [incoherent] Read DotNetTime
instance [incoherent] Show DotNetTime
instance [incoherent] FormatTime DotNetTime
instance [incoherent] FromJSON a => FromJSON (Last a)
instance [incoherent] ToJSON a => ToJSON (Last a)
instance [incoherent] FromJSON a => FromJSON (First a)
instance [incoherent] ToJSON a => ToJSON (First a)
instance [incoherent] FromJSON a => FromJSON (Dual a)
instance [incoherent] ToJSON a => ToJSON (Dual a)
instance [incoherent] (FromJSON a, FromJSON b, FromJSON c) => FromJSON (a, b, c)
instance [incoherent] (ToJSON a, ToJSON b, ToJSON c) => ToJSON (a, b, c)
instance [incoherent] (FromJSON a, FromJSON b) => FromJSON (a, b)
instance [incoherent] (ToJSON a, ToJSON b) => ToJSON (a, b)
instance [incoherent] FromJSON UTCTime
instance [incoherent] ToJSON UTCTime
instance [incoherent] FromJSON DotNetTime
instance [incoherent] ToJSON DotNetTime
instance [incoherent] FromJSON Value
instance [incoherent] ToJSON Value
instance [incoherent] FromJSON v => FromJSON (HashMap ByteString v)
instance [incoherent] ToJSON v => ToJSON (HashMap ByteString v)
instance [incoherent] FromJSON v => FromJSON (HashMap ByteString v)
instance [incoherent] ToJSON v => ToJSON (HashMap ByteString v)
instance [incoherent] FromJSON v => FromJSON (HashMap String v)
instance [incoherent] ToJSON v => ToJSON (HashMap String v)
instance [incoherent] FromJSON v => FromJSON (HashMap Text v)
instance [incoherent] ToJSON v => ToJSON (HashMap Text v)
instance [incoherent] FromJSON v => FromJSON (HashMap Text v)
instance [incoherent] ToJSON v => ToJSON (HashMap Text v)
instance [incoherent] FromJSON v => FromJSON (Map ByteString v)
instance [incoherent] ToJSON v => ToJSON (Map ByteString v)
instance [incoherent] FromJSON v => FromJSON (Map ByteString v)
instance [incoherent] ToJSON v => ToJSON (Map ByteString v)
instance [incoherent] FromJSON v => FromJSON (Map String v)
instance [incoherent] ToJSON v => ToJSON (Map String v)
instance [incoherent] FromJSON v => FromJSON (Map Text v)
instance [incoherent] ToJSON v => ToJSON (Map Text v)
instance [incoherent] FromJSON v => FromJSON (Map Text v)
instance [incoherent] ToJSON v => ToJSON (Map Text v)
instance [incoherent] FromJSON IntSet
instance [incoherent] ToJSON IntSet
instance [incoherent] (Eq a, Hashable a, FromJSON a) => FromJSON (HashSet a)
instance [incoherent] ToJSON a => ToJSON (HashSet a)
instance [incoherent] (Ord a, FromJSON a) => FromJSON (Set a)
instance [incoherent] ToJSON a => ToJSON (Set a)
instance [incoherent] FromJSON a => FromJSON (Vector a)
instance [incoherent] ToJSON a => ToJSON (Vector a)
instance [incoherent] FromJSON a => FromJSON [a]
instance [incoherent] ToJSON a => ToJSON [a]
instance [incoherent] FromJSON ByteString
instance [incoherent] ToJSON ByteString
instance [incoherent] FromJSON ByteString
instance [incoherent] ToJSON ByteString
instance [incoherent] FromJSON Text
instance [incoherent] ToJSON Text
instance [incoherent] FromJSON Text
instance [incoherent] ToJSON Text
instance [incoherent] FromJSON Word64
instance [incoherent] ToJSON Word64
instance [incoherent] FromJSON Word32
instance [incoherent] ToJSON Word32
instance [incoherent] FromJSON Word16
instance [incoherent] ToJSON Word16
instance [incoherent] FromJSON Word8
instance [incoherent] ToJSON Word8
instance [incoherent] FromJSON Word
instance [incoherent] ToJSON Word
instance [incoherent] FromJSON Int64
instance [incoherent] ToJSON Int64
instance [incoherent] FromJSON Int32
instance [incoherent] ToJSON Int32
instance [incoherent] FromJSON Int16
instance [incoherent] ToJSON Int16
instance [incoherent] FromJSON Int8
instance [incoherent] ToJSON Int8
instance [incoherent] FromJSON Integer
instance [incoherent] ToJSON Integer
instance [incoherent] FromJSON Int
instance [incoherent] ToJSON Int
instance [incoherent] FromJSON (Ratio Integer)
instance [incoherent] ToJSON (Ratio Integer)
instance [incoherent] FromJSON Float
instance [incoherent] ToJSON Float
instance [incoherent] FromJSON Number
instance [incoherent] ToJSON Number
instance [incoherent] FromJSON Double
instance [incoherent] ToJSON Double
instance [incoherent] FromJSON Char
instance [incoherent] ToJSON Char
instance [incoherent] FromJSON [Char]
instance [incoherent] ToJSON [Char]
instance [incoherent] FromJSON ()
instance [incoherent] ToJSON ()
instance [incoherent] FromJSON Bool
instance [incoherent] ToJSON Bool
instance [incoherent] (FromJSON a, FromJSON b) => FromJSON (Either a b)
instance [incoherent] (ToJSON a, ToJSON b) => ToJSON (Either a b)
instance [incoherent] FromJSON a => FromJSON (Maybe a)
instance [incoherent] ToJSON a => ToJSON (Maybe a)
instance [incoherent] Hashable Value
instance [incoherent] IsString Value
instance [incoherent] NFData Value
instance [incoherent] Monoid (Parser a)
instance [incoherent] MonadPlus Parser
instance [incoherent] Alternative Parser
instance [incoherent] Applicative Parser
instance [incoherent] Functor Parser
instance [incoherent] Monad Parser
instance [incoherent] Monoid (Result a)
instance [incoherent] Alternative Result
instance [incoherent] MonadPlus Result
instance [incoherent] Applicative Result
instance [incoherent] Monad Result
instance [incoherent] Functor Result
instance [incoherent] NFData a => NFData (Result a)


-- | JSON handling using <tt>Data.Generics</tt>.
--   
--   This is based on the <tt>Text.JSON.Generic</tt> package originally
--   written by Lennart Augustsson.
module Data.Aeson.Generic
fromJSON :: Data a => Value -> Result a
toJSON :: Data a => a -> Value


-- | Efficiently and correctly parse a JSON string. The string must be
--   encoded as UTF-8.
module Data.Aeson.Parser

-- | Parse a top-level JSON value. This must be either an object or an
--   array.
json :: Parser Value

-- | Parse any JSON value. Use <a>json</a> in preference to this function
--   if you are parsing data from an untrusted source.
value :: Parser Value


-- | Efficiently serialize a JSON value as a lazy <a>ByteString</a>,
--   encoded as UTF-8.
module Data.Aeson.Encode

-- | Encode a JSON value to a <a>Builder</a>.
fromValue :: Value -> Builder

-- | Efficiently serialize a JSON value as a lazy <a>ByteString</a>.
encode :: ToJSON a => a -> ByteString


-- | Types and functions for working efficiently with JSON data.
--   
--   (A note on naming: in Greek mythology, Aeson was the father of Jason.)
module Data.Aeson

-- | A JSON value represented as a Haskell value.
data Value
Object :: Object -> Value
Array :: Array -> Value
String :: Text -> Value
Number :: Number -> Value
Bool :: !Bool -> Value
Null :: Value

-- | A JSON "array" (sequence).
type Array = Vector Value

-- | A JSON "object" (key/value map).
type Object = Map Text Value

-- | A newtype wrapper for <a>UTCTime</a> that uses the same non-standard
--   serialization format as Microsoft .NET, whose <tt>System.DateTime</tt>
--   type is by default serialized to JSON as in the following example:
--   
--   <pre>
--   /Date(1302547608878)/
--   </pre>
--   
--   The number represents milliseconds since the Unix epoch.
newtype DotNetTime
DotNetTime :: UTCTime -> DotNetTime
fromDotNetTime :: DotNetTime -> UTCTime

-- | A type that can be converted from JSON, with the possibility of
--   failure.
--   
--   When writing an instance, use <a>mzero</a> or <a>fail</a> to make a
--   conversion fail, e.g. if an <a>Object</a> is missing a required key,
--   or the value is of the wrong type.
--   
--   An example type and instance:
--   
--   <pre>
--   data Coord { x :: Double, y :: Double }
--   
--   instance FromJSON Coord where
--      parseJSON (<a>Object</a> v) = Coord <a>&lt;$&gt;</a>
--                            v <a>.:</a> "x" <a>&lt;*&gt;</a>
--                            v <a>.:</a> "y"
--   
--   -- A non-<a>Object</a> value is of the wrong type, so use <a>mzero</a> to fail.
--      parseJSON _          = <a>mzero</a>
--   </pre>
class FromJSON a
parseJSON :: FromJSON a => Value -> Parser a

-- | The result of running a <a>Parser</a>.
data Result a
Error :: String -> Result a
Success :: a -> Result a

-- | Convert a value from JSON, failing if the types do not match.
fromJSON :: FromJSON a => Value -> Result a

-- | A type that can be converted to JSON.
--   
--   An example type and instance:
--   
--   <pre>
--   data Coord { x :: Double, y :: Double }
--   
--   instance ToJSON Coord where
--      toJSON (Coord x y) = <a>object</a> ["x" <a>.=</a> x, "y" <a>.=</a> y]
--   </pre>
class ToJSON a
toJSON :: ToJSON a => a -> Value

-- | Construct a <a>Pair</a> from a key and a value.
(.=) :: ToJSON a => Text -> a -> Pair

-- | Retrieve the value associated with the given key of an <a>Object</a>.
--   The result is <a>empty</a> if the key is not present or the value
--   cannot be converted to the desired type.
--   
--   This accessor is appropriate if the key and value <i>must</i> be
--   present in an object for it to be valid. If the key and value are
--   optional, use '(.:?)' instead.
(.:) :: FromJSON a => Object -> Text -> Parser a

-- | Retrieve the value associated with the given key of an <a>Object</a>.
--   The result is <a>Nothing</a> if the key is not present, or
--   <a>empty</a> if the value cannot be converted to the desired type.
--   
--   This accessor is most useful if the key and value can be absent from
--   an object without affecting its validity. If the key and value are
--   mandatory, use '(.:)' instead.
(.:?) :: FromJSON a => Object -> Text -> Parser (Maybe a)

-- | Create a <a>Value</a> from a list of name/value <a>Pair</a>s. If
--   duplicate keys arise, earlier keys and their associated values win.
object :: [Pair] -> Value

-- | Efficiently serialize a JSON value as a lazy <a>ByteString</a>.
encode :: ToJSON a => a -> ByteString

-- | Parse a top-level JSON value. This must be either an object or an
--   array.
json :: Parser Value
