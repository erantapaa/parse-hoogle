-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A simple request dispatcher.
--   
@package webcrank-dispatch
@version 0.1


module Webcrank.Dispatch

-- | The simplest <tt><tt>Path</tt></tt> is the <tt>root</tt> path, which
--   is equivalent to <tt>/</tt>.
root :: Path []

-- | Other routes can be built with <tt><a>/</a></tt>:
--   
--   <pre>
--   docsPath = "package" &lt;/&gt; "webcrank-dispatch-0.1" &lt;/&gt; "docs"
--   </pre>
(</>) :: Path as -> Path bs -> Path (Append as bs)

-- | Paths can contain parameters. To create a parameterized path, use
--   <tt>param</tt> as a path component:
--   
--   <pre>
--   docsPath :: Path '[String]
--   docsPath = "package" &lt;/&gt; param &lt;/&gt; "docs"
--   </pre>
--   
--   Paths can contain as many parameters of varying types as needed:
--   
--   <pre>
--   wat :: Path '[String, Int, Bool, Int, String]
--   wat :: "this" &lt;/&gt; param &lt;/&gt; param &lt;/&gt; "crazyness" &lt;/&gt; param &lt;/&gt; "ends" &lt;/&gt; param &lt;/&gt; param
--   </pre>
--   
--   Path parameters can be of any type that have instances for
--   <tt><a>Typeable</a></tt> and <tt><a>PathPiece</a></tt>.
param :: (Typeable a, PathPiece a) => Path (a : [])
data Path (as :: [*]) :: [*] -> *

-- | <tt>Path</tt>s can be rendered using <tt><a>renderPath</a></tt> and
--   <tt><a>params</a></tt>.
--   
--   <pre>
--   &gt;&gt;&gt; renderPath root params
--   ["/"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; renderPath docsPath $ params "webcrank-dispatch-0.1"
--   ["package", "webcrank-dispatch-0.1", "docs"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; renderPath wat $ params "down is up" 42 False 7 "up is down"
--   ["this", "down is up", "42", "crazyness", "False", "ends", "7", "up is down"]
--   </pre>
--   
--   Note in the last example that no encoding is done by
--   <tt>renderPath</tt>.
renderPath :: Path l -> HVect l -> [Text]
params :: HBuild' [] r => r
class HBuild' l r
hBuild' :: HBuild' l r => HVect l -> r

-- | An elementary <tt><a>Dispatcher</a></tt> can be built using
--   <tt><a>==&gt;</a></tt>.
--   
--   <pre>
--   disp = root ==&gt; "Dispatched"
--   </pre>
--   
--   <tt>Dispatcher</tt>s form a <tt><a>Monoid</a></tt>, so more
--   interesting dispatchers can be built with <tt><a>&lt;&gt;</a></tt> or
--   <tt><a>mconcat</a></tt>.
--   
--   <pre>
--   disp = mconcat
--     [ root ==&gt; "Welcome!"
--     , "echo" <a>/</a> param ==&gt; id
--     ]
--   </pre>
(==>) :: Path as -> HVectElim as a -> Dispatcher a

-- | Dispatching requests is done with <tt><a>dispatch</a></tt>. It turns a
--   <tt>Dispatcher</tt> into a function from a list of decoded path
--   components to a possible handler.
--   
--   <pre>
--   &gt;&gt;&gt; dispatch (root ==&gt; "Welcome!") [""]
--   Just "Welcome!"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dispatch (root ==&gt; "Welcome!") ["echo", "Goodbye!"]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dispatch (root ==&gt; "Welcome!" &lt;&gt; "echo" &lt;/&gt; param ==&gt; id) ["echo", "Goodbye!"]
--   Just "Goodbye!"
--   </pre>
dispatch :: Dispatcher a -> [Text] -> Maybe a
data Dispatcher a
instance AbstractRouter (SafeRouter a)
instance Monoid (Dispatcher a)
instance HBuild' (a : l) r => HBuild' l (a -> r)
instance l' ~ ReverseLoop l '[] => HBuild' l (HVect l')
