-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | NCurses bindings for Haskell
--   
@package hscurses
@version 1.4.2.0

module UI.HSCurses.Logging
trace :: String -> a -> a
debug :: MonadIO m => String -> m ()


-- | Binding to the [wn]curses library. From the ncurses man page:
--   
--   <pre>
--   The curses library routines give the user a terminal-inde-
--   pendent method of updating character screens with  reason-
--   able  optimization.
--   </pre>
--   
--   Sections of the quoted documentation are from the OpenBSD man pages,
--   which are distributed under a BSD license.
--   
--   A useful reference is: <i>Writing Programs with NCURSES</i>, by Eric
--   S. Raymond and Zeyd M. Ben-Halim,
--   <a>http://dickey.his.com/ncurses/</a>
--   
--   N.B attrs don't work with Irix curses.h. This should be fixed.
module UI.HSCurses.Curses

-- | The standard screen
stdScr :: Window

-- | initscr is normally the first curses routine to call when initializing
--   a program. curs_initscr(3):
--   
--   <pre>
--   To initialize the routines, the routine initscr or newterm
--   must be called before any of the other routines that  deal
--   with  windows  and  screens  are used.
--   </pre>
--   
--   <pre>
--   The initscr code determines the terminal type and initial-
--   izes all curses data structures.  initscr also causes  the
--   first  call  to  refresh  to  clear the screen.  If errors
--   occur, initscr writes  an  appropriate  error  message  to
--   standard error and exits; otherwise, a pointer is returned
--   to stdscr.
--   </pre>
initScr :: IO Window

-- | <tt>initCurses fn</tt> does all initialization necessary for a Curses
--   application.
initCurses :: IO ()
resetParams :: IO ()

-- | <pre>
--   The program must call endwin for each terminal being used before
--   exiting from curses.
--   </pre>
endWin :: IO ()

-- | get the dimensions of the screen (lines,cols)
scrSize :: IO (Int, Int)
type Window = Ptr WindowTag
data Border
Border :: Char -> Char -> Char -> Char -> Char -> Char -> Char -> Char -> Border
ls :: Border -> Char
rs :: Border -> Char
ts :: Border -> Char
bs :: Border -> Char
tl :: Border -> Char
tr :: Border -> Char
bl :: Border -> Char
br :: Border -> Char
touchWin :: Window -> IO ()
newPad :: Int -> Int -> IO Window
pRefresh :: Window -> Int -> Int -> Int -> Int -> Int -> Int -> IO ()
delWin :: Window -> IO ()
newWin :: Int -> Int -> Int -> Int -> IO Window

-- | wRefresh refreshes the specified window, copying the data | from the
--   virtual screen to the physical screen.
wRefresh :: Window -> IO ()

-- | Stage an update to a window, but don't actually do the refresh until
--   update is called. This allows multiple windows to be updated together
--   more smoothly.
wnoutRefresh :: Window -> IO ()

-- | <pre>
--   Draw a border around the edges of a window. defaultBorder is
--   a record  representing all 0 parameters to wrecord.
--   </pre>
wBorder :: Window -> Border -> IO ()
defaultBorder :: Border

-- | refresh curses windows and lines. curs_refresh(3)
refresh :: IO ()

-- | Do an actual update. Used after endWin on linux to restore the
--   terminal
update :: IO ()
resizeTerminal :: Int -> Int -> IO ()

-- | Set a delay in milliseconds.
timeout :: Int -> IO ()
noqiflush :: IO ()

-- | <pre>
--   move the cursor associated with the window
--   to line y and column x.  This routine does  not  move  the
--   physical  cursor  of the terminal until refresh is called.
--   The position specified is relative to the upper  left-hand
--   corner of the window, which is (0,0).
--   </pre>
--   
--   Note that <a>move_c</a> may be a macro.
move :: Int -> Int -> IO ()

-- | Get the current cursor coordinates
getYX :: Window -> IO (Int, Int)

-- | read a character from the window
getCh :: IO Key

-- | <pre>
--   The getch, wgetch, mvgetch and mvwgetch, routines read a
--   character  from the window.
--   </pre>
getch :: IO CInt
decodeKey :: CInt -> Key
ungetCh :: Integral a => a -> IO ()
keyResizeCode :: Maybe CInt

-- | <pre>
--   The cbreak routine
--   disables line buffering and erase/kill  character-process-
--   ing  (interrupt  and  flow  control  characters  are unaf-
--   fected), making characters typed by the  user  immediately
--   available  to  the  program.  The nocbreak routine returns
--   the terminal to normal (cooked) mode.
--   </pre>
cBreak :: Bool -> IO ()

-- | <pre>
--   The  raw and noraw routines place the terminal into or out
--    of raw mode.  Raw mode is similar to cbreak mode, in  that
--    characters  typed  are  immediately  passed through to the
--    user program.  The differences are that in raw  mode,  the
--    interrupt,  quit, suspend, and flow control characters are
--    all passed through uninterpreted, instead of generating  a
--    signal.   The  behavior  of the BREAK key depends on other
--    bits in the tty driver that are not set by curses.
--   </pre>
raw :: Bool -> IO ()

-- | <pre>
--   The  echo  and  noecho routines control whether characters
--    typed by the user are echoed by getch as they  are  typed.
--    Echoing  by  the  tty  driver is always disabled, but ini-
--    tially getch is in echo  mode,  so  characters  typed  are
--    echoed.  Authors of most interactive programs prefer to do
--    their own echoing in a controlled area of the  screen,  or
--    not  to  echo  at  all, so they disable echoing by calling
--    noecho.  [See curs_getch(3) for a discussion of how  these
--    routines interact with cbreak and nocbreak.]
--   </pre>
echo :: Bool -> IO ()

-- | <pre>
--   If  the intrflush option is enabled, (bf is TRUE), when an
--    interrupt key  is  pressed  on  the  keyboard  (interrupt,
--    break,  quit)  all  output in the tty driver queue will be
--    flushed, giving the  effect  of  faster  response  to  the
--    interrupt,  but  causing  curses to have the wrong idea of
--    what is on the  screen.   Disabling  (bf  is  FALSE),  the
--    option  prevents the flush.
--   </pre>
intrFlush :: Bool -> IO ()

-- | Enable the keypad of the user's terminal.
keypad :: Window -> Bool -> IO ()
noDelay :: Window -> Bool -> IO ()

-- | normalise the string, stripping \r and making control chars printable.
--   Called over all output(?)
wAddStr :: Window -> [Char] -> IO ()
addLn :: IO ()
mvWAddStr :: Window -> Int -> Int -> String -> IO ()
mvAddCh :: Int -> Int -> ChType -> IO ()

-- | <pre>
--   move the cursor associated with the window
--   to line y and column x.  This routine does  not  move  the
--   physical  cursor  of the terminal until refresh is called.
--   The position specified is relative to the upper  left-hand
--   corner of the window, which is (0,0).
--   </pre>
wMove :: Window -> Int -> Int -> IO ()
bkgrndSet :: Attr -> Pair -> IO ()

-- | Copy blanks to every position in the screen.
erase :: IO ()

-- | Copy blanks to a window and set clearOk for that window.
wclear :: Window -> IO ()

-- | Copy blanks to every position in a window.
werase :: Window -> IO ()
clrToEol :: IO ()
wClrToEol :: Window -> IO ()
beep :: IO ()

-- | Raw NCurses routine.
waddch :: Window -> ChType -> IO CInt

-- | Raw NCurses routine.
winsch :: Window -> ChType -> IO CInt

-- | Raw NCurses routine.
waddchnstr :: Window -> CString -> CInt -> IO CInt
clearOk :: Bool -> IO CInt

-- | Normally, the hardware cursor is left at the location of the window
--   cursor being refreshed. The leaveok option allows the cursor to be
--   left wherever the update happens to leave it. It is useful for
--   applications where the cur- sor is not used, since it reduces the need
--   for cursor motions. If possible, the cursor is made invisible when
--   this option is enabled.
leaveOk :: Bool -> IO CInt

-- | <pre>
--   The  nl  and  nonl routines control whether the underlying
--    display device translates the return key into  newline  on
--    input,  and  whether it translates newline into return and
--    line-feed on output (in either case, the call  addch('\n')
--    does the equivalent of return and line feed on the virtual
--    screen).  Initially, these translations do occur.  If  you
--    disable  them using nonl, curses will be able to make bet-
--    ter use of the line-feed capability, resulting  in  faster
--    cursor  motion.   Also, curses will then be able to detect
--    the return key.
--   </pre>
nl :: Bool -> IO ()
data CursorVisibility
CursorInvisible :: CursorVisibility
CursorVisible :: CursorVisibility
CursorVeryVisible :: CursorVisibility

-- | Set the cursor state
--   
--   <pre>
--   The curs_set routine sets  the  cursor  state  is  set  to
--   invisible, normal, or very visible for visibility equal to
--   0, 1, or 2 respectively.  If  the  terminal  supports  the
--   visibility   requested,   the  previous  cursor  state  is
--   returned; otherwise, ERR is returned.
--   </pre>
cursSet :: CursorVisibility -> IO CursorVisibility
hasColors :: IO Bool

-- | Initialise the color settings, also sets the screen to the default
--   colors (white on black)
startColor :: IO ()
useDefaultColors :: IO ()
newtype Pair
Pair :: Int -> Pair

-- | colorPairs defines the maximum number of color-pairs the terminal can
--   support).
colorPairs :: IO Int
newtype Color
Color :: Int -> Color
colors :: IO Int
color :: String -> Maybe Color

-- | curses support color attributes on terminals with that capability. To
--   use these routines start_color must be called, usually right after
--   initscr. Colors are always used in pairs (referred to as color-pairs).
--   A color-pair consists of a foreground color (for characters) and a
--   background color (for the blank field on which the charac- ters are
--   displayed). A programmer initializes a color- pair with the routine
--   init_pair. After it has been ini- tialized, COLOR_PAIR(n), a macro
--   defined in <a>curses.h</a>, can be used as a new video attribute.
--   
--   If a terminal is capable of redefining colors, the pro- grammer can
--   use the routine init_color to change the defi- nition of a color.
--   
--   The init_pair routine changes the definition of a color- pair. It
--   takes three arguments: the number of the color- pair to be changed,
--   the foreground color number, and the background color number. For
--   portable applications:
--   
--   <ul>
--   <li>The value of the first argument must be between 1 and
--   COLOR_PAIRS-1.<ul><li>The value of the second and third arguments must
--   be between 0 and COLORS (the 0 color pair is wired to white on black
--   and cannot be changed).</li></ul></li>
--   </ul>
initPair :: Pair -> Color -> Color -> IO ()
pairContent :: Pair -> IO (Color, Color)
canChangeColor :: IO Bool
initColor :: Color -> (Int, Int, Int) -> IO ()
colorContent :: Color -> IO (Int, Int, Int)
defaultBackground :: Color
defaultForeground :: Color
attrPlus :: Attr -> Attr -> Attr
data Attr

-- | Normal display (no highlight)
attr0 :: Attr
isAltCharset :: Attr -> Bool
isBlink :: Attr -> Bool
isBold :: Attr -> Bool
isDim :: Attr -> Bool
isHorizontal :: Attr -> Bool
isInvis :: Attr -> Bool
isLeft :: Attr -> Bool
isLow :: Attr -> Bool
isProtect :: Attr -> Bool
isReverse :: Attr -> Bool
isRight :: Attr -> Bool
isStandout :: Attr -> Bool
isTop :: Attr -> Bool
isUnderline :: Attr -> Bool
isVertical :: Attr -> Bool

-- | Setting attributes
setAltCharset :: Attr -> Bool -> Attr

-- | Setting attributes
setBlink :: Attr -> Bool -> Attr

-- | Setting attributes
setBold :: Attr -> Bool -> Attr

-- | Setting attributes
setDim :: Attr -> Bool -> Attr

-- | Setting attributes
setHorizontal :: Attr -> Bool -> Attr

-- | Setting attributes
setInvis :: Attr -> Bool -> Attr

-- | Setting attributes
setLeft :: Attr -> Bool -> Attr

-- | Setting attributes
setLow :: Attr -> Bool -> Attr

-- | Setting attributes
setProtect :: Attr -> Bool -> Attr

-- | Setting attributes
setReverse :: Attr -> Bool -> Attr

-- | Setting attributes
setRight :: Attr -> Bool -> Attr

-- | Setting attributes
setStandout :: Attr -> Bool -> Attr

-- | Setting attributes
setTop :: Attr -> Bool -> Attr

-- | Setting attributes
setUnderline :: Attr -> Bool -> Attr

-- | Setting attributes
setVertical :: Attr -> Bool -> Attr
attrSet :: Attr -> Pair -> IO ()
attrOn :: Attr -> IO ()
attrOff :: Attr -> IO ()
standout :: IO Int
standend :: IO Int
attrDim :: Int
attrBold :: Int
attrDimOn :: IO ()
attrDimOff :: IO ()
attrBoldOn :: IO ()
attrBoldOff :: IO ()
wAttrOn :: Window -> Int -> IO ()
wAttrOff :: Window -> Int -> IO ()
wAttrSet :: Window -> (Attr, Pair) -> IO ()

-- | manipulate the current attributes of the named window. see
--   curs_attr(3)
wAttrGet :: Window -> IO (Attr, Pair)
withMouseEventMask :: MonadIO m => [ButtonEvent] -> m a -> m a
data ButtonEvent
ButtonPressed :: Int -> ButtonEvent
ButtonReleased :: Int -> ButtonEvent
ButtonClicked :: Int -> ButtonEvent
ButtonDoubleClicked :: Int -> ButtonEvent
ButtonTripleClicked :: Int -> ButtonEvent
ButtonShift :: ButtonEvent
ButtonControl :: ButtonEvent
ButtonAlt :: ButtonEvent
data MouseEvent
MouseEvent :: Int -> Int -> Int -> Int -> [ButtonEvent] -> MouseEvent
mouseEventId :: MouseEvent -> Int
mouseEventX :: MouseEvent -> Int
mouseEventY :: MouseEvent -> Int
mouseEventZ :: MouseEvent -> Int
mouseEventButton :: MouseEvent -> [ButtonEvent]

-- | Map curses keys to key abstraction
data Key
KeyChar :: Char -> Key
KeyBreak :: Key
KeyDown :: Key
KeyUp :: Key
KeyLeft :: Key
KeyRight :: Key
KeyHome :: Key
KeyBackspace :: Key
KeyF :: Int -> Key
KeyDL :: Key
KeyIL :: Key
KeyDC :: Key
KeyIC :: Key
KeyEIC :: Key
KeyClear :: Key
KeyEOS :: Key
KeyEOL :: Key
KeySF :: Key
KeySR :: Key
KeyNPage :: Key
KeyPPage :: Key
KeySTab :: Key
KeyCTab :: Key
KeyCATab :: Key
KeyEnter :: Key
KeySReset :: Key
KeyReset :: Key
KeyPrint :: Key
KeyLL :: Key
KeyA1 :: Key
KeyA3 :: Key
KeyB2 :: Key
KeyC1 :: Key
KeyC3 :: Key
KeyBTab :: Key
KeyBeg :: Key
KeyCancel :: Key
KeyClose :: Key
KeyCommand :: Key
KeyCopy :: Key
KeyCreate :: Key
KeyEnd :: Key
KeyExit :: Key
KeyFind :: Key
KeyHelp :: Key
KeyMark :: Key
KeyMessage :: Key
KeyMove :: Key
KeyNext :: Key
KeyOpen :: Key
KeyOptions :: Key
KeyPrevious :: Key
KeyRedo :: Key
KeyReference :: Key
KeyRefresh :: Key
KeyReplace :: Key
KeyRestart :: Key
KeyResume :: Key
KeySave :: Key
KeySBeg :: Key
KeySCancel :: Key
KeySCommand :: Key
KeySCopy :: Key
KeySCreate :: Key
KeySDC :: Key
KeySDL :: Key
KeySelect :: Key
KeySEnd :: Key
KeySEOL :: Key
KeySExit :: Key
KeySFind :: Key
KeySHelp :: Key
KeySHome :: Key
KeySIC :: Key
KeySLeft :: Key
KeySMessage :: Key
KeySMove :: Key
KeySNext :: Key
KeySOptions :: Key
KeySPrevious :: Key
KeySPrint :: Key
KeySRedo :: Key
KeySReplace :: Key
KeySRight :: Key
KeySRsume :: Key
KeySSave :: Key
KeySSuspend :: Key
KeySUndo :: Key
KeySuspend :: Key
KeyUndo :: Key
KeyResize :: Key
KeyMouse :: Key
KeyUnknown :: Int -> Key
cERR :: CInt
cKEY_UP :: ChType
cKEY_DOWN :: ChType
cKEY_LEFT :: ChType
cKEY_RIGHT :: ChType
cTRUE :: NBool
vline :: Char -> Int -> IO ()
ulCorner :: Char
llCorner :: Char
urCorner :: Char
lrCorner :: Char
rTee :: Char
lTee :: Char
bTee :: Char
tTee :: Char
hLine :: Char
vLine :: Char
plus :: Char
s1 :: Char
s9 :: Char
diamond :: Char
ckBoard :: Char
degree :: Char
plMinus :: Char
bullet :: Char
lArrow :: Char
rArrow :: Char
dArrow :: Char
uArrow :: Char
board :: Char
lantern :: Char
block :: Char
s3 :: Char
s7 :: Char
lEqual :: Char
gEqual :: Char
pi :: Char
nEqual :: Char
sterling :: Char

-- | The SIGWINCH signal is sent whenever the terminal size changes. This
--   signal is not available on all platforms, so it is a |Maybe| value.
cursesSigWinch :: Maybe Signal
cursesTest :: IO ()
throwIfErr :: (Eq a, Show a, Num a) => String -> IO a -> IO a
throwIfErr_ :: (Eq a, Show a, Num a) => String -> IO a -> IO ()
errI :: IO CInt -> IO ()
flushinp :: IO CInt
recognize :: Char -> IO a -> (ChType -> IO a) -> IO a
type ChType = Word64
type NBool = Word8
instance Eq Pair
instance Ord Pair
instance Ix Pair
instance Show Pair
instance Eq Color
instance Ord Color
instance Ix Color
instance Eq Attr
instance Storable Attr
instance Bits Attr
instance Num Attr
instance Show Attr
instance Eq Key
instance Show Key
instance Eq ButtonEvent
instance Show ButtonEvent
instance Show MouseEvent

module UI.HSCurses.CursesHelper

-- | <tt>start</tt> initializes the UI and grabs the keyboard.
--   
--   This function installs a handler for the SIGWINCH signal which writes
--   the KEY_RESIZE key to the input queue (if KEY_RESIZE and and SIGWINCH
--   are both available).
start :: IO ()

-- | Clean up and go home.
end :: IO ()

-- | Suspend the program.
suspend :: IO ()

-- | Resize the window From "Writing Programs with NCURSES", by Eric S.
--   Raymond and Zeyd M. Ben-Halim
resizeui :: IO (Int, Int)

-- | <tt>getKey refresh</tt> reads a key.
--   
--   The <tt>refresh</tt> function is used to redraw the screen when the
--   terminal size changes (see the documentatio of <tt>start</tt> for a
--   discussion of the problem).
getKey :: MonadIO m => m () -> m Key

-- | <tt>drawLine n s</tt> draws <tt>n</tt> characters of string
--   <tt>s</tt>.
drawLine :: Int -> String -> IO ()

-- | Draw the cursor at the given position.
drawCursor :: (Int, Int) -> (Int, Int) -> IO ()

-- | Move cursor to origin of stdScr.
gotoTop :: IO ()

-- | Foreground colors.
data ForegroundColor
BlackF :: ForegroundColor
GreyF :: ForegroundColor
DarkRedF :: ForegroundColor
RedF :: ForegroundColor
DarkGreenF :: ForegroundColor
GreenF :: ForegroundColor
BrownF :: ForegroundColor
YellowF :: ForegroundColor
DarkBlueF :: ForegroundColor
BlueF :: ForegroundColor
PurpleF :: ForegroundColor
MagentaF :: ForegroundColor
DarkCyanF :: ForegroundColor
CyanF :: ForegroundColor
WhiteF :: ForegroundColor
BrightWhiteF :: ForegroundColor
DefaultF :: ForegroundColor

-- | Background colors.
data BackgroundColor
BlackB :: BackgroundColor
DarkRedB :: BackgroundColor
DarkGreenB :: BackgroundColor
BrownB :: BackgroundColor
DarkBlueB :: BackgroundColor
PurpleB :: BackgroundColor
DarkCyanB :: BackgroundColor
WhiteB :: BackgroundColor
DefaultB :: BackgroundColor

-- | Basic colors.
defaultColor :: Color
black :: Color
red :: Color
green :: Color
yellow :: Color
blue :: Color
magenta :: Color
cyan :: Color
white :: Color

-- | Abstractions for some commonly used attributes.
data Attribute
Bold :: Attribute
Underline :: Attribute
Dim :: Attribute
Reverse :: Attribute
Blink :: Attribute

-- | Converts an abstract attribute list into its curses representation.
convertAttributes :: [Attribute] -> Attr

-- | A humand-readable style.
data Style
Style :: ForegroundColor -> BackgroundColor -> Style
AttributeStyle :: [Attribute] -> ForegroundColor -> BackgroundColor -> Style
ColorlessStyle :: [Attribute] -> Style

-- | A style which uses the internal curses representations for attributes
--   and colors.
data CursesStyle
mkCursesStyle :: [Attribute] -> CursesStyle

-- | Changes the attributes of the given CursesStyle.
changeCursesStyle :: CursesStyle -> [Attribute] -> CursesStyle

-- | Manipulate the current style of the standard screen
setStyle :: CursesStyle -> IO ()
wSetStyle :: Window -> CursesStyle -> IO ()

-- | Reset the screen to normal values
resetStyle :: IO ()
wResetStyle :: Window -> IO ()

-- | Converts a list of human-readable styles into the corresponding curses
--   representation.
--   
--   This function should be called exactly once at application startup for
--   all styles of the application.
convertStyles :: [Style] -> IO [CursesStyle]
defaultStyle :: Style
defaultCursesStyle :: CursesStyle
withStyle :: (MonadIO m, MonadMask m) => CursesStyle -> m a -> m a
wWithStyle :: (MonadIO m, MonadMask m) => Window -> CursesStyle -> m a -> m a

-- | Converting keys to humand-readable strings
displayKey :: Key -> String

-- | Other helpers
--   
--   set the cursor, and do action
withCursor :: (MonadIO m, MonadMask m) => CursorVisibility -> m a -> m a
withProgram :: (MonadIO m, MonadMask m) => m a -> m a
instance Eq ForegroundColor
instance Show ForegroundColor
instance Eq BackgroundColor
instance Show BackgroundColor
instance Eq Attribute
instance Show Attribute
instance Eq Style
instance Show Style
instance Eq CursesStyle
instance Show CursesStyle

module UI.HSCurses.Widgets
type Pos = (Int, Int)
type Offset = (Int, Int)
type Size = (Int, Int)
getHeight :: Size -> Int
getWidth :: Size -> Int
getYOffset :: Offset -> Int
getXOffset :: Offset -> Int
getYPos :: Pos -> Int
getXPos :: Pos -> Int
data Direction
DirLeft :: Direction
DirRight :: Direction
DirUp :: Direction
DirDown :: Direction
data HAlignment
AlignLeft :: HAlignment
AlignCenter :: HAlignment
AlignRight :: HAlignment
data Cont a
Cont :: a -> Cont a
Done :: a -> Cont a
class Widget a
draw :: Widget a => Pos -> Size -> DrawingHint -> a -> IO ()
minSize :: Widget a => a -> Size
class Widget a => ActiveWidget a
activate :: (ActiveWidget a, MonadIO m, MonadMask m) => m () -> Pos -> Size -> a -> m (a, String)
type KeyHandler a = Pos -> Size -> a -> IO (Cont a)
mkKeyHandler :: (Pos -> Size -> a -> a) -> KeyHandler a
data DrawingHint
DHNormal :: DrawingHint
DHFocus :: DrawingHint
DHActive :: DrawingHint
data DrawingStyle
DStyle :: CursesStyle -> CursesStyle -> CursesStyle -> DrawingStyle
dstyle_normal :: DrawingStyle -> CursesStyle
dstyle_focus :: DrawingStyle -> CursesStyle
dstyle_active :: DrawingStyle -> CursesStyle
mkDrawingStyle :: CursesStyle -> DrawingStyle
defaultDrawingStyle :: DrawingStyle
_draw :: DrawingHint -> DrawingStyle -> IO a -> IO a
scrollFactor :: Double
scrollBy :: Int -> Int
scrollForward :: Int -> Int -> Int -> Int
scrollBackward :: t -> Int -> Int -> Int
data EmptyWidget
EmptyWidget :: Size -> EmptyWidget
data OpaqueWidget
OpaqueWidget :: Size -> OpaqueWidget
data EditWidget
EditWidget :: String -> Int -> Int -> [String] -> Int -> Maybe String -> EditWidgetOptions -> EditWidget
ew_content :: EditWidget -> String
ew_xoffset :: EditWidget -> Int
ew_xcursor :: EditWidget -> Int
ew_history :: EditWidget -> [String]
ew_historyIndex :: EditWidget -> Int
ew_historySavedContent :: EditWidget -> Maybe String
ew_options :: EditWidget -> EditWidgetOptions
ew_contentPos :: EditWidget -> Int
data EditWidgetOptions
EWOptions :: [(Key, KeyHandler EditWidget)] -> Int -> DrawingStyle -> EditWidgetOptions
ewopt_keyHandlers :: EditWidgetOptions -> [(Key, KeyHandler EditWidget)]
ewopt_minWidth :: EditWidgetOptions -> Int
ewopt_style :: EditWidgetOptions -> DrawingStyle
defaultEWOptions :: EditWidgetOptions
newEditWidget :: EditWidgetOptions -> String -> EditWidget
editWidgetGoLeft :: Pos -> Size -> EditWidget -> IO (Cont EditWidget)
editWidgetGoRight :: Pos -> Size -> EditWidget -> IO (Cont EditWidget)
editWidgetDeleteLeft :: Pos -> Size -> EditWidget -> IO (Cont EditWidget)
editWidgetDeleteUnderCursor :: Pos -> Size -> EditWidget -> IO (Cont EditWidget)
editWidgetDeleteToEnd :: Pos -> Size -> EditWidget -> IO (Cont EditWidget)
editWidgetGoHome :: Pos -> Size -> EditWidget -> IO (Cont EditWidget)
editWidgetGoEnd :: Pos -> Size -> EditWidget -> IO (Cont EditWidget)
editWidgetHistoryUp :: Pos -> Size -> EditWidget -> IO (Cont EditWidget)
editWidgetHistoryDown :: Pos -> Size -> EditWidget -> IO (Cont EditWidget)
editWidgetKeyHandlers :: [(Key, Pos -> Size -> EditWidget -> IO (Cont EditWidget))]
editWidgetGetContent :: EditWidget -> String
editWidgetSetContent :: EditWidget -> String -> EditWidget
editWidgetGetOptions :: EditWidget -> EditWidgetOptions
editWidgetSetOptions :: EditWidget -> EditWidgetOptions -> EditWidget
drawEditWidget :: Pos -> Size -> DrawingHint -> EditWidget -> IO ()
activateEditWidget :: (MonadIO m, MonadMask m) => m () -> Pos -> Size -> EditWidget -> m (EditWidget, String)
editWidgetGoLeft' :: t -> t1 -> EditWidget -> EditWidget
editWidgetGoRight' :: t -> (t1, Int) -> EditWidget -> EditWidget
editWidgetDeleteLeft' :: Pos -> Size -> EditWidget -> EditWidget
editWidgetDeleteUnderCursor' :: t -> t1 -> EditWidget -> EditWidget
editWidgetDeleteToEnd' :: t -> t1 -> EditWidget -> EditWidget
editWidgetGoHome' :: t -> t1 -> EditWidget -> EditWidget
editWidgetGoEnd' :: Pos -> Size -> EditWidget -> EditWidget
editWidgetFinish :: Monad m => t -> t1 -> EditWidget -> m (Cont EditWidget)
maxHistoryLength :: Int
addToHistory :: EditWidget -> [Char] -> EditWidget
editWidgetHistoryUp' :: t -> t1 -> EditWidget -> EditWidget
editWidgetHistoryDown' :: t -> t1 -> EditWidget -> EditWidget
editWidgetHistory :: Num t => (Int -> t -> Int) -> EditWidget -> EditWidget
data TextWidget
TextWidget :: String -> Int -> Int -> TextWidgetOptions -> TextWidget
tw_text :: TextWidget -> String
tw_yoffset :: TextWidget -> Int
tw_xoffset :: TextWidget -> Int
tw_options :: TextWidget -> TextWidgetOptions
data TextWidgetSize
TWSizeDefault :: TextWidgetSize
TWSizeFixed :: Size -> TextWidgetSize
data TextWidgetOptions
TWOptions :: TextWidgetSize -> DrawingStyle -> HAlignment -> TextWidgetOptions
twopt_size :: TextWidgetOptions -> TextWidgetSize
twopt_style :: TextWidgetOptions -> DrawingStyle
twopt_halign :: TextWidgetOptions -> HAlignment
defaultTWOptions :: TextWidgetOptions
newTextWidget :: TextWidgetOptions -> String -> TextWidget
drawTextWidget :: Pos -> Size -> DrawingHint -> TextWidget -> IO ()
textWidgetGetText :: TextWidget -> String
textWidgetSetText :: TextWidget -> String -> TextWidget
textWidgetScrollDown :: Size -> TextWidget -> TextWidget
textWidgetScrollUp :: Size -> TextWidget -> TextWidget
textWidgetScrollLeft :: Size -> TextWidget -> TextWidget
textWidgetScrollRight :: Size -> TextWidget -> TextWidget
data TableCell
TableCell :: w -> TableCell
ActiveTableCell :: w -> TableCell
isActive :: TableCell -> Bool
_activateTableCell :: (MonadIO m, MonadMask m) => m () -> Pos -> Size -> TableCell -> m (TableCell, String)
type Row = [TableCell]
singletonRow :: TableCell -> Row
getCellWidget :: TableWidget -> (Int, Int) -> TableCell
setCellWidget :: TableWidget -> (Int, Int) -> TableCell -> TableWidget
data TableWidget
TableWidget :: [Row] -> Int -> Maybe Pos -> TableWidgetOptions -> TableWidget
tbw_rows :: TableWidget -> [Row]
tbw_colOffset :: TableWidget -> Int
tbw_pos :: TableWidget -> Maybe Pos
tbw_options :: TableWidget -> TableWidgetOptions
data FillRow
First :: FillRow
Last :: FillRow
None :: FillRow
data TableWidgetOptions
TBWOptions :: Maybe Int -> FillRow -> [Int] -> Size -> TableWidgetOptions
tbwopt_fillCol :: TableWidgetOptions -> Maybe Int
tbwopt_fillRow :: TableWidgetOptions -> FillRow
tbwopt_activeCols :: TableWidgetOptions -> [Int]
tbwopt_minSize :: TableWidgetOptions -> Size
defaultTBWOptions :: TableWidgetOptions
newTableWidget :: TableWidgetOptions -> [Row] -> TableWidget
data TableWidgetDisplayInfo
TBWDisplayInfo :: Int -> Int -> Int -> Int -> [Row] -> Int -> [Int] -> [Int] -> Maybe (Int, Size) -> TableWidgetDisplayInfo
tbwdisp_height :: TableWidgetDisplayInfo -> Int
tbwdisp_width :: TableWidgetDisplayInfo -> Int
tbwdisp_firstVis :: TableWidgetDisplayInfo -> Int
tbwdisp_lastVis :: TableWidgetDisplayInfo -> Int
tbwdisp_rows :: TableWidgetDisplayInfo -> [Row]
tbwdisp_nrows :: TableWidgetDisplayInfo -> Int
tbwdisp_heights :: TableWidgetDisplayInfo -> [Int]
tbwdisp_widths :: TableWidgetDisplayInfo -> [Int]
tbwdisp_rightMargin :: TableWidgetDisplayInfo -> Maybe (Int, Size)
tableWidgetDisplayInfo :: Size -> TableWidget -> TableWidgetDisplayInfo
getCellInfo :: Pos -> Size -> TableWidget -> (Int, Int) -> (Pos, Size)
drawTableWidget :: Pos -> Size -> DrawingHint -> TableWidget -> IO ()
tableWidgetScrollDown :: Size -> TableWidget -> TableWidget
tableWidgetScrollUp :: Size -> TableWidget -> TableWidget
tableWidgetActivateCurrent :: (MonadIO m, MonadMask m) => m () -> Pos -> Size -> DrawingHint -> TableWidget -> m (TableWidget, Maybe String)
tableWidgetGoLeft :: Size -> TableWidget -> TableWidget
tableWidgetGoRight :: Size -> TableWidget -> TableWidget
tableWidgetGoUp :: Size -> TableWidget -> TableWidget
tableWidgetGoDown :: Size -> TableWidget -> TableWidget
tableWidgetMove :: Direction -> (Int, Int) -> TableWidget -> TableWidget
tableWidgetMakeVisible :: TableWidget -> (Int, Int) -> Int -> TableWidget
findFirstActiveCell :: [Row] -> TableWidgetOptions -> Maybe Pos
findNextActiveCell :: TableWidgetOptions -> Int -> Pos -> Direction -> Maybe Pos
tableWidgetDeleteRow :: Int -> TableWidget -> TableWidget

-- | Join a list by some delimiter
joinLists :: [[a]] -> [a] -> [a]

-- | Split a list by some delimiter
splitList :: Eq a => [a] -> [a] -> [[a]]
listReplace :: [a] -> a -> Int -> [a]
alignRows :: [[[a]]] -> a -> [a] -> [[a]]
align :: HAlignment -> Int -> a -> [a] -> [a]
deleteAt :: Int -> [a] -> [a]
instance Eq Direction
instance Show Direction
instance Ord Direction
instance Eq HAlignment
instance Show HAlignment
instance Eq DrawingHint
instance Show DrawingHint
instance Ord DrawingHint
instance Eq DrawingStyle
instance Show DrawingStyle
instance Eq TextWidgetSize
instance Show TextWidgetSize
instance Eq TextWidgetOptions
instance Show TextWidgetOptions
instance Eq TextWidget
instance Show TextWidget
instance Eq FillRow
instance Show FillRow
instance Eq TableWidgetOptions
instance Show TableWidgetOptions
instance Widget TableWidget
instance Widget TableCell
instance Widget TextWidget
instance ActiveWidget EditWidget
instance Widget EditWidget
instance Widget OpaqueWidget
instance Widget EmptyWidget
