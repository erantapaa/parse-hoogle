-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generic rewrite rules with safe treatment of variables and binders
--   
@package ho-rewriting
@version 0.1


-- | Rewrite rules
module Data.Rewriting.Rules

-- | Rewrite rules
data Rule lhs rhs
Rule :: lhs a -> rhs a -> Rule lhs rhs

-- | Construct a rule from an LHS and an RHS
(===>) :: lhs a -> rhs a -> Rule lhs rhs

-- | Representations supporting wildcards
class WildCard r
__ :: WildCard r => r a

-- | Meta-variable applied to a number of <a>Var</a> expressions
data MetaExp r a
MVar :: MetaRep r a -> MetaExp r a
MApp :: MetaExp r (a -> b) -> MetaArg r a -> MetaExp r b

-- | Representations supporting meta-variables
class MetaVar r where type family MetaRep r :: * -> * type family MetaArg r :: * -> *
metaExp :: MetaVar r => MetaExp r a -> r a

-- | Construct a meta-variable
mvar :: MetaVar r => MetaRep r a -> r a

-- | Meta-variable application (used for all but the first and last
--   variable)
($$) :: MetaExp r (a -> b) -> MetaArg r a -> MetaExp r b

-- | Meta-variable application (used for the last variable)
($-) :: MetaVar r => MetaExp r (a -> b) -> MetaArg r a -> r b

-- | Meta-variable application (used for the first variable)
(-$) :: MetaRep r (a -> b) -> MetaArg r a -> MetaExp r b

-- | Meta-variable application (used when there is only variable)
(-$-) :: MetaVar r => MetaRep r (a -> b) -> MetaArg r a -> r b

-- | Variable identifier
type Name = Integer

-- | Typed meta-variable identifiers
newtype MetaId a
MetaId :: Name -> MetaId a

-- | Rules that may take a number of meta-variables as arguments. Those
--   meta-variables are implicitly forall-quantified.
class Quantifiable rule where type family RuleType rule
quantify' :: Quantifiable rule => Name -> rule -> RuleType rule

-- | Base case: no meta-variables

-- | Recursive case: one more meta-variable

-- | Forall-quantify the meta-variable arguments of a rule
quantify :: (Quantifiable rule, RuleType rule ~ Rule lhs rhs) => rule -> Rule lhs rhs

-- | Functor representing wildcards
data WILD a
WildCard :: WILD a

-- | Functor representing meta variables applied to a number of <a>Var</a>
--   expressions
data META r a
Meta :: (MetaExp r b) -> META r a

-- | Left hand side of a rule
newtype LHS f a
LHS :: Term (WILD :+: (META (LHS f) :+: f)) -> LHS f a
unLHS :: LHS f a -> Term (WILD :+: (META (LHS f) :+: f))

-- | Right hand side of a rule
newtype RHS f a
RHS :: Term (META (RHS f) :+: f) -> RHS f a
unRHS :: RHS f a -> Term (META (RHS f) :+: f)

-- | Representation of object variables
class Rep r where type family PF r :: * -> *
toRep :: Rep r => Term (PF r) -> r a
fromRep :: Rep r => r a -> Term (PF r)
tRule :: Patch (Rule (LHS f) (RHS f)) (Rule (LHS f) (RHS f))
data A
A :: A
data B
B :: B
data C
C :: C
tA :: Patch A A
tB :: Patch B B
tC :: Patch C C

-- | Substitution
type Subst f = [(Name, Term f)]
instance Eq (MetaId a)
instance Show (MetaId a)
instance Ord (MetaId a)
instance Num (MetaId a)
instance Enum (MetaId a)
instance Real (MetaId a)
instance Integral (MetaId a)
instance Eq (WILD a)
instance Show (WILD a)
instance Functor WILD
instance Foldable WILD
instance Traversable WILD
instance Eq A
instance Eq B
instance Eq C
instance Rep (RHS f)
instance Rep (LHS f)
instance MetaVar (RHS f)
instance MetaVar (LHS f)
instance WildCard (LHS f)
instance Traversable (META r)
instance Foldable (META r)
instance Functor (META r)
instance (Quantifiable rule, m ~ MetaId a) => Quantifiable (m -> rule)
instance Quantifiable (Rule lhs rhs)


-- | First-order rewriting
module Data.Rewriting.FirstOrder

-- | First-order matching. Results in a list of candidate mappings.
--   
--   This function assumes that there are no applications of meta-variables
--   in <a>LHS</a>.
matchM :: (Functor f, Foldable f, EqF f) => LHS f a -> Term f -> WriterT (Subst f) Maybe ()

-- | Check if all terms are equal, and if so, return one of them
solveTerm :: EqF f => [Term f] -> Maybe (Term f)

-- | Turn a list of candidate mappings into a substitution. Succeeds iff.
--   all mappings for the same variable are equal.
solveSubst :: EqF f => [(Name, Term f)] -> Maybe (Subst f)

-- | First-order matching. Succeeds if the pattern matches and all
--   occurrences of a given meta-variable are matched against equal terms.
--   
--   This function assumes that there are no applications of meta-variables
--   in <a>LHS</a>.
match :: (Functor f, Foldable f, EqF f) => LHS f a -> Term f -> Maybe (Subst f)

-- | Naive substitution. Succeeds iff. each meta-variable in <a>RHS</a> has
--   a mapping in the substitution.
--   
--   This function assumes that there are no applications of meta-variables
--   in <a>RHS</a>.
substitute :: Traversable f => Subst f -> RHS f a -> Maybe (Term f)

-- | Apply a rule. Succeeds iff. both matching and substitution succeeds.
--   
--   This function assumes that there are no applications of meta-variables
--   in <a>LHS</a> or <a>RHS</a>.
rewrite :: (Traversable f, EqF f) => Rule (LHS f) (RHS f) -> Term f -> Maybe (Term f)

-- | Apply the first succeeding rule from a list of rules. If no rule
--   succeeds the term is returned unchanged.
--   
--   This function assumes that there are no applications of meta-variables
--   in <a>LHS</a> or <a>RHS</a>.
applyFirst :: (Traversable f, EqF f) => [Rule (LHS f) (RHS f)] -> Term f -> Term f

-- | Apply a list of rules bottom-up across a term
--   
--   This function assumes that there are no applications of meta-variables
--   in <a>LHS</a> or <a>RHS</a>.
bottomUp :: (Traversable f, EqF f) => [Rule (LHS f) (RHS f)] -> Term f -> Term f

-- | Apply a list of rules top-down across a term
--   
--   This function assumes that there are no applications of meta-variables
--   in <a>LHS</a> or <a>RHS</a>.
topDown :: (Traversable f, EqF f) => [Rule (LHS f) (RHS f)] -> Term f -> Term f


-- | Higher-order rewriting
module Data.Rewriting.HigherOrder

-- | Representations supporting variable binding
class Bind r
var :: Bind r => Var r a -> r a
lam :: Bind r => (Var r a -> r b) -> r (a -> b)

-- | Functor representing object variables
newtype VAR a
Var :: Name -> VAR a

-- | Functor representing lambda abstraction
data LAM a
Lam :: Name -> a -> LAM a

-- | Functor representing application
data APP a
App :: a -> a -> APP a
fresh :: (LAM :<: f, Functor f, Foldable f) => Term f -> Name

-- | Generic lambda abstraction
mkLam :: (Rep r, VAR :<: PF r, LAM :<: PF r, Functor (PF r), Foldable (PF r)) => (VAR a -> Var r a) -> (Var r a -> r b) -> r (a -> b)

-- | Application operator, to use as argument to functions like
--   <a>applyFirst</a>, <a>bottomUp</a>, etc.
app :: APP :<: f => Term (f :&: Set Name) -> Term (f :&: Set Name) -> Term (f :&: Set Name)

-- | One-to-one map
type OneToOne a b = (Map a b, Map b a)

-- | Empty one-to-one map
oEmpty :: OneToOne a b

-- | Test if a mapping is in a one-to-one map
oMember :: (Ord a, Ord b) => (a, b) -> OneToOne a b -> Bool

-- | Test if either side of a mapping is in a one-to-one map
oMemberEither :: (Ord a, Ord b) => (a, b) -> OneToOne a b -> Bool

-- | Left lookup in a one-to-one map
oLookupL :: Ord a => a -> OneToOne a b -> Maybe b

-- | Insert a one-to-one mapping
oInsert :: (Ord a, Ord b) => (a, b) -> OneToOne a b -> OneToOne a b
getAnn :: Term (f :&: a) -> a

-- | Environment keeping track of alpha-renaming
type AlphaEnv = OneToOne Name Name

-- | Higher-order matching. Results in a list of candidate mappings.
matchM :: (VAR :<: f, LAM :<: f, VAR :<: PF (LHS f), LAM :<: PF (LHS f), Functor f, Foldable f, EqF f) => LHS f a -> Term (f :&: Set Name) -> ReaderT AlphaEnv (WriterT (Subst (f :&: Set Name)) Maybe) ()

-- | Alpha-equivalence
alphaEq :: (VAR :<: f, LAM :<: f, Functor f, Foldable f, EqF f) => Term f -> Term f -> Bool

-- | Check if all terms are alpha-equivalent, and if so, return one of them
solveTermAlpha :: (VAR :<: f, LAM :<: f, Functor f, Foldable f, EqF f) => [Term (f :&: a)] -> Maybe (Term (f :&: a))

-- | Turn a list of candidate mappings into a substitution. Succeeds iff.
--   all mappings for the same variable are alpha-equivalent.
solveSubstAlpha :: (VAR :<: f, LAM :<: f, Functor f, Foldable f, EqF f) => Subst (f :&: a) -> Maybe (Subst (f :&: a))

-- | Higher-order matching. Succeeds if the pattern matches and all
--   occurrences of a given meta-variable are matched against equal terms.
match :: (VAR :<: f, LAM :<: f, VAR :<: PF (LHS f), LAM :<: PF (LHS f), Functor f, Foldable f, EqF f) => LHS f a -> Term (f :&: Set Name) -> Maybe (Subst (f :&: Set Name))

-- | Annotate a node with its set of free variables
annFreeVars :: (VAR :<: f, LAM :<: f, Functor f, Foldable f) => f (Term (f :&: Set Name)) -> Term (f :&: Set Name)

-- | Capture-avoiding substitution. Succeeds iff. each meta-variable in
--   <a>RHS</a> has a mapping in the substitution.
substitute :: (VAR :<: f, LAM :<: f, Traversable f, g ~ (f :&: Set Name)) => (Term g -> Term g -> Term g) -> Subst g -> RHS f a -> Maybe (Term g)

-- | Apply a rule. Succeeds iff. both matching and substitution succeeds.
rewrite :: (VAR :<: f, LAM :<: f, VAR :<: PF (LHS f), LAM :<: PF (LHS f), Traversable f, EqF f, g ~ (f :&: Set Name)) => (Term g -> Term g -> Term g) -> Rule (LHS f) (RHS f) -> Term (f :&: Set Name) -> Maybe (Term (f :&: Set Name))

-- | Apply the first succeeding rule from a list of rules. If no rule
--   succeeds the term is returned unchanged.
applyFirst :: (VAR :<: f, LAM :<: f, VAR :<: PF (LHS f), LAM :<: PF (LHS f), Traversable f, EqF f, g ~ (f :&: Set Name)) => (Term g -> Term g -> Term g) -> [Rule (LHS f) (RHS f)] -> Term (f :&: Set Name) -> Term (f :&: Set Name)

-- | Apply a list of rules bottom-up across a term
bottomUp :: (VAR :<: f, LAM :<: f, VAR :<: PF (LHS f), LAM :<: PF (LHS f), Traversable f, EqF f, g ~ (f :&: Set Name)) => (Term g -> Term g -> Term g) -> [Rule (LHS f) (RHS f)] -> Term f -> Term (f :&: Set Name)
instance (VAR :<: PF (RHS f), LAM :<: PF (RHS f), Functor f, Foldable f) => Bind (RHS f)
instance (VAR :<: PF (LHS f), LAM :<: PF (LHS f), Functor f, Foldable f) => Bind (LHS f)
instance Render APP
instance Render LAM
instance Render VAR
instance ShowConstr APP
instance ShowF APP
instance EqF APP
instance ShowConstr LAM
instance ShowF LAM
instance EqF LAM
instance ShowConstr VAR
instance ShowF VAR
instance EqF VAR
instance Eq (VAR a)
instance Show (VAR a)
instance Ord (VAR a)
instance Num (VAR a)
instance Enum (VAR a)
instance Real (VAR a)
instance Integral (VAR a)
instance Functor VAR
instance Foldable VAR
instance Traversable VAR
instance Eq a => Eq (LAM a)
instance Show a => Show (LAM a)
instance Functor LAM
instance Foldable LAM
instance Traversable LAM
instance Eq a => Eq (APP a)
instance Show a => Show (APP a)
instance Functor APP
instance Foldable APP
instance Traversable APP
