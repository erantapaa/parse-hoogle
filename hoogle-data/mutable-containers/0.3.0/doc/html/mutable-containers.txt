-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Abstactions and concrete implementations of mutable containers
--   
--   See docs and README at
--   <a>http://www.stackage.org/package/mutable-containers</a>
@package mutable-containers
@version 0.3.0


-- | Classes and concrete implementations for mutable data structures.
--   
--   For more information on the design of this library, see the README
--   file, also available at
--   <a>http://www.stackage.org/package/mutable-containers</a>.
module Data.Mutable

-- | A primitive ByteArray reference, supporting any monad.
--   
--   Since 0.2.0
data PRef s a

-- | Since 0.2.0
asPRef :: PRef s a -> PRef s a

-- | An unboxed vector reference, supporting any monad.
--   
--   Since 0.2.0
data URef s a

-- | Since 0.2.0
asURef :: URef s a -> URef s a

-- | A storable vector reference, supporting any monad.
--   
--   Since 0.2.0
data SRef s a

-- | Since 0.2.0
asSRef :: SRef s a -> SRef s a

-- | A boxed vector reference, supporting any monad.
--   
--   Since 0.2.0
data BRef s a

-- | Since 0.2.0
asBRef :: BRef s a -> BRef s a

-- | A mutable variable in the <a>IO</a> monad
data IORef a :: * -> *

-- | Since 0.2.0
asIORef :: IORef a -> IORef a

-- | a value of type <tt>STRef s a</tt> is a mutable variable in state
--   thread <tt>s</tt>, containing a value of type <tt>a</tt>
data STRef s a :: * -> * -> *

-- | Since 0.2.0
asSTRef :: STRef s a -> STRef s a
data MutVar s a :: * -> * -> *

-- | Since 0.2.0
asMutVar :: MutVar s a -> MutVar s a

-- | A double-ended queue supporting any underlying vector type and any
--   monad.
--   
--   This implements a circular double-ended queue with exponential growth.
--   
--   Since 0.2.0
data Deque v s a

-- | A <a>Deque</a> specialized to unboxed vectors.
--   
--   Since 0.2.0
type UDeque = Deque MVector

-- | Since 0.2.0
asUDeque :: UDeque s a -> UDeque s a

-- | A <a>Deque</a> specialized to storable vectors.
--   
--   Since 0.2.0
type SDeque = Deque MVector

-- | Since 0.2.0
asSDeque :: SDeque s a -> SDeque s a

-- | A <a>Deque</a> specialized to boxed vectors.
--   
--   Since 0.2.0
type BDeque = Deque MVector

-- | Since 0.2.0
asBDeque :: BDeque s a -> BDeque s a

-- | A doubly-linked list.
--   
--   Since 0.3.0
data DLList s a

-- | Since 0.2.0
asDLList :: DLList s a -> DLList s a

-- | The parent typeclass for all mutable containers.
--   
--   Since 0.2.0
class MutableContainer c where type family MCState c

-- | Typeclass for single-cell mutable references.
--   
--   Since 0.2.0
class MutableContainer c => MutableRef c where type family RefElement c
newRef :: (MutableRef c, PrimMonad m, PrimState m ~ MCState c) => RefElement c -> m c
readRef :: (MutableRef c, PrimMonad m, PrimState m ~ MCState c) => c -> m (RefElement c)
writeRef :: (MutableRef c, PrimMonad m, PrimState m ~ MCState c) => c -> RefElement c -> m ()
modifyRef :: (MutableRef c, PrimMonad m, PrimState m ~ MCState c) => c -> (RefElement c -> RefElement c) -> m ()
modifyRef' :: (MutableRef c, PrimMonad m, PrimState m ~ MCState c) => c -> (RefElement c -> RefElement c) -> m ()

-- | <tt>MutableRef</tt>s that provide for atomic modifications of their
--   contents.
--   
--   Since 0.2.0
class MutableRef c => MutableAtomicRef c
atomicModifyRef :: (MutableAtomicRef c, PrimMonad m, PrimState m ~ MCState c) => c -> (RefElement c -> (RefElement c, a)) -> m a
atomicModifyRef' :: (MutableAtomicRef c, PrimMonad m, PrimState m ~ MCState c) => c -> (RefElement c -> (RefElement c, a)) -> m a

-- | Containers which contain 0 or more values.
--   
--   Since 0.2.0
class MutableContainer c => MutableCollection c where type family CollElement c
newColl :: (MutableCollection c, PrimMonad m, PrimState m ~ MCState c) => m c

-- | Place a value at the front of the collection.
--   
--   Since 0.2.0
class MutableCollection c => MutablePushFront c
pushFront :: (MutablePushFront c, PrimMonad m, PrimState m ~ MCState c) => c -> CollElement c -> m ()

-- | Place a value at the back of the collection.
--   
--   Since 0.2.0
class MutableCollection c => MutablePushBack c
pushBack :: (MutablePushBack c, PrimMonad m, PrimState m ~ MCState c) => c -> CollElement c -> m ()

-- | Take a value from the front of the collection, if available.
--   
--   Since 0.2.0
class MutableCollection c => MutablePopFront c
popFront :: (MutablePopFront c, PrimMonad m, PrimState m ~ MCState c) => c -> m (Maybe (CollElement c))

-- | Take a value from the back of the collection, if available.
--   
--   Since 0.2.0
class MutableCollection c => MutablePopBack c
popBack :: (MutablePopBack c, PrimMonad m, PrimState m ~ MCState c) => c -> m (Maybe (CollElement c))

-- | Collections which allow pushing and popping at the front (aka FIFOs).
--   
--   Since 0.2.0
type MutableQueue c = (MutablePopFront c, MutablePushBack c)

-- | Collections which allow pushing at the back and popping at the front
--   (aka FILOs).
--   
--   Since 0.2.0
type MutableStack c = (MutablePopFront c, MutablePushFront c)

-- | Collections which allow pushing and popping at the front and back.
--   
--   Since 0.2.0
type MutableDeque c = (MutableQueue c, MutablePushFront c, MutablePopBack c)
class Monad m => PrimMonad (m :: * -> *) where type family PrimState (m :: * -> *) :: *

-- | <tt>RealWorld</tt> is deeply magical. It is <i>primitive</i>, but it
--   is not <i>unlifted</i> (hence <tt>ptrArg</tt>). We never manipulate
--   values of type <tt>RealWorld</tt>; it's only used in the type system,
--   to parameterise <tt>State#</tt>.
data RealWorld :: *
class Prim a
class (Vector Vector a, MVector MVector a) => Unbox a

-- | The member functions of this class facilitate writing values of
--   primitive types to raw memory (which may have been allocated with the
--   above mentioned routines) and reading values from blocks of raw
--   memory. The class, furthermore, includes support for computing the
--   storage requirements and alignment restrictions of storable types.
--   
--   Memory addresses are represented as values of type <tt><a>Ptr</a>
--   a</tt>, for some <tt>a</tt> which is an instance of class
--   <a>Storable</a>. The type argument to <a>Ptr</a> helps provide some
--   valuable type safety in FFI code (you can't mix pointers of different
--   types without an explicit cast), while helping the Haskell type system
--   figure out which marshalling method is needed for a given pointer.
--   
--   All marshalling between Haskell and a foreign language ultimately
--   boils down to translating Haskell data structures into the binary
--   representation of a corresponding data structure of the foreign
--   language and vice versa. To code this marshalling in Haskell, it is
--   necessary to manipulate primitive data types stored in unstructured
--   memory blocks. The class <a>Storable</a> facilitates this manipulation
--   on all types for which it is instantiated, which are the standard
--   basic types of Haskell, the fixed size <tt>Int</tt> types
--   (<a>Int8</a>, <a>Int16</a>, <a>Int32</a>, <a>Int64</a>), the fixed
--   size <tt>Word</tt> types (<a>Word8</a>, <a>Word16</a>, <a>Word32</a>,
--   <a>Word64</a>), <a>StablePtr</a>, all types from
--   <a>Foreign.C.Types</a>, as well as <a>Ptr</a>.
--   
--   Minimal complete definition: <a>sizeOf</a>, <a>alignment</a>, one of
--   <a>peek</a>, <a>peekElemOff</a> and <a>peekByteOff</a>, and one of
--   <a>poke</a>, <a>pokeElemOff</a> and <a>pokeByteOff</a>.
class Storable a
