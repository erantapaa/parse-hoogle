-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Set monad
--   
--   The <tt>set-monad</tt> library exports the <tt>Set</tt> abstract data
--   type and set-manipulating functions. These functions behave exactly as
--   their namesakes from the <tt>Data.Set</tt> module of the
--   <tt>containers</tt> library. In addition, the <tt>set-monad</tt>
--   library extends <tt>Data.Set</tt> by providing <tt>Functor</tt>,
--   <tt>Applicative</tt>, <tt>Alternative</tt>, <tt>Foldable</tt>,
--   <tt>Monad</tt>, and <tt>MonadPlus</tt> instances for sets.
--   
--   In other words, you can use the <tt>set-monad</tt> library as a
--   drop-in replacement for the <tt>Data.Set</tt> module of the
--   <tt>containers</tt> library and, in addition, you will also get the
--   aforementioned instances which are not available in the
--   <tt>containers</tt> package.
--   
--   It is not possible to directly implement instances for the
--   aforementioned standard Haskell type classes for the <tt>Set</tt> data
--   type from the <tt>containers</tt> library. This is because the key
--   operations <tt>map</tt> and <tt>union</tt>, are constrained with
--   <tt>Ord</tt> as follows.
--   
--   <pre>
--   map :: (Ord a, Ord b) =&gt; (a -&gt; b) -&gt; Set a -&gt; Set b
--   union :: (Ord a) =&gt; Set a -&gt; Set a -&gt; Set a
--   </pre>
--   
--   The <tt>set-monad</tt> library provides the type class instances by
--   wrapping the constrained <tt>Set</tt> type into a data type that has
--   unconstrained constructors corresponding to monadic combinators. The
--   data type constructors that represent monadic combinators are
--   evaluated with a constrained run function. This elevates the need to
--   use the constraints in the instance definitions (this is what prevents
--   a direct definition). The wrapping and unwrapping happens internally
--   in the library and does not affect its interface.
--   
--   For details, see the rather compact definitions of the <tt>run</tt>
--   function and type class instances. The left identity and associativity
--   monad laws play a crucial role in the definition of the <tt>run</tt>
--   function. The rest of the code should be self explanatory.
--   
--   The technique is not new. This library was inspired by [1]. To my
--   knowledge, the original, systematic presentation of the idea to
--   represent monadic combinators as data is given in [2]. There is also a
--   Haskell library that provides a generic infrastructure for the
--   aforementioned wrapping and unwrapping [3].
--   
--   The <tt>set-monad</tt> library is particularly useful for writing
--   set-oriented code using the do and/or monad comprehension notations.
--   For example, the following definitions now type check.
--   
--   <pre>
--   s1 :: Set (Int,Int)
--   s1 = do a &lt;- fromList [1 .. 4]
--           b &lt;- fromList [1 .. 4]
--           return (a,b)
--   </pre>
--   
--   <pre>
--   -- with -XMonadComprehensions
--   s2 :: Set (Int,Int)
--   s2 = [ (a,b) | (a,b) &lt;- s1, even a, even b ]
--   </pre>
--   
--   <pre>
--   s3 :: Set Int
--   s3 = fmap (+1) (fromList [1 .. 4])
--   </pre>
--   
--   As noted in [1], the implementation technique can be used for monadic
--   libraries and EDSLs with restricted types (compiled EDSLs often
--   restrict the types that they can handle). Haskell's standard monad
--   type class can be used for restricted monad instances. There is no
--   need to resort to GHC extensions that rebind the standard monadic
--   combinators with the library or EDSL specific ones.
--   
--   <tt>[</tt>1<tt>]</tt> CSDL Blog: The home of applied functional
--   programming at KU. Monad Reification in Haskell and the Sunroof
--   Javascript compiler. <a>http://www.ittc.ku.edu/csdlblog/?p=88</a>
--   
--   <tt>[</tt>2<tt>]</tt> Chuan-kai Lin. 2006. Programming monads
--   operationally with Unimo. In Proceedings of the eleventh ACM SIGPLAN
--   International Conference on Functional Programming (ICFP '06). ACM.
--   
--   <tt>[</tt>3<tt>]</tt> Heinrich Apfelmus. The operational package.
--   <a>http://hackage.haskell.org/package/operational</a>
@package set-monad
@version 0.2.0.0


-- | The <tt>set-monad</tt> library exports the <tt>Set</tt> abstract data
--   type and set-manipulating functions. These functions behave exactly as
--   their namesakes from the <tt>Data.Set</tt> module of the
--   <tt>containers</tt> library. In addition, the <tt>set-monad</tt>
--   library extends <tt>Data.Set</tt> by providing <tt>Functor</tt>,
--   <tt>Applicative</tt>, <tt>Alternative</tt>, <tt>Monad</tt>, and
--   <tt>MonadPlus</tt> instances for sets.
--   
--   In other words, you can use the <tt>set-monad</tt> library as a
--   drop-in replacement for the <tt>Data.Set</tt> module of the
--   <tt>containers</tt> library and, in addition, you will also get the
--   aforementioned instances which are not available in the
--   <tt>containers</tt> package.
--   
--   It is not possible to directly implement instances for the
--   aforementioned standard Haskell type classes for the <tt>Set</tt> data
--   type from the <tt>containers</tt> library. This is because the key
--   operations <tt>map</tt> and <tt>union</tt>, are constrained with
--   <tt>Ord</tt> as follows.
--   
--   <pre>
--   map :: (Ord a, Ord b) =&gt; (a -&gt; b) -&gt; Set a -&gt; Set b
--   union :: (Ord a) =&gt; Set a -&gt; Set a -&gt; Set a
--   </pre>
--   
--   The <tt>set-monad</tt> library provides the type class instances by
--   wrapping the constrained <tt>Set</tt> type into a data type that has
--   unconstrained constructors corresponding to monadic combinators. The
--   data type constructors that represent monadic combinators are
--   evaluated with a constrained run function. This elevates the need to
--   use the constraints in the instance definitions (this is what prevents
--   a direct definition). The wrapping and unwrapping happens internally
--   in the library and does not affect its interface.
--   
--   For details, see the rather compact definitions of the <tt>run</tt>
--   function and type class instances. The left identity and associativity
--   monad laws play a crucial role in the definition of the <tt>run</tt>
--   function. The rest of the code should be self explanatory.
--   
--   The technique is not new. This library was inspired by [1]. To my
--   knowledge, the original, systematic presentation of the idea to
--   represent monadic combinators as data is given in [2]. There is also a
--   Haskell library that provides a generic infrastructure for the
--   aforementioned wrapping and unwrapping [3].
--   
--   The <tt>set-monad</tt> library is particularly useful for writing
--   set-oriented code using the do and/or monad comprehension notations.
--   For example, the following definitions now type check.
--   
--   <pre>
--   s1 :: Set (Int,Int)
--   s1 = do a &lt;- fromList [1 .. 4]
--           b &lt;- fromList [1 .. 4]
--           return (a,b)
--   </pre>
--   
--   <pre>
--   -- with -XMonadComprehensions
--   s2 :: Set (Int,Int)
--   s2 = [ (a,b) | (a,b) &lt;- s1, even a, even b ]
--   </pre>
--   
--   <pre>
--   s3 :: Set Int
--   s3 = fmap (+1) (fromList [1 .. 4])
--   </pre>
--   
--   As noted in [1], the implementation technique can be used for monadic
--   libraries and EDSLs with restricted types (compiled EDSLs often
--   restrict the types that they can handle). Haskell's standard monad
--   type class can be used for restricted monad instances. There is no
--   need to resort to GHC extensions that rebind the standard monadic
--   combinators with the library or EDSL specific ones.
--   
--   <tt>[</tt>1<tt>]</tt> CSDL Blog: The home of applied functional
--   programming at KU. Monad Reification in Haskell and the Sunroof
--   Javascript compiler. <a>http://www.ittc.ku.edu/csdlblog/?p=88</a>
--   
--   <tt>[</tt>2<tt>]</tt> Chuan-kai Lin. 2006. Programming monads
--   operationally with Unimo. In Proceedings of the eleventh ACM SIGPLAN
--   International Conference on Functional Programming (ICFP '06). ACM.
--   
--   <tt>[</tt>3<tt>]</tt> Heinrich Apfelmus. The operational package.
--   <a>http://hackage.haskell.org/package/operational</a>
module Data.Set.Monad
data Set a
(\\) :: Ord a => Set a -> Set a -> Set a
null :: Ord a => Set a -> Bool
size :: Ord a => Set a -> Int
member :: Ord a => a -> Set a -> Bool
notMember :: Ord a => a -> Set a -> Bool
isSubsetOf :: Ord a => Set a -> Set a -> Bool
isProperSubsetOf :: Ord a => Set a -> Set a -> Bool
empty :: Ord a => Set a
singleton :: Ord a => a -> Set a
insert :: Ord a => a -> Set a -> Set a
delete :: Ord a => a -> Set a -> Set a
union :: Ord a => Set a -> Set a -> Set a
unions :: Ord a => [Set a] -> Set a
difference :: Ord a => Set a -> Set a -> Set a
intersection :: Ord a => Set a -> Set a -> Set a
filter :: Ord a => (a -> Bool) -> Set a -> Set a
partition :: Ord a => (a -> Bool) -> Set a -> (Set a, Set a)
split :: Ord a => a -> Set a -> (Set a, Set a)
splitMember :: Ord a => a -> Set a -> (Set a, Bool, Set a)
map :: (Ord a, Ord b) => (a -> b) -> Set a -> Set b
mapMonotonic :: (Ord a, Ord b) => (a -> b) -> Set a -> Set b
foldr :: Ord a => (a -> b -> b) -> b -> Set a -> b
foldl :: Ord a => (b -> a -> b) -> b -> Set a -> b
foldr' :: Ord a => (a -> b -> b) -> b -> Set a -> b
foldl' :: Ord a => (b -> a -> b) -> b -> Set a -> b
fold :: Ord a => (a -> b -> b) -> b -> Set a -> b
findMin :: Ord a => Set a -> a
findMax :: Ord a => Set a -> a
deleteMin :: Ord a => Set a -> Set a
deleteMax :: Ord a => Set a -> Set a
deleteFindMin :: Ord a => Set a -> (a, Set a)
deleteFindMax :: Ord a => Set a -> (a, Set a)
maxView :: Ord a => Set a -> Maybe (a, Set a)
minView :: Ord a => Set a -> Maybe (a, Set a)
elems :: Ord a => Set a -> [a]
toList :: Ord a => Set a -> [a]
fromList :: Ord a => [a] -> Set a
toAscList :: Ord a => Set a -> [a]
fromAscList :: Ord a => [a] -> Set a
fromDistinctAscList :: Ord a => [a] -> Set a
showTree :: (Show a, Ord a) => Set a -> String
showTreeWith :: (Show a, Ord a) => Bool -> Bool -> Set a -> String
valid :: Ord a => Set a -> Bool
instance [safe] (NFData a, Ord a) => NFData (Set a)
instance [safe] (Read a, Ord a) => Read (Set a)
instance [safe] (Show a, Ord a) => Show (Set a)
instance [safe] Ord a => Ord (Set a)
instance [safe] Ord a => Eq (Set a)
instance [safe] Foldable Set
instance [safe] Ord a => Monoid (Set a)
instance [safe] MonadPlus Set
instance [safe] Monad Set
instance [safe] Alternative Set
instance [safe] Applicative Set
instance [safe] Functor Set
