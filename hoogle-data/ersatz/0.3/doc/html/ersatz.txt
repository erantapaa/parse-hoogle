-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A monad for expressing SAT or QSAT problems using observable sharing.
--   
@package ersatz
@version 0.3


module Ersatz.Internal.Literal

-- | A naked possibly-negated Atom, present in the target <a>Solver</a>.
--   
--   The literals <tt>-1</tt> and <tt>1</tt> are dedicated for the constant
--   <a>False</a> and the constant <a>True</a> respectively.
newtype Literal
Literal :: Int -> Literal
literalId :: Literal -> Int
negateLiteral :: Literal -> Literal

-- | The <a>False</a> constant. The literal <tt>-1</tt> is dedicated for
--   it.
literalFalse :: Literal

-- | The <a>True</a> constant. The literal <tt>1</tt> is dedicated for it.
literalTrue :: Literal
instance [safe] Typeable Literal
instance [safe] Eq Literal
instance [safe] Ord Literal
instance [safe] Show Literal


module Ersatz.Internal.Formula

-- | A disjunction of possibly negated atoms. Negated atoms are represented
--   by negating the identifier.
newtype Clause
Clause :: IntSet -> Clause
clauseSet :: Clause -> IntSet

-- | Extract the (possibly negated) atoms referenced by a <a>Clause</a>.
clauseLiterals :: Clause -> [Literal]

-- | A conjunction of clauses
newtype Formula
Formula :: Set Clause -> Formula
formulaSet :: Formula -> Set Clause

-- | A formula with no clauses
formulaEmpty :: Formula

-- | Assert a literal
formulaLiteral :: Literal -> Formula

-- | The boolean <i>not</i> operation
--   
--   Derivation of the Tseitin transformation:
--   
--   <pre>
--   O ≡ ¬A
--   (O → ¬A) &amp; (¬O → A)
--   (¬O | ¬A) &amp; (O | A)
--   </pre>
formulaNot :: Literal -> Literal -> Formula

-- | The boolean <i>and</i> operation
--   
--   Derivation of the Tseitin transformation:
--   
--   <pre>
--   O ≡ (A &amp; B &amp; C)
--   (O → (A &amp; B &amp; C)) &amp; (¬O → ¬(A &amp; B &amp; C))
--   (¬O | (A &amp; B &amp; C)) &amp; (O | ¬(A &amp; B &amp; C))
--   (¬O | A) &amp; (¬O | B) &amp; (¬O | C) &amp; (O | ¬A | ¬B | ¬C)
--   </pre>
formulaAnd :: Literal -> [Literal] -> Formula

-- | The boolean <i>or</i> operation
--   
--   Derivation of the Tseitin transformation:
--   
--   <pre>
--   O ≡ (A | B | C)
--   (O → (A | B | C)) &amp; (¬O → ¬(A | B | C))
--   (¬O | (A | B | C)) &amp; (O | ¬(A | B | C))
--   (¬O | A | B | C) &amp; (O | (¬A &amp; ¬B &amp; ¬C))
--   (¬O | A | B | C) &amp; (O | ¬A) &amp; (O | ¬B) &amp; (O | ¬C)
--   </pre>
formulaOr :: Literal -> [Literal] -> Formula

-- | The boolean <i>xor</i> operation
--   
--   Derivation of the Tseitin transformation:
--   
--   <pre>
--   O ≡ A ⊕ B
--   O ≡ ((¬A &amp; B) | (A &amp; ¬B))
--   (O → ((¬A &amp; B) | (A &amp; ¬B))) &amp; (¬O → ¬((¬A &amp; B) | (A &amp; ¬B)))
--   </pre>
--   
--   Left hand side:
--   
--   <pre>
--   O → ((¬A &amp; B) | (A &amp; ¬B))
--   ¬O | ((¬A &amp; B) | (A &amp; ¬B))
--   ¬O | ((¬A | A) &amp; (¬A | ¬B) &amp; (A | B) &amp; (¬B | B))
--   ¬O | ((¬A | ¬B) &amp; (A | B))
--   (¬O | ¬A | ¬B) &amp; (¬O | A | B)
--   </pre>
--   
--   Right hand side:
--   
--   <pre>
--   ¬O → ¬((¬A &amp; B) | (A &amp; ¬B))
--   O | ¬((¬A &amp; B) | (A &amp; ¬B))
--   O | (¬(¬A &amp; B) &amp; ¬(A &amp; ¬B))
--   O | ((A | ¬B) &amp; (¬A | B))
--   (O | ¬A | B) &amp; (O | A | ¬B)
--   </pre>
--   
--   Result:
--   
--   <pre>
--   (¬O | ¬A | ¬B) &amp; (¬O | A | B) &amp; (O | ¬A | B) &amp; (O | A | ¬B)
--   </pre>
formulaXor :: Literal -> Literal -> Literal -> Formula

-- | The boolean <i>else-then-if</i> or <i>mux</i> operation
--   
--   Derivation of the Tseitin transformation:
--   
--   <pre>
--   O ≡ (F &amp; ¬P) | (T &amp; P)
--   (O → ((F &amp; ¬P) | (T &amp; P))) &amp; (¬O → ¬((F &amp; ¬P) | (T &amp; P)))
--   </pre>
--   
--   Left hand side:
--   
--   <pre>
--   O → ((F &amp; ¬P) | (T &amp; P))
--   ¬O | ((F &amp; ¬P) | (T &amp; P))
--   ¬O | ((F | T) &amp; (F | P) &amp; (T | ¬P) &amp; (¬P | P))
--   ¬O | ((F | T) &amp; (F | P) &amp; (T | ¬P))
--   (¬O | F | T) &amp; (¬O | F | P) &amp; (¬O | T | ¬P)
--   </pre>
--   
--   Right hand side:
--   
--   <pre>
--   ¬O → ¬((F &amp; ¬P) | (T &amp; P))
--   O | ¬((F &amp; ¬P) | (T &amp; P))
--   O | (¬(F &amp; ¬P) &amp; ¬(T &amp; P))
--   O | ((¬F | P) &amp; (¬T | ¬P))
--   (O | ¬F | P) &amp; (O | ¬T | ¬P)
--   </pre>
--   
--   Result:
--   
--   <pre>
--   (¬O | F | T) &amp; (¬O | F | P) &amp; (¬O | T | ¬P) &amp; (O | ¬F | P) &amp; (O | ¬T | ¬P)
--   </pre>
formulaMux :: Literal -> Literal -> Literal -> Literal -> Formula
instance [safe] Typeable Clause
instance [safe] Typeable Formula
instance [safe] Eq Clause
instance [safe] Ord Clause
instance [safe] Eq Formula
instance [safe] Ord Formula
instance [safe] Show Clause
instance [safe] Show Formula
instance [safe] Monoid Formula
instance [safe] Monoid Clause


module Ersatz.Problem
data SAT
SAT :: {-# UNPACK #-} !Int -> !Formula -> !(HashMap (StableName ()) Literal) -> SAT
class HasSAT s where lastAtom f = sat $ \ (SAT a b c) -> fmap (\ a' -> SAT a' b c) (f a) formula f = sat $ \ (SAT a b c) -> fmap (\ b' -> SAT a b' c) (f b) stableMap f = sat $ \ (SAT a b c) -> SAT a b <$> f c
sat :: HasSAT s => Lens' s SAT
lastAtom :: HasSAT s => Lens' s Int
formula :: HasSAT s => Lens' s Formula
stableMap :: HasSAT s => Lens' s (HashMap (StableName ()) Literal)

-- | Run a <a>SAT</a>-generating state computation. Useful e.g. in ghci for
--   disambiguating the type of a <a>MonadState</a>, <a>HasSAT</a> value.
runSAT :: StateT SAT m a -> m (a, SAT)

-- | Run a <a>SAT</a>-generating state computation in the <a>Identity</a>
--   monad. Useful e.g. in ghci for disambiguating the type of a
--   <a>MonadState</a>, <a>HasSAT</a> value.
runSAT' :: StateT SAT Identity a -> (a, SAT)

-- | Run a <a>SAT</a>-generating state computation and return the
--   respective <a>DIMACS</a> output. Useful for testing and debugging.
dimacsSAT :: StateT SAT Identity a -> ByteString
literalExists :: (MonadState s m, HasSAT s) => m Literal
assertFormula :: (MonadState s m, HasSAT s) => Formula -> m ()
generateLiteral :: (MonadState s m, HasSAT s) => a -> (Literal -> m ()) -> m Literal

-- | A (quantified) boolean formula.
data QSAT
QSAT :: !IntSet -> SAT -> QSAT
class HasSAT t => HasQSAT t where universals f = qsat ago where ago (QSAT u s) = f u <&> \ u' -> QSAT u' s
qsat :: HasQSAT t => Lens' t QSAT
universals :: HasQSAT t => Lens' t IntSet

-- | Run a <a>QSAT</a>-generating state computation. Useful e.g. in ghci
--   for disambiguating the type of a <a>MonadState</a>, <a>HasQSAT</a>
--   value.
runQSAT :: StateT QSAT m a -> m (a, QSAT)

-- | Run a <a>QSAT</a>-generating state computation in the <a>Identity</a>
--   monad. Useful e.g. in ghci for disambiguating the type of a
--   <a>MonadState</a>, <a>HasQSAT</a> value.
runQSAT' :: StateT QSAT Identity a -> (a, QSAT)

-- | Run a <a>QSAT</a>-generating state computation and return the
--   respective <a>QDIMACS</a> output. Useful for testing and debugging.
qdimacsQSAT :: StateT QSAT Identity a -> ByteString
literalForall :: (MonadState s m, HasQSAT s) => m Literal

-- | DIMACS file format pretty printer
--   
--   This is used to generate the problem statement for a given <a>SAT</a>
--   <a>Solver</a>.
class DIMACS t
dimacsComments :: DIMACS t => t -> [ByteString]
dimacsNumVariables :: DIMACS t => t -> Int
dimacsClauses :: DIMACS t => t -> Set IntSet

-- | QDIMACS file format pretty printer
--   
--   This is used to generate the problem statement for a given <a>QSAT</a>
--   <a>Solver</a>.
class QDIMACS t
qdimacsComments :: QDIMACS t => t -> [ByteString]
qdimacsNumVariables :: QDIMACS t => t -> Int
qdimacsQuantified :: QDIMACS t => t -> [Quant]
qdimacsClauses :: QDIMACS t => t -> Set IntSet

-- | WDIMACS file format pretty printer
--   
--   This is used to generate the problem statement for a given
--   <tt>MaxSAT</tt> <a>Solver</a> (TODO).
class WDIMACS t
wdimacsComments :: WDIMACS t => t -> [ByteString]
wdimacsNumVariables :: WDIMACS t => t -> Int
wdimacsTopWeight :: WDIMACS t => t -> Int64
wdimacsClauses :: WDIMACS t => t -> Set (Int64, IntSet)

-- | Generate a <a>Builder</a> out of a <a>DIMACS</a> problem.
dimacs :: DIMACS t => t -> Builder

-- | Generate a <a>Builder</a> out of a <a>QDIMACS</a> problem.
qdimacs :: QDIMACS t => t -> Builder

-- | Generate a <a>Builder</a> out of a <a>WDIMACS</a> problem.
wdimacs :: WDIMACS t => t -> Builder
instance Typeable SAT
instance Typeable QSAT
instance Typeable Quant
instance Show QSAT
instance QDIMACS QSAT
instance DIMACS SAT
instance Default QSAT
instance HasQSAT QSAT
instance HasSAT QSAT
instance Default SAT
instance Show SAT
instance HasSAT SAT


module Ersatz.Solution
data Solution
Solution :: (Literal -> Maybe Bool) -> (StableName () -> Maybe Bool) -> Solution
solutionLiteral :: Solution -> Literal -> Maybe Bool
solutionStableName :: Solution -> StableName () -> Maybe Bool
solutionFrom :: HasSAT s => IntMap Bool -> s -> Solution
data Result
Unsolved :: Result
Unsatisfied :: Result
Satisfied :: Result

-- | A <tt><a>Solver</a> s m</tt> is responsible for invoking a solver and
--   returning a <a>Result</a> and a map of determined results.
--   
--   <ul>
--   <li><tt>s</tt> is typically <a>SAT</a> or <a>QSAT</a></li>
--   <li><tt>m</tt> is typically <a>IO</a></li>
--   </ul>
type Solver s m = s -> m (Result, IntMap Bool)
instance [safe] Typeable Solution
instance [safe] Eq Result
instance [safe] Ord Result
instance [safe] Ix Result
instance [safe] Show Result
instance [safe] Read Result
instance [safe] Bounded Result
instance [safe] Enum Result


module Ersatz.Variable

-- | Instances for this class for product-like types can be automatically
--   derived for any type that is an instance of <a>Generic</a>.
class Variable t where literally = genericLiterally
literally :: (Variable t, HasSAT s, MonadState s m) => m Literal -> m t
forall :: (Variable a, MonadState s m, HasQSAT s) => m a
exists :: (Variable a, MonadState s m, HasSAT s) => m a
class GVariable f
gliterally :: (GVariable f, MonadState s m, HasSAT s) => m Literal -> m (f a)
genericLiterally :: (HasSAT s, MonadState s m, Generic t, GVariable (Rep t)) => m Literal -> m t
instance (Variable a, Variable b, Variable c, Variable d, Variable e, Variable f, Variable g) => Variable (a, b, c, d, e, f, g)
instance (Variable a, Variable b, Variable c, Variable d, Variable e, Variable f) => Variable (a, b, c, d, e, f)
instance (Variable a, Variable b, Variable c, Variable d, Variable e) => Variable (a, b, c, d, e)
instance (Variable a, Variable b, Variable c, Variable d) => Variable (a, b, c, d)
instance (Variable a, Variable b, Variable c) => Variable (a, b, c)
instance (Variable a, Variable b) => Variable (a, b)
instance Variable Literal
instance GVariable f => GVariable (M1 i c f)
instance Variable a => GVariable (K1 i a)
instance (GVariable f, GVariable g) => GVariable (f :*: g)
instance GVariable U1


-- | <a>DepQBF</a> is a solver capable of solving quantified boolean
--   formulae (<tt>QBF</tt>).
module Ersatz.Solver.DepQBF

-- | This is a <a>Solver</a> for <a>QSAT</a> problems that runs the
--   <tt>depqbf</tt> solver using the current <tt>PATH</tt>, it tries to
--   run an executable named <tt>depqbf</tt>.
depqbf :: MonadIO m => Solver QSAT m

-- | This is a <a>Solver</a> for <a>QSAT</a> problems that lets you specify
--   the path to the <tt>depqbf</tt> executable.
depqbfPath :: MonadIO m => FilePath -> Solver QSAT m


module Ersatz.Solver.Minisat

-- | <a>Solver</a> for <a>SAT</a> problems that tries to invoke the
--   <tt>minisat</tt> executable from the <tt>PATH</tt>
minisat :: MonadIO m => Solver SAT m

-- | <a>Solver</a> for <a>SAT</a> problems that tries to invoke the
--   <tt>cryptominisat</tt> executable from the <tt>PATH</tt>
cryptominisat :: MonadIO m => Solver SAT m

-- | <a>Solver</a> for <a>SAT</a> problems that tries to invoke a program
--   that takes <tt>minisat</tt> compatible arguments.
--   
--   The <a>FilePath</a> refers to the path to the executable.
minisatPath :: MonadIO m => FilePath -> Solver SAT m


module Ersatz.Codec

-- | This class describes data types that can be marshaled to or from a SAT
--   solver.
class Codec a where type family Decoded a :: *
decode :: (Codec a, Alternative f, MonadPlus f) => Solution -> a -> f (Decoded a)
encode :: Codec a => Decoded a -> a
instance [safe] Codec a => Codec (Tree a)
instance [safe] Codec a => Codec (Seq a)
instance [safe] Codec a => Codec (Maybe a)
instance [safe] Codec a => Codec (Map k a)
instance [safe] Codec a => Codec (IntMap a)
instance [safe] Codec a => Codec (HashMap k a)
instance [safe] (Codec a, Codec b) => Codec (Either a b)
instance [safe] (Ix i, Codec e) => Codec (Array i e)
instance [safe] Codec a => Codec [a]
instance [safe] (Codec a, Codec b, Codec c, Codec d, Codec e, Codec f, Codec g, Codec h) => Codec (a, b, c, d, e, f, g, h)
instance [safe] (Codec a, Codec b, Codec c, Codec d, Codec e, Codec f, Codec g) => Codec (a, b, c, d, e, f, g)
instance [safe] (Codec a, Codec b, Codec c, Codec d, Codec e, Codec f) => Codec (a, b, c, d, e, f)
instance [safe] (Codec a, Codec b, Codec c, Codec d, Codec e) => Codec (a, b, c, d, e)
instance [safe] (Codec a, Codec b, Codec c, Codec d) => Codec (a, b, c, d)
instance [safe] (Codec a, Codec b, Codec c) => Codec (a, b, c)
instance [safe] (Codec a, Codec b) => Codec (a, b)
instance [safe] Codec ()
instance [safe] Codec Literal


module Ersatz.Solver
solveWith :: (Monad m, Alternative n, MonadPlus n, HasSAT s, Default s, Codec a) => Solver s m -> StateT s m a -> m (Result, n (Decoded a))


module Ersatz.Bit

-- | A <a>Bit</a> provides a reference to a possibly indeterminate boolean
--   value that can be determined by an external SAT solver.
data Bit
And :: (Seq Bit) -> Bit
Or :: (Seq Bit) -> Bit
Xor :: Bit -> Bit -> Bit
Mux :: Bit -> Bit -> Bit -> Bit
Not :: Bit -> Bit
Var :: !Literal -> Bit

-- | Assert claims that <a>Bit</a> must be <a>true</a> in any satisfying
--   interpretation of the current problem.
assert :: (MonadState s m, HasSAT s) => Bit -> m ()

-- | The normal <a>Bool</a> operators in Haskell are not overloaded. This
--   provides a richer set that are.
--   
--   Instances for this class for product-like types can be automatically
--   derived for any type that is an instance of <a>Generic</a>
class Boolean b where true = bool True false = bool False x ==> y = not x || y and = all id or = any id nand = not . and nor = not . or choose f t s = (f && not s) || (t && s) bool = to . gbool x && y = to (from x &&# from y) x || y = to (from x ||# from y) not = to . gnot . from all p = to . gall (from . p) any p = to . gany (from . p) xor x y = to (from x `gxor` from y)
bool :: Boolean b => Bool -> b
true :: Boolean b => b
false :: Boolean b => b
(&&) :: Boolean b => b -> b -> b
(||) :: Boolean b => b -> b -> b
(==>) :: Boolean b => b -> b -> b
not :: Boolean b => b -> b
and :: (Boolean b, Foldable t) => t b -> b
or :: (Boolean b, Foldable t) => t b -> b
nand :: (Boolean b, Foldable t) => t b -> b
nor :: (Boolean b, Foldable t) => t b -> b
all :: (Boolean b, Foldable t, Boolean b) => (a -> b) -> t a -> b
any :: (Boolean b, Foldable t, Boolean b) => (a -> b) -> t a -> b
xor :: Boolean b => b -> b -> b
choose :: Boolean b => b -> b -> b -> b
instance Typeable Bit
instance Show Bit
instance Boolean Bool
instance GBoolean a => GBoolean (M1 i c a)
instance Boolean a => GBoolean (K1 i a)
instance (GBoolean f, GBoolean g) => GBoolean (f :*: g)
instance GBoolean U1
instance GBoolean V1
instance Codec Bit
instance Variable Bit
instance Boolean Bit


module Ersatz.Equatable

-- | Instances for this class for arbitrary types can be automatically
--   derived from <a>Generic</a>.
class Equatable t where a === b = from a ===# from b a /== b = not (a === b)
(===) :: Equatable t => t -> t -> Bit
(/==) :: Equatable t => t -> t -> Bit
class GEquatable f
(===#) :: GEquatable f => f a -> f a -> Bit
instance [safe] Equatable a => GEquatable (K1 i a)
instance [safe] GEquatable f => GEquatable (M1 i c f)
instance [safe] (GEquatable f, GEquatable g) => GEquatable (f :+: g)
instance [safe] (GEquatable f, GEquatable g) => GEquatable (f :*: g)
instance [safe] GEquatable V1
instance [safe] GEquatable U1
instance [safe] (Equatable a, Equatable b) => Equatable (Either a b)
instance [safe] Equatable a => Equatable [a]
instance [safe] Equatable a => Equatable (Maybe a)
instance [safe] (Equatable a, Equatable b, Equatable c, Equatable d, Equatable e, Equatable f, Equatable g) => Equatable (a, b, c, d, e, f, g)
instance [safe] (Equatable a, Equatable b, Equatable c, Equatable d, Equatable e, Equatable f) => Equatable (a, b, c, d, e, f)
instance [safe] (Equatable a, Equatable b, Equatable c, Equatable d, Equatable e) => Equatable (a, b, c, d, e)
instance [safe] (Equatable a, Equatable b, Equatable c, Equatable d) => Equatable (a, b, c, d)
instance [safe] (Equatable a, Equatable b, Equatable c) => Equatable (a, b, c)
instance [safe] (Equatable a, Equatable b) => Equatable (a, b)
instance [safe] Equatable v => Equatable (IntMap v)
instance [safe] (Eq k, Equatable v) => Equatable (Map k v)
instance [safe] Equatable Bit


module Ersatz.Orderable

-- | Instances for this class for arbitrary types can be automatically
--   derived from <a>Generic</a>.
class Equatable t => Orderable t where x <=? y = x === y || x <? y a <? b = from a <?# from b x >=? y = y <=? x x >? y = y <? x
(<?) :: Orderable t => t -> t -> Bit
(<=?) :: Orderable t => t -> t -> Bit
(>=?) :: Orderable t => t -> t -> Bit
(>?) :: Orderable t => t -> t -> Bit
class GEquatable f => GOrderable f
(<?#) :: GOrderable f => f a -> f a -> Bit
(<=?#) :: GOrderable f => f a -> f a -> Bit
instance [safe] Orderable a => GOrderable (K1 i a)
instance [safe] GOrderable f => GOrderable (M1 i c f)
instance [safe] (GOrderable f, GOrderable g) => GOrderable (f :+: g)
instance [safe] (GOrderable f, GOrderable g) => GOrderable (f :*: g)
instance [safe] GOrderable V1
instance [safe] GOrderable U1
instance [safe] Orderable a => Orderable [a]
instance [safe] (Orderable a, Orderable b) => Orderable (Either a b)
instance [safe] Orderable a => Orderable (Maybe a)
instance [safe] (Orderable a, Orderable b, Orderable c, Orderable d, Orderable e, Orderable f, Orderable g) => Orderable (a, b, c, d, e, f, g)
instance [safe] (Orderable a, Orderable b, Orderable c, Orderable d, Orderable e, Orderable f) => Orderable (a, b, c, d, e, f)
instance [safe] (Orderable a, Orderable b, Orderable c, Orderable d, Orderable e) => Orderable (a, b, c, d, e)
instance [safe] (Orderable a, Orderable b, Orderable c, Orderable d) => Orderable (a, b, c, d)
instance [safe] (Orderable a, Orderable b, Orderable c) => Orderable (a, b, c)
instance [safe] (Orderable a, Orderable b) => Orderable (a, b)
instance [safe] Orderable Bit


-- | <a>Bits</a> is an arbitrary length natural number type
module Ersatz.Bits

-- | A container of 1 <a>Bit</a> that <a>encode</a>s from and
--   <a>decode</a>s to <a>Word8</a>
newtype Bit1
Bit1 :: Bit -> Bit1

-- | A container of 2 <a>Bit</a>s that <a>encode</a>s from and
--   <a>decode</a>s to <a>Word8</a>
data Bit2
Bit2 :: !Bit -> !Bit -> Bit2

-- | A container of 3 <a>Bit</a>s that <a>encode</a>s from and
--   <a>decode</a>s to <a>Word8</a>
data Bit3
Bit3 :: !Bit -> !Bit -> !Bit -> Bit3

-- | A container of 4 <a>Bit</a>s that <a>encode</a>s from and
--   <a>decode</a>s to <a>Word8</a>
data Bit4
Bit4 :: !Bit -> !Bit -> !Bit -> !Bit -> Bit4

-- | A container of 5 <a>Bit</a>s that <a>encode</a>s from and
--   <a>decode</a>s to <a>Word8</a>
data Bit5
Bit5 :: !Bit -> !Bit -> !Bit -> !Bit -> !Bit -> Bit5

-- | A container of 6 <a>Bit</a>s that <a>encode</a>s from and
--   <a>decode</a>s to <a>Word8</a>
data Bit6
Bit6 :: !Bit -> !Bit -> !Bit -> !Bit -> !Bit -> !Bit -> Bit6

-- | A container of 7 <a>Bit</a>s that <a>encode</a>s from and
--   <a>decode</a>s to <a>Word8</a>
data Bit7
Bit7 :: !Bit -> !Bit -> !Bit -> !Bit -> !Bit -> !Bit -> !Bit -> Bit7

-- | A container of 8 <a>Bit</a>s that <a>encode</a>s from and
--   <a>decode</a>s to <a>Word8</a>
data Bit8
Bit8 :: !Bit -> !Bit -> !Bit -> !Bit -> !Bit -> !Bit -> !Bit -> !Bit -> Bit8
newtype Bits
Bits :: [Bit] -> Bits

-- | <a>HasBits</a> provides the <a>bits</a> method for embedding fixed
--   with numeric encoding types into the arbitrary width <a>Bits</a> type.
class HasBits a
bits :: HasBits a => a -> Bits

-- | Predicate for even-valued <a>Bits</a>s.
isEven :: HasBits b => b -> Bit

-- | Predicate for odd-valued <a>Bits</a>s.
isOdd :: HasBits b => b -> Bit

-- | Optimization of <a>sumBits</a> enabled when summing individual
--   <a>Bit</a>s.
sumBit :: Foldable t => t Bit -> Bits

-- | Compute the sum of a source of <a>Bits</a> values.
sumBits :: (Foldable t, HasBits a) => t a -> Bits

-- | Compute the sum and carry bit from adding three bits.
fullAdder :: Bit -> Bit -> Bit -> (Bit, Bit)

-- | Compute the sum and carry bit from adding two bits.
halfAdder :: Bit -> Bit -> (Bit, Bit)
instance [safe] Typeable Bit1
instance [safe] Typeable Bit2
instance [safe] Typeable Bit3
instance [safe] Typeable Bit4
instance [safe] Typeable Bit5
instance [safe] Typeable Bit6
instance [safe] Typeable Bit7
instance [safe] Typeable Bit8
instance [safe] Typeable Bits
instance [safe] Show Bit1
instance [safe] Generic Bit1
instance [safe] Show Bit2
instance [safe] Generic Bit2
instance [safe] Show Bit3
instance [safe] Generic Bit3
instance [safe] Show Bit4
instance [safe] Generic Bit4
instance [safe] Show Bit5
instance [safe] Generic Bit5
instance [safe] Show Bit6
instance [safe] Generic Bit6
instance [safe] Show Bit7
instance [safe] Generic Bit7
instance [safe] Show Bit8
instance [safe] Generic Bit8
instance [safe] Datatype D1Bit1
instance [safe] Constructor C1_0Bit1
instance [safe] Datatype D1Bit2
instance [safe] Constructor C1_0Bit2
instance [safe] Datatype D1Bit3
instance [safe] Constructor C1_0Bit3
instance [safe] Datatype D1Bit4
instance [safe] Constructor C1_0Bit4
instance [safe] Datatype D1Bit5
instance [safe] Constructor C1_0Bit5
instance [safe] Datatype D1Bit6
instance [safe] Constructor C1_0Bit6
instance [safe] Datatype D1Bit7
instance [safe] Constructor C1_0Bit7
instance [safe] Datatype D1Bit8
instance [safe] Constructor C1_0Bit8
instance [safe] Num Bits
instance [safe] HasBits Bits
instance [safe] HasBits Bit8
instance [safe] HasBits Bit7
instance [safe] HasBits Bit6
instance [safe] HasBits Bit5
instance [safe] HasBits Bit4
instance [safe] HasBits Bit3
instance [safe] HasBits Bit2
instance [safe] HasBits Bit1
instance [safe] HasBits Bit
instance [safe] Codec Bits
instance [safe] Orderable Bits
instance [safe] Equatable Bits
instance [safe] Show Bits
instance [safe] Num Bit2
instance [safe] Num Bit1
instance [safe] Codec Bit8
instance [safe] Codec Bit7
instance [safe] Codec Bit6
instance [safe] Codec Bit5
instance [safe] Codec Bit4
instance [safe] Codec Bit3
instance [safe] Codec Bit2
instance [safe] Codec Bit1
instance [safe] Variable Bit8
instance [safe] Variable Bit7
instance [safe] Variable Bit6
instance [safe] Variable Bit5
instance [safe] Variable Bit4
instance [safe] Variable Bit3
instance [safe] Variable Bit2
instance [safe] Variable Bit1
instance [safe] Orderable Bit8
instance [safe] Orderable Bit7
instance [safe] Orderable Bit6
instance [safe] Orderable Bit5
instance [safe] Orderable Bit4
instance [safe] Orderable Bit3
instance [safe] Orderable Bit2
instance [safe] Orderable Bit1
instance [safe] Equatable Bit8
instance [safe] Equatable Bit7
instance [safe] Equatable Bit6
instance [safe] Equatable Bit5
instance [safe] Equatable Bit4
instance [safe] Equatable Bit3
instance [safe] Equatable Bit2
instance [safe] Equatable Bit1
instance [safe] Boolean Bit8
instance [safe] Boolean Bit7
instance [safe] Boolean Bit6
instance [safe] Boolean Bit5
instance [safe] Boolean Bit4
instance [safe] Boolean Bit3
instance [safe] Boolean Bit2
instance [safe] Boolean Bit1


module Ersatz.BitChar

-- | List of <a>BitChar</a> intended to be used as the representation for
--   <a>String</a>.
type BitString = [BitChar]

-- | Encoding of the full range of <a>Char</a> values.
newtype BitChar
BitChar :: Bits -> BitChar
instance Typeable BitChar
instance Show BitChar
instance Variable BitChar
instance Orderable BitChar
instance Equatable BitChar
instance Codec BitChar


module Ersatz
