-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The category of monads
--   
--   MHask is the category where
--   
--   <ul>
--   <li>The objects are Haskell types of kind <tt>(* → *)</tt> that have
--   an instance of <a>Prelude.Monad</a></li>
--   <li>An arrow from object m to object n is a Haskell function of the
--   form <tt>(forall x. m x → n x)</tt></li>
--   <li>Arrow composition is merely a specialization of Haskell function
--   composition</li>
--   <li>The identity arrow for the object m is the <a>Prelude.id</a>
--   function in Haskell, specialized to <tt>(forall x. m x → m
--   x)</tt></li>
--   </ul>
--   
--   It is assumed that any instances of the classes provided here also
--   have an instance for Monad of the form <tt>instance (Monad m) ⇒ Monad
--   (t m)</tt>, thus guaranteeing that <tt>(t m)</tt> (or <tt>(t i j
--   m)</tt> for the indexed types) is always a Monad. If it were valid
--   Haskell, I'd write:
--   
--   <pre>
--   class (forall m. Monad m ⇒ Monad (t m)) ⇒ Functor t
--   </pre>
--   
--   <a>MHask.Functor.Functor</a> should actually be called Endofunctor,
--   because if m is an object in MHask, then an instance t of
--   <a>Functor</a> can map object m to object (t m), and arrows from m to
--   n get mapped to arrows from (t m) to (t n).
@package MHask
@version 0.3.0.0


-- | This module sets the stage for the rest of the package. It defines a
--   type synonym <tt>~&gt;</tt> which cleans up the type signatures, and
--   <tt>~&gt;~</tt> which is used in the default implementation of bind.
--   These represent the type of arrows and arrow composition in MHask,
--   respectively.
--   
--   By using <tt>~&gt;</tt>, type signatures for the MHask class
--   operations can be easily compared to their Hask counterparts. However,
--   as a reminder that you are dealing with Monads, where typically you
--   would see <tt>a</tt> and <tt>b</tt> in the Hask counterpart, you will
--   instead see <tt>m</tt> and <tt>n</tt>, and where you would typically
--   see <tt>m</tt> or <tt>w</tt>, you will instead see <tt>t</tt>, as a
--   mnemonic for Monad transformer.
--   
--   For illustrative purposes, this module also provides <tt>&lt;~</tt>
--   and <tt>~&lt;~</tt>, to clearly illustrate how duals are nothing more
--   than just "flipping the arrows". You are encouraged to compare docs or
--   even source files to see just how similar they are, all the way down
--   to default implementations.
module MHask.Arrow

-- | The <tt>~&gt;</tt> type represents arrows in the category of MHask.
type (~>) m n = forall x. m x -> n x

-- | It's just <tt>~&gt;</tt> flipped.
--   
--   <pre>
--   type m &lt;~ n = n ~&gt; m
--   </pre>
type (<~) m n = n ~> m

-- | Left-to-right composition of arrows in MHask.
(~>~) :: (Monad a, Monad b, Monad c) => (a ~> b) -> (b ~> c) -> (a ~> c)

-- | It's just <tt>~&gt;~</tt> flipped.
--   
--   <pre>
--   (~&lt;~) = flip (~&gt;~)
--   </pre>
(~<~) :: (Monad a, Monad b, Monad c) => (c <~ b) -> (b <~ a) -> (c <~ a)


-- | Compare to base.Prelude.Functor (Functor)
module MHask.Functor

-- | Functor is its own dual.
class Functor t
fmap :: (Functor t, Monad m, Monad n) => (m ~> n) -> (t m ~> t n)
instance Functor (WriterT w)
instance Functor (ReaderT r)
instance Functor (StateT s)


-- | Equivalent to transformers.Control.Monad.Trans.Class (MonadTrans)
module MHask.Pointed

-- | The dual of <a>MHask.Copointed</a>
class Functor t => Pointed t
return :: (Pointed t, Monad m) => m ~> t m
instance Monoid w => Pointed (WriterT w)
instance Pointed (ReaderT r)
instance Pointed (StateT s)


-- | Compare to base.Prelude (Monad)
module MHask.Monad

-- | Dual of <a>MHask.Comonad</a>
class Pointed t => Monad t where join = bind id bind f = fmap f ~>~ join
join :: (Monad t, Monad m) => t (t m) ~> t m
bind :: (Monad t, Monad m, Monad n) => (m ~> t n) -> (t m ~> t n)

-- | If you define your Monad in terms of bind and return, then you get a
--   free implementation of fmap which can be used for Functor.
fmapMonad :: (Monad m, Monad n, Monad (t n), Monad t) => (m ~> n) -> (t m ~> t n)


-- | Compare to comonad.Control.Comonad (Copointed)
module MHask.Copointed

-- | The dual of <a>MHask.Pointed</a>
class Functor t => Copointed t
extract :: (Copointed t, Monad m) => m <~ t m
instance Copointed (WriterT w)
instance Monoid r => Copointed (ReaderT r)
instance Monoid s => Copointed (StateT s)


-- | Compare to comonad.Control.Comonad (Comonad)
module MHask.Comonad

-- | Dual of <a>MHask.Monad</a>
class Copointed t => Comonad t where duplicate = extend id extend f = fmap f ~<~ duplicate
duplicate :: (Comonad t, Monad m) => t (t m) <~ t m
extend :: (Comonad t, Monad m, Monad n) => (m <~ t n) -> (t m <~ t n)

-- | If you define your Comonad in terms of extend and extract, then you
--   get a free implementation of fmap which can be used for Functor.
fmapComonad :: (Monad m, Monad n, Monad (t n), Comonad t) => (m <~ n) -> (t m <~ t n)


-- | Compare to indexed.Data.Functor.Indexed (IxFunctor)
module MHask.Indexed.Functor

-- | The indexed version of <a>MHask.Functor</a>. IxFunctor is its own
--   dual.
class IxFunctor t where imap = fmap
imap :: (IxFunctor t, Monad m, Monad n) => (m ~> n) -> (t i j m ~> t i j n)


-- | Compare to indexed.Data.Functor.Indexed (IxPointed)
module MHask.Indexed.Pointed

-- | The indexed version of <a>MHask.Pointed</a>. The dual of
--   <a>MHask.Indexed.Copointed</a>.
class IxFunctor t => IxPointed t where ireturn = return
ireturn :: (IxPointed t, Monad m) => m ~> t i i m


-- | Compare to indexed.Control.Monad.Indexed (IxMonad)
module MHask.Indexed.Monad

-- | Indexed version of <a>MHask.Monad</a>. Dual of
--   <a>MHask.Indexed.Comonad</a>
class IxPointed t => IxMonad t where ijoin = ibind id ibind f = imap f ~>~ ijoin
ijoin :: (IxMonad t, Monad m) => t i j (t j k m) ~> t i k m
ibind :: (IxMonad t, Monad m, Monad n) => (m ~> t j k n) -> (t i j m ~> t i k n)

-- | If you define your IxMonad in terms of ibind and ireturn, then you get
--   a free implementation of imap which can be used for IxFunctor.
imapMonad :: (Monad m, Monad n, Monad (t j j n), IxMonad t) => (m ~> n) -> (t i j m ~> t i j n)


-- | Compare to indexed.Data.Functor.Indexed (IxCopointed)
module MHask.Indexed.Copointed

-- | The indexed version of <a>MHask.Copointed</a>. The dual of
--   <a>MHask.Indexed.Pointed</a>.
class IxFunctor t => IxCopointed t where iextract = extract
iextract :: (IxCopointed t, Monad m) => m <~ t i i m


-- | Compare to indexed.Control.Comonad.Indexed (IxComonad)
module MHask.Indexed.Comonad

-- | Indexed version of <a>MHask.Comonad</a>. Dual of
--   <a>MHask.Indexed.Monad</a>
class IxCopointed t => IxComonad t where iduplicate = iextend id iextend f = imap f ~<~ iduplicate
iduplicate :: (IxComonad t, Monad m) => t i j (t j k m) <~ t i k m
iextend :: (IxComonad t, Monad m, Monad n) => (m <~ t j k n) -> (t i j m <~ t i k n)

-- | If you define your IxComonad in terms of iextend and iextract, then
--   you get a free implementation of imap which can be used for IxFunctor.
imapComonad :: (Monad m, Monad n, Monad (t j j n), IxComonad t) => (m <~ n) -> (t i j m <~ t i j n)


-- | Various abstractions in the category of MHask. This re-exports
--   everything, and should be imported qualified so that the operations
--   and classes do not clash with their Hask counterparts.
--   
--   <pre>
--   import qualified MHask
--   </pre>
module MHask
