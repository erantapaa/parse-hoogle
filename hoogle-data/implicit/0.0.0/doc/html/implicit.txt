-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Math-inspired programmatic 2&3D CAD: CSG, bevels, and shells; gcode export..
--   
--   A math-inspired programmatic CAD library in haskell. Build objects
--   with constructive solid geometry, bevels, shells and more in 2D &amp;
--   3D. Then export to SVGs, STLs, or produce gcode directly!
@package implicit
@version 0.0.0

module Graphics.Implicit.Definitions
type ℝ = Float
type ℝ2 = (ℝ, ℝ)
type ℝ3 = (ℝ, ℝ, ℝ)
type ℕ = Int

-- | A chain of line segments, as in SVG eg. [(0,0), (0.5,1), (1,0)]
--   ---&gt; /\
type Polyline = [ℝ2]

-- | A 2D object
type Obj2 = ℝ2 -> ℝ

-- | A 3D object
type Obj3 = ℝ3 -> ℝ

module Graphics.Implicit.ExtOpenScad
type VariableLookup = Map String OpenscadObj
data OpenscadObj
OUndefined :: OpenscadObj
OBool :: Bool -> OpenscadObj
ONum :: ℝ -> OpenscadObj
OList :: [OpenscadObj] -> OpenscadObj
OString :: String -> OpenscadObj
OFunc :: (OpenscadObj -> OpenscadObj) -> OpenscadObj
data Computation
ControlStructure :: (VariableLookup -> [Computation] -> ([Obj2], [Obj3], VariableLookup)) -> [Computation] -> Computation
Assignment :: (VariableLookup -> VariableLookup) -> Computation
Object2 :: (VariableLookup -> Obj2) -> Computation
Object3 :: (VariableLookup -> Obj3) -> Computation
Include :: String -> Computation
variable :: GenParser Char st (VariableLookup -> OpenscadObj)
literal :: GenParser Char st (VariableLookup -> OpenscadObj)
expression :: Int -> GenParser Char st (VariableLookup -> OpenscadObj)
instance Show OpenscadObj

module Graphics.Implicit.MathUtil

-- | Rounded Maximum Consider max(x,y) = 0, the generated curve has a
--   square-like corner. We replace it with a quarter of a circle
rmax :: ℝ -> ℝ -> ℝ -> ℝ

-- | Rounded minimum
rmin :: ℝ -> ℝ -> ℝ -> ℝ

-- | Like rmax, but on a list instead of two. Just as maximum is. The
--   implementation is to take the maximum two and rmax those.
rmaximum :: ℝ -> [ℝ] -> ℝ

-- | Like rmin but on a list.
rminimum :: ℝ -> [ℝ] -> ℝ

module Graphics.Implicit.SaneOperators
class Additive a b c | a b -> c
(+) :: Additive a b c => a -> b -> c
class Multiplicative a b c | a b -> c
(*) :: Multiplicative a b c => a -> b -> c
class AdditiveInvertable a
additiveInverse :: AdditiveInvertable a => a -> a
class MultiplicativeInvertable a
multiplicativeInverse :: MultiplicativeInvertable a => a -> a
class Normable a
norm :: Normable a => a -> ℝ
class InnerProductSpace a
(⋅) :: InnerProductSpace a => a -> a -> ℝ
(-) :: Additive a b c => AdditiveInvertable b => a -> b -> c
(/) :: Multiplicative a b c => MultiplicativeInvertable b => a -> b -> c
instance InnerProductSpace ℝ3
instance InnerProductSpace ℝ2
instance InnerProductSpace ℝ
instance Normable ℝ3
instance Normable ℝ2
instance Normable ℝ
instance Multiplicative a b c => Multiplicative (d -> a) (d -> b) (d -> c)
instance Additive a b c => Additive (d -> a) (d -> b) (d -> c)
instance AdditiveInvertable ℝ3
instance AdditiveInvertable ℝ2
instance Multiplicative ℝ ℝ3 ℝ3
instance Multiplicative ℝ ℝ2 ℝ2
instance Additive ℝ3 ℝ3 ℝ3
instance Additive ℝ2 ℝ2 ℝ2
instance Multiplicative ℕ ℝ ℝ
instance Additive ℕ ℝ ℝ
instance Multiplicative ℝ ℕ ℝ
instance Additive ℝ ℕ ℝ
instance AdditiveInvertable ℕ
instance Multiplicative ℕ ℕ ℕ
instance Additive ℕ ℕ ℕ
instance MultiplicativeInvertable ℝ
instance AdditiveInvertable ℝ
instance Multiplicative ℝ ℝ ℝ
instance Additive ℝ ℝ ℝ

module Graphics.Implicit.Primitives
sphere :: ℝ -> Obj3
cube :: ℝ -> Obj3
circle :: ℝ -> Obj2
cylinder :: ℝ -> ℝ -> Obj3
square :: ℝ -> Obj2
regularPolygon :: ℕ -> ℝ -> Obj2
polygon :: [ℝ2] -> Obj2
zsurface :: (ℝ2 -> ℝ) -> Obj3

module Graphics.Implicit.Operations

-- | Translate an object by a vector of appropriate dimension.
translate :: (Additive a a a, AdditiveInvertable a) => a -> (a -> ℝ) -> (a -> ℝ)

-- | Scale an object
scale :: Multiplicative a ℝ a => ℝ -> (a -> ℝ) -> (a -> ℝ)
complement :: (a -> ℝ) -> (a -> ℝ)

-- | Union a list of objects
union :: [a -> ℝ] -> (a -> ℝ)

-- | Intersect a list of objects
intersect :: [a -> ℝ] -> (a -> ℝ)

-- | Difference a list of objects
difference :: [a -> ℝ] -> (a -> ℝ)

-- | Rounded union
unionR :: ℝ -> [a -> ℝ] -> (a -> ℝ)

-- | Rounded minimum
intersectR :: ℝ -> [a -> ℝ] -> (a -> ℝ)

-- | Rounded difference
differenceR :: ℝ -> [a -> ℝ] -> (a -> ℝ)
shell :: ℝ -> (a -> ℝ) -> (a -> ℝ)

-- | Slice a 3D objects at a given z value to make a 2D object.
slice :: ℝ -> Obj3 -> Obj2

-- | Bubble out a 2D object into a 3D one.
bubble :: ℝ -> Obj2 -> Obj3

-- | Extrude a 2D object. (The extrusion goes into the z-plane)
extrude :: ℝ -> Obj2 -> Obj3

-- | Rounded extrude. Instead of the extrude having a flat top or bottom,
--   it is bevelled.
extrudeR :: ℝ -> ℝ -> Obj2 -> Obj3

-- | Create a 3D object by extruding a 2D object along the edge of another
--   2D object. For example, extruding a circle on the edge of another
--   circle would make a torus.
extrudeOnEdgeOf :: Obj2 -> Obj2 -> Obj3

module Graphics.Implicit.Tracing.GetTriangles
getTriangles :: ((ℝ, ℝ, ℝ, ℝ, ℝ, ℝ, ℝ, ℝ), ℝ3, ℝ) -> [(ℝ3, ℝ3, ℝ3)]

module Graphics.Implicit.Tracing
getTriangles :: ((ℝ, ℝ, ℝ, ℝ, ℝ, ℝ, ℝ, ℝ), ℝ3, ℝ) -> [(ℝ3, ℝ3, ℝ3)]
getLineSeg :: (ℝ, ℝ, ℝ, ℝ, ℝ, ℝ2, ℝ) -> [Polyline]
orderLines :: [Polyline] -> [Polyline]
orderLinesDC :: [[[Polyline]]] -> [Polyline]
orderLinesP :: [[[Polyline]]] -> [Polyline]
reducePolyline :: (Fractional t, Ord t) => [(t, t)] -> [(t, t)]
polylineNotNull :: [a] -> Bool

module Graphics.Implicit.Export
renderRaw :: ℝ3 -> ℝ3 -> ℝ -> String -> Obj3 -> IO ()
renderRaw2D :: ℝ2 -> ℝ2 -> ℝ -> String -> Obj2 -> IO ()

-- | Write an SVG of a 2D object
writeSVG :: ℝ2 -> ℝ2 -> ℝ -> String -> Obj2 -> IO ()

-- | Write an SVG of a 2D object (uses parallel algorithms)
writeSVG2 :: ℝ2 -> ℝ2 -> ℝ -> String -> Obj2 -> IO ()
writeGCode :: ℝ2 -> ℝ2 -> ℝ -> FilePath -> Obj2 -> IO ()
writeGCodeHacklabLaser :: ℝ2 -> ℝ2 -> ℝ -> FilePath -> Obj2 -> IO ()
writeSTL :: ℝ3 -> ℝ3 -> ℝ -> FilePath -> Obj3 -> IO ()

module Graphics.Implicit

-- | Translate an object by a vector of appropriate dimension.
translate :: (Additive a a a, AdditiveInvertable a) => a -> (a -> ℝ) -> (a -> ℝ)

-- | Scale an object
scale :: Multiplicative a ℝ a => ℝ -> (a -> ℝ) -> (a -> ℝ)
complement :: (a -> ℝ) -> (a -> ℝ)

-- | Union a list of objects
union :: [a -> ℝ] -> (a -> ℝ)

-- | Intersect a list of objects
intersect :: [a -> ℝ] -> (a -> ℝ)

-- | Difference a list of objects
difference :: [a -> ℝ] -> (a -> ℝ)

-- | Rounded union
unionR :: ℝ -> [a -> ℝ] -> (a -> ℝ)

-- | Rounded minimum
intersectR :: ℝ -> [a -> ℝ] -> (a -> ℝ)

-- | Rounded difference
differenceR :: ℝ -> [a -> ℝ] -> (a -> ℝ)
shell :: ℝ -> (a -> ℝ) -> (a -> ℝ)

-- | Slice a 3D objects at a given z value to make a 2D object.
slice :: ℝ -> Obj3 -> Obj2

-- | Bubble out a 2D object into a 3D one.
bubble :: ℝ -> Obj2 -> Obj3

-- | Extrude a 2D object. (The extrusion goes into the z-plane)
extrude :: ℝ -> Obj2 -> Obj3

-- | Rounded extrude. Instead of the extrude having a flat top or bottom,
--   it is bevelled.
extrudeR :: ℝ -> ℝ -> Obj2 -> Obj3

-- | Create a 3D object by extruding a 2D object along the edge of another
--   2D object. For example, extruding a circle on the edge of another
--   circle would make a torus.
extrudeOnEdgeOf :: Obj2 -> Obj2 -> Obj3
sphere :: ℝ -> Obj3
cube :: ℝ -> Obj3
circle :: ℝ -> Obj2
cylinder :: ℝ -> ℝ -> Obj3
square :: ℝ -> Obj2
regularPolygon :: ℕ -> ℝ -> Obj2
zsurface :: (ℝ2 -> ℝ) -> Obj3
polygon :: [ℝ2] -> Obj2

-- | Write an SVG of a 2D object
writeSVG :: ℝ2 -> ℝ2 -> ℝ -> String -> Obj2 -> IO ()
writeSTL :: ℝ3 -> ℝ3 -> ℝ -> FilePath -> Obj3 -> IO ()
