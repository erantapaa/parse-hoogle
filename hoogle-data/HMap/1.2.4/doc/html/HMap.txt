-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Fast heterogeneous maps and unconstrained typeable like functionality.
--   
@package HMap
@version 1.2.4


-- | Provides a Typeable-like interface for things that cannot derive
--   typeable.
module Data.Untypeable
data Untypeable

-- | Make an Untypeable value
inject :: HKey s a -> a -> Untypeable

-- | Project (i.e. cast) an untypeable value with a given key.
project :: HKey s a -> Untypeable -> Maybe a

module Data.HKey

-- | The datatype of Keys.
--   
--   <ul>
--   <li><i>x</i> The scope of this key. This can either be <a>T</a> for
--   top-level keys created with <a>createKey</a> or an existential type
--   for keys introduced by <a>withKey</a> (or with the Key monad
--   <a>KeyM</a>).</li>
--   <li><i>a</i> The type of things that can be sorted at this key.</li>
--   </ul>
--   
--   For example, <tt>Key T Int</tt> is a top-level key that can be used to
--   store values of type <tt>Int</tt> in a heterogenous map.
data HKey s a

-- | <i>O(1)</i>. Scopes a key to the given function The key cannot escape
--   the function (because of the existential type).
--   
--   The implementation actually *creates* a key, but because the key
--   cannot escape the given function <tt>f</tt>, there is no way to
--   observe that if we run <tt>withKey f</tt> twice, that it will get a
--   different key the second time.
withKey :: (forall x. HKey x a -> b) -> b

-- | The scope of top-level keys.
data T

-- | <i>O(1)</i>. Create a new top-level key.
createKey :: IO (HKey T a)

-- | A monad that can be used to create keys Keys cannot escape the monad,
--   analogous to the ST Monad. Can be used instead of the <a>withKey</a>
--   function if you need an statically unknown number of keys.
--   
--   The applicative instance is more non-strict than the standard
--   <a>ap</a>:
--   
--   let hang = getKey &gt;&gt; hang in snd $ runIdentity $ runKeyT $ pure
--   (,) <a>*</a> hang <a>*</a> (getKey &gt;&gt; return 2) does not hang,
--   but with <a>ap</a> it does.
type KeyM s a = KeyT s Identity a
data KeyT s m a
type Key s = KeyT s Identity
runKey :: (forall s. Key s a) -> a

-- | Obtain a key in the key monad
newKey :: KeyT s m (HKey s a)

-- | Obtain a key in the key monad, alias for newKey
getKey :: KeyT s m (HKey s a)

-- | Split of a keyT computation.
--   
--   As an analogy, think of a random number generator some random number
--   generator can be split, from one random number generator we obtain two
--   distinct random number generator that are unrelated.
--   
--   The KeyT monad gives us access to a name source, this operation allows
--   us to split the name source. The generated name from both this and the
--   split off computation have the same scope, but are otherwise
--   underlated.
--   
--   Notice that the sharing of the same scope is not a problem because the
--   monad ensures referential transparency.
keyTSplit :: KeyT s m a -> KeyT s m (m a)

-- | Run a key monad. Existential type makes sure keys cannot escape.
runKeyT :: Monad m => (forall s. KeyT s m a) -> m a


-- | An efficient implementation of heterogeneous maps.
--   
--   A heterogeneous map can store values of different types. This in
--   contrast to a homogenous map (such as the one in <a>Map</a>) which can
--   store values of a single type.
--   
--   For example, here we use a map with <a>String</a> (name),
--   <a>Double</a> (salary) and <a>Bool</a> (female):
--   
--   <pre>
--   import Data.HMap 
--   
--   -- type can be inferred.
--   example :: HKey x String -&gt; HKey x1 Double -&gt; HKey x2 Bool 
--              -&gt; String
--   example name salary female = 
--     format a ++ "\n" ++ format b ++ "\n"
--     where a = insert name "Edsger" $ 
--               insert salary 4450.0 $ 
--               insert female False empty
--           b = insert name "Ada"    $ 
--               insert salary 5000.0 $ 
--               insert female True empty
--           format x = x ! name ++ 
--                      ": salary=" ++ show (x ! salary) ++ 
--                      ", female="  ++ show (x ! female)
--   
--   keyLocal :: String
--   keyLocal = withKey $ withKey $ withKey example
--   
--   keyGlobal :: IO String
--   keyGlobal = 
--     do name   &lt;- createKey
--        salary &lt;- createKey
--        female &lt;- createKey
--        return $ example name salary female
--                       
--   main = do print "local"
--             putStr keyLocal
--             print "global"
--             keyGlobal &gt;&gt;= putStr
--   </pre>
--   
--   Which gives:
--   
--   <pre>
--   "local"
--   Edsger: salary=4450.0, female=False
--   Ada: salary=5000.0, female=True
--   "global"
--   Edsger: salary=4450.0, female=False
--   Ada: salary=5000.0, female=True
--   </pre>
--   
--   Key types carry two type arguments: the scope of the key and the the
--   type of things that can be stored at this key, for example
--   <tt>String</tt> or <tt>Int</tt>.
--   
--   The scope of the key depends on how it is created:
--   
--   <ul>
--   <li>In the <tt>keyLocal</tt> example, keys are created <i>locally</i>
--   with the <a>withKey</a> function. The type of the <a>withKey</a>
--   function is <tt>(forall x. Key x a -&gt; b) -&gt; b</tt>, which means
--   it assigns a key and passes it to the given function. The key cannot
--   escape the function (this would yield a type error). Hence, we say the
--   key is <i>scoped</i> to the function. The scope type argument of the
--   key is then an existential type.</li>
--   <li>In the <tt>keyGlobal</tt> example, keys are created
--   <i>globally</i> with <a>createKey</a> in the IO monad. This allows to
--   create keys that are not not scoped to a single function, but to the
--   whole program. The scope type argument of the key is then
--   <a>T</a>.</li>
--   </ul>
--   
--   This module differs from hackage package <tt>hetero-map</tt> in the
--   following ways:
--   
--   <ul>
--   <li>Lookup, insertion and updates are <i>O(log n)</i> when using this
--   module, whereas they are <i>O(n)</i> when using
--   <tt>hetero-map</tt>.</li>
--   <li>With this module we cannot statically ensure that a Heterogenous
--   map has a some key (i.e. (!) might throw error, like in <a>Map</a>).
--   With <tt>hetero-map</tt> it is possible to statically rule out such
--   errors.</li>
--   <li>The interface of this module is more similar to <a>Map</a>.</li>
--   </ul>
--   
--   This module differs from <tt>stable-maps</tt> in the following ways:
--   
--   <ul>
--   <li>Key can be created safely without using the IO monad.</li>
--   <li>The interface is more uniform and implements more of the
--   <a>Map</a> interface.</li>
--   <li>This module uses a Hashmap as a backend, whereas
--   <tt>stable-maps</tt> uses <tt>Data.Map</tt>. Hashmaps are faster, see
--   <a>http://blog.johantibell.com/2012/03/announcing-unordered-containers-02.html</a>.</li>
--   </ul>
--   
--   Another difference to both packages is that HMap has better memory
--   performance in the following way: An entry into an HMap does not keep
--   the value alive if the key is not alive. After all, if the key is
--   dead, then there is no way to retrieve the value!
--   
--   Hence, a HMap can have elements which can never be accessed again. Use
--   the IO operation <a>purge</a> to remove these.
--   
--   Since many function names (but not the type name) clash with
--   <a>Prelude</a> names, this module is usually imported
--   <tt>qualified</tt>, e.g.
--   
--   <pre>
--   import Data.HMap (HMap)
--   import qualified Data.HMap as HMap
--   </pre>
--   
--   This module uses <tt>Data.HashMap.Lazy</tt> as a backend. Every
--   function from <a>Map</a> that makes sense in a heterogenous setting
--   has been implemented.
--   
--   Note that the implementation is <i>left-biased</i> -- the elements of
--   a first argument are always preferred to the second, for example in
--   <a>union</a> or <a>insert</a>.
--   
--   Operation comments contain the operation time complexity in the Big-O
--   notation <a>http://en.wikipedia.org/wiki/Big_O_notation</a>.
module Data.HMap

-- | The type of hetrogenous maps.
data HMap

-- | <i>O(log n)</i>. Find the value at a key. Calls <a>error</a> when the
--   element can not be found.
(!) :: HMap -> HKey x a -> a

-- | Same as <a>difference</a>.
(\\) :: HMap -> HMap -> HMap

-- | <i>O(1)</i>. Is the map empty?
null :: HMap -> Bool

-- | <i>O(1)</i>. The number of elements in the map.
size :: HMap -> Int

-- | <i>O(log n)</i>. Is the key a member of the map? See also
--   <a>notMember</a>.
member :: HKey x a -> HMap -> Bool

-- | <i>O(log n)</i>. Is the key not a member of the map? See also
--   <a>member</a>.
notMember :: HKey x a -> HMap -> Bool

-- | <i>O(log n)</i>. Lookup the value at a key in the map.
--   
--   The function will return the corresponding value as <tt>(<a>Just</a>
--   value)</tt>, or <a>Nothing</a> if the key isn't in the map.
lookup :: HKey x a -> HMap -> Maybe a

-- | <i>O(log n)</i>. The expression <tt>(<a>findWithDefault</a> def k
--   map)</tt> returns the value at key <tt>k</tt> or returns default value
--   <tt>def</tt> when the key is not in the map.
findWithDefault :: a -> HKey x a -> HMap -> a

-- | <i>O(1)</i>. The empty map.
empty :: HMap

-- | <i>O(1)</i>. A map with a single element.
singleton :: HKey x a -> a -> HMap

-- | <i>O(log n)</i>. Insert a new key and value in the map. If the key is
--   already present in the map, the associated value is replaced with the
--   supplied value. <a>insert</a> is equivalent to <tt><a>insertWith</a>
--   <a>const</a></tt>.
insert :: HKey s a -> a -> HMap -> HMap

-- | <i>O(log n)</i>. Insert with a function, combining new value and old
--   value. <tt><a>insertWith</a> f key value mp</tt> will insert the pair
--   (key, value) into <tt>mp</tt> if key does not exist in the map. If the
--   key does exist, the function will insert the pair <tt>(key, f
--   new_value old_value)</tt>.
insertWith :: (a -> a -> a) -> HKey x a -> a -> HMap -> HMap

-- | <i>O(log n)</i>. Delete a key and its value from the map. When the key
--   is not a member of the map, the original map is returned.
delete :: HKey x a -> HMap -> HMap

-- | <i>O(log n)</i>. Update a value at a specific key with the result of
--   the provided function. When the key is not a member of the map, the
--   original map is returned.
adjust :: (a -> a) -> HKey x a -> HMap -> HMap

-- | <i>O(log n)</i>. The expression (<tt><a>update</a> f k map</tt>)
--   updates the value <tt>x</tt> at <tt>k</tt> (if it is in the map). If
--   (<tt>f x</tt>) is <a>Nothing</a>, the element is deleted. If it is
--   (<tt><a>Just</a> y</tt>), the key <tt>k</tt> is bound to the new value
--   <tt>y</tt>.
update :: (a -> Maybe a) -> HKey x a -> HMap -> HMap

-- | <i>O(log n)</i>. The expression (<tt><a>alter</a> f k map</tt>) alters
--   the value <tt>x</tt> at <tt>k</tt>, or absence thereof. <a>alter</a>
--   can be used to insert, delete, or update a value in a <tt>Map</tt>. In
--   short : <tt><a>lookup</a> k (<a>alter</a> f k m) = f (<a>lookup</a> k
--   m)</tt>.
alter :: (Maybe a -> Maybe a) -> HKey x a -> HMap -> HMap

-- | <i>O(n+m)</i>. The expression (<tt><a>union</a> t1 t2</tt>) takes the
--   left-biased union of <tt>t1</tt> and <tt>t2</tt>. It prefers
--   <tt>t1</tt> when duplicate keys are encountered.
union :: HMap -> HMap -> HMap

-- | The union of a list of maps: (<tt><a>unions</a> == <a>foldl</a>
--   <a>union</a> <a>empty</a></tt>).
unions :: [HMap] -> HMap

-- | <i>O(n+m)</i>. Difference of two maps. Return elements of the first
--   map not existing in the second map.
difference :: HMap -> HMap -> HMap

-- | <i>O(n+m)</i>. Intersection of two maps. Return data in the first map
--   for the keys existing in both maps.
intersection :: HMap -> HMap -> HMap

-- | <i>O(n)</i>. Remove dead values from map.
--   
--   An entry into an HMap does not keep the value alive if the key is not
--   alive. After all, if the key is dead, then there is no way to retrieve
--   the value!
--   
--   Hence, a HMap can have elements which can never be accessed again.
--   This operation purges such elements from the given map. Notice that
--   this does change the size of the map and is hence in the IO monad.
purge :: HMap -> IO HMap


-- | A set of <a>HKey</a>s
module Data.HKeySet

-- | The type of hetrogenous key sets.
data HKeySet

-- | <i>O(1)</i> Construct an empty key set.
empty :: HKeySet

-- | <i>O(1)</i> Construct a set with a single element.
singleton :: HKey s a -> HKeySet

-- | <i>O(n+m)</i> Construct a key set containing all elements from both
--   sets.
--   
--   To obtain good performance, the smaller set must be presented as the
--   first argument.
union :: HKeySet -> HKeySet -> HKeySet

-- | Construct a key set containing all elements from a list of key sets.
unions :: [HKeySet] -> HKeySet

-- | <i>O(1)</i> Return <a>True</a> if this key set is empty, <a>False</a>
--   otherwise.
null :: HKeySet -> Bool

-- | <i>O(n)</i> Return the number of elements in this set.
size :: HKeySet -> Int

-- | <i>O(min(n,W))</i> Return <a>True</a> if the given value is present in
--   this set, <a>False</a> otherwise.
member :: HKey s a -> HKeySet -> Bool

-- | <i>O(min(n,W))</i> Add the specified value to this set.
insert :: HKey x a -> HKeySet -> HKeySet

-- | <i>O(min(n,W))</i> Remove the specified value from this set if
--   present.
delete :: HKey s a -> HKeySet -> HKeySet

-- | <i>O(n)</i> Difference of two sets. Return elements of the first set
--   not existing in the second.
difference :: HKeySet -> HKeySet -> HKeySet

-- | <i>O(n)</i> Intersection of two sets. Return elements present in both
--   the first set and the second.
intersection :: HKeySet -> HKeySet -> HKeySet

-- | <i>O(n)</i>. Does the map carry any of the keys?
overlap :: HMap -> HKeySet -> Bool

-- | <i>O(n)</i>. Do the keyset and the map have the same keys?
sameKeys :: HMap -> HKeySet -> Bool

-- | <i>O(n)</i>. Remove the keys from the keyset from the map.
removeKeys :: HMap -> HKeySet -> HMap
