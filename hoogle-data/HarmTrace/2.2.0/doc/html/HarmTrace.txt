-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Harmony Analysis and Retrieval of Music
--   
--   HarmTrace: Harmony Analysis and Retrieval of Music with Type-level
--   Representations of Abstract Chords Entities
--   
--   We present HarmTrace, a system for automatically analysing the harmony
--   of music sequences. HarmTrace is described in the paper:
--   
--   <ul>
--   <li>Jose Pedro Magalhaes and W. Bas de Haas. <i>Experience Report:
--   Functional Modelling of Musical Harmony.</i> International Conference
--   on Functional Programming, 2011.
--   <a>http://dreixel.net/research/pdf/fmmh.pdf</a></li>
--   </ul>
@package HarmTrace
@version 2.2.0

module HarmTrace.Models.TypeLevel
data Su :: * -> *
data Ze :: *
type T0 = Ze
type T1 = Su T0
type T2 = Su T1
type T3 = Su T2
type T4 = Su T3
type T5 = Su T4
type T6 = Su T5
type T7 = Su T6
type T8 = Su T7
type T9 = Su T8
type T10 = Su T9
type T11 = Su T10
type T12 = Su T11
type T13 = Su T12
type T14 = Su T13
type T15 = Su T14
type T16 = Su T15
type T17 = Su T16
type T18 = Su T17
type T19 = Su T18
type T20 = Su T19
class ToNat n
toNat :: ToNat n => n -> Int
instance Typeable1 Su
instance Typeable Ze
instance ToNat n => ToNat (Su n)
instance ToNat Ze

module HarmTrace.Matching.Standard
diffChords :: (Show a, Eq a) => [a] -> [a] -> String
diffChordsLen :: Eq a => [a] -> [a] -> Float

module HarmTrace.Base.Instances
instance NFData Mode


-- | Summary: Some statistical functions used in processing audio.
module HarmTrace.Audio.Statistical

-- | Similar to group, but in case a group is smaller than s, the group is
--   filled with the same number of a's:
--   
--   <pre>
--   &gt;&gt;&gt; groupMinSize 3 0 [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5]
--   [[0],[0,0],[0,0,0],[4,4,4,4],[5,5,5,5,5]]
--   </pre>
groupMinSize :: Eq a => Int -> a -> [a] -> [[a]]

-- | Returns the mean of list.
listMean :: [NumData] -> NumData

-- | a median filter: see
--   <a>http://en.wikipedia.org/wiki/Median_filter</a>.
medianFilter :: Ord a => Int -> [a] -> [a]

-- | Returns a list with all <a>sliding windows</a> of a particular size.
--   The left and right edge of the list are filled with the first and last
--   (size <i>2) items, respectively and the remainder is filled with the
--   mode</i>median of the complete list.
getWindows :: Ord a => Int -> [a] -> [[a]]
hasSize :: Int -> [a] -> Bool

-- | The mode: the element that occurs most often in the collection.
mode :: Ord a => [a] -> a

-- | Returns the median of a list.
median :: Ord a => [a] -> a

-- | Returns the index of th maximal element of a list.
maxListIndex :: Ord a => [a] -> Int


-- | Summary: Basic parsers for parsing VAMP csv files.
module HarmTrace.Audio.DataParser

-- | Parsing beat time stamps.
parseBeatData :: Parser BeatTrackerData

-- | Parses <a>BarTime</a> data.
parseBarTimeData :: Parser BarTimeTrackData

-- | Parses a <a>Beat</a>.
pBeat :: Parser Beat

-- | Chroma parsing.
parseChordinoData :: Parser ChordinoData
parseChromaData :: Parser [ChordinoLine]
pNumData :: Parser NumData
pComma :: Parser Char
pParentheticalString :: Char -> Parser String
pQuotedString :: Parser String
pLabel :: Parser String
shift :: Int -> [a] -> [a]


-- | Summary: Parses textual ground-truth Chord annotations, such as the
--   ones found at:
--   <a>http://isophonics.net/content/reference-annotations</a>
module HarmTrace.Audio.AnnotationParser

-- | Parses a chord annotation.
parseAnnotationData :: Parser [TimedData ChordLabel]

-- | Parses a <a>Key</a> annotation.
parseKeyAnnotationData :: Parser [TimedData Key]

module HarmTrace.HAnTree.Tree
data Tree a
Node :: !a -> ![Tree a] -> !(Maybe Int) -> Tree a
getLabel :: Tree a -> !a
getChild :: Tree a -> ![Tree a]
getPn :: Tree a -> !(Maybe Int)
strTree :: String -> Tree String
findClose :: String -> Int
findClose' :: String -> Int -> Int -> Int
getPns :: [Tree t] -> [Int]
getChildPns :: Tree a -> [Int]
getSubTree :: Tree t -> Int -> Tree t
isLf :: Eq t => Tree t -> Bool
collectLeafs :: Tree t -> [Tree t]
size :: Tree t -> Int
depth :: Tree t -> Int
sizeF :: [Tree t] -> Int
depthF :: [Tree t] -> Int
avgDepth :: Tree t -> Float
avgDepthF :: [Tree t] -> Float
depth' :: Int -> Tree t -> [Int]
remove :: Eq t => t -> Tree t -> Tree t
removeBy :: (t -> Bool) -> Tree t -> Tree t
removeBy' :: (t -> Bool) -> Tree t -> [Tree t]
pot :: Tree t -> [Tree t]
potPret :: Tree t -> [Tree t]
pret' :: Tree t -> [Tree t]
pret :: Tree t -> [Tree t]
pot' :: Tree t -> [Tree t]
preToPost :: Tree t -> Int -> Int
setPost :: Tree t -> Tree t
setPre :: Tree t -> Tree t
matchToTree :: Tree t -> [Int] -> [Tree t]
instance Eq a => Eq (Tree a)
instance Binary a => Binary (Tree a)
instance NFData a => NFData (Tree a)
instance Show a => Show (Tree a)

module HarmTrace.IO.Errors
data ErrorNrs
ErrorNrs :: Int -> Int -> Int -> Int -> ErrorNrs
ins :: ErrorNrs -> Int
del :: ErrorNrs -> Int
delEnd :: ErrorNrs -> Int
rep :: ErrorNrs -> Int
showErrors :: Show a => String -> [Error a] -> IO ()
countErrors :: Show a => [Error a] -> ErrorNrs
simpleErrorMeasure :: ErrorNrs -> Float
errorRatio :: Show a => [Error a] -> [b] -> Float
inc1 :: ErrorNrs -> ErrorNrs
inc4 :: ErrorNrs -> ErrorNrs
inc3 :: ErrorNrs -> ErrorNrs
inc2 :: ErrorNrs -> ErrorNrs
instance Show ErrorNrs

module HarmTrace.Models.ChordTokens
data ChordToken
ChordToken :: ScaleDegree -> ClassType -> [ChordLabel] -> ParseStatus -> Int -> Int -> ChordToken
root :: ChordToken -> ScaleDegree
classType :: ChordToken -> ClassType
chords :: ChordToken -> [ChordLabel]
status :: ChordToken -> ParseStatus
chordNumReps :: ChordToken -> Int
dur :: ChordToken -> Int
data PieceToken
PieceToken :: Key -> [ChordToken] -> PieceToken
data ParseStatus
NotParsed :: ParseStatus
Parsed :: ParseStatus
Deleted :: ParseStatus
Inserted :: ParseStatus

-- | Merges duplicate chords and transforms absolute chord labels into key
--   relative tokens that can be parsed by the HarmTrace model
toKeyRelTok :: Key -> [ChordLabel] -> [ChordToken]
instance Eq ParseStatus
instance Show ParseStatus
instance Generic ParseStatus
instance Generic ChordToken
instance Datatype D1ParseStatus
instance Constructor C1_0ParseStatus
instance Constructor C1_1ParseStatus
instance Constructor C1_2ParseStatus
instance Constructor C1_3ParseStatus
instance Datatype D1ChordToken
instance Constructor C1_0ChordToken
instance Selector S1_0_0ChordToken
instance Selector S1_0_1ChordToken
instance Selector S1_0_2ChordToken
instance Selector S1_0_3ChordToken
instance Selector S1_0_4ChordToken
instance Selector S1_0_5ChordToken
instance Binary ParseStatus
instance Binary ChordToken
instance Show ChordToken
instance Eq ChordToken

module HarmTrace.HAnTree.HAn
data HAn
HAn :: !Int -> !String -> HAn
HAnFunc :: !HFunc -> HAn
HAnPrep :: !Prep -> HAn
HAnTrans :: !Trans -> HAn
HAnChord :: !ChordToken -> HAn
data HFunc
Ton :: !Int -> !Mode -> !Int -> !(Maybe Spec) -> HFunc
Dom :: !Int -> !Mode -> !Int -> !(Maybe Spec) -> HFunc
Sub :: !Int -> !Mode -> !Int -> !(Maybe Spec) -> HFunc
P :: HFunc
PD :: HFunc
PT :: HFunc
data Spec
Blues :: Spec
MinBorrow :: Spec
Parallel :: Spec
data Prep
SecDom :: !Int -> !ScaleDegree -> Prep
SecMin :: !Int -> !ScaleDegree -> Prep
DiatDom :: !Int -> !ScaleDegree -> Prep
NoPrep :: Prep
data Trans
Trit :: !Int -> !ScaleDegree -> Trans
DimTrit :: !Int -> !ScaleDegree -> Trans
DimTrans :: !Int -> !ScaleDegree -> Trans
NoTrans :: Trans
class GetDur a
getDur :: GetDur a => a -> Int
class SetDur a
setDur :: SetDur a => a -> Int -> a
instance Eq Spec
instance Generic Spec
instance Generic HFunc
instance Generic Prep
instance Generic Trans
instance Generic HAn
instance Datatype D1Spec
instance Constructor C1_0Spec
instance Constructor C1_1Spec
instance Constructor C1_2Spec
instance Datatype D1HFunc
instance Constructor C1_0HFunc
instance Constructor C1_1HFunc
instance Constructor C1_2HFunc
instance Constructor C1_3HFunc
instance Constructor C1_4HFunc
instance Constructor C1_5HFunc
instance Datatype D1Prep
instance Constructor C1_0Prep
instance Constructor C1_1Prep
instance Constructor C1_2Prep
instance Constructor C1_3Prep
instance Datatype D1Trans
instance Constructor C1_0Trans
instance Constructor C1_1Trans
instance Constructor C1_2Trans
instance Constructor C1_3Trans
instance Datatype D1HAn
instance Constructor C1_0HAn
instance Constructor C1_1HAn
instance Constructor C1_2HAn
instance Constructor C1_3HAn
instance Constructor C1_4HAn
instance Show Spec
instance Show HFunc
instance Show HAn
instance Show Trans
instance Show Prep
instance Eq Trans
instance Eq Prep
instance Eq HFunc
instance Eq HAn
instance SetDur Trans
instance SetDur Prep
instance SetDur HFunc
instance SetDur HAn
instance GetDur (Chord a)
instance GetDur Trans
instance GetDur Prep
instance GetDur HFunc
instance GetDur HAn
instance NFData Spec
instance NFData Trans
instance NFData Prep
instance NFData HFunc
instance NFData HAn
instance Binary Spec
instance Binary HFunc
instance Binary Prep
instance Binary Trans
instance Binary HAn

module HarmTrace.HAnTree.HAnParser
parseHAn :: ListLike state Char => state -> HAn
pHFunc :: Parser HFunc
pMode :: Parser Mode
pSpec :: Parser Spec
pAnyStr :: Parser String

module HarmTrace.HAnTree.ToHAnTree
class GTree a
gTree :: GTree a => a -> [Tree HAn]
data HAn
HAn :: !Int -> !String -> HAn
HAnFunc :: !HFunc -> HAn
HAnPrep :: !Prep -> HAn
HAnTrans :: !Trans -> HAn
HAnChord :: !ChordToken -> HAn
gTreeDefault :: (Representable a, GTree (Rep a)) => a -> [Tree HAn]
gTreeHead :: GTree a => a -> Tree HAn
emptyHAnTree :: Tree HAn
instance GTree a => GTree [a]
instance GTree a => GTree (Var a)
instance GTree a => GTree (Rec a)
instance (GTree a, GTree b) => GTree (a :*: b)
instance (GTree a, Constructor c) => GTree (CEq c p q a)
instance (GTree a, GTree b) => GTree (a :+: b)
instance GTree U

module HarmTrace.HAnTree.PostProcess
data PPOption
RemoveInsertions :: PPOption
RemovePDPT :: PPOption
MergeDelChords :: PPOption
ExpandChordDurations :: PPOption
expandChordDurations :: Tree HAn -> Tree HAn
removePDPT :: Tree HAn -> Tree HAn
removeInsertions :: Tree HAn -> Tree HAn
mergeDelChords :: Key -> [Error Int] -> [ChordLabel] -> Tree HAn -> Tree HAn
instance Eq PPOption

module HarmTrace.Matching.Sim
class Sim a
sim :: Sim a => a -> a -> Int
maxSim :: Sim a => [a] -> Int
div1 :: Int -> Int -> Int
instance Sim ChordToken
instance Sim Prep
instance Sim Trans
instance Sim Mode
instance Sim HFunc
instance Sim Int
instance Sim HAn
instance Sim a => Sim [a]
instance Sim a => Sim (Tree a)

module HarmTrace.Matching.SimpleChord
data SimChord
class Sim a
toSimChords :: ChordDegree -> [SimChord]
instance Show SimChord
instance Sim SimChord

module HarmTrace.Matching.HChord
data HChord
class Sim a
toHChords :: Tree HAn -> [HChord]
instance Show HChord
instance Sim HChord

module HarmTrace.Matching.Alignment
alignChordLab :: Key -> Key -> [ChordLabel] -> [ChordLabel] -> ([SimChord], Float, Vector (Vector Int))
pPrintV :: Show a => Vector (Vector a) -> IO ()
getAlignDist :: Key -> Key -> [ChordLabel] -> [ChordLabel] -> Float
getHAnDist :: Tree HAn -> Tree HAn -> Float
alignHAnChord :: Tree HAn -> Tree HAn -> ([HChord], Float, Vector (Vector Int))

module HarmTrace.Matching.GuptaNishimura
getLCES :: Tree HAn -> Tree HAn -> ([Tree HAn], Int)
getLCESsize :: Tree HAn -> Tree HAn -> Float
getLCESdepth :: Tree HAn -> Tree HAn -> Float
getLCESsim :: Tree HAn -> Tree HAn -> Float


-- | Summary: The jazz model
module HarmTrace.Models.Jazz.Model
data MajMode
data MinMode
data Piece
Piece :: [Phrase mode] -> Piece
data Phrase mode
PT :: Ton mode -> Phrase mode
PD :: Dom mode -> Phrase mode
data Ton mode
T_1 :: Final I MajClass -> Ton MajMode
T_2 :: Final I MajClass -> Final IV MajClass -> Final I MajClass -> Ton MajMode
T_3_par :: Final III MinClass -> Ton MajMode
T_6_bor :: TMinBorrow -> Ton MajMode
Tm_1 :: SD MinMode I MinClass -> Ton MinMode
Tm_2 :: Final I MinClass -> Final IV MinClass -> Final I MinClass -> Ton MinMode
Tm_3_par :: Final IIIb MajClass -> Ton MinMode
Tm_6_bor :: TMajBorrow -> Ton MinMode
data Dom mode
D_1 :: SDom mode -> Dom mode -> Dom mode
D_2 :: SD mode V DomClass -> Dom mode
D_3 :: SD mode V MajClass -> Dom mode
D_4 :: SD MajMode VII MinClass -> Dom MajMode
D_8_bor :: DMinBorrow -> Dom MajMode
Dm_4 :: SD MinMode VIIb MajClass -> Dom MinMode
Dm_8_bor :: DMajBorrow -> Dom MinMode
data SDom mode
S_1_par :: SD mode II MinClass -> SDom mode
S_2_par :: SD mode II DomClass -> Final II MinClass -> SDom mode
S_3 :: SD MajMode IV MajClass -> SDom MajMode
S_4 :: SD MajMode III MinClass -> Final IV MajClass -> SDom MajMode
S_5_bor :: SMinBorrow -> SDom MajMode
Sm_3 :: SD MinMode IV MinClass -> SDom MinMode
Sm_4 :: SD MinMode IIIb MajClass -> Final IV MinClass -> SDom MinMode
Sm_5_bor :: SMajBorrow -> SDom MinMode
Sm_6 :: SD MinMode IIb MajClass -> SDom MinMode
data TMinBorrow
Tm_21_bor :: (SD MinMode I MinClass) -> TMinBorrow
Tm_23_bor :: (SD MinMode IIIb MajClass) -> TMinBorrow
data DMinBorrow
Dm_24_bor :: (SD MinMode VIIb MajClass) -> DMinBorrow
data SMinBorrow
Sm_20_bor :: (SD MinMode IV MinClass) -> SMinBorrow
Sm_22_bor :: (SD MinMode IIb MajClass) -> SMinBorrow
data TMajBorrow
T_21_bor :: (SD MajMode I MajClass) -> TMajBorrow
T_23_bor :: (SD MajMode III MinClass) -> TMajBorrow
data DMajBorrow
D_24_bor :: (SD MajMode VII MinClass) -> DMajBorrow
data SMajBorrow
S_20_bor :: (SD MajMode IV MajClass) -> SMajBorrow
type SD mode deg clss = Base_SD deg clss T5
type TritMinVSub deg clss = Base_Final deg clss T2
type FinalDimTrans deg clss = Surface_Chord deg clss T4
type Final deg clss = Surface_Chord deg clss T1
data Base_SD deg clss n
Base_SD :: TritMinVSub deg clss -> Base_SD deg clss (Su n)
Cons_Vdom :: Base_SD (VDom deg) DomClass n -> Base_SD deg clss n -> Base_SD deg clss (Su n)
Cons_Diat :: Base_SD (DiatV deg) MinClass n -> Base_SD deg MinClass n -> Base_SD deg MinClass (Su n)
Cons_DiatM :: Base_SD (DiatVM deg) MajClass n -> Base_SD deg MajClass n -> Base_SD deg MajClass (Su n)
Cons_DiatM' :: Base_SD (DiatVM deg) MajClass n -> Base_SD deg MinClass n -> Base_SD deg MinClass (Su n)
Cons_Vmin :: Base_SD (VMin deg) MinClass n -> Base_SD deg DomClass n -> Base_SD deg DomClass (Su n)
data Base_Final deg clss n
Base_Final :: FinalDimTrans deg clss -> Base_Final deg clss (Su n)
Final_Tritone :: Base_Final (Tritone deg) DomClass n -> Base_Final deg DomClass (Su n)
Final_Dim_V :: Base_Final (IIbDim deg) DimClass n -> Base_Final deg DomClass (Su n)
data Surface_Chord deg clss n
Surface_Chord :: ChordToken -> Surface_Chord deg clss (Su n)
Dim_Chord_Trns :: Surface_Chord (MinThird deg) DimClass n -> Surface_Chord deg DimClass (Su n)
data MajClass
data MinClass
data DomClass
data DimClass
data I
data Ib
data Is
data II
data IIb
data IIs
data III
data IIIb
data IIIs
data IV
data IVb
data IVs
data V
data Vb
data Vs
data VI
data VIb
data VIs
data VII
data VIIb
data VIIs
data Imp
class ToClass clss
toClass :: ToClass clss => clss -> ClassType
class ToDegree deg
toDegree :: ToDegree deg => deg -> ScaleDegree
allTypes :: [Name]
instance ToDegree Imp
instance ToDegree VIIs
instance ToDegree VIs
instance ToDegree Vs
instance ToDegree IVs
instance ToDegree IIIs
instance ToDegree IIs
instance ToDegree VIIb
instance ToDegree VIb
instance ToDegree Vb
instance ToDegree IVb
instance ToDegree IIIb
instance ToDegree IIb
instance ToDegree Ib
instance ToDegree VII
instance ToDegree VI
instance ToDegree V
instance ToDegree IV
instance ToDegree III
instance ToDegree II
instance ToDegree I
instance ToClass Imp
instance ToClass DimClass
instance ToClass DomClass
instance ToClass MinClass
instance ToClass MajClass

module HarmTrace.Models.Pop.Model
data MajMode
data MinMode
data Piece
Piece :: [Phrase mode] -> Piece
data Phrase mode
PT :: Ton mode -> Phrase mode
PD :: Dom mode -> Phrase mode
data Ton mode
T_0 :: SDom mode -> Ton mode -> Ton mode
T_1 :: Final I MajClass -> Ton MajMode
T_4_bls :: Final I DomClass -> Ton mode
T_6_bor :: TMinBorrow -> Ton MajMode
Tm_1 :: SD MinMode I MinClass -> Ton MinMode
Tm_6_bor :: TMajBorrow -> Ton MinMode
data Dom mode
D_1 :: SDom mode -> Dom mode -> Dom mode
D_2 :: SD mode V DomClass -> Dom mode
D_3 :: SD mode V MajClass -> Dom mode
D_4 :: SD MajMode VII MinClass -> Dom MajMode
D_8_bor :: DMinBorrow -> Dom MajMode
Dm_4 :: SD MinMode VIIb MajClass -> Dom MinMode
Dm_8_bor :: DMajBorrow -> Dom MinMode
data SDom mode
S_1_par :: SD mode II MinClass -> SDom mode
S_2_par :: SD mode II DomClass -> Final II MinClass -> SDom mode
S_3 :: SD MajMode IV MajClass -> SDom MajMode
S_3_bls :: Final IV DomClass -> SDom mode
S_4 :: SD MajMode III MinClass -> Final IV MajClass -> SDom MajMode
S_7 :: SD MajMode III MinClass -> Final II MinClass -> SDom MajMode
S_5_par :: SD MajMode VI MinClass -> SDom MajMode
S_9_bor :: SMinBorrow -> SDom MajMode
Sm_3 :: SD MinMode IV MinClass -> SDom MinMode
Sm_4 :: SD MinMode IIIb MajClass -> Final IV MinClass -> SDom MinMode
Sm_7 :: SD MinMode IIIb MajClass -> Final II MinClass -> SDom MinMode
Sm_5_par :: SD MinMode VIb MajClass -> SDom MinMode
Sm_9_bor :: SMajBorrow -> SDom MinMode
Sm_6 :: SD MinMode IIb MajClass -> SDom MinMode
data TMinBorrow
Tm_21_bor :: (SD MinMode I MinClass) -> TMinBorrow
data DMinBorrow
Dm_24_bor :: (SD MinMode VIIb MajClass) -> DMinBorrow
data SMinBorrow
Sm_20_bor :: (SD MinMode IV MinClass) -> SMinBorrow
Sm_22_bor :: (SD MinMode IIb MajClass) -> SMinBorrow
data TMajBorrow
T_21_bor :: (SD MajMode I MajClass) -> TMajBorrow
data DMajBorrow
D_24_bor :: (SD MajMode VII MinClass) -> DMajBorrow
data SMajBorrow
S_20_bor :: (SD MajMode IV MajClass) -> SMajBorrow
type SD mode deg clss = Base_SD deg clss T4
type TritMinVSub deg clss = Base_Final deg clss T2
type FinalDimTrans deg clss = Surface_Chord deg clss T4
type Final deg clss = Surface_Chord deg clss T1
data Base_SD deg clss n
Base_SD :: TritMinVSub deg clss -> Base_SD deg clss (Su n)
Cons_Vdom :: Base_SD (VDom deg) DomClass n -> Base_SD deg clss n -> Base_SD deg clss (Su n)
Cons_Diat :: Base_SD (DiatV deg) MinClass n -> Base_SD deg MinClass n -> Base_SD deg MinClass (Su n)
Cons_DiatM :: Base_SD (DiatVM deg) MajClass n -> Base_SD deg MajClass n -> Base_SD deg MajClass (Su n)
Cons_DiatM' :: Base_SD (DiatVM deg) MajClass n -> Base_SD deg MinClass n -> Base_SD deg MinClass (Su n)
Cons_Vmin :: Base_SD (VMin deg) MinClass n -> Base_SD deg DomClass n -> Base_SD deg DomClass (Su n)
data Base_Final deg clss n
Base_Final :: FinalDimTrans deg clss -> Base_Final deg clss (Su n)
data Surface_Chord deg clss n
Surface_Chord :: ChordToken -> Surface_Chord deg clss (Su n)
data MajClass
data MinClass
data DomClass
data DimClass
data I
data Ib
data Is
data II
data IIb
data IIs
data III
data IIIb
data IIIs
data IV
data IVb
data IVs
data V
data Vb
data Vs
data VI
data VIb
data VIs
data VII
data VIIb
data VIIs
data Imp
class ToClass clss
toClass :: ToClass clss => clss -> ClassType
class ToDegree deg
toDegree :: ToDegree deg => deg -> ScaleDegree
allTypes :: [Name]
instance ToDegree Imp
instance ToDegree VIIs
instance ToDegree VIs
instance ToDegree Vs
instance ToDegree IVs
instance ToDegree IIIs
instance ToDegree IIs
instance ToDegree VIIb
instance ToDegree VIb
instance ToDegree Vb
instance ToDegree IVb
instance ToDegree IIIb
instance ToDegree IIb
instance ToDegree Ib
instance ToDegree VII
instance ToDegree VI
instance ToDegree V
instance ToDegree IV
instance ToDegree III
instance ToDegree II
instance ToDegree I
instance ToClass Imp
instance ToClass DimClass
instance ToClass DomClass
instance ToClass MinClass
instance ToClass MajClass


-- | Summary: Semi-generic parser for chords
module HarmTrace.Models.Parser
class ParseG a
parseG :: ParseG a => PMusic a

-- | default generic parser
parseGdefault :: (Representable a, Parse' (Rep a)) => PMusic a

-- | a type synoniome for a harmonic analysis of a piece of music
type PMusic a = P (Str ChordToken [ChordToken] Int) a
instance [overlap ok] ParseG a => ParseG (Maybe a)
instance [overlap ok] ParseG a => ParseG [a]
instance [overlap ok] (Parse' f, Parse' g) => Parse' (f :*: g)
instance [overlap ok] (Parse' f, Parse' g) => Parse' (f :+: g)
instance [overlap ok] Parse' (CEq c p q f)
instance [overlap ok] (Constructor c, Parse' f) => Parse' (CEq c p p f)
instance [overlap ok] ParseG a => Parse' (Var a)
instance [overlap ok] ParseG a => Parse' (Rec a)
instance [overlap ok] Parse' U


-- | Summary: Adhoc instances for the jazz model
module HarmTrace.Models.Jazz.Instances
pChord :: ScaleDegree -> ClassType -> PMusic (Surface_Chord deg clss (Su n))
toGTree :: (GetDegree a, GTree a) => (Int -> ScaleDegree -> Trans) -> Int -> a -> [Tree HAn]
toGTreeSplit :: (GetDegree a, GetDegree b, GTree a, GTree b) => (Int -> ScaleDegree -> Prep) -> b -> a -> [Tree HAn]
toTransSDVal :: GetDegree a => Int -> a -> ScaleDegree
toSDVal :: GetDegree a => a -> ScaleDegree
class GetDegree a
getDeg :: GetDegree a => a -> (ScaleDegree, Int)
data Phrase_PT_
data Phrase_PD_
type RepPhrase_ mode_a2BXz = :+: (CEq Phrase_PT_ () () (Rec (Ton mode_a2BXz))) (CEq Phrase_PD_ () () (Rec (Dom mode_a2BXz)))
data Ton_T_1_
data Ton_T_2_
data Ton_T_3_par_
data Ton_T_6_bor_
data Ton_Tm_1_
data Ton_Tm_2_
data Ton_Tm_3_par_
data Ton_Tm_6_bor_
type RepTon_ mode_a2BXy = :+: (:+: (:+: (CEq Ton_T_1_ (:*: mode_a2BXy ()) (:*: MajMode ()) (Rec (Final I MajClass))) (CEq Ton_T_2_ (:*: mode_a2BXy ()) (:*: MajMode ()) (:*: (Rec (Final I MajClass)) (:*: (Rec (Final IV MajClass)) (Rec (Final I MajClass)))))) (:+: (CEq Ton_T_3_par_ (:*: mode_a2BXy ()) (:*: MajMode ()) (Rec (Final III MinClass))) (CEq Ton_T_6_bor_ (:*: mode_a2BXy ()) (:*: MajMode ()) (Rec TMinBorrow)))) (:+: (:+: (CEq Ton_Tm_1_ (:*: mode_a2BXy ()) (:*: MinMode ()) (Rec (SD MinMode I MinClass))) (CEq Ton_Tm_2_ (:*: mode_a2BXy ()) (:*: MinMode ()) (:*: (Rec (Final I MinClass)) (:*: (Rec (Final IV MinClass)) (Rec (Final I MinClass)))))) (:+: (CEq Ton_Tm_3_par_ (:*: mode_a2BXy ()) (:*: MinMode ()) (Rec (Final IIIb MajClass))) (CEq Ton_Tm_6_bor_ (:*: mode_a2BXy ()) (:*: MinMode ()) (Rec TMajBorrow))))
data Dom_D_1_
data Dom_D_2_
data Dom_D_3_
data Dom_D_4_
data Dom_D_8_bor_
data Dom_Dm_4_
data Dom_Dm_8_bor_
type RepDom_ mode_a2BXu = :+: (:+: (CEq Dom_D_1_ () () (:*: (Rec (SDom mode_a2BXu)) (Rec (Dom mode_a2BXu)))) (:+: (CEq Dom_D_2_ () () (Rec (SD mode_a2BXu V DomClass))) (CEq Dom_D_3_ () () (Rec (SD mode_a2BXu V MajClass))))) (:+: (:+: (CEq Dom_D_4_ (:*: mode_a2BXu ()) (:*: MajMode ()) (Rec (SD MajMode VII MinClass))) (CEq Dom_D_8_bor_ (:*: mode_a2BXu ()) (:*: MajMode ()) (Rec DMinBorrow))) (:+: (CEq Dom_Dm_4_ (:*: mode_a2BXu ()) (:*: MinMode ()) (Rec (SD MinMode VIIb MajClass))) (CEq Dom_Dm_8_bor_ (:*: mode_a2BXu ()) (:*: MinMode ()) (Rec DMajBorrow))))
data SDom_S_1_par_
data SDom_S_2_par_
data SDom_S_3_
data SDom_S_4_
data SDom_S_5_bor_
data SDom_Sm_3_
data SDom_Sm_4_
data SDom_Sm_5_bor_
data SDom_Sm_6_
type RepSDom_ mode_a2BXr = :+: (:+: (:+: (CEq SDom_S_1_par_ () () (Rec (SD mode_a2BXr II MinClass))) (CEq SDom_S_2_par_ () () (:*: (Rec (SD mode_a2BXr II DomClass)) (Rec (Final II MinClass))))) (:+: (CEq SDom_S_3_ (:*: mode_a2BXr ()) (:*: MajMode ()) (Rec (SD MajMode IV MajClass))) (CEq SDom_S_4_ (:*: mode_a2BXr ()) (:*: MajMode ()) (:*: (Rec (SD MajMode III MinClass)) (Rec (Final IV MajClass)))))) (:+: (:+: (CEq SDom_S_5_bor_ (:*: mode_a2BXr ()) (:*: MajMode ()) (Rec SMinBorrow)) (CEq SDom_Sm_3_ (:*: mode_a2BXr ()) (:*: MinMode ()) (Rec (SD MinMode IV MinClass)))) (:+: (CEq SDom_Sm_4_ (:*: mode_a2BXr ()) (:*: MinMode ()) (:*: (Rec (SD MinMode IIIb MajClass)) (Rec (Final IV MinClass)))) (:+: (CEq SDom_Sm_5_bor_ (:*: mode_a2BXr ()) (:*: MinMode ()) (Rec SMajBorrow)) (CEq SDom_Sm_6_ (:*: mode_a2BXr ()) (:*: MinMode ()) (Rec (SD MinMode IIb MajClass))))))
data TMinBorrow_Tm_21_bor_
data TMinBorrow_Tm_23_bor_
type RepTMinBorrow_ = :+: (CEq TMinBorrow_Tm_21_bor_ () () (Rec (SD MinMode I MinClass))) (CEq TMinBorrow_Tm_23_bor_ () () (Rec (SD MinMode IIIb MajClass)))
data DMinBorrow_Dm_24_bor_
type RepDMinBorrow_ = CEq DMinBorrow_Dm_24_bor_ () () (Rec (SD MinMode VIIb MajClass))
data SMinBorrow_Sm_20_bor_
data SMinBorrow_Sm_22_bor_
type RepSMinBorrow_ = :+: (CEq SMinBorrow_Sm_20_bor_ () () (Rec (SD MinMode IV MinClass))) (CEq SMinBorrow_Sm_22_bor_ () () (Rec (SD MinMode IIb MajClass)))
data TMajBorrow_T_21_bor_
data TMajBorrow_T_23_bor_
type RepTMajBorrow_ = :+: (CEq TMajBorrow_T_21_bor_ () () (Rec (SD MajMode I MajClass))) (CEq TMajBorrow_T_23_bor_ () () (Rec (SD MajMode III MinClass)))
data DMajBorrow_D_24_bor_
type RepDMajBorrow_ = CEq DMajBorrow_D_24_bor_ () () (Rec (SD MajMode VII MinClass))
data SMajBorrow_S_20_bor_
type RepSMajBorrow_ = CEq SMajBorrow_S_20_bor_ () () (Rec (SD MajMode IV MajClass))
instance [overlap ok] IsLocationUpdatedBy Int ChordToken
instance [overlap ok] GTree SMajBorrow
instance [overlap ok] GTree DMajBorrow
instance [overlap ok] GTree TMajBorrow
instance [overlap ok] GTree SMinBorrow
instance [overlap ok] GTree DMinBorrow
instance [overlap ok] GTree TMinBorrow
instance [overlap ok] GTree (SDom mode0)
instance [overlap ok] GTree (Dom mode0)
instance [overlap ok] GTree (Ton mode0)
instance [overlap ok] GTree (Phrase mode0)
instance [overlap ok] ParseG (SD MajMode IV MajClass) => ParseG SMajBorrow
instance [overlap ok] ParseG (SD MajMode VII MinClass) => ParseG DMajBorrow
instance [overlap ok] (ParseG (SD MajMode I MajClass), ParseG (SD MajMode III MinClass)) => ParseG TMajBorrow
instance [overlap ok] (ParseG (SD MinMode IV MinClass), ParseG (SD MinMode IIb MajClass)) => ParseG SMinBorrow
instance [overlap ok] ParseG (SD MinMode VIIb MajClass) => ParseG DMinBorrow
instance [overlap ok] (ParseG (SD MinMode I MinClass), ParseG (SD MinMode IIIb MajClass)) => ParseG TMinBorrow
instance [overlap ok] (ParseG (SD MinMode IV MinClass), ParseG (SD MinMode IIIb MajClass), ParseG (Final IV MinClass), ParseG SMajBorrow, ParseG (SD MinMode IIb MajClass)) => ParseG (SDom MinMode)
instance [overlap ok] (ParseG (SD MajMode IV MajClass), ParseG (SD MajMode III MinClass), ParseG (Final IV MajClass), ParseG SMinBorrow) => ParseG (SDom MajMode)
instance [overlap ok] (ParseG (SD MinMode VIIb MajClass), ParseG DMajBorrow) => ParseG (Dom MinMode)
instance [overlap ok] (ParseG (SD MajMode VII MinClass), ParseG DMinBorrow) => ParseG (Dom MajMode)
instance [overlap ok] (ParseG (SD MinMode I MinClass), ParseG (Final I MinClass), ParseG (Final IV MinClass), ParseG (Final IIIb MajClass), ParseG TMajBorrow) => ParseG (Ton MinMode)
instance [overlap ok] (ParseG (Final I MajClass), ParseG (Final IV MajClass), ParseG (Final III MinClass), ParseG TMinBorrow) => ParseG (Ton MajMode)
instance [overlap ok] (ParseG (Ton mode0), ParseG (Dom mode0)) => ParseG (Phrase mode0)
instance [overlap ok] Representable SMajBorrow
instance [overlap ok] Constructor SMajBorrow_S_20_bor_
instance [overlap ok] Representable DMajBorrow
instance [overlap ok] Constructor DMajBorrow_D_24_bor_
instance [overlap ok] Representable TMajBorrow
instance [overlap ok] Constructor TMajBorrow_T_23_bor_
instance [overlap ok] Constructor TMajBorrow_T_21_bor_
instance [overlap ok] Representable SMinBorrow
instance [overlap ok] Constructor SMinBorrow_Sm_22_bor_
instance [overlap ok] Constructor SMinBorrow_Sm_20_bor_
instance [overlap ok] Representable DMinBorrow
instance [overlap ok] Constructor DMinBorrow_Dm_24_bor_
instance [overlap ok] Representable TMinBorrow
instance [overlap ok] Constructor TMinBorrow_Tm_23_bor_
instance [overlap ok] Constructor TMinBorrow_Tm_21_bor_
instance [overlap ok] Representable (SDom mode0)
instance [overlap ok] Constructor SDom_Sm_6_
instance [overlap ok] Constructor SDom_Sm_5_bor_
instance [overlap ok] Constructor SDom_Sm_4_
instance [overlap ok] Constructor SDom_Sm_3_
instance [overlap ok] Constructor SDom_S_5_bor_
instance [overlap ok] Constructor SDom_S_4_
instance [overlap ok] Constructor SDom_S_3_
instance [overlap ok] Constructor SDom_S_2_par_
instance [overlap ok] Constructor SDom_S_1_par_
instance [overlap ok] Representable (Dom mode0)
instance [overlap ok] Constructor Dom_Dm_8_bor_
instance [overlap ok] Constructor Dom_Dm_4_
instance [overlap ok] Constructor Dom_D_8_bor_
instance [overlap ok] Constructor Dom_D_4_
instance [overlap ok] Constructor Dom_D_3_
instance [overlap ok] Constructor Dom_D_2_
instance [overlap ok] Constructor Dom_D_1_
instance [overlap ok] Representable (Ton mode0)
instance [overlap ok] Constructor Ton_Tm_6_bor_
instance [overlap ok] Constructor Ton_Tm_3_par_
instance [overlap ok] Constructor Ton_Tm_2_
instance [overlap ok] Constructor Ton_Tm_1_
instance [overlap ok] Constructor Ton_T_6_bor_
instance [overlap ok] Constructor Ton_T_3_par_
instance [overlap ok] Constructor Ton_T_2_
instance [overlap ok] Constructor Ton_T_1_
instance [overlap ok] Representable (Phrase mode0)
instance [overlap ok] Constructor Phrase_PD_
instance [overlap ok] Constructor Phrase_PT_
instance [overlap ok] GetDegree (Surface_Chord (MinThird deg) DimClass n) => GetDegree (Surface_Chord deg clss (Su n))
instance [overlap ok] GetDegree (Surface_Chord deg clss Ze)
instance [overlap ok] GetDegree (Base_Final deg clss n)
instance [overlap ok] GetDegree (Base_Final deg clss Ze)
instance [overlap ok] GetDegree (Base_SD deg clss n)
instance [overlap ok] (GetDegree (Surface_Chord (MinThird deg) DimClass n), GTree (Surface_Chord (MinThird deg) DimClass n)) => GTree (Surface_Chord deg clss (Su n))
instance [overlap ok] GTree (Surface_Chord deg clss Ze)
instance [overlap ok] (GetDegree (Base_Final (Tritone deg) DomClass n), GetDegree (Base_Final (IIbDim deg) DimClass n), GTree (FinalDimTrans deg clss), GTree (Base_Final (Tritone deg) DomClass n), GTree (Base_Final (IIbDim deg) DimClass n)) => GTree (Base_Final deg clss (Su n))
instance [overlap ok] GTree (Base_Final deg clss Ze)
instance [overlap ok] (GTree (Base_SD (VDom deg) DomClass n), GTree (Base_SD (DiatV deg) MinClass n), GTree (Base_SD (DiatVM deg) MajClass n), GTree (Base_SD (VMin deg) MinClass n), GTree (Base_SD deg clss n), GTree (Base_Final deg clss n)) => GTree (Base_SD deg clss (Su n))
instance [overlap ok] GTree (Base_SD deg clss Ze)
instance [overlap ok] GTree Piece
instance [overlap ok] (ToDegree deg, ToClass clss) => ParseG (Surface_Chord deg clss (Su n))
instance [overlap ok] (ToDegree deg, ParseG (Surface_Chord (MinThird deg) DimClass n)) => ParseG (Surface_Chord deg DimClass (Su n))
instance [overlap ok] ParseG (Surface_Chord deg clss Ze)
instance [overlap ok] (ParseG (FinalDimTrans deg DomClass), ParseG (FinalDimTrans deg MinClass), ParseG (Base_Final (Tritone deg) DomClass n), ParseG (Base_Final (IIbDim deg) DimClass n)) => ParseG (Base_Final deg DomClass (Su n))
instance [overlap ok] ParseG (FinalDimTrans deg clss) => ParseG (Base_Final deg clss (Su n))
instance [overlap ok] ParseG (Base_Final deg clss Ze)
instance [overlap ok] (ToDegree (VDom deg), ParseG (Base_SD (VDom deg) DomClass n), ParseG (Base_SD deg DimClass n), ParseG (TritMinVSub deg DimClass)) => ParseG (Base_SD deg DimClass (Su n))
instance [overlap ok] (ToDegree (VMin deg), ToDegree (VDom deg), ParseG (Base_SD (VDom deg) DomClass n), ParseG (Base_SD (VMin deg) MinClass n), ParseG (Base_SD deg DomClass n), ParseG (TritMinVSub deg DomClass)) => ParseG (Base_SD deg DomClass (Su n))
instance [overlap ok] (ToDegree (DiatVM deg), ToDegree (VDom deg), ParseG (Base_SD (VDom deg) DomClass n), ParseG (Base_SD (DiatVM deg) MajClass n), ParseG (Base_SD deg MajClass n), ParseG (TritMinVSub deg MajClass)) => ParseG (Base_SD deg MajClass (Su n))
instance [overlap ok] (ToDegree (DiatV deg), ToDegree (VDom deg), ParseG (Base_SD (VDom deg) DomClass n), ParseG (Base_SD (DiatV deg) MinClass n), ParseG (Base_SD (DiatVM deg) MajClass n), ParseG (Base_SD deg MinClass n), ParseG (TritMinVSub deg MinClass)) => ParseG (Base_SD deg MinClass (Su n))
instance [overlap ok] ParseG (Base_SD deg clss Ze)

module HarmTrace.Models.Pop.Instances
pChord :: ScaleDegree -> ClassType -> PMusic (Surface_Chord deg clss (Su n))
toGTree :: (GetDegree a, GTree a) => (Int -> ScaleDegree -> Trans) -> Int -> a -> [Tree HAn]
toGTreeSplit :: (GetDegree a, GetDegree b, GTree a, GTree b) => (Int -> ScaleDegree -> Prep) -> b -> a -> [Tree HAn]
toTransSDVal :: GetDegree a => Int -> a -> ScaleDegree
toSDVal :: GetDegree a => a -> ScaleDegree
class GetDegree a
getDeg :: GetDegree a => a -> (ScaleDegree, Int)
data Phrase_PT_
data Phrase_PD_
type RepPhrase_ mode_a2D31 = :+: (CEq Phrase_PT_ () () (Rec (Ton mode_a2D31))) (CEq Phrase_PD_ () () (Rec (Dom mode_a2D31)))
data Ton_T_0_
data Ton_T_1_
data Ton_T_4_bls_
data Ton_T_6_bor_
data Ton_Tm_1_
data Ton_Tm_6_bor_
type RepTon_ mode_a2D2Y = :+: (:+: (CEq Ton_T_0_ () () (:*: (Rec (SDom mode_a2D2Y)) (Rec (Ton mode_a2D2Y)))) (:+: (CEq Ton_T_1_ (:*: mode_a2D2Y ()) (:*: MajMode ()) (Rec (Final I MajClass))) (CEq Ton_T_4_bls_ () () (Rec (Final I DomClass))))) (:+: (CEq Ton_T_6_bor_ (:*: mode_a2D2Y ()) (:*: MajMode ()) (Rec TMinBorrow)) (:+: (CEq Ton_Tm_1_ (:*: mode_a2D2Y ()) (:*: MinMode ()) (Rec (SD MinMode I MinClass))) (CEq Ton_Tm_6_bor_ (:*: mode_a2D2Y ()) (:*: MinMode ()) (Rec TMajBorrow))))
data Dom_D_1_
data Dom_D_2_
data Dom_D_3_
data Dom_D_4_
data Dom_D_8_bor_
data Dom_Dm_4_
data Dom_Dm_8_bor_
type RepDom_ mode_a2D2U = :+: (:+: (CEq Dom_D_1_ () () (:*: (Rec (SDom mode_a2D2U)) (Rec (Dom mode_a2D2U)))) (:+: (CEq Dom_D_2_ () () (Rec (SD mode_a2D2U V DomClass))) (CEq Dom_D_3_ () () (Rec (SD mode_a2D2U V MajClass))))) (:+: (:+: (CEq Dom_D_4_ (:*: mode_a2D2U ()) (:*: MajMode ()) (Rec (SD MajMode VII MinClass))) (CEq Dom_D_8_bor_ (:*: mode_a2D2U ()) (:*: MajMode ()) (Rec DMinBorrow))) (:+: (CEq Dom_Dm_4_ (:*: mode_a2D2U ()) (:*: MinMode ()) (Rec (SD MinMode VIIb MajClass))) (CEq Dom_Dm_8_bor_ (:*: mode_a2D2U ()) (:*: MinMode ()) (Rec DMajBorrow))))
data SDom_S_1_par_
data SDom_S_2_par_
data SDom_S_3_
data SDom_S_3_bls_
data SDom_S_4_
data SDom_S_7_
data SDom_S_5_par_
data SDom_S_9_bor_
data SDom_Sm_3_
data SDom_Sm_4_
data SDom_Sm_7_
data SDom_Sm_5_par_
data SDom_Sm_9_bor_
data SDom_Sm_6_
type RepSDom_ mode_a2D2Q = :+: (:+: (:+: (CEq SDom_S_1_par_ () () (Rec (SD mode_a2D2Q II MinClass))) (:+: (CEq SDom_S_2_par_ () () (:*: (Rec (SD mode_a2D2Q II DomClass)) (Rec (Final II MinClass)))) (CEq SDom_S_3_ (:*: mode_a2D2Q ()) (:*: MajMode ()) (Rec (SD MajMode IV MajClass))))) (:+: (:+: (CEq SDom_S_3_bls_ () () (Rec (Final IV DomClass))) (CEq SDom_S_4_ (:*: mode_a2D2Q ()) (:*: MajMode ()) (:*: (Rec (SD MajMode III MinClass)) (Rec (Final IV MajClass))))) (:+: (CEq SDom_S_7_ (:*: mode_a2D2Q ()) (:*: MajMode ()) (:*: (Rec (SD MajMode III MinClass)) (Rec (Final II MinClass)))) (CEq SDom_S_5_par_ (:*: mode_a2D2Q ()) (:*: MajMode ()) (Rec (SD MajMode VI MinClass)))))) (:+: (:+: (CEq SDom_S_9_bor_ (:*: mode_a2D2Q ()) (:*: MajMode ()) (Rec SMinBorrow)) (:+: (CEq SDom_Sm_3_ (:*: mode_a2D2Q ()) (:*: MinMode ()) (Rec (SD MinMode IV MinClass))) (CEq SDom_Sm_4_ (:*: mode_a2D2Q ()) (:*: MinMode ()) (:*: (Rec (SD MinMode IIIb MajClass)) (Rec (Final IV MinClass)))))) (:+: (:+: (CEq SDom_Sm_7_ (:*: mode_a2D2Q ()) (:*: MinMode ()) (:*: (Rec (SD MinMode IIIb MajClass)) (Rec (Final II MinClass)))) (CEq SDom_Sm_5_par_ (:*: mode_a2D2Q ()) (:*: MinMode ()) (Rec (SD MinMode VIb MajClass)))) (:+: (CEq SDom_Sm_9_bor_ (:*: mode_a2D2Q ()) (:*: MinMode ()) (Rec SMajBorrow)) (CEq SDom_Sm_6_ (:*: mode_a2D2Q ()) (:*: MinMode ()) (Rec (SD MinMode IIb MajClass))))))
data TMinBorrow_Tm_21_bor_
type RepTMinBorrow_ = CEq TMinBorrow_Tm_21_bor_ () () (Rec (SD MinMode I MinClass))
data DMinBorrow_Dm_24_bor_
type RepDMinBorrow_ = CEq DMinBorrow_Dm_24_bor_ () () (Rec (SD MinMode VIIb MajClass))
data SMinBorrow_Sm_20_bor_
data SMinBorrow_Sm_22_bor_
type RepSMinBorrow_ = :+: (CEq SMinBorrow_Sm_20_bor_ () () (Rec (SD MinMode IV MinClass))) (CEq SMinBorrow_Sm_22_bor_ () () (Rec (SD MinMode IIb MajClass)))
data TMajBorrow_T_21_bor_
type RepTMajBorrow_ = CEq TMajBorrow_T_21_bor_ () () (Rec (SD MajMode I MajClass))
data DMajBorrow_D_24_bor_
type RepDMajBorrow_ = CEq DMajBorrow_D_24_bor_ () () (Rec (SD MajMode VII MinClass))
data SMajBorrow_S_20_bor_
type RepSMajBorrow_ = CEq SMajBorrow_S_20_bor_ () () (Rec (SD MajMode IV MajClass))
instance [overlap ok] IsLocationUpdatedBy Int ChordToken
instance [overlap ok] GTree SMajBorrow
instance [overlap ok] GTree DMajBorrow
instance [overlap ok] GTree TMajBorrow
instance [overlap ok] GTree SMinBorrow
instance [overlap ok] GTree DMinBorrow
instance [overlap ok] GTree TMinBorrow
instance [overlap ok] GTree (SDom mode0)
instance [overlap ok] GTree (Dom mode0)
instance [overlap ok] GTree (Ton mode0)
instance [overlap ok] GTree (Phrase mode0)
instance [overlap ok] ParseG (SD MajMode IV MajClass) => ParseG SMajBorrow
instance [overlap ok] ParseG (SD MajMode VII MinClass) => ParseG DMajBorrow
instance [overlap ok] ParseG (SD MajMode I MajClass) => ParseG TMajBorrow
instance [overlap ok] (ParseG (SD MinMode IV MinClass), ParseG (SD MinMode IIb MajClass)) => ParseG SMinBorrow
instance [overlap ok] ParseG (SD MinMode VIIb MajClass) => ParseG DMinBorrow
instance [overlap ok] ParseG (SD MinMode I MinClass) => ParseG TMinBorrow
instance [overlap ok] (ParseG (SD MinMode IV MinClass), ParseG (SD MinMode IIIb MajClass), ParseG (Final IV MinClass), ParseG (Final II MinClass), ParseG (SD MinMode VIb MajClass), ParseG SMajBorrow, ParseG (SD MinMode IIb MajClass)) => ParseG (SDom MinMode)
instance [overlap ok] (ParseG (SD MajMode IV MajClass), ParseG (SD MajMode III MinClass), ParseG (Final IV MajClass), ParseG (Final II MinClass), ParseG (SD MajMode VI MinClass), ParseG SMinBorrow) => ParseG (SDom MajMode)
instance [overlap ok] (ParseG (SD MinMode VIIb MajClass), ParseG DMajBorrow) => ParseG (Dom MinMode)
instance [overlap ok] (ParseG (SD MajMode VII MinClass), ParseG DMinBorrow) => ParseG (Dom MajMode)
instance [overlap ok] (ParseG (SD MinMode I MinClass), ParseG TMajBorrow) => ParseG (Ton MinMode)
instance [overlap ok] (ParseG (Final I MajClass), ParseG TMinBorrow) => ParseG (Ton MajMode)
instance [overlap ok] (ParseG (Ton mode0), ParseG (Dom mode0)) => ParseG (Phrase mode0)
instance [overlap ok] Representable SMajBorrow
instance [overlap ok] Constructor SMajBorrow_S_20_bor_
instance [overlap ok] Representable DMajBorrow
instance [overlap ok] Constructor DMajBorrow_D_24_bor_
instance [overlap ok] Representable TMajBorrow
instance [overlap ok] Constructor TMajBorrow_T_21_bor_
instance [overlap ok] Representable SMinBorrow
instance [overlap ok] Constructor SMinBorrow_Sm_22_bor_
instance [overlap ok] Constructor SMinBorrow_Sm_20_bor_
instance [overlap ok] Representable DMinBorrow
instance [overlap ok] Constructor DMinBorrow_Dm_24_bor_
instance [overlap ok] Representable TMinBorrow
instance [overlap ok] Constructor TMinBorrow_Tm_21_bor_
instance [overlap ok] Representable (SDom mode0)
instance [overlap ok] Constructor SDom_Sm_6_
instance [overlap ok] Constructor SDom_Sm_9_bor_
instance [overlap ok] Constructor SDom_Sm_5_par_
instance [overlap ok] Constructor SDom_Sm_7_
instance [overlap ok] Constructor SDom_Sm_4_
instance [overlap ok] Constructor SDom_Sm_3_
instance [overlap ok] Constructor SDom_S_9_bor_
instance [overlap ok] Constructor SDom_S_5_par_
instance [overlap ok] Constructor SDom_S_7_
instance [overlap ok] Constructor SDom_S_4_
instance [overlap ok] Constructor SDom_S_3_bls_
instance [overlap ok] Constructor SDom_S_3_
instance [overlap ok] Constructor SDom_S_2_par_
instance [overlap ok] Constructor SDom_S_1_par_
instance [overlap ok] Representable (Dom mode0)
instance [overlap ok] Constructor Dom_Dm_8_bor_
instance [overlap ok] Constructor Dom_Dm_4_
instance [overlap ok] Constructor Dom_D_8_bor_
instance [overlap ok] Constructor Dom_D_4_
instance [overlap ok] Constructor Dom_D_3_
instance [overlap ok] Constructor Dom_D_2_
instance [overlap ok] Constructor Dom_D_1_
instance [overlap ok] Representable (Ton mode0)
instance [overlap ok] Constructor Ton_Tm_6_bor_
instance [overlap ok] Constructor Ton_Tm_1_
instance [overlap ok] Constructor Ton_T_6_bor_
instance [overlap ok] Constructor Ton_T_4_bls_
instance [overlap ok] Constructor Ton_T_1_
instance [overlap ok] Constructor Ton_T_0_
instance [overlap ok] Representable (Phrase mode0)
instance [overlap ok] Constructor Phrase_PD_
instance [overlap ok] Constructor Phrase_PT_
instance [overlap ok] GetDegree (Surface_Chord (MinThird deg) DimClass n) => GetDegree (Surface_Chord deg clss (Su n))
instance [overlap ok] GetDegree (Surface_Chord deg clss Ze)
instance [overlap ok] GetDegree (Base_Final deg clss n)
instance [overlap ok] GetDegree (Base_Final deg clss Ze)
instance [overlap ok] GetDegree (Base_SD deg clss n)
instance [overlap ok] (GetDegree (Surface_Chord (MinThird deg) DimClass n), GTree (Surface_Chord (MinThird deg) DimClass n)) => GTree (Surface_Chord deg clss (Su n))
instance [overlap ok] GTree (Surface_Chord deg clss Ze)
instance [overlap ok] (GetDegree (Base_Final (Tritone deg) DomClass n), GetDegree (Base_Final (IIbDim deg) DimClass n), GTree (FinalDimTrans deg clss), GTree (Base_Final (Tritone deg) DomClass n), GTree (Base_Final (IIbDim deg) DimClass n)) => GTree (Base_Final deg clss (Su n))
instance [overlap ok] GTree (Base_Final deg clss Ze)
instance [overlap ok] (GTree (Base_SD (VDom deg) DomClass n), GTree (Base_SD (DiatV deg) MinClass n), GTree (Base_SD (DiatVM deg) MajClass n), GTree (Base_SD (VMin deg) MinClass n), GTree (Base_SD deg clss n), GTree (Base_Final deg clss n)) => GTree (Base_SD deg clss (Su n))
instance [overlap ok] GTree (Base_SD deg clss Ze)
instance [overlap ok] GTree Piece
instance [overlap ok] (ToDegree deg, ToClass clss) => ParseG (Surface_Chord deg clss (Su n))
instance [overlap ok] ParseG (Surface_Chord deg clss Ze)
instance [overlap ok] (ParseG (FinalDimTrans deg DomClass), ParseG (FinalDimTrans deg MinClass), ParseG (Base_Final (Tritone deg) DomClass n), ParseG (Base_Final (IIbDim deg) DimClass n)) => ParseG (Base_Final deg DomClass (Su n))
instance [overlap ok] ParseG (FinalDimTrans deg clss) => ParseG (Base_Final deg clss (Su n))
instance [overlap ok] ParseG (Base_Final deg clss Ze)
instance [overlap ok] (ToDegree (VDom deg), ParseG (Base_SD (VDom deg) DomClass n), ParseG (Base_SD deg DimClass n), ParseG (TritMinVSub deg DimClass)) => ParseG (Base_SD deg DimClass (Su n))
instance [overlap ok] (ToDegree (VMin deg), ToDegree (VDom deg), ParseG (Base_SD (VDom deg) DomClass n), ParseG (Base_SD (VMin deg) MinClass n), ParseG (Base_SD deg DomClass n), ParseG (TritMinVSub deg DomClass)) => ParseG (Base_SD deg DomClass (Su n))
instance [overlap ok] (ToDegree (DiatVM deg), ToDegree (VDom deg), ParseG (Base_SD (VDom deg) DomClass n), ParseG (Base_SD (DiatVM deg) MajClass n), ParseG (Base_SD deg MajClass n), ParseG (TritMinVSub deg MajClass)) => ParseG (Base_SD deg MajClass (Su n))
instance [overlap ok] (ToDegree (DiatV deg), ToDegree (VDom deg), ParseG (Base_SD (VDom deg) DomClass n), ParseG (Base_SD (DiatV deg) MinClass n), ParseG (Base_SD (DiatVM deg) MajClass n), ParseG (Base_SD deg MinClass n), ParseG (TritMinVSub deg MinClass)) => ParseG (Base_SD deg MinClass (Su n))
instance [overlap ok] ParseG (Base_SD deg clss Ze)

module HarmTrace.Models.Pop.Main
pPop :: Key -> PMusic [Piece]


-- | Summary: The jazz parser
module HarmTrace.Models.Jazz.Main
pJazz :: Key -> PMusic [Piece]


-- | Summary: All the models
module HarmTrace.Models.Models
data Grammar :: * -> *
Jazz :: Grammar Piece
Pop :: Grammar Piece
data GrammarEx
GrammarEx :: Grammar g -> GrammarEx
instance Eq GrammarEx
instance Show GrammarEx

module HarmTrace.HarmTrace
data PPOption
RemoveInsertions :: PPOption
RemovePDPT :: PPOption
MergeDelChords :: PPOption
ExpandChordDurations :: PPOption
data Grammar :: * -> *
Jazz :: Grammar Piece
Pop :: Grammar Piece
data GrammarEx
GrammarEx :: Grammar g -> GrammarEx
data ParseResult a
ParseResult :: Key -> [ChordLabel] -> [a] -> Tree HAn -> Int -> [Error LineColPos] -> [Error Int] -> [PPOption] -> ParseResult a
parsedKey :: ParseResult a -> Key
parsedChordLabels :: ParseResult a -> [ChordLabel]
parsedPiece :: ParseResult a -> [a]
pieceTreeHAn :: ParseResult a -> Tree HAn
nrAmbTrees :: ParseResult a -> Int
tokenizerErrors :: ParseResult a -> [Error LineColPos]
pieceErrors :: ParseResult a -> [Error Int]
postProcessing :: ParseResult a -> [PPOption]
gt2Piece :: GTree g => Grammar g -> String -> String -> ParseResult g
string2Piece :: Grammar g -> String -> ParseResult g
postProc :: GTree g => [PPOption] -> ParseResult g -> ParseResult g


-- | Summary: Several constants used everywhere
module Constants

-- | Automatically generated
vERSION :: String

-- | The cutOffProbability is the value that determines the length of the
--   probChord list (a sorted list with normalised distances to the chroma
--   vector)
cutOffProbability :: NumData

-- | The maximum number if chords (the lenght) of a chord candidate list
maxProbChordListLength :: Int

-- | The maximum size of a list of chord candidate lists (of which all
--   possible combinations will be parsed). If, in the segmentation
--   procedure, this threshold is crossed an 'emergency split' will be made
--   (see Harmtrace.Audio.Annotate.emergencySplit for details)
maxSegmentSize :: Int

-- | Chord candidate list segments can contain long and short chord
--   candidate lists. This strongly influences the number of considered
--   chord sequence combinations, i.e. the LProductSize. If the number of
--   possible combinations becomes greater than the <a>maxLProductSize</a>
--   also an 'emergency split' will be made, similar to maxSegmentSize.
maxLProductSize :: Int

-- | The sample rate used in a normal (non-visual) comparison (in seconds).
evaluationSampleRate :: NumData

-- | The sample rate used when visually comparing a chord annotation with a
--   ground-truth annotation. Often a higher sample rate is preferred.
--   Although one uses precision, the visual result is easier to read.
displaySampleRate :: NumData

-- | Before feature extraction, all audio is downsampled to
--   <a>outputSampleRate</a> Hz. N.B. If the sample rate is changed the
--   VAMP plugin transforms should be updated accordingly (see
--   <tt>beat</tt>, <tt>chroma</tt>, <tt>key</tt>).
outputSampleRate :: Int

-- | Before feature extraction, all audio is converted to contain
--   <a>outputBitsPerSample</a> bits per sample.
outputBitsPerSample :: Int

-- | Before feature extraction, all audio is converted to contain a fixed
--   number of channels, e.g. 1 for mono or 2 for stereo.
outputNrOfChannels :: Int

-- | The strings that build up a audio feature file name
keyStr :: String

-- | The strings that build up a audio feature file name
chromaStr :: String

-- | The strings that build up a audio feature file name
beatStr :: String

-- | specifying the filename of the beat tracker VAMP plugin transform file
beatVampPath :: FilePath

-- | specifying the filename of the NNLS chroma VAMP plugin transform file
chromaVampPath :: FilePath

-- | specifying the filename of the key-finding chroma VAMP plugin
--   transform file
keyVampPath :: FilePath

-- | Controls whether the downsampled wav file is deleted after feature
--   extraction.
deleteDownsampledWav :: Bool

-- | Controls whether SoX is used to downsample the audio or whether the
--   audio file is passed to the sonic annotator directly. If 'downSample
--   is set to False, all paramters downsampling parameters will be ignored
--   
--   Controls whether the downsampled wav file is deleted after feature
--   extraction.
downSample :: Bool
defaultLogDir :: FilePath

-- | The default base directory is the current directory
defaultVampDir :: FilePath
defaultFeatDir :: FilePath
defaultOutDir :: FilePath

-- | By default we assume the sonic-annotator is in the path
logFileSuffix :: String

-- | By default we assume the sonic-annotator is in the path
sonicAnnotator :: String

-- | The penatly given in the cumulative key strength calculation. For
--   every beat the correlation between a Krumhansl profile and the current
--   beat synchronised chroma feature is calculated for all 24 keys at
--   every beat. An optimal path through this table can be defined as:
--   $M[i,j] = max { M[i-1,j] + K[i,j], M[i-1,j] + K[i,k] + p, } where {k
--   mid forall x : K[i,x] leq K[i,k]}$ where $p$ is the modulationPenalty,
--   i.e. the penalty for changing the key at that particular beat.
modulationPenalty :: NumData

-- | The minimal length in beats of a key segment
minModulationLength :: Int

-- | An ennumerator of determining the output format of the chords
data ChordPrintOpts
PrintMajMin :: ChordPrintOpts
PrintChordClass :: ChordPrintOpts

-- | By default we only display major and minor chords to the user (because
--   the transcription quality of these chords is better than that of the
--   chord class).
defaultChordPrinting :: ChordPrintOpts


-- | Summary: Recognise audio chroma vectors into textual chord
--   descriptions.
module HarmTrace.Audio.ChromaChord

-- | Having a matrix of beat-synchronised bass and treble chromagrams and a
--   chord dictionary, the probability of a chord sounding at a particular
--   beat is estimated by calculating the Euclidean distance between the
--   chord structures and the chroma feature. These distances are
--   calculated for every chord candidate at every beat. Next, we sort the
--   chord candidates by descending Euclidean distance. To obtain a
--   relative measure of the fit between a chord candidate and the chroma
--   vector in the range [0,1], the distances are normalised by dividing
--   them by distance of the best matching chord candidate.
createChordRanks :: [BeatChroma] -> [TimedData [ProbChord]]

-- | Synchronises the <a>ChordinoData</a> with the list of beats by
--   grouping the <tt>ChordinoLines</tt> of the <a>ChordinoData</a> in
--   separate lists.
beatSync :: BarTimeTrackData -> [ChordinoLine] -> [BeatChroma]
meanBeatSyncVectors :: [BeatChroma] -> [TimedData (Vector NumData)]

-- | Merges chord segments, adding a bias toward merging at the first and
--   the third <a>Beat</a>
mergeByOneAndThree :: [TimedData [ProbChord]] -> [TimedData [ProbChord]]


-- | Summary: Low-processing of chroma features for key-finding
module HarmTrace.Audio.ChromaKey

-- | Calculates the beat synchronised key strenght for all 24 keys (ordered
--   by <tt>KeyMap</tt>).
beatSyncKeyStrength :: BarTimeTrackData -> ChordinoData -> [TimedData [NumData]]

-- | A key chroma map using a circle of fifths based ordering.
keyMap :: [Key]


-- | Summary: Key-finding from musical audio.
module HarmTrace.Audio.Key

-- | Returns a <a>Key</a> key assignment, given <a>Beat</a> and chroma
--   information. N.B. The beats and chroma do not have to be synchronised,
--   they will be sychronised in the process of finding the key (see
--   <a>ChromaKey</a> and <a>BeatSync</a>)
getBeatSyncKeyFromChroma :: AudioFeat -> [TimedData Key]


-- | Summary: Combining low-level features (VAMP plug-ins) with high-level
--   knowledge (the HarmTrace harmony model)
module HarmTrace.Audio.Annotate

-- | MPTrEE (Model Propelled Transcription of Euphonic Enitities): a
--   sophisticated, harmony and beat informed chord annotator
mptreeAnnotator :: GrammarEx -> Maybe [TimedData Key] -> AudioFeat -> ChordAnnotation

-- | Creates an annotation out of a Chord candidate list by just picking
--   the first chord. This annotator does smart grouping (see
--   <a>mergeByBeat</a>).
groupAnnotator :: GrammarEx -> Maybe [TimedData Key] -> AudioFeat -> ChordAnnotation

-- | The most simple annotator, no grouping, no matching, just pick the
--   best matching chord
simpleAnnotator :: GrammarEx -> Maybe [TimedData Key] -> AudioFeat -> ChordAnnotation
mptreeAnnotatorSTG :: GrammarEx -> Maybe [TimedData Key] -> AudioFeat -> ChordAnnotation

-- | prints Segmetation statistics
putSegStats :: Maybe [TimedData Key] -> AudioFeat -> IO ()

-- | preprocesses the raw audio data before using chord harmony model based
--   chord selection. First, the beats and chroma are synchronised. Second,
--   chord candidate lists are created. Third, smart, beat informed
--   grouping of the chord candidates is performed. Fourth, the chord
--   candidate lists are grouped in segments based on the key (obtained as
--   provided by the user or as derived from the audio data). Last, the
--   chord candidate lists are further segmented based on the occurrences
--   of I and V chords.
preProcessData :: Maybe [TimedData Key] -> AudioFeat -> [ProbChordSeg]


-- | Summary: A module for evaluating chord and key annotations
module HarmTrace.Audio.Evaluation

-- | Calculates the relative correct overlap, which is the recall of
--   matching frames, and defined as the nr of matching frames (sampled at
--   an 10 milisecond interval) divided by all frames.
relCorrectOverlap :: (a -> a -> Bool) -> [TimedData a] -> [TimedData a] -> Double

-- | calculates the maximal achievable score given a ground truth
--   annotation and a chord candidate list.
achievScore :: [TimedData ChordLabel] -> [TimedData [ChordLabel]] -> Double
chordChangeRatio :: (ChordLabel -> ChordLabel -> Bool) -> [TimedData ChordLabel] -> [TimedData ChordLabel] -> Double

-- | The <a>chordChangeRatio</a> is optimal if it is one, but it can be
--   larger or smaller than 1. Therefore, calculating the average blurs the
--   actual result. <a>avgDistToOne</a> takes the absolute difference to
--   1.0 and averages these for a list of Doubles.
avgDistToOne :: [Double] -> Double

-- | Returns True if both <a>ChordLabel</a>s are equal at the triad level:
--   they are either moth major or both minor. <a>None Chords</a> match
--   only with other <a>None Chords</a> and with nothing else
chordTriadEq :: ChordLabel -> ChordLabel -> Bool

-- | Returns True if both <a>ChordLabel</a>s are equal at the chord class
--   level: A chord is classified as being major, minor, dominant seventh,
--   or dimished seventh. <a>chordClassEq</a> only returns True if the
--   class of compared chords is the same. <a>None Chords</a> match only
--   with other None Chords and with nothing else
chordClassEq :: ChordLabel -> ChordLabel -> Bool

-- | Returns True if the <a>Root</a>s of the <a>Chord</a>s are equal, but
--   the one chord is Major and the other chord is Minor.
majMinEq :: ChordLabel -> ChordLabel -> Bool

-- | does the same thing as relCorrectOverlap, but it also prints the
--   chords and uses a lower sample rate. N.B. the number output by
--   <tt>printRelCorrectOverlap</tt> might differ from the output of
--   <a>relCorrectOverlap</a>, because a different sample rate might be
--   used (see <tt>Constants</tt>).
printChordRCO :: (AudioFeat -> ChordAnnotation) -> [TimedData Key] -> AudioFeat -> [TimedData ChordLabel] -> IO Double

-- | Calculates the relative correct overlap, which is the recall of
--   matching frames, and defined as the nr of matching frames (sampled at
--   an interval set in <a>Constants</a> divided by all frames. This
--   functions difers from <a>relCorrectOverlap</a> in that it uses an
--   equality function that is in IO.
printRCO :: (a -> a -> IO (Bool)) -> [TimedData a] -> [TimedData a] -> IO (Double)

-- | Given a chord annotation sample the chord label at every 10 ms
sample :: [TimedData a] -> [a]
