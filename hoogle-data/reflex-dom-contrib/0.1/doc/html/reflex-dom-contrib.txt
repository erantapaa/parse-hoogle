-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A playground for experimenting with infrastructure and common code for reflex applications
--   
--   This library is intended to be a public playground for developing
--   infrastructure, higher level APIs, and widget libraries for reflex FRP
--   applications. This library is experimental and does not have a strong
--   commitment to preserving backwards compatibility. It will not have a
--   high bar for the quality of contributions. That being said, we prefer
--   commits that add new things rather than changing existing ones. If you
--   are wondering if there is some convenience code or abstractions and
--   you don't find them in reflex or reflex-dom, look here and see if
--   anyone has already done it. If you have general-purpose reflex code
--   that you find useful that is not already here, add it to this
--   repository and send us a pull request.
@package reflex-dom-contrib
@version 0.1


-- | Misc reflex-dom helper functions.
module Reflex.Dom.Contrib.Utils

-- | Convenient function that pops up a javascript confirmation dialog box
--   when an event fires with a message to display.
confirmEvent :: MonadWidget t m => (a -> String) -> Event t a -> m (Event t a)

-- | Gets the current path of the DOM Window (i.e., the contents of the
--   address bar after the host, beginning with a "/").
--   <a>https://developer.mozilla.org/en-US/docs/Web/API/Location</a>
getWindowLocationPath :: DOMWindow -> IO String

-- | Pushes a new URL to the window history.
windowHistoryPushState :: String -> IO ()

-- | A common form for widgetHold calls that mirrors the pattern seen in
--   hold and holdDyn.
widgetHoldHelper :: MonadWidget t m => (a -> m b) -> a -> Event t a -> m (Dynamic t b)

-- | Simple debug function that prints a message on postBuild.
putDebugLn :: MonadWidget t m => String -> m ()

-- | Prints a string when an event fires. This differs slightly from
--   traceEvent because it will print even if the event is otherwise
--   unused.
putDebugLnE :: MonadWidget t m => Event t a -> (a -> String) -> m ()


-- | An API for constructing a tab bar where the list of tabs in the bar is
--   determined dynamically.
module Reflex.Dom.Contrib.Widgets.DynTabs
class Eq tab => Tab m tab
tabIndicator :: Tab m tab => tab -> m ()
tabBar :: (MonadWidget t m, Tab m tab) => String -> tab -> [tab] -> Event t [tab] -> Event t tab -> m (Dynamic t tab)
tabPane :: (MonadWidget t m, Eq tab) => Dynamic t tab -> tab -> m a -> m a

-- | Sets the "active" class
activeHelper :: MonadWidget t m => String -> m () -> Dynamic t Bool -> m (Event t ())


-- | Convenience functions for dealing with XMLHttpRequest.
module Reflex.Dom.Contrib.Xhr

-- | URL encodes a map of key-value pairs.
formEncode :: Map String ByteString -> String

-- | Form encodes a JSON object.
formEncodeJSON :: ToJSON a => a -> String

-- | Convenience function for constructing a POST request.
toPost :: String -> String -> XhrRequest

-- | This is the foundational primitive for the XHR API because it gives
--   you full control over request generation and response parsing and also
--   allows you to match things that generated the request with their
--   corresponding responses.
performAJAX :: (MonadWidget t m) => (a -> XhrRequest) -> (XhrResponse -> b) -> Event t a -> m (Event t (a, b))

-- | Performs an async XHR taking a JSON object as input and another JSON
--   object as output.
performJsonAjax :: (MonadWidget t m, ToJSON a, FromJSON b) => Event t (String, a) -> m (Event t (a, Maybe b))

module Reflex.Dom.Contrib.Pagination
pqSearchString :: Lens' PaginationQuery String
pqOffset :: Lens' PaginationQuery Word64
pqLimit :: Lens' PaginationQuery Word64
prTotalCount :: Lens' (PaginationResults a_apzv) Word64
prTimestamp :: Lens' (PaginationResults a_apzv) UTCTime
prResults :: Lens (PaginationResults a_apzv) (PaginationResults a_aq7X) [a_apzv] [a_aq7X]
prOffset :: Lens' (PaginationResults a_apzv) Word64
pvValue :: Lens (CacheVal a_aq8y) (CacheVal a_aqhy) a_aq8y a_aqhy
pvShouldStore :: Lens' (CacheVal a_aq8y) Bool
pvQuery :: Lens' (CacheVal a_aq8y) PaginationQuery

-- | General data structure needed for running queries with paginated
--   results.
data PaginationQuery
[PaginationQuery] :: Word64 -> Word64 -> String -> PaginationQuery
[_pqLimit] :: PaginationQuery -> Word64
[_pqOffset] :: PaginationQuery -> Word64
[_pqSearchString] :: PaginationQuery -> String

-- | Data structure wrapping results.
data PaginationResults a
[PaginationResults] :: Word64 -> Word64 -> UTCTime -> [a] -> PaginationResults a
[_prOffset] :: PaginationResults a -> Word64
[_prTotalCount] :: PaginationResults a -> Word64
[_prTimestamp] :: PaginationResults a -> UTCTime
[_prResults] :: PaginationResults a -> [a]
type PaginationCache k v = Map k [CacheVal v]
type PaginationInput k = (k, PaginationQuery)
type PaginationOutput k v = (k, CacheVal v)

-- | Along with the query results we also need to store the PaginationQuery
--   structure that generated it as well as a flag indicating whether this
--   data should be stored in the cache. This prevents results that are
--   sub-searches of a previous search from overwriting the results of a
--   more general query.
data CacheVal a
[CacheVal] :: PaginationQuery -> Bool -> a -> CacheVal a
[_pvQuery] :: CacheVal a -> PaginationQuery
[_pvShouldStore] :: CacheVal a -> Bool
[_pvValue] :: CacheVal a -> a
data PQParams
[PQParams] :: Int -> Int -> PQParams

-- | The max number of queries to cache
[pqpMaxCacheSize] :: PQParams -> Int

-- | The number of queries to discard when we reach the size limit
[pqpPruneAmount] :: PQParams -> Int

-- | Paginated querying with built-in search and results caching.
paginatedQuery :: (MonadWidget t m, Show k, Ord k, FromJSON a) => PQParams -> (String -> a -> Bool) -> String -> Event t (Map String ByteString, PaginationInput k) -> m (Event t (PaginationResults a))
addToCache :: Ord k => PQParams -> PaginationOutput k (PaginationResults v) -> PaginationCache k (PaginationResults v) -> PaginationCache k (PaginationResults v)

-- | Prunes the PaginationCache of the oldest n entries. This is not the
--   oldest (k,v) pairs. It is the oldest vs out of all the (k,[v]) pairs.
prune :: Ord k => Int -> PaginationCache k (PaginationResults v) -> PaginationCache k (PaginationResults v)

-- | Checks a cache and makes a request to the supplied URL if the cached
--   data cannot be used to serve the results of the current requested
--   query.
cachedQuery :: (MonadWidget t m, Show k, Ord k, FromJSON a) => (String -> a -> Bool) -> String -> PaginationCache k (PaginationResults a) -> (Map String ByteString, PaginationInput k) -> m (Event t (PaginationOutput k (PaginationResults a)))

-- | Checks whether a previous cached search string is a substring of the
--   current search string. In this case we don't need to requery the
--   server.
isSubSearch :: PaginationQuery -> CacheVal (PaginationResults a) -> Bool
instance Ord PQParams
instance Show PQParams
instance Eq PQParams
instance Default PQParams
instance Ord a => Ord (CacheVal a)
instance Show a => Show (CacheVal a)
instance Eq a => Eq (CacheVal a)
instance FromJSON a => FromJSON (PaginationResults a)
instance ToJSON a => ToJSON (PaginationResults a)
instance Ord a => Ord (PaginationResults a)
instance Read a => Read (PaginationResults a)
instance Show a => Show (PaginationResults a)
instance Eq a => Eq (PaginationResults a)
instance Default PaginationQuery
instance FromJSON PaginationQuery
instance ToJSON PaginationQuery
instance Ord PaginationQuery
instance Read PaginationQuery
instance Show PaginationQuery
instance Eq PaginationQuery


-- | API for dealing with keyboard events.
module Reflex.Dom.Contrib.KeyEvent

-- | Data structure with the details of key events.
data KeyEvent
[KeyEvent] :: Int -> Bool -> Bool -> KeyEvent
[keKeyCode] :: KeyEvent -> Int
[keCtrl] :: KeyEvent -> Bool
[keShift] :: KeyEvent -> Bool

-- | Convenience constructor for KeyEvent with no modifiers pressed.
key :: Char -> KeyEvent

-- | Set the shift modifier of a KeyEvent.
shift :: KeyEvent -> KeyEvent

-- | Set the ctrl modifier of a KeyEvent.
ctrlKey :: Char -> KeyEvent
getKeyEvent :: ReaderT (t, UIEvent) IO KeyEvent
instance Ord KeyEvent
instance Eq KeyEvent
instance Read KeyEvent
instance Show KeyEvent

module Reflex.Contrib.Utils

-- | A small amount of convenience for return ().
end :: Monad m => m ()

-- | fmapMaybe twice
fmapMaybe2 :: Reflex t => Event t (Maybe (Maybe a)) -> Event t a

-- | Construct an event with a tuple of (current,updated).
attachDynSelf :: Reflex t => Dynamic t a -> Event t (a, a)

-- | Partitions an event into a pair of events that fire when the predicate
--   function evaluates to True and False respectively.
partitionEvent :: Reflex t => (a -> Bool) -> Event t a -> (Event t a, Event t a)

-- | Sometimes you end up with a Dynamic t Foo where Foo contains an Event
--   field. This function collapses the two levels of Dynamic Event into
--   just an Event.
extractEvent :: (Reflex t, MonadHold t m) => (a -> Event t b) -> Dynamic t a -> m (Event t b)

-- | Sometimes you end up with a Dynamic t Foo where Foo contains a Dynamic
--   field. This function collapses the two levels of Dynamic Dynamic into
--   a single Dynamic.
extractDyn :: (Reflex t, MonadHold t m) => (a -> Dynamic t b) -> Dynamic t a -> m (Dynamic t b)


-- | Infrastructure common to a wide variety of widgets. WidgetConfig holds
--   the core inputs needed by most widgets, while HtmlWidget holds the
--   core Dynamics and Events returned by most widgets. Encapsulating
--   widget inputs and outputs this way makes it easier to compose and
--   transform widgets.
module Reflex.Dom.Contrib.Widgets.Common
widgetConfig_setValue :: Lens' (WidgetConfig t_aBXR a_aBXS) (Event t_aBXR a_aBXS)
widgetConfig_initialValue :: Lens' (WidgetConfig t_aBXR a_aBXS) a_aBXS
widgetConfig_attributes :: Lens' (WidgetConfig t_aBXR a_aBXS) (Dynamic t_aBXR (Map String String))
hwidget_value :: Lens' (HtmlWidget t_aC2n a_aC2o) (Dynamic t_aC2n a_aC2o)
hwidget_keyup :: Lens' (HtmlWidget t_aC2n a_aC2o) (Event t_aC2n Int)
hwidget_keypress :: Lens' (HtmlWidget t_aC2n a_aC2o) (Event t_aC2n Int)
hwidget_keydown :: Lens' (HtmlWidget t_aC2n a_aC2o) (Event t_aC2n Int)
hwidget_hasFocus :: Lens' (HtmlWidget t_aC2n a_aC2o) (Dynamic t_aC2n Bool)
hwidget_change :: Lens' (HtmlWidget t_aC2n a_aC2o) (Event t_aC2n a_aC2o)

-- | Generic config structure common to most widgets. The attributes field
--   may not be used for all widgets, but in that case it can just be
--   ignored. We may want to change this in the future, but it seems like a
--   reasonable start for now.
data WidgetConfig t a
[WidgetConfig] :: Event t a -> a -> Dynamic t (Map String String) -> WidgetConfig t a
[_widgetConfig_setValue] :: WidgetConfig t a -> Event t a
[_widgetConfig_initialValue] :: WidgetConfig t a -> a
[_widgetConfig_attributes] :: WidgetConfig t a -> Dynamic t (Map String String)

-- | A general-purpose widget return value.
data HtmlWidget t a
[HtmlWidget] :: Dynamic t a -> Event t a -> Event t Int -> Event t Int -> Event t Int -> Dynamic t Bool -> HtmlWidget t a

-- | The authoritative value for this widget.
[_hwidget_value] :: HtmlWidget t a -> Dynamic t a

-- | Event that fires when the widget changes internally (not via a
--   setValue event).
[_hwidget_change] :: HtmlWidget t a -> Event t a
[_hwidget_keypress] :: HtmlWidget t a -> Event t Int
[_hwidget_keydown] :: HtmlWidget t a -> Event t Int
[_hwidget_keyup] :: HtmlWidget t a -> Event t Int
[_hwidget_hasFocus] :: HtmlWidget t a -> Dynamic t Bool

-- | Generalized form of many widget functions.
type GWidget t m a = WidgetConfig t a -> m (HtmlWidget t a)

-- | HtmlWidget with a constant value that never fires any events and does
--   not have focus.
constWidget :: Reflex t => a -> HtmlWidget t a

-- | We can't make a Functor instance for HtmlWidget until Dynamic gets a
--   Functor instance. So until then, this will have to do.
mapWidget :: MonadWidget t m => (a -> b) -> HtmlWidget t a -> m (HtmlWidget t b)

-- | Combine function does the expected thing for _value and _change and
--   applies leftmost to each of the widget events.
combineWidgets :: MonadWidget t m => (a -> b -> c) -> HtmlWidget t a -> HtmlWidget t b -> m (HtmlWidget t c)

-- | Combines multiple widgets over a Monoid operation.
wconcat :: (MonadWidget t m, Foldable f, Monoid a) => f (HtmlWidget t a) -> m (HtmlWidget t a)

-- | Convenience for extracting HtmlWidget from a Dynamic.
extractWidget :: MonadWidget t m => Dynamic t (HtmlWidget t a) -> m (HtmlWidget t a)

-- | Input widget for datetime values.
dateTimeWidget :: (MonadWidget t m) => GWidget t m (Maybe UTCTime)

-- | Input widget for dates.
dateWidget :: (MonadWidget t m) => GWidget t m (Maybe Day)

-- | HtmlWidget version of reflex-dom's checkbox.
htmlCheckbox :: MonadWidget t m => GWidget t m Bool

-- | HtmlWidget version of reflex-dom's textInput.
htmlTextInput :: MonadWidget t m => String -> GWidget t m String

-- | HtmlWidget version of reflex-dom's textInput that also returns the
--   HTMLInputElement.
htmlTextInput' :: MonadWidget t m => String -> WidgetConfig t String -> m (HTMLInputElement, HtmlWidget t String)

-- | NOTE: You should probably not use this function with string types
--   because the Show instance will quote strings.
readableWidget :: (MonadWidget t m, Show a, Readable a) => GWidget t m (Maybe a)

-- | Widget that parses its input to a Double.
doubleWidget :: (MonadWidget t m) => GWidget t m (Maybe Double)

-- | Widget that parses its input to an Integer.
integerWidget :: (MonadWidget t m) => GWidget t m (Maybe Integer)

-- | Widget that parses its input to an Int.
intWidget :: (MonadWidget t m) => GWidget t m (Maybe Int)

-- | Returns an event that fires when the widget loses focus or enter is
--   pressed.
blurOrEnter :: Reflex t => HtmlWidget t a -> Event t a

-- | Like readableWidget but only generates change events on blur or when
--   enter is pressed.
inputOnEnter :: MonadWidget t m => (WidgetConfig t a -> m (HtmlWidget t a)) -> WidgetConfig t a -> m (Dynamic t a)

-- | A list dropdown widget.
listDropdown :: (MonadWidget t m) => Dynamic t [a] -> (a -> String) -> Dynamic t (Map String String) -> String -> m (Dynamic t (Maybe a))
instance HasValue (HtmlWidget t a)
instance (Reflex t, Default a) => Default (WidgetConfig t a)
instance HasAttributes (WidgetConfig t a)
instance HasSetValue (WidgetConfig t a)

module Reflex.Dom.Contrib.Widgets.CheckboxList

-- | Takes a list of labels to make checkboxes for and returns the labels
--   of the boxes that are checked.
checkboxList :: (MonadWidget t m, Ord a, Show a) => (a -> String) -> (String -> a -> Bool) -> Event t Bool -> Dynamic t String -> Set a -> [a] -> m (HtmlWidget t [a])

module Reflex.Contrib.Interfaces

-- | A reflex interface to maps that allows inserting and deleting multiple
--   items at a time.
data ReflexMap t k v
[ReflexMap] :: Map k v -> Event t [(k, v)] -> Event t (Set k) -> ReflexMap t k v
[rmInitialItems] :: ReflexMap t k v -> Map k v

-- | We use a list of key-value pairs here because order is important
[rmInsertItems] :: ReflexMap t k v -> Event t [(k, v)]
[rmDeleteItems] :: ReflexMap t k v -> Event t (Set k)

-- | A reflex interface to lists. It has a pure list of initial items, an
--   event for inserting multiple items, and an event for deleting multiple
--   items.
data ReflexList t v
[ReflexList] :: [v] -> Event t [v] -> Event t [v] -> ReflexList t v
[rlInitialItems] :: ReflexList t v -> [v]
[rlInsertItems] :: ReflexList t v -> Event t [v]
[rlDeleteItems] :: ReflexList t v -> Event t [v]

-- | Converts a ReflexList to a ReflexMap with integer keys.
rlist2rmap :: (Reflex t, Eq v) => ReflexList t v -> Dynamic t (Map Int v) -> ReflexMap t Int v

-- | Converts a ReflexList to a Dynamic list.
toReflexMap :: (MonadWidget t m, Eq a) => ReflexList t a -> (ReflexMap t Int a -> m (Dynamic t (Map Int a))) -> m (Dynamic t [a])

-- | Takes a set of keys and returns a function that deletes these keys
--   from a map.
rmDeleteFunc :: Ord k => Set k -> Map k v -> Map k v

-- | A generalized version of the one in reflex-dom.
selectViewListWithKey :: (MonadWidget t m, Ord k) => Dynamic t k -> Dynamic t (Map k v) -> (k -> Dynamic t v -> Dynamic t Bool -> m a) -> m (Dynamic t (Map k a))

module Reflex.Dom.Contrib.Widgets.BoundedList

-- | Implements a common use of boundedSelectList' where only the currently
--   selected item from a list is displayed. In this case a Dynamic
--   representing the current selection is used to drive insertions and
--   they are never deleted externally. Instead of returning a Map of all
--   the item results, this function only returns the result for the item
--   that is currently selected.
boundedSelectList :: (MonadWidget t m, Show k, Ord k, Show v) => Limit -> Dynamic t a -> (a -> k) -> (a -> Maybe a) -> (Event t a -> m (Event t (k, v))) -> b -> (k -> Dynamic t v -> Dynamic t Bool -> m b) -> m (Dynamic t b)

-- | A widget with generalized handling for dynamically sized lists. There
--   are many possible approaches to rendering lists that have one visible
--   current selection. One way is to keep all the items in the DOM and
--   manage the selection by managing visibility through something like
--   display:none or visibility:hidden. Another way is to only keep the
--   currently selected item in the DOM and swap it out every time the
--   selection is changed.
--   
--   The problem with keeping all items in the DOM is that this might use
--   too much memory either because there are many items or the items are
--   large. The problem with keeping only the currently selected item in
--   the DOM is that performance might be too slow if removing the old
--   item's DOM elements and building the new one takes too long.
--   
--   This widget provides a middle ground. It lets the user decide how many
--   elements are kept in the DOM at any one time and prunes the least
--   recently used items if that size is exceeded.
boundedSelectList' :: (MonadWidget t m, Show k, Ord k, Show v) => Event t (Map k v -> Map k v) -> Limit -> Dynamic t k -> ReflexMap t k v -> (k -> Dynamic t v -> Dynamic t Bool -> m a) -> m (Dynamic t (Map k a))

-- | Wraps a widget with a dynamically hidden div that uses display:none to
--   hide.
mkHiding :: (MonadWidget t m) => Map String String -> m a -> Dynamic t Bool -> m a

-- | Small helper for a common pattern that comes up with the
--   expensiveGetNew parameter to boundedSelectList.
keyToMaybe :: MonadWidget t m => (Event t a -> m (Event t (b, c))) -> Event t (Maybe a) -> m (Event t (Maybe b, c))
