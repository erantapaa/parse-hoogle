-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A simple library for creating animated ascii art on ANSI terminals.
--   
--   A simple library for creating animated ascii art on ANSI terminals.
@package haha
@version 0.3.1.1

module Graphics.Ascii.Haha.Terminal
esc :: String -> [String] -> String -> String
clearAll, clear, clearEol :: String
move :: (Integral i, Show i) => i -> i -> String
moveUp, moveForward, moveBack, moveDown :: (Integral i, Show i) => i -> String
save, load :: String
clr :: [String] -> String
fg, bg :: Color -> [String]
normal, invisible, reverse, blink, underline, standout, faint, bold :: [String] -> [String]
data Color
Black :: Color
Red :: Color
Green :: Color
Yellow :: Color
Blue :: Color
Magenta :: Color
Cyan :: Color
White :: Color
Reset :: Color
num :: Integral i => Color -> i
reset :: String
black, white, cyan, magenta, blue, yellow, green, red :: String
blackBold, whiteBold, cyanBold, magentaBold, blueBold, yellowBold, greenBold, redBold :: String
blackBg, resetBg, whiteBg, cyanBg, magentaBg, blueBg, yellowBg, greenBg, redBg :: String
bg256, fg256 :: (Integral i, Show i) => i -> [String]
x256, x256Bg, x256Bold :: (Integral i, Show i) => i -> String
width :: (Read i, Integral i) => IO i
height :: (Read i, Integral i) => IO i
geometry :: (Read i, Integral i) => IO (i, i)
instance Show Color
instance Eq Color

module Graphics.Ascii.Haha.Geometry
data Point u
Point :: u -> u -> Point u
_x :: Point u -> u
_y :: Point u -> u
data Line u
Line :: Point u -> Point u -> Line u
_a :: Line u -> Point u
_b :: Line u -> Point u
data Tri u
Tri :: (Point u) -> (Point u) -> (Point u) -> Tri u
data Poly u
Poly :: [Point u] -> Poly u
data Mesh u
Mesh :: [Tri u] -> Mesh u
data Rect u
Rect :: (Point u) -> (Point u) -> Rect u
data Circle u
Circle :: (Point u) -> u -> Circle u
data Elipse u
Elipse :: (Point u) -> u -> u -> Elipse u
class Geometry g
centroid :: (Geometry g, Ord u, Floating u) => g u -> Point u
bounds :: (Geometry g, Ord u, Floating u) => g u -> Rect u
translate :: (Geometry g, Ord u, Floating u) => u -> u -> g u -> g u
rotate :: (Geometry g, Ord u, Floating u) => u -> Point u -> g u -> g u
scale :: (Geometry g, Ord u, Floating u) => u -> Point u -> g u -> g u
outline :: Geometry g => g u -> Poly u
mesh :: Geometry g => g u -> Mesh u
discrete :: (Geometry g, RealFrac u, Integral i) => g u -> g i
rotateLocal :: (Geometry g, Ord u, Floating u) => u -> g u -> g u
centroidPoint :: Point u -> Point u
boundsPoint :: Point u -> Rect u
translatePoint :: Num u => u -> u -> Point u -> Point u
rotatePoint :: Floating u => u -> Point u -> Point u -> Point u
scalePoint :: Num u => u -> Point u -> Point u -> Point u
outlinePoint :: Point u -> Poly u
meshPoint :: Point u -> Mesh u
discretePoint :: (RealFrac u, Integral i) => Point u -> Point i
centroidLine :: Fractional u => Line u -> Point u
boundsLine :: Line u -> Rect u
translateLine :: (Ord u, Floating u) => u -> u -> Line u -> Line u
rotateLine :: (Ord u, Floating u) => u -> Point u -> Line u -> Line u
scaleLine :: (Ord u, Floating u) => u -> Point u -> Line u -> Line u
outlineLine :: Line u -> Poly u
meshLine :: Line u -> Mesh u
discreteLine :: (RealFrac u, Integral i) => Line u -> Line i
centroidTri :: (Ord u, Floating u) => Tri u -> Point u
boundsTri :: Ord u => Tri u -> Rect u
translateTri :: (Ord u, Floating u) => u -> u -> Tri u -> Tri u
rotateTri :: (Ord u, Floating u) => u -> Point u -> Tri u -> Tri u
scaleTri :: (Ord u, Floating u) => u -> Point u -> Tri u -> Tri u
outlineTri :: Tri u -> Poly u
meshTri :: Tri u -> Mesh u
discreteTri :: (RealFrac u, Integral i) => Tri u -> Tri i
centroidPoly :: Fractional u => Poly u -> Point u
boundsPoly :: Ord u => Poly u -> Rect u
translatePoly :: (Ord u, Floating u) => u -> u -> Poly u -> Poly u
rotatePoly :: (Ord u, Floating u) => u -> Point u -> Poly u -> Poly u
scalePoly :: (Ord u, Floating u) => u -> Point u -> Poly u -> Poly u
outlinePoly :: Poly u -> Poly u
meshPoly :: Poly u -> Mesh u
discretePoly :: (RealFrac u, Integral i) => Poly u -> Poly i
inRect :: Ord u => Point u -> Rect u -> Bool
intersectRect :: (Ord u, Num u) => Rect u -> Rect u -> Maybe (Rect u)
star :: (Enum u, Floating u) => Point u -> u -> u -> u -> Poly u
instance Show u => Show (Point u)
instance Eq u => Eq (Point u)
instance Ord u => Ord (Point u)
instance Show u => Show (Line u)
instance Eq u => Eq (Line u)
instance Ord u => Ord (Line u)
instance Show u => Show (Tri u)
instance Eq u => Eq (Tri u)
instance Ord u => Ord (Tri u)
instance Show u => Show (Poly u)
instance Eq u => Eq (Poly u)
instance Ord u => Ord (Poly u)
instance Show u => Show (Mesh u)
instance Eq u => Eq (Mesh u)
instance Ord u => Ord (Mesh u)
instance Show u => Show (Rect u)
instance Eq u => Eq (Rect u)
instance Ord u => Ord (Rect u)
instance Show u => Show (Circle u)
instance Eq u => Eq (Circle u)
instance Ord u => Ord (Circle u)
instance Show u => Show (Elipse u)
instance Eq u => Eq (Elipse u)
instance Ord u => Ord (Elipse u)
instance Geometry Poly
instance Geometry Tri
instance Geometry Line
instance Geometry Point

module Graphics.Ascii.Haha.Bitmap
data Bitmap u p
Bitmap :: Map (Point u) p -> Bitmap u p
bits :: Bitmap u p -> Map (Point u) p
withBits :: (Map (Point u) p -> Map (Point v) q) -> Bitmap u p -> Bitmap v q
empty :: Bitmap u p
get :: Ord u => Point u -> Bitmap u p -> Maybe p
put :: Ord u => Point u -> p -> Bitmap u p -> Bitmap u p
erase :: Ord u => Point u -> Bitmap u p -> Bitmap u p
mapPoints :: Ord v => (Point u -> Point v) -> Bitmap u p -> Bitmap v p
filterPt :: Ord u => (Point u -> p -> Bool) -> Bitmap u p -> Bitmap u p
toList :: Bitmap u p -> [(Point u, p)]
clip :: Ord u => Rect u -> Bitmap u p -> Bitmap u p
drawPoint :: Ord u => Point u -> p -> Bitmap u p -> Bitmap u p
drawList :: Ord u => [Point u] -> p -> Bitmap u p -> Bitmap u p
drawLine :: (Fractional u, Ord u, Enum u) => Line u -> p -> Bitmap u p -> Bitmap u p
drawPoly :: (Fractional u, Ord u, Enum u) => Poly u -> p -> Bitmap u p -> Bitmap u p
drawElipse :: (Floating u, Ord u, Enum u) => Elipse u -> u -> p -> Bitmap u p -> Bitmap u p
drawCircle :: (Floating u, Ord u, Enum u) => Circle u -> u -> p -> Bitmap u p -> Bitmap u p
drawRect :: (Ord u, Enum u) => Rect u -> p -> Bitmap u p -> Bitmap u p
instance (Show u, Show p) => Show (Bitmap u p)
instance (Eq u, Eq p) => Eq (Bitmap u p)
instance Functor (Bitmap u)

module Graphics.Ascii.Haha.Plot
data Pixel
Pixel :: Char -> String -> Pixel
orderPoint :: Ord t => Point t -> Point t -> Ordering
list :: (Integral i, RealFrac u) => u -> Rect u -> Bitmap u p -> [(Point i, p)]
string :: (Integral i, Show i) => Bool -> Rect i -> Point i -> String -> String -> [(Point i, Pixel)] -> String
instance Show Pixel
instance Eq Pixel
