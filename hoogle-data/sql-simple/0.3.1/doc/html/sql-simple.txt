-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | common middle-level sql client.
--   
--   please read README.md
--   <a>https://github.com/philopon/sql-simple/blob/master/README.md</a>
@package sql-simple
@version 0.3.1

module Database.Sql.Simple.Internal
data Query
Query :: Text -> (Map TypeRep Text) -> Query
newtype Sql (l :: [*]) a
Sql :: IO a -> Sql a
unSql :: Sql a -> IO a
getQuery :: TypeRep -> Query -> Text
newtype Only a
Only :: a -> Only a
fromOnly :: Only a -> a
data (:.) h t
(:.) :: h -> t -> :. h t
class Elem a (as :: [*])
withConnection :: (Backend b, Elem b bs) => ConnectInfo b -> (b -> Sql bs a) -> IO a

-- | specify sql backends.
sql :: proxy bs -> Sql bs a -> Sql bs a
class Typeable b => Backend b where data family ConnectInfo b type family ToRow b :: * -> Constraint type family FromRow b :: * -> Constraint forEach c q qs = fold c q qs () . const forEach_ c q = fold_ c q () . const
connect :: Backend b => ConnectInfo b -> IO b
close :: Backend b => b -> IO ()
execute :: (Backend b, ToRow b q) => b -> Query -> q -> Sql c ()
execute_ :: Backend b => b -> Query -> Sql c ()
query :: (Backend b, FromRow b r, ToRow b q) => b -> Query -> q -> Sql c [r]
query_ :: (Backend b, FromRow b r) => b -> Query -> Sql c [r]
fold :: (Backend b, FromRow b r, ToRow b q) => b -> Query -> q -> a -> (a -> r -> IO a) -> IO a
fold_ :: (Backend b, FromRow b r) => b -> Query -> a -> (a -> r -> IO a) -> IO a
forEach :: (Backend b, FromRow b r, ToRow b q) => b -> Query -> q -> (r -> IO ()) -> IO ()
forEach_ :: (Backend b, FromRow b r) => b -> Query -> (r -> IO ()) -> IO ()
class Backend b => Transaction b where withTransaction c action = mask $ \ restore -> do { begin c; r <- restore action `onException` rollback c; commit c; return r }
begin :: Transaction b => b -> Sql c ()
commit :: Transaction b => b -> Sql c ()
rollback :: Transaction b => b -> Sql c ()
withTransaction :: Transaction b => b -> Sql c a -> Sql c a

-- | join sql backends.
(+:+) :: Proxy a -> Proxy b -> Proxy (a ++ b)

-- | add specified query string to Query.
--   
--   example:
--   
--   <pre>
--   q = specify sqlite "sqlite query" "common query"
--   </pre>
specify :: Backend b => proxy ((b :: *) : '[]) -> Text -> Query -> Query
instance [overlap ok] Show Query
instance [overlap ok] Eq Query
instance [overlap ok] Functor (Sql l)
instance [overlap ok] Applicative (Sql l)
instance [overlap ok] Monad (Sql l)
instance [overlap ok] MonadIO (Sql l)
instance [overlap ok] MonadThrow (Sql l)
instance [overlap ok] MonadCatch (Sql l)
instance [overlap ok] MonadMask (Sql l)
instance [overlap ok] MonadBase IO (Sql l)
instance [overlap ok] Elem k a as => Elem k a ((':) * a' as)
instance [overlap ok] Elem * a ((':) * a as)
instance [overlap ok] IsString Query
instance [overlap ok] MonadBaseControl IO (Sql l)

module Database.Sql.Simple
data Query

-- | add specified query string to Query.
--   
--   example:
--   
--   <pre>
--   q = specify sqlite "sqlite query" "common query"
--   </pre>
specify :: Backend b => proxy ((b :: *) : '[]) -> Text -> Query -> Query
newtype Only a
Only :: a -> Only a
fromOnly :: Only a -> a
data (:.) h t
(:.) :: h -> t -> :. h t
data Sql (l :: [*]) a
class Elem a (as :: [*])
class Typeable b => Backend b where data family ConnectInfo b type family ToRow b :: * -> Constraint type family FromRow b :: * -> Constraint forEach c q qs = fold c q qs () . const forEach_ c q = fold_ c q () . const
class Backend b => Transaction b where withTransaction c action = mask $ \ restore -> do { begin c; r <- restore action `onException` rollback c; commit c; return r }
withConnection :: (Backend b, Elem b bs) => ConnectInfo b -> (b -> Sql bs a) -> IO a
connect :: Backend b => ConnectInfo b -> IO b
close :: Backend b => b -> IO ()
execute :: (ToRow b q, Backend b) => b -> Query -> q -> Sql bs ()
execute_ :: Backend b => b -> Query -> Sql bs ()
query :: (Backend b, FromRow b r, ToRow b q) => b -> Query -> q -> Sql bs [r]
query_ :: (FromRow b r, Backend b) => b -> Query -> Sql bs [r]
fold :: (Backend b, FromRow b r, ToRow b q) => b -> Query -> q -> a -> (a -> r -> IO a) -> IO a
fold_ :: (Backend b, FromRow b r) => b -> Query -> a -> (a -> r -> IO a) -> IO a
forEach :: (Backend b, FromRow b r, ToRow b q) => b -> Query -> q -> (r -> IO ()) -> IO ()
forEach_ :: (Backend b, FromRow b r) => b -> Query -> (r -> IO ()) -> IO ()
begin :: Transaction b => b -> Sql bs ()
commit :: Transaction b => b -> Sql bs ()
rollback :: Transaction b => b -> Sql bs ()
withTransaction :: Transaction b => b -> Sql bs a -> Sql bs a

-- | specify sql backends.
sql :: proxy bs -> Sql bs a -> Sql bs a

-- | join sql backends.
(+:+) :: Proxy a -> Proxy b -> Proxy (a ++ b)
