-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Transformers for the Aivika simulation library
--   
@package aivika-transformers
@version 3.0


-- | Tested with: GHC 7.8.3
--   
--   It defines the table functions.
module Simulation.Aivika.Trans.Table

-- | Lookup <tt>x</tt> in a table of pairs <tt>(x, y)</tt> using linear
--   interpolation.
tableLookup :: Double -> Array Int (Double, Double) -> Double

-- | Lookup <tt>x</tt> in a table of pairs <tt>(x, y)</tt> using stepwise
--   function.
tableLookupStepwise :: Double -> Array Int (Double, Double) -> Double


-- | Tested with: GHC 7.8.3
--   
--   It defines a type class of monads with <a>IO</a> exception handling
--   capabilities.
module Simulation.Aivika.Trans.Exception

-- | A computation within which we can throw an exception.
class ExceptionThrowing m
throwComp :: (ExceptionThrowing m, Exception e) => e -> m a

-- | A computation within which we can handle <a>IO</a> exceptions as well
--   as define finalisation blocks.
class (ExceptionThrowing m, MonadIO m) => ExceptionHandling m
catchComp :: (ExceptionHandling m, Exception e, MonadIO m) => m a -> (e -> m a) -> m a
finallyComp :: (ExceptionHandling m, MonadIO m) => m a -> m b -> m a
instance ExceptionHandling IO
instance ExceptionThrowing IO


-- | Tested with: GHC 7.8.3
--   
--   It identifies a current simulation session usually associated with the
--   current simulation run.
module Simulation.Aivika.Trans.Session

-- | A monad within which computation we can create and work with a
--   simulation session.
class (Functor m, Monad m) => SessionMonad m where data family Session m :: * data family SessionMarker m :: *
newSession :: SessionMonad m => m (Session m)
newSessionMarker :: SessionMonad m => Session m -> m (SessionMarker m)
equalSessionMarker :: SessionMonad m => SessionMarker m -> SessionMarker m -> Bool
instance SessionMonad m => Eq (SessionMarker m)
instance SessionMonad IO


-- | Tested with: GHC 7.8.3
--   
--   It defines a prototype of mutable references.
module Simulation.Aivika.Trans.ProtoRef

-- | A monad within which computation we can create and work with the
--   prototype of mutable reference.
class (Functor m, Monad m) => ProtoRefMonad m where data family ProtoRef m :: * -> *
newProtoRef :: ProtoRefMonad m => Session m -> a -> m (ProtoRef m a)
readProtoRef :: ProtoRefMonad m => ProtoRef m a -> m a
writeProtoRef :: ProtoRefMonad m => ProtoRef m a -> a -> m ()
modifyProtoRef :: ProtoRefMonad m => ProtoRef m a -> (a -> a) -> m ()
modifyProtoRef' :: ProtoRefMonad m => ProtoRef m a -> (a -> a) -> m ()
instance ProtoRefMonad IO


-- | Tested with: GHC 7.8.3
--   
--   It defines a prototype of all mutable arrays.
module Simulation.Aivika.Trans.ProtoArray

-- | A monad within which computation we can create and work with the
--   prototype of mutable arrays.
class ProtoRefMonad m => ProtoArrayMonad m where data family ProtoArray m :: * -> *
protoArrayCount :: ProtoArrayMonad m => ProtoArray m a -> m Int
newProtoArray :: ProtoArrayMonad m => Session m -> Int -> a -> m (ProtoArray m a)
newProtoArray_ :: ProtoArrayMonad m => Session m -> Int -> m (ProtoArray m a)
readProtoArray :: ProtoArrayMonad m => ProtoArray m a -> Int -> m a
writeProtoArray :: ProtoArrayMonad m => ProtoArray m a -> Int -> a -> m ()
protoArrayToList :: ProtoArrayMonad m => ProtoArray m a -> m [a]
protoArrayFromList :: ProtoArrayMonad m => [a] -> m (ProtoArray m a)
freezeProtoArray :: ProtoArrayMonad m => ProtoArray m a -> m (Array Int a)
instance ProtoArrayMonad IO


-- | Tested with: GHC 7.8.3
--   
--   It defines a prototype of all mutable unboxed arrays.
module Simulation.Aivika.Trans.ProtoArray.Unboxed

-- | A monad within which computation we can create and work with the
--   prototype of mutable unboxed arrays.
class ProtoRefMonad m => ProtoArrayMonad m a where data family ProtoArray m :: * -> *
protoArrayCount :: ProtoArrayMonad m a => ProtoArray m a -> m Int
newProtoArray :: ProtoArrayMonad m a => Session m -> Int -> a -> m (ProtoArray m a)
newProtoArray_ :: ProtoArrayMonad m a => Session m -> Int -> m (ProtoArray m a)
readProtoArray :: ProtoArrayMonad m a => ProtoArray m a -> Int -> m a
writeProtoArray :: ProtoArrayMonad m a => ProtoArray m a -> Int -> a -> m ()
protoArrayToList :: ProtoArrayMonad m a => ProtoArray m a -> m [a]
protoArrayFromList :: ProtoArrayMonad m a => [a] -> m (ProtoArray m a)
freezeProtoArray :: ProtoArrayMonad m a => ProtoArray m a -> m (Array Int a)
instance MArray IOUArray a IO => ProtoArrayMonad IO a


-- | Tested with: GHC 7.8.3
--   
--   The <a>Unboxed</a> class allows creating unboxed arrays in monad
--   <a>IO</a>.
module Simulation.Aivika.Trans.Unboxed

-- | The type which values can be contained in an unboxed array.
class ProtoArrayMonad m e => Unboxed m e
instance Unboxed IO Word64
instance Unboxed IO Int64
instance Unboxed IO Word32
instance Unboxed IO Word16
instance Unboxed IO Word8
instance Unboxed IO Word
instance Unboxed IO Int32
instance Unboxed IO Int16
instance Unboxed IO Int8
instance Unboxed IO Int
instance Unboxed IO Float
instance Unboxed IO Double
instance Unboxed IO Char
instance Unboxed IO Bool


-- | Tested with: GHC 7.8.3
--   
--   It defines a prototype of mutable vectors.
module Simulation.Aivika.Trans.Vector

-- | A prototype of mutable vector.
data Vector m a

-- | Create a new vector within the specified simulation session.
newVector :: ProtoArrayMonad m => Session m -> m (Vector m a)

-- | Copy the vector.
copyVector :: ProtoArrayMonad m => Vector m a -> m (Vector m a)

-- | Return the element count.
vectorCount :: ProtoArrayMonad m => Vector m a -> m Int

-- | Add the specified element to the end of the vector.
appendVector :: ProtoArrayMonad m => Vector m a -> a -> m ()

-- | Read a value from the vector, where indices are started from 0.
readVector :: ProtoArrayMonad m => Vector m a -> Int -> m a

-- | Set an array item at the specified index which is started from 0.
writeVector :: ProtoArrayMonad m => Vector m a -> Int -> a -> m ()

-- | Return the index of the specified element using binary search;
--   otherwise, a negated insertion index minus one: 0 -&gt; -0 - 1, ..., i
--   -&gt; -i - 1, ....
vectorBinarySearch :: (ProtoArrayMonad m, Ord a) => Vector m a -> a -> m Int

-- | Insert the element in the vector at the specified index.
vectorInsert :: ProtoArrayMonad m => Vector m a -> Int -> a -> m ()

-- | Delete the element at the specified index.
vectorDeleteAt :: ProtoArrayMonad m => Vector m a -> Int -> m ()

-- | Return the index of the item or -1.
vectorIndex :: (ProtoArrayMonad m, Eq a) => Vector m a -> a -> m Int

-- | Return the elements of the vector in an immutable array.
freezeVector :: ProtoArrayMonad m => Vector m a -> m (Array Int a)


-- | Tested with: GHC 7.8.3
--   
--   It defines a prototype of mutable unboxed vectors.
module Simulation.Aivika.Trans.Vector.Unboxed

-- | A prototype of mutable unboxed vector.
data Vector m a

-- | Create a new vector within the specified simulation session.
newVector :: ProtoArrayMonad m a => Session m -> m (Vector m a)

-- | Copy the vector.
copyVector :: ProtoArrayMonad m a => Vector m a -> m (Vector m a)

-- | Return the element count.
vectorCount :: ProtoArrayMonad m a => Vector m a -> m Int

-- | Add the specified element to the end of the vector.
appendVector :: ProtoArrayMonad m a => Vector m a -> a -> m ()

-- | Read a value from the vector, where indices are started from 0.
readVector :: ProtoArrayMonad m a => Vector m a -> Int -> m a

-- | Set an array item at the specified index which is started from 0.
writeVector :: ProtoArrayMonad m a => Vector m a -> Int -> a -> m ()

-- | Return the index of the specified element using binary search;
--   otherwise, a negated insertion index minus one: 0 -&gt; -0 - 1, ..., i
--   -&gt; -i - 1, ....
vectorBinarySearch :: (ProtoArrayMonad m a, Ord a) => Vector m a -> a -> m Int

-- | Insert the element in the vector at the specified index.
vectorInsert :: ProtoArrayMonad m a => Vector m a -> Int -> a -> m ()

-- | Delete the element at the specified index.
vectorDeleteAt :: ProtoArrayMonad m a => Vector m a -> Int -> m ()

-- | Return the index of the item or -1.
vectorIndex :: (ProtoArrayMonad m a, Eq a) => Vector m a -> a -> m Int

-- | Return the elements of the vector in an immutable array.
freezeVector :: ProtoArrayMonad m a => Vector m a -> m (Array Int a)


-- | Tested with: GHC 7.8.3
--   
--   Represents statistics.
module Simulation.Aivika.Trans.Statistics

-- | Describes when the statistics consists of only samples not bound to
--   the simulation time.
data SamplingStats a :: * -> *
SamplingStats :: SrictNotUnpackedInt -> SrictNotUnpackeda -> SrictNotUnpackeda -> SrictNotUnpackedDouble -> SrictNotUnpackedDouble -> SamplingStats a

-- | The total number of samples.
samplingStatsCount :: SamplingStats a -> SrictNotUnpackedInt

-- | The minimum value among the samples.
samplingStatsMin :: SamplingStats a -> SrictNotUnpackeda

-- | The maximum value among the samples.
samplingStatsMax :: SamplingStats a -> SrictNotUnpackeda

-- | The average value.
samplingStatsMean :: SamplingStats a -> SrictNotUnpackedDouble

-- | The average square value.
samplingStatsMean2 :: SamplingStats a -> SrictNotUnpackedDouble

-- | Specifies data type from which values we can gather the statistics.
class Num a => SamplingData a
emptySamplingStats :: SamplingData a => SamplingStats a
addSamplingStats :: SamplingData a => a -> SamplingStats a -> SamplingStats a
combineSamplingStats :: SamplingData a => SamplingStats a -> SamplingStats a -> SamplingStats a

-- | If allows combining statistics more efficiently if we know that the
--   first argument can be a scalar.
combineSamplingStatsEither :: SamplingData a => Either a (SamplingStats a) -> SamplingStats a -> SamplingStats a

-- | Return the variance.
samplingStatsVariance :: SamplingStats a -> Double

-- | Return the deviation.
samplingStatsDeviation :: SamplingStats a -> Double

-- | Show the summary of the statistics using the specified indent.
samplingStatsSummary :: Show a => SamplingStats a -> Int -> ShowS

-- | Return the statistics by a single sample.
returnSamplingStats :: SamplingData a => a -> SamplingStats a

-- | Create the statistics by the specified list of data.
listSamplingStats :: SamplingData a => [a] -> SamplingStats a

-- | Convert the statistics from integer to double values.
fromIntSamplingStats :: SamplingStats Int -> SamplingStats Double

-- | This is the timing statistics where data are bound to the time.
data TimingStats a :: * -> *
TimingStats :: SrictNotUnpackedInt -> SrictNotUnpackeda -> SrictNotUnpackeda -> SrictNotUnpackeda -> SrictNotUnpackedDouble -> SrictNotUnpackedDouble -> SrictNotUnpackedDouble -> SrictNotUnpackedDouble -> SrictNotUnpackedDouble -> SrictNotUnpackedDouble -> TimingStats a

-- | Return the number of samples.
timingStatsCount :: TimingStats a -> SrictNotUnpackedInt

-- | Return the minimum value.
timingStatsMin :: TimingStats a -> SrictNotUnpackeda

-- | Return the maximum value.
timingStatsMax :: TimingStats a -> SrictNotUnpackeda

-- | Return the last value.
timingStatsLast :: TimingStats a -> SrictNotUnpackeda

-- | Return the time at which the minimum is attained.
timingStatsMinTime :: TimingStats a -> SrictNotUnpackedDouble

-- | Return the time at which the maximum is attained.
timingStatsMaxTime :: TimingStats a -> SrictNotUnpackedDouble

-- | Return the start time of sampling.
timingStatsStartTime :: TimingStats a -> SrictNotUnpackedDouble

-- | Return the last time of sampling.
timingStatsLastTime :: TimingStats a -> SrictNotUnpackedDouble

-- | Return the sum of values.
timingStatsSum :: TimingStats a -> SrictNotUnpackedDouble

-- | Return the sum of square values.
timingStatsSum2 :: TimingStats a -> SrictNotUnpackedDouble

-- | Defines the data type from which values we can gather the timing
--   statistics.
class Num a => TimingData a
emptyTimingStats :: TimingData a => TimingStats a
addTimingStats :: TimingData a => Double -> a -> TimingStats a -> TimingStats a
timingStatsMean :: TimingData a => TimingStats a -> Double
timingStatsVariance :: TimingData a => TimingStats a -> Double

-- | Return the deviation.
timingStatsDeviation :: TimingData a => TimingStats a -> Double

-- | Show the summary of the statistics using the specified indent.
timingStatsSummary :: (Show a, TimingData a) => TimingStats a -> Int -> ShowS

-- | Return the statistics by single timing data.
returnTimingStats :: TimingData a => Double -> a -> TimingStats a

-- | Convert the statistics from integer to double values.
fromIntTimingStats :: TimingStats Int -> TimingStats Double

-- | A counter for which the statistics is collected too.
data SamplingCounter a :: * -> *
SamplingCounter :: a -> SamplingStats a -> SamplingCounter a

-- | The counter value.
samplingCounterValue :: SamplingCounter a -> a

-- | The counter statistics.
samplingCounterStats :: SamplingCounter a -> SamplingStats a

-- | An empty counter.
emptySamplingCounter :: SamplingData a => SamplingCounter a

-- | Increase the counter.
incSamplingCounter :: SamplingData a => a -> SamplingCounter a -> SamplingCounter a

-- | Decrease the counter.
decSamplingCounter :: SamplingData a => a -> SamplingCounter a -> SamplingCounter a

-- | Reset the counter.
resetSamplingCounter :: SamplingData a => SamplingCounter a -> SamplingCounter a

-- | Create a counter with the specified initial value.
returnSamplingCounter :: SamplingData a => a -> SamplingCounter a

-- | A counter for which the timing statistics is collected too.
data TimingCounter a :: * -> *
TimingCounter :: a -> TimingStats a -> TimingCounter a

-- | The counter value.
timingCounterValue :: TimingCounter a -> a

-- | The counter statistics.
timingCounterStats :: TimingCounter a -> TimingStats a

-- | An empty counter.
emptyTimingCounter :: TimingData a => TimingCounter a

-- | Increase the counter at the specified time.
incTimingCounter :: TimingData a => Double -> a -> TimingCounter a -> TimingCounter a

-- | Decrease the counter at the specified time.
decTimingCounter :: TimingData a => Double -> a -> TimingCounter a -> TimingCounter a

-- | Reset the counter at the specified time.
resetTimingCounter :: TimingData a => Double -> TimingCounter a -> TimingCounter a

-- | Create a timing counter with the specified initial value at the given
--   time.
returnTimingCounter :: TimingData a => Double -> a -> TimingCounter a


-- | Tested with: GHC 7.8.3
--   
--   Below is defined a random number generator.
module Simulation.Aivika.Trans.Generator

-- | Defines a monad whithin which computation the random number generator
--   can work.
class (Functor m, Monad m) => GeneratorMonad m where data family Generator m :: *
generateUniform :: GeneratorMonad m => Generator m -> Double -> Double -> m Double
generateUniformInt :: GeneratorMonad m => Generator m -> Int -> Int -> m Int
generateNormal :: GeneratorMonad m => Generator m -> Double -> Double -> m Double
generateExponential :: GeneratorMonad m => Generator m -> Double -> m Double
generateErlang :: GeneratorMonad m => Generator m -> Double -> Int -> m Double
generatePoisson :: GeneratorMonad m => Generator m -> Double -> m Int
generateBinomial :: GeneratorMonad m => Generator m -> Double -> Int -> m Int
newGenerator :: GeneratorMonad m => Session m -> GeneratorType m -> m (Generator m)
newRandomGenerator :: (GeneratorMonad m, RandomGen g) => Session m -> g -> m (Generator m)
newRandomGenerator01 :: GeneratorMonad m => Session m -> m Double -> m (Generator m)

-- | Defines a type of the random number generator.
data GeneratorType m

-- | The simple random number generator.
SimpleGenerator :: GeneratorType m

-- | The simple random number generator with the specified seed.
SimpleGeneratorWithSeed :: Int -> GeneratorType m

-- | The custom random number generator.
CustomGenerator :: (m (Generator m)) -> GeneratorType m

-- | The custom random number generator by the specified uniform generator
--   of numbers from 0 to 1.
CustomGenerator01 :: (m Double) -> GeneratorType m
instance GeneratorMonad IO


-- | Tested with: GHC 7.8.3
--   
--   It defines the simulation specs and functions for this data type.
module Simulation.Aivika.Trans.Specs

-- | It defines the simulation specs.
data Specs m
Specs :: Double -> Double -> Double -> Method -> GeneratorType m -> Specs m

-- | the start time
spcStartTime :: Specs m -> Double

-- | the stop time
spcStopTime :: Specs m -> Double

-- | the integration time step
spcDT :: Specs m -> Double

-- | the integration method
spcMethod :: Specs m -> Method

-- | the type of the random number generator
spcGeneratorType :: Specs m -> GeneratorType m

-- | It defines the integration method.
data Method

-- | Euler's method
Euler :: Method

-- | the 2nd order Runge-Kutta method
RungeKutta2 :: Method

-- | the 4th order Runge-Kutta method
RungeKutta4 :: Method

-- | Returns a simulation time for the integration point specified by the
--   specs, iteration and phase.
basicTime :: Specs m -> Int -> Int -> Double

-- | Returns the first and last integration iterations.
integIterationBnds :: Specs m -> (Int, Int)

-- | Returns the last integration iteration.
integIterationHiBnd :: Specs m -> Int

-- | Returns the first integration iteration, i.e. zero.
integIterationLoBnd :: Specs m -> Int

-- | Returns the first and last integration phases.
integPhaseBnds :: Specs m -> (Int, Int)

-- | Returns the last integration phase, 0 for Euler's method, 1 for RK2
--   and 3 for RK4.
integPhaseHiBnd :: Specs m -> Int

-- | Returns the first integration phase, i.e. zero.
integPhaseLoBnd :: Specs m -> Int

-- | Return the integration time values.
integTimes :: Specs m -> [Double]


-- | Tested with: GHC 7.8.3
--   
--   It defines a type class of monads based on which the simulation monads
--   can be built.
module Simulation.Aivika.Trans.Comp

-- | A prototype of the type class of monads based on which the simulation
--   monads can be built.
class (Monad m, ExceptionHandling m, SessionMonad m, ProtoRefMonad m, ProtoArrayMonad m, Unboxed m Double, Unboxed m Float, Unboxed m Int, GeneratorMonad m) => ProtoMonadComp m

-- | Such a prototype monad that allows enqueueing events.
class (ProtoMonadComp m, EventQueueing m) => MonadComp m

-- | A variant of the standard <a>MonadTrans</a> type class with one
--   difference: the computation that will be lifted into another must be
--   <a>MonadComp</a> instead of more general and less restricted
--   <a>Monad</a>.
class MonadCompTrans t
liftComp :: (MonadCompTrans t, MonadComp m) => m a -> t m a
instance ProtoMonadComp IO


-- | Tested with: GHC 7.8.3
--   
--   An imperative heap-based priority queue.
module Simulation.Aivika.Trans.PriorityQueue

-- | The <a>PriorityQueue</a> type represents an imperative heap-based
--   priority queue.
data PriorityQueue m a

-- | Test whether the priority queue is empty.
queueNull :: ProtoMonadComp m => PriorityQueue m a -> m Bool

-- | Return the number of elements in the priority queue.
queueCount :: ProtoMonadComp m => PriorityQueue m a -> m Int

-- | Create a new priority queue.
newQueue :: ProtoMonadComp m => Session m -> m (PriorityQueue m a)

-- | Enqueue a new element with the specified priority.
enqueue :: ProtoMonadComp m => PriorityQueue m a -> Double -> a -> m ()

-- | Dequeue the element with the minimal priority.
dequeue :: ProtoMonadComp m => PriorityQueue m a -> m ()

-- | Return the element with the minimal priority.
queueFront :: ProtoMonadComp m => PriorityQueue m a -> m (Double, a)


-- | Tested with: GHC 7.8.3
--   
--   The module defines the event queue within monad <a>IO</a>.
module Simulation.Aivika.Trans.Comp.IO
instance MonadComp IO
instance EventQueueing IO


-- | Tested with: GHC 7.8.3
--   
--   The module defines the event queue.
module Simulation.Aivika.Trans.Comp.Template

-- | A template-based implementation of the <a>EventQueueing</a> class
--   type.
class ProtoMonadComp m => TemplateEventQueueing m
instance TemplateEventQueueing m => EventQueueing m


-- | Tested with: GHC 7.8.3
--   
--   An imperative double-linked list.
module Simulation.Aivika.Trans.DoubleLinkedList

-- | The <a>DoubleLinkedList</a> type represents an imperative
--   double-linked list.
data DoubleLinkedList m a

-- | Test whether the list is empty.
listNull :: ProtoRefMonad m => DoubleLinkedList m a -> m Bool

-- | Return the number of elements in the list.
listCount :: ProtoRefMonad m => DoubleLinkedList m a -> m Int

-- | Create a new list.
newList :: ProtoRefMonad m => Session m -> m (DoubleLinkedList m a)

-- | Insert a new element in the beginning.
listInsertFirst :: ProtoRefMonad m => DoubleLinkedList m a -> a -> m ()

-- | Add a new element to the end.
listAddLast :: ProtoRefMonad m => DoubleLinkedList m a -> a -> m ()

-- | Remove the first element.
listRemoveFirst :: ProtoRefMonad m => DoubleLinkedList m a -> m ()

-- | Remove the last element.
listRemoveLast :: ProtoRefMonad m => DoubleLinkedList m a -> m ()

-- | Return the first element.
listFirst :: ProtoRefMonad m => DoubleLinkedList m a -> m a

-- | Return the last element.
listLast :: ProtoRefMonad m => DoubleLinkedList m a -> m a


-- | Tested with: GHC 7.8.3
--   
--   The module defines the <tt>ParameterT</tt> monad transformer that
--   allows representing the model parameters. For example, they can be
--   used when running the Monte-Carlo simulation.
--   
--   In general, this monad tranformer is very useful for representing a
--   computation which is external relative to the model itself.
module Simulation.Aivika.Trans.Parameter

-- | The <a>Parameter</a> monad that allows specifying the model
--   parameters. For example, they can be used when running the Monte-Carlo
--   simulation.
--   
--   In general, this monad is very useful for representing a computation
--   which is external relative to the model itself.
data Parameter m a

-- | A type class to lift the parameters into other computations.
class ParameterLift t
liftParameter :: (ParameterLift t, MonadComp m) => Parameter m a -> t m a

-- | Run the parameter using the specified specs.
runParameter :: MonadComp m => Parameter m a -> Specs m -> m a

-- | Run the given number of parameters using the specified specs, where
--   each parameter is distinguished by its index <tt>parameterIndex</tt>.
runParameters :: MonadComp m => Parameter m a -> Specs m -> Int -> [m a]

-- | Exception handling within <a>Parameter</a> computations.
catchParameter :: (MonadComp m, Exception e) => Parameter m a -> (e -> Parameter m a) -> Parameter m a

-- | A computation with finalization part like the <a>finally</a> function.
finallyParameter :: MonadComp m => Parameter m a -> Parameter m b -> Parameter m a

-- | Like the standard <a>throw</a> function.
throwParameter :: (MonadComp m, Exception e) => e -> Parameter m a

-- | Return the run index for the current simulation.
simulationIndex :: Monad m => Parameter m Int

-- | Return the number of simulations currently run.
simulationCount :: Monad m => Parameter m Int

-- | Return the simulation specs.
simulationSpecs :: Monad m => Parameter m (Specs m)

-- | Return the simulation session.
simulationSession :: Monad m => Parameter m (Session m)

-- | Return the random number generator for the simulation run.
generatorParameter :: Monad m => Parameter m (Generator m)

-- | Computation that returns the start simulation time.
starttime :: Monad m => Parameter m Double

-- | Computation that returns the final simulation time.
stoptime :: Monad m => Parameter m Double

-- | Computation that returns the integration time step.
dt :: Monad m => Parameter m Double

-- | Memoize the <a>Parameter</a> computation, always returning the same
--   value within a simulation run. However, the value will be recalculated
--   for other simulation runs. Also it is thread-safe when different
--   simulation runs are executed in parallel on physically different
--   operating system threads.
memoParameter :: Parameter IO a -> IO (Parameter IO a)

-- | Return a parameter which value is taken consequently from the
--   specified table based on the run index of the current simulation
--   starting from zero. After all values from the table are used, it takes
--   again the first value of the table, then the second one and so on.
tableParameter :: Monad m => Array Int a -> Parameter m a


-- | Tested with: GHC 7.8.3
--   
--   The module defines the <tt>SimulationT</tt> monad transformer that
--   represents a simulation run.
module Simulation.Aivika.Trans.Simulation

-- | A value in the <a>Simulation</a> monad represents a computation within
--   the simulation run.
data Simulation m a

-- | A type class to lift the simulation computations into other
--   computations.
class SimulationLift t
liftSimulation :: (SimulationLift t, MonadComp m) => Simulation m a -> t m a

-- | Run the simulation using the specified specs.
runSimulation :: MonadComp m => Simulation m a -> Specs m -> m a

-- | Run the given number of simulations using the specified specs, where
--   each simulation is distinguished by its index <a>simulationIndex</a>.
runSimulations :: MonadComp m => Simulation m a -> Specs m -> Int -> [m a]

-- | Exception handling within <a>Simulation</a> computations.
catchSimulation :: (MonadComp m, Exception e) => Simulation m a -> (e -> Simulation m a) -> Simulation m a

-- | A computation with finalization part like the <a>finally</a> function.
finallySimulation :: MonadComp m => Simulation m a -> Simulation m b -> Simulation m a

-- | Like the standard <a>throw</a> function.
throwSimulation :: (MonadComp m, Exception e) => e -> Simulation m a

-- | Memoize the <a>Simulation</a> computation, always returning the same
--   value within a simulation run.
memoSimulation :: MonadComp m => Simulation m a -> Simulation m (Simulation m a)

-- | The root of simulation exceptions.
data SimulationException :: *

-- | An exception that signals of aborting the simulation.
data SimulationAbort :: *


-- | Tested with: GHC 7.8.3
--   
--   The module defines the <tt>DynamicsT</tt> monad tranformer
--   representing a time varying polymorphic function.
module Simulation.Aivika.Trans.Dynamics

-- | A value in the <a>Dynamics</a> monad represents a polymorphic time
--   varying function defined in the whole spectrum of time values as a
--   single entity. It is ideal for numerical approximating integrals.
data Dynamics m a

-- | A type class to lift the <a>Dynamics</a> computations into other
--   computations.
class DynamicsLift t
liftDynamics :: (DynamicsLift t, MonadComp m) => Dynamics m a -> t m a

-- | Run the <a>Dynamics</a> computation in the initial time point.
runDynamicsInStartTime :: Dynamics m a -> Simulation m a

-- | Run the <a>Dynamics</a> computation in the final time point.
runDynamicsInStopTime :: Dynamics m a -> Simulation m a

-- | Run the <a>Dynamics</a> computation in all integration time points.
runDynamicsInIntegTimes :: Monad m => Dynamics m a -> Simulation m [m a]

-- | Run the <a>Dynamics</a> computation in the specified time point.
runDynamicsInTime :: Double -> Dynamics m a -> Simulation m a

-- | Run the <a>Dynamics</a> computation in the specified time points.
runDynamicsInTimes :: Monad m => [Double] -> Dynamics m a -> Simulation m [m a]

-- | Exception handling within <a>Dynamics</a> computations.
catchDynamics :: (MonadComp m, Exception e) => Dynamics m a -> (e -> Dynamics m a) -> Dynamics m a

-- | A computation with finalization part like the <a>finally</a> function.
finallyDynamics :: MonadComp m => Dynamics m a -> Dynamics m b -> Dynamics m a

-- | Like the standard <a>throw</a> function.
throwDynamics :: (MonadComp m, Exception e) => e -> Dynamics m a

-- | Computation that returns the current simulation time.
time :: Monad m => Dynamics m Double

-- | Whether the current time is an integration time.
isTimeInteg :: Monad m => Dynamics m Bool

-- | Return the integration iteration closest to the current simulation
--   time.
integIteration :: Monad m => Dynamics m Int

-- | Return the integration phase for the current simulation time. It is
--   <tt>(-1)</tt> for non-integration time points.
integPhase :: Monad m => Dynamics m Int

-- | Show the debug message with the current simulation time.
traceDynamics :: Monad m => String -> Dynamics m a -> Dynamics m a


-- | Tested with: GHC 7.8.3
--   
--   This module defines auxiliary functions such as interpolation ones
--   that complement the memoization, for example. There are scan functions
--   too.
module Simulation.Aivika.Trans.Dynamics.Extra

-- | Return the initial value.
initDynamics :: Dynamics m a -> Dynamics m a

-- | Discretize the computation in the integration time points.
discreteDynamics :: Dynamics m a -> Dynamics m a

-- | Interpolate the computation based on the integration time points only.
--   Unlike the <a>discreteDynamics</a> function it knows about the
--   intermediate time points that are used in the Runge-Kutta method.
interpolateDynamics :: Dynamics m a -> Dynamics m a

-- | Like the standard <a>scanl</a> function but applied to values in the
--   integration time points. The accumulator values are transformed
--   according to the third argument, which should be either function
--   <tt>memo0Dynamics</tt> or its unboxed version.
scanDynamics :: (MonadComp m, MonadFix m) => (a -> b -> a) -> a -> (Dynamics m a -> Simulation m (Dynamics m a)) -> (Dynamics m b -> Simulation m (Dynamics m a))

-- | Like the standard <a>scanl1</a> function but applied to values in the
--   integration time points. The accumulator values are transformed
--   according to the second argument, which should be either function
--   <tt>memo0Dynamics</tt> or its unboxed version.
scan1Dynamics :: (MonadComp m, MonadFix m) => (a -> a -> a) -> (Dynamics m a -> Simulation m (Dynamics m a)) -> (Dynamics m a -> Simulation m (Dynamics m a))


-- | Tested with: GHC 7.8.3
--   
--   This module defines memo functions. The memoization creates such
--   <a>Dynamics</a> computations, which values are cached in the
--   integration time points. Then these values are interpolated in all
--   other time points.
module Simulation.Aivika.Trans.Dynamics.Memo

-- | Memoize and order the computation in the integration time points using
--   the interpolation that knows of the Runge-Kutta method. The values are
--   calculated sequentially starting from <a>starttime</a>.
memoDynamics :: MonadComp m => Dynamics m e -> Simulation m (Dynamics m e)

-- | Memoize and order the computation in the integration time points using
--   the <a>discreteDynamics</a> interpolation. It consumes less memory
--   than the <a>memoDynamics</a> function but it is not aware of the
--   Runge-Kutta method. There is a subtle difference when we request for
--   values in the intermediate time points that are used by this method to
--   integrate. In general case you should prefer the <a>memo0Dynamics</a>
--   function above <a>memoDynamics</a>.
memo0Dynamics :: MonadComp m => Dynamics m e -> Simulation m (Dynamics m e)

-- | Iterate sequentially the dynamic process with side effects in the
--   integration time points. It is equivalent to a call of the
--   <a>memo0Dynamics</a> function but significantly more efficient, for
--   the array is not created.
iterateDynamics :: MonadComp m => Dynamics m () -> Simulation m (Dynamics m ())

-- | Memoize and unzip the computation of pairs, applying the
--   <a>memoDynamics</a> function.
unzipDynamics :: MonadComp m => Dynamics m (a, b) -> Simulation m (Dynamics m a, Dynamics m b)

-- | Memoize and unzip the computation of pairs, applying the
--   <a>memo0Dynamics</a> function.
unzip0Dynamics :: MonadComp m => Dynamics m (a, b) -> Simulation m (Dynamics m a, Dynamics m b)


-- | Tested with: GHC 7.8.3
--   
--   This module defines the unboxed memo functions. The memoization
--   creates such <tt>DynamicsT</tt> computations, which values are cached
--   in the integration time points. Then these values are interpolated in
--   all other time points.
module Simulation.Aivika.Trans.Dynamics.Memo.Unboxed

-- | Memoize and order the computation in the integration time points using
--   the interpolation that knows of the Runge-Kutta method. The values are
--   calculated sequentially starting from <a>starttime</a>.
memoDynamics :: (Unboxed m e, MonadComp m) => Dynamics m e -> Simulation m (Dynamics m e)

-- | Memoize and order the computation in the integration time points using
--   the <a>discreteDynamics</a> interpolation. It consumes less memory
--   than the <a>memoDynamics</a> function but it is not aware of the
--   Runge-Kutta method. There is a subtle difference when we request for
--   values in the intermediate time points that are used by this method to
--   integrate. In general case you should prefer the <a>memo0Dynamics</a>
--   function above <a>memoDynamics</a>.
memo0Dynamics :: (Unboxed m e, MonadComp m) => Dynamics m e -> Simulation m (Dynamics m e)


-- | Tested with: GHC 7.8.3
--   
--   This module defines the random parameters of simulation experiments.
--   
--   To create a parameter that would return the same value within the
--   simulation run, you should memoize the computation with help of
--   <a>memoParameter</a>, which is important for the Monte-Carlo
--   simulation.
--   
--   To create a random function that would return the same values in the
--   integration time points within the simulation run, you should either
--   lift the computation to the <a>Dynamics</a> computation and then
--   memoize it too but using the <a>memo0Dynamics</a> function for that
--   computation, or just take the predefined function that does namely
--   this.
module Simulation.Aivika.Trans.Parameter.Random

-- | Computation that generates a new random number distributed uniformly.
randomUniform :: MonadComp m => Double -> Double -> Parameter m Double

-- | Computation that generates a new random integer number distributed
--   uniformly.
randomUniformInt :: MonadComp m => Int -> Int -> Parameter m Int

-- | Computation that generates a new random number distributed normally.
randomNormal :: MonadComp m => Double -> Double -> Parameter m Double

-- | Computation that returns a new exponential random number with the
--   specified mean (the reciprocal of the rate).
randomExponential :: MonadComp m => Double -> Parameter m Double

-- | Computation that returns a new Erlang random number with the specified
--   scale (the reciprocal of the rate) and integer shape.
randomErlang :: MonadComp m => Double -> Int -> Parameter m Double

-- | Computation that returns a new Poisson random number with the
--   specified mean.
randomPoisson :: MonadComp m => Double -> Parameter m Int

-- | Computation that returns a new binomial random number with the
--   specified probability and trials.
randomBinomial :: MonadComp m => Double -> Int -> Parameter m Int

-- | Computation that returns <a>True</a> in case of success.
randomTrue :: MonadComp m => Double -> Parameter m Bool

-- | Computation that returns <a>False</a> in case of success.
randomFalse :: MonadComp m => Double -> Parameter m Bool


-- | Tested with: GHC 7.8.3
--   
--   This module defines the random functions that always return the same
--   values in the integration time points within a single simulation run.
--   The values for another simulation run will be regenerated anew.
--   
--   For example, the computations returned by these functions can be used
--   in the equations of System Dynamics.
--   
--   Also it is worth noting that the values are generated in a strong
--   order starting from <a>starttime</a> with step <a>dt</a>. This is how
--   the <a>memo0Dynamics</a> function actually works.
module Simulation.Aivika.Trans.Dynamics.Random

-- | Computation that generates random numbers distributed uniformly and
--   memoizes them in the integration time points.
memoRandomUniformDynamics :: MonadComp m => Dynamics m Double -> Dynamics m Double -> Simulation m (Dynamics m Double)

-- | Computation that generates random integer numbers distributed
--   uniformly and memoizes them in the integration time points.
memoRandomUniformIntDynamics :: MonadComp m => Dynamics m Int -> Dynamics m Int -> Simulation m (Dynamics m Int)

-- | Computation that generates random numbers distributed normally and
--   memoizes them in the integration time points.
memoRandomNormalDynamics :: MonadComp m => Dynamics m Double -> Dynamics m Double -> Simulation m (Dynamics m Double)

-- | Computation that generates exponential random numbers with the
--   specified mean (the reciprocal of the rate) and memoizes them in the
--   integration time points.
memoRandomExponentialDynamics :: MonadComp m => Dynamics m Double -> Simulation m (Dynamics m Double)

-- | Computation that generates the Erlang random numbers with the
--   specified scale (the reciprocal of the rate) and integer shape but
--   memoizes them in the integration time points.
memoRandomErlangDynamics :: MonadComp m => Dynamics m Double -> Dynamics m Int -> Simulation m (Dynamics m Double)

-- | Computation that generats the Poisson random numbers with the
--   specified mean and memoizes them in the integration time points.
memoRandomPoissonDynamics :: MonadComp m => Dynamics m Double -> Simulation m (Dynamics m Int)

-- | Computation that generates binomial random numbers with the specified
--   probability and trials but memoizes them in the integration time
--   points.
memoRandomBinomialDynamics :: MonadComp m => Dynamics m Double -> Dynamics m Int -> Simulation m (Dynamics m Int)


-- | Tested with: GHC 7.8.3
--   
--   The module defines the <a>Event</a> monad which is very similar to the
--   <a>Dynamics</a> monad but only now the computation is strongly
--   synchronized with the event queue.
module Simulation.Aivika.Trans.Event

-- | A value in the <a>Event</a> monad transformer represents a polymorphic
--   time varying function which is strongly synchronized with the event
--   queue.
data Event m a

-- | A type class to lift the <a>Event</a> computations into other
--   computations.
class EventLift t
liftEvent :: (EventLift t, MonadComp m) => Event m a -> t m a

-- | Defines how the events are processed.
data EventProcessing

-- | either process all earlier and then current events, or raise an error
--   if the current simulation time is less than the actual time of the
--   event queue (safe within the <a>Event</a> computation as this is
--   protected by the type system)
CurrentEvents :: EventProcessing

-- | either process all earlier events not affecting the events at the
--   current simulation time, or raise an error if the current simulation
--   time is less than the actual time of the event queue (safe within the
--   <a>Event</a> computation as this is protected by the type system)
EarlierEvents :: EventProcessing

-- | either process all earlier and then current events, or do nothing if
--   the current simulation time is less than the actual time of the event
--   queue (do not use unless the documentation states the opposite)
CurrentEventsOrFromPast :: EventProcessing

-- | either process all earlier events, or do nothing if the current
--   simulation time is less than the actual time of the event queue (do
--   not use unless the documentation states the opposite)
EarlierEventsOrFromPast :: EventProcessing

-- | Run the <a>Event</a> computation in the start time involving all
--   pending <a>CurrentEvents</a> in the processing too.
runEventInStartTime :: MonadComp m => Event m a -> Simulation m a

-- | Run the <a>Event</a> computation in the stop time involving all
--   pending <a>CurrentEvents</a> in the processing too.
runEventInStopTime :: MonadComp m => Event m a -> Simulation m a

-- | A type class of monads that allow enqueueing the events.
class EventQueueing m where data family EventQueue m :: * runEvent = runEventWith CurrentEvents
newEventQueue :: EventQueueing m => Session m -> Specs m -> m (EventQueue m)
enqueueEvent :: EventQueueing m => Double -> Event m () -> Event m ()
runEvent :: EventQueueing m => Event m a -> Dynamics m a
runEventWith :: EventQueueing m => EventProcessing -> Event m a -> Dynamics m a
eventQueueCount :: EventQueueing m => Event m Int

-- | Enqueue the event with an ability to cancel it.
enqueueEventWithCancellation :: MonadComp m => Double -> Event m () -> Event m (EventCancellation m)

-- | Actuate the event handler in the specified time points.
enqueueEventWithTimes :: MonadComp m => [Double] -> Event m () -> Event m ()

-- | Actuate the event handler in the integration time points.
enqueueEventWithIntegTimes :: MonadComp m => Event m () -> Event m ()

-- | Enqueue the event which must be actuated with the current modeling
--   time but later.
yieldEvent :: MonadComp m => Event m () -> Event m ()

-- | It allows cancelling the event.
data EventCancellation m

-- | Cancel the event.
cancelEvent :: EventCancellation m -> Event m ()

-- | Test whether the event was cancelled.
eventCancelled :: EventCancellation m -> Event m Bool

-- | Test whether the event was processed and finished.
eventFinished :: EventCancellation m -> Event m Bool

-- | Exception handling within <a>Event</a> computations.
catchEvent :: (MonadComp m, Exception e) => Event m a -> (e -> Event m a) -> Event m a

-- | A computation with finalization part like the <a>finally</a> function.
finallyEvent :: MonadComp m => Event m a -> Event m b -> Event m a

-- | Like the standard <a>throw</a> function.
throwEvent :: (MonadComp m, Exception e) => e -> Event m a

-- | Memoize the <a>Event</a> computation, always returning the same value
--   within a simulation run.
memoEvent :: MonadComp m => Event m a -> Simulation m (Event m a)

-- | Memoize the <a>Event</a> computation, always returning the same value
--   in the same modeling time. After the time changes, the value is
--   recalculated by demand.
--   
--   It is possible to implement this function efficiently, for the
--   <a>Event</a> computation is always synchronized with the event queue
--   which time flows in one direction only. This synchronization is a key
--   difference between the <a>Event</a> and <a>Dynamics</a> computations.
memoEventInTime :: MonadComp m => Event m a -> Simulation m (Event m a)

-- | Defines a computation disposing some entity.
newtype DisposableEvent m
DisposableEvent :: Event m () -> DisposableEvent m

-- | Dispose something within the <a>Event</a> computation.
disposeEvent :: DisposableEvent m -> Event m ()

-- | Show the debug message with the current simulation time.
traceEvent :: MonadComp m => String -> Event m a -> Event m a


-- | Tested with: GHC 7.8.3
--   
--   This module defines the queue strategies.
module Simulation.Aivika.Trans.QueueStrategy

-- | Defines the basic queue strategy.
class MonadComp m => QueueStrategy m s where data family StrategyQueue m s :: * -> *
newStrategyQueue :: QueueStrategy m s => s -> Simulation m (StrategyQueue m s a)
strategyQueueNull :: QueueStrategy m s => StrategyQueue m s a -> Event m Bool

-- | Defines a strategy with support of the dequeuing operation.
class QueueStrategy m s => DequeueStrategy m s
strategyDequeue :: DequeueStrategy m s => StrategyQueue m s a -> Event m a

-- | It defines a strategy when we can enqueue a single element.
class DequeueStrategy m s => EnqueueStrategy m s
strategyEnqueue :: EnqueueStrategy m s => StrategyQueue m s a -> a -> Event m ()

-- | It defines a strategy when we can enqueue an element with the
--   specified priority.
class DequeueStrategy m s => PriorityQueueStrategy m s p | s -> p
strategyEnqueueWithPriority :: PriorityQueueStrategy m s p => StrategyQueue m s a -> p -> a -> Event m ()

-- | Strategy: First Come - First Served (FCFS).
data FCFS
FCFS :: FCFS

-- | Strategy: Last Come - First Served (LCFS)
data LCFS
LCFS :: LCFS

-- | Strategy: Service in Random Order (SIRO).
data SIRO
SIRO :: SIRO

-- | Strategy: Static Priorities. It uses the priority queue.
data StaticPriorities
StaticPriorities :: StaticPriorities

-- | An implementation of the <a>FCFS</a> queue strategy.

-- | An implementation of the <a>FCFS</a> queue strategy.

-- | An implementation of the <a>FCFS</a> queue strategy.

-- | An implementation of the <a>LCFS</a> queue strategy.

-- | An implementation of the <a>LCFS</a> queue strategy.

-- | An implementation of the <a>LCFS</a> queue strategy.

-- | An implementation of the <a>StaticPriorities</a> queue strategy.

-- | An implementation of the <a>StaticPriorities</a> queue strategy.

-- | An implementation of the <a>StaticPriorities</a> queue strategy.

-- | An implementation of the <a>SIRO</a> queue strategy.

-- | An implementation of the <a>SIRO</a> queue strategy.

-- | An implementation of the <a>SIRO</a> queue strategy.
instance Eq FCFS
instance Ord FCFS
instance Show FCFS
instance Eq LCFS
instance Ord LCFS
instance Show LCFS
instance Eq SIRO
instance Ord SIRO
instance Show SIRO
instance Eq StaticPriorities
instance Ord StaticPriorities
instance Show StaticPriorities
instance DequeueStrategy m SIRO => EnqueueStrategy m SIRO
instance QueueStrategy m SIRO => DequeueStrategy m SIRO
instance MonadComp m => QueueStrategy m SIRO
instance DequeueStrategy m StaticPriorities => PriorityQueueStrategy m StaticPriorities Double
instance QueueStrategy m StaticPriorities => DequeueStrategy m StaticPriorities
instance MonadComp m => QueueStrategy m StaticPriorities
instance DequeueStrategy m LCFS => EnqueueStrategy m LCFS
instance QueueStrategy m LCFS => DequeueStrategy m LCFS
instance MonadComp m => QueueStrategy m LCFS
instance DequeueStrategy m FCFS => EnqueueStrategy m FCFS
instance QueueStrategy m FCFS => DequeueStrategy m FCFS
instance MonadComp m => QueueStrategy m FCFS


-- | Tested with: GHC 7.8.3
--   
--   This module defines the signal which we can subscribe handlers to.
--   These handlers can be disposed. The signal is triggered in the current
--   time point actuating the corresponded computations from the handlers.
module Simulation.Aivika.Trans.Signal

-- | The signal that can have disposable handlers.
data Signal m a
Signal :: ((a -> Event m ()) -> Event m (DisposableEvent m)) -> Signal m a

-- | Subscribe the handler to the specified signal and return a nested
--   computation within a disposable object that, being applied,
--   unsubscribes the handler from this signal.
handleSignal :: Signal m a -> (a -> Event m ()) -> Event m (DisposableEvent m)

-- | Subscribe the handler to the specified signal forever. To subscribe
--   the disposable handlers, use function <a>handleSignal</a>.
handleSignal_ :: MonadComp m => Signal m a -> (a -> Event m ()) -> Event m ()

-- | The signal source that can publish its signal.
data SignalSource m a

-- | Create a new signal source.
newSignalSource :: MonadComp m => Simulation m (SignalSource m a)

-- | Publish the signal.
publishSignal :: SignalSource m a -> Signal m a

-- | Trigger the signal actuating all its handlers at the current
--   simulation time point.
triggerSignal :: SignalSource m a -> a -> Event m ()

-- | Map the signal according the specified function.
mapSignal :: MonadComp m => (a -> b) -> Signal m a -> Signal m b

-- | Compose the signal.
mapSignalM :: MonadComp m => (a -> Event m b) -> Signal m a -> Signal m b

-- | Transform the signal.
apSignal :: MonadComp m => Event m (a -> b) -> Signal m a -> Signal m b

-- | Filter only those signal values that satisfy to the specified
--   predicate.
filterSignal :: MonadComp m => (a -> Bool) -> Signal m a -> Signal m a

-- | Filter only those signal values that satisfy to the specified
--   predicate.
filterSignalM :: MonadComp m => (a -> Event m Bool) -> Signal m a -> Signal m a

-- | An empty signal which is never triggered.
emptySignal :: MonadComp m => Signal m a

-- | Merge two signals.
merge2Signals :: MonadComp m => Signal m a -> Signal m a -> Signal m a

-- | Merge three signals.
merge3Signals :: MonadComp m => Signal m a -> Signal m a -> Signal m a -> Signal m a

-- | Merge four signals.
merge4Signals :: MonadComp m => Signal m a -> Signal m a -> Signal m a -> Signal m a -> Signal m a

-- | Merge five signals.
merge5Signals :: MonadComp m => Signal m a -> Signal m a -> Signal m a -> Signal m a -> Signal m a -> Signal m a

-- | Transform a signal so that the resulting signal returns a sequence of
--   arrivals saving the information about the time points at which the
--   original signal was received.
arrivalSignal :: MonadComp m => Signal m a -> Signal m (Arrival a)

-- | Return a signal that is triggered in the specified time points.
newSignalInTimes :: MonadComp m => [Double] -> Event m (Signal m Double)

-- | Return a signal that is triggered in the integration time points. It
--   should be called with help of <a>runEventInStartTime</a>.
newSignalInIntegTimes :: MonadComp m => Event m (Signal m Double)

-- | Return a signal that is triggered in the start time. It should be
--   called with help of <a>runEventInStartTime</a>.
newSignalInStartTime :: MonadComp m => Event m (Signal m Double)

-- | Return a signal that is triggered in the final time.
newSignalInStopTime :: MonadComp m => Event m (Signal m Double)

-- | Represents the history of the signal values.
data SignalHistory m a

-- | The signal for which the history is created.
signalHistorySignal :: SignalHistory m a -> Signal m a

-- | Create a history of the signal values.
newSignalHistory :: MonadComp m => Signal m a -> Event m (SignalHistory m a)

-- | Create a history of the signal values starting with the optional
--   initial value.
newSignalHistoryStartingWith :: MonadComp m => Maybe a -> Signal m a -> Event m (SignalHistory m a)

-- | Read the history of signal values.
readSignalHistory :: MonadComp m => SignalHistory m a -> Event m (Array Int Double, Array Int a)

-- | Describes a computation that also signals when changing its value.
data Signalable m a
Signalable :: Event m a -> Signal m () -> Signalable m a

-- | Return a computation of the value.
readSignalable :: Signalable m a -> Event m a

-- | Return a signal notifying that the value has changed but without
--   providing the information about the changed value.
signalableChanged_ :: Signalable m a -> Signal m ()

-- | Return a signal notifying that the value has changed.
signalableChanged :: MonadComp m => Signalable m a -> Signal m a

-- | Return an identity.
emptySignalable :: (MonadComp m, Monoid a) => Signalable m a

-- | An associative operation.
appendSignalable :: (MonadComp m, Monoid a) => Signalable m a -> Signalable m a -> Signalable m a

-- | Show the debug message with the current simulation time.
traceSignal :: MonadComp m => String -> Signal m a -> Signal m a


-- | Tested with: GHC 7.8.3
--   
--   This module defines an updatable reference that depends on the event
--   queue.
module Simulation.Aivika.Trans.Ref

-- | The <a>Ref</a> type represents a mutable variable similar to the
--   <a>IORef</a> variable but only dependent on the event queue, which
--   allows synchronizing the reference with the model explicitly through
--   the <a>Event</a> monad.
data Ref m a

-- | Return a signal that notifies about every change of the reference
--   state.
refChanged :: MonadComp m => Ref m a -> Signal m a

-- | Return a signal that notifies about every change of the reference
--   state.
refChanged_ :: MonadComp m => Ref m a -> Signal m ()

-- | Create a new reference.
newRef :: MonadComp m => a -> Simulation m (Ref m a)

-- | Read the value of a reference.
readRef :: MonadComp m => Ref m a -> Event m a

-- | Write a new value into the reference.
writeRef :: MonadComp m => Ref m a -> a -> Event m ()

-- | Mutate the contents of the reference.
modifyRef :: MonadComp m => Ref m a -> (a -> a) -> Event m ()


-- | Tested with: GHC 7.8.3
--   
--   This small utility module allows accumulating the timing statistics
--   based on <a>Signalable</a> data such as the queue size or the number
--   of lost items in the queue.
module Simulation.Aivika.Trans.Statistics.Accumulator

-- | Represents an accumulator for the timing statistics.
data TimingStatsAccumulator m a

-- | Start gathering the timing statistics from the current simulation
--   time.
newTimingStatsAccumulator :: (MonadComp m, TimingData a) => Signalable m a -> Event m (TimingStatsAccumulator m a)

-- | Return the accumulated statistics.
timingStatsAccumulated :: MonadComp m => TimingStatsAccumulator m a -> Event m (TimingStats a)


-- | Tested with: GHC 7.8.3
--   
--   This module defines a variable that is bound up with the event queue
--   and that keeps the history of changes storing the values in arrays,
--   which allows using the variable in differential and difference
--   equations of System Dynamics within hybrid discrete-continuous
--   simulation.
module Simulation.Aivika.Trans.Var

-- | Like the <a>Ref</a> reference but keeps the history of changes in
--   different time points. The <a>Var</a> variable is safe to be used in
--   the hybrid discrete-continuous simulation.
--   
--   For example, the memoised values of a variable can be used in the
--   differential or difference equations of System Dynamics, while the
--   variable iself can be updated wihin the discrete event simulation.
--   
--   Only this variable is much slower than the reference.
data Var m a

-- | Return a signal that notifies about every change of the variable
--   state.
varChanged :: Var m a -> Signal m a

-- | Return a signal that notifies about every change of the variable
--   state.
varChanged_ :: MonadComp m => Var m a -> Signal m ()

-- | Create a new variable.
newVar :: MonadComp m => a -> Simulation m (Var m a)

-- | Read the recent actual value of a variable for the requested time.
--   
--   This computation is destined for using within discrete event
--   simulation.
readVar :: MonadComp m => Var m a -> Event m a

-- | Read the first actual, i.e. memoised, value of a variable for the
--   requested time actuating the current events from the queue if needed.
--   
--   This computation can be used in the ordinary differential and
--   difference equations of System Dynamics.
varMemo :: MonadComp m => Var m a -> Dynamics m a

-- | Write a new value into the variable.
writeVar :: MonadComp m => Var m a -> a -> Event m ()

-- | Mutate the contents of the variable.
modifyVar :: MonadComp m => Var m a -> (a -> a) -> Event m ()

-- | Freeze the variable and return in arrays the time points and
--   corresponded first and last values when the variable had changed or
--   had been memoised in different time points: (1) the time points are
--   sorted in ascending order; (2) the first and last actual values per
--   each time point are provided.
--   
--   If you need to get all changes including those ones that correspond to
--   the same simulation time points then you can use the
--   <a>newSignalHistory</a> function passing in the <a>varChanged</a>
--   signal to it and then call function <a>readSignalHistory</a>.
freezeVar :: MonadComp m => Var m a -> Event m (Array Int Double, Array Int a, Array Int a)


-- | Tested with: GHC 7.8.3
--   
--   This module defines an unboxed variable that is bound up with the
--   event queue and that keeps the history of changes storing the values
--   in unboxed arrays, which allows using the variable in differential and
--   difference equations of System Dynamics within hybrid
--   discrete-continuous simulation.
module Simulation.Aivika.Trans.Var.Unboxed

-- | Like the <a>Ref</a> reference but keeps the history of changes in
--   different time points. The <a>Var</a> variable is safe to be used in
--   the hybrid discrete-continuous simulation.
--   
--   For example, the memoised values of a variable can be used in the
--   differential or difference equations of System Dynamics, while the
--   variable iself can be updated wihin the discrete event simulation.
--   
--   Only this variable is much slower than the reference.
data Var m a

-- | Return a signal that notifies about every change of the variable
--   state.
varChanged :: Var m a -> Signal m a

-- | Return a signal that notifies about every change of the variable
--   state.
varChanged_ :: MonadComp m => Var m a -> Signal m ()

-- | Create a new variable.
newVar :: (MonadComp m, Unboxed m a) => a -> Simulation m (Var m a)

-- | Read the recent actual value of a variable for the requested time.
--   
--   This computation is destined for using within discrete event
--   simulation.
readVar :: (MonadComp m, Unboxed m a) => Var m a -> Event m a

-- | Read the first actual, i.e. memoised, value of a variable for the
--   requested time actuating the current events from the queue if needed.
--   
--   This computation can be used in the ordinary differential and
--   difference equations of System Dynamics.
varMemo :: (MonadComp m, Unboxed m a) => Var m a -> Dynamics m a

-- | Write a new value into the variable.
writeVar :: (MonadComp m, Unboxed m a) => Var m a -> a -> Event m ()

-- | Mutate the contents of the variable.
modifyVar :: (MonadComp m, Unboxed m a) => Var m a -> (a -> a) -> Event m ()

-- | Freeze the variable and return in arrays the time points and
--   corresponded first and last values when the variable had changed or
--   had been memoised in different time points: (1) the time points are
--   sorted in ascending order; (2) the first and last actual values per
--   each time point are provided.
--   
--   If you need to get all changes including those ones that correspond to
--   the same simulation time points then you can use the
--   <a>newSignalHistory</a> function passing in the <a>varChanged</a>
--   signal to it and then call function <a>readSignalHistory</a>.
freezeVar :: (MonadComp m, Unboxed m a) => Var m a -> Event m (Array Int Double, Array Int a, Array Int a)


-- | Tested with: GHC 7.8.3
--   
--   This module defines integrals and other functions of System Dynamics.
module Simulation.Aivika.Trans.SystemDynamics

-- | Compare for equality.
(.==.) :: (MonadComp m, Eq a) => Dynamics m a -> Dynamics m a -> Dynamics m Bool

-- | Compare for inequality.
(./=.) :: (MonadComp m, Eq a) => Dynamics m a -> Dynamics m a -> Dynamics m Bool

-- | Compare for ordering.
(.<.) :: (MonadComp m, Ord a) => Dynamics m a -> Dynamics m a -> Dynamics m Bool

-- | Compare for ordering.
(.>=.) :: (MonadComp m, Ord a) => Dynamics m a -> Dynamics m a -> Dynamics m Bool

-- | Compare for ordering.
(.>.) :: (MonadComp m, Ord a) => Dynamics m a -> Dynamics m a -> Dynamics m Bool

-- | Compare for ordering.
(.<=.) :: (MonadComp m, Ord a) => Dynamics m a -> Dynamics m a -> Dynamics m Bool

-- | Return the maximum.
maxDynamics :: (MonadComp m, Ord a) => Dynamics m a -> Dynamics m a -> Dynamics m a

-- | Return the minimum.
minDynamics :: (MonadComp m, Ord a) => Dynamics m a -> Dynamics m a -> Dynamics m a

-- | Implement the if-then-else operator.
ifDynamics :: MonadComp m => Dynamics m Bool -> Dynamics m a -> Dynamics m a -> Dynamics m a

-- | Return an integral with the specified derivative and initial value.
--   
--   To create a loopback, you should use the recursive do-notation. It
--   allows defining the differential equations unordered as in
--   mathematics:
--   
--   <pre>
--   model = 
--     mdo a &lt;- integ (- ka * a) 100
--         b &lt;- integ (ka * a - kb * b) 0
--         c &lt;- integ (kb * b) 0
--         let ka = 1
--             kb = 1
--         runDynamicsInStopTime $ sequence [a, b, c]
--   </pre>
integ :: (MonadComp m, MonadFix m) => Dynamics m Double -> Dynamics m Double -> Simulation m (Dynamics m Double)

-- | Like <a>integ</a> but allows either setting a new <a>Left</a> integral
--   value, or integrating using the <a>Right</a> derivative directly
--   within computation.
--   
--   This function always uses Euler's method.
integEither :: (MonadComp m, MonadFix m) => Dynamics m (Either Double Double) -> Dynamics m Double -> Simulation m (Dynamics m Double)

-- | Return the first order exponential smooth.
--   
--   To create a loopback, you should use the recursive do-notation with
--   help of which the function itself is defined:
--   
--   <pre>
--   smoothI x t i =
--     mdo y &lt;- integ ((x - y) / t) i
--         return y
--   </pre>
smoothI :: (MonadComp m, MonadFix m) => Dynamics m Double -> Dynamics m Double -> Dynamics m Double -> Simulation m (Dynamics m Double)

-- | Return the first order exponential smooth.
--   
--   This is a simplified version of the <a>smoothI</a> function without
--   specifing the initial value.
smooth :: (MonadComp m, MonadFix m) => Dynamics m Double -> Dynamics m Double -> Simulation m (Dynamics m Double)

-- | Return the third order exponential smooth.
--   
--   To create a loopback, you should use the recursive do-notation with
--   help of which the function itself is defined:
--   
--   <pre>
--   smooth3I x t i =
--     mdo y  &lt;- integ ((s2 - y) / t') i
--         s2 &lt;- integ ((s1 - s2) / t') i
--         s1 &lt;- integ ((x - s1) / t') i
--         let t' = t / 3.0
--         return y
--   </pre>
smooth3I :: (MonadComp m, MonadFix m) => Dynamics m Double -> Dynamics m Double -> Dynamics m Double -> Simulation m (Dynamics m Double)

-- | Return the third order exponential smooth.
--   
--   This is a simplified version of the <a>smooth3I</a> function without
--   specifying the initial value.
smooth3 :: (MonadComp m, MonadFix m) => Dynamics m Double -> Dynamics m Double -> Simulation m (Dynamics m Double)

-- | Return the n'th order exponential smooth.
--   
--   The result is not discrete in that sense that it may change within the
--   integration time interval depending on the integration method used.
--   Probably, you should apply the <a>discreteDynamics</a> function to the
--   result if you want to achieve an effect when the value is not changed
--   within the time interval, which is used sometimes.
smoothNI :: (MonadComp m, MonadFix m) => Dynamics m Double -> Dynamics m Double -> Int -> Dynamics m Double -> Simulation m (Dynamics m Double)

-- | Return the n'th order exponential smooth.
--   
--   This is a simplified version of the <a>smoothNI</a> function without
--   specifying the initial value.
smoothN :: (MonadComp m, MonadFix m) => Dynamics m Double -> Dynamics m Double -> Int -> Simulation m (Dynamics m Double)

-- | Return the first order exponential delay.
--   
--   To create a loopback, you should use the recursive do-notation with
--   help of which the function itself is defined:
--   
--   <pre>
--   delay1I x t i =
--     mdo y &lt;- integ (x - y / t) (i * t)
--         return $ y / t
--   </pre>
delay1I :: (MonadComp m, MonadFix m) => Dynamics m Double -> Dynamics m Double -> Dynamics m Double -> Simulation m (Dynamics m Double)

-- | Return the first order exponential delay.
--   
--   This is a simplified version of the <a>delay1I</a> function without
--   specifying the initial value.
delay1 :: (MonadComp m, MonadFix m) => Dynamics m Double -> Dynamics m Double -> Simulation m (Dynamics m Double)

-- | Return the third order exponential delay.
delay3I :: (MonadComp m, MonadFix m) => Dynamics m Double -> Dynamics m Double -> Dynamics m Double -> Simulation m (Dynamics m Double)

-- | Return the third order exponential delay.
--   
--   This is a simplified version of the <a>delay3I</a> function without
--   specifying the initial value.
delay3 :: (MonadComp m, MonadFix m) => Dynamics m Double -> Dynamics m Double -> Simulation m (Dynamics m Double)

-- | Return the n'th order exponential delay.
delayNI :: (MonadComp m, MonadFix m) => Dynamics m Double -> Dynamics m Double -> Int -> Dynamics m Double -> Simulation m (Dynamics m Double)

-- | Return the n'th order exponential delay.
--   
--   This is a simplified version of the <a>delayNI</a> function without
--   specifying the initial value.
delayN :: (MonadComp m, MonadFix m) => Dynamics m Double -> Dynamics m Double -> Int -> Simulation m (Dynamics m Double)

-- | Return the forecast.
--   
--   The function has the following definition:
--   
--   <pre>
--   forecast x at hz =
--     do y &lt;- smooth x at
--        return $ x * (1.0 + (x / y - 1.0) / at * hz)
--   </pre>
forecast :: (MonadComp m, MonadFix m) => Dynamics m Double -> Dynamics m Double -> Dynamics m Double -> Simulation m (Dynamics m Double)

-- | Return the trend.
--   
--   The function has the following definition:
--   
--   <pre>
--   trend x at i =
--     do y &lt;- smoothI x at (x / (1.0 + i * at))
--        return $ (x / y - 1.0) / at
--   </pre>
trend :: (MonadComp m, MonadFix m) => Dynamics m Double -> Dynamics m Double -> Dynamics m Double -> Simulation m (Dynamics m Double)

-- | Retun the sum for the difference equation. It is like an integral
--   returned by the <a>integ</a> function, only now the difference is used
--   instead of derivative.
--   
--   As usual, to create a loopback, you should use the recursive
--   do-notation.
diffsum :: (MonadComp m, MonadFix m, Unboxed m a, Num a) => Dynamics m a -> Dynamics m a -> Simulation m (Dynamics m a)

-- | Like <a>diffsum</a> but allows either setting a new <a>Left</a> sum
--   value, or adding the <a>Right</a> difference.
diffsumEither :: (MonadComp m, MonadFix m, Unboxed m a, Num a) => Dynamics m (Either a a) -> Dynamics m a -> Simulation m (Dynamics m a)

-- | Lookup <tt>x</tt> in a table of pairs <tt>(x, y)</tt> using linear
--   interpolation.
lookupDynamics :: MonadComp m => Dynamics m Double -> Array Int (Double, Double) -> Dynamics m Double

-- | Lookup <tt>x</tt> in a table of pairs <tt>(x, y)</tt> using stepwise
--   function.
lookupStepwiseDynamics :: MonadComp m => Dynamics m Double -> Array Int (Double, Double) -> Dynamics m Double

-- | Return the delayed value using the specified lag time.
delay :: MonadComp m => Dynamics m a -> Dynamics m Double -> Dynamics m a

-- | Return the delayed value using the specified lag time and initial
--   value. Because of the latter, it allows creating a loop back.
delayI :: MonadComp m => Dynamics m a -> Dynamics m Double -> Dynamics m a -> Simulation m (Dynamics m a)

-- | Computation that returns 0 until the step time and then returns the
--   specified height.
step :: MonadComp m => Dynamics m Double -> Dynamics m Double -> Dynamics m Double

-- | Computation that returns 1, starting at the time start, and lasting
--   for the interval width; 0 is returned at all other times.
pulse :: MonadComp m => Dynamics m Double -> Dynamics m Double -> Dynamics m Double

-- | Computation that returns 1, starting at the time start, and lasting
--   for the interval width and then repeats this pattern with the
--   specified period; 0 is returned at all other times.
pulseP :: MonadComp m => Dynamics m Double -> Dynamics m Double -> Dynamics m Double -> Dynamics m Double

-- | Computation that returns 0 until the specified time start and then
--   slopes upward until the end time and then holds constant.
ramp :: MonadComp m => Dynamics m Double -> Dynamics m Double -> Dynamics m Double -> Dynamics m Double

-- | Return the Net Present Value (NPV) of the stream computed using the
--   specified discount rate, the initial value and some factor (usually
--   1).
--   
--   It is defined in the following way:
--   
--   <pre>
--   npv stream rate init factor =
--     mdo let dt' = liftParameter dt
--         df &lt;- integ (- df * rate) 1
--         accum &lt;- integ (stream * df) init
--         return $ (accum + dt' * stream * df) * factor
--   </pre>
npv :: (MonadComp m, MonadFix m) => Dynamics m Double -> Dynamics m Double -> Dynamics m Double -> Dynamics m Double -> Simulation m (Dynamics m Double)

-- | Return the Net Present Value End of period (NPVE) of the stream
--   computed using the specified discount rate, the initial value and some
--   factor.
--   
--   It is defined in the following way:
--   
--   <pre>
--   npve stream rate init factor =
--     mdo let dt' = liftParameter dt
--         df &lt;- integ (- df * rate / (1 + rate * dt')) (1 / (1 + rate * dt'))
--         accum &lt;- integ (stream * df) init
--         return $ (accum + dt' * stream * df) * factor
--   </pre>
npve :: (MonadComp m, MonadFix m) => Dynamics m Double -> Dynamics m Double -> Dynamics m Double -> Dynamics m Double -> Simulation m (Dynamics m Double)


-- | Tested with: GHC 7.8.3
--   
--   The module defines something which is most close to the notion of
--   analogous circuit as an opposite to the digital one.
module Simulation.Aivika.Trans.Transform

-- | It allows representing an analogous circuit as an opposite to the
--   digital one.
--   
--   This is a transform of one time varying function to another usually
--   specified in the integration time points and then interpolated in
--   other time points with help of one of the memoization functions like
--   <a>memo0Dynamics</a>.
newtype Transform m a b
Transform :: (Dynamics m a -> Simulation m (Dynamics m b)) -> Transform m a b

-- | Run the transform.
runTransform :: Transform m a b -> Dynamics m a -> Simulation m (Dynamics m b)

-- | Return a delayed transform by the specified lag time and initial
--   value.
--   
--   This is actually the <a>delayI</a> function wrapped in the
--   <a>Transform</a> type.
delayTransform :: MonadComp m => Dynamics m Double -> Dynamics m a -> Transform m a a

-- | A transform that returns the current modeling time.
timeTransform :: MonadComp m => Transform m a Double

-- | Return a transform that maps the derivative to an integral by the
--   specified initial value.
--   
--   This is actually the <a>integ</a> function wrapped in the
--   <a>Transform</a> type.
integTransform :: (MonadComp m, MonadFix m) => Dynamics m Double -> Transform m Double Double

-- | Like <a>integTransform</a> but allows either setting a new <a>Left</a>
--   value of the integral, or updating it by the specified <a>Right</a>
--   derivative.
integTransformEither :: (MonadComp m, MonadFix m) => Dynamics m Double -> Transform m (Either Double Double) Double

-- | Return a transform that maps the difference to a sum by the specified
--   initial value.
--   
--   This is actually the <a>diffsum</a> function wrapped in the
--   <a>Transform</a> type.
sumTransform :: (MonadComp m, MonadFix m, Num a, Unboxed m a) => Dynamics m a -> Transform m a a

-- | Like <a>sumTransform</a> but allows either setting a new <a>Left</a>
--   value of the sum, or updating it by the specified <a>Right</a>
--   difference.
sumTransformEither :: (MonadComp m, MonadFix m, Num a, Unboxed m a) => Dynamics m a -> Transform m (Either a a) a
instance (MonadComp m, MonadFix m) => ArrowLoop (Transform m)
instance MonadComp m => Arrow (Transform m)
instance MonadComp m => Category (Transform m)


-- | Tested with: GHC 7.8.3
--   
--   This module defines memoization transforms. The memoization creates
--   such <a>Dynamics</a> computations, which values are cached in the
--   integration time points. Then these values are interpolated in all
--   other time points.
module Simulation.Aivika.Trans.Transform.Memo

-- | A transform that memoizes and order the computation in the integration
--   time points using the interpolation that knows of the Runge-Kutta
--   method. The values are calculated sequentially starting from
--   <a>starttime</a>.
memoTransform :: MonadComp m => Transform m e e

-- | A transform that memoizes and order the computation in the integration
--   time points using the <a>discreteDynamics</a> interpolation. It
--   consumes less memory than the <a>memoTransform</a> computation but it
--   is not aware of the Runge-Kutta method. There is a subtle difference
--   when we request for values in the intermediate time points that are
--   used by this method to integrate. In general case you should prefer
--   the <a>memo0Transform</a> computation above <a>memoTransform</a>.
memo0Transform :: MonadComp m => Transform m e e

-- | A transform that iterates sequentially the dynamic process with side
--   effects in the integration time points. It is equivalent to the
--   <a>memo0Transform</a> computation but significantly more efficient,
--   for the internal array is not created.
iteratingTransform :: MonadComp m => Transform m () ()


-- | Tested with: GHC 7.8.3
--   
--   This module defines auxiliary computations such as interpolation ones
--   that complement the memoization, for example. There are scan
--   computations too.
module Simulation.Aivika.Trans.Transform.Extra

-- | A transform that returns the initial value.
initTransform :: Monad m => Transform m a a

-- | A transform that discretizes the computation in the integration time
--   points.
discreteTransform :: Monad m => Transform m a a

-- | A tranform that interpolates the computation based on the integration
--   time points only. Unlike the <a>discreteTransform</a> computation it
--   knows about the intermediate time points that are used in the
--   Runge-Kutta method.
interpolatingTransform :: Monad m => Transform m a a

-- | Like the standard <a>scanl</a> function but applied to values in the
--   integration time points. The accumulator values are transformed
--   according to the third argument, which should be either
--   <a>memo0Transform</a> or its unboxed version.
scanTransform :: (MonadComp m, MonadFix m) => (a -> b -> a) -> a -> Transform m a a -> Transform m b a

-- | Like the standard <a>scanl1</a> function but applied to values in the
--   integration time points. The accumulator values are transformed
--   according to the second argument, which should be either
--   <a>memo0Transform</a> or its unboxed version.
scan1Transform :: (MonadComp m, MonadFix m) => (a -> a -> a) -> Transform m a a -> Transform m a a


-- | Tested with: GHC 7.8.3
--   
--   This module defines the unboxed memoization transforms. The
--   memoization creates such <a>Dynamics</a> computations, which values
--   are cached in the integration time points. Then these values are
--   interpolated in all other time points.
module Simulation.Aivika.Trans.Transform.Memo.Unboxed

-- | A transform that memoizes and order the computation in the integration
--   time points using the interpolation that knows of the Runge-Kutta
--   method. The values are calculated sequentially starting from
--   <a>starttime</a>.
memoTransform :: (MonadComp m, Unboxed m e) => Transform m e e

-- | A transform that memoizes and order the computation in the integration
--   time points using the <a>discreteDynamics</a> interpolation. It
--   consumes less memory than the <a>memoTransform</a> computation but it
--   is not aware of the Runge-Kutta method. There is a subtle difference
--   when we request for values in the intermediate time points that are
--   used by this method to integrate. In general case you should prefer
--   the <a>memo0Transform</a> computation above <a>memoTransform</a>.
memo0Transform :: (MonadComp m, Unboxed m e) => Transform m e e


-- | Tested with: GHC 7.8.3
--   
--   The <a>Cont</a> monad is a variation of the standard Cont monad and F#
--   async workflow, where the result of applying the continuations is the
--   <tt>Event</tt> computation.
module Simulation.Aivika.Trans.Cont

-- | It defines how the parent and child computations should be cancelled.
data ContCancellation

-- | Cancel the both computations together.
CancelTogether :: ContCancellation

-- | Cancel the child if its parent is cancelled.
CancelChildAfterParent :: ContCancellation

-- | Cancel the parent if its child is cancelled.
CancelParentAfterChild :: ContCancellation

-- | Cancel the computations in isolation.
CancelInIsolation :: ContCancellation

-- | The <a>Cont</a> type is similar to the standard Cont monad and F#
--   async workflow but only the result of applying the continuations
--   return the <a>Event</a> computation.
data Cont m a


-- | Tested with: GHC 7.8.3
--   
--   A value in the <a>Process</a> monad represents a discontinuous process
--   that can suspend in any simulation time point and then resume later in
--   the same or another time point.
--   
--   The process of this type can involve the <tt>Event</tt>,
--   <tt>Dynamics</tt> and <tt>Simulation</tt> computations. Moreover, a
--   value in the <tt>Process</tt> monad can be run within the
--   <tt>Event</tt> computation.
--   
--   A value of the <a>ProcessId</a> type is just an identifier of such a
--   process.
--   
--   The characteristic property of the <tt>Process</tt> type is function
--   <a>holdProcess</a> that suspends the current process for the specified
--   time interval.
module Simulation.Aivika.Trans.Process

-- | Represents a process identifier.
data ProcessId m

-- | Specifies a discontinuous process that can suspend at any time and
--   then resume later.
data Process m a

-- | A type class to lift the <a>Process</a> computation into other
--   computations.
class ProcessLift t
liftProcess :: (ProcessLift t, MonadComp m) => Process m a -> t m a

-- | Run immediately the process. A new <a>ProcessId</a> identifier will be
--   assigned to the process.
--   
--   To run the process at the specified time, you can use the
--   <a>enqueueProcess</a> function.
runProcess :: MonadComp m => Process m () -> Event m ()

-- | Run immediately the process with the specified identifier. It will be
--   more efficient than as you would specify the process identifier with
--   help of the <a>processUsingId</a> combinator and then would call
--   <a>runProcess</a>.
--   
--   To run the process at the specified time, you can use the
--   <a>enqueueProcessUsingId</a> function.
runProcessUsingId :: MonadComp m => ProcessId m -> Process m () -> Event m ()

-- | Run the process in the start time immediately involving all pending
--   <a>CurrentEvents</a> in the computation too.
runProcessInStartTime :: MonadComp m => Process m () -> Simulation m ()

-- | Run the process in the start time immediately using the specified
--   identifier and involving all pending <a>CurrentEvents</a> in the
--   computation too.
runProcessInStartTimeUsingId :: MonadComp m => ProcessId m -> Process m () -> Simulation m ()

-- | Run the process in the final simulation time immediately involving all
--   pending <a>CurrentEvents</a> in the computation too.
runProcessInStopTime :: MonadComp m => Process m () -> Simulation m ()

-- | Run the process in the final simulation time immediately using the
--   specified identifier and involving all pending <a>CurrentEvents</a> in
--   the computation too.
runProcessInStopTimeUsingId :: MonadComp m => ProcessId m -> Process m () -> Simulation m ()

-- | Spawn the child process. In case of cancelling one of the processes,
--   other process will be cancelled too.
spawnProcess :: MonadComp m => Process m () -> Process m ()

-- | Spawn the child process specifying the process identifier. In case of
--   cancelling one of the processes, other process will be cancelled too.
spawnProcessUsingId :: MonadComp m => ProcessId m -> Process m () -> Process m ()

-- | Spawn the child process specifying how the child and parent processes
--   should be cancelled in case of need.
spawnProcessWith :: MonadComp m => ContCancellation -> Process m () -> Process m ()

-- | Spawn the child process specifying how the child and parent processes
--   should be cancelled in case of need.
spawnProcessUsingIdWith :: MonadComp m => ContCancellation -> ProcessId m -> Process m () -> Process m ()

-- | Enqueue the process that will be then started at the specified time
--   from the event queue.
enqueueProcess :: MonadComp m => Double -> Process m () -> Event m ()

-- | Enqueue the process that will be then started at the specified time
--   from the event queue.
enqueueProcessUsingId :: MonadComp m => Double -> ProcessId m -> Process m () -> Event m ()

-- | Create a new process identifier.
newProcessId :: MonadComp m => Simulation m (ProcessId m)

-- | Return the current process identifier.
processId :: MonadComp m => Process m (ProcessId m)

-- | Allow calling the process with the specified identifier. It creates a
--   nested process when canceling any of two, or raising an <tt>IO</tt>
--   exception in any of the both, affects the <a>Process</a> computation.
--   
--   At the same time, the interruption has no such effect as it requires
--   explicit specifying the <a>ProcessId</a> identifier of the nested
--   process itself, that is the nested process cannot be interrupted using
--   only the parent process identifier.
processUsingId :: MonadComp m => ProcessId m -> Process m a -> Process m a

-- | Hold the process for the specified time period.
holdProcess :: MonadComp m => Double -> Process m ()

-- | Interrupt a process with the specified identifier if the process is
--   held by computation <a>holdProcess</a>.
interruptProcess :: MonadComp m => ProcessId m -> Event m ()

-- | Test whether the process with the specified identifier was
--   interrupted.
processInterrupted :: MonadComp m => ProcessId m -> Event m Bool

-- | Passivate the process.
passivateProcess :: MonadComp m => Process m ()

-- | Test whether the process with the specified identifier is passivated.
processPassive :: MonadComp m => ProcessId m -> Event m Bool

-- | Reactivate a process with the specified identifier.
reactivateProcess :: MonadComp m => ProcessId m -> Event m ()

-- | Cancel a process with the specified identifier, interrupting it if
--   needed.
cancelProcessWithId :: MonadComp m => ProcessId m -> Event m ()

-- | The process cancels itself.
cancelProcess :: (MonadComp m, MonadIO m) => Process m a

-- | Test whether the process with the specified identifier was cancelled.
processCancelled :: MonadComp m => ProcessId m -> Event m Bool

-- | Return a signal that notifies about cancelling the process with the
--   specified identifier.
processCancelling :: ProcessId m -> Signal m ()

-- | Register a handler that will be invoked in case of cancelling the
--   current process.
whenCancellingProcess :: MonadComp m => Event m () -> Process m ()

-- | Await the signal.
processAwait :: MonadComp m => Signal m a -> Process m a

-- | Yield to allow other <a>Process</a> and <a>Event</a> computations to
--   run at the current simulation time point.
processYield :: MonadComp m => Process m ()

-- | Try to run the child process within the specified timeout. If the
--   process will finish successfully within this time interval then the
--   result wrapped in <a>Just</a> will be returned; otherwise, the child
--   process will be cancelled and <a>Nothing</a> will be returned.
--   
--   If an exception is raised in the child process then it is propagated
--   to the parent computation as well.
--   
--   A cancellation of the child process doesn't lead to cancelling the
--   parent process. Then <a>Nothing</a> is returned within the
--   computation.
timeoutProcess :: (MonadComp m, MonadIO m) => Double -> Process m a -> Process m (Maybe a)

-- | Try to run the child process with the given identifier within the
--   specified timeout. If the process will finish successfully within this
--   time interval then the result wrapped in <a>Just</a> will be returned;
--   otherwise, the child process will be cancelled and <a>Nothing</a> will
--   be returned.
--   
--   If an exception is raised in the child process then it is propagated
--   to the parent computation as well.
--   
--   A cancellation of the child process doesn't lead to cancelling the
--   parent process. Then <a>Nothing</a> is returned within the
--   computation.
timeoutProcessUsingId :: (MonadComp m, MonadIO m) => Double -> ProcessId m -> Process m a -> Process m (Maybe a)

-- | Execute the specified computations in parallel within the current
--   computation and return their results. The cancellation of any of the
--   nested computations affects the current computation. The exception
--   raised in any of the nested computations is propagated to the current
--   computation as well.
--   
--   Here word <tt>parallel</tt> literally means that the computations are
--   actually executed on a single operating system thread but they are
--   processed simultaneously by the event queue.
--   
--   New <a>ProcessId</a> identifiers will be assigned to the started
--   processes.
processParallel :: MonadComp m => [Process m a] -> Process m [a]

-- | Like <a>processParallel</a> but allows specifying the process
--   identifiers. It will be more efficient than as you would specify the
--   process identifiers with help of the <a>processUsingId</a> combinator
--   and then would call <a>processParallel</a>.
processParallelUsingIds :: MonadComp m => [(ProcessId m, Process m a)] -> Process m [a]

-- | Like <a>processParallel</a> but ignores the result.
processParallel_ :: MonadComp m => [Process m a] -> Process m ()

-- | Like <a>processParallelUsingIds</a> but ignores the result.
processParallelUsingIds_ :: MonadComp m => [(ProcessId m, Process m a)] -> Process m ()

-- | Exception handling within <a>Process</a> computations.
catchProcess :: (MonadComp m, Exception e) => Process m a -> (e -> Process m a) -> Process m a

-- | A computation with finalization part.
finallyProcess :: MonadComp m => Process m a -> Process m b -> Process m a

-- | Throw the exception with the further exception handling.
--   
--   By some reason, an exception raised with help of the standard
--   <a>throw</a> function is not handled properly within <a>Process</a>
--   computation, altough it will be still handled if it will be wrapped in
--   the <a>IO</a> monad. Therefore, you should use specialised functions
--   like the stated one that use the <a>throw</a> function but within the
--   <a>IO</a> computation, which allows already handling the exception.
throwProcess :: (MonadComp m, Exception e) => e -> Process m a

-- | Zip two parallel processes waiting for the both.
zipProcessParallel :: MonadComp m => Process m a -> Process m b -> Process m (a, b)

-- | Zip three parallel processes waiting for their results.
zip3ProcessParallel :: MonadComp m => Process m a -> Process m b -> Process m c -> Process m (a, b, c)

-- | Unzip the process using memoization so that the both returned
--   processes could be applied independently, although they will refer to
--   the same pair of values.
unzipProcess :: (MonadComp m, MonadIO m) => Process m (a, b) -> Simulation m (Process m a, Process m b)

-- | Memoize the process so that it would always return the same value
--   within the simulation run.
memoProcess :: MonadComp m => Process m a -> Simulation m (Process m a)

-- | A computation that never computes the result. It behaves like a black
--   hole for the discontinuous process, although such a process can still
--   be canceled outside (see <a>cancelProcessWithId</a>), but then only
--   its finalization parts (see <a>finallyProcess</a>) will be called,
--   usually, to release the resources acquired before.
neverProcess :: MonadComp m => Process m a

-- | Show the debug message with the current simulation time.
traceProcess :: MonadComp m => String -> Process m a -> Process m a


-- | Tested with: GHC 7.8.3
--   
--   This module defines the resource which can be acquired and then
--   released by the discontinuous process <a>Process</a>. The resource can
--   be either limited by the upper bound (run-time check), or it can have
--   no upper bound. The latter is useful for modeling the infinite queue,
--   for example.
module Simulation.Aivika.Trans.Resource

-- | The ordinary FCFS (First Come - First Serviced) resource.
type FCFSResource m = Resource m FCFS

-- | The ordinary LCFS (Last Come - First Serviced) resource.
type LCFSResource m = Resource m LCFS

-- | The SIRO (Serviced in Random Order) resource.
type SIROResource m = Resource m SIRO

-- | The resource with static priorities.
type PriorityResource m = Resource m StaticPriorities

-- | Represents the resource with strategy <tt>s</tt> applied for queuing
--   the requests.
data Resource m s

-- | Create a new FCFS resource with the specified initial count which
--   value becomes the upper bound as well.
newFCFSResource :: MonadComp m => Int -> Simulation m (FCFSResource m)

-- | Create a new FCFS resource with the specified initial and maximum
--   counts, where <a>Nothing</a> means that the resource has no upper
--   bound.
newFCFSResourceWithMaxCount :: MonadComp m => Int -> Maybe Int -> Simulation m (FCFSResource m)

-- | Create a new LCFS resource with the specified initial count which
--   value becomes the upper bound as well.
newLCFSResource :: MonadComp m => Int -> Simulation m (LCFSResource m)

-- | Create a new LCFS resource with the specified initial and maximum
--   counts, where <a>Nothing</a> means that the resource has no upper
--   bound.
newLCFSResourceWithMaxCount :: MonadComp m => Int -> Maybe Int -> Simulation m (LCFSResource m)

-- | Create a new SIRO resource with the specified initial count which
--   value becomes the upper bound as well.
newSIROResource :: MonadComp m => Int -> Simulation m (SIROResource m)

-- | Create a new SIRO resource with the specified initial and maximum
--   counts, where <a>Nothing</a> means that the resource has no upper
--   bound.
newSIROResourceWithMaxCount :: MonadComp m => Int -> Maybe Int -> Simulation m (SIROResource m)

-- | Create a new priority resource with the specified initial count which
--   value becomes the upper bound as well.
newPriorityResource :: MonadComp m => Int -> Simulation m (PriorityResource m)

-- | Create a new priority resource with the specified initial and maximum
--   counts, where <a>Nothing</a> means that the resource has no upper
--   bound.
newPriorityResourceWithMaxCount :: MonadComp m => Int -> Maybe Int -> Simulation m (PriorityResource m)

-- | Create a new resource with the specified queue strategy and initial
--   count. The last value becomes the upper bound as well.
newResource :: (MonadComp m, QueueStrategy m s) => s -> Int -> Simulation m (Resource m s)

-- | Create a new resource with the specified queue strategy, initial and
--   maximum counts, where <a>Nothing</a> means that the resource has no
--   upper bound.
newResourceWithMaxCount :: (MonadComp m, QueueStrategy m s) => s -> Int -> Maybe Int -> Simulation m (Resource m s)

-- | Return the strategy applied for queuing the requests.
resourceStrategy :: Resource m s -> s

-- | Return the maximum count of the resource, where <a>Nothing</a> means
--   that the resource has no upper bound.
resourceMaxCount :: Resource m s -> Maybe Int

-- | Return the current count of the resource.
resourceCount :: MonadComp m => Resource m s -> Event m Int

-- | Request for the resource decreasing its count in case of success,
--   otherwise suspending the discontinuous process until some other
--   process releases the resource.
requestResource :: (MonadComp m, EnqueueStrategy m s) => Resource m s -> Process m ()

-- | Request with the priority for the resource decreasing its count in
--   case of success, otherwise suspending the discontinuous process until
--   some other process releases the resource.
requestResourceWithPriority :: (MonadComp m, PriorityQueueStrategy m s p) => Resource m s -> p -> Process m ()

-- | Try to request for the resource decreasing its count in case of
--   success and returning <a>True</a> in the <a>Event</a> monad;
--   otherwise, returning <a>False</a>.
tryRequestResourceWithinEvent :: MonadComp m => Resource m s -> Event m Bool

-- | Release the resource increasing its count and resuming one of the
--   previously suspended processes as possible.
releaseResource :: (MonadComp m, DequeueStrategy m s) => Resource m s -> Process m ()

-- | Release the resource increasing its count and resuming one of the
--   previously suspended processes as possible.
releaseResourceWithinEvent :: (MonadComp m, DequeueStrategy m s) => Resource m s -> Event m ()

-- | Acquire the resource, perform some action and safely release the
--   resource in the end, even if the <a>IOException</a> was raised within
--   the action.
usingResource :: (MonadComp m, EnqueueStrategy m s) => Resource m s -> Process m a -> Process m a

-- | Acquire the resource with the specified priority, perform some action
--   and safely release the resource in the end, even if the
--   <a>IOException</a> was raised within the action.
usingResourceWithPriority :: (MonadComp m, PriorityQueueStrategy m s p) => Resource m s -> p -> Process m a -> Process m a


-- | Tested with: GHC 7.8.3
--   
--   The <a>Task</a> value represents a process that was already started in
--   background. We can check the completion of the task, receive
--   notifications about changing its state and even suspend an outer
--   process awaiting the final result of the task. It complements the
--   <a>Process</a> monad as it allows immediately continuing the main
--   computation without suspension.
module Simulation.Aivika.Trans.Task

-- | The task represents a process that was already started in background.
data Task m a

-- | Represents the result of the task.
data TaskResult a

-- | the task was successfully completed and it returned the specified
--   result
TaskCompleted :: a -> TaskResult a

-- | the specified exception was raised when performing the task.
TaskError :: SomeException -> TaskResult a

-- | the task was cancelled
TaskCancelled :: TaskResult a

-- | Return an identifier for the process that was launched in background
--   for this task.
taskId :: Task m a -> ProcessId m

-- | Try to get the task result immediately without suspension.
tryGetTaskResult :: MonadComp m => Task m a -> Event m (Maybe (TaskResult a))

-- | Return the task result suspending the outer process if required.
taskResult :: MonadComp m => Task m a -> Process m (TaskResult a)

-- | Return a signal that notifies about receiving the result of the task.
taskResultReceived :: Task m a -> Signal m (TaskResult a)

-- | Return an outer process that behaves like the task itself except for
--   one thing: if the outer process is cancelled then it is not enough to
--   cancel the task.
taskProcess :: MonadComp m => Task m a -> Process m a

-- | Cancel the task.
cancelTask :: MonadComp m => Task m a -> Event m ()

-- | Test whether the task was cancelled.
taskCancelled :: MonadComp m => Task m a -> Event m Bool

-- | Run the process in background and return the corresponded task
--   immediately.
runTask :: MonadComp m => Process m a -> Event m (Task m a)

-- | Run the process with the specified identifier in background and return
--   the corresponded task immediately.
runTaskUsingId :: MonadComp m => ProcessId m -> Process m a -> Event m (Task m a)

-- | Run a child process in background and return immediately the
--   corresponded task.
spawnTask :: MonadComp m => Process m a -> Process m (Task m a)

-- | Run using the specified identifier a child process in background and
--   return immediately the corresponded task.
spawnTaskUsingId :: MonadComp m => ProcessId m -> Process m a -> Process m (Task m a)

-- | Run a child process in background and return immediately the
--   corresponded task.
spawnTaskWith :: MonadComp m => ContCancellation -> Process m a -> Process m (Task m a)

-- | Run using the specified identifier a child process in background and
--   return immediately the corresponded task.
spawnTaskUsingIdWith :: MonadComp m => ContCancellation -> ProcessId m -> Process m a -> Process m (Task m a)

-- | Enqueue the process that will be started at the specified time from
--   the event queue. It returns the corresponded task immediately.
enqueueTask :: MonadComp m => Double -> Process m a -> Event m (Task m a)

-- | Enqueue the process that will be started at the specified time with
--   the given identifier from the event queue. It returns the corresponded
--   task immediately.
enqueueTaskUsingId :: MonadComp m => Double -> ProcessId m -> Process m a -> Event m (Task m a)


-- | Tested with: GHC 7.8.3
--   
--   This module defines a queue that can use the specified strategies. So,
--   having only the <a>FCFS</a>, <a>LCFS</a>, <a>SIRO</a> and
--   <a>StaticPriorities</a> strategies, you can build 4 x 4 x 4 = 64
--   different types of the queue, each of them will have its own
--   behaviour.
module Simulation.Aivika.Trans.Queue

-- | A type synonym for the ordinary FIFO queue also known as the FCFS
--   (First Come - First Serviced) queue.
type FCFSQueue m a = Queue m FCFS FCFS FCFS a

-- | A type synonym for the ordinary LIFO queue also known as the LCFS
--   (Last Come - First Serviced) queue.
type LCFSQueue m a = Queue m FCFS LCFS FCFS a

-- | A type synonym for the SIRO (Serviced in Random Order) queue.
type SIROQueue m a = Queue m FCFS SIRO FCFS a

-- | A type synonym for the queue with static priorities applied when
--   storing the elements in the queue.
type PriorityQueue m a = Queue m FCFS StaticPriorities FCFS a

-- | Represents a queue using the specified strategies for enqueueing
--   (input), <tt>si</tt>, internal storing (in memory), <tt>sm</tt>, and
--   dequeueing (output), <tt>so</tt>, where <tt>a</tt> denotes the type of
--   items stored in the queue. Type <tt>m</tt> denotes the underlying
--   monad within which the simulation executes.
data Queue m si sm so a

-- | Create a new FCFS queue with the specified capacity.
newFCFSQueue :: MonadComp m => Int -> Event m (FCFSQueue m a)

-- | Create a new LCFS queue with the specified capacity.
newLCFSQueue :: MonadComp m => Int -> Event m (LCFSQueue m a)

-- | Create a new SIRO queue with the specified capacity.
newSIROQueue :: MonadComp m => Int -> Event m (SIROQueue m a)

-- | Create a new priority queue with the specified capacity.
newPriorityQueue :: MonadComp m => Int -> Event m (PriorityQueue m a)

-- | Create a new queue with the specified strategies and capacity.
newQueue :: (MonadComp m, QueueStrategy m si, QueueStrategy m sm, QueueStrategy m so) => si -> sm -> so -> Int -> Event m (Queue m si sm so a)

-- | The strategy applied to the enqueueing (input) processes when the
--   queue is full.
enqueueStrategy :: Queue m si sm so a -> si

-- | The strategy applied when storing (in memory) items in the queue.
enqueueStoringStrategy :: Queue m si sm so a -> sm

-- | The strategy applied to the dequeueing (output) processes when the
--   queue is empty.
dequeueStrategy :: Queue m si sm so a -> so

-- | Test whether the queue is empty.
--   
--   See also <a>queueNullChanged</a> and <a>queueNullChanged_</a>.
queueNull :: MonadComp m => Queue m si sm so a -> Event m Bool

-- | Test whether the queue is full.
--   
--   See also <a>queueFullChanged</a> and <a>queueFullChanged_</a>.
queueFull :: MonadComp m => Queue m si sm so a -> Event m Bool

-- | The queue capacity.
queueMaxCount :: Queue m si sm so a -> Int

-- | Return the current queue size.
--   
--   See also <a>queueCountStats</a>, <a>queueCountChanged</a> and
--   <a>queueCountChanged_</a>.
queueCount :: MonadComp m => Queue m si sm so a -> Event m Int

-- | Return the queue size statistics.
queueCountStats :: MonadComp m => Queue m si sm so a -> Event m (TimingStats Int)

-- | Return the total number of input items that were enqueued.
--   
--   See also <a>enqueueCountChanged</a> and <a>enqueueCountChanged_</a>.
enqueueCount :: MonadComp m => Queue m si sm so a -> Event m Int

-- | Return the number of lost items.
--   
--   See also <a>enqueueLostCountChanged</a> and
--   <a>enqueueLostCountChanged_</a>.
enqueueLostCount :: MonadComp m => Queue m si sm so a -> Event m Int

-- | Return the total number of input items that were stored.
--   
--   See also <a>enqueueStoreCountChanged</a> and
--   <a>enqueueStoreCountChanged_</a>.
enqueueStoreCount :: MonadComp m => Queue m si sm so a -> Event m Int

-- | Return the total number of requests for dequeueing the items, not
--   taking into account the failed attempts to dequeue immediately without
--   suspension.
--   
--   See also <a>dequeueCountChanged</a> and <a>dequeueCountChanged_</a>.
dequeueCount :: MonadComp m => Queue m si sm so a -> Event m Int

-- | Return the total number of output items that were actually dequeued.
--   
--   See also <a>dequeueExtractCountChanged</a> and
--   <a>dequeueExtractCountChanged_</a>.
dequeueExtractCount :: MonadComp m => Queue m si sm so a -> Event m Int

-- | Return the load factor: the queue size divided by its maximum size.
--   
--   See also <a>queueLoadFactorChanged</a> and
--   <a>queueLoadFactorChanged_</a>.
queueLoadFactor :: MonadComp m => Queue m si sm so a -> Event m Double

-- | Return the rate of the input items that were enqueued: how many items
--   per time.
enqueueRate :: MonadComp m => Queue m si sm so a -> Event m Double

-- | Return the rate of the items that were stored: how many items per
--   time.
enqueueStoreRate :: MonadComp m => Queue m si sm so a -> Event m Double

-- | Return the rate of the requests for dequeueing the items: how many
--   requests per time. It does not include the failed attempts to dequeue
--   immediately without suspension.
dequeueRate :: MonadComp m => Queue m si sm so a -> Event m Double

-- | Return the rate of the output items that were actually dequeued: how
--   many items per time.
dequeueExtractRate :: MonadComp m => Queue m si sm so a -> Event m Double

-- | Return the wait time from the time at which the item was stored in the
--   queue to the time at which it was dequeued.
--   
--   See also <a>queueWaitTimeChanged</a> and <a>queueWaitTimeChanged_</a>.
queueWaitTime :: MonadComp m => Queue m si sm so a -> Event m (SamplingStats Double)

-- | Return the total wait time from the time at which the enqueueing
--   operation was initiated to the time at which the item was dequeued.
--   
--   In some sense, <tt>queueTotalWaitTime == queueInputWaitTime +
--   queueWaitTime</tt>.
--   
--   See also <a>queueTotalWaitTimeChanged</a> and
--   <a>queueTotalWaitTimeChanged_</a>.
queueTotalWaitTime :: MonadComp m => Queue m si sm so a -> Event m (SamplingStats Double)

-- | Return the enqueue wait time from the time at which the enqueueing
--   operation was initiated to the time at which the item was stored in
--   the queue.
--   
--   See also <a>enqueueWaitTimeChanged</a> and
--   <a>enqueueWaitTimeChanged_</a>.
enqueueWaitTime :: MonadComp m => Queue m si sm so a -> Event m (SamplingStats Double)

-- | Return the dequeue wait time from the time at which the item was
--   requested for dequeueing to the time at which it was actually
--   dequeued.
--   
--   See also <a>dequeueWaitTimeChanged</a> and
--   <a>dequeueWaitTimeChanged_</a>.
dequeueWaitTime :: MonadComp m => Queue m si sm so a -> Event m (SamplingStats Double)

-- | Return a long-term average queue rate calculated as the average queue
--   size divided by the average wait time.
--   
--   This value may be less than the actual arrival rate as the queue is
--   finite and new arrivals may be locked while the queue remains full.
--   
--   See also <a>queueRateChanged</a> and <a>queueRateChanged_</a>.
queueRate :: MonadComp m => Queue m si sm so a -> Event m Double

-- | Dequeue suspending the process if the queue is empty.
dequeue :: (MonadComp m, DequeueStrategy m si, DequeueStrategy m sm, EnqueueStrategy m so) => Queue m si sm so a -> Process m a

-- | Dequeue with the output priority suspending the process if the queue
--   is empty.
dequeueWithOutputPriority :: (MonadComp m, DequeueStrategy m si, DequeueStrategy m sm, PriorityQueueStrategy m so po) => Queue m si sm so a -> po -> Process m a

-- | Try to dequeue immediately.
tryDequeue :: (MonadComp m, DequeueStrategy m si, DequeueStrategy m sm) => Queue m si sm so a -> Event m (Maybe a)

-- | Enqueue the item suspending the process if the queue is full.
enqueue :: (MonadComp m, EnqueueStrategy m si, EnqueueStrategy m sm, DequeueStrategy m so) => Queue m si sm so a -> a -> Process m ()

-- | Enqueue with the input priority the item suspending the process if the
--   queue is full.
enqueueWithInputPriority :: (MonadComp m, PriorityQueueStrategy m si pi, EnqueueStrategy m sm, DequeueStrategy m so) => Queue m si sm so a -> pi -> a -> Process m ()

-- | Enqueue with the storing priority the item suspending the process if
--   the queue is full.
enqueueWithStoringPriority :: (MonadComp m, EnqueueStrategy m si, PriorityQueueStrategy m sm pm, DequeueStrategy m so) => Queue m si sm so a -> pm -> a -> Process m ()

-- | Enqueue with the input and storing priorities the item suspending the
--   process if the queue is full.
enqueueWithInputStoringPriorities :: (MonadComp m, PriorityQueueStrategy m si pi, PriorityQueueStrategy m sm pm, DequeueStrategy m so) => Queue m si sm so a -> pi -> pm -> a -> Process m ()

-- | Try to enqueue the item. Return <a>False</a> in the monad if the queue
--   is full.
tryEnqueue :: (MonadComp m, EnqueueStrategy m sm, DequeueStrategy m so) => Queue m si sm so a -> a -> Event m Bool

-- | Try to enqueue with the storing priority the item. Return <a>False</a>
--   in the monad if the queue is full.
tryEnqueueWithStoringPriority :: (MonadComp m, PriorityQueueStrategy m sm pm, DequeueStrategy m so) => Queue m si sm so a -> pm -> a -> Event m Bool

-- | Try to enqueue the item. If the queue is full then the item will be
--   lost and <a>False</a> will be returned.
enqueueOrLost :: (MonadComp m, EnqueueStrategy m sm, DequeueStrategy m so) => Queue m si sm so a -> a -> Event m Bool

-- | Try to enqueue the item. If the queue is full then the item will be
--   lost.
enqueueOrLost_ :: (MonadComp m, EnqueueStrategy m sm, DequeueStrategy m so) => Queue m si sm so a -> a -> Event m ()

-- | Try to enqueue with the storing priority the item. If the queue is
--   full then the item will be lost and <a>False</a> will be returned.
enqueueWithStoringPriorityOrLost :: (MonadComp m, PriorityQueueStrategy m sm pm, DequeueStrategy m so) => Queue m si sm so a -> pm -> a -> Event m Bool

-- | Try to enqueue with the storing priority the item. If the queue is
--   full then the item will be lost.
enqueueWithStoringPriorityOrLost_ :: (MonadComp m, PriorityQueueStrategy m sm pm, DequeueStrategy m so) => Queue m si sm so a -> pm -> a -> Event m ()

-- | Wait while the queue is full.
waitWhileFullQueue :: MonadComp m => Queue m si sm so a -> Process m ()

-- | Return the summary for the queue with desciption of its properties and
--   activities using the specified indent.
queueSummary :: (MonadComp m, Show si, Show sm, Show so) => Queue m si sm so a -> Int -> Event m ShowS

-- | Signal when the <a>queueNull</a> property value has changed.
queueNullChanged :: MonadComp m => Queue m si sm so a -> Signal m Bool

-- | Signal when the <a>queueNull</a> property value has changed.
queueNullChanged_ :: MonadComp m => Queue m si sm so a -> Signal m ()

-- | Signal when the <a>queueFull</a> property value has changed.
queueFullChanged :: MonadComp m => Queue m si sm so a -> Signal m Bool

-- | Signal when the <a>queueFull</a> property value has changed.
queueFullChanged_ :: MonadComp m => Queue m si sm so a -> Signal m ()

-- | Signal when the <a>queueCount</a> property value has changed.
queueCountChanged :: MonadComp m => Queue m si sm so a -> Signal m Int

-- | Signal when the <a>queueCount</a> property value has changed.
queueCountChanged_ :: MonadComp m => Queue m si sm so a -> Signal m ()

-- | Signal when the <a>enqueueCount</a> property value has changed.
enqueueCountChanged :: MonadComp m => Queue m si sm so a -> Signal m Int

-- | Signal when the <a>enqueueCount</a> property value has changed.
enqueueCountChanged_ :: MonadComp m => Queue m si sm so a -> Signal m ()

-- | Signal when the <a>enqueueLostCount</a> property value has changed.
enqueueLostCountChanged :: MonadComp m => Queue m si sm so a -> Signal m Int

-- | Signal when the <a>enqueueLostCount</a> property value has changed.
enqueueLostCountChanged_ :: MonadComp m => Queue m si sm so a -> Signal m ()

-- | Signal when the <a>enqueueStoreCount</a> property value has changed.
enqueueStoreCountChanged :: MonadComp m => Queue m si sm so a -> Signal m Int

-- | Signal when the <a>enqueueStoreCount</a> property value has changed.
enqueueStoreCountChanged_ :: MonadComp m => Queue m si sm so a -> Signal m ()

-- | Signal when the <a>dequeueCount</a> property value has changed.
dequeueCountChanged :: MonadComp m => Queue m si sm so a -> Signal m Int

-- | Signal when the <a>dequeueCount</a> property value has changed.
dequeueCountChanged_ :: MonadComp m => Queue m si sm so a -> Signal m ()

-- | Signal when the <a>dequeueExtractCount</a> property value has changed.
dequeueExtractCountChanged :: MonadComp m => Queue m si sm so a -> Signal m Int

-- | Signal when the <a>dequeueExtractCount</a> property value has changed.
dequeueExtractCountChanged_ :: MonadComp m => Queue m si sm so a -> Signal m ()

-- | Signal when the <a>queueLoadFactor</a> property value has changed.
queueLoadFactorChanged :: MonadComp m => Queue m si sm so a -> Signal m Double

-- | Signal when the <a>queueLoadFactor</a> property value has changed.
queueLoadFactorChanged_ :: MonadComp m => Queue m si sm so a -> Signal m ()

-- | Signal when the <a>queueWaitTime</a> property value has changed.
queueWaitTimeChanged :: MonadComp m => Queue m si sm so a -> Signal m (SamplingStats Double)

-- | Signal when the <a>queueWaitTime</a> property value has changed.
queueWaitTimeChanged_ :: MonadComp m => Queue m si sm so a -> Signal m ()

-- | Signal when the <a>queueTotalWaitTime</a> property value has changed.
queueTotalWaitTimeChanged :: MonadComp m => Queue m si sm so a -> Signal m (SamplingStats Double)

-- | Signal when the <a>queueTotalWaitTime</a> property value has changed.
queueTotalWaitTimeChanged_ :: MonadComp m => Queue m si sm so a -> Signal m ()

-- | Signal when the <a>enqueueWaitTime</a> property value has changed.
enqueueWaitTimeChanged :: MonadComp m => Queue m si sm so a -> Signal m (SamplingStats Double)

-- | Signal when the <a>enqueueWaitTime</a> property value has changed.
enqueueWaitTimeChanged_ :: MonadComp m => Queue m si sm so a -> Signal m ()

-- | Signal when the <a>dequeueWaitTime</a> property value has changed.
dequeueWaitTimeChanged :: MonadComp m => Queue m si sm so a -> Signal m (SamplingStats Double)

-- | Signal when the <a>dequeueWaitTime</a> property value has changed.
dequeueWaitTimeChanged_ :: MonadComp m => Queue m si sm so a -> Signal m ()

-- | Signal when the <a>queueRate</a> property value has changed.
queueRateChanged :: MonadComp m => Queue m si sm so a -> Signal m Double

-- | Signal when the <a>queueRate</a> property value has changed.
queueRateChanged_ :: MonadComp m => Queue m si sm so a -> Signal m ()

-- | Return a signal that notifies when the enqueuing operation is
--   initiated.
enqueueInitiated :: MonadComp m => Queue m si sm so a -> Signal m a

-- | Return a signal that notifies when the enqueuing operation is
--   completed and the item is stored in the internal memory of the queue.
enqueueStored :: MonadComp m => Queue m si sm so a -> Signal m a

-- | Return a signal which notifies that the item was lost when attempting
--   to add it to the full queue with help of <a>enqueueOrLost</a>,
--   <a>enqueueOrLost_</a> or similar functions that imply that the element
--   can be lost. All their names are ending with <tt>OrLost</tt> or
--   <tt>OrLost_</tt>.
--   
--   In other cases the enqueued items are not lost but the corresponded
--   process can suspend until the internal queue storage is freed.
--   Although there is one exception from this rule. If the process trying
--   to enqueue a new element was suspended but then canceled through
--   <a>cancelProcess</a> from the outside then the item will not be added.
enqueueLost :: MonadComp m => Queue m si sm so a -> Signal m a

-- | Return a signal that notifies when the dequeuing operation was
--   requested.
dequeueRequested :: MonadComp m => Queue m si sm so a -> Signal m ()

-- | Return a signal that notifies when the item was extracted from the
--   internal storage of the queue and prepared for immediate receiving by
--   the dequeuing process.
dequeueExtracted :: MonadComp m => Queue m si sm so a -> Signal m a

-- | Signal whenever any property of the queue changes.
--   
--   The property must have the corresponded signal. There are also
--   characteristics similar to the properties but that have no signals. As
--   a rule, such characteristics already depend on the simulation time and
--   therefore they may change at any time point.
queueChanged_ :: MonadComp m => Queue m si sm so a -> Signal m ()


-- | Tested with: GHC 7.8.3
--   
--   This module defines an infinite queue that can use the specified
--   strategies.
module Simulation.Aivika.Trans.Queue.Infinite

-- | A type synonym for the ordinary FIFO queue also known as the FCFS
--   (First Come - First Serviced) queue.
type FCFSQueue m a = Queue m FCFS FCFS a

-- | A type synonym for the ordinary LIFO queue also known as the LCFS
--   (Last Come - First Serviced) queue.
type LCFSQueue m a = Queue m LCFS FCFS a

-- | A type synonym for the SIRO (Serviced in Random Order) queue.
type SIROQueue m a = Queue m SIRO FCFS a

-- | A type synonym for the queue with static priorities applied when
--   storing the elements in the queue.
type PriorityQueue m a = Queue m StaticPriorities FCFS a

-- | Represents an infinite queue using the specified strategies for
--   internal storing (in memory), <tt>sm</tt>, and dequeueing (output),
--   <tt>so</tt>, where <tt>a</tt> denotes the type of items stored in the
--   queue. As usual, type <tt>m</tt> denotes the underlying computation
--   within which the simulation executes.
data Queue m sm so a

-- | Create a new infinite FCFS queue.
newFCFSQueue :: MonadComp m => Event m (FCFSQueue m a)

-- | Create a new infinite LCFS queue.
newLCFSQueue :: MonadComp m => Event m (LCFSQueue m a)

-- | Create a new infinite SIRO queue.
newSIROQueue :: MonadComp m => Event m (SIROQueue m a)

-- | Create a new infinite priority queue.
newPriorityQueue :: MonadComp m => Event m (PriorityQueue m a)

-- | Create a new infinite queue with the specified strategies.
newQueue :: (MonadComp m, QueueStrategy m sm, QueueStrategy m so) => sm -> so -> Event m (Queue m sm so a)

-- | The strategy applied when storing (in memory) items in the queue.
enqueueStoringStrategy :: Queue m sm so a -> sm

-- | The strategy applied to the dequeueing (output) processes.
dequeueStrategy :: Queue m sm so a -> so

-- | Test whether the queue is empty.
--   
--   See also <a>queueNullChanged</a> and <a>queueNullChanged_</a>.
queueNull :: MonadComp m => Queue m sm so a -> Event m Bool

-- | Return the current queue size.
--   
--   See also <a>queueCountStats</a>, <a>queueCountChanged</a> and
--   <a>queueCountChanged_</a>.
queueCount :: MonadComp m => Queue m sm so a -> Event m Int

-- | Return the queue size statistics.
queueCountStats :: MonadComp m => Queue m sm so a -> Event m (TimingStats Int)

-- | Return the total number of input items that were stored.
--   
--   See also <a>enqueueStoreCountChanged</a> and
--   <a>enqueueStoreCountChanged_</a>.
enqueueStoreCount :: MonadComp m => Queue m sm so a -> Event m Int

-- | Return the total number of requests for dequeueing the items, not
--   taking into account the failed attempts to dequeue immediately without
--   suspension.
--   
--   See also <a>dequeueCountChanged</a> and <a>dequeueCountChanged_</a>.
dequeueCount :: MonadComp m => Queue m sm so a -> Event m Int

-- | Return the total number of output items that were actually dequeued.
--   
--   See also <a>dequeueExtractCountChanged</a> and
--   <a>dequeueExtractCountChanged_</a>.
dequeueExtractCount :: MonadComp m => Queue m sm so a -> Event m Int

-- | Return the rate of the items that were stored: how many items per
--   time.
enqueueStoreRate :: MonadComp m => Queue m sm so a -> Event m Double

-- | Return the rate of the requests for dequeueing the items: how many
--   requests per time. It does not include the failed attempts to dequeue
--   immediately without suspension.
dequeueRate :: MonadComp m => Queue m sm so a -> Event m Double

-- | Return the rate of the output items that were dequeued: how many items
--   per time.
dequeueExtractRate :: MonadComp m => Queue m sm so a -> Event m Double

-- | Return the wait time from the time at which the item was stored in the
--   queue to the time at which it was dequeued.
--   
--   See also <a>queueWaitTimeChanged</a> and <a>queueWaitTimeChanged_</a>.
queueWaitTime :: MonadComp m => Queue m sm so a -> Event m (SamplingStats Double)

-- | Return the dequeue wait time from the time at which the item was
--   requested for dequeueing to the time at which it was actually
--   dequeued.
--   
--   See also <a>dequeueWaitTimeChanged</a> and
--   <a>dequeueWaitTimeChanged_</a>.
dequeueWaitTime :: MonadComp m => Queue m sm so a -> Event m (SamplingStats Double)

-- | Return a long-term average queue rate calculated as the average queue
--   size divided by the average wait time.
--   
--   See also <a>queueRateChanged</a> and <a>queueRateChanged_</a>.
queueRate :: MonadComp m => Queue m sm so a -> Event m Double

-- | Dequeue suspending the process if the queue is empty.
dequeue :: (MonadComp m, DequeueStrategy m sm, EnqueueStrategy m so) => Queue m sm so a -> Process m a

-- | Dequeue with the output priority suspending the process if the queue
--   is empty.
dequeueWithOutputPriority :: (MonadComp m, DequeueStrategy m sm, PriorityQueueStrategy m so po) => Queue m sm so a -> po -> Process m a

-- | Try to dequeue immediately.
tryDequeue :: (MonadComp m, DequeueStrategy m sm) => Queue m sm so a -> Event m (Maybe a)

-- | Enqueue the item.
enqueue :: (MonadComp m, EnqueueStrategy m sm, DequeueStrategy m so) => Queue m sm so a -> a -> Event m ()

-- | Enqueue with the storing priority the item.
enqueueWithStoringPriority :: (MonadComp m, PriorityQueueStrategy m sm pm, DequeueStrategy m so) => Queue m sm so a -> pm -> a -> Event m ()

-- | Return the summary for the queue with desciption of its properties and
--   activities using the specified indent.
queueSummary :: (MonadComp m, Show sm, Show so) => Queue m sm so a -> Int -> Event m ShowS

-- | Signal when the <a>queueNull</a> property value has changed.
queueNullChanged :: MonadComp m => Queue m sm so a -> Signal m Bool

-- | Signal when the <a>queueNull</a> property value has changed.
queueNullChanged_ :: MonadComp m => Queue m sm so a -> Signal m ()

-- | Signal when the <a>queueCount</a> property value has changed.
queueCountChanged :: MonadComp m => Queue m sm so a -> Signal m Int

-- | Signal when the <a>queueCount</a> property value has changed.
queueCountChanged_ :: MonadComp m => Queue m sm so a -> Signal m ()

-- | Signal when the <a>enqueueStoreCount</a> property value has changed.
enqueueStoreCountChanged :: MonadComp m => Queue m sm so a -> Signal m Int

-- | Signal when the <a>enqueueStoreCount</a> property value has changed.
enqueueStoreCountChanged_ :: MonadComp m => Queue m sm so a -> Signal m ()

-- | Signal when the <a>dequeueCount</a> property value has changed.
dequeueCountChanged :: MonadComp m => Queue m sm so a -> Signal m Int

-- | Signal when the <a>dequeueCount</a> property value has changed.
dequeueCountChanged_ :: MonadComp m => Queue m sm so a -> Signal m ()

-- | Signal when the <a>dequeueExtractCount</a> property value has changed.
dequeueExtractCountChanged :: MonadComp m => Queue m sm so a -> Signal m Int

-- | Signal when the <a>dequeueExtractCount</a> property value has changed.
dequeueExtractCountChanged_ :: MonadComp m => Queue m sm so a -> Signal m ()

-- | Signal when the <a>queueWaitTime</a> property value has changed.
queueWaitTimeChanged :: MonadComp m => Queue m sm so a -> Signal m (SamplingStats Double)

-- | Signal when the <a>queueWaitTime</a> property value has changed.
queueWaitTimeChanged_ :: MonadComp m => Queue m sm so a -> Signal m ()

-- | Signal when the <a>dequeueWaitTime</a> property value has changed.
dequeueWaitTimeChanged :: MonadComp m => Queue m sm so a -> Signal m (SamplingStats Double)

-- | Signal when the <a>dequeueWaitTime</a> property value has changed.
dequeueWaitTimeChanged_ :: MonadComp m => Queue m sm so a -> Signal m ()

-- | Signal when the <a>queueRate</a> property value has changed.
queueRateChanged :: MonadComp m => Queue m sm so a -> Signal m Double

-- | Signal when the <a>queueRate</a> property value has changed.
queueRateChanged_ :: MonadComp m => Queue m sm so a -> Signal m ()

-- | Return a signal that notifies when the enqueued item is stored in the
--   internal memory of the queue.
enqueueStored :: MonadComp m => Queue m sm so a -> Signal m a

-- | Return a signal that notifies when the dequeuing operation was
--   requested.
dequeueRequested :: MonadComp m => Queue m sm so a -> Signal m ()

-- | Return a signal that notifies when the item was extracted from the
--   internal storage of the queue and prepared for immediate receiving by
--   the dequeuing process.
dequeueExtracted :: MonadComp m => Queue m sm so a -> Signal m a

-- | Signal whenever any property of the queue changes.
--   
--   The property must have the corresponded signal. There are also
--   characteristics similar to the properties but that have no signals. As
--   a rule, such characteristics already depend on the simulation time and
--   therefore they may change at any time point.
queueChanged_ :: MonadComp m => Queue m sm so a -> Signal m ()


-- | Tested with: GHC 7.8.3
--   
--   The infinite stream of data in time.
module Simulation.Aivika.Trans.Stream

-- | Represents an infinite stream of data in time, some kind of
--   never-ending cons cell.
newtype Stream m a
Cons :: Process m (a, Stream m a) -> Stream m a

-- | Run the stream.
runStream :: Stream m a -> Process m (a, Stream m a)

-- | An empty stream that never returns data.
emptyStream :: MonadComp m => Stream m a

-- | Merge two streams applying the <a>FCFS</a> strategy for enqueuing the
--   input data.
mergeStreams :: MonadComp m => Stream m a -> Stream m a -> Stream m a

-- | Merge two streams.
--   
--   If you don't know what the strategy to apply, then you probably need
--   the <a>FCFS</a> strategy, or function <a>mergeStreams</a> that does
--   namely this.
mergeQueuedStreams :: (MonadComp m, EnqueueStrategy m s) => s -> Stream m a -> Stream m a -> Stream m a

-- | Merge two priority streams.
mergePriorityStreams :: (MonadComp m, PriorityQueueStrategy m s p) => s -> Stream m (p, a) -> Stream m (p, a) -> Stream m a

-- | Concatenate the input streams applying the <a>FCFS</a> strategy and
--   producing one output stream.
concatStreams :: MonadComp m => [Stream m a] -> Stream m a

-- | Concatenate the input streams producing one output stream.
--   
--   If you don't know what the strategy to apply, then you probably need
--   the <a>FCFS</a> strategy, or function <a>concatStreams</a> that does
--   namely this.
concatQueuedStreams :: (MonadComp m, EnqueueStrategy m s) => s -> [Stream m a] -> Stream m a

-- | Concatenate the input priority streams producing one output stream.
concatPriorityStreams :: (MonadComp m, PriorityQueueStrategy m s p) => s -> [Stream m (p, a)] -> Stream m a

-- | Split the input stream into the specified number of output streams
--   after applying the <a>FCFS</a> strategy for enqueuing the output
--   requests.
splitStream :: MonadComp m => Int -> Stream m a -> Simulation m [Stream m a]

-- | Split the input stream into the specified number of output streams.
--   
--   If you don't know what the strategy to apply, then you probably need
--   the <a>FCFS</a> strategy, or function <a>splitStream</a> that does
--   namely this.
splitStreamQueueing :: (MonadComp m, EnqueueStrategy m s) => s -> Int -> Stream m a -> Simulation m [Stream m a]

-- | Split the input stream into a list of output streams using the
--   specified priorities.
splitStreamPrioritising :: (MonadComp m, PriorityQueueStrategy m s p) => s -> [Stream m p] -> Stream m a -> Simulation m [Stream m a]

-- | Create a stream that will use the specified process identifier. It can
--   be useful to refer to the underlying <a>Process</a> computation which
--   can be passivated, interrupted, canceled and so on. See also the
--   <a>processUsingId</a> function for more details.
streamUsingId :: MonadComp m => ProcessId m -> Stream m a -> Stream m a

-- | Prefetch the input stream requesting for one more data item in advance
--   while the last received item is not yet fully processed in the chain
--   of streams, usually by the processors.
--   
--   You can think of this as the prefetched stream could place its latest
--   data item in some temporary space for later use, which is very useful
--   for modeling a sequence of separate and independent work places.
prefetchStream :: MonadComp m => Stream m a -> Stream m a

-- | Delay the stream by one step using the specified initial value.
delayStream :: MonadComp m => a -> Stream m a -> Stream m a

-- | Transform a stream so that the resulting stream returns a sequence of
--   arrivals saving the information about the time points at which the
--   original stream items were received by demand.
arrivalStream :: MonadComp m => Stream m a -> Stream m (Arrival a)

-- | Memoize the stream so that it would always return the same data within
--   the simulation run.
memoStream :: MonadComp m => Stream m a -> Simulation m (Stream m a)

-- | Zip two streams trying to get data sequentially.
zipStreamSeq :: MonadComp m => Stream m a -> Stream m b -> Stream m (a, b)

-- | Zip two streams trying to get data as soon as possible, launching the
--   sub-processes in parallel.
zipStreamParallel :: MonadComp m => Stream m a -> Stream m b -> Stream m (a, b)

-- | Zip three streams trying to get data sequentially.
zip3StreamSeq :: MonadComp m => Stream m a -> Stream m b -> Stream m c -> Stream m (a, b, c)

-- | Zip three streams trying to get data as soon as possible, launching
--   the sub-processes in parallel.
zip3StreamParallel :: MonadComp m => Stream m a -> Stream m b -> Stream m c -> Stream m (a, b, c)

-- | Unzip the stream.
unzipStream :: MonadComp m => Stream m (a, b) -> Simulation m (Stream m a, Stream m b)

-- | To form each new portion of data for the output stream, read data
--   sequentially from the input streams.
--   
--   This is a generalization of <a>zipStreamSeq</a>.
streamSeq :: MonadComp m => [Stream m a] -> Stream m [a]

-- | To form each new portion of data for the output stream, read data from
--   the input streams in parallel.
--   
--   This is a generalization of <a>zipStreamParallel</a>.
streamParallel :: MonadComp m => [Stream m a] -> Stream m [a]

-- | Consume the stream. It returns a process that infinitely reads data
--   from the stream and then redirects them to the provided function. It
--   is useful for modeling the process of enqueueing data in the queue
--   from the input stream.
consumeStream :: MonadComp m => (a -> Process m ()) -> Stream m a -> Process m ()

-- | Sink the stream. It returns a process that infinitely reads data from
--   the stream. The resulting computation can be a moving force to
--   simulate the whole system of the interconnected streams and
--   processors.
sinkStream :: MonadComp m => Stream m a -> Process m ()

-- | Return a stream of values generated by the specified process.
repeatProcess :: MonadComp m => Process m a -> Stream m a

-- | Map the stream according the specified function.
mapStream :: MonadComp m => (a -> b) -> Stream m a -> Stream m b

-- | Compose the stream.
mapStreamM :: MonadComp m => (a -> Process m b) -> Stream m a -> Stream m b

-- | Sequential application.
apStream :: MonadComp m => Stream m (a -> b) -> Stream m a -> Stream m b

-- | Sequential application.
apStreamM :: MonadComp m => Stream m (a -> Process m b) -> Stream m a -> Stream m b

-- | Filter only those data values that satisfy to the specified predicate.
filterStream :: MonadComp m => (a -> Bool) -> Stream m a -> Stream m a

-- | Filter only those data values that satisfy to the specified predicate.
filterStreamM :: MonadComp m => (a -> Process m Bool) -> Stream m a -> Stream m a

-- | Return a stream of values triggered by the specified signal.
--   
--   Since the time at which the values of the stream are requested for may
--   differ from the time at which the signal is triggered, it can be
--   useful to apply the <a>arrivalSignal</a> function to add the
--   information about the time points at which the signal was actually
--   received.
--   
--   The point is that the <a>Stream</a> is requested outside, while the
--   <a>Signal</a> is triggered inside. They are different by nature. The
--   former is passive, while the latter is active.
--   
--   The resulting stream may be a root of space leak as it uses an
--   internal queue to store the values received from the signal. The
--   oldest value is dequeued each time we request the stream and it is
--   returned within the computation.
--   
--   Cancel the stream's process to unsubscribe from the specified signal.
signalStream :: MonadComp m => Signal m a -> Process m (Stream m a)

-- | Return a computation of the signal that triggers values from the
--   specified stream, each time the next value of the stream is received
--   within the underlying <a>Process</a> computation.
--   
--   Cancel the returned process to stop reading from the specified stream.
streamSignal :: MonadComp m => Stream m a -> Process m (Signal m a)

-- | The stream of <a>Left</a> values.
leftStream :: MonadComp m => Stream m (Either a b) -> Stream m a

-- | The stream of <a>Right</a> values.
rightStream :: MonadComp m => Stream m (Either a b) -> Stream m b

-- | Replace the <a>Left</a> values.
replaceLeftStream :: MonadComp m => Stream m (Either a b) -> Stream m c -> Stream m (Either c b)

-- | Replace the <a>Right</a> values.
replaceRightStream :: MonadComp m => Stream m (Either a b) -> Stream m c -> Stream m (Either a c)

-- | Partition the stream of <a>Either</a> values into two streams.
partitionEitherStream :: MonadComp m => Stream m (Either a b) -> Simulation m (Stream m a, Stream m b)

-- | Show the debug messages with the current simulation time.
traceStream :: MonadComp m => Maybe String -> Maybe String -> Stream m a -> Stream m a
instance MonadComp m => Monoid (Stream m a)
instance MonadComp m => Applicative (Stream m)
instance MonadComp m => Functor (Stream m)


-- | Tested with: GHC 7.8.3
--   
--   The processor of simulation data.
module Simulation.Aivika.Trans.Processor

-- | Represents a processor of simulation data.
newtype Processor m a b
Processor :: (Stream m a -> Stream m b) -> Processor m a b

-- | Run the processor.
runProcessor :: Processor m a b -> Stream m a -> Stream m b

-- | A processor that never finishes its work producing an
--   <a>emptyStream</a>.
emptyProcessor :: MonadComp m => Processor m a b

-- | Create a simple processor by the specified handling function that runs
--   the discontinuous process for each input value to get the output.
arrProcessor :: MonadComp m => (a -> Process m b) -> Processor m a b

-- | Accumulator that outputs a value determined by the supplied function.
accumProcessor :: MonadComp m => (acc -> a -> Process m (acc, b)) -> acc -> Processor m a b

-- | Create a processor that will use the specified process identifier. It
--   can be useful to refer to the underlying <a>Process</a> computation
--   which can be passivated, interrupted, canceled and so on. See also the
--   <a>processUsingId</a> function for more details.
processorUsingId :: MonadComp m => ProcessId m -> Processor m a b -> Processor m a b

-- | This is a prefetch processor that requests for one more data item from
--   the input in advance while the latest item is not yet fully processed
--   in the chain of streams, usually by other processors.
--   
--   You can think of this as the prefetched processor could place its
--   latest data item in some temporary space for later use, which is very
--   useful for modeling a sequence of separate and independent work
--   places.
prefetchProcessor :: MonadComp m => Processor m a a

-- | A processor that delays the input stream by one step using the
--   specified initial value.
delayProcessor :: MonadComp m => a -> Processor m a a

-- | Create a buffer processor, where the process from the first argument
--   consumes the input stream but the stream passed in as the second
--   argument and produced usually by some other process is returned as an
--   output. This kind of processor is very useful for modeling the queues.
bufferProcessor :: MonadComp m => (Stream m a -> Process m ()) -> Stream m b -> Processor m a b

-- | Like <a>bufferProcessor</a> but allows creating a loop when some items
--   can be processed repeatedly. It is very useful for modeling the
--   processors with queues and loop-backs.
bufferProcessorLoop :: MonadComp m => (Stream m a -> Stream m c -> Process m ()) -> Stream m d -> Processor m d (Either e b) -> Processor m e c -> Processor m a b

-- | Return a processor with help of which we can model the queue.
--   
--   Although the function doesn't refer to the queue directly, its main
--   use case is namely a processing of the queue. The first argument
--   should be the enqueueing operation, while the second argument should
--   be the opposite dequeueing operation.
--   
--   The reason is as follows. There are many possible combinations how the
--   queues can be modeled. There is no sense to enumerate all them
--   creating a separate function for each case. We can just use
--   combinators to define exactly what we need.
--   
--   So, the queue can lose the input items if the queue is full, or the
--   input process can suspend while the queue is full, or we can use
--   priorities for enqueueing, storing and dequeueing the items in
--   different combinations. There are so many use cases!
--   
--   There is a hope that this function along with other similar functions
--   from this module is sufficient to cover the most important cases. Even
--   if it is not sufficient then you can use a more generic function
--   <a>bufferProcessor</a> which this function is based on. In case of
--   need, you can even write your own function from scratch. It is quite
--   easy actually.
queueProcessor :: MonadComp m => (a -> Process m ()) -> Process m b -> Processor m a b

-- | Like <a>queueProcessor</a> creates a queue processor but with a loop
--   when some items can be processed and then added to the queue again.
--   Also it allows specifying how two input streams of data can be merged.
queueProcessorLoopMerging :: MonadComp m => (Stream m a -> Stream m d -> Stream m e) -> (e -> Process m ()) -> Process m c -> Processor m c (Either f b) -> Processor m f d -> Processor m a b

-- | Like <a>queueProcessorLoopMerging</a> creates a queue processor with a
--   loop when some items can be processed and then added to the queue
--   again. Only it sequentially merges two input streams of data: one
--   stream that come from the external source and another stream of data
--   returned by the loop. The first stream has a priority over the second
--   one.
queueProcessorLoopSeq :: MonadComp m => (a -> Process m ()) -> Process m c -> Processor m c (Either e b) -> Processor m e a -> Processor m a b

-- | Like <a>queueProcessorLoopMerging</a> creates a queue processor with a
--   loop when some items can be processed and then added to the queue
--   again. Only it runs two simultaneous processes to enqueue the input
--   streams of data: one stream that come from the external source and
--   another stream of data returned by the loop.
queueProcessorLoopParallel :: MonadComp m => (a -> Process m ()) -> Process m c -> Processor m c (Either e b) -> Processor m e a -> Processor m a b

-- | Launches the processors sequentially using the
--   <a>prefetchProcessor</a> between them to model an autonomous work of
--   each of the processors specified.
processorSeq :: MonadComp m => [Processor m a a] -> Processor m a a

-- | Launches the processors in parallel consuming the same input stream
--   and producing a combined output stream. This version applies the
--   <a>FCFS</a> strategy both for input and output, which suits the most
--   part of uses cases.
processorParallel :: MonadComp m => [Processor m a b] -> Processor m a b

-- | Launches the specified processors in parallel consuming the same input
--   stream and producing a combined output stream.
--   
--   If you don't know what the enqueue strategies to apply, then you will
--   probably need <a>FCFS</a> for the both parameters, or function
--   <a>processorParallel</a> that does namely this.
processorQueuedParallel :: (MonadComp m, EnqueueStrategy m si, EnqueueStrategy m so) => si -> so -> [Processor m a b] -> Processor m a b

-- | Launches the specified processors in parallel using priorities for
--   combining the output.
processorPrioritisingOutputParallel :: (MonadComp m, EnqueueStrategy m si, PriorityQueueStrategy m so po) => si -> so -> [Processor m a (po, b)] -> Processor m a b

-- | Launches the specified processors in parallel using priorities for
--   consuming the intput.
processorPrioritisingInputParallel :: (MonadComp m, PriorityQueueStrategy m si pi, EnqueueStrategy m so) => si -> so -> [(Stream m pi, Processor m a b)] -> Processor m a b

-- | Launches the specified processors in parallel using priorities for
--   consuming the input and combining the output.
processorPrioritisingInputOutputParallel :: (MonadComp m, PriorityQueueStrategy m si pi, PriorityQueueStrategy m so po) => si -> so -> [(Stream m pi, Processor m a (po, b))] -> Processor m a b

-- | A processor that adds the information about the time points at which
--   the original stream items were received by demand.
arrivalProcessor :: MonadComp m => Processor m a (Arrival a)

-- | Convert the specified signal transform to a processor.
--   
--   The processor may return data with delay as the values are requested
--   by demand. Consider using the <a>arrivalSignal</a> function to provide
--   with the information about the time points at which the signal was
--   actually triggered.
--   
--   The point is that the <a>Stream</a> used in the <a>Processor</a> is
--   requested outside, while the <a>Signal</a> is triggered inside. They
--   are different by nature. The former is passive, while the latter is
--   active.
--   
--   Cancel the processor's process to unsubscribe from the signals
--   provided.
signalProcessor :: MonadComp m => (Signal m a -> Signal m b) -> Processor m a b

-- | Convert the specified processor to a signal transform.
--   
--   The processor may return data with delay as the values are requested
--   by demand. Consider using the <a>arrivalSignal</a> function to provide
--   with the information about the time points at which the signal was
--   actually triggered.
--   
--   The point is that the <a>Stream</a> used in the <a>Processor</a> is
--   requested outside, while the <a>Signal</a> is triggered inside. They
--   are different by nature. The former is passive, while the latter is
--   active.
--   
--   Cancel the returned process to unsubscribe from the signal specified.
processorSignaling :: MonadComp m => Processor m a b -> Signal m a -> Process m (Signal m b)

-- | Show the debug messages with the current simulation time.
traceProcessor :: MonadComp m => Maybe String -> Maybe String -> Processor m a b -> Processor m a b
instance MonadComp m => ArrowPlus (Processor m)
instance MonadComp m => ArrowZero (Processor m)
instance MonadComp m => ArrowChoice (Processor m)
instance MonadComp m => Arrow (Processor m)
instance Category (Processor m)


-- | Tested with: GHC 7.8.3
--   
--   The module defines the Round-Robbin processor.
module Simulation.Aivika.Trans.Processor.RoundRobbin

-- | Represents the Round-Robbin processor that tries to perform the task
--   within the specified timeout. If the task times out, then it is
--   canceled and returned to the processor again; otherwise, the
--   successful result is redirected to output.
roundRobbinProcessor :: MonadComp m => Processor m (Process m Double, Process m a) a

-- | Like <a>roundRobbinProcessor</a> but allows specifying the process
--   identifiers which must be unique for every new attemp to perform the
--   task even if the task is the same.
roundRobbinProcessorUsingIds :: MonadComp m => Processor m (Process m (Double, ProcessId m), Process m a) a


-- | Tested with: GHC 7.8.3
--   
--   It models the server that prodives a service.
module Simulation.Aivika.Trans.Server

-- | It models a server that takes <tt>a</tt> and provides <tt>b</tt>
--   having state <tt>s</tt> within underlying computation <tt>m</tt>.
data Server m s a b

-- | Contains data about the interrupted task.
data ServerInterruption a :: * -> *
ServerInterruption :: a -> Double -> Double -> ServerInterruption a

-- | The input task that was interrupted.
serverInterruptedInput :: ServerInterruption a -> a

-- | The start time of processing the task.
serverStartProcessingTime :: ServerInterruption a -> Double

-- | The time of interrupting the task.
serverInterruptionTime :: ServerInterruption a -> Double

-- | Create a new server that can provide output <tt>b</tt> by input
--   <tt>a</tt>.
--   
--   By default, it is assumed that the server cannot be interrupted,
--   because the handling of possible task interruption is rather costly
--   operation.
newServer :: MonadComp m => (a -> Process m b) -> Simulation m (Server m () a b)

-- | Create a new server that can provide output <tt>b</tt> by input
--   <tt>a</tt> starting from state <tt>s</tt>.
--   
--   By default, it is assumed that the server cannot be interrupted,
--   because the handling of possible task interruption is rather costly
--   operation.
newStateServer :: MonadComp m => (s -> a -> Process m (s, b)) -> s -> Simulation m (Server m s a b)

-- | Create a new interruptible server that can provide output <tt>b</tt>
--   by input <tt>a</tt>.
newInterruptibleServer :: MonadComp m => Bool -> (a -> Process m b) -> Simulation m (Server m () a b)

-- | Create a new interruptible server that can provide output <tt>b</tt>
--   by input <tt>a</tt> starting from state <tt>s</tt>.
newInterruptibleStateServer :: MonadComp m => Bool -> (s -> a -> Process m (s, b)) -> s -> Simulation m (Server m s a b)

-- | Return a processor for the specified server.
--   
--   The processor updates the internal state of the server. The usual case
--   is when the processor is applied only once in a chain of data
--   processing. Otherwise; every time the processor is used, the state of
--   the server changes. Sometimes it can be indeed useful if you want to
--   aggregate the statistics for different servers simultaneously, but it
--   would be more preferable to avoid this.
--   
--   If you connect different server processors returned by this function
--   in a chain with help of <a>&gt;&gt;&gt;</a> or other category
--   combinator then this chain will act as one whole, where the first
--   server will take a new task only after the last server finishes its
--   current task and requests for the next one from the previous processor
--   in the chain. This is not always that thing you might need.
--   
--   To model a sequence of the server processors working independently,
--   you should use the <a>processorSeq</a> function which separates the
--   processors with help of the <a>prefetchProcessor</a> that plays a role
--   of a small one-place buffer in that case.
--   
--   The queue processors usually have the prefetching capabilities per se,
--   where the items are already stored in the queue. Therefore, the server
--   processor should not be prefetched if it is connected directly with
--   the queue processor.
serverProcessor :: MonadComp m => Server m s a b -> Processor m a b

-- | The initial state of the server.
serverInitState :: Server m s a b -> s

-- | Return the current state of the server.
--   
--   See also <a>serverStateChanged</a> and <a>serverStateChanged_</a>.
serverState :: MonadComp m => Server m s a b -> Event m s

-- | Return the counted total time when the server was locked while
--   awaiting the input.
--   
--   The value returned changes discretely and it is usually delayed
--   relative to the current simulation time.
--   
--   See also <a>serverTotalInputWaitTimeChanged</a> and
--   <a>serverTotalInputWaitTimeChanged_</a>.
serverTotalInputWaitTime :: MonadComp m => Server m s a b -> Event m Double

-- | Return the counted total time spent by the server while processing the
--   tasks.
--   
--   The value returned changes discretely and it is usually delayed
--   relative to the current simulation time.
--   
--   See also <a>serverTotalProcessingTimeChanged</a> and
--   <a>serverTotalProcessingTimeChanged_</a>.
serverTotalProcessingTime :: MonadComp m => Server m s a b -> Event m Double

-- | Return the counted total time when the server was locked while trying
--   to deliver the output.
--   
--   The value returned changes discretely and it is usually delayed
--   relative to the current simulation time.
--   
--   See also <a>serverTotalOutputWaitTimeChanged</a> and
--   <a>serverTotalOutputWaitTimeChanged_</a>.
serverTotalOutputWaitTime :: MonadComp m => Server m s a b -> Event m Double

-- | Return the statistics of the time when the server was locked while
--   awaiting the input.
--   
--   The value returned changes discretely and it is usually delayed
--   relative to the current simulation time.
--   
--   See also <a>serverInputWaitTimeChanged</a> and
--   <a>serverInputWaitTimeChanged_</a>.
serverInputWaitTime :: MonadComp m => Server m s a b -> Event m (SamplingStats Double)

-- | Return the statistics of the time spent by the server while processing
--   the tasks.
--   
--   The value returned changes discretely and it is usually delayed
--   relative to the current simulation time.
--   
--   See also <a>serverProcessingTimeChanged</a> and
--   <a>serverProcessingTimeChanged_</a>.
serverProcessingTime :: MonadComp m => Server m s a b -> Event m (SamplingStats Double)

-- | Return the statistics of the time when the server was locked while
--   trying to deliver the output.
--   
--   The value returned changes discretely and it is usually delayed
--   relative to the current simulation time.
--   
--   See also <a>serverOutputWaitTimeChanged</a> and
--   <a>serverOutputWaitTimeChanged_</a>.
serverOutputWaitTime :: MonadComp m => Server m s a b -> Event m (SamplingStats Double)

-- | It returns the factor changing from 0 to 1, which estimates how often
--   the server was awaiting for the next input task.
--   
--   This factor is calculated as
--   
--   <pre>
--   totalInputWaitTime / (totalInputWaitTime + totalProcessingTime + totalOutputWaitTime)
--   </pre>
--   
--   As before in this module, the value returned changes discretely and it
--   is usually delayed relative to the current simulation time.
--   
--   See also <a>serverInputWaitFactorChanged</a> and
--   <a>serverInputWaitFactorChanged_</a>.
serverInputWaitFactor :: MonadComp m => Server m s a b -> Event m Double

-- | It returns the factor changing from 0 to 1, which estimates how often
--   the server was busy with direct processing its tasks.
--   
--   This factor is calculated as
--   
--   <pre>
--   totalProcessingTime / (totalInputWaitTime + totalProcessingTime + totalOutputWaitTime)
--   </pre>
--   
--   As before in this module, the value returned changes discretely and it
--   is usually delayed relative to the current simulation time.
--   
--   See also <a>serverProcessingFactorChanged</a> and
--   <a>serverProcessingFactorChanged_</a>.
serverProcessingFactor :: MonadComp m => Server m s a b -> Event m Double

-- | It returns the factor changing from 0 to 1, which estimates how often
--   the server was locked trying to deliver the output after the task is
--   finished.
--   
--   This factor is calculated as
--   
--   <pre>
--   totalOutputWaitTime / (totalInputWaitTime + totalProcessingTime + totalOutputWaitTime)
--   </pre>
--   
--   As before in this module, the value returned changes discretely and it
--   is usually delayed relative to the current simulation time.
--   
--   See also <a>serverOutputWaitFactorChanged</a> and
--   <a>serverOutputWaitFactorChanged_</a>.
serverOutputWaitFactor :: MonadComp m => Server m s a b -> Event m Double

-- | Return the summary for the server with desciption of its properties
--   and activities using the specified indent.
serverSummary :: MonadComp m => Server m s a b -> Int -> Event m ShowS

-- | Signal when the <a>serverState</a> property value has changed.
serverStateChanged :: MonadComp m => Server m s a b -> Signal m s

-- | Signal when the <a>serverState</a> property value has changed.
serverStateChanged_ :: MonadComp m => Server m s a b -> Signal m ()

-- | Signal when the <a>serverTotalInputWaitTime</a> property value has
--   changed.
serverTotalInputWaitTimeChanged :: MonadComp m => Server m s a b -> Signal m Double

-- | Signal when the <a>serverTotalInputWaitTime</a> property value has
--   changed.
serverTotalInputWaitTimeChanged_ :: MonadComp m => Server m s a b -> Signal m ()

-- | Signal when the <a>serverTotalProcessingTime</a> property value has
--   changed.
serverTotalProcessingTimeChanged :: MonadComp m => Server m s a b -> Signal m Double

-- | Signal when the <a>serverTotalProcessingTime</a> property value has
--   changed.
serverTotalProcessingTimeChanged_ :: MonadComp m => Server m s a b -> Signal m ()

-- | Signal when the <a>serverTotalOutputWaitTime</a> property value has
--   changed.
serverTotalOutputWaitTimeChanged :: MonadComp m => Server m s a b -> Signal m Double

-- | Signal when the <a>serverTotalOutputWaitTime</a> property value has
--   changed.
serverTotalOutputWaitTimeChanged_ :: MonadComp m => Server m s a b -> Signal m ()

-- | Signal when the <a>serverInputWaitTime</a> property value has changed.
serverInputWaitTimeChanged :: MonadComp m => Server m s a b -> Signal m (SamplingStats Double)

-- | Signal when the <a>serverInputWaitTime</a> property value has changed.
serverInputWaitTimeChanged_ :: MonadComp m => Server m s a b -> Signal m ()

-- | Signal when the <a>serverProcessingTime</a> property value has
--   changed.
serverProcessingTimeChanged :: MonadComp m => Server m s a b -> Signal m (SamplingStats Double)

-- | Signal when the <a>serverProcessingTime</a> property value has
--   changed.
serverProcessingTimeChanged_ :: MonadComp m => Server m s a b -> Signal m ()

-- | Signal when the <a>serverOutputWaitTime</a> property value has
--   changed.
serverOutputWaitTimeChanged :: MonadComp m => Server m s a b -> Signal m (SamplingStats Double)

-- | Signal when the <a>serverOutputWaitTime</a> property value has
--   changed.
serverOutputWaitTimeChanged_ :: MonadComp m => Server m s a b -> Signal m ()

-- | Signal when the <a>serverInputWaitFactor</a> property value has
--   changed.
serverInputWaitFactorChanged :: MonadComp m => Server m s a b -> Signal m Double

-- | Signal when the <a>serverInputWaitFactor</a> property value has
--   changed.
serverInputWaitFactorChanged_ :: MonadComp m => Server m s a b -> Signal m ()

-- | Signal when the <a>serverProcessingFactor</a> property value has
--   changed.
serverProcessingFactorChanged :: MonadComp m => Server m s a b -> Signal m Double

-- | Signal when the <a>serverProcessingFactor</a> property value has
--   changed.
serverProcessingFactorChanged_ :: MonadComp m => Server m s a b -> Signal m ()

-- | Signal when the <a>serverOutputWaitFactor</a> property value has
--   changed.
serverOutputWaitFactorChanged :: MonadComp m => Server m s a b -> Signal m Double

-- | Signal when the <a>serverOutputWaitFactor</a> property value has
--   changed.
serverOutputWaitFactorChanged_ :: MonadComp m => Server m s a b -> Signal m ()

-- | Raised when the server receives a new input task.
serverInputReceived :: MonadComp m => Server m s a b -> Signal m a

-- | Raised when the task processing by the server was interrupted.
serverTaskInterrupted :: MonadComp m => Server m s a b -> Signal m (ServerInterruption a)

-- | Raised when the server has just processed the task.
serverTaskProcessed :: MonadComp m => Server m s a b -> Signal m (a, b)

-- | Raised when the server has just delivered the output.
serverOutputProvided :: MonadComp m => Server m s a b -> Signal m (a, b)

-- | Signal whenever any property of the server changes.
serverChanged_ :: MonadComp m => Server m s a b -> Signal m ()


-- | Tested with: GHC 7.8.3
--   
--   This module defines a plain and more fast version of an updatable
--   reference that depends on the event queue but that doesn't supply with
--   the signal notification.
module Simulation.Aivika.Trans.Ref.Plain

-- | The <a>Ref</a> type represents a mutable variable similar to the
--   <a>IORef</a> variable but only dependent on the event queue, which
--   allows synchronizing the reference with the model explicitly through
--   the <a>Event</a> monad.
data Ref m a

-- | Create a new reference.
newRef :: MonadComp m => a -> Simulation m (Ref m a)

-- | Read the value of a reference.
readRef :: MonadComp m => Ref m a -> Event m a

-- | Write a new value into the reference.
writeRef :: MonadComp m => Ref m a -> a -> Event m ()

-- | Mutate the contents of the reference.
modifyRef :: MonadComp m => Ref m a -> (a -> a) -> Event m ()


-- | Tested with: GHC 7.8.3
--   
--   It represents a circuit synchronized with the event queue. Also it
--   allows creating the recursive links with help of the proc-notation.
--   
--   The implementation is based on the <a>Arrow Tutorial</a>.
module Simulation.Aivika.Trans.Circuit

-- | Represents a circuit synchronized with the event queue. Besides, it
--   allows creating the recursive links with help of the proc-notation.
newtype Circuit m a b
Circuit :: (a -> Event m (b, Circuit m a b)) -> Circuit m a b

-- | Run the circuit.
runCircuit :: Circuit m a b -> a -> Event m (b, Circuit m a b)

-- | Iterate the circuit in the integration time points returning a task
--   which completes after the final output of the circuit is received.
iterateCircuitInIntegTimes :: MonadComp m => Circuit m a a -> a -> Event m (Task m a)

-- | Iterate the circuit in the integration time points.
iterateCircuitInIntegTimes_ :: MonadComp m => Circuit m a a -> a -> Event m ()

-- | Iterate the circuit in the integration time points, interrupting the
--   iteration immediately if <a>Nothing</a> is returned within the
--   <a>Circuit</a> computation.
iterateCircuitInIntegTimesMaybe :: MonadComp m => Circuit m a (Maybe a) -> a -> Event m ()

-- | Iterate the circuit in the integration time points returning a task
--   that computes the final output of the circuit either after all points
--   are exhausted, or after the <a>Left</a> result of type <tt>b</tt> is
--   received, which interrupts the computation immediately.
iterateCircuitInIntegTimesEither :: MonadComp m => Circuit m a (Either b a) -> a -> Event m (Task m (Either b a))

-- | Iterate the circuit in the specified time points returning a task
--   which completes after the final output of the circuit is received.
iterateCircuitInTimes :: MonadComp m => [Double] -> Circuit m a a -> a -> Event m (Task m a)

-- | Iterate the circuit in the specified time points.
iterateCircuitInTimes_ :: MonadComp m => [Double] -> Circuit m a a -> a -> Event m ()

-- | Iterate the circuit in the specified time points, interrupting the
--   iteration immediately if <a>Nothing</a> is returned within the
--   <a>Circuit</a> computation.
iterateCircuitInTimesMaybe :: MonadComp m => [Double] -> Circuit m a (Maybe a) -> a -> Event m ()

-- | Iterate the circuit in the specified time points returning a task that
--   computes the final output of the circuit either after all points are
--   exhausted, or after the <a>Left</a> result of type <tt>b</tt> is
--   received, which interrupts the computation immediately.
iterateCircuitInTimesEither :: MonadComp m => [Double] -> Circuit m a (Either b a) -> a -> Event m (Task m (Either b a))

-- | Create a simple circuit by the specified handling function that runs
--   the computation for each input value to get an output.
arrCircuit :: MonadComp m => (a -> Event m b) -> Circuit m a b

-- | Accumulator that outputs a value determined by the supplied function.
accumCircuit :: MonadComp m => (acc -> a -> Event m (acc, b)) -> acc -> Circuit m a b

-- | A circuit that adds the information about the time points at which the
--   values were received.
arrivalCircuit :: MonadComp m => Circuit m a (Arrival a)

-- | Delay the input by one step using the specified initial value.
delayCircuit :: MonadComp m => a -> Circuit m a a

-- | A circuit that returns the current modeling time.
timeCircuit :: MonadComp m => Circuit m a Double

-- | Like <a>&lt;&lt;&lt;</a> but processes only the represented events.
(<?<) :: MonadComp m => Circuit m b c -> Circuit m a (Maybe b) -> Circuit m a (Maybe c)

-- | Like <a>&gt;&gt;&gt;</a> but processes only the represented events.
(>?>) :: MonadComp m => Circuit m a (Maybe b) -> Circuit m b c -> Circuit m a (Maybe c)

-- | Filter the circuit, calculating only those parts of the circuit that
--   satisfy the specified predicate.
filterCircuit :: MonadComp m => (a -> Bool) -> Circuit m a b -> Circuit m a (Maybe b)

-- | Filter the circuit within the <a>Event</a> computation, calculating
--   only those parts of the circuit that satisfy the specified predicate.
filterCircuitM :: MonadComp m => (a -> Event m Bool) -> Circuit m a b -> Circuit m a (Maybe b)

-- | The source of events that never occur.
neverCircuit :: MonadComp m => Circuit m a (Maybe b)

-- | Get a signal transform by the specified circuit.
circuitSignaling :: MonadComp m => Circuit m a b -> Signal m a -> Signal m b

-- | Transform the circuit to a processor.
circuitProcessor :: MonadComp m => Circuit m a b -> Processor m a b

-- | An approximation of the integral using Euler's method.
--   
--   This function can be rather inaccurate as it depends on the time
--   points at wich the <a>Circuit</a> computation is actuated. Also
--   Euler's method per se is not most accurate, although simple enough for
--   implementation.
--   
--   Consider using the <a>integ</a> function whenever possible. That
--   function can integrate with help of the Runge-Kutta method by the
--   specified integration time points that are passed in the simulation
--   specs to every <a>Simulation</a>, when running the model.
--   
--   At the same time, the <a>integCircuit</a> function has no mutable
--   state unlike the former. The latter consumes less memory but at the
--   cost of inaccuracy and relatively more slow simulation, had we
--   requested the integral in the same time points.
--   
--   Regarding the recursive equations, the both functions allow defining
--   them but whithin different computations (either with help of the
--   recursive do-notation or the proc-notation).
integCircuit :: MonadComp m => Double -> Circuit m Double Double

-- | Like <a>integCircuit</a> but allows either setting a new <a>Left</a>
--   integral value, or using the <a>Right</a> derivative when integrating
--   by Euler's method.
integCircuitEither :: MonadComp m => Double -> Circuit m (Either Double Double) Double

-- | A sum of differences starting from the specified initial value.
--   
--   Consider using the more accurate <a>diffsum</a> function whener
--   possible as it is calculated in every integration time point specified
--   by specs passed in to every <a>Simulation</a>, when running the model.
--   
--   At the same time, the <a>sumCircuit</a> function has no mutable state
--   and it consumes less memory than the former.
--   
--   Regarding the recursive equations, the both functions allow defining
--   them but whithin different computations (either with help of the
--   recursive do-notation or the proc-notation).
sumCircuit :: (MonadComp m, Num a) => a -> Circuit m a a

-- | Like <a>sumCircuit</a> but allows either setting a new <a>Left</a>
--   value for the sum, or updating it by specifying the <a>Right</a>
--   difference.
sumCircuitEither :: (MonadComp m, Num a) => a -> Circuit m (Either a a) a

-- | Approximate the circuit as a transform of time varying function,
--   calculating the values in the integration time points and then
--   interpolating in all other time points. The resulting transform
--   computation is synchronized with the event queue.
--   
--   This procedure consumes memory as the underlying memoization allocates
--   an array to store the calculated values.
circuitTransform :: MonadComp m => Circuit m a b -> Transform m a b

-- | Show the debug messages with the current simulation time.
traceCircuit :: MonadComp m => Maybe String -> Maybe String -> Circuit m a b -> Circuit m a b
instance MonadComp m => ArrowChoice (Circuit m)
instance (MonadComp m, MonadFix m) => ArrowLoop (Circuit m)
instance MonadComp m => Arrow (Circuit m)
instance MonadComp m => Category (Circuit m)


-- | Tested with: GHC 7.8.3
--   
--   The module defines a <a>Net</a> arrow that can be applied to modeling
--   the queue networks like the <a>Processor</a> arrow from another
--   module. Only the former has a more efficient implementation of the
--   <a>Arrow</a> interface than the latter, although at the cost of some
--   decreasing in generality.
--   
--   While the <tt>Processor</tt> type is just a function that transforms
--   the input <a>Stream</a> into another, the <tt>Net</tt> type is
--   actually an automaton that has an implementation very similar to that
--   one which the <a>Circuit</a> type has, only the computations occur in
--   the <a>Process</a> monad. But unlike the <tt>Circuit</tt> type, the
--   <tt>Net</tt> type doesn't allow declaring recursive definitions, being
--   based on continuations.
--   
--   In a nutshell, the <tt>Net</tt> type is an interchangeable alternative
--   to the <tt>Processor</tt> type with its weaknesses and strengths. The
--   <tt>Net</tt> arrow is useful for constructing computations with help
--   of the proc-notation to be transformed then to the <tt>Processor</tt>
--   computations that are more general in nature and more easy-to-use but
--   which computations created with help of the proc-notation are not so
--   efficient.
module Simulation.Aivika.Trans.Net

-- | Represents the net as an automaton working within the <a>Process</a>
--   computation.
newtype Net m a b
Net :: (a -> Process m (b, Net m a b)) -> Net m a b

-- | Run the net.
runNet :: Net m a b -> a -> Process m (b, Net m a b)

-- | Iterate infinitely using the specified initial value.
iterateNet :: MonadComp m => Net m a a -> a -> Process m ()

-- | Iterate the net using the specified initial value until <a>Nothing</a>
--   is returned within the <a>Net</a> computation.
iterateNetMaybe :: MonadComp m => Net m a (Maybe a) -> a -> Process m ()

-- | Iterate the net using the specified initial value until the
--   <a>Left</a> result is returned within the <a>Net</a> computation.
iterateNetEither :: MonadComp m => Net m a (Either b a) -> a -> Process m b

-- | A net that never finishes its work.
emptyNet :: MonadComp m => Net m a b

-- | Create a simple net by the specified handling function that runs the
--   discontinuous process for each input value to get an output.
arrNet :: MonadComp m => (a -> Process m b) -> Net m a b

-- | Accumulator that outputs a value determined by the supplied function.
accumNet :: MonadComp m => (acc -> a -> Process m (acc, b)) -> acc -> Net m a b

-- | Create a net that will use the specified process identifier. It can be
--   useful to refer to the underlying <a>Process</a> computation which can
--   be passivated, interrupted, canceled and so on. See also the
--   <a>processUsingId</a> function for more details.
netUsingId :: MonadComp m => ProcessId m -> Net m a b -> Net m a b

-- | A net that adds the information about the time points at which the
--   values were received.
arrivalNet :: MonadComp m => Net m a (Arrival a)

-- | Delay the input by one step using the specified initial value.
delayNet :: MonadComp m => a -> Net m a a

-- | Transform the net to an equivalent processor (a rather cheap
--   transformation).
netProcessor :: MonadComp m => Net m a b -> Processor m a b

-- | Transform the processor to a similar net (a more costly
--   transformation).
processorNet :: MonadComp m => Processor m a b -> Net m a b

-- | Show the debug messages with the current simulation time.
traceNet :: MonadComp m => Maybe String -> Maybe String -> Net m a b -> Net m a b
instance MonadComp m => ArrowChoice (Net m)
instance MonadComp m => Arrow (Net m)
instance MonadComp m => Category (Net m)


-- | Tested with: GHC 7.8.3
--   
--   This module defines the types and functions for working with the
--   events that can represent something that arrive from outside the
--   model, or represent other things which computation is delayed and
--   hence is not synchronized.
--   
--   Therefore, the additional information is provided about the time and
--   delay of arrival.
module Simulation.Aivika.Trans.Arrival

-- | It defines when an event has arrived, usually generated by some random
--   stream.
--   
--   Such events should arrive one by one without time lag in the following
--   sense that the model should start awaiting the next event exactly in
--   that time when the previous event has arrived.
--   
--   Another use case is a situation when the actual event is not
--   synchronized with the <a>Event</a> computation, being synchronized
--   with the event queue, nevertheless. Then the arrival is used for
--   providing the additional information about the time at which the event
--   had been actually arrived.
data Arrival a :: * -> *
Arrival :: a -> Double -> Maybe Double -> Arrival a

-- | the data we received with the event
arrivalValue :: Arrival a -> a

-- | the simulation time at which the event has arrived
arrivalTime :: Arrival a -> Double

-- | the delay time which has passed from the time of arriving the previous
--   event
arrivalDelay :: Arrival a -> Maybe Double

-- | Accumulates the statistics about that how long the arrived events are
--   processed.
data ArrivalTimer m

-- | Create a new timer that measures how long the arrived events are
--   processed.
newArrivalTimer :: MonadComp m => Simulation m (ArrivalTimer m)

-- | Return a processor that actually measures how much time has passed
--   from the time of arriving the events.
arrivalTimerProcessor :: MonadComp m => ArrivalTimer m -> Processor m (Arrival a) (Arrival a)

-- | Return the statistics about that how long the arrived events were
--   processed.
arrivalProcessingTime :: MonadComp m => ArrivalTimer m -> Event m (SamplingStats Double)

-- | Return a signal raised when the the processing time statistics
--   changes.
arrivalProcessingTimeChanged :: MonadComp m => ArrivalTimer m -> Signal m (SamplingStats Double)

-- | Return a signal raised when the the processing time statistics
--   changes.
arrivalProcessingTimeChanged_ :: MonadComp m => ArrivalTimer m -> Signal m ()


-- | Tested with: GHC 7.8.3
--   
--   This module defines random streams of events, which are useful for
--   describing the input of the model.
module Simulation.Aivika.Trans.Stream.Random

-- | Return a sream of random events that arrive with the specified delay.
randomStream :: MonadComp m => Parameter m (Double, a) -> Stream m (Arrival a)

-- | Create a new stream with delays distributed uniformly.
randomUniformStream :: MonadComp m => Double -> Double -> Stream m (Arrival Double)

-- | Create a new stream with integer delays distributed uniformly.
randomUniformIntStream :: MonadComp m => Int -> Int -> Stream m (Arrival Int)

-- | Create a new stream with delays distributed normally.
randomNormalStream :: MonadComp m => Double -> Double -> Stream m (Arrival Double)

-- | Return a new stream with delays distibuted exponentially with the
--   specified mean (the reciprocal of the rate).
randomExponentialStream :: MonadComp m => Double -> Stream m (Arrival Double)

-- | Return a new stream with delays having the Erlang distribution with
--   the specified scale (the reciprocal of the rate) and shape parameters.
randomErlangStream :: MonadComp m => Double -> Int -> Stream m (Arrival Double)

-- | Return a new stream with delays having the Poisson distribution with
--   the specified mean.
randomPoissonStream :: MonadComp m => Double -> Stream m (Arrival Int)

-- | Return a new stream with delays having the binomial distribution with
--   the specified probability and trials.
randomBinomialStream :: MonadComp m => Double -> Int -> Stream m (Arrival Int)


-- | Tested with: GHC 7.8.3
--   
--   This module introduces basic entities for the agent-based modeling.
module Simulation.Aivika.Trans.Agent

-- | Represents an agent.
data Agent m

-- | Represents the agent state.
data AgentState m

-- | Create an agent.
newAgent :: MonadComp m => Simulation m (Agent m)

-- | Create a new state.
newState :: MonadComp m => Agent m -> Simulation m (AgentState m)

-- | Create a child state.
newSubstate :: MonadComp m => AgentState m -> Simulation m (AgentState m)

-- | Return the selected active state.
selectedState :: MonadComp m => Agent m -> Event m (Maybe (AgentState m))

-- | Return a signal that notifies about every change of the selected
--   state.
selectedStateChanged :: Agent m -> Signal m (Maybe (AgentState m))

-- | Return a signal that notifies about every change of the selected
--   state.
selectedStateChanged_ :: MonadComp m => Agent m -> Signal m ()

-- | Select the state. The activation and selection are repeated while
--   there is the transition state defined by <a>setStateTransition</a>.
selectState :: MonadComp m => AgentState m -> Event m ()

-- | Return the corresponded agent.
stateAgent :: AgentState m -> Agent m

-- | Return the parent state or <a>Nothing</a>.
stateParent :: AgentState m -> Maybe (AgentState m)

-- | Add to the state a timeout handler that will be actuated in the
--   specified time period if the state will remain active.
addTimeout :: MonadComp m => AgentState m -> Double -> Event m () -> Event m ()

-- | Add to the state a timer handler that will be actuated in the
--   specified time period and then repeated again many times, while the
--   state remains active.
addTimer :: MonadComp m => AgentState m -> Event m Double -> Event m () -> Event m ()

-- | Set the activation computation for the specified state.
setStateActivation :: MonadComp m => AgentState m -> Event m () -> Simulation m ()

-- | Set the deactivation computation for the specified state.
setStateDeactivation :: MonadComp m => AgentState m -> Event m () -> Simulation m ()

-- | Set the transition state which will be next and which is used only
--   when selecting the state directly with help of <a>selectState</a>. If
--   the state was activated intermediately, when selecting another state,
--   then this computation is not used.
setStateTransition :: MonadComp m => AgentState m -> Event m (Maybe (AgentState m)) -> Simulation m ()
instance MonadComp m => Eq (AgentState m)
instance MonadComp m => Eq (Agent m)


-- | Tested with: GHC 7.8.3
--   
--   It models an activity that can be utilised. The activity is similar to
--   a <a>Server</a> but destined for simulation within <a>Net</a>
--   computation.
module Simulation.Aivika.Trans.Activity

-- | Like <a>Server</a> it models an activity that takes <tt>a</tt> and
--   provides <tt>b</tt> having state <tt>s</tt>. But unlike the former the
--   activity is destined for simulation within <a>Net</a> computation.
data Activity m s a b

-- | Contains data about the interrupted task.
data ActivityInterruption a :: * -> *
ActivityInterruption :: a -> Double -> Double -> ActivityInterruption a

-- | The input task that was interrupted.
activityInterruptedInput :: ActivityInterruption a -> a

-- | The start time of processing the task.
activityStartProcessingTime :: ActivityInterruption a -> Double

-- | The time of interrupting the task.
activityInterruptionTime :: ActivityInterruption a -> Double

-- | Create a new activity that can provide output <tt>b</tt> by input
--   <tt>a</tt>.
--   
--   By default, it is assumed that the activity utilisation cannot be
--   interrupted, because the handling of possible task interruption is
--   rather costly operation.
newActivity :: MonadComp m => (a -> Process m b) -> Simulation m (Activity m () a b)

-- | Create a new activity that can provide output <tt>b</tt> by input
--   <tt>a</tt> starting from state <tt>s</tt>.
--   
--   By default, it is assumed that the activity utilisation cannot be
--   interrupted, because the handling of possible task interruption is
--   rather costly operation.
newStateActivity :: MonadComp m => (s -> a -> Process m (s, b)) -> s -> Simulation m (Activity m s a b)

-- | Create a new interruptible activity that can provide output <tt>b</tt>
--   by input <tt>a</tt>.
newInterruptibleActivity :: MonadComp m => Bool -> (a -> Process m b) -> Simulation m (Activity m () a b)

-- | Create a new activity that can provide output <tt>b</tt> by input
--   <tt>a</tt> starting from state <tt>s</tt>.
newInterruptibleStateActivity :: MonadComp m => Bool -> (s -> a -> Process m (s, b)) -> s -> Simulation m (Activity m s a b)

-- | Return a network computation for the specified activity.
--   
--   The computation updates the internal state of the activity. The usual
--   case is when the computation is applied only once in a chain of data
--   processing. Otherwise; every time the computation is used, the state
--   of the activity changes. Sometimes it can be indeed useful if you want
--   to aggregate the statistics for different activities simultaneously,
--   but it would be more preferable to avoid this.
--   
--   If you connect different activity computations returned by this
--   function in a chain with help of <a>&gt;&gt;&gt;</a> or other category
--   combinator then this chain will act as one whole, where the first
--   activity will take a new task only after the last activity finishes
--   its current task and requests for the next one from the previous
--   activity in the chain. This is not always that thing you might need.
activityNet :: MonadComp m => Activity m s a b -> Net m a b

-- | The initial state of the activity.
activityInitState :: Activity m s a b -> s

-- | Return the current state of the activity.
--   
--   See also <a>activityStateChanged</a> and <a>activityStateChanged_</a>.
activityState :: MonadComp m => Activity m s a b -> Event m s

-- | Return the counted total time when the activity was utilised.
--   
--   The value returned changes discretely and it is usually delayed
--   relative to the current simulation time.
--   
--   See also <a>activityTotalUtilisationTimeChanged</a> and
--   <a>activityTotalUtilisationTimeChanged_</a>.
activityTotalUtilisationTime :: MonadComp m => Activity m s a b -> Event m Double

-- | Return the counted total time when the activity was idle.
--   
--   The value returned changes discretely and it is usually delayed
--   relative to the current simulation time.
--   
--   See also <a>activityTotalIdleTimeChanged</a> and
--   <a>activityTotalIdleTimeChanged_</a>.
activityTotalIdleTime :: MonadComp m => Activity m s a b -> Event m Double

-- | Return the statistics for the time when the activity was utilised.
--   
--   The value returned changes discretely and it is usually delayed
--   relative to the current simulation time.
--   
--   See also <a>activityUtilisationTimeChanged</a> and
--   <a>activityUtilisationTimeChanged_</a>.
activityUtilisationTime :: MonadComp m => Activity m s a b -> Event m (SamplingStats Double)

-- | Return the statistics for the time when the activity was idle.
--   
--   The value returned changes discretely and it is usually delayed
--   relative to the current simulation time.
--   
--   See also <a>activityIdleTimeChanged</a> and
--   <a>activityIdleTimeChanged_</a>.
activityIdleTime :: MonadComp m => Activity m s a b -> Event m (SamplingStats Double)

-- | It returns the factor changing from 0 to 1, which estimates how often
--   the activity was utilised.
--   
--   This factor is calculated as
--   
--   <pre>
--   totalUtilisationTime / (totalUtilisationTime + totalIdleTime)
--   </pre>
--   
--   As before in this module, the value returned changes discretely and it
--   is usually delayed relative to the current simulation time.
--   
--   See also <a>activityUtilisationFactorChanged</a> and
--   <a>activityUtilisationFactorChanged_</a>.
activityUtilisationFactor :: MonadComp m => Activity m s a b -> Event m Double

-- | It returns the factor changing from 0 to 1, which estimates how often
--   the activity was idle.
--   
--   This factor is calculated as
--   
--   <pre>
--   totalIdleTime / (totalUtilisationTime + totalIdleTime)
--   </pre>
--   
--   As before in this module, the value returned changes discretely and it
--   is usually delayed relative to the current simulation time.
--   
--   See also <a>activityIdleFactorChanged</a> and
--   <a>activityIdleFactorChanged_</a>.
activityIdleFactor :: MonadComp m => Activity m s a b -> Event m Double

-- | Return the summary for the activity with desciption of its properties
--   using the specified indent.
activitySummary :: MonadComp m => Activity m s a b -> Int -> Event m ShowS

-- | Signal when the <a>activityState</a> property value has changed.
activityStateChanged :: MonadComp m => Activity m s a b -> Signal m s

-- | Signal when the <a>activityState</a> property value has changed.
activityStateChanged_ :: MonadComp m => Activity m s a b -> Signal m ()

-- | Signal when the <a>activityTotalUtilisationTime</a> property value has
--   changed.
activityTotalUtilisationTimeChanged :: MonadComp m => Activity m s a b -> Signal m Double

-- | Signal when the <a>activityTotalUtilisationTime</a> property value has
--   changed.
activityTotalUtilisationTimeChanged_ :: MonadComp m => Activity m s a b -> Signal m ()

-- | Signal when the <a>activityTotalIdleTime</a> property value has
--   changed.
activityTotalIdleTimeChanged :: MonadComp m => Activity m s a b -> Signal m Double

-- | Signal when the <a>activityTotalIdleTime</a> property value has
--   changed.
activityTotalIdleTimeChanged_ :: MonadComp m => Activity m s a b -> Signal m ()

-- | Signal when the <a>activityUtilisationTime</a> property value has
--   changed.
activityUtilisationTimeChanged :: MonadComp m => Activity m s a b -> Signal m (SamplingStats Double)

-- | Signal when the <a>activityUtilisationTime</a> property value has
--   changed.
activityUtilisationTimeChanged_ :: MonadComp m => Activity m s a b -> Signal m ()

-- | Signal when the <a>activityIdleTime</a> property value has changed.
activityIdleTimeChanged :: MonadComp m => Activity m s a b -> Signal m (SamplingStats Double)

-- | Signal when the <a>activityIdleTime</a> property value has changed.
activityIdleTimeChanged_ :: MonadComp m => Activity m s a b -> Signal m ()

-- | Signal when the <a>activityUtilisationFactor</a> property value has
--   changed.
activityUtilisationFactorChanged :: MonadComp m => Activity m s a b -> Signal m Double

-- | Signal when the <a>activityUtilisationFactor</a> property value has
--   changed.
activityUtilisationFactorChanged_ :: MonadComp m => Activity m s a b -> Signal m ()

-- | Signal when the <a>activityIdleFactor</a> property value has changed.
activityIdleFactorChanged :: MonadComp m => Activity m s a b -> Signal m Double

-- | Signal when the <a>activityIdleFactor</a> property value has changed.
activityIdleFactorChanged_ :: MonadComp m => Activity m s a b -> Signal m ()

-- | Raised when starting to utilise the activity after a new input task is
--   received.
activityUtilising :: Activity m s a b -> Signal m a

-- | Raised when the activity has been utilised after the current task is
--   processed.
activityUtilised :: Activity m s a b -> Signal m (a, b)

-- | Raised when the task utilisation by the activity was interrupted.
activityInterrupted :: Activity m s a b -> Signal m (ActivityInterruption a)

-- | Signal whenever any property of the activity changes.
activityChanged_ :: MonadComp m => Activity m s a b -> Signal m ()


-- | Tested with: GHC 7.8.3
--   
--   The module defines locales for outputting and printing the simulation
--   results.
module Simulation.Aivika.Trans.Results.Locale

-- | A locale to output the simulation results.
--   
--   Examples are: <tt>"ru", </tt>"en" etc.
type ResultLocale = String

-- | It localises the description of simulation results.
type ResultLocalisation = ResultId -> ResultDescription

-- | A description used for describing the results when generating output.
type ResultDescription = String

-- | The Russian locale.
russianResultLocale :: ResultLocale

-- | The English locale.
englishResultLocale :: ResultLocale

-- | Lookup a localisation by the specified locale.
lookupResultLocalisation :: ResultLocale -> ResultLocalisation

-- | The Russian localisation of the simulation results.
russianResultLocalisation :: ResultLocalisation

-- | The English localisation of the simulation results.
englishResultLocalisation :: ResultLocalisation

-- | The result entity identifier.
data ResultId

-- | A <a>time</a> computation.
TimeId :: ResultId

-- | Describes a vector.
VectorId :: ResultId

-- | Describes a vector item with the specified subscript.
VectorItemId :: String -> ResultId

-- | A <a>SamplingStats</a> value.
SamplingStatsId :: ResultId

-- | Property <a>samplingStatsCount</a>.
SamplingStatsCountId :: ResultId

-- | Property <a>samplingStatsMin</a>.
SamplingStatsMinId :: ResultId

-- | Property <a>samplingStatsMax</a>.
SamplingStatsMaxId :: ResultId

-- | Property <a>samplingStatsMean</a>.
SamplingStatsMeanId :: ResultId

-- | Property <a>samplingStatsMean2</a>.
SamplingStatsMean2Id :: ResultId

-- | Property <a>samplingStatsVariance</a>.
SamplingStatsVarianceId :: ResultId

-- | Property <a>samplingStatsDeviation</a>.
SamplingStatsDeviationId :: ResultId

-- | A <a>SamplingCounter</a> value.
SamplingCounterId :: ResultId

-- | Property <a>samplingCounterValue</a>.
SamplingCounterValueId :: ResultId

-- | Property <a>samplingCounterStats</a>.
SamplingCounterStatsId :: ResultId

-- | A <a>TimingStats</a> value.
TimingStatsId :: ResultId

-- | Property <a>timingStatsCount</a>.
TimingStatsCountId :: ResultId

-- | Property <a>timingStatsMin</a>.
TimingStatsMinId :: ResultId

-- | Property <a>timingStatsMax</a>.
TimingStatsMaxId :: ResultId

-- | Property <a>timingStatsMean</a>.
TimingStatsMeanId :: ResultId

-- | Property <a>timingStatsVariance</a>.
TimingStatsVarianceId :: ResultId

-- | Property <a>timingStatsDeviation</a>.
TimingStatsDeviationId :: ResultId

-- | Property <a>timingStatsMinTime</a>.
TimingStatsMinTimeId :: ResultId

-- | Property <a>timingStatsMaxTime</a>.
TimingStatsMaxTimeId :: ResultId

-- | Property <a>timingStatsStartTime</a>.
TimingStatsStartTimeId :: ResultId

-- | Property <a>timingStatsLastTime</a>.
TimingStatsLastTimeId :: ResultId

-- | Property <a>timingStatsSum</a>.
TimingStatsSumId :: ResultId

-- | Property <a>timingStatsSum2</a>.
TimingStatsSum2Id :: ResultId

-- | A <a>TimingCounter</a> value.
TimingCounterId :: ResultId

-- | Property <a>timingCounterValue</a>.
TimingCounterValueId :: ResultId

-- | Property <a>timingCounterStats</a>.
TimingCounterStatsId :: ResultId

-- | A finite <a>Queue</a>.
FiniteQueueId :: ResultId

-- | An infinite <a>Queue</a>.
InfiniteQueueId :: ResultId

-- | Property <a>enqueueStrategy</a>.
EnqueueStrategyId :: ResultId

-- | Property <a>enqueueStoringStrategy</a>.
EnqueueStoringStrategyId :: ResultId

-- | Property <a>dequeueStrategy</a>.
DequeueStrategyId :: ResultId

-- | Property <a>queueNull</a>.
QueueNullId :: ResultId

-- | Property <a>queueFull</a>.
QueueFullId :: ResultId

-- | Property <a>queueMaxCount</a>.
QueueMaxCountId :: ResultId

-- | Property <a>queueCount</a>.
QueueCountId :: ResultId

-- | Property <a>queueCountStats</a>.
QueueCountStatsId :: ResultId

-- | Property <a>enqueueCount</a>.
EnqueueCountId :: ResultId

-- | Property <a>enqueueLostCount</a>.
EnqueueLostCountId :: ResultId

-- | Property <a>enqueueStoreCount</a>.
EnqueueStoreCountId :: ResultId

-- | Property <a>dequeueCount</a>.
DequeueCountId :: ResultId

-- | Property <a>dequeueExtractCount</a>.
DequeueExtractCountId :: ResultId

-- | Property <a>queueLoadFactor</a>.
QueueLoadFactorId :: ResultId

-- | Property <a>enqueueRate</a>.
EnqueueRateId :: ResultId

-- | Property <a>enqueueStoreRate</a>.
EnqueueStoreRateId :: ResultId

-- | Property <a>dequeueRate</a>.
DequeueRateId :: ResultId

-- | Property <a>dequeueExtractRate</a>.
DequeueExtractRateId :: ResultId

-- | Property <a>queueWaitTime</a>.
QueueWaitTimeId :: ResultId

-- | Property <a>queueTotalWaitTime</a>.
QueueTotalWaitTimeId :: ResultId

-- | Property <a>enqueueWaitTime</a>.
EnqueueWaitTimeId :: ResultId

-- | Property <a>dequeueWaitTime</a>.
DequeueWaitTimeId :: ResultId

-- | Property <a>queueRate</a>.
QueueRateId :: ResultId

-- | An <a>ArrivalTimer</a>.
ArrivalTimerId :: ResultId

-- | Property <a>arrivalProcessingTime</a>.
ArrivalProcessingTimeId :: ResultId

-- | Represents a <a>Server</a>.
ServerId :: ResultId

-- | Property <a>serverInitState</a>.
ServerInitStateId :: ResultId

-- | Property <a>serverState</a>.
ServerStateId :: ResultId

-- | Property <a>serverTotalInputWaitTime</a>.
ServerTotalInputWaitTimeId :: ResultId

-- | Property <a>serverTotalProcessingTime</a>.
ServerTotalProcessingTimeId :: ResultId

-- | Property <a>serverTotalOutputWaitTime</a>.
ServerTotalOutputWaitTimeId :: ResultId

-- | Property <a>serverInputWaitTime</a>.
ServerInputWaitTimeId :: ResultId

-- | Property <a>serverProcessingTime</a>.
ServerProcessingTimeId :: ResultId

-- | Property <a>serverOutputWaitTime</a>.
ServerOutputWaitTimeId :: ResultId

-- | Property <a>serverInputWaitFactor</a>.
ServerInputWaitFactorId :: ResultId

-- | Property <a>serverProcessingFactor</a>.
ServerProcessingFactorId :: ResultId

-- | Property <a>serverOutputWaitFactor</a>.
ServerOutputWaitFactorId :: ResultId

-- | Represents an <a>Activity</a>.
ActivityId :: ResultId

-- | Property <a>activityInitState</a>.
ActivityInitStateId :: ResultId

-- | Property <a>activityState</a>.
ActivityStateId :: ResultId

-- | Property <a>activityTotalUtilisationTime</a>.
ActivityTotalUtilisationTimeId :: ResultId

-- | Property <a>activityTotalIdleTime</a>.
ActivityTotalIdleTimeId :: ResultId

-- | Property <a>activityUtilisationTime</a>.
ActivityUtilisationTimeId :: ResultId

-- | Property <a>activityIdleTime</a>.
ActivityIdleTimeId :: ResultId

-- | Property <a>activityUtilisationFactor</a>.
ActivityUtilisationFactorId :: ResultId

-- | Property <a>activityIdleFactor</a>.
ActivityIdleFactorId :: ResultId

-- | An user defined description.
UserDefinedResultId :: ResultDescription -> ResultId

-- | A localised property or object name.
LocalisedResultId :: (Map ResultLocale ResultDescription) -> ResultId
instance Eq ResultId
instance Ord ResultId
instance Show ResultId


-- | Tested with: GHC 7.8.3
--   
--   The module allows exporting the simulation results from the model.
module Simulation.Aivika.Trans.Results

-- | It contains the results of simulation.
data Results m

-- | It transforms the results of simulation.
type ResultTransform m = Results m -> Results m

-- | A name used for indentifying the results when generating output.
type ResultName = String

-- | Represents a provider of the simulation results. It is usually
--   something, or an array of something, or a list of such values which
--   can be simulated to get data.
class MonadComp m => ResultProvider p m | p -> m where resultSource name descr = resultSource' name (UserDefinedResultId descr)
resultSource :: ResultProvider p m => ResultName -> ResultDescription -> p -> ResultSource m
resultSource' :: ResultProvider p m => ResultName -> ResultId -> p -> ResultSource m

-- | Prepare the simulation results.
results :: [ResultSource m] -> Results m

-- | Return an expanded version of the simulation results expanding the
--   properties as possible, which takes place for expanding statistics to
--   show the count, average, deviation, minimum, maximum etc. as separate
--   values.
expandResults :: MonadComp m => ResultTransform m

-- | Return a short version of the simulation results, i.e. their summary,
--   expanding the main properties or excluding auxiliary properties if
--   required.
resultSummary :: MonadComp m => ResultTransform m

-- | Take a result by its name.
resultByName :: ResultName -> ResultTransform m

-- | Take a result from the object with the specified property label, but
--   it is more preferrable to refer to the property by its <a>ResultId</a>
--   identifier with help of the <a>resultById</a> function.
resultByProperty :: ResultName -> ResultTransform m

-- | Take a result from the object with the specified identifier. It can
--   identify an item, object property, the object iself, vector or its
--   elements.
resultById :: ResultId -> ResultTransform m

-- | Take a result from the vector by the specified integer index.
resultByIndex :: Int -> ResultTransform m

-- | Take a result from the vector by the specified string subscript.
resultBySubscript :: ResultName -> ResultTransform m

-- | Represents a computation that can return the simulation data.
class MonadComp m => ResultComputing t m
computeResultData :: ResultComputing t m => t m a -> ResultData a m
computeResultSignal :: ResultComputing t m => t m a -> ResultSignal m

-- | Represents a list with the specified subscript.
data ResultListWithSubscript p
ResultListWithSubscript :: [p] -> [String] -> ResultListWithSubscript p

-- | Represents an array with the specified subscript.
data ResultArrayWithSubscript i p
ResultArrayWithSubscript :: (Array i p) -> (Array i String) -> ResultArrayWithSubscript i p

-- | Represents a vector with the specified subscript.
data ResultVectorWithSubscript p
ResultVectorWithSubscript :: (Vector p) -> (Vector String) -> ResultVectorWithSubscript p

-- | Defines a final result extract: its name, values and other data.
data ResultExtract e m
ResultExtract :: ResultName -> ResultId -> Event m e -> ResultSignal m -> ResultExtract e m

-- | The result name.
resultExtractName :: ResultExtract e m -> ResultName

-- | The result identifier.
resultExtractId :: ResultExtract e m -> ResultId

-- | The result values.
resultExtractData :: ResultExtract e m -> Event m e

-- | Whether the result emits a signal.
resultExtractSignal :: ResultExtract e m -> ResultSignal m

-- | Extract the results as integer values, or raise a conversion error.
extractIntResults :: MonadComp m => Results m -> [ResultExtract Int m]

-- | Extract the results as lists of integer values, or raise a conversion
--   error.
extractIntListResults :: MonadComp m => Results m -> [ResultExtract [Int] m]

-- | Extract the results as statistics based on integer values, or raise a
--   conversion error.
extractIntStatsResults :: MonadComp m => Results m -> [ResultExtract (SamplingStats Int) m]

-- | Extract the results as statistics based on integer values and
--   optimised for fast aggregation, or raise a conversion error.
extractIntStatsEitherResults :: MonadComp m => Results m -> [ResultExtract (Either Int (SamplingStats Int)) m]

-- | Extract the results as timing statistics based on integer values, or
--   raise a conversion error.
extractIntTimingStatsResults :: MonadComp m => Results m -> [ResultExtract (TimingStats Int) m]

-- | Extract the results as double floating point values, or raise a
--   conversion error.
extractDoubleResults :: MonadComp m => Results m -> [ResultExtract Double m]

-- | Extract the results as lists of double floating point values, or raise
--   a conversion error.
extractDoubleListResults :: MonadComp m => Results m -> [ResultExtract [Double] m]

-- | Extract the results as statistics based on double floating point
--   values, or raise a conversion error.
extractDoubleStatsResults :: MonadComp m => Results m -> [ResultExtract (SamplingStats Double) m]

-- | Extract the results as statistics based on double floating point
--   values and optimised for fast aggregation, or raise a conversion
--   error.
extractDoubleStatsEitherResults :: MonadComp m => Results m -> [ResultExtract (Either Double (SamplingStats Double)) m]

-- | Extract the results as timing statistics based on double floating
--   point values, or raise a conversion error.
extractDoubleTimingStatsResults :: MonadComp m => Results m -> [ResultExtract (TimingStats Double) m]

-- | Extract the results as string values, or raise a conversion error.
extractStringResults :: MonadComp m => Results m -> [ResultExtract String m]

-- | It representes the predefined signals provided by every simulation
--   model.
data ResultPredefinedSignals m
ResultPredefinedSignals :: Signal m Double -> Signal m Double -> Signal m Double -> ResultPredefinedSignals m

-- | The signal triggered in the integration time points.
resultSignalInIntegTimes :: ResultPredefinedSignals m -> Signal m Double

-- | The signal triggered in the start time.
resultSignalInStartTime :: ResultPredefinedSignals m -> Signal m Double

-- | The signal triggered in the stop time.
resultSignalInStopTime :: ResultPredefinedSignals m -> Signal m Double

-- | Create the predefined signals provided by every simulation model.
newResultPredefinedSignals :: MonadComp m => Simulation m (ResultPredefinedSignals m)

-- | Return a signal emitted by the specified results.
resultSignal :: MonadComp m => Results m -> ResultSignal m

-- | Return a pure signal as a result of combination of the predefined
--   signals with the specified result signal usually provided by the
--   sources.
--   
--   The signal returned is triggered when the source signal is triggered.
--   The pure signal is also triggered in the integration time points if
--   the source signal is unknown or it was combined with any unknown
--   signal.
pureResultSignal :: MonadComp m => ResultPredefinedSignals m -> ResultSignal m -> Signal m ()

-- | It associates the result sources with their names.
type ResultSourceMap m = Map ResultName (ResultSource m)

-- | Encapsulates the result source.
data ResultSource m

-- | The source consisting of a single item.
ResultItemSource :: (ResultItem m) -> ResultSource m

-- | An object-like source.
ResultObjectSource :: (ResultObject m) -> ResultSource m

-- | A vector-like structure.
ResultVectorSource :: (ResultVector m) -> ResultSource m

-- | This is a separator text.
ResultSeparatorSource :: ResultSeparator -> ResultSource m

-- | The simulation results represented by a single item.
data ResultItem m
ResultItem :: (a m) -> ResultItem m

-- | Represents a type class for actual representing the items.
class ResultItemable a
resultItemName :: ResultItemable a => a m -> ResultName
resultItemId :: ResultItemable a => a m -> ResultId
resultItemSignal :: (ResultItemable a, MonadComp m) => a m -> ResultSignal m
resultItemExpansion :: (ResultItemable a, MonadComp m) => a m -> ResultSource m
resultItemSummary :: (ResultItemable a, MonadComp m) => a m -> ResultSource m
resultItemToIntValue :: (ResultItemable a, MonadComp m) => a m -> ResultValue Int m
resultItemToIntListValue :: (ResultItemable a, MonadComp m) => a m -> ResultValue [Int] m
resultItemToIntStatsValue :: (ResultItemable a, MonadComp m) => a m -> ResultValue (SamplingStats Int) m
resultItemToIntTimingStatsValue :: (ResultItemable a, MonadComp m) => a m -> ResultValue (TimingStats Int) m
resultItemToDoubleValue :: (ResultItemable a, MonadComp m) => a m -> ResultValue Double m
resultItemToDoubleListValue :: (ResultItemable a, MonadComp m) => a m -> ResultValue [Double] m
resultItemToDoubleStatsValue :: (ResultItemable a, MonadComp m) => a m -> ResultValue (SamplingStats Double) m
resultItemToDoubleTimingStatsValue :: (ResultItemable a, MonadComp m) => a m -> ResultValue (TimingStats Double) m
resultItemToStringValue :: (ResultItemable a, MonadComp m) => a m -> ResultValue String m

-- | Return a version optimised for fast aggregation of the statistics
--   based on integer numbers.
resultItemToIntStatsEitherValue :: (MonadComp m, ResultItemable a) => a m -> ResultValue (Either Int (SamplingStats Int)) m

-- | Return a version optimised for fast aggregation of the statistics
--   based on double floating point numbers.
resultItemToDoubleStatsEitherValue :: (MonadComp m, ResultItemable a) => a m -> ResultValue (Either Double (SamplingStats Double)) m

-- | The simulation results represented by an object having properties.
data ResultObject m
ResultObject :: ResultName -> ResultId -> ResultId -> [ResultProperty m] -> ResultSignal m -> ResultSource m -> ResultObject m

-- | The object name.
resultObjectName :: ResultObject m -> ResultName

-- | The object identifier.
resultObjectId :: ResultObject m -> ResultId

-- | The object type identifier.
resultObjectTypeId :: ResultObject m -> ResultId

-- | The object properties.
resultObjectProperties :: ResultObject m -> [ResultProperty m]

-- | A combined signal if present.
resultObjectSignal :: ResultObject m -> ResultSignal m

-- | A short version of the object, i.e. its summary.
resultObjectSummary :: ResultObject m -> ResultSource m

-- | The object property containing the simulation results.
data ResultProperty m
ResultProperty :: ResultName -> ResultId -> ResultSource m -> ResultProperty m

-- | The property short label.
resultPropertyLabel :: ResultProperty m -> ResultName

-- | The property identifier.
resultPropertyId :: ResultProperty m -> ResultId

-- | The simulation results supplied by the property.
resultPropertySource :: ResultProperty m -> ResultSource m

-- | The simulation results represented by a vector.
data ResultVector m
ResultVector :: ResultName -> ResultId -> Array Int (ResultSource m) -> Array Int ResultName -> ResultSignal m -> ResultSource m -> ResultVector m

-- | The vector name.
resultVectorName :: ResultVector m -> ResultName

-- | The vector identifier.
resultVectorId :: ResultVector m -> ResultId

-- | The results supplied by the vector items.
resultVectorItems :: ResultVector m -> Array Int (ResultSource m)

-- | The subscript used as a suffix to create item names.
resultVectorSubscript :: ResultVector m -> Array Int ResultName

-- | A combined signal if present.
resultVectorSignal :: ResultVector m -> ResultSignal m

-- | A short version of the vector, i.e. summary.
resultVectorSummary :: ResultVector m -> ResultSource m

-- | Calculate the result vector signal and memoize it in a new vector.
memoResultVectorSignal :: MonadComp m => ResultVector m -> ResultVector m

-- | Calculate the result vector summary and memoize it in a new vector.
memoResultVectorSummary :: MonadComp m => ResultVector m -> ResultVector m

-- | It separates the simulation results when printing.
data ResultSeparator
ResultSeparator :: String -> ResultSeparator

-- | The separator text.
resultSeparatorText :: ResultSeparator -> String

-- | A parameterised value that actually represents a generalised result
--   item that have no parametric type.
data ResultValue e m
ResultValue :: ResultName -> ResultId -> ResultData e m -> ResultSignal m -> ResultValue e m

-- | The value name.
resultValueName :: ResultValue e m -> ResultName

-- | The value identifier.
resultValueId :: ResultValue e m -> ResultId

-- | Simulation data supplied by the value.
resultValueData :: ResultValue e m -> ResultData e m

-- | Whether the value emits a signal when changing simulation data.
resultValueSignal :: ResultValue e m -> ResultSignal m

-- | Return a new value with the discarded simulation results.
voidResultValue :: ResultValue a m -> ResultValue b m

-- | A container of the simulation results such as queue, server or array.
data ResultContainer e m
ResultContainer :: ResultName -> ResultId -> e -> ResultSignal m -> ResultContainer e m

-- | The container name.
resultContainerName :: ResultContainer e m -> ResultName

-- | The container identifier.
resultContainerId :: ResultContainer e m -> ResultId

-- | The container data.
resultContainerData :: ResultContainer e m -> e

-- | Whether the container emits a signal when changing simulation data.
resultContainerSignal :: ResultContainer e m -> ResultSignal m

-- | Create a new property source by the specified container.
resultContainerPropertySource :: ResultItemable (ResultValue b) => ResultContainer a m -> ResultName -> ResultId -> (a -> ResultData b m) -> (a -> ResultSignal m) -> ResultSource m

-- | Create a constant property by the specified container.
resultContainerConstProperty :: (MonadComp m, ResultItemable (ResultValue b)) => ResultContainer a m -> ResultName -> ResultId -> (a -> b) -> ResultProperty m

-- | Create by the specified container a property that changes in the
--   integration time points, or it is supposed to be such one.
resultContainerIntegProperty :: (MonadComp m, ResultItemable (ResultValue b)) => ResultContainer a m -> ResultName -> ResultId -> (a -> Event m b) -> ResultProperty m

-- | Create a property by the specified container.
resultContainerProperty :: (MonadComp m, ResultItemable (ResultValue b)) => ResultContainer a m -> ResultName -> ResultId -> (a -> Event m b) -> (a -> Signal m ()) -> ResultProperty m

-- | Create by the specified container a mapped property which is
--   recomputed each time again and again.
resultContainerMapProperty :: (MonadComp m, ResultItemable (ResultValue b)) => ResultContainer (ResultData a m) m -> ResultName -> ResultId -> (a -> b) -> ResultProperty m

-- | Convert the result value to a container with the specified object
--   identifier.
resultValueToContainer :: ResultValue a m -> ResultContainer (ResultData a m) m

-- | Convert the result container to a value.
resultContainerToValue :: ResultContainer (ResultData a m) m -> ResultValue a m

-- | Represents the very simulation results.
type ResultData e m = Maybe (Event m e)

-- | Whether an object containing the results emits a signal notifying
--   about change of data.
data ResultSignal m

-- | There is no signal at all.
EmptyResultSignal :: ResultSignal m

-- | The signal is unknown, but the entity probably changes.
UnknownResultSignal :: ResultSignal m

-- | When the signal is precisely specified.
ResultSignal :: (Signal m ()) -> ResultSignal m

-- | When the specified signal was combined with unknown signal.
ResultSignalMix :: (Signal m ()) -> ResultSignal m

-- | Construct a new result signal by the specified optional pure signal.
maybeResultSignal :: Maybe (Signal m ()) -> ResultSignal m

-- | Return an arbitrary text as a separator source.
textResultSource :: String -> ResultSource m

-- | Return the source of the modeling time.
timeResultSource :: MonadComp m => ResultSource m

-- | Represent the result source as integer numbers.
resultSourceToIntValues :: MonadComp m => ResultSource m -> [ResultValue Int m]

-- | Represent the result source as lists of integer numbers.
resultSourceToIntListValues :: MonadComp m => ResultSource m -> [ResultValue [Int] m]

-- | Represent the result source as statistics based on integer numbers.
resultSourceToIntStatsValues :: MonadComp m => ResultSource m -> [ResultValue (SamplingStats Int) m]

-- | Represent the result source as statistics based on integer numbers and
--   optimised for fast aggregation.
resultSourceToIntStatsEitherValues :: MonadComp m => ResultSource m -> [ResultValue (Either Int (SamplingStats Int)) m]

-- | Represent the result source as timing statistics based on integer
--   numbers.
resultSourceToIntTimingStatsValues :: MonadComp m => ResultSource m -> [ResultValue (TimingStats Int) m]

-- | Represent the result source as double floating point numbers.
resultSourceToDoubleValues :: MonadComp m => ResultSource m -> [ResultValue Double m]

-- | Represent the result source as lists of double floating point numbers.
resultSourceToDoubleListValues :: MonadComp m => ResultSource m -> [ResultValue [Double] m]

-- | Represent the result source as statistics based on double floating
--   point numbers.
resultSourceToDoubleStatsValues :: MonadComp m => ResultSource m -> [ResultValue (SamplingStats Double) m]

-- | Represent the result source as statistics based on double floating
--   point numbers and optimised for fast aggregation.
resultSourceToDoubleStatsEitherValues :: MonadComp m => ResultSource m -> [ResultValue (Either Double (SamplingStats Double)) m]

-- | Represent the result source as timing statistics based on double
--   floating point numbers.
resultSourceToDoubleTimingStatsValues :: MonadComp m => ResultSource m -> [ResultValue (TimingStats Double) m]

-- | Represent the result source as string values.
resultSourceToStringValues :: MonadComp m => ResultSource m -> [ResultValue String m]

-- | The sources of simulation results as a map of associated names.
resultSourceMap :: Results m -> ResultSourceMap m

-- | The sources of simulation results as an ordered list.
resultSourceList :: Results m -> [ResultSource m]

-- | Represent the results as integer numbers.
resultsToIntValues :: MonadComp m => Results m -> [ResultValue Int m]

-- | Represent the results as lists of integer numbers.
resultsToIntListValues :: MonadComp m => Results m -> [ResultValue [Int] m]

-- | Represent the results as statistics based on integer numbers.
resultsToIntStatsValues :: MonadComp m => Results m -> [ResultValue (SamplingStats Int) m]

-- | Represent the results as statistics based on integer numbers and
--   optimised for fast aggregation.
resultsToIntStatsEitherValues :: MonadComp m => Results m -> [ResultValue (Either Int (SamplingStats Int)) m]

-- | Represent the results as timing statistics based on integer numbers.
resultsToIntTimingStatsValues :: MonadComp m => Results m -> [ResultValue (TimingStats Int) m]

-- | Represent the results as double floating point numbers.
resultsToDoubleValues :: MonadComp m => Results m -> [ResultValue Double m]

-- | Represent the results as lists of double floating point numbers.
resultsToDoubleListValues :: MonadComp m => Results m -> [ResultValue [Double] m]

-- | Represent the results as statistics based on double floating point
--   numbers.
resultsToDoubleStatsValues :: MonadComp m => Results m -> [ResultValue (SamplingStats Double) m]

-- | Represent the results as statistics based on double floating point
--   numbers and optimised for fast aggregation.
resultsToDoubleStatsEitherValues :: MonadComp m => Results m -> [ResultValue (Either Double (SamplingStats Double)) m]

-- | Represent the results as timing statistics based on double floating
--   point numbers.
resultsToDoubleTimingStatsValues :: MonadComp m => Results m -> [ResultValue (TimingStats Double) m]

-- | Represent the results as string values.
resultsToStringValues :: MonadComp m => Results m -> [ResultValue String m]

-- | Compose the results using the specified transformation function.
composeResults :: (ResultSource m -> [ResultSource m]) -> ResultTransform m

-- | Return a new result value by the specified name, identifier and
--   computation.
computeResultValue :: ResultComputing t m => ResultName -> ResultId -> t m a -> ResultValue a m
instance (MonadComp m, Show s, ResultItemable (ResultValue s)) => ResultProvider (Activity m s a b) m
instance (MonadComp m, Show s, ResultItemable (ResultValue s)) => ResultProvider (Server m s a b) m
instance MonadComp m => ResultProvider (ArrivalTimer m) m
instance (MonadComp m, Show sm, Show so, ResultItemable (ResultValue sm), ResultItemable (ResultValue so)) => ResultProvider (Queue m sm so a) m
instance (MonadComp m, Show si, Show sm, Show so, ResultItemable (ResultValue si), ResultItemable (ResultValue sm), ResultItemable (ResultValue so)) => ResultProvider (Queue m si sm so a) m
instance ResultComputing t m => ResultProvider (t m (Vector Int)) m
instance ResultComputing t m => ResultProvider (t m (Vector Double)) m
instance (Ix i, Show i, ResultComputing t m) => ResultProvider (t m (Array i Int)) m
instance (Ix i, Show i, ResultComputing t m) => ResultProvider (t m (Array i Double)) m
instance ResultProvider p m => ResultProvider (ResultVectorWithSubscript p) m
instance (Show i, Ix i, ResultProvider p m) => ResultProvider (ResultArrayWithSubscript i p) m
instance ResultProvider p m => ResultProvider (ResultListWithSubscript p) m
instance ResultProvider p m => ResultProvider (Vector p) m
instance (Show i, Ix i, ResultProvider p m) => ResultProvider (Array i p) m
instance ResultProvider p m => ResultProvider [p] m
instance ResultComputing t m => ResultProvider (t m String) m
instance ResultComputing t m => ResultProvider (t m (TimingCounter Int)) m
instance ResultComputing t m => ResultProvider (t m (SamplingCounter Int)) m
instance ResultComputing t m => ResultProvider (t m (TimingStats Int)) m
instance ResultComputing t m => ResultProvider (t m (SamplingStats Int)) m
instance ResultComputing t m => ResultProvider (t m [Int]) m
instance ResultComputing t m => ResultProvider (t m Int) m
instance ResultComputing t m => ResultProvider (t m (TimingCounter Double)) m
instance ResultComputing t m => ResultProvider (t m (SamplingCounter Double)) m
instance ResultComputing t m => ResultProvider (t m (TimingStats Double)) m
instance ResultComputing t m => ResultProvider (t m (SamplingStats Double)) m
instance ResultComputing t m => ResultProvider (t m [Double]) m
instance ResultComputing t m => ResultProvider (t m Double) m
instance MonadComp m => ResultComputing Signalable m
instance MonadComp m => ResultComputing Var m
instance MonadComp m => ResultComputing Ref m
instance MonadComp m => ResultComputing Ref m
instance MonadComp m => ResultComputing Event m
instance MonadComp m => ResultComputing Dynamics m
instance MonadComp m => ResultComputing Simulation m
instance MonadComp m => ResultComputing Parameter m
instance Monoid (Results m)
instance ResultItemable (ResultValue StaticPriorities)
instance ResultItemable (ResultValue SIRO)
instance ResultItemable (ResultValue LCFS)
instance ResultItemable (ResultValue FCFS)
instance ResultItemable (ResultValue ())
instance ResultItemable (ResultValue String)
instance ResultItemable (ResultValue Bool)
instance ResultItemable (ResultValue (TimingStats Double))
instance ResultItemable (ResultValue (TimingStats Int))
instance ResultItemable (ResultValue (SamplingStats Double))
instance ResultItemable (ResultValue (SamplingStats Int))
instance ResultItemable (ResultValue [Double])
instance ResultItemable (ResultValue [Int])
instance ResultItemable (ResultValue Double)
instance ResultItemable (ResultValue Int)
instance MonadComp m => Monoid (ResultSignal m)


-- | Tested with: GHC 7.8.3
--   
--   The module allows printing and converting the <a>Simulation</a>
--   <a>Results</a> to a <a>String</a>.
module Simulation.Aivika.Trans.Results.IO

-- | This is a function that prints the simulation results within the
--   <a>Event</a> computation synchronized with the event queue.
type ResultSourcePrint m = ResultSource m -> Event m ()

-- | This is a function that shows the simulation results within the
--   <a>Event</a> computation synchronized with the event queue.
type ResultSourceShowS m = ResultSource m -> Event m ShowS

-- | Print the results with the information about the modeling time.
printResultsWithTime :: (MonadComp m, MonadIO m) => ResultSourcePrint m -> Results m -> Event m ()

-- | Print the simulation results in start time.
printResultsInStartTime :: (MonadComp m, MonadIO m) => ResultSourcePrint m -> Results m -> Simulation m ()

-- | Print the simulation results in stop time.
printResultsInStopTime :: (MonadComp m, MonadIO m) => ResultSourcePrint m -> Results m -> Simulation m ()

-- | Print the simulation results in the integration time points.
printResultsInIntegTimes :: (MonadComp m, MonadIO m) => ResultSourcePrint m -> Results m -> Simulation m ()

-- | Print the simulation results in the specified time.
printResultsInTime :: (MonadComp m, MonadIO m) => Double -> ResultSourcePrint m -> Results m -> Simulation m ()

-- | Print the simulation results in the specified time points.
printResultsInTimes :: (MonadComp m, MonadIO m) => [Double] -> ResultSourcePrint m -> Results m -> Simulation m ()

-- | Run the simulation and then print the results in the start time.
printSimulationResultsInStartTime :: (MonadComp m, MonadIO m) => ResultSourcePrint m -> Simulation m (Results m) -> Specs m -> m ()

-- | Run the simulation and then print the results in the final time.
printSimulationResultsInStopTime :: (MonadComp m, MonadIO m) => ResultSourcePrint m -> Simulation m (Results m) -> Specs m -> m ()

-- | Run the simulation and then print the results in the integration time
--   points.
printSimulationResultsInIntegTimes :: (MonadComp m, MonadIO m) => ResultSourcePrint m -> Simulation m (Results m) -> Specs m -> m ()

-- | Run the simulation and then print the results in the specified time
--   point.
printSimulationResultsInTime :: (MonadComp m, MonadIO m) => Double -> ResultSourcePrint m -> Simulation m (Results m) -> Specs m -> m ()

-- | Run the simulation and then print the results in the specified time
--   points.
printSimulationResultsInTimes :: (MonadComp m, MonadIO m) => [Double] -> ResultSourcePrint m -> Simulation m (Results m) -> Specs m -> m ()

-- | Show the results with the information about the modeling time.
showResultsWithTime :: MonadComp m => ResultSourceShowS m -> Results m -> Event m ShowS

-- | Show the simulation results in start time.
showResultsInStartTime :: MonadComp m => ResultSourceShowS m -> Results m -> Simulation m ShowS

-- | Show the simulation results in stop time.
showResultsInStopTime :: MonadComp m => ResultSourceShowS m -> Results m -> Simulation m ShowS

-- | Show the simulation results in the integration time points.
--   
--   It may consume much memory, for we have to traverse all the
--   integration points to create the resulting function within the
--   <a>Simulation</a> computation.
showResultsInIntegTimes :: MonadComp m => ResultSourceShowS m -> Results m -> Simulation m ShowS

-- | Show the simulation results in the specified time point.
showResultsInTime :: MonadComp m => Double -> ResultSourceShowS m -> Results m -> Simulation m ShowS

-- | Show the simulation results in the specified time points.
--   
--   It may consume much memory, for we have to traverse all the specified
--   points to create the resulting function within the <a>Simulation</a>
--   computation.
showResultsInTimes :: MonadComp m => [Double] -> ResultSourceShowS m -> Results m -> Simulation m ShowS

-- | Run the simulation and then show the results in the start time.
showSimulationResultsInStartTime :: MonadComp m => ResultSourceShowS m -> Simulation m (Results m) -> Specs m -> m ShowS

-- | Run the simulation and then show the results in the final time.
showSimulationResultsInStopTime :: MonadComp m => ResultSourceShowS m -> Simulation m (Results m) -> Specs m -> m ShowS

-- | Run the simulation and then show the results in the integration time
--   points.
--   
--   It may consume much memory, for we have to traverse all the
--   integration points to create the resulting function within the
--   <a>IO</a> computation.
showSimulationResultsInIntegTimes :: MonadComp m => ResultSourceShowS m -> Simulation m (Results m) -> Specs m -> m ShowS

-- | Run the simulation and then show the results in the integration time
--   point.
showSimulationResultsInTime :: MonadComp m => Double -> ResultSourceShowS m -> Simulation m (Results m) -> Specs m -> m ShowS

-- | Run the simulation and then show the results in the specified time
--   points.
--   
--   It may consume much memory, for we have to traverse all the specified
--   points to create the resulting function within the <a>IO</a>
--   computation.
showSimulationResultsInTimes :: MonadComp m => [Double] -> ResultSourceShowS m -> Simulation m (Results m) -> Specs m -> m ShowS

-- | Print a localised text representation of the results by the specified
--   source and with the given indent.
hPrintResultSourceIndented :: (MonadComp m, MonadIO m) => Handle -> Int -> ResultLocalisation -> ResultSourcePrint m

-- | Print a localised text representation of the results by the specified
--   source.
hPrintResultSource :: (MonadComp m, MonadIO m) => Handle -> ResultLocalisation -> ResultSourcePrint m

-- | Print in Russian a text representation of the results by the specified
--   source.
hPrintResultSourceInRussian :: (MonadComp m, MonadIO m) => Handle -> ResultSourcePrint m

-- | Print in English a text representation of the results by the specified
--   source.
hPrintResultSourceInEnglish :: (MonadComp m, MonadIO m) => Handle -> ResultSourcePrint m

-- | Print a localised text representation of the results by the specified
--   source and with the given indent.
printResultSourceIndented :: (MonadComp m, MonadIO m) => Int -> ResultLocalisation -> ResultSourcePrint m

-- | Print a localised text representation of the results by the specified
--   source.
printResultSource :: (MonadComp m, MonadIO m) => ResultLocalisation -> ResultSourcePrint m

-- | Print in Russian a text representation of the results by the specified
--   source.
printResultSourceInRussian :: (MonadComp m, MonadIO m) => ResultSourcePrint m

-- | Print in English a text representation of the results by the specified
--   source.
printResultSourceInEnglish :: (MonadComp m, MonadIO m) => ResultSourcePrint m

-- | Show a localised text representation of the results by the specified
--   source and with the given indent.
showResultSourceIndented :: MonadComp m => Int -> ResultLocalisation -> ResultSourceShowS m

-- | Show a localised text representation of the results by the specified
--   source.
showResultSource :: MonadComp m => ResultLocalisation -> ResultSourceShowS m

-- | Show in Russian a text representation of the results by the specified
--   source.
showResultSourceInRussian :: MonadComp m => ResultSourceShowS m

-- | Show in English a text representation of the results by the specified
--   source.
showResultSourceInEnglish :: MonadComp m => ResultSourceShowS m


-- | Tested with: GHC 7.8.3
--   
--   This module re-exports the most part of the library functionality. But
--   there are modules that must be imported explicitly, though.
module Simulation.Aivika.Trans
