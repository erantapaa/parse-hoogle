-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Benchmarking code through strict evaluation
--   
--   A benchmarking library with a simple purpose: to strictly evaluate a
--   value and report how long it takes.
--   
--   Can be useful to identify the slow part of an algorithm, since
--   Haskell's lazy evaluation can make it hard to see where the bottleneck
--   lies.
@package StrictBench
@version 0.1.1


-- | A library to benchmark how long it takes to fully evaluate a value.
--   Can be useful to identify the slow part of an algorithm, since
--   Haskell's lazy evaluation can make it hard to see where the bottleneck
--   lies.
--   
--   Full evalution of a value is achieved by the <a>rnf</a> function,
--   which requires that the data type of the value being tested is an
--   instance of <a>NFData</a>. Making a data type an instance of
--   <a>NFData</a> is trivially done by applying <a>rnf</a> to all of its
--   fields and <a>seq</a>-ing those together.
--   
--   Example:
--   
--   <pre>
--   data Tree3 a = Leaf a | Branch (Tree3 a) (Tree3 a) (Tree3 a)
--   
--   instance NFData a =&gt; NFData (Tree3 a) where
--       rnf (Leaf x) = rnf x
--       rnf (Branch l c r) = rnf l `seq` rnf c `seq` rnf r
--       
--   main = bench . take 13 $ iterate (\x -&gt; Branch x x x) (Leaf 'a')
--   
--   Output:
--   765.625 ms
--   </pre>
--   
--   If a data constructor has no fields you can suffice with (), e.g.:
--   
--   <pre>
--   data Answer = Yes | No
--   
--   instance NFData Answer where
--       rnf Yes = ()
--       rnf No  = ()
--   </pre>
module Test.StrictBench

-- | Print how long it takes to strictly evaluate the given value.
--   
--   Example:
--   
--   <pre>
--   main = bench [1..10000000 :: Integer]
--   
--   Output:
--   515.625 ms
--   </pre>
bench :: (NFData a) => a -> IO ()

-- | Like <a>bench</a>, benchDesc prints the time needed to fully evaluate
--   the given value. Additionally, it prefixes the time taken with the
--   provided string, which can be useful to distinguish between different
--   benchmarks.
--   
--   Example:
--   
--   <pre>
--   main = benchDesc "Long string" $ replicate 10000000 'a'
--   
--   Output:
--   Long string: 375.0 ms
--   </pre>
benchDesc :: (NFData a) => String -> a -> IO ()

-- | The function used by bench and benchpress to determine how long (in
--   milliseconds) the value takes to calculate. You can use this function
--   for instance if you wish to sum the time of several different values.
--   
--   Example:
--   
--   <pre>
--   main = do t1 &lt;- time $ filter (&lt; 10) $ take 1000000 $ repeat (9 :: Int)
--             t2 &lt;- time $ reverse $ take 1000000 $ cycle "StrictBench"
--             print $ t1 + t2
--   
--   Output:
--   562.5
--   </pre>
time :: (NFData a) => a -> IO Double
class NFData a
rnf :: (NFData a) => a -> ()

-- | rnf should reduce its argument to normal form (that is, fully evaluate
--   all sub-components), and then return '()'.
--   
--   The default implementation of <a>rnf</a> is
--   
--   <pre>
--   rnf a = a `seq` ()
--   </pre>
--   
--   which may be convenient when defining instances for data types with no
--   unevaluated fields (e.g. enumerations).
rnf :: (NFData a) => a -> ()
