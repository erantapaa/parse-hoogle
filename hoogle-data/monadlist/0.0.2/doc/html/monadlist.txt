-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Monadic versions of list functions
--   
--   Monadic versions of list functions seen in Data.List.
@package monadlist
@version 0.0.2


module Control.Monad.ListM
mapMP :: (Monad m, MonadPlus p) => (a -> m b) -> [a] -> m (p b)
filterMP :: (Monad m, MonadPlus p) => (a -> m Bool) -> [a] -> m (p a)
intersperseM :: (Monad m, MonadPlus p) => m a -> [a] -> m (p a)
intercalateM :: (Monad m, MonadPlus p) => m (p a) -> [p a] -> m (p a)
foldM1 :: Monad m => (a -> a -> m a) -> [a] -> m a
joinMap :: Monad m => (a -> m b) -> m a -> m b
joinMapM :: (Monad m, MonadPlus p) => (a -> m (p b)) -> [a] -> m (p b)
anyM :: (Monad m, Traversable t) => (a -> m Bool) -> t a -> m Bool
allM :: (Monad m, Traversable t) => (a -> m Bool) -> t a -> m Bool
scanM :: (Monad m, MonadPlus p) => (a -> b -> m a) -> a -> [b] -> m (p a)
mapAccumM :: (Monad m, MonadPlus p) => (acc -> x -> m (acc, y)) -> acc -> [x] -> m (acc, p y)
iterateM :: (Monad m, MonadPlus p) => (a -> m a) -> a -> m (p a)
takeM :: (Integral i, Monad m, MonadPlus p) => i -> [m a] -> m (p a)
dropM :: (Integral i, Monad m) => i -> [m a] -> m [a]
splitAtM :: (Integral i, Monad m, MonadPlus p) => i -> [m a] -> m (p a, [a])
takeWhileM :: (Monad m, MonadPlus p) => (a -> m Bool) -> [a] -> m (p a)
dropWhileM :: Monad m => (a -> m Bool) -> [a] -> m [a]
spanM :: (Monad m, MonadPlus p) => (a -> m Bool) -> [a] -> m (p a, [a])
breakM :: (Monad m, MonadPlus p) => (a -> m Bool) -> [a] -> m (p a, [a])
elemM :: (Eq a, Monad m) => a -> [a] -> m Bool
notElemM :: (Eq a, Monad m) => a -> [a] -> m Bool
lookupM :: (Eq a, Monad m, MonadPlus p) => a -> [m (a, b)] -> m (p b)
findM :: (Monad m, MonadPlus p) => (a -> m Bool) -> [a] -> m (p a)
partitionM :: (Monad m, MonadPlus p) => (a -> m Bool) -> [a] -> m (p a, [a])
elemIndexM :: (Eq a, Integral i, Monad m, MonadPlus p) => a -> [a] -> m (p i)
elemIndicesM :: (Eq a, Integral i, Monad m, MonadPlus p) => a -> [a] -> m (p i)
findIndexM :: (Integral i, Monad m, MonadPlus p) => (a -> m Bool) -> [a] -> m (p i)
findIndicesM :: (Integral i, Monad m, MonadPlus p) => (a -> m Bool) -> [a] -> m (p i)
zipWithM3 :: (Monad m, MonadPlus p) => (a -> b -> c -> m d) -> [a] -> [b] -> [c] -> m (p d)
zipWithM4 :: (Monad m, MonadPlus p) => (a -> b -> c -> d -> m e) -> [a] -> [b] -> [c] -> [d] -> m (p e)
zipWithM5 :: (Monad m, MonadPlus p) => (a -> b -> c -> d -> e -> m f) -> [a] -> [b] -> [c] -> [d] -> [e] -> m (p f)
zipWithM6 :: (Monad m, MonadPlus p) => (a -> b -> c -> d -> e -> f -> m g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> m (p g)
nubM :: (Eq a, Monad m, MonadPlus p) => [a] -> m (p a)
nubByM :: (Monad m, MonadPlus p) => (a -> a -> m Bool) -> [a] -> m (p a)
deleteM :: (Eq a, Monad m) => a -> [a] -> m [a]
deleteByM :: Monad m => (a -> a -> m Bool) -> a -> [a] -> m [a]
deleteFirstsM :: (Eq a, Monad m) => [a] -> [a] -> m [a]
deleteFirstsByM :: Monad m => (a -> a -> m Bool) -> [a] -> [a] -> m [a]
unionM :: (Eq a, Monad m) => [a] -> [a] -> m [a]
unionByM :: Monad m => (a -> a -> m Bool) -> [a] -> [a] -> m [a]
intersectM :: (Eq a, Monad m, MonadPlus p) => [a] -> [a] -> m (p a)
intersectByM :: (Monad m, MonadPlus p) => (a -> a -> m Bool) -> [a] -> [a] -> m (p a)
groupM :: (Eq a, Monad m, MonadPlus p, MonadPlus q) => [a] -> m (p (q a))
groupByM :: (Monad m, MonadPlus p, MonadPlus q) => (a -> a -> m Bool) -> [a] -> m (p (q a))
sortM :: (Ord a, Monad m) => [a] -> m [a]
sortByM :: Monad m => (a -> a -> m Ordering) -> [a] -> m [a]
insertM :: (Ord a, Monad m) => a -> [a] -> m [a]
insertByM :: Monad m => (a -> a -> m Ordering) -> a -> [a] -> m [a]
maximumM :: (Ord a, Monad m) => [a] -> m a
maximumByM :: Monad m => (a -> a -> m Ordering) -> [a] -> m a
minimumM :: (Ord a, Monad m) => [a] -> m a
minimumByM :: Monad m => (a -> a -> m Ordering) -> [a] -> m a
