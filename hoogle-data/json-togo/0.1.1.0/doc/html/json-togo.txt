-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Effectful parsing of JSON documents
--   
@package json-togo
@version 0.1.1.0

module Data.JSON.ToGo.Parser
type ParserM = ParserT ByteString
rP :: Monad m => Parser ByteString r -> ParserT ByteString m r
parray :: (Monad m, Monoid r) => (Int -> ParserM m r) -> ParserM m r
pobject :: (Monad m, Monoid r) => (Text -> ParserM m r) -> ParserM m r
parrayL :: Monad m => (Int -> ParserM m r) -> ParserM m [r]
pobjectL :: Monad m => (Text -> ParserM m r) -> ParserM m [r]
parray_ :: Monad m => (Int -> ParserM m r) -> ParserM m ()
pobject_ :: Monad m => (Text -> ParserM m r) -> ParserM m ()
pnull :: Monad m => ParserM m ()
pbool :: Monad m => ParserM m Bool
pnumber :: Monad m => ParserM m Scientific
pstring :: Monad m => ParserM m Text
pvalue :: Monad m => ParserM m Value
pskip :: Monad m => ParserM m ()
parse :: (Monad m, FromJSON a) => ParserM m a

module Data.JSON.ToGo
data ValueT m a
NullM :: m a -> ValueT m a
matchNull :: ValueT m a -> m a
BoolM :: (Bool -> m a) -> ValueT m a
matchBool :: ValueT m a -> Bool -> m a
NumberM :: (Scientific -> m a) -> ValueT m a
matchNumber :: ValueT m a -> Scientific -> m a
StringM :: (Text -> m a) -> ValueT m a
matchString :: ValueT m a -> Text -> m a
ArrayM :: (Int -> ValueT m a) -> ValueT m a
matchArray :: ValueT m a -> Int -> ValueT m a
ObjectM :: (Text -> ValueT m a) -> ValueT m a
matchText :: ValueT m a -> Text -> ValueT m a
AnyM :: (Value -> m a) -> ValueT m a
matchAny :: ValueT m a -> Value -> m a
NoneM :: ValueT m a
toValueT :: Monad m => Value -> ValueT m Bool
matchValueT :: MonadPlus m => ValueT m a -> Value -> m a
matchValueT_ :: Monad m => ValueT m a -> Value -> m ()
parseValueT :: (Monad m, Monoid r) => ValueT m r -> ParserM m r
parseValueT_ :: Monad m => ValueT m a -> ParserM m ()
instance Monad m => Applicative (ValueT m)
instance Monad m => Functor (ValueT m)
