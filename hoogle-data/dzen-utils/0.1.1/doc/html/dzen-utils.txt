-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Utilities for creating inputs for dzen.
--   
--   This library has everything you need to create your <tt>dzen</tt>'s
--   bar input strings using powerful combinators in a type-safe way.
--   
--   It can be used to create standalone "scripts" with <tt>runhaskell</tt>
--   or it can be used inside <tt>xmonad</tt>'s main function.
--   
--   To see what can be done, please read the documentation of the toplevel
--   module <a>System.Dzen</a>.
@package dzen-utils
@version 0.1.1


-- | This module contains most of the basic functions of this package. The
--   data types presented here are:
--   
--   <ul>
--   <li><i><a>DString</a></i> strings that support constant time
--   concatenation, dzen attributes and some instropection.</li>
--   <li><i><a>Printer</a></i> encapsulates functions take take some input
--   and produce a <tt>DString</tt> as a result, allowing them to be
--   combined and applied.</li>
--   </ul>
module System.Dzen.Base

-- | A <tt>DString</tt> is used for constant string output, see
--   <tt>str</tt>. The <tt>D</tt> on <tt>DString</tt> stands for
--   <tt>dzen</tt>, as these strings may change depending on the state (and
--   that's why you shouldn't rely on <a>Show</a>, as it just uses an empty
--   state)
data DString

-- | Converts a <tt>String</tt> into a <tt>DString</tt>, escaping
--   characters if needed. This function is used in <a>fromString</a> from
--   <a>IsString</a>, so <tt>DString</tt>s created by
--   <tt>OverloadedStrings</tt> extension will be escaped.
str :: String -> DString

-- | Converts a <tt>String</tt> into a <tt>DString</tt> without escaping
--   anything. You <i>really</i> don't need to use this, trust me!
rawStr :: String -> DString

-- | Converts a <tt>DString</tt> back into a <tt>String</tt>. Note that
--   <tt>(toString . rawStr)</tt> is not <tt>id</tt>, otherwise
--   <tt>toString</tt> would not work in some cases. Probably you don't
--   need to use this, unless you want something like a static bar and
--   nothing else.
toString :: DString -> String

-- | Tries to get the number of characters of the <tt>DString</tt>. May
--   return <tt>Nothing</tt> when there are graphical objects. Probably you
--   don't need to use this function.
size :: DString -> Maybe Int

-- | <tt>parens open close d</tt> is equivalent to <tt>mconcat [open, d,
--   close]</tt>.
parens :: DString -> DString -> DString -> DString

-- | A printer is used when the output depends on an input, so a
--   <tt>Printer a</tt> generates a <a>DString</a> based on some input of
--   type <tt>a</tt> (and possibly updates some internal state).
data Printer a

-- | A <tt>Printer</tt> is a cofunctor.
comap :: (a -> b) -> (Printer b -> Printer a)

-- | Constructs a <tt>Printer</tt> that depends only on the input.
simple :: (a -> DString) -> Printer a

-- | Like <a>simple</a>, but using <tt>String</tt>s.
simple' :: (a -> String) -> Printer a

-- | Constructs a <tt>Printer</tt> that depends on the current and on the
--   previous inputs.
inputPrinter :: (b -> a -> (DString, b)) -> b -> Printer a

-- | Like <a>inputPrinter</a>, but with <tt>String</tt>s.
inputPrinter' :: (b -> a -> (String, b)) -> b -> Printer a

-- | Works like <a>str</a>, but uses the input instead of being constant.
--   In fact, it is defined as <tt>simple str</tt>.
cstr :: Printer String

-- | Same as <tt>simple' show</tt>.
cshow :: Show a => Printer a

-- | Class used for combining <tt>DString</tt>s and <tt>Printer</tt>s
--   exactly like <a>mappend</a>.
--   
--   Note that we don't lift <tt>DString</tt> to <tt>Printer ()</tt> and
--   use a plain function of type <tt>Printer a -&gt; Printer b -&gt;
--   Printer (a,b)</tt> because that would create types such as <tt>Printer
--   ((),(a,((),(b,()))))</tt> instead of <tt>Printer (a,b)</tt>.
class Combine a b where type family Combined a b :: *
(+++) :: Combine a b => a -> b -> Combined a b

-- | Sometimes you want two printers having the same input, but <tt>p1 +++
--   p2 :: Printer (a,a)</tt> is not convenient. So <tt>p1 +=+ p2 ::
--   Printer a</tt> works like <a>+++</a> but gives the same input for both
--   printers.
(+=+) :: Printer a -> Printer a -> Printer a

-- | Works like <a>+=+</a> but the second printer's input is a tuple.
(+-+) :: Printer a -> Printer (a, b) -> Printer (a, b)

-- | While you may say <tt>p1 +=+ (ds1 +++ ds2 +++ p2)</tt>, where
--   <tt>p1,p2 :: Printer a</tt> and <tt>ds1,ds2 :: DString</tt>, you can't
--   say <tt>p1 +=+ (po +++ p2)</tt> nor <tt>(p1 +++ po) +=+ p2</tt> where
--   <tt>po :: Printer b</tt>.
--   
--   This operator works like <a>+++</a> but shifts the tuple, giving you
--   <tt>Printer (b,a)</tt> instead of <tt>Printer (a,b)</tt>. In the
--   example above you may write <tt>p1 +&gt;+ po +/+ p2</tt>.
(+/+) :: Printer a -> Printer b -> Printer (b, a)

-- | This operator works like <a>+/+</a> but the second printer's input is
--   a tuple. Use it like
--   
--   <pre>
--   pA1 +-+ pB +&lt;+ pC +&lt;+ pD +/+ pA2 :: Printer (a,(b,(c,d)))
--   </pre>
--   
--   where both <tt>pA1</tt> and <tt>pA2</tt> are of type <tt>Printer
--   a</tt>.
(+<+) :: Printer a -> Printer (b, c) -> Printer (b, (a, c))

-- | This is a general combine function for <tt>Printer</tt>s. The outputs
--   are always concatenated, but the inputs are given by the supplied
--   function.
--   
--   The combining operators above are defined as:
--   
--   <pre>
--   (+++) = combine id    -- restricted to Printers
--   (+=+) = combine (\x -&gt; (    x, x))
--   (+-+) = combine (\x -&gt; (fst x, x))
--   (+/+) = combine (\(a,b)     -&gt; (b,a))
--   (+&lt;+) = combine (\(b,(a,c)) -&gt; (a,(b,c)))
--   </pre>
--   
--   Note also the resamblence with <a>comap</a>. In fact, if we have
--   <tt>(+++)</tt> and <tt>comap</tt> we may define
--   
--   <pre>
--   combine f a b = comap f (a +++ b)       -- pointwise
--   combine = flip (.) (+++) . (.) . comap  -- pointfree
--   </pre>
--   
--   and with <tt>combine</tt> and <tt>simple</tt> we may define
--   
--   <pre>
--   comap f = combine (\i -&gt; ((), f i)) (simple $ const mempty) -- pointwise
--   comap = flip combine (simple $ const mempty) . ((,) () .)   -- pointfree
--   </pre>
combine :: (c -> (a, b)) -> Printer a -> Printer b -> Printer c

-- | Apply a printer to an appropriate input, returning the output string
--   and the new printer.
apply :: Printer a -> a -> (String, Printer a)

-- | Apply a printer many times in sequence. Most of the time you would
--   ignore the final printer using <a>applyMany_</a>, but it can be used
--   to continue applying.
applyMany :: Printer a -> [a] -> ([String], Printer a)

-- | Like <a>applyMany</a> but ignoring the final printer.
applyMany_ :: Printer a -> [a] -> [String]

-- | Apply a printer forever inside a monad. The first action is used as a
--   supply of inputs while the second action receives the output before
--   the next input is requested.
--   
--   Note that your supply may be anything. For example, inside <tt>IO</tt>
--   you may use <tt>threadDelay</tt>:
--   
--   <pre>
--   applyForever (threadDelay 100000 &gt;&gt; getInfo) (hPutStrLn dzenHandle)
--   </pre>
applyForever :: Monad m => Printer a -> m a -> (String -> m ()) -> m ()

-- | <tt>Transform</tt> is a specialization of <tt>Functor</tt> for
--   <tt>DString</tt>s. This class is used for functions that may receive
--   <tt>DString</tt> or <tt>Printer a</tt> as an argument because they
--   operate only on their outputs and internal states (and not on the
--   inputs).
--   
--   So, whenever you see a function of type
--   
--   <pre>
--   func :: Transform a =&gt; Blah -&gt; Bleh -&gt; a -&gt; a
--   </pre>
--   
--   it means that <tt>func</tt> can be used in two ways:
--   
--   <pre>
--   func :: Blah -&gt; Bleh -&gt; DString -&gt; DString
--   func :: Blah -&gt; Bleh -&gt; Printer a -&gt; Printer a  -- Printer of any input!
--   </pre>
--   
--   Try to have this in mind when reading the types.
--   
--   Note: There is also a non-exported <tt>transformSt</tt> for
--   transforming the state in this class, otherwise it would be
--   meaningless to use a class only for <tt>transform</tt> (it would be
--   better to make <tt>liftT :: (DString -&gt; DString) -&gt; (Printer a
--   -&gt; Printer a)</tt>).
class Transform a where transform f = transformSt (\ st -> (st, f))
transform :: Transform a => (DString -> DString) -> (a -> a)
instance Combine (Printer a) (Printer b)
instance Combine (Printer a) DString
instance Combine DString (Printer a)
instance Combine DString DString


-- | Support for colours. This module is entirely based on the
--   <tt>colour</tt> package, so we strongly recommend that you at least
--   
--   <pre>
--   import qualified Data.Colour.Names as C
--   </pre>
--   
--   which will import various aliases for creating <a>Colour</a>s.
--   
--   Note changing the colours using the functions below do not hinder the
--   use of automatic padding.
module System.Dzen.Colour

-- | Our colours.
type DColour = Colour Double

-- | Set the foreground colour. Note that the foreground colour is changed
--   only inside the transformed <tt>DString</tt> or <tt>Printer</tt>,
--   unlike using <tt>"^fg"</tt> which may affect subsequent strings.
--   
--   So you may write <tt>fg <tt>black</tt> (fg <tt>lime</tt> (str "lime")
--   +++ str "black")</tt> and it works like you expect it to.
fg :: Transform a => DColour -> (a -> a)

-- | Like <a>fg</a>, but set the background colour.
bg :: Transform a => DColour -> (a -> a)

-- | Set the foreground colour to be the default one, which is specified as
--   a parameter to dzen (outside the control of the printers).
defFg :: Transform a => a -> a

-- | Like <a>defFg</a>, but for the background colour.
defBg :: Transform a => a -> a

-- | Set the foreground to be a specified one (<tt>Just c</tt>) or the
--   dzen's default (<tt>Nothing</tt>). Both <a>fg</a> and <a>defFg</a> are
--   specializations of this function.
changeFg :: Transform a => Maybe DColour -> (a -> a)

-- | Like <a>changeFg</a>, but for the background colour.
changeBg :: Transform a => Maybe DColour -> (a -> a)


-- | Support for the graphical abilities of <tt>dzen</tt>. Unfortunately
--   this is not the strongest are of <tt>dzen</tt>, so there isn't a lot
--   of functionality here, but there are "bindings" for every function
--   they provide.
--   
--   You can draw:
--   
--   <ul>
--   <li><i>icons</i> With <a>icon</a> (see <tt>dzen</tt> documentation
--   about formats and paths).</li>
--   <li><i>rectanges</i> With <a>rect</a> and <a>rectO</a>.</li>
--   <li><i>circles</i> With <a>circ</a> and <a>circO</a>.</li>
--   </ul>
--   
--   Although it may seem that you can draw anything with the rectangle
--   primitive (i.e. in the worst case just use 1x1 rectangles to simulate
--   pixels), <tt>dzen</tt> does not allow you to control the <tt>y</tt>
--   part of the shapes, only the <tt>x</tt> part (using <a>pos</a> and
--   <a>absPos</a>): they are always vertically centered.
module System.Dzen.Graphics
type Width = Int
type Height = Int
type Radius = Int

-- | Draws an icon.
icon :: FilePath -> DString

-- | <tt>rect w h</tt> draws and fills a rectangle of width <tt>w</tt> and
--   height <tt>h</tt>. The rectangle is vertically centered (that is, if
--   <tt>h == 1</tt> then it is a centered line, something like
--   <tt>----</tt>).
rect :: Width -> Height -> DString

-- | Like <tt>rect</tt>, but only draws and does not fills (i.e. draws an
--   outline).
rectO :: Width -> Height -> DString

-- | <tt>circ r</tt> draws and fils a circle of radius <tt>r</tt>, also
--   vertically centered.
circ :: Radius -> DString

-- | Like <tt>circ</tt>, but does not fills.
circO :: Radius -> DString

-- | <tt>pos p</tt> moves the position of the next input <tt>p</tt> pixels
--   to the right. Note that <tt>p</tt> may be negative, effectively moving
--   to the right.
pos :: Int -> DString

-- | <tt>absPos p</tt> moves the position of the next input to be exactly
--   <tt>p</tt> pixels to the right of the initial position. This should be
--   used with care.
absPos :: Int -> DString

-- | If <tt>True</tt>, the transformed <tt>DString</tt> or <tt>Printer</tt>
--   will ignore the background colour (i.e. it will draw over what was
--   already drawn). The default is <tt>False</tt>, the background colour
--   is used.
ignoreBg :: Transform a => Bool -> (a -> a)


-- | This is a handy module with functions for manual and automatic
--   padding. To pad means to force the length of a string to be of a
--   minimum size by adding <i>padding characters</i> on either or both
--   sides of the string (usually spaces). For example, padding the string
--   <tt>"123"</tt> to have length of 10 characters would give us the
--   string
--   
--   <pre>
--   "       123"   -- if padding on the left
--   "123       "   -- if padding on the right
--   "    123   "   -- if padding on both sides
--   </pre>
--   
--   We provide two kinds of padding here:
--   
--   <ul>
--   <li><i>manual padding</i> This is the kind of padding you usually see
--   in other (non-<tt>dzen</tt>) libraries. You give them the type of
--   padding and the minimum length that you want and they will give you
--   back another string. The <tt>pad*</tt> functions do this with both
--   plain <tt>DString</tt>s and with the output of <tt>Printer</tt>s.</li>
--   <li><i>automatic padding</i> This is the same as a "never shrink"
--   padding. An automatic padder adjusts its minimum length to be at least
--   the greatest length it has seen so far, which means that an
--   auto-padded <tt>Printer</tt> will never shrink its size. This is very
--   useful if you don't want everything swinging on your bar everytime the
--   bar is updated.</li>
--   </ul>
module System.Dzen.Padding

-- | Pads the given <tt>DString</tt> or <tt>Printer</tt> output with spaces
--   to be at least <tt>n</tt> chars in length
padL :: Transform a => Int -> (a -> a)

-- | Same as <a>padL</a>, but insert spaces on the right of the string.
padR :: Transform a => Int -> (a -> a)

-- | Same as <a>padL</a>, but insert spaces on both sides, trying to keep
--   the original contents in the middle.
padC :: Transform a => Int -> (a -> a)

-- | Generic pad function, padding with any character and in any place.
pad :: Transform a => Char -> PadWhere -> Int -> (a -> a)

-- | Where to add the padding characters.
data PadWhere
PadLeft :: PadWhere
PadRight :: PadWhere
PadCenter :: PadWhere

-- | Automatic padding for <a>padL</a>.
autoPadL :: Int -> (Printer a -> Printer a)

-- | Automatic padding for <a>padR</a>.
autoPadR :: Int -> (Printer a -> Printer a)

-- | Automatic padding for <a>padC</a>.
autoPadC :: Int -> (Printer a -> Printer a)

-- | Generic automatic padding function, analog to <a>pad</a>.
autoPad :: Char -> PadWhere -> Int -> (Printer a -> Printer a)


-- | Drawing of progress bars (sometimes called progress gauges), like
--   <tt>dbar</tt> and <tt>gdbar</tt> utilities work but a little more
--   powerful (in fact, we can simulate both utilities, see <a>dbar</a> and
--   <a>gdbar</a>).
--   
--   An example of text progress bar that can be drawn:
--   
--   <pre>
--   96% [==================&gt; ]
--   </pre>
module System.Dzen.Bars

-- | Mimics the dbar utility. Uses the <a>dbar_style</a>.
dbar :: (Num a, Enum a, Ord a, Show a) => Bool -> Width -> (a, a) -> a -> DString

-- | Mimics the dbar utility while getting the input dinamically.
cdbar :: (Num a, Enum a, Ord a, Show a) => Bool -> Width -> (a, a) -> Printer a

-- | Mimics the gdbar utility. Uses the <a>gdbar_style</a>.
gdbar :: (Num a, Enum a, Ord a, Show a) => Bool -> (Width, Height) -> Maybe DColour -> Maybe DColour -> Bool -> (a, a) -> a -> DString

-- | Mimics the gdbar utility while getting the input dinamically.
cgdbar :: (Num a, Enum a, Ord a, Show a) => Bool -> (Width, Height) -> Maybe DColour -> Maybe DColour -> Bool -> (a, a) -> Printer a

-- | Draws a bar and optionally some text describing some quantity in
--   relation to some range. For example,
--   
--   <pre>
--   bar (AtLeft Percentage) (Text "[" "=" (Just "&gt;") " " "]" 20) (-10,10) i
--   </pre>
--   
--   produces the bars
--   
--   <pre>
--   "  2% [                    ]"    where i = -9.6
--   "  2% [&gt;                   ]"    where i = -9.5
--   " 50% [=========&gt;          ]"    where i = 0
--   " 96% [==================&gt; ]"    where i = 9.4
--   " 99% [===================&gt;]"    where i = 9.99
--   "100% [====================]"    where i = 10
--   </pre>
--   
--   Note that the text is always padded to four characters. If the first
--   bar above had <tt>AtRight Percentage</tt> the result would be
--   
--   <pre>
--   "[                    ] 2%  "
--   </pre>
--   
--   so the padding always inserts the spaces on the outside.
bar :: (Num a, Enum a, Ord a, Show a) => BarText -> BarType -> (a, a) -> a -> DString

-- | <a>bar</a> wrapped with <a>simple</a> so that the value is taken from
--   an input.
cbar :: (Num a, Enum a, Ord a, Show a) => BarText -> BarType -> (a, a) -> Printer a

-- | The type of the bar to be drawn.
data BarType

-- | Draws a text bar. Note, however, that the <tt>DString</tt>s below can
--   be anything, not just text. For example, they may have colours
--   (<a>fg</a>), shapes (<a>rect</a>s and <a>circ</a>s) or <a>icon</a>s,
--   you may even simulate both <a>Filled</a> and <a>Hollow</a> using just
--   <a>Text</a> (although performance would be suboptimal).
Text :: !DString -> !DString -> !Maybe DString -> !DString -> !DString -> !Width -> BarType

-- | Text written at the start.
txtOpen :: BarType -> !DString

-- | Text written for each filled square.
txtFilled :: BarType -> !DString

-- | Text written for the last filled square. If <tt>Nothing</tt>, the same
--   as the filled square is used, but more fairly than if you used the
--   same value for filled and middle chars.
txtMiddle :: BarType -> !Maybe DString

-- | Text written for the unfilled squares.
txtBackground :: BarType -> !DString

-- | Text written at the end.
txtClose :: BarType -> !DString

-- | How many squares there should be (i.e. does not count the open and
--   close parts).
txtWidth :: BarType -> !Width

-- | Draws a filled graphical bar, like <tt>gdbar</tt> would.
Filled :: !Maybe DColour -> !Maybe DColour -> !(Width, Height) -> BarType

-- | Same as <tt>grpFilled</tt> above.
--   
--   Colour used for filled squares, or <tt>Nothing</tt> to use the default
--   <i>foreground</i> colour.
grpFilled :: BarType -> !Maybe DColour

-- | Same as <tt>grpBackground</tt> above.
--   
--   Colour used for the unfilled squares, or <tt>Nothing</tt> to use the
--   default <i>background</i> colour.
grpBackground :: BarType -> !Maybe DColour

-- | Size of the whole bar (including border).
--   
--   Size of the whole bar.
grpSize :: BarType -> !(Width, Height)

-- | Draws a filled graphical bar with a surrounding border.
Hollow :: !Maybe DColour -> !Maybe DColour -> !Maybe DColour -> !(Width, Height) -> BarType

-- | Same as <tt>grpFilled</tt> above.
--   
--   Colour used for filled squares, or <tt>Nothing</tt> to use the default
--   <i>foreground</i> colour.
grpFilled :: BarType -> !Maybe DColour

-- | Same as <tt>grpBackground</tt> above.
--   
--   Colour used for the unfilled squares, or <tt>Nothing</tt> to use the
--   default <i>background</i> colour.
grpBackground :: BarType -> !Maybe DColour

-- | Colour of the border, or <tt>Nothing</tt> to use the default
--   <i>foreground</i> colour.
grpBorder :: BarType -> !Maybe DColour

-- | Size of the whole bar (including border).
--   
--   Size of the whole bar.
grpSize :: BarType -> !(Width, Height)

-- | The type of text to be written.
data BarTextType
Percentage :: BarTextType
Absolute :: BarTextType

-- | How to draw the bar text. <tt>AtLeft</tt> and <tt>AtRight</tt> are
--   used to specify if the text is at the left or the right of the bar,
--   and <tt>None</tt> means that no text will be written.
data BarText
AtLeft :: !BarTextType -> BarText
AtRight :: !BarTextType -> BarText
None :: BarText

-- | The style produced by the dbar utility.
dbar_style :: Char -> Width -> BarType

-- | The style of gdbar (or something very close).
gdbar_style :: (Width, Height) -> Maybe DColour -> Maybe DColour -> Bool -> BarType
instance Show BarType
instance Eq BarTextType
instance Ord BarTextType
instance Show BarTextType
instance Enum BarTextType
instance Eq BarText
instance Ord BarText
instance Show BarText


-- | Functions for creating supplies and running <tt>dzen</tt>.
module System.Dzen.Process

-- | Pipes a <a>Printer</a> to a fresh instance of <tt>dzen</tt>. It runs
--   the following commands:
--   
--   <ol>
--   <li>Start <tt>dzen</tt> with the supplied executable and
--   arguments.</li>
--   <li>Call the supply to get an input.</li>
--   <li>Apply the input to the printer.</li>
--   <li>Write the printer's output to <tt>dzen</tt>'s standard input.</li>
--   <li>Sleeps for the specified delay using <a>threadDelay</a>.</li>
--   <li>Go back to step 2.</li>
--   </ol>
--   
--   You may want to use this function inside a <a>forkIO</a> if, for
--   example, you're inside <tt>xmonad</tt>.
runDzen :: FilePath -> [String] -> Int -> Printer a -> IO a -> IO ()

-- | This is the same as <tt>liftM2 (,)</tt>, but with as a convenient
--   operator with right infixity (the same as <a>+++</a>). For example,
--   suppose you have printers
--   
--   <pre>
--   prA :: Printer a
--   prB :: Printer b
--   prC :: Printer c
--   </pre>
--   
--   and supply functions
--   
--   <pre>
--   getA :: m a
--   getB :: m b
--   getC :: m c
--   </pre>
--   
--   for some monad <tt>m</tt>. The final printer
--   
--   <pre>
--   prFinal = prA +++ prB +++ prC
--   </pre>
--   
--   will be of type <tt>Printer (a,(b,c))</tt>, so you may use as its
--   supply function
--   
--   <pre>
--   getFinal = getA ## getB ## getC
--   </pre>
--   
--   which is of type <tt>m (a,(b,c))</tt>.
(##) :: Monad m => m a -> m b -> m (a, b)

-- | Runs a <tt>dzen</tt> instance and returns its <tt>stdin</tt> pipe.
--   Both <tt>stdout</tt> and <tt>stderr</tt> of the new process will be
--   the same as this process'. The pipe returned is already line buffered.
--   
--   The first string is interpreted as a shell command to start
--   <tt>dzen</tt>. Some examples of usage:
--   
--   <pre>
--   createDzen (RawCommand "dzen2" ["-p"])
--   createDzen (ShellCommand "dzen2 -l 8 -bg #331100")
--   </pre>
createDzen :: CmdSpec -> IO Handle

-- | Like <tt>createDzen</tt>, but never uses a shell (which is good).
createDzen' :: FilePath -> [String] -> IO Handle


-- | Hello!
--   
--   This is <tt>dzen-utils</tt>' main module. It re-exports every other
--   module from this library, so you may just say
--   
--   <pre>
--   import System.Dzen
--   </pre>
--   
--   and you'll have everything in hand. To learn more about this library,
--   please see the documentation of each module exported here. To get you
--   started, there are some simple examples below. :)
module System.Dzen
