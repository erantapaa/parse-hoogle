-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Measure container capacity. Use it to safely change container.
--   
--   This module introduces typeclasses
--   
--   <ul>
--   <li><tt>HasCard</tt> = "Has cardinality". In other words, "it's
--   possible to measure current count of elements for this container"</li>
--   <li><tt>HasCardT</tt> = "Has cardinality (for container types of kind
--   <tt>(* -&gt; *)</tt>)". In other words, "it's possible to measure
--   current count of elements for this container (for container types of
--   kind <tt>(* -&gt; *)</tt>)"</li>
--   <li><tt>HasCardConstr</tt> = "Has cardinality constraint". In other
--   words, "there is a capacity constraint for this container".</li>
--   <li><tt>HasCardConstrT</tt> = "Has cardinality constraint (for
--   container types of kind <tt>(* -&gt; *)</tt>)". In other words, "there
--   is a capacity constraint for this container type of kind <tt>(* -&gt;
--   *)</tt>".</li>
--   <li><tt>HasCardUCT</tt> = "Has cardinality-unsafe container
--   transform". Define transform that may thow an error, if contents of
--   <tt>from</tt> don't fit in <tt>to</tt> .</li>
--   <li><tt>HasCardUCT_T</tt> = "Has cardinality-unsafe container
--   transform (for container types of kind <tt>(* -&gt; *)</tt>)". Same
--   thing as <tt>HasCardUCT</tt>, but for containers of kind <tt>(* -&gt;
--   *)</tt>.</li>
--   </ul>
--   
--   No, it's not about playing cards. It's about cardinalities. Wikipedia:
--   "/In mathematics, the cardinality of a set is a measure of the number
--   of elements of the set. For example, the set A = 2, 4, 6 contains 3
--   elements, and therefore A has a cardinality of 3./" In this package I
--   dare to extend the definition a bit to "<i>C. is a measure of the
--   number of elements in a container</i>"
--   
--   Usual containers are (together with their cardinality ranges):
--   
--   <ul>
--   <li><tt>Identity a</tt> (1 element)</li>
--   <li><tt>Maybe a</tt> (0..1 element)</li>
--   <li><tt>[a]</tt> (0..inf elements)</li>
--   <li><tt>Map k e</tt> (0..inf elements)</li>
--   </ul>
--   
--   I extended this to the folowing list:
--   
--   <ul>
--   <li><tt>EmptySet a</tt> (0 elements)</li>
--   <li><tt>Identity a</tt> (1 element)</li>
--   <li><tt>Maybe a</tt> (0..1 element)</li>
--   <li><tt>[a]</tt> (0..inf elements)</li>
--   <li><tt>NeverEmptyList a</tt> (1..inf elements)</li>
--   <li><tt>Map k e</tt> (0..inf elements)</li>
--   </ul>
--   
--   Typeclass <tt>HasCardUCT</tt> together with function
--   <tt>sContTrans</tt> (safe container transform) provides a facility to
--   safely change container from one to another keepeng the content. If
--   content doesn't fit to target container, <tt>Nothing</tt> is returned.
--   However, when transforming from list <tt>[a]</tt> to <tt>(Maybe
--   a)</tt> it won't check list length further first 2 elements. The
--   complexity and power of this package is that it provides a facility to
--   <i>lazily</i> evaluate amount of content in the container.
--   
--   To interface package functions
--   
--   <pre>
--   import Data.Cardinality
--   </pre>
@package Cardinality
@version 0.2

module Data.Intersectable
data SetsFit set
NoIntersection :: SetsFit set
Intersection :: set -> SetsFit set
FirstInSecond :: SetsFit set
SecondInFirst :: SetsFit set
EqualSets :: SetsFit set
class Intersectable set
setFits :: Intersectable set => set -> set -> SetsFit set
instance Typeable1 SetsFit
instance Show set => Show (SetsFit set)

module Data.NeverEmptyList
data NeverEmptyList a
NEL :: a -> [a] -> NeverEmptyList a

-- | <pre>
--   neverEmptyList2List (NEL h t) = h:t
--   </pre>
nel2List :: NeverEmptyList a -> [a]

-- | <pre>
--   list2NeverEmptyList [] = Nothing
--   </pre>
--   
--   <pre>
--   list2NeverEmptyList (h:t) = Just (NEL h t)
--   </pre>
list2nel :: [a] -> Maybe (NeverEmptyList a)
nelSingleton :: a -> NeverEmptyList a

module Data.EmptySet
data EmptySet a
EmptySet :: EmptySet a
instance Typeable1 EmptySet
instance Eq (EmptySet a)
instance Show (EmptySet a)


-- | Two main assumptions (and constraints) of this module:
--   
--   <ol>
--   <li>Cardinality can't be negative.</li>
--   <li>For <tt><a>refinableC</a></tt> construction it is always refined
--   by growing. F.e., if <tt><a>refinableC</a> (7, ref_f_1)</tt> refines
--   to <tt><a>refinableC</a> (x, ref_f_2)</tt>, then <tt>x</tt> SHOULD
--   NEVER be less then <tt>7</tt>. On this assumption relies heavily
--   functions <tt><a>lazyIsZeroLC</a></tt>,
--   <tt><a>lazyCompare2LCs</a></tt>, <tt><a>addLCToLC</a></tt> and also
--   almost every refinement routine.</li>
--   </ol>
module Data.Cardinality.Cardinality

-- | Count of elements in container. It's always positive or zero.
--   
--   It would be best here to use <tt><a>Word32</a></tt> instead, however,
--   with <tt>Integer</tt> it's easier to catch the error of going down
--   below zero (in case of <tt><a>Word32</a> 0-1==4294967295</tt> ).
--   
--   However it is decided not to allow the direct use of
--   <tt><a>PreciseC</a></tt> data constructor, but to wrap it into
--   function <tt><a>preciseC</a></tt>, which guards from the attemts to
--   conctruct negative cardinality (by throwing an error).
type PreciseCardinality = Integer
type CurrentNotFinalPreciseCardinality = PreciseCardinality
type BoundaryPreciseCardinality = CurrentNotFinalPreciseCardinality
type ContinueCounting_DoWe = Bool

-- | An example of this is <tt><a>length2</a></tt> function.
type ContinueRefiningCardinalityUntil = CurrentNotFinalPreciseCardinality -> (CurrentNotFinalPreciseCardinality -> ContinueCounting_DoWe) -> LazyCardinality
type CardinalityRefinementState = (CurrentNotFinalPreciseCardinality, ContinueRefiningCardinalityUntil)

-- | In other words: count of elements in a container, with an opportunity
--   not to refine the whole content of the container (and the container's
--   structure).
--   
--   Constructors:
--   
--   <ul>
--   <li><pre><a>infiniteC</a></pre></li>
--   <li><pre><a>preciseC</a> <a>PreciseCardinality</a></pre></li>
--   <li><pre><a>refinableC</a>
--   <a>CardinalityRefinementState</a></pre></li>
--   </ul>
data LazyCardinality

-- | <tt><a>LazyCardinality</a></tt> constructor.
--   
--   F.e., <tt>[1..]</tt> list has such cardinality.
infiniteC :: LazyCardinality

-- | <tt><a>LazyCardinality</a></tt> constructor. If given negative value,
--   raises error.
--   
--   F.e., the tuple <tt>(5,6)</tt> has a precise cardinality 2.
preciseC :: PreciseCardinality -> LazyCardinality

-- | <tt><a>LazyCardinality</a></tt> constructor.
--   
--   For lists it happens, that we do not want to count all the elements of
--   a container, but want to count them until some lower boundary. For
--   example, I do not want to know the length of the list (which involves
--   taking each element of it, and counting it in) to reason about whether
--   it's content fit into the <tt>(,,)</tt> data constructor. For this
--   case I only need to count till 3rd element and check, if list is
--   continued. It's actual especially, when dealing with infinite lists or
--   with lists, whose reading may block.
--   
--   For <tt>(refinableC (x0, refine_f))</tt> important rules:
--   
--   <ol>
--   <li>If <tt>(refine_f x0 (&lt;= 5))</tt> evaluates to another
--   <tt>refinableC</tt>, then it is not fully refined, but (at least)
--   <tt>5</tt> is achieved (the precise cardinality is <tt>&gt;=
--   5</tt>).</li>
--   <li>If <tt>x0</tt> is <tt>10</tt> and <tt>(refine_f 10 (&lt;=
--   15))</tt> returned <tt>(refinableC (17, refine_f_2))</tt>, then it is
--   known, that precise cardinality is already &gt;= <tt>10 + 7</tt>. In
--   sight of <tt>refine_f</tt> there SHOULD be everything except for
--   what's already counted in <tt>x0</tt> (which is <tt>10</tt>), and in
--   sight of <tt>refine_f_2</tt> there should be even less by <tt>7</tt>
--   elements comparing to <tt>refine_f</tt>. So if total cardinality was
--   <tt>25</tt>, then <tt>(refine_f_2 17 (&lt;= 30))</tt> MUST return
--   <tt>preciseC 25</tt>, to make <tt>10 + 7 + 8 = 25</tt>.</li>
--   <li>The theatment of the first argument of refinement function
--   <tt>refine_f</tt> must be relative. For example, given total count of
--   elements <tt>= 25</tt> , and <tt>x0 = 20</tt> - these 20 elements are
--   already counted, and in sight of <tt>refine_f</tt> there are only 5
--   last elements. Then <tt>refine_f 20 (&lt;= 26)</tt> will result in
--   <tt>preciseC 25</tt>, but(!) <tt>refine_f 10 (&lt;= 16)</tt> MUST
--   result in <tt>preciseC 15</tt>.</li>
--   </ol>
--   
--   Recomendations:
--   
--   <ol>
--   <li>If subject has infinite cardinality, it's best to determine it's
--   cardinality as <tt><a>infiniteC</a></tt> at early stages and avoid
--   using <tt>refinableC</tt> for it.</li>
--   </ol>
refinableC :: CardinalityRefinementState -> LazyCardinality

-- | Returns <tt>Nothing</tt>, ONLY if LC is <tt><a>refinableC</a> (0,
--   _)</tt> (according to 2nd assumption of the module). Returns <tt>Just
--   True</tt> only for <tt><a>preciseC</a> 0</tt>.
lazyIsZeroLC :: LazyCardinality -> Maybe Bool
refinementState :: LazyCardinality -> Maybe CardinalityRefinementState
addPCToLC :: PreciseCardinality -> LazyCardinality -> LazyCardinality

-- | For case when adding up 2 refinables, if both of them sooner or later
--   refines to <tt><a>infiniteC</a></tt>, then one that returns infinity
--   earlier is recommended to put as a first term. Infinity + any
--   LazyCardinality = infinity. Another recommendation would be to put
--   refinable that's easier to compute as a first term.
addLCToLC :: LazyCardinality -> LazyCardinality -> LazyCardinality

-- | <pre>
--   foldl <a>addLCToLC</a>
--   </pre>
--   
--   See recommendations by <tt><a>addLCToLC</a></tt>.
sumLCs :: [LazyCardinality] -> LazyCardinality
refineCRS_Till :: CardinalityRefinementState -> BoundaryPreciseCardinality -> LazyCardinality
refineCRS_TillOneAbove :: CardinalityRefinementState -> BoundaryPreciseCardinality -> LazyCardinality
refineCRS_TillOneBelow :: CardinalityRefinementState -> BoundaryPreciseCardinality -> LazyCardinality
crsRefinementStep :: CardinalityRefinementState -> LazyCardinality

-- | Don't use it on infinite refinables not measured with
--   <a>infiniteC</a>.
refineCRS_TillEnd :: CardinalityRefinementState -> LazyCardinality

-- | Wrapper around <tt><a>refineCRS_Till</a></tt>.
refineTill :: LazyCardinality -> BoundaryPreciseCardinality -> LazyCardinality

-- | Wrapper around <tt><a>refineTillOneAbove</a></tt>.
refineTillOneAbove :: LazyCardinality -> BoundaryPreciseCardinality -> LazyCardinality

-- | Wrapper around <tt><a>refineTillOneBelow</a></tt>.
refineTillOneBelow :: LazyCardinality -> BoundaryPreciseCardinality -> LazyCardinality

-- | Wrapper around <tt><a>crsRefinementStep</a></tt>.
refinementStep :: LazyCardinality -> LazyCardinality

-- | Wrapper around <tt><a>refineCRS_TillEnd</a></tt>.
refineTillEnd :: LazyCardinality -> LazyCardinality

-- | For <tt>equalize2Refinements (m, ref_f_1) (n, ref_f_2)</tt> finishes
--   when m == n. Else refines them. Another termination condition is when
--   in result of refinement one of cardinalities becomes final (not
--   <tt><a>refinableC</a></tt>).
equalize2Refinements :: CardinalityRefinementState -> CardinalityRefinementState -> (LazyCardinality, LazyCardinality)
compare2Refinements :: CardinalityRefinementState -> CardinalityRefinementState -> (Ordering, LazyCardinality, LazyCardinality)

-- | Used for instance of Ord typeclass.
--   
--   Together with <tt><a>Ordering</a></tt> returns also probably refined
--   cardinalities for reuse.
--   
--   WARNING!!! When comparing <tt><a>refinableC</a></tt> with
--   <tt><a>infiniteC</a></tt> , it results in <tt><a>LT</a></tt> (less
--   than)! While comparing <tt><a>infiniteC</a> `almostStrictCompare2LCs`
--   <a>infiniteC</a> == <a>EQ</a></tt>. That's the reason for an
--   <i>almost-</i> prefix in function name. If there is a probability that
--   refinement of <tt><a>refinableC</a></tt> may evaluate to
--   <tt><a>infiniteC</a></tt>, and it's important to you, that infinities
--   are equal, then before comparing this refinable, use
--   <a>refineCRS_TillEnd</a> on it. That's laziness.
--   
--   Trying to compare 2 <tt><a>refinableC</a></tt>s that are actually
--   infinite, but don't use <tt><a>infiniteC</a></tt> will hang the system
--   (the same as if you try to determine length of an infinite list).
almostStrictCompare2LCs :: LazyCardinality -> LazyCardinality -> (Ordering, LazyCardinality, LazyCardinality)

-- | Won't refine refinables. According to 2nd assumption of the module:
--   
--   <pre>
--   <a>refinableC</a> (m, _) `lazyCompare2LCs` <a>preciseC</a> n
--   </pre>
--   
--   equals to <tt>Just GT</tt> if <tt>m &gt; n</tt> , and <tt>Nothing</tt>
--   otherwise.
lazyCompare2LCs :: LazyCardinality -> LazyCardinality -> Maybe Ordering

-- | Used for Show typeclass instaniation. Here <tt><a>refinableC</a></tt>
--   isn't refined.
showLazy :: LazyCardinality -> String

-- | Here <tt> <a>refineCRS_TillEnd</a></tt> is applied to
--   <tt><a>refinableC</a></tt> argument.
showStrict :: LazyCardinality -> String

-- | <tt>HasCard</tt> = "Has cardinality". In other words, "it's possible
--   to measure current count of elements for this container"
class HasCard a
cardOf :: HasCard a => a -> LazyCardinality

-- | <tt>HasCardT</tt> = "Has cardinality (for container types of kind
--   <tt>(* -&gt; *)</tt>)". In other words, "it's possible to measure
--   current count of elements for this container (for container types of
--   kind <tt>(* -&gt; *)</tt>)"
class HasCardT t
cardOfT :: HasCardT t => t elem -> LazyCardinality
cardOf_Unity :: () -> LazyCardinality
cardOf_EmptySet :: EmptySet a -> LazyCardinality
cardOf_Identity1 :: Identity a -> LazyCardinality
cardOf_Maybe :: Maybe a -> LazyCardinality

-- | Refinable starting from 0, uses <tt><a>length2</a></tt>
cardOf_List :: [a] -> LazyCardinality

-- | Not refinable, since <tt><a>Map</a></tt> is a strict structure.
cardOf_Map :: Map k e -> LazyCardinality

-- | Refinable starting from 1.
cardOf_NeverEmptyList :: NeverEmptyList k -> LazyCardinality

-- | List length of controlable greediness.
length2 :: [a] -> ContinueRefiningCardinalityUntil
instance Typeable LazyCardinality
instance HasCard (a, a, a, a, a, a, a, a, a, a, a, a)
instance HasCard (a, a, a, a, a, a, a, a, a, a, a)
instance HasCard (a, a, a, a, a, a, a, a, a, a)
instance HasCard (a, a, a, a, a, a, a, a, a)
instance HasCard (a, a, a, a, a, a, a, a)
instance HasCard (a, a, a, a, a, a, a)
instance HasCard (a, a, a, a, a, a)
instance HasCard (a, a, a, a, a)
instance HasCard (a, a, a, a)
instance HasCard (a, a, a)
instance HasCard (a, a)
instance HasCardT ((,) key)
instance HasCardT NeverEmptyList
instance HasCard (NeverEmptyList a)
instance HasCardT (Map k)
instance HasCard (Map k e)
instance HasCardT []
instance HasCard [a]
instance HasCardT Maybe
instance HasCard (Maybe a)
instance HasCardT Identity
instance HasCard (Identity a)
instance HasCardT EmptySet
instance HasCard (EmptySet a)
instance HasCard ()
instance Show LazyCardinality
instance Ord LazyCardinality
instance Eq LazyCardinality

module Data.Cardinality.CardinalityRange
type CardinalityRange_From = LazyCardinality
type CardinalityRange_To = LazyCardinality

-- | Constructor: <tt><a>cardinalityRange</a> <a>CardinalityRange_From</a>
--   <a>CardinalityRange_To</a></tt>
data CardinalityRange

-- | <tt>CardinalityRange</tt> data constructor. The range is always
--   including it's boundaries. F.e., range <tt><a>CardinalityRange</a>
--   (<a>preciseC</a> 1) (<a>preciseC</a> 4)</tt> contains cardinalities
--   [1,2,3,4]. First cardinality MUST always be less or equal to second
--   one. However, we do not fully guard from such type of error - we do
--   not refine <tt><a>refinableC</a></tt>, if it participates in the
--   constriction.
cardinalityRange :: CardinalityRange_From -> CardinalityRange_To -> CardinalityRange
cr2Tuple :: CardinalityRange -> (CardinalityRange_From, CardinalityRange_From)
lazyVerfyCR :: CardinalityRange_From -> CardinalityRange_To -> Maybe Bool

-- | Root prototype for all subsequent "FitsIn" functions. Returns probably
--   refined cardinality and range, which is useful for reuse. If returns
--   <tt>EQ</tt> then subject cardinality is between boundaries (including)
--   of cardinality range.
--   
--   Uses <tt><a>almostStrictCompare2LCs</a></tt> function.
cFitsInCR_Proto :: LazyCardinality -> CardinalityRange -> (Ordering, LazyCardinality, CardinalityRange)

-- | <tt><a>LazyCardinality</a></tt> fits in
--   <tt><a>CardinalityRange</a></tt>?
cFitsInCR :: LazyCardinality -> CardinalityRange -> Bool

-- | Wrapper around <tt><a>cFitsInCR</a></tt>.
fitsInCR :: HasCard a => a -> CardinalityRange -> Bool

-- | Wrapper around <tt><a>cFitsInCR</a></tt>.
fitsInCR_T :: HasCardT c => c a -> CardinalityRange -> Bool

-- | Used in <tt><a>Compare2CRsError</a></tt>
data FirstOrSecond
First :: FirstOrSecond
Second :: FirstOrSecond

-- | Error, that may occur, when performing <tt><a>compare2CRs</a></tt>
data Compare2CRsError
LowerBoundaryAfterHigher :: FirstOrSecond -> CardinalityRange -> Compare2CRsError

-- | This function is made hard, but fast. It tends to make minimal amount
--   of comparisons, reusing refinements.
compare2CRs :: CardinalityRange -> CardinalityRange -> (Either Compare2CRsError (SetsFit CardinalityRange), CardinalityRange, CardinalityRange)

-- | Wrapper around <tt><a>setFits</a></tt> of typeclass
--   <tt><a>Intersectable</a></tt>
crFitsInCR :: CardinalityRange -> CardinalityRange -> SetsFit CardinalityRange

-- | Same as <tt><a>cr0_Inf</a></tt>.
crNoConstraint :: CardinalityRange

-- | Only zero elements.
cr0 :: CardinalityRange

-- | Only one element.
cr1 :: CardinalityRange

-- | Zero or one element.
cr0_1 :: CardinalityRange

-- | Any count of elements.
cr0_Inf :: CardinalityRange

-- | Any nonzero count of elements.
cr1_Inf :: CardinalityRange

-- | Concrete count of elements.
crX :: PreciseCardinality -> CardinalityRange

-- | A concrete range.
crXY :: PreciseCardinality -> PreciseCardinality -> CardinalityRange
instance Show FirstOrSecond
instance Show CardinalityRange
instance Intersectable CardinalityRange
instance Show Compare2CRsError

module Data.Cardinality.ContTrans
type CardinalityConstraint = CardinalityRange

-- | <pre>
--   cFitsInCC = <a>cFitsInCR</a>
--   </pre>
--   
--   Defined to satisfy abbreviation.
cFitsInCC :: LazyCardinality -> CardinalityConstraint -> Bool

-- | <pre>
--   fitsInCC = <a>fitsInCR</a>
--   </pre>
--   
--   Defined to satisfy abbreviation.
fitsInCC :: HasCard a => a -> CardinalityConstraint -> Bool

-- | <pre>
--   fitsInCC = <a>fitsInCR_T</a>
--   </pre>
--   
--   Defined to satisfy abbreviation.
fitsInCC_T :: HasCardT c => c a -> CardinalityConstraint -> Bool

-- | <tt>HasCardConstr</tt> = "Has cardinality constraint". In other words,
--   "there is a capacity constraint for this container".
class HasCardConstr a
cardinalityConstraintOf :: HasCardConstr a => a -> CardinalityConstraint

-- | <tt>HasCardConstrT</tt> = "Has cardinality constraint (for container
--   types of kind <tt>(* -&gt; *)</tt>)". In other words, "there is a
--   capacity constraint for this container type of kind <tt>(* -&gt;
--   *)</tt>".
class HasCardConstrT c
cardinalityConstraintOfT :: HasCardConstrT c => c a -> CardinalityConstraint

-- | Wrapper around <tt><a>cFitsInCC</a></tt>.
cFitsIn :: HasCardConstr b => LazyCardinality -> b -> Bool

-- | Wrapper around <tt><a>cFitsInCC</a></tt>.
cFitsInT :: HasCardConstrT c => LazyCardinality -> c b -> Bool

-- | Wrapper around <tt><a>cFitsInCC</a></tt>.
fitsIn :: (HasCard a, HasCardConstr b) => a -> b -> Bool

-- | Wrapper around <tt><a>cFitsInCC</a></tt>.
fitsInT :: (HasCardT c, HasCardConstrT d) => c a -> d b -> Bool

-- | <tt>HasCardUCT</tt> = "Has cardinality-unsafe container transform".
--   Define transform that may thow an error, if contents of <tt>from</tt>
--   don't fit in <tt>to</tt> .
class HasCardUCT from to
uContTrans :: HasCardUCT from to => from -> to

-- | <tt>HasCardUCT_T</tt> = "Has cardinality-unsafe container transform
--   (for container types of kind <tt>(* -&gt; *)</tt>)". Same thing as
--   <tt><a>HasCardUCT</a></tt>, but for containers of kind <tt>(* -&gt;
--   *)</tt>.
class HasCardUCT_T from to
uContTransT :: HasCardUCT_T from to => from a -> to a
type TransformError_FromTypeName = String
type TransformError_ToTypeName = String
type TransformError_Details = String

-- | This error is used by <tt><a>HasCardUCT</a></tt> typeclass instances
--   in cases when <tt>from</tt> container's contents don't fit in
--   <tt>to</tt> container.
uContError :: TransformError_FromTypeName -> TransformError_ToTypeName -> TransformError_Details -> a

-- | Same as <tt><a>uContError</a></tt>, but for use in
--   <tt><a>HasCardUCT_T</a></tt> typeclass instances
uContErrorT :: TransformError_FromTypeName -> TransformError_ToTypeName -> TransformError_Details -> a

-- | A wrapper around <tt><a>uContTrans</a></tt>. Contrary to it, where
--   "u-" prefix stands for "unsafe-", here "s-" prefix stands for "safe-".
--   This is aimed to localize and exclude case, when contents of
--   <tt>from</tt> don't fit in <tt>to</tt> If <tt><a>HasCardUCT</a></tt>
--   instaniated correctly, then <tt><a>sContTrans</a></tt> should never
--   allow <tt><a>uContError</a></tt> to be called by subject instance. It
--   should return <tt>Nothing</tt> instead.
sContTrans :: (HasCard from, HasCardConstr to, HasCardUCT from to) => from -> Maybe to

-- | A wrapper around <tt><a>uContTransT</a></tt>. Contrary to it, where
--   "u-" prefix stands for "unsafe-", here "s-" prefix stands for "safe-".
--   This is aimed to localize and exclude case, when contents of <tt>(from
--   a)</tt> don't fit in <tt>(to a)</tt> . If <tt><a>HasCardUCT_T</a></tt>
--   instaniated correctly, then <tt><a>sContTransT</a></tt> should never
--   allow <tt><a>uContErrorT</a></tt> to be called by subject instance. It
--   should return <tt>Nothing</tt> instead.
sContTransT :: (HasCardT from, HasCardConstrT to, HasCardUCT_T from to) => from a -> Maybe (to a)

-- | Used in <tt><a>ContTransError</a></tt>.
type From_LazyCardinality = LazyCardinality

-- | Used in <tt><a>ContTransError</a></tt>.
type To_CardinalityConstraint = CardinalityConstraint

-- | Used in <tt><a>ContTransError</a></tt>. The kind of container.
data ContainerOrder

-- | For container transformation we might use more informative error
--   feedback. The <tt><a>Ordering</a></tt> in the middle is a relation
--   between subject <tt>From_LazyCardinality</tt> and
--   <tt>To_CardinalityConstraint</tt>. It's never EQ (and that's the
--   reason for the error).
data ContTransError
ContTransError :: From_LazyCardinality -> Ordering -> To_CardinalityConstraint -> ContainerOrder -> ContTransError

-- | Analogue to <tt><a>sContTrans</a></tt>. Herre, in case of cardinality
--   error, a more informative data structure is returned instead of
--   <tt>Nothing</tt> (as was in <tt><a>sContTrans</a></tt>).
sContTrans_E :: (HasCard from, HasCardConstr to, HasCardUCT from to) => from -> Either ContTransError to

-- | Analogue to <tt><a>sContTransT</a></tt>. Herre, in case of cardinality
--   error, a more informative data structure is returned instead of
--   <tt>Nothing</tt> (as was in <tt><a>sContTransT</a></tt>).
sContTransT_E :: (HasCardT from, HasCardConstrT to, HasCardUCT_T from to) => from a -> Either ContTransError (to a)
instance Show ContTransError
instance Eq ContainerOrder
instance Ord ContainerOrder
instance Show ContainerOrder
instance HasCardUCT (a, a, a, a, a, a, a, a, a, a, a) [a]
instance HasCardUCT (a, a, a, a, a, a, a, a, a, a) [a]
instance HasCardUCT (a, a, a, a, a, a, a, a, a) [a]
instance HasCardUCT (a, a, a, a, a, a, a, a) [a]
instance HasCardUCT (a, a, a, a, a, a, a) [a]
instance HasCardUCT (a, a, a, a, a, a) [a]
instance HasCardUCT (a, a, a, a, a) [a]
instance HasCardUCT (a, a, a, a) [a]
instance HasCardUCT (a, a, a) [a]
instance HasCardUCT (a, a) [a]
instance HasCardUCT [a] (a, a, a, a, a, a, a, a, a, a, a)
instance HasCardUCT [a] (a, a, a, a, a, a, a, a, a, a)
instance HasCardUCT [a] (a, a, a, a, a, a, a, a, a)
instance HasCardUCT [a] (a, a, a, a, a, a, a, a)
instance HasCardUCT [a] (a, a, a, a, a, a, a)
instance HasCardUCT [a] (a, a, a, a, a, a)
instance HasCardUCT [a] (a, a, a, a, a)
instance HasCardUCT [a] (a, a, a, a)
instance HasCardUCT [a] (a, a, a)
instance HasCardUCT [a] (a, a)
instance HasCardUCT (Map k e) (NeverEmptyList (k, e))
instance Ord k => HasCardUCT (NeverEmptyList (k, e)) (Map k e)
instance HasCardUCT (Map k e) [(k, e)]
instance HasCardUCT_T NeverEmptyList []
instance HasCardUCT (NeverEmptyList a) [a]
instance Ord k => HasCardUCT [(k, e)] (Map k e)
instance HasCardUCT_T [] NeverEmptyList
instance HasCardUCT [a] (NeverEmptyList a)
instance HasCardUCT (Map k e) (Maybe (k, e))
instance HasCardUCT_T NeverEmptyList Maybe
instance HasCardUCT (NeverEmptyList a) (Maybe a)
instance HasCardUCT_T [] Maybe
instance HasCardUCT [a] (Maybe a)
instance HasCardUCT (Maybe (k, e)) (Map k e)
instance HasCardUCT_T Maybe NeverEmptyList
instance HasCardUCT (Maybe a) (NeverEmptyList a)
instance HasCardUCT_T Maybe []
instance HasCardUCT (Maybe a) [a]
instance HasCardUCT (Map k e) ()
instance HasCardUCT [a] ()
instance HasCardUCT (Maybe a) ()
instance HasCardUCT () (Map k e)
instance HasCardUCT () [a]
instance HasCardUCT () (Maybe a)
instance HasCardUCT (Map k e) (Identity (k, e))
instance HasCardUCT_T NeverEmptyList Identity
instance HasCardUCT (NeverEmptyList a) (Identity a)
instance HasCardUCT_T [] Identity
instance HasCardUCT [a] (Identity a)
instance HasCardUCT_T Maybe Identity
instance HasCardUCT (Maybe a) (Identity a)
instance HasCardUCT (Identity (k, e)) (Map k e)
instance HasCardUCT_T Identity NeverEmptyList
instance HasCardUCT (Identity a) (NeverEmptyList a)
instance HasCardUCT_T Identity []
instance HasCardUCT (Identity a) [a]
instance HasCardUCT_T Identity Maybe
instance HasCardUCT (Identity a) (Maybe a)
instance HasCardUCT_T (Map k) ((,) k)
instance HasCardUCT (Map k e) (k, e)
instance HasCardUCT_T ((,) k) (Map k)
instance HasCardUCT (k, e) (Map k e)
instance HasCardUCT (Map k e) (EmptySet (k, e))
instance HasCardUCT (EmptySet (k, e)) (Map k e)
instance HasCardUCT_T [] EmptySet
instance HasCardUCT [a] (EmptySet a)
instance HasCardUCT_T EmptySet []
instance HasCardUCT (EmptySet a) [a]
instance HasCardUCT_T Maybe EmptySet
instance HasCardUCT (Maybe a) (EmptySet a)
instance HasCardUCT_T EmptySet Maybe
instance HasCardUCT (EmptySet a) (Maybe a)
instance HasCardUCT () (EmptySet a)
instance HasCardUCT (EmptySet a) ()
instance HasCardConstr (a, a, a, a, a, a, a, a, a, a, a)
instance HasCardConstr (a, a, a, a, a, a, a, a, a, a)
instance HasCardConstr (a, a, a, a, a, a, a, a, a)
instance HasCardConstr (a, a, a, a, a, a, a, a)
instance HasCardConstr (a, a, a, a, a, a, a)
instance HasCardConstr (a, a, a, a, a, a)
instance HasCardConstr (a, a, a, a, a)
instance HasCardConstr (a, a, a, a)
instance HasCardConstr (a, a, a)
instance HasCardConstr (a, a)
instance HasCardConstrT (Map k)
instance HasCardConstr (Map k e)
instance HasCardConstrT NeverEmptyList
instance HasCardConstr (NeverEmptyList a)
instance HasCardConstrT []
instance HasCardConstr [a]
instance HasCardConstrT Maybe
instance HasCardConstr (Maybe a)
instance HasCardConstrT Identity
instance HasCardConstr (Identity a)
instance HasCardConstrT EmptySet
instance HasCardConstr (EmptySet a)
instance HasCardConstr ()

module Data.Cardinality
