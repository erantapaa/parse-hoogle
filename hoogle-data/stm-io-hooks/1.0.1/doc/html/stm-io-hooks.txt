-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | STM with IO hooks
--   
@package stm-io-hooks
@version 1.0.1


module Control.Concurrent.AdvSTM.TVar
data TVar a

-- | See <a>newTVar</a>
newTVar :: MonadAdvSTM m => a -> m (TVar a)

-- | See <a>newTVarIO</a>
newTVarIO :: a -> IO (TVar a)

-- | Reads a value from a TVar. Blocks until the IO onCommit aidction(s) of
--   the corresponding transaction are complete.is not the last function
--   See <a>onCommit</a> for a more detailed description of this behaviour.
readTVar :: MonadAdvSTM m => TVar a -> m a

-- | Writes a value to a TVar. Blocks until the onCommit IO-action(s) are
--   complete. See <a>onCommit</a> for details.
writeTVar :: MonadAdvSTM m => TVar a -> a -> m ()

-- | Reads a value directly from the TVar. Does not block when the onCommit
--   actions aren't done yet. NOTE: Only use this function when you know
--   what you're doing.
readTVarAsync :: MonadAdvSTM m => TVar a -> m a

-- | Writes a value directly to the TVar. Does not block when onCommit
--   actions aren't done yet. This function comes in handy for error
--   recovery of exceptions that occur in onCommit.
writeTVarAsync :: MonadAdvSTM m => TVar a -> a -> m ()


-- | Extends Control.Concurrent.STM with IO hooks
module Control.Concurrent.AdvSTM

-- | A type class for extended-STM monads. For a concrete instantiation see
--   <tt>AdvSTM</tt>
class Monad m => MonadAdvSTM m
onCommitWith :: MonadAdvSTM m => ([IO ()] -> IO ()) -> m ()
onCommit :: MonadAdvSTM m => IO () -> m ()
unsafeRetryWith :: MonadAdvSTM m => IO () -> m b
orElse :: MonadAdvSTM m => m a -> m a -> m a
retry :: MonadAdvSTM m => m a
check :: MonadAdvSTM m => Bool -> m ()
alwaysSucceeds :: MonadAdvSTM m => m a -> m ()
always :: MonadAdvSTM m => m Bool -> m ()
catchSTM :: (MonadAdvSTM m, Exception e) => m a -> (e -> m a) -> m a
liftAdv :: MonadAdvSTM m => STM a -> m a
readTVar :: MonadAdvSTM m => TVar a -> m a
writeTVar :: MonadAdvSTM m => TVar a -> a -> m ()
readTVarAsync :: MonadAdvSTM m => TVar a -> m a
writeTVarAsync :: MonadAdvSTM m => TVar a -> a -> m ()
newTVar :: MonadAdvSTM m => a -> m (TVar a)
unsafeIOToSTM :: MonadAdvSTM m => IO a -> m a

-- | Drop-in replacement for the STM monad
data AdvSTM a

-- | See <a>atomically</a>
atomically :: AdvSTM a -> IO a

-- | A version of <a>catchSTM</a> with the arguments swapped around.
handleSTM :: (MonadAdvSTM m, Exception e) => (e -> m a) -> m a -> m a

-- | Uses unsafeIOToSTM to output the Thread Id and a message and delays
--   for a given number of time. <i>WARNING:</i> Can lead to deadlocks!
debugAdvSTM :: String -> Int -> AdvSTM ()

-- | Switches the debug mode on or off. <i>WARNING:</i> Can lead to
--   deadlocks!
debugMode :: Bool -> AdvSTM ()
instance MonadAdvSTM AdvSTM


-- | Provides the type class MonadAdvSTM and the AdvSTM monad. Parts of
--   this implementation were taken from the HaskellWiki Page of
--   MonadAdvSTM (see package description).
module Control.Monad.AdvSTM

-- | A type class for extended-STM monads. For a concrete instantiation see
--   <tt>AdvSTM</tt>
class Monad m => MonadAdvSTM m
onCommitWith :: MonadAdvSTM m => ([IO ()] -> IO ()) -> m ()
onCommit :: MonadAdvSTM m => IO () -> m ()
unsafeRetryWith :: MonadAdvSTM m => IO () -> m b
orElse :: MonadAdvSTM m => m a -> m a -> m a
retry :: MonadAdvSTM m => m a
check :: MonadAdvSTM m => Bool -> m ()
alwaysSucceeds :: MonadAdvSTM m => m a -> m ()
always :: MonadAdvSTM m => m Bool -> m ()
catchSTM :: (MonadAdvSTM m, Exception e) => m a -> (e -> m a) -> m a
liftAdv :: MonadAdvSTM m => STM a -> m a
readTVar :: MonadAdvSTM m => TVar a -> m a
writeTVar :: MonadAdvSTM m => TVar a -> a -> m ()
readTVarAsync :: MonadAdvSTM m => TVar a -> m a
writeTVarAsync :: MonadAdvSTM m => TVar a -> a -> m ()
newTVar :: MonadAdvSTM m => a -> m (TVar a)
unsafeIOToSTM :: MonadAdvSTM m => IO a -> m a

-- | Drop-in replacement for the STM monad
data AdvSTM a


-- | TMVar: Transactional MVars, for use in the AdvAdvSTM monad
--   
--   Corresponds to <a>Control.Concurrent.STM.TMVar</a>
module Control.Concurrent.AdvSTM.TMVar

-- | A <a>TMVar</a> is a synchronising variable, used for communication
--   between concurrent threads. It can be thought of as a box, which may
--   be empty or full.
data TMVar a

-- | Create a <a>TMVar</a> which contains the supplied value.
newTMVar :: MonadAdvSTM m => a -> m (TMVar a)

-- | Create a <a>TMVar</a> which is initially empty.
newEmptyTMVar :: MonadAdvSTM m => m (TMVar a)

-- | <tt>IO</tt> version of <a>newTMVar</a>. This is useful for creating
--   top-level <a>TMVar</a>s using <a>unsafePerformIO</a>, because using
--   <tt>atomically</tt> inside <a>unsafePerformIO</a> isn't possible.
newTMVarIO :: a -> IO (TMVar a)

-- | <tt>IO</tt> version of <a>newEmptyTMVar</a>. This is useful for
--   creating top-level <a>TMVar</a>s using <a>unsafePerformIO</a>, because
--   using <tt>atomically</tt> inside <a>unsafePerformIO</a> isn't
--   possible.
newEmptyTMVarIO :: IO (TMVar a)

-- | Return the contents of the <a>TMVar</a>. If the <a>TMVar</a> is
--   currently empty, the transaction will <a>retry</a>. After a
--   <a>takeTMVar</a>, the <a>TMVar</a> is left empty.
takeTMVar :: MonadAdvSTM m => TMVar a -> m a

-- | Put a value into a <a>TMVar</a>. If the <a>TMVar</a> is currently
--   full, <a>putTMVar</a> will <a>retry</a>.
putTMVar :: MonadAdvSTM m => TMVar a -> a -> m ()

-- | This is a combination of <a>takeTMVar</a> and <a>putTMVar</a>; ie. it
--   takes the value from the <a>TMVar</a>, puts it back, and also returns
--   it.
readTMVar :: MonadAdvSTM m => TMVar a -> m a

-- | Swap the contents of a <a>TMVar</a> for a new value.
swapTMVar :: MonadAdvSTM m => TMVar a -> a -> m a

-- | A version of <a>takeTMVar</a> that does not <a>retry</a>. The
--   <a>tryTakeTMVar</a> function returns <a>Nothing</a> if the
--   <a>TMVar</a> was empty, or <tt><a>Just</a> a</tt> if the <a>TMVar</a>
--   was full with contents <tt>a</tt>. After <a>tryTakeTMVar</a>, the
--   <a>TMVar</a> is left empty.
tryTakeTMVar :: MonadAdvSTM m => TMVar a -> m (Maybe a)

-- | A version of <a>putTMVar</a> that does not <a>retry</a>. The
--   <a>tryPutTMVar</a> function attempts to put the value <tt>a</tt> into
--   the <a>TMVar</a>, returning <a>True</a> if it was successful, or
--   <a>False</a> otherwise.
tryPutTMVar :: MonadAdvSTM m => TMVar a -> a -> m Bool

-- | Check whether a given <a>TMVar</a> is empty.
--   
--   Notice that the boolean value returned is just a snapshot of the state
--   of the <a>TMVar</a>. By the time you get to react on its result, the
--   <a>TMVar</a> may have been filled (or emptied) - so be extremely
--   careful when using this operation. Use <a>tryTakeTMVar</a> instead if
--   possible.
isEmptyTMVar :: MonadAdvSTM m => TMVar a -> m Bool


-- | Corresponds to <a>Control.Concurrent.STM.TArray</a>
module Control.Concurrent.AdvSTM.TArray

-- | TArray is a transactional array, supporting the usual <a>MArray</a>
--   interface for mutable arrays.
data TArray i e
instance MonadAdvSTM m => MArray TArray e m


-- | Corresponds to <a>Control.Concurrent.STM.TChan</a>
module Control.Concurrent.AdvSTM.TChan

-- | <a>TChan</a> is an abstract type representing an unbounded FIFO
--   channel.
data TChan a

-- | Build and returns a new instance of <a>TChan</a>
newTChan :: MonadAdvSTM m => m (TChan a)

-- | <tt>IO</tt> version of <a>newTChan</a>. This is useful for creating
--   top-level <a>TChan</a>s using <a>unsafePerformIO</a>, because using
--   <tt>atomically</tt> inside <a>unsafePerformIO</a> isn't possible.
newTChanIO :: IO (TChan a)

-- | Read the next value from the <a>TChan</a>.
readTChan :: MonadAdvSTM m => TChan a -> m a

-- | Write a value to a <a>TChan</a>.
writeTChan :: MonadAdvSTM m => TChan a -> a -> m ()

-- | Duplicate a <a>TChan</a>: the duplicate channel begins empty, but data
--   written to either channel from then on will be available from both.
--   Hence this creates a kind of broadcast channel, where data written by
--   anyone is seen by everyone else.
dupTChan :: MonadAdvSTM m => TChan a -> m (TChan a)

-- | Put a data item back onto a channel, where it will be the next item
--   read.
unGetTChan :: MonadAdvSTM m => TChan a -> a -> m ()

-- | Returns <a>True</a> if the supplied <a>TChan</a> is empty.
isEmptyTChan :: MonadAdvSTM m => TChan a -> m Bool
