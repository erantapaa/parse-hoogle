-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Bindings to the LLVM compiler toolkit with some custom extensions.
--   
--   Bindings to the LLVM compiler toolkit. Custom extensions: *
--   vector-aware versions of fptosi and friends * Callback from LLVM code
--   into Haskell code including StablePtr support * tuple arguments to
--   LLVM functions * instance IsFirstClass Array * CodeGen.constStruct *
--   Instruction.extractvalue, insertvalue * Core.Instruction.bitcastUnify:
--   like bitcast but uses type unification for asserting equal size of
--   source and target News in the original llvm package: * New in 0.7.0.0:
--   Adapted to LLVM 2.6; * New in 0.6.8.0: Add functions to allow freeing
--   function resources; * New in 0.6.7.0: Struct types; * New in 0.6.6.0:
--   Bug fixes; * New in 0.6.5.0: Adapted to LLVM 2.5;
@package llvm-ht
@version 0.7.0.0

module LLVM.Util.Foreign
with :: (Storable a) => a -> (Ptr a -> IO b) -> IO b
alloca :: (Storable a) => (Ptr a -> IO b) -> IO b
withArrayLen :: (Storable a) => [a] -> (Int -> Ptr a -> IO b) -> IO b


-- | This module provides direct access to the LLVM C bindings.
module LLVM.FFI.Core
data Module
type ModuleRef = Ptr Module
moduleCreateWithName :: CString -> IO ModuleRef
disposeModule :: ModuleRef -> IO ()
ptrDisposeModule :: FunPtr (ModuleRef -> IO ())
getDataLayout :: ModuleRef -> IO CString
setDataLayout :: ModuleRef -> CString -> IO ()
getTarget :: ModuleRef -> IO CString
setTarget :: ModuleRef -> CString -> IO ()
data ModuleProvider
type ModuleProviderRef = Ptr ModuleProvider
createModuleProviderForExistingModule :: ModuleRef -> IO ModuleProviderRef
ptrDisposeModuleProvider :: FunPtr (ModuleProviderRef -> IO ())
data Type
type TypeRef = Ptr Type
addTypeName :: ModuleRef -> CString -> TypeRef -> IO CInt
deleteTypeName :: ModuleRef -> CString -> IO ()
getTypeKind :: TypeRef -> IO TypeKind
data TypeKind
VoidTypeKind :: TypeKind
FloatTypeKind :: TypeKind
DoubleTypeKind :: TypeKind
X86_FP80TypeKind :: TypeKind
FP128TypeKind :: TypeKind
PPC_FP128TypeKind :: TypeKind
LabelTypeKind :: TypeKind
IntegerTypeKind :: TypeKind
FunctionTypeKind :: TypeKind
StructTypeKind :: TypeKind
ArrayTypeKind :: TypeKind
PointerTypeKind :: TypeKind
OpaqueTypeKind :: TypeKind
VectorTypeKind :: TypeKind
int1Type :: TypeRef
int8Type :: TypeRef
int16Type :: TypeRef
int32Type :: TypeRef
int64Type :: TypeRef

-- | An integer type of the given width.
integerType :: CUInt -> TypeRef
getIntTypeWidth :: TypeRef -> IO CUInt
floatType :: TypeRef
doubleType :: TypeRef
x86FP80Type :: TypeRef
fp128Type :: TypeRef
ppcFP128Type :: TypeRef

-- | Create a function type.
functionType :: TypeRef -> Ptr TypeRef -> CUInt -> CInt -> TypeRef

-- | Indicate whether a function takes varargs.
isFunctionVarArg :: TypeRef -> IO CInt

-- | Give a function's return type.
getReturnType :: TypeRef -> IO TypeRef

-- | Give the number of fixed parameters that a function takes.
countParamTypes :: TypeRef -> IO CUInt

-- | Fill out an array with the types of a function's fixed parameters.
getParamTypes :: TypeRef -> Ptr TypeRef -> IO ()
voidType :: TypeRef
labelType :: TypeRef
opaqueType :: TypeRef
arrayType :: TypeRef -> CUInt -> TypeRef
pointerType :: TypeRef -> CUInt -> TypeRef
vectorType :: TypeRef -> CUInt -> TypeRef

-- | Get the type of a sequential type's elements.
getElementType :: TypeRef -> IO TypeRef
getArrayLength :: TypeRef -> IO CUInt
getPointerAddressSpace :: TypeRef -> IO CUInt
getVectorSize :: TypeRef -> IO CUInt
structType :: Ptr TypeRef -> CUInt -> CInt -> TypeRef
countStructElementTypes :: TypeRef -> CUInt
getStructElementTypes :: TypeRef -> Ptr TypeRef -> IO ()
isPackedStruct :: TypeRef -> CInt
createTypeHandle :: TypeRef -> IO TypeHandleRef
refineType :: TypeRef -> TypeRef -> IO ()
resolveTypeHandle :: TypeHandleRef -> IO TypeRef
disposeTypeHandle :: TypeHandleRef -> IO ()
data Value
type ValueRef = Ptr Value
typeOf :: ValueRef -> IO TypeRef
getValueName :: ValueRef -> IO CString
setValueName :: ValueRef -> CString -> IO ()
dumpValue :: ValueRef -> IO ()
constNull :: TypeRef -> ValueRef
constAllOnes :: TypeRef -> ValueRef
getUndef :: TypeRef -> ValueRef
isConstant :: ValueRef -> IO CInt
isNull :: ValueRef -> IO CInt
isUndef :: ValueRef -> IO CInt

-- | An enumeration for the kinds of linkage for global values.
data Linkage

-- | Externally visible function
ExternalLinkage :: Linkage
AvailableExternallyLinkage :: Linkage

-- | Keep one copy of function when linking (inline)
LinkOnceAnyLinkage :: Linkage

-- | Same, but only replaced by something equivalent.
LinkOnceODRLinkage :: Linkage

-- | Keep one copy of named function when linking (weak)
WeakAnyLinkage :: Linkage

-- | Same, but only replaced by something equivalent.
WeakODRLinkage :: Linkage

-- | Special purpose, only applies to global arrays
AppendingLinkage :: Linkage

-- | Rename collisions when linking (static functions)
InternalLinkage :: Linkage

-- | Like Internal, but omit from symbol table
PrivateLinkage :: Linkage

-- | Function to be imported from DLL
DLLImportLinkage :: Linkage

-- | Function to be accessible from DLL
DLLExportLinkage :: Linkage

-- | ExternalWeak linkage description
ExternalWeakLinkage :: Linkage

-- | Stand-in functions for streaming fns from BC files
GhostLinkage :: Linkage

-- | Tentative definitions
CommonLinkage :: Linkage

-- | Like Private, but linker removes.
LinkerPrivateLinkage :: Linkage
fromLinkage :: Linkage -> CUInt
toLinkage :: CUInt -> Linkage
getLinkage :: ValueRef -> IO CUInt
setLinkage :: ValueRef -> CUInt -> IO ()

-- | An enumeration for the kinds of visibility of global values.
data Visibility

-- | The GV is visible
DefaultVisibility :: Visibility

-- | The GV is hidden
HiddenVisibility :: Visibility

-- | The GV is protected
ProtectedVisibility :: Visibility
fromVisibility :: Visibility -> CUInt
toVisibility :: CUInt -> Visibility
getVisibility :: ValueRef -> IO CUInt
setVisibility :: ValueRef -> CUInt -> IO ()
isDeclaration :: ValueRef -> IO CInt
getSection :: ValueRef -> IO CString
setSection :: ValueRef -> CString -> IO ()
getAlignment :: ValueRef -> IO CUInt
setAlignment :: ValueRef -> CUInt -> IO ()
addGlobal :: ModuleRef -> TypeRef -> CString -> IO ValueRef
getNamedGlobal :: ModuleRef -> CString -> IO ValueRef
deleteGlobal :: ValueRef -> IO ()
getInitializer :: ValueRef -> IO ValueRef
setInitializer :: ValueRef -> ValueRef -> IO ()
isThreadLocal :: ValueRef -> IO CInt
setThreadLocal :: ValueRef -> CInt -> IO ()
isGlobalConstant :: ValueRef -> IO CInt
setGlobalConstant :: ValueRef -> CInt -> IO ()
getFirstGlobal :: ModuleRef -> IO ValueRef
getNextGlobal :: ValueRef -> IO ValueRef
getPreviousGlobal :: ValueRef -> IO ValueRef
getLastGlobal :: ModuleRef -> IO ValueRef
getGlobalParent :: ValueRef -> IO ModuleRef
addFunction :: ModuleRef -> CString -> TypeRef -> IO ValueRef
getNamedFunction :: ModuleRef -> CString -> IO ValueRef
deleteFunction :: ValueRef -> IO ()
countParams :: ValueRef -> CUInt
getParams :: ValueRef -> Ptr ValueRef -> IO ()
getParam :: ValueRef -> CUInt -> ValueRef
getIntrinsicID :: ValueRef -> CUInt
getGC :: ValueRef -> IO CString
setGC :: ValueRef -> CString -> IO ()
getFirstFunction :: ModuleRef -> IO ValueRef
getNextFunction :: ValueRef -> IO ValueRef
getPreviousFunction :: ValueRef -> IO ValueRef
getLastFunction :: ModuleRef -> IO ValueRef
getFirstParam :: ValueRef -> IO ValueRef
getNextParam :: ValueRef -> IO ValueRef
getPreviousParam :: ValueRef -> IO ValueRef
getLastParam :: ValueRef -> IO ValueRef
getParamParent :: ValueRef -> IO ValueRef
isTailCall :: ValueRef -> IO CInt
setTailCall :: ValueRef -> CInt -> IO ()
addIncoming :: ValueRef -> Ptr ValueRef -> Ptr ValueRef -> CUInt -> IO ()
countIncoming :: ValueRef -> IO CUInt
getIncomingValue :: ValueRef -> CUInt -> IO ValueRef
getIncomingBlock :: ValueRef -> CUInt -> IO BasicBlockRef
data CallingConvention
C :: CallingConvention
Fast :: CallingConvention
Cold :: CallingConvention
X86StdCall :: CallingConvention
X86FastCall :: CallingConvention
fromCallingConvention :: CallingConvention -> CUInt
toCallingConvention :: CUInt -> CallingConvention
getFunctionCallConv :: ValueRef -> IO CUInt
setFunctionCallConv :: ValueRef -> CUInt -> IO ()
getInstructionCallConv :: ValueRef -> IO CUInt
setInstructionCallConv :: ValueRef -> CUInt -> IO ()
constInt :: TypeRef -> CULLong -> CInt -> ValueRef
constReal :: TypeRef -> CDouble -> ValueRef
constArray :: TypeRef -> Ptr ValueRef -> CUInt -> ValueRef
constString :: CString -> CUInt -> CInt -> ValueRef
constStruct :: Ptr ValueRef -> CUInt -> CInt -> ValueRef
constVector :: Ptr ValueRef -> CUInt -> ValueRef
sizeOf :: TypeRef -> IO ValueRef
constNeg :: ValueRef -> ValueRef
constNot :: ValueRef -> ValueRef
constAdd :: ValueRef -> ValueRef -> ValueRef
constSub :: ValueRef -> ValueRef -> ValueRef
constMul :: ValueRef -> ValueRef -> ValueRef
constExactSDiv :: ValueRef -> ValueRef -> IO ValueRef
constFAdd :: ValueRef -> ValueRef -> ValueRef
constFMul :: ValueRef -> ValueRef -> ValueRef
constFNeg :: ValueRef -> ValueRef
constFPCast :: ValueRef -> TypeRef -> ValueRef
constFSub :: ValueRef -> ValueRef -> ValueRef
constUDiv :: ValueRef -> ValueRef -> ValueRef
constSDiv :: ValueRef -> ValueRef -> ValueRef
constFDiv :: ValueRef -> ValueRef -> ValueRef
constURem :: ValueRef -> ValueRef -> ValueRef
constSRem :: ValueRef -> ValueRef -> ValueRef
constFRem :: ValueRef -> ValueRef -> ValueRef
constAnd :: ValueRef -> ValueRef -> ValueRef
constOr :: ValueRef -> ValueRef -> ValueRef
constXor :: ValueRef -> ValueRef -> ValueRef
constICmp :: CInt -> ValueRef -> ValueRef -> ValueRef
constFCmp :: CInt -> ValueRef -> ValueRef -> ValueRef
constShl :: ValueRef -> ValueRef -> ValueRef
constLShr :: ValueRef -> ValueRef -> ValueRef
constAShr :: ValueRef -> ValueRef -> ValueRef
constGEP :: ValueRef -> Ptr ValueRef -> CUInt -> ValueRef
constTrunc :: ValueRef -> TypeRef -> ValueRef
constSExt :: ValueRef -> TypeRef -> ValueRef
constZExt :: ValueRef -> TypeRef -> ValueRef
constFPTrunc :: ValueRef -> TypeRef -> ValueRef
constFPExt :: ValueRef -> TypeRef -> ValueRef
constUIToFP :: ValueRef -> TypeRef -> ValueRef
constSIToFP :: ValueRef -> TypeRef -> ValueRef
constFPToUI :: ValueRef -> TypeRef -> ValueRef
constFPToSI :: ValueRef -> TypeRef -> ValueRef
constPtrToInt :: ValueRef -> TypeRef -> ValueRef
constIntToPtr :: ValueRef -> TypeRef -> ValueRef
constBitCast :: ValueRef -> TypeRef -> ValueRef
constSelect :: ValueRef -> ValueRef -> ValueRef -> ValueRef
constExtractElement :: ValueRef -> ValueRef -> ValueRef
constInsertElement :: ValueRef -> ValueRef -> ValueRef -> ValueRef
constShuffleVector :: ValueRef -> ValueRef -> ValueRef -> ValueRef
constExtractValue :: ValueRef -> Ptr ValueRef -> CUInt -> ValueRef
constInsertValue :: ValueRef -> ValueRef -> Ptr ValueRef -> CUInt -> ValueRef
constRealOfString :: TypeRef -> CString -> IO ValueRef
type BasicBlock = Value
type BasicBlockRef = Ptr BasicBlock
basicBlockAsValue :: BasicBlockRef -> ValueRef
valueIsBasicBlock :: ValueRef -> Bool
valueAsBasicBlock :: ValueRef -> BasicBlockRef
countBasicBlocks :: ValueRef -> IO CUInt
getBasicBlocks :: ValueRef -> Ptr BasicBlockRef -> IO ()
getEntryBasicBlock :: ValueRef -> IO BasicBlockRef
appendBasicBlock :: ValueRef -> CString -> IO BasicBlockRef
insertBasicBlock :: BasicBlockRef -> CString -> IO BasicBlockRef
deleteBasicBlock :: BasicBlockRef -> IO ()
getFirstBasicBlock :: ValueRef -> IO BasicBlockRef
getNextBasicBlock :: BasicBlockRef -> IO BasicBlockRef
getPreviousBasicBlock :: BasicBlockRef -> IO BasicBlockRef
getLastBasicBlock :: ValueRef -> IO BasicBlockRef
getInsertBlock :: BuilderRef -> IO BasicBlockRef
getBasicBlockParent :: BasicBlockRef -> IO ValueRef
data Builder
type BuilderRef = Ptr Builder
createBuilder :: IO BuilderRef
ptrDisposeBuilder :: FunPtr (BuilderRef -> IO ())
positionBuilder :: BuilderRef -> BasicBlockRef -> ValueRef -> IO ()
positionBefore :: BuilderRef -> ValueRef -> IO ()
positionAtEnd :: BuilderRef -> BasicBlockRef -> IO ()
getFirstInstruction :: BasicBlockRef -> IO ValueRef
getNextInstruction :: ValueRef -> IO ValueRef
getPreviousInstruction :: ValueRef -> IO ValueRef
getLastInstruction :: BasicBlockRef -> IO ValueRef
getInstructionParent :: ValueRef -> IO BasicBlockRef
buildRetVoid :: BuilderRef -> IO ValueRef
buildRet :: BuilderRef -> ValueRef -> IO ValueRef
buildBr :: BuilderRef -> BasicBlockRef -> IO ValueRef
buildCondBr :: BuilderRef -> ValueRef -> BasicBlockRef -> BasicBlockRef -> IO ValueRef
buildSwitch :: BuilderRef -> ValueRef -> BasicBlockRef -> CUInt -> IO ValueRef
buildInvoke :: BuilderRef -> ValueRef -> Ptr ValueRef -> CUInt -> BasicBlockRef -> BasicBlockRef -> CString -> IO ValueRef
buildUnwind :: BuilderRef -> IO ValueRef
buildUnreachable :: BuilderRef -> IO ValueRef
buildAdd :: BuilderRef -> ValueRef -> ValueRef -> CString -> IO ValueRef
buildSub :: BuilderRef -> ValueRef -> ValueRef -> CString -> IO ValueRef
buildMul :: BuilderRef -> ValueRef -> ValueRef -> CString -> IO ValueRef
buildFAdd :: BuilderRef -> ValueRef -> ValueRef -> CString -> IO ValueRef
buildFMul :: BuilderRef -> ValueRef -> ValueRef -> CString -> IO ValueRef
buildFPCast :: BuilderRef -> ValueRef -> TypeRef -> CString -> IO ValueRef
buildFSub :: BuilderRef -> ValueRef -> ValueRef -> CString -> IO ValueRef
buildUDiv :: BuilderRef -> ValueRef -> ValueRef -> CString -> IO ValueRef
buildSDiv :: BuilderRef -> ValueRef -> ValueRef -> CString -> IO ValueRef
buildExactSDiv :: BuilderRef -> ValueRef -> ValueRef -> CString -> IO ValueRef
buildFDiv :: BuilderRef -> ValueRef -> ValueRef -> CString -> IO ValueRef
buildURem :: BuilderRef -> ValueRef -> ValueRef -> CString -> IO ValueRef
buildSRem :: BuilderRef -> ValueRef -> ValueRef -> CString -> IO ValueRef
buildFRem :: BuilderRef -> ValueRef -> ValueRef -> CString -> IO ValueRef
buildShl :: BuilderRef -> ValueRef -> ValueRef -> CString -> IO ValueRef
buildLShr :: BuilderRef -> ValueRef -> ValueRef -> CString -> IO ValueRef
buildAShr :: BuilderRef -> ValueRef -> ValueRef -> CString -> IO ValueRef
buildAnd :: BuilderRef -> ValueRef -> ValueRef -> CString -> IO ValueRef
buildOr :: BuilderRef -> ValueRef -> ValueRef -> CString -> IO ValueRef
buildXor :: BuilderRef -> ValueRef -> ValueRef -> CString -> IO ValueRef
buildNeg :: BuilderRef -> ValueRef -> CString -> IO ValueRef
buildNot :: BuilderRef -> ValueRef -> CString -> IO ValueRef
buildMalloc :: BuilderRef -> TypeRef -> CString -> IO ValueRef
buildArrayMalloc :: BuilderRef -> TypeRef -> ValueRef -> CString -> IO ValueRef
buildAlloca :: BuilderRef -> TypeRef -> CString -> IO ValueRef
buildArrayAlloca :: BuilderRef -> TypeRef -> ValueRef -> CString -> IO ValueRef
buildFree :: BuilderRef -> ValueRef -> IO ValueRef
buildLoad :: BuilderRef -> ValueRef -> CString -> IO ValueRef
buildStore :: BuilderRef -> ValueRef -> ValueRef -> IO ValueRef
buildGEP :: BuilderRef -> ValueRef -> Ptr ValueRef -> CUInt -> CString -> IO ValueRef
buildTrunc :: BuilderRef -> ValueRef -> TypeRef -> CString -> IO ValueRef
buildZExt :: BuilderRef -> ValueRef -> TypeRef -> CString -> IO ValueRef
buildSExt :: BuilderRef -> ValueRef -> TypeRef -> CString -> IO ValueRef
buildFPToUI :: BuilderRef -> ValueRef -> TypeRef -> CString -> IO ValueRef
buildFPToSI :: BuilderRef -> ValueRef -> TypeRef -> CString -> IO ValueRef
buildUIToFP :: BuilderRef -> ValueRef -> TypeRef -> CString -> IO ValueRef
buildSIToFP :: BuilderRef -> ValueRef -> TypeRef -> CString -> IO ValueRef
buildFPTrunc :: BuilderRef -> ValueRef -> TypeRef -> CString -> IO ValueRef
buildFPExt :: BuilderRef -> ValueRef -> TypeRef -> CString -> IO ValueRef
buildPtrToInt :: BuilderRef -> ValueRef -> TypeRef -> CString -> IO ValueRef
buildIntToPtr :: BuilderRef -> ValueRef -> TypeRef -> CString -> IO ValueRef
buildBitCast :: BuilderRef -> ValueRef -> TypeRef -> CString -> IO ValueRef
buildPointerCast :: BuilderRef -> ValueRef -> TypeRef -> CString -> IO ValueRef
buildTruncOrBitCast :: BuilderRef -> ValueRef -> TypeRef -> CString -> IO ValueRef
buildZExtOrBitCast :: BuilderRef -> ValueRef -> TypeRef -> CString -> IO ValueRef
buildSExtOrBitCast :: BuilderRef -> ValueRef -> TypeRef -> CString -> IO ValueRef
buildPtrDiff :: BuilderRef -> ValueRef -> ValueRef -> CString -> IO ValueRef
buildAggregateRet :: BuilderRef -> (Ptr ValueRef) -> CUInt -> IO ValueRef
buildGlobalString :: BuilderRef -> CString -> CString -> IO ValueRef
buildGlobalStringPtr :: BuilderRef -> CString -> CString -> IO ValueRef
buildInBoundsGEP :: BuilderRef -> ValueRef -> (Ptr ValueRef) -> CUInt -> CString -> IO ValueRef
buildIntCast :: BuilderRef -> ValueRef -> TypeRef -> CString -> IO ValueRef
buildIsNotNull :: BuilderRef -> ValueRef -> CString -> IO ValueRef
buildIsNull :: BuilderRef -> ValueRef -> CString -> IO ValueRef
buildNSWAdd :: BuilderRef -> ValueRef -> ValueRef -> CString -> IO ValueRef
buildStructGEP :: BuilderRef -> ValueRef -> CUInt -> CString -> IO ValueRef
buildICmp :: BuilderRef -> CInt -> ValueRef -> ValueRef -> CString -> IO ValueRef
buildFCmp :: BuilderRef -> CInt -> ValueRef -> ValueRef -> CString -> IO ValueRef
buildPhi :: BuilderRef -> TypeRef -> CString -> IO ValueRef
buildCall :: BuilderRef -> ValueRef -> Ptr ValueRef -> CUInt -> CString -> IO ValueRef
buildSelect :: BuilderRef -> ValueRef -> ValueRef -> ValueRef -> CString -> IO ValueRef
buildVAArg :: BuilderRef -> ValueRef -> TypeRef -> CString -> IO ValueRef
buildExtractElement :: BuilderRef -> ValueRef -> ValueRef -> CString -> IO ValueRef
buildInsertElement :: BuilderRef -> ValueRef -> ValueRef -> ValueRef -> CString -> IO ValueRef
buildShuffleVector :: BuilderRef -> ValueRef -> ValueRef -> ValueRef -> CString -> IO ValueRef
buildExtractValue :: BuilderRef -> ValueRef -> CUInt -> CString -> IO ValueRef
buildInsertValue :: BuilderRef -> ValueRef -> ValueRef -> CUInt -> CString -> IO ValueRef
addCase :: ValueRef -> ValueRef -> BasicBlockRef -> IO ()
data MemoryBuffer
type MemoryBufferRef = Ptr MemoryBuffer
createMemoryBufferWithContentsOfFile :: CString -> Ptr MemoryBufferRef -> Ptr CString -> IO CInt
createMemoryBufferWithSTDIN :: Ptr MemoryBufferRef -> Ptr CString -> IO CInt
disposeMemoryBuffer :: MemoryBufferRef -> IO ()
disposeMessage :: CString -> IO ()
addAttribute :: ValueRef -> CAttribute -> IO ()
setInstrParamAlignment :: ValueRef -> CUInt -> CUInt -> IO ()
setParamAlignment :: ValueRef -> CUInt -> IO ()
data Attribute
ZExtAttribute :: Attribute
SExtAttribute :: Attribute
NoReturnAttribute :: Attribute
InRegAttribute :: Attribute
StructRetAttribute :: Attribute
NoUnwindAttribute :: Attribute
NoAliasAttribute :: Attribute
ByValAttribute :: Attribute
NestAttribute :: Attribute
ReadNoneAttribute :: Attribute
ReadOnlyAttribute :: Attribute
fromAttribute :: Attribute -> CAttribute
toAttribute :: CAttribute -> Attribute
addInstrAttribute :: ValueRef -> CUInt -> CAttribute -> IO ()
removeFunctionAttr :: ValueRef -> CAttribute -> IO ()
removeAttribute :: ValueRef -> CAttribute -> IO ()
removeInstrAttribute :: ValueRef -> CUInt -> CAttribute -> IO ()
addFunctionAttr :: ValueRef -> CAttribute -> IO ()
data PassManager
type PassManagerRef = Ptr PassManager
createFunctionPassManager :: ModuleProviderRef -> IO PassManagerRef
createPassManager :: IO PassManagerRef
ptrDisposePassManager :: FunPtr (PassManagerRef -> IO ())
finalizeFunctionPassManager :: PassManagerRef -> IO CInt
initializeFunctionPassManager :: PassManagerRef -> IO CInt
runFunctionPassManager :: PassManagerRef -> ValueRef -> IO CInt
runPassManager :: PassManagerRef -> ModuleRef -> IO CInt
data Context
type ContextRef = Ptr Context
dumpModule :: ModuleRef -> IO ()
alignOf :: TypeRef -> IO ValueRef
constInBoundsGEP :: ValueRef -> (Ptr ValueRef) -> CUInt -> IO ValueRef
constIntCast :: ValueRef -> TypeRef -> CUInt -> IO ValueRef
constIntOfString :: TypeRef -> CString -> CUInt -> IO ValueRef
constIntOfStringAndSize :: TypeRef -> CString -> CUInt -> CUInt -> IO ValueRef
constNSWAdd :: ValueRef -> ValueRef -> IO ValueRef
constPointerCast :: ValueRef -> TypeRef -> IO ValueRef
constPointerNull :: TypeRef -> IO ValueRef
constRealOfStringAndSize :: TypeRef -> CString -> CUInt -> IO ValueRef
constSExtOrBitCast :: ValueRef -> TypeRef -> IO ValueRef
getTypeByName :: ModuleRef -> CString -> IO TypeRef
insertIntoBuilderWithName :: BuilderRef -> ValueRef -> CString -> IO ()
moduleCreateWithNameInContext :: CString -> ContextRef -> IO ModuleRef
appendBasicBlockInContext :: ContextRef -> ValueRef -> CString -> IO BasicBlockRef
insertBasicBlockInContext :: ContextRef -> BasicBlockRef -> CString -> IO BasicBlockRef
createBuilderInContext :: ContextRef -> IO BuilderRef
contextDispose :: ContextRef -> IO ()
constStringInContext :: ContextRef -> CString -> CUInt -> CInt -> IO ValueRef
constStructInContext :: ContextRef -> (Ptr ValueRef) -> CUInt -> CInt -> IO ValueRef
constTruncOrBitCast :: ValueRef -> TypeRef -> IO ValueRef
constZExtOrBitCast :: ValueRef -> TypeRef -> IO ValueRef
doubleTypeInContext :: ContextRef -> IO TypeRef
fP128TypeInContext :: ContextRef -> IO TypeRef
floatTypeInContext :: ContextRef -> IO TypeRef
int16TypeInContext :: ContextRef -> IO TypeRef
int1TypeInContext :: ContextRef -> IO TypeRef
int32TypeInContext :: ContextRef -> IO TypeRef
int64TypeInContext :: ContextRef -> IO TypeRef
int8TypeInContext :: ContextRef -> IO TypeRef
intTypeInContext :: ContextRef -> CUInt -> IO TypeRef
labelTypeInContext :: ContextRef -> IO TypeRef
opaqueTypeInContext :: ContextRef -> IO TypeRef
pPCFP128TypeInContext :: ContextRef -> IO TypeRef
structTypeInContext :: ContextRef -> (Ptr TypeRef) -> CUInt -> CInt -> IO TypeRef
voidTypeInContext :: ContextRef -> IO TypeRef
x86FP80TypeInContext :: ContextRef -> IO TypeRef
getTypeContext :: TypeRef -> IO ContextRef
instance Typeable Context
instance Typeable PassManager
instance Typeable Attribute
instance Typeable TypeKind
instance Typeable TypeHandle
instance Typeable MemoryBuffer
instance Typeable Builder
instance Typeable Linkage
instance Typeable CallingConvention
instance Typeable Value
instance Typeable Type
instance Typeable ModuleProvider
instance Typeable Module
instance Show Attribute
instance Eq Attribute
instance Ord Attribute
instance Enum Attribute
instance Bounded Attribute
instance Eq TypeKind
instance Ord TypeKind
instance Enum TypeKind
instance Bounded TypeKind
instance Show TypeKind
instance Read TypeKind
instance Show Visibility
instance Eq Visibility
instance Ord Visibility
instance Enum Visibility
instance Show Linkage
instance Eq Linkage
instance Ord Linkage
instance Enum Linkage
instance Show CallingConvention
instance Eq CallingConvention
instance Ord CallingConvention
instance Enum CallingConvention
instance Bounded CallingConvention

module LLVM.FFI.Analysis
type VerifierFailureAction = CInt
verifyFunction :: ValueRef -> VerifierFailureAction -> IO CInt
verifyModule :: ModuleRef -> VerifierFailureAction -> (Ptr CString) -> IO CInt
viewFunctionCFG :: ValueRef -> IO ()
viewFunctionCFGOnly :: ValueRef -> IO ()

module LLVM.FFI.BitReader
getBitcodeModuleProvider :: MemoryBufferRef -> (Ptr ModuleProviderRef) -> (Ptr CString) -> IO CInt
parseBitcode :: MemoryBufferRef -> (Ptr ModuleRef) -> (Ptr CString) -> IO CInt
getBitcodeModuleProviderInContext :: ContextRef -> MemoryBufferRef -> (Ptr ModuleProviderRef) -> (Ptr CString) -> IO CInt
parseBitcodeInContext :: ContextRef -> MemoryBufferRef -> (Ptr ModuleRef) -> (Ptr CString) -> IO CInt

module LLVM.FFI.BitWriter
writeBitcodeToFile :: ModuleRef -> CString -> IO CInt
writeBitcodeToFileHandle :: ModuleRef -> CInt -> IO CInt

module LLVM.FFI.Target
type ByteOrdering = CInt
data TargetData
type TargetDataRef = Ptr TargetData
aBIAlignmentOfType :: TargetDataRef -> TypeRef -> CUInt
aBISizeOfType :: TargetDataRef -> TypeRef -> CULLong
addTargetData :: TargetDataRef -> PassManagerRef -> IO ()
byteOrder :: TargetDataRef -> ByteOrdering
callFrameAlignmentOfType :: TargetDataRef -> TypeRef -> CUInt
copyStringRepOfTargetData :: TargetDataRef -> IO CString
createTargetData :: CString -> IO TargetDataRef
disposeTargetData :: TargetDataRef -> IO ()
elementAtOffset :: TargetDataRef -> TypeRef -> CULLong -> CUInt
intPtrType :: TargetDataRef -> TypeRef
invalidateStructLayout :: TargetDataRef -> TypeRef -> IO ()
offsetOfElement :: TargetDataRef -> TypeRef -> CUInt -> CULLong
pointerSize :: TargetDataRef -> CUInt
preferredAlignmentOfGlobal :: TargetDataRef -> ValueRef -> CUInt
preferredAlignmentOfType :: TargetDataRef -> TypeRef -> CUInt
sizeOfTypeInBits :: TargetDataRef -> TypeRef -> CULLong
storeSizeOfType :: TargetDataRef -> TypeRef -> CULLong
instance Typeable TargetData

module LLVM.FFI.ExecutionEngine
data ExecutionEngine
createExecutionEngine :: Ptr ExecutionEngineRef -> ModuleProviderRef -> Ptr CString -> IO CInt
ptrDisposeExecutionEngine :: FunPtr (ExecutionEngineRef -> IO ())
createInterpreter :: Ptr ExecutionEngineRef -> ModuleProviderRef -> Ptr CString -> IO CInt
createJITCompiler :: Ptr ExecutionEngineRef -> ModuleProviderRef -> Ptr CString -> IO CInt
addModuleProvider :: ExecutionEngineRef -> ModuleProviderRef -> IO ()
removeModuleProvider :: ExecutionEngineRef -> ModuleProviderRef -> Ptr ModuleRef -> Ptr CString -> IO CInt
findFunction :: ExecutionEngineRef -> CString -> Ptr ValueRef -> IO CInt
freeMachineCodeForFunction :: ExecutionEngineRef -> ValueRef -> IO ()
runStaticConstructors :: ExecutionEngineRef -> IO ()
runStaticDestructors :: ExecutionEngineRef -> IO ()
runFunction :: ExecutionEngineRef -> ValueRef -> CUInt -> Ptr GenericValueRef -> IO GenericValueRef
runFunctionAsMain :: ExecutionEngineRef -> ValueRef -> CUInt -> Ptr CString -> Ptr CString -> IO CInt
getExecutionEngineTargetData :: ExecutionEngineRef -> IO TargetDataRef
addGlobalMapping :: ExecutionEngineRef -> ValueRef -> Ptr () -> IO ()
getPointerToGlobal :: ExecutionEngineRef -> ValueRef -> IO (FunPtr a)
data GenericValue
type GenericValueRef = Ptr GenericValue
createGenericValueOfInt :: TypeRef -> CULLong -> CInt -> IO GenericValueRef
genericValueToInt :: GenericValueRef -> CInt -> CULLong
genericValueIntWidth :: GenericValueRef -> IO CUInt
createGenericValueOfFloat :: TypeRef -> CDouble -> IO GenericValueRef
genericValueToFloat :: TypeRef -> GenericValueRef -> CDouble
createGenericValueOfPointer :: Ptr a -> IO GenericValueRef
genericValueToPointer :: GenericValueRef -> IO (Ptr a)
ptrDisposeGenericValue :: FunPtr (GenericValueRef -> IO ())
linkInJIT :: IO ()
instance Typeable GenericValue
instance Typeable ExecutionEngine

module LLVM.FFI.Transforms.IPO
addArgumentPromotionPass :: PassManagerRef -> IO ()
addConstantMergePass :: PassManagerRef -> IO ()
addDeadArgEliminationPass :: PassManagerRef -> IO ()
addDeadTypeEliminationPass :: PassManagerRef -> IO ()
addFunctionAttrsPass :: PassManagerRef -> IO ()
addFunctionInliningPass :: PassManagerRef -> IO ()
addGlobalDCEPass :: PassManagerRef -> IO ()
addGlobalOptimizerPass :: PassManagerRef -> IO ()
addIPConstantPropagationPass :: PassManagerRef -> IO ()
addLowerSetJmpPass :: PassManagerRef -> IO ()
addPruneEHPass :: PassManagerRef -> IO ()
addRaiseAllocationsPass :: PassManagerRef -> IO ()
addStripDeadPrototypesPass :: PassManagerRef -> IO ()
addStripSymbolsPass :: PassManagerRef -> IO ()

module LLVM.FFI.Transforms.Scalar
addCFGSimplificationPass :: PassManagerRef -> IO ()
addConstantPropagationPass :: PassManagerRef -> IO ()
addDemoteMemoryToRegisterPass :: PassManagerRef -> IO ()
addGVNPass :: PassManagerRef -> IO ()
addInstructionCombiningPass :: PassManagerRef -> IO ()
addPromoteMemoryToRegisterPass :: PassManagerRef -> IO ()
addReassociatePass :: PassManagerRef -> IO ()
addAggressiveDCEPass :: PassManagerRef -> IO ()
addCondPropagationPass :: PassManagerRef -> IO ()
addDeadStoreEliminationPass :: PassManagerRef -> IO ()
addIndVarSimplifyPass :: PassManagerRef -> IO ()
addJumpThreadingPass :: PassManagerRef -> IO ()
addLICMPass :: PassManagerRef -> IO ()
addLoopDeletionPass :: PassManagerRef -> IO ()
addLoopIndexSplitPass :: PassManagerRef -> IO ()
addLoopRotatePass :: PassManagerRef -> IO ()
addLoopUnrollPass :: PassManagerRef -> IO ()
addLoopUnswitchPass :: PassManagerRef -> IO ()
addMemCpyOptPass :: PassManagerRef -> IO ()
addSCCPPass :: PassManagerRef -> IO ()
addScalarReplAggregatesPass :: PassManagerRef -> IO ()
addSimplifyLibCallsPass :: PassManagerRef -> IO ()
addTailCallEliminationPass :: PassManagerRef -> IO ()

module LLVM.Util.Optimize
optimizeModule :: Int -> Module -> IO Int


-- | The LLVM (Low Level Virtual Machine) is virtual machine at a machine
--   code level. It supports both stand alone code generation and JITing.
--   The Haskell llvm package is a (relatively) high level interface to the
--   LLVM. The high level interface makes it easy to construct LLVM code.
--   There is also an interface to the raw low level LLVM API as exposed by
--   the LLVM C interface.
--   
--   LLVM code is organized into modules (type <a>Module</a>). Each module
--   contains a number of global variables and functions (type
--   <a>Function</a>). Each functions has a number of basic blocks (type
--   <a>BasicBlock</a>). Each basic block has a number instructions, where
--   each instruction produces a value (type <a>Value</a>).
--   
--   Unlike assembly code for a real processor the assembly code for LLVM
--   is in SSA (Static Single Assignment) form. This means that each
--   instruction generates a new bound variable which may not be assigned
--   again. A consequence of this is that where control flow joins from
--   several execution paths there has to be a phi pseudo instruction if
--   you want different variables to be joined into one.
--   
--   The definition of several of the LLVM entities (<a>Module</a>,
--   <a>Function</a>, and <a>BasicBlock</a>) follow the same pattern. First
--   the entity has to be created using <tt>newX</tt> (where <tt>X</tt> is
--   one of <tt>Module</tt>, <tt>Function</tt>, or <tt>BasicBlock</tt>),
--   then at some later point it has to given its definition using
--   <tt>defineX</tt>. The reason for splitting the creation and definition
--   is that you often need to be able to refer to an entity before giving
--   it's body, e.g., in two mutually recursive functions. The the
--   <tt>newX</tt> and <tt>defineX</tt> function can also be done at the
--   same time by using <tt>createX</tt>. Furthermore, an explicit name can
--   be given to an entity by the <tt>newNamedX</tt> function; the
--   <tt>newX</tt> function just generates a fresh name.
module LLVM.Core

-- | Initialize jitter to the native target. The operation is idempotent.
initializeNativeTarget :: IO ()

-- | Type of top level modules.
data Module

-- | Create a new module.
newModule :: IO Module

-- | Create a new explicitely named module.
newNamedModule :: String -> IO Module

-- | Give the body for a module.
defineModule :: Module -> CodeGenModule a -> IO a

-- | Free all storage related to a module. *Note*, this is a dangerous
--   call, since referring to the module after this call is an error. The
--   reason for the explicit call to free the module instead of an
--   automatic lifetime management is that modules have a somewhat
--   complicated ownership. Handing a module to a module provider changes
--   the ownership of the module, and the module provider will free the
--   module when necessary.
destroyModule :: Module -> IO ()

-- | Create a new module with the given body.
createModule :: CodeGenModule a -> IO a

-- | A module provider is used by the code generator to get access to a
--   module.
data ModuleProvider

-- | Turn a module into a module provider.
createModuleProviderForExistingModule :: Module -> IO ModuleProvider

-- | Manage compile passes.
data PassManager

-- | Create a pass manager.
createPassManager :: IO PassManager

-- | Create a pass manager for a module.
createFunctionPassManager :: ModuleProvider -> IO PassManager

-- | Write a module to a file.
writeBitcodeToFile :: String -> Module -> IO ()

-- | Read a module from a file.
readBitcodeFromFile :: String -> IO Module
getModuleValues :: Module -> IO [(String, ModuleValue)]
data ModuleValue
castModuleValue :: (IsType a) => ModuleValue -> Maybe (Value a)

-- | Return from the current function with the given value. Use () as the
--   return value for what would be a void function is C.
ret :: (Ret a r) => a -> CodeGenFunction r Terminate

-- | Branch to the first basic block if the boolean is true, otherwise to
--   the second basic block.
condBr :: Value Bool -> BasicBlock -> BasicBlock -> CodeGenFunction r Terminate

-- | Unconditionally branch to the given basic block.
br :: BasicBlock -> CodeGenFunction r Terminate

-- | Branch table instruction.
switch :: (IsInteger a) => Value a -> BasicBlock -> [(ConstValue a, BasicBlock)] -> CodeGenFunction r Terminate

-- | Call a function with exception handling.
invoke :: (CallArgs f g) => BasicBlock -> BasicBlock -> Function f -> g

-- | Unwind the call stack until a function call performed with
--   <a>invoke</a> is reached. I.e., throw a non-local exception.
unwind :: CodeGenFunction r Terminate

-- | Inform the code generator that this code can never be reached.
unreachable :: CodeGenFunction r Terminate
add :: (IsArithmetic c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
sub :: (IsArithmetic c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
mul :: (IsArithmetic c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
neg :: (IsArithmetic a) => Value a -> CodeGenFunction r (Value a)
fadd :: (IsFloating c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
fsub :: (IsFloating c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
fmul :: (IsFloating c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
udiv :: (IsInteger c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
sdiv :: (IsInteger c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)

-- | Floating point division.
fdiv :: (IsFloating c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
urem :: (IsInteger c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
srem :: (IsInteger c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)

-- | Floating point remainder.
frem :: (IsFloating c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
shl :: (IsInteger c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
lshr :: (IsInteger c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
ashr :: (IsInteger c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
and :: (IsInteger c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
or :: (IsInteger c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
xor :: (IsInteger c, ABinOp a b (v c)) => a -> b -> CodeGenFunction r (v c)
inv :: (IsInteger a) => Value a -> CodeGenFunction r (Value a)

-- | Get a value from a vector.
extractelement :: Value (Vector n a) -> Value Word32 -> CodeGenFunction r (Value a)

-- | Insert a value into a vector, nondestructive.
insertelement :: Value (Vector n a) -> Value a -> Value Word32 -> CodeGenFunction r (Value (Vector n a))

-- | Permute vector.
shufflevector :: Value (Vector n a) -> Value (Vector n a) -> ConstValue (Vector n Word32) -> CodeGenFunction r (Value (Vector n a))

-- | Get a value from an aggregate.
extractvalue :: (GetValue agg i a) => Value agg -> i -> CodeGenFunction r (Value a)

-- | Insert a value into an aggregate, nondestructive.
insertvalue :: (GetValue agg i a) => Value agg -> Value a -> i -> CodeGenFunction r (Value agg)

-- | Allocate heap memory.
malloc :: (IsSized a s) => CodeGenFunction r (Value (Ptr a))

-- | Allocate heap (array) memory.
arrayMalloc :: (IsSized a n, AllocArg s) => s -> CodeGenFunction r (Value (Ptr a))

-- | Allocate stack memory.
alloca :: (IsSized a s) => CodeGenFunction r (Value (Ptr a))

-- | Allocate stack (array) memory.
arrayAlloca :: (IsSized a n, AllocArg s) => s -> CodeGenFunction r (Value (Ptr a))

-- | Free heap memory.
free :: Value (Ptr a) -> CodeGenFunction r (Value ())

-- | Load a value from memory.
load :: Value (Ptr a) -> CodeGenFunction r (Value a)

-- | Store a value in memory
store :: Value a -> Value (Ptr a) -> CodeGenFunction r (Value ())

-- | Address arithmetic. See LLVM description. The index is a nested tuple
--   of the form <tt>(i1,(i2,( ... ())))</tt>. (This is without a doubt the
--   most confusing LLVM instruction, but the types help.)
getElementPtr :: (GetElementPtr o i n, IsIndexArg a) => Value (Ptr o) -> (a, i) -> CodeGenFunction r (Value (Ptr n))

-- | Like getElementPtr, but with an initial index that is 0. This is
--   useful since any pointer first need to be indexed off the pointer, and
--   then into its actual value. This first indexing is often with 0.
getElementPtr0 :: (GetElementPtr o i n) => Value (Ptr o) -> i -> CodeGenFunction r (Value (Ptr n))

-- | Truncate a value to a shorter bit width.
trunc :: (IsInteger a, IsInteger b, IsPrimitive a, IsPrimitive b, IsSized a sa, IsSized b sb, :>: sa sb) => Value a -> CodeGenFunction r (Value b)

-- | Zero extend a value to a wider width.
zext :: (IsInteger a, IsInteger b, IsPrimitive a, IsPrimitive b, IsSized a sa, IsSized b sb, :<: sa sb) => Value a -> CodeGenFunction r (Value b)

-- | Sign extend a value to wider width.
sext :: (IsInteger a, IsInteger b, IsPrimitive a, IsPrimitive b, IsSized a sa, IsSized b sb, :<: sa sb) => Value a -> CodeGenFunction r (Value b)

-- | Truncate a floating point value.
fptrunc :: (IsFloating a, IsFloating b, IsPrimitive a, IsPrimitive b, IsSized a sa, IsSized b sb, :>: sa sb) => Value a -> CodeGenFunction r (Value b)

-- | Extend a floating point value.
fpext :: (IsFloating a, IsFloating b, IsPrimitive a, IsPrimitive b, IsSized a sa, IsSized b sb, :<: sa sb) => Value a -> CodeGenFunction r (Value b)

-- | Convert a floating point value to an unsigned integer.
fptoui :: (IsFloating a, IsInteger b, NumberOfElements n a, NumberOfElements n b) => Value a -> CodeGenFunction r (Value b)

-- | Convert a floating point value to a signed integer.
fptosi :: (IsFloating a, IsInteger b, NumberOfElements n a, NumberOfElements n b) => Value a -> CodeGenFunction r (Value b)

-- | Convert an unsigned integer to a floating point value.
uitofp :: (IsInteger a, IsFloating b, NumberOfElements n a, NumberOfElements n b) => Value a -> CodeGenFunction r (Value b)

-- | Convert a signed integer to a floating point value.
sitofp :: (IsInteger a, IsFloating b, NumberOfElements n a, NumberOfElements n b) => Value a -> CodeGenFunction r (Value b)

-- | Convert a pointer to an integer.
ptrtoint :: (IsInteger b, IsPrimitive b) => Value (Ptr a) -> CodeGenFunction r (Value b)

-- | Convert an integer to a pointer.
inttoptr :: (IsInteger a, IsType b) => Value a -> CodeGenFunction r (Value (Ptr b))

-- | Convert between to values of the same size by just copying the bit
--   pattern.
bitcast :: (IsFirstClass a, IsFirstClass b, IsSized a sa, IsSized b sb, :==: sa sb) => Value a -> CodeGenFunction r (Value b)

-- | Same as bitcast but instead of the '(:==:)' type class it uses type
--   unification. This way, properties like reflexivity, symmetry and
--   transitivity are obvious to the Haskell compiler.
bitcastUnify :: (IsFirstClass a, IsFirstClass b, IsSized a s, IsSized b s) => Value a -> CodeGenFunction r (Value b)
data IntPredicate

-- | equal
IntEQ :: IntPredicate

-- | not equal
IntNE :: IntPredicate

-- | unsigned greater than
IntUGT :: IntPredicate

-- | unsigned greater or equal
IntUGE :: IntPredicate

-- | unsigned less than
IntULT :: IntPredicate

-- | unsigned less or equal
IntULE :: IntPredicate

-- | signed greater than
IntSGT :: IntPredicate

-- | signed greater or equal
IntSGE :: IntPredicate

-- | signed less than
IntSLT :: IntPredicate

-- | signed less or equal
IntSLE :: IntPredicate
data FPPredicate

-- | Always false (always folded)
FPFalse :: FPPredicate

-- | True if ordered and equal
FPOEQ :: FPPredicate

-- | True if ordered and greater than
FPOGT :: FPPredicate

-- | True if ordered and greater than or equal
FPOGE :: FPPredicate

-- | True if ordered and less than
FPOLT :: FPPredicate

-- | True if ordered and less than or equal
FPOLE :: FPPredicate

-- | True if ordered and operands are unequal
FPONE :: FPPredicate

-- | True if ordered (no nans)
FPORD :: FPPredicate

-- | True if unordered: isnan(X) | isnan(Y)
FPUNO :: FPPredicate

-- | True if unordered or equal
FPUEQ :: FPPredicate

-- | True if unordered or greater than
FPUGT :: FPPredicate

-- | True if unordered, greater than, or equal
FPUGE :: FPPredicate

-- | True if unordered or less than
FPULT :: FPPredicate

-- | True if unordered, less than, or equal
FPULE :: FPPredicate

-- | True if unordered or not equal
FPUNE :: FPPredicate

-- | Always true (always folded)
FPT :: FPPredicate
class CmpRet a b | a -> b

-- | Compare integers.
icmp :: (IsIntegerOrPointer c, CmpOp a b c d, CmpRet c d) => IntPredicate -> a -> b -> CodeGenFunction r (Value d)

-- | Compare floating point values.
fcmp :: (IsFloating c, CmpOp a b c d, CmpRet c d) => FPPredicate -> a -> b -> CodeGenFunction r (Value d)

-- | Select between two values depending on a boolean.
select :: (IsFirstClass a, CmpRet a b) => Value b -> Value a -> Value a -> CodeGenFunction r (Value a)

-- | Join several variables (virtual registers) from different basic blocks
--   into one. All of the variables in the list are joined. See also
--   <a>addPhiInputs</a>.
phi :: (IsFirstClass a) => [(Value a, BasicBlock)] -> CodeGenFunction r (Value a)

-- | Add additional inputs to an existing phi node. The reason for this
--   instruction is that sometimes the structure of the code makes it
--   impossible to have all variables in scope at the point where you need
--   the phi node.
addPhiInputs :: (IsFirstClass a) => Value a -> [(Value a, BasicBlock)] -> CodeGenFunction r ()

-- | Call a function with the given arguments. The <a>call</a> instruction
--   is variadic, i.e., the number of arguments it takes depends on the
--   type of <i>f</i>.
call :: (CallArgs f g) => Function f -> g
type Terminate = ()

-- | Acceptable arguments to the <a>ret</a> instruction.
class Ret a r

-- | Acceptable arguments to <a>call</a>.
class CallArgs f g | f -> g, g -> f

-- | Acceptable arguments to arithmetic binary instructions.
class ABinOp a b c | a b -> c

-- | Acceptable operands to comparison instructions.
class CmpOp a b c d | a b -> c
class FunctionArgs f g r | f -> g r, g r -> f

-- | This class is just to simplify contexts.
class (FunctionArgs (IO a) (CodeGenFunction a ()) (CodeGenFunction a ())) => FunctionRet a
class IsConst a

-- | Acceptable argument to array memory allocation.
class AllocArg a

-- | Acceptable arguments to <tt>getElementPointer</tt>.
class GetElementPtr optr ixs nptr | optr ixs -> nptr

-- | Acceptable single index to <tt>getElementPointer</tt>.
class IsIndexArg a

-- | Acceptable arguments to <a>extractvalue</a> and <a>insertvalue</a>.
class GetValue agg ix el | agg ix -> el

-- | The <a>IsType</a> class classifies all types that have an LLVM
--   representation.
class IsType a
typeDesc :: (IsType a) => a -> TypeDesc

-- | Arithmetic types, i.e., integral and floating types.
class (IsFirstClass a) => IsArithmetic a

-- | Integral types.
class (IsArithmetic a, IsIntegerOrPointer a) => IsInteger a

-- | Integral or pointer type.
class IsIntegerOrPointer a

-- | Floating types.
class (IsArithmetic a) => IsFloating a

-- | Primitive types.
class (NumberOfElements D1 a) => IsPrimitive a

-- | First class types, i.e., the types that can be passed as arguments,
--   etc.
class (IsType a) => IsFirstClass a

-- | Types with a fixed size.
class (IsType a, Pos s) => IsSized a s | a -> s

-- | Function type.
class (IsType a) => IsFunction a
type UnknownSize = D99
class (Pos n) => IsPowerOf2 n

-- | Number of elements for instructions that handle both primitive and
--   vector types
class (IsType a) => NumberOfElements n a | a -> n
type :& a as = (a, as)
(&) :: a -> as -> a :& as

-- | TupleFunction is used for distinction of tuple and atomic arguments.
--   The a function of type <tt>a -&gt; b :+-&gt; c -&gt; d</tt> has atomic
--   arguments of type <tt>a</tt> and <tt>c</tt> and an argument of a type
--   <tt>b</tt> that can be a tuple. If <tt>a = (Word8,Int16)</tt> then the
--   corresponding LLVM value is of type <tt>Value (Word8,Int16)</tt>.
--   However, I do not know of a LLVM function that accepts values of this
--   type. If <tt>b = (Word8,Int16)</tt> then the corresponding LLVM value
--   is of type <tt>(Value Word8, Value Int16)</tt>.
data (:+->) a b
($+) :: (a :+-> b) -> (a -> b)
class IsTuple a
tupleDesc :: (IsTuple a) => a -> [TypeDesc]
withTuple :: (a -> b) -> (a :+-> b)

-- | Type descriptor, used to convey type information through the LLVM API.
data TypeDesc
TDFloat :: TypeDesc
TDDouble :: TypeDesc
TDFP128 :: TypeDesc
TDVoid :: TypeDesc
TDInt :: Bool -> Integer -> TypeDesc
TDArray :: Integer -> TypeDesc -> TypeDesc
TDVector :: Integer -> TypeDesc -> TypeDesc
TDPtr :: TypeDesc -> TypeDesc
TDFunction :: Bool -> [TypeDesc] -> TypeDesc -> TypeDesc
TDLabel :: TypeDesc
TDStruct :: [TypeDesc] -> Bool -> TypeDesc
isFloating :: (IsArithmetic a) => a -> Bool
isSigned :: (IsInteger a) => a -> Bool
typeRef :: (IsType a) => a -> TypeRef
typeName :: (IsType a) => a -> String

-- | The <a>VarArgs</a> type is a placeholder for the real <a>IO</a> type
--   that can be obtained with <tt>castVarArgs</tt>.
data VarArgs a

-- | Define what vararg types are permissible.
class CastVarArgs a b

-- | Variable sized signed integer. The <i>n</i> parameter should belong to
--   <tt>PosI</tt>.
newtype (Pos n) => IntN n
IntN :: Integer -> IntN n

-- | Variable sized unsigned integer. The <i>n</i> parameter should belong
--   to <tt>PosI</tt>.
newtype (Pos n) => WordN n
WordN :: Integer -> WordN n

-- | 128 bit floating point.
newtype FP128
FP128 :: Rational -> FP128

-- | Fixed sized arrays, the array size is encoded in the <i>n</i>
--   parameter.
newtype (Nat n) => Array n a
Array :: [a] -> Array n a

-- | Fixed sized vector, the array size is encoded in the <i>n</i>
--   parameter.
newtype Vector n a
Vector :: [a] -> Vector n a

-- | A value of type <tt><a>Ptr</a> a</tt> represents a pointer to an
--   object, or an array of objects, which may be marshalled to or from
--   Haskell values of type <tt>a</tt>.
--   
--   The type <tt>a</tt> will often be an instance of class
--   Foreign.Storable.Storable which provides the marshalling operations.
--   However this is not essential, and you can provide your own operations
--   to access the pointer. For example you might write small foreign
--   functions to get or set the fields of a C <tt>struct</tt>.
data Ptr a :: * -> *

-- | Label type, produced by a basic block.
data Label

-- | Struct types; a list (nested tuple) of component types.
newtype Struct a
Struct :: a -> Struct a
newtype PackedStruct a
PackedStruct :: a -> PackedStruct a
data Value a
data ConstValue a
valueOf :: (IsConst a) => a -> Value a
value :: ConstValue a -> Value a
zero :: (IsType a) => ConstValue a
allOnes :: (IsInteger a) => ConstValue a
undef :: (IsType a) => ConstValue a
createString :: String -> TGlobal (Array n Word8)
createStringNul :: String -> TGlobal (Array n Word8)

-- | Make a constant vector. Replicates or truncates the list to get length
--   <i>n</i>.
constVector :: (Pos n) => [ConstValue a] -> ConstValue (Vector n a)

-- | Make a constant array. Replicates or truncates the list to get length
--   <i>n</i>.
constArray :: (IsSized a s, Nat n) => [ConstValue a] -> ConstValue (Array n a)

-- | Make a constant struct.
constStruct :: (IsConstStruct c a) => c -> ConstValue (Struct a)

-- | Make a constant packed struct.
constPackedStruct :: (IsConstStruct c a) => c -> ConstValue (PackedStruct a)
toVector :: (MkVector va n a) => va -> Vector n a
fromVector :: (MkVector va n a) => Vector n a -> va

-- | Make a constant vector. Replicates or truncates the list to get length
--   <i>n</i>. This behaviour is consistent with that of
--   <tt>LLVM.Core.CodeGen.constVector</tt>.
vector :: (Pos n) => [a] -> Vector n a
data CodeGenFunction r a
data CodeGenModule a

-- | A function is simply a pointer to the function.
type Function a = Value (Ptr a)

-- | Create a new function. Use <a>newNamedFunction</a> to create a
--   function with external linkage, since it needs a known name.
newFunction :: (IsFunction a) => Linkage -> CodeGenModule (Function a)

-- | Create a new named function.
newNamedFunction :: (IsFunction a) => Linkage -> String -> CodeGenModule (Function a)

-- | Define a function body. The basic block returned by the function is
--   the function entry point.
defineFunction :: (FunctionArgs f g (CodeGenFunction r ())) => Function f -> g -> CodeGenModule ()

-- | Create a new function with the given body.
createFunction :: (IsFunction f, FunctionArgs f g (CodeGenFunction r ())) => Linkage -> g -> CodeGenModule (Function f)

-- | Create a new function with the given body.
createNamedFunction :: (IsFunction f, FunctionArgs f g (CodeGenFunction r ())) => Linkage -> String -> g -> CodeGenModule (Function f)
type TFunction a = CodeGenModule (Function a)
class (Undefined a) => ValueTuple a
buildTuple :: (ValueTuple a) => FunctionRef -> State Int a
class Undefined a
undefTuple :: (Undefined a) => a
class (IsTuple haskellValue, ValueTuple llvmValue) => MakeValueTuple haskellValue llvmValue | haskellValue -> llvmValue
valueTupleOf :: (MakeValueTuple haskellValue llvmValue) => haskellValue -> llvmValue
type Global a = Value (Ptr a)

-- | Create a new global variable.
newGlobal :: (IsType a) => Bool -> Linkage -> TGlobal a

-- | Create a new named global variable.
newNamedGlobal :: (IsType a) => Bool -> Linkage -> String -> TGlobal a

-- | Give a global variable a (constant) value.
defineGlobal :: Global a -> ConstValue a -> CodeGenModule ()

-- | Create and define a global variable.
createGlobal :: (IsType a) => Bool -> Linkage -> ConstValue a -> TGlobal a

-- | Create and define a named global variable.
createNamedGlobal :: (IsType a) => Bool -> Linkage -> String -> ConstValue a -> TGlobal a

-- | Create a reference to an external function while code generating for a
--   function. If LLVM cannot resolve its name, then you may try
--   <a>staticFunction</a>.
externFunction :: (IsFunction a) => String -> CodeGenFunction r (Function a)

-- | Make an external C function with a fixed address callable from LLVM
--   code. This callback function can also be a Haskell function, that was
--   imported like
--   
--   <pre>
--   foreign import ccall "&amp;nextElement"
--      nextElementFunPtr :: FunPtr (StablePtr (IORef [Word32]) -&gt; IO Word32)
--   </pre>
--   
--   See <tt>examples/List.hs</tt>.
--   
--   When you only use <a>externFunction</a>, then LLVM cannot resolve the
--   name. (However, I do not know why.) Thus <a>staticFunction</a> manages
--   a list of static functions. This list is automatically installed by
--   <tt>ExecutionEngine.simpleFunction</tt> and can be manually obtained
--   by <a>getGlobalMappings</a> and installed by
--   <tt>ExecutionEngine.addGlobalMappings</tt>. "Installing" means calling
--   LLVM's <tt>addGlobalMapping</tt> according to
--   <a>http://old.nabble.com/jit-with-external-functions-td7769793.html</a>.
staticFunction :: (IsFunction f) => FunPtr f -> CodeGenFunction r (Function f)
data GlobalMappings

-- | Get a list created by calls to <tt>staticFunction</tt> that must be
--   passed to the execution engine via
--   <tt>LLVM.ExecutionEngine.addGlobalMappings</tt>.
getGlobalMappings :: CodeGenModule GlobalMappings
type TGlobal a = CodeGenModule (Global a)

-- | An enumeration for the kinds of linkage for global values.
data Linkage

-- | Externally visible function
ExternalLinkage :: Linkage
AvailableExternallyLinkage :: Linkage

-- | Keep one copy of function when linking (inline)
LinkOnceAnyLinkage :: Linkage

-- | Same, but only replaced by something equivalent.
LinkOnceODRLinkage :: Linkage

-- | Keep one copy of named function when linking (weak)
WeakAnyLinkage :: Linkage

-- | Same, but only replaced by something equivalent.
WeakODRLinkage :: Linkage

-- | Special purpose, only applies to global arrays
AppendingLinkage :: Linkage

-- | Rename collisions when linking (static functions)
InternalLinkage :: Linkage

-- | Like Internal, but omit from symbol table
PrivateLinkage :: Linkage

-- | Function to be imported from DLL
DLLImportLinkage :: Linkage

-- | Function to be accessible from DLL
DLLExportLinkage :: Linkage

-- | ExternalWeak linkage description
ExternalWeakLinkage :: Linkage

-- | Stand-in functions for streaming fns from BC files
GhostLinkage :: Linkage

-- | Tentative definitions
CommonLinkage :: Linkage

-- | Like Private, but linker removes.
LinkerPrivateLinkage :: Linkage

-- | A basic block is a sequence of non-branching instructions, terminated
--   by a control flow instruction.
data BasicBlock
newBasicBlock :: CodeGenFunction r BasicBlock
newNamedBasicBlock :: String -> CodeGenFunction r BasicBlock
defineBasicBlock :: BasicBlock -> CodeGenFunction r ()
createBasicBlock :: CodeGenFunction r BasicBlock
getCurrentBasicBlock :: CodeGenFunction r BasicBlock
fromLabel :: Value Label -> BasicBlock
toLabel :: BasicBlock -> Value Label

-- | Add attributes to a value. Beware, what attributes are allowed depends
--   on what kind of value it is.
addAttributes :: Value a -> Int -> [Attribute] -> CodeGenFunction r ()
data Attribute
ZExtAttribute :: Attribute
SExtAttribute :: Attribute
NoReturnAttribute :: Attribute
InRegAttribute :: Attribute
StructRetAttribute :: Attribute
NoUnwindAttribute :: Attribute
NoAliasAttribute :: Attribute
ByValAttribute :: Attribute
NestAttribute :: Attribute
ReadNoneAttribute :: Attribute
ReadOnlyAttribute :: Attribute

-- | Convert a varargs function to a regular function.
castVarArgs :: (CastVarArgs a b) => Function a -> Function b

-- | Print a value.
dumpValue :: Value a -> IO ()

-- | Print a type.
dumpType :: Value a -> IO ()

-- | Get the name of a <a>Value</a>.
getValueName :: Value a -> IO String


-- | An <tt>ExecutionEngine</tt> is JIT compiler that is used to generate
--   code for an LLVM module.
module LLVM.ExecutionEngine
data EngineAccess a

-- | The LLVM execution engine is encapsulated so it cannot be accessed
--   directly. The reason is that (currently) there must only ever be one
--   engine, so access to it is wrapped in a monad.
runEngineAccess :: EngineAccess a -> IO a
addModuleProvider :: ModuleProvider -> EngineAccess ()
addModule :: Module -> EngineAccess ()

-- | In contrast to <tt>generateFunction</tt> this compiles a function
--   once. Thus it is faster for many calls to the same function. See
--   <tt>examples/Vector.hs</tt>.
--   
--   If the function calls back into Haskell code, you also have to set the
--   function addresses using <a>addFunctionValue</a> or
--   <a>addGlobalMappings</a>.
getPointerToFunction :: Function f -> EngineAccess (FunPtr f)

-- | Tell LLVM the address of an external function if it cannot resolve a
--   name automatically. Alternatively you may declare the function with
--   <tt>staticFunction</tt> instead of <tt>externFunction</tt>.
addFunctionValue :: Function f -> FunPtr f -> EngineAccess ()

-- | Pass a list of global mappings to LLVM that can be obtained from
--   <tt>LLVM.Core.getGlobalMappings</tt>.
addGlobalMappings :: GlobalMappings -> EngineAccess ()
getFreePointers :: Function f -> EngineAccess FreePointers

-- | Get all the information needed to free a function. Freeing code might
--   have to be done from a (C) finalizer, so it has to done from C. The
--   function c_freeFunctionObject take these pointers as arguments and
--   frees the function.
type FreePointers = (Ptr ExecutionEngine, ModuleProviderRef, ValueRef)

-- | Class of LLVM function types that can be translated to the
--   corresponding Haskell type.
class Translatable f
class Generic a
class GenericTuple a

-- | Generate a Haskell function from an LLVM function.
--   
--   Note that the function is compiled for every call (Just-In-Time
--   compilation). If you want to compile the function once and call it a
--   lot of times then you should better use <a>getPointerToFunction</a>.
generateFunction :: (Translatable f) => Value (Ptr f) -> EngineAccess f
class Unsafe a b | a -> b
unsafePurify :: (Unsafe a b) => a -> b

-- | Translate a function to Haskell code. This is a simplified interface
--   to the execution engine and module mechanism. It is based on
--   <a>generateFunction</a>, so see there for limitations.
simpleFunction :: (Translatable f) => CodeGenModule (Function f) -> IO f

-- | Combine <a>simpleFunction</a> and <a>unsafePurify</a>.
unsafeGenerateFunction :: (Unsafe t a, Translatable t) => CodeGenModule (Function t) -> a
data TargetData
TargetData :: (Type -> Int) -> (Type -> Int) -> Bool -> (Type -> Int) -> Type -> Int -> (Type -> Int) -> (Type -> Int) -> (Type -> Int) -> TargetData
aBIAlignmentOfType :: TargetData -> Type -> Int
aBISizeOfType :: TargetData -> Type -> Int
littleEndian :: TargetData -> Bool
callFrameAlignmentOfType :: TargetData -> Type -> Int
intPtrType :: TargetData -> Type
pointerSize :: TargetData -> Int
preferredAlignmentOfType :: TargetData -> Type -> Int
sizeOfTypeInBits :: TargetData -> Type -> Int
storeSizeOfType :: TargetData -> Type -> Int
getTargetData :: IO TargetData
targetDataFromString :: String -> TargetData
withIntPtrType :: (forall n. (Nat n) => WordN n -> a) -> a
instance Unsafe (IO a) a
instance (Unsafe b b') => Unsafe (a -> b) (a -> b')
instance (Generic a) => Translatable (IO a)
instance (GenericTuple a, Translatable b) => Translatable (a :+-> b)
instance (Generic a, Translatable b) => Translatable (a -> b)

module LLVM.Util.Loop
class (Undefined a) => Phi a
phis :: (Phi a) => BasicBlock -> a -> CodeGenFunction r a
addPhis :: (Phi a) => BasicBlock -> a -> a -> CodeGenFunction r ()
forLoop :: (Phi a, Num i, IsConst i, IsInteger i, IsFirstClass i, CmpRet i Bool) => Value i -> Value i -> a -> (Value i -> a -> CodeGenFunction r a) -> CodeGenFunction r a
mapVector :: (IsPowerOf2 n, IsPrimitive b) => (Value a -> CodeGenFunction r (Value b)) -> Value (Vector n a) -> CodeGenFunction r (Value (Vector n b))
mapVector2 :: (IsPowerOf2 n, IsPrimitive c) => (Value a -> Value b -> CodeGenFunction r (Value c)) -> Value (Vector n a) -> Value (Vector n b) -> CodeGenFunction r (Value (Vector n c))
instance (Phi a, Phi b, Phi c) => Phi (a, b, c)
instance (Phi a, Phi b) => Phi (a, b)
instance (IsFirstClass a) => Phi (Value a)
instance Phi ()

module LLVM.Util.Arithmetic

-- | Synonym for <tt>CodeGenFunction r (Value a)</tt>.
type TValue r a = CodeGenFunction r (Value a)
class (CmpRet a b) => Cmp a b | a -> b
cmp :: (Cmp a b) => IntPredicate -> Value a -> Value a -> TValue r b
(%==) :: (Cmp a b) => TValue r a -> TValue r a -> TValue r b

-- | Comparison functions.
(%/=) :: (Cmp a b) => TValue r a -> TValue r a -> TValue r b
(%<) :: (Cmp a b) => TValue r a -> TValue r a -> TValue r b
(%<=) :: (Cmp a b) => TValue r a -> TValue r a -> TValue r b
(%>) :: (Cmp a b) => TValue r a -> TValue r a -> TValue r b
(%>=) :: (Cmp a b) => TValue r a -> TValue r a -> TValue r b

-- | Lazy and.
(%&&) :: TValue r Bool -> TValue r Bool -> TValue r Bool

-- | Lazy or.
(%||) :: TValue r Bool -> TValue r Bool -> TValue r Bool

-- | Conditional, returns first element of the pair when condition is true,
--   otherwise second.
(?) :: (IsFirstClass a) => TValue r Bool -> (TValue r a, TValue r a) -> TValue r a
(??) :: (IsFirstClass a, CmpRet a b) => TValue r b -> (TValue r a, TValue r a) -> TValue r a

-- | Return a value from an <a>arithFunction</a>.
retrn :: (Ret (Value a) r) => TValue r a -> CodeGenFunction r ()

-- | Use <tt>x &lt;- set $ ...</tt> to make a binding.
set :: TValue r a -> (CodeGenFunction r (TValue r a))
class ArithFunction a b | a -> b, b -> a

-- | Unlift a function with <tt>TValue</tt> to have <tt>Value</tt>
--   arguments.
arithFunction :: (ArithFunction a b) => a -> b
class (UncurryN a (a1 -> CodeGenFunction r b1), LiftTuple r a1 b, UncurryN a2 (b -> CodeGenFunction r b1)) => UnwrapArgs a a1 b1 b a2 r | a -> a1 b1, a1 b1 -> a, a1 -> b, b -> a1, a2 -> b b1, b b1 -> a2

-- | Lift a function from having <tt>Value</tt> arguments to having
--   <tt>TValue</tt> arguments.
toArithFunction :: (CallArgs f g, UnwrapArgs a a1 b1 b g r) => Function f -> a

-- | Define a recursive <a>arithFunction</a>, gets pased itself as the
--   first argument.
recursiveFunction :: (CallArgs a g, UnwrapArgs a11 a1 b1 b g r, FunctionArgs a a2 (CodeGenFunction r1 ()), ArithFunction a3 a2, IsFunction a) => (a11 -> a3) -> CodeGenModule (Function a)
class CallIntrinsic a
instance [overlap ok] (IsPowerOf2 n, IsPrimitive a, CallIntrinsic a) => CallIntrinsic (Vector n a)
instance [overlap ok] CallIntrinsic Double
instance [overlap ok] CallIntrinsic Float
instance [overlap ok] (UncurryN a (a1 -> CodeGenFunction r b1), LiftTuple r a1 b, UncurryN a2 (b -> CodeGenFunction r b1)) => UnwrapArgs a a1 b1 b a2 r
instance [overlap ok] (LiftTuple r b b') => LiftTuple r (CodeGenFunction r a, b) (a, b')
instance [overlap ok] LiftTuple r () ()
instance [overlap ok] (UncurryN t (b -> c)) => UncurryN (a -> t) ((a, b) -> c)
instance [overlap ok] UncurryN (CodeGenFunction r a) (() -> CodeGenFunction r a)
instance [overlap ok] (ArithFunction b b') => ArithFunction (CodeGenFunction r a -> b) (a -> b')
instance [overlap ok] (Ret a r) => ArithFunction (CodeGenFunction r a) (CodeGenFunction r ())
instance [overlap ok] (Cmp a b, CallIntrinsic a, RealFloat a, IsConst a, IsFloating a) => RealFloat (TValue r a)
instance [overlap ok] (Cmp a b, CallIntrinsic a, Floating a, IsConst a, IsFloating a) => Floating (TValue r a)
instance [overlap ok] (Cmp a b, Fractional a, IsConst a, IsFloating a) => RealFrac (TValue r a)
instance [overlap ok] (Cmp a b, Fractional a, IsConst a, IsFloating a) => Fractional (TValue r a)
instance [overlap ok] (Cmp a b, Num a, IsConst a, IsInteger a) => Integral (TValue r a)
instance [overlap ok] (IsArithmetic a, Cmp a b, Num a, IsConst a) => Real (TValue r a)
instance [overlap ok] (IsArithmetic a, Cmp a b, Num a, IsConst a) => Enum (TValue r a)
instance [overlap ok] (IsArithmetic a, Cmp a b, Num a, IsConst a) => Num (TValue r a)
instance [overlap ok] Ord (TValue r a)
instance [overlap ok] Eq (TValue r a)
instance [overlap ok] Show (TValue r a)
instance [overlap ok] (IsPowerOf2 n) => Cmp (Vector n Word32) (Vector n Bool)
instance [overlap ok] (IsPowerOf2 n) => Cmp (Vector n Float) (Vector n Bool)
instance [overlap ok] Cmp FP128 Bool
instance [overlap ok] Cmp Double Bool
instance [overlap ok] Cmp Float Bool
instance [overlap ok] Cmp Int64 Bool
instance [overlap ok] Cmp Int32 Bool
instance [overlap ok] Cmp Int16 Bool
instance [overlap ok] Cmp Int8 Bool
instance [overlap ok] Cmp Word64 Bool
instance [overlap ok] Cmp Word32 Bool
instance [overlap ok] Cmp Word16 Bool
instance [overlap ok] Cmp Word8 Bool
instance [overlap ok] Cmp Bool Bool

module LLVM.Util.File
writeCodeGenModule :: String -> CodeGenModule a -> IO ()
optimizeFunction :: (IsType t, Translatable t) => CodeGenModule (Function t) -> IO (Function t)
optimizeFunctionCG :: (IsType t, Translatable t) => CodeGenModule (Function t) -> IO t
