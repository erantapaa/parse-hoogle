-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A list-like type for lazy streams, which might terminate with an error.
--   
--   A list-like type for lazy streams, which might terminate with an
--   error.
@package failable-list
@version 0.2


-- | A list-like type for lazy streams, which might terminate with an
--   error.
--   
--   This module uses common names and so is designed to be imported
--   qualified:
--   
--   <pre>
--   import qualified Data.FailableList as FL
--   </pre>
module Data.FailableList

-- | A list-like type for lazy sequences which might terminate with an
--   error.
--   
--   Standard lists can be converted to failable lists using
--   <tt>Prelude.foldr Next Done</tt>.
data FailableList e a
Next :: a -> (FailableList e a) -> FailableList e a
Done :: FailableList e a
Fail :: e -> FailableList e a

-- | Like the standard <a>null</a> function.
null :: FailableList e a -> Bool

-- | Like the standard <a>++</a> function.
append :: FailableList e a -> FailableList e a -> FailableList e a

-- | Like the standard <a>map</a> function.
map :: (a -> b) -> FailableList e a -> FailableList e b

-- | Like the standard <a>map</a> function, but the mapping function may
--   return an error.
mapEither :: (a -> Either e b) -> FailableList e a -> FailableList e b

-- | Like the standard <a>concatMap</a> function.
concatMap :: (a -> FailableList e b) -> FailableList e a -> FailableList e b

-- | Like the standard <a>foldr</a> function, but accepting an extra
--   parameter to handle <a>Fail</a> items.
foldr :: (a -> b -> b) -> b -> (e -> b) -> FailableList e a -> b

-- | Like the standard <a>foldl</a> function, but errors will return a
--   <a>Left</a> value.
foldl :: (b -> a -> b) -> b -> FailableList e a -> Either e b

-- | Like the standard <tt>Data.List.unfoldr</tt> function, but the step
--   function may return an error.
unfoldr :: (b -> Either e (Maybe (a, b))) -> b -> FailableList e a

-- | Like the standard <a>length</a> function; <a>Done</a> and <a>Fail</a>
--   are considered 0-length.
length :: FailableList e a -> Int
instance (Eq e, Eq a) => Eq (FailableList e a)
instance (Show e, Show a) => Show (FailableList e a)
instance MonadFix (FailableList e)
instance Traversable (FailableList e)
instance Foldable (FailableList e)
instance Applicative (FailableList e)
instance Alternative (FailableList e)
instance MonadPlus (FailableList e)
instance Monad (FailableList e)
instance Monoid (FailableList e a)
instance Functor (FailableList e)
