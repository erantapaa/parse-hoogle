-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A driver for RethinkDB 2.0
--   
@package rethinkdb
@version 2.0.0.0

module Database.RethinkDB.Wire
class WireValue a
toWire :: WireValue a => a -> Int
fromWire :: WireValue a => Int -> Maybe a

module Database.RethinkDB.Wire.Term
data TermType
DATUM :: TermType
MAKE_ARRAY :: TermType
MAKE_OBJ :: TermType
VAR :: TermType
JAVASCRIPT :: TermType
UUID :: TermType
HTTP :: TermType
ERROR :: TermType
IMPLICIT_VAR :: TermType
DB :: TermType
TABLE :: TermType
GET :: TermType
GET_ALL :: TermType
EQ :: TermType
NE :: TermType
LT :: TermType
LE :: TermType
GT :: TermType
GE :: TermType
NOT :: TermType
ADD :: TermType
SUB :: TermType
MUL :: TermType
DIV :: TermType
MOD :: TermType
APPEND :: TermType
PREPEND :: TermType
DIFFERENCE :: TermType
SET_INSERT :: TermType
SET_INTERSECTION :: TermType
SET_UNION :: TermType
SET_DIFFERENCE :: TermType
SLICE :: TermType
SKIP :: TermType
LIMIT :: TermType
OFFSETS_OF :: TermType
CONTAINS :: TermType
GET_FIELD :: TermType
KEYS :: TermType
OBJECT :: TermType
HAS_FIELDS :: TermType
WITH_FIELDS :: TermType
PLUCK :: TermType
WITHOUT :: TermType
MERGE :: TermType
BETWEEN_DEPRECATED :: TermType
BETWEEN :: TermType
REDUCE :: TermType
MAP :: TermType
FILTER :: TermType
CONCAT_MAP :: TermType
ORDER_BY :: TermType
DISTINCT :: TermType
COUNT :: TermType
IS_EMPTY :: TermType
UNION :: TermType
NTH :: TermType
BRACKET :: TermType
INNER_JOIN :: TermType
OUTER_JOIN :: TermType
EQ_JOIN :: TermType
ZIP :: TermType
RANGE :: TermType
INSERT_AT :: TermType
DELETE_AT :: TermType
CHANGE_AT :: TermType
SPLICE_AT :: TermType
COERCE_TO :: TermType
TYPE_OF :: TermType
UPDATE :: TermType
DELETE :: TermType
REPLACE :: TermType
INSERT :: TermType
DB_CREATE :: TermType
DB_DROP :: TermType
DB_LIST :: TermType
TABLE_CREATE :: TermType
TABLE_DROP :: TermType
TABLE_LIST :: TermType
CONFIG :: TermType
STATUS :: TermType
WAIT :: TermType
RECONFIGURE :: TermType
REBALANCE :: TermType
SYNC :: TermType
INDEX_CREATE :: TermType
INDEX_DROP :: TermType
INDEX_LIST :: TermType
INDEX_STATUS :: TermType
INDEX_WAIT :: TermType
INDEX_RENAME :: TermType
FUNCALL :: TermType
BRANCH :: TermType
OR :: TermType
AND :: TermType
FOR_EACH :: TermType
FUNC :: TermType
ASC :: TermType
DESC :: TermType
INFO :: TermType
MATCH :: TermType
UPCASE :: TermType
DOWNCASE :: TermType
SAMPLE :: TermType
DEFAULT :: TermType
JSON :: TermType
TO_JSON_STRING :: TermType
ISO8601 :: TermType
TO_ISO8601 :: TermType
EPOCH_TIME :: TermType
TO_EPOCH_TIME :: TermType
NOW :: TermType
IN_TIMEZONE :: TermType
DURING :: TermType
DATE :: TermType
TIME_OF_DAY :: TermType
TIMEZONE :: TermType
YEAR :: TermType
MONTH :: TermType
DAY :: TermType
DAY_OF_WEEK :: TermType
DAY_OF_YEAR :: TermType
HOURS :: TermType
MINUTES :: TermType
SECONDS :: TermType
TIME :: TermType
MONDAY :: TermType
TUESDAY :: TermType
WEDNESDAY :: TermType
THURSDAY :: TermType
FRIDAY :: TermType
SATURDAY :: TermType
SUNDAY :: TermType
JANUARY :: TermType
FEBRUARY :: TermType
MARCH :: TermType
APRIL :: TermType
MAY :: TermType
JUNE :: TermType
JULY :: TermType
AUGUST :: TermType
SEPTEMBER :: TermType
OCTOBER :: TermType
NOVEMBER :: TermType
DECEMBER :: TermType
LITERAL :: TermType
GROUP :: TermType
SUM :: TermType
AVG :: TermType
MIN :: TermType
MAX :: TermType
SPLIT :: TermType
UNGROUP :: TermType
RANDOM :: TermType
CHANGES :: TermType
ARGS :: TermType
BINARY :: TermType
GEOJSON :: TermType
TO_GEOJSON :: TermType
POINT :: TermType
LINE :: TermType
POLYGON :: TermType
DISTANCE :: TermType
INTERSECTS :: TermType
INCLUDES :: TermType
CIRCLE :: TermType
GET_INTERSECTING :: TermType
FILL :: TermType
GET_NEAREST :: TermType
POLYGON_SUB :: TermType
MINVAL :: TermType
MAXVAL :: TermType
instance Eq TermType
instance Show TermType
instance WireValue TermType

module Database.RethinkDB.Wire.Query
data QueryType
START :: QueryType
CONTINUE :: QueryType
STOP :: QueryType
NOREPLY_WAIT :: QueryType
instance Eq QueryType
instance Show QueryType
instance WireValue QueryType

module Database.RethinkDB.Wire.Response
data ResponseType
SUCCESS_ATOM :: ResponseType
SUCCESS_SEQUENCE :: ResponseType
SUCCESS_PARTIAL :: ResponseType
WAIT_COMPLETE :: ResponseType
CLIENT_ERROR :: ResponseType
COMPILE_ERROR :: ResponseType
RUNTIME_ERROR :: ResponseType
data ResponseNote
SEQUENCE_FEED :: ResponseNote
ATOM_FEED :: ResponseNote
ORDER_BY_LIMIT_FEED :: ResponseNote
UNIONED_FEED :: ResponseNote
INCLUDES_STATES :: ResponseNote
instance Eq ResponseType
instance Show ResponseType
instance Eq ResponseNote
instance Show ResponseNote
instance WireValue ResponseNote
instance WireValue ResponseType

module Database.RethinkDB.Wire.VersionDummy
data Version
V0_1 :: Version
V0_2 :: Version
V0_3 :: Version
V0_4 :: Version
data Protocol
PROTOBUF :: Protocol
JSON :: Protocol
instance Eq Version
instance Show Version
instance Eq Protocol
instance Show Protocol
instance WireValue Protocol
instance WireValue Version

module Database.RethinkDB.Wire.Datum
data DatumType
R_NULL :: DatumType
R_BOOL :: DatumType
R_NUM :: DatumType
R_STR :: DatumType
R_ARRAY :: DatumType
R_OBJECT :: DatumType
R_JSON :: DatumType
instance Eq DatumType
instance Show DatumType
instance WireValue DatumType

module Database.RethinkDB.Wire.Frame
data FrameType
POS :: FrameType
OPT :: FrameType
instance Eq FrameType
instance Show FrameType
instance WireValue FrameType

module Database.RethinkDB.Datum

-- | Run a <a>Parser</a>.
parse :: (a -> Parser b) -> a -> Result b

-- | A continuation-based parser type.
data Parser a :: * -> *

-- | The result of running a <a>Parser</a>.
data Result a :: * -> *
Error :: String -> Result a
Success :: a -> Result a

-- | A ReQL value
data Datum
Null :: Datum
Bool :: Bool -> Datum
String :: Text -> Datum
Number :: Double -> Datum
Array :: Array -> Datum
Object :: Object -> Datum
Time :: ZonedTime -> Datum
Point :: LonLat -> Datum
Line :: GeoLine -> Datum
Polygon :: GeoPolygon -> Datum
Binary :: ByteString -> Datum
class ToDatum a where toDatum = toJSONDatum
toDatum :: ToDatum a => a -> Datum
class FromDatum a where parseDatum = parseJSON . toJSON
parseDatum :: FromDatum a => Datum -> Parser a
fromDatum :: FromDatum a => Datum -> Result a
data LonLat
LonLat :: Double -> Double -> LonLat
longitude :: LonLat -> Double
latitude :: LonLat -> Double
type Array = Vector Datum
type Object = HashMap Text Datum
newtype GeoLine
GeoLine :: Vector LonLat -> GeoLine
geoLinePoints :: GeoLine -> Vector LonLat
newtype GeoPolygon
GeoPolygon :: Vector (Vector LonLat) -> GeoPolygon
geoPolygonLines :: GeoPolygon -> Vector (Vector LonLat)
(.=) :: ToDatum a => Text -> a -> (Text, Datum)
(.:) :: FromDatum a => HashMap Text Datum -> Text -> Parser a
(.:?) :: FromDatum a => HashMap Text Datum -> Text -> Parser (Maybe a)
encode :: ToDatum a => a -> ByteString
decode :: FromDatum a => ByteString -> Maybe a
eitherDecode :: FromDatum a => ByteString -> Either String a
resultToMaybe :: Result a -> Maybe a
resultToEither :: Result a -> Either String a
object :: [(Text, Datum)] -> Datum
instance [overlap ok] Eq LonLat
instance [overlap ok] Ord LonLat
instance [overlap ok] Eq GeoPolygon
instance [overlap ok] Ord GeoPolygon
instance [overlap ok] Eq GeoLine
instance [overlap ok] Ord GeoLine
instance [overlap ok] Ord Datum
instance [overlap ok] ToJSON Datum
instance [overlap ok] FromJSON Datum
instance [overlap ok] ToDatum Float
instance [overlap ok] ToDatum Double
instance [overlap ok] ToDatum Bool
instance [overlap ok] ToDatum Text
instance [overlap ok] ToDatum Text
instance [overlap ok] ToDatum Integer
instance [overlap ok] ToDatum [Char]
instance [overlap ok] ToDatum Char
instance [overlap ok] ToDatum Word64
instance [overlap ok] ToDatum Word32
instance [overlap ok] ToDatum Word16
instance [overlap ok] ToDatum Word8
instance [overlap ok] ToDatum Word
instance [overlap ok] ToDatum Int64
instance [overlap ok] ToDatum Int32
instance [overlap ok] ToDatum Int16
instance [overlap ok] ToDatum Int8
instance [overlap ok] ToDatum Int
instance [overlap ok] ToDatum Value
instance [overlap ok] ToDatum LonLat
instance [overlap ok] ToDatum (Ratio Integer)
instance [overlap ok] ToDatum a => ToDatum (Set a)
instance [overlap ok] ToDatum a => ToDatum (Maybe a)
instance [overlap ok] ToDatum ByteString
instance [overlap ok] ToDatum ByteString
instance [overlap ok] (ToDatum a, ToDatum b) => ToDatum (Either a b)
instance [overlap ok] ToDatum UTCTime
instance [overlap ok] ToDatum ZonedTime
instance [overlap ok] ToDatum a => ToDatum (Map [Char] a)
instance [overlap ok] ToDatum a => ToDatum (Map Text a)
instance [overlap ok] ToDatum a => ToDatum (HashMap [Char] a)
instance [overlap ok] ToDatum a => ToDatum (HashMap Text a)
instance [overlap ok] (ToDatum a, ToDatum b, ToDatum c, ToDatum d, ToDatum e) => ToDatum (a, b, c, d, e)
instance [overlap ok] (ToDatum a, ToDatum b, ToDatum c, ToDatum d) => ToDatum (a, b, c, d)
instance [overlap ok] (ToDatum a, ToDatum b, ToDatum c) => ToDatum (a, b, c)
instance [overlap ok] (ToDatum a, ToDatum b) => ToDatum (a, b)
instance [overlap ok] ToDatum ()
instance [overlap ok] ToDatum Datum
instance [overlap ok] ToDatum a => ToDatum (Vector a)
instance [overlap ok] ToDatum a => ToDatum [a]
instance [overlap ok] Show Datum
instance [overlap ok] Show LonLat
instance [overlap ok] Eq Datum
instance [overlap ok] FromDatum (Ratio Integer)
instance [overlap ok] FromDatum Text
instance [overlap ok] FromDatum Text
instance [overlap ok] FromDatum Integer
instance [overlap ok] FromDatum Char
instance [overlap ok] FromDatum Value
instance [overlap ok] FromDatum Bool
instance [overlap ok] FromDatum Double
instance [overlap ok] FromDatum Word64
instance [overlap ok] FromDatum Word32
instance [overlap ok] FromDatum Word16
instance [overlap ok] FromDatum Word8
instance [overlap ok] FromDatum Word
instance [overlap ok] FromDatum Int64
instance [overlap ok] FromDatum Int32
instance [overlap ok] FromDatum Int16
instance [overlap ok] FromDatum Int8
instance [overlap ok] FromDatum Int
instance [overlap ok] FromDatum String
instance [overlap ok] FromDatum Float
instance [overlap ok] FromDatum LonLat
instance [overlap ok] FromDatum GeoPolygon
instance [overlap ok] FromDatum GeoLine
instance [overlap ok] FromDatum a => FromDatum (Vector a)
instance [overlap ok] FromDatum UTCTime
instance [overlap ok] FromDatum ZonedTime
instance [overlap ok] (Ord a, FromDatum a) => FromDatum (Set a)
instance [overlap ok] FromDatum a => FromDatum (Maybe a)
instance [overlap ok] FromDatum a => FromDatum (Map [Char] a)
instance [overlap ok] FromDatum a => FromDatum (Map Text a)
instance [overlap ok] FromDatum a => FromDatum (HashMap [Char] a)
instance [overlap ok] FromDatum a => FromDatum (HashMap Text a)
instance [overlap ok] FromDatum ByteString
instance [overlap ok] FromDatum ByteString
instance [overlap ok] (FromDatum a, FromDatum b) => FromDatum (Either a b)
instance [overlap ok] (FromDatum a, FromDatum b, FromDatum c, FromDatum d, FromDatum e) => FromDatum (a, b, c, d, e)
instance [overlap ok] (FromDatum a, FromDatum b, FromDatum c, FromDatum d) => FromDatum (a, b, c, d)
instance [overlap ok] (FromDatum a, FromDatum b, FromDatum c) => FromDatum (a, b, c)
instance [overlap ok] (FromDatum a, FromDatum b) => FromDatum (a, b)
instance [overlap ok] FromDatum ()
instance [overlap ok] FromDatum Datum
instance [overlap ok] FromDatum a => FromDatum [a]

module Database.RethinkDB.Types

-- | A database, referenced by name
data Database
Database :: Text -> Database
databaseName :: Database -> Text

-- | A table description
data Table
Table :: Maybe Database -> Text -> Maybe Key -> Table

-- | when Nothing, use the connection's database
tableDatabase :: Table -> Maybe Database
tableName :: Table -> Text
tablePrimaryKey :: Table -> Maybe Key
type Key = Text
data Index
PrimaryKey :: Index
Index :: Key -> Index
instance Eq Database
instance Ord Database
instance Eq Table
instance Ord Table
instance IsString Index
instance IsString Table
instance Show Table
instance IsString Database
instance Show Database


-- | Building RQL queries in Haskell
module Database.RethinkDB.ReQL

-- | A ReQL Term
data ReQL
ReQL :: State QuerySettings Term -> ReQL
runReQL :: ReQL -> State QuerySettings Term

-- | Build a term with no optargs
op :: Arr a => TermType -> a -> ReQL

-- | Build a term
op' :: Arr a => TermType -> a -> [Attribute Static] -> ReQL

-- | Internal representation of a ReQL Term
data Term
Term :: TermType -> [Term] -> [TermAttribute] -> Term
termType :: Term -> TermType
termArgs :: Term -> [Term]
termOptArgs :: Term -> [TermAttribute]
Datum :: Datum -> Term
termDatum :: Term -> Datum
Note :: String -> Term -> Term
termNote :: Term -> String
termTerm :: Term -> Term
data TermAttribute
TermAttribute :: Text -> Term -> TermAttribute
buildQuery :: ReQL -> Int64 -> Database -> [(Text, Datum)] -> (WireQuery, Term)
type Backtrace = [Frame]
convertBacktrace :: WireBacktrace -> Backtrace
data Frame
FramePos :: Int -> Frame
FrameOpt :: Text -> Frame

-- | Convert other types into ReQL expressions
class Expr e where expr = datumTerm exprList = expr . arr
expr :: Expr e => e -> ReQL
exprList :: Expr e => [e] -> ReQL

-- | State used to build a Term
data QuerySettings
QuerySettings :: Int64 -> Database -> Int -> Maybe Bool -> QuerySettings
queryToken :: QuerySettings -> Int64
queryDefaultDatabase :: QuerySettings -> Database
queryVarIndex :: QuerySettings -> Int
queryUseOutdated :: QuerySettings -> Maybe Bool
newVarId :: State QuerySettings Int

-- | A shortcut for inserting strings into ReQL expressions Useful when
--   OverloadedStrings makes the type ambiguous
str :: String -> ReQL

-- | A shortcut for inserting numbers into ReQL expressions
num :: Double -> ReQL

-- | A key/value pair used for building objects
data Attribute a
(:=) :: Text -> e -> Attribute a
(::=) :: k -> v -> Attribute Dynamic
NoAttribute :: Attribute a
data Static
data Dynamic
type OptArg = Attribute Static

-- | An operation that accepts optional arguments
class OptArgs a
ex :: OptArgs a => a -> [Attribute Static] -> a
cons :: Expr e => e -> ArgList -> ArgList
baseArray :: ArgList -> State QuerySettings [Term]
withQuerySettings :: (QuerySettings -> ReQL) -> ReQL
reqlToDatum :: ReQL -> Datum

-- | An upper or lower bound for between and during
data Bound a

-- | An inclusive bound
Open :: a -> Bound a
getBound :: Bound a -> a

-- | An exclusive bound
Closed :: a -> Bound a
getBound :: Bound a -> a
DefaultBound :: a -> Bound a
getBound :: Bound a -> a
MinVal :: Bound a
MaxVal :: Bound a
closedOrOpen :: Bound a -> Maybe Text
datumTerm :: ToDatum a => a -> ReQL

-- | An empty object
empty :: ReQL
newtype WireQuery
WireQuery :: Datum -> WireQuery
queryJSON :: WireQuery -> Datum
newtype WireBacktrace
WireBacktrace :: Datum -> WireBacktrace
backtraceJSON :: WireBacktrace -> Datum

-- | Add a note a a ReQL Term
--   
--   This note does not get sent to the server. It is used to annotate
--   backtraces and help debugging.
note :: String -> ReQL -> ReQL
(?:=) :: Expr e => Text -> Maybe e -> Attribute a

-- | Build arrays of exprs
class Arr a
arr :: Arr a => a -> ArgList
minval :: Bound a
maxval :: Bound a
instance Eq Term
instance Eq TermAttribute
instance Show WireQuery
instance Floating ReQL
instance Fractional ReQL
instance (Expr a, Expr b, Expr c, Expr d, Expr e) => Expr (a, b, c, d, e)
instance (Expr a, Expr b, Expr c, Expr d) => Expr (a, b, c, d)
instance (Expr a, Expr b, Expr c) => Expr (a, b, c)
instance (Expr a, Expr b) => Expr (a, b)
instance Num a => Num (Bound a)
instance Functor Bound
instance Expr a => Expr (Bound a)
instance Expr Term
instance Expr ZonedTime
instance Expr UTCTime
instance FromDatum Frame
instance Show Frame
instance Show ReQL
instance (Expr k, Expr v) => Expr (HashMap k v)
instance Expr ArgList
instance Expr a => Expr [a]
instance Expr Database
instance Expr Table
instance (a ~ ReQL, b ~ ReQL, c ~ ReQL, d ~ ReQL, e ~ ReQL) => Expr (a -> b -> c -> d -> e -> ReQL)
instance (a ~ ReQL, b ~ ReQL, c ~ ReQL, d ~ ReQL) => Expr (a -> b -> c -> d -> ReQL)
instance (a ~ ReQL, b ~ ReQL, c ~ ReQL) => Expr (a -> b -> c -> ReQL)
instance (a ~ ReQL, b ~ ReQL) => Expr (a -> b -> ReQL)
instance a ~ ReQL => Expr (a -> ReQL)
instance Expr LonLat
instance Expr (Ratio Integer)
instance Expr Word64
instance Expr Word32
instance Expr Word16
instance Expr Word8
instance Expr Word
instance Expr ByteString
instance Expr ByteString
instance Expr Text
instance Expr Text
instance Expr Int64
instance Expr Int32
instance Expr Int16
instance Expr Int8
instance Expr Float
instance Expr ()
instance Expr Double
instance Expr Datum
instance Expr Bool
instance Expr Integer
instance Expr Int
instance Expr Value
instance Expr a => Expr (Vector a)
instance Expr a => Expr (Set a)
instance Expr a => Expr (Maybe a)
instance Expr a => Expr (Map Text a)
instance Expr a => Expr (Map [Char] a)
instance Expr a => Expr (HashMap Text a)
instance Expr a => Expr (HashMap [Char] a)
instance (Expr a, Expr b) => Expr (Either a b)
instance Expr Char
instance Expr ReQL
instance IsString ReQL
instance Num ReQL
instance Show TermAttribute
instance Expr (Attribute a)
instance Arr ArgList
instance (Expr a, Expr b, Expr c, Expr d) => Arr (a, b, c, d)
instance (Expr a, Expr b, Expr c) => Arr (a, b, c)
instance (Expr a, Expr b) => Arr (a, b)
instance Expr a => Arr [a]
instance Arr ()
instance Monoid ArgList
instance Show Term
instance OptArgs b => OptArgs (a -> b)
instance OptArgs ReQL
instance Default QuerySettings

module Database.RethinkDB.Network

-- | A connection to the database server
data RethinkDBHandle
RethinkDBHandle :: Socket -> MVar (Maybe SomeException) -> IORef Token -> Database -> IORef (Map Token (Chan Response, Term, IO ())) -> ThreadId -> RethinkDBHandle
rdbSocket :: RethinkDBHandle -> Socket
rdbWriteLock :: RethinkDBHandle -> MVar (Maybe SomeException)

-- | The next token to use
rdbToken :: RethinkDBHandle -> IORef Token

-- | The default database
rdbDatabase :: RethinkDBHandle -> Database
rdbWait :: RethinkDBHandle -> IORef (Map Token (Chan Response, Term, IO ()))
rdbThread :: RethinkDBHandle -> ThreadId

-- | Create a new connection to the database server
--   
--   <i>Example:</i> connect using the default port with no passphrase
--   (<i>note:</i> IPv4 and IPv6 supported)
--   
--   <pre>
--   &gt;&gt;&gt; h &lt;- connect "localhost" 28015 Nothing
--   
--   &gt;&gt;&gt; h &lt;- connect "::1" 28015 Nothing
--   </pre>
connect :: HostName -> Integer -> Maybe String -> IO RethinkDBHandle

-- | Close an open connection
close :: RethinkDBHandle -> IO ()

-- | Set the default database
--   
--   The new handle is an alias for the old one. Calling close on either
--   one will close both.
use :: Database -> RethinkDBHandle -> RethinkDBHandle
runQLQuery :: RethinkDBHandle -> WireQuery -> Term -> IO (MVar Response)
data Cursor a
Cursor :: MVar Response -> MVar (Either RethinkDBError ([Datum], Bool)) -> (Datum -> IO a) -> Cursor a
cursorMBox :: Cursor a -> MVar Response
cursorBuffer :: Cursor a -> MVar (Either RethinkDBError ([Datum], Bool))
cursorMap :: Cursor a -> Datum -> IO a
makeCursor :: MVar Response -> IO (Cursor Datum)

-- | Get the next value from a cursor
next :: Cursor a -> IO (Maybe a)

-- | Get the next batch from a cursor
nextBatch :: Cursor a -> IO [a]

-- | A lazy stream of all the elements in the cursor
collect :: Cursor a -> IO [a]

-- | A strict version of collect
collect' :: Cursor a -> IO [a]
nextResponse :: Response -> IO ()

-- | The response to a query
data Response
ResponseError :: RethinkDBError -> Response
ResponseSingle :: Datum -> Response
ResponseBatch :: (Maybe More) -> [Datum] -> Response
data ErrorCode
ErrorBrokenClient :: ErrorCode
ErrorBadQuery :: ErrorCode
ErrorRuntime :: ErrorCode
ErrorUnexpectedResponse :: ErrorCode
data RethinkDBError
RethinkDBError :: ErrorCode -> Term -> String -> Backtrace -> RethinkDBError
errorCode :: RethinkDBError -> ErrorCode
errorTerm :: RethinkDBError -> Term
errorMessage :: RethinkDBError -> String
errorBacktrace :: RethinkDBError -> Backtrace
data RethinkDBConnectionError
RethinkDBConnectionError :: String -> RethinkDBConnectionError
data More

-- | Wait for NoReply queries to complete on the server
--   
--   <pre>
--   &gt;&gt;&gt; () &lt;- runOpts h [NoReply] $ table "users" # get "bob" # update (\row -&gt; merge row ["occupation" := "teacher"])
--   
--   &gt;&gt;&gt; noReplyWait h
--   </pre>
noReplyWait :: RethinkDBHandle -> IO ()
each :: Cursor a -> (a -> IO b) -> IO ()
instance Typeable RethinkDBConnectionError
instance Typeable RethinkDBError
instance Typeable RethinkDBReadError
instance Show RethinkDBConnectionError
instance Show RethinkDBReadError
instance Exception RethinkDBReadError
instance Show Response
instance Show ErrorCode
instance Show RethinkDBError
instance Exception RethinkDBError
instance Exception RethinkDBConnectionError
instance Show RethinkDBHandle
instance Functor Cursor

module Database.RethinkDB.Driver

-- | Run a given query and return a Result
--   
--   <pre>
--   &gt;&gt;&gt; run h $ num 1 :: IO Int
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; run h $ str "foo" :: IO (Either RethinkDBError Int)
--   Left RethinkDB: Unexpected response: "when expecting a Int, encountered String instead"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; run h $ str "foo" :: IO (Maybe Int)
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; run h $ str "foo" :: IO Int
--   *** Exception: RethinkDB: Unexpected response: "when expecting a Int, encountered String instead"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; c &lt;- run h $ table "users" # orderBy [asc "name"] # (!"name"):: IO (Cursor Datum)
--   
--   &gt;&gt;&gt; next c
--   Just "bill"
--   
--   &gt;&gt;&gt; collect c
--   ["nancy","sabrina"]
--   </pre>
run :: (Expr query, Result r) => RethinkDBHandle -> query -> IO r

-- | Run a given query and return a Datum
run' :: Expr query => RethinkDBHandle -> query -> IO Datum

-- | Convert the raw query response into useful values
class Result r where convertResult = unsafeFromDatum <=< convertResult
convertResult :: Result r => MVar Response -> IO r

-- | Run a query with the given options
runOpts :: (Expr query, Result r) => RethinkDBHandle -> [RunFlag] -> query -> IO r

-- | Per-query settings
data RunFlag
UseOutdated :: RunFlag
NoReply :: RunFlag
Durability :: Durability -> RunFlag
Profile :: RunFlag
ArrayLimit :: Int -> RunFlag
data WriteResponse
WriteResponse :: Int -> Int -> Int -> Int -> Int -> Int -> Maybe Text -> Maybe [Text] -> Maybe [Change] -> WriteResponse
writeResponseInserted :: WriteResponse -> Int
writeResponseDeleted :: WriteResponse -> Int
writeResponseReplaced :: WriteResponse -> Int
writeResponseUnchanged :: WriteResponse -> Int
writeResponseSkipped :: WriteResponse -> Int
writeResponseErrors :: WriteResponse -> Int
writeResponseFirstError :: WriteResponse -> Maybe Text
writeResponseGeneratedKeys :: WriteResponse -> Maybe [Text]
writeResponseChanges :: WriteResponse -> Maybe [Change]
data Change
Change :: Datum -> Datum -> Change
oldVal :: Change -> Datum
newVal :: Change -> Datum
instance Show WriteResponse
instance FromDatum WriteResponse
instance FromDatum Change
instance Show Change
instance Result WriteResponse
instance Result Datum
instance (FromDatum a, FromDatum b, FromDatum c, FromDatum d, FromDatum e) => Result (a, b, c, d, e)
instance (FromDatum a, FromDatum b, FromDatum c, FromDatum d) => Result (a, b, c, d)
instance (FromDatum a, FromDatum b, FromDatum c) => Result (a, b, c)
instance (FromDatum a, FromDatum b) => Result (a, b)
instance Result LonLat
instance Result (Ratio Integer)
instance FromDatum a => Result (Map Text a)
instance FromDatum a => Result (Map [Char] a)
instance FromDatum a => Result (HashMap Text a)
instance FromDatum a => Result (HashMap [Char] a)
instance FromDatum a => Result (Vector a)
instance (Ord a, FromDatum a) => Result (Set a)
instance Result UTCTime
instance Result ZonedTime
instance Result Text
instance Result Text
instance Result ByteString
instance Result ByteString
instance Result Integer
instance Result Word64
instance Result Word32
instance Result Word16
instance Result Word8
instance Result Word
instance Result Int64
instance Result Int32
instance Result Int16
instance Result Int8
instance Result Float
instance Result Char
instance Result Value
instance Result ()
instance Result Bool
instance Result Double
instance Result Int
instance FromDatum a => Result (Maybe a)
instance (FromDatum b, a ~ RethinkDBError) => Result (Either a b)
instance FromDatum a => Result [a]
instance FromDatum a => Result (Cursor a)
instance Result Response

module Database.RethinkDB.Time

-- | The time and date when the query is executed
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ now
--   </pre>
now :: ReQL

-- | Build a time object from the year, month, day, hour, minute, second
--   and timezone fields
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ time 2011 12 24 23 59 59 "Z"
--   Time&lt;2011-12-24 23:59:59 +0000&gt;
--   </pre>
time :: ReQL -> ReQL -> ReQL -> ReQL -> ReQL -> ReQL -> ReQL -> ReQL

-- | Build a time object given the number of seconds since the unix epoch
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ epochTime 1147162826
--   Time&lt;2006-05-09 08:20:26 +0000&gt;
--   </pre>
epochTime :: ReQL -> ReQL

-- | Build a time object given an iso8601 string
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ iso8601 "2012-01-07T08:34:00-0700"
--   Time&lt;2012-01-07 08:34:00 -0700&gt;
--   </pre>
iso8601 :: ReQL -> ReQL

-- | The same time in a different timezone
--   
--   <pre>
--   &gt;&gt;&gt; _ &lt;- run' h $ inTimezone "+0800" now
--   </pre>
inTimezone :: Expr time => ReQL -> time -> ReQL

-- | Test if a time is between two other times
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ during (Open $ now R.- (60*60)) (Closed now) $ epochTime 1382919271
--   false
--   </pre>
during :: (Expr left, Expr right, Expr time) => Bound left -> Bound right -> time -> ReQL

-- | Extract part of a time value
timezone :: Expr time => time -> ReQL

-- | Extract part of a time value
seconds :: Expr time => time -> ReQL

-- | Extract part of a time value
minutes :: Expr time => time -> ReQL

-- | Extract part of a time value
hours :: Expr time => time -> ReQL

-- | Extract part of a time value
dayOfYear :: Expr time => time -> ReQL

-- | Extract part of a time value
dayOfWeek :: Expr time => time -> ReQL

-- | Extract part of a time value
day :: Expr time => time -> ReQL

-- | Extract part of a time value
month :: Expr time => time -> ReQL

-- | Extract part of a time value
year :: Expr time => time -> ReQL

-- | Extract part of a time value
timeOfDay :: Expr time => time -> ReQL

-- | Extract part of a time value
date :: Expr time => time -> ReQL

-- | Convert a time to another representation
toIso8601 :: Expr t => t -> ReQL

-- | Convert a time to another representation
toEpochTime :: Expr t => t -> ReQL

module Database.RethinkDB.Geospatial

-- | Convert a line object into a polygon
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ fill $ line [[-122,37], [-120,39], [-121,38]]
--   Polygon&lt;[[-122,37],[-120,39],[-121,38],[-122,37]]&gt;
--   </pre>
fill :: Expr line => line -> ReQL

-- | Convert a GeoJSON object into a RethinkDB geometry object
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ geoJSON ["type" := "Point", "coordinates" := [-45,80]]
--   Point&lt;-45,80&gt;
--   </pre>
geoJSON :: Expr geojson => geojson -> ReQL

-- | Convert a RethinkDB geometry object into a GeoJSON object
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ toGeoJSON $ point (-122.423246) 37.779388
--   {"coordinates":[-122.423246,37.779388],"type":"Point"}
--   </pre>
toGeoJSON :: Expr geo => geo -> ReQL

-- | Search a geospatial index for intersecting objects
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "places" # getIntersecting (point (-122) 37) (Index "geo")
--   []
--   </pre>
getIntersecting :: (Expr geo, Expr table) => geo -> Index -> table -> ReQL

-- | Query a geospatial index for the nearest matches
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "places" # getNearest (point (-122) 37) (Index "location")
--   []
--   
--   &gt;&gt;&gt; run' h $ table "places" # ex getNearest [maxResults 5, maxDist 10, unit Kilometer] (point (-122) 37) (Index "location")
--   []
--   </pre>
getNearest :: (Expr point, Expr table) => point -> Index -> table -> ReQL

-- | Test whether a geometry object includes another
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ circle (point (-122) 37) 5000 # includes (point (-120) 48)
--   false
--   </pre>
includes :: (Expr area, Expr geo) => geo -> area -> ReQL

-- | Test if two geometry objects intersects
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ intersects (line [[-122,37],[-120,48]]) (line [[-120,49],[-122,48]])
--   false
--   </pre>
intersects :: (Expr a, Expr b) => a -> b -> ReQL

-- | Create a line object
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ line [[-73,45],[-122,37]]
--   Line&lt;[-73,45],[-122,37]&gt;
--   </pre>
line :: Expr points => points -> ReQL

-- | Create a point objects
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ point (-73) 40
--   Point&lt;-73,40&gt;
--   </pre>
point :: (Expr longitude, Expr latitude) => longitude -> latitude -> ReQL

-- | Create a polygon object
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ polygon [[-73,45],[-122,37],[-73,40]]
--   Polygon&lt;[[-73,45],[-122,37],[-73,40],[-73,45]]&gt;
--   </pre>
polygon :: Expr points => points -> ReQL

-- | Punch a hole in a polygon
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ (polygon [[-73,45],[-122,37],[-73,40]]) # polygonSub (polygon [[-73.2,40.1],[-73.2,40.2],[-73.3,40.1]])
--   Polygon&lt;[[-73,45],[-122,37],[-73,40],[-73,45]],[[-73.2,40.1],[-73.2,40.2],[-73.3,40.1],[-73.2,40.1]]&gt;
--   </pre>
polygonSub :: (Expr polygon, Expr hole) => hole -> polygon -> ReQL

-- | Create a polygon approximating a circle
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ ex circle [numVertices 6, unit Kilometer] (point (-73) 40) 100
--   Polygon&lt;[[-73,39.099310036015424],[-74.00751390838496,39.54527799206398],[-74.02083610406069,40.445812561599965],[-73,40.900549591978255],[-71.97916389593931,40.445812561599965],[-71.99248609161504,39.54527799206398],[-73,39.099310036015424]]&gt;
--   </pre>
circle :: (Expr point, Expr radius) => point -> radius -> ReQL

-- | Distance between a point and another geometry object
--   
--   <pre>
--   run' h $ distance (point (-73) 40) (point (-122) 37)
--   </pre>
--   
--   <ol>
--   <li>467303546 &gt; run' h $ ex distance [unit Mile] (point (-73) 40)
--   (point (-122) 37)</li>
--   <li>5460282596796</li>
--   </ol>
distance :: (Expr a, Expr b) => a -> b -> ReQL

-- | Optional argument for getNearest
maxResults :: ReQL -> Attribute a

-- | Optional argument for getNearest
maxDist :: ReQL -> Attribute a

-- | Optional argument for getNearest, circle and distance
unit :: Unit -> Attribute a

-- | Optional argument for circle
numVertices :: ReQL -> Attribute a
data Unit
Meter :: Unit
Kilometer :: Unit
Mile :: Unit
NauticalMile :: Unit
Foot :: Unit
instance Expr Unit


-- | ReQL Functions
--   
--   ReQL was designed for dynamic languages. Many operations take optional
--   positional and named arguments.
--   
--   Optional named arguments can be added using <a>ex</a>, for example
--   `upsert = ex insert ["conflict" := "update"]`
--   
--   For optional positional arguments this module defines an extra
--   function if the functionality is not available otherwise. For example
--   <a>argmax</a> for <a>max</a> and <a>splitOn</a> for <a>split</a> but
--   <a>skip</a> instead of <tt>sliceFrom</tt> and `avg . (!k)` instead of
--   `avgOf k`.
module Database.RethinkDB.Functions

-- | Create a table on the server
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ tableCreate (table "posts") def
--   [{"created":1}]
--   &gt;&gt;&gt; run' h $ tableCreate (table "users"){ tablePrimaryKey = Just "name" } def
--   [{"created":1}]
--   &gt;&gt;&gt; run' h $ tableCreate (Table (Just "doctests") "bar" (Just "name")) def
--   [{"created":1}]
--   &gt;&gt;&gt; run' h $ ex tableCreate ["datacenter":="orion"] (Table (Just "doctests") "bar" (Just "name")) def
--   [{"created":1}]
--   </pre>
tableCreate :: Table -> ReQL

-- | Insert a document or a list of documents into a table
--   
--   <pre>
--   &gt;&gt;&gt; run h $ table "users" # insert (map (\x -&gt; ["name":=x]) ["bill", "bob", "nancy" :: Text]) :: IO WriteResponse
--   {inserted:3}
--   
--   &gt;&gt;&gt; run h $ table "posts" # insert ["author" := str "bill", "message" := str "hi", "id" := 1] :: IO WriteResponse
--   {inserted:1}
--   
--   &gt;&gt;&gt; run h $ table "posts" # insert ["author" := str "bill", "message" := str "hello", "id" := 2, "flag" := str "deleted"] :: IO WriteResponse
--   {inserted:1}
--   
--   &gt;&gt;&gt; run h $ table "posts" # insert ["author" := str "bob", "message" := str "lorem ipsum", "id" := 3, "flag" := str "pinned"] :: IO WriteResponse
--   {inserted:1}
--   </pre>
insert :: Expr object => object -> Table -> ReQL

-- | Add to or modify the contents of a document
--   
--   <pre>
--   &gt;&gt;&gt; run h $ table "users" # getAll "name" [str "bob"] # update (const ["occupation" := str "tailor"]) :: IO WriteResponse
--   {replaced:1}
--   </pre>
update :: (Expr selection, Expr a) => (ReQL -> a) -> selection -> ReQL

-- | Replace a document with another
--   
--   <pre>
--   &gt;&gt;&gt; run h $ replace (\user -&gt; ["name" := user!"name", "occupation" := str "clothier"]) . R.filter ((R.== str "tailor") . (!?"occupation")) $ table "users" :: IO WriteResponse
--   {replaced:1}
--   </pre>
replace :: (Expr selection, Expr a) => (ReQL -> a) -> selection -> ReQL

-- | Delete the documents
--   
--   <pre>
--   &gt;&gt;&gt; run h $ delete . getAll "name" [str "bob"] $ table "users" :: IO WriteResponse
--   {deleted:1}
--   </pre>
delete :: Expr selection => selection -> ReQL

-- | Like map but for write queries
--   
--   <pre>
--   &gt;&gt;&gt; _ &lt;- run' h $ table "users" # replace (without ["post_count"])
--   
--   &gt;&gt;&gt; run h $ forEach (\user -&gt; table "users" # get (user!"name") # ex update [nonAtomic] (const ["post_count" := R.count (table "posts" # R.filter (\post -&gt; post!"author" R.== user!"name"))])) (table "users") :: IO WriteResponse
--   {replaced:2}
--   </pre>
forEach :: (Expr a, Expr s) => (ReQL -> a) -> s -> ReQL

-- | A table
--   
--   <pre>
--   &gt;&gt;&gt; fmap sort $ run h $ table "users" :: IO [Datum]
--   [{"post_count":2,"name":"bill"},{"post_count":0,"name":"nancy"}]
--   </pre>
table :: Text -> Table

-- | Drop a table
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ tableDrop (table "foo")
--   {"config_changes":[{"new_val":null,"old_val":{"primary_key":"id","write_acks":"majority","durability":"hard","name":"foo","shards":...,"id":...,"db":"doctests"}}],"tables_dropped":1}
--   </pre>
tableDrop :: Table -> ReQL

-- | List the tables in a database
--   
--   <pre>
--   &gt;&gt;&gt; fmap sort $ run h $ tableList (db "doctests") :: IO [String]
--   ["places","posts","users"]
--   </pre>
tableList :: Database -> ReQL

-- | Addition or concatenation
--   
--   Use the Num instance, or a qualified operator.
--   
--   <pre>
--   &gt;&gt;&gt; run h $ 2 + 5
--   7
--   
--   &gt;&gt;&gt; run h $ str "foo" R.+ str "bar"
--   "foobar"
--   </pre>
(+) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Subtraction
--   
--   <pre>
--   &gt;&gt;&gt; run h $ 2 - 5
--   -3
--   </pre>
(-) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Multiplication
--   
--   <pre>
--   &gt;&gt;&gt; run h $ 2 * 5
--   10
--   </pre>
(*) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Division
--   
--   <pre>
--   &gt;&gt;&gt; run h $ 2 R./ 5
--   0.4
--   </pre>
(/) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Mod
--   
--   <pre>
--   &gt;&gt;&gt; run h $ 5 `mod` 2
--   1
--   </pre>
mod :: (Expr a, Expr b) => a -> b -> ReQL

-- | Boolean or
--   
--   <pre>
--   &gt;&gt;&gt; run h $ True R.|| False
--   true
--   </pre>
(||) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Boolean and
--   
--   <pre>
--   &gt;&gt;&gt; run h $ True R.&amp;&amp; False
--   false
--   </pre>
(&&) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Test for equality
--   
--   <pre>
--   &gt;&gt;&gt; run h $ ["a" := 1] R.== ["a" := 1]
--   true
--   </pre>
(==) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Test for inequality
--   
--   <pre>
--   &gt;&gt;&gt; run h $ 1 R./= False
--   true
--   </pre>
(/=) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Greater than
--   
--   <pre>
--   &gt;&gt;&gt; run h $ 3 R.&gt; 2
--   true
--   </pre>
(>) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Lesser than
--   
--   <pre>
--   &gt;&gt;&gt; run h $ (str "a") R.&lt; (str "b")
--   true
--   </pre>
(<) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Greater than or equal to
--   
--   <pre>
--   &gt;&gt;&gt; run h $ [1] R.&gt;= Null
--   false
--   </pre>
(>=) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Lesser than or equal to
--   
--   <pre>
--   &gt;&gt;&gt; run h $ 2 R.&lt;= 2
--   true
--   </pre>
(<=) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Negation
--   
--   <pre>
--   &gt;&gt;&gt; run h $ R.not False
--   true
--   
--   &gt;&gt;&gt; run h $ R.not Null
--   true
--   </pre>
not :: Expr a => a -> ReQL

-- | The size of a sequence or an array.
--   
--   <pre>
--   &gt;&gt;&gt; run h $ count (table "users")
--   2
--   </pre>
count :: Expr a => a -> ReQL

-- | Join two sequences.
--   
--   <pre>
--   &gt;&gt;&gt; run h $ [1,2,3] `union` ["a", "b", "c" :: Text]
--   [1,2,3,"a","b","c"]
--   </pre>
union :: (Expr a, Expr b) => a -> b -> ReQL

-- | Map a function over a sequence
--   
--   <pre>
--   &gt;&gt;&gt; run h $ R.map (!"a") [["a" := 1], ["a" := 2]]
--   [1,2]
--   </pre>
map :: (Expr a, Expr b) => (ReQL -> b) -> a -> ReQL

-- | Filter a sequence given a predicate
--   
--   <pre>
--   &gt;&gt;&gt; run h $ R.filter (R.&lt; 4) [3, 1, 4, 1, 5, 9, 2, 6]
--   [3,1,1,2]
--   </pre>
filter :: (Expr predicate, Expr seq) => predicate -> seq -> ReQL

-- | Query all the documents whose value for the given index is in a given
--   range
--   
--   <pre>
--   &gt;&gt;&gt; run h $ table "users" # between "name" (Closed $ str "a") (Open $ str "c")
--   [{"post_count":2,"name":"bill"}]
--   </pre>
between :: (Expr left, Expr right, Expr seq) => Index -> Bound left -> Bound right -> seq -> ReQL

-- | Append a datum to a sequence
--   
--   <pre>
--   &gt;&gt;&gt; run h $ append 3 [1, 2]
--   [1,2,3]
--   </pre>
append :: (Expr a, Expr b) => a -> b -> ReQL

-- | Map a function of a sequence and concat the results
--   
--   <pre>
--   &gt;&gt;&gt; run h $ concatMap id [[1, 2], [3], [4, 5]]
--   [1,2,3,4,5]
--   </pre>
concatMap :: (Expr a, Expr b) => (ReQL -> b) -> a -> ReQL

-- | SQL-like inner join of two sequences
--   
--   <pre>
--   &gt;&gt;&gt; sorted $ run' h $ innerJoin (\user post -&gt; user!"name" R.== post!"author") (table "users") (table "posts") # R.zip # orderBy [asc "id"] # pluck ["name", "message"]
--   [{"name":"bill","message":"hello"},{"name":"bill","message":"hi"}]
--   </pre>
innerJoin :: (Expr a, Expr b, Expr c) => (ReQL -> ReQL -> c) -> a -> b -> ReQL

-- | SQL-like outer join of two sequences
--   
--   <pre>
--   &gt;&gt;&gt; sorted $ run' h $ outerJoin (\user post -&gt; user!"name" R.== post!"author") (table "users") (table "posts") # R.zip # orderBy [asc "id", asc "name"] # pluck ["name", "message"]
--   [{"name":"bill","message":"hello"},{"name":"bill","message":"hi"},{"name":"nancy"}]
--   </pre>
outerJoin :: (Expr a, Expr b, Expr c) => (ReQL -> ReQL -> c) -> a -> b -> ReQL

-- | An efficient inner_join that uses a key for the left table and an
--   index for the right table.
--   
--   <pre>
--   &gt;&gt;&gt; sorted $ run' h $ table "posts" # eqJoin "author" (table "users") "name" # R.zip # orderBy [asc "id"] # pluck ["name", "message"]
--   [{"name":"bill","message":"hello"},{"name":"bill","message":"hi"}]
--   </pre>
eqJoin :: (Expr fun, Expr right, Expr left) => fun -> right -> Index -> left -> ReQL

-- | Drop elements from the head of a sequence.
--   
--   <pre>
--   &gt;&gt;&gt; run h $ skip 2 [1, 2, 3, 4]
--   [3,4]
--   </pre>
skip :: (Expr n, Expr seq) => n -> seq -> ReQL

-- | Limit the size of a sequence.
--   
--   <pre>
--   &gt;&gt;&gt; run h $ limit 2 [1, 2, 3, 4]
--   [1,2]
--   </pre>
limit :: (Expr n, Expr seq) => n -> seq -> ReQL

-- | Cut out part of a sequence
--   
--   <pre>
--   &gt;&gt;&gt; run h $ slice 2 4 [1, 2, 3, 4, 5]
--   [3,4]
--   </pre>
slice :: (Expr a, Expr b, Expr c) => a -> b -> c -> ReQL

-- | Reduce a sequence to a single value
--   
--   <pre>
--   &gt;&gt;&gt; run h $ reduce0 (+) 0 [1, 2, 3]
--   6
--   </pre>
reduce0 :: (Expr base, Expr seq, Expr a) => (ReQL -> ReQL -> a) -> base -> seq -> ReQL

-- | Reduce a non-empty sequence to a single value
--   
--   <pre>
--   &gt;&gt;&gt; run h $ reduce (+) [1, 2, 3]
--   6
--   </pre>
reduce :: (Expr a, Expr s) => (ReQL -> ReQL -> a) -> s -> ReQL

-- | Filter out identical elements of the sequence
--   
--   <pre>
--   &gt;&gt;&gt; fmap sort $ run h $ distinct (table "posts" ! "flag") :: IO [String]
--   ["deleted","pinned"]
--   </pre>
distinct :: Expr s => s -> ReQL

-- | Merge the "left" and "right" attributes of the objects in a sequence.
--   
--   <pre>
--   &gt;&gt;&gt; fmap sort $ run h $ table "posts" # eqJoin "author" (table "users") "name" # R.zip :: IO [Datum]
--   [{"post_count":2,"flag":"deleted","name":"bill","author":"bill","id":2,"message":"hello"},{"post_count":2,"name":"bill","author":"bill","id":1,"message":"hi"}]
--   </pre>
zip :: Expr a => a -> ReQL

-- | Order a sequence by the given keys
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "users" # orderBy [desc "post_count", asc "name"] # pluck ["name", "post_count"]
--   [{"post_count":2,"name":"bill"},{"post_count":0,"name":"nancy"}]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "users" # ex orderBy ["index":="name"] [] # pluck ["name"]
--   [{"name":"bill"},{"name":"nancy"}]
--   </pre>
orderBy :: Expr s => [ReQL] -> s -> ReQL

-- | Ascending order
asc :: ReQL -> ReQL

-- | Descending order
desc :: ReQL -> ReQL

-- | Turn a grouping function and a reduction function into a grouped map
--   reduce operation
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "posts" # orderBy [asc "id"] # group (!"author") (reduce (\a b -&gt; a + "\n" + b) . R.map (!"message"))
--   [{"group":"bill","reduction":"hi\nhello"},{"group":"bob","reduction":"lorem ipsum"}]
--   
--   &gt;&gt;&gt; run' h $ table "users" # group ((!0) . splitOn "" . (!"name")) (\users -&gt; let pc = users!"post_count" in [avg pc, R.sum pc])
--   [{"group":"b","reduction":[2,2]},{"group":"n","reduction":[0,0]}]
--   </pre>
group :: (Expr group, Expr reduction, Expr seq) => (ReQL -> group) -> (ReQL -> reduction) -> seq -> ReQL

-- | Rewrite multiple reductions into a single map/reduce operation
mapReduce :: (Expr reduction, Expr seq) => (ReQL -> reduction) -> seq -> ReQL

-- | The sum of a sequence
--   
--   <pre>
--   &gt;&gt;&gt; run h $ sum [1, 2, 3]
--   6
--   </pre>
sum :: Expr s => s -> ReQL

-- | The average of a sequence
--   
--   <pre>
--   &gt;&gt;&gt; run h $ avg [1, 2, 3, 4]
--   2.5
--   </pre>
avg :: Expr s => s -> ReQL

-- | Minimum value
min :: Expr s => s -> ReQL

-- | Value that minimizes the function
argmin :: (Expr s, Expr a) => (ReQL -> a) -> s -> ReQL

-- | Minimum value
max :: Expr s => s -> ReQL

-- | Value that maximizes the function
argmax :: (Expr s, Expr a) => (ReQL -> a) -> s -> ReQL

-- | Get a single field from an object or an element of an array
--   
--   <pre>
--   &gt;&gt;&gt; run h $ ["foo" := True] ! "foo"
--   true
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; run h $ [1, 2, 3] ! 0
--   1
--   </pre>
--   
--   Or a single field from each object in a sequence
--   
--   <pre>
--   &gt;&gt;&gt; run h $ [["foo" := True], ["foo" := False]] ! "foo"
--   [true,false]
--   </pre>
(!) :: Expr s => s -> ReQL -> ReQL

-- | Get a single field, or null if not present
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ empty !? "foo"
--   null
--   </pre>
(!?) :: Expr s => s -> ReQL -> ReQL

-- | Keep only the given attributes
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ [["a" := 1, "b" := 2], ["a" := 2, "c" := 7], ["b" := 4]] # pluck ["a"]
--   [{"a":1},{"a":2},{}]
--   </pre>
pluck :: Expr o => [ReQL] -> o -> ReQL

-- | Remove the given attributes from an object
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ [["a" := 1, "b" := 2], ["a" := 2, "c" := 7], ["b" := 4]] # without ["a"]
--   [{"b":2},{"c":7},{"b":4}]
--   </pre>
without :: Expr o => [ReQL] -> o -> ReQL

-- | Test if a sequence contains a given element
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ [1,2,3] # contains 1
--   true
--   </pre>
contains :: (Expr x, Expr seq) => x -> seq -> ReQL

-- | Merge two objects together
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ merge ["a" := 1, "b" := 1] ["b" := 1, "c" := 2]
--   {"a":1,"b":1,"c":2}
--   </pre>
merge :: (Expr a, Expr b) => a -> b -> ReQL

-- | Literal objects, in a merge or update, are not processed recursively.
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ ["a" := ["b" := 1]] # merge ["a" := literal ["c" := 2]]
--   {"a":{"c":2}}
--   </pre>
literal :: Expr a => a -> ReQL

-- | Remove fields when doing a merge or update
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ ["a" := ["b" := 1]] # merge ["a" := remove]
--   {}
--   </pre>
remove :: ReQL

-- | Evaluate a JavaScript expression
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ js "Math.PI"
--   3.141592653589793
--   
--   &gt;&gt;&gt; let r_sin x = js "Math.sin" `apply` [x]
--   
--   &gt;&gt;&gt; run h $ R.map r_sin [pi, pi/2]
--   [1.2246...,1]
--   </pre>
js :: ReQL -> ReQL

-- | Server-side if
--   
--   <pre>
--   &gt;&gt;&gt; run h $ branch (1 R.&lt; 2) 3 4
--   3
--   </pre>
branch :: (Expr a, Expr b, Expr c) => a -> b -> c -> ReQL

-- | Abort the query with an error
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ R.error (str "haha") R./ 2 + 1
--   *** Exception: RethinkDB: Runtime error: "haha"
--     in add(div({- HERE -} error("haha"), 2), 1)
--   </pre>
error :: Expr s => s -> ReQL

-- | Create a Database reference
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ db "test" # info
--   {"name":"test","id":...,"type":"DB"}
--   </pre>
db :: Text -> Database

-- | Create a database on the server
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ dbCreate "dev"
--   {"config_changes":[{"new_val":{"name":"dev","id":...},"old_val":null}],"dbs_created":1}
--   </pre>
dbCreate :: Text -> ReQL

-- | Drop a database
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ dbDrop (db "dev")
--   {"config_changes":[{"new_val":null,"old_val":{"name":"dev","id":...}}],"tables_dropped":0,"dbs_dropped":1}
--   </pre>
dbDrop :: Database -> ReQL

-- | List the databases on the server
--   
--   <pre>
--   &gt;&gt;&gt; _ &lt;- run' h $ dbList
--   </pre>
dbList :: ReQL

-- | Create an index on the table from the given function
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "users" # indexCreate "occupation" (!"occupation")
--   {"created":1}
--   
--   &gt;&gt;&gt; run' h $ table "users" # ex indexCreate ["multi":=True] "friends" (!"friends")
--   {"created":1}
--   
--   &gt;&gt;&gt; run' h $ table "users" # ex indexCreate ["geo":=True] "location" (!"location")
--   {"created":1}
--   </pre>
indexCreate :: Expr fun => Text -> fun -> Table -> ReQL

-- | Get the status of the given indexes
--   
--   <pre>
--   run' h $ table "users" # indexStatus []
--   </pre>
indexStatus :: Expr table => [ReQL] -> table -> ReQL

-- | Wait for an index to be built
--   
--   <pre>
--   run' h $ table "users" # indexWait []
--   </pre>
indexWait :: Expr table => [ReQL] -> table -> ReQL
indexRename :: Expr table => ReQL -> ReQL -> table -> ReQL

-- | Ensures that writes on a given table are written to permanent storage
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ sync (table "users")
--   {"synced":1}
--   </pre>
sync :: Expr table => table -> ReQL

-- | List the indexes on the table
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ indexList (table "users")
--   ["friends","location","occupation"]
--   </pre>
indexList :: Table -> ReQL

-- | Drop an index
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "users" # indexDrop "occupation"
--   {"dropped":1}
--   </pre>
indexDrop :: Key -> Table -> ReQL

-- | Retreive documents by their indexed value
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "users" # getAll PrimaryKey [str "bill"]
--   [{"post_count":2,"name":"bill"}]
--   </pre>
getAll :: Expr values => Index -> values -> Table -> ReQL

-- | Get a document by primary key
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "users" # get "nancy"
--   {"post_count":0,"name":"nancy"}
--   </pre>
get :: Expr s => ReQL -> s -> ReQL

-- | Convert a value to a different type
--   
--   <pre>
--   &gt;&gt;&gt; run h $ coerceTo "STRING" 1
--   "1"
--   </pre>
coerceTo :: Expr x => ReQL -> x -> ReQL

-- | Convert a value to an array
--   
--   <pre>
--   &gt;&gt;&gt; run h $ asArray $ ["a" := 1, "b" := 2] :: IO [(String, Int)]
--   [("a",1),("b",2)]
--   </pre>
asArray :: Expr x => x -> ReQL

-- | Convert a value to a string
--   
--   <pre>
--   &gt;&gt;&gt; run h $ asString $ ["a" := 1, "b" := 2]
--   "{\n\t\"a\":\t1,\n\t\"b\":\t2\n}"
--   </pre>
asString :: Expr x => x -> ReQL

-- | Convert a value to a number
--   
--   <pre>
--   &gt;&gt;&gt; run h $ asNumber (str "34")
--   34
--   </pre>
asNumber :: Expr x => x -> ReQL

-- | Convert a value to an object
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ asObject $ [(str "a",1),("b",2)]
--   {"a":1,"b":2}
--   </pre>
asObject :: Expr x => x -> ReQL

-- | Convert a value to a boolean
asBool :: Expr x => x -> ReQL

-- | Like hasFields followed by pluck
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ [["a" := 1, "b" := 2], ["a" := 2, "c" := 7], ["b" := 4]] # withFields ["a"]
--   [{"a":1},{"a":2}]
--   </pre>
withFields :: Expr seq => [ReQL] -> seq -> ReQL

-- | The position in the sequence of the elements that match the predicate
--   
--   <pre>
--   &gt;&gt;&gt; run h $ indexesOf (match "ba.") [str "foo", "bar", "baz"]
--   [1,2]
--   </pre>
indexesOf :: (Expr fun, Expr seq) => fun -> seq -> ReQL

-- | Test if a sequence is empty
--   
--   <pre>
--   &gt;&gt;&gt; run h $ isEmpty [1]
--   false
--   </pre>
isEmpty :: Expr seq => seq -> ReQL

-- | Select a given number of elements from a sequence with uniform random
--   distribution
--   
--   <pre>
--   &gt;&gt;&gt; _ &lt;- run' h $ sample 3 [0,1,2,3,4,5,6,7,8,9]
--   </pre>
sample :: (Expr n, Expr seq) => n -> seq -> ReQL

-- | Prepend an element to an array
--   
--   <pre>
--   &gt;&gt;&gt; run h $ prepend 1 [2,3]
--   [1,2,3]
--   </pre>
prepend :: (Expr datum, Expr array) => datum -> array -> ReQL

-- | The different of two lists
--   
--   <pre>
--   &gt;&gt;&gt; run h $ [1,2,3,4,5] # difference [2,5]
--   [1,3,4]
--   </pre>
difference :: (Expr a, Expr b) => a -> b -> ReQL

-- | Insert a datum into an array if it is not yet present
--   
--   <pre>
--   &gt;&gt;&gt; run h $ setInsert 3 [1,2,4,4,5]
--   [1,2,4,5,3]
--   </pre>
setInsert :: (Expr datum, Expr array) => datum -> array -> ReQL

-- | The union of two sets
--   
--   <pre>
--   &gt;&gt;&gt; run h $ [1,2] `setUnion` [2,3]
--   [2,3,1]
--   </pre>
setUnion :: (Expr a, Expr b) => a -> b -> ReQL

-- | The intersection of two sets
--   
--   <pre>
--   &gt;&gt;&gt; run h $ [1,2] `setIntersection` [2,3]
--   [2]
--   </pre>
setIntersection :: (Expr a, Expr b) => a -> b -> ReQL

-- | The difference of two sets
--   
--   <pre>
--   &gt;&gt;&gt; run h $ [2,3] # setDifference [1,2]
--   [3]
--   </pre>
setDifference :: (Expr set, Expr remove) => remove -> set -> ReQL

-- | Test if an object has the given fields
--   
--   <pre>
--   &gt;&gt;&gt; run h $ hasFields "a" $ ["a" := 1]
--   true
--   </pre>
hasFields :: Expr obj => ReQL -> obj -> ReQL

-- | Insert a datum at the given position in an array
--   
--   <pre>
--   &gt;&gt;&gt; run h $ insertAt 1 4 [1,2,3]
--   [1,4,2,3]
--   </pre>
insertAt :: (Expr n, Expr datum, Expr array) => n -> datum -> array -> ReQL

-- | Splice an array at a given position inside another array
--   
--   <pre>
--   &gt;&gt;&gt; run h $ spliceAt 2 [4,5] [1,2,3]
--   [1,2,4,5,3]
--   </pre>
spliceAt :: (Expr n, Expr replace, Expr array) => n -> replace -> array -> ReQL

-- | Delete an element from an array
--   
--   <pre>
--   &gt;&gt;&gt; run h $ deleteAt 1 [1,2,3]
--   [1,3]
--   </pre>
deleteAt :: (Expr n, Expr array) => n -> array -> ReQL

-- | Change an element in an array
--   
--   <pre>
--   &gt;&gt;&gt; run h $ changeAt 1 4 [1,2,3]
--   [1,4,3]
--   </pre>
changeAt :: (Expr n, Expr datum, Expr array) => n -> datum -> array -> ReQL

-- | The list of keys of the given object
--   
--   <pre>
--   &gt;&gt;&gt; run h $ keys ["a" := 1, "b" := 2]
--   ["a","b"]
--   </pre>
keys :: Expr object => object -> ReQL

-- | Match a string to a regular expression.
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ str "foobar" # match "f(.)+[bc](.+)"
--   {"groups":[{"start":2,"end":3,"str":"o"},{"start":4,"end":6,"str":"ar"}],"start":0,"end":6,"str":"foobar"}
--   </pre>
match :: Expr string => ReQL -> string -> ReQL

-- | Apply a function to a list of arguments.
--   
--   Called <i>do</i> in the official drivers
--   
--   <pre>
--   &gt;&gt;&gt; run h $ (\x -&gt; x R.* 2) `apply` [4]
--   8
--   </pre>
apply :: (Expr fun, Expr arg) => fun -> [arg] -> ReQL

-- | Catch some expections inside the query.
--   
--   Called <i>default</i> in the official drivers
--   
--   <pre>
--   &gt;&gt;&gt; run h $ R.handle (const 0) $ ["a" := 1] ! "b"
--   0
--   
--   &gt;&gt;&gt; run h $ R.handle (expr . id) $ ["a" := 1] ! "b"
--   "No attribute `b` in object:\n{\n\t\"a\":\t1\n}"
--   </pre>
handle :: (Expr instead, Expr reql) => (ReQL -> instead) -> reql -> ReQL

-- | A string representing the type of an expression
--   
--   <pre>
--   &gt;&gt;&gt; run h $ typeOf 1
--   "NUMBER"
--   </pre>
typeOf :: Expr a => a -> ReQL

-- | Get information on a given expression. Useful for tables and
--   databases.
--   
--   <pre>
--   &gt;&gt;&gt; run h $ info $ table "users"
--   {"primary_key":"name","doc_count_estimates":...,"name":"users","id":...,"indexes":["friends","location"],"type":"TABLE","db":{"name":"doctests","id":...,"type":"DB"}}
--   </pre>
info :: Expr a => a -> ReQL

-- | Parse a json string into an object
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ json "{\"a\":1}"
--   {"a":1}
--   </pre>
json :: ReQL -> ReQL

-- | Flipped function application
(#) :: (Expr a, Expr b) => a -> (a -> b) -> ReQL

-- | Convert to upper case
--   
--   <pre>
--   &gt;&gt;&gt; run h $ upcase (str "Foo")
--   "FOO"
--   </pre>
upcase :: Expr str => str -> ReQL

-- | Convert to lower case
--   
--   <pre>
--   &gt;&gt;&gt; run h $ downcase (str "Foo")
--   "foo"
--   </pre>
downcase :: Expr str => str -> ReQL

-- | Split a string on whitespace characters
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ split (str "foo bar")
--   ["foo","bar"]
--   </pre>
split :: Expr str => str -> ReQL

-- | Split a string on a given delimiter
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ str "foo, bar" # splitOn ","
--   ["foo"," bar"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ str "foo" # splitOn ""
--   ["f","o","o"]
--   </pre>
splitOn :: Expr str => ReQL -> str -> ReQL

-- | Split a string up to a given number of times
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ str "a:b:c:d" # splitMax ":" 2
--   ["a","b","c:d"]
--   </pre>
splitMax :: Expr str => ReQL -> ReQL -> str -> ReQL

-- | A random float between 0 and 1
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ (\x -&gt; x R.&lt; 1 R.&amp;&amp; x R.&gt;= 0) `apply` [random]
--   true
--   </pre>
random :: ReQL

-- | A random number between 0 and n
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ (\x -&gt; x R.&lt; 10 R.&amp;&amp; x R.&gt;= 0) `apply` [randomTo 10]
--   true
--   </pre>
randomTo :: ReQL -> ReQL

-- | A random number between 0 and n
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ (\x -&gt; x R.&lt; 10 R.&amp;&amp; x R.&gt;= 5) `apply` [randomFromTo 5 10]
--   true
--   </pre>
randomFromTo :: ReQL -> ReQL -> ReQL
data HttpOptions
HttpOptions :: Maybe Int -> Maybe Int -> Maybe Int -> Maybe Bool -> Maybe HttpResultFormat -> Maybe HttpMethod -> Maybe [Attribute Dynamic] -> Maybe [Attribute Dynamic] -> Maybe [Attribute Dynamic] -> Maybe ReQL -> Maybe PaginationStrategy -> Maybe Int -> HttpOptions
httpTimeout :: HttpOptions -> Maybe Int
httpReattempts :: HttpOptions -> Maybe Int
httpRedirects :: HttpOptions -> Maybe Int
httpVerify :: HttpOptions -> Maybe Bool
httpResultFormat :: HttpOptions -> Maybe HttpResultFormat
httpMethod :: HttpOptions -> Maybe HttpMethod
httpAuth :: HttpOptions -> Maybe [Attribute Dynamic]
httpParams :: HttpOptions -> Maybe [Attribute Dynamic]
httpHeader :: HttpOptions -> Maybe [Attribute Dynamic]
httpData :: HttpOptions -> Maybe ReQL
httpPage :: HttpOptions -> Maybe PaginationStrategy
httpPageLimit :: HttpOptions -> Maybe Int
data HttpResultFormat
FormatAuto :: HttpResultFormat
FormatJSON :: HttpResultFormat
FormatJSONP :: HttpResultFormat
FormatBinary :: HttpResultFormat
data HttpMethod
GET :: HttpMethod
POST :: HttpMethod
PUT :: HttpMethod
PATCH :: HttpMethod
DELETE :: HttpMethod
HEAD :: HttpMethod
data PaginationStrategy
LinkNext :: PaginationStrategy
PaginationFunction :: (ReQL -> ReQL) -> PaginationStrategy

-- | Retrieve data from the specified URL over HTTP
--   
--   <pre>
--   &gt;&gt;&gt; _ &lt;- run' h $ http "http://httpbin.org/get" def{ httpParams = Just ["foo" := 1] }
--   
--   &gt;&gt;&gt; _ &lt;- run' h $ http "http://httpbin.org/put" def{ httpMethod = Just PUT, httpData = Just $ expr ["foo" := "bar"] }
--   </pre>
http :: Expr url => url -> HttpOptions -> ReQL

-- | Splice a list of values into an argument list
args :: Expr array => array -> ReQL

-- | Return an infinite stream of objects representing changes to a table
--   
--   <pre>
--   &gt;&gt;&gt; cursor &lt;- run h $ table "posts" # changes :: IO (Cursor Datum)
--   
--   &gt;&gt;&gt; run h $ table "posts" # insert ["author" := "bill", "message" := "bye", "id" := 4] :: IO WriteResponse
--   {inserted:1}
--   
--   &gt;&gt;&gt; next cursor
--   Just {"new_val":{"author":"bill","id":4,"message":"bye"},"old_val":null}
--   </pre>
changes :: Expr seq => seq -> ReQL

-- | Optional argument for returning an array of objects describing the
--   changes made
--   
--   <pre>
--   &gt;&gt;&gt; run h $ table "users" # ex insert [returnChanges] ["name" := "sabrina"] :: IO WriteResponse
--   {inserted:1,changes:[{"old_val":null,"new_val":{"name":"sabrina"}}]}
--   </pre>
returnChanges :: Attribute a

-- | Optional argument for changes
includeStates :: Attribute a
data Durability
Hard :: Durability
Soft :: Durability

-- | Optional argument for soft durability writes
durability :: Durability -> Attribute a

-- | Optional argument for non-atomic writes
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "users" # get "sabrina" # update (merge ["lucky_number" := random])
--   *** Exception: RethinkDB: Runtime error: "Could not prove function deterministic.  Maybe you want to use the non_atomic flag?"
--     in
--       {- HERE -}
--       update(
--         get(table(db("doctests"), "users"), "sabrina"),
--         (\b -&gt; merge(b, {lucky_number: random()})))
--   
--   &gt;&gt;&gt; run h $ table "users" # get "sabrina" # ex update [nonAtomic] (merge ["lucky_number" := random]) :: IO WriteResponse
--   {replaced:1}
--   </pre>
nonAtomic :: Attribute a
data ConflictResolution
Error :: ConflictResolution
Replace :: ConflictResolution
Update :: ConflictResolution
conflict :: ConflictResolution -> Attribute a

-- | Generate a UUID
--   
--   <pre>
--   &gt;&gt;&gt; run h uuid
--   "...-...-...-..."
--   </pre>
uuid :: ReQL

-- | Generate numbers starting from 0
--   
--   <pre>
--   &gt;&gt;&gt; run h $ range 10
--   [0,1,2,3,4,5,6,7,8,9]
--   </pre>
range :: ReQL -> ReQL

-- | Generate numbers within a range
--   
--   <pre>
--   &gt;&gt;&gt; run h $ rangeFromTo 2 4
--   [2,3]
--   </pre>
rangeFromTo :: ReQL -> ReQL -> ReQL

-- | Generate numbers starting from 0
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ rangeAll # limit 4
--   [0,1,2,3]
--   </pre>
rangeAll :: ReQL

-- | Wait for tables to be ready
--   
--   <pre>
--   &gt;&gt;&gt; run h $ table "users" # wait
--   {"ready":1,"status_changes":[{"new_val":{"status":{"all_replicas_ready":true,"ready_for_outdated_reads":true,"ready_for_writes":true,"ready_for_reads":true},"name":"users","shards":...,"id":...,"db":"doctests"},"old_val":...}]}
--   </pre>
wait :: Expr table => table -> ReQL

-- | Convert an object or value to a JSON string
--   
--   <pre>
--   &gt;&gt;&gt; run h $ toJSON "a"
--   "\"a\""
--   </pre>
toJSON :: Expr a => a -> ReQL

-- | Map over two sequences
--   
--   <pre>
--   &gt;&gt;&gt; run h $ zipWith (+) [1,2] [3,4]
--   [4,6]
--   </pre>
zipWith :: (Expr left, Expr right, Expr b) => (ReQL -> ReQL -> b) -> left -> right -> ReQL

-- | Map over multiple sequences
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ zipWithN (\a b c -&gt; expr $ a + b * c) [[1,2],[3,4],[5,6]]
--   [16,26]
--   </pre>
zipWithN :: (Arr a, Expr f) => f -> a -> ReQL

-- | Change a table's configuration
--   
--   <pre>
--   &gt;&gt;&gt; run h $ table "users" # reconfigure 2 1
--   {"config_changes":[{"new_val":{"primary_key":"name","write_acks":"majority","durability":"hard","name":"users","shards":...,"id":...,"db":"doctests"},"old_val":...}],"reconfigured":1,"status_changes":[{"new_val":{"status":{"all_replicas_ready":...,"ready_for_outdated_reads":...,"ready_for_writes":...,"ready_for_reads":...},"name":"users","shards":...,"id":...,"db":"doctests"},"old_val":...}]}
--   </pre>
reconfigure :: (Expr table, Expr replicas) => ReQL -> replicas -> table -> ReQL

-- | Rebalance a table's shards
--   
--   <pre>
--   &gt;&gt;&gt; run h $ table "users" # rebalance
--   {"rebalanced":1,"status_changes":[{"new_val":{"status":{"all_replicas_ready":...,"ready_for_outdated_reads":...,"ready_for_writes":...,"ready_for_reads":...},"name":"users","shards":...,"id":...,"db":"doctests"},"old_val":...}]}
--   </pre>
rebalance :: Expr table => table -> ReQL

-- | Get the config for a table or database
--   
--   <pre>
--   &gt;&gt;&gt; run h $ table "users" # config
--   {"primary_key":"name","write_acks":"majority","durability":"hard","name":"users","shards":...,"id":...,"db":"doctests"}
--   </pre>
config :: Expr table => table -> ReQL

-- | Get the status of a table
--   
--   <pre>
--   &gt;&gt;&gt; run h $ table "users" # status
--   {"status":{"all_replicas_ready":true,"ready_for_outdated_reads":true,"ready_for_writes":true,"ready_for_reads":true},"name":"users","shards":...,"id":...,"db":"doctests"}
--   </pre>
status :: Expr table => table -> ReQL
instance Show HttpMethod
instance Expr ConflictResolution
instance Expr Durability
instance Default HttpOptions
instance Expr PaginationStrategy
instance Expr HttpMethod
instance Expr HttpResultFormat


-- | Haskell client driver for RethinkDB
--   
--   Based upon the official Javascript, Python and Ruby API:
--   <a>http://www.rethinkdb.com/api/</a>
--   
--   <i>How to use</i>
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   import qualified Database.RethinkDB as R
--   import qualified Database.RethinkDB.NoClash
--   </pre>
module Database.RethinkDB

-- | Create a new connection to the database server
--   
--   <i>Example:</i> connect using the default port with no passphrase
--   (<i>note:</i> IPv4 and IPv6 supported)
--   
--   <pre>
--   &gt;&gt;&gt; h &lt;- connect "localhost" 28015 Nothing
--   
--   &gt;&gt;&gt; h &lt;- connect "::1" 28015 Nothing
--   </pre>
connect :: HostName -> Integer -> Maybe String -> IO RethinkDBHandle

-- | A connection to the database server
data RethinkDBHandle

-- | Close an open connection
close :: RethinkDBHandle -> IO ()

-- | Set the default database
--   
--   The new handle is an alias for the old one. Calling close on either
--   one will close both.
use :: Database -> RethinkDBHandle -> RethinkDBHandle

-- | Run a given query and return a Result
--   
--   <pre>
--   &gt;&gt;&gt; run h $ num 1 :: IO Int
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; run h $ str "foo" :: IO (Either RethinkDBError Int)
--   Left RethinkDB: Unexpected response: "when expecting a Int, encountered String instead"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; run h $ str "foo" :: IO (Maybe Int)
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; run h $ str "foo" :: IO Int
--   *** Exception: RethinkDB: Unexpected response: "when expecting a Int, encountered String instead"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; c &lt;- run h $ table "users" # orderBy [asc "name"] # (!"name"):: IO (Cursor Datum)
--   
--   &gt;&gt;&gt; next c
--   Just "bill"
--   
--   &gt;&gt;&gt; collect c
--   ["nancy","sabrina"]
--   </pre>
run :: (Expr query, Result r) => RethinkDBHandle -> query -> IO r

-- | Run a given query and return a Datum
run' :: Expr query => RethinkDBHandle -> query -> IO Datum

-- | Run a query with the given options
runOpts :: (Expr query, Result r) => RethinkDBHandle -> [RunFlag] -> query -> IO r

-- | A ReQL Term
data ReQL

-- | A ReQL value
data Datum
Null :: Datum
Bool :: Bool -> Datum
String :: Text -> Datum
Number :: Double -> Datum
Array :: Array -> Datum
Object :: Object -> Datum
Time :: ZonedTime -> Datum
Point :: LonLat -> Datum
Line :: GeoLine -> Datum
Polygon :: GeoPolygon -> Datum
Binary :: ByteString -> Datum
class ToDatum a where toDatum = toJSONDatum
toDatum :: ToDatum a => a -> Datum
class FromDatum a where parseDatum = parseJSON . toJSON
parseDatum :: FromDatum a => Datum -> Parser a
fromDatum :: FromDatum a => Datum -> Result a

-- | Per-query settings
data RunFlag
UseOutdated :: RunFlag
NoReply :: RunFlag
Durability :: Durability -> RunFlag
Profile :: RunFlag
ArrayLimit :: Int -> RunFlag

-- | Wait for NoReply queries to complete on the server
--   
--   <pre>
--   &gt;&gt;&gt; () &lt;- runOpts h [NoReply] $ table "users" # get "bob" # update (\row -&gt; merge row ["occupation" := "teacher"])
--   
--   &gt;&gt;&gt; noReplyWait h
--   </pre>
noReplyWait :: RethinkDBHandle -> IO ()
data RethinkDBError
RethinkDBError :: ErrorCode -> Term -> String -> Backtrace -> RethinkDBError
errorCode :: RethinkDBError -> ErrorCode
errorTerm :: RethinkDBError -> Term
errorMessage :: RethinkDBError -> String
errorBacktrace :: RethinkDBError -> Backtrace
data ErrorCode
ErrorBrokenClient :: ErrorCode
ErrorBadQuery :: ErrorCode
ErrorRuntime :: ErrorCode
ErrorUnexpectedResponse :: ErrorCode

-- | The response to a query
data Response

-- | Convert the raw query response into useful values
class Result r where convertResult = unsafeFromDatum <=< convertResult
convertResult :: Result r => MVar Response -> IO r

-- | Get the next value from a cursor
next :: Cursor a -> IO (Maybe a)

-- | A lazy stream of all the elements in the cursor
collect :: Cursor a -> IO [a]

-- | A strict version of collect
collect' :: Cursor a -> IO [a]
each :: Cursor a -> (a -> IO b) -> IO ()
data Cursor a

-- | A database, referenced by name
data Database
Database :: Text -> Database
databaseName :: Database -> Text

-- | Create a database on the server
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ dbCreate "dev"
--   {"config_changes":[{"new_val":{"name":"dev","id":...},"old_val":null}],"dbs_created":1}
--   </pre>
dbCreate :: Text -> ReQL

-- | Drop a database
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ dbDrop (db "dev")
--   {"config_changes":[{"new_val":null,"old_val":{"name":"dev","id":...}}],"tables_dropped":0,"dbs_dropped":1}
--   </pre>
dbDrop :: Database -> ReQL

-- | List the databases on the server
--   
--   <pre>
--   &gt;&gt;&gt; _ &lt;- run' h $ dbList
--   </pre>
dbList :: ReQL

-- | A table description
data Table
Table :: Maybe Database -> Text -> Maybe Key -> Table

-- | when Nothing, use the connection's database
tableDatabase :: Table -> Maybe Database
tableName :: Table -> Text
tablePrimaryKey :: Table -> Maybe Key

-- | Create a table on the server
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ tableCreate (table "posts") def
--   [{"created":1}]
--   &gt;&gt;&gt; run' h $ tableCreate (table "users"){ tablePrimaryKey = Just "name" } def
--   [{"created":1}]
--   &gt;&gt;&gt; run' h $ tableCreate (Table (Just "doctests") "bar" (Just "name")) def
--   [{"created":1}]
--   &gt;&gt;&gt; run' h $ ex tableCreate ["datacenter":="orion"] (Table (Just "doctests") "bar" (Just "name")) def
--   [{"created":1}]
--   </pre>
tableCreate :: Table -> ReQL

-- | Drop a table
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ tableDrop (table "foo")
--   {"config_changes":[{"new_val":null,"old_val":{"primary_key":"id","write_acks":"majority","durability":"hard","name":"foo","shards":...,"id":...,"db":"doctests"}}],"tables_dropped":1}
--   </pre>
tableDrop :: Table -> ReQL

-- | List the tables in a database
--   
--   <pre>
--   &gt;&gt;&gt; fmap sort $ run h $ tableList (db "doctests") :: IO [String]
--   ["places","posts","users"]
--   </pre>
tableList :: Database -> ReQL

-- | Create an index on the table from the given function
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "users" # indexCreate "occupation" (!"occupation")
--   {"created":1}
--   
--   &gt;&gt;&gt; run' h $ table "users" # ex indexCreate ["multi":=True] "friends" (!"friends")
--   {"created":1}
--   
--   &gt;&gt;&gt; run' h $ table "users" # ex indexCreate ["geo":=True] "location" (!"location")
--   {"created":1}
--   </pre>
indexCreate :: Expr fun => Text -> fun -> Table -> ReQL

-- | Drop an index
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "users" # indexDrop "occupation"
--   {"dropped":1}
--   </pre>
indexDrop :: Key -> Table -> ReQL

-- | List the indexes on the table
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ indexList (table "users")
--   ["friends","location","occupation"]
--   </pre>
indexList :: Table -> ReQL
indexRename :: Expr table => ReQL -> ReQL -> table -> ReQL

-- | Get the status of the given indexes
--   
--   <pre>
--   run' h $ table "users" # indexStatus []
--   </pre>
indexStatus :: Expr table => [ReQL] -> table -> ReQL

-- | Wait for an index to be built
--   
--   <pre>
--   run' h $ table "users" # indexWait []
--   </pre>
indexWait :: Expr table => [ReQL] -> table -> ReQL

-- | Return an infinite stream of objects representing changes to a table
--   
--   <pre>
--   &gt;&gt;&gt; cursor &lt;- run h $ table "posts" # changes :: IO (Cursor Datum)
--   
--   &gt;&gt;&gt; run h $ table "posts" # insert ["author" := "bill", "message" := "bye", "id" := 4] :: IO WriteResponse
--   {inserted:1}
--   
--   &gt;&gt;&gt; next cursor
--   Just {"new_val":{"author":"bill","id":4,"message":"bye"},"old_val":null}
--   </pre>
changes :: Expr seq => seq -> ReQL
data WriteResponse
WriteResponse :: Int -> Int -> Int -> Int -> Int -> Int -> Maybe Text -> Maybe [Text] -> Maybe [Change] -> WriteResponse
writeResponseInserted :: WriteResponse -> Int
writeResponseDeleted :: WriteResponse -> Int
writeResponseReplaced :: WriteResponse -> Int
writeResponseUnchanged :: WriteResponse -> Int
writeResponseSkipped :: WriteResponse -> Int
writeResponseErrors :: WriteResponse -> Int
writeResponseFirstError :: WriteResponse -> Maybe Text
writeResponseGeneratedKeys :: WriteResponse -> Maybe [Text]
writeResponseChanges :: WriteResponse -> Maybe [Change]
data Change
Change :: Datum -> Datum -> Change
oldVal :: Change -> Datum
newVal :: Change -> Datum

-- | Insert a document or a list of documents into a table
--   
--   <pre>
--   &gt;&gt;&gt; run h $ table "users" # insert (map (\x -&gt; ["name":=x]) ["bill", "bob", "nancy" :: Text]) :: IO WriteResponse
--   {inserted:3}
--   
--   &gt;&gt;&gt; run h $ table "posts" # insert ["author" := str "bill", "message" := str "hi", "id" := 1] :: IO WriteResponse
--   {inserted:1}
--   
--   &gt;&gt;&gt; run h $ table "posts" # insert ["author" := str "bill", "message" := str "hello", "id" := 2, "flag" := str "deleted"] :: IO WriteResponse
--   {inserted:1}
--   
--   &gt;&gt;&gt; run h $ table "posts" # insert ["author" := str "bob", "message" := str "lorem ipsum", "id" := 3, "flag" := str "pinned"] :: IO WriteResponse
--   {inserted:1}
--   </pre>
insert :: Expr object => object -> Table -> ReQL

-- | Add to or modify the contents of a document
--   
--   <pre>
--   &gt;&gt;&gt; run h $ table "users" # getAll "name" [str "bob"] # update (const ["occupation" := str "tailor"]) :: IO WriteResponse
--   {replaced:1}
--   </pre>
update :: (Expr selection, Expr a) => (ReQL -> a) -> selection -> ReQL

-- | Replace a document with another
--   
--   <pre>
--   &gt;&gt;&gt; run h $ replace (\user -&gt; ["name" := user!"name", "occupation" := str "clothier"]) . R.filter ((R.== str "tailor") . (!?"occupation")) $ table "users" :: IO WriteResponse
--   {replaced:1}
--   </pre>
replace :: (Expr selection, Expr a) => (ReQL -> a) -> selection -> ReQL

-- | Delete the documents
--   
--   <pre>
--   &gt;&gt;&gt; run h $ delete . getAll "name" [str "bob"] $ table "users" :: IO WriteResponse
--   {deleted:1}
--   </pre>
delete :: Expr selection => selection -> ReQL

-- | Ensures that writes on a given table are written to permanent storage
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ sync (table "users")
--   {"synced":1}
--   </pre>
sync :: Expr table => table -> ReQL

-- | Optional argument for returning an array of objects describing the
--   changes made
--   
--   <pre>
--   &gt;&gt;&gt; run h $ table "users" # ex insert [returnChanges] ["name" := "sabrina"] :: IO WriteResponse
--   {inserted:1,changes:[{"old_val":null,"new_val":{"name":"sabrina"}}]}
--   </pre>
returnChanges :: Attribute a

-- | Optional argument for non-atomic writes
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "users" # get "sabrina" # update (merge ["lucky_number" := random])
--   *** Exception: RethinkDB: Runtime error: "Could not prove function deterministic.  Maybe you want to use the non_atomic flag?"
--     in
--       {- HERE -}
--       update(
--         get(table(db("doctests"), "users"), "sabrina"),
--         (\b -&gt; merge(b, {lucky_number: random()})))
--   
--   &gt;&gt;&gt; run h $ table "users" # get "sabrina" # ex update [nonAtomic] (merge ["lucky_number" := random]) :: IO WriteResponse
--   {replaced:1}
--   </pre>
nonAtomic :: Attribute a

-- | Optional argument for soft durability writes
durability :: Durability -> Attribute a
data Durability
conflict :: ConflictResolution -> Attribute a
data ConflictResolution
Error :: ConflictResolution
Replace :: ConflictResolution
Update :: ConflictResolution

-- | Create a Database reference
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ db "test" # info
--   {"name":"test","id":...,"type":"DB"}
--   </pre>
db :: Text -> Database

-- | A table
--   
--   <pre>
--   &gt;&gt;&gt; fmap sort $ run h $ table "users" :: IO [Datum]
--   [{"post_count":2,"name":"bill"},{"post_count":0,"name":"nancy"}]
--   </pre>
table :: Text -> Table

-- | Get a document by primary key
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "users" # get "nancy"
--   {"post_count":0,"name":"nancy"}
--   </pre>
get :: Expr s => ReQL -> s -> ReQL

-- | Retreive documents by their indexed value
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "users" # getAll PrimaryKey [str "bill"]
--   [{"post_count":2,"name":"bill"}]
--   </pre>
getAll :: Expr values => Index -> values -> Table -> ReQL

-- | Filter a sequence given a predicate
--   
--   <pre>
--   &gt;&gt;&gt; run h $ R.filter (R.&lt; 4) [3, 1, 4, 1, 5, 9, 2, 6]
--   [3,1,1,2]
--   </pre>
filter :: (Expr predicate, Expr seq) => predicate -> seq -> ReQL

-- | Query all the documents whose value for the given index is in a given
--   range
--   
--   <pre>
--   &gt;&gt;&gt; run h $ table "users" # between "name" (Closed $ str "a") (Open $ str "c")
--   [{"post_count":2,"name":"bill"}]
--   </pre>
between :: (Expr left, Expr right, Expr seq) => Index -> Bound left -> Bound right -> seq -> ReQL
minval :: Bound a
maxval :: Bound a

-- | An upper or lower bound for between and during
data Bound a

-- | An inclusive bound
Open :: a -> Bound a
getBound :: Bound a -> a

-- | An exclusive bound
Closed :: a -> Bound a
getBound :: Bound a -> a
DefaultBound :: a -> Bound a
getBound :: Bound a -> a
MinVal :: Bound a
MaxVal :: Bound a

-- | SQL-like inner join of two sequences
--   
--   <pre>
--   &gt;&gt;&gt; sorted $ run' h $ innerJoin (\user post -&gt; user!"name" R.== post!"author") (table "users") (table "posts") # R.zip # orderBy [asc "id"] # pluck ["name", "message"]
--   [{"name":"bill","message":"hello"},{"name":"bill","message":"hi"}]
--   </pre>
innerJoin :: (Expr a, Expr b, Expr c) => (ReQL -> ReQL -> c) -> a -> b -> ReQL

-- | SQL-like outer join of two sequences
--   
--   <pre>
--   &gt;&gt;&gt; sorted $ run' h $ outerJoin (\user post -&gt; user!"name" R.== post!"author") (table "users") (table "posts") # R.zip # orderBy [asc "id", asc "name"] # pluck ["name", "message"]
--   [{"name":"bill","message":"hello"},{"name":"bill","message":"hi"},{"name":"nancy"}]
--   </pre>
outerJoin :: (Expr a, Expr b, Expr c) => (ReQL -> ReQL -> c) -> a -> b -> ReQL

-- | An efficient inner_join that uses a key for the left table and an
--   index for the right table.
--   
--   <pre>
--   &gt;&gt;&gt; sorted $ run' h $ table "posts" # eqJoin "author" (table "users") "name" # R.zip # orderBy [asc "id"] # pluck ["name", "message"]
--   [{"name":"bill","message":"hello"},{"name":"bill","message":"hi"}]
--   </pre>
eqJoin :: (Expr fun, Expr right, Expr left) => fun -> right -> Index -> left -> ReQL

-- | Merge the "left" and "right" attributes of the objects in a sequence.
--   
--   <pre>
--   &gt;&gt;&gt; fmap sort $ run h $ table "posts" # eqJoin "author" (table "users") "name" # R.zip :: IO [Datum]
--   [{"post_count":2,"flag":"deleted","name":"bill","author":"bill","id":2,"message":"hello"},{"post_count":2,"name":"bill","author":"bill","id":1,"message":"hi"}]
--   </pre>
zip :: Expr a => a -> ReQL
data Index
PrimaryKey :: Index
Index :: Key -> Index

-- | Map a function over a sequence
--   
--   <pre>
--   &gt;&gt;&gt; run h $ R.map (!"a") [["a" := 1], ["a" := 2]]
--   [1,2]
--   </pre>
map :: (Expr a, Expr b) => (ReQL -> b) -> a -> ReQL

-- | Map over two sequences
--   
--   <pre>
--   &gt;&gt;&gt; run h $ zipWith (+) [1,2] [3,4]
--   [4,6]
--   </pre>
zipWith :: (Expr left, Expr right, Expr b) => (ReQL -> ReQL -> b) -> left -> right -> ReQL

-- | Map over multiple sequences
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ zipWithN (\a b c -&gt; expr $ a + b * c) [[1,2],[3,4],[5,6]]
--   [16,26]
--   </pre>
zipWithN :: (Arr a, Expr f) => f -> a -> ReQL

-- | Like hasFields followed by pluck
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ [["a" := 1, "b" := 2], ["a" := 2, "c" := 7], ["b" := 4]] # withFields ["a"]
--   [{"a":1},{"a":2}]
--   </pre>
withFields :: Expr seq => [ReQL] -> seq -> ReQL

-- | Map a function of a sequence and concat the results
--   
--   <pre>
--   &gt;&gt;&gt; run h $ concatMap id [[1, 2], [3], [4, 5]]
--   [1,2,3,4,5]
--   </pre>
concatMap :: (Expr a, Expr b) => (ReQL -> b) -> a -> ReQL

-- | Order a sequence by the given keys
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "users" # orderBy [desc "post_count", asc "name"] # pluck ["name", "post_count"]
--   [{"post_count":2,"name":"bill"},{"post_count":0,"name":"nancy"}]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "users" # ex orderBy ["index":="name"] [] # pluck ["name"]
--   [{"name":"bill"},{"name":"nancy"}]
--   </pre>
orderBy :: Expr s => [ReQL] -> s -> ReQL

-- | Ascending order
asc :: ReQL -> ReQL

-- | Descending order
desc :: ReQL -> ReQL

-- | Drop elements from the head of a sequence.
--   
--   <pre>
--   &gt;&gt;&gt; run h $ skip 2 [1, 2, 3, 4]
--   [3,4]
--   </pre>
skip :: (Expr n, Expr seq) => n -> seq -> ReQL

-- | Limit the size of a sequence.
--   
--   <pre>
--   &gt;&gt;&gt; run h $ limit 2 [1, 2, 3, 4]
--   [1,2]
--   </pre>
limit :: (Expr n, Expr seq) => n -> seq -> ReQL

-- | Cut out part of a sequence
--   
--   <pre>
--   &gt;&gt;&gt; run h $ slice 2 4 [1, 2, 3, 4, 5]
--   [3,4]
--   </pre>
slice :: (Expr a, Expr b, Expr c) => a -> b -> c -> ReQL

-- | The position in the sequence of the elements that match the predicate
--   
--   <pre>
--   &gt;&gt;&gt; run h $ indexesOf (match "ba.") [str "foo", "bar", "baz"]
--   [1,2]
--   </pre>
indexesOf :: (Expr fun, Expr seq) => fun -> seq -> ReQL

-- | Test if a sequence is empty
--   
--   <pre>
--   &gt;&gt;&gt; run h $ isEmpty [1]
--   false
--   </pre>
isEmpty :: Expr seq => seq -> ReQL

-- | Join two sequences.
--   
--   <pre>
--   &gt;&gt;&gt; run h $ [1,2,3] `union` ["a", "b", "c" :: Text]
--   [1,2,3,"a","b","c"]
--   </pre>
union :: (Expr a, Expr b) => a -> b -> ReQL

-- | Select a given number of elements from a sequence with uniform random
--   distribution
--   
--   <pre>
--   &gt;&gt;&gt; _ &lt;- run' h $ sample 3 [0,1,2,3,4,5,6,7,8,9]
--   </pre>
sample :: (Expr n, Expr seq) => n -> seq -> ReQL

-- | Turn a grouping function and a reduction function into a grouped map
--   reduce operation
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "posts" # orderBy [asc "id"] # group (!"author") (reduce (\a b -&gt; a + "\n" + b) . R.map (!"message"))
--   [{"group":"bill","reduction":"hi\nhello"},{"group":"bob","reduction":"lorem ipsum"}]
--   
--   &gt;&gt;&gt; run' h $ table "users" # group ((!0) . splitOn "" . (!"name")) (\users -&gt; let pc = users!"post_count" in [avg pc, R.sum pc])
--   [{"group":"b","reduction":[2,2]},{"group":"n","reduction":[0,0]}]
--   </pre>
group :: (Expr group, Expr reduction, Expr seq) => (ReQL -> group) -> (ReQL -> reduction) -> seq -> ReQL

-- | Reduce a non-empty sequence to a single value
--   
--   <pre>
--   &gt;&gt;&gt; run h $ reduce (+) [1, 2, 3]
--   6
--   </pre>
reduce :: (Expr a, Expr s) => (ReQL -> ReQL -> a) -> s -> ReQL

-- | Reduce a sequence to a single value
--   
--   <pre>
--   &gt;&gt;&gt; run h $ reduce0 (+) 0 [1, 2, 3]
--   6
--   </pre>
reduce0 :: (Expr base, Expr seq, Expr a) => (ReQL -> ReQL -> a) -> base -> seq -> ReQL

-- | Filter out identical elements of the sequence
--   
--   <pre>
--   &gt;&gt;&gt; fmap sort $ run h $ distinct (table "posts" ! "flag") :: IO [String]
--   ["deleted","pinned"]
--   </pre>
distinct :: Expr s => s -> ReQL

-- | Test if a sequence contains a given element
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ [1,2,3] # contains 1
--   true
--   </pre>
contains :: (Expr x, Expr seq) => x -> seq -> ReQL

-- | Rewrite multiple reductions into a single map/reduce operation
mapReduce :: (Expr reduction, Expr seq) => (ReQL -> reduction) -> seq -> ReQL

-- | The size of a sequence or an array.
--   
--   <pre>
--   &gt;&gt;&gt; run h $ count (table "users")
--   2
--   </pre>
count :: Expr a => a -> ReQL

-- | The sum of a sequence
--   
--   <pre>
--   &gt;&gt;&gt; run h $ sum [1, 2, 3]
--   6
--   </pre>
sum :: Expr s => s -> ReQL

-- | The average of a sequence
--   
--   <pre>
--   &gt;&gt;&gt; run h $ avg [1, 2, 3, 4]
--   2.5
--   </pre>
avg :: Expr s => s -> ReQL

-- | Minimum value
min :: Expr s => s -> ReQL

-- | Minimum value
max :: Expr s => s -> ReQL

-- | Value that minimizes the function
argmin :: (Expr s, Expr a) => (ReQL -> a) -> s -> ReQL

-- | Value that maximizes the function
argmax :: (Expr s, Expr a) => (ReQL -> a) -> s -> ReQL

-- | Keep only the given attributes
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ [["a" := 1, "b" := 2], ["a" := 2, "c" := 7], ["b" := 4]] # pluck ["a"]
--   [{"a":1},{"a":2},{}]
--   </pre>
pluck :: Expr o => [ReQL] -> o -> ReQL

-- | Remove the given attributes from an object
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ [["a" := 1, "b" := 2], ["a" := 2, "c" := 7], ["b" := 4]] # without ["a"]
--   [{"b":2},{"c":7},{"b":4}]
--   </pre>
without :: Expr o => [ReQL] -> o -> ReQL

-- | Merge two objects together
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ merge ["a" := 1, "b" := 1] ["b" := 1, "c" := 2]
--   {"a":1,"b":1,"c":2}
--   </pre>
merge :: (Expr a, Expr b) => a -> b -> ReQL

-- | Append a datum to a sequence
--   
--   <pre>
--   &gt;&gt;&gt; run h $ append 3 [1, 2]
--   [1,2,3]
--   </pre>
append :: (Expr a, Expr b) => a -> b -> ReQL

-- | Prepend an element to an array
--   
--   <pre>
--   &gt;&gt;&gt; run h $ prepend 1 [2,3]
--   [1,2,3]
--   </pre>
prepend :: (Expr datum, Expr array) => datum -> array -> ReQL

-- | The different of two lists
--   
--   <pre>
--   &gt;&gt;&gt; run h $ [1,2,3,4,5] # difference [2,5]
--   [1,3,4]
--   </pre>
difference :: (Expr a, Expr b) => a -> b -> ReQL

-- | Insert a datum into an array if it is not yet present
--   
--   <pre>
--   &gt;&gt;&gt; run h $ setInsert 3 [1,2,4,4,5]
--   [1,2,4,5,3]
--   </pre>
setInsert :: (Expr datum, Expr array) => datum -> array -> ReQL

-- | The union of two sets
--   
--   <pre>
--   &gt;&gt;&gt; run h $ [1,2] `setUnion` [2,3]
--   [2,3,1]
--   </pre>
setUnion :: (Expr a, Expr b) => a -> b -> ReQL

-- | The intersection of two sets
--   
--   <pre>
--   &gt;&gt;&gt; run h $ [1,2] `setIntersection` [2,3]
--   [2]
--   </pre>
setIntersection :: (Expr a, Expr b) => a -> b -> ReQL

-- | The difference of two sets
--   
--   <pre>
--   &gt;&gt;&gt; run h $ [2,3] # setDifference [1,2]
--   [3]
--   </pre>
setDifference :: (Expr set, Expr remove) => remove -> set -> ReQL

-- | Get a single field from an object or an element of an array
--   
--   <pre>
--   &gt;&gt;&gt; run h $ ["foo" := True] ! "foo"
--   true
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; run h $ [1, 2, 3] ! 0
--   1
--   </pre>
--   
--   Or a single field from each object in a sequence
--   
--   <pre>
--   &gt;&gt;&gt; run h $ [["foo" := True], ["foo" := False]] ! "foo"
--   [true,false]
--   </pre>
(!) :: Expr s => s -> ReQL -> ReQL

-- | Get a single field, or null if not present
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ empty !? "foo"
--   null
--   </pre>
(!?) :: Expr s => s -> ReQL -> ReQL

-- | Test if an object has the given fields
--   
--   <pre>
--   &gt;&gt;&gt; run h $ hasFields "a" $ ["a" := 1]
--   true
--   </pre>
hasFields :: Expr obj => ReQL -> obj -> ReQL

-- | Insert a datum at the given position in an array
--   
--   <pre>
--   &gt;&gt;&gt; run h $ insertAt 1 4 [1,2,3]
--   [1,4,2,3]
--   </pre>
insertAt :: (Expr n, Expr datum, Expr array) => n -> datum -> array -> ReQL

-- | Splice an array at a given position inside another array
--   
--   <pre>
--   &gt;&gt;&gt; run h $ spliceAt 2 [4,5] [1,2,3]
--   [1,2,4,5,3]
--   </pre>
spliceAt :: (Expr n, Expr replace, Expr array) => n -> replace -> array -> ReQL

-- | Delete an element from an array
--   
--   <pre>
--   &gt;&gt;&gt; run h $ deleteAt 1 [1,2,3]
--   [1,3]
--   </pre>
deleteAt :: (Expr n, Expr array) => n -> array -> ReQL

-- | Change an element in an array
--   
--   <pre>
--   &gt;&gt;&gt; run h $ changeAt 1 4 [1,2,3]
--   [1,4,3]
--   </pre>
changeAt :: (Expr n, Expr datum, Expr array) => n -> datum -> array -> ReQL

-- | The list of keys of the given object
--   
--   <pre>
--   &gt;&gt;&gt; run h $ keys ["a" := 1, "b" := 2]
--   ["a","b"]
--   </pre>
keys :: Expr object => object -> ReQL

-- | Literal objects, in a merge or update, are not processed recursively.
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ ["a" := ["b" := 1]] # merge ["a" := literal ["c" := 2]]
--   {"a":{"c":2}}
--   </pre>
literal :: Expr a => a -> ReQL

-- | Remove fields when doing a merge or update
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ ["a" := ["b" := 1]] # merge ["a" := remove]
--   {}
--   </pre>
remove :: ReQL

-- | A key/value pair used for building objects
data Attribute a
(:=) :: Text -> e -> Attribute a
(::=) :: k -> v -> Attribute Dynamic
NoAttribute :: Attribute a

-- | Match a string to a regular expression.
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ str "foobar" # match "f(.)+[bc](.+)"
--   {"groups":[{"start":2,"end":3,"str":"o"},{"start":4,"end":6,"str":"ar"}],"start":0,"end":6,"str":"foobar"}
--   </pre>
match :: Expr string => ReQL -> string -> ReQL

-- | Convert to upper case
--   
--   <pre>
--   &gt;&gt;&gt; run h $ upcase (str "Foo")
--   "FOO"
--   </pre>
upcase :: Expr str => str -> ReQL

-- | Convert to lower case
--   
--   <pre>
--   &gt;&gt;&gt; run h $ downcase (str "Foo")
--   "foo"
--   </pre>
downcase :: Expr str => str -> ReQL

-- | Split a string on whitespace characters
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ split (str "foo bar")
--   ["foo","bar"]
--   </pre>
split :: Expr str => str -> ReQL

-- | Split a string on a given delimiter
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ str "foo, bar" # splitOn ","
--   ["foo"," bar"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ str "foo" # splitOn ""
--   ["f","o","o"]
--   </pre>
splitOn :: Expr str => ReQL -> str -> ReQL

-- | Split a string up to a given number of times
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ str "a:b:c:d" # splitMax ":" 2
--   ["a","b","c:d"]
--   </pre>
splitMax :: Expr str => ReQL -> ReQL -> str -> ReQL

-- | Addition or concatenation
--   
--   Use the Num instance, or a qualified operator.
--   
--   <pre>
--   &gt;&gt;&gt; run h $ 2 + 5
--   7
--   
--   &gt;&gt;&gt; run h $ str "foo" R.+ str "bar"
--   "foobar"
--   </pre>
(+) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Subtraction
--   
--   <pre>
--   &gt;&gt;&gt; run h $ 2 - 5
--   -3
--   </pre>
(-) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Multiplication
--   
--   <pre>
--   &gt;&gt;&gt; run h $ 2 * 5
--   10
--   </pre>
(*) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Division
--   
--   <pre>
--   &gt;&gt;&gt; run h $ 2 R./ 5
--   0.4
--   </pre>
(/) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Mod
--   
--   <pre>
--   &gt;&gt;&gt; run h $ 5 `mod` 2
--   1
--   </pre>
mod :: (Expr a, Expr b) => a -> b -> ReQL

-- | Boolean and
--   
--   <pre>
--   &gt;&gt;&gt; run h $ True R.&amp;&amp; False
--   false
--   </pre>
(&&) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Boolean or
--   
--   <pre>
--   &gt;&gt;&gt; run h $ True R.|| False
--   true
--   </pre>
(||) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Test for equality
--   
--   <pre>
--   &gt;&gt;&gt; run h $ ["a" := 1] R.== ["a" := 1]
--   true
--   </pre>
(==) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Test for inequality
--   
--   <pre>
--   &gt;&gt;&gt; run h $ 1 R./= False
--   true
--   </pre>
(/=) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Greater than
--   
--   <pre>
--   &gt;&gt;&gt; run h $ 3 R.&gt; 2
--   true
--   </pre>
(>) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Greater than or equal to
--   
--   <pre>
--   &gt;&gt;&gt; run h $ [1] R.&gt;= Null
--   false
--   </pre>
(>=) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Lesser than
--   
--   <pre>
--   &gt;&gt;&gt; run h $ (str "a") R.&lt; (str "b")
--   true
--   </pre>
(<) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Lesser than or equal to
--   
--   <pre>
--   &gt;&gt;&gt; run h $ 2 R.&lt;= 2
--   true
--   </pre>
(<=) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Negation
--   
--   <pre>
--   &gt;&gt;&gt; run h $ R.not False
--   true
--   
--   &gt;&gt;&gt; run h $ R.not Null
--   true
--   </pre>
not :: Expr a => a -> ReQL

-- | A random float between 0 and 1
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ (\x -&gt; x R.&lt; 1 R.&amp;&amp; x R.&gt;= 0) `apply` [random]
--   true
--   </pre>
random :: ReQL

-- | A random number between 0 and n
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ (\x -&gt; x R.&lt; 10 R.&amp;&amp; x R.&gt;= 0) `apply` [randomTo 10]
--   true
--   </pre>
randomTo :: ReQL -> ReQL

-- | A random number between 0 and n
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ (\x -&gt; x R.&lt; 10 R.&amp;&amp; x R.&gt;= 5) `apply` [randomFromTo 5 10]
--   true
--   </pre>
randomFromTo :: ReQL -> ReQL -> ReQL

-- | The time and date when the query is executed
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ now
--   </pre>
now :: ReQL

-- | Build a time object from the year, month, day, hour, minute, second
--   and timezone fields
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ time 2011 12 24 23 59 59 "Z"
--   Time&lt;2011-12-24 23:59:59 +0000&gt;
--   </pre>
time :: ReQL -> ReQL -> ReQL -> ReQL -> ReQL -> ReQL -> ReQL -> ReQL

-- | Build a time object given the number of seconds since the unix epoch
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ epochTime 1147162826
--   Time&lt;2006-05-09 08:20:26 +0000&gt;
--   </pre>
epochTime :: ReQL -> ReQL

-- | Build a time object given an iso8601 string
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ iso8601 "2012-01-07T08:34:00-0700"
--   Time&lt;2012-01-07 08:34:00 -0700&gt;
--   </pre>
iso8601 :: ReQL -> ReQL

-- | The same time in a different timezone
--   
--   <pre>
--   &gt;&gt;&gt; _ &lt;- run' h $ inTimezone "+0800" now
--   </pre>
inTimezone :: Expr time => ReQL -> time -> ReQL

-- | Test if a time is between two other times
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ during (Open $ now R.- (60*60)) (Closed now) $ epochTime 1382919271
--   false
--   </pre>
during :: (Expr left, Expr right, Expr time) => Bound left -> Bound right -> time -> ReQL

-- | Extract part of a time value
timezone :: Expr time => time -> ReQL

-- | Extract part of a time value
date :: Expr time => time -> ReQL

-- | Extract part of a time value
timeOfDay :: Expr time => time -> ReQL

-- | Extract part of a time value
year :: Expr time => time -> ReQL

-- | Extract part of a time value
month :: Expr time => time -> ReQL

-- | Extract part of a time value
day :: Expr time => time -> ReQL

-- | Extract part of a time value
dayOfWeek :: Expr time => time -> ReQL

-- | Extract part of a time value
dayOfYear :: Expr time => time -> ReQL

-- | Extract part of a time value
hours :: Expr time => time -> ReQL

-- | Extract part of a time value
minutes :: Expr time => time -> ReQL

-- | Extract part of a time value
seconds :: Expr time => time -> ReQL

-- | Convert a time to another representation
toIso8601 :: Expr t => t -> ReQL

-- | Convert a time to another representation
toEpochTime :: Expr t => t -> ReQL

-- | Splice a list of values into an argument list
args :: Expr array => array -> ReQL

-- | Apply a function to a list of arguments.
--   
--   Called <i>do</i> in the official drivers
--   
--   <pre>
--   &gt;&gt;&gt; run h $ (\x -&gt; x R.* 2) `apply` [4]
--   8
--   </pre>
apply :: (Expr fun, Expr arg) => fun -> [arg] -> ReQL

-- | Evaluate a JavaScript expression
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ js "Math.PI"
--   3.141592653589793
--   
--   &gt;&gt;&gt; let r_sin x = js "Math.sin" `apply` [x]
--   
--   &gt;&gt;&gt; run h $ R.map r_sin [pi, pi/2]
--   [1.2246...,1]
--   </pre>
js :: ReQL -> ReQL

-- | Server-side if
--   
--   <pre>
--   &gt;&gt;&gt; run h $ branch (1 R.&lt; 2) 3 4
--   3
--   </pre>
branch :: (Expr a, Expr b, Expr c) => a -> b -> c -> ReQL

-- | Like map but for write queries
--   
--   <pre>
--   &gt;&gt;&gt; _ &lt;- run' h $ table "users" # replace (without ["post_count"])
--   
--   &gt;&gt;&gt; run h $ forEach (\user -&gt; table "users" # get (user!"name") # ex update [nonAtomic] (const ["post_count" := R.count (table "posts" # R.filter (\post -&gt; post!"author" R.== user!"name"))])) (table "users") :: IO WriteResponse
--   {replaced:2}
--   </pre>
forEach :: (Expr a, Expr s) => (ReQL -> a) -> s -> ReQL

-- | Generate numbers starting from 0
--   
--   <pre>
--   &gt;&gt;&gt; run h $ range 10
--   [0,1,2,3,4,5,6,7,8,9]
--   </pre>
range :: ReQL -> ReQL

-- | Generate numbers within a range
--   
--   <pre>
--   &gt;&gt;&gt; run h $ rangeFromTo 2 4
--   [2,3]
--   </pre>
rangeFromTo :: ReQL -> ReQL -> ReQL

-- | Generate numbers starting from 0
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ rangeAll # limit 4
--   [0,1,2,3]
--   </pre>
rangeAll :: ReQL

-- | Abort the query with an error
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ R.error (str "haha") R./ 2 + 1
--   *** Exception: RethinkDB: Runtime error: "haha"
--     in add(div({- HERE -} error("haha"), 2), 1)
--   </pre>
error :: Expr s => s -> ReQL

-- | Catch some expections inside the query.
--   
--   Called <i>default</i> in the official drivers
--   
--   <pre>
--   &gt;&gt;&gt; run h $ R.handle (const 0) $ ["a" := 1] ! "b"
--   0
--   
--   &gt;&gt;&gt; run h $ R.handle (expr . id) $ ["a" := 1] ! "b"
--   "No attribute `b` in object:\n{\n\t\"a\":\t1\n}"
--   </pre>
handle :: (Expr instead, Expr reql) => (ReQL -> instead) -> reql -> ReQL

-- | Convert other types into ReQL expressions
class Expr e where expr = datumTerm exprList = expr . arr
expr :: Expr e => e -> ReQL
exprList :: Expr e => [e] -> ReQL

-- | Convert a value to a different type
--   
--   <pre>
--   &gt;&gt;&gt; run h $ coerceTo "STRING" 1
--   "1"
--   </pre>
coerceTo :: Expr x => ReQL -> x -> ReQL

-- | Convert a value to an array
--   
--   <pre>
--   &gt;&gt;&gt; run h $ asArray $ ["a" := 1, "b" := 2] :: IO [(String, Int)]
--   [("a",1),("b",2)]
--   </pre>
asArray :: Expr x => x -> ReQL

-- | Convert a value to a string
--   
--   <pre>
--   &gt;&gt;&gt; run h $ asString $ ["a" := 1, "b" := 2]
--   "{\n\t\"a\":\t1,\n\t\"b\":\t2\n}"
--   </pre>
asString :: Expr x => x -> ReQL

-- | Convert a value to a number
--   
--   <pre>
--   &gt;&gt;&gt; run h $ asNumber (str "34")
--   34
--   </pre>
asNumber :: Expr x => x -> ReQL

-- | Convert a value to an object
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ asObject $ [(str "a",1),("b",2)]
--   {"a":1,"b":2}
--   </pre>
asObject :: Expr x => x -> ReQL

-- | Convert a value to a boolean
asBool :: Expr x => x -> ReQL

-- | A string representing the type of an expression
--   
--   <pre>
--   &gt;&gt;&gt; run h $ typeOf 1
--   "NUMBER"
--   </pre>
typeOf :: Expr a => a -> ReQL

-- | Get information on a given expression. Useful for tables and
--   databases.
--   
--   <pre>
--   &gt;&gt;&gt; run h $ info $ table "users"
--   {"primary_key":"name","doc_count_estimates":...,"name":"users","id":...,"indexes":["friends","location"],"type":"TABLE","db":{"name":"doctests","id":...,"type":"DB"}}
--   </pre>
info :: Expr a => a -> ReQL

-- | Parse a json string into an object
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ json "{\"a\":1}"
--   {"a":1}
--   </pre>
json :: ReQL -> ReQL

-- | Convert an object or value to a JSON string
--   
--   <pre>
--   &gt;&gt;&gt; run h $ toJSON "a"
--   "\"a\""
--   </pre>
toJSON :: Expr a => a -> ReQL

-- | Generate a UUID
--   
--   <pre>
--   &gt;&gt;&gt; run h uuid
--   "...-...-...-..."
--   </pre>
uuid :: ReQL

-- | Retrieve data from the specified URL over HTTP
--   
--   <pre>
--   &gt;&gt;&gt; _ &lt;- run' h $ http "http://httpbin.org/get" def{ httpParams = Just ["foo" := 1] }
--   
--   &gt;&gt;&gt; _ &lt;- run' h $ http "http://httpbin.org/put" def{ httpMethod = Just PUT, httpData = Just $ expr ["foo" := "bar"] }
--   </pre>
http :: Expr url => url -> HttpOptions -> ReQL
data HttpOptions
HttpOptions :: Maybe Int -> Maybe Int -> Maybe Int -> Maybe Bool -> Maybe HttpResultFormat -> Maybe HttpMethod -> Maybe [Attribute Dynamic] -> Maybe [Attribute Dynamic] -> Maybe [Attribute Dynamic] -> Maybe ReQL -> Maybe PaginationStrategy -> Maybe Int -> HttpOptions
httpTimeout :: HttpOptions -> Maybe Int
httpReattempts :: HttpOptions -> Maybe Int
httpRedirects :: HttpOptions -> Maybe Int
httpVerify :: HttpOptions -> Maybe Bool
httpResultFormat :: HttpOptions -> Maybe HttpResultFormat
httpMethod :: HttpOptions -> Maybe HttpMethod
httpAuth :: HttpOptions -> Maybe [Attribute Dynamic]
httpParams :: HttpOptions -> Maybe [Attribute Dynamic]
httpHeader :: HttpOptions -> Maybe [Attribute Dynamic]
httpData :: HttpOptions -> Maybe ReQL
httpPage :: HttpOptions -> Maybe PaginationStrategy
httpPageLimit :: HttpOptions -> Maybe Int
data HttpResultFormat
FormatAuto :: HttpResultFormat
FormatJSON :: HttpResultFormat
FormatJSONP :: HttpResultFormat
FormatBinary :: HttpResultFormat
data HttpMethod
GET :: HttpMethod
POST :: HttpMethod
PUT :: HttpMethod
PATCH :: HttpMethod
DELETE :: HttpMethod
HEAD :: HttpMethod
data PaginationStrategy
LinkNext :: PaginationStrategy
PaginationFunction :: (ReQL -> ReQL) -> PaginationStrategy

-- | Create a polygon approximating a circle
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ ex circle [numVertices 6, unit Kilometer] (point (-73) 40) 100
--   Polygon&lt;[[-73,39.099310036015424],[-74.00751390838496,39.54527799206398],[-74.02083610406069,40.445812561599965],[-73,40.900549591978255],[-71.97916389593931,40.445812561599965],[-71.99248609161504,39.54527799206398],[-73,39.099310036015424]]&gt;
--   </pre>
circle :: (Expr point, Expr radius) => point -> radius -> ReQL

-- | Distance between a point and another geometry object
--   
--   <pre>
--   run' h $ distance (point (-73) 40) (point (-122) 37)
--   </pre>
--   
--   <ol>
--   <li>467303546 &gt; run' h $ ex distance [unit Mile] (point (-73) 40)
--   (point (-122) 37)</li>
--   <li>5460282596796</li>
--   </ol>
distance :: (Expr a, Expr b) => a -> b -> ReQL

-- | Convert a line object into a polygon
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ fill $ line [[-122,37], [-120,39], [-121,38]]
--   Polygon&lt;[[-122,37],[-120,39],[-121,38],[-122,37]]&gt;
--   </pre>
fill :: Expr line => line -> ReQL

-- | Convert a GeoJSON object into a RethinkDB geometry object
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ geoJSON ["type" := "Point", "coordinates" := [-45,80]]
--   Point&lt;-45,80&gt;
--   </pre>
geoJSON :: Expr geojson => geojson -> ReQL

-- | Convert a RethinkDB geometry object into a GeoJSON object
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ toGeoJSON $ point (-122.423246) 37.779388
--   {"coordinates":[-122.423246,37.779388],"type":"Point"}
--   </pre>
toGeoJSON :: Expr geo => geo -> ReQL

-- | Search a geospatial index for intersecting objects
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "places" # getIntersecting (point (-122) 37) (Index "geo")
--   []
--   </pre>
getIntersecting :: (Expr geo, Expr table) => geo -> Index -> table -> ReQL

-- | Query a geospatial index for the nearest matches
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "places" # getNearest (point (-122) 37) (Index "location")
--   []
--   
--   &gt;&gt;&gt; run' h $ table "places" # ex getNearest [maxResults 5, maxDist 10, unit Kilometer] (point (-122) 37) (Index "location")
--   []
--   </pre>
getNearest :: (Expr point, Expr table) => point -> Index -> table -> ReQL

-- | Test whether a geometry object includes another
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ circle (point (-122) 37) 5000 # includes (point (-120) 48)
--   false
--   </pre>
includes :: (Expr area, Expr geo) => geo -> area -> ReQL

-- | Test if two geometry objects intersects
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ intersects (line [[-122,37],[-120,48]]) (line [[-120,49],[-122,48]])
--   false
--   </pre>
intersects :: (Expr a, Expr b) => a -> b -> ReQL

-- | Create a line object
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ line [[-73,45],[-122,37]]
--   Line&lt;[-73,45],[-122,37]&gt;
--   </pre>
line :: Expr points => points -> ReQL

-- | Create a point objects
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ point (-73) 40
--   Point&lt;-73,40&gt;
--   </pre>
point :: (Expr longitude, Expr latitude) => longitude -> latitude -> ReQL

-- | Create a polygon object
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ polygon [[-73,45],[-122,37],[-73,40]]
--   Polygon&lt;[[-73,45],[-122,37],[-73,40],[-73,45]]&gt;
--   </pre>
polygon :: Expr points => points -> ReQL

-- | Punch a hole in a polygon
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ (polygon [[-73,45],[-122,37],[-73,40]]) # polygonSub (polygon [[-73.2,40.1],[-73.2,40.2],[-73.3,40.1]])
--   Polygon&lt;[[-73,45],[-122,37],[-73,40],[-73,45]],[[-73.2,40.1],[-73.2,40.2],[-73.3,40.1],[-73.2,40.1]]&gt;
--   </pre>
polygonSub :: (Expr polygon, Expr hole) => hole -> polygon -> ReQL
data LonLat
LonLat :: Double -> Double -> LonLat
longitude :: LonLat -> Double
latitude :: LonLat -> Double
newtype GeoLine
GeoLine :: Vector LonLat -> GeoLine
geoLinePoints :: GeoLine -> Vector LonLat
newtype GeoPolygon
GeoPolygon :: Vector (Vector LonLat) -> GeoPolygon
geoPolygonLines :: GeoPolygon -> Vector (Vector LonLat)

-- | Optional argument for getNearest
maxResults :: ReQL -> Attribute a

-- | Optional argument for getNearest
maxDist :: ReQL -> Attribute a

-- | Optional argument for getNearest, circle and distance
unit :: Unit -> Attribute a

-- | Optional argument for circle
numVertices :: ReQL -> Attribute a
data Unit
Meter :: Unit
Kilometer :: Unit
Mile :: Unit
NauticalMile :: Unit
Foot :: Unit

-- | Get the config for a table or database
--   
--   <pre>
--   &gt;&gt;&gt; run h $ table "users" # config
--   {"primary_key":"name","write_acks":"majority","durability":"hard","name":"users","shards":...,"id":...,"db":"doctests"}
--   </pre>
config :: Expr table => table -> ReQL

-- | Rebalance a table's shards
--   
--   <pre>
--   &gt;&gt;&gt; run h $ table "users" # rebalance
--   {"rebalanced":1,"status_changes":[{"new_val":{"status":{"all_replicas_ready":...,"ready_for_outdated_reads":...,"ready_for_writes":...,"ready_for_reads":...},"name":"users","shards":...,"id":...,"db":"doctests"},"old_val":...}]}
--   </pre>
rebalance :: Expr table => table -> ReQL

-- | Change a table's configuration
--   
--   <pre>
--   &gt;&gt;&gt; run h $ table "users" # reconfigure 2 1
--   {"config_changes":[{"new_val":{"primary_key":"name","write_acks":"majority","durability":"hard","name":"users","shards":...,"id":...,"db":"doctests"},"old_val":...}],"reconfigured":1,"status_changes":[{"new_val":{"status":{"all_replicas_ready":...,"ready_for_outdated_reads":...,"ready_for_writes":...,"ready_for_reads":...},"name":"users","shards":...,"id":...,"db":"doctests"},"old_val":...}]}
--   </pre>
reconfigure :: (Expr table, Expr replicas) => ReQL -> replicas -> table -> ReQL

-- | Get the status of a table
--   
--   <pre>
--   &gt;&gt;&gt; run h $ table "users" # status
--   {"status":{"all_replicas_ready":true,"ready_for_outdated_reads":true,"ready_for_writes":true,"ready_for_reads":true},"name":"users","shards":...,"id":...,"db":"doctests"}
--   </pre>
status :: Expr table => table -> ReQL

-- | Wait for tables to be ready
--   
--   <pre>
--   &gt;&gt;&gt; run h $ table "users" # wait
--   {"ready":1,"status_changes":[{"new_val":{"status":{"all_replicas_ready":true,"ready_for_outdated_reads":true,"ready_for_writes":true,"ready_for_reads":true},"name":"users","shards":...,"id":...,"db":"doctests"},"old_val":...}]}
--   </pre>
wait :: Expr table => table -> ReQL

-- | Extend an operation with optional arguments
ex :: OptArgs a => a -> [Attribute Static] -> a

-- | A shortcut for inserting strings into ReQL expressions Useful when
--   OverloadedStrings makes the type ambiguous
str :: String -> ReQL

-- | A shortcut for inserting numbers into ReQL expressions
num :: Double -> ReQL

-- | Flipped function application
(#) :: (Expr a, Expr b) => a -> (a -> b) -> ReQL

-- | Add a note a a ReQL Term
--   
--   This note does not get sent to the server. It is used to annotate
--   backtraces and help debugging.
note :: String -> ReQL -> ReQL

-- | An empty object
empty :: ReQL

-- | The default value for this type.
def :: Default a => a


-- | This module exports all of Database.RethinkDB except for the names
--   that clash with Prelude or Data.Time
module Database.RethinkDB.NoClash

module Database.RethinkDB.MapReduce

-- | Takes a function that takes a sequence as an argument, and returns a
--   function that only uses that sequence once, by merging the map and
--   reduce operations. This is used by groupBy.
termToMapReduce :: (ReQL -> ReQL) -> State QuerySettings (ReQL -> ReQL)

-- | Compares the two representations of a variable
sameVar :: Int -> [Term] -> Bool

-- | notNone checks that it is a map/reduce and not a constant
notConst :: Chain -> Bool

-- | Helper function for casting up from Term into ReQL
wrap :: Term -> ReQL

-- | Build a single argument function from a constant ReQL expression
toFun1 :: Term -> (ReQL -> ReQL)

-- | Build a two argument function from a constant ReQL expression
toFun2 :: Term -> (ReQL -> ReQL -> ReQL)

-- | Represents a map/reduce operation split into its map and reduce parts
data MRF
MRF :: MapFun -> (ReQL -> ReQL -> ReQL) -> Maybe ReQL -> (ReQL -> ReQL) -> MRF
_mrfMapFun :: MRF -> MapFun
_mrfReduceFun :: MRF -> ReQL -> ReQL -> ReQL
_mrfBase :: MRF -> Maybe ReQL
_mrfFinally :: MRF -> ReQL -> ReQL

-- | A Chain of ReQL expressions that might be transformed into a
--   map/reduce operation
data Chain

-- | A constant, not really a map/reduce operation
None :: ReQL -> Chain

-- | Just a map
Map :: [Map] -> Chain

-- | map/reduce operations represented as parts
MapReduceChain :: [Map] -> Reduce -> Chain

-- | A rewritten map/reduce
MapReduce :: MRF -> Chain

-- | Special cases for reduce with base
SingletonArray :: ReQL -> Chain
AddBase :: ReQL -> Chain -> Chain

-- | A built-in map operation
data Map
BuiltInMap :: TermType -> [ReQL] -> [OptArg] -> MapFun -> Map
data MapFun
MapFun :: (ReQL -> ReQL) -> MapFun
ConcatMapFun :: (ReQL -> ReQL) -> MapFun
data Reduce
BuiltInReduce :: TermType -> [ReQL] -> [OptArg] -> MRF -> Reduce

-- | Convert a Chain back into a ReQL function
applyChain :: Chain -> (ReQL -> ReQL)

-- | Convert an MRF into a ReQL function
applyMRF :: MRF -> ReQL -> ReQL
applyMaps :: [Map] -> ReQL -> ReQL
applyMap :: Map -> ReQL -> ReQL
applyMapFun :: MapFun -> ReQL -> ReQL
applyReduce :: Reduce -> ReQL -> ReQL
chainToMRF :: Chain -> Either ReQL MRF
thenFinally :: MRF -> (ReQL -> ReQL) -> MRF
thenMRF :: [Map] -> MRF -> MRF
composeMaps :: [Map] -> MapFun
composeMapFun :: MapFun -> MapFun -> MapFun
thenReduce :: [Map] -> Reduce -> MRF
collect :: MRF

-- | Rewrites the term in the second argument to merge all uses of the
--   variable whose id is given in the first argument.
toMapReduce :: Int -> Term -> Chain
singleton :: TermType -> [Chain] -> [TermAttribute] -> Maybe ReQL

-- | Chain a ReQL command onto a MapReduce operation
mrChain :: TermType -> Chain -> [Term] -> [TermAttribute] -> Maybe Chain

-- | Convert some builtin operations into a map
mapMRF :: TermType -> [Term] -> [TermAttribute] -> Maybe MapFun

-- | Convert some of the built-in operations into a map/reduce
--   
--   TODO: these have not been tested
reduceMRF :: TermType -> [Term] -> [TermAttribute] -> Maybe MRF

-- | Convert from one representation to the other
baseAttrToOptArg :: TermAttribute -> OptArg

-- | This undocumented optional argument circumvents stream polymorphism on
--   some operations
noRecurse :: OptArg

-- | Rewrite a command into a map/reduce.
--   
--   This is a special case for when only one of the arguments is itself a
--   map/reduce
rewrite1 :: TermType -> [Chain] -> [(Text, Chain)] -> MRF

-- | Rewrite a command that combines the result of multiple map/reduce
--   operations into a single map/reduce operation
rewritex :: TermType -> [Chain] -> [(Key, Chain)] -> MRF

-- | Extract the inner map/reduce objects, also returning a function which,
--   given the result of all the map/reduce operations, returns the result
--   of the given command
extract :: Maybe Int -> TermType -> [Chain] -> [(Key, Chain)] -> ([ReQL] -> ReQL, [MRF])

module Database.RethinkDB.Doctest
try' :: IO a -> IO ()
doctestConnect :: IO RethinkDBHandle
sorted :: IO Datum -> IO Datum
