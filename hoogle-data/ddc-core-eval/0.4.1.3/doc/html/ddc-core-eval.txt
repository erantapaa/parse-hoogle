-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Disciplined Disciple Compiler semantic evaluator for the core language.
--   
--   This is a direct implementation of the operational semantics and is by
--   no means fast, or a substitute for a real interpreter. Programs run
--   with this evaluator will have an asymptotic complexity much worse than
--   if they were compiled. This evaluator is intended for experimenting
--   with the language semantics, and not running actual programs.
@package ddc-core-eval
@version 0.4.1.3

module DDC.Core.Eval.Name

-- | Names of things recognised by the evaluator.
data Name

-- | User variables.
NameVar :: String -> Name

-- | User constructors.
NameCon :: String -> Name

-- | Integer literals (which data constructors).
NameInt :: Integer -> Name

-- | Primitive constructors (eg <tt>List, Nil</tt>).
NamePrimCon :: PrimCon -> Name

-- | Primitive operators (eg <tt>addInt, subInt</tt>).
NamePrimOp :: PrimOp -> Name

-- | Store locations.
NameLoc :: Loc -> Name

-- | Region handles.
NameRgn :: Rgn -> Name

-- | Store capabilities.
NameCap :: Cap -> Name

-- | A primitive constructor.
data PrimCon

-- | <tt>Int</tt> type constructor.
PrimTyConInt :: PrimCon

-- | <tt>Pair</tt> type constructor.
PrimTyConPair :: PrimCon

-- | <tt>List</tt> type constructor.
PrimTyConList :: PrimCon

-- | <tt>P</tt> data construct (pairs).
PrimDaConPr :: PrimCon

-- | <tt>Nil</tt> data constructor.
PrimDaConNil :: PrimCon

-- | <tt>Cons</tt> data constructor.
PrimDaConCons :: PrimCon

-- | A primitive operator.
data PrimOp
PrimOpNegInt :: PrimOp
PrimOpAddInt :: PrimOp
PrimOpSubInt :: PrimOp
PrimOpMulInt :: PrimOp
PrimOpDivInt :: PrimOp
PrimOpEqInt :: PrimOp
PrimOpUpdateInt :: PrimOp
PrimOpCopyInt :: PrimOp

-- | A store location, tagged with the type of the value contained at that
--   location.
--   
--   These are pretty printed like <tt>l4#</tt>.
data Loc
Loc :: Int -> (Type Name) -> Loc

-- | A region handle.
--   
--   These are pretty printed like <tt>r5#</tt>.
data Rgn
Rgn :: Int -> Rgn

-- | These are primitive witnesses that guarantee the associated property
--   of the program. Ostensibly, they are only introduced by the system at
--   runtime, but for testing purposes we can also inject them into the
--   source program.
data Cap

-- | Witness that a region is global. Global regions live for the duration
--   of the program and are not deallocated in a stack like manner. This
--   lets us hide the use of such regions, and rely on the garbage
--   collector to reclaim the space.
CapGlobal :: Cap

-- | Witness that a region is constant. This lets us purify read and
--   allocation effects on it, and prevents it from being Mutable.
CapConst :: Cap

-- | Witness that a region is mutable. This lets us update objects in the
--   region, and prevents it from being Constant.
CapMutable :: Cap

-- | Witness that some regions are distinct This lets us perform aliasing
--   based optimisations.
CapDistinct :: Int -> Cap

-- | Witness that a region is lazy. This lets is allocate thunks into the
--   region, and prevents it from being Manifest.
CapLazy :: Cap

-- | Witness that a region is manifest. This ensures there are no thunks in
--   the region, which prevents it from being Lazy.
CapManifest :: Cap

-- | Read a primitive name.
readName :: String -> Maybe Name

-- | Lex a string to tokens, using primitive names.
--   
--   The first argument gives the starting source line number.
lexModuleString :: String -> Int -> String -> [Token (Tok Name)]

-- | Lex a string to tokens, using primitive names.
--   
--   The first argument gives the starting source line number.
lexExpString :: String -> Int -> String -> [Token (Tok Name)]
instance Typeable Name
instance Eq Rgn
instance Ord Rgn
instance Show Rgn
instance Eq Cap
instance Ord Cap
instance Show Cap
instance Show PrimCon
instance Eq PrimCon
instance Ord PrimCon
instance Show PrimOp
instance Eq PrimOp
instance Ord PrimOp
instance Show Name
instance Eq Name
instance Ord Name
instance Show Loc
instance Pretty PrimOp
instance NFData PrimOp
instance Pretty PrimCon
instance NFData PrimCon
instance Pretty Cap
instance NFData Cap
instance Pretty Rgn
instance NFData Rgn
instance Ord Loc
instance Eq Loc
instance Pretty Loc
instance NFData Loc
instance Pretty Name
instance NFData Name


-- | Utilities for constructing and destructing compound types and
--   expressions.
module DDC.Core.Eval.Compounds

-- | Application of the Pair type constructor.
tPair :: Region Name -> Type Name -> Type Name -> Type Name

-- | Application of the List type constructor.
tList :: Region Name -> Type Name -> Type Name
wGlobal :: a -> Region Name -> Witness a Name
wConst :: a -> Region Name -> Witness a Name
wMutable :: a -> Region Name -> Witness a Name
wDistinct :: a -> Int -> [Region Name] -> Witness a Name
wLazy :: a -> Region Name -> Witness a Name
wManifest :: a -> Region Name -> Witness a Name
wcGlobal :: WiCon Name
wcConst :: WiCon Name
wcMutable :: WiCon Name
wcDistinct :: Int -> WiCon Name
wcLazy :: WiCon Name
wcManifest :: WiCon Name

-- | Check whether a witness is a capability constructor.
isCapConW :: Witness a Name -> Bool

-- | Take a witness of mutability from an expression.
takeMutableX :: Exp a Name -> Maybe Rgn

-- | Check whether an expression is the unit constructor.
isUnitX :: Exp a Name -> Bool

-- | Take a region handle from a type.
takeHandleT :: Type Name -> Maybe Rgn

-- | Take a region handle from an expression.
takeHandleX :: Exp a Name -> Maybe Rgn

-- | Make a location expression.
xLoc :: Loc -> Type Name -> Exp () Name

-- | Take a store location from an expression. We strip off <tt>forget</tt>
--   casts along the way
takeLocX :: Exp a Name -> Maybe Loc

-- | Take a store location from an expression, reaching under any
--   <tt>forget</tt> casts.
stripLocX :: Exp a Name -> Maybe Loc

-- | Application of the Int type constructor.
tInt :: Region Name -> Type Name

-- | The integer type constructor
tcInt :: TyCon Name

-- | Make an integer data constructor.
dcInt :: Integer -> DaCon Name

-- | Take an integer literal from an data constructor.
takeIntDC :: DaCon Name -> Maybe Integer

-- | Take an integer literal from an expression.
takeIntX :: Exp a Name -> Maybe Integer


-- | Primitive types and operators for the core language evaluator.
--   
--   These are only a subset of the primitives supported by the real
--   compiler, there's just enough to experiment with the core language.
module DDC.Core.Eval.Env

-- | Data type definitions for:
--   
--   <pre>
--   Type   Constructors
--   ----   ------------
--   Int    0 1 2 3 ...
--   Pair   Pr
--   List   Nil Cons
--   </pre>
primDataDefs :: DataDefs Name

-- | Kind environment containing kinds of primitive data types.
primKindEnv :: Env Name

-- | Take the kind of a primitive name.
--   
--   Returns <a>Nothing</a> if the name isn't primitive.
kindOfPrimName :: Name -> Maybe (Kind Name)

-- | Type environment containing types of primitive data constructors as
--   well as the following primitive operators:
--   
--   <pre>
--   negInt, addInt, subInt, mulInt, divInt, eqInt, updateInt
--   </pre>
--   
--   It also contains types for the primitive capability constructors:
--   
--   <pre>
--   Global#, Const#, Mutable#, Lazy#, Manifest#
--   </pre>
primTypeEnv :: Env Name

-- | Take the type of a primitive name.
--   
--   Returns <a>Nothing</a> if the name isn't primitive.
typeOfPrimName :: Name -> Maybe (Type Name)

-- | Take the arity of a primitive name.
arityOfName :: Name -> Maybe Int


-- | Core language profile for the evaluator.
module DDC.Core.Eval.Profile

-- | Core language fragment that can be directly evaluated.
evalProfile :: Profile Name


-- | Definition of the store.
module DDC.Core.Eval.Store
data Store
Store :: Int -> Int -> Set Rgn -> Set Rgn -> Map Loc (Rgn, Type Name, SBind) -> Store

-- | Next store location to allocate.
storeNextLoc :: Store -> Int

-- | Next region handle to allocate.
storeNextRgn :: Store -> Int

-- | Region handles already allocated.
storeRegions :: Store -> Set Rgn

-- | Regions that are marked as global, and are not deallocated with a
--   stack discipline.
storeGlobal :: Store -> Set Rgn

-- | Map of locations to store bindings, their types, and the handle for
--   the regions they're in.
storeBinds :: Store -> Map Loc (Rgn, Type Name, SBind)

-- | A store location, tagged with the type of the value contained at that
--   location.
--   
--   These are pretty printed like <tt>l4#</tt>.
data Loc
Loc :: Int -> (Type Name) -> Loc

-- | A region handle.
--   
--   These are pretty printed like <tt>r5#</tt>.
data Rgn
Rgn :: Int -> Rgn

-- | Store binding. These are naked objects that can be allocated directly
--   into the heap.
data SBind

-- | An algebraic data constructor.
SObj :: DaCon Name -> [Loc] -> SBind
sbindDataTag :: SBind -> DaCon Name
sbindDataArgs :: SBind -> [Loc]

-- | Lambda abstraction, used for recursive bindings. The flag indicates
--   whether each binder is level-1 (True) or level-0 (False).
SLams :: [(Bool, Bind Name)] -> Exp () Name -> SBind
sbindLamBinds :: SBind -> [(Bool, Bind Name)]
sbindLamBody :: SBind -> Exp () Name

-- | A thunk, used for lazy evaluation.
SThunk :: Exp () Name -> SBind
sbindThunkExp :: SBind -> Exp () Name

-- | Initial store containing the preallocated regions and bindings.
initial :: Store

-- | Location of the static unit object.
locUnit :: Loc

-- | Check whether an expression is the unit constructor, or its static
--   heap location.
isUnitOrLocX :: Show a => Exp a Name -> Bool

-- | Create a new location in the store.
newLoc :: Type Name -> Store -> (Store, Loc)

-- | Create several new locations in the store.
newLocs :: [Type Name] -> Store -> (Store, [Loc])

-- | Create a new region in the store.
newRgn :: Store -> (Store, Rgn)

-- | Create several new regions in the store
newRgns :: Int -> Store -> (Store, [Rgn])

-- | Delete a region, removing all its bindings.
delRgn :: Rgn -> Store -> Store

-- | Check whether a store contains the given region.
hasRgn :: Store -> Rgn -> Bool

-- | Set a region as being global.
setGlobal :: Rgn -> Store -> Store

-- | Add a store binding to the store, at the given location.
addBind :: Loc -> Rgn -> Type Name -> SBind -> Store -> Store

-- | Allocate a new binding into the given region, returning the new
--   location.
allocBind :: Rgn -> Type Name -> SBind -> Store -> (Store, Loc)

-- | Alloc some recursive bindings into the given region, returning the new
--   locations.
allocBinds :: [[Loc] -> (Rgn, Type Name, SBind)] -> [Type Name] -> Store -> (Store, [Loc])

-- | Lookup a the binding for a location.
lookupBind :: Loc -> Store -> Maybe SBind

-- | Lookup the type of a store location.
lookupTypeOfLoc :: Loc -> Store -> Maybe (Type Name)

-- | Lookup the region handle, type and binding for a location.
lookupRegionTypeBind :: Loc -> Store -> Maybe (Rgn, Type Name, SBind)
instance Eq SBind
instance Show SBind
instance Show Store
instance Pretty SBind
instance Pretty Store


-- | Single step evaluation of primitive operators and constructors.
module DDC.Core.Eval.Prim

-- | Step a primitive constructor, which allocates an object in the store.
stepPrimCon :: DaCon Name -> [Exp () Name] -> Store -> Maybe (Store, Exp () Name)

-- | Step a primitive operator.
stepPrimOp :: Name -> [Exp () Name] -> Store -> Maybe (Store, Exp () Name)

-- | Like <a>newRgn</a> but return the region handle wrapped in a
--   <a>Bound</a>.
primNewRegion :: Store -> (Store, Bound Name)

-- | Like <a>delRgn</a> but accept a region handle wrapped in a
--   <a>Bound</a>.
primDelRegion :: Bound Name -> Store -> Maybe Store


-- | Single step evalation for the Disciple Core language.
module DDC.Core.Eval.Step

-- | The result of stepping some expression.
data StepResult

-- | Expression progressed to a new state.
StepProgress :: Store -> (Exp () Name) -> StepResult

-- | Expression cannot step and is a (weak) value. We're done already.
StepDone :: StepResult

-- | Expression cannot step, and is not a (weak) value. The original
--   expression was mistyped, or something is wrong with the interpreter.
StepStuck :: StepResult

-- | Expression is stuck, and we know for sure it's mistyped.
StepMistyped :: (Error () Name) -> StepResult

-- | Single step a core expression to a value.
--   
--   As opposed to <a>step</a>, if the provided expression is the location
--   of a Thunk, then the thunk will be forced.
force :: Store -> Exp () Name -> StepResult

-- | Single step a code expression to a weak value.
--   
--   As opposed to <a>force</a>, if the provided expression is the location
--   of a Thunk, then the thunk is not forced.
step :: Store -> Exp () Name -> StepResult

-- | Check if an expression is a value. Values can't be progressed any
--   further, with either <a>force</a> or <a>step</a>.
isValue :: Store -> Exp a Name -> Bool

-- | Check if an expression is a weak values. These are all the values, and
--   locations that point to thunks.
--   
--   Weak values can be progressed with <a>force</a>, but not <a>step</a>.
isWeakValue :: Store -> Exp a Name -> Bool
instance Show StepResult


-- | Check for conflicting store capabilities in the initial program.
module DDC.Core.Eval.Check

-- | Check for conflicting store capabilities in a module.
checkCapsModule :: Module a Name -> Maybe (Error a)

-- | Check for conflicting store capabilities in an expression.
checkCapsX :: Exp a Name -> Maybe (Error a)

-- | Things that can go wrong with the capabilities in a program.
data Error a

-- | Conflicting capabilities in program.
ErrorConflict :: Rgn -> Cap -> Cap -> Error a
errorRegions :: Error a -> Rgn
errorCap1 :: Error a -> Cap
errorCap2 :: Error a -> Cap

-- | A partially applied capability constructor. In the formal semantics,
--   capabilities are atomic, so this isn't a problem. However, as we're
--   representing them with general witness appliction we need to ensure
--   the constructors aren't partially applied.
ErrorPartial :: Witness () Name -> Error a
errorWitness :: Error a -> Witness () Name

-- | A capability constructor applied to a non-region handle. As with
--   <a>ErrorPartial</a> we only need to check for this because we're using
--   general witness application to represent capabilities, instead of
--   having an atomic form.
ErrorNonHandle :: Witness () Name -> Error a
errorWitness :: Error a -> Witness () Name
instance Show CapSet
instance Pretty (Error a)


-- | Single step evaluator for the Disciple Core language.
--   
--   This is a direct implementation of the operational semantics and is by
--   no means fast, or a substitute for a real interpreter. Programs run
--   with this evaluator will have an asymptotic complexity much worse than
--   if they were compiled. This evaluator is intended for experimenting
--   with the language semantics, and not running actual programs.
module DDC.Core.Eval

-- | Core language fragment that can be directly evaluated.
evalProfile :: Profile Name

-- | The result of stepping some expression.
data StepResult

-- | Expression progressed to a new state.
StepProgress :: Store -> (Exp () Name) -> StepResult

-- | Expression cannot step and is a (weak) value. We're done already.
StepDone :: StepResult

-- | Expression cannot step, and is not a (weak) value. The original
--   expression was mistyped, or something is wrong with the interpreter.
StepStuck :: StepResult

-- | Expression is stuck, and we know for sure it's mistyped.
StepMistyped :: (Error () Name) -> StepResult

-- | Single step a core expression to a value.
--   
--   As opposed to <a>step</a>, if the provided expression is the location
--   of a Thunk, then the thunk will be forced.
force :: Store -> Exp () Name -> StepResult

-- | Single step a code expression to a weak value.
--   
--   As opposed to <a>force</a>, if the provided expression is the location
--   of a Thunk, then the thunk is not forced.
step :: Store -> Exp () Name -> StepResult
