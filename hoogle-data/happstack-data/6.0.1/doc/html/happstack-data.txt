-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Happstack data manipulation libraries
--   
--   This package provides libraries for:
--   
--   <ul>
--   <li>Deriving instances for your datatypes.</li>
--   <li>Producing default values of Haskell datatypes.</li>
--   <li>Normalizing values of Haskell datatypes.</li>
--   <li>Marshalling Haskell values to and from XML.</li>
--   <li>Marshalling Haskell values to and from HTML forms.</li>
--   </ul>
@package happstack-data
@version 6.0.1

module Happstack.Data.GOps

-- | <tt>gSet x y</tt> will traveral <tt>x</tt> and replace any instances
--   of the type <tt>a</tt> in its structure with <tt>y</tt>.
gSet :: (Data b, Typeable a) => a -> b -> b

-- | <tt>gReplace f b</tt> will traverse <tt>x</tt> and will act on any
--   instance of the type <tt>a</tt> in its structure with the function
--   <tt>f</tt>.
gReplace :: (Typeable a, Data b) => (a -> a) -> b -> b

-- | <tt>gFind a</tt> will extract any elements of type <tt>b</tt> from
--   <tt>a</tt>'s structure in accordance with the MonadPlus instance, e.g.
--   Maybe Foo will return the first Foo found while [Foo] will return the
--   list of Foos found.
gFind :: (MonadPlus m, Data a, Typeable b) => a -> m b

-- | Acts as gFind but will throw an exception if nothing is found.
gFind' :: (Data a, Typeable b) => a -> b

-- | A generalized modify that will apply the modification function to the
--   structure of the state.
gModify :: (MonadState s m, Typeable a, Data s) => (a -> a) -> m ()

-- | A generalized ask that will traverse the stored type of the
--   MonadReader in an attempt to find an <tt>a</tt> and will then apply
--   the provided function if found.
gAsk :: (Data r, Typeable a, MonadReader r m, MonadPlus n) => (a -> n b) -> m (n b)

-- | The equivalent of <a>gAsk</a> for MonadState
gGet :: (Data s, Typeable a, MonadState s m, MonadPlus n) => (a -> n b) -> c -> m (n b)


-- | Normalizing Haskell values.
module Happstack.Data.Normalize

-- | The <a>Normalize</a> class provides a <a>normalize</a> function, which
--   is intended to normalize values only at the top-level constructor, and
--   a <a>normalizeRecursively</a> function, which is intended to normalize
--   all the subvalues and then normalize the top-level constructor.
--   
--   There is a default instance that matches all types, where
--   <a>normalize</a> is <a>id</a> and <a>normalizeRecursively</a> applies
--   <a>normalizeRecursively</a> to all of its children and then
--   <a>normalize</a> to the result.
--   
--   If you want to actually do some normalization for a certain type, then
--   just define an instance for that type; this will take precedence over
--   the default instance.
class Data NormalizeD a => Normalize a where normalize = defaultNormalize normalizeRecursively = defaultNormalizeRecursively
normalize :: Normalize a => a -> a
normalizeRecursively :: Normalize a => a -> a

-- | This is the <a>normalize</a> function in the default <a>Normalize</a>
--   instance. It may be a useful building block when writing your own
--   instances.
defaultNormalize :: Normalize a => a -> a

-- | This is the <a>normalizeRecursively</a> function in the default
--   <a>Normalize</a> instance. It may be a useful building block when
--   writing your own instances.
defaultNormalizeRecursively :: Normalize a => a -> a

-- | When writing your own generic functions for <a>Normalize</a> you may
--   need to access the class methods through this datatype rather than
--   directly.
data NormalizeD a
NormalizeD :: (a -> a) -> (a -> a) -> NormalizeD a
normalizeD :: NormalizeD a -> a -> a
normalizeRecursivelyD :: NormalizeD a -> a -> a

-- | When writing your own generic functions for <a>Normalize</a> you may
--   need this, the proxy value.
normalizeProxy :: Proxy NormalizeD
instance [overlap ok] Data NormalizeD a => Normalize a
instance [overlap ok] Normalize t => Sat (NormalizeD t)

module Happstack.Data.Migrate

-- | Migrate instances are needed to allow upgrades of MACID state. It
--   should be declared as instance Migrate Old New where migrate =
--   transition_function
class Migrate a b
migrate :: Migrate a b => a -> b


-- | Provides default values for Haskell datatypes.
module Happstack.Data.Default

-- | The <a>Default</a> class provides a <a>defaultValue</a> value, which
--   is the default value for that type.
--   
--   There is no instance for arbitrary types by default, but if you
--   declare an instance without providing the value then one will be built
--   using the first constructor. <a>defaultValue</a> is used to provide
--   values for any arguments of the constructor.
--   
--   If you want an instance for all types then import
--   <a>Happstack.Data.Default.Generic</a>.
class Data DefaultD a => Default a where defaultValue = defaultDefaultValue
defaultValue :: Default a => a

-- | This is the <a>defaultValue</a> that is used in an instance if you
--   don't specify one. It may be a useful building block when writing your
--   own instances.
defaultDefaultValue :: (Data DefaultD a, Default a) => a

-- | When writing your own generic functions for <a>Default</a> you may
--   need to access the class method through this datatype rather than
--   directly.
data DefaultD a
DefaultD :: a -> DefaultD a
defaultValueD :: DefaultD a -> a

-- | When writing your own generic functions for <a>Default</a> you may
--   need this, the proxy value.
defaultProxy :: Proxy DefaultD
instance [overlap ok] (Data DefaultD a, Ord a) => Default (Set a)
instance [overlap ok] (Data DefaultD a, Data DefaultD b, Ord a) => Default (Map a b)
instance [overlap ok] Default a => Default (ForeignPtr a)
instance [overlap ok] Default Text
instance [overlap ok] Default Text
instance [overlap ok] Default ByteString
instance [overlap ok] Default a => Default (Maybe a)
instance [overlap ok] Default Char
instance [overlap ok] (Default a, Default b, Default c, Default d) => Default (a, b, c, d)
instance [overlap ok] (Default a, Default b, Default c) => Default (a, b, c)
instance [overlap ok] (Default a, Default b) => Default (a, b)
instance [overlap ok] Default ()
instance [overlap ok] (Default a, Default b) => Default (Either a b)
instance [overlap ok] Default Double
instance [overlap ok] Default Float
instance [overlap ok] Default Integer
instance [overlap ok] Default Word64
instance [overlap ok] Default Word32
instance [overlap ok] Default Word16
instance [overlap ok] Default Word8
instance [overlap ok] Default Word
instance [overlap ok] Default Int64
instance [overlap ok] Default Int32
instance [overlap ok] Default Int16
instance [overlap ok] Default Int8
instance [overlap ok] Default Int
instance [overlap ok] Data DefaultD a => Default [a]
instance [overlap ok] Default t => Sat (DefaultD t)


-- | Concisely specify which classes to derive for your datatypes. As well
--   as the standard derivable classes, it can also derive syb-with-class's
--   <a>Data</a> class and Happstack.Data.Default's <a>Default</a> class.
module Happstack.Data.DeriveAll

-- | The <a>deriveAll</a> function takes a list of classes to derive and a
--   block of declarations. It will additionally derive instances for
--   Typeable, Old.Data and New.Data.
--   
--   Example:
--   
--   <pre>
--   $( deriveAll [''Show, ''Eq, ''Default] [d|
--          data Foo a = Foo a
--          data Bar = Baz | Quux
--    |] )
--   </pre>
deriveAll :: [Name] -> Q [Dec] -> Q [Dec]

-- | Derives instances for syb-with-class's Data class and
--   Happstack.Data.Default's Default class. The list of names should be of
--   the form [''Foo,''Bar,..]
deriveNewData :: [Name] -> Q [Dec]

-- | Derives instances for syb-with-class's Data class only. The list of
--   names should be of the form [''Foo,''Bar,..]
deriveNewDataNoDefault :: [Name] -> Q [Dec]


-- | Provides a <a>Default</a> instance for all types.
--   <a>defaultDefaultValue</a> is used for <a>defaultValue</a>.
module Happstack.Data.Default.Generic
instance [overlap ok] Data DefaultD a => Default a

module Happstack.Data.Xml

-- | Element recursively represents XML data. Elem n elems -&gt; XML
--   element with name n and described by elems. Note that elems contains
--   sub-elements as well as the attributes or literal data of the element.
--   CData d -&gt; Literal string data Attr key val -&gt; Key/Value pair of
--   the element attribute.
data Element
Elem :: String -> [Element] -> Element
CData :: String -> Element
Attr :: String -> String -> Element

-- | insEl a b will convert a to xml and insert it into the xml of b if b
--   results in an Elem constructor.
insEl :: (Data XmlD a, Default a, Data NormalizeD a, Data XmlD b, Default b, Data NormalizeD b) => a -> b -> Element

-- | Wrapper around the Xml class method readXml. The Rigidity will
--   determine the behavior in the case of a failed parsing: Rigid will
--   return Nothing and Flexible will return Identity (defaultValue)
fromXml :: (Monad m, Xml a) => Rigidity m -> [Element] -> m a
data Other b
Other :: a -> Other b
NoOther :: Other b

-- | Identical to toXml from Xml class except that it will remove
--   attributes named haskellType or haskellTypeVersion
toPublicXml :: Xml a => a -> [Element]

-- | Rigidity is used to designate the result of a failed Xml parsing.
data Rigidity m
Rigid :: Rigidity Maybe
Flexible :: Rigidity Identity
data XmlD a
XmlD :: (a -> [Element]) -> (forall m. Monad m => Rigidity m -> ReadM m a) -> (forall m. Monad m => Rigidity m -> ReadM Maybe a) -> XmlD a
toXmlD :: XmlD a -> a -> [Element]
readMXmlD :: XmlD a -> forall m. Monad m => Rigidity m -> ReadM m a
readMXmlNoRootDefaultD :: XmlD a -> forall m. Monad m => Rigidity m -> ReadM Maybe a
class (Data XmlD a, Default a, Normalize a) => Xml a where toXml = defaultToXml readXml = defaultReadXml readXml' = defaultReadXml' normalizeXml _ = id version _ = Just "0" otherVersion _ = NoOther typ _ = dataTypeName (dataTypeOf xmlProxy (undefined :: a))
toXml :: Xml a => a -> [Element]
readXml :: (Xml a, Monad m) => Rigidity m -> [Element] -> Maybe ([Element], a)
readXml' :: (Xml a, Monad m) => Rigidity m -> [Element] -> Maybe ([Element], a)
normalizeXml :: Xml a => a -> [Element] -> [Element]
version :: Xml a => a -> Maybe String
otherVersion :: Xml a => a -> Other a
typ :: Xml a => a -> String

-- | Used as a type witness for usage with syb-with-class Data class.
xmlProxy :: Proxy XmlD

-- | Converts the argument to an Xml element with the constructor name as
--   the root of the Elem and the additional attributes corresponding to
--   haskellType and haskellTypeVersion added
defaultToXml :: Xml t => t -> [Element]

-- | Generically traverses an instance of Xml and converts it into a list
--   of elements
transparentToXml :: Xml t => t -> [Element]

-- | Attempts to parse the set of elements and return the first constructor
--   it can successfully parse of the inferred type.
transparentReadXml :: (Monad m, Xml t) => Rigidity m -> [Element] -> Maybe ([Element], t)

-- | Create an Xml instance using transparentToXml and transparentReadXml
transparentXml :: Name -> Q [Dec]
defaultReadXml :: (Monad m, Xml t) => Rigidity m -> [Element] -> Maybe ([Element], t)
defaultReadXml' :: (Monad m, Xml t) => Rigidity m -> [Element] -> Maybe ([Element], t)
readXmlWith :: Xml t => (Rigidity m -> Element -> Maybe t) -> Rigidity m -> [Element] -> Maybe ([Element], t)
readVersionedElement :: (Monad m, Xml t) => Rigidity m -> Element -> Maybe t

-- | Matches the provided string to the key of an attribute. Returns False
--   if any other Element constructor is given.
isTheAttr :: String -> Element -> Bool

-- | Fetch the value of the given attribute if present, if not present will
--   return Nothing
getAttr :: String -> [Element] -> Maybe (String, [Element])

-- | Attribute used for Xml class version information
versionAttr :: String

-- | Attribute used for recording the actual Haskell type in the xml
--   serialization
typeAttr :: String
readElement :: (Monad m, Xml t) => Rigidity m -> Element -> Maybe t

-- | aConstrFromElements will return the results of the first constructor
--   that parses correctly.
aConstrFromElements :: (Monad m, Xml t) => Rigidity m -> [Constr] -> [Element] -> Maybe ([Element], t)

-- | Like constrFromElements but does not allow defaulting in case of a
--   parse error.
constrFromElementsNoRootDefault :: (Monad m, Xml t) => Rigidity m -> Constr -> [Element] -> Maybe ([Element], t)

-- | Attempts to parse the given elements to build the particular type
--   given by the constructor argument.
constrFromElements :: (Monad m, Xml t) => Rigidity m -> Constr -> [Element] -> m ([Element], t)

-- | Returns the elements currently in the state
getXmls :: Monad m => ReadM m [Element]

-- | Sets the state of the xml parsing to the given value
putXmls :: Monad m => [Element] -> ReadM m ()

-- | Attempts to parse the current set of elements. If it fails the
--   behavior is dependent on the Rigidity. If it is Rigid, then it will
--   return Nothing but if it is Flexible it will return the defaultValue.
--   If the parsing succeeds, it will return the value and store the
--   remaining XML elements in the parser state.
readMXml :: (Monad m, Xml a) => Rigidity m -> ReadM m a

-- | Identical to readMXml except that in the case of a failed parsing it
--   will not use defaultValue.
readMXmlNoRootDefault :: (Monad m, Xml a) => Rigidity m -> ReadM Maybe a
xmlAttr :: Name -> Q [Dec]

-- | xmlShowCData lifted to act on lists
xmlShowCDatas :: [Name] -> Q [Dec]

-- | automatically creates an Xml definition for a type that is an instance
--   of Show and Read. This will result in an instance that converts the
--   type to and from CData.
xmlShowCData :: Name -> Q [Dec]

-- | xmlCDataLists lifted to act on lists
xmlCDataLists :: [Name] -> Q [Dec]

-- | Creates an instance similar to xmlShowCData except for lists of the
--   provided type
xmlCDataList :: Name -> Q [Dec]

-- | Replaces commas in the string with single spaces
noCommas :: String -> String

-- | Throws an error when called
typeNotValue :: Xml a => a -> a

module Happstack.Data.Pairs

-- | Converts lists of string pairs into a list of Elements. The basic
--   structure is pairsToXml [(<a>foo</a>,<a>bar</a>)] = [Elem <a>foo</a>
--   [CData <a>bar</a>]] pairsToXml [(<a>foo/bar</a>,<a>baz</a>)] = [Elem
--   <a>foo</a> [Elem <a>bar</a> [CData <a>baz</a>]]]
pairsToXml :: Pairs -> [Element]

-- | Converts a list of Elements to a list of String pairs. xmlToPairs
--   [CData _] = error xmlToPairs [Elem <a>foo</a> [CData <a>bar</a>]] =
--   [(<a>foo</a>,<a>bar</a>)] xmlToPairs [Elem <a>foo</a> [Elem <a>bar</a>
--   [CData <a>baz</a>]]] = [(<a>foo/bar</a>,<a>baz</a>)] xmlToPairs .
--   pairsToXml = id
xmlToPairs :: [Element] -> Pairs

-- | Creates the Xml structure corresponding to the specification of an
--   HTML form. The provided pairs should be the spec of the inputs to the
--   form.
pairsToHTMLForm :: String -> String -> String -> Pairs -> [Element]

-- | Equivalent to pairsToHTMLForm but first converts the Xml instance to
--   list of pairs.
xmlToHTMLForm :: (Xml a, Show a, Data a, Eq a) => String -> String -> String -> a -> [Element]
toPairsX :: (Xml a, Show a, Data a, Eq a) => a -> Pairs

-- | Equivalent to pairsToHTMLForm but first converts the Xml instance to
--   list of pairs. An alias for xmlToHTMLForm currently.
toHTMLForm :: (Xml a, Show a, Data a, Eq a) => String -> String -> String -> a -> [Element]
type Pairs = [(String, String)]
class (Xml x, Show x, Data x) => AsPairs x
toPairs :: AsPairs x => x -> Pairs
fromPairs :: AsPairs x => Pairs -> Maybe x
instance [overlap ok] Data Pass
instance [overlap ok] Show Pass
instance [overlap ok] Eq Pass
instance [overlap ok] Data User
instance [overlap ok] Show User
instance [overlap ok] Eq User
instance [overlap ok] Data UserInfo
instance [overlap ok] Show UserInfo
instance [overlap ok] Eq UserInfo
instance [overlap ok] (Data ctx String, Sat (ctx Pass), Sat (ctx String)) => Data ctx Pass
instance [overlap ok] Typeable Pass
instance [overlap ok] (Data ctx String, Sat (ctx User), Sat (ctx String)) => Data ctx User
instance [overlap ok] Typeable User
instance [overlap ok] (Data ctx User, Data ctx Pass, Sat (ctx UserInfo), Sat (ctx User), Sat (ctx Pass)) => Data ctx UserInfo
instance [overlap ok] Typeable UserInfo
instance [overlap ok] Default Pass
instance [overlap ok] Default User
instance [overlap ok] Default UserInfo
instance [overlap ok] (Xml a, Show a, Data a, Eq a) => AsPairs a

module Happstack.Data.Proxy

-- | Proxy is empty and is used as a transport of a phantom type
data Proxy t_as6Y
Proxy :: Proxy t_as6Y
dataType_sybwc_Proxy_1627498014 :: DataType
constr_sybwc_Proxy_1627498015 :: Constr

-- | Creates the Proxy with a type matching the argument
proxy :: t -> Proxy t

-- | Returns bottom
unProxy :: Proxy t -> t

-- | Acts as id except for providing type restrictions
asProxyType :: t -> Proxy t -> t
instance [overlap ok] Data t0 => Data (Proxy t0)
instance [overlap ok] Read (Proxy t0)
instance [overlap ok] Show (Proxy t0)
instance [overlap ok] (Data ctx t0, Sat (ctx (Proxy t0))) => Data ctx (Proxy t0)
instance [overlap ok] Typeable1 Proxy
instance [overlap ok] Default t0 => Default (Proxy t0)

module Happstack.Data.Serialize
class (Typeable a, Version a) => Serialize a
getCopy :: Serialize a => Contained (Get a)
putCopy :: Serialize a => a -> Contained Put

-- | The Version type class is used to describe whether a type is
--   fundamental or if it is meant to extend another type. For a user
--   defined type that does not extend any others, one can use the default
--   instance of Version, e.g. <tt>instance Version MyType</tt> to define
--   it has having a version id of 0 and previous type.
class Version a where mode = Versioned 0 Nothing
mode :: Version a => Mode a

-- | Migrate instances are needed to allow upgrades of MACID state. It
--   should be declared as instance Migrate Old New where migrate =
--   transition_function
class Migrate a b
migrate :: Migrate a b => a -> b
data Mode a

-- | Data layout won't change. Used for types like Int and Char.
Primitive :: Mode a
Versioned :: (VersionId a) -> (Maybe (Previous a)) -> Mode a
data Contained a

-- | Lifts the provided value into Contained
contain :: a -> Contained a

-- | Creates a Mode that is a new version of the type carried by the
--   provided proxy and with the provided version number. Note that since
--   VersionId is an instance of Num that you may use int literals when
--   calling extension, e.g. <tt>extension 1 (Proxy :: Proxy OldState)</tt>
extension :: (Serialize b, Migrate b a) => VersionId a -> Proxy b -> Mode a

-- | Equivalent of Data.Binary.get for instances of Serialize Takes into
--   account versioning of types.
safeGet :: Serialize a => Get a

-- | Equivalent of Data.Binary.put for instances of Serialize. Takes into
--   account versioning of types.
safePut :: Serialize a => a -> Put
getSafeGet :: Serialize a => Get (Get a)
getSafePut :: Serialize a => PutM (a -> Put)

-- | Pure version of <a>safePut</a>. Serializes to a ByteString
serialize :: Serialize a => a -> ByteString

-- | Pure version of <a>safeGet</a>. Parses a ByteString into the expected
--   type and a remainder.
deserialize :: Serialize a => ByteString -> (a, ByteString)

-- | Version lookups
collectVersions :: (Typeable a, Version a) => Proxy a -> [ByteString]

-- | Uniform container for any serialized data. It contains a string rep of
--   the type and the actual data serialized to a byte string.
data Object

-- | Serializes data and stores it along with its type name in an Object
mkObject :: Serialize a => a -> Object

-- | <a>deserialize</a> specialized to Objects
deserializeObject :: ByteString -> (Object, ByteString)

-- | Attempts to convert an Object back into its base type. If the
--   conversion fails <a>error</a> will be called.
parseObject :: Serialize a => Object -> a
showQualifiedTypeRep :: TypeRep -> String
instance [overlap ok] Typeable Object
instance [overlap ok] Num (VersionId a)
instance [overlap ok] Read (VersionId a)
instance [overlap ok] Show (VersionId a)
instance [overlap ok] Eq (VersionId a)
instance [overlap ok] Show Object
instance [overlap ok] Serialize Object
instance [overlap ok] Version Object
instance [overlap ok] Serialize AbsoluteTime
instance [overlap ok] Version AbsoluteTime
instance [overlap ok] Serialize NominalDiffTime
instance [overlap ok] Version NominalDiffTime
instance [overlap ok] Serialize DiffTime
instance [overlap ok] Version DiffTime
instance [overlap ok] Serialize LocalTime
instance [overlap ok] Version LocalTime
instance [overlap ok] Serialize ZonedTime
instance [overlap ok] Version ZonedTime
instance [overlap ok] Serialize TimeOfDay
instance [overlap ok] Version TimeOfDay
instance [overlap ok] Serialize TimeZone
instance [overlap ok] Version TimeZone
instance [overlap ok] Serialize UTCTime
instance [overlap ok] Version UTCTime
instance [overlap ok] Serialize UniversalTime
instance [overlap ok] Version UniversalTime
instance [overlap ok] Serialize Day
instance [overlap ok] Version Day
instance [overlap ok] Serialize Text
instance [overlap ok] Version Text
instance [overlap ok] Serialize Text
instance [overlap ok] Version Text
instance [overlap ok] Serialize a => Serialize (IntMap a)
instance [overlap ok] Version (IntMap a)
instance [overlap ok] (Serialize a, Serialize b, Ord a) => Serialize (Map a b)
instance [overlap ok] Version (Map a b)
instance [overlap ok] (Serialize a, Ord a) => Serialize (Set a)
instance [overlap ok] Version (Set a)
instance [overlap ok] Serialize a => Serialize (Maybe a)
instance [overlap ok] Version (Maybe a)
instance [overlap ok] Serialize a => Serialize [a]
instance [overlap ok] Version [a]
instance [overlap ok] Typeable a => Serialize (Proxy a)
instance [overlap ok] Version (Proxy a)
instance [overlap ok] (Serialize a, Serialize b, Serialize c, Serialize d, Serialize e) => Serialize (a, b, c, d, e)
instance [overlap ok] Version (a, b, c, d, e)
instance [overlap ok] (Serialize a, Serialize b, Serialize c, Serialize d) => Serialize (a, b, c, d)
instance [overlap ok] Version (a, b, c, d)
instance [overlap ok] (Serialize a, Serialize b, Serialize c) => Serialize (a, b, c)
instance [overlap ok] Version (a, b, c)
instance [overlap ok] (Serialize a, Serialize b) => Serialize (a, b)
instance [overlap ok] Version (a, b)
instance [overlap ok] (Serialize a, Serialize b) => Serialize (Either a b)
instance [overlap ok] Version (Either a b)
instance [overlap ok] Serialize Bool
instance [overlap ok] Version Bool
instance [overlap ok] Serialize ()
instance [overlap ok] Version ()
instance [overlap ok] (Integral a, Serialize a) => Serialize (Ratio a)
instance [overlap ok] Typeable a => Version (Ratio a)
instance [overlap ok] Serialize Int64
instance [overlap ok] Version Int64
instance [overlap ok] Serialize Int32
instance [overlap ok] Version Int32
instance [overlap ok] Serialize Int16
instance [overlap ok] Version Int16
instance [overlap ok] Serialize Int8
instance [overlap ok] Version Int8
instance [overlap ok] Serialize Ordering
instance [overlap ok] Version Ordering
instance [overlap ok] Serialize Word64
instance [overlap ok] Version Word64
instance [overlap ok] Serialize Word32
instance [overlap ok] Version Word32
instance [overlap ok] Serialize Word16
instance [overlap ok] Version Word16
instance [overlap ok] Serialize Word8
instance [overlap ok] Version Word8
instance [overlap ok] Serialize Char
instance [overlap ok] Version Char
instance [overlap ok] Serialize ByteString
instance [overlap ok] Version ByteString
instance [overlap ok] Serialize ByteString
instance [overlap ok] Version ByteString
instance [overlap ok] Serialize Double
instance [overlap ok] Version Double
instance [overlap ok] Serialize Float
instance [overlap ok] Version Float
instance [overlap ok] Serialize Integer
instance [overlap ok] Version Integer
instance [overlap ok] Serialize Int
instance [overlap ok] Version Int
instance [overlap ok] Binary (VersionId a)

module Happstack.Data.SerializeTH

-- | Derives an instance of Serialize for the provided type Should work in
--   most cases if the type is already and instance of Version. Ex:
--   <tt>$(deriveSerialize ''Foo)</tt>
deriveSerialize :: Name -> Q [Dec]

-- | Derives Serialize for a list of types
deriveSerializeFor :: [Name] -> Q [Dec]

module Happstack.Data
