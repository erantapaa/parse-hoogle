-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A library to work with, or as, a logstash server
--   
@package hslogstash
@version 0.3.7


-- | This module is not very well named, as it has almost nothing to do
--   with Logstash. It is used to define counters that will then be logged
--   by collectd.
--   
--   You should configure collectd to create a Unix socket :
--   
--   <pre>
--   LoadPlugin unixsock
--   
--   &lt;Plugin "unixsock"&gt;
--      SocketFile "/var/run/collectd-unixsock"
--      SocketGroup "collectdsocket"
--      SocketPerms "0660"
--   &lt;/Plugin&gt;
--   </pre>
module Logstash.Counter

-- | The opaque counter type. It is actually just a <a>TVar</a>
--   <a>Integer</a>.
data Counter

-- | Gives you a new empty counter.
newCounter :: IO Counter

-- | This is a conduits-specific function that will increase a counter for
--   each piece of data that traverses this conduit. It will not alter the
--   data.
incrementCounterConduit :: (Monad m, MonadIO m) => Counter -> Conduit a m a

-- | Increments a counter.
incrementCounter :: Counter -> IO ()

-- | Retrieve the current value of a counter.
readCounter :: Counter -> IO Integer

-- | This registers a counter to a Collectd server. This can be used in
--   this way :
--   
--   <pre>
--   counter2collectd nbmsg "/var/run/collectd-unixsock" nodename "logstash-shipper" "messages"
--   </pre>
counter2collectd :: Counter -> FilePath -> String -> String -> String -> IO ()


-- | Various conduit functions, mostly related to grouping or separating
--   the items handled by conduits.
module Data.Conduit.Misc

-- | Converts a stream of lists into a stream of single elements.
concat :: Monad m => Conduit [a] m a

-- | Converts a stream of [a] into a stream of (Flush a). This is done by
--   sending a Flush when the input is the empty list, or that we reached a
--   certain threshold
simpleConcatFlush :: Monad m => Int -> Conduit [a] m (Flush a)

-- | This is a more general version of <a>simpleConcatFlush</a>, where you
--   provide your own fold.
concatFlush :: Monad m => b -> (b -> a -> ConduitM [a] (Flush a) m b) -> Conduit [a] m (Flush a)

-- | A generalized version of <a>simpleConcatFlush</a> where some value is
--   summed and the <a>Flush</a> is sent when it reaches a threshold.
concatFlushSum :: (Num n, Ord n, Monad m) => (a -> n) -> n -> Conduit [a] m (Flush a)

-- | Regroup a stream of (Flush a) into a stream of lists, using
--   <a>Flush</a> as the separator
groupFlush :: Monad m => Conduit (Flush a) m [a]

-- | Analogous to maybe, but for chunks
mchunk :: b -> (a -> b) -> Flush a -> b

-- | Like mapMaybe, but in a Flush. Will not touch the Flush values.
mapFlushMaybe :: Monad m => (a -> Maybe b) -> Conduit (Flush a) m (Flush b)


-- | <pre>
--   WARNING: executables using this function must be compiled with -threaded
--   </pre>
--   
--   These functions let you connect several sinks to a single source,
--   according to a branching strategy. For example :
--   
--   <pre>
--   module Main where
--   
--   import Data.Conduit.Branching
--   import Data.Conduit
--   import qualified Data.Conduit.List as CL
--   import Control.Monad.IO.Class
--   
--   src :: Monad m =&gt; Producer m (Either Int String)
--   src = CL.sourceList [Left 5, Left 4, Right "five", Right "four"]
--   
--   sinkString :: (Monad m, MonadIO m) =&gt; Sink (Either Int String) m ()
--   sinkString = CL.mapM_ $ (Right x) -&gt; liftIO (putStrLn ("This is a string: " ++ x))
--   
--   sinkInt :: (Monad m, MonadIO m) =&gt; Sink (Either Int String) m ()
--   sinkInt = CL.mapM_ $ (Left x) -&gt; liftIO (putStrLn ("This is an integer: " ++ show x))
--   
--   sinkLog :: (Monad m, MonadIO m) =&gt; Sink (Either Int String) m ()
--   sinkLog = CL.mapM_ (liftIO . putStrLn . ("Raw logging: " ++) . show)
--   
--   main :: IO ()
--   main = branchConduits src branching [sinkInt, sinkString, sinkLog]
--       where
--           branching (Left _) = [0,2]
--           branching (Right _) = [1,2]
--   </pre>
module Data.Conduit.Branching

-- | Creates the <i>plumbing</i> that might be used to connect several
--   conduits together, based on a branching function.
mkBranchingConduit :: MonadResource m => Int -> (a -> [Int]) -> IO (Sink a m (), [Source m a])

-- | A higher level function. Given a source, a branching function and a
--   list of sinks, this will run the conduits until completion.
branchConduits :: Source (ResourceT IO) a -> (a -> [Int]) -> [Sink a (ResourceT IO) ()] -> IO ()


-- | Network conduits that will retry sending messages forever
module Data.Conduit.Network.Retry

-- | Tentative <i>safe</i> <a>Sink</a> for a <a>Socket</a>. It should try
--   reopening the <a>Socket</a> every time the call to <a>sendAll</a>
--   fails. This means that some bytes might be sent multiple times, if the
--   socket fails in the middle of the sendAll call. This is targeted at
--   protocols where only a full message makes sense.
sinkSocketRetry :: MonadResource m => IO Socket -> Int -> IO () -> Consumer ByteString m ()

-- | A specialization of the previous Sink that opens a TCP connection.
tcpSinkRetry :: MonadResource m => ByteString -> Int -> Int -> IO () -> Consumer ByteString m ()


-- | Quick conduit for reading from Redis lists. Not tested much, and
--   probably quite slow.
module Data.Conduit.Redis

-- | This is a source that pops elements from a Redis list. It is capable
--   of poping several elements at once, and will return lists of
--   ByteStrings. You might then use <a>concat</a> or the flushing
--   facilities in <a>Data.Conduit.Misc</a> to work with individual
--   elements.
redisSource :: MonadResource m => HostName -> Int -> ByteString -> Int -> Integer -> Source m [ByteString]

-- | A Sink that will let you write ByteStrings to a redis queue. It can be
--   augmented with a logging function, that will be able to report errors.
redisSink :: MonadResource m => HostName -> Int -> ByteString -> Maybe (ByteString -> IO ()) -> Sink ByteString m ()


-- | Datatypes, helper functions, and JSON instances for Logstash messages.
module Logstash.Message

-- | The Logstash message, as described in
--   <a>https://github.com/logstash/logstash/wiki/logstash's-internal-message-format</a>.
--   Please note that it is good practice to forget about the timestamp
--   when creating messages (set <a>logstashTime</a> to <a>Nothing</a>), as
--   it should be a responsability of the Logstash server to add it.
data LogstashMessage
LogstashMessage :: Text -> Text -> [Text] -> Value -> Text -> Maybe UTCTime -> LogstashMessage
logstashType :: LogstashMessage -> Text
logstashSource :: LogstashMessage -> Text
logstashTags :: LogstashMessage -> [Text]
logstashFields :: LogstashMessage -> Value
logstashContent :: LogstashMessage -> Text
logstashTime :: LogstashMessage -> Maybe UTCTime

-- | As the name implies, this creates a dummy Logstash message, only
--   updating the message field.
emptyLSMessage :: Text -> LogstashMessage

-- | This formats an UTCTime in what logstash expects
logstashTimestamp :: UTCTime -> Text

-- | This parses the logstash time format.
parseLogstashTime :: Text -> Maybe UTCTime

-- | This will try to convert an arbitrary JSON value into a
--   <a>LogstashMessage</a>.
value2logstash :: Value -> Maybe LogstashMessage

-- | Adds the current timestamp if it is not provided.
addLogstashTime :: LogstashMessage -> IO LogstashMessage

-- | Adds a tag to a logstash message.
addLogstashTag :: Text -> LogstashMessage -> LogstashMessage
instance Show LogstashMessage
instance Eq LogstashMessage
instance ToJSON LogstashMessage
instance FromJSON LogstashMessage


-- | This module needs a lot of work. It will contain all the functions
--   that are needed to send some <a>LogstashMessage</a> to a Logstash
--   server.
module Logstash.IO

-- | This very simple function lets you send a single message to a Logstash
--   server, using the tcp input, configured in the following way:
--   
--   <pre>
--   input {
--     tcp {
--       debug        =&gt; "true"
--       port         =&gt; "12345"
--       data_timeout =&gt; -1
--       format       =&gt; "json_event"
--       type         =&gt; "somemessages"
--     }
--   }
--   </pre>
sendSingleMessage :: HostName -> PortID -> LogstashMessage -> IO ()


-- | This module exports <a>Conduit</a> interfaces to ElasticSearch. It has
--   been used intensively in production for several month now, but at a
--   single site.
module Data.Conduit.ElasticSearch

-- | Takes a <a>LogstashMessage</a>, and returns the result of the
--   ElasticSearch request along with the value in case of errors, or
--   ElasticSearch's values in case of success.
esConduit :: MonadResource m => Maybe Request -> ByteString -> Int -> Text -> Conduit [LogstashMessage] m [Either (LogstashMessage, Value) Value]

-- | A source of Logstash messages generated from an ElasticSearch query.
esSearchSource :: MonadResource m => Maybe Request -> ByteString -> Int -> ByteString -> Value -> Int -> Int -> Producer m (Either Value [LogstashMessage])

-- | Use this function for 'scanning' requests, using the scroll feature.
esScan :: Maybe Request -> ByteString -> Int -> ByteString -> Int -> Producer (ResourceT IO) (Either Value [Value])
instance Show SearchObject
instance Show Hits
instance Show SearchResponse
instance FromJSON SearchResponse
instance FromJSON Hits
instance FromJSON SearchObject


-- | Receive logstash messages from the network, and process them with a
--   conduit.
module Data.Conduit.Logstash

-- | This creates a logstash network listener, given a TCP port. It will
--   try to decode the Bytestring as UTF-8, and, if it fails, as Latin1.
logstashListener :: Int -> Sink (Either ByteString LogstashMessage) (ResourceT IO) () -> IO ()

-- | Decodes JSON data from ByteStrings that can be encoded in UTF-8 or
--   latin1.
tryDecode :: FromJSON a => ByteString -> Either ByteString a


-- | A firehose conduit, spawning a web server that will allow for the
--   observation of the messages.
module Data.Conduit.FireHose

-- | A web server will be launched on the specified port. Clients can
--   request URLs of the form /type1,type2,type3. They will be fed all
--   <a>LogstashMessage</a> matching one of the given types.
--   
--   Here is a sample usage :
--   
--   <pre>
--   -- run the fire hose on port 13400
--   fh &lt;- fireHose 13400 10
--   logstashListener lport (printErrors =$ CL.mapM (liftIO . addLogstashTime) -- add the time
--                                       =$ fh
--                                       =$ CL.map (BSL.toStrict . encode) -- turn into a bytestring
--                                       =$ redisSink host port queue (Just logfunc)) -- store to redis
--   </pre>
fireHose :: MonadIO m => Int -> Int -> IO (Conduit LogstashMessage m LogstashMessage)
