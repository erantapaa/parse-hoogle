-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Iteratee-based I/O
--   
--   The Iteratee monad provides strict, safe, and functional I/O. In
--   addition to pure Iteratee processors, file IO and combinator functions
--   are provided. See <tt>Data.Iteratee</tt> for full documentation.
@package iteratee
@version 0.8.9.6

module Data.Iteratee.IO.Posix
type FileOffset = COff

-- | Alas, GHC provides no function to read from Fd to an allocated buffer.
--   The library function fdRead is not appropriate as it returns a string
--   already. I'd rather get data from a buffer. Furthermore, fdRead (at
--   least in GHC) allocates a new buffer each time it is called. This is a
--   waste. Yet another problem with fdRead is in raising an exception on
--   any IOError or even EOF. I'd rather avoid exceptions altogether.
myfdRead :: Fd -> Ptr CChar -> ByteCount -> IO (Either Errno ByteCount)

-- | The following fseek procedure throws no exceptions.
myfdSeek :: Fd -> SeekMode -> FileOffset -> IO (Either Errno FileOffset)

-- | Haskell representation for <tt>errno</tt> values. The implementation
--   is deliberately exposed, to allow users to add their own definitions
--   of <a>Errno</a> values.
newtype Errno :: *
Errno :: CInt -> Errno

-- | poll if file descriptors have something to read Return the list of
--   read-pending descriptors
select'read'pending :: [Fd] -> IO (Either Errno [Fd])


-- | Monadic Iteratees: incremental input parsers, processors and
--   transformers
--   
--   Support for IO enumerators
module Data.Iteratee.Base.ReadableChunk

-- | Class of streams which can be filled from a <a>Ptr</a>. Typically
--   these are streams which can be read from a file, <tt>Handle</tt>, or
--   similar resource.
class Storable el => ReadableChunk s el | s -> el
readFromPtr :: (ReadableChunk s el, MonadIO m) => Ptr el -> Int -> m s
instance ReadableChunk ByteString Word8
instance ReadableChunk ByteString Word8
instance ReadableChunk [Word] Word
instance ReadableChunk [Word32] Word32
instance ReadableChunk [Word16] Word16
instance ReadableChunk [Word8] Word8
instance ReadableChunk [Char] Char


-- | Monadic Iteratees: incremental input parsers, processors, and
--   transformers
--   
--   Maps over restricted-element containers
module Data.Iteratee.Base.LooseMap

-- | Enable map functions for containers that require class contexts on the
--   element types. For lists, this is identical to plain <a>map</a>.
class LooseMap c el el'
lMap :: LooseMap c el el' => (el -> el') -> c el -> c el'
instance LooseMap [] el el'


-- | Monadic and General Iteratees: Messaging and exception handling.
--   
--   Iteratees use an internal exception handling mechanism that is
--   parallel to that provided by <a>Exception</a>. This allows the
--   iteratee framework to handle its own exceptions outside <tt>IO</tt>.
--   
--   Iteratee exceptions are divided into two categories,
--   <a>IterException</a> and <a>EnumException</a>. <tt>IterExceptions</tt>
--   are exceptions within an iteratee, and <tt>EnumExceptions</tt> are
--   exceptions within an enumerator.
--   
--   Enumerators can be constructed to handle an <a>IterException</a> with
--   <tt>Data.Iteratee.Iteratee.enumFromCallbackCatch</tt>. If the
--   enumerator detects an <tt>iteratee exception</tt>, the enumerator
--   calls the provided exception handler. The enumerator is then able to
--   continue feeding data to the iteratee, provided the exception was
--   successfully handled. If the handler could not handle the exception,
--   the <a>IterException</a> is converted to an <a>EnumException</a> and
--   processing aborts.
--   
--   Exceptions can also be cleared by
--   <tt>Data.Iteratee.Iteratee.checkErr</tt>, although in this case the
--   iteratee continuation cannot be recovered.
--   
--   When viewed as Resumable Exceptions, iteratee exceptions provide a
--   means for iteratees to send control messages to enumerators. The
--   <tt>seek</tt> implementation provides an example.
--   <tt>Data.Iteratee.Iteratee.seek</tt> stores the current iteratee
--   continuation and throws a <a>SeekException</a>, which inherits from
--   <a>IterException</a>. <tt>Data.Iteratee.IO.enumHandleRandom</tt> is
--   constructed with <tt>enumFromCallbackCatch</tt> and a handler that
--   performs an <tt>hSeek</tt>. Upon receiving the <a>SeekException</a>,
--   <tt>enumHandleRandom</tt> calls the handler, checks that it executed
--   properly, and then continues with the stored continuation.
--   
--   As the exception hierarchy is open, users can extend it with custom
--   exceptions and exception handlers to implement sophisticated messaging
--   systems based upon resumable exceptions.
module Data.Iteratee.Exception

-- | Root of the Iteratee exception hierarchy. <tt>IFException</tt> derives
--   from <tt>Control.Exception.SomeException</tt>. <a>EnumException</a>,
--   <a>IterException</a>, and all inheritants are descendents of
--   <a>IFException</a>.
data IFException
IFException :: e -> IFException

-- | Any type that you wish to throw or catch as an exception must be an
--   instance of the <tt>Exception</tt> class. The simplest case is a new
--   exception type directly below the root:
--   
--   <pre>
--   data MyException = ThisException | ThatException
--       deriving (Show, Typeable)
--   
--   instance Exception MyException
--   </pre>
--   
--   The default method definitions in the <tt>Exception</tt> class do what
--   we need in this case. You can now throw and catch
--   <tt>ThisException</tt> and <tt>ThatException</tt> as exceptions:
--   
--   <pre>
--   *Main&gt; throw ThisException `catch` \e -&gt; putStrLn ("Caught " ++ show (e :: MyException))
--   Caught ThisException
--   </pre>
--   
--   In more complicated examples, you may wish to define a whole hierarchy
--   of exceptions:
--   
--   <pre>
--   ---------------------------------------------------------------------
--   -- Make the root exception type for all the exceptions in a compiler
--   
--   data SomeCompilerException = forall e . Exception e =&gt; SomeCompilerException e
--       deriving Typeable
--   
--   instance Show SomeCompilerException where
--       show (SomeCompilerException e) = show e
--   
--   instance Exception SomeCompilerException
--   
--   compilerExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   compilerExceptionToException = toException . SomeCompilerException
--   
--   compilerExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   compilerExceptionFromException x = do
--       SomeCompilerException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make a subhierarchy for exceptions in the frontend of the compiler
--   
--   data SomeFrontendException = forall e . Exception e =&gt; SomeFrontendException e
--       deriving Typeable
--   
--   instance Show SomeFrontendException where
--       show (SomeFrontendException e) = show e
--   
--   instance Exception SomeFrontendException where
--       toException = compilerExceptionToException
--       fromException = compilerExceptionFromException
--   
--   frontendExceptionToException :: Exception e =&gt; e -&gt; SomeException
--   frontendExceptionToException = toException . SomeFrontendException
--   
--   frontendExceptionFromException :: Exception e =&gt; SomeException -&gt; Maybe e
--   frontendExceptionFromException x = do
--       SomeFrontendException a &lt;- fromException x
--       cast a
--   
--   ---------------------------------------------------------------------
--   -- Make an exception type for a particular frontend compiler exception
--   
--   data MismatchedParentheses = MismatchedParentheses
--       deriving (Typeable, Show)
--   
--   instance Exception MismatchedParentheses where
--       toException   = frontendExceptionToException
--       fromException = frontendExceptionFromException
--   </pre>
--   
--   We can now catch a <tt>MismatchedParentheses</tt> exception as
--   <tt>MismatchedParentheses</tt>, <tt>SomeFrontendException</tt> or
--   <tt>SomeCompilerException</tt>, but not other types, e.g.
--   <tt>IOException</tt>:
--   
--   <pre>
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: MismatchedParentheses))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: SomeFrontendException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: SomeCompilerException))
--   Caught MismatchedParentheses
--   *Main&gt; throw MismatchedParentheses <tt>catch</tt> e -&gt; putStrLn ("Caught " ++ show (e :: IOException))
--   *** Exception: MismatchedParentheses
--   </pre>
class (Typeable e, Show e) => Exception e
toException :: Exception e => e -> SomeException
fromException :: Exception e => SomeException -> Maybe e
data EnumException
EnumException :: e -> EnumException

-- | The <tt>iteratee</tt> diverged upon receiving <tt>EOF</tt>.
data DivergentException
DivergentException :: DivergentException

-- | Create an enumerator exception from a <tt>String</tt>.
data EnumStringException
EnumStringException :: String -> EnumStringException

-- | The enumerator received an <a>IterException</a> it could not handle.
data EnumUnhandledIterException
EnumUnhandledIterException :: IterException -> EnumUnhandledIterException

-- | A class for <tt>iteratee exceptions</tt>. Only inheritants of
--   <tt>IterException</tt> should be instances of this class.
class Exception e => IException e where toIterException = IterException fromIterException = fromException . toException
toIterException :: IException e => e -> IterException
fromIterException :: IException e => IterException -> Maybe e

-- | Root of iteratee exceptions.
data IterException
IterException :: e -> IterException

-- | A seek request within an <tt>Iteratee</tt>.
data SeekException
SeekException :: FileOffset -> SeekException

-- | The <tt>Iteratee</tt> needs more data but received <tt>EOF</tt>.
data EofException
EofException :: EofException

-- | An <tt>Iteratee exception</tt> specified by a <tt>String</tt>.
data IterStringException
IterStringException :: String -> IterStringException

-- | Create an <a>EnumException</a> from a string.
enStrExc :: String -> EnumException

-- | Create an <tt>iteratee exception</tt> from a string. This convenience
--   function wraps <a>IterStringException</a> and <a>toException</a>.
iterStrExc :: String -> SomeException

-- | Convert an <a>IterException</a> to an <a>EnumException</a>. Meant to
--   be used within an <tt>Enumerator</tt> to signify that it could not
--   handle the <tt>IterException</tt>.
wrapIterExc :: IterException -> EnumException
iterExceptionToException :: Exception e => e -> SomeException
iterExceptionFromException :: Exception e => SomeException -> Maybe e
instance Typeable IFException
instance Typeable EnumException
instance Typeable DivergentException
instance Typeable EnumStringException
instance Typeable IterException
instance Typeable EnumUnhandledIterException
instance Typeable SeekException
instance Typeable EofException
instance Typeable IterStringException
instance Show DivergentException
instance Show EnumStringException
instance Show EnumUnhandledIterException
instance Show SeekException
instance Show EofException
instance Show IterStringException
instance IException IterStringException
instance Exception IterStringException
instance IException EofException
instance Exception EofException
instance IException SeekException
instance Exception SeekException
instance IException IterException
instance Exception IterException
instance Show IterException
instance Exception EnumUnhandledIterException
instance Exception EnumStringException
instance Exception DivergentException
instance Exception EnumException
instance Show EnumException
instance Exception IFException
instance Show IFException


-- | NullPoint: Pointed types (usually containers) that can be empty.
--   Corresponds to Data.Monoid.mempty
module Data.NullPoint

-- | NullPoint class. Containers that have a null representation,
--   corresponding to Data.Monoid.mempty.
class NullPoint c
empty :: NullPoint c => c
instance NullPoint ByteString
instance NullPoint ByteString
instance NullPoint [a]


-- | Nullable: test if a type (container) is null.
module Data.Nullable

-- | Nullable container class
class NullPoint c => Nullable c
nullC :: Nullable c => c -> Bool
instance Nullable ByteString
instance Nullable ByteString
instance Nullable [a]


-- | Monadic Iteratees: incremental input parsers, processors and
--   transformers
module Data.Iteratee.Base

-- | A stream is a (continuing) sequence of elements bundled in Chunks. The
--   first variant indicates termination of the stream. Chunk a gives the
--   currently available part of the stream. The stream is not terminated
--   yet. The case (null Chunk) signifies a stream with no currently
--   available data but which is still continuing. A stream processor
--   should, informally speaking, ``suspend itself'' and wait for more data
--   to arrive.
data Stream c
EOF :: (Maybe SomeException) -> Stream c
Chunk :: c -> Stream c

-- | Describe the status of a stream of data.
data StreamStatus
DataRemaining :: StreamStatus
EofNoError :: StreamStatus
EofError :: SomeException -> StreamStatus

-- | Monadic iteratee
newtype Iteratee s m a
Iteratee :: (forall r. (a -> Stream s -> m r) -> ((Stream s -> Iteratee s m a) -> Maybe SomeException -> m r) -> m r) -> Iteratee s m a
runIter :: Iteratee s m a -> forall r. (a -> Stream s -> m r) -> ((Stream s -> Iteratee s m a) -> Maybe SomeException -> m r) -> m r

-- | Send <a>EOF</a> to the <tt>Iteratee</tt> and disregard the unconsumed
--   part of the stream. If the iteratee is in an exception state, that
--   exception is thrown with <a>throw</a>. Iteratees that do not terminate
--   on <tt>EOF</tt> will throw <a>EofException</a>.
run :: Monad m => Iteratee s m a -> m a

-- | Run an iteratee, returning either the result or the iteratee
--   exception. Note that only internal iteratee exceptions will be
--   returned; exceptions thrown with <tt>Control.Exception.throw</tt> or
--   <tt>Control.Monad.CatchIO.throw</tt> will not be returned.
--   
--   See <a>IFException</a> for details.
tryRun :: (Exception e, Monad m) => Iteratee s m a -> m (Either e a)

-- | Transform a computation inside an <tt>Iteratee</tt>.

-- | <i>Deprecated: This function will be removed, compare to <a>ilift</a>
--   </i>
mapIteratee :: (NullPoint s, Monad n, Monad m) => (m a -> n b) -> Iteratee s m a -> Iteratee s n b

-- | Lift a computation in the inner monad of an iteratee.
--   
--   A simple use would be to lift a logger iteratee to a monad stack.
--   
--   <pre>
--   logger :: Iteratee String IO ()
--   logger = mapChunksM_ putStrLn
--   
--   loggerG :: MonadIO m =&gt; Iteratee String m ()
--   loggerG = ilift liftIO logger
--   </pre>
--   
--   A more complex example would involve lifting an iteratee to work with
--   interleaved streams. See the example at <a>merge</a>.
ilift :: (Monad m, Monad n) => (forall r. m r -> n r) -> Iteratee s m a -> Iteratee s n a

-- | Lift a computation in the inner monad of an iteratee, while threading
--   through an accumulator.
ifold :: (Monad m, Monad n) => (forall r. m r -> acc -> n (r, acc)) -> acc -> Iteratee s m a -> Iteratee s n (a, acc)
idone :: a -> Stream s -> Iteratee s m a
icont :: (Stream s -> Iteratee s m a) -> Maybe SomeException -> Iteratee s m a
liftI :: (Stream s -> Iteratee s m a) -> Iteratee s m a
idoneM :: Monad m => a -> Stream s -> m (Iteratee s m a)
icontM :: Monad m => (Stream s -> Iteratee s m a) -> Maybe SomeException -> m (Iteratee s m a)

-- | Produce the <a>EOF</a> error message. If the stream was terminated
--   because of an error, keep the error message.
setEOF :: Stream c -> SomeException
instance Typeable1 Stream
instance Typeable StreamStatus
instance Show c => Show (Stream c)
instance Show StreamStatus
instance (MonadBaseControl b m, Nullable s) => MonadBaseControl b (Iteratee s m)
instance (NullPoint s, Nullable s) => MonadTransControl (Iteratee s)
instance (MonadMask m, Nullable s, NullPoint s) => MonadMask (Iteratee s m)
instance (MonadCatch m, Nullable s, NullPoint s) => MonadCatch (Iteratee s m)
instance (MonadThrow m, Nullable s, NullPoint s) => MonadThrow (Iteratee s m)
instance (MonadIO m, Nullable s, NullPoint s) => MonadIO (Iteratee s m)
instance (MonadBase b m, Nullable s, NullPoint s) => MonadBase b (Iteratee s m)
instance NullPoint s => MonadTrans (Iteratee s)
instance (Monad m, Nullable s) => Monad (Iteratee s m)
instance (Functor m, Monad m, Nullable s) => Applicative (Iteratee s m)
instance Functor m => Functor (Iteratee s m)
instance Functor Stream
instance Monoid c => Monoid (Stream c)
instance Eq c => Eq (Stream c)


-- | Monadic and General Iteratees: incremental input parsers, processors
--   and transformers
module Data.Iteratee.Iteratee
type EnumerateeHandler eli elo m a = (Stream eli -> Iteratee eli m a) -> SomeException -> Iteratee elo m (Iteratee eli m a)

-- | Report and propagate an unrecoverable error. Disregard the input first
--   and then propagate the error. This error cannot be handled by
--   <a>enumFromCallbackCatch</a>, although it can be cleared by
--   <a>checkErr</a>.
throwErr :: SomeException -> Iteratee s m a

-- | Report and propagate a recoverable error. This error can be handled by
--   both <a>enumFromCallbackCatch</a> and <a>checkErr</a>.
throwRecoverableErr :: SomeException -> (Stream s -> Iteratee s m a) -> Iteratee s m a

-- | Check if an iteratee produces an error. Returns <tt>Right a</tt> if it
--   completes without errors, otherwise <tt>Left SomeException</tt>.
--   <a>checkErr</a> is useful for iteratees that may not terminate, such
--   as <tt>Data.Iteratee.head</tt> with an empty stream.
checkErr :: NullPoint s => Iteratee s m a -> Iteratee s m (Either SomeException a)

-- | The identity iteratee. Doesn't do any processing of input.
identity :: NullPoint s => Iteratee s m ()

-- | Skip the rest of the stream
skipToEof :: Iteratee s m ()

-- | Get the stream status of an iteratee.
isStreamFinished :: Nullable s => Iteratee s m (Maybe SomeException)

-- | Map a monadic function over the chunks of the stream and ignore the
--   result. Useful for creating efficient monadic iteratee consumers, e.g.
--   
--   <pre>
--   logger = mapChunksM_ (liftIO . putStrLn)
--   </pre>
--   
--   these can be efficiently run in parallel with other iteratees via
--   <tt>Data.Iteratee.ListLike.zip</tt>.
mapChunksM_ :: (Monad m, Nullable s) => (s -> m b) -> Iteratee s m ()

-- | A fold over chunks
foldChunksM :: (Monad m, Nullable s) => (a -> s -> m a) -> a -> Iteratee s m a

-- | Get the current chunk from the stream.
getChunk :: (Nullable s, NullPoint s) => Iteratee s m s

-- | Get a list of all chunks from the stream.
getChunks :: Nullable s => Iteratee s m [s]

-- | Convert one stream into another with the supplied mapping function.
--   This function operates on whole chunks at a time, contrasting to
--   <tt>mapStream</tt> which operates on single elements.
--   
--   <pre>
--   unpacker :: Enumeratee B.ByteString [Word8] m a
--   unpacker = mapChunks B.unpack
--   </pre>
mapChunks :: NullPoint s => (s -> s') -> Enumeratee s s' m a

-- | Convert a stream of <tt>s</tt> to a stream of <tt>s'</tt> using the
--   supplied function.
mapChunksM :: (Monad m, NullPoint s, Nullable s) => (s -> m s') -> Enumeratee s s' m a

-- | Convert one stream into another, not necessarily in lockstep.
--   
--   The transformer mapStream maps one element of the outer stream to one
--   element of the nested stream. The transformer below is more general:
--   it may take several elements of the outer stream to produce one
--   element of the inner stream, or the other way around. The
--   transformation from one stream to the other is specified as Iteratee s
--   m s'.
convStream :: (Monad m, Nullable s) => Iteratee s m s' -> Enumeratee s s' m a

-- | The most general stream converter. Given a function to produce
--   iteratee transformers and an initial state, convert the stream using
--   iteratees generated by the function while continually updating the
--   internal state.
unfoldConvStream :: (Monad m, Nullable s) => (acc -> Iteratee s m (acc, s')) -> acc -> Enumeratee s s' m a
unfoldConvStreamCheck :: (Monad m, Nullable elo) => (((Stream eli -> Iteratee eli m a) -> Maybe SomeException -> Iteratee elo m (Iteratee eli m a)) -> Enumeratee elo eli m a) -> (acc -> Iteratee elo m (acc, eli)) -> acc -> Enumeratee elo eli m a

-- | Collapse a nested iteratee. The inner iteratee is terminated by
--   <tt>EOF</tt>. Errors are propagated through the result.
--   
--   The stream resumes from the point of the outer iteratee; any remaining
--   input in the inner iteratee will be lost. Differs from <a>join</a> in
--   that the inner iteratee is terminated, and may have a different stream
--   type than the result.
joinI :: (Monad m, Nullable s) => Iteratee s m (Iteratee s' m a) -> Iteratee s m a

-- | Lift an iteratee inside a monad to an iteratee.
joinIM :: Monad m => m (Iteratee s m a) -> Iteratee s m a

-- | Each enumerator takes an iteratee and returns an iteratee
--   
--   an Enumerator is an iteratee transformer. The enumerator normally
--   stops when the stream is terminated or when the iteratee moves to the
--   done state, whichever comes first. When to stop is of course up to the
--   enumerator...
type Enumerator s m a = Iteratee s m a -> m (Iteratee s m a)
type Enumeratee sFrom sTo (m :: * -> *) a = Iteratee sTo m a -> Iteratee sFrom m (Iteratee sTo m a)

-- | Applies the iteratee to the given stream. This wraps <a>enumEof</a>,
--   <a>enumErr</a>, and <a>enumPure1Chunk</a>, calling the appropriate
--   enumerator based upon <a>Stream</a>.
enumChunk :: Monad m => Stream s -> Enumerator s m a

-- | The most primitive enumerator: applies the iteratee to the terminated
--   stream. The result is the iteratee in the Done state. It is an error
--   if the iteratee does not terminate on EOF.
enumEof :: Monad m => Enumerator s m a

-- | Another primitive enumerator: tell the Iteratee the stream terminated
--   with an error.
enumErr :: (Exception e, Monad m) => e -> Enumerator s m a

-- | The pure 1-chunk enumerator
--   
--   It passes a given list of elements to the iteratee in one chunk This
--   enumerator does no IO and is useful for testing of base parsing
enumPure1Chunk :: Monad m => s -> Enumerator s m a

-- | Enumerate chunks from a list
enumList :: Monad m => [s] -> Enumerator s m a

-- | Checks if an iteratee has finished.
--   
--   This enumerator runs the iteratee, performing any monadic actions. If
--   the result is True, the returned iteratee is done.
enumCheckIfDone :: Monad m => Iteratee s m a -> m (Bool, Iteratee s m a)

-- | Create an enumerator from a callback function
enumFromCallback :: (Monad m, NullPoint s) => (st -> m (Either SomeException ((Bool, st), s))) -> st -> Enumerator s m a

-- | Create an enumerator from a callback function with an exception
--   handler. The exception handler is called if an iteratee reports an
--   exception.
enumFromCallbackCatch :: (IException e, Monad m, NullPoint s) => (st -> m (Either SomeException ((Bool, st), s))) -> (e -> m (Maybe EnumException)) -> st -> Enumerator s m a

-- | The composition of two enumerators: essentially the functional
--   composition
--   
--   It is convenient to flip the order of the arguments of the composition
--   though: in e1 &gt;&gt;&gt; e2, e1 is executed first
(>>>) :: Monad m => Enumerator s m a -> Enumerator s m a -> Enumerator s m a

-- | Utility function for creating enumeratees. Typical usage is
--   demonstrated by the <tt>breakE</tt> definition.
--   
--   <pre>
--   breakE
--     :: (Monad m, LL.ListLike s el, NullPoint s)
--     =&gt; (el -&gt; Bool)
--     -&gt; Enumeratee s s m a
--   breakE cpred = eneeCheckIfDone (liftI . step)
--    where
--     step k (Chunk s)
--         | LL.null s  = liftI (step k)
--         | otherwise  = case LL.break cpred s of
--           (str', tail')
--             | LL.null tail' -&gt; eneeCheckIfDone (liftI . step) . k $ Chunk str'
--             | otherwise     -&gt; idone (k $ Chunk str') (Chunk tail')
--     step k stream           =  idone (k stream) stream
--   </pre>
eneeCheckIfDone :: (Monad m, NullPoint elo) => ((Stream eli -> Iteratee eli m a) -> Iteratee elo m (Iteratee eli m a)) -> Enumeratee elo eli m a

-- | The same as eneeCheckIfDonePass, with one extra argument: a handler
--   which is used to process any exceptions in a separate method.
eneeCheckIfDoneHandle :: NullPoint elo => EnumerateeHandler eli elo m a -> ((Stream eli -> Iteratee eli m a) -> Maybe SomeException -> Iteratee elo m (Iteratee eli m a)) -> Enumeratee elo eli m a
eneeCheckIfDoneIgnore :: NullPoint elo => ((Stream eli -> Iteratee eli m a) -> Maybe SomeException -> Iteratee elo m (Iteratee eli m a)) -> Enumeratee elo eli m a
eneeCheckIfDonePass :: NullPoint elo => ((Stream eli -> Iteratee eli m a) -> Maybe SomeException -> Iteratee elo m (Iteratee eli m a)) -> Enumeratee elo eli m a

-- | Combine enumeration over two streams. The merging enumeratee would
--   typically be the result of <a>merge</a> or <a>mergeByChunks</a> (see
--   <tt>merge</tt> for example).
mergeEnums :: (Nullable s2, Nullable s1, Monad m) => Enumerator s1 m a -> Enumerator s2 (Iteratee s1 m) a -> Enumeratee s2 s1 (Iteratee s1 m) a -> Enumerator s1 m a

-- | Combines Enumerator which produces stream of <tt>s</tt> and
--   <tt>Enumeratee</tt> which transforms stream of <tt>s</tt> to stream of
--   <tt>s'</tt> to into Enumerator which produces stream of <tt>s'</tt>
($=) :: (Nullable s, Nullable s', Monad m) => (forall a. Enumerator s m a) -> Enumeratee s s' m b -> Enumerator s' m b

-- | Combines an Enumeratee from <tt>s</tt> to <tt>s'</tt> and an Iteratee
--   that consumes <tt>s'</tt> into an Iteratee which consumes <tt>s</tt>
(=$) :: (Nullable s, Nullable s', Monad m) => Enumeratee s s' m a -> Iteratee s' m a -> Iteratee s m a

-- | Enumeratee composition Run the second enumeratee within the first. In
--   this example, stream2list is run within the 'take 10', which is itself
--   run within 'take 15', resulting in 15 elements being consumed
--   
--   <pre>
--   &gt;&gt;&gt; run =&lt;&lt; enumPure1Chunk [1..1000 :: Int] (joinI $ (I.take 15 &gt;&lt;&gt; I.take 10) I.stream2list)
--   [1,2,3,4,5,6,7,8,9,10]
--   </pre>
(><>) :: (Nullable s1, Monad m) => (forall x. Enumeratee s1 s2 m x) -> Enumeratee s2 s3 m a -> Enumeratee s1 s3 m a

-- | enumeratee composition with the arguments flipped, see
--   <a>&gt;&lt;&gt;</a>
(<><) :: (Nullable s1, Monad m) => Enumeratee s2 s3 m a -> (forall x. Enumeratee s1 s2 m x) -> Enumeratee s1 s3 m a

-- | Seek to a position in the stream
seek :: NullPoint s => FileOffset -> Iteratee s m ()
type FileOffset = COff
instance Typeable NotAnException
instance Show NotAnException
instance IException NotAnException
instance Exception NotAnException


-- | Monadic Iteratees: incremental input parsers, processors and
--   transformers
--   
--   This module provides many basic iteratees from which more complicated
--   iteratees can be built. In general these iteratees parallel those in
--   <tt>Data.List</tt>, with some additions.
module Data.Iteratee.ListLike

-- | Check if a stream has received <a>EOF</a>.
isFinished :: Nullable s => Iteratee s m Bool

-- | Read a stream to the end and return all of its elements as a list.
--   This iteratee returns all data from the stream *strictly*.
stream2list :: (Monad m, Nullable s, ListLike s el) => Iteratee s m [el]

-- | Read a stream to the end and return all of its elements as a stream.
--   This iteratee returns all data from the stream *strictly*.
stream2stream :: (Monad m, Nullable s, Monoid s) => Iteratee s m s

-- | Takes an element predicate and returns the (possibly empty) prefix of
--   the stream. None of the characters in the string satisfy the character
--   predicate. If the stream is not terminated, the first character of the
--   remaining stream satisfies the predicate.
--   
--   N.B. <a>breakE</a> should be used in preference to <tt>break</tt>.
--   <tt>break</tt> will retain all data until the predicate is met, which
--   may result in a space leak.
--   
--   The analogue of <tt>List.break</tt>
break :: ListLike s el => (el -> Bool) -> Iteratee s m s

-- | Skip all elements while the predicate is true.
--   
--   The analogue of <tt>List.dropWhile</tt>
dropWhile :: ListLike s el => (el -> Bool) -> Iteratee s m ()

-- | Drop n elements of the stream, if there are that many.
--   
--   The analogue of <tt>List.drop</tt>
drop :: (Nullable s, ListLike s el) => Int -> Iteratee s m ()

-- | Attempt to read the next element of the stream and return it Raise a
--   (recoverable) error if the stream is terminated.
--   
--   The analogue of <tt>List.head</tt>
--   
--   Because <tt>head</tt> can raise an error, it shouldn't be used when
--   constructing iteratees for <tt>convStream</tt>. Use <tt>tryHead</tt>
--   instead.
head :: ListLike s el => Iteratee s m el

-- | Similar to <tt>head</tt>, except it returns <tt>Nothing</tt> if the
--   stream is terminated.
tryHead :: ListLike s el => Iteratee s m (Maybe el)

-- | Attempt to read the last element of the stream and return it Raise a
--   (recoverable) error if the stream is terminated
--   
--   The analogue of <tt>List.last</tt>
last :: (ListLike s el, Nullable s) => Iteratee s m el

-- | Given a sequence of characters, attempt to match them against the
--   characters on the stream. Return the count of how many characters
--   matched. The matched characters are removed from the stream. For
--   example, if the stream contains <tt>abd</tt>, then (heads
--   <tt>abc</tt>) will remove the characters <tt>ab</tt> and return 2.
heads :: (Monad m, Nullable s, ListLike s el, Eq el) => s -> Iteratee s m Int

-- | Look ahead at the next element of the stream, without removing it from
--   the stream. Return <tt>Just c</tt> if successful, return
--   <tt>Nothing</tt> if the stream is terminated by <a>EOF</a>.
peek :: ListLike s el => Iteratee s m (Maybe el)

-- | Return a chunk of <tt>t</tt> elements length while consuming
--   <tt>d</tt> elements from the stream. Useful for creating a 'rolling
--   average' with <a>convStream</a>.
roll :: (Monad m, Functor m, Nullable s, ListLike s el, ListLike s' s) => Int -> Int -> Iteratee s m s'

-- | Return the total length of the remaining part of the stream.
--   
--   This forces evaluation of the entire stream.
--   
--   The analogue of <tt>List.length</tt>
length :: (Num a, ListLike s el) => Iteratee s m a

-- | Get the length of the current chunk, or <tt>Nothing</tt> if
--   <a>EOF</a>.
--   
--   This function consumes no input.
chunkLength :: ListLike s el => Iteratee s m (Maybe Int)

-- | Take <tt>n</tt> elements from the current chunk, or the whole chunk if
--   <tt>n</tt> is greater.
takeFromChunk :: (Nullable s, ListLike s el) => Int -> Iteratee s m s

-- | Takes an element predicate and an iteratee, running the iteratee on
--   all elements of the stream until the predicate is met.
--   
--   the following rule relates <tt>break</tt> to <tt>breakE</tt>
--   <tt>break</tt> pred === <tt>joinI</tt> (<tt>breakE</tt> pred
--   stream2stream)
--   
--   <tt>breakE</tt> should be used in preference to <tt>break</tt>
--   whenever possible.
breakE :: (ListLike s el, NullPoint s) => (el -> Bool) -> Enumeratee s s m a

-- | Read n elements from a stream and apply the given iteratee to the
--   stream of the read elements. Unless the stream is terminated early, we
--   read exactly n elements, even if the iteratee has accepted fewer.
--   
--   The analogue of <tt>List.take</tt>
take :: (Monad m, Nullable s, ListLike s el) => Int -> Enumeratee s s m a

-- | Read n elements from a stream and apply the given iteratee to the
--   stream of the read elements. If the given iteratee accepted fewer
--   elements, we stop. This is the variation of <a>take</a> with the early
--   termination of processing of the outer stream once the processing of
--   the inner stream finished early.
--   
--   Iteratees composed with <a>takeUpTo</a> will consume only enough
--   elements to reach a done state. Any remaining data will be available
--   in the outer stream.
--   
--   <pre>
--   &gt; let iter = do
--   h &lt;- joinI $ takeUpTo 5 I.head
--   t &lt;- stream2list
--   return (h,t)
--   
--   &gt; enumPureNChunk [1..10::Int] 3 iter &gt;&gt;= run &gt;&gt;= print
--   (1,[2,3,4,5,6,7,8,9,10])
--   
--   &gt; enumPureNChunk [1..10::Int] 7 iter &gt;&gt;= run &gt;&gt;= print
--   (1,[2,3,4,5,6,7,8,9,10])
--   </pre>
--   
--   in each case, <tt>I.head</tt> consumes only one element, returning the
--   remaining 4 elements to the outer stream
takeUpTo :: (Monad m, Nullable s, ListLike s el) => Int -> Enumeratee s s m a

-- | Takes an element predicate and returns the (possibly empty) prefix of
--   the stream. All characters in the string will satisfy the character
--   predicate. If the stream is not terminated, the first character of the
--   remaining stream will not satisfy the predicate.
--   
--   The analogue of <tt>List.takeWhile</tt>, see also <tt>break</tt> and
--   <tt>takeWhileE</tt>
takeWhile :: ListLike s el => (el -> Bool) -> Iteratee s m s

-- | Takes an element predicate and an iteratee, running the iteratee on
--   all elements of the stream while the predicate is met.
--   
--   This is preferred to <tt>takeWhile</tt>.
takeWhileE :: (ListLike s el, NullPoint s) => (el -> Bool) -> Enumeratee s s m a

-- | Map the stream: another iteratee transformer Given the stream of
--   elements of the type <tt>el</tt> and the function
--   <tt>(el-&gt;el')</tt>, build a nested stream of elements of the type
--   <tt>el'</tt> and apply the given iteratee to it.
--   
--   The analog of <tt>List.map</tt>
mapStream :: (ListLike (s el) el, ListLike (s el') el', NullPoint (s el), LooseMap s el el') => (el -> el') -> Enumeratee (s el) (s el') m a

-- | Map the stream rigidly.
--   
--   Like <a>mapStream</a>, but the element type cannot change. This
--   function is necessary for <tt>ByteString</tt> and similar types that
--   cannot have <a>LooseMap</a> instances, and may be more efficient.
rigidMapStream :: (ListLike s el, NullPoint s) => (el -> el) -> Enumeratee s s m a

-- | Creates an <tt>enumeratee</tt> with only elements from the stream that
--   satisfy the predicate function. The outer stream is completely
--   consumed.
--   
--   The analogue of <tt>List.filter</tt>
filter :: (Monad m, Functor m, Nullable s, ListLike s el) => (el -> Bool) -> Enumeratee s s m a

-- | Creates an <a>Enumeratee</a> in which elements from the stream are
--   grouped into <tt>sz</tt>-sized blocks. The final block may be smaller
--   than sz.
group :: (ListLike s el, Monad m, Nullable s) => Int -> Enumeratee s [s] m a

-- | Creates an <tt>enumeratee</tt> in which elements are grouped into
--   contiguous blocks that are equal according to a predicate.
--   
--   The analogue of <a>groupBy</a>
groupBy :: (ListLike s el, Monad m, Nullable s) => (el -> el -> Bool) -> Enumeratee s [s] m a

-- | <tt>merge</tt> offers another way to nest iteratees: as a monad stack.
--   This allows for the possibility of interleaving data from multiple
--   streams.
--   
--   <pre>
--   -- print each element from a stream of lines.
--   logger :: (MonadIO m) =&gt; Iteratee [ByteString] m ()
--   logger = mapM_ (liftIO . putStrLn . B.unpack)
--   
--   -- combine alternating lines from two sources
--   -- To see how this was derived, follow the types from
--   -- 'ileaveLines logger' and work outwards.
--   run =&lt;&lt; enumFile 10 "file1" (joinI $ enumLinesBS $
--             ( enumFile 10 "file2" . joinI . enumLinesBS $ joinI
--                   (ileaveLines logger)) &gt;&gt;= run)
--   
--   ileaveLines :: (Functor m, Monad m)
--     =&gt; Enumeratee [ByteString] [ByteString] (Iteratee [ByteString] m)
--          [ByteString]
--   ileaveLines = merge (\l1 l2 -&gt;
--      [B.pack "f1:\n\t" ,l1 ,B.pack "f2:\n\t" ,l2 ]
--   
--   
--   </pre>
merge :: (ListLike s1 el1, ListLike s2 el2, Nullable s1, Nullable s2, Monad m, Functor m) => (el1 -> el2 -> b) -> Enumeratee s2 b (Iteratee s1 m) a

-- | A version of merge which operates on chunks instead of elements.
--   
--   mergeByChunks offers more control than <a>merge</a>. <a>merge</a>
--   terminates when the first stream terminates, however mergeByChunks
--   will continue until both streams are exhausted.
--   
--   <a>mergeByChunks</a> guarantees that both chunks passed to the merge
--   function will have the same number of elements, although that number
--   may vary between calls.
mergeByChunks :: (Nullable c2, Nullable c1, NullPoint c2, NullPoint c1, ListLike c1 el1, ListLike c2 el2, Functor m, Monad m) => (c1 -> c2 -> c3) -> (c1 -> c3) -> (c2 -> c3) -> Enumeratee c2 c3 (Iteratee c1 m) a

-- | Left-associative fold.
--   
--   The analogue of <tt>List.foldl</tt>
foldl :: (ListLike s el, FoldableLL s el) => (a -> el -> a) -> a -> Iteratee s m a

-- | Left-associative fold that is strict in the accumulator. This function
--   should be used in preference to <a>foldl</a> whenever possible.
--   
--   The analogue of <tt>List.foldl'</tt>.
foldl' :: (ListLike s el, FoldableLL s el) => (a -> el -> a) -> a -> Iteratee s m a

-- | Variant of foldl with no base case. Requires at least one element in
--   the stream.
--   
--   The analogue of <tt>List.foldl1</tt>.
foldl1 :: (ListLike s el, FoldableLL s el) => (el -> el -> el) -> Iteratee s m el

-- | Strict variant of <a>foldl1</a>.
foldl1' :: (ListLike s el, FoldableLL s el) => (el -> el -> el) -> Iteratee s m el

-- | Sum of a stream.
sum :: (ListLike s el, Num el) => Iteratee s m el

-- | Product of a stream.
product :: (ListLike s el, Num el) => Iteratee s m el

-- | The pure n-chunk enumerator It passes a given stream of elements to
--   the iteratee in <tt>n</tt>-sized chunks.
enumPureNChunk :: (Monad m, ListLike s el) => s -> Int -> Enumerator s m a

-- | Enumerate two iteratees over a single stream simultaneously.
--   Deprecated, use <a>zip</a> instead.
--   
--   Compare to <tt>zip</tt>.

-- | <i>Deprecated: use Data.Iteratee.ListLike.zip </i>
enumPair :: (Monad m, Nullable s, ListLike s el) => Iteratee s m a -> Iteratee s m b -> Iteratee s m (a, b)

-- | Enumerate over two iteratees in parallel as long as the first iteratee
--   is still consuming input. The second iteratee will be terminated with
--   EOF when the first iteratee has completed. An example use is to
--   determine how many elements an iteratee has consumed:
--   
--   <pre>
--   snd &lt;$&gt; enumWith (dropWhile (&lt;5)) length
--   </pre>
--   
--   Compare to <tt>zip</tt>
enumWith :: (Monad m, Nullable s, ListLike s el) => Iteratee s m a -> Iteratee s m b -> Iteratee s m (a, b)

-- | Enumerate two iteratees over a single stream simultaneously.
--   
--   Compare to <tt>List.zip</tt>.
zip :: (Monad m, Nullable s, ListLike s el) => Iteratee s m a -> Iteratee s m b -> Iteratee s m (a, b)
zip3 :: (Monad m, Nullable s, ListLike s el) => Iteratee s m a -> Iteratee s m b -> Iteratee s m c -> Iteratee s m (a, b, c)
zip4 :: (Monad m, Nullable s, ListLike s el) => Iteratee s m a -> Iteratee s m b -> Iteratee s m c -> Iteratee s m d -> Iteratee s m (a, b, c, d)
zip5 :: (Monad m, Nullable s, ListLike s el) => Iteratee s m a -> Iteratee s m b -> Iteratee s m c -> Iteratee s m d -> Iteratee s m e -> Iteratee s m (a, b, c, d, e)

-- | Enumerate a list of iteratees over a single stream simultaneously and
--   discard the results. This is a different behavior than Prelude's
--   sequence_ which runs iteratees in the list one after the other.
--   
--   Compare to <tt>Prelude.sequence_</tt>.
sequence_ :: (Monad m, ListLike s el, Nullable s) => [Iteratee s m a] -> Iteratee s m ()

-- | Transform an iteratee into one that keeps track of how much data it
--   consumes.
countConsumed :: (Monad m, ListLike s el, Nullable s, Integral n) => Iteratee s m a -> Iteratee s m (a, n)

-- | Convert an iteratee to a "greedy" version.
--   
--   When a chunk is received, repeatedly run the input iteratee until the
--   entire chunk is consumed, then the outputs are combined (via
--   <a>mconcat</a>).
--   
--   <pre>
--   &gt; let l = [1..5::Int]
--   &gt; run =&lt;&lt; enumPure1Chunk l (joinI (take 2 stream2list))
--   [1,2]
--   &gt; run =&lt;&lt; enumPure1Chunk l (greedy $ joinI (I.take 2 stream2list))
--   [1,2,3,4,5]
--   </pre>
--   
--   Note that a greedy iteratee will consume the entire input chunk and
--   force the next chunk before returning a value. A portion of the second
--   chunk may be consumed.
--   
--   <a>greedy</a> may be useful on the first parameter of
--   <a>convStream</a>, e.g.
--   
--   <pre>
--   convStream (greedy someIter)
--   </pre>
--   
--   to create more efficient converters.
greedy :: (Monad m, Functor m, ListLike s el', Monoid a) => Iteratee s m a -> Iteratee s m a

-- | Map a monadic function over the elements of the stream and ignore the
--   result.
mapM_ :: (Monad m, ListLike s el, Nullable s) => (el -> m b) -> Iteratee s m ()

-- | The analogue of <tt>Control.Monad.foldM</tt>
foldM :: (Monad m, ListLike s b, Nullable s) => (a -> b -> m a) -> a -> Iteratee s m a


-- | Monadic Iteratees: incremental input parsers, processors, and
--   transformers
--   
--   Iteratees for parsing binary data.
module Data.Iteratee.Binary

-- | Indicate endian-ness.
data Endian

-- | Most Significant Byte is first (big-endian)
MSB :: Endian

-- | Least Significan Byte is first (little-endian)
LSB :: Endian
endianRead2 :: (Nullable s, ListLike s Word8, Monad m) => Endian -> Iteratee s m Word16
endianRead3 :: (Nullable s, ListLike s Word8, Monad m) => Endian -> Iteratee s m Word32

-- | Read 3 bytes in an endian manner. If the first bit is set (negative),
--   set the entire first byte so the Int32 will be negative as well.
endianRead3i :: (Nullable s, ListLike s Word8, Monad m) => Endian -> Iteratee s m Int32
endianRead4 :: (Nullable s, ListLike s Word8, Monad m) => Endian -> Iteratee s m Word32
endianRead8 :: (Nullable s, ListLike s Word8, Monad m) => Endian -> Iteratee s m Word64
readWord16be_bs :: Monad m => Iteratee ByteString m Word16
readWord16le_bs :: Monad m => Iteratee ByteString m Word16
readWord32be_bs :: Monad m => Iteratee ByteString m Word32
readWord32le_bs :: Monad m => Iteratee ByteString m Word32
readWord64be_bs :: Monad m => Iteratee ByteString m Word64
readWord64le_bs :: Monad m => Iteratee ByteString m Word64
instance Eq Endian
instance Ord Endian
instance Show Endian
instance Enum Endian


-- | Enumeratees - pass terminals variant.
--   
--   Provides enumeratees that pass terminal markers (<a>EOF</a>) to the
--   inner <tt>iteratee</tt>.
--   
--   Most enumeratees, upon receipt of <tt>EOF</tt>, will enter a done
--   state and return the inner iteratee without sending <tt>EOF</tt> to
--   it. This allows for composing enumerators as in:
--   
--   <pre>
--   myEnum extraData i = do
--   nested &lt;- enumFile "file" (mapChunks unpacker i)
--   inner &lt;- run nested
--   enumList extraData inner
--   </pre>
--   
--   if <tt>mapChunks unpacker</tt> sent <a>EOF</a> to the inner iteratee
--   <tt>i</tt>, there would be no way to submit extra data to it after
--   <a>run</a>ing the result from <tt>enumFile</tt>.
--   
--   In certain cases, this is not the desired behavior. Consider:
--   
--   <pre>
--   consumer :: Iteratee String IO ()
--   consumer = liftI (go 0)
--     where
--       go c (Chunk xs) = liftIO (putStr s) &gt;&gt; liftI (go c)
--       go 10 e         = liftIO (putStr "10 loops complete")
--                           &gt;&gt; idone () (Chunk "")
--       go n  e         = I.seek 0 &gt;&gt; liftI (go (n+1))
--   </pre>
--   
--   The <tt>consumer</tt> iteratee does not complete until after it has
--   received 10 <tt>EOF</tt>s. If you attempt to use it in a standard
--   enumeratee, it will never terminate. When the outer enumeratee is
--   terminated, the inner iteratee will remain in a <tt>cont</tt> state,
--   but in general there is no longer any valid data for the continuation.
--   The enumeratee itself must pass the EOF marker to the inner iteratee
--   and remain in a cont state until the inner iteratee signals its
--   completion.
--   
--   All enumeratees in this module will pass <a>EOF</a> terminators to the
--   inner iteratees.
module Data.Iteratee.PTerm

-- | Convert one stream into another with the supplied mapping function.
--   
--   A version of <a>mapChunks</a> that sends <a>EOF</a>s to the inner
--   iteratee.
mapChunksPT :: NullPoint s => (s -> s') -> Enumeratee s s' m a

-- | Convert a stream of <tt>s</tt> to a stream of <tt>s'</tt> using the
--   supplied function.
--   
--   A version of <a>mapChunksM</a> that sends <a>EOF</a>s to the inner
--   iteratee.
mapChunksMPT :: (Monad m, NullPoint s, Nullable s) => (s -> m s') -> Enumeratee s s' m a

-- | Convert one stream into another, not necessarily in lockstep.
--   
--   A version of <a>convStream</a> that sends <a>EOF</a>s to the inner
--   iteratee.
convStreamPT :: (Monad m, Nullable s, NullPoint s') => Iteratee s m s' -> Enumeratee s s' m a

-- | The most general stream converter.
--   
--   A version of <a>unfoldConvStream</a> that sends <a>EOF</a>s to the
--   inner iteratee.
unfoldConvStreamPT :: (Monad m, Nullable s, NullPoint s') => (acc -> Iteratee s m (acc, s')) -> acc -> Enumeratee s s' m a

-- | A version of <a>unfoldConvStreamCheck</a> that sends <a>EOF</a>s to
--   the inner iteratee.
unfoldConvStreamCheckPT :: (Monad m, Nullable elo) => (((Stream eli -> Iteratee eli m a) -> Maybe SomeException -> Iteratee elo m (Iteratee eli m a)) -> Enumeratee elo eli m a) -> (acc -> Iteratee elo m (acc, eli)) -> acc -> Enumeratee elo eli m a

-- | A variant of <a>breakE</a> that passes <a>EOF</a>s.
breakEPT :: (ListLike s el, NullPoint s) => (el -> Bool) -> Enumeratee s s m a

-- | A variant of <a>take</a> that passes <a>EOF</a>s.
takePT :: (Monad m, Nullable s, ListLike s el) => Int -> Enumeratee s s m a

-- | A variant of <a>takeUpTo</a> that passes <a>EOF</a>s.
takeUpToPT :: (Monad m, Nullable s, ListLike s el) => Int -> Enumeratee s s m a

-- | A variant of <a>takeWhileE</a> that passes <a>EOF</a>s.
takeWhileEPT :: (ListLike s el, NullPoint s) => (el -> Bool) -> Enumeratee s s m a

-- | A variant of <a>mapStream</a> that passes <a>EOF</a>s.
mapStreamPT :: (ListLike (s el) el, ListLike (s el') el', NullPoint (s el), LooseMap s el el') => (el -> el') -> Enumeratee (s el) (s el') m a

-- | A variant of <a>rigidMapStream</a> that passes <a>EOF</a>s.
rigidMapStreamPT :: (ListLike s el, NullPoint s) => (el -> el) -> Enumeratee s s m a

-- | A variant of <a>filter</a> that passes <a>EOF</a>s.
filterPT :: (Monad m, Functor m, Nullable s, ListLike s el) => (el -> Bool) -> Enumeratee s s m a


-- | Utilities for Char-based iteratee processing.
module Data.Iteratee.Char

-- | Print lines as they are received. This is the first <tt>impure</tt>
--   iteratee with non-trivial actions during chunk processing
--   
--   Only lines ending with a newline are printed, data terminated with EOF
--   is not printed.
printLines :: Iteratee String IO ()

-- | Print lines as they are received.
--   
--   All lines are printed, including a line with a terminating EOF. If the
--   final line is terminated by EOF without a newline, no newline is
--   printed. this function should be used in preference to printLines when
--   possible, as it is more efficient with long lines.
printLinesUnterminated :: (Eq el, Nullable s, StringLike s, ListLike s el) => Iteratee s IO ()

-- | Convert the stream of characters to the stream of lines, and apply the
--   given iteratee to enumerate the latter. The stream of lines is
--   normally terminated by the empty line. When the stream of characters
--   is terminated, the stream of lines is also terminated. This is the
--   first proper iteratee-enumerator: it is the iteratee of the character
--   stream and the enumerator of the line stream.
enumLines :: (ListLike s el, StringLike s, Nullable s, Monad m) => Enumeratee s [s] m a
enumLinesBS :: Monad m => Enumeratee ByteString [ByteString] m a

-- | Convert the stream of characters to the stream of words, and apply the
--   given iteratee to enumerate the latter. Words are delimited by white
--   space. This is the analogue of List.words
enumWords :: (ListLike s Char, Nullable s, Monad m) => Enumeratee s [s] m a
enumWordsBS :: Monad m => Enumeratee ByteString [ByteString] m a


-- | Random and Binary IO with generic Iteratees. These functions use
--   Handles for IO operations, and are provided for compatibility. When
--   available, the File Descriptor based functions are preferred as these
--   wastefully allocate memory rather than running in constant space.
module Data.Iteratee.IO.Handle

-- | The (monadic) enumerator of a file Handle. This version enumerates
--   over the entire contents of a file, in order, unless stopped by the
--   iteratee. In particular, seeking is not supported. Data is read into a
--   buffer of the specified size.
enumHandle :: (NullPoint s, ReadableChunk s el, MonadIO m, MonadMask m) => Int -> Handle -> Enumerator s m a

-- | An enumerator of a file handle that catches exceptions raised by the
--   Iteratee.
enumHandleCatch :: (IException e, NullPoint s, ReadableChunk s el, MonadIO m, MonadMask m) => Int -> Handle -> (e -> m (Maybe EnumException)) -> Enumerator s m a

-- | The enumerator of a Handle: a variation of enumHandle that supports
--   RandomIO (seek requests). Data is read into a buffer of the specified
--   size.
enumHandleRandom :: (NullPoint s, ReadableChunk s el, MonadIO m, MonadMask m) => Int -> Handle -> Enumerator s m a
enumFile :: (NullPoint s, MonadIO m, MonadMask m, ReadableChunk s el) => Int -> FilePath -> Enumerator s m a
enumFileRandom :: (NullPoint s, MonadIO m, MonadMask m, ReadableChunk s el) => Int -> FilePath -> Enumerator s m a

-- | Process a file using the given <tt>Iteratee</tt>. This function wraps
--   <tt>enumHandle</tt> as a convenience.
fileDriverHandle :: (NullPoint s, MonadIO m, MonadMask m, ReadableChunk s el) => Int -> Iteratee s m a -> FilePath -> m a

-- | A version of <tt>fileDriverHandle</tt> that supports seeking.
fileDriverRandomHandle :: (NullPoint s, MonadIO m, MonadMask m, ReadableChunk s el) => Int -> Iteratee s m a -> FilePath -> m a


-- | Random and Binary IO with generic Iteratees, using File Descriptors
--   for IO. when available, these are the preferred functions for
--   performing IO as they run in constant space and function properly with
--   sockets, pipes, etc.
module Data.Iteratee.IO.Fd

-- | The enumerator of a POSIX File Descriptor. This version enumerates
--   over the entire contents of a file, in order, unless stopped by the
--   iteratee. In particular, seeking is not supported.
enumFd :: (NullPoint s, ReadableChunk s el, MonadIO m, MonadMask m) => Int -> Fd -> Enumerator s m a

-- | A variant of enumFd that catches exceptions raised by the
--   <tt>Iteratee</tt>.
enumFdCatch :: (IException e, NullPoint s, ReadableChunk s el, MonadIO m, MonadMask m) => Int -> Fd -> (e -> m (Maybe EnumException)) -> Enumerator s m a

-- | The enumerator of a POSIX File Descriptor: a variation of
--   <tt>enumFd</tt> that supports RandomIO (seek requests).
enumFdRandom :: (NullPoint s, ReadableChunk s el, MonadIO m, MonadMask m) => Int -> Fd -> Enumerator s m a
enumFile :: (NullPoint s, MonadIO m, MonadMask m, ReadableChunk s el) => Int -> FilePath -> Enumerator s m a
enumFileRandom :: (NullPoint s, MonadIO m, MonadMask m, ReadableChunk s el) => Int -> FilePath -> Enumerator s m a

-- | Process a file using the given <tt>Iteratee</tt>.
fileDriverFd :: (NullPoint s, MonadIO m, MonadMask m, ReadableChunk s el) => Int -> Iteratee s m a -> FilePath -> m a

-- | A version of fileDriverFd that supports seeking.
fileDriverRandomFd :: (NullPoint s, MonadIO m, MonadMask m, ReadableChunk s el) => Int -> Iteratee s m a -> FilePath -> m a


-- | Random and Binary IO with generic Iteratees.
module Data.Iteratee.IO

-- | The default buffer size.
defaultBufSize :: Int

-- | The (monadic) enumerator of a file Handle. This version enumerates
--   over the entire contents of a file, in order, unless stopped by the
--   iteratee. In particular, seeking is not supported. Data is read into a
--   buffer of the specified size.
enumHandle :: (NullPoint s, ReadableChunk s el, MonadIO m, MonadMask m) => Int -> Handle -> Enumerator s m a

-- | The enumerator of a Handle: a variation of enumHandle that supports
--   RandomIO (seek requests). Data is read into a buffer of the specified
--   size.
enumHandleRandom :: (NullPoint s, ReadableChunk s el, MonadIO m, MonadMask m) => Int -> Handle -> Enumerator s m a
enumFile :: (MonadIO m, MonadMask m, NullPoint s, ReadableChunk s el) => Int -> FilePath -> Enumerator s m a
enumFileRandom :: (MonadIO m, MonadMask m, NullPoint s, ReadableChunk s el) => Int -> FilePath -> Enumerator s m a

-- | The enumerator of a POSIX File Descriptor. This version enumerates
--   over the entire contents of a file, in order, unless stopped by the
--   iteratee. In particular, seeking is not supported.
enumFd :: (NullPoint s, ReadableChunk s el, MonadIO m, MonadMask m) => Int -> Fd -> Enumerator s m a

-- | The enumerator of a POSIX File Descriptor: a variation of
--   <tt>enumFd</tt> that supports RandomIO (seek requests).
enumFdRandom :: (NullPoint s, ReadableChunk s el, MonadIO m, MonadMask m) => Int -> Fd -> Enumerator s m a

-- | Process a file using the given Iteratee. This function wraps enumFd as
--   a convenience.
fileDriver :: (MonadIO m, MonadMask m, NullPoint s, ReadableChunk s el) => Iteratee s m a -> FilePath -> m a

-- | A version of fileDriver with a user-specified buffer size (in
--   elements).
fileDriverVBuf :: (MonadIO m, MonadMask m, NullPoint s, ReadableChunk s el) => Int -> Iteratee s m a -> FilePath -> m a

-- | Process a file using the given Iteratee. This function wraps
--   enumFdRandom as a convenience.
fileDriverRandom :: (MonadIO m, MonadMask m, NullPoint s, ReadableChunk s el) => Iteratee s m a -> FilePath -> m a
fileDriverRandomVBuf :: (MonadIO m, MonadMask m, NullPoint s, ReadableChunk s el) => Int -> Iteratee s m a -> FilePath -> m a


-- | Provide iteratee-based IO as described in Oleg Kiselyov's paper
--   'http://okmij.org/ftp/Haskell/Iteratee/'.
--   
--   Oleg's original code uses lists to store buffers of data for reading
--   in the iteratee. This package allows the use of arbitrary types
--   through use of the ListLike type class.
--   
--   Iteratees can be thought of as stream processor combinators. Iteratees
--   are combined to run in sequence or in parallel, and then processed by
--   enumerators. The result of the enumeration is another iteratee, which
--   may then be used again, or have the result obtained via the <a>run</a>
--   function.
--   
--   <pre>
--   -- count the number of bytes in a file, reading at most 8192 bytes at a time
--   import Data.Iteratee as I
--   import Data.Iteratee.IO
--   import Data.ByteString
--   
--   byteCounter :: Monad m =&gt; Iteratee ByteString m Int
--   byteCounter = I.length
--   
--   countBytes = do
--     i' &lt;- enumFile 8192 "/usr/share/dict/words" byteCounter
--     result &lt;- run i'
--     print result
--   </pre>
--   
--   Iteratees can be combined to perform much more complex tasks. The
--   iteratee monad allows for sequencing iteratee operations.
--   
--   <pre>
--   iter2 = do
--     I.drop 4
--     I.head
--   </pre>
--   
--   In addition to enumerations over files and Handles, enumerations can
--   be programmatically generated.
--   
--   <pre>
--   get5thElement = enumPure1Chunk [1..10] iter2 &gt;&gt;= run &gt;&gt;= print
--   </pre>
--   
--   Iteratees can also work as stream transformers, called
--   <a>Enumeratee</a>s. A very simple example is provided by
--   <a>filter</a>. When working with enumeratees, it's very common to
--   collaps the nested iteratee with <a>joinI</a>.
--   
--   This function returns the 5th element greater than 5.
--   
--   <pre>
--   iterfilt = joinI $ I.filter (&gt;5) iter2
--   find5thOver5 = enumPure1Chunk [10,1,4,6,7,4,2,8,5,9::Int] iterfilt &gt;&gt;= run &gt;&gt;= print
--   </pre>
--   
--   Another common use of iteratees is <a>takeUpTo</a>, which guarantees
--   that an iteratee consumes a bounded number of elements. This is often
--   useful when parsing data. You can check how much data an iteratee has
--   consumed with <a>enumWith</a>
--   
--   <pre>
--   iter3 :: (Num el, Ord el, Monad m) =&gt; Iteratee [el] m (el,Int)
--   iter3 = joinI (I.takeUpTo 100 (enumWith iterfilt I.length))
--   </pre>
--   
--   Many more functions are provided, and there are many other useful ways
--   to combine iteratees and enumerators.
module Data.Iteratee

-- | Process a file using the given Iteratee. This function wraps enumFd as
--   a convenience.
fileDriver :: (MonadIO m, MonadMask m, NullPoint s, ReadableChunk s el) => Iteratee s m a -> FilePath -> m a

-- | A version of fileDriver with a user-specified buffer size (in
--   elements).
fileDriverVBuf :: (MonadIO m, MonadMask m, NullPoint s, ReadableChunk s el) => Int -> Iteratee s m a -> FilePath -> m a

-- | Process a file using the given Iteratee. This function wraps
--   enumFdRandom as a convenience.
fileDriverRandom :: (MonadIO m, MonadMask m, NullPoint s, ReadableChunk s el) => Iteratee s m a -> FilePath -> m a
fileDriverRandomVBuf :: (MonadIO m, MonadMask m, NullPoint s, ReadableChunk s el) => Int -> Iteratee s m a -> FilePath -> m a

module Data.Iteratee.IO.Interact

-- | Use an IO function to choose what iteratee to run. -- Typically this
--   function handles user interaction and -- returns with a simple
--   iteratee such as <a>head</a> or <a>seek</a>. -- -- The IO function
--   takes a value of type <tt>a</tt> as input, and -- should return 'Right
--   a' to continue, or 'Left b' -- to terminate. Upon termination, ioIter
--   will return 'Done b'. -- -- The second argument to <a>ioIter</a> is
--   used as the initial input -- to the IO function, and on each
--   successive iteration the -- previously returned value is used as
--   input. Put another way, -- the value of type <tt>a</tt> is used like a
--   fold accumulator. -- The value of type <tt>b</tt> is typically some
--   form of control code -- that the application uses to signal the reason
--   for termination.
ioIter :: (MonadIO m, Nullable s) => (a -> IO (Either b (Iteratee s m a))) -> a -> Iteratee s m b

module Data.Iteratee.Parallel

-- | Enumerate a list of iteratees over a single stream simultaneously and
--   discard the results. Each iteratee runs in a separate forkIO thread,
--   passes all errors from iteratees up.
psequence_ :: (ListLike s el, Nullable s) => [Iteratee s IO a] -> Iteratee s IO ()

-- | Transform an Enumeratee into a parallel composable one, introducing
--   one step extra delay, see <a>parI</a>.
parE :: (Nullable s1, Nullable s2, Monoid s1) => Enumeratee s1 s2 IO r -> Enumeratee s1 s2 IO r

-- | Transform usual Iteratee into parallel composable one, introducing one
--   step extra delay.
--   
--   Ex - time spent in Enumerator working on x'th packet Ix - time spent
--   in Iteratee working on x'th packet z - last packet, y = (z-1)'th
--   packet
--   
--   regular Iteratee: E0 - I0, E1 - I1, E2 - I2 .. Ez -&gt; Iz parallel
--   Iteratee: E0, E1, E2, .. Ez _ I0_ I1_ .. Iy__ Iz
parI :: (Nullable s, Monoid s) => Iteratee s IO a -> Iteratee s IO a

-- | A variant of <a>parI</a> with the parallelized iteratee lifted into an
--   arbitrary MonadIO.
liftParI :: (Nullable s, Monoid s, MonadIO m) => Iteratee s IO a -> Iteratee s m a

-- | Perform a parallel map/reduce. The <tt>bufsize</tt> parameter controls
--   the maximum number of chunks to read at one time. A larger bufsize
--   allows for greater parallelism, but will require more memory.
--   
--   Implementation of <a>sum</a>
--   
--   <pre>
--   sum :: (Monad m, LL.ListLike s, Nullable s) =&gt; Iteratee s m Int64
--   sum = getSum &lt;$&gt; mapReduce 4 (Sum . LL.sum)
--   </pre>
mapReduce :: (Monad m, Nullable s, Monoid b) => Int -> (s -> b) -> Iteratee s m b
