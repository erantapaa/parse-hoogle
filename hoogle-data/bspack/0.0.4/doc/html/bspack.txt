-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A simple and fast bytestring packer
--   
@package bspack
@version 0.0.4


-- | Copyright : Copyright Â© 2014 Nicolas DI PRIMA
--   
--   Maintainer : Nicolas DI PRIMA <a>nicolas@di-prima.fr</a> Stability :
--   experimental Portability : unknown
--   
--   Simple ByteString packer
--   
--   <pre>
--   &gt; either error id $ flip pack 20 $ putWord8 0x41 &gt;&gt; putByteString "BCD" &gt;&gt; putWord8 0x20 &gt;&gt; putStorable (42 :: Word32)
--   ABCD *\NUL\NUL\NUL"
--   </pre>
module Data.ByteString.Pack

-- | Simple Bytestring Packer
data Packer a

-- | Packing result:
--   
--   <ul>
--   <li>PackerOK a -&gt; means the bytestring has been filled with the
--   given data</li>
--   <li>PackerMore a cache -&gt; a temporary</li>
--   </ul>
data Result a
PackerMore :: a -> Cache -> Result a
PackerFail :: String -> Result a

-- | pack the given packer into the given bytestring
pack :: Packer a -> Int -> Either String ByteString

-- | put Word8 in the current position in the stream
putWord8 :: Word8 -> Packer ()

-- | put Word16 in the current position in the stream /! use Host
--   Endianness
putWord16 :: Word16 -> Packer ()

-- | put Word32 in the current position in the stream /! use Host
--   Endianness
putWord32 :: Word32 -> Packer ()

-- | put a storable from the current position in the stream
putStorable :: Storable storable => storable -> Packer ()

-- | put a Bytestring from the current position in the stream
--   
--   If the ByteString ins null, then do nothing
putByteString :: ByteString -> Packer ()

-- | Will put the given storable list from the current position in the
--   stream to the end.
--   
--   This function will fail with not enough storage if the given storable
--   can't be written (not enough space)
--   
--   example: &gt; pack (fillList $ [1..] :: Word8) 9 ==&gt; "123456789"
--   &gt; pack (fillList $ [1..] :: Word32) 4 ==&gt; "1000" &gt; pack
--   (fillList $ [1..] :: Word32) 64 -- will work &gt; pack (fillList $
--   [1..] :: Word32) 1 -- will fail (not enough space) &gt; pack (fillList
--   $ [1..] :: Word32) 131 -- will fail (not enough space)
fillList :: Storable storable => [storable] -> Packer ()

-- | fill up from the current position in the stream to the end
--   
--   it is basically: &gt; fillUpWith s == fillList (repeat s)
fillUpWith :: Storable storable => storable -> Packer ()

-- | skip some bytes from the current position in the stream
skip :: Int -> Packer ()

-- | skip the size of a storable from the current position in the stream
skipStorable :: Storable storable => storable -> Packer ()
