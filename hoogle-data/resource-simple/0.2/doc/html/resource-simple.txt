-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Allocate resources which are guaranteed to be released.
--   
--   This is a simplified, standalone version of the <tt>ResourceT</tt>
--   transformer that was originally developed as part of the
--   <tt>conduit</tt> package. That version of <tt>ResourceT</tt> was
--   supported by a complicated hierarchy of type classes, the main purpose
--   of which was to enable the usage of <tt>ResourceT</tt> on top of the
--   <tt>ST</tt> monad. However, this doesn't really make much sense
--   conceptually, and the reason it was done is because conduits are very
--   closely tied to <tt>ResourceT</tt>, and an instance for <tt>ST</tt>
--   would enable the usage of <tt>ResourceT</tt> in pure code.
--   
--   This package completely does away with the supporting type class
--   hierarchy, and as such, this version of <tt>ResourceT</tt> can only be
--   used with <tt>IO</tt> or <tt>IO</tt>-like monads.
--   
--   This package is motivated by a belief that the iteratee problem and
--   the resource finalization problem are orthogonal. This package is
--   ideal for usage with the <tt>pipes</tt> library.
@package resource-simple
@version 0.2


-- | Allocate resources which are guaranteed to be released.
--   
--   One point to note: all register cleanup actions live in IO, not the
--   main monad. This allows both more efficient code, and for monads to be
--   transformed.
module Control.Monad.Resource

-- | The Resource transformer. This transformer keeps track of all
--   registered actions, and calls them upon exit (via
--   <a>runResourceT</a>). Actions may be registered via <a>register</a>,
--   or resources may be allocated atomically via <a>with</a>. The
--   <a>with</a> function corresponds closely to <tt>bracket</tt>. These
--   functions are provided by 'ResourceT'\'s <a>MonadResource</a>
--   instance.
--   
--   Releasing may be performed before exit via the <a>release</a>
--   function. This is a highly recommended optimization, as it will ensure
--   that scarce resources are freed early. Note that calling
--   <tt>release</tt> will deregister the action, so that a release action
--   will only ever be called once.
--   
--   Pass-through instances for the <tt>mtl</tt> type classes are provided
--   automatically by the <tt>mtl-evil-instances</tt> package.
data ResourceT m a

-- | Unwrap a <a>ResourceT</a> transformer, and call all registered release
--   actions.
--   
--   Note that there is some reference counting involved due to the
--   implementation of <a>fork</a> used in the <a>MonadFork</a> instance.
--   If multiple threads are sharing the same collection of resources, only
--   the last call to <tt>runResourceT</tt> will deallocate the resources.
runResourceT :: MonadBaseControl IO m => ResourceT m a -> m a

-- | Transform the monad a <tt>ResourceT</tt> lives in. This is most often
--   used to strip or add new transformers to a stack, e.g. to run a
--   <tt>ReaderT</tt>.
mapResourceT :: (m a -> n b) -> ResourceT m a -> ResourceT n b

-- | The <a>MonadResource</a> type class. This provides the <a>with</a>,
--   <a>register</a> and <a>release</a> functions, which are the main
--   functionality of this package. The main instance of this class is
--   <a>ResourceT</a>.
--   
--   The others instances are overlapping instances (in the spirit of
--   <tt>mtl-evil-instances</tt>), which provide automatic pass-through
--   instances for <a>MonadResource</a> for every monad transformer. This
--   means that you don't have to provide a pass-through instance of
--   <a>MonadResource</a> for every monad transformer you write.
class MonadIO m => MonadResource m
with :: MonadResource m => IO a -> (a -> IO ()) -> m (ReleaseKey, a)
register :: MonadResource m => IO () -> m ReleaseKey
release :: MonadResource m => ReleaseKey -> m ()

-- | A lookup key for a specific release action. This value is returned by
--   <a>register</a> and <a>with</a> and is passed to <a>release</a>.
data ReleaseKey
instance [overlap ok] (MonadBase b m, MonadResource b) => MonadResource m
instance [overlap ok] (MonadTrans t, Monad (t m), MonadResource m) => MonadResource (t m)
instance [overlap ok] MonadBaseControl IO m => MonadResource (ResourceT m)
instance [overlap ok] (MonadFork m, MonadBaseControl IO m) => MonadFork (ResourceT m)
instance [overlap ok] MonadBaseControl b m => MonadBaseControl b (ResourceT m)
instance [overlap ok] MonadPlus m => MonadPlus (ResourceT m)
instance [overlap ok] Monad m => Monad (ResourceT m)
instance [overlap ok] MonadPlus m => Alternative (ResourceT m)
instance [overlap ok] Monad m => Applicative (ResourceT m)
instance [overlap ok] Monad m => Functor (ResourceT m)
instance [overlap ok] MonadTransControl ResourceT
instance [overlap ok] MonadTrans ResourceT
