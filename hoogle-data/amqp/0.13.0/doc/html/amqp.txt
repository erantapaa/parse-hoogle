-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Client library for AMQP servers (currently only RabbitMQ)
--   
@package amqp
@version 0.13.0


-- | This module contains data-types specified in the AMQP spec
module Network.AMQP.Types
data AMQPException

-- | the <a>String</a> contains the reason why the channel was closed
ChannelClosedException :: String -> AMQPException

-- | String may contain a reason
ConnectionClosedException :: String -> AMQPException

-- | the <a>Int</a> contains the channel-max property of the connection
--   (i.e. the highest permitted channel id)
AllChannelsAllocatedException :: Int -> AMQPException
type Octet = Word8
type Bit = Bool
type ChannelID = ShortInt
type PayloadSize = LongInt
type ShortInt = Word16
type LongInt = Word32
type LongLongInt = Word64
newtype ShortString
ShortString :: Text -> ShortString
newtype LongString
LongString :: ByteString -> LongString
type Timestamp = Word64

-- | Keys must be shorter than 256 bytes when encoded as UTF-8
data FieldTable
FieldTable :: (Map Text FieldValue) -> FieldTable
data FieldValue
FVBool :: Bool -> FieldValue
FVInt8 :: Int8 -> FieldValue
FVInt16 :: Int16 -> FieldValue
FVInt32 :: Int32 -> FieldValue
FVInt64 :: Int64 -> FieldValue
FVFloat :: Float -> FieldValue
FVDouble :: Double -> FieldValue
FVDecimal :: DecimalValue -> FieldValue
FVString :: Text -> FieldValue
FVFieldArray :: [FieldValue] -> FieldValue
FVTimestamp :: Timestamp -> FieldValue
FVFieldTable :: FieldTable -> FieldValue
FVVoid :: FieldValue
FVByteArray :: ByteString -> FieldValue
type Decimals = Octet
data DecimalValue
DecimalValue :: Decimals -> LongInt -> DecimalValue
data ConfirmationResult
Complete :: (IntSet, IntSet) -> ConfirmationResult
Partial :: (IntSet, IntSet, IntSet) -> ConfirmationResult
instance Typeable AMQPException
instance Show AMQPException
instance Ord AMQPException
instance Eq AMQPException
instance Eq ShortString
instance Ord ShortString
instance Read ShortString
instance Show ShortString
instance Eq LongString
instance Ord LongString
instance Read LongString
instance Show LongString
instance Eq DecimalValue
instance Ord DecimalValue
instance Read DecimalValue
instance Show DecimalValue
instance Eq FieldValue
instance Ord FieldValue
instance Read FieldValue
instance Show FieldValue
instance Eq FieldTable
instance Ord FieldTable
instance Read FieldTable
instance Show FieldTable
instance Show ConfirmationResult
instance Binary DecimalValue
instance Binary FieldValue
instance Binary FieldTable
instance Binary LongString
instance Binary ShortString
instance Exception AMQPException


-- | A client library for AMQP servers implementing the 0-9-1 spec;
--   currently only supports RabbitMQ (see <a>http://www.rabbitmq.com</a>)
--   
--   A good introduction to RabbitMQ and AMQP 0-9-1 (in various languages):
--   <a>http://www.rabbitmq.com/getstarted.html</a>,
--   <a>http://www.rabbitmq.com/tutorials/amqp-concepts.html</a>
--   
--   <i>Example</i>:
--   
--   Connect to a server, declare a queue and an exchange and setup a
--   callback for messages coming in on the queue. Then publish a single
--   message to our new exchange
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   import Network.AMQP
--   import qualified Data.ByteString.Lazy.Char8 as BL
--   
--   main = do
--       conn &lt;- openConnection "127.0.0.1" "/" "guest" "guest"
--       chan &lt;- openChannel conn
--   
--       -- declare a queue, exchange and binding
--       declareQueue chan newQueue {queueName = "myQueue"}
--       declareExchange chan newExchange {exchangeName = "myExchange", exchangeType = "direct"}
--       bindQueue chan "myQueue" "myExchange" "myKey"
--   
--       -- subscribe to the queue
--       consumeMsgs chan "myQueue" Ack myCallback
--   
--       -- publish a message to our new exchange
--       publishMsg chan "myExchange" "myKey"
--           newMsg {msgBody = (BL.pack "hello world"),
--                   msgDeliveryMode = Just Persistent}
--   
--       getLine -- wait for keypress
--       closeConnection conn
--       putStrLn "connection closed"
--   
--   
--   myCallback :: (Message,Envelope) -&gt; IO ()
--   myCallback (msg, env) = do
--       putStrLn $ "received message: " ++ (BL.unpack $ msgBody msg)
--       -- acknowledge receiving the message
--       ackEnv env
--   </pre>
--   
--   <i>Exception handling</i>:
--   
--   Some function calls can make the AMQP server throw an AMQP exception,
--   which has the side-effect of closing the connection or channel. The
--   AMQP exceptions are raised as Haskell exceptions (see
--   <a>AMQPException</a>). So upon receiving an <a>AMQPException</a> you
--   may have to reopen the channel or connection.
module Network.AMQP
data Connection

-- | Represents the parameters to connect to a broker or a cluster of
--   brokers. See <tt>defaultConnectionOpts</tt>.
data ConnectionOpts
ConnectionOpts :: ![(String, PortNumber)] -> !Text -> ![SASLMechanism] -> !(Maybe Word32) -> !(Maybe Word16) -> !(Maybe Word16) -> Maybe TLSSettings -> ConnectionOpts

-- | A list of host-port pairs. Useful in a clustered setup to connect to
--   the first available host.
coServers :: ConnectionOpts -> ![(String, PortNumber)]

-- | The VHost to connect to.
coVHost :: ConnectionOpts -> !Text

-- | The <a>SASLMechanism</a>s to use for authenticating with the broker.
coAuth :: ConnectionOpts -> ![SASLMechanism]

-- | The maximum frame size to be used. If not specified, no limit is
--   assumed.
coMaxFrameSize :: ConnectionOpts -> !(Maybe Word32)

-- | The delay in seconds, after which the client expects a heartbeat frame
--   from the broker. If <a>Nothing</a>, the value suggested by the broker
--   is used. Use <tt>Just 0</tt> to disable the heartbeat mechnism.
coHeartbeatDelay :: ConnectionOpts -> !(Maybe Word16)

-- | The maximum number of channels the client will use.
coMaxChannel :: ConnectionOpts -> !(Maybe Word16)

-- | Whether or not to connect to servers using TLS. See
--   <a>http://www.rabbitmq.com/ssl.html</a> for details.
coTLSSettings :: ConnectionOpts -> Maybe TLSSettings

-- | Represents the kind of TLS connection to establish.
data TLSSettings

-- | Require trusted certificates (Recommended).
TLSTrusted :: TLSSettings

-- | Allow untrusted certificates (Discouraged. Vulnerable to
--   man-in-the-middle attacks)
TLSUntrusted :: TLSSettings

-- | Constructs default connection options with the following settings :
--   
--   <ul>
--   <li>Broker: <tt>amqp://guest:guest@localhost:5672/%2F</tt> using the
--   <tt>PLAIN</tt> SASL mechanism</li>
--   <li>max frame size: <tt>131072</tt></li>
--   <li>use the heartbeat delay suggested by the broker</li>
--   <li>no limit on the number of used channels</li>
--   </ul>
defaultConnectionOpts :: ConnectionOpts

-- | <tt>openConnection hostname virtualHost loginName loginPassword</tt>
--   opens a connection to an AMQP server running on <tt>hostname</tt>.
--   <tt>virtualHost</tt> is used as a namespace for AMQP resources
--   (default is "/"), so different applications could use multiple virtual
--   hosts on the same AMQP server.
--   
--   You must call <a>closeConnection</a> before your program exits to
--   ensure that all published messages are received by the server.
--   
--   The <tt>loginName</tt> and <tt>loginPassword</tt> will be used to
--   authenticate via the <tt>PLAIN</tt> SASL mechanism.
--   
--   NOTE: If the login name, password or virtual host are invalid, this
--   method will throw a <a>ConnectionClosedException</a>. The exception
--   will not contain a reason why the connection was closed, so you'll
--   have to find out yourself.
openConnection :: String -> Text -> Text -> Text -> IO Connection

-- | same as <a>openConnection</a> but allows you to specify a non-default
--   port-number as the 2nd parameter
openConnection' :: String -> PortNumber -> Text -> Text -> Text -> IO Connection

-- | Opens a connection to a broker specified by the given
--   <a>ConnectionOpts</a> parameter.
openConnection'' :: ConnectionOpts -> IO Connection

-- | closes a channel. It is typically not necessary to manually call this
--   as closing a connection will implicitly close all channels.
closeChannel :: Channel -> IO ()

-- | closes a connection
--   
--   Make sure to call this function before your program exits to ensure
--   that all published messages are received by the server.
closeConnection :: Connection -> IO ()

-- | <tt>addConnectionClosedHandler conn ifClosed handler</tt> adds a
--   <tt>handler</tt> that will be called after the connection is closed
--   (either by calling <tt>closeConnection</tt> or by an exception). If
--   the <tt>ifClosed</tt> parameter is True and the connection is already
--   closed, the handler will be called immediately. If <tt>ifClosed ==
--   False</tt> and the connection is already closed, the handler will
--   never be called
addConnectionClosedHandler :: Connection -> Bool -> IO () -> IO ()

-- | A connection to an AMQP server is made up of separate channels. It is
--   recommended to use a separate channel for each thread in your
--   application that talks to the AMQP server (but you don't have to as
--   channels are thread-safe)
data Channel

-- | opens a new channel on the connection
openChannel :: Connection -> IO Channel

-- | registers a callback function that is called whenever a message is
--   returned from the broker ('basic.return').
addReturnListener :: Channel -> ((Message, PublishError) -> IO ()) -> IO ()

-- | registers a callback function that is called whenever a channel is
--   closed by an exception.
addChannelExceptionHandler :: Channel -> (SomeException -> IO ()) -> IO ()

-- | <tt>qos chan prefetchSize prefetchCount global</tt> limits the amount
--   of data the server delivers before requiring acknowledgements.
--   <tt>prefetchSize</tt> specifies the number of bytes and
--   <tt>prefetchCount</tt> the number of messages. In both cases the value
--   0 means unlimited.
--   
--   The meaning of the <tt>global</tt> flag is explained here:
--   <a>http://www.rabbitmq.com/consumer-prefetch.html</a>
--   
--   NOTE: RabbitMQ does not implement prefetchSize and will throw an
--   exception if it doesn't equal 0.
qos :: Channel -> Word32 -> Word16 -> Bool -> IO ()

-- | A record that contains the fields needed when creating a new exhange
--   using <a>declareExchange</a>. The default values apply when you use
--   <a>newExchange</a>.
data ExchangeOpts
ExchangeOpts :: Text -> Text -> Bool -> Bool -> Bool -> Bool -> FieldTable -> ExchangeOpts

-- | (must be set); the name of the exchange
exchangeName :: ExchangeOpts -> Text

-- | (must be set); the type of the exchange ("fanout", "direct", "topic",
--   "headers")
exchangeType :: ExchangeOpts -> Text

-- | (default <a>False</a>); If set, the server will not create the
--   exchange. The client can use this to check whether an exchange exists
--   without modifying the server state.
exchangePassive :: ExchangeOpts -> Bool

-- | (default <a>True</a>); If set when creating a new exchange, the
--   exchange will be marked as durable. Durable exchanges remain active
--   when a server restarts. Non-durable exchanges (transient exchanges)
--   are purged if/when a server restarts.
exchangeDurable :: ExchangeOpts -> Bool

-- | (default <a>False</a>); If set, the exchange is deleted when all
--   queues have finished using it.
exchangeAutoDelete :: ExchangeOpts -> Bool

-- | (default <a>False</a>); If set, the exchange may not be used directly
--   by publishers, but only when bound to other exchanges. Internal
--   exchanges are used to construct wiring that is not visible to
--   applications.
exchangeInternal :: ExchangeOpts -> Bool

-- | (default empty); A set of arguments for the declaration. The syntax
--   and semantics of these arguments depends on the server implementation.
exchangeArguments :: ExchangeOpts -> FieldTable

-- | an <a>ExchangeOpts</a> with defaults set; you must override at least
--   the <a>exchangeName</a> and <a>exchangeType</a> fields.
newExchange :: ExchangeOpts

-- | declares a new exchange on the AMQP server. Can be used like this:
--   <tt>declareExchange channel newExchange {exchangeName = "myExchange",
--   exchangeType = "fanout"}</tt>
declareExchange :: Channel -> ExchangeOpts -> IO ()

-- | <tt>bindExchange chan destinationName sourceName routingKey</tt> binds
--   the exchange to the exchange using the provided routing key
bindExchange :: Channel -> Text -> Text -> Text -> IO ()

-- | an extended version of <tt>bindExchange</tt> that allows you to
--   include arbitrary arguments. This is useful to use the
--   <tt>headers</tt> exchange-type.
bindExchange' :: Channel -> Text -> Text -> Text -> FieldTable -> IO ()

-- | <tt>unbindExchange chan destinationName sourceName routingKey</tt>
--   unbinds an exchange from an exchange. The <tt>routingKey</tt> must be
--   identical to the one specified when binding the exchange.
unbindExchange :: Channel -> Text -> Text -> Text -> IO ()

-- | an extended version of <tt>unbindExchange</tt> that allows you to
--   include arguments. The <tt>arguments</tt> must be identical to the
--   ones specified when binding the exchange.
unbindExchange' :: Channel -> Text -> Text -> Text -> FieldTable -> IO ()

-- | deletes the exchange with the provided name
deleteExchange :: Channel -> Text -> IO ()

-- | A record that contains the fields needed when creating a new queue
--   using <a>declareQueue</a>. The default values apply when you use
--   <a>newQueue</a>.
data QueueOpts
QueueOpts :: Text -> Bool -> Bool -> Bool -> Bool -> FieldTable -> QueueOpts

-- | (default ""); the name of the queue; if left empty, the server will
--   generate a new name and return it from the <a>declareQueue</a> method
queueName :: QueueOpts -> Text

-- | (default <a>False</a>); If set, the server will not create the queue.
--   The client can use this to check whether a queue exists without
--   modifying the server state.
queuePassive :: QueueOpts -> Bool

-- | (default <a>True</a>); If set when creating a new queue, the queue
--   will be marked as durable. Durable queues remain active when a server
--   restarts. Non-durable queues (transient queues) are purged if/when a
--   server restarts. Note that durable queues do not necessarily hold
--   persistent messages, although it does not make sense to send
--   persistent messages to a transient queue.
queueDurable :: QueueOpts -> Bool

-- | (default <a>False</a>); Exclusive queues may only be consumed from by
--   the current connection. Setting the <tt>exclusive</tt> flag always
--   implies 'auto-delete'.
queueExclusive :: QueueOpts -> Bool

-- | (default <a>False</a>); If set, the queue is deleted when all
--   consumers have finished using it. Last consumer can be cancelled
--   either explicitly or because its channel is closed. If there was no
--   consumer ever on the queue, it won't be deleted.
queueAutoDelete :: QueueOpts -> Bool

-- | (default empty): Headers to use when creating this queue, such as
--   <tt>x-message-ttl</tt> or <tt>x-dead-letter-exchange</tt>.
queueHeaders :: QueueOpts -> FieldTable

-- | a <a>QueueOpts</a> with defaults set; you should override at least
--   <a>queueName</a>.
newQueue :: QueueOpts

-- | creates a new queue on the AMQP server; can be used like this:
--   <tt>declareQueue channel newQueue {queueName = "myQueue"}</tt>.
--   
--   Returns a tuple <tt>(queue, messageCount, consumerCount)</tt>.
--   <tt>queue</tt> is the name of the new queue (if you don't specify a
--   queue the server will autogenerate one). <tt>messageCount</tt> is the
--   number of messages in the queue, which will be zero for newly-created
--   queues. <tt>consumerCount</tt> is the number of active consumers for
--   the queue.
declareQueue :: Channel -> QueueOpts -> IO (Text, Int, Int)

-- | <tt>bindQueue chan queue exchange routingKey</tt> binds the queue to
--   the exchange using the provided routing key. If <tt>exchange</tt> is
--   the empty string, the default exchange will be used.
bindQueue :: Channel -> Text -> Text -> Text -> IO ()

-- | an extended version of <tt>bindQueue</tt> that allows you to include
--   arbitrary arguments. This is useful to use the <tt>headers</tt>
--   exchange-type.
bindQueue' :: Channel -> Text -> Text -> Text -> FieldTable -> IO ()

-- | <tt>unbindQueue chan queue exchange routingKey</tt> unbinds a queue
--   from an exchange. The <tt>routingKey</tt> must be identical to the one
--   specified when binding the queue.
unbindQueue :: Channel -> Text -> Text -> Text -> IO ()

-- | an extended version of <tt>unbindQueue</tt> that allows you to include
--   arguments. The <tt>arguments</tt> must be identical to the ones
--   specified when binding the queue.
unbindQueue' :: Channel -> Text -> Text -> Text -> FieldTable -> IO ()

-- | remove all messages from the queue; returns the number of messages
--   that were in the queue
purgeQueue :: Channel -> Text -> IO Word32

-- | deletes the queue; returns the number of messages that were in the
--   queue before deletion
deleteQueue :: Channel -> Text -> IO Word32

-- | An AMQP message
data Message
Message :: ByteString -> Maybe DeliveryMode -> Maybe Timestamp -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Octet -> Maybe Text -> Maybe Text -> Maybe FieldTable -> Message

-- | the content of your message
msgBody :: Message -> ByteString

-- | see <a>DeliveryMode</a>
msgDeliveryMode :: Message -> Maybe DeliveryMode

-- | use in any way you like; this doesn't affect the way the message is
--   handled
msgTimestamp :: Message -> Maybe Timestamp

-- | use in any way you like; this doesn't affect the way the message is
--   handled
msgID :: Message -> Maybe Text

-- | use in any way you like; this doesn't affect the way the message is
--   handled
msgType :: Message -> Maybe Text
msgUserID :: Message -> Maybe Text
msgApplicationID :: Message -> Maybe Text
msgClusterID :: Message -> Maybe Text
msgContentType :: Message -> Maybe Text
msgContentEncoding :: Message -> Maybe Text
msgReplyTo :: Message -> Maybe Text
msgPriority :: Message -> Maybe Octet
msgCorrelationID :: Message -> Maybe Text
msgExpiration :: Message -> Maybe Text
msgHeaders :: Message -> Maybe FieldTable
data DeliveryMode

-- | the message will survive server restarts (if the queue is durable)
Persistent :: DeliveryMode

-- | the message may be lost after server restarts
NonPersistent :: DeliveryMode
data PublishError
PublishError :: ReturnReplyCode -> Maybe Text -> Text -> PublishError
errReplyCode :: PublishError -> ReturnReplyCode
errExchange :: PublishError -> Maybe Text
errRoutingKey :: PublishError -> Text
data ReturnReplyCode
Unroutable :: Text -> ReturnReplyCode
NoConsumers :: Text -> ReturnReplyCode
NotFound :: Text -> ReturnReplyCode

-- | a <tt>Msg</tt> with defaults set; you should override at least
--   <a>msgBody</a>
newMsg :: Message

-- | contains meta-information of a delivered message (through
--   <tt>getMsg</tt> or <tt>consumeMsgs</tt>)
data Envelope
Envelope :: LongLongInt -> Bool -> Text -> Text -> Channel -> Envelope
envDeliveryTag :: Envelope -> LongLongInt
envRedelivered :: Envelope -> Bool
envExchangeName :: Envelope -> Text
envRoutingKey :: Envelope -> Text
envChannel :: Envelope -> Channel
type ConsumerTag = Text

-- | specifies whether you have to acknowledge messages that you receive
--   from <a>consumeMsgs</a> or <a>getMsg</a>. If you use <a>Ack</a>, you
--   have to call <a>ackMsg</a> or <a>ackEnv</a> after you have processed a
--   message, otherwise it might be delivered again in the future
data Ack
Ack :: Ack
NoAck :: Ack

-- | <tt>consumeMsgs chan queue ack callback</tt> subscribes to the given
--   queue and returns a consumerTag. For any incoming message, the
--   callback will be run. If <tt>ack == <a>Ack</a></tt> you will have to
--   acknowledge all incoming messages (see <a>ackMsg</a> and
--   <a>ackEnv</a>)
--   
--   NOTE: The callback will be run on the same thread as the channel
--   thread (every channel spawns its own thread to listen for incoming
--   data) so DO NOT perform any request on <tt>chan</tt> inside the
--   callback (however, you CAN perform requests on other open channels
--   inside the callback, though I wouldn't recommend it). Functions that
--   can safely be called on <tt>chan</tt> are <a>ackMsg</a>,
--   <a>ackEnv</a>, <a>rejectMsg</a>, <a>recoverMsgs</a>. If you want to
--   perform anything more complex, it's a good idea to wrap it inside
--   <a>forkIO</a>.
consumeMsgs :: Channel -> Text -> Ack -> ((Message, Envelope) -> IO ()) -> IO ConsumerTag

-- | an extended version of <tt>consumeMsgs</tt> that allows you to include
--   arbitrary arguments.
consumeMsgs' :: Channel -> Text -> Ack -> ((Message, Envelope) -> IO ()) -> FieldTable -> IO ConsumerTag

-- | stops a consumer that was started with <a>consumeMsgs</a>
cancelConsumer :: Channel -> ConsumerTag -> IO ()

-- | <tt>publishMsg chan exchange routingKey msg</tt> publishes
--   <tt>msg</tt> to the exchange with the provided <tt>exchange</tt>. The
--   effect of <tt>routingKey</tt> depends on the type of the exchange.
--   
--   NOTE: This method may temporarily block if the AMQP server requested
--   us to stop sending content data (using the flow control mechanism). So
--   don't rely on this method returning immediately.
publishMsg :: Channel -> Text -> Text -> Message -> IO ()

-- | Like <a>publishMsg</a>, but additionally allows you to specify whether
--   the <tt>mandatory</tt> flag should be set.
publishMsg' :: Channel -> Text -> Text -> Bool -> Message -> IO ()

-- | <tt>getMsg chan ack queue</tt> gets a message from the specified
--   queue. If <tt>ack==<a>Ack</a></tt>, you have to call <a>ackMsg</a> or
--   <a>ackEnv</a> for any message that you get, otherwise it might be
--   delivered again in the future (by calling <a>recoverMsgs</a>)
getMsg :: Channel -> Ack -> Text -> IO (Maybe (Message, Envelope))

-- | <tt>rejectMsg chan deliveryTag requeue</tt> allows a client to reject
--   a message. It can be used to interrupt and cancel large incoming
--   messages, or return untreatable messages to their original queue. If
--   <tt>requeue==False</tt>, the message will be discarded. If it is
--   <a>True</a>, the server will attempt to requeue the message.
--   
--   NOTE: RabbitMQ 1.7 doesn't implement this command
rejectMsg :: Channel -> LongLongInt -> Bool -> IO ()

-- | Reject a message. This is a wrapper for <a>rejectMsg</a> in case you
--   have the <a>Envelope</a> at hand.
rejectEnv :: Envelope -> Bool -> IO ()

-- | <tt>recoverMsgs chan requeue</tt> asks the broker to redeliver all
--   messages that were received but not acknowledged on the specified
--   channel. If <tt>requeue==False</tt>, the message will be redelivered
--   to the original recipient. If <tt>requeue==True</tt>, the server will
--   attempt to requeue the message, potentially then delivering it to an
--   alternative subscriber.
recoverMsgs :: Channel -> Bool -> IO ()

-- | <tt>ackMsg chan deliveryTag multiple</tt> acknowledges one or more
--   messages. A message MUST not be acknowledged more than once.
--   
--   if <tt>multiple==True</tt>, the <tt>deliverTag</tt> is treated as "up
--   to and including", so that the client can acknowledge multiple
--   messages with a single method call. If <tt>multiple==False</tt>,
--   <tt>deliveryTag</tt> refers to a single message.
--   
--   If <tt>multiple==True</tt>, and <tt>deliveryTag==0</tt>, tells the
--   server to acknowledge all outstanding mesages.
ackMsg :: Channel -> LongLongInt -> Bool -> IO ()

-- | Acknowledges a single message. This is a wrapper for <a>ackMsg</a> in
--   case you have the <a>Envelope</a> at hand.
ackEnv :: Envelope -> IO ()

-- | This method sets the channel to use standard transactions. The client
--   must use this method at least once on a channel before using the
--   Commit or Rollback methods.
txSelect :: Channel -> IO ()

-- | This method commits all messages published and acknowledged in the
--   current transaction. A new transaction starts immediately after a
--   commit.
txCommit :: Channel -> IO ()

-- | This method abandons all messages published and acknowledged in the
--   current transaction. A new transaction starts immediately after a
--   rollback.
txRollback :: Channel -> IO ()

-- | <tt>confirmSelect chan nowait</tt> puts the channel in publisher
--   confirm mode. This mode is a RabbitMQ extension where a producer
--   receives confirmations when messages are successfully processed by the
--   broker. Publisher confirms are a relatively lightweight alternative to
--   full transactional mode. For details about the delivery guarantees and
--   performace implications of this mode, see
--   <a>https://www.rabbitmq.com/confirms.html</a>. Note that on a single
--   channel, publisher confirms and transactions are mutually exclusive
--   (you cannot select both at the same time). When <tt>nowait==True</tt>
--   the server will not send back a response to this method.
confirmSelect :: Channel -> Bool -> IO ()

-- | Calling this function will cause the invoking thread to block until
--   all previously published messages have been acknowledged by the broker
--   (positively or negatively). Returns a value of type
--   <tt>ConfirmationResult, holding a tuple of two </tt>IntSet's @(acked,
--   nacked), ontaining the delivery tags for the messages that have been
--   confirmed by the broker.
waitForConfirms :: Channel -> IO ConfirmationResult

-- | Same as <tt>waitForConfirms, but with a timeout in microseconds. Note
--   that, since this operation may timeout before the server has acked or
--   nacked all pending messages, the returned </tt>ConfirmationResult
--   should be pattern-matched for the constructors <tt>Complete (acked,
--   nacked) and </tt>Partial (acked, nacked, pending)
waitForConfirmsUntil :: Channel -> Int -> IO ConfirmationResult

-- | Adds a handler which will be invoked each time the <tt>Channel
--   receives a confirmation from the broker. --The parameters passed to
--   the the handler are the </tt>deliveryTag for the message being
--   confirmed, a flag indicating whether the confirmation refers to this
--   message individually (<tt>False) or all messages up to this one
--   (</tt>True) and an <tt>AckType whose value can be either </tt>BasicAck
--   or @BasicNack.
addConfirmationListener :: Channel -> ((Word64, Bool, AckType) -> IO ()) -> IO ()
data ConfirmationResult
Complete :: (IntSet, IntSet) -> ConfirmationResult
Partial :: (IntSet, IntSet, IntSet) -> ConfirmationResult

-- | <tt>flow chan active</tt> tells the AMQP server to pause or restart
--   the flow of content data. This is a simple flow-control mechanism that
--   a peer can use to avoid overflowing its queues or otherwise finding
--   itself receiving more messages than it can process.
--   
--   If <tt>active==True</tt> the server will start sending content data,
--   if <tt>active==False</tt> the server will stop sending content data.
--   
--   A new channel is always active by default.
--   
--   NOTE: RabbitMQ 1.7 doesn't implement this command.
flow :: Channel -> Bool -> IO ()

-- | A <a>SASLMechanism</a> is described by its name (<a>saslName</a>), its
--   initial response (<a>saslInitialResponse</a>), and an optional
--   function (<a>saslChallengeFunc</a>) that transforms a security
--   challenge provided by the server into response, which is then sent
--   back to the server for verification.
data SASLMechanism
SASLMechanism :: !Text -> !ByteString -> !(Maybe (ByteString -> IO ByteString)) -> SASLMechanism

-- | mechanism name
saslName :: SASLMechanism -> !Text

-- | initial response
saslInitialResponse :: SASLMechanism -> !ByteString

-- | challenge processing function
saslChallengeFunc :: SASLMechanism -> !(Maybe (ByteString -> IO ByteString))

-- | The <tt>PLAIN</tt> SASL mechanism. See <a>RFC4616</a>
plain :: Text -> Text -> SASLMechanism

-- | The <tt>AMQPLAIN</tt> SASL mechanism. See
--   <a>http://www.rabbitmq.com/authentication.html</a>.
amqplain :: Text -> Text -> SASLMechanism

-- | The <tt>RABBIT-CR-DEMO</tt> SASL mechanism needs to be explicitly
--   enabled on the RabbitMQ server and should only be used for
--   demonstration purposes of the challenge-response cycle. See
--   <a>http://www.rabbitmq.com/authentication.html</a>.
rabbitCRdemo :: Text -> Text -> SASLMechanism
data AMQPException

-- | the <a>String</a> contains the reason why the channel was closed
ChannelClosedException :: String -> AMQPException

-- | String may contain a reason
ConnectionClosedException :: String -> AMQPException

-- | the <a>Int</a> contains the channel-max property of the connection
--   (i.e. the highest permitted channel id)
AllChannelsAllocatedException :: Int -> AMQPException

-- | Parses amqp standard URI of the form
--   <tt>amqp://user:password</tt>host:port/vhost<tt> and returns a
--   </tt>ConnectionOpts<tt> for use with </tt>openConnection''<tt> | Any
--   of these fields may be empty and will be replaced with defaults from
--   </tt>amqp:/<i>guest:guest@localhost:5672</i>@
fromURI :: String -> ConnectionOpts
instance Eq ExchangeOpts
instance Ord ExchangeOpts
instance Read ExchangeOpts
instance Show ExchangeOpts
instance Eq QueueOpts
instance Ord QueueOpts
instance Read QueueOpts
instance Show QueueOpts
instance Eq Ack
instance Ord Ack
instance Read Ack
instance Show Ack

module Network.AMQP.Lifted

-- | <tt>consumeMsgs chan queueName ack callback</tt> subscribes to the
--   given queue and returns a consumerTag. For any incoming message, the
--   callback will be run. If <tt>ack == <tt>Ack</tt></tt> you will have to
--   acknowledge all incoming messages (see <tt>ackMsg</tt> and
--   <tt>ackEnv</tt>)
--   
--   NOTE: The callback will be run on the same thread as the channel
--   thread (every channel spawns its own thread to listen for incoming
--   data) so DO NOT perform any request on <tt>chan</tt> inside the
--   callback (however, you CAN perform requests on other open channels
--   inside the callback, though I wouldn't recommend it). Functions that
--   can safely be called on <tt>chan</tt> are <tt>ackMsg</tt>,
--   <tt>ackEnv</tt>, <tt>rejectMsg</tt>, <tt>recoverMsgs</tt>. If you want
--   to perform anything more complex, it's a good idea to wrap it inside
--   <tt>forkIO</tt>.
--   
--   In addition, while the callback function <tt>((<tt>Message</tt>,
--   <tt>Envelope</tt>) -&gt; m ())</tt> has access to the captured state,
--   all its side-effects in m are discarded.
consumeMsgs :: MonadBaseControl IO m => Channel -> Text -> Ack -> ((Message, Envelope) -> m ()) -> m ConsumerTag

-- | an extended version of <tt>consumeMsgs</tt> that allows you to include
--   arbitrary arguments.
consumeMsgs' :: MonadBaseControl IO m => Channel -> Text -> Ack -> ((Message, Envelope) -> m ()) -> FieldTable -> m ConsumerTag
