-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Utility functions
--   
--   Extends base with all sorts of utility functions. Very easy, useful
--   and portable
@package hinduce-missingh
@version 0.0.0.0

module Data.String.HIUtils

-- | Pad left side with spaces such that <tt>length (pad n s) &gt;= length
--   s + n</tt>
padl :: Int -> String -> String

-- | Pad right side with spaces such that <tt>length (pad n s) &gt;= length
--   s + n</tt>
padr :: Int -> String -> String

-- | Pad right side with spaces such that <tt>length (pad n s) &gt;= length
--   s + n</tt>
pad :: Int -> String -> String

module Data.List.HIUtils

-- | Sort a list and leave out duplicates. Like <tt>nub . sort</tt> but
--   faster.
uniqSort :: Ord a => [a] -> [a]

-- | Sort, then group
aggregate :: Ord a => [a] -> [[a]]

-- | Sort, then group
aggregateBy :: (a -> a -> Ordering) -> [a] -> [[a]]

-- | Aggregate an association list, such that keys become unique.
aggregateAL :: Ord a => [(a, b)] -> [(a, [b])]

-- | Infinite integer sequence of the natural numbers, starting at 0
nat0 :: Num n => [n]

-- | Infinite integer sequence of the natural numbers, starting at 1
nat1 :: Num n => [n]

-- | Calculate the arithmetic mean. May not be numerically robust for some
--   types and lists. Double and Rational should be fine most of the time.
average :: Fractional a => [a] -> a

-- | Shortcut for <tt>average . map fromIntegral</tt>. Check numerical
--   robustness, see <tt>average</tt> above.
averageI :: (Integral i, Fractional a) => [i] -> a

-- | Turn a list of integer frequencies into relative frequencies that sum
--   up to 1. Frequencies should be nonnegative.
relFreq :: (Integral i, Fractional f) => [i] -> [f]

-- | Turn an association list of integer frequencies into on of relative
--   frequencies that sum up to 1. Frequencies should be nonnegative.
relFreqAL :: (Integral i, Fractional f) => [(a, i)] -> [(a, f)]

-- | Find the most frequently occurring element. TODO: rewrite for Eq
majority :: Ord a => [a] -> a
oddIx :: [b] -> [b]
evenIx :: [b] -> [b]
