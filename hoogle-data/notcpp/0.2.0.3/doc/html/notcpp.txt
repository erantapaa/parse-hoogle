-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Avoiding the C preprocessor via cunning use of Template Haskell
--   
@package notcpp
@version 0.2.0.3


-- | This module uses scope lookup techniques to either export
--   <a>lookupValueName</a> from <tt>Language.Haskell.TH</tt>, or define
--   its own <a>lookupValueName</a>, which attempts to do the same job with
--   just <a>reify</a>. This will sometimes fail, but if it succeeds it
--   will give the answer that the real function would have given.
--   
--   The idea is that if you use lookupValueName from this module, your
--   client code will automatically use the best available name lookup
--   mechanism. This means that e.g. <tt>scopeLookup</tt> can work very
--   well on recent GHCs and less well but still somewhat usefully on older
--   GHCs.
module NotCPP.LookupValueName

-- | Look up the given name in the (value namespace of the) current
--   splice's scope. See <a>Language.Haskell.TH.Syntax#namelookup</a> for
--   more details.
lookupValueName :: String -> Q (Maybe Name)


-- | This module exports <a>scopeLookup</a>, which will find a variable or
--   value constructor for you and present it for your use. E.g. at some
--   point in the history of the acid-state package, <tt>openAcidState</tt>
--   was renamed <tt>openLocalState</tt>; for compatibility with both, you
--   could use:
--   
--   <pre>
--   openState :: IO (AcidState st)
--   openState = case $(scopeLookup "openLocalState") of
--     Just open -&gt; open defaultState
--     Nothing -&gt; case $(scopeLookup "openAcidState") of
--       Just open -&gt; open defaultState
--       Nothing -&gt; error
--         "openState: runtime name resolution has its drawbacks :/"
--   </pre>
--   
--   Or, for this specific case, you can use <a>scopeLookups</a>:
--   
--   <pre>
--   openState :: IO (AcidState st)
--   openState = open defaultState
--    where
--     open = $(scopeLookups ["openLocalState","openAcidState"])
--   </pre>
--   
--   Now if neither of the names are found then TH will throw a
--   compile-time error.
module NotCPP.ScopeLookup

-- | Produces a spliceable expression which expands to <tt><a>Just</a>
--   val</tt> if the given string refers to a value <tt>val</tt> in scope,
--   or <a>Nothing</a> otherwise.
--   
--   <pre>
--   scopeLookup = <a>fmap</a> <a>liftMaybe</a> . <a>scopeLookup'</a>
--   </pre>
scopeLookup :: String -> Q Exp

-- | Finds the first string in the list that names a value, and produces a
--   spliceable expression of that value, or reports a compile error if it
--   fails.
scopeLookups :: [String] -> Q Exp

-- | Produces <tt><a>Just</a> x</tt> if the given string names the value
--   <tt>x</tt>, or <a>Nothing</a> otherwise.
scopeLookup' :: String -> Q (Maybe Exp)

-- | Turns <a>Nothing</a> into an expression representing <a>Nothing</a>,
--   and <tt><a>Just</a> x</tt> into an expression representing <a>Just</a>
--   applied to the expression in <tt>x</tt>.
liftMaybe :: Maybe Exp -> Exp

-- | Turns a possibly-failing <a>Q</a> action into one returning a
--   <a>Maybe</a> value.
recoverMaybe :: Q a -> Q (Maybe a)

-- | A useful variant of <a>reify</a> that returns <a>Nothing</a> instead
--   of halting compilation when an error occurs (e.g. because the given
--   name was not in scope).
maybeReify :: Name -> Q (Maybe Info)

-- | Returns <tt><a>Just</a> (<a>VarE</a> n)</tt> if the info relates to a
--   value called <tt>n</tt>, or <a>Nothing</a> if it relates to a
--   different sort of thing.
infoToExp :: Info -> Maybe Exp


-- | The orphan instance problem is well-known in Haskell. This module by
--   no means purports to solve the problem, but provides a workaround that
--   may be significantly less awful than the status quo in some cases.
--   
--   Say I think that the <a>Name</a> type should have an <tt>IsString</tt>
--   instance. But I don't control either the class or the type, so if I
--   define the instance, and then the template-haskell package defines
--   one, my code is going to break.
--   
--   <a>safeInstance</a> can help me to solve this problem:
--   
--   <pre>
--   safeInstance ''IsString [t| Name |] [d|
--     fromString = mkName |]
--   </pre>
--   
--   This will declare an instance only if one doesn't already exist. Now
--   anyone importing your module is guaranteed to get an instance one way
--   or the other.
--   
--   This module is still highly experimental. The example given above does
--   work, but anything involving type variables or complex method bodies
--   may be less fortunate. The names of the methods are mangled a bit, so
--   using recursion to define them may not work. Define the method outside
--   the code and then use a simple binding as above.
--   
--   If you use this code (successfully or unsuccessfully!), go fetch the
--   maintainer address from the cabal file and let me know!
module NotCPP.OrphanEvasion

-- | An empty type used only to signify a multiparameter typeclass in
--   <a>safeInstance</a>.
data MultiParams a

-- | <a>safeInstance</a> is a more convenient version of
--   <a>safeInstance'</a> that takes the context and type from a
--   <tt><a>Q</a> <a>Type</a></tt> with the intention that it be supplied
--   using a type-quote.
--   
--   To define an instance <tt>Show a =&gt; Show (Wrapper a)</tt>, you'd
--   use:
--   
--   <pre>
--   safeInstance ''Show [t| Show a =&gt; Wrapper a |]
--     [d| show _ = "stuff" |]
--   </pre>
--   
--   To define an instance of a multi-param type class, use the
--   <a>MultiParams</a> type constructor with a tuple:
--   
--   <pre>
--   safeInstance ''MonadState
--     [t| MonadState s m =&gt; MultiParams (s, MaybeT m) |]
--     [d| put = ... |]
--   </pre>
safeInstance :: Name -> Q Type -> Q [Dec] -> Q [Dec]

-- | <tt><a>safeInstance'</a> className cxt types methods</tt> produces an
--   instance of the given class if and only if one doesn't already exist.
--   
--   See <a>safeInstance</a> for a simple way to construct the <a>Cxt</a>
--   and <tt>[<a>Type</a>]</tt> parameters.
safeInstance' :: Name -> Cxt -> [Type] -> Q [Dec] -> Q [Dec]
