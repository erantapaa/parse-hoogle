-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A semantic web toolkit.
--   
@package swish
@version 0.9.1.3


module Swish.Utils.ListHelpers

-- | Apply list of functions to some value, returning list of results. It's
--   kind of like an converse map.
--   
--   This is similar to the <tt>ap</tt> function in the Monad library.
flist :: [a -> b] -> a -> [b]


-- | This module defines a Labelled Directed Graph and Label classes, and
--   the Arc datatype.
module Swish.GraphClass

-- | Labelled Directed Graph class.
--   
--   Minimum required implementation: <a>emptyGraph</a>, <a>setArcs</a>,
--   and <a>getArcs</a>.
class LDGraph lg lb where extract sel = update (filter sel) addGraphs addg = update (union (getArcs addg)) delete g1 g2 = setArcs g2 (getArcs g2 `difference` getArcs g1) labels = getComponents arcLabels . getArcs nodes = getComponents arcNodes . getArcs update f g = setArcs g (f (getArcs g))
emptyGraph :: LDGraph lg lb => lg lb
setArcs :: LDGraph lg lb => lg lb -> ArcSet lb -> lg lb
getArcs :: LDGraph lg lb => lg lb -> ArcSet lb
extract :: (LDGraph lg lb, Ord lb) => Selector lb -> lg lb -> lg lb
addGraphs :: (LDGraph lg lb, Ord lb) => lg lb -> lg lb -> lg lb
delete :: (LDGraph lg lb, Ord lb) => lg lb -> lg lb -> lg lb
labels :: (LDGraph lg lb, Ord lb) => lg lb -> Set lb
nodes :: (LDGraph lg lb, Ord lb) => lg lb -> Set lb
update :: LDGraph lg lb => (ArcSet lb -> ArcSet lb) -> lg lb -> lg lb

-- | Label class.
--   
--   A label may have a fixed binding, which means that the label
--   identifies (is) a particular graph node, and different such labels are
--   always distinct nodes. Alternatively, a label may be unbound
--   (variable), which means that it is a placeholder for an unknown node
--   label. Unbound node labels are used as graph-local identifiers for
--   indicating when the same node appears in several arcs.
--   
--   For the purposes of graph-isomorphism testing, fixed labels are
--   matched when they are the same. Variable labels may be matched with
--   any other variable label. Our definition of isomorphism (for RDF
--   graphs) does not match variable labels with fixed labels.
class (Ord lb, Show lb) => Label lb
labelIsVar :: Label lb => lb -> Bool
labelHash :: Label lb => Int -> lb -> Int
getLocal :: Label lb => lb -> String
makeLabel :: Label lb => String -> lb

-- | Arc type.
--   
--   Prior to <tt>0.7.0.0</tt> you could also use <tt>asubj</tt>,
--   <tt>apred</tt> and <tt>aobj</tt> to access the elements of the arc.
data Arc lb
Arc :: lb -> lb -> lb -> Arc lb

-- | The subject of the arc.
arcSubj :: Arc lb -> lb

-- | The predicate (property) of the arc.
arcPred :: Arc lb -> lb

-- | The object of the arc.
arcObj :: Arc lb -> lb

-- | A set - or graph - of arcs.
type ArcSet lb = Set (Arc lb)

-- | Identify arcs.
type Selector lb = Arc lb -> Bool

-- | Create an arc.
arc :: lb -> lb -> lb -> Arc lb

-- | Convert an Arc into a tuple.
arcToTriple :: Arc lb -> (lb, lb, lb)

-- | Create an Arc from a tuple.
arcFromTriple :: (lb, lb, lb) -> Arc lb

-- | Does the arc contain the label in any position (subject, predicate, or
--   object)?
hasLabel :: Eq lb => lb -> Arc lb -> Bool

-- | Return all the labels in an arc.
arcLabels :: Arc lb -> [lb]

-- | Extract components from a set.
getComponents :: (Ord a, Ord b) => (a -> [b]) -> Set a -> Set b
instance Eq lb => Eq (Arc lb)
instance Functor Arc
instance Foldable Arc
instance Traversable Arc
instance Show lb => Show (Arc lb)
instance Ord lb => Ord (Arc lb)
instance Hashable lb => Hashable (Arc lb)


-- | This module contains functions for partitioning a graph into subgraphs
--   that rooted from different subject nodes.
module Swish.GraphPartition

-- | Representation of a graph as a collection of (possibly nested)
--   partitions. Each node in the graph appears at least once as the root
--   value of a <a>GraphPartition</a> value:
--   
--   <ul>
--   <li>Nodes that are the subject of at least one statement appear as the
--   first value of exactly one <a>PartSub</a> constructor, and may also
--   appear in any number of <a>PartObj</a> constructors.</li>
--   <li>Nodes appearing only as objects of statements appear only in
--   <a>PartObj</a> constructors.</li>
--   </ul>
data PartitionedGraph lb
PartitionedGraph :: [GraphPartition lb] -> PartitionedGraph lb

-- | Returns all the arcs in the partitioned graph.
getArcs :: PartitionedGraph lb -> [Arc lb]

-- | Returns a list of partitions.
getPartitions :: PartitionedGraph lb -> [GraphPartition lb]

-- | Represent a partition of a graph by a node and (optional) contents.
data GraphPartition lb
PartObj :: lb -> GraphPartition lb
PartSub :: lb -> (NonEmpty (lb, GraphPartition lb)) -> GraphPartition lb

-- | Returns the node for the partition.
node :: GraphPartition lb -> lb

-- | Creates a list of arcs from the partition. The empty list is returned
--   for <a>PartObj</a>.
toArcs :: GraphPartition lb -> [Arc lb]

-- | Turning a partitioned graph into a flat graph is easy. The interesting
--   challenge is to turn a flat graph into a partitioned graph that is
--   more useful for certain purposes. Currently, I'm interested in:
--   
--   <ol>
--   <li>isolating differences between graphs</li>
--   <li>pretty-printing graphs</li>
--   </ol>
--   
--   For (1), the goal is to separate subgraphs that are known to be
--   equivalent from subgraphs that are known to be different, such that:
--   
--   <ul>
--   <li>different sub-graphs are minimized,</li>
--   <li>different sub-graphs are placed into 1:1 correspondence (possibly
--   with null subgraphs), and</li>
--   <li>only deterministic matching decisions are made.</li>
--   </ul>
--   
--   For (2), the goal is to decide when a subgraph is to be treated as
--   nested in another partition, or treated as a new top-level partition.
--   If a subgraph is referenced by exactly one graph partition, it should
--   be nested in that partition, otherwise it should be a new top-level
--   partition.
--   
--   Strategy. Examining just subject and object nodes:
--   
--   <ul>
--   <li>all non-blank subject nodes are the root of a top-level
--   partition</li>
--   <li>blank subject nodes that are not the object of exactly one
--   statement are the root of a top-level partition.</li>
--   <li>blank nodes referenced as the object of exactly 1 statement of an
--   existing partition are the root of a sub-partition of the refering
--   partition.</li>
--   <li>what remain are circular chains of blank nodes not referenced
--   elsewhere: for each such chain, pick a root node arbitrarily.</li>
--   </ul>
partitionGraph :: Label lb => [Arc lb] -> PartitionedGraph lb

-- | Create a list of pairs of corresponding Partitions that are unequal.
comparePartitions :: Label lb => PartitionedGraph lb -> PartitionedGraph lb -> [(Maybe (GraphPartition lb), Maybe (GraphPartition lb))]

-- | Convert a partition into a string with a leading separator string.
partitionShowP :: Label lb => String -> GraphPartition lb -> String
instance Label lb => Eq (PartitionedGraph lb)
instance Label lb => Show (PartitionedGraph lb)
instance Label lb => Show (GraphPartition lb)
instance Label lb => Ord (GraphPartition lb)
instance Label lb => Eq (GraphPartition lb)


-- | This module contains graph-matching logic.
--   
--   The algorithm used is derived from a paper on RDF graph matching by
--   Jeremy Carroll
--   <a>http://www.hpl.hp.com/techreports/2001/HPL-2001-293.html</a>.
module Swish.GraphMatch

-- | Graph matching function accepting two lists of arcs and returning a
--   node map if successful
graphMatch :: Label lb => (lb -> lb -> Bool) -> ArcSet lb -> ArcSet lb -> (Bool, LabelMap (ScopedLabel lb))

-- | A label lookup table specialized to <a>LabelIndex</a> indices.
type LabelMap lb = GenLabelMap lb LabelIndex

-- | Type for label-&gt;index lookup table
data (Label lb, Eq lv, Show lv) => GenLabelMap lb lv
LabelMap :: Word32 -> (Map lb lv) -> GenLabelMap lb lv

-- | A label associated with a <a>LabelIndex</a>
type LabelEntry lb = GenLabelEntry lb LabelIndex

-- | A Mapping between a label and a value (e.g. an index value).
data Label lb => GenLabelEntry lb lv
LabelEntry :: lb -> lv -> GenLabelEntry lb lv

-- | This instance of class label adds a graph identifier to each variable
--   label, so that variable labels from different graphs are always seen
--   as distinct values.
--   
--   The essential logic added by this class instance is embodied in the eq
--   and hash functions. Note that variable label hashes depend only on the
--   graph in which they appear, and non-variable label hashes depend only
--   on the variable. Label hash values are used when initializing a label
--   equivalence-class map (and, for non-variable labels, also for
--   resolving hash collisions).
data Label lb => ScopedLabel lb
ScopedLabel :: Int -> lb -> ScopedLabel lb

-- | Create a scoped label given an identifier and label.
makeScopedLabel :: Label lb => Int -> lb -> ScopedLabel lb

-- | Create an arc containining a scoped label with the given identifier.
makeScopedArc :: Label lb => Int -> Arc lb -> Arc (ScopedLabel lb)

-- | LabelIndex is a unique value assigned to each label, such that labels
--   with different values are definitely different values in the graph;
--   e.g. do not map to each other in the graph bijection. The first member
--   is a generation counter that ensures new values are distinct from
--   earlier passes.
type LabelIndex = (Word32, Word32)

-- | Type for equivalence class description (An equivalence class is a
--   collection of labels with the same <a>LabelIndex</a> value.)
type EquivalenceClass lb = (LabelIndex, [lb])

-- | The null, or empty, index value.
nullLabelVal :: LabelIndex

-- | The empty label map table.
emptyMap :: Label lb => LabelMap lb

-- | Does this node have a variable binding?
labelIsVar :: Label lb => lb -> Bool

-- | Calculate the hash of the label using the supplied seed.
labelHash :: Label lb => Int -> lb -> Int

-- | Map a label to its corresponding label index value in the supplied
--   LabelMap.
mapLabelIndex :: Label lb => LabelMap lb -> lb -> LabelIndex

-- | Replace a label and its associated value in a label map with a new
--   value using the supplied hash value and the current <a>LabelMap</a>
--   generation number. If the key is not found, then no change is made to
--   the label map.
setLabelHash :: Label lb => LabelMap lb -> (lb, Word32) -> LabelMap lb

-- | Replace selected values in a label map with new values from the
--   supplied list of labels and new label index values. The generation
--   number is supplied from the current label map. The generation number
--   in the resulting label map is incremented.
newLabelMap :: Label lb => LabelMap lb -> [(lb, Word32)] -> LabelMap lb

-- | Return the set of distinct labels used in the graph.
graphLabels :: Label lb => ArcSet lb -> Set lb

-- | Scan label list, assigning initial label map values, adding new values
--   to the label map supplied.
--   
--   Label map values are assigned on the basis of the label alone, without
--   regard for it's connectivity in the graph. (cf. <a>reclassify</a>).
--   
--   All variable node labels are assigned the same initial value, as they
--   may be matched with each other.
assignLabelMap :: Label lb => Set lb -> LabelMap lb -> LabelMap lb

-- | Increment the generation of the label map.
--   
--   Returns a new label map identical to the supplied value but with an
--   incremented generation number.
newGenerationMap :: Label lb => LabelMap lb -> LabelMap lb

-- | Recursive graph matching function
--   
--   This function assumes that no variable label appears in both graphs.
--   (Function <a>graphMatch</a>, which calls this, ensures that all
--   variable labels are distinct.)
graphMatch1 :: Label lb => Bool -> (lb -> lb -> Bool) -> ArcSet lb -> ArcSet lb -> LabelMap lb -> [(EquivalenceClass lb, EquivalenceClass lb)] -> (Bool, LabelMap lb)

-- | Auxiliary graph matching function
--   
--   This function is called when deterministic decomposition of node
--   mapping equivalence classes has run its course.
--   
--   It picks a pair of equivalence classes in ecpairs, and arbitrarily
--   matches pairs of nodes in those equivalence classes, recursively
--   calling the graph matching function until a suitable node mapping is
--   discovered (success), or until all such pairs have been tried
--   (failure).
--   
--   This function represents a point to which arbitrary choices are
--   backtracked. The list comprehension <tt>glp</tt> represents the
--   alternative choices at the point of backtracking
--   
--   The selected pair of nodes are placed in a new equivalence class based
--   on their original equivalence class value, but with a new NodeVal
--   generation number.
graphMatch2 :: Label lb => (lb -> lb -> Bool) -> ArcSet lb -> ArcSet lb -> LabelMap lb -> [(EquivalenceClass lb, EquivalenceClass lb)] -> (Bool, LabelMap lb)

-- | Return the equivalence classes of the supplied nodes using the label
--   map.
equivalenceClasses :: Label lb => LabelMap lb -> Set lb -> [EquivalenceClass lb]

-- | Reclassify labels
--   
--   Examines the supplied label equivalence classes (based on the supplied
--   label map), and evaluates new equivalence subclasses based on node
--   values and adjacency (for variable nodes) and rehashing (for
--   non-variable nodes).
--   
--   Note, assumes that all all equivalence classes supplied are
--   non-singletons; i.e. contain more than one label.
reclassify :: Label lb => ArcSet lb -> ArcSet lb -> LabelMap lb -> [(EquivalenceClass lb, EquivalenceClass lb)] -> (LabelMap lb, [(EquivalenceClass lb, EquivalenceClass lb)], Bool, Bool)
instance Label lb => Ord (ScopedLabel lb)
instance Label lb => Show (ScopedLabel lb)
instance Label lb => Eq (ScopedLabel lb)
instance Label lb => Label (ScopedLabel lb)
instance Label lb => Eq (LabelMap lb)
instance Label lb => Show (LabelMap lb)
instance (Label lb, Show lv, Ord lv) => Ord (GenLabelEntry lb lv)
instance (Label lb, Eq lv) => Eq (GenLabelEntry lb lv)
instance (Label lb, Show lv) => Show (GenLabelEntry lb lv)


-- | This module defines a simple memory-based graph instance.
module Swish.GraphMem

-- | Simple memory-based graph type.
data GraphMem lb
GraphMem :: ArcSet lb -> GraphMem lb
arcs :: GraphMem lb -> ArcSet lb

-- | Minimal graph label value - for testing
data LabelMem
LF :: String -> LabelMem
LV :: String -> LabelMem

-- | Replace the existing arcs in the graph.
setArcs :: LDGraph lg lb => lg lb -> ArcSet lb -> lg lb

-- | Extract all the arcs from a graph
getArcs :: LDGraph lg lb => lg lb -> ArcSet lb

-- | Add the two graphs
addGraphs :: (LDGraph lg lb, Ord lb) => lg lb -> lg lb -> lg lb

-- | Remove those arcs in the first graph from the second graph
delete :: (LDGraph lg lb, Ord lb) => lg lb -> lg lb -> lg lb

-- | Extract those arcs that match the given <a>Selector</a>.
extract :: (LDGraph lg lb, Ord lb) => Selector lb -> lg lb -> lg lb

-- | Enumerate the distinct labels contained in a graph; that is, any label
--   that appears in the subject, predicate or object position of an
--   <a>Arc</a>.
labels :: (LDGraph lg lb, Ord lb) => lg lb -> Set lb

-- | Does this node have a variable binding?
labelIsVar :: Label lb => lb -> Bool

-- | Calculate the hash of the label using the supplied seed.
labelHash :: Label lb => Int -> lb -> Int

-- | GraphMem matching function accepting GraphMem value and returning node
--   map if successful
matchGraphMem :: Label lb => GraphMem lb -> GraphMem lb -> (Bool, LabelMap (ScopedLabel lb))
instance Show LabelMem
instance Ord LabelMem
instance Eq LabelMem
instance Label LabelMem
instance Hashable LabelMem
instance Label lb => Monoid (GraphMem lb)
instance Label lb => Show (GraphMem lb)
instance Label lb => Ord (GraphMem lb)
instance Label lb => Eq (GraphMem lb)
instance Label lb => LDGraph GraphMem lb


-- | <ul>
--   <li>This module is deprecated and will be removed*</li>
--   </ul>
--   
--   This module no-longer does anything since <a>URI</a> now has an
--   <a>Ord</a> instance by default (prior to <tt>network </tt>2.4.0.0@
--   this was not the case).
--   
--   This module used to provide an ordering for earlier versions of the
--   network package, but with the split of <a>URI</a> out to the
--   <tt>network-uri</tt> in version <tt>2.6.0.0</tt>, the CPP needed to
--   keep this going got annoying enough for me to just require a recent
--   <tt>network</tt> package.
module Network.URI.Ord


-- | This module defines an extension of the <a>Show</a> class for
--   displaying multi-line values. It serves the following purposes:
--   
--   <ol>
--   <li>provides a method with greater layout control of multiline
--   values,</li>
--   <li>provides a possibility to override the default <a>Show</a>
--   behaviour for programs that use the extended <a>ShowLines</a>
--   interface, and</li>
--   <li>uses a <a>ShowS</a> intermediate value to avoid unnecessary
--   concatenation of long strings.</li>
--   </ol>
module Data.String.ShowLines

-- | ShowLines is a type class for values that may be formatted in
--   multi-line displays.
class Show sh => ShowLines sh where showls _ = shows
showls :: ShowLines sh => String -> sh -> ShowS


-- | This module provides methods to support operations on partially
--   ordered collections. The partial ordering relationship is represented
--   by <a>Maybe</a> <a>Ordering</a>.
--   
--   Thanks to members of the haskell-cafe mailing list - Robert
--   (rvollmert-lists@gmx.net) and Tom Pledger (Tom.Pledger@peace.com) -
--   who suggested key ideas on which some of the code in this module is
--   based.
module Data.Ord.Partial

-- | Partial comparison function.
type PartCompare a = a -> a -> Maybe Ordering

-- | This function finds the minima in a list of partially ordered values,
--   preserving the sequence of retained values from the supplied list.
--   
--   It returns all those values in the supplied list for which there is no
--   smaller element in the list.
minima :: PartCompare a -> [a] -> [a]

-- | This function finds the maxima in a list of partially ordered values,
--   preserving the sequence of retained values from the supplied list.
--   
--   It returns all those values in the supplied list for which there is no
--   larger element in the list.
maxima :: PartCompare a -> [a] -> [a]

-- | Partial ordering for Eq values
partCompareEq :: Eq a => PartCompare a

-- | Part-ordering comparison on pairs of values, where each has a
--   part-ordering relationship
partComparePair :: PartCompare a -> PartCompare b -> (a, b) -> (a, b) -> Maybe Ordering

-- | Part-ordering comparison on lists of Maybe values.
partCompareListMaybe :: Eq a => [Maybe a] -> [Maybe a] -> Maybe Ordering

-- | Part-ordering comparison on lists based on subset relationship
partCompareListSubset :: Eq a => [a] -> [a] -> Maybe Ordering


-- | Support interning URIs.
module Data.Interned.URI

-- | An interned URI. The hashing is based on the reversed URI (as a
--   string).
data InternedURI
instance Eq (Description InternedURI)
instance Hashable (Description InternedURI)
instance Uninternable InternedURI
instance Interned InternedURI
instance Show InternedURI
instance Ord InternedURI
instance Eq InternedURI
instance IsString InternedURI


-- | This module defines an algebraic datatype for qualified names
--   (QNames), which represents a <a>URI</a> as the combination of a
--   namespace <a>URI</a> and a local component (<a>LName</a>), which can
--   be empty.
--   
--   Although RDF supports using IRIs, the use of <a>URI</a> here precludes
--   this, which means that, for instance, <a>LName</a> only accepts a
--   subset of valid characters. There is currently no attempt to convert
--   from an IRI into a URI.
module Swish.QName

-- | A qualified name, consisting of a namespace URI and the local part of
--   the identifier, which can be empty. The serialisation of a QName is
--   formed by concatanating the two components.
--   
--   <pre>
--   Prelude&gt; :set prompt "swish&gt; "
--   swish&gt; :set -XOverloadedStrings
--   swish&gt; :m + Swish.QName
--   swish&gt; let qn1 = "http://example.com/" :: QName
--   swish&gt; let qn2 = "http://example.com/bob" :: QName
--   swish&gt; let qn3 = "http://example.com/bob/fred" :: QName
--   swish&gt; let qn4 = "http://example.com/bob/fred#x" :: QName
--   swish&gt; let qn5 = "http://example.com/bob/fred:joe" :: QName
--   swish&gt; map getLocalName [qn1, qn2, qn3, qn4, qn5]
--   ["","bob","fred","x","fred:joe"]
--   swish&gt; getNamespace qn1
--   http://example.com/
--   swish&gt; getNamespace qn2
--   http://example.com/
--   swish&gt; getNamespace qn3
--   http://example.com/bob/
--   swish&gt; getNamespace qn4
--   http://example.com/bob/fred#
--   </pre>
data QName

-- | A local name, which can be empty.
--   
--   At present, the local name can not contain a space character and can
--   only contain ascii characters (those that match <a>isAscii</a>).
--   
--   In version <tt>0.9.0.3</tt> and earlier, the following characters were
--   not allowed in local names: '#', ':', or '/' characters.
--   
--   This is all rather experimental.
data LName

-- | The empty local name.
emptyLName :: LName

-- | Create a local name.
newLName :: Text -> Maybe LName

-- | Extract the local name.
getLName :: LName -> Text

-- | Create a new qualified name with an explicit local component.
newQName :: URI -> LName -> QName

-- | Create a new qualified name.
qnameFromURI :: URI -> Maybe QName

-- | Return the URI of the namespace stored in the QName. This does not
--   contain the local component.
getNamespace :: QName -> URI

-- | Return the local component of the QName.
getLocalName :: QName -> LName

-- | Returns the full URI of the QName (ie the combination of the namespace
--   and local components).
getQNameURI :: QName -> URI

-- | Convert a filepath to a file: URI stored in a QName. If the input file
--   path is relative then the current working directory is used to convert
--   it into an absolute path.
--   
--   If the input represents a directory then it *must* end in the
--   directory separator - so for Posix systems use <tt>"/foo/bar/"</tt>
--   rather than <tt>"/foo/bar"</tt>.
--   
--   This has not been tested on Windows.
qnameFromFilePath :: FilePath -> IO QName
instance Eq LName
instance Ord LName
instance Show QName
instance Ord QName
instance Eq QName
instance IsString QName
instance IsString LName
instance Show LName


-- | This module defines algebraic datatypes for namespaces and scoped
--   names.
--   
--   For these purposes, a namespace is a prefix and URI used to identify a
--   namespace (cf. XML namespaces), and a scoped name is a name that is
--   scoped by a specified namespace.
module Swish.Namespace

-- | A NameSpace value consists of an optional prefix and a corresponding
--   URI.
data Namespace

-- | Create a name space from a URI and an optional prefix label.
makeNamespace :: Maybe Text -> URI -> Namespace

-- | Create a qualified name by combining the URI from the name space with
--   a local component.
makeNamespaceQName :: Namespace -> LName -> QName

-- | Returns the prefix stored in the name space.
getNamespacePrefix :: Namespace -> Maybe Text

-- | Returns the URI stored in the name space.
getNamespaceURI :: Namespace -> URI

-- | Convert the name space to a (prefix, URI) tuple.
getNamespaceTuple :: Namespace -> (Maybe Text, URI)

-- | A full ScopedName value has a QName prefix, namespace URI and a local
--   part. ScopedName values may omit the prefix (see <a>Namespace</a>) or
--   the local part.
--   
--   Some applications may handle null namespace URIs as meaning the local
--   part is relative to some base URI.
data ScopedName

-- | Returns the namespace.
getScopeNamespace :: ScopedName -> Namespace

-- | Returns the local part.
getScopeLocal :: ScopedName -> LName

-- | Returns the prefix of the namespace, if set.
getScopePrefix :: ScopedName -> Maybe Text

-- | Returns the URI of the namespace.
getScopeURI :: ScopedName -> URI

-- | Get the QName corresponding to a scoped name.
getQName :: ScopedName -> QName

-- | Get URI corresponding to a scoped name (using RDF conventions).
getScopedNameURI :: ScopedName -> URI

-- | Test if supplied string matches the display form of a scoped name.
matchName :: String -> ScopedName -> Bool

-- | Construct a ScopedName.
makeScopedName :: Maybe Text -> URI -> LName -> ScopedName

-- | Construct a ScopedName from a QName.
makeQNameScopedName :: Maybe Text -> QName -> ScopedName

-- | Construct a ScopedName for a bare URI (the label is set to "").
makeURIScopedName :: URI -> ScopedName

-- | Construct a ScopedName.
makeNSScopedName :: Namespace -> LName -> ScopedName

-- | This should never appear as a valid name
nullScopedName :: ScopedName

-- | Utility routine to create a @prefix line (matching N3/Turtle) grammar
--   for this namespace.
namespaceToBuilder :: Namespace -> Builder
instance Show ScopedName
instance Ord ScopedName
instance Eq ScopedName
instance IsString ScopedName
instance Show Namespace
instance Ord Namespace
instance Eq Namespace


-- | This module defines a framework for defining inference rules over some
--   expression form. It is intended to be used with RDF graphs, but the
--   structures aim to be quite generic with respect to the expression
--   forms allowed.
module Swish.Rule

-- | Expression is a type class for values over which proofs may be
--   constructed.
class Eq ex => Expression ex
isValid :: Expression ex => ex -> Bool

-- | A Formula is a named expression.
data Formula ex
Formula :: ScopedName -> ex -> Formula ex

-- | Name used for formula in proof chain
formName :: Formula ex -> ScopedName

-- | Named formula value
formExpr :: Formula ex -> ex

-- | Rule is a data type for inference rules that can be used to construct
--   a step in a proof.
data Rule ex
Rule :: ScopedName -> ([ex] -> [ex]) -> (ex -> [[ex]]) -> ([ex] -> ex -> Bool) -> Rule ex

-- | Name of rule, for use when displaying a proof
ruleName :: Rule ex -> ScopedName

-- | Forward application of a rule, takes a list of expressions and returns
--   a list (possibly empty) of forward applications of the rule to
--   combinations of the antecedent expressions. Note that all of the
--   results returned can be assumed to be (simultaneously) true, given the
--   antecedents provided.
fwdApply :: Rule ex -> [ex] -> [ex]

-- | Backward application of a rule, takes an expression and returns a list
--   of alternative antecedents, each of which is a list of expressions
--   that jointly yield the given consequence through application of the
--   inference rule. An empty list is returned if no antecedents will allow
--   the consequence to be inferred.
bwdApply :: Rule ex -> ex -> [[ex]]

-- | Inference check. Takes a list of antecedent expressions and a
--   consequent expression, returning True if the consequence can be
--   obtained from the antecedents by application of the rule. When the
--   antecedents and consequent are both given, this is generally more
--   efficient that using either forward or backward chaining. Also, a
--   particular rule may not fully support either forward or backward
--   chaining, but all rules are required to fully support this function.
--   
--   A default implementation based on forward chaining is given below.
checkInference :: Rule ex -> [ex] -> ex -> Bool

-- | A set of rules labelled with their name.
type RuleMap ex = Map ScopedName (Rule ex)

-- | The namespace <tt>http://id.ninebynine.org/2003/Ruleset/null</tt> with
--   the prefix <tt>null:</tt>.
nullScope :: Namespace

-- | Create a scoped name with the null namespace.
nullSN :: LName -> ScopedName

-- | The null formula.
nullFormula :: Formula ex

-- | The null rule.
nullRule :: Rule ex

-- | Checks that consequence is a result of applying the rule to the
--   antecedants.
fwdCheckInference :: Eq ex => Rule ex -> [ex] -> ex -> Bool

-- | Checks that the antecedants are all required to create the consequence
--   using the given rule.
bwdCheckInference :: Eq ex => Rule ex -> [ex] -> ex -> Bool

-- | Create a displayable form of a labelled formula
showsFormula :: ShowLines ex => String -> Formula ex -> ShowS

-- | Return a displayable form of a list of labelled formulae
showsFormulae :: ShowLines ex => String -> [Formula ex] -> String -> ShowS

-- | Show a string left justified in a field of at least the specified
--   number of characters width.
showsWidth :: Int -> String -> ShowS
instance Show ex => Show (Formula ex)
instance Show (Rule ex)
instance Ord (Rule ex)
instance Eq (Rule ex)
instance Ord (Formula ex)
instance Eq (Formula ex)


-- | This module defines a ruleset data type, used to collect information
--   about a ruleset that may contribute torwards inferences in RDF; e.g.
--   RDF and RDFS are rulesets.
--   
--   A <a>Ruleset</a> consists of a namespace, a collection of axioms, and
--   a collection of rules.
module Swish.Ruleset

-- | A Rule set.
data Ruleset ex
Ruleset :: Namespace -> [Formula ex] -> [Rule ex] -> Ruleset ex

-- | Namespace.
rsNamespace :: Ruleset ex -> Namespace

-- | Axioms.
rsAxioms :: Ruleset ex -> [Formula ex]

-- | Rules.
rsRules :: Ruleset ex -> [Rule ex]

-- | A set of Rulesets labelled by their Namespace.
type RulesetMap ex = Map Namespace (Ruleset ex)

-- | Create a ruleset.
makeRuleset :: Namespace -> [Formula ex] -> [Rule ex] -> Ruleset ex

-- | Extract the namespace of a ruleset.
getRulesetNamespace :: Ruleset ex -> Namespace

-- | Extract the axioms from a ruleset.
getRulesetAxioms :: Ruleset ex -> [Formula ex]

-- | Extract the rules from a ruleset.
getRulesetRules :: Ruleset ex -> [Rule ex]

-- | Find a named axiom in a ruleset.
getRulesetAxiom :: ScopedName -> Ruleset ex -> Maybe (Formula ex)

-- | Find a named rule in a ruleset.
getRulesetRule :: ScopedName -> Ruleset ex -> Maybe (Rule ex)

-- | Find a named axiom in a proof context.
getContextAxiom :: ScopedName -> Formula ex -> [Ruleset ex] -> Formula ex

-- | Find a named axiom in a proof context.
getMaybeContextAxiom :: ScopedName -> [Ruleset ex] -> Maybe (Formula ex)

-- | Find a named rule in a proof context.
getContextRule :: ScopedName -> Rule ex -> [Ruleset ex] -> Rule ex

-- | Find a named rule in a proof context.
getMaybeContextRule :: ScopedName -> [Ruleset ex] -> Maybe (Rule ex)
instance Eq (Ruleset ex)


-- | This module defines a framework for constructing proofs over some
--   expression form. It is intended to be used with RDF graphs, but the
--   structures aim to be quite generic with respect to the expression
--   forms allowed.
--   
--   It does not define any proof-finding strategy.
module Swish.Proof

-- | Proof is a structure that presents a chain of rule applications that
--   yield a result expression from a given expression
data Proof ex
Proof :: [Ruleset ex] -> Formula ex -> Formula ex -> [Step ex] -> Proof ex

-- | Proof context: list of rulesets, each of which provides a number of
--   axioms and rules.
proofContext :: Proof ex -> [Ruleset ex]

-- | Given expression
proofInput :: Proof ex -> Formula ex

-- | Result expression
proofResult :: Proof ex -> Formula ex

-- | Chain of inference rule applications progressing from input to result
proofChain :: Proof ex -> [Step ex]

-- | Step in proof chain
--   
--   The display name for a proof step comes from the display name of its
--   consequence formula.
data Step ex
Step :: Rule ex -> [Formula ex] -> Formula ex -> Step ex

-- | Inference rule used
stepRule :: Step ex -> Rule ex

-- | Antecedents of inference rule
stepAnt :: Step ex -> [Formula ex]

-- | Named consequence of inference rule
stepCon :: Step ex -> Formula ex

-- | Check consistency of given proof. The supplied rules and axioms are
--   assumed to be correct.
checkProof :: (Expression ex, Ord ex) => Proof ex -> Bool

-- | Check proof. If there is an error then return information about the
--   failing step.
explainProof :: (Expression ex, Ord ex) => Proof ex -> Maybe String

-- | A proof step is valid if rule is in list of rules and the antecedents
--   are sufficient to obtain the conclusion and the antecedents are in the
--   list of formulae already proven.
--   
--   Note: this function depends on the ruleName of any rule being unique
--   among all rules. In particular the name of the step rule being in
--   correspondence with the name of one of the indicated valid rules of
--   inference.
checkStep :: (Expression ex, Ord ex) => [Rule ex] -> [ex] -> Step ex -> Bool

-- | Returns a simple string representation of a proof.
showProof :: ShowLines ex => String -> Proof ex -> String

-- | Create a displayable form of a proof, returned as a <a>ShowS</a>
--   value.
--   
--   This function is intended to allow the calling function some control
--   of multiline displays by providing:
--   
--   <ol>
--   <li>the first line of the proof is not preceded by any text, so it may
--   be appended to some preceding text on the same line,</li>
--   <li>the supplied newline string is used to separate lines of the
--   formatted text, and may include any desired indentation, and</li>
--   <li>no newline is output following the final line of text.</li>
--   </ol>
showsProof :: ShowLines ex => String -> Proof ex -> ShowS

-- | Create a displayable form of a labelled formula
showsFormula :: ShowLines ex => String -> Formula ex -> ShowS
instance Show ex => Show (Step ex)


-- | This module defines some commonly used vocabulary terms from the RDF
--   (<a>http://www.w3.org/TR/rdf-syntax-grammar/</a>) and RDF Schema
--   (<a>http://www.w3.org/TR/rdf-schema/</a>) documents.
module Swish.RDF.Vocabulary.RDF

-- | Maps <tt>rdf</tt> to
--   <a>http://www.w3.org/1999/02/22-rdf-syntax-ns#</a>.
namespaceRDF :: Namespace

-- | Maps <tt>rdfs</tt> to <a>http://www.w3.org/2000/01/rdf-schema#</a>.
namespaceRDFS :: Namespace

-- | <tt>rdf:RDF</tt>.
rdfRDF :: ScopedName

-- | <tt>rdf:Description</tt>.
rdfDescription :: ScopedName

-- | <tt>rdf:ID</tt>.
rdfID :: ScopedName

-- | <tt>rdf:about</tt>.
rdfAbout :: ScopedName

-- | <tt>rdf:parseType</tt>.
rdfParseType :: ScopedName

-- | <tt>rdf:resource</tt>.
rdfResource :: ScopedName

-- | <tt>rdf:li</tt>.
rdfLi :: ScopedName

-- | <tt>rdf:nodeID</tt>.
rdfNodeID :: ScopedName

-- | <tt>rdf:datatype</tt>.
rdfDatatype :: ScopedName

-- | <tt>rdf:_1</tt>.
rdf1 :: ScopedName

-- | <tt>rdf:_2</tt>.
rdf2 :: ScopedName

-- | Create a <tt>rdf:_n</tt> entity.
--   
--   There is no check that the argument is not 0, so it is possible to
--   create the un-defined label <tt>rdf:_0</tt>.
rdfn :: Word32 -> ScopedName

-- | <tt>rdfs:Resource</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_resource</a>.
rdfsResource :: ScopedName

-- | <tt>rdfs:Class</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_class</a>.
rdfsClass :: ScopedName

-- | <tt>rdfs:Literal</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_literal</a>.
rdfsLiteral :: ScopedName

-- | <tt>rdfs:Datatype</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_datatype</a>.
rdfsDatatype :: ScopedName

-- | <tt>rdf:XMLLiteral</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_xmlliteral</a>.
rdfXMLLiteral :: ScopedName

-- | <tt>rdf:Property</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_property</a>.
rdfProperty :: ScopedName

-- | <tt>rdfs:range</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_range</a>.
rdfsRange :: ScopedName

-- | <tt>rdfs:domain</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_domain</a>.
rdfsDomain :: ScopedName

-- | <tt>rdf:type</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_type</a>.
rdfType :: ScopedName

-- | <tt>rdfs:subClassOf</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_subclassof</a>.
rdfsSubClassOf :: ScopedName

-- | <tt>rdfs:subPropertyOf</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_subpropertyof</a>.
rdfsSubPropertyOf :: ScopedName

-- | <tt>rdfs:label</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_label</a>.
rdfsLabel :: ScopedName

-- | <tt>rdfs:comment</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_comment</a>.
rdfsComment :: ScopedName

-- | <tt>rdfs:Container</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_container</a>.
rdfsContainer :: ScopedName

-- | <tt>rdf:Bag</tt> from <a>http://www.w3.org/TR/rdf-schema/#ch_bag</a>.
rdfBag :: ScopedName

-- | <tt>rdf:Seq</tt> from <a>http://www.w3.org/TR/rdf-schema/#ch_seq</a>.
rdfSeq :: ScopedName

-- | <tt>rdf:Alt</tt> from <a>http://www.w3.org/TR/rdf-schema/#ch_alt</a>.
rdfAlt :: ScopedName

-- | <tt>rdfs:ContainerMembershipProperty</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_containermembershipproperty</a>.
rdfsContainerMembershipProperty :: ScopedName

-- | <tt>rdfs:member</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_member</a>.
rdfsMember :: ScopedName

-- | <tt>rdf:List</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_list</a>.
rdfList :: ScopedName

-- | <tt>rdf:first</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_first</a>.
rdfFirst :: ScopedName

-- | <tt>rdf:rest</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_rest</a>.
rdfRest :: ScopedName

-- | <tt>rdf:nil</tt> from <a>http://www.w3.org/TR/rdf-schema/#ch_nil</a>.
rdfNil :: ScopedName

-- | <tt>rdf:Statement</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_statement</a>.
rdfStatement :: ScopedName

-- | <tt>rdf:subject</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_subject</a>.
rdfSubject :: ScopedName

-- | <tt>rdf:predicate</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_predicate</a>.
rdfPredicate :: ScopedName

-- | <tt>rdf:object</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_object</a>.
rdfObject :: ScopedName

-- | <tt>rdfs:seeAlso</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_seealso</a>.
rdfsSeeAlso :: ScopedName

-- | <tt>rdfs:isDefinedBy</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_isdefinedby</a>.
rdfsIsDefinedBy :: ScopedName

-- | <tt>rdf:value</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_value</a>.
rdfValue :: ScopedName


-- | This module defines vocabulary terms from the OWL vocabulary. Note
--   that there is an unfortunate mixture of styles for property names -
--   e.g. <a>owlSameAs</a> and <a>owlequivalentClass</a>. At present there
--   is no systematic attempt to include terms from the vocabulary.
module Swish.RDF.Vocabulary.OWL

-- | Maps <tt>owl</tt> to <a>http://www.w3.org/2002/07/owl#</a>.
namespaceOWL :: Namespace

-- | <tt>owl:Ontology</tt>.
owlOntology :: ScopedName

-- | <tt>owl:imports</tt>.
owlimports :: ScopedName

-- | <tt>owl:versionInfo</tt>.
owlversionInfo :: ScopedName

-- | <tt>owl:deprecated</tt>.
owldeprecated :: ScopedName

-- | <tt>owl:priorVersion</tt>.
owlpriorVersion :: ScopedName

-- | <tt>owl:backwartCompatibleWith</tt>.
owlbackwardCompatibleWith :: ScopedName

-- | <tt>owl:incompatibleWith</tt>.
owlincompatibleWith :: ScopedName

-- | <tt>owl:Class</tt>.
owlClass :: ScopedName

-- | <tt>owl:Thing</tt>.
owlThing :: ScopedName

-- | <tt>owl:Thing</tt>.
owlNothing :: ScopedName

-- | <tt>owl:NamedIndividual</tt>.
owlNamedIndividual :: ScopedName

-- | <tt>owl:sameAs</tt>.
owlSameAs :: ScopedName

-- | <tt>owl:equivalentClass</tt>.
owlequivalentClass :: ScopedName

-- | <tt>owl:equivalentProperty</tt>.
owlequivalentProperty :: ScopedName

-- | <tt>owl:ObjectProperty</tt>.
owlObjectProperty :: ScopedName

-- | <tt>owl:DatatypeProperty</tt>.
owlDatatypeProperty :: ScopedName

-- | <tt>owl:AnnotationProperty</tt>.
owlAnnotationProperty :: ScopedName

-- | <tt>owl:rational</tt>.
owlrational :: ScopedName

-- | <tt>owl:real</tt>.
owlreal :: ScopedName


-- | This module defines vocabulary terms from the XSD document.
module Swish.RDF.Vocabulary.XSD

-- | Maps <tt>xsd</tt> to <a>http://www.w3.org/2001/XMLSchema#</a>.
namespaceXSD :: Namespace

-- | Create a scoped name for an XSD datatype with the given name.
xsdType :: LName -> ScopedName

-- | <tt>xsd:string</tt> from
--   <a>http://www.w3.org/TR/xmlschema-2/#string</a>.
xsdString :: ScopedName

-- | <tt>xsd:boolean</tt> from
--   <a>http://www.w3.org/TR/xmlschema-2/#boolean</a>.
xsdBoolean :: ScopedName

-- | <tt>xsd:decimal</tt> from
--   <a>http://www.w3.org/TR/xmlschema-2/#decimal</a>.
xsdDecimal :: ScopedName

-- | <tt>xsd:float</tt> from
--   <a>http://www.w3.org/TR/xmlschema-2/#float</a>.
xsdFloat :: ScopedName

-- | <tt>xsd:double</tt> from
--   <a>http://www.w3.org/TR/xmlschema-2/#double</a>.
xsdDouble :: ScopedName

-- | <tt>xsd:dateTime</tt> from
--   <a>http://www.w3.org/TR/xmlschema-2/#dateTime</a>.
xsdDateTime :: ScopedName

-- | <tt>xsd:time</tt> from <a>http://www.w3.org/TR/xmlschema-2/#time</a>.
xsdTime :: ScopedName

-- | <tt>xsd:date</tt> from <a>http://www.w3.org/TR/xmlschema-2/#date</a>.
xsdDate :: ScopedName

-- | <tt>xsd:anyURI</tt> from
--   <a>http://www.w3.org/TR/xmlschema-2/#anyURI</a>.
xsdAnyURI :: ScopedName

-- | <tt>xsd:integer</tt> from
--   <a>http://www.w3.org/TR/xmlschema-2/#integer</a>.
xsdInteger :: ScopedName

-- | <tt>xsd:nonPositiveInteger</tt> from
--   <a>http://www.w3.org/TR/xmlschema-2/#nonPositiveInteger</a>.
xsdNonPosInteger :: ScopedName

-- | <tt>xsd:negativeInteger</tt> from
--   <a>http://www.w3.org/TR/xmlschema-2/#negativeInteger</a>.
xsdNegInteger :: ScopedName

-- | <tt>xsd:long</tt> from <a>http://www.w3.org/TR/xmlschema-2/#long</a>.
xsdLong :: ScopedName

-- | <tt>xsd:int</tt> from <a>http://www.w3.org/TR/xmlschema-2/#int</a>.
xsdInt :: ScopedName

-- | <tt>xsd:short</tt> from
--   <a>http://www.w3.org/TR/xmlschema-2/#short</a>.
xsdShort :: ScopedName

-- | <tt>xsd:byte</tt> from <a>http://www.w3.org/TR/xmlschema-2/#byte</a>.
xsdByte :: ScopedName

-- | <tt>xsd:nonNegativeInteger</tt> from
--   <a>http://www.w3.org/TR/xmlschema-2/#nonNegativeInteger</a>.
xsdNonNegInteger :: ScopedName

-- | <tt>xsd:unsignedLong</tt> from
--   <a>http://www.w3.org/TR/xmlschema-2/#unsignedLong</a>.
xsdUnsignedLong :: ScopedName

-- | <tt>xsd:unsignedInt</tt> from
--   <a>http://www.w3.org/TR/xmlschema-2/#unsignedInt</a>.
xsdUnsignedInt :: ScopedName

-- | <tt>xsd:unsignedShort</tt> from
--   <a>http://www.w3.org/TR/xmlschema-2/#unsignedShort</a>.
xsdUnsignedShort :: ScopedName

-- | <tt>xsd:unsignedByte</tt> from
--   <a>http://www.w3.org/TR/xmlschema-2/#unsignedByte</a>.
xsdUnsignedByte :: ScopedName

-- | <tt>xsd:positiveInteger</tt> from
--   <a>http://www.w3.org/TR/xmlschema-2/#positiveInteger</a>.
xsdPosInteger :: ScopedName


-- | This module defines some commonly used vocabulary terms, using the
--   <a>Namespace</a> and <a>ScopedName</a> data types. Additional
--   vocabularies are available in the set of
--   <tt>Swish.RDF.Vocabulary.*</tt> modules, parts of which are
--   re-exported by this module
module Swish.RDF.Vocabulary

-- | Maps <tt>rdfd</tt> to
--   <tt>http://id.ninebynine.org/2003/rdfext/rdfd#</tt>.
namespaceRDFD :: Namespace

-- | Create a namespace for the datatype family schema used by Swish.
namespaceXsdType :: LName -> Namespace

-- | Maps <tt>math</tt> to <a>http://www.w3.org/2000/10/swap/math#</a>.
namespaceMATH :: Namespace

-- | Maps <tt>log</tt> to <a>http://www.w3.org/2000/10/swap/log#</a>.
namespaceLOG :: Namespace

-- | Maps <tt>daml</tt> to <a>http://www.daml.org/2000/10/daml-ont#</a>.
namespaceDAML :: Namespace

-- | Maps <tt>default</tt> to <tt>http://id.ninebynine.org/default/</tt>.
namespaceDefault :: Namespace

-- | Maps <tt>swish</tt> to <tt>http://id.ninebynine.org/2003/Swish/</tt>.
namespaceSwish :: Namespace

-- | Maps <tt>rs_rdf</tt> to
--   <tt>http://id.ninebynine.org/2003/Ruleset/rdf#</tt>.
scopeRDF :: Namespace

-- | Maps <tt>rs_rdfs</tt> to
--   <tt>http://id.ninebynine.org/2003/Ruleset/rdfs#</tt>.
scopeRDFS :: Namespace

-- | Maps <tt>rs_rdfd</tt> to
--   <tt>http://id.ninebynine.org/2003/Ruleset/rdfd#</tt>.
scopeRDFD :: Namespace

-- | Represent the language tag for a literal string, following RFC 3066
--   <a>http://www.ietf.org/rfc/rfc3066.txt</a>.
--   
--   Use <a>toLangTag</a> to create a tag and <a>fromLangTag</a> to convert
--   back. The case is preserved for the tag, although comparison (both the
--   <a>Eq</a> instance and <tt>compareLangTag</tt>) is done using the
--   lower-case form of the tags.
--   
--   As an example:
--   
--   <pre>
--   Prelude&gt; :set prompt "swish&gt; "
--   swish&gt; :set -XOverloadedStrings
--   swish&gt; :m + Swish.RDF.Vocabulary
--   swish&gt; let en = "en" :: LanguageTag
--   swish&gt; let us = "en-us" :: LanguageTag
--   swish&gt; let gb = "en-GB" :: LanguageTag
--   swish&gt; gb
--   en-GB
--   swish&gt; gb == "en-gb"
--   True
--   swish&gt; en == us
--   False
--   swish&gt; en `isBaseLang` us
--   True
--   swish&gt; us `isBaseLang` en
--   False
--   swish&gt; us `isBaseLang` gb
--   False
--   </pre>
data LanguageTag

-- | Create a <a>LanguageTag</a> element from the label.
--   
--   Valid tags follow the ABNF from RCF 3066, which is
--   
--   <pre>
--   Language-Tag = Primary-subtag *( "-" Subtag )
--   Primary-subtag = 1*8ALPHA
--   Subtag = 1*8(ALPHA / DIGIT)
--   </pre>
--   
--   There are no checks that the primary or secondary sub tag values are
--   defined in any standard, such as ISO 639, or obey any other
--   syntactical restriction than given above.
toLangTag :: Text -> Maybe LanguageTag

-- | Convert a language tag back into text form.
fromLangTag :: LanguageTag -> Text

-- | Compare language tags using the Language-range specification in
--   section 2.5 of RFC 3066.
--   
--   <a>True</a> is returned if the comparison tag is the same as, or
--   matches a prefix of, the base tag (where the match must be over
--   complete sub tags).
--   
--   Note that
--   
--   <pre>
--   l1 `isBaseLang` l2 == l2 `isBaseLang` l1
--   </pre>
--   
--   only when
--   
--   <pre>
--   l1 == l2
--   </pre>
isBaseLang :: LanguageTag -> LanguageTag -> Bool

-- | Convert a local name to a scoped name in the <tt>swish</tt> namespace
--   (<a>namespaceSwish</a>).
swishName :: LName -> ScopedName

-- | <tt>rdfd:GeneralRestriction</tt>.
rdfdGeneralRestriction :: ScopedName

-- | <tt>rdfd:onProperties</tt>.
rdfdOnProperties :: ScopedName

-- | <tt>rdfd:constraint</tt>.
rdfdConstraint :: ScopedName

-- | <tt>rdfd:maxCardinality</tt>.
rdfdMaxCardinality :: ScopedName

-- | <tt>log:implies</tt>.
logImplies :: ScopedName

-- | <tt>default:base</tt>.
defaultBase :: ScopedName
instance Ord LanguageTag
instance Eq LanguageTag
instance IsString LanguageTag
instance Show LanguageTag


-- | This module defines a memory-based RDF graph instance. At present only
--   RDF 1.0 is explicitly supported; I have not gone through the RDF 1.1
--   changes to see how the code needs to be updated. This means that you
--   can have untyped strings in your graph that do not match the same
--   content but with an explicit <tt>xsd:string</tt> datatype.
--   
--   Note that the identifiers for blank nodes may <i>not</i> be propogated
--   when a graph is written out using one of the formatters, such as
--   <a>Turtle</a>. There is limited support for generating new blank nodes
--   from an existing set of triples; e.g. <a>newNode</a> and
--   <a>newNodes</a>.
module Swish.RDF.Graph

-- | RDF graph node values
--   
--   cf. <a>http://www.w3.org/TR/rdf-concepts/#section-Graph-syntax</a>
--   version 1.0
--   
--   This is extended from the RDF abstract graph syntax in the following
--   ways:
--   
--   (a) a graph can be part of a resource node or blank node (cf.
--   Notation3 formulae)
--   
--   (b) a "variable" node option is distinguished from a blank node. I
--   have found this useful for encoding and handling queries, even though
--   query variables can be expressed as blank nodes.
--   
--   (c) a "NoNode" option is defined. This might otherwise be handled by
--   <tt>Maybe (RDFLabel g)</tt>.
--   
--   Prior to version <tt>0.7.0.0</tt>, literals were represented by a
--   single constructor, <tt>Lit</tt>, with an optional argument. Language
--   codes for literals was also stored as a <a>ScopedName</a> rather than
--   as a <a>LanguageTag</a>.
data RDFLabel

-- | resource
Res :: ScopedName -> RDFLabel

-- | plain literal
--   (<a>http://www.w3.org/TR/rdf-concepts/#dfn-plain-literal</a>)
Lit :: Text -> RDFLabel

-- | plain literal
LangLit :: Text -> LanguageTag -> RDFLabel

-- | typed literal
--   (<a>http://www.w3.org/TR/rdf-concepts/#dfn-typed-literal</a>)
TypedLit :: Text -> ScopedName -> RDFLabel

-- | blank node
Blank :: String -> RDFLabel

-- | variable (not used in ordinary graphs)
Var :: String -> RDFLabel

-- | no node (not used in ordinary graphs)
NoNode :: RDFLabel

-- | A type that can be converted to a RDF Label.
--   
--   The String instance converts to an untyped literal (so no language tag
--   is assumed).
--   
--   The <a>UTCTime</a> and <a>Day</a> instances assume values are in UTC.
--   
--   The conversion for XSD types attempts to use the canonical form
--   described in section 2.3.1 of
--   <a>http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#lexical-space</a>.
--   
--   Note that this is similar to <a>toRDFLabel</a>; the code should
--   probably be combined at some point.
class ToRDFLabel a
toRDFLabel :: ToRDFLabel a => a -> RDFLabel

-- | A type that can be converted from a RDF Label, with the possibility of
--   failure.
--   
--   The String instance converts from an untyped literal (so it can not be
--   used with a string with a language tag).
--   
--   The following conversions are supported for common XSD types
--   (out-of-band values result in <tt>Nothing</tt>):
--   
--   <ul>
--   <li><tt>xsd:boolean</tt> to <tt>Bool</tt></li>
--   <li><tt>xsd:integer</tt> to <tt>Int</tt> and <tt>Integer</tt></li>
--   <li><tt>xsd:float</tt> to <tt>Float</tt></li>
--   <li><tt>xsd:double</tt> to <tt>Double</tt></li>
--   <li><tt>xsd:dateTime</tt> to <tt>UTCTime</tt></li>
--   <li><tt>xsd:date</tt> to <tt>Day</tt></li>
--   </ul>
--   
--   Note that this is similar to <a>fromRDFLabel</a>; the code should
--   probably be combined at some point.
class FromRDFLabel a
fromRDFLabel :: FromRDFLabel a => RDFLabel -> Maybe a

-- | Test if supplied labal is a literal node (<a>Lit</a>, <a>LangLit</a>,
--   or <a>TypedLit</a>).
isLiteral :: RDFLabel -> Bool

-- | Test if supplied labal is an untyped literal node (either <a>Lit</a>
--   or <a>LangLit</a>).
isUntypedLiteral :: RDFLabel -> Bool

-- | Test if supplied labal is a typed literal node (<a>TypedLit</a>).
isTypedLiteral :: RDFLabel -> Bool

-- | Test if supplied labal is a XML literal node
isXMLLiteral :: RDFLabel -> Bool

-- | Test if supplied label is a typed literal node of a given datatype
isDatatyped :: ScopedName -> RDFLabel -> Bool

-- | Test if supplied label is a container membership property
--   
--   Check for namespace is RDF namespace and first character of local name
--   is '_' and remaining characters of local name are all digits
isMemberProp :: RDFLabel -> Bool

-- | Test if supplied labal is a URI resource node
isUri :: RDFLabel -> Bool

-- | Test if supplied labal is a blank node
isBlank :: RDFLabel -> Bool

-- | Test if supplied labal is a query variable
isQueryVar :: RDFLabel -> Bool

-- | Extract text value from a literal node (including the Language and
--   Typed variants). The empty string is returned for other nodes.
getLiteralText :: RDFLabel -> Text

-- | Extract the ScopedName value from a resource node
--   (<a>nullScopedName</a> is returned for non-resource nodes).
getScopedName :: RDFLabel -> ScopedName

-- | Make a blank node from a supplied query variable, or return the
--   supplied label unchanged. (Use this in when substituting an
--   existential for an unsubstituted query variable.)
makeBlank :: RDFLabel -> RDFLabel

-- | Turtle-style quoting rules for a string.
--   
--   At present the choice is between using one or three double quote
--   (<tt>"</tt>) characters to surround the string; i.e. using single
--   quote (<tt>'</tt>) characters is not supported.
--   
--   As of Swish 0.9.0.6, the <tt>\f</tt> character is converted to
--   <tt>\u000C</tt> rather than left as is to aid interoperability with
--   some other tools.
quote :: Bool -> String -> String

-- | See <a>quote</a>.
quoteT :: Bool -> Text -> Text

-- | A set of RDF triples.
type RDFArcSet = ArcSet RDFLabel

-- | RDF Triple (statement)
--   
--   At present there is no check or type-level constraint that stops the
--   subject or predicate of the triple from being a literal.
type RDFTriple = Arc RDFLabel

-- | Convert 3 RDF labels to a RDF triple.
--   
--   See also <tt>Swish.RDF.GraphClass.arcFromTriple</tt>.
toRDFTriple :: (ToRDFLabel s, ToRDFLabel p, ToRDFLabel o) => s -> p -> o -> RDFTriple

-- | Extract the contents of a RDF triple.
--   
--   See also <tt>Swish.RDF.GraphClass.arcToTriple</tt>.
fromRDFTriple :: (FromRDFLabel s, FromRDFLabel p, FromRDFLabel o) => RDFTriple -> Maybe (s, p, o)

-- | Memory-based graph with namespaces and subgraphs.
--   
--   The primary means for adding arcs to an existing graph are:
--   
--   <ul>
--   <li><a>setArcs</a> from the <a>LDGraph</a> instance, which replaces
--   the existing set of arcs and does not change the namespace map.</li>
--   <li><a>addArc</a> which checks that the arc is unknown before adding
--   it but does not change the namespace map or re-label any blank nodes
--   in the arc.</li>
--   </ul>
data NSGraph lb
NSGraph :: NamespaceMap -> FormulaMap lb -> ArcSet lb -> NSGraph lb

-- | the namespaces to use
namespaces :: NSGraph lb -> NamespaceMap

-- | any associated formulae (a.k.a. sub- or named- graps)
formulae :: NSGraph lb -> FormulaMap lb

-- | the statements in the graph
statements :: NSGraph lb -> ArcSet lb

-- | Memory-based RDF graph type
type RDFGraph = NSGraph RDFLabel

-- | Create a new RDF graph from a supplied set of arcs.
--   
--   This version will attempt to fill up the namespace map of the graph
--   based on the input labels (including datatypes on literals). For
--   faster creation of a graph you can use:
--   
--   <pre>
--   emptyRDFGraph { statements = arcs }
--   </pre>
--   
--   which is how this routine was defined in version <tt>0.3.1.1</tt> and
--   earlier.
toRDFGraph :: RDFArcSet -> RDFGraph

-- | Create a new, empty RDF graph (it is just <a>mempty</a>).
emptyRDFGraph :: RDFGraph

-- | Namespace prefix list entry
--   
--   A map for name spaces (key is the prefix).
type NamespaceMap = Map (Maybe Text) URI

-- | Create an empty namespace map.
emptyNamespaceMap :: NamespaceMap

-- | Graph formula entry
data LookupFormula lb gr
Formula :: lb -> gr -> LookupFormula lb gr

-- | The label for the formula
formLabel :: LookupFormula lb gr -> lb

-- | The contents of the formula
formGraph :: LookupFormula lb gr -> gr

-- | A named formula.
type Formula lb = LookupFormula lb (NSGraph lb)

-- | A map for named formulae.
type FormulaMap lb = Map lb (NSGraph lb)

-- | Create an empty formula map.
emptyFormulaMap :: FormulaMap RDFLabel

-- | Add an arc to the graph. It does not relabel any blank nodes in the
--   input arc, nor does it change the namespace map, but it does ensure
--   that the arc is unknown before adding it.
addArc :: Label lb => Arc lb -> NSGraph lb -> NSGraph lb

-- | Merge RDF graphs, renaming blank and query variable nodes as needed to
--   neep variable nodes from the two graphs distinct in the resulting
--   graph.
--   
--   Currently formulae are not guaranteed to be preserved across a merge.
merge :: Label lb => NSGraph lb -> NSGraph lb -> NSGraph lb

-- | Return list of all labels (including properties) in the graph
--   satisfying a supplied filter predicate. This routine includes the
--   labels in any formulae.
allLabels :: Label lb => (lb -> Bool) -> NSGraph lb -> Set lb

-- | Return list of all subjects and objects in the graph satisfying a
--   supplied filter predicate.
allNodes :: Label lb => (lb -> Bool) -> NSGraph lb -> Set lb

-- | Remap selected nodes in graph.
--   
--   This is the node renaming operation that prevents graph-scoped
--   variable nodes from being merged when two graphs are merged.
remapLabels :: Label lb => [lb] -> [lb] -> (lb -> lb) -> NSGraph lb -> NSGraph lb

-- | Externally callable function to construct a list of (old,new) values
--   to be used for graph label remapping.
remapLabelList :: Label lb => [lb] -> [lb] -> [(lb, lb)]

-- | Given a node and a list of existing nodes, find a new node for the
--   supplied node that does not clash with any existing node. (Generates
--   an non-terminating list of possible replacements, and picks the first
--   one that isn't already in use.)
newNode :: Label lb => lb -> [lb] -> lb

-- | Given a node and a list of existing nodes, generate a list of new
--   nodes for the supplied node that do not clash with any existing node.
newNodes :: Label lb => lb -> [lb] -> [lb]

-- | Replace the namespace information in the graph.
setNamespaces :: NamespaceMap -> NSGraph lb -> NSGraph lb

-- | Retrieve the namespace map in the graph.
getNamespaces :: NSGraph lb -> NamespaceMap

-- | Replace the formulae in the graph.
setFormulae :: FormulaMap lb -> NSGraph lb -> NSGraph lb

-- | Retrieve the formulae in the graph.
getFormulae :: NSGraph lb -> FormulaMap lb

-- | Add (or replace) a formula.
setFormula :: Label lb => Formula lb -> NSGraph lb -> NSGraph lb

-- | Find a formula in the graph, if it exists.
getFormula :: Label lb => NSGraph lb -> lb -> Maybe (NSGraph lb)

-- | <a>fmap</a> for <a>NSGraph</a> instances.
fmapNSGraph :: Ord lb => (lb -> lb) -> NSGraph lb -> NSGraph lb

-- | <a>traverse</a> for <a>NSGraph</a> instances.
traverseNSGraph :: (Applicative f, Ord a) => (a -> f a) -> NSGraph a -> f (NSGraph a)

-- | Labelled Directed Graph class.
--   
--   Minimum required implementation: <a>emptyGraph</a>, <a>setArcs</a>,
--   and <a>getArcs</a>.
class LDGraph lg lb where extract sel = update (filter sel) addGraphs addg = update (union (getArcs addg)) delete g1 g2 = setArcs g2 (getArcs g2 `difference` getArcs g1) labels = getComponents arcLabels . getArcs nodes = getComponents arcNodes . getArcs update f g = setArcs g (f (getArcs g))
emptyGraph :: LDGraph lg lb => lg lb
setArcs :: LDGraph lg lb => lg lb -> ArcSet lb -> lg lb
getArcs :: LDGraph lg lb => lg lb -> ArcSet lb
extract :: (LDGraph lg lb, Ord lb) => Selector lb -> lg lb -> lg lb
addGraphs :: (LDGraph lg lb, Ord lb) => lg lb -> lg lb -> lg lb
delete :: (LDGraph lg lb, Ord lb) => lg lb -> lg lb -> lg lb
labels :: (LDGraph lg lb, Ord lb) => lg lb -> Set lb
nodes :: (LDGraph lg lb, Ord lb) => lg lb -> Set lb
update :: LDGraph lg lb => (ArcSet lb -> ArcSet lb) -> lg lb -> lg lb

-- | Label class.
--   
--   A label may have a fixed binding, which means that the label
--   identifies (is) a particular graph node, and different such labels are
--   always distinct nodes. Alternatively, a label may be unbound
--   (variable), which means that it is a placeholder for an unknown node
--   label. Unbound node labels are used as graph-local identifiers for
--   indicating when the same node appears in several arcs.
--   
--   For the purposes of graph-isomorphism testing, fixed labels are
--   matched when they are the same. Variable labels may be matched with
--   any other variable label. Our definition of isomorphism (for RDF
--   graphs) does not match variable labels with fixed labels.
class (Ord lb, Show lb) => Label lb
labelIsVar :: Label lb => lb -> Bool
labelHash :: Label lb => Int -> lb -> Int
getLocal :: Label lb => lb -> String
makeLabel :: Label lb => String -> lb

-- | Arc type.
--   
--   Prior to <tt>0.7.0.0</tt> you could also use <tt>asubj</tt>,
--   <tt>apred</tt> and <tt>aobj</tt> to access the elements of the arc.
data Arc lb
Arc :: lb -> lb -> lb -> Arc lb

-- | The subject of the arc.
arcSubj :: Arc lb -> lb

-- | The predicate (property) of the arc.
arcPred :: Arc lb -> lb

-- | The object of the arc.
arcObj :: Arc lb -> lb

-- | Create an arc.
arc :: lb -> lb -> lb -> Arc lb

-- | Identify arcs.
type Selector lb = Arc lb -> Bool

-- | <tt>rdf:RDF</tt>.
resRdfRDF :: RDFLabel

-- | <tt>rdf:Description</tt>.
resRdfDescription :: RDFLabel

-- | <tt>rdf:ID</tt>.
resRdfID :: RDFLabel

-- | <tt>rdf:about</tt>.
resRdfAbout :: RDFLabel

-- | <tt>rdf:parseType</tt>.
resRdfParseType :: RDFLabel

-- | <tt>rdf:resource</tt>.
resRdfResource :: RDFLabel

-- | <tt>rdf:li</tt>.
resRdfLi :: RDFLabel

-- | <tt>rdf:nodeID</tt>.
resRdfNodeID :: RDFLabel

-- | <tt>rdf:datatype</tt>.
resRdfDatatype :: RDFLabel

-- | <tt>rdf:_1</tt>.
resRdf1 :: RDFLabel

-- | <tt>rdf:_2</tt>.
resRdf2 :: RDFLabel

-- | Create a <tt>rdf:_n</tt> entity.
--   
--   There is no check that the argument is not <tt>0</tt>.
resRdfn :: Word32 -> RDFLabel

-- | <tt>rdfs:Resource</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_resource</a>.
resRdfsResource :: RDFLabel

-- | <tt>rdfs:Class</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_class</a>.
resRdfsClass :: RDFLabel

-- | <tt>rdfs:Literal</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_literal</a>.
resRdfsLiteral :: RDFLabel

-- | <tt>rdfs:Datatype</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_datatype</a>.
resRdfsDatatype :: RDFLabel

-- | <tt>rdf:XMLLiteral</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_xmlliteral</a>.
resRdfXMLLiteral :: RDFLabel

-- | <tt>rdf:Property</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_property</a>.
resRdfProperty :: RDFLabel

-- | <tt>rdfs:range</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_range</a>.
resRdfsRange :: RDFLabel

-- | <tt>rdfs:domain</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_domain</a>.
resRdfsDomain :: RDFLabel

-- | <tt>rdf:type</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_type</a>.
resRdfType :: RDFLabel

-- | <tt>rdfs:subClassOf</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_subclassof</a>.
resRdfsSubClassOf :: RDFLabel

-- | <tt>rdfs:subPropertyOf</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_subpropertyof</a>.
resRdfsSubPropertyOf :: RDFLabel

-- | <tt>rdfs:label</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_label</a>.
resRdfsLabel :: RDFLabel

-- | <tt>rdfs:comment</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_comment</a>.
resRdfsComment :: RDFLabel

-- | <tt>rdfs:Container</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_container</a>.
resRdfsContainer :: RDFLabel

-- | <tt>rdf:Bag</tt> from <a>http://www.w3.org/TR/rdf-schema/#ch_bag</a>.
resRdfBag :: RDFLabel

-- | <tt>rdf:Seq</tt> from <a>http://www.w3.org/TR/rdf-schema/#ch_seq</a>.
resRdfSeq :: RDFLabel

-- | <tt>rdf:Alt</tt> from <a>http://www.w3.org/TR/rdf-schema/#ch_alt</a>.
resRdfAlt :: RDFLabel

-- | <tt>rdfs:ContainerMembershipProperty</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_containermembershipproperty</a>.
resRdfsContainerMembershipProperty :: RDFLabel

-- | <tt>rdfs:member</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_member</a>.
resRdfsMember :: RDFLabel

-- | <tt>rdf:List</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_list</a>.
resRdfList :: RDFLabel

-- | <tt>rdf:first</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_first</a>.
resRdfFirst :: RDFLabel

-- | <tt>rdf:rest</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_rest</a>.
resRdfRest :: RDFLabel

-- | <tt>rdf:nil</tt> from <a>http://www.w3.org/TR/rdf-schema/#ch_nil</a>.
resRdfNil :: RDFLabel

-- | <tt>rdf:Statement</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_statement</a>.
resRdfStatement :: RDFLabel

-- | <tt>rdf:subject</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_subject</a>.
resRdfSubject :: RDFLabel

-- | <tt>rdf:predicate</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_predicate</a>.
resRdfPredicate :: RDFLabel

-- | <tt>rdf:object</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_object</a>.
resRdfObject :: RDFLabel

-- | <tt>rdfs:seeAlso</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_seealso</a>.
resRdfsSeeAlso :: RDFLabel

-- | <tt>rdfs:isDefinedBy</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_isdefinedby</a>.
resRdfsIsDefinedBy :: RDFLabel

-- | <tt>rdf:value</tt> from
--   <a>http://www.w3.org/TR/rdf-schema/#ch_value</a>.
resRdfValue :: RDFLabel

-- | <tt>owl:sameAs</tt>.
resOwlSameAs :: RDFLabel

-- | <tt>rdfd:GeneralRestriction</tt>.
resRdfdGeneralRestriction :: RDFLabel

-- | <tt>rdfd:onProperties</tt>.
resRdfdOnProperties :: RDFLabel

-- | <tt>rdfd:constraint</tt>.
resRdfdConstraint :: RDFLabel

-- | <tt>rdfd:maxCardinality</tt>.
resRdfdMaxCardinality :: RDFLabel

-- | <tt>log:implies</tt>.
resLogImplies :: RDFLabel

-- | Match graphs, returning <a>True</a> if they are equivalent, with a map
--   of labels to equivalence class identifiers (see <a>graphMatch</a> for
--   further details).
grMatchMap :: Label lb => NSGraph lb -> NSGraph lb -> (Bool, LabelMap (ScopedLabel lb))

-- | Graph equality.
grEq :: Label lb => NSGraph lb -> NSGraph lb -> Bool

-- | Remap a single graph node.
--   
--   If the node is not one of those to be remapped, the supplied value is
--   returned unchanged.
mapnode :: Label lb => [lb] -> [lb] -> (lb -> lb) -> lb -> lb

-- | Construct a list of (oldnode,newnode) values to be used for graph
--   label remapping. The function operates recursively, adding new nodes
--   generated to the accumulator and also to the list of nodes to be
--   avoided.
maplist :: Label lb => [lb] -> [lb] -> (lb -> lb) -> [(lb, lb)] -> [(lb, lb)]
instance Label lb => Show (NSGraph lb)
instance Label lb => Ord (NSGraph lb)
instance Label lb => Eq (NSGraph lb)
instance Label lb => Monoid (NSGraph lb)
instance Label lb => LDGraph NSGraph lb
instance Label lb => Show (Formula lb)
instance (Ord lb, Ord gr) => Ord (LookupFormula lb gr)
instance (Eq lb, Eq gr) => Eq (LookupFormula lb gr)
instance FromRDFLabel URI
instance ToRDFLabel URI
instance FromRDFLabel QName
instance ToRDFLabel QName
instance FromRDFLabel ScopedName
instance ToRDFLabel ScopedName
instance FromRDFLabel Day
instance ToRDFLabel Day
instance FromRDFLabel UTCTime
instance ToRDFLabel UTCTime
instance FromRDFLabel Integer
instance ToRDFLabel Integer
instance FromRDFLabel Int
instance ToRDFLabel Int
instance FromRDFLabel Double
instance ToRDFLabel Double
instance FromRDFLabel Float
instance ToRDFLabel Float
instance FromRDFLabel Bool
instance ToRDFLabel Bool
instance FromRDFLabel String
instance ToRDFLabel String
instance FromRDFLabel Char
instance ToRDFLabel Char
instance FromRDFLabel RDFLabel
instance ToRDFLabel RDFLabel
instance IsString RDFLabel
instance Label RDFLabel
instance Ord RDFLabel
instance Show RDFLabel
instance Eq RDFLabel


-- | This module provides an in-memory RDF Graph (it re-exports
--   <a>Swish.RDF.Graph</a>).
module Swish.RDF


-- | Support for the RDF Parsing modules.
module Swish.RDF.Parser.Utils

-- | Type for special name lookup table
type SpecialMap = Map String ScopedName

-- | Define default table of namespaces
prefixTable :: [Namespace]

-- | Define default special-URI table.
specialTable :: Maybe ScopedName -> [(String, ScopedName)]

-- | Run the parser and return the successful parse or an error message
--   which consists of the standard Polyparse error plus a fragment of the
--   unparsed input to provide context.
runParserWithError :: Parser a b -> a -> Text -> Either String b

-- | The result of a parse, which is either an error message or a graph.
type ParseResult = Either String RDFGraph

-- | Run the parser and ignore the result.
ignore :: Applicative f => f a -> f ()

-- | Match the character.
char :: Char -> Parser s Char

-- | Match the character, ignoring the result.
ichar :: Char -> Parser s ()

-- | Match the text.
string :: String -> Parser s String

-- | Match the text.
stringT :: Text -> Parser s Text

-- | Match the given string and any trailing <a>whiteSpace</a>.
symbol :: String -> Parser s String

-- | As <a>symbol</a> but ignoring the result.
isymbol :: String -> Parser s ()

-- | Convert a parser into one that also matches, and ignores, trailing
--   <a>whiteSpace</a>.
lexeme :: Parser s a -> Parser s a

-- | Succeed if the next character does not match the given function.
notFollowedBy :: (Char -> Bool) -> Parser s ()

-- | Match white space: a space or a comment (<tt>#</tt> character and
--   anything following it up to to a new line).
whiteSpace :: Parser s ()

-- | Run the parser <a>many</a> times and ignore the result.
skipMany :: Parser s a -> Parser s ()

-- | Run the parser <a>many1</a> times and ignore the result.
skipMany1 :: Parser s a -> Parser s ()

-- | Match zero or more occurences of parser followed by separator.
endBy :: Parser s a -> Parser s b -> Parser s [a]

-- | Match zero or more occurences of the parser followed by the separator.
sepEndBy :: Parser s a -> Parser s b -> Parser s [a]

-- | Accept one or more occurences of the parser separated by the
--   separator. Unlike <a>endBy</a> the last separator is optional.
sepEndBy1 :: Parser s a -> Parser s b -> Parser s [a]

-- | Accept zero or more runs of the parser ending with the delimiter.
manyTill :: Parser s a -> Parser s b -> Parser s [a]

-- | Accept any character that is not a member of the given string.
noneOf :: String -> Parser s Char

-- | Match the end-of-line sequence (<tt>"\n"</tt>, <tt>"\r"</tt>, or
--   <tt>"\r\n"</tt>).
eoln :: Parser s ()

-- | Matches <a>.</a>.
fullStop :: Parser s ()

-- | A four-digit hex value (e.g. <tt>1a34</tt> or <tt>03F1</tt>).
hex4 :: Parser a Char

-- | An eight-digit hex value that has a maximum of <tt>0010FFFF</tt>.
hex8 :: Parser a Char

-- | Append the two URIs. Given the change in signature of
--   <a>relativeTo</a> in version <tt>2.4.0.0</tt> of <tt>network</tt>, it
--   is not clear that this function is necessary. At the very least, it
--   should be changed to just return a <a>URI</a>.
appendURIs :: URI -> URI -> Either String URI


-- | This Module implements a NTriples parser, returning a new
--   <a>RDFGraph</a> consisting of triples and namespace information parsed
--   from the supplied NTriples input string, or an error indication.
--   
--   REFERENCES:
--   
--   <ul>
--   <li>"RDF Test Cases", W3C Recommendation 10 February 2004,
--   <a>http://www.w3.org/TR/rdf-testcases/#ntriples</a></li>
--   </ul>
--   
--   NOTES:
--   
--   <ul>
--   <li>If the URI is actually an IRI (Internationalized Resource
--   Identifiers) then the parser will fail since <a>parseURI</a>
--   fails.</li>
--   <li>The case of language tags is retained.</li>
--   <li>Update to the document "N-Triples. A line-based syntax for an RDF
--   graph" W3C Working Group Note 09 April 2013,
--   <a>http://www.w3.org/TR/2013/NOTE-n-triples-20130409/</a></li>
--   </ul>
module Swish.RDF.Parser.NTriples

-- | The result of a parse, which is either an error message or a graph.
type ParseResult = Either String RDFGraph

-- | Parse a string.
parseNT :: Text -> ParseResult


-- | This module defines functions for representing and manipulating query
--   binding variable sets. This is the key data that mediates between
--   query and back substitution when performing inferences. A framework of
--   query variable modifiers is provided that can be used to implement
--   richer inferences, such as filtering of query results, or replacing
--   values based on known relationships.
module Swish.VarBinding

-- | VarBinding is the type of an arbitrary variable bindings value, where
--   the type of the bound values is not specified.
data VarBinding a b
VarBinding :: (a -> Maybe b) -> Set (a, b) -> Bool -> VarBinding a b
vbMap :: VarBinding a b -> a -> Maybe b
vbEnum :: VarBinding a b -> Set (a, b)
vbNull :: VarBinding a b -> Bool

-- | The null, or empry, binding maps no query variables. This is the
--   <a>mempty</a> instance of the Monoid.
nullVarBinding :: VarBinding a b

-- | Return a list of the variables bound by a supplied variable binding
boundVars :: (Ord a, Ord b) => VarBinding a b -> Set a

-- | VarBinding subset function, tests to see if one query binding is a
--   subset of another; i.e. every query variable mapping defined by one is
--   also defined by the other.
subBinding :: (Ord a, Ord b) => VarBinding a b -> VarBinding a b -> Bool

-- | Function to make a variable binding from a list of pairs of variable
--   and corresponding assigned value.
makeVarBinding :: (Ord a, Ord b) => [(a, b)] -> VarBinding a b

-- | Apply query binding to a supplied value, returning the value unchanged
--   if no binding is defined
applyVarBinding :: VarBinding a a -> a -> a

-- | Join a pair of query bindings, returning a new binding that maps all
--   variables recognized by either of the input bindings. If the bindings
--   should overlap, such overlap is not detected and the value from the
--   first binding provided is used.
joinVarBindings :: (Ord a, Ord b) => VarBinding a b -> VarBinding a b -> VarBinding a b

-- | Add a single new value to a variable binding and return the resulting
--   new variable binding.
addVarBinding :: (Ord a, Ord b) => a -> b -> VarBinding a b -> VarBinding a b

-- | Define the type of a function to modify variable bindings in forward
--   chaining based on rule antecedent matches. This function is used to
--   implement the "allocated to" logic described in Appendix B of the RDF
--   semantics document, in which a specific blank node is associated with
--   all matches of some specific value by applications of the rule on a
--   given graph. Use <a>id</a> if no modification of the variable bindings
--   is required.
--   
--   This datatype consists of the modifier function itself, which operates
--   on a list of variable bindings rather than a single variable binding
--   (because some modifications share context across a set of bindings),
--   and some additional descriptive information that allows possible usage
--   patterns to be analyzed.
--   
--   Some usage patterns (see <a>vbmUsage</a> for more details):
--   
--   <ul>
--   <li><i>filter</i> all variables are input variables, and the effect of
--   the modifier function is to drop variable bindings that don't satisfy
--   some criterion. Identifiable by an empty element in
--   <tt>vbmUsage</tt>.</li>
--   <li><i>source</i> all variables are output variables: a raw query
--   could be viewed as a source of variable bindings. Identifiable by an
--   element of <tt>vbmUsage</tt> equal to <tt>vbmVocab</tt>.</li>
--   <li><i>modifier</i> for each supplied variable binding, one or more
--   new variable bindings may be created that contain the input variables
--   bound as supplied plus some additional variables. Identifiable by an
--   element of <tt>vbmUsage</tt> some subset of <tt>vbmVocab</tt>.</li>
--   </ul>
--   
--   A variety of variable usage patterns may be supported by a given
--   modifier: a modifier may be used to define new variable bindings from
--   existing bindings in a number of ways, or simply to check that some
--   required relationship between bindings is satisfied. (Example, for
--   <tt>a + b = c</tt>, any one variable can be deduced from the other
--   two, or all three may be supplied to check that the relationship does
--   indeed hold.)
data VarBindingModify a b
VarBindingModify :: ScopedName -> ([VarBinding a b] -> [VarBinding a b]) -> [a] -> [[a]] -> VarBindingModify a b

-- | Name used to identify this variable binding modifier when building
--   inference rules.
vbmName :: VarBindingModify a b -> ScopedName

-- | Apply variable binding modifier to a list of variable bindings,
--   returning a new list. The result list is not necessarily the same
--   length as the supplied list.
vbmApply :: VarBindingModify a b -> [VarBinding a b] -> [VarBinding a b]

-- | List of variables used by this modifier. All results of applying this
--   modifier contain bindings for these variables.
vbmVocab :: VarBindingModify a b -> [a]

-- | List of binding modifier usage patterns supported. Each pattern is
--   characterized as a list of variables for which new bindings may be
--   created by some application of this modifier, assuming that bindings
--   for all other variables in <tt>vbmVocab</tt> are supplied.
vbmUsage :: VarBindingModify a b -> [[a]]

-- | Type for variable binding modifier that has yet to be instantiated
--   with respect to the variables that it operates upon.
type OpenVarBindingModify lb vn = [lb] -> VarBindingModify lb vn

-- | Extract variable binding name from <tt>OpenVarBindingModify</tt> value
--   
--   (Because only the name is required, the application to an undefined
--   list of variable labels should never be evaluated, as long as the name
--   is not dependent on the variable names in any way.)
--   
--   NOT QUITE... some of the functions that create
--   <tt>OpenVarBindingModify</tt> instances also pattern-match the number
--   of labels provided, forcing evaluation of the labels parameter, even
--   though it's not used.
openVbmName :: OpenVarBindingModify lb vn -> ScopedName

-- | Variable binding modifier compatibility test.
--   
--   Given a list of bound variables and a variable binding modifier,
--   return a list of new variables that may be bound, or <tt>Nothing</tt>.
--   
--   Note: if the usage pattern component is well-formed (i.e. all elements
--   different) then at most one element can be compatible with a given
--   input variable set.
vbmCompatibility :: Eq a => VarBindingModify a b -> [a] -> Maybe [a]

-- | Compose variable binding modifiers.
--   
--   Returns <tt>Just a</tt> new variable binding modifier that corresponds
--   to applying the first supplied modifier and then applying the second
--   one, or <tt>Nothing</tt> if the two modifiers cannot be compatibly
--   composed.
--   
--   NOTE: this function does not, in general, commute.
--   
--   NOTE: if there are different ways to achieve the same usage, that
--   usage is currently repeated in the result returned.
vbmCompose :: Eq a => VarBindingModify a b -> VarBindingModify a b -> Maybe (VarBindingModify a b)

-- | Compose sequence of variable binding modifiers.
composeSequence :: Eq a => [VarBindingModify a b] -> Maybe (VarBindingModify a b)

-- | Find all compatible compositions of a list of variable binding
--   modifiers for a given set of supplied bound variables.
findCompositions :: Eq a => [VarBindingModify a b] -> [a] -> [VarBindingModify a b]

-- | Return <tt>Just a</tt> compatible composition of variable binding
--   modifiers for a given set of supplied bound variables, or
--   <tt>Nothing</tt> if there is no compatible composition
findComposition :: Eq a => [VarBindingModify a b] -> [a] -> Maybe (VarBindingModify a b)

-- | VarBindingFilter is a function type that tests to see if a query
--   binding satisfies some criterion.
--   
--   Queries often want to apply some kind of filter or condition to the
--   variable bindings that are processed. In inference rules, it sometimes
--   seems desirable to stipulate additional conditions on the things that
--   are matched.
--   
--   This function type is used to perform such tests. A number of simple
--   implementations are included below.
data VarBindingFilter a b
VarBindingFilter :: ScopedName -> [a] -> (VarBinding a b -> Bool) -> VarBindingFilter a b
vbfName :: VarBindingFilter a b -> ScopedName
vbfVocab :: VarBindingFilter a b -> [a]
vbfTest :: VarBindingFilter a b -> VarBinding a b -> Bool

-- | Make a variable binding modifier from a variable binding filter value.
makeVarFilterModify :: VarBindingFilter a b -> VarBindingModify a b

-- | Make a variable test filter for a named variable using a supplied
--   value testing function.
makeVarTestFilter :: ScopedName -> (b -> Bool) -> a -> VarBindingFilter a b

-- | Make a variable comparison filter for named variables using a supplied
--   value comparison function.
makeVarCompareFilter :: ScopedName -> (b -> b -> Bool) -> a -> a -> VarBindingFilter a b

-- | Variable binding modifier that returns exactly those variable bindings
--   presented.
varBindingId :: VarBindingModify a b

-- | Null variable binding modifier
--   
--   This is like <a>varBindingId</a> except parameterized by some labels.
--   I think this is redundant, and should be eliminated.
nullVarBindingModify :: OpenVarBindingModify a b

-- | This function composes a number of query binding filters into a
--   composite filter that accepts any query binding that satisfies at
--   least one of the component values.
varFilterDisjunction :: Eq a => [VarBindingFilter a b] -> VarBindingFilter a b

-- | This function composes a number of query binding filters into a
--   composite filter that accepts any query binding that satisfies all of
--   the component values.
--   
--   The same function could be achieved by composing the component
--   filter-based modifiers, but this function is more convenient as it
--   avoids the need to check for modifier compatibility.
varFilterConjunction :: Eq a => [VarBindingFilter a b] -> VarBindingFilter a b

-- | This function generates a query binding filter that ensures that two
--   indicated query variables are mapped to the same value.
varFilterEQ :: Eq b => a -> a -> VarBindingFilter a b

-- | This function generates a query binding filter that ensures that two
--   indicated query variables are mapped to different values.
varFilterNE :: Eq b => a -> a -> VarBindingFilter a b
instance Show (OpenVarBindingModify a b)
instance (Show a, Show b) => Show (VarBinding a b)
instance (Ord a, Ord b) => Monoid (VarBinding a b)
instance (Ord a, Ord b) => Ord (VarBinding a b)
instance (Ord a, Ord b) => Eq (VarBinding a b)


-- | This module defines the structures used to represent and manipulate
--   datatypes. It is designed as a basis for handling datatyped RDF
--   literals, but the functions in this module are more generic.
module Swish.Datatype

-- | Datatype wraps a <a>DatatypeVal</a> value, hiding the value type that
--   is used only in implementations of the datatype. Users see just the
--   datatype name and associated ruleset.
data Datatype ex lb vn
Datatype :: (DatatypeVal ex vt lb vn) -> Datatype ex lb vn

-- | Get type name from Datatype value
typeName :: Datatype ex lb vn -> ScopedName

-- | Get static rules from Datatype value
typeRules :: Datatype ex lb vn -> Ruleset ex

-- | Make rules for Datatype value based on supplied expression
typeMkRules :: Datatype ex lb vn -> ex -> [Rule ex]

-- | Make variable binding modifiers based on values supplied
typeMkModifiers :: Datatype ex lb vn -> [OpenVarBindingModify lb vn]

-- | Get the canonical form of a datatype value.
typeMkCanonicalForm :: Datatype ex lb vn -> Text -> Maybe Text

-- | Get the named axiom from a Datatype value.
getTypeAxiom :: ScopedName -> Datatype ex lb vn -> Maybe (Formula ex)

-- | Get the named rule from a Datatype value.
getTypeRule :: ScopedName -> Datatype ex lb vn -> Maybe (Rule ex)

-- | DatatypeVal is a structure that defines a number of functions and
--   values that characterize the behaviour of a datatype.
--   
--   A datatype is specified with respect to (polymophic in) a given type
--   of (syntactic) expression with which it may be used, and a value type
--   (whose existence is hidden as an existential type within
--   <a>DatatypeMap</a>).
--   
--   (I tried hiding the value type with an internal existential
--   declaration, but that wouldn't wash. Hence this two-part structure
--   with <a>Datatype</a> in which the internal detail of the value type is
--   hidden from users of the <a>Datatype</a> class.)
--   
--   The datatype characteristic functions have two goals:
--   
--   <ol>
--   <li>to support the general datatype entailment rules defined by the
--   RDF semantics specification, and</li>
--   <li>to define additional datatype-specific inference patterns by means
--   of which provide additional base functionality to applications based
--   on RDF inference.</li>
--   </ol>
--   
--   Datatype-specific inferences are provided using the <a>DatatypeRel</a>
--   structure for a datatype, which allows a number of named relations to
--   be defined on datatype values, and provides mechanisms to calculate
--   missing values in a partially-specified member of a relation.
--   
--   Note that rules and variable binding modifiers that deal with combined
--   values of more than one datatype may be defined separately.
--   Definitions in this module are generally applicable only when using a
--   single datatype.
--   
--   An alternative model for datatype value calculations is inspired by
--   that introduced by CWM for arithmetic operations, e.g.
--   
--   <pre>
--   (1 2 3) math:sum ?x =&gt; ?x rdf:value 6
--   </pre>
--   
--   (where the bare integer <tt>n</tt> here is shorthand for
--   <tt>"n"^^xsd:integer</tt>).
--   
--   Datatype-specific inference patterns are provided in two ways:
--   
--   <ul>
--   <li>by variable binding modifiers that can be combined with the query
--   results during forward- for backward-chaining of inference rules,
--   and</li>
--   <li>by the definition of inference rulesets that involve datatype
--   values.</li>
--   </ul>
--   
--   I believe the first method to be more flexible than the second, in
--   that it more readily supports forward and backward chaining, but can
--   be used only through the definition of new rules.
--   
--   Type parameters:
--   
--   <ul>
--   <li><i><tt>ex</tt></i> is the type of expression with which the
--   datatype may be used.</li>
--   <li><i><tt>vt</tt></i> is the internal value type with which the
--   labels are associated.</li>
--   <li><i><tt>lb</tt></i> is the type of label that may be used as a
--   variable in an expression or rule.</li>
--   <li><i><tt>vn</tt></i> is the type of node that may be used to carry a
--   value in an expression or rule.</li>
--   </ul>
data DatatypeVal ex vt lb vn
DatatypeVal :: ScopedName -> Ruleset ex -> (ex -> [Rule ex]) -> [OpenVarBindingModify lb vn] -> DatatypeMap vt -> [DatatypeRel vt] -> [DatatypeMod vt lb vn] -> DatatypeVal ex vt lb vn

-- | Identifies the datatype, and also its value space class.
tvalName :: DatatypeVal ex vt lb vn -> ScopedName

-- | A set of named expressions and rules that are valid in in any theory
--   that recognizes the current datatype.
tvalRules :: DatatypeVal ex vt lb vn -> Ruleset ex

-- | A function that accepts an expression and devives some
--   datatype-dependent rules from it. This is provided as a hook for
--   creating datatyped class restriction rules.
tvalMkRules :: DatatypeVal ex vt lb vn -> ex -> [Rule ex]

-- | Constructs a list of open variable binding modifiers based on tvalMod,
--   but hiding the actual value type.
tvalMkMods :: DatatypeVal ex vt lb vn -> [OpenVarBindingModify lb vn]

-- | Lexical to value mapping, where <tt>vt</tt> is a datatype used within
--   a Haskell program to represent and manipulate values in the datatype's
--   value space
tvalMap :: DatatypeVal ex vt lb vn -> DatatypeMap vt

-- | A set of named relations on datatype values. Each relation accepts a
--   list of <tt>Maybe vt</tt>, and computes any unspecified values that
--   are in the relation with values supplied.
tvalRel :: DatatypeVal ex vt lb vn -> [DatatypeRel vt]

-- | A list of named values that are used to construct variable binding
--   modifiers, which in turn may be used by a rule definition.
--   
--   TODO: In due course, this value may be calculated automatically from
--   the supplied value for <tt>tvalRel</tt>.
tvalMod :: DatatypeVal ex vt lb vn -> [DatatypeMod vt lb vn]

-- | Return the named datatype value modifier, if it exists.
getDTMod :: ScopedName -> DatatypeVal ex vt lb vn -> Maybe (DatatypeMod vt lb vn)

-- | Return the named datatype relation, if it exists.
getDTRel :: ScopedName -> DatatypeVal ex vt lb vn -> Maybe (DatatypeRel vt)

-- | Get the canonical form of a datatype value, or <tt>Nothing</tt>.
tvalMkCanonicalForm :: DatatypeVal ex vt lb vn -> Text -> Maybe Text

-- | DatatypeMap consists of methods that perform lexical-to-value and
--   value-to-canonical-lexical mappings for a datatype.
--   
--   The datatype mappings apply to string lexical forms which are stored
--   as <a>Text</a>.
data DatatypeMap vt
DatatypeMap :: (Text -> Maybe vt) -> (vt -> Maybe Text) -> DatatypeMap vt

-- | Function to map a lexical string to the datatype value. This
--   effectively defines the lexical space of the datatype to be all
--   strings for which yield a value other than <tt>Nothing</tt>.
mapL2V :: DatatypeMap vt -> Text -> Maybe vt

-- | Function to map a value to its canonical lexical form, if it has such.
mapV2L :: DatatypeMap vt -> vt -> Maybe Text

-- | Datatype for a named relation on values of a datatype.
data DatatypeRel vt
DatatypeRel :: ScopedName -> DatatypeRelFn vt -> DatatypeRel vt
dtRelName :: DatatypeRel vt -> ScopedName
dtRelFunc :: DatatypeRel vt -> DatatypeRelFn vt

-- | Type for a datatype relation inference function.
--   
--   A datatype relation defines tuples of values that satisfy some
--   relation. A datatype relation inference function calculates values
--   that complete a relation with values supplied.
--   
--   The function accepts a list of <tt>Maybe vt</tt>, where vt is the
--   datatype value type. It returns one of:
--   
--   <ul>
--   <li>Just a list of lists, where each inner list returned is a complete
--   set of values, including the values supplied, that are in the
--   relation.</li>
--   <li>Just an empty list is returned if the supplied values are
--   insufficient to compute any complete sets of values in the
--   relation.</li>
--   <li>Nothing if the supplied values are not consistent with the
--   relation.</li>
--   </ul>
type DatatypeRelFn vt = [Maybe vt] -> Maybe [[vt]]

-- | Type for datatype relation predicate: accepts a list of values and
--   determines whether or not they satisfy the relation.
type DatatypeRelPr vt = [vt] -> Bool

-- | Given a list of argument values and a list of functions for
--   calculating new values from supplied values, return a list of argument
--   values, or <tt>Nothing</tt> if the supplied values are inconsistent
--   with the calculations specified.
--   
--   Each list of values returned corresponds to a set of values that
--   satisfy the relation, consistent with the values supplied.
--   
--   Functions are described as tuple consisting of:
--   
--   (a) a predicate that the argument is required to satisfy
--   
--   (b) a function to apply,
--   
--   (c) a function to apply function (b) to a list of arguments
--   
--   (d) argument list index values to which the function is applied.
--   
--   Each supplied argument is of the form <tt>Maybe a</tt>, where the
--   argument has value type a. <tt>Nothing</tt> indicates arguments of
--   unknown value.
--   
--   The basic idea is that, for each argument position in the relation, a
--   function may be supplied to calculate that argument's possible values
--   from some combination of the other arguments. The results calculated
--   in this way are compared with the original arguments provided: if the
--   values conflict then the relation is presumed to be unsatisfiable with
--   the supplied values, and <tt>Nothing</tt> is returned; if there are
--   any calculated values for arguments supplied without any values, then
--   tbe calculated values are used. If there are any arguments for which
--   no values are supplied or calculated, then the relation is presumed to
--   be underdetermined, and <tt>Just []</tt> is returned.
altArgs :: Eq vt => DatatypeRelPr vt -> [(vt -> Bool, [b])] -> ((vt -> Bool) -> b -> [Maybe vt] -> Maybe [vt]) -> DatatypeRelFn vt

-- | <a>altArgs</a> support for unary functions: function descriptor type
type UnaryFnDescr a = (a -> a, Int)

-- | <a>altArgs</a> support for unary functions: function descriptor table
--   type
type UnaryFnTable a = [(a -> Bool, [UnaryFnDescr a])]

-- | <a>altArgs</a> support for unary functions: function applicator type
type UnaryFnApply a = (a -> Bool) -> UnaryFnDescr a -> [Maybe a] -> Maybe [a]

-- | <a>altArgs</a> support for unary functions: function applicator
unaryFnApp :: UnaryFnApply a

-- | <a>altArgs</a> support for binary functions: function descriptor type
type BinaryFnDescr a = (a -> a -> a, Int, Int)

-- | <a>altArgs</a> support for binary functions: function descriptor table
--   type
type BinaryFnTable a = [(a -> Bool, [BinaryFnDescr a])]

-- | <a>altArgs</a> support for binary functions: function applicator type
type BinaryFnApply a = (a -> Bool) -> BinaryFnDescr a -> [Maybe a] -> Maybe [a]

-- | <a>altArgs</a> support for binary functions: function applicator
binaryFnApp :: BinaryFnApply a

-- | <a>altArgs</a> support for binary function with provision for
--   indicating inconsistent supplied values: function descriptor type
type BinMaybeFnDescr a = (a -> a -> Maybe [a], Int, Int)

-- | <a>altArgs</a> support for binary function with provision for
--   indicating inconsistent supplied values: function descriptor table
--   type
type BinMaybeFnTable a = [(a -> Bool, [BinMaybeFnDescr a])]

-- | <a>altArgs</a> support for binary function with provision for
--   indicating inconsistent supplied values: function applicator type
type BinMaybeFnApply a = (a -> Bool) -> BinMaybeFnDescr a -> [Maybe a] -> Maybe [a]

-- | <a>altArgs</a> support for binary function with provision for
--   indicating inconsistent supplied values: function applicator
binMaybeFnApp :: BinMaybeFnApply a

-- | <a>altArgs</a> support for list functions (e.g. sum over list of
--   args), where first element of list is a fold over the rest of the
--   list, and remaining elements of list can be calculated in terms of the
--   result of the fold and the remaining elements
--   
--   List function descriptor is
--   
--   (a) list-fold function, f (e.g. (+)
--   
--   (b) list-fold identity, z (e.g. 0)
--   
--   (c) list-fold-function inverse, g (e.g. (-))
--   
--   (d) index of element to evaluate
--   
--   such that:
--   
--   <pre>
--   (a `f` z) == (z `f` a) == a
--   (a `g` c) == b &lt;=&gt; a == b `f` c
--   (a `g` z) == a
--   (a `g` a) == z
--   </pre>
--   
--   and the result of the folded function does not depend on the order
--   that the list elements are processed.
--   
--   NOTE: the list of <a>ListFnDescr</a> values supplied to <a>altArgs</a>
--   must be at least as long as the argument list. In many cases, Haskell
--   lazy evaluation can be used to supply an arbitrarily long list. See
--   test cases in spike-altargs.hs for an example.
--   
--   Function descriptor type
type ListFnDescr a = (a -> a -> a, a, a -> a -> a, Int)

-- | Function table type
type ListFnTable a = [(a -> Bool, [ListFnDescr a])]

-- | <a>altArgs</a> support for list functions: function applicator type
type ListFnApply a = (a -> Bool) -> ListFnDescr a -> [Maybe a] -> Maybe [a]

-- | <a>altArgs</a> support for list functions: function applicator
listFnApp :: ListFnApply a

-- | Wrapper for data type variable binding modifier included in a datatype
--   value.
data DatatypeMod vt lb vn
DatatypeMod :: ScopedName -> [ModifierFn vt] -> ApplyModifier lb vn -> DatatypeMod vt lb vn
dmName :: DatatypeMod vt lb vn -> ScopedName
dmModf :: DatatypeMod vt lb vn -> [ModifierFn vt]
dmAppf :: DatatypeMod vt lb vn -> ApplyModifier lb vn

-- | Datatype value modifier functions type
--   
--   Each function accepts a list of values and returns a list of values.
--   The exact significance of the different values supplied and returned
--   depends on the variable binding pattern used (cf.
--   <a>ApplyModifier</a>), but in all cases an empty list returned means
--   that the corresponding inputs are not consistent with the function and
--   cannot be used.
type ModifierFn vn = [vn] -> [vn]

-- | Type of function used to apply a data value modifier to specified
--   variables in a supplied variable binding. It also accepts the name of
--   the datatype modifier and carries it into the resulting variable
--   binding modifier.
--   
--   (Note that <tt>vn</tt> is not necessarily the same as <tt>vt</tt>, the
--   datatype value type: the modifier functions may be lifted or otherwise
--   adapted to operate on some other type from which the raw data values
--   are extracted.)
type ApplyModifier lb vn = ScopedName -> [ModifierFn vn] -> OpenVarBindingModify lb vn

-- | Null datatype value modifier
nullDatatypeMod :: DatatypeMod vt lb vn

-- | <a>ApplyModifier</a> function for use with <a>DatatypeMod</a> in cases
--   when the value mapping is a <tt>1-&gt;1</tt> function and inverse,
--   such as negate.
--   
--   <ul>
--   <li><i><tt>nam</tt></i> is the name from the <a>DatatypeMod</a> value
--   that is carried into the resulting variable binding modifier.</li>
--   <li><i><tt>fns</tt></i> are functions used to implement details of the
--   variable binding modifier:<ol><li>is <tt>[x,y] -&gt; [?]</tt>, used as
--   a filter (i.e. not creating any new variable bindings), returning a
--   non-empty list if <tt>x</tt> and <tt>y</tt> are in the appropriate
--   relationship.<ol><li>is <tt>[y] -&gt; [x]</tt>, used to perform the
--   calculation in a forward direction.</li><li>is <tt>[x] -&gt; [y]</tt>,
--   used to perform the calculation in a backward direction. This may be
--   the same as (2) (e.g. for negation) or may be different (e.g.
--   increment).</li></ol></li></ol></li>
--   <li><i><tt>lbs</tt></i> is a list of specific label values for which a
--   variable binding modifier will be generated. (The intent is that a
--   variable-free value can be generated as a Curried function, and
--   instantiated for particular variables as required.)</li>
--   </ul>
--   
--   Note: an irrefutable pattern match for <tt>lbs</tt> is used so that a
--   name for the <a>VarBindingModify</a> value can be extracted using an
--   undefined label value.
makeVmod11inv :: (Ord lb, Ord vn) => ApplyModifier lb vn

-- | <a>ApplyModifier</a> function for use with <a>DatatypeMod</a> in cases
--   when the value mapping is a non-invertable <tt>1-&gt;1</tt> injection,
--   such as absolute value.
--   
--   <ul>
--   <li><i><tt>nam</tt></i> is the name from the <a>DatatypeMod</a> value
--   that is carried into the resulting variable binding modifier.</li>
--   <li><i><tt>fns</tt></i> are functions used to implement details of the
--   variable binding modifier:<ol><li>is <tt>[x,y] -&gt; [?]</tt>, used as
--   a filter (i.e. not creating any new variable bindings), returning a
--   non-empty list if <tt>x</tt> and <tt>y</tt> are in the appropriate
--   relationship.<ol><li>is <tt>[x]</tt> -&gt; <tt>[y]</tt>, used to
--   perform the calculation.</li></ol></li></ol></li>
--   <li><i><tt>lbs</tt></i> is a list of specific label values for which a
--   variable binding modifier will be generated.</li>
--   </ul>
--   
--   Note: an irrefutable pattern match for <tt>lbs</tt> is used so that a
--   name for the <a>VarBindingModify</a> value can be extracted using an
--   undefined label value.
makeVmod11 :: (Ord lb, Ord vn) => ApplyModifier lb vn

-- | <a>ApplyModifier</a> function for use with <a>DatatypeMod</a> in cases
--   when the value mapping is a <tt>2-&gt;1</tt> invertable function, such
--   as addition or subtraction.
--   
--   <ul>
--   <li><i><tt>nam</tt></i> is the name from the <a>DatatypeMod</a> value
--   that is carried into the resulting variable binding modifier.</li>
--   <li><i><tt>fns</tt></i> are functions used to implement details of the
--   variable binding modifier:<ol><li>is <tt>[x,y,z] -&gt; [?]</tt>, used
--   as a filter (i.e. not creating any new variable bindings), returning a
--   non-empty list if <tt>x</tt>, <tt>y</tt> and <tt>z</tt> are in the
--   appropriate relationship.<ol><li>is <tt>[y,z] -&gt; [x]</tt>, used to
--   perform the calculation in a forward direction.</li><li>is <tt>[x,z]
--   -&gt; [y]</tt>, used to run the calculation backwards to determine the
--   first input argument</li><li>is <tt>[x,y] -&gt; [z]</tt>, used to run
--   the calculation backwards to determine the second input
--   argument</li></ol></li></ol></li>
--   <li><i><tt>lbs</tt></i> is a list of specific label values for which a
--   variable binding modifier will be generated.</li>
--   </ul>
--   
--   Note: an irrefutable pattern match for <tt>lbs</tt> is used so that a
--   name for the <a>VarBindingModify</a> value can be extracted using an
--   undefined label value.
makeVmod21inv :: (Ord lb, Ord vn) => ApplyModifier lb vn

-- | <a>ApplyModifier</a> function for use with <a>DatatypeMod</a> in cases
--   when the value mapping is a <tt>2-&gt;1</tt> non-invertable function,
--   such as logical <tt>AND</tt> or <tt>OR</tt>.
--   
--   <ul>
--   <li><i><tt>nam</tt></i> is the name from the <a>DatatypeMod</a> value
--   that is carried into the resulting variable binding modifier.</li>
--   <li><i><tt>fns</tt></i> are functions used to implement details of the
--   variable binding modifier:<ol><li>is <tt>[x,y,z] -&gt; [?]</tt>, used
--   as a filter (i.e. not creating any new variable bindings), returning a
--   non-empty list if <tt>x</tt>, <tt>y</tt> and <tt>z</tt> are in the
--   appropriate relationship.<ol><li>is <tt>[y,z] -&gt; [x]</tt>, used to
--   perform the calculation in a forward
--   direction.</li></ol></li></ol></li>
--   <li><i><tt>lbs</tt></i> is a list of specific label values for which a
--   variable binding modifier will be generated.</li>
--   </ul>
--   
--   Note: an irrefutable pattern match for <tt>lbs</tt> is used so that a
--   name for the <a>VarBindingModify</a> value can be extracted using an
--   undefined label value.
makeVmod21 :: (Ord lb, Ord vn) => ApplyModifier lb vn

-- | <a>ApplyModifier</a> function for use with <a>DatatypeMod</a> in cases
--   when the value mapping is a simple comparson of two values.
--   
--   <ul>
--   <li><i><tt>nam</tt></i> is the name from the <a>DatatypeMod</a> value
--   that is carried into the resulting variable binding modifier.</li>
--   <li><i><tt>fns</tt></i> are functions used to implement details of the
--   variable binding modifier:<ol><li>is <tt>[x,y] -&gt; [?]</tt>, used as
--   a filter (i.e. not creating any new variable bindings), returning a
--   non-empty list if <tt>x</tt> and <tt>y</tt> are in the appropriate
--   relationship.</li></ol></li>
--   <li><i><tt>lbs</tt></i> is a list of specific label values for which a
--   variable binding modifier will be generated.</li>
--   </ul>
--   
--   Note: an irrefutable pattern match for <tt>lbs</tt> is used so that a
--   name for the <a>VarBindingModify</a> value can be extracted using an
--   undefined label value.
makeVmod20 :: (Eq lb, Show lb, Eq vn, Show vn) => ApplyModifier lb vn

-- | <a>ApplyModifier</a> function for use with <a>DatatypeMod</a> in cases
--   when the value mapping is a <tt>2-&gt;2</tt> non-invertable function,
--   such as quotient/remainder
--   
--   <ul>
--   <li><i><tt>nam</tt></i> is the name from the <a>DatatypeMod</a> value
--   that is carried into the resulting variable binding modifier.</li>
--   <li><i><tt>fns</tt></i> are functions used to implement details of the
--   variable binding modifier:<ol><li>is <tt>[w,x,y,z] -&gt; [?]</tt>,
--   used as a filter (i.e. not creating any new variable bindings),
--   returning a non-empty list if <tt>w</tt>, <tt>x</tt>, <tt>y</tt> and
--   <tt>z</tt> are in the appropriate relationship.<ol><li>is <tt>[y,z]
--   -&gt; [w,x]</tt>, used to perform the calculation given two input
--   values.</li></ol></li></ol></li>
--   <li><i><tt>lbs</tt></i> is a list of specific label values for which a
--   variable binding modifier will be generated.</li>
--   </ul>
--   
--   Note: an irrefutable pattern match for <tt>lbs</tt> is used so that a
--   name for the <a>VarBindingModify</a> value can be extracted using an
--   undefined label value.
--   
--   NOTE: this might be generalized to allow one of <tt>w</tt> or
--   <tt>x</tt> to be specified, and return null if it doesn't match the
--   calculated value.
makeVmod22 :: (Ord lb, Ord vn) => ApplyModifier lb vn

-- | <a>ApplyModifier</a> function for use with <a>DatatypeMod</a> in cases
--   when the value mapping is a <tt>N-&gt;1</tt> function, such as Sigma
--   (sum) of a vector.
--   
--   <ul>
--   <li><i><tt>nam</tt></i> is the name from the <a>DatatypeMod</a> value
--   that is carried into the resulting variable binding modifier.</li>
--   <li><i><tt>fns</tt></i> are functions used to implement details of the
--   variable binding modifier:<ol><li>is <tt>[x,y...] -&gt; [?]</tt>, used
--   as a filter (i.e. not creating any new variable bindings), returning a
--   non-empty list if <tt>x</tt> and <tt>y...</tt> are in the appropriate
--   relationship.<ol><li>is <tt>[y...] -&gt; [x]</tt>, used to perform the
--   calculation.</li></ol></li></ol></li>
--   <li><i><tt>lbs</tt></i> is a list of specific label values for which a
--   variable binding modifier will be generated.</li>
--   </ul>
--   
--   Note: an irrefutable pattern match for <tt>lbs</tt> is used so that a
--   name for the <a>VarBindingModify</a> value can be extracted using an
--   undefined label value.
makeVmodN1 :: (Ord lb, Ord vn) => ApplyModifier lb vn

-- | Describe a subtype/supertype relationship between a pair of datatypes.
--   
--   Originally, I had this as a supertype field of the DatatypeVal
--   structure, but that suffered from some problems:
--   
--   <ul>
--   <li>supertypes may be introduced retrospectively,</li>
--   <li>the relationship expressed with respect to a single datatype
--   cannot indicate how to do injections/restrictions between the
--   underlying value types.</li>
--   </ul>
--   
--   <ul>
--   <li><i><tt>ex</tt></i> is the type of expression with which the
--   datatype may be used.</li>
--   <li><i><tt>lb</tt></i> is the type of the variable labels used.</li>
--   <li><i><tt>vn</tt></i> is the type of value node used to contain a
--   datatyped value</li>
--   <li><i><tt>supvt</tt></i> is the internal value type of the
--   super-datatype</li>
--   <li><i><tt>subvt</tt></i> is the internal value type of the
--   sub-datatype</li>
--   </ul>
data DatatypeSub ex lb vn supvt subvt
DatatypeSub :: DatatypeVal ex supvt lb vn -> DatatypeVal ex subvt lb vn -> (subvt -> supvt) -> (supvt -> Maybe subvt) -> DatatypeSub ex lb vn supvt subvt

-- | Datatype that is a supertype of <tt>trelSub</tt>, having value space
--   <tt>supvt</tt>.
trelSup :: DatatypeSub ex lb vn supvt subvt -> DatatypeVal ex supvt lb vn

-- | Datatype that is a subtype of <tt>trelSup</tt>, having value space
--   <tt>supvt</tt>.
trelSub :: DatatypeSub ex lb vn supvt subvt -> DatatypeVal ex subvt lb vn

-- | Function that maps subtype value to corresponding supertype value.
trelToSup :: DatatypeSub ex lb vn supvt subvt -> subvt -> supvt

-- | Function that maps supertype value to corresponding subtype value, if
--   there is such a value.
trelToSub :: DatatypeSub ex lb vn supvt subvt -> supvt -> Maybe subvt


-- | This module defines the datatytpe mapping and relation values used for
--   RDF dataype <tt>xsd:decimal</tt>.
module Swish.RDF.Datatype.XSD.MapDecimal

-- | Functions that perform lexical-to-value and value-to-canonical-lexical
--   mappings for <tt>xsd:decimal</tt> values.
mapXsdDecimal :: DatatypeMap Double


-- | This module defines the datatytpe mapping and relation values used for
--   RDF dataype <tt>xsd:integer</tt>.
module Swish.RDF.Datatype.XSD.MapInteger

-- | Functions that perform lexical-to-value and value-to-canonical-lexical
--   mappings for <tt>xsd:integer</tt> values.
mapXsdInteger :: DatatypeMap Integer


-- | This module instantiates the <a>VarBinding</a> types and methods for
--   use with RDF graph labels.
module Swish.RDF.VarBinding

-- | <tt>RDFVarBinding</tt> is the specific type type of a variable binding
--   value used with RDF graph queries.
type RDFVarBinding = VarBinding RDFLabel RDFLabel

-- | Define type of query binding modifier for RDF graph inference
type RDFVarBindingModify = VarBindingModify RDFLabel RDFLabel

-- | Open variable binding modifier that operates on RDFLabel values
type RDFOpenVarBindingModify = OpenVarBindingModify RDFLabel RDFLabel

-- | Define type for lookup map of open query binding modifiers
type RDFOpenVarBindingModifyMap = Map ScopedName RDFOpenVarBindingModify

-- | <tt>RDFVarBindingFilter</tt> is a function type that tests to see if a
--   query binding satisfies some criterion, and is used to create a
--   variable binding modifier that simply filers given variable bindings.
--   
--   Queries often want to apply some kind of filter or condition to the
--   variable bindings that are processed. In inference rules, it sometimes
--   seems desirable to stipulate additional conditions on the things that
--   are matched.
--   
--   This function type is used to perform such tests. A number of simple
--   implementations are included.
type RDFVarBindingFilter = VarBindingFilter RDFLabel RDFLabel

-- | maps no query variables.
nullRDFVarBinding :: RDFVarBinding

-- | This function generates a query binding filter that ensures an
--   indicated variable is bound to a URI reference.
rdfVarBindingUriRef :: RDFLabel -> RDFVarBindingFilter

-- | This function generates a query binding filter that ensures an
--   indicated variable is bound to a blank node.
rdfVarBindingBlank :: RDFLabel -> RDFVarBindingFilter

-- | This function generates a query binding filter that ensures an
--   indicated variable is bound to a literal value.
rdfVarBindingLiteral :: RDFLabel -> RDFVarBindingFilter

-- | This function generates a query binding filter that ensures an
--   indicated variable is bound to an untyped literal value.
rdfVarBindingUntypedLiteral :: RDFLabel -> RDFVarBindingFilter

-- | This function generates a query binding filter that ensures an
--   indicated variable is bound to a typed literal value.
rdfVarBindingTypedLiteral :: RDFLabel -> RDFVarBindingFilter

-- | This function generates a query binding filter that ensures an
--   indicated variable is bound to an XML literal value.
rdfVarBindingXMLLiteral :: RDFLabel -> RDFVarBindingFilter

-- | This function generates a query binding filter that ensures an
--   indicated variable is bound to a literal value with a datatype whose
--   URI is bound to another node
rdfVarBindingDatatyped :: RDFLabel -> RDFLabel -> RDFVarBindingFilter

-- | This function generates a query binding filter that ensures an
--   indicated variable is bound to container membership property.
rdfVarBindingMemberProp :: RDFLabel -> RDFVarBindingFilter


-- | This module defines the structures used by Swish to represent and
--   manipulate RDF datatypes.
module Swish.RDF.Datatype

-- | RDF datatype wrapper used with RDF graph values
type RDFDatatype = Datatype RDFGraph RDFLabel RDFLabel

-- | RDF datatype value used with RDF graph values
type RDFDatatypeVal vt = DatatypeVal RDFGraph vt RDFLabel RDFLabel

-- | RDF datatype modifier used with RDF graph values
type RDFDatatypeMod vt = DatatypeMod vt RDFLabel RDFLabel

-- | RDF value modifier function type
--   
--   This indicates a modifier function that operates on <a>RDFLabel</a>
--   values.
type RDFModifierFn = ModifierFn RDFLabel

-- | RDF value modifier application function type
--   
--   This indicates a function that applies RDFModifierFn functions.
type RDFApplyModifier = ApplyModifier RDFLabel RDFLabel

-- | Create an <a>RDFOpenVarBindingModify</a> value.
--   
--   The key purpose of this function is to lift the supplied variable
--   constraint functions from operating on data values directly to a
--   corresponding list of functions that operate on values contained in
--   RDF graph labels (i.e. RDF literal nodes). It also applies node type
--   checking, such that if the actual RDF nodes supplied do not contain
--   appropriate values then the variable binding is not accepted.
makeRdfDtOpenVarBindingModify :: RDFDatatypeVal vt -> RDFDatatypeMod vt -> RDFOpenVarBindingModify

-- | Create all RDFOpenVarBindingModify values for a given datatype value.
--   See <a>makeRdfDtOpenVarBindingModify</a>.
makeRdfDtOpenVarBindingModifiers :: RDFDatatypeVal vt -> [RDFOpenVarBindingModify]

-- | Apply a datatype modifier using supplied RDF labels to a supplied RDF
--   variable binding.
applyRDFDatatypeMod :: RDFDatatypeVal vt -> RDFDatatypeMod vt -> [RDFLabel] -> [RDFVarBinding] -> [RDFVarBinding]

-- | Describe a subtype/supertype relationship between a pair of RDF
--   datatypes.
type RDFDatatypeSub supvt subvt = DatatypeSub RDFGraph RDFLabel RDFLabel supvt subvt

-- | Convert from a typed literal to a Haskell value, with the possibility
--   of failure.
fromRDFLabel :: RDFDatatypeVal vt -> RDFLabel -> Maybe vt

-- | Convert a Haskell value to a typed literal (label), with the
--   possibility of failure.
toRDFLabel :: RDFDatatypeVal vt -> vt -> Maybe RDFLabel

-- | Create a typed literal. No conversion is made to the string
--   representation.
makeDatatypedLiteral :: ScopedName -> Text -> RDFLabel


-- | This Module implements a Turtle parser, returning a new
--   <a>RDFGraph</a> consisting of triples and namespace information parsed
--   from the supplied input string, or an error indication.
--   
--   REFERENCES:
--   
--   <ul>
--   <li>"Turtle, Terse RDF Triple Language", W3C Candidate Recommendation
--   19 February 2013
--   (&lt;<a>http://www.w3.org/TR/2013/CR-turtle-20130219/L)</a>,
--   <a>http://www.w3.org/TR/turtle/</a></li>
--   </ul>
--   
--   NOTES:
--   
--   <ul>
--   <li>Prior to version <tt>0.9.0.4</tt>, the parser followed the W3C
--   Working Draft 09 August 2011
--   (<a>http://www.w3.org/TR/2011/WD-turtle-20110809/</a>)</li>
--   <li>Strings with no language tag are converted to a <tt>LitTag</tt>
--   not a <tt>TypedLitTag</tt> with a type of <tt>xsd:string</tt> (e.g.
--   see <a>http://www.w3.org/TR/2011/WD-turtle-20110809/#terms</a>).</li>
--   <li>If the URI is actually an IRI (Internationalized Resource
--   Identifiers) then the parser will fail since <a>parseURI</a>
--   fails.</li>
--   <li>The current (August 2013) Turtle test suite from
--   <a>http://www.w3.org/2013/TurtleTests/</a> passes except for the four
--   tests with non-ASCII local names, namely:
--   <tt>localName_with_assigned_nfc_bmp_PN_CHARS_BASE_character_boundaries</tt>,
--   <tt>localName_with_assigned_nfc_PN_CHARS_BASE_character_boundaries</tt>,
--   <tt>localName_with_nfc_PN_CHARS_BASE_character_boundaries</tt>, and
--   <tt>localName_with_non_leading_extras</tt>.</li>
--   </ul>
module Swish.RDF.Parser.Turtle

-- | The result of a parse, which is either an error message or a graph.
type ParseResult = Either String RDFGraph

-- | Parse a string with an optional base URI.
--   
--   Unlike <tt>parseN3</tt> we treat the base URI as a URI and not a
--   QName.
parseTurtle :: Text -> Maybe URI -> ParseResult

-- | Parse as Turtle (with no real base URI).
--   
--   See <a>parseTurtle</a> if you need to provide a base URI.
parseTurtlefromText :: Text -> ParseResult
instance Show TurtleState


-- | This Module implements a Notation 3 parser, returning a new
--   <a>RDFGraph</a> consisting of triples and namespace information parsed
--   from the supplied N3 input string, or an error indication.
--   
--   REFERENCES:
--   
--   <ul>
--   <li>"Notation3 (N3): A readable RDF syntax", W3C Team Submission 14
--   January 2008,
--   <a>http://www.w3.org/TeamSubmission/2008/SUBM-n3-20080114/</a></li>
--   <li>Tim Berners-Lee's design issues series notes and description,
--   <a>http://www.w3.org/DesignIssues/Notation3.html</a></li>
--   <li>Notation 3 Primer by Sean Palmer,
--   <a>http://www.w3.org/2000/10/swap/Primer.html</a></li>
--   </ul>
--   
--   NOTES:
--   
--   <ul>
--   <li>The parser needs to be updated to the latest version ("W3C Team
--   Submission 28 March 2011",
--   <a>http://www.w3.org/TeamSubmission/2011/SUBM-n3-20110328/</a>)</li>
--   <li>UTF-8 handling is not really tested.</li>
--   <li>No performance testing has been applied.</li>
--   <li>Not all N3 grammar elements are supported,
--   including:<ul><li><tt>@forSome</tt> (we read it in but ignore the
--   arguments)</li><li><tt>@forAll</tt> (this causes a parse
--   error)</li><li>formulae are lightly tested</li><li>string support is
--   incomplete (e.g. unrecognized escape characters such as <tt>\q</tt>
--   are probably handled incorrectly)</li></ul></li>
--   </ul>
module Swish.RDF.Parser.N3

-- | The result of a parse, which is either an error message or a graph.
type ParseResult = Either String RDFGraph

-- | Parse a string with an optional base URI.
--   
--   See also <tt>parseN3fromString</tt>.
parseN3 :: Text -> Maybe QName -> ParseResult

-- | Parse a string as N3 (with no real base URI).
--   
--   See <a>parseN3</a> if you need to provide a base URI.
parseN3fromText :: Text -> ParseResult

-- | Function to supply initial context and parse supplied term.
parseAnyfromText :: N3Parser a -> Maybe QName -> Text -> Either String a

-- | Used in testing.
parseTextFromText :: String -> Text -> Either String String

-- | Used in testing.
parseAltFromText :: String -> String -> Text -> Either String String

-- | Used in testing.
parseNameFromText :: Text -> Either String String

-- | Used in testing.
parseAbsURIrefFromText :: Text -> Either String URI

-- | Used in testing.
parseLexURIrefFromText :: Text -> Either String URI

-- | Used in testing.
parseURIref2FromText :: Text -> Either String ScopedName

-- | The N3 parser.
type N3Parser a = Parser N3State a

-- | N3 parser state
data N3State
N3State :: RDFGraph -> RDFLabel -> NamespaceMap -> SpecialMap -> Word32 -> [Text] -> Bool -> N3State
graphState :: N3State -> RDFGraph
thisNode :: N3State -> RDFLabel
prefixUris :: N3State -> NamespaceMap
syntaxUris :: N3State -> SpecialMap
nodeGen :: N3State -> Word32
keywordsList :: N3State -> [Text]
allowLocalNames :: N3State -> Bool

-- | Type for special name lookup table
type SpecialMap = Map String ScopedName

-- | Process the remainder of an <tt>@prefix</tt> line (after this has been
--   processed). The prefix value and URI are added to the parser state.
getPrefix :: N3Parser ()

-- | Match a N3 symbol (an explicit URI or a QName) and convert it to a
--   <a>ScopedName</a>.
n3symbol :: N3Parser ScopedName

-- | Match <tt>?<a>name</a></tt>.
quickVariable :: N3Parser RDFLabel

-- | An explicitly given URI followed by white space.
lexUriRef :: N3Parser URI

-- | Process a N3 document, returning a graph.
document :: N3Parser RDFGraph

-- | Process a sub graph and assign it to the given label.
subgraph :: RDFLabel -> N3Parser RDFGraph

-- | Create a new blank node.
newBlankNode :: N3Parser RDFLabel


-- | This module defines functions for querying an RDF graph to obtain a
--   set of variable substitutions, and to apply a set of variable
--   substitutions to a query pattern to obtain a new graph.
--   
--   It also defines a few primitive graph access functions.
--   
--   A minimal example is shown below, where we query a very simple graph:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; import Swish.RDF
--   
--   &gt;&gt;&gt; import Swish.RDF.Parser.N3 (parseN3fromText)
--   
--   &gt;&gt;&gt; import Swish.RDF.Query
--   
--   &gt;&gt;&gt; import Swish.VarBinding (VarBinding(vbMap))
--   
--   &gt;&gt;&gt; import Network.URI (parseURI)
--   
--   &gt;&gt;&gt; import Data.Maybe (fromJust, mapMaybe)
--   
--   &gt;&gt;&gt; let qparse = either error id . parseN3fromText
--   
--   &gt;&gt;&gt; let igr = qparse "@prefix a: &lt;http://example.com/&gt;. a:a a a:A ; a:foo a:bar. a:b a a:B ; a:foo a:bar."
--   
--   &gt;&gt;&gt; let qgr = qparse "?node a ?type."
--   
--   &gt;&gt;&gt; let ans = rdfQueryFind qgr igr
--   
--   &gt;&gt;&gt; :t ans
--   ans :: [Swish.RDF.VarBinding.RDFVarBinding]
--   
--   &gt;&gt;&gt; ans
--   [[(?node,a:a),(?type,a:A)],[(?node,a:b),(?type,a:B)]]
--   
--   &gt;&gt;&gt; let bn = toRDFLabel . fromJust . parseURI $ "http://example.com/B"
--   
--   &gt;&gt;&gt; let arcs = rdfFindArcs (rdfObjEq bn) igr
--   
--   &gt;&gt;&gt; :t arcs
--   arcs :: [RDFTriple]
--   
--   &gt;&gt;&gt; arcs
--   [(a:b,rdf:type,a:B)]
--   
--   &gt;&gt;&gt; let lbls = mapMaybe (`vbMap` (Var "type")) ans
--   
--   &gt;&gt;&gt; :t lbls
--   lbls :: [RDFLabel]
--   
--   &gt;&gt;&gt; lbls
--   [a:A,a:B]
--   </pre>
module Swish.RDF.Query

-- | Basic graph-query function.
--   
--   The triples of the query graph are matched sequentially against the
--   target graph, each taking account of any variable bindings that have
--   already been determined, and adding new variable bindings as triples
--   containing query variables are matched against the graph.
rdfQueryFind :: RDFGraph -> RDFGraph -> [RDFVarBinding]

-- | RDF query filter.
--   
--   This function applies a supplied query binding filter to the result
--   from a call of <a>rdfQueryFind</a>.
--   
--   If none of the query bindings found satisfy the filter, a null list is
--   returned (which is what <a>rdfQueryFind</a> returns if the query
--   cannot be satisfied).
--   
--   (Because of lazy evaluation, this should be as efficient as applying
--   the filter as the search proceeds. I started to build the filter logic
--   into the query function itself, with consequent increase in
--   complexity, until I remembered lazy evaluation lets me keep things
--   separate.)
rdfQueryFilter :: RDFVarBindingFilter -> [RDFVarBinding] -> [RDFVarBinding]

-- | Reverse graph-query function.
--   
--   Similar to <a>rdfQueryFind</a>, but with different success criteria.
--   The query graph is matched against the supplied graph, but not every
--   triple of the query is required to be matched. Rather, every triple of
--   the target graph must be matched, and substitutions for just the
--   variables thus bound are returned. In effect, these are subsitutions
--   in the query that entail the target graph (where <tt>rdfQueryFind</tt>
--   returns substitutions that are entailed by the target graph).
--   
--   Multiple substitutions may be used together, so the result returned is
--   a list of lists of query bindings. Each inner list contains several
--   variable bindings that must all be applied separately to the closure
--   antecendents to obtain a collection of expressions that together are
--   antecedent to the supplied conclusion. A null list of bindings
--   returned means the conclusion can be inferred without any antecedents.
--   
--   Note: in back-chaining, the conditions required to prove each target
--   triple are derived independently, using the inference rule for each
--   such triple, so there are no requirements to check consistency with
--   previously determined variable bindings, as there are when doing
--   forward chaining. A result of this is that there may be redundant
--   triples generated by the back-chaining process. Any process using
--   back-chaining should deal with the results returned accordingly.
--   
--   An empty outer list is returned if no combination of substitutions can
--   infer the supplied target.
rdfQueryBack :: RDFGraph -> RDFGraph -> [[RDFVarBinding]]

-- | RDF back-chaining query filter. This function applies a supplied query
--   binding filter to the result from a call of <a>rdfQueryBack</a>.
--   
--   Each inner list contains bindings that must all be used to satisfy the
--   backchain query, so if any query binding does not satisfy the filter,
--   the entire corresponding row is removed
rdfQueryBackFilter :: RDFVarBindingFilter -> [[RDFVarBinding]] -> [[RDFVarBinding]]

-- | RDF back-chaining query modifier. This function applies a supplied
--   query binding modifier to the result from a call of
--   <a>rdfQueryBack</a>.
--   
--   Each inner list contains bindings that must all be used to satisfy a
--   backchaining query, so if any query binding does not satisfy the
--   filter, the entire corresponding row is removed
rdfQueryBackModify :: VarBindingModify a b -> [[VarBinding a b]] -> [[VarBinding a b]]

-- | Simple entailment (instance) graph query.
--   
--   This function queries a graph to find instances of the query graph in
--   the target graph. It is very similar to the normal forward chaining
--   query <a>rdfQueryFind</a>, except that blank nodes rather than query
--   variable nodes in the query graph are matched against nodes in the
--   target graph. Neither graph should contain query variables.
--   
--   An instance is defined by the RDF semantics specification, per
--   <a>http://www.w3.org/TR/rdf-mt/</a>, and is obtained by replacing
--   blank nodes with URIs, literals or other blank nodes. RDF simple
--   entailment can be determined in terms of instances. This function
--   looks for a subgraph of the target graph that is an instance of the
--   query graph, which is a necessary and sufficient condition for RDF
--   entailment (see the Interpolation Lemma in RDF Semantics, section
--   1.2).
--   
--   It is anticipated that this query function can be used in conjunction
--   with backward chaining to determine when the search for sufficient
--   antecendents to determine some goal has been concluded.
rdfQueryInstance :: RDFGraph -> RDFGraph -> [RDFVarBinding]

-- | Graph substitution function.
--   
--   Uses the supplied variable bindings to substitute variables in a
--   supplied graph, returning a list of result graphs corresponding to
--   each set of variable bindings applied to the input graph. This
--   function is used for formward chaining substitutions, and returns only
--   those result graphs for which all query variables are bound.
rdfQuerySubs :: [RDFVarBinding] -> RDFGraph -> [RDFGraph]

-- | Graph back-substitution function.
--   
--   Uses the supplied variable bindings from <a>rdfQueryBack</a> to
--   perform a series of variable substitutions in a supplied graph,
--   returning a list of lists of result graphs corresponding to each set
--   of variable bindings applied to the input graphs.
--   
--   The outer list of the result contains alternative antecedent lists
--   that satisfy the query goal. Each inner list contains graphs that must
--   all be inferred to satisfy the query goal.
rdfQueryBackSubs :: [[RDFVarBinding]] -> RDFGraph -> [[(RDFGraph, [RDFLabel])]]

-- | Graph substitution function.
--   
--   This function performs the substitutions and returns a list of result
--   graphs each paired with a list unbound variables in each.
rdfQuerySubsAll :: [RDFVarBinding] -> RDFGraph -> [(RDFGraph, [RDFLabel])]

-- | Graph substitution function.
--   
--   This function performs each of the substitutions in <tt>vars</tt>, and
--   replaces any nodes corresponding to unbound query variables with new
--   blank nodes.
rdfQuerySubsBlank :: [RDFVarBinding] -> RDFGraph -> [RDFGraph]

-- | Graph back-substitution function, replacing variables with bnodes.
--   
--   Uses the supplied variable bindings from <a>rdfQueryBack</a> to
--   perform a series of variable substitutions in a supplied graph,
--   returning a list of lists of result graphs corresponding to each set
--   of variable bindings applied to the input graphs.
--   
--   The outer list of the result contains alternative antecedent lists
--   that satisfy the query goal. Each inner list contains graphs that must
--   all be inferred to satisfy the query goal.
rdfQueryBackSubsBlank :: [[RDFVarBinding]] -> RDFGraph -> [[RDFGraph]]

-- | Take a predicate on an RDF statement and a graph, and returns all
--   statements in the graph satisfying that predicate.
--   
--   Use combinations of these as follows:
--   
--   <ul>
--   <li>find all statements with given subject: <tt>rdfFindArcs (rdfSubjEq
--   s)</tt></li>
--   <li>find all statements with given property: <tt>rdfFindArcs
--   (rdfPredEq p)</tt></li>
--   <li>find all statements with given object: <tt>rdfFindArcs (rdfObjEq
--   o)</tt></li>
--   <li>find all statements matching conjunction of these conditions:
--   <tt>rdfFindArcs (<a>allp</a> [...])</tt></li>
--   <li>find all statements matching disjunction of these conditions:
--   <tt>rdfFindArcs (<a>anyp</a> [...])</tt></li>
--   </ul>
--   
--   Custom predicates can also be used.
rdfFindArcs :: (RDFTriple -> Bool) -> RDFGraph -> [RDFTriple]

-- | Test if statement has given subject
rdfSubjEq :: RDFLabel -> RDFTriple -> Bool

-- | Test if statement has given predicate
rdfPredEq :: RDFLabel -> RDFTriple -> Bool

-- | Test if statement has given object
rdfObjEq :: RDFLabel -> RDFTriple -> Bool

-- | Find values of given predicate for a given subject
rdfFindPredVal :: RDFLabel -> RDFLabel -> RDFGraph -> [RDFLabel]

-- | Find integer values of a given predicate for a given subject
rdfFindPredInt :: RDFLabel -> RDFLabel -> RDFGraph -> [Integer]

-- | Find all subjects that match (subject, predicate, object) in the
--   graph.
rdfFindValSubj :: RDFLabel -> RDFLabel -> RDFGraph -> [RDFLabel]

-- | Return a list of nodes that comprise an rdf:collection value, given
--   the head element of the collection. If the list is ill-formed then an
--   arbitrary value is returned.
rdfFindList :: RDFGraph -> RDFLabel -> [RDFLabel]

-- | Test if a value satisfies all predicates in a list
allp :: [a -> Bool] -> a -> Bool

-- | Test if a value satisfies any predicate in a list
anyp :: [a -> Bool] -> a -> Bool

-- | This function applies a substitution for a single set of variable
--   bindings, returning the result and a list of unbound variables. It
--   uses a state transformer monad to collect the list of unbound
--   variables.
--   
--   Adding an empty graph forces elimination of duplicate arcs.
rdfQuerySubs2 :: RDFVarBinding -> RDFGraph -> (RDFGraph, [RDFLabel])


-- | This module defines some datatypes and functions that are used to
--   define rules and rulesets over RDF graphs.
--   
--   For the routines that accept a graph in N3 format, the following
--   namespaces are pre-defined for use by the graph: <tt>rdf:</tt> and
--   <tt>rdfs:</tt>.
module Swish.RDF.Ruleset

-- | A named formula expressed as a RDF Graph.
type RDFFormula = Formula RDFGraph

-- | A named inference rule expressed in RDF.
type RDFRule = Rule RDFGraph

-- | A map for <a>RDFRule</a> rules.
type RDFRuleMap = RuleMap RDFGraph

-- | A <a>GraphClosure</a> for RDF statements.
type RDFClosure = GraphClosure RDFLabel

-- | A <a>Ruleset</a> for RDF.
type RDFRuleset = Ruleset RDFGraph

-- | A map for <a>RDFRuleset</a>.
type RDFRulesetMap = RulesetMap RDFGraph

-- | The null RDF formula.
nullRDFFormula :: Formula RDFGraph

-- | Datatype for constructing a graph closure rule
data GraphClosure lb
GraphClosure :: ScopedName -> ArcSet lb -> ArcSet lb -> VarBindingModify lb lb -> GraphClosure lb

-- | Name of rule for proof display
nameGraphRule :: GraphClosure lb -> ScopedName

-- | Antecedent triples pattern (may include variable nodes)
ruleAnt :: GraphClosure lb -> ArcSet lb

-- | Consequent triples pattern (may include variable nodes)
ruleCon :: GraphClosure lb -> ArcSet lb

-- | Structure that defines additional constraints and/or variable bindings
--   based on other matched query variables. Matching the antecedents. Use
--   <a>varBindingId</a> if no additional variable constraints or bindings
--   are added beyond those arising from graph queries.
ruleModify :: GraphClosure lb -> VarBindingModify lb lb

-- | Define a value of type Rule based on an RDFClosure value.
makeGraphClosureRule :: GraphClosure RDFLabel -> Rule RDFGraph

-- | Helper function to parse a string containing Notation3 and return the
--   corresponding RDFGraph value.
makeRDFGraphFromN3Builder :: Builder -> RDFGraph

-- | Create an RDF formula.
makeRDFFormula :: Namespace -> LName -> Builder -> RDFFormula

-- | Constructs an RDF graph closure rule. That is, a rule that given some
--   set of antecedent statements returns new statements that may be added
--   to the graph.
makeRDFClosureRule :: ScopedName -> [RDFGraph] -> RDFGraph -> RDFVarBindingModify -> RDFRule

-- | Constructs an RDF graph closure rule. That is, a rule that given some
--   set of antecedent statements returns new statements that may be added
--   to the graph. This is the basis for implementation of most of the
--   inference rules given in the RDF formal semantics document.
makeN3ClosureRule :: Namespace -> LName -> Builder -> Builder -> RDFVarBindingModify -> RDFRule

-- | Construct a simple RDF graph closure rule without additional node
--   allocations or variable binding constraints.
makeN3ClosureSimpleRule :: Namespace -> LName -> Builder -> Builder -> RDFRule

-- | Constructs an RDF graph closure rule that incorporates a variable
--   binding filter and a variable binding modifier.
makeN3ClosureModifyRule :: Namespace -> LName -> Builder -> Builder -> RDFVarBindingModify -> RDFVarBindingModify -> RDFRule

-- | Construct an RDF graph closure rule with a bnode allocator.
--   
--   This function is rather like <a>makeN3ClosureModifyRule</a>, except
--   that the variable binding modifier is a function from the variables in
--   the variables and bnodes contained in the antecedent graph.
makeN3ClosureAllocatorRule :: Namespace -> LName -> Builder -> Builder -> RDFVarBindingModify -> ([RDFLabel] -> RDFVarBindingModify) -> RDFRule

-- | This function defines a variable binding modifier that allocates a new
--   blank node for each value bound to a query variable, and binds it to
--   another variable in each query binding.
--   
--   This provides a single binding for query variables that would
--   otherwise be unbound by a query. For example, consider the inference
--   pattern:
--   
--   <pre>
--   ?a hasUncle ?c =&gt; ?a hasFather ?b . ?b hasBrother ?c .
--   </pre>
--   
--   For a given <tt>?a</tt> and <tt>?c</tt>, there is insufficient
--   information here to instantiate a value for variable <tt>?b</tt>.
--   Using this function as part of a graph instance closure rule allows
--   forward chaining to allocate a single bnode for each occurrence of
--   <tt>?a</tt>, so that given:
--   
--   <pre>
--   Jimmy hasUncle Fred .
--   Jimmy hasUncle Bob .
--   </pre>
--   
--   leads to exactly one bnode inference of:
--   
--   <pre>
--   Jimmy hasFather _:f .
--   </pre>
--   
--   giving:
--   
--   <pre>
--   Jimmy hasFather _:f .
--   _:f   hasBrother Fred .
--   _:f   hasBrother Bob .
--   </pre>
--   
--   rather than:
--   
--   <pre>
--   Jimmy hasFather _:f1 .
--   _:f1  hasBrother Fred .
--   Jimmy hasFather _:f2 .
--   _:f2  hasBrother Bob .
--   </pre>
--   
--   This form of constrained allocation of bnodes is also required for
--   some of the inference patterns described by the RDF formal semantics,
--   particularly those where bnodes are substituted for URIs or literals.
makeNodeAllocTo :: RDFLabel -> RDFLabel -> [RDFLabel] -> RDFVarBindingModify

-- | Forward chaining function based on RDF graph closure description
--   
--   Note: antecedents here are presumed to share bnodes.
graphClosureFwdApply :: GraphClosure RDFLabel -> [RDFGraph] -> [RDFGraph]

-- | Backward chaining function based on RDF graph closure description
graphClosureBwdApply :: GraphClosure RDFLabel -> RDFGraph -> [[RDFGraph]]
instance Label lb => Show (GraphClosure lb)
instance Label lb => Eq (GraphClosure lb)


-- | This module implements an inference rule based on a restruction on
--   class membership of one or more values.
module Swish.RDF.ClassRestrictionRule

-- | Datatype for named class restriction
data ClassRestriction
ClassRestriction :: ScopedName -> ClassRestrictionFn -> ClassRestriction
crName :: ClassRestriction -> ScopedName
crFunc :: ClassRestriction -> ClassRestrictionFn

-- | Type of function that evaluates missing node values in a restriction
--   from those supplied.
type ClassRestrictionFn = [Maybe RDFLabel] -> Maybe [[RDFLabel]]

-- | Make a class restriction from a datatype relation.
--   
--   This lifts application of the datatype relation to operate on
--   <a>RDFLabel</a> values, which are presumed to contain appropriately
--   datatyped values.
makeDatatypeRestriction :: RDFDatatypeVal vt -> DatatypeRel vt -> ClassRestriction

-- | Make a class restriction function from a datatype relation function.
makeDatatypeRestrictionFn :: RDFDatatypeVal vt -> DatatypeRelFn vt -> ClassRestrictionFn

-- | Make a list of class restriction rules given a list of class
--   restriction values and a graph containing one or more class
--   restriction definitions.
makeRDFClassRestrictionRules :: [ClassRestriction] -> RDFGraph -> [RDFRule]

-- | Make restriction rules from the supplied datatype and graph.
makeRDFDatatypeRestrictionRules :: RDFDatatypeVal vt -> RDFGraph -> [RDFRule]

-- | The graph
--   
--   <pre>
--   _:a &lt;http://id.ninebynine.org/2003/rdfext/rdfd#false&gt; _:b .
--   </pre>
--   
--   Exported for testing.
falseGraph :: RDFGraph

-- | Exported for testing.
falseGraphStr :: Builder
instance Show ClassRestriction
instance Eq ClassRestriction


-- | This module defines the structures used to represent and manipulate
--   RDF <tt>xsd:string</tt> datatyped literals.
module Swish.RDF.Datatype.XSD.String

-- | The RDFDatatype value for <tt>xsd:string</tt>.
rdfDatatypeXsdString :: RDFDatatype

-- | Define Datatype value for <tt>xsd:string</tt>.
rdfDatatypeValXsdString :: RDFDatatypeVal Text

-- | Type name for <tt>xsd:string</tt> datatype
typeNameXsdString :: ScopedName

-- | Namespace for <tt>xsd:string</tt> datatype functions
namespaceXsdString :: Namespace

-- | The axioms for <tt>xsd:string</tt>, which are
--   
--   <pre>
--   xsd:string a rdfs:Datatype .
--   </pre>
axiomsXsdString :: [RDFFormula]

-- | The rules for <tt>xsd:string</tt>.
rulesXsdString :: [RDFRule]


-- | This module defines the structures used to represent and manipulate
--   RDF <tt>xsd:integer</tt> datatyped literals.
module Swish.RDF.Datatype.XSD.Integer

-- | The RDFDatatype value for <tt>xsd:integer</tt>.
rdfDatatypeXsdInteger :: RDFDatatype

-- | Define Datatype value for <tt>xsd:integer</tt>.
--   
--   Members of this datatype are positive or negative integer values.
--   
--   The lexical form consists of an optional <tt>+</tt> or <tt>-</tt>
--   followed by a sequence of decimal digits.
--   
--   The canonical lexical form has leading zeros and <tt>+</tt> sign
--   removed.
rdfDatatypeValXsdInteger :: RDFDatatypeVal Integer

-- | Type name for <tt>xsd:integer</tt> datatype.
typeNameXsdInteger :: ScopedName

-- | Namespace for <tt>xsd:integer</tt> datatype functions.
namespaceXsdInteger :: Namespace

-- | The axioms for <tt>xsd:integer</tt>, which are
--   
--   <pre>
--   xsd:integer a rdfs:Datatype .
--   </pre>
axiomsXsdInteger :: [RDFFormula]

-- | The rules for <tt>xsd:integer</tt>.
rulesXsdInteger :: [RDFRule]


-- | This module defines the structures used to represent and manipulate
--   RDF <tt>xsd:decimal</tt> datatyped literals.
--   
--   Note that in versions <tt>0.6.4</tt> and <tt>0.6.5</tt>, this module
--   was a mixture of support for <tt>xsd:decimal</tt> and
--   <tt>xsd:double</tt>. In <tt>0.7.0</tt> the module has been changed to
--   <tt>xsd:decimal</tt>, but this may change.
module Swish.RDF.Datatype.XSD.Decimal

-- | The RDFDatatype value for <tt>xsd:decimal</tt>.
rdfDatatypeXsdDecimal :: RDFDatatype

-- | Define Datatype value for <tt>xsd:decimal</tt>.
--   
--   Members of this datatype decimal values.
--   
--   The lexical form consists of an optional <tt>+</tt> or <tt>-</tt>
--   followed by a sequence of decimal digits, an optional decimal point
--   and a sequence of decimal digits.
--   
--   The canonical lexical form has leading zeros and <tt>+</tt> sign
--   removed.
rdfDatatypeValXsdDecimal :: RDFDatatypeVal Double

-- | Type name for <tt>xsd:decimal</tt> datatype.
typeNameXsdDecimal :: ScopedName

-- | Namespace for <tt>xsd:decimal</tt> datatype functions.
namespaceXsdDecimal :: Namespace

-- | The axioms for <tt>xsd:decimal</tt>, which are
--   
--   <pre>
--   xsd:decimal a rdfs:Datatype .
--   </pre>
axiomsXsdDecimal :: [RDFFormula]

-- | The rules for <tt>xsd:decimal</tt>.
rulesXsdDecimal :: [RDFRule]


-- | This module collects references and provides access to all of the
--   datatypes built in to Swish.
module Swish.RDF.BuiltIn.Datatypes

-- | Al the data type declarations built into Swish.
allDatatypes :: [RDFDatatype]

-- | Look up a data type declaration.
findRDFDatatype :: ScopedName -> Maybe RDFDatatype


-- | This module instantiates the <a>Proof</a> framework for constructing
--   proofs over <a>RDFGraph</a> expressions. The intent is that this can
--   be used to test some correspondences between the RDF Model theory and
--   corresponding proof theory based on closure rules applied to the
--   graph, per <a>http://www.w3.org/TR/rdf-mt/</a>.
module Swish.RDF.Proof

-- | An RDF proof.
type RDFProof = Proof RDFGraph

-- | A step in an RDF proof.
type RDFProofStep = Step RDFGraph

-- | Make an RDF proof.
makeRDFProof :: [RDFRuleset] -> RDFFormula -> RDFFormula -> [RDFProofStep] -> RDFProof

-- | Make an RDF graph proof step.
makeRDFProofStep :: RDFRule -> [RDFFormula] -> RDFFormula -> RDFProofStep

-- | Make an inference rule dealing with RDF instance entailment; i.e.
--   entailments that are due to replacement of a URI or literal node with
--   a blank node.
--   
--   The part of this rule expected to be useful is <a>checkInference</a>.
--   The <a>fwdApply</a> and <a>bwdApply</a> functions defined here may
--   return rather large results if applied to graphs with many variables
--   or a large vocabulary, and are defined for experimentation.
--   
--   Forward and backward chaining is performed with respect to a specified
--   vocabulary. In the case of backward chaining, it would otherwise be
--   impossible to bound the options thus generated. In the case of forward
--   chaining, it is often not desirable to have the properties
--   generalized. If forward or backward backward chaining will not be
--   used, supply an empty vocabulary. Note: graph method <a>allNodes</a>
--   can be used to obtain a list of all the subjects and objects used in a
--   graph, not counting nested formulae; use a call of the form:
--   
--   <pre>
--   allNodes (not . labelIsVar) graph
--   </pre>
makeRdfInstanceEntailmentRule :: ScopedName -> [RDFLabel] -> RDFRule

-- | Make an inference rule dealing with RDF subgraph entailment. The part
--   of this rule expected to be useful is <a>checkInference</a>. The
--   <a>fwdApply</a> function defined here may return rather large results.
--   But in the name of completeness and experimentation with the
--   possibilities of lazy evaluation, it has been defined.
--   
--   Backward chaining is not performed, as there is no reasonable way to
--   choose a meaningful supergraph of that supplied.
makeRdfSubgraphEntailmentRule :: ScopedName -> RDFRule

-- | Make an inference rule dealing with RDF simple entailment. The part of
--   this rule expected to be useful is <a>checkInference</a>. The
--   <a>fwdApply</a> and <a>bwdApply</a> functions defined return null
--   results, indicating that they are not useful for the purposes of proof
--   discovery.
makeRdfSimpleEntailmentRule :: ScopedName -> RDFRule
instance (Label lb, LDGraph lg lb, Eq (lg lb)) => Expression (lg lb)


-- | This module contains proof-context declarations based on the RDF,
--   RDFS, and RDF datatyping semantics specifications. These definitions
--   consist of namespaces (for identification in proofs), axioms and
--   inference rules.
module Swish.RDF.ProofContext

-- | Ruleset for RDF inference.
rulesetRDF :: RDFRuleset

-- | Ruleset for RDFS inference.
rulesetRDFS :: RDFRuleset

-- | Ruleset for RDFD (datatyping) inference.
rulesetRDFD :: RDFRuleset


-- | This module collects references and provides access to all of the
--   rulesets, variable binding modifiers and variable binding filters
--   built in to Swish.
module Swish.RDF.BuiltIn.Rules

-- | Find the named open variable binding modifier.
findRDFOpenVarBindingModifier :: ScopedName -> Maybe RDFOpenVarBindingModify

-- | A <tt>LookupMap</tt> of <a>allRulesets</a>.
rdfRulesetMap :: RDFRulesetMap

-- | All the rule sets known to Swish.
allRulesets :: [RDFRuleset]

-- | The data type rule sets known to Swish.
allDatatypeRulesets :: [RDFRuleset]


-- | This module collects references and provides access to all of the
--   datatypes, variable binding modifiers and variable binding filters
--   built in to Swish.
module Swish.RDF.BuiltIn

-- | Find the named open variable binding modifier.
findRDFOpenVarBindingModifier :: ScopedName -> Maybe RDFOpenVarBindingModify

-- | Look up a data type declaration.
findRDFDatatype :: ScopedName -> Maybe RDFDatatype

-- | A <tt>LookupMap</tt> of <a>allRulesets</a>.
rdfRulesetMap :: RDFRulesetMap

-- | All the rule sets known to Swish.
allRulesets :: [RDFRuleset]

-- | The data type rule sets known to Swish.
allDatatypeRulesets :: [RDFRuleset]


-- | Composed state and IO monad for Swish
module Swish.Monad

-- | The state monad used in executing Swish programs.
type SwishStateIO a = StateT SwishState IO a

-- | The State for a Swish "program".
data SwishState
SwishState :: SwishFormat -> Maybe QName -> RDFGraph -> NamedGraphMap -> RDFRuleMap -> RDFRulesetMap -> Maybe String -> Maybe String -> SwishStatus -> SwishState

-- | format to use for I/O
format :: SwishState -> SwishFormat

-- | base to use rather than file name
base :: SwishState -> Maybe QName

-- | current graph
graph :: SwishState -> RDFGraph

-- | script processor named graphs
graphs :: SwishState -> NamedGraphMap

-- | script processor named rules
rules :: SwishState -> RDFRuleMap

-- | script processor rulesets
rulesets :: SwishState -> RDFRulesetMap

-- | information message, or Nothing
infomsg :: SwishState -> Maybe String

-- | error message, or Nothing
errormsg :: SwishState -> Maybe String

-- | current status
exitcode :: SwishState -> SwishStatus

-- | Status of the processor
data SwishStatus

-- | successful run
SwishSuccess :: SwishStatus

-- | graphs do not compare
SwishGraphCompareError :: SwishStatus

-- | input data problem (ie format/syntax)
SwishDataInputError :: SwishStatus

-- | data access error
SwishDataAccessError :: SwishStatus

-- | command-line argument error
SwishArgumentError :: SwishStatus

-- | error executing a Swish script
SwishExecutionError :: SwishStatus

-- | The supported input and output formats.
data SwishFormat

-- | Turtle format
Turtle :: SwishFormat

-- | N3 format
N3 :: SwishFormat

-- | NTriples format
NT :: SwishFormat

-- | A LookupMap for the graphs dictionary.
type NamedGraphMap = Map ScopedName [RDFGraph]

-- | The default state for Swish: no loaded graphs or rules, and format set
--   to <a>N3</a>.
emptyState :: SwishState

-- | Change the format.
setFormat :: SwishFormat -> SwishState -> SwishState

-- | Change (or remove) the base URI.
setBase :: Maybe QName -> SwishState -> SwishState

-- | Change the current graph.
setGraph :: RDFGraph -> SwishState -> SwishState

-- | Modify the named graphs.
modGraphs :: (NamedGraphMap -> NamedGraphMap) -> SwishState -> SwishState

-- | Find a named graph.
findGraph :: ScopedName -> SwishState -> Maybe [RDFGraph]

-- | Find a formula. The search is first made in the named graphs and then,
--   if not found, the rulesets.
findFormula :: ScopedName -> SwishState -> Maybe RDFFormula

-- | Modify the named rules.
modRules :: (RDFRuleMap -> RDFRuleMap) -> SwishState -> SwishState

-- | Find a named rule.
findRule :: ScopedName -> SwishState -> Maybe RDFRule

-- | Modify the rule sets.
modRulesets :: (RDFRulesetMap -> RDFRulesetMap) -> SwishState -> SwishState

-- | Find a rule set.
findRuleset :: ScopedName -> SwishState -> Maybe RDFRuleset

-- | Find a modify rule.
findOpenVarModify :: ScopedName -> SwishState -> Maybe RDFOpenVarBindingModify

-- | Find a data type declaration.
findDatatype :: ScopedName -> SwishState -> Maybe RDFDatatype

-- | Set the information message.
setInfo :: String -> SwishState -> SwishState

-- | Clear the information message.
resetInfo :: SwishState -> SwishState

-- | Set the error message.
setError :: String -> SwishState -> SwishState

-- | Clear the error message.
resetError :: SwishState -> SwishState

-- | Set the status.
setStatus :: SwishStatus -> SwishState -> SwishState

-- | Report error and set exit status code
swishError :: String -> SwishStatus -> SwishStateIO ()

-- | Output the text to the standard error stream (a new line is added to
--   the output).
reportLine :: String -> SwishStateIO ()
instance Eq SwishFormat
instance Eq SwishStatus
instance Enum SwishStatus
instance Show SwishStatus
instance Show SwishFormat


-- | This Module implements a Turtle formatter for an <a>RDFGraph</a>
--   value.
--   
--   REFERENCES:
--   
--   <ul>
--   <li>"Turtle, Terse RDF Triple Language", W3C Working Draft 09 August
--   2011 (<a>http://www.w3.org/TR/2011/WD-turtle-20110809/</a>)
--   <a>http://www.w3.org/TR/turtle/</a></li>
--   </ul>
--   
--   NOTES:
--   
--   <ul>
--   <li>The formatter needs to be updated to the W3C Candidate
--   Recommendation (19 February 2013,
--   <a>http://www.w3.org/TR/2013/CR-turtle-20130219/</a>).</li>
--   <li>Should literal strings (<tt>Lit</tt>) be written out as
--   <tt>xsd:string</tt>, or should <tt>TypedLit</tt> strings with a type
--   of <tt>xsd:string</tt> be written out with no type? (e.g. see
--   <a>http://www.w3.org/TR/2011/WD-turtle-20110809/#terms</a>).</li>
--   </ul>
module Swish.RDF.Formatter.Turtle

-- | Node name generation state information that carries through and is
--   updated by nested formulae.
type NodeGenLookupMap = Map RDFLabel Word32

-- | Convert the graph to text.
formatGraphAsText :: RDFGraph -> Text

-- | Convert the graph to text.
formatGraphAsLazyText :: RDFGraph -> Text

-- | Convert the graph to a Builder.
formatGraphAsBuilder :: RDFGraph -> Builder

-- | Convert the graph to a builder using the given indentation text.
formatGraphIndent :: Builder -> Bool -> RDFGraph -> Builder

-- | Format graph and return additional information.
formatGraphDiag :: Builder -> Bool -> RDFGraph -> (Builder, NodeGenLookupMap, Word32, [String])


-- | This Module implements a Notation 3 formatter for an <a>RDFGraph</a>
--   value.
--   
--   REFERENCES:
--   
--   <ul>
--   <li>"Notation3 (N3): A readable RDF syntax", W3C Team Submission 14
--   January 2008,
--   <a>http://www.w3.org/TeamSubmission/2008/SUBM-n3-20080114/</a></li>
--   <li>Tim Berners-Lee's design issues series notes and description,
--   <a>http://www.w3.org/DesignIssues/Notation3.html</a></li>
--   <li>Notation 3 Primer by Sean Palmer,
--   <a>http://www.w3.org/2000/10/swap/Primer.html</a></li>
--   </ul>
--   
--   TODO:
--   
--   <ul>
--   <li>Initial prefix list to include nested formulae; then don't need to
--   update prefix list for these.</li>
--   <li>correct output of strings containing unsupported escape characters
--   (such as <tt>\q</tt>)</li>
--   <li>more flexible terminator generation for formatted formulae (for
--   inline blank nodes.)</li>
--   </ul>
module Swish.RDF.Formatter.N3

-- | Node name generation state information that carries through and is
--   updated by nested formulae.
type NodeGenLookupMap = Map RDFLabel Word32

-- | Convert the graph to text.
formatGraphAsText :: RDFGraph -> Text

-- | Convert the graph to text.
formatGraphAsLazyText :: RDFGraph -> Text

-- | Convert the graph to a Builder.
formatGraphAsBuilder :: RDFGraph -> Builder

-- | Convert the graph to a builder using the given indentation text.
formatGraphIndent :: Builder -> Bool -> RDFGraph -> Builder

-- | Format graph and return additional information
formatGraphDiag :: Builder -> Bool -> RDFGraph -> (Builder, NodeGenLookupMap, Word32, [String])


-- | This module defines a <a>ShowLines</a> class instance for
--   <a>RDFGraph</a>, to be used when displaying RDF Graph values as part
--   of a proof sequence, etc.
module Swish.RDF.GraphShowLines
instance ShowLines RDFGraph


-- | This module implements the Swish script processor: it parses a script
--   from a supplied string, and returns a list of Swish state transformer
--   functions whose effect, when applied to a state value, is to implement
--   the supplied script.
module Swish.Script

-- | Parser for Swish script processor
parseScriptFromText :: Maybe QName -> Text -> Either String [SwishStateIO ()]


-- | This Module implements a NTriples formatter for a <a>RDFGraph</a>.
--   
--   REFERENCES:
--   
--   <ul>
--   <li>"RDF Test Cases", W3C Recommendation 10 February 2004,
--   <a>http://www.w3.org/TR/rdf-testcases/#ntriples</a></li>
--   </ul>
--   
--   NOTES:
--   
--   <ul>
--   <li>Update to the document "N-Triples. A line-based syntax for an RDF
--   graph" W3C Working Group Note 09 April 2013,
--   <a>http://www.w3.org/TR/2013/NOTE-n-triples-20130409/</a></li>
--   </ul>
module Swish.RDF.Formatter.NTriples

-- | Convert a RDF graph to NTriples format.
formatGraphAsText :: RDFGraph -> Text

-- | Convert a RDF graph to NTriples format.
formatGraphAsLazyText :: RDFGraph -> Text

-- | Convert a RDF graph to NTriples format.
formatGraphAsBuilder :: RDFGraph -> Builder


-- | Functions to deal with indivudual Swish command options.
module Swish.Commands

-- | Set the file format.
swishFormat :: SwishFormat -> SwishStateIO ()

-- | Set (or clear) the base URI.
swishBase :: Maybe QName -> SwishStateIO ()

-- | Read in a graph and make it the current graph.
swishInput :: Maybe String -> SwishStateIO ()

-- | Write out the current graph.
swishOutput :: Maybe String -> SwishStateIO ()

-- | Read in a graph and merge it with the current graph.
swishMerge :: Maybe String -> SwishStateIO ()

-- | Read in a graph and compare it with the current graph.
swishCompare :: Maybe String -> SwishStateIO ()

-- | Read in a graph and display the differences to the current graph to
--   standard output.
swishGraphDiff :: Maybe String -> SwishStateIO ()

-- | Read in a script and execute it.
swishScript :: Maybe String -> SwishStateIO ()


-- | Swish: Semantic Web Inference Scripting in Haskell
--   
--   This program is a simple skeleton for constructing Semantic Web [1]
--   inference tools in Haskell, using the RDF graph and several RDF
--   parsers (at present Notation 3 and NTriples).
--   
--   It might be viewed as a kind of embroyonic CWM [2] in Haskell, except
--   that the intent is that Haskell will be used as a primary language for
--   defining inferences. As such, Swish is an open-ended toolkit for
--   constructing new special-purpose Semantic Web applications rather than
--   a closed, self-contained general-purpose SW application. As such, it
--   is part of another experiment along the lines described in [3].
--   
--   The script format used by Swish is described in <a>Swish.Script</a>.
--   
--   Users wishing to process RDF data directly may prefer to look at the
--   following modules; <a>Swish.RDF</a>, <a>Swish.RDF.Parser.Turtle</a>,
--   <a>Swish.RDF.Parser.N3</a>, <a>Swish.RDF.Parser.NTriples</a>,
--   <a>Swish.RDF.Formatter.Turtle</a>, <a>Swish.RDF.Formatter.N3</a> and
--   <a>Swish.RDF.Formatter.NTriples</a>.
--   
--   <ol>
--   <li>Semantic web: <a>http://www.w3.org/2001/sw/</a></li>
--   <li>CWM: <a>http://www.w3.org/2000/10/swap/doc/cwm.html</a></li>
--   <li>Motivation:
--   <a>http://www.w3.org/2000/10/swap/doc/Motivation.html</a></li>
--   <li>Notation 3:
--   <a>http://www.w3.org/TeamSubmission/2008/SUBM-n3-20080114/</a></li>
--   <li>Turtle: <a>http://www.w3.org/TR/turtle/</a></li>
--   <li>RDF: <a>http://www.w3.org/RDF/</a></li>
--   </ol>
--   
--   Notes
--   
--   I anticipate that this module may be used as a starting point for
--   creating new programs rather then as a complete program in its own
--   right. The functionality built into this code is selected with a view
--   to testing the Haskell modules for handling RDF rather than for
--   performing any particular application processing (though development
--   as a tool with some broader utility is not ruled out).
--   
--   With the following in ghci:
--   
--   <pre>
--   &gt;&gt;&gt; :m + Swish
--   
--   &gt;&gt;&gt; :set prompt "swish&gt; "
--   </pre>
--   
--   then we can run a Swish script (format described in
--   <a>Swish.Script</a>) by saying:
--   
--   <pre>
--   &gt;&gt;&gt; runSwish "-s=script.ss"
--   ExitSuccess
--   </pre>
--   
--   or convert a file from Turtle to NTriples format with:
--   
--   <pre>
--   &gt;&gt;&gt; runSwish "-ttl -i=foo.ttl -nt -o=foo.nt"
--   ExitSuccess
--   </pre>
--   
--   You can also use <a>validateCommands</a> by giving it the individual
--   commands, such as
--   
--   <pre>
--   &gt;&gt;&gt; let Right cs = validateCommands ["-ttl", "-i=file1.ttl", "-c=file2.ttl"]
--   
--   &gt;&gt;&gt; cs
--   [SwishAction: -ttl,SwishAction: -i=file1.ttl,SwishAction: -c=file2.ttl]
--   
--   &gt;&gt;&gt; st &lt;- runSwishActions cs
--   
--   &gt;&gt;&gt; st
--   The graphs do not compare as equal.
--   </pre>
module Swish

-- | Status of the processor
data SwishStatus

-- | successful run
SwishSuccess :: SwishStatus

-- | graphs do not compare
SwishGraphCompareError :: SwishStatus

-- | input data problem (ie format/syntax)
SwishDataInputError :: SwishStatus

-- | data access error
SwishDataAccessError :: SwishStatus

-- | command-line argument error
SwishArgumentError :: SwishStatus

-- | error executing a Swish script
SwishExecutionError :: SwishStatus

-- | Represent a Swish action. At present there is no way to create these
--   actions other than <a>validateCommands</a>.
data SwishAction

-- | Parse and run the given string as if given at the command line. The
--   "quiet", "version" and "help" options are ignored.
runSwish :: String -> IO ExitCode

-- | Execute the given set of actions.
runSwishActions :: [SwishAction] -> IO SwishStatus

-- | Write out the help for Swish
displaySwishHelp :: IO ()

-- | Return any arguments that need processing immediately, namely the
--   "help", "quiet" and "version" options.
splitArguments :: [String] -> ([String], [String])

-- | Given a list of command-line arguments create the list of actions to
--   perform or a string and status value indicating an input error.
validateCommands :: [String] -> Either (String, SwishStatus) [SwishAction]
instance Show SwishAction


-- | This module defines some commonly used vocabulary terms from the
--   Dublin Core vocabularies
--   (<a>http://dublincore.org/documents/dcmi-terms/</a>).
module Swish.RDF.Vocabulary.DublinCore

-- | Maps <tt>dcterms</tt> to <a>http://purl.org/dc/terms/</a>.
namespaceDCTERMS :: Namespace

-- | Maps <tt>dcelem</tt> to the legacy namespace
--   <a>http://purl.org/dc/elements/1.1/</a>.
namespaceDCELEM :: Namespace

-- | Maps <tt>dcam</tt> to <a>http://purl.org/dc/dcam/</a>.
namespaceDCAM :: Namespace

-- | Maps <tt>dctype</tt> to <a>http://purl.org/dc/dcmitype/</a>.
namespaceDCTYPE :: Namespace

-- | <tt>dcterms:Agent</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#classes-Agent</a>.
dctAgent :: ScopedName

-- | <tt>dcterms:AgentClass</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#classes-AgentClass</a>.
dctAgentClass :: ScopedName

-- | <tt>dcterms:BibliographicResource</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#classes-BibliographicResource</a>.
dctBibliographicResource :: ScopedName

-- | <tt>dcterms:FileFormat</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#classes-FileFormat</a>.
dctFileFormat :: ScopedName

-- | <tt>dcterms:Frequency</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#classes-Frequency</a>.
dctFrequency :: ScopedName

-- | <tt>dcterms:Jurisdiction</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#classes-Jurisdiction</a>.
dctJurisdiction :: ScopedName

-- | <tt>dcterms:LicenseDocument</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#classes-LicenseDocument</a>.
dctLicenseDocument :: ScopedName

-- | <tt>dcterms:LinguisticSystem</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#classes-LinguisticSystem</a>.
dctLinguisticSystem :: ScopedName

-- | <tt>dcterms:Location</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#classes-Location</a>.
dctLocation :: ScopedName

-- | <tt>dcterms:LocationPeriodOrJurisdiction</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#classes-LocationPeriodOrJurisdiction</a>.
dctLocationPeriodOrJurisdiction :: ScopedName

-- | <tt>dcterms:MediaType</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#classes-MediaType</a>.
dctMediaType :: ScopedName

-- | <tt>dcterms:MediaTypeOrExtent</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#classes-MediaTypeOrExtent</a>.
dctMediaTypeOrExtent :: ScopedName

-- | <tt>dcterms:MethodOfAccrual</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#classes-MethodOfAccrual</a>.
dctMethodOfAccrual :: ScopedName

-- | <tt>dcterms:MethodOfInstruction</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#classes-MethodOfInstruction</a>.
dctMethodOfInstruction :: ScopedName

-- | <tt>dcterms:PeriodOfTime</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#classes-PeriodOfTime</a>.
dctPeriodOfTime :: ScopedName

-- | <tt>dcterms:PhysicalMedium</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#classes-PhysicalMedium</a>.
dctPhysicalMedium :: ScopedName

-- | <tt>dcterms:PhysicalResource</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#classes-PhysicalResource</a>.
dctPhysicalResource :: ScopedName

-- | <tt>dcterms:Policy</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#classes-Policy</a>.
dctPolicy :: ScopedName

-- | <tt>dcterms:ProvenanceStatement</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#classes-ProvenanceStatement</a>.
dctProvenanceStatement :: ScopedName

-- | <tt>dcterms:RightsStatement</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#classes-RightsStatement</a>.
dctRightsStatement :: ScopedName

-- | <tt>dcterms:SizeOrDuration</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#classes-SizeOrDuration</a>.
dctSizeOrDuration :: ScopedName

-- | <tt>dcterms:Standard</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#classes-Standard</a>.
dctStandard :: ScopedName

-- | <tt>dcterms:abstract</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-abstract</a>.
dctabstract :: ScopedName

-- | <tt>dcterms:accessRights</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-accessRights</a>.
dctaccessRights :: ScopedName

-- | <tt>dcterms:accrualMethod</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-accrualMethod</a>.
dctaccrualMethod :: ScopedName

-- | <tt>dcterms:accrualPeriodicity</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-accrualPeriodicity</a>.
dctaccrualPeriodicity :: ScopedName

-- | <tt>dcterms:accrualPolicy</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-accrualPolicy</a>.
dctaccrualPolicy :: ScopedName

-- | <tt>dcterms:alternative</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-alternative</a>.
dctalternative :: ScopedName

-- | <tt>dcterms:audience</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-audience</a>.
dctaudience :: ScopedName

-- | <tt>dcterms:available</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-available</a>.
dctavailable :: ScopedName

-- | <tt>dcterms:bibliographicCitation</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-bibliographicCitation</a>.
dctbibliographicCitation :: ScopedName

-- | <tt>dcterms:conformsTo</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-conformsTo</a>.
dctconformsTo :: ScopedName

-- | <tt>dcterms:contributor</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-contributor</a>.
dctcontributor :: ScopedName

-- | <tt>dcterms:coverage</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-coverage</a>.
dctcoverage :: ScopedName

-- | <tt>dcterms:created</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-created</a>.
dctcreated :: ScopedName

-- | <tt>dcterms:creator</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-creator</a>.
dctcreator :: ScopedName

-- | <tt>dcterms:date</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-date</a>.
dctdate :: ScopedName

-- | <tt>dcterms:dateAccepted</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-dateAccepted</a>.
dctdateAccepted :: ScopedName

-- | <tt>dcterms:dateCopyrighted</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-dateCopyrighted</a>.
dctdateCopyrighted :: ScopedName

-- | <tt>dcterms:dateSubmitted</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-dateSubmitted</a>.
dctdateSubmitted :: ScopedName

-- | <tt>dcterms:description</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-description</a>.
dctdescription :: ScopedName

-- | <tt>dcterms:educationLevel</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-educationLevel</a>.
dcteducationLevel :: ScopedName

-- | <tt>dcterms:extent</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-extent</a>.
dctextent :: ScopedName

-- | <tt>dcterms:format</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-format</a>.
dctformat :: ScopedName

-- | <tt>dcterms:hasFormat</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-hasFormat</a>.
dcthasFormat :: ScopedName

-- | <tt>dcterms:hasPart</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-hasPart</a>.
dcthasPart :: ScopedName

-- | <tt>dcterms:hasVersion</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-hasVersion</a>.
dcthasVersion :: ScopedName

-- | <tt>dcterms:identifier</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-identifier</a>.
dctidentifier :: ScopedName

-- | <tt>dcterms:instructionalMethod</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-instructionalMethod</a>.
dctinstructionalMethod :: ScopedName

-- | <tt>dcterms:isFormatOf</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-isFormatOf</a>.
dctisFormatOf :: ScopedName

-- | <tt>dcterms:isPartOf</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-isPartOf</a>.
dctisPartOf :: ScopedName

-- | <tt>dcterms:isReferencedBy</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-isReferencedBy</a>.
dctisReferencedBy :: ScopedName

-- | <tt>dcterms:isReplacedBy</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-isReplacedBy</a>.
dctisReplacedBy :: ScopedName

-- | <tt>dcterms:isRequiredBy</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-isRequiredBy</a>.
dctisRequiredBy :: ScopedName

-- | <tt>dcterms:issued</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-issued</a>.
dctissued :: ScopedName

-- | <tt>dcterms:isVersionOf</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-isVersionOf</a>.
dctisVersionOf :: ScopedName

-- | <tt>dcterms:language</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-language</a>.
dctlanguage :: ScopedName

-- | <tt>dcterms:license</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-license</a>.
dctlicense :: ScopedName

-- | <tt>dcterms:mediator</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-mediator</a>.
dctmediator :: ScopedName

-- | <tt>dcterms:medium</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-medium</a>.
dctmedium :: ScopedName

-- | <tt>dcterms:modified</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-modified</a>.
dctmodified :: ScopedName

-- | <tt>dcterms:provenance</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-provenance</a>.
dctprovenance :: ScopedName

-- | <tt>dcterms:publisher</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-publisher</a>.
dctpublisher :: ScopedName

-- | <tt>dcterms:references</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-references</a>.
dctreferences :: ScopedName

-- | <tt>dcterms:relation</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-relation</a>.
dctrelation :: ScopedName

-- | <tt>dcterms:replaces</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-replaces</a>.
dctreplaces :: ScopedName

-- | <tt>dcterms:requires</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-requires</a>.
dctrequires :: ScopedName

-- | <tt>dcterms:rights</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-rights</a>.
dctrights :: ScopedName

-- | <tt>dcterms:rightsHolder</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-rightsHolder</a>.
dctrightsHolder :: ScopedName

-- | <tt>dcterms:source</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-source</a>.
dctsource :: ScopedName

-- | <tt>dcterms:spatial</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-spatial</a>.
dctspatial :: ScopedName

-- | <tt>dcterms:subject</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-subject</a>.
dctsubject :: ScopedName

-- | <tt>dcterms:tableOfContents</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-tableOfContents</a>.
dcttableOfContents :: ScopedName

-- | <tt>dcterms:temporal</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-temporal</a>.
dcttemporal :: ScopedName

-- | <tt>dcterms:title</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-title</a>.
dcttitle :: ScopedName

-- | <tt>dcterms:type</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-type</a>.
dcttype :: ScopedName

-- | <tt>dcterms:valid</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#terms-valid</a>.
dctvalid :: ScopedName

-- | <tt>dcelem:contributor</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#elements-contributor</a>.
dcelemcontributor :: ScopedName

-- | <tt>dcelem:coverage</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#elements-coverage</a>.
dcelemcoverage :: ScopedName

-- | <tt>dcelem:creator</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#elements-creator</a>.
dcelemcreator :: ScopedName

-- | <tt>dcelem:date</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#elements-date</a>.
dcelemdate :: ScopedName

-- | <tt>dcelem:description</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#elements-description</a>.
dcelemdescription :: ScopedName

-- | <tt>dcelem:format</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#elements-format</a>.
dcelemformat :: ScopedName

-- | <tt>dcelem:identifier</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#elements-identifier</a>.
dcelemidentifier :: ScopedName

-- | <tt>dcelem:language</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#elements-language</a>.
dcelemlanguage :: ScopedName

-- | <tt>dcelem:publisher</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#elements-publisher</a>.
dcelempublisher :: ScopedName

-- | <tt>dcelem:relation</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#elements-relation</a>.
dcelemrelation :: ScopedName

-- | <tt>dcelem:rights</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#elements-rights</a>.
dcelemrights :: ScopedName

-- | <tt>dcelem:source</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#elements-source</a>.
dcelemsource :: ScopedName

-- | <tt>dcelem:subject</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#elements-subject</a>.
dcelemsubject :: ScopedName

-- | <tt>dcelem:title</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#elements-title</a>.
dcelemtitle :: ScopedName

-- | <tt>dcelem:type</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#elements-type</a>.
dcelemtype :: ScopedName

-- | <tt>dcterms:LCSH</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#ves-LCSH</a>.
dctLCSH :: ScopedName

-- | <tt>dcterms:MESH</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#ves-MESH</a>.
dctMESH :: ScopedName

-- | <tt>dcterms:DDC</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#ves-DDC</a>.
dctDDC :: ScopedName

-- | <tt>dcterms:LCC</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#ves-LCC</a>.
dctLCC :: ScopedName

-- | <tt>dcterms:UDC</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#ves-UDC</a>.
dctUDC :: ScopedName

-- | <tt>dcterms:DCMIType</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#ves-DCMIType</a>.
dctDCMIType :: ScopedName

-- | <tt>dcterms:IMT</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#ves-IMT</a>.
dctIMT :: ScopedName

-- | <tt>dcterms:TGN</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#ves-TGN</a>.
dctTGN :: ScopedName

-- | <tt>dcterms:NLM</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#ves-NLM</a>.
dctNLM :: ScopedName

-- | <tt>dcterms:Box</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#ses-Box</a>.
dctBox :: ScopedName

-- | <tt>dcterms:ISO3166</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#ses-ISO3166</a>.
dctISO3166 :: ScopedName

-- | <tt>dcterms:ISO639-2</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#ses-ISO639-2</a>.
dctISO639_2 :: ScopedName

-- | <tt>dcterms:ISO639-3</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#ses-ISO639-3</a>.
dctISO639_3 :: ScopedName

-- | <tt>dcterms:Period</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#ses-Period</a>.
dctPeriod :: ScopedName

-- | <tt>dcterms:Point</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#ses-Point</a>.
dctPoint :: ScopedName

-- | <tt>dcterms:RFC1766</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#ses-RFC1766</a>.
dctRFC1766 :: ScopedName

-- | <tt>dcterms:RFC3066</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#ses-RFC3066</a>.
dctRFC3066 :: ScopedName

-- | <tt>dcterms:RFC4646</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#ses-RFC4646</a>.
dctRFC4646 :: ScopedName

-- | <tt>dcterms:RFC5646</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#ses-RFC5646</a>.
dctRFC5646 :: ScopedName

-- | <tt>dcterms:URI</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#ses-URI</a>.
dctURI :: ScopedName

-- | <tt>dcterms:W3CDTF</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#ses-W3CDTF</a>.
dctW3CDTF :: ScopedName

-- | <tt>dctype:Collection</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#dcmitype-Collection</a>.
dctypeCollection :: ScopedName

-- | <tt>dctype:Dataset</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#dcmitype-Dataset</a>.
dctypeDataset :: ScopedName

-- | <tt>dctype:Event</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#dcmitype-Event</a>.
dctypeEvent :: ScopedName

-- | <tt>dctype:Image</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#dcmitype-Image</a>.
dctypeImage :: ScopedName

-- | <tt>dctype:InteractiveResource</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#dcmitype-InteractiveResource</a>.
dctypeInteractiveResource :: ScopedName

-- | <tt>dctype:Service</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#dcmitype-Service</a>.
dctypeService :: ScopedName

-- | <tt>dctype:Software</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#dcmitype-Software</a>.
dctypeSoftware :: ScopedName

-- | <tt>dctype:Sound</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#dcmitype-Sound</a>.
dctypeSound :: ScopedName

-- | <tt>dctype:Text</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#dcmitype-Text</a>.
dctypeText :: ScopedName

-- | <tt>dctype:PhysicalObject</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#dcmitype-PhysicalObject</a>.
dctypePhysicalObject :: ScopedName

-- | <tt>dctype:StillImage</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#dcmitype-StillImage</a>.
dctypeStillImage :: ScopedName

-- | <tt>dctype:MovingImage</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#dcmitype-MovingImage</a>.
dctypeMovingImage :: ScopedName

-- | <tt>dcam:memberOf</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#dcam-memberOf</a>.
dcammemberOf :: ScopedName

-- | <tt>dcam:memberOf</tt> from
--   <a>http://dublincore.org/documents/dcmi-terms/#dcam-memberOf</a>.
dcamVocabularyEncodingScheme :: ScopedName


-- | This module defines some commonly used vocabulary terms from the FOAF
--   vocabulary (<a>http://xmlns.com/foaf/spec/</a>).
--   
--   Note that unlike some of the existing vocabularies in Swish, the FOAF
--   one matches the case and spelling of the RDF terms; so we use
--   <a>foafbased_near</a> rather than <tt>foafBasedNear</tt>. This is
--   partly because some terms would end up with the same Haskell label if
--   a conversion to camel-case wer used.
module Swish.RDF.Vocabulary.FOAF

-- | Maps <tt>foaf</tt> to <a>http://xmlns.com/foaf/0.1/</a>.
namespaceFOAF :: Namespace

-- | <tt>foaf:Agent</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_Agent</a>.
foafAgent :: ScopedName

-- | <tt>foaf:Document</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_Document</a>.
foafDocument :: ScopedName

-- | <tt>foaf:Group</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_Group</a>.
foafGroup :: ScopedName

-- | <tt>foaf:Image</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_Image</a>.
foafImage :: ScopedName

-- | <tt>foaf:LabelProperty</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_LabelProperty</a>.
foafLabelProperty :: ScopedName

-- | <tt>foaf:OnlineAccount</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_OnlineAccount</a>.
foafOnlineAccount :: ScopedName

-- | <tt>foaf:OnlineChatAccount</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_OnlineChatAccount</a>.
foafOnlineChatAccount :: ScopedName

-- | <tt>foaf:OnlineEcommerceAccount</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_OnlineEcommerceAccount</a>.
foafOnlineEcommerceAccount :: ScopedName

-- | <tt>foaf:OnlineGamingAccount</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_OnlineGamingAccount</a>.
foafOnlineGamingAccount :: ScopedName

-- | <tt>foaf:Organization</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_Organization</a>.
foafOrganization :: ScopedName

-- | <tt>foaf:Person</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_Person</a>.
foafPerson :: ScopedName

-- | <tt>foaf:PersonalProfileDocument</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_PersonalProfileDocument</a>.
foafPersonalProfileDocument :: ScopedName

-- | <tt>foaf:Project</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_Project</a>.
foafProject :: ScopedName

-- | <tt>foaf:account</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_account</a>.
foafaccount :: ScopedName

-- | <tt>foaf:accountName</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_accountName</a>.
foafaccountName :: ScopedName

-- | <tt>foaf:accountServiceHomepage</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_accountServiceHomepage</a>.
foafaccountServiceHomepage :: ScopedName

-- | <tt>foaf:age</tt> from <a>http://xmlns.com/foaf/spec/#term_age</a>.
foafage :: ScopedName

-- | <tt>foaf:aimChatID</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_aimChatID</a>.
foafaimChatID :: ScopedName

-- | <tt>foaf:based_near</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_based_near</a>.
foafbased_near :: ScopedName

-- | <tt>foaf:birthday</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_birthday</a>.
foafbirthday :: ScopedName

-- | <tt>foaf:currentProject</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_currentProject</a>.
foafcurrentProject :: ScopedName

-- | <tt>foaf:depiction</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_depiction</a>.
foafdepiction :: ScopedName

-- | <tt>foaf:depicts</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_depicts</a>.
foafdepicts :: ScopedName

-- | <tt>foaf:dnaChecksum</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_dnaChecksum</a>.
foafdnaChecksum :: ScopedName

-- | <tt>foaf:familyName</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_familyName</a>.
foaffamilyName :: ScopedName

-- | <tt>foaf:family_name</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_family_name</a>.
foaffamily_name :: ScopedName

-- | <tt>foaf:firstName</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_firstName</a>.
foaffirstName :: ScopedName

-- | <tt>foaf:focus</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_focus</a>.
foaffocus :: ScopedName

-- | <tt>foaf:fundedBy</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_fundedBy</a>.
foaffundedBy :: ScopedName

-- | <tt>foaf:geekcode</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_geekcode</a>.
foafgeekcode :: ScopedName

-- | <tt>foaf:gender</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_gender</a>.
foafgender :: ScopedName

-- | <tt>foaf:givenName</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_givenName</a>.
foafgivenName :: ScopedName

-- | <tt>foaf:givenname</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_givenname</a>.
foafgivenname :: ScopedName

-- | <tt>foaf:holdsAccount</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_holdsAccount</a>.
foafholdsAccount :: ScopedName

-- | <tt>foaf:homepage</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_homepage</a>.
foafhomepage :: ScopedName

-- | <tt>foaf:icqChatID</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_icqChatID</a>.
foaficqChatID :: ScopedName

-- | <tt>foaf:img</tt> from <a>http://xmlns.com/foaf/spec/#term_img</a>.
foafimg :: ScopedName

-- | <tt>foaf:interest</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_interest</a>.
foafinterest :: ScopedName

-- | <tt>foaf:isPrimaryTopicOf</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_isPrimaryTopicOf</a>.
foafisPrimaryTopicOf :: ScopedName

-- | <tt>foaf:jabberID</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_jabberID</a>.
foafjabberID :: ScopedName

-- | <tt>foaf:knows</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_knows</a>.
foafknows :: ScopedName

-- | <tt>foaf:lastName</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_lastName</a>.
foaflastName :: ScopedName

-- | <tt>foaf:logo</tt> from <a>http://xmlns.com/foaf/spec/#term_logo</a>.
foaflogo :: ScopedName

-- | <tt>foaf:made</tt> from <a>http://xmlns.com/foaf/spec/#term_made</a>.
foafmade :: ScopedName

-- | <tt>foaf:maker</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_maker</a>.
foafmaker :: ScopedName

-- | <tt>foaf:mbox</tt> from <a>http://xmlns.com/foaf/spec/#term_mbox</a>.
foafmbox :: ScopedName

-- | <tt>foaf:mbox_sha1sum</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_mbox_sha1sum</a>.
foafmbox_sha1sum :: ScopedName

-- | <tt>foaf:member</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_member</a>.
foafmember :: ScopedName

-- | <tt>foaf:membershipClass</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_membershipClass</a>.
foafmembershipClass :: ScopedName

-- | <tt>foaf:msnChatID</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_msnChatID</a>.
foafmsnChatID :: ScopedName

-- | <tt>foaf:myersBriggs</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_myersBriggs</a>.
foafmyersBriggs :: ScopedName

-- | <tt>foaf:name</tt> from <a>http://xmlns.com/foaf/spec/#term_name</a>.
foafname :: ScopedName

-- | <tt>foaf:nick</tt> from <a>http://xmlns.com/foaf/spec/#term_nick</a>.
foafnick :: ScopedName

-- | <tt>foaf:openid</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_openid</a>.
foafopenid :: ScopedName

-- | <tt>foaf:page</tt> from <a>http://xmlns.com/foaf/spec/#term_page</a>.
foafpage :: ScopedName

-- | <tt>foaf:pastProject</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_pastProject</a>.
foafpastProject :: ScopedName

-- | <tt>foaf:phone</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_phone</a>.
foafphone :: ScopedName

-- | <tt>foaf:plan</tt> from <a>http://xmlns.com/foaf/spec/#term_plan</a>.
foafplan :: ScopedName

-- | <tt>foaf:primaryTopic</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_primaryTopic</a>.
foafprimaryTopic :: ScopedName

-- | <tt>foaf:publications</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_publications</a>.
foafpublications :: ScopedName

-- | <tt>foaf:schoolHomepage</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_schoolHomepage</a>.
foafschoolHomepage :: ScopedName

-- | <tt>foaf:sha1</tt> from <a>http://xmlns.com/foaf/spec/#term_sha1</a>.
foafsha1 :: ScopedName

-- | <tt>foaf:skypeID</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_skypeID</a>.
foafskypeID :: ScopedName

-- | <tt>foaf:status</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_status</a>.
foafstatus :: ScopedName

-- | <tt>foaf:surname</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_surname</a>.
foafsurname :: ScopedName

-- | <tt>foaf:theme</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_theme</a>.
foaftheme :: ScopedName

-- | <tt>foaf:thumbnail</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_thumbnail</a>.
foafthumbnail :: ScopedName

-- | <tt>foaf:tipjar</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_tipjar</a>.
foaftipjar :: ScopedName

-- | <tt>foaf:title</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_title</a>.
foaftitle :: ScopedName

-- | <tt>foaf:topic</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_topic</a>.
foaftopic :: ScopedName

-- | <tt>foaf:topic_interest</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_topic_interest</a>.
foaftopic_interest :: ScopedName

-- | <tt>foaf:weblog</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_weblog</a>.
foafweblog :: ScopedName

-- | <tt>foaf:workInfoHomepage</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_workInfoHomepage</a>.
foafworkInfoHomepage :: ScopedName

-- | <tt>foaf:workplaceHomepage</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_workplaceHomepage</a>.
foafworkplaceHomepage :: ScopedName

-- | <tt>foaf:yahooChatID</tt> from
--   <a>http://xmlns.com/foaf/spec/#term_yahooChatID</a>.
foafyahooChatID :: ScopedName


-- | This module defines some commonly used vocabulary terms from the Geo
--   vocabulary (<a>http://www.w3.org/2003/01/geo/</a>, WGS84 Geo
--   Positioning: an RDF vocabulary).
--   
--   Note that unlike some of the existing vocabularies in Swish, the Geo
--   one matches the case and spelling of the RDF terms; so we use
--   <a>geolat</a> rather than <tt>geoLat</tt>.
module Swish.RDF.Vocabulary.Geo

-- | Maps <tt>geo</tt> to <a>http://www.w3.org/2003/01/geo/wgs84_pos#</a>.
namespaceGEO :: Namespace

-- | <tt>geo:SpatialThing</tt>.
geoSpatialThing :: ScopedName

-- | <tt>geo:Point</tt>.
geoPoint :: ScopedName

-- | <tt>geo:location</tt>.
geolocation :: ScopedName

-- | <tt>geo:lat</tt>.
geolat :: ScopedName

-- | <tt>geo:long</tt>.
geolong :: ScopedName

-- | <tt>geo:lat_long</tt> (it is suggested that this not be used when
--   generating RDF statements).
geolat_long :: ScopedName


-- | This module defines some vocabulary terms from the Provenance Ontology
--   <a>http://www.w3.org/TR/prov-o/</a> by the W3C Provenance Working
--   Group (<a>http://www.w3.org/2011/prov/wiki/Main_Page/</a>). This is
--   <i>experimental</i> since the Ontology is still a Working Draft.
module Swish.RDF.Vocabulary.Provenance

-- | Maps <tt>prov</tt> to <a>http://www.w3.org/ns/prov-o/</a>.
namespacePROV :: Namespace

-- | <tt>prov:Activity</tt> from
--   <a>http://www.w3.org/TR/prov-o/#activity</a>.
provActivity :: ScopedName

-- | <tt>prov:Agent</tt> from <a>http://www.w3.org/TR/prov-o/#agent</a>.
provAgent :: ScopedName

-- | <tt>prov:Control</tt> from
--   <a>http://www.w3.org/TR/prov-o/#control</a>.
provControl :: ScopedName

-- | <tt>prov:Entity</tt> from <a>http://www.w3.org/TR/prov-o/#entity</a>.
provEntity :: ScopedName

-- | <tt>prov:Generation</tt> from
--   <a>http://www.w3.org/TR/prov-o/#generation</a>.
provGeneration :: ScopedName

-- | <tt>prov:Location</tt> from
--   <a>http://www.w3.org/TR/prov-o/#location</a>.
provLocation :: ScopedName

-- | <tt>prov:Participation</tt> from
--   <a>http://www.w3.org/TR/prov-o/#participation</a>.
provParticipation :: ScopedName

-- | <tt>prov:ProvenanceContainer</tt> from
--   <a>http://www.w3.org/TR/prov-o/#provenancecontainer</a>.
provProvenanceContainer :: ScopedName

-- | <tt>prov:QualifiedInvolvement</tt> from
--   <a>http://www.w3.org/TR/prov-o/#qualifiedinvolvement</a>.
provQualifiedInvolvement :: ScopedName

-- | <tt>prov:Recipe</tt> from <a>http://www.w3.org/TR/prov-o/#recipe</a>.
provRecipe :: ScopedName

-- | <tt>prov:Role</tt> from <a>http://www.w3.org/TR/prov-o/#role</a>.
provRole :: ScopedName

-- | <tt>prov:Usage</tt> from <a>http://www.w3.org/TR/prov-o/#usage</a>.
provUsage :: ScopedName

-- | <tt>prov:dependedOn</tt> from
--   <a>http://www.w3.org/TR/prov-o/#dependedon</a>.
provdependedOn :: ScopedName

-- | <tt>prov:endedAt</tt> from
--   <a>http://www.w3.org/TR/prov-o/#endedat</a>.
provendedAt :: ScopedName

-- | <tt>prov:hadLocation</tt> from
--   <a>http://www.w3.org/TR/prov-o/#hadlocation</a>.
provhadLocation :: ScopedName

-- | <tt>prov:hadOriginalSource</tt> from
--   <a>http://www.w3.org/TR/prov-o/#hadoriginalsource</a>.
provhadOriginalSource :: ScopedName

-- | <tt>prov:hadParticipant</tt> from
--   <a>http://www.w3.org/TR/prov-o/#hadparticipant</a>.
provhadParticipant :: ScopedName

-- | <tt>prov:hadQualifiedControl</tt> from
--   <a>http://www.w3.org/TR/prov-o/#hadqualifiedcontrol</a>.
provhadQualifiedControl :: ScopedName

-- | <tt>prov:hadQualifiedEntity</tt> from
--   <a>http://www.w3.org/TR/prov-o/#hadqualifiedentity</a>.
provhadQualifiedEntity :: ScopedName

-- | <tt>prov:hadQualifiedGeneration</tt> from
--   <a>http://www.w3.org/TR/prov-o/#hadqualifiedgeneration</a>.
provhadQualifiedGeneration :: ScopedName

-- | <tt>prov:hadQualifiedParticipation</tt> from
--   <a>http://www.w3.org/TR/prov-o/#hadqualifiedparticipation</a>.
provhadQualifiedParticipation :: ScopedName

-- | <tt>prov:hadQualifiedUsage</tt> from
--   <a>http://www.w3.org/TR/prov-o/#hadqualifiedusage</a>.
provhadQualifiedUsage :: ScopedName

-- | <tt>prov:hadRecipe</tt> from
--   <a>http://www.w3.org/TR/prov-o/#hadrecipe</a>.
provhadRecipe :: ScopedName

-- | <tt>prov:hadRole</tt> from
--   <a>http://www.w3.org/TR/prov-o/#hadrole</a>.
provhadRole :: ScopedName

-- | <tt>prov:hadTemporalValue</tt> from
--   <a>http://www.w3.org/TR/prov-o/#hadtemporalvalue</a>.
provhadTemporalValue :: ScopedName

-- | <tt>prov:startedAt</tt> from
--   <a>http://www.w3.org/TR/prov-o/#startedat</a>.
provstartedAt :: ScopedName

-- | <tt>prov:used</tt> from <a>http://www.w3.org/TR/prov-o/#used</a>.
provused :: ScopedName

-- | <tt>prov:wasAttributedTo</tt> from
--   <a>http://www.w3.org/TR/prov-o/#wasattributedto</a>.
provwasAttributedTo :: ScopedName

-- | <tt>prov:wasComplementOf</tt> from
--   <a>http://www.w3.org/TR/prov-o/#wascomplementof</a>.
provwasComplementOf :: ScopedName

-- | <tt>prov:wasControlledBy</tt> from
--   <a>http://www.w3.org/TR/prov-o/#wascontrolledby</a>.
provwasControlledBy :: ScopedName

-- | <tt>prov:wasDerivedFrom</tt> from
--   <a>http://www.w3.org/TR/prov-o/#wasderivedfrom</a>.
provwasDerivedFrom :: ScopedName

-- | <tt>prov:wasEventuallyDerivedFrom</tt> from
--   <a>http://www.w3.org/TR/prov-o/#waseventuallyderivedfrom</a>.
provwasEventuallyDerivedFrom :: ScopedName

-- | <tt>prov:wasGeneratedAt</tt> from
--   <a>http://www.w3.org/TR/prov-o/#wasgeneratedat</a>.
provwasGeneratedAt :: ScopedName

-- | <tt>prov:wasGeneratedBy</tt> from
--   <a>http://www.w3.org/TR/prov-o/#wasgeneratedby</a>.
provwasGeneratedBy :: ScopedName

-- | <tt>prov:wasInformedBy</tt> from
--   <a>http://www.w3.org/TR/prov-o/#wasinformedby</a>.
provwasInformedBy :: ScopedName

-- | <tt>prov:wasQuoteOf</tt> from
--   <a>http://www.w3.org/TR/prov-o/#wasquoteof</a>.
provwasQuoteOf :: ScopedName

-- | <tt>prov:wasRevisionOf</tt> from
--   <a>http://www.w3.org/TR/prov-o/#wasrevisionof</a>.
provwasRevisionOf :: ScopedName

-- | <tt>prov:wasScheduledAfter</tt> from
--   <a>http://www.w3.org/TR/prov-o/#wasscheduledafter</a>.
provwasScheduledAfter :: ScopedName

-- | <tt>prov:wasSummaryOf</tt> from
--   <a>http://www.w3.org/TR/prov-o/#wassummaryof</a>.
provwasSummaryOf :: ScopedName


-- | This module defines some commonly used vocabulary terms from the SIOC
--   project (<a>http://sioc-project.org/</a>).
module Swish.RDF.Vocabulary.SIOC

-- | Maps <tt>sioc</tt> to <a>http://rdfs.org/sioc/ns#</a>.
namespaceSIOC :: Namespace

-- | <tt>sioc:Community</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_Community</a>.
siocCommunity :: ScopedName

-- | <tt>sioc:Container</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_Container</a>.
siocContainer :: ScopedName

-- | <tt>sioc:Forum</tt> from <a>http://rdfs.org/sioc/spec/#term_Forum</a>.
siocForum :: ScopedName

-- | <tt>sioc:Item</tt> from <a>http://rdfs.org/sioc/spec/#term_Item</a>.
siocItem :: ScopedName

-- | <tt>sioc:Post</tt> from <a>http://rdfs.org/sioc/spec/#term_Post</a>.
siocPost :: ScopedName

-- | <tt>sioc:Role</tt> from <a>http://rdfs.org/sioc/spec/#term_Role</a>.
siocRole :: ScopedName

-- | <tt>sioc:Site</tt> from <a>http://rdfs.org/sioc/spec/#term_Site</a>.
siocSite :: ScopedName

-- | <tt>sioc:Space</tt> from <a>http://rdfs.org/sioc/spec/#term_Space</a>.
siocSpace :: ScopedName

-- | <tt>sioc:Thread</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_Thread</a>.
siocThread :: ScopedName

-- | <tt>sioc:UserAccount</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_UserAccount</a>.
siocUserAccount :: ScopedName

-- | <tt>sioc:Usergroup</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_Usergroup</a>.
siocUsergroup :: ScopedName

-- | <tt>sioc:about</tt> from <a>http://rdfs.org/sioc/spec/#term_about</a>.
siocabout :: ScopedName

-- | <tt>sioc:account_of</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_account_of</a>.
siocaccount_of :: ScopedName

-- | <tt>sioc:addressed_to</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_addressed_to</a>.
siocaddressed_to :: ScopedName

-- | <tt>sioc:administrator_of</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_administrator_of</a>.
siocadministrator_of :: ScopedName

-- | <tt>sioc:attachment</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_attachment</a>.
siocattachment :: ScopedName

-- | <tt>sioc:avatar</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_avatar</a>.
siocavatar :: ScopedName

-- | <tt>sioc:container_of</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_container_of</a>.
sioccontainer_of :: ScopedName

-- | <tt>sioc:content</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_content</a>.
sioccontent :: ScopedName

-- | <tt>sioc:creator_of</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_creator_of</a>.
sioccreator_of :: ScopedName

-- | <tt>sioc:earlier_version</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_earlier_version</a>.
siocearlier_version :: ScopedName

-- | <tt>sioc:email</tt> from <a>http://rdfs.org/sioc/spec/#term_email</a>.
siocemail :: ScopedName

-- | <tt>sioc:email_sha1</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_email_sha1</a>.
siocemail_sha1 :: ScopedName

-- | <tt>sioc:embeds_knowledge</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_embeds_knowledge</a>.
siocembeds_knowledge :: ScopedName

-- | <tt>sioc:feed</tt> from <a>http://rdfs.org/sioc/spec/#term_feed</a>.
siocfeed :: ScopedName

-- | <tt>sioc:follows</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_follows</a>.
siocfollows :: ScopedName

-- | <tt>sioc:function_of</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_function_of</a>.
siocfunction_of :: ScopedName

-- | <tt>sioc:has_administrator</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_has_administrator</a>.
siochas_administrator :: ScopedName

-- | <tt>sioc:has_container</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_has_container</a>.
siochas_container :: ScopedName

-- | <tt>sioc:has_creator</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_has_creator</a>.
siochas_creator :: ScopedName

-- | <tt>sioc:has_discussion</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_has_discussion</a>.
siochas_discussion :: ScopedName

-- | <tt>sioc:has_function</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_has_function</a>.
siochas_function :: ScopedName

-- | <tt>sioc:has_host</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_has_host</a>.
siochas_host :: ScopedName

-- | <tt>sioc:has_member</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_has_member</a>.
siochas_member :: ScopedName

-- | <tt>sioc:has_moderator</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_has_moderator</a>.
siochas_moderator :: ScopedName

-- | <tt>sioc:has_modifier</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_has_modifier</a>.
siochas_modifier :: ScopedName

-- | <tt>sioc:has_owner</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_has_owner</a>.
siochas_owner :: ScopedName

-- | <tt>sioc:has_parent</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_has_parent</a>.
siochas_parent :: ScopedName

-- | <tt>sioc:has_reply</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_has_reply</a>.
siochas_reply :: ScopedName

-- | <tt>sioc:has_scope</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_has_scope</a>.
siochas_scope :: ScopedName

-- | <tt>sioc:has_space</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_has_space</a>.
siochas_space :: ScopedName

-- | <tt>sioc:has_subscriber</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_has_subscriber</a>.
siochas_subscriber :: ScopedName

-- | <tt>sioc:has_usergroup</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_has_usergroup</a>.
siochas_usergroup :: ScopedName

-- | <tt>sioc:host_of</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_host_of</a>.
siochost_of :: ScopedName

-- | <tt>sioc:id</tt> from <a>http://rdfs.org/sioc/spec/#term_id</a>.
siocid :: ScopedName

-- | <tt>sioc:ip_address</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_ip_address</a>.
siocip_address :: ScopedName

-- | <tt>sioc:last_activity_date</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_last_activity_date</a>.
sioclast_activity_date :: ScopedName

-- | <tt>sioc:last_item_date</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_last_item_date</a>.
sioclast_item_date :: ScopedName

-- | <tt>sioc:last_reply_date</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_last_reply_date</a>.
sioclast_reply_date :: ScopedName

-- | <tt>sioc:later_version</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_later_version</a>.
sioclater_version :: ScopedName

-- | <tt>sioc:latest_version</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_latest_version</a>.
sioclatest_version :: ScopedName

-- | <tt>sioc:link</tt> from <a>http://rdfs.org/sioc/spec/#term_link</a>.
sioclink :: ScopedName

-- | <tt>sioc:links_to</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_links_to</a>.
sioclinks_to :: ScopedName

-- | <tt>sioc:member_of</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_member_of</a>.
siocmember_of :: ScopedName

-- | <tt>sioc:moderator_of</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_moderator_of</a>.
siocmoderator_of :: ScopedName

-- | <tt>sioc:modifier_of</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_modifier_of</a>.
siocmodifier_of :: ScopedName

-- | <tt>sioc:name</tt> from <a>http://rdfs.org/sioc/spec/#term_name</a>.
siocname :: ScopedName

-- | <tt>sioc:next_by_date</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_next_by_date</a>.
siocnext_by_date :: ScopedName

-- | <tt>sioc:next_version</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_next_version</a>.
siocnext_version :: ScopedName

-- | <tt>sioc:note</tt> from <a>http://rdfs.org/sioc/spec/#term_note</a>.
siocnote :: ScopedName

-- | <tt>sioc:num_authors</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_num_authors</a>.
siocnum_authors :: ScopedName

-- | <tt>sioc:num_items</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_num_items</a>.
siocnum_items :: ScopedName

-- | <tt>sioc:num_replies</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_num_replies</a>.
siocnum_replies :: ScopedName

-- | <tt>sioc:num_threads</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_num_threads</a>.
siocnum_threads :: ScopedName

-- | <tt>sioc:num_views</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_num_views</a>.
siocnum_views :: ScopedName

-- | <tt>sioc:owner_of</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_owner_of</a>.
siocowner_of :: ScopedName

-- | <tt>sioc:parent_of</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_parent_of</a>.
siocparent_of :: ScopedName

-- | <tt>sioc:previous_by_date</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_previous_by_date</a>.
siocprevious_by_date :: ScopedName

-- | <tt>sioc:previous_version</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_previous_version</a>.
siocprevious_version :: ScopedName

-- | <tt>sioc:related_to</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_related_to</a>.
siocrelated_to :: ScopedName

-- | <tt>sioc:reply_of</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_reply_of</a>.
siocreply_of :: ScopedName

-- | <tt>sioc:scope_of</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_scope_of</a>.
siocscope_of :: ScopedName

-- | <tt>sioc:sibling</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_sibling</a>.
siocsibling :: ScopedName

-- | <tt>sioc:space_of</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_space_of</a>.
siocspace_of :: ScopedName

-- | <tt>sioc:subscriber_of</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_subscriber_of</a>.
siocsubscriber_of :: ScopedName

-- | <tt>sioc:topic</tt> from <a>http://rdfs.org/sioc/spec/#term_topic</a>.
sioctopic :: ScopedName

-- | <tt>sioc:usergroup_of</tt> from
--   <a>http://rdfs.org/sioc/spec/#term_usergroup_of</a>.
siocusergroup_of :: ScopedName
