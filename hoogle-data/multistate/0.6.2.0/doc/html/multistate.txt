-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | like mtl's ReaderT / WriterT / StateT, but more than one
contained value/type.
--   
--   When using multiple Read/Write/State transformers in the same monad
--   stack, it becomes necessary to lift the operations in order to affect
--   a specific transformer. Using heterogeneous lists (and all kinds of
--   GHC extensions magic), this package provides transformers that remove
--   that necessity: MultiReaderT/MultiWriterT/MultiStateT/MultiRWST can
--   contain a heterogeneous list of values.
--   
--   See the <a>README</a> for a longer description.
--   
--   The latest published version contains some breaking changes. Please
--   complain if this causes problems (for future consideration).
@package multistate
@version 0.6.2.0


-- | The multi-valued version of mtl's MonadWriter
module Control.Monad.Trans.MultiWriter.Class
class (Monad m, Monoid a) => MonadMultiWriter a m
mTell :: MonadMultiWriter a m => a -> m ()
instance [overlap ok] (MonadTrans t, Monad (t m), MonadMultiWriter a m) => MonadMultiWriter a (t m)


-- | The multi-valued version of mtl's MonadReader
module Control.Monad.Trans.MultiReader.Class

-- | All methods must be defined.
--   
--   The idea is: Any monad stack is instance of <tt>MonadMultiReader
--   a</tt>, iff the stack contains a <tt>MultiReaderT x</tt> with <i>a</i>
--   element of <i>x</i>.
class Monad m => MonadMultiReader a m
mAsk :: MonadMultiReader a m => m a
instance [overlap ok] (MonadTrans t, Monad (t m), MonadMultiReader a m) => MonadMultiReader a (t m)


-- | The multi-valued version of mtl's MonadState
module Control.Monad.Trans.MultiState.Class

-- | All methods must be defined.
--   
--   The idea is: Any monad stack is instance of <tt>MonadMultiState
--   a</tt>, iff the stack contains a <tt>MultiStateT x</tt> with <i>a</i>
--   element of <i>x</i>.
class Monad m => MonadMultiState a m
mSet :: MonadMultiState a m => a -> m ()
mGet :: MonadMultiState a m => m a
instance [overlap ok] (MonadTrans t, Monad (t m), MonadMultiState a m) => MonadMultiState a (t m)


-- | A GADT HList implementation
--   
--   Probably exists somewhere else already, but why add a dependency for
--   something so simple.
module Data.HList.HList
data HList :: [*] -> *
HNil :: HList []
(:+:) :: x -> HList xs -> HList (x : xs)
hAppend :: HList ts1 -> HList ts2 -> HList (Append ts1 ts2)
class HInit (l1 :: [*])
hInit :: HInit l1 => Proxy l2 -> HList (Append l1 l2) -> HList l1
hSplit :: HInit l1 => HList (Append l1 l2) -> (HList l1, HList l2)
instance [overlap ok] HInit l1 => HInit (x : l1)
instance [overlap ok] HInit '[]
instance [overlap ok] (Eq x, Eq (HList xs)) => Eq (HList (x : xs))
instance [overlap ok] Eq (HList '[])
instance [overlap ok] (Monoid x, Monoid (HList xs)) => Monoid (HList (x : xs))
instance [overlap ok] Monoid (HList '[])
instance [overlap ok] (Show a, Show (HList b)) => Show (HList (a : b))
instance [overlap ok] Show (HList '[])


-- | Class to provide type-driven access to elements of a HList
module Data.HList.ContainsType
class ContainsType a c
setHListElem :: ContainsType a c => a -> HList c -> HList c
getHListElem :: ContainsType a c => HList c -> a
instance [overlap ok] ContainsType a xs => ContainsType a (x : xs)
instance [overlap ok] ContainsType a (a : xs)


-- | The multi-valued version of mtl's State / StateT
module Control.Monad.Trans.MultiState.Lazy

-- | A State transformer monad patameterized by:
--   
--   <ul>
--   <li>x - The list of types constituting the state,</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   <a>MultiStateT</a> corresponds to mtl's <a>StateT</a>, but can contain
--   a heterogenous list of types.
--   
--   This heterogenous list is represented using Types.Data.List, i.e:
--   
--   <ul>
--   <li><tt>'[]</tt> - The empty list,</li>
--   <li><tt>a ': b</tt> - A list where <tt><i>a</i></tt> is an arbitrary
--   type and <tt><i>b</i></tt> is the rest list.</li>
--   </ul>
--   
--   For example,
--   
--   <pre>
--   MultiStateT '[Int, Bool] :: (* -&gt; *) -&gt; (* -&gt; *)
--   </pre>
--   
--   is a State wrapper containing the types [Int, Bool].
newtype MultiStateT x m a
MultiStateT :: StateT (HList x) m a -> MultiStateT x m a
runMultiStateTRaw :: MultiStateT x m a -> StateT (HList x) m a

-- | A MultiState transformer carrying an empty state.
type MultiStateTNull = MultiStateT []

-- | A state monad parameterized by the list of types x of the state to
--   carry.
--   
--   Similar to <tt>State s = StateT s Identity</tt>
type MultiState x = MultiStateT x Identity

-- | All methods must be defined.
--   
--   The idea is: Any monad stack is instance of <tt>MonadMultiState
--   a</tt>, iff the stack contains a <tt>MultiStateT x</tt> with <i>a</i>
--   element of <i>x</i>.
class Monad m => MonadMultiState a m
mSet :: MonadMultiState a m => a -> m ()
mGet :: MonadMultiState a m => m a
runMultiStateT :: Functor m => HList s -> MultiStateT s m a -> m (a, HList s)
runMultiStateTAS :: Functor m => HList s -> MultiStateT s m a -> m (a, HList s)
runMultiStateTSA :: Monad m => HList s -> MultiStateT s m a -> m (HList s, a)
runMultiStateTA :: Monad m => HList s -> MultiStateT s m a -> m a
runMultiStateTS :: Monad m => HList s -> MultiStateT s m a -> m (HList s)
runMultiStateT_ :: Functor m => HList s -> MultiStateT s m a -> m ()
runMultiStateTNil :: Monad m => MultiStateT [] m a -> m a
runMultiStateTNil_ :: Functor m => MultiStateT [] m a -> m ()
withMultiState :: Monad m => s -> MultiStateT (s : ss) m a -> MultiStateT ss m (a, s)
withMultiStateAS :: Monad m => s -> MultiStateT (s : ss) m a -> MultiStateT ss m (a, s)
withMultiStateSA :: Monad m => s -> MultiStateT (s : ss) m a -> MultiStateT ss m (s, a)
withMultiStateA :: Monad m => s -> MultiStateT (s : ss) m a -> MultiStateT ss m a
withMultiStateS :: Monad m => s -> MultiStateT (s : ss) m a -> MultiStateT ss m s
withMultiState_ :: (Functor m, Monad m) => s -> MultiStateT (s : ss) m a -> MultiStateT ss m ()
withMultiStates :: Monad m => HList s1 -> MultiStateT (Append s1 s2) m a -> MultiStateT s2 m (a, HList s1)
withMultiStatesAS :: Monad m => HList s1 -> MultiStateT (Append s1 s2) m a -> MultiStateT s2 m (a, HList s1)
withMultiStatesSA :: Monad m => HList s1 -> MultiStateT (Append s1 s2) m a -> MultiStateT s2 m (HList s1, a)
withMultiStatesA :: Monad m => HList s1 -> MultiStateT (Append s1 s2) m a -> MultiStateT s2 m a
withMultiStatesS :: Monad m => HList s1 -> MultiStateT (Append s1 s2) m a -> MultiStateT s2 m (HList s1)
withMultiStates_ :: (Functor m, Monad m) => HList s1 -> MultiStateT (Append s1 s2) m a -> MultiStateT s2 m ()
inflateState :: (Monad m, ContainsType s ss) => StateT s m a -> MultiStateT ss m a
inflateReader :: (Monad m, ContainsType r ss) => ReaderT r m a -> MultiStateT ss m a
inflateWriter :: (Monad m, ContainsType w ss, Monoid w) => WriterT w m a -> MultiStateT ss m a

-- | Map both the return value and the state of a computation using the
--   given function.
mapMultiStateT :: (m (a, HList w) -> m' (a', HList w)) -> MultiStateT w m a -> MultiStateT w m' a'

-- | A raw extractor of the contained HList (i.e. the complete state).
mGetRaw :: Monad m => MultiStateT a m (HList a)
mPutRaw :: Monad m => HList s -> MultiStateT s m ()
instance [overlap ok] MonadWriter w m => MonadWriter w (MultiStateT c m)
instance [overlap ok] MonadState s m => MonadState s (MultiStateT c m)
instance [overlap ok] MonadFix m => MonadFix (MultiStateT s m)
instance [overlap ok] (Monad m, ContainsType a c) => MonadMultiState a (MultiStateT c m)
instance [overlap ok] MonadTrans (MultiStateT x)
instance [overlap ok] Monad m => Monad (MultiStateT x m)
instance [overlap ok] (Applicative m, Monad m) => Applicative (MultiStateT x m)
instance [overlap ok] Functor f => Functor (MultiStateT x f)


-- | The multi-valued version of mtl's State / StateT / MonadState

-- | <i>Deprecated: Use Control.Monad.Trans.MultiState instead</i>
module Control.Monad.MultiState

-- | A State transformer monad patameterized by:
--   
--   <ul>
--   <li>x - The list of types constituting the state,</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   <a>MultiStateT</a> corresponds to mtl's <a>StateT</a>, but can contain
--   a heterogenous list of types.
--   
--   This heterogenous list is represented using Types.Data.List, i.e:
--   
--   <ul>
--   <li><tt>'[]</tt> - The empty list,</li>
--   <li><tt>a ': b</tt> - A list where <tt><i>a</i></tt> is an arbitrary
--   type and <tt><i>b</i></tt> is the rest list.</li>
--   </ul>
--   
--   For example,
--   
--   <pre>
--   MultiStateT '[Int, Bool] :: (* -&gt; *) -&gt; (* -&gt; *)
--   </pre>
--   
--   is a State wrapper containing the types [Int, Bool].
newtype MultiStateT x m a
MultiStateT :: StateT (HList x) m a -> MultiStateT x m a
runMultiStateTRaw :: MultiStateT x m a -> StateT (HList x) m a

-- | A MultiState transformer carrying an empty state.
type MultiStateTNull = MultiStateT []

-- | A state monad parameterized by the list of types x of the state to
--   carry.
--   
--   Similar to <tt>State s = StateT s Identity</tt>
type MultiState x = MultiStateT x Identity

-- | All methods must be defined.
--   
--   The idea is: Any monad stack is instance of <tt>MonadMultiState
--   a</tt>, iff the stack contains a <tt>MultiStateT x</tt> with <i>a</i>
--   element of <i>x</i>.
class Monad m => MonadMultiState a m
mSet :: MonadMultiState a m => a -> m ()
mGet :: MonadMultiState a m => m a
runMultiStateT :: Functor m => HList s -> MultiStateT s m a -> m (a, HList s)
runMultiStateTAS :: Functor m => HList s -> MultiStateT s m a -> m (a, HList s)
runMultiStateTSA :: Monad m => HList s -> MultiStateT s m a -> m (HList s, a)
runMultiStateTA :: Monad m => HList s -> MultiStateT s m a -> m a
runMultiStateTS :: Monad m => HList s -> MultiStateT s m a -> m (HList s)
runMultiStateT_ :: Functor m => HList s -> MultiStateT s m a -> m ()
runMultiStateTNil :: Monad m => MultiStateT [] m a -> m a
runMultiStateTNil_ :: Functor m => MultiStateT [] m a -> m ()
withMultiState :: Monad m => s -> MultiStateT (s : ss) m a -> MultiStateT ss m (a, s)
withMultiStateAS :: Monad m => s -> MultiStateT (s : ss) m a -> MultiStateT ss m (a, s)
withMultiStateSA :: Monad m => s -> MultiStateT (s : ss) m a -> MultiStateT ss m (s, a)
withMultiStateA :: Monad m => s -> MultiStateT (s : ss) m a -> MultiStateT ss m a
withMultiStateS :: Monad m => s -> MultiStateT (s : ss) m a -> MultiStateT ss m s
withMultiState_ :: (Functor m, Monad m) => s -> MultiStateT (s : ss) m a -> MultiStateT ss m ()
withMultiStates :: Monad m => HList s1 -> MultiStateT (Append s1 s2) m a -> MultiStateT s2 m (a, HList s1)
withMultiStatesAS :: Monad m => HList s1 -> MultiStateT (Append s1 s2) m a -> MultiStateT s2 m (a, HList s1)
withMultiStatesSA :: Monad m => HList s1 -> MultiStateT (Append s1 s2) m a -> MultiStateT s2 m (HList s1, a)
withMultiStatesA :: Monad m => HList s1 -> MultiStateT (Append s1 s2) m a -> MultiStateT s2 m a
withMultiStatesS :: Monad m => HList s1 -> MultiStateT (Append s1 s2) m a -> MultiStateT s2 m (HList s1)
withMultiStates_ :: (Functor m, Monad m) => HList s1 -> MultiStateT (Append s1 s2) m a -> MultiStateT s2 m ()
inflateState :: (Monad m, ContainsType s ss) => StateT s m a -> MultiStateT ss m a
inflateReader :: (Monad m, ContainsType r ss) => ReaderT r m a -> MultiStateT ss m a
inflateWriter :: (Monad m, ContainsType w ss, Monoid w) => WriterT w m a -> MultiStateT ss m a

-- | Map both the return value and the state of a computation using the
--   given function.
mapMultiStateT :: (m (a, HList w) -> m' (a', HList w)) -> MultiStateT w m a -> MultiStateT w m' a'

-- | A raw extractor of the contained HList (i.e. the complete state).
mGetRaw :: Monad m => MultiStateT a m (HList a)
mPutRaw :: Monad m => HList s -> MultiStateT s m ()


-- | The multi-valued version of mtl's State / StateT / MonadState
module Control.Monad.Trans.MultiState

-- | A State transformer monad patameterized by:
--   
--   <ul>
--   <li>x - The list of types constituting the state,</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   <a>MultiStateT</a> corresponds to mtl's <a>StateT</a>, but can contain
--   a heterogenous list of types.
--   
--   This heterogenous list is represented using Types.Data.List, i.e:
--   
--   <ul>
--   <li><tt>'[]</tt> - The empty list,</li>
--   <li><tt>a ': b</tt> - A list where <tt><i>a</i></tt> is an arbitrary
--   type and <tt><i>b</i></tt> is the rest list.</li>
--   </ul>
--   
--   For example,
--   
--   <pre>
--   MultiStateT '[Int, Bool] :: (* -&gt; *) -&gt; (* -&gt; *)
--   </pre>
--   
--   is a State wrapper containing the types [Int, Bool].
newtype MultiStateT x m a
MultiStateT :: StateT (HList x) m a -> MultiStateT x m a
runMultiStateTRaw :: MultiStateT x m a -> StateT (HList x) m a

-- | A MultiState transformer carrying an empty state.
type MultiStateTNull = MultiStateT []

-- | A state monad parameterized by the list of types x of the state to
--   carry.
--   
--   Similar to <tt>State s = StateT s Identity</tt>
type MultiState x = MultiStateT x Identity

-- | All methods must be defined.
--   
--   The idea is: Any monad stack is instance of <tt>MonadMultiState
--   a</tt>, iff the stack contains a <tt>MultiStateT x</tt> with <i>a</i>
--   element of <i>x</i>.
class Monad m => MonadMultiState a m
mSet :: MonadMultiState a m => a -> m ()
mGet :: MonadMultiState a m => m a
runMultiStateT :: Functor m => HList s -> MultiStateT s m a -> m (a, HList s)
runMultiStateTAS :: Functor m => HList s -> MultiStateT s m a -> m (a, HList s)
runMultiStateTSA :: Monad m => HList s -> MultiStateT s m a -> m (HList s, a)
runMultiStateTA :: Monad m => HList s -> MultiStateT s m a -> m a
runMultiStateTS :: Monad m => HList s -> MultiStateT s m a -> m (HList s)
runMultiStateT_ :: Functor m => HList s -> MultiStateT s m a -> m ()
runMultiStateTNil :: Monad m => MultiStateT [] m a -> m a
runMultiStateTNil_ :: Functor m => MultiStateT [] m a -> m ()
withMultiState :: Monad m => s -> MultiStateT (s : ss) m a -> MultiStateT ss m (a, s)
withMultiStateAS :: Monad m => s -> MultiStateT (s : ss) m a -> MultiStateT ss m (a, s)
withMultiStateSA :: Monad m => s -> MultiStateT (s : ss) m a -> MultiStateT ss m (s, a)
withMultiStateA :: Monad m => s -> MultiStateT (s : ss) m a -> MultiStateT ss m a
withMultiStateS :: Monad m => s -> MultiStateT (s : ss) m a -> MultiStateT ss m s
withMultiState_ :: (Functor m, Monad m) => s -> MultiStateT (s : ss) m a -> MultiStateT ss m ()
withMultiStates :: Monad m => HList s1 -> MultiStateT (Append s1 s2) m a -> MultiStateT s2 m (a, HList s1)
withMultiStatesAS :: Monad m => HList s1 -> MultiStateT (Append s1 s2) m a -> MultiStateT s2 m (a, HList s1)
withMultiStatesSA :: Monad m => HList s1 -> MultiStateT (Append s1 s2) m a -> MultiStateT s2 m (HList s1, a)
withMultiStatesA :: Monad m => HList s1 -> MultiStateT (Append s1 s2) m a -> MultiStateT s2 m a
withMultiStatesS :: Monad m => HList s1 -> MultiStateT (Append s1 s2) m a -> MultiStateT s2 m (HList s1)
withMultiStates_ :: (Functor m, Monad m) => HList s1 -> MultiStateT (Append s1 s2) m a -> MultiStateT s2 m ()
inflateState :: (Monad m, ContainsType s ss) => StateT s m a -> MultiStateT ss m a
inflateReader :: (Monad m, ContainsType r ss) => ReaderT r m a -> MultiStateT ss m a
inflateWriter :: (Monad m, ContainsType w ss, Monoid w) => WriterT w m a -> MultiStateT ss m a

-- | Map both the return value and the state of a computation using the
--   given function.
mapMultiStateT :: (m (a, HList w) -> m' (a', HList w)) -> MultiStateT w m a -> MultiStateT w m' a'

-- | A raw extractor of the contained HList (i.e. the complete state).
mGetRaw :: Monad m => MultiStateT a m (HList a)
mPutRaw :: Monad m => HList s -> MultiStateT s m ()


-- | The multi-valued version of mtl's Reader / ReaderT
module Control.Monad.Trans.MultiReader.Lazy

-- | A Reader transformer monad patameterized by:
--   
--   <ul>
--   <li>x - The list of types constituting the environment / input (to be
--   read),</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   <a>MultiReaderT</a> corresponds to mtl's <a>ReaderT</a>, but can
--   contain a heterogenous list of types.
--   
--   This heterogenous list is represented using Types.Data.List, i.e:
--   
--   <ul>
--   <li><tt>'[]</tt> - The empty list,</li>
--   <li><tt>a ': b</tt> - A list where <tt><i>a</i></tt> is an arbitrary
--   type and <tt><i>b</i></tt> is the rest list.</li>
--   </ul>
--   
--   For example,
--   
--   <pre>
--   MultiReaderT '[Int, Bool] :: (* -&gt; *) -&gt; (* -&gt; *)
--   </pre>
--   
--   is a Reader transformer containing the types [Int, Bool].
newtype MultiReaderT x m a
MultiReaderT :: StateT (HList x) m a -> MultiReaderT x m a
runMultiReaderTRaw :: MultiReaderT x m a -> StateT (HList x) m a

-- | A MultiReader transformer carrying an empty state.
type MultiReaderTNull = MultiReaderT []

-- | A reader monad parameterized by the list of types x of the environment
--   / input to carry.
--   
--   Similar to <tt>Reader r = ReaderT r Identity</tt>
type MultiReader x = MultiReaderT x Identity

-- | All methods must be defined.
--   
--   The idea is: Any monad stack is instance of <tt>MonadMultiReader
--   a</tt>, iff the stack contains a <tt>MultiReaderT x</tt> with <i>a</i>
--   element of <i>x</i>.
class Monad m => MonadMultiReader a m
mAsk :: MonadMultiReader a m => m a
runMultiReaderT :: Monad m => HList r -> MultiReaderT r m a -> m a
runMultiReaderT_ :: Functor m => HList r -> MultiReaderT r m a -> m ()
runMultiReaderTNil :: Monad m => MultiReaderT [] m a -> m a
runMultiReaderTNil_ :: Functor m => MultiReaderT [] m a -> m ()
withMultiReader :: Monad m => r -> MultiReaderT (r : rs) m a -> MultiReaderT rs m a
withMultiReader_ :: (Functor m, Monad m) => r -> MultiReaderT (r : rs) m a -> MultiReaderT rs m ()
withMultiReaders :: Monad m => HList r1 -> MultiReaderT (Append r1 r2) m a -> MultiReaderT r2 m a
withMultiReaders_ :: (Functor m, Monad m) => HList r1 -> MultiReaderT (Append r1 r2) m a -> MultiReaderT r2 m ()
inflateReader :: (Monad m, ContainsType r rs) => ReaderT r m a -> MultiReaderT rs m a

-- | Map both the return value and the environment of a computation using
--   the given function.
--   
--   Note that there is a difference to mtl's ReaderT, where it is
--   <i>not</i> possible to modify the environment.
mapMultiReaderT :: (m (a, HList w) -> m' (a', HList w)) -> MultiReaderT w m a -> MultiReaderT w m' a'

-- | A raw extractor of the contained HList (i.e. the complete Reader).
mGetRaw :: Monad m => MultiReaderT a m (HList a)
mPutRaw :: Monad m => HList s -> MultiReaderT s m ()
instance [overlap ok] MonadWriter w m => MonadWriter w (MultiReaderT c m)
instance [overlap ok] MonadState s m => MonadState s (MultiReaderT c m)
instance [overlap ok] MonadFix m => MonadFix (MultiReaderT r m)
instance [overlap ok] (Monad m, ContainsType a c) => MonadMultiReader a (MultiReaderT c m)
instance [overlap ok] MonadTrans (MultiReaderT x)
instance [overlap ok] Monad m => Monad (MultiReaderT x m)
instance [overlap ok] (Applicative m, Monad m) => Applicative (MultiReaderT x m)
instance [overlap ok] Functor f => Functor (MultiReaderT x f)


-- | The multi-valued version of mtl's Reader / ReaderT / MonadReader

-- | <i>Deprecated: Use Control.Monad.Trans.MultiReader instead</i>
module Control.Monad.MultiReader

-- | A Reader transformer monad patameterized by:
--   
--   <ul>
--   <li>x - The list of types constituting the environment / input (to be
--   read),</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   <a>MultiReaderT</a> corresponds to mtl's <a>ReaderT</a>, but can
--   contain a heterogenous list of types.
--   
--   This heterogenous list is represented using Types.Data.List, i.e:
--   
--   <ul>
--   <li><tt>'[]</tt> - The empty list,</li>
--   <li><tt>a ': b</tt> - A list where <tt><i>a</i></tt> is an arbitrary
--   type and <tt><i>b</i></tt> is the rest list.</li>
--   </ul>
--   
--   For example,
--   
--   <pre>
--   MultiReaderT '[Int, Bool] :: (* -&gt; *) -&gt; (* -&gt; *)
--   </pre>
--   
--   is a Reader transformer containing the types [Int, Bool].
newtype MultiReaderT x m a
MultiReaderT :: StateT (HList x) m a -> MultiReaderT x m a
runMultiReaderTRaw :: MultiReaderT x m a -> StateT (HList x) m a

-- | A MultiReader transformer carrying an empty state.
type MultiReaderTNull = MultiReaderT []

-- | A reader monad parameterized by the list of types x of the environment
--   / input to carry.
--   
--   Similar to <tt>Reader r = ReaderT r Identity</tt>
type MultiReader x = MultiReaderT x Identity

-- | All methods must be defined.
--   
--   The idea is: Any monad stack is instance of <tt>MonadMultiReader
--   a</tt>, iff the stack contains a <tt>MultiReaderT x</tt> with <i>a</i>
--   element of <i>x</i>.
class Monad m => MonadMultiReader a m
mAsk :: MonadMultiReader a m => m a
runMultiReaderT :: Monad m => HList r -> MultiReaderT r m a -> m a
runMultiReaderT_ :: Functor m => HList r -> MultiReaderT r m a -> m ()
runMultiReaderTNil :: Monad m => MultiReaderT [] m a -> m a
runMultiReaderTNil_ :: Functor m => MultiReaderT [] m a -> m ()
withMultiReader :: Monad m => r -> MultiReaderT (r : rs) m a -> MultiReaderT rs m a
withMultiReader_ :: (Functor m, Monad m) => r -> MultiReaderT (r : rs) m a -> MultiReaderT rs m ()
withMultiReaders :: Monad m => HList r1 -> MultiReaderT (Append r1 r2) m a -> MultiReaderT r2 m a
withMultiReaders_ :: (Functor m, Monad m) => HList r1 -> MultiReaderT (Append r1 r2) m a -> MultiReaderT r2 m ()
inflateReader :: (Monad m, ContainsType r rs) => ReaderT r m a -> MultiReaderT rs m a

-- | Map both the return value and the environment of a computation using
--   the given function.
--   
--   Note that there is a difference to mtl's ReaderT, where it is
--   <i>not</i> possible to modify the environment.
mapMultiReaderT :: (m (a, HList w) -> m' (a', HList w)) -> MultiReaderT w m a -> MultiReaderT w m' a'

-- | A raw extractor of the contained HList (i.e. the complete Reader).
mGetRaw :: Monad m => MultiReaderT a m (HList a)
mPutRaw :: Monad m => HList s -> MultiReaderT s m ()


-- | The multi-valued version of mtl's Reader / ReaderT / MonadReader
module Control.Monad.Trans.MultiReader

-- | A Reader transformer monad patameterized by:
--   
--   <ul>
--   <li>x - The list of types constituting the environment / input (to be
--   read),</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   <a>MultiReaderT</a> corresponds to mtl's <a>ReaderT</a>, but can
--   contain a heterogenous list of types.
--   
--   This heterogenous list is represented using Types.Data.List, i.e:
--   
--   <ul>
--   <li><tt>'[]</tt> - The empty list,</li>
--   <li><tt>a ': b</tt> - A list where <tt><i>a</i></tt> is an arbitrary
--   type and <tt><i>b</i></tt> is the rest list.</li>
--   </ul>
--   
--   For example,
--   
--   <pre>
--   MultiReaderT '[Int, Bool] :: (* -&gt; *) -&gt; (* -&gt; *)
--   </pre>
--   
--   is a Reader transformer containing the types [Int, Bool].
newtype MultiReaderT x m a
MultiReaderT :: StateT (HList x) m a -> MultiReaderT x m a
runMultiReaderTRaw :: MultiReaderT x m a -> StateT (HList x) m a

-- | A MultiReader transformer carrying an empty state.
type MultiReaderTNull = MultiReaderT []

-- | A reader monad parameterized by the list of types x of the environment
--   / input to carry.
--   
--   Similar to <tt>Reader r = ReaderT r Identity</tt>
type MultiReader x = MultiReaderT x Identity

-- | All methods must be defined.
--   
--   The idea is: Any monad stack is instance of <tt>MonadMultiReader
--   a</tt>, iff the stack contains a <tt>MultiReaderT x</tt> with <i>a</i>
--   element of <i>x</i>.
class Monad m => MonadMultiReader a m
mAsk :: MonadMultiReader a m => m a
runMultiReaderT :: Monad m => HList r -> MultiReaderT r m a -> m a
runMultiReaderT_ :: Functor m => HList r -> MultiReaderT r m a -> m ()
runMultiReaderTNil :: Monad m => MultiReaderT [] m a -> m a
runMultiReaderTNil_ :: Functor m => MultiReaderT [] m a -> m ()
withMultiReader :: Monad m => r -> MultiReaderT (r : rs) m a -> MultiReaderT rs m a
withMultiReader_ :: (Functor m, Monad m) => r -> MultiReaderT (r : rs) m a -> MultiReaderT rs m ()
withMultiReaders :: Monad m => HList r1 -> MultiReaderT (Append r1 r2) m a -> MultiReaderT r2 m a
withMultiReaders_ :: (Functor m, Monad m) => HList r1 -> MultiReaderT (Append r1 r2) m a -> MultiReaderT r2 m ()
inflateReader :: (Monad m, ContainsType r rs) => ReaderT r m a -> MultiReaderT rs m a

-- | Map both the return value and the environment of a computation using
--   the given function.
--   
--   Note that there is a difference to mtl's ReaderT, where it is
--   <i>not</i> possible to modify the environment.
mapMultiReaderT :: (m (a, HList w) -> m' (a', HList w)) -> MultiReaderT w m a -> MultiReaderT w m' a'

-- | A raw extractor of the contained HList (i.e. the complete Reader).
mGetRaw :: Monad m => MultiReaderT a m (HList a)
mPutRaw :: Monad m => HList s -> MultiReaderT s m ()


-- | The multi-valued version of mtl's Writer / WriterT
module Control.Monad.Trans.MultiWriter.Lazy

-- | A Writer transformer monad patameterized by:
--   
--   <ul>
--   <li>x - The list of types that can be written (Monoid instances).</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   <a>MultiWriterT</a> corresponds to mtl's <a>WriterT</a>, but can
--   contain a heterogenous list of types.
--   
--   This heterogenous list is represented using Types.Data.List, i.e:
--   
--   <ul>
--   <li><tt>'[]</tt> - The empty list,</li>
--   <li><tt>a ': b</tt> - A list where <tt><i>a</i></tt> is an arbitrary
--   type and <tt><i>b</i></tt> is the rest list.</li>
--   </ul>
--   
--   For example,
--   
--   <pre>
--   MultiWriterT '[Int, Bool] :: (* -&gt; *) -&gt; (* -&gt; *)
--   </pre>
--   
--   is a Writer transformer containing the types [Int, Bool].
newtype MultiWriterT x m a
MultiWriterT :: StateT (HList x) m a -> MultiWriterT x m a
runMultiWriterTRaw :: MultiWriterT x m a -> StateT (HList x) m a

-- | A MultiWriter transformer carrying an empty state.
type MultiWriterTNull = MultiWriterT []
type MultiWriter x a = MultiWriterT x Identity a
class (Monad m, Monoid a) => MonadMultiWriter a m
mTell :: MonadMultiWriter a m => a -> m ()
runMultiWriterT :: (Monoid (HList w), Functor m) => MultiWriterT w m a -> m (a, HList w)
runMultiWriterTAW :: (Monoid (HList w), Functor m) => MultiWriterT w m a -> m (a, HList w)
runMultiWriterTWA :: (Monoid (HList w), Monad m) => MultiWriterT w m a -> m (HList w, a)
runMultiWriterTW :: (Monoid (HList w), Monad m) => MultiWriterT w m a -> m (HList w)
runMultiWriterTNil :: Monad m => MultiWriterT [] m a -> m a
runMultiWriterTNil_ :: Functor m => MultiWriterT [] m a -> m ()
withMultiWriter :: (Monoid w, Monad m) => MultiWriterT (w : ws) m a -> MultiWriterT ws m (a, w)
withMultiWriterAW :: (Monoid w, Monad m) => MultiWriterT (w : ws) m a -> MultiWriterT ws m (a, w)
withMultiWriterWA :: (Monoid w, Monad m) => MultiWriterT (w : ws) m a -> MultiWriterT ws m (w, a)
withMultiWriterW :: (Monoid w, Monad m) => MultiWriterT (w : ws) m a -> MultiWriterT ws m w
withMultiWriters :: (Monoid (HList w1), Monad m, HInit w1) => MultiWriterT (Append w1 w2) m a -> MultiWriterT w2 m (a, HList w1)
withMultiWritersAW :: (Monoid (HList w1), Monad m, HInit w1) => MultiWriterT (Append w1 w2) m a -> MultiWriterT w2 m (a, HList w1)
withMultiWritersWA :: (Monoid (HList w1), Monad m, HInit w1) => MultiWriterT (Append w1 w2) m a -> MultiWriterT w2 m (HList w1, a)
withMultiWritersW :: (Monoid (HList w1), Monad m, HInit w1) => MultiWriterT (Append w1 w2) m a -> MultiWriterT w2 m (HList w1)
inflateWriter :: (Monad m, Monoid w, ContainsType w ws) => WriterT w m a -> MultiWriterT ws m a

-- | Map both the return value and the state of a computation using the
--   given function.
mapMultiWriterT :: (m (a, HList w) -> m' (a', HList w)) -> MultiWriterT w m a -> MultiWriterT w m' a'

-- | A raw extractor of the contained HList (i.e. the complete state).
mGetRaw :: Monad m => MultiWriterT a m (HList a)
mPutRaw :: Monad m => HList s -> MultiWriterT s m ()
instance [overlap ok] MonadWriter w m => MonadWriter w (MultiWriterT c m)
instance [overlap ok] MonadState s m => MonadState s (MultiWriterT c m)
instance [overlap ok] MonadFix m => MonadFix (MultiWriterT w m)
instance [overlap ok] (Monad m, ContainsType a c, Monoid a) => MonadMultiWriter a (MultiWriterT c m)
instance [overlap ok] MonadTrans (MultiWriterT x)
instance [overlap ok] Monad m => Monad (MultiWriterT x m)
instance [overlap ok] (Applicative m, Monad m) => Applicative (MultiWriterT x m)
instance [overlap ok] Functor f => Functor (MultiWriterT x f)


-- | The multi-valued version of mtl's Writer / WriterT / MonadWriter

-- | <i>Deprecated: Use Control.Monad.Trans.MultiWriter instead</i>
module Control.Monad.MultiWriter

-- | A Writer transformer monad patameterized by:
--   
--   <ul>
--   <li>x - The list of types that can be written (Monoid instances).</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   <a>MultiWriterT</a> corresponds to mtl's <a>WriterT</a>, but can
--   contain a heterogenous list of types.
--   
--   This heterogenous list is represented using Types.Data.List, i.e:
--   
--   <ul>
--   <li><tt>'[]</tt> - The empty list,</li>
--   <li><tt>a ': b</tt> - A list where <tt><i>a</i></tt> is an arbitrary
--   type and <tt><i>b</i></tt> is the rest list.</li>
--   </ul>
--   
--   For example,
--   
--   <pre>
--   MultiWriterT '[Int, Bool] :: (* -&gt; *) -&gt; (* -&gt; *)
--   </pre>
--   
--   is a Writer transformer containing the types [Int, Bool].
newtype MultiWriterT x m a
MultiWriterT :: StateT (HList x) m a -> MultiWriterT x m a
runMultiWriterTRaw :: MultiWriterT x m a -> StateT (HList x) m a

-- | A MultiWriter transformer carrying an empty state.
type MultiWriterTNull = MultiWriterT []
type MultiWriter x a = MultiWriterT x Identity a
class (Monad m, Monoid a) => MonadMultiWriter a m
mTell :: MonadMultiWriter a m => a -> m ()
runMultiWriterT :: (Monoid (HList w), Functor m) => MultiWriterT w m a -> m (a, HList w)
runMultiWriterTAW :: (Monoid (HList w), Functor m) => MultiWriterT w m a -> m (a, HList w)
runMultiWriterTWA :: (Monoid (HList w), Monad m) => MultiWriterT w m a -> m (HList w, a)
runMultiWriterTW :: (Monoid (HList w), Monad m) => MultiWriterT w m a -> m (HList w)
runMultiWriterTNil :: Monad m => MultiWriterT [] m a -> m a
runMultiWriterTNil_ :: Functor m => MultiWriterT [] m a -> m ()
withMultiWriter :: (Monoid w, Monad m) => MultiWriterT (w : ws) m a -> MultiWriterT ws m (a, w)
withMultiWriterAW :: (Monoid w, Monad m) => MultiWriterT (w : ws) m a -> MultiWriterT ws m (a, w)
withMultiWriterWA :: (Monoid w, Monad m) => MultiWriterT (w : ws) m a -> MultiWriterT ws m (w, a)
withMultiWriterW :: (Monoid w, Monad m) => MultiWriterT (w : ws) m a -> MultiWriterT ws m w
withMultiWriters :: (Monoid (HList w1), Monad m, HInit w1) => MultiWriterT (Append w1 w2) m a -> MultiWriterT w2 m (a, HList w1)
withMultiWritersAW :: (Monoid (HList w1), Monad m, HInit w1) => MultiWriterT (Append w1 w2) m a -> MultiWriterT w2 m (a, HList w1)
withMultiWritersWA :: (Monoid (HList w1), Monad m, HInit w1) => MultiWriterT (Append w1 w2) m a -> MultiWriterT w2 m (HList w1, a)
withMultiWritersW :: (Monoid (HList w1), Monad m, HInit w1) => MultiWriterT (Append w1 w2) m a -> MultiWriterT w2 m (HList w1)
inflateWriter :: (Monad m, Monoid w, ContainsType w ws) => WriterT w m a -> MultiWriterT ws m a

-- | Map both the return value and the state of a computation using the
--   given function.
mapMultiWriterT :: (m (a, HList w) -> m' (a', HList w)) -> MultiWriterT w m a -> MultiWriterT w m' a'

-- | A raw extractor of the contained HList (i.e. the complete state).
mGetRaw :: Monad m => MultiWriterT a m (HList a)
mPutRaw :: Monad m => HList s -> MultiWriterT s m ()


-- | The multi-valued version of mtl's Writer / WriterT / MonadWriter
module Control.Monad.Trans.MultiWriter

-- | A Writer transformer monad patameterized by:
--   
--   <ul>
--   <li>x - The list of types that can be written (Monoid instances).</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   <a>MultiWriterT</a> corresponds to mtl's <a>WriterT</a>, but can
--   contain a heterogenous list of types.
--   
--   This heterogenous list is represented using Types.Data.List, i.e:
--   
--   <ul>
--   <li><tt>'[]</tt> - The empty list,</li>
--   <li><tt>a ': b</tt> - A list where <tt><i>a</i></tt> is an arbitrary
--   type and <tt><i>b</i></tt> is the rest list.</li>
--   </ul>
--   
--   For example,
--   
--   <pre>
--   MultiWriterT '[Int, Bool] :: (* -&gt; *) -&gt; (* -&gt; *)
--   </pre>
--   
--   is a Writer transformer containing the types [Int, Bool].
newtype MultiWriterT x m a
MultiWriterT :: StateT (HList x) m a -> MultiWriterT x m a
runMultiWriterTRaw :: MultiWriterT x m a -> StateT (HList x) m a

-- | A MultiWriter transformer carrying an empty state.
type MultiWriterTNull = MultiWriterT []
type MultiWriter x a = MultiWriterT x Identity a
class (Monad m, Monoid a) => MonadMultiWriter a m
mTell :: MonadMultiWriter a m => a -> m ()
runMultiWriterT :: (Monoid (HList w), Functor m) => MultiWriterT w m a -> m (a, HList w)
runMultiWriterTAW :: (Monoid (HList w), Functor m) => MultiWriterT w m a -> m (a, HList w)
runMultiWriterTWA :: (Monoid (HList w), Monad m) => MultiWriterT w m a -> m (HList w, a)
runMultiWriterTW :: (Monoid (HList w), Monad m) => MultiWriterT w m a -> m (HList w)
runMultiWriterTNil :: Monad m => MultiWriterT [] m a -> m a
runMultiWriterTNil_ :: Functor m => MultiWriterT [] m a -> m ()
withMultiWriter :: (Monoid w, Monad m) => MultiWriterT (w : ws) m a -> MultiWriterT ws m (a, w)
withMultiWriterAW :: (Monoid w, Monad m) => MultiWriterT (w : ws) m a -> MultiWriterT ws m (a, w)
withMultiWriterWA :: (Monoid w, Monad m) => MultiWriterT (w : ws) m a -> MultiWriterT ws m (w, a)
withMultiWriterW :: (Monoid w, Monad m) => MultiWriterT (w : ws) m a -> MultiWriterT ws m w
withMultiWriters :: (Monoid (HList w1), Monad m, HInit w1) => MultiWriterT (Append w1 w2) m a -> MultiWriterT w2 m (a, HList w1)
withMultiWritersAW :: (Monoid (HList w1), Monad m, HInit w1) => MultiWriterT (Append w1 w2) m a -> MultiWriterT w2 m (a, HList w1)
withMultiWritersWA :: (Monoid (HList w1), Monad m, HInit w1) => MultiWriterT (Append w1 w2) m a -> MultiWriterT w2 m (HList w1, a)
withMultiWritersW :: (Monoid (HList w1), Monad m, HInit w1) => MultiWriterT (Append w1 w2) m a -> MultiWriterT w2 m (HList w1)

-- | Map both the return value and the state of a computation using the
--   given function.
mapMultiWriterT :: (m (a, HList w) -> m' (a', HList w)) -> MultiWriterT w m a -> MultiWriterT w m' a'

-- | A raw extractor of the contained HList (i.e. the complete state).
mGetRaw :: Monad m => MultiWriterT a m (HList a)
mPutRaw :: Monad m => HList s -> MultiWriterT s m ()


-- | The multi-valued version of mtl's Reader / ReaderT
module Control.Monad.Trans.MultiReader.Strict

-- | A Reader transformer monad patameterized by:
--   
--   <ul>
--   <li>x - The list of types constituting the environment / input (to be
--   read),</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   <a>MultiReaderT</a> corresponds to mtl's <a>ReaderT</a>, but can
--   contain a heterogenous list of types.
--   
--   This heterogenous list is represented using Types.Data.List, i.e:
--   
--   <ul>
--   <li><tt>'[]</tt> - The empty list,</li>
--   <li><tt>a ': b</tt> - A list where <tt><i>a</i></tt> is an arbitrary
--   type and <tt><i>b</i></tt> is the rest list.</li>
--   </ul>
--   
--   For example,
--   
--   <pre>
--   MultiReaderT '[Int, Bool] :: (* -&gt; *) -&gt; (* -&gt; *)
--   </pre>
--   
--   is a Reader transformer containing the types [Int, Bool].
newtype MultiReaderT x m a
MultiReaderT :: StateT (HList x) m a -> MultiReaderT x m a
runMultiReaderTRaw :: MultiReaderT x m a -> StateT (HList x) m a

-- | A MultiReader transformer carrying an empty state.
type MultiReaderTNull = MultiReaderT []

-- | A reader monad parameterized by the list of types x of the environment
--   / input to carry.
--   
--   Similar to <tt>Reader r = ReaderT r Identity</tt>
type MultiReader x = MultiReaderT x Identity

-- | All methods must be defined.
--   
--   The idea is: Any monad stack is instance of <tt>MonadMultiReader
--   a</tt>, iff the stack contains a <tt>MultiReaderT x</tt> with <i>a</i>
--   element of <i>x</i>.
class Monad m => MonadMultiReader a m
mAsk :: MonadMultiReader a m => m a
runMultiReaderT :: Monad m => HList r -> MultiReaderT r m a -> m a
runMultiReaderT_ :: Functor m => HList r -> MultiReaderT r m a -> m ()
runMultiReaderTNil :: Monad m => MultiReaderT [] m a -> m a
runMultiReaderTNil_ :: Functor m => MultiReaderT [] m a -> m ()
withMultiReader :: Monad m => r -> MultiReaderT (r : rs) m a -> MultiReaderT rs m a
withMultiReader_ :: (Functor m, Monad m) => r -> MultiReaderT (r : rs) m a -> MultiReaderT rs m ()
withMultiReaders :: Monad m => HList r1 -> MultiReaderT (Append r1 r2) m a -> MultiReaderT r2 m a
withMultiReaders_ :: (Functor m, Monad m) => HList r1 -> MultiReaderT (Append r1 r2) m a -> MultiReaderT r2 m ()
inflateReader :: (Monad m, ContainsType r rs) => ReaderT r m a -> MultiReaderT rs m a

-- | Map both the return value and the environment of a computation using
--   the given function.
--   
--   Note that there is a difference to mtl's ReaderT, where it is
--   <i>not</i> possible to modify the environment.
mapMultiReaderT :: (m (a, HList w) -> m' (a', HList w)) -> MultiReaderT w m a -> MultiReaderT w m' a'

-- | A raw extractor of the contained HList (i.e. the complete Reader).
mGetRaw :: Monad m => MultiReaderT a m (HList a)
mPutRaw :: Monad m => HList s -> MultiReaderT s m ()
instance [overlap ok] MonadWriter w m => MonadWriter w (MultiReaderT c m)
instance [overlap ok] MonadState s m => MonadState s (MultiReaderT c m)
instance [overlap ok] MonadFix m => MonadFix (MultiReaderT r m)
instance [overlap ok] (Monad m, ContainsType a c) => MonadMultiReader a (MultiReaderT c m)
instance [overlap ok] MonadTrans (MultiReaderT x)
instance [overlap ok] Monad m => Monad (MultiReaderT x m)
instance [overlap ok] (Applicative m, Monad m) => Applicative (MultiReaderT x m)
instance [overlap ok] Functor f => Functor (MultiReaderT x f)


-- | The multi-valued version of mtl's Writer / WriterT
module Control.Monad.Trans.MultiWriter.Strict

-- | A Writer transformer monad patameterized by:
--   
--   <ul>
--   <li>x - The list of types that can be written (Monoid instances).</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   <a>MultiWriterT</a> corresponds to mtl's <a>WriterT</a>, but can
--   contain a heterogenous list of types.
--   
--   This heterogenous list is represented using Types.Data.List, i.e:
--   
--   <ul>
--   <li><tt>'[]</tt> - The empty list,</li>
--   <li><tt>a ': b</tt> - A list where <tt><i>a</i></tt> is an arbitrary
--   type and <tt><i>b</i></tt> is the rest list.</li>
--   </ul>
--   
--   For example,
--   
--   <pre>
--   MultiWriterT '[Int, Bool] :: (* -&gt; *) -&gt; (* -&gt; *)
--   </pre>
--   
--   is a Writer transformer containing the types [Int, Bool].
newtype MultiWriterT x m a
MultiWriterT :: StateT (HList x) m a -> MultiWriterT x m a
runMultiWriterTRaw :: MultiWriterT x m a -> StateT (HList x) m a

-- | A MultiWriter transformer carrying an empty state.
type MultiWriterTNull = MultiWriterT []
type MultiWriter x a = MultiWriterT x Identity a
class (Monad m, Monoid a) => MonadMultiWriter a m
mTell :: MonadMultiWriter a m => a -> m ()
runMultiWriterT :: (Monoid (HList w), Functor m) => MultiWriterT w m a -> m (a, HList w)
runMultiWriterTAW :: (Monoid (HList w), Functor m) => MultiWriterT w m a -> m (a, HList w)
runMultiWriterTWA :: (Monoid (HList w), Monad m) => MultiWriterT w m a -> m (HList w, a)
runMultiWriterTW :: (Monoid (HList w), Monad m) => MultiWriterT w m a -> m (HList w)
runMultiWriterTNil :: Monad m => MultiWriterT [] m a -> m a
runMultiWriterTNil_ :: Functor m => MultiWriterT [] m a -> m ()
withMultiWriter :: (Monoid w, Monad m) => MultiWriterT (w : ws) m a -> MultiWriterT ws m (a, w)
withMultiWriterAW :: (Monoid w, Monad m) => MultiWriterT (w : ws) m a -> MultiWriterT ws m (a, w)
withMultiWriterWA :: (Monoid w, Monad m) => MultiWriterT (w : ws) m a -> MultiWriterT ws m (w, a)
withMultiWriterW :: (Monoid w, Monad m) => MultiWriterT (w : ws) m a -> MultiWriterT ws m w
withMultiWriters :: (Monoid (HList w1), Monad m, HInit w1) => MultiWriterT (Append w1 w2) m a -> MultiWriterT w2 m (a, HList w1)
withMultiWritersAW :: (Monoid (HList w1), Monad m, HInit w1) => MultiWriterT (Append w1 w2) m a -> MultiWriterT w2 m (a, HList w1)
withMultiWritersWA :: (Monoid (HList w1), Monad m, HInit w1) => MultiWriterT (Append w1 w2) m a -> MultiWriterT w2 m (HList w1, a)
withMultiWritersW :: (Monoid (HList w1), Monad m, HInit w1) => MultiWriterT (Append w1 w2) m a -> MultiWriterT w2 m (HList w1)
inflateWriter :: (Monad m, Monoid w, ContainsType w ws) => WriterT w m a -> MultiWriterT ws m a

-- | Map both the return value and the state of a computation using the
--   given function.
mapMultiWriterT :: (m (a, HList w) -> m' (a', HList w)) -> MultiWriterT w m a -> MultiWriterT w m' a'

-- | A raw extractor of the contained HList (i.e. the complete state).
mGetRaw :: Monad m => MultiWriterT a m (HList a)
mPutRaw :: Monad m => HList s -> MultiWriterT s m ()
instance [overlap ok] MonadWriter w m => MonadWriter w (MultiWriterT c m)
instance [overlap ok] MonadState s m => MonadState s (MultiWriterT c m)
instance [overlap ok] MonadFix m => MonadFix (MultiWriterT w m)
instance [overlap ok] (Monad m, ContainsType a c, Monoid a) => MonadMultiWriter a (MultiWriterT c m)
instance [overlap ok] MonadTrans (MultiWriterT x)
instance [overlap ok] Monad m => Monad (MultiWriterT x m)
instance [overlap ok] (Applicative m, Monad m) => Applicative (MultiWriterT x m)
instance [overlap ok] Functor f => Functor (MultiWriterT x f)


-- | The multi-valued version of mtl's State / StateT
module Control.Monad.Trans.MultiState.Strict

-- | A State transformer monad patameterized by:
--   
--   <ul>
--   <li>x - The list of types constituting the state,</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   <a>MultiStateT</a> corresponds to mtl's <a>StateT</a>, but can contain
--   a heterogenous list of types.
--   
--   This heterogenous list is represented using Types.Data.List, i.e:
--   
--   <ul>
--   <li><tt>'[]</tt> - The empty list,</li>
--   <li><tt>a ': b</tt> - A list where <tt><i>a</i></tt> is an arbitrary
--   type and <tt><i>b</i></tt> is the rest list.</li>
--   </ul>
--   
--   For example,
--   
--   <pre>
--   MultiStateT '[Int, Bool] :: (* -&gt; *) -&gt; (* -&gt; *)
--   </pre>
--   
--   is a State wrapper containing the types [Int, Bool].
newtype MultiStateT x m a
MultiStateT :: StateT (HList x) m a -> MultiStateT x m a
runMultiStateTRaw :: MultiStateT x m a -> StateT (HList x) m a

-- | A MultiState transformer carrying an empty state.
type MultiStateTNull = MultiStateT []

-- | A state monad parameterized by the list of types x of the state to
--   carry.
--   
--   Similar to <tt>State s = StateT s Identity</tt>
type MultiState x = MultiStateT x Identity

-- | All methods must be defined.
--   
--   The idea is: Any monad stack is instance of <tt>MonadMultiState
--   a</tt>, iff the stack contains a <tt>MultiStateT x</tt> with <i>a</i>
--   element of <i>x</i>.
class Monad m => MonadMultiState a m
mSet :: MonadMultiState a m => a -> m ()
mGet :: MonadMultiState a m => m a
runMultiStateT :: Functor m => HList s -> MultiStateT s m a -> m (a, HList s)
runMultiStateTAS :: Functor m => HList s -> MultiStateT s m a -> m (a, HList s)
runMultiStateTSA :: Monad m => HList s -> MultiStateT s m a -> m (HList s, a)
runMultiStateTA :: Monad m => HList s -> MultiStateT s m a -> m a
runMultiStateTS :: Monad m => HList s -> MultiStateT s m a -> m (HList s)
runMultiStateT_ :: Functor m => HList s -> MultiStateT s m a -> m ()
runMultiStateTNil :: Monad m => MultiStateT [] m a -> m a
runMultiStateTNil_ :: Functor m => MultiStateT [] m a -> m ()
withMultiState :: Monad m => s -> MultiStateT (s : ss) m a -> MultiStateT ss m (a, s)
withMultiStateAS :: Monad m => s -> MultiStateT (s : ss) m a -> MultiStateT ss m (a, s)
withMultiStateSA :: Monad m => s -> MultiStateT (s : ss) m a -> MultiStateT ss m (s, a)
withMultiStateA :: Monad m => s -> MultiStateT (s : ss) m a -> MultiStateT ss m a
withMultiStateS :: Monad m => s -> MultiStateT (s : ss) m a -> MultiStateT ss m s
withMultiState_ :: (Functor m, Monad m) => s -> MultiStateT (s : ss) m a -> MultiStateT ss m ()
withMultiStates :: Monad m => HList s1 -> MultiStateT (Append s1 s2) m a -> MultiStateT s2 m (a, HList s1)
withMultiStatesAS :: Monad m => HList s1 -> MultiStateT (Append s1 s2) m a -> MultiStateT s2 m (a, HList s1)
withMultiStatesSA :: Monad m => HList s1 -> MultiStateT (Append s1 s2) m a -> MultiStateT s2 m (HList s1, a)
withMultiStatesA :: Monad m => HList s1 -> MultiStateT (Append s1 s2) m a -> MultiStateT s2 m a
withMultiStatesS :: Monad m => HList s1 -> MultiStateT (Append s1 s2) m a -> MultiStateT s2 m (HList s1)
withMultiStates_ :: (Functor m, Monad m) => HList s1 -> MultiStateT (Append s1 s2) m a -> MultiStateT s2 m ()
inflateState :: (Monad m, ContainsType s ss) => StateT s m a -> MultiStateT ss m a
inflateReader :: (Monad m, ContainsType r ss) => ReaderT r m a -> MultiStateT ss m a
inflateWriter :: (Monad m, ContainsType w ss, Monoid w) => WriterT w m a -> MultiStateT ss m a

-- | Map both the return value and the state of a computation using the
--   given function.
mapMultiStateT :: (m (a, HList w) -> m' (a', HList w)) -> MultiStateT w m a -> MultiStateT w m' a'

-- | A raw extractor of the contained HList (i.e. the complete state).
mGetRaw :: Monad m => MultiStateT a m (HList a)
mPutRaw :: Monad m => HList s -> MultiStateT s m ()
instance [overlap ok] MonadWriter w m => MonadWriter w (MultiStateT c m)
instance [overlap ok] MonadState s m => MonadState s (MultiStateT c m)
instance [overlap ok] MonadFix m => MonadFix (MultiStateT s m)
instance [overlap ok] (Monad m, ContainsType a c) => MonadMultiState a (MultiStateT c m)
instance [overlap ok] MonadTrans (MultiStateT x)
instance [overlap ok] Monad m => Monad (MultiStateT x m)
instance [overlap ok] (Applicative m, Monad m) => Applicative (MultiStateT x m)
instance [overlap ok] Functor f => Functor (MultiStateT x f)


-- | The multi-valued version of mtl's RWS / RWST
module Control.Monad.Trans.MultiRWS.Lazy
newtype MultiRWST r w s m a
MultiRWST :: StateT (HList r, HList w, HList s) m a -> MultiRWST r w s m a
runMultiRWSTRaw :: MultiRWST r w s m a -> StateT (HList r, HList w, HList s) m a
type MultiRWSTNull = MultiRWST [] [] []
type MultiRWS r w s = MultiRWST r w s Identity

-- | All methods must be defined.
--   
--   The idea is: Any monad stack is instance of <tt>MonadMultiReader
--   a</tt>, iff the stack contains a <tt>MultiReaderT x</tt> with <i>a</i>
--   element of <i>x</i>.
class Monad m => MonadMultiReader a m
mAsk :: MonadMultiReader a m => m a
class (Monad m, Monoid a) => MonadMultiWriter a m
mTell :: MonadMultiWriter a m => a -> m ()

-- | All methods must be defined.
--   
--   The idea is: Any monad stack is instance of <tt>MonadMultiState
--   a</tt>, iff the stack contains a <tt>MultiStateT x</tt> with <i>a</i>
--   element of <i>x</i>.
class Monad m => MonadMultiState a m
mSet :: MonadMultiState a m => a -> m ()
mGet :: MonadMultiState a m => m a
runMultiRWST :: (Monad m, Monoid (HList w)) => HList r -> HList s -> MultiRWST r w s m a -> m (a, HList s, HList w)
runMultiRWSTASW :: (Monad m, Monoid (HList w)) => HList r -> HList s -> MultiRWST r w s m a -> m (a, HList s, HList w)
runMultiRWSTW :: (Monad m, Monoid (HList w)) => HList r -> HList s -> MultiRWST r w s m a -> m (HList w)
runMultiRWSTAW :: (Monad m, Monoid (HList w)) => HList r -> HList s -> MultiRWST r w s m a -> m (a, HList w)
runMultiRWSTSW :: (Monad m, Monoid (HList w)) => HList r -> HList s -> MultiRWST r w s m a -> m (HList s, HList w)
runMultiRWSTNil :: Monad m => MultiRWST [] [] [] m a -> m a
runMultiRWSTNil_ :: (Monad m, Functor m) => MultiRWST [] [] [] m a -> m ()
withMultiReader :: Monad m => r -> MultiRWST (r : rs) w s m a -> MultiRWST rs w s m a
withMultiReader_ :: (Functor m, Monad m) => r -> MultiRWST (r : rs) w s m a -> MultiRWST rs w s m ()
withMultiReaders :: Monad m => HList r1 -> MultiRWST (Append r1 r2) w s m a -> MultiRWST r2 w s m a
withMultiReaders_ :: (Functor m, Monad m) => HList r1 -> MultiRWST (Append r1 r2) w s m a -> MultiRWST r2 w s m ()
withMultiWriter :: (Monoid w, Monad m) => MultiRWST r (w : ws) s m a -> MultiRWST r ws s m (a, w)
withMultiWriterAW :: (Monoid w, Monad m) => MultiRWST r (w : ws) s m a -> MultiRWST r ws s m (a, w)
withMultiWriterWA :: (Monoid w, Monad m) => MultiRWST r (w : ws) s m a -> MultiRWST r ws s m (w, a)
withMultiWriterW :: (Monoid w, Monad m) => MultiRWST r (w : ws) s m a -> MultiRWST r ws s m w
withMultiWriters :: (Monoid (HList w1), Monad m, HInit w1) => MultiRWST r (Append w1 w2) s m a -> MultiRWST r w2 s m (a, HList w1)
withMultiWritersAW :: (Monoid (HList w1), Monad m, HInit w1) => MultiRWST r (Append w1 w2) s m a -> MultiRWST r w2 s m (a, HList w1)
withMultiWritersWA :: (Monoid (HList w1), Monad m, HInit w1) => MultiRWST r (Append w1 w2) s m a -> MultiRWST r w2 s m (HList w1, a)
withMultiWritersW :: (Monoid (HList w1), Monad m, HInit w1) => MultiRWST r (Append w1 w2) s m a -> MultiRWST r w2 s m (HList w1)
withMultiState :: Monad m => s -> MultiRWST r w (s : ss) m a -> MultiRWST r w ss m (a, s)
withMultiStateAS :: Monad m => s -> MultiRWST r w (s : ss) m a -> MultiRWST r w ss m (a, s)
withMultiStateSA :: Monad m => s -> MultiRWST r w (s : ss) m a -> MultiRWST r w ss m (s, a)
withMultiStateA :: Monad m => s -> MultiRWST r w (s : ss) m a -> MultiRWST r w ss m a
withMultiStateS :: Monad m => s -> MultiRWST r w (s : ss) m a -> MultiRWST r w ss m s
withMultiState_ :: (Functor m, Monad m) => s -> MultiRWST r w (s : ss) m a -> MultiRWST r w ss m ()
withMultiStates :: Monad m => HList s1 -> MultiRWST r w (Append s1 s2) m a -> MultiRWST r w s2 m (a, HList s1)
withMultiStatesAS :: Monad m => HList s1 -> MultiRWST r w (Append s1 s2) m a -> MultiRWST r w s2 m (a, HList s1)
withMultiStatesSA :: Monad m => HList s1 -> MultiRWST r w (Append s1 s2) m a -> MultiRWST r w s2 m (HList s1, a)
withMultiStatesA :: Monad m => HList s1 -> MultiRWST r w (Append s1 s2) m a -> MultiRWST r w s2 m a
withMultiStatesS :: Monad m => HList s1 -> MultiRWST r w (Append s1 s2) m a -> MultiRWST r w s2 m (HList s1)
withMultiStates_ :: (Functor m, Monad m) => HList s1 -> MultiRWST r w (Append s1 s2) m a -> MultiRWST r w s2 m ()
inflateReader :: (Monad m, ContainsType r rs) => ReaderT r m a -> MultiRWST rs w s m a
inflateMultiReader :: Monad m => MultiReaderT r m a -> MultiRWST r w s m a
inflateWriter :: (Monad m, ContainsType w ws, Monoid w) => WriterT w m a -> MultiRWST r ws s m a
inflateMultiWriter :: (Functor m, Monad m, Monoid (HList w)) => MultiWriterT w m a -> MultiRWST r w s m a
inflateState :: (Monad m, ContainsType s ss) => StateT s m a -> MultiRWST r w ss m a
inflateMultiState :: (Functor m, Monad m) => MultiStateT s m a -> MultiRWST r w s m a
mapMultiRWST :: ss ~ (HList r, HList w, HList s) => (m (a, ss) -> m' (a', ss)) -> MultiRWST r w s m a -> MultiRWST r w s m' a'
mGetRawR :: Monad m => MultiRWST r w s m (HList r)
mGetRawW :: Monad m => MultiRWST r w s m (HList w)
mGetRawS :: Monad m => MultiRWST r w s m (HList s)
mPutRawR :: Monad m => HList r -> MultiRWST r w s m ()
mPutRawW :: Monad m => HList w -> MultiRWST r w s m ()
mPutRawS :: Monad m => HList s -> MultiRWST r w s m ()
instance [overlap ok] MonadFix m => MonadFix (MultiRWST r w s m)
instance [overlap ok] (Monad m, ContainsType a s) => MonadMultiState a (MultiRWST r w s m)
instance [overlap ok] (Monad m, ContainsType a w, Monoid a) => MonadMultiWriter a (MultiRWST r w s m)
instance [overlap ok] (Monad m, ContainsType a r) => MonadMultiReader a (MultiRWST r w s m)
instance [overlap ok] MonadTrans (MultiRWST r w s)
instance [overlap ok] Monad m => Monad (MultiRWST r w s m)
instance [overlap ok] (Applicative m, Monad m) => Applicative (MultiRWST r w s m)
instance [overlap ok] Functor f => Functor (MultiRWST r w s f)


-- | The multi-valued version of mtl's RWS / RWST
module Control.Monad.Trans.MultiRWS
newtype MultiRWST r w s m a
MultiRWST :: StateT (HList r, HList w, HList s) m a -> MultiRWST r w s m a
runMultiRWSTRaw :: MultiRWST r w s m a -> StateT (HList r, HList w, HList s) m a
type MultiRWSTNull = MultiRWST [] [] []
type MultiRWS r w s = MultiRWST r w s Identity

-- | All methods must be defined.
--   
--   The idea is: Any monad stack is instance of <tt>MonadMultiReader
--   a</tt>, iff the stack contains a <tt>MultiReaderT x</tt> with <i>a</i>
--   element of <i>x</i>.
class Monad m => MonadMultiReader a m
mAsk :: MonadMultiReader a m => m a
class (Monad m, Monoid a) => MonadMultiWriter a m
mTell :: MonadMultiWriter a m => a -> m ()

-- | All methods must be defined.
--   
--   The idea is: Any monad stack is instance of <tt>MonadMultiState
--   a</tt>, iff the stack contains a <tt>MultiStateT x</tt> with <i>a</i>
--   element of <i>x</i>.
class Monad m => MonadMultiState a m
mSet :: MonadMultiState a m => a -> m ()
mGet :: MonadMultiState a m => m a
runMultiRWST :: (Monad m, Monoid (HList w)) => HList r -> HList s -> MultiRWST r w s m a -> m (a, HList s, HList w)
runMultiRWSTASW :: (Monad m, Monoid (HList w)) => HList r -> HList s -> MultiRWST r w s m a -> m (a, HList s, HList w)
runMultiRWSTW :: (Monad m, Monoid (HList w)) => HList r -> HList s -> MultiRWST r w s m a -> m (HList w)
runMultiRWSTAW :: (Monad m, Monoid (HList w)) => HList r -> HList s -> MultiRWST r w s m a -> m (a, HList w)
runMultiRWSTSW :: (Monad m, Monoid (HList w)) => HList r -> HList s -> MultiRWST r w s m a -> m (HList s, HList w)
runMultiRWSTNil :: Monad m => MultiRWST [] [] [] m a -> m a
runMultiRWSTNil_ :: (Monad m, Functor m) => MultiRWST [] [] [] m a -> m ()
withMultiReader :: Monad m => r -> MultiRWST (r : rs) w s m a -> MultiRWST rs w s m a
withMultiReader_ :: (Functor m, Monad m) => r -> MultiRWST (r : rs) w s m a -> MultiRWST rs w s m ()
withMultiReaders :: Monad m => HList r1 -> MultiRWST (Append r1 r2) w s m a -> MultiRWST r2 w s m a
withMultiReaders_ :: (Functor m, Monad m) => HList r1 -> MultiRWST (Append r1 r2) w s m a -> MultiRWST r2 w s m ()
withMultiWriter :: (Monoid w, Monad m) => MultiRWST r (w : ws) s m a -> MultiRWST r ws s m (a, w)
withMultiWriterAW :: (Monoid w, Monad m) => MultiRWST r (w : ws) s m a -> MultiRWST r ws s m (a, w)
withMultiWriterWA :: (Monoid w, Monad m) => MultiRWST r (w : ws) s m a -> MultiRWST r ws s m (w, a)
withMultiWriterW :: (Monoid w, Monad m) => MultiRWST r (w : ws) s m a -> MultiRWST r ws s m w
withMultiWriters :: (Monoid (HList w1), Monad m, HInit w1) => MultiRWST r (Append w1 w2) s m a -> MultiRWST r w2 s m (a, HList w1)
withMultiWritersAW :: (Monoid (HList w1), Monad m, HInit w1) => MultiRWST r (Append w1 w2) s m a -> MultiRWST r w2 s m (a, HList w1)
withMultiWritersWA :: (Monoid (HList w1), Monad m, HInit w1) => MultiRWST r (Append w1 w2) s m a -> MultiRWST r w2 s m (HList w1, a)
withMultiWritersW :: (Monoid (HList w1), Monad m, HInit w1) => MultiRWST r (Append w1 w2) s m a -> MultiRWST r w2 s m (HList w1)
withMultiState :: Monad m => s -> MultiRWST r w (s : ss) m a -> MultiRWST r w ss m (a, s)
withMultiStateAS :: Monad m => s -> MultiRWST r w (s : ss) m a -> MultiRWST r w ss m (a, s)
withMultiStateSA :: Monad m => s -> MultiRWST r w (s : ss) m a -> MultiRWST r w ss m (s, a)
withMultiStateA :: Monad m => s -> MultiRWST r w (s : ss) m a -> MultiRWST r w ss m a
withMultiStateS :: Monad m => s -> MultiRWST r w (s : ss) m a -> MultiRWST r w ss m s
withMultiState_ :: (Functor m, Monad m) => s -> MultiRWST r w (s : ss) m a -> MultiRWST r w ss m ()
withMultiStates :: Monad m => HList s1 -> MultiRWST r w (Append s1 s2) m a -> MultiRWST r w s2 m (a, HList s1)
withMultiStatesAS :: Monad m => HList s1 -> MultiRWST r w (Append s1 s2) m a -> MultiRWST r w s2 m (a, HList s1)
withMultiStatesSA :: Monad m => HList s1 -> MultiRWST r w (Append s1 s2) m a -> MultiRWST r w s2 m (HList s1, a)
withMultiStatesA :: Monad m => HList s1 -> MultiRWST r w (Append s1 s2) m a -> MultiRWST r w s2 m a
withMultiStatesS :: Monad m => HList s1 -> MultiRWST r w (Append s1 s2) m a -> MultiRWST r w s2 m (HList s1)
withMultiStates_ :: (Functor m, Monad m) => HList s1 -> MultiRWST r w (Append s1 s2) m a -> MultiRWST r w s2 m ()
inflateReader :: (Monad m, ContainsType r rs) => ReaderT r m a -> MultiRWST rs w s m a
inflateMultiReader :: Monad m => MultiReaderT r m a -> MultiRWST r w s m a
inflateWriter :: (Monad m, ContainsType w ws, Monoid w) => WriterT w m a -> MultiRWST r ws s m a
inflateMultiWriter :: (Functor m, Monad m, Monoid (HList w)) => MultiWriterT w m a -> MultiRWST r w s m a
inflateState :: (Monad m, ContainsType s ss) => StateT s m a -> MultiRWST r w ss m a
inflateMultiState :: (Functor m, Monad m) => MultiStateT s m a -> MultiRWST r w s m a
mapMultiRWST :: ss ~ (HList r, HList w, HList s) => (m (a, ss) -> m' (a', ss)) -> MultiRWST r w s m a -> MultiRWST r w s m' a'
mGetRawR :: Monad m => MultiRWST r w s m (HList r)
mGetRawW :: Monad m => MultiRWST r w s m (HList w)
mGetRawS :: Monad m => MultiRWST r w s m (HList s)
mPutRawR :: Monad m => HList r -> MultiRWST r w s m ()
mPutRawW :: Monad m => HList w -> MultiRWST r w s m ()
mPutRawS :: Monad m => HList s -> MultiRWST r w s m ()


-- | The multi-valued version of mtl's RWS / RWST
module Control.Monad.Trans.MultiRWS.Strict
newtype MultiRWST r w s m a
MultiRWST :: StateT (HList r, HList w, HList s) m a -> MultiRWST r w s m a
runMultiRWSTRaw :: MultiRWST r w s m a -> StateT (HList r, HList w, HList s) m a
type MultiRWSTNull = MultiRWST [] [] []
type MultiRWS r w s = MultiRWST r w s Identity

-- | All methods must be defined.
--   
--   The idea is: Any monad stack is instance of <tt>MonadMultiReader
--   a</tt>, iff the stack contains a <tt>MultiReaderT x</tt> with <i>a</i>
--   element of <i>x</i>.
class Monad m => MonadMultiReader a m
mAsk :: MonadMultiReader a m => m a
class (Monad m, Monoid a) => MonadMultiWriter a m
mTell :: MonadMultiWriter a m => a -> m ()

-- | All methods must be defined.
--   
--   The idea is: Any monad stack is instance of <tt>MonadMultiState
--   a</tt>, iff the stack contains a <tt>MultiStateT x</tt> with <i>a</i>
--   element of <i>x</i>.
class Monad m => MonadMultiState a m
mSet :: MonadMultiState a m => a -> m ()
mGet :: MonadMultiState a m => m a
runMultiRWST :: (Monad m, Monoid (HList w)) => HList r -> HList s -> MultiRWST r w s m a -> m (a, HList s, HList w)
runMultiRWSTASW :: (Monad m, Monoid (HList w)) => HList r -> HList s -> MultiRWST r w s m a -> m (a, HList s, HList w)
runMultiRWSTW :: (Monad m, Monoid (HList w)) => HList r -> HList s -> MultiRWST r w s m a -> m (HList w)
runMultiRWSTAW :: (Monad m, Monoid (HList w)) => HList r -> HList s -> MultiRWST r w s m a -> m (a, HList w)
runMultiRWSTSW :: (Monad m, Monoid (HList w)) => HList r -> HList s -> MultiRWST r w s m a -> m (HList s, HList w)
runMultiRWSTNil :: Monad m => MultiRWST [] [] [] m a -> m a
runMultiRWSTNil_ :: (Monad m, Functor m) => MultiRWST [] [] [] m a -> m ()
withMultiReader :: Monad m => r -> MultiRWST (r : rs) w s m a -> MultiRWST rs w s m a
withMultiReader_ :: (Functor m, Monad m) => r -> MultiRWST (r : rs) w s m a -> MultiRWST rs w s m ()
withMultiReaders :: Monad m => HList r1 -> MultiRWST (Append r1 r2) w s m a -> MultiRWST r2 w s m a
withMultiReaders_ :: (Functor m, Monad m) => HList r1 -> MultiRWST (Append r1 r2) w s m a -> MultiRWST r2 w s m ()
withMultiWriter :: (Monoid w, Monad m) => MultiRWST r (w : ws) s m a -> MultiRWST r ws s m (a, w)
withMultiWriterAW :: (Monoid w, Monad m) => MultiRWST r (w : ws) s m a -> MultiRWST r ws s m (a, w)
withMultiWriterWA :: (Monoid w, Monad m) => MultiRWST r (w : ws) s m a -> MultiRWST r ws s m (w, a)
withMultiWriterW :: (Monoid w, Monad m) => MultiRWST r (w : ws) s m a -> MultiRWST r ws s m w
withMultiWriters :: (Monoid (HList w1), Monad m, HInit w1) => MultiRWST r (Append w1 w2) s m a -> MultiRWST r w2 s m (a, HList w1)
withMultiWritersAW :: (Monoid (HList w1), Monad m, HInit w1) => MultiRWST r (Append w1 w2) s m a -> MultiRWST r w2 s m (a, HList w1)
withMultiWritersWA :: (Monoid (HList w1), Monad m, HInit w1) => MultiRWST r (Append w1 w2) s m a -> MultiRWST r w2 s m (HList w1, a)
withMultiWritersW :: (Monoid (HList w1), Monad m, HInit w1) => MultiRWST r (Append w1 w2) s m a -> MultiRWST r w2 s m (HList w1)
withMultiState :: Monad m => s -> MultiRWST r w (s : ss) m a -> MultiRWST r w ss m (a, s)
withMultiStateAS :: Monad m => s -> MultiRWST r w (s : ss) m a -> MultiRWST r w ss m (a, s)
withMultiStateSA :: Monad m => s -> MultiRWST r w (s : ss) m a -> MultiRWST r w ss m (s, a)
withMultiStateA :: Monad m => s -> MultiRWST r w (s : ss) m a -> MultiRWST r w ss m a
withMultiStateS :: Monad m => s -> MultiRWST r w (s : ss) m a -> MultiRWST r w ss m s
withMultiState_ :: (Functor m, Monad m) => s -> MultiRWST r w (s : ss) m a -> MultiRWST r w ss m ()
withMultiStates :: Monad m => HList s1 -> MultiRWST r w (Append s1 s2) m a -> MultiRWST r w s2 m (a, HList s1)
withMultiStatesAS :: Monad m => HList s1 -> MultiRWST r w (Append s1 s2) m a -> MultiRWST r w s2 m (a, HList s1)
withMultiStatesSA :: Monad m => HList s1 -> MultiRWST r w (Append s1 s2) m a -> MultiRWST r w s2 m (HList s1, a)
withMultiStatesA :: Monad m => HList s1 -> MultiRWST r w (Append s1 s2) m a -> MultiRWST r w s2 m a
withMultiStatesS :: Monad m => HList s1 -> MultiRWST r w (Append s1 s2) m a -> MultiRWST r w s2 m (HList s1)
withMultiStates_ :: (Functor m, Monad m) => HList s1 -> MultiRWST r w (Append s1 s2) m a -> MultiRWST r w s2 m ()
inflateReader :: (Monad m, ContainsType r rs) => ReaderT r m a -> MultiRWST rs w s m a
inflateMultiReader :: Monad m => MultiReaderT r m a -> MultiRWST r w s m a
inflateWriter :: (Monad m, ContainsType w ws, Monoid w) => WriterT w m a -> MultiRWST r ws s m a
inflateMultiWriter :: (Functor m, Monad m, Monoid (HList w)) => MultiWriterT w m a -> MultiRWST r w s m a
inflateState :: (Monad m, ContainsType s ss) => StateT s m a -> MultiRWST r w ss m a
inflateMultiState :: (Functor m, Monad m) => MultiStateT s m a -> MultiRWST r w s m a
mapMultiRWST :: ss ~ (HList r, HList w, HList s) => (m (a, ss) -> m' (a', ss)) -> MultiRWST r w s m a -> MultiRWST r w s m' a'
mGetRawR :: Monad m => MultiRWST r w s m (HList r)
mGetRawW :: Monad m => MultiRWST r w s m (HList w)
mGetRawS :: Monad m => MultiRWST r w s m (HList s)
mPutRawR :: Monad m => HList r -> MultiRWST r w s m ()
mPutRawW :: Monad m => HList w -> MultiRWST r w s m ()
mPutRawS :: Monad m => HList s -> MultiRWST r w s m ()
instance [overlap ok] MonadFix m => MonadFix (MultiRWST r w s m)
instance [overlap ok] (Monad m, ContainsType a s) => MonadMultiState a (MultiRWST r w s m)
instance [overlap ok] (Monad m, ContainsType a w, Monoid a) => MonadMultiWriter a (MultiRWST r w s m)
instance [overlap ok] (Monad m, ContainsType a r) => MonadMultiReader a (MultiRWST r w s m)
instance [overlap ok] MonadTrans (MultiRWST r w s)
instance [overlap ok] Monad m => Monad (MultiRWST r w s m)
instance [overlap ok] (Applicative m, Monad m) => Applicative (MultiRWST r w s m)
instance [overlap ok] Functor f => Functor (MultiRWST r w s f)
