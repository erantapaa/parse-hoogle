-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | VHDL AST and pretty printer
--   
--   VHDL AST and pretty printer, should only be used for building AST's,
--   not as part of a VHDL parser
@package vhdl
@version 0.1.2.1


-- | ForSyDe pretty-printing class and auxiliar functions.
module Language.VHDL.Ppr

-- | Pretty printing class
class Ppr a
ppr :: Ppr a => a -> Doc

-- | Pretty printing class with associated printing options
class PprOps ops toPpr | toPpr -> ops
pprOps :: PprOps ops toPpr => ops -> toPpr -> Doc
dot :: Doc
vSpace :: Doc
multiVSpace :: Int -> Doc
ppr_list :: Ppr a => (Doc -> Doc -> Doc) -> [a] -> Doc
pprOps_list :: PprOps ops toPpr => ops -> (Doc -> Doc -> Doc) -> [toPpr] -> Doc

-- | Join two documents vertically leaving n vertical spaces between them
vNSpaces :: Int -> Doc -> Doc -> Doc
vSemi :: Doc -> Doc -> Doc
vComma :: Doc -> Doc -> Doc
hComma :: Doc -> Doc -> Doc

-- | apply sep to a list of prettyprintable elements, previously
--   interspersing commas
commaSep :: Ppr a => [a] -> Doc

-- | Only append if both of the documents are non-empty
($++$) :: Doc -> Doc -> Doc

-- | Only append if both of the documents are non-empty
(<++>) :: Doc -> Doc -> Doc

-- | Enclose in parenthesis only if the document is non-empty
parensNonEmpty :: Doc -> Doc

-- | Enclose in parenthesis only if the predicate is True
parensIf :: Bool -> Doc -> Doc
instance Ppr Doc


-- | A VHDL 93 subset AST (Abstract Syntax Tree), coded so that it can be
--   easy to extend, please see doc<i>VHDL</i>vhdl93-syntax.html as
--   reference in order to extend it (this AST is based on that grammar)
module Language.VHDL.AST
data VHDLId
Basic :: String -> VHDLId
Extended :: String -> VHDLId

-- | Obtain the String of a VHDL identifier
fromVHDLId :: VHDLId -> String

-- | unsafely create a basic VHDLId (without cheking if the string is
--   correct)
unsafeVHDLBasicId :: String -> VHDLId

-- | unsafely create an exteded VHDLId (without cheking if the string is
--   correct)
unsafeVHDLExtId :: String -> VHDLId

-- | Create a VHDL basic identifier from a String, previously checking if
--   the String is correct
mkVHDLBasicId :: String -> EProne VHDLId

-- | Create a VHDL extended identifier from a String, previously checking
--   if the String is correct. The input string must not include the
--   initial and ending backslashes nad the intermediate backslashes
--   shouldn't be escaped.
mkVHDLExtId :: String -> EProne VHDLId

-- | Unsafely append a string to a VHDL identifier (i.e. without checking
--   if the resulting identifier is valid)
unsafeIdAppend :: VHDLId -> String -> VHDLId

-- | special characters as defined in the VHDL93 standard
specialChars :: [Char]

-- | other special characters as defined in the VHDL93 standard
otherSpecialChars :: [Char]

-- | Reserved identifiers
reservedWords :: [String]
data DesignFile
DesignFile :: [ContextItem] -> [LibraryUnit] -> DesignFile
data ContextItem
Library :: VHDLId -> ContextItem
Use :: SelectedName -> ContextItem
data LibraryUnit
LUEntity :: EntityDec -> LibraryUnit
LUArch :: ArchBody -> LibraryUnit
LUPackageDec :: PackageDec -> LibraryUnit
LUPackageBody :: PackageBody -> LibraryUnit
data EntityDec
EntityDec :: VHDLId -> [IfaceSigDec] -> EntityDec

-- | interface_signal_declaration We don't allow the <a>id1,id2,id3</a>
--   syntax, only one identifier is allowed at once The Mode is mandatory
--   Bus is not allowed Preasigned values are not allowed Subtype
--   indications are not allowed, just a typemark Constraints are not
--   allowed: just add a new type with the constarint in ForSyDe.vhd if it
--   is required
data IfaceSigDec
IfaceSigDec :: VHDLId -> Mode -> TypeMark -> IfaceSigDec

-- | type_mark We don't distinguish between type names and subtype names We
--   dont' support selected names, only simple names because we won't need
--   name selection (i.e. Use clauses will make name selection unnecesary)
type TypeMark = SimpleName

-- | mode INOUT | BUFFER | LINKAGE are not allowed
data Mode
In :: Mode
Out :: Mode

-- | architecture_body [ ARCHITECTURE ] and [ architecture_simple_name ]
--   are not allowed
data ArchBody
ArchBody :: VHDLId -> VHDLName -> [BlockDecItem] -> [ConcSm] -> ArchBody

-- | package_declaration [ PACKAGE ] and [ package_simple_name ] are not
--   allowed
data PackageDec
PackageDec :: VHDLId -> [PackageDecItem] -> PackageDec

-- | package_declarative_item only type declarations, subtype declarations
--   and subprogram specifications (working as subprogram_declaration)
--   allowed
data PackageDecItem
PDITD :: TypeDec -> PackageDecItem
PDISD :: SubtypeDec -> PackageDecItem
PDISS :: SubProgSpec -> PackageDecItem

-- | package_body [ PACKAGE ] and [ package_simple_name ] are not allowed
data PackageBody
PackageBody :: VHDLId -> [PackageBodyDecItem] -> PackageBody

-- | only subprogram_body is allowed
type PackageBodyDecItem = SubProgBody

-- | subtype-declaration
data SubtypeDec
SubtypeDec :: VHDLId -> SubtypeIn -> SubtypeDec

-- | subtype_indication resolution functions are not permitted
data SubtypeIn
SubtypeIn :: TypeMark -> (Maybe SubtypeConstraint) -> SubtypeIn

-- | constraint Only index constraints are allowed
type Constraint = IndexConstraint
data SubtypeConstraint
ConstraintIndex :: Constraint -> SubtypeConstraint
ConstraintRange :: Range -> SubtypeConstraint

-- | range the direction must always be "to"
data Range
AttribRange :: AttribName -> Range
SubTypeRange :: Expr -> Expr -> Range
ToRange :: Expr -> Expr -> Range
DownRange :: Expr -> Expr -> Range

-- | index_constraint
data IndexConstraint
IndexConstraint :: [DiscreteRange] -> IndexConstraint

-- | discrete_range only ranges are allowed
type DiscreteRange = Range

-- | type_declaration only full_type_declarations are allowed
data TypeDec
TypeDec :: VHDLId -> TypeDef -> TypeDec

-- | type_declaration only composite types and enumeration types (a
--   specific scalar type)
data TypeDef
TDA :: ArrayTypeDef -> TypeDef
TDR :: RecordTypeDef -> TypeDef
TDE :: EnumTypeDef -> TypeDef
TDI :: IntegerTypeDef -> TypeDef

-- | array_type_definition unconstrained_array_definition
--   constrained_array_definition A TypeMark is used instead of a
--   subtype_indication. If subtyping is required, declare a subtype
--   explicitly.
data ArrayTypeDef
UnconsArrayDef :: [TypeMark] -> TypeMark -> ArrayTypeDef
ConsArrayDef :: IndexConstraint -> TypeMark -> ArrayTypeDef

-- | record_type_definition [ record_type_simple_name ] not allowed
data RecordTypeDef
RecordTypeDef :: [ElementDec] -> RecordTypeDef

-- | element_declaration multi-identifier element declarations not allowed
--   element_subtype_definition is simplified to a type_mark
data ElementDec
ElementDec :: VHDLId -> TypeMark -> ElementDec

-- | enumeration_type_definition enumeration literals can only be
--   identifiers
data EnumTypeDef
EnumTypeDef :: [VHDLId] -> EnumTypeDef

-- | integer_type_definition integer literals can only be numbers
data IntegerTypeDef
IntegerTypeDef :: DiscreteRange -> IntegerTypeDef

-- | name operator_names are not allowed
data VHDLName
NSimple :: SimpleName -> VHDLName
NSelected :: SelectedName -> VHDLName
NIndexed :: IndexedName -> VHDLName
NSlice :: SliceName -> VHDLName
NAttribute :: AttribName -> VHDLName

-- | simple_name
type SimpleName = VHDLId

-- | selected_name
data SelectedName
(:.:) :: Prefix -> Suffix -> SelectedName

-- | indexed_name note that according to the VHDL93 grammar the index list
--   cannot be empty
data IndexedName
IndexedName :: Prefix -> [Expr] -> IndexedName

-- | prefix only names (no function calls)
type Prefix = VHDLName

-- | suffix no character or operator symbols are accepted
data Suffix
SSimple :: SimpleName -> Suffix
All :: Suffix

-- | slice_name
data SliceName
SliceName :: Prefix -> DiscreteRange -> SliceName

-- | attribute_name signatures are not allowed
data AttribName
AttribName :: Prefix -> VHDLName -> (Maybe Expr) -> AttribName

-- | block_declarative_item Only subprogram bodies and signal declarations
--   are allowed
data BlockDecItem
BDISPB :: SubProgBody -> BlockDecItem
BDISD :: SigDec -> BlockDecItem

-- | subprogram_body No subprogram kind nor designator is allowed
data SubProgBody
SubProgBody :: SubProgSpec -> [SubProgDecItem] -> [SeqSm] -> SubProgBody

-- | subprogram_declarative_item only varaible declarations are allowed.
data SubProgDecItem
SPVD :: VarDec -> SubProgDecItem
SPCD :: ConstDec -> SubProgDecItem
SPSB :: SubProgBody -> SubProgDecItem

-- | variable_declaration identifier lists are not allowed
data VarDec
VarDec :: VHDLId -> SubtypeIn -> (Maybe Expr) -> VarDec
data ConstDec
ConstDec :: VHDLId -> SubtypeIn -> (Maybe Expr) -> ConstDec

-- | subprogram_specification Only Functions are allowed [Pure | Impure] is
--   not allowed Only an identifier is valid as the designator In the
--   formal parameter list only variable declarations are accepted
data SubProgSpec
Function :: VHDLId -> [IfaceVarDec] -> TypeMark -> SubProgSpec

-- | interface_variable_declaration [variable] is not allowed We don't
--   allow the <a>id1,id2,id3</a> syntax, only one identifier is allowed
--   Mode is not allowed Resolution functions and constraints are not
--   allowed, thus a TypeMark is used instead of a subtype_indication. If
--   subtyping is required, declare a subtype explicitly.
data IfaceVarDec
IfaceVarDec :: VHDLId -> TypeMark -> IfaceVarDec

-- | sequential_statement Only If, case, return, for loops, assignment,
--   <tt>wait for</tt> procedure calls allowed. Only for loops are allowed
--   (thus loop_statement doesn't exist) and cannot be provided labels. The
--   target cannot be an aggregate. General wait statements are not
--   allowed, only <tt>wait for</tt> It is incorrect to have an empty
--   [CaseSmAlt]
data SeqSm
IfSm :: Expr -> [SeqSm] -> [ElseIf] -> (Maybe Else) -> SeqSm
CaseSm :: Expr -> [CaseSmAlt] -> SeqSm
ReturnSm :: (Maybe Expr) -> SeqSm
ForSM :: VHDLId -> DiscreteRange -> [SeqSm] -> SeqSm
(:=) :: VHDLName -> Expr -> SeqSm
WaitFor :: Expr -> SeqSm
SigAssign :: VHDLName -> Wform -> SeqSm
ProcCall :: VHDLName -> [AssocElem] -> SeqSm

-- | helper type, they doesn't exist in the origianl grammar
data ElseIf
ElseIf :: Expr -> [SeqSm] -> ElseIf

-- | helper type, it doesn't exist in the origianl grammar
data Else
Else :: [SeqSm] -> Else

-- | case_statement_alternative it is incorrect to have an empty [Choice]
data CaseSmAlt
CaseSmAlt :: [Choice] -> [SeqSm] -> CaseSmAlt

-- | choice although any expression is allowed the grammar specfically only
--   allows simple_expressions (not covered in this AST)
data Choice
ChoiceE :: Expr -> Choice
Others :: Choice

-- | signal_declaration We don't allow the <a>id1,id2,id3</a> syntax, only
--   one identifier is allowed at once Resolution functions and constraints
--   are not allowed, thus a TypeMark is used instead of a
--   subtype_indication Signal kinds are not allowed
data SigDec
SigDec :: VHDLId -> TypeMark -> (Maybe Expr) -> SigDec

-- | concurrent_statement only block statements, component instantiations
--   and signal assignments are allowed
data ConcSm
CSBSm :: BlockSm -> ConcSm
CSSASm :: ConSigAssignSm -> ConcSm
CSISm :: CompInsSm -> ConcSm
CSPSm :: ProcSm -> ConcSm
CSGSm :: GenerateSm -> ConcSm

-- | block_statement Generics are not supported The port_clause (with only
--   signals) and port_map_aspect are mandatory The ending [ block_label ]
--   is not allowed
data BlockSm
BlockSm :: Label -> [IfaceSigDec] -> PMapAspect -> [BlockDecItem] -> [ConcSm] -> BlockSm

-- | port_map_aspect
newtype PMapAspect
PMapAspect :: [AssocElem] -> PMapAspect

-- | label
type Label = VHDLId

-- | association_element
data AssocElem
(:=>:) :: Maybe (FormalPart) -> ActualPart -> AssocElem

-- | formal_part We only accept a formal_designator (which is a name after
--   all), in the forme of simple name (no need for selected names)
--   <a>function_name ( formal_designator )</a> and <a>type_mark (
--   formal_designator )</a> are not allowed
type FormalPart = SimpleName

-- | actual_part We only accept an actual_designator, <a>function_name (
--   actual_designator )</a> and <a>type_mark ( actual_designator )</a> are
--   not allowed
type ActualPart = ActualDesig

-- | actual_designator
data ActualDesig
ADName :: VHDLName -> ActualDesig
ADExpr :: Expr -> ActualDesig
Open :: ActualDesig

-- | concurrent_signal_assignment_statement Only
--   conditional_signal_assignment is allowed (without options) The LHS
--   (targets) are simply signal names, no aggregates
data ConSigAssignSm
(:<==:) :: VHDLName -> ConWforms -> ConSigAssignSm

-- | conditional_waveforms
data ConWforms
ConWforms :: [WhenElse] -> Wform -> (Maybe When) -> ConWforms

-- | Helper type, it doesn't exist in the VHDL grammar
data WhenElse
WhenElse :: Wform -> Expr -> WhenElse

-- | Helper type, it doesn't exist in the VHDL grammar
newtype When
When :: Expr -> When

-- | waveform although it is possible to leave [Expr] empty, that's
--   obviously not valid VHDL waveform
data Wform
Wform :: [WformElem] -> Wform
Unaffected :: Wform

-- | waveform_element Null is not accepted
data WformElem
WformElem :: Expr -> (Maybe Expr) -> WformElem

-- | component_instantiation_statement No generics supported The port map
--   aspect is mandatory
data CompInsSm
CompInsSm :: Label -> InsUnit -> PMapAspect -> CompInsSm

-- | process_statement The label is mandatory Only simple names are
--   accepted in the sensitivity list No declarative part is allowed
data ProcSm
ProcSm :: Label -> [SimpleName] -> [SeqSm] -> ProcSm

-- | instantiated_unit Only Entities are allowed and their architecture
--   cannot be specified
data InsUnit
IUEntity :: VHDLName -> InsUnit
data GenerateSm
GenerateSm :: Label -> GenSm -> [BlockDecItem] -> [ConcSm] -> GenerateSm
data GenSm
ForGn :: VHDLId -> DiscreteRange -> GenSm
IfGn :: Expr -> GenSm

-- | expression, instead of creating an AST like the grammar (see commented
--   section below) we made our own expressions which are easier to handle,
--   but which don't don't show operand precedence (that is a
--   responsibility of the pretty printer)
data Expr
And :: Expr -> Expr -> Expr
Or :: Expr -> Expr -> Expr
Xor :: Expr -> Expr -> Expr
Nand :: Expr -> Expr -> Expr
Nor :: Expr -> Expr -> Expr
Xnor :: Expr -> Expr -> Expr
(:=:) :: Expr -> Expr -> Expr
(:/=:) :: Expr -> Expr -> Expr
(:<:) :: Expr -> Expr -> Expr
(:<=:) :: Expr -> Expr -> Expr
(:>:) :: Expr -> Expr -> Expr
(:>=:) :: Expr -> Expr -> Expr
Sll :: Expr -> Expr -> Expr
Srl :: Expr -> Expr -> Expr
Sla :: Expr -> Expr -> Expr
Sra :: Expr -> Expr -> Expr
Rol :: Expr -> Expr -> Expr
Ror :: Expr -> Expr -> Expr
(:+:) :: Expr -> Expr -> Expr
(:-:) :: Expr -> Expr -> Expr
(:&:) :: Expr -> Expr -> Expr
Neg :: Expr -> Expr
Pos :: Expr -> Expr
(:*:) :: Expr -> Expr -> Expr
(:/:) :: Expr -> Expr -> Expr
Mod :: Expr -> Expr -> Expr
Rem :: Expr -> Expr -> Expr
(:**:) :: Expr -> Expr -> Expr
Abs :: Expr -> Expr
Not :: Expr -> Expr
PrimName :: VHDLName -> Expr
PrimLit :: Literal -> Expr
PrimFCall :: FCall -> Expr
Aggregate :: [ElemAssoc] -> Expr

-- | Logical Operators precedence
logicalPrec :: Int

-- | Relational Operators Precedence
relationalPrec :: Int

-- | Shift Operators Precedence
shiftPrec :: Int

-- | Plus Operators precedence
plusPrec :: Int

-- | Sign Operators Precedence
signPrec :: Int

-- | Multplying Operators Precedecne
multPrec :: Int

-- | Miscellaneous Operators Precedence
miscPrec :: Int

-- | element_association only one choice is allowed
data ElemAssoc
ElemAssoc :: (Maybe Choice) -> Expr -> ElemAssoc

-- | literal Literals are expressed as a string (remember we are generating
--   code, not parsing)
type Literal = String

-- | function_call
data FCall
FCall :: VHDLName -> [AssocElem] -> FCall
instance Show FCall
instance Show ElemAssoc
instance Show Expr
instance Show GenSm
instance Show GenerateSm
instance Show InsUnit
instance Show ProcSm
instance Show CompInsSm
instance Show WformElem
instance Show Wform
instance Show When
instance Show WhenElse
instance Show ConWforms
instance Show ConSigAssignSm
instance Show ActualDesig
instance Show AssocElem
instance Show PMapAspect
instance Show BlockSm
instance Show ConcSm
instance Show SigDec
instance Show Choice
instance Show CaseSmAlt
instance Show Else
instance Show ElseIf
instance Show SeqSm
instance Show IfaceVarDec
instance Show SubProgSpec
instance Show ConstDec
instance Show VarDec
instance Show SubProgDecItem
instance Show SubProgBody
instance Show BlockDecItem
instance Show AttribName
instance Show SliceName
instance Show Suffix
instance Show IndexedName
instance Show SelectedName
instance Show VHDLName
instance Show IntegerTypeDef
instance Show EnumTypeDef
instance Show ElementDec
instance Show RecordTypeDef
instance Show ArrayTypeDef
instance Show TypeDef
instance Show TypeDec
instance Show IndexConstraint
instance Show Range
instance Show SubtypeConstraint
instance Show SubtypeIn
instance Show SubtypeDec
instance Show PackageBody
instance Show PackageDecItem
instance Show PackageDec
instance Show ArchBody
instance Show Mode
instance Eq Mode
instance Show IfaceSigDec
instance Show EntityDec
instance Show LibraryUnit
instance Show ContextItem
instance Show DesignFile
instance Eq VHDLId
instance Show VHDLId


-- | VHDL pretty-printing instances.
module Language.VHDL.AST.Ppr
instance Ppr FCall
instance Ppr ElemAssoc
instance Ppr Expr
instance Ppr InsUnit
instance Ppr ProcSm
instance Ppr CompInsSm
instance Ppr WformElem
instance Ppr Wform
instance Ppr When
instance Ppr WhenElse
instance Ppr ConWforms
instance Ppr ConSigAssignSm
instance Ppr ActualDesig
instance Ppr AssocElem
instance Ppr PMapAspect
instance Ppr GenSm
instance Ppr GenerateSm
instance Ppr BlockSm
instance Ppr ConcSm
instance Ppr [ConcSm]
instance Ppr SigDec
instance Ppr CaseSmAlt
instance Ppr Choice
instance Ppr [CaseSmAlt]
instance Ppr Else
instance Ppr ElseIf
instance Ppr [ElseIf]
instance Ppr [SeqSm]
instance Ppr SeqSm
instance Ppr IfaceVarDec
instance Ppr SubProgSpec
instance Ppr ConstDec
instance Ppr VarDec
instance Ppr SubProgDecItem
instance Ppr SubProgBody
instance Ppr BlockDecItem
instance Ppr [BlockDecItem]
instance Ppr AttribName
instance Ppr SliceName
instance Ppr IndexedName
instance Ppr Suffix
instance Ppr SelectedName
instance Ppr VHDLName
instance Ppr IntegerTypeDef
instance Ppr EnumTypeDef
instance Ppr ElementDec
instance Ppr RecordTypeDef
instance Ppr ArrayTypeDef
instance Ppr TypeDef
instance Ppr TypeDec
instance Ppr IndexConstraint
instance Ppr Range
instance Ppr SubtypeConstraint
instance Ppr SubtypeIn
instance Ppr SubtypeDec
instance Ppr PackageBody
instance Ppr PackageDecItem
instance Ppr PackageDec
instance Ppr ArchBody
instance Ppr Mode
instance Ppr IfaceSigDec
instance Ppr [IfaceSigDec]
instance Ppr EntityDec
instance Ppr LibraryUnit
instance Ppr ContextItem
instance Ppr DesignFile
instance Ppr VHDLId
instance (Ppr a, Ppr b) => Ppr (a, b)
instance Ppr a => Ppr (Maybe a)


-- | Functions working with files in the VHDL backend.
module Language.VHDL.FileIO

-- | Write a design file to a file in disk
writeDesignFile :: DesignFile -> FilePath -> IO ()
