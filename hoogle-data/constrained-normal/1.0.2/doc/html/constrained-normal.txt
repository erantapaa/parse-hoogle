-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Normalised Deep Embeddings for Constrained Type-Class Instances
--   
--   The package provides normal forms for monads and related structures,
--   similarly to the Operational package. The difference is that we
--   parameterise the normal forms on a constraint, and apply that
--   constraint to all existential types within the normal form. This
--   allows monad (and other) instances to be generated for underlying
--   types that require constraints on their return-like and bind-like
--   operations, e.g. Set.
--   
--   This is documented in the following paper:
--   
--   The Constrained-Monad Problem. Neil Sculthorpe and Jan Bracker and
--   George Giorgidze and Andy Gill. International Conference on Functional
--   Programming, pages 287-298. ACM, 2013.
--   <a>http://dx.doi.org/10.1145/2500365.2500602</a>
--   
--   The functionality exposed by this library is also used internally by
--   the Set-Monad and RMonad packages.
@package constrained-normal
@version 1.0.2


-- | This module provides constrained normalised type classes. The ideas
--   behind this module are documented in the following paper:
--   
--   <i>The Constrained-Monad Problem</i>. Neil Sculthorpe and Jan Bracker
--   and George Giorgidze and Andy Gill. International Conference on
--   Functional Programming, pages 287-298. ACM, 2013.
--   <a>http://dx.doi.org/10.1145/2500365.2500602</a>
module Control.Monad.ConstrainedNormal
data NF :: (* -> Constraint) -> (* -> *) -> * -> *
FMap :: (x -> a) -> t x -> NF c t a
liftNF :: c a => t a -> NF c t a
lowerNF :: (forall x. c x => (x -> a) -> t x -> t a) -> NF c t a -> t a
foldNF :: (forall x. c x => (x -> a) -> t x -> r) -> NF c t a -> r
class Functor f => PointedFunctor (f :: * -> *)
point :: PointedFunctor f => a -> f a
data NPF :: (* -> Constraint) -> (* -> *) -> * -> *
Point :: a -> NPF c t a
Functor :: NF c t a -> NPF c t a
liftNPF :: c a => t a -> NPF c t a
lowerNPF :: (a -> t a) -> (forall x. c x => (x -> a) -> t x -> t a) -> NPF c t a -> t a
foldNPF :: (a -> r) -> (forall x. c x => (x -> a) -> t x -> r) -> NPF c t a -> r
data NAF :: (* -> Constraint) -> (* -> *) -> * -> *
Pure :: a -> NAF c t a
Ap :: NAF c t (x -> a) -> t x -> NAF c t a
liftNAF :: c a => t a -> NAF c t a
lowerNAF :: (forall x. x -> t x) -> (forall y z. c y => t (y -> z) -> t y -> t z) -> NAF c t a -> t a
foldNAF :: (forall x. x -> r x) -> (forall y z. c y => r (y -> z) -> t y -> r z) -> NAF c t a -> r a
data NM :: (* -> Constraint) -> (* -> *) -> * -> *
Return :: a -> NM c t a
Bind :: t x -> (x -> NM c t a) -> NM c t a
liftNM :: c a => t a -> NM c t a
lowerNM :: (a -> t a) -> (forall x. c x => t x -> (x -> t a) -> t a) -> NM c t a -> t a
foldNM :: (a -> r) -> (forall x. c x => t x -> (x -> r) -> r) -> NM c t a -> r
data NMP (c :: * -> Constraint) (t :: * -> *) (a :: *)
MZero :: NMP
MPlus :: (NMP' c t a) -> (NMP c t a) -> NMP
data NMP' :: (* -> Constraint) -> (* -> *) -> * -> *
MPReturn :: a -> NMP' c t a
MPBind :: t x -> (x -> NMP c t a) -> NMP' c t a
liftNMP :: c a => t a -> NMP c t a
lowerNMP :: t a -> (t a -> t a -> t a) -> (a -> t a) -> (forall x. c x => t x -> (x -> t a) -> t a) -> NMP c t a -> t a
foldNMP :: r -> (r -> r -> r) -> (a -> r) -> (forall x. c x => t x -> (x -> r) -> r) -> NMP c t a -> r

-- | An empty type class. This can be used when a parameter of kind
--   <tt>*</tt> <tt>-&gt;</tt> <a>Constraint</a> is needed, but no
--   constraints need to be imposed.
class Unconstrained (a :: *)
instance Unconstrained a
instance Applicative (NAF c t)
instance PointedFunctor (NAF c t)
instance Functor (NAF c t)
instance MonadPlus (NMP c t)
instance Monad (NMP c t)
instance Alternative (NMP c t)
instance Applicative (NMP c t)
instance PointedFunctor (NMP c t)
instance Functor (NMP c t)
instance Monad (NM c t)
instance Applicative (NM c t)
instance PointedFunctor (NM c t)
instance Functor (NM c t)
instance PointedFunctor (NPF c t)
instance Functor (NPF c t)
instance Functor (NF c t)
