-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Compiler for a simple functional language
--   
--   Epic is a simple functional language which compiles to reasonably
--   efficient C code, using the Boehm-Demers-Weiser garbage collector
--   (<a>http://www.hpl.hp.com/personal/Hans_Boehm/gc/</a>). It is intended
--   as a compiler back end, and is currently used as a back end for
--   Epigram (<a>http://www.e-pig.org</a>) and Idris
--   (<a>http://idris-lang.org/</a>). It can be invoked either as a library
--   or an application.
@package epic
@version 0.9.3


-- | Public interface for Epigram Supercombinator Compiler
module Epic.Compiler

-- | (Debugging) options to give to compiler
data CompileOptions

-- | Keep intermediate C file
KeepC :: CompileOptions

-- | Generate trace at run-time (debug)
Trace :: CompileOptions

-- | Show generated code
ShowBytecode :: CompileOptions

-- | Show parse tree
ShowParseTree :: CompileOptions

-- | Output a .h file too
MakeHeader :: FilePath -> CompileOptions

-- | Extra GCC option
GCCOpt :: String -> CompileOptions

-- | Generate debug info
Debug :: CompileOptions

-- | Checking level (0 none)
Checking :: Int -> CompileOptions

-- | main is defined externally (in C)
ExternalMain :: CompileOptions

-- | File to #include in main program
MainInc :: FilePath -> CompileOptions

-- | .o file to link with
LinkObj :: FilePath -> CompileOptions

-- | Compile a source file in supercombinator language to a .o
compile :: FilePath -> FilePath -> Maybe FilePath -> IO ()
compileOpts :: FilePath -> FilePath -> Maybe FilePath -> [CompileOptions] -> IO ()
compileDecls :: FilePath -> Maybe FilePath -> [Decl] -> [CompileOptions] -> IO ()

-- | Link a collection of .o files into an executable
link :: [FilePath] -> FilePath -> [CompileOptions] -> IO ()


-- | Combinators for builing Epic programs
module Epic.Epic

-- | Build expressions, with a name supply
class EpicExpr e
term :: EpicExpr e => e -> State Int Expr

-- | Build a function definition, with a name supply
class EpicFn e

-- | Build a case alternative, with a name supply
class Alternative e
data Expr

-- | A sub-term, with a name supply
type Term = State Int Expr
data Name
name :: String -> Name

-- | Application
(@@) :: (EpicExpr f, EpicExpr a) => f -> a -> Term

-- | Build a case expression with a list of alternatives
case_ :: EpicExpr e => e -> [State Int CaseAlt] -> Term

-- | Build a constructor with the given tag
con_ :: Int -> Term

-- | Build a tuple
tuple_ :: Term

-- | Case alternative for constructor with the given tag
con :: Alternative e => Int -> e -> State Int CaseAlt

-- | Case alternative for a tuple with the given tag
tuple :: Alternative e => e -> State Int CaseAlt

-- | Case alternative for a constant
constcase :: EpicExpr a => Int -> a -> State Int CaseAlt

-- | Default case if no other branches apply
defaultcase :: EpicExpr a => a -> State Int CaseAlt
if_ :: (EpicExpr a, EpicExpr t, EpicExpr e) => a -> t -> e -> Term

-- | While loops (primitive, for efficiency).
while_ :: (EpicExpr t, EpicExpr b) => t -> b -> Term

-- | While loop, with an accumulator
whileAcc_ :: (EpicExpr t, EpicExpr a, EpicExpr b) => t -> a -> b -> Term
error_ :: String -> Term

-- | Evaluate an expression lazily
lazy_ :: EpicExpr a => a -> Term

-- | Evaluate an expression but don't update the closure with the result. |
--   Use this if the expression has a side effect.
effect_ :: EpicExpr a => a -> Term
foreign_, foreignL_ :: EpicExpr e => Type -> String -> [(e, Type)] -> Term
foreignConst_, foreignConstL_ :: Type -> String -> Term
let_ :: (LetExpr e, EpicExpr val) => val -> e -> State Int Expr

-- | Let bindings with an explicit name
letN_ :: (EpicExpr val, EpicExpr scope) => Name -> val -> scope -> Term

-- | Update a local variable (could be an explicit name or bound with a
--   lambda, so we let it be an <a>Expr</a>.
update_ :: (EpicExpr val, EpicExpr scope) => Expr -> val -> scope -> Term
op_ :: (EpicExpr a, EpicExpr b) => Op -> a -> b -> Term

-- | Constant string
str :: String -> Term

-- | Constant integer
int :: Int -> Term

-- | Constant big integer
bigint :: Integer -> Term

-- | Constant float
float :: Double -> Term

-- | Constant character
char :: Char -> Term

-- | Constant bool
bool :: Bool -> Term

-- | Constructor for the unit type
unit_ :: Term

-- | Project an argument from an expression which evaluates to constructor
--   form.
(!.) :: EpicExpr t => t -> Int -> Term

-- | Reference to a function name
fn :: String -> Term

-- | Reference to a function name
ref :: Name -> Term

-- | Sequence terms --- evaluate the first then second
(+>) :: EpicExpr c => c -> Term -> Term

-- | Evaluate an expression under manually allocated memory. Creates a pool
--   of memory. All allocation is from this pool, and there is no garbage
--   collection. The pool is freed after evaluation.
malloc_ :: (EpicExpr a, EpicExpr b) => a -> b -> Term

-- | Evaluate an expression under garbage collected memory, and output how
--   much was allocated during evaluation.
mallocTrace_ :: EpicExpr a => a -> Term
data Type
tyInt, tyFloat, tyBool, tyChar, tyBigInt :: Type
tyString, tyAny, tyUnit, tyPtr :: Type
tyC :: String -> Type
data Op
plus_, divideF_, timesF_, minusF_, plusF_, divide_, times_, minus_ :: Op
eq_ :: Op
lt_, shiftr_, shiftl_, gteF_, gtF_, lteF_, ltF_, gte_, gt_, lte_ :: Op
eqF_ :: Op

-- | Top level declarations
data EpicDecl

-- | Normal function
EpicFn :: Name -> e -> EpicDecl

-- | Epic function defined in a separate .o
EpicExt :: Name -> Int -> EpicDecl

-- | Include a C header
Include :: String -> EpicDecl

-- | Link to a C library
Link :: String -> EpicDecl

-- | Export a C type
CType :: String -> EpicDecl
data Program
mkProgram :: [EpicDecl] -> Program

-- | Compile a program to an executable
compile :: Program -> FilePath -> IO ()

-- | Compile a program to a .o
compileObj :: Program -> FilePath -> IO ()

-- | Link a collection of object files. By convention, the entry point is
--   the function called <tt>main</tt>.
link :: [FilePath] -> FilePath -> IO ()

-- | Compile a program to an executable, with options
compileWith :: [CompileOptions] -> Program -> FilePath -> IO ()

-- | Compile a program to a .o, with options
compileObjWith :: [CompileOptions] -> Program -> FilePath -> IO ()

-- | Link a collection of object files, with options. By convention, the
--   entry point is the function called <tt>main</tt>.
linkWith :: [CompileOptions] -> [FilePath] -> FilePath -> IO ()
run :: Program -> IO ()
evaluate :: EpicExpr e => Program -> e -> Expr

-- | (Debugging) options to give to compiler
data CompileOptions

-- | Keep intermediate C file
KeepC :: CompileOptions

-- | Generate trace at run-time (debug)
Trace :: CompileOptions

-- | Show generated code
ShowBytecode :: CompileOptions

-- | Show parse tree
ShowParseTree :: CompileOptions

-- | Output a .h file too
MakeHeader :: FilePath -> CompileOptions

-- | Extra GCC option
GCCOpt :: String -> CompileOptions

-- | Generate debug info
Debug :: CompileOptions

-- | Checking level (0 none)
Checking :: Int -> CompileOptions

-- | main is defined externally (in C)
ExternalMain :: CompileOptions

-- | File to #include in main program
MainInc :: FilePath -> CompileOptions

-- | .o file to link with
LinkObj :: FilePath -> CompileOptions

-- | Some default definitions: putStr, putStrLn, readStr, append,
--   intToString
basic_defs :: [EpicDecl]
instance Show EpicDecl
instance EpicExpr sc => LetExpr (Name, sc)
instance LetExpr (Expr -> Term)
instance Alternative e => Alternative ([Name], e)
instance Alternative e => Alternative (Expr -> e)
instance Alternative Term
instance Alternative Expr
instance Cases c => Cases [c]
instance Cases CaseAlt
instance EpicFn e => EpicFn ([Name], e)
instance EpicFn e => EpicFn (Expr -> e)
instance EpicFn Term
instance EpicFn Expr
instance EpicExpr e => EpicExpr ([Name], e)
instance EpicExpr e => EpicExpr (Expr -> e)
instance EpicExpr String
instance EpicExpr Term
instance EpicExpr Expr
instance Show Term
