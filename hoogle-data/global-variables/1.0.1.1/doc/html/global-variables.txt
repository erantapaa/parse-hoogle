-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Namespaced, global, and top-level mutable variables without
unsafePerformIO.
--   
--   <a>Data.Global</a> provides a global namespace of <a>IORef</a>s,
--   <a>MVar</a>s and <a>TVar</a>s. This namespace may be accessed in pure
--   code. Yet reading and writing to those <a>IORef</a>s, <a>MVar</a>s and
--   <a>TVar</a>s happens still in their respective monads.
--   
--   <a>Data.Global</a> is designed to meet the following use cases:
--   
--   <ul>
--   <li>Simplify the declaration of top-level mutable variables, by
--   avoiding any pragmas as well as <a>unsafePerformIO</a>.</li>
--   <li>Avoid having to pass references explicitly throughout the program
--   in order to let distant parts communicate.</li>
--   <li>Enable a communication by convention scheme, where e.g. different
--   libraries may communicate without code dependencies.</li>
--   <li>Simplify the "configuration problem" - at least for code in the IO
--   monad.</li>
--   </ul>
--   
--   Note, that this library does not encourage sloppy software design by
--   re-introducing all bad effects of global variables. Nevertheless,
--   sometimes global variables are a suitable solution to a problem. In
--   that case <a>Data.Global</a> simplifies and extends their handling
--   significantly.
--   
--   Examples are in the documentation of <a>Data.Global</a>.
--   
--   Version History:
--   
--   <ol>
--   <li>0.1.1: made compatible with stm-2.3</li>
--   <li>0.1.0: added declareEmptyMVar and widened the stm dependency</li>
--   <li>0: First public release</li>
--   </ol>
@package global-variables
@version 1.0.1.1


-- | <a>Global</a> provides a global namespace of <tt>IORef</tt>s,
--   <tt>MVar</tt>s and <tt>TVar</tt>s. This namespace may be accessed in
--   pure code. Yet reading and writing to those <tt>IORef</tt>s,
--   <tt>MVar</tt>s and <tt>TVar</tt>s happens still in their respective
--   monads.
--   
--   <a>Global</a> is designed to meet the following use cases:
--   
--   <ul>
--   <li>Simplify the declaration of top-level mutable variables, by
--   avoiding any pragmas as well as <tt>unsafePerformIO</tt>.</li>
--   <li>Avoid having to pass references explicitly throughout the program
--   in order to let distant parts communicate.</li>
--   <li>Enable a communication by convention scheme, where e.g. different
--   libraries may communicate without code dependencies.</li>
--   <li>Simplify the <a>configuration problem</a> - at least for code in
--   the IO monad.</li>
--   </ul>
--   
--   Note, that this library does not encourage sloppy software design by
--   re-introducing all bad effects of global variables. Nevertheless,
--   sometimes global variables are a suitable solution to a problem. In
--   that case <a>Global</a> simplifies and extends their handling
--   significantly.
module Data.Global

-- | <tt>declareIORef name val</tt> maps a variable name to an
--   <a>IORef</a>. Calling it multiple times with the same <tt>name</tt>
--   and type of <tt>val</tt> will always return the same <a>IORef</a>.
--   
--   <pre>
--   someVar :: IORef Int
--   someVar = declareMVar "my-global-some-var" 0
--   </pre>
--   
--   Note, there is <i>no</i> need to use <a>unsafePerformIO</a> or to add
--   a <tt>{-# NOINLINE someVar #-}</tt> pragma in order to define
--   top-level <a>IORef</a>s.
declareIORef :: Typeable a => String -> a -> IORef a

-- | <tt>declareMVar name val</tt> maps a variable name to an <a>MVar</a>.
--   Calling it multiple times with the same <tt>name</tt> and type of
--   <tt>val</tt> will always return the same <a>MVar</a>.
--   
--   <pre>
--   someVar :: MVar Int
--   someVar = declareMVar "my-global-some-var" 0
--   </pre>
--   
--   Note, there is <i>no</i> need to use <a>unsafePerformIO</a> or to add
--   a <tt>{-# NOINLINE someVar #-}</tt> pragma in order to define
--   top-level <a>MVar</a>s.
declareMVar :: Typeable a => String -> a -> MVar a

-- | <tt>declareEmptyMVar name</tt> maps a variable name to an <a>MVar</a>.
--   Calling it multiple times with the same <tt>name</tt> and type of the
--   expected <a>MVar</a> will always return the same <a>MVar</a>.
--   
--   <pre>
--   someVar :: MVar Int
--   someVar = declareEmptyMVar "my-global-some-var"
--   </pre>
--   
--   Note, there is <i>no</i> need to use <a>unsafePerformIO</a> or to add
--   a <tt>{-# NOINLINE someVar #-}</tt> pragma in order to define
--   top-level <a>MVar</a>s.
declareEmptyMVar :: Typeable a => String -> MVar a

-- | <tt>declareTVar name val</tt> maps a variable name to an <a>TVar</a>.
--   Calling it multiple times with the same <tt>name</tt> and type of
--   <tt>val</tt> will always return the same <a>TVar</a>.
--   
--   <pre>
--   someVar :: TVar Int
--   someVar = declareMVar "my-global-some-var" 0
--   </pre>
--   
--   Note, there is <i>no</i> need to use <a>unsafePerformIO</a> or to add
--   a <tt>{-# NOINLINE someVar #-}</tt> pragma in order to define
--   top-level <a>TVar</a>s.
declareTVar :: Typeable a => String -> a -> TVar a
