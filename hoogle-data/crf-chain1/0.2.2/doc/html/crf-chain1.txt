-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | First-order, linear-chain conditional random fields
--   
--   The library provides efficient implementation of the first-order,
--   linear-chain conditional random fields (CRFs).
--   
--   Important feature of the implemented flavour of CRFs is that
--   transition features which are not included in the CRF model are
--   considered to have probability of 0. It is particularly useful when
--   the training material determines the set of possible label transitions
--   (e.g. when using the IOB encoding method). Furthermore, this design
--   decision makes the implementation much faster for sparse datasets.
@package crf-chain1
@version 0.2.2

module Data.CRF.Chain1.Dataset.Internal

-- | An observation.
newtype Ob
Ob :: Int -> Ob
unOb :: Ob -> Int

-- | A label.
newtype Lb
Lb :: Int -> Lb
unLb :: Lb -> Int

-- | Simple word represented by a list of its observations.
newtype X
X :: Vector Ob -> X
_unX :: X -> Vector Ob

-- | X constructor.
mkX :: [Ob] -> X

-- | X deconstructor symetric to mkX.
unX :: X -> [Ob]

-- | Sentence of words.
type Xs = Vector X

-- | Probability distribution over labels.
newtype Y
Y :: Vector (Lb, Double) -> Y
_unY :: Y -> Vector (Lb, Double)

-- | Y constructor.
mkY :: [(Lb, Double)] -> Y

-- | Y deconstructor symetric to mkY.
unY :: Y -> [(Lb, Double)]

-- | Sentence of Y (label choices).
type Ys = Vector Y
instance Show X
instance Read X
instance Eq X
instance Ord X
instance Show Y
instance Read Y
instance Eq Y
instance Ord Y
instance Vector Vector Lb
instance MVector MVector Lb
instance Unbox Lb
instance Show Lb
instance Read Lb
instance Eq Lb
instance Ord Lb
instance Binary Lb
instance Num Lb
instance Ix Lb
instance Vector Vector Ob
instance MVector MVector Ob
instance Unbox Ob
instance Show Ob
instance Read Ob
instance Eq Ob
instance Ord Ob
instance Binary Ob

module Data.CRF.Chain1.Feature

-- | A Feature is either an observation feature OFeature o x, which models
--   relation between observation o and label x assigned to the same word,
--   or a transition feature TFeature x y (SFeature x for the first
--   position in the sentence), which models relation between two
--   subsequent labels, x (on i-th position) and y (on (i-1)-th positoin).
data Feature
SFeature :: {-# UNPACK #-} !Lb -> Feature
TFeature :: {-# UNPACK #-} !Lb -> {-# UNPACK #-} !Lb -> Feature
OFeature :: {-# UNPACK #-} !Ob -> {-# UNPACK #-} !Lb -> Feature

-- | Is it a <a>SFeature</a>?
isSFeat :: Feature -> Bool

-- | Is it a <a>TFeature</a>?
isTFeat :: Feature -> Bool

-- | Is it an <a>OFeature</a>?
isOFeat :: Feature -> Bool

-- | All features with assigned probabilities in given labeled sentence.
featuresIn :: Xs -> Ys -> [(Feature, LogFloat)]
instance Show Feature
instance Eq Feature
instance Ord Feature
instance Binary Feature


-- | The module provides feature selection functions which extract features
--   present in the dataset, i.e. features which directly occure the
--   dataset.
--   
--   You can mix functions defined here with the selection functions from
--   the <a>Data.CRF.Chain1.Feature.Hidden</a> module.
module Data.CRF.Chain1.Feature.Present

-- | <a>Feature</a>s of all kinds which occur in the dataset.
presentFeats :: [(Xs, Ys)] -> [Feature]

-- | <a>OFeature</a>s which occur in the dataset.
presentOFeats :: [(Xs, Ys)] -> [Feature]

-- | <a>TFeature</a>s which occur in the dataset.
presentTFeats :: [(a, Ys)] -> [Feature]

-- | <a>SFeature</a>s which occur in the dataset.
presentSFeats :: [(a, Ys)] -> [Feature]


-- | The module provides feature selection functions which extract hidden
--   features, i.e. all features which can be constructed (by means of
--   cartesian product) on the basis of the set of observations and the set
--   of labels. For example, the list of hidden observation features can be
--   defined as <a>OFeature</a> <tt>&lt;$&gt;</tt> os <tt>&lt;*&gt;</tt>
--   xs, where os is a list of all observations and xs is a list of all
--   labels.
--   
--   You can mix functions defined here with the selection functions from
--   the <a>Data.CRF.Chain1.Feature.Present</a> module.
module Data.CRF.Chain1.Feature.Hidden

-- | Hidden <a>Feature</a>s of all types which can be constructed based on
--   the dataset.
hiddenFeats :: [(Xs, Ys)] -> [Feature]

-- | Hidden <a>OFeature</a>s which can be constructed based on the dataset.
hiddenOFeats :: [(Xs, Ys)] -> [Feature]

-- | Hidden <a>TFeature</a>s which can be constructed based on the dataset.
hiddenTFeats :: [(Xs, Ys)] -> [Feature]

-- | Hidden <a>SFeature</a>s which can be constructed based on the dataset.
hiddenSFeats :: [(Xs, Ys)] -> [Feature]


-- | Internal implementation of the CRF model.
module Data.CRF.Chain1.Model

-- | A feature index. To every model feature a unique index is assigned.
newtype FeatIx
FeatIx :: Int -> FeatIx
unFeatIx :: FeatIx -> Int

-- | The model is realy a map from features to potentials, but for the sake
--   of efficiency the internal representation is more complex.
data Model
Model :: Vector Double -> Map Feature FeatIx -> Int -> Vector FeatIx -> Vector (Vector LbIx) -> Vector (Vector LbIx) -> Vector (Vector LbIx) -> Model

-- | Value (potential) of the model for feature index.
values :: Model -> Vector Double

-- | A map from features to feature indices
ixMap :: Model -> Map Feature FeatIx

-- | Number of labels. The label set is of the {0, 1, .., lbNum - 1} form,
--   which is guaranteed by the codec.
lbNum :: Model -> Int

-- | Singular feature index for the given label. Index is equall to -1 if
--   feature is not present in the model.
sgIxsV :: Model -> Vector FeatIx

-- | Set of labels for the given observation which, together with the
--   observation, constitute an observation feature of the model.
obIxsV :: Model -> Vector (Vector LbIx)

-- | Set of ,,previous'' labels for the value of the ,,current'' label.
--   Both labels constitute a transition feature present in the the model.
prevIxsV :: Model -> Vector (Vector LbIx)

-- | Set of ,,next'' labels for the value of the ,,current'' label. Both
--   labels constitute a transition feature present in the the model.
nextIxsV :: Model -> Vector (Vector LbIx)

-- | Construct the model from the list of features. All parameters will be
--   set to 0. There may be repetitions in the input list.
mkModel :: [Feature] -> Model

-- | List of labels [0 .. <a>lbNum</a> - 1].
lbSet :: Model -> [Lb]

-- | Model potential defined for the given feature interpreted as a number
--   in logarithmic domain.
valueL :: Model -> FeatIx -> LogFloat

-- | Determine the index for the given feature.
featToIx :: Model -> Feature -> FeatIx

-- | Same as <a>featToIx</a> but immediately unwrap the feature index to
--   integer value.
featToInt :: Model -> Feature -> Int

-- | Potential value (in log domain) of the singular feature with the given
--   label. The value defaults to 0 when the feature is not a member of the
--   model.
sgValue :: Model -> Lb -> LogFloat

-- | List of labels which can be located on the first position of a
--   sentence together with feature indices determined by them.
sgIxs :: Model -> [LbIx]

-- | List of labels which constitute a valid feature in combination with
--   the given observation accompanied by feature indices determined by
--   these labels.
obIxs :: Model -> Ob -> [LbIx]

-- | List of ,,next'' labels which constitute a valid feature in
--   combination with the ,,current'' label accompanied by feature indices
--   determined by ,,next'' labels.
nextIxs :: Model -> Lb -> [LbIx]

-- | List of ,,previous'' labels which constitute a valid feature in
--   combination with the ,,current'' label accompanied by feature indices
--   determined by ,,previous'' labels.
prevIxs :: Model -> Lb -> [LbIx]
instance Binary Model
instance Vector Vector FeatIx
instance MVector MVector FeatIx
instance Unbox FeatIx
instance Show FeatIx
instance Eq FeatIx
instance Ord FeatIx
instance Binary FeatIx

module Data.CRF.Chain1.Inference

-- | Determine the most probable label sequence given the context of the
--   CRF model and the sentence.
tag :: Model -> Xs -> [Lb]

-- | Tag probabilities with respect to marginal distributions.
marginals :: Model -> Xs -> [[(Lb, LogFloat)]]

-- | Compute the accuracy of the model with respect to the labeled dataset.
accuracy :: Model -> [(Xs, Ys)] -> Double

-- | A list of features (represented by feature indices) defined within the
--   context of the sentence accompanied by expected probabilities
--   determined on the basis of the model.
--   
--   One feature can occur multiple times in the output list.
expectedFeaturesIn :: Model -> Xs -> [(FeatIx, LogFloat)]

-- | Normalization factor computed for the <a>Xs</a> sentence using the
--   backward computation.
zx :: Model -> Xs -> LogFloat

-- | Normalization factor computed for the <a>Xs</a> sentence using the
--   forward computation.
zx' :: Model -> Xs -> LogFloat

module Data.CRF.Chain1.Dataset.External

-- | A Word is represented by a set of observations.
type Word a = Set a

-- | A sentence of words.
type Sent a = [Word a]

-- | A probability distribution defined over elements of type a. All
--   elements not included in the map have probability equal to 0.
data Dist a

-- | Construct the probability distribution.
mkDist :: Ord a => [(a, Double)] -> Dist a

-- | A WordL is a labeled word, i.e. a word with probability distribution
--   defined over labels.
type WordL a b = (Word a, Dist b)

-- | Annotate the word with the label.
annotate :: Word a -> b -> WordL a b

-- | A sentence of labeled words.
type SentL a b = [WordL a b]

module Data.CRF.Chain1.Dataset.Codec

-- | A codec. The first component is used to encode observations of type a,
--   the second one is used to encode labels of type b.
type Codec a b = (AtomCodec a, AtomCodec b)

-- | Type synonym for the codec monad. It is important to notice that by a
--   codec we denote here a structure of two <a>AtomCodec</a>s while in the
--   monad-codec package it denotes a monad.
type CodecM a b c = Codec (Codec a b) c

-- | Encode the word and update the codec.
encodeWord'Cu :: Ord a => Word a -> CodecM a b X

-- | Encode the word and do *not* update the codec.
encodeWord'Cn :: Ord a => Word a -> CodecM a b X

-- | Encode the sentence and update the codec.
encodeSent'Cu :: Ord a => Sent a -> CodecM a b Xs

-- | Encode the sentence and do *not* update the codec.
encodeSent'Cn :: Ord a => Sent a -> CodecM a b Xs

-- | Encode the sentence using the given codec.
encodeSent :: Ord a => Codec a b -> Sent a -> Xs

-- | Encode the labeled word and update the codec.
encodeWordL'Cu :: (Ord a, Ord b) => WordL a b -> CodecM a b (X, Y)

-- | Encodec the labeled word and do *not* update the codec. If the label
--   is not in the codec, use the default value.
encodeWordL'Cn :: (Ord a, Ord b) => Int -> WordL a b -> CodecM a b (X, Y)

-- | Encode the labeled sentence and update the codec.
encodeSentL'Cu :: (Ord a, Ord b) => SentL a b -> CodecM a b (Xs, Ys)

-- | Encode the labeled sentence and do *not* update the codec. Substitute
--   the default label for any label not present in the codec.
encodeSentL'Cn :: (Ord a, Ord b) => b -> SentL a b -> CodecM a b (Xs, Ys)

-- | Encode the labeled sentence with the given codec. Substitute the
--   default label for any label not present in the codec.
encodeSentL :: (Ord a, Ord b) => b -> Codec a b -> SentL a b -> (Xs, Ys)

-- | Decode the label.
decodeLabel :: Ord b => Codec a b -> Lb -> b

-- | Decode the sequence of labels.
decodeLabels :: Ord b => Codec a b -> [Lb] -> [b]

-- | Create the codec on the basis of the labeled dataset, return the
--   resultant codec and the encoded dataset.
mkCodec :: (Ord a, Ord b) => [SentL a b] -> (Codec a b, [(Xs, Ys)])

-- | Encode the dataset with the codec.
encodeData :: Ord a => Codec a b -> [Sent a] -> [Xs]

-- | Encode the labeled dataset using the codec. Substitute the default
--   label for any label not present in the codec.
encodeDataL :: (Ord a, Ord b) => b -> Codec a b -> [SentL a b] -> [(Xs, Ys)]

module Data.CRF.Chain1.Train

-- | A conditional random field model with additional codec used for data
--   encoding.
data CRF a b
CRF :: Codec a b -> Model -> CRF a b

-- | The codec is used to transform data into internal representation,
--   where each observation and each label is represented by a unique
--   integer number.
codec :: CRF a b -> Codec a b

-- | The actual model, which is a map from <a>Feature</a>s to potentials.
model :: CRF a b -> Model

-- | Train the CRF using the stochastic gradient descent method. The
--   resulting model will contain features extracted with the user supplied
--   extraction function. You can use the functions provided by the
--   <a>Data.CRF.Chain1.Feature.Present</a> and
--   <a>Data.CRF.Chain1.Feature.Hidden</a> modules for this purpose. When
--   the evaluation data <a>IO</a> action is <a>Just</a>, the iterative
--   training process will notify the user about the current accuracy on
--   the evaluation part every full iteration over the training part.
train :: (Ord a, Ord b) => SgdArgs -> IO [SentL a b] -> Maybe (b, IO [SentL a b]) -> ([(Xs, Ys)] -> [Feature]) -> IO (CRF a b)
instance (Ord a, Ord b, Binary a, Binary b) => Binary (CRF a b)


-- | The module provides first-order, linear-chain conditional random
--   fields (CRFs).
--   
--   Important feature of the implemented flavour of CRFs is that
--   transition features which are not included in the CRF model are
--   considered to have probability of 0. It is particularly useful when
--   the training material determines the set of possible label transitions
--   (e.g. when using the IOB encoding method). Furthermore, this design
--   decision makes the implementation much faster for sparse datasets.
module Data.CRF.Chain1

-- | A Word is represented by a set of observations.
type Word a = Set a

-- | A sentence of words.
type Sent a = [Word a]

-- | A probability distribution defined over elements of type a. All
--   elements not included in the map have probability equal to 0.
data Dist a

-- | Construct the probability distribution.
mkDist :: Ord a => [(a, Double)] -> Dist a

-- | A WordL is a labeled word, i.e. a word with probability distribution
--   defined over labels.
type WordL a b = (Word a, Dist b)

-- | Annotate the word with the label.
annotate :: Word a -> b -> WordL a b

-- | A sentence of labeled words.
type SentL a b = [WordL a b]

-- | A conditional random field model with additional codec used for data
--   encoding.
data CRF a b
CRF :: Codec a b -> Model -> CRF a b

-- | The codec is used to transform data into internal representation,
--   where each observation and each label is represented by a unique
--   integer number.
codec :: CRF a b -> Codec a b

-- | The actual model, which is a map from <a>Feature</a>s to potentials.
model :: CRF a b -> Model

-- | Train the CRF using the stochastic gradient descent method. The
--   resulting model will contain features extracted with the user supplied
--   extraction function. You can use the functions provided by the
--   <a>Data.CRF.Chain1.Feature.Present</a> and
--   <a>Data.CRF.Chain1.Feature.Hidden</a> modules for this purpose. When
--   the evaluation data <a>IO</a> action is <a>Just</a>, the iterative
--   training process will notify the user about the current accuracy on
--   the evaluation part every full iteration over the training part.
train :: (Ord a, Ord b) => SgdArgs -> IO [SentL a b] -> Maybe (b, IO [SentL a b]) -> ([(Xs, Ys)] -> [Feature]) -> IO (CRF a b)

-- | Determine the most probable label sequence within the context of the
--   given sentence using the model provided by the <a>CRF</a>.
tag :: (Ord a, Ord b) => CRF a b -> Sent a -> [b]

-- | Hidden <a>Feature</a>s of all types which can be constructed based on
--   the dataset.
hiddenFeats :: [(Xs, Ys)] -> [Feature]

-- | <a>Feature</a>s of all kinds which occur in the dataset.
presentFeats :: [(Xs, Ys)] -> [Feature]
