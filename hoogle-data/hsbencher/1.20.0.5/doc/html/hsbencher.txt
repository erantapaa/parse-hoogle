-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Launch and gather data from Haskell and non-Haskell benchmarks.
--   
@package hsbencher
@version 1.20.0.5


-- | All the core types used by the rest of the HSBencher codebase.
module HSBencher.Types

-- | Make a Benchmark data structure given the core, required set of
--   fields, and uses defaults to fill in the rest. Takes target, cmdargs,
--   configs.
mkBenchmark :: FilePath -> [String] -> BenchSpace a -> Benchmark a

-- | The canonical name of a benchmark that is entered in results tables
--   and used in messages printed to the user.
--   
--   This takes the full benchmark LIST which this benchmark is part of.
--   That may be used in the future to ensure this canonical name is
--   unique.
canonicalBenchName :: [Benchmark a] -> Benchmark a -> String

-- | This may return something prettier than <a>canonicalBenchName</a>, but
--   should only be used for printing informative messages to the user, not
--   for entering data in any results table.
prettyBenchName :: [Benchmark a] -> Benchmark a -> String

-- | The all-inclusive datatype for a single Benchmark. Do NOT construct
--   values of this type directly. Rather, you should make your code robust
--   against future addition of fields to this datatype. Use
--   <a>mkBenchmark</a> followed by customizing only the fields you need.
data Benchmark a
Benchmark :: FilePath -> [String] -> BenchSpace a -> Maybe String -> Maybe Double -> Maybe BuildMethod -> Benchmark a

-- | Where is the benchmark to run? This must be a single target file or
--   directory. The convention is that this file or directory, when
--   combined with a BuildMethod, provides a self-contained way to build
--   one benchmark. The <a>buildMethods</a> field of the <a>Config</a> had
--   better contain some build method that knows how to handle this file or
--   directory.
target :: Benchmark a -> FilePath

-- | Command line argument to feed the benchmark executable.
cmdargs :: Benchmark a -> [String]

-- | The configration space to iterate over.
configs :: Benchmark a -> BenchSpace a

-- | Optional name to use to identify this benchmark, INSTEAD of the
--   basename from <a>target</a>.
progname :: Benchmark a -> Maybe String

-- | Specific timeout for this benchmark in seconds. Overrides global
--   setting.
benchTimeOut :: Benchmark a -> Maybe Double

-- | Force use of this specific build method.
overrideMethod :: Benchmark a -> Maybe BuildMethod

-- | The arguments passed (in a build-method specific way) to the running
--   benchmark.
type RunFlags = [String]

-- | The arguments passed (in a build-method specific way) into the
--   compilation process.
type CompileFlags = [String]

-- | A completely encapsulated method of building benchmarks. Cabal and
--   Makefiles are two examples of this. The user may extend it with their
--   own methods.
data BuildMethod
BuildMethod :: String -> FilePredicate -> Bool -> (Config -> BuildID -> CompileFlags -> EnvVars -> FilePath -> BenchM BuildResult) -> (PathRegistry -> BuildID -> FilePath -> BenchM ()) -> Maybe (Int -> [ParamSetting]) -> BuildMethod

-- | Identifies this build method for humans. , buildsFiles ::
--   FilePredicate , canBuild :: FilePath -&gt; IO Bool
methodName :: BuildMethod -> String

-- | Can this method build a given file/directory?
canBuild :: BuildMethod -> FilePredicate

-- | More than one build can happen at once. This implies that compile
--   always returns StandAloneBinary.
concurrentBuild :: BuildMethod -> Bool

-- | Identify the benchmark to build by its target FilePath. Compile it.
compile :: BuildMethod -> Config -> BuildID -> CompileFlags -> EnvVars -> FilePath -> BenchM BuildResult

-- | Clean any left-over build results.
clean :: BuildMethod -> PathRegistry -> BuildID -> FilePath -> BenchM ()

-- | Synthesize a list of compile/runtime settings that will control the
--   number of threads.
setThreads :: BuildMethod -> Maybe (Int -> [ParamSetting])

-- | The result of doing a build. Note that <a>compile</a> can will throw
--   an exception if compilation fails.
data BuildResult

-- | This binary can be copied and executed whenever.
StandAloneBinary :: FilePath -> BuildResult

-- | In this case the build return what you need to do the benchmark run,
--   but the directory contents cannot be touched until after than run is
--   finished.
RunInPlace :: (RunFlags -> EnvVars -> CommandDescr) -> BuildResult

-- | A description of a set of files. The description may take one of
--   multiple forms.
data FilePredicate

-- | E.g. ".hs", WITH the dot.
WithExtension :: String -> FilePredicate

-- | E.g. <a>Makefile</a> | SatisfiesPredicate (String -&gt; Bool)
IsExactly :: String -> FilePredicate

-- | A common pattern. For example, we can build a file foo.c, if it lives
--   in a directory with exactly one <a>Makefile</a>.
InDirectoryWithExactlyOne :: FilePredicate -> FilePredicate

-- | Logical or.
PredOr :: FilePredicate -> FilePredicate -> FilePredicate
AnyFile :: FilePredicate

-- | This function gives meaning to the <tt>FilePred</tt> type. It returns
--   a filepath to signal <a>True</a> and Nothing otherwise.
filePredCheck :: FilePredicate -> FilePath -> IO (Maybe FilePath)

-- | A datatype for describing (generating) benchmark configuration spaces.
--   This is accomplished by nested conjunctions and disjunctions. For
--   example, varying threads from 1-32 would be a 32-way Or. Combining
--   that with profiling on/off (product) would create a 64-config space.
--   
--   While the ParamSetting provides an *implementation* of the behavior,
--   this datatype can also be decorated with a (more easily machine
--   readable) meaning of the corresponding setting. For example,
--   indicating that the setting controls the number of threads.
data BenchSpace meaning
And :: [BenchSpace meaning] -> BenchSpace meaning
Or :: [BenchSpace meaning] -> BenchSpace meaning
Set :: meaning -> ParamSetting -> BenchSpace meaning

-- | Different types of parameters that may be set or varied.
data ParamSetting

-- | String contains runtime options, expanded and tokenized by the shell.
RuntimeParam :: String -> ParamSetting

-- | Runtime "args" are like runtime params but are more prominent. They
--   typically are part of the "key" of the benchmark.
RuntimeArg :: String -> ParamSetting

-- | String contains compile-time options, expanded and tokenized by the
--   shell.
CompileParam :: String -> ParamSetting

-- | Establish an environment variable binding during compile time.
CompileEnv :: String -> String -> ParamSetting

-- | The name of the env var and its value, respectively. For now Env Vars
--   ONLY affect runtime.
RuntimeEnv :: String -> String -> ParamSetting

-- | Takes CMD PATH, and establishes a benchmark-private setting to use
--   PATH for CMD. For example `CmdPath "ghc" "ghc-7.6.3"`.
CmdPath :: String -> String -> ParamSetting

-- | Set the cpu affinity in a particular way before launching the
--   benchmark process.
CPUSet :: CPUAffinity -> ParamSetting
data CPUAffinity

-- | Picks cores packed into as few NUMA domains as possible.
Packed :: CPUAffinity

-- | Picks cores spread over as many NUMA domains as possible.
SpreadOut :: CPUAffinity
Default :: CPUAffinity

-- | Modify a config by <a>And</a>ing in an extra param setting to *every*
--   <a>configs</a> field of *every* benchmark in the global <a>Config</a>.
andAddParam :: ParamSetting -> Config -> Config

-- | Strip all runtime options, leaving only compile-time options. This is
--   useful for figuring out how many separate compiles need to happen.
compileOptsOnly :: BenchSpace a -> BenchSpace a

-- | Is it a setting that affects compile time?
isCompileTime :: ParamSetting -> Bool

-- | Extract ALL the parameters that affect the compile-time arguments.
toCompileFlags :: [(a, ParamSetting)] -> CompileFlags
toEnvVars :: [(a, ParamSetting)] -> [(String, String)]
toCmdPaths :: [(a, ParamSetting)] -> [(String, String)]
compileTimeEnvVars :: [(a, ParamSetting)] -> EnvVars

-- | A BuildID should uniquely identify a particular (compile-time)
--   configuration, but consist only of characters that would be reasonable
--   to put in a filename. This is used to keep build results from
--   colliding.
type BuildID = String

-- | Performs a simple reformatting (stripping disallowed characters) to
--   create a build ID corresponding to a set of compile flags. To make it
--   unique we also append the target path.
makeBuildID :: FilePath -> CompileFlags -> EnvVars -> BuildID

-- | A default notion of what extra benchmark arguments actually *mean*.
data DefaultParamMeaning

-- | Set the number of threads.
Threads :: Int -> DefaultParamMeaning

-- | Which scheduler<i>implementation</i>etc.
Variant :: String -> DefaultParamMeaning
NoMeaning :: DefaultParamMeaning

-- | The global configuration for benchmarking. WARNING! This is an
--   internal data structure. You shouldn't really use it.
--   
--   This is isomorphic to `Maybe (IO ())` but it has a <a>Show</a>
--   instance.
data Config
Config :: [Benchmark DefaultParamMeaning] -> [ParamSetting] -> Maybe String -> (String, Double) -> Maybe Double -> Int -> Int -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe String -> Maybe String -> Bool -> Bool -> Bool -> Bool -> PathRegistry -> String -> String -> Integer -> String -> String -> (String, String, Int) -> [BuildMethod] -> FilePath -> CleanupAction -> OutputStream ByteString -> OutputStream ByteString -> OutputStream ByteString -> [[(String, String)]] -> Bool -> LineHarvester -> [SomePlugin] -> Map String SomePluginConf -> Config
benchlist :: Config -> [Benchmark DefaultParamMeaning]

-- | Extra parameter settings to fold into EVERY benchmark we run.
extraParams :: Config -> [ParamSetting]

-- | What identifies this set of benchmarks? In some upload backends this
--   is the name of the dataset or table.
benchsetName :: Config -> Maybe String

-- | benchlist file name and version number (e.g. X.Y) , threadsettings ::
--   [Int] -- ^ A list of #threads to test. 0 signifies non-threaded mode.
benchversion :: Config -> (String, Double)

-- | Timeout in seconds for running benchmarks (if not specified by the
--   benchmark specifically)
runTimeOut :: Config -> Maybe Double

-- | In parallel compile/run phases use at most this many threads. Defaults
--   to <tt>getNumProcessors</tt>.
maxthreads :: Config -> Int

-- | number of runs of each configuration
trials :: Config -> Int

-- | Where to start in the config space.
skipTo :: Config -> Maybe Int

-- | How many configurations to run before stopping.
runOnly :: Config -> Maybe Int

-- | How many times to retry failed benchmark configs.
retryFailed :: Config -> Maybe Int

-- | An over-ride for the run ID.
runID :: Config -> Maybe String

-- | The build ID from the continuous integration system.
ciBuildID :: Config -> Maybe String

-- | An alternate mode to run very small sizes of benchmarks for testing.
--   HSBencher relies on a convention where benchmarks WITHOUT command-line
--   arguments must do a short run.
shortrun :: Config -> Bool

-- | Invoke the build method's clean operation before compilation.
doClean :: Config -> Bool

-- | Use the "lspci" command to gather more machine details on each run.
doLSPCI :: Config -> Bool

-- | Keep going after error.
keepgoing :: Config -> Bool

-- | Paths to executables
pathRegistry :: Config -> PathRegistry

-- | Manually override the machine hostname. Defaults to the output of the
--   <a>hostname</a> command.
hostname :: Config -> String

-- | The default for the TOPOLOGY field, if a benchmark does not specify.
--   Usually, what cores we run on is fixed for a whole run of hsbencher.
defTopology :: Config -> String

-- | Seconds since Epoch.
startTime :: Config -> Integer

-- | Where to put timing results.
resultsFile :: Config -> String

-- | Where to put full, verbose testing output.
logFile :: Config -> String

-- | Branch, revision hash, depth.
gitInfo :: Config -> (String, String, Int)

-- | Known methods for building benchmark targets. Starts with
--   cabal<i>make</i>ghc, can be extended by user.
buildMethods :: Config -> [BuildMethod]

-- | The path for build products that is managed (and cleared) by
--   HSBencher. Usually a relative path.
binDir :: Config -> FilePath

-- | An optional action to run between benchmark runs to make sure the
--   system is clean. For example, this could kill off zombie processes if
--   any were left by previous benchmark trials.
systemCleaner :: Config -> CleanupAction

-- | Internal use only
logOut :: Config -> OutputStream ByteString

-- | Internal use only
resultsOut :: Config -> OutputStream ByteString

-- | Internal use only A set of environment variable configurations to test
stdOut :: Config -> OutputStream ByteString
envs :: Config -> [[(String, String)]]

-- | A global setting to control whether executables are given their
--   'flags/params' after their regular arguments. This is here because
--   some executables don't use proper command line parsing.
argsBeforeFlags :: Config -> Bool

-- | A stack of line harvesters that gather RunResult details.
harvesters :: Config -> LineHarvester

-- | Each plugin, and, if configured, its configuration.
plugIns :: Config -> [SomePlugin]

-- | Maps the <a>plugName</a> to its config.
plugInConfs :: Config -> Map String SomePluginConf

-- | A monad for benchmarking This provides access to configuration
--   options, but really, its main purpose is enabling logging.
type BenchM a = ReaderT Config IO a
data CleanupAction
NoCleanup :: CleanupAction
Cleanup :: (IO ()) -> CleanupAction

-- | A self-contained description of a runnable command. Similar to
--   System.Process.CreateProcess but slightly simpler.
data CommandDescr
CommandDescr :: CmdSpec -> [(String, String)] -> Maybe Double -> Maybe FilePath -> Bool -> CommandDescr

-- | Executable and arguments
command :: CommandDescr -> CmdSpec

-- | Environment variables to APPEND to current env.
envVars :: CommandDescr -> [(String, String)]

-- | Optional timeout in seconds.
timeout :: CommandDescr -> Maybe Double

-- | Optional working directory to switch to before running command.
workingDir :: CommandDescr -> Maybe FilePath

-- | Does a crash of the process mean we throw away any data the program
--   already printed? Usually False.
tolerateError :: CommandDescr -> Bool

-- | Measured results from running a subprocess (benchmark).
data RunResult
RunCompleted :: Double -> Maybe Double -> Maybe Word64 -> Maybe Word64 -> Maybe Double -> [(Tag, SomeResult)] -> RunResult

-- | Benchmark time in seconds, may be different than total process time.
realtime :: RunResult -> Double

-- | Seconds
productivity :: RunResult -> Maybe Double

-- | Bytes allocated per mutator-second
allocRate :: RunResult -> Maybe Word64

-- | High water mark of allocated memory, in bytes.
memFootprint :: RunResult -> Maybe Word64

-- | Time to JIT compile the benchmark, counted separately from realtime.
jittime :: RunResult -> Maybe Double
custom :: RunResult -> [(Tag, SomeResult)]
RunTimeOut :: RunResult

-- | Contains the returned error code.
ExitError :: Int -> RunResult

-- | A default <a>RunResult</a> that is a good starting point for filling
--   in desired fields. (This way, one remains robust to additional fields
--   that are added in the future.)
emptyRunResult :: RunResult

-- | A running subprocess.
data SubProcess
SubProcess :: IO RunResult -> InputStream ByteString -> InputStream ByteString -> SubProcess
wait :: SubProcess -> IO RunResult

-- | A stream of lines.
process_out :: SubProcess -> InputStream ByteString

-- | A stream of lines.
process_err :: SubProcess -> InputStream ByteString

-- | A line harvester takes a single line of input and possible extracts
--   data from it which it can then add to a RunResult.
--   
--   The boolean result indicates whether the line was used or not.
newtype LineHarvester
LineHarvester :: (ByteString -> (RunResult -> RunResult, Bool)) -> LineHarvester

-- | Run the second harvester only if the first fails.
orHarvest :: LineHarvester -> LineHarvester -> LineHarvester

-- | This contains all the contextual information for a single benchmark
--   run, which makes up a "row" in a table of benchmark results. Note that
--   multiple "trials" (actual executions) go into a single BenchmarkResult
data BenchmarkResult
BenchmarkResult :: String -> String -> [String] -> String -> String -> String -> Int -> String -> Double -> Double -> Double -> Maybe Double -> Maybe Double -> Maybe Double -> String -> Int -> String -> String -> String -> String -> String -> String -> String -> String -> String -> String -> String -> Int -> String -> String -> String -> String -> Maybe Word64 -> Maybe Word64 -> String -> Int -> [(Tag, SomeResult)] -> BenchmarkResult

-- | Which benchmark are we running
_PROGNAME :: BenchmarkResult -> String

-- | If there are multiple ways to run the benchmark, this shoud record
--   which was used.
_VARIANT :: BenchmarkResult -> String

-- | Command line arguments.
_ARGS :: BenchmarkResult -> [String]

-- | Which machine did we run on?
_HOSTNAME :: BenchmarkResult -> String

-- | A unique identifier for the full hsbencher that included this
--   benchmark.
_RUNID :: BenchmarkResult -> String

-- | When launched from Jenkins or Travis, it can help to record where we
--   came from.
_CI_BUILD_ID :: BenchmarkResult -> String

-- | If multithreaded, how many CPU threads did this benchmark run with,
--   zero otherwise.
_THREADS :: BenchmarkResult -> Int
_DATETIME :: BenchmarkResult -> String

-- | Time of the fastest run
_MINTIME :: BenchmarkResult -> Double

-- | Time of the median run
_MEDIANTIME :: BenchmarkResult -> Double

-- | Time of the slowest run
_MAXTIME :: BenchmarkResult -> Double

-- | GC productivity (if recorded) for the mintime run.
_MINTIME_PRODUCTIVITY :: BenchmarkResult -> Maybe Double

-- | GC productivity (if recorded) for the mediantime run.
_MEDIANTIME_PRODUCTIVITY :: BenchmarkResult -> Maybe Double

-- | GC productivity (if recorded) for the maxtime run.
_MAXTIME_PRODUCTIVITY :: BenchmarkResult -> Maybe Double

-- | Space separated list of numbers, should be one number for each TRIAL
_ALLTIMES :: BenchmarkResult -> String

-- | How many times to [re]run each benchmark.
_TRIALS :: BenchmarkResult -> Int
_COMPILER :: BenchmarkResult -> String

-- | Flags used during compilation
_COMPILE_FLAGS :: BenchmarkResult -> String

-- | Flags passed at runtime, possibly in addition to ARGS
_RUNTIME_FLAGS :: BenchmarkResult -> String

-- | Environment variables set for this benchmark run
_ENV_VARS :: BenchmarkResult -> String

-- | If the benchmark *suite* tracks its version number, put it here.
_BENCH_VERSION :: BenchmarkResult -> String
_BENCH_FILE :: BenchmarkResult -> String

-- | Information about the host machine that ran the benchmark.
_UNAME :: BenchmarkResult -> String
_PROCESSOR :: BenchmarkResult -> String

-- | Some freeform indication of what cores we ran on
_TOPOLOGY :: BenchmarkResult -> String

-- | Which branch was the benchmark run from
_GIT_BRANCH :: BenchmarkResult -> String

-- | Which exact revision of the code was run.
_GIT_HASH :: BenchmarkResult -> String

-- | How many git commits deep was that rev (rough proxy for age)
_GIT_DEPTH :: BenchmarkResult -> Int

-- | Was anyone else logged into the machine?
_WHO :: BenchmarkResult -> String

-- | Information about the host machine from <i>etc</i>issue
_ETC_ISSUE :: BenchmarkResult -> String

-- | Information about the host machine from the lspci command
_LSPCI :: BenchmarkResult -> String

-- | Optionally record the full stdout from the benchmarking process.
_FULL_LOG :: BenchmarkResult -> String

-- | If recorded, the allocation rate of the median run.
_MEDIANTIME_ALLOCRATE :: BenchmarkResult -> Maybe Word64

-- | If recorded, the memory footprint (high water mark) of the median run
_MEDIANTIME_MEMFOOTPRINT :: BenchmarkResult -> Maybe Word64

-- | Space separated list of numbers, JIT compile times (if applicable),
--   with a 1-1 correspondence to the exec times in ALLTIMES. Time should
--   not be double counted as JIT and exec time; these should be disjoint.
_ALLJITTIMES :: BenchmarkResult -> String

-- | The number of times any trial of the benchmark was reexecuted because
--   of failure.
_RETRIES :: BenchmarkResult -> Int

-- | A List of custom results The tag corresponds to column "title"
_CUSTOM :: BenchmarkResult -> [(Tag, SomeResult)]

-- | A default value, useful for filling in only the fields that are
--   relevant to a particular benchmark.
emptyBenchmarkResult :: BenchmarkResult

-- | Convert the Haskell representation of a benchmark result into a tuple
--   for upload to a typical database backend.
resultToTuple :: BenchmarkResult -> [(String, String)]

-- | Perform some validation and then convert raw CSV data to a
--   BenchmarkResult.
tupleToResult :: [(String, String)] -> BenchmarkResult
data SomePlugin
SomePlugin :: p -> SomePlugin

-- | Keep a full plugin configuration together with the plugin it goes
--   with.
data SomePluginConf
SomePluginConf :: p -> (PlugConf p) -> SomePluginConf

-- | Keep a single flag together with the plugin it goes with.
data SomePluginFlag
SomePluginFlag :: p -> (PlugFlag p) -> SomePluginFlag

-- | An interface for plugins provided in separate packages. These plugins
--   provide new backends for uploading benchmark data.
class (Show p, Eq p, Ord p, Show (PlugFlag p), Ord (PlugFlag p), Typeable (PlugFlag p), Show (PlugConf p), Ord (PlugConf p), Typeable (PlugConf p), Default p, Default (PlugConf p)) => Plugin p where type family PlugFlag p type family PlugConf p
plugName :: Plugin p => p -> String
plugCmdOpts :: Plugin p => p -> (String, [OptDescr (PlugFlag p)])
foldFlags :: Plugin p => p -> [PlugFlag p] -> PlugConf p -> PlugConf p
plugInitialize :: Plugin p => p -> Config -> IO Config
plugUploadRow :: Plugin p => p -> Config -> BenchmarkResult -> IO ()

-- | Make the command line flags for a particular plugin generic so that
--   they can be mixed together with other plugins options.
genericCmdOpts :: Plugin p => p -> [OptDescr SomePluginFlag]

-- | Retrieve our own Plugin's configuration from the global config. This
--   involves a dynamic type cast.
--   
--   If there is no configuration for this plugin currently registered, the
--   default configuration for that plugin is returned.
getMyConf :: Plugin p => p -> Config -> PlugConf p

-- | Encapsulate the policy for where/how to inject the Plugin's conf into
--   the global Config.
setMyConf :: Plugin p => p -> PlugConf p -> Config -> Config
data SomeResult
IntResult :: Int -> SomeResult
DoubleResult :: Double -> SomeResult
StringResult :: String -> SomeResult
AccumResult :: [SomeResult] -> SomeResult
type Tag = String
type EnvVars = [(String, String)]

-- | <a>doc</a> is the equivalent of <a>show</a>
--   
--   This is a specialised variant of <a>docPrec</a>, using precedence
--   context zero.
doc :: Out a => a -> Doc
instance Read CmdSpec
instance Ord CmdSpec
instance Show CmdSpec
instance Eq CmdSpec
instance Show FilePredicate
instance Generic FilePredicate
instance Ord FilePredicate
instance Eq FilePredicate
instance Show DefaultParamMeaning
instance Eq DefaultParamMeaning
instance Ord DefaultParamMeaning
instance Read DefaultParamMeaning
instance Generic DefaultParamMeaning
instance Show CPUAffinity
instance Eq CPUAffinity
instance Read CPUAffinity
instance Ord CPUAffinity
instance Generic CPUAffinity
instance Show ParamSetting
instance Eq ParamSetting
instance Read ParamSetting
instance Ord ParamSetting
instance Generic ParamSetting
instance Show meaning => Show (BenchSpace meaning)
instance Eq meaning => Eq (BenchSpace meaning)
instance Ord meaning => Ord (BenchSpace meaning)
instance Read meaning => Read (BenchSpace meaning)
instance Generic (BenchSpace meaning)
instance Show CommandDescr
instance Eq CommandDescr
instance Ord CommandDescr
instance Read CommandDescr
instance Generic CommandDescr
instance Eq SomeResult
instance Read SomeResult
instance Ord SomeResult
instance Eq RunResult
instance Show RunResult
instance Show BenchmarkResult
instance Read BenchmarkResult
instance Ord BenchmarkResult
instance Eq BenchmarkResult
instance Show Config
instance Show a => Show (Benchmark a)
instance Generic (Benchmark a)
instance Datatype D1FilePredicate
instance Constructor C1_0FilePredicate
instance Constructor C1_1FilePredicate
instance Constructor C1_2FilePredicate
instance Constructor C1_3FilePredicate
instance Constructor C1_4FilePredicate
instance Datatype D1DefaultParamMeaning
instance Constructor C1_0DefaultParamMeaning
instance Constructor C1_1DefaultParamMeaning
instance Constructor C1_2DefaultParamMeaning
instance Datatype D1CPUAffinity
instance Constructor C1_0CPUAffinity
instance Constructor C1_1CPUAffinity
instance Constructor C1_2CPUAffinity
instance Datatype D1ParamSetting
instance Constructor C1_0ParamSetting
instance Constructor C1_1ParamSetting
instance Constructor C1_2ParamSetting
instance Constructor C1_3ParamSetting
instance Constructor C1_4ParamSetting
instance Constructor C1_5ParamSetting
instance Constructor C1_6ParamSetting
instance Datatype D1BenchSpace
instance Constructor C1_0BenchSpace
instance Constructor C1_1BenchSpace
instance Constructor C1_2BenchSpace
instance Datatype D1CommandDescr
instance Constructor C1_0CommandDescr
instance Selector S1_0_0CommandDescr
instance Selector S1_0_1CommandDescr
instance Selector S1_0_2CommandDescr
instance Selector S1_0_3CommandDescr
instance Selector S1_0_4CommandDescr
instance Datatype D1Benchmark
instance Constructor C1_0Benchmark
instance Selector S1_0_0Benchmark
instance Selector S1_0_1Benchmark
instance Selector S1_0_2Benchmark
instance Selector S1_0_3Benchmark
instance Selector S1_0_4Benchmark
instance Selector S1_0_5Benchmark
instance Show SomePluginFlag
instance Show SomePluginConf
instance Ord SomePlugin
instance Eq SomePlugin
instance Show SomePlugin
instance Show SomeResult
instance Show LineHarvester
instance Monoid LineHarvester
instance (Out k, Out v) => Out (Map k v)
instance Out a => Out (Benchmark a)
instance Out a => Out (BenchSpace a)
instance Out BuildMethod
instance Out DefaultParamMeaning
instance Out FilePredicate
instance Out ParamSetting
instance Out CPUAffinity
instance Show (OutputStream a)
instance Show CleanupAction
instance Show BuildMethod
instance Show BuildResult

module HSBencher.Internal.Logging

-- | There are three logging destinations we care about. The .dat file, the
--   .log file, and the user's screen (i.e. the user who launched the
--   benchmarks).
data LogDest
ResultsFile :: LogDest
LogFile :: LogDest
StdOut :: LogDest

-- | Print a message (line) both to stdout and logFile:
log :: String -> BenchM ()

-- | Log a line to a particular file and also echo to stdout.
logOn :: [LogDest] -> String -> BenchM ()

-- | Shorthand for tagged version of logging.
logT :: String -> BenchM ()

-- | The tag for printing hsbencher messagse
hsbencher_tag :: String

-- | Logging straight to stdout (but with the hsbencher tag).
chatter :: String -> IO ()
instance Show LogDest


-- | A simple backend that dribbles benchmark results (i.e. rows/tuples)
--   into a series of files in an "hsbencher" subdir of the the users
--   ".cabal/" directory.
--   
--   This is often useful as a failsafe to reinforce other backends that
--   depend on connecting to internet services for upload. Even if the
--   upload fails, you still have a local copy of the data.
module HSBencher.Backend.Dribble

-- | A plugin with the basic options (if any) included.
defaultDribblePlugin :: DribblePlugin

-- | A simple singleton type -- a unique signifier.
data DribblePlugin

-- | The configuration consists only of the location of a single file,
--   which is where the results will be fed. If no file is provided, the
--   default location is selected during plugin initialization.
data DribbleConf
DribbleConf :: Maybe String -> DribbleConf
csvfile :: DribbleConf -> Maybe String
instance Typeable DribbleConf
instance Read DribblePlugin
instance Show DribblePlugin
instance Eq DribblePlugin
instance Ord DribblePlugin
instance Read DribbleConf
instance Show DribbleConf
instance Eq DribbleConf
instance Ord DribbleConf
instance Plugin DribblePlugin
instance Default DribbleConf
instance Default DribblePlugin


-- | This module provides tools to time a sub-process (benchmark),
--   including a facility for self-reporting execution time and reporting
--   garbage collector overhead for GHC-compiled programs.
module HSBencher.Internal.MeasureProcess

-- | This runs a sub-process and tries to determine how long it took (real
--   time) and how much of that time was spent in the mutator vs. the
--   garbage collector.
--   
--   It is complicated by:
--   
--   <ol>
--   <li>An additional protocol for the process to report self-measured
--   realtime (a line starting in <a>SELFTIMED</a>, ditto for
--   <a>JITTIME:</a>)</li>
--   <li>Parsing the output of GHC's "+RTS -s" to retrieve productivity OR
--   using lines of the form "PRODUCTIVITY: XYZ"</li>
--   </ol>
--   
--   Note that "+RTS -s" is specific to Haskell/GHC, but the PRODUCTIVITY
--   tag allows non-haskell processes to report garbage collector overhead.
--   
--   This procedure is currently not threadsafe, because it changes the
--   current working directory.
measureProcess :: Maybe (Int, CPUAffinity) -> LineHarvester -> CommandDescr -> IO SubProcess

-- | A simpler and SINGLE-THREADED alternative to <a>measureProcess</a>.
--   This is part of the process of trying to debug the HSBencher zombie
--   state (Issue #32).
measureProcessDBG :: Maybe (Int, CPUAffinity) -> LineHarvester -> CommandDescr -> IO ([ByteString], RunResult)

-- | Check for a SELFTIMED line of output.
selftimedHarvester :: LineHarvester
jittimeHarvester :: LineHarvester

-- | Retrieve productivity (i.e. percent time NOT garbage collecting) as
--   output from a Haskell program with "+RTS -s". Productivity is a
--   percentage (double between 0.0 and 100.0, inclusive).
ghcProductivityHarvester :: LineHarvester
ghcAllocRateHarvester :: LineHarvester
ghcMemFootprintHarvester :: LineHarvester

-- | Check for a line of output of the form "TAG NUM" or "TAG: NUM". Take a
--   function that puts the result into place (the write half of a lens).
taggedLineHarvester :: Read a => ByteString -> (a -> RunResult -> RunResult) -> LineHarvester

-- | Set the affinity of the *current* process.
setCPUAffinity :: (Int, CPUAffinity) -> IO ()
instance Show ProcessEvt
instance Eq ProcessEvt
instance Read ProcessEvt

module HSBencher.Harvesters
customTagHarvesterInt :: String -> LineHarvester
customTagHarvesterDouble :: String -> LineHarvester
customTagHarvesterString :: String -> LineHarvester
customAccumHarvesterInt :: String -> LineHarvester
customAccumHarvesterDouble :: String -> LineHarvester
customAccumHarvesterString :: String -> LineHarvester


-- | Misc Small Helpers
module HSBencher.Internal.Utils

-- | In seconds.
defaultTimeout :: Double

-- | Create a backup copy of existing results_HOST.dat files.
backupResults :: String -> String -> IO ()

-- | Run a command and wait for all output. Log output to the appropriate
--   places. The first argument is a "tag" to append to each output line to
--   make things clearer.
runLogged :: String -> String -> [(String, String)] -> BenchM (RunResult, [ByteString])

-- | Runs a command through the OS shell and returns the first line of
--   output. (Ignore exit code and stderr.)
--   
--   If the command does not return any output, this function returns the
--   empty string.
runSL :: String -> IO String

-- | Runs a command through the OS shell and returns stdout split into
--   lines. (Ignore exit code and stderr.)
runLines :: String -> IO [String]
trim :: String -> String

-- | A more persistent version of <a>takeBaseName</a>.
fetchBaseName :: FilePath -> FilePath

-- | Create a thread that echos the contents of stdout/stderr InputStreams
--   (lines) to the appropriate places (as designated by the logging
--   facility). Returns an MVar used to synchronize on the completion of
--   the echo thread.
echoStream :: Bool -> InputStream ByteString -> BenchM (Async ())
my_name :: String

-- | Global variable holding the main thread id.
main_threadid :: IORef ThreadId


-- | These are the built-in build methods for HSBencher that come with the
--   main package. They are relatively unsophisticated.
module HSBencher.Methods.Builtin

-- | Build with GNU Make. This is a basic Make protocol; your application
--   may need something more complicated. This assumes targets clean, run,
--   and the default target for building.
--   
--   The variables RUN_ARGS and COMPILE_ARGS are used to pass in the
--   per-benchmark run and compile options, so the Makefile must be written
--   with these conventions in mind. Note that this build method never
--   knows where or if any resulting binaries reside. One effect of that is
--   that this simple build method can never be used for PARALLEL compiles,
--   because it cannot manage where the build-intermediates are stored.
makeMethod :: BuildMethod

-- | Build with GHC directly. This assumes that all dependencies are
--   installed and a single call to <tt>ghc</tt> can build the file.
--   
--   Compile-time arguments go directly to GHC, and runtime arguments
--   directly to the resulting binary.
ghcMethod :: BuildMethod

-- | Build with cabal. Specifically, this uses "cabal install".
--   
--   This build method attempts to choose reasonable defaults for
--   benchmarking. It takes control of the output program suffix and
--   directory (setting it to BENCHROOT/bin). It passes compile-time
--   arguments directly to cabal. Likewise, runtime arguments get passed
--   directly to the resulting binary.
cabalMethod :: BuildMethod


-- | Code to deal with configuration information, including gathering it
--   from the host environment. Also deals with command line arguments.
module HSBencher.Internal.Config

-- | Retrieve the (default) configuration from the environment, it may
--   subsequently be tinkered with. This procedure should be idempotent.
getConfig :: [Flag] -> [Benchmark DefaultParamMeaning] -> IO Config

-- | Fill in "static" fields of a BenchmarkResult row based on the
--   <a>Config</a> data.
augmentResultWithConfig :: Config -> BenchmarkResult -> IO BenchmarkResult

-- | This abstracts over the actions we need to take to properly add an
--   additional plugin to the <a>Config</a>.
addPlugin :: Plugin p => p -> PlugConf p -> Config -> Config

-- | Command line flags to the benchmarking executable.
data Flag
ParBench :: Flag
BenchsetName :: (String) -> Flag
BinDir :: FilePath -> Flag
NoRecomp :: Flag
NoCabal :: Flag
NoClean :: Flag
ShortRun :: Flag
KeepGoing :: Flag
NumTrials :: String -> Flag
SkipTo :: String -> Flag
RunOnly :: Int -> Flag
RetryFailed :: Int -> Flag
RunID :: String -> Flag
CIBuildID :: String -> Flag
ForceHostName :: String -> Flag
CabalPath :: String -> Flag
GHCPath :: String -> Flag
ShowHelp :: Flag
ShowVersion :: Flag
ShowBenchmarks :: Flag
DisablePlug :: String -> Flag
AddLSPCI :: Flag
ExtraParam :: ParamSetting -> Flag
SetAffinityPacked :: Flag
SetAffinitySpreadOut :: Flag
all_cli_options :: [(String, [OptDescr Flag])]
instance Show Flag


-- | Code for dealing with the <a>BenchSpace</a> datatype.
module HSBencher.Internal.BenchSpace

-- | A datatype for describing (generating) benchmark configuration spaces.
--   This is accomplished by nested conjunctions and disjunctions. For
--   example, varying threads from 1-32 would be a 32-way Or. Combining
--   that with profiling on/off (product) would create a 64-config space.
--   
--   While the ParamSetting provides an *implementation* of the behavior,
--   this datatype can also be decorated with a (more easily machine
--   readable) meaning of the corresponding setting. For example,
--   indicating that the setting controls the number of threads.
data BenchSpace meaning
And :: [BenchSpace meaning] -> BenchSpace meaning
Or :: [BenchSpace meaning] -> BenchSpace meaning
Set :: meaning -> ParamSetting -> BenchSpace meaning

-- | Exhaustively compute all configurations described by a benchmark
--   configuration space.
enumerateBenchSpace :: BenchSpace a -> [[(a, ParamSetting)]]

-- | The size of a configuration space. This is equal to the length of the
--   result returned by <a>enumerateBenchSpace</a>, but is quicker to
--   compute.
benchSpaceSize :: BenchSpace a -> Int

-- | Filter down a list of benchmarks (and their configuration spaces) to
--   only those that have ALL of the pattern arguments occurring
--   *somewhere* in their printed representation.
--   
--   This completely removes any benchmark with an empty configuration
--   space (`Or []`).
filterBenchmarks :: [String] -> [Benchmark DefaultParamMeaning] -> [Benchmark DefaultParamMeaning]

-- | Filter down the config space of a benchmark, to only those
--   configurations that have a match for ALL of the pattern arguments
--   occurring somewhere inside them.
--   
--   A note on semantics:
--   
--   A benchmark (with its config space) implies a STREAM of concrete
--   benchmark instances.
--   
--   Each pattern filters out a subset of these instances (either by
--   matching a varying field like <a>RuntimeEnv</a> or a static field like
--   <a>progname</a>). This function conjoins all the patterns and thus
--   returns a benchmark that iterates over the INTERSECTION of those
--   subsets implied by each pattern, respectively.
filterBenchmark :: [String] -> Benchmark DefaultParamMeaning -> Benchmark DefaultParamMeaning

-- | Convert to disjunctive normal form. This can be an exponential
--   increase in the size of the value.
disjunctiveNF :: BenchSpace a -> BenchSpace a


-- | The Main module defining the HSBencher driver.
module HSBencher.Internal.App

-- | An even more flexible version allows the user to install a hook which
--   modifies the configuration just before bencharking begins. All
--   trawling of the execution environment (command line args, environment
--   variables) happens BEFORE the user sees the configuration.
--   
--   This function doesn't take a benchmark list separately, because that
--   simply corresponds to the <a>benchlist</a> field of the output
--   <a>Config</a>.
defaultMainModifyConfig :: (Config -> Config) -> IO ()

-- | Command line flags to the benchmarking executable.
data Flag
ParBench :: Flag
BenchsetName :: (String) -> Flag
BinDir :: FilePath -> Flag
NoRecomp :: Flag
NoCabal :: Flag
NoClean :: Flag
ShortRun :: Flag
KeepGoing :: Flag
NumTrials :: String -> Flag
SkipTo :: String -> Flag
RunOnly :: Int -> Flag
RetryFailed :: Int -> Flag
RunID :: String -> Flag
CIBuildID :: String -> Flag
ForceHostName :: String -> Flag
CabalPath :: String -> Flag
GHCPath :: String -> Flag
ShowHelp :: Flag
ShowVersion :: Flag
ShowBenchmarks :: Flag
DisablePlug :: String -> Flag
AddLSPCI :: Flag
ExtraParam :: ParamSetting -> Flag
SetAffinityPacked :: Flag
SetAffinitySpreadOut :: Flag
all_cli_options :: [(String, [OptDescr Flag])]

-- | Multiple lines of usage info help docs.
fullUsageInfo :: String


-- | Convenience module that reexports the necessary bits.
module HSBencher

-- | An even more flexible version allows the user to install a hook which
--   modifies the configuration just before bencharking begins. All
--   trawling of the execution environment (command line args, environment
--   variables) happens BEFORE the user sees the configuration.
--   
--   This function doesn't take a benchmark list separately, because that
--   simply corresponds to the <a>benchlist</a> field of the output
--   <a>Config</a>.
defaultMainModifyConfig :: (Config -> Config) -> IO ()

-- | This abstracts over the actions we need to take to properly add an
--   additional plugin to the <a>Config</a>.
addPlugin :: Plugin p => p -> PlugConf p -> Config -> Config

-- | A convenience combinator for composing together with other
--   <a>Config</a> transformers. This one adds benchmarks to whatever is
--   already in the <a>benchlist</a> field.
addBenchmarks :: [Benchmark DefaultParamMeaning] -> Config -> Config

-- | Command line flags to the benchmarking executable.
data Flag
ParBench :: Flag
BenchsetName :: (String) -> Flag
BinDir :: FilePath -> Flag
NoRecomp :: Flag
NoCabal :: Flag
NoClean :: Flag
ShortRun :: Flag
KeepGoing :: Flag
NumTrials :: String -> Flag
SkipTo :: String -> Flag
RunOnly :: Int -> Flag
RetryFailed :: Int -> Flag
RunID :: String -> Flag
CIBuildID :: String -> Flag
ForceHostName :: String -> Flag
CabalPath :: String -> Flag
GHCPath :: String -> Flag
ShowHelp :: Flag
ShowVersion :: Flag
ShowBenchmarks :: Flag
DisablePlug :: String -> Flag
AddLSPCI :: Flag
ExtraParam :: ParamSetting -> Flag
SetAffinityPacked :: Flag
SetAffinitySpreadOut :: Flag
all_cli_options :: [(String, [OptDescr Flag])]

-- | Multiple lines of usage info help docs.
fullUsageInfo :: String
