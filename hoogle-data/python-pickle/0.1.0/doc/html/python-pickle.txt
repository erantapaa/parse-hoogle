-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Serialization/deserialization using Python Pickle format.
--   
--   This package implements serialization and deserialization of Python
--   objects using the Pickle format.
@package python-pickle
@version 0.1.0


-- | Very partial implementation of the Python Pickle Virtual Machine
--   (protocol 2): i.e. parses pickled data into opcodes, then executes the
--   opcodes to construct a (Haskell representation of a) Python object.
module Language.Python.Pickle
unpickle :: ByteString -> Either String Value
pickle :: Value -> ByteString
opcodes :: [Parser OpCode]
empty_dict :: Parser OpCode
tuple2 :: Parser OpCode
tuple1 :: Parser OpCode
empty_tuple :: Parser OpCode
empty_list :: Parser OpCode
binput :: Parser OpCode
mark :: Parser OpCode
binint :: Parser OpCode
binfloat :: Parser OpCode
binint2 :: Parser OpCode
binint1 :: Parser OpCode
short_binstring :: Parser OpCode
setitem :: Parser OpCode
setitems :: Parser OpCode
append :: Parser OpCode
appends :: Parser OpCode
stop :: Parser OpCode
float8 :: Parser Double
int4 :: Parser Int
uint2 :: Parser Int
serialize :: OpCode -> Put
putFloat8 :: Double -> Put
putUint2 :: Int -> Put
data OpCode
EMPTY_DICT :: OpCode
EMPTY_LIST :: OpCode
EMPTY_TUPLE :: OpCode
BINPUT :: Int -> OpCode
MARK :: OpCode
BININT :: Int -> OpCode
BININT1 :: Int -> OpCode
BININT2 :: Int -> OpCode
BINFLOAT :: Double -> OpCode
SHORT_BINSTRING :: ByteString -> OpCode
TUPLE1 :: OpCode
TUPLE2 :: OpCode
SETITEM :: OpCode
SETITEMS :: OpCode
APPEND :: OpCode
APPENDS :: OpCode
STOP :: OpCode
data Value
Dict :: (Map Value Value) -> Value
List :: [Value] -> Value
Tuple :: [Value] -> Value
BinInt :: Int -> Value
BinFloat :: Double -> Value
BinString :: ByteString -> Value
MarkObject :: Value
unpickle' :: [OpCode] -> Either String Value
type Stack = [Value]
type Memo = IntMap Value
execute :: [OpCode] -> Stack -> Memo -> Either String Value
executePartial :: [OpCode] -> Stack -> Memo -> (Stack, Memo, [OpCode])
executeOne :: OpCode -> Stack -> Memo -> Either String (Stack, Memo)
executeSetitem :: Monad m => Stack -> Memo -> m ([Value], Memo)
executeSetitems :: Monad m => [(Value, Value)] -> Stack -> Memo -> m ([Value], Memo)
executeAppend :: Monad m => Stack -> Memo -> m ([Value], Memo)
executeAppends :: Monad m => [Value] -> Stack -> Memo -> m ([Value], Memo)
addToDict :: [(Value, Value)] -> Value -> Value
newtype Pickler a
Pickler :: WriterT [OpCode] (State (Map Value Int)) a -> Pickler a
runP :: Pickler a -> WriterT [OpCode] (State (Map Value Int)) a
runPickler :: Pickler () -> [OpCode]
pickle' :: Value -> Pickler ()
binput' :: Value -> Pickler ()
pickleDict :: Map Value Value -> Pickler ()
pickleList :: [Value] -> Pickler ()
pickleTuple :: [Value] -> Pickler ()
pickleBinInt :: Int -> Pickler ()
pickleBinFloat :: Double -> Pickler ()
pickleBinString :: ByteString -> Pickler ()
dictGet :: Value -> Value -> Either String (Maybe Value)
dictGet' :: Value -> Value -> Either String Value
dictGetString :: Value -> ByteString -> Either String ByteString
instance Show OpCode
instance Eq Value
instance Ord Value
instance Show Value
instance Monad Pickler
instance MonadWriter [OpCode] Pickler
instance MonadState (Map Value Int) Pickler
