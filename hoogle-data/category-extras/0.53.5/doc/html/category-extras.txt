-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Various modules and constructs inspired by category theory
--   
--   A vastly expanded collection of modules implementing various ideas
--   from category theory. Notable bits include: comonads, adjunctions, and
--   various recursion schemes ala <i>Functional Programming with Bananas,
--   Lenses, Envelopes and Barbed Wire</i>.
@package category-extras
@version 0.53.5


-- | Note the choice of which is universal and which is couniversal is
--   chosen to make the definitions consistent with limits and colimits.
module Control.Morphism.Universal
data Couniversal a f x
Couniversal :: (a -> f x) -> (forall z. (a -> f z) -> x -> z) -> Couniversal a f x
extractCouniversal :: Couniversal a f x -> a -> f x
couniversalize :: (a -> f z) -> Couniversal a f x -> x -> z
couniversalIdentity :: Couniversal a Identity a
data Universal a f x
Universal :: (f x -> a) -> (forall z. (f z -> a) -> z -> x) -> Universal a f x
extractUniversal :: Universal a f x -> f x -> a
universalize :: Universal a f x -> (f z -> a) -> z -> x
universalIdentity :: Universal a Identity a


-- | Spans and Cospans
--   <a>http://en.wikipedia.org/wiki/Span_(category_theory)</a>
module Control.Morphism.Span
newtype Span ~> x y z
Span :: (y ~> x, y ~> z) -> Span ~> x y z
runSpan :: Span ~> x y z -> (y ~> x, y ~> z)
newtype Cospan ~> x y z
Cospan :: (x ~> y, z ~> y) -> Cospan ~> x y z
runCospan :: Cospan ~> x y z -> (x ~> y, z ~> y)


-- | TODO: figure out a meaningful way for indexed monads to transform
--   indexed monads
module Control.Monad.Indexed.Trans
class IxMonadTrans t
ilift :: (IxMonadTrans t, Monad m) => m a -> t m i i a


module Control.Functor.Contra
class ContraFunctor f
contramap :: (ContraFunctor f) => (a -> b) -> f b -> f a
newtype ContraF a b
ContraF :: (b -> a) -> ContraF a b
runContraF :: ContraF a b -> b -> a
instance ContraFunctor (Const a)
instance ContraFunctor (ContraF a)


module Control.Functor.Full

-- | A <a>Full</a> <a>Functor</a> <tt>F : C -&gt; D</tt> provides for every
--   pair of objects <tt>c</tt>, <tt>c'</tt> in <tt>C</tt> and every
--   morphism <tt>g : F c -&gt; F c'l</tt> in <tt>D</tt>, a morphism <tt>g'
--   : c -&gt; c'</tt> in <tt>C</tt>. In short map has a right-inverse
--   under composition.
--   
--   <pre>
--   fmap . premap = id
--   </pre>
class (Functor f) => Full f
premap :: (Full f) => (f a -> f b) -> a -> b
class (Functor f) => Faithful f

-- | For every pair of objects <tt>a</tt> and <tt>b</tt> in <tt>C</tt> a
--   <a>Full</a> <a>Faithful</a> <a>Functor</a> <tt>F : C -&gt; D</tt> maps
--   every morphism <tt>f : a -&gt; b</tt> onto a distinct morphism <tt>f :
--   T a -&gt; T b</tt> (since it is faithful) and every morphism from
--   <tt>g : T a -&gt; T b</tt> can be obtained from some <tt>f</tt>. (It
--   maps Hom-sets bijectively, or in short <tt>fmap</tt> has both a left
--   and right inverse under composition.
--   
--   <pre>
--   unmap . fmap = id
--   </pre>
unmap :: (Full f, Faithful f) => (f a -> f b) -> a -> b
instance Faithful Identity
instance Full Identity


-- | Exponential functors, see
--   <a>http://comonad.com/reader/2008/rotten-bananas/</a>
module Control.Functor.Exponential
class ExpFunctor f
xmap :: (ExpFunctor f) => (a -> b) -> (b -> a) -> f a -> f b
instance ExpFunctor (Const a)


module Control.Functor.Indexed
class IxFunctor f
imap :: (IxFunctor f) => (a -> b) -> f j k a -> f j k b
class (IxFunctor w) => IxCopointed w
iextract :: (IxCopointed w) => w i i a -> a
class (IxFunctor m) => IxPointed m
ireturn :: (IxPointed m) => a -> m i i a
class (IxPointed m) => IxApplicative m
iap :: (IxApplicative m) => m i j (a -> b) -> m j k a -> m i k b


module Control.Monad.Indexed
class IxFunctor f
imap :: (IxFunctor f) => (a -> b) -> f j k a -> f j k b
class (IxFunctor m) => IxPointed m
ireturn :: (IxPointed m) => a -> m i i a
class (IxPointed m) => IxApplicative m
iap :: (IxApplicative m) => m i j (a -> b) -> m j k a -> m i k b
class (IxApplicative m) => IxMonad m
ibind :: (IxMonad m) => (a -> m j k b) -> m i j a -> m i k b
class (IxMonad m) => IxMonadZero m
imzero :: (IxMonadZero m) => m i j a
class (IxMonadZero m) => IxMonadPlus m
implus :: (IxMonadPlus m) => m i j a -> m i j a -> m i j a
ijoin :: (IxMonad m) => m i j (m j k a) -> m i k a
(>>>=) :: (IxMonad m) => m i j a -> (a -> m j k b) -> m i k b
(=<<<) :: (IxMonad m) => (a -> m j k b) -> m i j a -> m i k b
iapIxMonad :: (IxMonad m) => m i j (a -> b) -> m j k a -> m i k b


module Control.Monad.Indexed.Fix
class (IxMonad m) => IxMonadFix m
imfix :: (IxMonadFix m) => (a -> m i i a) -> m i i a


module Control.Comonad.Indexed
class IxFunctor f
imap :: (IxFunctor f) => (a -> b) -> f j k a -> f j k b
class (IxFunctor w) => IxCopointed w
iextract :: (IxCopointed w) => w i i a -> a
class (IxCopointed w) => IxComonad w
iextend :: (IxComonad w) => (w j k a -> b) -> w i k a -> w i j b
iduplicate :: (IxComonad w) => w i k a -> w i j (w j k a)


-- | This module declares the <a>HasTerminalObject</a> and
--   <a>HasInitialObject</a> classes. These are defined in terms of
--   class-associated types rather than functional dependencies because
--   most of the time when you are manipulating a category you don't care
--   about them; this gets them out of the signature of most functions that
--   use the category. Both of these are special cases of the idea of a
--   (co)limit.
module Control.Category.Object

-- | The <tt>Category k</tt> has a terminal object <tt>Terminal k</tt> such
--   that for all objects <tt>a</tt> in <tt>k</tt>, there exists a unique
--   morphism from <tt>a</tt> to <tt>Terminal k</tt>.
class (Category k) => HasTerminalObject k t | k -> t
terminate :: (HasTerminalObject k t) => k a t

-- | The <tt>Category k</tt> has an initial (coterminal) object <tt>Initial
--   k</tt> such that for all objects <tt>a</tt> in <tt>k</tt>, there
--   exists a unique morphism from <tt>Initial k </tt> to <tt>a</tt>.
class (Category k) => HasInitialObject k i | k -> i
initiate :: (HasInitialObject k i) => k i a


module Control.Category.Dual
data Dual k a b
Dual :: k b a -> Dual k a b
runDual :: Dual k a b -> k b a
instance (Category k) => Category (Dual k)


module Control.Category.Discrete
data Discrete a b
Refl :: Discrete a a
mapDiscrete :: Discrete a b -> Discrete (f a) (f b)
cast :: Discrete a b -> a -> b
invDiscrete :: Discrete a b -> Discrete b a
instance Category Discrete


module Control.Functor.Extras
type Dist f g = forall a. f (g a) -> g (f a)

-- | A natural transformation between functors f and g.
type :~> f g = forall a. f a -> g a
type Natural f g = f :~> g

-- | A transformation natural in both sides of a bifunctor.
type :~~> f g = forall a b. f a b -> g a b

-- | Dinatural transformations
type Dinatural f g = forall a. f a a -> g a a
class PostFold m f
postFold :: (PostFold m f) => f (m (f a)) -> m (f a)
class PostUnfold w f
postUnfold :: (PostUnfold w f) => w (f a) -> f (w (f a))
class PreFold f m
preFold :: (PreFold f m) => f (m (f a)) -> f (m a)
class PreUnfold f w
preUnfold :: (PreUnfold f w) => f (w a) -> f (w (f a))
class Distributes f g
dist :: (Distributes f g) => f (g a) -> g (f a)
class (Functor f) => FunctorZero f
fzero :: (FunctorZero f) => f a
class (FunctorZero f) => FunctorPlus f
fplus :: (FunctorPlus f) => f a -> f a -> f a
class (Functor f) => FunctorSplit f
fsplit :: (FunctorSplit f) => f a -> (f a, f a)
instance FunctorPlus []
instance FunctorZero []
instance FunctorPlus Maybe
instance FunctorZero Maybe


module Control.Functor.Limit

-- | <tt>type Limit = Ran (Const Void)</tt> Limit { runLimit :: forall a. f
--   a }
type Limit f = forall a. f a
class HasLimit f
limit :: (HasLimit f) => f a

-- | <pre>
--   type Colimit = Lan (Const Void)
--   </pre>
data Colimit f
Colimit :: (f b) -> Colimit f
liftLimit :: (f :~> g) -> Limit f -> Limit g
liftColimit :: (f :~> g) -> Colimit f -> Colimit g
instance (Monoid a) => HasLimit (Either a)
instance HasLimit []
instance HasLimit Maybe


module Control.Functor.Cone
type Cone n f = n -> forall a. f a
newtype Cocone f n
Cocone :: (forall a. f a -> n) -> Cocone f n
runCocone :: Cocone f n -> forall a. f a -> n
instance MonadReader (Colimit f) (Cocone f)
instance Monad (Cocone f)
instance Functor (Cocone f)


module Data.Void
data Void
void :: Void -> a


-- | Make it clearer when we are dealing with the category (-&gt;) that we
--   mean the category of haskell types via its Hom bifunctor (-&gt;)
module Control.Category.Hask
type Hask = (->)


-- | A more categorical definition of Functor than endofunctors in the
--   category Hask
module Control.Functor
class (Category r, Category t) => PFunctor p r t | p r -> t, p t -> r
first :: (PFunctor p r t) => r a b -> t (p a c) (p b c)
first' :: (Bifunctor p r s t) => r a b -> t (p a c) (p b c)
class (Category s, Category t) => QFunctor q s t | q s -> t, q t -> s
second :: (QFunctor q s t) => s a b -> t (q c a) (q c b)
second' :: (Bifunctor p r s t) => s a b -> t (p c a) (p c b)
class (PFunctor p r t, QFunctor p s t) => Bifunctor p r s t | p r -> s t, p s -> r t, p t -> r s
bimap :: (Bifunctor p r s t) => r a b -> s c d -> t (p a c) (p b d)
dimap :: (Bifunctor f (Dual k) k k) => k b a -> k c d -> k (f a c) (f b d)
instance Bifunctor (,) Hask Hask Hask
instance QFunctor (,) Hask Hask
instance PFunctor (,) Hask Hask
instance QFunctor (->) Hask Hask
instance Bifunctor Either Hask Hask Hask
instance QFunctor Either Hask Hask
instance PFunctor Either Hask Hask


-- | NB: this contradicts another common meaning for an <a>Associative</a>
--   <tt>Category</tt>, which is one where the pentagonal condition does
--   not hold, but for which there is an identity.
module Control.Category.Associative

-- | A category with an associative bifunctor satisfying Mac Lane's
--   pentagonal coherence identity law:
--   
--   <pre>
--   bimap id associate . associate . bimap associate id = associate . associate
--   </pre>
class (Bifunctor p k k k) => Associative k p
associate :: (Associative k p) => k (p (p a b) c) (p a (p b c))

-- | A category with a coassociative bifunctor satisyfing the dual of Mac
--   Lane's pentagonal coherence identity law:
--   
--   <pre>
--   bimap coassociate id . coassociate . bimap id coassociate = coassociate . coassociate
--   </pre>
class (Bifunctor s k k k) => Coassociative k s
coassociate :: (Coassociative k s) => k (s a (s b c)) (s (s a b) c)
instance Coassociative Hask Either
instance Associative Hask Either
instance Coassociative Hask (,)
instance Associative Hask (,)


module Control.Functor.Pointed
class (Functor f) => Pointed f
point :: (Pointed f) => a -> f a
class (Functor f) => Copointed f
extract :: (Copointed f) => f a -> a
class (PFunctor f Hask Hask) => PPointed f
preturn :: (PPointed f) => a -> f a c
class (PFunctor f Hask Hask) => PCopointed f
pextract :: (PCopointed f) => f a c -> a
instance Copointed ((,) e)
instance Copointed Identity
instance Pointed []
instance Pointed (Either a)
instance Pointed Maybe
instance Pointed Identity


module Control.Applicative.Parameterized
class (PPointed f) => PApplicative f
pap :: (PApplicative f) => f (a -> b) c -> f a c -> f b c
class (PFunctor f Hask Hask) => PPointed f
preturn :: (PPointed f) => a -> f a c


module Control.Monad.Parameterized
class (PFunctor p r t, QFunctor p s t) => Bifunctor p r s t | p r -> s t, p s -> r t, p t -> r s
bimap :: (Bifunctor p r s t) => r a b -> s c d -> t (p a c) (p b d)
class (PFunctor f Hask Hask) => PPointed f
preturn :: (PPointed f) => a -> f a c
class (PPointed f) => PApplicative f
pap :: (PApplicative f) => f (a -> b) c -> f a c -> f b c
class (PApplicative f) => PMonad f
pbind :: (PMonad f) => (a -> f b c) -> f a c -> f b c
pjoin :: (PMonad f) => f (f a b) b -> f a b
(>>*=) :: (PMonad f) => f a c -> (a -> f b c) -> f b c
(=*<<) :: (PMonad f) => (a -> f b c) -> f a c -> f b c
(>>*) :: (PMonad f) => f a c -> f b c -> f b c
papPMonad :: (PMonad f) => f (a -> b) c -> f a c -> f b c


-- | (C) 2004 Dave Menendez License : BSD-style (see the file LICENSE)
--   
--   Maintainer : Edward Kmett <a>ekmett@gmail.com</a> Stability :
--   experimental Portability : portable
--   
--   This module declares the <a>Comonad</a> class
module Control.Comonad

-- | There are two ways to define a comonad:
--   
--   I. Provide definitions for <a>fmap</a>, <a>extract</a>, and
--   <a>duplicate</a> satisfying these laws:
--   
--   <pre>
--   extract . duplicate      == id
--   fmap extract . duplicate == id
--   duplicate . duplicate    == fmap duplicate . duplicate
--   </pre>
--   
--   II. Provide definitions for <a>extract</a> and <a>extend</a>
--   satisfying these laws:
--   
--   <pre>
--   extend extract      == id
--   extract . extend f  == f
--   extend f . extend g == extend (f . extend g)
--   </pre>
--   
--   (<a>fmap</a> cannot be defaulted, but a comonad which defines
--   <a>extend</a> may simply set <a>fmap</a> equal to <a>liftW</a>.)
--   
--   A comonad providing definitions for <a>extend</a> <i>and</i>
--   <a>duplicate</a>, must also satisfy these laws:
--   
--   <pre>
--   extend f  == fmap f . duplicate
--   duplicate == extend id
--   fmap f    == extend (f . duplicate)
--   </pre>
--   
--   (The first two are the defaults for <a>extend</a> and
--   <a>duplicate</a>, and the third is the definition of <a>liftW</a>.)
class (Copointed w) => Comonad w
duplicate :: (Comonad w) => w a -> w (w a)
extend :: (Comonad w) => (w a -> b) -> w a -> w b
liftW :: (Comonad w) => (a -> b) -> w a -> w b

-- | <a>extend</a> with the arguments swapped. Dual to <a>&gt;&gt;=</a> for
--   monads.
(=>>) :: (Comonad w) => w a -> (w a -> b) -> w b

-- | Injects a value into the comonad.
(.>>) :: (Comonad w) => w a -> b -> w b

-- | Transform a function into a comonadic action
liftCtx :: (Comonad w) => (a -> b) -> w a -> b
mapW :: (Comonad w) => (w a -> b) -> w [a] -> [b]
parallelW :: (Comonad w) => w [a] -> [w a]
unfoldW :: (Comonad w) => (w b -> (a, b)) -> w b -> [a]

-- | Converts a list of comonadic functions into a single function
--   returning a list of values
sequenceW :: (Comonad w) => [w a -> b] -> w a -> [b]
instance (Monoid m) => Comonad ((->) m)
instance (Monoid m) => Copointed ((->) m)
instance Comonad ((,) e)
instance Comonad Identity


module Control.Arrow.BiKleisli
newtype BiKleisli w m a b
BiKleisli :: (w a -> m b) -> BiKleisli w m a b
runBiKleisli :: BiKleisli w m a b -> w a -> m b
instance (Comonad w, Monad m, Distributes w m) => Category (BiKleisli w m)
instance (Comonad w, Monad m, Distributes w m) => Arrow (BiKleisli w m)
instance (Monad m) => Functor (BiKleisli w m a)


module Control.Arrow.CoKleisli
newtype CoKleisli w a b
CoKleisli :: (w a -> b) -> CoKleisli w a b
runCoKleisli :: CoKleisli w a b -> w a -> b
instance (Comonad w) => Category (CoKleisli w)
instance (Comonad w) => Arrow (CoKleisli w)
instance Functor (CoKleisli w a)


-- | The Context Comonad Transformer is related to the left Kan Extension
--   <tt>Lan</tt> of a comonad along itself, except the type of the context
--   is fixed, and not existentially quantified.
module Control.Comonad.Context
class (Comonad w) => ComonadContext s w | w -> s
getC :: (ComonadContext s w) => w a -> s
modifyC :: (ComonadContext s w) => (s -> s) -> w a -> a
putC :: (ComonadContext s w) => s -> w a -> a
experiment :: (ComonadContext s w, Functor f) => f (s -> s) -> w a -> f a
data Context s a
Context :: (s -> a) -> s -> Context s a
runContext :: (Context s s -> Context s b) -> s -> (b, s)
newtype ContextT s w a
ContextT :: (w s -> a, w s) -> ContextT s w a
runContextT :: ContextT s w a -> (w s -> a, w s)
instance (Comonad w) => Comonad (ContextT b w)
instance Copointed (ContextT b w)
instance Functor (ContextT b f)
instance (Comonad w) => ComonadContext s (ContextT s w)
instance Comonad (Context s)
instance Copointed (Context s)
instance Functor (Context s)
instance ComonadContext s (Context s)


-- | (C) 2004 Dave Menendez License : BSD-style (see the file LICENSE)
--   
--   Maintainer : Edward Kmett <a>ekmett@gmail.com</a> Stability :
--   experimental Portability : portable
module Control.Comonad.Trans
class ComonadTrans t
colift :: (ComonadTrans t, Comonad w) => w a -> t w a


module Control.Comonad.Exponent
data Exp m a
Exp :: (m -> a) -> Exp m a
runExp :: Exp m a -> m -> a
instance (Monoid m) => Comonad (Exp m)
instance (Monoid m) => Copointed (Exp m)
instance Functor (Exp m)


module Control.Comonad.Fix
cofix :: (Comonad w) => w (w a -> a) -> a


-- | SIGFPE (Dan Piponi)'s Pointer Comonad
module Control.Comonad.Pointer
data Pointer i a
Pointer :: i -> Array i a -> Pointer i a
index :: Pointer i a -> i
array :: Pointer i a -> Array i a
distPointer :: (Monad m, Ix i) => Dist (Pointer i) m
instance (Show i, Show a, Ix i) => Show (Pointer i a)
instance (Read i, Read a, Ix i) => Read (Pointer i a)
instance (Ix i) => Comonad (Pointer i)
instance (Ix i) => Copointed (Pointer i)
instance (Ix i) => Functor (Pointer i)


-- | The technique for generating new values is based on the paper ''On
--   Generating Unique Names'' by Lennart Augustsson, Mikael Rittri, and
--   Dan Synek.
--   
--   Integrated from value-supply-0.1
--   
--   TODO: a SupplyT Comonad Transformer
module Control.Comonad.Supply

-- | A type that can be used to generate values on demand. A supply may be
--   turned into two different supplies by using the functions
--   <a>supplyLeft</a> and <a>supplyRight</a>.
data Supply a

-- | Creates a new supply of values. The arguments specify how to generate
--   values: the first argument is an initial value, the second specifies
--   how to generate a new value from an existing one.
newSupply :: a -> (a -> a) -> IO (Supply a)

-- | A supply of values that are in the <a>Enum</a> class. The initial
--   value is <tt>toEnum 0</tt>, new values are generates with <a>succ</a>.
newEnumSupply :: (Enum a) => IO (Supply a)

-- | A supply of values that are in the <a>Num</a> class. The initial value
--   is 0, new values are generated by adding 1.
newNumSupply :: (Num a) => IO (Supply a)

-- | Get the value of a supply. This function, together with
--   <a>modifySupply</a> forms a comonad on <a>Supply</a>.
supplyValue :: Supply a -> a

-- | Generate a new supply. This supply is different from the one generated
--   with <a>supplyRight</a>.
supplyLeft :: Supply a -> Supply a

-- | Generate a new supply. This supply is different from the one generated
--   with <a>supplyLeft</a>.
supplyRight :: Supply a -> Supply a

-- | Generate a new supply by systematically applying a function to an
--   existing supply. This function, together with <a>supplyValue</a> form
--   a comonad on <a>Supply</a>.
modifySupply :: Supply a -> (Supply a -> b) -> Supply b

-- | Generate an infinite list of supplies by using <a>supplyLeft</a> and
--   <a>supplyRight</a> repeatedly.
split :: Supply a -> [Supply a]

-- | Split a supply into two different supplies. The resulting supplies are
--   different from the input supply.
split2 :: Supply a -> (Supply a, Supply a)

-- | Split a supply into three different supplies.
split3 :: Supply a -> (Supply a, Supply a, Supply a)

-- | Split a supply into four different supplies.
split4 :: Supply a -> (Supply a, Supply a, Supply a, Supply a)
instance FunctorSplit Supply
instance Comonad Supply
instance Copointed Supply
instance Functor Supply


-- | Neil Ghani and Particia Johann''s higher order functors from
--   <a>http://crab.rutgers.edu/~pjohann/tlca07-rev.pdf</a>
module Control.Functor.HigherOrder
class HFunctor f
ffmap :: (HFunctor f, Functor g) => (a -> b) -> f g a -> f g b
hfmap :: (HFunctor f) => (g :~> h) -> f g :~> f h
class (HFunctor m) => HPointed m
hreturn :: (HPointed m, Functor f) => f a -> m f a
class (HFunctor w) => HCopointed w
hextract :: (HCopointed w, Functor f) => w f a -> f a
type HAlgebra f g = f g :~> g
type HCoalgebra f g = g :~> f g
newtype FixH f a
InH :: f (FixH f) a -> FixH f a
outH :: FixH f a -> f (FixH f) a
newtype LowerH h :: ((* -> *) -> * -> *) f :: (* -> *) a
LowerH :: h f a -> LowerH
liftH :: LowerH -> h f a
instance HPointed ListT
instance HFunctor ListT
instance (Monoid e) => HPointed (WriterT e)
instance HFunctor (WriterT e)
instance HPointed (StateT e)
instance HFunctor (StateT e)
instance HPointed (ReaderT e)
instance HFunctor (ReaderT e)
instance (HCopointed h, Copointed f) => Copointed (LowerH h f)
instance (HPointed h, Pointed f) => Pointed (LowerH h f)
instance (HFunctor h, Functor f) => Functor (LowerH h f)


-- | extending Neil Ghani and Patrician Johann's HFunctor to higher order
--   comonads
module Control.Comonad.HigherOrder
class HFunctor f
ffmap :: (HFunctor f, Functor g) => (a -> b) -> f g a -> f g b
hfmap :: (HFunctor f) => (g :~> h) -> f g :~> f h
class (HFunctor w) => HCopointed w
hextract :: (HCopointed w, Functor f) => w f a -> f a
class (HCopointed w) => HComonad w
hextend :: (HComonad w, Functor f, Functor g) => (w f :~> g) -> w f :~> w g
hduplicate :: (HComonad w, Functor (w g), Functor g) => w g :~> w (w g)


-- | Composition of higher order functors
module Control.Functor.HigherOrder.Composition
newtype CompH f :: ((* -> *) -> * -> *) g :: ((* -> *) -> * -> *) a :: (* -> *) b
CompH :: f (g a) b -> CompH
runCompH :: CompH -> f (g a) b
class HComposition o :: (((* -> *) -> * -> *) -> ((* -> *) -> * -> *) -> (* -> *) -> * -> *)
hcompose :: (HComposition o) => f (g h) a -> (f o g) h a
hdecompose :: (HComposition o) => (f o g) h a -> f (g h) a
hassociateComposition :: (HFunctor f, HComposition o) => ((f o g) o h) a b -> (f o (g o h)) a b
hcoassociateComposition :: (HFunctor f, HComposition o) => (f o (g o h)) a b -> ((f o g) o h) a b
instance (HFunctor f, HFunctor g, Functor h) => Functor (CompH f g h)
instance (HFunctor f, HFunctor g) => HFunctor (CompH f g)
instance HComposition CompH


-- | Higher-Order Adjunctions
module Control.Functor.Adjunction.HigherOrder
class (HFunctor f, HFunctor g) => HAdjunction f g
hunit :: (HAdjunction f g) => a :~> g (f a)
hcounit :: (HAdjunction f g) => f (g b) :~> b
hleftAdjunct :: (HAdjunction f g) => (f a :~> b) -> a :~> g b
hrightAdjunct :: (HAdjunction f g) => (a :~> g b) -> f a :~> b
instance (HAdjunction f1 g1, HAdjunction f2 g2) => HAdjunction (CompH f2 f1) (CompH g1 g2)


module Control.Monad.HigherOrder
class HFunctor f
ffmap :: (HFunctor f, Functor g) => (a -> b) -> f g a -> f g b
hfmap :: (HFunctor f) => (g :~> h) -> f g :~> f h
class (HFunctor m) => HPointed m
hreturn :: (HPointed m, Functor f) => f a -> m f a
class (HPointed m) => HMonad m
hbind :: (HMonad m, Functor f, Functor g) => (f :~> m g) -> m f :~> m g
hjoin :: (HMonad m, Functor (m g), Functor g) => m (m g) :~> m g
(>>**=) :: (HMonad m, Functor f, Functor g) => m f a -> (f :~> m g) -> m g a
(=**<<) :: (HMonad m, Functor f, Functor g) => (f :~> m g) -> m f :~> m g


module Control.Comonad.Parameterized
class (PFunctor f Hask Hask) => PCopointed f
pextract :: (PCopointed f) => f a c -> a
class (PCopointed f) => PComonad f
pextend :: (PComonad f) => (f b c -> a) -> f b c -> f a c


-- | Incompatible with Control.Monad.Error, but removes the Error
--   restriction that prevents a natural encoding of Apomorphisms. This
--   module is therefore incompatible with Control.Monad.Error
module Control.Monad.Either

-- | The <a>Either</a> type represents values with two possibilities: a
--   value of type <tt><a>Either</a> a b</tt> is either <tt><a>Left</a>
--   a</tt> or <tt><a>Right</a> b</tt>.
--   
--   The <a>Either</a> type is sometimes used to represent a value which is
--   either correct or an error; by convention, the <a>Left</a> constructor
--   is used to hold an error value and the <a>Right</a> constructor is
--   used to hold a correct value (mnemonic: "right" also means "correct").
data Either a b :: * -> * -> *
Left :: a -> Either a b
Right :: b -> Either a b
newtype EitherT a m b
EitherT :: m (Either a b) -> EitherT a m b
runEitherT :: EitherT a m b -> m (Either a b)
instance (MonadFix m) => MonadFix (EitherT a m)
instance (Monad m) => Monad (EitherT a m)
instance (Pointed f) => Pointed (EitherT a f)
instance (Functor f) => Functor (EitherT a f)
instance MonadFix (Either e)
instance Applicative (Either e)
instance Monad (Either e)


module Control.Functor.Strong
strength :: (Functor f) => a -> f b -> f (a, b)
costrength :: (Traversable f) => f (Either a b) -> Either a (f b)


module Control.Monad.Indexed.Cont
class (IxMonad m) => IxMonadCont m
reset :: (IxMonadCont m) => m a o o -> m r r a
shift :: (IxMonadCont m) => (forall i. (a -> m i i o) -> m r j j) -> m r o a
newtype IxContT m r o a
IxContT :: ((a -> m o) -> m r) -> IxContT m r o a
runIxContT :: IxContT m r o a -> (a -> m o) -> m r
runIxContT_ :: (Monad m) => IxContT m r a a -> m r
newtype IxCont r o a
IxCont :: (IxContT Identity r o a) -> IxCont r o a
runIxCont :: IxCont r o a -> (a -> o) -> r
runIxCont_ :: IxCont r a a -> r
instance IxFunctor IxCont
instance IxPointed IxCont
instance IxApplicative IxCont
instance IxMonad IxCont
instance IxMonadCont IxCont
instance Monad (IxCont i i)
instance Applicative (IxCont i i)
instance Pointed (IxCont i i)
instance Functor (IxCont i j)
instance (MonadIO m) => MonadIO (IxContT m i i)
instance (MonadState e m) => MonadState e (IxContT m i i)
instance (MonadReader e m) => MonadReader e (IxContT m i i)
instance IxMonadTrans IxContT
instance (Monad m) => Monad (IxContT m i i)
instance (Monad m) => Applicative (IxContT m i i)
instance (Monad m) => Pointed (IxContT m i i)
instance (Monad m) => Functor (IxContT m i j)
instance (Monad m) => IxMonadCont (IxContT m)
instance (Monad m) => IxMonad (IxContT m)
instance (Monad m) => IxApplicative (IxContT m)
instance IxPointed (IxContT m)
instance IxFunctor (IxContT m)


-- | A more categorical definition of Functor than endofunctors in the
--   category Hask
module Control.Functor.Categorical
class (Category r, Category s) => CFunctor f r s | f r -> s, f s -> r
cmap :: (CFunctor f r s) => r a b -> s (f a) (f b)
class (CFunctor m ~> ~>) => CPointed m ~>
creturn :: (CPointed m ~>) => a ~> m a
class (CFunctor w ~> ~>) => CCopointed w ~>
cextract :: (CCopointed w ~>) => w a ~> a
class (CFunctor m ~> ~>) => CBind m ~>
cjoin :: (CBind m ~>) => m (m a) ~> m a
cbind :: (CBind m ~>) => (a ~> m b) -> (m a ~> m b)
class (CFunctor w ~> ~>) => CExtend w ~>
cduplicate :: (CExtend w ~>) => w a ~> w (w a)
cextend :: (CExtend w ~>) => (w a ~> b) -> (w a ~> w b)
class (CFunctor f ~> ~>, CFunctor g ~> ~>) => CDistributes f g ~>
cdist :: (CDistributes f g ~>) => f (g a) ~> g (f a)
class (CPointed m ~>, CBind m ~>) => CMonad m ~>
class (CCopointed m ~>, CExtend m ~>) => CComonad m ~>
instance (CCopointed m (~>), CExtend m (~>)) => CComonad m (~>)
instance (CPointed m (~>), CBind m (~>)) => CMonad m (~>)
instance (Monad m) => CFunctor (RWST r w s m) Hask Hask
instance (Monad m) => CFunctor (StateT s m) Hask Hask
instance (Monad m) => CFunctor (WriterT w m) Hask Hask
instance CFunctor (RWS r w s) Hask Hask
instance CFunctor (State s) Hask Hask
instance CFunctor (Writer e) Hask Hask
instance (Monad m) => CFunctor (RWST r w s m) Hask Hask
instance (Monad m) => CFunctor (ListT m) Hask Hask
instance (Monad m) => CFunctor (ContT r m) Hask Hask
instance (Monad m) => CFunctor (StateT e m) Hask Hask
instance (Monad m) => CFunctor (WriterT e m) Hask Hask
instance (Monad m) => CFunctor (ReaderT e m) Hask Hask
instance CFunctor IO Hask Hask
instance CFunctor (RWS r w s) Hask Hask
instance CFunctor (Cont e) Hask Hask
instance CFunctor (State s) Hask Hask
instance CFunctor (Writer e) Hask Hask
instance CFunctor (Reader e) Hask Hask
instance CFunctor ((,) e) Hask Hask
instance CFunctor Identity Hask Hask
instance CFunctor (Either a) Hask Hask
instance CFunctor Maybe Hask Hask
instance CFunctor [] Hask Hask


-- | Allegories are generalizations of categories to cover relations.
module Control.Allegory
class (Category k) => Allegory k
(.<=.) :: (Allegory k) => k a b -> k a b -> Bool
meet :: (Allegory k) => k a b -> k a b -> k a b
converse :: (Allegory k) => k a b -> k b a
isSimple :: (Allegory k) => k a b -> Bool
isTotal :: (Allegory k) => k a b -> Bool
isMap :: (Allegory k) => k a b -> Bool
class (Allegory k) => TabulatedAllegory k f
tabulateLeft :: (TabulatedAllegory k f) => k a b -> k a (f a b)
tabulateRight :: (TabulatedAllegory k f) => k a b -> k b (f a b)
class (Allegory k) => UnitalAllegory k i | k -> i
all :: (UnitalAllegory k i) => k a i
rightDomain :: (UnitalAllegory k i) => k b a -> k b b
leftDomain :: (UnitalAllegory k i) => k b a -> k a a
class (Allegory k1, Allegory k2, CFunctor f k1 k2) => Relator f k1 k2
data Map k a b
Map :: k a b -> Map k a b
runMap :: Map k a b -> k a b
extractMap :: (Allegory k) => k a b -> Maybe (Map k a b)
instance (Allegory k) => Category (Map k)


-- | Working Towards Maarten Fokkinga's Dyads
module Control.Dyad
class (CDistributes w m ~>, CDistributes m w ~>, CExtend w ~>, CBind m ~>) => CDyad w m ~>
cdyid :: (CDyad w m ~>) => w a ~> m a
newtype DiKleisli w m ~> a b
DiKleisli :: w a ~> m b -> DiKleisli w m ~> a b
runDiKleisli :: DiKleisli w m ~> a b -> w a ~> m b
instance (CDyad w m k) => Category (DiKleisli w m k)

module Control.Monad.Categorical
class (CPointed m ~>, CBind m ~>) => CMonad m ~>
class (CFunctor m ~> ~>) => CBind m ~>
cjoin :: (CBind m ~>) => m (m a) ~> m a
cbind :: (CBind m ~>) => (a ~> m b) -> (m a ~> m b)
class (CFunctor m ~> ~>) => CPointed m ~>
creturn :: (CPointed m ~>) => a ~> m a


-- | If you look at the reader arrow: <tt>(e, a) -&gt; a</tt> you can see
--   that all the interesting bits are bunched on the left. This is that
--   comonad. Flipping the pair and currying the arguments yields <tt>a
--   -&gt; (e -&gt; a)</tt>, and you can recognize the (e -&gt; a) as the
--   reader monad. In more technical language the Reader comonad is left
--   adjoint to the Reader monad.
module Control.Comonad.Reader
data Coreader r a
Coreader :: r -> a -> Coreader r a
runCoreader :: Coreader r a -> (r, a)
newtype CoreaderT w r a
CoreaderT :: w (r, a) -> CoreaderT w r a
runCoreaderT :: CoreaderT w r a -> w (r, a)
class (Comonad w) => ComonadReader r w | w -> r
askC :: (ComonadReader r w) => w a -> r
instance ComonadReader e ((,) e)
instance (Functor f) => Bifunctor (CoreaderT f) Hask Hask Hask
instance (Functor f) => QFunctor (CoreaderT f) Hask Hask
instance (Functor f) => PFunctor (CoreaderT f) Hask Hask
instance (Comonad w) => Comonad (CoreaderT w b)
instance (Copointed w) => Copointed (CoreaderT w b)
instance (Functor f) => Functor (CoreaderT f b)
instance (Comonad w) => ComonadReader r (CoreaderT w r)
instance Bifunctor Coreader Hask Hask Hask
instance QFunctor Coreader Hask Hask
instance PFunctor Coreader Hask Hask
instance Comonad (Coreader r)
instance Copointed (Coreader r)
instance Functor (Coreader r)
instance ComonadReader r (Coreader r)


-- | transform a pair of functors with a bifunctor deriving a new functor.
--   this subsumes functor product and functor coproduct
module Control.Functor.Combinators.Lift
newtype Lift p f g a
Lift :: p (f a) (g a) -> Lift p f g a
runLift :: Lift p f g a -> p (f a) (g a)
type :*: f g = Lift (,) f g
runProductF :: (f :*: g) a -> (f a, g a)
type :+: f g = Lift Either f g
runCoproductF :: (f :+: g) a -> Either (f a) (g a)
type Ap p = Lift p Identity
runAp :: (Bifunctor p Hask Hask Hask) => Ap p f a -> p a (f a)
mkAp :: (Bifunctor p Hask Hask Hask) => p a (f a) -> Ap p f a
instance (Copointed f, Copointed g) => Copointed (f :+: g)
instance (Faithful f, Faithful g) => Faithful (f :*: g)
instance (Applicative f, Applicative g) => Applicative (f :*: g)
instance (Pointed f, Pointed g) => Pointed (f :*: g)
instance (Bifunctor p Hask Hask Hask) => HFunctor (Ap p)
instance (Bifunctor p Hask Hask Hask, ExpFunctor f, ExpFunctor g) => ExpFunctor (Lift p f g)
instance (Bifunctor p Hask Hask Hask, ContraFunctor f, ContraFunctor g) => ContraFunctor (Lift p f g)
instance (Bifunctor p Hask Hask Hask, Functor f, Functor g) => Functor (Lift p f g)


-- | Algebras, Coalgebras, Bialgebras, and Dialgebras and their (co)monadic
--   variants
module Control.Functor.Algebra

-- | F,G-dialgebras generalize algebras and coalgebras NB: these
--   definitions are actually wrong.
type Dialgebra f g a = f a -> g a
type GDialgebra f g w m a = f (w a) -> g (m a)

-- | F-G-bialgebras are representable by <tt>DiAlg (f :+: Identity)
--   (Identity :+: g) a</tt> and so add no expressive power, but are a lot
--   more convenient.
type Bialgebra f g a = (Algebra f a, Coalgebra g a)
type GBialgebra f g w m a = (GAlgebra f w a, GCoalgebra g m a)

-- | F-Algebras
type Algebra f a = f a -> a

-- | F-W-Comonadic Algebras for a given comonad W
type GAlgebra f w a = f (w a) -> a

-- | F-Coalgebras
type Coalgebra f a = a -> f a

-- | F-M-Monadic Coalgebras for a given monad M
type GCoalgebra f m a = a -> f (m a)

-- | Martin Erwig's trialgebras for indexed data types
type Trialgebra f g h a = (Algebra f a, Dialgebra g h a)

-- | Turn an F-algebra into a F-W-algebra by throwing away the comonad
liftAlgebra :: (Functor f, Comonad w) => Algebra f :~> GAlgebra f w

-- | Turn a F-coalgebra into a F-M-coalgebra by returning into a monad
liftCoalgebra :: (Functor f, Monad m) => Coalgebra f :~> GCoalgebra f m
liftDialgebra :: (Functor g, Functor f, Comonad w, Monad m) => Dialgebra f g :~> GDialgebra f g w m
fromCoalgebra :: Coalgebra f :~> Dialgebra Identity f
fromAlgebra :: Algebra f :~> Dialgebra f Identity
fromBialgebra :: Bialgebra f g :~> Dialgebra (f :*: Identity) (Identity :*: g)


-- | Elgot algebras, and their obvious dual, based on:
--   <a>http://www.iti.cs.tu-bs.de/~milius/research/elgot_lmcs.pdf</a>
--   
--   Elgot algebras given you a shortcircuitable hylomorphism where you can
--   directly return a sub-answer to the catamorphism.
--   
--   Elgot coalgebras are defined in:
--   <a>http://comonad.com/reader/2008/elgot-coalgebras/</a>
module Control.Functor.Algebra.Elgot

-- | Elgot algebra
elgot :: (Functor f) => Algebra f a -> (b -> Either a (f b)) -> b -> a

-- | Elgot coalgebra
coelgot :: (Functor f) => ((a, f b) -> b) -> Coalgebra f a -> a -> b


module Control.Functor.Combinators.Join
newtype Join p a
Join :: p a a -> Join p a
runJoin :: Join p a -> p a a
instance (Bifunctor p Hask Hask Hask) => Functor (Join p)


-- | Generalized hylomorphisms
module Control.Morphism.Hylo

-- | hylo :: (g b -&gt; b) -&gt; (forall c. f c -&gt; g c) -&gt; (a -&gt; f
--   b) -&gt; a -&gt; b
hylo :: (Functor f) => Algebra g b -> (f :~> g) -> Coalgebra f a -> a -> b

-- | g_hylo :: (Comonad w, Functor f, Monad m) =&gt; (forall d. g (w d)
--   -&gt; w (g d)) -&gt; (forall e. m (f e) -&gt; f (m e)) -&gt; (g (w b)
--   -&gt; b) -&gt; (forall c. f c -&gt; g c) -&gt; a -&gt; f (m a) -&gt; a
--   -&gt; b
g_hylo :: (Comonad w, Functor f, Monad m) => Dist g w -> Dist m f -> GAlgebra g w b -> (f :~> g) -> GCoalgebra f m a -> a -> b
bihylo :: (QFunctor f Hask Hask) => Algebra (g d) b -> (f c :~> g d) -> Coalgebra (f c) a -> a -> b
g_bihylo :: (Comonad w, QFunctor f Hask Hask, Monad m) => Dist (g d) w -> Dist m (f c) -> GAlgebra (g d) w b -> (f c :~> g d) -> GCoalgebra (f c) m a -> a -> b

-- | higher order hylomorphisms for use in building up and tearing down
--   higher order functors
hhylo :: (HFunctor f) => HAlgebra f b -> HCoalgebra f a -> a :~> b


-- | Since in Hask, Mu = Nu, we don't bother to distinguish them here
module Control.Functor.Fix
newtype FixF f
InF :: f (FixF f) -> FixF f
outF :: FixF f -> f (FixF f)
outM :: (Functor f, Monad m) => GCoalgebra f m (FixF f)
inW :: (Functor f, Comonad w) => GAlgebra f w (FixF f)
identityBialgebraF :: Bialgebra f f (FixF f)
newtype Fix s a
InB :: s a (Fix s a) -> Fix s a
outB :: Fix s a -> s a (Fix s a)
identityBialgebraB :: Bialgebra (f a) (f a) (Fix f a)
paugment :: (PMonad f) => (forall c. (f a c -> c) -> c) -> (a -> Fix f b) -> Fix f b
pcoaugment :: (PComonad f) => ((Fix f a -> f b (Fix f a)) -> Fix f b) -> (Fix f a -> b) -> Fix f b
instance (Bifunctor f Hask Hask Hask, PMonad f) => Monad (Fix f)
instance (Bifunctor f Hask Hask Hask, PComonad f) => Comonad (Fix f)
instance (Bifunctor f Hask Hask Hask, PPointed f) => Pointed (Fix f)
instance (Bifunctor f Hask Hask Hask, PCopointed f) => Copointed (Fix f)
instance (Bifunctor s Hask Hask Hask) => Functor (Fix s)


-- | Martin Erwig's exomorphism
module Control.Morphism.Exo

-- | Martin Erwig's exomorphism from d to d'
exo :: (Functor h) => Bialgebra m n b -> (h b -> m b) -> (h a -> h (g a)) -> Trialgebra f g h a -> g a -> b


-- | Martin Erwig's metamorphisms for indexed data types.
--   
--   ADT fusion: <tt>snd c . fst c == id =&gt; erwig d id c . erwig c id d'
--   = erwig d id d'</tt>
--   
--   FreeMeta: <tt>l strict, snd c == snd c' == phi', fst d == fst d' ==
--   alpha, l . fst c = fst c' . fmap l, snd d' . rr = fmap r . snd d
--   ==&gt; l . (erwig d id c) = (erwig d' id c') . r</tt>
module Control.Morphism.Meta.Erwig

-- | <tt>meta d f c</tt> is Martin Erwig's metamorphism from <tt>c</tt> to
--   <tt>d</tt>
meta :: (Functor h) => Bialgebra m n b -> (h :~> m) -> Bialgebra f h a -> a -> b


module Control.Monad.Indexed.State
class (IxMonad m) => IxMonadState m
iget :: (IxMonadState m) => m i i i
iput :: (IxMonadState m) => j -> m i j ()
imodify :: (IxMonadState m) => (i -> j) -> m i j ()
igets :: (IxMonadState m) => (i -> a) -> m i i a
newtype IxStateT m i j a
IxStateT :: (i -> m (a, j)) -> IxStateT m i j a
runIxStateT :: IxStateT m i j a -> i -> m (a, j)
newtype IxState i j a
IxState :: (i -> (a, j)) -> IxState i j a
runIxState :: IxState i j a -> i -> (a, j)
instance (MonadWriter w m) => MonadWriter w (IxStateT m i i)
instance (MonadError e m) => MonadError e (IxStateT m i i)
instance (MonadCont m) => MonadCont (IxStateT m i i)
instance (MonadReader r m) => MonadReader r (IxStateT m i i)
instance (MonadIO m) => MonadIO (IxStateT m i i)
instance IxMonadTrans IxStateT
instance (Monad m) => MonadState i (IxStateT m i i)
instance (Monad m) => Applicative (IxStateT m i i)
instance (Monad m) => Monad (IxStateT m i i)
instance (MonadFix m) => MonadFix (IxStateT m i i)
instance (MonadFix m) => IxMonadFix (IxStateT m)
instance (MonadPlus m) => IxMonadPlus (IxStateT m)
instance (MonadPlus m) => IxMonadZero (IxStateT m)
instance (Monad m) => IxMonadState (IxStateT m)
instance (Monad m) => Bifunctor (IxStateT m i) Hask Hask Hask
instance (Monad m) => QFunctor (IxStateT m i) Hask Hask
instance (Monad m) => PFunctor (IxStateT m i) Hask Hask
instance (Monad m) => IxMonad (IxStateT m)
instance (Monad m) => IxApplicative (IxStateT m)
instance (Monad m) => IxPointed (IxStateT m)
instance (Monad m) => IxFunctor (IxStateT m)
instance (Monad m) => Functor (IxStateT m i j)
instance IxMonadFix IxState
instance MonadFix (IxState i i)
instance MonadState i (IxState i i)
instance Applicative (IxState i i)
instance Monad (IxState i i)
instance Bifunctor (IxState i) Hask Hask Hask
instance QFunctor (IxState i) Hask Hask
instance PFunctor (IxState i) Hask Hask
instance IxMonadState IxState
instance IxMonad IxState
instance IxApplicative IxState
instance IxPointed IxState
instance IxFunctor IxState
instance Functor (IxState i j)


-- | Based on the construction of hyperfunctions as parameterized monads in
--   <a>http://crab.rutgers.edu/~pjohann/f14-ghani.pdf</a>
module Control.Monad.Hyper
class ContraFunctor f
contramap :: (ContraFunctor f) => (a -> b) -> f b -> f a

-- | A generic recursive hyperfunction-like combinator
type Hyper h a = Fix (PHyper h)

-- | Traditional Hyper functions
type Hyp e a = Hyper (ContraF e) a
newtype PHyper h a b
PHyper :: (h b -> a) -> PHyper h a b
runPHyper :: PHyper h a b -> h b -> a
instance (ContraFunctor h) => PMonad (PHyper h)
instance (ContraFunctor h) => PApplicative (PHyper h)
instance (ContraFunctor h) => PPointed (PHyper h)
instance (ContraFunctor h) => Bifunctor (PHyper h) Hask Hask Hask
instance (ContraFunctor h) => QFunctor (PHyper h) Hask Hask
instance PFunctor (PHyper h) Hask Hask


module Control.Category.Braided

-- | A braided (co)(monoidal or associative) category can commute the
--   arguments of its bi-endofunctor. Obeys the laws:
--   
--   <pre>
--   idr . braid = idl 
--   idl . braid = idr 
--   braid . coidr = coidl 
--   braid . coidl = coidr 
--   associate . braid . associate = second braid . associate . first braid 
--   coassociate . braid . coassociate = first braid . coassociate . second braid 
--   </pre>
class Braided k p
braid :: (Braided k p) => k (p a b) (p b a)

-- | If we have a symmetric (co)<tt>Monoidal</tt> category, you get the
--   additional law:
--   
--   <pre>
--   swap . swap = id
--   </pre>
class (Braided k p) => Symmetric k p
swap :: (Symmetric k p) => k (p a b) (p b a)
instance Symmetric Hask (,)
instance Braided Hask (,)
instance Symmetric Hask Either
instance Braided Hask Either


module Control.Functor.Combinators.Biff
newtype Biff p f g a b
Biff :: p (f a) (g b) -> Biff p f g a b
runBiff :: Biff p f g a b -> p (f a) (g b)
type On p f = Biff p f f
runOn :: On p f a b -> p (f a) (f b)
mkOn :: p (f a) (f b) -> On p f a b
type PAp p = Biff p Identity
runPAp :: (PFunctor p Hask Hask) => PAp p f a b -> p a (f b)
mkPAp :: (PFunctor p Hask Hask) => p a (f b) -> PAp p f a b
type PCofree = PAp (,)
runPCofree :: PCofree f a b -> (a, f b)
pcofree :: (a, f b) -> PCofree f a b
type PFree = PAp Either
runPFree :: PFree f a b -> Either a (f b)
pfree :: Either a (f b) -> PFree f a b
instance (Functor f) => PComonad (PCofree f)
instance (FunctorPlus f) => PMonad (PCofree f)
instance (FunctorPlus f) => PApplicative (PCofree f)
instance (Functor f) => PMonad (PFree f)
instance (Functor f) => PApplicative (PFree f)
instance (Functor f) => PCopointed (PCofree f)
instance (Functor f) => PPointed (PFree f)
instance (FunctorPlus f) => PPointed (PCofree f)
instance (Functor f, Bifunctor p Hask Hask Hask, Functor g) => Functor (Biff p f g a)
instance (Functor f, Symmetric Hask p) => Symmetric Hask (Biff p f f)
instance (Functor f, Braided Hask p) => Braided Hask (Biff p f f)
instance (Functor f, Bifunctor p Hask Hask Hask, Functor g) => Bifunctor (Biff p f g) Hask Hask Hask
instance (QFunctor q Hask Hask, Functor g) => QFunctor (Biff q f g) Hask Hask
instance (Functor f, PFunctor p Hask Hask) => PFunctor (Biff p f g) Hask Hask


-- | Examples: type LV = Cofree Maybe type Stream = Cofree Identity
module Control.Comonad.Cofree
type Cofree f = Fix (PCofree f)
runCofree :: Cofree f a -> (a, f (Cofree f a))
cofree :: a -> f (Cofree f a) -> Cofree f a
class (Functor f, Comonad w) => ComonadCofree f w | w -> f
outCofree :: (ComonadCofree f w) => w a -> f (w a)
class (ComonadCofree f w) => RunComonadCofree f w | w -> f
anaCofree :: (RunComonadCofree f w, Functor f) => (a -> c) -> (a -> f a) -> a -> w c
instance (Functor f) => RunComonadCofree f (Cofree f)
instance (ComonadCofree f w) => ComonadCofree f (CoreaderT w e)
instance (Functor f) => ComonadCofree f (Cofree f)


module Control.Comonad.Stream
type Stream = Cofree Identity


-- | Generalized functor composition. Since we have many reasons for which
--   you might want to compose a functor, and many expected results. i.e.
--   monads via adjunctions, monads via composition with a pointed
--   endofunctor, etc. we have to make multiple composition operators.
module Control.Functor.Composition

-- | Basic functor composition
newtype CompF f g a
CompF :: f (g a) -> CompF f g a
runCompF :: CompF f g a -> f (g a)
class Composition o
decompose :: (Composition o) => (f o g) x -> f (g x)
compose :: (Composition o) => f (g x) -> (f o g) x

-- | The only reason the compositions are all the same is for type
--   inference. This can be liberalized.
associateComposition :: (Functor f, Composition o) => ((f o g) o h) :~> (f o (g o h))
coassociateComposition :: (Functor f, Composition o) => (f o (g o h)) :~> ((f o g) o h)

-- | An infix alias for functor composition
type :.: = CompF
preTransform :: (Composition o) => (f :~> g) -> (f o k) :~> (g o k)
postTransform :: (Functor k, Composition o) => (f :~> g) -> (k o f) :~> (k o g)

-- | Bifunctor composition
data Comp p f g a b

-- | Bifunctor coproduct
type :++: = Comp Either

-- | Bifunctor product
type :**: = Comp (,)
liftComp :: (Bifunctor p r s Hask) => r (f a b) (f c d) -> s (g a b) (g c d) -> Comp p f g a b -> Comp p f g c d
instance (Bifunctor p Hask Hask Hask, Bifunctor f Hask Hask Hask, Bifunctor g Hask Hask Hask) => Functor (Comp p f g a)
instance (Bifunctor p Hask Hask Hask, Symmetric Hask f, Symmetric Hask g) => Symmetric Hask (Comp p f g)
instance (Bifunctor p Hask Hask Hask, Braided Hask f, Braided Hask g) => Braided Hask (Comp p f g)
instance (Bifunctor p c d Hask, Bifunctor f a b c, Bifunctor g a b d) => Bifunctor (Comp p f g) a b Hask
instance (Bifunctor p c d Hask, QFunctor f b c, QFunctor g b d) => QFunctor (Comp p f g) b Hask
instance (Bifunctor p c d Hask, PFunctor f a c, PFunctor g a d) => PFunctor (Comp p f g) a Hask
instance (Full f, Full g) => Full (CompF f g)
instance (ExpFunctor f, ExpFunctor g) => ExpFunctor (CompF f g)
instance (Functor f, Functor g) => Functor (CompF f g)
instance (Functor f) => HFunctor (CompF f)
instance Composition CompF


module Control.Functor.Adjunction

-- | An <a>Adjunction</a> formed by the <a>Functor</a> f and <a>Functor</a>
--   g.
class (Representable g (f ()), Functor f) => Adjunction f g | f -> g, g -> f
unit :: (Adjunction f g) => a -> g (f a)
counit :: (Adjunction f g) => f (g a) -> a
leftAdjunct :: (Adjunction f g) => (f a -> b) -> a -> g b
rightAdjunct :: (Adjunction f g) => (a -> g b) -> f a -> b

-- | Adjunction-oriented composition, yields monads and comonads from
--   adjunctions
newtype ACompF f g a
ACompF :: (CompF f g a) -> ACompF f g a
repAdjunction :: (Adjunction f g) => (f () -> a) -> g a
unrepAdjunction :: (Adjunction f g) => g a -> (f () -> a)


-- | Left and right Kan extensions, expressed as higher order functors
--   
--   See <a>http://comonad.com/reader/2008/kan-extensions/</a> and
--   <a>http://comonad.com/reader/2008/kan-extensions-ii/</a> for
--   motivation.
--   
--   NB: <tt>Yoneda</tt>, <tt>CoYoneda</tt>, <tt>Density</tt>,
--   <tt>Codensity</tt> have been factored out into separate modules.
module Control.Functor.KanExtension

-- | The right Kan Extension of h along g. An alternative definition in
--   terms of Ends.
--   
--   <pre>
--   newtype RanT g h a b b' { (a -&gt; g b) -&gt; h b' }
--   </pre>
--   
--   <pre>
--   type Ran g h a = End (RanT g h a)
--   </pre>
newtype Ran g h a
Ran :: (forall b. (a -> g b) -> h b) -> Ran g h a
runRan :: Ran g h a -> forall b. (a -> g b) -> h b

-- | Nat(k <tt>o</tt> g, h) is isomorphic to Nat(k, Ran g h) (forwards)
toRan :: (Composition o, Functor k) => ((k o g) :~> h) -> k :~> Ran g h

-- | Nat(k <tt>o</tt> g, h) is isomorphic to Nat(k, Ran g h) (backwards)
fromRan :: (Composition o) => (k :~> Ran g h) -> (k o g) :~> h

-- | <tt>f -| g</tt> iff <tt>Ran g Identity</tt> exists (forward)
adjointToRan :: (Adjunction f g) => f :~> Ran g Identity

-- | <tt>f -| g</tt> iff <tt>Ran g Identity</tt> exists (backwards)
ranToAdjoint :: (Adjunction f g) => Ran g Identity :~> f
ranToComposedAdjoint :: (Composition o, Adjunction f g) => Ran g h :~> (h o f)
composedAdjointToRan :: (Functor h, Composition o, Adjunction f g) => (h o f) :~> Ran g h

-- | The natural isomorphism from <tt>Ran f (Ran g h)</tt> to <tt>Ran (f
--   <tt>o</tt> g) h</tt> (forwards)
composeRan :: (Composition o) => Ran f (Ran g h) :~> Ran (f o g) h

-- | The natural isomorphism from <tt>Ran f (Ran g h)</tt> to <tt>Ran (f
--   <tt>o</tt> g) h</tt> (backwards)
decomposeRan :: (Functor f, Composition o) => Ran (f o g) h :~> Ran f (Ran g h)

-- | Left Kan Extension
--   
--   <pre>
--   newtype LanT g h a b b' { (g b -&gt; a, h b') }
--   </pre>
--   
--   <pre>
--   type Lan g h a = Coend (LanT g h a)
--   </pre>
data Lan g h a
Lan :: (g b -> a) -> (h b) -> Lan g h a

-- | <tt>Nat(h, f.g)</tt> is isomorphic to <tt>Nat (Lan g h, f)</tt>
--   (forwards)
toLan :: (Composition o, Functor f) => (h :~> (f o g)) -> Lan g h :~> f

-- | <tt>Nat(h, f.g)</tt> is isomorphic to <tt>Nat (Lan g h, f)</tt>
--   (backwards)
fromLan :: (Composition o) => (Lan g h :~> f) -> h :~> (f o g)

-- | f -| g iff Lan f Identity is inhabited (forwards)
adjointToLan :: (Adjunction f g) => g :~> Lan f Identity

-- | f -| g iff Lan f Identity is inhabited (backwards)
lanToAdjoint :: (Adjunction f g) => Lan f Identity :~> g

-- | the natural isomorphism from <tt>Lan f (Lan g h)</tt> to <tt>Lan (f
--   <tt>o</tt> g) h</tt> (forwards)
composeLan :: (Functor f, Composition o) => Lan f (Lan g h) :~> Lan (f o g) h

-- | the natural isomorphism from <tt>Lan f (Lan g h)</tt> to <tt>Lan (f
--   <tt>o</tt> g) h</tt> (backwards)
decomposeLan :: (Composition o) => Lan (f o g) h :~> Lan f (Lan g h)
lanToComposedAdjoint :: (Functor h, Composition o, Adjunction f g) => Lan f h :~> (h o g)
composedAdjointToLan :: (Composition o, Adjunction f g) => (h o g) :~> Lan f h
instance Functor (Lan f g)
instance (Functor g) => HFunctor (Lan g)
instance Functor (Ran g h)
instance HFunctor (Ran g)


-- | The density comonad for a functor. aka the comonad cogenerated by a
--   functor The ''density'' term dates back to Dubuc''s 1974 thesis. The
--   term ''monad genererated by a functor'' dates back to 1972 in
--   Street''s ''Formal Theory of Monads''.
module Control.Comonad.Density
data Density k a
Density :: (k b -> a) -> (k b) -> Density k a
densityToLan :: Density k a -> Lan k k a
lanToDensity :: Lan k k a -> Density k a

-- | <tt>Nat(k, s.k)</tt> is isomorphic to <tt>Nat (Density k, s)</tt>
--   (forwards)
toDensity :: (Functor s) => (forall a. k a -> s (k a)) -> Density k :~> s

-- | <tt>Nat(k, s.k)</tt> is isomorphic to <tt>Nat (Density k, s)</tt>
--   (backwards)
fromDensity :: (Density k :~> s) -> k a -> s (k a)

-- | The natural isomorphism between a comonad w and the comonad generated
--   by w (forwards).
liftDensity :: (Comonad w) => w a -> Density w a

-- | The natural isomorphism between a comonad w and the comonad generated
--   by w (backwards).
lowerDensity :: (Comonad w) => Density w a -> w a
densityToAdjunction :: (Adjunction f g) => Density f a -> f (g a)
adjunctionToDensity :: (Adjunction f g) => f (g a) -> Density f a
densityToComposedAdjunction :: (Composition o, Adjunction f g) => Density f :~> (f o g)
composedAdjunctionToDensity :: (Composition o, Adjunction f g) => (f o g) :~> Density f
improveCofree :: (Functor f) => (forall w. (ComonadCofree f w) => w a) -> Cofree f a
instance (RunComonadCofree f w) => RunComonadCofree f (Density w)
instance (ComonadCofree f w) => ComonadCofree f (Density w)
instance (ComonadContext e w) => ComonadContext e (Density w)
instance (ComonadReader e w) => ComonadReader e (Density w)
instance Comonad (Density f)
instance Copointed (Density f)
instance Functor (Density f)
instance ComonadTrans Density


-- | Ghani and Johann's Interp/InterpT types from ''Initial Algebra
--   Semantics is Enough!''
--   <a>http://crab.rutgers.edu/~pjohann/tlca07-rev.pdf</a> and its dual.
module Control.Functor.KanExtension.Interpreter
type Interpreter y g h = y :~> Ran g h
type InterpreterT f g h = forall y. (Functor y) => Interpreter y g h -> Interpreter (f y) g h
interpreterAlgebra :: InterpreterT f g h -> HAlgebra f (Ran g h)
algebraInterpreter :: (HFunctor f) => HAlgebra f (Ran g h) -> InterpreterT f g h
type Cointerpreter y g h = Lan g h :~> y
type CointerpreterT f g h = forall y. (Functor y) => Cointerpreter y g h -> Cointerpreter (f y) g h
cointerpreterCoalgebra :: CointerpreterT f g h -> HCoalgebra f (Lan g h)
coalgebraCointerpreter :: (HFunctor f) => HCoalgebra f (Lan g h) -> CointerpreterT f g h


module Control.Morphism.Cata
cata :: (Functor f) => Algebra f a -> FixF f -> a
g_cata :: (Functor f, Comonad w) => Dist f w -> GAlgebra f w a -> FixF f -> a
distCata :: (Functor f) => Dist f Identity
bicata :: (QFunctor f Hask Hask) => Algebra (f b) a -> Fix f b -> a
g_bicata :: (QFunctor f Hask Hask, Comonad w) => Dist (f b) w -> GAlgebra (f b) w a -> Fix f b -> a
hcata :: (HFunctor f) => HAlgebra f a -> FixH f :~> a
kcata :: (HFunctor f) => InterpreterT f g h -> FixH f :~> Ran g h
runkcata :: (HFunctor f) => InterpreterT f g h -> FixH f a -> (a -> g b) -> h b


-- | See Maarten Fokkinga''s PhD Dissertation for cascade and prepro.
--   g_prepro is an obvious generalization. The prepro variants of other
--   morphisms are distributed through the corresponding files.
module Control.Morphism.Prepro

-- | Fokkinga's Prepromorphism
prepro :: (Functor f) => Algebra f c -> (f :~> f) -> FixF f -> c

-- | Generalized prepromorphisms, parameterized by a comonad This is used
--   to generate most of the specialized prepromorphisms in other modules.
--   You can use the distributive law combinators to build up analogues of
--   other recursion schemes.
g_prepro :: (Functor f, Comonad w) => Dist f w -> GAlgebra f w a -> (f :~> f) -> FixF f -> a

-- | <pre>
--   cascade f . map f = map f . cascade f
--   </pre>
--   
--   <pre>
--   cascade f = biprepro InB (first f)
--   </pre>
--   
--   <pre>
--   cascade f = x where x = InB . bimap id (x . fmap f) . outB
--   </pre>
--   
--   <pre>
--   cascade f = x where x = InB . bimap id (fmap f . x) . outB
--   </pre>
cascade :: (Bifunctor s Hask Hask Hask) => (a -> a) -> Fix s a -> Fix s a

-- | Prepromorphisms for bifunctors
biprepro :: (Bifunctor f Hask Hask Hask) => Algebra (f a) c -> (f a :~> f a) -> Fix f a -> c

-- | Generalized bifunctor prepromorphism, parameterized by a comonad
g_biprepro :: (Bifunctor f Hask Hask Hask, Comonad w) => Dist (f a) w -> GAlgebra (f a) w c -> (f a :~> f a) -> Fix f a -> c


-- | Traditional operators, shown here to show how to roll your own
module Control.Morphism.Histo
distHisto :: (RunComonadCofree h w, Functor f) => Dist f h -> Dist f w
histo :: (RunComonadCofree f w) => GAlgebra f w a -> FixF f -> a
g_histo :: (RunComonadCofree h w, Functor f) => Dist f h -> GAlgebra f w a -> FixF f -> a
prepro_histo :: (RunComonadCofree f w) => GAlgebra f w a -> (f :~> f) -> FixF f -> a
g_prepro_histo :: (RunComonadCofree h w, Functor f) => Dist f h -> GAlgebra f w a -> (f :~> f) -> FixF f -> a


module Control.Morphism.Zygo
type Zygo = (,)
type ZygoT = CoreaderT
distZygo :: (Functor f) => Algebra f b -> Dist f (Zygo b)
distZygoT :: (Functor f, Comonad w) => GAlgebra f w b -> Dist f w -> Dist f (ZygoT w b)
zygo :: (Functor f) => Algebra f b -> GAlgebra f (Zygo b) a -> FixF f -> a
g_zygo :: (Functor f, Comonad w) => GAlgebra f w b -> Dist f w -> GAlgebra f (ZygoT w b) a -> FixF f -> a

-- | a zygomorphic prepromorphism
prepro_zygo :: (Functor f) => Algebra f b -> GAlgebra f (Zygo b) a -> (f :~> f) -> FixF f -> a

-- | a generalized zygomorphic prepromorphism
g_prepro_zygo :: (Functor f, Comonad w) => GAlgebra f w b -> Dist f w -> GAlgebra f (ZygoT w b) a -> (f :~> f) -> FixF f -> a


module Control.Morphism.Para
type Para f = (,) (FixF f)
type ParaT w f = CoreaderT w (FixF f)
distParaT :: (Functor f, Comonad w) => Dist f w -> Dist f (ParaT w f)
para :: (Functor f) => GAlgebra f (Para f) a -> FixF f -> a

-- | Generalized paramorphisms using a comonad reader transformer to carry
--   the primitive recursive state
g_para :: (Functor f, Comonad w) => Dist f w -> GAlgebra f (ParaT w f) a -> FixF f -> a

-- | A paramorphic prepromorphism
prepro_para :: (Functor f) => GAlgebra f (Para f) a -> (f :~> f) -> FixF f -> a

-- | A generalized paramorphic prepromorphism
g_prepro_para :: (Functor f, Comonad w) => Dist f w -> GAlgebra f (ParaT w f) a -> (f :~> f) -> FixF f -> a


module Control.Morphism.Ana

-- | Anamorphisms are a generalized form of <tt>unfoldr</tt>
ana :: (Functor f) => Coalgebra f a -> a -> FixF f

-- | Generalized anamorphisms allow you to work with a monad given a
--   distributive law
g_ana :: (Functor f, Monad m) => Dist m f -> GCoalgebra f m a -> a -> FixF f

-- | The distributive law for the identity monad
distAna :: (Functor f) => Dist Identity f
biana :: (QFunctor f Hask Hask) => Coalgebra (f b) a -> a -> Fix f b
g_biana :: (QFunctor f Hask Hask, Monad m) => Dist m (f b) -> GCoalgebra (f b) m a -> a -> Fix f b

-- | A higher-order anamorphism for constructing higher order functors.
hana :: (HFunctor f) => HCoalgebra f a -> a :~> FixH f
kana :: (HFunctor f) => CointerpreterT f g h -> Lan g h :~> FixH f
runkana :: (HFunctor f) => CointerpreterT f g h -> (g b -> a) -> h b -> FixH f a


module Control.Functor.Lambek
lambek :: (Functor f) => Algebra f (FixF f) -> Coalgebra f (FixF f)
hlambek :: (HFunctor f) => HAlgebra f (FixH f) -> HCoalgebra f (FixH f)
colambek :: (Functor f) => Coalgebra f (FixF f) -> Algebra f (FixF f)
hcolambek :: (HFunctor f) => HCoalgebra f (FixH f) -> HAlgebra f (FixH f)


-- | See Maarten Fokkinga''s PhD Dissertation for postpro. g_postpro is an
--   obvious generalization.
module Control.Morphism.Postpro
postpro :: (Functor f) => Coalgebra f c -> (f :~> f) -> c -> FixF f

-- | Generalized postpromorphisms
g_postpro :: (Functor f, Monad m) => Dist m f -> GCoalgebra f m a -> (f :~> f) -> a -> FixF f
bipostpro :: (Bifunctor f Hask Hask Hask) => Coalgebra (f a) c -> (f a :~> f a) -> c -> Fix f a
g_bipostpro :: (Bifunctor f Hask Hask Hask, Monad m) => Dist m (f a) -> GCoalgebra (f a) m c -> (f a :~> f a) -> c -> Fix f a


-- | Traditional operators, shown here to show how to roll your own
module Control.Morphism.Apo
apo :: (Functor f) => GCoalgebra f (Apo f) a -> a -> FixF f
g_apo :: (Functor f) => Coalgebra f b -> GCoalgebra f (GApo b) a -> a -> FixF f
postpro_apo :: (Functor f) => GCoalgebra f (Apo f) a -> (f :~> f) -> a -> FixF f
g_postpro_apo :: (Functor f) => Coalgebra f b -> GCoalgebra f (GApo b) a -> (f :~> f) -> a -> FixF f
type Apo f a = Either (FixF f) a
type ApoT f m a = EitherT (FixF f) m a
distApoT :: (Functor f, Monad m) => Dist m f -> Dist (ApoT f m) f
type GApo b a = Either b a
type GApoT b m a = EitherT b m a
distGApo :: (Functor f) => Coalgebra f b -> Dist (Either b) f
distGApoT :: (Functor f, Monad m) => GCoalgebra f m b -> Dist m f -> Dist (EitherT b m) f


module Control.Morphism.Dyna
dyna :: (Functor f, RunComonadCofree g w) => GAlgebra g w b -> (f :~> g) -> Coalgebra f a -> a -> b


-- | A very basic Jeremy Gibbons metamorphism, without all the productive
--   stream stuff. See:
--   <a>http://www.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/metamorphisms-scp.pdf</a>
--   TODO: Add some support for spigot algorithms over streams/lists.
module Control.Morphism.Meta.Gibbons
meta :: (Functor f, Functor g) => Coalgebra f b -> (a -> b) -> Algebra g a -> FixF g -> FixF f

-- | Generalized Jeremy Gibbons metamorphism
g_meta :: (Monad m, Functor f, Comonad w, Functor g) => Dist m f -> Dist g w -> GCoalgebra f m b -> (a -> b) -> GAlgebra g w a -> FixF g -> FixF f


module Control.Morphism.Build

-- | <tt>forall h g. hcata h . hbuild g = g h</tt> cannot be realized as a
--   RULE because h and g are not monotypes. Kan extended build, gbuild in
--   Ghani/Johann parlance, but g_foo currently denotes generalized in the
--   'has a parameterizing (co)monad' sense.
hbuild :: (HFunctor f, Functor c) => (forall x. HAlgebra f x -> c :~> x) -> c :~> FixH f

-- | <tt> forall h g. kcata h . kbuild g = g (interpreterAlgebra h)</tt>
--   cannot be realized as a RULE because h and g are not monotypes.
kbuild :: (HFunctor f) => (forall x. HAlgebra f x -> Lan g h :~> x) -> Lan g h :~> FixH f


module Control.Morphism.Destroy

-- | <tt>forall h g . hdestroy g . hana h = g h</tt> cannot be realized as
--   a RULE.
hdestroy :: (HFunctor f, Functor c) => (forall g. HCoalgebra f g -> g :~> c) -> FixH f :~> c

-- | <tt>forall h g . kdestroy g . kana h = g (cointerpreterCoalgebra
--   h)</tt> cannot be realized as a RULE
kdestroy :: (HFunctor f) => (forall x. HCoalgebra f x -> x :~> Ran g h) -> FixH f :~> Ran g h


module Control.Functor.Representable
class (Functor f) => Representable f x
rep :: (Representable f x) => (x -> a) -> f a
unrep :: (Representable f x) => f a -> (x -> a)
class (ContraFunctor f) => Corepresentable f x
corep :: (Corepresentable f x) => (a -> x) -> f a
uncorep :: (Corepresentable f x) => f a -> (a -> x)
data Both a
Both :: a -> a -> Both a
data EitherF a b c
EitherF :: (a -> c) -> (b -> c) -> EitherF a b c


-- | Dual (bi)Functors
module Control.Functor.Zap

-- | Minimum definition: zapWith
class Zap f g | f -> g, g -> f
zapWith :: (Zap f g) => (a -> b -> c) -> f a -> g b -> c
zap :: (Zap f g) => f (a -> b) -> g a -> b
(>$<) :: (Zap f g) => f (a -> b) -> g a -> b

-- | Minimum definition: bizapWith
class Bizap p q | p -> q, q -> p
bizapWith :: (Bizap p q) => (a -> c -> e) -> (b -> d -> e) -> p a b -> q c d -> e
bizap :: (Bizap p q) => p (a -> c) (b -> c) -> q a b -> c
(>>$<<) :: (Bizap p q) => p (a -> c) (b -> c) -> q a b -> c


-- | TODO: finish the monad instances
module Control.Functor.Pointed.Composition
newtype PointedCompF f g a
PointedCompF :: (CompF f g a) -> PointedCompF f g a
newtype PostCompF mw f a
PostCompF :: (PointedCompF mw f a) -> PostCompF mw f a
newtype PreCompF f mw a
PreCompF :: (PointedCompF f mw a) -> PreCompF f mw a
newtype DistCompF f g a
DistCompF :: (PointedCompF f g a) -> DistCompF f g a
instance (Functor f, Functor g) => Functor (DistCompF f g)
instance (ExpFunctor f, ExpFunctor g) => ExpFunctor (DistCompF f g)
instance (Full f, Full g) => Full (DistCompF f g)
instance Composition DistCompF
instance (Pointed f, Pointed g) => Pointed (DistCompF f g)
instance (Copointed f, Copointed g) => Copointed (DistCompF f g)
instance (Functor f, Functor mw) => Functor (PreCompF f mw)
instance (ExpFunctor f, ExpFunctor mw) => ExpFunctor (PreCompF f mw)
instance (Full f, Full mw) => Full (PreCompF f mw)
instance Composition PreCompF
instance (Pointed f, Pointed mw) => Pointed (PreCompF f mw)
instance (Copointed f, Copointed mw) => Copointed (PreCompF f mw)
instance (Functor mw, Functor f) => Functor (PostCompF mw f)
instance (ExpFunctor mw, ExpFunctor f) => ExpFunctor (PostCompF mw f)
instance (Full mw, Full f) => Full (PostCompF mw f)
instance Composition PostCompF
instance (Pointed mw, Pointed f) => Pointed (PostCompF mw f)
instance (Copointed mw, Copointed f) => Copointed (PostCompF mw f)
instance (Functor f, Functor g) => Functor (PointedCompF f g)
instance (ExpFunctor f, ExpFunctor g) => ExpFunctor (PointedCompF f g)
instance (Full f, Full g) => Full (PointedCompF f g)
instance Composition PointedCompF
instance (Comonad f, Comonad g, Distributes f g) => Comonad (DistCompF f g)
instance (Copointed f, Comonad w, PreUnfold f w) => Comonad (PreCompF f w)
instance (Comonad w, Copointed f, PostUnfold w f) => Comonad (PostCompF w f)
instance (Copointed f, Copointed g) => Copointed (PointedCompF f g)
instance (Pointed f, Pointed g) => Pointed (PointedCompF f g)


module Control.Functor.Combinators.Of
newtype Of f p a b
Of :: f (p a b) -> Of f p a b
runOf :: Of f p a b -> f (p a b)
liftOf :: (Functor f) => (p a b -> p c d) -> Of f p a b -> Of f p c d
instance (Copointed f, Copointed (p a)) => Copointed (Of f p a)
instance (Pointed f, Pointed (p a)) => Pointed (Of f p a)
instance (Copointed f, PCopointed p) => PCopointed (Of f p)
instance (Pointed f, PPointed p) => PPointed (Of f p)
instance (Functor f, Functor (p a)) => Functor (Of f p a)
instance (Functor f, Symmetric Hask p) => Symmetric Hask (Of f p)
instance (Functor f, Braided Hask p) => Braided Hask (Of f p)
instance (Functor f, Bifunctor p Hask Hask Hask) => Bifunctor (Of f p) Hask Hask Hask
instance (Functor f, QFunctor p Hask Hask) => QFunctor (Of f p) Hask Hask
instance (Functor f, PFunctor p Hask Hask) => PFunctor (Of f p) Hask Hask


-- | A <a>Monoidal</a> category is a category with an associated
--   biendofunctor that has an identity, which satisfies Mac Lane''s
--   pentagonal and triangular coherence conditions Technically we usually
--   say that category is <tt>monoidal</tt>, but since most interesting
--   categories in our world have multiple candidate bifunctors that you
--   can use to enrich their structure, we choose here to think of the
--   bifunctor as being monoidal. This lets us reuse the same Bifunctor
--   over different categories without painful type annotations.
module Control.Category.Monoidal

-- | Denotes that we have some reasonable notion of <tt>Identity</tt> for a
--   particular <a>Bifunctor</a> in this <tt>Category</tt>. This notion is
--   currently used by both <a>Monoidal</a> and <a>Comonoidal</a>
class (Bifunctor p k k k) => HasIdentity k p i | k p -> i

-- | A monoidal category. <a>idl</a> and <a>idr</a> are traditionally
--   denoted lambda and rho the triangle identity holds:
--   
--   <pre>
--   bimap idr id = bimap id idl . associate 
--   bimap id idl = bimap idr id . associate
--   </pre>
class (Associative k p, HasIdentity k p i) => Monoidal k p i | k p -> i
idl :: (Monoidal k p i) => k (p i a) a
idr :: (Monoidal k p i) => k (p a i) a

-- | A comonoidal category satisfies the dual form of the triangle
--   identities
--   
--   <pre>
--   bimap idr id = coassociate . bimap id idl
--   bimap id idl = coassociate . bimap idr id
--   </pre>
--   
--   This type class is also (ab)used for the inverse operations needed for
--   a strict (co)monoidal category. A strict (co)monoidal category is one
--   that is both <a>Monoidal</a> and <a>Comonoidal</a> and satisfies the
--   following laws:
--   
--   <pre>
--   idr . coidr = id 
--   idl . coidl = id 
--   coidl . idl = id 
--   coidr . idr = id 
--   </pre>
class (Coassociative k p, HasIdentity k p i) => Comonoidal k p i | k p -> i
coidl :: (Comonoidal k p i) => k a (p i a)
coidr :: (Comonoidal k p i) => k a (p a i)
instance Monoidal Hask (,) Void
instance HasIdentity Hask (,) Void


module Control.Category.Cartesian

-- | NB: This is weaker than traditional category with products! That is
--   Cartesian, below. The problem is <tt>(-&gt;)</tt> lacks an initial
--   object, since every type is inhabited in Haskell. Consequently its
--   coproduct is merely a semigroup, not a monoid as it has no identity,
--   and since we want to be able to describe its dual category, which has
--   this non-traditional form being built over a category with an
--   associative bifunctor rather than as a monoidal category for the
--   product monoid.
--   
--   Minimum definition:
--   
--   <pre>
--   fst, snd, diag 
--   fst, snd, (&amp;&amp;&amp;)
--   </pre>
class (Associative k p, Coassociative k p, Braided k p) => PreCartesian k p | k -> p
fst :: (PreCartesian k p) => k (p a b) a
snd :: (PreCartesian k p) => k (p a b) b
diag :: (PreCartesian k p) => k a (p a a)
(&&&) :: (PreCartesian k p) => k a b -> k a c -> k a (p b c)

-- | free construction of <a>Bifunctor</a> for the product <a>Bifunctor</a>
--   <tt>Prod k</tt> if <tt>(&amp;&amp;&amp;)</tt> is known
bimapPreCartesian :: (PreCartesian k p) => k a c -> k b d -> k (p a b) (p c d)

-- | free construction of <a>Braided</a> for the product <a>Bifunctor</a>
--   <tt>Prod k</tt>
braidPreCartesian :: (PreCartesian k p) => k (p a b) (p b a)

-- | free construction of <a>Associative</a> for the product
--   <a>Bifunctor</a> <tt>Prod k</tt>
associatePreCartesian :: (PreCartesian k p) => k (p (p a b) c) (p a (p b c))

-- | free construction of <a>Coassociative</a> for the product
--   <a>Bifunctor</a> <tt>Prod k</tt>
coassociatePreCartesian :: (PreCartesian k p) => k (p a (p b c)) (p (p a b) c)
class (Associative k s, Coassociative k s, Braided k s) => PreCoCartesian k s | k -> s
inl :: (PreCoCartesian k s) => k a (s a b)
inr :: (PreCoCartesian k s) => k b (s a b)
codiag :: (PreCoCartesian k s) => k (s a a) a
(|||) :: (PreCoCartesian k s) => k a c -> k b c -> k (s a b) c

-- | free construction of <a>Bifunctor</a> for the coproduct
--   <a>Bifunctor</a> <tt>Sum k</tt> if <tt>(|||)</tt> is known
bimapPreCoCartesian :: (PreCoCartesian k s) => k a c -> k b d -> k (s a b) (s c d)

-- | free construction of <a>Braided</a> for the coproduct <a>Bifunctor</a>
--   <tt>Sum k</tt>
braidPreCoCartesian :: (PreCoCartesian k s) => k (s a b) (s b a)

-- | free construction of <a>Associative</a> for the coproduct
--   <a>Bifunctor</a> <tt>Sum k</tt>
associatePreCoCartesian :: (PreCoCartesian k s) => k (s (s a b) c) (s a (s b c))

-- | free construction of <a>Coassociative</a> for the coproduct
--   <a>Bifunctor</a> <tt>Sum k</tt>
coassociatePreCoCartesian :: (PreCoCartesian k s) => k (s a (s b c)) (s (s a b) c)
class (Monoidal k p i, PreCartesian k p) => Cartesian k p i | k -> p i
class (Comonoidal k s i, PreCoCartesian k s) => CoCartesian k s i | k -> s i
instance (Comonoidal k s i, PreCoCartesian k s) => CoCartesian k s i
instance PreCoCartesian Hask Either
instance (Monoidal k p i, PreCartesian k p) => Cartesian k p i
instance PreCartesian Hask (,)


module Control.Category.Distributive

-- | the canonical factoring morphism
factor :: (PreCartesian hom prod, PreCoCartesian hom sum) => hom (sum (prod a b) (prod a c)) (prod a (sum b c))

-- | A category in which <a>factor</a> is an isomorphism
class (PreCartesian hom prod, PreCoCartesian hom sum) => Distributive hom prod sum
distribute :: (Distributive hom prod sum) => hom (prod a (sum b c)) (sum (prod a b) (prod a c))
instance Distributive Hask (,) Either


module Control.Comonad.Coideal
class (Functor w) => ComonadCoideal w
coidealize :: (ComonadCoideal w) => w a -> w (a, w a)
type Coideal = Ap (,)
coideal :: (a, f a) -> Coideal f a
buildCoideal :: Coalgebra m a -> a -> Coideal m a
newtype Mutual p m n a
Mutual :: m (p a (Mutual p n m a)) -> Mutual p m n a
runMutual :: Mutual p m n a -> m (p a (Mutual p n m a))
type :* m n = Mutual' (,) m n


module Control.Monad.Ideal
class (Functor m) => MonadIdeal m
idealize :: (MonadIdeal m) => m (Either a (m a)) -> m a
type Ideal = Ap Either
ideal :: Either a (f a) -> Ideal f a
destroyIdeal :: Algebra m a -> Ideal m a -> a
newtype Mutual p m n a
Mutual :: m (p a (Mutual p n m a)) -> Mutual p m n a
runMutual :: Mutual p m n a -> m (p a (Mutual p n m a))
type :+ m n = Mutual' Either m n


-- | Described in
--   <a>http://comonad.com/reader/2008/zipping-and-unzipping-functors/</a>
--   and <a>http://comonad.com/reader/2008/cozipping/</a>
module Control.Functor.Zip
unfzip :: (Functor f) => f (a, b) -> (f a, f b)
unbizip :: (PreCartesian r pr, PreCartesian s ps, PreCartesian t pt, Bifunctor p r s t) => t (p (pr a c) (ps b d)) (pt (p a b) (p c d))
counzip :: (Functor f) => Either (f a) (f b) -> f (Either a b)
counbizip :: (PreCoCartesian r sr, PreCoCartesian s ss, PreCoCartesian t st, Bifunctor q r s t) => t (st (q a c) (q b d)) (q (sr a b) (ss c d))

-- | Minimum definition:
--   
--   <ol>
--   <li>fzipWith</li>
--   <li>fzip</li>
--   </ol>
class (Functor f) => Zip f
fzip :: (Zip f) => f a -> f b -> f (a, b)
fzipWith :: (Zip f) => (a -> b -> c) -> f a -> f b -> f c

-- | Minimum definition:
--   
--   <ol>
--   <li>bizipWith</li>
--   <li>bizip</li>
--   </ol>
class (Bifunctor p Hask Hask Hask) => Bizip p
bizip :: (Bizip p) => p a c -> p b d -> p (a, b) (c, d)
bizipWith :: (Bizip p) => (a -> b -> e) -> (c -> d -> f) -> p a c -> p b d -> p e f
class (Functor f) => Cozip f
cozip :: (Cozip f) => f (Either a b) -> Either (f a) (f b)
instance Cozip (Either c)
instance Cozip Maybe
instance Cozip ((,) c)
instance Cozip Identity
instance (Monoid a) => Zip (Either a)
instance (Bizip p) => Zip (Fix p)
instance (Bizip p, Zip f, Zip g) => Bizip (Biff p f g)
instance Bizip (,)
instance (Monoid a) => Zip ((,) a)
instance Zip Maybe
instance Zip []
instance Zip Identity


module Control.Functor.Combinators.Const
newtype Const2 t a b
Const2 :: t -> Const2 t a b
runConst2 :: Const2 t a b -> t
instance (Monoid t) => MonadPlus (Const2 t a)
instance (Monoid t) => Monoid (Const2 t a b)
instance (Monoid t) => PMonad (Const2 t)
instance (Monoid t) => Monad (Const2 t a)
instance (Monoid t) => PApplicative (Const2 t)
instance (Monoid t) => Applicative (Const2 t a)
instance (Monoid t) => PPointed (Const2 t)
instance (Monoid t) => Pointed (Const2 t a)
instance ExpFunctor (Const2 t a)
instance ContraFunctor (Const2 t a)
instance Functor (Const2 t a)
instance (Monoid t) => Bizip (Const2 t)
instance (Monoid t) => Zip (Const2 t a)
instance Symmetric Hask (Const2 t)
instance Braided Hask (Const2 t)
instance Coassociative Hask (Const2 t)
instance Associative Hask (Const2 t)
instance Bifunctor (Const2 t) Hask Hask Hask
instance PFunctor (Const2 t) Hask Hask
instance QFunctor (Const2 t) Hask Hask


-- | See <a>http://wwwtcs.inf.tu-dresden.de/%7Evoigt/mpc08.pdf</a> for the
--   background on rep, abs and improve and their use. NB: the C type in
--   that paper is just the right Kan extension of a monad along itself,
--   also known as the monad generated by a functor:
--   <a>http://www.tac.mta.ca/tac/volumes/10/19/10-19.ps</a>
module Control.Monad.Free
type PFree = PAp Either
type Free f = Fix (PFree f)
runFree :: Free f a -> Either a (f (Free f a))
free :: Either a (f (Free f a)) -> Free f a
class (Functor f, Monad m) => MonadFree f m | m -> f
inFree :: (MonadFree f m) => f (m a) -> m a
class (MonadFree f m) => RunMonadFree f m | m -> f
cataFree :: (RunMonadFree f m) => (c -> a) -> Algebra f a -> m c -> a
instance (MonadFree f m) => MonadFree f (ReaderT e m)
instance (Functor f) => MonadFree f (Free f)
instance (Functor f) => RunMonadFree f (Free f)


-- | The Yoneda lemma can be realized as the Kan extension along Identity
--   However, having this special instance allows us to define Yoneda f as
--   a monad, comonad, etc. based on whatever properties the base functor
--   has, without limiting ourselves to what Ran f f can manage.
--   
--   Performance wise, Yoneda may make your monad more efficient at
--   handling a bunch of fmaps, while CoYoneda may do the same for a
--   comonad assuming you require a greater than linear amount of time to
--   fmap over your structure. You can apply each in either role but the
--   asymptotics will probably not be in your favor.
module Control.Functor.Yoneda
newtype Yoneda f a
Yoneda :: (forall b. (a -> b) -> f b) -> Yoneda f a
runYoneda :: Yoneda f a -> forall b. (a -> b) -> f b
ranToYoneda :: Ran Identity f :~> Yoneda f
yonedaToRan :: Yoneda f :~> Ran Identity f
lowerYoneda :: Yoneda f :~> f

-- | Left Kan Extensions CoYoneda ~ Lan Identity
data CoYoneda f a
CoYoneda :: (b -> a) -> (f b) -> CoYoneda f a
lanToCoYoneda :: Lan Identity f :~> CoYoneda f
coYonedaToLan :: CoYoneda f :~> Lan Identity f
liftCoYoneda :: f :~> CoYoneda f
instance (RunMonadFree f m) => RunMonadFree f (CoYoneda m)
instance (MonadFree f m) => MonadFree f (CoYoneda m)
instance (MonadWriter e m) => MonadWriter e (CoYoneda m)
instance (MonadReader e m) => MonadReader e (CoYoneda m)
instance (MonadState e m) => MonadState e (CoYoneda m)
instance (ComonadReader e m) => ComonadReader e (CoYoneda m)
instance (ComonadContext e m) => ComonadContext e (CoYoneda m)
instance (RunComonadCofree f m) => RunComonadCofree f (CoYoneda m)
instance (ComonadCofree f m) => ComonadCofree f (CoYoneda m)
instance ComonadTrans CoYoneda
instance MonadTrans CoYoneda
instance (Comonad w) => Comonad (CoYoneda w)
instance (Copointed w) => Copointed (CoYoneda w)
instance HCopointed CoYoneda
instance HComonad CoYoneda
instance HMonad CoYoneda
instance HPointed CoYoneda
instance HFunctor CoYoneda
instance (Monad m) => Monad (CoYoneda m)
instance (Applicative f) => Applicative (CoYoneda f)
instance (Pointed f) => Pointed (CoYoneda f)
instance Functor (CoYoneda f)
instance (ComonadReader e m) => ComonadReader e (Yoneda m)
instance (ComonadContext e m) => ComonadContext e (Yoneda m)
instance (RunComonadCofree f m) => RunComonadCofree f (Yoneda m)
instance (ComonadCofree f m) => ComonadCofree f (Yoneda m)
instance (RunMonadFree f m) => RunMonadFree f (Yoneda m)
instance (MonadFree f m) => MonadFree f (Yoneda m)
instance (MonadWriter e m) => MonadWriter e (Yoneda m)
instance (MonadReader e m) => MonadReader e (Yoneda m)
instance (MonadState e m) => MonadState e (Yoneda m)
instance (Comonad f) => Comonad (Yoneda f)
instance (Copointed f) => Copointed (Yoneda f)
instance HComonad Yoneda
instance HMonad Yoneda
instance HCopointed Yoneda
instance ComonadTrans Yoneda
instance MonadTrans Yoneda
instance HPointed Yoneda
instance HFunctor Yoneda
instance (Monad f) => Monad (Yoneda f)
instance (Applicative f) => Applicative (Yoneda f)
instance (Pointed f) => Pointed (Yoneda f)
instance Functor (Yoneda f)


module Control.Monad.Codensity
data Codensity m a
liftCodensity :: (Monad m) => m :~> Codensity m
lowerCodensity :: (Monad m) => Codensity m :~> m
codensityToRan :: Codensity m :~> Ran m m
ranToCodensity :: Ran m m :~> Codensity m
toCodensity :: (Functor s) => (forall a. s (k a) -> k a) -> s :~> Codensity k
fromCodensity :: (s :~> Codensity k) -> s (k a) -> k a
codensityToAdjunction :: (Adjunction f g) => Codensity g a -> g (f a)
adjunctionToCodensity :: (Adjunction f g) => g (f a) -> Codensity g a
improveFree :: (Functor f) => (forall m. (MonadFree f m) => m a) -> Free f a
instance (RunMonadFree f m) => RunMonadFree f (Codensity m)
instance (MonadFree f m) => MonadFree f (Codensity m)
instance (MonadState s m) => MonadState s (Codensity m)
instance (MonadIO m) => MonadIO (Codensity m)
instance (MonadReader r m) => MonadReader r (Codensity m)
instance Monad (Codensity f)
instance Pointed (Codensity f)
instance Functor (Codensity k)


-- | Traditional operators, shown here to show how to roll your own
module Control.Morphism.Futu

-- | Generalized from <tt>futu :: Functor f =&gt; GCoalgebra f (Free f) a
--   -&gt; a -&gt; FixF f</tt>
futu :: (RunMonadFree f m) => GCoalgebra f m a -> a -> FixF f
g_futu :: (Functor f, RunMonadFree h m) => Dist h f -> GCoalgebra f m a -> a -> FixF f

-- | A futumorphic postpromorphism
postpro_futu :: (RunMonadFree f m) => GCoalgebra f m a -> (f :~> f) -> a -> FixF f

-- | A generalized-futumorphic postpromorphism
g_postpro_futu :: (Functor f, RunMonadFree h m) => Dist h f -> GCoalgebra f m a -> (f :~> f) -> a -> FixF f

-- | Turn a distributive law for a functor into a distributive law for the
--   free monad of that functor. This has been generalized to support
--   generating distributive laws for a number of related free-monad-like
--   constructions such as the Codensity monad of the free monad of a
--   functor.
distFutu :: (Functor f, RunMonadFree h m) => Dist h f -> Dist m f


-- | Chronomorphisms from
--   <a>http://comonad.com/reader/2008/time-for-chronomorphisms/</a>
module Control.Morphism.Chrono
chrono :: (RunMonadFree f m, RunComonadCofree g w) => GAlgebra g w b -> (f :~> g) -> GCoalgebra f m a -> a -> b
g_chrono :: (Functor f, Functor g, RunComonadCofree h w, RunMonadFree j m) => Dist g h -> Dist j f -> GAlgebra g w b -> (f :~> g) -> GCoalgebra f m a -> a -> b


-- | Martin Erwig's synchromorphisms.
module Control.Morphism.Synchro

-- | <tt>synchro d' f d g1 g2 d''</tt> is Martin Erwig's
--   <tt>d,d''-synchromorphism to d'</tt>. Mostly useful for graph
--   algorithms.
synchro :: (QFunctor h Hask Hask) => Bialgebra m n c -> (h x (Either a c) -> m c) -> Trialgebra (f x) (g x) (h x) a -> ((h x a, b) -> k x b) -> ((h x a, j x b) -> h x (Either a (g x a, b))) -> Bialgebra (k x) (j x) b -> (g x a, b) -> c


-- | NB: Some rewrite rules are disabled pending resolution of:
--   <a>http://hackage.haskell.org/trac/ghc/ticket/2291</a>
module Control.Category.Cartesian.Closed

-- | A <a>CCC</a> has full-fledged monoidal finite products and
--   exponentials
class (Monoidal hom prod i, Cartesian hom prod i) => CCC hom prod exp i | hom -> prod exp i
apply :: (CCC hom prod exp i) => hom (prod (exp a b) a) b
curry :: (CCC hom prod exp i) => hom (prod a b) c -> hom a (exp b c)
uncurry :: (CCC hom prod exp i) => hom a (exp b c) -> hom (prod a b) c
unitCCC :: (CCC hom prod exp i) => hom a (exp b (prod b a))
counitCCC :: (CCC hom prod exp i) => hom (prod b (exp b a)) a

-- | A Co-CCC has full-fledged comonoidal finite coproducts and
--   coexponentials
class (Comonoidal hom sum i, CoCartesian hom sum i) => CoCCC hom sum coexp i | hom -> sum coexp i
coapply :: (CoCCC hom sum coexp i) => hom b (sum (coexp hom a b) a)
cocurry :: (CoCCC hom sum coexp i) => hom c (sum a b) -> hom (coexp hom b c) a
uncocurry :: (CoCCC hom sum coexp i) => hom (coexp hom b c) a -> hom c (sum a b)
unitCoCCC :: (CoCCC hom sum coexp i) => hom a (sum b (coexp hom b a))
counitCoCCC :: (CoCCC hom sum coexp i) => hom (coexp hom b (sum b a)) a


module Control.Functor.Combinators.Flip
newtype Flip p a b
Flip :: p b a -> Flip p a b
runFlip :: Flip p a b -> p b a
liftFlip :: (p a b -> p c d) -> Flip p b a -> Flip p d c
instance (Associative Hask p, Comonoidal Hask p i) => Comonoidal Hask (Flip p) i
instance (Coassociative Hask p, Monoidal Hask p i) => Monoidal Hask (Flip p) i
instance (Coassociative Hask p) => Associative Hask (Flip p)
instance (Associative Hask p) => Coassociative Hask (Flip p)
instance (HasIdentity Hask p i) => HasIdentity Hask (Flip p) i
instance (Bifunctor p Hask Hask Hask) => Functor (Flip p a)
instance (Symmetric Hask p) => Symmetric Hask (Flip p)
instance (Braided Hask p) => Braided Hask (Flip p)
instance (Bifunctor p Hask Hask Hask) => Bifunctor (Flip p) Hask Hask Hask
instance (QFunctor p Hask Hask) => PFunctor (Flip p) Hask Hask
instance (PFunctor p Hask Hask) => QFunctor (Flip p) Hask Hask
