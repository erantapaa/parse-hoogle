-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | a cyclic doubly linked list
--   
--   This package implements a cyclic doubly linked list and defines
--   various instances for it.
@package data-cycle
@version 0.1.2

module Data.Cycle

-- | A cyclic doubly linked list.
--   
--   To create a new Cycle, use <a>fromList</a>, <a>fromFoldable</a> or any
--   of the insertion functions from <a>Unfoldable</a>. Elements are
--   inserted in front of the current position.
--   
--   To get the length of the list, use <a>size</a>. To extract all cycle
--   elements, use <a>toList</a>. You can also create an infinite list with
--   <a>cycleToInfiniteList</a>.
--   
--   <a>take</a>, <a>drop</a> and <a>splitAt</a> also accept negative
--   values for working backwards (see <a>takeLR</a> and <a>dropLR</a> for
--   details).
--   
--   In general, any function <tt>f</tt> working on <tt>[a]</tt> can be
--   adapted for <tt>Cycle a</tt> by writing <tt>fromList . f .
--   toList</tt>.
--   
--   The <a>Monad</a>, <a>Functor</a>, <a>Applicative</a>,
--   <a>Alternative</a>, <a>Monoid</a> and <a>Foldable</a> instances work
--   like the default instances for lists.
data Cycle a

-- | Move focus to the element on the left of the current position.
goLeft :: Cycle a -> Cycle a

-- | Move focus to the element on the right of the current position.
--   
--   <pre>
--   goLeft . goRight == id
--   </pre>
goRight :: Cycle a -> Cycle a

-- | Move <tt>abs n</tt> steps to the left (<tt>n &lt; 0</tt>) or right
--   (<tt>n &gt; 0</tt>) or don't move at all (<tt>n == 0</tt>).
goLR :: Int -> Cycle a -> Cycle a

-- | Get the value at the current position. <a>error</a> if <tt>null
--   c</tt>.
getValue :: Cycle a -> a

-- | Get value on the left. <a>error</a> if <tt>null c</tt>.
leftValue :: Cycle a -> a

-- | Get value on the right. <a>error</a> if <tt>null c</tt>.
rightValue :: Cycle a -> a

-- | Get nth value to the left (<tt>n &lt; 0</tt>) or right (<tt>n &gt;
--   0</tt>) or the current value (<tt>n == 0</tt>). <a>error</a> if
--   <tt>null c</tt>.
--   
--   <pre>
--   nthValue = flip (!)
--   </pre>
nthValue :: Int -> Cycle a -> a

-- | Take <tt>abs n</tt> values starting at the current one and moving to
--   the right (<tt>n &gt; 0</tt>) or left (<tt>n &lt; 0</tt>). <tt>n</tt>
--   can be arbitrary big.
--   
--   <pre>
--   take n = fromList . takeLR n
--   </pre>
takeLR :: Int -> Cycle a -> [a]

-- | Drop <tt>abs n</tt> values starting at the current one and moving to
--   the right (<tt>n &gt; 0</tt>) or left (<tt>n &lt; 0</tt>). <tt>n</tt>
--   can be arbitrary big.
--   
--   <pre>
--   drop n = fromList . dropLR n
--   </pre>
dropLR :: Int -> Cycle a -> [a]

-- | Convert to an infinite list starting with the current value and moving
--   to the right.
cycleToInfiniteList :: Cycle a -> [a]

-- | <pre>
--   zipCycle = zipCycleWith (,)
--   </pre>
zipCycle :: Cycle a -> Cycle b -> Cycle (a, b)

-- | Combine two cycles by applying a binary function to all element pairs.
--   Like <a>zipWith</a>.
zipCycleWith :: (a -> b -> c) -> Cycle a -> Cycle b -> Cycle c
instance Eq a => Eq (Cycle a)
instance Indexed (Cycle a) Int a
instance Sequence (Cycle a) a
instance Monoid (Cycle a)
instance Show a => Show (Cycle a)
instance Collection (Cycle a) a
instance Foldable (Cycle a) a
instance Unfoldable (Cycle a) a
instance Monad Cycle
instance Alternative Cycle
instance Applicative Cycle
instance Functor Cycle
instance Functor DList
