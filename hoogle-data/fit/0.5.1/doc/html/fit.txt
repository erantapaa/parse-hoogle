-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | FIT file decoder
--   
@package fit
@version 0.5.1


-- | FIT files can contain values encoded with both little-endian and
--   big-endian orderings, and this can vary throughout the file. This
--   module provides some helper types for using parsers with the correct
--   endian-ness during the parse. See the <a>Fit.Internal.Numbers</a> and
--   <a>Fit.Internal.FitParser</a> modules for example use.
module Fit.Internal.Architecture
data Arch
ArchLittle :: Arch
ArchBig :: Arch

-- | Tag a value for use in a little- or big-endian context (with
--   <a>ArchLittle</a> and <a>ArchBig</a>, respectively)
newtype WithArch (a :: Arch) b
WithArch :: b -> WithArch b
unArch :: WithArch b -> b

-- | Convenience type for values to use in a little-endian context
type LittleEndian a = WithArch ArchLittle a

-- | Convenience type for values to use in a big-endian context
type BigEndian a = WithArch ArchBig a

-- | Alias for <a>pure</a>
withLE :: a -> LittleEndian a

-- | Alias for <a>pure</a>
withBE :: a -> BigEndian a
instance Show Arch
instance Eq Arch
instance Applicative (WithArch a)
instance Functor (WithArch a)


-- | Little-endian and big-endian parsers for signed and unsigned integers,
--   and for single-precision and double-precision floating point numbers.
--   
--   The parsers are tagged for endianness using the tools in
--   <a>Fit.Internal.Architecture</a>.
module Fit.Internal.Numbers
int16le :: LittleEndian (Parser Int16)
int32le :: LittleEndian (Parser Int32)
int64le :: LittleEndian (Parser Int64)
word16le :: LittleEndian (Parser Word16)
word32le :: LittleEndian (Parser Word32)
word64le :: LittleEndian (Parser Word64)
float32le :: LittleEndian (Parser Float)
float64le :: LittleEndian (Parser Double)
int16be :: BigEndian (Parser Int16)
int32be :: BigEndian (Parser Int32)
int64be :: BigEndian (Parser Int64)
word16be :: BigEndian (Parser Word16)
word32be :: BigEndian (Parser Word32)
word64be :: BigEndian (Parser Word64)
float32be :: BigEndian (Parser Float)
float64be :: BigEndian (Parser Double)

-- | Parse <tt>n</tt> bytes and interpret them as a little-endian integer.
--   The caller must ensure that the returned type is the correct size for
--   the number of bytes parsed.
nByteIntLe :: (Integral a, Bits a) => Int -> Parser a

-- | Parse <tt>n</tt> bytes and interpret them as a big-endian integer. The
--   caller must ensure that the returned type is the correct size for the
--   number of bytes parsed.
nByteIntBe :: (Integral a, Bits a) => Int -> Parser a


module Fit.Internal.FitFile

-- | A FIT file consists of a header and a collection of messages.
data Fit
Fit :: FitHeader -> [Message] -> Fit
fHeader :: Fit -> FitHeader
fMessages :: Fit -> [Message]

-- | The FIT file header
data FitHeader
FH :: !Word8 -> !Word8 -> !Word16 -> !Word32 -> ByteString -> !(Maybe Word16) -> FitHeader

-- | Size of the header in bytes. Will always be 12 or 14, based on
--   presence of the CRC
fhSize :: FitHeader -> !Word8

-- | Protocol version number
fhProtocolVersion :: FitHeader -> !Word8

-- | Profile version number
fhProfileVersion :: FitHeader -> !Word16

-- | Combined length of the FIT messages, in bytes
fhDataSize :: FitHeader -> !Word32

-- | File tag, should always be ".FIT"
fhDataType :: FitHeader -> ByteString

-- | Optional checksum for header contents
fhCrc :: FitHeader -> !(Maybe Word16)

-- | There are two kinds of FIT messages:
--   
--   <ul>
--   <li><b>Definition messages</b> set the structure for messages of a
--   particular <i>local message type</i></li>
--   <li><b>Data messages</b> contain the actual information, according to
--   the structure given by a definition message.</li>
--   </ul>
data Message
DefM :: MessageDefinition -> Message
DataM :: !LocalMessageType -> !Int -> [Field] -> Message
msgLmt :: Message -> LocalMessageType

-- | A <a>MessageDefinition</a> for a local message type (LMT) determines
--   how future data messages with that LMT are decoded. LMTs can be
--   re-used: a data message with LMT <tt>n</tt> will use the <i>most
--   recent</i> message definition for LMT <tt>n</tt>.
data MessageDefinition
MessageDef :: !LocalMessageType -> !Int -> !Arch -> [FieldDef] -> MessageDefinition

-- | The local message type being defined
defLocalType :: MessageDefinition -> !LocalMessageType

-- | The <i>global</i> message type this LMT will refer to. Must be a valid
--   <tt>mesg_num</tt> value from the FIT profile
defGlobalType :: MessageDefinition -> !Int

-- | The <i>architecture</i> this messages with this LMT will use for
--   multi-byte values (little- or big-endian)
defArch :: MessageDefinition -> !Arch

-- | Definitions for the fields messages with this LMT will contain
defFields :: MessageDefinition -> [FieldDef]

-- | Defines the structure for a single field in a message
data FieldDef
FieldDef :: !Int -> !Int -> !BaseType -> FieldDef

-- | The <i>field number</i>. The interpretation of the field number
--   depends on the global message type and is found in the FIT profile
fdNum :: FieldDef -> !Int

-- | The size, in bytes, of the field's contents. This will be a multiple
--   of the base type size. In a singleton field this size will be the same
--   as the base type size. In an array field it will be some multiple of
--   the base type size.
fdSize :: FieldDef -> !Int

-- | The FIT base type of values in the field
fdBaseType :: FieldDef -> !BaseType

-- | A single field in a data message, containing the field number and the
--   value(s)
data Field
SingletonField :: !Int -> Value -> Field
ArrayField :: !Int -> Array -> Field

-- | Singleton values. There is a Value constructor for each BaseType
--   constructor. The wrapped value in these constructors corresponds to
--   the specific format used in the FIT file, for example an <tt>enum</tt>
--   in FIT is stored as an 8-bit unsigned int (ie a Word8). The primary
--   exception to this is using <a>Text</a> for string values.
data Value
EnumValue :: !Word8 -> Value
SInt8Value :: !Int8 -> Value
UInt8Value :: !Word8 -> Value
SInt16Value :: !Int16 -> Value
UInt16Value :: !Word16 -> Value
SInt32Value :: !Int32 -> Value
UInt32Value :: !Word32 -> Value

-- | A <tt>string</tt> in FIT is a null-terminated arrays of UTF-8 code
--   units, but <a>Text</a> is used here instead
StringValue :: Text -> Value
Float32Value :: !Float -> Value
Float64Value :: !Double -> Value
UInt8ZValue :: !Word8 -> Value
UInt16ZValue :: !Word16 -> Value
UInt32ZValue :: !Word32 -> Value
ByteValue :: !Word8 -> Value

-- | Array values use similar constructors to singleton values. However,
--   there is no constructor for arrays of strings, which seem to be unused
--   in FIT.
data Array
EnumArray :: (Seq Word8) -> Array
SInt8Array :: (Seq Int8) -> Array
UInt8Array :: (Seq Word8) -> Array
SInt16Array :: (Seq Int16) -> Array
UInt16Array :: (Seq Word16) -> Array
SInt32Array :: (Seq Int32) -> Array
UInt32Array :: (Seq Word32) -> Array
Float32Array :: (Seq Float) -> Array
Float64Array :: (Seq Double) -> Array
UInt8ZArray :: (Seq Word8) -> Array
UInt16ZArray :: (Seq Word16) -> Array
UInt32ZArray :: (Seq Word32) -> Array
ByteArray :: (Seq Word8) -> Array

-- | Each message has a header that primarily determines whether the
--   message is a definition or data message. If the message uses a
--   <i>compressed timestamp header</i>, the header also contains the
--   compressed time offset.
data MessageHeader
DefHeader :: !LocalMessageType -> MessageHeader
DataHeader :: !LocalMessageType -> MessageHeader
CTDataHeader :: !LocalMessageType -> !TimeOffset -> MessageHeader

-- | A local message type is a 4 bit unsigned integer
newtype LocalMessageType
LMT :: Int8 -> LocalMessageType
unLmt :: LocalMessageType -> Int8

-- | Only the lower 4 bits of the integer are used to construct a
--   <a>LocalMessageType</a>
mkLocalMessageType :: (Integral a, Bits a) => a -> LocalMessageType

-- | Unwrap a <a>LocalMessageType</a>. The resulting integer will be
--   between 0 and 15
unLocalMessageType :: Integral a => LocalMessageType -> a

-- | A time offset is 5 bits
newtype TimeOffset
TO :: Word8 -> TimeOffset
unTo :: TimeOffset -> Word8

-- | Only the lower 5 bits of the number are used
mkTimeOffset :: (Integral a, Bits a) => a -> TimeOffset
newtype Timestamp
Timestamp :: Word32 -> Timestamp
unTimestamp :: Timestamp -> Word32

-- | The different types that FIT uses for field values
data BaseType
FitEnum :: BaseType
FitSInt8 :: BaseType
FitUInt8 :: BaseType
FitSInt16 :: BaseType
FitUInt16 :: BaseType
FitSInt32 :: BaseType
FitUInt32 :: BaseType
FitString :: BaseType
FitFloat32 :: BaseType
FitFloat64 :: BaseType
FitUInt8Z :: BaseType
FitUInt16Z :: BaseType
FitUInt32Z :: BaseType
FitByte :: BaseType

-- | Get the size in bytes for a single value of the given base type
btSize :: BaseType -> Int
instance Show FitHeader
instance Show Value
instance Show Array
instance Show Field
instance Show LocalMessageType
instance Eq LocalMessageType
instance Show TimeOffset
instance Show MessageHeader
instance Show Timestamp
instance Eq Timestamp
instance Show BaseType
instance Eq BaseType
instance Show FieldDef
instance Eq FieldDef
instance Show MessageDefinition
instance Eq MessageDefinition
instance Show Message
instance Show Fit


module Fit.Internal.FitParser
type FitParser a = StateT FpState Parser a

-- | Turn a <a>FitParser</a> into a plain attoparsec <a>Parser</a>. This
--   doesn't require any configuration as the initial state for a FIT parse
--   is always the same.
runFitParser :: FitParser a -> Parser a

-- | The necessary state for parsing FIT files
data FpState
FpState :: !Arch -> Definitions -> !(Maybe Timestamp) -> FpState

-- | The active endian-ness
_fpArch :: FpState -> !Arch

-- | The set of active message definitions
_fpMessageDefs :: FpState -> Definitions

-- | The most recently stored timestamp
_fpLastTimestamp :: FpState -> !(Maybe Timestamp)

-- | The definitions are stored as a map on the local message type number.
--   When a definition is parsed with a previously-used local message type,
--   the previous definition is overwritten.
newtype Definitions
Defs :: IntMap MessageDefinition -> Definitions
unDefs :: Definitions -> IntMap MessageDefinition

-- | Register a <a>MessageDefinition</a> with the parser, so it can decode
--   subsequent data messages using the definition
addMessageDef :: MessageDefinition -> FitParser ()

-- | Look up the <a>MessageDefinition</a> for the given message type. It is
--   an error to look up a message type that has no registered definition,
--   since it is impossible to decode a data message with no definition
lookupMessageDef :: LocalMessageType -> FitParser MessageDefinition

-- | Little-endian interpretation is used by default by <a>FitParser</a>.
--   Use this function to set the endianness to use for the scope of a
--   particular action. After the action is finished the previous
--   endianness is restored.
withArchitecture :: Arch -> FitParser a -> FitParser a

-- | Store the given <a>Timestamp</a> as the most recent. Is used to store
--   timestamps from non-compressed timestamp messages. For
--   compressed-timestamp messages use <a>updateTimestamp</a> instead.
storeTimestamp :: Timestamp -> FitParser ()

-- | Use the given <a>TimeOffset</a> and the previous <a>Timestamp</a> to
--   compute a new Timestamp. The new <a>Timestamp</a> is stored as most
--   recent and is returned.
--   
--   This function fails if there is no previously-stored <a>Timestamp</a>.
--   This condition should never come up when parsing a valid FIT file.
updateTimestamp :: TimeOffset -> FitParser Timestamp
word8 :: FitParser Word8
int8 :: FitParser Int8

-- | Parse a Word16 using the active endianness
archWord16 :: FitParser Word16

-- | Parse a Word32 using the active endianness
archWord32 :: FitParser Word32

-- | Parse a Word64 using the active endianness
archWord64 :: FitParser Word64

-- | Parse an Int16 using the active endianness
archInt16 :: FitParser Int16

-- | Parse an Int32 using the active endiannessa
archInt32 :: FitParser Int32

-- | Parse an Int64 using the active endianness
archInt64 :: FitParser Int64

-- | Parse a Float using the active endianness
archFloat32 :: FitParser Float

-- | Parse a Double using the active endianness
archFloat64 :: FitParser Double
instance Functor Identity


module Fit.Internal.Parse

-- | Parse a strict <a>ByteString</a> containing the FIT data into a
--   <a>Fit</a> value
readFitRaw :: ByteString -> Either String Fit

-- | An Attoparsec parser for <a>Fit</a> values
parseFit :: Parser Fit
parseHeader :: FitParser FitHeader
parseMessages :: FitParser [Message]
parseMessage :: FitParser Message
parseMessageDef :: LocalMessageType -> FitParser MessageDefinition
parseFieldDef :: FitParser FieldDef
parseDataMessage :: MessageDefinition -> FitParser Message
parseField :: FieldDef -> FitParser Field
parseValue :: BaseType -> FitParser Value

-- | This function will fail if the <a>BaseType</a> is <a>FitString</a>.
--   This implementation currently doesn't support arrays of strings, but
--   treats char arrays as always being a single string.
parseArray :: Int -> BaseType -> FitParser Array

-- | Run a <a>FitParser</a> <tt>n</tt> times to parse a <a>Seq</a> of
--   values
parseSeq :: Int -> FitParser a -> FitParser (Seq a)

-- | Parse a null-terminated UTF-8 string.
parseString :: Parser Text

-- | Parse a compressed-timestamp message, using the <a>TimeOffset</a> from
--   the compressed-timestamp message header.
parseCTDataMessage :: TimeOffset -> MessageDefinition -> FitParser Message

-- | Transform a FIT message header byte into a <a>MessageHeader</a>
mkHeader :: Word8 -> MessageHeader


-- | The Messages API abtracts over the structure of a FIT file slightly
--   and presents the FIT file as just the sequence of data messages in the
--   file. The Messages API also abstracts over the various FIT base types
--   (for example, signed/unsigned integers of different sizes) to give a
--   simpler set of types to work with.
--   
--   If you need to know about the specifics of the FIT file structure, use
--   the API in <a>Fit.Internal.FitFile</a> instead. However, for pulling
--   information out of a FIT file this API is much more convenient.
module Fit.Messages

-- | Parse a strict <a>ByteString</a> containing the FIT data into its
--   <a>Messages</a>
readMessages :: ByteString -> Either String Messages

-- | Parse the given FIT file into its <a>Messages</a>
readFileMessages :: FilePath -> IO (Either String Messages)

-- | An Attoparsec parser for <a>Messages</a>
parseMessages :: Parser Messages

-- | The collection of data messages from the FIT file.
newtype Messages
Messages :: Seq Message -> Messages
_messages :: Messages -> Seq Message

-- | A FIT data message
data Message
Message :: !Int -> IntMap Field -> Message

-- | The global message number, as found in the FIT profile
_mNumber :: Message -> !Int

-- | The fields in the message, mapped from field number to <a>Field</a>
_mFields :: Message -> IntMap Field

-- | A single field in a FIT data message
data Field
Field :: !Int -> Value -> Field

-- | The field number, as found in the FIT profile
_fNumber :: Field -> !Int
_fValue :: Field -> Value

-- | FIT values can either contain a single piece of data or an array. FIT
--   arrays are homogenous
data Value
Singleton :: SingletonValue -> Value
Array :: ArrayValue -> Value

-- | A singleton value. In the Messages API we abstract over the specific
--   FIT base type of the field. For example, the FIT types uint8, sint8,
--   uint16, etc. are all presented as an <a>IntValue</a>. FIT strings (ie.
--   character arrays) are presented as singleton <a>TextValue</a>s. If you
--   need to know the specific base type of a field you can use the API in
--   <a>Fit.Internal.FitFile</a>.
data SingletonValue
IntValue :: !Int -> SingletonValue
RealValue :: !Double -> SingletonValue
ByteValue :: !Word8 -> SingletonValue
TextValue :: Text -> SingletonValue

-- | Array values. Like singleton values these ignore the specific FIT base
--   type to present a simpler interface. Byte arrays are presented as
--   strict <a>ByteString</a>s. There are no character arrays, since the
--   singleton <a>TextValue</a> handles that case.
data ArrayValue
IntArray :: (Seq Int) -> ArrayValue
RealArray :: (Seq Double) -> ArrayValue
ByteArray :: ByteString -> ArrayValue
instance Show SingletonValue
instance Show ArrayValue
instance Show Value
instance Show Field
instance Show Message
instance Show Messages


-- | Some basic lenses for the Messages API. These are compatible with both
--   lens and lens-family. This package doesn't provide any lens
--   combinators like <tt>^.</tt> or <tt>^..</tt>, so you'll need to use
--   ones from a lens package.
--   
--   For example, the following code gets the values of the <tt>speed</tt>
--   fields from all of the <tt>record</tt> messages in the file:
--   
--   <pre>
--   Right fit &lt;- readFileMessages "file.fit"
--   let speeds = fit ^.. message 20 . field 6 . int
--   </pre>
module Fit.Messages.Lens

-- | Traverse all the messages in a <a>Messages</a>
--   
--   <pre>
--   messages :: Traversal' Messages Message
--   </pre>
messages :: Applicative f => (Message -> f Message) -> Messages -> f Messages

-- | A Fold over the messages with the given message number
--   
--   <pre>
--   message :: Int -&gt; Fold Messages Message
--   </pre>
message :: (Contravariant f, Applicative f) => Int -> (Message -> f Message) -> Messages -> f Messages

-- | Lens on the message number from a <a>Message</a>
--   
--   <pre>
--   messageNumber :: Lens' Message Int
--   </pre>
messageNumber :: Functor f => (Int -> f Int) -> Message -> f Message

-- | Traverse all the fields in a <a>Message</a>
--   
--   <pre>
--   fields :: Traversal' Message Field
--   </pre>
fields :: Applicative f => (Field -> f Field) -> Message -> f Message

-- | A Fold over the fields in a <a>Message</a> with the given field number
--   
--   <pre>
--   field :: Int -&gt; Fold Message Field
--   </pre>
field :: (Contravariant f, Applicative f) => Int -> (Field -> f Field) -> Message -> f Message

-- | Lens on the field number from a <a>Field</a>
--   
--   <pre>
--   fieldNumber :: Lens Field Int
--   </pre>
fieldNumber :: Functor f => (Int -> f Int) -> Field -> f Field

-- | Lens on the <a>Value</a> from a <a>Field</a>
--   
--   <pre>
--   fieldValue :: Lens Field Value
--   </pre>
fieldValue :: Functor f => (Value -> f Value) -> Field -> f Field

-- | Traverse the <a>Singleton</a> and <a>IntValue</a> constructors for a
--   field value
--   
--   <pre>
--   int :: Traversal' Field Int
--   </pre>
int :: Applicative f => (Int -> f Int) -> Field -> f Field

-- | Traverse the <a>Singleton</a> and <a>RealValue</a> constructors for a
--   field value
--   
--   <pre>
--   real :: Traversal' Field Double
--   </pre>
real :: Applicative f => (Double -> f Double) -> Field -> f Field

-- | Traverse the <a>Singleton</a> and <a>TextValue</a> constructors for a
--   field value
--   
--   <pre>
--   text :: Traversal' Field Text
--   </pre>
text :: Applicative f => (Text -> f Text) -> Field -> f Field

-- | Traverse the <a>Singleton</a> and <a>ByteValue</a> constructors for a
--   field value
--   
--   <pre>
--   byte :: Traversal' Field Word8
--   </pre>
byte :: Applicative f => (Word8 -> f Word8) -> Field -> f Field

-- | Traverse the <a>Array</a> and <a>IntArray</a> constructors for a field
--   value
--   
--   <pre>
--   ints :: Traversal' Field (Seq Int)
--   </pre>
ints :: Applicative f => (Seq Int -> f (Seq Int)) -> Field -> f Field

-- | Traverse the <a>Array</a> and <a>RealArray</a> constructors for a
--   field value
--   
--   <pre>
--   reals :: Traversal' Field (Seq Double)
--   </pre>
reals :: Applicative f => (Seq Double -> f (Seq Double)) -> Field -> f Field

-- | Travese the <a>Array</a> and <a>ByteArray</a> constructors for a field
--   value
--   
--   <pre>
--   bytestring :: Traversal' Field ByteString
--   </pre>
bytestring :: Applicative f => (ByteString -> f ByteString) -> Field -> f Field


module Fit

-- | Parse a strict <a>ByteString</a> containing the FIT data into its
--   <a>Messages</a>
readMessages :: ByteString -> Either String Messages

-- | Parse the given FIT file into its <a>Messages</a>
readFileMessages :: FilePath -> IO (Either String Messages)

-- | An Attoparsec parser for <a>Messages</a>
parseMessages :: Parser Messages

-- | The collection of data messages from the FIT file.
newtype Messages
Messages :: Seq Message -> Messages
_messages :: Messages -> Seq Message

-- | A FIT data message
data Message
Message :: !Int -> IntMap Field -> Message

-- | The global message number, as found in the FIT profile
_mNumber :: Message -> !Int

-- | The fields in the message, mapped from field number to <a>Field</a>
_mFields :: Message -> IntMap Field

-- | A single field in a FIT data message
data Field
Field :: !Int -> Value -> Field

-- | The field number, as found in the FIT profile
_fNumber :: Field -> !Int
_fValue :: Field -> Value

-- | FIT values can either contain a single piece of data or an array. FIT
--   arrays are homogenous
data Value
Singleton :: SingletonValue -> Value
Array :: ArrayValue -> Value

-- | A singleton value. In the Messages API we abstract over the specific
--   FIT base type of the field. For example, the FIT types uint8, sint8,
--   uint16, etc. are all presented as an <a>IntValue</a>. FIT strings (ie.
--   character arrays) are presented as singleton <a>TextValue</a>s. If you
--   need to know the specific base type of a field you can use the API in
--   <a>Fit.Internal.FitFile</a>.
data SingletonValue
IntValue :: !Int -> SingletonValue
RealValue :: !Double -> SingletonValue
ByteValue :: !Word8 -> SingletonValue
TextValue :: Text -> SingletonValue

-- | Array values. Like singleton values these ignore the specific FIT base
--   type to present a simpler interface. Byte arrays are presented as
--   strict <a>ByteString</a>s. There are no character arrays, since the
--   singleton <a>TextValue</a> handles that case.
data ArrayValue
IntArray :: (Seq Int) -> ArrayValue
RealArray :: (Seq Double) -> ArrayValue
ByteArray :: ByteString -> ArrayValue

-- | Traverse all the messages in a <a>Messages</a>
--   
--   <pre>
--   messages :: Traversal' Messages Message
--   </pre>
messages :: Applicative f => (Message -> f Message) -> Messages -> f Messages

-- | A Fold over the messages with the given message number
--   
--   <pre>
--   message :: Int -&gt; Fold Messages Message
--   </pre>
message :: (Contravariant f, Applicative f) => Int -> (Message -> f Message) -> Messages -> f Messages

-- | Lens on the message number from a <a>Message</a>
--   
--   <pre>
--   messageNumber :: Lens' Message Int
--   </pre>
messageNumber :: Functor f => (Int -> f Int) -> Message -> f Message

-- | Traverse all the fields in a <a>Message</a>
--   
--   <pre>
--   fields :: Traversal' Message Field
--   </pre>
fields :: Applicative f => (Field -> f Field) -> Message -> f Message

-- | A Fold over the fields in a <a>Message</a> with the given field number
--   
--   <pre>
--   field :: Int -&gt; Fold Message Field
--   </pre>
field :: (Contravariant f, Applicative f) => Int -> (Field -> f Field) -> Message -> f Message

-- | Lens on the field number from a <a>Field</a>
--   
--   <pre>
--   fieldNumber :: Lens Field Int
--   </pre>
fieldNumber :: Functor f => (Int -> f Int) -> Field -> f Field

-- | Lens on the <a>Value</a> from a <a>Field</a>
--   
--   <pre>
--   fieldValue :: Lens Field Value
--   </pre>
fieldValue :: Functor f => (Value -> f Value) -> Field -> f Field

-- | Traverse the <a>Singleton</a> and <a>IntValue</a> constructors for a
--   field value
--   
--   <pre>
--   int :: Traversal' Field Int
--   </pre>
int :: Applicative f => (Int -> f Int) -> Field -> f Field

-- | Traverse the <a>Singleton</a> and <a>RealValue</a> constructors for a
--   field value
--   
--   <pre>
--   real :: Traversal' Field Double
--   </pre>
real :: Applicative f => (Double -> f Double) -> Field -> f Field

-- | Traverse the <a>Singleton</a> and <a>TextValue</a> constructors for a
--   field value
--   
--   <pre>
--   text :: Traversal' Field Text
--   </pre>
text :: Applicative f => (Text -> f Text) -> Field -> f Field

-- | Traverse the <a>Singleton</a> and <a>ByteValue</a> constructors for a
--   field value
--   
--   <pre>
--   byte :: Traversal' Field Word8
--   </pre>
byte :: Applicative f => (Word8 -> f Word8) -> Field -> f Field

-- | Traverse the <a>Array</a> and <a>IntArray</a> constructors for a field
--   value
--   
--   <pre>
--   ints :: Traversal' Field (Seq Int)
--   </pre>
ints :: Applicative f => (Seq Int -> f (Seq Int)) -> Field -> f Field

-- | Traverse the <a>Array</a> and <a>RealArray</a> constructors for a
--   field value
--   
--   <pre>
--   reals :: Traversal' Field (Seq Double)
--   </pre>
reals :: Applicative f => (Seq Double -> f (Seq Double)) -> Field -> f Field

-- | Travese the <a>Array</a> and <a>ByteArray</a> constructors for a field
--   value
--   
--   <pre>
--   bytestring :: Traversal' Field ByteString
--   </pre>
bytestring :: Applicative f => (ByteString -> f ByteString) -> Field -> f Field
