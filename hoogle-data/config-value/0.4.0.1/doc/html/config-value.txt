-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Simple, layout-based value language similar to YAML or JSON
--   
--   This package implments a language similar to YAML or JSON but with
--   fewer special cases and fewer dependencies. It emphasizes layout
--   structure for sections and lists, and requires quotes around strings.
@package config-value
@version 0.4.0.1


-- | Optics for compatibility with the lens package
module Config.Lens

-- | Apply a function to the subsections of the given value when that value
--   is a <tt>Sections</tt> and the subsection name matches the given
--   section name
key :: Applicative f => Text -> (Value -> f Value) -> Value -> f Value

-- | Apply a function to the <a>Text</a> contained inside the given
--   <a>Value</a> when it is a <tt>Text</tt>.
text :: Applicative f => (Text -> f Text) -> Value -> f Value

-- | Apply a function to the <a>Integer</a> contained inside the given
--   <a>Value</a> when it is a <tt>Number</tt>.
number :: Applicative f => (Integer -> f Integer) -> Value -> f Value

-- | Apply a function to the <a>Text</a> contained inside the given
--   <a>Value</a> when it is a <tt>Text</tt>. This traversal is only valid
--   if the output atom is a valid atom!
atom :: Applicative f => (Atom -> f Atom) -> Value -> f Value

-- | Apply a function to the [<a>Value</a>] contained inside the given
--   <a>Value</a> when it is a <tt>List</tt>.
list :: Applicative f => ([Value] -> f [Value]) -> Value -> f Value

-- | Apply a function to the <a>Value</a> elements inside the given
--   <a>Value</a> when it is a <tt>List</tt>.
--   
--   <pre>
--   values = list . traverse
--   </pre>
values :: Applicative f => (Value -> f Value) -> Value -> f Value

-- | Apply a function to the [<a>Section</a>] contained inside the given
--   <a>Value</a> when it is a <tt>Sections</tt>.
sections :: Applicative f => ([Section] -> f [Section]) -> Value -> f Value


-- | This module parses files using the syntax demonstrated below. The full
--   grammar is available in the Happy source file.
--   
--   <pre>
--   -- Line comments until newline
--   layout:
--     based:
--       configuration:
--         {} -- empty section
--   
--       sections:
--        "glguy"
--   
--       {- Block comments
--          {- nested comments -}
--          "O'caml style {- strings in comments"
--          so you can comment out otherwise valid
--          portions of your config
--       -}
--       atoms      : yes
--   
--       decimal    : -1234
--       hexadecimal: 0x1234
--       octal      : 0o1234
--       binary     : 0b1010
--   
--   lists:
--      * sections: in-lists
--        next-section: still-in-list
--      * [ "inline", "lists" ]
--      * * "nestable"
--        * "layout"
--        * "lists"
--      * 3
--   
--   unicode : "standard Haskell format strings (1 ≤ 2)\x2228(2 ≤ 3)"
--   </pre>
module Config

-- | A single section of a <a>Value</a>
data Section
[Section] :: Text -> Value -> Section
[sectionName] :: Section -> Text
[sectionValue] :: Section -> Value

-- | Sum type of the values supported by this language.
data Value
[Sections] :: [Section] -> Value

-- | base number
[Number] :: Int -> Integer -> Value
[Text] :: Text -> Value
[Atom] :: Atom -> Value
[List] :: [Value] -> Value

-- | Wrapper to distinguish <a>Atom</a> from <a>Text</a> by type in a
--   configuration.
newtype Atom
[MkAtom] :: Text -> Atom
[atomName] :: Atom -> Text

-- | Parse a configuration file and return the result on the right, or the
--   position of an error on the left. Note: Text file lines are terminated
--   by new-lines.
parse :: Text -> Either String Value

-- | Pretty-print a <a>Value</a> as shown in the example. Sections will
--   nest complex values underneath with indentation and simple values will
--   be rendered on the same line as their section.
pretty :: Value -> Doc
