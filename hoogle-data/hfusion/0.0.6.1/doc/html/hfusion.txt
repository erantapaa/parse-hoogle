-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A library for fusing a subset of Haskell programs.
--   
--   This package implements algorithms for fusing pure functions which can
--   be written as primitive recursive functions or as hylomorphisms. The
--   functions can be mutually recursive and make recursion over multiple
--   arguments.
@package hfusion
@version 0.0.6.1


-- | Version 0.0.6
--   
--   This version contains several tweaks and fixes as a result of fusing
--   the example of game trees in John Hughes's paper Why Functional
--   Programming Matters.
--   
--   Version 0.0.5.1
--   
--   <ul>
--   <li>Lists missing file in hfusion.cabal.</li>
--   </ul>
--   
--   Version 0.0.5
--   
--   <ul>
--   <li>Implements searching and fusing explicit compositions of
--   hylomorphisms in expressions. E.g.</li>
--   </ul>
--   
--   <pre>
--   ... map f (filter p (map g xs)) ...
--   </pre>
--   
--   but not
--   
--   <pre>
--   ... map f . filter p . map g ...
--   </pre>
--   
--   or
--   
--   <pre>
--   h = map f
--   k = filter p
--   ... h (k (map g xs)) ...
--   </pre>
--   
--   <ul>
--   <li>Fixes fusion of <tt>tails . map</tt> with <tt>tails</tt> defined
--   as:</li>
--   </ul>
--   
--   <pre>
--   tails :: [a] -&gt; [[a]]
--   tails [] = []
--   tails xs@(_:xss) = xs : tails xss
--   </pre>
--   
--   <ul>
--   <li>Fixed derivation of mutual hylos from definitions where each one
--   uses a different set of names for the constant arguments.</li>
--   <li>Fixed pretty printing of terms in the presence of infix
--   constructors. HFusion doesn't support specifying precedences and
--   associativity for infix operators really. I've tried to have the
--   common infix operators (<tt>(:),(+),(*),(-),(^),(++)</tt>) printed
--   resonably, however.</li>
--   </ul>
--   
--   Version 0.0.4
--   
--   <ul>
--   <li>Fuses spoon-feeded compositions.</li>
--   </ul>
module HFusion.CHANGELOG


-- | Functions exported by this module can be used to fuse programs as
--   shown below. The following program reads some Haskell definitions from
--   the standard input and prints the transformed definitions to the
--   standard output.
--   
--   <pre>
--   import HFusion.HFusion
--   import Control.Monad.Trans(lift)
--   import Language.Haskell.Parser(parseModule)
--   </pre>
--   
--   <pre>
--   fuseProgram :: String -&gt; Either FusionError String
--   fuseProgram sourceCode = runFusionState newVarGen$
--      -- Parse input with a Haskell parser.
--      parseResult2FusionState (Language.Haskell.Parser.parseModule sourceCode) 
--      -- Convert the haskell AST to the AST used by HFusion.
--      &gt;&gt;= hsModule2HsSyn 
--      -- Fuse compositions in the program.
--      &gt;&gt;= \dfs -&gt; lift (fuseDefinitions dfs dfs) 
--      -- Pretty print the result.
--      &gt;&gt;= return . hsSyn2HsSourceCode . uncurry (++)
--   
--      main = do cs &lt;- getContents
--                putStr$ either (("There was an error: "++) . show) id$ fuseProgram cs
--   </pre>
--   
--   For more information on HFusion please visit
--   <a>http://www.fing.edu.uy/inco/proyectos/fusion</a>.
module HFusion.HFusion

-- | Converts an <a>HsModule</a> into the abstract syntax tree used by
--   HFusion. The HsModule can be obtained by parsing a Haskell program
--   with <tt>Language.Haskell.Parser.parseModule</tt>
hsModule2HsSyn :: HsModule -> FusionState [Def]

-- | Obtains hylomorphisms representing functions in the original program.
--   
--   The hylomorphisms are returned in the second component of the output.
--   If a hylomorphism cannot be derived for some (possibly) mutually
--   recursive function definitions, then they are returned in the first
--   component of the output together with the error obtained when
--   attempting derivation.
deriveHylos :: [Def] -> VarGenState ([([Def], FusionError)], [([Def], HyloT)])

-- | Eliminates compositions of recursive functions from definitions.
fuseDefinitions :: [Def] -> [Def] -> VarGenState ([Def], [Def])

-- | Fuses the composition of two recursive functions producing an
--   equivalent new recursive function.
--   
--   <tt>fuse <a>f</a> 1 <a>g</a> [h_1 .. h_n] dfns</tt> yields a set of
--   mutually recursive functions named <tt>h_1 .. h_n</tt> which are
--   equivalent to <tt>f . g</tt>. Functions <tt>f</tt> and <tt>g</tt> must
--   be hylomorphisms defined in <tt>dfns</tt>.
--   
--   <tt>fuse <a>f</a> 2 <a>g</a> [h_1 .. h_n] dfns</tt> yields a recursive
--   function equivalent to <tt>\x y -&gt; f x (g y)</tt>, <tt>fuse
--   <a>f</a> 3 <a>g</a> [h_1 .. h_n] dfns</tt> yields a recursive function
--   equivalent to <tt>\x y z -&gt; f x y (g z)</tt>, and so on ...
fuse :: String -> Int -> String -> [String] -> [HyloT] -> FusionState [Def]

-- | Works like <a>fuse</a> but returns also a string resembling the
--   hylomorphism which represents the result of fusion.
fuse' :: String -> Int -> String -> [String] -> [HyloT] -> FusionState ([Def], String)

-- | Pretty prints a set of definitions into Haskell source code.
hsSyn2HsSourceCode :: [Def] -> String

-- | Runs a <a>FusionState</a> computation using the given variable
--   generator. The result is either the promised value or a
--   <a>FusionError</a>.
runFusionState :: VarGen -> FusionState a -> Either FusionError a

-- | Errors that the algorithms in <a>HFusion</a> can produce.
data FusionError

-- | Thrown when hylomorphism derivation fails due to the existence of a
--   non-saturated application of the recursive function in its definition.
NotSaturated :: Term -> FusionError

-- | Thrown when hylomorphism derivation fails due to encountering a
--   <a>Term</a> like <a>Thyloapp</a> which is not expected in the input.
NotExpected :: Term -> FusionError

-- | Thrown when fusion fails due to the inability of the implementation to
--   derive an unfold from the definition at the right of the composition.
NotInF :: FusionError

-- | Thrown when fusion fails due to the inability of the implementation to
--   derive a fold from the definition at the left of the composition.
NotOutF :: FusionError

-- | Thrown when fusion fails due to the inability of the implementation to
--   derive a <i>tau</i> transformer from the algebra of the definition at
--   the right of the composition.
NotTau :: FusionError

-- | Thrown when fusion fails due to the inability of the implementation to
--   derive a <i>sigma</i> transformer from the coalgebra of the definition
--   at the left of the composition.
NotSigma :: FusionError

-- | When a definition which was requested to be fused is not found among
--   the derived hylomorphisms.
NotFound :: String -> FusionError

-- | A generic error message.
Msg :: String -> FusionError

-- | Thrown when translation of a program to a <a>Def</a> values fails.
ParserError :: SrcLoc -> String -> FusionError

-- | An error monad with <a>FusionError</a> errors and a state monad
--   carrying a generator of fresh variables.
type FusionState a = ErrorT FusionError VarGenState a

-- | Data used to generate variables. The map stores for each variable name
--   generated so far which was the index last used to generate a fresh
--   variable with such a name as prefix.
type VarGen = Map String Int

-- | Creates a variable generator
newVarGen :: VarGen

-- | Allows to handle parsing of an <a>HsModule</a> as a <a>FusionState</a>
--   computation.
--   
--   <pre>
--   parseResult2FusionState (Language.Haskell.Parser.parseModule sourceCode)
--   </pre>
parseResult2FusionState :: ParseResult HsModule -> FusionState HsModule

-- | Representation for function definitions.
data Def
Defvalue :: Variable -> Term -> Def

-- | Representation for terms in programs handled by <a>HFusion</a>.
data Term

-- | Variables
Tvar :: Variable -> Term

-- | Literals
Tlit :: Literal -> Term

-- | Tuples. The boolean argument tells if the tuple must be flattened when
--   nested with others under an hylo application.
Ttuple :: Bool -> [Term] -> Term

-- | Lambda expressions
Tlamb :: Boundvar -> Term -> Term

-- | Let expressions
Tlet :: Variable -> Term -> Term -> Term

-- | Case expressions
Tcase :: Term -> [Pattern] -> [Term] -> Term

-- | Function application (saturated)
Tfapp :: Variable -> [Term] -> Term

-- | Constructor application
Tcapp :: Constructor -> [Term] -> Term

-- | General term application
Tapp :: Term -> Term -> Term

-- | Undefined computation
Tbottom :: Term

-- | If expressions, only used for pretty printing
Tif :: Term -> Term -> Term -> Term
Tpar :: Term -> Term

-- | Hylo application, only used for inlining. In <tt>Thyloapp name
--   recargsCount non-recargs recarg</tt> the argument <tt>recarg</tt> may
--   be a tuple.
Thyloapp :: Variable -> Int -> [Term] -> (Maybe [Int]) -> Term -> Term

-- | Representation of patterns
data Pattern

-- | Variables
Pvar :: Variable -> Pattern

-- | Tuple patterns
Ptuple :: [Pattern] -> Pattern

-- | Constructor application patterns
Pcons :: Constructor -> [Pattern] -> Pattern

-- | Literals
Plit :: Literal -> Pattern

-- | @-pattern
Pas :: Variable -> Pattern -> Pattern

-- | Representation of variables.
data Variable

-- | Name found in the original program.
Vuserdef :: String -> Variable

-- | Generated identifier containing a prefix and an index.
Vgen :: String -> Int -> Variable

-- | Representation for constructors.
type Constructor = String

-- | Representation for Literals.
data Literal

-- | String literals
Lstring :: String -> Literal

-- | Integer literals
Lint :: String -> Literal

-- | Character literals
Lchar :: Char -> Literal

-- | Rational literals
Lrat :: String -> Literal

-- | Representation of bound variables in lambda expressions.
data Boundvar
Bvar :: Variable -> Boundvar

-- | Bound variable tuples. Uses the boolean value like in <a>Ttuple</a>.
--   but when bounding input variables of hylomorphisms.
Bvtuple :: Bool -> [Boundvar] -> Boundvar
