-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Data-flow based graph algorithms
--   
--   Data-flow based graph algorithms using the <a>Control.Etage</a>
--   framework, showcasing its use for data-flow computations. It is meant
--   to be used with the <a>Data.Graph.Inductive</a> package which provides
--   graph structures these algorithms take as an input.
--   
--   Currently only the shortest paths computation is implemented (from all
--   to all nodes).
--   
--   Also a benchmarking <tt>test</tt> program is provided, comparing the
--   performance with algorithms found in the <a>Data.Graph.Inductive</a>
--   package.
@package Etage-Graph
@version 0.1.7


-- | Please read the <a>Control.Etage</a> framework documentation for
--   general information how it works. Also check included <tt>test</tt>
--   program for an example of how to work with the algorithms bellow.
module Data.Graph.Etage

-- | Shortest paths algorithm (from all to all nodes) using message
--   (<a>Impulse</a>s in the <a>Control.Etage</a> terminology) passing
--   between the nodes along the edges of the graph to compute shortest
--   paths. Loosely based on the algorithm used in the Babel routing
--   protocol, <a>http://www.pps.jussieu.fr/~jch/software/babel/</a>.
--   
--   It takes a <a>Data.Graph.Inductive</a> graph as an input and produces
--   a map between source nodes and its corresponding <a>Nerve</a>s, over
--   which <a>Impulse</a>s about shortest paths search will be send. To
--   trigger the search <a>sendTopologyChange</a> should be used on
--   returned <a>Nerve</a>s.
--   
--   One way how to collect this <a>Impulse</a>s into an array for querying
--   about shortest paths can be found in the <tt>test</tt> program found
--   in this package.
--   
--   While shortest paths search is lasting, information about suboptimal
--   paths is already available. This algorithm also allows effective
--   incremental search after graph topology changes (new nodes are added
--   or removed, weights are changed) but this is not yet implemented.
shortestPaths :: (DynGraph gr, Show a, Show b, Data a, Data b, Real b, Bounded b) => gr a b -> Incubation (Map Node (Nerve (GraphImpulse a b) AxonConductive (GraphImpulse a b) AxonConductive))

-- | Inform nodes that topology has changed (new nodes have been added or
--   removed, weights changed).
--   
--   Currently it should only be invoked after the data-flow graph
--   structure has been built (for example with <a>shortestPaths</a>). As
--   graph topology changing interface (and thus incremental nature of
--   algorithms) is not yet implemented.
sendTopologyChange :: Map Node (Nerve (GraphImpulse a b) AxonConductive (GraphImpulse a b) AxonConductive) -> Incubation ()
data GraphImpulse a b

-- | Informs nodes about possible improvement in the topology information,
--   like a newly discovered shortest path.
TopologyUpdate :: ImpulseTime -> LNode a -> LNode a -> SPath b -> GraphImpulse a b
impulseTimestamp :: GraphImpulse a b -> ImpulseTime
originator :: GraphImpulse a b -> LNode a
destination :: GraphImpulse a b -> LNode a
path :: GraphImpulse a b -> SPath b

-- | Informs nodes that topology has changed and the algorithm should be
--   triggered (again).
TopologyChange :: ImpulseTime -> GraphImpulse a b
impulseTimestamp :: GraphImpulse a b -> ImpulseTime

-- | Inform the node that new outbound edges have been <a>attach</a>ed to
--   it, giving the node their weights.
AddOutEdges :: ImpulseTime -> Adj b -> GraphImpulse a b
impulseTimestamp :: GraphImpulse a b -> ImpulseTime
newOutEdges :: GraphImpulse a b -> Adj b
instance Typeable2 NodeNeuron
instance Typeable2 GraphImpulse
instance Data a => Data (LPath a)
instance Typeable1 LPath
instance (Data a, Data b) => Data (NodeNeuron a b)
instance (Eq a, Eq b) => Eq (GraphImpulse a b)
instance (Ord a, Ord b) => Ord (GraphImpulse a b)
instance (Show a, Show b) => Show (GraphImpulse a b)
instance (Data a, Data b) => Data (GraphImpulse a b)
instance Eq a => Eq (NeuronOptions (NodeNeuron a b))
instance Ord a => Ord (NeuronOptions (NodeNeuron a b))
instance Read a => Read (NeuronOptions (NodeNeuron a b))
instance Show a => Show (NeuronOptions (NodeNeuron a b))
instance Bounded Double
instance Bounded Float
instance (Show a, Data a, Show b, Data b, Real b, Bounded b) => Neuron (NodeNeuron a b)
instance (Show a, Typeable a, Show b, Typeable b, Real b, Bounded b) => Impulse (GraphImpulse a b)
