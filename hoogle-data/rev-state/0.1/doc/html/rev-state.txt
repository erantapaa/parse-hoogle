-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Reverse State monad transformer
--   
--   It's like the State monad transformer. But Reversed! The state goes
--   backwards.
@package rev-state
@version 0.1

module Control.Monad.Trans.RevState
newtype StateT s m a
StateT :: (s -> m (a, s)) -> StateT s m a
runStateT :: StateT s m a -> s -> m (a, s)
evalStateT :: Monad m => StateT s m a -> s -> m a
execStateT :: Monad m => StateT s m a -> s -> m s
mapStateT :: (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
withStateT :: (s -> s) -> StateT s m a -> StateT s m a
type State s = StateT s Identity
runState :: State s a -> s -> (a, s)
evalState :: State s a -> s -> a
execState :: State s a -> s -> s
mapState :: ((a, s) -> (b, s)) -> State s a -> State s b
withState :: (s -> s) -> State s a -> State s a
get :: Monad m => StateT s m s
put :: Monad m => s -> StateT s m ()
state :: Monad m => (s -> (a, s)) -> StateT s m a
gets :: Monad m => (s -> a) -> StateT s m a
modify :: Monad m => (s -> s) -> StateT s m ()
instance MonadFix m => MonadFix (StateT s m)
instance Monad m => Functor (StateT s m)
instance MonadFix m => Applicative (StateT s m)
instance MonadFix m => Monad (StateT s m)

module Control.Monad.RevState.Class
class (Applicative m, MonadFix m) => MonadRevState s m | m -> s where get = state $ \ s -> (s, s) put s = state $ \ _ -> ((), s) state f = do { rec { let ~(a, s') = f s; put s'; s <- get }; return a }
get :: MonadRevState s m => m s
put :: MonadRevState s m => s -> m ()
state :: MonadRevState s m => (s -> (a, s)) -> m a
modify :: MonadRevState s m => (s -> s) -> m ()
gets :: MonadRevState s m => (s -> a) -> m a
instance MonadFix m => MonadRevState s (StateT s m)

module Control.Monad.RevState
