-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Small modules for a Haskell course in which Haskell is taught by implementing Prelude functionality.
--   
--   Small modules for a Haskell course in which Haskell is taught by
--   implementing Prelude functionality.
@package haskell-course-preludes
@version 0.0.0.4

module Prelude.OldIO
data IORequest
Print :: String -> IORequest
PrintChar :: Char -> IORequest
GetLine :: IORequest
ReadFile :: FilePath -> IORequest
WriteToFile :: FilePath -> String -> IORequest
Exit :: IORequest
data IOResponse
Success :: IOResponse
FileContents :: String -> IOResponse
ConsoleLine :: String -> IOResponse
run :: ([IOResponse] -> [IORequest]) -> IO ()

-- | Function composition.
(.) :: (b -> c) -> (a -> b) -> a -> c

-- | The <a>trace</a> function outputs the trace message given as its first
--   argument, before returning the second argument as its result.
--   
--   For example, this returns the value of <tt>f x</tt> but first outputs
--   the message.
--   
--   <pre>
--   trace ("calling f with x = " ++ show x) (f x)
--   </pre>
--   
--   The <a>trace</a> function should <i>only</i> be used for debugging, or
--   for monitoring execution. The function is not referentially
--   transparent: its type indicates that it is a pure function but it has
--   the side effect of outputting the trace message.
trace :: String -> a -> a
instance NFData IOResponse

module Prelude.Week0
type Char = Char
type String = [Char]
type Int = Int
type Double = Double
data Bool :: *
False :: Bool
True :: Bool
(+) :: Int -> Int -> Int
(-) :: Int -> Int -> Int
(*) :: Int -> Int -> Int
mod :: Int -> Int -> Int
(>) :: Int -> Int -> Bool
(<) :: Int -> Int -> Bool
(>=) :: Int -> Int -> Bool
(<=) :: Int -> Int -> Bool
(==) :: Int -> Int -> Bool
(/=) :: Int -> Int -> Bool
(+.) :: Double -> Double -> Double
(-.) :: Double -> Double -> Double
(*.) :: Double -> Double -> Double
(>.) :: Double -> Double -> Bool
(<.) :: Double -> Double -> Bool
(>=.) :: Double -> Double -> Bool
(<=.) :: Double -> Double -> Bool
(==.) :: Double -> Double -> Bool
(/=.) :: Double -> Double -> Bool

-- | Boolean "or"
(||) :: Bool -> Bool -> Bool

-- | Boolean "and"
(&&) :: Bool -> Bool -> Bool

-- | Boolean "not"
not :: Bool -> Bool
doubleToString :: Double -> String
intToString :: Int -> String
charToString :: Char -> String
intToDouble :: Int -> Double
intToChar :: Int -> Char
charToInt :: Char -> Int
data BasicList a
empty :: BasicList a
prepend :: a -> BasicList a -> BasicList a
get :: Int -> BasicList a -> a

-- | Append two strings.
(<>) :: String -> String -> String

-- | Function composition.
(.) :: (b -> c) -> (a -> b) -> a -> c

-- | The <a>trace</a> function outputs the trace message given as its first
--   argument, before returning the second argument as its result.
--   
--   For example, this returns the value of <tt>f x</tt> but first outputs
--   the message.
--   
--   <pre>
--   trace ("calling f with x = " ++ show x) (f x)
--   </pre>
--   
--   The <a>trace</a> function should <i>only</i> be used for debugging, or
--   for monitoring execution. The function is not referentially
--   transparent: its type indicates that it is a pure function but it has
--   the side effect of outputting the trace message.
trace :: String -> a -> a

-- | <a>error</a> stops execution and displays an error message.
error :: [Char] -> a

-- | The <a>print</a> function outputs a value of any printable type to the
--   standard output device. Printable types are those that are instances
--   of class <a>Show</a>; <a>print</a> converts values to strings for
--   output using the <a>show</a> operation and adds a newline.
--   
--   For example, a program to print the first 20 integers and their powers
--   of 2 could be written as:
--   
--   <pre>
--   main = print ([(n, 2^n) | n &lt;- [0..19]])
--   </pre>
print :: Show a => a -> IO ()

-- | Sequentially compose two actions, discarding any value produced by the
--   first, like sequencing operators (such as the semicolon) in imperative
--   languages.
(>>) :: Monad m => forall a b. m a -> m b -> m b

-- | Inject a value into the monadic type.
return :: Monad m => forall a. a -> m a
