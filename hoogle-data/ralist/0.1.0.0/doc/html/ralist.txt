-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Random access list with a list compatible interface.
--   
--   Random access list with a list compatible interface. Random access
--   list have same complexity as lists with some exceptions, the notable
--   one being that (!!) is O(log n) instead of O(n). RALists have to be
--   finite.
@package ralist
@version 0.1.0.0


-- | A random-access list implementation based on Chris Okasaki's approach
--   on his book "Purely Functional Data Structures", Cambridge University
--   Press, 1998, chapter 9.3.
--   
--   <a>RAList</a> is a replacement for ordinary finite lists.
--   <a>RAList</a> provides the same complexity as ordinary for most the
--   list operations. Some operations take <i>O(log n)</i> for
--   <a>RAList</a> where the list operation is <i>O(n)</i>, notably
--   indexing, '(!!)'.
module Data.RAList
data RAList a
empty :: RAList a

-- | Complexity <i>O(1)</i>.
cons :: a -> RAList a -> RAList a
(++) :: RAList a -> RAList a -> RAList a

-- | Complexity <i>O(1)</i>.
head :: RAList a -> a

-- | Complexity <i>O(log n)</i>.
last :: RAList a -> a

-- | Complexity <i>O(1)</i>.
tail :: RAList a -> RAList a
init :: RAList a -> RAList a
null :: RAList a -> Bool

-- | Complexity <i>O(1)</i>.
length :: RAList a -> Int
map :: (a -> b) -> RAList a -> RAList b
reverse :: RAList a -> RAList a
foldl :: (a -> b -> a) -> a -> RAList b -> a
foldl' :: (a -> b -> a) -> a -> RAList b -> a
foldl1 :: (a -> a -> a) -> RAList a -> a
foldl1' :: (a -> a -> a) -> RAList a -> a
foldr :: (a -> b -> b) -> b -> RAList a -> b
foldr1 :: (a -> a -> a) -> RAList a -> a
concat :: RAList (RAList a) -> RAList a
concatMap :: (a -> RAList b) -> RAList a -> RAList b
and :: RAList Bool -> Bool
or :: RAList Bool -> Bool
any :: (a -> Bool) -> RAList a -> Bool
all :: (a -> Bool) -> RAList a -> Bool
sum :: Num a => RAList a -> a
product :: Num a => RAList a -> a
maximum :: Ord a => RAList a -> a
minimum :: Ord a => RAList a -> a
replicate :: Int -> a -> RAList a
take :: Int -> RAList a -> RAList a

-- | Complexity <i>O(log n)</i>.
drop :: Int -> RAList a -> RAList a
splitAt :: Int -> RAList a -> (RAList a, RAList a)
elem :: Eq a => a -> RAList a -> Bool
notElem :: Eq a => a -> RAList a -> Bool
lookup :: Eq a => a -> RAList (a, b) -> Maybe b
filter :: (a -> Bool) -> RAList a -> RAList a
partition :: (a -> Bool) -> RAList a -> (RAList a, RAList a)

-- | Complexity <i>O(log n)</i>.
(!!) :: RAList a -> Int -> a
zip :: RAList a -> RAList b -> RAList (a, b)
zipWith :: (a -> b -> c) -> RAList a -> RAList b -> RAList c
unzip :: RAList (a, b) -> (RAList a, RAList b)

-- | Change element at the given index. Complexity <i>O(log n)</i>.
update :: Int -> a -> RAList a -> RAList a

-- | Apply a function to the value at the given index. Complexity <i>O(log
--   n)</i>.
adjust :: (a -> a) -> Int -> RAList a -> RAList a

-- | Complexity <i>O(n)</i>.
toList :: RAList a -> [a]

-- | Complexity <i>O(n)</i>.
fromList :: [a] -> RAList a
instance Eq a => Eq (Tree a)
instance Eq a => Eq (Top a)
instance Eq a => Eq (RAList a)
instance Functor Tree
instance Functor Top
instance Monad RAList
instance Functor RAList
instance Monoid (RAList a)
instance Ord a => Ord (RAList a)
instance Read a => Read (RAList a)
instance Show a => Show (RAList a)
