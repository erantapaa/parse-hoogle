-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Operational Applicative, Alternative, Monad and MonadPlus from free types.
--   
--   A reimplementation of the <tt>operational</tt> package
--   (<a>http://hackage.haskell.org/package/operational</a>) using free
--   monads (from <a>http://hackage.haskell.org/package/free</a>). This
--   implements ideas discussed here:
--   
--   <ul>
--   
--   <li><a>http://stackoverflow.com/questions/14263363/is-operational-really-isomorphic-to-a-free-monad</a></li>
--   
--   <li><a>http://www.reddit.com/r/haskell/comments/17a33g/free_functors_the_reason_free_and_operational_are/</a></li>
--   </ul>
--   
--   To understand the basic concepts you can do no better than read
--   Heinrich Apfelmus' <tt>operational</tt> tutorial:
--   
--   <ul>
--   
--   <li><a>http://apfelmus.nfshost.com/articles/operational-monad.html</a></li>
--   </ul>
--   
--   In addition to that, this package supplies <tt>operational</tt>-style
--   modules for <a>Applicative</a>, <a>Alternative</a> and
--   <a>MonadPlus</a>. <a>Applicative</a> and <a>Alternative</a> programs
--   easily admit of static analysis. See these references for discussion
--   and examples:
--   
--   <ul>
--   
--   <li><a>http://gergo.erdi.hu/blog/2012-12-01-static_analysis_with_applicatives/</a>
--   (discussion:
--   <a>http://www.reddit.com/r/haskell/comments/143wpd/static_analysis_with_applicatives/</a>)</li>
--   
--   <li><a>http://paolocapriotti.com/blog/2013/04/03/free-applicative-functors/</a>
--   (discussion:
--   <a>http://www.reddit.com/r/haskell/comments/1bnql3/free_applicative_functors_icfp_submission/</a>)</li>
--   </ul>
--   
--   See <a>Control.Applicative.Operational</a> for the bulk of the
--   documentation. <a>Control.Alternative.Operational</a> also has some
--   significant examples.
@package free-operational
@version 0.5.0.0


-- | Utility functions for working with instructions and instruction sets.
--   
--   The <a>Data.Functor.Coproduct</a> module is very useful with
--   instruction sets, so this module reexports it. The <a>Coproduct</a>
--   type can be used to take the union of two instruction sets, and the
--   <a>coproduct</a> function can be used to construct an instruction
--   evaluation for such an union. So if we have these two instruction
--   evaluations:
--   
--   <pre>
--   evalI  :: forall x. instr  x -&gt; f x
--   evalI' :: forall x. instr' x -&gt; f x 
--   </pre>
--   
--   then their <a>coproduct</a> is an evaluation for the union of the
--   instruction sets:
--   
--   <pre>
--   coproduct evalI evalI' :: forall x. (Coproduct instr instr' x) -&gt; f x
--   </pre>
module Control.Operational.Instruction

-- | Lift an operational instruction evaluator into a free <a>Functor</a>
--   evaluator.
liftEvalI :: Functor f => (forall x. instr x -> f x) -> Coyoneda instr a -> f a
liftInstr :: instr a -> Coyoneda instr a

module Control.Operational.Class

-- | The class of operational programs.
class Operational instr p | p -> instr
singleton :: Operational instr p => instr a -> p a


-- | <a>Applicative</a> programs over an <tt>operational</tt>-style
--   instruction set, implemented on top of the <a>Ap</a> free
--   <a>Applicative</a> type.
module Control.Applicative.Operational

-- | An <a>Applicative</a> program over instruction set <tt>instr</tt>.
--   This is modeled after the <tt>Program</tt> type from
--   <tt>operational</tt>
--   (<a>http://hackage.haskell.org/package/operational</a>), but this one
--   is an <a>Applicative</a>, not a <a>Monad</a>. This makes it less
--   powerful, but in exchange for the sacrificed power <a>ProgramAp</a> is
--   suceptible to much stronger static analysis.
--   
--   For examples of this (though applied to free applicatives), see:
--   
--   <ul>
--   
--   <li><a>http://gergo.erdi.hu/blog/2012-12-01-static_analysis_with_applicatives/</a></li>
--   
--   <li><a>http://paolocapriotti.com/blog/2013/04/03/free-applicative-functors/</a></li>
--   </ul>
--   
--   See also the examples in <a>Control.Alternative.Operational</a>.
newtype ProgramAp instr a
ProgramAp :: Ap (Coyoneda instr) a -> ProgramAp instr a

-- | Interpret a <a>ProgramAp</a> as a free applicative (<a>Ap</a>).
toAp :: ProgramAp instr a -> Ap (Coyoneda instr) a

-- | Evaluate a <a>ProgramAp</a> by interpreting each instruction as an
--   <a>Applicative</a> action. Example <tt>Reader</tt> implementation:
--   
--   <pre>
--   type Reader r a = ProgramAp (ReaderI r) a
--   
--   data ReaderI r a where
--       Ask :: ReaderI r r
--   
--   ask :: Reader r r
--   ask = singleton Ask
--   
--   runReader :: forall r a. Reader r a -&gt; r -&gt; a
--   runReader = interpretAp evalI
--       where evalI :: forall a. ReaderI r a -&gt; r -&gt; a
--             evalI Ask = id
--   </pre>
interpretAp :: Applicative f => (forall x. instr x -> f x) -> ProgramAp instr a -> f a

-- | Lift a <a>ProgramAp</a> into any other <a>Operational</a> program type
--   that is at least as strong as <a>Applicative</a>; e.g., lift an
--   applicative program into a monadic one. Note that not all applicatives
--   are monads, so a lifted program may "lose" some of the interpretations
--   that the original could be given.
fromProgramAp :: (Operational instr f, Applicative f) => ProgramAp instr a -> f a

-- | A friendly concrete tree view type for <a>ProgramAp</a>. Unlike the
--   <tt>:&gt;&gt;=</tt> constructor in the <tt>ProgramView</tt> type of
--   <a>Control.Monad.Operational</a>, whose second data member is a
--   function that consumes an instruction result to generate the rest of
--   the program, our <a>:&lt;**&gt;</a> constructor exposes the rest of
--   program immediately.
--   
--   Note that the <a>ProgramViewAp</a> type normalizes the program into a
--   different ordering and bracketing than the applicative
--   <a>&lt;*&gt;</a> operator does. The <a>:&lt;**&gt;</a> constructor is
--   an analogue of <tt><a>&lt;**&gt;</a> :: Applicative f =&gt; f a -&gt;
--   f (a -&gt; b) -&gt; f b</tt> from <a>Control.Applicative</a>. The
--   normalization means that you get a list-like structure with
--   instructions as the elements (in the same order as their effects) and
--   <a>Pure</a> as the terminator.
--   
--   A static analysis example, based on Capriotti and Kaposi (2013,
--   <a>http://paolocapriotti.com/blog/2013/04/03/free-applicative-functors/</a>):
--   
--   <pre>
--   {-# LANGUAGE GADTs, RankNTypes, ScopedTypeVariables #-}
--   
--   import Control.Operational.Applicative
--   
--   data FileSystemI a where
--       Read  :: FilePath -&gt; FileSystemI String 
--       Write :: FilePath -&gt; String -&gt; FileSystemI ()
--   
--   -- | Count how many file accesses a program does.
--   count :: ProgramAp FileSystemI a -&gt; Int
--   count = count' . viewAp
--       where count' :: forall x. ProgramViewAp FileSystemI x -&gt; Int
--             count' (Pure _)   = 0
--             count' (_ :&lt;**&gt; k) = succ (count' k)
--   </pre>
--   
--   Or actually, just this:
--   
--   <pre>
--   count :: ProgramAp FileSystemI a -&gt; Int
--   count = length . instructions
--   </pre>
--   
--   You can also use the <a>ProgramViewAp</a> to interpret the program, in
--   the style of the <tt>operational</tt> package. Example implementation
--   of a simple terminal language in this style:
--   
--   <pre>
--   data TermI a where
--       Say :: String -&gt; TermI ()
--       Get :: TermI String
--   
--   say :: String -&gt; ProgramAp TermI ()
--   say = singleton . Say
--   
--   get :: ProgramAp TermI String
--   get = singleton Get
--   
--   prompt :: String -&gt; ProgramAp TermI String
--   prompt str = say str *&gt; get
--   
--   runTerm :: ProgramAp TermI a -&gt; IO a
--   runTerm = eval . viewAp
--       where eval :: forall x. ProgramViewAp TermI x -&gt; IO x
--             eval (Pure a) = pure a
--             eval (Say str :&lt;**&gt; k) = putStr str &lt;**&gt; eval k
--             eval (Get :&lt;**&gt; k)     = getLine    &lt;**&gt; eval k 
--   
--   example :: ProgramAp TermI (String, String)
--   example = (,) &lt;$&gt; prompt "First question: " &lt;*&gt; prompt "Second question: "
--   
--   -- example = Say "First question: " :&lt;**&gt; (Get :&lt;**&gt; (Say "Second question: " :&lt;**&gt; (Get :&lt;**&gt; Pure (\_ a _ b -&gt; (a, b)))))
--   </pre>
--   
--   But as a general rule, <a>interpretAp</a> makes for shorter, less
--   repetitive, fooler-proof interpreters:
--   
--   <pre>
--   runTerm :: ProgramAp TermI a -&gt; IO a
--   runTerm = interpretAp evalI
--       where evalI :: forall x. TermI x -&gt; IO x
--             evalI (Say str)   = putStr str
--             evalI Get         = getLine
--   </pre>
data ProgramViewAp instr a
Pure :: a -> ProgramViewAp instr a
(:<**>) :: instr a -> ProgramViewAp instr (a -> b) -> ProgramViewAp instr b

-- | Materialize a <a>ProgramAp</a> as a concrete tree. Note that
--   <tt>ProgramAp'</tt>s <a>Functor</a> and <a>Applicative</a> instances
--   normalize their programs, so the view term may not look like the code
--   that created it. Instructions however will appear in the order that
--   their effects should happen, from left to right.
viewAp :: ProgramAp instr a -> ProgramViewAp instr a

-- | Compile a <a>ProgramViewAp</a> back into a <a>ProgramAp</a>.
compileAp :: ProgramViewAp instr a -> ProgramAp instr a
foldProgramViewAp :: (forall x. instr x -> r -> r) -> r -> ProgramViewAp instr a -> r
instructions :: ProgramAp instr a -> [AnyInstr instr]
data AnyInstr instr
AnyInstr :: (instr a) -> AnyInstr instr
instance Functor (ProgramAp instr)
instance Applicative (ProgramAp instr)
instance Operational instr (ProgramAp instr)


-- | <tt>operational</tt>-style <a>Alternative</a> programs. See
--   <a>Control.Applicative.Operational</a> for guidance on how to use this
--   module.
--   
--   Example: simple applicative parsers:
--   
--   <pre>
--   import Control.Applicative
--   import Control.Alternative.Operational
--   import Control.Alternative.Monad (void)
--   import Data.Functor.Compose (Compose(..))
--   import Data.Traversable
--   import Data.Maybe (listToMaybe)
--   data ParserI a where
--       Symbol :: Char -&gt; ParserI Char
--   
--   char :: Operational ParserI f =&gt; Char -&gt; f Char
--   char = singleton . Symbol
--   
--   string :: (Operational ParserI f, Applicative f) =&gt; String -&gt; f String
--   string = traverse char
--   
--   oneOf :: (Operational ParserI f, Alternative f) =&gt; String -&gt; f Char
--   oneOf = foldr (&lt;|&gt;) empty . map char
--   
--   
--   -- | Example parser: match parentheses and count depth.
--   parens :: ProgramAlt ParserI Int
--   parens = pure 0  &lt;|&gt;  char '(' *&gt; fmap (+1) parens &lt;* char ')'
--   
--   
--   -- | Interpret a parser program \"syntactically\" by pattern matching
--   -- on its view.
--   runParser :: ProgramAlt ParserI a -&gt; String -&gt; Maybe a
--   runParser = fmap listToMaybe . eval . viewAlt
--       where
--         eval :: ProgramViewAlt ParserI a -&gt; String -&gt; [a]
--         eval (Pure a) [] = pure a
--         eval (Pure a) _  = empty
--         eval (Symbol c :&lt;**&gt; k) [] = empty
--         eval (Symbol c :&lt;**&gt; k) (x:xs) 
--             | c == x    = pure c &lt;**&gt; eval k xs
--             | otherwise = empty
--         eval (Many ps) str = fmap asum (sequenceA (map eval ps)) str
--   
--   asum :: Alternative f =&gt; [f a] -&gt; f a
--   asum = foldr (&lt;|&gt;) empty
--   </pre>
--   
--   Alternatively, programs may be interpreted in a more denotational
--   style:
--   
--   <pre>
--   runParser :: ProgramAlt ParserI a -&gt; String -&gt; Maybe a
--   runParser = (firstSuccess .) . runStateT . interpretAlt evalParserI
--       where firstSuccess [] = Nothing
--             firstSuccess ((a,""):_) = Just a
--             firstSuccess (_:xs) = firstSuccess xs
--   
--   evalParserI :: ParserI a -&gt; StateT String [] a
--   evalParserI (Symbol c) = 
--       do str &lt;- get
--          case str of
--            x:xs | c == x -&gt; put xs &gt;&gt; return c
--            otherwise     -&gt; mzero
--   </pre>
--   
--   One of the big "powers" of <a>ProgramAlt</a> is that it allows for
--   powerful static analysis of programs. For example, we can enumerate
--   the strings accepted by a non-degenerate parser:
--   
--   <pre>
--   -- | Static analysis example: enumerate the strings accepted by a parser.
--   enumerate :: ProgramAlt ParserI a -&gt; [String]
--   enumerate = go [showString ""] . viewAlt
--       where
--         go :: [ShowS] -&gt; ProgramViewAlt ParserI a -&gt; [String]
--         go strs (Pure a) = map ($"") strs
--         go strs (Symbol c :&lt;**&gt; k) = go (map (.(showChar c)) strs) k
--         go strs (Many ps) = interleave $ map (go strs) ps
--   
--   interleave :: [[a]] -&gt; [a]
--   interleave = foldr interleave2 []
--       where
--         interleave2 :: [a] -&gt; [a] -&gt; [a]
--         interleave2 [] ys = ys
--         interleave2 (x:xs) ys = x : interleave2 ys xs
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; take 7 (enumerate parens)
--   ["","()","(())","((()))","(((())))","((((()))))","(((((())))))"]
--   </pre>
--   
--   (<tt>enumerate</tt> isn't guaranteed to terminate or even produce WHNF
--   for all parsers; e.g., <tt>let a = char <tt>a</tt> *&gt; a in
--   enumerate a</tt> diverges. But this parser doesn't accept any
--   strings!)
--   
--   Or we can optimize a (non-degenerate) parser by merging prefixes:
--   
--   <pre>
--   optimize :: ProgramAlt ParserI a -&gt; ProgramAlt ParserI a
--   optimize = compileAlt . merge . viewAlt
--   
--   merge :: ProgramViewAlt ParserI a -&gt; ProgramViewAlt ParserI a
--   merge p@(Pure _) = p
--   merge (Symbol a :&lt;**&gt; k) = Symbol a :&lt;**&gt; merge k
--   merge (Many ps) = Many (mergeMany ps)
--   
--   mergeMany :: [ProgramViewAlt ParserI a] -&gt; [ProgramViewAlt ParserI a]
--   mergeMany = foldr step [] . map merge
--       where step (Pure a) ps = Pure a : ps
--             step (Symbol a :&lt;**&gt; l) ((Symbol b :&lt;**&gt; r) : ps) =
--                  case a `compare` b of
--                    EQ -&gt; (Symbol a :&lt;**&gt; Many (mergeMany [l, r])) : ps
--                    LT -&gt; (Symbol a :&lt;**&gt; l) : (Symbol b :&lt;**&gt; r) : ps
--                    GT -&gt; (Symbol b :&lt;**&gt; r) : (Symbol a :&lt;**&gt; l) : ps
--             step (Symbol a :&lt;**&gt; l) ps = (Symbol a :&lt;**&gt; l) : ps
--             step (Many ps) ps' = mergeMany (mergeMany ps ++ ps')
--   </pre>
--   
--   (Also not guaranteed to terminate on all cases; <tt>let a = a &lt;*
--   char <tt>a</tt> in optimize a</tt> diverges, but that parser never
--   terminates for any string.)
--   
--   Example of <tt>optimize</tt>:
--   
--   <pre>
--   tokens :: [String] -&gt; ProgramAlt ParserI String 
--   tokens = asum . map string
--   
--   example = [ "abactor", "abacus", "abaft", "abaisance", "abaissed", "abalone"
--             ]
--   
--   describe :: forall a. ProgramAlt ParserI a -&gt; Description
--   describe = eval . viewAlt
--       where eval :: forall x. ProgramViewAlt ParserI x -&gt; Description
--             eval (Pure _) = Ok
--             eval (Symbol c :&lt;**&gt; k) = c :&gt; (eval k)
--             eval (Many ps) = OneOf (map eval ps)
--   
--   data Description = Ok 
--                    | Char :&gt; Description
--                    | OneOf [Description] 
--                      deriving Show
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; describe $ tokens example
--   OneOf ['a' :&gt; ('b' :&gt; ('a' :&gt; ('c' :&gt; ('t' :&gt; ('o' :&gt; ('r' :&gt; Ok)))))),
--          OneOf ['a' :&gt; ('b' :&gt; ('a' :&gt; ('c' :&gt; ('u' :&gt; ('s' :&gt; Ok))))),
--                 OneOf ['a' :&gt; ('b' :&gt; ('a' :&gt; ('f' :&gt; ('t' :&gt; Ok)))),
--                        OneOf ['a' :&gt; ('b' :&gt; ('a' :&gt; ('i' :&gt; ('s' :&gt; ('a' :&gt; ('n' :&gt; ('c' :&gt; ('e' :&gt; Ok)))))))),
--                               OneOf ['a' :&gt; ('b' :&gt; ('a' :&gt; ('i' :&gt; ('s' :&gt; ('s' :&gt; ('e' :&gt; ('d' :&gt; Ok))))))),
--                                      'a' :&gt; ('b' :&gt; ('a' :&gt; ('l' :&gt; ('o' :&gt; ('n' :&gt; ('e' :&gt; Ok))))))]]]]]
--   
--   &gt;&gt;&gt; describe $ optimize (tokens example)
--   'a' :&gt; ('b' :&gt; ('a' :&gt; OneOf ['c' :&gt; OneOf ['t' :&gt; ('o' :&gt; ('r' :&gt; Ok)),'u' :&gt; ('s' :&gt; Ok)],
--                                 OneOf ['f' :&gt; ('t' :&gt; Ok),
--                                        OneOf ['i' :&gt; ('s' :&gt; OneOf ['a' :&gt; ('n' :&gt; ('c' :&gt; ('e' :&gt; Ok))),
--                                                                     's' :&gt; ('e' :&gt; ('d' :&gt; Ok))]),
--                                               'l' :&gt; ('o' :&gt; ('n' :&gt; ('e' :&gt; Ok)))]]]))
--   </pre>
module Control.Alternative.Operational
newtype ProgramAlt instr a
ProgramAlt :: Alt (Coyoneda instr) a -> ProgramAlt instr a

-- | Interpret the program as a free <a>Alternative</a> (<a>Alt</a>).
toAlt :: ProgramAlt instr a -> Alt (Coyoneda instr) a
interpretAlt :: Alternative f => (forall x. instr x -> f x) -> ProgramAlt instr a -> f a
fromProgramAlt :: (Operational instr f, Alternative f) => ProgramAlt instr a -> f a
data ProgramViewAlt instr a
Pure :: a -> ProgramViewAlt instr a
(:<**>) :: instr a -> ProgramViewAlt instr (a -> b) -> ProgramViewAlt instr b
Many :: [ProgramViewAlt instr a] -> ProgramViewAlt instr a
viewAlt :: ProgramAlt instr a -> ProgramViewAlt instr a
compileAlt :: ProgramViewAlt instr a -> ProgramAlt instr a
foldProgramViewAlt :: (forall x. instr x -> r -> r) -> r -> ([r] -> r) -> ProgramViewAlt instr a -> r
instance Functor (ProgramAlt instr)
instance Applicative (ProgramAlt instr)
instance Alternative (ProgramAlt instr)
instance Operational instr (ProgramAlt instr)

module Control.Monad.Trans.Operational
newtype ProgramT instr m a
ProgramT :: FreeT (Coyoneda instr) m a -> ProgramT instr m a
toFreeT :: ProgramT instr m a -> FreeT (Coyoneda instr) m a

-- | Given an intepretation of <tt>instr x</tt> as actions over a given
--   monad transformer <tt>t</tt> (transforming over an arbitrary monad
--   <tt>m</tt>), interpret <tt><a>ProgramT</a> instr</tt> as a monad
--   transformer <tt>t</tt>. Read that sentence and the type carefully: the
--   instruction interpretation can pick its choice of <tt>t</tt> but not
--   <tt>m</tt>.
interpretT :: (MonadTrans t, Functor (t m), Monad (t m), Functor m, Monad m) => (forall n x. (Functor n, Monad n) => instr x -> t n x) -> ProgramT instr m a -> t m a

-- | Given an intepretation of <tt>instr x</tt> as actions over a given
--   transformed monad <tt>t m</tt>, interpret <tt><a>ProgramT</a>
--   instr</tt> as a transformed monad <tt>t m</tt>. Read that sentence and
--   the type carefully: the instruction interpretation can pick its choice
--   of both <tt>t</tt> and <tt>m</tt>.
interpretTM :: (MonadTrans t, Functor (t m), Monad (t m), Monad m) => (forall x. instr x -> t m x) -> ProgramT instr m a -> t m a
interpretM :: (Functor m, Monad m) => (forall x. instr x -> m x) -> ProgramT instr m a -> m a
data ProgramViewT instr m a
Return :: a -> ProgramViewT instr m a
(:>>=) :: instr a -> (a -> ProgramT instr m b) -> ProgramViewT instr m b
viewT :: Monad m => ProgramT instr m a -> m (ProgramViewT instr m a)
instance Monad m => Functor (ProgramT instr m)
instance Monad m => Applicative (ProgramT instr m)
instance Monad m => Monad (ProgramT instr m)
instance MonadTrans (ProgramT instr)
instance Monad m => Operational instr (ProgramT instr m)


-- | A reconstruction of the <tt>operational</tt> package in terms of the
--   <a>FreeT</a> monad transformer.
--   
--   This module is meant to be a drop-in replacement for its counterpart
--   in the <tt>operational</tt> package. Some of the implementation
--   choices reflect that:
--   
--   <ul>
--   <li><tt><a>Program</a> instr</tt> and <tt><a>ProgramView</a>
--   instr</tt> are type synonyms for <tt><a>ProgramT</a> instr m</tt> and
--   <tt><a>ProgramViewT</a> instr m</tt>, just as in <tt>operational</tt>.
--   If you don't care for that, <a>Control.Monad.Operational.Simple</a>
--   implements them directly in terms of <a>Free</a>.</li>
--   </ul>
--   
--   The <a>ProgramT</a> and <a>ProgramViewT</a> types and operations are
--   reexported from <a>Control.Monad.Trans.Operational</a>.
module Control.Monad.Operational

-- | Drop-in replacement for <tt>operational</tt>'s type synonym.
type Program instr = ProgramT instr Identity

-- | The <a>Free</a> monad action for a <a>Program</a>.
toFree :: Program instr a -> Free (Coyoneda instr) a

-- | Lift a <a>Program</a> into any <a>Operational</a> type at least as
--   strong as <a>Monad</a>.
fromProgram :: (Operational instr m, Functor m, Monad m) => Program instr a -> m a

-- | Lift a <a>Program</a> into a <a>ProgramT</a>. Really the same as
--   <a>fromProgram</a>, but with a more restricted type; this function is
--   a drop-in replacement for the eponymous function in
--   <tt>operational</tt>.
liftProgram :: Monad m => Program instr a -> ProgramT instr m a

-- | Interpret a <a>Program</a> by interpreting each instruction as a
--   monadic action. Unlike <a>interpretWithMonad</a>, this soes not use
--   <a>view</a> nor <a>ProgramView</a>.
--   
--   This function is not a drop-in replacement for
--   <a>interpretWithMonad</a> because it has an extra <tt>Functor m</tt>
--   constraint.
interpret :: (Functor m, Monad m) => (forall x. instr x -> m x) -> Program instr a -> m a

-- | Drop-in replacement for the eponymous function in the
--   <tt>operational</tt> package. This is like <a>interpret</a> but with a
--   slightly broader type, and the same implementation as in
--   <tt>operational</tt> (in terms of <a>view</a>).
interpretWithMonad :: Monad m => (forall x. instr x -> m x) -> Program instr a -> m a

-- | Drop-in replacement for <tt>operational</tt>'s eponymous type synonym.
type ProgramView instr = ProgramViewT instr Identity

-- | Drop-in replacement for <tt>operational</tt>'s function.
view :: Program instr a -> ProgramView instr a


-- | A simpler, non-transformer version of this package's
--   <a>Control.Monad.Operational</a>'s <a>Program</a> type, using
--   <a>Free</a> directly.
module Control.Monad.Operational.Simple
newtype Program instr a
Program :: Free (Coyoneda instr) a -> Program instr a

-- | Intepret the program as a <a>Free</a> monad.
toFree :: Program instr a -> Free (Coyoneda instr) a

-- | Interpret a <a>Program</a> by translating each instruction to a
--   <a>Monad</a> action. Does not use <a>view</a>.
interpret :: (Functor m, Monad m) => (forall x. instr x -> m x) -> Program instr a -> m a

-- | Lift a <a>Program</a> to any <a>Operational</a> instance at least as
--   powerful as <a>Monad</a>.
fromProgram :: (Operational instr m, Functor m, Monad m) => Program instr a -> m a
data ProgramView instr a
Return :: a -> ProgramView instr a
(:>>=) :: instr a -> (a -> Program instr b) -> ProgramView instr b
view :: Program instr a -> ProgramView instr a
instance Functor (Program instr)
instance Applicative (Program instr)
instance Monad (Program instr)
instance Operational instr (Program instr)


-- | <tt>operational</tt>-style programs for <a>MonadPlus</a>. See the
--   documentation for <a>Control.Applicative.Operational</a> and
--   <a>Control.Monad.Operational</a> for guidance on how to use this
--   module.
module Control.MonadPlus.Operational
newtype ProgramP instr a
ProgramP :: Free (Coyoneda instr) a -> ProgramP instr a

-- | Interpret the program as a free <a>MonadPlus</a>.
toFree :: ProgramP instr a -> Free (Coyoneda instr) a
interpretP :: (Functor m, MonadPlus m) => (forall x. instr x -> m x) -> ProgramP instr a -> m a
fromProgramP :: (Operational instr m, Functor m, MonadPlus m) => ProgramP instr a -> m a
data ProgramViewP instr a
Return :: a -> ProgramViewP instr a
(:>>=) :: instr a -> (a -> ProgramP instr b) -> ProgramViewP instr b
MPlus :: [ProgramViewP instr a] -> ProgramViewP instr a
view :: ProgramP instr a -> ProgramViewP instr a
instance Functor (ProgramP instr)
instance Applicative (ProgramP instr)
instance Alternative (ProgramP instr)
instance Monad (ProgramP instr)
instance MonadPlus (ProgramP instr)
instance Operational instr (ProgramP instr)
