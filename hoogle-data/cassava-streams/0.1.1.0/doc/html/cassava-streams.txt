-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | io-streams interface for the cassava CSV library.
--   
@package cassava-streams
@version 0.1.1.0


-- | This module exports functions which can be used to read instances of
--   the cassava classes <tt>FromRecord</tt> and <tt>FromNamedRecord</tt>
--   from an io-streams <tt>InputStream ByteString</tt>.
--   
--   It also exports functions which can write instances of
--   <tt>ToRecord</tt> and <tt>ToNamedRecord</tt> to an io-streams
--   <tt>OutputStream ByteString</tt>.
--   
--   See the <a>System.IO.Streams.Csv.Tutorial</a> module for a simple
--   tutorial.
module System.IO.Streams.Csv

-- | Exception thrown when stream decoding cannot continue due to an error.
data StreamDecodingError
StreamDecodingError :: String -> StreamDecodingError

-- | Create an <tt>InputStream</tt> which decodes CSV records from the
--   given upstream data source.
--   
--   Equivalent to <tt>decodeStreamWith defaultDecodeOptions</tt>.
decodeStream :: FromRecord a => HasHeader -> InputStream ByteString -> IO (InputStream (Either String a))

-- | Create an <tt>InputStream</tt> which decodes CSV records from the
--   given upstream data source.
decodeStreamWith :: FromRecord a => DecodeOptions -> HasHeader -> InputStream ByteString -> IO (InputStream (Either String a))

-- | Create an <tt>InputStream</tt> which decodes CSV records from the
--   given upstream data source. Data should be preceded by a header.
--   
--   Equivalent to <tt>decodeStreamByNameWith defaultDecodeOptions</tt>.
decodeStreamByName :: FromNamedRecord a => InputStream ByteString -> IO (InputStream (Either String a))

-- | Create an <tt>InputStream</tt> which decodes CSV records from the
--   given upstream data source. Data should be preceded by a header.
decodeStreamByNameWith :: FromNamedRecord a => DecodeOptions -> InputStream ByteString -> IO (InputStream (Either String a))

-- | Creates a new <tt>InputStream</tt> which only sends valid CSV records
--   downstream. The first invalid record will throw an exception.
onlyValidRecords :: InputStream (Either String a) -> IO (InputStream a)

-- | Create a new <tt>OutputStream</tt> that can be fed <tt>ToRecord</tt>
--   values which are converted to CSV. The records are encoded into
--   <tt>ByteString</tt>s and passed on to the given downstream
--   <tt>OutputStream</tt>.
--   
--   Equivalent to <tt>encodeStreamWith defaultEncodeOptions</tt>.
encodeStream :: ToRecord a => OutputStream ByteString -> IO (OutputStream a)

-- | Create a new <tt>OutputStream</tt> that can be fed <tt>ToRecord</tt>
--   values which are converted to CSV. The records are encoded into
--   <tt>ByteString</tt>s and passed on to the given downstream
--   <tt>OutputStream</tt>.
encodeStreamWith :: ToRecord a => EncodeOptions -> OutputStream ByteString -> IO (OutputStream a)

-- | Create a new <tt>OutputStream</tt> which can be fed
--   <tt>ToNamedRecord</tt> values that will be converted into CSV. The
--   records are encoded into <tt>ByteString</tt>s and passed on to the
--   given downstream <tt>OutputStream</tt>.
--   
--   Equivalent to <tt>encodeStreamByNameWith defaultEncodeOptions</tt>.
encodeStreamByName :: ToNamedRecord a => Header -> OutputStream ByteString -> IO (OutputStream a)

-- | Create a new <tt>OutputStream</tt> which can be fed
--   <tt>ToNamedRecord</tt> values that will be converted into CSV. The
--   records are encoded into <tt>ByteString</tt>s and passed on to the
--   given downstream <tt>OutputStream</tt>.
encodeStreamByNameWith :: ToNamedRecord a => EncodeOptions -> Header -> OutputStream ByteString -> IO (OutputStream a)


-- | A simple tutorial on using the cassava-streams library to glue
--   together cassava and io-streams.
--   
--   Note: if you're reading this on Hackage or in Haddock then you should
--   switch to source view with the "Source" link at the top of this page
--   or open this file in your favorite text editor.
module System.IO.Streams.Csv.Tutorial

-- | A to-do item.
data Item
Item :: String -> TState -> Maybe Double -> Item

-- | Title.
title :: Item -> String

-- | State.
state :: Item -> TState

-- | Seconds taken to complete.
time :: Item -> Maybe Double

-- | Possible states for a to-do item.
data TState

-- | Item needs to be completed.
Todo :: TState

-- | Item has been finished.
Done :: TState

-- | The <tt>onlyTodo</tt> function reads to-do <a>Item</a>s from the given
--   input handle (in CSV format) and writes them back to the output handle
--   (also in CSV format), but only if the items are in the <tt>Todo</tt>
--   state. In another words, the CSV data is filtered so that the output
--   handle only receives to-do <a>Item</a>s which haven't been completed.
--   
--   The io-streams <tt>handleToInputStream</tt> function is used to create
--   an <tt>InputStream ByteString</tt> stream from the given input handle.
--   
--   That stream is then given to the cassava-streams function
--   <a>decodeStreamByName</a> which converts the <tt>InputStream
--   ByteString</tt> stream into an <tt>InputStream Item</tt> stream.
--   
--   Notice that the cassava-streams function <a>onlyValidRecords</a> is
--   used to transform the decoding stream into one that only produces
--   valid records. Any records which fail type conversion (via
--   <tt>FromNamedRecord</tt> or <tt>FromRecord</tt>) will not escape from
--   <a>onlyValidRecords</a> but instead will throw an exception.
--   
--   Finally the io-streams <tt>filter</tt> function is used to filter the
--   input stream so that it only produces to-do items which haven't been
--   completed.
onlyTodo :: Handle -> Handle -> IO ()

-- | The <tt>markDone</tt> function will read to-do items from the given
--   input handle and mark any matching items as <tt>Done</tt>. All to-do
--   items are written to the given output handle.
markDone :: String -> Handle -> Handle -> IO ()
instance Show TState
instance Eq TState
instance Show Item
instance Eq Item
instance ToField TState
instance FromField TState
instance ToNamedRecord Item
instance FromNamedRecord Item
