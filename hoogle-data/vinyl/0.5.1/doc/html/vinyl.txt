-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Extensible Records
--   
--   Extensible records for Haskell with lenses using modern GHC features.
@package vinyl
@version 0.5.1

module Data.Vinyl.TypeLevel

-- | A mere approximation of the natural numbers. And their image as lifted
--   by <tt>-XDataKinds</tt> corresponds to the actual natural numbers.
data Nat
Z :: Nat
S :: !Nat -> Nat

-- | A partial relation that gives the index of a value in a list.

-- | A partial relation that gives the indices of a sublist in a larger
--   list.

-- | A constraint-former which applies to every field in a record.

-- | Append for type-level lists.

module Data.Vinyl.Functor
newtype Identity a
Identity :: a -> Identity a
getIdentity :: Identity a -> a
data Thunk a
Thunk :: a -> Thunk a
getThunk :: Thunk a -> a
newtype Lift (op :: l -> l' -> *) (f :: k -> l) (g :: k -> l') (x :: k)
Lift :: op (f x) (g x) -> Lift
getLift :: Lift -> op (f x) (g x)
newtype Compose (f :: l -> *) (g :: k -> l) (x :: k)
Compose :: f (g x) -> Compose
getCompose :: Compose -> f (g x)
type (:.) f g = Compose f g
newtype Const (a :: *) (b :: k)
Const :: a -> Const
getConst :: Const -> a
instance Functor Identity
instance Foldable Identity
instance Traversable Identity
instance Storable a => Storable (Identity a)
instance Functor Thunk
instance Foldable Thunk
instance Traversable Thunk
instance Storable (f (g x)) => Storable (Compose f g x)
instance Functor (Const a)
instance Foldable (Const a)
instance Traversable (Const a)
instance Storable a => Storable (Const a b)
instance (Applicative f, Applicative g) => Applicative (Lift (,) f g)
instance (Functor f, Functor g) => Functor (Lift Either f g)
instance (Functor f, Functor g) => Functor (Lift (,) f g)
instance Show a => Show (Thunk a)
instance Monad Thunk
instance Applicative Thunk
instance Show a => Show (Identity a)
instance Monad Identity
instance Applicative Identity
instance (Applicative f, Applicative g) => Applicative (Compose f g)
instance (Traversable f, Traversable g) => Traversable (Compose f g)
instance (Foldable f, Foldable g) => Foldable (Compose f g)
instance (Functor f, Functor g) => Functor (Compose f g)

module Data.Vinyl.Core

-- | A record is parameterized by a universe <tt>u</tt>, an interpretation
--   <tt>f</tt> and a list of rows <tt>rs</tt>. The labels or indices of
--   the record are given by inhabitants of the kind <tt>u</tt>; the type
--   of values at any label <tt>r :: u</tt> is given by its interpretation
--   <tt>f r :: *</tt>.
data Rec :: (u -> *) -> [u] -> *
RNil :: Rec f []
(:&) :: !(f r) -> !(Rec f rs) -> Rec f (r : rs)

-- | Two records may be pasted together.
rappend :: Rec f as -> Rec f bs -> Rec f (as ++ bs)

-- | A shorthand for <a>rappend</a>.
(<+>) :: Rec f as -> Rec f bs -> Rec f (as ++ bs)

-- | <a>Rec</a> <tt>_ rs</tt> with labels in kind <tt>u</tt> gives rise to
--   a functor <tt>Hask^u -&gt; Hask</tt>; that is, a natural
--   transformation between two interpretation functors <tt>f,g</tt> may be
--   used to transport a value from <a>Rec</a> <tt>f rs</tt> to <a>Rec</a>
--   <tt>g rs</tt>.
rmap :: (forall x. f x -> g x) -> Rec f rs -> Rec g rs

-- | A shorthand for <a>rmap</a>.
(<<$>>) :: (forall x. f x -> g x) -> Rec f rs -> Rec g rs

-- | An inverted shorthand for <a>rmap</a>.
(<<&>>) :: Rec f rs -> (forall x. f x -> g x) -> Rec g rs

-- | A record of components <tt>f r -&gt; g r</tt> may be applied to a
--   record of <tt>f</tt> to get a record of <tt>g</tt>.
rapply :: Rec (Lift (->) f g) rs -> Rec f rs -> Rec g rs

-- | A shorthand for <a>rapply</a>.
(<<*>>) :: Rec (Lift (->) f g) rs -> Rec f rs -> Rec g rs

-- | Given a section of some functor, records in that functor of any size
--   are inhabited.
class RecApplicative rs
rpure :: RecApplicative rs => (forall x. f x) -> Rec f rs

-- | A record may be traversed with respect to its interpretation functor.
--   This can be used to yank (some or all) effects from the fields of the
--   record to the outside of the record.
rtraverse :: Applicative h => (forall x. f x -> h (g x)) -> Rec f rs -> h (Rec g rs)

-- | A record with uniform fields may be turned into a list.
recordToList :: Rec (Const a) rs -> [a]

-- | Wrap up a value with a capability given by its type
data Dict c a
Dict :: a -> Dict c a

-- | Sometimes we may know something for <i>all</i> fields of a record, but
--   when you expect to be able to <i>each</i> of the fields, you are then
--   out of luck. Surely given <tt>∀x:u.φ(x)</tt> we should be able to
--   recover <tt>x:u ⊢ φ(x)</tt>! Sadly, the constraint solver is not quite
--   smart enough to realize this and we must make it patently obvious by
--   reifying the constraint pointwise with proof.
reifyConstraint :: RecAll f rs c => proxy c -> Rec f rs -> Rec (Dict c :. f) rs

-- | Records may be shown insofar as their points may be shown.
--   <a>reifyConstraint</a> is used to great effect here.
instance (Storable (f r), Storable (Rec f rs)) => Storable (Rec f (r : rs))
instance Storable (Rec f '[])
instance (Eq (f r), Eq (Rec f rs)) => Eq (Rec f (r : rs))
instance Eq (Rec f '[])
instance (Monoid (f r), Monoid (Rec f rs)) => Monoid (Rec f (r : rs))
instance Monoid (Rec f '[])
instance (RecAll f rs Show) => Show (Rec f rs)
instance RecApplicative rs => RecApplicative (r : rs)
instance RecApplicative '[]

module Data.Vinyl.Derived
data ElField (field :: (Symbol, *))
Field :: !t -> ElField '(s, t)
type FieldRec = Rec ElField
type HList = Rec Identity
type LazyHList = Rec Thunk

-- | Get the data payload of an <a>ElField</a>.
getField :: ElField '(s, t) -> t

-- | <a>ElField</a> is isomorphic to a functor something like <tt>Compose
--   ElField ('(,) s)</tt>.
fieldMap :: (a -> b) -> ElField '(s, a) -> ElField '(s, b)

-- | Lens for an <tt>ElField'</tt>s data payload.
rfield :: Functor f => (a -> f b) -> ElField '(s, a) -> f (ElField '(s, b))

-- | Shorthand for a <a>FieldRec</a> with a single field.
(=:) :: KnownSymbol s => proxy '(s, a) -> a -> FieldRec '['(s, a)]

-- | A proxy for field types.
data SField (field :: k)
SField :: SField
instance Ord t => Ord (ElField '(s, t))
instance Eq t => Eq (ElField '(s, t))
instance (KnownSymbol s, Storable t) => Storable (ElField '(s, t))
instance KnownSymbol s => Show (SField '(s, t))
instance Ord (SField a)
instance Eq (SField a)
instance Show t => Show (ElField '(s, t))

module Data.Vinyl.Lens

-- | The presence of a field in a record is witnessed by a lens into its
--   value. The third parameter to <a>RElem</a>, <tt>i</tt>, is there to
--   help the constraint solver realize that this is a decidable predicate
--   with respect to the judgemental equality in <tt>k</tt>.
class i ~ RIndex r rs => RElem (r :: k) (rs :: [k]) (i :: Nat) where rget k = getConst . rlens k Const rput y = getIdentity . rlens Proxy (\ _ -> Identity y)
rlens :: (RElem r rs i, Functor g) => sing r -> (f r -> g (f r)) -> Rec f rs -> g (Rec f rs)
rget :: RElem r rs i => sing r -> Rec f rs -> f r
rput :: RElem r rs i => f r -> Rec f rs -> Rec f rs

-- | If one field set is a subset another, then a lens of from the latter's
--   record to the former's is evident. That is, we can either cast a
--   larger record to a smaller one, or we may replace the values in a
--   slice of a record.
class is ~ RImage rs ss => RSubset (rs :: [k]) (ss :: [k]) is where rcast = getConst . rsubset Const rreplace rs = getIdentity . rsubset (\ _ -> Identity rs)
rsubset :: (RSubset rs ss is, Functor g) => (Rec f rs -> g (Rec f rs)) -> Rec f ss -> g (Rec f ss)
rcast :: RSubset rs ss is => Rec f ss -> Rec f rs
rreplace :: RSubset rs ss is => Rec f rs -> Rec f ss -> Rec f ss

-- | Two record types are equivalent when they are subtypes of each other.
type REquivalent rs ss is js = (RSubset rs ss is, RSubset ss rs js)

-- | A shorthand for <a>RElem</a> which supplies its index.
type (∈) r rs = RElem r rs (RIndex r rs)

-- | A shorthand for <a>RSubset</a> which supplies its image.
type (⊆) rs ss = RSubset rs ss (RImage rs ss)

-- | A shorthand for <a>REquivalent</a> which supplies its images.
type (≅) rs ss = REquivalent rs ss (RImage rs ss) (RImage ss rs)

-- | A non-unicode equivalent of <tt>(⊆)</tt>.
type (<:) rs ss = rs ⊆ ss

-- | A non-unicode equivalent of <tt>(≅)</tt>.
type (:~:) rs ss = rs ≅ ss
instance (RElem r ss i, RSubset rs ss is) => RSubset (r : rs) ss (i : is)
instance RSubset '[] ss '[]
instance (RIndex r (s : rs) ~ 'S i, RElem r rs i) => RElem r (s : rs) ('S i)
instance RElem r (r : rs) 'Z

module Data.Vinyl.Notation

-- | A shorthand for <a>rappend</a>.
(<+>) :: Rec f as -> Rec f bs -> Rec f (as ++ bs)

-- | A shorthand for <a>rapply</a>.
(<<*>>) :: Rec (Lift (->) f g) rs -> Rec f rs -> Rec g rs

-- | A shorthand for <a>rmap</a>.
(<<$>>) :: (forall x. f x -> g x) -> Rec f rs -> Rec g rs

-- | An inverted shorthand for <a>rmap</a>.
(<<&>>) :: Rec f rs -> (forall x. f x -> g x) -> Rec g rs

-- | A record is parameterized by a universe <tt>u</tt>, an interpretation
--   <tt>f</tt> and a list of rows <tt>rs</tt>. The labels or indices of
--   the record are given by inhabitants of the kind <tt>u</tt>; the type
--   of values at any label <tt>r :: u</tt> is given by its interpretation
--   <tt>f r :: *</tt>.
data Rec :: (u -> *) -> [u] -> *
(:&) :: !(f r) -> !(Rec f rs) -> Rec f (r : rs)

-- | A shorthand for <a>RElem</a> which supplies its index.
type (∈) r rs = RElem r rs (RIndex r rs)

-- | A shorthand for <a>RSubset</a> which supplies its image.
type (⊆) rs ss = RSubset rs ss (RImage rs ss)

-- | A shorthand for <a>REquivalent</a> which supplies its images.
type (≅) rs ss = REquivalent rs ss (RImage rs ss) (RImage ss rs)

-- | A non-unicode equivalent of <tt>(⊆)</tt>.
type (<:) rs ss = rs ⊆ ss

-- | A non-unicode equivalent of <tt>(≅)</tt>.
type (:~:) rs ss = rs ≅ ss

module Data.Vinyl
