-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Data Parallel Haskell lifted array combinators.
--   
--   This package provides the following: nested arrays and the primitive
--   operators that work on them (PA functions); the lifted array
--   combinators that the vectoriser introduces (PP functions); the user
--   facing library functions that work on [::] style arrays (P functions).
--   This implementation directly encodes sharing between array segments,
--   and avoids the copying that dph-lifted-copy would otherwise do. Use
--   this version for production code.
@package dph-lifted-vseg
@version 0.7.0.1

module Data.Array.Parallel.Trace
data Trace
Trace :: Op -> Trace
data Op
OpSingleton :: TypeRep -> Op
traceElemType :: Op -> TypeRep
OpSingletonL :: TypeRep -> Int -> Op
traceElemType :: Op -> TypeRep
traceContext :: Op -> Int
OpReplicate :: TypeRep -> Int -> Op
traceElemType :: Op -> TypeRep
traceCount :: Op -> Int
OpReplicateL :: TypeRep -> Int -> Op
traceElemType :: Op -> TypeRep
traceContext :: Op -> Int
OpReplicateS :: TypeRep -> Int -> Op
traceElemType :: Op -> TypeRep
traceCount :: Op -> Int
OpAppend :: TypeRep -> Int -> Int -> Int -> Op
traceElemType :: Op -> TypeRep
traceSrc1Length :: Op -> Int
traceSrc2Length :: Op -> Int
traceDstLength :: Op -> Int
OpAppendL :: TypeRep -> Int -> Op
traceElemType :: Op -> TypeRep
traceContext :: Op -> Int
OpConcat :: TypeRep -> Int -> Int -> Op
traceElemType :: Op -> TypeRep
traceSrcLength :: Op -> Int
traceDstLength :: Op -> Int
OpConcatL :: TypeRep -> Int -> Op
traceElemType :: Op -> TypeRep
traceContext :: Op -> Int
OpUnconcat :: TypeRep -> Int -> Op
traceElemType :: Op -> TypeRep
traceCount :: Op -> Int
OpLength :: Op
OpLengthL :: Int -> Op
traceContext :: Op -> Int
OpIndex :: Op
OpIndexL :: Int -> Op
traceContext :: Op -> Int
OpExtract :: Int -> Op
traceDstLength :: Op -> Int
OpExtractS :: Int -> Op
traceDstLength :: Op -> Int
OpSlice :: Int -> Op
traceDstLength :: Op -> Int
OpSliceL :: Int -> Op
traceContext :: Op -> Int
OpPack :: Int -> Op
traceDstLength :: Op -> Int
OpPackL :: Int -> Op
traceContext :: Op -> Int
OpPackByTag :: Int -> Op
traceDstLength :: Op -> Int
OpCombine2 :: Int -> Op
traceDstLength :: Op -> Int
OpZip :: Int -> Op
traceLength :: Op -> Int
OpZipL :: Int -> Op
traceLength :: Op -> Int
OpUnzip :: Int -> Op
traceLength :: Op -> Int
OpUnzipL :: Int -> Op
traceLength :: Op -> Int
traceOp :: Op -> a -> a
instance Show Op
instance Show Trace


-- | Parallel array data.
--   
--   This is an interface onto the internal array types and operators
--   defined by the library, and should not normally be used by client
--   programs.
module Data.Array.Parallel.PArray.PData

-- | A parallel array consisting of a length field and some array data.
data PArray a
PArray :: Int# -> (PData a) -> PArray a

-- | A chunk of parallel array data with a linear index space.
--   
--   In contrast to a <a>PArray</a>, a <a>PData</a> may not have a fixed
--   length, and its elements may have been converted to a generic
--   representation. Whereas a <a>PArray</a> is the "user view" of an
--   array, a <a>PData</a> is a type only used internally to the library.

-- | Several chunks of parallel array data.
--   
--   Although a <a>PArray</a> of atomic type such as <a>Int</a> only
--   contains a single <a>PData</a> chunk, nested arrays may contain
--   several, which we wrap up into a <a>PDatas</a>.

-- | Take the length field of a <a>PArray</a>.
length :: PArray a -> Int

-- | Take the <a>PData</a> of a <a>PArray</a>.
takeData :: PArray a -> PData a

-- | The PR (Parallel Representation) class holds primitive array operators
--   that work on our generic representation of data.
--   
--   There are instances for all atomic types such as <a>Int</a> and
--   <a>Double</a>, tuples, nested arrays `PData (PArray a)` and for the
--   generic types we used to represent user level algebraic data,
--   <tt>Sum2</tt> and <tt>Wrap</tt> and <tt>Void</tt>. All array data is
--   converted to this fixed set of types.
--   
--   TODO: refactor to change PData Int to U.Array Int, there's not need to
--   wrap an extra PData constructor around these arrays, and the type of
--   bpermute is different than the others.
class PR a where extractvsPR pdatas vsegd = extractssPR pdatas (unsafeDemoteToSSegdOfVSegd vsegd)
validPR :: PR a => PData a -> Bool
nfPR :: PR a => PData a -> ()
similarPR :: PR a => a -> a -> Bool
coversPR :: PR a => Bool -> PData a -> Int -> Bool
pprpPR :: PR a => a -> Doc
pprpDataPR :: PR a => PData a -> Doc
typeRepPR :: PR a => a -> TypeRep
typeRepDataPR :: PR a => PData a -> TypeRep
typeRepDatasPR :: PR a => PDatas a -> TypeRep
emptyPR :: PR a => PData a
replicatePR :: PR a => Int -> a -> PData a
replicatesPR :: PR a => Segd -> PData a -> PData a
appendPR :: PR a => PData a -> PData a -> PData a
appendvsPR :: PR a => Segd -> VSegd -> PDatas a -> VSegd -> PDatas a -> PData a
lengthPR :: PR a => PData a -> Int
indexPR :: PR a => PData a -> Int -> a
indexsPR :: PR a => PDatas a -> Array (Int, Int) -> PData a
indexvsPR :: PR a => PDatas a -> VSegd -> Array (Int, Int) -> PData a
extractPR :: PR a => PData a -> Int -> Int -> PData a
extractssPR :: PR a => PDatas a -> SSegd -> PData a
extractvsPR :: PR a => PDatas a -> VSegd -> PData a
packByTagPR :: PR a => PData a -> Array Tag -> Tag -> PData a
combine2PR :: PR a => Sel2 -> PData a -> PData a -> PData a
fromVectorPR :: PR a => Vector a -> PData a
toVectorPR :: PR a => PData a -> Vector a
emptydPR :: PR a => PDatas a
singletondPR :: PR a => PData a -> PDatas a
lengthdPR :: PR a => PDatas a -> Int
indexdPR :: PR a => PDatas a -> Int -> PData a
appenddPR :: PR a => PDatas a -> PDatas a -> PDatas a
fromVectordPR :: PR a => Vector (PData a) -> PDatas a
toVectordPR :: PR a => PDatas a -> Vector (PData a)

-- | Convert a list to a PData.
fromListPR :: PR a => [a] -> PData a

-- | Convert a PData to a list.
toListPR :: PR a => PData a -> [a]

-- | A chunk of parallel array data with a linear index space.
--   
--   In contrast to a <a>PArray</a>, a <a>PData</a> may not have a fixed
--   length, and its elements may have been converted to a generic
--   representation. Whereas a <a>PArray</a> is the "user view" of an
--   array, a <a>PData</a> is a type only used internally to the library.

-- | Several chunks of parallel array data.
--   
--   Although a <a>PArray</a> of atomic type such as <a>Int</a> only
--   contains a single <a>PData</a> chunk, nested arrays may contain
--   several, which we wrap up into a <a>PDatas</a>.

-- | Construct a nested array.
mkPNested :: PR a => VSegd -> PDatas a -> Segd -> PData a -> PData (PArray a)

-- | Concatenate a nested array.
concatPR :: PR a => PData (PArray a) -> PData a

-- | Lifted concatenation.
--   
--   Concatenate all the arrays in a triply nested array.
concatlPR :: PR a => PData (PArray (PArray a)) -> PData (PArray a)

-- | Flatten a nested array, yielding a plain segment descriptor and
--   concatenated data.
flattenPR :: PR a => PData (PArray a) -> (Segd, PData a)

-- | Take the segment descriptor from a nested array and demote it to a
--   plain Segd.
takeSegdPD :: PData (PArray a) -> Segd

-- | Build a nested array given a single flat data vector, and a template
--   nested array that defines the segmentation.
unconcatPR :: PR b => PData (PArray a) -> PData b -> PData (PArray b)

-- | Lifted append. Both arrays must contain the same number of elements.
appendlPR :: PR a => PData (PArray a) -> PData (PArray a) -> PData (PArray a)

-- | O(len result). Lifted indexing
indexlPR :: PR a => PData (PArray a) -> PData Int -> PData a

-- | Extract some slices from some arrays.
--   
--   All three parameters must have the same length, and we take one slice
--   from each of the source arrays.
slicelPR :: PR a => PData Int -> PData Int -> PData (PArray a) -> PData (PArray a)

-- | Wrapper for extracts that is NOT INLINED.
--   
--   This is experimental, used to initialise the pnested_flat field of a
--   nested array. It<tt>s</tt> marked at NOINLINE to avoid code explosion.
extractvs_delay :: PR a => PDatas a -> VSegd -> PData a

-- | A chunk of parallel array data with a linear index space.
--   
--   In contrast to a <a>PArray</a>, a <a>PData</a> may not have a fixed
--   length, and its elements may have been converted to a generic
--   representation. Whereas a <a>PArray</a> is the "user view" of an
--   array, a <a>PData</a> is a type only used internally to the library.

-- | Several chunks of parallel array data.
--   
--   Although a <a>PArray</a> of atomic type such as <a>Int</a> only
--   contains a single <a>PData</a> chunk, nested arrays may contain
--   several, which we wrap up into a <a>PDatas</a>.

-- | O(1). Zip a pair of arrays into an array of pairs.
zipPD :: PData a -> PData b -> PData (a, b)

-- | Lifted zip.
ziplPR :: (PR a, PR b) => PData (PArray a) -> PData (PArray b) -> PData (PArray (a, b))

-- | O(1). Unzip an array of pairs into a pair of arrays.
unzipPD :: PData (a, b) -> (PData a, PData b)

-- | Lifted unzip.
unziplPD :: PData (PArray (a, b)) -> PData (PArray a, PArray b)

-- | A chunk of parallel array data with a linear index space.
--   
--   In contrast to a <a>PArray</a>, a <a>PData</a> may not have a fixed
--   length, and its elements may have been converted to a generic
--   representation. Whereas a <a>PArray</a> is the "user view" of an
--   array, a <a>PData</a> is a type only used internally to the library.

-- | Several chunks of parallel array data.
--   
--   Although a <a>PArray</a> of atomic type such as <a>Int</a> only
--   contains a single <a>PData</a> chunk, nested arrays may contain
--   several, which we wrap up into a <a>PDatas</a>.

-- | O(1). Zip a pair of arrays into an array of pairs.
zip3PD :: PData a -> PData b -> PData c -> PData (a, b, c)

-- | A chunk of parallel array data with a linear index space.
--   
--   In contrast to a <a>PArray</a>, a <a>PData</a> may not have a fixed
--   length, and its elements may have been converted to a generic
--   representation. Whereas a <a>PArray</a> is the "user view" of an
--   array, a <a>PData</a> is a type only used internally to the library.

-- | Several chunks of parallel array data.
--   
--   Although a <a>PArray</a> of atomic type such as <a>Int</a> only
--   contains a single <a>PData</a> chunk, nested arrays may contain
--   several, which we wrap up into a <a>PDatas</a>.

-- | O(1). Zip a pair of arrays into an array of pairs.
zip4PD :: PData a -> PData b -> PData c -> PData d -> PData (a, b, c, d)

-- | A chunk of parallel array data with a linear index space.
--   
--   In contrast to a <a>PArray</a>, a <a>PData</a> may not have a fixed
--   length, and its elements may have been converted to a generic
--   representation. Whereas a <a>PArray</a> is the "user view" of an
--   array, a <a>PData</a> is a type only used internally to the library.

-- | Several chunks of parallel array data.
--   
--   Although a <a>PArray</a> of atomic type such as <a>Int</a> only
--   contains a single <a>PData</a> chunk, nested arrays may contain
--   several, which we wrap up into a <a>PDatas</a>.

-- | O(1). Zip a pair of arrays into an array of pairs.
zip5PD :: PData a -> PData b -> PData c -> PData d -> PData e -> PData (a, b, c, d, e)

-- | A chunk of parallel array data with a linear index space.
--   
--   In contrast to a <a>PArray</a>, a <a>PData</a> may not have a fixed
--   length, and its elements may have been converted to a generic
--   representation. Whereas a <a>PArray</a> is the "user view" of an
--   array, a <a>PData</a> is a type only used internally to the library.

-- | Several chunks of parallel array data.
--   
--   Although a <a>PArray</a> of atomic type such as <a>Int</a> only
--   contains a single <a>PData</a> chunk, nested arrays may contain
--   several, which we wrap up into a <a>PDatas</a>.

-- | O(1). Zip a pair of arrays into an array of pairs.
zip6PD :: PData a -> PData b -> PData c -> PData d -> PData e -> PData f -> PData (a, b, c, d, e, f)


-- | Defines the <a>PRepr</a> family and <a>PA</a> class that converts
--   between the user level element types and our generic representation.
--   Apart from <a>unpackPA</a>, the <a>PA</a> wrapper functions defined
--   here all have equivalent <a>PR</a> versions in
--   <a>Data.Array.Parallel.PArray.PData</a>, so see there for
--   documentation.
module Data.Array.Parallel.PArray.PRepr

-- | Family of Representable types. These are the types that we know how to
--   represent generically. <a>PRepr</a> takes an arbitrary type and
--   produces the generic type we use to represent it.
--   
--   Instances for simple types are defined by the library. For algebraic
--   types, it's up to the vectoriser/client module to create a suitable
--   instance.

-- | A PA dictionary contains the functions that we use to convert a
--   representable type to and from its generic representation.
--   
--   The conversions methods should all be O(1).
class PR (PRepr a) => PA a
toPRepr :: PA a => a -> PRepr a
fromPRepr :: PA a => PRepr a -> a
toArrPRepr :: PA a => PData a -> PData (PRepr a)
fromArrPRepr :: PA a => PData (PRepr a) -> PData a
toArrPReprs :: PA a => PDatas a -> PDatas (PRepr a)
fromArrPReprs :: PA a => PDatas (PRepr a) -> PDatas a

-- | Convert a nested array to its generic representation.
toNestedArrPRepr :: PA a => PData (PArray a) -> PData (PArray (PRepr a))
validPA :: PA a => PData a -> Bool
nfPA :: PA a => PData a -> ()
similarPA :: PA a => a -> a -> Bool
coversPA :: PA a => Bool -> PData a -> Int -> Bool
pprpPA :: PA a => a -> Doc
pprpDataPA :: PA a => PData a -> Doc
typeRepPA :: PA a => a -> TypeRep
typeRepDataPA :: PA a => PData a -> TypeRep
typeRepDatasPA :: PA a => PDatas a -> TypeRep
emptyPA :: PA a => PData a
replicatePA :: PA a => Int -> a -> PData a
replicatesPA :: PA a => Segd -> PData a -> PData a
appendPA :: PA a => PData a -> PData a -> PData a
appendsPA :: PA a => Segd -> VSegd -> PDatas a -> VSegd -> PDatas a -> PData a
lengthPA :: PA a => PData a -> Int
indexPA :: PA a => PData a -> Int -> a
indexsPA :: PA a => PDatas a -> Array (Int, Int) -> PData a
indexvsPA :: PA a => PDatas a -> VSegd -> Array (Int, Int) -> PData a
bpermutePA :: PA a => PData a -> Array Int -> PData a
extractPA :: PA a => PData a -> Int -> Int -> PData a
extractssPA :: PA a => PDatas a -> SSegd -> PData a
extractvsPA :: PA a => PDatas a -> VSegd -> PData a
packByTagPA :: PA a => PData a -> Array Tag -> Tag -> PData a
combine2PA :: PA a => Sel2 -> PData a -> PData a -> PData a
fromVectorPA :: PA a => Vector a -> PData a
toVectorPA :: PA a => PData a -> Vector a
emptydPA :: PA a => PDatas a
singletondPA :: PA a => PData a -> PDatas a
lengthdPA :: PA a => PDatas a -> Int
indexdPA :: PA a => PDatas a -> Int -> PData a
appenddPA :: PA a => PDatas a -> PDatas a -> PDatas a
fromVectordPA :: PA a => Vector (PData a) -> PDatas a
toVectordPA :: PA a => PDatas a -> Vector (PData a)

-- | Conatruct a nested array.
mkPNestedPA :: PA a => VSegd -> PDatas a -> Segd -> PData a -> PData (PArray a)
concatPA :: PA a => PData (PArray a) -> PData a
concatlPA :: PA a => PData (PArray (PArray a)) -> PData (PArray a)
unconcatPA :: (PA a, PA b) => PData (PArray a) -> PData b -> PData (PArray b)
appendlPA :: PA a => PData (PArray a) -> PData (PArray a) -> PData (PArray a)
indexlPA :: PA a => PData (PArray a) -> PData Int -> PData a
slicelPA :: PA a => PData Int -> PData Int -> PData (PArray a) -> PData (PArray a)

-- | Unpack an array to reveal its representation.
unpackPA :: PA a => PArray a -> PData (PRepr a)

-- | Family of Representable types. These are the types that we know how to
--   represent generically. <a>PRepr</a> takes an arbitrary type and
--   produces the generic type we use to represent it.
--   
--   Instances for simple types are defined by the library. For algebraic
--   types, it's up to the vectoriser/client module to create a suitable
--   instance.

-- | Lifted zip on PData arrays.
ziplPA :: (PA a, PA b) => PData (PArray a) -> PData (PArray b) -> PData (PArray (a, b))
instance (PprVirtual a, PA a) => PprVirtual (PArray a)
instance (Show a, PA a) => Show (PArray a)


-- | Functions that work on parallel arrays of scalar elements. Unlike the
--   functions defined in D.A.P.PArray, these only need Scalar
--   dictionaries, instead of PR or PA dictionaries.
--   
--   They are used when defining vectorised Prelude functions, eg in
--   D.A.P.Prelude.Int and D.A.P.Prelude.Double.
--   
--   The map and zipWith functions are also used by the vectoriser when
--   vectorising uses of scalar operators like (+).
module Data.Array.Parallel.PArray.Scalar

-- | Class of Scalar data that can be converted to and from single unboxed
--   vectors.
class (PA a, Elt a) => Scalar a
fromScalarPData :: Scalar a => PData a -> Array a
toScalarPData :: Scalar a => Array a -> PData a
fromScalarPDatas :: Scalar a => PDatas a -> Arrays a
toScalarPDatas :: Scalar a => Arrays a -> PDatas a
toUArray :: Scalar a => PArray a -> Array a
fromUArray :: Scalar a => Array a -> PArray a

-- | Convert an U.Array of pairs to a PArray.
fromUArray2 :: (Scalar a, Scalar b) => Array (a, b) -> PArray (a, b)

-- | Apply a worker function to every element of an array, yielding a new
--   array.
map :: (Scalar a, Scalar b) => (a -> b) -> PArray a -> PArray b

-- | Zip two arrays, yielding a new array.
zipWith :: (Scalar a, Scalar b, Scalar c) => (a -> b -> c) -> PArray a -> PArray b -> PArray c

-- | Zip three arrays, yielding a new array.
zipWith3 :: (Scalar a, Scalar b, Scalar c, Scalar d) => (a -> b -> c -> d) -> PArray a -> PArray b -> PArray c -> PArray d

-- | Zip four arrays, yielding a new array.
zipWith4 :: (Scalar a, Scalar b, Scalar c, Scalar d, Scalar e) => (a -> b -> c -> d -> e) -> PArray a -> PArray b -> PArray c -> PArray d -> PArray e

-- | Zip five arrays, yielding a new array.
zipWith5 :: (Scalar a, Scalar b, Scalar c, Scalar d, Scalar e, Scalar f) => (a -> b -> c -> d -> e -> f) -> PArray a -> PArray b -> PArray c -> PArray d -> PArray e -> PArray f

-- | Zip six arrays, yielding a new array.
zipWith6 :: (Scalar a, Scalar b, Scalar c, Scalar d, Scalar e, Scalar f, Scalar g) => (a -> b -> c -> d -> e -> f -> g) -> PArray a -> PArray b -> PArray c -> PArray d -> PArray e -> PArray f -> PArray g

-- | Zip seven arrays, yielding a new array.
zipWith7 :: (Scalar a, Scalar b, Scalar c, Scalar d, Scalar e, Scalar f, Scalar g, Scalar h) => (a -> b -> c -> d -> e -> f -> g -> h) -> PArray a -> PArray b -> PArray c -> PArray d -> PArray e -> PArray f -> PArray g -> PArray h

-- | Eight seven arrays, yielding a new array.
zipWith8 :: (Scalar a, Scalar b, Scalar c, Scalar d, Scalar e, Scalar f, Scalar g, Scalar h, Scalar i) => (a -> b -> c -> d -> e -> f -> g -> h -> i) -> PArray a -> PArray b -> PArray c -> PArray d -> PArray e -> PArray f -> PArray g -> PArray h -> PArray i

-- | Left fold over an array.
fold :: Scalar a => (a -> a -> a) -> a -> PArray a -> a

-- | Segmented fold of an array of arrays.
folds :: (Scalar a, Elts a) => (a -> a -> a) -> a -> PArray (PArray a) -> PArray a

-- | Left fold over an array, using the first element to initialise the
--   state.
fold1 :: Scalar a => (a -> a -> a) -> PArray a -> a

-- | Segmented fold of an array of arrays, using the first element of each
--   segment to initialse the state for that segment.
fold1s :: (Scalar a, Elts a) => (a -> a -> a) -> PArray (PArray a) -> PArray a

-- | Left fold over an array, also passing the index of each element to the
--   parameter function.
fold1Index :: Scalar a => ((Int, a) -> (Int, a) -> (Int, a)) -> PArray a -> Int

-- | Segmented fold over an array, also passing the index of each element
--   to the parameter function. TODO: fold the psegs then replicate, like
--   in the other folds. this currently has the wrong complexity.
fold1sIndex :: Scalar a => ((Int, a) -> (Int, a) -> (Int, a)) -> PArray (PArray a) -> PArray Int

-- | Construct a range of integers.
enumFromTo :: Int -> Int -> PArray Int
enumFromTol :: PArray Int -> PArray Int -> PArray (PArray Int)
instance Scalar Double
instance Scalar Word8
instance Scalar Int
instance Scalar Integer
instance Elt Integer
instance PA Integer
instance Scalar Ordering
instance Elt Ordering
instance Scalar Bool


-- | Unvectorised parallel arrays.
--   
--   <ul>
--   <li>These operators may be used directly by unvectorised client
--   programs.</li>
--   <li>They are also used by the
--   <a>Data.Array.Parallel.Lifted.Combinators</a> module to define the
--   closure converted versions that vectorised code uses.</li>
--   <li>In general, the operators here are all unsafe and don't do bounds
--   checks. The lifted versions also don't check that each of the argument
--   arrays have the same length.</li>
--   </ul>
module Data.Array.Parallel.PArray

-- | A parallel array consisting of a length field and some array data.
data PArray a

-- | A PA dictionary contains the functions that we use to convert a
--   representable type to and from its generic representation.
--   
--   The conversions methods should all be O(1).
class PR (PRepr a) => PA a

-- | Check that an array has a valid internal representation.
valid :: PA a => PArray a -> Bool

-- | Force an array to normal form.
nf :: PA a => PArray a -> ()

-- | Get the type of a thing.
typeRep :: PA a => a -> TypeRep

-- | O(1). An empty array.
empty :: PA a => PArray a

-- | O(1). Produce an array containing a single element.
singleton :: PA a => a -> PArray a

-- | O(n). Produce an array of singleton arrays.
singletonl :: PA a => PArray a -> PArray (PArray a)

-- | O(n). Define an array of the given size, that maps all elements to the
--   same value. We require the replication count to be &gt; 0 so that it's
--   easier to maintain the validPR invariants for nested arrays.
replicate :: PA a => Int -> a -> PArray a

-- | O(sum lengths). Lifted replicate.
replicatel :: PA a => PArray Int -> PArray a -> PArray (PArray a)

-- | O(sum lengths). Segmented replicate.
replicates :: PA a => Segd -> PArray a -> PArray a

-- | O(sum lengths). Wrapper for segmented replicate that takes replication
--   counts and uses them to build the <a>Segd</a>.
replicates' :: PA a => PArray Int -> PArray a -> PArray a

-- | Append two arrays.
append :: PA a => PArray a -> PArray a -> PArray a

-- | Lifted append. Both arrays must have the same length
appendl :: PA a => PArray (PArray a) -> PArray (PArray a) -> PArray (PArray a)

-- | Concatenate a nested array.
concat :: PA a => PArray (PArray a) -> PArray a

-- | Lifted concat.
concatl :: PA a => PArray (PArray (PArray a)) -> PArray (PArray a)

-- | Impose a nesting structure on a flat array
unconcat :: (PA a, PA b) => PArray (PArray a) -> PArray b -> PArray (PArray b)

-- | Create a nested array from a segment descriptor and some flat data.
--   The segment descriptor must represent as many elements as present in
--   the flat data array, else <a>error</a>
nestUSegd :: PA a => Segd -> PArray a -> PArray (PArray a)

-- | Take the length field of a <a>PArray</a>.
length :: PArray a -> Int

-- | Take the length of some arrays.
lengthl :: PA a => PArray (PArray a) -> PArray Int

-- | O(1). Lookup a single element from the source array.
index :: PA a => PArray a -> Int -> a

-- | O(len indices). Lookup a several elements from several source arrays
indexl :: PA a => PArray (PArray a) -> PArray Int -> PArray a

-- | Extract a range of elements from an array.
extract :: PA a => PArray a -> Int -> Int -> PArray a

-- | Segmented extract.
extracts :: PA a => Vector (PArray a) -> SSegd -> PArray a

-- | Wrapper for <a>extracts</a> that takes arrays of sources, starts and
--   lengths of the segments, and uses these to build the <a>SSegd</a>.
--   TODO: The lengths of the sources, starts and lengths arrays must be
--   the same, but this is not checked. All sourceids must point to valid
--   data arrays. Segments must be within their corresponding source array.
extracts' :: PA a => Vector (PArray a) -> PArray Int -> PArray Int -> PArray Int -> PArray a

-- | Extract a range of elements from an arrary. Like <a>extract</a> but
--   with the parameters in a different order.
slice :: PA a => Int -> Int -> PArray a -> PArray a

-- | Extract some slices from some arrays. The arrays of starting indices
--   and lengths must themselves have the same length.
slicel :: PA a => PArray Int -> PArray Int -> PArray (PArray a) -> PArray (PArray a)

-- | Take the segment descriptor from a nested array and demote it to a
--   plain Segd. This is unsafe because it can cause index space overflow.
takeUSegd :: PArray (PArray a) -> Segd

-- | Select the elements of an array that have their tag set to True.
pack :: PA a => PArray a -> PArray Bool -> PArray a

-- | Lifted pack.
packl :: PA a => PArray (PArray a) -> PArray (PArray Bool) -> PArray (PArray a)

-- | Filter an array based on some tags.
packByTag :: PA a => PArray a -> Array Tag -> Tag -> PArray a

-- | Combine two arrays based on a selector.
combine2 :: PA a => Sel2 -> PArray a -> PArray a -> PArray a

-- | Construct a range of integers.
enumFromTo :: Int -> Int -> PArray Int
enumFromTol :: PArray Int -> PArray Int -> PArray (PArray Int)

-- | O(1). Zip a pair of arrays into an array of pairs. The two arrays must
--   have the same length, else <a>error</a>.
zip :: PArray a -> PArray b -> PArray (a, b)

-- | Lifted zip.
zipl :: (PA a, PA b) => PArray (PArray a) -> PArray (PArray b) -> PArray (PArray (a, b))

-- | O(1). Zip three arrays. All arrays must have the same length, else
--   <a>error</a>.
zip3 :: PArray a -> PArray b -> PArray c -> PArray (a, b, c)

-- | O(1). Zip four arrays. All arrays must have the same length, else
--   <a>error</a>.
zip4 :: PArray a -> PArray b -> PArray c -> PArray d -> PArray (a, b, c, d)

-- | O(1). Zip five arrays. All arrays must have the same length, else
--   <a>error</a>.
zip5 :: PArray a -> PArray b -> PArray c -> PArray d -> PArray e -> PArray (a, b, c, d, e)

-- | O(1). Unzip an array of pairs into a pair of arrays.
unzip :: PArray (a, b) -> (PArray a, PArray b)

-- | Lifted unzip
unzipl :: PArray (PArray (a, b)) -> PArray (PArray a, PArray b)

-- | Convert a <a>Vector</a> to a <a>PArray</a>
fromVector :: PA a => Vector a -> PArray a

-- | Convert a <a>PArray</a> to a <a>Vector</a>
toVector :: PA a => PArray a -> Vector a

-- | Convert a list to a <a>PArray</a>.
fromList :: PA a => [a] -> PArray a

-- | Convert a <a>PArray</a> to a list.
toList :: PA a => PArray a -> [a]
fromUArray :: Scalar a => Array a -> PArray a
toUArray :: Scalar a => PArray a -> Array a

-- | Convert an U.Array of pairs to a PArray.
fromUArray2 :: (Scalar a, Scalar b) => Array (a, b) -> PArray (a, b)
instance (Eq a, PA a) => Eq (PArray a)
instance PA e => Array PArray e
instance PA a => PprPhysical1 a
instance PA a => Similar a
instance PA a => PprPhysical (PArray a)


-- | Closures. Used when closure converting the source program during
--   vectorisation.
module Data.Array.Parallel.Lifted.Closure

-- | Define the fixity of the closure type constructor.
--   
--   The type of closures. This bundles up:
data (:->) a b
Clo :: (env -> a -> b) -> (Int -> PData env -> PData a -> PData b) -> env -> :-> a b

-- | Closure application.
($:) :: (a :-> b) -> a -> b

-- | A chunk of parallel array data with a linear index space.
--   
--   In contrast to a <a>PArray</a>, a <a>PData</a> may not have a fixed
--   length, and its elements may have been converted to a generic
--   representation. Whereas a <a>PArray</a> is the "user view" of an
--   array, a <a>PData</a> is a type only used internally to the library.

-- | Lifted closure application.
($:^) :: PArray (a :-> b) -> PArray a -> PArray b

-- | Lifted closure application, taking an explicit lifting context.
liftedApply :: Int -> PData (a :-> b) -> PData a -> PData b

-- | Construct an arity-1 closure, from unlifted and lifted versions of a
--   primitive function.
closure1 :: (a -> b) -> (Int -> PData a -> PData b) -> (a :-> b)

-- | Construct an arity-2 closure, from lifted and unlifted versions of a
--   primitive function.
closure2 :: PA a => (a -> b -> c) -> (Int -> PData a -> PData b -> PData c) -> (a :-> (b :-> c))

-- | Construct an arity-3 closure from lifted and unlifted versions of a
--   primitive function.
closure3 :: (PA a, PA b) => (a -> b -> c -> d) -> (Int -> PData a -> PData b -> PData c -> PData d) -> (a :-> (b :-> (c :-> d)))

-- | Construct an arity-4 closure from lifted and unlifted versions of a
--   primitive function.
closure4 :: (PA a, PA b, PA c) => (a -> b -> c -> d -> e) -> (Int -> PData a -> PData b -> PData c -> PData d -> PData e) -> (a :-> (b :-> (c :-> (d :-> e))))

-- | Construct an arity-5 closure from lifted and unlifted versions of a
--   primitive function.
closure5 :: (PA a, PA b, PA c, PA d) => (a -> b -> c -> d -> e -> f) -> (Int -> PData a -> PData b -> PData c -> PData d -> PData e -> PData f) -> (a :-> (b :-> (c :-> (d :-> (e :-> f)))))

-- | Construct an arity-6 closure from lifted and unlifted versions of a
--   primitive function.
closure6 :: (PA a, PA b, PA c, PA d, PA e) => (a -> b -> c -> d -> e -> f -> g) -> (Int -> PData a -> PData b -> PData c -> PData d -> PData e -> PData f -> PData g) -> (a :-> (b :-> (c :-> (d :-> (e :-> (f :-> g))))))

-- | Construct an arity-6 closure from lifted and unlifted versions of a
--   primitive function.
closure7 :: (PA a, PA b, PA c, PA d, PA e, PA f) => (a -> b -> c -> d -> e -> f -> g -> h) -> (Int -> PData a -> PData b -> PData c -> PData d -> PData e -> PData f -> PData g -> PData h) -> (a :-> (b :-> (c :-> (d :-> (e :-> (f :-> (g :-> h)))))))

-- | Construct an arity-6 closure from lifted and unlifted versions of a
--   primitive function.
closure8 :: (PA a, PA b, PA c, PA d, PA e, PA f, PA g) => (a -> b -> c -> d -> e -> f -> g -> h -> i) -> (Int -> PData a -> PData b -> PData c -> PData d -> PData e -> PData f -> PData g -> PData h -> PData i) -> (a :-> (b :-> (c :-> (d :-> (e :-> (f :-> (g :-> (h :-> i))))))))

-- | Construct an arity-1 closure.
closure1' :: (a -> b) -> (PArray a -> PArray b) -> (a :-> b)

-- | Construct an arity-2 closure.
closure2' :: PA a => (a -> b -> c) -> (PArray a -> PArray b -> PArray c) -> (a :-> (b :-> c))

-- | Construct an arity-3 closure.
closure3' :: (PA a, PA b) => (a -> b -> c -> d) -> (PArray a -> PArray b -> PArray c -> PArray d) -> (a :-> (b :-> (c :-> d)))

-- | Construct an arity-4 closure.
closure4' :: (PA a, PA b, PA c) => (a -> b -> c -> d -> e) -> (PArray a -> PArray b -> PArray c -> PArray d -> PArray e) -> (a :-> (b :-> (c :-> (d :-> e))))

-- | Construct an arity-5 closure.
closure5' :: (PA a, PA b, PA c, PA d) => (a -> b -> c -> d -> e -> f) -> (PArray a -> PArray b -> PArray c -> PArray d -> PArray e -> PArray f) -> (a :-> (b :-> (c :-> (d :-> (e :-> f)))))

-- | Construct an arity-6 closure.
closure6' :: (PA a, PA b, PA c, PA d, PA e, PA f) => (a -> b -> c -> d -> e -> f -> g) -> (PArray a -> PArray b -> PArray c -> PArray d -> PArray e -> PArray f -> PArray g) -> (a :-> (b :-> (c :-> (d :-> (e :-> (f :-> g))))))

-- | Construct an arity-7 closure.
closure7' :: (PA a, PA b, PA c, PA d, PA e, PA f, PA g) => (a -> b -> c -> d -> e -> f -> g -> h) -> (PArray a -> PArray b -> PArray c -> PArray d -> PArray e -> PArray f -> PArray g -> PArray h) -> (a :-> (b :-> (c :-> (d :-> (e :-> (f :-> (g :-> h)))))))

-- | Construct an arity-8 closure.
closure8' :: (PA a, PA b, PA c, PA d, PA e, PA f, PA g, PA h) => (a -> b -> c -> d -> e -> f -> g -> h -> i) -> (PArray a -> PArray b -> PArray c -> PArray d -> PArray e -> PArray f -> PArray g -> PArray h -> PArray i) -> (a :-> (b :-> (c :-> (d :-> (e :-> (f :-> (g :-> (h :-> i))))))))
instance Typeable2 :->
instance (PA a, PA b) => PA (a :-> b)
instance PR (a :-> b)


-- | Closure converted lifted array combinators. The vectoriser produces
--   code that uses these combinators directly.
--   
--   All of the combinators in this module are polymorphic, work on
--   <a>PArray</a>, and take <a>PA</a> dictionaries. Combinators that are
--   specific to a certain element type, like <a>Int</a>, are defined in
--   the corresponding prelude module, eg
--   <a>Data.Array.Parallel.Prelude.Int</a>.
module Data.Array.Parallel.Lifted.Combinators

-- | Identity function, used as the vectorised version of fromPArrayP.
fromPArrayPP :: PA a => PArray a :-> PArray a

-- | Identity function, used as the vectorised version of toPArrayP.
toPArrayPP :: PA a => PArray a :-> PArray a

-- | Identity function, used as the vectorised version of fromNestedPArrayP
fromNestedPArrayPP :: PA a => (PArray (PArray a) :-> PArray (PArray a))

-- | O(1). Construct an empty array.
emptyPP :: PA a => PArray a

-- | O(1). Construct an array containing a single element.
singletonPP :: PA a => a :-> PArray a

-- | O(n). Construct an array of the given size, that maps all elements to
--   the same value.
replicatePP :: PA a => Int :-> (a :-> PArray a)

-- | O(len result). Append two arrays.
appendPP :: PA a => PArray a :-> (PArray a :-> PArray a)

-- | O(1). Take the number of elements in an array.
lengthPP :: PA a => PArray a :-> Int

-- | O(1). Lookup a single element from the source array.
indexPP :: PA a => PArray a :-> (Int :-> a)

-- | O(len slice). Extract a range of elements from an array.
slicePP :: PA a => Int :-> (Int :-> (PArray a :-> PArray a))

-- | Apply a worker function to every element of an array.
mapPP :: (PA a, PA b) => (a :-> b) :-> (PArray a :-> PArray b)

-- | Apply a worker function to every pair of two arrays.
zipWithPP :: (PA a, PA b, PA c) => (a :-> (b :-> c)) :-> (PArray a :-> (PArray b :-> PArray c))
crossMapPP :: (PA a, PA b) => PArray a :-> ((a :-> PArray b) :-> PArray (a, b))

-- | Extract the elements from an array that match the given predicate.
filterPP :: PA a => (a :-> Bool) :-> (PArray a :-> PArray a)

-- | O(len result). Concatenate a nested array.
concatPP :: PA a => PArray (PArray a) :-> PArray a

-- | Zip a pair of arrays into an array of pairs.
zipPP :: (PA a, PA b) => PArray a :-> (PArray b :-> PArray (a, b))

-- | Unzip an array of pairs into a pair of arrays.
unzipPP :: (PA a, PA b) => PArray (a, b) :-> (PArray a, PArray b)


-- | Closure converted tuple data constructors used by the vectoriser.
module Data.Array.Parallel.Prelude.Tuple
tup2 :: (PA a, PA b) => a :-> (b :-> (a, b))
tup3 :: (PA a, PA b, PA c) => a :-> (b :-> (c :-> (a, b, c)))
tup4 :: (PA a, PA b, PA c, PA d) => a :-> (b :-> (c :-> (d :-> (a, b, c, d))))
tup5 :: (PA a, PA b, PA c, PA d, PA e) => a :-> (b :-> (c :-> (d :-> (e :-> (a, b, c, d, e)))))


-- | This is the API used by the vectoriser. The vectoriser wants a
--   slightly different interface to the one used natively by the library.
--   This module performs the impedance matching.
module Data.Array.Parallel.Prim

-- | A chunk of parallel array data with a linear index space.
--   
--   In contrast to a <a>PArray</a>, a <a>PData</a> may not have a fixed
--   length, and its elements may have been converted to a generic
--   representation. Whereas a <a>PArray</a> is the "user view" of an
--   array, a <a>PData</a> is a type only used internally to the library.

-- | Several chunks of parallel array data.
--   
--   Although a <a>PArray</a> of atomic type such as <a>Int</a> only
--   contains a single <a>PData</a> chunk, nested arrays may contain
--   several, which we wrap up into a <a>PDatas</a>.

-- | Family of Representable types. These are the types that we know how to
--   represent generically. <a>PRepr</a> takes an arbitrary type and
--   produces the generic type we use to represent it.
--   
--   Instances for simple types are defined by the library. For algebraic
--   types, it's up to the vectoriser/client module to create a suitable
--   instance.

-- | A PA dictionary contains the functions that we use to convert a
--   representable type to and from its generic representation.
--   
--   The conversions methods should all be O(1).
class PR (PRepr a) => PA a
toPRepr :: PA a => a -> PRepr a
fromPRepr :: PA a => PRepr a -> a
toArrPRepr :: PA a => PData a -> PData (PRepr a)
fromArrPRepr :: PA a => PData (PRepr a) -> PData a
toArrPReprs :: PA a => PDatas a -> PDatas (PRepr a)
fromArrPReprs :: PA a => PDatas (PRepr a) -> PDatas a

-- | The PR (Parallel Representation) class holds primitive array operators
--   that work on our generic representation of data.
--   
--   There are instances for all atomic types such as <a>Int</a> and
--   <a>Double</a>, tuples, nested arrays `PData (PArray a)` and for the
--   generic types we used to represent user level algebraic data,
--   <tt>Sum2</tt> and <tt>Wrap</tt> and <tt>Void</tt>. All array data is
--   converted to this fixed set of types.
--   
--   TODO: refactor to change PData Int to U.Array Int, there's not need to
--   wrap an extra PData constructor around these arrays, and the type of
--   bpermute is different than the others.
class PR a where extractvsPR pdatas vsegd = extractssPR pdatas (unsafeDemoteToSSegdOfVSegd vsegd)
validPR :: PR a => PData a -> Bool
nfPR :: PR a => PData a -> ()
similarPR :: PR a => a -> a -> Bool
coversPR :: PR a => Bool -> PData a -> Int -> Bool
pprpPR :: PR a => a -> Doc
pprpDataPR :: PR a => PData a -> Doc
typeRepPR :: PR a => a -> TypeRep
typeRepDataPR :: PR a => PData a -> TypeRep
typeRepDatasPR :: PR a => PDatas a -> TypeRep
emptyPR :: PR a => PData a
replicatePR :: PR a => Int -> a -> PData a
replicatesPR :: PR a => Segd -> PData a -> PData a
appendPR :: PR a => PData a -> PData a -> PData a
appendvsPR :: PR a => Segd -> VSegd -> PDatas a -> VSegd -> PDatas a -> PData a
lengthPR :: PR a => PData a -> Int
indexPR :: PR a => PData a -> Int -> a
indexsPR :: PR a => PDatas a -> Array (Int, Int) -> PData a
indexvsPR :: PR a => PDatas a -> VSegd -> Array (Int, Int) -> PData a
extractPR :: PR a => PData a -> Int -> Int -> PData a
extractssPR :: PR a => PDatas a -> SSegd -> PData a
extractvsPR :: PR a => PDatas a -> VSegd -> PData a
packByTagPR :: PR a => PData a -> Array Tag -> Tag -> PData a
combine2PR :: PR a => Sel2 -> PData a -> PData a -> PData a
fromVectorPR :: PR a => Vector a -> PData a
toVectorPR :: PR a => PData a -> Vector a
emptydPR :: PR a => PDatas a
singletondPR :: PR a => PData a -> PDatas a
lengthdPR :: PR a => PDatas a -> Int
indexdPR :: PR a => PDatas a -> Int -> PData a
appenddPR :: PR a => PDatas a -> PDatas a -> PDatas a
fromVectordPR :: PR a => Vector (PData a) -> PDatas a
toVectordPR :: PR a => PDatas a -> Vector (PData a)
emptyPD :: PA a => PData a
replicatePD :: PA a => Int# -> a -> PData a
packByTagPD :: PA a => PData a -> Int# -> Array Tag -> Int# -> PData a
combine2PD :: PA a => Int# -> Sel2 -> PData a -> PData a -> PData a

-- | Class of Scalar data that can be converted to and from single unboxed
--   vectors.
class (PA a, Elt a) => Scalar a
fromScalarPData :: Scalar a => PData a -> Array a
toScalarPData :: Scalar a => Array a -> PData a
fromScalarPDatas :: Scalar a => PDatas a -> Arrays a
toScalarPDatas :: Scalar a => Arrays a -> PDatas a
scalar_map :: (Scalar a, Scalar b) => (a -> b) -> PArray a -> PArray b
scalar_zipWith :: (Scalar a, Scalar b, Scalar c) => (a -> b -> c) -> PArray a -> PArray b -> PArray c
scalar_zipWith3 :: (Scalar a, Scalar b, Scalar c, Scalar d) => (a -> b -> c -> d) -> PArray a -> PArray b -> PArray c -> PArray d
scalar_zipWith4 :: (Scalar a, Scalar b, Scalar c, Scalar d, Scalar e) => (a -> b -> c -> d -> e) -> PArray a -> PArray b -> PArray c -> PArray d -> PArray e
scalar_zipWith5 :: (Scalar a, Scalar b, Scalar c, Scalar d, Scalar e, Scalar f) => (a -> b -> c -> d -> e -> f) -> PArray a -> PArray b -> PArray c -> PArray d -> PArray e -> PArray f
scalar_zipWith6 :: (Scalar a, Scalar b, Scalar c, Scalar d, Scalar e, Scalar f, Scalar g) => (a -> b -> c -> d -> e -> f -> g) -> PArray a -> PArray b -> PArray c -> PArray d -> PArray e -> PArray f -> PArray g
scalar_zipWith7 :: (Scalar a, Scalar b, Scalar c, Scalar d, Scalar e, Scalar f, Scalar g, Scalar h) => (a -> b -> c -> d -> e -> f -> g -> h) -> PArray a -> PArray b -> PArray c -> PArray d -> PArray e -> PArray f -> PArray g -> PArray h
scalar_zipWith8 :: (Scalar a, Scalar b, Scalar c, Scalar d, Scalar e, Scalar f, Scalar g, Scalar h, Scalar i) => (a -> b -> c -> d -> e -> f -> g -> h -> i) -> PArray a -> PArray b -> PArray c -> PArray d -> PArray e -> PArray f -> PArray g -> PArray h -> PArray i

-- | The <a>Void</a> type is used when representing enumerations.
--   
--   A type like Bool is represented as <tt>Sum2 Void Void</tt>, meaning
--   that we only only care about the tag of the data constructor and not
--   its argumnent.
data Void :: *

-- | A <tt>value</tt> with the void type. Used as a placholder like
--   <a>undefined</a>. Forcing this yields <a>error</a>.
void :: Void

-- | Coerce a <a>Void</a> to a different type. Used as a placeholder like
--   <a>undefined</a>. Forcing the result yields <a>error</a>.
fromVoid :: a
pvoid :: PData Void
pvoids# :: Int# -> PDatas Void
punit :: Int -> PData ()

-- | When converting a data type to its generic representation, we use
--   <a>Wrap</a> to help us convert only one layer at a time. For example:
--   
--   <pre>
--      data Foo a = Foo Int a
--   
--   instance PA a =&gt; PA (Foo a) where
--       type PRepr (Foo a) = (Int, Wrap a)  -- define how (Foo a) is represented
--   </pre>
--   
--   Here we've converted the <tt>Foo</tt> data constructor to a pair, and
--   Int is its own representation type. We have PData/PR instances for
--   pairs and Ints, so we can work with arrays of these types. However, we
--   can't just use (Int, a) as the representation of (Foo a) because
--   <tt>a</tt> might be user defined and we won't have PData/PR instances
--   for it.
--   
--   Instead, we wrap the second element with the Wrap constructor, which
--   tells us that if we want to process this element we still need to
--   convert it to the generic representation (and back). This last part is
--   done by the PR instance of Wrap, who's methods are defined by calls to
--   the *PD functions from <a>Data.Array.Parallel.PArray.PRepr</a>.
newtype Wrap a :: * -> *
Wrap :: a -> Wrap a
unWrap :: Wrap a -> a

-- | Sum types used for the generic representation of algebraic data.
data Sum2 a b :: * -> * -> *
Alt2_1 :: a -> Sum2 a b
Alt2_2 :: b -> Sum2 a b
data Sum3 a b c :: * -> * -> * -> *
Alt3_1 :: a -> Sum3 a b c
Alt3_2 :: b -> Sum3 a b c
Alt3_3 :: c -> Sum3 a b c

-- | Define the fixity of the closure type constructor.
--   
--   The type of closures. This bundles up:
data (:->) a b
Clo :: (env -> a -> b) -> (Int -> PData env -> PData a -> PData b) -> env -> :-> a b

-- | Construct a closure.
closure :: PA e => (e -> a -> b) -> (Int# -> PData e -> PData a -> PData b) -> e -> (a :-> b)

-- | Apply a closure.
($:) :: (a :-> b) -> a -> b

-- | Construct a lifted closure.
liftedClosure :: PA e => (e -> a -> b) -> (Int# -> PData e -> PData a -> PData b) -> PData e -> PData (a :-> b)

-- | Apply a lifted closure.
liftedApply :: Int# -> PData (a :-> b) -> PData a -> PData b
closure1 :: (a -> b) -> (PArray a -> PArray b) -> (a :-> b)
closure2 :: PA a => (a -> b -> c) -> (PArray a -> PArray b -> PArray c) -> (a :-> (b :-> c))
closure3 :: (PA a, PA b) => (a -> b -> c -> d) -> (PArray a -> PArray b -> PArray c -> PArray d) -> (a :-> (b :-> (c :-> d)))
closure4 :: (PA a, PA b, PA c) => (a -> b -> c -> d -> e) -> (PArray a -> PArray b -> PArray c -> PArray d -> PArray e) -> (a :-> (b :-> (c :-> (d :-> e))))
closure5 :: (PA a, PA b, PA c, PA d) => (a -> b -> c -> d -> e -> f) -> (PArray a -> PArray b -> PArray c -> PArray d -> PArray e -> PArray f) -> (a :-> (b :-> (c :-> (d :-> (e :-> f)))))
closure6 :: (PA a, PA b, PA c, PA d, PA e) => (a -> b -> c -> d -> e -> f -> g) -> (PArray a -> PArray b -> PArray c -> PArray d -> PArray e -> PArray f -> PArray g) -> (a :-> (b :-> (c :-> (d :-> (e :-> (f :-> g))))))
closure7 :: (PA a, PA b, PA c, PA d, PA e, PA f, PA g) => (a -> b -> c -> d -> e -> f -> g -> h) -> (PArray a -> PArray b -> PArray c -> PArray d -> PArray e -> PArray f -> PArray g -> PArray h) -> (a :-> (b :-> (c :-> (d :-> (e :-> (f :-> (g :-> h)))))))
closure8 :: (PA a, PA b, PA c, PA d, PA e, PA f, PA g, PA h) => (a -> b -> c -> d -> e -> f -> g -> h -> i) -> (PArray a -> PArray b -> PArray c -> PArray d -> PArray e -> PArray f -> PArray g -> PArray h -> PArray i) -> (a :-> (b :-> (c :-> (d :-> (e :-> (f :-> (g :-> (h :-> i))))))))
type Sel2 = Sel2
tagsSel2 :: Sel2 -> Array Tag
pickSel2# :: Sel2 -> Int# -> Array Bool
replicateSel2# :: Int# -> Int# -> Sel2
elementsSel2_0# :: Sel2 -> Int#
elementsSel2_1# :: Sel2 -> Int#
type Sels2 = Vector Sel2
lengthSels2# :: Sels2 -> Int#
emptyPA_Int# :: PArray_Int#
emptyPA_Double# :: PArray_Double#
replicatePA_Int# :: Int# -> Int# -> PArray_Int#
replicatePA_Double# :: Int# -> Double# -> PArray_Double#
packByTagPA_Int# :: a
packByTagPA_Double# :: a
combine2PA_Int# :: Int# -> PArray_Int# -> PArray_Int# -> PArray_Int# -> PArray_Int# -> PArray_Int#
combine2PA_Double# :: Int# -> PArray_Int# -> PArray_Int# -> PArray_Double# -> PArray_Double# -> PArray_Double#
tup2 :: (PA a, PA b) => a :-> (b :-> (a, b))
tup3 :: (PA a, PA b, PA c) => a :-> (b :-> (c :-> (a, b, c)))
tup4 :: (PA a, PA b, PA c, PA d) => a :-> (b :-> (c :-> (d :-> (a, b, c, d))))
tup5 :: (PA a, PA b, PA c, PA d, PA e) => a :-> (b :-> (c :-> (d :-> (e :-> (a, b, c, d, e)))))


-- | This module sets up the basic vectorisation map for vectorising the
--   DPH Prelude.
module Data.Array.Parallel.Prelude.Base
type PArr = [::]
data Bool :: *
False :: Bool
True :: Bool
data Ordering :: *
LT :: Ordering
EQ :: Ordering
GT :: Ordering

-- | 8-bit unsigned integer type
data Word8 :: *

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int :: *

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float :: *

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double :: *

-- | The <a>Eq</a> class defines equality (<a>==</a>) and inequality
--   (<a>/=</a>). All the basic datatypes exported by the <a>Prelude</a>
--   are instances of <a>Eq</a>, and <a>Eq</a> may be derived for any
--   datatype whose constituents are also instances of <a>Eq</a>.
--   
--   Minimal complete definition: either <a>==</a> or <a>/=</a>.
class Eq a
(==) :: Eq a => a -> a -> Bool
(/=) :: Eq a => a -> a -> Bool

-- | The <a>Ord</a> class is used for totally ordered datatypes.
--   
--   Instances of <a>Ord</a> can be derived for any user-defined datatype
--   whose constituent types are in <a>Ord</a>. The declared order of the
--   constructors in the data declaration determines the ordering in
--   derived <a>Ord</a> instances. The <a>Ordering</a> datatype allows a
--   single comparison to determine the precise ordering of two objects.
--   
--   Minimal complete definition: either <a>compare</a> or <a>&lt;=</a>.
--   Using <a>compare</a> can be more efficient for complex types.
class Eq a => Ord a
compare :: Ord a => a -> a -> Ordering
(<) :: Ord a => a -> a -> Bool
(>=) :: Ord a => a -> a -> Bool
(>) :: Ord a => a -> a -> Bool
(<=) :: Ord a => a -> a -> Bool
max :: Ord a => a -> a -> a
min :: Ord a => a -> a -> a

-- | Conversion of values to readable <a>String</a>s.
--   
--   Minimal complete definition: <a>showsPrec</a> or <a>show</a>.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class Show a

-- | Basic numeric class.
--   
--   Minimal complete definition: all except <a>negate</a> or <tt>(-)</tt>
class Num a
(+) :: Num a => a -> a -> a
(*) :: Num a => a -> a -> a
(-) :: Num a => a -> a -> a
negate :: Num a => a -> a
abs :: Num a => a -> a
signum :: Num a => a -> a
fromInteger :: Num a => Integer -> a


-- | Closures and closure converted lifted array combinators.
module Data.Array.Parallel.Lifted

module Data.Array.Parallel.Prelude.Int

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int :: *
(==) :: Int -> Int -> Bool
(/=) :: Int -> Int -> Bool
(<) :: Int -> Int -> Bool
(<=) :: Int -> Int -> Bool
(>) :: Int -> Int -> Bool
(>=) :: Int -> Int -> Bool
min :: Int -> Int -> Int
max :: Int -> Int -> Int
maximumP :: PArr Int -> Int
minimumP :: PArr Int -> Int
maxIndexP :: PArr Int -> Int
minIndexP :: PArr Int -> Int
(+) :: Int -> Int -> Int
(-) :: Int -> Int -> Int
(*) :: Int -> Int -> Int
negate :: Int -> Int
abs :: Int -> Int
sumP :: PArr Int -> Int
productP :: PArr Int -> Int
div :: Int -> Int -> Int
mod :: Int -> Int -> Int
sqrt :: Int -> Int
enumFromToP :: Int -> Int -> PArr Int

module Data.Array.Parallel.Prelude.Bool
data Bool :: *
False :: Bool
True :: Bool

-- | <a>otherwise</a> is defined as the value <a>True</a>. It helps to make
--   guards more readable. eg.
--   
--   <pre>
--   f x | x &lt; 0     = ...
--       | otherwise = ...
--   </pre>
otherwise :: Bool

-- | Boolean "and"
(&&) :: Bool -> Bool -> Bool

-- | Boolean "or"
(||) :: Bool -> Bool -> Bool

-- | Boolean "not"
not :: Bool -> Bool
andP :: PArr Bool -> Bool
orP :: PArr Bool -> Bool
fromBool :: Bool -> Int
toBool :: Int -> Bool

module Data.Array.Parallel.Prelude.Double

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double :: *
(==) :: Double -> Double -> Bool
(/=) :: Double -> Double -> Bool
(<) :: Double -> Double -> Bool
(<=) :: Double -> Double -> Bool
(>) :: Double -> Double -> Bool
(>=) :: Double -> Double -> Bool
min :: Double -> Double -> Double
max :: Double -> Double -> Double
maximumP :: PArr Double -> Double
minimumP :: PArr Double -> Double
maxIndexP :: PArr Double -> Int
minIndexP :: PArr Double -> Int
(+) :: Double -> Double -> Double
(-) :: Double -> Double -> Double
(*) :: Double -> Double -> Double
(/) :: Double -> Double -> Double
negate :: Double -> Double
abs :: Double -> Double
sumP :: PArr Double -> Double
productP :: PArr Double -> Double
pi :: Double
sqrt :: Double -> Double
exp :: Double -> Double
(**) :: Double -> Double -> Double
log :: Double -> Double
logBase :: Double -> Double -> Double
sin :: Double -> Double
tan :: Double -> Double
cos :: Double -> Double
asin :: Double -> Double
atan :: Double -> Double
acos :: Double -> Double
sinh :: Double -> Double
tanh :: Double -> Double
cosh :: Double -> Double
asinh :: Double -> Double
atanh :: Double -> Double
acosh :: Double -> Double
fromInt :: Int -> Double

module Data.Array.Parallel.Prelude.Word8

-- | 8-bit unsigned integer type
data Word8 :: *
(==) :: Word8 -> Word8 -> Bool
(/=) :: Word8 -> Word8 -> Bool
(<) :: Word8 -> Word8 -> Bool
(<=) :: Word8 -> Word8 -> Bool
(>) :: Word8 -> Word8 -> Bool
(>=) :: Word8 -> Word8 -> Bool
min :: Word8 -> Word8 -> Word8
max :: Word8 -> Word8 -> Word8
maximumP :: PArr Word8 -> Word8
minimumP :: PArr Word8 -> Word8
maxIndexP :: PArr Word8 -> Int
minIndexP :: PArr Word8 -> Int
(+) :: Word8 -> Word8 -> Word8
(-) :: Word8 -> Word8 -> Word8
(*) :: Word8 -> Word8 -> Word8
negate :: Word8 -> Word8
abs :: Word8 -> Word8
sumP :: PArr Word8 -> Word8
productP :: PArr Word8 -> Word8
div :: Word8 -> Word8 -> Word8
mod :: Word8 -> Word8 -> Word8
sqrt :: Word8 -> Word8
fromInt :: Int -> Word8
toInt :: Word8 -> Int

module Data.Array.Parallel.Prelude.Ordering
data Ordering :: *
isLT :: Ordering -> Bool
isEQ :: Ordering -> Bool
isGT :: Ordering -> Bool


-- | This modules bundles all vectorised versions of Prelude definitions.
--   
--   <i>This module should not be explicitly imported in user code
--   anymore.</i> User code should only import <a>Parallel</a> and, until
--   the vectoriser supports type classes, the type-specific modules
--   <a>*</a>.
module Data.Array.Parallel.Prelude


-- | User level interface to vectorised parallel arrays.
--   
--   <i>WARNING:</i> In the current implementation, the functionality
--   provided in this module is tied to the vectoriser pass of GHC, invoked
--   by `-fvectorise`. These functions will not work at all in unvectorised
--   code. To operate on parallel arrays in unvectorised code, use the
--   functions in <a>Data.Array.Parallel.PArray</a> and convert between
--   array representations by using <a>fromPArrayP</a> and <a>toPArrayP</a>
--   from <i>vectorised</i> code.
module Data.Array.Parallel

-- | A parallel array consisting of a length field and some array data.
data PArray a

-- | O(1). Convert between <a>PArray</a> and [::] array representations.
fromPArrayP :: PArray a -> [:a:]

-- | O(1). Convert between <a>PArray</a> and [::] array representations.
toPArrayP :: [:a:] -> PArray a

-- | O(1). Convert between <a>PArray</a> and [::] array representations.
fromNestedPArrayP :: PArray (PArray a) -> [:[:a:]:]

-- | Construct an empty array, with no elements.
emptyP :: [:a:]

-- | Construct an array with a single element.
singletonP :: a -> [:a:]

-- | Construct an array by replicating the given element some number of
--   times.
replicateP :: Int -> a -> [:a:]

-- | Append two arrays.
appendP :: [:a:] -> [:a:] -> [:a:]

-- | Append two arrays.
(+:+) :: [:a:] -> [:a:] -> [:a:]

-- | Concatenate an array of arrays.
concatP :: [:[:a:]:] -> [:a:]

-- | Take the length of an array.
lengthP :: [:a:] -> Int

-- | Lookup a single element from the source array.
indexP :: [:a:] -> Int -> a

-- | Lookup a single element from the source array.
(!:) :: [:a:] -> Int -> a

-- | Extract a slice from an array.
sliceP :: Int -> Int -> [:a:] -> [:a:]

-- | Apply a worker function to every element of an array.
mapP :: (a -> b) -> [:a:] -> [:b:]

-- | Apply a worker function to every pair of two arrays.
zipWithP :: (a -> b -> c) -> [:a:] -> [:b:] -> [:c:]

-- | For every element <tt>a</tt> apply the function to get an array of
--   <tt>b</tt> then, and return an array of all the <tt>a</tt>s and
--   <tt>b</tt>s.
crossMapP :: [:a:] -> (a -> [:b:]) -> [:(a, b):]

-- | Filter an array, keeping only those elements that match the given
--   predicate.
filterP :: (a -> Bool) -> [:a:] -> [:a:]

-- | Zip a pair of arrays into an array of pairs.
zipP :: [:a:] -> [:b:] -> [:(a, b):]

-- | Unzip an array of pairs into a pair of arrays.
unzipP :: [:(a, b):] -> ([:a:], [:b:])
