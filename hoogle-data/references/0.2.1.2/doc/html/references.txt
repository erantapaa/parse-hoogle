-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generalization of lenses, folds and traversals to handle monads and addition.
--   
@package references
@version 0.2.1.2


-- | This module declares the representation and basic classes of
--   references.
--   
--   This module should not be imported directly.
module Control.Reference.Representation

-- | A reference is an accessor to a part or different view of some data.
--   The referenc has a separate getter, setter and updater. In some cases,
--   the semantics are a bit different
--   
--   <h2>Reference laws </h2>
--   
--   As the references are generalizations of lenses, they should conform
--   to the lens laws:
--   
--   1) You get back what you put in:
--   
--   <pre>
--   <a>refSet</a> l a s &gt;&gt;= <a>refGet</a> l return ≡ a
--   </pre>
--   
--   2) Putting back what you got doesn't change anything:
--   
--   <pre>
--   <a>refGet</a> l return a &gt;&gt;= \b -&gt; <a>refSet</a> l b s ≡ s
--   </pre>
--   
--   3) Setting twice is the same as setting once:
--   
--   <pre>
--   <a>refSet</a> l a s &gt;&gt;= <a>refSet</a> l b ≡ <a>refSet</a> l b s
--   </pre>
--   
--   But because update, set and get are different operations, .
--   
--   4) Updating something is the same as getting and then setting (if the
--   reader and writer monads are the same, or one can be converted into
--   the other):
--   
--   <pre>
--   <a>refGet</a> l a &gt;&gt;= f &gt;&gt;= \b -&gt; <a>refSet</a> l b s ≡ <a>refUpdate</a> l f s
--   </pre>
--   
--   This has some consequences. For example <tt>lensUpdate l id =
--   return</tt>.
--   
--   <h2>Type arguments of <a>Reference</a> </h2>
--   
--   <ul>
--   <li><i><tt>w</tt></i> Writer monad, controls how the value can be
--   reassembled when the part is changed. See differences between
--   <a>Lens</a>, <a>IOLens</a> and <a>StateLens</a></li>
--   <li><i><tt>r</tt></i> Reader monad. Controls how part of the value can
--   be asked. See differences between <a>Lens</a>, <a>Partial</a> and
--   <a>Traversal</a></li>
--   <li><i><tt>w'</tt></i> Backward writer monad. See <tt>turn</tt></li>
--   <li><i><tt>r'</tt></i> Backward reader monad. See <tt>turn</tt></li>
--   <li><i><tt>s</tt></i> The type of the original context.</li>
--   <li><i><tt>t</tt></i> The after replacing the accessed part to
--   something of type <tt>b</tt> the type of the context changes to
--   <tt>t</tt>.</li>
--   <li><i><tt>a</tt></i> The type of the accessed part.</li>
--   <li><i><tt>b</tt></i> The accessed part can be changed to something of
--   this type.</li>
--   </ul>
--   
--   Usually <tt>s</tt> and <tt>b</tt> determines <tt>t</tt>, <tt>t</tt>
--   and <tt>a</tt> determines <tt>s</tt>.
--   
--   The reader monad usually have more information (<tt>MMorph <tt>w</tt>
--   <tt>r</tt></tt>).
data Reference w r w' r' s t a b
Reference :: (forall x. (a -> r x) -> s -> r x) -> (b -> s -> w t) -> ((a -> w b) -> s -> w t) -> (forall x. (s -> r' x) -> a -> r' x) -> (t -> a -> w' b) -> ((s -> w' t) -> a -> w' b) -> Reference w r w' r' s t a b

-- | Getter for the lens. Takes a monadic function and runs it on the
--   accessed value. This is necessary to run actions after a read.
refGet :: Reference w r w' r' s t a b -> forall x. (a -> r x) -> s -> r x

-- | Setter for the lens
refSet :: Reference w r w' r' s t a b -> b -> s -> w t

-- | Updater for the lens. Handles monadic update functions.
refUpdate :: Reference w r w' r' s t a b -> (a -> w b) -> s -> w t
refGet' :: Reference w r w' r' s t a b -> forall x. (s -> r' x) -> a -> r' x
refSet' :: Reference w r w' r' s t a b -> t -> a -> w' b
refUpdate' :: Reference w r w' r' s t a b -> (s -> w' t) -> a -> w' b
bireference :: (RefMonads w r, RefMonads w' r') => (s -> r a) -> (b -> s -> w t) -> ((a -> w b) -> s -> w t) -> (a -> r' s) -> (t -> a -> w' b) -> ((s -> w' t) -> a -> w' b) -> Reference w r w' r' s t a b

-- | Creates a reference.
reference :: RefMonads w r => (s -> r a) -> (b -> s -> w t) -> ((a -> w b) -> s -> w t) -> Reference w r MU MU s t a b

-- | Creates a reference where all operations are added in their original
--   form.
--   
--   The use of this method is not suggested, because it is closely related
--   to the representation of the references.
rawReference :: (RefMonads w r, RefMonads w' r') => (forall x. (a -> r x) -> s -> r x) -> (b -> s -> w t) -> ((a -> w b) -> s -> w t) -> (forall x. (s -> r' x) -> a -> r' x) -> (t -> a -> w' b) -> ((s -> w' t) -> a -> w' b) -> Reference w r w' r' s t a b

-- | Creates a reference with explicit close operations that are executed
--   after the data is accessed.
referenceWithClose :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, Monad r) => (s -> r a) -> (s -> r ()) -> (b -> s -> w t) -> (s -> w ()) -> ((a -> w b) -> s -> w t) -> (s -> w ()) -> Reference w r MU MU s t a b

-- | Polymorph unit type. Can represent a calculation that cannot calculate
--   anything.
data MU a
MU :: MU a

-- | A simple class to enforce that both reader and writer semantics of the
--   reference are <a>Monad</a>s (as well as <a>Applicative</a>s and
--   <a>Functor</a>s)
class (Functor w, Applicative w, Monad w, Functor r, Applicative r, Monad r) => RefMonads w r

-- | A monomorph <a>Lens</a>, <a>Traversal</a>, <a>Partial</a>, etc...
--   Setting or updating does not change the type of the base.
type Simple t s a = t s s a a

-- | A two-way <a>Reference</a> that represents an isomorphism between two
--   datatypes. Can be used to access the same data in two different
--   representations.
type Iso s t a b = forall w r w' r'. (RefMonads w r, RefMonads w' r') => Reference w r w' r' s t a b

-- | A partial lens that can be turned to get a total lens.
type Prism s t a b = forall w r w' r'. (RefMonads w r, RefMonads w' r', MonadPlus r, MMorph Maybe r, MonadPlus w', MMorph Maybe w') => Reference w r w' r' s t a b

-- | A <a>Reference</a> that can access a part of data that exists in the
--   context. Every well-formed <a>Reference</a> is a <a>Lens</a>.
type Lens s t a b = forall w r. RefMonads w r => Reference w r MU MU s t a b

-- | Strict lens. A <a>Reference</a> that must access a part of data that
--   surely exists in the context.
type Lens' = Reference Identity Identity MU MU

-- | A reference that may not have the accessed element, and that can look
--   for the accessed element in multiple locations.
type RefPlus s t a b = forall w r. (RefMonads w r, MonadPlus r) => Reference w r MU MU s t a b

-- | Partial lens. A <a>Reference</a> that can access data that may not
--   exist in the context. Every lens is a partial lens.
--   
--   Any reference that is a partial lens should only perform the action
--   given to its <tt>updateRef</tt> function if it can get a value (the
--   value returned by <tt>getRef</tt> is not the lifted form of
--   <a>Nothing</a>).
type Partial s t a b = forall w r. (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, MMorph Maybe r) => Reference w r MU MU s t a b

-- | Strict partial lens. A <a>Reference</a> that must access data that may
--   not exist in the context.
type Partial' = Reference Identity Maybe MU MU

-- | A reference that can access data that is available in a number of
--   instances inside the contexts.
--   
--   Any reference that is a <a>Traversal</a> should perform the action
--   given to its updater in the exactly the same number of times that is
--   the number of the values returned by it's <tt>getRef</tt> function.
type Traversal s t a b = forall w r. (RefMonads w r, MonadPlus r, MMorph Maybe r, MMorph [] r) => Reference w r MU MU s t a b

-- | Strict traversal. A reference that must access data that is available
--   in a number of instances inside the context.
type Traversal' = Reference Identity [] MU MU
class (MMorph IO w, MMorph IO r, MonadBaseControl IO w, MonadBaseControl IO r) => IOMonads w r

-- | A reference that can access mutable data.
type IOLens s t a b = forall w r. (RefMonads w r, IOMonads w r) => Reference w r MU MU s t a b

-- | A reference that must access mutable data that is available in the
--   context.
type IOLens' = Reference IO IO MU MU

-- | A reference that can access mutable data that may not exist in the
--   context.
type IOPartial s t a b = forall w r. (RefMonads w r, IOMonads w r, MonadPlus r, MMorph Maybe r) => Reference w r MU MU s t a b

-- | A reference that must access mutable data that may not exist in the
--   context.
type IOPartial' = Reference IO (MaybeT IO) MU MU
type IOTraversal s t a b = forall w r. (RefMonads w r, IOMonads w r, MonadPlus r, MMorph Maybe r, MMorph [] r) => Reference w r MU MU s t a b

-- | A reference that can access mutable data that is available in a number
--   of instances inside the contexts.
type IOTraversal' = Reference IO (ListT IO) MU MU

-- | A reference that can access a value inside a <a>StateT</a> transformed
--   monad.
type StateLens st m s t a b = forall w r. (RefMonads w r, MMorph (StateT st m) w, MMorph (StateT st m) r) => Reference w r MU MU s t a b

-- | A reference that must access a value inside a <a>StateT</a>
--   transformed monad.
type StateLens' s m = Reference (StateT s m) (StateT s m) MU MU

-- | A reference that can access a value inside a <a>StateT</a> transformed
--   monad that may not exist.
type StatePartial st m s t a b = forall w r. (RefMonads w r, MMorph (StateT st m) w, MonadPlus r, MMorph Maybe r, MMorph (StateT st m) r) => Reference w r MU MU s t a b

-- | A reference that must access a value inside a <a>StateT</a>
--   transformed monad that may not exist.
type StatePartial' s m = Reference (StateT s m) (MaybeT (StateT s m)) MU MU

-- | A reference that can access a value inside a <a>StateT</a> transformed
--   monad that may exist in multiple instances.
type StateTraversal st m s t a b = forall w r. (RefMonads w r, MMorph (StateT st m) w, MonadPlus r, MMorph Maybe r, MMorph [] r, MMorph (StateT st m) r) => Reference w r MU MU s t a b

-- | A reference that must access a value inside a <a>StateT</a>
--   transformed monad that may exist in multiple instances.
type StateTraversal' s m = Reference (StateT s m) (ListT (StateT s m)) MU MU

-- | A reference that can access a value inside a <a>WriterT</a>
--   transformed monad.
type WriterLens st m s t a b = forall w r. (RefMonads w r, MMorph (WriterT st m) w, MMorph (WriterT st m) r) => Reference w r MU MU s t a b

-- | A reference that must access a value inside a <a>WriterT</a>
--   transformed monad.
type WriterLens' s m = Reference (WriterT s m) (WriterT s m) MU MU

-- | A reference that can access a value inside a <a>WriterT</a>
--   transformed monad that may not exist.
type WriterPartial st m s t a b = forall w r. (RefMonads w r, MMorph (WriterT st m) w, MonadPlus r, MMorph Maybe r, MMorph (WriterT st m) r) => Reference w r MU MU s t a b

-- | A reference that must access a value inside a <tt>WriteT</tt>
--   transformed monad that may not exist.
type WriterPartial' s m = Reference (WriterT s m) (MaybeT (WriterT s m)) MU MU

-- | A reference that can access a value inside a <tt>WriteT</tt>
--   transformed monad that may exist in multiple instances.
type WriterTraversal st m s t a b = forall w r. (RefMonads w r, MMorph (WriterT st m) w, MonadPlus r, MMorph Maybe r, MMorph [] r, MMorph (WriterT st m) r) => Reference w r MU MU s t a b

-- | A reference that must access a value inside a <tt>WriteT</tt>
--   transformed monad that may exist in multiple instances.
type WriterTraversal' s m = Reference (WriterT s m) (ListT (WriterT s m)) MU MU

-- | A reference that can access a value inside an <a>ST</a> transformed
--   monad.
type STLens st s t a b = forall w r. (RefMonads w r, MMorph (ST st) w, MMorph (ST st) r) => Reference w r MU MU s t a b

-- | A reference that must access a value inside an <a>ST</a> transformed
--   monad.
type STLens' s = Reference (ST s) (ST s) MU MU

-- | A reference that can access a value inside an <a>ST</a> transformed
--   monad that may not exist.
type STPartial st s t a b = forall w r. (RefMonads w r, MMorph (ST st) w, MonadPlus r, MMorph Maybe r, MMorph (ST st) r) => Reference w r MU MU s t a b

-- | A reference that must access a value inside an <a>ST</a> transformed
--   monad that may not exist.
type STPartial' s = Reference (ST s) (MaybeT (ST s)) MU MU

-- | A reference that can access a value inside an <a>ST</a> transformed
--   monad that may exist in multiple instances.
type STTraversal st s t a b = forall w r. (RefMonads w r, MMorph (ST st) w, MonadPlus r, MMorph Maybe r, MMorph [] r, MMorph (ST st) r) => Reference w r MU MU s t a b

-- | A reference that must access a value inside an <a>ST</a> transformed
--   monad that may exist in multiple instances.
type STTraversal' s = Reference (ST s) (ListT (ST s)) MU MU

-- | States that <tt>m1</tt> can be represented with <tt>m2</tt>. That is
--   because <tt>m2</tt> contains more infromation than <tt>m1</tt>.
--   
--   The <a>MMorph</a> relation defines a natural transformation from
--   <tt>m1</tt> to <tt>m2</tt> that keeps the following laws:
--   
--   <pre>
--   morph (return x)  =  return x
--   morph (m &gt;&gt;= f)   =  morph m &gt;&gt;= morph . f
--   </pre>
--   
--   It is a reflexive and transitive relation.
class MMorph (m1 :: * -> *) (m2 :: * -> *)
morph :: MMorph m1 m2 => m1 a -> m2 a
instance MMorph m MU
instance MMorph [] []
instance MMorph Maybe []
instance MMorph Maybe Maybe
instance MMorph Identity []
instance MMorph Identity Maybe
instance MMorph IO IO
instance MMorph IO (ListT IO)
instance MMorph IO (MaybeT IO)
instance (MMorph IO w, MMorph IO r, MonadBaseControl IO w, MonadBaseControl IO r) => IOMonads w r
instance (Functor w, Applicative w, Monad w, Functor r, Applicative r, Monad r) => RefMonads w r
instance MonadPlus MU
instance Monad MU
instance Applicative MU
instance Functor MU


-- | Common operators for references. References bind the types of the read
--   and write monads of a reference.
--   
--   The naming of the operators follows the given convetions:
--   
--   <ul>
--   <li>There are four kinds of operator for every type of reference. The
--   operators are either getters (<tt>^_</tt>), setters (<tt>_=</tt>),
--   monadic updaters (<tt>_~</tt>), pure updaters (<tt>_-</tt>) or action
--   performers (<tt>_|</tt>). The <tt>_</tt> will be replaced with the
--   signs of the monads accessable.</li>
--   <li>There are pure operators for <a>Lens</a> (<tt>.</tt>), partial
--   operators for <a>Partial</a> lenses (<tt>?</tt>), operators for
--   <a>Traversal</a> (<tt>*</tt>), and operators that work inside
--   <a>IO</a> for <a>IOLens</a> (<tt>!</tt>).</li>
--   <li>Different reference types can be combined, the outermost monad is
--   the first character. Example: Partial IO lens (<tt>?!</tt>). But
--   partial lens and traversal combined is simply a traversal.</li>
--   <li>Generic operators (<tt>#</tt>) do not bind the types of the
--   monads, so they must disambiguated manually.</li>
--   </ul>
module Control.Reference.Operators

-- | Flips a reference to the other direction
turn :: Reference w r w' r' s t a b -> Reference w' r' w r a b s t
review :: Reference MU MU Identity Identity s t a b -> a -> s

-- | Gets the referenced data in the monad of the lens. Does not bind the
--   type of the writer monad, so the reference must have its type
--   disambiguated.
(^#) :: RefMonads w r => s -> Reference w r w' r' s t a b -> r a

-- | Pure version of <a>^#</a>
(^.) :: s -> Lens' s t a b -> a

-- | Partial version of <a>^#</a>
(^?) :: s -> Partial' s t a b -> Maybe a

-- | Traversal version of <a>^#</a>
(^*) :: s -> Traversal' s t a b -> [a]

-- | IO version of <a>^#</a>
(^!) :: s -> IOLens' s t a b -> IO a

-- | IO partial version of <a>^#</a>
(^?!) :: s -> IOPartial' s t a b -> IO (Maybe a)

-- | IO traversal version of <a>^#</a>
(^*!) :: s -> IOTraversal' s t a b -> IO [a]

-- | Sets the referenced data to the given pure value in the monad of the
--   reference.
--   
--   Does not bind the type of the reader monad, so the reference must have
--   its type disambiguated.
(#=) :: Reference w r w' r' s t a b -> b -> s -> w t

-- | Pure version of '#='
(.=) :: Lens' s t a b -> b -> s -> t

-- | Partial version of '#='
(?=) :: Partial' s t a b -> b -> s -> t

-- | Traversal version of '#='
(*=) :: Traversal' s t a b -> b -> s -> t

-- | IO version of '#='
(!=) :: IOLens' s t a b -> b -> s -> IO t

-- | Partial IO version of '#='
(?!=) :: IOPartial' s t a b -> b -> s -> IO t

-- | Traversal IO version of '#='
(*!=) :: IOTraversal' s t a b -> b -> s -> IO t

-- | Applies the given monadic function on the referenced data in the monad
--   of the lens.
--   
--   Does not bind the type of the reader monad, so the reference must have
--   its type disambiguated.
(#~) :: Reference w r w' r' s t a b -> (a -> w b) -> s -> w t

-- | Pure version of '#~'
(.~) :: Lens' s t a b -> (a -> Identity b) -> s -> t

-- | Partial version of '#~'
(?~) :: Partial' s t a b -> (a -> Identity b) -> s -> t

-- | Traversal version of '#~'
(*~) :: Traversal' s t a b -> (a -> Identity b) -> s -> t

-- | IO version of '#~'
(!~) :: IOLens' s t a b -> (a -> IO b) -> s -> IO t

-- | Partial IO version of '#~'
(?!~) :: IOPartial' s t a b -> (a -> IO b) -> s -> IO t

-- | Traversal IO version of '#~'
(*!~) :: IOTraversal' s t a b -> (a -> IO b) -> s -> IO t

-- | Applies the given pure function on the referenced data in the monad of
--   the lens.
--   
--   Does not bind the type of the reader monad, so the reference must have
--   its type disambiguated.
(#-) :: Monad w => Reference w r w' r' s t a b -> (a -> b) -> s -> w t

-- | Pure version of '#-'
(.-) :: Lens' s t a b -> (a -> b) -> s -> t

-- | Partial version of '#-'
(?-) :: Partial' s t a b -> (a -> b) -> s -> t

-- | Traversal version of '#-'
(*-) :: Traversal' s t a b -> (a -> b) -> s -> t

-- | IO version of '#-'
(!-) :: IOLens' s t a b -> (a -> b) -> s -> IO t

-- | Partial IO version of '#-'
(?!-) :: IOPartial' s t a b -> (a -> b) -> s -> IO t

-- | Traversal IO version of '#-'
(*!-) :: IOTraversal' s t a b -> (a -> b) -> s -> IO t

-- | Performs the given monadic action on referenced data while giving back
--   the original data.
--   
--   Does not bind the type of the reader monad, so the reference must have
--   its type disambiguated.
(#|) :: Monad w => Reference w r w' r' s s a a -> (a -> w x) -> s -> w s

-- | IO version of '#|'
(!|) :: IOLens' s s a a -> (a -> IO c) -> s -> IO s

-- | Partial IO version of '#|'
(?!|) :: IOPartial' s s a a -> (a -> IO c) -> s -> IO s

-- | Traversal IO version of '#|'
(*!|) :: IOTraversal' s s a a -> (a -> IO c) -> s -> IO s

-- | Composes two references. They must be of the same kind.
--   
--   If reference <tt>r</tt> accesses <tt>b</tt> inside the context
--   <tt>a</tt>, and reference <tt>p</tt> accesses <tt>c</tt> inside the
--   context <tt>b</tt>, than the reference <tt>r&amp;p</tt> will access
--   <tt>c</tt> inside <tt>a</tt>.
--   
--   Composition is associative: <tt> (r&amp;p)&amp;q = r&amp;(p&amp;q)
--   </tt>
(&) :: (Monad w, Monad r) => Reference w r w' r' s t c d -> Reference w r w' r' c d a b -> Reference w r w' r' s t a b

-- | Adds two references.
--   
--   Using this operator may result in accessing the same parts of data
--   multiple times. For example <tt> twice = self &amp;+&amp; self </tt>
--   is a reference that accesses itself twice:
--   
--   <pre>
--   a ^* twice == [a,a]
--   (twice *= x) a == x
--   (twice *- f) a == f (f a)
--   </pre>
--   
--   Addition is commutative only if we do not consider the order of the
--   results from a get, or the order in which monadic actions are
--   performed.
(&+&) :: (RefMonads w r, RefMonads w' r', MonadPlus r, MonadPlus r', MMorph [] r) => Reference w r w' r' s s a a -> Reference w r w' r' s s a a -> Reference w r w' r' s s a a

-- | Pack two references in parallel.
(&|&) :: RefMonads m m' => Reference m m m' m' s t a b -> Reference m m m' m' s' t' a' b' -> Reference m m m' m' (s, s') (t, t') (a, a') (b, b')


-- | Predefined references for commonly used data structures and reference
--   generators.
--   
--   When defining lenses one should use the more general types. For
--   instance <a>Lens</a> instead of the more strict <a>Lens'</a>. This way
--   references with different <tt>m1</tt> and <tt>m2</tt> monads can be
--   combined if there is a monad <tt>m'</tt> for <tt>MMorph m1 m'</tt> and
--   <tt>MMorph m2 m'</tt>.
module Control.Reference.Predefined

-- | An identical lens. Accesses the context.
--   
--   <pre>
--   self &amp; a = a &amp; self = a
--   </pre>
self :: Lens a b a b

-- | An empty reference that do not traverse anything
--   
--   <pre>
--   emptyRef &amp;+&amp; a = a &amp;+&amp; emptyRef = a
--   </pre>
--   
--   <pre>
--   a &amp; emptyRef = emptyRef &amp; a = emptyRef
--   </pre>
emptyRef :: Simple RefPlus s a

-- | Generates a traversal for any <a>Traversable</a> <a>Functor</a>
traverse :: Traversable t => Traversal (t a) (t b) a b

-- | Generate a lens from a pair of inverse functions
iso :: (a -> b) -> (b -> a) -> Simple Iso a b
iso' :: (a -> b) -> (a' -> b') -> (b -> a) -> (b' -> a') -> Iso a a' b b'

-- | Generates a lens from a getter and a setter
lens :: (s -> a) -> (b -> s -> t) -> Lens s t a b

-- | Creates a polymorphic partial lense
--   
--   <tt>Either t a</tt> is used instead of <tt>Maybe a</tt> to permit the
--   types of <tt>s</tt> and <tt>t</tt> to differ.
partial :: (s -> Either t (a, b -> t)) -> Partial s t a b

-- | Creates a polymorphic partial lens that can be turned to give a total
--   lens
prism :: (a -> s) -> (b -> t) -> (s -> Either t a) -> (t -> Maybe b) -> Prism s t a b

-- | Creates a monomorphic partial lens that can be turned to give a total
--   lens
simplePrism :: (a -> s) -> (s -> Maybe a) -> Prism s s a a

-- | Creates a simple partial lens
simplePartial :: (s -> Maybe (a, a -> s)) -> Partial s s a a

-- | Clones a lens from <a>Control.Lens</a>
fromLens :: (forall f. Functor f => (a -> f b) -> s -> f t) -> Lens s t a b

-- | Clones a traversal from <a>Control.Lens</a>
fromTraversal :: (forall f. Applicative f => (a -> f b) -> s -> f t) -> Traversal s t a b

-- | Filters the traversed elements with a given predicate. Has specific
--   versions for traversals and partial lenses.
filtered :: (a -> Bool) -> Simple RefPlus a a

-- | A partial lens to access the value that may not exist
just :: Prism (Maybe a) (Maybe b) a b

-- | A partial lens to access the right option of an <a>Either</a>
right :: Prism (Either a b) (Either a c) b c

-- | A partial lens to access the left option of an <a>Either</a>
left :: Prism (Either a c) (Either b c) a b

-- | Access the value that is in the left or right state of an
--   <a>Either</a>
anyway :: Lens (Either a a) (Either b b) a b

-- | References both elements of a tuple
both :: Traversal (a, a) (b, b) a b

-- | References the head of a list
atHead :: Simple Lens [a] (Maybe a)

-- | References the element at the head of the list
headElem :: Simple Partial [a] a

-- | References the tail of a list
_tail :: Simple Partial [a] [a]

-- | References a suffix of a list
dropped :: Int -> Simple Partial [a] [a]

-- | Views a list as an optinal pair
view :: Iso [a] [b] (Maybe (a, [a])) (Maybe (b, [b]))

-- | An isomorphism between the list and text representation of a string
text :: Simple Iso String Text

-- | Accesses the reversed version of a list
--   
--   <pre>
--   'turn' reversed == reversed
--   </pre>
reversed :: Iso [a] [b] [a] [b]

-- | Accesses the numerator of a ratio
_numerator :: Integral a => Simple Lens (Ratio a) a

-- | Accesses the denominator of a ratio
_denominator :: Integral a => Simple Lens (Ratio a) a

-- | Accesses the real part of a complex number
_realPart :: RealFloat a => Simple Lens (Complex a) a

-- | Accesses the imaginary part of a complex number
_imagPart :: RealFloat a => Simple Lens (Complex a) a

-- | Accesses the polar representation of a complex number
_polar :: RealFloat a => Simple Lens (Complex a) (a, a)

-- | A dummy object to interact with the user through the console.
data Console
Console :: Console

-- | Interacts with a line of text on the console. Values set are printed,
--   getting is reading from the console.
consoleLine :: Simple IOLens Console String

-- | Access a value inside an MVar. Setting is not atomic. If there is two
--   supplier that may set the accessed value, one may block and can
--   corrupt the following updates.
--   
--   Reads and updates are done in sequence, always using consistent data.
mvar :: Simple IOLens (MVar a) a
chan :: Simple IOLens (Chan a) a

-- | Access the value of an IORef.
ioref :: Simple IOLens (IORef a) a

-- | Access the state inside a state monad (from any context).
state :: Monad m => Simple (StateLens s m) a s

-- | Access the value inside an <a>STRef</a>
stRef :: Simple (STLens s) (STRef s a) a


-- | A module for making connections between different monads.
module Control.Reference.TH.Monad

-- | Creates <a>MMorph</a> instances from reflectivity, and transitivity of
--   the relation. Uses data from all instances declared so far.
makeMonadRepr :: (ToQType t1, ToQType t2, ToQExp e) => t1 -> t2 -> e -> Q [Dec]

-- | A type name or a type expression, that can be converted into a type
--   inside <a>Q</a>.
class ToQType t
toQType :: ToQType t => t -> Q Type

-- | A variable or function name or an expression, that can be converted
--   into an expression inside <a>Q</a>.
class ToQExp t
toQExp :: ToQExp t => t -> Q Exp
instance Show InstanceGenState
instance Show Above
instance Show Below
instance ToQExp Name
instance ToQExp (Q Exp)
instance ToQType Name
instance ToQType (Q Type)
instance ToQType Type

module Control.Reference.Predefined.Containers

-- | Lenses for given values in a data structure that is indexed by keys.
class Association e where type family AssocIndex e :: * type family AssocElem e :: *
element :: Association e => AssocIndex e -> Simple Partial e (AssocElem e)
class Association e => Mapping e
at :: Mapping e => AssocIndex e -> Simple Lens e (Maybe (AssocElem e))

-- | Containers that can be used as a set, inserting and removing elements
class SetLike e where type family SetElem e :: *
contains :: SetLike e => (SetElem e) -> Simple Lens e Bool
instance SetLike IntSet
instance Ord v => SetLike (Set v)
instance Mapping (IntMap v)
instance Association (IntMap v)
instance Ord k => Mapping (Map k v)
instance Ord k => Association (Map k v)
instance Eq a => Mapping (a -> Maybe b)
instance Eq a => Association (a -> Maybe b)
instance Association Text
instance Association (Seq a)
instance Ix i => Association (Array i a)
instance Association [a]


-- | An interface with references that can be used internally while
--   generating instances for <a>MMorph</a> and tuple lens classes.
--   
--   Only the public parts of <a>Control.Reference.Representation</a> are
--   exported.
--   
--   For creating a new interface with different generated elements, use
--   this internal interface.
module Control.Reference.InternalInterface

-- | A monomorph <a>Lens</a>, <a>Traversal</a>, <a>Partial</a>, etc...
--   Setting or updating does not change the type of the base.
type Simple t s a = t s s a a

-- | A reference is an accessor to a part or different view of some data.
--   The referenc has a separate getter, setter and updater. In some cases,
--   the semantics are a bit different
--   
--   <h2>Reference laws </h2>
--   
--   As the references are generalizations of lenses, they should conform
--   to the lens laws:
--   
--   1) You get back what you put in:
--   
--   <pre>
--   <a>refSet</a> l a s &gt;&gt;= <a>refGet</a> l return ≡ a
--   </pre>
--   
--   2) Putting back what you got doesn't change anything:
--   
--   <pre>
--   <a>refGet</a> l return a &gt;&gt;= \b -&gt; <a>refSet</a> l b s ≡ s
--   </pre>
--   
--   3) Setting twice is the same as setting once:
--   
--   <pre>
--   <a>refSet</a> l a s &gt;&gt;= <a>refSet</a> l b ≡ <a>refSet</a> l b s
--   </pre>
--   
--   But because update, set and get are different operations, .
--   
--   4) Updating something is the same as getting and then setting (if the
--   reader and writer monads are the same, or one can be converted into
--   the other):
--   
--   <pre>
--   <a>refGet</a> l a &gt;&gt;= f &gt;&gt;= \b -&gt; <a>refSet</a> l b s ≡ <a>refUpdate</a> l f s
--   </pre>
--   
--   This has some consequences. For example <tt>lensUpdate l id =
--   return</tt>.
--   
--   <h2>Type arguments of <a>Reference</a> </h2>
--   
--   <ul>
--   <li><i><tt>w</tt></i> Writer monad, controls how the value can be
--   reassembled when the part is changed. See differences between
--   <a>Lens</a>, <a>IOLens</a> and <a>StateLens</a></li>
--   <li><i><tt>r</tt></i> Reader monad. Controls how part of the value can
--   be asked. See differences between <a>Lens</a>, <a>Partial</a> and
--   <a>Traversal</a></li>
--   <li><i><tt>w'</tt></i> Backward writer monad. See <tt>turn</tt></li>
--   <li><i><tt>r'</tt></i> Backward reader monad. See <tt>turn</tt></li>
--   <li><i><tt>s</tt></i> The type of the original context.</li>
--   <li><i><tt>t</tt></i> The after replacing the accessed part to
--   something of type <tt>b</tt> the type of the context changes to
--   <tt>t</tt>.</li>
--   <li><i><tt>a</tt></i> The type of the accessed part.</li>
--   <li><i><tt>b</tt></i> The accessed part can be changed to something of
--   this type.</li>
--   </ul>
--   
--   Usually <tt>s</tt> and <tt>b</tt> determines <tt>t</tt>, <tt>t</tt>
--   and <tt>a</tt> determines <tt>s</tt>.
--   
--   The reader monad usually have more information (<tt>MMorph <tt>w</tt>
--   <tt>r</tt></tt>).
data Reference w r w' r' s t a b
bireference :: (RefMonads w r, RefMonads w' r') => (s -> r a) -> (b -> s -> w t) -> ((a -> w b) -> s -> w t) -> (a -> r' s) -> (t -> a -> w' b) -> ((s -> w' t) -> a -> w' b) -> Reference w r w' r' s t a b

-- | Creates a reference.
reference :: RefMonads w r => (s -> r a) -> (b -> s -> w t) -> ((a -> w b) -> s -> w t) -> Reference w r MU MU s t a b

-- | Creates a reference with explicit close operations that are executed
--   after the data is accessed.
referenceWithClose :: (Functor w, Applicative w, Monad w, Functor r, Applicative r, Monad r) => (s -> r a) -> (s -> r ()) -> (b -> s -> w t) -> (s -> w ()) -> ((a -> w b) -> s -> w t) -> (s -> w ()) -> Reference w r MU MU s t a b

-- | A two-way <a>Reference</a> that represents an isomorphism between two
--   datatypes. Can be used to access the same data in two different
--   representations.
type Iso s t a b = forall w r w' r'. (RefMonads w r, RefMonads w' r') => Reference w r w' r' s t a b

-- | A <a>Reference</a> that can access a part of data that exists in the
--   context. Every well-formed <a>Reference</a> is a <a>Lens</a>.
type Lens s t a b = forall w r. RefMonads w r => Reference w r MU MU s t a b

-- | Partial lens. A <a>Reference</a> that can access data that may not
--   exist in the context. Every lens is a partial lens.
--   
--   Any reference that is a partial lens should only perform the action
--   given to its <tt>updateRef</tt> function if it can get a value (the
--   value returned by <tt>getRef</tt> is not the lifted form of
--   <a>Nothing</a>).
type Partial s t a b = forall w r. (Functor w, Applicative w, Monad w, Functor r, Applicative r, MonadPlus r, MMorph Maybe r) => Reference w r MU MU s t a b

-- | A reference that can access data that is available in a number of
--   instances inside the contexts.
--   
--   Any reference that is a <a>Traversal</a> should perform the action
--   given to its updater in the exactly the same number of times that is
--   the number of the values returned by it's <tt>getRef</tt> function.
type Traversal s t a b = forall w r. (RefMonads w r, MonadPlus r, MMorph Maybe r, MMorph [] r) => Reference w r MU MU s t a b

-- | Strict lens. A <a>Reference</a> that must access a part of data that
--   surely exists in the context.
type Lens' = Reference Identity Identity MU MU

-- | Strict partial lens. A <a>Reference</a> that must access data that may
--   not exist in the context.
type Partial' = Reference Identity Maybe MU MU

-- | Strict traversal. A reference that must access data that is available
--   in a number of instances inside the context.
type Traversal' = Reference Identity [] MU MU

-- | A reference that can access mutable data.
type IOLens s t a b = forall w r. (RefMonads w r, IOMonads w r) => Reference w r MU MU s t a b

-- | A reference that can access mutable data that may not exist in the
--   context.
type IOPartial s t a b = forall w r. (RefMonads w r, IOMonads w r, MonadPlus r, MMorph Maybe r) => Reference w r MU MU s t a b
type IOTraversal s t a b = forall w r. (RefMonads w r, IOMonads w r, MonadPlus r, MMorph Maybe r, MMorph [] r) => Reference w r MU MU s t a b

-- | A reference that must access mutable data that is available in the
--   context.
type IOLens' = Reference IO IO MU MU

-- | A reference that must access mutable data that may not exist in the
--   context.
type IOPartial' = Reference IO (MaybeT IO) MU MU

-- | A reference that can access mutable data that is available in a number
--   of instances inside the contexts.
type IOTraversal' = Reference IO (ListT IO) MU MU

-- | A reference that can access a value inside a <a>StateT</a> transformed
--   monad.
type StateLens st m s t a b = forall w r. (RefMonads w r, MMorph (StateT st m) w, MMorph (StateT st m) r) => Reference w r MU MU s t a b

-- | A reference that can access a value inside a <a>StateT</a> transformed
--   monad that may not exist.
type StatePartial st m s t a b = forall w r. (RefMonads w r, MMorph (StateT st m) w, MonadPlus r, MMorph Maybe r, MMorph (StateT st m) r) => Reference w r MU MU s t a b

-- | A reference that can access a value inside a <a>StateT</a> transformed
--   monad that may exist in multiple instances.
type StateTraversal st m s t a b = forall w r. (RefMonads w r, MMorph (StateT st m) w, MonadPlus r, MMorph Maybe r, MMorph [] r, MMorph (StateT st m) r) => Reference w r MU MU s t a b

-- | A reference that must access a value inside a <a>StateT</a>
--   transformed monad.
type StateLens' s m = Reference (StateT s m) (StateT s m) MU MU

-- | A reference that must access a value inside a <a>StateT</a>
--   transformed monad that may not exist.
type StatePartial' s m = Reference (StateT s m) (MaybeT (StateT s m)) MU MU

-- | A reference that must access a value inside a <a>StateT</a>
--   transformed monad that may exist in multiple instances.
type StateTraversal' s m = Reference (StateT s m) (ListT (StateT s m)) MU MU

-- | A reference that can access a value inside a <a>WriterT</a>
--   transformed monad.
type WriterLens st m s t a b = forall w r. (RefMonads w r, MMorph (WriterT st m) w, MMorph (WriterT st m) r) => Reference w r MU MU s t a b

-- | A reference that can access a value inside a <a>WriterT</a>
--   transformed monad that may not exist.
type WriterPartial st m s t a b = forall w r. (RefMonads w r, MMorph (WriterT st m) w, MonadPlus r, MMorph Maybe r, MMorph (WriterT st m) r) => Reference w r MU MU s t a b

-- | A reference that can access a value inside a <tt>WriteT</tt>
--   transformed monad that may exist in multiple instances.
type WriterTraversal st m s t a b = forall w r. (RefMonads w r, MMorph (WriterT st m) w, MonadPlus r, MMorph Maybe r, MMorph [] r, MMorph (WriterT st m) r) => Reference w r MU MU s t a b

-- | A reference that must access a value inside a <a>WriterT</a>
--   transformed monad.
type WriterLens' s m = Reference (WriterT s m) (WriterT s m) MU MU

-- | A reference that must access a value inside a <tt>WriteT</tt>
--   transformed monad that may not exist.
type WriterPartial' s m = Reference (WriterT s m) (MaybeT (WriterT s m)) MU MU

-- | A reference that must access a value inside a <tt>WriteT</tt>
--   transformed monad that may exist in multiple instances.
type WriterTraversal' s m = Reference (WriterT s m) (ListT (WriterT s m)) MU MU

-- | States that <tt>m1</tt> can be represented with <tt>m2</tt>. That is
--   because <tt>m2</tt> contains more infromation than <tt>m1</tt>.
--   
--   The <a>MMorph</a> relation defines a natural transformation from
--   <tt>m1</tt> to <tt>m2</tt> that keeps the following laws:
--   
--   <pre>
--   morph (return x)  =  return x
--   morph (m &gt;&gt;= f)   =  morph m &gt;&gt;= morph . f
--   </pre>
--   
--   It is a reflexive and transitive relation.
class MMorph (m1 :: * -> *) (m2 :: * -> *)
morph :: MMorph m1 m2 => m1 a -> m2 a


-- | A basic set of instances derived using
--   <a>Control.Reference.TH.Monad</a>.
--   
--   <h2>Structure defined</h2>
--   
--   <pre>
--        <a>ListT</a> <a>IO</a>
--       /         \
--     []       <a>MaybeT</a> <a>IO</a>
--     |      /     |
--   <a>Maybe</a>         <a>IO</a>
--        \       /
--        <a>Identity</a>
--   </pre>
module Control.Reference.TH.MonadInstances
instance Monad m => MMorph (StateT s m) (ListT (StateT s m))
instance (Monad m, Monoid s) => MMorph Maybe (ListT (WriterT s m))
instance (Monad m, Monoid s) => MMorph [] (ListT (WriterT s m))
instance Monad m => MMorph Maybe (ListT (StateT s m))
instance Monad m => MMorph [] (ListT (StateT s m))
instance MMorph (MaybeT IO) (ListT IO)
instance MMorph Maybe (ListT IO)
instance MMorph [] (ListT IO)
instance MMorph (ListT IO) (ListT IO)
instance MMorph Maybe (MaybeT IO)
instance MMorph (MaybeT IO) (MaybeT IO)
instance MMorph Identity (MaybeT IO)
instance MMorph Identity (ListT IO)
instance MMorph Identity IO
instance MMorph Identity Identity


-- | A module for creating lenses to fields of simple, tuple data
--   structures like pairs, triplets, and so on.
module Control.Reference.TH.Tuple

-- | A tuple configuration is a scheme for tuple-like data structures.
data TupleConf
TupleConf :: ([Name] -> Type) -> ([Name] -> Pat) -> ([Name] -> Exp) -> TupleConf
tupleType :: TupleConf -> [Name] -> Type
tuplePattern :: TupleConf -> [Name] -> Pat
tupleExpr :: TupleConf -> [Name] -> Exp

-- | Generates the normal haskell tuples (<tt>(a,b), (a,b,c),
--   (a,b,c,d)</tt>)
hsTupConf :: TupleConf

-- | Creates <tt>Lens_1</tt> ... <tt>Lens_n</tt> classes, and instances for
--   tuples up to <tt>m</tt>.
--   
--   Classes and instances look like the following:
--   
--   <pre>
--   class Lens_1 s t a b | s -&gt; a, t -&gt; b
--                        , a t -&gt; s, b s -&gt; t where 
--     _1 :: Lens s t a b
--   
--   instance Lens_1 (a,b) (a',b) a a' where 
--     _1 = lens ((a,b) -&gt; a) (a' (a,b) -&gt; (a',b))
--   </pre>
makeTupleRefs :: TupleConf -> Int -> Int -> Q [Dec]


-- | A module where tuple classes and instances are created up to 16-tuple
--   using <a>makeTupleRefs</a>. The number of classes and instances can be
--   changed by hiding import from this module and calling
--   <a>makeTupleRefs</a> in an other module.
module Control.Reference.TupleInstances
class Lens_1 s_ah2i t_ah2j a_ah2k b1_ah2l | s_ah2i -> a_ah2k, t_ah2j -> b1_ah2l, a_ah2k t_ah2j -> s_ah2i, b1_ah2l s_ah2i -> t_ah2j
_1 :: Lens_1 s_ah2i t_ah2j a_ah2k b1_ah2l => Lens s_ah2i t_ah2j a_ah2k b1_ah2l
class Lens_2 s_ah2m t_ah2n a_ah2o b1_ah2p | s_ah2m -> a_ah2o, t_ah2n -> b1_ah2p, a_ah2o t_ah2n -> s_ah2m, b1_ah2p s_ah2m -> t_ah2n
_2 :: Lens_2 s_ah2m t_ah2n a_ah2o b1_ah2p => Lens s_ah2m t_ah2n a_ah2o b1_ah2p
class Lens_3 s_ah2q t_ah2r a_ah2s b1_ah2t | s_ah2q -> a_ah2s, t_ah2r -> b1_ah2t, a_ah2s t_ah2r -> s_ah2q, b1_ah2t s_ah2q -> t_ah2r
_3 :: Lens_3 s_ah2q t_ah2r a_ah2s b1_ah2t => Lens s_ah2q t_ah2r a_ah2s b1_ah2t
class Lens_4 s_ah2u t_ah2v a_ah2w b1_ah2x | s_ah2u -> a_ah2w, t_ah2v -> b1_ah2x, a_ah2w t_ah2v -> s_ah2u, b1_ah2x s_ah2u -> t_ah2v
_4 :: Lens_4 s_ah2u t_ah2v a_ah2w b1_ah2x => Lens s_ah2u t_ah2v a_ah2w b1_ah2x
class Lens_5 s_ah2y t_ah2z a_ah2A b1_ah2B | s_ah2y -> a_ah2A, t_ah2z -> b1_ah2B, a_ah2A t_ah2z -> s_ah2y, b1_ah2B s_ah2y -> t_ah2z
_5 :: Lens_5 s_ah2y t_ah2z a_ah2A b1_ah2B => Lens s_ah2y t_ah2z a_ah2A b1_ah2B
class Lens_6 s_ah2C t_ah2D a_ah2E b1_ah2F | s_ah2C -> a_ah2E, t_ah2D -> b1_ah2F, a_ah2E t_ah2D -> s_ah2C, b1_ah2F s_ah2C -> t_ah2D
_6 :: Lens_6 s_ah2C t_ah2D a_ah2E b1_ah2F => Lens s_ah2C t_ah2D a_ah2E b1_ah2F
class Lens_7 s_ah2G t_ah2H a_ah2I b1_ah2J | s_ah2G -> a_ah2I, t_ah2H -> b1_ah2J, a_ah2I t_ah2H -> s_ah2G, b1_ah2J s_ah2G -> t_ah2H
_7 :: Lens_7 s_ah2G t_ah2H a_ah2I b1_ah2J => Lens s_ah2G t_ah2H a_ah2I b1_ah2J
class Lens_8 s_ah2K t_ah2L a_ah2M b1_ah2N | s_ah2K -> a_ah2M, t_ah2L -> b1_ah2N, a_ah2M t_ah2L -> s_ah2K, b1_ah2N s_ah2K -> t_ah2L
_8 :: Lens_8 s_ah2K t_ah2L a_ah2M b1_ah2N => Lens s_ah2K t_ah2L a_ah2M b1_ah2N
class Lens_9 s_ah2O t_ah2P a_ah2Q b1_ah2R | s_ah2O -> a_ah2Q, t_ah2P -> b1_ah2R, a_ah2Q t_ah2P -> s_ah2O, b1_ah2R s_ah2O -> t_ah2P
_9 :: Lens_9 s_ah2O t_ah2P a_ah2Q b1_ah2R => Lens s_ah2O t_ah2P a_ah2Q b1_ah2R
class Lens_10 s_ah2S t_ah2T a_ah2U b1_ah2V | s_ah2S -> a_ah2U, t_ah2T -> b1_ah2V, a_ah2U t_ah2T -> s_ah2S, b1_ah2V s_ah2S -> t_ah2T
_10 :: Lens_10 s_ah2S t_ah2T a_ah2U b1_ah2V => Lens s_ah2S t_ah2T a_ah2U b1_ah2V
class Lens_11 s_ah2W t_ah2X a_ah2Y b1_ah2Z | s_ah2W -> a_ah2Y, t_ah2X -> b1_ah2Z, a_ah2Y t_ah2X -> s_ah2W, b1_ah2Z s_ah2W -> t_ah2X
_11 :: Lens_11 s_ah2W t_ah2X a_ah2Y b1_ah2Z => Lens s_ah2W t_ah2X a_ah2Y b1_ah2Z
class Lens_12 s_ah30 t_ah31 a_ah32 b1_ah33 | s_ah30 -> a_ah32, t_ah31 -> b1_ah33, a_ah32 t_ah31 -> s_ah30, b1_ah33 s_ah30 -> t_ah31
_12 :: Lens_12 s_ah30 t_ah31 a_ah32 b1_ah33 => Lens s_ah30 t_ah31 a_ah32 b1_ah33
class Lens_13 s_ah34 t_ah35 a_ah36 b1_ah37 | s_ah34 -> a_ah36, t_ah35 -> b1_ah37, a_ah36 t_ah35 -> s_ah34, b1_ah37 s_ah34 -> t_ah35
_13 :: Lens_13 s_ah34 t_ah35 a_ah36 b1_ah37 => Lens s_ah34 t_ah35 a_ah36 b1_ah37
class Lens_14 s_ah38 t_ah39 a_ah3a b1_ah3b | s_ah38 -> a_ah3a, t_ah39 -> b1_ah3b, a_ah3a t_ah39 -> s_ah38, b1_ah3b s_ah38 -> t_ah39
_14 :: Lens_14 s_ah38 t_ah39 a_ah3a b1_ah3b => Lens s_ah38 t_ah39 a_ah3a b1_ah3b
class Lens_15 s_ah3c t_ah3d a_ah3e b1_ah3f | s_ah3c -> a_ah3e, t_ah3d -> b1_ah3f, a_ah3e t_ah3d -> s_ah3c, b1_ah3f s_ah3c -> t_ah3d
_15 :: Lens_15 s_ah3c t_ah3d a_ah3e b1_ah3f => Lens s_ah3c t_ah3d a_ah3e b1_ah3f
class Lens_16 s_ah3g t_ah3h a_ah3i b1_ah3j | s_ah3g -> a_ah3i, t_ah3h -> b1_ah3j, a_ah3i t_ah3h -> s_ah3g, b1_ah3j s_ah3g -> t_ah3h
_16 :: Lens_16 s_ah3g t_ah3h a_ah3i b1_ah3j => Lens s_ah3g t_ah3h a_ah3i b1_ah3j
instance Lens_16 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, b20) a15 b20
instance Lens_15 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, b20, a15) a14 b20
instance Lens_15 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, b20) a14 b20
instance Lens_14 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, b20, a14, a15) a13 b20
instance Lens_14 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, b20, a14) a13 b20
instance Lens_14 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, b20) a13 b20
instance Lens_13 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, b20, a13, a14, a15) a12 b20
instance Lens_13 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, b20, a13, a14) a12 b20
instance Lens_13 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, b20, a13) a12 b20
instance Lens_13 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, b20) a12 b20
instance Lens_12 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, b20, a12, a13, a14, a15) a11 b20
instance Lens_12 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, b20, a12, a13, a14) a11 b20
instance Lens_12 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, b20, a12, a13) a11 b20
instance Lens_12 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, b20, a12) a11 b20
instance Lens_12 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, b20) a11 b20
instance Lens_11 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, b20, a11, a12, a13, a14, a15) a10 b20
instance Lens_11 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, b20, a11, a12, a13, a14) a10 b20
instance Lens_11 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, b20, a11, a12, a13) a10 b20
instance Lens_11 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, b20, a11, a12) a10 b20
instance Lens_11 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, b20, a11) a10 b20
instance Lens_11 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, b20) a10 b20
instance Lens_10 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) (a0, a1, a2, a3, a4, a5, a6, a7, a8, b20, a10, a11, a12, a13, a14, a15) a9 b20
instance Lens_10 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) (a0, a1, a2, a3, a4, a5, a6, a7, a8, b20, a10, a11, a12, a13, a14) a9 b20
instance Lens_10 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) (a0, a1, a2, a3, a4, a5, a6, a7, a8, b20, a10, a11, a12, a13) a9 b20
instance Lens_10 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) (a0, a1, a2, a3, a4, a5, a6, a7, a8, b20, a10, a11, a12) a9 b20
instance Lens_10 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) (a0, a1, a2, a3, a4, a5, a6, a7, a8, b20, a10, a11) a9 b20
instance Lens_10 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) (a0, a1, a2, a3, a4, a5, a6, a7, a8, b20, a10) a9 b20
instance Lens_10 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) (a0, a1, a2, a3, a4, a5, a6, a7, a8, b20) a9 b20
instance Lens_9 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) (a0, a1, a2, a3, a4, a5, a6, a7, b20, a9, a10, a11, a12, a13, a14, a15) a8 b20
instance Lens_9 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) (a0, a1, a2, a3, a4, a5, a6, a7, b20, a9, a10, a11, a12, a13, a14) a8 b20
instance Lens_9 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) (a0, a1, a2, a3, a4, a5, a6, a7, b20, a9, a10, a11, a12, a13) a8 b20
instance Lens_9 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) (a0, a1, a2, a3, a4, a5, a6, a7, b20, a9, a10, a11, a12) a8 b20
instance Lens_9 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) (a0, a1, a2, a3, a4, a5, a6, a7, b20, a9, a10, a11) a8 b20
instance Lens_9 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) (a0, a1, a2, a3, a4, a5, a6, a7, b20, a9, a10) a8 b20
instance Lens_9 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) (a0, a1, a2, a3, a4, a5, a6, a7, b20, a9) a8 b20
instance Lens_9 (a0, a1, a2, a3, a4, a5, a6, a7, a8) (a0, a1, a2, a3, a4, a5, a6, a7, b20) a8 b20
instance Lens_8 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) (a0, a1, a2, a3, a4, a5, a6, b20, a8, a9, a10, a11, a12, a13, a14, a15) a7 b20
instance Lens_8 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) (a0, a1, a2, a3, a4, a5, a6, b20, a8, a9, a10, a11, a12, a13, a14) a7 b20
instance Lens_8 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) (a0, a1, a2, a3, a4, a5, a6, b20, a8, a9, a10, a11, a12, a13) a7 b20
instance Lens_8 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) (a0, a1, a2, a3, a4, a5, a6, b20, a8, a9, a10, a11, a12) a7 b20
instance Lens_8 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) (a0, a1, a2, a3, a4, a5, a6, b20, a8, a9, a10, a11) a7 b20
instance Lens_8 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) (a0, a1, a2, a3, a4, a5, a6, b20, a8, a9, a10) a7 b20
instance Lens_8 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) (a0, a1, a2, a3, a4, a5, a6, b20, a8, a9) a7 b20
instance Lens_8 (a0, a1, a2, a3, a4, a5, a6, a7, a8) (a0, a1, a2, a3, a4, a5, a6, b20, a8) a7 b20
instance Lens_8 (a0, a1, a2, a3, a4, a5, a6, a7) (a0, a1, a2, a3, a4, a5, a6, b20) a7 b20
instance Lens_7 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) (a0, a1, a2, a3, a4, a5, b20, a7, a8, a9, a10, a11, a12, a13, a14, a15) a6 b20
instance Lens_7 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) (a0, a1, a2, a3, a4, a5, b20, a7, a8, a9, a10, a11, a12, a13, a14) a6 b20
instance Lens_7 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) (a0, a1, a2, a3, a4, a5, b20, a7, a8, a9, a10, a11, a12, a13) a6 b20
instance Lens_7 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) (a0, a1, a2, a3, a4, a5, b20, a7, a8, a9, a10, a11, a12) a6 b20
instance Lens_7 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) (a0, a1, a2, a3, a4, a5, b20, a7, a8, a9, a10, a11) a6 b20
instance Lens_7 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) (a0, a1, a2, a3, a4, a5, b20, a7, a8, a9, a10) a6 b20
instance Lens_7 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) (a0, a1, a2, a3, a4, a5, b20, a7, a8, a9) a6 b20
instance Lens_7 (a0, a1, a2, a3, a4, a5, a6, a7, a8) (a0, a1, a2, a3, a4, a5, b20, a7, a8) a6 b20
instance Lens_7 (a0, a1, a2, a3, a4, a5, a6, a7) (a0, a1, a2, a3, a4, a5, b20, a7) a6 b20
instance Lens_7 (a0, a1, a2, a3, a4, a5, a6) (a0, a1, a2, a3, a4, a5, b20) a6 b20
instance Lens_6 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) (a0, a1, a2, a3, a4, b20, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) a5 b20
instance Lens_6 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) (a0, a1, a2, a3, a4, b20, a6, a7, a8, a9, a10, a11, a12, a13, a14) a5 b20
instance Lens_6 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) (a0, a1, a2, a3, a4, b20, a6, a7, a8, a9, a10, a11, a12, a13) a5 b20
instance Lens_6 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) (a0, a1, a2, a3, a4, b20, a6, a7, a8, a9, a10, a11, a12) a5 b20
instance Lens_6 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) (a0, a1, a2, a3, a4, b20, a6, a7, a8, a9, a10, a11) a5 b20
instance Lens_6 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) (a0, a1, a2, a3, a4, b20, a6, a7, a8, a9, a10) a5 b20
instance Lens_6 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) (a0, a1, a2, a3, a4, b20, a6, a7, a8, a9) a5 b20
instance Lens_6 (a0, a1, a2, a3, a4, a5, a6, a7, a8) (a0, a1, a2, a3, a4, b20, a6, a7, a8) a5 b20
instance Lens_6 (a0, a1, a2, a3, a4, a5, a6, a7) (a0, a1, a2, a3, a4, b20, a6, a7) a5 b20
instance Lens_6 (a0, a1, a2, a3, a4, a5, a6) (a0, a1, a2, a3, a4, b20, a6) a5 b20
instance Lens_6 (a0, a1, a2, a3, a4, a5) (a0, a1, a2, a3, a4, b20) a5 b20
instance Lens_5 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) (a0, a1, a2, a3, b20, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) a4 b20
instance Lens_5 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) (a0, a1, a2, a3, b20, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) a4 b20
instance Lens_5 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) (a0, a1, a2, a3, b20, a5, a6, a7, a8, a9, a10, a11, a12, a13) a4 b20
instance Lens_5 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) (a0, a1, a2, a3, b20, a5, a6, a7, a8, a9, a10, a11, a12) a4 b20
instance Lens_5 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) (a0, a1, a2, a3, b20, a5, a6, a7, a8, a9, a10, a11) a4 b20
instance Lens_5 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) (a0, a1, a2, a3, b20, a5, a6, a7, a8, a9, a10) a4 b20
instance Lens_5 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) (a0, a1, a2, a3, b20, a5, a6, a7, a8, a9) a4 b20
instance Lens_5 (a0, a1, a2, a3, a4, a5, a6, a7, a8) (a0, a1, a2, a3, b20, a5, a6, a7, a8) a4 b20
instance Lens_5 (a0, a1, a2, a3, a4, a5, a6, a7) (a0, a1, a2, a3, b20, a5, a6, a7) a4 b20
instance Lens_5 (a0, a1, a2, a3, a4, a5, a6) (a0, a1, a2, a3, b20, a5, a6) a4 b20
instance Lens_5 (a0, a1, a2, a3, a4, a5) (a0, a1, a2, a3, b20, a5) a4 b20
instance Lens_5 (a0, a1, a2, a3, a4) (a0, a1, a2, a3, b20) a4 b20
instance Lens_4 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) (a0, a1, a2, b20, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) a3 b20
instance Lens_4 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) (a0, a1, a2, b20, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) a3 b20
instance Lens_4 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) (a0, a1, a2, b20, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) a3 b20
instance Lens_4 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) (a0, a1, a2, b20, a4, a5, a6, a7, a8, a9, a10, a11, a12) a3 b20
instance Lens_4 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) (a0, a1, a2, b20, a4, a5, a6, a7, a8, a9, a10, a11) a3 b20
instance Lens_4 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) (a0, a1, a2, b20, a4, a5, a6, a7, a8, a9, a10) a3 b20
instance Lens_4 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) (a0, a1, a2, b20, a4, a5, a6, a7, a8, a9) a3 b20
instance Lens_4 (a0, a1, a2, a3, a4, a5, a6, a7, a8) (a0, a1, a2, b20, a4, a5, a6, a7, a8) a3 b20
instance Lens_4 (a0, a1, a2, a3, a4, a5, a6, a7) (a0, a1, a2, b20, a4, a5, a6, a7) a3 b20
instance Lens_4 (a0, a1, a2, a3, a4, a5, a6) (a0, a1, a2, b20, a4, a5, a6) a3 b20
instance Lens_4 (a0, a1, a2, a3, a4, a5) (a0, a1, a2, b20, a4, a5) a3 b20
instance Lens_4 (a0, a1, a2, a3, a4) (a0, a1, a2, b20, a4) a3 b20
instance Lens_4 (a0, a1, a2, a3) (a0, a1, a2, b20) a3 b20
instance Lens_3 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) (a0, a1, b20, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) a2 b20
instance Lens_3 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) (a0, a1, b20, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) a2 b20
instance Lens_3 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) (a0, a1, b20, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) a2 b20
instance Lens_3 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) (a0, a1, b20, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) a2 b20
instance Lens_3 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) (a0, a1, b20, a3, a4, a5, a6, a7, a8, a9, a10, a11) a2 b20
instance Lens_3 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) (a0, a1, b20, a3, a4, a5, a6, a7, a8, a9, a10) a2 b20
instance Lens_3 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) (a0, a1, b20, a3, a4, a5, a6, a7, a8, a9) a2 b20
instance Lens_3 (a0, a1, a2, a3, a4, a5, a6, a7, a8) (a0, a1, b20, a3, a4, a5, a6, a7, a8) a2 b20
instance Lens_3 (a0, a1, a2, a3, a4, a5, a6, a7) (a0, a1, b20, a3, a4, a5, a6, a7) a2 b20
instance Lens_3 (a0, a1, a2, a3, a4, a5, a6) (a0, a1, b20, a3, a4, a5, a6) a2 b20
instance Lens_3 (a0, a1, a2, a3, a4, a5) (a0, a1, b20, a3, a4, a5) a2 b20
instance Lens_3 (a0, a1, a2, a3, a4) (a0, a1, b20, a3, a4) a2 b20
instance Lens_3 (a0, a1, a2, a3) (a0, a1, b20, a3) a2 b20
instance Lens_3 (a0, a1, a2) (a0, a1, b20) a2 b20
instance Lens_2 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) (a0, b20, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) a1 b20
instance Lens_2 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) (a0, b20, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) a1 b20
instance Lens_2 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) (a0, b20, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) a1 b20
instance Lens_2 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) (a0, b20, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) a1 b20
instance Lens_2 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) (a0, b20, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) a1 b20
instance Lens_2 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) (a0, b20, a2, a3, a4, a5, a6, a7, a8, a9, a10) a1 b20
instance Lens_2 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) (a0, b20, a2, a3, a4, a5, a6, a7, a8, a9) a1 b20
instance Lens_2 (a0, a1, a2, a3, a4, a5, a6, a7, a8) (a0, b20, a2, a3, a4, a5, a6, a7, a8) a1 b20
instance Lens_2 (a0, a1, a2, a3, a4, a5, a6, a7) (a0, b20, a2, a3, a4, a5, a6, a7) a1 b20
instance Lens_2 (a0, a1, a2, a3, a4, a5, a6) (a0, b20, a2, a3, a4, a5, a6) a1 b20
instance Lens_2 (a0, a1, a2, a3, a4, a5) (a0, b20, a2, a3, a4, a5) a1 b20
instance Lens_2 (a0, a1, a2, a3, a4) (a0, b20, a2, a3, a4) a1 b20
instance Lens_2 (a0, a1, a2, a3) (a0, b20, a2, a3) a1 b20
instance Lens_2 (a0, a1, a2) (a0, b20, a2) a1 b20
instance Lens_2 (a0, a1) (a0, b20) a1 b20
instance Lens_1 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) (b20, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) a0 b20
instance Lens_1 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) (b20, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) a0 b20
instance Lens_1 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) (b20, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) a0 b20
instance Lens_1 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) (b20, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) a0 b20
instance Lens_1 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) (b20, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) a0 b20
instance Lens_1 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) (b20, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) a0 b20
instance Lens_1 (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) (b20, a1, a2, a3, a4, a5, a6, a7, a8, a9) a0 b20
instance Lens_1 (a0, a1, a2, a3, a4, a5, a6, a7, a8) (b20, a1, a2, a3, a4, a5, a6, a7, a8) a0 b20
instance Lens_1 (a0, a1, a2, a3, a4, a5, a6, a7) (b20, a1, a2, a3, a4, a5, a6, a7) a0 b20
instance Lens_1 (a0, a1, a2, a3, a4, a5, a6) (b20, a1, a2, a3, a4, a5, a6) a0 b20
instance Lens_1 (a0, a1, a2, a3, a4, a5) (b20, a1, a2, a3, a4, a5) a0 b20
instance Lens_1 (a0, a1, a2, a3, a4) (b20, a1, a2, a3, a4) a0 b20
instance Lens_1 (a0, a1, a2, a3) (b20, a1, a2, a3) a0 b20
instance Lens_1 (a0, a1, a2) (b20, a1, a2) a0 b20
instance Lens_1 (a0, a1) (b20, a1) a0 b20

module Control.Reference.Predefined.Containers.Tree
instance Association (Tree v)


-- | An example module that adds references for Template Haskell. These
--   references are used to create the TH functions that generate
--   references.
module Control.Reference.Examples.TH

-- | Reference all type variables inside a type
typeVariableNames :: Simple Traversal Type Name

-- | Reference the name of the type variable
typeVar :: Simple Partial Type Name

-- | Reference all type variables inside a type
typeVariables :: Simple Traversal Type Type

-- | Reference all type variables not binded by a forall
freeTypeVariables :: Simple Traversal Type Type

-- | Reference the name of the type variable inside a type variable binder
typeVarName :: Simple Lens TyVarBndr Name

-- | Reference the characters of the name. If changed there is no guarantee
--   that the created name will be unique.
nameBaseStr :: Simple Lens Name String

-- | Reference the record fields in a constructor.
recFields :: Simple Partial Con [(Name, Strict, Type)]

-- | Reference all fields (data members) in a constructor.
conFields :: Simple Lens Con [(Strict, Type)]

-- | Reference types of fields
conTypes :: Simple Traversal Con Type

-- | Reference the name of the constructor
conName :: Simple Lens Con Name

-- | Access a function application as a list of expressions with the
--   function application at the head of the list and the arguments on it's
--   tail.
funApplication :: Simple Iso Exp [Exp]

-- | Accesses the name of the defined object. Does not return name in
--   signatures.
definedName :: Simple Partial Dec Name

-- | Accesses the constructors of a data or newtype definition. After
--   changing the definition becames a newtype if there is only one
--   constructor.
definedConstructors :: Simple Partial Dec [Con]

-- | Accesses the type variables of a definition
definedTypeArgs :: Simple Partial Dec [TyVarBndr]


-- | This module can be used to generate references for record fields. If
--   the field surely exists, a <a>Lens</a> will be generated. If the field
--   may not exist, it will be a <a>Partial</a> lens.
--   
--   It will have the maximum amount of polymorphism it can create.
--   
--   If the name of the field starts with "_", the name of the field will
--   be the same with "_" removed. If not, the reference name will be the
--   field name with "_" added te the start.
--   
--   The following code sample:
--   
--   <pre>
--   data Maybe' a = Just' { _fromJust' :: a }
--                 | Nothing'
--   $(makeReferences ''Maybe)
--   
--   data Tuple a b = Tuple { _fst' :: a, _snd' :: b }
--   $(makeReferences ''Tuple)
--   </pre>
--   
--   Is equivalent to:
--   
--   <pre>
--   data Maybe' a = Just' { _fromJust' :: a }
--                 | Nothing'
--                 
--   fromJust' :: <a>Partial</a> (Maybe' a) (Maybe' b) a b
--   fromJust' = <a>partial</a> (case Just' x -&gt; Right (x, y -&gt; return (Just' y))
--                              Nothing' -&gt; Left (return Nothing'))
--   
--   data Tuple a b = Tuple { _fst' :: a, _snd' :: b }
--   fst' :: <a>Lens</a> (Tuple a c) (Tuple b c) a b
--   fst' = <a>lens</a> _fst' (b tup -&gt; tup { _fst' = b })
--   snd' :: <a>Lens</a> (Tuple a c) (Tuple a d) c d
--   snd' = <a>lens</a> _snd' (b tup -&gt; tup { _snd' = b })
--   </pre>
module Control.Reference.TH.Records

-- | Creates references for fields of a data structure.
makeReferences :: Name -> Q [Dec]

-- | Shows the generated declarations instead of using them.
debugTH :: Q [Dec] -> Q [Dec]


-- | A frontend module for the Control.Reference package
module Control.Reference
