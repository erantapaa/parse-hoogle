-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | cryptanalysis of Blizzard's broken SHA-1 implementation.
--   
--   Caution: XSHA1 is weak, and should not be used as a hash.
--   
--   XSHA1 is used in password and CD key authentication in older Blizzard
--   games (Starcraft, Diablo 2) among other things. The fact that it's
--   cryptographically weak has been known for years: this is a public
--   analysis of the weakness. The goal is to determine risk posed to
--   users, and find safeguards if possible.
--   
--   The code is geared for rapid interactive development with GHCI. Excuse
--   the lax conventions.
--   
--   Data.Digest.* implements and explores XSHA1, while Data.Codec.*
--   contains applications.
@package xsha1
@version 0.0.0


-- | Arithmetic taint tracking.
--   
--   Extension of Word32, that allows <a>U</a>nknown values to be used.
--   Operations on known values are calculated as usual, while operations
--   on unknowns are recorded in unsimplified form.
--   
--   <pre>
--   &gt;&gt;&gt; let e = 1+5 `xor` U `lshift` 2
--   
--   &gt;&gt;&gt; e
--   X Xor (N 6) (X LShift U (N 2))
--   
--   &gt;&gt;&gt; pprint e
--   "(6^(?&lt;&lt;2))"
--   
--   &gt;&gt;&gt; 1+5 `xor` 0xBEEF `lshift` 2
--   N 195514
--   </pre>
--   
--   Intended for analysis of XSHA-1, so only supports the necessary
--   primitives.
module Numeric.Taint.Word32

-- | A numeric type extended to hold information about unknown values.
data N

-- | Numbers are still present.
N :: Word32 -> N

-- | Unknown values are marked with X.
U :: N

-- | Operations can be piled on top of them.
X :: Op -> N -> N -> N

-- | Supported operators.
data Op
LShift :: Op
Xor :: Op
Or :: Op
And :: Op
Add :: Op
Sub :: Op
Rot :: Op

-- | Infix notation display of stored operations.
pprint :: N -> String

-- | The shift in the Bits class doesn't allow non-int shifts.
--   
--   We'll be shifting by Unknown values, so have to use custom stuff.
--   
--   Also we're following VC++ compiler behaviour, and shifting in modulo
--   32 for 32 bit unsigned numbers. This behaviour is undefined in the C
--   standard.
lshift :: N -> N -> N
instance Typeable Op
instance Typeable N
instance Eq Op
instance Ord Op
instance Show Op
instance Data Op
instance Eq N
instance Ord N
instance Show N
instance Data N
instance Bits N
instance Num N


-- | Extension stage of XSHA1.
--   
--   In SHA-1, it follows padding. XSHA1 doesn't pad, just zeros.
module Data.Digest.XSHA1.Extend

-- | Take a 16 DWORD list, and extend it to 80 DWORDS based on itself.
extend :: Vector N -> Vector N


-- | Compression stage. Padding - extension - compression.
--   
--   See <a>http://en.wikipedia.org/wiki/Sha1</a> for the real thing.
--   
--   Forward and reverse of a single round is implemented, to perform the
--   full thing just foldl over [0..79].
module Data.Digest.XSHA1.Compress
type Regs = (N, N, N, N, N)

-- | Initial values for registers a..e.
--   
--   Also get added to the registers at the end.
consts :: Regs

-- | Round function f, with round number and three of the registers.
f :: Int -> N -> N -> N -> N

-- | Round constant k.
k :: Int -> N

-- | One round of the XSHA1 compression function.
iter :: Vector N -> Regs -> Int -> Regs

-- | Inverse of the round function.
reti :: Vector N -> Regs -> Int -> Regs

-- | Does the last step, a weird addition thrown in for obfuscation.
finalize :: Regs -> Regs

-- | Inverse of <a>finalize</a>.
unfinalize :: Regs -> Regs
test :: IO ()
instance Arbitrary N


-- | Single-block implementation of XSHA-1.
--   
--   See no reason to implement multiple blocks.
module Data.Digest.XSHA1

-- | Single block of XSHA1.
xsha1 :: Vector N -> Regs

-- | Print 512 bit hash in hex.
hexp :: Regs -> IO ()

-- | Tests of known pairs, based on hash reverser's implementation.
test :: IO Counts
testEmpty :: Assertion
testOneLetter :: Assertion


-- | Exploring the CD key hash used to authenticate the game with
--   Battle.net.
module Data.Codec.Blizz.CDHash

-- | Data accessible to an attacker observing traffic. All plaintext.
--   
--   Only missing piece of CD key info is the private value, which gets
--   hashed.
data Sniff
Sniff :: Word32 -> Word32 -> Word32 -> Word32 -> Sniff

-- | nonce
snClientTok :: Sniff -> Word32

-- | nonce
snServerTok :: Sniff -> Word32

-- | decoded from key: 6 classic D2, 10 xpac D2 are common values
snProduct :: Sniff -> Word32

-- | decoded from key, server has mapping to the private value
snPublic :: Sniff -> Word32

-- | Sample D2 CD key hash buffer. XSHA1 of this is sent to the server.
hash :: Sniff -> N -> Vector N
sniff1, sniff2 :: Sniff
result1, result2 :: (N, N, N, N, N)

-- | Print infix equations for buffer.
view :: Vector N -> IO ()

-- | Classify DWORDs based on how much knowledge an eavesdropper has of
--   them.
--   
--   X = known value
--   
--   ? = unknown (32 bit CD key private value)
--   
--   # = depends on 5 LSBs of private value
classify :: Vector N -> String

-- | Possible hash buffer construction from data known to eavesdroper.
--   
--   Since most of the expanded buffer depends just on 5 secret bits, 32
--   different buffers will cover all the possibilities for all but one
--   DWORD. That DWORD is the private key value, and is unknown.
--   
--   Only the relevant 5 bits on the private value are set. It should be
--   re-set afterwards, to a better guess or and unknown.
space :: Sniff -> [Vector N]
setPriv :: N -> Vector N -> Vector N
test :: Regs

-- | Unknown value is the pivot point.
--   
--   Register states before and after it are marked alpha and beta. Beta
--   has 32 possible values. Alpha just one. Solve for 32 private values.
alpha :: Vector N -> Regs
beta :: Vector N -> Regs -> Regs
getUnk :: Regs -> Vector N -> N
guessedUnknowns :: Sniff -> Regs -> [N]

-- | Get private values from sniffed data.
--   
--   Some false positives, Binomial(n=31, p=1/32)
--   
--   Straightforward to encode back into human-readable CD key.
unhash :: Sniff -> (N, N, N, N, N) -> IO ()
printReg :: PrintfType t => (N, N, N, N, N) -> t

-- | Foldl that keeps history.
hfoldl :: (a -> t -> a) -> a -> [t] -> (a, [a])
instance Eq Sniff
instance Ord Sniff
instance Show Sniff
