-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Higher-order file applicator
--   
--   λtext is a general-purpose templating utility for text files.
--   
--   Turn plaintext files into lambdas - function application then becomes
--   concatenation.
--   
--   Please see the <a>github page</a> for more details.
--   
--   All credits go to Martin Grabmueller's <a>AlgorithmW</a> package for
--   the type inference algorithm used in λtext.
@package ltext
@version 0.0.2.1

module LText.Parser.Lexer
data ExprTokens
[TLamb] :: ExprTokens
[TArrow] :: ExprTokens
[TIdent] :: String -> ExprTokens
[TGroup] :: [ExprTokens] -> ExprTokens
[TLParen] :: ExprTokens
[TRParen] :: ExprTokens
data TokenState
[TokenState] :: String -> TokenState
[between] :: TokenState -> String
initTokenState :: TokenState
tokenize :: String -> [ExprTokens]
runGroup :: (Monad m, MonadError String m) => StateT Integer m a -> m a

-- | Matches brackets and nests token streams
group :: (MonadState Integer m) => ([ExprTokens], [ExprTokens]) -> m ([ExprTokens], [ExprTokens])
lexer :: (Monad m, MonadError String m) => String -> m [ExprTokens]
instance Show TokenState
instance Eq TokenState
instance Eq ExprTokens
instance Show ExprTokens

module LText.Internal.Classes
class SetLike (c :: * -> *)
empty :: SetLike c => c a
union :: (SetLike c, Ord a) => c a -> c a -> c a
intersection :: (SetLike c, Ord a) => c a -> c a -> c a
difference :: (SetLike c, Ord a) => c a -> c a -> c a
class (SetLike vars) => Bindable vars name a
fv :: Bindable vars name a => a -> vars name
class (SetLike (subst name)) => Substitutable subst name domain a
apply :: Substitutable subst name domain a => subst name domain -> a -> a
instance Ord k => SetLike (Map k)
instance SetLike Set
instance (Foldable f, Ord name, Bindable vars name a) => Bindable vars name (f a)
instance (Functor f, Substitutable subst name domain a) => Substitutable subst name domain (f a)

module LText.Internal.Expr
type Span = (FilePath, Text)
type ExprVar = String
data Expr
[EVar] :: ExprVar -> Expr
[EApp] :: Expr -> Expr -> Expr
[EAbs] :: ExprVar -> Expr -> Expr
[ELet] :: ExprVar -> Expr -> Expr -> Expr
[EText] :: [Span] -> Expr
[EConc] :: Expr -> Expr -> Expr

-- | Recursively checks to see if all <tt>EText</tt> constructors only
--   occur inside the <i>first</i> <tt>EAbs</tt> constructor via
--   <tt>EConc</tt> - if some are in <tt>EApp</tt>, for instance, then you
--   can't successfully <tt>render</tt> the expression.
litsAtTopLevel :: Expr -> Bool
prExp :: Expr -> Doc
prParenExp :: Expr -> Doc
instance Ord Expr
instance Eq Expr
instance Bindable Set ExprVar Expr
instance Substitutable Map ExprVar Expr Expr
instance Show Expr

module LText.Internal.Expr.TH
exprToHs :: Expr -> Q Exp

module LText.Parser.Expr
data ParseState
[ParseState] :: Bool -> Bool -> Maybe Expr -> ParseState
[inLambdaDec] :: ParseState -> Bool
[isFreshScope] :: ParseState -> Bool
[exprSoFar] :: ParseState -> Maybe Expr
initParseState :: ParseState
runParse :: (Monad m, MonadError String m) => StateT ParseState m a -> m a

-- | Parser for expressions. Note - cannot parse <tt>EConc</tt> or
--   <tt>EText</tt> constructors - they are implicit, and not considered in
--   evaluation.
parseExpr :: (MonadState ParseState m, MonadError String m) => [ExprTokens] -> m Expr
makeExpr :: (Monad m, MonadError String m) => String -> m Expr
instance Eq ParseState
instance Show ParseState

module LText.Parser.Document
type Var = String
type HeaderSchema = (String, [Var], String)
getHeader :: String -> Maybe HeaderSchema
parseDelim :: Monad m => (String, String) -> ParsecT Text u m String
parseDocument :: (MonadIO m, MonadError String m) => FilePath -> Text -> m Expr

module LText.Renderer
type Var = String
type HeaderSchema = (String, [Var], String)
showHeader :: HeaderSchema -> String

-- | turn head of template's arity into list - still need to render inner
--   expressions
renderHeaderSchema :: [String] -> (String, String) -> Expr -> (HeaderSchema, Expr)
render :: (Maybe String, Maybe String) -> Expr -> Text

-- | Note - only use post-beta reduction: this function is partial
hasArity :: Expr -> Bool

module LText.Internal.Types
type TypeVar = String
data Type
[TVar] :: TypeVar -> Type
[TFun] :: Type -> Type -> Type
[TText] :: Type
data Prenex
[Prenex] :: [TypeVar] -> Type -> Prenex
type Subst name domain = Map name domain
nullSubst :: Subst TypeVar Type
composeSubst :: Subst TypeVar Type -> Subst TypeVar Type -> Subst TypeVar Type
prType :: Type -> Doc
prParenType :: Type -> Doc
prPrenex :: Prenex -> Doc
instance Ord Type
instance Eq Type
instance NFData Type
instance Bindable Set TypeVar Type
instance Substitutable Map TypeVar Type Type
instance Bindable Set TypeVar Prenex
instance Substitutable Map TypeVar Type Prenex
instance Show Type
instance Show Prenex

module LText.Internal.Inference
newtype Context
[Context] :: (Map ExprVar Prenex) -> Context
remove :: Context -> String -> Context

-- | Binds free type variables as universally quantified
generalize :: Context -> Type -> Prenex
data TIState
[TIState] :: Int -> Subst TypeVar Type -> TIState
[tiSupply] :: TIState -> Int
[tiSubst] :: TIState -> Subst TypeVar Type
runTI :: (Monad m, MonadError String m) => StateT TIState m a -> m a
newTyVar :: (Monad m, MonadState TIState m, MonadError String m) => TypeVar -> m Type

-- | Replaces bound type variables with free, fresh ones
instantiate :: (Monad m, MonadState TIState m, MonadError String m) => Prenex -> m Type

-- | Most general unifier
mgu :: (Monad m, MonadState TIState m, MonadError String m) => Type -> Type -> m (Subst TypeVar Type)

-- | Makes a substitution <tt>[x -&gt; t]</tt>
varBind :: (Monad m, MonadState TIState m, MonadError String m) => TypeVar -> Type -> m (Subst TypeVar Type)

-- | Type inference function
ti :: (Monad m, MonadState TIState m, MonadError String m) => Context -> Expr -> m (Subst TypeVar Type, Type)
typeInference :: (Monad m, MonadState TIState m, MonadError String m) => Context -> Expr -> m Type
test :: (Monad m, MonadIO m) => Expr -> m ()
instance Bindable Set TypeVar Context
instance Substitutable Map TypeVar Type Context

module LText.Internal.Evaluation
runEv :: (Monad m, MonadError String m) => StateT (Int, Bool) m a -> m a
freshExprVar :: (Monad m, MonadState (Int, Bool) m) => String -> m String
reduce :: (Monad m, Functor m, MonadState (Int, Bool) m) => Expr -> m Expr
alpha :: (Monad m, MonadState (Int, Bool) m) => Expr -> m Expr

module LText.Internal
