-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Analysis and generation of Objective C code
--   
--   Language-ObjC is a haskell library for the analysis and generation of
--   Objective C code. It features a complete, well tested parser and
--   pretty printer.
@package language-objc
@version 0.4.2.6


-- | This module manages name spaces.
--   
--   <ul>
--   <li>A name space map associates identifiers with their
--   definition.</li>
--   <li>Each name space map is organized in a hierarchical way using the
--   notion of scopes. A name space map, at any moment, always has a global
--   scope and may have several local scopes. Definitions in inner scopes
--   hide definitions of the same identifier in outer scopes.</li>
--   </ul>
module Language.ObjC.Analysis.NameSpaceMap

-- | <tt>NameSpaceMap a</tt> is a Map from identifiers to <tt>a</tt>, which
--   manages global and local name spaces.
data NameSpaceMap k v

-- | create a name space
nameSpaceMap :: Ord k => NameSpaceMap k v

-- | flatten a namespace into a assoc list
--   
--   <pre>
--   nameSpaceToList ns = (localDefInnermost ns ++ .. ++ localDefsOutermost ns) ++ globalDefs ns
--   </pre>
nsMapToList :: Ord k => NameSpaceMap k a -> [(k, a)]
globalNames :: Ord k => NameSpaceMap k v -> Map k v
localNames :: Ord k => NameSpaceMap k v -> [[(k, v)]]
hasLocalNames :: NameSpaceMap k v -> Bool

-- | Add global definition
--   
--   <tt>(ns',oldDef) = defGlobal ns ident def</tt> adds a global
--   definition <tt>ident := def</tt> to the namespace. It returns the
--   modified namespace <tt>ns'</tt>. If the identifier is already declared
--   in the global namespace, the definition is overwritten and the old
--   definition <tt>oldDef</tt> is returned.
defGlobal :: Ord k => NameSpaceMap k a -> k -> a -> (NameSpaceMap k a, Maybe a)

-- | Enter new local scope
--   
--   <tt>ns' = enterNewScope ns</tt> creates and enters a new local scope.
enterNewScope :: Ord k => NameSpaceMap k a -> NameSpaceMap k a

-- | Leave innermost local scope
--   
--   <tt>(ns',defs) = leaveScope ns</tt> pops leaves the innermost local
--   scope. and returns its definitions
leaveScope :: Ord k => NameSpaceMap k a -> (NameSpaceMap k a, [(k, a)])

-- | Add local definition
--   
--   <tt>(ns',oldDef) = defLocal ns ident def</tt> adds the local
--   definition <tt>ident := def</tt> to the innermost local scope, if
--   there is a local scope, and to the global scope otherwise. It returns
--   the modified name space <tt>ns'</tt> and the old binding of the
--   identifier <tt>oldDef</tt>, which is overwritten.
defLocal :: Ord k => NameSpaceMap k a -> k -> a -> (NameSpaceMap k a, Maybe a)

-- | Search for a definition
--   
--   <tt>def = find ns ident</tt> returns the definition in some scope
--   (inner to outer), if there is one.
lookupName :: Ord k => NameSpaceMap k a -> k -> Maybe a
lookupGlobal :: Ord k => NameSpaceMap k a -> k -> Maybe a
lookupInnermostScope :: Ord k => NameSpaceMap k a -> k -> Maybe a

-- | Merge two namespaces. If they disagree on the types of any variables,
--   all bets are off.
mergeNameSpace :: Ord k => NameSpaceMap k a -> NameSpaceMap k a -> NameSpaceMap k a


-- | Unary, binary and asssignment operators. Exported via AST.
module Language.ObjC.Syntax.Ops

-- | C assignment operators (K&amp;R A7.17)
data CAssignOp
CAssignOp :: CAssignOp
CMulAssOp :: CAssignOp
CDivAssOp :: CAssignOp

-- | remainder and assignment
CRmdAssOp :: CAssignOp
CAddAssOp :: CAssignOp
CSubAssOp :: CAssignOp
CShlAssOp :: CAssignOp
CShrAssOp :: CAssignOp
CAndAssOp :: CAssignOp
CXorAssOp :: CAssignOp
COrAssOp :: CAssignOp
assignBinop :: CAssignOp -> CBinaryOp

-- | C binary operators (K&amp;R A7.6-15)
data CBinaryOp
CMulOp :: CBinaryOp
CDivOp :: CBinaryOp

-- | remainder of division
CRmdOp :: CBinaryOp
CAddOp :: CBinaryOp
CSubOp :: CBinaryOp

-- | shift left
CShlOp :: CBinaryOp

-- | shift right
CShrOp :: CBinaryOp

-- | less
CLeOp :: CBinaryOp

-- | greater
CGrOp :: CBinaryOp

-- | less or equal
CLeqOp :: CBinaryOp

-- | greater or equal
CGeqOp :: CBinaryOp

-- | equal
CEqOp :: CBinaryOp

-- | not equal
CNeqOp :: CBinaryOp

-- | bitwise and
CAndOp :: CBinaryOp

-- | exclusive bitwise or
CXorOp :: CBinaryOp

-- | inclusive bitwise or
COrOp :: CBinaryOp

-- | logical and
CLndOp :: CBinaryOp

-- | logical or
CLorOp :: CBinaryOp
isCmpOp :: CBinaryOp -> Bool
isPtrOp :: CBinaryOp -> Bool
isBitOp :: CBinaryOp -> Bool
isLogicOp :: CBinaryOp -> Bool

-- | C unary operator (K&amp;R A7.3-4)
data CUnaryOp

-- | prefix increment operator
CPreIncOp :: CUnaryOp

-- | prefix decrement operator
CPreDecOp :: CUnaryOp

-- | postfix increment operator
CPostIncOp :: CUnaryOp

-- | postfix decrement operator
CPostDecOp :: CUnaryOp

-- | address operator
CAdrOp :: CUnaryOp

-- | indirection operator
CIndOp :: CUnaryOp

-- | prefix plus
CPlusOp :: CUnaryOp

-- | prefix minus
CMinOp :: CUnaryOp

-- | one's complement
CCompOp :: CUnaryOp

-- | logical negation
CNegOp :: CUnaryOp
isEffectfulOp :: CUnaryOp -> Bool
instance Typeable CAssignOp
instance Typeable CBinaryOp
instance Typeable CUnaryOp
instance Eq CAssignOp
instance Ord CAssignOp
instance Show CAssignOp
instance Data CAssignOp
instance Eq CBinaryOp
instance Ord CBinaryOp
instance Show CBinaryOp
instance Data CBinaryOp
instance Eq CUnaryOp
instance Ord CUnaryOp
instance Show CUnaryOp
instance Data CUnaryOp


-- | This module provides support for representing, checking and exporting
--   c constants, i.e. integral, float, character and string constants.
module Language.ObjC.Syntax.Constants
escapeChar :: Char -> String
unescapeChar :: String -> (Char, String)
unescapeString :: String -> String
newtype Flags f
Flags :: Integer -> Flags f
noFlags :: Flags f
setFlag :: Enum f => f -> Flags f -> Flags f
clearFlag :: Enum f => f -> Flags f -> Flags f
testFlag :: Enum f => f -> Flags f -> Bool

-- | construct a character constant from a haskell <a>Char</a> Use
--   <tt>cchar_w</tt> if you want a wide character constant.
cChar :: Char -> CChar

-- | construct a wide chararacter constant
cChar_w :: Char -> CChar

-- | create a multi-character character constant
cChars :: [Char] -> Bool -> CChar

-- | C char constants (abstract)
data CChar
CChar :: !Char -> !Bool -> CChar
CChars :: [Char] -> !Bool -> CChar

-- | get the haskell representation of a char constant
getCChar :: CChar -> [Char]

-- | get integer value of a C char constant undefined result for multi-char
--   char constants
getCCharAsInt :: CChar -> Integer

-- | return <tt>true</tt> if the character constant is <i>wide</i>.
isWideChar :: CChar -> Bool

-- | <tt>showCharConst c</tt> prepends _a_ String representing the C char
--   constant corresponding to <tt>c</tt>. If necessary uses octal or
--   hexadecimal escape sequences.
showCharConst :: Char -> ShowS

-- | datatype representing type flags for integers
data CIntFlag
FlagUnsigned :: CIntFlag
FlagLong :: CIntFlag
FlagLongLong :: CIntFlag
FlagImag :: CIntFlag

-- | datatype for memorizing the representation of an integer
data CIntRepr
DecRepr :: CIntRepr
HexRepr :: CIntRepr
OctalRepr :: CIntRepr

-- | construct a integer constant (without type flags) from a haskell
--   integer
cInteger :: Integer -> CInteger
data CInteger
CInteger :: !Integer -> !CIntRepr -> !(Flags CIntFlag) -> CInteger
getCInteger :: CInteger -> Integer
readCInteger :: CIntRepr -> String -> Either String CInteger
cFloat :: Float -> CFloat

-- | Floats (represented as strings)
data CFloat
CFloat :: !String -> CFloat
readCFloat :: String -> CFloat
cString :: String -> CString
cString_w :: String -> CString

-- | C String literals
data CString
CString :: [Char] -> Bool -> CString
getCString :: CString -> String

-- | <tt>showStringLiteral s</tt> prepends a String representing the C
--   string literal corresponding to <tt>s</tt>. If necessary it uses octal
--   or hexadecimal escape sequences.
showStringLit :: String -> ShowS

-- | concatenate a list of C string literals
concatCStrings :: [CString] -> CString
instance Typeable CChar
instance Typeable CIntRepr
instance Typeable CIntFlag
instance Typeable CFloat
instance Typeable CString
instance Typeable1 Flags
instance Typeable CInteger
instance Eq CChar
instance Ord CChar
instance Data CChar
instance Eq CIntRepr
instance Ord CIntRepr
instance Enum CIntRepr
instance Bounded CIntRepr
instance Data CIntRepr
instance Eq CIntFlag
instance Ord CIntFlag
instance Enum CIntFlag
instance Bounded CIntFlag
instance Data CIntFlag
instance Eq CFloat
instance Ord CFloat
instance Data CFloat
instance Eq CString
instance Ord CString
instance Data CString
instance Eq (Flags f)
instance Ord (Flags f)
instance Data f => Data (Flags f)
instance Eq CInteger
instance Ord CInteger
instance Data CInteger
instance Show CString
instance Show CFloat
instance Show CInteger
instance Show CIntFlag
instance Show CChar


-- | Source code position
module Language.ObjC.Data.Position

-- | uniform representation of source file positions
data Position
Position :: {-# UNPACK #-} !Int -> String -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> Position

-- | absolute offset in the preprocessed file
posOffset' :: Position -> {-# UNPACK #-} !Int

-- | source file
posFile' :: Position -> String

-- | row (line) in the original file. Affected by #LINE pragmas.
posRow' :: Position -> {-# UNPACK #-} !Int

-- | column in the preprocessed file. Inaccurate w.r.t. to the original
--   file in the presence of preprocessor macros.
posColumn' :: Position -> {-# UNPACK #-} !Int
NoPosition :: Position
BuiltinPosition :: Position
InternalPosition :: Position

-- | <tt>position absoluteOffset fileName lineNumber columnNumber</tt>
--   initializes a <tt>Position</tt> using the given arguments
position :: Int -> String -> Int -> Int -> Position

-- | Position and length of a token
data PosLength
PL :: !Position -> {-# UNPACK #-} !Int -> PosLength
mkPosLength :: Position -> Int -> PosLength
unPosLength :: PosLength -> (Position, Int)
posFile :: Position -> String
posRow :: Position -> Int

-- | <i>Deprecated: column number information is inaccurate in presence of
--   macros - do not rely on it. </i>
posColumn :: Position -> Int
posOffset :: Position -> Int

-- | initialize a Position to the start of the translation unit starting in
--   the given file
initPos :: FilePath -> Position

-- | returns <tt>True</tt> if the given position refers to an actual source
--   file
isSourcePos :: Position -> Bool

-- | no position (for unknown position information)
nopos :: Position

-- | returns <tt>True</tt> if the there is no position information
--   available
isNoPos :: Position -> Bool

-- | position attached to built-in objects
builtinPos :: Position

-- | returns <tt>True</tt> if the given position refers to a builtin
--   definition
isBuiltinPos :: Position -> Bool

-- | position used for internal errors
internalPos :: Position

-- | returns <tt>True</tt> if the given position is internal
isInternalPos :: Position -> Bool

-- | advance column
incPos :: Position -> Int -> Position

-- | advance to next line
retPos :: Position -> Position

-- | adjust position: change file and line number, reseting column to 1.
--   This is usually used for #LINE pragmas. The absolute offset is not
--   changed - this can be done by <tt>adjustPos newFile line . incPos
--   (length pragma)</tt>.
adjustPos :: FilePath -> Int -> Position -> Position

-- | advance just the offset
incOffset :: Position -> Int -> Position

-- | class of type which aggregate a source code location
class Pos a
posOf :: Pos a => a -> Position
instance Typeable Position
instance Typeable PosLength
instance Eq Position
instance Ord Position
instance Data Position
instance Eq PosLength
instance Ord PosLength
instance Data PosLength
instance Show PosLength
instance Show Position


-- | Unique Names with fast equality (newtype <a>Int</a>)
module Language.ObjC.Data.Name

-- | Name is a unique identifier
newtype Name
Name :: Int -> Name
nameId :: Name -> Int

-- | return an infinite stream of <a>Name</a>s starting with
--   <tt>nameId</tt> 0
newNameSupply :: [Name]

-- | get the infinite stream of unique names starting from the given
--   integer
namesStartingFrom :: Int -> [Name]
instance Typeable Name
instance Show Name
instance Read Name
instance Eq Name
instance Ord Name
instance Ix Name
instance Data Name
instance Enum Name


-- | source position and unqiue name
module Language.ObjC.Data.Node

-- | Parsed entity attribute
data NodeInfo
OnlyPos :: !Position -> {-# UNPACK #-} !PosLength -> NodeInfo
NodeInfo :: !Position -> {-# UNPACK #-} !PosLength -> {-# UNPACK #-} !Name -> NodeInfo

-- | create a node with neither name nor positional information
undefNode :: NodeInfo

-- | return True if the node carries neither name nor positional
--   information
isUndefNode :: NodeInfo -> Bool

-- | | Given only a source position, create a new node attribute
mkNodeInfoOnlyPos :: Position -> NodeInfo

-- | Given a source position and the position and length of the last token,
--   create a new node attribute
mkNodeInfoPosLen :: Position -> (Position, Int) -> NodeInfo

-- | Given a source position and a unique name, create a new attribute
--   identifier
mkNodeInfo :: Position -> Name -> NodeInfo

-- | Given a source position, the position and length of the last token and
--   a unique name, create a new attribute identifier. Strict in
mkNodeInfo' :: Position -> (Position, Int) -> Name -> NodeInfo

-- | <i>Deprecated: use undefNode instead </i>
internalNode :: NodeInfo

-- | a class for convenient access to the attributes of an attributed
--   object
class CNode a
nodeInfo :: CNode a => a -> NodeInfo
fileOfNode :: CNode a => a -> Maybe FilePath
posOfNode :: NodeInfo -> Position
nameOfNode :: NodeInfo -> Maybe Name

-- | get the position and length of the last token
getLastTokenPos :: NodeInfo -> PosLength

-- | get the number of characters an AST node spans
lengthOfNode :: NodeInfo -> Maybe Int

-- | equality by name
eqByName :: CNode a => a -> a -> Bool
instance Typeable NodeInfo
instance Data NodeInfo
instance (CNode a, CNode b) => CNode (Either a b)
instance CNode NodeInfo
instance Pos NodeInfo
instance Ord NodeInfo
instance Eq NodeInfo
instance Show NodeInfo


-- | This module provides the notion of identifiers in C, speed up using
--   hashing. Identifiers are associated optionally associated with a
--   <a>NodeInfo</a>, i.e. with a unique <a>Name</a> and a source location
--   (<a>Position</a>). The ordering relation on identifiers is based on
--   the hash and does not follow the lexical order.
module Language.ObjC.Data.Ident

-- | C identifiers
data Ident
Ident :: String -> {-# UNPACK #-} !Int -> NodeInfo -> Ident

-- | References uniquely determining a struct, union or enum type. Those
--   are either identified by an string identifier, or by a unique name
--   (anonymous types).
data SUERef
AnonymousRef :: Name -> SUERef
NamedRef :: Ident -> SUERef

-- | Return true if the struct/union/enum reference is anonymous.
isAnonymousRef :: SUERef -> Bool

-- | build an identifier from a string.
--   
--   <ul>
--   <li>only minimal error checking, e.g., the characters of the
--   identifier are not checked for being alphanumerical only; the correct
--   lexis of the identifier should be ensured by the caller, e.g., the
--   scanner.</li>
--   <li>for reasons of simplicity the complete lexeme is hashed.</li>
--   </ul>
mkIdent :: Position -> String -> Name -> Ident

-- | returns a <i>builtin</i> identifier (has builtin position and no
--   unique name)
builtinIdent :: String -> Ident

-- | returns an <i>internal</i> identifier (has internal position and no
--   unique name)
internalIdent :: String -> Ident

-- | return an <i>internal</i> identifier with position info
internalIdentAt :: Position -> String -> Ident

-- | return <tt>True</tt> if the given identifier is <i>internal</i>
isInternalIdent :: Ident -> Bool

-- | string of an identifier
identToString :: Ident -> String

-- | dump the identifier string and its positions for debugging purposes
dumpIdent :: Ident -> String
instance Typeable Ident
instance Typeable SUERef
instance Data Ident
instance Data SUERef
instance Ord SUERef
instance Eq SUERef
instance Pos Ident
instance CNode Ident
instance Show Ident
instance Ord Ident
instance Eq Ident
instance Show SUERef


-- | Abstract syntax of C source and header files.
--   
--   The tree structure is based on the grammar in Appendix A of K&amp;R.
--   The abstract syntax simplifies the concrete syntax by merging similar
--   concrete constructs into a single type of abstract tree structure:
--   declarations are merged with structure declarations, parameter
--   declarations and type names, and declarators are merged with abstract
--   declarators.
--   
--   With K&amp;R we refer to ``The C Programming Language'', second
--   edition, Brain W. Kernighan and Dennis M. Ritchie, Prentice Hall,
--   1988. The AST supports all of C99
--   <a>http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf</a> and
--   several GNU extensions
--   <a>http://gcc.gnu.org/onlinedocs/gcc/C-Extensions.html</a>.
module Language.ObjC.Syntax.AST

-- | Complete C tranlsation unit (C99 6.9, K&amp;R A10)
--   
--   A complete C translation unit, for example representing a C header or
--   source file. It consists of a list of external (i.e. toplevel)
--   declarations.
type CTranslUnit = CTranslationUnit NodeInfo

-- | External C declaration (C99 6.9, K&amp;R A10)
--   
--   Either a toplevel declaration, function definition, class, category,
--   protocol, or external assembler.
type CExtDecl = CExternalDeclaration NodeInfo
data CTranslationUnit a
CTranslUnit :: [CExternalDeclaration a] -> a -> CTranslationUnit a
data CExternalDeclaration a
CDeclExt :: (CDeclaration a) -> CExternalDeclaration a
CFDefExt :: (CFunctionDef a) -> CExternalDeclaration a
ObjCIfaceExt :: (ObjCInterface a) -> CExternalDeclaration a
ObjCImplExt :: (ObjCImplementation a) -> CExternalDeclaration a
ObjCClassExt :: (ObjCClassListDef a) -> CExternalDeclaration a
ObjCProtoExt :: (ObjCProtocolDec a) -> CExternalDeclaration a
ObjCCatExt :: (ObjCCategoryDec a) -> CExternalDeclaration a
ObjCCatImplExt :: (ObjCCategoryImplementation a) -> CExternalDeclaration a
CAsmExt :: (CStringLiteral a) -> a -> CExternalDeclaration a

-- | C function definition (C99 6.9.1, K&amp;R A10.1)
--   
--   A function definition is of the form <tt>CFunDef specifiers declarator
--   decllist? stmt</tt>.
--   
--   <ul>
--   <li><tt>specifiers</tt> are the type and storage-class specifiers of
--   the function. The only storage-class specifiers allowed are
--   <i>extern</i> and <i>static</i>.</li>
--   <li>The <tt>declarator</tt> must be such that the declared identifier
--   has <i>function type</i>. The return type shall be void or an object
--   type other than array type.</li>
--   <li>The optional declaration list <tt>decllist</tt> is for old-style
--   function declarations.</li>
--   <li>The statement <tt>stmt</tt> is a compound statement.</li>
--   </ul>
type CFunDef = CFunctionDef NodeInfo

-- | C declarations (K&amp;R A8, C99 6.7), including structure
--   declarations, parameter declarations and type names.
--   
--   A declaration is of the form <tt>CDecl specifiers
--   init-declarator-list</tt>, where the form of the declarator list's
--   elements depends on the kind of declaration:
--   
--   1) Toplevel declarations (K&amp;R A8, C99 6.7 declaration)
--   
--   <ul>
--   <li>C99 requires that there is at least one specifier, though this is
--   merely a syntactic restriction</li>
--   <li>at most one storage class specifier is allowed per
--   declaration</li>
--   <li>the elements of the non-empty <tt>init-declarator-list</tt> are of
--   the form <tt>(Just declr, init?, Nothing)</tt>. The declarator
--   <tt>declr</tt> has to be present and non-abstract and the
--   initialization expression is optional.</li>
--   </ul>
--   
--   2) Structure declarations (K&amp;R A8.3, C99 6.7.2.1
--   struct-declaration)
--   
--   Those are the declarations of a structure's members.
--   
--   <ul>
--   <li>do not allow storage specifiers</li>
--   <li>in strict C99, the list of declarators has to be non-empty</li>
--   <li>the elements of <tt>init-declarator-list</tt> are either of the
--   form <tt>(Just declr, Nothing, size?)</tt>, representing a member with
--   optional bit-field size, or of the form <tt>(Nothing, Nothing, Just
--   size)</tt>, for unnamed bitfields. <tt>declr</tt> has to be
--   non-abstract.</li>
--   <li>no member of a structure shall have incomplete type</li>
--   </ul>
--   
--   3) Parameter declarations (K&amp;R A8.6.3, C99 6.7.5
--   parameter-declaration)
--   
--   <ul>
--   <li><tt>init-declarator-list</tt> must contain at most one triple of
--   the form <tt>(Just declr, Nothing, Nothing)</tt>, i.e. consist of a
--   single declarator, which is allowed to be abstract (i.e.
--   unnamed).</li>
--   </ul>
--   
--   4) Type names (A8.8, C99 6.7.6)
--   
--   <ul>
--   <li>do not allow storage specifiers</li>
--   <li><tt>init-declarator-list</tt> must contain at most one triple of
--   the form <tt>(Just declr, Nothing, Nothing)</tt>. where <tt>declr</tt>
--   is an abstract declarator (i.e. doesn't contain a declared
--   identifier)</li>
--   </ul>
type CDecl = CDeclaration NodeInfo

-- | C structure or union specifiers (K&amp;R A8.3, C99 6.7.2.1)
--   
--   <tt>CStruct tag identifier struct-decls c-attrs</tt> represents a
--   struct or union specifier (depending on <tt>tag</tt>).
--   
--   <ul>
--   <li>either <tt>identifier</tt> or the declaration list
--   <tt>struct-decls</tt> (or both) have to be present.</li>
--   </ul>
--   
--   Example: in <tt>struct foo x;</tt>, the identifier is present, in
--   <tt>struct { int y; } x</tt> the declaration list, and in <tt>struct
--   foo { int y; } x;</tt> both of them.
--   
--   <ul>
--   <li><tt>c-attrs</tt> is a list of <tt>__attribute__</tt> annotations
--   associated with the struct or union specifier</li>
--   </ul>
type CStructUnion = CStructureUnion NodeInfo

-- | C enumeration specifier (K&amp;R A8.4, C99 6.7.2.2)
--   
--   <tt>CEnum identifier enumerator-list attrs</tt> represent as enum
--   specifier
--   
--   <ul>
--   <li>Either the identifier or the enumerator-list (or both) have to be
--   present.</li>
--   <li>If <tt>enumerator-list</tt> is present, it has to be
--   non-empty.</li>
--   <li>The enumerator list is of the form <tt>(enumeration-constant,
--   enumeration-value?)</tt>, where the latter is an optional constant
--   integral expression.</li>
--   <li><tt>attrs</tt> is a list of <tt>__attribute__</tt> annotations
--   associated with the enumeration specifier</li>
--   </ul>
type CEnum = CEnumeration NodeInfo
data CFunctionDef a
CFunDef :: [CDeclarationSpecifier a] -> (CDeclarator a) -> [CDeclaration a] -> (CStatement a) -> a -> CFunctionDef a
data CDeclaration a
CDecl :: [CDeclarationSpecifier a] -> [(Maybe (CDeclarator a), Maybe (CInitializer a), Maybe (CExpression a))] -> a -> CDeclaration a

-- | A tag to determine wheter we refer to a <tt>struct</tt> or
--   <tt>union</tt>, see <a>CStructUnion</a>.
data CStructTag
CStructTag :: CStructTag
CUnionTag :: CStructTag
data CStructureUnion a
CStruct :: !CStructTag -> (Maybe Ident) -> (Maybe [CDeclaration a]) -> [CAttribute a] -> a -> CStructureUnion a
data CEnumeration a
CEnum :: (Maybe Ident) -> (Maybe [(Ident, Maybe (CExpression a))]) -> [CAttribute a] -> a -> CEnumeration a
type ObjCIface = ObjCInterface NodeInfo
type ObjCClassDef = ObjCClassListDef NodeInfo
type ObjCProtoNm = ObjCProtocolName NodeInfo
type ObjCInstanceVarBlock = ObjCInstanceVariableBlock NodeInfo
type ObjCVisSpec = ObjCVisibilitySpec NodeInfo
type ObjCPropDecl = ObjCPropertyDeclaration NodeInfo
type ObjCSel = ObjCSelector NodeInfo
type ObjCMethodSel = ObjCMethodSelector NodeInfo
type ObjCMethodDecl = ObjCMethodDeclaration NodeInfo
type ObjCProtoDec = ObjCProtocolDec NodeInfo
type ObjCProtoDeclBlock = ObjCProtocolDeclBlock NodeInfo
type ObjCCatDec = ObjCCategoryDec NodeInfo
type ObjCImpl = ObjCImplementation NodeInfo
type ObjCCatImpl = ObjCCategoryImplementation NodeInfo
type ObjCMethodDef = ObjCMethodDefinition NodeInfo
type ObjCImplDef = ObjCImplementationDefinition NodeInfo

-- | Interface declaration, '@interface'
data ObjCInterface a
ObjCIface :: (ObjCClassDeclarator a) -> (Maybe (ObjCClassName a)) -> [ObjCProtocolName a] -> [ObjCInstanceVariableBlock a] -> [ObjCInterfaceDeclaration a] -> [CAttribute a] -> a -> ObjCInterface a
data ObjCClassListDef a
ObjCClassDef :: [ObjCClassDeclarator a] -> a -> ObjCClassListDef a
data ObjCProtocolName a
ObjCProtoNm :: !Ident -> a -> ObjCProtocolName a
data ObjCInstanceVariableBlock a
ObjCInstanceVarBlock :: (Maybe (ObjCVisibilitySpec a)) -> [CDeclaration a] -> a -> ObjCInstanceVariableBlock a
data ObjCVisibilitySpec a
ObjCVisSpec :: !ObjCVisType -> a -> ObjCVisibilitySpec a

-- | Available visibility specifications.
data ObjCVisType
ObjCPrivVis :: ObjCVisType
ObjCProtVis :: ObjCVisType
ObjCPubVis :: ObjCVisType
ObjCPackageVis :: ObjCVisType
data ObjCPropertyDeclaration a
ObjCPropDecl :: [ObjCPropertyModifier a] -> (CDeclaration a) -> a -> ObjCPropertyDeclaration a
data ObjCSelector a
ObjCSel :: Ident -> a -> ObjCSelector a
ObjCInSel :: a -> ObjCSelector a
ObjCOutSel :: a -> ObjCSelector a
data ObjCMethodSelector a
ObjCUnaryMethod :: (ObjCSelector a) -> a -> ObjCMethodSelector a
ObjCMethod :: [ObjCKeywordDeclarator a] -> (Maybe ([CDeclaration a], Bool)) -> a -> ObjCMethodSelector a
ObjCEllipseMethod :: [ObjCKeywordDeclarator a] -> a -> ObjCMethodSelector a
data ObjCMethodType
ObjCClassMethod :: ObjCMethodType
ObjCInstanceMethod :: ObjCMethodType
data ObjCMethodDeclaration a
ObjCMethodDecl :: !ObjCMethodType -> (Maybe (CDeclaration a)) -> (ObjCMethodSelector a) -> [CAttribute a] -> a -> ObjCMethodDeclaration a

-- | Objective-C protocol declaration
data ObjCProtocolDec a
ObjCForwardProtoDec :: [Ident] -> [CAttribute a] -> a -> ObjCProtocolDec a
ObjCProtoDec :: !Ident -> [ObjCProtocolName a] -> [ObjCProtocolDeclBlock a] -> [CAttribute a] -> a -> ObjCProtocolDec a
data ObjCProtocolDeclBlock a
ObjCProtoDeclBlock :: [ObjCInterfaceDeclaration a] -> a -> ObjCProtocolDeclBlock a
ObjCReqProtoBlock :: [ObjCInterfaceDeclaration a] -> a -> ObjCProtocolDeclBlock a
ObjCOptProtoBlock :: [ObjCInterfaceDeclaration a] -> a -> ObjCProtocolDeclBlock a

-- | Objective-C Category definition ('@interface')
data ObjCCategoryDec a
ObjCCatDec :: !Ident -> !Ident -> [ObjCProtocolName a] -> [ObjCInterfaceDeclaration a] -> [CAttribute a] -> a -> ObjCCategoryDec a

-- | Implementation declaration, '@implementation'
data ObjCImplementation a
ObjCImpl :: (ObjCClassName a) -> (Maybe (ObjCClassName a)) -> [ObjCInstanceVariableBlock a] -> [ObjCImplementationDefinition a] -> a -> ObjCImplementation a

-- | Objective-C Category implementation '@implementation'
data ObjCCategoryImplementation a
ObjCCatImpl :: !Ident -> !Ident -> [ObjCImplementationDefinition a] -> a -> ObjCCategoryImplementation a
data ObjCMethodDefinition a
ObjCMethodDef :: !ObjCMethodType -> (Maybe (CDeclaration a)) -> (ObjCMethodSelector a) -> [CDeclaration a] -> (CStatement a) -> a -> ObjCMethodDefinition a
data ObjCImplementationDefinition a
ObjCImplDec :: (CDeclaration a) -> ObjCImplementationDefinition a
ObjCImplMethod :: (ObjCMethodDefinition a) -> ObjCImplementationDefinition a
ObjCImplFun :: (CFunctionDef a) -> ObjCImplementationDefinition a

-- | C declaration specifiers and qualifiers
--   
--   Declaration specifiers include at most one storage-class specifier
--   (C99 6.7.1), type specifiers (6.7.2) and type qualifiers (6.7.3).
type CDeclSpec = CDeclarationSpecifier NodeInfo

-- | Separate the declaration specifiers
--   
--   Note that inline isn't actually a type qualifier, but a function
--   specifier. <tt>__attribute__</tt> of a declaration qualify
--   declarations or declarators (but not types), and are therefore
--   separated as well.
partitionDeclSpecs :: [CDeclarationSpecifier a] -> ([CStorageSpecifier a], [CAttribute a], [CTypeQualifier a], [CTypeSpecifier a], Bool)

-- | C storage class specifier (and typedefs) (K&amp;R A8.1, C99 6.7.1)
type CStorageSpec = CStorageSpecifier NodeInfo

-- | C type specifier (K&amp;R A8.2, C99 6.7.2)
--   
--   Type specifiers are either basic types such as <tt>char</tt> or
--   <tt>int</tt>, <tt>struct</tt>, <tt>union</tt> or <tt>enum</tt>
--   specifiers or typedef names.
--   
--   As a GNU extension, a <tt>typeof</tt> expression also is a type
--   specifier.
--   
--   Objective-C class names and specifiers of the form 'typdefname
--   <a>Protocols</a>' are also allowed.
type CTypeSpec = CTypeSpecifier NodeInfo

-- | returns <tt>True</tt> if the given typespec is a struct, union or enum
--   <i>definition</i>
isSUEDef :: CTypeSpecifier a -> Bool

-- | C type qualifiers (K&amp;R A8.2, C99 6.7.3), function specifiers (C99
--   6.7.4), and attributes.
--   
--   <tt>const</tt>, <tt>volatile</tt> and <tt>restrict</tt> type
--   qualifiers and <tt>inline</tt> function specifier. Additionally,
--   <tt>__attribute__</tt> annotations for declarations and declarators.
type CTypeQual = CTypeQualifier NodeInfo

-- | <tt>__attribute__</tt> annotations
--   
--   Those are of the form <tt>CAttr attribute-name
--   attribute-parameters</tt>, and serve as generic properties of some
--   syntax tree elements.
type CAttr = CAttribute NodeInfo
data CDeclarationSpecifier a

-- | storage-class specifier or typedef
CStorageSpec :: (CStorageSpecifier a) -> CDeclarationSpecifier a

-- | type name
CTypeSpec :: (CTypeSpecifier a) -> CDeclarationSpecifier a

-- | type qualifier
CTypeQual :: (CTypeQualifier a) -> CDeclarationSpecifier a
data CStorageSpecifier a

-- | auto
CAuto :: a -> CStorageSpecifier a

-- | register
CRegister :: a -> CStorageSpecifier a

-- | static
CStatic :: a -> CStorageSpecifier a

-- | extern
CExtern :: a -> CStorageSpecifier a

-- | typedef
CTypedef :: a -> CStorageSpecifier a

-- | GNUC thread local storage
CThread :: a -> CStorageSpecifier a
data CTypeSpecifier a
CVoidType :: a -> CTypeSpecifier a
CCharType :: a -> CTypeSpecifier a
CShortType :: a -> CTypeSpecifier a
CIntType :: a -> CTypeSpecifier a
CLongType :: a -> CTypeSpecifier a
CFloatType :: a -> CTypeSpecifier a
CDoubleType :: a -> CTypeSpecifier a
CSignedType :: a -> CTypeSpecifier a
CUnsigType :: a -> CTypeSpecifier a
CBoolType :: a -> CTypeSpecifier a
CComplexType :: a -> CTypeSpecifier a

-- | Struct or Union specifier
CSUType :: (CStructureUnion a) -> a -> CTypeSpecifier a

-- | Enumeration specifier
CEnumType :: (CEnumeration a) -> a -> CTypeSpecifier a

-- | Typedef name
CTypeDef :: !Ident -> a -> CTypeSpecifier a

-- | <pre>
--   typeof(expr)
--   </pre>
CTypeOfExpr :: (CExpression a) -> a -> CTypeSpecifier a

-- | <pre>
--   typeof(type)
--   </pre>
CTypeOfType :: (CDeclaration a) -> a -> CTypeSpecifier a

-- | class name with protocol list
ObjCClassProto :: !Ident -> [ObjCProtocolName a] -> a -> CTypeSpecifier a

-- | Typedef name with protocol list
ObjCTypeProto :: !Ident -> [ObjCProtocolName a] -> a -> CTypeSpecifier a
data CTypeQualifier a
CConstQual :: a -> CTypeQualifier a
CVolatQual :: a -> CTypeQualifier a
CRestrQual :: a -> CTypeQualifier a
CInlineQual :: a -> CTypeQualifier a
CAttrQual :: (CAttribute a) -> CTypeQualifier a
ObjCProtoQual :: (ObjCProtoQualifier a) -> CTypeQualifier a
data CAttribute a
CAttr :: !Ident -> [CExpression a] -> a -> CAttribute a
type ObjCPropMod = ObjCPropertyModifier NodeInfo
type ObjCProtoQual = ObjCProtoQualifier NodeInfo
data ObjCPropertyModifier a
ObjCPropMod :: !Ident -> (Maybe Ident) -> a -> ObjCPropertyModifier a
data ObjCProtoQualifier a
ObjCInQual :: a -> ObjCProtoQualifier a
ObjCOutQual :: a -> ObjCProtoQualifier a
ObjCInOutQual :: a -> ObjCProtoQualifier a
ObjCBycopyQual :: a -> ObjCProtoQualifier a
ObjCOnewayQual :: a -> ObjCProtoQualifier a

-- | C declarator (K&amp;R A8.5, C99 6.7.5) and abstract declarator
--   (K&amp;R A8.8, C99 6.7.6)
--   
--   A declarator declares a single object, function, or type. It is always
--   associated with a declaration (<a>CDecl</a>), which specifies the
--   declaration's type and the additional storage qualifiers and
--   attributes, which apply to the declared object.
--   
--   A declarator is of the form <tt>CDeclr name? indirections asm-name?
--   attrs _</tt>, where <tt>name</tt> is the name of the declared object
--   (missing for abstract declarators), <tt>declquals</tt> is a set of
--   additional declaration specifiers, <tt>asm-name</tt> is the optional
--   assembler name and attributes is a set of attrs is a set of
--   <tt>__attribute__</tt> annotations for the declared object.
--   
--   <tt>indirections</tt> is a set of pointer, array and function
--   declarators, which modify the type of the declared object as described
--   below. If the <i>declaration</i> specifies the non-derived type
--   <tt>T</tt>, and we have <tt>indirections = [D1, D2, ..., Dn]</tt> than
--   the declared object has type <tt>(D1 <tt>indirect</tt> (D2
--   <tt>indirect</tt> ... (Dn <tt>indirect</tt> T)))</tt>, where
--   
--   <ul>
--   <li><tt>(CPtrDeclr attrs) <tt>indirect</tt> T</tt> is <i>attributed
--   pointer to T</i></li>
--   <li><tt>(CFunDeclr attrs) <tt>indirect</tt> T</tt> is <i>attributed
--   function returning T</i></li>
--   <li><tt>(CArrayDeclr attrs) <tt>indirect</tt> T</tt> is <i>attributed
--   array of elemements of type T</i></li>
--   </ul>
--   
--   Examples (simplified attributes):
--   
--   <ul>
--   <li><i>x</i> is an int</li>
--   </ul>
--   
--   <pre>
--   int x;
--   CDeclr "x" []
--   </pre>
--   
--   <ul>
--   <li><i>x</i> is a restrict pointer to a const pointer to int</li>
--   </ul>
--   
--   <pre>
--   const int * const * restrict x;
--   CDeclr "x" [CPtrDeclr [restrict], CPtrDeclr [const]]
--   </pre>
--   
--   <ul>
--   <li><i>f</i> is an function return a constant pointer to int</li>
--   </ul>
--   
--   <pre>
--   int* const f();
--   CDeclr "f" [CFunDeclr [],CPtrDeclr [const]]
--   </pre>
--   
--   <ul>
--   <li><i>f</i> is a constant pointer to a function returning int</li>
--   </ul>
--   
--   <pre>
--   int (* const f)(); ==&gt;
--   CDeclr "f" [CPtrDeclr [const], CFunDeclr []]
--   </pre>
type CDeclr = CDeclarator NodeInfo

-- | Derived declarators, see <a>CDeclr</a>
--   
--   Indirections are qualified using type-qualifiers and generic
--   attributes, and additionally
--   
--   <ul>
--   <li>The size of an array is either a constant expression, variable
--   length (<a>*</a>) or missing; in the last case, the type of the array
--   is incomplete. The qualifier static is allowed for function arguments
--   only, indicating that the supplied argument is an array of at least
--   the given size.</li>
--   <li>New style parameter lists have the form <tt>Right (declarations,
--   isVariadic)</tt>, old style parameter lists have the form <tt>Left
--   (parameter-names)</tt></li>
--   </ul>
type CDerivedDeclr = CDerivedDeclarator NodeInfo

-- | Size of an array
type CArrSize = CArraySize NodeInfo
data CDeclarator a
CDeclr :: (Maybe Ident) -> [CDerivedDeclarator a] -> (Maybe (CStringLiteral a)) -> [CAttribute a] -> a -> CDeclarator a
data CDerivedDeclarator a

-- | Pointer declarator <tt>CPtrDeclr tyquals declr</tt>
CPtrDeclr :: [CTypeQualifier a] -> a -> CDerivedDeclarator a

-- | Block declarator <tt>CBlkDeclr tyquals declr</tt>
CBlkDeclr :: [CTypeQualifier a] -> a -> CDerivedDeclarator a

-- | Array declarator <tt>CArrDeclr declr tyquals size-expr?</tt>
CArrDeclr :: [CTypeQualifier a] -> (CArraySize a) -> a -> CDerivedDeclarator a

-- | Function declarator <tt>CFunDeclr declr (old-style-params |
--   new-style-params) c-attrs</tt>
CFunDeclr :: (Either [Ident] ([CDeclaration a], Bool)) -> [CAttribute a] -> a -> CDerivedDeclarator a
data CArraySize a

-- | <pre>
--   CUnknownSize isCompleteType
--   </pre>
CNoArrSize :: !Bool -> CArraySize a

-- | <pre>
--   CArrSize isStatic expr
--   </pre>
CArrSize :: !Bool -> (CExpression a) -> CArraySize a
type ObjCClassNm = ObjCClassName NodeInfo
type ObjCClassDeclr = ObjCClassDeclarator NodeInfo
type ObjCIfaceDecl = ObjCInterfaceDeclaration NodeInfo
type ObjCKeyDeclr = ObjCKeywordDeclarator NodeInfo
data ObjCClassName a
ObjCClassNm :: !Ident -> a -> ObjCClassName a
data ObjCClassDeclarator a
ObjCClassDeclr :: !Ident -> a -> ObjCClassDeclarator a
data ObjCInterfaceDeclaration a
ObjCIfaceDecl :: (CDeclaration a) -> a -> ObjCInterfaceDeclaration a
ObjCIfaceMethodDecl :: (ObjCMethodDeclaration a) -> a -> ObjCInterfaceDeclaration a
ObjCIfacePropDecl :: (ObjCPropertyDeclaration a) -> a -> ObjCInterfaceDeclaration a
data ObjCKeywordDeclarator a
ObjCKeyDeclr :: (Maybe (ObjCSelector a)) -> (Maybe (CDeclaration a)) -> !Ident -> a -> ObjCKeywordDeclarator a

-- | C initialization (K&amp;R A8.7, C99 6.7.8)
--   
--   Initializers are either assignment expressions or initializer lists
--   (surrounded in curly braces), whose elements are themselves
--   initializers, paired with an optional list of designators.
type CInit = CInitializer NodeInfo

-- | Initializer List
--   
--   The members of an initializer list are of the form
--   <tt>(designator-list,initializer)</tt>. The <tt>designator-list</tt>
--   specifies one member of the compound type which is initialized. It is
--   allowed to be empty - in this case the initializer refers to the
--   ''next'' member of the compound type (see C99 6.7.8).
--   
--   Examples (simplified expressions and identifiers):
--   
--   <pre>
--   -- int x[3][4] = { [0][3] = 4, [2] = 5, 8 };
--   --   corresponds to the assignments
--   -- x[0][3] = 4; x[2][0] = 5; x[2][1] = 8;
--   let init1 = ([CArrDesig 0, CArrDesig 3], CInitExpr 4)
--       init2 = ([CArrDesig 2]             , CInitExpr 5)
--       init3 = ([]                        , CInitExpr 8)
--   in  CInitList [init1, init2, init3]
--   </pre>
--   
--   <pre>
--   -- struct { struct { int a[2]; int b[2]; int c[2]; } s; } x = { .s = { {2,3} , .c[0] = 1 } };
--   --   corresponds to the assignments
--   -- x.s.a[0] = 2; x.s.a[1] = 3; x.s.c[0] = 1;
--   let init_s_0 = CInitList [ ([], CInitExpr 2), ([], CInitExpr 3)]
--       init_s   = CInitList [
--                              ([], init_s_0),
--                              ([CMemberDesig "c", CArrDesig 0], CInitExpr 1)
--                            ]
--   in  CInitList [(CMemberDesig "s", init_s)]
--   </pre>
type CInitList = CInitializerList NodeInfo

-- | Designators
--   
--   A designator specifies a member of an object, either an element or
--   range of an array, or the named member of a struct / union.
type CDesignator = CPartDesignator NodeInfo
data CInitializer a

-- | assignment expression
CInitExpr :: (CExpression a) -> a -> CInitializer a

-- | initialization list (see <a>CInitList</a>)
CInitList :: (CInitializerList a) -> a -> CInitializer a
type CInitializerList a = [([CPartDesignator a], CInitializer a)]
data CPartDesignator a

-- | array position designator
CArrDesig :: (CExpression a) -> a -> CPartDesignator a

-- | member designator
CMemberDesig :: !Ident -> a -> CPartDesignator a

-- | array range designator <tt>CRangeDesig from to _</tt> (GNU C)
CRangeDesig :: (CExpression a) -> (CExpression a) -> a -> CPartDesignator a

-- | C statement (K&amp;R A9, C99 6.8)
type CStat = CStatement NodeInfo

-- | C99 Block items
--   
--   Things that may appear in compound statements: either statements,
--   declarations or nested function definitions.
type CBlockItem = CCompoundBlockItem NodeInfo

-- | GNU Assembler statement
--   
--   <pre>
--   CAssemblyStatement type-qual? asm-expr out-ops in-ops clobbers _
--   </pre>
--   
--   is an inline assembler statement. The only type-qualifier (if any)
--   allowed is <i>volatile</i>. <tt>asm-expr</tt> is the actual assembler
--   epxression (a string), <tt>out-ops</tt> and <tt>in-ops</tt> are the
--   input and output operands of the statement. <tt>clobbers</tt> is a
--   list of registers which are clobbered when executing the assembler
--   statement
type CAsmStmt = CAssemblyStatement NodeInfo

-- | Assembler operand
--   
--   <tt>CAsmOperand argName? constraintExpr arg</tt> specifies an operand
--   for an assembler statement.
type CAsmOperand = CAssemblyOperand NodeInfo
data CStatement a

-- | An (attributed) label followed by a statement
CLabel :: !Ident -> (CStatement a) -> [CAttribute a] -> a -> CStatement a

-- | A statement of the form <tt>case expr : stmt</tt>
CCase :: (CExpression a) -> (CStatement a) -> a -> CStatement a

-- | A case range of the form <tt>case lower ... upper : stmt</tt>
CCases :: (CExpression a) -> (CExpression a) -> (CStatement a) -> a -> CStatement a

-- | The default case <tt>default : stmt</tt>
CDefault :: (CStatement a) -> a -> CStatement a

-- | A simple statement, that is in C: evaluating an expression with
--   side-effects and discarding the result.
CExpr :: (Maybe (CExpression a)) -> a -> CStatement a

-- | compound statement <tt>CCompound localLabels blockItems at</tt>
CCompound :: [Ident] -> [CCompoundBlockItem a] -> a -> CStatement a

-- | conditional statement <tt>CIf ifExpr thenStmt maybeElseStmt at</tt>
CIf :: (CExpression a) -> (CStatement a) -> (Maybe (CStatement a)) -> a -> CStatement a

-- | switch statement <tt>CSwitch selectorExpr switchStmt</tt>, where
--   <tt>switchStmt</tt> usually includes <i>case</i>, <i>break</i> and
--   <i>default</i> statements
CSwitch :: (CExpression a) -> (CStatement a) -> a -> CStatement a

-- | while or do-while statement <tt>CWhile guard stmt isDoWhile at</tt>
CWhile :: (CExpression a) -> (CStatement a) -> Bool -> a -> CStatement a

-- | for statement <tt>CFor init expr-2 expr-3 stmt</tt>, where
--   <tt>init</tt> is either a declaration or initializing expression
CFor :: (Either (Maybe (CExpression a)) (CDeclaration a)) -> (Maybe (CExpression a)) -> (Maybe (CExpression a)) -> (CStatement a) -> a -> CStatement a

-- | goto statement <tt>CGoto label</tt>
CGoto :: !Ident -> a -> CStatement a

-- | computed goto <tt>CGotoPtr labelExpr</tt>
CGotoPtr :: (CExpression a) -> a -> CStatement a

-- | continue statement
CCont :: a -> CStatement a

-- | break statement
CBreak :: a -> CStatement a

-- | return statement <tt>CReturn returnExpr</tt>
CReturn :: (Maybe (CExpression a)) -> a -> CStatement a

-- | assembly statement
CAsm :: (CAssemblyStatement a) -> a -> CStatement a
data CCompoundBlockItem a

-- | A statement
CBlockStmt :: (CStatement a) -> CCompoundBlockItem a

-- | A local declaration
CBlockDecl :: (CDeclaration a) -> CCompoundBlockItem a

-- | A nested function (GNU C)
CNestedFunDef :: (CFunctionDef a) -> CCompoundBlockItem a
data CAssemblyStatement a
CAsmStmt :: (Maybe (CTypeQualifier a)) -> (CStringLiteral a) -> [CAssemblyOperand a] -> [CAssemblyOperand a] -> [CStringLiteral a] -> a -> CAssemblyStatement a
data CAssemblyOperand a
CAsmOperand :: (Maybe Ident) -> (CStringLiteral a) -> (CExpression a) -> a -> CAssemblyOperand a

-- | C expression (K&amp;R A7)
--   
--   <ul>
--   <li>these can be arbitrary expression, as the argument of
--   <tt>sizeof</tt> can be arbitrary, even if appearing in a constant
--   expression</li>
--   <li>GNU C extensions: <tt>alignof</tt>, <tt>__real</tt>,
--   <tt>__imag</tt>, <tt>({ stmt-expr })</tt>, <tt>&amp;&amp; label</tt>
--   and built-ins * objective-C style code blocks</li>
--   </ul>
type CExpr = CExpression NodeInfo
data CExpression a
CComma :: [CExpression a] -> a -> CExpression a
CAssign :: !CAssignOp -> (CExpression a) -> (CExpression a) -> a -> CExpression a
CCond :: (CExpression a) -> (Maybe (CExpression a)) -> (CExpression a) -> a -> CExpression a
CBinary :: CBinaryOp -> (CExpression a) -> (CExpression a) -> a -> CExpression a
CCast :: (CDeclaration a) -> (CExpression a) -> a -> CExpression a
CUnary :: CUnaryOp -> (CExpression a) -> a -> CExpression a
CSizeofExpr :: (CExpression a) -> a -> CExpression a
CSizeofType :: (CDeclaration a) -> a -> CExpression a
CAlignofExpr :: (CExpression a) -> a -> CExpression a
CAlignofType :: (CDeclaration a) -> a -> CExpression a
CComplexReal :: (CExpression a) -> a -> CExpression a
CComplexImag :: (CExpression a) -> a -> CExpression a
CIndex :: (CExpression a) -> (CExpression a) -> a -> CExpression a
CCall :: (CExpression a) -> [CExpression a] -> a -> CExpression a
CMember :: (CExpression a) -> !Ident -> !Bool -> a -> CExpression a
CVar :: !Ident -> a -> CExpression a

-- | integer, character, floating point and string constants
CConst :: (CConstant a) -> CExpression a

-- | C99 compound literal
CCompoundLit :: (CDeclaration a) -> (CInitializerList a) -> a -> CExpression a

-- | GNU C compound statement as expr
CStatExpr :: (CStatement a) -> a -> CExpression a

-- | GNU C address of label
CLabAddrExpr :: !Ident -> a -> CExpression a

-- | builtin expressions, see <a>CBuiltin</a> objective-c additions
CBuiltinExpr :: (CBuiltinThing a) -> CExpression a

-- | Code block definition, new-style params, compound statement
CBlockExpr :: ([CDeclaration a], Bool) -> (CStatement a) -> a -> CExpression a

-- | Obj-c message
ObjCMessageExpr :: (ObjCMessageExpression a) -> a -> CExpression a

-- | selector name
ObjCSelectorExpr :: (ObjCSelectorName a) -> a -> CExpression a
ObjCProtoExpr :: Ident -> a -> CExpression a
ObjCEncodeExpr :: (CDeclaration a) -> a -> CExpression a

-- | NSString constant
ObjCConst :: (ObjCConstant a) -> CExpression a

-- | C assignment operators (K&amp;R A7.17)
data CAssignOp
CAssignOp :: CAssignOp
CMulAssOp :: CAssignOp
CDivAssOp :: CAssignOp

-- | remainder and assignment
CRmdAssOp :: CAssignOp
CAddAssOp :: CAssignOp
CSubAssOp :: CAssignOp
CShlAssOp :: CAssignOp
CShrAssOp :: CAssignOp
CAndAssOp :: CAssignOp
CXorAssOp :: CAssignOp
COrAssOp :: CAssignOp

-- | C binary operators (K&amp;R A7.6-15)
data CBinaryOp
CMulOp :: CBinaryOp
CDivOp :: CBinaryOp

-- | remainder of division
CRmdOp :: CBinaryOp
CAddOp :: CBinaryOp
CSubOp :: CBinaryOp

-- | shift left
CShlOp :: CBinaryOp

-- | shift right
CShrOp :: CBinaryOp

-- | less
CLeOp :: CBinaryOp

-- | greater
CGrOp :: CBinaryOp

-- | less or equal
CLeqOp :: CBinaryOp

-- | greater or equal
CGeqOp :: CBinaryOp

-- | equal
CEqOp :: CBinaryOp

-- | not equal
CNeqOp :: CBinaryOp

-- | bitwise and
CAndOp :: CBinaryOp

-- | exclusive bitwise or
CXorOp :: CBinaryOp

-- | inclusive bitwise or
COrOp :: CBinaryOp

-- | logical and
CLndOp :: CBinaryOp

-- | logical or
CLorOp :: CBinaryOp

-- | C unary operator (K&amp;R A7.3-4)
data CUnaryOp

-- | prefix increment operator
CPreIncOp :: CUnaryOp

-- | prefix decrement operator
CPreDecOp :: CUnaryOp

-- | postfix increment operator
CPostIncOp :: CUnaryOp

-- | postfix decrement operator
CPostDecOp :: CUnaryOp

-- | address operator
CAdrOp :: CUnaryOp

-- | indirection operator
CIndOp :: CUnaryOp

-- | prefix plus
CPlusOp :: CUnaryOp

-- | prefix minus
CMinOp :: CUnaryOp

-- | one's complement
CCompOp :: CUnaryOp

-- | logical negation
CNegOp :: CUnaryOp

-- | GNU Builtins, which cannot be typed in C99
type CBuiltin = CBuiltinThing NodeInfo
data CBuiltinThing a

-- | <pre>
--   (expr, type)
--   </pre>
CBuiltinVaArg :: (CExpression a) -> (CDeclaration a) -> a -> CBuiltinThing a

-- | <pre>
--   (type, designator-list)
--   </pre>
CBuiltinOffsetOf :: (CDeclaration a) -> [CPartDesignator a] -> a -> CBuiltinThing a

-- | <pre>
--   (type,type)
--   </pre>
CBuiltinTypesCompatible :: (CDeclaration a) -> (CDeclaration a) -> a -> CBuiltinThing a
type ObjCMsgExpr = ObjCMessageExpression NodeInfo
type ObjCMsgSel = ObjCMessageSelector NodeInfo
type ObjCKeyArg = ObjCKeywordArg NodeInfo
type ObjCSelName = ObjCSelectorName NodeInfo
type ObjCSelKeyName = ObjCSelectorKeyName NodeInfo
data ObjCMessageExpression a
ObjCMsgExpr :: (CExpression a) -> (ObjCMessageSelector a) -> a -> ObjCMessageExpression a
ObjCMsgClass :: (ObjCClassName a) -> (ObjCMessageSelector a) -> a -> ObjCMessageExpression a
ObjCMsgSup :: (ObjCMessageSelector a) -> a -> ObjCMessageExpression a
data ObjCMessageSelector a
ObjCMsgSel :: (ObjCSelector a) -> a -> ObjCMessageSelector a
ObjCKeyArgs :: [ObjCKeywordArg a] -> a -> ObjCMessageSelector a
data ObjCKeywordArg a
ObjCKeyArg :: (ObjCSelectorKeyName a) -> (CExpression a) -> a -> ObjCKeywordArg a
data ObjCSelectorName a
ObjCSelPlain :: (ObjCSelector a) -> a -> ObjCSelectorName a
ObjCSelKeys :: [ObjCSelectorKeyName a] -> a -> ObjCSelectorName a
data ObjCSelectorKeyName a
ObjCSelKeyName :: (Maybe (ObjCSelector a)) -> a -> ObjCSelectorKeyName a

-- | C constant (K&amp;R A2.5 &amp; A7.2)
type CConst = CConstant NodeInfo

-- | Attributed string literals
type CStrLit = CStringLiteral NodeInfo
cstringOfLit :: CStringLiteral a -> CString

-- | Lift a string literal to a C constant
liftStrLit :: CStringLiteral a -> CConstant a
data CConstant a
CIntConst :: CInteger -> a -> CConstant a
CCharConst :: CChar -> a -> CConstant a
CFloatConst :: CFloat -> a -> CConstant a
CStrConst :: CString -> a -> CConstant a
data CStringLiteral a
CStrLit :: CString -> a -> CStringLiteral a

-- | Objective-C constant (NSString)
type ObjCConst = ObjCConstant NodeInfo
data ObjCConstant a
ObjCStrConst :: CString -> a -> ObjCConstant a
instance Typeable1 ObjCClassDeclarator
instance Typeable1 ObjCClassListDef
instance Typeable1 ObjCClassName
instance Typeable1 ObjCProtocolName
instance Typeable ObjCVisType
instance Typeable1 ObjCVisibilitySpec
instance Typeable ObjCMethodType
instance Typeable1 ObjCPropertyModifier
instance Typeable1 CStorageSpecifier
instance Typeable1 ObjCProtoQualifier
instance Typeable CStructTag
instance Typeable1 ObjCSelector
instance Typeable1 ObjCSelectorKeyName
instance Typeable1 ObjCSelectorName
instance Typeable1 ObjCConstant
instance Typeable1 CConstant
instance Typeable1 CStringLiteral
instance Typeable1 CDeclarator
instance Typeable1 CAttribute
instance Typeable1 CExpression
instance Typeable1 CBuiltinThing
instance Typeable1 CPartDesignator
instance Typeable1 CDeclaration
instance Typeable1 CInitializer
instance Typeable1 CDeclarationSpecifier
instance Typeable1 CTypeQualifier
instance Typeable1 CTypeSpecifier
instance Typeable1 CEnumeration
instance Typeable1 CStructureUnion
instance Typeable1 ObjCMessageExpression
instance Typeable1 ObjCMessageSelector
instance Typeable1 ObjCKeywordArg
instance Typeable1 CStatement
instance Typeable1 CCompoundBlockItem
instance Typeable1 CFunctionDef
instance Typeable1 CAssemblyStatement
instance Typeable1 CAssemblyOperand
instance Typeable1 CDerivedDeclarator
instance Typeable1 CArraySize
instance Typeable1 ObjCPropertyDeclaration
instance Typeable1 ObjCKeywordDeclarator
instance Typeable1 ObjCMethodSelector
instance Typeable1 ObjCMethodDeclaration
instance Typeable1 ObjCInterfaceDeclaration
instance Typeable1 ObjCProtocolDeclBlock
instance Typeable1 ObjCProtocolDec
instance Typeable1 ObjCCategoryDec
instance Typeable1 ObjCInstanceVariableBlock
instance Typeable1 ObjCInterface
instance Typeable1 ObjCMethodDefinition
instance Typeable1 ObjCImplementationDefinition
instance Typeable1 ObjCImplementation
instance Typeable1 ObjCCategoryImplementation
instance Typeable1 CExternalDeclaration
instance Typeable1 CTranslationUnit
instance Show a => Show (ObjCClassDeclarator a)
instance Data a => Data (ObjCClassDeclarator a)
instance Functor ObjCClassDeclarator
instance Show a => Show (ObjCClassListDef a)
instance Data a => Data (ObjCClassListDef a)
instance Show a => Show (ObjCClassName a)
instance Data a => Data (ObjCClassName a)
instance Functor ObjCClassName
instance Show a => Show (ObjCProtocolName a)
instance Data a => Data (ObjCProtocolName a)
instance Functor ObjCProtocolName
instance Show ObjCVisType
instance Data ObjCVisType
instance Enum ObjCVisType
instance Show a => Show (ObjCVisibilitySpec a)
instance Data a => Data (ObjCVisibilitySpec a)
instance Functor ObjCVisibilitySpec
instance Show ObjCMethodType
instance Data ObjCMethodType
instance Enum ObjCMethodType
instance Show a => Show (ObjCPropertyModifier a)
instance Data a => Data (ObjCPropertyModifier a)
instance Functor ObjCPropertyModifier
instance Show a => Show (CStorageSpecifier a)
instance Eq a => Eq (CStorageSpecifier a)
instance Ord a => Ord (CStorageSpecifier a)
instance Data a => Data (CStorageSpecifier a)
instance Show a => Show (ObjCProtoQualifier a)
instance Data a => Data (ObjCProtoQualifier a)
instance Functor ObjCProtoQualifier
instance Show CStructTag
instance Eq CStructTag
instance Data CStructTag
instance Data a => Data (ObjCSelector a)
instance Show a => Show (ObjCSelector a)
instance Functor ObjCSelector
instance Data a => Data (ObjCSelectorKeyName a)
instance Show a => Show (ObjCSelectorKeyName a)
instance Functor ObjCSelectorKeyName
instance Data a => Data (ObjCSelectorName a)
instance Show a => Show (ObjCSelectorName a)
instance Functor ObjCSelectorName
instance Show a => Show (ObjCConstant a)
instance Data a => Data (ObjCConstant a)
instance Functor ObjCConstant
instance Show a => Show (CConstant a)
instance Data a => Data (CConstant a)
instance Show a => Show (CStringLiteral a)
instance Data a => Data (CStringLiteral a)
instance Show a => Show (CDeclarator a)
instance Data a => Data (CDeclarator a)
instance Show a => Show (CAttribute a)
instance Data a => Data (CAttribute a)
instance Data a => Data (CExpression a)
instance Show a => Show (CExpression a)
instance Functor CExpression
instance Show a => Show (CBuiltinThing a)
instance Data a => Data (CBuiltinThing a)
instance Show a => Show (CPartDesignator a)
instance Data a => Data (CPartDesignator a)
instance Show a => Show (CDeclaration a)
instance Data a => Data (CDeclaration a)
instance Show a => Show (CInitializer a)
instance Data a => Data (CInitializer a)
instance Show a => Show (CDeclarationSpecifier a)
instance Data a => Data (CDeclarationSpecifier a)
instance Show a => Show (CTypeQualifier a)
instance Data a => Data (CTypeQualifier a)
instance Show a => Show (CTypeSpecifier a)
instance Data a => Data (CTypeSpecifier a)
instance Show a => Show (CEnumeration a)
instance Data a => Data (CEnumeration a)
instance Show a => Show (CStructureUnion a)
instance Data a => Data (CStructureUnion a)
instance Data a => Data (ObjCMessageExpression a)
instance Show a => Show (ObjCMessageExpression a)
instance Functor ObjCMessageExpression
instance Data a => Data (ObjCMessageSelector a)
instance Show a => Show (ObjCMessageSelector a)
instance Functor ObjCMessageSelector
instance Data a => Data (ObjCKeywordArg a)
instance Show a => Show (ObjCKeywordArg a)
instance Functor ObjCKeywordArg
instance Show a => Show (CStatement a)
instance Data a => Data (CStatement a)
instance Show a => Show (CCompoundBlockItem a)
instance Data a => Data (CCompoundBlockItem a)
instance Show a => Show (CFunctionDef a)
instance Data a => Data (CFunctionDef a)
instance Show a => Show (CAssemblyStatement a)
instance Data a => Data (CAssemblyStatement a)
instance Show a => Show (CAssemblyOperand a)
instance Data a => Data (CAssemblyOperand a)
instance Show a => Show (CDerivedDeclarator a)
instance Data a => Data (CDerivedDeclarator a)
instance Show a => Show (CArraySize a)
instance Data a => Data (CArraySize a)
instance Show a => Show (ObjCPropertyDeclaration a)
instance Data a => Data (ObjCPropertyDeclaration a)
instance Functor ObjCPropertyDeclaration
instance Show a => Show (ObjCKeywordDeclarator a)
instance Data a => Data (ObjCKeywordDeclarator a)
instance Functor ObjCKeywordDeclarator
instance Show a => Show (ObjCMethodSelector a)
instance Data a => Data (ObjCMethodSelector a)
instance Functor ObjCMethodSelector
instance Show a => Show (ObjCMethodDeclaration a)
instance Data a => Data (ObjCMethodDeclaration a)
instance Functor ObjCMethodDeclaration
instance Show a => Show (ObjCInterfaceDeclaration a)
instance Data a => Data (ObjCInterfaceDeclaration a)
instance Functor ObjCInterfaceDeclaration
instance Show a => Show (ObjCProtocolDeclBlock a)
instance Data a => Data (ObjCProtocolDeclBlock a)
instance Show a => Show (ObjCProtocolDec a)
instance Data a => Data (ObjCProtocolDec a)
instance Show a => Show (ObjCCategoryDec a)
instance Data a => Data (ObjCCategoryDec a)
instance Functor ObjCCategoryDec
instance Show a => Show (ObjCInstanceVariableBlock a)
instance Data a => Data (ObjCInstanceVariableBlock a)
instance Functor ObjCInstanceVariableBlock
instance Show a => Show (ObjCInterface a)
instance Data a => Data (ObjCInterface a)
instance Functor ObjCInterface
instance Show a => Show (ObjCMethodDefinition a)
instance Data a => Data (ObjCMethodDefinition a)
instance Functor ObjCMethodDefinition
instance Show a => Show (ObjCImplementationDefinition a)
instance Data a => Data (ObjCImplementationDefinition a)
instance Functor ObjCImplementationDefinition
instance Show a => Show (ObjCImplementation a)
instance Data a => Data (ObjCImplementation a)
instance Functor ObjCImplementation
instance Show a => Show (ObjCCategoryImplementation a)
instance Data a => Data (ObjCCategoryImplementation a)
instance Functor ObjCCategoryImplementation
instance Show a => Show (CExternalDeclaration a)
instance Data a => Data (CExternalDeclaration a)
instance Show a => Show (CTranslationUnit a)
instance Data a => Data (CTranslationUnit a)
instance Annotated CStringLiteral
instance Functor CStringLiteral
instance CNode t1 => Pos (CStringLiteral t1)
instance CNode t1 => CNode (CStringLiteral t1)
instance Annotated CConstant
instance Functor CConstant
instance CNode t1 => Pos (CConstant t1)
instance CNode t1 => CNode (CConstant t1)
instance Annotated ObjCConstant
instance CNode t1 => Pos (ObjCConstant t1)
instance CNode t1 => CNode (ObjCConstant t1)
instance Annotated CBuiltinThing
instance Functor CBuiltinThing
instance CNode t1 => Pos (CBuiltinThing t1)
instance CNode t1 => CNode (CBuiltinThing t1)
instance Annotated ObjCKeywordArg
instance CNode t1 => Pos (ObjCKeywordArg t1)
instance CNode t1 => CNode (ObjCKeywordArg t1)
instance Annotated ObjCMessageSelector
instance CNode t1 => Pos (ObjCMessageSelector t1)
instance CNode t1 => CNode (ObjCMessageSelector t1)
instance Annotated ObjCMessageExpression
instance CNode t1 => Pos (ObjCMessageExpression t1)
instance CNode t1 => CNode (ObjCMessageExpression t1)
instance Annotated ObjCSelector
instance CNode t1 => Pos (ObjCSelector t1)
instance CNode t1 => CNode (ObjCSelector t1)
instance Annotated ObjCSelectorKeyName
instance CNode t1 => Pos (ObjCSelectorKeyName t1)
instance CNode t1 => CNode (ObjCSelectorKeyName t1)
instance Annotated ObjCSelectorName
instance CNode t1 => Pos (ObjCSelectorName t1)
instance CNode t1 => CNode (ObjCSelectorName t1)
instance Annotated CExpression
instance CNode t1 => Pos (CExpression t1)
instance CNode t1 => CNode (CExpression t1)
instance Annotated CAttribute
instance Functor CAttribute
instance CNode t1 => Pos (CAttribute t1)
instance CNode t1 => CNode (CAttribute t1)
instance Annotated CPartDesignator
instance Functor CPartDesignator
instance CNode t1 => Pos (CPartDesignator t1)
instance CNode t1 => CNode (CPartDesignator t1)
instance Annotated CInitializer
instance CNode t1 => Pos (CInitializer t1)
instance CNode t1 => CNode (CInitializer t1)
instance Annotated CEnumeration
instance Functor CEnumeration
instance CNode t1 => Pos (CEnumeration t1)
instance CNode t1 => CNode (CEnumeration t1)
instance Annotated CStructureUnion
instance Functor CStructureUnion
instance CNode t1 => Pos (CStructureUnion t1)
instance CNode t1 => CNode (CStructureUnion t1)
instance Annotated ObjCProtoQualifier
instance CNode t1 => Pos (ObjCProtoQualifier t1)
instance CNode t1 => CNode (ObjCProtoQualifier t1)
instance Annotated CTypeQualifier
instance Functor CTypeQualifier
instance CNode t1 => Pos (CTypeQualifier t1)
instance CNode t1 => CNode (CTypeQualifier t1)
instance Annotated CTypeSpecifier
instance Functor CTypeSpecifier
instance CNode t1 => Pos (CTypeSpecifier t1)
instance CNode t1 => CNode (CTypeSpecifier t1)
instance Annotated CStorageSpecifier
instance Functor CStorageSpecifier
instance CNode t1 => Pos (CStorageSpecifier t1)
instance CNode t1 => CNode (CStorageSpecifier t1)
instance Annotated CDeclarationSpecifier
instance Functor CDeclarationSpecifier
instance CNode t1 => Pos (CDeclarationSpecifier t1)
instance CNode t1 => CNode (CDeclarationSpecifier t1)
instance Annotated CCompoundBlockItem
instance Functor CCompoundBlockItem
instance CNode t1 => Pos (CCompoundBlockItem t1)
instance CNode t1 => CNode (CCompoundBlockItem t1)
instance Annotated CAssemblyOperand
instance Functor CAssemblyOperand
instance CNode t1 => Pos (CAssemblyOperand t1)
instance CNode t1 => CNode (CAssemblyOperand t1)
instance Annotated CAssemblyStatement
instance Functor CAssemblyStatement
instance CNode t1 => Pos (CAssemblyStatement t1)
instance CNode t1 => CNode (CAssemblyStatement t1)
instance Annotated CStatement
instance CNode t1 => Pos (CStatement t1)
instance CNode t1 => CNode (CStatement t1)
instance Functor CArraySize
instance Annotated CDerivedDeclarator
instance CNode t1 => Pos (CDerivedDeclarator t1)
instance CNode t1 => CNode (CDerivedDeclarator t1)
instance Annotated CDeclarator
instance Functor CDeclarator
instance CNode t1 => Pos (CDeclarator t1)
instance CNode t1 => CNode (CDeclarator t1)
instance Annotated CDeclaration
instance CNode t1 => Pos (CDeclaration t1)
instance CNode t1 => CNode (CDeclaration t1)
instance Annotated ObjCPropertyModifier
instance CNode t1 => Pos (ObjCPropertyModifier t1)
instance CNode t1 => CNode (ObjCPropertyModifier t1)
instance Annotated ObjCPropertyDeclaration
instance CNode t1 => Pos (ObjCPropertyDeclaration t1)
instance CNode t1 => CNode (ObjCPropertyDeclaration t1)
instance Annotated ObjCKeywordDeclarator
instance CNode t1 => Pos (ObjCKeywordDeclarator t1)
instance CNode t1 => CNode (ObjCKeywordDeclarator t1)
instance Annotated ObjCMethodSelector
instance CNode t1 => Pos (ObjCMethodSelector t1)
instance CNode t1 => CNode (ObjCMethodSelector t1)
instance Annotated ObjCMethodDefinition
instance CNode t1 => Pos (ObjCMethodDefinition t1)
instance CNode t1 => CNode (ObjCMethodDefinition t1)
instance Annotated ObjCMethodDeclaration
instance CNode t1 => Pos (ObjCMethodDeclaration t1)
instance CNode t1 => CNode (ObjCMethodDeclaration t1)
instance Annotated ObjCImplementationDefinition
instance CNode t1 => Pos (ObjCImplementationDefinition t1)
instance CNode t1 => CNode (ObjCImplementationDefinition t1)
instance Annotated ObjCInterfaceDeclaration
instance CNode t1 => Pos (ObjCInterfaceDeclaration t1)
instance CNode t1 => CNode (ObjCInterfaceDeclaration t1)
instance Annotated ObjCVisibilitySpec
instance CNode t1 => Pos (ObjCVisibilitySpec t1)
instance CNode t1 => CNode (ObjCVisibilitySpec t1)
instance Annotated ObjCInstanceVariableBlock
instance CNode t1 => Pos (ObjCInstanceVariableBlock t1)
instance CNode t1 => CNode (ObjCInstanceVariableBlock t1)
instance Annotated ObjCProtocolName
instance CNode t1 => Pos (ObjCProtocolName t1)
instance CNode t1 => CNode (ObjCProtocolName t1)
instance Annotated ObjCClassName
instance CNode t1 => Pos (ObjCClassName t1)
instance CNode t1 => CNode (ObjCClassName t1)
instance Annotated ObjCClassDeclarator
instance CNode t1 => Pos (ObjCClassDeclarator t1)
instance CNode t1 => CNode (ObjCClassDeclarator t1)
instance Annotated ObjCImplementation
instance CNode t1 => Pos (ObjCImplementation t1)
instance CNode t1 => CNode (ObjCImplementation t1)
instance Annotated ObjCInterface
instance CNode t1 => Pos (ObjCInterface t1)
instance CNode t1 => CNode (ObjCInterface t1)
instance Annotated ObjCProtocolDeclBlock
instance Functor ObjCProtocolDeclBlock
instance CNode t1 => Pos (ObjCProtocolDeclBlock t1)
instance CNode t1 => CNode (ObjCProtocolDeclBlock t1)
instance Annotated ObjCProtocolDec
instance Functor ObjCProtocolDec
instance CNode t1 => Pos (ObjCProtocolDec t1)
instance CNode t1 => CNode (ObjCProtocolDec t1)
instance Annotated ObjCClassListDef
instance Functor ObjCClassListDef
instance CNode t1 => Pos (ObjCClassListDef t1)
instance CNode t1 => CNode (ObjCClassListDef t1)
instance Annotated ObjCCategoryImplementation
instance CNode t1 => Pos (ObjCCategoryImplementation t1)
instance CNode t1 => CNode (ObjCCategoryImplementation t1)
instance Annotated ObjCCategoryDec
instance CNode t1 => Pos (ObjCCategoryDec t1)
instance CNode t1 => CNode (ObjCCategoryDec t1)
instance Annotated CFunctionDef
instance Functor CFunctionDef
instance CNode t1 => Pos (CFunctionDef t1)
instance CNode t1 => CNode (CFunctionDef t1)
instance Annotated CExternalDeclaration
instance Functor CExternalDeclaration
instance CNode t1 => Pos (CExternalDeclaration t1)
instance CNode t1 => CNode (CExternalDeclaration t1)
instance Annotated CTranslationUnit
instance Functor CTranslationUnit
instance CNode t1 => Pos (CTranslationUnit t1)
instance CNode t1 => CNode (CTranslationUnit t1)
instance Functor CInitializer
instance Functor CStatement
instance Functor CDerivedDeclarator
instance Functor CDeclaration


-- | Functions to assist with writing abstract syntax manually.
module Language.ObjC.Syntax.Builders
idType :: CDecl
idTypeSpec :: CDeclSpec
idSpec :: CTypeSpec

-- | Create a type name of <tt>id <a>protoname</a></tt>
protoType :: Ident -> CDecl
nonode :: NodeInfo

module Language.ObjC.Syntax.Utils
getSubStmts :: CStat -> [CStat]
mapSubStmts :: (CStat -> Bool) -> (CStat -> CStat) -> CStat -> CStat
mapBlockItemStmts :: (CStat -> Bool) -> (CStat -> CStat) -> CBlockItem -> CBlockItem
getLabels :: CStat -> [Ident]


-- | Base type for errors occurring in parsing, analysing and
--   pretty-printing. With ideas from Simon Marlow's <a>An extensible
--   dynamically-typed hierarchy of execeptions [2006]</a>
module Language.ObjC.Data.Error

-- | Error levels (severity)
data ErrorLevel
LevelWarn :: ErrorLevel
LevelError :: ErrorLevel
LevelFatal :: ErrorLevel

-- | return <tt>True</tt> when the given error makes it impossible to
--   continue analysis or compilation.
isHardError :: Error ex => ex -> Bool

-- | errors in Language.ObjC are instance of <a>Error</a>
class (Typeable e, Show e) => Error e where fromError (CError e) = cast e toError = CError changeErrorLevel e lvl = if errorLevel e == lvl then e else error $ "changeErrorLevel: not possible for " ++ show e
errorInfo :: Error e => e -> ErrorInfo
toError :: Error e => e -> CError
fromError :: Error e => CError -> (Maybe e)
changeErrorLevel :: Error e => e -> ErrorLevel -> e

-- | position of an <tt>Error</tt>
errorPos :: Error e => e -> Position

-- | severity level of an <tt>Error</tt>
errorLevel :: Error e => e -> ErrorLevel

-- | message lines of an <tt>Error</tt>
errorMsgs :: Error e => e -> [String]

-- | <tt>supertype</tt> of all errors
data CError
CError :: err -> CError

-- | information attached to every error in Language.ObjC
data ErrorInfo
ErrorInfo :: ErrorLevel -> Position -> [String] -> ErrorInfo
showError :: Error e => String -> e -> String

-- | converts an error into a string using a fixed format
--   
--   <ul>
--   <li>either the lines of the long error message or the short message
--   has to be non-empty</li>
--   <li>the format is</li>
--   </ul>
--   
--   <pre>
--   &lt;fname&gt;:&lt;row&gt;: (column &lt;col&gt;) [&lt;err lvl&gt;]
--     &gt;&gt;&gt; &lt;line_1&gt;
--     &lt;line_2&gt;
--       ...
--     &lt;line_n&gt;
--   </pre>
showErrorInfo :: String -> ErrorInfo -> String
mkErrorInfo :: ErrorLevel -> String -> NodeInfo -> ErrorInfo

-- | error raised if a operation requires an unsupported or not yet
--   implemented feature.
data UnsupportedFeature
unsupportedFeature :: Pos a => String -> a -> UnsupportedFeature
unsupportedFeature_ :: String -> UnsupportedFeature

-- | unspecified error raised by the user (in case the user does not want
--   to define her own error types).
data UserError
userErr :: String -> UserError

-- | raise a fatal internal error; message may have multiple lines
internalErr :: String -> a
instance Typeable ErrorInfo
instance Typeable CError
instance Typeable UnsupportedFeature
instance Typeable UserError
instance Eq ErrorLevel
instance Ord ErrorLevel
instance Show UserError
instance Error UserError
instance Show UnsupportedFeature
instance Error UnsupportedFeature
instance Error CError
instance Show CError
instance Error ErrorInfo
instance Show ErrorInfo
instance Show ErrorLevel


-- | Compile time input abstraction for the parser, relying on ByteString.
--   The String interface only supports Latin-1 since alex-3, as alex now
--   requires byte based access to the input stream.
module Language.ObjC.Data.InputStream
type InputStream = ByteString

-- | read a file into an <a>InputStream</a>
readInputStream :: FilePath -> IO InputStream

-- | convert <a>InputStream</a> to <a>String</a>
inputStreamToString :: InputStream -> String

-- | convert a <a>String</a> to an <a>InputStream</a>
inputStreamFromString :: String -> InputStream

-- | <tt>(b,is') = takeByte is</tt> reads and removes the first byte
--   <tt>b</tt> from the <a>InputStream</a> <tt>is</tt>
takeByte :: InputStream -> (Word8, InputStream)

-- | <tt>(c,is') = takeChar is</tt> reads and removes the first character
--   <tt>c</tt> from the <a>InputStream</a> <tt>is</tt>
takeChar :: InputStream -> (Char, InputStream)

-- | return <tt>True</tt> if the given input stream is empty
inputStreamEmpty :: InputStream -> Bool

-- | <tt>str = takeChars n is</tt> returns the first <tt>n</tt> characters
--   of the given input stream, without removing them
takeChars :: Int -> InputStream -> [Char]

-- | <tt>countLines</tt> returns the number of text lines in the given
--   <a>InputStream</a>
countLines :: InputStream -> Int


-- | Invoking external preprocessors.
module Language.ObjC.System.Preprocess

-- | <a>Preprocessor</a> encapsulates the abstract interface for invoking C
--   preprocessors
class Preprocessor cpp
parseCPPArgs :: Preprocessor cpp => cpp -> [String] -> Either String (CppArgs, [String])
runCPP :: Preprocessor cpp => cpp -> CppArgs -> IO ExitCode

-- | Generic Options for the preprocessor
data CppOption
IncludeDir :: FilePath -> CppOption
Define :: String -> String -> CppOption
Undefine :: String -> CppOption
IncludeFile :: FilePath -> CppOption

-- | Generic arguments for the preprocessor
data CppArgs
CppArgs :: [CppOption] -> [String] -> Maybe FilePath -> FilePath -> Maybe FilePath -> CppArgs
cppOptions :: CppArgs -> [CppOption]
extraOptions :: CppArgs -> [String]
cppTmpDir :: CppArgs -> Maybe FilePath
inputFile :: CppArgs -> FilePath
outputFile :: CppArgs -> Maybe FilePath

-- | use the given preprocessor arguments without analyzing them
rawCppArgs :: [String] -> FilePath -> CppArgs

-- | add a typed option to the given preprocessor arguments
addCppOption :: CppArgs -> CppOption -> CppArgs

-- | add a string option to the given preprocessor arguments
addExtraOption :: CppArgs -> String -> CppArgs

-- | Cpp arguments that only specify the input file name.
cppFile :: FilePath -> CppArgs

-- | run the preprocessor and return an <a>InputStream</a> if
--   preprocesssing succeeded
runPreprocessor :: Preprocessor cpp => cpp -> CppArgs -> IO (Either ExitCode InputStream)

-- | guess whether a file is preprocessed (file end with .i)
isPreprocessed :: FilePath -> Bool


-- | Invoking gcc for preprocessing and compiling.
module Language.ObjC.System.GCC

-- | <tt>GCC</tt> represents a reference to the gcc compiler
data GCC

-- | create a reference to <tt>gcc</tt>
newGCC :: FilePath -> GCC
instance Preprocessor GCC

module Language.ObjC.System


-- | Syntax of C files: The abstract syntax tree and constants.
module Language.ObjC.Syntax


-- | Common data types for Language.ObjC: Identifiers, unique names, source
--   code locations, ast node attributes and extensible errors.
module Language.ObjC.Data

-- | References uniquely determining a struct, union or enum type. Those
--   are either identified by an string identifier, or by a unique name
--   (anonymous types).
data SUERef
AnonymousRef :: Name -> SUERef
NamedRef :: Ident -> SUERef

-- | Return true if the struct/union/enum reference is anonymous.
isAnonymousRef :: SUERef -> Bool

-- | C identifiers
data Ident

-- | build an identifier from a string.
--   
--   <ul>
--   <li>only minimal error checking, e.g., the characters of the
--   identifier are not checked for being alphanumerical only; the correct
--   lexis of the identifier should be ensured by the caller, e.g., the
--   scanner.</li>
--   <li>for reasons of simplicity the complete lexeme is hashed.</li>
--   </ul>
mkIdent :: Position -> String -> Name -> Ident

-- | string of an identifier
identToString :: Ident -> String

-- | returns an <i>internal</i> identifier (has internal position and no
--   unique name)
internalIdent :: String -> Ident

-- | return <tt>True</tt> if the given identifier is <i>internal</i>
isInternalIdent :: Ident -> Bool

-- | returns a <i>builtin</i> identifier (has builtin position and no
--   unique name)
builtinIdent :: String -> Ident

-- | Name is a unique identifier
newtype Name
Name :: Int -> Name
nameId :: Name -> Int

-- | return an infinite stream of <a>Name</a>s starting with
--   <tt>nameId</tt> 0
newNameSupply :: [Name]

-- | uniform representation of source file positions
data Position
Position :: {-# UNPACK #-} !Int -> String -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> Position

-- | absolute offset in the preprocessed file
posOffset' :: Position -> {-# UNPACK #-} !Int

-- | source file
posFile' :: Position -> String

-- | row (line) in the original file. Affected by #LINE pragmas.
posRow' :: Position -> {-# UNPACK #-} !Int

-- | column in the preprocessed file. Inaccurate w.r.t. to the original
--   file in the presence of preprocessor macros.
posColumn' :: Position -> {-# UNPACK #-} !Int
NoPosition :: Position
BuiltinPosition :: Position
InternalPosition :: Position

-- | class of type which aggregate a source code location
class Pos a
posOf :: Pos a => a -> Position

-- | initialize a Position to the start of the translation unit starting in
--   the given file
initPos :: FilePath -> Position

-- | no position (for unknown position information)
nopos :: Position

-- | position attached to built-in objects
builtinPos :: Position

-- | position used for internal errors
internalPos :: Position
posFile :: Position -> String
posRow :: Position -> Int

-- | <i>Deprecated: column number information is inaccurate in presence of
--   macros - do not rely on it. </i>
posColumn :: Position -> Int

-- | returns <tt>True</tt> if the given position refers to an actual source
--   file
isSourcePos :: Position -> Bool

-- | returns <tt>True</tt> if the given position refers to a builtin
--   definition
isBuiltinPos :: Position -> Bool

-- | returns <tt>True</tt> if the given position is internal
isInternalPos :: Position -> Bool

-- | Parsed entity attribute
data NodeInfo
OnlyPos :: !Position -> {-# UNPACK #-} !PosLength -> NodeInfo
NodeInfo :: !Position -> {-# UNPACK #-} !PosLength -> {-# UNPACK #-} !Name -> NodeInfo

-- | a class for convenient access to the attributes of an attributed
--   object
class CNode a
nodeInfo :: CNode a => a -> NodeInfo
fileOfNode :: CNode a => a -> Maybe FilePath
posOfNode :: NodeInfo -> Position
nameOfNode :: NodeInfo -> Maybe Name

-- | create a node with neither name nor positional information
undefNode :: NodeInfo

-- | | Given only a source position, create a new node attribute
mkNodeInfoOnlyPos :: Position -> NodeInfo

-- | Given a source position and a unique name, create a new attribute
--   identifier
mkNodeInfo :: Position -> Name -> NodeInfo

-- | <i>Deprecated: use undefNode instead </i>
internalNode :: NodeInfo


-- | This module provides a pretty printer for the parse tree (<a>AST</a>).
module Language.ObjC.Pretty

-- | A class of types which can be pretty printed
class Pretty p where pretty = prettyPrec 0 prettyPrec _ = pretty
pretty :: Pretty p => p -> Doc
prettyPrec :: Pretty p => Int -> p -> Doc

-- | Pretty print the given tranlation unit, but replace declarations from
--   header files with <tt>#include</tt> directives.
--   
--   The resulting file may not compile (because of missing
--   <tt>#define</tt> directives and similar things), but is very useful
--   for testing, as otherwise the pretty printed file will be cluttered
--   with declarations from system headers.
prettyUsingInclude :: CTranslUnit -> Doc
instance Pretty CStrLit
instance Pretty CConst
instance Pretty CUnaryOp
instance Pretty CBinaryOp
instance Pretty CAssignOp
instance Pretty CBuiltin
instance Pretty ObjCKeyArg
instance Pretty ObjCMsgSel
instance Pretty ObjCMsgExpr
instance Pretty ObjCSelKeyName
instance Pretty ObjCSelName
instance Pretty ObjCConst
instance Pretty CExpr
instance Pretty CAttr
instance Pretty CDesignator
instance Pretty CInit
instance Pretty CArrSize
instance Pretty CDeclr
instance Pretty CEnum
instance Pretty CStructTag
instance Pretty CStructUnion
instance Pretty ObjCProtoQual
instance Pretty CTypeQual
instance Pretty CTypeSpec
instance Pretty CStorageSpec
instance Pretty CDeclSpec
instance Pretty CDecl
instance Pretty CBlockItem
instance Pretty CAsmOperand
instance Pretty CAsmStmt
instance Pretty CStat
instance Pretty ObjCProtoNm
instance Pretty ObjCClassNm
instance Pretty ObjCVisType
instance Pretty ObjCVisSpec
instance Pretty ObjCInstanceVarBlock
instance Pretty ObjCPropMod
instance Pretty ObjCPropDecl
instance Pretty ObjCKeyDeclr
instance Pretty ObjCSel
instance Pretty ObjCMethodSel
instance Pretty ObjCMethodType
instance Pretty ObjCMethodDef
instance Pretty ObjCMethodDecl
instance Pretty ObjCIfaceDecl
instance Pretty ObjCProtoDeclBlock
instance Pretty ObjCProtoDec
instance Pretty ObjCImplDef
instance Pretty ObjCImpl
instance Pretty ObjCIface
instance Pretty ObjCCatImpl
instance Pretty ObjCCatDec
instance Pretty ObjCClassDeclr
instance Pretty ObjCClassDef
instance Pretty CFunDef
instance Pretty CExtDecl
instance Pretty CTranslUnit


-- | Language.ObjC parser
module Language.ObjC.Parser

-- | <tt>parseC input initialPos</tt> parses the given preprocessed
--   Objective-C source input and returns the AST or a list of parse
--   errors.
parseC :: InputStream -> Position -> Either ParseError CTranslUnit
parseLazyC :: InputStream -> Position -> ([CExtDecl], Either ParseError ())

-- | Default parser type, so CExtDecls can be parsed lazily
type P a = LP [CExtDecl] a

-- | execute the given parser on the supplied input stream. returns
--   <a>ParseError</a> if the parser failed, and a pair of result and
--   remaining name supply otherwise
--   
--   Lazy parsing results are ignored.
--   
--   Synopsis: <tt>execParser parser inputStream initialPos
--   predefinedTypedefs uniqNameSupply</tt>
execParser :: LP [s] a -> InputStream -> Position -> [Ident] -> [Name] -> Either ParseError (a, [Name])

-- | execute the given parser on the supplied input stream.
--   
--   returns a lazy list of results, and either the parse result or a
--   ParseError if there was an error.
--   
--   The list should be consumed as far as possible before checking the
--   result is evaluated for maximum laziness.
--   
--   Synopsis: <tt>execParser parser inputStream initialPos
--   predefinedTypedefs uniqNameSupply</tt>
execLazyParser :: LP [s] a -> InputStream -> Position -> [Ident] -> [Name] -> ([s], Either ParseError a)

-- | run the given parser using a new name supply and builtin typedefs see
--   <a>execParser</a>
--   
--   Synopsis: <tt>runParser parser inputStream initialPos</tt>
execParser_ :: P a -> InputStream -> Position -> Either ParseError a
builtinTypeNames :: [Ident]

-- | <tt>translUnitP</tt> provides a parser for a complete C translation
--   unit, i.e. a list of external declarations.
translUnitP :: P CTranslUnit

-- | <tt>extDeclP</tt> provides a parser for an external (file-scope)
--   declaration
extDeclP :: P CExtDecl

-- | <tt>statementP</tt> provides a parser for C statements
statementP :: P CStat

-- | <tt>expressionP</tt> provides a parser for C expressions
expressionP :: P CExpr
newtype ParseError
ParseError :: ([String], Position) -> ParseError


-- | This module contains definitions for representing C translation units.
--   In contrast to <a>AST</a>, the representation tries to express the
--   semantics of of a translation unit.
module Language.ObjC.Analysis.SemRep

-- | Composite type definitions (tags)
data TagDef
CompDef :: CompType -> TagDef
EnumDef :: EnumType -> TagDef

-- | return the type corresponding to a tag definition
typeOfTagDef :: TagDef -> TypeName

-- | All datatypes aggregating a declaration are instances of
--   <tt>Declaration</tt>
class Declaration n
getVarDecl :: Declaration n => n -> VarDecl

-- | get the variable identifier of a declaration (only safe if the the
--   declaration is known to have a name)
declIdent :: Declaration n => n -> Ident

-- | get the variable name of a <tt>Declaration</tt>
declName :: Declaration n => n -> VarName

-- | get the type of a <tt>Declaration</tt>
declType :: Declaration n => n -> Type

-- | get the declaration attributes of a <tt>Declaration</tt>
declAttrs :: Declaration n => n -> DeclAttrs

-- | identifiers, typedefs and enumeration constants (namespace sum)
data IdentDecl

-- | object or function declaration
Declaration :: Decl -> IdentDecl

-- | object definition
ObjectDef :: ObjDef -> IdentDecl

-- | function definition
FunctionDef :: FunDef -> IdentDecl

-- | definition of an enumerator
EnumeratorDef :: Enumerator -> IdentDecl

-- | textual description of the kind of an object
objKindDescr :: IdentDecl -> String

-- | <tt>splitIdentDecls includeAllDecls</tt> splits a map of object,
--   function and enumerator declarations and definitions into one map
--   holding declarations, and three maps for object definitions,
--   enumerator definitions and function definitions. If
--   <tt>includeAllDecls</tt> is <tt>True</tt> all declarations are present
--   in the first map, otherwise only those where no corresponding
--   definition is available.
splitIdentDecls :: Bool -> Map Ident IdentDecl -> (Map Ident Decl, (Map Ident Enumerator, Map Ident ObjDef, Map Ident FunDef))

-- | global declaration/definition table returned by the analysis
data GlobalDecls
GlobalDecls :: Map Ident IdentDecl -> Map SUERef TagDef -> Map Ident TypeDef -> GlobalDecls
gObjs :: GlobalDecls -> Map Ident IdentDecl
gTags :: GlobalDecls -> Map SUERef TagDef
gTypeDefs :: GlobalDecls -> Map Ident TypeDef

-- | empty global declaration table
emptyGlobalDecls :: GlobalDecls

-- | filter global declarations
filterGlobalDecls :: (DeclEvent -> Bool) -> GlobalDecls -> GlobalDecls

-- | merge global declarations
mergeGlobalDecls :: GlobalDecls -> GlobalDecls -> GlobalDecls

-- | Declaration events
--   
--   Those events are reported to callbacks, which are executed during the
--   traversal.
data DeclEvent

-- | file-scope struct/union/enum event
TagEvent :: TagDef -> DeclEvent

-- | file-scope declaration or definition
DeclEvent :: IdentDecl -> DeclEvent

-- | parameter declaration
ParamEvent :: ParamDecl -> DeclEvent

-- | local variable declaration or definition
LocalEvent :: IdentDecl -> DeclEvent

-- | a type definition
TypeDefEvent :: TypeDef -> DeclEvent

-- | assembler block
AsmEvent :: AsmBlock -> DeclEvent

-- | Declarations, which aren't definitions
data Decl
Decl :: VarDecl -> NodeInfo -> Decl

-- | Object Definitions
--   
--   An object definition is a declaration together with an initializer.
--   
--   If the initializer is missing, it is a tentative definition, i.e. a
--   definition which might be overriden later on.
data ObjDef
ObjDef :: VarDecl -> (Maybe Initializer) -> NodeInfo -> ObjDef

-- | Returns <tt>True</tt> if the given object definition is tentative.
isTentative :: ObjDef -> Bool

-- | Function definitions
--   
--   A function definition is a declaration together with a statement (the
--   function body).
data FunDef
FunDef :: VarDecl -> Stmt -> NodeInfo -> FunDef

-- | Parameter declaration
data ParamDecl
ParamDecl :: VarDecl -> NodeInfo -> ParamDecl
AbstractParamDecl :: VarDecl -> NodeInfo -> ParamDecl

-- | Struct/Union member declaration
data MemberDecl

-- | <pre>
--   MemberDecl vardecl bitfieldsize node
--   </pre>
MemberDecl :: VarDecl -> (Maybe Expr) -> NodeInfo -> MemberDecl

-- | <pre>
--   AnonBitField typ size
--   </pre>
AnonBitField :: Type -> Expr -> NodeInfo -> MemberDecl

-- | <tt>typedef</tt> definitions.
--   
--   The identifier is a new name for the given type.
data TypeDef
TypeDef :: Ident -> Type -> Attributes -> NodeInfo -> TypeDef

-- | return the idenitifier of a <tt>typedef</tt>
identOfTypeDef :: TypeDef -> Ident

-- | Generic variable declarations
data VarDecl
VarDecl :: VarName -> DeclAttrs -> Type -> VarDecl

-- | Declaration attributes of the form <tt>DeclAttrs isInlineFunction
--   storage linkage attrs</tt>
--   
--   They specify the storage and linkage of a declared object.
data DeclAttrs

-- | <pre>
--   DeclAttrs inline storage attrs
--   </pre>
DeclAttrs :: Bool -> Storage -> Attributes -> DeclAttrs
isExtDecl :: Declaration n => n -> Bool

-- | Storage duration and linkage of a variable
data Storage

-- | no storage
NoStorage :: Storage

-- | automatic storage (optional: register)
Auto :: Register -> Storage

-- | static storage, linkage spec and thread local specifier (gnu c)
Static :: Linkage -> ThreadLocal -> Storage

-- | function, either internal or external linkage
FunLinkage :: Linkage -> Storage

-- | get the <a>Storage</a> of a declaration
declStorage :: Declaration d => d -> Storage
type ThreadLocal = Bool
type Register = Bool

-- | Linkage: Either no linkage, internal to the translation unit or
--   external
data Linkage
NoLinkage :: Linkage
InternalLinkage :: Linkage
ExternalLinkage :: Linkage

-- | return <tt>True</tt> if the object has linkage
hasLinkage :: Storage -> Bool

-- | Get the linkage of a definition
declLinkage :: Declaration d => d -> Linkage

-- | types of C objects
data Type

-- | a non-derived type
DirectType :: TypeName -> TypeQuals -> Attributes -> Type

-- | pointer type
PtrType :: Type -> TypeQuals -> Attributes -> Type

-- | block type
BlockType :: Type -> TypeQuals -> Attributes -> Type

-- | array type
ArrayType :: Type -> ArraySize -> TypeQuals -> Attributes -> Type

-- | function type
FunctionType :: FunType -> Attributes -> Type

-- | a defined type
TypeDefType :: TypeDefRef -> TypeQuals -> Attributes -> Type

-- | Function types are of the form <tt>FunType return-type params
--   isVariadic</tt>.
--   
--   If the parameter types aren't yet known, the function has type
--   <tt>FunTypeIncomplete type attrs</tt>.
data FunType
FunType :: Type -> [ParamDecl] -> Bool -> FunType
FunTypeIncomplete :: Type -> FunType

-- | An array type may either have unknown size or a specified array size,
--   the latter either variable or constant. Furthermore, when used as a
--   function parameters, the size may be qualified as <i>static</i>. In a
--   function prototype, the size may be `Unspecified variable size'
--   (<tt>[*]</tt>).
data ArraySize

-- | <pre>
--   UnknownArraySize is-starred
--   </pre>
UnknownArraySize :: Bool -> ArraySize

-- | <pre>
--   FixedSizeArray is-static size-expr
--   </pre>
ArraySize :: Bool -> Expr -> ArraySize

-- | typdef references If the actual type is known, it is attached for
--   convenience
data TypeDefRef
TypeDefRef :: Ident -> (Maybe Type) -> NodeInfo -> TypeDefRef

-- | normalized type representation
data TypeName
TyVoid :: TypeName
TyIntegral :: IntType -> TypeName
TyFloating :: FloatType -> TypeName
TyComplex :: FloatType -> TypeName
TyComp :: CompTypeRef -> TypeName
TyEnum :: EnumTypeRef -> TypeName
TyBuiltin :: BuiltinType -> TypeName

-- | Builtin type (va_list, anything)
data BuiltinType
TyVaList :: BuiltinType
TyAny :: BuiltinType

-- | integral types (C99 6.7.2.2)
data IntType
TyBool :: IntType
TyChar :: IntType
TySChar :: IntType
TyUChar :: IntType
TyShort :: IntType
TyUShort :: IntType
TyInt :: IntType
TyUInt :: IntType
TyLong :: IntType
TyULong :: IntType
TyLLong :: IntType
TyULLong :: IntType

-- | floating point type (C99 6.7.2.2)
data FloatType
TyFloat :: FloatType
TyDouble :: FloatType
TyLDouble :: FloatType

-- | accessor class : struct/union/enum names
class HasSUERef a
sueRef :: HasSUERef a => a -> SUERef

-- | accessor class : composite type tags (struct or union)
class HasCompTyKind a
compTag :: HasCompTyKind a => a -> CompTyKind

-- | composite type declarations
data CompTypeRef
CompTypeRef :: SUERef -> CompTyKind -> NodeInfo -> CompTypeRef

-- | Composite type (struct or union).
data CompType
CompType :: SUERef -> CompTyKind -> [MemberDecl] -> Attributes -> NodeInfo -> CompType

-- | return the type of a composite type definition
typeOfCompDef :: CompType -> TypeName

-- | a tag to determine wheter we refer to a <tt>struct</tt> or
--   <tt>union</tt>, see <a>CompType</a>.
data CompTyKind
StructTag :: CompTyKind
UnionTag :: CompTyKind
data EnumTypeRef
EnumTypeRef :: SUERef -> NodeInfo -> EnumTypeRef

-- | Representation of C enumeration types
data EnumType

-- | <pre>
--   EnumType name enumeration-constants attrs node
--   </pre>
EnumType :: SUERef -> [Enumerator] -> Attributes -> NodeInfo -> EnumType

-- | return the type of an enum definition
typeOfEnumDef :: EnumType -> TypeName

-- | An Enumerator consists of an identifier, a constant expressions and
--   the link to its type
data Enumerator
Enumerator :: Ident -> Expr -> EnumType -> NodeInfo -> Enumerator

-- | Type qualifiers: constant, volatile, proto, and restrict
data TypeQuals
TypeQuals :: Bool -> Bool -> Bool -> ProtoQuals -> TypeQuals
constant :: TypeQuals -> Bool
volatile :: TypeQuals -> Bool
restrict :: TypeQuals -> Bool
protocol :: TypeQuals -> ProtoQuals

-- | no type qualifiers
noTypeQuals :: TypeQuals

-- | merge (<i>&amp;&amp;</i>) two type qualifier sets
mergeTypeQuals :: TypeQuals -> TypeQuals -> TypeQuals
data ProtoQuals
ProtoQuals :: Bool -> Bool -> Bool -> Bool -> Bool -> ProtoQuals
inQ :: ProtoQuals -> Bool
outQ :: ProtoQuals -> Bool
inoutQ :: ProtoQuals -> Bool
bycopyQ :: ProtoQuals -> Bool
onewayQ :: ProtoQuals -> Bool
noProtoQuals :: ProtoQuals

-- | merge (<i>&amp;&amp;</i>) two protocol qualifier sets
mergeProtoQuals :: ProtoQuals -> ProtoQuals -> ProtoQuals

-- | Convert protocol qualifier from AST representation
protoFromAST :: ObjCProtoQualifier a -> ProtoQuals

-- | <tt>VarName name assembler-name</tt> is a name of an declared object
data VarName
VarName :: Ident -> (Maybe AsmName) -> VarName
NoName :: VarName
identOfVarName :: VarName -> Ident
isNoName :: VarName -> Bool

-- | Assembler name (alias for <tt>CStrLit</tt>)
type AsmName = CStrLit

-- | <tt>__attribute__</tt> annotations
--   
--   Those are of the form <tt>Attr attribute-name
--   attribute-parameters</tt>, and serve as generic properties of some
--   syntax tree elements.
--   
--   Some examples:
--   
--   <ul>
--   <li>labels can be attributed with <i>unused</i> to indicate that their
--   not used</li>
--   <li>struct definitions can be attributed with <i>packed</i> to tell
--   the compiler to use the most compact representation</li>
--   <li>declarations can be attributed with <i>deprecated</i></li>
--   <li>function declarations can be attributes with <i>noreturn</i> to
--   tell the compiler that the function will never return,</li>
--   <li>or with <i>const</i> to indicate that it is a pure function</li>
--   </ul>
--   
--   <i>TODO</i>: ultimatively, we want to parse attributes and represent
--   them in a typed way
data Attr
Attr :: Ident -> [Expr] -> NodeInfo -> Attr
type Attributes = [Attr]

-- | Empty attribute list
noAttributes :: Attributes

-- | Merge attribute lists <i>TODO</i>: currently does not remove
--   duplicates
mergeAttributes :: Attributes -> Attributes -> Attributes

-- | <a>Stmt</a> is an alias for <a>CStat</a> (Syntax)
type Stmt = CStat

-- | <a>Expr</a> is currently an alias for <a>CExpr</a> (Syntax)
type Expr = CExpr

-- | <a>Initializer</a> is currently an alias for <a>CInit</a>.
--   
--   We're planning a normalized representation, but this depends on the
--   implementation of constant expression evaluation
type Initializer = CInit

-- | Top level assembler block (alias for <tt>CStrLit</tt>)
type AsmBlock = CStrLit
instance Typeable Linkage
instance Typeable Storage
instance Typeable BuiltinType
instance Typeable IntType
instance Typeable FloatType
instance Typeable EnumTypeRef
instance Typeable CompTyKind
instance Typeable CompTypeRef
instance Typeable TypeName
instance Typeable ProtoQuals
instance Typeable TypeQuals
instance Typeable VarName
instance Typeable Attr
instance Typeable DeclAttrs
instance Typeable Enumerator
instance Typeable EnumType
instance Typeable ArraySize
instance Typeable Type
instance Typeable TypeDefRef
instance Typeable FunType
instance Typeable ParamDecl
instance Typeable VarDecl
instance Typeable FunDef
instance Typeable ObjDef
instance Typeable Decl
instance Typeable IdentDecl
instance Typeable TypeDef
instance Typeable MemberDecl
instance Typeable CompType
instance Typeable TagDef
instance Data Linkage
instance Show Linkage
instance Eq Linkage
instance Ord Linkage
instance Data Storage
instance Show Storage
instance Eq Storage
instance Ord Storage
instance Data BuiltinType
instance Data IntType
instance Eq IntType
instance Ord IntType
instance Data FloatType
instance Eq FloatType
instance Ord FloatType
instance Data EnumTypeRef
instance Eq CompTyKind
instance Ord CompTyKind
instance Data CompTyKind
instance Data CompTypeRef
instance Data TypeName
instance Data ProtoQuals
instance Eq ProtoQuals
instance Ord ProtoQuals
instance Data TypeQuals
instance Eq TypeQuals
instance Ord TypeQuals
instance Data VarName
instance Data Attr
instance Data DeclAttrs
instance Data Enumerator
instance Data EnumType
instance Data ArraySize
instance Data Type
instance Data TypeDefRef
instance Data FunType
instance Data ParamDecl
instance Data VarDecl
instance Data FunDef
instance Data ObjDef
instance Data Decl
instance Data IdentDecl
instance Data TypeDef
instance Data MemberDecl
instance Data CompType
instance Data TagDef
instance Pos Attr
instance CNode Attr
instance Pos Enumerator
instance CNode Enumerator
instance Pos EnumType
instance CNode EnumType
instance Pos CompType
instance CNode CompType
instance Pos EnumTypeRef
instance CNode EnumTypeRef
instance Pos CompTypeRef
instance CNode CompTypeRef
instance Pos TypeDefRef
instance CNode TypeDefRef
instance Pos TypeDef
instance CNode TypeDef
instance Pos MemberDecl
instance CNode MemberDecl
instance Pos ParamDecl
instance CNode ParamDecl
instance Pos FunDef
instance CNode FunDef
instance Pos ObjDef
instance CNode ObjDef
instance Pos Decl
instance CNode Decl
instance Pos DeclEvent
instance CNode DeclEvent
instance Pos IdentDecl
instance CNode IdentDecl
instance Pos TagDef
instance CNode TagDef
instance Monoid ProtoQuals
instance Monoid TypeQuals
instance Declaration Enumerator
instance HasSUERef EnumType
instance Show CompTyKind
instance HasCompTyKind CompType
instance HasSUERef CompType
instance HasSUERef EnumTypeRef
instance HasCompTyKind CompTypeRef
instance HasSUERef CompTypeRef
instance Show FloatType
instance Show IntType
instance Declaration VarDecl
instance Declaration MemberDecl
instance Declaration ParamDecl
instance Declaration FunDef
instance Declaration ObjDef
instance Declaration Decl
instance Declaration IdentDecl
instance (Declaration a, Declaration b) => Declaration (Either a b)
instance HasSUERef TagDef


-- | Errors in the semantic analysis
module Language.ObjC.Analysis.SemError

-- | InvalidASTError is caused by the violation of an invariant in the AST
newtype InvalidASTError
InvalidAST :: ErrorInfo -> InvalidASTError
invalidAST :: NodeInfo -> String -> InvalidASTError

-- | BadSpecifierError is caused by an invalid combination of specifiers
newtype BadSpecifierError
BadSpecifierError :: ErrorInfo -> BadSpecifierError
badSpecifierError :: NodeInfo -> String -> BadSpecifierError
data TypeMismatch
TypeMismatch :: String -> (NodeInfo, Type) -> (NodeInfo, Type) -> TypeMismatch
typeMismatch :: String -> (NodeInfo, Type) -> (NodeInfo, Type) -> TypeMismatch

-- | RedefError is caused by an invalid redefinition of the same identifier
--   or type
data RedefError
RedefError :: ErrorLevel -> RedefInfo -> RedefError
data RedefInfo
RedefInfo :: String -> RedefKind -> NodeInfo -> NodeInfo -> RedefInfo
data RedefKind
DuplicateDef :: RedefKind
DiffKindRedecl :: RedefKind
ShadowedDef :: RedefKind
DisagreeLinkage :: RedefKind
NoLinkageOld :: RedefKind
redefinition :: ErrorLevel -> String -> RedefKind -> NodeInfo -> NodeInfo -> RedefError
instance Typeable InvalidASTError
instance Typeable BadSpecifierError
instance Typeable RedefError
instance Typeable TypeMismatch
instance Error InvalidASTError
instance Error BadSpecifierError
instance Error RedefError
instance Show RedefError
instance Error TypeMismatch
instance Show TypeMismatch
instance Show BadSpecifierError
instance Show InvalidASTError

module Language.ObjC.Analysis.TypeUtils

-- | Constructor for a simple integral type.
integral :: IntType -> Type

-- | Constructor for a simple floating-point type.
floating :: FloatType -> Type

-- | A simple pointer with no qualifiers
simplePtr :: Type -> Type

-- | The type returned by sizeof (size_t). For now, this is just
--   <tt>int</tt>.
size_tType :: Type

-- | The type of pointer differences (ptrdiff_t). For now, this is just
--   <tt>int</tt>.
ptrDiffType :: Type

-- | The type of comparisons/guards. This is always just <tt>int</tt>.
boolType :: Type

-- | Simple <tt>void</tt> type.
voidType :: Type

-- | An unqualified <tt>void</tt> pointer.
voidPtr :: Type

-- | A <tt>const</tt>-qualified <tt>void</tt> pointer.
constVoidPtr :: Type

-- | An unqualified <tt>char</tt> pointer.
charPtr :: Type

-- | A <tt>const</tt>-qualified <tt>char</tt> pointer.
constCharPtr :: Type

-- | The type of a constant string.
stringType :: Type

-- | The builtin type of variable-length argument lists.
valistType :: Type

-- | Check whether a type is an integral type. This includes <tt>enum</tt>
--   types. This function does not attempt to resolve <tt>typedef</tt>
--   types.
isIntegralType :: Type -> Bool

-- | Check whether a type is a floating-point numeric type. This function
--   does not attempt to resolve <tt>typedef</tt> types.
isFloatingType :: Type -> Bool

-- | Check whether a type is an pointer type. This includes array types.
--   This function does not attempt to resolve <tt>typedef</tt> types.
isPointerType :: Type -> Bool

-- | Check whether a type is a scalar type. Scalar types include arithmetic
--   types and pointer types.
isScalarType :: Type -> Bool

-- | return <tt>True</tt> if the given type is a function type
--   
--   Result is undefined in the presence of undefined typeDefs
isFunctionType :: Type -> Bool

-- | Return the qualifiers of a type.
typeQuals :: Type -> TypeQuals
typeQualsUpd :: (TypeQuals -> TypeQuals) -> Type -> Type

-- | Return the attributes of a type.
typeAttrs :: Type -> Attributes
typeAttrsUpd :: (Attributes -> Attributes) -> Type -> Type

-- | Return the base type of a pointer or array type. It is an error to
--   call this function with a type that is not in one of those two
--   categories.
baseType :: Type -> Type

-- | resolve typedefs, if possible
derefTypeDef :: Type -> Type

-- | Attempt to remove all references to <tt>typedef</tt> types from a
--   given type. Note that this does not dereference the types of structure
--   or union fields, so there are still cases where further dereferencing
--   is needed.
deepDerefTypeDef :: Type -> Type
canonicalType :: Type -> Type
getIntType :: Flags CIntFlag -> IntType
getFloatType :: String -> FloatType


-- | <i>WARNING</i> : This is just an implementation sketch and not very
--   well tested.
--   
--   Export <tt>SemRep</tt> entities to <tt>AST</tt> nodes.
module Language.ObjC.Analysis.Export

-- | Export Declarator
--   
--   Synopsis: <tt>exportDeclr other_specs type attributes
--   variable-name</tt>
exportDeclr :: [CDeclSpec] -> Type -> Attributes -> VarName -> ([CDeclSpec], CDeclr)

-- | Export a type to syntax
exportType :: Type -> ([CDeclSpec], [CDerivedDeclr])
exportTypeDecl :: Type -> CDecl
exportTypeSpec :: TypeName -> [CTypeSpec]
exportTypeDef :: TypeDef -> CDecl
exportCompType :: CompType -> [CTypeSpec]
exportCompTypeDecl :: CompTypeRef -> [CTypeSpec]
exportCompTypeRef :: CompType -> [CTypeSpec]
exportEnumType :: EnumType -> [CTypeSpec]
exportEnumTypeDecl :: EnumTypeRef -> [CTypeSpec]
exportEnumTypeRef :: EnumType -> [CTypeSpec]

module Language.ObjC.Analysis.TypeConversions

-- | For an arithmetic operator, if the arguments are of the given types,
--   return the type of the full expression.
arithmeticConversion :: TypeName -> TypeName -> Maybe TypeName
floatConversion :: FloatType -> FloatType -> FloatType
intConversion :: IntType -> IntType -> IntType


-- | This module manages symbols in local and global scopes.
--   
--   There are four different kind of identifiers: ordinary identifiers
--   (henceforth simply called <tt>identifier</tt>), tag names (names of
--   struct/union/enum types), labels and structure members.
module Language.ObjC.Analysis.DefTable

-- | All ordinary identifiers map to <tt>IdenTyDecl</tt>: either a typedef
--   or a object/function/enumerator
type IdentEntry = Either TypeDef IdentDecl
identOfTyDecl :: IdentEntry -> Ident

-- | Tag names map to forward declarations or definitions of
--   struct/union/enum types
type TagEntry = Either TagFwdDecl TagDef
data TagFwdDecl
CompDecl :: CompTypeRef -> TagFwdDecl
EnumDecl :: EnumTypeRef -> TagFwdDecl

-- | Table holding current definitions
data DefTable
DefTable :: NameSpaceMap Ident IdentEntry -> NameSpaceMap SUERef TagEntry -> NameSpaceMap Ident Ident -> NameSpaceMap Ident MemberDecl -> IntMap Name -> IntMap Type -> DefTable

-- | declared `ordinary identifiers'
identDecls :: DefTable -> NameSpaceMap Ident IdentEntry

-- | declared struct<i>union</i>enum tags
tagDecls :: DefTable -> NameSpaceMap SUERef TagEntry

-- | defined labels
labelDefs :: DefTable -> NameSpaceMap Ident Ident

-- | member declarations (only local)
memberDecls :: DefTable -> NameSpaceMap Ident MemberDecl

-- | link names with definitions
refTable :: DefTable -> IntMap Name
typeTable :: DefTable -> IntMap Type

-- | empty definition table, with all name space maps in global scope
emptyDefTable :: DefTable

-- | get the globally defined entries of a definition table
globalDefs :: DefTable -> GlobalDecls
inFileScope :: DefTable -> Bool

-- | Enter function scope (AND the corresponding block scope)
enterFunctionScope :: DefTable -> DefTable

-- | Leave function scope, and return the associated DefTable. Error if not
--   in function scope.
leaveFunctionScope :: DefTable -> DefTable

-- | Enter new block scope
enterBlockScope :: DefTable -> DefTable

-- | Leave innermost block scope
leaveBlockScope :: DefTable -> DefTable

-- | Enter new member declaration scope
enterMemberDecl :: DefTable -> DefTable

-- | Leave innermost member declaration scope
leaveMemberDecl :: DefTable -> ([MemberDecl], DefTable)

-- | Status of a declaration
data DeclarationStatus t

-- | new entry
NewDecl :: DeclarationStatus t

-- | old def was overwritten
Redeclared :: t -> DeclarationStatus t

-- | new def was discarded
KeepDef :: t -> DeclarationStatus t

-- | new def shadows one in outer scope
Shadowed :: t -> DeclarationStatus t

-- | kind mismatch
KindMismatch :: t -> DeclarationStatus t
declStatusDescr :: DeclarationStatus t -> String
defineTypeDef :: Ident -> TypeDef -> DefTable -> (DeclarationStatus IdentEntry, DefTable)

-- | declare/define a global object/function/typeDef
--   
--   returns <tt>Redeclared def</tt> if there is already an
--   object/function/typeDef in global scope, or <tt>DifferentKindRedec
--   def</tt> if the old declaration is of a different kind.
defineGlobalIdent :: Ident -> IdentDecl -> DefTable -> (DeclarationStatus IdentEntry, DefTable)

-- | declare/define a object/function/typeDef with lexical scope
--   
--   returns <tt>Redeclared def</tt> or <tt>DifferentKindRedec def</tt> if
--   there is already an object/function/typeDef in the same scope.
defineScopedIdent :: Ident -> IdentDecl -> DefTable -> (DeclarationStatus IdentEntry, DefTable)

-- | declare/define a object/function/typeDef with lexical scope, if the
--   given predicate holds on the old entry.
--   
--   returns <tt>Keep old_def</tt> if the old definition shouldn't be
--   overwritten, and otherwise <tt>Redeclared def</tt> or
--   <tt>DifferentKindRedecl def</tt> if there is already an
--   object/function/typeDef in the same scope.
defineScopedIdentWhen :: (IdentDecl -> Bool) -> Ident -> IdentDecl -> DefTable -> (DeclarationStatus IdentEntry, DefTable)

-- | declare a tag (fwd decl in case the struct name isn't defined yet)
declareTag :: SUERef -> TagFwdDecl -> DefTable -> (DeclarationStatus TagEntry, DefTable)

-- | define a tag
defineTag :: SUERef -> TagDef -> DefTable -> (DeclarationStatus TagEntry, DefTable)

-- | define a label Return the old label if it is already defined in this
--   function's scope
defineLabel :: Ident -> DefTable -> (DeclarationStatus Ident, DefTable)

-- | lookup identifier (object, function, typeDef, enumerator)
lookupIdent :: Ident -> DefTable -> Maybe IdentEntry

-- | lookup tag
lookupTag :: SUERef -> DefTable -> Maybe TagEntry

-- | lookup label
lookupLabel :: Ident -> DefTable -> Maybe Ident

-- | lookup an object in the innermost scope
lookupIdentInner :: Ident -> DefTable -> Maybe IdentEntry

-- | lookup an identifier in the innermost scope
lookupTagInner :: SUERef -> DefTable -> Maybe TagEntry

-- | Record the type of a node.
insertType :: DefTable -> Name -> Type -> DefTable

-- | Lookup the type of a node.
lookupType :: DefTable -> Name -> Maybe Type

-- | Merge two DefTables. If both tables contain an entry for a given key,
--   they must agree on its value.
mergeDefTable :: DefTable -> DefTable -> DefTable
instance Typeable1 DeclarationStatus
instance Data t => Data (DeclarationStatus t)
instance Eq TagEntryKind
instance Ord TagEntryKind
instance Show TagEntryKind
instance CNode TagFwdDecl
instance HasSUERef TagFwdDecl


-- | Pretty printing the semantic analysis representation. This is
--   currently only intended for debugging purposes.
module Language.ObjC.Analysis.Debug
globalDeclStats :: (FilePath -> Bool) -> GlobalDecls -> [(String, Int)]
prettyAssocs :: (Pretty k, Pretty v) => String -> [(k, v)] -> Doc
prettyAssocsWith :: String -> (k -> Doc) -> (v -> Doc) -> [(k, v)] -> Doc
instance Pretty Attr
instance Pretty Attributes
instance Pretty VarName
instance Pretty Linkage
instance Pretty Storage
instance Pretty Enumerator
instance Pretty EnumType
instance Pretty MemberDecl
instance Pretty CompType
instance Pretty TypeQuals
instance Pretty Type
instance Pretty DeclAttrs
instance Pretty ParamDecl
instance Pretty VarDecl
instance Pretty FunDef
instance Pretty ObjDef
instance Pretty TypeDef
instance Pretty Decl
instance Pretty IdentDecl
instance Pretty TagDef
instance Pretty SUERef
instance Pretty Ident
instance Pretty EnumTypeRef
instance Pretty CompTypeRef
instance Pretty CompTyKind
instance Pretty TagFwdDecl
instance (Pretty a, Pretty b) => Pretty (Either a b)
instance Pretty GlobalDecls
instance Pretty DefTable

module Language.ObjC.Analysis.Builtins
builtins :: DefTable


-- | Monad for Traversals of the C AST.
--   
--   For the traversal, we maintain a symboltable and need MonadError and
--   unique name generation facilities. Furthermore, the user may provide
--   callbacks to handle declarations and definitions.
module Language.ObjC.Analysis.TravMonad
class Monad m => MonadName m
genName :: MonadName m => m Name
class Monad m => MonadSymtab m
getDefTable :: MonadSymtab m => m DefTable
withDefTable :: MonadSymtab m => (DefTable -> (a, DefTable)) -> m a
class Monad m => MonadCError m
throwTravError :: (MonadCError m, Error e) => e -> m a
catchTravError :: MonadCError m => m a -> (CError -> m a) -> m a
recordError :: (MonadCError m, Error e) => e -> m ()
getErrors :: MonadCError m => m [CError]

-- | Traversal monad
class (Functor m, MonadName m, MonadSymtab m, MonadCError m) => MonadTrav m
handleDecl :: MonadTrav m => DeclEvent -> m ()

-- | forward declaration of a tag. Only necessary for name analysis, but
--   otherwise no semantic consequences.
handleTagDecl :: (MonadCError m, MonadSymtab m) => TagFwdDecl -> m ()

-- | define the given composite type or enumeration If there is a
--   declaration visible, overwrite it with the definition. Otherwise,
--   enter a new definition in the current namespace. If there is already a
--   definition present, yield an error (redeclaration).
handleTagDef :: MonadTrav m => TagDef -> m ()
handleEnumeratorDef :: (MonadCError m, MonadSymtab m) => Enumerator -> m ()
handleTypeDef :: MonadTrav m => TypeDef -> m ()

-- | handle object defintions (maybe tentative)
handleObjectDef :: MonadTrav m => Bool -> Ident -> ObjDef -> m ()

-- | handle function definitions
handleFunDef :: MonadTrav m => Ident -> FunDef -> m ()

-- | handle variable declarations (external object declarations and
--   function prototypes) variable declarations are either function
--   prototypes, or external declarations, and not very interesting on
--   their own. we only put them in the symbol table and call the handle.
--   declarations never override definitions
handleVarDecl :: MonadTrav m => Bool -> Decl -> m ()

-- | handle parameter declaration. The interesting part is that parameters
--   can be abstract (if they are part of a type). If they have a name, we
--   enter the name (usually in function prototype or function scope),
--   checking if there are duplicate definitions. FIXME: I think it would
--   be more transparent to handle parameter declarations in a special way
handleParamDecl :: MonadTrav m => ParamDecl -> m ()
handleAsmBlock :: MonadTrav m => AsmBlock -> m ()
enterPrototypeScope :: MonadSymtab m => m ()
leavePrototypeScope :: MonadSymtab m => m ()
enterFunctionScope :: MonadSymtab m => m ()
leaveFunctionScope :: MonadSymtab m => m ()
enterBlockScope :: MonadSymtab m => m ()
leaveBlockScope :: MonadSymtab m => m ()

-- | lookup a type definition the 'wrong kind of object' is an internal
--   error here, because the parser should distinguish typeDefs and other
--   objects
lookupTypeDef :: (MonadCError m, MonadSymtab m) => Ident -> m Type

-- | lookup an object, function or enumerator
lookupObject :: (MonadCError m, MonadSymtab m) => Ident -> m (Maybe IdentDecl)

-- | create a reference to a struct/union/enum
--   
--   This currently depends on the fact the structs are tagged with unique
--   names. We could use the name generation of TravMonad as well, which
--   might be the better choice when dealing with autogenerated code.
createSUERef :: (MonadCError m, MonadSymtab m) => NodeInfo -> Maybe Ident -> m SUERef

-- | check wheter non-recoverable errors occurred
hadHardErrors :: [CError] -> Bool
handleTravError :: MonadCError m => m a -> m (Maybe a)

-- | raise an error based on an Either argument
throwOnLeft :: (MonadCError m, Error e) => Either e a -> m a

-- | raise an error caused by a malformed AST
astError :: MonadCError m => NodeInfo -> String -> m a
warn :: (Error e, MonadCError m) => e -> m ()

-- | simple traversal monad, providing user state and callbacks
data Trav s a
runTrav :: s -> Trav s a -> Either [CError] (a, TravState s)
runTrav_ :: Trav () a -> Either [CError] (a, [CError])
data TravState s
initTravState :: s -> TravState s
withExtDeclHandler :: Trav s a -> (DeclEvent -> Trav s ()) -> Trav s a
modifyUserState :: (s -> s) -> Trav s ()
userState :: TravState s -> s
getUserState :: Trav s s
data TravOptions
TravOptions :: CLanguage -> TravOptions
language :: TravOptions -> CLanguage
modifyOptions :: (TravOptions -> TravOptions) -> Trav s ()
travErrors :: TravState s -> [CError]

-- | The variety of the C language to accept. Note: this is not yet
--   enforced.
data CLanguage
C89 :: CLanguage
C99 :: CLanguage
GNU89 :: CLanguage
GNU99 :: CLanguage
mapMaybeM :: Monad m => (Maybe a) -> (a -> m b) -> m (Maybe b)
maybeM :: Monad m => (Maybe a) -> (a -> m ()) -> m ()
mapSndM :: Monad m => (b -> m c) -> (a, b) -> m (a, c)
concatMapM :: Monad m => (a -> m [b]) -> [a] -> m [b]
instance Functor (Trav s)
instance MonadTrav (Trav s)
instance MonadCError (Trav s)
instance MonadSymtab (Trav s)
instance MonadName (Trav s)
instance Monad (Trav s)


-- | This module performs the analysis of declarations and the translation
--   of type specifications in the AST.
module Language.ObjC.Analysis.DeclAnalysis

-- | get the type of a <i>type declaration</i>
--   
--   A type declaration <tt>T</tt> may appear in thre forms:
--   
--   <ul>
--   <li><pre>typeof(T)</pre></li>
--   <li>as abstract declarator in a function prototype, as in
--   <tt>f(int)</tt></li>
--   <li>in a declaration without declarators, as in <tt>struct x { int a }
--   ;</tt></li>
--   </ul>
--   
--   Currently, <tt>analyseTypeDecl</tt> is exlusively used for analysing
--   types for GNU's <tt>typeof(T)</tt>.
--   
--   We move attributes to the type, as they have no meaning for the
--   abstract declarator
analyseTypeDecl :: MonadTrav m => CDecl -> m Type

-- | translate a type
tType :: MonadTrav m => Bool -> NodeInfo -> [CTypeQual] -> TypeSpecAnalysis -> [CDerivedDeclr] -> [CDecl] -> m Type

-- | translate a type without (syntactic) indirections Due to the GNU
--   <tt>typeof</tt> extension and typeDefs, this can be an arbitrary type
tDirectType :: MonadTrav m => Bool -> NodeInfo -> [CTypeQual] -> TypeSpecAnalysis -> m Type

-- | Mapping from num type specs to C types (C99 6.7.2-2), ignoring the
--   complex qualifier.
tNumType :: MonadCError m => NumTypeSpec -> m (Either (FloatType, Bool) IntType)
tArraySize :: MonadTrav m => CArrSize -> m ArraySize
tTypeQuals :: MonadTrav m => [CTypeQual] -> m (TypeQuals, Attributes)

-- | convert old style parameters
--   
--   This requires matching parameter names and declarations, as in the
--   following example:
--   
--   <pre>
--   int f(d,c,a,b)
--   char a,*b;
--   int c;
--   { }
--   </pre>
--   
--   is converted to
--   
--   <pre>
--   int f(int d, int c, char a, char* b)
--   </pre>
--   
--   TODO: This could be moved to syntax, as it operates on the AST only
mergeOldStyle :: MonadCError m => NodeInfo -> [CDecl] -> [CDerivedDeclr] -> m [CDerivedDeclr]
canonicalTypeSpec :: MonadTrav m => [CTypeSpec] -> m TypeSpecAnalysis
data NumBaseType
NoBaseType :: NumBaseType
BaseChar :: NumBaseType
BaseInt :: NumBaseType
BaseFloat :: NumBaseType
BaseDouble :: NumBaseType
data SignSpec
NoSignSpec :: SignSpec
Signed :: SignSpec
Unsigned :: SignSpec
data SizeMod
NoSizeMod :: SizeMod
ShortMod :: SizeMod
LongMod :: SizeMod
LongLongMod :: SizeMod
data NumTypeSpec
NumTypeSpec :: NumBaseType -> SignSpec -> SizeMod -> Bool -> NumTypeSpec
base :: NumTypeSpec -> NumBaseType
signSpec :: NumTypeSpec -> SignSpec
sizeMod :: NumTypeSpec -> SizeMod
isComplex :: NumTypeSpec -> Bool
data TypeSpecAnalysis
TSNone :: TypeSpecAnalysis
TSVoid :: TypeSpecAnalysis
TSBool :: TypeSpecAnalysis
TSNum :: NumTypeSpec -> TypeSpecAnalysis
TSTypeDef :: TypeDefRef -> TypeSpecAnalysis
TSType :: Type -> TypeSpecAnalysis
TSNonBasic :: CTypeSpec -> TypeSpecAnalysis
canonicalStorageSpec :: MonadCError m => [CStorageSpec] -> m StorageSpec
data StorageSpec
NoStorageSpec :: StorageSpec
AutoSpec :: StorageSpec
RegSpec :: StorageSpec
ThreadSpec :: StorageSpec
StaticSpec :: Bool -> StorageSpec
ExternSpec :: Bool -> StorageSpec
hasThreadLocalSpec :: StorageSpec -> Bool
isTypeDef :: [CDeclSpec] -> Bool
data VarDeclInfo
VarDeclInfo :: VarName -> Bool -> StorageSpec -> Attributes -> Type -> NodeInfo -> VarDeclInfo

-- | translate <tt>__attribute__</tt> annotations TODO: This is a unwrap
--   and wrap stub
tAttr :: (MonadCError m, MonadSymtab m) => CAttr -> m Attr

-- | construct a name for a variable TODO: more or less bogus
mkVarName :: (MonadCError m, MonadSymtab m) => NodeInfo -> Maybe Ident -> Maybe AsmName -> m VarName
getOnlyDeclr :: MonadCError m => CDecl -> m CDeclr
nameOfDecl :: MonadCError m => CDecl -> m Ident

-- | analyse declarators
analyseVarDecl :: MonadTrav m => Bool -> [CStorageSpec] -> [CAttr] -> [CTypeQual] -> TypeSpecAnalysis -> Bool -> CDeclr -> [CDecl] -> (Maybe CInit) -> m VarDeclInfo
analyseVarDecl' :: MonadTrav m => Bool -> [CDeclSpec] -> CDeclr -> [CDecl] -> (Maybe CInit) -> m VarDeclInfo
instance Eq StorageSpec
instance Ord StorageSpec
instance Show StorageSpec
instance Read StorageSpec
instance Eq NumBaseType
instance Ord NumBaseType
instance Eq SignSpec
instance Ord SignSpec
instance Eq SizeMod
instance Ord SizeMod

module Language.ObjC.Analysis.ConstEval
data MachineDesc
MachineDesc :: (IntType -> Integer) -> (FloatType -> Integer) -> (BuiltinType -> Integer) -> Integer -> Integer -> (IntType -> Integer) -> (FloatType -> Integer) -> (BuiltinType -> Integer) -> Integer -> Integer -> MachineDesc
iSize :: MachineDesc -> IntType -> Integer
fSize :: MachineDesc -> FloatType -> Integer
builtinSize :: MachineDesc -> BuiltinType -> Integer
ptrSize :: MachineDesc -> Integer
voidSize :: MachineDesc -> Integer
iAlign :: MachineDesc -> IntType -> Integer
fAlign :: MachineDesc -> FloatType -> Integer
builtinAlign :: MachineDesc -> BuiltinType -> Integer
ptrAlign :: MachineDesc -> Integer
voidAlign :: MachineDesc -> Integer
intExpr :: (Pos n, MonadName m) => n -> Integer -> m CExpr
sizeofType :: (MonadTrav m, CNode n) => MachineDesc -> n -> Type -> m Integer
alignofType :: (MonadTrav m, CNode n) => MachineDesc -> n -> Type -> m Integer
compSize :: MonadTrav m => MachineDesc -> CompTypeRef -> m Integer
intOp :: CBinaryOp -> Integer -> Integer -> Integer
intUnOp :: CUnaryOp -> Integer -> Maybe Integer
withWordBytes :: Int -> Integer -> Integer
boolValue :: CExpr -> Maybe Bool
intValue :: CExpr -> Maybe Integer
constEval :: MonadTrav m => MachineDesc -> Map Ident CExpr -> CExpr -> m CExpr

module Language.ObjC.Analysis.TypeCheck
pType :: Type -> String
typeErrorOnLeft :: MonadCError m => NodeInfo -> Either String a -> m a
typeError :: MonadCError m => NodeInfo -> String -> m a
notFound :: Ident -> Either String a
checkScalar' :: MonadCError m => NodeInfo -> Type -> m ()
checkIntegral' :: MonadCError m => NodeInfo -> Type -> m ()
assignCompatible' :: MonadCError m => NodeInfo -> CAssignOp -> Type -> Type -> m ()
binopType' :: MonadCError m => NodeInfo -> CBinaryOp -> Type -> Type -> m Type
conditionalType' :: MonadCError m => NodeInfo -> Type -> Type -> m Type
checkScalar :: Type -> Either String ()
checkIntegral :: Type -> Either String ()

-- | Determine the type of a constant.
constType :: (MonadCError m, MonadName m) => CConst -> m Type

-- | Determine whether two types are compatible.
compatible :: Type -> Type -> Either String ()

-- | Determine the composite type of two compatible types.
compositeType :: Type -> Type -> Either String Type
compositeSize :: ArraySize -> ArraySize -> Either String ArraySize
sizeEqual :: CExpr -> CExpr -> Bool
mergeAttrs :: Attributes -> Attributes -> Attributes
compositeParamDecl :: ParamDecl -> ParamDecl -> Either String ParamDecl
compositeParamDecl' :: (VarDecl -> NodeInfo -> ParamDecl) -> VarDecl -> VarDecl -> NodeInfo -> Either String ParamDecl
compositeVarDecl :: VarDecl -> VarDecl -> Either String VarDecl
compositeDeclAttrs :: DeclAttrs -> DeclAttrs -> DeclAttrs
castCompatible :: Type -> Type -> Either String ()

-- | Determine whether two types are compatible in an assignment
--   expression.
assignCompatible :: CAssignOp -> Type -> Type -> Either String ()

-- | Determine the type of a binary operation.
binopType :: CBinaryOp -> Type -> Type -> Either String Type

-- | Determine the type of a conditional expression.
conditionalType :: Type -> Type -> Either String Type
derefType :: Type -> Either String Type
varAddrType :: IdentDecl -> Either String Type

-- | Get the type of field <tt>m</tt> of type <tt>t</tt>
fieldType :: (MonadCError m, MonadSymtab m) => NodeInfo -> Ident -> Type -> m Type

-- | Get all members of a struct, union, or enum, with their types.
--   Collapse fields of anonymous members.
tagMembers :: (MonadCError m, MonadSymtab m) => NodeInfo -> TagDef -> m [(Ident, Type)]

-- | Expand an anonymous composite type into a list of member names and
--   their associated types.
expandAnonymous :: (MonadCError m, MonadSymtab m) => NodeInfo -> (VarName, Type) -> m [(Ident, Type)]
lookupSUE :: (MonadCError m, MonadSymtab m) => NodeInfo -> SUERef -> m TagDef
deepTypeAttrs :: (MonadCError m, MonadSymtab m) => Type -> m Attributes
typeDefAttrs :: (MonadCError m, MonadSymtab m) => NodeInfo -> Ident -> m Attributes
sueAttrs :: (MonadCError m, MonadSymtab m) => NodeInfo -> SUERef -> m Attributes


-- | Analyse the parse tree
--   
--   Traverses the AST, analyses declarations and invokes handlers.
module Language.ObjC.Analysis.AstAnalysis

-- | Analyse the given AST
--   
--   <tt>analyseAST ast</tt> results in global declaration dictionaries. If
--   you want to perform specific actions on declarations or definitions,
--   you may provide callbacks in the <tt>MonadTrav</tt> <tt>m</tt>.
--   
--   Returns the set of global declarations and definitions which where
--   successfully translated. It is the users responsibility to check
--   whether any hard errors occurred (<tt>runTrav</tt> does this for you).
analyseAST :: MonadTrav m => CTranslUnit -> m GlobalDecls

-- | Analyse an top-level declaration
analyseExt :: MonadTrav m => CExtDecl -> m ()

-- | Analyse a function definition
analyseFunDef :: MonadTrav m => CFunDef -> m ()

-- | Analyse a declaration other than a function definition
analyseDecl :: MonadTrav m => Bool -> CDecl -> m ()
analyseFunctionBody :: MonadTrav m => NodeInfo -> VarDecl -> CStat -> m Stmt
defineParams :: MonadTrav m => NodeInfo -> VarDecl -> m ()
tExpr :: MonadTrav m => [StmtCtx] -> ExprSide -> CExpr -> m Type
data ExprSide
LValue :: ExprSide
RValue :: ExprSide

-- | Typecheck a statement, given a statement context. The type of a
--   statement is usually <tt>void</tt>, but expression statements and
--   blocks can sometimes have other types.
tStmt :: MonadTrav m => [StmtCtx] -> CStat -> m Type
data StmtCtx
FunCtx :: VarDecl -> StmtCtx
LoopCtx :: StmtCtx
SwitchCtx :: StmtCtx
tDesignator :: MonadTrav m => Type -> [CDesignator] -> m Type
defaultMD :: MachineDesc
instance Eq ExprSide
instance Show ExprSide


-- | Analysis of the AST.
--   
--   Currently, we provide a monad for analysis and analyze declarations
--   and types. Especially note that there is no direct support for
--   analyzing function bodies and constant expressions.
--   
--   <i>NOTE</i> This is an experimental interface, and therefore the API
--   will change in the future.
--   
--   DONE:
--   
--   <ul>
--   <li>Name analysis framework</li>
--   <li>File-scope analysis</li>
--   <li>Declaration analysis</li>
--   </ul>
--   
--   TODO:
--   
--   <ul>
--   <li>Type checking expressions</li>
--   <li>Constant expression evaluation (CEE)</li>
--   <li>Typed representation of attributes (depends on CEE)</li>
--   <li>Normalized representation of initializers</li>
--   <li>Support for analyzing function bodies (depends on CEE)</li>
--   <li>Normalizing expressions and statements</li>
--   <li>Formal rules how to link back to the AST using NodeInfo
--   fields</li>
--   <li>Typed assembler representation</li>
--   </ul>
module Language.ObjC.Analysis


-- | Library for analysing and generating Objective-C code.
--   
--   See <a>http://www.sivity.net/projects/language.c</a>
module Language.ObjC

-- | preprocess (if necessary) and parse a C source file
--   
--   <pre>
--   Synopsis: parseCFile preprocesssor tmp-dir? cpp-opts file
--   Example:  parseCFile (newGCC "gcc") Nothing ["-I/usr/include/gtk-2.0"] my-gtk-exts.c
--   </pre>
parseCFile :: Preprocessor cpp => cpp -> (Maybe FilePath) -> [String] -> FilePath -> IO (Either ParseError CTranslUnit)

-- | parse an already preprocessed C file
--   
--   <pre>
--   Synopsis: parseCFilePre file.i
--   </pre>
parseCFilePre :: FilePath -> IO (Either ParseError CTranslUnit)
