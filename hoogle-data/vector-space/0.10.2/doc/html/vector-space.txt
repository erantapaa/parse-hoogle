-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Vector & affine spaces, linear maps, and derivatives
--   
@package vector-space
@version 0.10.2


-- | Groups: zero, addition, and negation (additive inverse)
module Data.AdditiveGroup

-- | Additive group <tt>v</tt>.
class AdditiveGroup v where v ^-^ v' = v ^+^ negateV v'
zeroV :: AdditiveGroup v => v
(^+^) :: AdditiveGroup v => v -> v -> v
negateV :: AdditiveGroup v => v -> v
(^-^) :: AdditiveGroup v => v -> v -> v

-- | Sum over several vectors
sumV :: (Foldable f, AdditiveGroup v) => f v -> v

-- | Monoid under group addition. Alternative to the <tt>Sum</tt> in
--   <a>Data.Monoid</a>, which uses <a>Num</a> instead of
--   <a>AdditiveGroup</a>.
newtype Sum a
Sum :: a -> Sum a
getSum :: Sum a -> a

-- | Application a unary function inside a <a>Sum</a>
inSum :: (a -> b) -> (Sum a -> Sum b)

-- | Application a binary function inside a <a>Sum</a>
inSum2 :: (a -> b -> c) -> (Sum a -> Sum b -> Sum c)
instance Eq a => Eq (Sum a)
instance Ord a => Ord (Sum a)
instance Read a => Read (Sum a)
instance Show a => Show (Sum a)
instance Bounded a => Bounded (Sum a)
instance AdditiveGroup a => AdditiveGroup (Sum a)
instance AdditiveGroup a => Monoid (Sum a)
instance Applicative Sum
instance Functor Sum
instance (HasTrie u, AdditiveGroup v) => AdditiveGroup (u :->: v)
instance AdditiveGroup a => AdditiveGroup (Maybe a)
instance AdditiveGroup v => AdditiveGroup (a -> v)
instance (AdditiveGroup u, AdditiveGroup v, AdditiveGroup w, AdditiveGroup x) => AdditiveGroup (u, v, w, x)
instance (AdditiveGroup u, AdditiveGroup v, AdditiveGroup w) => AdditiveGroup (u, v, w)
instance (AdditiveGroup u, AdditiveGroup v) => AdditiveGroup (u, v)
instance (RealFloat v, AdditiveGroup v) => AdditiveGroup (Complex v)
instance Integral a => AdditiveGroup (Ratio a)
instance AdditiveGroup CDouble
instance AdditiveGroup CFloat
instance AdditiveGroup CIntMax
instance AdditiveGroup CLLong
instance AdditiveGroup CLong
instance AdditiveGroup CShort
instance AdditiveGroup CInt
instance AdditiveGroup CSChar
instance AdditiveGroup Double
instance AdditiveGroup Float
instance AdditiveGroup Integer
instance AdditiveGroup Int
instance AdditiveGroup ()


-- | Vector spaces
--   
--   This version uses associated types instead of fundeps and requires
--   ghc-6.10 or later
module Data.VectorSpace

-- | Vector space <tt>v</tt>.
class AdditiveGroup v => VectorSpace v where type family Scalar v :: *
(*^) :: VectorSpace v => Scalar v -> v -> v

-- | Vector divided by scalar
(^/) :: (VectorSpace v, s ~ Scalar v, Fractional s) => v -> s -> v

-- | Vector multiplied by scalar
(^*) :: (VectorSpace v, s ~ Scalar v) => v -> s -> v

-- | Adds inner (dot) products.
class (VectorSpace v, AdditiveGroup (Scalar v)) => InnerSpace v
(<.>) :: InnerSpace v => v -> v -> Scalar v

-- | Linear interpolation between <tt>a</tt> (when <tt>t==0</tt>) and
--   <tt>b</tt> (when <tt>t==1</tt>).
lerp :: VectorSpace v => v -> v -> Scalar v -> v

-- | Linear combination of vectors
linearCombo :: VectorSpace v => [(v, Scalar v)] -> v

-- | Square of the length of a vector. Sometimes useful for efficiency. See
--   also <a>magnitude</a>.
magnitudeSq :: (InnerSpace v, s ~ Scalar v) => v -> s

-- | Length of a vector. See also <a>magnitudeSq</a>.
magnitude :: (InnerSpace v, s ~ Scalar v, Floating s) => v -> s

-- | Vector in same direction as given one but with length of one. If given
--   the zero vector, then return it.
normalized :: (InnerSpace v, s ~ Scalar v, Floating s) => v -> v

-- | <tt>project u v</tt> computes the projection of <tt>v</tt> onto
--   <tt>u</tt>.
project :: (InnerSpace v, s ~ Scalar v, Fractional s) => v -> v -> v
instance InnerSpace a => InnerSpace (Maybe a)
instance (HasTrie a, VectorSpace v) => VectorSpace (a :->: v)
instance InnerSpace v => InnerSpace (a -> v)
instance VectorSpace v => VectorSpace (a -> v)
instance VectorSpace v => VectorSpace (Maybe v)
instance (InnerSpace u, s ~ Scalar u, InnerSpace v, s ~ Scalar v, InnerSpace w, s ~ Scalar w, InnerSpace x, s ~ Scalar x) => InnerSpace (u, v, w, x)
instance (VectorSpace u, s ~ Scalar u, VectorSpace v, s ~ Scalar v, VectorSpace w, s ~ Scalar w, VectorSpace x, s ~ Scalar x) => VectorSpace (u, v, w, x)
instance (InnerSpace u, s ~ Scalar u, InnerSpace v, s ~ Scalar v, InnerSpace w, s ~ Scalar w) => InnerSpace (u, v, w)
instance (VectorSpace u, s ~ Scalar u, VectorSpace v, s ~ Scalar v, VectorSpace w, s ~ Scalar w) => VectorSpace (u, v, w)
instance (InnerSpace u, s ~ Scalar u, InnerSpace v, s ~ Scalar v) => InnerSpace (u, v)
instance (VectorSpace u, s ~ Scalar u, VectorSpace v, s ~ Scalar v) => VectorSpace (u, v)
instance (RealFloat v, InnerSpace v) => InnerSpace (Complex v)
instance (RealFloat v, VectorSpace v) => VectorSpace (Complex v)
instance Integral a => InnerSpace (Ratio a)
instance Integral a => VectorSpace (Ratio a)
instance InnerSpace CFloat
instance VectorSpace CFloat
instance InnerSpace CDouble
instance VectorSpace CDouble
instance InnerSpace CIntMax
instance VectorSpace CIntMax
instance InnerSpace CLLong
instance VectorSpace CLLong
instance InnerSpace CLong
instance VectorSpace CLong
instance InnerSpace CShort
instance VectorSpace CShort
instance InnerSpace CInt
instance VectorSpace CInt
instance InnerSpace CSChar
instance VectorSpace CSChar
instance InnerSpace Float
instance VectorSpace Float
instance InnerSpace Double
instance VectorSpace Double
instance InnerSpace Integer
instance VectorSpace Integer
instance InnerSpace Int
instance VectorSpace Int


-- | Basis of a vector space, as an associated type This module requires
--   ghc-6.10 or later
module Data.Basis
class VectorSpace v => HasBasis v where type family Basis v :: *
basisValue :: HasBasis v => Basis v -> v
decompose :: HasBasis v => v -> [(Basis v, Scalar v)]
decompose' :: HasBasis v => v -> (Basis v -> Scalar v)

-- | Linear combination of vectors
linearCombo :: VectorSpace v => [(v, Scalar v)] -> v
recompose :: HasBasis v => [(Basis v, Scalar v)] -> v
instance (HasBasis u, s ~ Scalar u, HasBasis v, s ~ Scalar v, HasBasis w, s ~ Scalar w) => HasBasis (u, v, w)
instance (HasBasis u, s ~ Scalar u, HasBasis v, s ~ Scalar v) => HasBasis (u, v)
instance Integral a => HasBasis (Ratio a)
instance HasBasis CDouble
instance HasBasis Double
instance HasBasis CFloat
instance HasBasis Float


-- | Affine spaces.
module Data.AffineSpace
class AdditiveGroup (Diff p) => AffineSpace p where type family Diff p
(.-.) :: AffineSpace p => p -> p -> Diff p
(.+^) :: AffineSpace p => p -> Diff p -> p

-- | Point minus vector
(.-^) :: AffineSpace p => p -> Diff p -> p

-- | Square of the distance between two points. Sometimes useful for
--   efficiency. See also <a>distance</a>.
distanceSq :: (AffineSpace p, v ~ Diff p, InnerSpace v) => p -> p -> Scalar v

-- | Distance between two points. See also <a>distanceSq</a>.
distance :: (AffineSpace p, v ~ Diff p, InnerSpace v, s ~ Scalar v, Floating (Scalar v)) => p -> p -> s

-- | Affine linear interpolation. Varies from <tt>p</tt> to <tt>p'</tt> as
--   <tt>s</tt> varies from 0 to 1. See also <a>lerp</a> (on vector
--   spaces).
alerp :: (AffineSpace p, VectorSpace (Diff p)) => p -> p -> Scalar (Diff p) -> p

-- | Compute an affine combination (weighted average) of points. The first
--   element is used as origin and is weighted such that all coefficients
--   sum to 1. For example,
--   
--   <pre>
--   affineCombo a [(0.3,b), (0.2,c)]
--   </pre>
--   
--   is equal to
--   
--   <pre>
--   a .+^ (0.3 *^ (b .-. a) ^+^ 0.2 *^ (c .-. a))
--   </pre>
--   
--   and if <tt>a</tt>, <tt>b</tt>, and <tt>c</tt> were in a vector space
--   would also be equal to
--   
--   <pre>
--   0.5 *^ a ^+^ 0.3 *^ b ^+^ 0.2 *^ c
--   </pre>
--   
--   See also <a>linearCombo</a> (on vector spaces).
affineCombo :: (AffineSpace p, v ~ Diff p, VectorSpace v) => p -> [(p, Scalar v)] -> p
instance AffineSpace p => AffineSpace (a -> p)
instance (AffineSpace p, AffineSpace q, AffineSpace r) => AffineSpace (p, q, r)
instance (AffineSpace p, AffineSpace q) => AffineSpace (p, q)
instance Integral a => AffineSpace (Ratio a)
instance AffineSpace CFloat
instance AffineSpace Float
instance AffineSpace CDouble
instance AffineSpace Double


-- | Linear maps
module Data.LinearMap

-- | Linear map, represented as an optional memo-trie from basis to values,
--   where <a>Nothing</a> means the zero map (an optimization).
data (:-*) u v

-- | Function (assumed linear) as linear map.
linear :: (HasBasis u, HasTrie (Basis u)) => (u -> v) -> (u :-* v)

-- | Apply a linear map to a vector.
lapply :: (VectorSpace v, Scalar u ~ Scalar v, HasBasis u, HasTrie (Basis u)) => (u :-* v) -> (u -> v)

-- | Evaluate a linear map on a basis element.
atBasis :: (AdditiveGroup v, HasTrie (Basis u)) => (u :-* v) -> Basis u -> v

-- | Identity linear map
idL :: (HasBasis u, HasTrie (Basis u)) => u :-* u

-- | Compose linear maps
(*.*) :: (HasBasis u, HasTrie (Basis u), HasBasis v, HasTrie (Basis v), VectorSpace w, Scalar v ~ Scalar w) => (v :-* w) -> (u :-* v) -> (u :-* w)
inLMap :: (LMap' r s -> LMap' t u) -> ((r :-* s) -> (t :-* u))
inLMap2 :: (LMap' r s -> LMap' t u -> LMap' v w) -> ((r :-* s) -> (t :-* u) -> (v :-* w))
inLMap3 :: (LMap' r s -> LMap' t u -> LMap' v w -> LMap' x y) -> ((r :-* s) -> (t :-* u) -> (v :-* w) -> (x :-* y))
liftMS :: AdditiveGroup a => (a -> b) -> (MSum a -> MSum b)
liftMS2 :: (AdditiveGroup a, AdditiveGroup b) => (a -> b -> c) -> (MSum a -> MSum b -> MSum c)
liftMS3 :: (AdditiveGroup a, AdditiveGroup b, AdditiveGroup c) => (a -> b -> c -> d) -> (MSum a -> MSum b -> MSum c -> MSum d)

-- | Apply a linear function to each element of a linear map. <tt>liftL f l
--   == linear f *.* l</tt>, but works more efficiently.
liftL :: (Functor f, AdditiveGroup (f a)) => (a -> b) -> MSum (f a) -> MSum (f b)

-- | Apply a linear binary function (not to be confused with a bilinear
--   function) to each element of a linear map.
liftL2 :: (Applicative f, AdditiveGroup (f a), AdditiveGroup (f b)) => (a -> b -> c) -> (MSum (f a) -> MSum (f b) -> MSum (f c))

-- | Apply a linear ternary function (not to be confused with a trilinear
--   function) to each element of a linear map.
liftL3 :: (Applicative f, AdditiveGroup (f a), AdditiveGroup (f b), AdditiveGroup (f c)) => (a -> b -> c -> d) -> (MSum (f a) -> MSum (f b) -> MSum (f c) -> MSum (f d))
firstL :: (HasBasis u, HasBasis u', HasBasis v, HasTrie (Basis u), HasTrie (Basis v), Scalar u ~ Scalar v, Scalar u ~ Scalar u') => (u :-* u') -> ((u, v) :-* (u', v))
instance (HasTrie (Basis u), AdditiveGroup v) => AdditiveGroup (u :-* v)
instance (HasTrie (Basis u), VectorSpace v) => VectorSpace (u :-* v)


-- | Infinite derivative towers via linear maps, using the Maclaurin
--   representation. See blog posts
--   <a>http://conal.net/blog/tag/derivatives/</a>.
module Data.Maclaurin

-- | Tower of derivatives.
data (:>) a b
D :: b -> a :-* (a :> b) -> (:>) a b
powVal :: (:>) a b -> b
derivative :: (:>) a b -> a :-* (a :> b)

-- | Sample the derivative at a basis element. Optimized for partial
--   application to save work for non-scalar derivatives.
derivAtBasis :: (HasTrie (Basis a), HasBasis a, AdditiveGroup b) => (a :> b) -> (Basis a -> (a :> b))

-- | Infinitely differentiable functions
type (:~>) a b = a -> (a :> b)

-- | Constant derivative tower.
pureD :: (AdditiveGroup b, HasBasis a, HasTrie (Basis a)) => b -> a :> b

-- | Map a <i>linear</i> function over a derivative tower.
fmapD :: (HasBasis a, HasTrie (Basis a), AdditiveGroup b) => (b -> c) -> (a :> b) -> (a :> c)

-- | Map a <i>linear</i> function over a derivative tower.
(<$>>) :: (HasBasis a, HasTrie (Basis a), AdditiveGroup b) => (b -> c) -> (a :> b) -> (a :> c)

-- | Apply a <i>linear</i> binary function over derivative towers.
liftD2 :: (HasBasis a, HasTrie (Basis a), AdditiveGroup b, AdditiveGroup c) => (b -> c -> d) -> (a :> b) -> (a :> c) -> (a :> d)

-- | Apply a <i>linear</i> ternary function over derivative towers.
liftD3 :: (HasBasis a, HasTrie (Basis a), AdditiveGroup b, AdditiveGroup c, AdditiveGroup d) => (b -> c -> d -> e) -> (a :> b) -> (a :> c) -> (a :> d) -> (a :> e)

-- | Differentiable identity function. Sometimes called "the derivation
--   variable" or similar, but it's not really a variable.
idD :: (VectorSpace u, s ~ Scalar u, VectorSpace (u :> u), VectorSpace s, HasBasis u, HasTrie (Basis u)) => u :~> u

-- | Differentiable version of <a>fst</a>
fstD :: (HasBasis a, HasTrie (Basis a), HasBasis b, HasTrie (Basis b), Scalar a ~ Scalar b) => (a, b) :~> a

-- | Differentiable version of <a>snd</a>
sndD :: (HasBasis a, HasTrie (Basis a), HasBasis b, HasTrie (Basis b), Scalar a ~ Scalar b) => (a, b) :~> b

-- | Every linear function has a constant derivative equal to the function
--   itself (as a linear map).
linearD :: (HasBasis u, HasTrie (Basis u), AdditiveGroup v) => (u -> v) -> (u :~> v)

-- | Derivative tower for applying a binary function that distributes over
--   addition, such as multiplication. A bit weaker assumption than
--   bilinearity. Is bilinearity necessary for correctness here?
distrib :: (HasBasis a, HasTrie (Basis a), AdditiveGroup b, AdditiveGroup c, AdditiveGroup u) => (b -> c -> u) -> (a :> b) -> (a :> c) -> (a :> u)

-- | Specialized chain rule. See also '(@.)'
(>-<) :: (HasBasis a, HasTrie (Basis a), VectorSpace u, AdditiveGroup (Scalar u)) => (u -> u) -> ((a :> u) -> (a :> Scalar u)) -> (a :> u) -> (a :> u)
pairD :: (HasBasis a, HasTrie (Basis a), VectorSpace b, VectorSpace c, Scalar b ~ Scalar c) => (a :> b, a :> c) -> a :> (b, c)
unpairD :: (HasBasis a, HasTrie (Basis a), VectorSpace a, VectorSpace b, VectorSpace c, Scalar b ~ Scalar c) => (a :> (b, c)) -> (a :> b, a :> c)
tripleD :: (HasBasis a, HasTrie (Basis a), VectorSpace b, VectorSpace c, VectorSpace d, Scalar b ~ Scalar c, Scalar c ~ Scalar d) => (a :> b, a :> c, a :> d) -> a :> (b, c, d)
untripleD :: (HasBasis a, HasTrie (Basis a), VectorSpace a, VectorSpace b, VectorSpace c, VectorSpace d, Scalar b ~ Scalar c, Scalar c ~ Scalar d) => (a :> (b, c, d)) -> (a :> b, a :> c, a :> d)
instance (HasBasis a, s ~ Scalar a, HasTrie (Basis a), Floating s, VectorSpace s, Scalar s ~ s) => Floating (a :> s)
instance (HasBasis a, s ~ Scalar a, HasTrie (Basis a), Fractional s, VectorSpace s, Scalar s ~ s) => Fractional (a :> s)
instance (HasBasis a, s ~ Scalar a, HasTrie (Basis a), Num s, VectorSpace s, Scalar s ~ s) => Num (a :> s)
instance (InnerSpace u, s ~ Scalar u, AdditiveGroup s, HasBasis a, HasTrie (Basis a)) => InnerSpace (a :> u)
instance (HasBasis a, HasTrie (Basis a), VectorSpace u, AdditiveGroup (Scalar u)) => VectorSpace (a :> u)
instance (HasBasis a, HasTrie (Basis a), AdditiveGroup u) => AdditiveGroup (a :> u)
instance (AdditiveGroup b, HasBasis a, HasTrie (Basis a), OrdB b, IfB b, Ord b) => Ord (a :> b)
instance (AdditiveGroup v, HasBasis u, HasTrie (Basis u), OrdB v) => OrdB (u :> v)
instance (AdditiveGroup v, HasBasis u, HasTrie (Basis u), IfB v) => IfB (u :> v)
instance Eq b => Eq (a :> b)
instance Show b => Show (a :> b)


-- | Module indirection module. For Maclaurin- vs Horner-based derivative
--   towers.
module Data.Derivative


-- | Cross products and normals
module Data.Cross

-- | Thing with a normal vector (not necessarily normalized).
class HasNormal v
normalVec :: HasNormal v => v -> v

-- | Normalized normal vector. See also <tt>cross</tt>.
normal :: (HasNormal v, InnerSpace v, Floating (Scalar v)) => v -> v

-- | Singleton
type One s = s

-- | Homogeneous pair
type Two s = (s, s)

-- | Homogeneous triple
type Three s = (s, s, s)

-- | Cross product of various forms of 2D vectors
class HasCross2 v
cross2 :: HasCross2 v => v -> v

-- | Cross product of various forms of 3D vectors
class HasCross3 v
cross3 :: HasCross3 v => v -> v -> v
instance (Num s, VectorSpace s, HasBasis s, HasTrie (Basis s), HasNormal (Two s :> Three s)) => HasNormal (Three (Two s :> s))
instance (Num s, HasTrie (Basis (s, s)), HasBasis s, Basis s ~ ()) => HasNormal (Two s :> Three s)
instance (HasBasis a, HasTrie (Basis a), VectorSpace v, HasCross3 v) => HasCross3 (a :> v)
instance Num s => HasCross3 (s, s, s)
instance (Num s, VectorSpace s, HasBasis s, HasTrie (Basis s), Basis s ~ ()) => HasNormal (Two (One s :> s))
instance (HasBasis s, HasTrie (Basis s), Basis s ~ ()) => HasNormal (One s :> Two s)
instance (HasBasis a, HasTrie (Basis a), VectorSpace v, HasCross2 v) => HasCross2 (a :> v)
instance AdditiveGroup u => HasCross2 (u, u)
