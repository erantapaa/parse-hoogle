-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A GTK widget for displaying arbitrary Data.Data.Data instances
--   
--   Screenshot: <a>http://i.imgur.com/5JlhG.png</a>
--   
--   Example use:
--   
--   <pre>
--   import DataTreeView
--   main = simpleView [(["hello","world",error "this works too"],25)]
--   </pre>
@package DataTreeView
@version 0.1.1


-- | Remark: the heavy use of strictness here is for correctly catching
--   exceptions, not for performance reasons
module DataTreeView.StrictTypes

-- | Strict lists (in both the head and tail)
--   
--   Note: Most operations for this type are provided via the
--   <a>ListLike</a> instance, but <a>ListLike</a> is not reexported here.
data StrictList a
class ToStrictList x a
strictList :: ToStrictList x a => x -> StrictList a
fromStrictList :: StrictList a -> [a]
data StrictTree a
type StrictForest a = StrictList (StrictTree a)
class ToStrictTree x a
strictTree :: ToStrictTree x a => x -> StrictTree a
class ToStrictForest y a
strictForest :: ToStrictForest y a => y -> StrictForest a

-- | Note: this function is not recursive.
modifyValue :: StrictTree a -> (a -> a) -> StrictTree a

-- | Note: this function is not recursive.
modifyChildren :: StrictTree a -> (StrictForest a -> StrictForest a) -> StrictTree a
nodeValue :: StrictTree a -> a
nodeChildren :: StrictTree t -> [StrictTree t]
fromStrictTree :: StrictTree a -> Tree a
fromStrictForest :: StrictForest a -> Forest a
instance Typeable1 StrictList
instance Typeable1 StrictTree
instance Show a => Show (StrictList a)
instance Data a => Data (StrictList a)
instance Functor StrictList
instance Foldable StrictList
instance Traversable StrictList
instance Show a => Show (StrictTree a)
instance Data a => Data (StrictTree a)
instance Functor StrictTree
instance Foldable StrictTree
instance Traversable StrictTree
instance ToStrictForest (StrictForest a) a
instance ToStrictTree x a => ToStrictForest (StrictList x) a
instance ToStrictTree x a => ToStrictForest [x] a
instance ToStrictTree (StrictTree a) a
instance ToStrictForest y a => ToStrictTree (a, y) a
instance ToStrictTree (Tree a) a
instance ToStrictTree a a
instance Monoid (StrictList a)
instance ListLike (StrictList a) a
instance FoldableLL (StrictList a) a
instance ToStrictList (StrictList a) a
instance ToStrictList x a => ToStrictList (a, x) a
instance ToStrictList [a] a
instance ToStrictList a a

module DataTreeView
data DataTreeView
DataTreeView :: TreeView -> DataTreeView
dtvTreeView :: DataTreeView -> TreeView
dtvNew :: Data d => [d] -> IO DataTreeView
dtvNewWithCH :: Data d => CustomHandler -> [d] -> IO DataTreeView
simpleView :: Data d => [d] -> IO ()
simpleViewWithCH :: Data d => CustomHandler -> [d] -> IO ()

module DataTreeView.CustomHandlers

-- | Custom handlers are used for overriding the generic formatting
--   behaviour at some values (for example, printing a <tt>String</tt>
--   directly into the <i>Constructor or value</i> column rather than as a
--   list of chars).
--   
--   If a custom handler matches (returns a <a>Just</a>), no recursion into
--   its children is performed by default. You can recurse manually using
--   <a>self</a>.
newtype CustomHandler
CH :: (forall d. Data d => d -> MCH (Maybe (StrictTree Row))) -> CustomHandler
runCH :: CustomHandler -> forall d. Data d => d -> MCH (Maybe (StrictTree Row))

-- | Show a type with some prettification like replacing <tt>[Char]</tt>
--   with <tt>String</tt>.
showType :: TypeRep -> String
showTypeOf :: Typeable a => a -> String
data MCH a

-- | Invokes the <i>final</i> Data-to-Tree conversion function, which
--   includes the generic handler, the <a>CustomHandler</a> being defined,
--   and any <a>CustomHandler</a>s <a>mappend</a>ed to the one being
--   defined.
--   
--   Thus, invoking <tt><a>self</a> x</tt> from your implementation of
--   <tt><a>runCH</a> x</tt> will usually amount to an infinite loop, but
--   invoking <tt><a>self</a> y</tt> on some child <tt>y</tt> of <tt>x</tt>
--   is fine.
self :: Data d => d -> MCH (StrictTree Row)

-- | Generates the subtree using the <a>Data</a> instance of the argument
--   (calls <a>self</a> on the children, not <a>genericHandler</a>).
--   
--   You can invoke this from your <a>CustomHandler</a> and then override
--   some attributes of the result.
genericHandler :: Data e => e -> MCH (StrictTree Row)

-- | A <a>CustomHandler</a> that only works at a fixed type (and always
--   works there), and generates a node with no children and with the
--   default text in the <i>type</i> column. The function should return the
--   <a>rowCV</a> in the first component and the <a>rowCustomInfo</a> in
--   the second.
simpleCH :: Typeable a => (a -> MCH ([CellAttr], [CellAttr])) -> CustomHandler

-- | Creates a custom handler that only applies at a fixed monomorphic type
--   <tt>a</tt>.
monoCH :: Typeable a => (a -> MCH (Maybe (StrictTree Row))) -> CustomHandler

-- | Creates a pure custom handler that only applies at a fixed monomorphic
--   type <tt>a</tt>.
monoPureCH :: Typeable a => (a -> (Maybe (StrictTree Row))) -> CustomHandler

-- | Creates a pure custom handler that only and always applies at a fixed
--   monomorphic type <tt>a</tt>.
monoPureCH' :: Typeable a => (a -> StrictTree Row) -> CustomHandler

-- | Creates a custom handler that applies at <tt>f a</tt> for a fixed type
--   constructor <tt>f</tt> and for any <tt>a</tt>.
poly1CH :: Typeable1 f => (forall a. Data a => f a -> MCH (Maybe (StrictTree Row))) -> CustomHandler

-- | Creates a custom handler that applies at <tt>f a b</tt> for a fixed
--   binary type constructor <tt>f</tt> and for any <tt>a</tt> and
--   <tt>b</tt>.
poly2CH :: Typeable2 f => (forall a b. (Data a, Data b) => f a b -> MCH (Maybe (StrictTree Row))) -> CustomHandler
data AnyData
AnyData :: a -> AnyData

-- | Makes a <a>CustomHandler</a> for container-like types. The given
--   function should return:
--   
--   <ul>
--   <li>The string for the <a>rowCV</a> cell</li>
--   <li>A list of arbitrary (key,value) pairs to be displayed in the
--   <a>rowCustomInfo</a> cell (this should be things like the size of the
--   collection, not a list of elements)</li>
--   <li>The list of elements</li>
--   </ul>
container0CH :: Typeable a => (a -> (String, [(String, String)], [AnyData])) -> CustomHandler

-- | Like <a>container0CH</a>, but for type constructors
container1CH :: Typeable1 f => (forall a. Data a => f a -> (String, [(String, String)], [AnyData])) -> CustomHandler

-- | Like <a>container1CH</a>, but for binary type constructor
container2CH :: Typeable2 f => (forall a b. (Data a, Data b) => f a b -> (String, [(String, String)], [AnyData])) -> CustomHandler
type CellData = StrictList CellAttr

-- | Data for a row of the tree widget.
data Row
Row :: !CellData -> !CellData -> !CellData -> !CellData -> Row

-- | Constructor name, literal value, or a placeholder like
--   <tt>"{List}"</tt> for custom things
rowCV :: Row -> !CellData

-- | Record field name. You can mostly ignore this, see the remark in
--   <tt>newRow</tt>.
rowFieldName :: Row -> !CellData

-- | Arbitrary information (left empty by the generic handler)
rowCustomInfo :: Row -> !CellData
rowTypeName :: Row -> !CellData

-- | Construct a <a>Row</a> with empty <a>rowFieldName</a>.
--   
--   You usually can't know the field name for a node <tt>x</tt> during a
--   recursive call with <tt>x</tt> at its root - the field name will be
--   added <i>afterwards</i> by the generic handler for the parent node of
--   <tt>x</tt> if that parent node is a constructor with named fields.
newRow :: [CellAttr] -> [CellAttr] -> [CellAttr] -> Row

-- | Adds the given attribute to each cell of the given row.
addToAll :: Row -> [CellAttr] -> Row
addFieldName :: String -> Row -> Row

-- | Cell attributes
data CellAttr
type ColorName = String

-- | The cell's text. If this attribute occurs multiple times for a single
--   cell, the occurences are concatenated.
txt :: String -> CellAttr

-- | Background color, by name
bgcolor :: ColorName -> CellAttr

-- | Background color, red/green/blue
bgcolor' :: Word16 -> Word16 -> Word16 -> CellAttr

-- | Foreground color, by name
fgcolor :: ColorName -> CellAttr

-- | Foreground color, red/green/blue
fgcolor' :: Word16 -> Word16 -> Word16 -> CellAttr

-- | Font scaling factor
scale :: Double -> CellAttr
dataToTree :: Data d => CustomHandler -> d -> IO (StrictTree Row)
