-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Hydrogen Tools
--   
--   Hydrogen Tools
@package hydrogen-util
@version 0.8

module Hydrogen.Util.Read
tryRead :: Monad m => ReadS a -> String -> m a
tryReads :: (Monad m, Read a) => String -> m a
firstJust :: [a -> Maybe b] -> a -> Maybe b
ignoreUnderscores :: String -> String
tryReadDecimal :: String -> Maybe Rational
tryReadRational :: String -> Maybe Rational
tryReadHex :: String -> Maybe Rational
tryReadUUID :: String -> Maybe UUID
tryReadVersion :: String -> Maybe Version
tryReadDateTime :: String -> Maybe (Maybe ZonedTime)
tryReadDate :: String -> Maybe (Maybe Day)
tryReadTime :: String -> Maybe (Maybe TimeOfDay)
tryReadBool :: String -> Maybe Bool

module Hydrogen.Util.Parsec
type Parser source result = source -> Either SomethingBad result

-- | The abstract data type <tt>ParseError</tt> represents parse errors. It
--   provides the source position (<a>SourcePos</a>) of the error and a
--   list of error messages (<a>Message</a>). A <tt>ParseError</tt> can be
--   returned by the function <a>parse</a>. <tt>ParseError</tt> is an
--   instance of the <a>Show</a> class.
data ParseError :: *
type SomethingBad = (SourcePos, [String])
type Tokens t = [(SourcePos, t)]
runTokenParser :: Stream a Identity t => ParsecT a () Identity b -> Parser a b
mkError :: ParseError -> Either SomethingBad b
sourceToken :: (Show t, Stream (Tokens t) m (SourcePos, t)) => (t -> Maybe a) -> ParsecT [(SourcePos, t)] u m a
manyBetween :: (Monad m, Stream s m t) => ParsecT s u m open -> ParsecT s u m close -> ParsecT s u m p -> ParsecT s u m [p]
(>+>) :: Parser a b -> Parser b c -> Parser a c
(<+<) :: Parser b c -> Parser a b -> Parser a c

module Hydrogen.Util.Parsec.Char

-- | <tt>oneOf cs</tt> succeeds if the current character is in the supplied
--   list of characters <tt>cs</tt>. Returns the parsed character. See also
--   <a>satisfy</a>.
--   
--   <pre>
--   vowel  = oneOf "aeiou"
--   </pre>
oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char

-- | As the dual of <a>oneOf</a>, <tt>noneOf cs</tt> succeeds if the
--   current character <i>not</i> in the supplied list of characters
--   <tt>cs</tt>. Returns the parsed character.
--   
--   <pre>
--   consonant = noneOf "aeiou"
--   </pre>
noneOf :: Stream s m Char => [Char] -> ParsecT s u m Char

-- | Skips <i>zero</i> or more white space characters. See also
--   <a>skipMany</a>.
spaces :: Stream s m Char => ParsecT s u m ()

-- | Parses a white space character (any character which satisfies
--   <a>isSpace</a>) Returns the parsed character.
space :: Stream s m Char => ParsecT s u m Char

-- | Parses end of line, which maybe ('\n' or '\r' or "rn").
--   
--   Returns the newline character, '\r' in case of "rn".
newline :: (Monad m, Stream s m Char) => ParsecT s u m Char

-- | Parses a tab character ('\t'). Returns a tab character.
tab :: Stream s m Char => ParsecT s u m Char

-- | Parses an upper case letter (a character between 'A' and 'Z'). Returns
--   the parsed character.
upper :: Stream s m Char => ParsecT s u m Char

-- | Parses a lower case character (a character between 'a' and 'z').
--   Returns the parsed character.
lower :: Stream s m Char => ParsecT s u m Char

-- | Parses a letter or digit (a character between '0' and '9'). Returns
--   the parsed character.
alphaNum :: Stream s m Char => ParsecT s u m Char

-- | Parses a letter (an upper case or lower case character). Returns the
--   parsed character.
letter :: Stream s m Char => ParsecT s u m Char

-- | Parses a digit. Returns the parsed character.
digit :: Stream s m Char => ParsecT s u m Char

-- | Parses a hexadecimal digit (a digit or a letter between 'a' and 'f' or
--   'A' and 'F'). Returns the parsed character.
hexDigit :: Stream s m Char => ParsecT s u m Char

-- | <tt>char c</tt> parses a single character <tt>c</tt>. Returns the
--   parsed character (i.e. <tt>c</tt>).
--   
--   <pre>
--   semiColon  = char ';'
--   </pre>
char :: Stream s m Char => Char -> ParsecT s u m Char

-- | This parser succeeds for any character. Returns the parsed character.
anyChar :: Stream s m Char => ParsecT s u m Char

-- | The parser <tt>satisfy f</tt> succeeds for any character for which the
--   supplied function <tt>f</tt> returns <a>True</a>. Returns the
--   character that is actually parsed.
satisfy :: Stream s m Char => (Char -> Bool) -> ParsecT s u m Char

-- | <tt>string s</tt> parses a sequence of characters given by <tt>s</tt>.
--   Returns the parsed string (i.e. <tt>s</tt>).
--   
--   <pre>
--   divOrMod    =   string "div" 
--               &lt;|&gt; string "mod"
--   </pre>
string :: Stream s m Char => String -> ParsecT s u m String

-- | Parses a negative or a positive number (indicated by an unary minus
--   operator, does not accept an unary plus).
number :: (Monad m, Stream s m Char, Read a, Num a, Integral a) => ParsecT s u m a

-- | Parses a positive integral number.
positiveNumber :: (Monad m, Stream s m Char, Read a, Num a, Integral a) => ParsecT s u m a

-- | Parses a negative integral number (indicated by an unary minus
--   operator).
negativeNumber :: (Monad m, Stream s m Char, Read a, Num a, Integral a) => ParsecT s u m a

-- | Parses a decimal number
decimal :: (Monad m, Stream s m Char, Read a, Num a, RealFrac a) => ParsecT s u m a

-- | <pre>
--   [a-z][a-z0-9]*
--   </pre>
name :: (Monad m, Stream s m Char) => ParsecT s u m String

-- | <pre>
--   [a-z_][a-z0-9_]*
--   </pre>
name_ :: (Monad m, Stream s m Char) => ParsecT s u m String

-- | <tt>keyword w</tt> parses the string <tt>w</tt> which must not be
--   followed by any alpha numeric character, i.e. <tt>keyword "as"</tt>
--   parses "as" but not "ass".
keyword :: (Monad m, Stream s m Char) => String -> ParsecT s u m String
keyword_ :: (Monad m, Stream s m Char) => String -> ParsecT s u m ()
between' :: (Monad m, Stream s m Char) => Char -> Char -> ParsecT s u m t -> ParsecT s u m t

module Hydrogen.Util.Files
findFilesRecursively :: (FilePath -> IO Bool) -> FilePath -> IO [FilePath]
findFilesRecursivelyWithContext :: (c -> FilePath -> [FilePath] -> IO c) -> (FilePath -> IO Bool) -> c -> FilePath -> IO [(FilePath, c)]
escape :: String -> String
unescape :: String -> Maybe String

module Hydrogen.Util.CliArgs
data Option
switch :: String -> Option
optarg :: String -> Option
(~:) :: Char -> Option -> Option
getOpts :: [Option] -> IO (Map String String, Set String, [String])
getOpts' :: [Option] -> [String] -> (Map String String, Set String, [String])
instance Typeable Option
instance Eq Option
instance Show Option
instance Generic Option
instance Datatype D1Option
instance Constructor C1_0Option
instance Constructor C1_1Option
instance Constructor C1_2Option

module Hydrogen.Util

-- | Infix to postfix notation (an implementation of the
--   Shunting-Yard-Algorithm)
sya :: (Ord p, Eq o) => (a -> Maybe o) -> (o -> Bool) -> (o -> p) -> [a] -> [a]
