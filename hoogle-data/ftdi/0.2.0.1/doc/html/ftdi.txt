-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A thin layer over USB to communicate with FTDI chips
--   
--   This library enables you to communicate with FTDI devices. It is
--   implemented as a lightweight wrapper around the usb library.
@package ftdi
@version 0.2.0.1

module System.FTDI

-- | A representation of an FTDI device.
data Device

-- | The type of FTDI chip in a <a>Device</a>. The capabilities of a device
--   depend on its chip type.
data ChipType
ChipType_AM :: ChipType
ChipType_BM :: ChipType
ChipType_2232C :: ChipType
ChipType_R :: ChipType
ChipType_2232H :: ChipType
ChipType_4232H :: ChipType
getChipType :: Device -> ChipType
setChipType :: Device -> ChipType -> Device

-- | Promote a USB device to an FTDI device. You are responsible for
--   supplying the correct USB device and specifying the correct chip type.
--   There is no failsafe way to automatically determine whether a random
--   USB device is an actual FTDI device.
fromUSBDevice :: Device -> ChipType -> Device

-- | Tries to guess the type of the FTDI chip by looking at the USB device
--   release number of a device's descriptor. Each FTDI chip uses a
--   specific release number to indicate its type.
guessChipType :: DeviceDesc -> Maybe ChipType

-- | A device interface. You can imagine an interface as a port or a
--   communication channel. Some devices support communication over
--   multiple interfaces at the same time.
data Interface
Interface_A :: Interface
Interface_B :: Interface
Interface_C :: Interface
Interface_D :: Interface

-- | You need a handle in order to communicate with a <a>Device</a>.
data DeviceHandle

-- | Perform a USB device reset.
resetUSB :: DeviceHandle -> IO ()

-- | Returns the USB timeout associated with a handle.
getTimeout :: DeviceHandle -> Int

-- | Modifies the USB timeout associated with a handle.
setTimeout :: DeviceHandle -> Int -> DeviceHandle

-- | Open a device handle to enable communication. Only use this if you
--   can't use <a>withDeviceHandle</a> for some reason.
openDevice :: Device -> IO DeviceHandle

-- | Release a device handle.
closeDevice :: DeviceHandle -> IO ()

-- | The recommended way to acquire a handle. Ensures that the handle is
--   released when the monadic computation is completed. Even, or
--   especially, when an exception is thrown.
withDeviceHandle :: Device -> (DeviceHandle -> IO α) -> IO α
data InterfaceHandle
getDeviceHandle :: InterfaceHandle -> DeviceHandle
getInterface :: InterfaceHandle -> Interface
openInterface :: DeviceHandle -> Interface -> IO InterfaceHandle
closeInterface :: InterfaceHandle -> IO ()
withInterfaceHandle :: DeviceHandle -> Interface -> (InterfaceHandle -> IO α) -> IO α
data ChunkedReaderT m α

-- | Run the ChunkedReaderT given an initial state.
--   
--   The initial state represents excess bytes carried over from a previous
--   run. When invoking runChunkedReaderT for the first time you can safely
--   pass the <a>empty</a> bytestring as the initial state.
--   
--   A contrived example showing how you can manually thread the excess
--   bytes through subsequent invocations of runChunkedReaderT:
--   
--   <pre>
--   example ∷ <a>InterfaceHandle</a> → IO ()
--   example ifHnd = do
--     (packets1, rest1) ← runChunkedReaderT (<a>readData</a> ifHnd (return <a>False</a>) 400) <a>empty</a>
--     print $ <tt>BS.concat</tt> packets1
--     (packets2, rest2) ← runChunkedReaderT (<a>readData</a> ifHnd (return <a>False</a>) 200) rest1
--     print $ <tt>BS.concat</tt> packets2
--   </pre>
--   
--   However, it is much easier to let <a>ChunkedReaderT</a>s monad
--   instance handle the plumbing:
--   
--   <pre>
--   example ∷ <a>InterfaceHandle</a> → IO ()
--   example ifHnd =
--     let reader = do packets1 ← <a>readData</a> ifHnd (return <a>False</a>) 400
--                     liftIO $ print $ <tt>BS.concat</tt> packets1
--                     packets2 ← <a>readData</a> ifHnd (return <a>False</a>) 200
--                     liftIO $ print $ <tt>BS.concat</tt> packets1
--     in runChunkedReaderT reader <a>empty</a>
--   </pre>
runChunkedReaderT :: ChunkedReaderT m α -> ByteString -> m (α, ByteString)

-- | Reads data from the given FTDI interface by performing bulk reads.
--   
--   This function produces an action in the <tt>ChunkedReaderT</tt> monad
--   that will read exactly the requested number of bytes unless it is
--   explicitly asked to stop early. Executing the <tt>readData</tt> action
--   will block until either:
--   
--   <ul>
--   <li>All data are read</li>
--   <li>The given checkStop action returns <a>True</a></li>
--   </ul>
--   
--   The result value is a list of chunks, represented as
--   <tt>ByteString</tt>s. This representation was choosen for efficiency
--   reasons.
--   
--   Data are read in packets. The function may choose to request more than
--   needed in order to get the highest possible bandwidth. The excess of
--   bytes is kept as the state of the <tt>ChunkedReaderT</tt> monad. A
--   subsequent invocation of <tt>readData</tt> will first return bytes
--   from the stored state before requesting more from the device itself. A
--   consequence of this behaviour is that even when you request 100 bytes
--   the function will actually request 512 bytes (depending on the packet
--   size) and <i>block</i> until all 512 bytes are read! There is no
--   workaround since requesting less bytes than the packet size is an
--   error.
--   
--   USB timeouts will not interrupt <tt>readData</tt>. In case of a
--   timeout <tt>readData</tt> will simply resume reading data. A small USB
--   timeout can degrade performance.
--   
--   The FTDI latency timer can cause poor performance. If the FTDI chip
--   can't fill a packet before the latency timer fires it is forced to
--   send an incomplete packet. This will cause a stream of tiny packets
--   instead of a few large packets. Performance will suffer horribly, but
--   the request will still be completed.
--   
--   If you need to make a lot of small requests then a small latency can
--   actually improve performance.
--   
--   Modem status bytes are filtered from the result. Every packet send by
--   the FTDI chip contains 2 modem status bytes. They are not part of the
--   data and do not count for the number of bytes read. They will not
--   appear in the result.
--   
--   Example:
--   
--   <pre>
--   -- Read 100 data bytes from ifHnd
--   (packets, rest) ← <a>runChunkedReaderT</a> (<a>readData</a> ifHnd (return <a>False</a>) 100) <a>empty</a>
--   </pre>
readData :: (MonadIO m) => InterfaceHandle -> m Bool -> Int -> ChunkedReaderT m [ByteString]

-- | Perform a bulk read.
--   
--   Returns the bytes that where read (in the form of a <a>ByteString</a>)
--   and a flag which indicates whether a timeout occured during the
--   request.
readBulk :: InterfaceHandle -> Int -> IO (ByteString, Bool)

-- | Perform a bulk write.
--   
--   Returns the number of bytes that where written and a flag which
--   indicates whether a timeout occured during the request.
writeBulk :: InterfaceHandle -> ByteString -> IO (Int, Bool)

-- | Reset the FTDI device.
reset :: InterfaceHandle -> IO ()

-- | Clear the on-chip read buffer.
purgeReadBuffer :: InterfaceHandle -> IO ()

-- | Clear the on-chip write buffer.
purgeWriteBuffer :: InterfaceHandle -> IO ()

-- | Returns the current value of the FTDI latency timer.
getLatencyTimer :: InterfaceHandle -> IO Word8

-- | Set the FTDI latency timer. The latency is the amount of milliseconds
--   after which the FTDI chip will send a packet regardless of the number
--   of bytes in the packet.
setLatencyTimer :: InterfaceHandle -> Word8 -> IO ()

-- | MPSSE bitbang modes
data BitMode

-- | Switch off bitbang mode, back to regular serial/FIFO.
BitMode_Reset :: BitMode

-- | Classical asynchronous bitbang mode, introduced with B-type chips.
BitMode_BitBang :: BitMode

-- | Multi-Protocol Synchronous Serial Engine, available on 2232x chips.
BitMode_MPSSE :: BitMode

-- | Synchronous Bit-Bang Mode, available on 2232x and R-type chips.
BitMode_SyncBitBang :: BitMode

-- | MCU Host Bus Emulation Mode, available on 2232x chips. CPU-style fifo
--   mode gets set via EEPROM.
BitMode_MCU :: BitMode

-- | Fast Opto-Isolated Serial Interface Mode, available on 2232x chips.
BitMode_Opto :: BitMode

-- | Bit-Bang on CBus pins of R-type chips, configure in EEPROM before use.
BitMode_CBus :: BitMode

-- | Single Channel Synchronous FIFO Mode, available on 2232H chips.
BitMode_SyncFIFO :: BitMode

-- | The bitmode controls the method of communication.
setBitMode :: InterfaceHandle -> Word8 -> BitMode -> IO ()
data Parity

-- | The parity bit is set to one if the number of ones in a given set of
--   bits is even (making the total number of ones, including the parity
--   bit, odd).
Parity_Odd :: Parity

-- | The parity bit is set to one if the number of ones in a given set of
--   bits is odd (making the total number of ones, including the parity
--   bit, even).
Parity_Even :: Parity

-- | The parity bit is always 1.
Parity_Mark :: Parity

-- | The parity bit is always 0.
Parity_Space :: Parity
data BitDataFormat
Bits_7 :: BitDataFormat
Bits_8 :: BitDataFormat
data StopBits
StopBit_1 :: StopBits
StopBit_15 :: StopBits
StopBit_2 :: StopBits

-- | Set RS232 line characteristics
setLineProperty :: InterfaceHandle -> BitDataFormat -> StopBits -> Maybe Parity -> Bool -> IO ()

-- | Representation of a baud rate. The most interesting part is the
--   instance for <a>Bounded</a>.
newtype BaudRate α
BaudRate :: α -> BaudRate α
unBaudRate :: BaudRate α -> α

-- | Calculates the nearest representable baud rate.
nearestBaudRate :: (RealFrac α) => ChipType -> BaudRate α -> BaudRate α

-- | Sets the baud rate. Internally the baud rate is represented as a
--   fraction. The maximum baudrate is the numerator and a special
--   <i>divisor</i> is used as the denominator. The maximum baud rate is
--   given by the <a>BaudRate</a> instance for <a>Bounded</a>. The divisor
--   consists of an integral part and a fractional part. Both parts are
--   limited in range. As a result not all baud rates can be accurately
--   represented. This function returns the nearest representable baud rate
--   relative to the requested baud rate. According to FTDI documentation
--   the maximum allowed error is 3%. The nearest representable baud rate
--   can be calculated with the <a>nearestBaudRate</a> function.
setBaudRate :: (RealFrac α) => InterfaceHandle -> BaudRate α -> IO (BaudRate α)

-- | Modem status information. The modem status is send as a header for
--   each read access. In the absence of data the FTDI chip will generate
--   the status every 40 ms.
--   
--   The modem status can be explicitely requested with the
--   <a>pollModemStatus</a> function.
data ModemStatus
ModemStatus :: Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> Bool -> ModemStatus

-- | Clear to send (CTS)
msClearToSend :: ModemStatus -> Bool

-- | Data set ready (DTS)
msDataSetReady :: ModemStatus -> Bool

-- | Ring indicator (RI)
msRingIndicator :: ModemStatus -> Bool

-- | Receive line signal detect (RLSD)
msReceiveLineSignalDetect :: ModemStatus -> Bool

-- | Data ready (DR)
msDataReady :: ModemStatus -> Bool

-- | Overrun error (OE)
msOverrunError :: ModemStatus -> Bool

-- | Parity error (PE)
msParityError :: ModemStatus -> Bool

-- | Framing error (FE)
msFramingError :: ModemStatus -> Bool

-- | Break interrupt (BI)
msBreakInterrupt :: ModemStatus -> Bool

-- | Transmitter holding register (THRE)
msTransmitterHoldingRegister :: ModemStatus -> Bool

-- | Transmitter empty (TEMT)
msTransmitterEmpty :: ModemStatus -> Bool

-- | Error in RCVR FIFO
msErrorInReceiverFIFO :: ModemStatus -> Bool

-- | Manually request the modem status.
pollModemStatus :: InterfaceHandle -> IO ModemStatus
data FlowCtrl

-- | Request-To-Send / Clear-To-Send
RTS_CTS :: FlowCtrl

-- | Data-Terminal-Ready / Data-Set-Ready
DTR_DSR :: FlowCtrl

-- | Transmitter on / Transmitter off
XOnXOff :: FlowCtrl

-- | Set the flow control for the FTDI chip. Use <a>Nothing</a> to disable
--   flow control.
setFlowControl :: InterfaceHandle -> Maybe FlowCtrl -> IO ()

-- | Set DTR line.
setDTR :: InterfaceHandle -> Bool -> IO ()

-- | Set RTS line.
setRTS :: InterfaceHandle -> Bool -> IO ()

-- | Set the special event character. Use <a>Nothing</a> to disable the
--   event character.
setEventCharacter :: InterfaceHandle -> Maybe Word8 -> IO ()

-- | Set the error character. Use <a>Nothing</a> to disable the error
--   character.
setErrorCharacter :: InterfaceHandle -> Maybe Word8 -> IO ()

-- | Default USB timeout. The timeout can be set per device handle with the
--   <a>setTimeout</a> function.
defaultTimeout :: Int
