-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A high level static library for working with CouchDB
--   
--   EZCouch is a library which takes a mission of bringing the topmost
--   level of abstraction for working with CouchDB from Haskell. It
--   abstracts away from loose concepts of this database and brings a
--   strict static API over standard ADTs.
@package ez-couch
@version 0.7.0


-- | EZCouch is a library which takes a mission of bringing the topmost
--   level of abstraction for working with CouchDB in Haskell. It abstracts
--   away from loose concepts of this database and brings a strict static
--   API over standard ADTs.
module EZCouch
createEntity :: (MonadAction m, Entity a) => a -> m (Persisted a)
createEntities :: (MonadAction m, Entity a) => [a] -> m [Persisted a]
data KeysSelection k
KeysSelectionAll :: KeysSelection k
KeysSelectionRange :: k -> k -> KeysSelection k
KeysSelectionRangeStart :: k -> KeysSelection k
KeysSelectionRangeEnd :: k -> KeysSelection k
KeysSelectionList :: [k] -> KeysSelection k
readEntities :: (MonadAction m, Entity a, ToJSON k) => Int -> Maybe Int -> Bool -> KeysSelection k -> View a k -> m [Persisted a]
readRandomEntities :: (MonadAction m, Entity a) => Maybe Int -> m [Persisted a]
readEntity :: (MonadAction m, Entity a, ToJSON k) => Int -> Bool -> KeysSelection k -> View a k -> m (Maybe (Persisted a))
readKeysExist :: (MonadAction m, Entity a, ToJSON k, FromJSON k) => KeysSelection k -> View a k -> m [(k, Bool)]
readKeys :: (MonadAction m, Entity a, ToJSON k, FromJSON k) => KeysSelection k -> View a k -> m [k]
readCount :: (MonadAction m, Entity a, ToJSON k, FromJSON k) => KeysSelection k -> View a k -> m Int
readKeys' :: (ToJSON k, FromJSON k, Entity a, MonadAction m) => View a k -> m [k]
readCount' :: (ToJSON k, FromJSON k, Entity a, MonadAction m) => View a k -> m Int
readKeysExist' :: (ToJSON k, FromJSON k, Entity a, MonadAction m) => View a k -> m [(k, Bool)]
readEntities' :: (ToJSON k, Entity a, MonadAction m) => Maybe Int -> Bool -> KeysSelection k -> View a k -> m [Persisted a]
readEntities'' :: (ToJSON k, Entity a, MonadAction m) => Bool -> KeysSelection k -> View a k -> m [Persisted a]
readEntities''' :: (ToJSON k, Entity a, MonadAction m) => KeysSelection k -> View a k -> m [Persisted a]
readEntities'''' :: (ToJSON k, Entity a, MonadAction m) => View a k -> m [Persisted a]
readEntities''''' :: (Entity a, MonadAction m) => m [Persisted a]
readEntity' :: (ToJSON k, Entity a, MonadAction m) => Bool -> KeysSelection k -> View a k -> m (Maybe (Persisted a))
readEntity'' :: (ToJSON k, Entity a, MonadAction m) => KeysSelection k -> View a k -> m (Maybe (Persisted a))
readEntity''' :: (ToJSON k, Entity a, MonadAction m) => View a k -> m (Maybe (Persisted a))
readEntity'''' :: (Entity a, MonadAction m) => m (Maybe (Persisted a))
updateEntity :: (MonadAction m, Entity a) => Persisted a -> m (Persisted a)
updateEntities :: (MonadAction m, Entity a) => [Persisted a] -> m [Persisted a]
deleteEntity :: (MonadAction m, Entity a) => Persisted a -> m ()
deleteEntities :: (MonadAction m, Entity a) => [Persisted a] -> m ()

-- | Current time according to server. This function doesn't actually emit
--   any requests to the server, calculating the value from a deviation of
--   local time from server time determined at the beginning of the EZCouch
--   session.
readTime :: MonadAction m => m UTCTime
data View entity keys
ViewById :: View entity Text
ViewByKeys1 :: ViewKey a -> View entity a
ViewByKeys2 :: ViewKey a -> ViewKey b -> View entity (a, b)
ViewByKeys3 :: ViewKey a -> ViewKey b -> ViewKey c -> View entity (a, b, c)
ViewByKeys4 :: ViewKey a -> ViewKey b -> ViewKey c -> ViewKey d -> View entity (a, b, c, d)
ViewByKeys5 :: ViewKey a -> ViewKey b -> ViewKey c -> ViewKey d -> ViewKey e -> View entity (a, b, c, d, e)
ViewByKeys6 :: ViewKey a -> ViewKey b -> ViewKey c -> ViewKey d -> ViewKey e -> ViewKey f -> View entity (a, b, c, d, e, f)
ViewByKeys7 :: ViewKey a -> ViewKey b -> ViewKey c -> ViewKey d -> ViewKey e -> ViewKey f -> ViewKey g -> View entity (a, b, c, d, e, f, g)
data ViewKey a

-- | A path to a field value.
ViewKeyValue :: Path -> ViewKey a

-- | A floating point number in range <tt>0 &lt;= x &lt;= 1</tt> based on
--   the revision hash of the document.
--   
--   This is used to simulate an output <tt>Math.random()</tt> for random
--   fetching, while producing a stable value across all database replicas.
ViewKeyFloatRevHash :: ViewKey a
data Path
PathField :: Text -> Path -> Path
PathItem :: Path -> Path
PathNil :: Path

-- | Protect the entity from being accessed by concurrent clients until you
--   release it using <a>releaseIsolation</a>, delete it with the isolation
--   using <a>deleteIsolation</a>, or the timeout passes and it gets
--   considered to be zombie and gets released automatically some time
--   later.
--   
--   The automatic releasing gets done by a sweeper daemon running in
--   background when EZCouch is being used on a timely basis and on its
--   launch.
isolateEntity :: (MonadAction m, Entity e) => Int -> Persisted e -> m (Maybe (Isolation e))

-- | Does the same as <a>isolateEntity</a> but for multiple entities and in
--   a single request.
isolateEntities :: (MonadAction m, Entity e) => Int -> [Persisted e] -> m ([Maybe (Isolation e)])

-- | Restore the entity document under the same id and drop the isolation.
releaseIsolation :: (MonadAction m, Entity e) => Isolation e -> m (Persisted e)
releaseIsolations :: (MonadAction m, Entity e) => [Isolation e] -> m [Persisted e]

-- | Get rid of both the isolation and the entity. The entity won't get
--   restored by the sweeper daemon after.
deleteIsolation :: (MonadAction m, Entity e) => Isolation e -> m ()
deleteIsolations :: (MonadAction m, Entity e) => [Isolation e] -> m ()
data Isolation e
isolationEntity :: Isolation t1 -> t1

-- | A wrapper for entity values which preserves the information required
--   for identifying the appropriate documents in the db.
data Persisted a
Persisted :: Text -> Text -> a -> Persisted a
persistedId :: Persisted a -> Text
persistedRev :: Persisted a -> Text
persistedValue :: Persisted a -> a
persistedIdHashPart :: Entity a => Persisted a -> Text

-- | Return <a>Nothing</a> if an action throws an <a>OperationException</a>
--   or <a>Just</a> its result otherwise.
--   
--   This is only useful for writing actions (Create, Update, Delete).
tryOperation :: MonadAction m => m a -> m (Maybe a)

-- | All EZCouch operations are performed in this monad.
class (MonadBaseControl IO m, MonadResource m, MonadReader Environment m) => MonadAction m
type Environment = (ConnectionSettings, Manager, NominalDiffTime)
run :: (MonadIO m, MonadBaseControl IO m, MonadThrow m, MonadUnsafeIO m) => ConnectionSettings -> ReaderT (ConnectionSettings, Manager, NominalDiffTime) (ResourceT m) a -> m a
runWithManager :: (MonadBaseControl IO m, MonadResource m) => Manager -> ConnectionSettings -> ReaderT (ConnectionSettings, Manager, NominalDiffTime) m a -> m a
data ConnectionSettings
ConnectionSettings :: Text -> Maybe Int -> Maybe (Text, Text) -> Text -> ConnectionSettings
connectionSettingsHost :: ConnectionSettings -> Text
connectionSettingsPort :: ConnectionSettings -> Maybe Int
connectionSettingsAuth :: ConnectionSettings -> Maybe (Text, Text)
connectionSettingsDatabase :: ConnectionSettings -> Text
data EZCouchException

-- | A response from CouchDB could not be parsed.
ParsingException :: Text -> EZCouchException

-- | An operation failed, e.g. a document couldn't be created or deleted.
OperationException :: Text -> EZCouchException

-- | E.g., server provided an unexpected response
ResponseException :: Text -> EZCouchException

-- | Either a connection got closed or a timeout passed
ConnectionException :: Text -> EZCouchException

-- | A weird status 500 response
ServerException :: Text -> EZCouchException
class (ToJSON a, FromJSON a) => Entity a where entityType = gEntityType . from
entityType :: Entity a => a -> Text

-- | A type that can be converted to JSON.
--   
--   An example type and instance:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord { x :: Double, y :: Double }
--   
--   instance ToJSON Coord where
--      toJSON (Coord x y) = <a>object</a> ["x" <a>.=</a> x, "y" <a>.=</a> y]
--   </pre>
--   
--   Note the use of the <tt>OverloadedStrings</tt> language extension
--   which enables <a>Text</a> values to be written as string literals.
--   
--   Instead of manually writing your <a>ToJSON</a> instance, there are
--   three options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides template-haskell functions which
--   will derive an instance at compile-time. The generated instance is
--   optimized for your type so will probably be more efficient than the
--   following two options:</li>
--   <li><a>Data.Aeson.Generic</a> provides a generic <tt>toJSON</tt>
--   function that accepts any type which is an instance of
--   <tt>Data</tt>.</li>
--   <li>If your compiler has support for the <tt>DeriveGeneric</tt> and
--   <tt>DefaultSignatures</tt> language extensions (GHC 7.2 and newer),
--   <tt>toJSON</tt> will have a default generic implementation.</li>
--   </ul>
--   
--   To use the latter option, simply add a <tt>deriving
--   <a>Generic</a></tt> clause to your datatype and declare a
--   <tt>ToJSON</tt> instance for your datatype without giving a definition
--   for <tt>toJSON</tt>.
--   
--   For example the previous example can be simplified to just:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics
--   
--   data Coord { x :: Double, y :: Double } deriving Generic
--   
--   instance ToJSON Coord
--   </pre>
--   
--   Note that, instead of using <tt>DefaultSignatures</tt>, it's also
--   possible to parameterize the generic encoding using
--   <a>genericToJSON</a> applied to your encoding/decoding <a>Options</a>:
--   
--   <pre>
--   instance ToJSON Coord where
--       toJSON = <a>genericToJSON</a> <a>defaultOptions</a>
--   </pre>
class ToJSON a
toJSON :: ToJSON a => a -> Value

-- | A type that can be converted from JSON, with the possibility of
--   failure.
--   
--   When writing an instance, use <a>empty</a>, <tt>mzero</tt>, or
--   <a>fail</a> to make a conversion fail, e.g. if an <a>Object</a> is
--   missing a required key, or the value is of the wrong type.
--   
--   An example type and instance:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord { x :: Double, y :: Double }
--   
--   instance FromJSON Coord where
--      parseJSON (<a>Object</a> v) = Coord    <a>&lt;$&gt;</a>
--                             v <a>.:</a> "x" <a>&lt;*&gt;</a>
--                             v <a>.:</a> "y"
--   
--   -- A non-<a>Object</a> value is of the wrong type, so use <tt>mzero</tt> to fail.
--      parseJSON _          = <tt>mzero</tt>
--   </pre>
--   
--   Note the use of the <tt>OverloadedStrings</tt> language extension
--   which enables <a>Text</a> values to be written as string literals.
--   
--   Instead of manually writing your <a>FromJSON</a> instance, there are
--   three options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides template-haskell functions which
--   will derive an instance at compile-time. The generated instance is
--   optimized for your type so will probably be more efficient than the
--   following two options:</li>
--   <li><a>Data.Aeson.Generic</a> provides a generic <tt>fromJSON</tt>
--   function that parses to any type which is an instance of
--   <tt>Data</tt>.</li>
--   <li>If your compiler has support for the <tt>DeriveGeneric</tt> and
--   <tt>DefaultSignatures</tt> language extensions, <tt>parseJSON</tt>
--   will have a default generic implementation.</li>
--   </ul>
--   
--   To use this, simply add a <tt>deriving <a>Generic</a></tt> clause to
--   your datatype and declare a <tt>FromJSON</tt> instance for your
--   datatype without giving a definition for <tt>parseJSON</tt>.
--   
--   For example the previous example can be simplified to just:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics
--   
--   data Coord { x :: Double, y :: Double } deriving Generic
--   
--   instance FromJSON Coord
--   </pre>
--   
--   Note that, instead of using <tt>DefaultSignatures</tt>, it's also
--   possible to parameterize the generic decoding using
--   <a>genericParseJSON</a> applied to your encoding/decoding
--   <a>Options</a>:
--   
--   <pre>
--   instance FromJSON Coord where
--       parseJSON = <a>genericParseJSON</a> <a>defaultOptions</a>
--   </pre>
class FromJSON a
parseJSON :: FromJSON a => Value -> Parser a
