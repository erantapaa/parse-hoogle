-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | PCD file loader.
--   
--   Parser for PCD (point cloud data) formats. See
--   <a>http://pointclouds.org/documentation/tutorials/pcd_file_format.php</a>
--   for more information.
@package pcd-loader
@version 0.3.0.1


-- | Common types for dealing with PCD files.
module PCD.Internal.Types

-- | A 2-dimensional vector
--   
--   <pre>
--   &gt;&gt;&gt; pure 1 :: V2 Int
--   V2 1 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V2 1 2 + V2 3 4
--   V2 4 6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; V2 1 2 * V2 3 4
--   V2 3 8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sum (V2 1 2)
--   3
--   </pre>
data V2 a :: * -> *
V2 :: a -> a -> V2 a

-- | A 3-dimensional vector
data V3 a :: * -> *
V3 :: a -> a -> a -> V3 a

-- | A 4-dimensional vector.
data V4 a :: * -> *
V4 :: a -> a -> a -> a -> V4 a

-- | A 4x4 matrix with row-major representation
type M44 a = V4 (V4 a)

-- | Quaternions
data Quaternion a :: * -> *
Quaternion :: a -> {-# UNPACK #-} !(V3 a) -> Quaternion a

-- | <a>Storable</a>-based vectors
data Vector a :: * -> *

-- | 8-bit unsigned integer type
data Word8 :: *


-- | Define a data structure for a PCD file header and an associated
--   parser.
module PCD.Header

-- | Fields attached to a point may be signed integers (I), unsigned
--   integers (U), or floating point (F).
data DimType
I :: DimType
U :: DimType
F :: DimType

-- | The PCD format has both ASCII and binary variants.
data DataFormat
ASCII :: DataFormat
Binary :: DataFormat
data FieldType
TUchar :: {-# UNPACK #-} !Word8 -> FieldType
TChar :: {-# UNPACK #-} !Int8 -> FieldType
TUshort :: {-# UNPACK #-} !Word16 -> FieldType
TShort :: {-# UNPACK #-} !Int16 -> FieldType
TUint :: {-# UNPACK #-} !Word32 -> FieldType
TInt :: {-# UNPACK #-} !Int32 -> FieldType
TFloat :: {-# UNPACK #-} !Float -> FieldType
TDouble :: {-# UNPACK #-} !Double -> FieldType
class PCDType a
unsafeUnwrap :: PCDType a => FieldType -> a
fromHaskell :: PCDType a => a -> (DimType, Int)

-- | Construct a parser for a field based on its type and size.
fieldParser :: DimType -> Int -> Parser FieldType
sequence' :: Monad m => [m a] -> m [a]
data Header
Header :: Text -> [Text] -> [Int] -> [DimType] -> [Int] -> Integer -> Int -> (V3 Double, Quaternion Double) -> Integer -> DataFormat -> Header
_version :: Header -> Text
_fields :: Header -> [Text]
_sizes :: Header -> [Int]
_dimTypes :: Header -> [DimType]
_counts :: Header -> [Int]
_width :: Header -> Integer
_height :: Header -> Int
_viewpoint :: Header -> (V3 Double, Quaternion Double)
_points :: Header -> Integer
_format :: Header -> DataFormat
width :: Lens' Header Integer
viewpoint :: Lens' Header (V3 Double, Quaternion Double)
version :: Lens' Header Text
sizes :: Lens' Header [Int]
points :: Lens' Header Integer
height :: Lens' Header Int
format :: Lens' Header DataFormat
fields :: Lens' Header [Text]
dimTypes :: Lens' Header [DimType]
counts :: Lens' Header [Int]

-- | The default PCD version of 0.7.
defaultVersion :: Text

-- | Make a PCD header for a monotyped vector point type.
--   <tt>mkSimpleHeader fields (type,sz) n</tt> prepares a <a>Header</a>
--   for <tt>n</tt> points with field names <tt>fields</tt>, field type
--   given by <tt>type</tt>, and field size given by <tt>sz</tt>. Example
--   to save 1000 3D points using a single-precision floating point number
--   (4 bytes) for each field:
--   
--   <pre>
--   mkSimpleHeader ["x","y","z"] (F,4) 1000
--   </pre>
mkSimpleHeader :: [Text] -> (DimType, Int) -> Int -> Header

-- | <tt>mkHeaderXYZ sample n</tt> builds a <a>Header</a> for <tt>n</tt>
--   points with fields "x", "y", and "z" of <a>DimType</a> and size (in
--   bytes) derived from the <a>PCDType</a> instance of <tt>sample</tt>.
--   Example:
--   
--   <pre>
--   mkHeaderXYZ (undefined::Float) 1000
--   </pre>
mkHeaderXYZ :: PCDType a => a -> Int -> Header

-- | Assemble a parser for points by sequencing together all necessary
--   field parsers.
pointParser :: Header -> Parser [FieldType]

-- | Create a <a>Header</a> based on an existing one that keeps only the
--   fields whose names pass the supplied predicate.
filterFields :: (Text -> Bool) -> Header -> Header
defaultHeader :: Header
readVersion :: Parser Text
readFields :: Parser [Text]
readTypes :: Parser [DimType]
namedIntegral :: Integral a => Text -> Parser a
namedIntegrals :: Integral a => Text -> Parser [a]
readViewpoint :: Parser (V3 Double, Quaternion Double)
readFormat :: Parser DataFormat

-- | Get the next non-comment line.
nextLine :: Handle -> IO Text

-- | Parse a PCD header. Returns the <a>Header</a> and the rest of the file
--   contents.
readHeader :: Handle -> IO (Header, Maybe Text)

-- | Format a <a>Header</a> to be compatible with the PCD specification.
writeHeader :: Header -> Text

-- | Compute the number of bytes this point cloud would occupy if
--   serialized with the <a>Binary</a> encoding.
totalBinarySize :: Header -> Int
instance NFData Header
instance Eq DimType
instance Show DimType
instance Ord DimType
instance Eq DataFormat
instance Show DataFormat
instance Ord DataFormat
instance Show FieldType
instance Show Header
instance PCDType Double
instance PCDType Float
instance PCDType Int32
instance PCDType Word32
instance PCDType Int16
instance PCDType Word16
instance PCDType Int8
instance PCDType Word8

module PCD.Internal.AsciiParsers

-- | Read point data using a user-supplied ASCII point parser.
readPoints :: Vector v a => Header -> Handle -> Parser a -> IO (v a)

-- | Load points of arbitrary dimension into a boxed vector with a
--   <a>Vector</a> of <a>FieldType</a> as the point representation.
readPointsDefault :: Header -> Handle -> IO (Vector (Vector FieldType))

-- | Parse 3D points serialized in ASCII.
readXYZ :: Fractional a => Parser (V3 a)

-- | Parse 4D points serialized to ASCII. This is useful for points with
--   X,Y,Z, and RGB fields each represented by a single float.
readXYZW :: Fractional a => Parser (V4 a)

module PCD.Internal.StorableFieldType
parseBinaryPoints :: Header -> Handle -> IO (Vector (Vector FieldType))
pokeBinaryPoints :: Ptr a -> Vector (Vector FieldType) -> IO ()


-- | Facility to convert an ASCII PCD file to a Binary one.
module PCD.Conversion

-- | <tt>asciiToBinary inputFile outputFile</tt> converts a PCD file from
--   ASCII to Binary.
asciiToBinary :: FilePath -> FilePath -> IO ()


-- | Parser for PCD (point cloud data) files.
module PCD.Data
data FieldType
TUchar :: {-# UNPACK #-} !Word8 -> FieldType
TChar :: {-# UNPACK #-} !Int8 -> FieldType
TUshort :: {-# UNPACK #-} !Word16 -> FieldType
TShort :: {-# UNPACK #-} !Int16 -> FieldType
TUint :: {-# UNPACK #-} !Word32 -> FieldType
TInt :: {-# UNPACK #-} !Int32 -> FieldType
TFloat :: {-# UNPACK #-} !Float -> FieldType
TDouble :: {-# UNPACK #-} !Double -> FieldType

-- | Extract a raw Haskell value from the <a>FieldType</a> variant. If you
--   know what you've got, this frees from having to pattern match on the
--   <a>FieldType</a> constructor. If you're wrong, you'll get an
--   exception.
unsafeUnwrap :: PCDType a => FieldType -> a

-- | Parse every field of every point in a PCD file. Returns a function
--   that may be used to project out a named field.
loadFieldsByName :: FilePath -> IO (Text -> Vector FieldType)

-- | Load a <a>Vector</a> of points, each represented as a <a>Vector</a> of
--   <a>FieldType</a> fields. If you wish to use field names to access to
--   the data, consider using <a>loadFieldsByName</a>.
loadFlexiblePoints :: Header -> Handle -> IO (Vector (Vector FieldType))

-- | Read a PCD file consisting of floating point XYZW coordinates for each
--   point (where the final "W" field may be an RGB triple encoded as a
--   float).
loadXyzw :: (Fractional a, Storable a) => FilePath -> IO (Vector (V4 a))

-- | Read a PCD file consisting of floating point XYZ coordinates for each
--   point.
loadXyz :: (Fractional a, Storable a) => FilePath -> IO (Vector (V3 a))

-- | Use an existing PCD header to save binary point data to a file. The
--   supplied header is used as-is, except that its format is set to
--   <a>Binary</a>.
saveBinaryPcd :: Storable a => FilePath -> Header -> Vector a -> IO ()

-- | Save a binary PCD file including only the named fields. This is useful
--   when you have a PCD file that has more fields for each point than you
--   care about. For instance, you may wish to extract just the "x", "y",
--   and "z" fields for each point. This can be accomplished using,
--   <tt>projectBinaryFields ["x", "y", "z"] inputFile outputFile</tt>.
projectBinaryFields :: [Text] -> FilePath -> FilePath -> IO ()

-- | Make a PCD header for a monotyped vector point type.
--   <tt>mkSimpleHeader fields (type,sz) n</tt> prepares a <a>Header</a>
--   for <tt>n</tt> points with field names <tt>fields</tt>, field type
--   given by <tt>type</tt>, and field size given by <tt>sz</tt>. Example
--   to save 1000 3D points using a single-precision floating point number
--   (4 bytes) for each field:
--   
--   <pre>
--   mkSimpleHeader ["x","y","z"] (F,4) 1000
--   </pre>
mkSimpleHeader :: [Text] -> (DimType, Int) -> Int -> Header

-- | <tt>mkHeaderXYZ sample n</tt> builds a <a>Header</a> for <tt>n</tt>
--   points with fields "x", "y", and "z" of <a>DimType</a> and size (in
--   bytes) derived from the <a>PCDType</a> instance of <tt>sample</tt>.
--   Example:
--   
--   <pre>
--   mkHeaderXYZ (undefined::Float) 1000
--   </pre>
mkHeaderXYZ :: PCDType a => a -> Int -> Header
