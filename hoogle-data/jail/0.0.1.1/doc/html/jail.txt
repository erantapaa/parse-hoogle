-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Jailed IO monad.
--   
--   Like all of us know, the IO monad from the System.IO module is a wild
--   beast allowing all forms of insecure computations that can read, or
--   even worse, alter <i>the real world</i>. Writing to sockets, deleting
--   files or even launching missiles, its possibilities are endless. This
--   library provides a special IO module that wraps all file and handle
--   based IO operations from the System.IO module, but provides a
--   possibility to run them in an restricted environment. When running a
--   jailed IO computation a file path can be specified all IO operations
--   will be checked against. Accessing files outside this directory is not
--   allowed and results in a runtime error. Additionally, when running a
--   jailed IO computation a whitelist of file handles can be specified
--   that are accessible as well.
--   
--   For example, running some code with the permission to access all files
--   within (and only within) my home directory and allowing to access the
--   standard output and standard error can be enforced like this:
--   
--   <pre>
--   Jail.run (Just "/home/sebas") [stdout, stderr] yourUntrustworthyComputation
--   </pre>
--   
--   Only allowing the code to access the standard input and nothing else
--   can be enforced like this:
--   
--   <pre>
--   Jail.run Nothing [stdin] yourEvenMoreUntrustworthyComputation
--   </pre>
--   
--   Because the jailed IO environment keeps track of all file handles and
--   checks that are opened by its own operations, smuggling in evil file
--   handles from the fierce and dangerous outside world will be punished
--   by border patrol. Only handles from the whitelist or handles securely
--   opened by functions like <a>openFile</a> will be accepted. Because of
--   the opaque IO constructor and the restricted set of exported
--   operations this module is not easily fooled.
--   
--   I would almost dare to say this module is conceptually safe and code
--   with the jailed IO type can blindly be trusted. Except, yes
--   unfortunately except, <tt>unsafePerformIO</tt> ruins it all. I would
--   almost suggest adding a flag to the compiler to enforce the absence of
--   <tt>unsafeRuinMyTypeSafety</tt>-alike functions in order to be able to
--   create systems in which code can be trusted by its type alone.
--   
--   Nonetheless, this module is one step forward in trusting your own
--   programs. Some real <a>http://tinyurl.com/paranoidpeople</a> prefer
--   writing their software in one of the most insecure programming
--   languages and perform security audits by hand, I'd rather have my
--   compiler do the job. (Anyone who wants to audit this library is more
--   than welcome!)
@package jail
@version 0.0.1.1

module System.IO.Jail

-- | The jailed IO monad.
data IO a

-- | Run a jailed IO computation. The IO computation will be able to access
--   all files that are within the specified jail directory. All file
--   accesses outside the jail directory will be refused. Only file handles
--   opened from within the jailed computation and the handles from the
--   white list will be accessible to the operations requiring a file
--   handle. No smuggling in of foreign handles, border patrol is very
--   strict. When the jail path is specified as <a>Nothing</a> no file
--   access will be possible at all, this means the computation can only
--   rely on the white listed handles.
run :: Maybe FilePath -> [Handle] -> IO a -> IO a

-- | Like <a>MonadIO</a>, but for jailed computations.
class (Monad m) => JailIO m
jailIO :: (JailIO m) => IO a -> m a

-- | File and directory names are values of type <a>String</a>, whose
--   precise meaning is operating system dependent. Files can be opened,
--   yielding a handle which can then be used to operate on the contents of
--   that file.
type FilePath = String

-- | Haskell defines operations to read and write characters from and to
--   files, represented by values of type <tt>Handle</tt>. Each value of
--   this type is a <i>handle</i>: a record used by the Haskell run-time
--   system to <i>manage</i> I/O with file system objects. A handle has at
--   least the following properties:
--   
--   <ul>
--   <li>whether it manages input or output or both;</li>
--   <li>whether it is <i>open</i>, <i>closed</i> or
--   <i>semi-closed</i>;</li>
--   <li>whether the object is seekable;</li>
--   <li>whether buffering is disabled, or enabled on a line or block
--   basis;</li>
--   <li>a buffer (whose length may be zero).</li>
--   </ul>
--   
--   Most handles will also have a current I/O position indicating where
--   the next input or output operation will occur. A handle is
--   <i>readable</i> if it manages only input or both input and output;
--   likewise, it is <i>writable</i> if it manages only output or both
--   input and output. A handle is <i>open</i> when first allocated. Once
--   it is closed it can no longer be used for either input or output,
--   though an implementation cannot re-use its storage while references
--   remain to it. Handles are in the <a>Show</a> and <a>Eq</a> classes.
--   The string produced by showing a handle is system dependent; it should
--   include enough information to identify the handle for debugging. A
--   handle is equal according to <a>==</a> only to itself; no attempt is
--   made to compare the internal state of different handles for equality.
--   
--   GHC note: a <a>Handle</a> will be automatically closed when the
--   garbage collector detects that it has become unreferenced by the
--   program. However, relying on this behaviour is not generally
--   recommended: the garbage collector is unpredictable. If possible, use
--   explicit an explicit hClose to close <a>Handle</a>s when they are no
--   longer required. GHC does not currently attempt to free up file
--   descriptors when they have run out, it is your responsibility to
--   ensure that this doesn't happen.
data Handle :: *

-- | A handle managing input from the Haskell program's standard input
--   channel.
stdin :: Handle

-- | A handle managing output to the Haskell program's standard output
--   channel.
stdout :: Handle

-- | A handle managing output to the Haskell program's standard error
--   channel.
stderr :: Handle
withFile :: FilePath -> IOMode -> (Handle -> IO a) -> IO a
openFile :: FilePath -> IOMode -> IO Handle
data IOMode :: *
ReadMode :: IOMode
WriteMode :: IOMode
AppendMode :: IOMode
ReadWriteMode :: IOMode
hClose :: Handle -> IO ()
readFile :: FilePath -> IO String
writeFile :: FilePath -> String -> IO ()
appendFile :: FilePath -> String -> IO ()
hFileSize :: Handle -> IO Integer
hSetFileSize :: Handle -> Integer -> IO ()
hIsEOF :: Handle -> IO Bool
isEOF :: IO Bool

-- | Three kinds of buffering are supported: line-buffering,
--   block-buffering or no-buffering. These modes have the following
--   effects. For output, items are written out, or <i>flushed</i>, from
--   the internal buffer according to the buffer mode:
--   
--   <ul>
--   <li><i>line-buffering</i>: the entire output buffer is flushed
--   whenever a newline is output, the buffer overflows, a System.IO.hFlush
--   is issued, or the handle is closed.</li>
--   <li><i>block-buffering</i>: the entire buffer is written out whenever
--   it overflows, a System.IO.hFlush is issued, or the handle is
--   closed.</li>
--   <li><i>no-buffering</i>: output is written immediately, and never
--   stored in the buffer.</li>
--   </ul>
--   
--   An implementation is free to flush the buffer more frequently, but not
--   less frequently, than specified above. The output buffer is emptied as
--   soon as it has been written out.
--   
--   Similarly, input occurs according to the buffer mode for the handle:
--   
--   <ul>
--   <li><i>line-buffering</i>: when the buffer for the handle is not
--   empty, the next item is obtained from the buffer; otherwise, when the
--   buffer is empty, characters up to and including the next newline
--   character are read into the buffer. No characters are available until
--   the newline character is available or the buffer is full.</li>
--   <li><i>block-buffering</i>: when the buffer for the handle becomes
--   empty, the next block of data is read into the buffer.</li>
--   <li><i>no-buffering</i>: the next input item is read and returned. The
--   System.IO.hLookAhead operation implies that even a no-buffered handle
--   may require a one-character buffer.</li>
--   </ul>
--   
--   The default buffering mode when a handle is opened is
--   implementation-dependent and may depend on the file system object
--   which is attached to that handle. For most implementations, physical
--   files will normally be block-buffered and terminals will normally be
--   line-buffered.
data BufferMode :: *

-- | buffering is disabled if possible.
NoBuffering :: BufferMode

-- | line-buffering should be enabled if possible.
LineBuffering :: BufferMode

-- | block-buffering should be enabled if possible. The size of the buffer
--   is <tt>n</tt> items if the argument is <a>Just</a> <tt>n</tt> and is
--   otherwise implementation-dependent.
BlockBuffering :: Maybe Int -> BufferMode
hSetBuffering :: Handle -> BufferMode -> IO ()
hGetBuffering :: Handle -> IO BufferMode
hFlush :: Handle -> IO ()
hGetPosn :: Handle -> IO HandlePosn
hSetPosn :: HandlePosn -> IO ()
data HandlePosn :: *
hSeek :: Handle -> SeekMode -> Integer -> IO ()

-- | A mode that determines the effect of hSeek <tt>hdl mode i</tt>, as
--   follows:
data SeekMode :: *

-- | the position of <tt>hdl</tt> is set to <tt>i</tt>.
AbsoluteSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the
--   current position.
RelativeSeek :: SeekMode

-- | the position of <tt>hdl</tt> is set to offset <tt>i</tt> from the end
--   of the file.
SeekFromEnd :: SeekMode
hTell :: Handle -> IO Integer
hIsOpen :: Handle -> IO Bool
hIsClosed :: Handle -> IO Bool
hIsReadable :: Handle -> IO Bool
hIsWritable :: Handle -> IO Bool
hIsSeekable :: Handle -> IO Bool
hIsTerminalDevice :: Handle -> IO Bool
hSetEcho :: Handle -> Bool -> IO ()
hGetEcho :: Handle -> IO Bool
hShow :: Handle -> IO String
hWaitForInput :: Handle -> Int -> IO Bool
hReady :: Handle -> IO Bool
hGetChar :: Handle -> IO Char
hGetLine :: Handle -> IO String
hLookAhead :: Handle -> IO Char
hGetContents :: Handle -> IO String
hPutChar :: Handle -> Char -> IO ()
hPutStr :: Handle -> String -> IO ()
hPutStrLn :: Handle -> String -> IO ()
hPrint :: (Show a) => Handle -> a -> IO ()
interact :: (String -> String) -> IO ()
putChar :: Char -> IO ()
putStr :: String -> IO ()
putStrLn :: String -> IO ()
print :: (Show a) => a -> IO ()
getChar :: IO Char
getLine :: IO String
getContents :: IO String
readIO :: (Read a) => String -> IO a
readLn :: (Read a) => IO a
withBinaryFile :: FilePath -> IOMode -> (Handle -> IO a) -> IO a
openBinaryFile :: FilePath -> IOMode -> IO Handle
hSetBinaryMode :: Handle -> Bool -> IO ()
hPutBuf :: Handle -> Ptr a -> Int -> IO ()
hGetBuf :: Handle -> Ptr a -> Int -> IO Int
hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
openTempFile :: FilePath -> String -> IO (FilePath, Handle)
openBinaryTempFile :: FilePath -> String -> IO (FilePath, Handle)
instance Typeable1 IO
instance Functor IO
instance Applicative IO
instance Monad IO
instance MonadFix IO
instance (Monoid r, JailIO m) => JailIO (WriterT r m)
instance (JailIO m) => JailIO (StateT r m)
instance (JailIO m) => JailIO (ReaderT r m)
instance (Monoid w, JailIO m) => JailIO (RWST r w s m)
instance (JailIO m) => JailIO (ListT m)
instance (JailIO m) => JailIO (IdentityT m)
instance (Error e, JailIO m) => JailIO (ErrorT e m)
instance (JailIO m) => JailIO (ContT r m)
instance JailIO IO
instance Ord HandleS
instance Eq HandleS
