-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Monadic graph rewriting of hypergraphs with ports and multiedges
--   
--   This library provides a monadic EDSL to define your own port graph
--   rewrite system in Haskell. Once you have specified the signature of
--   your nodes and a set of rewrite rules, you can apply these rules on a
--   graph to effect a graph transformation. The aim of this library is to
--   make it as convenient as possible to define such a system and
--   experiment with it and is not intended as a backend for
--   high-performance computation.
@package graph-rewriting
@version 0.7.6

module GraphRewriting.Graph.Types

-- | Hypergraph that holds nodes of type <tt>n</tt>. Nodes can be
--   referenced by type <a>Node</a>, edges by type <a>Edge</a>, see
--   <a>GraphRewriting.Graph.Read</a> and <a>GraphRewriting.Graph.Write</a>
data Graph n
data Rewrite n a
data Node
data Port
type Edge = Port


-- | Most of the functions for graph scrutinisation (<a>Read</a>) and
--   modification (<a>Write</a>) are defined monadically. This module
--   defines functions for extracting these monadic values and a few
--   non-monadic graph scrutinisation/modification functions.
module GraphRewriting.Graph
emptyGraph :: Graph n
nodes :: Graph n -> [n]

-- | Each edge corresponds to the set of nodes it connects
edges :: Graph n -> [(Edge, [n])]

-- | unsafe, since no checks are performed to ensure that the invariants
--   from <a>GraphRewriting.Graph.Write</a> are preserved
unsafeMapNodes :: (n -> n') -> Graph n -> Graph n'

-- | map that supplies an additional unique key to the mapping function;
--   unsafe in the same way as <a>unsafeMapNodes</a>
unsafeMapNodesUnique :: (Int -> n -> n') -> Graph n -> Graph n'

-- | apply a monadic graph modification to a graph
runGraph :: Rewrite n a -> Graph n -> (a, Graph n)
evalGraph :: Rewrite n a -> Graph n -> a
execGraph :: Rewrite n a -> Graph n -> Graph n

-- | Hypergraph that holds nodes of type <tt>n</tt>. Nodes can be
--   referenced by type <a>Node</a>, edges by type <a>Edge</a>, see
--   <a>GraphRewriting.Graph.Read</a> and <a>GraphRewriting.Graph.Write</a>
data Graph n
Graph :: IntMap n -> IntMap IntSet -> Int -> Graph n
nodeMap :: Graph n -> IntMap n
edgeMap :: Graph n -> IntMap IntSet
nextKey :: Graph n -> Int


-- | The multi-parameter type-class <a>View</a> provides an abstraction
--   <tt>View v n</tt> of a type <tt>n</tt> that exposes a value of type
--   <tt>v</tt>. It allows both to <a>inspect</a> and <a>update</a> the
--   value, while hiding the internal structure of the value type
--   (<tt>n</tt>).
module Data.View

-- | Minimal complete definition: <tt>inspect</tt> and one of
--   {<tt>update</tt>, <tt>adjust</tt>}
class View v n where update v = adjust (const v) adjust f n = update (f $ inspect n) n
inspect :: View v n => n -> v
update :: View v n => v -> n -> n
adjust :: View v n => (v -> v) -> n -> n

-- | convenience function that can be used to access record fields of the
--   exposed type
examine :: View v n => (v -> field) -> n -> field
adjustM :: (Monad m, View v n) => (v -> m v) -> n -> m n
instance [overlap ok] (View v1 n, View v2 n, View v3 n, View v4 n) => View (v1, v2, v3, v4) n
instance [overlap ok] (View v1 n, View v2 n, View v3 n) => View (v1, v2, v3) n
instance [overlap ok] (View v1 n, View v2 n) => View (v1, v2) n
instance [overlap ok] View n n


-- | Enquiry of the graph structure. Note: In this module the term
--   <a>node</a> is often used synonymously to <a>node reference</a> and
--   <a>node value</a>. The two can easily distinguished by their type: the
--   former has type <a>Node</a> the latter usually <tt>n</tt>.
module GraphRewriting.Graph.Read
type WithGraph n = Reader (Graph n)

-- | This forces the use of the <a>Reader</a> monad. Wrapping a sequence of
--   monadic read-only operations (such as those defined below) into a
--   read-only block can save much overhead e.g. in the state monad.
readOnly :: MonadReader (Graph n) m => Reader (Graph n) a -> m a
existNode :: MonadReader (Graph n) m => Node -> m Bool
readNode :: MonadReader (Graph n) m => Node -> m n

-- | a wrapper to <a>inspect</a> the given node
inspectNode :: (View v n, MonadReader (Graph n) m) => Node -> m v

-- | a wrapper to <a>examine</a> the given node
examineNode :: (View v n, MonadReader (Graph n) m) => (v -> a) -> Node -> m a

-- | all of the graph's nodes
readNodeList :: MonadReader (Graph n) m => m [Node]

-- | all of the graph's edges
readEdgeList :: MonadReader (Graph n) m => m [Edge]

-- | edges attached to the given node
attachedEdges :: (View [Port] n, MonadReader (Graph n) m) => Node -> m [Edge]

-- | non-empty set of nodes attached to the given edge
attachedNodes :: MonadReader (Graph n) m => Edge -> m [Node]

-- | amount of ports the given hyperedge is connected to
edgeCardinality :: (View [Port] n, MonadReader (Graph n) m) => Edge -> m Int

-- | list of nodes that are connected to the given node, not including the
--   node itself
neighbours :: (View [Port] n, MonadReader (Graph n) m) => Node -> m [Node]

-- | list of nodes that are connected to the given node, including the node
--   itself
relatives :: (View [Port] n, MonadReader (Graph n) m) => Node -> m [Node]

-- | nodes connected to given port of the specified node, not including the
--   node itself
adverseNodes :: MonadReader (Graph n) m => Node -> Port -> m [Node]

-- | whether two nodes are connected
connected :: (View [Port] n, MonadReader (Graph n) m) => Node -> Node -> m Bool

-- | whether the given ports features a dangling edge
dangling :: (View [Port] n, MonadReader (Graph n) m) => Port -> m Bool

-- | Map node-relative enquiry over the nodes of the graph.
withNodes :: MonadReader (Graph n) m => (Node -> m a) -> m [a]


-- | Patterns allow monadic scrutinisation of the graph (modifications are
--   not possible) while keeping track of matched nodes (history). A
--   <a>Pattern</a> is interpreted by <a>runPattern</a> that returns a
--   result for each position in the graph where the pattern matches. It is
--   allowed to <a>fail</a> inside the <a>Pattern</a> monad, indicating
--   that the pattern does not match, which corresponds to conditional
--   rewriting.
module GraphRewriting.Pattern

-- | A pattern represents a graph scrutinisation that memorises all the
--   scrutinised nodes during matching.
type Pattern n = PatternT n Identity
runPatternT :: PatternT n m a -> Graph n -> m [(Match, a)]

-- | Apply a pattern on a graph returning a result for each matching
--   position in the graph together with the matched nodes.
runPattern :: Pattern n a -> Graph n -> [(Match, a)]
evalPattern :: Pattern n a -> Graph n -> [a]
execPattern :: Pattern n a -> Graph n -> [Match]

-- | Something like an implicit monadic map
branch :: Monad m => [a] -> PatternT n m a

-- | <a>branch</a> on each node, add it to the history, and return it
branchNodes :: Monad m => [Node] -> PatternT n m Node

-- | Probe whether a pattern matches somewhere on the graph. You might want
--   to combine this with <a>amnesia</a>.
probe :: Monad m => PatternT n m a -> PatternT n m Bool

-- | probe a pattern returning the matches it has on the graph. You might
--   want to combine this with <a>amnesia</a>.
matches :: Monad m => PatternT n m a -> PatternT n m [Match]

-- | probe a pattern returning the matches it has on the graph. You might
--   want to combine this with <a>amnesia</a>.
match :: Monad m => PatternT n m a -> PatternT n m [(Match, a)]

-- | choice over a list of patterns
anyOf :: Alternative f => [f a] -> f a

-- | conditional rewriting: <a>fail</a> when predicate is not met
require :: Monad m => Bool -> m ()

-- | <a>fail</a> if given pattern succeeds, succeed if it fails.
requireFailure :: Monad m => PatternT n m a -> PatternT n m ()

-- | <a>fail</a> when monadic predicate is not met
requireM :: Monad m => m Bool -> m ()

-- | Lift a scrutinisation from <a>Reader</a> to <a>Pattern</a> leaving the
--   history unchanged.
liftReader :: Monad m => Reader (Graph n) a -> PatternT n m a

-- | any node anywhere in the graph
node :: (Monad m, View v n) => PatternT n m v

-- | A specific node
nodeAt :: (Monad m, View v n) => Node -> PatternT n m v

-- | any edge anywhere in the graph
edge :: Monad m => PatternT n m Edge

-- | node that is connected to given edge
nodeWith :: (Monad m, View v n) => Edge -> PatternT n m v

-- | edge that is attached to given node
edgeOf :: (Monad m, View [Port] n) => Node -> PatternT n m Edge

-- | node that is connected to the given node, but not that node itself
neighbour :: Monad m => (View [Port] n, View v n) => Node -> PatternT n m v

-- | node that is connected to the given node, permitting the node itself
relative :: (Monad m, View [Port] n, View v n) => Node -> PatternT n m v

-- | nodes connected to given port of the specified node, not including the
--   node itself. Consider as an alternative <a>linear</a> combined with
--   <a>nodeWith</a>.
adverse :: (Monad m, View [Port] n, View v n) => Port -> Node -> PatternT n m v

-- | A specific node
visit :: Monad m => Node -> PatternT n m ()

-- | Do not remember any of the nodes matched by the supplied pattern
amnesia :: Monad m => PatternT n m a -> PatternT n m a

-- | list of nodes matched until now with the most recent node in head
--   position
history :: Monad m => PatternT n m Match

-- | a reference to the lastly matched node
previous :: Monad m => PatternT n m Node

-- | only match nodes in the next pattern that have not been matched before
nextFresh :: Monad m => PatternT n m a -> PatternT n m a

-- | only accept the given node in the next match
nextIs :: Monad m => Node -> PatternT n m a -> PatternT n m a

-- | Restrict a pattern based on the which of nodes have matched been
--   previously and which nodes will be matched in the future. The first
--   parameter of the supplied function is the history with the most
--   recently matched node in head position. The second parameter is the
--   future with the next matched node in head position.
restrictOverlap :: Monad m => (Match -> Match -> Bool) -> PatternT n m a -> PatternT n m a

-- | Nodes in the future may not be matched more than once.
linear :: Monad m => PatternT n m a -> PatternT n m a

-- | A pattern represents a graph scrutinisation that memorises all the
--   scrutinised nodes during matching.
data PatternT n m a

-- | A pattern represents a graph scrutinisation that memorises all the
--   scrutinised nodes during matching.
type Pattern n = PatternT n Identity

-- | Nodes matched in the evaluation of a pattern with the lastly matched
--   node at the head
type Match = [Node]
(<|>) :: Alternative f => forall a. f a -> f a -> f a
instance [overlap ok] Monad m => MonadPlus (PatternT n m)
instance [overlap ok] Monad m => Monoid (PatternT n m a)
instance [overlap ok] Monad m => Alternative (PatternT n m)
instance [overlap ok] Monad m => Applicative (PatternT n m)
instance [overlap ok] Monad m => Functor (PatternT n m)
instance [overlap ok] MonadTrans (PatternT n)
instance [overlap ok] Monad m => Monad (PatternT n m)


-- | This modules provides variants of the functions in
--   <a>GraphRewriting.Graph.Write</a> for transforming the graph, but
--   without checking for changed port assignments, which could lead to an
--   inconsistent state. Therefore these should only be used (for increased
--   efficiency) if the modifications do not change the graph structure
--   (such as in layouting), or you really know what you are doing. Note
--   that the functions provided by this library never change the length of
--   the port list
module GraphRewriting.Graph.Write.Unsafe
writeNode :: Node -> n -> Rewrite n ()
modifyNode :: Node -> (n -> n) -> Rewrite n ()
updateNode :: View v n => Node -> v -> Rewrite n ()
adjustNode :: View v n => Node -> (v -> v) -> Rewrite n ()
adjustNodeM :: (View [Port] n, View v n) => Node -> (v -> Rewrite n v) -> Rewrite n ()
unregister :: Node -> [Edge] -> Rewrite n ()
register :: Node -> [Edge] -> Rewrite n ()


-- | Functions for modifying the graph. Although the graph structure is
--   entirely expressed by the graph's node collection, for convenience and
--   efficiency the graph representation also comprises a complementary
--   collection of edges, that has to be synchronised with the node
--   collection. Therefore each of the functions below involves a test for
--   whether the graph structure has been changed, and if so, measures are
--   taken to ensure the graph remains consistent.
--   
--   Invariants for graph consistency:
--   
--   <ul>
--   <li>Every edge attached to some node points back to that node: ∀n∊N
--   ∀e∊E: n</li>
--   </ul>
module GraphRewriting.Graph.Write

-- | assign new value to given node
writeNode :: View [Port] n => Node -> n -> Rewrite n ()

-- | modify the node value
modifyNode :: View [Port] n => Node -> (n -> n) -> Rewrite n ()

-- | Wraps <a>update</a> to update aspect <tt>v</tt> of a node.
updateNode :: (View [Port] n, View v n) => Node -> v -> Rewrite n ()

-- | Wraps <a>adjust</a> to adjust aspect <tt>v</tt> of a node.
adjustNode :: (View [Port] n, View v n) => Node -> (v -> v) -> Rewrite n ()
adjustNodeM :: (View [Port] n, View v n) => Node -> (v -> Rewrite n v) -> Rewrite n ()

-- | add a new node with value <tt>n</tt> to the graph
newNode :: View [Port] n => n -> Rewrite n Node

-- | Create a new node by cloning another, at the same time updating aspect
--   <tt>v</tt>. When defining rewrites in a context where it is not known
--   what type <tt>n</tt> the nodes of the graph have, this is the only way
--   to add new nodes to the graph.
copyNode :: (View [Port] n, View v n) => Node -> v -> Rewrite n Node

-- | Create a new (unconnected) edge. It is expected that the created edge
--   is connected to a port sooner or later. Otherwise the graph will
--   invove unconnected edges.
newEdge :: Rewrite n Edge

-- | remove node from the graph
deleteNode :: View [Port] n => Node -> Rewrite n ()

-- | Disconnect ports connected to the given edge by assigning a new
--   (dangling) edge to each of the ports. Then the edge is deleted.
deleteEdge :: View [Port] n => Edge -> Rewrite n [Edge]

-- | Reconnects the ports connected to the second edge to the first one.
--   Then the second edge is deleted.
mergeEdges :: View [Port] n => Edge -> Edge -> Rewrite n ()


-- | Rewrite rules are represented as nested monads: a <a>Rule</a> is a
--   <a>Pattern</a> that returns a <a>Rewrite</a> the latter directly
--   defining the transformation of the graph.
--   
--   For rule construction a few functions a provided: The most basic one
--   is <a>rewrite</a>. But in most cases <a>erase</a>, <a>rewire</a>, and
--   'replace*' should be more convenient. These functions express rewrites
--   that <i>replace</i> the matched nodes of the <a>Pattern</a>, which
--   comes quite close to the <tt>L -&gt; R</tt> form in which graph
--   rewriting rules are usually expressed.
module GraphRewriting.Rule
data Replace n a

-- | A rewriting rule is defined as a <a>Pattern</a> that returns a
--   <a>Rewrite</a>
type Rule n = Pattern n (Rewrite n ())

-- | Apply rule at an arbitrary position if applicable
apply :: Rule n -> Rewrite n ()

-- | Apply rule at an arbitrary position. Return value states whether the
--   rule was applicable.
apply' :: Rule n -> Rewrite n Bool

-- | primitive rule construction with the matched nodes of the left hand
--   side as a parameter
rewrite :: (Match -> Rewrite n a) -> Rule n

-- | constructs a rule that deletes all of the matched nodes from the graph
erase :: View [Port] n => Rule n

-- | Constructs a rule from a list of rewirings. Each rewiring specifies a
--   list of hyperedges that are to be merged into a single hyperedge. All
--   matched nodes of the left-hand side are removed.
rewire :: View [Port] n => [[Edge]] -> Rule n
replace :: View [Port] n => Replace n () -> Rule n
byNode :: (View [Port] n, View v n) => v -> Replace n ()
byNewNode :: View [Port] n => n -> Replace n ()
byEdge :: Replace n Edge
byWire :: Edge -> Edge -> Replace n ()
byConnector :: [Edge] -> Replace n ()

-- | Apply two rules consecutively. Second rule is only applied if first
--   one succeeds. Fails if (and only if) first rule fails.
(>>>) :: Rule n -> Rule n -> Rule n

-- | Make a rule exhaustive, i.e. such that (when applied) it reduces
--   redexes until no redexes are occur in the graph.
exhaustive :: Rule n -> Rule n

-- | Make a rule parallel, i.e. such that (when applied) all current
--   redexes are contracted one by one. Neither new redexes or destroyed
--   redexes are reduced.
everywhere :: Rule n -> Rule n

-- | Repeatedly apply the rules from the given list prefering earlier
--   entries. Returns a list of indexes reporting the sequence of rules
--   that has applied.
benchmark :: [Rule n] -> Rewrite n [Int]
instance [overlap ok] Monoid (Replace n ())
instance [overlap ok] Applicative (Replace n)
instance [overlap ok] Functor (Replace n)
instance [overlap ok] Monad (Replace n)


-- | This is a monadic graph rewriting library for port graphs with a
--   strong emphasis on nodes. It aims primarily at making it as convenient
--   as possible to specify graph rewriting systems in Haskell and to
--   experiment with them. There are a few aspects of the design to be
--   pointed out:
--   
--   <ol>
--   <li>The port graph is actually a hypergraph, therefore if we speak of
--   edges we are in fact referring hyperedges.</li>
--   <li>The graph structure is essentially representated as a collection
--   of nodes. The nodes have a user-defined type, where each node features
--   a list of <a>Port</a>s to each of which an <a>Edge</a> is attached.
--   Edges are unlabeled and can not exist autonomously, i.e. each edge is
--   connected to at least one port. Each port is connetected to exactly
--   one edge. Two ports are connected if (and only if) they share the same
--   edge. What is particularly convenient is how these ports can be
--   modeled as constructor fields of a user-defined node type.</li>
--   <li>An important abstraction used in this library is the
--   multi-parameter type-class <a>View</a>. It permits to expose a certain
--   aspect of a node, allowing both to <a>inspect</a> or <a>update</a> it,
--   while hiding the internal representation of the node. By that it is
--   easy to specify the rewrite system in a way, that it can not only be
--   applied to a graph with nodes of a fixed node type, but also to a
--   <a>Graph</a> with polymorphic node type <tt>n</tt>. The nodes merely
--   have to <i>expose</i> values of type <tt>v</tt> by means of defining a
--   <tt>View v</tt> on <tt>n</tt>. The <a>View</a> abstraction is also
--   used to expose the nodes' ports (and therefore the graph structure) to
--   this library.</li>
--   <li>Rewrite <a>Rule</a> are represented as <a>Pattern</a>s that return
--   a <a>Rewrite</a>. A <a>Pattern</a> is a branching scrutinisation of
--   the graph that returns a result for every possible matching position
--   in the graph. A <a>Rule</a> is essentially a <a>Pattern</a> that
--   returns a <a>Rewrite</a>. A <a>Rewrite</a> is a monadic modification
--   of the graph structure. In a <a>Rule</a> the <a>Rewrite</a> part can
--   conveniently use the variables bound in the <a>Pattern</a> code.</li>
--   </ol>
--   
--   See the graph-rewriting-ski package for an example of a simple rewrite
--   system. Together with the graph-rewriting-layout and the
--   graph-rewriting-gl packages it is easy to build a graphical and
--   interactive application to experiment with your rewrite system.
--   
--   What the library does not (yet) offer combinators to define
--   strategies, since the emphasis of the project was to create an
--   interactive graph-rewriting tool where rules and rewriting positions
--   are selected manually.
module GraphRewriting


-- | Offers an <a>activePair</a> pattern for convenient implementation of
--   interaction nets.
module GraphRewriting.Pattern.InteractionNet

-- | Index that identifies the principal port within the list of ports
class INet n
principalPort :: INet n => n -> Port

-- | Instead of <tt>(,)</tt> to save parentheses
data Pair a
(:-:) :: a -> a -> Pair a
pair :: Pair a -> (a, a)
activePair :: (View [Port] n, View v n, INet v) => Pattern n (Pair v)
instance [overlap ok] Functor Pair
