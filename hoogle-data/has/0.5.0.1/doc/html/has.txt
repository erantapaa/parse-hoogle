-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Entity based records
--   
--   Typical usage is described at
--   <a>http://github.com/nonowarn/has/blob/master/examples/Announce04.lhs</a>.
@package has
@version 0.5.0.1


-- | Entiry based records. To use this module, you have to write LANGUGAGE
--   pragma
--   
--   <pre>
--   {-# LANGUAGE TypeFamilies,TypeOperators,FlexibleContexts #-}
--   </pre>
--   
--   Or OPTIONS_GHC pragma if you are lazy.
--   
--   <pre>
--   {-# OPTIONS_GHC -fglasgow-exts #-}
--   </pre>
module Data.Has

-- | Meaning of this constraint is "This record <tt>s</tt> has a field of
--   entity <tt>e</tt>." Here, I use the word "constraint" for class which
--   is useful on writing type signitures.
--   
--   Holds <tt>v == (e .^ (e ^= v $ s))</tt> where <tt>e :: e; v :: TypeOf
--   e; s :: s</tt> for all <tt>e</tt> with <tt>TypeOf e</tt> and
--   <tt>s</tt>.
--   
--   Same as <tt>Knows e (TypeOf e) s</tt>.
class Knows e (TypeOf e) r => Has e r

-- | <tt>Field a</tt> is a type list which contains only one element of
--   <tt>a</tt>. And every field in the records should be this type.
--   
--   If you concatenate fields with <tt>(:&amp;:)</tt> at type-level,
--   <tt>(&amp;)</tt> at value-level, it becomes a record can be
--   manipulated by functions in this module.
type Field a = a ::: TyNil

-- | Creates a <a>Field</a> of <tt>a</tt>.
field :: a -> Field a

-- | Creates a field labelled by <tt>a</tt>
fieldOf :: TypeOf a -> FieldOf a

-- | Writes field of <tt>e</tt> in <tt>r</tt> with <tt>TypeOf e</tt>.
(^=) :: Knows e (TypeOf e) r => e -> TypeOf e -> r -> r

-- | Reads <tt>TypeOf e</tt> from field of <tt>e</tt> in <tt>r</tt>.
(^.) :: Knows e (TypeOf e) r => e -> r -> TypeOf e

-- | Modifies field of <tt>e</tt> in <tt>r</tt> with given function
--   <tt>TypeOf e -&gt; | TypeOf e</tt>.
(^:) :: Knows e (TypeOf e) r => e -> (TypeOf e -> TypeOf e) -> (r -> r)

-- | Creates field of <tt>e</tt> with given value <tt>TypeOf e</tt>.
--   Stealed from Chris Done's blog post:
--   <a>http://chrisdone.com/posts/2010-11-22-duck-typing-in-haskell.html</a>
(^-) :: e -> TypeOf e -> FieldOf e

-- | Injects and projects a value of <tt>v</tt> a corresponding field in
--   records <tt>a</tt> along entity <tt>e</tt>.
--   
--   Holds <tt>v == prjl e (injl e v r)</tt>.
class Contains (Labelled e v) r => Knows e v r | e r -> v
injl :: Knows e v r => e -> v -> r -> r
prjl :: Knows e v r => e -> r -> v

-- | Updates a value of <tt>v</tt> in a record <tt>r</tt> using function of
--   <tt>v -&gt; v</tt>.
updl :: Knows e v r => e -> (v -> v) -> (r -> r)

-- | Represents labelled value.
data Labelled lab a

-- | Represents labelled field.
type :> lab a = Field (Labelled lab a)

-- | Makes a labelled field.
(.>) :: lab -> a -> lab :> a

-- | <tt>TypeOf a</tt> should indicate a type labelled by <tt>a</tt>. When
--   defining entities, declare instance of this family. If you want
--   <tt>Foo</tt> entity points to <tt>Int</tt>, you write
--   
--   <pre>
--   data Foo = Foo; type instance TypeOf Foo = Int
--   </pre>

-- | Field labelled with <tt>a</tt>, and contains <tt>TypeOf a</tt>.

-- | Concatenates between <a>Field</a>s or records. Records are
--   concatenated rows. For example, Following expressions are valid.
--   
--   <pre>
--   -- Concatenation of rows (i.e. record)
--   field "string" &amp; field True
--   </pre>
--   
--   <pre>
--   -- Concatenation of records
--   (field 'c' &amp; field ()) &amp; (field False &amp; field "string")
--   </pre>
--   
--   <pre>
--   -- ... And concatenations between a field and a record
--   field () &amp; (field False &amp; field "string")
--   (field 'c' &amp; field ()) &amp; field False
--   </pre>
(&) :: Append a b => a -> b -> a :&: b

-- | Represents concatenated rows or records.

-- | Cons a type onto type-list.
data (:::) a b

-- | The empty type-list.
data TyNil

-- | Provides injection and projection into type lists.
--   
--   Holds <tt>e == prj (inj e s)</tt> for all <tt>s</tt> and <tt>e</tt>.
class Contains e s
instance Typeable2 Labelled
instance Eq a => Eq (Labelled lab a)
instance Ord a => Ord (Labelled lab a)
instance Show a => Show (Labelled lab a)
instance Read a => Read (Labelled lab a)
instance Bounded a => Bounded (Labelled lab a)
instance (Data lab, Data a) => Data (Labelled lab a)
instance CoArbitrary a => CoArbitrary (Labelled lab a)
instance Arbitrary a => Arbitrary (Labelled lab a)
instance Monoid a => Monoid (Labelled lab a)
instance Knows e (TypeOf e) r => Has e r
instance Contains (Labelled e v) r => Knows e v r
