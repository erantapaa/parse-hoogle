-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | timers which are updatable in the remaining time
--   
--   Timers implemented in this package can be used to synchronise threads
--   to continue all together when the timer rings. While the timer is
--   running it can be updated in the remaining time. A parallel and serial
--   update policy is provided.
@package timers-updatable
@version 0.2.0.2


-- | Ad hoc overload of term kill
module Control.Concurrent.Killable

-- | Objects that forked threads and can be killed
class Killable a
kill :: Killable a => a -> IO ()
instance Foldable a => Killable (a ThreadId)
instance Killable ThreadId


-- | An updatable timer is a timer for which it is possible to update the
--   remaining time.
--   
--   Methods are exposed in STM to give composability. IO wrappers for
--   those are exported also.
--   
--   Parallel and serial update politics are implemented.
--   
--   In the example we start a timer with a time to wait of 10 seconds,
--   hang 2 threads which will wait for it to finish, and update it after 5
--   seconds to wait for other 6 seconds. It will complete and run its
--   action and the hanged threads after 11 seconds because of its parallel
--   nature. The serial timer would have ringed after 16 seconds.
--   
--   <pre>
--   import Control.Concurrent
--   import System.Timer.Updatable
--   import Data.Maybe
--   main = do
--    t &lt;- parallel (return 5) $ 10^7
--    forkIO $ waitIO t &gt;&gt;= print . (+1) . fromJust 
--    forkIO $ waitIO t &gt;&gt;= print . (+2) . fromJust
--    threadDelay $ 5 * 10 ^ 6
--    renewIO t $ 6 * 10 ^ 6
--    waitIO t &gt;&gt;= print . fromJust 
--   </pre>
module System.Timer.Updatable

-- | A delay in microseconds
type Delay = Int64

-- | Abstract timers that can be updated. Hanging via wait function can be
--   done by any number of threads, which is synchronization.
data Updatable a

-- | wait until the timer rings, or signal Nothing if timer is destroyed
wait :: Updatable a -> STM (Maybe a)

-- | update the delay in the timer
renew :: Updatable a -> Delay -> STM ()

-- | Wait in IO
waitIO :: Updatable a -> IO (Maybe a)

-- | Renew in IO
renewIO :: Updatable a -> Delay -> IO ()

-- | Create and start a parallel updatable timer. The <a>renew</a> action
--   for this timer will start parallel timers. The last timer that is over
--   will compute the given action.
parallel :: IO a -> Delay -> IO (Updatable a)

-- | Create and start a serial updatable timer. The <a>renew</a> action for
--   this timer will schedule new timer after the running one. The timer
--   will run the given action after the sum of all scheduled times is
--   over.
serial :: IO a -> Delay -> IO (Updatable a)

-- | Create and start a replacer updatable timer. The <a>renew</a> action
--   for this timer will insert a new timer replacing the running one. The
--   timer will run the given action after this time
replacer :: IO a -> Delay -> IO (Updatable a)

-- | Pause the thread for the given number of microseconds. There is no
--   guarantee that the thread will be restarted promptly after the delay,
--   but it will not be started before then.
--   
--   Similar to <a>threadDelay</a>, but takes a 64-bit argument. The
--   Haskell 2010 specification says that (maxBound :: Int) is at least
--   2^29-1. However 2^29 microseconds is only about 538 seconds. GHC on a
--   32-bit machine has a 32 bit Int, but that is still less than 36
--   minutes. 64-bit signed integers give a maximum delay of over 292
--   million years, which should be sufficient.
longThreadDelay :: Delay -> IO ()
instance Killable (Updatable a)
