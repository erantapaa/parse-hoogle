-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A binding for the OpenGL Utility Toolkit
--   
@package GLUT
@version 2.7.0.1


-- | In addition to the functionality offered by <a>fullScreen</a>, GLUT
--   offers an sub-API to change the screen resolution, color depth, and
--   refresh rate of the display for a single full screen window. This mode
--   of operation is called <i>game mode</i>, and is restricted in various
--   ways: No pop-up menus are allowed for this full screen window, no
--   other (sub-)windows can be created, and all other applications are
--   hidden.
--   
--   <i>X Implementation Notes:</i> Note that game mode is not fully
--   supported in the original GLUT for X, it is essentially the same as
--   using <a>fullScreen</a>. The GLUT clone freeglut (see
--   <a>http://freeglut.sourceforge.net/</a>) does not have this
--   restriction.
module Graphics.UI.GLUT.GameMode

-- | Capabilities for <a>gameModeCapabilities</a>
data GameModeCapability

-- | Width of the screen resolution in pixels
GameModeWidth :: GameModeCapability

-- | Height of the screen resolution in pixels
GameModeHeight :: GameModeCapability

-- | Color depth of the screen in bits
GameModeBitsPerPlane :: GameModeCapability

-- | Refresh rate in Hertz
GameModeRefreshRate :: GameModeCapability

-- | Match the Nth frame buffer configuration compatible with the given
--   capabilities (numbering starts at 1)
GameModeNum :: GameModeCapability

-- | A single capability description for <a>gameModeCapabilities</a>.
data GameModeCapabilityDescription
Where' :: GameModeCapability -> Relation -> Int -> GameModeCapabilityDescription

-- | Controls the <i>game mode</i> to be used when <a>enterGameMode</a> is
--   called. It is described by a list of zero or more capability
--   descriptions, which are translated into a set of criteria used to
--   select the appropriate screen configuration. The criteria are matched
--   in strict left to right order of precdence. That is, the first
--   specified criterion (leftmost) takes precedence over the later
--   criteria for non-exact criteria (<a>IsGreaterThan</a>,
--   <a>IsLessThan</a>, etc.). Exact criteria (<a>IsEqualTo</a>,
--   <a>IsNotEqualTo</a>) must match exactly so precedence is not relevant.
--   
--   To determine which configuration will actually be tried by
--   <a>enterGameMode</a> (if any), use <a>gameModeInfo</a>.
--   
--   Note that even for game mode the current values of
--   <a>initialDisplayMode</a>or <a>initialDisplayCapabilities</a> will
--   determine which buffers are available, if double buffering is used or
--   not, etc.
gameModeCapabilities :: SettableStateVar [GameModeCapabilityDescription]

-- | Enter <i>game mode</i>, trying to change resolution, refresh rate,
--   etc., as specified by the current value of
--   <a>gameModeCapabilities</a>. An identifier for the game mode window
--   and a flag, indicating if the display mode actually changed, are
--   returned. The game mode window is made the <i>current window</i>.
--   
--   Re-entering <i>game mode</i> is allowed, the previous game mode window
--   gets destroyed by this, and a new one is created.
enterGameMode :: MonadIO m => m (Window, Bool)

-- | Leave <i>game mode</i>, restoring the old display mode and destroying
--   the game mode window.
leaveGameMode :: MonadIO m => m ()

-- | The color depth of the screen, measured in bits (e.g. 8, 16, 24, 32,
--   ...)
type BitsPerPlane = Int

-- | The refresh rate of the screen, measured in Hertz (e.g. 60, 75, 100,
--   ...)
type RefreshRate = Int
data GameModeInfo
GameModeInfo :: Size -> BitsPerPlane -> RefreshRate -> GameModeInfo

-- | Return <a>Just</a> the mode which would be tried by the next call to
--   <a>enterGameMode</a>. Returns <a>Nothing</a> if the mode requested by
--   the current value of <a>gameModeCapabilities</a> is not possible, in
--   which case <a>enterGameMode</a> would simply create a full screen
--   window using the current mode.
gameModeInfo :: GettableStateVar (Maybe GameModeInfo)

-- | Contains <a>True</a> when the <i>game mode</i> is active, <a>False</a>
--   otherwise.
gameModeActive :: GettableStateVar Bool
instance Eq GameModeCapability
instance Ord GameModeCapability
instance Show GameModeCapability
instance Eq GameModeCapabilityDescription
instance Ord GameModeCapabilityDescription
instance Show GameModeCapabilityDescription
instance Eq GameModeInfo
instance Ord GameModeInfo
instance Show GameModeInfo


-- | GLUT offers some routines for controlling the key repeat and polling
--   the joystick.
module Graphics.UI.GLUT.DeviceControl

-- | The state of the global key repeat
data GlobalKeyRepeat
GlobalKeyRepeatOff :: GlobalKeyRepeat
GlobalKeyRepeatOn :: GlobalKeyRepeat
GlobalKeyRepeatDefault :: GlobalKeyRepeat

-- | Controls the key repeat mode for the window system on a global basis
--   if possible. If supported by the window system, the key repeat can
--   either be disabled, enabled, or set to the window system's default key
--   repeat state.
--   
--   <i>X Implementation Notes:</i> X11 sends <tt>KeyPress</tt> events
--   repeatedly when the window system's global auto repeat is enabled.
--   <a>perWindowKeyRepeat</a> can prevent these auto repeated keystrokes
--   from being reported as keyboard or special callbacks, but there is
--   still some minimal overhead by the X server to continually stream
--   <tt>KeyPress</tt> events to the GLUT application. The
--   <a>globalKeyRepeat</a> state variable can be used to actually disable
--   the global sending of auto repeated <tt>KeyPress</tt> events. Note
--   that <a>globalKeyRepeat</a> affects the global window system auto
--   repeat state so other applications will not auto repeat if you disable
--   auto repeat globally through <a>globalKeyRepeat</a>. GLUT applications
--   using the X11 GLUT implementation should disable key repeat with
--   <a>globalKeyRepeat</a> to disable key repeats most efficiently, but
--   are responsible for explicitly restoring the default key repeat state
--   on exit.
--   
--   <i>Win32 Implementation Notes:</i> The Win32 implementation of
--   <a>globalKeyRepeat</a> does nothing. The <a>perWindowKeyRepeat</a> can
--   be used in the Win32 GLUT implementation to ignore repeated keys on a
--   per-window basis without changing the global window system key repeat.
globalKeyRepeat :: StateVar GlobalKeyRepeat

-- | The state of the per-window key repeat
data PerWindowKeyRepeat
PerWindowKeyRepeatOff :: PerWindowKeyRepeat
PerWindowKeyRepeatOn :: PerWindowKeyRepeat

-- | Controls if auto repeat keystrokes are reported to the <i>current
--   window.</i> Ignoring auto repeated keystrokes is generally done in
--   conjunction with using the <a>keyboardMouseCallback</a>. If you do not
--   ignore auto repeated keystrokes, your GLUT application will experience
--   repeated release/press callbacks. Games using the keyboard will
--   typically want to ignore key repeat.
perWindowKeyRepeat :: StateVar PerWindowKeyRepeat

-- | Execute the joystick callback set by <a>joystickCallback</a> once (if
--   one exists). This is done in a synchronous fashion within the current
--   context, i.e. when <a>forceJoystickCallback</a> returns, the callback
--   will have already happened.
forceJoystickCallback :: MonadIO m => m ()
instance Eq GlobalKeyRepeat
instance Ord GlobalKeyRepeat
instance Show GlobalKeyRepeat
instance Eq PerWindowKeyRepeat
instance Ord PerWindowKeyRepeat
instance Show PerWindowKeyRepeat


-- | This module contains a simple utility routine to report any pending GL
--   errors.
module Graphics.UI.GLUT.Debugging

-- | Report any pending GL errors to stderr (which is typically the
--   console). If there are no pending errors, this routine does nothing.
--   Note that the error flags are reset after this action, i.e. there are
--   no pending errors left afterwards.
reportErrors :: MonadIO m => m ()


-- | GLUT includes a number of routines for generating easily recognizable
--   3D geometric objects. These routines reflect functionality available
--   in the <tt>aux</tt> toolkit described in the <i>OpenGL Programmer's
--   Guide</i> and are included in GLUT to allow the construction of simple
--   GLUT programs that render recognizable objects. These routines can be
--   implemented as pure OpenGL rendering routines. The routines do not
--   generate display lists for the objects they create. The routines
--   generate normals appropriate for lighting but do not generate texture
--   coordinates (except for the solid teapot, teacup and teaspoon). If
--   VBOs should be used instead of the fixed function pipeline, specify at
--   least one of the attribute locations <a>vertexAttribCoord3</a> or
--   <a>vertexAttribNormal</a>.
module Graphics.UI.GLUT.Objects

-- | Flavour of object rendering
data Flavour

-- | Object is rendered as a solid with shading and surface normals.
Solid :: Flavour

-- | Object is rendered as a wireframe without surface normals.
Wireframe :: Flavour

-- | GLUT offers five types of objects:
--   
--   <ul>
--   <li>The five Platonic solids, see
--   <a>http://mathworld.wolfram.com/PlatonicSolid.html</a>.</li>
--   <li>A rhombic dodecahedron, see
--   <a>http://mathworld.wolfram.com/RhombicDodecahedron.html</a>.</li>
--   <li>Approximations to rounded objects.</li>
--   <li>The classic teaset modeled by Martin Newell in 1975. Both surface
--   normals and texture coordinates for the teaset are generated.</li>
--   <li>A Sierpinski sponge, see
--   <a>http://mathworld.wolfram.com/Tetrix.html</a>.</li>
--   </ul>
data Object

-- | A cube centered at the modeling coordinates origin with sides of the
--   given length.
Cube :: Height -> Object

-- | A dodecahedron (12-sided regular solid) centered at the modeling
--   coordinates origin with a radius of <tt>sqrt 3</tt>.
Dodecahedron :: Object

-- | A icosahedron (20-sided regular solid) centered at the modeling
--   coordinates origin with a radius of 1.0.
Icosahedron :: Object

-- | Render a solid octahedron (8-sided regular solid) centered at the
--   modeling coordinates origin with a radius of 1.0.
Octahedron :: Object

-- | Render a solid tetrahedron (4-sided regular solid) centered at the
--   modeling coordinates origin with a radius of <tt>sqrt 3</tt>.
Tetrahedron :: Object

-- | (<i>freeglut only</i>) A rhombic dodecahedron whose corners are at
--   most a distance of one from the origin. The rhombic dodecahedron has
--   faces which are identical rhombi, but which have some vertices at
--   which three faces meet and some vertices at which four faces meet. The
--   length of each side is <tt>(sqrt 3)/2</tt>. Vertices at which four
--   faces meet are found at <tt>(0, 0, +/-1)</tt> and <tt>(+/-(sqrt 2)/2,
--   +/-(sqrt 2)/2, 0)</tt>.
RhombicDodecahedron :: Object

-- | A sphere centered at the modeling coordinates origin of the specified
--   radius. The sphere is subdivided around the Z axis into slices
--   (similar to lines of longitude) and along the Z axis into stacks
--   (similar to lines of latitude).
Sphere' :: Radius -> Slices -> Stacks -> Object

-- | A cone oriented along the Z axis. The base of the cone is placed at Z
--   = 0, and the top at Z = the given height. The cone is subdivided
--   around the Z axis into slices, and along the Z axis into stacks.
Cone :: Radius -> Height -> Slices -> Stacks -> Object

-- | (<i>freeglut only</i>) A cylinder oriented along the Z axis. The base
--   of the cylinder is placed at Z = 0, and the top at Z = the given
--   height. The cylinder is subdivided around the Z axis into slices, and
--   along the Z axis into stacks.
Cylinder' :: Radius -> Height -> Slices -> Stacks -> Object

-- | A torus (doughnut) centered at the modeling coordinates origin whose
--   axis is aligned with the Z axis. The torus is described by its inner
--   and outer radius, the number of sides for each radial section, and the
--   number of radial divisions (rings).
Torus :: Radius -> Radius -> Sides -> Rings -> Object

-- | A teapot with a given relative size.
Teapot :: Height -> Object

-- | (<i>freeglut only</i>) A teacup with a given relative size.
Teacup :: Height -> Object

-- | (<i>freeglut only</i>) A teaspoon with a given relative size.
Teaspoon :: Height -> Object

-- | (<i>freeglut only</i>) A Sierpinski sponge of a given level, where a
--   level 0 sponge is the same as a <a>Tetrahedron</a>.
SierpinskiSponge :: NumLevels -> Object
type Sides = GLint
type Rings = GLint
type NumLevels = GLint

-- | Render an object in the given flavour.
renderObject :: MonadIO m => Flavour -> Object -> m ()
instance Eq Flavour
instance Ord Flavour
instance Show Flavour
instance Eq Object
instance Ord Object
instance Show Object


-- | GLUT supports two types of font rendering: stroke fonts, meaning each
--   character is rendered as a set of line segments; and bitmap fonts,
--   where each character is a bitmap generated with <a>bitmap</a>. Stroke
--   fonts have the advantage that because they are geometry, they can be
--   arbitrarily scale and rendered. Bitmap fonts are less flexible since
--   they are rendered as bitmaps but are usually faster than stroke fonts.
module Graphics.UI.GLUT.Fonts
class Font a
renderString :: (Font a, MonadIO m) => a -> String -> m ()
stringWidth :: (Font a, MonadIO m) => a -> String -> m GLint
fontHeight :: (Font a, MonadIO m) => a -> m GLfloat

-- | The bitmap fonts available in GLUT. The exact bitmap to be used is
--   defined by the standard X glyph bitmaps for the X font with the given
--   name.
data BitmapFont

-- | A fixed width font with every character fitting in an 8 by 13 pixel
--   rectangle.
--   (<tt>-misc-fixed-medium-r-normal--13-120-75-75-C-80-iso8859-1</tt>)
Fixed8By13 :: BitmapFont

-- | A fixed width font with every character fitting in an 9 by 15 pixel
--   rectangle.
--   (<tt>-misc-fixed-medium-r-normal--15-140-75-75-C-90-iso8859-1</tt>)
Fixed9By15 :: BitmapFont

-- | A 10-point proportional spaced Times Roman font.
--   (<tt>-adobe-times-medium-r-normal--10-100-75-75-p-54-iso8859-1</tt>)
TimesRoman10 :: BitmapFont

-- | A 24-point proportional spaced Times Roman font.
--   (<tt>-adobe-times-medium-r-normal--24-240-75-75-p-124-iso8859-1</tt>)
TimesRoman24 :: BitmapFont

-- | A 10-point proportional spaced Helvetica font.
--   (<tt>-adobe-helvetica-medium-r-normal--10-100-75-75-p-56-iso8859-1</tt>)
Helvetica10 :: BitmapFont

-- | A 12-point proportional spaced Helvetica font.
--   (<tt>-adobe-helvetica-medium-r-normal--12-120-75-75-p-67-iso8859-1</tt>)
Helvetica12 :: BitmapFont

-- | A 18-point proportional spaced Helvetica font.
--   (<tt>-adobe-helvetica-medium-r-normal--18-180-75-75-p-98-iso8859-1</tt>)
Helvetica18 :: BitmapFont

-- | The stroke fonts available in GLUT.
data StrokeFont

-- | A proportionally spaced Roman Simplex font for ASCII characters 32
--   through 127. The maximum top character in the font is 119.05 units;
--   the bottom descends 33.33 units.
Roman :: StrokeFont

-- | A mono-spaced spaced Roman Simplex font (same characters as
--   <a>Roman</a>) for ASCII characters 32 through 127. The maximum top
--   character in the font is 119.05 units; the bottom descends 33.33
--   units. Each character is 104.76 units wide.
MonoRoman :: StrokeFont
instance Font StrokeFont
instance Font BitmapFont


-- | OpenGL supports both RGBA and color index rendering. The RGBA mode is
--   generally preferable to color index because more OpenGL rendering
--   capabilities are available and color index mode requires the loading
--   of colormap entries.
--   
--   The GLUT color index state variables are used to read and write
--   entries in a window's color index colormap. Every GLUT color index
--   window has its own logical color index colormap. The size of a
--   window's colormap can be determined by reading
--   <a>numColorMapEntries</a>.
--   
--   GLUT color index windows within a program can attempt to share
--   colormap resources by copying a single color index colormap to
--   multiple windows using <a>copyColormap</a>. If possible GLUT will
--   attempt to share the actual colormap. While copying colormaps using
--   <a>copyColormap</a> can potentially allow sharing of physical colormap
--   resources, logically each window has its own colormap. So changing a
--   copied colormap of a window will force the duplication of the
--   colormap. For this reason, color index programs should generally load
--   a single color index colormap, copy it to all color index windows
--   within the program, and then not modify any colormap cells.
--   
--   Use of multiple colormaps is likely to result in colormap installation
--   problems where some windows are displayed with an incorrect colormap
--   due to limitations on colormap resources.
module Graphics.UI.GLUT.Colormap

-- | Controls the color index colormap entry of the <i>current window</i>'s
--   logical colormap for the <i>layer in use</i>. The <i>layer in use</i>
--   of the <i>current window</i> should be a color index window. The color
--   index should be zero or greater and less than the total number of
--   colormap entries for the window (see <a>numColorMapEntries</a>) and
--   different from an overlay's transparent index (see
--   <a>transparentIndex</a>).
--   
--   If the <i>layer in use</i>'s colormap was copied by reference, setting
--   a colormap entry will force the duplication of the colormap.
colorMapEntry :: Index1 GLint -> StateVar (Color3 GLfloat)

-- | Copy (lazily if possible to promote sharing) the logical colormap from
--   a specified window to the <i>current window</i>'s <i>layer in use</i>.
--   The copy will be from the normal plane to the normal plane; or from
--   the overlay to the overlay (never across different layers). Once a
--   colormap has been copied, avoid setting cells in the colormap via
--   <a>colorMapEntry</a> since that will force an actual copy of the
--   colormap if it was previously copied by reference. <a>copyColormap</a>
--   should only be called when both the <i>current window</i> and the
--   specified window are color index windows.
copyColormap :: MonadIO m => Window -> m ()

-- | Contains the number of entries in the colormap of the <i>current
--   window</i>'s current layer (0 in RGBA mode).
numColorMapEntries :: GettableStateVar GLint

-- | Contains the transparent color index of the overlay of the <i>current
--   window</i> or -1 if no overlay is in use.
transparentIndex :: GettableStateVar (Index1 GLint)


-- | When overlay hardware is available, GLUT provides a set of routines
--   for establishing, using, and removing an overlay for GLUT windows.
--   When an overlay is established, a separate OpenGL context is also
--   established. A window's overlay OpenGL state is kept distinct from the
--   normal planes' OpenGL state.
module Graphics.UI.GLUT.Overlay

-- | Controls the overlay for the <i>current window</i>. The requested
--   display mode for the overlay is determined by the <i>initial display
--   mode</i>. <a>overlayPossible</a> can be used to determine if an
--   overlay is possible for the <i>current window</i> with the current
--   <i>initial display mode</i>. Do not attempt to establish an overlay
--   when one is not possible; GLUT will terminate the program.
--   
--   When <a>hasOverlay</a> is set to <a>True</a> when an overlay already
--   exists, the existing overlay is first removed, and then a new overlay
--   is established. The state of the old overlay's OpenGL context is
--   discarded. Implicitly, the window's <i>layer in use</i> changes to the
--   overlay immediately after the overlay is established.
--   
--   The initial display state of an overlay is shown, however the overlay
--   is only actually shown if the overlay's window is shown.
--   
--   Setting <a>hasOverlay</a> to <a>False</a> is safe even if no overlay
--   is currently established, nothing happens in this case. Implicitly,
--   the window's /layer in use/ changes to the normal plane immediately
--   once the overlay is removed.
--   
--   If the program intends to re-establish the overlay later, it is
--   typically faster and less resource intensive to use
--   <a>overlayVisible</a> to simply change the display status of the
--   overlay.
--   
--   <i>X Implementation Notes:</i> GLUT for X uses the
--   <tt>SERVER_OVERLAY_VISUALS</tt> convention to determine if overlay
--   visuals are available. While the convention allows for opaque overlays
--   (no transparency) and overlays with the transparency specified as a
--   bitmask, GLUT overlay management only provides access to transparent
--   pixel overlays.
--   
--   Until RGBA overlays are better understood, GLUT only supports color
--   index overlays.
hasOverlay :: StateVar Bool

-- | Contains <a>True</a> if an overlay could be established for the
--   <i>current window</i> given the current <i>initial display mode</i>.
--   If it contains <a>False</a>, setting <a>hasOverlay</a> will fail with
--   a fatal error.
overlayPossible :: GettableStateVar Bool

-- | Controls the visibility of the overlay of the <i>current window</i>.
--   
--   The effect of showing or hiding an overlay takes place immediately.
--   Note that setting <a>overlayVisible</a> to <a>True</a> will not
--   actually display the overlay unless the window is also shown (and even
--   a shown window may be obscured by other windows, thereby obscuring the
--   overlay). It is typically faster and less resource intensive to use
--   the routines below to control the display status of an overlay as
--   opposed to removing and re-establishing the overlay.
overlayVisible :: SettableStateVar Bool

-- | The <i>layer in use</i>.
data Layer

-- | The normal plane.
Normal :: Layer

-- | The overlay.
Overlay :: Layer

-- | Controls the per-window <i>layer in use</i> for the <i>current
--   window</i>, which can either be the normal plane or the overlay.
--   Selecting the overlay should only be done if an overlay exists,
--   however windows without an overlay may still set the <i>layer in
--   use</i> to <a>Normal</a>. OpenGL commands for the window are directed
--   to the current <i>layer in use</i>.
layerInUse :: StateVar Layer

-- | Mark the overlay of the given window (or the <i>current window</i>, if
--   none is supplied) as needing to be redisplayed. The next iteration
--   through <a>mainLoop</a>, the window's overlay display callback (or
--   simply the display callback if no overlay display callback is
--   registered) will be called to redisplay the window's overlay plane.
--   Multiple calls to <a>postOverlayRedisplay</a> before the next display
--   callback opportunity (or overlay display callback opportunity if one
--   is registered) generate only a single redisplay.
--   <a>postOverlayRedisplay</a> may be called within a window's display or
--   overlay display callback to re-mark that window for redisplay.
--   
--   Logically, overlay damage notification for a window is treated as a
--   <a>postOverlayRedisplay</a> on the damaged window. Unlike damage
--   reported by the window system, <a>postOverlayRedisplay</a> will not
--   set to true the overlay's damaged status (see <a>damaged</a>).
--   
--   Also, see <a>postRedisplay</a>.
postOverlayRedisplay :: MonadIO m => Maybe Window -> m ()
instance Eq Layer
instance Ord Layer
instance Show Layer


-- | GLUT supports two types of windows: top-level windows and subwindows.
--   Both types support OpenGL rendering and GLUT callbacks. There is a
--   single identifier space for both types of windows.
module Graphics.UI.GLUT.Window

-- | An opaque identifier for a top-level window or a subwindow.
data Window

-- | Create a top-level window. The given name will be provided to the
--   window system as the window's name. The intent is that the window
--   system will label the window with the name.Implicitly, the <i>current
--   window</i> is set to the newly created window.
--   
--   <i>X Implementation Notes:</i> The proper X Inter-Client Communication
--   Conventions Manual (ICCCM) top-level properties are established. The
--   <tt>WM_COMMAND</tt> property that lists the command line used to
--   invoke the GLUT program is only established for the first window
--   created.
createWindow :: MonadIO m => String -> m Window

-- | Create a subwindow of the identified window with the given relative
--   position and size. Implicitly, the <i>current window</i> is set to the
--   newly created subwindow. Subwindows can be nested arbitrarily deep.
createSubWindow :: MonadIO m => Window -> Position -> Size -> m Window

-- | Destroy the specified window and the window's associated OpenGL
--   context, logical colormap (if the window is color index), and overlay
--   and related state (if an overlay has been established). Any subwindows
--   of the destroyed window are also destroyed by <a>destroyWindow</a>. If
--   the specified window was the <i>current window</i>, the <i>current
--   window</i> becomes invalid (<a>currentWindow</a> will contain
--   <a>Nothing</a>).
destroyWindow :: MonadIO m => Window -> m ()

-- | Contains the <i>current window's</i> parent. If the <i>current
--   window</i> is a top-level window, <a>Nothing</a> is returned.
parentWindow :: GettableStateVar (Maybe Window)

-- | Contains the number of subwindows the <i>current window</i> has, not
--   counting children of children.
numSubWindows :: GettableStateVar Int

-- | Controls the <i>current window</i>. It does <i>not</i> affect the
--   <i>layer in use</i> for the window; this is done using
--   <a>layerInUse</a>. Contains <a>Nothing</a> if no windows exist or the
--   previously <i>current window</i> was destroyed. Setting the <i>current
--   window</i> to <a>Nothing</a> is a no-op.
currentWindow :: StateVar (Maybe Window)

-- | Mark the normal plane of given window (or the <i>current window</i>,
--   if none is supplied) as needing to be redisplayed. The next iteration
--   through <a>mainLoop</a>, the window's display callback will be called
--   to redisplay the window's normal plane. Multiple calls to
--   <a>postRedisplay</a> before the next display callback opportunity
--   generates only a single redisplay callback. <a>postRedisplay</a> may
--   be called within a window's display or overlay display callback to
--   re-mark that window for redisplay.
--   
--   Logically, normal plane damage notification for a window is treated as
--   a <a>postRedisplay</a> on the damaged window. Unlike damage reported
--   by the window system, <a>postRedisplay</a> will <i>not</i> set to true
--   the normal plane's damaged status (see <a>damaged</a>).
--   
--   Also, see <a>postOverlayRedisplay</a>.
postRedisplay :: MonadIO m => Maybe Window -> m ()

-- | Mark the normal plane of the given window as needing to be
--   redisplayed, otherwise the same as <a>postRedisplay</a>.
--   
--   The advantage of this routine is that it saves the cost of using
--   <a>currentWindow</a> (entailing an expensive OpenGL context switch),
--   which is particularly useful when multiple windows need redisplays
--   posted at the same time.
--   
--   Perform a buffer swap on the <i>layer in use</i> for the <i>current
--   window</i>. Specifically, <a>swapBuffers</a> promotes the contents of
--   the back buffer of the <i>layer in use</i> of the <i>current
--   window</i> to become the contents of the front buffer. The contents of
--   the back buffer then become undefined. The update typically takes
--   place during the vertical retrace of the monitor, rather than
--   immediately after <a>swapBuffers</a> is called.
--   
--   An implicit <a>flush</a> is done by <a>swapBuffers</a> before it
--   returns. Subsequent OpenGL commands can be issued immediately after
--   calling <a>swapBuffers</a>, but are not executed until the buffer
--   exchange is completed.
--   
--   If the <i>layer in use</i> is not double buffered, <a>swapBuffers</a>
--   has no effect.
swapBuffers :: MonadIO m => m ()

-- | Controls the position of the <i>current window</i>. For top-level
--   windows, parameters of <a>Position</a> are pixel offsets from the
--   screen origin. For subwindows, the parameters are pixel offsets from
--   the window's parent window origin.
--   
--   In the case of top-level windows, setting <a>windowPosition</a> is
--   considered only a request for positioning the window. The window
--   system is free to apply its own policies to top-level window
--   placement. The intent is that top-level windows should be repositioned
--   according to the value of <a>windowPosition</a>.
windowPosition :: StateVar Position

-- | Controls the size of the <i>current window</i>. The parameters of
--   <a>Size</a> are size extents in pixels. The width and height must be
--   positive values.
--   
--   In the case of top-level windows, setting <a>windowSize</a> is
--   considered only a request for sizing the window. The window system is
--   free to apply its own policies to top-level window sizing. The intent
--   is that top-level windows should be reshaped according to the value of
--   <a>windowSize</a>. Whether a reshape actually takes effect and, if so,
--   the reshaped dimensions are reported to the program by a reshape
--   callback.
windowSize :: StateVar Size

-- | Request that the <i>current window</i> be made full screen. The exact
--   semantics of what full screen means may vary by window system. The
--   intent is to make the window as large as possible and disable any
--   window decorations or borders added the window system. The window
--   width and height are not guaranteed to be the same as the screen width
--   and height, but that is the intent of making a window full screen.
--   
--   <a>fullScreen</a> is defined to work only on top-level windows.
--   
--   <i>X Implementation Notes:</i> In the X implementation of GLUT, full
--   screen is implemented by sizing and positioning the window to cover
--   the entire screen and posting the <tt>_MOTIF_WM_HINTS</tt> property on
--   the window requesting absolutely no decorations. Non-Motif window
--   managers may not respond to <tt>_MOTIF_WM_HINTS</tt>.
fullScreen :: MonadIO m => m ()

-- | (<i>freeglut only</i>) Toggle between windowed and full screen mode.
fullScreenToggle :: MonadIO m => m ()

-- | (<i>freeglut only</i>) If we are in full screen mode, resize the
--   current window back to its original size.
leaveFullScreen :: MonadIO m => m ()

-- | Change the stacking order of the <i>current window</i> relative to its
--   siblings (lowering it).
pushWindow :: MonadIO m => m ()

-- | Change the stacking order of the <i>current window</i> relative to its
--   siblings, bringing the <i>current window</i> closer to the top.
popWindow :: MonadIO m => m ()

-- | The display status of a window.
data WindowStatus
Shown :: WindowStatus
Hidden :: WindowStatus
Iconified :: WindowStatus

-- | Controls the display status of the <i>current window</i>.
--   
--   Note that the effect of showing, hiding, and iconifying windows does
--   not take place immediately. Instead the requests are saved for
--   execution upon return to the GLUT event loop. Subsequent show, hide,
--   or iconification requests on a window replace the previously saved
--   request for that window. The effect of hiding, showing, or iconifying
--   top-level windows is subject to the window system's policy for
--   displaying windows. Subwindows can't be iconified.
windowStatus :: SettableStateVar WindowStatus

-- | Controls the window title of the <i>current top-level window</i>.
windowTitle :: SettableStateVar String

-- | Controls the icon title of the <i>current top-level window</i>.
iconTitle :: SettableStateVar String

-- | The different cursor images GLUT supports.
data Cursor

-- | Arrow pointing up and to the right.
RightArrow :: Cursor

-- | Arrow pointing up and to the left.
LeftArrow :: Cursor

-- | Pointing hand.
Info :: Cursor

-- | Skull &amp; cross bones.
Destroy :: Cursor

-- | Question mark.
Help :: Cursor

-- | Arrows rotating in a circle.
Cycle :: Cursor

-- | Spray can.
Spray :: Cursor

-- | Wrist watch.
Wait :: Cursor

-- | Insertion point cursor for text.
Text :: Cursor

-- | Simple cross-hair.
Crosshair :: Cursor

-- | Bi-directional pointing up &amp; down.
UpDown :: Cursor

-- | Bi-directional pointing left &amp; right.
LeftRight :: Cursor

-- | Arrow pointing to top side.
TopSide :: Cursor

-- | Arrow pointing to bottom side.
BottomSide :: Cursor

-- | Arrow pointing to left side.
LeftSide :: Cursor

-- | Arrow pointing to right side.
RightSide :: Cursor

-- | Arrow pointing to top-left corner.
TopLeftCorner :: Cursor

-- | Arrow pointing to top-right corner.
TopRightCorner :: Cursor

-- | Arrow pointing to bottom-left corner.
BottomRightCorner :: Cursor

-- | Arrow pointing to bottom-right corner.
BottomLeftCorner :: Cursor

-- | Use parent's cursor.
Inherit :: Cursor

-- | Invisible cursor.
None :: Cursor

-- | Full-screen cross-hair cursor (if possible, otherwise
--   <a>Crosshair</a>).
FullCrosshair :: Cursor

-- | Change the cursor image of the <i>current window</i>. Each call
--   requests the window system change the cursor appropriately. The cursor
--   image when a window is created is <a>Inherit</a>. The exact cursor
--   images used are implementation dependent. The intent is for the image
--   to convey the meaning of the cursor name. For a top-level window,
--   <a>Inherit</a> uses the default window system cursor.
--   
--   <i>X Implementation Notes:</i> GLUT for X uses SGI's
--   <tt>_SGI_CROSSHAIR_CURSOR</tt> convention to access a full-screen
--   cross-hair cursor if possible.
cursor :: StateVar Cursor

-- | Setting <a>pointerPosition</a> warps the window system's pointer to a
--   new location relative to the origin of the <i>current window</i> by
--   the specified pixel offset, which may be negative. The warp is done
--   immediately.
--   
--   If the pointer would be warped outside the screen's frame buffer
--   region, the location will be clamped to the nearest screen edge. The
--   window system is allowed to further constrain the pointer's location
--   in window system dependent ways.
--   
--   Good advice from Xlib's <tt>XWarpPointer</tt> man page: "There is
--   seldom any reason for calling this function. The pointer should
--   normally be left to the user."
pointerPosition :: SettableStateVar Position
instance Eq WindowStatus
instance Ord WindowStatus
instance Show WindowStatus
instance Eq Cursor
instance Ord Cursor
instance Show Cursor


-- | GLUT maintains a considerable amount of programmer visible state. Some
--   (but not all) of this state may be directly retrieved.
module Graphics.UI.GLUT.State

-- | (<i>freeglut only</i>) Contains the thickness of the sizing border
--   around the perimeter of a window that can be resized, in pixels.
windowBorderWidth :: GettableStateVar Int

-- | (<i>freeglut only</i>) Contains the height of the header/caption area
--   of a window in pixels.
windowHeaderHeight :: GettableStateVar Int

-- | (<i>freeglut on X11 only</i>) Controls if all but the last motion
--   event should be discarded.
skipStaleMotionEvents :: StateVar Bool

-- | Contains <a>True</a> when the current layer of the <i>current
--   window</i> is in RGBA mode, <a>False</a> means color index mode.
rgba :: GettableStateVar Bool

-- | Bit depth of a buffer
type BufferDepth = Int

-- | Contains the number of red, green, blue, and alpha bits in the color
--   buffer of the <i>current window's</i> current layer (0 in color index
--   mode).
rgbaBufferDepths :: GettableStateVar (BufferDepth, BufferDepth, BufferDepth, BufferDepth)

-- | Contains the total number of bits in the color buffer of the /current
--   window's/ current layer. For an RGBA layer, this is the sum of the
--   red, green, blue, and alpha bits. For an color index layer, this is
--   the number of bits of the color indexes.
colorBufferDepth :: GettableStateVar BufferDepth

-- | Contains <a>True</a> when the current layer of the <i>current
--   window</i> is double buffered, <a>False</a> otherwise.
doubleBuffered :: GettableStateVar Bool

-- | Contains <a>True</a> when the current layer of the <i>current
--   window</i> is stereo, <a>False</a> otherwise.
stereo :: GettableStateVar Bool

-- | Contains the number of red, green, blue, and alpha bits in the
--   accumulation buffer of the <i>current window's</i> current layer (0 in
--   color index mode).
accumBufferDepths :: GettableStateVar (BufferDepth, BufferDepth, BufferDepth, BufferDepth)

-- | Contains the number of bits in the depth buffer of the <i>current
--   window's</i> current layer.
depthBufferDepth :: GettableStateVar BufferDepth

-- | Contains the number of bits in the stencil buffer of the /current
--   window's/ current layer.
stencilBufferDepth :: GettableStateVar BufferDepth

-- | Number of samples for multisampling
type SampleCount = Int

-- | Contains the number of samples for multisampling for the <i>current
--   window.</i>
sampleCount :: GettableStateVar SampleCount

-- | Contains the window system dependent format ID for the current layer
--   of the <i>current window</i>. On X11 GLUT implementations, this is the
--   X visual ID. On Win32 GLUT implementations, this is the Win32 Pixel
--   Format Descriptor number. This value is returned for debugging,
--   benchmarking, and testing ease.
formatID :: GettableStateVar Int

-- | (<i>freeglut only</i>) Contains <a>True</a> if the <i>current
--   window</i> is in full screen mode, <a>False</a> otherwise.
fullScreenMode :: StateVar Bool

-- | (<i>freeglut only</i>) Controls if vectors representing the normals
--   should be drawn, too, when objects are drawn.
geometryVisualizeNormals :: StateVar Bool

-- | (<i>freeglut only</i>) If <a>vertexAttribCoord3</a> and
--   <a>vertexAttribNormal</a> both contain <a>Nothing</a>, the fixed
--   function pipeline is used to draw objects. Otherwise VBOs are used and
--   the coordinates are passed via <a>Just</a> this attribute location
--   (for a vec3).
vertexAttribCoord3 :: SettableStateVar (Maybe AttribLocation)

-- | (<i>freeglut only</i>) If <a>vertexAttribCoord3</a> and
--   <a>vertexAttribNormal</a> both contain <a>Nothing</a>, the fixed
--   function pipeline is used to draw objects. Otherwise VBOs are used and
--   the normals are passed via <a>Just</a> this attribute location (for a
--   vec3).
vertexAttribNormal :: SettableStateVar (Maybe AttribLocation)

-- | (<i>freeglut only</i>) If VBOs are used to draw objects (controlled
--   via <a>vertexAttribCoord3</a> and <a>vertexAttribNormal</a>), the
--   texture coordinates are passed via <a>Just</a> this attribute location
--   (for a vec2).
vertexAttribTexCoord2 :: SettableStateVar (Maybe AttribLocation)

-- | Contains <a>True</a> if the given plane of the <i>current window</i>
--   has been damaged (by window system activity) since the last display
--   callback was triggered. Calling <a>postRedisplay</a> or
--   <a>postOverlayRedisplay</a> will not set this <a>True</a>.
damaged :: Layer -> GettableStateVar Bool

-- | Contains the number of milliseconds since <a>initialize</a> was
--   called.
elapsedTime :: GettableStateVar Int

-- | The size of the screen in pixels.
screenSize :: GettableStateVar Size

-- | The size of the screen in millimeters.
screenSizeMM :: GettableStateVar Size

-- | Contains <a>True</a> if a keyboard is present, <a>False</a> otherwise.
hasKeyboard :: GettableStateVar Bool

-- | Number of buttons of an input device
type ButtonCount = Int

-- | Contains <a>Just</a> the number of buttons of an attached mouse or
--   <a>Nothing</a> if there is none.
numMouseButtons :: GettableStateVar (Maybe ButtonCount)

-- | Contains <a>Just</a> the number of buttons of the attached Spaceball
--   or <a>Nothing</a> if there is none.
numSpaceballButtons :: GettableStateVar (Maybe ButtonCount)

-- | Number of dials of a dial and button box
type DialCount = Int

-- | Contains <a>Just</a> the number of dials and buttons of an attached
--   dial &amp; button box or <a>Nothing</a> if there is none.
numDialsAndButtons :: GettableStateVar (Maybe (DialCount, ButtonCount))

-- | Contains <a>Just</a> the number of buttons of an attached tablet or
--   <a>Nothing</a> if there is none.
numTabletButtons :: GettableStateVar (Maybe ButtonCount)

-- | Number of axes of a joystick
type AxisCount = Int

-- | The a rate at which a joystick is polled (in milliseconds)
type PollRate = Int

-- | Contains <a>Just</a> the number of buttons of an attached joystick,
--   the number of joystick axes, and the rate at which the joystick is
--   polled. Contains <a>Nothing</a> if there is no joystick attached.
joystickInfo :: GettableStateVar (Maybe (ButtonCount, PollRate, AxisCount))

-- | (<i>freeglut only</i>) Contains a list of the number of auxiliary
--   buffers supported, in increasing order.
supportedNumAuxBuffers :: GettableStateVar [Int]

-- | (<i>freeglut only</i>) Contains a list of the number of samples per
--   pixel supported for multisampling, in increasing order.
supportedSamplesPerPixel :: GettableStateVar [SampleCount]

-- | Contains version of GLUT in the form of <tt><i>flavour</i>
--   <i>major</i>.<i>minor</i>.<i>patchlevel</i></tt>, where
--   <tt><i>flavour</i></tt> is one of <tt>GLUT</tt>, <tt>freeglut</tt> or
--   <tt>OpenGLUT</tt>.
glutVersion :: GettableStateVar String

-- | (<i>freeglut only</i>) Contains <a>True</a> if GLUT has been
--   initialized with <a>initialize</a> or <a>getArgsAndInitialize</a> has
--   and not yet been de-initialized with <a>exit</a>. Contains
--   <a>False</a> otherwise.
initState :: GettableStateVar Bool


-- | GLUT supports simple cascading pop-up menus. They are designed to let
--   a user select various modes within a program. The functionality is
--   simple and minimalistic and is meant to be that way. Do not mistake
--   GLUT's pop-up menu facility with an attempt to create a full-featured
--   user interface.
module Graphics.UI.GLUT.Menu

-- | A menu is simply a list of menu items, possibly with an associated
--   font.
data Menu
Menu :: [MenuItem] -> Menu
MenuWithFont :: BitmapFont -> [MenuItem] -> Menu

-- | A single item within a menu can either be a plain menu entry or a
--   sub-menu entry, allowing for arbitrarily deep nested menus.
data MenuItem

-- | A plain menu entry with an associated callback, which is triggered
--   when the user selects the entry
MenuEntry :: String -> MenuCallback -> MenuItem

-- | A sub-menu, which is cascaded when the user selects the entry,
--   allowing sub-menu entries to be selected
SubMenu :: String -> Menu -> MenuItem
type MenuCallback = IO ()

-- | Create a new pop-up menu for the <i>current window,</i> attaching it
--   to the given mouse button. A previously attached menu (if any), is
--   detached before and won't receive callbacks anymore.
--   
--   It is illegal to call <a>attachMenu</a> while any (sub-)menu is in
--   use, i.e. popped up.
--   
--   <i>X Implementation Notes:</i> If available, GLUT for X will take
--   advantage of overlay planes for implementing pop-up menus. The use of
--   overlay planes can eliminate display callbacks when pop-up menus are
--   deactivated. The <tt>SERVER_OVERLAY_VISUALS</tt> convention is used to
--   determine if overlay visuals are available.
attachMenu :: MonadIO m => MouseButton -> Menu -> m ()

-- | Contains the number of menu items in the <i>current menu.</i>
numMenuItems :: GettableStateVar Int
instance Eq MenuHook
instance Ord MenuHook


module Graphics.UI.GLUT.Callbacks.Window

-- | A display callback
type DisplayCallback = IO ()

-- | Controls the display callback for the <i>current window.</i> When GLUT
--   determines that the normal plane for the window needs to be
--   redisplayed, the display callback for the window is called. Before the
--   callback, the <i>current window</i> is set to the window needing to be
--   redisplayed and (if no overlay display callback is registered) the
--   <i>layer in use</i> is set to the normal plane. The entire normal
--   plane region should be redisplayed in response to the callback (this
--   includes ancillary buffers if your program depends on their state).
--   
--   GLUT determines when the display callback should be triggered based on
--   the window's redisplay state. The redisplay state for a window can be
--   either set explicitly by calling <a>postRedisplay</a> or implicitly as
--   the result of window damage reported by the window system. Multiple
--   posted redisplays for a window are coalesced by GLUT to minimize the
--   number of display callbacks called.
--   
--   When an overlay is established for a window, but there is no overlay
--   display callback registered, the display callback is used for
--   redisplaying both the overlay and normal plane (that is, it will be
--   called if either the redisplay state or overlay redisplay state is
--   set). In this case, the <i>layer in use</i> is not implicitly changed
--   on entry to the display callback.
--   
--   See <a>overlayDisplayCallback</a> to understand how distinct callbacks
--   for the overlay and normal plane of a window may be established.
--   
--   When a window is created, no display callback exists for the window.
--   It is the responsibility of the programmer to install a display
--   callback for the window before the window is shown. A display callback
--   must be registered for any window that is shown. If a window becomes
--   displayed without a display callback being registered, a fatal error
--   occurs. There is no way to "deregister" a display callback (though
--   another callback routine can always be registered).
--   
--   Upon return from the display callback, the normal damaged state of the
--   window (see <a>damaged</a>) is cleared. If there is no overlay display
--   callback registered the overlay damaged state of the window (see
--   <a>damaged</a>) is also cleared.
displayCallback :: SettableStateVar DisplayCallback

-- | Controls the overlay display callback for the <i>current window.</i>
--   The overlay display callback is functionally the same as the window's
--   display callback except that the overlay display callback is used to
--   redisplay the window's overlay.
--   
--   When GLUT determines that the overlay plane for the window needs to be
--   redisplayed, the overlay display callback for the window is called.
--   Before the callback, the <i>current window</i> is set to the window
--   needing to be redisplayed and the <i>layer in use</i> is set to the
--   overlay. The entire overlay region should be redisplayed in response
--   to the callback (this includes ancillary buffers if your program
--   depends on their state).
--   
--   GLUT determines when the overlay display callback should be triggered
--   based on the window's overlay redisplay state. The overlay redisplay
--   state for a window can be either set explicitly by calling
--   <a>postOverlayRedisplay</a> or implicitly as the result of window
--   damage reported by the window system. Multiple posted overlay
--   redisplays for a window are coalesced by GLUT to minimize the number
--   of overlay display callbacks called.
--   
--   Upon return from the overlay display callback, the overlay damaged
--   state of the window (see <a>damaged</a>) is cleared.
--   
--   Initially there is no overlay display callback registered when an
--   overlay is established. See <a>displayCallback</a> to understand how
--   the display callback alone is used if an overlay display callback is
--   not registered.
overlayDisplayCallback :: SettableStateVar (Maybe DisplayCallback)

-- | A reshape callback
type ReshapeCallback = Size -> IO ()

-- | Controls the reshape callback for the <i>current window.</i> The
--   reshape callback is triggered when a window is reshaped. A reshape
--   callback is also triggered immediately before a window's first display
--   callback after a window is created or whenever an overlay for the
--   window is established. The parameter of the callback specifies the new
--   window size in pixels. Before the callback, the <i>current window</i>
--   is set to the window that has been reshaped.
--   
--   If a reshape callback is not registered for a window or
--   <a>reshapeCallback</a> is set to <a>Nothing</a> (to deregister a
--   previously registered callback), the default reshape callback is used.
--   This default callback will simply call
--   
--   <pre>
--   <a>viewport</a> (<a>Position</a> 0 0) (<a>Size</a> <i>width</i> <i>height</i>)
--   </pre>
--   
--   on the normal plane (and on the overlay if one exists).
--   
--   If an overlay is established for the window, a single reshape callback
--   is generated. It is the callback's responsibility to update both the
--   normal plane and overlay for the window (changing the layer in use as
--   necessary).
--   
--   When a top-level window is reshaped, subwindows are not reshaped. It
--   is up to the GLUT program to manage the size and positions of
--   subwindows within a top-level window. Still, reshape callbacks will be
--   triggered for subwindows when their size is changed using
--   <a>windowSize</a>.
reshapeCallback :: SettableStateVar (Maybe ReshapeCallback)

-- | A position callback
type PositionCallback = Position -> IO ()

-- | (<i>freeglut only</i>) Controls the position callback for the
--   <i>current window.</i> The position callback for a window is called
--   when the position of a window changes.
positionCallback :: SettableStateVar (Maybe PositionCallback)

-- | The visibility state of the <i>current window</i>
data Visibility

-- | No part of the <i>current window</i> is visible, i.e., until the
--   window's visibility changes, all further rendering to the window is
--   discarded.
NotVisible :: Visibility

-- | The <i>current window</i> is totally or partially visible. GLUT
--   considers a window visible if any pixel of the window is visible or
--   any pixel of any descendant window is visible on the screen.
Visible :: Visibility

-- | A visibility callback
type VisibilityCallback = Visibility -> IO ()

-- | Controls the visibility callback for the <i>current window.</i> The
--   visibility callback for a window is called when the visibility of a
--   window changes.
--   
--   If the visibility callback for a window is disabled and later
--   re-enabled, the visibility status of the window is undefined; any
--   change in window visibility will be reported, that is if you disable a
--   visibility callback and re-enable the callback, you are guaranteed the
--   next visibility change will be reported.
--   
--   Note that you can either use <a>visibilityCallback</a> or
--   <a>windowStateCallback</a>, but not both, because the former is
--   implemented via the latter.
visibilityCallback :: SettableStateVar (Maybe VisibilityCallback)

-- | The window state of the <i>current window</i>
data WindowState

-- | The <i>current window</i> is unmapped.
Unmapped :: WindowState

-- | The <i>current window</i> is unobscured.
FullyRetained :: WindowState

-- | The <i>current window</i> is partially obscured.
PartiallyRetained :: WindowState

-- | The <i>current window</i> is fully obscured.
FullyCovered :: WindowState

-- | A window state callback
type WindowStateCallback = WindowState -> IO ()

-- | Controls the window state callback for the <i>current window.</i> The
--   window state callback for a window is called when the window state of
--   a window changes.
--   
--   If the window state callback for a window is disabled and later
--   re-enabled, the window state state of the window is undefined; any
--   change in the window state will be reported, that is if you disable a
--   window state callback and re-enable the callback, you are guaranteed
--   the next window state change will be reported.
--   
--   Note that you can either use <a>visibilityCallback</a> or
--   <a>windowStateCallback</a>, but not both, because the former is
--   implemented via the latter.
windowStateCallback :: SettableStateVar (Maybe WindowStateCallback)

-- | A window close callback
type CloseCallback = IO ()

-- | Controls the window close callback for the <i>current window</i>.
closeCallback :: SettableStateVar (Maybe CloseCallback)

-- | An initialize context callback
type InitContextCallback = IO ()

-- | (<i>freeglut only</i>) Controls the initialize context callback for
--   the /current window/.
initContextCallback :: SettableStateVar (Maybe InitContextCallback)

-- | The application status of the <i>current window</i>
data AppStatus
AppStatusPause :: AppStatus
AppStatusResume :: AppStatus

-- | An application status callback
type AppStatusCallback = AppStatus -> IO ()

-- | Controls the application status callback for the <i>current
--   window.</i>
appStatusCallback :: SettableStateVar (Maybe AppStatusCallback)

-- | A keyboard callback
type KeyboardCallback = Char -> Position -> IO ()

-- | Controls the keyboard callback for the <i>current window</i>. This is
--   activated only when a key is pressed.
keyboardCallback :: SettableStateVar (Maybe KeyboardCallback)

-- | Controls the keyboard callback for the <i>current window</i>. This is
--   activated only when a key is released.
keyboardUpCallback :: SettableStateVar (Maybe KeyboardCallback)

-- | A special key callback
type SpecialCallback = SpecialKey -> Position -> IO ()

-- | Controls the special key callback for the <i>current window</i>. This
--   is activated only when a special key is pressed.
specialCallback :: SettableStateVar (Maybe SpecialCallback)

-- | Controls the special key callback for the <i>current window</i>. This
--   is activated only when a special key is released.
specialUpCallback :: SettableStateVar (Maybe SpecialCallback)

-- | A mouse callback
type MouseCallback = MouseButton -> KeyState -> Position -> IO ()

-- | Controls the mouse callback for the <i>current window</i>.
mouseCallback :: SettableStateVar (Maybe MouseCallback)

-- | A generalized view of keys
data Key
Char :: Char -> Key
SpecialKey :: SpecialKey -> Key
MouseButton :: MouseButton -> Key

-- | Special keys
data SpecialKey
KeyF1 :: SpecialKey
KeyF2 :: SpecialKey
KeyF3 :: SpecialKey
KeyF4 :: SpecialKey
KeyF5 :: SpecialKey
KeyF6 :: SpecialKey
KeyF7 :: SpecialKey
KeyF8 :: SpecialKey
KeyF9 :: SpecialKey
KeyF10 :: SpecialKey
KeyF11 :: SpecialKey
KeyF12 :: SpecialKey
KeyLeft :: SpecialKey
KeyUp :: SpecialKey
KeyRight :: SpecialKey
KeyDown :: SpecialKey
KeyPageUp :: SpecialKey
KeyPageDown :: SpecialKey
KeyHome :: SpecialKey
KeyEnd :: SpecialKey
KeyInsert :: SpecialKey
KeyNumLock :: SpecialKey
KeyBegin :: SpecialKey
KeyDelete :: SpecialKey
KeyShiftL :: SpecialKey
KeyShiftR :: SpecialKey
KeyCtrlL :: SpecialKey
KeyCtrlR :: SpecialKey
KeyAltL :: SpecialKey
KeyAltR :: SpecialKey

-- | You should actually never encounter this value, it is just here as a
--   safeguard against future changes in the native GLUT library.
KeyUnknown :: Int -> SpecialKey

-- | Mouse buttons, including a wheel
data MouseButton
LeftButton :: MouseButton
MiddleButton :: MouseButton
RightButton :: MouseButton
WheelUp :: MouseButton
WheelDown :: MouseButton
AdditionalButton :: Int -> MouseButton

-- | The current state of a key or button
data KeyState
Down :: KeyState
Up :: KeyState

-- | The state of the keyboard modifiers
data Modifiers
Modifiers :: KeyState -> KeyState -> KeyState -> Modifiers
shift :: Modifiers -> KeyState
ctrl :: Modifiers -> KeyState
alt :: Modifiers -> KeyState

-- | A keyboard/mouse callback
type KeyboardMouseCallback = Key -> KeyState -> Modifiers -> Position -> IO ()

-- | Controls the keyboard/mouse callback for the <i>current window.</i>
--   The keyboard/mouse callback for a window is called when the state of a
--   key or mouse button changes. The callback parameters indicate the new
--   state of the key/button, the state of the keyboard modifiers, and the
--   mouse location in window relative coordinates.
--   
--   Note that this is a convenience function that should not ordinarily be
--   used in conjunction with <a>keyboardCallback</a>,
--   <a>keyboardUpCallback</a>, <a>specialCallback</a>,
--   <a>specialUpCallback</a>, or <a>mouseCallback</a>.
keyboardMouseCallback :: SettableStateVar (Maybe KeyboardMouseCallback)
type WheelNumber = Int
type WheelDirection = Int
type MouseWheelCallback = WheelNumber -> WheelDirection -> Position -> IO ()

-- | (<i>freeglut only</i>) Controls the mouse wheel callback for the
--   <i>current window.</i> The mouse wheel callback for a window is called
--   when a mouse wheel is used and the wheel number is greater than or
--   equal to <a>numMouseButtons</a>.
mouseWheelCallback :: SettableStateVar (Maybe MouseWheelCallback)

-- | A motion callback
type MotionCallback = Position -> IO ()

-- | Controls the motion callback for the <i>current window.</i> The motion
--   callback for a window is called when the mouse moves within the window
--   while one or more mouse buttons are pressed. The callback parameter
--   indicates the mouse location in window relative coordinates.
motionCallback :: SettableStateVar (Maybe MotionCallback)

-- | Controls the passive motion callback for the <i>current window.</i>
--   The passive motion callback for a window is called when the mouse
--   moves within the window while <i>no</i> mouse buttons are pressed. The
--   callback parameter indicates the mouse location in window relative
--   coordinates.
passiveMotionCallback :: SettableStateVar (Maybe MotionCallback)

-- | The relation between the mouse pointer and the <i>current window</i>
--   has changed.
data Crossing

-- | The mouse pointer has left the <i>current window.</i>
WindowLeft :: Crossing

-- | The mouse pointer has entered the <i>current window.</i>
WindowEntered :: Crossing

-- | An enter/leave callback
type CrossingCallback = Crossing -> IO ()

-- | Controls the mouse enter/leave callback for the <i>current window.</i>
--   Note that some window systems may not generate accurate enter/leave
--   callbacks.
--   
--   <i>X Implementation Notes:</i> An X implementation of GLUT should
--   generate accurate enter/leave callbacks.
crossingCallback :: SettableStateVar (Maybe CrossingCallback)

-- | Translation of the Spaceball along one axis, normalized to be in the
--   range of -1000 to +1000 inclusive
type SpaceballMotion = Int

-- | Rotation of the Spaceball along one axis, normalized to be in the
--   range of -1800 .. +1800 inclusive
type SpaceballRotation = Int

-- | The index of a specific buttons of an input device.
type ButtonIndex = Int

-- | The state of the Spaceball has changed.
data SpaceballInput
SpaceballMotion :: SpaceballMotion -> SpaceballMotion -> SpaceballMotion -> SpaceballInput
SpaceballRotation :: SpaceballRotation -> SpaceballRotation -> SpaceballRotation -> SpaceballInput
SpaceballButton :: ButtonIndex -> KeyState -> SpaceballInput

-- | A SpaceballButton callback
type SpaceballCallback = SpaceballInput -> IO ()

-- | Controls the Spaceball callback for the <i>current window.</i> The
--   Spaceball callback for a window is called when the window has
--   Spaceball input focus (normally, when the mouse is in the window) and
--   the user generates Spaceball translations, rotations, or button
--   presses. The number of available Spaceball buttons can be determined
--   with <a>numSpaceballButtons</a>.
--   
--   Registering a Spaceball callback when a Spaceball device is not
--   available has no effect and is not an error. In this case, no
--   Spaceball callbacks will be generated.
spaceballCallback :: SettableStateVar (Maybe SpaceballCallback)

-- | The dial &amp; button box state has changed.
data DialAndButtonBoxInput
DialAndButtonBoxButton :: ButtonIndex -> KeyState -> DialAndButtonBoxInput
DialAndButtonBoxDial :: DialIndex -> Int -> DialAndButtonBoxInput

-- | The index of a specific dial of a dial and button box.
type DialIndex = Int

-- | A dial &amp; button box callback
type DialAndButtonBoxCallback = DialAndButtonBoxInput -> IO ()

-- | Controls the dial &amp; button box callback for the <i>current
--   window.</i> The dial &amp; button box button callback for a window is
--   called when the window has dial &amp; button box input focus
--   (normally, when the mouse is in the window) and the user generates
--   dial &amp; button box button presses or dial changes. The number of
--   available dial &amp; button box buttons and dials can be determined
--   with <a>numDialsAndButtons</a>.
--   
--   Registering a dial &amp; button box callback when a dial &amp; button
--   box device is not available is ineffectual and not an error. In this
--   case, no dial &amp; button box button will be generated.
dialAndButtonBoxCallback :: SettableStateVar (Maybe DialAndButtonBoxCallback)

-- | Absolute tablet position, with coordinates normalized to be in the
--   range of 0 to 2000 inclusive
data TabletPosition
TabletPosition :: Int -> Int -> TabletPosition

-- | The table state has changed.
data TabletInput
TabletMotion :: TabletInput
TabletButton :: ButtonIndex -> KeyState -> TabletInput

-- | A tablet callback
type TabletCallback = TabletInput -> TabletPosition -> IO ()

-- | Controls the tablet callback for the <i>current window.</i> The tablet
--   callback for a window is called when the window has tablet input focus
--   (normally, when the mouse is in the window) and the user generates
--   tablet motion or button presses. The number of available tablet
--   buttons can be determined with <a>numTabletButtons</a>.
--   
--   Registering a tablet callback when a tablet device is not available is
--   ineffectual and not an error. In this case, no tablet callbacks will
--   be generated.
tabletCallback :: SettableStateVar (Maybe TabletCallback)

-- | The state of the joystick buttons
data JoystickButtons
JoystickButtons :: KeyState -> KeyState -> KeyState -> KeyState -> JoystickButtons
joystickButtonA :: JoystickButtons -> KeyState
joystickButtonB :: JoystickButtons -> KeyState
joystickButtonC :: JoystickButtons -> KeyState
joystickButtonD :: JoystickButtons -> KeyState

-- | Absolute joystick position, with coordinates normalized to be in the
--   range of -1000 to 1000 inclusive. The signs of the three axes mean the
--   following:
--   
--   <ul>
--   <li>negative = left, positive = right</li>
--   <li>negative = towards player, positive = away</li>
--   <li>if available (e.g. rudder): negative = down, positive = up</li>
--   </ul>
data JoystickPosition
JoystickPosition :: Int -> Int -> Int -> JoystickPosition

-- | A joystick callback
type JoystickCallback = JoystickButtons -> JoystickPosition -> IO ()

-- | Controls the joystick callback for the <i>current window.</i> The
--   joystick callback is called either due to polling of the joystick at
--   the uniform timer interval specified (if &gt; 0) or in response to an
--   explicit call of <a>forceJoystickCallback</a>.
--   
--   <i>X Implementation Notes:</i> Currently GLUT has no joystick support
--   for X11.
joystickCallback :: SettableStateVar (Maybe (JoystickCallback, PollRate))

-- | A description where the multi-touch event is coming from, the freeglut
--   specs are very vague about the actual semantics. It contains the
--   device ID and/or the cursor/finger ID.
type TouchID = Int

-- | A multi-touch variant of <a>MouseCallback</a>.
type MultiMouseCallback = TouchID -> MouseCallback

-- | (<i>freeglut only</i>) A multi-touch variant of <a>mouseCallback</a>.
multiMouseCallback :: SettableStateVar (Maybe MultiMouseCallback)

-- | A multi-touch variant of <a>CrossingCallback</a>.
type MultiCrossingCallback = TouchID -> CrossingCallback

-- | (<i>freeglut only</i>) A multi-touch variant of
--   <a>crossingCallback</a>.
multiCrossingCallback :: SettableStateVar (Maybe MultiCrossingCallback)

-- | A multi-touch variant of <a>MotionCallback</a>.
type MultiMotionCallback = TouchID -> MotionCallback

-- | (<i>freeglut only</i>) A multi-touch variant of <a>motionCallback</a>.
multiMotionCallback :: SettableStateVar (Maybe MultiMotionCallback)

-- | (<i>freeglut only</i>) A multi-touch variant of
--   <a>passiveMotionCallback</a>.
multiPassiveMotionCallback :: SettableStateVar (Maybe MultiMotionCallback)
instance Eq Visibility
instance Ord Visibility
instance Show Visibility
instance Eq WindowState
instance Ord WindowState
instance Show WindowState
instance Eq AppStatus
instance Ord AppStatus
instance Show AppStatus
instance Eq SpecialKey
instance Ord SpecialKey
instance Show SpecialKey
instance Eq KeyState
instance Ord KeyState
instance Show KeyState
instance Eq Modifiers
instance Ord Modifiers
instance Show Modifiers
instance Eq Key
instance Ord Key
instance Show Key
instance Eq Crossing
instance Ord Crossing
instance Show Crossing
instance Eq SpaceballInput
instance Ord SpaceballInput
instance Show SpaceballInput
instance Eq DialAndButtonBoxInput
instance Ord DialAndButtonBoxInput
instance Show DialAndButtonBoxInput
instance Eq TabletPosition
instance Ord TabletPosition
instance Show TabletPosition
instance Eq TabletInput
instance Ord TabletInput
instance Show TabletInput
instance Eq JoystickButtons
instance Ord JoystickButtons
instance Show JoystickButtons
instance Eq JoystickPosition
instance Ord JoystickPosition
instance Show JoystickPosition


module Graphics.UI.GLUT.Callbacks.Global
data MenuUsage
NotInUse :: MenuUsage
InUse :: MenuUsage
type MenuStatusCallback = MenuUsage -> Position -> IO ()

-- | Controls the global menu status callback so a GLUT program can
--   determine when a menu is in use or not. When a menu status callback is
--   registered, it will be called with the value <a>InUse</a> when pop-up
--   menus are in use by the user; and the callback will be called with the
--   value <a>NotInUse</a> when pop-up menus are no longer in use.
--   Additionally, the location in window coordinates of the button press
--   that caused the menu to go into use, or the location where the menu
--   was released (maybe outside the window). Other callbacks continue to
--   operate (except mouse motion callbacks) when pop-up menus are in use
--   so the menu status callback allows a program to suspend animation or
--   other tasks when menus are in use. The cascading and unmapping of
--   sub-menus from an initial pop-up menu does not generate menu status
--   callbacks. There is a single menu status callback for GLUT.
--   
--   When the menu status callback is called, the <i>current menu</i> will
--   be set to the initial pop-up menu in both the <a>InUse</a> and
--   <a>NotInUse</a> cases. The <i>current window</i> will be set to the
--   window from which the initial menu was popped up from, also in both
--   cases.
menuStatusCallback :: SettableStateVar (Maybe MenuStatusCallback)
type IdleCallback = IO ()

-- | Controls the global idle callback so a GLUT program can perform
--   background processing tasks or continuous animation when window system
--   events are not being received. If enabled, the idle callback is
--   continuously called when events are not being received. The <i>current
--   window</i> and <i>current menu</i> will not be changed before the idle
--   callback. Programs with multiple windows and/or menus should
--   explicitly set the <i>current window</i> and/or /current menu/ and not
--   rely on its current setting.
--   
--   The amount of computation and rendering done in an idle callback
--   should be minimized to avoid affecting the program's interactive
--   response. In general, not more than a single frame of rendering should
--   be done in an idle callback.
idleCallback :: SettableStateVar (Maybe IdleCallback)

-- | Timeout for the timer callback in milliseconds
type Timeout = Int
type TimerCallback = IO ()

-- | Register a one-shot timer callback to be triggered after at least the
--   given amount of time. Multiple timer callbacks at same or differing
--   times may be registered simultaneously. There is no support for
--   canceling a registered callback.
--   
--   The number of milliseconds is a lower bound on the time before the
--   callback is generated. GLUT attempts to deliver the timer callback as
--   soon as possible after the expiration of the callback's time interval.
addTimerCallback :: Timeout -> TimerCallback -> IO ()
instance Eq MenuUsage
instance Ord MenuUsage
instance Show MenuUsage


-- | GLUT supports a number of callbacks to respond to events. There are
--   three types of callbacks: window, menu, and global. Window callbacks
--   indicate when to redisplay or reshape a window, when the visibility of
--   the window changes, and when input is available for the window. Menu
--   callbacks are described in <a>Graphics.UI.GLUT.Menu</a>. The global
--   callbacks manage the passing of time and menu usage. The calling order
--   of callbacks between different windows is undefined.
--   
--   Callbacks for input events should be delivered to the window the event
--   occurs in. Events should not propagate to parent windows.
--   
--   A callback of type <tt>Foo</tt> can registered by setting
--   <tt>fooCallback</tt> to <a>Just</a> the callback. Almost all callbacks
--   can be de-registered by setting the corresponding <tt>fooCallback</tt>
--   to <a>Nothing</a>, the only exceptions being <a>DisplayCallback</a>
--   (can only be re-registered) and <a>TimerCallback</a> (can't be
--   unregistered).
--   
--   <i>X Implementation Notes:</i> The X GLUT implementation uses the X
--   Input extension to support sophisticated input devices: Spaceball,
--   dial &amp; button box, and digitizing tablet. Because the X Input
--   extension does not mandate how particular types of devices are
--   advertised through the extension, it is possible GLUT for X may not
--   correctly support input devices that would otherwise be of the correct
--   type. The X GLUT implementation will support the Silicon Graphics
--   Spaceball, dial &amp; button box, and digitizing tablet as advertised
--   through the X Input extension.
module Graphics.UI.GLUT.Callbacks


-- | After a GLUT program has done initial setup such as creating windows
--   and menus, GLUT programs enter the GLUT event processing loop by
--   calling <a>mainLoop</a> or handle events iteratively with
--   <a>mainLoopEvent</a>.
module Graphics.UI.GLUT.Begin

-- | Enter the GLUT event processing loop; it will call as necessary any
--   callbacks that have been registered. This routine should be called at
--   most once in a GLUT program.
mainLoop :: MonadIO m => m ()

-- | (<i>freeglut only</i>) Process one iteration's worth of events in its
--   event loop. This allows the application to control its own event loop
--   and still use the GLUT package.
mainLoopEvent :: MonadIO m => m ()

-- | (<i>freeglut only</i>) Stop the event loop. If
--   <a>actionOnWindowClose</a> contains <a>Exit</a>, the application will
--   exit; otherwise control will return to the function which called
--   <a>mainLoop</a>.
--   
--   If the application has two nested calls to <a>mainLoop</a> and calls
--   <a>leaveMainLoop</a>, the behaviour is undefined. It may leave only
--   the inner nested loop or it may leave both loops. If the reader has a
--   strong preference for one behaviour over the other he should contact
--   the freeglut Programming Consortium and ask for the code to be fixed.
leaveMainLoop :: MonadIO m => m ()

-- | The behaviour when the user closes a window.
data ActionOnWindowClose

-- | Exit the whole program when any window is closed or
--   <a>leaveMainLoop</a> is called (default).
Exit :: ActionOnWindowClose

-- | Return from mainLoop when any window is closed.
MainLoopReturns :: ActionOnWindowClose

-- | Return from mainLoop after the last window is closed.
ContinueExecution :: ActionOnWindowClose

-- | (<i>freeglut only</i>) Controls the behaviour when the user closes a
--   window.
actionOnWindowClose :: StateVar ActionOnWindowClose
instance Eq ActionOnWindowClose
instance Ord ActionOnWindowClose
instance Show ActionOnWindowClose


-- | Actions and state variables in this module are used to initialize GLUT
--   state. The primary initialization routine is <a>initialize</a>, which
--   should only be called exactly once in a GLUT program. No other GLUT or
--   OpenGL actions should be called before <a>initialize</a>, apart from
--   getting or setting the state variables in this module.
--   
--   The reason is that these state variables can be used to set default
--   window initialization state that might be modified by the command
--   processing done in <a>initialize</a>. For example,
--   <a>initialWindowSize</a> can be set to <tt>(<a>Size</a> 400 400)</tt>
--   before <a>initialize</a> is called to indicate 400 by 400 is the
--   program's default window size. Setting the initial window size or
--   position before <a>initialize</a> allows the GLUT program user to
--   specify the initial size or position using command line arguments.
module Graphics.UI.GLUT.Initialization

-- | Given the program name and command line arguments, initialize the GLUT
--   library and negotiate a session with the window system. During this
--   process, <a>initialize</a> may cause the termination of the GLUT
--   program with an error message to the user if GLUT cannot be properly
--   initialized. Examples of this situation include the failure to connect
--   to the window system, the lack of window system support for OpenGL,
--   and invalid command line options.
--   
--   <a>initialize</a> also processes command line options, but the
--   specific options parsed are window system dependent. Any command line
--   arguments which are not GLUT-specific are returned.
--   
--   <i>X Implementation Notes:</i> The X Window System specific options
--   parsed by <a>initialize</a> are as follows:
--   
--   <ul>
--   <li><tt>-display <i>DISPLAY</i></tt>: Specify the X server to connect
--   to. If not specified, the value of the <tt>DISPLAY</tt> environment
--   variable is used.</li>
--   <li><tt>-geometry <i>WxH+X+Y</i></tt>: Determines where windows should
--   be created on the screen. The parameter following <tt>-geometry</tt>
--   should be formatted as a standard X geometry specification. The effect
--   of using this option is to change the GLUT initial size and initial
--   position the same as if <a>initialWindowSize</a> or
--   <a>initialWindowPosition</a> were modified directly.</li>
--   <li><tt>-iconic</tt>: Requests all top-level windows be created in an
--   iconic state.</li>
--   <li><tt>-indirect</tt>: Force the use of indirect OpenGL rendering
--   contexts.</li>
--   <li><tt>-direct</tt>: Force the use of direct OpenGL rendering
--   contexts (not all GLX implementations support direct rendering
--   contexts). A fatal error is generated if direct rendering is not
--   supported by the OpenGL implementation. If neither <tt>-indirect</tt>
--   or <tt>-direct</tt> are used to force a particular behavior, GLUT will
--   attempt to use direct rendering if possible and otherwise fallback to
--   indirect rendering.</li>
--   <li><tt>-gldebug</tt>: After processing callbacks and/or events, call
--   <a>reportErrors</a> to check if there are any pending OpenGL errors.
--   Using this option is helpful in detecting OpenGL run-time errors.</li>
--   <li><tt>-sync</tt>: Enable synchronous X protocol transactions. This
--   option makes it easier to track down potential X protocol errors.</li>
--   </ul>
initialize :: MonadIO m => String -> [String] -> m [String]

-- | Convenience action: Initialize GLUT, returning the program name and
--   any non-GLUT command line arguments.
getArgsAndInitialize :: MonadIO m => m (String, [String])

-- | (<i>freeglut only</i>) De-initialize GLUT. After this, one has to use
--   <a>initialize</a> or <a>getArgsAndInitialize</a> to initialize GLUT
--   again.
exit :: MonadIO m => m ()

-- | Controls the <i>initial window position</i>. Windows created by
--   <a>createWindow</a> will be requested to be created with the current
--   <i>initial window position</i>. The initial value of the /initial
--   window position/ GLUT state is <tt><a>Position</a> (-1) (-1)</tt>. If
--   either the X or Y component of the <i>initial window position</i> is
--   negative, the actual window position is left to the window system to
--   determine.
--   
--   The intent of the <i>initial window position</i> is to provide a
--   suggestion to the window system for a window's initial position. The
--   window system is not obligated to use this information. Therefore,
--   GLUT programs should not assume the window was created at the
--   specified position.
initialWindowPosition :: StateVar Position

-- | Controls the <i>initial window size</i>. Windows created by
--   <a>createWindow</a> will be requested to be created with the current
--   <i>initial window size</i>. The initial value of the /initial window
--   size/ GLUT state is <tt><a>Size</a> 300 300</tt>. If either the width
--   or the height component of the <i>initial window size</i> is
--   non-positive, the actual window size is left to the window system to
--   determine.
--   
--   The intent of the <i>initial window size</i> is to provide a
--   suggestion to the window system for a window's initial size. The
--   window system is not obligated to use this information. Therefore,
--   GLUT programs should not assume the window was created at the
--   specified size. A GLUT program should use the window's reshape
--   callback to determine the true size of the window.
initialWindowSize :: StateVar Size

-- | A single aspect of a window which is to be created, used in
--   conjunction with <a>initialDisplayMode</a>.
data DisplayMode

-- | Select an RGBA mode window. This is the default if neither
--   <a>RGBAMode</a> nor <a>IndexMode</a> are specified.
RGBAMode :: DisplayMode

-- | An alias for <a>RGBAMode</a>.
RGBMode :: DisplayMode

-- | Select a color index mode window. This overrides <a>RGBAMode</a> if it
--   is also specified.
IndexMode :: DisplayMode

-- | Select a window with a "luminance" color model. This model provides
--   the functionality of OpenGL's RGBA color model, but the green and blue
--   components are not maintained in the frame buffer. Instead each
--   pixel's red component is converted to an index between zero and
--   <a>numColorMapEntries</a> and looked up in a per-window color map to
--   determine the color of pixels within the window. The initial colormap
--   of <a>LuminanceMode</a> windows is initialized to be a linear gray
--   ramp, but can be modified with GLUT's colormap actions.
--   <i>Implementation Notes:</i> <a>LuminanceMode</a> is not supported on
--   most OpenGL platforms.
LuminanceMode :: DisplayMode

-- | Select a window with an alpha component to the color buffer(s).
WithAlphaComponent :: DisplayMode

-- | Select a window with an accumulation buffer.
WithAccumBuffer :: DisplayMode

-- | Select a window with a depth buffer.
WithDepthBuffer :: DisplayMode

-- | Select a window with a stencil buffer.
WithStencilBuffer :: DisplayMode

-- | (<i>freeglut only</i>) Select a window with <i>n</i> (1 .. 4)
--   auxiliary buffers. Any <i>n</i> outside the range 1 .. 4 is a fatal
--   error.
WithAuxBuffers :: Int -> DisplayMode

-- | Select a single buffered window. This is the default if neither
--   <a>DoubleBuffered</a> nor <a>SingleBuffered</a> are specified.
SingleBuffered :: DisplayMode

-- | Select a double buffered window. This overrides <a>SingleBuffered</a>
--   if it is also specified.
DoubleBuffered :: DisplayMode

-- | Select a window with multisampling support. If multisampling is not
--   available, a non-multisampling window will automatically be chosen.
--   Note: both the OpenGL client-side and server-side implementations must
--   support the <tt>GLX_SAMPLE_SGIS</tt> extension for multisampling to be
--   available. Deprecated, use <a>WithSamplesPerPixel</a>.
Multisampling :: DisplayMode

-- | Select a window with multisampling, using the given samples per pixel.
WithSamplesPerPixel :: Int -> DisplayMode

-- | Select a stereo window.
Stereoscopic :: DisplayMode

-- | Select a window without a caption (<i>freeglut only</i>).
Captionless :: DisplayMode

-- | Select a window without any borders (<i>freeglut only</i>).
Borderless :: DisplayMode

-- | Select an sRGB mode window (<i>freeglut only</i>).
SRGBMode :: DisplayMode

-- | Controls the <i>initial display mode</i> used when creating top-level
--   windows, subwindows, and overlays to determine the OpenGL display mode
--   for the to-be-created window or overlay.
--   
--   Note that <a>RGBAMode</a> selects the RGBA color model, but it does
--   not request any bits of alpha (sometimes called an <i>alpha buffer</i>
--   or <i>destination alpha</i>) be allocated. To request alpha, specify
--   <a>WithAlphaComponent</a>. The same applies to <a>LuminanceMode</a>.
initialDisplayMode :: StateVar [DisplayMode]

-- | Contains <a>True</a> if the <i>current display mode</i> is supported,
--   <a>False</a> otherwise.
displayModePossible :: GettableStateVar Bool

-- | Capabilities for <a>initialDisplayCapabilities</a>, most of them are
--   extensions of the constructors of <a>DisplayMode</a>.
data DisplayCapability

-- | Number of bits of red, green, blue, and alpha in the RGBA color
--   buffer. Default is "<a>IsAtLeast</a> <tt>1</tt>" for red, green, blue,
--   and alpha capabilities, and "<a>IsEqualTo</a> <tt>1</tt>" for the RGBA
--   color model capability.
DisplayRGBA :: DisplayCapability

-- | Number of bits of red, green, and blue in the RGBA color buffer and
--   zero bits of alpha color buffer precision. Default is
--   "<a>IsAtLeast</a> <tt>1</tt>" for the red, green, and blue
--   capabilities, and "<a>IsNotLessThan</a> <tt>0</tt>" for alpha
--   capability, and "<a>IsEqualTo</a> <tt>1</tt>" for the RGBA color model
--   capability.
DisplayRGB :: DisplayCapability

-- | Red color buffer precision in bits. Default is "<a>IsAtLeast</a>
--   <tt>1</tt>".
DisplayRed :: DisplayCapability

-- | Green color buffer precision in bits. Default is "<a>IsAtLeast</a>
--   <tt>1</tt>".
DisplayGreen :: DisplayCapability

-- | Blue color buffer precision in bits. Default is "<a>IsAtLeast</a>
--   <tt>1</tt>".
DisplayBlue :: DisplayCapability

-- | Boolean if the color model is color index or not. True is color index.
--   Default is "<a>IsAtLeast</a> <tt>1</tt>".
DisplayIndex :: DisplayCapability

-- | Number of bits in the color index color buffer. Default is
--   "<a>IsAtLeast</a> <tt>1</tt>".
DisplayBuffer :: DisplayCapability

-- | Boolean indicate the color buffer is single buffered. Default is
--   "<a>IsEqualTo</a> <tt>1</tt>".
DisplaySingle :: DisplayCapability

-- | Boolean indicating if the color buffer is double buffered. Default is
--   "<a>IsEqualTo</a> <tt>1</tt>".
DisplayDouble :: DisplayCapability

-- | Red, green, blue, and alpha accumulation buffer precision in bits.
--   Default is "<a>IsAtLeast</a> <tt>1</tt>" for red, green, blue, and
--   alpha capabilities.
DisplayAccA :: DisplayCapability

-- | Red, green, and green accumulation buffer precision in bits and zero
--   bits of alpha accumulation buffer precision. Default is
--   "<a>IsAtLeast</a> <tt>1</tt>" for red, green, and blue capabilities,
--   and "<a>IsNotLessThan</a> <tt>0</tt>" for the alpha capability.
DisplayAcc :: DisplayCapability

-- | Alpha color buffer precision in bits. Default is "<a>IsAtLeast</a>
--   <tt>1</tt>".
DisplayAlpha :: DisplayCapability

-- | Number of bits of precsion in the depth buffer. Default is
--   "<a>IsAtLeast</a> <tt>12</tt>".
DisplayDepth :: DisplayCapability

-- | Number of bits in the stencil buffer. Default is "<a>IsNotLessThan</a>
--   <tt>1</tt>".
DisplayStencil :: DisplayCapability

-- | Indicates the number of multisamples to use based on GLX's
--   <tt>SGIS_multisample</tt> extension (for antialiasing). Default is
--   "<a>IsNotGreaterThan</a> <tt>4</tt>". This default means that a GLUT
--   application can request multisampling if available by simply
--   specifying "<a>With</a> <a>DisplaySamples</a>".
DisplaySamples :: DisplayCapability

-- | Boolean indicating the color buffer is supports OpenGL-style stereo.
--   Default is "<a>IsEqualTo</a> <tt>1</tt>".
DisplayStereo :: DisplayCapability

-- | Number of bits of red in the RGBA and zero bits of green, blue (alpha
--   not specified) of color buffer precision. Default is "<a>IsAtLeast</a>
--   <tt>1</tt>" for the red capabilitis, and "<a>IsEqualTo</a> <tt>0</tt>"
--   for the green and blue capabilities, and "<a>IsEqualTo</a> <tt>1</tt>"
--   for the RGBA color model capability, and, for X11, "<a>IsEqualTo</a>
--   <tt>1</tt>" for the <a>DisplayXStaticGray</a> capability. SGI
--   InfiniteReality (and other future machines) support a 16-bit luminance
--   (single channel) display mode (an additional 16-bit alpha channel can
--   also be requested). The red channel maps to gray scale and green and
--   blue channels are not available. A 16-bit precision luminance display
--   mode is often appropriate for medical imaging applications. Do not
--   expect many machines to support extended precision luminance display
--   modes.
DisplayLuminance :: DisplayCapability

-- | (<i>freeglut only</i>) Number of auxiliary buffers. Default is
--   "<a>IsEqualTo</a> <tt>1</tt>".
DisplayAux :: DisplayCapability

-- | A special capability name indicating where the value represents the
--   Nth frame buffer configuration matching the description string. When
--   not specified, <a>initialDisplayCapabilities</a> also uses the first
--   (best matching) configuration. <a>Num</a> requires a relation and
--   numeric value.
DisplayNum :: DisplayCapability

-- | Boolean indicating if the frame buffer configuration is conformant or
--   not. Conformance information is based on GLX's
--   <tt>EXT_visual_rating</tt> extension if supported. If the extension is
--   not supported, all visuals are assumed conformant. Default is
--   "<a>IsEqualTo</a> <tt>1</tt>".
DisplayConformant :: DisplayCapability

-- | Boolean indicating if the frame buffer configuration is slow or not.
--   Slowness information is based on GLX's <tt>EXT_visual_rating</tt>
--   extension if supported. If the extension is not supported, all visuals
--   are assumed fast. Note that slowness is a relative designation
--   relative to other frame buffer configurations available. The intent of
--   the slow capability is to help programs avoid frame buffer
--   configurations that are slower (but perhaps higher precision) for the
--   current machine. Default is "<a>IsAtLeast</a> <tt>0</tt>". This
--   default means that slow visuals are used in preference to fast
--   visuals, but fast visuals will still be allowed.
DisplaySlow :: DisplayCapability

-- | Only recognized on GLUT implementations for Win32, this capability
--   name matches the Win32 Pixel Format Descriptor by number.
--   <a>DisplayWin32PFD</a> can only be used with <a>Where</a>.
DisplayWin32PFD :: DisplayCapability

-- | Only recongized on GLUT implementations for the X Window System, this
--   capability name matches the X visual ID by number.
--   <a>DisplayXVisual</a> requires a relation and numeric value.
DisplayXVisual :: DisplayCapability

-- | Only recongized on GLUT implementations for the X Window System,
--   boolean indicating if the frame buffer configuration's X visual is of
--   type <tt>StaticGray</tt>. Default is "<a>IsEqualTo</a> <tt>1</tt>".
DisplayXStaticGray :: DisplayCapability

-- | Only recongized on GLUT implementations for the X Window System,
--   boolean indicating if the frame buffer configuration's X visual is of
--   type <tt>GrayScale</tt>. Default is "<a>IsEqualTo</a> <tt>1</tt>".
DisplayXGrayScale :: DisplayCapability

-- | Only recongized on GLUT implementations for the X Window System,
--   boolean indicating if the frame buffer configuration's X visual is of
--   type <tt>StaticColor</tt>. Default is "<a>IsEqualTo</a> <tt>1</tt>".
DisplayXStaticColor :: DisplayCapability

-- | Only recongized on GLUT implementations for the X Window System,
--   boolean indicating if the frame buffer configuration's X visual is of
--   type <tt>PsuedoColor</tt>. Default is "<a>IsEqualTo</a> <tt>1</tt>".
DisplayXPseudoColor :: DisplayCapability

-- | Only recongized on GLUT implementations for the X Window System,
--   boolean indicating if the frame buffer configuration's X visual is of
--   type <tt>TrueColor</tt>. Default is "<a>IsEqualTo</a> <tt>1</tt>".
DisplayXTrueColor :: DisplayCapability

-- | Only recongized on GLUT implementations for the X Window System,
--   boolean indicating if the frame buffer configuration's X visual is of
--   type <tt>DirectColor</tt>. Default is "<a>IsEqualTo</a> <tt>1</tt>".
DisplayXDirectColor :: DisplayCapability

-- | A relation between a <a>DisplayCapability</a> and a numeric value.
data Relation

-- | Equal.
IsEqualTo :: Relation

-- | Not equal.
IsNotEqualTo :: Relation

-- | Less than and preferring larger difference (the least is best).
IsLessThan :: Relation

-- | Less than or equal and preferring larger difference (the least is
--   best).
IsNotGreaterThan :: Relation

-- | Greater than and preferring larger differences (the most is best).
IsGreaterThan :: Relation

-- | Greater than or equal and preferring more instead of less. This
--   relation is useful for allocating resources like color precision or
--   depth buffer precision where the maximum precision is generally
--   preferred. Contrast with <a>IsNotLessThan</a> relation.
IsAtLeast :: Relation

-- | Greater than or equal but preferring less instead of more. This
--   relation is useful for allocating resources such as stencil bits or
--   auxillary color buffers where you would rather not over-allocate.
IsNotLessThan :: Relation

-- | A single capability description for <a>initialDisplayCapabilities</a>.
data DisplayCapabilityDescription

-- | A description of a capability with a specific relation to a numeric
--   value.
Where :: DisplayCapability -> Relation -> Int -> DisplayCapabilityDescription

-- | When the relation and numeric value are not specified, each capability
--   has a different default, see the different constructors of
--   <a>DisplayCapability</a>.
With :: DisplayCapability -> DisplayCapabilityDescription

-- | Controls the <i>initial display mode</i> used when creating top-level
--   windows, subwindows, and overlays to determine the OpenGL display mode
--   for the to-be-created window or overlay. It is described by a list of
--   zero or more capability descriptions, which are translated into a set
--   of criteria used to select the appropriate frame buffer configuration.
--   The criteria are matched in strict left to right order of precdence.
--   That is, the first specified criterion (leftmost) takes precedence
--   over the later criteria for non-exact criteria (<a>IsGreaterThan</a>,
--   <a>IsLessThan</a>, etc.). Exact criteria (<a>IsEqualTo</a>,
--   <a>IsNotEqualTo</a>) must match exactly so precedence is not relevant.
--   
--   Unspecified capability descriptions will result in unspecified
--   criteria being generated. These unspecified criteria help
--   <a>initialDisplayCapabilities</a> behave sensibly with terse display
--   mode descriptions.
--   
--   Here is an example using <a>initialDisplayCapabilities</a>:
--   
--   <pre>
--   initialDisplayCapabilities $= [ With  DisplayRGB,
--                                   Where DisplayDepth IsAtLeast 16,
--                                   With  DisplaySamples,
--                                   Where DisplayStencil IsNotLessThan 2,
--                                   With  DisplayDouble ]
--   </pre>
--   
--   The above call requests a window with an RGBA color model (but
--   requesting no bits of alpha), a depth buffer with at least 16 bits of
--   precision but preferring more, multisampling if available, at least 2
--   bits of stencil (favoring less stencil to more as long as 2 bits are
--   available), and double buffering.
initialDisplayCapabilities :: SettableStateVar [DisplayCapabilityDescription]

-- | How rendering context for new windows are created.
data RenderingContext

-- | Create a new context via <tt>glXCreateContext</tt> or
--   <tt>wglCreateContext</tt> (default).
CreateNewContext :: RenderingContext

-- | Re-use the current rendering context.
UseCurrentContext :: RenderingContext

-- | (<i>freeglut only</i>) Controls the creation of rendering contexts for
--   new windows.
renderingContext :: StateVar RenderingContext

-- | The kind of GLX rendering context used. Direct rendering provides a
--   performance advantage in some implementations. However, direct
--   rendering contexts cannot be shared outside a single process, and they
--   may be unable to render to GLX pixmaps.
data DirectRendering

-- | Rendering is always done through the X server. This corresponds to the
--   command line argument <tt>-indirect</tt>, see <a>initialize</a>.
ForceIndirectContext :: DirectRendering

-- | Try to use direct rendering, silently using indirect rendering if this
--   is not possible.
AllowDirectContext :: DirectRendering

-- | Try to use direct rendering, issue a warning and use indirect
--   rendering if this is not possible.
TryDirectContext :: DirectRendering

-- | Try to use direct rendering, issue an error and terminate the program
--   if this is not possible.This corresponds to the command line argument
--   <tt>-direct</tt>, see <a>initialize</a>.
ForceDirectContext :: DirectRendering

-- | (<i>freeglut on X11 only</i>) Controls which kind of rendering context
--   is created when a new one is required.
directRendering :: StateVar DirectRendering

-- | (<i>freeglut only</i>) Controls the API major/minor version of the
--   OpenGL context. If a version less than or equal to 2.1 is requested,
--   the context returned may implement any version no less than that
--   requested and no greater than 2.1. If version 3.0 is requested, the
--   context returned must implement exactly version 3.0. Versioning
--   behavior once GL versions beyond 3.0 are defined will be defined by an
--   amendment to the OpenGL specification to define dependencies on such
--   GL versions.
--   
--   <a>glVersion</a> and <a>majorMinor</a> will return the actual version
--   supported by a context.
--   
--   The default context version is (1, 0), which will typically return an
--   OpenGL 2.1 context, if one is available.
initialContextVersion :: StateVar (Int, Int)

-- | A flag affecting the rendering context to create, used in conjunction
--   with <a>initialContextFlags</a>.
data ContextFlag

-- | Debug contexts are intended for use during application development,
--   and provide additional runtime checking, validation, and logging
--   functionality while possibly incurring performance penalties. The
--   additional functionality provided by debug contexts may vary according
--   to the implementation. In some cases a debug context may be identical
--   to a non-debug context.
DebugContext :: ContextFlag

-- | Forward-compatible contexts are defined only for OpenGL versions 3.0
--   and later. They must not support functionality marked as
--   <i>deprecated</i> by that version of the API, while a
--   non-forward-compatible context must support all functionality in that
--   version, deprecated or not.
ForwardCompatibleContext :: ContextFlag

-- | (<i>freeglut only</i>) Controls the set of flags for the rendering
--   context.
initialContextFlags :: StateVar [ContextFlag]

-- | An OpenGL API profile, affecting the rendering context to create, used
--   in conjunction with <a>initialContextProfile</a>.
data ContextProfile

-- | The OpenGL <i>core</i> profile, which all OpenGL 3.2 implementations
--   are required to support.
CoreProfile :: ContextProfile

-- | The OpenGL <i>compatibility</i> profile, which is optional for OpenGL
--   3.2 implementations.
CompatibilityProfile :: ContextProfile

-- | (<i>freeglut only</i>) Controls the set of profiles for the rendering
--   context.
initialContextProfile :: StateVar [ContextProfile]
instance Eq DisplayMode
instance Ord DisplayMode
instance Show DisplayMode
instance Eq DisplayCapability
instance Ord DisplayCapability
instance Show DisplayCapability
instance Eq DisplayCapabilityDescription
instance Ord DisplayCapabilityDescription
instance Show DisplayCapabilityDescription
instance Eq RenderingContext
instance Ord RenderingContext
instance Show RenderingContext
instance Eq DirectRendering
instance Ord DirectRendering
instance Show DirectRendering
instance Eq ContextFlag
instance Ord ContextFlag
instance Show ContextFlag
instance Eq ContextProfile
instance Ord ContextProfile
instance Show ContextProfile


-- | A Haskell binding for GLUT, the OpenGL Utility Toolkit, a window
--   system independent toolkit for writing OpenGL programs. It includes
--   support for the extended functionality available in freeglut (see
--   <a>http://freeglut.sourceforge.net/</a>) and OpenGLUT (see
--   <a>http://openglut.sourceforge.net/</a>), too.
module Graphics.UI.GLUT
