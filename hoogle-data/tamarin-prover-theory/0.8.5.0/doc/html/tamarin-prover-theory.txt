-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Term manipulation library for the tamarin prover.
--   
--   This is an internal library of the Tamarin prover for security
--   protocol verification
--   (<a>hackage.haskell.org/package/tamarin-prover</a>).
--   
--   This library provides the types to represent security protocol, and it
--   implements the constraint solver.
@package tamarin-prover-theory
@version 0.8.5.0


-- | Facts used to formulate and reason about protocol execution.
module Theory.Model.Fact

-- | Facts.
data Fact t
Fact :: FactTag -> [t] -> Fact t
factTag :: Fact t -> FactTag
factTerms :: Fact t -> [t]
data Multiplicity
Persistent :: Multiplicity
Linear :: Multiplicity

-- | Fact tags/symbols
data FactTag

-- | A protocol fact together with its arity and multiplicity.
ProtoFact :: Multiplicity -> String -> Int -> FactTag

-- | Freshly generated value.
FreshFact :: FactTag

-- | Sent by the protocol
OutFact :: FactTag

-- | Officially known by the intruder/network.
InFact :: FactTag

-- | Up-knowledge fact in messsage deduction.
KUFact :: FactTag

-- | Down-knowledge fact in message deduction.
KDFact :: FactTag

-- | Log-fact denoting that the intruder deduced a message using a
--   construction rule.
DedFact :: FactTag

-- | <tt>matchLFact t p</tt> is a complete set of AC matchers for the term
--   fact <tt>t</tt> and the pattern fact <tt>p</tt>.
matchFact :: Fact t -> Fact t -> Match t

-- | True if the fact is a linear fact.
isLinearFact :: Fact t -> Bool

-- | True if the fact is a persistent fact.
isPersistentFact :: Fact t -> Bool

-- | True iff the fact is a non-special protocol fact.
isProtoFact :: Fact t -> Bool

-- | The name of a fact tag, e.g., <tt>factTagName KUFact = <a>KU</a></tt>.
factTagName :: FactTag -> String

-- | Show a fact tag as a <a>String</a>. This is the <a>factTagName</a>
--   prefixed with the multiplicity.
showFactTag :: FactTag -> String

-- | Show a fact tag together with its aritiy.
showFactTagArity :: FactTag -> String

-- | The arity of a <a>FactTag</a>.
factTagArity :: FactTag -> Int

-- | The multiplicity of a <a>FactTag</a>.
factTagMultiplicity :: FactTag -> Multiplicity

-- | The arity of a <a>Fact</a>.
factArity :: Fact t -> Int

-- | The multiplicity of a <a>Fact</a>.
factMultiplicity :: Fact t -> Multiplicity

-- | A direction tag
data DirTag
UpK :: DirTag
DnK :: DirTag
kuFact :: t -> Fact t
kdFact :: t -> Fact t

-- | View a message-deduction fact.
kFactView :: LNFact -> Maybe (DirTag, LNTerm)

-- | View a deduction logging fact.
dedFactView :: LNFact -> Maybe LNTerm

-- | True if the fact is a message-deduction fact.
isKFact :: LNFact -> Bool

-- | True if the fact is a KU-fact.
isKUFact :: LNFact -> Bool

-- | True if the fact is a KD-fact.
isKDFact :: LNFact -> Bool

-- | A fresh fact denotes a fresh unguessable name.
freshFact :: t -> Fact t

-- | A fact denoting a message sent by the protocol to the intruder.
outFact :: t -> Fact t

-- | A fact denoting that the intruder sent a message to the protocol.
inFact :: t -> Fact t

-- | A fact logging that the intruder knows a message.
kLogFact :: t -> Fact t

-- | A fact logging that the intruder deduced a message using a
--   construction rule. We use this to formulate invariants over normal
--   dependency graphs.
dedLogFact :: t -> Fact t

-- | A protocol fact denotes a fact generated by a protocol rule.
protoFact :: Multiplicity -> String -> [t] -> Fact t

-- | Facts with literals containing names and arbitrary variables.
type NFact v = Fact (NTerm v)

-- | Facts with literals arbitrary constants and logical variables.
type LFact c = Fact (LTerm c)

-- | Facts used for proving; i.e. variables fixed to logical variables and
--   constant fixed to names.
type LNFact = Fact LNTerm

-- | Unify a list of <tt>LFact</tt> equalities.
unifyLNFactEqs :: [Equal LNFact] -> WithMaude [LNSubstVFresh]

-- | <a>True</a> iff the two facts are unifiable.
unifiableLNFacts :: LNFact -> LNFact -> WithMaude Bool

-- | Pretty print a fact.
prettyFact :: Document d => (t -> d) -> Fact t -> d

-- | Pretty print a <a>NFact</a>.
prettyNFact :: Document d => LNFact -> d

-- | Pretty print a <a>LFact</a>.
prettyLNFact :: Document d => LNFact -> d
instance NFData t_1627412214 => NFData (Fact t_1627412214)
instance NFData FactTag
instance NFData Multiplicity
instance Binary t_1627412214 => Binary (Fact t_1627412214)
instance Binary FactTag
instance Binary Multiplicity
instance Typeable Multiplicity
instance Typeable FactTag
instance Typeable1 Fact
instance Eq Multiplicity
instance Ord Multiplicity
instance Show Multiplicity
instance Data Multiplicity
instance Eq FactTag
instance Ord FactTag
instance Show FactTag
instance Data FactTag
instance Eq t => Eq (Fact t)
instance Ord t => Ord (Fact t)
instance Show t => Show (Fact t)
instance Data t => Data (Fact t)
instance Eq DirTag
instance Ord DirTag
instance Show DirTag
instance Apply t => Apply (Fact t)
instance HasFrees t => HasFrees (Fact t)
instance Sized t => Sized (Fact t)
instance Traversable Fact
instance Foldable Fact
instance Functor Fact


-- | General support for pretty printing theories.
module Theory.Text.Pretty

-- | Vertically separate a list of documents by empty lines.
vsep :: Document d => [d] -> d

-- | Pretty print a list of values as a comma-separated list wrapped in
--   paragraph mode.
fsepList :: Document d => (a -> d) -> [a] -> d
lineComment :: HighlightDocument d => d -> d
multiComment :: HighlightDocument d => d -> d
lineComment_ :: HighlightDocument d => String -> d
multiComment_ :: HighlightDocument d => [String] -> d
kwTheoryHeader :: HighlightDocument d => d -> d
kwEnd :: HighlightDocument d => d
kwModulo :: HighlightDocument d => String -> String -> d
kwBy :: HighlightDocument d => d
kwCase :: HighlightDocument d => d
kwNext :: HighlightDocument d => d
kwQED :: HighlightDocument d => d
kwLemma :: HighlightDocument d => d
kwAxiom :: HighlightDocument d => d
kwRuleModulo :: HighlightDocument d => String -> d
kwInstanceModulo :: HighlightDocument d => String -> d
kwVariantsModulo :: HighlightDocument d => String -> d
kwTypesModulo :: HighlightDocument d => String -> d
opProvides :: HighlightDocument d => d
opRequires :: HighlightDocument d => d
opAction :: HighlightDocument d => d
opPath :: HighlightDocument d => d
opLess :: HighlightDocument d => d
opEqual :: HighlightDocument d => d
opDedBefore :: HighlightDocument d => d
opEdge :: HighlightDocument d => d
opExists :: HighlightDocument d => d
opForall :: HighlightDocument d => d
opLAnd :: HighlightDocument d => d
opLOr :: HighlightDocument d => d
opImp :: HighlightDocument d => d
opIff :: HighlightDocument d => d
opDot :: HighlightDocument d => d


-- | Support for reasoning with and about disjunctions of substitutions.
module Theory.Tools.EquationStore

-- | Index of disjunction in equation store
newtype SplitId
SplitId :: Integer -> SplitId
unSplitId :: SplitId -> Integer
data EqStore
EqStore :: LNSubst -> Conj (SplitId, Set LNSubstVFresh) -> SplitId -> EqStore
_eqsSubst :: EqStore -> LNSubst
_eqsConj :: EqStore -> Conj (SplitId, Set LNSubstVFresh)
_eqsNextSplitId :: EqStore -> SplitId

-- | <tt>emptyEqStore</tt> is the empty equation store.
emptyEqStore :: EqStore
eqsSubst :: Arrow arr => Lens arr EqStore LNSubst
eqsConj :: Arrow arr => Lens arr EqStore (Conj (SplitId, Set LNSubstVFresh))

-- | The false conjunction. It is always identified with split number -1.
falseEqConstrConj :: Conj (SplitId, Set LNSubstVFresh)

-- | <tt>True</tt> iff the <a>EqStore</a> is contradictory.
eqsIsFalse :: EqStore -> Bool

-- | Add a list of term equalities to the equation store. Returns the split
--   identifier of the disjunction in resulting equation store.
addEqs :: MonadFresh m => MaudeHandle -> [Equal LNTerm] -> EqStore -> m (EqStore, Maybe SplitId)

-- | Add the given rule variants.
addRuleVariants :: Disj LNSubstVFresh -> EqStore -> (EqStore, SplitId)

-- | Add a disjunction to the equation store at the beginning
addDisj :: EqStore -> (Set LNSubstVFresh) -> (EqStore, SplitId)

-- | <tt>performSplit eqs i</tt> performs a case-split on the first
--   disjunction with the given <a>SplitId</a>.
performSplit :: EqStore -> SplitId -> Maybe [EqStore]
dropNameHintsBound :: EqStore -> EqStore

-- | Returns the list of all <tt>SplitId</tt>s valid for the given equation
--   store sorted by the size of the disjunctions.
splits :: EqStore -> [SplitId]

-- | Returns the number of cases for a given <a>SplitId</a>.
splitSize :: EqStore -> SplitId -> Maybe Int

-- | Returns <a>True</a> if the <a>SplitId</a> is valid.
splitExists :: EqStore -> SplitId -> Bool

-- | <tt>simp eqStore</tt> simplifies the equation store.
simp :: MonadFresh m => MaudeHandle -> (LNSubst -> LNSubstVFresh -> Bool) -> EqStore -> m EqStore

-- | Simplify given disjunction via EqStore simplification. Obtains fresh
--   names for variables from the underlying <a>MonadFresh</a>.
simpDisjunction :: MonadFresh m => MaudeHandle -> (LNSubst -> LNSubstVFresh -> Bool) -> Disj LNSubstVFresh -> m (LNSubst, Maybe [LNSubstVFresh])

-- | Pretty print an <a>EqStore</a>.
prettyEqStore :: HighlightDocument d => EqStore -> d
instance NFData EqStore
instance Binary EqStore
instance Show EqStore
instance HasFrees EqStore
instance Apply SplitId
instance Eq SplitId
instance Ord SplitId
instance Show SplitId
instance Enum SplitId
instance Binary SplitId
instance NFData SplitId
instance HasFrees SplitId
instance Eq EqStore
instance Ord EqStore


-- | Formulas that represent security properties.
module Theory.Model.Atom

-- | <tt>Atom</tt>'s are the atoms of trace formulas parametrized over
--   arbitrary terms.
data Atom t
Action :: t -> (Fact t) -> Atom t
EqE :: t -> t -> Atom t
Less :: t -> t -> Atom t
Last :: t -> Atom t

-- | <tt>LAtom</tt> are the atoms we actually use in graph formulas input
--   by the user.
type NAtom v = Atom (VTerm Name v)

-- | <tt>LAtom</tt> are the atoms we actually use in graph formulas input
--   by the user.
type LNAtom = Atom LNTerm

-- | True iff the atom is an action atom.
isActionAtom :: Atom t -> Bool

-- | True iff the atom is a last atom.
isLastAtom :: Atom t -> Bool

-- | True iff the atom is a temporal ordering atom.
isLessAtom :: Atom t -> Bool

-- | True iff the atom is an equality atom.
isEqAtom :: Atom t -> Bool

-- | Atoms built over <a>BLTerm</a>s.
type BLAtom = Atom BLTerm
prettyNAtom :: (Show v, HighlightDocument d) => NAtom v -> d
instance Binary t_1627526347 => Binary (Atom t_1627526347)
instance NFData t_1627526347 => NFData (Atom t_1627526347)
instance Typeable1 Atom
instance Eq t => Eq (Atom t)
instance Ord t => Ord (Atom t)
instance Show t => Show (Atom t)
instance Data t => Data (Atom t)
instance Apply BLAtom
instance Apply LNAtom
instance HasFrees t => HasFrees (Atom t)
instance Traversable Atom
instance Foldable Atom
instance Functor Atom


-- | Types and operations for handling sorted first-order logic
module Theory.Model.Formula

-- | Logical connectives.
data Connective
And :: Connective
Or :: Connective
Imp :: Connective
Iff :: Connective

-- | Quantifiers.
data Quantifier
All :: Quantifier
Ex :: Quantifier

-- | First-order formulas in locally nameless representation with hints for
--   the names/sorts of quantified variables.
data Formula s c v
Ato :: (Atom (VTerm c (BVar v))) -> Formula s c v
TF :: !Bool -> Formula s c v
Not :: (Formula s c v) -> Formula s c v
Conn :: !Connective -> (Formula s c v) -> (Formula s c v) -> Formula s c v
Qua :: !Quantifier -> s -> (Formula s c v) -> Formula s c v
type LNFormula = Formula (String, LSort) Name LVar

-- | <tt>LFormula</tt> are FOL formulas with sorts abused to denote both a
--   hint for the name of the bound variable, as well as the variable's
--   actual sort.
type LFormula c = Formula (String, LSort) c LVar

-- | Introduce a bound variable for a free variable.
quantify :: (Ord c, Ord v, Eq v) => v -> Formula s c v -> Formula s c v

-- | <tt>openFormula f</tt> returns <tt>Just (v,Q,f')</tt> if <tt>f = Q v.
--   f'</tt> modulo alpha renaming and <tt>Nothing otherwise</tt>.
--   <tt>v</tt> is always chosen to be fresh.
openFormula :: (MonadFresh m, Ord c) => LFormula c -> Maybe (Quantifier, m (LVar, LFormula c))

-- | <tt>openFormulaPrefix f</tt> returns <tt>Just (vs,Q,f')</tt> if <tt>f
--   = Q v_1 .. v_k. f'</tt> modulo alpha renaming and <tt>Nothing
--   otherwise</tt>. <tt>vs</tt> is always chosen to be fresh.
openFormulaPrefix :: (MonadFresh m, Ord c) => LFormula c -> m ([LVar], Quantifier, LFormula c)

-- | Logically false.
lfalse :: Formula a s v

-- | Logically true.
ltrue :: Formula a s v
(.&&.) :: Formula a s v -> Formula a s v -> Formula a s v
(.||.) :: Formula a s v -> Formula a s v -> Formula a s v
(.==>.) :: Formula a s v -> Formula a s v -> Formula a s v
(.<=>.) :: Formula a s v -> Formula a s v -> Formula a s v

-- | Create a existential quantification with a sort hint for the bound
--   variable.
exists :: (Ord c, Ord v, Eq v) => s -> v -> Formula s c v -> Formula s c v

-- | Create a universal quantification with a sort hint for the bound
--   variable.
forall :: (Ord c, Ord v, Eq v) => s -> v -> Formula s c v -> Formula s c v

-- | Change the representation of atoms.
mapAtoms :: (Integer -> Atom (VTerm c (BVar v)) -> Atom (VTerm c1 (BVar v1))) -> Formula s c v -> Formula s c1 v1

-- | Fold a formula.
foldFormula :: (Atom (VTerm c (BVar v)) -> b) -> (Bool -> b) -> (b -> b) -> (Connective -> b -> b -> b) -> (Quantifier -> s -> b -> b) -> Formula s c v -> b

-- | Pretty print a logical formula
prettyLNFormula :: HighlightDocument d => LNFormula -> d
instance (NFData s_1627543173, NFData c_1627543174, NFData v_1627543175) => NFData (Formula s_1627543173 c_1627543174 v_1627543175)
instance NFData Quantifier
instance NFData Connective
instance (Binary s_1627543173, Binary c_1627543174, Binary v_1627543175) => Binary (Formula s_1627543173 c_1627543174 v_1627543175)
instance Binary Quantifier
instance Binary Connective
instance Typeable Connective
instance Typeable Quantifier
instance Ord (Formula (String, LSort) Name LVar)
instance Show (Formula (String, LSort) Name LVar)
instance Eq (Formula (String, LSort) Name LVar)
instance Eq Connective
instance Ord Connective
instance Show Connective
instance Enum Connective
instance Bounded Connective
instance Data Connective
instance Eq Quantifier
instance Ord Quantifier
instance Show Quantifier
instance Enum Quantifier
instance Bounded Quantifier
instance Data Quantifier
instance Apply LNFormula
instance HasFrees LNFormula
instance Foldable (Formula s c)


-- | Rewriting rules representing protocol execution and intruder
--   deduction. Once modulo the full Diffie-Hellman equational theory and
--   once modulo AC.
module Theory.Model.Rule

-- | Rewriting rules with arbitrary additional information and facts with
--   names and logical variables.
data Rule i
Rule :: i -> [LNFact] -> [LNFact] -> [LNFact] -> Rule i
_rInfo :: Rule i -> i
_rPrems :: Rule i -> [LNFact]
_rConcs :: Rule i -> [LNFact]
_rActs :: Rule i -> [LNFact]

-- | An index of a premise. The first premise has index '0'.
newtype PremIdx
PremIdx :: Int -> PremIdx
getPremIdx :: PremIdx -> Int

-- | An index of a conclusion. The first conclusion has index '0'.
newtype ConcIdx
ConcIdx :: Int -> ConcIdx
getConcIdx :: ConcIdx -> Int
rInfo :: Arrow arr => Lens arr (Rule i) i
rPrems :: Arrow arr => Lens arr (Rule i) [LNFact]
rConcs :: Arrow arr => Lens arr (Rule i) [LNFact]
rActs :: Arrow arr => Lens arr (Rule i) [LNFact]

-- | <tt>rPrem i</tt> is a lens for the <tt>i</tt>-th premise of a rule.
rPrem :: PremIdx -> (Rule i :-> LNFact)

-- | <tt>rConc i</tt> is a lens for the <tt>i</tt>-th conclusion of a rule.
rConc :: ConcIdx -> (Rule i :-> LNFact)

-- | <tt>lookupPrem i ru</tt> returns the <tt>i</tt>-th premise of rule
--   <tt>ru</tt>, if possible.
lookupPrem :: PremIdx -> Rule i -> Maybe LNFact

-- | <tt>lookupConc i ru</tt> returns the <tt>i</tt>-th conclusion of rule
--   <tt>ru</tt>, if possible.
lookupConc :: ConcIdx -> Rule i -> Maybe LNFact

-- | Enumerate all premises of a rule.
enumPrems :: Rule i -> [(PremIdx, LNFact)]

-- | Enumerate all conclusions of a rule.
enumConcs :: Rule i -> [(ConcIdx, LNFact)]

-- | Rule information for protocol and intruder rules.
data RuleInfo p i
ProtoInfo :: p -> RuleInfo p i
IntrInfo :: i -> RuleInfo p i

-- | <tt>ruleInfo proto intr</tt> maps the protocol information with
--   <tt>proto</tt> and the intruder information with <tt>intr</tt>.
ruleInfo :: (p -> c) -> (i -> c) -> RuleInfo p i -> c

-- | A name of a protocol rule is either one of the special reserved rules
--   or some standard rule.
data ProtoRuleName
FreshRule :: ProtoRuleName

-- | Some standard protocol rule
StandRule :: String -> ProtoRuleName

-- | Information for protocol rules modulo AC. The variants list the
--   possible instantiations of the free variables of the rule. The typing
--   is interpreted modulo AC; i.e., its variants were also built.
data ProtoRuleACInfo
ProtoRuleACInfo :: ProtoRuleName -> Disj (LNSubstVFresh) -> [PremIdx] -> ProtoRuleACInfo
_pracName :: ProtoRuleACInfo -> ProtoRuleName
_pracVariants :: ProtoRuleACInfo -> Disj (LNSubstVFresh)
_pracLoopBreakers :: ProtoRuleACInfo -> [PremIdx]
pracName :: Arrow arr => Lens arr ProtoRuleACInfo ProtoRuleName
pracVariants :: Arrow arr => Lens arr ProtoRuleACInfo (Disj LNSubstVFresh)
pracLoopBreakers :: Arrow arr => Lens arr ProtoRuleACInfo [PremIdx]

-- | Information for instances of protocol rules modulo AC.
data ProtoRuleACInstInfo
ProtoRuleACInstInfo :: ProtoRuleName -> [PremIdx] -> ProtoRuleACInstInfo
_praciName :: ProtoRuleACInstInfo -> ProtoRuleName
_praciLoopBreakers :: ProtoRuleACInstInfo -> [PremIdx]
praciName :: Arrow arr => Lens arr ProtoRuleACInstInfo ProtoRuleName
praciLoopBreakers :: Arrow arr => Lens arr ProtoRuleACInstInfo [PremIdx]
type RuleACConstrs = Disj LNSubstVFresh

-- | An intruder rule modulo AC is described by its name.
data IntrRuleACInfo
ConstrRule :: ByteString -> IntrRuleACInfo
DestrRule :: ByteString -> IntrRuleACInfo
CoerceRule :: IntrRuleACInfo
IRecvRule :: IntrRuleACInfo
ISendRule :: IntrRuleACInfo
PubConstrRule :: IntrRuleACInfo
FreshConstrRule :: IntrRuleACInfo

-- | A rule modulo E is always a protocol rule. Intruder rules are
--   specified abstractly by their operations generating them and are only
--   available once their variants are built.
type ProtoRuleE = Rule ProtoRuleName

-- | A protocol rule modulo AC.
type ProtoRuleAC = Rule ProtoRuleACInfo

-- | An intruder rule modulo AC.
type IntrRuleAC = Rule IntrRuleACInfo

-- | A rule modulo AC is either a protocol rule or an intruder rule
type RuleAC = Rule (RuleInfo ProtoRuleACInfo IntrRuleACInfo)

-- | A rule instance module AC is either a protocol rule or an intruder
--   rule. The info identifies the corresponding rule modulo AC that the
--   instance was derived from.
type RuleACInst = Rule (RuleInfo ProtoRuleACInstInfo IntrRuleACInfo)

-- | Types that have an associated name.
class HasRuleName t
ruleName :: HasRuleName t => t -> RuleInfo ProtoRuleName IntrRuleACInfo

-- | True iff the rule is an intruder rule
isIntruderRule :: HasRuleName r => r -> Bool

-- | True iff the rule is a destruction rule.
isDestrRule :: HasRuleName r => r -> Bool

-- | True iff the rule is a construction rule.
isConstrRule :: HasRuleName r => r -> Bool

-- | True iff the rule is the special fresh rule.
isFreshRule :: HasRuleName r => r -> Bool

-- | True iff the rule is the special learn rule.
isIRecvRule :: HasRuleName r => r -> Bool

-- | True iff the rule is the special knows rule.
isISendRule :: HasRuleName r => r -> Bool

-- | True iff the rule is the special coerce rule.
isCoerceRule :: HasRuleName r => r -> Bool

-- | True if the messages in premises and conclusions are in normal form
nfRule :: Rule i -> WithMaude Bool

-- | True if the protocol rule has only the trivial variant.
isTrivialProtoVariantAC :: ProtoRuleAC -> ProtoRuleE -> Bool

-- | Converts between these two types of rules, if possible.
ruleACToIntrRuleAC :: RuleAC -> Maybe IntrRuleAC

-- | Converts between these two types of rules.
ruleACIntrToRuleAC :: IntrRuleAC -> RuleAC

-- | Converts between these two types of rules.
ruleACIntrToRuleACInst :: IntrRuleAC -> RuleACInst

-- | Compute <i>some</i> rule instance of a rule modulo AC. If the rule is
--   a protocol rule, then the given typing and variants also need to be
--   handled.
someRuleACInst :: MonadFresh m => RuleAC -> m (RuleACInst, Maybe RuleACConstrs)

-- | Unify a list of <tt>RuleACInst</tt> equalities.
unifyRuleACInstEqs :: [Equal RuleACInst] -> WithMaude [LNSubstVFresh]

-- | Are these two rule instances unifiable.
unifiableRuleACInsts :: RuleACInst -> RuleACInst -> WithMaude Bool

-- | List of all reserved rule names.
reservedRuleNames :: [String]

-- | Pretty print the rule name such that it can be used as a case name
showRuleCaseName :: HasRuleName (Rule i) => Rule i -> String
prettyProtoRuleName :: Document d => ProtoRuleName -> d
prettyRuleName :: (HighlightDocument d, HasRuleName (Rule i)) => Rule i -> d
prettyProtoRuleE :: HighlightDocument d => ProtoRuleE -> d
prettyProtoRuleAC :: HighlightDocument d => ProtoRuleAC -> d
prettyIntrRuleAC :: HighlightDocument d => IntrRuleAC -> d
prettyIntrRuleACInfo :: Document d => IntrRuleACInfo -> d
prettyRuleAC :: HighlightDocument d => RuleAC -> d
prettyLoopBreakers :: HighlightDocument d => ProtoRuleACInfo -> d
prettyRuleACInst :: HighlightDocument d => RuleACInst -> d
instance NFData IntrRuleACInfo
instance (NFData p_1627582388, NFData i_1627582389) => NFData (RuleInfo p_1627582388 i_1627582389)
instance NFData ProtoRuleACInstInfo
instance NFData ProtoRuleACInfo
instance NFData ProtoRuleName
instance NFData i_1627581947 => NFData (Rule i_1627581947)
instance Binary IntrRuleACInfo
instance (Binary p_1627582388, Binary i_1627582389) => Binary (RuleInfo p_1627582388 i_1627582389)
instance Binary ProtoRuleACInstInfo
instance Binary ProtoRuleACInfo
instance Binary ProtoRuleName
instance Binary i_1627581947 => Binary (Rule i_1627581947)
instance Typeable IntrRuleACInfo
instance Ord IntrRuleACInfo
instance Eq IntrRuleACInfo
instance Show IntrRuleACInfo
instance Data IntrRuleACInfo
instance HasRuleName RuleACInst
instance HasRuleName IntrRuleAC
instance HasRuleName ProtoRuleAC
instance HasRuleName RuleAC
instance HasRuleName ProtoRuleE
instance HasFrees IntrRuleACInfo
instance Apply IntrRuleACInfo
instance HasFrees ProtoRuleACInstInfo
instance Apply ProtoRuleACInstInfo
instance HasFrees ProtoRuleACInfo
instance HasFrees ConcIdx
instance Apply ConcIdx
instance HasFrees PremIdx
instance Apply PremIdx
instance HasFrees ProtoRuleName
instance Apply ProtoRuleName
instance Typeable PremIdx
instance Typeable ConcIdx
instance Typeable ProtoRuleName
instance Eq PremIdx
instance Ord PremIdx
instance Show PremIdx
instance Enum PremIdx
instance Data PremIdx
instance Binary PremIdx
instance NFData PremIdx
instance Eq ConcIdx
instance Ord ConcIdx
instance Show ConcIdx
instance Enum ConcIdx
instance Data ConcIdx
instance Binary ConcIdx
instance NFData ConcIdx
instance (Eq p, Eq i) => Eq (RuleInfo p i)
instance (Ord p, Ord i) => Ord (RuleInfo p i)
instance (Show p, Show i) => Show (RuleInfo p i)
instance Eq ProtoRuleName
instance Ord ProtoRuleName
instance Show ProtoRuleName
instance Data ProtoRuleName
instance Eq ProtoRuleACInfo
instance Ord ProtoRuleACInfo
instance Show ProtoRuleACInfo
instance Eq ProtoRuleACInstInfo
instance Ord ProtoRuleACInstInfo
instance Show ProtoRuleACInstInfo
instance (Apply p, Apply i) => Apply (RuleInfo p i)
instance (HasFrees p, HasFrees i) => HasFrees (RuleInfo p i)
instance Sized (Rule i)
instance Apply i => Apply (Rule i)
instance (Show i, HasFrees i) => HasFrees (Rule i)
instance Functor Rule
instance Typeable1 Rule
instance Eq i => Eq (Rule i)
instance Ord i => Ord (Rule i)
instance Show i => Show (Rule i)
instance Data i => Data (Rule i)


-- | Signatures for the terms and multiset rewriting rules used to model
--   and reason about a security protocol. modulo the full Diffie-Hellman
--   equational theory and once modulo AC.
module Theory.Model.Signature

-- | A theory signature.
data Signature a
Signature :: a -> Signature a
_sigMaudeInfo :: Signature a -> a

-- | A <a>Signature</a> without an associated Maude process.
type SignaturePure = Signature MaudeSig

-- | The empty pure signature.
emptySignaturePure :: SignaturePure

-- | Access the maude signature.
sigpMaudeSig :: SignaturePure :-> MaudeSig

-- | A <a>Signature</a> with an associated, running Maude process.
type SignatureWithMaude = Signature MaudeHandle

-- | Ensure that maude is running and configured with the current
--   signature.
toSignatureWithMaude :: FilePath -> SignaturePure -> IO (SignatureWithMaude)

-- | The pure signature of a <a>SignatureWithMaude</a>.
toSignaturePure :: SignatureWithMaude -> SignaturePure

-- | Access the maude handle in a signature.
sigmMaudeHandle :: SignatureWithMaude :-> MaudeHandle

-- | Pretty-print a signature with maude.
prettySignaturePure :: HighlightDocument d => SignaturePure -> d

-- | Pretty-print a pure signature.
prettySignatureWithMaude :: HighlightDocument d => SignatureWithMaude -> d
instance Show (Signature MaudeSig)
instance Ord (Signature MaudeSig)
instance Eq (Signature MaudeSig)
instance NFData SignatureWithMaude
instance Binary SignatureWithMaude
instance Show SignatureWithMaude
instance Ord SignatureWithMaude
instance Eq SignatureWithMaude
instance NFData SignaturePure
instance Binary SignaturePure


-- | Security protocol model.
module Theory.Model


-- | Abstract intepretation for partial evaluation of multiset rewriting
--   systems.
module Theory.Tools.AbstractInterpretation

-- | Higher-order combinator to construct abstract interpreters.
interpretAbstractly :: (Eq s, HasFrees i, Apply i, Show i) => ([Equal LNFact] -> [LNSubstVFresh]) -> s -> (LNFact -> s -> s) -> (s -> [LNFact]) -> [Rule i] -> [(s, [Rule i])]

-- | How to report on performing a partial evaluation.
data EvaluationStyle
Silent :: EvaluationStyle
Summary :: EvaluationStyle
Tracing :: EvaluationStyle

-- | Concrete partial evaluator activated with flag: --partial-evaluation
partialEvaluation :: EvaluationStyle -> [ProtoRuleE] -> WithMaude (Set LNFact, [ProtoRuleE])


-- | Computate an under-approximation to the set of all facts with unique
--   instances, i.e., fact whose instances never occur more than once in a
--   state. We use this information to reason about protocols that exploit
--   exclusivity of linear facts.
module Theory.Tools.InjectiveFactInstances

-- | Compute a simple under-approximation to the set of facts with
--   injective instances. A fact-tag is has injective instances, if there
--   is no state of the protocol with more than one instance with the same
--   term as a first argument of the fact-tag.
--   
--   We compute the under-approximation by checking that (1) the fact-tag
--   is linear, (2) every introduction of such a fact-tag is protected by a
--   Fr-fact of the first term, and (3) every rule has at most one copy of
--   this fact-tag in the conlcusion and the first term arguments agree.
--   
--   We exclude facts that are not copied in a rule, as they are already
--   handled properly by the naive backwards reasoning.
simpleInjectiveFactInstances :: [ProtoRuleE] -> Set FactTag


-- | Computate the loop-breakers in the premise-conclusion graph of a set
--   of multiset rewriting rules.
module Theory.Tools.LoopBreakers

-- | Replace all loop-breaker information with loop-breakers computed
--   automatically from the dataflow relation <tt>dataflowRelAC</tt>.
useAutoLoopBreakersAC :: Ord a => (a -> [(PremIdx, LNFact)]) -> (a -> [(ConcIdx, LNFact)]) -> (a -> [LNSubstVFresh]) -> ([PremIdx] -> a -> a) -> [a] -> WithMaude ([a], Relation (a, PremIdx), [(a, PremIdx)])


-- | Variants of protocol rules.
module Theory.Tools.RuleVariants
tmpdir :: FilePath

-- | Compute the variants of a protocol rule. 1. Abstract away terms in
--   facts with variables. 2. Compute variants of RHSs of equations. 3.
--   Apply variant substitutions to equations to obtain DNF of equations.
--   4. Simplify rule.
variantsProtoRule :: MaudeHandle -> ProtoRuleE -> ProtoRuleAC
computeVariantsCached :: LNTerm -> MaudeHandle -> [LNSubstVFresh]


module Theory.Tools.IntruderRules

-- | <tt>subtermIntruderRules maudeSig</tt> returns the set of intruder
--   rules for the subterm (not Xor, DH, and MSet) part of the given
--   signature.
subtermIntruderRules :: MaudeSig -> [IntrRuleAC]

-- | <tt>dhIntruderRules</tt> computes the intruder rules for DH
dhIntruderRules :: WithMaude [IntrRuleAC]
bpIntruderRules :: WithMaude [IntrRuleAC]
multisetIntruderRules :: [IntrRuleAC]
mkDUnionRule :: [LNTerm] -> LNTerm -> IntrRuleAC

-- | <tt>specialIntruderRules</tt> returns the special intruder rules that
--   are included independently of the message theory
specialIntruderRules :: [IntrRuleAC]
isDExpRule :: Rule (RuleInfo t IntrRuleACInfo) -> Bool
isDEMapRule :: Rule (RuleInfo t IntrRuleACInfo) -> Bool
isDPMultRule :: Rule (RuleInfo t IntrRuleACInfo) -> Bool


-- | Guarded formulas.
module Theory.Constraint.System.Guarded
data Guarded s c v
GAto :: (Atom (VTerm c (BVar v))) -> Guarded s c v
GDisj :: (Disj (Guarded s c v)) -> Guarded s c v
GConj :: (Conj (Guarded s c v)) -> Guarded s c v

-- | Denotes <tt>ALL xs. as =&gt; gf</tt> or <tt>Ex xs. as &amp; gf&amp;
--   depending on the <a>Quantifier</a>. We assume that all bound variables
--   xs occur in f</tt>i atoms in as.
GGuarded :: Quantifier -> [s] -> [Atom (VTerm c (BVar v))] -> (Guarded s c v) -> Guarded s c v
type LGuarded c = Guarded (String, LSort) c LVar
type LNGuarded = Guarded (String, LSort) Name LVar

-- | Atoms that are allowed as guards.
data GAtom t
GEqE :: (t, t) -> GAtom t
GAction :: (t, Fact t) -> GAtom t

-- | <tt>gfalse</tt> returns the guarded formula f with <tt>False <a>-</a>
--   f</tt>.
gfalse :: Guarded s c v

-- | <tt>gtrue</tt> returns the guarded formula f with <tt>True <a>-</a>
--   f</tt>.
gtrue :: Guarded s c v

-- | <tt>gdisj gfs</tt> smart constructor for the disjunction of gfs.
gdisj :: (Ord s, Ord c, Ord v) => [Guarded s c v] -> Guarded s c v

-- | <tt>gconj gfs</tt> smart constructor for the conjunction of gfs.
gconj :: (Ord s, Ord c, Ord v) => [Guarded s c v] -> Guarded s c v
gex :: (Ord s, Ord c, Ord v) => [s] -> [Atom (VTerm c (BVar v))] -> Guarded s c v -> Guarded s c v
gall :: (Eq s, Eq c, Eq v) => [s] -> [Atom (VTerm c (BVar v))] -> Guarded s c v -> Guarded s c v

-- | Negate a guarded formula.
gnot :: (Ord s, Ord c, Ord v) => Guarded s c v -> Guarded s c v

-- | Try to prove the formula by applying induction over the trace. Returns
--   <tt><a>Left</a> errMsg</tt> if this is not possible. Returns a tuple
--   of formulas: one formalizing the proof obligation of the base-case and
--   one formalizing the proof obligation of the step-case.
ginduct :: Ord c => LGuarded c -> Either String (LGuarded c, LGuarded c)

-- | <tt>formulaToGuarded fm</tt> returns a guarded formula <tt>gf</tt>
--   that is equivalent to <tt>fm</tt> if possible.
formulaToGuarded :: HighlightDocument d => LNFormula -> Either d LNGuarded

-- | <tt>formulaToGuarded fm</tt> returns a guarded formula <tt>gf</tt>
--   that is equivalent to <tt>fm</tt> under the assumption that this is
--   possible. If not, then <a>error</a> is called.
formulaToGuarded_ :: LNFormula -> LNGuarded

-- | Simplify a <a>Guarded</a> formula by replacing atoms with their truth
--   value, if it can be determined.
simplifyGuarded :: (LNAtom -> Maybe Bool) -> LNGuarded -> Maybe LNGuarded

-- | Map a guarded formula with scope info. The Integer argument denotes
--   the number of quantifiers that have been encountered so far.
mapGuardedAtoms :: (Integer -> Atom (VTerm c (BVar v)) -> Atom (VTerm d (BVar w))) -> Guarded s c v -> Guarded s d w

-- | Convert <a>Atom</a>s to <a>GAtom</a>s, if possible.
atomToGAtom :: Show t => Atom t -> GAtom t

-- | Stable sort that ensures that actions occur before equations.
sortGAtoms :: [GAtom t] -> [GAtom t]
isConjunction :: Guarded s c v -> Bool
isDisjunction :: Guarded s c v -> Bool
isAllGuarded :: Guarded s c v -> Bool
isExGuarded :: Guarded s c v -> Bool

-- | Check whether the guarded formula is closed and does not contain an
--   existential quantifier. This under-approximates the question whether
--   the formula is a safety formula. A safety formula <tt>phi</tt> has the
--   property that a trace violating it can never be extended to a trace
--   satisfying it.
isSafetyFormula :: HasFrees (Guarded s c v) => Guarded s c v -> Bool

-- | All <a>FactTag</a>s that are used in guards.
guardFactTags :: Guarded s c v -> [FactTag]

-- | Assuming that there are no more bound variables left in an atom of a
--   formula, convert it to an atom with free variables only.
bvarToLVar :: Ord c => Atom (VTerm c (BVar LVar)) -> Atom (VTerm c LVar)

-- | <tt>openGuarded gf</tt> returns <tt>Just (qua,vs,ats,gf')</tt> if
--   <tt>gf</tt> is a guarded clause and <tt>Nothing</tt> otherwise. In the
--   first case, <tt>qua</tt> is the quantifier, <tt>vs</tt> is a list of
--   fresh variables, <tt>ats</tt> is the antecedent, and <tt>gf'</tt> is
--   the succedent. In both antecedent and succedent, the bound variables
--   are replaced by <tt>vs</tt>.
openGuarded :: (Ord c, MonadFresh m) => LGuarded c -> m (Maybe (Quantifier, [LVar], [Atom (VTerm c LVar)], LGuarded c))

-- | <tt>substBound s gf</tt> substitutes each occurence of a bound
--   variable <tt>i</tt> in <tt>dom(s)</tt> with the corresponding free
--   variable <tt>s(i)=x</tt> in all atoms in <tt>gf</tt>.
substBound :: Ord c => [(Integer, LVar)] -> LGuarded c -> LGuarded c

-- | <tt>substBoundAtom s a</tt> substitutes each occurence of a bound
--   variables <tt>i</tt> in <tt>dom(s)</tt> with the corresponding free
--   variable <tt>x=s(i)</tt> in the atom <tt>a</tt>.
substBoundAtom :: Ord c => [(Integer, LVar)] -> Atom (VTerm c (BVar LVar)) -> Atom (VTerm c (BVar LVar))

-- | <tt>substFreeAtom s gf</tt> substitutes each occurence of a free
--   variables <tt>v in dom(s)</tt> with the correpsonding bound variables
--   <tt>i=s(v)</tt> in all atoms in <tt>gf</tt>.
substFree :: Ord c => [(LVar, Integer)] -> LGuarded c -> LGuarded c

-- | <tt>substFreeAtom s a</tt> substitutes each occurence of a free
--   variables <tt>v</tt> in <tt>dom(s)</tt> with the bound variables
--   <tt>i=s(v)</tt> in the atom <tt>a</tt>.
substFreeAtom :: Ord c => [(LVar, Integer)] -> Atom (VTerm c (BVar LVar)) -> Atom (VTerm c (BVar LVar))

-- | Pretty print a formula.
prettyGuarded :: HighlightDocument d => LNGuarded -> d
instance (NFData s_1627723903, NFData c_1627723904, NFData v_1627723905) => NFData (Guarded s_1627723903 c_1627723904 v_1627723905)
instance (Binary s_1627723903, Binary c_1627723904, Binary v_1627723905) => Binary (Guarded s_1627723903 c_1627723904 v_1627723905)
instance (Eq s, Eq c, Eq v) => Eq (Guarded s c v)
instance (Ord s, Ord c, Ord v) => Ord (Guarded s c v)
instance (Show s, Show c, Show v) => Show (Guarded s c v)
instance Eq t => Eq (GAtom t)
instance Show t => Show (GAtom t)
instance Ord t => Ord (GAtom t)
instance Monoid d => Monoid (ErrorDoc d)
instance NFData d => NFData (ErrorDoc d)
instance Document d => Document (ErrorDoc d)
instance HighlightDocument d => HighlightDocument (ErrorDoc d)
instance Document d => Error (ErrorDoc d)
instance Apply LNGuarded
instance Ord c => HasFrees (Guarded (String, LSort) c LVar)
instance Foldable (Guarded s c)


-- | Types representing constraints.
module Theory.Constraint.System.Constraints

-- | A premise of a node.
type NodePrem = (NodeId, PremIdx)

-- | A conclusion of a node.
type NodeConc = (NodeId, ConcIdx)

-- | A labeled edge in a derivation graph.
data Edge
Edge :: NodeConc -> NodePrem -> Edge
eSrc :: Edge -> NodeConc
eTgt :: Edge -> NodePrem

-- | A *⋖* constraint between <a>NodeId</a>s.
type Less = (NodeId, NodeId)

-- | A <a>Goal</a> denotes that a constraint reduction rule is applicable,
--   which might result in case splits. We either use a heuristic to decide
--   what goal to solve next or leave the choice to user (in case of the
--   interactive UI).
data Goal

-- | An action that must exist in the trace.
ActionG :: LVar -> LNFact -> Goal
ChainG :: NodeConc -> NodePrem -> Goal

-- | A premise that must have an incoming direct edge.
PremiseG :: NodePrem -> LNFact -> Goal

-- | A case split over equalities.
SplitG :: SplitId -> Goal

-- | A case split over a disjunction.
DisjG :: (Disj LNGuarded) -> Goal
isActionGoal :: Goal -> Bool
isStandardActionGoal :: Goal -> Bool
isPremiseGoal :: Goal -> Bool
isChainGoal :: Goal -> Bool
isSplitGoal :: Goal -> Bool
isDisjGoal :: Goal -> Bool

-- | Pretty print a node.
prettyNode :: HighlightDocument d => (NodeId, RuleACInst) -> d

-- | Pretty print a node premise.
prettyNodePrem :: HighlightDocument d => NodePrem -> d

-- | Pretty print a node conclusion.
prettyNodeConc :: HighlightDocument d => NodeConc -> d

-- | Pretty print a edge as <tt>src &gt;-i--j-&gt; tgt</tt>.
prettyEdge :: HighlightDocument d => Edge -> d

-- | Pretty print a less-atom as <tt>src &lt; tgt</tt>.
prettyLess :: HighlightDocument d => Less -> d

-- | Pretty print a goal.
prettyGoal :: HighlightDocument d => Goal -> d
instance NFData Goal
instance NFData Edge
instance Binary Goal
instance Binary Edge
instance Typeable Edge
instance Show Edge
instance Ord Edge
instance Eq Edge
instance Data Edge
instance Eq Goal
instance Ord Goal
instance Show Goal
instance Apply Goal
instance HasFrees Goal
instance HasFrees Edge
instance Apply Edge


-- | This is the public interface for constructing and deconstructing
--   constraint systems. The interface for performing constraint solving
--   provided by <a>Theory.Constraint.Solver</a>.
module Theory.Constraint.System

-- | A constraint system.
data System

-- | The empty constraint system, which is logically equivalent to true.
emptySystem :: CaseDistKind -> System

-- | Whether we are checking for the existence of a trace satisfiying a the
--   current constraint system or whether we're checking that no traces
--   satisfies the current constraint system.
data SystemTraceQuantifier
ExistsSomeTrace :: SystemTraceQuantifier
ExistsNoTrace :: SystemTraceQuantifier

-- | Returns the constraint system that has to be proven to show that given
--   formula holds in the context of the given theory.
formulaToSystem :: [LNGuarded] -> CaseDistKind -> SystemTraceQuantifier -> LNFormula -> System
sNodes :: Arrow arr => Lens arr System (Map NodeId RuleACInst)

-- | A list of all KD-conclusions in the <a>System</a>.
allKDConcs :: System -> [(NodeId, RuleACInst, LNTerm)]

-- | <tt>nodeRule v</tt> accesses the rule label of node <tt>v</tt> under
--   the assumption that it is present in the sequent.
nodeRule :: NodeId -> System -> RuleACInst

-- | <a>nodeConcNode</a> <tt>c</tt> compute the node-id of the node
--   conclusion <tt>c</tt>.
nodeConcNode :: NodeConc -> NodeId

-- | <tt>nodePremNode prem</tt> is the node that this premise is referring
--   to.
nodePremNode :: NodePrem -> NodeId

-- | <tt>nodePremFact prem se</tt> computes the fact associated to premise
--   <tt>prem</tt> in sequent <tt>se</tt> under the assumption that premise
--   <tt>prem</tt> is a a premise in <tt>se</tt>.
nodePremFact :: NodePrem -> System -> LNFact

-- | <tt>nodeConcFact (NodeConc (v, i))</tt> accesses the <tt>i</tt>-th
--   conclusion of the rule associated with node <tt>v</tt> under the
--   assumption that <tt>v</tt> is labeled with a rule that has an
--   <tt>i</tt>-th conclusion.
nodeConcFact :: NodeConc -> System -> LNFact

-- | All facts associated to this node premise.
resolveNodePremFact :: NodePrem -> System -> Maybe LNFact

-- | The fact associated with this node conclusion, if there is one.
resolveNodeConcFact :: NodeConc -> System -> Maybe LNFact

-- | All actions that hold in a sequent.
allActions :: System -> [(NodeId, LNFact)]

-- | All actions that hold in a sequent.
allKUActions :: System -> [(NodeId, LNFact, LNTerm)]

-- | All actions that hold in a sequent.
unsolvedActionAtoms :: System -> [(NodeId, LNFact)]

-- | All KU-actions.
kuActionAtoms :: System -> [(NodeId, LNFact, LNTerm)]

-- | The standard actions, i.e., non-KU-actions.
standardActionAtoms :: System -> [(NodeId, LNFact)]
sEdges :: Arrow arr => Lens arr System (Set Edge)

-- | All unsolved destruction chains in the constraint system.
unsolvedChains :: System -> [(NodeConc, NodePrem)]
sLessAtoms :: Arrow arr => Lens arr System (Set (NodeId, NodeId))

-- | <tt>(from,to)</tt> is in <tt>rawLessRel se</tt> iff we can prove that
--   there is a path (possibly using the <a>Less</a> relation) from
--   <tt>from</tt> to <tt>to</tt> in <tt>se</tt> without appealing to
--   transitivity.
rawLessRel :: System -> [(NodeId, NodeId)]

-- | <tt>(from,to)</tt> is in <tt>rawEdgeRel se</tt> iff we can prove that
--   there is an edge-path from <tt>from</tt> to <tt>to</tt> in <tt>se</tt>
--   without appealing to transitivity.
rawEdgeRel :: System -> [(NodeId, NodeId)]

-- | Returns a predicate that is <a>True</a> iff the first argument happens
--   before the second argument in all models of the sequent.
alwaysBefore :: System -> (NodeId -> NodeId -> Bool)

-- | <a>True</a> iff the given node id is guaranteed to be instantiated to
--   an index in the trace.
isInTrace :: System -> NodeId -> Bool
sLastAtom :: Arrow arr => Lens arr System (Maybe NodeId)

-- | <a>True</a> iff the given node id is guaranteed to be instantiated to
--   the last index of the trace.
isLast :: System -> NodeId -> Bool
sEqStore :: Arrow arr => Lens arr System EqStore

-- | Label to access the free substitution of the equation store.
sSubst :: System :-> LNSubst

-- | Label to access the conjunction of disjunctions of fresh
--   substutitution in the equation store.
sConjDisjEqs :: System :-> Conj (SplitId, Set (LNSubstVFresh))
sFormulas :: Arrow arr => Lens arr System (Set LNGuarded)
sSolvedFormulas :: Arrow arr => Lens arr System (Set LNGuarded)
sLemmas :: Arrow arr => Lens arr System (Set LNGuarded)

-- | Add lemmas / additional assumptions to a constraint system.
insertLemmas :: [LNGuarded] -> System -> System

-- | Case dinstinction kind that are allowed. The order of the kinds
--   corresponds to the subkinding relation: untyped &lt; typed.
data CaseDistKind
UntypedCaseDist :: CaseDistKind
TypedCaseDist :: CaseDistKind
sCaseDistKind :: Arrow arr => Lens arr System CaseDistKind

-- | The status of a <a>Goal</a>. Use its <tt>Semigroup</tt> instance to
--   combine the status info of goals that collapse.
data GoalStatus
GoalStatus :: Bool -> Integer -> Bool -> GoalStatus
_gsSolved :: GoalStatus -> Bool
_gsNr :: GoalStatus -> Integer
_gsLoopBreaker :: GoalStatus -> Bool
gsSolved :: Arrow arr => Lens arr GoalStatus Bool
gsLoopBreaker :: Arrow arr => Lens arr GoalStatus Bool
gsNr :: Arrow arr => Lens arr GoalStatus Integer
sGoals :: Arrow arr => Lens arr System (Map Goal GoalStatus)
sNextGoalNr :: Arrow arr => Lens arr System Integer

-- | Pretty print a sequent
prettySystem :: HighlightDocument d => System -> d

-- | Pretty print the non-graph part of the sequent; i.e. equation store
--   and clauses.
prettyNonGraphSystem :: HighlightDocument d => System -> d
instance NFData SystemTraceQuantifier
instance NFData System
instance NFData GoalStatus
instance NFData CaseDistKind
instance Binary SystemTraceQuantifier
instance Binary System
instance Binary GoalStatus
instance Binary CaseDistKind
instance Show System
instance HasFrees System
instance HasFrees GoalStatus
instance HasFrees CaseDistKind
instance Apply CaseDistKind
instance Eq SystemTraceQuantifier
instance Ord SystemTraceQuantifier
instance Show SystemTraceQuantifier
instance Eq CaseDistKind
instance Eq GoalStatus
instance Ord GoalStatus
instance Show GoalStatus
instance Eq System
instance Ord System
instance Ord CaseDistKind
instance Read CaseDistKind
instance Show CaseDistKind


-- | Common types for our constraint solver. They must be declared jointly
--   because there is a recursive dependency between goals, proof contexts,
--   and case distinctions.
module Theory.Constraint.Solver.Types

-- | A proof context contains the globally fresh facts, classified rewrite
--   rules and the corresponding precomputed premise case distinction
--   theorems.
data ProofContext
ProofContext :: SignatureWithMaude -> ClassifiedRules -> Set FactTag -> CaseDistKind -> [CaseDistinction] -> InductionHint -> SystemTraceQuantifier -> ProofContext
_pcSignature :: ProofContext -> SignatureWithMaude
_pcRules :: ProofContext -> ClassifiedRules
_pcInjectiveFactInsts :: ProofContext -> Set FactTag
_pcCaseDistKind :: ProofContext -> CaseDistKind
_pcCaseDists :: ProofContext -> [CaseDistinction]
_pcUseInduction :: ProofContext -> InductionHint
_pcTraceQuantifier :: ProofContext -> SystemTraceQuantifier
data InductionHint
UseInduction :: InductionHint
AvoidInduction :: InductionHint
pcSignature :: Arrow arr => Lens arr ProofContext SignatureWithMaude
pcRules :: Arrow arr => Lens arr ProofContext ClassifiedRules
pcInjectiveFactInsts :: Arrow arr => Lens arr ProofContext (Set FactTag)
pcCaseDists :: Arrow arr => Lens arr ProofContext [CaseDistinction]
pcCaseDistKind :: Arrow arr => Lens arr ProofContext CaseDistKind
pcUseInduction :: Arrow arr => Lens arr ProofContext InductionHint
pcTraceQuantifier :: Arrow arr => Lens arr ProofContext SystemTraceQuantifier

-- | The <a>MaudeHandle</a> of a proof-context.
pcMaudeHandle :: ProofContext :-> MaudeHandle
data ClassifiedRules
ClassifiedRules :: [RuleAC] -> [RuleAC] -> [RuleAC] -> ClassifiedRules
_crProtocol :: ClassifiedRules -> [RuleAC]
_crDestruct :: ClassifiedRules -> [RuleAC]
_crConstruct :: ClassifiedRules -> [RuleAC]

-- | The empty proof rule set.
emptyClassifiedRules :: ClassifiedRules
crConstruct :: Arrow arr => Lens arr ClassifiedRules [RuleAC]
crDestruct :: Arrow arr => Lens arr ClassifiedRules [RuleAC]
crProtocol :: Arrow arr => Lens arr ClassifiedRules [RuleAC]

-- | <tt>joinAllRules rules</tt> computes the union of all rules classified
--   in <tt>rules</tt>.
joinAllRules :: ClassifiedRules -> [RuleAC]

-- | Extract all non-silent rules.
nonSilentRules :: ClassifiedRules -> [RuleAC]

-- | A big-step case distinction.
data CaseDistinction
CaseDistinction :: Goal -> Disj ([String], System) -> CaseDistinction
_cdGoal :: CaseDistinction -> Goal
_cdCases :: CaseDistinction -> Disj ([String], System)
cdGoal :: Arrow arr => Lens arr CaseDistinction Goal
cdCases :: Arrow arr => Lens arr CaseDistinction (Disj ([String], System))

-- | Pretty print a case distinction
prettyCaseDistinction :: HighlightDocument d => CaseDistinction -> d
instance NFData InductionHint
instance NFData ClassifiedRules
instance NFData CaseDistinction
instance Binary InductionHint
instance Binary ClassifiedRules
instance Binary CaseDistinction
instance HasFrees CaseDistinction
instance Eq CaseDistinction
instance Ord CaseDistinction
instance Show CaseDistinction
instance Eq InductionHint
instance Ord InductionHint
instance Show InductionHint
instance Eq ProofContext
instance Ord ProofContext
instance Show ProofContext
instance Eq ClassifiedRules
instance Ord ClassifiedRules
instance Show ClassifiedRules


-- | This is the public interface for constructing and deconstructing
--   constraint systems. The interface for performing constraint solving
--   provided by <a>Theory.Constraint.Solver</a>.
module Theory.Constraint.Solver.Contradictions

-- | Reasons why a constraint <a>System</a> can be contradictory.
data Contradiction

-- | The paths are cyclic.
Cyclic :: Contradiction

-- | Has terms that are not in normal form. | NonLastNode -- ^ Has a
--   non-silent node after the last node.
NonNormalTerms :: Contradiction

-- | Forbidden Exp-down rule instance
ForbiddenExp :: Contradiction

-- | Forbidden bilinear pairing rule instance
ForbiddenBP :: Contradiction

-- | has forbidden KD-fact
ForbiddenKD :: Contradiction

-- | has impossible chain
ImpossibleChain :: Contradiction

-- | Contradicts that certain facts have unique instances.
NonInjectiveFactInstance :: (NodeId, NodeId, NodeId) -> Contradiction

-- | Incompatible equalities.
IncompatibleEqs :: Contradiction

-- | False in formulas
FormulasFalse :: Contradiction

-- | A term is derived both before and after a learn
SuperfluousLearn :: LNTerm -> NodeId -> Contradiction

-- | There is a node after the last node.
NodeAfterLast :: (NodeId, NodeId) -> Contradiction
substCreatesNonNormalTerms :: MaudeHandle -> System -> LNSubst -> LNSubstVFresh -> Bool

-- | All CR-rules reducing a constraint system to *⟂* represented as a list
--   of trivial contradictions. Note that some constraint systems are also
--   removed because they have no unifier. This is part of unification.
--   Note also that *S_{¬,@}* is handled as part of *S_∀*.
contradictions :: ProofContext -> System -> [Contradiction]

-- | <a>True</a> if the constraint system is contradictory.
contradictorySystem :: ProofContext -> System -> Bool

-- | Pretty-print a <a>Contradiction</a>.
prettyContradiction :: Document d => Contradiction -> d
instance NFData Contradiction
instance Binary Contradiction
instance Eq Contradiction
instance Ord Contradiction
instance Show Contradiction
instance HasFrees Contradiction


-- | A monad for writing constraint reduction steps together with basic
--   steps for inserting nodes, edges, actions, and equations and applying
--   substitutions.
module Theory.Constraint.Solver.Reduction

-- | A constraint reduction step. Its state is the current constraint
--   system, it can generate fresh names, split over cases, and access the
--   proof context.
type Reduction = StateT System (FreshT (DisjT (Reader ProofContext)))

-- | Run a constraint reduction returning only the updated constraint
--   systems and the new freshness states.
execReduction :: Reduction a -> ProofContext -> System -> FreshState -> Disj (System, FreshState)

-- | Run a constraint reduction. Returns a list of constraint systems whose
--   combined solutions are equal to the solutions of the given system.
--   This property is obviously not enforced, but it must be respected by
--   all functions of type <a>Reduction</a>.
runReduction :: Reduction a -> ProofContext -> System -> FreshState -> Disj ((a, System), FreshState)

-- | Indicate whether the constraint system was changed or not.
data ChangeIndicator
Unchanged :: ChangeIndicator
Changed :: ChangeIndicator

-- | Only apply a monadic action, if there has been a change.
whenChanged :: Monad m => ChangeIndicator -> m () -> m ()

-- | Apply a list of changes to the proof state.
applyChangeList :: [Reduction ()] -> Reduction ChangeIndicator

-- | Execute a <a>Reduction</a> as long as it results in changes. Indicate
--   whether at least one change was performed.
whileChanging :: Reduction ChangeIndicator -> Reduction ChangeIndicator

-- | Retrieve the <a>ProofContext</a>.
getProofContext :: Reduction ProofContext

-- | Retrieve the <a>MaudeHandle</a> from the <a>ProofContext</a>.
getMaudeHandle :: Reduction MaudeHandle

-- | Label a node-id with a fresh instance of one of the rules and solve
--   it's <tt>Fr</tt>, <tt>In</tt>, and <tt>KU</tt> premises immediatly.
--   
--   PRE: Node must not yet be labelled with a rule.
labelNodeId :: NodeId -> [RuleAC] -> Reduction RuleACInst

-- | Insert a fresh rule node labelled with a fresh instance of one of the
--   rules and solve it's <tt>Fr</tt>, <tt>In</tt>, and <tt>KU</tt>
--   premises immediatly.
insertFreshNode :: [RuleAC] -> Reduction (NodeId, RuleACInst)

-- | Insert a fresh rule node labelled with a fresh instance of one of the
--   rules and return one of the conclusions.
insertFreshNodeConc :: [RuleAC] -> Reduction (RuleACInst, NodeConc, LNFact)

-- | Insert a <a>Goal</a> and store its age.
insertGoal :: Goal -> Bool -> Reduction ()

-- | Insert an atom. Returns <a>Changed</a> if another part of the
--   constraint system than the set of actions was changed.
insertAtom :: LNAtom -> Reduction ChangeIndicator

-- | Insert an edge constraint. CR-rule *DG1_2* is enforced automatically,
--   i.e., the fact equalities are enforced.
insertEdges :: [(NodeConc, LNFact, LNFact, NodePrem)] -> Reduction ()

-- | Insert a chain constrain.
insertChain :: NodeConc -> NodePrem -> Reduction ()

-- | Insert an <a>Action</a> atom. Ensures that (almost all) trivial *KU*
--   actions are solved immediately using rule *S_{at,u,triv}*. We
--   currently avoid adding intermediate products. Indicates whether nodes
--   other than the given action have been added to the constraint system.
--   
--   FIXME: Ensure that intermediate products are also solved before
--   stating that no rule is applicable.
insertAction :: NodeId -> LNFact -> Reduction ChangeIndicator

-- | Insert a <a>Less</a> atom. <tt>insertLess i j</tt> means that *i &lt;
--   j* is added.
insertLess :: NodeId -> NodeId -> Reduction ()

-- | Insert a <a>Guarded</a> formula. Ensures that existentials,
--   conjunctions, negated last atoms, and negated less atoms, are
--   immediately solved using the rules *S_exists*, *S_and*, *S_not,last*,
--   and *S_not,less*. Only the inserted formula is marked as solved. Other
--   intermediate formulas are not marked.
insertFormula :: LNGuarded -> Reduction ()

-- | <a>True</a> iff the formula can be reduced by one of the rules
--   implemented in <a>insertFormula</a>.
reducibleFormula :: LNGuarded -> Bool

-- | Mark the given goal as solved.
markGoalAsSolved :: String -> Goal -> Reduction ()
removeSolvedSplitGoals :: Reduction ()

-- | Apply the current substitution of the equation store to the remainder
--   of the sequent.
substSystem :: Reduction ChangeIndicator

-- | Apply the current substitution of the equation store the nodes of the
--   constraint system. Indicates whether additional equalities were added
--   to the equations store.
substNodes :: Reduction ChangeIndicator
substEdges :: Reduction ()
substLastAtom :: Reduction ()
substLessAtoms :: Reduction ()
substFormulas :: Reduction ()
substSolvedFormulas :: Reduction ()

-- | <a>SplitStrategy</a> denotes if the equation store should be split
--   into multiple equation stores.
data SplitStrategy
SplitNow :: SplitStrategy
SplitLater :: SplitStrategy

-- | Add a list of node equalities to the equation store.
solveNodeIdEqs :: [Equal NodeId] -> Reduction ChangeIndicator

-- | Add a list of term equalities to the equation store. And split
--   resulting disjunction of equations according to given split strategy.
--   
--   Note that updating the remaining parts of the constraint system with
--   the substitution has to be performed using a separate call to
--   <a>substSystem</a>.
solveTermEqs :: SplitStrategy -> [Equal LNTerm] -> Reduction ChangeIndicator

-- | Add a list of fact equalities to the equation store, if possible.
solveFactEqs :: SplitStrategy -> [Equal LNFact] -> Reduction ChangeIndicator

-- | Add a list of rule equalities to the equation store, if possible.
solveRuleEqs :: SplitStrategy -> [Equal RuleACInst] -> Reduction ChangeIndicator

-- | Add a list of equalities in substitution form to the equation store
solveSubstEqs :: SplitStrategy -> LNSubst -> Reduction ChangeIndicator

-- | <tt>conjoinSystem se</tt> conjoins the logical information in
--   <tt>se</tt> to the constraint system. It assumes that the free
--   variables in <tt>se</tt> are shared with the free variables in the
--   proof state.
conjoinSystem :: System -> Reduction ()
instance Eq ChangeIndicator
instance Ord ChangeIndicator
instance Show ChangeIndicator
instance Monoid ChangeIndicator


-- | The constraint reduction rules, which are not enforced as invariants
--   in <a>Theory.Constraint.Solver.Reduction</a>.
--   
--   A goal represents a possible application of a rule that may result in
--   multiple cases or even non-termination (if applied repeatedly). These
--   goals are computed as the list of <a>openGoals</a>. See
--   <a>Theory.Constraint.Solver.ProofMethod</a> for the public interface
--   to solving goals and the implementation of heuristics.
module Theory.Constraint.Solver.Goals
data Usefulness

-- | A goal that is likely to result in progress.
Useful :: Usefulness

-- | A goal that is delayed to avoid immediate termination.
LoopBreaker :: Usefulness

-- | A goal that is likely to be constructible by the adversary.
ProbablyConstructible :: Usefulness

-- | A message that is deducible for the current solution.
CurrentlyDeducible :: Usefulness

-- | Goals annotated with their number and usefulness.
type AnnotatedGoal = (Goal, (Integer, Usefulness))

-- | The list of goals that must be solved before a solution can be
--   extracted. Each goal is annotated with its age and an indicator for
--   its usefulness.
openGoals :: System -> [AnnotatedGoal]

-- | <tt>solveGoal rules goal</tt> enumerates all possible cases of how
--   this goal could be solved in the context of the given <tt>rules</tt>.
--   For each case, a sensible case-name is returned.
solveGoal :: Goal -> Reduction String
instance Show Usefulness
instance Eq Usefulness
instance Ord Usefulness


-- | This module implements all rules that do not result in case
--   distinctions and equation solving. Some additional cases may although
--   result from splitting over multiple AC-unifiers. Note that a few of
--   these rules are implemented directly in the methods for inserting
--   constraints to the constraint system. These methods are provided by
--   <a>Theory.Constraint.Solver.Reduction</a>.
module Theory.Constraint.Solver.Simplify

-- | Apply CR-rules that don't result in case splitting until the
--   constraint system does not change anymore.
simplifySystem :: Reduction ()
instance Typeable SkConst
instance Eq SkConst
instance Ord SkConst
instance Show SkConst
instance Data SkConst
instance IsConst SkConst


-- | Big-step proofs using case distinctions on the possible sources of a
--   fact.
module Theory.Constraint.Solver.CaseDistinctions

-- | The number of remaining chain constraints of each case.
unsolvedChainConstraints :: CaseDistinction -> [Int]

-- | Precompute a saturated set of case distinctions.
precomputeCaseDistinctions :: ProofContext -> [LNGuarded] -> [CaseDistinction]

-- | Refine a set of case distinction by exploiting additional typing
--   assumptions.
refineWithTypingAsms :: [LNGuarded] -> ProofContext -> [CaseDistinction] -> [CaseDistinction]

-- | Try to solve a premise goal or <tt>KU</tt> action using the first
--   precomputed case distinction with a matching premise.
solveWithCaseDistinction :: ProofContext -> [CaseDistinction] -> Goal -> Maybe (Reduction [String])

-- | Given a list of stable variables (that are referenced from outside and
--   cannot be simply renamed) and a list containing systems, this function
--   returns a subsequence of the list such that for all removed systems,
--   there is a remaining system that is equal modulo renaming of
--   non-stable variables.
removeRedundantCases :: ProofContext -> [LVar] -> (a -> System) -> [a] -> [a]


-- | Proof methods and heuristics: the external small-step interface to the
--   constraint solver.
module Theory.Constraint.Solver.ProofMethod

-- | Every case in a proof is uniquely named.
type CaseName = String

-- | Sound transformations of sequents.
data ProofMethod

-- | Proof was not completed
Sorry :: (Maybe String) -> ProofMethod

-- | An attack was fond
Solved :: ProofMethod

-- | A simplification step.
Simplify :: ProofMethod

-- | A goal that was solved.
SolveGoal :: Goal -> ProofMethod

-- | A contradiction could be derived, possibly with a reason.
Contradiction :: (Maybe Contradiction) -> ProofMethod

-- | Use inductive strengthening on the single formula constraint in the
--   system.
Induction :: ProofMethod
execProofMethod :: ProofContext -> ProofMethod -> System -> Maybe (Map CaseName System)

-- | The different available functions to rank goals with respect to their
--   order of solving in a constraint system.
data GoalRanking
GoalNrRanking :: GoalRanking
UsefulGoalNrRanking :: GoalRanking
SmartRanking :: Bool -> GoalRanking

-- | The name/explanation of a <a>GoalRanking</a>.
goalRankingName :: GoalRanking -> String

-- | Use a <a>GoalRanking</a> to generate the ranked, list of possible
--   <a>ProofMethod</a>s and their corresponding results in this
--   <a>ProofContext</a> and for this <a>System</a>. If the resulting list
--   is empty, then the constraint system is solved.
rankProofMethods :: GoalRanking -> ProofContext -> System -> [(ProofMethod, (Map CaseName System, String))]
data Heuristic

-- | Smart constructor for heuristics. Schedules the goal rankings in a
--   round-robin fashion dependent on the proof depth.
roundRobinHeuristic :: [GoalRanking] -> Heuristic

-- | Use a heuristic to schedule a <a>GoalRanking</a> according to the
--   given proof-depth.
useHeuristic :: Heuristic -> Int -> GoalRanking

-- | Pretty-print a proof method.
prettyProofMethod :: HighlightDocument d => ProofMethod -> d
instance NFData Heuristic
instance NFData GoalRanking
instance NFData ProofMethod
instance Binary Heuristic
instance Binary GoalRanking
instance Binary ProofMethod
instance Eq ProofMethod
instance Ord ProofMethod
instance Show ProofMethod
instance Eq GoalRanking
instance Ord GoalRanking
instance Show GoalRanking
instance Eq Heuristic
instance Ord Heuristic
instance Show Heuristic
instance HasFrees ProofMethod


-- | The public interface of the constraint solver, which implements all
--   constraint reduction rules and together with a rule application
--   heuristic.
module Theory.Constraint.Solver

-- | A proof context contains the globally fresh facts, classified rewrite
--   rules and the corresponding precomputed premise case distinction
--   theorems.
data ProofContext
ProofContext :: SignatureWithMaude -> ClassifiedRules -> Set FactTag -> CaseDistKind -> [CaseDistinction] -> InductionHint -> SystemTraceQuantifier -> ProofContext
_pcSignature :: ProofContext -> SignatureWithMaude
_pcRules :: ProofContext -> ClassifiedRules
_pcInjectiveFactInsts :: ProofContext -> Set FactTag
_pcCaseDistKind :: ProofContext -> CaseDistKind
_pcCaseDists :: ProofContext -> [CaseDistinction]
_pcUseInduction :: ProofContext -> InductionHint
_pcTraceQuantifier :: ProofContext -> SystemTraceQuantifier
pcSignature :: Arrow arr => Lens arr ProofContext SignatureWithMaude
pcRules :: Arrow arr => Lens arr ProofContext ClassifiedRules
pcCaseDists :: Arrow arr => Lens arr ProofContext [CaseDistinction]
pcUseInduction :: Arrow arr => Lens arr ProofContext InductionHint
pcCaseDistKind :: Arrow arr => Lens arr ProofContext CaseDistKind
pcTraceQuantifier :: Arrow arr => Lens arr ProofContext SystemTraceQuantifier
pcInjectiveFactInsts :: Arrow arr => Lens arr ProofContext (Set FactTag)
data InductionHint
UseInduction :: InductionHint
AvoidInduction :: InductionHint
data ClassifiedRules
ClassifiedRules :: [RuleAC] -> [RuleAC] -> [RuleAC] -> ClassifiedRules
_crProtocol :: ClassifiedRules -> [RuleAC]
_crDestruct :: ClassifiedRules -> [RuleAC]
_crConstruct :: ClassifiedRules -> [RuleAC]

-- | <tt>joinAllRules rules</tt> computes the union of all rules classified
--   in <tt>rules</tt>.
joinAllRules :: ClassifiedRules -> [RuleAC]
crProtocol :: Arrow arr => Lens arr ClassifiedRules [RuleAC]
crConstruct :: Arrow arr => Lens arr ClassifiedRules [RuleAC]
crDestruct :: Arrow arr => Lens arr ClassifiedRules [RuleAC]

-- | Reasons why a constraint <a>System</a> can be contradictory.
data Contradiction

-- | All CR-rules reducing a constraint system to *⟂* represented as a list
--   of trivial contradictions. Note that some constraint systems are also
--   removed because they have no unifier. This is part of unification.
--   Note also that *S_{¬,@}* is handled as part of *S_∀*.
contradictions :: ProofContext -> System -> [Contradiction]

-- | A big-step case distinction.
data CaseDistinction
cdGoal :: Arrow arr => Lens arr CaseDistinction Goal
cdCases :: Arrow arr => Lens arr CaseDistinction (Disj ([String], System))

-- | Precompute a saturated set of case distinctions.
precomputeCaseDistinctions :: ProofContext -> [LNGuarded] -> [CaseDistinction]

-- | Refine a set of case distinction by exploiting additional typing
--   assumptions.
refineWithTypingAsms :: [LNGuarded] -> ProofContext -> [CaseDistinction] -> [CaseDistinction]

-- | The number of remaining chain constraints of each case.
unsolvedChainConstraints :: CaseDistinction -> [Int]


-- | Types to represent proofs.
module Theory.Proof

-- | Trees with uniquely labelled edges.
data LTree l a
LNode :: a -> Map l (LTree l a) -> LTree l a
root :: LTree l a -> a
children :: LTree l a -> Map l (LTree l a)

-- | <i>O(n+m)</i>. A generalized union operator for maps with differing
--   types.
mergeMapsWith :: Ord k => (a -> c) -> (b -> c) -> (a -> b -> c) -> Map k a -> Map k b -> Map k c

-- | A proof steps is a proof method together with additional
--   context-dependent information.
data ProofStep a
ProofStep :: ProofMethod -> a -> ProofStep a
psMethod :: ProofStep a -> ProofMethod
psInfo :: ProofStep a -> a

-- | A proof is a tree of proof steps whose edges are labelled with case
--   names.
type Proof a = LTree CaseName (ProofStep a)

-- | A path to a subproof.
type ProofPath = [CaseName]

-- | <tt>prf <a>atPath</a> path</tt> returns the subproof at the
--   <tt>path</tt> in <tt>prf</tt>.
atPath :: Proof a -> ProofPath -> Maybe (Proof a)

-- | <tt>insertPaths prf</tt> inserts the path to every proof node.
insertPaths :: Proof a -> Proof (a, ProofPath)

-- | Apply a function to the information of every proof step.
mapProofInfo :: (a -> b) -> Proof a -> Proof b

-- | Fold a proof.
foldProof :: Monoid m => (ProofStep a -> m) -> Proof a -> m

-- | Annotate a proof in a bottom-up fashion.
annotateProof :: (ProofStep a -> [b] -> b) -> Proof a -> Proof b

-- | The status of a <a>Proof</a>.
data ProofStatus

-- | All steps are unannotated
UndeterminedProof :: ProofStatus

-- | The proof is complete: no annotated sorry, no annotated solved step
CompleteProof :: ProofStatus

-- | There is a annotated sorry, but no annotatd solved step.
IncompleteProof :: ProofStatus

-- | There is an annotated solved step
TraceFound :: ProofStatus

-- | The status of a <a>ProofStep</a>.
proofStepStatus :: ProofStep (Maybe a) -> ProofStatus

-- | A proof using the <a>sorry</a> proof method.
sorry :: Maybe String -> a -> Proof a

-- | A proof denoting an unproven part of the proof.
unproven :: a -> Proof a

-- | Incremental proofs are used to represent intermediate results of proof
--   checking/construction.
type IncrementalProof = Proof (Maybe System)

-- | Provers whose sequencing is handled via the <a>Monoid</a> instance.
--   
--   <pre>
--   p1 `mappend` p2
--   </pre>
--   
--   Is a prover that first runs p1 and then p2 on the resulting proof.
data Prover
runProver :: Prover -> ProofContext -> Int -> System -> IncrementalProof -> Maybe IncrementalProof

-- | Map the proof generated by the prover.
mapProverProof :: (IncrementalProof -> IncrementalProof) -> Prover -> Prover

-- | Resorts to the second prover, if the first one is not successful.
orelse :: Prover -> Prover -> Prover

-- | Try to apply a prover. If it fails, just return the original proof.
tryProver :: Prover -> Prover

-- | Replace the current proof with a sorry step and the given reason.
sorryProver :: Maybe String -> Prover

-- | Try to execute one proof step using the given proof method.
oneStepProver :: ProofMethod -> Prover

-- | Apply a prover only to a sub-proof, fails if the subproof doesn't
--   exist.
focus :: ProofPath -> Prover -> Prover

-- | Check the proof and handle new cases using the given prover.
checkAndExtendProver :: Prover -> Prover

-- | Replace all annotated sorry steps using the given prover.
replaceSorryProver :: Prover -> Prover

-- | Prover that does one contradiction step.
contradictionProver :: Prover
data SolutionExtractor
CutDFS :: SolutionExtractor
CutBFS :: SolutionExtractor
CutNothing :: SolutionExtractor
data AutoProver
AutoProver :: Heuristic -> Maybe Int -> SolutionExtractor -> AutoProver
apHeuristic :: AutoProver -> Heuristic
apBound :: AutoProver -> Maybe Int
apCut :: AutoProver -> SolutionExtractor
runAutoProver :: AutoProver -> Prover
prettyProof :: HighlightDocument d => Proof a -> d
prettyProofWith :: HighlightDocument d => (ProofStep a -> d) -> (ProofStep a -> d -> d) -> Proof a -> d

-- | Convert a proof status to a redable string.
showProofStatus :: SystemTraceQuantifier -> ProofStatus -> String

-- | A parallel evaluation strategy well-suited for DFS traversal: As soon
--   as a node is forced it sparks off the computation of the number of
--   case-maps of all its children. This way most of the data is already
--   evaulated, when the actual DFS traversal visits it.
--   
--   NOT used for now. It sometimes required too much memory.
parLTreeDFS :: Strategy (LTree l a)
instance (Ord l, Binary l, Binary a) => Binary (LTree l a)
instance (Ord l, NFData l, NFData a) => NFData (LTree l a)
instance NFData AutoProver
instance NFData SolutionExtractor
instance NFData ProofStatus
instance NFData a_1628259371 => NFData (ProofStep a_1628259371)
instance Binary AutoProver
instance Binary SolutionExtractor
instance Binary ProofStatus
instance Binary a_1628259371 => Binary (ProofStep a_1628259371)
instance (Eq l, Eq a) => Eq (LTree l a)
instance (Ord l, Ord a) => Ord (LTree l a)
instance (Show l, Show a) => Show (LTree l a)
instance Eq a => Eq (ProofStep a)
instance Ord a => Ord (ProofStep a)
instance Show a => Show (ProofStep a)
instance Eq SolutionExtractor
instance Ord SolutionExtractor
instance Show SolutionExtractor
instance Read SolutionExtractor
instance Monoid IterDeepRes
instance Monoid Prover
instance Monoid ProofStatus
instance HasFrees a => HasFrees (ProofStep a)
instance Traversable ProofStep
instance Foldable ProofStep
instance Functor ProofStep
instance Traversable (LTree l)
instance Foldable (LTree l)
instance Functor (LTree l)


-- | Conversion of the graph part of a sequent to a Graphviz Dot file.
module Theory.Constraint.System.Dot

-- | <a>True</a> iff the dotted system will be a non-empty graph.
nonEmptyGraph :: System -> Bool

-- | Convert the sequent to a <a>Dot</a> action representing this sequent
--   as a graph in the GraphViz format. The style is loose in the sense
--   that each premise and conclusion gets its own node.
dotSystemLoose :: System -> Dot ()

-- | Dot a sequent in compact form (one record per rule), if there is
--   anything to draw.
dotSystemCompact :: BoringNodeStyle -> System -> Dot ()

-- | Unsound compression of the sequent that drops fully connected learns
--   and knows nodes.
compressSystem :: System -> System

-- | The style for nodes of the intruder.
data BoringNodeStyle
FullBoringNodes :: BoringNodeStyle
CompactBoringNodes :: BoringNodeStyle
instance Eq BoringNodeStyle
instance Ord BoringNodeStyle
instance Show BoringNodeStyle


-- | Theory datatype and transformations on it.
module Theory

-- | An axiom describes a property that must hold for all traces. Axioms
--   are always used as lemmas in proofs.
data Axiom
Axiom :: String -> LNFormula -> Axiom
_axName :: Axiom -> String
_axFormula :: Axiom -> LNFormula
axName :: Arrow arr => Lens arr Axiom String
axFormula :: Arrow arr => Lens arr Axiom LNFormula

-- | An attribute for a <a>Lemma</a>.
data LemmaAttribute
TypingLemma :: LemmaAttribute
ReuseLemma :: LemmaAttribute
InvariantLemma :: LemmaAttribute

-- | A <a>TraceQuantifier</a> stating whether we check satisfiability of
--   validity.
data TraceQuantifier
ExistsTrace :: TraceQuantifier
AllTraces :: TraceQuantifier

-- | A lemma describes a property that holds in the context of a theory
--   together with a proof of its correctness.
data Lemma p
lName :: Arrow arr => Lens arr (Lemma p) String
lTraceQuantifier :: Arrow arr => Lens arr (Lemma p) TraceQuantifier
lFormula :: Arrow arr => Lens arr (Lemma p) LNFormula
lAttributes :: Arrow arr => Lens arr (Lemma p) [LemmaAttribute]
lProof :: Arrow arr => Lens arr (Lemma p) p

-- | Create a new unproven lemma from a formula modulo E.
unprovenLemma :: String -> [LemmaAttribute] -> TraceQuantifier -> LNFormula -> Lemma ProofSkeleton
skeletonLemma :: String -> [LemmaAttribute] -> TraceQuantifier -> LNFormula -> ProofSkeleton -> Lemma ProofSkeleton

-- | A theory contains a single set of rewriting rules modeling a protocol
--   and the lemmas that
data Theory sig c r p
Theory :: String -> sig -> c -> [TheoryItem r p] -> Theory sig c r p
_thyName :: Theory sig c r p -> String
_thySignature :: Theory sig c r p -> sig
_thyCache :: Theory sig c r p -> c
_thyItems :: Theory sig c r p -> [TheoryItem r p]

-- | A theory item built over the given rule type.
data TheoryItem r p
RuleItem :: r -> TheoryItem r p
LemmaItem :: (Lemma p) -> TheoryItem r p
AxiomItem :: Axiom -> TheoryItem r p
TextItem :: FormalComment -> TheoryItem r p
thyName :: Arrow arr => Lens arr (Theory sig c r p) String
thySignature :: Arrow arr => Lens arr (Theory sig c r p) sig
thyCache :: Arrow arr => Lens arr (Theory sig c r p) c
thyItems :: Arrow arr => Lens arr (Theory sig c r p) [TheoryItem r p]

-- | All rules of a theory.
theoryRules :: Theory sig c r p -> [r]

-- | All lemmas of a theory.
theoryLemmas :: Theory sig c r p -> [Lemma p]

-- | All axioms of a theory.
theoryAxioms :: Theory sig c r p -> [Axiom]

-- | Add a new axiom. Fails, if axiom with the same name exists.
addAxiom :: Axiom -> Theory sig c r p -> Maybe (Theory sig c r p)

-- | Add a new lemma. Fails, if a lemma with the same name exists.
addLemma :: Lemma p -> Theory sig c r p -> Maybe (Theory sig c r p)

-- | Remove a lemma by name. Fails, if the lemma does not exist.
removeLemma :: String -> Theory sig c r p -> Maybe (Theory sig c r p)

-- | Find the lemma with the given name.
lookupLemma :: String -> Theory sig c r p -> Maybe (Lemma p)

-- | Add a comment to the theory.
addComment :: Doc -> Theory sig c r p -> Theory sig c r p

-- | Add a comment represented as a string to the theory.
addStringComment :: String -> Theory sig c r p -> Theory sig c r p
addFormalComment :: FormalComment -> Theory sig c r p -> Theory sig c r p
cprRuleE :: Arrow arr => Lens arr ClosedProtoRule ProtoRuleE

-- | Open theories can be extended. Invariants: 1. Lemma names are unique.
type OpenTheory = Theory SignaturePure [IntrRuleAC] OpenProtoRule ProofSkeleton

-- | Default theory
defaultOpenTheory :: OpenTheory

-- | Add a new protocol rules. Fails, if a protocol rule with the same name
--   exists.
addProtoRule :: ProtoRuleE -> OpenTheory -> Maybe OpenTheory

-- | Apply partial evaluation.
applyPartialEvaluation :: EvaluationStyle -> ClosedTheory -> ClosedTheory

-- | Add intruder proof rules.
addIntrRuleACs :: [IntrRuleAC] -> OpenTheory -> OpenTheory

-- | Normalize the theory representation such that they remain semantically
--   equivalent. Use this function when you want to compare two theories
--   (quite strictly) for semantic equality; e.g., when testing the parser.
normalizeTheory :: OpenTheory -> OpenTheory

-- | Closed theories can be proven. Invariants: 1. Lemma names are unique
--   2. All proof steps with annotated sequents are sound with respect to
--   the closed rule set of the theory. 3. Maude is running under the given
--   handle.
type ClosedTheory = Theory SignatureWithMaude ClosedRuleCache ClosedProtoRule IncrementalProof
data ClosedRuleCache
ClosedRuleCache :: ClassifiedRules -> [CaseDistinction] -> [CaseDistinction] -> Set FactTag -> ClosedRuleCache
_crcRules :: ClosedRuleCache -> ClassifiedRules
_crcUntypedCaseDists :: ClosedRuleCache -> [CaseDistinction]
_crcTypedCaseDists :: ClosedRuleCache -> [CaseDistinction]
_crcInjectiveFactInsts :: ClosedRuleCache -> Set FactTag

-- | Close a theory by closing its associated rule set and checking the
--   proof skeletons and caching AC variants as well as precomputed case
--   distinctions.
--   
--   This function initializes the relation to the Maude process with the
--   correct signature. This is the right place to do that because in a
--   closed theory the signature may not change any longer.
closeTheory :: FilePath -> OpenTheory -> IO ClosedTheory

-- | Open a theory by dropping the closed world assumption and values whose
--   soundness dependens on it.
openTheory :: ClosedTheory -> OpenTheory

-- | A closed proto rule lists its original rule modulo E, the
--   corresponding variant modulo AC, and if required the assertion
--   soundness proof.
data ClosedProtoRule
ClosedProtoRule :: ProtoRuleE -> ProtoRuleAC -> ClosedProtoRule
_cprRuleE :: ClosedProtoRule -> ProtoRuleE
_cprRuleAC :: ClosedProtoRule -> ProtoRuleAC

-- | All lemmas.
getLemmas :: ClosedTheory -> [Lemma IncrementalProof]

-- | The variants of the intruder rules.
getIntrVariants :: ClosedTheory -> [IntrRuleAC]

-- | All protocol rules modulo E.
getProtoRuleEs :: ClosedTheory -> [ProtoRuleE]

-- | Get the proof context for a lemma of the closed theory.
getProofContext :: Lemma a -> ClosedTheory -> ProofContext

-- | The classified set of rules modulo AC in this theory.
getClassifiedRules :: ClosedTheory -> ClassifiedRules

-- | The facts with injective instances in this theory
getInjectiveFactInsts :: ClosedTheory -> Set FactTag

-- | The precomputed case distinctions.
getCaseDistinction :: CaseDistKind -> ClosedTheory -> [CaseDistinction]

-- | Proof skeletons are used to represent proofs in open theories.
type ProofSkeleton = Proof ()

-- | Prove both the assertion soundness as well as all lemmas of the
--   theory. If the prover fails on a lemma, then its proof remains
--   unchanged.
proveTheory :: (Lemma IncrementalProof -> Bool) -> Prover -> ClosedTheory -> ClosedTheory

-- | Resolve a path in a theory.
lookupLemmaProof :: LemmaRef -> ClosedTheory -> Maybe IncrementalProof

-- | Modify the proof at the given lemma ref, if there is one. Fails if the
--   path is not present or if the prover fails.
modifyLemmaProof :: Prover -> LemmaRef -> ClosedTheory -> Maybe ClosedTheory

-- | Pretty print a formal comment
prettyFormalComment :: HighlightDocument d => String -> String -> d

-- | Pretty print the lemma name together with its attributes.
prettyLemmaName :: HighlightDocument d => Lemma p -> d

-- | Pretty print an axiom.
prettyAxiom :: HighlightDocument d => Axiom -> d

-- | Pretty print a lemma.
prettyLemma :: HighlightDocument d => (p -> d) -> Lemma p -> d

-- | Pretty print a closed theory.
prettyClosedTheory :: HighlightDocument d => ClosedTheory -> d

-- | Pretty print an open theory.
prettyOpenTheory :: HighlightDocument d => OpenTheory -> d
prettyClosedSummary :: Document d => ClosedTheory -> d

-- | Pretty-print a non-empty bunch of intruder rules.
prettyIntruderVariants :: HighlightDocument d => [IntrRuleAC] -> d

-- | Pretty print a <a>TraceQuantifier</a>.
prettyTraceQuantifier :: Document d => TraceQuantifier -> d
instance (NFData sig_1628398556, NFData c_1628398557, NFData r_1628398558, NFData p_1628398559) => NFData (Theory sig_1628398556 c_1628398557 r_1628398558 p_1628398559)
instance NFData ClosedRuleCache
instance NFData ClosedProtoRule
instance NFData p_1628398076 => NFData (Lemma p_1628398076)
instance NFData Axiom
instance NFData TraceQuantifier
instance NFData LemmaAttribute
instance (NFData r_1628398560, NFData p_1628398561) => NFData (TheoryItem r_1628398560 p_1628398561)
instance (Binary sig_1628398556, Binary c_1628398557, Binary r_1628398558, Binary p_1628398559) => Binary (Theory sig_1628398556 c_1628398557 r_1628398558 p_1628398559)
instance Binary ClosedRuleCache
instance Binary ClosedProtoRule
instance Binary p_1628398076 => Binary (Lemma p_1628398076)
instance Binary Axiom
instance Binary TraceQuantifier
instance Binary LemmaAttribute
instance (Binary r_1628398560, Binary p_1628398561) => Binary (TheoryItem r_1628398560 p_1628398561)
instance (Show r, Show p) => Show (TheoryItem r p)
instance (Eq r, Eq p) => Eq (TheoryItem r p)
instance (Ord r, Ord p) => Ord (TheoryItem r p)
instance Functor (TheoryItem r)
instance (Eq sig, Eq c, Eq r, Eq p) => Eq (Theory sig c r p)
instance (Ord sig, Ord c, Ord r, Ord p) => Ord (Theory sig c r p)
instance (Show sig, Show c, Show r, Show p) => Show (Theory sig c r p)
instance Traversable Lemma
instance Foldable Lemma
instance Functor Lemma
instance Eq LemmaAttribute
instance Ord LemmaAttribute
instance Show LemmaAttribute
instance Eq TraceQuantifier
instance Ord TraceQuantifier
instance Show TraceQuantifier
instance Eq p => Eq (Lemma p)
instance Ord p => Ord (Lemma p)
instance Show p => Show (Lemma p)
instance Eq Axiom
instance Ord Axiom
instance Show Axiom
instance HasRuleName ClosedProtoRule
instance Eq ClosedProtoRule
instance Ord ClosedProtoRule
instance Show ClosedProtoRule
instance Eq ClosedRuleCache
instance Ord ClosedRuleCache
instance Show ClosedRuleCache


-- | Tokenizing infrastructure
module Theory.Text.Parser.Token

-- | Parse a symbol.
symbol :: String -> Parser String

-- | Parse a symbol without returning the parsed string.
symbol_ :: String -> Parser ()

-- | A dot <tt>.</tt>.
dot :: Parser ()

-- | A comma <tt>,</tt>.
comma :: Parser ()

-- | A colon <tt>:</tt>.
colon :: Parser ()

-- | Parse an natural.
natural :: Parser Integer

-- | Parse a Unicode-subscripted natural number.
naturalSubscript :: Parser Integer

-- | A formal comment; i.e., (header, body)
formalComment :: Parser (String, String)

-- | Parse an identifier as a string
identifier :: Parser String

-- | Parse an identifier possibly indexed with a number.
indexedIdentifier :: Parser (String, Integer)

-- | Parse a literal fresh name, e.g., <tt>~<tt>n</tt></tt>.
freshName :: Parser String

-- | Parse a literal public name, e.g., <tt><tt>n</tt></tt>.
pubName :: Parser String

-- | Parse a logical variable with the given sorts allowed.
sortedLVar :: [LSort] -> Parser LVar

-- | An arbitrary logical variable.
lvar :: Parser LVar

-- | Parse a non-node variable.
msgvar :: Parser LVar

-- | Parse a graph node variable.
nodevar :: Parser NodeId

-- | The exponentiation operator <tt>^</tt>.
opExp :: Parser ()

-- | The multiplication operator <tt>*</tt>.
opMult :: Parser ()

-- | The equality operator <tt>=</tt>.
opEqual :: Parser ()

-- | The timepoint comparison operator <tt>&lt;</tt>.
opLess :: Parser ()

-- | The action-at-timepoint operator @.
opAt :: Parser ()

-- | The logical-forall operator <tt>All</tt> or <tt>∀</tt>.
opForall :: Parser ()

-- | The logical-exists operator <tt>Ex</tt> or <tt>∃</tt>.
opExists :: Parser ()

-- | The logical-implies operator <tt>==&gt;</tt>.
opImplies :: Parser ()

-- | The logical-equivalence operator <tt><a>=</a></tt>.
opLEquiv :: Parser ()

-- | The logical-and operator <tt>&amp;</tt> or <tt>∧</tt>.
opLAnd :: Parser ()

-- | The logical-or operator <tt>|</tt> or <tt>∨</tt>.
opLOr :: Parser ()

-- | The logical not operator <tt>not</tt> or <tt>¬</tt>.
opLNot :: Parser ()

-- | A logical false, <tt>F</tt> or <tt>⊥</tt>.
opLFalse :: Parser ()

-- | A logical false, <tt>T</tt> or <tt>⊥</tt>.
opLTrue :: Parser ()

-- | The requires-a-premise operator, <tt>▶ subscript-idx</tt>.
opRequires :: Parser PremIdx

-- | The chain operator <tt>~~&gt;</tt>.
opChain :: Parser ()

-- | The equal sign <tt>=</tt>.
equalSign :: Parser ()

-- | The sharp operator <tt>#</tt>.
opSharp :: Parser ()

-- | The bang operator <tt>!</tt>.
opBang :: Parser ()

-- | The slash operator <tt>/</tt>.
opSlash :: Parser ()

-- | The minus operator <tt>-</tt>.
opMinus :: Parser ()

-- | The multiplication operator <tt>*</tt>.
opPlus :: Parser ()

-- | The leftarrow operator <tt>&lt;--</tt>.
opLeftarrow :: Parser ()

-- | The rightarrow operator <tt>--&gt;</tt>.
opRightarrow :: Parser ()

-- | The longleftarrow operator <tt>&lt;--</tt>.
opLongleftarrow :: Parser ()

-- | The longrightarrow operator <tt>--&gt;</tt>.
opLongrightarrow :: Parser ()

-- | Between braces.
braced :: Parser a -> Parser a

-- | Between parentheses.
parens :: Parser a -> Parser a

-- | Between angular brackets.
angled :: Parser a -> Parser a

-- | Between brackets.
brackets :: Parser a -> Parser a

-- | Between single quotes.
singleQuoted :: Parser a -> Parser a

-- | Between double quotes.
doubleQuoted :: Parser a -> Parser a

-- | A comma separated list of elements.
commaSep :: Parser a -> Parser [a]

-- | A comma separated non-empty list of elements.
commaSep1 :: Parser a -> Parser [a]

-- | Parse a list of items '[' item ',' ... ',' item ']'
list :: Parser a -> Parser [a]

-- | A parser for a stream of tokens.
type Parser a = Parsec String MaudeSig a

-- | Run a parser on the contents of a file.
parseFile :: Parser a -> FilePath -> IO a

-- | Run a given parser on a given string.
parseString :: FilePath -> Parser a -> String -> Either ParseError a


-- | Parsing protocol theories. See the MANUAL for a high-level description
--   of the syntax.
module Theory.Text.Parser

-- | Parse a security protocol theory file.
parseOpenTheory :: [String] -> FilePath -> IO OpenTheory

-- | Parse a security protocol theory from a string.
parseOpenTheoryString :: [String] -> String -> Either ParseError OpenTheory

-- | Parse a lemma for an open theory from a string.
parseLemma :: String -> Either ParseError (Lemma ProofSkeleton)

-- | Parse DH intruder rules.
parseIntruderRules :: MaudeSig -> FilePath -> IO [IntrRuleAC]


-- | Wellformedness checks for intruder variants, protocol rules, and
--   properties.
--   
--   The following checks are/should be performed (FIXME: compare the list
--   below to what is really implemented.)
--   
--   <ul>
--   <li><i>protocol rules</i></li>
--   </ul>
--   
--   <ol>
--   <li>no fresh names in rule. (protocol cond. 1) ==&gt;
--   freshNamesReport</li>
--   <li>no Out or K facts in premises. (protocol cond. 2) ==&gt;
--   factReports</li>
--   <li>no Fr, In, or K facts in conclusions. (protocol cond. 3) ==&gt;
--   factReports</li>
--   <li>vars(rhs) subset of vars(lhs) u V_Pub ==&gt;
--   multRestrictedReport</li>
--   <li>lhs does not contain reducible function symbols (*-restricted (a))
--   ==&gt; multRestrictedReport</li>
--   <li>rhs does not contain * (*-restricted (b)) ==&gt;
--   multRestrictedReport</li>
--   <li>all facts are used with the same arity.</li>
--   <li>fr, in, and out, facts are used with arity 1.</li>
--   <li>fr facts are used with a variable of sort msg or sort fresh</li>
--   <li>fresh facts of the same rule contain different variables.
--   [TODO]</li>
--   <li>no protocol fact uses a reserved name =&gt; [TODO] change parser
--   to ensure this and pretty printer to show this.</li>
--   </ol>
--   
--   <ul>
--   <li><i>security properties</i></li>
--   </ul>
--   
--   <ol>
--   <li>all facts occur with the same arity in the action of some protocol
--   rule.</li>
--   <li>no node variable is used in a message position and vice
--   versa.</li>
--   </ol>
module Theory.Tools.Wellformedness
type WfErrorReport = [WfError]

-- | All 2-multicombinations of a list. multicombine2 :: [a] -&gt; [(a,a)]
--   multicombine2 xs0 = do (x,xs) <a>zip xs0 $ tails xs0; (,) x &lt;$</a>
--   xs
--   
--   Returns a list of errors, if there are any.
checkWellformedness :: OpenTheory -> WfErrorReport

-- | Adds a note to the end of the theory, if it is not well-formed.
noteWellformedness :: WfErrorReport -> OpenTheory -> OpenTheory
prettyWfErrorReport :: WfErrorReport -> Doc
