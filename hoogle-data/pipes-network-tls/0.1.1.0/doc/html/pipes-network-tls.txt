-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | TLS-secured network connections support for pipes.
--   
--   Use TLS-secured network connections together with the <tt>pipes</tt>
--   ecosystem.
--   
--   This package is organized using the following namespaces:
--   
--   <ul>
--   <li><a>Control.Proxy.TCP.TLS</a> exports <a>Control.Proxy.Proxy</a>s
--   and functions for establishing and using TLS-secured TCP
--   connections.</li>
--   <li><a>Control.Proxy.TCP.TLS.Safe</a> is similar to
--   <a>Control.Proxy.TCP.TLS</a>, except the exported
--   <a>Control.Proxy.Proxy</a>s themselves can obtain new TLS resources
--   safely by using the facilities providied by the <tt>pipes-safe</tt>
--   package.</li>
--   </ul>
--   
--   See the <tt>NEWS</tt> file in the source distribution to learn about
--   any important changes between version.
@package pipes-network-tls
@version 0.1.1.0


-- | This module exports functions that allow you to use TLS-secured TCP
--   connections as <a>Proxy</a> streams, as well as utilities to connect
--   to a TLS-enabled TCP server or running your own, possibly within the
--   pipeline itself by relying on the facilities provided by
--   <a>ExceptionP</a> from the <tt>pipes-safe</tt> library.
--   
--   If you don't need to establish new TLS connections within your
--   pipeline, then consider using the simpler and similar functions
--   exported by <a>Control.Proxy.TCP.TLS</a>.
--   
--   This module re-exports many functions and types from
--   <a>Network.Simple.TCP.TLS</a> module in the <tt>network-simple</tt>
--   package. You might refer to that module for more documentation.
module Control.Proxy.TCP.TLS.Safe

-- | Connect to a TLS-secured TCP server and use the connection.
--   
--   A TLS handshake is performed immediately after establishing the TCP
--   connection.
--   
--   The connection is properly closed when done or in case of exceptions.
--   If you need to manage the lifetime of the connection resources
--   yourself, then use <a>connectTls</a> instead.
connect :: (Proxy p, Monad m) => (forall x. SafeIO x -> m x) -> ClientSettings -> HostName -> ServiceName -> ((Context, SockAddr) -> ExceptionP p a' a b' b m r) -> ExceptionP p a' a b' b m r

-- | Abstract type representing the configuration settings for a TLS
--   client.
--   
--   Use <a>makeClientSettings</a> or <a>getDefaultClientSettings</a> to
--   obtain your <a>ClientSettings</a> value.
data ClientSettings :: *

-- | Get the system default <a>ClientSettings</a>.
--   
--   See <a>makeClientSettings</a> for the for the default TLS settings
--   used.
getDefaultClientSettings :: IO ClientSettings

-- | Make defaults <a>ClientSettings</a>.
--   
--   The following TLS settings are used by default:
--   
--   <ul>
--   <li><i>Supported versions</i> <a>TLS10</a>, <a>TLS11</a>,
--   <a>TLS12</a>.</li>
--   <li><i>Version reported during <i>ClientHello</i></i>
--   <a>TLS10</a>.</li>
--   <li><i>Supported cipher suites</i> In decreasing order of preference:
--   <a>cipher_AES256_SHA256</a>, <a>cipher_AES256_SHA1</a>,
--   <a>cipher_AES128_SHA256</a>, <a>cipher_AES128_SHA1</a>,
--   <a>cipher_RC4_128_SHA1</a>, <a>cipher_RC4_128_MD5</a>.</li>
--   </ul>
makeClientSettings :: [Credential] -> Maybe HostName -> CertificateStore -> ClientSettings

-- | Connect to a TLS-secured TCP server and send downstream the decrypted
--   bytes received from the remote end.
--   
--   Up to <tt>16384</tt> decrypted bytes will be received at once. The TLS
--   connection is automatically renegotiated if a <i>ClientHello</i>
--   message is received.
--   
--   If an optional timeout is given and receiveing data from the remote
--   end takes more time that such timeout, then throw a <a>Timeout</a>
--   exception in the <a>ExceptionP</a> proxy transformer.
--   
--   If the remote peer closes its side of the connection of EOF is
--   reached, this proxy returns.
--   
--   The connection is closed when done or in case of exceptions.
connectReadS :: Proxy p => Maybe Int -> ClientSettings -> HostName -> ServiceName -> () -> Producer (ExceptionP p) ByteString SafeIO ()

-- | Connects to a TLS-secured TCP server, encrypts and sends to the remote
--   end the bytes received from upstream, then forwards such same bytes
--   downstream.
--   
--   Requests from downstream are forwarded upstream.
--   
--   If an optional timeout is given and sending data to the remote end
--   takes more time that such timeout, then throw a <a>Timeout</a>
--   exception in the <a>ExceptionP</a> proxy transformer.
--   
--   The connection is properly closed when done or in case of exceptions.
connectWriteD :: Proxy p => Maybe Int -> ClientSettings -> HostName -> ServiceName -> x -> (ExceptionP p) x ByteString x ByteString SafeIO r

-- | Start a TLS-secured TCP server that accepts incoming connections and
--   handles each of them concurrently, in different threads.
--   
--   A TLS handshake is performed immediately after establishing each TCP
--   connection.
--   
--   Any acquired network resources are properly closed and discarded when
--   done or in case of exceptions.
--   
--   Note: This function binds a listening socket, accepts an connection,
--   performs a TLS handshake and then safely closes the connection. You
--   don't need to perform any of those steps manually.
serve :: (Proxy p, Monad m) => (forall x. SafeIO x -> m x) -> ServerSettings -> HostPreference -> ServiceName -> ((Context, SockAddr) -> IO ()) -> ExceptionP p a' a b' b m r

-- | Abstract type representing the configuration settings for a TLS
--   server.
--   
--   Use <a>makeServerSettings</a> to obtain your <a>ServerSettings</a>
--   value, and <a>updateServerParams</a> to update it.
data ServerSettings :: *

-- | Make default <a>ServerSettings</a>.
--   
--   The following TLS settings are used by default:
--   
--   <ul>
--   <li><i>Supported versions</i> <a>TLS10</a>, <a>TLS11</a>,
--   <a>TLS12</a>.</li>
--   <li><i>Supported cipher suites for <a>TLS10</a></i> In decreasing
--   order of preference: <a>cipher_AES256_SHA256</a>,
--   <a>cipher_AES256_SHA1</a>, <a>cipher_AES128_SHA256</a>,
--   <a>cipher_AES128_SHA1</a>, <a>cipher_RC4_128_SHA1</a>,
--   <a>cipher_RC4_128_MD5</a>. The cipher suite preferred by the client is
--   used.</li>
--   <li><i>Supported cipher suites for <a>TLS11</a> and <a>TLS12</a></i>
--   In decreasing order of preference: <a>cipher_AES256_SHA256</a>,
--   <a>cipher_AES256_SHA1</a>, <a>cipher_AES128_SHA256</a>,
--   <a>cipher_AES128_SHA1</a>. The cipher suite preferred by the client is
--   used.</li>
--   </ul>
makeServerSettings :: Credential -> Maybe CertificateStore -> ServerSettings

-- | Bind a TCP listening socket and use it.
--   
--   The listening socket is closed when done or in case of exceptions.
--   
--   If you prefer to acquire and close the socket yourself, then use
--   <a>bindSock</a> and the <a>listen</a> and <a>sClose</a> functions from
--   <a>Network.Socket</a> instead.
--   
--   Note: <a>maxListenQueue</a> is tipically 128, which is too small for
--   high performance servers. So, we use the maximum between
--   <a>maxListenQueue</a> and 2048 as the default size of the listening
--   queue.
listen :: (Proxy p, Monad m) => (forall x. SafeIO x -> m x) -> HostPreference -> ServiceName -> ((Socket, SockAddr) -> ExceptionP p a' a b' b m r) -> ExceptionP p a' a b' b m r

-- | Accept a single incoming TLS-secured TCP connection and use it.
--   
--   A TLS handshake is performed immediately after establishing each TCP
--   connection.
--   
--   The connection properly closed when done or in case of exceptions.
accept :: (Proxy p, Monad m) => (forall x. SafeIO x -> m x) -> ServerSettings -> Socket -> ((Context, SockAddr) -> ExceptionP p a' a b' b m r) -> ExceptionP p a' a b' b m r

-- | Like <a>accept</a>, except it uses a different thread to performs the
--   TLS handshake and run the given computation.
acceptFork :: (Proxy p, Monad m) => (forall x. SafeIO x -> m x) -> ServerSettings -> Socket -> ((Context, SockAddr) -> IO ()) -> ExceptionP p a' a b' b m ThreadId

-- | Binds a listening TCP socket, accepts a single TLS-secured connection
--   and sends downstream any decrypted bytes received from the remote end.
--   
--   Up to <tt>16384</tt> decrypted bytes will be received at once. The TLS
--   connection is automatically renegotiated if a <i>ClientHello</i>
--   message is received.
--   
--   If an optional timeout is given and receiveing data from the remote
--   end takes more time that such timeout, then throw a <a>Timeout</a>
--   exception in the <a>ExceptionP</a> proxy transformer.
--   
--   If the remote peer closes its side of the connection of EOF is
--   reached, this proxy returns.
--   
--   Both the listening and connection sockets are closed when done or in
--   case of exceptions.
serveReadS :: Proxy p => Maybe Int -> ServerSettings -> HostPreference -> ServiceName -> () -> Producer (ExceptionP p) ByteString SafeIO ()

-- | Binds a listening TCP socket, accepts a single TLS-secured connection,
--   sends to the remote end the bytes received from upstream and then
--   forwards such sames bytesdownstream.
--   
--   Requests from downstream are forwarded upstream.
--   
--   If an optional timeout is given and sending data to the remote end
--   takes more time that such timeout, then throw a <a>Timeout</a>
--   exception in the <a>ExceptionP</a> proxy transformer.
--   
--   If the remote peer closes its side of the connection, this proxy
--   returns.
--   
--   Both the listening and connection sockets are closed when done or in
--   case of exceptions.
serveWriteD :: Proxy p => Maybe Int -> ServerSettings -> HostPreference -> ServiceName -> x -> (ExceptionP p) x ByteString x ByteString SafeIO r

-- | Receives decrypted bytes from the remote end, sending them downstream.
--   
--   Up to <tt>16384</tt> decrypted bytes will be received at once. The TLS
--   connection is automatically renegotiated if a <i>ClientHello</i>
--   message is received.
--   
--   If an optional timeout is given and receiveing data from the remote
--   end takes more time that such timeout, then throw a <a>Timeout</a>
--   exception in the <a>ExceptionP</a> proxy transformer.
--   
--   If the remote peer closes its side of the connection or EOF is
--   reached, this proxy returns.
contextReadS :: Proxy p => Maybe Int -> Context -> () -> Producer (ExceptionP p) ByteString SafeIO ()

-- | Encrypts and sends to the remote end the bytes received from upstream,
--   then forwards such same bytes downstream.
--   
--   If an optional timeout is given and sending data to the remote end
--   takes more time that such timeout, then throw a <a>Timeout</a>
--   exception in the <a>ExceptionP</a> proxy transformer.
--   
--   If the remote peer closes its side of the connection, this proxy
--   returns.
--   
--   Requests from downstream are forwarded upstream.
contextWriteD :: Proxy p => Maybe Int -> Context -> x -> (ExceptionP p) x ByteString x ByteString SafeIO r

-- | On Windows operating systems, the networking subsystem has to be
--   initialised using <a>withSocketsDo</a> before any networking
--   operations can be used. eg.
--   
--   <pre>
--   main = withSocketsDo $ do {...}
--   </pre>
--   
--   Although this is only strictly necessary on Windows platforms, it is
--   harmless on other platforms, so for portability it is good practice to
--   use it all the time.
withSocketsDo :: IO a -> IO a

-- | Preferred host to bind.
data HostPreference :: *

-- | Any available host.
HostAny :: HostPreference

-- | Any available IPv4 host.
HostIPv4 :: HostPreference

-- | Any available IPv6 host.
HostIPv6 :: HostPreference

-- | An explicit host name.
Host :: HostName -> HostPreference

-- | Primary certificate, private key and the rest of the certificate
--   chain.
data Credential :: *
Credential :: !X509 -> !PrivateKey -> [X509] -> Credential

-- | Exception thrown when a time limit has elapsed.
data Timeout :: *

-- | Timeouted with an additional explanatory message.
Timeout :: String -> Timeout


-- | This module exports functions that allow you to use TLS-secured TCP
--   connections as streams, as well as utilities to connect to a
--   TLS-enabled TCP server or running your own.
--   
--   If you need to safely connect to a TLS-enabled TCP server or run your
--   own <i>within</i> a pipes pipeline, then you <i>must</i> use the
--   functions exported from the module <a>Control.Proxy.TCP.TLS.Safe</a>
--   instead.
--   
--   This module re-exports many functions and types from
--   <a>Network.Simple.TCP.TLS</a> module in the <tt>network-simple</tt>
--   package. You might refer to that module for more documentation.
module Control.Proxy.TCP.TLS

-- | Connect to a TLS-secured TCP server and use the connection
--   
--   A TLS handshake is performed immediately after establishing the TCP
--   connection.
--   
--   The connection is properly closed when done or in case of exceptions.
--   If you need to manage the lifetime of the connection resources
--   yourself, then use <a>connectTls</a> instead.
connect :: ClientSettings -> HostName -> ServiceName -> ((Context, SockAddr) -> IO r) -> IO r

-- | Abstract type representing the configuration settings for a TLS
--   client.
--   
--   Use <a>makeClientSettings</a> or <a>getDefaultClientSettings</a> to
--   obtain your <a>ClientSettings</a> value.
data ClientSettings :: *

-- | Get the system default <a>ClientSettings</a>.
--   
--   See <a>makeClientSettings</a> for the for the default TLS settings
--   used.
getDefaultClientSettings :: IO ClientSettings

-- | Make defaults <a>ClientSettings</a>.
--   
--   The following TLS settings are used by default:
--   
--   <ul>
--   <li><i>Supported versions</i> <a>TLS10</a>, <a>TLS11</a>,
--   <a>TLS12</a>.</li>
--   <li><i>Version reported during <i>ClientHello</i></i>
--   <a>TLS10</a>.</li>
--   <li><i>Supported cipher suites</i> In decreasing order of preference:
--   <a>cipher_AES256_SHA256</a>, <a>cipher_AES256_SHA1</a>,
--   <a>cipher_AES128_SHA256</a>, <a>cipher_AES128_SHA1</a>,
--   <a>cipher_RC4_128_SHA1</a>, <a>cipher_RC4_128_MD5</a>.</li>
--   </ul>
makeClientSettings :: [Credential] -> Maybe HostName -> CertificateStore -> ClientSettings

-- | Start a TLS-secured TCP server that accepts incoming connections and
--   handles each of them concurrently, in different threads.
--   
--   Any acquired network resources are properly closed and discarded when
--   done or in case of exceptions. This function binds a listening socket,
--   accepts an incoming connection, performs a TLS handshake and then
--   safely closes the connection when done or in case of exceptions. You
--   don't need to perform any of those steps manually.
serve :: ServerSettings -> HostPreference -> ServiceName -> ((Context, SockAddr) -> IO ()) -> IO ()

-- | Abstract type representing the configuration settings for a TLS
--   server.
--   
--   Use <a>makeServerSettings</a> to obtain your <a>ServerSettings</a>
--   value, and <a>updateServerParams</a> to update it.
data ServerSettings :: *

-- | Make default <a>ServerSettings</a>.
--   
--   The following TLS settings are used by default:
--   
--   <ul>
--   <li><i>Supported versions</i> <a>TLS10</a>, <a>TLS11</a>,
--   <a>TLS12</a>.</li>
--   <li><i>Supported cipher suites for <a>TLS10</a></i> In decreasing
--   order of preference: <a>cipher_AES256_SHA256</a>,
--   <a>cipher_AES256_SHA1</a>, <a>cipher_AES128_SHA256</a>,
--   <a>cipher_AES128_SHA1</a>, <a>cipher_RC4_128_SHA1</a>,
--   <a>cipher_RC4_128_MD5</a>. The cipher suite preferred by the client is
--   used.</li>
--   <li><i>Supported cipher suites for <a>TLS11</a> and <a>TLS12</a></i>
--   In decreasing order of preference: <a>cipher_AES256_SHA256</a>,
--   <a>cipher_AES256_SHA1</a>, <a>cipher_AES128_SHA256</a>,
--   <a>cipher_AES128_SHA1</a>. The cipher suite preferred by the client is
--   used.</li>
--   </ul>
makeServerSettings :: Credential -> Maybe CertificateStore -> ServerSettings

-- | Bind a TCP listening socket and use it.
--   
--   The listening socket is closed when done or in case of exceptions.
--   
--   If you prefer to acquire and close the socket yourself, then use
--   <a>bindSock</a> and the <a>listen</a> and <a>sClose</a> functions from
--   <a>Network.Socket</a> instead.
--   
--   Note: <a>maxListenQueue</a> is tipically 128, which is too small for
--   high performance servers. So, we use the maximum between
--   <a>maxListenQueue</a> and 2048 as the default size of the listening
--   queue. The <a>NoDelay</a> and <a>ReuseAddr</a> options are set on the
--   socket.
listen :: HostPreference -> ServiceName -> ((Socket, SockAddr) -> IO r) -> IO r

-- | Accepts a single incomming TLS-secured TCP connection and use it.
--   
--   A TLS handshake is performed immediately after establishing the TCP
--   connection.
--   
--   The connection is properly closed when done or in case of exceptions.
--   If you need to manage the lifetime of the connection resources
--   yourself, then use <a>acceptTls</a> instead.
accept :: ServerSettings -> Socket -> ((Context, SockAddr) -> IO b) -> IO b

-- | Like <a>accept</a>, except it uses a different thread to performs the
--   TLS handshake and run the given computation.
acceptFork :: ServerSettings -> Socket -> ((Context, SockAddr) -> IO ()) -> IO ThreadId

-- | Receives decrypted bytes from the remote end, sending them downstream.
--   
--   Up to <tt>16384</tt> decrypted bytes will be received at once. The TLS
--   connection is automatically renegotiated if a <i>ClientHello</i>
--   message is received.
--   
--   If the remote peer closes its side of the connection or EOF is
--   reached, this proxy returns.
contextReadS :: Proxy p => Context -> () -> Producer p ByteString IO ()

-- | Encrypts and sends to the remote end the bytes received from upstream,
--   then forwards such same bytes downstream.
--   
--   If the remote peer closes its side of the connection, this proxy
--   returns.
--   
--   Requests from downstream are forwarded upstream.
contextWriteD :: Proxy p => Context -> x -> p x ByteString x ByteString IO r

-- | Like <a>contextReadS</a>, except it throws a <a>Timeout</a> exception
--   in the <a>EitherP</a> proxy transformer if receiving data from the
--   remote end takes more time than specified.
contextReadTimeoutS :: Proxy p => Int -> Context -> () -> Producer (EitherP Timeout p) ByteString IO ()

-- | Like <a>contextWriteD</a>, except it throws a <a>Timeout</a> exception
--   in the <a>EitherP</a> proxy transformer if sending data to the remote
--   end takes more time than specified.
contextWriteTimeoutD :: Proxy p => Int -> Context -> x -> (EitherP Timeout p) x ByteString x ByteString IO r

-- | On Windows operating systems, the networking subsystem has to be
--   initialised using <a>withSocketsDo</a> before any networking
--   operations can be used. eg.
--   
--   <pre>
--   main = withSocketsDo $ do {...}
--   </pre>
--   
--   Although this is only strictly necessary on Windows platforms, it is
--   harmless on other platforms, so for portability it is good practice to
--   use it all the time.
withSocketsDo :: IO a -> IO a

-- | Preferred host to bind.
data HostPreference :: *

-- | Any available host.
HostAny :: HostPreference

-- | Any available IPv4 host.
HostIPv4 :: HostPreference

-- | Any available IPv6 host.
HostIPv6 :: HostPreference

-- | An explicit host name.
Host :: HostName -> HostPreference

-- | Primary certificate, private key and the rest of the certificate
--   chain.
data Credential :: *
Credential :: !X509 -> !PrivateKey -> [X509] -> Credential

-- | Exception thrown when a time limit has elapsed.
data Timeout :: *

-- | Timeouted with an additional explanatory message.
Timeout :: String -> Timeout
