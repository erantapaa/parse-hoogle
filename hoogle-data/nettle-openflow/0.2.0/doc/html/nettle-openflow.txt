-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | OpenFlow protocol messages, binary formats, and servers.
--   
--   This package provides data types that model the messages of the
--   OpenFlow protocol, functions that implement serialization and
--   deserialization between these data types and their binary
--   representations in the protocol, and an efficient OpenFlow server. The
--   library is under active development.
@package nettle-openflow
@version 0.2.0

module Nettle.Topology.ExtendedDouble
data ExtendedDouble
Finite :: !Double -> ExtendedDouble
Infinity :: ExtendedDouble
addExtendedDouble :: ExtendedDouble -> ExtendedDouble -> ExtendedDouble
instance Show ExtendedDouble
instance Read ExtendedDouble
instance Eq ExtendedDouble
instance Ord ExtendedDouble


-- | This module implements a data type of directed graphs where there may
--   be multiple edges between a pair of vertices. There are a variety of
--   ways to think of this: As two finite sets <tt>V</tt>, <tt>E</tt> with
--   two maps source, target : <tt>E -&gt; V</tt>. As a finite Set
--   <tt>V</tt>, a finite set of labels <tt>L</tt>, and a ternary relation
--   as a subset of <tt>(V,L,V)</tt>.
module Nettle.Topology.LabelledGraph
data LabelledGraph n e
type Weight = Double
empty :: (Ord n, Ord e) => LabelledGraph n e
addNode :: Ord n => n -> LabelledGraph n e -> LabelledGraph n e
addEdge :: (Ord n, Ord e) => e -> (n, n) -> Weight -> LabelledGraph n e -> LabelledGraph n e
adjustEdgeWeight :: (Ord n, Ord e) => e -> (Weight -> Weight) -> LabelledGraph n e -> LabelledGraph n e
deleteNode :: (Ord e, Ord n) => n -> LabelledGraph n e -> LabelledGraph n e
deleteEdge :: (Ord n, Ord e) => e -> LabelledGraph n e -> LabelledGraph n e
nodes :: Ord n => LabelledGraph n e -> [n]
numberOfNodes :: Ord n => LabelledGraph n e -> Int
edgesOutOf :: (Ord e, Ord n) => n -> LabelledGraph n e -> [(e, n)]
edgesFromTo :: (Ord e, Ord n) => n -> n -> LabelledGraph n e -> [(e, Weight)]
edges :: LabelledGraph n e -> [(e, Weight)]
data LTree a b
LNode :: a -> [(b, LTree a b)] -> LTree a b

-- | Computes the path tree from one node to another node of the graph.
--   Each node of the tree is a path in the graph from the source to some
--   node in the graph. The parent of a node is the node representing the
--   path with one less edge than the node.
pathTree :: (Ord n, Ord e) => LabelledGraph n e -> n -> n -> Maybe (LTree n (e, Weight))
mapLTree :: (a -> c) -> (b -> d) -> LTree a b -> LTree c d

-- | Neat 2-dimensional drawing of a tree. Mostly borrowed from code in
--   <tt>Data.Tree</tt> module.
drawTree :: LTree String String -> String
instance (Show n, Show e) => Show (LabelledGraph n e)
instance (Show a, Show b) => Show (LTree a b)
instance (Eq a, Eq b) => Eq (LTree a b)


-- | Implements the Floyd-Warshall algorithm for computing all-pairs
--   shortest paths from a weighted directed graph.
module Nettle.Topology.FloydWarshall

-- | The input is a matrix where the <tt>(i,j)</tt> entry contains the
--   distance of a path going from node <tt>i</tt> to node <tt>j</tt> in
--   the graph as well as the next hop node in the path and a value (left
--   polymorphic, of type <tt>a</tt> here) representing the link (e.g. a
--   link identifier, particularly useful if there can more than one link
--   between nodes). If the distance is |Infinity| then the next hop and
--   link identifier should be |Nothing|. Typically, this function is
--   applied to an array in which <tt>(i,j)</tt> value contains the
--   distance and the link ID for one link from <tt>i</tt> to <tt>j</tt>.
floydWarshall :: Array (Int, Int) (ExtendedDouble, Maybe (Int, a)) -> Array (Int, Int) (ExtendedDouble, Maybe (Int, a))

-- | Extracts the shortest path from the matrix computed by
--   |floydWarshall|. The path includes the the nodes and the links of the
--   path.
shortestPath :: Array (Int, Int) (ExtendedDouble, Maybe (Int, a)) -> (Int, Int) -> Maybe [(Int, a)]

module Nettle.OpenFlow.Error

-- | When a switch encounters an error condition, it sends the controller a
--   message containing the information in <tt>SwitchErrorRecord</tt>.
data SwitchError
HelloFailed :: HelloFailure -> String -> SwitchError
BadRequest :: RequestError -> [Word8] -> SwitchError
BadAction :: ActionError -> [Word8] -> SwitchError
FlowModFailed :: FlowModError -> [Word8] -> SwitchError
PortModFailed :: PortModError -> [Word8] -> SwitchError
QueueOperationFailed :: QueueOpError -> [Word8] -> SwitchError
data HelloFailure
IncompatibleVersions :: HelloFailure
HelloPermissionsError :: HelloFailure
data RequestError
VersionNotSupported :: RequestError
MessageTypeNotSupported :: RequestError
StatsRequestTypeNotSupported :: RequestError
VendorNotSupported :: RequestError
VendorSubtypeNotSupported :: RequestError
RequestPermissionsError :: RequestError
BadRequestLength :: RequestError
BufferEmpty :: RequestError
UnknownBuffer :: RequestError
data ActionError
UnknownActionType :: ActionError
BadActionLength :: ActionError
UnknownVendorID :: ActionError
UnknownActionTypeForVendor :: ActionError
BadOutPort :: ActionError
BadActionArgument :: ActionError
ActionPermissionsError :: ActionError
TooManyActions :: ActionError
InvalidQueue :: ActionError
data FlowModError
TablesFull :: FlowModError
OverlappingFlow :: FlowModError
FlowModPermissionsError :: FlowModError
EmergencyModHasTimeouts :: FlowModError
BadCommand :: FlowModError
UnsupportedActionList :: FlowModError
data PortModError
BadPort :: PortModError
BadHardwareAddress :: PortModError
data QueueOpError
QueueOpBadPort :: QueueOpError
QueueDoesNotExist :: QueueOpError
QueueOpPermissionsError :: QueueOpError
instance Show HelloFailure
instance Eq HelloFailure
instance Ord HelloFailure
instance Enum HelloFailure
instance Show RequestError
instance Eq RequestError
instance Ord RequestError
instance Enum RequestError
instance Show ActionError
instance Eq ActionError
instance Ord ActionError
instance Enum ActionError
instance Show FlowModError
instance Eq FlowModError
instance Ord FlowModError
instance Enum FlowModError
instance Show PortModError
instance Eq PortModError
instance Ord PortModError
instance Enum PortModError
instance Show QueueOpError
instance Eq QueueOpError
instance Ord QueueOpError
instance Enum QueueOpError
instance Show SwitchError
instance Eq SwitchError


-- | This module provides a monad for serializing data into byte strings.
--   It provides mostly the same interface that Data.Binary.Put does.
--   However, the implementation is different. It allows for the data to be
--   serialized into an existing array of Word8 values. This differs from
--   the Data.Binary.Put data type, which allocates a Word8 array every
--   time a value is serialized. This module's implementation is useful if
--   you want to reuse the Word8 array for many serializations. In the case
--   of an OpenFlow server, we can reuse a buffer to send messages, since
--   we have no use for the the Word8 array, except to pass it to an IO
--   procedure to write the data to a socket or file.
module Nettle.OpenFlow.StrictPut
data PutM a
type Put = PutM ()

-- | Runs the Put writer with write position given by the first pointer
--   argument. Returns the number of words written.
runPut :: Ptr Word8 -> Put -> IO Int

-- | Allocates a new byte string, and runs the Put writer with that byte
--   string. The first argument is an upper bound on the size of the array
--   needed to do the serialization.
runPutToByteString :: Int -> Put -> ByteString
putWord8 :: Word8 -> Put
putWord16be :: Word16 -> Put

-- | Write a Word32 in big endian format
putWord32be :: Word32 -> Put

-- | Write a Word64 in big endian format
putWord64be :: Word64 -> Put
putByteString :: ByteString -> Put
instance Monad PutM

module Nettle.IPv4.IPAddress
newtype IPAddress
IPAddress :: Word32 -> IPAddress
type IPAddressPrefix = (IPAddress, PrefixLength)
type PrefixLength = Word8
ipAddressToWord32 :: IPAddress -> Word32
ipAddress :: Word8 -> Word8 -> Word8 -> Word8 -> IPAddress
getIPAddress :: Get IPAddress
getIPAddress2 :: Get IPAddress
putIPAddress :: IPAddress -> Put
(//) :: IPAddress -> PrefixLength -> IPAddressPrefix
addressPart :: IPAddressPrefix -> IPAddress
prefixLength :: IPAddressPrefix -> PrefixLength
maxPrefixLen :: Word8
prefixIsExact :: IPAddressPrefix -> Bool
addressToOctets :: IPAddress -> (Word8, Word8, Word8, Word8)
showOctets :: IPAddress -> String
showPrefix :: IPAddressPrefix -> String
prefixPlus :: IPAddressPrefix -> Word32 -> IPAddress
prefixOverlaps :: IPAddressPrefix -> IPAddressPrefix -> Bool
elemOfPrefix :: IPAddress -> IPAddressPrefix -> Bool
intersect :: IPAddressPrefix -> IPAddressPrefix -> Maybe IPAddressPrefix
intersects :: [IPAddressPrefix] -> Maybe IPAddressPrefix
disjoint :: IPAddressPrefix -> IPAddressPrefix -> Bool
disjoints :: [IPAddressPrefix] -> Bool
isSubset :: IPAddressPrefix -> IPAddressPrefix -> Bool
parseIPAddress :: String -> Maybe IPAddress
ipAddressParser :: CharParser () IPAddress
instance Read IPAddress
instance Eq IPAddress
instance Show IPAddress
instance Ord IPAddress


-- | This module provides <tt>Get</tt> values for parsing various IP
--   packets and headers from ByteStrings into a byte-sequence-independent
--   representation as Haskell datatypes.
--   
--   Warning:
--   
--   These are incomplete. The headers may not contain all the information
--   that the protocols specify. For example, the Haskell representation of
--   an IP Header only includes source and destination addresses and IP
--   protocol number, even though an IP packet has many more header fields.
--   More seriously, an IP header may have an optional extra headers
--   section after the destination address. We assume this is not present.
--   If it is present, then the transport protocol header will not be
--   directly after the destination address, but will be after these
--   options. Therefore functions that assume this, such as the
--   getExactMatch function below, will give incorrect results when applied
--   to such IP packets.
--   
--   The Haskell representations of the headers for the transport protocols
--   are similarly incomplete. Again, the Get instances for the transport
--   protocols may not parse through the end of the transport protocol
--   header.
module Nettle.IPv4.IPPacket

-- | An IP packet consists of a header and a body.
type IPPacket = IPHeader :*: (IPBody :*: HNil)

-- | An IP Header includes various information about the packet, including
--   the type of payload it contains. Warning: this definition does not
--   include every header field included in an IP packet.
data IPHeader
IPHeader :: !IPAddress -> !IPAddress -> !IPProtocol -> !Int -> !Int -> !DifferentiatedServicesCodePoint -> IPHeader
ipSrcAddress :: IPHeader -> !IPAddress
ipDstAddress :: IPHeader -> !IPAddress
ipProtocol :: IPHeader -> !IPProtocol
headerLength :: IPHeader -> !Int
totalLength :: IPHeader -> !Int

-- | differentiated services code point - 6 bit number
dscp :: IPHeader -> !DifferentiatedServicesCodePoint
type DifferentiatedServicesCodePoint = Word8
type FragOffset = Word16
type IPProtocol = Word8
type IPTypeOfService = Word8
type TransportPort = Word16
ipTypeTcp, ipTypeIcmp, ipTypeUdp :: IPProtocol

-- | The body of an IP packet can be either a TCP, UDP, ICMP or other
--   packet. Packets other than TCP, UDP, ICMP are represented as unparsed
--   <tt>ByteString</tt> values.
data IPBody
TCPInIP :: TCPHeader -> IPBody
UDPInIP :: UDPHeader -> ByteString -> IPBody
ICMPInIP :: ICMPHeader -> IPBody
UninterpretedIPBody :: ByteString -> IPBody
fromTCPPacket :: IPBody -> Maybe (TCPHeader :*: HNil)
fromUDPPacket :: IPBody -> Maybe (UDPHeader :*: (ByteString :*: HNil))
withIPPacket :: HList l => (IPBody -> Maybe l) -> IPPacket -> Maybe (IPHeader :*: l)
foldIPPacket :: (IPHeader -> IPBody -> a) -> IPPacket -> a
foldIPBody :: (TCPHeader -> a) -> (UDPHeader -> a) -> (ICMPHeader -> a) -> (ByteString -> a) -> IPBody -> a
getIPPacket :: Get IPPacket
getIPPacket2 :: Get IPPacket
getIPHeader :: Get IPHeader
type ICMPHeader = (ICMPType, ICMPCode)
type ICMPType = Word8
type ICMPCode = Word8
getICMPHeader :: Get ICMPHeader
type TCPHeader = (TCPPortNumber, TCPPortNumber)
type TCPPortNumber = Word16
getTCPHeader :: Get TCPHeader
type UDPHeader = (UDPPortNumber, UDPPortNumber)
type UDPPortNumber = Word16
getUDPHeader :: Get UDPHeader
instance Read IPHeader
instance Show IPHeader
instance Eq IPHeader
instance Show IPBody
instance Eq IPBody

module Nettle.Ethernet.EthernetAddress

-- | An Ethernet address consists of 6 bytes. It is stored in a single
--   64-bit value.
data EthernetAddress
ethernetAddress :: Word8 -> Word8 -> Word8 -> Word8 -> Word8 -> Word8 -> EthernetAddress

-- | Builds an ethernet address from a Word64 value. The two most
--   significant bytes are irrelevant; only the bottom 6 bytes are used.
ethernetAddress64 :: Word64 -> EthernetAddress
unpack :: EthernetAddress -> (Word8, Word8, Word8, Word8, Word8, Word8)
unpack64 :: EthernetAddress -> Word64
pack_32_16 :: Word32 -> Word16 -> Word64
isReserved :: EthernetAddress -> Bool
broadcastAddress :: EthernetAddress

-- | Parse an Ethernet address from a ByteString
getEthernetAddress :: Get EthernetAddress
getEthernetAddress2 :: Get EthernetAddress

-- | Unparse an Ethernet address to a ByteString
putEthernetAddress :: EthernetAddress -> Put

-- | Unparse an Ethernet address to a ByteString
putEthernetAddress2 :: EthernetAddress -> Put
instance Typeable EthernetAddress
instance Show EthernetAddress
instance Read EthernetAddress
instance Eq EthernetAddress
instance Ord EthernetAddress
instance Data EthernetAddress

module Nettle.Ethernet.AddressResolutionProtocol
data ARPPacket
ARPQuery :: ARPQueryPacket -> ARPPacket
ARPReply :: ARPReplyPacket -> ARPPacket
data ARPQueryPacket
ARPQueryPacket :: EthernetAddress -> IPAddress -> IPAddress -> ARPQueryPacket
querySenderEthernetAddress :: ARPQueryPacket -> EthernetAddress
querySenderIPAddress :: ARPQueryPacket -> IPAddress
queryTargetIPAddress :: ARPQueryPacket -> IPAddress
data ARPReplyPacket
ARPReplyPacket :: EthernetAddress -> IPAddress -> EthernetAddress -> IPAddress -> ARPReplyPacket
replySenderEthernetAddress :: ARPReplyPacket -> EthernetAddress
replySenderIPAddress :: ARPReplyPacket -> IPAddress
replyTargetEthernetAddress :: ARPReplyPacket -> EthernetAddress
replyTargetIPAddress :: ARPReplyPacket -> IPAddress

-- | Parser for ARP packets
getARPPacket :: Get (Maybe ARPPacket)

-- | Parser for ARP packets
getARPPacket2 :: Get (Maybe ARPPacket)
putARPPacket :: ARPPacket -> Put
instance Show ARPQueryPacket
instance Eq ARPQueryPacket
instance Show ARPReplyPacket
instance Eq ARPReplyPacket
instance Show ARPPacket
instance Eq ARPPacket


-- | This module provides data structures for Ethernet frames as well as
--   parsers and unparsers for Ethernet frames.
module Nettle.Ethernet.EthernetFrame

-- | An Ethernet frame is either an IP packet, an ARP packet, or an
--   uninterpreted <tt>ByteString</tt>. Based on
--   http:<i></i>en.wikipedia.org<i>wiki</i>File:Ethernet_Type_II_Frame_format.svg
type EthernetFrame = EthernetHeader :*: (EthernetBody :*: HNil)
data EthernetBody
IPInEthernet :: !IPPacket -> EthernetBody
ARPInEthernet :: !ARPPacket -> EthernetBody
UninterpretedEthernetBody :: !ByteString -> EthernetBody
data EthernetHeader
EthernetHeader :: !EthernetAddress -> !EthernetAddress -> !EthernetTypeCode -> EthernetHeader
destMACAddress :: EthernetHeader -> !EthernetAddress
sourceMACAddress :: EthernetHeader -> !EthernetAddress
typeCode :: EthernetHeader -> !EthernetTypeCode
Ethernet8021Q :: !EthernetAddress -> !EthernetAddress -> !EthernetTypeCode -> !VLANPriority -> !Bool -> !VLANID -> EthernetHeader
destMACAddress :: EthernetHeader -> !EthernetAddress
sourceMACAddress :: EthernetHeader -> !EthernetAddress
typeCode :: EthernetHeader -> !EthernetTypeCode
priorityCodePoint :: EthernetHeader -> !VLANPriority
canonicalFormatIndicator :: EthernetHeader -> !Bool
vlanId :: EthernetHeader -> !VLANID

-- | Ethernet type code, determines the type of payload carried by an
--   Ethernet frame.
type EthernetTypeCode = Word16
ethTypeIP, typeEth2Cutoff, ethTypeVLAN, ethTypeLLDP, ethTypeARP :: EthernetTypeCode
type VLANPriority = Word8
type VLANID = Word16
eth_ip_packet :: EthernetFrame -> Maybe (EthernetHeader :*: IPPacket)
eth_ip_tcp_packet :: EthernetFrame -> Maybe (EthernetHeader :*: (IPHeader :*: (TCPHeader :*: HNil)))
eth_ip_udp_packet :: EthernetFrame -> Maybe (EthernetHeader :*: (IPHeader :*: (UDPHeader :*: (ByteString :*: HNil))))
foldEthernetFrame :: (EthernetHeader -> EthernetBody -> a) -> EthernetFrame -> a
foldEthernetBody :: (IPPacket -> a) -> (ARPPacket -> a) -> (ByteString -> a) -> EthernetBody -> a

-- | Parser for Ethernet frames.
getEthernetFrame :: Get EthernetFrame
getEthHeader :: Get EthernetHeader
getEthernetFrame2 :: Int -> Get EthernetFrame

-- | Parser for Ethernet headers.
getEthHeader2 :: Get EthernetHeader

-- | Unparser for Ethernet headers.
putEthHeader :: EthernetHeader -> Put
putEthFrame :: EthernetFrame -> Put
arpQuery :: EthernetAddress -> IPAddress -> IPAddress -> EthernetFrame
arpReply :: EthernetAddress -> IPAddress -> EthernetAddress -> IPAddress -> EthernetFrame
instance Show EthernetBody
instance Eq EthernetBody
instance Read EthernetHeader
instance Show EthernetHeader
instance Eq EthernetHeader

module Nettle.OpenFlow.Port

-- | A switch receives and sends packets on a port; The Port data type
--   models attributes of a physical port.
data Port
Port :: PortID -> String -> EthernetAddress -> [PortConfigAttribute] -> Bool -> SpanningTreePortState -> Maybe PortFeatures -> Maybe PortFeatures -> Maybe PortFeatures -> Maybe PortFeatures -> Port

-- | value datapath associates with a physical port
portID :: Port -> PortID

-- | human-readable interface name
portName :: Port -> String

-- | the Ethernet address of the port
portAddress :: Port -> EthernetAddress

-- | describes spanning tree and administrative settings
portConfig :: Port -> [PortConfigAttribute]

-- | describes whether the link is down
portLinkDown :: Port -> Bool

-- | describes spanning tree state
portSTPState :: Port -> SpanningTreePortState

-- | port's current features
portCurrentFeatures :: Port -> Maybe PortFeatures

-- | features advertised by port
portAdvertisedFeatures :: Port -> Maybe PortFeatures

-- | features supported by port
portSupportedFeatures :: Port -> Maybe PortFeatures

-- | features advertised by peer
portPeerFeatures :: Port -> Maybe PortFeatures
type PortID = Word16
data SpanningTreePortState
STPListening :: SpanningTreePortState
STPLearning :: SpanningTreePortState
STPForwarding :: SpanningTreePortState
STPBlocking :: SpanningTreePortState

-- | Possible behaviors of a physical port. Specification:
--   <tt>ofp_port_config</tt>.
data PortConfigAttribute

-- | port is administratively down
PortDown :: PortConfigAttribute

-- | disable 802.1D spanning tree on this port
STPDisabled :: PortConfigAttribute

-- | drop all packets except 802.1D spanning tree packets
OnlySTPackets :: PortConfigAttribute

-- | drop received 802.1D STP packets
NoSTPackets :: PortConfigAttribute

-- | do not include this port when flooding
NoFlooding :: PortConfigAttribute

-- | drop packets forwarded to port
DropForwarded :: PortConfigAttribute

-- | do not send packet-in messages for this port
NoPacketInMsg :: PortConfigAttribute

-- | Possible port features. Specification <tt>ofp_port_features</tt>.
data PortFeature

-- | 10 Mb half-duplex rate support
Rate10MbHD :: PortFeature

-- | 10 Mb full-duplex rate support
Rate10MbFD :: PortFeature

-- | 100 Mb half-duplex rate support
Rate100MbHD :: PortFeature

-- | 100 Mb full-duplex rate support
Rate100MbFD :: PortFeature

-- | 1 Gb half-duplex rate support
Rate1GbHD :: PortFeature

-- | 1 Gb full-duplex rate support
Rate1GbFD :: PortFeature

-- | 10 Gb full-duplex rate support
Rate10GbFD :: PortFeature
Copper :: PortFeature
Fiber :: PortFeature
AutoNegotiation :: PortFeature
Pause :: PortFeature
AsymmetricPause :: PortFeature

-- | Set of <a>PortFeature</a>s. Specification: bitmap of members in
--   <tt>enum ofp_port_features</tt>.
type PortFeatures = [PortFeature]

-- | A port can be configured with a <tt>PortMod</tt> message.
data PortMod
PortModRecord :: PortID -> EthernetAddress -> Map PortConfigAttribute Bool -> PortMod

-- | port number of port to modify
portNumber :: PortMod -> PortID

-- | hardware address of the port (redundant with the port number above;
--   both are required)
hwAddr :: PortMod -> EthernetAddress

-- | attributes mapped to true will be set on, attributes mapped to false
--   will be turned off, and attributes missing will be unchanged
attributesToSet :: PortMod -> Map PortConfigAttribute Bool

-- | The <tt>PortStatus</tt> represents information regarding a change to a
--   port state on a switch.
type PortStatus = (PortStatusUpdateReason, Port)

-- | The reason that a port status update message was sent.
data PortStatusUpdateReason
PortAdded :: PortStatusUpdateReason
PortDeleted :: PortStatusUpdateReason
PortModified :: PortStatusUpdateReason
portAttributeOn :: PortID -> EthernetAddress -> PortConfigAttribute -> PortMod
portAttributeOff :: PortID -> EthernetAddress -> PortConfigAttribute -> PortMod
instance Show SpanningTreePortState
instance Read SpanningTreePortState
instance Eq SpanningTreePortState
instance Ord SpanningTreePortState
instance Enum SpanningTreePortState
instance Show PortConfigAttribute
instance Read PortConfigAttribute
instance Eq PortConfigAttribute
instance Ord PortConfigAttribute
instance Enum PortConfigAttribute
instance Show PortFeature
instance Read PortFeature
instance Eq PortFeature
instance Show Port
instance Read Port
instance Eq Port
instance Show PortMod
instance Read PortMod
instance Eq PortMod
instance Show PortStatusUpdateReason
instance Read PortStatusUpdateReason
instance Eq PortStatusUpdateReason
instance Ord PortStatusUpdateReason
instance Enum PortStatusUpdateReason

module Nettle.OpenFlow.Action

-- | Each flow table entry contains a list of actions that will be executed
--   when a packet matches the entry. Specification:
--   <tt>ofp_action_header</tt> and all <tt>ofp_action_*</tt> structures.
data Action

-- | send out given port
SendOutPort :: PseudoPort -> Action

-- | set the 802.1q VLAN ID
SetVlanVID :: VLANID -> Action

-- | set the 802.1q priority
SetVlanPriority :: VLANPriority -> Action

-- | strip the 802.1q header
StripVlanHeader :: Action

-- | set ethernet source address
SetEthSrcAddr :: EthernetAddress -> Action

-- | set ethernet destination address
SetEthDstAddr :: EthernetAddress -> Action

-- | set IP source address
SetIPSrcAddr :: IPAddress -> Action

-- | set IP destination address
SetIPDstAddr :: IPAddress -> Action

-- | IP ToS (DSCP field)
SetIPToS :: IPTypeOfService -> Action

-- | set TCP/UDP source port
SetTransportSrcPort :: TransportPort -> Action

-- | set TCP/UDP destination port
SetTransportDstPort :: TransportPort -> Action

-- | output to queue
Enqueue :: PortID -> QueueID -> Action

-- | port the queue belongs to
enqueuePort :: Action -> PortID

-- | where to enqueue the packets
queueID :: Action -> QueueID
VendorAction :: VendorID -> [Word8] -> Action

-- | The supported switch actions are denoted with these symbols.
data ActionType
OutputToPortType :: ActionType
SetVlanVIDType :: ActionType
SetVlanPriorityType :: ActionType
StripVlanHeaderType :: ActionType
SetEthSrcAddrType :: ActionType
SetEthDstAddrType :: ActionType
SetIPSrcAddrType :: ActionType
SetIPDstAddrType :: ActionType
SetIPTypeOfServiceType :: ActionType
SetTransportSrcPortType :: ActionType
SetTransportDstPortType :: ActionType
EnqueueType :: ActionType
VendorActionType :: ActionType

-- | A <tt>PseudoPort</tt> denotes the target of a forwarding action.
data PseudoPort

-- | send out physical port with given id
PhysicalPort :: PortID -> PseudoPort

-- | send packet out the input port
InPort :: PseudoPort

-- | send out all physical ports except input port and those disabled by
--   STP
Flood :: PseudoPort

-- | send out all physical ports except input port
AllPhysicalPorts :: PseudoPort

-- | send to controller
ToController :: MaxLenToSendController -> PseudoPort

-- | process with normal L2/L3 switching
NormalSwitching :: PseudoPort

-- | process packet with flow table
WithTable :: PseudoPort

-- | A send to controller action includes the maximum number of bytes that
--   a switch will send to the controller.
type MaxLenToSendController = Word16
type VendorID = Word32
type QueueID = Word32

-- | Sequence of actions, represented as finite lists. The Monoid instance
--   of lists provides methods for denoting the do-nothing action
--   (<tt>mempty</tt>) and for concatenating action sequences
--   <tt>mconcat</tt>.
type ActionSequence = [Action]
sendOnPort :: PortID -> ActionSequence
sendOnInPort, processNormally, allPhysicalPorts, drop, flood :: ActionSequence
sendToController :: MaxLenToSendController -> ActionSequence
processWithTable :: ActionSequence
setVlanVID :: VLANID -> ActionSequence
setVlanPriority :: VLANPriority -> ActionSequence
stripVlanHeader :: ActionSequence
setEthSrcAddr :: EthernetAddress -> ActionSequence
setEthDstAddr :: EthernetAddress -> ActionSequence
setIPSrcAddr :: IPAddress -> ActionSequence
setIPDstAddr :: IPAddress -> ActionSequence
setIPToS :: IPTypeOfService -> ActionSequence
setTransportSrcPort :: TransportPort -> ActionSequence
setTransportDstPort :: TransportPort -> ActionSequence
enqueue :: PortID -> QueueID -> ActionSequence
vendorAction :: VendorID -> [Word8] -> ActionSequence
instance Show ActionType
instance Read ActionType
instance Eq ActionType
instance Ord ActionType
instance Enum ActionType
instance Show PseudoPort
instance Read PseudoPort
instance Eq PseudoPort
instance Show Action
instance Eq Action

module Nettle.OpenFlow.Switch

-- | The switch features record, summarizes information about a switch
data SwitchFeatures
SwitchFeatures :: SwitchID -> Integer -> Integer -> [SwitchCapability] -> [ActionType] -> [Port] -> SwitchFeatures

-- | unique switch identifier
switchID :: SwitchFeatures -> SwitchID

-- | maximum number of packets buffered at the switch
packetBufferSize :: SwitchFeatures -> Integer

-- | number of flow tables
numberFlowTables :: SwitchFeatures -> Integer

-- | switch's capabilities
capabilities :: SwitchFeatures -> [SwitchCapability]

-- | switch's supported actions
supportedActions :: SwitchFeatures -> [ActionType]

-- | description of each port on switch
ports :: SwitchFeatures -> [Port]

-- | A unique identifier for a switch, also known as DataPathID.
type SwitchID = Word64

-- | The switch capabilities are denoted with these symbols
data SwitchCapability

-- | can provide flow statistics
HasFlowStats :: SwitchCapability

-- | can provide table statistics
HasTableStats :: SwitchCapability

-- | can provide port statistics
HasPortStats :: SwitchCapability

-- | supports the 802.1d spanning tree protocol
SpanningTree :: SwitchCapability
MayTransmitOverMultiplePhysicalInterfaces :: SwitchCapability

-- | can provide queue statistics
HasQueueStatistics :: SwitchCapability

-- | match IP addresses in ARP packets
CanMatchIPAddressesInARPPackets :: SwitchCapability

-- | can reassemble IP fragments
CanReassembleIPFragments :: SwitchCapability

-- | Maximum number of ports on a switch
maxNumberPorts :: PortID
data QueueConfigRequest
QueueConfigRequest :: PortID -> QueueConfigRequest
data QueueConfigReply
PortQueueConfig :: PortID -> [QueueConfig] -> QueueConfigReply
data QueueConfig
QueueConfig :: QueueID -> [QueueProperty] -> QueueConfig
type QueueLength = Word16
data QueueProperty
MinRateQueue :: QueueRate -> QueueProperty
data QueueRate
Disabled :: QueueRate
Enabled :: Word16 -> QueueRate
instance Show SwitchCapability
instance Read SwitchCapability
instance Eq SwitchCapability
instance Ord SwitchCapability
instance Enum SwitchCapability
instance Show SwitchFeatures
instance Read SwitchFeatures
instance Eq SwitchFeatures
instance Show QueueConfigRequest
instance Read QueueConfigRequest
instance Eq QueueConfigRequest
instance Show QueueRate
instance Read QueueRate
instance Eq QueueRate
instance Show QueueProperty
instance Read QueueProperty
instance Eq QueueProperty
instance Show QueueConfig
instance Read QueueConfig
instance Eq QueueConfig
instance Show QueueConfigReply
instance Read QueueConfigReply
instance Eq QueueConfigReply

module Nettle.OpenFlow.Packet

-- | A switch can be remotely commanded to send a packet. The packet can
--   either be a packet buffered at the switch, in which case the bufferID
--   is provided, or it can be specified explicitly by giving the packet
--   data.
data PacketOut
PacketOutRecord :: !Either BufferID ByteString -> !Maybe PortID -> !ActionSequence -> PacketOut

-- | either a buffer ID or the data itself
bufferIDData :: PacketOut -> !Either BufferID ByteString

-- | the port at which the packet received, for the purposes of processing
--   this command
packetInPort :: PacketOut -> !Maybe PortID

-- | actions to apply to the packet
packetActions :: PacketOut -> !ActionSequence

-- | Constructs a <tt>PacketOut</tt> value for a packet buffered at a
--   switch.
bufferedPacketOut :: BufferID -> Maybe PortID -> ActionSequence -> PacketOut

-- | Constructs a <tt>PacketOut</tt> value for an unbuffered packet,
--   including the packet data.
unbufferedPacketOut :: ByteString -> Maybe PortID -> ActionSequence -> PacketOut

-- | Constructs a <tt>PacketOut</tt> value that processes the packet
--   referred to by the <tt>PacketInfo</tt> value according to the
--   specified actions.
receivedPacketOut :: PacketInfo -> ActionSequence -> PacketOut

-- | A switch may buffer a packet that it receives. When it does so, the
--   packet is assigned a bufferID which can be used to refer to that
--   packet.
type BufferID = Word32

-- | A switch receives packets on its ports. If the packet matches some
--   flow rules, the highest priority rule is executed. If no flow rule
--   matches, the packet is sent to the controller. When packet is sent to
--   the controller, the switch sends a message containing the following
--   information.
data PacketInfo
PacketInfo :: !Maybe BufferID -> !NumBytes -> !PortID -> !PacketInReason -> !ByteString -> !Either String EthernetFrame -> PacketInfo

-- | buffer ID if packet buffered
bufferID :: PacketInfo -> !Maybe BufferID

-- | full length of frame
packetLength :: PacketInfo -> !NumBytes

-- | port on which frame was received
receivedOnPort :: PacketInfo -> !PortID

-- | reason packet is being sent
reasonSent :: PacketInfo -> !PacketInReason

-- | ethernet frame, includes full packet only if no buffer ID
packetData :: PacketInfo -> !ByteString

-- | result of parsing packetData field.
enclosedFrame :: PacketInfo -> !Either String EthernetFrame

-- | A PacketInfo message includes the reason that the message was sent,
--   namely either there was no match, or there was a match, and that
--   match's actions included a Sent-To-Controller action.
data PacketInReason
NotMatched :: PacketInReason
ExplicitSend :: PacketInReason

-- | The number of bytes in a packet.
type NumBytes = Int
bufferedAtSwitch :: PacketInfo -> Bool
instance Eq PacketOut
instance Show PacketOut
instance Show PacketInReason
instance Read PacketInReason
instance Eq PacketInReason
instance Ord PacketInReason
instance Enum PacketInReason
instance Show PacketInfo
instance Eq PacketInfo

module Nettle.OpenFlow.Match

-- | Each flow entry includes a match, which essentially defines
--   packet-matching condition. Fields that are left Nothing are
--   <a>wildcards</a>.
data Match
Match :: !Maybe PortID -> !Maybe EthernetAddress -> !Maybe EthernetAddress -> !Maybe VLANID -> !Maybe VLANPriority -> !Maybe EthernetTypeCode -> !Maybe IPTypeOfService -> !Maybe IPProtocol -> !IPAddressPrefix -> !IPAddressPrefix -> !Maybe TransportPort -> !Maybe TransportPort -> Match
inPort :: Match -> !Maybe PortID
srcEthAddress :: Match -> !Maybe EthernetAddress
dstEthAddress :: Match -> !Maybe EthernetAddress
vLANID :: Match -> !Maybe VLANID
vLANPriority :: Match -> !Maybe VLANPriority
ethFrameType :: Match -> !Maybe EthernetTypeCode
ipTypeOfService :: Match -> !Maybe IPTypeOfService
matchIPProtocol :: Match -> !Maybe IPProtocol
srcIPAddress :: Match -> !IPAddressPrefix
dstIPAddress :: Match -> !IPAddressPrefix
srcTransportPort :: Match -> !Maybe TransportPort
dstTransportPort :: Match -> !Maybe TransportPort

-- | A match that matches every packet.
matchAny :: Match

-- | Return True if given <a>Match</a> represents an exact match, i.e. no
--   wildcards and the IP addresses' prefixes cover all bits.
isExactMatch :: Match -> Bool

-- | Utility function to get an exact match corresponding to a packet (as
--   given by a byte sequence).
getExactMatch :: PortID -> Get Match
frameToExactMatch :: PortID -> EthernetFrame -> Match
frameToExactMatchNoPort :: EthernetFrame -> Match
ofpVlanNone :: Integer

-- | Models the match semantics of an OpenFlow switch.
matches :: (PortID, EthernetFrame) -> Match -> Bool
instance Show Match
instance Read Match
instance Eq Match


-- | A switch has some number of flow tables. Each flow table is a
--   prioritized list of entries containing a <tt>Match</tt>, a list of
--   <tt>Action</tt>s, and other options affecting the behavior of the
--   switch. This module represents the OpenFlow messages that can be used
--   to modify flow tables.
module Nettle.OpenFlow.FlowTable
type FlowTableID = Word8
data FlowMod
AddFlow :: Match -> Priority -> ActionSequence -> Cookie -> TimeOut -> TimeOut -> Bool -> Maybe BufferID -> Bool -> FlowMod
match :: FlowMod -> Match
priority :: FlowMod -> Priority
actions :: FlowMod -> ActionSequence
cookie :: FlowMod -> Cookie
idleTimeOut :: FlowMod -> TimeOut
hardTimeOut :: FlowMod -> TimeOut
notifyWhenRemoved :: FlowMod -> Bool
applyToPacket :: FlowMod -> Maybe BufferID
overlapAllowed :: FlowMod -> Bool
AddEmergencyFlow :: Match -> Priority -> ActionSequence -> Cookie -> Bool -> FlowMod
match :: FlowMod -> Match
priority :: FlowMod -> Priority
actions :: FlowMod -> ActionSequence
cookie :: FlowMod -> Cookie
overlapAllowed :: FlowMod -> Bool
ModifyFlows :: Match -> ActionSequence -> Priority -> Cookie -> TimeOut -> TimeOut -> Bool -> Bool -> FlowMod
match :: FlowMod -> Match
newActions :: FlowMod -> ActionSequence
ifMissingPriority :: FlowMod -> Priority
ifMissingCookie :: FlowMod -> Cookie
ifMissingIdleTimeOut :: FlowMod -> TimeOut
ifMissingHardTimeOut :: FlowMod -> TimeOut
ifMissingNotifyWhenRemoved :: FlowMod -> Bool
ifMissingOverlapAllowed :: FlowMod -> Bool
ModifyExactFlow :: Match -> Priority -> ActionSequence -> Cookie -> TimeOut -> TimeOut -> Bool -> Bool -> FlowMod
match :: FlowMod -> Match
priority :: FlowMod -> Priority
newActions :: FlowMod -> ActionSequence
ifMissingCookie :: FlowMod -> Cookie
ifMissingIdleTimeOut :: FlowMod -> TimeOut
ifMissingHardTimeOut :: FlowMod -> TimeOut
ifMissingNotifyWhenRemoved :: FlowMod -> Bool
ifMissingOverlapAllowed :: FlowMod -> Bool
DeleteFlows :: Match -> Maybe PseudoPort -> FlowMod
match :: FlowMod -> Match
outPort :: FlowMod -> Maybe PseudoPort
DeleteExactFlow :: Match -> Maybe PseudoPort -> Priority -> FlowMod
match :: FlowMod -> Match
outPort :: FlowMod -> Maybe PseudoPort
priority :: FlowMod -> Priority
type Cookie = Word64

-- | The priority of a flow entry is a 16-bit integer. Flow entries with
--   higher numeric priorities match before lower ones.
type Priority = Word16

-- | Each flow entry has idle and hard timeout values associated with it.
data TimeOut
Permanent :: TimeOut
ExpireAfter :: Word16 -> TimeOut

-- | When a switch removes a flow, it may send a message containing the
--   information in <tt>FlowRemovedRecord</tt> to the controller.
data FlowRemoved
FlowRemovedRecord :: Match -> Word64 -> Priority -> FlowRemovalReason -> Integer -> Integer -> Integer -> Integer -> Integer -> FlowRemoved
flowRemovedMatch :: FlowRemoved -> Match
flowRemovedCookie :: FlowRemoved -> Word64
flowRemovedPriority :: FlowRemoved -> Priority
flowRemovedReason :: FlowRemoved -> FlowRemovalReason
flowRemovedDuration :: FlowRemoved -> Integer
flowRemovedDurationNSecs :: FlowRemoved -> Integer
flowRemovedIdleTimeout :: FlowRemoved -> Integer
flowRemovedPacketCount :: FlowRemoved -> Integer
flowRemovedByteCount :: FlowRemoved -> Integer
data FlowRemovalReason
IdleTimerExpired :: FlowRemovalReason
HardTimerExpired :: FlowRemovalReason
DeletedByController :: FlowRemovalReason
instance Show TimeOut
instance Eq TimeOut
instance Show FlowMod
instance Eq FlowMod
instance Show FlowRemovalReason
instance Eq FlowRemovalReason
instance Ord FlowRemovalReason
instance Enum FlowRemovalReason
instance Show FlowRemoved
instance Eq FlowRemoved

module Nettle.OpenFlow.Statistics
data StatsRequest
FlowStatsRequest :: Match -> TableQuery -> Maybe PseudoPort -> StatsRequest

-- | fields to match
statsRequestMatch :: StatsRequest -> Match

-- | ID of table to read
statsRequestTableID :: StatsRequest -> TableQuery

-- | if present, require matching entries to include this as an output port
statsRequestPort :: StatsRequest -> Maybe PseudoPort
AggregateFlowStatsRequest :: Match -> TableQuery -> Maybe PseudoPort -> StatsRequest

-- | fields to match
statsRequestMatch :: StatsRequest -> Match

-- | ID of table to read
statsRequestTableID :: StatsRequest -> TableQuery

-- | if present, require matching entries to include this as an output port
statsRequestPort :: StatsRequest -> Maybe PseudoPort
TableStatsRequest :: StatsRequest
DescriptionRequest :: StatsRequest
PortStatsRequest :: PortQuery -> StatsRequest
portStatsQuery :: StatsRequest -> PortQuery
QueueStatsRequest :: PortQuery -> QueueQuery -> StatsRequest
queueStatsPort :: StatsRequest -> PortQuery
queueStatsQuery :: StatsRequest -> QueueQuery
data TableQuery
AllTables :: TableQuery
EmergencyTable :: TableQuery
Table :: FlowTableID -> TableQuery
data PortQuery
AllPorts :: PortQuery
SinglePort :: PortID -> PortQuery
data QueueQuery
AllQueues :: QueueQuery
SingleQueue :: QueueID -> QueueQuery
data StatsReply
DescriptionReply :: Description -> StatsReply
FlowStatsReply :: MoreToFollowFlag -> [FlowStats] -> StatsReply
AggregateFlowStatsReply :: AggregateFlowStats -> StatsReply
TableStatsReply :: MoreToFollowFlag -> [TableStats] -> StatsReply
PortStatsReply :: MoreToFollowFlag -> [(PortID, PortStats)] -> StatsReply
QueueStatsReply :: MoreToFollowFlag -> [QueueStats] -> StatsReply
type MoreToFollowFlag = Bool
data FlowStats
FlowStats :: FlowTableID -> Match -> [Action] -> Priority -> Cookie -> Integer -> Integer -> Integer -> Integer -> Integer -> Integer -> FlowStats

-- | Table ID of the flow
flowStatsTableID :: FlowStats -> FlowTableID

-- | Match condition of the flow
flowStatsMatch :: FlowStats -> Match

-- | Actions for the flow
flowStatsActions :: FlowStats -> [Action]

-- | Priority of the flow entry (meaningful when the match is not exact).
flowStatsPriority :: FlowStats -> Priority

-- | Cookie associated with the flow.
flowStatsCookie :: FlowStats -> Cookie
flowStatsDurationSeconds :: FlowStats -> Integer
flowStatsDurationNanoseconds :: FlowStats -> Integer
flowStatsIdleTimeout :: FlowStats -> Integer
flowStatsHardTimeout :: FlowStats -> Integer
flowStatsPacketCount :: FlowStats -> Integer
flowStatsByteCount :: FlowStats -> Integer
data AggregateFlowStats
AggregateFlowStats :: Integer -> Integer -> Integer -> AggregateFlowStats
aggregateFlowStatsPacketCount :: AggregateFlowStats -> Integer
aggregateFlowStatsByteCount :: AggregateFlowStats -> Integer
aggregateFlowStatsFlowCount :: AggregateFlowStats -> Integer
data TableStats
TableStats :: FlowTableID -> String -> Integer -> Integer -> Integer -> Integer -> TableStats
tableStatsTableID :: TableStats -> FlowTableID
tableStatsTableName :: TableStats -> String
tableStatsMaxEntries :: TableStats -> Integer
tableStatsActiveCount :: TableStats -> Integer
tableStatsLookupCount :: TableStats -> Integer
tableStatsMatchedCount :: TableStats -> Integer
data PortStats
PortStats :: Maybe Double -> Maybe Double -> Maybe Double -> Maybe Double -> Maybe Double -> Maybe Double -> Maybe Double -> Maybe Double -> Maybe Double -> Maybe Double -> Maybe Double -> Maybe Double -> PortStats
portStatsReceivedPackets :: PortStats -> Maybe Double
portStatsSentPackets :: PortStats -> Maybe Double
portStatsReceivedBytes :: PortStats -> Maybe Double
portStatsSentBytes :: PortStats -> Maybe Double
portStatsReceiverDropped :: PortStats -> Maybe Double
portStatsSenderDropped :: PortStats -> Maybe Double
portStatsReceiveErrors :: PortStats -> Maybe Double
portStatsTransmitError :: PortStats -> Maybe Double
portStatsReceivedFrameErrors :: PortStats -> Maybe Double
portStatsReceiverOverrunError :: PortStats -> Maybe Double
portStatsReceiverCRCError :: PortStats -> Maybe Double
portStatsCollisions :: PortStats -> Maybe Double

-- | A port stats value with all fields missing.
nullPortStats :: PortStats

-- | A port stats value with all fields present, but set to 0.
zeroPortStats :: PortStats

-- | Lift a unary function and apply to every member of a PortStats record.
liftIntoPortStats1 :: (Double -> Double) -> PortStats -> PortStats

-- | Lift a binary function and apply to every member of a PortStats
--   record.
liftIntoPortStats2 :: (Double -> Double -> Double) -> PortStats -> PortStats -> PortStats
data Description
Description :: String -> String -> String -> String -> String -> Description
manufacturerDesc :: Description -> String
hardwareDesc :: Description -> String
softwareDesc :: Description -> String
serialNumber :: Description -> String
datapathDesc :: Description -> String
data QueueStats
QueueStats :: PortID -> QueueID -> Integer -> Integer -> Integer -> QueueStats
queueStatsPortID :: QueueStats -> PortID
queueStatsQueueID :: QueueStats -> QueueID
queueStatsTransmittedBytes :: QueueStats -> Integer
queueStatsTransmittedPackets :: QueueStats -> Integer
queueStatsTransmittedErrors :: QueueStats -> Integer
instance Show PortQuery
instance Eq PortQuery
instance Ord PortQuery
instance Show QueueQuery
instance Eq QueueQuery
instance Ord QueueQuery
instance Show TableQuery
instance Eq TableQuery
instance Show StatsRequest
instance Eq StatsRequest
instance Show Description
instance Eq Description
instance Show AggregateFlowStats
instance Eq AggregateFlowStats
instance Show FlowStats
instance Eq FlowStats
instance Show TableStats
instance Eq TableStats
instance Show PortStats
instance Eq PortStats
instance Show QueueStats
instance Eq QueueStats
instance Show StatsReply
instance Eq StatsReply


-- | This module provides a logical representation of OpenFlow switches and
--   protocol messages. An OpenFlow message is either a
--   switch-to-controller message or controller-to-switch message. In
--   either case, each message is tagged with a unique message identifier.
module Nettle.OpenFlow.Messages

-- | Every OpenFlow message is tagged with a MessageID value.
type TransactionID = Word32

-- | The Switch can send the following messages to the controller.
data SCMessage

-- | Sent after a switch establishes a TCP connection to the controller
SCHello :: SCMessage

-- | Switch requests an echo reply
SCEchoRequest :: ![Word8] -> SCMessage

-- | Switch responds to an echo request
SCEchoReply :: ![Word8] -> SCMessage

-- | Switch reports its features
Features :: !SwitchFeatures -> SCMessage

-- | Switch sends a packet to the controller
PacketIn :: !PacketInfo -> SCMessage

-- | Switch sends port status
PortStatus :: !PortStatus -> SCMessage

-- | Switch reports that a flow has been removed
FlowRemoved :: !FlowRemoved -> SCMessage

-- | Switch reports statistics
StatsReply :: !StatsReply -> SCMessage

-- | Switch reports an error
Error :: !SwitchError -> SCMessage

-- | Switch responds that a barrier has been processed
BarrierReply :: SCMessage
QueueConfigReply :: !QueueConfigReply -> SCMessage

-- | The controller can send these messages to the switch.
data CSMessage

-- | Controller must send hello before sending any other messages
CSHello :: CSMessage

-- | Controller requests a switch echo
CSEchoRequest :: ![Word8] -> CSMessage

-- | Controller responds to a switch echo request
CSEchoReply :: ![Word8] -> CSMessage

-- | Controller requests features information
FeaturesRequest :: CSMessage

-- | Controller commands switch to send a packet
PacketOut :: !PacketOut -> CSMessage

-- | Controller modifies a switch flow table
FlowMod :: !FlowMod -> CSMessage

-- | Controller configures a switch port
PortMod :: !PortMod -> CSMessage

-- | Controller requests statistics
StatsRequest :: !StatsRequest -> CSMessage

-- | Controller requests a barrier
BarrierRequest :: CSMessage
SetConfig :: CSMessage
Vendor :: CSMessage
GetQueueConfig :: !QueueConfigRequest -> CSMessage
instance Show SCMessage
instance Eq SCMessage
instance Show CSMessage
instance Eq CSMessage


-- | This module implements parsing and unparsing functions for OpenFlow
--   messages. It exports a driver that can be used to read messages from a
--   file handle and write messages to a handle.
module Nettle.OpenFlow.MessagesBinary

-- | Parser for the OpenFlow message header
getHeader :: Get OFPHeader

-- | Parser for <tt>SCMessage</tt>s
getSCMessage :: Get (TransactionID, SCMessage)
getSCMessageBody :: OFPHeader -> Get (TransactionID, SCMessage)

-- | Unparser for <tt>SCMessage</tt>s
putSCMessage :: (TransactionID, SCMessage) -> Put

-- | Parser for <tt>CSMessage</tt>s
getCSMessage :: Get (TransactionID, CSMessage)
getCSMessageBody :: OFPHeader -> Get (TransactionID, CSMessage)

-- | Unparser for <tt>CSMessage</tt>s
putCSMessage :: (TransactionID, CSMessage) -> Put

-- | OpenFlow message header
data OFPHeader
OFPHeader :: !OpenFlowVersionID -> !MessageTypeCode -> !Word16 -> !TransactionID -> OFPHeader
msgVersion :: OFPHeader -> !OpenFlowVersionID
msgType :: OFPHeader -> !MessageTypeCode
msgLength :: OFPHeader -> !Word16
msgTransactionID :: OFPHeader -> !TransactionID
instance Show OFPHeader
instance Eq OFPHeader
instance Show FlowModType
instance Eq FlowModType
instance Ord FlowModType
instance Show FlowModFlag
instance Eq FlowModFlag
instance Ord FlowModFlag
instance Enum FlowModFlag
instance Eq FlowModRecordInternal
instance Show FlowModRecordInternal
instance Show OFPMatch
instance Eq OFPMatch

module Nettle.OpenFlow


-- | Provides a simple, basic, and efficient server which provides methods
--   to listen for new switches to connect, and to receive and send
--   OpenFlow messages to switches. This server handles the initialization
--   procedure with switches and handles echo requests from switches.
module Nettle.Servers.Server

-- | Abstract type containing the state of the OpenFlow server.
data OpenFlowServer
type ServerPortNumber = Word16

-- | Either a host name e.g., <tt>"haskell.org"</tt> or a numeric host
--   address string consisting of a dotted decimal IPv4 address or an IPv6
--   address e.g., <tt>"192.168.0.1"</tt>.
type HostName = String

-- | Starts an OpenFlow server. The server socket will be bound to a
--   wildcard IP address if the first argument is <a>Nothing</a> and will
--   be bound to a particular address if the first argument is <a>Just</a>
--   something. The <a>HostName</a> value can either be an IP address in
--   dotted quad notation, like 10.1.30.127, or a host name, whose IP
--   address will be looked up. The server port must be specified.
startOpenFlowServer :: Maybe HostName -> ServerPortNumber -> IO OpenFlowServer

-- | Blocks until a switch connects to the server and returns the switch
--   handle.
acceptSwitch :: OpenFlowServer -> IO (SwitchHandle, SwitchFeatures)

-- | Closes the OpenFlow server.
closeServer :: OpenFlowServer -> IO ()

-- | Abstract type managing the state of the switch connection.
data SwitchHandle
handle2SwitchID :: SwitchHandle -> SwitchID

-- | Returns the socket address of the switch connection.
switchSockAddr :: SwitchHandle -> SockAddr

-- | Blocks until a message is received from the switch or the connection
--   is closed. Returns <a>Nothing</a> only if the connection is closed.
receiveFromSwitch :: SwitchHandle -> IO (Maybe (TransactionID, SCMessage))
receiveBatch :: SwitchHandle -> IO [(TransactionID, SCMessage)]

-- | Send a message to the switch.
sendToSwitch :: SwitchHandle -> (TransactionID, CSMessage) -> IO ()
sendBatch :: SwitchHandle -> Int -> [(TransactionID, CSMessage)] -> IO ()
sendBatches :: SwitchHandle -> Int -> [[(TransactionID, CSMessage)]] -> IO ()
sendToSwitchWithID :: OpenFlowServer -> SwitchID -> (TransactionID, CSMessage) -> IO ()

-- | Close a switch connection.
closeSwitchHandle :: SwitchHandle -> IO ()

-- | Repeatedly perform the first action, passing its result to the second
--   action, until the result of the first action is <a>Nothing</a>, at
--   which point the computation returns.
untilNothing :: IO (Maybe a) -> (a -> IO ()) -> IO ()
instance Ord SockAddr


-- | This module provides a TCP server that multiplexes incoming and
--   outgoing messages from many connected peers onto a single pair of
--   input and output channels. The socket address of the peer is used to
--   identify the source and destination of messages.
--   
--   This interface introduces a new error condition: that a message on the
--   outgoing channel has a socket address for which no socket exists. This
--   may occur because of incorrect usage of this library, or because a
--   peer disconnected after the client placed a message on the outgoing
--   channel, but before that message was sent. Currently, the server does
--   not notify its caller of the occurrence of this error.
module Nettle.Servers.MultiplexedTCPServer

-- | Runs a server that returns two commands, one to receive the next
--   message from any connected client, and one that sends a message to a
--   client.
muxedTCPServer :: ServerPortNumber -> IO (IO (TCPMessage (TransactionID, SCMessage)), SockAddr -> (TransactionID, CSMessage) -> IO ())

-- | The type of externally visible events that may occur for the
--   multiplexed TCP server.
data TCPMessage a

-- | A connection to a peer with the given address is established.
ConnectionEstablished :: SockAddr -> TCPMessage a

-- | A connection with the given address is terminated, due to the given
--   exception.
ConnectionTerminated :: SockAddr -> TCPMessage a

-- | A message of type <tt>a</tt> has been received from the peer with the
--   given address.
PeerMessage :: SockAddr -> a -> TCPMessage a
type ServerPortNumber = Word16
instance Show a => Show (TCPMessage a)
instance Eq a => Eq (TCPMessage a)
instance Functor TCPMessage


-- | This module provides methods to connect to an OpenFlow control server,
--   and send and receive messages to the server.
module Nettle.Servers.Client

-- | Abstract type representing the state of the connection to the control
--   server.
data ClientHandle

-- | Established a connection to the control server with the given
--   <a>HostName</a> and <a>PortID</a> and returns its <a>ClientHandle</a>.
connectToController :: HostName -> PortID -> IO ClientHandle

-- | Creates a <a>ClientHandle</a> based on a handle to read from and one
--   to write to.
connectToHandles :: Handle -> Handle -> IO ClientHandle

-- | Close client, closing read and write handles.
closeClient :: ClientHandle -> IO ()

-- | Blocks until a new control message arrives or the connection is
--   terminated, in which the return value is <a>Nothing</a>.
receiveControlMessage :: ClientHandle -> IO (Maybe (TransactionID, CSMessage))

-- | Sends a message to the controller.
sendMessage :: ClientHandle -> (TransactionID, SCMessage) -> IO ()
flushClient :: ClientHandle -> IO ()


-- | This module implements a data structure that can be used to maintain
--   information about the topology of an OpenFlow network. It maintains a
--   graph whose nodes are switches and whose edges are links connect
--   switches and attaching to switches at particular ports.
module Nettle.Topology.Topology
type LinkID = ((SwitchID, PortID), (SwitchID, PortID))
data Topology
type Weight = Double
empty :: Topology
addLink :: LinkID -> Weight -> Topology -> Topology
adjustLinkWeight :: LinkID -> (Weight -> Weight) -> Topology -> Topology
deleteLink :: LinkID -> Topology -> Topology
addSwitch :: SwitchID -> Topology -> Topology
deleteSwitch :: SwitchID -> Topology -> Topology
addEdgePort :: SwitchID -> PortID -> Topology -> Topology
addEdgePorts :: [(SwitchID, PortID)] -> Topology -> Topology
lookupLink :: Topology -> SwitchID -> PortID -> (LinkID, Weight)
links :: Topology -> [LinkID]
lGraph :: Topology -> LabelledGraph SwitchID LinkID
edgePorts :: Topology -> Set (SwitchID, PortID)
data ShortestPathMatrix
shortestPathMatrix :: Topology -> ShortestPathMatrix
pathBetween :: ShortestPathMatrix -> SwitchID -> SwitchID -> Maybe [LinkID]
completeTopology :: Int -> Int -> Weight -> Topology
makeTopology :: Int -> Int -> [(Int, Int, Weight)] -> Topology
