-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | HTTP client package with enumerator interface and HTTPS support. (deprecated)
--   
--   This package has been deprecated in favor of http-conduit
--   (<a>http://hackage.haskell.org/package/http-conduit</a>), which
--   provides a more powerful and simpler interface. The API is very
--   similar, and migrating should not be problematic. Send concerns about
--   this move to the maintainer (address listed above).
@package http-enumerator
@version 0.7.3.3


-- | This module contains everything you need to initiate HTTP connections.
--   If you want a simple interface based on URLs, you can use
--   <a>simpleHttp</a>. If you want raw power, <a>http</a> is the
--   underlying workhorse of this package. Some examples:
--   
--   <pre>
--   -- Just download an HTML document and print it.
--   import Network.HTTP.Enumerator
--   import qualified Data.ByteString.Lazy as L
--   
--   main = simpleHttp "http://www.haskell.org/" &gt;&gt;= L.putStr
--   </pre>
--   
--   This example uses interleaved IO to write the response body to a file
--   in constant memory space. By using <a>httpRedirect</a>, it will
--   automatically follow 3xx redirects.
--   
--   <pre>
--   import Data.Enumerator
--   import Data.Enumerator.Binary
--   import Network.HTTP.Enumerator
--   import System.IO
--   
--   main :: IO ()
--   main = withFile "google.html" WriteMode $ \handle -&gt; do
--       request &lt;- parseUrl "http://google.com/"
--       withManager $ \manager -&gt; do
--           run_ $ httpRedirect request (\_ _ -&gt; iterHandle handle) manager
--   </pre>
--   
--   The following headers are automatically set by this module, and should
--   not be added to <a>requestHeaders</a>:
--   
--   <ul>
--   <li>Content-Length</li>
--   <li>Host</li>
--   <li>Accept-Encoding (not currently set, but client usage of this
--   variable <i>will</i> cause breakage).</li>
--   </ul>
--   
--   Any network code on Windows requires some initialization, and the
--   network library provides withSocketsDo to perform it. Therefore,
--   proper usage of this library will always involve calling that function
--   at some point. The best approach is to simply call them at the
--   beginning of your main function, such as:
--   
--   <pre>
--   import Network.HTTP.Enumerator
--   import qualified Data.ByteString.Lazy as L
--   import Network (withSocketsDo)
--   
--   main = withSocketsDo
--        $ simpleHttp "http://www.haskell.org/" &gt;&gt;= L.putStr
--   </pre>
module Network.HTTP.Enumerator

-- | Download the specified URL, following any redirects, and return the
--   response body.
--   
--   This function will <a>throwIO</a> an <a>HttpException</a> for any
--   response with a non-2xx status code. It uses <a>parseUrl</a> to parse
--   the input. This function essentially wraps <a>httpLbsRedirect</a>.
--   
--   Note: Even though this function returns a lazy bytestring, it does
--   <i>not</i> utilize lazy I/O, and therefore the entire response body
--   will live in memory. If you want constant memory usage, you'll need to
--   write your own iteratee and use <a>http</a> or <a>httpRedirect</a>
--   directly.
simpleHttp :: MonadIO m => String -> m ByteString

-- | Download the specified <a>Request</a>, returning the results as a
--   <a>Response</a>.
--   
--   This is a simplified version of <a>http</a> for the common case where
--   you simply want the response data as a simple datatype. If you want
--   more power, such as interleaved actions on the response body during
--   download, you'll need to use <a>http</a> directly. This function is
--   defined as:
--   
--   <pre>
--   httpLbs = http lbsIter
--   </pre>
--   
--   Please see <a>lbsIter</a> for more information on how the
--   <a>Response</a> value is created.
--   
--   Even though a <a>Response</a> contains a lazy bytestring, this
--   function does <i>not</i> utilize lazy I/O, and therefore the entire
--   response body will live in memory. If you want constant memory usage,
--   you'll need to write your own iteratee and use <a>http</a> or
--   <a>httpRedirect</a> directly.
httpLbs :: MonadIO m => Request m -> Manager -> m Response

-- | Download the specified <a>Request</a>, returning the results as a
--   <a>Response</a> and automatically handling redirects.
--   
--   This is a simplified version of <a>httpRedirect</a> for the common
--   case where you simply want the response data as a simple datatype. If
--   you want more power, such as interleaved actions on the response body
--   during download, you'll need to use <a>httpRedirect</a> directly. This
--   function is defined as:
--   
--   <pre>
--   httpLbsRedirect = httpRedirect lbsIter
--   </pre>
--   
--   Please see <a>lbsIter</a> for more information on how the
--   <a>Response</a> value is created.
--   
--   Even though a <a>Response</a> contains a lazy bytestring, this
--   function does <i>not</i> utilize lazy I/O, and therefore the entire
--   response body will live in memory. If you want constant memory usage,
--   you'll need to write your own iteratee and use <a>http</a> or
--   <a>httpRedirect</a> directly.
httpLbsRedirect :: MonadIO m => Request m -> Manager -> m Response

-- | The most low-level function for initiating an HTTP request.
--   
--   The first argument to this function gives a full specification on the
--   request: the host to connect to, whether to use SSL, headers, etc.
--   Please see <a>Request</a> for full details.
--   
--   The second argument specifies how the response should be handled. It's
--   a function that takes two arguments: the first is the HTTP status code
--   of the response, and the second is a list of all response headers.
--   This module exports <a>lbsIter</a>, which generates a <a>Response</a>
--   value.
--   
--   Note that this allows you to have fully interleaved IO actions during
--   your HTTP download, making it possible to download very large
--   responses in constant memory.
http :: MonadIO m => Request m -> (Status -> ResponseHeaders -> Iteratee ByteString m a) -> Manager -> Iteratee ByteString m a

-- | Same as <a>http</a>, but follows all 3xx redirect status codes that
--   contain a location header.
httpRedirect :: MonadIO m => Request m -> (Status -> ResponseHeaders -> Iteratee ByteString m a) -> Manager -> Iteratee ByteString m a

-- | Make a request automatically follow 3xx redirects.
--   
--   Used internally by <a>httpRedirect</a> and family.
redirectIter :: MonadIO m => Int -> Request m -> (Status -> ResponseHeaders -> Iteratee ByteString m a) -> Manager -> (Status -> ResponseHeaders -> Iteratee ByteString m a)

-- | Define a HTTP proxy, consisting of a hostname and port number.
data Proxy
Proxy :: Ascii -> Int -> Proxy

-- | The host name of the HTTP proxy.
proxyHost :: Proxy -> Ascii

-- | The port numner of the HTTP proxy.
proxyPort :: Proxy -> Int

-- | When using the <a>RequestBodyEnum</a> constructor and any function
--   which calls <a>redirectIter</a>, you must ensure that the
--   <a>Enumerator</a> can be called multiple times.
--   
--   The <a>RequestBodyEnumChunked</a> will send a chunked request body,
--   note that not all servers support this. Only use
--   <a>RequestBodyEnumChunked</a> if you know the server you're sending to
--   supports chunked request bodies.
data RequestBody m
RequestBodyLBS :: ByteString -> RequestBody m
RequestBodyBS :: ByteString -> RequestBody m
RequestBodyBuilder :: Int64 -> Builder -> RequestBody m
RequestBodyEnum :: Int64 -> (Enumerator Builder m ()) -> RequestBody m
RequestBodyEnumChunked :: (Enumerator Builder m ()) -> RequestBody m

-- | A simple representation of the HTTP response created by
--   <a>lbsIter</a>.
data Response
Response :: Int -> ResponseHeaders -> ByteString -> Response
statusCode :: Response -> Int
responseHeaders :: Response -> ResponseHeaders
responseBody :: Response -> ByteString

-- | All information on how to connect to a host and what should be sent in
--   the HTTP request.
--   
--   If you simply wish to download from a URL, see <a>parseUrl</a>.
--   
--   The constructor for this data type is not exposed. Instead, you should
--   use either the <a>def</a> method to retrieve a default instance, or
--   <a>parseUrl</a> to construct from a URL, and then use the records
--   below to make modifications. This approach allows http-enumerator to
--   add configuration options without breaking backwards compatibility.
data Request m

-- | The default value for this type.
def :: Default a => a

-- | HTTP request method, eg GET, POST.
method :: Request m -> Method

-- | Whether to use HTTPS (ie, SSL).
secure :: Request m -> Bool

-- | Check if the server certificate is valid. Only relevant for HTTPS.
checkCerts :: Request m -> Ascii -> [X509] -> IO TLSCertificateUsage
host :: Request m -> Ascii
port :: Request m -> Int

-- | Everything from the host to the query string.
path :: Request m -> Ascii

-- | Automatically escaped for your convenience.
queryString :: Request m -> Query
requestHeaders :: Request m -> RequestHeaders
requestBody :: Request m -> RequestBody m

-- | Optional HTTP proxy.
proxy :: Request m -> Maybe Proxy

-- | If True, a chunked and/or gzipped body will not be decoded. Use with
--   caution.
rawBody :: Request m -> Bool

-- | Predicate to specify whether gzipped data should be decompressed on
--   the fly.
decompress :: Request m -> ContentType -> Bool
defaultCheckCerts :: Ascii -> [X509] -> IO TLSCertificateUsage

-- | Keeps track of open connections for keep-alive.
data Manager

-- | Create a new <a>Manager</a> with no open connection.
newManager :: IO Manager

-- | Close all connections in a <a>Manager</a>. Afterwards, the
--   <a>Manager</a> can be reused if desired.
closeManager :: Manager -> IO ()

-- | Create a new <a>Manager</a>, call the supplied function and then close
--   it.
withManager :: MonadBaseControl IO m => (Manager -> m a) -> m a

-- | Convert a URL into a <a>Request</a>.
--   
--   This defaults some of the values in <a>Request</a>, such as setting
--   <a>method</a> to GET and <a>requestHeaders</a> to <tt>[]</tt>.
--   
--   Since this function uses <a>Failure</a>, the return monad can be
--   anything that is an instance of <a>Failure</a>, such as <a>IO</a> or
--   <a>Maybe</a>.
parseUrl :: Failure HttpException m => String -> m (Request m')

-- | Add a Basic Auth header (with the specified user name and password) to
--   the given Request. Ignore error handling:
--   
--   applyBasicAuth "user" "pass" $ fromJust $ parseUrl url
applyBasicAuth :: ByteString -> ByteString -> Request m -> Request m

-- | Add a proxy to the the Request so that the Request when executed will
--   use the provided proxy.
addProxy :: ByteString -> Int -> Request m -> Request m

-- | Same as <a>parseUrl</a>, with one distinction: this function will not
--   attempt to parse the query string, but instead leave it with the path
--   info. This can be useful if you need precise control of the rendering
--   of the query string, such as using semicolons instead of ampersands.
semiParseUrl :: Failure HttpException m => String -> m (Request m')

-- | Convert the HTTP response into a <a>Response</a> value.
--   
--   Even though a <a>Response</a> contains a lazy bytestring, this
--   function does <i>not</i> utilize lazy I/O, and therefore the entire
--   response body will live in memory. If you want constant memory usage,
--   you'll need to write your own iteratee and use <a>http</a> or
--   <a>httpRedirect</a> directly.
lbsIter :: Monad m => Status -> ResponseHeaders -> Iteratee ByteString m Response

-- | Always decompress a compressed stream.
alwaysDecompress :: ContentType -> Bool

-- | Decompress a compressed stream unless the content-type is
--   'application/x-tar'.
browserDecompress :: ContentType -> Bool

-- | Add url-encoded paramters to the <a>Request</a>.
--   
--   This sets a new <a>requestBody</a>, adds a content-type request header
--   and changes the <a>method</a> to POST.
urlEncodedBody :: Monad m => [(ByteString, ByteString)] -> Request m' -> Request m
data HttpException
StatusCodeException :: Int -> ByteString -> HttpException
InvalidUrlException :: String -> String -> HttpException
TooManyRedirects :: HttpException
HttpParserException :: String -> HttpException
instance Typeable Response
instance Typeable HttpException
instance Show Response
instance Read Response
instance Eq Response
instance Show HttpException
instance Exception HttpException
instance Default (Request m)
