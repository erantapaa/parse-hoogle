-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | High level interface for webkit-javascriptcore
--   
@package jsc
@version 0.1.1.1


module Language.Javascript.JSC.Types
type JSValueRef = Ptr OpaqueJSValue
type JSValueRefRef = Ptr JSValueRef
type JSObjectRef = Ptr OpaqueJSValue
type JSPropertyNameArrayRef = Ptr OpaqueJSPropertyNameArray
type JSPropertyAttributes = CUInt
type JSContextRef = Ptr OpaqueJSContext
type JSStringRef = Ptr OpaqueJSString
type Index = CUInt


-- | Helper function to make it easy to embed JMacro in your code and use
--   it from JSC
module Language.Javascript.JSC.JMacro

-- | Quasi quoter that creates a JavaScript string from JMacro statement
--   and stores it in a string litteral
evalJM :: QuasiQuoter

-- | Quasi quoter that creates a JavaScript string from JMacro expression
--   and stores it in a string litteral
evalJME :: QuasiQuoter


-- | JSC monad keeps track of the JavaScript context
module Language.Javascript.JSC.Monad

-- | The <tt>JSC</tt> monad keeps track of the JavaScript context.
--   
--   Given a <tt>JSC</tt> function and a <a>JSContextRef</a> you can run
--   the function like this...
--   
--   <pre>
--   runReaderT jscFunction javaScriptContext
--   </pre>
--   
--   For an example of how to set up WebKitGTK+ see tests/TestJSC.hs
type JSC = ReaderT JSContextRef IO
type JSContextRef = Ptr OpaqueJSContext
runJSC :: WebView -> JSC a -> IO a
runJSC_ :: WebView -> JSC a -> IO ()

-- | Handle JavaScriptCore functions that take a JSValueRefRef in order to
--   throw exceptions.
catchval :: (JSValueRefRef -> JSC a) -> (JSValueRef -> JSC a) -> JSC a

-- | Wrapped version of <a>catch</a> that runs in a MonadIO that works a
--   bit better with <a>JSC</a>
catch :: (MonadIO m, Exception e) => ReaderT r IO b -> (e -> ReaderT r IO b) -> ReaderT r m b


module Language.Javascript.JSC.Exception
data JSException
JSException :: JSValueRef -> JSException

-- | Catch JavaScript exceptions and rethrow Haskell ones
rethrow :: (JSValueRefRef -> JSC a) -> JSC a
instance Typeable JSException
instance Show JSException
instance Exception JSException


-- | These classes are used to make various JavaScriptCore types out of
--   whatever we have. Functions in jsc take these as inputs. This alows
--   implicit casting and eager evaluation.
module Language.Javascript.JSC.Classes

-- | Anything that can be used to make a JavaScript value reference
class MakeValueRef a
makeValueRef :: MakeValueRef a => a -> JSC JSValueRef

-- | Anything that can be used to make a JavaScript string reference
class MakeStringRef a
makeStringRef :: MakeStringRef a => a -> JSStringRef

-- | Anything that can be used to make a list of JavaScript value
--   references for use as function arguments
class MakeArgRefs this
makeArgRefs :: MakeArgRefs this => this -> JSC [JSValueRef]

-- | Anything that can be used to make a JavaScript object reference
class MakeObjectRef this
makeObjectRef :: MakeObjectRef this => this -> JSC JSObjectRef

-- | Anything that can be used to make a JavaScript property reference
class MakePropRef this
makePropRef :: MakePropRef this => this -> JSC JSPropRef


module Language.Javascript.JSC.Arguments

-- | Anything that can be used to make a list of JavaScript value
--   references for use as function arguments
class MakeArgRefs this
makeArgRefs :: MakeArgRefs this => this -> JSC [JSValueRef]
instance (MakeValueRef arg1, MakeValueRef arg2, MakeValueRef arg3, MakeValueRef arg4, MakeValueRef arg5) => MakeArgRefs (arg1, arg2, arg3, arg4, arg5)
instance (MakeValueRef arg1, MakeValueRef arg2, MakeValueRef arg3, MakeValueRef arg4) => MakeArgRefs (arg1, arg2, arg3, arg4)
instance (MakeValueRef arg1, MakeValueRef arg2, MakeValueRef arg3) => MakeArgRefs (arg1, arg2, arg3)
instance (MakeValueRef arg1, MakeValueRef arg2) => MakeArgRefs (arg1, arg2)
instance MakeValueRef arg => MakeArgRefs [arg]
instance MakeArgRefs arg => MakeArgRefs (JSC arg)


-- | JavaScript string conversion functions
module Language.Javascript.JSC.String
type JSStringRef = Ptr OpaqueJSString

-- | Anything that can be used to make a JavaScript string reference
class MakeStringRef a
makeStringRef :: MakeStringRef a => a -> JSStringRef

-- | Convert a JavaScript string to a Haskell <a>Text</a>
strToText :: MonadIO m => JSStringRef -> m Text

-- | Convert a Haskell <a>Text</a> to a JavaScript string
textToStr :: Text -> JSStringRef
instance MakeStringRef String
instance MakeStringRef Text
instance MakeStringRef JSStringRef


-- | Deals with JavaScript values. These can be
--   
--   <ul>
--   <li>null</li>
--   <li>undefined</li>
--   <li>true | false</li>
--   <li>a double precision floating point number</li>
--   <li>a string</li>
--   <li>an object</li>
--   </ul>
module Language.Javascript.JSC.Value
type JSValueRef = Ptr OpaqueJSValue

-- | Anything that can be used to make a JavaScript value reference
class MakeValueRef a
makeValueRef :: MakeValueRef a => a -> JSC JSValueRef
data JSNull

-- | Type that represents a value that can only be null. Haskell of course
--   has no null so we are adding this type.
JSNull :: JSNull
type JSUndefined = ()
type JSBool = Bool
type JSNumber = Double
type JSString = Text

-- | An algebraic data type that can represent a JavaScript value. Any
--   JavaScriptCore <a>JSValueRef</a> can be converted into this type.
data JSValue

-- | null
ValNull :: JSValue

-- | undefined
ValUndefined :: JSValue

-- | true or false
ValBool :: JSBool -> JSValue

-- | a number
ValNumber :: JSNumber -> JSValue

-- | a string
ValString :: JSString -> JSValue

-- | an object
ValObject :: JSObjectRef -> JSValue

-- | Given a JavaScript value get its boolean value. All values in
--   JavaScript convert to bool.
--   
--   <pre>
--   &gt;&gt;&gt; testJSC $ valToBool JSNull
--   false
--   
--   &gt;&gt;&gt; testJSC $ valToBool ()
--   false
--   
--   &gt;&gt;&gt; testJSC $ valToBool True
--   true
--   
--   &gt;&gt;&gt; testJSC $ valToBool False
--   false
--   
--   &gt;&gt;&gt; testJSC $ valToBool (1.0 :: Double)
--   true
--   
--   &gt;&gt;&gt; testJSC $ valToBool (0.0 :: Double)
--   false
--   
--   &gt;&gt;&gt; testJSC $ valToBool ""
--   false
--   
--   &gt;&gt;&gt; testJSC $ valToBool "1"
--   true
--   </pre>
valToBool :: MakeValueRef val => val -> JSC JSBool

-- | Given a JavaScript value get its numeric value. May throw JSException.
--   
--   <pre>
--   &gt;&gt;&gt; testJSC $ show &lt;$&gt; valToNumber JSNull
--   0.0
--   
--   &gt;&gt;&gt; testJSC $ show &lt;$&gt; valToNumber ()
--   NaN
--   
--   &gt;&gt;&gt; testJSC $ show &lt;$&gt; valToNumber True
--   1.0
--   
--   &gt;&gt;&gt; testJSC $ show &lt;$&gt; valToNumber False
--   0.0
--   
--   &gt;&gt;&gt; testJSC $ show &lt;$&gt; valToNumber (1.0 :: Double)
--   1.0
--   
--   &gt;&gt;&gt; testJSC $ show &lt;$&gt; valToNumber (0.0 :: Double)
--   0.0
--   
--   &gt;&gt;&gt; testJSC $ show &lt;$&gt; valToNumber ""
--   0.0
--   
--   &gt;&gt;&gt; testJSC $ show &lt;$&gt; valToNumber "1"
--   1.0
--   </pre>
valToNumber :: MakeValueRef val => val -> JSC JSNumber

-- | Given a JavaScript value get its string value (as a JavaScript
--   string). May throw JSException.
--   
--   <pre>
--   &gt;&gt;&gt; testJSC $ valToStr JSNull &gt;&gt;= strToText
--   null
--   
--   &gt;&gt;&gt; testJSC $ valToStr () &gt;&gt;= strToText
--   undefined
--   
--   &gt;&gt;&gt; testJSC $ valToStr True &gt;&gt;= strToText
--   true
--   
--   &gt;&gt;&gt; testJSC $ valToStr False &gt;&gt;= strToText
--   false
--   
--   &gt;&gt;&gt; testJSC $ valToStr (1.0 :: Double) &gt;&gt;= strToText
--   1
--   
--   &gt;&gt;&gt; testJSC $ valToStr (0.0 :: Double) &gt;&gt;= strToText
--   0
--   
--   &gt;&gt;&gt; testJSC $ valToStr "" &gt;&gt;= strToText
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; testJSC $ valToStr "1" &gt;&gt;= strToText
--   1
--   </pre>
valToStr :: MakeValueRef val => val -> JSC JSStringRef

-- | Given a JavaScript value get its object value. May throw JSException.
--   
--   <pre>
--   &gt;&gt;&gt; testJSC $ (valToObject JSNull &gt;&gt;= valToText) `catch` \ (JSException e) -&gt; valToText e
--   TypeError: 'null' is not an object
--   
--   &gt;&gt;&gt; testJSC $ (valToObject () &gt;&gt;= valToText) `catch` \ (JSException e) -&gt; valToText e
--   TypeError: 'undefined' is not an object
--   
--   &gt;&gt;&gt; testJSC $ valToObject True
--   true
--   
--   &gt;&gt;&gt; testJSC $ valToObject False
--   false
--   
--   &gt;&gt;&gt; testJSC $ valToObject (1.0 :: Double)
--   1
--   
--   &gt;&gt;&gt; testJSC $ valToObject (0.0 :: Double)
--   0
--   
--   &gt;&gt;&gt; testJSC $ valToObject ""
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; testJSC $ valToObject "1"
--   1
--   </pre>
valToObject :: MakeValueRef val => val -> JSC JSObjectRef

-- | Given a JavaScript value get its string value (as a Haskell
--   <a>Text</a>). May throw JSException.
--   
--   <pre>
--   &gt;&gt;&gt; testJSC $ show &lt;$&gt; valToText JSNull
--   "null"
--   
--   &gt;&gt;&gt; testJSC $ show &lt;$&gt; valToText ()
--   "undefined"
--   
--   &gt;&gt;&gt; testJSC $ show &lt;$&gt; valToText True
--   "true"
--   
--   &gt;&gt;&gt; testJSC $ show &lt;$&gt; valToText False
--   "false"
--   
--   &gt;&gt;&gt; testJSC $ show &lt;$&gt; valToText (1.0 :: Double)
--   "1"
--   
--   &gt;&gt;&gt; testJSC $ show &lt;$&gt; valToText (0.0 :: Double)
--   "0"
--   
--   &gt;&gt;&gt; testJSC $ show &lt;$&gt; valToText ""
--   ""
--   
--   &gt;&gt;&gt; testJSC $ show &lt;$&gt; valToText "1"
--   "1"
--   </pre>
valToText :: MakeValueRef val => val -> JSC Text

-- | Given a JavaScript value get a JSON string value. May throw
--   JSException.
--   
--   <pre>
--   &gt;&gt;&gt; testJSC $ valToJSON 0 JSNull &gt;&gt;= strToText
--   null
--   
--   &gt;&gt;&gt; testJSC $ valToJSON 0 () &gt;&gt;= strToText
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; testJSC $ valToJSON 0 True &gt;&gt;= strToText
--   true
--   
--   &gt;&gt;&gt; testJSC $ valToJSON 0 False &gt;&gt;= strToText
--   false
--   
--   &gt;&gt;&gt; testJSC $ valToJSON 0 (1.0 :: Double) &gt;&gt;= strToText
--   1
--   
--   &gt;&gt;&gt; testJSC $ valToJSON 0 (0.0 :: Double) &gt;&gt;= strToText
--   0
--   
--   &gt;&gt;&gt; testJSC $ valToJSON 0 "" &gt;&gt;= strToText
--   ""
--   
--   &gt;&gt;&gt; testJSC $ valToJSON 0 "1" &gt;&gt;= strToText
--   "1"
--   
--   &gt;&gt;&gt; testJSC $ obj &gt;&gt;= valToJSON 0 &gt;&gt;= strToText
--   {}
--   </pre>
valToJSON :: MakeValueRef val => Word -> val -> JSC JSStringRef

-- | Convert to a JavaScript value (just an alias for <a>makeValueRef</a>)
val :: MakeValueRef value => value -> JSC JSValueRef

-- | Make a <tt>null</tt> JavaScript value
valMakeNull :: JSC JSValueRef

-- | Make an <tt>undefined</tt> JavaScript value
valMakeUndefined :: JSC JSValueRef

-- | Make a JavaScript boolean value
valMakeBool :: JSBool -> JSC JSValueRef

-- | Make a JavaScript number
valMakeNumber :: JSNumber -> JSC JSValueRef

-- | Make a JavaScript string
valMakeString :: Text -> JSC JSValueRef

-- | Derefernce a value reference.
--   
--   <pre>
--   &gt;&gt;&gt; testJSC $ show &lt;$&gt; deRefVal JSNull
--   ValNull
--   
--   &gt;&gt;&gt; testJSC $ show &lt;$&gt; deRefVal ()
--   ValUndefined
--   
--   &gt;&gt;&gt; testJSC $ show &lt;$&gt; deRefVal True
--   ValBool True
--   
--   &gt;&gt;&gt; testJSC $ show &lt;$&gt; deRefVal False
--   ValBool False
--   
--   &gt;&gt;&gt; testJSC $ show &lt;$&gt; deRefVal (1.0 :: Double)
--   ValNumber 1.0
--   
--   &gt;&gt;&gt; testJSC $ show &lt;$&gt; deRefVal (0.0 :: Double)
--   ValNumber 0.0
--   
--   &gt;&gt;&gt; testJSC $ show &lt;$&gt; deRefVal ""
--   ValString ""
--   
--   &gt;&gt;&gt; testJSC $ show &lt;$&gt; deRefVal "1"
--   ValString "1"
--   
--   &gt;&gt;&gt; testJSC $ show &lt;$&gt; valToObject True &gt;&gt;= deRefVal
--   ValObject 0x...
--   </pre>
deRefVal :: MakeValueRef val => val -> JSC JSValue

-- | Make a JavaScript value out of a <a>JSValue</a> ADT.
--   
--   <pre>
--   &gt;&gt;&gt; testJSC $ valMakeRef ValNull
--   "null"
--   
--   &gt;&gt;&gt; testJSC $ valMakeRef ValUndefined
--   "undefined"
--   
--   &gt;&gt;&gt; testJSC $ valMakeRef (ValBool True)
--   "true"
--   
--   &gt;&gt;&gt; testJSC $ valMakeRef (ValNumber 1)
--   "1"
--   
--   &gt;&gt;&gt; testJSC $ valMakeRef (ValString $ pack "Hello")
--   "Hello"
--   </pre>
valMakeRef :: JSValue -> JSC JSValueRef
instance Show JSValue
instance Eq JSValue
instance MakeObjectRef JSNull
instance MakeArgRefs JSValue
instance MakeValueRef JSValue
instance MakeValueRef String
instance MakeArgRefs Text
instance MakeValueRef Text
instance MakeArgRefs Double
instance MakeValueRef Double
instance MakeArgRefs Bool
instance MakeValueRef Bool
instance MakeArgRefs ()
instance MakeValueRef JSUndefined
instance MakeArgRefs JSNull
instance MakeValueRef JSNull
instance MakeValueRef v => MakeValueRef (JSC v)
instance MakeArgRefs JSValueRef
instance MakeValueRef JSValueRef


-- | Low level JavaScript object property access. In most cases you should
--   use <a>Language.Javascript.JSC.Object</a> instead.
--   
--   This module is mostly here to implement functions needed to use
--   <a>JSPropRef</a>.
module Language.Javascript.JSC.Properties

-- | A reference to a property. Implemented as a reference to an object and
--   something to find the property.
data JSPropRef

-- | Object and property name.
JSPropRef :: JSObjectRef -> JSStringRef -> JSPropRef

-- | Object and property index.
JSPropIndexRef :: JSObjectRef -> Index -> JSPropRef

-- | Anything that can be used to make a JavaScript property reference
class MakePropRef this
makePropRef :: MakePropRef this => this -> JSC JSPropRef

-- | Get a property value given the object and the name of the property.
objGetPropertyByName :: MakeStringRef name => JSObjectRef -> name -> JSValueRefRef -> JSC JSValueRef

-- | Get a property value given the object and the index of the property.
objGetPropertyAtIndex :: JSObjectRef -> Index -> JSValueRefRef -> JSC JSValueRef

-- | Gets the value of a property given a <a>JSPropRef</a>.
objGetProperty :: JSPropRef -> JSC JSValueRef

-- | This version of <a>objGetProperty</a> is handy when you also need to
--   perform. another operation on the object the property is on.
objGetProperty' :: JSPropRef -> JSC (JSObjectRef, JSValueRef)

-- | Set a property value given the object and the name of the property.
objSetPropertyByName :: (MakeStringRef name, MakeValueRef val) => JSObjectRef -> name -> val -> JSPropertyAttributes -> JSValueRefRef -> JSC ()

-- | Set a property value given the object and the index of the property.
objSetPropertyAtIndex :: MakeValueRef val => JSObjectRef -> Index -> val -> JSValueRefRef -> JSC ()

-- | Sets the value of a property given a <a>JSPropRef</a>.
objSetProperty :: MakeValueRef val => JSPropRef -> val -> JSC ()
instance MakeArgRefs JSPropRef
instance MakeValueRef JSPropRef
instance MakeObjectRef JSPropRef
instance MakePropRef prop => MakePropRef (JSC prop)
instance MakePropRef JSPropRef


-- | Interface to JavaScript object
module Language.Javascript.JSC.Object
type JSObjectRef = Ptr OpaqueJSValue

-- | Anything that can be used to make a JavaScript object reference
class MakeObjectRef this
makeObjectRef :: MakeObjectRef this => this -> JSC JSObjectRef

-- | Lookup a property based on its name. This function just constructs a
--   JSPropRef the lookup is delayed until we use the JSPropRef. This makes
--   it a bit lazy compared to JavaScript's <tt>.</tt> operator.
--   
--   <pre>
--   &gt;&gt;&gt; testJSC $ eval "'Hello World'.length"
--   
--   &gt;&gt;&gt; testJSC $ val "Hello World" ! "length"
--   11
--   </pre>
(!) :: (MakeObjectRef this, MakeStringRef name) => this -> name -> JSC JSPropRef

-- | Lookup a property based on its index. This function just constructs a
--   JSPropRef the lookup is delayed until we use the JSPropRef. This makes
--   it a bit lazy compared to JavaScript's <tt>[]</tt> operator.
--   
--   <pre>
--   &gt;&gt;&gt; testJSC $ eval "'Hello World'[6]"
--   
--   &gt;&gt;&gt; testJSC $ val "Hello World" !! 6
--   W
--   </pre>
(!!) :: MakeObjectRef this => this -> Index -> JSC JSPropRef

-- | Makes a getter for a particular property name.
--   
--   <pre>
--   js name = to (!name)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; testJSC $ eval "'Hello World'.length"
--   
--   &gt;&gt;&gt; testJSC $ val "Hello World" ^. js "length"
--   11
--   </pre>
js :: (MakeObjectRef s, MakeStringRef name) => name -> IndexPreservingGetter s (JSC JSPropRef)

-- | Java script function applications have this type
type JSF = MakeObjectRef o => IndexPreservingGetter o (JSC JSValueRef)

-- | Handy way to call a function
--   
--   <pre>
--   jsf name = js name . to (# args)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; testJSC $ val "Hello World" ^. jsf "indexOf" ["World"]
--   6
--   </pre>
jsf :: (MakeStringRef name, MakeArgRefs args) => name -> args -> JSF

-- | Handy way to call a function that expects no arguments
--   
--   <pre>
--   js0 name = jsf name ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; testJSC $ val "Hello World" ^. js0 "toLowerCase"
--   hello world
--   </pre>
js0 :: MakeStringRef name => name -> JSF

-- | Handy way to call a function that expects one argument
--   
--   <pre>
--   js1 name a0 = jsf name [a0]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; testJSC $ val "Hello World" ^. js1 "indexOf" "World"
--   6
--   </pre>
js1 :: (MakeStringRef name, MakeValueRef a0) => name -> a0 -> JSF

-- | Handy way to call a function that expects two arguments
js2 :: (MakeStringRef name, MakeValueRef a0, MakeValueRef a1) => name -> a0 -> a1 -> JSF

-- | Handy way to call a function that expects three arguments
js3 :: (MakeStringRef name, MakeValueRef a0, MakeValueRef a1, MakeValueRef a2) => name -> a0 -> a1 -> a2 -> JSF

-- | Handy way to call a function that expects four arguments
js4 :: (MakeStringRef name, MakeValueRef a0, MakeValueRef a1, MakeValueRef a2, MakeValueRef a3) => name -> a0 -> a1 -> a2 -> a3 -> JSF

-- | Handy way to call a function that expects five arguments
js5 :: (MakeStringRef name, MakeValueRef a0, MakeValueRef a1, MakeValueRef a2, MakeValueRef a3, MakeValueRef a4) => name -> a0 -> a1 -> a2 -> a3 -> a4 -> JSF

-- | Handy way to get and hold onto a reference top level javascript
--   
--   <pre>
--   &gt;&gt;&gt; testJSC $ eval "w = console; w.log('Hello World')"
--   
--   &gt;&gt;&gt; testJSC $ do w &lt;- jsg "console"; w ^. js "log" # ["Hello World"]
--   11
--   </pre>
jsg :: MakeStringRef a => a -> JSC JSPropRef

-- | Call a JavaScript function
--   
--   <pre>
--   &gt;&gt;&gt; testJSC $ eval "var j = {}; j.x = 1; j.x"
--   
--   &gt;&gt;&gt; testJSC $ do {j &lt;- eval "({})"; j!"x" &lt;# 1; j!"x"}
--   1
--   </pre>
(<#) :: (MakePropRef prop, MakeValueRef val) => prop -> val -> JSC JSPropRef

-- | Call a JavaScript function
--   
--   <pre>
--   &gt;&gt;&gt; testJSC $ eval "'Hello World'.indexOf('World')"
--   
--   &gt;&gt;&gt; testJSC $ val "Hello World" ! "indexOf" # ["World"]
--   6
--   </pre>
(#) :: (MakePropRef prop, MakeArgRefs args) => prop -> args -> JSC JSValueRef

-- | Use this to create a new JavaScript object
--   
--   <pre>
--   &gt;&gt;&gt; testJSC $ new "Date" (2013, 1, 1)
--   Fri Feb 01 2013 00:00:00 GMT+1300 (NZDT)
--   </pre>
new :: (MakeObjectRef constructor, MakeArgRefs args) => constructor -> args -> JSC JSValueRef

-- | Call function with a given <tt>this</tt>. In most cases you should use
--   '#'.
--   
--   <pre>
--   &gt;&gt;&gt; testJSC $ eval "(function(){return this;}).apply('Hello', [])"
--   
--   &gt;&gt;&gt; testJSC $ do { test &lt;- eval "(function(){return this;})"; call test (val "Hello") () }
--   Hello
--   </pre>
call :: (MakeObjectRef function, MakeObjectRef this, MakeArgRefs args) => function -> this -> args -> JSC JSValueRef

-- | Make an empty object using the default constuctor
--   
--   <pre>
--   &gt;&gt;&gt; testJSC $ eval "var a = {}; a.x = 'Hello'; a.x"
--   
--   &gt;&gt;&gt; testJSC $ do { a &lt;- obj; a ^. js "x" &lt;# "Hello"; a ^. js "x" }
--   Hello
--   </pre>
obj :: JSC JSObjectRef
function :: MakeStringRef name => name -> JSCallAsFunction -> JSC JSObjectRef

-- | Short hand <tt>::JSCallAsFunction</tt> so a haskell function can be
--   passed to a to a JavaScipt one.
--   
--   <pre>
--   &gt;&gt;&gt; testJSC $ eval "(function(f) {f('Hello');})(function (a) {console.log(a)})"
--   
--   &gt;&gt;&gt; testJSC $ call (eval "(function(f) {f('Hello');})") global [fun $ \ _ _ args -&gt; valToText (head args) &gt;&gt;= (liftIO . putStrLn . T.unpack) ]
--   Hello
--   undefined
--   </pre>
fun :: JSCallAsFunction -> JSCallAsFunction

-- | Type used for Haskell functions called from JavaScript.
type JSCallAsFunction = JSValueRef -> JSValueRef -> [JSValueRef] -> JSC JSUndefined

-- | Make an JavaScript array from a list of values
--   
--   <pre>
--   &gt;&gt;&gt; testJSC $ eval "['Hello', 'World'][1]"
--   
--   &gt;&gt;&gt; testJSC $ array ["Hello", "World"] !! 1
--   World
--   
--   &gt;&gt;&gt; testJSC $ eval "['Hello', null, undefined, true, 1]"
--   
--   &gt;&gt;&gt; testJSC $ array ("Hello", JSNull, (), True, 1.0::Double)
--   Hello,,,true,1
--   </pre>
array :: MakeArgRefs args => args -> JSC JSObjectRef

-- | JavaScript's global object
global :: JSC JSObjectRef

-- | Get a list containing the property names present on a given object
propertyNames :: MakeObjectRef this => this -> JSC [JSStringRef]

-- | Call a JavaScript object as function. Consider using '#'.
objCallAsFunction :: MakeArgRefs args => JSObjectRef -> JSObjectRef -> args -> JSValueRefRef -> JSC JSValueRef

-- | Call a JavaScript object as a constructor. Consider using <a>new</a>.
objCallAsConstructor :: MakeArgRefs args => JSObjectRef -> args -> JSValueRefRef -> JSC JSValueRef
instance MakeArgRefs JSCallAsFunction
instance MakeValueRef JSCallAsFunction
instance MakeObjectRef v => MakeObjectRef (JSC v)
instance MakeObjectRef JSObjectRef


-- | If you just want to run some JavaScript that you have as a string this
--   is you can use <a>eval</a> or <a>evaluateScript</a>.
module Language.Javascript.JSC.Evaluate

-- | Evaluates a script (like eval in java script). Unlike <a>eval</a> this
--   function lets you specify a source URL and starting line number for
--   beter error information.
--   
--   <pre>
--   &gt;&gt;&gt; testJSC $ (evaluateScript "\n\n{" global "FileName" 53 &gt;&gt;= valToText) `catch` \(JSException e) -&gt; array (e,e!"sourceURL", e!"line") &gt;&gt;= valToText
--   SyntaxError: Expected token '}',FileName,55
--   </pre>
evaluateScript :: (MakeStringRef script, MakeObjectRef this, MakeStringRef url) => script -> this -> url -> Int -> JSC JSValueRef

-- | Evaluates a script (like eval in java script)
--   
--   <pre>
--   &gt;&gt;&gt; testJSC $ eval "1+1"
--   2
--   </pre>
eval :: MakeStringRef script => script -> JSC JSValueRef


-- | This package provides an EDSL for calling JavaScript code using the
--   JavaScriptCore engine and low level Haskell bindings in the
--   webkit-javascriptcore library
--   <a>https://github.com/ghcjs/webkit-javascriptcore</a>.
module Language.Javascript.JSC
