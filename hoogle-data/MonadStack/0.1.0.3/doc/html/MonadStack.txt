-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generalizing lift to monad stacks
--   
@package MonadStack
@version 0.1.0.3


-- | MonadStack provides a multi-level <tt>lift</tt> function, called
--   <tt>liftFrom</tt>. It allows lifting from an arbitrary monad in a
--   monad transformer stack up to any higher monad in that stack. And
--   example use might be:
--   
--   <pre>
--   newtype MyMonad = MyMonad ... deriving (Monad)
--   
--   doFoo :: MonadStack MyMonad m =&gt; something -&gt; m whatever
--   doFoo arg = liftFrom go
--       where
--           go :: MyMonad whatever
--           go = do ...
--   </pre>
--   
--   This allows calling doFoo either in the MyMonad monad, or in any monad
--   transformer stack on top of the MyMonad.
--   
--   MonadStack is similar to the <tt>Control.Monad.Base</tt> module from
--   the <a>transformers-base</a> package, except that there is no
--   functional dependency between the monads. A monad transformer stack
--   can only have one base, but it can have several MonadStack
--   implementations.
--   
--   MonadStack is very similar to the <tt>Control.Monad.Lifter</tt> module
--   from the <a>MonadCompose</a> package, with two exceptions. One,
--   MonadStack does not require the OverlappingInstances and
--   UndecidableInstances extensions- both of which are prone to generating
--   hard to diagnose bugs. But this implies two, that MonadStack is much
--   less feature-rich than Lifter is. Specifically, MonadStack only works
--   with "proper" monad transformers (those that implment
--   <tt>MonadTrans</tt>), while Lifter generalizes the notion of lifting
--   and works with more different types of monads, especially
--   <tt>MonadPlus</tt>.
module Control.Monad.MonadStack

-- | A multi-level lifter class.
--   
--   The existance of an implementation of <tt>MonadStack m n</tt> implies
--   that is is possible to convert an <tt>m a</tt> into an <tt>n a</tt>
--   via zero or more applications of <tt>lift</tt>.
class MonadStack m n
liftFrom :: MonadStack m n => m a -> n a

-- | The base case implementation
--   
--   You can always convert an <tt>m a</tt> into an <tt>m a</tt> by
--   applying 0 lifts. This is like treating an <tt>m a</tt> as a
--   zero-level monad transformer stack (a monad transformer stack with no
--   monad transformers), and <tt>liftFrom</tt> is just the <tt>id</tt>
--   function.

-- | The inductive step implementation
--   
--   If there exists an implementation of <tt>MonadStack k m</tt> for
--   monads <tt>k</tt> and <tt>m</tt> (that is, we can perform a
--   <tt>liftFrom</tt> to convert a <tt>k a</tt> to a <tt>m a</tt>), and n
--   is a monad transformer, then we can construct an implementation of
--   <tt>MonadStack k (n m)</tt>, by just adding one more <tt>lift</tt> to
--   the <tt>liftFrom</tt>.
instance (Monad k, Monad m, MonadTrans n, MonadStack k m) => MonadStack k (n m)
instance MonadStack m m
