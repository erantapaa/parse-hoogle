-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Purely functional sets and heaps
--   
--   Purely functional data structure including red-black trees,
--   left-leaning red-black trees, weight balanced trees, splay trees, skew
--   heaps, leftist heaps, splay heaps, and binominal heaps.
@package llrbtree
@version 0.1.1


-- | Binominal Heap
--   
--   <ul>
--   <li>the fun of programming</li>
--   </ul>
module Data.Heap.Binominal
newtype Heap a
Heap :: [Tree a] -> Heap a
data Tree a

-- | Rank, a minimum root element, trees
Node :: Rank -> a -> [Tree a] -> Tree a
type Rank = Int

-- | Empty heap.
empty :: Heap a

-- | Singleton heap.
singleton :: a -> Heap a

-- | Insertion.
--   
--   <pre>
--   &gt;&gt;&gt; insert 7 (fromList [5,3]) == fromList [3,5,7]
--   True
--   
--   &gt;&gt;&gt; insert 5 empty            == singleton 5
--   True
--   </pre>
insert :: Ord a => a -> Heap a -> Heap a

-- | Creating a heap from a list.
--   
--   <pre>
--   &gt;&gt;&gt; empty == fromList []
--   True
--   
--   &gt;&gt;&gt; singleton 'a' == fromList ['a']
--   True
--   
--   &gt;&gt;&gt; fromList [5,3] == fromList [5,3]
--   True
--   </pre>
fromList :: Ord a => [a] -> Heap a

-- | Creating a list from a heap. O(N)
--   
--   <pre>
--   &gt;&gt;&gt; let xs = [5,3,5]
--   
--   &gt;&gt;&gt; length (toList (fromList xs)) == length xs
--   True
--   
--   &gt;&gt;&gt; toList empty
--   []
--   </pre>
toList :: Heap a -> [a]

-- | Deleting the minimum element.
--   
--   <pre>
--   &gt;&gt;&gt; deleteMin (fromList [5,3,7]) == fromList [5,7]
--   True
--   
--   &gt;&gt;&gt; deleteMin empty == empty
--   True
--   </pre>
deleteMin :: Ord a => Heap a -> Heap a

-- | See if the heap is empty.
--   
--   <pre>
--   &gt;&gt;&gt; Data.Heap.Binominal.null empty
--   True
--   
--   &gt;&gt;&gt; Data.Heap.Binominal.null (singleton 1)
--   False
--   </pre>
null :: Heap a -> Bool

-- | Merging two heaps
--   
--   <pre>
--   &gt;&gt;&gt; merge (fromList [5,3]) (fromList [5,7]) == fromList [3,5,5,7]
--   True
--   </pre>
merge :: Ord a => Heap a -> Heap a -> Heap a

-- | Finding the minimum element.
--   
--   <pre>
--   &gt;&gt;&gt; minimum (fromList [3,5,1])
--   Just 1
--   
--   &gt;&gt;&gt; minimum empty
--   Nothing
--   </pre>
minimum :: Ord a => Heap a -> Maybe a

-- | Checking validity of a heap.
valid :: Ord a => Heap a -> Bool
heapSort :: Ord a => Heap a -> [a]
instance Show a => Show (Tree a)
instance Show a => Show (Heap a)
instance (Eq a, Ord a) => Eq (Heap a)


-- | Purely functional top-down splay heaps.
--   
--   <ul>
--   <li>D.D. Sleator and R.E. Rarjan, "Self-Adjusting Binary Search Tree",
--   Journal of the Association for Computing Machinery, Vol 32, No 3, July
--   1985, pp 652-686.
--   <a>http://www.cs.cmu.edu/~sleator/papers/self-adjusting.pdf</a></li>
--   </ul>
module Data.Heap.Splay
data Heap a
None :: Heap a
Some :: a -> (Splay a) -> Heap a
data Splay a
Leaf :: Splay a
Node :: (Splay a) -> a -> (Splay a) -> Splay a

-- | Empty heap.
empty :: Heap a

-- | Singleton heap.
singleton :: a -> Heap a

-- | Insertion.
--   
--   <pre>
--   &gt;&gt;&gt; insert 7 (fromList [5,3]) == fromList [3,5,7]
--   True
--   
--   &gt;&gt;&gt; insert 5 empty            == singleton 5
--   True
--   </pre>
insert :: Ord a => a -> Heap a -> Heap a

-- | Creating a heap from a list.
--   
--   <pre>
--   &gt;&gt;&gt; empty == fromList []
--   True
--   
--   &gt;&gt;&gt; singleton 'a' == fromList ['a']
--   True
--   
--   &gt;&gt;&gt; fromList [5,3] == fromList [5,3]
--   True
--   </pre>
fromList :: Ord a => [a] -> Heap a

-- | Creating a list from a heap. O(N)
--   
--   <pre>
--   &gt;&gt;&gt; let xs = [5,3,5]
--   
--   &gt;&gt;&gt; length (toList (fromList xs)) == length xs
--   True
--   
--   &gt;&gt;&gt; toList empty
--   []
--   </pre>
toList :: Heap a -> [a]

-- | Deleting the minimum element.
--   
--   <pre>
--   &gt;&gt;&gt; deleteMin (fromList [5,3,7]) == fromList [5,7]
--   True
--   
--   &gt;&gt;&gt; deleteMin empty == empty
--   True
--   </pre>
deleteMin :: Heap a -> Heap a

-- | See if the heap is empty.
--   
--   <pre>
--   &gt;&gt;&gt; Data.Heap.Splay.null empty
--   True
--   
--   &gt;&gt;&gt; Data.Heap.Splay.null (singleton 1)
--   False
--   </pre>
null :: Heap a -> Bool

-- | Splitting smaller and bigger with splay. Since this is a heap
--   implementation, members is not necessarily unique.
partition :: Ord a => a -> Splay a -> (Splay a, Splay a)

-- | Merging two heaps
--   
--   <pre>
--   &gt;&gt;&gt; merge (fromList [5,3]) (fromList [5,7]) == fromList [3,5,5,7]
--   True
--   </pre>
merge :: Ord a => Heap a -> Heap a -> Heap a

-- | Finding the minimum element.
--   
--   <pre>
--   &gt;&gt;&gt; minimum (fromList [3,5,1])
--   Just 1
--   
--   &gt;&gt;&gt; minimum empty
--   Nothing
--   </pre>
minimum :: Heap a -> Maybe a

-- | Checking validity of a heap.
valid :: Ord a => Heap a -> Bool
heapSort :: Ord a => Heap a -> [a]
showHeap :: Show a => Splay a -> String
printHeap :: Show a => Splay a -> IO ()
instance Show a => Show (Splay a)
instance Show a => Show (Heap a)
instance (Eq a, Ord a) => Eq (Heap a)


-- | Leftist Heap
--   
--   <ul>
--   <li>the fun of programming</li>
--   </ul>
module Data.Heap.Leftist
data Leftist a
Leaf :: Leftist a
Node :: Rank -> (Leftist a) -> a -> (Leftist a) -> Leftist a
type Rank = Int

-- | Empty heap.
empty :: Leftist a

-- | Singleton heap.
singleton :: a -> Leftist a

-- | Insertion.
--   
--   <pre>
--   &gt;&gt;&gt; insert 7 (fromList [5,3]) == fromList [3,5,7]
--   True
--   
--   &gt;&gt;&gt; insert 5 empty            == singleton 5
--   True
--   </pre>
insert :: Ord a => a -> Leftist a -> Leftist a

-- | Creating a heap from a list.
--   
--   <pre>
--   &gt;&gt;&gt; empty == fromList []
--   True
--   
--   &gt;&gt;&gt; singleton 'a' == fromList ['a']
--   True
--   
--   &gt;&gt;&gt; fromList [5,3] == fromList [5,3]
--   True
--   </pre>
fromList :: Ord a => [a] -> Leftist a

-- | Creating a list from a heap. O(N)
--   
--   <pre>
--   &gt;&gt;&gt; let xs = [5,3,5]
--   
--   &gt;&gt;&gt; length (toList (fromList xs)) == length xs
--   True
--   
--   &gt;&gt;&gt; toList empty
--   []
--   </pre>
toList :: Leftist a -> [a]

-- | Deleting the minimum element.
--   
--   <pre>
--   &gt;&gt;&gt; deleteMin (fromList [5,3,7]) == fromList [5,7]
--   True
--   
--   &gt;&gt;&gt; deleteMin empty == empty
--   True
--   </pre>
deleteMin :: Ord a => Leftist a -> Leftist a

-- | See if the heap is empty.
--   
--   <pre>
--   &gt;&gt;&gt; Data.Heap.Leftist.null empty
--   True
--   
--   &gt;&gt;&gt; Data.Heap.Leftist.null (singleton 1)
--   False
--   </pre>
null :: Leftist t -> Bool

-- | Merging two heaps
--   
--   <pre>
--   &gt;&gt;&gt; merge (fromList [5,3]) (fromList [5,7]) == fromList [3,5,5,7]
--   True
--   </pre>
merge :: Ord a => Leftist a -> Leftist a -> Leftist a

-- | Finding the minimum element.
--   
--   <pre>
--   &gt;&gt;&gt; minimum (fromList [3,5,1])
--   Just 1
--   
--   &gt;&gt;&gt; minimum empty
--   Nothing
--   </pre>
minimum :: Leftist a -> Maybe a

-- | Checking validity of a heap.
valid :: Ord a => Leftist a -> Bool
heapSort :: Ord a => Leftist a -> [a]
instance Show a => Show (Leftist a)
instance (Eq a, Ord a) => Eq (Leftist a)


-- | Skew Heap
--   
--   <ul>
--   <li>the fun of programming</li>
--   </ul>
module Data.Heap.Skew
data Skew a
Leaf :: Skew a
Node :: (Skew a) -> a -> (Skew a) -> Skew a

-- | Empty heap.
empty :: Skew a

-- | Singleton heap.
singleton :: a -> Skew a

-- | Insertion.
--   
--   <pre>
--   &gt;&gt;&gt; insert 7 (fromList [5,3]) == fromList [3,5,7]
--   True
--   
--   &gt;&gt;&gt; insert 5 empty            == singleton 5
--   True
--   </pre>
insert :: Ord a => a -> Skew a -> Skew a

-- | Creating a heap from a list.
--   
--   <pre>
--   &gt;&gt;&gt; empty == fromList []
--   True
--   
--   &gt;&gt;&gt; singleton 'a' == fromList ['a']
--   True
--   
--   &gt;&gt;&gt; fromList [5,3] == fromList [5,3]
--   True
--   </pre>
fromList :: Ord a => [a] -> Skew a

-- | Creating a list from a heap. O(N)
--   
--   <pre>
--   &gt;&gt;&gt; let xs = [5,3,5]
--   
--   &gt;&gt;&gt; length (toList (fromList xs)) == length xs
--   True
--   
--   &gt;&gt;&gt; toList empty
--   []
--   </pre>
toList :: Skew a -> [a]

-- | Deleting the minimum element.
--   
--   <pre>
--   &gt;&gt;&gt; deleteMin (fromList [5,3,7]) == fromList [5,7]
--   True
--   
--   &gt;&gt;&gt; deleteMin empty == empty
--   True
--   </pre>
deleteMin :: Ord a => Skew a -> Skew a

-- | See if the heap is empty.
--   
--   <pre>
--   &gt;&gt;&gt; Data.Heap.Skew.null empty
--   True
--   
--   &gt;&gt;&gt; Data.Heap.Skew.null (singleton 1)
--   False
--   </pre>
null :: Skew t -> Bool

-- | Merging two heaps
--   
--   <pre>
--   &gt;&gt;&gt; merge (fromList [5,3]) (fromList [5,7]) == fromList [3,5,5,7]
--   True
--   </pre>
merge :: Ord a => Skew a -> Skew a -> Skew a

-- | Finding the minimum element.
--   
--   <pre>
--   &gt;&gt;&gt; minimum (fromList [3,5,1])
--   Just 1
--   
--   &gt;&gt;&gt; minimum empty
--   Nothing
--   </pre>
minimum :: Skew a -> Maybe a

-- | Checking validity of a heap.
valid :: Ord a => Skew a -> Bool
heapSort :: Ord a => Skew a -> [a]
instance Show a => Show (Skew a)
instance (Eq a, Ord a) => Eq (Skew a)


-- | Purely functional bottom-up splay sets.
--   
--   <ul>
--   <li>D.D. Sleator and R.E. Rarjan, "Self-Adjusting Binary Search Tree",
--   Journal of the Association for Computing Machinery, Vol 32, No 3, July
--   1985, pp 652-686.
--   <a>http://www.cs.cmu.edu/~sleator/papers/self-adjusting.pdf</a></li>
--   </ul>
module Data.Set.BUSplay
data Splay a
Leaf :: Splay a
Node :: (Splay a) -> a -> (Splay a) -> Splay a

-- | Empty set.
empty :: Splay a

-- | Singleton set.
singleton :: a -> Splay a

-- | Insertion.
--   
--   <pre>
--   &gt;&gt;&gt; insert 5 (fromList [5,3]) == fromList [3,5]
--   True
--   
--   &gt;&gt;&gt; insert 7 (fromList [5,3]) == fromList [3,5,7]
--   True
--   
--   &gt;&gt;&gt; insert 5 empty            == singleton 5
--   True
--   </pre>
insert :: Ord a => a -> Splay a -> Splay a

-- | Creating a set from a list.
--   
--   <pre>
--   &gt;&gt;&gt; empty == fromList []
--   True
--   
--   &gt;&gt;&gt; singleton 'a' == fromList ['a']
--   True
--   
--   &gt;&gt;&gt; fromList [5,3,5] == fromList [5,3]
--   True
--   </pre>
fromList :: Ord a => [a] -> Splay a

-- | Creating a list from a set. O(N)
--   
--   <pre>
--   &gt;&gt;&gt; toList (fromList [5,3])
--   [3,5]
--   
--   &gt;&gt;&gt; toList empty
--   []
--   </pre>
toList :: Splay a -> [a]

-- | Checking if this element is a member of a set?
--   
--   <pre>
--   &gt;&gt;&gt; fst $ member 5 (fromList [5,3])
--   True
--   
--   &gt;&gt;&gt; fst $ member 1 (fromList [5,3])
--   False
--   </pre>
member :: Ord a => a -> Splay a -> (Bool, Splay a)

-- | Deleting this element from a set.
--   
--   <pre>
--   &gt;&gt;&gt; delete 5 (fromList [5,3]) == singleton 3
--   True
--   
--   &gt;&gt;&gt; delete 7 (fromList [5,3]) == fromList [3,5]
--   True
--   
--   &gt;&gt;&gt; delete 5 empty            == empty
--   True
--   </pre>
delete :: Ord a => a -> Splay a -> Splay a

-- | Deleting the minimum element.
--   
--   <pre>
--   &gt;&gt;&gt; deleteMin (fromList [5,3,7]) == fromList [5,7]
--   True
--   
--   &gt;&gt;&gt; deleteMin empty
--   *** Exception: deleteMin
--   </pre>
deleteMin :: Splay a -> Splay a

-- | Deleting the maximum
--   
--   <pre>
--   &gt;&gt;&gt; deleteMax (fromList [(5,"a"), (3,"b"), (7,"c")]) == fromList [(3,"b"), (5,"a")]
--   True
--   
--   &gt;&gt;&gt; deleteMax empty
--   *** Exception: deleteMax
--   </pre>
deleteMax :: Splay a -> Splay a

-- | See if the splay set is empty.
--   
--   <pre>
--   &gt;&gt;&gt; Data.Set.BUSplay.null empty
--   True
--   
--   &gt;&gt;&gt; Data.Set.BUSplay.null (singleton 1)
--   False
--   </pre>
null :: Splay a -> Bool

-- | Creating a union set from two sets.
--   
--   <pre>
--   &gt;&gt;&gt; union (fromList [5,3]) (fromList [5,7]) == fromList [3,5,7]
--   True
--   </pre>
union :: Ord a => Splay a -> Splay a -> Splay a

-- | Creating a intersection set from sets.
--   
--   <pre>
--   &gt;&gt;&gt; intersection (fromList [5,3]) (fromList [5,7]) == singleton 5
--   True
--   </pre>
intersection :: Ord a => Splay a -> Splay a -> Splay a

-- | Creating a difference set from sets.
--   
--   <pre>
--   &gt;&gt;&gt; difference (fromList [5,3]) (fromList [5,7]) == singleton 3
--   True
--   </pre>
difference :: Ord a => Splay a -> Splay a -> Splay a

-- | Finding the minimum element.
--   
--   <pre>
--   &gt;&gt;&gt; fst $ minimum (fromList [3,5,1])
--   1
--   
--   &gt;&gt;&gt; minimum empty
--   *** Exception: minimum
--   </pre>
minimum :: Splay a -> (a, Splay a)

-- | Finding the maximum element.
--   
--   <pre>
--   &gt;&gt;&gt; fst $ maximum (fromList [3,5,1])
--   5
--   
--   &gt;&gt;&gt; maximum empty
--   *** Exception: maximum
--   </pre>
maximum :: Splay a -> (a, Splay a)

-- | Checking validity of a set.
valid :: Ord a => Splay a -> Bool

-- | Checking if two splay sets are exactly the same shape.
(===) :: Eq a => Splay a -> Splay a -> Bool
showSet :: Show a => Splay a -> String
printSet :: Show a => Splay a -> IO ()
instance Show a => Show (Splay a)
instance Show a => Show (Direction a)
instance Eq a => Eq (Splay a)


-- | Purely functional top-down splay sets.
--   
--   <ul>
--   <li>D.D. Sleator and R.E. Rarjan, "Self-Adjusting Binary Search Tree",
--   Journal of the Association for Computing Machinery, Vol 32, No 3, July
--   1985, pp 652-686.
--   <a>http://www.cs.cmu.edu/~sleator/papers/self-adjusting.pdf</a></li>
--   </ul>
module Data.Set.Splay
data Splay a
Leaf :: Splay a
Node :: (Splay a) -> a -> (Splay a) -> Splay a

-- | Empty set.
empty :: Splay a

-- | Singleton set.
singleton :: a -> Splay a

-- | Insertion.
--   
--   <pre>
--   &gt;&gt;&gt; insert 5 (fromList [5,3]) == fromList [3,5]
--   True
--   
--   &gt;&gt;&gt; insert 7 (fromList [5,3]) == fromList [3,5,7]
--   True
--   
--   &gt;&gt;&gt; insert 5 empty            == singleton 5
--   True
--   </pre>
insert :: Ord a => a -> Splay a -> Splay a

-- | Creating a set from a list.
--   
--   <pre>
--   &gt;&gt;&gt; empty == fromList []
--   True
--   
--   &gt;&gt;&gt; singleton 'a' == fromList ['a']
--   True
--   
--   &gt;&gt;&gt; fromList [5,3,5] == fromList [5,3]
--   True
--   </pre>
fromList :: Ord a => [a] -> Splay a

-- | Creating a list from a set.
--   
--   <pre>
--   &gt;&gt;&gt; toList (fromList [5,3])
--   [3,5]
--   
--   &gt;&gt;&gt; toList empty
--   []
--   </pre>
toList :: Splay a -> [a]

-- | Checking if this element is a member of a set?
--   
--   <pre>
--   &gt;&gt;&gt; fst $ member 5 (fromList [5,3])
--   True
--   
--   &gt;&gt;&gt; fst $ member 1 (fromList [5,3])
--   False
--   </pre>
member :: Ord a => a -> Splay a -> (Bool, Splay a)

-- | Deleting this element from a set.
--   
--   <pre>
--   &gt;&gt;&gt; delete 5 (fromList [5,3]) == singleton 3
--   True
--   
--   &gt;&gt;&gt; delete 7 (fromList [5,3]) == fromList [3,5]
--   True
--   
--   &gt;&gt;&gt; delete 5 empty            == empty
--   True
--   </pre>
delete :: Ord a => a -> Splay a -> Splay a

-- | Deleting the minimum element.
--   
--   <pre>
--   &gt;&gt;&gt; snd (deleteMin (fromList [5,3,7])) == fromList [5,7]
--   True
--   
--   &gt;&gt;&gt; deleteMin empty
--   *** Exception: deleteMin
--   </pre>
deleteMin :: Splay a -> (a, Splay a)

-- | Deleting the maximum
--   
--   <pre>
--   &gt;&gt;&gt; snd (deleteMax (fromList [(5,"a"), (3,"b"), (7,"c")])) == fromList [(3,"b"), (5,"a")]
--   True
--   
--   &gt;&gt;&gt; deleteMax empty
--   *** Exception: deleteMax
--   </pre>
deleteMax :: Splay a -> (a, Splay a)

-- | See if the splay set is empty.
--   
--   <pre>
--   &gt;&gt;&gt; Data.Set.Splay.null empty
--   True
--   
--   &gt;&gt;&gt; Data.Set.Splay.null (singleton 1)
--   False
--   </pre>
null :: Splay a -> Bool

-- | Creating a union set from two sets.
--   
--   <pre>
--   &gt;&gt;&gt; union (fromList [5,3]) (fromList [5,7]) == fromList [3,5,7]
--   True
--   </pre>
union :: Ord a => Splay a -> Splay a -> Splay a

-- | Creating a intersection set from sets.
--   
--   <pre>
--   &gt;&gt;&gt; intersection (fromList [5,3]) (fromList [5,7]) == singleton 5
--   True
--   </pre>
intersection :: Ord a => Splay a -> Splay a -> Splay a

-- | Creating a difference set from sets.
--   
--   <pre>
--   &gt;&gt;&gt; difference (fromList [5,3]) (fromList [5,7]) == singleton 3
--   True
--   </pre>
difference :: Ord a => Splay a -> Splay a -> Splay a

-- | Splitting smaller and bigger with splay. Since this is a set
--   implementation, members must be unique.
split :: Ord a => a -> Splay a -> (Splay a, Bool, Splay a)

-- | Finding the minimum element.
--   
--   <pre>
--   &gt;&gt;&gt; fst $ minimum (fromList [3,5,1])
--   1
--   
--   &gt;&gt;&gt; minimum empty
--   *** Exception: minimum
--   </pre>
minimum :: Splay a -> (a, Splay a)

-- | Finding the maximum element.
--   
--   <pre>
--   &gt;&gt;&gt; fst $ maximum (fromList [3,5,1])
--   5
--   
--   &gt;&gt;&gt; maximum empty
--   *** Exception: maximum
--   </pre>
maximum :: Splay a -> (a, Splay a)

-- | Checking validity of a set.
valid :: Ord a => Splay a -> Bool

-- | Checking if two splay sets are exactly the same shape.
(===) :: Eq a => Splay a -> Splay a -> Bool
showSet :: Show a => Splay a -> String
printSet :: Show a => Splay a -> IO ()
instance Show a => Show (Splay a)
instance Eq a => Eq (Splay a)


-- | Purely functional weight balanced trees, aka trees of bounded balance.
--   
--   <ul>
--   <li>J. Nievergelt and E.M. Reingold, "Binary search trees of bounded
--   balance", Proceedings of the fourth annual ACM symposium on Theory of
--   computing, pp 137-142, 1972.</li>
--   <li>S. Adams, "Implementing sets efficiently in a functional
--   language", Technical Report CSTR 92-10, University of Southampton,
--   1992. <a>http://groups.csail.mit.edu/mac/users/adams/BB/</a></li>
--   <li>S. Adam, "Efficient sets: a balancing act", Journal of Functional
--   Programming, Vol 3, Issue 4, pp 553-562.</li>
--   <li>Y. Hirai and K. Yamamoto, "Balancing Weight-Balanced Trees",
--   Journal of Functional Programming. Vol 21, Issue 03, pp 287-307.
--   <a>http://mew.org/~kazu/proj/weight-balanced-tree/</a></li>
--   <li>M. Strake, "Adams' Trees Revisited - Correct and Efficient
--   Implementation", TFP 2011.
--   <a>http://fox.ucw.cz/papers/bbtree/</a></li>
--   </ul>
module Data.Set.WBTree
data WBTree a
Leaf :: WBTree a
Node :: Size -> (WBTree a) -> a -> (WBTree a) -> WBTree a
type Size = Int
size :: WBTree a -> Size

-- | Empty set.
--   
--   <pre>
--   &gt;&gt;&gt; size empty
--   0
--   </pre>
empty :: WBTree a

-- | Singleton set.
--   
--   <pre>
--   &gt;&gt;&gt; size (singleton 'a')
--   1
--   </pre>
singleton :: a -> WBTree a

-- | Insertion. O(log N)
--   
--   <pre>
--   &gt;&gt;&gt; insert 5 (fromList [5,3]) == fromList [3,5]
--   True
--   
--   &gt;&gt;&gt; insert 7 (fromList [5,3]) == fromList [3,5,7]
--   True
--   
--   &gt;&gt;&gt; insert 5 empty            == singleton 5
--   True
--   </pre>
insert :: Ord a => a -> WBTree a -> WBTree a

-- | Creating a set from a list. O(N log N)
--   
--   <pre>
--   &gt;&gt;&gt; empty == fromList []
--   True
--   
--   &gt;&gt;&gt; singleton 'a' == fromList ['a']
--   True
--   
--   &gt;&gt;&gt; fromList [5,3,5] == fromList [5,3]
--   True
--   </pre>
fromList :: Ord a => [a] -> WBTree a

-- | Creating a list from a set. O(N)
--   
--   <pre>
--   &gt;&gt;&gt; toList (fromList [5,3])
--   [3,5]
--   
--   &gt;&gt;&gt; toList empty
--   []
--   </pre>
toList :: WBTree a -> [a]

-- | Checking if this element is a member of a set?
--   
--   <pre>
--   &gt;&gt;&gt; member 5 (fromList [5,3])
--   True
--   
--   &gt;&gt;&gt; member 1 (fromList [5,3])
--   False
--   </pre>
member :: Ord a => a -> WBTree a -> Bool

-- | Deleting this element from a set. O(log N)
--   
--   <pre>
--   &gt;&gt;&gt; delete 5 (fromList [5,3]) == singleton 3
--   True
--   
--   &gt;&gt;&gt; delete 7 (fromList [5,3]) == fromList [3,5]
--   True
--   
--   &gt;&gt;&gt; delete 5 empty            == empty
--   True
--   </pre>
delete :: Ord a => a -> WBTree a -> WBTree a

-- | Deleting the minimum element. O(log N)
--   
--   <pre>
--   &gt;&gt;&gt; deleteMin (fromList [5,3,7]) == fromList [5,7]
--   True
--   
--   &gt;&gt;&gt; deleteMin empty == empty
--   True
--   </pre>
deleteMin :: WBTree a -> WBTree a

-- | Deleting the maximum
--   
--   <pre>
--   &gt;&gt;&gt; deleteMax (fromList [(5,"a"), (3,"b"), (7,"c")]) == fromList [(3,"b"), (5,"a")]
--   True
--   
--   &gt;&gt;&gt; deleteMax empty == empty
--   True
--   </pre>
deleteMax :: WBTree a -> WBTree a

-- | See if the set is empty.
--   
--   <pre>
--   &gt;&gt;&gt; Data.Set.WBTree.null empty
--   True
--   
--   &gt;&gt;&gt; Data.Set.WBTree.null (singleton 1)
--   False
--   </pre>
null :: Eq a => WBTree a -> Bool

-- | Creating a union set from two sets. O(N + M)
--   
--   <pre>
--   &gt;&gt;&gt; union (fromList [5,3]) (fromList [5,7]) == fromList [3,5,7]
--   True
--   </pre>
union :: Ord a => WBTree a -> WBTree a -> WBTree a

-- | Creating a intersection set from sets. O(N + N)
--   
--   <pre>
--   &gt;&gt;&gt; intersection (fromList [5,3]) (fromList [5,7]) == singleton 5
--   True
--   </pre>
intersection :: Ord a => WBTree a -> WBTree a -> WBTree a

-- | Creating a difference set from sets. O(N + N)
--   
--   <pre>
--   &gt;&gt;&gt; difference (fromList [5,3]) (fromList [5,7]) == singleton 3
--   True
--   </pre>
difference :: Ord a => WBTree a -> WBTree a -> WBTree a

-- | Joining two sets with an element. O(log N)
--   
--   Each element of the left set must be less than the element. Each
--   element of the right set must be greater than the element.
join :: Ord a => WBTree a -> a -> WBTree a -> WBTree a

-- | Merging two sets. O(log N)
--   
--   Each element of the left set must be less than each element of the
--   right set.
merge :: WBTree a -> WBTree a -> WBTree a

-- | Splitting a set. O(log N)
--   
--   <pre>
--   &gt;&gt;&gt; split 2 (fromList [5,3]) == (empty, fromList [3,5])
--   True
--   
--   &gt;&gt;&gt; split 3 (fromList [5,3]) == (empty, singleton 5)
--   True
--   
--   &gt;&gt;&gt; split 4 (fromList [5,3]) == (singleton 3, singleton 5)
--   True
--   
--   &gt;&gt;&gt; split 5 (fromList [5,3]) == (singleton 3, empty)
--   True
--   
--   &gt;&gt;&gt; split 6 (fromList [5,3]) == (fromList [3,5], empty)
--   True
--   </pre>
split :: Ord a => a -> WBTree a -> (WBTree a, WBTree a)

-- | Finding the minimum element. O(log N)
--   
--   <pre>
--   &gt;&gt;&gt; minimum (fromList [3,5,1])
--   1
--   
--   &gt;&gt;&gt; minimum empty
--   *** Exception: minimum
--   </pre>
minimum :: WBTree a -> a

-- | Finding the maximum element. O(log N)
--   
--   <pre>
--   &gt;&gt;&gt; maximum (fromList [3,5,1])
--   5
--   
--   &gt;&gt;&gt; maximum empty
--   *** Exception: maximum
--   </pre>
maximum :: WBTree a -> a

-- | Checking validity of a set.
valid :: Ord a => WBTree a -> Bool
instance Show a => Show (WBTree a)
instance Eq a => Eq (WBTree a)


-- | Purely functional left-leaning red-black trees.
--   
--   <ul>
--   <li>Robert Sedgewick, "Left-Leaning Red-Black Trees", Data structures
--   seminar at Dagstuhl, Feb 2008.
--   <a>http://www.cs.princeton.edu/~rs/talks/LLRB/LLRB.pdf</a></li>
--   <li>Robert Sedgewick, "Left-Leaning Red-Black Trees", Analysis of
--   Algorithms meeting at Maresias, Apr 2008
--   <a>http://www.cs.princeton.edu/~rs/talks/LLRB/RedBlack.pdf</a></li>
--   </ul>
module Data.Set.LLRBTree
data RBTree a
Leaf :: RBTree a
Node :: Color -> !BlackHeight -> !RBTree a -> a -> !RBTree a -> RBTree a
data Color

-- | Black
B :: Color

-- | Red
R :: Color

-- | Red nodes have the same BlackHeight of their parent.
type BlackHeight = Int

-- | Empty tree.
--   
--   <pre>
--   &gt;&gt;&gt; height empty
--   0
--   </pre>
empty :: RBTree a

-- | Insertion. O(log N)
--   
--   <pre>
--   &gt;&gt;&gt; insert 5 (fromList [5,3]) == fromList [3,5]
--   True
--   
--   &gt;&gt;&gt; insert 7 (fromList [5,3]) == fromList [3,5,7]
--   True
--   
--   &gt;&gt;&gt; insert 5 empty            == singleton 5
--   True
--   </pre>
insert :: Ord a => a -> RBTree a -> RBTree a

-- | Singleton tree.
--   
--   <pre>
--   &gt;&gt;&gt; height (singleton 'a')
--   1
--   </pre>
singleton :: Ord a => a -> RBTree a

-- | Creating a tree from a list. O(N log N)
--   
--   <pre>
--   &gt;&gt;&gt; empty == fromList []
--   True
--   
--   &gt;&gt;&gt; singleton 'a' == fromList ['a']
--   True
--   
--   &gt;&gt;&gt; fromList [5,3,5] == fromList [5,3]
--   True
--   </pre>
fromList :: Ord a => [a] -> RBTree a

-- | Creating a list from a tree. O(N)
--   
--   <pre>
--   &gt;&gt;&gt; toList (fromList [5,3])
--   [3,5]
--   
--   &gt;&gt;&gt; toList empty
--   []
--   </pre>
toList :: RBTree a -> [a]

-- | Checking if this element is a member of a tree?
--   
--   <pre>
--   &gt;&gt;&gt; member 5 (fromList [5,3])
--   True
--   
--   &gt;&gt;&gt; member 1 (fromList [5,3])
--   False
--   </pre>
member :: Ord a => a -> RBTree a -> Bool

-- | Deleting this element from a tree. O(log N)
--   
--   <pre>
--   &gt;&gt;&gt; delete 5 (fromList [5,3]) == singleton 3
--   True
--   
--   &gt;&gt;&gt; delete 7 (fromList [5,3]) == fromList [3,5]
--   True
--   
--   &gt;&gt;&gt; delete 5 empty                         == empty
--   True
--   </pre>
delete :: Ord a => a -> RBTree a -> RBTree a

-- | Deleting the minimum element. O(log N)
--   
--   <pre>
--   &gt;&gt;&gt; deleteMin (fromList [5,3,7]) == fromList [5,7]
--   True
--   
--   &gt;&gt;&gt; deleteMin empty == empty
--   True
--   </pre>
deleteMin :: RBTree a -> RBTree a

-- | Deleting the maximum
--   
--   <pre>
--   &gt;&gt;&gt; deleteMax (fromList [(5,"a"), (3,"b"), (7,"c")]) == fromList [(3,"b"), (5,"a")]
--   True
--   
--   &gt;&gt;&gt; deleteMax empty == empty
--   True
--   </pre>
deleteMax :: RBTree a -> RBTree a

-- | See if the red black tree is empty.
--   
--   <pre>
--   &gt;&gt;&gt; Data.Set.LLRBTree.null empty
--   True
--   
--   &gt;&gt;&gt; Data.Set.LLRBTree.null (singleton 1)
--   False
--   </pre>
null :: Eq a => RBTree a -> Bool

-- | Creating a union tree from two trees. O(N + M)
--   
--   <pre>
--   &gt;&gt;&gt; union (fromList [5,3]) (fromList [5,7]) == fromList [3,5,7]
--   True
--   </pre>
union :: Ord a => RBTree a -> RBTree a -> RBTree a

-- | Creating a intersection tree from trees. O(N + N)
--   
--   <pre>
--   &gt;&gt;&gt; intersection (fromList [5,3]) (fromList [5,7]) == singleton 5
--   True
--   </pre>
intersection :: Ord a => RBTree a -> RBTree a -> RBTree a

-- | Creating a difference tree from trees. O(N + N)
--   
--   <pre>
--   &gt;&gt;&gt; difference (fromList [5,3]) (fromList [5,7]) == singleton 3
--   True
--   </pre>
difference :: Ord a => RBTree a -> RBTree a -> RBTree a

-- | Joining two trees with an element. O(log N)
--   
--   Each element of the left tree must be less than the element. Each
--   element of the right tree must be greater than the element. Both tree
--   must have black root.
join :: Ord a => RBTree a -> a -> RBTree a -> RBTree a

-- | Merging two trees. O(log N)
--   
--   Each element of the left tree must be less than each element of the
--   right tree. Both trees must have black root.
merge :: Ord a => RBTree a -> RBTree a -> RBTree a

-- | Splitting a tree. O(log N)
--   
--   <pre>
--   &gt;&gt;&gt; split 2 (fromList [5,3]) == (empty, fromList [3,5])
--   True
--   
--   &gt;&gt;&gt; split 3 (fromList [5,3]) == (empty, singleton 5)
--   True
--   
--   &gt;&gt;&gt; split 4 (fromList [5,3]) == (singleton 3, singleton 5)
--   True
--   
--   &gt;&gt;&gt; split 5 (fromList [5,3]) == (singleton 3, empty)
--   True
--   
--   &gt;&gt;&gt; split 6 (fromList [5,3]) == (fromList [3,5], empty)
--   True
--   </pre>
split :: Ord a => a -> RBTree a -> (RBTree a, RBTree a)

-- | Finding the minimum element. O(log N)
--   
--   <pre>
--   &gt;&gt;&gt; minimum (fromList [3,5,1])
--   1
--   
--   &gt;&gt;&gt; minimum empty
--   *** Exception: minimum
--   </pre>
minimum :: RBTree a -> a

-- | Finding the maximum element. O(log N)
--   
--   <pre>
--   &gt;&gt;&gt; maximum (fromList [3,5,1])
--   5
--   
--   &gt;&gt;&gt; maximum empty
--   *** Exception: maximum
--   </pre>
maximum :: RBTree a -> a

-- | Checking validity of a tree.
valid :: Ord a => RBTree a -> Bool
showSet :: Show a => RBTree a -> String
printSet :: Show a => RBTree a -> IO ()
instance Eq Color
instance Show Color
instance Show a => Show (RBTree a)
instance Eq a => Eq (RBTree a)


-- | Purely functional red-black trees.
--   
--   <ul>
--   <li>Chris Okasaki, "Red-Black Trees in a Functional Setting", Journal
--   of Functional Programming, 9(4), pp 471-477, July 1999
--   <a>http://www.eecs.usma.edu/webs/people/okasaki/pubs.html#jfp99</a></li>
--   <li>Stefan Kahrs, "Red-black trees with types", Journal of functional
--   programming, 11(04), pp 425-432, July 2001</li>
--   </ul>
module Data.Set.RBTree
data RBTree a
Leaf :: RBTree a
Node :: Color -> !BlackHeight -> !RBTree a -> a -> !RBTree a -> RBTree a
data Color

-- | Black
B :: Color

-- | Red
R :: Color

-- | Red nodes have the same BlackHeight of their parent.
type BlackHeight = Int

-- | Empty tree.
--   
--   <pre>
--   &gt;&gt;&gt; height empty
--   0
--   </pre>
empty :: RBTree a

-- | Singleton tree.
--   
--   <pre>
--   &gt;&gt;&gt; height (singleton 'a')
--   1
--   </pre>
singleton :: Ord a => a -> RBTree a

-- | Insertion. O(log N)
--   
--   <pre>
--   &gt;&gt;&gt; insert 5 (fromList [5,3]) == fromList [3,5]
--   True
--   
--   &gt;&gt;&gt; insert 7 (fromList [5,3]) == fromList [3,5,7]
--   True
--   
--   &gt;&gt;&gt; insert 5 empty            == singleton 5
--   True
--   </pre>
insert :: Ord a => a -> RBTree a -> RBTree a

-- | Creating a tree from a list. O(N log N)
--   
--   <pre>
--   &gt;&gt;&gt; empty == fromList []
--   True
--   
--   &gt;&gt;&gt; singleton 'a' == fromList ['a']
--   True
--   
--   &gt;&gt;&gt; fromList [5,3,5] == fromList [5,3]
--   True
--   </pre>
fromList :: Ord a => [a] -> RBTree a

-- | Creating a list from a tree. O(N)
--   
--   <pre>
--   &gt;&gt;&gt; toList (fromList [5,3])
--   [3,5]
--   
--   &gt;&gt;&gt; toList empty
--   []
--   </pre>
toList :: RBTree a -> [a]

-- | Checking if this element is a member of a tree?
--   
--   <pre>
--   &gt;&gt;&gt; member 5 (fromList [5,3])
--   True
--   
--   &gt;&gt;&gt; member 1 (fromList [5,3])
--   False
--   </pre>
member :: Ord a => a -> RBTree a -> Bool

-- | Deleting this element from a tree. O(log N)
--   
--   <pre>
--   &gt;&gt;&gt; delete 5 (fromList [5,3]) == singleton 3
--   True
--   
--   &gt;&gt;&gt; delete 7 (fromList [5,3]) == fromList [3,5]
--   True
--   
--   &gt;&gt;&gt; delete 5 empty            == empty
--   True
--   </pre>
delete :: Ord a => a -> RBTree a -> RBTree a

-- | Deleting the minimum element. O(log N)
--   
--   <pre>
--   &gt;&gt;&gt; deleteMin (fromList [5,3,7]) == fromList [5,7]
--   True
--   
--   &gt;&gt;&gt; deleteMin empty == empty
--   True
--   </pre>
deleteMin :: RBTree a -> RBTree a

-- | Deleting the maximum
--   
--   <pre>
--   &gt;&gt;&gt; deleteMax (fromList [(5,"a"), (3,"b"), (7,"c")]) == fromList [(3,"b"), (5,"a")]
--   True
--   
--   &gt;&gt;&gt; deleteMax empty == empty
--   True
--   </pre>
deleteMax :: RBTree a -> RBTree a

-- | See if the red black tree is empty.
--   
--   <pre>
--   &gt;&gt;&gt; Data.Set.RBTree.null empty
--   True
--   
--   &gt;&gt;&gt; Data.Set.RBTree.null (singleton 1)
--   False
--   </pre>
null :: Eq a => RBTree a -> Bool

-- | Creating a union tree from two trees. O(N + M)
--   
--   <pre>
--   &gt;&gt;&gt; union (fromList [5,3]) (fromList [5,7]) == fromList [3,5,7]
--   True
--   </pre>
union :: Ord a => RBTree a -> RBTree a -> RBTree a

-- | Creating a intersection tree from trees. O(N + N)
--   
--   <pre>
--   &gt;&gt;&gt; intersection (fromList [5,3]) (fromList [5,7]) == singleton 5
--   True
--   </pre>
intersection :: Ord a => RBTree a -> RBTree a -> RBTree a

-- | Creating a difference tree from trees. O(N + N)
--   
--   <pre>
--   &gt;&gt;&gt; difference (fromList [5,3]) (fromList [5,7]) == singleton 3
--   True
--   </pre>
difference :: Ord a => RBTree a -> RBTree a -> RBTree a

-- | Joining two trees with an element. O(log N)
--   
--   Each element of the left tree must be less than the element. Each
--   element of the right tree must be greater than the element. Both tree
--   must have black root.
join :: Ord a => RBTree a -> a -> RBTree a -> RBTree a

-- | Merging two trees. O(log N)
--   
--   Each element of the left tree must be less than each element of the
--   right tree. Both trees must have black root.
merge :: Ord a => RBTree a -> RBTree a -> RBTree a

-- | Splitting a tree. O(log N)
--   
--   <pre>
--   &gt;&gt;&gt; split 2 (fromList [5,3]) == (empty, fromList [3,5])
--   True
--   
--   &gt;&gt;&gt; split 3 (fromList [5,3]) == (empty, singleton 5)
--   True
--   
--   &gt;&gt;&gt; split 4 (fromList [5,3]) == (singleton 3, singleton 5)
--   True
--   
--   &gt;&gt;&gt; split 5 (fromList [5,3]) == (singleton 3, empty)
--   True
--   
--   &gt;&gt;&gt; split 6 (fromList [5,3]) == (fromList [3,5], empty)
--   True
--   </pre>
split :: Ord a => a -> RBTree a -> (RBTree a, RBTree a)

-- | Finding the minimum element. O(log N)
--   
--   <pre>
--   &gt;&gt;&gt; minimum (fromList [3,5,1])
--   1
--   
--   &gt;&gt;&gt; minimum empty
--   *** Exception: minimum
--   </pre>
minimum :: RBTree a -> a

-- | Finding the maximum element. O(log N)
--   
--   <pre>
--   &gt;&gt;&gt; maximum (fromList [3,5,1])
--   5
--   
--   &gt;&gt;&gt; maximum empty
--   *** Exception: maximum
--   </pre>
maximum :: RBTree a -> a

-- | Checking validity of a tree.
valid :: Ord a => RBTree a -> Bool
showSet :: Show a => RBTree a -> String
printSet :: Show a => RBTree a -> IO ()
instance Eq Color
instance Show Color
instance Show a => Show (RBTree a)
instance Eq a => Eq (RBTree a)
