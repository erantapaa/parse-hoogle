-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Storable type class for variable-sized data
--   
--   The module <a>Data.Storable</a> provides an extension to the
--   Foreign.Storable type class adding support for variable-sized data
--   types.
@package storable
@version 0.1


-- | The module <a>Data.Storable</a> provides an extension to the
--   Foreign.Storable type class adding support for variable-sized data
--   types.
module Data.Storable

-- | The member functions of this class facilitate writing values of
--   arbitrary (including recursive) data types to raw memory and reading
--   values from blocks of raw memory. The class, furthermore, includes
--   support for computing the storage requirements and alignment
--   restrictions of storable types.
--   
--   This class fills the gap between Foreign.Storable and Data.Binary. It
--   adds support for marshalling (finite) values of variable-sized data
--   types, like lists or trees, while preserving the performance and
--   memory efficiency one expects from the Storable class. It also
--   provides a (monadic) syntactic sugar that takes care of alignment
--   restrictions by itself and makes instance deriving easy.
--   
--   The primary aim of this class, as opposed to Foreign.Storable, is
--   storing values to raw memory for the purpose of sending them over a
--   network (in a homogeneous distributed environment, no endianness
--   translation is done) or dumping them to external storage. It was not
--   intended to be used for marshalling structures to/from C, although it
--   may be used for that -- you'll need, however, specially crafted
--   instances for compound data types that apply alignment restrictions
--   recursively, not only for elementary Storable values. These may be
--   provided someday.
--   
--   The API used for writing/reading values is provided by the
--   <a>sizeOfV</a>, <a>alignmentV</a>, <a>peekV</a> and <a>pokeV</a>
--   functions (V standing for value).
--   
--   For help on deriving instances see the source of the
--   Data.Storable.Instances module. For help on usage of the <a>Ptr</a>
--   type, which represents raw memory addresses, see the documentation of
--   Foreign Function Interface (FFI).
--   
--   Minimal complete definition: <a>sizeOfM</a>, <a>alignmentM</a>,
--   <a>peekM</a> and <a>pokeM</a>.
class StorableM a
sizeOfM :: StorableM a => a -> SizeOf ()
alignmentM :: StorableM a => a -> Alignment ()
peekM :: StorableM a => Offset a
pokeM :: StorableM a => a -> Offset ()

-- | Computes the storage requirements (in bytes) of the argument. The
--   value of the argument _is_ used.
sizeOfV :: StorableM a => a -> Int

-- | Computes the alignment constraint of the argument. An alignment
--   constraint <tt>x</tt> is fulfilled by any address divisible by
--   <tt>x</tt>. The value of the argument _is_not_ used.
alignmentV :: StorableM a => a -> Int

-- | Read a value from the given memory location.
--   
--   Note that the peekV and pokeV functions might require properly aligned
--   addresses to function correctly. This is architecture dependent; thus,
--   portable code should ensure that when peeking or poking values of some
--   type <tt>a</tt>, the alignment constraint for <tt>a</tt>, as given by
--   the function <a>alignmentV</a> is fulfilled.
peekV :: StorableM a => Ptr a -> IO a

-- | Write the given value to the given memory location. Alignment
--   restrictions might apply; see <a>peekV</a>.
pokeV :: StorableM a => Ptr a -> a -> IO ()
instance [overlap ok] Eq a => Eq (LCM a)
instance [overlap ok] Ord a => Ord (LCM a)
instance [overlap ok] Read a => Read (LCM a)
instance [overlap ok] Show a => Show (LCM a)
instance [overlap ok] Bounded a => Bounded (LCM a)
instance [overlap ok] Storable a => StorableM a
instance [overlap ok] Integral a => Monoid (LCM a)

module Data.Storable.Instances
instance StorableM a => StorableM [a]
instance (StorableM a, StorableM b) => StorableM (a, b)
