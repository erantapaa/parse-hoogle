-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Reactors for the uniform workbench
--   
--   uni reactor
@package uni-reactor
@version 2.2.1.0


-- | InfoBus implements the <a>shutdown</a> command. This destroys all the
--   things registered via <a>registerTool</a> and not subsequently
--   registered via <a>deregisterTool</a>. Tools are identified by
--   <tt>ObjectId</tt>.
module Reactor.InfoBus
registerTool :: (Object t, Destroyable t) => t -> IO ()
registerToolDebug :: (Object t, Destroyable t) => String -> t -> IO ()
deregisterTool :: Object t => t -> IO ()
shutdown :: IO ()

-- | register the given action to be done at shutdown. The returned action
--   cancels the registration (without performing the given action).
registerDestroyAct :: IO () -> IO (IO ())

-- | encapsulate an action such that shutdown waits for its termination
encapsulateWaitTermAct :: IO () -> IO ()
instance Destroyable SimpleTool
instance Object SimpleTool


-- | Lock is an instance of a typical thing we synchronize with. One
--   instance is <tt>BSem</tt>.
module Reactor.Lock
class Lock l
release :: Lock l => l -> IO ()
acquire :: Lock l => l -> IO ()
tryAcquire :: Lock l => l -> IO Bool


-- | A simple semaphore
module Reactor.BSem

-- | A simple lock.
data BSem

-- | Create a new unlocked BSem
newBSem :: IO BSem

-- | Create a new locked BSem
newLockedBSem :: IO BSem

-- | tryAcquireBSems attempts to acquire a list of BSems. If successful it
--   returns the action to release them all again. If unsuccessful it
--   returns Nothing, and leaves all the BSems released.
tryAcquireBSems :: [BSem] -> IO (Maybe (IO ()))

-- | tryAcquireBSemsWithError is a generalisation of tryAcquireBSems, which
--   produces an error message
--   
--   The first argument extracts an object's BSem; the second gets a String
--   to be used as a message if we can't get the object's lock.
tryAcquireBSemsWithError :: (object -> BSem) -> (object -> IO String) -> [object] -> IO (WithError (IO ()))

-- | tryAcquireBSemsWithError1 toBSem getMessIfError objects attempts to
--   acquire the BSems in (map toBSem objects). In the event of a (toBSem
--   object) already being acquired, it looks at the result of
--   getMessIfError object. If this is (Just mess) it returns an error
--   condition with message (mess), first releasing all BSems it has
--   already acquired; if it is (Nothing) it goes on to attempt to acquire
--   the BSems for the remaining objects. If it gets to the end of the list
--   it returns an action which can be used to release all the BSems it has
--   acquired.
tryAcquireBSemsWithError1 :: (object -> IO BSem) -> (object -> IO (Maybe String)) -> [object] -> IO (WithError (IO ()))
instance Eq BSem
instance Synchronized BSem
instance Lock BSem


-- | This is a much simpler reimplementation of Einar's old Mutex
--   semaphores. This is a lock which can be required by a thread which is
--   already holding it.
--   
--   See also <a>TSem</a>.
module Reactor.MSem
data MSem
newMSem :: IO MSem
synchronizeWithChoice :: MSem -> (Bool -> IO a) -> IO a
instance Synchronized MSem


-- | <ul>
--   <li>Reentrant, protected references: an IORef in an MVar, protected by
--   - a reentrant monitor. - - The operations which change the value
--   (setRef, changeRef, withRef) - are protected by the monitor, which
--   additionally provides a reentrant - synchronize method.</li>
--   </ul>
module Reactor.ReferenceVariables
data Ref a
newRef :: a -> IO (Ref a)
setRef :: Ref a -> a -> IO ()
changeRef :: Ref a -> (a -> a) -> IO ()
changeRefM :: Ref a -> (a -> IO a) -> IO ()
withRef :: Ref a -> (a -> b) -> IO b
getRef :: Ref a -> IO a
instance Synchronized (Ref a)


-- | A function for changing directories in a thread-safe way.
--   
--   We use an MSem to lock the current directory. This means that withDir
--   can be nested without deadlock (presumably the user knows what he's
--   doing).
module Reactor.WithDir
withDir :: FilePath -> IO a -> IO a
