-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | In-memory relational database
--   
--   Library that provides a sort of relational database in memory (which
--   could be saved to the disk, however).
@package hmemdb
@version 0.4.0.0


-- | Tables of values and keys for that tables.
--   
--   Each value in the table may be accompanied with references to other
--   tables.
--   
--   = Usage
--   
--   Each table is just an unordered collection of values.
--   
--   == Simple values
--   
--   Suppose we want to keep a collection of values of some type <a>T</a>.
--   We should use a very simple specification to create a table:
--   
--   <pre>
--   createTable (Spec Refs Keys :: Spec Refs Keys T)
--   </pre>
--   
--   Here we have to specify the type <a>T</a>, as otherwise Haskell would
--   have no way of knowing what type to use. Generally it's not really
--   needed.
--   
--   == Keys
--   
--   Of course, just keeping a collection of values is not very useful.
--   Let's say a company wants to keep a table of it's employees, looking
--   for information about them by their id numbers or names. Id number is
--   unique, while the names could probably coincide.
--   
--   <pre>
--   data Employee = Employee {empId :: Int, empName :: String}
--   cEmps &lt;- createTable $ Spec Refs (Keys :+: K (single empId) :+: K (multiple empName))
--   case cEmps of
--     Created employees (Keys :+: K idKey :+: K nameKey) -&gt; ...
--   </pre>
--   
--   Here <tt>employees</tt> would be the table of employees itself,
--   <tt>idKey</tt> would be the key that can be used to look up an
--   employee by the id, and <tt>nameKey</tt> would be the key that can be
--   used to look up an employee by the name.
--   
--   <a>select</a> function can do the looking up by id part.
--   
--   <pre>
--   ceoVar &lt;- select idKey 0
--   ceo &lt;- readVar employees ceoVar
--   </pre>
--   
--   For multiple values the function <a>select_</a> should be used
--   instead.
--   
--   <pre>
--   workersNamedDaniel &lt;- select_ nameKey "Daniel" (==)
--   mapM (\workerVar -&gt; runMaybeT $ readVar employees workerVar) workersNamedDaniel
--   </pre>
--   
--   We can also use other comparison operators, like
--   
--   <pre>
--   workersFromZ &lt;- select_ nameKey "Z" (&lt;=)
--   </pre>
--   
--   for selecting all workers whose names satisfy the inequality <tt>"Z"
--   &lt;= name</tt>.
--   
--   == References
--   
--   Tables can reference other tables, created before. For example, assume
--   that we have a set of departments and a set of employees, and each of
--   employees can be in one of the departments. We shouldn't keep that
--   information inside the <tt>Employee</tt> data type (as it is quite
--   changeable); instead we keep a reference into the <tt>departments</tt>
--   table along with the <tt>Employee</tt> value in the <tt>employees</tt>
--   table
--   
--   <pre>
--   cDepts &lt;- createTable $ ...
--   case cDepts of
--     Created departments ... -&gt;
--       do cEmps &lt;- case createTable $ Spec (Refs :&amp;: R (only departments)) (Keys ...)
--          case cEmps of
--            Created employees (Keys ...) -&gt; ...
--   </pre>
--   
--   Given the <a>TableVar</a> we can find out the references associated
--   with it:
--   
--   <pre>
--   Refs :&amp;: R deptVar &lt;- readRefs employees ceoVar
--   dept &lt;- readVar departments deptVar
--   </pre>
--   
--   References can also be used as keys, if they are unique:
--   
--   <pre>
--   createTable $ Spec (...) (Keys :+: K (single_ (\_ (Refs :&amp;: deptVar) -&gt; deptVar)))
--   </pre>
--   
--   == Circular references
--   
--   It's possible to have tables referencing each other, but that requires
--   some finesse. Suppose that each department has a manager. Again, we
--   don't keep that information in the <tt>Department</tt> data type
--   itself, but we want to keep a reference along the value in the table.
--   
--   First of all, we need to create a data type that keeps both tables
--   inside.
--   
--   <pre>
--   data Company where
--     Company
--       :: Table (Refs :&amp;: Ref d Department Single) e Employee -&gt;
--          Table (Refs :&amp;: Ref e Employee Single) d Department -&gt;
--          Company
--   </pre>
--   
--   Then we make specifications from table tokens (tables aren't created
--   yet):
--   
--   <pre>
--   makeSpecs (Tokens :*: tE :*: tD) =
--     Specs :&amp;&amp;: Spec (Refs :&amp;: R (only tD)) Keys :&amp;&amp;: Spec (Refs :&amp;: R (only tE)) Keys
--   </pre>
--   
--   and make the final result (the <tt>Company</tt> type) from the tables:
--   
--   <pre>
--   generate (Tables :*: T employees Keys :*: T departments Keys) =
--     return $ Company employees departments
--   </pre>
--   
--   All that should be launched by the <a>createTables</a> function:
--   
--   <pre>
--   company &lt;- createTables $ C $ C $ Exists makeSpecs generate
--   case company of
--     Company employees departments -&gt; ...
--   </pre>
--   
--   Here we should use two <a>C</a> constructors to indicate that we are
--   creating two tables.
module Data.HMemDb

-- | <a>STM</a> that can fail. Note that it doesn't revert the transaction
--   on failure.
type MS = MaybeT STM

-- | Closed class. It's instances allow us to choose whether we want to get
--   a single value or multiple ones.
class Binary u => Multitude u

-- | This type specifies that we want a single value.
data Single

-- | This type specifies that we want multiple values.
data Multiple

-- | Abstract type, which represents a collection of values of type
--   <tt>a</tt>, possibly accompanied with some references to other
--   <a>Table</a>s. The type <tt>t</tt> is an abstract type, used to ensure
--   that we don't confuse different tables with values of the same type.
--   <tt>r</tt> is a type of references accompanying each value.
data Table r t a

-- | Abstract type, which allows us to <a>select</a> one or many values
--   from the <a>Table</a>. Type <tt>t</tt> is an abstract type, same as in
--   the <a>Table</a>. Type <tt>a</tt> is a type of values, also same as in
--   the <a>Table</a>. Type <tt>i</tt> is a type of index values, used by
--   this key. Type <tt>u</tt> is either <a>Multiple</a> or <a>Single</a>,
--   depending on whether this key allows different values to have the same
--   index, or not.
data Key t a i u

-- | Base type for <a>TableVar</a> and <a>TableVars</a> Type <tt>t</tt> is
--   an abstract type, same as in the <a>Table</a>. Type <tt>a</tt> is a
--   type of value, which can be obtained with <tt>unVar</tt>, also same as
--   in the <a>Table</a>.
data TableVarU t a u

-- | Reference to a single value in some table.
type TableVar t a = TableVarU t a Single

-- | Reference to multiple values in a single table.
type TableVars t a = TableVarU t a Multiple

-- | Function that converts a list of single-value references to a single
--   multiple-value reference. Normally it should only be used in
--   <tt>cInsert</tt> statments.
fromList :: [TableVar t a] -> TableVars t a

-- | Function that converts a multiple-value reference to a list of
--   single-value references. Should be used with multiple-value references
--   accompanying values in the <a>Table</a>.
toList :: TableVars t a -> [TableVar t a]

-- | Function that dereferences a value from table. Note that we have to
--   provide the <a>Table</a> along with <a>TableVar</a>.
readVar :: Table r t a -> TableVar t a -> MS a

-- | Function that reads all references accompanying the value.
readRefs :: Table r t a -> TableVar t a -> MS (r TableVarU)

-- | Type of table specifications.
data Spec r k a
Spec :: r TableRef -> k (KeySpec r a) -> Spec r k a

-- | Other tables that should be referenced by values of this one.
sRefs :: Spec r k a -> r TableRef

-- | Keys for the table-to-be
sKeys :: Spec r k a -> k (KeySpec r a)

-- | Type that is a template for references to another table. Used only in
--   <a>Spec</a>s. Type <tt>t</tt> is an abstract type, same as in the
--   <a>Table</a>. Type <tt>a</tt> is a type of values in that
--   <a>Table</a>. Type <tt>u</tt> is either <a>Single</a> or
--   <a>Multiple</a>, depending on whether the reference, accompanying the
--   value, should be single-value or multiple-value
data TableRef t a u

-- | Class of things you can reference. Normally that would be only tables,
--   but you can use tokens as substitutes.
class ToRefBase tbl => ToRef tbl where only = const TableRef some = const TableRef
only :: ToRef tbl => tbl t a -> TableRef t a Single
some :: ToRef tbl => tbl t a -> TableRef t a Multiple

-- | Class of table reference specifications, used in the <a>sRefs</a>
--   field of the <a>Spec</a>.
class RefsC r

-- | Empty reference specification. It doesn't specify any reference
--   whatsoever.
data Refs (f :: * -> * -> * -> *)
Refs :: Refs

-- | Class of the part of reference specification, corresponding to one
--   reference.
class RefsComponent r

-- | One table reference specification. Note that it can't be used in the
--   <a>sRefs</a> field by itself, but rather should be combined with
--   <a>Refs</a> with the <a>:&amp;:</a> operator.
newtype Ref t a u f
R :: (f t a u) -> Ref t a u f

-- | Combining operator for reference specifications.
data (:&:) rs r (f :: * -> * -> * -> *)
(:&:) :: rs f -> r f -> :&: rs r

-- | Splitting references.
splitRef :: (rs :&: Ref t a u) f -> (rs f, f t a u)

-- | Type that is a template for the key. Used only in <a>Spec</a>s. Type
--   <tt>t</tt> is an abstract type, same as in the <a>Table</a>. Type
--   <tt>a</tt> is a type of values in that <a>Table</a>. Type <tt>i</tt>
--   is a type of index values, used by this key. Type <tt>u</tt> is either
--   <a>Multiple</a> or <a>Single</a>, depending on whether this key allows
--   different values to have the same index, or not.
data KeySpec r a i u

-- | This key will provide access to a single value within a <a>Table</a>.
--   It's index will be calculated, based on this value alone.
single :: (a -> i) -> KeySpec r a i Single

-- | This key will provide access to multiple values in the same
--   <a>Table</a>. Their indices will be calculated based on the value
--   alone.
multiple :: (a -> i) -> KeySpec r a i Multiple

-- | This is a more generic version of <a>single</a>. The difference is
--   that value index will be calculated based on both the value and it's
--   accompanying references.
single_ :: (a -> r TableVarU -> i) -> KeySpec r a i Single

-- | This is a more generic version of <a>multiple</a>. The difference is
--   that value index will be calculated based on both the value and it's
--   accompanying references.
multiple_ :: (a -> r TableVarU -> i) -> KeySpec r a i Multiple

-- | Class of key specifications, used in the <a>sKeys</a> field of the
--   <a>Spec</a>.
class KeysC k

-- | Empty key specification. It doesn't specify any key whatsoever.
data Keys (f :: * -> * -> *)
Keys :: Keys

-- | Class of the part of key specification, corresponding to one key.
class KeysComponent k

-- | One key specification. Note that it can't be used in the <a>sKeys</a>
--   field by itself, but rather should be combined with <a>Keys</a> with
--   the <a>:+:</a> operator.
newtype KeyRef i u f
K :: (f i u) -> KeyRef i u f

-- | Combining operator for key specifications.
data (:+:) ks k (f :: * -> * -> *)
(:+:) :: ks f -> k f -> :+: ks k

-- | Splitting keys.
splitKey :: (ks :+: KeyRef i u) f -> (ks f, f i u)

-- | Output of the <a>createTable</a> function. Contains the created table
--   and the keys to it.
data Created r k a
Created :: Table r t a -> k (Key t a) -> Created r k a

-- | Function that creates the table (along with keys and everything) based
--   on a <a>Spec</a>.
createTable :: (KeysC k, RefsC r) => Spec r k a -> STM (Created r k a)

-- | Function that selects one value from a <a>Key</a>. Note that the value
--   is not returned directly. Instead, a reference to it is returned,
--   which allows to get other references, accompanying that value in the
--   <a>Table</a>.
select :: Ord i => Key t a i Single -> i -> MS (TableVar t a)

-- | A more generic version of <a>select</a>. Instead of one value, it
--   returns multiple ones. It can also select values with indices that are
--   smaller or greater to the provided one, depending on the third
--   argument, which could be anything like <tt>(&gt;)</tt>,
--   <tt>(&lt;=)</tt>, <tt>(/=)</tt>, or even <tt>return True</tt>.
--   
--   <pre>
--   select_ k i (==) ~~ [select k i]
--   </pre>
select_ :: (Multitude u, Ord i) => Key t a i u -> i -> (forall o. Ord o => o -> o -> Bool) -> STM [TableVar t a]

-- | A variant of <a>select_</a>, which allows to choose two bounds for the
--   index. Additional boolean arguments show whether to include bounds
--   themselves or not.
selectBetween :: (Multitude u, Ord i) => Key t a i u -> i -> Bool -> i -> Bool -> STM [TableVar t a]

-- | An invalid reference to any table. Dereferencing it always fails.
nullVar :: TableVar t a

-- | Function that lets one to insert a new value to the <a>Table</a>. Of
--   course, we have to provide accompanying references as well. This
--   function can fail if some key clashes with an already existing one.
insert :: Table r t a -> a -> r TableVarU -> MS (TableVar t a)

-- | Function that writes another value to the referenced place in the
--   <a>Table</a>. It doesn't change the accompanying references. In case
--   that it fails due to some single-value key prohibiting the new value,
--   nothing is changed, and the <a>Table</a> remains the same.
update :: Table r t a -> TableVar t a -> a -> MS ()

-- | More generic version of <a>update</a>. It allows changing accompanying
--   references as well as the value.
update_ :: Table r t a -> TableVar t a -> a -> r TableVarU -> MS ()

-- | Function that removes the value (along with accompanying references)
--   from the <a>Table</a>. It only fails if the value was already removed.
delete :: Table r t a -> TableVar t a -> MS ()

-- | Function that makes it possible to read the table from the file or
--   other source. Table should be created beforehand, as specifications
--   are not serializable.
getTable :: Binary a => Table t r a -> Get (STM ())

-- | More generic version of <a>getTable</a> that allows to change the way
--   values are serialized.
getTable_ :: Get a -> Table t r a -> Get (STM ())

-- | The most generic version of <a>getTable</a>. Not only it allows to
--   change the way values are serialized, it also permits side-effects
--   during the deserialization. The table is still filled in one
--   <a>STM</a> transaction, thus avoiding any difficulties with
--   multithreading.
getTable__ :: (Monad m, MonadSTM m) => Get (m a) -> Table t r a -> Get (m ())

-- | Function that makes it possible to write the table to the file or
--   other storage.
putTable :: Binary a => Table t r a -> STM Put

-- | More generic version of <a>putTable</a> that allows to change the way
--   values are serialized.
putTable_ :: (a -> Put) -> Table t r a -> STM Put

-- | The most generic version of <a>putTable</a>. Not only it allows to
--   change the way values are serialized, it also permits side-effects
--   during the serialization. The table is still read in one <a>STM</a>
--   transaction, thus avoiding any difficulties with multithreading.
putTable__ :: (Monad m, MonadSTM m) => (a -> m Put) -> Table t r a -> m Put

-- | Type that can be used as a substitute for <a>Table</a> in <a>only</a>
--   and <a>some</a> functions.
data Token t a
Token :: Token t a

-- | Empty tokens set.
data Tokens
Tokens :: Tokens

-- | Combining operator for tokens or tables sets.
data (:*:) tps tp
(:*:) :: tps -> tp -> :*: tps tp

-- | Class of token sets, used primarily in the argument of
--   <a>createTables</a> function.
class TokensC toks

-- | Class of <a>Token</a>s
class IsToken t

-- | Set of specs, of the same size as given sets of tokens and tables.
data Specs toks tbls
Specs :: Specs Tokens Tables
(:&&:) :: Specs toks tbls -> Spec r k a -> Specs (toks :*: Token t a) (tbls :*: TableData r k t a)

-- | Empty tables set.
data Tables
Tables :: Tables

-- | Class of tables sets, used primarily in the argument of
--   <a>createTables</a> function.
class TablesC tbls

-- | Table, paired with keys to it
data TableData r k t a
T :: (Table r t a) -> (k (Key t a)) -> TableData r k t a

-- | Class of all <a>TableData</a>s
class IsTableData tbl

-- | Class of the data used to generate <a>Spec</a>s for tables that need
--   to reference each other.
class CreateTables crts

-- | Data type that hides references and keys specifications inside.
data Exists toks z
Exists :: (toks -> Specs toks tbls) -> (tbls -> STM z) -> Exists toks z

-- | Data type that quantifies universally over the table types. It should
--   be applied as many times as there are tables being created.
newtype (:**:) crts a toks z
C :: (forall t. crts (toks :*: Token t a) z) -> :**: crts a toks z

-- | Function that actually creates multiple tables, possibly referencing
--   each other, at once.
createTables :: CreateTables crts => crts Tokens z -> STM z
instance Eq Single
instance Ord Single
instance Eq Multiple
instance Eq u => Eq (TableVarU t a u)
instance Ord u => Ord (TableVarU t a u)
instance CreateTables crts => CreateTables (crts :**: a)
instance CreateTables Exists
instance (IsTableData tbl, TablesC tbls) => TablesC (tbls :*: tbl)
instance TablesC Tables
instance IsTableData (TableData r k t a)
instance (IsToken t, TokensC toks) => TokensC (toks :*: t)
instance TokensC Tokens
instance IsToken (Token t a)
instance ToRef Token
instance ToRef (Table r)
instance ToRefBase Token
instance ToRefBase (Table r)
instance Multitude u => RefsComponent (Ref t a u)
instance (RefsC rs, RefsComponent r) => RefsC (rs :&: r)
instance RefsC Refs
instance (Multitude u, Ord i) => KeysComponent (KeyRef i u)
instance (KeysC ks, KeysComponent k) => KeysC (ks :+: k)
instance KeysC Keys
instance Multitude Multiple
instance Binary Multiple
instance Multitude Single
instance Binary Single
