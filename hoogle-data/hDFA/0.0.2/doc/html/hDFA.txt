-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A simple library for representing and minimising DFAs.
--   
--   hDFA provides a simple API for representing and minimizing
--   deterministic finite automata (DFAs) using an explicit representation
--   (a list of transitions). It includes a port of Antti Valmari's
--   efficient DFA minimization algorithm from C++ to C. (See A. Valmari,
--   <a>Fast brief practical DFA minimization</a> Information Processing
--   Letters 112(6) 2012.)
@package hDFA
@version 0.0.2


-- | Representation of DFAs and some simple algorithms on them.
module Data.DFA

-- | The type of DFAs is abstract: it is a pointer to a C <tt>struct</tt>.
data DFA

-- | Labels are represented using C <tt>unsigned int</tt>s.
type Label = CUInt

-- | States are represented using C <tt>unsigned int</tt>s.
type State = CUInt

-- | Create a new <tt>DFA</tt>.
initialize :: Bool -> State -> IO DFA

-- | Garbage collect a <tt>DFA</tt>.
finished :: DFA -> IO ()

-- | Add a transition from the given <tt>State</tt> on the given
--   <tt>Label</tt> to the given <tt>State</tt> to <tt>DFA</tt>.
addTransition :: DFA -> (State, Label, State) -> IO ()

-- | Set the final bit associated with <tt>State</tt>.
--   
--   The minimization algorithm will distinguish states with different bits
--   (that are otherwise bisimilar).
setFinal :: DFA -> State -> IO ()

-- | Reduce the <tt>DFA</tt> using Antti Valmari's algorithm. The result
--   should be the same as for the standard algorithm due to Hopcroft.
minimize :: DFA -> Bool -> IO ()

-- | Traverse the transitions of <tt>DFA</tt> by invoking the given
--   function on each of them.
--   
--   DFAs aren't functorial (they're monomorphic), so we cannot use
--   <tt>Traversable</tt>.
foldTransitions :: DFA -> ((State, Label, State, Bool) -> b -> IO b) -> b -> IO b

-- | Get the initial state.
getInitialState :: DFA -> IO State

-- | Returns the number of states that are actually present in
--   <tt>DFA</tt>.
numStates :: DFA -> IO CUInt

-- | Returns the number of symbols that are actually present in
--   <tt>DFA</tt>.
numSymbols :: DFA -> IO CUInt

-- | Is the state <tt>s</tt> final?
isFinal :: DFA -> State -> IO Bool

-- | Is the debugging flag set?
debugging :: DFA -> IO Bool

-- | Load a <tt>DFA</tt> from a file in a standard format. (See the
--   accompanying examples and <tt>dfa.c</tt> for details.)
loadFromFile :: FilePath -> IO DFA

-- | Dump a <tt>DFA</tt> to a file in a standard format. (See the
--   accompanying examples and <tt>dfa.c</tt> for details.)
dumpToFile :: DFA -> FilePath -> IO ()


-- | graphviz DOT format operations.
--   
--   Support here is rudimentary. It is probably better to build it on top
--   of one of the existing libraries on Hackage.
module Data.DFA.DOT

-- | Write <tt>DFA</tt> to a file with the given <tt>FilePath</tt> in
--   graphviz DOT format, using the given labelling function.
writeToFile :: DFA -> FilePath -> (Label -> String) -> IO ()


-- | Berkeley KISS2 format operations.
--   
--   We use this to interface with STAMINA.
module Data.DFA.KISS2

-- | Read a <tt>DFA</tt> from Berkeley KISS2 format.
--   
--   A very sloppy and incomplete parser. Assumes there is a single output.
read :: Bool -> String -> IO DFA

-- | Write <tt>DFA</tt> to a file with the given <tt>FilePath</tt> in
--   Berkeley KISS2 format.
writeToFile :: DFA -> FilePath -> IO ()


-- | An interface to the Berkeley/Colorado STAMINA tool.
--   
--   STAMINA minimizes the number of states in an under-specified finite
--   state automata. This problem is NP-complete in general (unlike the
--   problem solved by Hopcroft's algorithm and its modern descendants.).
--   
--   It is part of Berkeley's SIS distribution:
--   <a>http://embedded.eecs.berkeley.edu/pubs/downloads/sis/index.htm</a>
module Data.DFA.STAMINA

-- | Minimize an automaton using STAMINA.
--   
--   The first argument is the path to STAMINA.
--   
--   FIXME This creates a new DFA (it really shouldn't). It inherits the
--   debugging setting from the argument <tt>DFA</tt>.
minimize :: FilePath -> DFA -> IO DFA
