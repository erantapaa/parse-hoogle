-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An IDE backend library
--   
@package ide-backend
@version 0.9.0.11


-- | This module provides an interface to the IDE backend. It centres
--   around the idea of a single threaded IDE session, and operations for
--   updating the session or running queries given the current state of the
--   session.
--   
--   <i>Interaction with the compiler</i>
--   
--   Ironically for a pure functional language, the interface to the
--   compiler is rather stateful and sequential. In part this is because
--   it's dealing with the state of files in the file system which are of
--   course mutable variables.
--   
--   So the general pattern of interaction is sequential and
--   single-threaded. The state transitions are fairly simple:
--   
--   <ul>
--   <li>update phase: we have a batch of updates, e.g. changes in module
--   contents. This part is declarative, we just describe what changes we
--   want to make.</li>
--   <li>compile phase: we apply the updates and invoke the compiler, which
--   incrementally recompiles some modules. This may be a relatively long
--   running operation and we may want progress info.</li>
--   <li>query phase: after compiling we can collect information like
--   source errors, the list of successfully loaded modules or symbol
--   maps.</li>
--   <li>run phase: regardless of compilation results, we may want to run
--   some code from a module (compiled recently or compiled many updates
--   ago), interact with the running code's input and output, interrupt its
--   execution.</li>
--   </ul>
--   
--   Then the whole process can repeat.
--   
--   To clarify these different phases we use different types:
--   
--   <ul>
--   <li><a>IdeSession</a> for the query mode. This is in a sense also the
--   default mode.</li>
--   <li><a>IdeSessionUpdate</a> for accumulating updates.</li>
--   <li><a>Progress</a> for the progress information in the compile
--   mode.</li>
--   <li><a>RunActions</a> for handles on the running code, through which
--   one can interact with the code.</li>
--   </ul>
--   
--   <i>Additional notes</i>
--   
--   <ul>
--   <li>Responsibility for managing and mutating files in the sources
--   dir.</li>
--   </ul>
--   
--   In general, updating and changing source files in the sources dir has
--   to be coordinated with the IdeSession, since we're in a concurrent
--   mutable setting.
--   
--   The model here is that the IdeSession alone manages the files in the
--   sources directory. All file changes and file reading must be managed
--   via the session, and sequenced relative to other session state
--   changes.
--   
--   The session will manage the files carefully, including in the case of
--   exceptions and things going awry. Thus the caller does not need to
--   duplicate the file state: it can rely on putting files in, applying
--   updates to the files via the session, and extracting the files again
--   at any time (before the session is closed).
--   
--   <ul>
--   <li>Morally pure queries</li>
--   </ul>
--   
--   Morally, a compiler is a pure function from the current value of the
--   various source files (and other bits of the environment) to object
--   code and/or other information about the modules (errors, types etc).
--   
--   The intention is to reflect this purity property in this interface.
--   The value of an <a>IdeSession</a> represents the state of the
--   files/modules and contains the other parameters supplied by the user
--   (compiler options, environment variables). It also contains or
--   represents the result of the pure compilation function. It should
--   always be the case that we can throw away all the compilation results
--   and recover them just from the file state and user parameters.
--   
--   One example where this notion makes a difference is with warnings.
--   Traditionally, compilers just return the warnings for the modules they
--   compiled, skipping warnings for the modules they didn't need to
--   recompile. But this doesn't match the pure function idea, because the
--   compilation result now depends on which steps we took to get there,
--   rather than just on the current value of the files. So one of the
--   things this wrapper can do is to restore the purity in these corner
--   cases (which otherwise the client of this API would probably have to
--   do).
--   
--   <ul>
--   <li>Persistent and transitory state</li>
--   </ul>
--   
--   The persistent state is obviously the files: source files and data
--   files, as well as user-supplied parameters of the compilation.
--   Internally there is a great deal of transitory and cached state,
--   either in memory or on disk (such as .hi files on disk or the
--   equivalent in memory). Note that none of the state persists in case of
--   a fatal internal error (the files are wiped out before shutdown) and
--   only the files persist in case of a power failure (but have to be
--   recovered manually).
--   
--   It should be possible to drop all the transitory state and recover,
--   just at the cost of some extra work, as long as the original
--   <tt>Session</tt> value is available. The <a>restartSession</a>
--   function does almost exactly that.
--   
--   This property is a useful correctness property for internal testing:
--   the results of all the queries should be the same before and after
--   blowing away all the transitory state and recovering.
module IdeSession

-- | Configuration parameters for a session. These remain the same
--   throughout the whole session's lifetime.
data SessionConfig
SessionConfig :: FilePath -> [FilePath] -> InProcess -> Bool -> PackageDBStack -> [String] -> [(String, (Maybe License, Maybe FilePath, Maybe String))] -> (String -> IO ()) -> Bool -> SessionConfig

-- | The directory to use for all session files.
configDir :: SessionConfig -> FilePath

-- | Extra directories in which to look for programs, including ghc and
--   other tools. Note that the <tt>$PATH</tt> is still searched
--   <i>first</i>, these directories are extra.
configExtraPathDirs :: SessionConfig -> [FilePath]

-- | Should the GHC client run in-process? NOTE: This is currently broken.
--   Set to False.
configInProcess :: SessionConfig -> InProcess

-- | Whether to generate module type/autocompletion info.
configGenerateModInfo :: SessionConfig -> Bool

-- | Package DBs to consult
configPackageDBStack :: SessionConfig -> PackageDBStack

-- | Packages that don't need the .cabal files provided for license
--   concatenation (e.g., because they are covered by the core license
--   set).
configLicenseExc :: SessionConfig -> [String]

-- | Hard-coded package licence information, e.g., for the packages that
--   always stay installed in-place in the GHC tree, so it's troublesome to
--   automatically retrieve their .cabal files.
configLicenseFixed :: SessionConfig -> [(String, (Maybe License, Maybe FilePath, Maybe String))]

-- | Function to be used for logging. Messages logged in this manner may be
--   provided to users in a special debugging UI.
configLog :: SessionConfig -> String -> IO ()

-- | Delete temporary files when session finishes? (Defaults to True;
--   mostly for internal debugging purposes)
configDeleteTempFiles :: SessionConfig -> Bool

-- | Default session configuration
--   
--   Use this instead of creating your own SessionConfig to be robust
--   against extensions of SessionConfig.
--   
--   <pre>
--   defaultSessionConfig = SessionConfig {
--       configDir              = "."
--     , configExtraPathDirs    = []
--     , configInProcess        = False
--     , configGenerateModInfo  = True
--     , configPackageDBStack   = [GlobalPackageDB, UserPackageDB]
--       -- ghc-prim, integer-gmp, etc., all have their own licenses specified
--       -- in their .cabal files.
--     , configLicenseExc       = ["rts"]
--     , configLicenseFixed     = [
--           ("bin-package-db", (Just BSD3, Nothing,           Nothing))
--         , ("ghc",            (Just BSD3, Just "../LICENSE", Just "The GHC Team"))
--         , ("ghc-prim",       (Just BSD3, Just "LICENSE",    Nothing))
--         , ("integer-gmp",    (Just BSD3, Just "LICENSE",    Nothing))
--         ]
--     , configLog              = const $ return ()
--     , configDeleteTempFiles  = True
--     }
--   </pre>
defaultSessionConfig :: SessionConfig
type InProcess = Bool

-- | This type is a handle to a session state. Values of this type point to
--   the non-persistent parts of the session state in memory and to
--   directories containing source and data file that form the persistent
--   part of the session state. Whenever we perform updates or run queries,
--   it's always in the context of a particular handle, representing the
--   session we want to work within. Many sessions can be active at once,
--   but in normal applications this shouldn't be needed.
data IdeSession

-- | Create a fresh session, using some initial configuration.
--   
--   Throws an exception if the configuration is invalid, or if
--   GHC_PACKAGE_PATH is set.
initSession :: SessionInitParams -> SessionConfig -> IO IdeSession

-- | How should the session be initialized?
--   
--   Client code should use <a>defaultSessionInitParams</a> to protect
--   itself against future extensions of this record.
data SessionInitParams
SessionInitParams :: Maybe ByteString -> [String] -> [FilePath] -> Targets -> [String] -> SessionInitParams

-- | Previously computed cabal macros, or <a>Nothing</a> to compute them on
--   startup
sessionInitCabalMacros :: SessionInitParams -> Maybe ByteString

-- | Initial ghc options
sessionInitGhcOptions :: SessionInitParams -> [String]

-- | Include paths (equivalent of GHC's <tt>-i</tt> parameter) relative to
--   the temporary directory where we store the session's source files.
--   
--   By default this is the singleton list <tt>[""]</tt> -- i.e., we
--   include the sources dir but nothing else.
sessionInitRelativeIncludes :: SessionInitParams -> [FilePath]

-- | Targets for compilation
--   
--   Defaults to <tt>TargetsExclude []</tt> -- i.e., compile all modules in
--   the project.
sessionInitTargets :: SessionInitParams -> Targets

-- | RTS options
--   
--   Defaults to <tt>-K8M</tt>
sessionInitRtsOpts :: SessionInitParams -> [String]
defaultSessionInitParams :: SessionInitParams

-- | Close a session down, releasing the resources.
--   
--   This operation is the only one that can be run after a shutdown was
--   already performed. This lets the API user execute an early shutdown,
--   e.g., before the <tt>shutdownSession</tt> placed inside
--   <tt>bracket</tt> is triggered by a normal program control flow.
--   
--   If code is still running, it will be interrupted.
shutdownSession :: IdeSession -> IO ()

-- | Like shutdownSession, but don't be nice about it (SIGKILL)
forceShutdownSession :: IdeSession -> IO ()

-- | Restart a session
--   
--   This puts the session in a "dead" state; it won't _actually_ be
--   restarted until the next call to <a>updateSession</a>.
restartSession :: IdeSession -> IO ()

-- | Declarative description of session updates
--   
--   IdeSessionUpdate forms a monoid, which is right-biased: "later" calls
--   override "earlier" ones:
--   
--   <pre>
--   updateTargets targets1 &lt;&gt; updateTargets2
--   </pre>
--   
--   is equivalent to
--   
--   <pre>
--   updateTargets2
--   </pre>
--   
--   However, updates of a different nature are not necessarily executed in
--   order; for instance,
--   
--   <pre>
--   updateDynamicOpts opts &lt;&gt; updateSourceFile fp bs
--   </pre>
--   
--   is equivalent to
--   
--   <pre>
--   updateSourceFile fp bs &lt;&gt; updateDynamicOpts opts
--   </pre>
--   
--   In both cases options are set before new source files are compiled.
--   
--   File commands are updated in order, so that
--   
--   <pre>
--   updateSourceFile fp bs &lt;&gt; updateSourceFile fp bs'
--   </pre>
--   
--   is equivalent to
--   
--   <pre>
--   updateSourceFile fp bs'
--   </pre>
--   
--   which is consistent with "later updates override earlier ones".
data IdeSessionUpdate

-- | Given the current IDE session state, go ahead and update the session,
--   eventually resulting in a new session state, with fully updated
--   computed information (typing, etc.).
--   
--   The update can be a long running operation, so we support a callback
--   which can be used to monitor progress of the operation.
updateSession :: IdeSession -> IdeSessionUpdate -> (Progress -> IO ()) -> IO ()

-- | A session update that changes a source file by providing some
--   contents. This can be used to add a new module or update an existing
--   one. The <tt>FilePath</tt> argument determines the directory and file
--   where the module is located within the project. In case of Haskell
--   source files, the actual internal compiler module name, such as the
--   one given by the <tt>getLoadedModules</tt> query, comes from within
--   <tt>module ... end</tt>. Usually the two names are equal, but they
--   needn't be.
updateSourceFile :: FilePath -> ByteString -> IdeSessionUpdate

-- | Like <a>updateSourceFile</a> except that instead of passing the source
--   by value, it's given by reference to an existing file, which will be
--   copied.
updateSourceFileFromFile :: FilePath -> IdeSessionUpdate

-- | A session update that deletes an existing source file.
updateSourceFileDelete :: FilePath -> IdeSessionUpdate

-- | Set ghc options
--   
--   This function is stateless: the set of actions options is the set
--   provided by the last call to updateGhcOptions.
updateGhcOpts :: [String] -> IdeSessionUpdate

-- | Set RTS options for the ghc session (this does not affect executables)
--   
--   This will cause a session restart.
--   
--   NOTE: Limiting stack size does not seem to work for ghc 7.4
--   (https:/<i>github.com</i>fpco<i>ide-backend</i>issues/258).
updateRtsOpts :: [String] -> IdeSessionUpdate

-- | Set include paths (equivalent of GHC's <tt>-i</tt> parameter). In
--   general, this requires session restart, because GHC doesn't revise
--   module dependencies when targets or include paths change, but only
--   when files change.
--   
--   This function is stateless: semantically, the set of currently active
--   include paths are those set in the last call to
--   updateRelativeIncludes. Any paths set earlier (including those from
--   <tt>configRelativeIncludes</tt>) are wiped out and overwritten in each
--   call to updateRelativeIncludes.
updateRelativeIncludes :: [FilePath] -> IdeSessionUpdate

-- | Enable or disable code generation in addition to type-checking.
--   Required by <tt>runStmt</tt>.
updateCodeGeneration :: Bool -> IdeSessionUpdate

-- | A session update that changes a data file by giving a new value for
--   the file. This can be used to add a new file or update an existing
--   one.
updateDataFile :: FilePath -> ByteString -> IdeSessionUpdate

-- | Like <a>updateDataFile</a> except that instead of passing the file
--   content by value, it's given by reference to an existing file (the
--   second argument), which will be copied.
updateDataFileFromFile :: FilePath -> FilePath -> IdeSessionUpdate

-- | Deletes an existing data file.
updateDataFileDelete :: FilePath -> IdeSessionUpdate

-- | Delete all files currently managed in this session
updateDeleteManagedFiles :: IdeSessionUpdate

-- | Set environment variables
--   
--   Use <tt>updateEnv [(var, Nothing)]</tt> to unset <tt>var</tt>.
--   
--   Note that this is intended to be stateless:
--   
--   <pre>
--   updateEnv []
--   </pre>
--   
--   will reset the environment to the server's original environment.
updateEnv :: [(String, Maybe String)] -> IdeSessionUpdate

-- | Set command line arguments for snippets (i.e., the expected value of
--   <tt>getArgs</tt>)
updateArgs :: [String] -> IdeSessionUpdate

-- | Set buffering mode for snippets' stdout
updateStdoutBufferMode :: RunBufferMode -> IdeSessionUpdate

-- | Set buffering mode for snippets' stderr
updateStderrBufferMode :: RunBufferMode -> IdeSessionUpdate

-- | Set compilation targets. In general, this requires session restart,
--   because GHC doesn't revise module dependencies when targets or include
--   paths change, but only when files change.
updateTargets :: Targets -> IdeSessionUpdate

-- | Build an exe from sources added previously via the ide-backend
--   updateSourceFile* mechanism. The modules that contains the
--   <tt>main</tt> code are indicated in second argument to
--   <tt>buildExe</tt>. The function can be called multiple times with
--   different arguments. Additional GHC options, applied only when
--   building executables, are supplied in the first argument.
--   
--   We assume any indicated module is already successfully processed by
--   GHC API in a compilation mode that makes <tt>computedImports</tt>
--   available (but no code needs to be generated). The environment
--   (package dependencies, ghc options, preprocessor program options,
--   etc.) for building the exe is the same as when previously compiling
--   the code via GHC API. The module does not have to be called
--   <tt>Main</tt>, but we assume the main function is always <tt>main</tt>
--   (we don't check this and related conditions, but GHC does when
--   eventually called to build the exe).
--   
--   The executable files are placed in the filesystem inside the
--   <tt>build</tt> subdirectory of <a>getDistDir</a>, in subdirectories
--   corresponding to the given module names. The build directory does not
--   overlap with any of the other used directories and with its path.
--   
--   Logs from the building process are saved in files
--   <tt>build/ide-backend-exe.stdout</tt> and
--   <tt>build/ide-backend-exe.stderr</tt> in the <a>getDistDir</a>
--   directory.
--   
--   Note: currently it requires <tt>configGenerateModInfo</tt> to be set
--   (see #86). Also, after session restart, one has to call
--   <tt>updateSession</tt> at least once (even with empty updates list)
--   before calling it for <tt>buildExe</tt>. This ensures the code is
--   compiled again and the results made accessible.
buildExe :: [String] -> [(ModuleName, FilePath)] -> IdeSessionUpdate

-- | Build haddock documentation from sources added previously via the
--   ide-backend updateSourceFile* mechanism. Similarly to <a>buildExe</a>,
--   it needs the project modules to be already loaded within the session
--   and the generated docs can be found in the <tt>doc</tt> subdirectory
--   of <a>getDistDir</a>.
--   
--   Logs from the documentation building process are saved in files
--   <tt>doc/ide-backend-doc.stdout</tt> and
--   <tt>doc/ide-backend-doc.stderr</tt> in the <a>getDistDir</a>
--   directory.
--   
--   Note: currently it requires <tt>configGenerateModInfo</tt> to be set
--   (see #86).
buildDoc :: IdeSessionUpdate

-- | Build a file containing licenses of all used packages. Similarly to
--   <a>buildExe</a>, the function needs the project modules to be already
--   loaded within the session. The concatenated licenses can be found in
--   file <tt>licenses.txt</tt> inside the <a>getDistDir</a> directory.
--   
--   The function expects .cabal files of all used packages, except those
--   mentioned in <tt>configLicenseExc</tt>, to be gathered in the
--   directory given as the first argument (which needs to be an absolute
--   path or a path relative to the data dir). The code then expects to
--   find those packages installed and their license files in the usual
--   place that Cabal puts them (or the in-place packages should be
--   correctly embedded in the GHC tree).
--   
--   We guess the installed locations of the license files on the basis of
--   the haddock interfaces path. If the default setting does not work
--   properly, the haddock interfaces path should be set manually. E.g.,
--   <tt>cabal configure --docdir=the_same_path
--   --htmldir=the_same_path</tt> affects the haddock interfaces path
--   (because it is by default based on htmldir) and is reported to work
--   for some values of <tt>the_same_path</tt>.
--   
--   Logs from the license search and catenation process are saved in files
--   <tt>licenses.stdout</tt> and <tt>licenses.stderr</tt> in the
--   <a>getDistDir</a> directory.
--   
--   Note: currently <tt>configGenerateModInfo</tt> needs to be set for
--   this function to work (see #86).
--   
--   Note: if the executable uses TH and its module is named <tt>Main</tt>
--   (and so it's not compiled as a part of a temporary library)
--   <a>configDynLink</a> needs to be set. See #162.
buildLicenses :: FilePath -> IdeSessionUpdate

-- | This type represents intermediate progress information during
--   compilation.
data Progress :: *
Progress :: Int -> Int -> Maybe Text -> Maybe Text -> Progress

-- | The current step number
--   
--   When these Progress messages are generated from progress updates from
--   ghc, it is entirely possible that we might get step 4<i>26, 16</i>26,
--   3/26; the steps may not be continuous, might even be out of order, and
--   may not finish at X/X.
progressStep :: Progress -> Int

-- | The total number of steps
progressNumSteps :: Progress -> Int

-- | The parsed message. For instance, in the case of progress messages
--   during compilation, <a>progressOrigMsg</a> might be
--   
--   <pre>
--   [1 of 2] Compiling M (some/path/to/file.hs, some/other/path/to/file.o)
--   </pre>
--   
--   while <tt>progressMsg</tt> will just be 'Compiling M'
progressParsedMsg :: Progress -> Maybe Text

-- | The full original message (see <tt>progressMsg</tt>)
progressOrigMsg :: Progress -> Maybe Text

-- | Handles to the running code snippet, through which one can interact
--   with the snippet.
--   
--   Requirement: concurrent uses of <tt>supplyStdin</tt> should be
--   possible, e.g., two threads that share a <tt>RunActions</tt> should be
--   able to provide input concurrently without problems. (Currently this
--   is ensured by <tt>supplyStdin</tt> writing to a channel.)
data RunActions a
RunActions :: IO (Either ByteString a) -> IO () -> (ByteString -> IO ()) -> IO () -> RunActions a

-- | Wait for the code to output something or terminate
runWait :: RunActions a -> IO (Either ByteString a)

-- | Send a UserInterrupt exception to the code
--   
--   A call to <a>interrupt</a> after the snippet has terminated has no
--   effect.
interrupt :: RunActions a -> IO ()

-- | Make data available on the code's stdin
--   
--   A call to <a>supplyStdin</a> after the snippet has terminated has no
--   effect.
supplyStdin :: RunActions a -> ByteString -> IO ()

-- | Force terminate the runaction (The server will be useless after this
--   -- for internal use only).
--   
--   Guranteed not to block.
forceCancel :: RunActions a -> IO ()

-- | The outcome of running code
data RunResult :: *

-- | The code terminated okay
RunOk :: RunResult

-- | The code threw an exception
RunProgException :: String -> RunResult

-- | GHC itself threw an exception when we tried to run the code
RunGhcException :: String -> RunResult

-- | The session was restarted
RunForceCancelled :: RunResult

-- | Execution was paused because of a breakpoint
RunBreak :: RunResult

-- | Buffer modes for running code
--   
--   Note that <tt>NoBuffering</tt> means that something like
--   <a>putStrLn</a> will do a syscall per character, and each of these
--   characters will be read and sent back to the client. This results in a
--   large overhead.
--   
--   When using <tt>LineBuffering</tt> or <tt>BlockBuffering</tt>,
--   <tt>runWait</tt> will not report any output from the snippet until it
--   outputs a linebreak/fills the buffer, respectively (or does an
--   explicit flush). However, you can specify a timeout in addition to the
--   buffering mode; if you set this to <tt>Just n</tt>, the buffer will be
--   flushed every <tt>n</tt> microseconds.
--   
--   NOTE: This is duplicated in the IdeBackendRTS (defined in IdeSession)
data RunBufferMode :: *
RunNoBuffering :: RunBufferMode
RunLineBuffering :: Maybe Int -> RunBufferMode
runBufferTimeout :: RunBufferMode -> Maybe Int
RunBlockBuffering :: Maybe Int -> Maybe Int -> RunBufferMode
runBufferBlockSize :: RunBufferMode -> Maybe Int
runBufferTimeout :: RunBufferMode -> Maybe Int

-- | Information about a triggered breakpoint
data BreakInfo :: *
BreakInfo :: ModuleName -> SourceSpan -> Type -> VariableEnv -> BreakInfo

-- | Module containing the breakpoint
breakInfoModule :: BreakInfo -> ModuleName

-- | Location of the breakpoint
breakInfoSpan :: BreakInfo -> SourceSpan

-- | Type of the result
breakInfoResultType :: BreakInfo -> Type

-- | Local variables and their values
breakInfoVariableEnv :: BreakInfo -> VariableEnv

-- | Run a given function in a given module (the name of the module is the
--   one between <tt>module ... end</tt>, which may differ from the file
--   name). The function resembles a query, but it's not instantaneous and
--   the running code can be interrupted or interacted with.
--   
--   <a>runStmt</a> will throw an exception if the code has not been
--   compiled yet, or when the server is in a dead state (i.e., when ghc
--   has crashed). In the latter case <tt>getSourceErrors</tt> will report
--   the ghc exception; it is the responsibility of the client code to
--   check for this.
runStmt :: IdeSession -> String -> String -> IO (RunActions RunResult)

-- | Like <a>runStmt</a>, but runs the statement in a pseudoterminal.
runStmtPty :: IdeSession -> String -> String -> IO (RunActions RunResult)

-- | Run the main function from the last compiled executable.
--   
--   <a>runExe</a> will throw an exception if there were no executables
--   compiled since session init, or if the last compilation was not
--   successful (checked as in <tt>getBuildExeStatus</tt>) or if none of
--   the executables last compiled have the supplied name or when the
--   server is in a dead state (i.e., when ghc has crashed). In the last
--   case <tt>getSourceErrors</tt> will report the ghc exception; it is the
--   responsibility of the client code to check for this.
runExe :: IdeSession -> String -> IO (RunActions ExitCode)

-- | Resume a previously interrupted statement
resume :: IdeSession -> IO (RunActions RunResult)

-- | Repeatedly call <a>runWait</a> until we receive a <a>Right</a> result,
--   while collecting all <a>Left</a> results
runWaitAll :: RunActions a -> IO (ByteString, a)

-- | Breakpoint
--   
--   Set a breakpoint at the specified location. Returns <tt>Just</tt> the
--   old value of the breakpoint if successful, or <tt>Nothing</tt>
--   otherwise.
setBreakpoint :: IdeSession -> ModuleName -> SourceSpan -> Bool -> IO (Maybe Bool)

-- | Print and/or force values during debugging
--   
--   Only valid in breakpoint state.
printVar :: IdeSession -> Name -> Bool -> Bool -> IO VariableEnv

-- | The type of queries in a given session state.
--   
--   Queries are in IO because they depend on the current state of the
--   session but they promise not to alter the session state (at least not
--   in any visible way; they might update caches, etc.).
type Query a = IdeSession -> IO a

-- | The collection of source and data files submitted by the user.
data ManagedFiles
ManagedFiles :: [FilePath] -> [FilePath] -> ManagedFiles
sourceFiles :: ManagedFiles -> [FilePath]
dataFiles :: ManagedFiles -> [FilePath]
data Targets :: *
TargetsInclude :: [FilePath] -> Targets
TargetsExclude :: [FilePath] -> Targets

-- | GHC version
--   
--   NOTE: Defined in such a way that the Ord instance makes sense.
data GhcVersion :: *
GHC_7_4 :: GhcVersion
GHC_7_8 :: GhcVersion
GHC_7_10 :: GhcVersion

-- | Recover the fixed config the session was initialized with.
getSessionConfig :: Query SessionConfig

-- | Obtain the source files directory for this session.
getSourcesDir :: Query FilePath

-- | Obtain the data files directory for this session.
getDataDir :: Query FilePath

-- | Obtain the directory prefix for results of Cabal invocations.
--   Executables compiled in this session end up in a subdirectory
--   <tt>build</tt>, haddocks in <tt>doc</tt>, concatenated licenses in
--   file <tt>licenses</tt>, etc.
getDistDir :: Query FilePath

-- | Read the current value of one of the source modules.
getSourceModule :: FilePath -> Query ByteString

-- | Read the current value of one of the data files.
getDataFile :: FilePath -> Query ByteString

-- | Get the list of all data files currently available to the session:
--   both the files copied via an update and files created by user code.
getAllDataFiles :: Query [FilePath]
getCabalMacros :: Query ByteString

-- | Is code generation currently enabled?
getCodeGeneration :: Query Bool

-- | Get all current environment overrides
getEnv :: Query [(String, Maybe String)]

-- | Get the RPC server used by the session.
getGhcServer :: Query GhcServer

-- | Which GHC version is `ide-backend-server` using?
getGhcVersion :: Query GhcVersion

-- | Get the collection of files submitted by the user and not deleted yet.
--   The module names are those supplied by the user as the first arguments
--   of the <tt>updateSourceFile</tt> and <tt>updateSourceFileFromFile</tt>
--   calls, as opposed to the compiler internal <tt>module ... end</tt>
--   module names. Usually the two names are equal, but they needn't be.
getManagedFiles :: Query ManagedFiles

-- | Get information about the last breakpoint that we hit
--   
--   Returns Nothing if we are not currently stopped on a breakpoint.
getBreakInfo :: Query (Maybe BreakInfo)

-- | Get any compilation errors or warnings in the current state of the
--   session, meaning errors that GHC reports for the current state of all
--   the source modules.
--   
--   Note that in the initial implementation this will only return warnings
--   from the modules that changed in the last update, the intended
--   semantics is that morally it be a pure function of the current state
--   of the files, and so it would return all warnings (as if you did clean
--   and rebuild each time).
--   
--   getSourceErrors does internal normalization. This simplifies the life
--   of the client and anyway there shouldn't be that many source errors
--   that it really makes a big difference.
getSourceErrors :: Query [SourceError]

-- | Get the list of correctly compiled modules, as reported by the
--   compiler
getLoadedModules :: Query [ModuleName]

-- | Get the mapping from filenames to modules (as computed by GHC)
getFileMap :: Query (FilePath -> Maybe ModuleId)

-- | Get exit status of the last invocation of <tt>buildExe</tt>, if any.
getBuildExeStatus :: Query (Maybe ExitCode)

-- | Get exit status of the last invocation of <tt>buildDoc</tt>, if any.
getBuildDocStatus :: Query (Maybe ExitCode)

-- | Get exit status of the last invocation of <tt>buildLicenses</tt>, if
--   any.
getBuildLicensesStatus :: Query (Maybe ExitCode)

-- | Get information about an identifier at a specific location
getSpanInfo :: Query (ModuleName -> SourceSpan -> [(SourceSpan, SpanInfo)])

-- | Get information the type of a subexpressions and the subexpressions
--   around it
getExpTypes :: Query (ModuleName -> SourceSpan -> [(SourceSpan, Text)])

-- | Use sites
--   
--   Use sites are only reported in modules that get compiled successfully.
getUseSites :: Query (ModuleName -> SourceSpan -> [SourceSpan])

-- | Minimal .cabal file for the loaded modules seen as a library. The
--   argument specifies the name of the library.
--   
--   License is set to <tt>AllRightsReserved</tt>. All transitive package
--   dependencies are included, with package versions set to the currently
--   used versions. Only modules that get compiled successfully are
--   included. Source directory is the currently used session source
--   directory. Warning: all modules named <tt>Main</tt> (even in
--   subdirectories or files with different names) are ignored so that they
--   don't get in the way when we build an executable using the library and
--   so that the behaviour is consistent with that of <tt>buildExe</tt>.
getDotCabal :: Query (String -> Version -> ByteString)

-- | Get import information
--   
--   This information is available even for modules with parse/type errors
getImports :: Query (ModuleName -> Maybe [Import])

-- | Autocompletion
--   
--   Use <a>idInfoQN</a> to translate these <a>IdInfo</a>s into qualified
--   names, taking into account the module imports.
getAutocompletion :: Query (ModuleName -> String -> [IdInfo])

-- | (Transitive) package dependencies
--   
--   These are only available for modules that got compiled successfully.
getPkgDeps :: Query (ModuleName -> Maybe [PackageId])

-- | Identifiers in Haskell are drawn from a number of different name
--   spaces
data IdNameSpace :: *

-- | Variables, including real data constructors
VarName :: IdNameSpace

-- | Source data constructors
DataName :: IdNameSpace

-- | Type variables
TvName :: IdNameSpace

-- | Type constructors and classes
TcClsName :: IdNameSpace

-- | For now we represent types in pretty-printed form
type Type = Text

-- | Information about identifiers
data IdInfo :: *
IdInfo :: SrictNotUnpackedIdProp -> SrictNotUnpackedIdScope -> IdInfo
idProp :: IdInfo -> SrictNotUnpackedIdProp
idScope :: IdInfo -> SrictNotUnpackedIdScope

-- | Identifier info that is independent of the usage site
data IdProp :: *
IdProp :: SrictNotUnpackedName -> SrictNotUnpackedIdNameSpace -> SrictNotUnpacked(Maybe Type) -> SrictNotUnpackedModuleId -> SrictNotUnpackedEitherSpan -> SrictNotUnpacked(Maybe ModuleId) -> IdProp

-- | The base name of the identifer at this location. Module prefix is not
--   included.
idName :: IdProp -> SrictNotUnpackedName

-- | Namespace this identifier is drawn from
idSpace :: IdProp -> SrictNotUnpackedIdNameSpace

-- | The type We don't always know this; in particular, we don't know kinds
--   because the type checker does not give us LSigs for top-level
--   annotations)
idType :: IdProp -> SrictNotUnpacked(Maybe Type)

-- | Module the identifier was defined in
idDefinedIn :: IdProp -> SrictNotUnpackedModuleId

-- | Where in the module was it defined (not always known)
idDefSpan :: IdProp -> SrictNotUnpackedEitherSpan

-- | Haddock home module
idHomeModule :: IdProp -> SrictNotUnpacked(Maybe ModuleId)
data IdScope :: *

-- | This is a binding occurrence (<tt>f x = ..</tt>, <tt>x -&gt; ..</tt>,
--   etc.)
Binder :: IdScope

-- | Defined within this module
Local :: IdScope

-- | Imported from a different module
Imported :: SrictNotUnpackedModuleId -> SrictNotUnpackedEitherSpan -> SrictNotUnpackedText -> IdScope
idImportedFrom :: IdScope -> SrictNotUnpackedModuleId
idImportSpan :: IdScope -> SrictNotUnpackedEitherSpan

-- | Qualifier used for the import
--   
--   <pre>
--   IMPORTED AS                       idImportQual
--   import Data.List                  ""
--   import qualified Data.List        "Data.List."
--   import qualified Data.List as L   "L."
--   </pre>
idImportQual :: IdScope -> SrictNotUnpackedText

-- | Wired into the compiler (<tt>()</tt>, <tt>True</tt>, etc.)
WiredIn :: IdScope
data SourceSpan :: *
SourceSpan :: SrictNotUnpackedFilePath -> SrictNotUnpackedInt -> SrictNotUnpackedInt -> SrictNotUnpackedInt -> SrictNotUnpackedInt -> SourceSpan
spanFilePath :: SourceSpan -> SrictNotUnpackedFilePath
spanFromLine :: SourceSpan -> SrictNotUnpackedInt
spanFromColumn :: SourceSpan -> SrictNotUnpackedInt
spanToLine :: SourceSpan -> SrictNotUnpackedInt
spanToColumn :: SourceSpan -> SrictNotUnpackedInt
data EitherSpan :: *
ProperSpan :: SrictNotUnpackedSourceSpan -> EitherSpan
TextSpan :: SrictNotUnpackedText -> EitherSpan

-- | An error or warning in a source module.
--   
--   Most errors are associated with a span of text, but some have only a
--   location point.
data SourceError :: *
SourceError :: SrictNotUnpackedSourceErrorKind -> SrictNotUnpackedEitherSpan -> SrictNotUnpackedText -> SourceError
errorKind :: SourceError -> SrictNotUnpackedSourceErrorKind
errorSpan :: SourceError -> SrictNotUnpackedEitherSpan
errorMsg :: SourceError -> SrictNotUnpackedText

-- | Severity of an error.
data SourceErrorKind :: *
KindError :: SourceErrorKind
KindWarning :: SourceErrorKind
KindServerDied :: SourceErrorKind
type ModuleName = Text
data ModuleId :: *
ModuleId :: SrictNotUnpackedModuleName -> SrictNotUnpackedPackageId -> ModuleId
moduleName :: ModuleId -> SrictNotUnpackedModuleName
modulePackage :: ModuleId -> SrictNotUnpackedPackageId

-- | A package ID in ide-backend consists of a human-readable package name
--   and version (what Cabal calls a source ID) along with ghc's internal
--   package key (primarily for internal use).
data PackageId :: *
PackageId :: SrictNotUnpackedText -> SrictNotUnpacked(Maybe Text) -> SrictNotUnpackedText -> PackageId
packageName :: PackageId -> SrictNotUnpackedText
packageVersion :: PackageId -> SrictNotUnpacked(Maybe Text)
packageKey :: PackageId -> SrictNotUnpackedText
data ImportEntities :: *
ImportOnly :: SrictNotUnpacked[Text] -> ImportEntities
ImportHiding :: SrictNotUnpacked[Text] -> ImportEntities
ImportAll :: ImportEntities
data Import :: *
Import :: SrictNotUnpackedModuleId -> SrictNotUnpacked(Maybe Text) -> SrictNotUnpackedBool -> SrictNotUnpackedBool -> SrictNotUnpacked(Maybe ModuleName) -> SrictNotUnpackedImportEntities -> Import
importModule :: Import -> SrictNotUnpackedModuleId

-- | Used only for ghc's PackageImports extension
importPackage :: Import -> SrictNotUnpacked(Maybe Text)
importQualified :: Import -> SrictNotUnpackedBool
importImplicit :: Import -> SrictNotUnpackedBool
importAs :: Import -> SrictNotUnpacked(Maybe ModuleName)
importEntities :: Import -> SrictNotUnpackedImportEntities

-- | Returned when the IDE asks "what's at this particular location?"
data SpanInfo :: *

-- | Identifier
SpanId :: IdInfo -> SpanInfo

-- | Quasi-quote. The <a>IdInfo</a> field gives the quasi-quoter
SpanQQ :: IdInfo -> SpanInfo

-- | Construct qualified name following Haskell's scoping rules
idInfoQN :: IdInfo -> String

-- | Show approximately a haddock link (without haddock root) for an id.
--   This is an illustration and a test of the id info, but under ideal
--   conditions could perhaps serve to link to documentation without going
--   via Hoogle.
haddockLink :: IdProp -> IdScope -> String

-- | Exceptions thrown by the remote server
data ExternalException :: *
ExternalException :: String -> Maybe IOException -> ExternalException

-- | The output from the server on stderr
externalStdErr :: ExternalException -> String

-- | The local exception that was thrown and alerted us to the problem
externalException :: ExternalException -> Maybe IOException
data InvalidSessionStateQueries
InvalidSessionStateQueries :: InvalidSessionStateQueries

-- | We typically get packages from several databases, and stack them
--   together. This type lets us be explicit about that stacking. For
--   example typical stacks include:
--   
--   <pre>
--   [GlobalPackageDB]
--   [GlobalPackageDB, UserPackageDB]
--   [GlobalPackageDB, SpecificPackageDB "package.conf.inplace"]
--   </pre>
--   
--   Note that the <a>GlobalPackageDB</a> is invariably at the bottom since
--   it contains the rts, base and other special compiler-specific
--   packages.
--   
--   We are not restricted to using just the above combinations. In
--   particular we can use several custom package dbs and the user package
--   db together.
--   
--   When it comes to writing, the top most (last) package is used.
type PackageDBStack = [PackageDB]

-- | Some compilers have a notion of a database of available packages. For
--   some there is just one global db of packages, other compilers support
--   a per-user or an arbitrary db specified at some location in the file
--   system. This can be used to build isloated environments of packages,
--   for example to build a collection of related packages without
--   installing them globally.
data PackageDB :: *
GlobalPackageDB :: PackageDB
UserPackageDB :: PackageDB
SpecificPackageDB :: FilePath -> PackageDB
getGhcExitCode :: GhcServer -> IO (Maybe ExitCode)

-- | Print the id info maps to stdout (for debugging purposes only)
dumpIdInfo :: IdeSession -> IO ()

-- | Print autocompletion to stdout (for debugging purposes only)
dumpAutocompletion :: IdeSession -> IO ()

-- | Print file mapping to stdout (for debugging purposes only)
dumpFileMap :: IdeSession -> IO ()

-- | Crash the GHC server. For debugging only. If the specified delay is
--   <tt>Nothing</tt>, crash immediately; otherwise, set up a thread that
--   throws an exception to the main thread after the delay.
crashGhcServer :: IdeSession -> Maybe Int -> IO ()

-- | Extensions of all source files we keep in our source directory.
sourceExtensions :: [FilePath]

-- | For detecting runtime version mismatch between the server and the
--   library
--   
--   We use a Unix timestamp for this so that these API versions have some
--   semantics (http:/<i>www.epochconverter.com</i>, GMT).
ideBackendApiVersion :: Int

-- | Build the concatenation of all license files from a given list of
--   packages. See <tt>buildLicenses</tt>.
buildLicsFromPkgs :: Bool -> LicenseArgs -> IO ExitCode
data LicenseArgs
LicenseArgs :: PackageDBStack -> [FilePath] -> [String] -> FilePath -> FilePath -> FilePath -> [(String, (Maybe License, Maybe FilePath, Maybe String))] -> FilePath -> [PackageId] -> LicenseArgs

-- | 3 fields from session configuration
liPackageDBStack :: LicenseArgs -> PackageDBStack
liExtraPathDirs :: LicenseArgs -> [FilePath]
liLicenseExc :: LicenseArgs -> [String]

-- | the working directory; the resulting file is written there
liDistDir :: LicenseArgs -> FilePath
liStdoutLog :: LicenseArgs -> FilePath
liStderrLog :: LicenseArgs -> FilePath

-- | see <tt>configLicenseFixed</tt>
licenseFixed :: LicenseArgs -> [(String, (Maybe License, Maybe FilePath, Maybe String))]

-- | the directory with all the .cabal files
liCabalsDir :: LicenseArgs -> FilePath

-- | the list of packages to process
liPkgs :: LicenseArgs -> [PackageId]
