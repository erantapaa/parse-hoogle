-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | a monad to calculate linear recursive sequence
--   
--   A monad to calculate linear recursive sequence efficiently. Matrix
--   multiplication and fast exponentiation algorithm are used to speed up
--   calculating the number with particular index in the sequence. This
--   library also provides a monadic DSL to describe the sequence.
@package monad-lrs
@version 0.0.2.1


-- | A monad to calculate linear recursive sequence efficiently. Matrix
--   multiplication and fast exponentiation algorithm are used to speed up
--   calculating the number with particular index in the sequence. This
--   library also provides a monadic DSL to describe the sequence.
--   
--   As an example, here is the fibonacci sequence
--   
--   <pre>
--   fib = do
--       [f0, f1] &lt;- newVariables [1, 1]
--       f0 &lt;:- f0 &lt;+&gt; f1
--       return f1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (runLinearRecursive fib) [0..10]
--   [1,1,2,3,5,8,13,21,34,55,89]
--   </pre>
module Math.LinearRecursive.Monad

-- | represents vector type class, there are two instances:
--   
--   <ul>
--   <li><i><tt>Vector</tt></i> General purpose vector.</li>
--   <li><i><tt>Vector1</tt></i> Unit vector in vector space.</li>
--   </ul>
class VectorLike v
toVector :: (VectorLike v, Eq a, Num a) => v a -> Vector a

-- | A vector represents linear combination of several variables.
type LinearCombination = Vector

-- | An unit vector represents dependence on a particular variable.
type Variable = Vector1

-- | Vector addition, <tt>a &lt;+&gt; b</tt> represents sum of <tt>a</tt>
--   and <tt>b</tt>.
(<+>) :: (Eq a, Num a, VectorLike v1, VectorLike v2) => v1 a -> v2 a -> Vector a

-- | Vector subtraction, <tt>a &lt;-&gt; b</tt> represents difference of
--   <tt>a</tt> and <tt>b</tt>
(<->) :: (Eq a, Num a, VectorLike v1, VectorLike v2) => v1 a -> v2 a -> Vector a

-- | Left-side scalar multiplication, <tt>s &lt;* a</tt> is <tt>a</tt>
--   scaled by <tt>s</tt>. For example, <tt>1 &lt;* a</tt> equals to
--   <tt>a</tt>, <tt>2 &lt;* a</tt> equals to <tt>a+a</tt>
(<*) :: (Eq a, Num a, VectorLike v) => a -> v a -> Vector a

-- | Right-side scalar multiplication, <tt>a *&gt; s</tt> is <tt>a</tt>
--   scaled by <tt>s</tt>.
(*>) :: (Eq a, Num a, VectorLike v) => v a -> a -> Vector a

-- | The zero vector.
zeroVector :: (Eq a, Num a) => Vector a
data Polynomial a
x :: (Eq a, Num a) => Polynomial a

-- | The monad to specify the calculation of next number of a linear
--   recursive sequence.
--   
--   All linear recursive sequences can be generated by iteration, the next
--   number can be represented by linear combination of some previous
--   numbers. This can be regarded as linear transformation between states,
--   and it's actually multiply a transform matrix.
--   
--   In order to formalize and simply this procedure, this monad use
--   mutable-like variables to denote the states, and mutable-like
--   assignment to denote the transform matrix.
--   
--   To evaluate this sequence, the monad will be simulated step by step,
--   after each step, all variable will be updated. Besides, if the monad
--   returns a <a>LinearCombination</a>, a number will be generated each
--   step. (well, actual calculation uses fast exponentiation algorithm to
--   speed up this calculation)
data LinearRecursive a b

-- | Declare a new variable, with its initial value (the value before step
--   0).
--   
--   <pre>
--   test = do
--       v &lt;- newVariable 1
--       v &lt;:- v &lt;+&gt; v
--       return v
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (runLinearRecursive test) [0..10]
--   [1,2,4,8,16,32,64,128,256,512,1024]
--   </pre>
newVariable :: (Eq a, Num a) => a -> LinearRecursive a (Variable a)

-- | Declare a new sequence, with their initial value.
--   
--   After each step, each variable except the first one will be assigned
--   with the value of its predecessor variable before this turn.
--   
--   It's not encouraged to assign any value to the variables other than
--   the first one.
--   
--   <pre>
--   test = do
--        [v1, v2, v3] &lt;- newVariables [1,2,3]
--        v1 &lt;:- v3
--        return v3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map (runLinearRecursive test) [0..10]
--   [3,2,1,3,2,1,3,2,1,3,2]
--   </pre>
newVariables :: (Eq a, Num a) => [a] -> LinearRecursive a [Variable a]

-- | Variable assignment. <tt>v &lt;:- a</tt> replace variable <tt>v</tt>
--   with <tt>a</tt> after this step. If there are multiple assignments to
--   one variable, only the last one counts.
(<:-) :: (Eq a, Num a, VectorLike v) => Variable a -> v a -> LinearRecursive a ()

-- | Variable accumulated assignment. <tt>v &lt;+- a</tt> replace variable
--   <tt>v</tt> with <tt>v &lt;+&gt; a</tt>.
--   
--   Be aware that <tt>v</tt> will be zero before any assignment.
(<+-) :: (Eq a, Num a, VectorLike v) => Variable a -> v a -> LinearRecursive a ()

-- | <i>O(v^3 * log n)</i>, where <i>v</i> is the number of variables, and
--   <i>n</i> is steps to simulate.
--   
--   <tt>runLinearRecursive m n</tt> simulate the monad by <tt>n</tt>
--   steps, and return the actual value denoted by returned
--   <a>LinearCombination</a>.
--   
--   n must be non-negative.
runLinearRecursive :: (Eq a, Num a, Integral b, VectorLike v) => LinearRecursive a (v a) -> b -> a

-- | <i>O(v^2 * n)</i>. similar to <tt>runLinearRecursive</tt>, but return
--   an infinite list instead of a particular index.
simulateLinearRecursive :: (Eq a, Num a, VectorLike v) => LinearRecursive a (v a) -> [a]

-- | return a constent number. Use one extra variable.
--   
--   <pre>
--   &gt;&gt;&gt; map (runLinearRecursive (getConstant 3)) [0..10]
--   [3,3,3,3,3,3,3,3,3,3,3]
--   </pre>
getConstant :: (Eq a, Num a) => a -> LinearRecursive a (LinearCombination a)

-- | return sum of a linear combination in steps before current one. Use
--   one extra variable.
--   
--   <pre>
--   &gt;&gt;&gt; map (runLinearRecursive (getConstant 3 &gt;&gt;= getPartialSum)) [0..10]
--   [0,3,6,9,12,15,18,21,24,27,30]
--   </pre>
getPartialSum :: (Eq a, Num a) => LinearCombination a -> LinearRecursive a (LinearCombination a)

-- | return the current step number. Use two extra variables.
--   
--   <pre>
--   &gt;&gt;&gt; map (runLinearRecursive getStep) [0..10]
--   [0,1,2,3,4,5,6,7,8,9,10]
--   </pre>
getStep :: (Eq a, Num a) => LinearRecursive a (LinearCombination a)

-- | <tt>getPowerOf a</tt> return power of <tt>a</tt> with order equal to
--   current step number. Use one extra variable.
--   
--   <pre>
--   &gt;&gt;&gt; map (runLinearRecursive (getPowerOf 3)) [0..10]
--   [1,3,9,27,81,243,729,2187,6561,19683,59049]
--   </pre>
getPowerOf :: (Eq a, Num a) => a -> LinearRecursive a (LinearCombination a)

-- | <tt>getPolynomial poly</tt> evaluate polynomial <tt>poly</tt> with
--   variable <tt>x</tt> replaced by current step number. Use <tt>n</tt>
--   extra variables, where <tt>n</tt> is the degree of <tt>poly</tt>
--   
--   <pre>
--   &gt;&gt;&gt; map (runLinearRecursive (getPolynomial ((x+1)^2))) [0..10]
--   [1,4,9,16,25,36,49,64,81,100,121]
--   </pre>
getPolynomial :: (Eq a, Num a) => Polynomial a -> LinearRecursive a (LinearCombination a)
getPartialSumWith :: (Eq a, Num a, VectorLike v) => Polynomial a -> v a -> LinearRecursive a (LinearCombination a)
instance Num a => Monad (LinearRecursive a)
instance Num a => Functor (LinearRecursive a)
