-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A replacement for System.Exit and System.Process.
--   
@package sys-process
@version 0.1.6

module Sys.ExitCode
type ExitCode = Number Int
_ExitFailure :: Prism' ExitCode (NotZero Int)
_ExitSuccess :: Prism' ExitCode ()
exitFailure :: NotZero Int -> ExitCode
exitSuccess :: ExitCode
exitFailureP :: Prism' ExitCode Int
exitSuccessP :: Prism' ExitCode ()
exitCode :: ExitCode -> ExitCode
unExitCode :: ExitCode -> ExitCode

module Sys.StdStream
data StdStream

-- | Inherit Handle from parent
Inherit :: StdStream

-- | Use the supplied Handle
UseHandle :: Handle -> StdStream

-- | Create a new pipe. The returned <tt>Handle</tt> will use the default
--   encoding and newline translation mode (just like <tt>Handle</tt>s
--   created by <tt>openFile</tt>).
CreatePipe :: StdStream
class AsStdStream p f s
_StdStream :: AsStdStream p f s => Optic' p f s StdStream
class AsInherit p f s
_Inherit :: AsInherit p f s => Optic' p f s ()
class AsUseHandle p f s
_UseHandle :: AsUseHandle p f s => Optic' p f s Handle
class AsCreatePipe p f s
instance Eq StdStream
instance Show StdStream
instance (Choice p, Applicative f) => AsCreatePipe p f StdStream
instance AsCreatePipe p f ()
instance (Choice p, Applicative f) => AsUseHandle p f StdStream
instance AsUseHandle p f Handle
instance (Choice p, Applicative f) => AsInherit p f StdStream
instance AsInherit p f ()
instance (Profunctor p, Functor f) => AsStdStream p f StdStream
instance AsStdStream p f StdStream

module Sys.CmdSpec
data CmdSpec

-- | A command line to execute using the shell
ShellCommand :: String -> CmdSpec

-- | The name of an executable with a list of arguments
--   
--   The <a>FilePath</a> argument names the executable, and is interpreted
--   according to the platform's standard policy for searching for
--   executables. Specifically:
--   
--   <ul>
--   <li>on Unix systems the <a>execvp(3)</a> semantics is used, where if
--   the executable filename does not contain a slash (<tt>/</tt>) then the
--   <tt>PATH</tt> environment variable is searched for the
--   executable.</li>
--   <li>on Windows systems the Win32 <tt>CreateProcess</tt> semantics is
--   used. Briefly: if the filename does not contain a path, then the
--   directory containing the parent executable is searched, followed by
--   the current directory, then some standard locations, and finally the
--   current <tt>PATH</tt>. An <tt>.exe</tt> extension is added if the
--   filename does not already have an extension. For full details see the
--   <a>documentation</a> for the Windows <tt>SearchPath</tt> API.</li>
--   </ul>
RawCommand :: FilePath -> [String] -> CmdSpec
class AsCmdSpec p f s
_CmdSpec :: AsCmdSpec p f s => Optic' p f s CmdSpec
class AsExecutableName p f s
_ExecutableName :: AsExecutableName p f s => Optic' p f s FilePath
class AsExecutableArguments p f s
_ExecutableArguments :: AsExecutableArguments p f s => Optic' p f s [String]
class AsShellCommand p f s
_ShellCommand :: AsShellCommand p f s => Optic' p f s String
class AsRawCommand p f s
_RawCommand :: AsRawCommand p f s => Optic' p f s (FilePath, [String])
instance Eq CmdSpec
instance Ord CmdSpec
instance Show CmdSpec
instance (Choice p, Applicative f) => AsRawCommand p f CmdSpec
instance AsRawCommand p f (FilePath, [String])
instance (Choice p, Applicative f) => AsShellCommand p f CmdSpec
instance AsShellCommand p f String
instance Applicative f => AsExecutableArguments (->) f CmdSpec
instance AsExecutableArguments p f [String]
instance Applicative f => AsExecutableName (->) f CmdSpec
instance AsExecutableName p f FilePath
instance (Profunctor p, Functor f) => AsCmdSpec p f CmdSpec
instance AsCmdSpec p f CmdSpec
instance IsString CmdSpec

module Sys.CreateProcess

-- | Data type representing a process.
--   
--   <i>see <a>CreateProcess</a></i>.
data CreateProcess
CreateProcess :: CmdSpec -> (Maybe FilePath) -> (Maybe [(String, String)]) -> StdStream -> StdStream -> StdStream -> Bool -> Bool -> Bool -> CreateProcess

-- | Types that related to <tt>CreateProcess</tt>.
class AsCreateProcess p f s
_CreateProcess :: AsCreateProcess p f s => Optic' p f s CreateProcess

-- | Types that relate to a (maybe) working directory.
class AsWorkingDirectory p f s
_WorkingDirectory :: AsWorkingDirectory p f s => Optic' p f s (Maybe FilePath)

-- | Types that relate to an environment.
class AsEnvironment p f s
_Environment :: AsEnvironment p f s => Optic' p f s (Maybe [(String, String)])

-- | Types that relate to a standard input stream.
class AsStdin p f s
_Stdin :: AsStdin p f s => Optic' p f s StdStream

-- | Types that relate to a standard output stream.
class AsStdout p f s
_Stdout :: AsStdout p f s => Optic' p f s StdStream

-- | Types that relate to a standard error stream.
class AsStderr p f s
_Stderr :: AsStderr p f s => Optic' p f s StdStream

-- | Types that relate to closing descriptors.
class AsCloseDescriptors p f s
_CloseDescriptors :: AsCloseDescriptors p f s => Optic' p f s Bool

-- | Types that relate to creating groups.
class AsCreateGroup p f s
_CreateGroup :: AsCreateGroup p f s => Optic' p f s Bool

-- | Types that relate to delegating CTRL-C.
class AsDelegateCtrlC p f s
_DelegateCtrlC :: AsDelegateCtrlC p f s => Optic' p f s Bool
instance Eq CreateProcess
instance Show CreateProcess
instance Functor f => AsDelegateCtrlC (->) f CreateProcess
instance AsDelegateCtrlC p f Bool
instance Functor f => AsCreateGroup (->) f CreateProcess
instance AsCreateGroup p f Bool
instance Functor f => AsCloseDescriptors (->) f CreateProcess
instance AsCloseDescriptors p f Bool
instance Functor f => AsStderr (->) f CreateProcess
instance AsStderr p f StdStream
instance Functor f => AsStdout (->) f CreateProcess
instance AsStdout p f StdStream
instance Functor f => AsStdin (->) f CreateProcess
instance AsStdin p f StdStream
instance Functor f => AsEnvironment (->) f CreateProcess
instance AsEnvironment p f (Maybe [(String, String)])
instance Functor f => AsWorkingDirectory (->) f CreateProcess
instance AsWorkingDirectory p f (Maybe FilePath)
instance Applicative f => AsRawCommand (->) f CreateProcess
instance Applicative f => AsShellCommand (->) f CreateProcess
instance Applicative f => AsExecutableArguments (->) f CreateProcess
instance Applicative f => AsExecutableName (->) f CreateProcess
instance Functor f => AsCmdSpec (->) f CreateProcess
instance (Profunctor p, Functor f) => AsCreateProcess p f CreateProcess
instance AsCreateProcess p f CreateProcess

module Sys.Process
data ProcessHandle :: *

-- | This is the most general way to spawn an external process. The process
--   can be a command line to be executed by a shell or a raw command with
--   a list of arguments. The stdin, stdout, and stderr streams of the new
--   process may individually be attached to new pipes, to existing
--   <a>Handle</a>s, or just inherited from the parent (the default.)
--   
--   The details of how to create the process are passed in the
--   <a>CreateProcess</a> record. To make it easier to construct a
--   <a>CreateProcess</a>, the functions <a>proc</a> and <a>shell</a> are
--   supplied that fill in the fields with default values which can be
--   overriden as needed.
--   
--   <a>createProcess</a> returns <tt>(<i>mb_stdin_hdl</i>,
--   <i>mb_stdout_hdl</i>, <i>mb_stderr_hdl</i>, <i>ph</i>)</tt>, where
--   
--   <ul>
--   <li>if <tt><tt>std_in</tt> == <a>CreatePipe</a></tt>, then
--   <tt><i>mb_stdin_hdl</i></tt> will be <tt>Just <i>h</i></tt>, where
--   <tt><i>h</i></tt> is the write end of the pipe connected to the child
--   process's <tt>stdin</tt>.</li>
--   <li>otherwise, <tt><i>mb_stdin_hdl</i> == Nothing</tt></li>
--   </ul>
--   
--   Similarly for <tt><i>mb_stdout_hdl</i></tt> and
--   <tt><i>mb_stderr_hdl</i></tt>.
--   
--   For example, to execute a simple <tt>ls</tt> command:
--   
--   <pre>
--   r &lt;- createProcess (proc "ls" [])
--   </pre>
--   
--   To create a pipe from which to read the output of <tt>ls</tt>:
--   
--   <pre>
--   (_, Just hout, _, _) &lt;-
--       createProcess (proc "ls" []){ std_out = CreatePipe }
--   </pre>
--   
--   To also set the directory in which to run <tt>ls</tt>:
--   
--   <pre>
--   (_, Just hout, _, _) &lt;-
--       createProcess (proc "ls" []){ cwd = Just "\home\bob",
--                                     std_out = CreatePipe }
--   </pre>
--   
--   Note that <tt>Handle</tt>s provided for <tt>std_in</tt>,
--   <tt>std_out</tt>, or <tt>std_err</tt> via the <tt>UseHandle</tt>
--   constructor will be closed by calling this function. This is not
--   always the desired behavior. In cases where you would like to leave
--   the <tt>Handle</tt> open after spawning the child process, please use
--   <a>createProcess_</a> instead.
--   
--   <i>see <a>createProcess</a></i>.
createProcess :: CreateProcess -> IO (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle)

-- | This function is almost identical to <a>createProcess</a>. The only
--   differences are:
--   
--   <ul>
--   <li><a>Handle</a>s provided via <a>UseHandle</a> are not closed
--   automatically.</li>
--   <li>This function takes an extra <tt>String</tt> argument to be used
--   in creating error messages.</li>
--   </ul>
--   
--   <i>see <a>createProcess_</a></i>.
createProcess_ :: String -> CreateProcess -> IO (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle)
createProcessHandle :: CreateProcess -> IO ProcessHandle
createWaitProcess :: CreateProcess -> IO ExitCode
createMakeWaitProcess :: CreateProcess -> IO ExitCode

-- | Construct a <a>CreateProcess</a> record for passing to
--   <a>createProcess</a>, representing a command to be passed to the
--   shell.
--   
--   <i>see <a>shell</a></i>.
shell :: String -> CreateProcess

-- | Construct a <a>CreateProcess</a> record for passing to
--   <a>createProcess</a>, representing a raw command with arguments.
--   
--   See <a>RawCommand</a> for precise semantics of the specified
--   <tt>FilePath</tt>.
--   
--   <i>see <a>proc</a></i>.
proc :: FilePath -> [String] -> CreateProcess
procIn :: FilePath -> FilePath -> [String] -> CreateProcess

-- | Creates a new process to run the specified command with the given
--   arguments, and wait for it to finish. If the command returns a
--   non-zero exit code, an exception is raised.
--   
--   If an asynchronous exception is thrown to the thread executing
--   <tt>callProcess</tt>. The forked process will be terminated and
--   <tt>callProcess</tt> will wait (block) until the process has been
--   terminated.
--   
--   <i>see 'System.Process.callProcess</i>.
callProcess :: FilePath -> [String] -> IO ()

-- | Creates a new process to run the specified shell command. If the
--   command returns a non-zero exit code, an exception is raised.
--   
--   If an asynchronous exception is thrown to the thread executing
--   <tt>callCommand</tt>. The forked process will be terminated and
--   <tt>callCommand</tt> will wait (block) until the process has been
--   terminated.
--   
--   <i>see 'System.Process.callCommand</i>.
callCommand :: String -> IO ()

-- | Creates a new process to run the specified raw command with the given
--   arguments. It does not wait for the program to finish, but returns the
--   <tt>ProcessHandle</tt>.
--   
--   <i>see 'System.Process.spawnProcess</i>.
spawnProcess :: FilePath -> [String] -> IO ProcessHandle

-- | Creates a new process to run the specified shell command. It does not
--   wait for the program to finish, but returns the
--   <tt>ProcessHandle</tt>.
--   
--   <i>see 'System.Process.spawnCommand</i>.
spawnCommand :: String -> IO ProcessHandle

-- | <tt>readCreateProcess</tt> works exactly like <a>readProcess</a>
--   except that it lets you pass <a>CreateProcess</a> giving better
--   flexibility.
--   
--   <pre>
--   &gt; readCreateProcess (shell "pwd" { cwd = "/etc/" }) ""
--   "/etc\n"
--   </pre>
--   
--   Note that <tt>Handle</tt>s provided for <tt>std_in</tt> or
--   <tt>std_out</tt> via the CreateProcess record will be ignored.
--   
--   <i>see <a>readCreateProcess</a></i>.
readCreateProcess :: CreateProcess -> String -> IO String
readProcess :: FilePath -> [String] -> String -> IO String

-- | <tt>readCreateProcessWithExitCode</tt> works exactly like
--   <a>readProcessWithExitCode</a> except that it lets you pass
--   <a>CreateProcess</a> giving better flexibility.
--   
--   Note that <tt>Handle</tt>s provided for <tt>std_in</tt>,
--   <tt>std_out</tt>, or <tt>std_err</tt> via the CreateProcess record
--   will be ignored.
--   
--   <i>see <a>readCreateProcessWithExitCode</a></i>.
readCreateProcessWithExitCode :: CreateProcess -> String -> IO (ExitCode, String, String)

-- | <tt>readProcessWithExitCode</tt> is like <tt>readProcess</tt> but with
--   two differences:
--   
--   <ul>
--   <li>it returns the <a>ExitCode</a> of the process, and does not throw
--   any exception if the code is not <tt>ExitSuccess</tt>.</li>
--   <li>it reads and returns the output from process' standard error
--   handle, rather than the process inheriting the standard error
--   handle.</li>
--   </ul>
--   
--   On Unix systems, see <a>waitForProcess</a> for the meaning of exit
--   codes when the process died as the result of a signal.
--   
--   <i>see <a>readProcessWithExitCode</a></i>.
readProcessWithExitCode :: FilePath -> [String] -> String -> IO (ExitCode, String, String)

-- | Given a program <tt><i>p</i></tt> and arguments <tt><i>args</i></tt>,
--   <tt>showCommandForUser <i>p</i> <i>args</i></tt> returns a string
--   suitable for pasting into <tt>/bin/sh</tt> (on Unix systems) or
--   <tt>CMD.EXE</tt> (on Windows).
--   
--   <i>see <a>showCommandForUser</a></i>.
showCommandForUser :: FilePath -> [String] -> String

-- | Waits for the specified process to terminate, and returns its exit
--   code.
--   
--   GHC Note: in order to call <tt>waitForProcess</tt> without blocking
--   all the other threads in the system, you must compile the program with
--   <tt>-threaded</tt>.
--   
--   On Unix systems, a negative value <tt><tt>ExitFailure</tt>
--   -<i>signum</i></tt> indicates that the child was terminated by signal
--   <tt><i>signum</i></tt>. The signal numbers are platform-specific, so
--   to test for a specific signal use the constants provided by
--   <a>System.Posix.Signals</a> in the <tt>unix</tt> package. Note: core
--   dumps are not reported, use <a>System.Posix.Process</a> if you need
--   this detail.
--   
--   <i>see <a>waitForProcess</a></i>.
waitForProcess :: ProcessHandle -> IO ExitCode

-- | This is a non-blocking version of <a>waitForProcess</a>. If the
--   process is still running, <tt>Nothing</tt> is returned. If the process
--   has exited, then <tt><a>Just</a> e</tt> is returned where <tt>e</tt>
--   is the exit code of the process.
--   
--   On Unix systems, see <a>waitForProcess</a> for the meaning of exit
--   codes when the process died as the result of a signal.
--   
--   <i>see <a>getProcessExitCode</a></i>.
getProcessExitCode :: ProcessHandle -> IO (Maybe ExitCode)

-- | Attempts to terminate the specified process. This function should not
--   be used under normal circumstances - no guarantees are given regarding
--   how cleanly the process is terminated. To check whether the process
--   has indeed terminated, use <a>getProcessExitCode</a>.
--   
--   On Unix systems, <a>terminateProcess</a> sends the process the SIGTERM
--   signal. On Windows systems, the Win32 <tt>TerminateProcess</tt>
--   function is called, passing an exit code of 1.
--   
--   Note: on Windows, if the process was a shell command created by
--   <a>createProcess</a> with <a>shell</a>, or created by
--   <tt>runCommand</tt> or <tt>runInteractiveCommand</tt>, then
--   <a>terminateProcess</a> will only terminate the shell, not the command
--   itself. On Unix systems, both processes are in a process group and
--   will be terminated together.
--   
--   <i>see 'System.Process.terminateProcess</i>.
terminateProcess :: ProcessHandle -> IO ()

-- | Sends an interrupt signal to the process group of the given process.
--   
--   On Unix systems, it sends the group the SIGINT signal.
--   
--   On Windows systems, it generates a CTRL_BREAK_EVENT and will only work
--   for processes created using <a>createProcess</a> and setting the
--   <tt>create_group</tt> flag
--   
--   <i>see 'System.Process.interruptProcessGroupOf</i>.
interruptProcessGroupOf :: ProcessHandle -> IO ()

-- | Create a pipe for interprocess communication and return a
--   <tt>(readEnd, writeEnd)</tt> <a>Handle</a> pair.
--   
--   <i>see <a>createPipe</a></i>.
createPipe :: IO (Handle, Handle)

module Sys.Exit

-- | Computation <a>exitWith</a> <tt>code</tt> throws <a>ExitCode</a>
--   <tt>code</tt>. Normally this terminates the program, returning
--   <tt>code</tt> to the program's caller.
--   
--   On program termination, the standard <tt>Handle</tt>s <tt>stdout</tt>
--   and <tt>stderr</tt> are flushed automatically; any other buffered
--   <tt>Handle</tt>s need to be flushed manually, otherwise the buffered
--   data will be discarded.
--   
--   A program that fails in any other way is treated as if it had called
--   <a>exitFailure</a>. A program that terminates successfully without
--   calling <a>exitWith</a> explicitly is treated as it it had called
--   <a>exitWith</a> <tt>ExitSuccess</tt>.
--   
--   As an <a>ExitCode</a> is not an <tt>IOError</tt>, <a>exitWith</a>
--   bypasses the error handling in the <a>IO</a> monad and cannot be
--   intercepted by <tt>catch</tt> from the <a>Prelude</a>. However it is a
--   <tt>SomeException</tt>, and can be caught using the functions of
--   <a>Control.Exception</a>. This means that cleanup computations added
--   with <a>bracket</a> (from <a>Control.Exception</a>) are also executed
--   properly on <a>exitWith</a>.
--   
--   Note: in GHC, <a>exitWith</a> should be called from the main program
--   thread in order to exit the process. When called from another thread,
--   <a>exitWith</a> will throw an <tt>ExitException</tt> as normal, but
--   the exception will not cause the process itself to exit.
--   
--   <i>see 'System.Exit.exitWith</i>.
exitWith :: ExitCode -> IO a
exitWithFailure :: NotZero Int -> IO a

-- | The computation <a>exitWithFailure1</a> is equivalent to
--   <a>exitWith</a> <tt>(</tt><tt>ExitFailure</tt>
--   <i>exitfail</i><tt>)</tt>, where <i>exitfail</i> is
--   implementation-dependent.
--   
--   <i>see 'System.Exit.exitWithFailure</i>.
exitWithFailure1 :: IO a

-- | The computation <a>exitWithSuccess</a> is equivalent to
--   <a>exitWith</a> <tt>ExitSuccess</tt>, It terminates the program
--   successfully.
--   
--   <i>see 'System.Exit.exitWithSuccess</i>.
exitWithSuccess :: IO a
type ExitCodeM f = NumberM Int f
exitCodeM :: f (Number Int) -> ExitCodeM f
createWaitProcessM :: CreateProcess -> ExitCodeM IO
createMakeWaitProcessM :: CreateProcess -> ExitCodeM IO
createWaitProcesses :: Foldable t => t CreateProcess -> ExitCodeM IO
createMakeWaitProcesses :: Foldable t => t CreateProcess -> ExitCodeM IO
exit :: ExitCodeM IO -> IO ()
createWaitProcessesExit :: Foldable t => t CreateProcess -> IO ()
createMakeWaitProcessesExit :: Foldable t => t CreateProcess -> IO ()
