-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Various number types
--   
--   Instances of the numerical classes for a variety of different numbers:
--   (computable) real numbers, arbitrary precision fixed numbers,
--   arbitrary precision floating point numbers, differentiable numbers,
--   symbolic numbers, natural numbers, interval arithmetic.
@package numbers
@version 3000.1.0.3


-- | Lazy natural numbers. Addition and multiplication recurses over the
--   first argument, i.e., <tt>1 + n</tt> is the way to write the constant
--   time successor function.
--   
--   Note that (+) and (*) are not commutative for lazy natural numbers
--   when considering bottom.
module Data.Number.Natural
data Natural

-- | The infinite natural number.
infinity :: Natural
instance Enum Natural
instance Real Natural
instance Integral Natural
instance Num Natural
instance Ord Natural
instance Eq Natural
instance Show Natural


-- | An incomplete implementation of interval aritrhmetic.
module Data.Number.Interval
data Interval a
ival :: Ord a => a -> a -> Interval a
getIval :: Interval a -> (a, a)
instance (Ord a, Fractional a) => Fractional (Interval a)
instance (Ord a, Num a) => Num (Interval a)
instance (Eq a, Show a) => Show (Interval a)
instance Ord a => Ord (Interval a)
instance Ord a => Eq (Interval a)


-- | Numbers with a fixed number of decimals.
module Data.Number.Fixed
data Fixed e

-- | The <a>Epsilon</a> class contains the types that can be used to
--   determine the precision of a <a>Fixed</a> number.
class Epsilon e

-- | An epsilon of 1, i.e., no decimals.
data Eps1

-- | A type construct that gives one more decimals than the argument.
data EpsDiv10 p

-- | Ten decimals.
data Prec10

-- | 50 decimals.
data Prec50
data PrecPlus20 e

-- | Convert between two arbitrary fixed precision types.
convertFixed :: (Epsilon e, Epsilon f) => Fixed e -> Fixed f
dynamicEps :: Rational -> (forall e. Epsilon e => Fixed e -> a) -> Rational -> a
precision :: Epsilon e => Fixed e -> Rational
instance Eq (Fixed e)
instance Ord (Fixed e)
instance Enum (Fixed e)
instance Epsilon e => Real (Fixed e)
instance Epsilon e => RealFrac (Fixed e)
instance Epsilon e => RealFloat (Fixed e)
instance Epsilon e => Floating (Fixed e)
instance Epsilon e => Read (Fixed e)
instance Epsilon e => Show (Fixed e)
instance Epsilon e => Fractional (Fixed e)
instance Epsilon e => Num (Fixed e)
instance Epsilon e => Epsilon (PrecPlus20 e)
instance Epsilon Prec500
instance Epsilon Prec50
instance Epsilon Prec10
instance Epsilon e => Epsilon (EpsDiv10 e)
instance Epsilon Eps1


-- | A simple implementation of floating point numbers with a selectable
--   precision. The number of digits in the mantissa is selected by the
--   <a>Epsilon</a> type class from the <a>Fixed</a> module.
--   
--   The numbers are stored in base 10.
module Data.Number.BigFloat

-- | Floating point number where the precision is determined by the type
--   <i>e</i>.
data BigFloat e

-- | The <a>Epsilon</a> class contains the types that can be used to
--   determine the precision of a <a>Fixed</a> number.
class Epsilon e

-- | An epsilon of 1, i.e., no decimals.
data Eps1

-- | A type construct that gives one more decimals than the argument.
data EpsDiv10 p

-- | Ten decimals.
data Prec10

-- | 50 decimals.
data Prec50
data PrecPlus20 e
instance Eq (BigFloat e)
instance Epsilon e => RealFloat (BigFloat e)
instance Epsilon e => Floating (BigFloat e)
instance Epsilon e => RealFrac (BigFloat e)
instance Epsilon e => Fractional (BigFloat e)
instance Epsilon e => Ord (BigFloat e)
instance Epsilon e => Real (BigFloat e)
instance Epsilon e => Num (BigFloat e)
instance Epsilon e => Show (BigFloat e)

module Data.Number.CReal

-- | The <a>CReal</a> type implements (constructive) real numbers.
--   
--   Note that the comparison operations on <a>CReal</a> may diverge since
--   it is (by necessity) impossible to implementent them correctly and
--   always terminating.
--   
--   This implementation is really David Lester's ERA package.
data CReal

-- | The <a>showCReal</a> function connverts a <a>CReal</a> to a
--   <a>String</a>.
showCReal :: Int -> CReal -> String
instance Show CReal
instance Read CReal
instance RealFloat CReal
instance RealFrac CReal
instance Real CReal
instance Enum CReal
instance Floating CReal
instance Fractional CReal
instance Num CReal
instance Ord CReal
instance Eq CReal


-- | The <a>Dif</a> module contains a data type, <a>Dif</a>, that allows
--   for automatic forward differentiation.
--   
--   All the ideas are from Jerzy Karczmarczuk's work, see
--   <a>http://users.info.unicaen.fr/~karczma/arpap/diffalg.pdf</a>.
--   
--   A simple example, if we define
--   
--   <pre>
--   foo x = x*x
--   </pre>
--   
--   then the function
--   
--   <pre>
--   foo' = deriv foo
--   </pre>
--   
--   will behave as if its body was 2*x.
module Data.Number.Dif

-- | The <a>Dif</a> type is the type of differentiable numbers. It's an
--   instance of all the usual numeric classes. The computed derivative of
--   a function is is correct except where the function is discontinuous,
--   at these points the derivative should be a Dirac pulse, but it isn't.
--   
--   The <a>Dif</a> numbers are printed with a trailing ~~ to indicate that
--   there is a "tail" of derivatives.
data Dif a

-- | The <a>val</a> function takes a <a>Dif</a> number back to a normal
--   number, thus forgetting about all the derivatives.
val :: Dif a -> a

-- | The <a>df</a> takes a <a>Dif</a> number and returns its first
--   derivative. The function can be iterated to to get higher derivaties.
df :: (Num a, Eq a) => Dif a -> Dif a

-- | The <a>mkDif</a> takes a value and <a>Dif</a> value and makes a
--   <a>Dif</a> number that has the given value as its normal value, and
--   the <a>Dif</a> number as its derivatives.
mkDif :: a -> Dif a -> Dif a

-- | The <a>dCon</a> function turns a normal number into a <a>Dif</a>
--   number with the same value. Not that numeric literals do not need an
--   explicit conversion due to the normal Haskell overloading of literals.
dCon :: Num a => a -> Dif a

-- | The <a>dVar</a> function turns a number into a variable number. This
--   is the number with with respect to which the derivaticve is computed.
dVar :: (Num a, Eq a) => a -> Dif a

-- | The <a>deriv</a> function is a simple utility to take the derivative
--   of a (single argument) function. It is simply defined as
--   
--   <pre>
--   deriv f = val . df . f . dVar
--   </pre>
deriv :: (Num a, Num b, Eq a, Eq b) => (Dif a -> Dif b) -> (a -> b)

-- | Convert a <a>Dif</a> function to an ordinary function.
unDif :: (Num a, Eq a) => (Dif a -> Dif b) -> (a -> b)
instance RealFloat a => RealFloat (Dif a)
instance RealFrac a => RealFrac (Dif a)
instance Real a => Real (Dif a)
instance (Floating a, Eq a) => Floating (Dif a)
instance (Fractional a, Eq a) => Fractional (Dif a)
instance (Num a, Eq a) => Num (Dif a)
instance Ord a => Ord (Dif a)
instance Eq a => Eq (Dif a)
instance Read a => Read (Dif a)
instance Show a => Show (Dif a)


-- | Symbolic number, i.e., these are not numbers at all, but just build a
--   representation of the expressions. This implementation is incomplete
--   in that it allows comnstruction, but not deconstruction of the
--   expressions. It's mainly useful for debugging.
module Data.Number.Symbolic

-- | Symbolic numbers over some base type for the literals.
data Sym a

-- | Create a variable.
var :: String -> Sym a

-- | Create a constant (useful when it is not a literal).
con :: a -> Sym a

-- | The expression <tt>subst x v e</tt> substitutes the expression
--   <tt>v</tt> for each occurence of the variable <tt>x</tt> in
--   <tt>e</tt>.
subst :: (Num a, Eq a) => String -> Sym a -> Sym a -> Sym a
unSym :: Show a => Sym a -> a
instance (RealFloat a, Show a) => RealFloat (Sym a)
instance (Floating a, Eq a) => Floating (Sym a)
instance RealFrac a => RealFrac (Sym a)
instance Real a => Real (Sym a)
instance Enum a => Enum (Sym a)
instance Integral a => Integral (Sym a)
instance (Fractional a, Eq a) => Fractional (Sym a)
instance (Num a, Eq a) => Num (Sym a)
instance Show a => Show (Sym a)
instance Ord a => Ord (Sym a)
instance Eq a => Eq (Sym a)
