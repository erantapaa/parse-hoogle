-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Heap profiling helper library
--   
--   This is the core library of the hp2any suite. It makes heap profiles
--   available during runtime through a simple interface, optionally
--   managing all the data in the background. It can also process archived
--   profiler output and present it in a structured form.
@package hp2any-core
@version 0.11.2


-- | This is a utility module to aid the construction of
--   <a>CreateProcess</a> structures with profiling parameters.
module Profiling.Heap.Process

-- | The possible types of parameters.
data ProfParam

-- | The type of breakdown.
PPBreakdown :: Breakdown -> ProfParam

-- | An additional filter on the runtime side.
PPRestriction :: Restriction -> [String] -> ProfParam

-- | Sampling interval in seconds.
PPInterval :: Float -> ProfParam

-- | Whether to include memory taken up by threads.
PPIncludeThreads :: ProfParam

-- | The maximum length of cost centre stack names.
PPNameLength :: Int -> ProfParam

-- | Retainer set size limit.
PPRetainerLimit :: Int -> ProfParam

-- | The possible types of breakdowns.
data Breakdown

-- | Breakdown by cost centre stack (origin of the data).
BCostCentreStack :: Breakdown

-- | Breakdown by module (code responsible for the data).
BModule :: Breakdown

-- | Breakdown by closure description (constructor name or some unique
--   identifier).
BDescription :: Breakdown

-- | Breakdown by type (or an approximation if it is not known exactly).
BType :: Breakdown

-- | Breakdown by retainer set (effectively the entities that hold a direct
--   reference to the data in question).
BRetainer :: Breakdown

-- | Breakdown by biography (phase of an object's lifetime).
BBiography :: Breakdown

-- | The possible filters. Note that these are imposed by the runtime, so
--   we cannot override them on the application side.
data Restriction

-- | Show only closures with one of the given names on the top of the cost
--   centre stack.
RCCStackTop :: Restriction

-- | Show only closures with one of the given names somewhere in the cost
--   centre stack.
RCCStackAny :: Restriction

-- | Show only closures produced by one of the given modules.
RModule :: Restriction

-- | Show only closures with a description that matches one of the given
--   names.
RDescription :: Restriction

-- | Show only closures with one of the given types.
RType :: Restriction

-- | Show only closures with retainer sets that contain at least one cost
--   centre stack with a given name on the top.
RRetainer :: Restriction

-- | Show only closures with one of the specified biographies, which must
--   come from the set {lag, drag, void, use}.
RBiography :: Restriction

-- | A helper function to create a <a>CreateProcess</a> structure.
processToProfile :: FilePath -> Maybe FilePath -> [String] -> [ProfParam] -> CreateProcess
instance Show Restriction
instance Show Breakdown
instance Show ProfParam


-- | This module defines the commonly used data structures and basic types
--   of the heap profiling framework.
--   
--   Profiling information is a sequence of time-stamped samples, therefore
--   the ideal data structure should have an efficient snoc operation.
--   Also, it should make it easy to extract an interval given by a start
--   and an end time. On top of the raw data, we also want to access some
--   statistics as efficiently as possible.
--   
--   We can separate two phases: looking at the profile during execution
--   and later. In the first case we might not want statistics, just live
--   monitoring, while we probably want to analyse archived profiles more
--   deeply. Therefore, it makes sense to define two separate data
--   structures for these two purposes, and give them a common interface
--   for extracting the necessary data. The simple case is covered by the
--   <a>Profile</a> type defined here, while a more complex structure
--   providing fast off-line queries is defined in the
--   <a>Profiling.Heap.Stats</a> module.
module Profiling.Heap.Types

-- | Cost centres are identified by integers for simplicity (so we can use
--   IntMap).
type CostCentreId = Int

-- | At this level cost centre names have no internal structure that we
--   would care about. While in some cases they reflect the call hierarchy,
--   we are not splitting them at this point, because all kinds of names
--   can appear here.
type CostCentreName = ByteString

-- | Time is measured in seconds.
type Time = Double

-- | Costs are measured in bytes.
type Cost = Int64

-- | A sampling point is simply a list of cost centres with the associated
--   cost. There is no need for a fancy data structure here, since we
--   normally process every value in this collection, and it's usually not
--   big either, only holding a few dozen entries at most.
type ProfileSample = [(CostCentreId, Cost)]

-- | A raw heap profile that's easy to grow further, therefore it is used
--   during loading.
data Profile
Profile :: ![(Time, ProfileSample)] -> !(IntMap CostCentreName) -> !(Trie CostCentreId) -> !String -> !String -> Profile

-- | Samples in decreasing time order (latest first).
prSamples :: Profile -> ![(Time, ProfileSample)]

-- | A map from cost centre ids to names.
prNames :: Profile -> !(IntMap CostCentreName)

-- | A map from cost centre names to ids.
prNamesInv :: Profile -> !(Trie CostCentreId)

-- | Information about the job (command line).
prJob :: Profile -> !String

-- | Job start time and date.
prDate :: Profile -> !String

-- | An initial <a>Profile</a> structure that can be used in accumulations.
emptyProfile :: Profile

-- | The <a>ProfileQuery</a> class contains all kinds of reading
--   operations. The minimal definition consists of <a>job</a>,
--   <a>date</a>, <a>ccNames</a> and <a>samples</a>. All the statistics
--   have default implementations, which are mostly okay for a single
--   query, but they are generally highly inefficient.
class ProfileQuery p where ccName p ccId = findWithDefault empty ccId (ccNames p) samplesIvl p t1 t2 = takeWhile ((< t2) . fst) $ dropWhile ((< t1) . fst) $ samples p minTime p | null smp = 0 | otherwise = fst (head smp) where smp = samples p maxTime p | null smp = 0 | otherwise = fst (last smp) where smp = samples p maxCost p = maximum $ 0 : [c | (_, s) <- samples p, (_, c) <- s] maxCostTotal p = maximum $ 0 : [sum (map snd s) | (_, s) <- samples p] maxCostIvl p t1 t2 = maximum $ 0 : [c | (_, s) <- samplesIvl p t1 t2, (_, c) <- s] maxCostTotalIvl p t1 t2 = maximum $ 0 : [sum (map snd s) | (_, s) <- samplesIvl p t1 t2] integral = integral' . samples integralIvl p t1 t2 = integral' (samplesIvl p t1 t2)
job :: ProfileQuery p => p -> String
date :: ProfileQuery p => p -> String
ccNames :: ProfileQuery p => p -> IntMap CostCentreName
ccName :: ProfileQuery p => p -> Int -> CostCentreName
samples :: ProfileQuery p => p -> [(Time, ProfileSample)]
samplesIvl :: ProfileQuery p => p -> Time -> Time -> [(Time, ProfileSample)]
minTime :: ProfileQuery p => p -> Time
maxTime :: ProfileQuery p => p -> Time
maxCost :: ProfileQuery p => p -> Cost
maxCostTotal :: ProfileQuery p => p -> Cost
maxCostIvl :: ProfileQuery p => p -> Time -> Time -> Cost
maxCostTotalIvl :: ProfileQuery p => p -> Time -> Time -> Cost
integral :: ProfileQuery p => p -> ProfileSample
integralIvl :: ProfileQuery p => p -> Time -> Time -> ProfileSample

-- | We might not want to hold on to all the past output, just do some
--   stream processing. We can achieve this using a callback function
--   that's invoked whenever a new profile sample is available. The type of
--   this function can be <a>ProfileSink</a>. Besides the actual costs, it
--   is also necessary to send over the names that belong to the short cost
--   centre identifiers as well as the fact that no more data will come.
--   The <a>SinkInput</a> type expresses these possibilities.
type ProfileSink = SinkInput -> IO ()
data SinkInput

-- | A snapshot of costs at a given time.
SinkSample :: !Time -> !ProfileSample -> SinkInput

-- | The name behind a cost centre id used in the samples.
SinkId :: !CostCentreId -> !CostCentreName -> SinkInput

-- | Indication that no more data will come.
SinkStop :: SinkInput
instance Eq Profile
instance Eq SinkInput
instance Show SinkInput
instance ProfileQuery Profile
instance Show Profile


-- | This module provides functions to send and receive profiling
--   information over the network. Currently the messages can only encode
--   <a>SinkInput</a> data.
module Profiling.Heap.Network
data Message
Stream :: SinkInput -> Message

-- | Send a structured message over the network. Can also be used for
--   logging into a file.
sendMsg :: Handle -> Message -> IO ()

-- | Receive a structured message over the network. Can also be used for
--   parsing from a file.
recvMsg :: Handle -> IO (Maybe Message)

-- | Parse a message.
readMsg :: String -> Maybe Message

-- | Serialise a message.
writeMsg :: Message -> String

-- | Convert from callback data to message.
putStream :: SinkInput -> Message

-- | Extract callback data from message, if applicable.
getStream :: Message -> Maybe SinkInput
instance Alternative MsgParser
instance Applicative MsgParser
instance Functor MsgParser
instance Show Message


-- | This module defines a heap profile data structure optimised for
--   querying various statistics, but not suitable for continuous updating.
module Profiling.Heap.Stats

-- | A data structure providing profile statistics at a low cost. It
--   accelerates interval extraction as well as determining maxima and
--   integrals over any subinterval: all of these operations take
--   logarithmic time to execute.
data ProfileWithStats

-- | Create extra data to speed up various queries.
buildStats :: Profile -> ProfileWithStats
instance ProfileQuery ProfileWithStats


-- | This module defines the functions that access heap profiles both
--   during and after execution.
module Profiling.Heap.Read

-- | The simplest case to handle is the traditional method of taking the
--   profiler output of an earlier run and turning it into an easy to query
--   structure. This is done by passing <a>readProfile</a> the log created
--   by the heap profiler (a file with .hp extension).
readProfile :: FilePath -> IO (Maybe Profile)

-- | If we want to observe the progress of loading, we can perform the
--   operation asynchronously. We need a query operation to check the
--   progress and extract the final result after the whole profile was
--   loaded. A <a>LoadProgress</a> computation tells us precisely that,
--   representing progress with a number between 0 and 1.
type LoadProgress = IO (Either Double Profile)

-- | A common stopping action that can be used to cancel asynchronous
--   loading as well as killing the reading thread during live profiling
--   without touching the slave process.
type ProfilingStop = IO ()

-- | Read a heap profile asynchronously. Since we might want to interrupt
--   the loading process if it proves to be too long, a stopper action is
--   also returned along with the progress query action. If the stopper
--   action is executed, the query function will return an empty profile as
--   a result.
readProfileAsync :: FilePath -> IO (LoadProgress, ProfilingStop)

-- | Since we want to possibly look at heap profiles during the run, we
--   might need an action that returns the data recorded so far.
type ProfileReader = IO Profile

-- | There are two basic ways of profiling: local and remote. Local
--   profiling means that we directly manage the process we are monitoring.
--   In the case of remote profiling we connect to a server that streams
--   profiling information and acts as a proxy between the process to
--   profile and our program. The type of profiling also determines the
--   kind of information available to us after initiating the process, so
--   we need generic labels to distinguish the alternatives.
data ProfilingType loc rem
Local :: loc -> ProfilingType loc rem
local :: ProfilingType loc rem -> loc
Remote :: rem -> ProfilingType loc rem
remote :: ProfilingType loc rem -> rem

-- | The input of the profiling functions. When we start profiling, we need
--   a process descriptor for the local case or a server address (of the
--   form "address:port") in the remote case. The creation of the process
--   descriptor is aided by the <a>Profiling.Heap.Process</a> module.
type ProfilingCommand = ProfilingType CreateProcess String

-- | The return value of the profiling functions. In the local case we are
--   given the handle of the process monitored. Asking for a remote profile
--   gives us a handle we can use to communicate with the proxy via the
--   common protocol defined in the <a>Profiling.Heap.Network</a> module.
type ProfilingInfo = ProfilingType ProcessHandle Handle

-- | In order to perform real-time profiling, we need to fire up the
--   program to analyse and create an accumulator in the background that we
--   can look at whenever we want using the reading action returned by the
--   function. We are also given a stopping action and the handle to the
--   slave process or network connection depending on the type of
--   profiling. If there is a problem, <a>Nothing</a> is returned.
profile :: ProfilingCommand -> IO (Maybe (ProfileReader, ProfilingStop, ProfilingInfo))

-- | The <a>profileCallback</a> function initiates an observation without
--   maintaining any internal data other than the name mapping, passing
--   profile samples to the callback (provided in the second argument) as
--   they come. It returns the handle of the new process or the remote
--   connection as well as the thread stopper action, assuming that a heap
--   profile could be found.
profileCallback :: ProfilingCommand -> ProfileSink -> IO (Maybe (ProfilingStop, ProfilingInfo))
