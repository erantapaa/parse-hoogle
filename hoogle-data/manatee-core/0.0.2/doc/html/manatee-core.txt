-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The core of Manatee.
--   
--   manatee-core is core package of Manatee (Haskell/Gtk+ Integrated Live
--   Environment) To provide basic communication protocol and toolkit.
@package manatee-core
@version 0.0.2

module Manatee.Toolkit.Gtk.Event

-- | Get keystroke value as a text.
eventKeystoke :: EventM EKey Text

-- | Get key char.
eventKeyChar :: EventM EKey (Maybe Char)

-- | Like <a>eventKeyName</a> just return Text.
eventKeyName' :: EventM EKey Text

-- | Like <a>eventKeyName</a> return key name, but return symbol when key
--   is corresponding Unicode character.
eventKeyName_ :: EventM EKey Text

-- | Modifier alias.
eventModifierAlias :: Modifier -> Text

-- | Event key name alias
eventKeyNameAlias :: String -> String

-- | Concat modifier list as alias.
eventModifierAliasList :: [Modifier] -> Text

-- | Modifier name map.
eventModifierMap :: Map Text Modifier

-- | Whether key is Unicode character.
isUnicodeKey :: EventM EKey Bool

-- | Get size of event window.
eventWindowSize :: EventM EExpose (Double, Double)

module Manatee.Toolkit.Gtk.DrawWindow

-- | Invalidate rectangle stroke.
drawWindowInvalidateRectStroke :: (DrawWindowClass self) => self -> Rectangle -> Int -> Bool -> IO ()

module Manatee.Toolkit.Gtk.Cairo

-- | Like <tt>Cairo.rectangle</tt>, but with round corner.
roundRectangle :: Double -> Double -> Double -> Double -> Double -> Render ()

-- | Convert from degree to radian.
degreeToRadian :: Double -> Double

-- | Like <tt>Cairo.arc</tt> except use degree as arguments.
arcDegree :: Double -> Double -> Double -> Double -> Double -> Render ()

module Manatee.Toolkit.Glib.GError

-- | Like <a>catchGError</a>, but easier to use.
catchGErrorM :: IO a -> IO a -> IO a

module Manatee.Toolkit.General.Url

-- | Encode url.
encodeUrl :: String -> String

module Manatee.Toolkit.General.Time

-- | Get local time.
getCurrentLocalTime :: IO LocalTime

-- | Different two time with second.
diffUTCTimeWithSecond :: UTCTime -> UTCTime -> Integer

-- | Different two time with millisecond.
diffUTCTimeWithMillisecond :: UTCTime -> UTCTime -> Integer

-- | Different two time with microsecond.
diffUTCTimeWithMicrosecond :: UTCTime -> UTCTime -> Integer

-- | Different two time with quantify.
diffUTCTimeWithQuantify :: UTCTime -> UTCTime -> NominalDiffTime -> Integer

-- | Convert GTimeVale to ClockTime.
gTimeValToClockTime :: GTimeVal -> ClockTime

-- | Get local time stamp with your format!
getTimeStamp :: String -> IO String

-- | Get diff time that seconds from 1970.
getSecondsTimeStamp :: Integer -> String -> IO String
instance Show GTimeVal

module Manatee.Toolkit.General.Seq

-- | Filter min.
filterMin :: (a -> Bool) -> Seq a -> Maybe a

-- | Maybe index.
maybeIndex :: Seq a -> Int -> Maybe a

-- | Insert element in sequence.
insertAt :: Int -> a -> Seq a -> Seq a

-- | Delete element in sequence.
deleteAt :: Int -> Seq a -> Seq a

-- | Swap two element in sequence.
swap :: Int -> Int -> Seq a -> Seq a

-- | Delete match element in sequence.
deleteMatch :: (a -> Bool) -> Seq a -> Seq a

-- | Replace element if found match.
tryReplace :: (a -> Bool) -> a -> Seq a -> Seq a

-- | Replace or add.
replaceOrAdd :: (a -> Bool) -> a -> Seq a -> Seq a

module Manatee.Toolkit.General.Process

-- | Like <a>runProcessDefault</a>, but wait for child process terminate.
--   To avoid *zombie* child process. You will got zombie child process
--   when child process exist before parent process, and parent process
--   don't wait process.
runProcess_ :: FilePath -> [String] -> IO ()

-- | Like <a>runProcess</a>, but just accept path and args.
runProcessDefault :: FilePath -> [String] -> IO ProcessHandle

-- | Like run <a>runCommand</a>, but return IO ()
runCommand_ :: String -> IO ()

-- | Run external command and won't kill when parent process exit.
runExternalCommand :: String -> IO ()

-- | Check command whether exist before exectue it. Return reason when not
--   found command.
execute :: String -> String -> Bool -> IO (Maybe String)

module Manatee.Toolkit.General.Functor
(<<<=) :: (Functor f) => (b -> c) -> (a -> f b) -> a -> f c
(=>>>) :: (Functor f) => (a -> f b) -> (b -> c) -> a -> f c
(<<=<) :: (Functor f) => (b -> f c) -> (a -> b) -> a -> f c
(>=>>) :: (Functor f) => (a -> b) -> (b -> f c) -> a -> f c

module Manatee.Toolkit.General.Either

-- | Map left.
mapLeft :: (t1 -> a) -> Either t1 t -> Either a t

-- | Map right.
mapRight :: (t1 -> b) -> Either t t1 -> Either t b

-- | Apply either left.
applyEitherLeft :: (a -> c) -> Either a b -> Maybe c

-- | Apply either right.
applyEitherRight :: (b -> c) -> Either a b -> Maybe c

module Manatee.Toolkit.General.Concurrent

-- | Build new thread do *forever*.
forkForever :: IO a -> IO ()

module Manatee.Toolkit.General.ByteString

-- | Like <tt>System.FilePath.combine</tt>, except for ByteString.
combine :: ByteString -> ByteString -> ByteString

-- | Is blank string.
isBlankByteString :: ByteString -> Bool

-- | Wraps a list of words to a list of lines of words of a particular
--   width.
wrapLine :: Int -> [ByteString] -> [[ByteString]]

-- | Like <a>words</a>, but just split with first space char, don't
--   truncates rest space char.
splitWords :: ByteString -> [ByteString]

module Manatee.Toolkit.GConf.GConf
data BackgroundOption
None :: BackgroundOption
Wallpaper :: BackgroundOption
Centered :: BackgroundOption
Scaled :: BackgroundOption
Stretched :: BackgroundOption
Zoom :: BackgroundOption
Spanned :: BackgroundOption

-- | Set background, just for gnome.
setDesktopBackground :: FilePath -> Int -> BackgroundOption -> IO ()
instance Show BackgroundOption
instance Ord BackgroundOption
instance Eq BackgroundOption
instance Read BackgroundOption

module Manatee.Toolkit.General.Set

-- | Find min element match in
maybeFindMin :: (Ord a) => Set a -> (a -> Bool) -> Maybe a

-- | maybeFindMinM.
maybeFindMinM :: (Ord a, Monad m) => Set a -> (a -> m Bool) -> m (Maybe a)

-- | filterM for Data.
filterM :: (Ord a, Monad m) => (a -> m Bool) -> Set a -> m (Set a)

-- | mapM for Data.Set
mapM :: (Ord a, Ord b, Monad m) => (a -> m b) -> Set a -> m (Set b)

-- | Next element
nextElement :: (Ord a) => Set a -> a -> Maybe a

-- | Prev element
prevElement :: (Ord a) => Set a -> a -> Maybe a

-- | Try find min element.
tryFindMin :: (Ord a) => Set a -> Maybe a

-- | Try find min element.
tryFindMax :: (Ord a) => Set a -> Maybe a

module Manatee.Toolkit.Data.SetList
data (Ord a) => SetList a
SetList :: Int -> Set a -> SetList a
listCounter :: SetList a -> Int
listSet :: SetList a -> Set a

-- | New SetList.
setListNew :: (Ord a) => SetList a

-- | Get counter for SetList.
setListGetCounter :: (Ord a) => SetList a -> Int

-- | Increase counter and then get new counter. Return new setList and new
--   id.
setListGetNewCounter :: (Ord a) => SetList a -> (Int, SetList a)

-- | Set counter.
setListSetCounter :: (Ord a) => SetList a -> Int -> SetList a

-- | Increase counter.
setListIncCounter :: (Ord a) => SetList a -> SetList a

-- | Add new node in SetList.
setListAddNode :: (Ord a) => SetList a -> a -> SetList a

-- | Remove node from SetList.
setListRemoveNode :: (Ord a) => SetList a -> a -> SetList a

-- | Remove others node except current one.
setListRemoveOthersNode :: (Ord a) => SetList a -> a -> SetList a

-- | Find some node and return.
setListGetNode :: (Ord a) => SetList a -> (a -> Bool) -> Maybe a

-- | Like <a>setListGetNode</a>, but use Monad wrap search condition.
setListGetNodeM :: (Ord a, Monad m) => SetList a -> (a -> m Bool) -> m (Maybe a)

-- | Empty List, but keep counter.
setListEmptySet :: (Ord a) => SetList a -> SetList a

-- | Convert from SetList to list.
setListGetList :: (Ord a) => SetList a -> [a]

module Manatee.Toolkit.Gtk.ScrolledWindow
data AdjustmentDirection
AdjustmentVertical :: AdjustmentDirection
AdjustmentHorizontal :: AdjustmentDirection

-- | Like <a>scrolledWindowNew</a>, except the scrollbar is present only if
--   needed.
scrolledWindowNew_ :: IO ScrolledWindow

-- | Scroll to begin vertically.
scrolledWindowScrollToLeft :: (ScrolledWindowClass sw) => sw -> IO ()
scrolledWindowScrollToTop :: (ScrolledWindowClass sw) => sw -> IO ()

-- | Scroll to end vertically.
scrolledWindowScrollToRight :: (ScrolledWindowClass sw) => sw -> IO ()
scrolledWindowScrollToBottom :: (ScrolledWindowClass sw) => sw -> IO ()

-- | Scroll page vertically.
scrolledWindowScrollHorizontalPage :: (ScrolledWindowClass sw) => Bool -> sw -> IO ()
scrolledWindowScrollVerticalPage :: (ScrolledWindowClass sw) => Bool -> sw -> IO ()
scrolledWindowScrollHorizontalStep :: (ScrolledWindowClass sw) => Bool -> sw -> IO ()
scrolledWindowScrollVerticalStep :: (ScrolledWindowClass sw) => Bool -> sw -> IO ()

-- | At top.
scrolledWindowIsAtLeft :: (ScrolledWindowClass sw) => sw -> IO Bool
scrolledWindowIsAtTop :: (ScrolledWindowClass sw) => sw -> IO Bool

-- | At bottom.
scrolledWindowIsAtRight :: (ScrolledWindowClass sw) => sw -> IO Bool
scrolledWindowIsAtBottom :: (ScrolledWindowClass sw) => sw -> IO Bool

-- | Get adjustment.
scrolledWindowGetAdjustment :: (ScrolledWindowClass sw) => sw -> AdjustmentDirection -> IO Adjustment

-- | Scroll to begin vertically.
scrolledWindowScrollToLower :: (ScrolledWindowClass sw) => AdjustmentDirection -> sw -> IO ()

-- | Scroll to end vertically.
scrolledWindowScrollToUpper :: (ScrolledWindowClass sw) => AdjustmentDirection -> sw -> IO ()

-- | Scroll page vertically.
scrolledWindowScrollPage :: (ScrolledWindowClass sw) => AdjustmentDirection -> Bool -> sw -> IO ()

-- | Scroll page vertically.
scrolledWindowScrollStep :: (ScrolledWindowClass sw) => AdjustmentDirection -> Bool -> sw -> IO ()

-- | At top.
scrolledWindowIsAtLower :: (ScrolledWindowClass sw) => AdjustmentDirection -> sw -> IO Bool

-- | At bottom.
scrolledWindowIsAtUpper :: (ScrolledWindowClass sw) => AdjustmentDirection -> sw -> IO Bool

module Manatee.Toolkit.General.String
searchForwardWord :: String -> (String, String)

-- | Like <a>searchForwardWord</a> except reverse ordering.
searchBackwardWord :: String -> (String, String)

-- | Whether string is blank.
isBlankString :: String -> Bool

-- | Convert string to int.
stringToInt :: Int -> String -> Int

-- | Convert a string of hexadecimal digits into an Int
hexStringToInt :: String -> Int

-- | Drop suffix.
dropSuffix :: [String] -> String -> String

-- | Strip and format.
stripFormat :: String -> Int -> String

-- | Unlines except last one.
unlinesExceptLast :: [String] -> String

module Manatee.Toolkit.General.Maybe

-- | Indicate error or return a. This function for replace <a>fromJust</a>,
--   expression `fromJust x` is bad when <tt>x</tt> is <a>Nothing</a>, so
--   <a>maybeError</a> allowed you customize error information.
maybeError :: Maybe a -> String -> a

-- | Maybe boolean.
maybeBool :: Maybe a -> Bool -> Bool

-- | Maybe alternative.
maybeAlternate :: Maybe a -> a -> a

-- | Maybe alternative monad.
maybeAlternateM :: (Monad m) => Maybe a -> m a -> m a

-- | Apply maybe.
maybeApply :: Maybe a -> (a -> b) -> Maybe b

-- | Apply maybe with monad.
maybeApplyM :: (Monad m) => Maybe a -> (a -> m b) -> m (Maybe b)

-- | Maybe transform monad.
(?>=>) :: (Monad m) => Maybe a -> (a -> m (Maybe b)) -> m (Maybe b)
(>?>=>) :: (Monad m) => m (Maybe a) -> (a -> m (Maybe b)) -> m (Maybe b)

-- | Maybe tranform ().
(?>=) :: (Monad m) => Maybe a -> (a -> m ()) -> m ()
(>?>=) :: (Monad m) => m (Maybe a) -> (a -> m ()) -> m ()

-- | Maybe branch.
maybeBranch :: (Monad m) => Maybe a -> (a -> m b) -> m b -> m b

-- | Maybe head.
maybeHead :: [a] -> Maybe a

module Manatee.Toolkit.General.Typeable

-- | Get type string of dynamic type.
dynTypeString :: Dynamic -> String

-- | Type String.
typeString :: (Typeable a) => a -> String

-- | Cast to Type with String.
castType :: (Typeable a) => String -> Maybe a

-- | Type of byte string.
typeByteString :: (Typeable a) => a -> ByteString

-- | Convert Type.
convertType :: (Typeable a, Typeable b) => a -> b

module Manatee.Toolkit.Gtk.Box

-- | Try to packing widget in box. If <tt>child</tt> have exist parent, do
--   nothing, otherwise, add <tt>child</tt> to <tt>parent</tt>.
boxTryPack :: (BoxClass parent, WidgetClass child) => parent -> child -> Packing -> Maybe Int -> Maybe Int -> IO ()

-- | Change box child Packing.
boxChangeChildPacking :: (BoxClass parent, WidgetClass child) => parent -> child -> Packing -> IO ()

module Manatee.Toolkit.General.Basic

-- | Swap tuple.
swap :: (a, b) -> (b, a)

-- | Try to swap tuple.
ifSwap :: Bool -> (a, a) -> (a, a)

-- | Duplicate current value with tuple.
dup :: a -> (a, a)

-- | Transform Int to Double
i2d :: (Integral a) => a -> Double

-- | Integer to Int.
integerToInt :: Integer -> Int

-- | Flip &gt;&gt;
(<<) :: (Monad m) => m b -> m a -> m b

-- | Like LiftM2, but make function at middle of two arguments.
liftM2' :: (Monad m) => m a -> (a -> b -> c) -> m b -> m c
liftM2_ :: (Monad m) => (a -> b -> c) -> m a -> m b -> m ()

-- | If monad.
ifM :: (Monad m) => m Bool -> m a -> m a -> m a

-- | If monad.
ifF :: (Monad m) => a -> (a -> m Bool) -> (a -> m b) -> (a -> m b) -> m b

-- | When monad.
whenM :: (Monad m) => m Bool -> m () -> m ()

-- | Unless monad.
unlessM :: (Monad m) => m Bool -> m () -> m ()

-- | Zip'
zip' :: a -> b -> (a, b)

-- | ZipM'
zipM' :: (Monad m) => m a -> m b -> m (a, b)

-- | FirstMap.
firstMap :: (b -> c) -> [(b, d)] -> [(c, d)]

-- | Zip with map.
zipMap :: (a -> b, a -> c) -> a -> (b, c)

-- | Unzip with map.
unzipMap :: (a -> (b, c)) -> (a -> b, a -> c)

-- | Trace.
trace :: ((a, c) -> (b, c)) -> a -> b

-- | Floor to multiple.
floorToMultiple :: (Integral a) => a -> a -> a

-- | Like a switch statement, and less cluttered than if else if
--   
--   <pre>
--   cond [ (t1,a1), (t2,a2), ... ]
--   </pre>
cond :: (Monad m) => [(Bool, m ())] -> m ()

-- | Like a switch statement, and less cluttered than if else if
--   
--   <pre>
--   condM [ (t1,a1), (t2,a2), ... ]
--   </pre>
condM :: (Monad m) => [(m Bool, m ())] -> m ()

module Manatee.Toolkit.General.STM

-- | Read an STM variable, apply some transformation function to it, and
--   write the transformed value back to the same variable.
modifyTVar :: TVar a -> (a -> a) -> STM ()

-- | The IO version of <a>modifyTVar</a>.
modifyTVarIO :: TVar a -> (a -> a) -> IO ()

-- | Replace TVar field.
replaceTVarField :: a -> a -> (a -> TVar b) -> IO ()

-- | The IO version of <a>modifyTVar</a>.
modifyTVarIOM :: TVar a -> (a -> IO a) -> IO ()

-- | The IO version of <a>writeTVar</a>.
writeTVarIO :: TVar a -> a -> IO ()

-- | Ticket TVar.
tickTVar :: TVar Int -> STM Int

-- | Like <a>tickTVar</a> but output with io monad.
tickTVarIO :: TVar Int -> IO Int

-- | Crock TVar.
crockTVar :: TVar Int -> STM Int

-- | Like <a>crockTVar</a> but output with io monad.
crockTVarIO :: TVar Int -> IO Int

-- | Query TVar with some function.
queryTVarIO :: TVar a -> (a -> b) -> IO b

-- | dupTChanIO
dupTChanIO :: TChan a -> IO (TChan a)

-- | readTChanIO
readTChanIO :: TChan a -> IO a

-- | writeTChanIO
writeTChanIO :: TChan a -> a -> IO ()

module Manatee.Toolkit.General.State

-- | Like <a>modify</a>, except use Monad wrap update function.
modifyM :: (Monad m, MonadTrans t, MonadState a (t m)) => (a -> m a) -> t m ()

-- | Like <a>modifyM</a>, but add two functions filter new state and return
--   value. This is handy when function return result including state.
--   Example, state is (a,b), and function return (a,b,c), then you can
--   write: <a>result &lt;- modifyM_ f fst snd</a>.
modifyM_ :: (Monad m, MonadTrans t, MonadState a1 (t m)) => (a1 -> m a) -> (a -> a1) -> (a -> a2) -> t m a2

-- | Like <a>modifyM_</a>, except don't return value.
modifyM' :: (Monad m, MonadTrans t, MonadState a1 (t m)) => (a1 -> m a) -> (a -> a1) -> t m ()

-- | Modify fst state of tuple.
modifyFst :: (MonadState (t, t1) m) => ((t, t1) -> t) -> m ()

-- | Modify snd state of tuple.
modifySnd :: (MonadState (t, t1) m) => ((t, t1) -> t1) -> m ()

-- | Like <a>modifyFst</a>, except use moand wrap function.
modifyFstM :: (Monad m, MonadTrans t1, MonadState (a, t) (t1 m)) => ((a, t) -> m a) -> t1 m ()

-- | Like <a>modifySnd</a>, except use moand wrap function.
modifySndM :: (Monad m, MonadTrans t1, MonadState (t, a) (t1 m)) => ((t, a) -> m a) -> t1 m ()

-- | Like <a>get</a>, except use Monad wrap function.
getM :: (MonadState a (t m), MonadTrans t, Monad m) => (a -> m a1) -> t m a1

-- | Like <a>runStateT</a>, just reverse arguments order.
runStateT_ :: b -> StateT b m a -> m (a, b)

-- | Like <a>runStateT_</a>, but just return last argument. It's useful
--   that you just want use runStateT wrap *one* state.
runStateT' :: (Functor f) => b -> StateT b f a -> f b

-- | Use runStateT' wrap TVar.
runTVarStateT :: TVar a -> (a -> StateT a IO b) -> IO ()

-- | Like <a>runTVarStateT</a>, but handle tuple TVar.
runTVarTupeStateT :: (TVar a, TVar b) -> (a -> b -> StateT (a, b) IO c) -> IO ()

module Manatee.Toolkit.Gtk.Concurrent
data ViewChannel a
ViewChannel :: TChan a -> TVar Bool -> ViewChannel a
viewChannel :: ViewChannel a -> TChan a
viewChannelLock :: ViewChannel a -> TVar Bool

-- | Fork GUI IO.
forkGuiIO :: IO a -> (a -> IO ()) -> IO (MVar a, ThreadId, ThreadId)

-- | Similar <a>forkGuiIO</a>, except return ()
forkGuiIO_ :: IO a -> (a -> IO ()) -> IO ()

-- | Post GUI Action to Gtk+ thread when catch signal.
onGuiSignal :: MVar a -> (a -> IO ()) -> IO ThreadId

-- | Create view channel. If widget destroy, stop read broadcast channel.
createViewChannel :: (WidgetClass widget) => TChan a -> widget -> IO (ViewChannel a)

-- | Listen view channel.
listenViewChannel :: ViewChannel a -> (a -> IO ()) -> IO ()

-- | Listen buffer channel.
listenBufferChannel :: TChan a -> (a -> IO ()) -> IO ()

module Manatee.Toolkit.Widget.Outputbar
data Outputbar
Outputbar :: Frame -> Label -> TVar (Maybe HandlerId) -> Outputbar
outputbarFrame :: Outputbar -> Frame
outputbarLabel :: Outputbar -> Label
outputbarHandlerId :: Outputbar -> TVar (Maybe HandlerId)

-- | Background color.
outputbarBackgroundColor :: Color

-- | Create outputbar.
outputbarNew :: IO Outputbar

-- | Show outputbar.
outputbarShow :: (BoxClass box) => box -> Outputbar -> String -> IO ()

module Manatee.Toolkit.General.List

-- | Return element of list with given index.
(?!) :: [a] -> Int -> Maybe a

-- | Intersect element with list from end, don't including front or middle
--   element. Return null if haven't intersection element.
intersectEnd :: (Ord a) => [a] -> [a] -> [a]

-- | Intersect element with list from front, don't including end or middle
--   element. Return null if haven't intersection element.
intersectFront :: (Ord a) => [a] -> [a] -> [a]

-- | Delay list with given start index.
delay :: Int -> [a] -> [Int]

-- | Index of list
listIndex :: [a] -> [Int]

-- | Pair with list index.
pairPred :: [a] -> [(a, Int)]

-- | Different two list, and two lists must have same length. otherwise
--   throw a error.
different :: (Ord a) => [a] -> [a] -> [a]

-- | Do action when list not empty.
unlessNull :: [a] -> IO () -> IO ()

-- | not . null
has :: [a] -> Bool

-- | Head monad list.
headM :: (Monad m) => m [a] -> m a

-- | Last monad list.
lastM :: (Monad m) => m [a] -> m a

-- | ConcatM.
concatM :: (Monad m) => m [a] -> m [a] -> m [a]

-- | Replace n'th element (count from 0) in <tt>xs</tt> to <tt>x</tt>
replaceAt :: Int -> [a] -> a -> [a]

-- | Split list with given condition.
splitWith :: (a -> Bool) -> [a] -> [[a]]

-- | concatMapM.
concatMapM :: (Monad m) => (a -> m [b]) -> [a] -> m [b]

-- | Like find, but works with monadic computation instead of pure
--   function. In expression `find FUNCTION list`, if FUNCTION is <a>IO
--   Bool</a>, you can use `findM FUNCTION list` to instead.
findM :: (Monad m) => (a -> m Bool) -> [a] -> m (Maybe a)

-- | Apply two monad function with list. And return new monad tuples list.
apply2M :: (Monad m) => [a] -> (a -> m b) -> (a -> m c) -> m [(b, c)]

-- | Apply two function with list. And return new tuples list.
apply2 :: [a] -> (a -> b) -> (a -> c) -> [(b, c)]

-- | Partition list.
partitionM :: (Monad m) => (a -> m Bool) -> [a] -> m ([a], [a])

-- | Like <a>init</a>, but accept empty list.
--   
--   Like <a>foldl1</a>, but accept empty list.
--   
--   Find next element.
findNext :: (a -> Bool) -> [a] -> Maybe a

-- | Find next cycle.
findNextCycle :: (a -> Bool) -> [a] -> Maybe a

-- | Find previous cycle.
findPrevCycle :: (a -> Bool) -> [a] -> Maybe a

-- | Delete at.
deleteAt :: Int -> [a] -> [a]

-- | Get last one.
getLast :: [a] -> Maybe a

-- | Get first one.
getFirst :: [a] -> Maybe a

-- | Zip with list index.
zipWithIndex :: [a] -> (a -> Int -> c) -> [c]

-- | Zip with list index.
zipWithIndexM :: (Monad m) => [a] -> (a -> Int -> m c) -> m [c]

-- | Zip with list index.
zipWithIndexM_ :: (Monad m) => [a] -> (a -> Int -> m c) -> m ()

-- | Like <a>concatMap</a>, but don't concat last one.
addMap :: ([a] -> [a]) -> [[a]] -> [a]

-- | Like <a>insert</a> but just insert unique element.
insertUnique :: (Ord a) => a -> [a] -> [a]

module Manatee.Toolkit.Data.ListZipper
data ListZipper a
ListZipper :: ![a] -> ![a] -> ListZipper a

-- | Create an empty ListZipper.
empty :: ListZipper a

-- | Create a ListZipper with a single element.
singleton :: a -> ListZipper a

-- | Create a ListZipper from list, and focus focus to first element in
--   list.
fromList :: [a] -> ListZipper a

-- | Create a ListZipper from list end, and focus focus to end element in
--   list.
fromListEnd :: [a] -> ListZipper a

-- | Convert ListZipper to List.
toList :: ListZipper a -> [a]

-- | Whether is first element.
atStart :: ListZipper a -> Bool

-- | Whether is last element.
atEnd :: ListZipper a -> Bool

-- | Whether is empty.
isEmpty :: ListZipper a -> Bool

-- | Get current node, return Nothing if haven't found anything at current
--   node. This function won't change current focus node.
getCurrent :: ListZipper a -> Maybe a

-- | Get left node, return Nothing if haven't found anything at left node.
--   This function won't change current focus node.
getLeft :: ListZipper a -> Maybe a

-- | Get right node, return Nothing if haven't found anything at right
--   node. This function won't change current focus node.
getRight :: ListZipper a -> Maybe a

-- | Get first node, return Nothing if haven't found anything at first
--   node. This function won't change current focus node.
getFirst :: ListZipper a -> Maybe a

-- | Get last node, return Nothing if haven't found anything at last node.
--   This function won't change current focus node.
getLast :: ListZipper a -> Maybe a

-- | Get left node, return Nothing if haven't found anything at left node.
--   If reach first node, circular to end node. This function won't change
--   current focus node.
getLeftCircular :: ListZipper a -> Maybe a

-- | Get right node, return Nothing if haven't found anything at right
--   node. If reach last node, circular to first node. This function won't
--   change current focus node.
getRightCircular :: ListZipper a -> Maybe a

-- | Get node with given index. This function won't change current focus
--   node.
get :: ListZipper a -> Int -> Maybe a

-- | Focus left node.
focusLeft :: ListZipper a -> Maybe (ListZipper a)

-- | Focus right node.
focusRight :: ListZipper a -> Maybe (ListZipper a)

-- | Focus first node.
focusFirst :: ListZipper a -> Maybe (ListZipper a)

-- | Focus last node.
focusLast :: ListZipper a -> Maybe (ListZipper a)

-- | Focus node with given index.
focus :: Int -> ListZipper a -> Maybe (ListZipper a)

-- | Focus node.
focusNode :: (Eq a) => a -> ListZipper a -> Maybe (ListZipper a)

-- | Insert node to right side and keep current focus.
insertLeft :: a -> ListZipper a -> ListZipper a

-- | Insert node to left side and keep current focus. Except it will focus
--   first element when list is empty.
insertRight :: a -> ListZipper a -> ListZipper a

-- | Insert node to first and keep current focus.
insertFirst :: a -> ListZipper a -> ListZipper a

-- | Insert node to last end and keep current focus.
insertLast :: a -> ListZipper a -> ListZipper a

-- | Delete current node and focus focus right node.
delete :: ListZipper a -> Maybe (ListZipper a)

-- | Delete left node and keep current focus.
deleteLeft :: ListZipper a -> Maybe (ListZipper a)

-- | Delete right node and keep current focus.
deleteRight :: ListZipper a -> Maybe (ListZipper a)

-- | Delete first node and keep current focus.
deleteFirst :: ListZipper a -> Maybe (ListZipper a)

-- | Delete last node and keep current focus.
deleteLast :: ListZipper a -> Maybe (ListZipper a)

-- | Delete other node except current node.
deleteOthers :: ListZipper a -> Maybe (ListZipper a)

-- | Delete specify node.
deleteNode :: (Eq a) => a -> ListZipper a -> Maybe (ListZipper a)

-- | Swap with left node, and focus swap node.
swapLeft :: ListZipper a -> Maybe (ListZipper a)

-- | Swap with right node, and focus swap node.
swapRight :: ListZipper a -> Maybe (ListZipper a)

-- | Replace current node.
replace :: a -> ListZipper a -> Maybe (ListZipper a)

-- | Get length.
length :: ListZipper a -> Int

-- | Get current index.
currentIndex :: ListZipper a -> Int

-- | Get left index.
leftIndex :: ListZipper a -> Int

-- | Get right index.
rightIndex :: ListZipper a -> Int

-- | Get first index.
firstIndex :: ListZipper a -> Int

-- | Get last index.
lastIndex :: ListZipper a -> Int
instance Functor ListZipper
instance (Show a) => Show (ListZipper a)

module Manatee.Toolkit.General.FilePath

-- | Intersect two file path from end.
fileIntersectEnd :: FilePath -> FilePath -> FilePath

-- | Get upper directory name.
getUpperDirectoryName :: FilePath -> FilePath

-- | Get upper directory path.
getUpperDirectory :: FilePath -> FilePath

-- | Try to expand file path that start with backtick. Just return original
--   one when file path not start with backtick.
expandBacktickFilePath :: FilePath -> IO FilePath

-- | Expand file name, including expand backtick and fill blank in
--   filepath.
expandFileName :: FilePath -> IO FilePath

-- | Expand file path.
expandFilePath :: FilePath -> IO FilePath

-- | Fill blank in filepath with `\ `.
fillFilePathBlank :: FilePath -> FilePath

-- | Filter dot directory.
filterDotDirectory :: [FilePath] -> [FilePath]

-- | Filter dot directory apply list.
filterDotDirectoryApply :: (a -> FilePath) -> [a] -> [a]

-- | File not directory.
notDotDirectory :: FilePath -> Bool

-- | Like takeFileName, but won't return empty when filepath is root path
--   <a>/</a> Instead return <a>/</a>.
takeFileNameExceptRoot :: FilePath -> FilePath

module Manatee.Toolkit.Gtk.Container

-- | Get first child.
containerGetFirstChild :: (ContainerClass self) => self -> IO (Maybe Widget)

-- | Get last child.
containerGetLastChild :: (ContainerClass self) => self -> IO (Maybe Widget)

-- | Remove all child of container.
containerRemoveAll :: (ContainerClass self) => self -> IO ()

-- | Try to remove child from parent.
containerTryRemove :: (ContainerClass parent, WidgetClass child) => parent -> child -> IO ()

-- | Apply container size and won't change widget's size.
containerApplySize :: (ContainerClass self) => self -> (Int -> Int -> IO ()) -> IO ()

-- | Whether has children.
containerHasChildren :: (ContainerClass self) => self -> IO Bool

module Manatee.Toolkit.Widget.PopupWindow
data PopupWindow
PopupWindow :: Window -> Frame -> PopupWindow
pwWindow :: PopupWindow -> Window
pwFrame :: PopupWindow -> Frame

-- | The default height of popup window.
popupWindowDefaultHeight :: Int

-- | Create popup window.
popupWindowNew :: IO PopupWindow

-- | Stick popup window with parent window. Note, the widget's toplevel
--   widget must be Window, otherwise this function with failed.
popupWindowStickParent :: (WidgetClass widget) => PopupWindow -> widget -> IO ()

-- | Set size and position.
popupWindowSetAllocation :: PopupWindow -> Rectangle -> IO ()

-- | Show popup window.
popupWindowShow :: PopupWindow -> IO ()

-- | Hide popup window.
popupWindowHide :: PopupWindow -> IO ()

-- | Add child.
popupWindowAdd :: (WidgetClass child) => PopupWindow -> child -> IO ()

-- | Remove children.
popupWindowRemove :: PopupWindow -> IO ()

-- | Is visible.
popupWindowIsVisible :: PopupWindow -> IO Bool

-- | Exit.
popupWindowExit :: PopupWindow -> IO ()

module Manatee.Toolkit.Gtk.Editable
type EditableContent = String
type EditableBound = (Int, Int)
type EditableStatus = (EditableContent, EditableBound)

-- | Focus editable and keep status.
editableFocus :: (EditableClass self) => self -> IO ()

-- | Get unselect text.
editableGetUnselectText :: (EditableClass self) => self -> IO String

-- | Select from current position to end.
editableSelectToEnd :: (EditableClass self) => self -> Int -> IO ()

-- | Get all text.
editableGetAllText :: (EditableClass self) => self -> IO String

-- | Set text.
editableSetText :: (EditableClass self) => self -> String -> IO ()

-- | Set completion text.
editableSetCompletionText :: (EditableClass self) => self -> String -> String -> IO ()

-- | Set bound.
editableSetBound :: (EditableClass self) => self -> (Int, Int) -> IO ()

-- | Get status.
editableGetStatus :: (EditableClass self) => self -> IO EditableStatus

-- | Set status.
editableSetStatus :: (EditableClass self) => self -> EditableStatus -> IO ()

-- | Delete all text.
editableDeleteAllText :: (EditableClass self) => self -> IO ()

-- | Expand completion.
editableExpandCompletion :: (EditableClass self) => self -> IO ()

-- | Delete backward char.
editableDeleteBackwardChar :: (EditableClass self) => self -> IO ()

-- | Delete backward word.
editableDeleteBackwardWord :: (EditableClass self) => self -> IO ()

-- | Backward char.
editableBackwardChar :: (EditableClass self) => self -> IO ()

-- | Whether changed after do editable action?
editableIsChanged :: (EditableClass self) => self -> IO () -> IO Bool

module Manatee.Toolkit.Widget.Statusbar
type StatusbarSubitem = Statusbar
type StatusbarInfoTable = Seq (String, String)
data Statusbar
Statusbar :: HBox -> StatusbarSubitem -> TVar StatusbarInfoTable -> ProgressBar -> Statusbar
statusbarBox :: Statusbar -> HBox
statusbarInfoSubitem :: Statusbar -> StatusbarSubitem
statusbarInfoTable :: Statusbar -> TVar StatusbarInfoTable
statusbarProgressBar :: Statusbar -> ProgressBar

-- | Create new statusbar.
statusbarNew :: (BoxClass b) => b -> IO Statusbar

-- | Clone statusbar.
statusbarClone :: (BoxClass b) => b -> Statusbar -> IO Statusbar

-- | Get info table.
statusbarGetInfoTable :: Statusbar -> IO StatusbarInfoTable

-- | Create new sub-statusbar.
statusbarSubitemNew :: (BoxClass b) => b -> IO StatusbarSubitem

-- | Update info status.
statusbarInfoSubitemSetText :: Statusbar -> String -> IO ()

-- | Set text internal.
statusbarSubitemSetText :: StatusbarSubitem -> String -> IO ()

-- | Add new info item to info subitem.
statusbarInfoItemAdd :: Statusbar -> String -> String -> IO ()

-- | Update info item.
statusbarInfoItemUpdate :: Statusbar -> String -> String -> IO ()

-- | Remove info item from info subitem.
statusbarInfoItemRemove :: Statusbar -> String -> IO ()

-- | Apply info table.
statusbarApplyInfoTable :: Statusbar -> (StatusbarInfoTable -> StatusbarInfoTable) -> IO ()

-- | Update info item subitem information.
statusbarInfoSubitemUpdate :: Statusbar -> IO ()

-- | Update progress status.
statusbarProgressUpdate :: Statusbar -> Double -> IO ()

module Manatee.Toolkit.Data.Unique

-- | Unique file path list.
unique :: [FilePath] -> [(FilePath, FilePath)]

-- | Different file path.
uniqueDiff :: [(FilePath, Int)] -> [(FilePath, Int)]

-- | Internal function for different file path.
uniqueDiffInternal :: [(FilePath, Int)] -> [(FilePath, Int)]

-- | Get min diff directory.
uniqueMinDiffDir :: FilePath -> FilePath -> FilePath

-- | Group file path with same file name.
uniqueGroup :: [(FilePath, Int)] -> ([(FilePath, Int)] -> [(FilePath, Int)]) -> [[(FilePath, Int)]]

-- | Pick same file name from list.
uniquePick :: [(FilePath, Int)] -> [(FilePath, Int)]

-- | Pick same path part from list.
uniquePick_ :: [(FilePath, Int)] -> [(FilePath, Int)]

-- | Get common path with all file path.
uniqueCommon :: [FilePath] -> FilePath

module Manatee.Toolkit.General.Arrow

-- | Arrow with delicate.
dupA :: (Arrow a) => a b (b, b)

-- | Arrow with curry.
curryA :: (Arrow a) => a ((b, c) -> d) (b -> c -> d)

-- | Arrow with uncurry.
uncurryA :: (Arrow a) => a (b -> c -> d) ((b, c) -> d)

-- | Arrow with swap.
swapA :: (Arrow a) => a (b, c) (c, b)

-- | Arrow with liftM2.
liftA2 :: (Arrow a) => (b -> c -> d) -> a e b -> a e c -> a e d

-- | Arrow with id.
idA :: (Arrow a) => a b b

-- | Fst with arrow.
fstA :: (Arrow a) => a (b, c) b

-- | Snd with arrow.
sndA :: (Arrow a) => a (b, c) c

module Manatee.Toolkit.Gtk.Gtk

-- | Get source language along with file name.
sourceLanguageForFilename :: SourceLanguageManager -> Maybe String -> IO (Maybe String, Maybe SourceLanguage)

-- | Add window with special window group.
windowNewWithWindowGroup :: WindowGroup -> IO Window

-- | Get x coordinate of Rectangle.
rectangleX :: Rectangle -> Int

-- | Get y coordinate of Rectangle.
rectangleY :: Rectangle -> Int

-- | Get width of Rectangle.
rectangleW :: Rectangle -> Int

-- | Get height of Rectangle.
rectangleH :: Rectangle -> Int

-- | This function like <a>socketNew</a>, but call <a>widgetShow</a> when
--   create. Because Gtk+ said must show GtkScoekt before add to container.
socketNew_ :: IO Socket

-- | Window is full-screen. Notes, just call this function when you have
--   realized window.
windowIsFullscreen :: Window -> IO Bool

-- | Frame new with shadow type.
frameNewWithShadowType :: Maybe ShadowType -> IO Frame

-- | Redraw rectangle frame.
widgetRedrawRectangleFrame :: (WidgetClass self) => self -> Int -> Int -> Int -> Int -> Int -> IO ()

-- | Whether the widget has parent.
widgetHasParent :: (WidgetClass widget) => widget -> IO Bool

-- | Propagate event on specify widget.
widgetPropagateEvent :: (WidgetClass widget) => widget -> SerializedEvent -> IO ()

-- | Get screen size.
widgetGetScreenSize :: (WidgetClass widget) => widget -> IO (Int, Int)

-- | Create image widget with given icon name and size.
imageNewFromIcon :: String -> Int -> IO Image

-- | Set position of paned.
panedAdjustSize :: (PanedClass self) => self -> Int -> IO ()

-- | Convert Color to RGB value.
colorToRGB :: Color -> (Double, Double, Double)

module Manatee.Toolkit.Widget.NotebookTab
data NotebookTab
NotebookTab :: HBox -> Spinner -> Label -> ToolButton -> Int -> NotebookTab
ntBox :: NotebookTab -> HBox
ntSpinner :: NotebookTab -> Spinner
ntLabel :: NotebookTab -> Label
ntCloseButton :: NotebookTab -> ToolButton
ntSize :: NotebookTab -> Int

-- | Default size.
notebookTabDefaultSize :: Int

-- | Create notebook tab.
notebookTabNew :: Maybe String -> Maybe Int -> IO NotebookTab

-- | Set tab name.
notebookTabSetName :: NotebookTab -> String -> IO ()

-- | Start spinner animation.
notebookTabStart :: NotebookTab -> IO ()

-- | Stop spinner animation.
notebookTabStop :: NotebookTab -> IO ()

module Manatee.Toolkit.Widget.Tooltip
data Tooltip
Tooltip :: Int -> Window -> Window -> Label -> Int -> Bool -> ConnectId Window -> ConnectId Window -> Tooltip
tooltipId :: Tooltip -> Int
tooltipWindow :: Tooltip -> Window
tooltipDependWindow :: Tooltip -> Window
tooltipLabel :: Tooltip -> Label
tooltipTimeout :: Tooltip -> Int
tooltipHideWhenPress :: Tooltip -> Bool
tooltipFocusInConnectId :: Tooltip -> ConnectId Window
tooltipFocusOutConnectId :: Tooltip -> ConnectId Window

-- | Align size.
tooltipAlignSize :: Int

-- | Default foreground color.
tooltipDefaultForegroundColor :: Color

-- | Default background color.
tooltipDefaultBackgroundColor :: Color

-- | New tooltip.
tooltipNew :: Int -> Window -> String -> Maybe Point -> Int -> Maybe Color -> Maybe Color -> Bool -> TVar (Set Tooltip) -> IO Tooltip

-- | Exit tooltip.
tooltipExit :: Tooltip -> TVar (Set Tooltip) -> IO ()
instance Ord Tooltip
instance Eq Tooltip

module Manatee.Toolkit.Gtk.ModelView

-- | Focus first toplevel node. It focus first node if model is list model.
treeViewFocusFirstToplevelNode :: (TreeViewClass view) => view -> IO ()

-- | Focus last toplevel node. It focus last node if model is list model.
treeViewFocusLastToplevelNode :: (TreeViewClass view) => view -> IO ()

-- | Get number of toplevel node in TreeView.
treeViewGetToplevelNodeCount :: (TreeViewClass view) => view -> IO Int

-- | Get number of toplevel node in TreeModel.
treeModelGetToplevelNodeCount :: (TreeModelClass model) => model -> IO Int

-- | Apply treeView model.
treeViewApplyModel :: (TreeViewClass view) => view -> (TreeModel -> IO ()) -> IO ()

-- | Get current selection. Don't *store* TreeIter, it's wrong value after
--   model change. It's should just as a argument for another IO function.
treeViewGetSelectedPath :: (TreeViewClass view) => view -> IO (Maybe TreePath)

-- | Get tree coordinate of cell.
treeViewGetCellTreeCoordinate :: (TreeViewClass view) => view -> Maybe TreePath -> TreeViewColumn -> IO Rectangle

-- | Get selection bound.
treeViewGetSelectedTreeCoordidnate :: (TreeViewClass view) => view -> IO (Maybe Rectangle)

-- | Get selection widget coordinate.
treeViewGetSelectedWidgetCoordinate :: (TreeViewClass view) => view -> IO (Maybe Rectangle)

-- | Focus next toplevel node.
treeViewFocusNextToplevelNode :: (TreeViewClass view) => view -> IO ()

-- | Focus prev toplevel node. Return True if focus prev toplevel node,
--   Otherwise return False.
treeViewFocusPrevToplevelNode :: (TreeViewClass view) => view -> IO ()

-- | Last toplevel node path of TreeModel.
treeModelLastToplevelPath :: (TreeModelClass model) => model -> IO TreePath

-- | Whether at first toplevel node? It at first node if model is list
--   model.
treeViewAtFirstToplevelNode :: (TreeViewClass view) => view -> IO Bool

-- | Whether at last toplevel node? It at last node if model is list model.
treeViewAtLastToplevelNode :: (TreeViewClass view) => view -> IO Bool

-- | Remove all column's from treeView.
treeViewRemoveColumns :: (TreeViewClass self) => self -> IO ()

-- | Have cell columns.
treeViewHaveColumn :: (TreeViewClass self) => self -> IO Bool

-- | Un-select all.
treeViewUnselectAll :: (TreeViewClass view) => view -> IO ()

-- | Get default cell height.
treeViewGetDefaultCellHeight :: (TreeViewClass view) => view -> IO (Maybe Int)

-- | Get attribute of cursor cell.
treeViewGetSelectedCellArea :: (TreeViewClass self) => (Rectangle -> Int) -> self -> IO Int

-- | Get current cell height.
treeViewGetSelectedCellHeight :: (TreeViewClass view) => view -> IO Int

-- | Get current cell height.
treeViewGetSelectedCellY :: (TreeViewClass view) => view -> IO Int

-- | Get header height.
treeViewGetHeaderHeight :: (TreeViewClass self) => self -> IO Int

-- | Focus TreeView and keep current selected position.
treeViewFocus :: (TreeViewClass self) => self -> IO ()

-- | Scroll vertical.
treeViewScrollVertical :: (TreeViewClass self, ScrolledWindowClass swc) => self -> swc -> Double -> IO ()
treeViewAddColumnWithTitle :: (TreeViewClass self) => self -> String -> SortColumnId -> IO TreeViewColumn

-- | Get row.
treeModelSortGetRow :: (TreeModelSortClass self, TypedTreeModelClass model) => model row -> self -> TreeIter -> IO row

-- | Get next sort path. Pass unsorted path to get next path in the given
--   sorted model. Very useful to track path after change sort rule.
treeViewNextSortPath :: (TreeViewClass view, TreeModelClass sortModel, TreeModelSortClass sortModel) => view -> sortModel -> TreePath -> IO TreePath

-- | Get previous sort path. Pass unsorted path to get previous path in the
--   given sorted model. Very useful to track path after change sort rule.
treeViewPrevSortPath :: (TreeViewClass view, TreeModelClass sortModel, TreeModelSortClass sortModel) => view -> sortModel -> TreePath -> IO TreePath

-- | Get current value.
treeViewGetSelectedValue :: (TreeViewClass view, TreeModelSortClass self) => view -> self -> ListStore a -> IO (Maybe a)

module Manatee.Toolkit.Gtk.Multiline

-- | Wrap user action. Then user can undo/redo this action.
textBufferWrapAction :: (TextBufferClass self) => self -> IO () -> IO ()

-- | Get text with given text tag.
textBufferGetTagTextWithIter :: (TextBufferClass buffer) => buffer -> TextIter -> TextTag -> IO (Maybe String)

-- | Get insert text with given text tag.
textBufferGetTagText :: (TextBufferClass buffer) => buffer -> TextTag -> IO (Maybe String)

-- | Get bytestring with give text tag.
textBufferGetTagByteStringWithIter :: (TextBufferClass buffer) => buffer -> TextIter -> TextTag -> IO (Maybe ByteString)

-- | Get insert text with given text tag.
textBufferGetTagByteString :: (TextBufferClass buffer) => buffer -> TextTag -> IO (Maybe ByteString)

-- | Text buffer keep selection to execute action.
textBufferKeepSelection :: (TextBufferClass self) => self -> Bool -> Bool -> IO () -> IO ()

-- | Move text, tags, and pixbufs between start and end (the order of start
--   and end doesn't matter) to iter.
textBufferMoveRange :: (TextBufferClass self) => self -> TextIter -> TextIter -> TextIter -> IO ()

-- | Cancel selection.
textBufferCancelSelection :: (TextBufferClass self) => self -> IO ()

-- | Get text iter at cursor.
textBufferGetInsertIter :: (TextBufferClass self) => self -> IO TextIter

-- | Create an iterator at start position of special line.
textBufferGetLineStartIter :: (TextBufferClass self) => self -> Int -> IO TextIter

-- | Create an iterator at start position of current line.
textBufferGetCurrentLineStartIter :: (TextBufferClass self) => self -> IO TextIter

-- | Create an iterator line delimiter characters, If incLimitincDelimiter
--   is True which will be either a newline, a carriage return, a carriage
--   return/newline in sequence. Otherwise, not include delimiter
--   characters.
textBufferGetLineEndIter :: (TextBufferClass self) => self -> Int -> Bool -> IO TextIter

-- | Create an iterator line delimiter characters, which will be either a
--   newline, a carriage return, a carriage return/newline in sequence.
textBufferGetCurrentLineEndIter :: (TextBufferClass self) => self -> IO TextIter

-- | Create an iterator line delimiter characters,
textBufferGetCurrentLineEndIter_ :: (TextBufferClass self) => self -> IO TextIter

-- | Get line from text buffer.
textBufferGetLine :: (TextBufferClass self) => self -> IO Int

-- | Get line offset from text buffer.
textBufferGetLineOffset :: (TextBufferClass self) => self -> IO Int
textBufferSelectionIter :: Attr TextBuffer (Maybe TextIter)

-- | Set text buffer selection iter.
textBufferSetSelectionIter :: (TextBufferClass self) => self -> TextIter -> IO ()

-- | Remove text buffer selection iter.
textBufferRemoveSelectionIter :: (TextBufferClass self) => self -> IO ()

-- | Get text buffer selection iter.
textBufferGetSelectionIter :: (TextBufferClass self) => self -> IO (Maybe TextIter)

-- | Update selection iter after buffer changed. If selection active, just
--   update SelectionIter, otherwise set Nothing.
textBufferUpdateSelectionIter :: (TextBufferClass self) => self -> IO ()

-- | Get selection bound line.
textBufferGetSelectionBoundLines :: (TextBufferClass self) => self -> IO (TextIter, TextIter, Bool, Bool)

-- | Get bound iter of selection region.
textBufferGetSelectionBoundIter :: (TextBufferClass self) => self -> IO TextIter

-- | Get insert iter of selection region.
textBufferGetSelectionInsertIter :: (TextBufferClass self) => self -> IO TextIter

-- | Is equal current InsertIter?
textBufferIsEqualInsertIter :: (TextBufferClass self) => self -> TextIter -> IO Bool

-- | Delete last char.
textBufferDeleteLastChar :: (TextBufferClass self) => self -> IO ()

-- | Text buffer newline at mark.
textBufferInsertNewlineAtMark :: (TextBufferClass self) => self -> TextMark -> IO ()

-- | Text buffer insert at mark.
textBufferInsertAtMark :: (TextBufferClass self) => self -> TextMark -> String -> IO ()

-- | Text view place cursor. Move insert to iter, then scroll text view to
--   visible area of widget.
textViewPlaceCursor :: (TextViewClass self) => self -> TextIter -> IO ()

-- | Place cursor with mark.
textViewPlaceCursorWithMark :: (TextViewClass self) => self -> TextMark -> IO ()

-- | Goto line. If line number not in buffer bound, goto min/max line.
textViewGotoLine :: (TextViewClass self) => self -> Int -> IO ()

-- | Goto column. If column number not in buffer bound, goto start/end of
--   line.
textViewGotoColumn :: (TextViewClass self) => self -> Int -> IO ()

-- | Text view wrap user action.
textViewWrapAction :: (TextViewClass self) => self -> IO () -> IO ()

-- | Text View load file.
textViewLoadFile :: (TextViewClass self) => self -> FilePath -> IO ()

-- | Set text.
textViewSetText :: (TextViewClass self) => self -> String -> IO ()

-- | Get text iter from text view.
textViewGetTextIter :: (TextViewClass self) => self -> IO TextIter

-- | Move text iter
textViewMoveTextIter :: (TextViewClass self, ScrolledWindowClass swc) => (TextIter -> IO Bool) -> self -> swc -> IO ()

-- | Forward line.
textViewForwardLine :: (TextViewClass self, ScrolledWindowClass swc) => self -> swc -> IO ()

-- | Backward line.
textViewBackwardLine :: (TextViewClass self, ScrolledWindowClass swc) => self -> swc -> IO ()

-- | Forward char.
textViewForwardChar :: (TextViewClass self, ScrolledWindowClass swc) => self -> swc -> IO ()

-- | Backward char.
textViewBackwardChar :: (TextViewClass self, ScrolledWindowClass swc) => self -> swc -> IO ()

-- | Forward word.
textViewForwardWord :: (TextViewClass self, ScrolledWindowClass swc) => self -> swc -> IO ()

-- | Backward word.
textViewBackwardWord :: (TextViewClass self, ScrolledWindowClass swc) => self -> swc -> IO ()

-- | Move to buffer beginning.
textViewBegin :: (TextViewClass self, ScrolledWindowClass swc) => self -> swc -> IO ()

-- | Move to buffer end.
textViewEnd :: (TextViewClass self, ScrolledWindowClass swc) => self -> swc -> IO ()

-- | Get text.
textViewGetText :: (TextViewClass self) => self -> IO String

-- | Get current line.
textViewGetCurrentLineContent :: (TextViewClass self) => self -> IO String

-- | Get current line number.
textViewGetLine :: (TextViewClass self) => self -> IO Int

-- | Get current column number
textViewGetColumn :: (TextViewClass self) => self -> IO Int

-- | Select all.
textViewSelectAll :: (TextViewClass self) => self -> IO ()

-- | Delete.
textViewDelete :: (TextViewClass self) => self -> Bool -> Bool -> IO Bool

-- | Cut.
textViewCut :: (TextViewClass self) => self -> IO ()

-- | Copy.
textViewCopy :: (TextViewClass self) => self -> IO ()

-- | Paste.
textViewPaste :: (TextViewClass self) => self -> IO ()

-- | Delete forward char.
textViewDeleteForwardChar :: (TextViewClass self) => self -> Bool -> IO Bool

-- | Delete backward char.
textViewDeleteBackwardChar :: (TextViewClass self) => self -> Bool -> IO Bool

-- | Delete forward word.
textViewDeleteForwardWord :: (TextViewClass self) => self -> Bool -> IO Bool

-- | Delete backward word.
textViewDeleteBackwardWord :: (TextViewClass self) => self -> Bool -> IO Bool

-- | Delete to line end.
textViewDeleteToLineEnd :: (TextViewClass self) => self -> Bool -> IO Bool

-- | Delete to line start.
textViewDeleteToLineStart :: (TextViewClass self) => self -> Bool -> IO Bool

-- | Delete bound.
textViewDeleteBound :: (TextViewClass self) => self -> (TextIter -> IO Bool) -> Bool -> IO Bool

-- | Duplicate lines. Just duplicate current line to below if haven't
--   selection anything. Otherwise duplicate selection lines to below.
textViewDupLines :: (TextViewClass self) => self -> Bool -> IO ()
textViewDupLinesAbove :: (TextViewClass self) => self -> IO ()
textViewDupLinesBelow :: (TextViewClass self) => self -> IO ()

-- | Transposes lines. Just transposes current line to below if haven't
--   selection anything. Otherwise transposes selection lines to below.
textViewTraLines :: (TextViewClass self) => self -> Bool -> IO ()
textViewTraLinesAbove :: (TextViewClass self) => self -> IO ()
textViewTraLinesBelow :: (TextViewClass self) => self -> IO ()

-- | Delete lines. Just delete current line to below if haven't selection
--   anything. Otherwise delete selection lines to below. Return
--   <a>False</a> if in uneditable area.
textViewDelLines :: (TextViewClass self) => self -> IO Bool

-- | Smart home.
textViewSmartHome :: (TextViewClass self) => self -> IO ()

-- | Smart end.
textViewSmartEnd :: (TextViewClass self) => self -> IO ()

-- | Scroll vertical.
textViewScrollVertical :: (TextViewClass tvc, ScrolledWindowClass swc) => tvc -> swc -> Double -> IO ()

-- | Toggle selection.
textViewToggleSelectionMark :: (TextViewClass self) => self -> IO ()

-- | Exchange selection mark.
textViewExchangeSelectionMark :: (TextViewClass self) => self -> IO ()

-- | Scroll text view the minimum distance such that cursor is contained
--   within the visible area of widget.
textViewScrollCursorOnscreen :: (TextViewClass self) => self -> IO ()

-- | Set selection.
textViewSetSelectionMark :: (TextViewClass self) => self -> IO ()

-- | Cancel selection.
textViewCancelSelectionMark :: (TextViewClass self) => self -> IO ()

-- | Apply selection.
textViewApplySelectionMark :: (TextViewClass self) => self -> IO ()

-- | Text view newline.
textViewNewLine :: (TextViewClass self) => self -> IO ()

-- | Insert string at cursor.
textViewInsertAtCursor :: (TextViewClass self) => self -> String -> IO ()

-- | Move to next line and then opens a line.
textViewOpenNewlineBelow :: (TextViewClass self, ScrolledWindowClass swc) => self -> swc -> IO ()

-- | Move to previous line and then opens a line.
textViewOpenNewlineAbove :: (TextViewClass self, ScrolledWindowClass swc) => self -> swc -> IO ()

-- | Move to `first iter` of buffer.
textIterBackwardToStart :: TextIter -> IO ()

-- | Forward to line end, like textIterForwardToLineEnd, but don't move to
--   next line when current line is empty.
textIterForwardToLineEnd_ :: TextIter -> IO ()

-- | In blank line.
textIterInBlankLine :: TextIter -> IO Bool

-- | Is first line.
textIterIsFirstLine :: TextIter -> IO Bool

-- | Is last line.
textIterIsLastLine :: TextIter -> IO Bool

-- | Backward to line start.
textIterBackwardToLineStart :: TextIter -> IO ()

-- | Return number of characters in this line. The return value not
--   includes delimiters.
textIterGetCharsInLine_ :: TextIter -> IO Int

-- | Whether selection iter is editable.
textIterBoundIsEditable :: (TextIter, TextIter) -> IO Bool

module Manatee.Toolkit.Gtk.Notebook

-- | In Gtk+ C code, GtkNotebook refuses to switch to a page unless the
--   child widget is visible. So wrap below functions that show child
--   widget before add them to a notebook. Details see documents of
--   <tt>gtk_notebook_set_current_page</tt>.
notebookAppendPage_ :: (NotebookClass notebook, WidgetClass child) => notebook -> child -> String -> IO Int
notebookAppendPageMenu_ :: (NotebookClass notebook, WidgetClass child, WidgetClass tabLabel, WidgetClass menuLabel) => notebook -> child -> tabLabel -> menuLabel -> IO Int
notebookAppendPageTab_ :: (NotebookClass notebook, WidgetClass child, WidgetClass tabLabel) => notebook -> child -> tabLabel -> IO Int
notebookPrependPage_ :: (NotebookClass notebook, WidgetClass child) => notebook -> child -> String -> IO Int
notebookPrependPageMenu_ :: (NotebookClass notebook, WidgetClass child, WidgetClass tabLabel, WidgetClass menuLabel) => notebook -> child -> tabLabel -> menuLabel -> IO Int
notebookPrependPageTab_ :: (NotebookClass notebook, WidgetClass child, WidgetClass tabLabel) => notebook -> child -> tabLabel -> IO Int
notebookInsertPage_ :: (NotebookClass notebook, WidgetClass child) => notebook -> child -> String -> Int -> IO Int
notebookInsertPageMenu_ :: (NotebookClass notebook, WidgetClass child, WidgetClass tabLabel, WidgetClass menuLabel) => notebook -> child -> tabLabel -> menuLabel -> Int -> IO Int
notebookInsertPageTab_ :: (NotebookClass notebook, WidgetClass child, WidgetClass tabLabel) => notebook -> child -> tabLabel -> Int -> IO Int

-- | Remove child, just remove it's page when child is contained in
--   notebook.
notebookRemoveChild :: (NotebookClass notebook, WidgetClass child) => notebook -> child -> IO ()

-- | Insert page and make child reorderable.
notebookInsertReorderPage :: (NotebookClass notebook, WidgetClass child) => notebook -> child -> String -> Int -> IO ()

-- | Focus current page.
notebookFocusCurrentPage :: (NotebookClass notebook) => notebook -> IO ()

-- | Get current page. Like <a>notebookGetCurrentPage</a> except use widget
--   instead current page index.
notebookGetCurrentPage_ :: (NotebookClass notebook) => notebook -> IO (Maybe Widget)

-- | Select next page.
notebookSelectNextPage :: (NotebookClass notebook) => notebook -> IO ()

-- | Select previous page.
notebookSelectPrevPage :: (NotebookClass notebook) => notebook -> IO ()

-- | Select first page.
notebookSelectFirstPage :: (NotebookClass notebook) => notebook -> IO ()

-- | Select last page.
notebookSelectLastPage :: (NotebookClass notebook) => notebook -> IO ()

-- | At start.
notebookAtStart :: (NotebookClass notebook) => notebook -> IO Bool

-- | At End.
notebookAtEnd :: (NotebookClass notebook) => notebook -> IO Bool

-- | Get tab first index.
notebookFirstIndex :: (NotebookClass notebook) => notebook -> IO Int

-- | Get tab last index.
notebookLastIndex :: (NotebookClass notebook) => notebook -> IO Int

-- | Set name with given index.
notebookSetTabName :: (NotebookClass notebook) => notebook -> Int -> String -> IO ()

module Manatee.Toolkit.Widget.Interactivebar
data Interactivebar
Interactivebar :: Frame -> HBox -> Label -> Entry -> Interactivebar
interactivebarFrame :: Interactivebar -> Frame
interactivebarBox :: Interactivebar -> HBox
interactivebarTitleLabel :: Interactivebar -> Label
interactivebarEntry :: Interactivebar -> Entry
type InteractivebarTitle = String
type InteractivebarEntryStatus = EditableStatus
type InteractivebarStatus = (InteractivebarTitle, InteractivebarEntryStatus)

-- | Create new interactivebar.
interactivebarNew :: IO Interactivebar

-- | Clone interactivebar.
interactivebarClone :: (BoxClass box) => box -> Interactivebar -> IO Interactivebar

-- | Init.
interactivebarInit :: Interactivebar -> VBox -> String -> String -> IO ()

-- | Set title.
interactivebarSetTitle :: Interactivebar -> String -> IO ()

-- | Set content.
interactivebarSetContent :: Interactivebar -> String -> IO ()

-- | Show interactivebar.
interactivebarShow :: (BoxClass box) => box -> Interactivebar -> IO ()

-- | Exit interactivebar.
interactivebarExit :: (BoxClass box) => box -> Interactivebar -> IO ()

-- | Is visible.
interactivebarIsVisible :: Interactivebar -> IO Bool

-- | Set status.
interactivebarSetStatus :: Interactivebar -> InteractivebarStatus -> IO ()

-- | Get interactivebar status. Return Nothing if interactivebar is not
--   visible.
interactivebarGetStatus :: Interactivebar -> IO (Maybe InteractivebarStatus)

module Manatee.Toolkit.General.Map

-- | Find min match one.
findMinMatch :: (Ord k) => Map k a -> (k -> a -> Bool) -> Maybe (k, a)

module Manatee.Toolkit.Gio.Gio
type FileContentType = String
type FileIconPixbufDatabase = Map FileContentType Pixbuf

-- | Check file is exist.
fileDoesExist :: ByteString -> Bool

-- | Check directory is exist.
directoryDoesExist :: ByteString -> Bool

-- | Check file path whether directory.
isDirectory :: ByteString -> Bool

-- | Get files from given directory.
directoryGetFiles :: ByteString -> IO [ByteString]

-- | Get files recursive.
directoryGetFilesRecursive :: ByteString -> IO [ByteString]

-- | Get info name with type.
fileInfoGetNameWithType :: (FileInfoClass info) => info -> ByteString

-- | Get info name with type.
fileInfoGetDisplayNameWithType :: (FileInfoClass info) => info -> String

-- | Get display name for given filepath.
filepathGetDisplayName :: ByteString -> FilePath

-- | Get FileInfo list from given directory.
directoryGetFileInfos :: ByteString -> IO [FileInfo]

-- | We need use absolute *byte string* to identifier a filepath in
--   filesystem. So we need 'directory name' and 'file name' are valid
--   'byte string', no encoding information. 'Byte string file name' can
--   get by <a>fileEnumeratorNextFile</a> and <a>fileInfoGetName</a>. 'Byte
--   string directory name ' can get by <a>fileEnumerateChildren</a> and
--   <a>fileEnumeratorGetContainer</a> So this function is convert user
--   input directory name (UTF8) to 'byte string'.
getDirectoryPath :: String -> IO ByteString

-- | Get FileInfo list from given FileEnumerator.
fileEnumeratorGetFileInfos :: (FileEnumeratorClass enumerator) => enumerator -> IO [FileInfo]

-- | Compare file name with file type. Directory first, then sort file. All
--   sort is alpha sort.
compareFileWithType :: (FilePath, FileType) -> (FilePath, FileType) -> Ordering

-- | Get description for file info.
fileInfoGetDescription :: (FileInfoClass info) => info -> String

-- | Get all execute files.
getAllExecuteFiles :: IO [ByteString]

-- | Launch command in terminal.
launchCommandInTerminal :: String -> IO ()

-- | Get icon pixbuf.
fileInfoGetIconPixbuf :: (FileInfoClass info) => info -> IO Pixbuf

-- | Get icon pixbuf.
getIconPixbuf :: (IconClass icon) => icon -> IO Pixbuf

-- | Update file icon database.
updateFileIconPixbufDatabase :: (FileInfoClass info) => info -> FileIconPixbufDatabase -> IO FileIconPixbufDatabase

module Manatee.Toolkit.Gtk.Struct
newtype GWindowId
GWindowId :: NativeWindowId -> GWindowId

-- | Get NativeWindowId.
getInternalWindowId :: GWindowId -> NativeWindowId
instance Num GWindowId
instance Read GWindowId
instance Ord GWindowId
instance Eq GWindowId
instance Show GWindowId

module Manatee.Toolkit.Widget.Plug
data Plug
Plug :: Plug -> GWindowId -> ConnectId Plug -> Plug
plugBody :: Plug -> Plug
plugId :: Plug -> GWindowId
plugHandler :: Plug -> ConnectId Plug

-- | Create new plug.
plugNew :: Maybe NativeWindowId -> IO Plug

-- | Destroy plug. Disconnect <a>deleteEvent</a> signal before destroy
--   GtkPlug. Make sure GtkPlug destroy completely.
plugDestroy :: Plug -> IO ()

module Manatee.Core.Config

-- | Config file directly.
getConfigDirectory :: IO FilePath

-- | Browse history path.
browseHistoryPath :: FilePath

-- | Page type path.
pageTypeRulePath :: FilePath

-- | File open rule.
fileOpenRulePath :: FilePath

-- | Page mode rule.
pageModeRulePath :: FilePath

-- | Duplicate tab list path.
pageModeDuplicateList :: FilePath

-- | Write config file.
writeConfig :: (Binary a) => FilePath -> a -> IO ()

-- | Read config file.
readConfig :: (Binary a) => FilePath -> a -> IO a

module Manatee.Core.Interactive

-- | Parse interactive string. Return error reason if parse failed.
parseInteractiveString :: String -> Either Text [(String, String)]

-- | Get candidate name for type character.
interactiveCandidateName :: Char -> String

module Manatee.Core.Debug

-- | Debug flag for dbus message.
debugDBusFlag :: Bool

-- | Debug flag for test event.
debugEventFlag :: Bool

-- | Debug message for dbus message.
debugDBusMessage :: String -> IO ()

-- | Debug message for event.
debugEventMessage :: String -> IO ()

module Manatee.Toolkit.General.Misc

-- | Like =~ , but don't care case sensitive.
(=~^) :: (RegexLike Regex source1, RegexMaker Regex CompOption ExecOption source) => source1 -> source -> Bool

-- | Show to text.
showText :: (Show a) => a -> Text

-- | Format file size (bytes) to hummable size.
formatFileSizeForDisplay :: Integer -> String

-- | Format float with specify precision.
formatFloatN :: Double -> Int -> Double

-- | splitInt 1000000 =&gt; <a>1,000,000</a>
splitInt :: Int -> String

module Manatee.Toolkit.General.DBus
type ObjectPathText = Text
type MemberNameText = Text
type InterfaceNameText = Text
type BusNameText = Text
type SignatureText = Text

-- | Member name prefix for some name that beginning with digit.
memberNamePrefix :: Text

-- | Handy function for build DBus message signal.
mkMessageSignal :: ObjectPathText -> MemberNameText -> InterfaceNameText -> BusNameText -> [Variant] -> Signal

-- | Build system bus client.
mkSystemClient :: IO Client

-- | Build system bus client with name.
mkSystemClientWithName :: Text -> IO Client

-- | Build session bus client.
mkSessionClient :: IO Client

-- | Build session bus client with name.
mkSessionClientWithName :: Text -> IO Client

-- | Build starter bus client.
mkStarterClient :: IO Client

-- | Request name.
requestName' :: Client -> BusNameText -> [RequestNameFlag] -> IO RequestNameReply

-- | Build LoaclObject with Text information, handy!.
mkLocalObject :: [(InterfaceNameText, [(MemberNameText, Member)])] -> LocalObject

-- | Like <a>export</a>, but instead ObjectPath with ObjectPathText.
export' :: Client -> ObjectPathText -> LocalObject -> IO ()

-- | Export LocalObject.
exportLocalObject :: Client -> ObjectPathText -> [(InterfaceNameText, [(MemberNameText, Member)])] -> IO ()

-- | Build MatchRule.
mkMatchRule :: Maybe MessageType -> BusNameText -> InterfaceNameText -> MemberNameText -> ObjectPathText -> BusNameText -> [ParameterValue] -> MatchRule

-- | Create Signal Memeber.
mkSignalMember :: SignatureText -> Member

-- | Create Method Member.
mkMethodMember :: SignatureText -> SignatureText -> (MethodCall -> IO ()) -> Member

-- | Pack digit member name for protocol.
packDigitMemberName :: Text -> Text

-- | Unpack digit member name for protocol.
unpackDigitMemberName :: Text -> Text

-- | Check specify bus name whether exist. This function very useful to
--   check dbus process whether exist by check bus name in dbus list.
isBusNameExist :: Text -> IO Bool

module Manatee.Core.TH

-- | Unpack variant with corresponding type.
unpackVariantList :: Name -> Name -> ExpQ

-- | This string is append in SignalArgs with MemberName. Example dbus
--   member named <tt>Foo</tt>, and SignalArgs should be <tt>FooArgs</tt>.
--   Otherwise, function <a>checkSignalArgs</a> will failed.
signalArgsTemplate :: String

-- | Unpack variant with corresponding type.
checkSignalArgs :: Name -> Name -> ExpQ

-- | Pack variant with corresponding type.
packVariantList :: String -> Name -> Q [Dec]

-- | Pack variant with corresponding type.
packStringList :: String -> Name -> Q [Dec]

-- | This is template code for transform typ to [a]
packListTemplate :: (Name -> ExpQ) -> String -> Name -> Q [Dec]

-- | Build declaration. If this function got <a>unbound variable</a>, try
--   use <a>packVariantList</a> style to build [PatQ] explicitly.
mkDec :: String -> ExpQ -> DecQ

-- | Build function declaration.
mkFunDec :: String -> ExpQ -> Q [Dec]

module Manatee.Core.Types

-- | Page is widget container for render view.
data Page
Page :: PageId -> PageType -> Plug -> PageViewWrap -> Page
pageId :: Page -> PageId
pageType :: Page -> PageType
pagePlug :: Page -> Plug
pageView :: Page -> PageViewWrap
type PagePlug = Plug

-- | PageList Contain pages (different view for same buffer) in child
--   process. Build index for looking for corresponding page.
type PageList = Set Page

-- | PageType for different type page.
type PageType = String
data PageTypeRule
PageTypeRule :: (Map PageType String) -> PageTypeRule
data FileOpenRule
FileOpenRule :: (Map FileMatch [(FileOpenName, PageType, FilePrefix)]) -> FileOpenRule
type FileOpenName = String
type FilePrefix = String
data PageModeRule
PageModeRule :: (Map PageType (Either PageModeName (Map String PageModeName))) -> PageModeRule
data PageModeDuplicateList
PageModeDuplicateList :: [PageModeName] -> PageModeDuplicateList
data FileMatch
ContentTypeMatch :: String -> FileMatch
RegexpMatch :: String -> FileMatch

-- | BufferList
newtype BufferList
BufferList :: (Map PageModeName (Seq Buffer)) -> BufferList
data Buffer
Buffer :: ProcessID -> PageId -> PageType -> String -> String -> Buffer
bufferProcessId :: Buffer -> ProcessID
bufferPageId :: Buffer -> PageId
bufferPageType :: Buffer -> PageType
bufferPath :: Buffer -> String
bufferName :: Buffer -> String
data BufferInfo
BufferInfo :: PageModeName -> PagePath -> String -> PageId -> BufferInfo
bufferInfoMode :: BufferInfo -> PageModeName
bufferInfoPath :: BufferInfo -> PagePath
bufferInfoName :: BufferInfo -> String
bufferInfoId :: BufferInfo -> PageId
data BufferHistory
BufferHistory :: PageModeName -> PageType -> PagePath -> BufferHistory
bufferHistoryMode :: BufferHistory -> PageModeName
bufferHistoryType :: BufferHistory -> PageType
bufferHistoryPath :: BufferHistory -> PagePath
data BrowseHistoryList
BrowseHistoryList :: (Map String String) -> BrowseHistoryList
type BufferInfoList = [BufferInfo]
type BufferHistoryList = [BufferHistory]

-- | PageMode
type PageModeName = String
type PageModeRegexp = String
data PageMode
PageMode :: PageModeName -> PageModeRegexp -> PageViewKeymap -> (forall a. (PageView a) => a -> IO ()) -> PageMode
pageModeName :: PageMode -> PageModeName
pageModeRegexp :: PageMode -> PageModeRegexp
pageModeKeymap :: PageMode -> PageViewKeymap
pageModeLoad :: PageMode -> forall a. (PageView a) => a -> IO ()

-- | PageBuffer
class (Typeable a) => PageBuffer a
pageBufferGetName :: (PageBuffer a) => a -> IO String
pageBufferSetName :: (PageBuffer a) => a -> String -> IO ()
pageBufferClient :: (PageBuffer a) => a -> Client
pageBufferCreateView :: (PageBuffer a) => a -> PagePlugId -> IO PageViewWrap
pageBufferMode :: (PageBuffer a) => a -> PageMode
data PageBufferWrap
PageBufferWrap :: a -> PageBufferWrap

-- | Page buffer new function.
type PageBufferNewFun = FilePath -> Client -> PageId -> IO PageBufferWrap

-- | PageView class.
class (Typeable a) => PageView a
pageViewBuffer :: (PageView a) => a -> PageBufferWrap
pageViewPlugId :: (PageView a) => a -> TVar PagePlugId
pageViewHandleKeyAction :: (PageView a) => a -> Text -> SerializedEvent -> IO ()
pageViewFocus :: (PageView a) => a -> IO ()
pageViewCopy :: (PageView a) => a -> IO Bool
pageViewCut :: (PageView a) => a -> IO Bool
pageViewPaste :: (PageView a) => a -> IO Bool
pageViewScrolledWindow :: (PageView a) => a -> ScrolledWindow
pageViewScrollToTop :: (PageView a) => a -> IO ()
pageViewScrollToBottom :: (PageView a) => a -> IO ()
pageViewScrollVerticalPage :: (PageView a) => Bool -> a -> IO ()
pageViewScrollVerticalStep :: (PageView a) => Bool -> a -> IO ()
pageViewScrollToLeft :: (PageView a) => a -> IO ()
pageViewScrollToRight :: (PageView a) => a -> IO ()
pageViewScrollHorizontalPage :: (PageView a) => Bool -> a -> IO ()
pageViewScrollHorizontalStep :: (PageView a) => Bool -> a -> IO ()
data PageViewWrap
PageViewWrap :: a -> PageViewWrap
type PageViewKeymap = forall a. (PageView a) => Map Text (a -> IO ())
data AnythingInteractiveType
GlobalSearch :: AnythingInteractiveType
GlobalInteractive :: AnythingInteractiveType
LocalInteractive :: AnythingInteractiveType

-- | DBus
type AnythingKeyPressId = Int
type PageId = Int
type PageSocketId = GWindowId
type PagePlugId = GWindowId
type PagePath = String
type SignalBoxId = Int
type InteractiveString = (PagePlugId, String)
type InteractiveResult = [String]
data DaemonMember
NewRenderPageConfirm :: DaemonMember
NewAnythingProcessConfirm :: DaemonMember
RenderProcessExit :: DaemonMember
RenderProcessException :: DaemonMember
NewTab :: DaemonMember
AnythingViewOutput :: DaemonMember
LocalInteractivebarExit :: DaemonMember
LocalOutputbarUpdate :: DaemonMember
LocalStatusbarUpdate :: DaemonMember
LocalProgressUpdate :: DaemonMember
SynchronizationPathName :: DaemonMember
ChangeTabName :: DaemonMember
SwitchBuffer :: DaemonMember
ShowTooltip :: DaemonMember
LocalInteractiveReturn :: DaemonMember
GlobalInteractiveReturn :: DaemonMember
data DaemonSignalArgs
NewRenderPageConfirmArgs :: PageId -> PageType -> SignalBoxId -> PagePlugId -> ProcessID -> PageModeName -> String -> Bool -> DaemonSignalArgs
NewAnythingProcessConfirmArgs :: PagePlugId -> ProcessID -> DaemonSignalArgs
RenderProcessExitArgs :: PageId -> ProcessID -> DaemonSignalArgs
RenderProcessExceptionArgs :: PageId -> DaemonSignalArgs
NewTabArgs :: PageType -> PagePath -> DaemonSignalArgs
AnythingViewOutputArgs :: String -> String -> (Maybe Int) -> AnythingKeyPressId -> DaemonSignalArgs
LocalInteractivebarExitArgs :: DaemonSignalArgs
LocalOutputbarUpdateArgs :: PagePlugId -> String -> DaemonSignalArgs
LocalStatusbarUpdateArgs :: PagePlugId -> String -> String -> DaemonSignalArgs
LocalProgressUpdateArgs :: PagePlugId -> Double -> DaemonSignalArgs
SynchronizationPathNameArgs :: PageModeName -> PageId -> String -> DaemonSignalArgs
ChangeTabNameArgs :: PageModeName -> PageId -> String -> DaemonSignalArgs
SwitchBufferArgs :: PageModeName -> PageId -> DaemonSignalArgs
ShowTooltipArgs :: String -> (Maybe Point) -> Int -> (Maybe Color) -> (Maybe Color) -> Bool -> (Maybe PageId) -> DaemonSignalArgs
LocalInteractiveReturnArgs :: [String] -> DaemonSignalArgs
GlobalInteractiveReturnArgs :: [String] -> DaemonSignalArgs
data RenderMember
CloneRenderPage :: RenderMember
ReparentRenderPage :: RenderMember
FocusRenderPage :: RenderMember
PageViewKeyPress :: RenderMember
DestroyRenderPage :: RenderMember
ExitRenderProcess :: RenderMember
AnythingViewKeyPress :: RenderMember
AnythingViewChangeCandidate :: RenderMember
AnythingViewChangeInteractiveType :: RenderMember
data RenderSignalArgs
CloneRenderPageArgs :: PageId -> SignalBoxId -> RenderSignalArgs
ReparentRenderPageArgs :: PageId -> PagePlugId -> SignalBoxId -> RenderSignalArgs
FocusRenderPageArgs :: PagePlugId -> RenderSignalArgs
PageViewKeyPressArgs :: PagePlugId -> Text -> SerializedEvent -> RenderSignalArgs
DestroyRenderPageArgs :: PageId -> PagePlugId -> RenderSignalArgs
ExitRenderProcessArgs :: PageId -> RenderSignalArgs
AnythingViewKeyPressArgs :: Text -> String -> String -> AnythingKeyPressId -> Bool -> RenderSignalArgs
AnythingViewChangeCandidateArgs :: [String] -> RenderSignalArgs
AnythingViewChangeInteractiveTypeArgs :: AnythingInteractiveType -> RenderSignalArgs
data DaemonBroadcastMember
ExitDaemonProcess :: DaemonBroadcastMember
data DaemonBroadcastSignalArgs
ExitDaemonProcessArgs :: DaemonBroadcastSignalArgs
data AnythingSearchArgs
GlobalSearchArgs :: AnythingSearchArgs
InteractiveSearchArgs :: AnythingInteractiveType -> [String] -> AnythingSearchArgs
data SpawnProcessArgs
SpawnRenderProcessArgs :: PageId -> PageType -> SignalBoxId -> PagePath -> SpawnProcessArgs
SpawnAnythingProcessArgs :: AnythingSearchArgs -> SpawnProcessArgs
instance Binary PageModeDuplicateList
instance Binary PageModeRule
instance Binary FileOpenRule
instance Binary FileMatch
instance Binary PageTypeRule
instance Binary BrowseHistoryList
instance Show SpawnProcessArgs
instance Eq SpawnProcessArgs
instance Ord SpawnProcessArgs
instance Read SpawnProcessArgs
instance Show AnythingSearchArgs
instance Eq AnythingSearchArgs
instance Ord AnythingSearchArgs
instance Read AnythingSearchArgs
instance Show DaemonBroadcastSignalArgs
instance Eq DaemonBroadcastSignalArgs
instance Ord DaemonBroadcastSignalArgs
instance Show DaemonBroadcastMember
instance Eq DaemonBroadcastMember
instance Ord DaemonBroadcastMember
instance Show RenderSignalArgs
instance Eq RenderSignalArgs
instance Ord RenderSignalArgs
instance Show RenderMember
instance Eq RenderMember
instance Ord RenderMember
instance Show DaemonSignalArgs
instance Eq DaemonSignalArgs
instance Ord DaemonSignalArgs
instance Show DaemonMember
instance Eq DaemonMember
instance Ord DaemonMember
instance Variable AnythingInteractiveType
instance Variable InteractiveResult
instance Variable InteractiveString
instance Variable (Maybe Point)
instance Variable BufferHistoryList
instance Variable BufferInfoList
instance Variable SerializedEvent
instance Variable (Maybe Int)
instance Variable (Maybe Char)
instance Variable Int
instance Variable (Maybe Color)
instance Variable Color
instance Variable GWindowId
instance Variable ProcessID
instance Read Color
instance Ord Color
instance Typeable BrowseHistoryList
instance Typeable BufferHistory
instance Typeable BufferInfo
instance Typeable FileMatch
instance Typeable PageModeDuplicateList
instance Typeable PageModeRule
instance Typeable FileOpenRule
instance Typeable PageTypeRule
instance Show AnythingInteractiveType
instance Ord AnythingInteractiveType
instance Eq AnythingInteractiveType
instance Read AnythingInteractiveType
instance Show BrowseHistoryList
instance Read BrowseHistoryList
instance Eq BrowseHistoryList
instance Ord BrowseHistoryList
instance Show BufferHistory
instance Read BufferHistory
instance Eq BufferHistory
instance Ord BufferHistory
instance Show BufferInfo
instance Read BufferInfo
instance Eq BufferInfo
instance Ord BufferInfo
instance Show Buffer
instance Read Buffer
instance Eq Buffer
instance Ord Buffer
instance Show BufferList
instance Show FileMatch
instance Read FileMatch
instance Eq FileMatch
instance Ord FileMatch
instance Show PageModeDuplicateList
instance Read PageModeDuplicateList
instance Eq PageModeDuplicateList
instance Ord PageModeDuplicateList
instance Show PageModeRule
instance Read PageModeRule
instance Eq PageModeRule
instance Ord PageModeRule
instance Show FileOpenRule
instance Read FileOpenRule
instance Eq FileOpenRule
instance Ord FileOpenRule
instance Show PageTypeRule
instance Read PageTypeRule
instance Eq PageTypeRule
instance Ord PageTypeRule
instance Ord Page
instance Eq Page

module Manatee.Core.Page

-- | New page.
pageNew :: PageId -> PageType -> PagePlug -> PageViewWrap -> IO Page

-- | Page scrolled window.
pageScrolledWindow :: Page -> ScrolledWindow

-- | Applying function with page buffer.
pageApplyViewWrap :: Page -> (forall a. (PageView a) => a -> b) -> b

-- | Page plug id.
pagePlugId :: Page -> GWindowId

module Manatee.Core.PageMode

-- | Default mode.
defaultMode :: PageMode

-- | Get duplicate tab list.
getDuplicateTabList :: IO [PageModeName]

-- | Get page mode name.
getPageModeName :: PageType -> String -> IO PageModeName

module Manatee.Core.DBus

-- | The daemon bus name.
daemonBusName :: Text

-- | The daemon interface name.
daemonInterfaceName :: Text

-- | The daemon path name.
daemonPathName :: Text

-- | The damon broadcast interface name.
daemonBroadcastInterfaceName :: Text

-- | The damon broadcast path name.
daemonBroadcastPathName :: Text

-- | The daemon interactive error name.
daemonInteractiveErrorName :: Text

-- | The render bus name. This name just template name, The real render
--   name should add render process id behind.
renderBusName :: Text

-- | The render interface name.
renderInterfaceName :: Text

-- | The render path name.
renderPathName :: Text

-- | Build render client name. Concat renderBusName and render process id.
mkRenderClientName :: ProcessID -> Text

-- | Unpack daemon signal from Variant list. unpackDaemonSignalArgs_ ::
--   DaemonMember -&gt; [Variant] -&gt; Maybe DaemonSignalArgs
--   
--   Unpack daemon signal from Variant list.
--   unpackDaemonBroadcastSignalArgs_ :: DaemonBroadcastMember -&gt;
--   [Variant] -&gt; Maybe DaemonBroadcastSignalArgs
--   
--   Unpack render signal arguments from Variant list.
--   unpackRenderSignalArgs_ :: RenderMember -&gt; [Variant] -&gt; Maybe
--   RenderSignalArgs
--   
--   Pack daemon signal argument to Variant list. packDaemonSignalArgs ::
--   DaemonSignalArgs -&gt; [Variant]
--   
--   Pack render signal arguments to Variant list.
--   
--   Pack daemon broadcast signal arguments to Variant list.
--   packDaemonBroadcastSignalArgs :: DaemonBroadcastSignalArgs -&gt;
--   [Variant]
--   
--   Check daemon signal argument. Return False if mismatch.
--   
--   Check render signal arguments. Return False is mismatch.
--   
--   Check daemon broadcast signal argument. Return False if mismatch.
--   
--   Build daemon broadcast signal.
mkDaemonBroadcastSignal :: Client -> DaemonBroadcastMember -> DaemonBroadcastSignalArgs -> IO ()

-- | Build daemon broadcast match rule.
mkDaemonBroadcastMatchRule :: Client -> (DaemonBroadcastMember, DaemonBroadcastSignalArgs -> IO ()) -> IO ()

-- | Build daemon signal. If signal argument not match daemon member name.
mkDaemonSignal :: Client -> DaemonMember -> DaemonSignalArgs -> IO ()

-- | Build daemon match rule. Use <a>postGUIAsync</a> wrap all signal
--   handler.
mkDaemonMatchRule :: Client -> (DaemonMember, DaemonSignalArgs -> IO ()) -> IO ()

-- | Build daemon match rule list.
mkDaemonMatchRules :: Client -> [(DaemonMember, DaemonSignalArgs -> IO ())] -> IO ()

-- | Pick DaemonSignalArgs.
pickDaemonSignalArgs :: DaemonMember -> Signal -> DaemonSignalArgs

-- | Pick DaemonBroadcastSignalArgs.
pickDaemonBroadcastSignalArgs :: DaemonBroadcastMember -> Signal -> DaemonBroadcastSignalArgs

-- | Build render signal. If signal argument not match render member name.
mkRenderSignal :: Client -> ProcessID -> RenderMember -> RenderSignalArgs -> IO ()

-- | Build render process match rule for catch signal. Use
--   <a>postGUIAsync</a> wrap all signal handler. If signal handler need
--   long time calculation, please use <a>mkRenderMatchRuleUnsafe</a> for
--   better performance.
mkRenderMatchRule :: Client -> (RenderMember, RenderSignalArgs -> IO ()) -> IO ()

-- | Build render process match rule for catch signal. Simliar
--   <a>mkRenderMatchRule</a>, but don't use <a>postGUIAsync</a> wrap all
--   signal handler. This function design for signal handler that need long
--   time calculation. So you need use <a>postGUIAsync</a> wrap GTK+ code
--   explicitly to protect GTK+ main thread won't crash.
mkRenderMatchRuleUnsafe :: Client -> (RenderMember, RenderSignalArgs -> IO ()) -> IO ()

-- | Build render math rule list.
mkRenderMatchRules :: Client -> [(RenderMember, RenderSignalArgs -> IO ())] -> IO ()

-- | Pick RenderSignalArgs.
pickRenderSignalArgs :: RenderMember -> Signal -> RenderSignalArgs

-- | Unpack daemon signal from Variant list. Report error if mismatch.
--   
--   Unpack daemon signal from Variant list. Report error if mismatch.
--   
--   Unpack render signal arguments from Variant list. Report error when
--   mismatch.
--   
--   Wait broadcast exit signal. This function is useful for listen exit
--   status of main process of manatee. Most for manatee extension daemon
--   process.
waitBroadcastExitSignal :: Client -> IO ()

-- | Build daemon local object.
mkDaemonMethods :: [(Text, Member)] -> IO ()

-- | Call daemon method.
callDaemonMethod :: Client -> Text -> [Variant] -> IO (Either Error MethodReturn)

-- | Call daemon method asynchronously.
callDaemonMethodAsync :: Client -> Text -> [Variant] -> (Error -> IO ()) -> (MethodReturn -> IO ()) -> IO ()

module Manatee.Core.FileOpenRule

-- | The rule how to open file.
fileOpenRule :: FilePath -> String -> IO [(String, Client -> IO ())]

-- | The open rule that handle by system.
systemOpenRule :: FilePath -> String -> IO [(String, Client -> IO ())]

-- | Open by default editor.
openByDefaultEditor :: FilePath -> Client -> IO ()

module Manatee.Core.PageView

-- | PageViewKeymap.
pageViewKeymap :: PageViewKeymap

-- | Basic scroll action.
pageViewScrollStepDown :: (PageView a) => a -> IO ()
pageViewScrollPageUp :: (PageView a) => a -> IO ()
pageViewScrollPageDown :: (PageView a) => a -> IO ()
pageViewScrollStepUp :: (PageView a) => a -> IO ()
pageViewScrollStepLeft :: (PageView a) => a -> IO ()
pageViewScrollPageRight :: (PageView a) => a -> IO ()
pageViewScrollPageLeft :: (PageView a) => a -> IO ()
pageViewScrollStepRight :: (PageView a) => a -> IO ()

-- | Get plug id of page view.
pageViewGetPlugId :: (PageView a) => a -> IO PagePlugId

-- | Update output.
pageViewUpdateOutputStatus :: (PageView a) => a -> String -> Maybe Int -> IO ()

-- | Update progress.
pageViewUpdateProgressStatus :: (PageView a) => a -> Double -> IO ()

-- | Update status.
pageViewUpdateInfoStatus :: (PageView a) => a -> String -> String -> IO ()

-- | Get dbus client.
pageViewClient :: (PageView a) => a -> Client

-- | Cut action.
pageViewCutAction :: (PageView a) => a -> IO ()

-- | Copy action.
pageViewCopyAction :: (PageView a) => a -> IO ()

-- | Paste action.
pageViewPasteAction :: (PageView a) => a -> IO ()

-- | Call local interactive.
localInteractive :: (PageView a) => a -> String -> ([String] -> IO ()) -> IO ()

module Manatee.Core.Render

-- | Irc client render process.
startupRender :: PageBufferNewFun -> IO ()

-- | Render process main entry.
renderMain :: SpawnProcessArgs -> PageBufferNewFun -> IO ()

-- | Build render client for listen dbus signal.
mkRenderClient :: Client -> PageBufferWrap -> ProcessID -> TVar PageList -> PageType -> IO ()

-- | Handle clone render page signal.
renderHandleClonePage :: Client -> PageBufferWrap -> TVar PageList -> ProcessID -> PageType -> RenderSignalArgs -> IO ()

-- | Handle re-parent render page signal.
renderHandleReparentPage :: Client -> PageBufferWrap -> TVar PageList -> ProcessID -> RenderSignalArgs -> IO ()

-- | Handle new render page signal.
renderPageNew :: Client -> PageBufferWrap -> TVar PageList -> ProcessID -> (PageId, PageType, SignalBoxId) -> Bool -> IO ()

-- | Handle focus render page signal.
renderHandleFocusPage :: TVar PageList -> RenderSignalArgs -> IO ()

-- | Handle page view key press signal.
renderHandleKeyPress :: TVar PageList -> RenderSignalArgs -> IO ()

-- | Handle destroy render page signal.
renderHandleDestroyPage :: TVar PageList -> RenderSignalArgs -> IO ()

-- | Handle exit process signal.
renderHandleExitProcess :: Client -> ProcessID -> RenderSignalArgs -> IO ()
