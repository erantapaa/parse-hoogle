-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Functions for working with Dirichlet densities and mixtures on vectors.
--   
--   Functions for working with Dirichlet densities and mixtures on
--   vectors. The focus of this package is on deriving these distributions
--   from observed data.
--   
--   This package should be treated as experimental code, it has not been
--   battle-tested as much as it would be nice to be.
--   
--   Note that although this package is BSD3-licensed, it uses the
--   <tt>nonlinear-optimization</tt> package which is GPLed. It should be
--   straightforward to use another library in its stead, though.
@package statistics-dirichlet
@version 0.6.1


-- | Implement matrices using plain <a>Vector</a>s with data stored in
--   row-major order (i.e. the first elements correspond to the first row).
module Math.Statistics.Dirichlet.Matrix

-- | A matrix.
data Matrix
M :: !Int -> !Int -> !Vector Double -> Matrix
mRows :: Matrix -> !Int
mCols :: Matrix -> !Int
mData :: Matrix -> !Vector Double

-- | Size of the matrix.
size :: Matrix -> (Int, Int)

-- | Element at position.
(!) :: Matrix -> (Int, Int) -> Double

-- | A matrix where all elements are of the same value.
replicate :: (Int, Int) -> Double -> Matrix

-- | A matrix where all rows are of the same value.
replicateRows :: Int -> Vector Double -> Matrix

-- | Creates a matrix from a vector of vectors. It *is not* verified that
--   the vectors have the right length.
fromVector :: (Vector v (w Double), Vector w Double) => v (w Double) -> Matrix

-- | Creates a matrix from a vector of vectors. The vectors are transposed,
--   so <tt>fromVectorT</tt> is the same as <tt>transpose .
--   fromVector</tt>. It *is* verified that the vectors have the right
--   length.
fromVectorT :: (Vector v (w Double), Vector w Double) => v (w Double) -> Matrix

-- | <i>O(rows)</i> Rows of the matrix. Each element takes <i>O(1)</i> time
--   and storage.
rows :: Matrix -> Vector (Vector Double)

-- | <i>O(1)</i> <tt>m !!! i</tt> is the <tt>i</tt>-th row of the matrix.
(!!!) :: Matrix -> Int -> Vector Double

-- | <i>O(rows*cols)</i> Columns of the matrix. Each element takes
--   <i>O(rows)</i> time and storage.
cols :: Matrix -> Vector (Vector Double)

-- | <i>O(rows)</i> <tt>m <a>col</a> i</tt> is the <tt>i</tt>-th column of
--   the matrix.
col :: Matrix -> Int -> Vector Double
umap :: (Vector Double -> Vector Double) -> Matrix -> Matrix
map :: (Double -> Double) -> Matrix -> Matrix
imap :: ((Int, Int) -> Double -> Double) -> Matrix -> Matrix
rowmap :: (Vector Double -> Double) -> Matrix -> Vector Double
irowmap :: (Int -> Vector Double -> Double) -> Matrix -> Vector Double
uzipWith :: (Vector Double -> Vector Double -> Vector Double) -> Matrix -> Matrix -> Matrix
zipWith :: (Double -> Double -> Double) -> Matrix -> Matrix -> Matrix
izipWith :: ((Int, Int) -> Double -> Double -> Double) -> Matrix -> Matrix -> Matrix

-- | <tt>rzipWith f m n</tt> is a matrix with the same number of rows as
--   <tt>m</tt>. The <tt>i</tt>-th row is obtained by applying <tt>f</tt>
--   to the <tt>i</tt>-th rows of <tt>m</tt> and <tt>n</tt>.
rzipWith :: (Int -> Vector Double -> Vector Double -> Vector Double) -> Matrix -> Matrix -> Matrix
transpose :: Matrix -> Matrix
instance Eq Matrix
instance Ord Matrix
instance Show Matrix


module Math.Statistics.Dirichlet.Util

-- | Infinity, currently defined as <tt>1e100</tt>. Used mainly as the
--   initial cost.
infinity :: Double

-- | Logarithm of the beta function applied to a vector.
logBeta :: Vector Double -> Double


module Math.Statistics.Dirichlet.Options

-- | A vector used for deriving the parameters of a Dirichlet density or
--   mixture.
type TrainingVector = Vector Double

-- | A vector of training vectors. This is the only vector that is not
--   unboxed (for obvious reasons).
type TrainingVectors = Vector TrainingVector

-- | Usually denoted by lowercase greek letter eta (η), size of each step
--   in the gradient. Should be greater than zero and much less than one.
newtype StepSize
Step :: Double -> StepSize

-- | Maximum difference between costs to consider that the process
--   converged.
type Delta = Double

-- | Predicate specifying when the training should be over.
data Predicate
Pred :: !Int -> !Delta -> !Int -> !Int -> !Delta -> Predicate

-- | Maximum number of iterations.
maxIter :: Predicate -> !Int

-- | Minimum delta to continue iterating. This is invariant of
--   <tt>deltaSteps</tt>, which means that if <tt>deltaSteps</tt> is
--   <tt>2</tt> then minDelta will be considered twice bigger to account
--   for the different <tt>deltaSteps</tt>.
minDelta :: Predicate -> !Delta

-- | How many estimation steps should be done before recalculating the
--   delta. If <tt>deltaSteps</tt> is <tt>1</tt> then it will be
--   recalculated on every step.
deltaSteps :: Predicate -> !Int

-- | Maximum number of iterations on each weight step.
maxWeightIter :: Predicate -> !Int

-- | Used only when calculating mixtures. When the delta drops below this
--   cutoff the computation changes from estimating the alphas to
--   estimatating the weights and vice-versa. Should be greater than
--   <tt>minDelta</tt>.
jumpDelta :: Predicate -> !Delta

-- | Reason why the derivation was over.
data Reason

-- | The difference between applications of the cost function dropped below
--   the minimum delta. In other words, it coverged.
Delta :: Reason

-- | The maximum number of iterations was reached while the delta was still
--   greater than the minimum delta.
MaxIter :: Reason

-- | CG_DESCENT returned this result, which brought the derivation process
--   to a halt.
CG :: Result -> Reason

-- | Result of a deriviation.
data Result a
Result :: !Reason -> !Int -> !Delta -> !Double -> !a -> Result a

-- | Reason why the derivation was over.
reason :: Result a -> !Reason

-- | Number of iterations spent.
iters :: Result a -> !Int

-- | Last difference between costs.
lastDelta :: Result a -> !Delta

-- | Last cost (i.e. the cost of the result).
lastCost :: Result a -> !Double

-- | Result obtained.
result :: Result a -> !a
instance Eq Predicate
instance Read Predicate
instance Show Predicate
instance Eq Reason
instance Read Reason
instance Show Reason
instance Eq a => Eq (Result a)
instance Read a => Read (Result a)
instance Show a => Show (Result a)
instance NFData a => NFData (Result a)


module Math.Statistics.Dirichlet.Density

-- | A Dirichlet density.
newtype DirichletDensity
DD :: Vector Double -> DirichletDensity
unDD :: DirichletDensity -> Vector Double

-- | <tt>empty n x</tt> is an "empty" Dirichlet density with size
--   <tt>n</tt> and all alphas set to <tt>x</tt>.
empty :: Int -> Double -> DirichletDensity

-- | <tt>fromList xs</tt> constructs a Dirichlet density from a list of
--   alpha values.
fromList :: [Double] -> DirichletDensity

-- | <tt>toList d</tt> deconstructs a Dirichlet density to a list of alpha
--   values.
toList :: DirichletDensity -> [Double]

-- | Derive a Dirichlet density using a maximum likelihood method as
--   described by Karplus et al (equation 26). All training vectors should
--   have the same length, however this is not verified.
derive :: DirichletDensity -> Predicate -> StepSize -> TrainingVectors -> Result DirichletDensity

-- | Cost function for deriving a Dirichlet density (equation 18). This
--   function is minimized by <a>derive</a>.
cost :: TrainingVectors -> DirichletDensity -> Double
instance Eq DirichletDensity
instance NFData DirichletDensity
instance Read DirichletDensity
instance Show DirichletDensity


module Math.Statistics.Dirichlet.Mixture

-- | A Dirichlet mixture.
data DirichletMixture
DM :: !Vector Double -> !Matrix -> DirichletMixture

-- | Weights of each density.
dmWeights :: DirichletMixture -> !Vector Double

-- | Values of all parameters of all densities. This matrix has <tt>length
--   dmWeights</tt> rows.
dmDensities :: DirichletMixture -> !Matrix

-- | Number of components in a dirichlet mixture.
dmComponents :: DirichletMixture -> Int

-- | Number of parameters each component has.
dmParameters :: DirichletMixture -> Int

-- | Separated list of densities.
dmDensitiesL :: DirichletMixture -> [DirichletDensity]

-- | <tt>dm !!! i</tt> is the <tt>i</tt>-th density. No bounding checks are
--   made.
(!!!) :: DirichletMixture -> Int -> Vector Double

-- | <tt>empty q n x</tt> is an "empty" Dirichlet mixture with <tt>q</tt>
--   components and <tt>n</tt> parameters. Each component has size
--   <tt>n</tt>, weight inversely proportional to its index and all alphas
--   set to <tt>x</tt>.
empty :: Int -> Int -> Double -> DirichletMixture

-- | A list representation of a component of a Dirichlet mixture. Used by
--   <a>fromList</a> and <a>toList</a> only.
type Component = (Double, [Double])

-- | <tt>fromList xs</tt> constructs a Dirichlet mixture from a non-empty
--   list of components. Each component has a weight and a list of alpha
--   values. The weights sum to 1, all lists must have the same number of
--   values and every number must be non-negative. None of these
--   preconditions are verified.
fromList :: [Component] -> DirichletMixture

-- | <tt>toList dm</tt> is the inverse of <tt>fromList</tt>, constructs a
--   list of components from a Dirichlet mixture. There are no error
--   conditions and <tt>toList . fromList == id</tt>.
toList :: DirichletMixture -> [Component]

-- | Constructs a Dirichlet mixture of one component from a Dirichlet
--   density.
fromDD :: DirichletDensity -> DirichletMixture

-- | Pre-processed training vectors (see <a>prepareTraining</a>).
data TrainingData

-- | Prepares training vectors to be used as training data. Anything that
--   depends only on the training vectors is precalculated here.
--   
--   We also try to find columns where all training vectors are zero. Those
--   columns are removed from the derivation process and every component
--   will have zero value on that column. Note that at least one column
--   should have non-zero training vectors.
prepareTraining :: TrainingVectors -> TrainingData

-- | Derive a Dirichlet mixture using a maximum likelihood method as
--   described by Karplus et al (equation 25) using CG_DESCENT method by
--   Hager and Zhang (see
--   <a>Numeric.Optimization.Algorithms.HagerZhang05</a>). All training
--   vectors should have the same length, however this is not verified.
derive :: DirichletMixture -> Predicate -> StepSize -> TrainingData -> Result DirichletMixture

-- | Cost function for deriving a Dirichlet mixture (equation 18). This
--   function is minimized by <a>derive</a>. Calculated using (17) and
--   (54).
cost :: TrainingData -> DirichletMixture -> Double

-- | Derivative of the cost function with respect <tt>w_{i,j}</tt>, defined
--   by Equation (22). The result is given in the same size and order as
--   the <tt>dmDensitites</tt> vector.
del_cost_w :: TrainingData -> DirichletMixture -> Matrix
instance Eq DirichletMixture
instance Eq TrainingData
instance Show TrainingData
instance NFData DirichletMixture
instance Read DirichletMixture
instance Show DirichletMixture


-- | This module re-exports functions from
--   <a>Math.Statistics.Dirichlet.Mixture</a> and
--   <a>Math.Statistics.Dirichlet.Options</a> in a more digestable way.
--   Since this library is under-documented, I recommend reading the
--   documentation of the symbols re-exported here.
--   
--   This module does not use <a>Math.Statistics.Dirichlet.Density</a> in
--   any way. If you don't need mixtures then you should probably use that
--   module directly since it's faster and more reliable (less magic
--   happens there).
module Math.Statistics.Dirichlet

-- | A Dirichlet mixture.
data DirichletMixture
DM :: !Vector Double -> !Matrix -> DirichletMixture

-- | Weights of each density.
dmWeights :: DirichletMixture -> !Vector Double

-- | Values of all parameters of all densities. This matrix has <tt>length
--   dmWeights</tt> rows.
dmDensities :: DirichletMixture -> !Matrix

-- | <tt>empty q n x</tt> is an "empty" Dirichlet mixture with <tt>q</tt>
--   components and <tt>n</tt> parameters. Each component has size
--   <tt>n</tt>, weight inversely proportional to its index and all alphas
--   set to <tt>x</tt>.
empty :: Int -> Int -> Double -> DirichletMixture

-- | A list representation of a component of a Dirichlet mixture. Used by
--   <a>fromList</a> and <a>toList</a> only.
type Component = (Double, [Double])

-- | <tt>fromList xs</tt> constructs a Dirichlet mixture from a non-empty
--   list of components. Each component has a weight and a list of alpha
--   values. The weights sum to 1, all lists must have the same number of
--   values and every number must be non-negative. None of these
--   preconditions are verified.
fromList :: [Component] -> DirichletMixture

-- | <tt>toList dm</tt> is the inverse of <tt>fromList</tt>, constructs a
--   list of components from a Dirichlet mixture. There are no error
--   conditions and <tt>toList . fromList == id</tt>.
toList :: DirichletMixture -> [Component]

-- | A vector used for deriving the parameters of a Dirichlet density or
--   mixture.
type TrainingVector = Vector Double

-- | A vector of training vectors. This is the only vector that is not
--   unboxed (for obvious reasons).
type TrainingVectors = Vector TrainingVector

-- | Usually denoted by lowercase greek letter eta (η), size of each step
--   in the gradient. Should be greater than zero and much less than one.
newtype StepSize
Step :: Double -> StepSize

-- | Maximum difference between costs to consider that the process
--   converged.
type Delta = Double

-- | Predicate specifying when the training should be over.
data Predicate
Pred :: !Int -> !Delta -> !Int -> !Int -> !Delta -> Predicate

-- | Maximum number of iterations.
maxIter :: Predicate -> !Int

-- | Minimum delta to continue iterating. This is invariant of
--   <tt>deltaSteps</tt>, which means that if <tt>deltaSteps</tt> is
--   <tt>2</tt> then minDelta will be considered twice bigger to account
--   for the different <tt>deltaSteps</tt>.
minDelta :: Predicate -> !Delta

-- | How many estimation steps should be done before recalculating the
--   delta. If <tt>deltaSteps</tt> is <tt>1</tt> then it will be
--   recalculated on every step.
deltaSteps :: Predicate -> !Int

-- | Maximum number of iterations on each weight step.
maxWeightIter :: Predicate -> !Int

-- | Used only when calculating mixtures. When the delta drops below this
--   cutoff the computation changes from estimating the alphas to
--   estimatating the weights and vice-versa. Should be greater than
--   <tt>minDelta</tt>.
jumpDelta :: Predicate -> !Delta

-- | Reason why the derivation was over.
data Reason

-- | The difference between applications of the cost function dropped below
--   the minimum delta. In other words, it coverged.
Delta :: Reason

-- | The maximum number of iterations was reached while the delta was still
--   greater than the minimum delta.
MaxIter :: Reason

-- | CG_DESCENT returned this result, which brought the derivation process
--   to a halt.
CG :: Result -> Reason

-- | Result of a deriviation.
data Result a
Result :: !Reason -> !Int -> !Delta -> !Double -> !a -> Result a

-- | Reason why the derivation was over.
reason :: Result a -> !Reason

-- | Number of iterations spent.
iters :: Result a -> !Int

-- | Last difference between costs.
lastDelta :: Result a -> !Delta

-- | Last cost (i.e. the cost of the result).
lastCost :: Result a -> !Double

-- | Result obtained.
result :: Result a -> !a

-- | Pre-processed training vectors (see <a>prepareTraining</a>).
data TrainingData

-- | Prepares training vectors to be used as training data. Anything that
--   depends only on the training vectors is precalculated here.
--   
--   We also try to find columns where all training vectors are zero. Those
--   columns are removed from the derivation process and every component
--   will have zero value on that column. Note that at least one column
--   should have non-zero training vectors.
prepareTraining :: TrainingVectors -> TrainingData

-- | Derive a Dirichlet mixture using a maximum likelihood method as
--   described by Karplus et al (equation 25) using CG_DESCENT method by
--   Hager and Zhang (see
--   <a>Numeric.Optimization.Algorithms.HagerZhang05</a>). All training
--   vectors should have the same length, however this is not verified.
derive :: DirichletMixture -> Predicate -> StepSize -> TrainingData -> Result DirichletMixture

-- | Cost function for deriving a Dirichlet mixture (equation 18). This
--   function is minimized by <a>derive</a>. Calculated using (17) and
--   (54).
cost :: TrainingData -> DirichletMixture -> Double
