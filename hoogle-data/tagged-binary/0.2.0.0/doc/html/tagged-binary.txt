-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Provides tools for serializing data tagged with type
information.
--   
@package tagged-binary
@version 0.2.0.0


-- | Internals for the library, exported in case you should need it.
--   Usually, the parts you would need should be re-exported in
--   <a>Tagged</a>.
module Data.Binary.Tagged.Internal

-- | A data type tupling together data with a <a>TagFingerprint</a>,
--   representing data tagged with its type.
--   
--   It's best to interface directly with data using <tt>encodeTagged</tt>,
--   <tt>decodeTagged</tt>, etc, using <a>tag</a> to tag data and
--   <tt>extractTagged</tt> to extract data from valid tagged data. This
--   type is exported mostly when you want to specifically decode a
--   <a>ByteString</a> into tagged data, and manually extract it yourself.
--   If you are writing a framework, it is preferred to handle this for the
--   end user.
data Tagged a

-- | A data type representing a fingerprint for a <a>Typeable</a> type.
--   Ideally, this would be <a>Internal'</a>s own <a>Fingerprint</a> types;
--   however, for some reason, the fingerprints for the same data type from
--   the same modules differ between different GHC backends. So for now, it
--   is just a <a>ByteString</a> representation of the name of the type.
--   This is literally a bad idea, and so two types with the same name but
--   from different modules will share a non-unique <a>TagFingerprint</a>.
--   Hopefully in the future when I find out a way to fix this or the GHC
--   backend maintainers find a way to provide consistent type
--   fingerprints, this will be fixed.
--   
--   This type is mostly used for the ability to categorized Tagged items
--   by their type.
--   
--   <a>emptyTagFP</a> gives a <a>TagFingerprint</a> that will most likely
--   never be matched by any actual tag from a real type, so can be used as
--   a test if needed. This replaces functionality that used to come from
--   the <tt>Default</tt> instance.
data TagFingerprint

-- | Wrap data inside a <a>Tagged</a> tuple.
tag :: Typeable a => a -> Tagged a

-- | Extract data out of a <a>Tagged</a>, but only the type of the data
--   matches the type represented by the fingerprint. It is polymorphic on
--   its output and meant to be used when decoding a <a>Tagged</a> item
--   with a desired type.
getTagged :: Typeable a => Tagged a -> Maybe a

-- | Check if the type inside the <a>Tagged</a> matches the fingerprint.
tagMatched :: Typeable a => Tagged a -> Bool

-- | Compute the <a>Fingerprint</a> representing a type. It is non-strict
--   on its parameter, so passing in undefined should work if you want to
--   just get the <a>Fingerprint</a> of a specific type without having data
--   of that type on hand:
--   
--   <pre>
--   typeFingerprint (undefined :: Int)
--   </pre>
typeFingerprint :: Typeable a => a -> TagFingerprint

-- | Extract the <a>Fingerprint</a> out of a <a>Tagged</a>. Mostly used so
--   that you can categorize and associate Tagged items; to check if a
--   <a>Tagged</a> is of a desired typed, <a>getTagged</a> and
--   <a>tagMatched</a> might be more useful.
tagFingerprint :: Tagged a -> TagFingerprint

-- | With a <a>ByteString</a>, expecting tagged data, returns the
--   <a>Fingerprint</a> that the data is tagged with. Returns
--   <tt>Nothing</tt> if the data is not decodable as tagged data. Might
--   accidentally decode untagged data though!
bsFingerprint :: ByteString -> Maybe TagFingerprint

-- | <a>TagFingerprint</a> that is meant to never be matched by any actual
--   normal type's <a>TagFingerprint</a>.
emptyTagFP :: TagFingerprint
instance Typeable TagFingerprint
instance Typeable Tagged
instance Show TagFingerprint
instance Generic TagFingerprint
instance Eq TagFingerprint
instance Ord TagFingerprint
instance Show a => Show (Tagged a)
instance Eq a => Eq (Tagged a)
instance Generic (Tagged a)
instance Datatype D1TagFingerprint
instance Constructor C1_0TagFingerprint
instance Datatype D1Tagged
instance Constructor C1_0Tagged
instance Binary TagLead
instance Binary TagFingerprint
instance Binary a => Binary (Tagged a)


-- | Provides tools for serializing and decoding data into
--   <a>ByteString</a> tagged with information about its type. Really, most
--   of this should be used by libraries and frameworks and abstracted
--   over. Typical use cases are the polymorphic communication channels in
--   distributed computing used by Cloud Haskell and distributed-process
--   --- data of any type can come through the channel, and the framework
--   can chose to ignore, queue, or accept data depending on the type the
--   data is tagged with. Designed to work with cross-platform GHC backends
--   like ghcjs.
--   
--   When decoding data, the result is polymorphic, and you should either
--   allow GHC to infer what you want somehow somewhere, or specify it
--   explicitly.
--   
--   Quick example:
--   
--   <pre>
--   &gt; let x = encodeTagged (1 :: Int)
--   &gt; decodeTagged x :: Maybe Bool
--   Nothing
--   &gt; decodeTagged x :: Maybe Int
--   Just 1
--   </pre>
--   
--   The interface is very similar to that of <a>Dynamic</a>.
--   
--   Also provided here is the internal <a>TagFingerprint</a> data type, so
--   that you can categorize, sort, and queue <a>Tagged</a> or
--   <a>ByteString</a> based on the types they represent.
--   
--   It might be significant to note that the current <a>TagFingerprint</a>
--   implementation is a little shaky; it's a bit tricky getting all GHC
--   platforms to agree on a meaningful <a>TypeRep</a> serialization, and
--   we will have a better implementation eventually. For now, it just uses
--   an MD5 hash of the string name of the type. So for now, don't
--   encode/decode things with the same type name but exist in different
--   modules (<a>Text</a> or <a>Text</a>, for example) through the same
--   polymorphic channel! This is a bit limiting, admittedly, but until I
--   or the backend maintainers find out a way to ensure that type
--   fingerprints match up per backend, be aware of this limitation.
module Data.Binary.Tagged

-- | Encode data into a <a>ByteString</a> with its type data tagged.
--   
--   Remember that for now, types are distinguished by their string names,
--   so two types of the same name in different modules will not have
--   unique tags.
encodeTagged :: (Binary a, Typeable a) => a -> ByteString

-- | Decode tagged data from a <a>ByteString</a>. The return type is
--   polymorphic, so it'll attempt to decode it by inferred or specified
--   type.
--   
--   <ul>
--   <li>If the data is not decoded, <tt>Nothing</tt> is returned.</li>
--   <li>If successfully decoded data is tagged with a <a>Fingerprint</a>
--   not matching the desired type, <tt>Nothing</tt> is also returned.</li>
--   <li>If the data is successfully decoded *and* the tagged
--   <a>Fingerprint</a> matches the desired type, <tt>Just x</tt> is
--   returned, where <tt>x</tt> is the originally encoded data (with its
--   tag stripped).</li>
--   </ul>
decodeTagged :: (Binary a, Typeable a) => ByteString -> Maybe a

-- | With a <a>ByteString</a>, expecting tagged data, returns the
--   <a>Fingerprint</a> that the data is tagged with. Returns
--   <tt>Nothing</tt> if the data is not decodable as tagged data. Might
--   accidentally decode untagged data though!
bsFingerprint :: ByteString -> Maybe TagFingerprint

-- | A data type tupling together data with a <a>TagFingerprint</a>,
--   representing data tagged with its type.
--   
--   It's best to interface directly with data using <tt>encodeTagged</tt>,
--   <tt>decodeTagged</tt>, etc, using <a>tag</a> to tag data and
--   <tt>extractTagged</tt> to extract data from valid tagged data. This
--   type is exported mostly when you want to specifically decode a
--   <a>ByteString</a> into tagged data, and manually extract it yourself.
--   If you are writing a framework, it is preferred to handle this for the
--   end user.
data Tagged a

-- | A data type representing a fingerprint for a <a>Typeable</a> type.
--   Ideally, this would be <a>Internal'</a>s own <a>Fingerprint</a> types;
--   however, for some reason, the fingerprints for the same data type from
--   the same modules differ between different GHC backends. So for now, it
--   is just a <a>ByteString</a> representation of the name of the type.
--   This is literally a bad idea, and so two types with the same name but
--   from different modules will share a non-unique <a>TagFingerprint</a>.
--   Hopefully in the future when I find out a way to fix this or the GHC
--   backend maintainers find a way to provide consistent type
--   fingerprints, this will be fixed.
--   
--   This type is mostly used for the ability to categorized Tagged items
--   by their type.
--   
--   <a>emptyTagFP</a> gives a <a>TagFingerprint</a> that will most likely
--   never be matched by any actual tag from a real type, so can be used as
--   a test if needed. This replaces functionality that used to come from
--   the <tt>Default</tt> instance.
data TagFingerprint

-- | Compute the <a>Fingerprint</a> representing a type. It is non-strict
--   on its parameter, so passing in undefined should work if you want to
--   just get the <a>Fingerprint</a> of a specific type without having data
--   of that type on hand:
--   
--   <pre>
--   typeFingerprint (undefined :: Int)
--   </pre>
typeFingerprint :: Typeable a => a -> TagFingerprint
