-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Literal for regular expression
--   
--   Literal notation for regular expression with QuasiQuotes
@package relit
@version 0.1.3


-- | Literal notation for regular expression.
--   
--   Importing this module with the <tt>QuasiQuotes</tt> and
--   <tt>OverloadedStrings</tt> extensions making possible to directly
--   specify reqular expression literal. This means that awkward
--   backslashes are not necessary.
--   
--   You can copy a regular expression in other languages and paste it to
--   your Haskell program.
--   
--   Sample code:
--   
--   <pre>
--   {-# LANGUAGE QuasiQuotes, OverloadedStrings #-}
--   
--   import Text.Regex.Literal
--   import Text.Regex.Posix
--   
--   -- Regular expression as the regular expression literal
--   regexp :: Regex
--   regexp = [$re|\\(foo)\\(bar\.c)|]
--   </pre>
--   
--   Compare with regular expression as the String literal.
--   
--   <pre>
--   regexp :: Regex
--   regexp = makeRegex ("\\\\(foo)\\\\(bar\\.c)" :: String)
--   </pre>
--   
--   GHC 6.12.3 or earlier requires the dollar sign before "re".
--   
--   GHC 7.0.1 does not allow the dollar sign before "re".
--   
--   GHC 7.0.2 or later allows the dollar sign before "re" as an obsoleted
--   syntax.
--   
--   So, use GHC other than 7.0.1 and specify the dollor sign for
--   portability.
module Text.Regex.Literal

-- | A <a>QuasiQuoter</a> function to implement regular expression literal.
re :: QuasiQuoter
instance RegexMaker regex compOpt execOpt String => IsString regex
