-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Translates high-level definitions of "fuzzily" scheduled objects (e.g. play this commercial 10 times per hour between 9:00-13:00) to a list of accurately scheduled objects using glpk-hs.
--   
@package fuzzy-timings
@version 0.0.1

module FuzzyTimings.TimeOfDaySlice
data TimeOfDaySlice a
TimeOfDaySlice :: TimeOfDay -> TimeOfDay -> a -> TimeOfDaySlice a
todsStart :: TimeOfDaySlice a -> TimeOfDay
todsEnd :: TimeOfDaySlice a -> TimeOfDay
todsValue :: TimeOfDaySlice a -> a
mkTimeOfDaySlice :: TimeOfDay -> Int -> a -> TimeOfDaySlice a
todsOverlaps :: TimeOfDaySlice a -> TimeOfDaySlice b -> Bool
instance Show a => Show (TimeOfDaySlice a)
instance Ord (TimeOfDaySlice a)
instance Eq (TimeOfDaySlice a)

module FuzzyTimings.TimeSlice
data TimeSlice a
TimeSlice :: LocalTime -> LocalTime -> a -> TimeSlice a
tsStart :: TimeSlice a -> LocalTime
tsEnd :: TimeSlice a -> LocalTime
tsValue :: TimeSlice a -> a
tsDuration :: TimeSlice a -> Int
mkTimeSlice :: LocalTime -> Int -> a -> TimeSlice a
overlaps :: TimeSlice a -> TimeSlice b -> Bool
addSecs :: Int -> LocalTime -> LocalTime
inTimeSlice :: TimeSlice a -> LocalTime -> Bool
intersectTimeSlice :: TimeSlice a -> TimeSlice b -> Maybe (TimeSlice a)
deleteTimeSlice :: TimeSlice a -> TimeSlice b -> [TimeSlice a]
cutTimeSlice :: [LocalTime] -> TimeSlice a -> [TimeSlice a]
instance Show a => Show (TimeSlice a)
instance Ord (TimeSlice a)
instance Eq (TimeSlice a)

module FuzzyTimings.SlicedTime
data SlicedTime a
fromTimeSlices :: [TimeSlice a] -> SlicedTime a
toTimeSlices :: SlicedTime a -> [TimeSlice a]
fromBoundaries :: [LocalTime] -> a -> SlicedTime a
flattenSlicedTime :: SlicedTime a -> SlicedTime a
intersectSlicedTime :: SlicedTime a -> SlicedTime b -> SlicedTime a
deleteSlicedTime :: SlicedTime a -> SlicedTime b -> SlicedTime a
slicedTimeBoundaries :: SlicedTime a -> [LocalTime]
cutSlicedTime :: SlicedTime a -> [LocalTime] -> SlicedTime a
mapSlicedTime :: SlicedTime a -> (TimeSlice a -> Maybe (TimeSlice a)) -> SlicedTime a
instance Show a => Show (SlicedTime a)
instance Eq (SlicedTime a)

module FuzzyTimings.WeeklySlicedTime
data WeeklySlicedTime a
fromTimeOfDaySlices :: [(WeekDay, [TimeOfDaySlice a])] -> WeeklySlicedTime a
toTimeOfDaySlices :: WeeklySlicedTime a -> [(WeekDay, [TimeOfDaySlice a])]
flattenWeeklySlicedTime :: WeeklySlicedTime a -> WeeklySlicedTime a
implementWeeklySlicedTime :: WeeklySlicedTime a -> Day -> Day -> SlicedTime a
instance Show a => Show (WeeklySlicedTime a)
instance Eq (WeeklySlicedTime a)

module FuzzyTimings.FuzzyTiming

-- | <a>Fuzzily</a> timed object that is to be scheduled a number of times
--   within a period of time.
data FuzzyTiming k
FuzzyTiming :: k -> SlicedTime TimesToPlay -> Int -> FuzzyTiming k
ftId :: FuzzyTiming k -> k
ftPlayTimes :: FuzzyTiming k -> SlicedTime TimesToPlay
ftDuration :: FuzzyTiming k -> Int
ftPlayCount :: FuzzyTiming k -> Double
cropFuzzyTiming :: SlicedTime () -> FuzzyTiming k -> FuzzyTiming k
type TimesToPlay = Double
instance Show k => Show (FuzzyTiming k)
instance Ord k => Ord (FuzzyTiming k)
instance Eq k => Eq (FuzzyTiming k)

module FuzzyTimings.AccTiming

-- | Accurately timed object with duration
data AccTiming k
AccTiming :: k -> LocalTime -> Int -> AccTiming k
atId :: AccTiming k -> k
atTime :: AccTiming k -> LocalTime
atDuration :: AccTiming k -> Int
instance Show k => Show (AccTiming k)
instance Eq k => Eq (AccTiming k)

module FuzzyTimings.TimingBuckets
type FuzzyCountMap k = Map (FuzzyTiming k) TimesToPlay
type TimingBuckets k = SlicedTime (FuzzyCountMap k)
splitToTimingBuckets :: Ord k => [FuzzyTiming k] -> [AccTiming k] -> TimingBuckets k

module FuzzyTimings.Schedule
scheduleTimings :: Show k => SlicedTime (FuzzyCountMap k) -> IO [AccTiming k]

module FuzzyTimings.Solve
solveTimingBuckets :: (Show k, Ord k) => SlicedTime (FuzzyCountMap k) -> IO (Maybe (SlicedTime (FuzzyCountMap k)))
