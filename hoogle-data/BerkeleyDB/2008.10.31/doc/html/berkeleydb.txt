-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Pretty BerkeleyDB v4 binding.
--   
--   This library attempts to provide a memory efficient alternative to
--   Data.Map. The BerkeleyDB system is bound and exposed through an
--   interface that mimics Data.Map as much as possible.
--   
--   Features include: pure interface with fairly efficient sharing and a
--   very small memory footprint.
--   
--   Tested with libdb4.6
@package berkeleydb
@version 2008.10.31


-- | An efficient implementation of maps from keys to values
--   (dictionaries).
--   
--   Since many function names (but not the type name) clash with
--   <a>Prelude</a> names, this module is usually imported
--   <tt>qualified</tt>, e.g.
--   
--   <pre>
--   import Data.BerkeleyDB (DB)
--   import qualified Data.BerkeleyDB as DB
--   </pre>
--   
--   The implementation of <a>Db</a> uses the berkeley db library. See
--   <a>http://en.wikipedia.org/wiki/Berkeley_DB</a> and
--   <a>http://www.oracle.com/technology/products/berkeley-db/index.html</a>
--   
--   Note that this implementation behaves exactly like a <tt>Data.Map.Map
--   ByteString ByteString</tt>, with the key and value encoded by
--   <tt>Data.Binary.encode/Data.Binary.decode</tt>. This means that keys
--   aren't sorted according to Ord. Affected functions are: <a>toList</a>,
--   <a>assocs</a>, <a>elems</a>.
module Data.BerkeleyDB
data Db key value

-- | <i>O(log n)</i>. Find the value at a key. Calls <a>error</a> when the
--   element can not be found.
(!) :: (Binary k, Binary v) => Db k v -> k -> v

-- | <i>O(1)</i>. Is the map empty?
null :: Db key value -> Bool

-- | <i>O(1)</i>. The number of elements in the map.
size :: Db key value -> Int

-- | <i>O(log n)</i>. Is the key a member of the map?
member :: (Binary key, Binary value) => key -> Db key value -> Bool

-- | <i>O(log n)</i>. Is the key not a member of the map?
notMember :: (Binary key, Binary value) => key -> Db key value -> Bool

-- | <i>O(log n)</i>. Lookup the value at a key in the database.
--   
--   The function will <tt>return</tt> the result in the monad or
--   <tt>fail</tt> in it the key isn't in the database. Often, the monad to
--   use is <a>Maybe</a>, so you get either <tt>(<a>Just</a> result)</tt>
--   or <tt><a>Nothing</a></tt>.
lookup :: (Binary key, Binary value, Monad m) => key -> Db key value -> m value

-- | <i>O(log n)</i>. The expression <tt>(<a>findWithDefault</a> def k
--   db)</tt> returns the value at key <tt>k</tt> or returns <tt>def</tt>
--   when the key is not in the database.
findWithDefault :: (Binary k, Binary a) => a -> k -> Db k a -> a

-- | <i>O(1)</i>. The empty database.
empty :: (Binary key, Binary value) => Db key value

-- | <i>O(1)</i>. A map with a single element.
singleton :: (Binary k, Binary a) => k -> a -> Db k a

-- | <i>O(log n)</i>. Insert a new key and value in the database. If the
--   key is already present in the database, the associated value is
--   replaced with the supplied value, i.e. <a>insert</a> is equivalent to
--   <tt><a>insertWith</a> <a>const</a></tt>.
insert :: (Binary key, Binary value) => key -> value -> Db key value -> Db key value

-- | <i>O(log n)</i>. Insert with a combining function.
--   <tt><a>insertWith</a> f key value db</tt> will insert the pair (key,
--   value) into <tt>db</tt> if key does not exist in the database. If the
--   key does exist, the function will insert the pair <tt>(key, f
--   new_value old_value)</tt>.
insertWith :: (Binary k, Binary a) => (a -> a -> a) -> k -> a -> Db k a -> Db k a

-- | <i>O(log n)</i>. Insert with a combining function.
--   <tt><a>insertWithKey</a> f key value db</tt> will insert the pair
--   (key, value) into <tt>db</tt> if key does not exist in the database.
--   If the key does exist, the function will insert the pair <tt>(key,f
--   key new_value old_value)</tt>. Note that the key passed to f is the
--   same key passed to <a>insertWithKey</a>.
insertWithKey :: (Binary k, Binary a) => (k -> a -> a -> a) -> k -> a -> Db k a -> Db k a

-- | <i>O(log n)</i>. Delete a key and its value from the database. When
--   the key is not a member of the database, the original database is
--   returned.
delete :: (Binary key, Binary value) => key -> Db key value -> Db key value

-- | <i>O(log n)</i>. Adjust a value at a specific key. When the key is not
--   a member of the map, the original map is returned.
adjust :: (Binary k, Binary a) => (a -> a) -> k -> Db k a -> Db k a

-- | <i>O(log n)</i>. Adjust a value at a specific key. When the key is not
--   a member of the map, the original map is returned.
adjustWithKey :: (Binary k, Binary a) => (k -> a -> a) -> k -> Db k a -> Db k a

-- | <i>O(log n)</i>. The expression (<tt><a>update</a> f k map</tt>)
--   updates the value <tt>x</tt> at <tt>k</tt> (if it is in the map). If
--   (<tt>f x</tt>) is <a>Nothing</a>, the element is deleted. If it is
--   (<tt><a>Just</a> y</tt>), the key <tt>k</tt> is bound to the new value
--   <tt>y</tt>.
update :: (Binary k, Binary a) => (a -> Maybe a) -> k -> Db k a -> Db k a

-- | <i>O(log n)</i>. The expression (<tt><a>updateWithKey</a> f k db</tt>)
--   updates the value <tt>x</tt> at <tt>k</tt> (if it is in the database).
--   If (<tt>f k x</tt>) is <a>Nothing</a>, the element is deleted. If it
--   is (<tt><a>Just</a> y</tt>), the key <tt>k</tt> is bound to the new
--   value <tt>y</tt>.
updateWithKey :: (Binary k, Binary a) => (k -> a -> Maybe a) -> k -> Db k a -> Db k a

-- | <i>O(log n)</i>. The expression (<tt><a>updateWithKey</a> f k db</tt>)
--   updates the value <tt>x</tt> at <tt>k</tt> (if it is in the database).
--   If (<tt>f k x</tt>) is <a>Nothing</a>, the element is deleted. If it
--   is (<tt><a>Just</a> y</tt>), the key <tt>k</tt> is bound to the new
--   value <tt>y</tt>.
updateLookupWithKey :: (Binary k, Binary a) => (k -> a -> Maybe a) -> k -> Db k a -> (Maybe a, Db k a)

-- | <i>O(log n)</i>. The expression (<tt><a>alter</a> f k db</tt>) alters
--   the value <tt>x</tt> at <tt>k</tt>, or absence thereof. <a>alter</a>
--   can be used to insert, delete, or update a value in a <a>Db</a>. In
--   short : <tt><a>lookup</a> k (<a>alter</a> f k m) = f (<a>lookup</a> k
--   m)</tt>
alter :: (Binary k, Binary a) => (Maybe a -> Maybe a) -> k -> Db k a -> Db k a

-- | <i>O(log n*m)</i>. The expression (<tt><a>union</a> t1 t2</tt>) takes
--   the left-biased union of <tt>t1</tt> and <tt>t2</tt>. It prefers
--   <tt>t1</tt> when duplicate keys are encountered, i.e.
--   (<tt><a>union</a> == <a>unionWith</a> <a>const</a></tt>).
union :: (Binary key, Binary value) => Db key value -> Db key value -> Db key value

-- | <i>O(log n*m)</i>. Union with a combining function.
unionWith :: (Binary key, Binary value) => (value -> value -> value) -> Db key value -> Db key value -> Db key value

-- | <i>O(log n*m))</i>. Union with a combining function. This function is
--   most efficient on (bigset <a>union</a> smallset).
unionWithKey :: (Binary key, Binary value) => (key -> value -> value -> value) -> Db key value -> Db key value -> Db key value

-- | The union of a list of databases: (<tt><a>unions</a> == <a>foldl</a>
--   <a>union</a> <a>empty</a></tt>).
unions :: (Binary k, Binary a) => [Db k a] -> Db k a

-- | The union of a list of databases, with a combining operation:
--   (<tt><a>unionsWith</a> f == <a>foldl</a> (<a>unionWith</a> f)
--   <a>empty</a></tt>).
unionsWith :: (Binary k, Binary a) => (a -> a -> a) -> [Db k a] -> Db k a

-- | <i>O(n)</i>. Map a function over all values in the database.
map :: (Binary a, Binary b, Binary k) => (a -> b) -> Db k a -> Db k b

-- | <i>O(n)</i>. Map a function over all values in the database.
mapWithKey :: (Binary a, Binary b, Binary k) => (k -> a -> b) -> Db k a -> Db k b

-- | <i>O(n)</i>. Fold the values in the map, such that <tt><a>fold</a> f z
--   == <a>foldr</a> f z . <a>elems</a></tt>. For example,
--   
--   <pre>
--   elems map = fold (:) [] map
--   </pre>
fold :: (Binary k, Binary a) => (a -> b -> b) -> b -> Db k a -> b

-- | <i>O(n)</i>. Return all elements of the database in the ascending
--   order of their keys sorted by their binary representation.
elems :: (Binary key, Binary value) => Db key value -> [value]

-- | <i>O(n)</i>. Return all keys of the database in ascending order sorted
--   by their binary representation.
keys :: (Binary key, Binary value) => Db key value -> [key]

-- | <i>O(n)</i>. Return all key/value pairs in the map in ascending key
--   order.
assocs :: (Binary key, Binary value) => Db key value -> [(key, value)]

-- | <i>O(n)</i>. Convert to a list of key/value pairs.
toList :: (Binary key, Binary value) => Db key value -> [(key, value)]

-- | <i>O(n*log n)</i>. Build a database from a list of key/value pairs.
--   See also <tt>fromAscList</tt>.
fromList :: (Binary key, Binary value) => [(key, value)] -> Db key value

-- | <i>O(n*log n)</i>. Build a database from a list of key/value pairs
--   with a combining function.
fromListWith :: (Binary k, Binary a) => (a -> a -> a) -> [(k, a)] -> Db k a

-- | <i>O(n*log n)</i>. Build a database from a list of key/value pairs
--   with a combining function.
fromListWithKey :: (Binary k, Binary a) => (k -> a -> a -> a) -> [(k, a)] -> Db k a

-- | <i>O(n)</i>. Filter all values that satisfy the predicate.
filter :: (Binary k, Binary a) => (a -> Bool) -> Db k a -> Db k a

-- | <i>O(n)</i>. Filter all keys/values that satisfy the predicate.
filterWithKey :: (Binary k, Binary a) => (k -> a -> Bool) -> Db k a -> Db k a
instance Typeable2 Db
instance Show Range
instance (Data k, Data a, Binary k, Binary a) => Data (Db k a)
instance (Binary k, Binary a) => Monoid (Db k a)
instance (Binary key, Binary value, Ord key, Ord value) => Ord (Db key value)
instance (Binary key, Binary value, Eq key, Eq value) => Eq (Db key value)
instance (Binary k, Binary a, Read k, Read a) => Read (Db k a)
instance (Binary key, Binary value, Show key, Show value) => Show (Db key value)
instance (Show key, Show value, Binary key, Binary value) => Binary (Db key value)
