-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Interval Arithmetic
--   
@package intervals
@version 0.7.1

module Numeric.Interval.Exception
data EmptyInterval
EmptyInterval :: EmptyInterval
data AmbiguousComparison
AmbiguousComparison :: AmbiguousComparison
instance Typeable EmptyInterval
instance Typeable AmbiguousComparison
instance Eq EmptyInterval
instance Ord EmptyInterval
instance Data EmptyInterval
instance Eq AmbiguousComparison
instance Ord AmbiguousComparison
instance Data AmbiguousComparison
instance Exception AmbiguousComparison
instance Show AmbiguousComparison
instance Exception EmptyInterval
instance Show EmptyInterval


-- | <a>Directed</a> Interval arithmetic
module Numeric.Interval.Kaucher
data Interval a
I :: !a -> !a -> Interval a

-- | Create a directed interval.
(...) :: a -> a -> Interval a

-- | Try to create a non-empty interval.
interval :: Ord a => a -> a -> Maybe (Interval a)

-- | The whole real number line
--   
--   <pre>
--   &gt;&gt;&gt; whole
--   -Infinity ... Infinity
--   </pre>
whole :: Fractional a => Interval a

-- | An empty interval
--   
--   <pre>
--   &gt;&gt;&gt; empty
--   NaN ... NaN
--   </pre>
empty :: Fractional a => Interval a

-- | negation handles NaN properly
--   
--   <pre>
--   &gt;&gt;&gt; null (1 ... 5)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; null (1 ... 1)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; null empty
--   True
--   </pre>
null :: Ord a => Interval a -> Bool

-- | A singleton point
--   
--   <pre>
--   &gt;&gt;&gt; singleton 1
--   1 ... 1
--   </pre>
singleton :: a -> Interval a

-- | Determine if a point is in the interval.
--   
--   <pre>
--   &gt;&gt;&gt; elem 3.2 (1.0 ... 5.0)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; elem 5 (1.0 ... 5.0)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; elem 1 (1.0 ... 5.0)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; elem 8 (1.0 ... 5.0)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; elem 5 empty
--   False
--   </pre>
elem :: Ord a => a -> Interval a -> Bool

-- | Determine if a point is not included in the interval
--   
--   <pre>
--   &gt;&gt;&gt; notElem 8 (1.0 ... 5.0)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; notElem 1.4 (1.0 ... 5.0)
--   False
--   </pre>
--   
--   And of course, nothing is a member of the empty interval.
--   
--   <pre>
--   &gt;&gt;&gt; notElem 5 empty
--   True
--   </pre>
notElem :: Ord a => a -> Interval a -> Bool

-- | The infinumum (lower bound) of an interval
--   
--   <pre>
--   &gt;&gt;&gt; inf (1 ... 20)
--   1
--   </pre>
inf :: Interval a -> a

-- | The supremum (upper bound) of an interval
--   
--   <pre>
--   &gt;&gt;&gt; sup (1 ... 20)
--   20
--   </pre>
sup :: Interval a -> a

-- | Is the interval a singleton point? N.B. This is fairly fragile and
--   likely will not hold after even a few operations that only involve
--   singletons
--   
--   <pre>
--   &gt;&gt;&gt; singular (singleton 1)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; singular (1.0 ... 20.0)
--   False
--   </pre>
singular :: Ord a => Interval a -> Bool

-- | Calculate the width of an interval.
--   
--   <pre>
--   &gt;&gt;&gt; width (1 ... 20)
--   19
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; width (singleton 1)
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; width empty
--   NaN
--   </pre>
width :: Num a => Interval a -> a

-- | Nearest point to the midpoint of the interval.
--   
--   <pre>
--   &gt;&gt;&gt; midpoint (10.0 ... 20.0)
--   15.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; midpoint (singleton 5.0)
--   5.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; midpoint empty
--   NaN
--   </pre>
midpoint :: Fractional a => Interval a -> a

-- | Calculate the intersection of two intervals.
--   
--   <pre>
--   &gt;&gt;&gt; intersection (1 ... 10 :: Interval Double) (5 ... 15 :: Interval Double)
--   5.0 ... 10.0
--   </pre>
intersection :: (Fractional a, Ord a) => Interval a -> Interval a -> Interval a

-- | Calculate the convex hull of two intervals
--   
--   <pre>
--   &gt;&gt;&gt; hull (0 ... 10 :: Interval Double) (5 ... 15 :: Interval Double)
--   0.0 ... 15.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hull (15 ... 85 :: Interval Double) (0 ... 10 :: Interval Double)
--   0.0 ... 85.0
--   </pre>
hull :: Ord a => Interval a -> Interval a -> Interval a

-- | Bisect an interval at its midpoint.
--   
--   <pre>
--   &gt;&gt;&gt; bisect (10.0 ... 20.0)
--   (10.0 ... 15.0,15.0 ... 20.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bisect (singleton 5.0)
--   (5.0 ... 5.0,5.0 ... 5.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bisect empty
--   (NaN ... NaN,NaN ... NaN)
--   </pre>
bisect :: Fractional a => Interval a -> (Interval a, Interval a)

-- | Magnitude
--   
--   <pre>
--   &gt;&gt;&gt; magnitude (1 ... 20)
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; magnitude (-20 ... 10)
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; magnitude (singleton 5)
--   5
--   </pre>
magnitude :: (Num a, Ord a) => Interval a -> a

-- | "mignitude"
--   
--   <pre>
--   &gt;&gt;&gt; mignitude (1 ... 20)
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mignitude (-20 ... 10)
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mignitude (singleton 5)
--   5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mignitude empty
--   NaN
--   </pre>
mignitude :: (Num a, Ord a) => Interval a -> a

-- | Hausdorff distance between non-empty intervals.
--   
--   <pre>
--   &gt;&gt;&gt; distance (1 ... 7) (6 ... 10)
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; distance (1 ... 7) (15 ... 24)
--   8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; distance (1 ... 7) (-10 ... -2)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; distance empty (1 ... 1)
--   NaN
--   </pre>
distance :: (Num a, Ord a) => Interval a -> Interval a -> a

-- | Inflate an interval by enlarging it at both ends.
--   
--   <pre>
--   &gt;&gt;&gt; inflate 3 (-1 ... 7)
--   -4 ... 10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; inflate (-2) (0 ... 4)
--   2 ... 2
--   </pre>
inflate :: (Num a, Ord a) => a -> Interval a -> Interval a

-- | Deflate an interval by shrinking it from both ends.
--   
--   <pre>
--   &gt;&gt;&gt; deflate 3.0 (-4.0 ... 10.0)
--   -1.0 ... 7.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; deflate 2.0 (-1.0 ... 1.0)
--   1.0 ... -1.0
--   </pre>
deflate :: (Fractional a, Ord a) => a -> Interval a -> Interval a

-- | Scale an interval about its midpoint.
--   
--   <pre>
--   &gt;&gt;&gt; scale 1.1 (-6.0 ... 4.0)
--   -6.5 ... 4.5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scale (-2.0) (-1.0 ... 1.0)
--   2.0 ... -2.0
--   </pre>
scale :: (Fractional a, Ord a) => a -> Interval a -> Interval a

-- | Construct a symmetric interval.
--   
--   <pre>
--   &gt;&gt;&gt; symmetric 3
--   -3 ... 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; symmetric (-2)
--   2 ... -2
--   </pre>
symmetric :: (Num a, Ord a) => a -> Interval a

-- | Check if interval <tt>X</tt> totally contains interval <tt>Y</tt>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 40 :: Interval Double) `contains` (25 ... 35 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 40 :: Interval Double) `contains` (15 ... 35 :: Interval Double)
--   False
--   </pre>
contains :: Ord a => Interval a -> Interval a -> Bool

-- | Flipped version of <a>contains</a>. Check if interval <tt>X</tt> a
--   subset of interval <tt>Y</tt>
--   
--   <pre>
--   &gt;&gt;&gt; (25 ... 35 :: Interval Double) `isSubsetOf` (20 ... 40 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 40 :: Interval Double) `isSubsetOf` (15 ... 35 :: Interval Double)
--   False
--   </pre>
isSubsetOf :: Ord a => Interval a -> Interval a -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <tt>op</tt> y</tt>
certainly :: Ord a => (forall b. Ord b => b -> b -> Bool) -> Interval a -> Interval a -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&lt;</a> y</tt>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 10 :: Interval Double) &lt;! (20 ... 30 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 10 :: Interval Double) &lt;! (10 ... 30 :: Interval Double)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 30 :: Interval Double) &lt;! (5 ... 10 :: Interval Double)
--   False
--   </pre>
(<!) :: Ord a => Interval a -> Interval a -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&lt;=</a> y</tt>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 10 :: Interval Double) &lt;=! (20 ... 30 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 10 :: Interval Double) &lt;=! (10 ... 30 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 30 :: Interval Double) &lt;=! (5 ... 10 :: Interval Double)
--   False
--   </pre>
(<=!) :: Ord a => Interval a -> Interval a -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>==</a> y</tt>
--   
--   Only singleton intervals return true
--   
--   <pre>
--   &gt;&gt;&gt; (singleton 5 :: Interval Double) ==! (singleton 5 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 10 :: Interval Double) ==! (5 ... 10 :: Interval Double)
--   False
--   </pre>
(==!) :: Eq a => Interval a -> Interval a -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&gt;=</a> y</tt>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 40 :: Interval Double) &gt;=! (10 ... 20 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 20 :: Interval Double) &gt;=! (15 ... 40 :: Interval Double)
--   False
--   </pre>
(>=!) :: Ord a => Interval a -> Interval a -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&gt;</a> y</tt>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 40 :: Interval Double) &gt;! (10 ... 19 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 20 :: Interval Double) &gt;! (15 ... 40 :: Interval Double)
--   False
--   </pre>
(>!) :: Ord a => Interval a -> Interval a -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <tt>op</tt> y</tt>?
possibly :: Ord a => (forall b. Ord b => b -> b -> Bool) -> Interval a -> Interval a -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&lt;</a> y</tt>?
(<?) :: Ord a => Interval a -> Interval a -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&lt;=</a> y</tt>?
(<=?) :: Ord a => Interval a -> Interval a -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>==</a> y</tt>?
(==?) :: Ord a => Interval a -> Interval a -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&gt;=</a> y</tt>?
(>=?) :: Ord a => Interval a -> Interval a -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&gt;</a> y</tt>?
(>?) :: Ord a => Interval a -> Interval a -> Bool

-- | The nearest value to that supplied which is contained in the interval.
clamp :: Ord a => Interval a -> a -> a

-- | id function. Useful for type specification
--   
--   <pre>
--   &gt;&gt;&gt; :t idouble (1 ... 3)
--   idouble (1 ... 3) :: Interval Double
--   </pre>
idouble :: Interval Double -> Interval Double

-- | id function. Useful for type specification
--   
--   <pre>
--   &gt;&gt;&gt; :t ifloat (1 ... 3)
--   ifloat (1 ... 3) :: Interval Float
--   </pre>
ifloat :: Interval Float -> Interval Float
instance Typeable Interval
instance Data a => Data (Interval a)
instance Generic (Interval a)
instance Generic1 Interval
instance Datatype D1Interval
instance Constructor C1_0Interval
instance RealFloat a => RealFloat (Interval a)
instance (RealFloat a, Ord a) => Floating (Interval a)
instance RealFrac a => RealFrac (Interval a)
instance (Fractional a, Ord a) => Fractional (Interval a)
instance Ord a => Ord (Interval a)
instance Real a => Real (Interval a)
instance (Num a, Ord a) => Num (Interval a)
instance Show a => Show (Interval a)
instance Eq a => Eq (Interval a)
instance Distributive Interval
instance Monad Interval
instance Applicative Interval
instance Traversable Interval
instance Foldable Interval
instance Functor Interval


-- | Interval arithmetic
module Numeric.Interval.NonEmpty.Internal
data Interval a
I :: !a -> !a -> Interval a

-- | Create a non-empty interval, turning it around if necessary
(...) :: Ord a => a -> a -> Interval a

-- | Try to create a non-empty interval.
interval :: Ord a => a -> a -> Maybe (Interval a)

-- | The whole real number line
--   
--   <pre>
--   &gt;&gt;&gt; whole
--   -Infinity ... Infinity
--   </pre>
whole :: Fractional a => Interval a

-- | A singleton point
--   
--   <pre>
--   &gt;&gt;&gt; singleton 1
--   1 ... 1
--   </pre>
singleton :: a -> Interval a

-- | Determine if a point is in the interval.
--   
--   <pre>
--   &gt;&gt;&gt; elem 3.2 (1.0 ... 5.0)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; elem 5 (1.0 ... 5.0)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; elem 1 (1.0 ... 5.0)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; elem 8 (1.0 ... 5.0)
--   False
--   </pre>
elem :: Ord a => a -> Interval a -> Bool

-- | Determine if a point is not included in the interval
--   
--   <pre>
--   &gt;&gt;&gt; notElem 8 (1.0 ... 5.0)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; notElem 1.4 (1.0 ... 5.0)
--   False
--   </pre>
notElem :: Ord a => a -> Interval a -> Bool

-- | The infinumum (lower bound) of an interval
--   
--   <pre>
--   &gt;&gt;&gt; inf (1 ... 20)
--   1
--   </pre>
inf :: Interval a -> a

-- | The supremum (upper bound) of an interval
--   
--   <pre>
--   &gt;&gt;&gt; sup (1 ... 20)
--   20
--   </pre>
sup :: Interval a -> a

-- | Is the interval a singleton point? N.B. This is fairly fragile and
--   likely will not hold after even a few operations that only involve
--   singletons
--   
--   <pre>
--   &gt;&gt;&gt; singular (singleton 1)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; singular (1.0 ... 20.0)
--   False
--   </pre>
singular :: Ord a => Interval a -> Bool

-- | Calculate the width of an interval.
--   
--   <pre>
--   &gt;&gt;&gt; width (1 ... 20)
--   19
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; width (singleton 1)
--   0
--   </pre>
width :: Num a => Interval a -> a

-- | Nearest point to the midpoint of the interval.
--   
--   <pre>
--   &gt;&gt;&gt; midpoint (10.0 ... 20.0)
--   15.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; midpoint (singleton 5.0)
--   5.0
--   </pre>
midpoint :: Fractional a => Interval a -> a

-- | Hausdorff distance between intervals.
--   
--   <pre>
--   &gt;&gt;&gt; distance (1 ... 7) (6 ... 10)
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; distance (1 ... 7) (15 ... 24)
--   8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; distance (1 ... 7) (-10 ... -2)
--   3
--   </pre>
distance :: (Num a, Ord a) => Interval a -> Interval a -> a

-- | Calculate the intersection of two intervals.
--   
--   <pre>
--   &gt;&gt;&gt; intersection (1 ... 10 :: Interval Double) (5 ... 15 :: Interval Double)
--   Just (5.0 ... 10.0)
--   </pre>
intersection :: Ord a => Interval a -> Interval a -> Maybe (Interval a)

-- | Calculate the convex hull of two intervals
--   
--   <pre>
--   &gt;&gt;&gt; hull (0 ... 10 :: Interval Double) (5 ... 15 :: Interval Double)
--   0.0 ... 15.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hull (15 ... 85 :: Interval Double) (0 ... 10 :: Interval Double)
--   0.0 ... 85.0
--   </pre>
hull :: Ord a => Interval a -> Interval a -> Interval a

-- | Bisect an interval at its midpoint.
--   
--   <pre>
--   &gt;&gt;&gt; bisect (10.0 ... 20.0)
--   (10.0 ... 15.0,15.0 ... 20.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bisect (singleton 5.0)
--   (5.0 ... 5.0,5.0 ... 5.0)
--   </pre>
bisect :: Fractional a => Interval a -> (Interval a, Interval a)
bisectIntegral :: Integral a => Interval a -> (Interval a, Interval a)

-- | Magnitude
--   
--   <pre>
--   &gt;&gt;&gt; magnitude (1 ... 20)
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; magnitude (-20 ... 10)
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; magnitude (singleton 5)
--   5
--   </pre>
magnitude :: (Num a, Ord a) => Interval a -> a

-- | "mignitude"
--   
--   <pre>
--   &gt;&gt;&gt; mignitude (1 ... 20)
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mignitude (-20 ... 10)
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mignitude (singleton 5)
--   5
--   </pre>
mignitude :: (Num a, Ord a) => Interval a -> a

-- | Check if interval <tt>X</tt> totally contains interval <tt>Y</tt>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 40 :: Interval Double) `contains` (25 ... 35 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 40 :: Interval Double) `contains` (15 ... 35 :: Interval Double)
--   False
--   </pre>
contains :: Ord a => Interval a -> Interval a -> Bool

-- | Flipped version of <a>contains</a>. Check if interval <tt>X</tt> a
--   subset of interval <tt>Y</tt>
--   
--   <pre>
--   &gt;&gt;&gt; (25 ... 35 :: Interval Double) `isSubsetOf` (20 ... 40 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 40 :: Interval Double) `isSubsetOf` (15 ... 35 :: Interval Double)
--   False
--   </pre>
isSubsetOf :: Ord a => Interval a -> Interval a -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <tt>op</tt> y</tt>
certainly :: Ord a => (forall b. Ord b => b -> b -> Bool) -> Interval a -> Interval a -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&lt;</a> y</tt>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 10 :: Interval Double) &lt;! (20 ... 30 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 10 :: Interval Double) &lt;! (10 ... 30 :: Interval Double)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 30 :: Interval Double) &lt;! (5 ... 10 :: Interval Double)
--   False
--   </pre>
(<!) :: Ord a => Interval a -> Interval a -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&lt;=</a> y</tt>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 10 :: Interval Double) &lt;=! (20 ... 30 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 10 :: Interval Double) &lt;=! (10 ... 30 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 30 :: Interval Double) &lt;=! (5 ... 10 :: Interval Double)
--   False
--   </pre>
(<=!) :: Ord a => Interval a -> Interval a -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>==</a> y</tt>
--   
--   Only singleton intervals or empty intervals can return true
--   
--   <pre>
--   &gt;&gt;&gt; (singleton 5 :: Interval Double) ==! (singleton 5 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 10 :: Interval Double) ==! (5 ... 10 :: Interval Double)
--   False
--   </pre>
(==!) :: Eq a => Interval a -> Interval a -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&gt;=</a> y</tt>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 40 :: Interval Double) &gt;=! (10 ... 20 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 20 :: Interval Double) &gt;=! (15 ... 40 :: Interval Double)
--   False
--   </pre>
(>=!) :: Ord a => Interval a -> Interval a -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&gt;</a> y</tt>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 40 :: Interval Double) &gt;! (10 ... 19 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 20 :: Interval Double) &gt;! (15 ... 40 :: Interval Double)
--   False
--   </pre>
(>!) :: Ord a => Interval a -> Interval a -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <tt>op</tt> y</tt>?
possibly :: Ord a => (forall b. Ord b => b -> b -> Bool) -> Interval a -> Interval a -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&lt;</a> y</tt>?
(<?) :: Ord a => Interval a -> Interval a -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&lt;=</a> y</tt>?
(<=?) :: Ord a => Interval a -> Interval a -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>==</a> y</tt>?
(==?) :: Ord a => Interval a -> Interval a -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&gt;=</a> y</tt>?
(>=?) :: Ord a => Interval a -> Interval a -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&gt;</a> y</tt>?
(>?) :: Ord a => Interval a -> Interval a -> Bool

-- | The nearest value to that supplied which is contained in the interval.
clamp :: Ord a => Interval a -> a -> a

-- | Inflate an interval by enlarging it at both ends.
--   
--   <pre>
--   &gt;&gt;&gt; inflate 3 (-1 ... 7)
--   -4 ... 10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; inflate (-2) (0 ... 4)
--   -2 ... 6
--   </pre>
inflate :: (Num a, Ord a) => a -> Interval a -> Interval a

-- | Deflate an interval by shrinking it from both ends. Note that in cases
--   that would result in an empty interval, the result is a singleton
--   interval at the midpoint.
--   
--   <pre>
--   &gt;&gt;&gt; deflate 3.0 (-4.0 ... 10.0)
--   -1.0 ... 7.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; deflate 2.0 (-1.0 ... 1.0)
--   0.0 ... 0.0
--   </pre>
deflate :: (Fractional a, Ord a) => a -> Interval a -> Interval a

-- | Scale an interval about its midpoint.
--   
--   <pre>
--   &gt;&gt;&gt; scale 1.1 (-6.0 ... 4.0)
--   -6.5 ... 4.5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scale (-2.0) (-1.0 ... 1.0)
--   -2.0 ... 2.0
--   </pre>
scale :: (Fractional a, Ord a) => a -> Interval a -> Interval a

-- | Construct a symmetric interval.
--   
--   <pre>
--   &gt;&gt;&gt; symmetric 3
--   -3 ... 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; symmetric (-2)
--   -2 ... 2
--   </pre>
symmetric :: (Num a, Ord a) => a -> Interval a

-- | id function. Useful for type specification
--   
--   <pre>
--   &gt;&gt;&gt; :t idouble (1 ... 3)
--   idouble (1 ... 3) :: Interval Double
--   </pre>
idouble :: Interval Double -> Interval Double

-- | id function. Useful for type specification
--   
--   <pre>
--   &gt;&gt;&gt; :t ifloat (1 ... 3)
--   ifloat (1 ... 3) :: Interval Float
--   </pre>
ifloat :: Interval Float -> Interval Float
instance Typeable Interval
instance Data a => Data (Interval a)
instance Generic (Interval a)
instance Generic1 Interval
instance Datatype D1Interval
instance Constructor C1_0Interval
instance RealFloat a => RealFloat (Interval a)
instance (RealFloat a, Ord a) => Floating (Interval a)
instance RealFrac a => RealFrac (Interval a)
instance (Fractional a, Ord a) => Fractional (Interval a)
instance Ord a => Ord (Interval a)
instance Real a => Real (Interval a)
instance (Num a, Ord a) => Num (Interval a)
instance Show a => Show (Interval a)
instance Eq a => Eq (Interval a)
instance Foldable Interval


-- | Interval arithmetic
module Numeric.Interval.NonEmpty
data Interval a

-- | Create a non-empty interval, turning it around if necessary
(...) :: Ord a => a -> a -> Interval a

-- | Try to create a non-empty interval.
interval :: Ord a => a -> a -> Maybe (Interval a)

-- | The whole real number line
--   
--   <pre>
--   &gt;&gt;&gt; whole
--   -Infinity ... Infinity
--   </pre>
whole :: Fractional a => Interval a

-- | A singleton point
--   
--   <pre>
--   &gt;&gt;&gt; singleton 1
--   1 ... 1
--   </pre>
singleton :: a -> Interval a

-- | Determine if a point is in the interval.
--   
--   <pre>
--   &gt;&gt;&gt; elem 3.2 (1.0 ... 5.0)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; elem 5 (1.0 ... 5.0)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; elem 1 (1.0 ... 5.0)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; elem 8 (1.0 ... 5.0)
--   False
--   </pre>
elem :: Ord a => a -> Interval a -> Bool

-- | Determine if a point is not included in the interval
--   
--   <pre>
--   &gt;&gt;&gt; notElem 8 (1.0 ... 5.0)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; notElem 1.4 (1.0 ... 5.0)
--   False
--   </pre>
notElem :: Ord a => a -> Interval a -> Bool

-- | The infinumum (lower bound) of an interval
--   
--   <pre>
--   &gt;&gt;&gt; inf (1 ... 20)
--   1
--   </pre>
inf :: Interval a -> a

-- | The supremum (upper bound) of an interval
--   
--   <pre>
--   &gt;&gt;&gt; sup (1 ... 20)
--   20
--   </pre>
sup :: Interval a -> a

-- | Is the interval a singleton point? N.B. This is fairly fragile and
--   likely will not hold after even a few operations that only involve
--   singletons
--   
--   <pre>
--   &gt;&gt;&gt; singular (singleton 1)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; singular (1.0 ... 20.0)
--   False
--   </pre>
singular :: Ord a => Interval a -> Bool

-- | Calculate the width of an interval.
--   
--   <pre>
--   &gt;&gt;&gt; width (1 ... 20)
--   19
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; width (singleton 1)
--   0
--   </pre>
width :: Num a => Interval a -> a

-- | Nearest point to the midpoint of the interval.
--   
--   <pre>
--   &gt;&gt;&gt; midpoint (10.0 ... 20.0)
--   15.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; midpoint (singleton 5.0)
--   5.0
--   </pre>
midpoint :: Fractional a => Interval a -> a

-- | Hausdorff distance between intervals.
--   
--   <pre>
--   &gt;&gt;&gt; distance (1 ... 7) (6 ... 10)
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; distance (1 ... 7) (15 ... 24)
--   8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; distance (1 ... 7) (-10 ... -2)
--   3
--   </pre>
distance :: (Num a, Ord a) => Interval a -> Interval a -> a

-- | Calculate the intersection of two intervals.
--   
--   <pre>
--   &gt;&gt;&gt; intersection (1 ... 10 :: Interval Double) (5 ... 15 :: Interval Double)
--   Just (5.0 ... 10.0)
--   </pre>
intersection :: Ord a => Interval a -> Interval a -> Maybe (Interval a)

-- | Calculate the convex hull of two intervals
--   
--   <pre>
--   &gt;&gt;&gt; hull (0 ... 10 :: Interval Double) (5 ... 15 :: Interval Double)
--   0.0 ... 15.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hull (15 ... 85 :: Interval Double) (0 ... 10 :: Interval Double)
--   0.0 ... 85.0
--   </pre>
hull :: Ord a => Interval a -> Interval a -> Interval a

-- | Bisect an interval at its midpoint.
--   
--   <pre>
--   &gt;&gt;&gt; bisect (10.0 ... 20.0)
--   (10.0 ... 15.0,15.0 ... 20.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bisect (singleton 5.0)
--   (5.0 ... 5.0,5.0 ... 5.0)
--   </pre>
bisect :: Fractional a => Interval a -> (Interval a, Interval a)
bisectIntegral :: Integral a => Interval a -> (Interval a, Interval a)

-- | Magnitude
--   
--   <pre>
--   &gt;&gt;&gt; magnitude (1 ... 20)
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; magnitude (-20 ... 10)
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; magnitude (singleton 5)
--   5
--   </pre>
magnitude :: (Num a, Ord a) => Interval a -> a

-- | "mignitude"
--   
--   <pre>
--   &gt;&gt;&gt; mignitude (1 ... 20)
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mignitude (-20 ... 10)
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mignitude (singleton 5)
--   5
--   </pre>
mignitude :: (Num a, Ord a) => Interval a -> a

-- | Check if interval <tt>X</tt> totally contains interval <tt>Y</tt>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 40 :: Interval Double) `contains` (25 ... 35 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 40 :: Interval Double) `contains` (15 ... 35 :: Interval Double)
--   False
--   </pre>
contains :: Ord a => Interval a -> Interval a -> Bool

-- | Flipped version of <a>contains</a>. Check if interval <tt>X</tt> a
--   subset of interval <tt>Y</tt>
--   
--   <pre>
--   &gt;&gt;&gt; (25 ... 35 :: Interval Double) `isSubsetOf` (20 ... 40 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 40 :: Interval Double) `isSubsetOf` (15 ... 35 :: Interval Double)
--   False
--   </pre>
isSubsetOf :: Ord a => Interval a -> Interval a -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <tt>op</tt> y</tt>
certainly :: Ord a => (forall b. Ord b => b -> b -> Bool) -> Interval a -> Interval a -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&lt;</a> y</tt>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 10 :: Interval Double) &lt;! (20 ... 30 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 10 :: Interval Double) &lt;! (10 ... 30 :: Interval Double)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 30 :: Interval Double) &lt;! (5 ... 10 :: Interval Double)
--   False
--   </pre>
(<!) :: Ord a => Interval a -> Interval a -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&lt;=</a> y</tt>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 10 :: Interval Double) &lt;=! (20 ... 30 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 10 :: Interval Double) &lt;=! (10 ... 30 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 30 :: Interval Double) &lt;=! (5 ... 10 :: Interval Double)
--   False
--   </pre>
(<=!) :: Ord a => Interval a -> Interval a -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>==</a> y</tt>
--   
--   Only singleton intervals or empty intervals can return true
--   
--   <pre>
--   &gt;&gt;&gt; (singleton 5 :: Interval Double) ==! (singleton 5 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 10 :: Interval Double) ==! (5 ... 10 :: Interval Double)
--   False
--   </pre>
(==!) :: Eq a => Interval a -> Interval a -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&gt;=</a> y</tt>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 40 :: Interval Double) &gt;=! (10 ... 20 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 20 :: Interval Double) &gt;=! (15 ... 40 :: Interval Double)
--   False
--   </pre>
(>=!) :: Ord a => Interval a -> Interval a -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&gt;</a> y</tt>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 40 :: Interval Double) &gt;! (10 ... 19 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 20 :: Interval Double) &gt;! (15 ... 40 :: Interval Double)
--   False
--   </pre>
(>!) :: Ord a => Interval a -> Interval a -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <tt>op</tt> y</tt>?
possibly :: Ord a => (forall b. Ord b => b -> b -> Bool) -> Interval a -> Interval a -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&lt;</a> y</tt>?
(<?) :: Ord a => Interval a -> Interval a -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&lt;=</a> y</tt>?
(<=?) :: Ord a => Interval a -> Interval a -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>==</a> y</tt>?
(==?) :: Ord a => Interval a -> Interval a -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&gt;=</a> y</tt>?
(>=?) :: Ord a => Interval a -> Interval a -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&gt;</a> y</tt>?
(>?) :: Ord a => Interval a -> Interval a -> Bool

-- | The nearest value to that supplied which is contained in the interval.
clamp :: Ord a => Interval a -> a -> a

-- | Inflate an interval by enlarging it at both ends.
--   
--   <pre>
--   &gt;&gt;&gt; inflate 3 (-1 ... 7)
--   -4 ... 10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; inflate (-2) (0 ... 4)
--   -2 ... 6
--   </pre>
inflate :: (Num a, Ord a) => a -> Interval a -> Interval a

-- | Deflate an interval by shrinking it from both ends. Note that in cases
--   that would result in an empty interval, the result is a singleton
--   interval at the midpoint.
--   
--   <pre>
--   &gt;&gt;&gt; deflate 3.0 (-4.0 ... 10.0)
--   -1.0 ... 7.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; deflate 2.0 (-1.0 ... 1.0)
--   0.0 ... 0.0
--   </pre>
deflate :: (Fractional a, Ord a) => a -> Interval a -> Interval a

-- | Scale an interval about its midpoint.
--   
--   <pre>
--   &gt;&gt;&gt; scale 1.1 (-6.0 ... 4.0)
--   -6.5 ... 4.5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scale (-2.0) (-1.0 ... 1.0)
--   -2.0 ... 2.0
--   </pre>
scale :: (Fractional a, Ord a) => a -> Interval a -> Interval a

-- | Construct a symmetric interval.
--   
--   <pre>
--   &gt;&gt;&gt; symmetric 3
--   -3 ... 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; symmetric (-2)
--   -2 ... 2
--   </pre>
symmetric :: (Num a, Ord a) => a -> Interval a

-- | id function. Useful for type specification
--   
--   <pre>
--   &gt;&gt;&gt; :t idouble (1 ... 3)
--   idouble (1 ... 3) :: Interval Double
--   </pre>
idouble :: Interval Double -> Interval Double

-- | id function. Useful for type specification
--   
--   <pre>
--   &gt;&gt;&gt; :t ifloat (1 ... 3)
--   ifloat (1 ... 3) :: Interval Float
--   </pre>
ifloat :: Interval Float -> Interval Float


-- | Interval arithmetic
module Numeric.Interval.Internal
data Interval a
I :: !a -> !a -> Interval a
Empty :: Interval a
(...) :: Ord a => a -> a -> Interval a
(+/-) :: (Num a, Ord a) => a -> a -> Interval a
interval :: Ord a => a -> a -> Maybe (Interval a)

-- | The whole real number line
--   
--   <pre>
--   &gt;&gt;&gt; whole
--   -Infinity ... Infinity
--   </pre>
whole :: Fractional a => Interval a

-- | An empty interval
--   
--   <pre>
--   &gt;&gt;&gt; empty
--   Empty
--   </pre>
empty :: Ord a => Interval a

-- | Check if an interval is empty
--   
--   <pre>
--   &gt;&gt;&gt; null (1 ... 5)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; null (1 ... 1)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; null empty
--   True
--   </pre>
null :: Interval a -> Bool

-- | A singleton point
--   
--   <pre>
--   &gt;&gt;&gt; singleton 1
--   1 ... 1
--   </pre>
singleton :: a -> Interval a

-- | Determine if a point is in the interval.
--   
--   <pre>
--   &gt;&gt;&gt; elem 3.2 (1.0 ... 5.0)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; elem 5 (1.0 ... 5.0)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; elem 1 (1.0 ... 5.0)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; elem 8 (1.0 ... 5.0)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; elem 5 empty
--   False
--   </pre>
elem :: Ord a => a -> Interval a -> Bool

-- | Determine if a point is not included in the interval
--   
--   <pre>
--   &gt;&gt;&gt; notElem 8 (1.0 ... 5.0)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; notElem 1.4 (1.0 ... 5.0)
--   False
--   </pre>
--   
--   And of course, nothing is a member of the empty interval.
--   
--   <pre>
--   &gt;&gt;&gt; notElem 5 empty
--   True
--   </pre>
notElem :: Ord a => a -> Interval a -> Bool

-- | The infimum (lower bound) of an interval
--   
--   <pre>
--   &gt;&gt;&gt; inf (1.0 ... 20.0)
--   1.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; inf empty
--   *** Exception: empty interval
--   </pre>
inf :: Interval a -> a

-- | The supremum (upper bound) of an interval
--   
--   <pre>
--   &gt;&gt;&gt; sup (1.0 ... 20.0)
--   20.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sup empty
--   *** Exception: empty interval
--   </pre>
sup :: Interval a -> a

-- | Is the interval a singleton point? N.B. This is fairly fragile and
--   likely will not hold after even a few operations that only involve
--   singletons
--   
--   <pre>
--   &gt;&gt;&gt; singular (singleton 1)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; singular (1.0 ... 20.0)
--   False
--   </pre>
singular :: Ord a => Interval a -> Bool

-- | Calculate the width of an interval.
--   
--   <pre>
--   &gt;&gt;&gt; width (1 ... 20)
--   19
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; width (singleton 1)
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; width empty
--   0
--   </pre>
width :: Num a => Interval a -> a

-- | Nearest point to the midpoint of the interval.
--   
--   <pre>
--   &gt;&gt;&gt; midpoint (10.0 ... 20.0)
--   15.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; midpoint (singleton 5.0)
--   5.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; midpoint empty
--   *** Exception: empty interval
--   </pre>
midpoint :: Fractional a => Interval a -> a

-- | Calculate the intersection of two intervals.
--   
--   <pre>
--   &gt;&gt;&gt; intersection (1 ... 10 :: Interval Double) (5 ... 15 :: Interval Double)
--   5.0 ... 10.0
--   </pre>
intersection :: Ord a => Interval a -> Interval a -> Interval a

-- | Calculate the convex hull of two intervals
--   
--   <pre>
--   &gt;&gt;&gt; hull (0 ... 10 :: Interval Double) (5 ... 15 :: Interval Double)
--   0.0 ... 15.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hull (15 ... 85 :: Interval Double) (0 ... 10 :: Interval Double)
--   0.0 ... 85.0
--   </pre>
hull :: Ord a => Interval a -> Interval a -> Interval a

-- | Bisect an interval at its midpoint.
--   
--   <pre>
--   &gt;&gt;&gt; bisect (10.0 ... 20.0)
--   (10.0 ... 15.0,15.0 ... 20.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bisect (singleton 5.0)
--   (5.0 ... 5.0,5.0 ... 5.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bisect Empty
--   (Empty,Empty)
--   </pre>
bisect :: Fractional a => Interval a -> (Interval a, Interval a)
bisectIntegral :: Integral a => Interval a -> (Interval a, Interval a)

-- | Magnitude
--   
--   <pre>
--   &gt;&gt;&gt; magnitude (1 ... 20)
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; magnitude (-20 ... 10)
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; magnitude (singleton 5)
--   5
--   </pre>
--   
--   throws <a>EmptyInterval</a> if the interval is empty.
--   
--   <pre>
--   &gt;&gt;&gt; magnitude empty
--   *** Exception: empty interval
--   </pre>
magnitude :: (Num a, Ord a) => Interval a -> a

-- | "mignitude"
--   
--   <pre>
--   &gt;&gt;&gt; mignitude (1 ... 20)
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mignitude (-20 ... 10)
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mignitude (singleton 5)
--   5
--   </pre>
--   
--   throws <a>EmptyInterval</a> if the interval is empty.
--   
--   <pre>
--   &gt;&gt;&gt; mignitude empty
--   *** Exception: empty interval
--   </pre>
mignitude :: (Num a, Ord a) => Interval a -> a

-- | Hausdorff distance between intervals.
--   
--   <pre>
--   &gt;&gt;&gt; distance (1 ... 7) (6 ... 10)
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; distance (1 ... 7) (15 ... 24)
--   8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; distance (1 ... 7) (-10 ... -2)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; distance Empty (1 ... 1)
--   *** Exception: empty interval
--   </pre>
distance :: (Num a, Ord a) => Interval a -> Interval a -> a

-- | Inflate an interval by enlarging it at both ends.
--   
--   <pre>
--   &gt;&gt;&gt; inflate 3 (-1 ... 7)
--   -4 ... 10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; inflate (-2) (0 ... 4)
--   -2 ... 6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; inflate 1 empty
--   Empty
--   </pre>
inflate :: (Num a, Ord a) => a -> Interval a -> Interval a

-- | Deflate an interval by shrinking it from both ends.
--   
--   <pre>
--   &gt;&gt;&gt; deflate 3.0 (-4.0 ... 10.0)
--   -1.0 ... 7.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; deflate 2.0 (-1.0 ... 1.0)
--   Empty
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; deflate 1.0 empty
--   Empty
--   </pre>
deflate :: (Fractional a, Ord a) => a -> Interval a -> Interval a

-- | Scale an interval about its midpoint.
--   
--   <pre>
--   &gt;&gt;&gt; scale 1.1 (-6.0 ... 4.0)
--   -6.5 ... 4.5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scale (-2.0) (-1.0 ... 1.0)
--   Empty
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scale 3.0 empty
--   Empty
--   </pre>
scale :: (Fractional a, Ord a) => a -> Interval a -> Interval a

-- | Construct a symmetric interval.
--   
--   <pre>
--   &gt;&gt;&gt; symmetric 3
--   -3 ... 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; symmetric (-2)
--   -2 ... 2
--   </pre>
symmetric :: (Num a, Ord a) => a -> Interval a

-- | Check if interval <tt>X</tt> totally contains interval <tt>Y</tt>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 40 :: Interval Double) `contains` (25 ... 35 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 40 :: Interval Double) `contains` (15 ... 35 :: Interval Double)
--   False
--   </pre>
contains :: Ord a => Interval a -> Interval a -> Bool

-- | Flipped version of <a>contains</a>. Check if interval <tt>X</tt> a
--   subset of interval <tt>Y</tt>
--   
--   <pre>
--   &gt;&gt;&gt; (25 ... 35 :: Interval Double) `isSubsetOf` (20 ... 40 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 40 :: Interval Double) `isSubsetOf` (15 ... 35 :: Interval Double)
--   False
--   </pre>
isSubsetOf :: Ord a => Interval a -> Interval a -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <tt>op</tt> y</tt>
certainly :: Ord a => (forall b. Ord b => b -> b -> Bool) -> Interval a -> Interval a -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&lt;</a> y</tt>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 10 :: Interval Double) &lt;! (20 ... 30 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 10 :: Interval Double) &lt;! (10 ... 30 :: Interval Double)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 30 :: Interval Double) &lt;! (5 ... 10 :: Interval Double)
--   False
--   </pre>
(<!) :: Ord a => Interval a -> Interval a -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&lt;=</a> y</tt>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 10 :: Interval Double) &lt;=! (20 ... 30 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 10 :: Interval Double) &lt;=! (10 ... 30 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 30 :: Interval Double) &lt;=! (5 ... 10 :: Interval Double)
--   False
--   </pre>
(<=!) :: Ord a => Interval a -> Interval a -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>==</a> y</tt>
--   
--   Only singleton intervals or empty intervals can return true
--   
--   <pre>
--   &gt;&gt;&gt; (singleton 5 :: Interval Double) ==! (singleton 5 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 10 :: Interval Double) ==! (5 ... 10 :: Interval Double)
--   False
--   </pre>
(==!) :: Eq a => Interval a -> Interval a -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&gt;=</a> y</tt>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 40 :: Interval Double) &gt;=! (10 ... 20 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 20 :: Interval Double) &gt;=! (15 ... 40 :: Interval Double)
--   False
--   </pre>
(>=!) :: Ord a => Interval a -> Interval a -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&gt;</a> y</tt>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 40 :: Interval Double) &gt;! (10 ... 19 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 20 :: Interval Double) &gt;! (15 ... 40 :: Interval Double)
--   False
--   </pre>
(>!) :: Ord a => Interval a -> Interval a -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <tt>op</tt> y</tt>?
possibly :: Ord a => (forall b. Ord b => b -> b -> Bool) -> Interval a -> Interval a -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&lt;</a> y</tt>?
(<?) :: Ord a => Interval a -> Interval a -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&lt;=</a> y</tt>?
(<=?) :: Ord a => Interval a -> Interval a -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>==</a> y</tt>?
(==?) :: Ord a => Interval a -> Interval a -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&gt;=</a> y</tt>?
(>=?) :: Ord a => Interval a -> Interval a -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&gt;</a> y</tt>?
(>?) :: Ord a => Interval a -> Interval a -> Bool

-- | id function. Useful for type specification
--   
--   <pre>
--   &gt;&gt;&gt; :t idouble (1 ... 3)
--   idouble (1 ... 3) :: Interval Double
--   </pre>
idouble :: Interval Double -> Interval Double

-- | id function. Useful for type specification
--   
--   <pre>
--   &gt;&gt;&gt; :t ifloat (1 ... 3)
--   ifloat (1 ... 3) :: Interval Float
--   </pre>
ifloat :: Interval Float -> Interval Float
instance Typeable Interval
instance Data a => Data (Interval a)
instance Generic (Interval a)
instance Generic1 Interval
instance Datatype D1Interval
instance Constructor C1_0Interval
instance Constructor C1_1Interval
instance RealFloat a => RealFloat (Interval a)
instance (RealFloat a, Ord a) => Floating (Interval a)
instance RealFrac a => RealFrac (Interval a)
instance (Fractional a, Ord a) => Fractional (Interval a)
instance Ord a => Ord (Interval a)
instance Real a => Real (Interval a)
instance (Num a, Ord a) => Num (Interval a)
instance Show a => Show (Interval a)
instance Eq a => Eq (Interval a)
instance Foldable Interval


-- | Interval arithmetic
module Numeric.Interval
data Interval a
(...) :: Ord a => a -> a -> Interval a
(+/-) :: (Num a, Ord a) => a -> a -> Interval a
interval :: Ord a => a -> a -> Maybe (Interval a)

-- | The whole real number line
--   
--   <pre>
--   &gt;&gt;&gt; whole
--   -Infinity ... Infinity
--   </pre>
whole :: Fractional a => Interval a

-- | An empty interval
--   
--   <pre>
--   &gt;&gt;&gt; empty
--   Empty
--   </pre>
empty :: Ord a => Interval a

-- | Check if an interval is empty
--   
--   <pre>
--   &gt;&gt;&gt; null (1 ... 5)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; null (1 ... 1)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; null empty
--   True
--   </pre>
null :: Interval a -> Bool

-- | A singleton point
--   
--   <pre>
--   &gt;&gt;&gt; singleton 1
--   1 ... 1
--   </pre>
singleton :: a -> Interval a

-- | Determine if a point is in the interval.
--   
--   <pre>
--   &gt;&gt;&gt; elem 3.2 (1.0 ... 5.0)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; elem 5 (1.0 ... 5.0)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; elem 1 (1.0 ... 5.0)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; elem 8 (1.0 ... 5.0)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; elem 5 empty
--   False
--   </pre>
elem :: Ord a => a -> Interval a -> Bool

-- | Determine if a point is not included in the interval
--   
--   <pre>
--   &gt;&gt;&gt; notElem 8 (1.0 ... 5.0)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; notElem 1.4 (1.0 ... 5.0)
--   False
--   </pre>
--   
--   And of course, nothing is a member of the empty interval.
--   
--   <pre>
--   &gt;&gt;&gt; notElem 5 empty
--   True
--   </pre>
notElem :: Ord a => a -> Interval a -> Bool

-- | The infimum (lower bound) of an interval
--   
--   <pre>
--   &gt;&gt;&gt; inf (1.0 ... 20.0)
--   1.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; inf empty
--   *** Exception: empty interval
--   </pre>
inf :: Interval a -> a

-- | The supremum (upper bound) of an interval
--   
--   <pre>
--   &gt;&gt;&gt; sup (1.0 ... 20.0)
--   20.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sup empty
--   *** Exception: empty interval
--   </pre>
sup :: Interval a -> a

-- | Is the interval a singleton point? N.B. This is fairly fragile and
--   likely will not hold after even a few operations that only involve
--   singletons
--   
--   <pre>
--   &gt;&gt;&gt; singular (singleton 1)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; singular (1.0 ... 20.0)
--   False
--   </pre>
singular :: Ord a => Interval a -> Bool

-- | Calculate the width of an interval.
--   
--   <pre>
--   &gt;&gt;&gt; width (1 ... 20)
--   19
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; width (singleton 1)
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; width empty
--   0
--   </pre>
width :: Num a => Interval a -> a

-- | Nearest point to the midpoint of the interval.
--   
--   <pre>
--   &gt;&gt;&gt; midpoint (10.0 ... 20.0)
--   15.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; midpoint (singleton 5.0)
--   5.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; midpoint empty
--   *** Exception: empty interval
--   </pre>
midpoint :: Fractional a => Interval a -> a

-- | Calculate the intersection of two intervals.
--   
--   <pre>
--   &gt;&gt;&gt; intersection (1 ... 10 :: Interval Double) (5 ... 15 :: Interval Double)
--   5.0 ... 10.0
--   </pre>
intersection :: Ord a => Interval a -> Interval a -> Interval a

-- | Calculate the convex hull of two intervals
--   
--   <pre>
--   &gt;&gt;&gt; hull (0 ... 10 :: Interval Double) (5 ... 15 :: Interval Double)
--   0.0 ... 15.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hull (15 ... 85 :: Interval Double) (0 ... 10 :: Interval Double)
--   0.0 ... 85.0
--   </pre>
hull :: Ord a => Interval a -> Interval a -> Interval a

-- | Bisect an interval at its midpoint.
--   
--   <pre>
--   &gt;&gt;&gt; bisect (10.0 ... 20.0)
--   (10.0 ... 15.0,15.0 ... 20.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bisect (singleton 5.0)
--   (5.0 ... 5.0,5.0 ... 5.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; bisect Empty
--   (Empty,Empty)
--   </pre>
bisect :: Fractional a => Interval a -> (Interval a, Interval a)
bisectIntegral :: Integral a => Interval a -> (Interval a, Interval a)

-- | Magnitude
--   
--   <pre>
--   &gt;&gt;&gt; magnitude (1 ... 20)
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; magnitude (-20 ... 10)
--   20
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; magnitude (singleton 5)
--   5
--   </pre>
--   
--   throws <a>EmptyInterval</a> if the interval is empty.
--   
--   <pre>
--   &gt;&gt;&gt; magnitude empty
--   *** Exception: empty interval
--   </pre>
magnitude :: (Num a, Ord a) => Interval a -> a

-- | "mignitude"
--   
--   <pre>
--   &gt;&gt;&gt; mignitude (1 ... 20)
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mignitude (-20 ... 10)
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mignitude (singleton 5)
--   5
--   </pre>
--   
--   throws <a>EmptyInterval</a> if the interval is empty.
--   
--   <pre>
--   &gt;&gt;&gt; mignitude empty
--   *** Exception: empty interval
--   </pre>
mignitude :: (Num a, Ord a) => Interval a -> a

-- | Hausdorff distance between intervals.
--   
--   <pre>
--   &gt;&gt;&gt; distance (1 ... 7) (6 ... 10)
--   0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; distance (1 ... 7) (15 ... 24)
--   8
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; distance (1 ... 7) (-10 ... -2)
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; distance Empty (1 ... 1)
--   *** Exception: empty interval
--   </pre>
distance :: (Num a, Ord a) => Interval a -> Interval a -> a

-- | Inflate an interval by enlarging it at both ends.
--   
--   <pre>
--   &gt;&gt;&gt; inflate 3 (-1 ... 7)
--   -4 ... 10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; inflate (-2) (0 ... 4)
--   -2 ... 6
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; inflate 1 empty
--   Empty
--   </pre>
inflate :: (Num a, Ord a) => a -> Interval a -> Interval a

-- | Deflate an interval by shrinking it from both ends.
--   
--   <pre>
--   &gt;&gt;&gt; deflate 3.0 (-4.0 ... 10.0)
--   -1.0 ... 7.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; deflate 2.0 (-1.0 ... 1.0)
--   Empty
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; deflate 1.0 empty
--   Empty
--   </pre>
deflate :: (Fractional a, Ord a) => a -> Interval a -> Interval a

-- | Scale an interval about its midpoint.
--   
--   <pre>
--   &gt;&gt;&gt; scale 1.1 (-6.0 ... 4.0)
--   -6.5 ... 4.5
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scale (-2.0) (-1.0 ... 1.0)
--   Empty
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; scale 3.0 empty
--   Empty
--   </pre>
scale :: (Fractional a, Ord a) => a -> Interval a -> Interval a

-- | Construct a symmetric interval.
--   
--   <pre>
--   &gt;&gt;&gt; symmetric 3
--   -3 ... 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; symmetric (-2)
--   -2 ... 2
--   </pre>
symmetric :: (Num a, Ord a) => a -> Interval a

-- | Check if interval <tt>X</tt> totally contains interval <tt>Y</tt>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 40 :: Interval Double) `contains` (25 ... 35 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 40 :: Interval Double) `contains` (15 ... 35 :: Interval Double)
--   False
--   </pre>
contains :: Ord a => Interval a -> Interval a -> Bool

-- | Flipped version of <a>contains</a>. Check if interval <tt>X</tt> a
--   subset of interval <tt>Y</tt>
--   
--   <pre>
--   &gt;&gt;&gt; (25 ... 35 :: Interval Double) `isSubsetOf` (20 ... 40 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 40 :: Interval Double) `isSubsetOf` (15 ... 35 :: Interval Double)
--   False
--   </pre>
isSubsetOf :: Ord a => Interval a -> Interval a -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <tt>op</tt> y</tt>
certainly :: Ord a => (forall b. Ord b => b -> b -> Bool) -> Interval a -> Interval a -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&lt;</a> y</tt>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 10 :: Interval Double) &lt;! (20 ... 30 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 10 :: Interval Double) &lt;! (10 ... 30 :: Interval Double)
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 30 :: Interval Double) &lt;! (5 ... 10 :: Interval Double)
--   False
--   </pre>
(<!) :: Ord a => Interval a -> Interval a -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&lt;=</a> y</tt>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 10 :: Interval Double) &lt;=! (20 ... 30 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 10 :: Interval Double) &lt;=! (10 ... 30 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 30 :: Interval Double) &lt;=! (5 ... 10 :: Interval Double)
--   False
--   </pre>
(<=!) :: Ord a => Interval a -> Interval a -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>==</a> y</tt>
--   
--   Only singleton intervals or empty intervals can return true
--   
--   <pre>
--   &gt;&gt;&gt; (singleton 5 :: Interval Double) ==! (singleton 5 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 10 :: Interval Double) ==! (5 ... 10 :: Interval Double)
--   False
--   </pre>
(==!) :: Eq a => Interval a -> Interval a -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&gt;=</a> y</tt>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 40 :: Interval Double) &gt;=! (10 ... 20 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 20 :: Interval Double) &gt;=! (15 ... 40 :: Interval Double)
--   False
--   </pre>
(>=!) :: Ord a => Interval a -> Interval a -> Bool

-- | For all <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>. <tt>x
--   <a>&gt;</a> y</tt>
--   
--   <pre>
--   &gt;&gt;&gt; (20 ... 40 :: Interval Double) &gt;! (10 ... 19 :: Interval Double)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (5 ... 20 :: Interval Double) &gt;! (15 ... 40 :: Interval Double)
--   False
--   </pre>
(>!) :: Ord a => Interval a -> Interval a -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <tt>op</tt> y</tt>?
possibly :: Ord a => (forall b. Ord b => b -> b -> Bool) -> Interval a -> Interval a -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&lt;</a> y</tt>?
(<?) :: Ord a => Interval a -> Interval a -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&lt;=</a> y</tt>?
(<=?) :: Ord a => Interval a -> Interval a -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>==</a> y</tt>?
(==?) :: Ord a => Interval a -> Interval a -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&gt;=</a> y</tt>?
(>=?) :: Ord a => Interval a -> Interval a -> Bool

-- | Does there exist an <tt>x</tt> in <tt>X</tt>, <tt>y</tt> in <tt>Y</tt>
--   such that <tt>x <a>&gt;</a> y</tt>?
(>?) :: Ord a => Interval a -> Interval a -> Bool

-- | id function. Useful for type specification
--   
--   <pre>
--   &gt;&gt;&gt; :t idouble (1 ... 3)
--   idouble (1 ... 3) :: Interval Double
--   </pre>
idouble :: Interval Double -> Interval Double

-- | id function. Useful for type specification
--   
--   <pre>
--   &gt;&gt;&gt; :t ifloat (1 ... 3)
--   ifloat (1 ... 3) :: Interval Float
--   </pre>
ifloat :: Interval Float -> Interval Float
