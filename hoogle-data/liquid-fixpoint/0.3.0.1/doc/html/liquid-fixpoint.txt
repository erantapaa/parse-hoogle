-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Predicate Abstraction-based Horn-Clause/Implication Constraint Solver
--   
@package liquid-fixpoint
@version 0.3.0.1

module Language.Fixpoint.Misc
data Moods
Ok :: Moods
Loud :: Moods
Sad :: Moods
Happy :: Moods
Angry :: Moods
moodColor :: Moods -> Color
wrapStars :: [Char] -> [Char]
wrapStarsWithOptStars :: Bool -> [Char] -> [Char]
withColor :: Color -> IO a -> IO ()
colorStrLn :: Moods -> String -> IO ()
colorPhaseLn :: Moods -> [Char] -> [Char] -> IO ()
startPhase :: Moods -> [Char] -> IO ()
doneLine :: Moods -> [Char] -> IO ()
colorPhaseLnWithOptStars :: Bool -> Moods -> [Char] -> [Char] -> IO ()
startPhaseWithOptStars :: Bool -> Moods -> [Char] -> IO ()
doneLineWithOptStars :: Bool -> Moods -> [Char] -> IO ()
donePhase :: Moods -> String -> IO ()
donePhaseWithOptStars :: Bool -> Moods -> String -> IO ()
data Empty
Emp :: Empty
unIntersperse :: Eq t => t -> [t] -> [[t]]
(=>>) :: Monad m => m b -> (b -> m a) -> m b
wrap :: [a] -> [a] -> [a] -> [a]
repeats :: Int -> [a] -> [a]
errorstar :: [Char] -> c
errortext :: Doc -> c
putDocLn :: Doc -> IO ()
assertstar :: [Char] -> Bool -> c -> c
findWithDefaultL :: (a -> Bool) -> [a] -> a -> a
fst3 :: (a, b, c) -> a
snd3 :: (a, b, c) -> b
thd3 :: (a, b, c) -> c
single :: a -> [a]
mapFst :: (t -> t1) -> (t, t2) -> (t1, t2)
mapSnd :: (t -> t2) -> (t1, t) -> (t1, t2)
mapFst3 :: (t -> t1) -> (t, t2, t3) -> (t1, t2, t3)
mapSnd3 :: (t -> t2) -> (t1, t, t3) -> (t1, t2, t3)
mapThd3 :: (t -> t3) -> (t1, t2, t) -> (t1, t2, t3)
expandSnd :: [([a], t)] -> [(a, t)]
mapPair :: (a -> b) -> (a, a) -> (b, b)
mlookup :: (Hashable a, Show a, Eq a) => HashMap a v -> a -> v
safeLookup :: (Hashable k, Eq k) => [Char] -> k -> HashMap k a -> a
mfromJust :: String -> Maybe a -> a
boxStrCat :: String -> [String] -> String
tryIgnore :: String -> IO () -> IO ()
traceShow :: Show a => String -> a -> a
warnShow :: Show a => String -> a -> a
inserts :: (Hashable k, Eq k) => k -> a -> HashMap k [a] -> HashMap k [a]
concatMaps :: (Hashable k, Ord a, Eq k) => [HashMap k [a]] -> HashMap k [a]
group :: (Hashable k, Eq k) => [(k, a)] -> HashMap k [a]
groupBase :: (Hashable k, Eq k) => HashMap k [a] -> [(k, a)] -> HashMap k [a]
groupList :: (Hashable k, Eq k) => [(k, a)] -> [(k, [a])]
mkGraph :: (Eq a, Eq b, Hashable a, Hashable b) => [(a, b)] -> HashMap a (HashSet b)
groupMap :: (Hashable k, Eq k) => (a -> k) -> [a] -> HashMap k [a]
sortNub :: Ord a => [a] -> [a]
sortDiff :: Ord a => [a] -> [a] -> [a]
folds :: (a -> b -> (c, a)) -> a -> [b] -> ([c], a)
distinct :: Ord a => [a] -> Bool
tr_reverse :: [a] -> [a]
tr_foldr' :: (a -> b -> b) -> b -> [a] -> b
safeZip :: [Char] -> [a] -> [b] -> [(a, b)]
safeZipWith :: [Char] -> (a -> b -> c) -> [a] -> [b] -> [c]
safeFromList :: (Hashable k, Show v, Show k, Eq k) => [Char] -> [(k, v)] -> HashMap k v
safeUnion :: (Hashable k, Show k, Eq k) => [Char] -> HashMap k v -> HashMap k v -> HashMap k v
type ListNE a = [a]
safeHead :: String -> ListNE a -> a
safeLast :: String -> ListNE a -> a
safeInit :: String -> ListNE a -> [a]
safeUncons :: String -> ListNE a -> (a, [a])
safeUnsnoc :: String -> ListNE a -> ([a], a)
memoIndex :: (Hashable k, Eq k) => (x -> Maybe k) -> [x] -> [Maybe Int]
checkFail :: [Char] -> (a -> Bool) -> a -> a
chopAfter :: (a -> Bool) -> [a] -> [a]
chopPrefix :: Eq a => [a] -> [a] -> Maybe [a]
firstElem :: Eq a => [(a, t)] -> [a] -> Maybe Int
chopAlt :: Eq a => [(a, a)] -> [a] -> [[a]]
firstElems :: [(ByteString, ByteString)] -> ByteString -> Maybe (Int, ByteString, (ByteString, ByteString))
splitters :: [(ByteString, t)] -> ByteString -> [(Int, t, (ByteString, ByteString))]
bchopAlts :: [(ByteString, ByteString)] -> ByteString -> [ByteString]
chopAlts :: [(String, String)] -> String -> [[Char]]
findFirst :: Monad m => (t -> m [a]) -> [t] -> m (Maybe a)
testM :: Monad m => (t -> m Bool) -> t -> m [t]
stripParens :: Text -> Text
ifM :: Monad m => m Bool -> m a -> m a -> m a
executeShellCommand :: [Char] -> [Char] -> IO ExitCode
executeShellCommandWithOptStars :: Bool -> [Char] -> [Char] -> IO ExitCode
checkExitCode :: Monad m => [Char] -> ExitCode -> m ()
hashMapToAscList :: Ord a => HashMap a b -> [(a, b)]
hashMapMapWithKey :: (k -> v1 -> v2) -> HashMap k v1 -> HashMap k v2
hashMapMapKeys :: (Eq k, Hashable k) => (t -> k) -> HashMap t v -> HashMap k v
applyNonNull :: t -> ([t1] -> t) -> [t1] -> t
concatMapM :: (Functor f, Monad f) => (a1 -> f [a]) -> [a1] -> f [a]
angleBrackets :: Doc -> Doc
dot :: Doc
arrow :: Doc
dcolon :: Doc
intersperse :: Doc -> [Doc] -> Doc
tshow :: Show a => a -> Doc
foldlMap :: (a -> b -> (c, a)) -> a -> [b] -> ([c], a)
mapEither :: (a -> Either b c) -> [a] -> ([b], [c])
(<$$>) :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
instance Typeable Empty
instance Data Empty
instance Eq Empty
instance Show Empty


-- | This module contains Haskell variables representing globally visible
--   names for files, paths, extensions.
--   
--   Rather than have strings floating around the system, all constant
--   names should be defined here, and the (exported) variables should be
--   used and manipulated elsewhere.
module Language.Fixpoint.Files
data Ext

-- | Constraint Generation Information
Cgi :: Ext

-- | Input to constraint solving (fixpoint)
Fq :: Ext

-- | Output from constraint solving (fixpoint)
Out :: Ext

-- | HTML file with inferred type annotations
Html :: Ext

-- | Text file with inferred types
Annot :: Ext

-- | Vim annotation file
Vim :: Ext

-- | Haskell source
Hs :: Ext

-- | Literate Haskell source
LHs :: Ext

-- | JavaScript source
Js :: Ext

-- | Typescript source
Ts :: Ext

-- | Spec file (e.g. include/Prelude.spec)
Spec :: Ext

-- | Qualifiers file (e.g. include/Prelude.hquals)
Hquals :: Ext

-- | Final result: SAFE/UNSAFE
Result :: Ext

-- | HTML file with templates?
Cst :: Ext

-- | Markdown file (temporarily generated from .Lhs + annots)
Mkdn :: Ext

-- | JSON file containing result (annots + errors)
Json :: Ext

-- | Previous source (for incremental checking)
Saved :: Ext

-- | Previous output (for incremental checking)
Cache :: Ext
Pred :: Ext
PAss :: Ext
Dat :: Ext

-- | SMTLIB2 query file
Smt2 :: Ext
extFileName :: Ext -> FilePath -> FilePath
extFileNameR :: Ext -> FilePath -> FilePath
tempDirectory :: FilePath -> FilePath
extModuleName :: String -> Ext -> FilePath
withExt :: FilePath -> Ext -> FilePath
isExtFile :: Ext -> FilePath -> Bool

-- | Hardwired Paths and Files -----------------------------
getFixpointPath :: IO FilePath
getZ3LibPath :: IO FilePath
getFileInDirs :: FilePath -> [FilePath] -> IO (Maybe FilePath)
copyFiles :: [FilePath] -> FilePath -> IO ()
instance Eq Ext
instance Ord Ext
instance Show Ext

module Language.Fixpoint.Config
data Config
Config :: FilePath -> FilePath -> FilePath -> SMTSolver -> GenQualifierSort -> UeqAllSorts -> Bool -> Bool -> Bool -> Config

-- | target fq-file
inFile :: Config -> FilePath

-- | output file
outFile :: Config -> FilePath

-- | src file (*.hs, *.ts, *.c)
srcFile :: Config -> FilePath

-- | which SMT solver to use
solver :: Config -> SMTSolver

-- | generalize qualifier sorts
genSorts :: Config -> GenQualifierSort

-- | use UEq on all sorts
ueqAllSorts :: Config -> UeqAllSorts

-- | use haskell solver
native :: Config -> Bool

-- | interpret div and mul in SMT
real :: Config -> Bool

-- | eliminate non-cut KVars
eliminate :: Config -> Bool
getOpts :: IO Config
class Command a
command :: Command a => a -> String
data SMTSolver
Z3 :: SMTSolver
Cvc4 :: SMTSolver
Mathsat :: SMTSolver
Z3mem :: SMTSolver
newtype GenQualifierSort
GQS :: Bool -> GenQualifierSort
newtype UeqAllSorts
UAS :: Bool -> UeqAllSorts
withTarget :: Config -> FilePath -> Config
withUEqAllSorts :: Config -> Bool -> Config
instance Typeable GenQualifierSort
instance Typeable UeqAllSorts
instance Typeable SMTSolver
instance Typeable Config
instance Eq GenQualifierSort
instance Data GenQualifierSort
instance Show GenQualifierSort
instance Eq UeqAllSorts
instance Data UeqAllSorts
instance Show UeqAllSorts
instance Eq SMTSolver
instance Data SMTSolver
instance Eq Config
instance Data Config
instance Show Config
instance Show SMTSolver
instance Default SMTSolver
instance Command SMTSolver
instance Command UeqAllSorts
instance Default UeqAllSorts
instance Command GenQualifierSort
instance Default GenQualifierSort
instance Command Config
instance Default Config


-- | This module contains Haskell variables representing globally visible
--   names. Rather than have strings floating around the system, all
--   constant names should be defined here, and the (exported) variables
--   should be used and manipulated elsewhere.
module Language.Fixpoint.Names
data Symbol

-- | Values that can be viewed as Symbols
class Symbolic a
symbol :: Symbolic a => a -> Symbol
anfPrefix :: Symbol
tempPrefix :: Symbol
vv :: Maybe Integer -> Symbol
isPrefixOfSym :: Symbol -> Symbol -> Bool
isSuffixOfSym :: Symbol -> Symbol -> Bool
stripParensSym :: Symbol -> Symbol
consSym :: Char -> Symbol -> Symbol
unconsSym :: Symbol -> Maybe (Char, Symbol)
dropSym :: Int -> Symbol -> Symbol
singletonSym :: Char -> Symbol
headSym :: Symbol -> Char
takeWhileSym :: (Char -> Bool) -> Symbol -> Symbol
lengthSym :: Symbol -> Int
symChars :: [Char]
isNonSymbol :: Symbol -> Bool
nonSymbol :: Symbol
isNontrivialVV :: Symbol -> Bool
symbolText :: Symbol -> Text
symbolString :: Symbol -> String
encode :: String -> String
vvCon :: Symbol
dropModuleNames :: Symbol -> Symbol
dropModuleUnique :: Symbol -> Symbol
takeModuleNames :: Symbol -> Symbol
dummySymbol :: Symbol
intSymbol :: Show a => Symbol -> a -> Symbol
tempSymbol :: Symbol -> Integer -> Symbol
existSymbol :: Symbol -> Integer -> Symbol
qualifySymbol :: Symbol -> Symbol -> Symbol
suffixSymbol :: Symbol -> Text -> Symbol
dummyName :: Symbol
preludeName :: Symbol
boolConName :: Symbol
funConName :: Symbol
listConName :: Symbol
tupConName :: Symbol
propConName :: Symbol
hpropConName :: Symbol
strConName :: Symbol
nilName :: Symbol
consName :: Symbol
vvName :: Symbol
symSepName :: Char
size32Name :: Symbol
size64Name :: Symbol
bitVecName :: Symbol
bvAndName :: Symbol
bvOrName :: Symbol
prims :: [Symbol]
instance Typeable Symbol
instance Generic InternedText
instance Typeable InternedText
instance Data InternedText
instance Eq Symbol
instance Ord Symbol
instance Data Symbol
instance Generic Symbol
instance IsString Symbol
instance Datatype D1Symbol
instance Constructor C1_0Symbol
instance Datatype D1InternedText
instance Constructor C1_0InternedText
instance Selector S1_0_0InternedText
instance Selector S1_0_1InternedText
instance Symbolic Symbol
instance Symbolic InternedText
instance Symbolic Text
instance Symbolic String
instance Hashable Symbol
instance NFData Symbol
instance Show Symbol
instance NFData InternedText
instance Hashable InternedText
instance Monoid Symbol


-- | This module contains the data types, operations and serialization
--   functions for representing Fixpoint's implication (i.e. subtyping) and
--   well-formedness constraints in Haskell. The actual constraint solving
--   is done by the `fixpoint.native` which is written in Ocaml.
module Language.Fixpoint.Types
class Fixpoint a where simplify = id
toFix :: Fixpoint a => a -> Doc
simplify :: Fixpoint a => a -> a
toFixpoint :: FInfo a -> Doc
data FInfo a
FI :: HashMap Integer (SubC a) -> ![WfC a] -> !BindEnv -> !FEnv -> ![(Symbol, Sort)] -> Kuts -> ![Qualifier] -> FInfo a
cm :: FInfo a -> HashMap Integer (SubC a)
ws :: FInfo a -> ![WfC a]
bs :: FInfo a -> !BindEnv
gs :: FInfo a -> !FEnv
lits :: FInfo a -> ![(Symbol, Sort)]
kuts :: FInfo a -> Kuts
quals :: FInfo a -> ![Qualifier]
showFix :: Fixpoint a => a -> String
traceFix :: Fixpoint a => String -> a -> a
resultDoc :: (Ord a, Fixpoint a) => FixResult a -> Doc
data Symbol
newtype KVar
KV :: Symbol -> KVar
kv :: KVar -> Symbol
anfPrefix :: Symbol
tempPrefix :: Symbol
vv :: Maybe Integer -> Symbol
vv_ :: Symbol
intKvar :: Integer -> KVar
symChars :: [Char]
isNonSymbol :: Symbol -> Bool
nonSymbol :: Symbol
isNontrivialVV :: Symbol -> Bool
symbolText :: Symbol -> Text
symbolString :: Symbol -> String
dummySymbol :: Symbol
intSymbol :: Show a => Symbol -> a -> Symbol
tempSymbol :: Symbol -> Integer -> Symbol
qualifySymbol :: Symbol -> Symbol -> Symbol
suffixSymbol :: Symbol -> Text -> Symbol
data Sort
FInt :: Sort
FReal :: Sort

-- | numeric kind for Num tyvars
FNum :: Sort

-- | numeric kind for Fractional tyvars
FFrac :: Sort

-- | uninterpreted type
FObj :: Symbol -> Sort

-- | fixpoint type variable
FVar :: !Int -> Sort

-- | type-var arity, in-ts ++ [out-t]
FFunc :: !Int -> ![Sort] -> Sort

-- | constructed type
FApp :: FTycon -> [Sort] -> Sort
data FTycon
type TCEmb a = HashMap a FTycon
intFTyCon :: FTycon
boolFTyCon :: FTycon
realFTyCon :: FTycon
strFTyCon :: FTycon
propFTyCon :: FTycon
listFTyCon :: FTycon
appFTyCon :: FTycon
fTyconSymbol :: FTycon -> Located Symbol
symbolFTycon :: LocSymbol -> FTycon
strSort :: Sort
fApp :: Either FTycon Sort -> [Sort] -> Sort
fObj :: LocSymbol -> Sort
isListTC :: FTycon -> Bool
isFAppTyTC :: FTycon -> Bool

-- | Uninterpreted constants that are embedded as "constant symbol : Str"
data SymConst
SL :: !Text -> SymConst
data Constant
I :: !Integer -> Constant
R :: !Double -> Constant
L :: !Text -> !Sort -> Constant
data Bop
Plus :: Bop
Minus :: Bop
Times :: Bop
Div :: Bop
Mod :: Bop
data Brel
Eq :: Brel
Ne :: Brel
Gt :: Brel
Ge :: Brel
Lt :: Brel
Le :: Brel
Ueq :: Brel
Une :: Brel
data Expr
ESym :: !SymConst -> Expr
ECon :: !Constant -> Expr
EVar :: !Symbol -> Expr
ELit :: !LocSymbol -> !Sort -> Expr
EApp :: !LocSymbol -> ![Expr] -> Expr
ENeg :: !Expr -> Expr
EBin :: !Bop -> !Expr -> !Expr -> Expr
EIte :: !Pred -> !Expr -> !Expr -> Expr
ECst :: !Expr -> !Sort -> Expr
EBot :: Expr
data Pred
PTrue :: Pred
PFalse :: Pred
PAnd :: ![Pred] -> Pred
POr :: ![Pred] -> Pred
PNot :: !Pred -> Pred
PImp :: !Pred -> !Pred -> Pred
PIff :: !Pred -> !Pred -> Pred
PBexp :: !Expr -> Pred
PAtom :: !Brel -> !Expr -> !Expr -> Pred
PKVar :: !KVar -> !Subst -> Pred
PAll :: ![(Symbol, Sort)] -> !Pred -> Pred
PTop :: Pred
eVar :: Symbolic a => a -> Expr
eProp :: Symbolic a => a -> Pred
pAnd :: [Pred] -> Pred
pOr :: [Pred] -> Pred
pIte :: Pred -> Pred -> Pred -> Pred
isTautoPred :: Pred -> Bool

-- | String Constants -----------------------------------------
symConstLits :: FInfo a -> [(Symbol, Sort)]

-- | Values that can be viewed as Symbols
class Symbolic a
symbol :: Symbolic a => a -> Symbol

-- | Generalizing Symbol, Expression, Predicate into Classes -----------
--   
--   Values that can be viewed as Constants
--   
--   Values that can be viewed as Expressions
class Expression a
expr :: Expression a => a -> Expr

-- | Values that can be viewed as Predicates
class Predicate a
prop :: Predicate a => a -> Pred
data WfC a
WfC :: !IBindEnv -> !SortedReft -> !(Maybe Integer) -> !a -> WfC a
wenv :: WfC a -> !IBindEnv
wrft :: WfC a -> !SortedReft
wid :: WfC a -> !(Maybe Integer)
winfo :: WfC a -> !a
data SubC a
sid :: SubC a -> (Maybe Integer)
sgrd :: SubC a -> Pred
senv :: SubC a -> IBindEnv
slhs :: SubC a -> SortedReft
srhs :: SubC a -> SortedReft
subC :: IBindEnv -> Pred -> SortedReft -> SortedReft -> Maybe Integer -> Tag -> a -> [SubC a]
lhsCs :: SubC a -> Reft
rhsCs :: SubC a -> Reft
wfC :: IBindEnv -> SortedReft -> Maybe Integer -> a -> WfC a
type Tag = [Int]
envCs :: BindEnv -> IBindEnv -> [(Symbol, SortedReft)]
addIds :: [SubC a] -> [(Integer, SubC a)]
sinfo :: SubC a -> a
trueSubCKvar :: KVar -> a -> [SubC a]
removeLhsKvars :: t -> t1 -> t2

-- | The output of the Solver
type Result a = (FixResult (SubC a), HashMap KVar Pred)
data FixResult a
Crash :: [a] -> String -> FixResult a
Safe :: FixResult a
Unsafe :: ![a] -> FixResult a
UnknownError :: !String -> FixResult a
type FixSolution = HashMap KVar Pred
data SEnv a
data SESearch a
Found :: a -> SESearch a
Alts :: [Symbol] -> SESearch a
emptySEnv :: SEnv a

-- | Environments ---------------------------------------------
toListSEnv :: SEnv a -> [(Symbol, a)]
fromListSEnv :: [(Symbol, a)] -> SEnv a
mapSEnvWithKey :: ((Symbol, a1) -> (Symbol, a)) -> SEnv a1 -> SEnv a
insertSEnv :: Symbol -> a -> SEnv a -> SEnv a
deleteSEnv :: Symbol -> SEnv a -> SEnv a
memberSEnv :: Symbol -> SEnv a -> Bool
lookupSEnv :: Symbol -> SEnv v -> Maybe v
intersectWithSEnv :: (v1 -> v2 -> a) -> SEnv v1 -> SEnv v2 -> SEnv a
filterSEnv :: (a -> Bool) -> SEnv a -> SEnv a
lookupSEnvWithDistance :: Symbol -> SEnv a -> SESearch a
type FEnv = SEnv SortedReft
insertFEnv :: Symbol -> a -> SEnv a -> SEnv a
data IBindEnv
type BindId = Int
type BindMap a = HashMap BindId a

-- | Functions for Indexed Bind Environment
emptyIBindEnv :: IBindEnv
insertsIBindEnv :: [BindId] -> IBindEnv -> IBindEnv
deleteIBindEnv :: BindId -> IBindEnv -> IBindEnv
elemsIBindEnv :: IBindEnv -> [BindId]
data BindEnv

-- | Functions for Global Binder Environment
insertBindEnv :: Symbol -> SortedReft -> BindEnv -> (BindId, BindEnv)
emptyBindEnv :: BindEnv
lookupBindEnv :: BindId -> BindEnv -> (Symbol, SortedReft)
mapBindEnv :: ((Symbol, SortedReft) -> (Symbol, SortedReft)) -> BindEnv -> BindEnv
bindEnvFromList :: [(BindId, Symbol, SortedReft)] -> BindEnv
bindEnvToList :: BindEnv -> [(BindId, Symbol, SortedReft)]
unionIBindEnv :: IBindEnv -> IBindEnv -> IBindEnv
newtype Refa
Refa :: Pred -> Refa
raPred :: Refa -> Pred
data SortedReft
RR :: !Sort -> !Reft -> SortedReft
sr_sort :: SortedReft -> !Sort
sr_reft :: SortedReft -> !Reft
newtype Reft
Reft :: (Symbol, Refa) -> Reft

-- | A Class Predicates for Valid Refinements Types ---------------------
class (Monoid r, Subable r) => Reftable r where top _ = mempty meet = mappend
isTauto :: Reftable r => r -> Bool
ppTy :: Reftable r => r -> Doc -> Doc
top :: Reftable r => r -> r
bot :: Reftable r => r -> r
meet :: Reftable r => r -> r -> r
toReft :: Reftable r => r -> Reft
ofReft :: Reftable r => Reft -> r
params :: Reftable r => r -> [Symbol]
refa :: [Pred] -> Refa
reft :: Symbol -> Pred -> Reft
trueSortedReft :: Sort -> SortedReft
trueRefa :: Refa
trueReft :: Reft
exprReft :: Expression a => a -> Reft
notExprReft :: Expression a => a -> Reft
uexprReft :: Expression a => a -> Reft
symbolReft :: Symbolic a => a -> Reft
usymbolReft :: Symbolic a => a -> Reft
propReft :: Predicate a => a -> Reft
predReft :: Predicate a => a -> Reft
reftPred :: Reft -> Pred
reftBind :: Reft -> Symbol
isFunctionSortedReft :: SortedReft -> Bool
functionSort :: Sort -> Maybe (Int, [Sort], Sort)
isNonTrivial :: Reftable r => r -> Bool
isSingletonReft :: Reft -> Maybe Expr
isEVar :: Expr -> Bool
isFalse :: Falseable a => a -> Bool
flattenRefas :: [Refa] -> [Refa]
squishRefas :: [Refa] -> [Refa]
conjuncts :: Pred -> [Pred]
shiftVV :: Reft -> Symbol -> Reft
mapPredReft :: (Pred -> Pred) -> Reft -> Reft
newtype Subst
Su :: [(Symbol, Expr)] -> Subst
class Subable a where subst1 y (x, e) = subst (Su [(x, e)]) y
syms :: Subable a => a -> [Symbol]
substa :: Subable a => (Symbol -> Symbol) -> a -> a
substf :: Subable a => (Symbol -> Expr) -> a -> a
subst :: Subable a => Subst -> a -> a
subst1 :: Subable a => a -> (Symbol, Expr) -> a
mkSubst :: [(Symbol, Expr)] -> Subst
isEmptySubst :: Subst -> Bool
substExcept :: Subst -> [Symbol] -> Subst
substfExcept :: (Symbol -> Expr) -> [Symbol] -> Symbol -> Expr
subst1Except :: Subable a => [Symbol] -> a -> (Symbol, Expr) -> a
sortSubst :: HashMap Symbol Sort -> Sort -> Sort
targetSubstSyms :: Subst -> [Symbol]
colorResult :: FixResult t -> Moods
newtype Kuts
KS :: HashSet KVar -> Kuts
ksVars :: Kuts -> HashSet KVar
ksEmpty :: Kuts
ksUnion :: [KVar] -> Kuts -> Kuts
data Qualifier
Q :: Symbol -> [(Symbol, Sort)] -> Pred -> !SourcePos -> Qualifier

-- | Name
q_name :: Qualifier -> Symbol

-- | Parameters
q_params :: Qualifier -> [(Symbol, Sort)]

-- | Predicate
q_body :: Qualifier -> Pred

-- | Source Location
q_pos :: Qualifier -> !SourcePos

-- | Entities in Query File --------------------------------------------
data Def a
Srt :: Sort -> Def a
Axm :: Pred -> Def a
Cst :: (SubC a) -> Def a
Wfc :: (WfC a) -> Def a
Con :: Symbol -> Sort -> Def a
Qul :: Qualifier -> Def a
Kut :: KVar -> Def a
IBind :: Int -> Symbol -> SortedReft -> Def a

-- | Located Values
--   ---------------------------------------------------------
data Located a
Loc :: !SourcePos -> !SourcePos -> a -> Located a

-- | Start Position
loc :: Located a -> !SourcePos

-- | End Position
locE :: Located a -> !SourcePos
val :: Located a -> a
type LocSymbol = Located Symbol
type LocText = Located Text
dummyLoc :: a -> Located a
dummyPos :: String -> SourcePos
dummyName :: Symbol
isDummy :: Symbolic a => a -> Bool
instance Typeable KVar
instance Typeable SymConst
instance Typeable Brel
instance Typeable Bop
instance Typeable IBindEnv
instance Typeable SEnv
instance Typeable Located
instance Typeable FTycon
instance Typeable Sort
instance Typeable Constant
instance Typeable Expr
instance Typeable Pred
instance Typeable Subst
instance Typeable Qualifier
instance Typeable Refa
instance Typeable Reft
instance Typeable SortedReft
instance Eq KVar
instance Ord KVar
instance Data KVar
instance Generic KVar
instance IsString KVar
instance Show Kuts
instance Eq SymConst
instance Ord SymConst
instance Show SymConst
instance Data SymConst
instance Generic SymConst
instance Eq Brel
instance Ord Brel
instance Show Brel
instance Data Brel
instance Generic Brel
instance Eq Bop
instance Ord Bop
instance Show Bop
instance Data Bop
instance Generic Bop
instance Data IBindEnv
instance Eq a => Eq (SEnv a)
instance Data a => Data (SEnv a)
instance Generic (SEnv a)
instance Foldable SEnv
instance Traversable SEnv
instance Show a => Show (FixResult a)
instance Generic (FixResult a)
instance Data a => Data (Located a)
instance Generic (Located a)
instance Eq FTycon
instance Ord FTycon
instance Show FTycon
instance Data FTycon
instance Generic FTycon
instance Eq Sort
instance Ord Sort
instance Show Sort
instance Data Sort
instance Generic Sort
instance Eq Constant
instance Ord Constant
instance Show Constant
instance Data Constant
instance Generic Constant
instance Eq Expr
instance Ord Expr
instance Show Expr
instance Data Expr
instance Generic Expr
instance Eq Pred
instance Ord Pred
instance Show Pred
instance Data Pred
instance Generic Pred
instance Eq Subst
instance Ord Subst
instance Data Subst
instance Generic Subst
instance Eq Qualifier
instance Ord Qualifier
instance Show Qualifier
instance Data Qualifier
instance Generic Qualifier
instance Eq Refa
instance Ord Refa
instance Show Refa
instance Data Refa
instance Generic Refa
instance Eq Reft
instance Ord Reft
instance Data Reft
instance Generic Reft
instance Eq SortedReft
instance Show SortedReft
instance Data SortedReft
instance Generic SortedReft
instance Generic (WfC a)
instance Generic (SubC a)
instance Show BindEnv
instance Show (FInfo a)
instance Generic (Def a)
instance Datatype D1KVar
instance Constructor C1_0KVar
instance Selector S1_0_0KVar
instance Datatype D1SymConst
instance Constructor C1_0SymConst
instance Datatype D1Brel
instance Constructor C1_0Brel
instance Constructor C1_1Brel
instance Constructor C1_2Brel
instance Constructor C1_3Brel
instance Constructor C1_4Brel
instance Constructor C1_5Brel
instance Constructor C1_6Brel
instance Constructor C1_7Brel
instance Datatype D1Bop
instance Constructor C1_0Bop
instance Constructor C1_1Bop
instance Constructor C1_2Bop
instance Constructor C1_3Bop
instance Constructor C1_4Bop
instance Datatype D1SEnv
instance Constructor C1_0SEnv
instance Selector S1_0_0SEnv
instance Datatype D1FixResult
instance Constructor C1_0FixResult
instance Constructor C1_1FixResult
instance Constructor C1_2FixResult
instance Constructor C1_3FixResult
instance Datatype D1Located
instance Constructor C1_0Located
instance Selector S1_0_0Located
instance Selector S1_0_1Located
instance Selector S1_0_2Located
instance Datatype D1FTycon
instance Constructor C1_0FTycon
instance Datatype D1Sort
instance Constructor C1_0Sort
instance Constructor C1_1Sort
instance Constructor C1_2Sort
instance Constructor C1_3Sort
instance Constructor C1_4Sort
instance Constructor C1_5Sort
instance Constructor C1_6Sort
instance Constructor C1_7Sort
instance Datatype D1Constant
instance Constructor C1_0Constant
instance Constructor C1_1Constant
instance Constructor C1_2Constant
instance Datatype D1Expr
instance Constructor C1_0Expr
instance Constructor C1_1Expr
instance Constructor C1_2Expr
instance Constructor C1_3Expr
instance Constructor C1_4Expr
instance Constructor C1_5Expr
instance Constructor C1_6Expr
instance Constructor C1_7Expr
instance Constructor C1_8Expr
instance Constructor C1_9Expr
instance Datatype D1Pred
instance Constructor C1_0Pred
instance Constructor C1_1Pred
instance Constructor C1_2Pred
instance Constructor C1_3Pred
instance Constructor C1_4Pred
instance Constructor C1_5Pred
instance Constructor C1_6Pred
instance Constructor C1_7Pred
instance Constructor C1_8Pred
instance Constructor C1_9Pred
instance Constructor C1_10Pred
instance Constructor C1_11Pred
instance Datatype D1Subst
instance Constructor C1_0Subst
instance Datatype D1Qualifier
instance Constructor C1_0Qualifier
instance Selector S1_0_0Qualifier
instance Selector S1_0_1Qualifier
instance Selector S1_0_2Qualifier
instance Selector S1_0_3Qualifier
instance Datatype D1Refa
instance Constructor C1_0Refa
instance Selector S1_0_0Refa
instance Datatype D1Reft
instance Constructor C1_0Reft
instance Datatype D1SortedReft
instance Constructor C1_0SortedReft
instance Selector S1_0_0SortedReft
instance Selector S1_0_1SortedReft
instance Datatype D1WfC
instance Constructor C1_0WfC
instance Selector S1_0_0WfC
instance Selector S1_0_1WfC
instance Selector S1_0_2WfC
instance Selector S1_0_3WfC
instance Datatype D1SubC
instance Constructor C1_0SubC
instance Selector S1_0_0SubC
instance Selector S1_0_1SubC
instance Selector S1_0_2SubC
instance Selector S1_0_3SubC
instance Selector S1_0_4SubC
instance Selector S1_0_5SubC
instance Selector S1_0_6SubC
instance Datatype D1Def
instance Constructor C1_0Def
instance Constructor C1_1Def
instance Constructor C1_2Def
instance Constructor C1_3Def
instance Constructor C1_4Def
instance Constructor C1_5Def
instance Constructor C1_6Def
instance Constructor C1_7Def
instance NFData a => NFData (Located a)
instance Hashable a => Hashable (Located a)
instance Subable a => Subable (Located a)
instance Ord a => Ord (Located a)
instance Eq a => Eq (Located a)
instance Show a => Show (Located a)
instance Traversable Located
instance Foldable Located
instance Functor Located
instance Expression a => Expression (Located a)
instance Symbolic a => Symbolic (Located a)
instance Fixpoint a => Fixpoint (Located a)
instance Fixpoint SourcePos
instance IsString a => IsString (Located a)
instance SymConsts Pred
instance SymConsts Expr
instance SymConsts Refa
instance SymConsts Reft
instance SymConsts SortedReft
instance SymConsts (SubC a)
instance SymConsts (FInfo a)
instance Symbolic SymConst
instance Falseable Reft
instance Falseable Refa
instance Falseable Pred
instance Reftable SortedReft
instance Monoid SortedReft
instance Monoid Sort
instance Reftable Reft
instance Reftable ()
instance Subable ()
instance Monoid Reft
instance Monoid Refa
instance Monoid Pred
instance Monoid (FInfo a)
instance Monoid BindEnv
instance Monoid (SEnv a)
instance Monoid Kuts
instance NFData Qualifier
instance Fixpoint Qualifier
instance Hashable FTycon
instance NFData a => NFData (WfC a)
instance NFData a => NFData (SubC a)
instance NFData SortedReft
instance NFData Reft
instance NFData Refa
instance NFData Pred
instance NFData Expr
instance NFData Bop
instance NFData Brel
instance NFData SymConst
instance NFData Constant
instance NFData BindEnv
instance NFData IBindEnv
instance NFData FEnv
instance NFData Subst
instance NFData Sub
instance NFData Sort
instance NFData FTycon
instance Monoid Subst
instance Subable SortedReft
instance Subable Reft
instance Subable a => Subable (HashMap k a)
instance Subable a => Subable [a]
instance (Subable a, Subable b) => Subable (a, b)
instance Subable Refa
instance Subable Pred
instance Subable Expr
instance Subable Symbol
instance Fixpoint Int
instance Fixpoint (WfC a)
instance Fixpoint (SubC a)
instance Fixpoint IBindEnv
instance Show (SubC a)
instance Show (WfC a)
instance (Ord a, Fixpoint a) => Fixpoint (FixResult (SubC a))
instance Functor FixResult
instance Monoid (FixResult a)
instance Eq a => Eq (FixResult a)
instance Fixpoint (SEnv a) => Show (SEnv a)
instance Fixpoint a => Fixpoint (SEnv a)
instance Fixpoint BindEnv
instance Fixpoint SortedReft
instance Fixpoint Reft
instance Fixpoint Refa
instance Functor SEnv
instance Show Reft
instance Predicate Bool
instance Predicate Pred
instance Predicate Symbol
instance Expression Int
instance Expression Integer
instance Expression Text
instance Expression Symbol
instance Expression Expr
instance Fixpoint Pred
instance Hashable Pred
instance Hashable Expr
instance Hashable Subst
instance Hashable Constant
instance Hashable SymConst
instance Hashable Bop
instance Hashable Brel
instance Fixpoint Expr
instance Fixpoint Bop
instance Fixpoint Brel
instance Fixpoint Text
instance Fixpoint KVar
instance Fixpoint Symbol
instance Fixpoint SymConst
instance Fixpoint Constant
instance Fixpoint Double
instance Fixpoint Integer
instance Fixpoint Subst
instance Show Subst
instance Fixpoint FTycon
instance Fixpoint Sort
instance Hashable Sort
instance (Fixpoint a, Fixpoint b) => Fixpoint (a, b)
instance Fixpoint a => Fixpoint [a]
instance Fixpoint a => Fixpoint (Maybe a)
instance (Eq a, Hashable a, Fixpoint a) => Fixpoint (HashSet a)
instance Fixpoint Kuts
instance NFData Kuts
instance Hashable KVar
instance Show KVar

module Language.Fixpoint.PrettyPrint
class PPrint a where pprint = pprintPrec 0 pprintPrec _ = pprint
pprint :: PPrint a => a -> Doc
pprintPrec :: PPrint a => Int -> a -> Doc
showpp :: PPrint a => a -> String
tracepp :: PPrint a => String -> a -> a

-- | Wrap the enclosed <a>Doc</a> in parentheses only if the condition
--   holds.
parensIf :: Bool -> Doc -> Doc
opPrec :: Num a => Bop -> a
trueD :: Doc
falseD :: Doc
andD :: Doc
orD :: Doc
pprintBin :: PPrint a => Int -> Doc -> Doc -> [a] -> Doc
instance PPrint a => PPrint (Located a)
instance PPrint SortedReft
instance PPrint Reft
instance PPrint Refa
instance PPrint Pred
instance PPrint Expr
instance PPrint SymConst
instance PPrint KVar
instance PPrint Symbol
instance PPrint Sort
instance PPrint Bop
instance PPrint Brel
instance PPrint Constant
instance PPrint Integer
instance PPrint Int
instance PPrint String
instance PPrint ()
instance PPrint Bool
instance PPrint SourcePos
instance (PPrint a, PPrint b) => PPrint (a, b)
instance (PPrint a, PPrint b, PPrint c) => PPrint (a, b, c)
instance (PPrint a, PPrint b) => PPrint (HashMap a b)
instance PPrint a => PPrint [a]
instance PPrint a => PPrint (Maybe a)

module Language.Fixpoint.Errors

-- | A Reusable SrcSpan Type ------------------------------------------
data SrcSpan
SS :: !SourcePos -> !SourcePos -> SrcSpan
sp_start :: SrcSpan -> !SourcePos
sp_stop :: SrcSpan -> !SourcePos
dummySpan :: SrcSpan
sourcePosElts :: SourcePos -> (SourceName, Line, Column)

-- | A BareBones Error Type -------------------------------------------
data Error
err :: SrcSpan -> String -> Error
errLoc :: Error -> SrcSpan
errMsg :: Error -> String
catMessage :: Error -> String -> Error
catError :: Error -> Error -> Error
die :: Error -> a
exit :: a -> IO a -> IO a
instance Typeable SrcSpan
instance Typeable Error
instance Eq SrcSpan
instance Ord SrcSpan
instance Show SrcSpan
instance Data SrcSpan
instance Generic SrcSpan
instance Eq Error
instance Ord Error
instance Show Error
instance Data Error
instance Generic Error
instance Datatype D1SrcSpan
instance Constructor C1_0SrcSpan
instance Selector S1_0_0SrcSpan
instance Selector S1_0_1SrcSpan
instance Datatype D1Error
instance Constructor C1_0Error
instance Selector S1_0_0Error
instance Selector S1_0_1Error
instance Error Error
instance Exception Error
instance Fixpoint Error
instance PPrint Error
instance Hashable SrcSpan
instance Hashable SourcePos
instance PPrint SrcSpan

module Language.Fixpoint.Visitor
data Visitor acc ctx
Visitor :: (ctx -> Expr -> ctx) -> (ctx -> Pred -> ctx) -> (ctx -> Expr -> Expr) -> (ctx -> Pred -> Pred) -> (ctx -> Expr -> acc) -> (ctx -> Pred -> acc) -> Visitor acc ctx

-- | Context <tt>ctx</tt> is built in a "top-down" fashion; not "across"
--   siblings
ctxExpr :: Visitor acc ctx -> ctx -> Expr -> ctx
ctxPred :: Visitor acc ctx -> ctx -> Pred -> ctx

-- | Transforms can access current <tt>ctx</tt>
txExpr :: Visitor acc ctx -> ctx -> Expr -> Expr
txPred :: Visitor acc ctx -> ctx -> Pred -> Pred

-- | Accumulations can access current <tt>ctx</tt>; <tt>acc</tt> value is
--   monoidal
accExpr :: Visitor acc ctx -> ctx -> Expr -> acc
accPred :: Visitor acc ctx -> ctx -> Pred -> acc
defaultVisitor :: Monoid acc => Visitor acc ctx
trans :: (Visitable t, Monoid a) => Visitor a ctx -> ctx -> a -> t -> t
fold :: (Visitable t, Monoid a) => Visitor a ctx -> ctx -> a -> t -> a
kvars :: Visitable t => t -> [KVar]
envKVars :: BindEnv -> SubC a -> [KVar]
mapKVars :: Visitable t => (KVar -> Maybe Pred) -> t -> t

-- | Visitors over <tt>Sort</tt>
foldSort :: (a -> Sort -> a) -> a -> Sort -> a
mapSort :: (Sort -> Sort) -> Sort -> Sort
instance Visitable Reft
instance Visitable Refa
instance Visitable Pred
instance Visitable Expr


-- | This module has the functions that perform sort-checking, and related
--   operations on Fixpoint expressions and predicates.
module Language.Fixpoint.Sort

-- | API for manipulating Sort Substitutions ---------------------------
data TVSubst
checkSorted :: Checkable a => SEnv Sort -> a -> Maybe Doc

-- | Checking Refinements -----------------------------------------------
checkSortedReft :: SEnv SortedReft -> [Symbol] -> SortedReft -> Maybe Doc
checkSortedReftFull :: Checkable a => SEnv SortedReft -> a -> Maybe Doc
checkSortFull :: Checkable a => SEnv SortedReft -> Sort -> a -> Maybe Doc
pruneUnsortedReft :: SEnv Sort -> SortedReft -> SortedReft

-- | Unification of Sorts
unify :: Sort -> Sort -> Maybe TVSubst

-- | Applying a Type Substitution ---------------------------------------
apply :: TVSubst -> Sort -> Sort
instance Checkable SortedReft
instance Checkable Pred
instance Checkable Expr
instance Checkable Refa


-- | This module contains an SMTLIB2 interface for 1. checking the
--   validity, and, 2. computing satisfying assignments for formulas. By
--   implementing a binary interface over the SMTLIB2 format defined at
--   <a>http://www.smt-lib.org/</a>
--   <a>http://www.grammatech.com/resource/smt/SMTLIBTutorial.pdf</a>
module Language.Fixpoint.SmtLib2

-- | Commands issued to SMT engine
data Command
Push :: Command
Pop :: Command
CheckSat :: Command
Declare :: Symbol -> [Sort] -> Sort -> Command
Define :: Sort -> Command
Assert :: (Maybe Int) -> Pred -> Command
Distinct :: [Expr] -> Command
GetValue :: [Symbol] -> Command

-- | Responses received from SMT engine
data Response
Ok :: Response
Sat :: Response
Unsat :: Response
Unknown :: Response
Values :: [(Symbol, Raw)] -> Response
Error :: Raw -> Response

-- | AST Conversion ---------------------------------------------------
--   
--   Types that can be serialized
class SMTLIB2 a
smt2 :: SMTLIB2 a => a -> Text

-- | Information about the external SMT process
data Context
Ctx :: ProcessHandle -> Handle -> Handle -> Maybe Handle -> Bool -> Context
pId :: Context -> ProcessHandle
cIn :: Context -> Handle
cOut :: Context -> Handle
cLog :: Context -> Maybe Handle
verbose :: Context -> Bool

-- | SMT Context ---------------------------------------------------------
makeContext :: SMTSolver -> FilePath -> IO Context
makeContextNoLog :: SMTSolver -> IO Context
cleanupContext :: Context -> IO ExitCode

-- | SMT IO --------------------------------------------------------------
command :: Context -> Command -> IO Response
smtWrite :: Context -> Text -> IO ()
smtDecl :: Context -> Symbol -> Sort -> IO ()
smtAssert :: Context -> Pred -> IO ()
smtCheckUnsat :: Context -> IO Bool
smtBracket :: Context -> IO a -> IO a
smtDistinct :: Context -> [Expr] -> IO ()
smt_set_funs :: HashMap Symbol Raw
instance Eq Command
instance Show Command
instance Eq Response
instance Show Response
instance SMTLIB2 Command
instance SMTLIB2 Pred
instance SMTLIB2 Expr
instance SMTLIB2 Brel
instance SMTLIB2 Bop
instance SMTLIB2 LocSymbol
instance SMTLIB2 Constant
instance SMTLIB2 SymConst
instance SMTLIB2 Symbol
instance SMTLIB2 Sort

module Language.Fixpoint.Solver.Solution

-- | Types ----------------------------------------------------------
type Solution = Sol KBind
type Cand a = [(Pred, a)]

-- | Expanded or Instantiated Qualifier -----------------------------
data EQual
EQL :: !Qualifier -> !Pred -> ![Expr] -> EQual
eqQual :: EQual -> !Qualifier
eqPred :: EQual -> !Pred
eqArgs :: EQual -> ![Expr]

-- | Apply Solution -------------------------------------------------
class Solvable a
apply :: Solvable a => Solution -> a -> Pred

-- | Initial Solution (from Qualifiers and WF constraints) ---------
init :: Config -> FInfo a -> Solution

-- | Update Solution ---------------------------------------------------
update :: Solution -> [KVar] -> [(KVar, EQual)] -> (Bool, Solution)
lookup :: Solution -> KVar -> KBind
instance Eq EQual
instance Ord EQual
instance Show EQual
instance Solvable a => Solvable [a]
instance Solvable (Symbol, SortedReft)
instance Solvable SortedReft
instance Solvable Reft
instance Solvable Refa
instance Solvable Pred
instance Solvable (KVar, Subst)
instance Solvable KVar
instance Solvable EQual
instance PPrint EQual


-- | Validate and Transform Constraints to Ensure various Invariants
--   ------------------------- 1. Each binder must be unique
module Language.Fixpoint.Solver.Validate
validate :: Config -> FInfo a -> Either Error (FInfo a)

-- | symbol |-&gt; sort for EVERY variable in the FInfo
symbolSorts :: FInfo a -> Either Error [(Symbol, Sort)]


-- | This is a wrapper around IO that permits SMT queries
module Language.Fixpoint.Solver.Monad

-- | Solver Monadic API ---------------------------------------------------
type SolveM = StateT SolverState IO
runSolverM :: Config -> FInfo b -> SolveM a -> IO a
getBinds :: SolveM BindEnv

-- | SMT Interface --------------------------------------------------------
filterValid :: Pred -> Cand a -> SolveM [a]
tickIter :: SolveM Int

module Language.Fixpoint.Bitvector
data Bv
Bv :: BvSize -> String -> Bv
data BvSize
S32 :: BvSize
S64 :: BvSize
data BvOp
BvAnd :: BvOp
BvOr :: BvOp

-- | Construct the bitvector <a>Sort</a> from its <a>BvSize</a>
mkSort :: BvSize -> Sort

-- | Apply some bitvector operator to a list of arguments
eOp :: BvOp -> [Expr] -> Expr
bvTyCon :: FTycon
instance Typeable BvSize
instance Typeable BvOp
instance Eq BvSize
instance Ord BvSize
instance Show BvSize
instance Data BvSize
instance Generic BvSize
instance Eq BvOp
instance Ord BvOp
instance Show BvOp
instance Data BvOp
instance Generic BvOp
instance Datatype D1BvSize
instance Constructor C1_0BvSize
instance Constructor C1_1BvSize
instance Datatype D1BvOp
instance Constructor C1_0BvOp
instance Constructor C1_1BvOp
instance Expression Bv

module Language.Fixpoint.Parse
class Inputable a where rr' _ = rr rr = rr' ""
rr :: Inputable a => String -> a
rr' :: Inputable a => String -> String -> a
type Parser = Parsec String Integer
lexer :: GenTokenParser String u Identity
reserved :: String -> ParsecT String u Identity ()
reservedOp :: String -> ParsecT String u Identity ()
parens :: ParsecT String u Identity a -> ParsecT String u Identity a
brackets :: ParsecT String u Identity a -> ParsecT String u Identity a
angles :: ParsecT String u Identity a -> ParsecT String u Identity a
braces :: ParsecT String u Identity a -> ParsecT String u Identity a
semi :: ParsecT String u Identity String
comma :: ParsecT String u Identity String
colon :: ParsecT String u Identity String
dcolon :: Stream s m Char => ParsecT s u m String
whiteSpace :: ParsecT String u Identity ()
blanks :: Stream s m Char => ParsecT s u m [Char]
fTyConP :: ParsecT String Integer Identity FTycon
lowerIdP :: Parser Symbol
upperIdP :: Parser Symbol
symbolP :: Parser Symbol
constantP :: Parser Constant
integer :: Stream s m Char => ParsecT s u m Integer
bindP :: ParsecT String Integer Identity Symbol
exprP :: Parser Expr
predP :: Parser Pred
funAppP :: ParsecT String Integer Identity Expr

-- | Parsing Qualifiers ---------------------------------------------
qualifierP :: ParsecT String Integer Identity Qualifier
refP :: Parser (Reft -> a) -> Parser a
refDefP :: Symbol -> Parser Refa -> Parser (Reft -> a) -> Parser a
refBindP :: Parser Symbol -> Parser Refa -> Parser (Reft -> a) -> Parser a
condIdP :: [Char] -> (String -> Bool) -> Parser Symbol
locParserP :: Parser a -> Parser (Located a)
locLowerIdP :: Parser (Located Symbol)
locUpperIdP :: Parser (Located Symbol)
freshIntP :: Parser Integer
doParse' :: Num u => ParsecT String u Identity a -> SourceName -> String -> a
parseFromFile :: Parser b -> SourceName -> IO b
remainderP :: Monad m => ParsecT t1 u m t -> ParsecT t1 u m (t, t1, SourcePos)
instance Inputable [Command]
instance Inputable Command
instance Inputable (FInfo ())
instance Inputable (FixResult Integer, FixSolution)
instance Inputable (FixResult Integer)
instance Inputable Refa
instance Inputable Expr
instance Inputable Pred
instance Inputable Constant
instance Inputable Symbol

module Language.Fixpoint.Solver.Deps

-- | Dummy just for debugging --------------------------------
solve :: Config -> FInfo a -> IO (FixResult a)

-- | Compute Dependencies and Cuts ---------------------------
deps :: FInfo a -> Deps
data Deps
Deps :: ![KVar] -> ![KVar] -> Deps
depCuts :: Deps -> ![KVar]
depNonCuts :: Deps -> ![KVar]
lhsKVars :: BindEnv -> SubC a -> [KVar]
rhsKVars :: SubC a -> [KVar]
instance Eq Deps
instance Ord Deps
instance Show Deps

module Language.Fixpoint.Solver.Eliminate
eliminateAll :: FInfo a -> FInfo a
instance Elimable BindEnv
instance Elimable (FInfo a)
instance Elimable Reft
instance Elimable SortedReft
instance Elimable (SubC a)

module Language.Fixpoint.Solver.Worklist
data Worklist a

-- | Worklist -------------------------------------------------------------
init :: Config -> FInfo a -> Worklist a
pop :: Worklist a -> Maybe (SubC a, Worklist a)
push :: SubC a -> Worklist a -> Worklist a
instance PPrint (Worklist a)


-- | Solve a system of horn-clause constraints ----------------------------
module Language.Fixpoint.Solver.Solve
solve :: Config -> FInfo a -> IO (Result a)


-- | This module implements the top-level API for interfacing with Fixpoint
--   In particular it exports the functions that solve constraints supplied
--   either as .fq files or as FInfo.
module Language.Fixpoint.Interface
data FInfo a
FI :: HashMap Integer (SubC a) -> ![WfC a] -> !BindEnv -> !FEnv -> ![(Symbol, Sort)] -> Kuts -> ![Qualifier] -> FInfo a

-- | Solve FInfo system of horn-clause constraints ------------------------
solve :: Config -> FInfo a -> IO (Result a)

-- | Solve .fq File -------------------------------------------------------
solveFQ :: Config -> IO ExitCode
resultExit :: FixResult a -> ExitCode

-- | Parse External Qualifiers --------------------------------------------
parseFInfo :: [FilePath] -> IO (FInfo a)
