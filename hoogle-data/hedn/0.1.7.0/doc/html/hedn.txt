-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | EDN parsing and encoding
--   
--   A EDN parsing and encoding library inspired by Data.Aeson.
--   
--   Based on specs published at <a>https://github.com/edn-format/edn</a>.
@package hedn
@version 0.1.7.0

module Data.EDN.Types

-- | A "raw" EDN value represented as a Haskell value.
data Value
Nil :: Value
Boolean :: !Bool -> Value
String :: !Text -> Value
Character :: !Char -> Value
Symbol :: !ByteString -> !ByteString -> Value
Keyword :: !ByteString -> Value
Integer :: !Integer -> Value
Floating :: !Double -> Value
List :: EDNList -> Value
Vec :: !EDNVec -> Value
Map :: !EDNMap -> Value
Set :: !EDNSet -> Value

-- | Abstract namespaced tag.
data Tagged a
NoTag :: !a -> Tagged a
Tagged :: !a -> !ByteString -> !ByteString -> Tagged a
type TaggedValue = Tagged Value
type EDNList = [TaggedValue]
type EDNVec = Vector TaggedValue
type EDNSet = Set TaggedValue
type EDNMap = Map Value TaggedValue

-- | A key/value pair for a EDN Map
type Pair = (Value, TaggedValue)

-- | Replace a tag on a <a>Tagged</a> value.
setTag :: ByteString -> ByteString -> Tagged a -> Tagged a

-- | Extract namespace and tag from a tagged container. Will be a pair of
--   <a>empty</a> for tagless containers.
getTag :: TaggedValue -> (ByteString, ByteString)

-- | Extract bare value from a tagged or tagless container.
stripTag :: Tagged a -> a

-- | Attach a namespaced tag to a value.
tag :: ByteString -> ByteString -> a -> Tagged a

-- | Wrap a value into tagless container.
notag :: a -> Tagged a

-- | Basic EDN nil.
nil :: TaggedValue

-- | Basic EDN boolean.
bool :: Bool -> TaggedValue

-- | Const EDN True.
true :: TaggedValue

-- | Const EDN False.
false :: TaggedValue

-- | Basic EDN character.
char :: Char -> TaggedValue

-- | Basic EDN string.
string :: Text -> TaggedValue

-- | "Bare" symbol.
symbol :: ByteString -> TaggedValue

-- | A namespaced symbol.
symbolNS :: ByteString -> ByteString -> TaggedValue

-- | Basic EDN keyword.
keyword :: ByteString -> TaggedValue

-- | Basic EDN integer.
integer :: Integer -> TaggedValue

-- | Basic EDN fp number.
floating :: Double -> TaggedValue

-- | Create an EDN <a>List</a> from a <a>Value</a> list wrapping them into
--   empty tags.
makeList :: [TaggedValue] -> Value

-- | Create an EDN <tt>Vector</tt> from a <a>TaggedValue</a> list.
makeVec :: [TaggedValue] -> Value

-- | Create an EDN <a>Set</a> from a <a>TaggedValue</a> list.
makeSet :: [TaggedValue] -> Value

-- | Create an EDN <a>Map</a> from a assoc list with untagged keys and
--   tagged values.
makeMap :: [Pair] -> Value
instance Eq a => Eq (Tagged a)
instance Ord a => Ord (Tagged a)
instance Show a => Show (Tagged a)
instance Eq Value
instance Ord Value
instance Show Value
instance NFData Value
instance IsString (Tagged Value)
instance IsString Value
instance NFData a => NFData (Tagged a)
instance Functor Tagged


-- | Parse an UTF-8 encoded EDN string into a haskell representation of EDN
--   objects. Use <a>decode</a> to get actual types.
module Data.EDN.Parser

-- | Parse a lazy <a>ByteString</a> into a <a>TaggedValue</a>. If fails due
--   to incomplete or invalid input, <a>Nothing</a> is returned.
parseMaybe :: ByteString -> Maybe TaggedValue

-- | Parse a lazy <a>ByteString</a>.
parseBSL :: ByteString -> Result TaggedValue

-- | Parse a strict <a>ByteString</a>, but without continutations.
parseBS :: ByteString -> Result TaggedValue

-- | Parse a strict <a>Text</a>.
parseT :: Text -> Result TaggedValue

-- | Parse a lazy <a>Text</a>.
parseTL :: Text -> Result TaggedValue

-- | Parse a string AKA '[Char]'. Not really useful other than for
--   debugging purposes.
parseS :: [Char] -> Result TaggedValue

-- | Parse a "raw" EDN value into a <a>Value</a>.
parseValue :: Parser Value

-- | Parse a probably tagged EDN value into a <a>TaggedValue</a>.
parseTagged :: Parser TaggedValue

module Data.EDN.Types.Class

-- | A type that can be converted to JSON.
class ToEDN a where toEDN = notag . toEDNv toEDNv = stripTag . toEDN
toEDN :: ToEDN a => a -> TaggedValue
toEDNv :: ToEDN a => a -> Value

-- | A type that can be converted from EDN, with a possibility of failure.
--   
--   When writing an instance, use <tt>empty</tt>, <tt>mzero</tt>, or
--   <a>fail</a> to make a conversion fail, e.g. if an <a>Map</a> is
--   missing a required key, or the value is of the wrong type.
class FromEDN a where parseEDN = parseEDNv . stripTag parseEDNv = parseEDN . notag
parseEDN :: FromEDN a => TaggedValue -> Parser a
parseEDNv :: FromEDN a => Value -> Parser a

-- | Convert a value from <a>TaggedValue</a>, failing if the types do not
--   match.
fromEDN :: FromEDN a => TaggedValue -> Result a

-- | Convert a value from <a>Value</a>, failing if the types do not match.
fromEDNv :: FromEDN a => Value -> Result a

-- | Deserializes a EDN value from a lazy <a>ByteString</a>. If this fails
--   to to incomplete or invalid input, <a>Nothing</a> is returned.
decode :: FromEDN a => ByteString -> Maybe a

-- | Run a <a>Parser</a>.
parse :: (a -> Parser b) -> a -> Result b

-- | Run a <a>Parser</a> with an <a>Either</a> result type.
parseEither :: (a -> Parser b) -> a -> Either String b

-- | Run a <a>Parser</a> with a <a>Maybe</a> result type.
parseMaybe :: (a -> Parser b) -> a -> Maybe b

-- | A continuation-based parser type.
data Parser a

-- | The result of running a <a>Parser</a>.
data Result a
Error :: String -> Result a
Success :: a -> Result a

-- | Construct a <tt>Pair</tt> from a key (as EDN keyword) and a value.
(.=) :: ToEDN a => ByteString -> a -> Pair

-- | Retrieve the value associated with the given key of an <a>EDNMap</a>.
--   The result is <tt>empty</tt> if the key is not present or the value
--   cannot be converted to the desired type.
--   
--   This accessor is appropriate if the key and value <i>must</i> be
--   present in an object for it to be valid. If the key and value are
--   optional, use '(.:?)' instead.
(.:) :: (Show k, ToEDN k, FromEDN a) => EDNMap -> k -> Parser a

-- | Retrieve the value associated with the given key of an <a>EDNMap</a>.
--   The result is <a>Nothing</a> if the key is not present, or
--   <tt>empty</tt> if the value cannot be converted to the desired type.
--   
--   This accessor is most useful if the key and value can be absent from
--   an object without affecting its validity. If the key and value are
--   mandatory, use '(.:)' instead.
(.:?) :: (ToEDN k, FromEDN a) => EDNMap -> k -> Parser (Maybe a)

-- | Helper for use in combination with <a>.:?</a> to provide default
--   values for optional JSON object fields.
--   
--   This combinator is most useful if the key and value can be absent from
--   an object without affecting its validity and we know a default value
--   to assign in that case. If the key and value are mandatory, use '(.:)'
--   instead.
--   
--   Example usage:
--   
--   <pre>
--   v1 &lt;- o <a>.:?</a> "opt_field_with_dfl" .!= "default_val"
--   v2 &lt;- o <a>.:</a>  "mandatory_field"
--   v3 &lt;- o <a>.:?</a> "opt_field2"
--   </pre>
(.!=) :: Parser (Maybe a) -> a -> Parser a

-- | Fail parsing due to a type mismatch, with a descriptive message.
typeMismatch :: String -> Value -> Parser a
instance [incoherent] FromEDN TaggedValue
instance [incoherent] ToEDN TaggedValue
instance [incoherent] FromEDN Value
instance [incoherent] ToEDN Value
instance [incoherent] (FromEDN a, FromEDN b, FromEDN c, FromEDN d, FromEDN e, FromEDN f, FromEDN g, FromEDN h) => FromEDN (a, b, c, d, e, f, g, h)
instance [incoherent] (ToEDN a, ToEDN b, ToEDN c, ToEDN d, ToEDN e, ToEDN f, ToEDN g, ToEDN h) => ToEDN (a, b, c, d, e, f, g, h)
instance [incoherent] (FromEDN a, FromEDN b, FromEDN c, FromEDN d, FromEDN e, FromEDN f, FromEDN g) => FromEDN (a, b, c, d, e, f, g)
instance [incoherent] (ToEDN a, ToEDN b, ToEDN c, ToEDN d, ToEDN e, ToEDN f, ToEDN g) => ToEDN (a, b, c, d, e, f, g)
instance [incoherent] (FromEDN a, FromEDN b, FromEDN c, FromEDN d, FromEDN e, FromEDN f) => FromEDN (a, b, c, d, e, f)
instance [incoherent] (ToEDN a, ToEDN b, ToEDN c, ToEDN d, ToEDN e, ToEDN f) => ToEDN (a, b, c, d, e, f)
instance [incoherent] (FromEDN a, FromEDN b, FromEDN c, FromEDN d, FromEDN e) => FromEDN (a, b, c, d, e)
instance [incoherent] (ToEDN a, ToEDN b, ToEDN c, ToEDN d, ToEDN e) => ToEDN (a, b, c, d, e)
instance [incoherent] (FromEDN a, FromEDN b, FromEDN c, FromEDN d) => FromEDN (a, b, c, d)
instance [incoherent] (ToEDN a, ToEDN b, ToEDN c, ToEDN d) => ToEDN (a, b, c, d)
instance [incoherent] (FromEDN a, FromEDN b, FromEDN c) => FromEDN (a, b, c)
instance [incoherent] (ToEDN a, ToEDN b, ToEDN c) => ToEDN (a, b, c)
instance [incoherent] (FromEDN a, FromEDN b) => FromEDN (a, b)
instance [incoherent] (ToEDN a, ToEDN b) => ToEDN (a, b)
instance [incoherent] (Ord a, FromEDN a, FromEDN b) => FromEDN (Map a b)
instance [incoherent] (ToEDN a, ToEDN b) => ToEDN (Map a b)
instance [incoherent] (Ord a, FromEDN a) => FromEDN (Set a)
instance [incoherent] (Ord a, ToEDN a) => ToEDN (Set a)
instance [incoherent] FromEDN a => FromEDN (Vector a)
instance [incoherent] ToEDN a => ToEDN (Vector a)
instance [incoherent] FromEDN a => FromEDN [a]
instance [incoherent] ToEDN a => ToEDN [a]
instance [incoherent] FromEDN UTCTime
instance [incoherent] ToEDN UTCTime
instance [incoherent] FromEDN Int
instance [incoherent] ToEDN Int
instance [incoherent] FromEDN Integer
instance [incoherent] ToEDN Integer
instance [incoherent] FromEDN Double
instance [incoherent] ToEDN Double
instance [incoherent] FromEDN Char
instance [incoherent] ToEDN Char
instance [incoherent] FromEDN ByteString
instance [incoherent] ToEDN ByteString
instance [incoherent] FromEDN ByteString
instance [incoherent] ToEDN ByteString
instance [incoherent] FromEDN Text
instance [incoherent] ToEDN Text
instance [incoherent] FromEDN Text
instance [incoherent] ToEDN Text
instance [incoherent] FromEDN [Char]
instance [incoherent] ToEDN [Char]
instance [incoherent] FromEDN ()
instance [incoherent] ToEDN ()
instance [incoherent] FromEDN Bool
instance [incoherent] ToEDN Bool
instance [incoherent] FromEDN a => FromEDN (Tagged a)
instance [incoherent] ToEDN a => ToEDN (Tagged a)
instance [incoherent] (FromEDN a, FromEDN b) => FromEDN (Either a b)
instance [incoherent] (ToEDN a, ToEDN b) => ToEDN (Either a b)
instance [incoherent] FromEDN a => FromEDN (Maybe a)
instance [incoherent] ToEDN a => ToEDN (Maybe a)

module Data.EDN.Encode

-- | Encode a raw EDN value to a <a>Builder</a>.
fromValue :: Value -> Builder

-- | Encode a Tagged EDN value to a <a>Builder</a>.
fromTagged :: TaggedValue -> Builder

-- | Serialize a value as a lazy <a>ByteString</a>.
encode :: ToEDN a => a -> ByteString

module Data.EDN

-- | Deserializes a EDN value from a lazy <a>ByteString</a>. If this fails
--   to to incomplete or invalid input, <a>Nothing</a> is returned.
decode :: FromEDN a => ByteString -> Maybe a

-- | Serialize a value as a lazy <a>ByteString</a>.
encode :: ToEDN a => a -> ByteString

-- | A "raw" EDN value represented as a Haskell value.
data Value
Nil :: Value
Boolean :: !Bool -> Value
String :: !Text -> Value
Character :: !Char -> Value
Symbol :: !ByteString -> !ByteString -> Value
Keyword :: !ByteString -> Value
Integer :: !Integer -> Value
Floating :: !Double -> Value
List :: EDNList -> Value
Vec :: !EDNVec -> Value
Map :: !EDNMap -> Value
Set :: !EDNSet -> Value
type TaggedValue = Tagged Value

-- | Abstract namespaced tag.
data Tagged a
NoTag :: !a -> Tagged a
Tagged :: !a -> !ByteString -> !ByteString -> Tagged a

-- | A type that can be converted to JSON.
class ToEDN a where toEDN = notag . toEDNv toEDNv = stripTag . toEDN
toEDN :: ToEDN a => a -> TaggedValue

-- | A type that can be converted from EDN, with a possibility of failure.
--   
--   When writing an instance, use <tt>empty</tt>, <tt>mzero</tt>, or
--   <a>fail</a> to make a conversion fail, e.g. if an <a>Map</a> is
--   missing a required key, or the value is of the wrong type.
class FromEDN a where parseEDN = parseEDNv . stripTag parseEDNv = parseEDN . notag

-- | Convert a value from <a>TaggedValue</a>, failing if the types do not
--   match.
fromEDN :: FromEDN a => TaggedValue -> Result a

-- | Convert a value from <a>Value</a>, failing if the types do not match.
fromEDNv :: FromEDN a => Value -> Result a

-- | Retrieve the value associated with the given key of an <a>EDNMap</a>.
--   The result is <tt>empty</tt> if the key is not present or the value
--   cannot be converted to the desired type.
--   
--   This accessor is appropriate if the key and value <i>must</i> be
--   present in an object for it to be valid. If the key and value are
--   optional, use '(.:?)' instead.
(.:) :: (Show k, ToEDN k, FromEDN a) => EDNMap -> k -> Parser a

-- | Retrieve the value associated with the given key of an <a>EDNMap</a>.
--   The result is <a>Nothing</a> if the key is not present, or
--   <tt>empty</tt> if the value cannot be converted to the desired type.
--   
--   This accessor is most useful if the key and value can be absent from
--   an object without affecting its validity. If the key and value are
--   mandatory, use '(.:)' instead.
(.:?) :: (ToEDN k, FromEDN a) => EDNMap -> k -> Parser (Maybe a)

-- | Helper for use in combination with <a>.:?</a> to provide default
--   values for optional JSON object fields.
--   
--   This combinator is most useful if the key and value can be absent from
--   an object without affecting its validity and we know a default value
--   to assign in that case. If the key and value are mandatory, use '(.:)'
--   instead.
--   
--   Example usage:
--   
--   <pre>
--   v1 &lt;- o <a>.:?</a> "opt_field_with_dfl" .!= "default_val"
--   v2 &lt;- o <a>.:</a>  "mandatory_field"
--   v3 &lt;- o <a>.:?</a> "opt_field2"
--   </pre>
(.!=) :: Parser (Maybe a) -> a -> Parser a

-- | Attach a namespaced tag to a value.
tag :: ByteString -> ByteString -> a -> Tagged a

-- | Wrap a value into tagless container.
notag :: a -> Tagged a

-- | Basic EDN nil.
nil :: TaggedValue

-- | Basic EDN boolean.
bool :: Bool -> TaggedValue

-- | Const EDN True.
true :: TaggedValue

-- | Const EDN False.
false :: TaggedValue

-- | Basic EDN character.
char :: Char -> TaggedValue

-- | Basic EDN string.
string :: Text -> TaggedValue

-- | "Bare" symbol.
symbol :: ByteString -> TaggedValue

-- | A namespaced symbol.
symbolNS :: ByteString -> ByteString -> TaggedValue

-- | Basic EDN keyword.
keyword :: ByteString -> TaggedValue

-- | Basic EDN integer.
integer :: Integer -> TaggedValue

-- | Basic EDN fp number.
floating :: Double -> TaggedValue

-- | Create an EDN <a>List</a> from a <a>Value</a> list wrapping them into
--   empty tags.
makeList :: [TaggedValue] -> Value

-- | Create an EDN <tt>Vector</tt> from a <a>TaggedValue</a> list.
makeVec :: [TaggedValue] -> Value

-- | Create an EDN <a>Set</a> from a <a>TaggedValue</a> list.
makeSet :: [TaggedValue] -> Value

-- | Create an EDN <a>Map</a> from a assoc list with untagged keys and
--   tagged values.
makeMap :: [Pair] -> Value

-- | A key/value pair for a EDN Map
type Pair = (Value, TaggedValue)

-- | Construct a <tt>Pair</tt> from a key (as EDN keyword) and a value.
(.=) :: ToEDN a => ByteString -> a -> Pair

-- | Replace a tag on a <a>Tagged</a> value.
setTag :: ByteString -> ByteString -> Tagged a -> Tagged a

-- | Extract namespace and tag from a tagged container. Will be a pair of
--   <a>empty</a> for tagless containers.
getTag :: TaggedValue -> (ByteString, ByteString)

-- | Extract bare value from a tagged or tagless container.
stripTag :: Tagged a -> a

-- | Parse a lazy <a>ByteString</a> into a <a>TaggedValue</a>. If fails due
--   to incomplete or invalid input, <a>Nothing</a> is returned.
parseMaybe :: ByteString -> Maybe TaggedValue
