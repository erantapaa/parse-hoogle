-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Tools for manipulating fingertrees of bytestrings with optional annotations
--   
--   Tools for manipulating fingertrees of bytestrings with optional
--   annotations
@package rope
@version 0.6.2

module Data.Rope.Body
type Body = FingerTree Offset Chunk
newtype Offset
Offset :: Int -> Offset
getOffset :: Offset -> Int
newtype Chunk
Chunk :: ByteString -> Chunk
unchunk :: Chunk -> ByteString
measureBody :: Measured Offset a => FingerTree Offset a -> Int
consBody :: ByteString -> Body -> Body
snocBody :: Body -> ByteString -> Body
packBody :: ByteString -> FingerTree Offset Chunk
instance Typeable Offset
instance Typeable Chunk
instance Eq Offset
instance Ord Offset
instance Num Offset
instance Show Offset
instance Read Offset
instance Enum Offset
instance Data Offset
instance Eq Chunk
instance Ord Chunk
instance Show Chunk
instance Read Chunk
instance Data Chunk
instance Measured Offset Chunk
instance Monoid Offset

module Data.Rope.Branded.Comonad
class Functor w => Comonad w where duplicate = extend id extend f = fmap f . duplicate
extract :: Comonad w => w a -> a
duplicate :: Comonad w => w a -> w (w a)
extend :: Comonad w => (w a -> b) -> w a -> w b

module Data.Rope.Internal
newtype Rope
Rope :: Body -> Rope
body :: Rope -> Body
class Packable c where pack = snoc mempty snoc m = mappend m . pack cons = mappend . pack
pack :: Packable c => c -> Rope
snoc :: Packable c => Rope -> c -> Rope
cons :: Packable c => c -> Rope -> Rope
empty :: Rope
fromChunks :: [ByteString] -> Rope
fromByteString :: ByteString -> Rope
fromLazyByteString :: ByteString -> Rope
fromString :: String -> Rope
fromWords :: [Word8] -> Rope
fromChar :: Char -> Rope
fromWord8 :: Word8 -> Rope
length :: Rope -> Int
null :: Rope -> Bool
toChunks :: Rope -> [ByteString]
toString :: Rope -> String
toLazyByteString :: Rope -> ByteString
splitAt :: Int -> Rope -> (Rope, Rope)
take :: Int -> Rope -> Rope
drop :: Int -> Rope -> Rope
class Unpackable a where head = head . unpack
unpack :: Unpackable a => Rope -> [a]
head :: Unpackable a => Rope -> a
last :: Unpackable a => Rope -> a
uncons :: Unpackable a => Rope -> Maybe (a, Rope)
unsnoc :: Unpackable a => Rope -> Maybe (Rope, a)
class Breakable a where span f = break (not . f) takeWhile f = fst . span f dropWhile f = snd . span f
break :: Breakable a => (a -> Bool) -> Rope -> (Rope, Rope)
span :: Breakable a => (a -> Bool) -> Rope -> (Rope, Rope)
takeWhile :: Breakable a => (a -> Bool) -> Rope -> Rope
dropWhile :: Breakable a => (a -> Bool) -> Rope -> Rope
w2c :: Word8 -> Char
findIndexOrEnd :: (Word8 -> Bool) -> ByteString -> Int
instance Typeable Rope
instance Show Rope
instance Unpackable Chunk
instance Unpackable ByteString
instance Unpackable Char
instance Unpackable Word8
instance UTF8Bytes Rope Int
instance Packable Chunk
instance Packable ByteString
instance Packable ByteString
instance Packable [Word8]
instance Packable String
instance Packable Rope
instance Packable Word8
instance Packable Char
instance Breakable Word8
instance Data Rope
instance Measured Offset Rope
instance Ord Rope
instance Eq Rope
instance Monoid Rope

module Data.Rope.Branded
data Branded brand t a
Branded :: !t -> a -> Branded brand t a
context :: Branded brand t a -> !t
extractBranded :: Branded brand t a -> a
data Unsafe
type UBR a = (Unsafe Branded Rope) a
null :: Branded s Rope a -> Bool
head :: Unpackable t => Branded s Rope a -> t
last :: Unpackable t => Branded s Rope a -> t
unpack :: Unpackable t => Branded s Rope a -> [t]
runBranded :: Branded s t a -> (a, t)
execBranded :: Branded s t a -> t
instance [incoherent] Monoid t => MonadWriter t (Branded Unsafe t)
instance [incoherent] (Monoid t, Monoid m) => Monoid (Branded Unsafe t m)
instance [incoherent] Monoid t => Monad (Branded Unsafe t)
instance [incoherent] Monoid t => Applicative (Branded Unsafe t)
instance [incoherent] Traversable (Branded s t)
instance [incoherent] Foldable (Branded s t)
instance [incoherent] Comonad (Branded s t)
instance [incoherent] Functor (Branded s t)
instance [incoherent] Measured v t => Measured v (Branded s t a)

module Data.Rope
data Rope
length :: Rope -> Int
null :: Rope -> Bool
class Breakable a where span f = break (not . f) takeWhile f = fst . span f dropWhile f = snd . span f
break :: Breakable a => (a -> Bool) -> Rope -> (Rope, Rope)
span :: Breakable a => (a -> Bool) -> Rope -> (Rope, Rope)
takeWhile :: Breakable a => (a -> Bool) -> Rope -> Rope
dropWhile :: Breakable a => (a -> Bool) -> Rope -> Rope
splitAt :: Int -> Rope -> (Rope, Rope)
take :: Int -> Rope -> Rope
drop :: Int -> Rope -> Rope
class Packable c where pack = snoc mempty snoc m = mappend m . pack cons = mappend . pack
pack :: Packable c => c -> Rope
snoc :: Packable c => Rope -> c -> Rope
cons :: Packable c => c -> Rope -> Rope
empty :: Rope
fromByteString :: ByteString -> Rope
fromChunks :: [ByteString] -> Rope
fromLazyByteString :: ByteString -> Rope
fromWords :: [Word8] -> Rope
fromChar :: Char -> Rope
fromWord8 :: Word8 -> Rope
fromString :: String -> Rope
class Unpackable a where head = head . unpack
unpack :: Unpackable a => Rope -> [a]
head :: Unpackable a => Rope -> a
last :: Unpackable a => Rope -> a
uncons :: Unpackable a => Rope -> Maybe (a, Rope)
unsnoc :: Unpackable a => Rope -> Maybe (Rope, a)
toChunks :: Rope -> [ByteString]
toLazyByteString :: Rope -> ByteString
toString :: Rope -> String

module Data.Rope.Annotation
class MonoidalAnn f
emptyAnn :: MonoidalAnn f => f a
appendAnn :: MonoidalAnn f => Rope -> f a -> Rope -> f b -> f c
class MonoidalAnn f => PackableAnn f
packAnn :: PackableAnn f => Rope -> f a
snocAnn :: PackableAnn f => Int -> Rope -> f a -> f b
consAnn :: PackableAnn f => Int -> Rope -> f a -> f b
class BreakableAnn f where takeAnn n r = fst . splitAtAnn n r dropAnn n r = snd . splitAtAnn n r
splitAtAnn :: BreakableAnn f => Int -> Rope -> f a -> (f b, f c)
takeAnn :: BreakableAnn f => Int -> Rope -> f a -> f b
dropAnn :: BreakableAnn f => Int -> Rope -> f a -> f b

module Data.Rope.Annotation.Product

-- | A <tt>Rope</tt> <tt>Annotation</tt> product.
data (:*:) f g a
(:*:) :: f a -> g a -> :*: f g a
fstF :: (f :*: g) a -> f a
sndF :: (f :*: g) a -> g a
instance (BreakableAnn f, BreakableAnn g) => BreakableAnn (f :*: g)
instance (PackableAnn f, PackableAnn g) => PackableAnn (f :*: g)
instance (MonoidalAnn f, MonoidalAnn g) => MonoidalAnn (f :*: g)
instance (Traversable f, Traversable g) => Traversable (f :*: g)
instance (Foldable f, Foldable g) => Foldable (f :*: g)
instance (Applicative f, Applicative g) => Applicative (f :*: g)
instance (Functor f, Functor g) => Functor (f :*: g)

module Data.Rope.Annotation.Unit
data Unit a
instance BreakableAnn Unit
instance PackableAnn Unit
instance MonoidalAnn Unit

module Data.Rope.Annotated
data Branded brand t a
type Ann f s = (s Branded Rope) (f s)
class MonoidalAnn f
class MonoidalAnn f => PackableAnn f
class BreakableAnn f where takeAnn n r = fst . splitAtAnn n r dropAnn n r = snd . splitAtAnn n r
runAnn :: Ann f a -> (forall b. Ann f b -> r) -> r
null :: Branded s Rope a -> Bool
head :: Unpackable t => Branded s Rope a -> t
last :: Unpackable t => Branded s Rope a -> t
unpack :: Unpackable t => Branded s Rope a -> [t]
empty :: MonoidalAnn f => Ann f Nil
append :: MonoidalAnn f => Ann f a -> Ann f b -> Ann f (a :<> b)
pack :: (PackableAnn f, Packable t) => t -> (forall a. Ann f (Return a) -> r) -> r
snoc :: (PackableAnn f, Packable t) => Ann f a -> t -> (forall c. Ann f (Snoc a c t) -> r) -> r
cons :: (PackableAnn f, Packable t) => t -> Ann f a -> (forall c. Ann f (Cons c t a) -> r) -> r
splitAt :: BreakableAnn f => Int -> Ann f a -> (forall n. Ann f (Take n a) -> Ann f (Drop n a) -> r) -> r
drop :: BreakableAnn f => Int -> Ann f a -> (forall n. Ann f (Drop n a) -> r) -> r
take :: BreakableAnn f => Int -> Ann f a -> (forall n. Ann f (Take n a) -> r) -> r
break :: (BreakableAnn f, Breakable t) => (t -> Bool) -> Ann f a -> (forall n. Ann f (Take n a) -> Ann f (Drop n a) -> r) -> r
span :: (BreakableAnn f, Breakable t) => (t -> Bool) -> Ann f a -> (forall n. Ann f (Take n a) -> Ann f (Drop n a) -> r) -> r
takeWhile :: (BreakableAnn f, Breakable t) => (t -> Bool) -> Ann f a -> (forall n. Ann f (Take n a) -> r) -> r
dropWhile :: (BreakableAnn f, Breakable t) => (t -> Bool) -> Ann f a -> (forall n. Ann f (Drop n a) -> r) -> r
uncons :: (BreakableAnn f, Unpackable t) => Ann f a -> Maybe (t, Ann f (Tail t a))
unsnoc :: (BreakableAnn f, Unpackable t) => Ann f a -> Maybe (Ann f (Init a t), t)
type Snoc a s t = a :<> Return (Token s t)
type Cons s t a = Token s t :> a
type Tail t a = Return (Tailed t a)
type Init a t = Return (Inited a t)
type Return a = a :> Nil
data Tailed t a
data Inited a t
data Dropped n a
data Taken n a
data Nil
data (:>) a b

-- | A <tt>Rope</tt> <tt>Annotation</tt> product.
data (:*:) f g a
(:*:) :: f a -> g a -> :*: f g a
fstF :: (f :*: g) a -> f a
sndF :: (f :*: g) a -> g a
data Unit a

module Data.Rope.Unsafe
class MonoidalAnn f
class MonoidalAnn f => PackableAnn f
class BreakableAnn f where takeAnn n r = fst . splitAtAnn n r dropAnn n r = snd . splitAtAnn n r
data Branded brand t a
type Ann f s = (s Branded Rope) (f s)
data Unsafe
null :: Branded s Rope a -> Bool
head :: Unpackable t => Branded s Rope a -> t
last :: Unpackable t => Branded s Rope a -> t
unpack :: Unpackable t => Branded s Rope a -> [t]
empty :: MonoidalAnn f => Ann f Unsafe
append :: MonoidalAnn f => Ann f a -> Ann f b -> Ann f Unsafe
class Packable c where pack = snoc mempty snoc m = mappend m . pack cons = mappend . pack
pack :: (PackableAnn f, Packable t) => t -> Ann f Unsafe
snoc :: (PackableAnn f, Packable t) => Ann f a -> t -> Ann f Unsafe
cons :: (PackableAnn f, Packable t) => t -> Ann f a -> Ann f Unsafe
splitAt :: BreakableAnn f => Int -> Ann f a -> (Ann f Unsafe, Ann f Unsafe)
drop :: BreakableAnn f => Int -> Ann f a -> Ann f Unsafe
take :: BreakableAnn f => Int -> Ann f a -> Ann f Unsafe
break :: (BreakableAnn f, Breakable t) => (t -> Bool) -> Ann f a -> (Ann f Unsafe, Ann f Unsafe)
span :: (BreakableAnn f, Breakable t) => (t -> Bool) -> Ann f a -> (Ann f Unsafe, Ann f Unsafe)
takeWhile :: (BreakableAnn f, Breakable t) => (t -> Bool) -> Ann f a -> Ann f Unsafe
dropWhile :: (BreakableAnn f, Breakable t) => (t -> Bool) -> Ann f a -> Ann f Unsafe
uncons :: (BreakableAnn f, Unpackable t) => Ann f a -> Maybe (t, Ann f Unsafe)
unsnoc :: (BreakableAnn f, Unpackable t) => Ann f a -> Maybe (Ann f Unsafe, t)
