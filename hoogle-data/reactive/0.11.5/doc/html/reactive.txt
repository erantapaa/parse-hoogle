-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Push-pull functional reactive programming
--   
--   <i>Reactive</i> is a simple foundation for programming reactive
--   systems functionally. Like Fran/FRP, it has a notions of (reactive)
--   behaviors and events. Unlike most previous FRP implementations,
--   Reactive has a hybrid demand/data-driven implementation, as described
--   in the paper "Push-pull functional reactive programming",
--   <a>http://conal.net/papers/push-pull-frp/</a>.
--   
--   This version of Reactive has some serious bugs that show up
--   particularly with some uses of the Event monad. Some problems have
--   been due to bugs in the GHC run-time support for concurrency. I do not
--   know whether the remaining problems in Reactive are still more subtle
--   RTS issues, or some subtle laziness bugs in Reactive. Help probing the
--   remaining difficulties is most welcome.
--   
--   Import <a>FRP.Reactive</a> for FRP client apps. To make a Reactive
--   adapter for an imperative library, import
--   <a>FRP.Reactive.LegacyAdapters</a>.
--   
--   Please see the project wiki page:
--   <a>http://haskell.org/haskellwiki/reactive</a>
--   
--   Â© 2007-2009 by Conal Elliott; GNU AGPLv3 license (see COPYING). I am
--   not thrilled with GPL, and I doubt I'll stay with it for long. If you
--   would like different terms, please talk to me.
--   
--   With contributions from: Robin Green, Thomas Davie, Luke Palmer, David
--   Sankel, Jules Bean, Creighton Hogg, Chuan-kai Lin, and Richard Smith.
--   Please let me know if I've forgotten to list you.
@package reactive
@version 0.11.5


-- | Write-once variables.
module FRP.Reactive.Internal.IVar
data IVar a
newIVar :: IO (IVar a)

-- | Returns the value in the IVar. The *value* will block until the
--   variable becomes filled.
readIVar :: IVar a -> a

-- | Returns Nothing if the IVar has no value yet, otherwise returns the
--   value.
tryReadIVar :: IVar a -> IO (Maybe a)

-- | Puts the value of the IVar. If it already has a value, block forever.
writeIVar :: IVar a -> a -> IO ()


-- | Min monoid
module Data.Min

-- | Ordered monoid under <a>min</a>.
newtype Min a
Min :: a -> Min a
getMin :: Min a -> a
instance (Eq a) => Eq (Min a)
instance (Ord a) => Ord (Min a)
instance (Read a) => Read (Min a)
instance (Show a) => Show (Min a)
instance (Bounded a) => Bounded (Min a)
instance (EqProp a) => EqProp (Min a)
instance (Arbitrary a) => Arbitrary (Min a)
instance (Ord a, Bounded a) => Monoid (Min a)


-- | Unbounded channels.
module FRP.Reactive.Internal.Chan

-- | <a>Chan</a> is an abstract type representing an unbounded FIFO
--   channel.
data Chan a

-- | Build and returns a new instance of <a>Chan</a>.
newChan :: IO (Chan a)

-- | Write a value to a <a>Chan</a>.
writeChan :: Chan a -> a -> IO ()

-- | Read the next value from the <a>Chan</a>.
readChan :: Chan a -> IO a

-- | Duplicate a <a>Chan</a>: the duplicate channel begins empty, but data
--   written to either channel from then on will be available from both.
--   Hence this creates a kind of broadcast channel, where data written by
--   anyone is seen by everyone else.
dupChan :: Chan a -> IO (Chan a)

-- | Put a data item back onto a channel, where it will be the next item
--   read.
unGetChan :: Chan a -> a -> IO ()

-- | Returns <a>True</a> if the supplied <a>Chan</a> is empty.
isEmptyChan :: Chan a -> IO Bool

-- | Return a lazy list representing the contents of the supplied
--   <a>Chan</a>, much like <tt>System.IO.hGetContents</tt>.
getChanContents :: Chan a -> IO [a]

-- | Write an entire list of items to a <a>Chan</a>.
writeList2Chan :: Chan a -> [a] -> IO ()

-- | A weak channel writer. Sustained by the read head. Thus channel
--   consumers keep channel producers alive.
weakChanWriter :: Chan a -> IO (IO (Maybe (a -> IO ())))
instance Typeable1 Chan


-- | Serialize actions.
module FRP.Reactive.Internal.Serial

-- | Serializer. Turns actions into equivalent but serialized actions
type Serial = forall a. IO a -> IO a

-- | Make a locking serializer
makeSerial :: IO Serial

-- | Make a locking serializer with a given lock
locking :: MVar () -> Serial


-- | Writer monad as a pair. Until it's in Control.Monad.Instances.
--   
--   Use <tt>import Data.PairMonad ()</tt>
module Data.PairMonad
instance (Monoid o) => Monad ((,) o)


-- | Misc Reactive internal defs
module FRP.Reactive.Internal.Misc

-- | Convenient alias for dropping parentheses.
type Action = IO ()

-- | Value consumer
type Sink a = a -> Action


-- | Constant-optimized representation of functions.
module FRP.Reactive.Internal.Fun

-- | Constant-optimized functions
data Fun t a

-- | constant function
K :: a -> Fun t a

-- | non-constant function
Fun :: (t -> a) -> Fun t a


-- | Functions, with constant functions optimized, with instances for many
--   standard classes.
module FRP.Reactive.Fun

-- | Constant-optimized functions
data Fun t a
fun :: (t -> a) -> Fun t a

-- | <a>Fun</a> as a function
apply :: Fun t a -> (t -> a)
batch :: TestBatch
instance (Monoid t) => Comonad (Fun t)
instance (Monoid t) => Copointed (Fun t)
instance Pointed (Fun t)
instance Arrow Fun
instance Category Fun
instance Monad (Fun t)
instance Applicative (Fun t)
instance Zip (Fun t)
instance Functor (Fun t)
instance (Monoid a) => Monoid (Fun t a)
instance Model1 (Fun a) ((->) a)
instance Model (Fun a b) (a -> b)
instance (Show a, Arbitrary a, EqProp a, EqProp b) => EqProp (Fun a b)
instance (Show b) => Show (Fun a b)
instance (Arbitrary a, CoArbitrary b) => CoArbitrary (Fun a b)
instance (CoArbitrary a, Arbitrary b) => Arbitrary (Fun a b)


-- | Improving values -- efficient version
module FRP.Reactive.Improving

-- | An improving value.
data Improving a
Imp :: a -> (a -> Ordering) -> Improving a
exact :: Improving a -> a
compareI :: Improving a -> a -> Ordering

-- | A known improving value (which doesn't really improve)
exactly :: (Ord a) => a -> Improving a

-- | A value known to be <tt>&lt; x</tt>.
before :: (Ord a) => a -> Improving a

-- | A value known to be <tt>&gt; x</tt>.
after :: (Ord a) => a -> Improving a

-- | Efficient combination of <a>min</a> and '(&lt;=)'
minI :: (Ord a) => Improving a -> Improving a -> (Improving a, Bool)

-- | Efficient combination of <a>max</a> and '(&gt;=)'
maxI :: (Ord a) => Improving a -> Improving a -> (Improving a, Bool)
batch :: TestBatch
instance (EqProp a) => EqProp (Improving a)
instance Model (Improving a) a
instance (CoArbitrary a) => CoArbitrary (Improving a)
instance (Ord a, Arbitrary a) => Arbitrary (Improving a)
instance (Ord a, Bounded a) => Bounded (Improving a)
instance (Ord a) => Ord (Improving a)
instance (Eq a) => Eq (Improving a)
instance (Show a) => Show (Improving a)


-- | Add bounds to an ordered type
module Data.AddBounds

-- | Wrap a type into one having new least and greatest elements,
--   preserving the existing ordering.
data AddBounds a
MinBound :: AddBounds a
NoBound :: a -> AddBounds a
MaxBound :: AddBounds a
instance (Eq a) => Eq (AddBounds a)
instance (Read a) => Read (AddBounds a)
instance (Show a) => Show (AddBounds a)
instance (AffineSpace t) => AffineSpace (AddBounds t)
instance (EqProp a, Eq a) => EqProp (AddBounds a)
instance (CoArbitrary a) => CoArbitrary (AddBounds a)
instance (Arbitrary a) => Arbitrary (AddBounds a)
instance (Ord a) => Ord (AddBounds a)
instance Bounded (AddBounds a)


-- | Max monoid
module Data.Max

-- | Ordered monoid under <a>max</a>.
newtype Max a
Max :: a -> Max a
getMax :: Max a -> a
instance (Eq a) => Eq (Max a)
instance (Ord a) => Ord (Max a)
instance (Bounded a) => Bounded (Max a)
instance (Read a) => Read (Max a)
instance (Show a) => Show (Max a)
instance (EqProp a) => EqProp (Max a)
instance (Arbitrary a) => Arbitrary (Max a)
instance (CoArbitrary a) => CoArbitrary (Max a)
instance (Ord a, Bounded a) => Monoid (Max a)


-- | Representation of future values
module FRP.Reactive.Internal.Future

-- | Time used in futures. The parameter <tt>t</tt> can be any <tt>Ord</tt>
--   and <tt>Bounded</tt> type. Pure values have time <a>minBound</a>,
--   while never-occurring futures have time 'maxBound.' type Time t = Max
--   (AddBounds t)
type Time = Max

-- | A future value of type <tt>a</tt> with time type <tt>t</tt>. Simply a
--   time/value pair. Particularly useful with time types that have
--   non-flat structure.
newtype FutureG t a
Future :: (Time t, a) -> FutureG t a
unFuture :: FutureG t a -> (Time t, a)
isNeverF :: (Bounded t, Eq t) => FutureG t t1 -> Bool

-- | Apply a unary function within the <a>FutureG</a> representation.
inFuture :: ((Time t, a) -> (Time t', b)) -> FutureG t a -> FutureG t' b

-- | Apply a binary function within the <a>FutureG</a> representation.
inFuture2 :: ((Time t, a) -> (Time t', b) -> (Time t', c)) -> FutureG t a -> FutureG t' b -> FutureG t' c

-- | Run a future in the current thread. Use the given time sink to sync
--   time, i.e., to wait for an output time before performing the action.
runF :: (Ord t) => Sink t -> FutureG t (IO a) -> IO a
instance Functor (FutureG t)
instance (Bounded t, Ord t) => Applicative (FutureG t)
instance (Bounded t, Ord t) => Monad (FutureG t)
instance Copointed (FutureG t)
instance Comonad (FutureG t)
instance (Arbitrary t, Arbitrary a) => Arbitrary (FutureG t a)
instance (CoArbitrary t, CoArbitrary a) => CoArbitrary (FutureG t a)
instance (Show t, Show a, Eq t, Bounded t) => Show (FutureG t a)
instance (Eq t, Eq a, Bounded t) => Eq (FutureG t a)


-- | Representation for <tt>Reactive</tt> and <a>Event</a> types. Combined
--   here, because they're mutually recursive.
--   
--   The representation used in this module is based on a close connection
--   between these two types. A reactive value is defined by an initial
--   value and an event that yields future values; while an event is given
--   as a future reactive value.
module FRP.Reactive.Internal.Reactive

-- | Events. Semantically: time-ordered list of future values. Instances:
--   
--   <ul>
--   <li><tt>Monoid</tt>: <tt>mempty</tt> is the event that never occurs,
--   and <tt>e <tt>mappend</tt> e'</tt> is the event that combines
--   occurrences from <tt>e</tt> and <tt>e'</tt>.</li>
--   <li><a>Functor</a>: <tt>fmap f e</tt> is the event that occurs
--   whenever <tt>e</tt> occurs, and whose occurrence values come from
--   applying <tt>f</tt> to the values from <tt>e</tt>.</li>
--   <li><tt>Applicative</tt>: <tt>pure a</tt> is an event with a single
--   occurrence at time -Infinity. <tt>ef &lt;*&gt; ex</tt> is an event
--   whose occurrences are made from the <i>product</i> of the occurrences
--   of <tt>ef</tt> and <tt>ex</tt>. For every occurrence <tt>f</tt> at
--   time <tt>tf</tt> of <tt>ef</tt> and occurrence <tt>x</tt> at time
--   <tt>tx</tt> of <tt>ex</tt>, <tt>ef &lt;*&gt; ex</tt> has an occurrence
--   <tt>f x</tt> at time <tt>tf <a>max</a> tx</tt>. N.B.: I don't expect
--   this instance to be very useful. If <tt>ef</tt> has <tt>nf</tt>
--   instances and <tt>ex</tt> has <tt>nx</tt> instances, then <tt>ef
--   &lt;*&gt; ex</tt> has <tt>nf*nx</tt> instances. However, there are
--   only <tt>nf+nx</tt> possibilities for <tt>tf <a>max</a> tx</tt>, so
--   many of the occurrences are simultaneous. If you think you want to use
--   this instance, consider using <tt>Reactive</tt> instead.</li>
--   <li><a>Monad</a>: <tt>return a</tt> is the same as <tt>pure a</tt> (as
--   usual). In <tt>e &gt;&gt;= f</tt>, each occurrence of <tt>e</tt>
--   leads, through <tt>f</tt>, to a new event. Similarly for <tt>join
--   ee</tt>, which is somehow simpler for me to think about. The
--   occurrences of <tt>e &gt;&gt;= f</tt> (or <tt>join ee</tt>) correspond
--   to the union of the occurrences (temporal interleaving) of all such
--   events. For example, suppose we're playing Asteroids and tracking
--   collisions. Each collision can break an asteroid into more of them,
--   each of which has to be tracked for more collisions. Another example:
--   A chat room has an <i>enter</i> event, whose occurrences contain new
--   events like <i>speak</i>. An especially useful monad-based function is
--   <tt>joinMaybes</tt>, which filters a Maybe-valued event.</li>
--   </ul>
newtype EventG t a
Event :: FutureG t (ReactiveG t a) -> EventG t a
eFuture :: EventG t a -> FutureG t (ReactiveG t a)
isNeverE :: (Bounded t, Eq t) => EventG t a -> Bool

-- | Apply a unary function inside an <a>EventG</a> representation.
inEvent :: (FutureG s (ReactiveG s a) -> FutureG t (ReactiveG t b)) -> (EventG s a -> EventG t b)

-- | Apply a binary function inside an <a>EventG</a> representation.
inEvent2 :: (FutureG t (ReactiveG t a) -> FutureG t (ReactiveG t b) -> FutureG t (ReactiveG t c)) -> (EventG t a -> EventG t b -> EventG t c)

-- | Make the event into a list of futures
eFutures :: (Bounded t, Eq t) => EventG t a -> [FutureG t a]

-- | Reactive value: a discretely changing value. Reactive values can be
--   understood in terms of (a) a simple denotational semantics of reactive
--   values as functions of time, and (b) the corresponding instances for
--   functions. The semantics is given by the function <tt>at :: ReactiveG
--   t a -&gt; (t -&gt; a)</tt>. A reactive value may also be thought of
--   (and in this module is implemented as) a current value and an event
--   (stream of future values).
--   
--   The semantics of <a>ReactiveG</a> instances are given by corresponding
--   instances for the semantic model (functions):
--   
--   <ul>
--   <li><a>Functor</a>: <tt>at (fmap f r) == fmap f (at r)</tt>, i.e.,
--   <tt>fmap f r <tt>at</tt> t == f (r <tt>at</tt> t)</tt>.</li>
--   <li><tt>Applicative</tt>: <tt>at (pure a) == pure a</tt>, and <tt>at
--   (s &lt;*&gt; r) == at s &lt;*&gt; at t</tt>. That is, <tt>pure a
--   <tt>at</tt> t == a</tt>, and <tt>(s &lt;*&gt; r) <tt>at</tt> t == (s
--   <tt>at</tt> t) (r <tt>at</tt> t)</tt>.</li>
--   <li><a>Monad</a>: <tt>at (return a) == return a</tt>, and <tt>at (join
--   rr) == join (at . at rr)</tt>. That is, <tt>return a <tt>at</tt> t ==
--   a</tt>, and <tt>join rr <tt>at</tt> t == (rr <tt>at</tt> t)
--   <tt>at</tt> t</tt>. As always, <tt>(r &gt;&gt;= f) == join (fmap f
--   r)</tt>. <tt>at (r &gt;&gt;= f) == at r &gt;&gt;= at . f</tt>.</li>
--   <li><tt>Monoid</tt>: a typical lifted monoid. If <tt>o</tt> is a
--   monoid, then <tt>Reactive o</tt> is a monoid, with <tt>mempty == pure
--   mempty</tt>, and <tt>mappend == liftA2 mappend</tt>. That is,
--   <tt>mempty <tt>at</tt> t == mempty</tt>, and <tt>(r <tt>mappend</tt>
--   s) <tt>at</tt> t == (r <tt>at</tt> t) <tt>mappend</tt> (s <tt>at</tt>
--   t).</tt></li>
--   </ul>
data ReactiveG t a
Stepper :: a -> EventG t a -> ReactiveG t a

-- | Apply a unary function inside the <tt>rEvent</tt> part of a
--   <tt>Reactive</tt> representation.
inREvent :: (EventG s a -> EventG t a) -> (ReactiveG s a -> ReactiveG t a)

-- | Apply a unary function inside the future reactive inside a
--   <tt>Reactive</tt> representation.
inFutR :: (FutureG s (ReactiveG s b) -> FutureG t (ReactiveG t b)) -> (ReactiveG s b -> ReactiveG t b)

-- | Run an event in the current thread. Use the given time sink to sync
--   time, i.e., to wait for an output time before performing the action.
runE :: (Ord t, Bounded t) => Sink t -> Sink (EventG t Action)

-- | Run a reactive value in the current thread, using the given time sink
--   to sync time.
runR :: (Bounded t, Ord t) => Sink t -> Sink (ReactiveG t Action)

-- | Run an event in a new thread, using the given time sink to sync time.
forkE :: (Ord t, Bounded t) => Sink t -> EventG t Action -> IO ThreadId

-- | Run a reactive value in a new thread, using the given time sink to
--   sync time. The initial action happens in the current thread.
forkR :: (Ord t, Bounded t) => Sink t -> ReactiveG t Action -> IO ThreadId
instance (Eq t, Bounded t, Show t, Show a) => Show (ReactiveG t a)
instance (Eq t, Bounded t, Show t, Show a) => Show (EventG t a)


-- | A simple formulation of functional <i>futures</i>, roughly as
--   described at <a>http://en.wikipedia.org/wiki/Futures_and_promises</a>.
--   
--   A <i>future</i> is a value with an associated time of <i>arrival</i>.
--   Typically, neither the time nor the value can be known until the
--   arrival time.
--   
--   Primitive futures can be things like /the value of the next key you
--   press<i>, or </i>the value of LambdaPix stock at noon next Monday/.
--   
--   Composition is via standard type classes: <a>Functor</a>,
--   <tt>Applicative</tt>, <a>Monad</a>, and <a>Monoid</a>. Some comments
--   on the <a>Future</a> instances of these classes:
--   
--   <ul>
--   <li>Monoid: <a>mempty</a> is a future that never arrives (infinite
--   time and undefined value), and <tt>a <a>mappend</a> b</tt> is the
--   earlier of <tt>a</tt> and <tt>b</tt>, preferring <tt>a</tt> when
--   simultaneous.</li>
--   <li><a>Functor</a>: apply a function to a future argument. The
--   (future) result arrives simultaneously with the argument.</li>
--   <li><tt>Applicative</tt>: <tt>pure</tt> gives value arriving negative
--   infinity. '(&lt;*&gt;)' applies a future function to a future
--   argument, yielding a future result that arrives once <i>both</i>
--   function and argument have arrived (coinciding with the later of the
--   two times).</li>
--   <li><a>Monad</a>: <a>return</a> is the same as <tt>pure</tt> (as
--   usual). <tt>(&gt;&gt;=)</tt> cascades futures. <tt>join</tt> resolves
--   a future future value into a future value.</li>
--   </ul>
--   
--   Futures are parametric over <i>time</i> as well as <i>value</i> types.
--   The time parameter can be any ordered type and is particularly useful
--   with time types that have rich partial information structure, such as
--   /improving values/.
module FRP.Reactive.Future

-- | Time used in futures. The parameter <tt>t</tt> can be any <tt>Ord</tt>
--   and <tt>Bounded</tt> type. Pure values have time <a>minBound</a>,
--   while never-occurring futures have time 'maxBound.' type Time t = Max
--   (AddBounds t)
type Time = Max

-- | Make a finite time
ftime :: t -> Time t

-- | A future value of type <tt>a</tt> with time type <tt>t</tt>. Simply a
--   time/value pair. Particularly useful with time types that have
--   non-flat structure.
newtype FutureG t a
Future :: (Time t, a) -> FutureG t a
unFuture :: FutureG t a -> (Time t, a)
isNeverF :: (Bounded t, Eq t) => FutureG t t1 -> Bool

-- | Apply a unary function within the <a>FutureG</a> representation.
inFuture :: ((Time t, a) -> (Time t', b)) -> FutureG t a -> FutureG t' b

-- | Apply a binary function within the <a>FutureG</a> representation.
inFuture2 :: ((Time t, a) -> (Time t', b) -> (Time t', c)) -> FutureG t a -> FutureG t' b -> FutureG t' c

-- | A future's time
futTime :: FutureG t a -> Time t

-- | A future's value
futVal :: FutureG t a -> a

-- | A future value with given time &amp; value
future :: t -> a -> FutureG t a

-- | Access time of future
withTimeF :: FutureG t a -> FutureG t (Time t, a)
batch :: TestBatch
instance (EqProp t) => EqProp (TimeInfo t)
instance (Ord a) => Ord (TimeInfo a)
instance (Eq a) => Eq (TimeInfo a)
instance (Bounded t) => Bounded (TimeInfo t)
instance (Ord t, Bounded t) => Monoid (FutureG t a)
instance (Bounded t, Eq t, EqProp t, EqProp a) => EqProp (FutureG t a)


-- | Functional <i>events</i> and <i>reactive values</i>. Semantically, an
--   <a>Event</a> is stream of future values in time order. A
--   <tt>Reactive</tt> value is a discretly time-varying value.
--   
--   Many of the operations on events and reactive values are packaged as
--   instances of the standard type classes <a>Monoid</a>, <a>Functor</a>,
--   <a>Applicative</a>, and <a>Monad</a>.
--   
--   This module focuses on representation and primitives defined in terms
--   of the representation. See also <a>FRP.Reactive.Reactive</a>, which
--   re-exports this module, plus extras that do not exploit the
--   representation. My intention for this separation is to ease
--   experimentation with alternative representations.
--   
--   Although the basic <tt>Reactive</tt> type describes
--   <i>discretely</i>-changing values, <i>continuously</i>-changing values
--   can be modeled simply as reactive functions. See
--   <a>FRP.Reactive.Behavior</a> for a convenient type composition of
--   <tt>Reactive</tt> and a constant-optimized representation of functions
--   of time. The exact packaging of discrete vs continuous will probably
--   change with more experience.
module FRP.Reactive.PrimReactive

-- | Events. Semantically: time-ordered list of future values. Instances:
--   
--   <ul>
--   <li><tt>Monoid</tt>: <tt>mempty</tt> is the event that never occurs,
--   and <tt>e <tt>mappend</tt> e'</tt> is the event that combines
--   occurrences from <tt>e</tt> and <tt>e'</tt>.</li>
--   <li><a>Functor</a>: <tt>fmap f e</tt> is the event that occurs
--   whenever <tt>e</tt> occurs, and whose occurrence values come from
--   applying <tt>f</tt> to the values from <tt>e</tt>.</li>
--   <li><tt>Applicative</tt>: <tt>pure a</tt> is an event with a single
--   occurrence at time -Infinity. <tt>ef &lt;*&gt; ex</tt> is an event
--   whose occurrences are made from the <i>product</i> of the occurrences
--   of <tt>ef</tt> and <tt>ex</tt>. For every occurrence <tt>f</tt> at
--   time <tt>tf</tt> of <tt>ef</tt> and occurrence <tt>x</tt> at time
--   <tt>tx</tt> of <tt>ex</tt>, <tt>ef &lt;*&gt; ex</tt> has an occurrence
--   <tt>f x</tt> at time <tt>tf <a>max</a> tx</tt>. N.B.: I don't expect
--   this instance to be very useful. If <tt>ef</tt> has <tt>nf</tt>
--   instances and <tt>ex</tt> has <tt>nx</tt> instances, then <tt>ef
--   &lt;*&gt; ex</tt> has <tt>nf*nx</tt> instances. However, there are
--   only <tt>nf+nx</tt> possibilities for <tt>tf <a>max</a> tx</tt>, so
--   many of the occurrences are simultaneous. If you think you want to use
--   this instance, consider using <tt>Reactive</tt> instead.</li>
--   <li><a>Monad</a>: <tt>return a</tt> is the same as <tt>pure a</tt> (as
--   usual). In <tt>e &gt;&gt;= f</tt>, each occurrence of <tt>e</tt>
--   leads, through <tt>f</tt>, to a new event. Similarly for <tt>join
--   ee</tt>, which is somehow simpler for me to think about. The
--   occurrences of <tt>e &gt;&gt;= f</tt> (or <tt>join ee</tt>) correspond
--   to the union of the occurrences (temporal interleaving) of all such
--   events. For example, suppose we're playing Asteroids and tracking
--   collisions. Each collision can break an asteroid into more of them,
--   each of which has to be tracked for more collisions. Another example:
--   A chat room has an <i>enter</i> event, whose occurrences contain new
--   events like <i>speak</i>. An especially useful monad-based function is
--   <tt>joinMaybes</tt>, which filters a Maybe-valued event.</li>
--   </ul>
data EventG t a

-- | Reactive value: a discretely changing value. Reactive values can be
--   understood in terms of (a) a simple denotational semantics of reactive
--   values as functions of time, and (b) the corresponding instances for
--   functions. The semantics is given by the function <tt>at :: ReactiveG
--   t a -&gt; (t -&gt; a)</tt>. A reactive value may also be thought of
--   (and in this module is implemented as) a current value and an event
--   (stream of future values).
--   
--   The semantics of <a>ReactiveG</a> instances are given by corresponding
--   instances for the semantic model (functions):
--   
--   <ul>
--   <li><a>Functor</a>: <tt>at (fmap f r) == fmap f (at r)</tt>, i.e.,
--   <tt>fmap f r <tt>at</tt> t == f (r <tt>at</tt> t)</tt>.</li>
--   <li><tt>Applicative</tt>: <tt>at (pure a) == pure a</tt>, and <tt>at
--   (s &lt;*&gt; r) == at s &lt;*&gt; at t</tt>. That is, <tt>pure a
--   <tt>at</tt> t == a</tt>, and <tt>(s &lt;*&gt; r) <tt>at</tt> t == (s
--   <tt>at</tt> t) (r <tt>at</tt> t)</tt>.</li>
--   <li><a>Monad</a>: <tt>at (return a) == return a</tt>, and <tt>at (join
--   rr) == join (at . at rr)</tt>. That is, <tt>return a <tt>at</tt> t ==
--   a</tt>, and <tt>join rr <tt>at</tt> t == (rr <tt>at</tt> t)
--   <tt>at</tt> t</tt>. As always, <tt>(r &gt;&gt;= f) == join (fmap f
--   r)</tt>. <tt>at (r &gt;&gt;= f) == at r &gt;&gt;= at . f</tt>.</li>
--   <li><tt>Monoid</tt>: a typical lifted monoid. If <tt>o</tt> is a
--   monoid, then <tt>Reactive o</tt> is a monoid, with <tt>mempty == pure
--   mempty</tt>, and <tt>mappend == liftA2 mappend</tt>. That is,
--   <tt>mempty <tt>at</tt> t == mempty</tt>, and <tt>(r <tt>mappend</tt>
--   s) <tt>at</tt> t == (r <tt>at</tt> t) <tt>mappend</tt> (s <tt>at</tt>
--   t).</tt></li>
--   </ul>
data ReactiveG t a

-- | Reactive value from an initial value and a new-value event.
stepper :: a -> EventG t a -> ReactiveG t a

-- | Switch between reactive values.
switcher :: (Ord t, Bounded t) => ReactiveG t a -> EventG t (ReactiveG t a) -> ReactiveG t a

-- | Access occurrence times in an event. See also <a>withTimeGR</a>.
withTimeGE :: EventG t a -> EventG t (a, Time t)

-- | Access occurrence times in a reactive value. See also
--   <a>withTimeGE</a>.
withTimeGR :: Time t -> ReactiveG t a -> ReactiveG t (a, Time t)

-- | Convert a temporally monotonic list of futures to an event
futuresE :: (Ord t, Bounded t) => [FutureG t a] -> EventG t a

-- | Convert a temporally monotonic stream of futures to an event. Like
--   <a>futuresE</a> but it can be lazier, because there's not empty case.
futureStreamE :: (Ord t, Bounded t) => Stream (FutureG t a) -> EventG t a

-- | Convert a temporally monotonic list of futures to an event. See also
--   the specialization <tt>listE</tt>
listEG :: (Ord t, Bounded t) => [(t, a)] -> EventG t a

-- | Event at given times. See also <a>atTimeG</a>.
atTimesG :: (Ord t, Bounded t) => [t] -> EventG t ()

-- | Single-occurrence event at given time.
atTimeG :: (Ord t, Bounded t) => t -> EventG t ()

-- | Snapshot a reactive value whenever an event occurs and apply a
--   combining function to the event and reactive's values.
snapshotWith :: (Ord t, Bounded t) => (a -> b -> c) -> ReactiveG t b -> EventG t a -> EventG t c

-- | Accumulating event, starting from an initial value and a
--   update-function event. See also <a>accumR</a>.
accumE :: a -> EventG t (a -> a) -> EventG t a

-- | Reactive value from an initial value and an updater event. See also
--   <a>accumE</a>.
accumR :: a -> EventG t (a -> a) -> ReactiveG t a

-- | Just the first occurrence of an event.
once :: (Ord t, Bounded t) => EventG t a -> EventG t a

-- | Access the remainder with each event occurrence.
withRestE :: EventG t a -> EventG t (a, EventG t a)

-- | Truncate first event at first occurrence of second event.
untilE :: (Ord t, Bounded t) => EventG t a -> EventG t b -> EventG t a

-- | Experimental specialization of <a>joinMaybes</a>.
justE :: (Ord t, Bounded t) => EventG t (Maybe a) -> EventG t a

-- | Experimental specialization of <a>filterMP</a>.
filterE :: (Ord t, Bounded t) => (a -> Bool) -> EventG t a -> EventG t a

-- | Extract a future representing the first occurrence of the event
--   together with the event of all occurrences after that one.
eventOcc :: (Ord t) => EventG t a -> FutureG t (a, EventG t a)

-- | Pass through <tt>Just</tt> occurrences.
joinMaybes :: (MonadPlus m) => m (Maybe a) -> m a

-- | Pass through values satisfying <tt>p</tt>.
filterMP :: (MonadPlus m) => (a -> Bool) -> m a -> m a

-- | Apply a given function inside the results of other functions.
--   Equivalent to '(.)', but has a nicer reading when composed
result :: (b -> b') -> ((a -> b) -> (a -> b'))
isMonotoneR :: (Ord t, Bounded t) => ReactiveG t a -> Bool
batch :: TestBatch
infE :: EventG NumT NumT
monoid_E :: TestBatch
instance (Monoid t) => Comonad (ReactiveG t)
instance Copointed (ReactiveG t)
instance (Ord t, Bounded t) => Pointed (ReactiveG t)
instance (Monoid t) => Comonad (EventG t)
instance Copointed (EventG t)
instance Unzip (EventG t)
instance (Ord t, Bounded t, Cozip f) => Zip (EventG t :. f)
instance (Ord t, Bounded t) => Monoid_f (EventG t :. f)
instance (Ord t, Bounded t) => Monoid ((:.) (EventG t) f a)
instance (Ord t, Bounded t) => Monoid_f (EventG t)
instance Unzip (ReactiveG t)
instance (Ord t, Bounded t, Zip f) => Zip (ReactiveG t :. f)
instance (Monoid_f f, Ord t, Bounded t) => Monoid_f (ReactiveG t :. f)
instance (Ord t, Bounded t) => Monad (ReactiveG t)
instance (Ord t, Bounded t) => MonadPlus (EventG t)
instance (Ord t, Bounded t) => Monad (EventG t)
instance (Ord t, Bounded t) => Applicative (ReactiveG t)
instance (Ord t, Bounded t) => Zip (ReactiveG t)
instance (Ord t, Bounded t) => Alternative (EventG t)
instance (Ord t, Bounded t) => Applicative (EventG t)
instance Functor (ReactiveG t)
instance Functor (EventG t)
instance (Ord t, Bounded t, Monoid a) => Monoid (ReactiveG t a)
instance (Ord t, Bounded t) => Monoid (EventG t a)
instance (Ord t, Bounded t, Arbitrary t, Show t, EqProp a) => EqProp (ReactiveG t a)
instance (Ord t, Bounded t) => Model (ReactiveG t a) (t -> a)
instance (CoArbitrary t, CoArbitrary a) => CoArbitrary (ReactiveG t a)
instance (Arbitrary t, Arbitrary a, Num t, Ord t, Bounded t) => Arbitrary (ReactiveG t a)
instance (CoArbitrary t, CoArbitrary a) => CoArbitrary (EventG t a)
instance (Arbitrary t, Ord t, Bounded t, Num t, Arbitrary a) => Arbitrary (EventG t a)
instance (Bounded t, Eq t, Eq a, EqProp t, EqProp a) => EqProp (EventG t a)


-- | Simple reactive values. Adds some extra functionality on top of
--   <a>FRP.Reactive.PrimReactive</a>
module FRP.Reactive.Reactive
type ImpBounds t = Improving (AddBounds t)

-- | Exact &amp; finite content of an <a>ImpBounds</a>
exactNB :: ImpBounds t -> t

-- | The type of time values with additional min &amp; max elements.
type TimeT = Double

-- | Improving times, as used for time values in <a>Event</a>,
--   <a>Reactive</a>, and <tt>ReactiveB</tt>.
type ITime = ImpBounds TimeT

-- | Type of future values. Specializes <a>FutureG</a>.
type Future = FutureG ITime

-- | Trace the elements of a functor type.
traceF :: (Functor f) => (a -> String) -> f a -> f a

-- | Events, specialized to improving doubles for time
type Event = EventG ITime

-- | Access occurrence times in an event. See <a>withTimeGE</a> for more
--   general notions of time.
--   
--   <pre>
--   withTimeE :: Event a -&gt; Event (a, TimeT)
--   </pre>
withTimeE :: (Ord t) => EventG (ImpBounds t) d -> EventG (ImpBounds t) (d, t)

-- | Access occurrence times in an event. Discard the rest. See also
--   <a>withTimeE</a>.
--   
--   <pre>
--   withTimeE_ :: Event a -&gt; Event TimeT
--   </pre>
withTimeE_ :: (Ord t) => EventG (ImpBounds t) d -> EventG (ImpBounds t) t

-- | Single-occurrence event at given time. See <a>atTimes</a> and
--   <a>atTimeG</a>.
atTime :: TimeT -> Event ()

-- | Event occuring at given times. See also <a>atTime</a> and
--   <a>atTimeG</a>.
atTimes :: [TimeT] -> Event ()

-- | Convert a temporally monotonic list of timed values to an event. See
--   also the generalization <a>listEG</a>
listE :: [(TimeT, a)] -> Event a

-- | Generate a pair-valued event, given a pair of initial values and a
--   pair of events. See also <tt>pair</tt> on <a>Reactive</a>. Not quite a
--   <a>zip</a>, because of the initial pair required.
zipE :: (Ord t, Bounded t) => (c, d) -> (EventG t c, EventG t d) -> EventG t (c, d)

-- | Like <a>scanl</a> for events.
scanlE :: (Ord t, Bounded t) => (a -> b -> a) -> a -> EventG t b -> EventG t a

-- | Accumulate values from a monoid-typed event. Specialization of
--   <a>scanlE</a>, using <a>mappend</a> and <a>mempty</a>.
monoidE :: (Ord t, Bounded t, Monoid o) => EventG t o -> EventG t o

-- | Decompose an event into its first occurrence value and a remainder
--   event. See also <a>firstE</a> and <a>restE</a>.
firstRestE :: (Ord t, Bounded t) => EventG t a -> (a, EventG t a)

-- | Extract the first occurrence value of an event. See also
--   <a>firstRestE</a> and <a>restE</a>.
firstE :: (Ord t, Bounded t) => EventG t a -> a

-- | Extract the remainder an event, after its first occurrence. See also
--   <a>firstRestE</a> and <a>firstE</a>.
restE :: (Ord t, Bounded t) => EventG t a -> EventG t a

-- | Remaining part of an event. See also <a>withRestE</a>.
remainderR :: (Ord t, Bounded t) => EventG t a -> ReactiveG t (EventG t a)

-- | Tack remainders a second event onto values of a first event. Occurs
--   when the first event occurs.
snapRemainderE :: (Ord t, Bounded t) => EventG t b -> EventG t a -> EventG t (a, EventG t b)

-- | Convert an event into a single-occurrence event, whose occurrence
--   contains the remainder.
onceRestE :: (Ord t, Bounded t) => EventG t a -> EventG t (a, EventG t a)

-- | Pair each event value with the previous one. The second result is the
--   old one. Nothing will come out for the first occurrence of <tt>e</tt>,
--   but if you have an initial value <tt>a</tt>, you can do <tt>withPrevE
--   (pure a <a>mappend</a> e)</tt>.
withPrevE :: (Ord t, Bounded t) => EventG t a -> EventG t (a, a)

-- | Same as <a>withPrevE</a>, but allow a function to combine the values.
--   Provided for convenience.
withPrevEWith :: (Ord t, Bounded t) => (a -> a -> b) -> EventG t a -> EventG t b

-- | Pair each event value with the next one one. The second result is the
--   next one.
withNextE :: (Ord t, Bounded t) => EventG t a -> EventG t (a, a)

-- | Same as <a>withNextE</a>, but allow a function to combine the values.
--   Provided for convenience.
withNextEWith :: (Ord t, Bounded t) => (a -> a -> b) -> EventG t a -> EventG t b

-- | Mealy-style state machine, given initial value and transition
--   function. Carries along event data. See also <a>mealy_</a>.
mealy :: (Ord t, Bounded t) => s -> (s -> s) -> EventG t b -> EventG t (b, s)

-- | Mealy-style state machine, given initial value and transition
--   function. Forgetful version of <a>mealy</a>.
mealy_ :: (Ord t, Bounded t) => s -> (s -> s) -> EventG t b -> EventG t s

-- | Count occurrences of an event, remembering the occurrence values. See
--   also <a>countE_</a>.
countE :: (Ord t, Bounded t, Num n) => EventG t b -> EventG t (b, n)

-- | Count occurrences of an event, forgetting the occurrence values. See
--   also <a>countE</a>.
countE_ :: (Ord t, Bounded t, Num n) => EventG t b -> EventG t n

-- | Difference of successive event occurrences. See <a>withPrevE</a> for a
--   trick to supply an initial previous value.
diffE :: (Ord t, Bounded t, AffineSpace a) => EventG t a -> EventG t (Diff a)

-- | Reactive values, specialized to improving doubles for time
type Reactive = ReactiveG ITime

-- | Like <a>snapshot</a> but discarding event data (often <tt>a</tt> is
--   '()').
snapshot_ :: (Ord t, Bounded t) => ReactiveG t b -> EventG t a -> EventG t b

-- | Snapshot a reactive value whenever an event occurs.
snapshot :: (Ord t, Bounded t) => ReactiveG t b -> EventG t a -> EventG t (a, b)

-- | Filter an event according to whether a reactive boolean is true.
whenE :: (Ord t, Bounded t) => EventG t a -> ReactiveG t Bool -> EventG t a

-- | Like <a>scanl</a> for reactive values. See also <a>scanlE</a>.
scanlR :: (Ord t, Bounded t) => (a -> b -> a) -> a -> EventG t b -> ReactiveG t a

-- | Accumulate values from a monoid-valued event. Specialization of
--   <a>scanlE</a>, using <a>mappend</a> and <a>mempty</a>. See also
--   <a>monoidE</a>.
monoidR :: (Ord t, Bounded t, Monoid a) => EventG t a -> ReactiveG t a

-- | Combine two events into one.
eitherE :: (Ord t, Bounded t) => EventG t a -> EventG t b -> EventG t (Either a b)

-- | Start out blank (<a>Nothing</a>), latching onto each new <tt>a</tt>,
--   and blanking on each <tt>b</tt>. If you just want to latch and not
--   blank, then use <a>mempty</a> for <tt>lose</tt>.
maybeR :: (Ord t, Bounded t) => EventG t a -> EventG t b -> ReactiveG t (Maybe a)

-- | Flip-flopping reactive value. Turns true when <tt>ea</tt> occurs and
--   false when <tt>eb</tt> occurs.
flipFlop :: (Ord t, Bounded t) => EventG t a -> EventG t b -> ReactiveG t Bool

-- | Count occurrences of an event. See also <a>countE</a>.
countR :: (Ord t, Bounded t, Num n) => EventG t a -> ReactiveG t n

-- | Partition an event into segments.
splitE :: (Ord t, Bounded t) => EventG t b -> EventG t a -> EventG t (a, EventG t b)

-- | Switch from one event to another, as they occur. (Doesn't merge, as
--   <a>join</a> does.)
switchE :: (Ord t, Bounded t) => EventG t (EventG t a) -> EventG t a

-- | Euler integral.
integral :: (VectorSpace v, AffineSpace t, (Scalar v) ~ (Diff t)) => t -> Event t -> Reactive v -> Reactive v
sumR :: (Ord t, Bounded t) => (AdditiveGroup v) => EventG t v -> ReactiveG t v
exact :: Improving a -> a
batch :: TestBatch


-- | Representation of reactive behaviors
module FRP.Reactive.Internal.Behavior

-- | Reactive behaviors. They can be understood in terms of a simple model
--   (denotational semantics) as functions of time, namely <tt>at ::
--   BehaviorG t a -&gt; (t -&gt; a)</tt>.
--   
--   The semantics of <a>BehaviorG</a> instances are given by corresponding
--   instances for the semantic model (functions). See
--   <a>http://conal.net/blog/posts/simplifying-semantics-with-type-class-morphisms/</a>.
--   
--   <ul>
--   <li><a>Functor</a>: <tt>at (fmap f r) == fmap f (at r)</tt>, i.e.,
--   <tt>fmap f r <tt>at</tt> t == f (r <tt>at</tt> t)</tt>.</li>
--   <li><a>Applicative</a>: <tt>at (pure a) == pure a</tt>, and <tt>at (s
--   &lt;*&gt; r) == at s &lt;*&gt; at t</tt>. That is, <tt>pure a
--   <tt>at</tt> t == a</tt>, and <tt>(s &lt;*&gt; r) <tt>at</tt> t == (s
--   <tt>at</tt> t) (r <tt>at</tt> t)</tt>.</li>
--   <li><a>Monad</a>: <tt>at (return a) == return a</tt>, and <tt>at (join
--   rr) == join (at . at rr)</tt>. That is, <tt>return a <tt>at</tt> t ==
--   a</tt>, and <tt>join rr <tt>at</tt> t == (rr <tt>at</tt> t)
--   <tt>at</tt> t</tt>. As always, <tt>(r &gt;&gt;= f) == join (fmap f
--   r)</tt>. <tt>at (r &gt;&gt;= f) == at r &gt;&gt;= at . f</tt>.</li>
--   <li><a>Monoid</a>: a typical lifted monoid. If <tt>o</tt> is a monoid,
--   then <tt>Reactive o</tt> is a monoid, with <tt>mempty == pure
--   mempty</tt>, and <tt>mappend == liftA2 mappend</tt>. That is,
--   <tt>mempty <tt>at</tt> t == mempty</tt>, and <tt>(r <a>mappend</a> s)
--   <tt>at</tt> t == (r <tt>at</tt> t) <a>mappend</a> (s <tt>at</tt>
--   t).</tt></li>
--   </ul>
newtype BehaviorG tr tf a
Beh :: (ReactiveG tr :. Fun tf) a -> BehaviorG tr tf a
unBeh :: BehaviorG tr tf a -> (ReactiveG tr :. Fun tf) a

-- | Wrap a reactive time fun as a behavior.
beh :: ReactiveG tr (Fun tf a) -> BehaviorG tr tf a

-- | Unwrap a behavior.
unb :: BehaviorG tr tf a -> ReactiveG tr (Fun tf a)
instance (Bounded tr, Ord tr, Monoid a) => Monoid (BehaviorG tr tf a)
instance Functor (BehaviorG tr tf)
instance (Bounded tr, Ord tr) => Applicative (BehaviorG tr tf)
instance Unzip (BehaviorG tr tf)
instance (Ord tr, Bounded tr) => Zip (BehaviorG tr tf)
instance (Applicative (ReactiveG tr :. Fun tf), Monoid a) => Monoid ((:.) (ReactiveG tr) (Fun tf) a)


-- | Reactive behaviors (continuous time)
module FRP.Reactive.Behavior

-- | Reactive behaviors. They can be understood in terms of a simple model
--   (denotational semantics) as functions of time, namely <tt>at ::
--   BehaviorG t a -&gt; (t -&gt; a)</tt>.
--   
--   The semantics of <a>BehaviorG</a> instances are given by corresponding
--   instances for the semantic model (functions). See
--   <a>http://conal.net/blog/posts/simplifying-semantics-with-type-class-morphisms/</a>.
--   
--   <ul>
--   <li><a>Functor</a>: <tt>at (fmap f r) == fmap f (at r)</tt>, i.e.,
--   <tt>fmap f r <tt>at</tt> t == f (r <tt>at</tt> t)</tt>.</li>
--   <li><a>Applicative</a>: <tt>at (pure a) == pure a</tt>, and <tt>at (s
--   &lt;*&gt; r) == at s &lt;*&gt; at t</tt>. That is, <tt>pure a
--   <tt>at</tt> t == a</tt>, and <tt>(s &lt;*&gt; r) <tt>at</tt> t == (s
--   <tt>at</tt> t) (r <tt>at</tt> t)</tt>.</li>
--   <li><a>Monad</a>: <tt>at (return a) == return a</tt>, and <tt>at (join
--   rr) == join (at . at rr)</tt>. That is, <tt>return a <tt>at</tt> t ==
--   a</tt>, and <tt>join rr <tt>at</tt> t == (rr <tt>at</tt> t)
--   <tt>at</tt> t</tt>. As always, <tt>(r &gt;&gt;= f) == join (fmap f
--   r)</tt>. <tt>at (r &gt;&gt;= f) == at r &gt;&gt;= at . f</tt>.</li>
--   <li><a>Monoid</a>: a typical lifted monoid. If <tt>o</tt> is a monoid,
--   then <tt>Reactive o</tt> is a monoid, with <tt>mempty == pure
--   mempty</tt>, and <tt>mappend == liftA2 mappend</tt>. That is,
--   <tt>mempty <tt>at</tt> t == mempty</tt>, and <tt>(r <a>mappend</a> s)
--   <tt>at</tt> t == (r <tt>at</tt> t) <a>mappend</a> (s <tt>at</tt>
--   t).</tt></li>
--   </ul>
data BehaviorG tr tf a

-- | Time-specialized behaviors. Note: The signatures of all of the
--   behavior functions can be generalized. Is the interface generality
--   worth the complexity?
type Behavior = BehaviorI TimeT
type Behaviour = Behavior

-- | The identity generalized behavior. Has value <tt>t</tt> at time
--   <tt>t</tt>.
--   
--   <pre>
--   time :: Behavior TimeT
--   </pre>
time :: (Ord t) => BehaviorI t t

-- | Discretely changing behavior, based on an initial value and a
--   new-value event.
--   
--   <pre>
--   stepper :: a -&gt; Event a -&gt; Behavior a
--   </pre>
stepper :: a -> EventI t a -> BehaviorI t a

-- | Switch between behaviors.
--   
--   <pre>
--   switcher :: Behavior a -&gt; Event (Behavior a) -&gt; Behavior a
--   </pre>
switcher :: (Ord tr, Bounded tr) => BehaviorG tr tf a -> EventG tr (BehaviorG tr tf a) -> BehaviorG tr tf a

-- | Snapshots a behavior whenever an event occurs and combines the values
--   using the combining function passed. Take careful note of the order of
--   arguments and results.
--   
--   <pre>
--   snapshotWith :: (a -&gt; b -&gt; c) -&gt; Behavior b -&gt; Event a -&gt; Event c
--   </pre>
snapshotWith :: (Ord t) => (a -> b -> c) -> BehaviorI t b -> EventI t a -> EventI t c

-- | Snapshot a behavior whenever an event occurs. See also
--   <a>snapshotWith</a>. Take careful note of the order of arguments and
--   results.
--   
--   <pre>
--   snapshot :: Behavior b -&gt; Event a -&gt; Event (a,b)
--   </pre>
snapshot :: (Ord t) => BehaviorI t b -> EventI t a -> EventI t (a, b)

-- | Like <a>snapshot</a> but discarding event data (often <tt>a</tt> is
--   '()').
--   
--   <pre>
--   snapshot_ :: Behavior b -&gt; Event a -&gt; Event b
--   </pre>
snapshot_ :: (Ord t) => BehaviorI t b -> EventI t a -> EventI t b

-- | Filter an event according to whether a reactive boolean is true.
--   
--   <pre>
--   whenE :: Behavior Bool -&gt; Event a -&gt; Event a
--   </pre>
whenE :: (Ord t) => BehaviorI t Bool -> EventI t a -> EventI t a

-- | Behavior from an initial value and an updater event. See also
--   <tt>accumE</tt>.
--   
--   <pre>
--   accumB :: a -&gt; Event (a -&gt; a) -&gt; Behavior a
--   </pre>
accumB :: a -> EventI t (a -> a) -> BehaviorI t a

-- | Like <a>scanl</a> for behaviors. See also <tt>scanlE</tt>.
--   
--   <pre>
--   scanlB :: forall a. (Behavior a -&gt; Behavior a -&gt; Behavior a) -&gt; Behavior a
--          -&gt; Event (Behavior a) -&gt; Behavior a
--   </pre>
scanlB :: (Ord tr, Bounded tr) => (b -> BehaviorG tr tf a -> BehaviorG tr tf a) -> BehaviorG tr tf a -> EventG tr b -> BehaviorG tr tf a

-- | Accumulate values from a monoid-valued event. Specialization of
--   <a>scanlB</a>, using <a>mappend</a> and <a>mempty</a>. See also
--   <tt>monoidE</tt>.
--   
--   <pre>
--   monoidB :: Monoid a =&gt; Event (Behavior a) -&gt; Behavior a
--   </pre>
monoidB :: (Ord tr, Bounded tr, Monoid a) => EventG tr (BehaviorG tr tf a) -> BehaviorG tr tf a

-- | Start out blank (<a>Nothing</a>), latching onto each new <tt>a</tt>,
--   and blanking on each <tt>b</tt>. If you just want to latch and not
--   blank, then use <a>mempty</a> for the second event.
--   
--   <pre>
--   maybeB :: Event a -&gt; Event b -&gt; Behavior (Maybe a)
--   </pre>
maybeB :: (Ord t) => EventI t a -> EventI t b -> BehaviorI t (Maybe a)

-- | Flip-flopping behavior. Turns true whenever first event occurs and
--   false whenever the second event occurs.
--   
--   <pre>
--   flipFlop :: Event a -&gt; Event b -&gt; Behavior Bool
--   </pre>
flipFlop :: (Ord t) => EventI t a -> EventI t b -> BehaviorI t Bool

-- | Count occurrences of an event. See also <tt>countE</tt>.
--   
--   <pre>
--   countB :: Num n =&gt; Event a -&gt; Behavior n
--   </pre>
countB :: (Ord t, Num n) => EventI t a -> BehaviorI t n

-- | Like <a>sum</a> for behaviors.
--   
--   <pre>
--   sumB :: AdditiveGroup a =&gt; Event a -&gt; Behavior a
--   </pre>
sumB :: (Ord t, AdditiveGroup a) => EventI t a -> BehaviorI t a

-- | Euler integral.
--   
--   <pre>
--   integral :: (VectorSpace v, Scalar v ~ TimeT) =&gt;
--               Event () -&gt; Behavior v -&gt; Behavior v
--   </pre>
integral :: (VectorSpace v, AffineSpace t, (Scalar v) ~ (Diff t), Ord t) => EventI t a -> BehaviorI t v -> BehaviorI t v
instance (Monoid tr, Monoid tf) => Copointed (BehaviorG tr tf)
instance (Functor g, Functor f, Copointed g, Copointed f) => Copointed (g :. f)

module FRP.Reactive.VectorSpace
instance (VectorSpace v) => VectorSpace (Behavior v)
instance (AdditiveGroup v) => AdditiveGroup (Behavior v)


-- | Numeric class instances for behaviors
module FRP.Reactive.Num
instance (RealFloat a) => RealFloat (Behavior a)
instance (RealFrac a) => RealFrac (Behavior a)
instance (Floating b) => Floating (Behavior b)
instance (Fractional b) => Fractional (Behavior b)
instance (Integral a) => Integral (Behavior a)
instance (Num a, Ord a) => Real (Behavior a)
instance (Num b) => Num (Behavior b)
instance Show (Behavior b)
instance (Enum a) => Enum (Behavior a)
instance (Ord b) => Ord (Behavior b)
instance Eq (Behavior b)


-- | Serializing clocks
--   
--   Thanks to Luke Palmer for help with this module.
module FRP.Reactive.Internal.Clock

-- | Waits a specified duration and then execute an action type Delay t = t
--   -&gt; forall a. IO a -&gt; IO a
--   
--   Waits until just after a specified time and then execute an action,
--   passing in the actual time. type Schedule t = t -&gt; Sink (Sink t)
--   
--   A serializing clock. Can (a) produce a time and (b) serialize an
--   action.
data Clock t
Clock :: IO t -> Serial -> Clock t
cGetTime :: Clock t -> IO t
cSerialize :: Clock t -> Serial

-- | Make a clock
makeClock :: IO (Clock TimeT)


module FRP.Reactive.Internal.Timing

-- | Execute an action-valued event.
adaptE :: Sink (Event Action)

-- | Make an action to be executed regularly, given a time-source and a
--   action-behavior. The generated action is optimized to do almost no
--   work during known-constant phases of the given behavior.
mkUpdater :: IO TimeT -> Behavior Action -> IO Action

-- | Sleep past a given time
sleepPast :: IO TimeT -> Sink TimeT


-- | Timed values. A primitive interface for futures.
module FRP.Reactive.Internal.TVal

-- | An <tt>a</tt> that's fed by a <tt>b</tt>
type :--> b a = (Sink b, a)

-- | Make a '(:--&gt;)'.
type :+-> b a = IO (b :--> a)

-- | Make a new event and a sink that writes to it. Uses the given clock to
--   serialize and time-stamp.
makeEvent :: Clock TimeT -> forall a. (Show a) => (a :+-> Event a)


-- | Tools for making Reactive adapters for imperative ("legacy")
--   libraries.
module FRP.Reactive.LegacyAdapters

-- | Value consumer
type Sink a = a -> Action

-- | Convenient alias for dropping parentheses.
type Action = IO ()

-- | Waits a specified duration and then execute an action type Delay t = t
--   -&gt; forall a. IO a -&gt; IO a
--   
--   Waits until just after a specified time and then execute an action,
--   passing in the actual time. type Schedule t = t -&gt; Sink (Sink t)
--   
--   A serializing clock. Can (a) produce a time and (b) serialize an
--   action.
data Clock t

-- | Make a clock
makeClock :: IO (Clock TimeT)
cGetTime :: Clock t -> IO t

-- | Execute an action-valued event.
adaptE :: Sink (Event Action)

-- | Make an action to be executed regularly, given a time-source and a
--   action-behavior. The generated action is optimized to do almost no
--   work during known-constant phases of the given behavior.
mkUpdater :: IO TimeT -> Behavior Action -> IO Action


-- | A library for programming with functional reactive behaviors.
module FRP.Reactive

-- | The type of time values with additional min &amp; max elements.
type TimeT = Double

-- | Improving times, as used for time values in <a>Event</a>,
--   <a>Reactive</a>, and <tt>ReactiveB</tt>.
type ITime = ImpBounds TimeT

-- | Events. Semantically: time-ordered list of future values. Instances:
--   
--   <ul>
--   <li><tt>Monoid</tt>: <tt>mempty</tt> is the event that never occurs,
--   and <tt>e <tt>mappend</tt> e'</tt> is the event that combines
--   occurrences from <tt>e</tt> and <tt>e'</tt>.</li>
--   <li><a>Functor</a>: <tt>fmap f e</tt> is the event that occurs
--   whenever <tt>e</tt> occurs, and whose occurrence values come from
--   applying <tt>f</tt> to the values from <tt>e</tt>.</li>
--   <li><tt>Applicative</tt>: <tt>pure a</tt> is an event with a single
--   occurrence at time -Infinity. <tt>ef &lt;*&gt; ex</tt> is an event
--   whose occurrences are made from the <i>product</i> of the occurrences
--   of <tt>ef</tt> and <tt>ex</tt>. For every occurrence <tt>f</tt> at
--   time <tt>tf</tt> of <tt>ef</tt> and occurrence <tt>x</tt> at time
--   <tt>tx</tt> of <tt>ex</tt>, <tt>ef &lt;*&gt; ex</tt> has an occurrence
--   <tt>f x</tt> at time <tt>tf <a>max</a> tx</tt>. N.B.: I don't expect
--   this instance to be very useful. If <tt>ef</tt> has <tt>nf</tt>
--   instances and <tt>ex</tt> has <tt>nx</tt> instances, then <tt>ef
--   &lt;*&gt; ex</tt> has <tt>nf*nx</tt> instances. However, there are
--   only <tt>nf+nx</tt> possibilities for <tt>tf <a>max</a> tx</tt>, so
--   many of the occurrences are simultaneous. If you think you want to use
--   this instance, consider using <tt>Reactive</tt> instead.</li>
--   <li><a>Monad</a>: <tt>return a</tt> is the same as <tt>pure a</tt> (as
--   usual). In <tt>e &gt;&gt;= f</tt>, each occurrence of <tt>e</tt>
--   leads, through <tt>f</tt>, to a new event. Similarly for <tt>join
--   ee</tt>, which is somehow simpler for me to think about. The
--   occurrences of <tt>e &gt;&gt;= f</tt> (or <tt>join ee</tt>) correspond
--   to the union of the occurrences (temporal interleaving) of all such
--   events. For example, suppose we're playing Asteroids and tracking
--   collisions. Each collision can break an asteroid into more of them,
--   each of which has to be tracked for more collisions. Another example:
--   A chat room has an <i>enter</i> event, whose occurrences contain new
--   events like <i>speak</i>. An especially useful monad-based function is
--   <tt>joinMaybes</tt>, which filters a Maybe-valued event.</li>
--   </ul>
data EventG t a

-- | Events, specialized to improving doubles for time
type Event = EventG ITime

-- | Accumulating event, starting from an initial value and a
--   update-function event. See also <a>accumR</a>.
accumE :: a -> EventG t (a -> a) -> EventG t a

-- | Access occurrence times in an event. See <a>withTimeGE</a> for more
--   general notions of time.
--   
--   <pre>
--   withTimeE :: Event a -&gt; Event (a, TimeT)
--   </pre>
withTimeE :: (Ord t) => EventG (ImpBounds t) d -> EventG (ImpBounds t) (d, t)

-- | Access occurrence times in an event. Discard the rest. See also
--   <a>withTimeE</a>.
--   
--   <pre>
--   withTimeE_ :: Event a -&gt; Event TimeT
--   </pre>
withTimeE_ :: (Ord t) => EventG (ImpBounds t) d -> EventG (ImpBounds t) t

-- | Generate a pair-valued event, given a pair of initial values and a
--   pair of events. See also <tt>pair</tt> on <a>Reactive</a>. Not quite a
--   <a>zip</a>, because of the initial pair required.
zipE :: (Ord t, Bounded t) => (c, d) -> (EventG t c, EventG t d) -> EventG t (c, d)

-- | Like <a>scanl</a> for events.
scanlE :: (Ord t, Bounded t) => (a -> b -> a) -> a -> EventG t b -> EventG t a

-- | Accumulate values from a monoid-typed event. Specialization of
--   <a>scanlE</a>, using <a>mappend</a> and <a>mempty</a>.
monoidE :: (Ord t, Bounded t, Monoid o) => EventG t o -> EventG t o

-- | Mealy-style state machine, given initial value and transition
--   function. Carries along event data. See also <a>mealy_</a>.
mealy :: (Ord t, Bounded t) => s -> (s -> s) -> EventG t b -> EventG t (b, s)

-- | Mealy-style state machine, given initial value and transition
--   function. Forgetful version of <a>mealy</a>.
mealy_ :: (Ord t, Bounded t) => s -> (s -> s) -> EventG t b -> EventG t s

-- | Count occurrences of an event, remembering the occurrence values. See
--   also <a>countE_</a>.
countE :: (Ord t, Bounded t, Num n) => EventG t b -> EventG t (b, n)

-- | Count occurrences of an event, forgetting the occurrence values. See
--   also <a>countE</a>.
countE_ :: (Ord t, Bounded t, Num n) => EventG t b -> EventG t n

-- | Difference of successive event occurrences. See <a>withPrevE</a> for a
--   trick to supply an initial previous value.
diffE :: (Ord t, Bounded t, AffineSpace a) => EventG t a -> EventG t (Diff a)

-- | Pair each event value with the previous one. The second result is the
--   old one. Nothing will come out for the first occurrence of <tt>e</tt>,
--   but if you have an initial value <tt>a</tt>, you can do <tt>withPrevE
--   (pure a <a>mappend</a> e)</tt>.
withPrevE :: (Ord t, Bounded t) => EventG t a -> EventG t (a, a)

-- | Same as <a>withPrevE</a>, but allow a function to combine the values.
--   Provided for convenience.
withPrevEWith :: (Ord t, Bounded t) => (a -> a -> b) -> EventG t a -> EventG t b

-- | Combine two events into one.
eitherE :: (Ord t, Bounded t) => EventG t a -> EventG t b -> EventG t (Either a b)

-- | Experimental specialization of <a>joinMaybes</a>.
justE :: (Ord t, Bounded t) => EventG t (Maybe a) -> EventG t a

-- | Experimental specialization of <a>filterMP</a>.
filterE :: (Ord t, Bounded t) => (a -> Bool) -> EventG t a -> EventG t a

-- | Convert a temporally monotonic list of timed values to an event. See
--   also the generalization <a>listEG</a>
listE :: [(TimeT, a)] -> Event a

-- | Event occuring at given times. See also <a>atTime</a> and
--   <a>atTimeG</a>.
atTimes :: [TimeT] -> Event ()

-- | Single-occurrence event at given time. See <a>atTimes</a> and
--   <a>atTimeG</a>.
atTime :: TimeT -> Event ()

-- | Just the first occurrence of an event.
once :: (Ord t, Bounded t) => EventG t a -> EventG t a

-- | Decompose an event into its first occurrence value and a remainder
--   event. See also <a>firstE</a> and <a>restE</a>.
firstRestE :: (Ord t, Bounded t) => EventG t a -> (a, EventG t a)

-- | Extract the first occurrence value of an event. See also
--   <a>firstRestE</a> and <a>restE</a>.
firstE :: (Ord t, Bounded t) => EventG t a -> a

-- | Extract the remainder an event, after its first occurrence. See also
--   <a>firstRestE</a> and <a>firstE</a>.
restE :: (Ord t, Bounded t) => EventG t a -> EventG t a

-- | Tack remainders a second event onto values of a first event. Occurs
--   when the first event occurs.
snapRemainderE :: (Ord t, Bounded t) => EventG t b -> EventG t a -> EventG t (a, EventG t b)

-- | Access the remainder with each event occurrence.
withRestE :: EventG t a -> EventG t (a, EventG t a)

-- | Truncate first event at first occurrence of second event.
untilE :: (Ord t, Bounded t) => EventG t a -> EventG t b -> EventG t a

-- | Partition an event into segments.
splitE :: (Ord t, Bounded t) => EventG t b -> EventG t a -> EventG t (a, EventG t b)

-- | Switch from one event to another, as they occur. (Doesn't merge, as
--   <a>join</a> does.)
switchE :: (Ord t, Bounded t) => EventG t (EventG t a) -> EventG t a

-- | Pass through <tt>Just</tt> occurrences.
joinMaybes :: (MonadPlus m) => m (Maybe a) -> m a

-- | Pass through values satisfying <tt>p</tt>.
filterMP :: (MonadPlus m) => (a -> Bool) -> m a -> m a

-- | Reactive behaviors. They can be understood in terms of a simple model
--   (denotational semantics) as functions of time, namely <tt>at ::
--   BehaviorG t a -&gt; (t -&gt; a)</tt>.
--   
--   The semantics of <a>BehaviorG</a> instances are given by corresponding
--   instances for the semantic model (functions). See
--   <a>http://conal.net/blog/posts/simplifying-semantics-with-type-class-morphisms/</a>.
--   
--   <ul>
--   <li><a>Functor</a>: <tt>at (fmap f r) == fmap f (at r)</tt>, i.e.,
--   <tt>fmap f r <tt>at</tt> t == f (r <tt>at</tt> t)</tt>.</li>
--   <li><a>Applicative</a>: <tt>at (pure a) == pure a</tt>, and <tt>at (s
--   &lt;*&gt; r) == at s &lt;*&gt; at t</tt>. That is, <tt>pure a
--   <tt>at</tt> t == a</tt>, and <tt>(s &lt;*&gt; r) <tt>at</tt> t == (s
--   <tt>at</tt> t) (r <tt>at</tt> t)</tt>.</li>
--   <li><a>Monad</a>: <tt>at (return a) == return a</tt>, and <tt>at (join
--   rr) == join (at . at rr)</tt>. That is, <tt>return a <tt>at</tt> t ==
--   a</tt>, and <tt>join rr <tt>at</tt> t == (rr <tt>at</tt> t)
--   <tt>at</tt> t</tt>. As always, <tt>(r &gt;&gt;= f) == join (fmap f
--   r)</tt>. <tt>at (r &gt;&gt;= f) == at r &gt;&gt;= at . f</tt>.</li>
--   <li><a>Monoid</a>: a typical lifted monoid. If <tt>o</tt> is a monoid,
--   then <tt>Reactive o</tt> is a monoid, with <tt>mempty == pure
--   mempty</tt>, and <tt>mappend == liftA2 mappend</tt>. That is,
--   <tt>mempty <tt>at</tt> t == mempty</tt>, and <tt>(r <a>mappend</a> s)
--   <tt>at</tt> t == (r <tt>at</tt> t) <a>mappend</a> (s <tt>at</tt>
--   t).</tt></li>
--   </ul>
data BehaviorG tr tf a

-- | Time-specialized behaviors. Note: The signatures of all of the
--   behavior functions can be generalized. Is the interface generality
--   worth the complexity?
type Behavior = BehaviorI TimeT
type Behaviour = Behavior

-- | The identity generalized behavior. Has value <tt>t</tt> at time
--   <tt>t</tt>.
--   
--   <pre>
--   time :: Behavior TimeT
--   </pre>
time :: (Ord t) => BehaviorI t t

-- | Discretely changing behavior, based on an initial value and a
--   new-value event.
--   
--   <pre>
--   stepper :: a -&gt; Event a -&gt; Behavior a
--   </pre>
stepper :: a -> EventI t a -> BehaviorI t a

-- | Switch between behaviors.
--   
--   <pre>
--   switcher :: Behavior a -&gt; Event (Behavior a) -&gt; Behavior a
--   </pre>
switcher :: (Ord tr, Bounded tr) => BehaviorG tr tf a -> EventG tr (BehaviorG tr tf a) -> BehaviorG tr tf a

-- | Snapshots a behavior whenever an event occurs and combines the values
--   using the combining function passed. Take careful note of the order of
--   arguments and results.
--   
--   <pre>
--   snapshotWith :: (a -&gt; b -&gt; c) -&gt; Behavior b -&gt; Event a -&gt; Event c
--   </pre>
snapshotWith :: (Ord t) => (a -> b -> c) -> BehaviorI t b -> EventI t a -> EventI t c

-- | Snapshot a behavior whenever an event occurs. See also
--   <a>snapshotWith</a>. Take careful note of the order of arguments and
--   results.
--   
--   <pre>
--   snapshot :: Behavior b -&gt; Event a -&gt; Event (a,b)
--   </pre>
snapshot :: (Ord t) => BehaviorI t b -> EventI t a -> EventI t (a, b)

-- | Like <a>snapshot</a> but discarding event data (often <tt>a</tt> is
--   '()').
--   
--   <pre>
--   snapshot_ :: Behavior b -&gt; Event a -&gt; Event b
--   </pre>
snapshot_ :: (Ord t) => BehaviorI t b -> EventI t a -> EventI t b

-- | Filter an event according to whether a reactive boolean is true.
--   
--   <pre>
--   whenE :: Behavior Bool -&gt; Event a -&gt; Event a
--   </pre>
whenE :: (Ord t) => BehaviorI t Bool -> EventI t a -> EventI t a

-- | Behavior from an initial value and an updater event. See also
--   <tt>accumE</tt>.
--   
--   <pre>
--   accumB :: a -&gt; Event (a -&gt; a) -&gt; Behavior a
--   </pre>
accumB :: a -> EventI t (a -> a) -> BehaviorI t a

-- | Like <a>scanl</a> for behaviors. See also <tt>scanlE</tt>.
--   
--   <pre>
--   scanlB :: forall a. (Behavior a -&gt; Behavior a -&gt; Behavior a) -&gt; Behavior a
--          -&gt; Event (Behavior a) -&gt; Behavior a
--   </pre>
scanlB :: (Ord tr, Bounded tr) => (b -> BehaviorG tr tf a -> BehaviorG tr tf a) -> BehaviorG tr tf a -> EventG tr b -> BehaviorG tr tf a

-- | Accumulate values from a monoid-valued event. Specialization of
--   <a>scanlB</a>, using <a>mappend</a> and <a>mempty</a>. See also
--   <tt>monoidE</tt>.
--   
--   <pre>
--   monoidB :: Monoid a =&gt; Event (Behavior a) -&gt; Behavior a
--   </pre>
monoidB :: (Ord tr, Bounded tr, Monoid a) => EventG tr (BehaviorG tr tf a) -> BehaviorG tr tf a

-- | Start out blank (<a>Nothing</a>), latching onto each new <tt>a</tt>,
--   and blanking on each <tt>b</tt>. If you just want to latch and not
--   blank, then use <a>mempty</a> for the second event.
--   
--   <pre>
--   maybeB :: Event a -&gt; Event b -&gt; Behavior (Maybe a)
--   </pre>
maybeB :: (Ord t) => EventI t a -> EventI t b -> BehaviorI t (Maybe a)

-- | Flip-flopping behavior. Turns true whenever first event occurs and
--   false whenever the second event occurs.
--   
--   <pre>
--   flipFlop :: Event a -&gt; Event b -&gt; Behavior Bool
--   </pre>
flipFlop :: (Ord t) => EventI t a -> EventI t b -> BehaviorI t Bool

-- | Count occurrences of an event. See also <tt>countE</tt>.
--   
--   <pre>
--   countB :: Num n =&gt; Event a -&gt; Behavior n
--   </pre>
countB :: (Ord t, Num n) => EventI t a -> BehaviorI t n

-- | Like <a>sum</a> for behaviors.
--   
--   <pre>
--   sumB :: AdditiveGroup a =&gt; Event a -&gt; Behavior a
--   </pre>
sumB :: (Ord t, AdditiveGroup a) => EventI t a -> BehaviorI t a

-- | Euler integral.
--   
--   <pre>
--   integral :: (VectorSpace v, Scalar v ~ TimeT) =&gt;
--               Event () -&gt; Behavior v -&gt; Behavior v
--   </pre>
integral :: (VectorSpace v, AffineSpace t, (Scalar v) ~ (Diff t), Ord t) => EventI t a -> BehaviorI t v -> BehaviorI t v
