-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | the * -> * types, operators, and covariant instances.
--   
--   Fundamental * -&gt; * types, operators, and covariant instances.
@package star-to-star
@version 1.0


-- | Fundamental * -&gt; * types and (covariant) instances for the common
--   classes: Functor, Foldable, and Traversable.
module Data.StarToStar
data V a
data U a
U :: U a
data C x a
C :: x -> C x a
onC :: (x -> b) -> C x a -> b
underC :: (x -> y) -> C x a -> C y b
toC :: x -> C x a
fromC :: C x a -> x
data I a
I :: a -> I a
onI :: (a -> b) -> I a -> b
underI :: (a -> b) -> I a -> I b
toI :: a -> I a
fromI :: I a -> a
newtype E e a
E :: (e -> a) -> E e a
onE :: ((e -> a) -> b) -> E e a -> b
underE :: ((e -> a) -> (f -> b)) -> E e a -> E f b
toE :: (e -> a) -> E e a
fromE :: E e a -> (e -> a)
type :-> = E
newtype K r a
K :: (a -> r) -> K r a
onK :: ((a -> r) -> b) -> K r a -> b
underK :: ((a -> r) -> (b -> s)) -> K r a -> K s b
toK :: (a -> r) -> K r a
fromK :: K r a -> a -> r
type :<- = K
newtype O f g a
O :: (f (g a)) -> O f g a
onO :: (f (g a) -> b) -> O f g a -> b
underO :: (f (g a) -> h (i b)) -> O f g a -> O h i b
toO :: f (g a) -> O f g a
fromO :: O f g a -> f (g a)
type :. = O
data S f g a
L :: (f a) -> S f g a
R :: (g a) -> S f g a
onS :: (Either (f a) (g a) -> b) -> S f g a -> b
onS' :: (f a -> b) -> (g a -> b) -> S f g a -> b
underS :: (Either (f a) (g a) -> Either (h b) (i b)) -> S f g a -> S h i b
toS :: Either (f a) (g a) -> S f g a
fromS :: S f g a -> Either (f a) (g a)
type :+ = S
data P f g a
P :: (f a) -> (g a) -> P f g a
onP :: ((f a, g a) -> b) -> P f g a -> b
underP :: ((f a, g a) -> (h b, i b)) -> P f g a -> P h i b
toP :: (f a, g a) -> P f g a
fromP :: P f g a -> (f a, g a)
type :* = P
newtype F f g a
F :: (f a -> g a) -> F f g a
onF :: ((f a -> g a) -> b) -> F f g a -> b
underF :: ((f a -> g a) -> (h b -> i b)) -> F f g a -> F h i b
toF :: (f a -> g a) -> F f g a
fromF :: F f g a -> f a -> g a
newtype Fix ff a
In :: (ff (Fix ff) a) -> Fix ff a
underFix :: (ff (Fix ff) a -> gg (Fix gg) b) -> Fix ff a -> Fix gg b
toFix :: ff (Fix ff) a -> Fix ff a
fromFix :: Fix ff a -> ff (Fix ff) a
newtype Flip op f g a
Flip :: (op g f a) -> Flip op f g a
onFlip :: (op g f a -> b) -> Flip op f g a -> b
underFlip :: (op g f a -> op' g' f' a') -> Flip op f g a -> Flip op' f' g' a'
toFlip :: op g f a -> Flip op f g a
fromFlip :: Flip op f g a -> op g f a
instance Traversable (op g f) => Traversable (Flip op f g)
instance Foldable (op g f) => Foldable (Flip op f g)
instance Functor (op g f) => Functor (Flip op f g)
instance Traversable (ff (Fix ff)) => Traversable (Fix ff)
instance Foldable (ff (Fix ff)) => Foldable (Fix ff)
instance Functor (ff (Fix ff)) => Functor (Fix ff)
instance (Traversable f, Traversable g) => Traversable (P f g)
instance (Foldable f, Foldable g) => Foldable (P f g)
instance (Functor f, Functor g) => Functor (P f g)
instance (Traversable f, Traversable g) => Traversable (S f g)
instance (Foldable f, Foldable g) => Foldable (S f g)
instance (Functor f, Functor g) => Functor (S f g)
instance (Traversable f, Traversable g) => Traversable (O f g)
instance (Foldable f, Foldable g) => Foldable (O f g)
instance (Functor f, Functor g) => Functor (O f g)
instance Functor (E e)
instance Traversable I
instance Foldable I
instance Functor I
instance Traversable (C x)
instance Foldable (C x)
instance Functor (C x)
instance Traversable U
instance Foldable U
instance Functor U
instance Traversable V
instance Foldable V
instance Functor V
