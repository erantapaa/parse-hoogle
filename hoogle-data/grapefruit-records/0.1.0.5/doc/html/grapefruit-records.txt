-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A record system for Functional Reactive Programming
--   
--   Grapefruit is a library for Functional Reactive Programming (FRP) with
--   a focus on user interfaces. FRP makes it possible to implement
--   reactive and interactive systems in a declarative style. To learn more
--   about FRP, have a look at
--   <a>http://haskell.org/haskellwiki/Functional_Reactive_Programming</a>.
--   
--   This package provides a record system for use with FRP.
@package grapefruit-records
@version 0.1.0.5

module Data.Record
class Kind kind where data family Forall kind :: (* -> *) -> *
encase :: Kind kind => (forall sort. Sort kind sort => piece sort) -> Forall kind piece
class Sort kind sort
specialize :: Sort kind sort => Forall kind piece -> piece sort
class Kind (K style) => Style style where type family K style :: *

-- | The class of all record types.
--   
--   A record type is a type of records without the style parameter.
--   Therefore, it has kind <tt>* -&gt; *</tt>.
class Kind kind => Record kind record
build :: Record kind record => thing X -> (forall record name. Record kind record => Forall kind (ExtenderPiece thing record name)) -> thing record
newtype ExtenderPiece thing record name sort
ExtenderPiece :: (thing record -> thing (record :& (name ::: sort))) -> ExtenderPiece thing record name sort

-- | The type of empty records.
data X style
X :: X style

-- | The type of non-empty records, consisting of an initial record and a
--   last field.
data (:&) record field style
(:&) :: !(record style) -> !(field style) -> :& record field style

-- | The family of record fields.
--   
--   Each instance of it matches arbitrary <tt>name</tt> parameters and all
--   <tt>signalOfVal</tt> parameters which are of the form
--   <tt><i>signal</i> `<tt>Of</tt>` <i>val</i></tt>. The actual choice of
--   the instance depends only on the <tt>style</tt> parameter. The
--   structure of fields of a specific style is documented together with
--   the respective style type.
data (:::) name sort style
(:=) :: !name -> Value style sort -> ::: name sort style

-- | The catenation of two record types.

-- | The catenation of two records.
cat :: (Style style, Record (K style) record1, Record (K style) record2) => record1 style -> record2 style -> Cat record1 record2 style

-- | Application of a function to the fields of a record.
map :: (Style style, Style style', K style ~ K style', Record (K style) record) => Forall (K style) (TransformerPiece style style') -> record style -> record style'
newtype TransformerPiece style style' sort
TransformerPiece :: (Value style sort -> Value style' sort) -> TransformerPiece style style' sort

-- | The class of all pairs of record types where the first is a subrecord
--   of the second.
--   
--   Currenty, the subrecord relation is only defined for records which do
--   not have multiple occurences of the same name. A records is a
--   subrecord of another record if all field types of the first record are
--   also field types of the second, independently of order.
--   
--   The instance declarations of <tt>Subrecord</tt> use several helper
--   classes which are hidden. One of them is the class <tt>Presence</tt>.
--   You get the error message that no instance of <tt>Presence
--   <i>name</i></tt> could be found if the alleged subrecord contains a
--   name which is not present in the alleged superrecord.
class Subrecord subrecord record
narrow :: (Subrecord subrecord record, Style style) => record style -> subrecord style
instance [overlap ok] Show (X style)
instance [overlap ok] (Dissection init initRemainder lookupName lookupSort, (initRemainder :& (lastName ::: lastSort)) ~ remainder) => Dissection (init :& (lastName ::: lastSort)) remainder lookupName lookupSort
instance [overlap ok] lastSort ~ lookupSort => Dissection (init :& (lookupName ::: lastSort)) init lookupName lookupSort
instance [overlap ok] (Dissection record remainder subname subsort, Subrecord subrecord remainder) => Subrecord (subrecord :& (subname ::: subsort)) record
instance [overlap ok] Subrecord X record
instance [overlap ok] (Show name, Show (Value style sort)) => Show ((:::) name sort style)
instance [overlap ok] (Show (init style), Show (last style)) => Show ((:&) init last style)
instance [overlap ok] (Kind kind, Record kind record, Sort kind sort) => Record kind (record :& (name ::: sort))
instance [overlap ok] Kind kind => Record kind X

module Data.Record.Context

-- | The context consumer and context producer record styles.
--   
--   <tt>ContextConnectorStyle <i>context</i> <tt>Consumer</tt></tt> is the
--   style of context consumer records with context <tt><i>context</i></tt>
--   and <tt>ContextConnectorStyle <i>context</i> <tt>Producer</tt></tt> is
--   the style of context producer records with context
--   <tt><i>context</i></tt>. Fields of context connector style records
--   have the form <tt><i>name</i> ::~~ <i>connectorGenerator</i></tt>.
data ContextStyle context style

-- | Applies all values of a context connector record to a given context to
--   form an ordinary context record.
app :: (Style style, Record (K style) record) => record (ContextStyle context style) -> context -> record style
instance [overlap ok] Style style => Style (ContextStyle context style)

module Data.Record.Plain
data PlainKind
data PlainStyle
instance [overlap ok] Style PlainStyle
instance [overlap ok] Sort PlainKind val
instance [overlap ok] Kind PlainKind


-- | This module provides support for optionality records.
--   
--   Optionality records are used to specify interfaces with optional input
--   data. Compared to an ordinary record type, an optionality record type
--   states for every field whether it is required or optional. This is
--   done by a slight abuse of field names. A field name
--   <tt><i>name</i></tt> is replaced by either <tt><a>Req</a>
--   <i>name</i></tt> or <tt><a>Opt</a> <i>name</i></tt>. Optionality
--   record types are never used directly in types of actual values.
--   Instead, they are converted into ordinary record types with the type
--   functions <a>All</a> and <a>Required</a>.
module Data.Record.Optionality

-- | A marker for required fields.
data Req name

-- | A marker for optional fields.
data Opt name

-- | The class of all optionality record types.
class OptRecord (optRecord :: * -> *) where type family All optRecord :: * -> * type family Required optRecord :: * -> *
instance [overlap ok] OptRecord optRecord => OptRecord (optRecord :& (Opt name ::: sort))
instance [overlap ok] OptRecord optRecord => OptRecord (optRecord :& (Req name ::: sort))
instance [overlap ok] OptRecord X


-- | This module provides records of signals and signal-related data.
--   
--   A record has a type of the following form:
--   
--   <pre>
--   (X :&amp; <i>name_1</i> ::: <i>signal_1</i> `<a>Of</a>` <i>val_1</i> :&amp; ... :&amp; <i>name_n</i> ::: <i>signal_n</i> `<a>Of</a>` <i>val_n</i>) <i>style</i>
--   </pre>
--   
--   A value of such a type is a list of <i>fields</i> where the <i>i</i>th
--   field has type <tt>(<i>name_i</i> ::: <i>signal_i</i> `<a>Of</a>`
--   <i>val_i</i>) <i>style</i></tt>.
--   
--   <tt>(:::)</tt> is a data family. Its <tt><i>style</i></tt> parameter
--   is a phantom type which selects the instance of the family. For a
--   concrete <tt><i>style</i></tt> type, the type <tt>(<i>name</i> :::
--   <i>signal</i> `<a>Of</a>` <i>val</i>) <i>style</i></tt> covers
--   name-value pairs where the type of the values depends on
--   <tt><i>signal</i></tt> and <tt><i>val</i></tt>. For example, if
--   <tt><i>style</i></tt> is of the form <tt><a>SignalStyle</a>
--   <i>era</i></tt>, the values have type <tt><i>signal</i> <i>era</i>
--   <i>val</i></tt>. This leads to records of signals with identical era.
--   With the styles <tt><tt>Connector</tt> <a>Consumer</a></tt> and
--   <tt><tt>Connector</tt> <a>Producer</a></tt>, it is possible to form
--   records of consumers and producers.
--   
--   Field names are represented by types which are declared as follows:
--   
--   <pre>
--   data <i>Name</i> = <i>Name</i>
--   </pre>
--   
--   This makes it possible to use names as types (allowing the use of
--   names in compile-time checks) but also as expressions and patterns.
module Data.Record.Signal
data SignalKind

-- | Records which contain signals of a common era as values.
type SignalRecord era record = record (SignalStyle era)

-- | The style of signal records of a specific era.
--   
--   Fields of signal style records have the form <tt><i>name</i> ::=
--   <i>signal</i></tt>.
data SignalStyle era

-- | Records which contain signal consumers as values.
type ConsumerRecord record = ConnectorRecord Consumer record

-- | Records which contain signal producers as values.
type ProducerRecord record = ConnectorRecord Producer record

-- | Records which which contain signal connectors (producers or consumers)
--   as values.
type ConnectorRecord connector record = record (ConnectorStyle connector)

-- | The consumer and producer record styles.
--   
--   <tt>ConnectorStyle <a>Consumer</a></tt> is the style of consumer
--   records and <tt>ConnectorStyle <a>Producer</a></tt> is the style of
--   producer records. Fields of connector style records have the form
--   <tt><i>name</i> ::~ <i>connector</i></tt>.
data ConnectorStyle (connector :: (* -> * -> *) -> * -> *)

-- | Converts a record of consumers into a circuit that consumes a
--   corresponding record of signals.
consume :: Record SignalKind record => ConsumerRecord record -> Circuit era (SignalRecord era record) ()

-- | Converts a record of producers into a circuit that produces a
--   corresponding record of signals.
produce :: Record SignalKind record => ProducerRecord record -> Circuit era () (SignalRecord era record)
instance [overlap ok] Style (ConnectorStyle connector)
instance [overlap ok] Style (SignalStyle era)
instance [overlap ok] Sort SignalKind (Of signal val)
instance [overlap ok] Kind SignalKind


-- | This module provides context connector records.
--   
--   A context connector record is a record of connectors (consumers or
--   producers) which depend on some data, called the context.
module Data.Record.Signal.Context

-- | Records which contain functions from contexts to consumers as values.
type ContextConsumerRecord context record = ContextConnectorRecord context Consumer record

-- | Records which contain functions from contexts to producers as values.
type ContextProducerRecord context record = ContextConnectorRecord context Producer record

-- | Records which contain functions from contexts to connectors (consumers
--   or producers) as values.
type ContextConnectorRecord context connector record = record (ContextConnectorStyle context connector)
type ContextConnectorStyle context connector = ContextStyle context (ConnectorStyle connector)

-- | Converts a record of context consumers into a reader arrow which
--   consumes a corresponding record of signals. The concrete context has
--   to be provided as the environment of the reader arrow.
consume :: Record SignalKind record => ContextConsumerRecord context record -> ReaderArrow context (Circuit era) (SignalRecord era record) ()

-- | Converts a record of context producers into a reader arrow which
--   produces a corresponding record of signals. The concrete context has
--   to be provided as the environment of the reader arrow.
produce :: Record SignalKind record => ContextProducerRecord context record -> ReaderArrow context (Circuit era) () (SignalRecord era record)
