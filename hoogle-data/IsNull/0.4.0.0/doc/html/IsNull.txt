-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A typeclass to determine if a given value is null.
--   
--   A typeclass to determine if a given foldable type (or other) is empty
--   ~ null ~ invalid. The definition is intentionally vague, to cover
--   types from Either to Text and Sets.
@package IsNull
@version 0.4.0.0


-- | A typeclass to determine if a given value is null.
--   
--   Strongly inspired by <a>mono-traversable</a> but with a simpler goal:
--   supporting IsNull and nested IsNull operations.
--   
--   While the <tt><a>isNull</a></tt> function is equivalent to <tt>(==)
--   mempty</tt> for most of the instances, not all
--   <tt><tt>Foldable</tt></tt>s are monoids, and not all monoids
--   <tt><tt>mempty</tt></tt> means null:
--   
--   <ul>
--   <li><tt><a>Either</a></tt> is an example of a <tt>Foldable</tt> which
--   is not a <tt><tt>Monoid</tt></tt>, but where it makes sense to
--   consider a <tt><a>Left</a></tt> as an <tt>Null</tt> value. While this
--   is not strictly true, the <tt><a>Left</a></tt> option does carries a
--   value, we take the more liberal approach: Empty ~ Null ~ Invalid
--   Value. If you need proper type reasoning, you should not be using this
--   package, just regular pattern matching instead.</li>
--   <li><tt><tt>Product</tt></tt> <tt><tt>Monoid</tt></tt> instance is
--   <tt>1</tt>. Hardly qualifies as an <tt>Empty</tt> or <tt>Null</tt>
--   value. For this reason no default implementation is provided for the
--   <tt><tt>Monoid</tt></tt> class. It's up to you to use <tt>(==)
--   mempty</tt> instead.</li>
--   </ul>
--   
--   This class is suitable for use with
--   <tt>GeneralizedNewtypeDeriving</tt>, thanks to the precious help of
--   Ivan Miljenovic.
--   
--   Bugs, suggestions and comments are most welcomed!
--   
--   <a>https://github.com/jcristovao/IsNull</a>
module Data.IsNull
class IsNull a
isNull :: IsNull a => a -> Bool

-- | the logical negation of <tt><a>isNull</a></tt>
notNull :: IsNull a => a -> Bool

-- | Nested isNull
--   
--   <pre>
--   &gt;&gt;&gt; isNullN (Just "abc")
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNullN (Just "")
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isNullN (Nothing :: Maybe String)
--   True
--   </pre>
isNullN :: (IsNull a, Foldable f) => f a -> Bool

-- | Nested isNotNull
notNullN :: (IsNull a, Foldable f) => f a -> Bool

-- | Monadic isNull
--   
--   <pre>
--   &gt;&gt;&gt; isNullM [""]
--   [True]
--   </pre>
isNullM :: (IsNull a, Functor m) => m a -> m Bool

-- | Monadic Nested isNull
isNullNM :: (IsNull a, Functor m, Foldable f) => m (f a) -> m Bool
(<\>) :: IsNull a => a -> a -> a
instance [overlap ok] Foldable f => IsNull (f a)
instance [overlap ok] IsNull IntSet
instance [overlap ok] IsNull ByteString
instance [overlap ok] IsNull ByteString
instance [overlap ok] IsNull Text
instance [overlap ok] IsNull Text
