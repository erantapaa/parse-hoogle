-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Efficient geometric vectors and transformations.
--   
--   This Haskell library implements several small vectors types with
--   <tt>Double</tt> fields, with seperate types for each size of vector,
--   and a type class for handling vectors generally. (Note that although
--   this package is listed in the "graphics" category, the package itself
--   has no graphics facilities. It just contains data structures that are
--   useful for graphics work.)
--   
--   Changes:
--   
--   <ul>
--   <li>Fixed a stupid bug in <tt>union</tt>. Until now, the function
--   could sometimes return gibberish answers. Hopefully this is now
--   fixed.</li>
--   </ul>
@package AC-Vector
@version 2.3.2


-- | General functions applicable to all vector types.
module Data.Vector.Class

-- | The type of vector field values.
type Scalar = Double

-- | All vector types belong to this class. Aside from <a>vpack</a> and
--   <a>vunpack</a>, these methods aren't especially useful to end-users;
--   they're used internally by the vector arithmetic implementations.
class BasicVector v
vmap :: BasicVector v => (Scalar -> Scalar) -> (v -> v)
vzip :: BasicVector v => (Scalar -> Scalar -> Scalar) -> (v -> v -> v)
vfold :: BasicVector v => (Scalar -> Scalar -> Scalar) -> (v -> Scalar)
vpack :: BasicVector v => [Scalar] -> Maybe v
vunpack :: BasicVector v => v -> [Scalar]
vpromote :: BasicVector v => Scalar -> v

-- | Dummy class that enables you to request a vector in a type signature
--   without needing to explicitly list <a>Num</a> or <a>Fractional</a> as
--   well.
class (BasicVector v, Num v, Fractional v) => Vector v

-- | Scale a vector (i.e., change its length but not its direction). This
--   operator has the same precedence as the usual <tt>(*)</tt> operator.
--   
--   The <tt>(*|)</tt> and <tt>(|*)</tt> operators are identical, but with
--   their argument flipped. Just remember that the '<tt>|</tt>' denotes
--   the scalar part.
(*|) :: Vector v => Scalar -> v -> v

-- | Scale a vector (i.e., change its length but not its direction). This
--   operator has the same precedence as the usual <tt>(*)</tt> operator.
--   
--   The <tt>(*|)</tt> and <tt>(|*)</tt> operators are identical, but with
--   their argument flipped. Just remember that the '<tt>|</tt>' denotes
--   the scalar part.
(|*) :: Vector v => v -> Scalar -> v

-- | Scale a vector (i.e., change its length but not its direction). This
--   operator has the same precedence as the usual <tt>(/)</tt> operator.
--   
--   The <tt>(<i>|)@ and @(|</i>)</tt> operators are identical, but with
--   their argument flipped. Just remember that the '<tt>|</tt>' denotes
--   the scalar part.
(|/) :: Vector v => v -> Scalar -> v

-- | Scale a vector (i.e., change its length but not its direction). This
--   operator has the same precedence as the usual <tt>(/)</tt> operator.
--   
--   The <tt>(<i>|)@ and @(|</i>)</tt> operators are identical, but with
--   their argument flipped. Just remember that the '<tt>|</tt>' denotes
--   the scalar part.
(/|) :: Vector v => Scalar -> v -> v

-- | Take the <i>dot product</i> of two vectors. This is a scalar equal to
--   the cosine of the angle between the two vectors multiplied by the
--   length of each vectors.
vdot :: Vector v => v -> v -> Scalar

-- | Return the length or <i>magnitude</i> of a vector. (Note that this
--   involves a slow square root operation.)
vmag :: Vector v => v -> Scalar

-- | Normalise a vector. In order words, return a new vector with the same
--   direction, but a length of exactly one. (If the vector's length is
--   zero or very near to zero, the vector is returned unchanged.)
vnormalise :: Vector v => v -> v

-- | Linearly interpolate between two points in space.
--   
--   <ul>
--   <li><pre>vlinear 0 a b = a</pre></li>
--   <li><pre>vlinear 1 a b = b</pre></li>
--   <li><tt>vlinear 0.5 a b</tt> would give a point exactly half way
--   between <tt>a</tt> and <tt>b</tt> in a straight line.</li>
--   </ul>
vlinear :: Vector v => Scalar -> v -> v -> v


-- | 1-dimensional vectors with vector arithmetic.
--   
--   This isn't especially useful. Usually if you want to calculate with
--   scalars, you can just use the <a>Scalar</a> type directly. However,
--   this module provides a <a>Vector1</a> newtype over <a>Scalar</a> that
--   allows a scalar to be treated as a sort of vector, which is very
--   occasionally useful.
module Data.Vector.V1

-- | The type of 1D vectors.
--   
--   Owing to its particularly simple structure, this type has more class
--   instances than 'propper' vectors have. Still, for the most part you'll
--   probably want to just use <a>Scalar</a> itself directly.
newtype Vector1
Vector1 :: Scalar -> Vector1
v1x :: Vector1 -> Scalar
instance Eq Vector1
instance Ord Vector1
instance Enum Vector1
instance Show Vector1
instance Num Vector1
instance Fractional Vector1
instance Vector Vector1
instance BasicVector Vector1


-- | 2-dimensional vectors with vector arithmetic.
module Data.Vector.V2
data Vector2
Vector2 :: {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> Vector2
v2x :: Vector2 -> {-# UNPACK #-} !Scalar
v2y :: Vector2 -> {-# UNPACK #-} !Scalar
instance Eq Vector2
instance Show Vector2
instance Vector Vector2
instance Fractional Vector2
instance Num Vector2
instance BasicVector Vector2


-- | 3-dimensional vectors with vector arithmetic.
module Data.Vector.V3
data Vector3
Vector3 :: {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> Vector3
v3x :: Vector3 -> {-# UNPACK #-} !Scalar
v3y :: Vector3 -> {-# UNPACK #-} !Scalar
v3z :: Vector3 -> {-# UNPACK #-} !Scalar

-- | Take the <i>cross product</i> of two 3D vectors. This produces a new
--   3D vector that is perpendicular to the plane of the first two vectors,
--   and who's length is equal to the sine of the angle between those
--   vectors multiplied by their lengths.
--   
--   Note that <tt>a `vcross` b = negate (b `vcross` a)</tt>.
vcross :: Vector3 -> Vector3 -> Vector3
instance Eq Vector3
instance Show Vector3
instance Vector Vector3
instance Fractional Vector3
instance Num Vector3
instance BasicVector Vector3


-- | 4-dimensional vectors with vector arithmetic.
module Data.Vector.V4
data Vector4
Vector4 :: {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> Vector4
v4x :: Vector4 -> {-# UNPACK #-} !Scalar
v4y :: Vector4 -> {-# UNPACK #-} !Scalar
v4z :: Vector4 -> {-# UNPACK #-} !Scalar
v4w :: Vector4 -> {-# UNPACK #-} !Scalar
instance Eq Vector4
instance Show Vector4
instance Vector Vector4
instance Fractional Vector4
instance Num Vector4
instance BasicVector Vector4


-- | 1-dimensional linear transformations.
module Data.Vector.Transform.T1

-- | The type of 1D linear transformations. Essentially, this is applying a
--   linear function to a number.
--   
--   Note the <tt>Monoid</tt> instance, which gives you access to the
--   identity transform (<tt>mempty</tt>) and the ability to combine a
--   series of transforms into a single transform (<tt>mappend</tt>).
data Transform1
Transform1 :: {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> Transform1
t1_XX :: Transform1 -> {-# UNPACK #-} !Scalar
t1_1X :: Transform1 -> {-# UNPACK #-} !Scalar

-- | Apply a 1D transformation to a 1D point, yielding a new 1D point.
transformP1 :: Transform1 -> Vector1 -> Vector1
instance Eq Transform1
instance Show Transform1
instance Monoid Transform1


-- | 2-dimensional linear transformations.
module Data.Vector.Transform.T2

-- | The type of 2D linear transformations.
--   
--   Note the <tt>Monoid</tt> instance, which gives you access to the
--   identity transform (<tt>mempty</tt>) and the ability to combine a
--   series of transforms into a single transform (<tt>mappend</tt>).
data Transform2
Transform2 :: {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> Transform2
t2_XX :: Transform2 -> {-# UNPACK #-} !Scalar
t2_YX :: Transform2 -> {-# UNPACK #-} !Scalar
t2_1X :: Transform2 -> {-# UNPACK #-} !Scalar
t2_XY :: Transform2 -> {-# UNPACK #-} !Scalar
t2_YY :: Transform2 -> {-# UNPACK #-} !Scalar
t2_1Y :: Transform2 -> {-# UNPACK #-} !Scalar

-- | Apply a 2D transformation to a 2D point, yielding a new 2D point.
transformP2 :: Transform2 -> Vector2 -> Vector2
instance Eq Transform2
instance Show Transform2
instance Monoid Transform2


-- | 3-dimensional linear transformations.
module Data.Vector.Transform.T3

-- | The type of 3D linear transformations.
--   
--   Note the <tt>Monoid</tt> instance, which gives you access to the
--   identity transform (<tt>mempty</tt>) and the ability to combine a
--   series of transforms into a single transform (<tt>mappend</tt>).
data Transform3
Transform3 :: {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> Transform3
t3_XX :: Transform3 -> {-# UNPACK #-} !Scalar
t3_YX :: Transform3 -> {-# UNPACK #-} !Scalar
t3_ZX :: Transform3 -> {-# UNPACK #-} !Scalar
t3_1X :: Transform3 -> {-# UNPACK #-} !Scalar
t3_XY :: Transform3 -> {-# UNPACK #-} !Scalar
t3_YY :: Transform3 -> {-# UNPACK #-} !Scalar
t3_ZY :: Transform3 -> {-# UNPACK #-} !Scalar
t3_1Y :: Transform3 -> {-# UNPACK #-} !Scalar
t3_XZ :: Transform3 -> {-# UNPACK #-} !Scalar
t3_YZ :: Transform3 -> {-# UNPACK #-} !Scalar
t3_ZZ :: Transform3 -> {-# UNPACK #-} !Scalar
t3_1Z :: Transform3 -> {-# UNPACK #-} !Scalar

-- | Apply a 3D transformation to a 3D point, yielding a new 3D point.
transformP3 :: Transform3 -> Vector3 -> Vector3
instance Eq Transform3
instance Show Transform3
instance Monoid Transform3


-- | 4-dimensional linear transformations.
module Data.Vector.Transform.T4

-- | The type of 4D linear transformations.
--   
--   Note the <tt>Monoid</tt> instance, which gives you access to the
--   identity transform (<tt>mempty</tt>) and the ability to combine a
--   series of transforms into a single transform (<tt>mappend</tt>).
data Transform4
Transform4 :: {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> Transform4
t4_XX :: Transform4 -> {-# UNPACK #-} !Scalar
t4_YX :: Transform4 -> {-# UNPACK #-} !Scalar
t4_ZX :: Transform4 -> {-# UNPACK #-} !Scalar
t4_WX :: Transform4 -> {-# UNPACK #-} !Scalar
t4_1X :: Transform4 -> {-# UNPACK #-} !Scalar
t4_XY :: Transform4 -> {-# UNPACK #-} !Scalar
t4_YY :: Transform4 -> {-# UNPACK #-} !Scalar
t4_ZY :: Transform4 -> {-# UNPACK #-} !Scalar
t4_WY :: Transform4 -> {-# UNPACK #-} !Scalar
t4_1Y :: Transform4 -> {-# UNPACK #-} !Scalar
t4_XZ :: Transform4 -> {-# UNPACK #-} !Scalar
t4_YZ :: Transform4 -> {-# UNPACK #-} !Scalar
t4_ZZ :: Transform4 -> {-# UNPACK #-} !Scalar
t4_WZ :: Transform4 -> {-# UNPACK #-} !Scalar
t4_1Z :: Transform4 -> {-# UNPACK #-} !Scalar
t4_XW :: Transform4 -> {-# UNPACK #-} !Scalar
t4_YW :: Transform4 -> {-# UNPACK #-} !Scalar
t4_ZW :: Transform4 -> {-# UNPACK #-} !Scalar
t4_WW :: Transform4 -> {-# UNPACK #-} !Scalar
t4_1W :: Transform4 -> {-# UNPACK #-} !Scalar

-- | Apply a 4D transformation to a 4D point, yielding a new 4D point.
transformP4 :: Transform4 -> Vector4 -> Vector4
instance Eq Transform4
instance Show Transform4
instance Monoid Transform4


-- | This module provides the <a>Range</a> type and several functions for
--   working with ranges.
module Data.BoundingBox.Range

-- | A <a>Range</a> represents a continuous interval between two
--   <a>Scalar</a> endpoints.
data Range
Range :: {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> Range
min_point :: Range -> {-# UNPACK #-} !Scalar
max_point :: Range -> {-# UNPACK #-} !Scalar

-- | Given two <a>Scalar</a>s, construct a <a>Range</a> (swapping the
--   endpoints if necessary so that they are in the correct order.
bound_corners :: Scalar -> Scalar -> Range

-- | Find the bounds of a list of points. (Throws an exception if the list
--   is empty.)
bound_points :: [Scalar] -> Range

-- | Test whether a given <a>Scalar</a> falls within a particular
--   <a>Range</a>.
within_bounds :: Scalar -> Range -> Bool

-- | Take the union of two ranges. The resulting <a>Range</a> contains all
--   points that the original ranges contained, plus any points between
--   them (if the original ranges don't overlap).
union :: Range -> Range -> Range

-- | Take the intersection of two ranges. If the ranges do not overlap, the
--   intersection is empty, and <a>Nothing</a> is returned. (This is a good
--   way to check whether two ranges overlap or not.) Otherwise a new
--   <a>Range</a> is returned that contains only the points common to both
--   ranges.
isect :: Range -> Range -> Maybe Range

-- | Efficiently compute the union of a list of ranges.
unions :: [Range] -> Range
instance Eq Range
instance Show Range


-- | This module provides the <a>BBox1</a> type (mainly for completeness).
module Data.BoundingBox.B1

-- | The <a>BBox1</a> type is basically a <tt>Range</tt>, but all the
--   operations over it work with <a>Vector1</a> (which is really
--   <a>Scalar</a>). While it's called a bounding <i>box</i>, a
--   1-dimensional box is in truth a simple line interval, just like
--   <tt>Range</tt>.
newtype BBox1
BBox1 :: Range -> BBox1
range :: BBox1 -> Range

-- | Given two vectors, construct a bounding box (swapping the endpoints if
--   necessary).
bound_corners :: Vector1 -> Vector1 -> BBox1

-- | Find the bounds of a list of points. (Throws an exception if the list
--   is empty.)
bound_points :: [Vector1] -> BBox1

-- | Test whether a <a>Vector1</a> lies within a <a>BBox1</a>.
within_bounds :: Vector1 -> BBox1 -> Bool

-- | Return the minimum endpoint for a <a>BBox1</a>.
min_point :: BBox1 -> Vector1

-- | Return the maximum endpoint for a <a>BBox1</a>.
max_point :: BBox1 -> Vector1

-- | Take the union of two <a>BBox1</a> values. The result is a new
--   <a>BBox1</a> that contains all the points the original boxes
--   contained, plus any extra space between them.
union :: BBox1 -> BBox1 -> BBox1

-- | Take the intersection of two <a>BBox1</a> values. If the boxes do not
--   overlap, return <a>Nothing</a>. Otherwise return a <a>BBox1</a>
--   containing only the points common to both argument boxes.
isect :: BBox1 -> BBox1 -> Maybe BBox1

-- | Efficiently compute the union of a list of bounding boxes.
unions :: [BBox1] -> BBox1
instance Eq BBox1
instance Show BBox1


-- | This module provides the <a>BBox2</a> type for 2-dimensional bounding
--   boxes.
module Data.BoundingBox.B2

-- | A <a>BBox2</a> is a 2D bounding box (aligned to the coordinate axies).
data BBox2
BBox2 :: {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> BBox2
minX :: BBox2 -> {-# UNPACK #-} !Scalar
minY :: BBox2 -> {-# UNPACK #-} !Scalar
maxX :: BBox2 -> {-# UNPACK #-} !Scalar
maxY :: BBox2 -> {-# UNPACK #-} !Scalar

-- | Return the X-range that this bounding box covers.
rangeX :: BBox2 -> Range

-- | Return the Y-range that this bounding box covers.
rangeY :: BBox2 -> Range

-- | Given ranges for each coordinate axis, construct a bounding box.
rangeXY :: Range -> Range -> BBox2

-- | Given a pair of corner points, construct a bounding box. (The points
--   must be from opposite corners, but it doesn't matter <i>which</i>
--   corners nor which order they are given in.)
bound_corners :: Vector2 -> Vector2 -> BBox2

-- | Find the bounds of a list of points. (Throws an exception if the list
--   is empty.)
bound_points :: [Vector2] -> BBox2

-- | Test whether a given 2D vector is inside this bounding box.
within_bounds :: Vector2 -> BBox2 -> Bool

-- | Return the minimum values for both coordinates. (In usual 2D space,
--   the bottom-left corner point.)
min_point :: BBox2 -> Vector2

-- | Return the maximum values for both coordinates. (In usual 2D space,
--   the top-right corner point.)
max_point :: BBox2 -> Vector2

-- | Take the union of two bounding boxes. The result is a new bounding box
--   that contains all the points the original boxes contained, plus any
--   extra space between them.
union :: BBox2 -> BBox2 -> BBox2

-- | Take the intersection of two bounding boxes. If the boxes do not
--   overlap, return <a>Nothing</a>. Otherwise return a new bounding box
--   containing only the points common to both argument boxes.
isect :: BBox2 -> BBox2 -> Maybe BBox2

-- | Efficiently compute the union of a list of bounding boxes.
unions :: [BBox2] -> BBox2
instance Eq BBox2
instance Show BBox2


-- | This module provides the <a>BBox3</a> type for 3-dimensional bounding
--   boxes ("bounding volumes").
module Data.BoundingBox.B3

-- | A <a>BBox3</a> is a 3D bounding box (aligned to the coordinate axies).
data BBox3
BBox3 :: {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> BBox3
minX :: BBox3 -> {-# UNPACK #-} !Scalar
minY :: BBox3 -> {-# UNPACK #-} !Scalar
minZ :: BBox3 -> {-# UNPACK #-} !Scalar
maxX :: BBox3 -> {-# UNPACK #-} !Scalar
maxY :: BBox3 -> {-# UNPACK #-} !Scalar
maxZ :: BBox3 -> {-# UNPACK #-} !Scalar

-- | Return the X-range that this bounding box covers.
rangeX :: BBox3 -> Range

-- | Return the Y-range that this bounding box covers.
rangeY :: BBox3 -> Range

-- | Return the Z-range that this bounding box covers.
rangeZ :: BBox3 -> Range

-- | Given ranges for each coordinate axis, construct a bounding box.
rangeXYZ :: Range -> Range -> Range -> BBox3

-- | Given a pair of corner points, construct a bounding box. (The points
--   must be from opposite corners, but it doesn't matter <i>which</i>
--   corners nor which order they are given in.)
bound_corners :: Vector3 -> Vector3 -> BBox3

-- | Find the bounds of a list of points. (Throws an exception if the list
--   is empty.)
bound_points :: [Vector3] -> BBox3

-- | Test whether a given 3D vector is inside this bounding box.
within_bounds :: Vector3 -> BBox3 -> Bool

-- | Return the minimum values for all coordinates.
min_point :: BBox3 -> Vector3

-- | Return the maximum values for all coordinates.
max_point :: BBox3 -> Vector3

-- | Take the union of two bounding boxes. The result is a new bounding box
--   that contains all the points the original boxes contained, plus any
--   extra space between them.
union :: BBox3 -> BBox3 -> BBox3

-- | Take the intersection of two bounding boxes. If the boxes do not
--   overlap, return <a>Nothing</a>. Otherwise return a new bounding box
--   containing only the points common to both argument boxes.
isect :: BBox3 -> BBox3 -> Maybe BBox3

-- | Efficiently compute the union of a list of bounding boxes.
unions :: [BBox3] -> BBox3
instance Eq BBox3
instance Show BBox3


-- | This module provides the <a>BBox4</a> type for 4-dimensional bounding
--   boxes (bounding hyper-volumes).
module Data.BoundingBox.B4

-- | A <a>BBox4</a> is a 4D bounding box (aligned to the coordinate axies).
data BBox4
BBox4 :: {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> {-# UNPACK #-} !Scalar -> BBox4
minX :: BBox4 -> {-# UNPACK #-} !Scalar
minY :: BBox4 -> {-# UNPACK #-} !Scalar
minZ :: BBox4 -> {-# UNPACK #-} !Scalar
minW :: BBox4 -> {-# UNPACK #-} !Scalar
maxX :: BBox4 -> {-# UNPACK #-} !Scalar
maxY :: BBox4 -> {-# UNPACK #-} !Scalar
maxZ :: BBox4 -> {-# UNPACK #-} !Scalar
maxW :: BBox4 -> {-# UNPACK #-} !Scalar

-- | Return the X-range that this bounding box covers.
rangeX :: BBox4 -> Range

-- | Return the Y-range that this bounding box covers.
rangeY :: BBox4 -> Range

-- | Return the Z-range that this bounding box covers.
rangeZ :: BBox4 -> Range

-- | Return the W-range (4th coordinate) that this bounding box covers.
rangeW :: BBox4 -> Range

-- | Given ranges for each coordinate axis, construct a bounding box.
rangeXYZW :: Range -> Range -> Range -> Range -> BBox4

-- | Given a pair of corner points, construct a bounding box. (The points
--   must be from opposite corners, but it doesn't matter <i>which</i>
--   corners nor which order they are given in.)
bound_corners :: Vector4 -> Vector4 -> BBox4

-- | Find the bounds of a list of points. (Throws an exception if the list
--   is empty.)
bound_points :: [Vector4] -> BBox4

-- | Test whether a given 4D vector is inside this bounding box.
within_bounds :: Vector4 -> BBox4 -> Bool

-- | Return the minimum values for all coordinates.
min_point :: BBox4 -> Vector4

-- | Return the maximum values for all coordinates.
max_point :: BBox4 -> Vector4

-- | Take the union of two bounding boxes. The result is a new bounding box
--   that contains all the points the original boxes contained, plus any
--   extra space between them.
union :: BBox4 -> BBox4 -> BBox4

-- | Take the intersection of two bounding boxes. If the boxes do not
--   overlap, return <a>Nothing</a>. Otherwise return a new bounding box
--   containing only the points common to both argument boxes.
isect :: BBox4 -> BBox4 -> Maybe BBox4

-- | Efficiently compute the union of a list of bounding boxes.
unions :: [BBox4] -> BBox4
instance Eq BBox4
instance Show BBox4
