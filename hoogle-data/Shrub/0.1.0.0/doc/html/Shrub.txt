-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | 4-way trie fuzzy search
--   
@package Shrub
@version 0.1.0.0

module Shrub
data Shrub a
Branch :: !(Shrub a) -> !(Shrub a) -> !(Shrub a) -> !(Shrub a) -> Shrub a
Leaf :: !a -> Shrub a
Empty :: Shrub a
addShrub :: Shrub a -> String -> a -> Shrub a
addShrubDegen :: Shrub a -> String -> a -> Shrub a
subtractMultiple :: Shrub a -> [String] -> Shrub a
subtractShrubDegen :: Shrub a -> String -> Shrub a
fromListDegen :: [(String, a)] -> Shrub a
fromList :: [(String, a)] -> Shrub a
searchShrub :: Eq b => Shrub b -> String -> Int -> [(Int, b)]
searchShrub' :: Shrub a -> String -> Int -> [(Int, a)]
perfMatch' :: Shrub a -> String -> Int -> [(Int, a)]
searchShrub'' :: Shrub a -> String -> Int -> Int -> [(Int, a)]

-- | Search Shrub with constraint to ignore a result
searchShrubNE :: Eq a => Shrub a -> String -> a -> Int -> Int -> [(Int, a)]

-- | Give you nid 1 cost indel, then remaining 2 cost indels
searchShrub3 :: Shrub a -> String -> Int -> Int -> [(Int, a)]

-- | Melting point shrub search
searchShrubTM :: Int -> Shrub a -> String -> Int -> [(Int, a)]
searchShrubPN :: Int -> Shrub a -> String -> Int -> [(Int, a)]
searchShrubTK :: Int -> Shrub a -> String -> Int -> [(Int, a)]
searchShrubTK2 :: Int -> Shrub a -> String -> Int -> Int -> [(Int, a)]
searchShrubTK3 :: Int -> Shrub a -> String -> Int -> Int -> [(Int, a)]
searchShrubXF :: Shrub a -> String -> Int -> Bool -> [(Int, a)]

-- | IonTorrent Shrub search
searchShrubIT :: Shrub a -> String -> Int -> [(Int, (a, String))]
nubMax :: (Ord a, Eq b) => [(a, b)] -> [(a, b)]
searchShrubCount :: Shrub a -> String -> Int -> [(Int, Int, a)]
instance Show a => Show (Shrub a)
