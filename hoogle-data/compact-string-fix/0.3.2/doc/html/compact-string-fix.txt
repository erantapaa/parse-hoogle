-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Same as compact-string except with a small fix so it builds on ghc-6.12
--   
--   Fast, packed, strict strings with a list interface. Based on
--   <a>Data.ByteString</a>. Multiple encodings are supported. This is the
--   same package as compact-string-0.3.1 except for a small fix to work
--   with the new Exception library. Once Twan updates that package, this
--   package will be deprecated.
@package compact-string-fix
@version 0.3.2


-- | Internal functions for the CompactString type.
module Data.CompactString.Internal

-- | A String using a compact, strict representation. A <tt>CompactString
--   a</tt> is encoded using encoding <tt>a</tt>, for example
--   <tt>CompactString <tt>UTF8</tt></tt>.
newtype CompactString a
CS :: ByteString -> CompactString a
unCS :: CompactString a -> ByteString
data Proxy a
encoding :: CompactString a -> Proxy a

-- | A way to encode characters into bytes
class Encoding a
pokeCharFun :: Encoding a => Proxy a -> Char -> (Int, Ptr Word8 -> IO ())
pokeCharLen :: Encoding a => Proxy a -> Char -> Int
pokeChar :: Encoding a => Proxy a -> Ptr Word8 -> Char -> IO Int
pokeCharRev :: Encoding a => Proxy a -> Ptr Word8 -> Char -> IO Int
peekChar :: Encoding a => Proxy a -> Ptr Word8 -> IO (Int, Char)
peekCharLen :: Encoding a => Proxy a -> Ptr Word8 -> IO Int
peekCharRev :: Encoding a => Proxy a -> Ptr Word8 -> IO (Int, Char)
peekCharLenRev :: Encoding a => Proxy a -> Ptr Word8 -> IO Int
peekCharSafe :: Encoding a => Proxy a -> Int -> Ptr Word8 -> IO (Int, Char)
validateLength :: Encoding a => Proxy a -> Int -> IO ()
copyChar :: Encoding a => Proxy a -> Ptr Word8 -> Ptr Word8 -> IO Int
copyCharRev :: Encoding a => Proxy a -> Ptr Word8 -> Ptr Word8 -> IO Int
containsASCII :: Encoding a => Proxy a -> Bool
validEquality :: Encoding a => Proxy a -> Bool
validOrdering :: Encoding a => Proxy a -> Bool
validSubstring :: Encoding a => Proxy a -> Bool
charCount :: Encoding a => Proxy a -> Int -> Int
byteCount :: Encoding a => Proxy a -> Int -> Int
newSize :: Encoding a => Proxy a -> Int -> Int
doUpLoop :: Encoding a => Proxy a -> AccEFL acc -> acc -> ImperativeLoop acc
doDownLoop :: Encoding a => Proxy a -> AccEFL acc -> acc -> ImperativeLoop acc
doUpLoopFold :: Encoding a => Proxy a -> FoldEFL acc -> acc -> ImperativeLoop_ acc
doDownLoopFold :: Encoding a => Proxy a -> FoldEFL acc -> acc -> ImperativeLoop_ acc
data PairS a b
(:*:) :: {-# UNPACK #-} !a -> {-# UNPACK #-} !b -> PairS a b
data MaybeS a
NothingS :: MaybeS a
JustS :: {-# UNPACK #-} !a -> MaybeS a
unSP :: PairS a b -> (a, b)

-- | Type of loop functions
type AccEFL acc = acc -> Char -> (PairS acc (MaybeS Char))
type FoldEFL acc = acc -> Char -> acc

-- | An imperative loop transforming a string, using an accumulating
--   parameter. See Data.ByteString.Fusion
type ImperativeLoop acc = Ptr Word8 -> Ptr Word8 -> Int -> IO (PairS (PairS acc Int) Int)

-- | ImperativeLoop with no output
type ImperativeLoop_ acc = Ptr Word8 -> Int -> IO acc

-- | A space-efficient representation of a Word8 vector, supporting many
--   efficient operations. A <a>ByteString</a> contains 8-bit characters
--   only.
--   
--   Instances of Eq, Ord, Read, Show, Data, Typeable
data ByteString :: *
PS :: {-# UNPACK #-} !ForeignPtr Word8 -> {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> ByteString
memcpy :: Ptr Word8 -> Ptr Word8 -> CSize -> IO ()

-- | Just like unsafePerformIO, but we inline it. Big performance gains as
--   it exposes lots of things to further inlining. <i>Very unsafe</i>. In
--   particular, you should do no memory allocation inside an
--   <a>inlinePerformIO</a> block. On Hugs this is just
--   <tt>unsafePerformIO</tt>.
inlinePerformIO :: IO a -> a

-- | Perform a function given a pointer to the buffer of a CompactString
withBuffer :: CompactString a -> (Ptr Word8 -> IO b) -> IO b

-- | Perform a function given a pointer to the last byte in the buffer of a
--   CompactString
withBufferEnd :: CompactString a -> (Ptr Word8 -> IO b) -> IO b

-- | Perform a function given a pointer to the buffer of a CompactString
unsafeWithBuffer :: CompactString a -> (Ptr Word8 -> IO b) -> b

-- | Perform a function given a pointer to the last byte in the buffer of a
--   CompactString
unsafeWithBufferEnd :: CompactString a -> (Ptr Word8 -> IO b) -> b
create :: Int -> (Ptr Word8 -> IO ()) -> IO (CompactString a)

-- | The <tt>Prelude.fromEnum</tt> method restricted to the type
--   <tt>Data.Char.Char</tt>.
ord :: Char -> Int
unsafeChr :: Int -> Char

-- | Safe variant of chr, combined with return; does more checks. At least
--   GHC does not check for surrogate pairs
returnChr :: Int -> Word32 -> IO (Int, Char)

-- | plusPtr that preserves the pointer type
plusPtr :: Ptr a -> Int -> Ptr a
peekByteOff :: Storable a => Ptr a -> Int -> IO a
pokeByteOff :: Storable a => Ptr a -> Int -> a -> IO ()

-- | Read a value from the given memory location.
--   
--   Note that the peek and poke functions might require properly aligned
--   addresses to function correctly. This is architecture dependent; thus,
--   portable code should ensure that when peeking or poking values of some
--   type <tt>a</tt>, the alignment constraint for <tt>a</tt>, as given by
--   the function <a>alignment</a> is fulfilled.
peek :: Storable a => Ptr a -> IO a

-- | Write the given value to the given memory location. Alignment
--   restrictions might apply; see <a>peek</a>.
poke :: Storable a => Ptr a -> a -> IO ()

-- | Fail with an error message including the module name and function
failMessage :: String -> String -> IO a

-- | Raise an errorr, with the message including the module name and
--   function
moduleError :: String -> String -> a
errorEmptyList :: String -> a

-- | Catch exceptions from fail in the IO monad, and wrap them in another
--   monad
unsafeTry :: MonadPlus m => IO a -> m a

-- | Catch exceptions from fail in the IO monad, and wrap them in another
--   monad
unsafeTryIO :: MonadPlus m => IO a -> IO (m a)


-- | Fusable loop functions, mirrors <a>Data.ByteString.Fusion</a>.
module Data.CompactString.Fusion
loopAcc :: (PairS acc arr) -> acc

-- | Projection functions that are fusion friendly (as in, we determine
--   when they are inlined)
loopArr :: (PairS acc arr) -> arr

-- | Data type for accumulators which can be ignored. The rewrite rules
--   rely on the fact that no bottoms of this type are ever constructed;
--   hence, we can assume <tt>(_ :: NoAcc) <a>seq</a> x = x</tt>.
data NoAcc
NoAcc :: NoAcc
foldEFL :: (acc -> Char -> acc) -> AccEFL acc
mapEFL :: (Char -> Char) -> AccEFL NoAcc
filterEFL :: (Char -> Bool) -> AccEFL NoAcc
scanEFL :: (Char -> Char -> Char) -> AccEFL Char

-- | Element function implementing a map and fold
mapAccumEFL :: (acc -> Char -> (acc, Char)) -> AccEFL acc

-- | Element function implementing a map with index
mapIndexEFL :: (Int -> Char -> Char) -> AccEFL Int
loopUp :: Encoding a => AccEFL acc -> acc -> CompactString a -> PairS acc (CompactString a)

-- | like loopUp, but the size of the buffer can only become smaller
loopUpC :: Encoding a => AccEFL acc -> acc -> CompactString a -> PairS acc (CompactString a)
loopDown :: Encoding a => AccEFL acc -> acc -> CompactString a -> PairS acc (CompactString a)
loopUpFold :: Encoding a => FoldEFL acc -> acc -> CompactString a -> acc
loopDownFold :: Encoding a => FoldEFL acc -> acc -> CompactString a -> acc


-- | Unsafe functions on <a>CompactString</a>s. All these functions can
--   lead to crashes if not used properly.
module Data.CompactString.Unsafe

-- | A variety of <a>head</a> for non-empty CompactString.
--   <a>unsafeHead</a> omits the check for the empty case, so there is an
--   obligation on the programmer to provide a proof that the CompactString
--   is non-empty.
unsafeHead :: Encoding a => CompactString a -> Char

-- | A variety of <a>last</a> for non-empty CompactString.
--   <a>unsafeLast</a> omits the check for the empty case, so there is an
--   obligation on the programmer to provide a proof that the CompactString
--   is non-empty.
unsafeLast :: Encoding a => CompactString a -> Char

-- | A variety of <a>tail</a> for non-empty CompactString.
--   <a>unsafeTail</a> omits the check for the empty case, so there is an
--   obligation on the programmer to provide a proof that the CompactString
--   is non-empty.
unsafeTail :: Encoding a => CompactString a -> CompactString a

-- | A variety of <a>init</a> for non-empty CompactString.
--   <a>unsafeInit</a> omits the check for the empty case, so there is an
--   obligation on the programmer to provide a proof that the CompactString
--   is non-empty.
unsafeInit :: Encoding a => CompactString a -> CompactString a

-- | Convert a ByteString to a CompactString, does not check whether the
--   ByteString represents a valid string in the encoding a.
unsafeFromByteString :: ByteString -> CompactString a


-- | Different encodings of characters into bytes.
module Data.CompactString.Encodings

-- | Tag representing the UTF-8 encoding. Use <tt><a>CompactString</a>
--   UTF8</tt> for UTF-8 encoded strings.
data UTF8
UTF8 :: UTF8

-- | Tag representing big endian encoding
data BE
BE :: BE

-- | Tag representing little endian encoding
data LE
LE :: LE

-- | The platform native endianness
type Native = LE

-- | Tag representing the UTF-16 encoding
data UTF16 endianness
UTF16 :: endianness -> UTF16 endianness

-- | Tag representing the big endian UTF-16 encoding, aka. UTF-16BE.
type UTF16BE = UTF16 BE

-- | Tag representing the little endian UTF-16 encoding, aka. UTF-16LE.
type UTF16LE = UTF16 LE

-- | Tag representing the platform native UTF-16 encoding.
type UTF16Native = UTF16 Native

-- | Tag representing the UTF-32 encoding
data UTF32 endianness
UTF32 :: endianness -> UTF32 endianness

-- | Tag representing the big endian UTF-32 encoding, aka. UTF-32BE.
type UTF32BE = UTF32 BE

-- | Tag representing the little endian UTF-32 encoding, aka. UTF-32LE.
type UTF32LE = UTF32 LE

-- | Tag representing the platform native UTF-32 encoding.
type UTF32Native = UTF32 Native

-- | Tag representing the ASCII encoding.
data ASCII
ASCII :: ASCII

-- | Tag representing the ISO 8859-1 encoding (latin 1).
data Latin1
Latin1 :: Latin1

-- | Tag representing a custom encoding optimized for memory usage.
--   
--   This encoding looks like UTF-8, but is slightly more efficient. It
--   requires at most 3 byes per character, as opposed to 4 for UTF-8.
--   
--   Encoding looks like:
--   
--   <pre>
--                     0zzzzzzz -&gt; 0zzzzzzz
--            00yyyyyy yzzzzzzz -&gt; 1xxxxxxx 1yyyyyyy
--   000xxxxx xxyyyyyy yzzzzzzz -&gt; 1xxxxxxx 0yyyyyyy 1zzzzzzz
--   </pre>
--   
--   The reasoning behind the tag bits is that this allows the char to be
--   read both forwards and backwards.
data Compact
Compact :: Compact
instance Encoding Compact
instance Encoding Latin1
instance Encoding ASCII
instance Endian e => Encoding (UTF32 e)
instance Endian e => Encoding (UTF16 e)
instance Endian LE
instance Endian BE
instance Encoding UTF8


-- | A time and space-efficient implementation of strings using packed
--   Word8 arrays, suitable for high performance use, both in terms of
--   large data quantities, or high speed requirements.
--   
--   This module is intended to be imported <tt>qualified</tt>, to avoid
--   name clashes with <a>Prelude</a> functions. eg.
--   
--   <pre>
--   import qualified Data.CompactString as C
--   </pre>
--   
--   Internally, CompactStrings are encoded <a>ByteString</a>s.
module Data.CompactString

-- | A way to encode characters into bytes
class Encoding a

-- | A String using a compact, strict representation. A <tt>CompactString
--   a</tt> is encoded using encoding <tt>a</tt>, for example
--   <tt>CompactString <tt>UTF8</tt></tt>.
data CompactString a

-- | <i>O(1)</i> The empty <a>CompactString</a>
empty :: CompactString a

-- | <i>O(1)</i> Convert a <a>Char</a> into a <a>CompactString</a>
singleton :: Encoding a => Char -> CompactString a

-- | <i>O(n)</i> Convert a <a>String</a> into a <a>CompactString</a>.
pack :: Encoding a => String -> CompactString a

-- | <i>O(n)</i> Converts a <a>CompactString</a> to a <a>String</a>.
unpack :: Encoding a => CompactString a -> String

-- | <i>O(n)</i> <a>cons</a> is analogous to (:) for lists, but of
--   different complexity, as it requires a memcpy.
cons :: Encoding a => Char -> CompactString a -> CompactString a

-- | <i>O(n)</i> Append a byte to the end of a <a>CompactString</a>
snoc :: Encoding a => CompactString a -> Char -> CompactString a

-- | <i>O(n)</i> Append two CompactStrings
append :: Encoding a => CompactString a -> CompactString a -> CompactString a

-- | <i>O(1)</i> Extract the first element of a CompactString, which must
--   be non-empty. An exception will be thrown in the case of an empty
--   CompactString.
head :: Encoding a => CompactString a -> Char

-- | <i>O(1)</i> Extract the last element of a ByteString, which must be
--   finite and non-empty. An exception will be thrown in the case of an
--   empty ByteString.
last :: Encoding a => CompactString a -> Char

-- | <i>O(1)</i> Extract the elements after the head of a CompactString,
--   which must be non-empty. An exception will be thrown in the case of an
--   empty CompactString.
tail :: Encoding a => CompactString a -> CompactString a

-- | <i>O(1)</i> Return all the elements of a <a>CompactString</a> except
--   the last one. An exception will be thrown in the case of an empty
--   ByteString.
init :: Encoding a => CompactString a -> CompactString a

-- | <i>O(1)</i> A view of the front of a <a>CompactString</a>.
--   
--   <pre>
--   headView s = if null s then Nothing else Just (head s, tail s)
--   </pre>
headView :: Encoding a => CompactString a -> Maybe (Char, CompactString a)

-- | <i>O(1)</i> A view of the back of a <a>CompactString</a>.
--   
--   <pre>
--   lastView s = if null s then Nothing else Just (init s, last s)
--   </pre>
lastView :: Encoding a => CompactString a -> Maybe (CompactString a, Char)

-- | <i>O(1)</i> Test whether a CompactString is empty.
null :: Encoding a => CompactString a -> Bool

-- | <i>O(n)</i> <a>length</a> returns the length of a CompactString as an
--   <a>Int</a>.
length :: Encoding a => CompactString a -> Int

-- | <i>O(n)</i> <a>map</a> <tt>f xs</tt> is the CompactString obtained by
--   applying <tt>f</tt> to each element of <tt>xs</tt>. This function is
--   subject to array fusion.
map :: Encoding a => (Char -> Char) -> CompactString a -> CompactString a

-- | Reverse a <a>CompactString</a>
reverse :: Encoding a => CompactString a -> CompactString a

-- | <i>O(n)</i> The <a>intersperse</a> function takes a <a>Char</a> and a
--   <a>CompactString</a> and `intersperses' that character between the
--   elements of the <a>CompactString</a>. It is analogous to the
--   intersperse function on Lists.
intersperse :: Encoding a => Char -> CompactString a -> CompactString a

-- | <i>O(n)</i> The <a>intercalate</a> function takes a
--   <a>CompactString</a> and a list of <a>CompactString</a>s and
--   concatenates the list after interspersing the first argument between
--   each element of the list.
intercalate :: Encoding a => CompactString a -> [CompactString a] -> CompactString a

-- | The <a>transpose</a> function transposes the rows and columns of its
--   <a>CompactString</a> argument.
transpose :: Encoding a => [CompactString a] -> [CompactString a]

-- | <a>foldl</a>, applied to a binary operator, a starting value
--   (typically the left-identity of the operator), and a CompactString,
--   reduces the CompactString using the binary operator, from left to
--   right. This function is subject to array fusion.
foldl :: Encoding a => (acc -> Char -> acc) -> acc -> CompactString a -> acc

-- | 'foldl\'' is like <a>foldl</a>, but strict in the accumulator. Though
--   actually foldl is also strict in the accumulator.
foldl' :: Encoding a => (acc -> Char -> acc) -> acc -> CompactString a -> acc

-- | <a>foldl1</a> is a variant of <a>foldl</a> that has no starting value
--   argument, and thus must be applied to non-empty <a>CompactString</a>.
--   This function is subject to array fusion. An exception will be thrown
--   in the case of an empty CompactString.
foldl1 :: Encoding a => (Char -> Char -> Char) -> CompactString a -> Char

-- | 'foldl1\'' is like <a>foldl1</a>, but strict in the accumulator. An
--   exception will be thrown in the case of an empty CompactString.
foldl1' :: Encoding a => (Char -> Char -> Char) -> CompactString a -> Char

-- | <a>foldr</a>, applied to a binary operator, a starting value
--   (typically the right-identity of the operator), and a CompactString,
--   reduces the CompactString using the binary operator, from right to
--   left.
foldr :: Encoding a => (Char -> acc -> acc) -> acc -> CompactString a -> acc

-- | <a>foldr</a>, applied to a binary operator, a starting value
--   (typically the right-identity of the operator), and a CompactString,
--   reduces the CompactString using the binary operator, from right to
--   left.
foldr' :: Encoding a => (Char -> acc -> acc) -> acc -> CompactString a -> acc

-- | <a>foldr1</a> is a variant of <a>foldr</a> that has no starting value
--   argument, and thus must be applied to non-empty <a>CompactString</a>s
--   An exception will be thrown in the case of an empty CompactString.
foldr1 :: Encoding a => (Char -> Char -> Char) -> CompactString a -> Char

-- | 'foldr1\'' is a variant of <a>foldr1</a>, but is strict in the
--   accumulator. An exception will be thrown in the case of an empty
--   CompactString.
foldr1' :: Encoding a => (Char -> Char -> Char) -> CompactString a -> Char

-- | <i>O(n)</i> Concatenate a list of <a>CompactString</a>s.
concat :: Encoding a => [CompactString a] -> CompactString a

-- | Map a function over a <a>CompactString</a> and concatenate the results
concatMap :: Encoding a => (Char -> CompactString a) -> CompactString a -> CompactString a

-- | <i>O(n)</i> Applied to a predicate and a CompactString, <a>any</a>
--   determines if any element of the <a>CompactString</a> satisfies the
--   predicate.
any :: Encoding a => (Char -> Bool) -> CompactString a -> Bool

-- | <i>O(n)</i> Applied to a predicate and a CompactString, <a>any</a>
--   determines if all elements of the <a>CompactString</a> satisfy the
--   predicate.
all :: Encoding a => (Char -> Bool) -> CompactString a -> Bool

-- | <i>O(n)</i> <a>maximum</a> returns the maximum value from a
--   <a>CompactString</a> An exception will be thrown in the case of an
--   empty CompactString.
maximum :: Encoding a => CompactString a -> Char

-- | <i>O(n)</i> <a>minimum</a> returns the minimum value from a
--   <a>CompactString</a> An exception will be thrown in the case of an
--   empty CompactString.
minimum :: Encoding a => CompactString a -> Char

-- | <a>scanl</a> is similar to <a>foldl</a>, but returns a list of
--   successive reduced values from the left. This function will fuse.
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs.
--   </pre>
scanl :: Encoding a => (Char -> Char -> Char) -> Char -> CompactString a -> CompactString a

-- | <a>scanl1</a> is a variant of <a>scanl</a> that has no starting value
--   argument. This function will fuse.
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
scanl1 :: Encoding a => (Char -> Char -> Char) -> CompactString a -> CompactString a

-- | scanr is the right-to-left dual of scanl.
scanr :: Encoding a => (Char -> Char -> Char) -> Char -> CompactString a -> CompactString a

-- | <a>scanr1</a> is a variant of <a>scanr</a> that has no starting value
--   argument.
scanr1 :: Encoding a => (Char -> Char -> Char) -> CompactString a -> CompactString a

-- | The <a>mapAccumL</a> function behaves like a combination of <a>map</a>
--   and <a>foldl</a>; it applies a function to each element of a
--   CompactString, passing an accumulating parameter from left to right,
--   and returning a final value of this accumulator together with the new
--   CompactString.
mapAccumL :: Encoding a => (acc -> Char -> (acc, Char)) -> acc -> CompactString a -> (acc, CompactString a)

-- | The <a>mapAccumR</a> function behaves like a combination of <a>map</a>
--   and <a>foldr</a>; it applies a function to each element of a
--   CompactString, passing an accumulating parameter from right to left,
--   and returning a final value of this accumulator together with the new
--   CompactString.
mapAccumR :: Encoding a => (acc -> Char -> (acc, Char)) -> acc -> CompactString a -> (acc, CompactString a)

-- | <i>O(n)</i> map Char functions, provided with the index at each
--   position.
mapIndexed :: Encoding a => (Int -> Char -> Char) -> CompactString a -> CompactString a

-- | <i>O(n)</i> <a>replicate</a> <tt>n x</tt> is a CompactString of length
--   <tt>n</tt> with <tt>x</tt> the value of every element. The following
--   holds:
--   
--   <pre>
--   replicate w c = unfoldr w (\u -&gt; Just (u,u)) c
--   </pre>
replicate :: Encoding a => Int -> Char -> CompactString a

-- | <i>O(n)</i>, where <i>n</i> is the length of the result. The
--   <a>unfoldr</a> function is analogous to the List 'unfoldr'.
--   <a>unfoldr</a> builds a ByteString from a seed value. The function
--   takes the element and returns <a>Nothing</a> if it is done producing
--   the CompactString or returns <a>Just</a> <tt>(a,b)</tt>, in which
--   case, <tt>a</tt> is the next byte in the string, and <tt>b</tt> is the
--   seed value for further production.
--   
--   Examples:
--   
--   <pre>
--      unfoldr (\x -&gt; if x &lt;= 5 then Just (x, x + 1) else Nothing) 0
--   == pack [0, 1, 2, 3, 4, 5]
--   </pre>
unfoldr :: Encoding a => (acc -> Maybe (Char, acc)) -> acc -> CompactString a

-- | <i>O(n)</i> Like <a>unfoldr</a>, <a>unfoldrN</a> builds a ByteString
--   from a seed value. However, the length of the result is limited by the
--   first argument to <a>unfoldrN</a>. This function is more efficient
--   than <a>unfoldr</a> when the maximum length of the result is known.
--   
--   The following equation relates <a>unfoldrN</a> and <a>unfoldr</a>:
--   
--   <pre>
--   fst (unfoldrN n f s) == take n (unfoldr f s)
--   </pre>
unfoldrN :: Encoding a => Int -> (acc -> Maybe (Char, acc)) -> acc -> (CompactString a, Maybe acc)

-- | <i>O(n)</i> <a>take</a> <tt>n</tt>, applied to a CompactString
--   <tt>xs</tt>, returns the prefix of <tt>xs</tt> of length <tt>n</tt>,
--   or <tt>xs</tt> itself if <tt>n &gt; <a>length</a> xs</tt>.
take :: Encoding a => Int -> CompactString a -> CompactString a

-- | <i>O(n)</i> <a>drop</a> <tt>n xs</tt> returns the suffix of
--   <tt>xs</tt> after the first <tt>n</tt> elements, or <tt>empty</tt> if
--   <tt>n &gt; <a>length</a> xs</tt>.
drop :: Encoding a => Int -> CompactString a -> CompactString a

-- | <i>O(n)</i> <a>splitAt</a> <tt>n xs</tt> is equivalent to
--   <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt>.
splitAt :: Encoding a => Int -> CompactString a -> (CompactString a, CompactString a)

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a
--   CompactString <tt>xs</tt>, returns the longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt>.
takeWhile :: Encoding a => (Char -> Bool) -> CompactString a -> CompactString a

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>.
dropWhile :: Encoding a => (Char -> Bool) -> CompactString a -> CompactString a

-- | <a>span</a> <tt>p xs</tt> breaks the ByteString into two segments. It
--   is equivalent to <tt>(<a>takeWhile</a> p xs, <a>dropWhile</a> p
--   xs)</tt>
span :: Encoding a => (Char -> Bool) -> CompactString a -> (CompactString a, CompactString a)

-- | <a>spanEnd</a> behaves like <a>span</a> but from the end of the
--   <a>CompactString</a>
--   
--   We have
--   
--   <pre>
--   spanEnd (not.isSpace) "x y z" == ("x y ","z")
--   </pre>
--   
--   and
--   
--   <pre>
--   spanEnd (not . isSpace) cs
--      == 
--   let (x,y) = span (not.isSpace) (reverse cs) in (reverse y, reverse x)
--   </pre>
spanEnd :: Encoding a => (Char -> Bool) -> CompactString a -> (CompactString a, CompactString a)

-- | <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: Encoding a => (Char -> Bool) -> CompactString a -> (CompactString a, CompactString a)

-- | <a>breakEnd</a> behaves like <a>break</a> but from the end of the
--   <a>CompactString</a>
--   
--   <pre>
--   breakEnd p == spanEnd (not.p)
--   </pre>
breakEnd :: Encoding a => (Char -> Bool) -> CompactString a -> (CompactString a, CompactString a)

-- | The <a>group</a> function takes a <a>CompactString</a> and returns a
--   list of CompactStrings such that the concatenation of the result is
--   equal to the argument. Moreover, each sublist in the result contains
--   only equal elements. For example,
--   
--   <pre>
--   group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
--   </pre>
--   
--   It is a special case of <a>groupBy</a>, which allows the programmer to
--   supply their own equality test.
group :: Encoding a => CompactString a -> [CompactString a]

-- | The <a>groupBy</a> function is the non-overloaded version of
--   <a>group</a>.
groupBy :: Encoding a => (Char -> Char -> Bool) -> CompactString a -> [CompactString a]

-- | <i>O(n)</i> Return all initial segments of the given
--   <a>CompactString</a>, shortest first.
inits :: Encoding a => CompactString a -> [CompactString a]

-- | <i>O(n)</i> Return all final segments of the given
--   <a>CompactString</a>, longest first.
tails :: Encoding a => CompactString a -> [CompactString a]

-- | <i>O(n)</i> Break a <a>ByteString</a> into pieces separated by the
--   byte argument, consuming the delimiter. I.e.
--   
--   <pre>
--   split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
--   split 'a'  "aXaXaXa"    == ["","X","X","X",""]
--   split 'x'  "x"          == ["",""]
--   </pre>
--   
--   and
--   
--   <pre>
--   intercalate [c] . split c == id
--   split == splitWith . (==)
--   </pre>
--   
--   As for all splitting functions in this library, this function does not
--   copy the substrings, it just constructs new <a>CompactString</a> that
--   are slices of the original.
split :: Encoding a => Char -> CompactString a -> [CompactString a]

-- | <i>O(n)</i> Splits a <a>CompactString</a> into components delimited by
--   separators, where the predicate returns True for a separator element.
--   The resulting components do not contain the separators. Two adjacent
--   separators result in an empty component in the output. eg.
--   
--   <pre>
--   splitWith (=='a') "aabbaca" == ["","","bb","c",""]
--   splitWith (=='a') []        == []
--   </pre>
splitWith :: Encoding a => (Char -> Bool) -> CompactString a -> [CompactString a]

-- | <a>lines</a> breaks a <a>CompactString</a> up into a list of
--   CompactStrings at newline Chars. The resulting strings do not contain
--   newlines.
lines :: Encoding a => CompactString a -> [CompactString a]

-- | <a>words</a> breaks a ByteString up into a list of words, which were
--   delimited by Chars representing white space. And
--   
--   <pre>
--   words = filter (not . null) . splitWith isSpace
--   </pre>
words :: Encoding a => CompactString a -> [CompactString a]

-- | <a>unlines</a> is an inverse operation to <a>lines</a>. It joins
--   lines, after appending a terminating newline to each.
unlines :: Encoding a => [CompactString a] -> CompactString a

-- | The <a>unwords</a> function is analogous to the <a>unlines</a>
--   function, on words.
unwords :: Encoding a => [CompactString a] -> CompactString a

-- | <i>O(n)</i> The <a>isPrefixOf</a> function takes two CompactString and
--   returns <a>True</a> iff the first is a prefix of the second.
isPrefixOf :: CompactString a -> CompactString a -> Bool

-- | <i>O(n)</i> The <a>isSuffixOf</a> function takes two CompactString and
--   returns <a>True</a> iff the first is a suffix of the second.
--   
--   The following holds:
--   
--   <pre>
--   isSuffixOf x y == reverse x `isPrefixOf` reverse y
--   </pre>
isSuffixOf :: Encoding a => CompactString a -> CompactString a -> Bool

-- | Check whether one string is a substring of another. <tt>isInfixOf p
--   s</tt> is equivalent to <tt>not (null (findSubstrings p s))</tt>.
isInfixOf :: Encoding a => CompactString a -> CompactString a -> Bool

-- | Get the first index of a substring in another string, or
--   <a>Nothing</a> if the string is not found. <tt>findSubstring p s</tt>
--   is equivalent to <tt>listToMaybe (findSubstrings p s)</tt>.
findSubstring :: Encoding a => CompactString a -> CompactString a -> Maybe Int

-- | Find the indexes of all (possibly overlapping) occurances of a
--   substring in a string. This function uses the Knuth-Morris-Pratt
--   string matching algorithm.
findSubstrings :: Encoding a => CompactString a -> CompactString a -> [Int]

-- | <i>O(n)</i> <a>elem</a> is the <a>CompactString</a> membership
--   predicate.
elem :: Encoding a => Char -> CompactString a -> Bool

-- | <i>O(n)</i> <a>notElem</a> is the inverse of <a>elem</a>
notElem :: Encoding a => Char -> CompactString a -> Bool

-- | <i>O(n)</i> The <a>find</a> function takes a predicate and a
--   <a>CompactString</a>, and returns the first element in matching the
--   predicate, or <a>Nothing</a> if there is no such element.
--   
--   <pre>
--   find f p = case findIndex f p of Just n -&gt; Just (p `index` n) ; _ -&gt; Nothing
--   </pre>
find :: Encoding a => (Char -> Bool) -> CompactString a -> Maybe Char

-- | <i>O(n)</i> <a>filter</a>, applied to a predicate and a
--   <a>CompactString</a>, returns a CompactString containing those
--   characters that satisfy the predicate. This function is subject to
--   array fusion.
filter :: Encoding a => (Char -> Bool) -> CompactString a -> CompactString a

-- | <i>O(n)</i> <a>partition</a>, applied to a predicate and a
--   <a>CompactString</a>, returns a pair of CompactStrings. The first
--   containing those characters that satisfy the predicate, the second
--   containg those that don't.
partition :: Encoding a => (Char -> Bool) -> CompactString a -> (CompactString a, CompactString a)

-- | <i>O(n)</i> <a>CompactString</a> index (subscript) operator, starting
--   from 0.
index :: Encoding a => CompactString a -> Int -> Char

-- | <i>O(n)</i> The <a>elemIndex</a> function returns the index of the
--   first element in the given <a>ByteString</a> which is equal to the
--   query element, or <a>Nothing</a> if there is no such element.
elemIndex :: Encoding a => Char -> CompactString a -> Maybe Int

-- | <i>O(n)</i> The <a>elemIndices</a> function extends <a>elemIndex</a>,
--   by returning the indices of all elements equal to the query element,
--   in ascending order.
elemIndices :: Encoding a => Char -> CompactString a -> [Int]

-- | <i>O(n)</i> The <a>elemIndexEnd</a> function returns the last index of
--   the element in the given <a>CompactString</a> which is equal to the
--   query element, or <a>Nothing</a> if there is no such element. The
--   following holds:
--   
--   <pre>
--   elemIndexEnd c xs == 
--   (-) (length xs - 1) `fmap` elemIndex c (reverse xs)
--   </pre>
elemIndexEnd :: Encoding a => Char -> CompactString a -> Maybe Int

-- | The <a>findIndex</a> function takes a predicate and a
--   <a>CompactString</a> and returns the index of the first element in the
--   CompactString satisfying the predicate.
findIndex :: Encoding a => (Char -> Bool) -> CompactString a -> Maybe Int

-- | <i>O(n)</i> The <a>findIndexEnd</a> function returns the last index of
--   the element in the given <a>CompactString</a> which satisfies the
--   predicate, or <a>Nothing</a> if there is no such element. The
--   following holds:
--   
--   <pre>
--   findIndexEnd c xs == 
--   (-) (length xs - 1) `fmap` findIndex c (reverse xs)
--   </pre>
findIndexEnd :: Encoding a => (Char -> Bool) -> CompactString a -> Maybe Int

-- | The <a>findIndices</a> function extends <a>findIndex</a>, by returning
--   the indices of all elements satisfying the predicate, in ascending
--   order.
findIndices :: Encoding a => (Char -> Bool) -> CompactString a -> [Int]

-- | count returns the number of times its argument appears in the
--   <a>CompactString</a>
--   
--   <pre>
--   count c = length . elemIndices c
--   </pre>
count :: Encoding a => Char -> CompactString a -> Int

-- | <i>O(n)</i> <a>zip</a> takes two ByteStrings and returns a list of
--   corresponding pairs of bytes. If one input ByteString is short, excess
--   elements of the longer ByteString are discarded. This is equivalent to
--   a pair of <a>unpack</a> operations.
zip :: Encoding a => CompactString a -> CompactString a -> [(Char, Char)]

-- | <a>zipWith</a> generalises <a>zip</a> by zipping with the function
--   given as the first argument, instead of a tupling function. For
--   example, <tt><a>zipWith</a> (+)</tt> is applied to two ByteStrings to
--   produce the list of corresponding sums.
zipWith :: Encoding a => (Char -> Char -> b) -> CompactString a -> CompactString a -> [b]

-- | A specialised version of <a>zipWith</a> for the common case of a
--   simultaneous map over two <a>CompactString</a>s, to build a 3rd.
--   Rewrite rules are used to automatically covert zipWith into zipWith'
--   when a pack is performed on the result of zipWith, but we also export
--   it for convenience.
zipWith' :: Encoding a => (Char -> Char -> Char) -> CompactString a -> CompactString a -> CompactString a

-- | <i>O(n)</i> <a>unzip</a> transforms a list of pairs of bytes into a
--   pair of CompactStrings. Note that this performs two <a>pack</a>
--   operations.
unzip :: Encoding a => [(Char, Char)] -> (CompactString a, CompactString a)

-- | <i>O(n log n)</i> Sort a CompactString
sort :: Encoding a => CompactString a -> CompactString a

-- | Compare two bytestrings, possibly with a different encoding.
compare' :: (Encoding a, Encoding b) => CompactString a -> CompactString b -> Ordering

-- | Convert a CompactString to a ByteString
toByteString :: Encoding a => CompactString a -> ByteString

-- | Convert a ByteString to a CompactString. Fails if the ByteString is
--   not a valid encoded string.
fromByteString :: (Encoding a, MonadPlus m) => ByteString -> m (CompactString a)

-- | Convert a ByteString to a CompactString. Raises an error if the
--   ByteString is not a valid encoded string.
fromByteString_ :: Encoding a => ByteString -> CompactString a

-- | Validates a CompactString. If the string is invalid, fails, otherwise
--   returns the input.
validate :: (Encoding a, MonadPlus m) => CompactString a -> m (CompactString a)

-- | Validates a CompactString. If the string is invalid, throws an error,
--   otherwise returns the input.
validate_ :: Encoding a => CompactString a -> CompactString a

-- | Convert between two different encodings, fails if conversion is not
--   possible.
recode :: (Encoding a, Encoding b, MonadPlus m) => CompactString a -> m (CompactString b)

-- | Convert between two different encodings, raises an error if conversion
--   is not possible.
recode_ :: (Encoding a, Encoding b) => CompactString a -> CompactString b

-- | Encode a CompactString to a ByteString using the given encoding.
--   
--   <pre>
--   encode e = liftM toByteString . recode
--   </pre>
--   
--   But it might be faster for some combinations of encodings.
--   
--   Fails if the string is cannot be encoded in the target encoding.
encode :: (Encoding a, Encoding e, MonadPlus m) => e -> CompactString a -> m ByteString

-- | Encode a CompactString to a ByteString using the given encoding.
--   
--   <pre>
--   encode_ e = toByteString . recode
--   </pre>
--   
--   But it might be faster for some combinations of encodings.
--   
--   Raises an error if the string is cannot be encoded in the target
--   encoding.
encode_ :: (Encoding a, Encoding e) => e -> CompactString a -> ByteString

-- | Decode a ByteString to a CompactString using the given encoding.
--   
--   <pre>
--   decode e = recode =&lt;&lt; fromByteString
--   </pre>
--   
--   but it might be faster for some combinations of encodings.
--   
--   Fails if the ByteString is not a valid encoded string or if the string
--   can not be represented in the encoding <tt>a</tt>.
decode :: (Encoding a, Encoding e, MonadPlus m) => e -> ByteString -> m (CompactString a)

-- | Decode a ByteString to a CompactString using the given encoding.
--   
--   <pre>
--   decode_ e = recode_ . fromByteString_
--   </pre>
--   
--   but it might be faster for some combinations of encodings.
--   
--   Raises an error if the ByteString is not a valid encoded string or if
--   the string can not be represented in the encoding <tt>a</tt>.
decode_ :: (Encoding a, Encoding e) => e -> ByteString -> CompactString a

-- | Encode a <a>CompactString</a> using the given encoding, and add a Byte
--   Order Mark. Byte Order Marks are common on Windows, but not on other
--   platforms.
--   
--   Fails if the string is cannot be encoded in the target encoding.
encodeBOM :: (Encoding a, Encoding e, MonadPlus m) => e -> CompactString a -> m ByteString

-- | Encode a <a>CompactString</a> using the given encoding, and add a Byte
--   Order Mark. Byte Order Marks are common on Windows, but not on other
--   platforms.
--   
--   Raises an error if the string is cannot be encoded in the target
--   encoding.
encodeBOM_ :: (Encoding a, Encoding e) => e -> CompactString a -> ByteString

-- | Decode a <a>ByteString</a> into a <a>CompactString</a>, by
--   investigating the Byte Order Mark. If there is no BOM assumes UTF-8.
--   Fails if the input is not a valid encoded string or if the string can
--   not be represented in the encoding <tt>a</tt>.
--   
--   For portability, this function should be prefered over <tt>decode
--   UTF8</tt> when reading files.
decodeBOM :: (Encoding a, MonadPlus m) => ByteString -> m (CompactString a)

-- | Decode a <a>ByteString</a> into a <a>CompactString</a>, by
--   investigating the Byte Order Mark. If there is no BOM assumes UTF-8.
--   Raises an error if the input is not a valid encoded string or if the
--   string can not be represented in the encoding <tt>a</tt>.
--   
--   For portability, this function should be prefered over <tt>decode
--   UTF8</tt> when reading files.
decodeBOM_ :: Encoding a => ByteString -> CompactString a

-- | Read a line from stdin.
getLine :: Encoding a => IO (CompactString a)

-- | getContents. Equivalent to <tt>hGetContents stdin</tt>
--   
--   Input is assumed to be in the encoding <tt>a</tt>, this may not be
--   appropriate.
getContents :: Encoding a => IO (CompactString a)

-- | Write a <a>CompactString</a> to stdout.
--   
--   Output is written in the encoding <tt>a</tt>, this may not be
--   appropriate.
putStr :: Encoding a => CompactString a -> IO ()

-- | Write a <a>CompactString</a> to stdout, appending a newline character.
--   
--   Output is written in the encoding <tt>a</tt>, this may not be
--   appropriate.
putStrLn :: Encoding a => CompactString a -> IO ()

-- | The interact function takes a function of type <tt>CompactString -&gt;
--   CompactString</tt> as its argument. The entire input from the standard
--   input device is passed to this function as its argument, and the
--   resulting string is output on the standard output device. It's great
--   for writing one line programs!
interact :: Encoding a => (CompactString a -> CompactString a) -> IO ()

-- | Read an entire file strictly into a <a>CompactString</a>. This is far
--   more efficient than reading the characters into a <a>String</a> and
--   then using <a>pack</a>. Files are read using 'text mode' on Windows.
--   
--   Files are assumed to be in the encoding <tt>a</tt>.
readFile :: Encoding a => FilePath -> IO (CompactString a)

-- | Read an entire file strictly into a <a>CompactString</a>. This is far
--   more efficient than reading the characters into a <a>String</a> and
--   then using <a>pack</a>. Files are read using 'text mode' on Windows.
--   
--   The encoding of the file is determined based on a Byte Order Mark, see
--   <a>decodeBOM</a>.
readFile' :: Encoding a => FilePath -> IO (CompactString a)

-- | Write a <a>CompactString</a> to a file.
--   
--   Files are written using the encoding <tt>a</tt>.
writeFile :: Encoding a => FilePath -> CompactString a -> IO ()

-- | Write a <a>CompactString</a> to a file.
--   
--   Files are written using the encoding <tt>a</tt>. A Byte Order Mark is
--   also written.
writeFile' :: Encoding a => FilePath -> CompactString a -> IO ()

-- | Append a <a>CompactString</a> to a file.
--   
--   Files are written using the encoding <tt>a</tt>.
appendFile :: Encoding a => FilePath -> CompactString a -> IO ()

-- | Append a <a>CompactString</a> to a file.
--   
--   The encoding of the file is determined based on a Byte Order Mark. If
--   the file is empty, it is written using the encoding <tt>a</tt> with a
--   Byte Order Mark. If the encoding can not be determined the file is
--   assumed to be UTF-8.
appendFile' :: Encoding a => FilePath -> CompactString a -> IO ()

-- | Read a line from a handle
hGetLine :: Encoding a => Handle -> IO (CompactString a)

-- | Read entire handle contents into a <a>CompactString</a>.
--   
--   The handle is interpreted as the encoding <tt>a</tt>.
hGetContents :: Encoding a => Handle -> IO (CompactString a)

-- | Read entire handle contents into a <a>CompactString</a>.
--   
--   The encoding is determined based on a Byte Order Mark, see
--   <a>decodeBOM</a>.
hGetContents' :: Encoding a => Handle -> IO (CompactString a)

-- | Read a <a>CompactString</a> directly from the specified <a>Handle</a>.
--   
--   The handle is interpreted as the encoding <tt>a</tt>.
hGet :: Encoding a => Handle -> Int -> IO (CompactString a)

-- | hGetNonBlocking is identical to <a>hGet</a>, except that it will never
--   block waiting for data to become available, instead it returns only
--   whatever data is available.
--   
--   The handle is interpreted as the encoding <tt>a</tt>.
hGetNonBlocking :: Encoding a => Handle -> Int -> IO (CompactString a)

-- | Outputs a <a>CompactString</a> to the specified <a>Handle</a>.
--   
--   Output is written in the encoding <tt>a</tt>.
hPut :: Encoding a => Handle -> CompactString a -> IO ()

-- | A synonym for <tt>hPut</tt>, for compatibility
hPutStr :: Encoding a => Handle -> CompactString a -> IO ()

-- | Write a <a>CompactString</a> to a handle, appending a newline byte
--   
--   Output is written in the encoding <tt>a</tt>.
hPutStrLn :: Encoding a => Handle -> CompactString a -> IO ()
instance Encoding a => IsString (CompactString a)
instance Encoding a => Show (CompactString a)
instance Encoding a => Ord (CompactString a)
instance Encoding a => Monoid (CompactString a)
instance Encoding a => Eq (CompactString a)


-- | CompactString specialized to ASCII. Note that not all characters can
--   be encoded in ASCII, if encoding is not possible the function will
--   raise an error..
--   
--   This module can be used to reduce the need for type signatures, since
--   in most cases only a single encoding is used.
module Data.CompactString.ASCII

-- | CompactString specialized to ASCII.
type CompactString = CompactString ASCII

-- | <i>O(1)</i> The empty <a>CompactString</a>
empty :: CompactString

-- | <i>O(1)</i> Convert a <a>Char</a> into a <a>CompactString</a>
singleton :: Char -> CompactString

-- | <i>O(n)</i> Convert a <a>String</a> into a <a>CompactString</a>.
pack :: String -> CompactString

-- | <i>O(n)</i> Converts a <a>CompactString</a> to a <a>String</a>.
unpack :: CompactString -> String

-- | <i>O(n)</i> <a>cons</a> is analogous to (:) for lists, but of
--   different complexity, as it requires a memcpy.
cons :: Char -> CompactString -> CompactString

-- | <i>O(n)</i> Append a byte to the end of a <a>CompactString</a>
snoc :: CompactString -> Char -> CompactString

-- | <i>O(n)</i> Append two CompactStrings
append :: CompactString -> CompactString -> CompactString

-- | <i>O(1)</i> Extract the first element of a CompactString, which must
--   be non-empty. An exception will be thrown in the case of an empty
--   CompactString.
head :: CompactString -> Char

-- | <i>O(1)</i> Extract the last element of a ByteString, which must be
--   finite and non-empty. An exception will be thrown in the case of an
--   empty ByteString.
last :: CompactString -> Char

-- | <i>O(1)</i> Extract the elements after the head of a CompactString,
--   which must be non-empty. An exception will be thrown in the case of an
--   empty CompactString.
tail :: CompactString -> CompactString

-- | <i>O(1)</i> Return all the elements of a <a>CompactString</a> except
--   the last one. An exception will be thrown in the case of an empty
--   ByteString.
init :: CompactString -> CompactString

-- | <i>O(1)</i> A view of the front of a <a>CompactString</a>.
--   
--   <pre>
--   headView s = if null s then Nothing else Just (head s, tail s)
--   </pre>
headView :: CompactString -> Maybe (Char, CompactString)

-- | <i>O(1)</i> A view of the back of a <a>CompactString</a>.
--   
--   <pre>
--   lastView s = if null s then Nothing else Just (init s, last s)
--   </pre>
lastView :: CompactString -> Maybe (CompactString, Char)

-- | <i>O(1)</i> Test whether a CompactString is empty.
null :: CompactString -> Bool

-- | <i>O(n)</i> <a>length</a> returns the length of a CompactString as an
--   <a>Int</a>.
length :: CompactString -> Int

-- | <i>O(n)</i> <a>map</a> <tt>f xs</tt> is the CompactString obtained by
--   applying <tt>f</tt> to each element of <tt>xs</tt>. This function is
--   subject to array fusion.
map :: (Char -> Char) -> CompactString -> CompactString

-- | Reverse a <a>CompactString</a>
reverse :: CompactString -> CompactString

-- | <i>O(n)</i> The <a>intersperse</a> function takes a <a>Char</a> and a
--   <a>CompactString</a> and `intersperses' that character between the
--   elements of the <a>CompactString</a>. It is analogous to the
--   intersperse function on Lists.
intersperse :: Char -> CompactString -> CompactString

-- | <i>O(n)</i> The <a>intercalate</a> function takes a
--   <a>CompactString</a> and a list of <a>CompactString</a>s and
--   concatenates the list after interspersing the first argument between
--   each element of the list.
intercalate :: CompactString -> [CompactString] -> CompactString

-- | The <a>transpose</a> function transposes the rows and columns of its
--   <a>CompactString</a> argument.
transpose :: [CompactString] -> [CompactString]

-- | <a>foldl</a>, applied to a binary operator, a starting value
--   (typically the left-identity of the operator), and a CompactString,
--   reduces the CompactString using the binary operator, from left to
--   right. This function is subject to array fusion.
foldl :: (acc -> Char -> acc) -> acc -> CompactString -> acc

-- | 'foldl\'' is like <a>foldl</a>, but strict in the accumulator. Though
--   actually foldl is also strict in the accumulator.
foldl' :: (acc -> Char -> acc) -> acc -> CompactString -> acc

-- | <a>foldl1</a> is a variant of <a>foldl</a> that has no starting value
--   argument, and thus must be applied to non-empty <a>CompactString</a>.
--   This function is subject to array fusion. An exception will be thrown
--   in the case of an empty CompactString.
foldl1 :: (Char -> Char -> Char) -> CompactString -> Char

-- | 'foldl1\'' is like <a>foldl1</a>, but strict in the accumulator. An
--   exception will be thrown in the case of an empty CompactString.
foldl1' :: (Char -> Char -> Char) -> CompactString -> Char

-- | <a>foldr</a>, applied to a binary operator, a starting value
--   (typically the right-identity of the operator), and a CompactString,
--   reduces the CompactString using the binary operator, from right to
--   left.
foldr :: (Char -> acc -> acc) -> acc -> CompactString -> acc

-- | <a>foldr</a>, applied to a binary operator, a starting value
--   (typically the right-identity of the operator), and a CompactString,
--   reduces the CompactString using the binary operator, from right to
--   left.
foldr' :: (Char -> acc -> acc) -> acc -> CompactString -> acc

-- | <a>foldr1</a> is a variant of <a>foldr</a> that has no starting value
--   argument, and thus must be applied to non-empty <a>CompactString</a>s
--   An exception will be thrown in the case of an empty CompactString.
foldr1 :: (Char -> Char -> Char) -> CompactString -> Char

-- | 'foldr1\'' is a variant of <a>foldr1</a>, but is strict in the
--   accumulator. An exception will be thrown in the case of an empty
--   CompactString.
foldr1' :: (Char -> Char -> Char) -> CompactString -> Char

-- | <i>O(n)</i> Concatenate a list of <a>CompactString</a>s.
concat :: [CompactString] -> CompactString

-- | Map a function over a <a>CompactString</a> and concatenate the results
concatMap :: (Char -> CompactString) -> CompactString -> CompactString

-- | <i>O(n)</i> Applied to a predicate and a CompactString, <a>any</a>
--   determines if any element of the <a>CompactString</a> satisfies the
--   predicate.
any :: (Char -> Bool) -> CompactString -> Bool

-- | <i>O(n)</i> Applied to a predicate and a CompactString, <a>any</a>
--   determines if all elements of the <a>CompactString</a> satisfy the
--   predicate.
all :: (Char -> Bool) -> CompactString -> Bool

-- | <i>O(n)</i> <a>maximum</a> returns the maximum value from a
--   <a>CompactString</a> An exception will be thrown in the case of an
--   empty CompactString.
maximum :: CompactString -> Char

-- | <i>O(n)</i> <a>minimum</a> returns the minimum value from a
--   <a>CompactString</a> An exception will be thrown in the case of an
--   empty CompactString.
minimum :: CompactString -> Char

-- | <a>scanl</a> is similar to <a>foldl</a>, but returns a list of
--   successive reduced values from the left. This function will fuse.
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs.
--   </pre>
scanl :: (Char -> Char -> Char) -> Char -> CompactString -> CompactString

-- | <a>scanl1</a> is a variant of <a>scanl</a> that has no starting value
--   argument. This function will fuse.
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
scanl1 :: (Char -> Char -> Char) -> CompactString -> CompactString

-- | scanr is the right-to-left dual of scanl.
scanr :: (Char -> Char -> Char) -> Char -> CompactString -> CompactString

-- | <a>scanr1</a> is a variant of <a>scanr</a> that has no starting value
--   argument.
scanr1 :: (Char -> Char -> Char) -> CompactString -> CompactString

-- | The <a>mapAccumL</a> function behaves like a combination of <a>map</a>
--   and <a>foldl</a>; it applies a function to each element of a
--   CompactString, passing an accumulating parameter from left to right,
--   and returning a final value of this accumulator together with the new
--   CompactString.
mapAccumL :: (acc -> Char -> (acc, Char)) -> acc -> CompactString -> (acc, CompactString)

-- | The <a>mapAccumR</a> function behaves like a combination of <a>map</a>
--   and <a>foldr</a>; it applies a function to each element of a
--   CompactString, passing an accumulating parameter from right to left,
--   and returning a final value of this accumulator together with the new
--   CompactString.
mapAccumR :: (acc -> Char -> (acc, Char)) -> acc -> CompactString -> (acc, CompactString)

-- | <i>O(n)</i> map Char functions, provided with the index at each
--   position.
mapIndexed :: (Int -> Char -> Char) -> CompactString -> CompactString

-- | <i>O(n)</i> <a>replicate</a> <tt>n x</tt> is a CompactString of length
--   <tt>n</tt> with <tt>x</tt> the value of every element. The following
--   holds:
--   
--   <pre>
--   replicate w c = unfoldr w (\u -&gt; Just (u,u)) c
--   </pre>
replicate :: Int -> Char -> CompactString

-- | <i>O(n)</i>, where <i>n</i> is the length of the result. The
--   <a>unfoldr</a> function is analogous to the List 'unfoldr'.
--   <a>unfoldr</a> builds a ByteString from a seed value. The function
--   takes the element and returns <a>Nothing</a> if it is done producing
--   the CompactString or returns <a>Just</a> <tt>(a,b)</tt>, in which
--   case, <tt>a</tt> is the next byte in the string, and <tt>b</tt> is the
--   seed value for further production.
--   
--   Examples:
--   
--   <pre>
--      unfoldr (\x -&gt; if x &lt;= 5 then Just (x, x + 1) else Nothing) 0
--   == pack [0, 1, 2, 3, 4, 5]
--   </pre>
unfoldr :: (acc -> Maybe (Char, acc)) -> acc -> CompactString

-- | <i>O(n)</i> Like <a>unfoldr</a>, <a>unfoldrN</a> builds a ByteString
--   from a seed value. However, the length of the result is limited by the
--   first argument to <a>unfoldrN</a>. This function is more efficient
--   than <a>unfoldr</a> when the maximum length of the result is known.
--   
--   The following equation relates <a>unfoldrN</a> and <a>unfoldr</a>:
--   
--   <pre>
--   fst (unfoldrN n f s) == take n (unfoldr f s)
--   </pre>
unfoldrN :: Int -> (acc -> Maybe (Char, acc)) -> acc -> (CompactString, Maybe acc)

-- | <i>O(n)</i> <a>take</a> <tt>n</tt>, applied to a CompactString
--   <tt>xs</tt>, returns the prefix of <tt>xs</tt> of length <tt>n</tt>,
--   or <tt>xs</tt> itself if <tt>n &gt; <a>length</a> xs</tt>.
take :: Int -> CompactString -> CompactString

-- | <i>O(n)</i> <a>drop</a> <tt>n xs</tt> returns the suffix of
--   <tt>xs</tt> after the first <tt>n</tt> elements, or <tt>empty</tt> if
--   <tt>n &gt; <a>length</a> xs</tt>.
drop :: Int -> CompactString -> CompactString

-- | <i>O(n)</i> <a>splitAt</a> <tt>n xs</tt> is equivalent to
--   <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt>.
splitAt :: Int -> CompactString -> (CompactString, CompactString)

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a
--   CompactString <tt>xs</tt>, returns the longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt>.
takeWhile :: (Char -> Bool) -> CompactString -> CompactString

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>.
dropWhile :: (Char -> Bool) -> CompactString -> CompactString

-- | <a>span</a> <tt>p xs</tt> breaks the ByteString into two segments. It
--   is equivalent to <tt>(<a>takeWhile</a> p xs, <a>dropWhile</a> p
--   xs)</tt>
span :: (Char -> Bool) -> CompactString -> (CompactString, CompactString)

-- | <a>spanEnd</a> behaves like <a>span</a> but from the end of the
--   <a>CompactString</a>
--   
--   We have
--   
--   <pre>
--   spanEnd (not.isSpace) "x y z" == ("x y ","z")
--   </pre>
--   
--   and
--   
--   <pre>
--   spanEnd (not . isSpace) cs
--      == 
--   let (x,y) = span (not.isSpace) (reverse cs) in (reverse y, reverse x)
--   </pre>
spanEnd :: (Char -> Bool) -> CompactString -> (CompactString, CompactString)

-- | <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (Char -> Bool) -> CompactString -> (CompactString, CompactString)

-- | <a>breakEnd</a> behaves like <a>break</a> but from the end of the
--   <a>CompactString</a>
--   
--   <pre>
--   breakEnd p == spanEnd (not.p)
--   </pre>
breakEnd :: (Char -> Bool) -> CompactString -> (CompactString, CompactString)

-- | The <a>group</a> function takes a <a>CompactString</a> and returns a
--   list of CompactStrings such that the concatenation of the result is
--   equal to the argument. Moreover, each sublist in the result contains
--   only equal elements. For example,
--   
--   <pre>
--   group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
--   </pre>
--   
--   It is a special case of <a>groupBy</a>, which allows the programmer to
--   supply their own equality test.
group :: CompactString -> [CompactString]

-- | The <a>groupBy</a> function is the non-overloaded version of
--   <a>group</a>.
groupBy :: (Char -> Char -> Bool) -> CompactString -> [CompactString]

-- | <i>O(n)</i> Return all initial segments of the given
--   <a>CompactString</a>, shortest first.
inits :: CompactString -> [CompactString]

-- | <i>O(n)</i> Return all final segments of the given
--   <a>CompactString</a>, longest first.
tails :: CompactString -> [CompactString]

-- | <i>O(n)</i> Break a <a>ByteString</a> into pieces separated by the
--   byte argument, consuming the delimiter. I.e.
--   
--   <pre>
--   split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
--   split 'a'  "aXaXaXa"    == ["","X","X","X",""]
--   split 'x'  "x"          == ["",""]
--   </pre>
--   
--   and
--   
--   <pre>
--   intercalate [c] . split c == id
--   split == splitWith . (==)
--   </pre>
--   
--   As for all splitting functions in this library, this function does not
--   copy the substrings, it just constructs new <a>CompactString</a> that
--   are slices of the original.
split :: Char -> CompactString -> [CompactString]

-- | <i>O(n)</i> Splits a <a>CompactString</a> into components delimited by
--   separators, where the predicate returns True for a separator element.
--   The resulting components do not contain the separators. Two adjacent
--   separators result in an empty component in the output. eg.
--   
--   <pre>
--   splitWith (=='a') "aabbaca" == ["","","bb","c",""]
--   splitWith (=='a') []        == []
--   </pre>
splitWith :: (Char -> Bool) -> CompactString -> [CompactString]

-- | <a>lines</a> breaks a <a>CompactString</a> up into a list of
--   CompactStrings at newline Chars. The resulting strings do not contain
--   newlines.
lines :: CompactString -> [CompactString]

-- | <a>words</a> breaks a ByteString up into a list of words, which were
--   delimited by Chars representing white space. And
--   
--   <pre>
--   words = filter (not . null) . splitWith isSpace
--   </pre>
words :: CompactString -> [CompactString]

-- | <a>unlines</a> is an inverse operation to <a>lines</a>. It joins
--   lines, after appending a terminating newline to each.
unlines :: [CompactString] -> CompactString

-- | The <a>unwords</a> function is analogous to the <a>unlines</a>
--   function, on words.
unwords :: [CompactString] -> CompactString

-- | <i>O(n)</i> The <a>isPrefixOf</a> function takes two CompactString and
--   returns <a>True</a> iff the first is a prefix of the second.
isPrefixOf :: CompactString -> CompactString -> Bool

-- | <i>O(n)</i> The <a>isSuffixOf</a> function takes two CompactString and
--   returns <a>True</a> iff the first is a suffix of the second.
--   
--   The following holds:
--   
--   <pre>
--   isSuffixOf x y == reverse x `isPrefixOf` reverse y
--   </pre>
isSuffixOf :: CompactString -> CompactString -> Bool

-- | Check whether one string is a substring of another. <tt>isInfixOf p
--   s</tt> is equivalent to <tt>not (null (findSubstrings p s))</tt>.
isInfixOf :: CompactString -> CompactString -> Bool

-- | Get the first index of a substring in another string, or
--   <a>Nothing</a> if the string is not found. <tt>findSubstring p s</tt>
--   is equivalent to <tt>listToMaybe (findSubstrings p s)</tt>.
findSubstring :: CompactString -> CompactString -> Maybe Int

-- | Find the indexes of all (possibly overlapping) occurances of a
--   substring in a string. This function uses the Knuth-Morris-Pratt
--   string matching algorithm.
findSubstrings :: CompactString -> CompactString -> [Int]

-- | <i>O(n)</i> <a>elem</a> is the <a>CompactString</a> membership
--   predicate.
elem :: Char -> CompactString -> Bool

-- | <i>O(n)</i> <a>notElem</a> is the inverse of <a>elem</a>
notElem :: Char -> CompactString -> Bool

-- | <i>O(n)</i> The <a>find</a> function takes a predicate and a
--   <a>CompactString</a>, and returns the first element in matching the
--   predicate, or <a>Nothing</a> if there is no such element.
--   
--   <pre>
--   find f p = case findIndex f p of Just n -&gt; Just (p `index` n) ; _ -&gt; Nothing
--   </pre>
find :: (Char -> Bool) -> CompactString -> Maybe Char

-- | <i>O(n)</i> <a>filter</a>, applied to a predicate and a
--   <a>CompactString</a>, returns a CompactString containing those
--   characters that satisfy the predicate. This function is subject to
--   array fusion.
filter :: (Char -> Bool) -> CompactString -> CompactString

-- | <i>O(n)</i> <a>partition</a>, applied to a predicate and a
--   <a>CompactString</a>, returns a pair of CompactStrings. The first
--   containing those characters that satisfy the predicate, the second
--   containg those that don't.
partition :: (Char -> Bool) -> CompactString -> (CompactString, CompactString)

-- | <i>O(n)</i> <a>CompactString</a> index (subscript) operator, starting
--   from 0.
index :: CompactString -> Int -> Char

-- | <i>O(n)</i> The <a>elemIndex</a> function returns the index of the
--   first element in the given <a>ByteString</a> which is equal to the
--   query element, or <a>Nothing</a> if there is no such element.
elemIndex :: Char -> CompactString -> Maybe Int

-- | <i>O(n)</i> The <a>elemIndices</a> function extends <a>elemIndex</a>,
--   by returning the indices of all elements equal to the query element,
--   in ascending order.
elemIndices :: Char -> CompactString -> [Int]

-- | <i>O(n)</i> The <a>elemIndexEnd</a> function returns the last index of
--   the element in the given <a>CompactString</a> which is equal to the
--   query element, or <a>Nothing</a> if there is no such element. The
--   following holds:
--   
--   <pre>
--   elemIndexEnd c xs == 
--   (-) (length xs - 1) `fmap` elemIndex c (reverse xs)
--   </pre>
elemIndexEnd :: Char -> CompactString -> Maybe Int

-- | The <a>findIndex</a> function takes a predicate and a
--   <a>CompactString</a> and returns the index of the first element in the
--   CompactString satisfying the predicate.
findIndex :: (Char -> Bool) -> CompactString -> Maybe Int

-- | <i>O(n)</i> The <a>findIndexEnd</a> function returns the last index of
--   the element in the given <a>CompactString</a> which satisfies the
--   predicate, or <a>Nothing</a> if there is no such element. The
--   following holds:
--   
--   <pre>
--   findIndexEnd c xs == 
--   (-) (length xs - 1) `fmap` findIndex c (reverse xs)
--   </pre>
findIndexEnd :: (Char -> Bool) -> CompactString -> Maybe Int

-- | The <a>findIndices</a> function extends <a>findIndex</a>, by returning
--   the indices of all elements satisfying the predicate, in ascending
--   order.
findIndices :: (Char -> Bool) -> CompactString -> [Int]

-- | count returns the number of times its argument appears in the
--   <a>CompactString</a>
--   
--   <pre>
--   count c = length . elemIndices c
--   </pre>
count :: Char -> CompactString -> Int

-- | <i>O(n)</i> <a>zip</a> takes two ByteStrings and returns a list of
--   corresponding pairs of bytes. If one input ByteString is short, excess
--   elements of the longer ByteString are discarded. This is equivalent to
--   a pair of <a>unpack</a> operations.
zip :: CompactString -> CompactString -> [(Char, Char)]

-- | <a>zipWith</a> generalises <a>zip</a> by zipping with the function
--   given as the first argument, instead of a tupling function. For
--   example, <tt><a>zipWith</a> (+)</tt> is applied to two ByteStrings to
--   produce the list of corresponding sums.
zipWith :: (Char -> Char -> b) -> CompactString -> CompactString -> [b]

-- | A specialised version of <a>zipWith</a> for the common case of a
--   simultaneous map over two <a>CompactString</a>s, to build a 3rd.
--   Rewrite rules are used to automatically covert zipWith into zipWith'
--   when a pack is performed on the result of zipWith, but we also export
--   it for convenience.
zipWith' :: (Char -> Char -> Char) -> CompactString -> CompactString -> CompactString

-- | <i>O(n)</i> <a>unzip</a> transforms a list of pairs of bytes into a
--   pair of CompactStrings. Note that this performs two <a>pack</a>
--   operations.
unzip :: [(Char, Char)] -> (CompactString, CompactString)

-- | <i>O(n log n)</i> Sort a CompactString
sort :: CompactString -> CompactString

-- | Convert a CompactString to a ByteString
toByteString :: CompactString -> ByteString

-- | Convert a ByteString to a CompactString. Fails if the ByteString is
--   not a valid encoded string.
fromByteString :: MonadPlus m => ByteString -> m (CompactString)

-- | Convert a ByteString to a CompactString. Raises an error if the
--   ByteString is not a valid encoded string.
fromByteString_ :: ByteString -> CompactString

-- | Validates a CompactString. If the string is invalid, fails, otherwise
--   returns the input.
validate :: MonadPlus m => CompactString -> m (CompactString)

-- | Validates a CompactString. If the string is invalid, throws an error,
--   otherwise returns the input.
validate_ :: CompactString -> CompactString

-- | Encode a CompactString to a ByteString using the given encoding.
--   
--   <pre>
--   encode e = liftM toByteString . recode
--   </pre>
--   
--   But it might be faster for some combinations of encodings.
--   
--   Fails if the string is cannot be encoded in the target encoding.
encode :: (Encoding e, MonadPlus m) => e -> CompactString -> m ByteString

-- | Encode a CompactString to a ByteString using the given encoding.
--   
--   <pre>
--   encode_ e = toByteString . recode
--   </pre>
--   
--   But it might be faster for some combinations of encodings.
--   
--   Raises an error if the string is cannot be encoded in the target
--   encoding.
encode_ :: Encoding e => e -> CompactString -> ByteString

-- | Decode a ByteString to a CompactString using the given encoding.
--   
--   <pre>
--   decode e = recode =&lt;&lt; fromByteString
--   </pre>
--   
--   but it might be faster for some combinations of encodings.
--   
--   Fails if the ByteString is not a valid encoded string or if the string
--   can not be represented in ASCII.
decode :: (Encoding e, MonadPlus m) => e -> ByteString -> m (CompactString)

-- | Decode a ByteString to a CompactString using the given encoding.
--   
--   <pre>
--   decode_ e = recode_ . fromByteString_
--   </pre>
--   
--   but it might be faster for some combinations of encodings.
--   
--   Raises an error if the ByteString is not a valid encoded string or if
--   the string can not be represented in ASCII.
decode_ :: Encoding e => e -> ByteString -> CompactString

-- | Encode a <a>CompactString</a> using the given encoding, and add a Byte
--   Order Mark. Byte Order Marks are common on Windows, but not on other
--   platforms.
--   
--   Fails if the string is cannot be encoded in the target encoding.
encodeBOM :: (Encoding e, MonadPlus m) => e -> CompactString -> m ByteString

-- | Encode a <a>CompactString</a> using the given encoding, and add a Byte
--   Order Mark. Byte Order Marks are common on Windows, but not on other
--   platforms.
--   
--   Raises an error if the string is cannot be encoded in the target
--   encoding.
encodeBOM_ :: Encoding e => e -> CompactString -> ByteString

-- | Decode a <a>ByteString</a> into a <a>CompactString</a>, by
--   investigating the Byte Order Mark. If there is no BOM assumes UTF-8.
--   Fails if the input is not a valid encoded string or if the string can
--   not be represented in ASCII.
--   
--   For portability, this function should be prefered over <tt>decode
--   UTF8</tt> when reading files.
decodeBOM :: MonadPlus m => ByteString -> m (CompactString)

-- | Decode a <a>ByteString</a> into a <a>CompactString</a>, by
--   investigating the Byte Order Mark. If there is no BOM assumes UTF-8.
--   Raises an error if the input is not a valid encoded string or if the
--   string can not be represented in ASCII.
--   
--   For portability, this function should be prefered over <tt>decode
--   UTF8</tt> when reading files.
decodeBOM_ :: ByteString -> CompactString

-- | Read a line from stdin.
getLine :: IO (CompactString)

-- | getContents. Equivalent to <tt>hGetContents stdin</tt>
--   
--   Input is assumed to be in ASCII, this may not be appropriate.
getContents :: IO (CompactString)

-- | Write a <a>CompactString</a> to stdout.
--   
--   Output is written in ASCII, this may not be appropriate.
putStr :: CompactString -> IO ()

-- | Write a <a>CompactString</a> to stdout, appending a newline character.
--   
--   Output is written in ASCII, this may not be appropriate.
putStrLn :: CompactString -> IO ()

-- | The interact function takes a function of type <tt>CompactString -&gt;
--   CompactString</tt> as its argument. The entire input from the standard
--   input device is passed to this function as its argument, and the
--   resulting string is output on the standard output device. It's great
--   for writing one line programs!
interact :: (CompactString -> CompactString) -> IO ()

-- | Read an entire file strictly into a <a>CompactString</a>. This is far
--   more efficient than reading the characters into a <a>String</a> and
--   then using <a>pack</a>. Files are read using 'text mode' on Windows.
--   
--   Files are assumed to be in ASCII.
readFile :: FilePath -> IO (CompactString)

-- | Read an entire file strictly into a <a>CompactString</a>. This is far
--   more efficient than reading the characters into a <a>String</a> and
--   then using <a>pack</a>. Files are read using 'text mode' on Windows.
--   
--   The encoding of the file is determined based on a Byte Order Mark, see
--   <a>decodeBOM</a>.
readFile' :: FilePath -> IO (CompactString)

-- | Write a <a>CompactString</a> to a file.
--   
--   Files are written using ASCII.
writeFile :: FilePath -> CompactString -> IO ()

-- | Write a <a>CompactString</a> to a file.
--   
--   Files are written using ASCII. A Byte Order Mark is also written.
writeFile' :: FilePath -> CompactString -> IO ()

-- | Append a <a>CompactString</a> to a file.
--   
--   Files are written using ASCII.
appendFile :: FilePath -> CompactString -> IO ()

-- | Append a <a>CompactString</a> to a file.
--   
--   The encoding of the file is determined based on a Byte Order Mark. If
--   the file is empty, it is written using ASCII with a Byte Order Mark.
--   If the encoding can not be determined the file is assumed to be UTF-8.
appendFile' :: FilePath -> CompactString -> IO ()

-- | Read a line from a handle
hGetLine :: Handle -> IO (CompactString)

-- | Read entire handle contents into a <a>CompactString</a>.
--   
--   The handle is interpreted as ASCII.
hGetContents :: Handle -> IO (CompactString)

-- | Read entire handle contents into a <a>CompactString</a>.
--   
--   The encoding is determined based on a Byte Order Mark, see
--   <a>decodeBOM</a>.
hGetContents' :: Handle -> IO (CompactString)

-- | Read a <a>CompactString</a> directly from the specified <a>Handle</a>.
--   
--   The handle is interpreted as ASCII.
hGet :: Handle -> Int -> IO (CompactString)

-- | hGetNonBlocking is identical to <a>hGet</a>, except that it will never
--   block waiting for data to become available, instead it returns only
--   whatever data is available.
--   
--   The handle is interpreted as ASCII.
hGetNonBlocking :: Handle -> Int -> IO (CompactString)

-- | Outputs a <a>CompactString</a> to the specified <a>Handle</a>.
--   
--   Output is written in ASCII.
hPut :: Handle -> CompactString -> IO ()

-- | A synonym for <tt>hPut</tt>, for compatibility
hPutStr :: Handle -> CompactString -> IO ()

-- | Write a <a>CompactString</a> to a handle, appending a newline byte
--   
--   Output is written in ASCII.
hPutStrLn :: Handle -> CompactString -> IO ()


-- | CompactString specialized to platform native UTF-16.
--   
--   This module can be used to reduce the need for type signatures, since
--   in most cases only a single encoding is used.
module Data.CompactString.UTF16

-- | CompactString specialized to UTF-16.
type CompactString = CompactString UTF16Native

-- | <i>O(1)</i> The empty <a>CompactString</a>
empty :: CompactString

-- | <i>O(1)</i> Convert a <a>Char</a> into a <a>CompactString</a>
singleton :: Char -> CompactString

-- | <i>O(n)</i> Convert a <a>String</a> into a <a>CompactString</a>.
pack :: String -> CompactString

-- | <i>O(n)</i> Converts a <a>CompactString</a> to a <a>String</a>.
unpack :: CompactString -> String

-- | <i>O(n)</i> <a>cons</a> is analogous to (:) for lists, but of
--   different complexity, as it requires a memcpy.
cons :: Char -> CompactString -> CompactString

-- | <i>O(n)</i> Append a byte to the end of a <a>CompactString</a>
snoc :: CompactString -> Char -> CompactString

-- | <i>O(n)</i> Append two CompactStrings
append :: CompactString -> CompactString -> CompactString

-- | <i>O(1)</i> Extract the first element of a CompactString, which must
--   be non-empty. An exception will be thrown in the case of an empty
--   CompactString.
head :: CompactString -> Char

-- | <i>O(1)</i> Extract the last element of a ByteString, which must be
--   finite and non-empty. An exception will be thrown in the case of an
--   empty ByteString.
last :: CompactString -> Char

-- | <i>O(1)</i> Extract the elements after the head of a CompactString,
--   which must be non-empty. An exception will be thrown in the case of an
--   empty CompactString.
tail :: CompactString -> CompactString

-- | <i>O(1)</i> Return all the elements of a <a>CompactString</a> except
--   the last one. An exception will be thrown in the case of an empty
--   ByteString.
init :: CompactString -> CompactString

-- | <i>O(1)</i> A view of the front of a <a>CompactString</a>.
--   
--   <pre>
--   headView s = if null s then Nothing else Just (head s, tail s)
--   </pre>
headView :: CompactString -> Maybe (Char, CompactString)

-- | <i>O(1)</i> A view of the back of a <a>CompactString</a>.
--   
--   <pre>
--   lastView s = if null s then Nothing else Just (init s, last s)
--   </pre>
lastView :: CompactString -> Maybe (CompactString, Char)

-- | <i>O(1)</i> Test whether a CompactString is empty.
null :: CompactString -> Bool

-- | <i>O(n)</i> <a>length</a> returns the length of a CompactString as an
--   <a>Int</a>.
length :: CompactString -> Int

-- | <i>O(n)</i> <a>map</a> <tt>f xs</tt> is the CompactString obtained by
--   applying <tt>f</tt> to each element of <tt>xs</tt>. This function is
--   subject to array fusion.
map :: (Char -> Char) -> CompactString -> CompactString

-- | Reverse a <a>CompactString</a>
reverse :: CompactString -> CompactString

-- | <i>O(n)</i> The <a>intersperse</a> function takes a <a>Char</a> and a
--   <a>CompactString</a> and `intersperses' that character between the
--   elements of the <a>CompactString</a>. It is analogous to the
--   intersperse function on Lists.
intersperse :: Char -> CompactString -> CompactString

-- | <i>O(n)</i> The <a>intercalate</a> function takes a
--   <a>CompactString</a> and a list of <a>CompactString</a>s and
--   concatenates the list after interspersing the first argument between
--   each element of the list.
intercalate :: CompactString -> [CompactString] -> CompactString

-- | The <a>transpose</a> function transposes the rows and columns of its
--   <a>CompactString</a> argument.
transpose :: [CompactString] -> [CompactString]

-- | <a>foldl</a>, applied to a binary operator, a starting value
--   (typically the left-identity of the operator), and a CompactString,
--   reduces the CompactString using the binary operator, from left to
--   right. This function is subject to array fusion.
foldl :: (acc -> Char -> acc) -> acc -> CompactString -> acc

-- | 'foldl\'' is like <a>foldl</a>, but strict in the accumulator. Though
--   actually foldl is also strict in the accumulator.
foldl' :: (acc -> Char -> acc) -> acc -> CompactString -> acc

-- | <a>foldl1</a> is a variant of <a>foldl</a> that has no starting value
--   argument, and thus must be applied to non-empty <a>CompactString</a>.
--   This function is subject to array fusion. An exception will be thrown
--   in the case of an empty CompactString.
foldl1 :: (Char -> Char -> Char) -> CompactString -> Char

-- | 'foldl1\'' is like <a>foldl1</a>, but strict in the accumulator. An
--   exception will be thrown in the case of an empty CompactString.
foldl1' :: (Char -> Char -> Char) -> CompactString -> Char

-- | <a>foldr</a>, applied to a binary operator, a starting value
--   (typically the right-identity of the operator), and a CompactString,
--   reduces the CompactString using the binary operator, from right to
--   left.
foldr :: (Char -> acc -> acc) -> acc -> CompactString -> acc

-- | <a>foldr</a>, applied to a binary operator, a starting value
--   (typically the right-identity of the operator), and a CompactString,
--   reduces the CompactString using the binary operator, from right to
--   left.
foldr' :: (Char -> acc -> acc) -> acc -> CompactString -> acc

-- | <a>foldr1</a> is a variant of <a>foldr</a> that has no starting value
--   argument, and thus must be applied to non-empty <a>CompactString</a>s
--   An exception will be thrown in the case of an empty CompactString.
foldr1 :: (Char -> Char -> Char) -> CompactString -> Char

-- | 'foldr1\'' is a variant of <a>foldr1</a>, but is strict in the
--   accumulator. An exception will be thrown in the case of an empty
--   CompactString.
foldr1' :: (Char -> Char -> Char) -> CompactString -> Char

-- | <i>O(n)</i> Concatenate a list of <a>CompactString</a>s.
concat :: [CompactString] -> CompactString

-- | Map a function over a <a>CompactString</a> and concatenate the results
concatMap :: (Char -> CompactString) -> CompactString -> CompactString

-- | <i>O(n)</i> Applied to a predicate and a CompactString, <a>any</a>
--   determines if any element of the <a>CompactString</a> satisfies the
--   predicate.
any :: (Char -> Bool) -> CompactString -> Bool

-- | <i>O(n)</i> Applied to a predicate and a CompactString, <a>any</a>
--   determines if all elements of the <a>CompactString</a> satisfy the
--   predicate.
all :: (Char -> Bool) -> CompactString -> Bool

-- | <i>O(n)</i> <a>maximum</a> returns the maximum value from a
--   <a>CompactString</a> An exception will be thrown in the case of an
--   empty CompactString.
maximum :: CompactString -> Char

-- | <i>O(n)</i> <a>minimum</a> returns the minimum value from a
--   <a>CompactString</a> An exception will be thrown in the case of an
--   empty CompactString.
minimum :: CompactString -> Char

-- | <a>scanl</a> is similar to <a>foldl</a>, but returns a list of
--   successive reduced values from the left. This function will fuse.
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs.
--   </pre>
scanl :: (Char -> Char -> Char) -> Char -> CompactString -> CompactString

-- | <a>scanl1</a> is a variant of <a>scanl</a> that has no starting value
--   argument. This function will fuse.
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
scanl1 :: (Char -> Char -> Char) -> CompactString -> CompactString

-- | scanr is the right-to-left dual of scanl.
scanr :: (Char -> Char -> Char) -> Char -> CompactString -> CompactString

-- | <a>scanr1</a> is a variant of <a>scanr</a> that has no starting value
--   argument.
scanr1 :: (Char -> Char -> Char) -> CompactString -> CompactString

-- | The <a>mapAccumL</a> function behaves like a combination of <a>map</a>
--   and <a>foldl</a>; it applies a function to each element of a
--   CompactString, passing an accumulating parameter from left to right,
--   and returning a final value of this accumulator together with the new
--   CompactString.
mapAccumL :: (acc -> Char -> (acc, Char)) -> acc -> CompactString -> (acc, CompactString)

-- | The <a>mapAccumR</a> function behaves like a combination of <a>map</a>
--   and <a>foldr</a>; it applies a function to each element of a
--   CompactString, passing an accumulating parameter from right to left,
--   and returning a final value of this accumulator together with the new
--   CompactString.
mapAccumR :: (acc -> Char -> (acc, Char)) -> acc -> CompactString -> (acc, CompactString)

-- | <i>O(n)</i> map Char functions, provided with the index at each
--   position.
mapIndexed :: (Int -> Char -> Char) -> CompactString -> CompactString

-- | <i>O(n)</i> <a>replicate</a> <tt>n x</tt> is a CompactString of length
--   <tt>n</tt> with <tt>x</tt> the value of every element. The following
--   holds:
--   
--   <pre>
--   replicate w c = unfoldr w (\u -&gt; Just (u,u)) c
--   </pre>
replicate :: Int -> Char -> CompactString

-- | <i>O(n)</i>, where <i>n</i> is the length of the result. The
--   <a>unfoldr</a> function is analogous to the List 'unfoldr'.
--   <a>unfoldr</a> builds a ByteString from a seed value. The function
--   takes the element and returns <a>Nothing</a> if it is done producing
--   the CompactString or returns <a>Just</a> <tt>(a,b)</tt>, in which
--   case, <tt>a</tt> is the next byte in the string, and <tt>b</tt> is the
--   seed value for further production.
--   
--   Examples:
--   
--   <pre>
--      unfoldr (\x -&gt; if x &lt;= 5 then Just (x, x + 1) else Nothing) 0
--   == pack [0, 1, 2, 3, 4, 5]
--   </pre>
unfoldr :: (acc -> Maybe (Char, acc)) -> acc -> CompactString

-- | <i>O(n)</i> Like <a>unfoldr</a>, <a>unfoldrN</a> builds a ByteString
--   from a seed value. However, the length of the result is limited by the
--   first argument to <a>unfoldrN</a>. This function is more efficient
--   than <a>unfoldr</a> when the maximum length of the result is known.
--   
--   The following equation relates <a>unfoldrN</a> and <a>unfoldr</a>:
--   
--   <pre>
--   fst (unfoldrN n f s) == take n (unfoldr f s)
--   </pre>
unfoldrN :: Int -> (acc -> Maybe (Char, acc)) -> acc -> (CompactString, Maybe acc)

-- | <i>O(n)</i> <a>take</a> <tt>n</tt>, applied to a CompactString
--   <tt>xs</tt>, returns the prefix of <tt>xs</tt> of length <tt>n</tt>,
--   or <tt>xs</tt> itself if <tt>n &gt; <a>length</a> xs</tt>.
take :: Int -> CompactString -> CompactString

-- | <i>O(n)</i> <a>drop</a> <tt>n xs</tt> returns the suffix of
--   <tt>xs</tt> after the first <tt>n</tt> elements, or <tt>empty</tt> if
--   <tt>n &gt; <a>length</a> xs</tt>.
drop :: Int -> CompactString -> CompactString

-- | <i>O(n)</i> <a>splitAt</a> <tt>n xs</tt> is equivalent to
--   <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt>.
splitAt :: Int -> CompactString -> (CompactString, CompactString)

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a
--   CompactString <tt>xs</tt>, returns the longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt>.
takeWhile :: (Char -> Bool) -> CompactString -> CompactString

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>.
dropWhile :: (Char -> Bool) -> CompactString -> CompactString

-- | <a>span</a> <tt>p xs</tt> breaks the ByteString into two segments. It
--   is equivalent to <tt>(<a>takeWhile</a> p xs, <a>dropWhile</a> p
--   xs)</tt>
span :: (Char -> Bool) -> CompactString -> (CompactString, CompactString)

-- | <a>spanEnd</a> behaves like <a>span</a> but from the end of the
--   <a>CompactString</a>
--   
--   We have
--   
--   <pre>
--   spanEnd (not.isSpace) "x y z" == ("x y ","z")
--   </pre>
--   
--   and
--   
--   <pre>
--   spanEnd (not . isSpace) cs
--      == 
--   let (x,y) = span (not.isSpace) (reverse cs) in (reverse y, reverse x)
--   </pre>
spanEnd :: (Char -> Bool) -> CompactString -> (CompactString, CompactString)

-- | <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (Char -> Bool) -> CompactString -> (CompactString, CompactString)

-- | <a>breakEnd</a> behaves like <a>break</a> but from the end of the
--   <a>CompactString</a>
--   
--   <pre>
--   breakEnd p == spanEnd (not.p)
--   </pre>
breakEnd :: (Char -> Bool) -> CompactString -> (CompactString, CompactString)

-- | The <a>group</a> function takes a <a>CompactString</a> and returns a
--   list of CompactStrings such that the concatenation of the result is
--   equal to the argument. Moreover, each sublist in the result contains
--   only equal elements. For example,
--   
--   <pre>
--   group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
--   </pre>
--   
--   It is a special case of <a>groupBy</a>, which allows the programmer to
--   supply their own equality test.
group :: CompactString -> [CompactString]

-- | The <a>groupBy</a> function is the non-overloaded version of
--   <a>group</a>.
groupBy :: (Char -> Char -> Bool) -> CompactString -> [CompactString]

-- | <i>O(n)</i> Return all initial segments of the given
--   <a>CompactString</a>, shortest first.
inits :: CompactString -> [CompactString]

-- | <i>O(n)</i> Return all final segments of the given
--   <a>CompactString</a>, longest first.
tails :: CompactString -> [CompactString]

-- | <i>O(n)</i> Break a <a>ByteString</a> into pieces separated by the
--   byte argument, consuming the delimiter. I.e.
--   
--   <pre>
--   split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
--   split 'a'  "aXaXaXa"    == ["","X","X","X",""]
--   split 'x'  "x"          == ["",""]
--   </pre>
--   
--   and
--   
--   <pre>
--   intercalate [c] . split c == id
--   split == splitWith . (==)
--   </pre>
--   
--   As for all splitting functions in this library, this function does not
--   copy the substrings, it just constructs new <a>CompactString</a> that
--   are slices of the original.
split :: Char -> CompactString -> [CompactString]

-- | <i>O(n)</i> Splits a <a>CompactString</a> into components delimited by
--   separators, where the predicate returns True for a separator element.
--   The resulting components do not contain the separators. Two adjacent
--   separators result in an empty component in the output. eg.
--   
--   <pre>
--   splitWith (=='a') "aabbaca" == ["","","bb","c",""]
--   splitWith (=='a') []        == []
--   </pre>
splitWith :: (Char -> Bool) -> CompactString -> [CompactString]

-- | <a>lines</a> breaks a <a>CompactString</a> up into a list of
--   CompactStrings at newline Chars. The resulting strings do not contain
--   newlines.
lines :: CompactString -> [CompactString]

-- | <a>words</a> breaks a ByteString up into a list of words, which were
--   delimited by Chars representing white space. And
--   
--   <pre>
--   words = filter (not . null) . splitWith isSpace
--   </pre>
words :: CompactString -> [CompactString]

-- | <a>unlines</a> is an inverse operation to <a>lines</a>. It joins
--   lines, after appending a terminating newline to each.
unlines :: [CompactString] -> CompactString

-- | The <a>unwords</a> function is analogous to the <a>unlines</a>
--   function, on words.
unwords :: [CompactString] -> CompactString

-- | <i>O(n)</i> The <a>isPrefixOf</a> function takes two CompactString and
--   returns <a>True</a> iff the first is a prefix of the second.
isPrefixOf :: CompactString -> CompactString -> Bool

-- | <i>O(n)</i> The <a>isSuffixOf</a> function takes two CompactString and
--   returns <a>True</a> iff the first is a suffix of the second.
--   
--   The following holds:
--   
--   <pre>
--   isSuffixOf x y == reverse x `isPrefixOf` reverse y
--   </pre>
isSuffixOf :: CompactString -> CompactString -> Bool

-- | Check whether one string is a substring of another. <tt>isInfixOf p
--   s</tt> is equivalent to <tt>not (null (findSubstrings p s))</tt>.
isInfixOf :: CompactString -> CompactString -> Bool

-- | Get the first index of a substring in another string, or
--   <a>Nothing</a> if the string is not found. <tt>findSubstring p s</tt>
--   is equivalent to <tt>listToMaybe (findSubstrings p s)</tt>.
findSubstring :: CompactString -> CompactString -> Maybe Int

-- | Find the indexes of all (possibly overlapping) occurances of a
--   substring in a string. This function uses the Knuth-Morris-Pratt
--   string matching algorithm.
findSubstrings :: CompactString -> CompactString -> [Int]

-- | <i>O(n)</i> <a>elem</a> is the <a>CompactString</a> membership
--   predicate.
elem :: Char -> CompactString -> Bool

-- | <i>O(n)</i> <a>notElem</a> is the inverse of <a>elem</a>
notElem :: Char -> CompactString -> Bool

-- | <i>O(n)</i> The <a>find</a> function takes a predicate and a
--   <a>CompactString</a>, and returns the first element in matching the
--   predicate, or <a>Nothing</a> if there is no such element.
--   
--   <pre>
--   find f p = case findIndex f p of Just n -&gt; Just (p `index` n) ; _ -&gt; Nothing
--   </pre>
find :: (Char -> Bool) -> CompactString -> Maybe Char

-- | <i>O(n)</i> <a>filter</a>, applied to a predicate and a
--   <a>CompactString</a>, returns a CompactString containing those
--   characters that satisfy the predicate. This function is subject to
--   array fusion.
filter :: (Char -> Bool) -> CompactString -> CompactString

-- | <i>O(n)</i> <a>partition</a>, applied to a predicate and a
--   <a>CompactString</a>, returns a pair of CompactStrings. The first
--   containing those characters that satisfy the predicate, the second
--   containg those that don't.
partition :: (Char -> Bool) -> CompactString -> (CompactString, CompactString)

-- | <i>O(n)</i> <a>CompactString</a> index (subscript) operator, starting
--   from 0.
index :: CompactString -> Int -> Char

-- | <i>O(n)</i> The <a>elemIndex</a> function returns the index of the
--   first element in the given <a>ByteString</a> which is equal to the
--   query element, or <a>Nothing</a> if there is no such element.
elemIndex :: Char -> CompactString -> Maybe Int

-- | <i>O(n)</i> The <a>elemIndices</a> function extends <a>elemIndex</a>,
--   by returning the indices of all elements equal to the query element,
--   in ascending order.
elemIndices :: Char -> CompactString -> [Int]

-- | <i>O(n)</i> The <a>elemIndexEnd</a> function returns the last index of
--   the element in the given <a>CompactString</a> which is equal to the
--   query element, or <a>Nothing</a> if there is no such element. The
--   following holds:
--   
--   <pre>
--   elemIndexEnd c xs == 
--   (-) (length xs - 1) `fmap` elemIndex c (reverse xs)
--   </pre>
elemIndexEnd :: Char -> CompactString -> Maybe Int

-- | The <a>findIndex</a> function takes a predicate and a
--   <a>CompactString</a> and returns the index of the first element in the
--   CompactString satisfying the predicate.
findIndex :: (Char -> Bool) -> CompactString -> Maybe Int

-- | <i>O(n)</i> The <a>findIndexEnd</a> function returns the last index of
--   the element in the given <a>CompactString</a> which satisfies the
--   predicate, or <a>Nothing</a> if there is no such element. The
--   following holds:
--   
--   <pre>
--   findIndexEnd c xs == 
--   (-) (length xs - 1) `fmap` findIndex c (reverse xs)
--   </pre>
findIndexEnd :: (Char -> Bool) -> CompactString -> Maybe Int

-- | The <a>findIndices</a> function extends <a>findIndex</a>, by returning
--   the indices of all elements satisfying the predicate, in ascending
--   order.
findIndices :: (Char -> Bool) -> CompactString -> [Int]

-- | count returns the number of times its argument appears in the
--   <a>CompactString</a>
--   
--   <pre>
--   count c = length . elemIndices c
--   </pre>
count :: Char -> CompactString -> Int

-- | <i>O(n)</i> <a>zip</a> takes two ByteStrings and returns a list of
--   corresponding pairs of bytes. If one input ByteString is short, excess
--   elements of the longer ByteString are discarded. This is equivalent to
--   a pair of <a>unpack</a> operations.
zip :: CompactString -> CompactString -> [(Char, Char)]

-- | <a>zipWith</a> generalises <a>zip</a> by zipping with the function
--   given as the first argument, instead of a tupling function. For
--   example, <tt><a>zipWith</a> (+)</tt> is applied to two ByteStrings to
--   produce the list of corresponding sums.
zipWith :: (Char -> Char -> b) -> CompactString -> CompactString -> [b]

-- | A specialised version of <a>zipWith</a> for the common case of a
--   simultaneous map over two <a>CompactString</a>s, to build a 3rd.
--   Rewrite rules are used to automatically covert zipWith into zipWith'
--   when a pack is performed on the result of zipWith, but we also export
--   it for convenience.
zipWith' :: (Char -> Char -> Char) -> CompactString -> CompactString -> CompactString

-- | <i>O(n)</i> <a>unzip</a> transforms a list of pairs of bytes into a
--   pair of CompactStrings. Note that this performs two <a>pack</a>
--   operations.
unzip :: [(Char, Char)] -> (CompactString, CompactString)

-- | <i>O(n log n)</i> Sort a CompactString
sort :: CompactString -> CompactString

-- | Convert a CompactString to a ByteString
toByteString :: CompactString -> ByteString

-- | Convert a ByteString to a CompactString. Fails if the ByteString is
--   not a valid encoded string.
fromByteString :: MonadPlus m => ByteString -> m (CompactString)

-- | Convert a ByteString to a CompactString. Raises an error if the
--   ByteString is not a valid encoded string.
fromByteString_ :: ByteString -> CompactString

-- | Validates a CompactString. If the string is invalid, fails, otherwise
--   returns the input.
validate :: MonadPlus m => CompactString -> m (CompactString)

-- | Validates a CompactString. If the string is invalid, throws an error,
--   otherwise returns the input.
validate_ :: CompactString -> CompactString

-- | Encode a CompactString to a ByteString using the given encoding.
--   
--   <pre>
--   encode e = liftM toByteString . recode
--   </pre>
--   
--   But it might be faster for some combinations of encodings.
--   
--   Fails if the string is cannot be encoded in the target encoding.
encode :: (Encoding e, MonadPlus m) => e -> CompactString -> m ByteString

-- | Encode a CompactString to a ByteString using the given encoding.
--   
--   <pre>
--   encode_ e = toByteString . recode
--   </pre>
--   
--   But it might be faster for some combinations of encodings.
--   
--   Raises an error if the string is cannot be encoded in the target
--   encoding.
encode_ :: Encoding e => e -> CompactString -> ByteString

-- | Decode a ByteString to a CompactString using the given encoding.
--   
--   <pre>
--   decode e = recode =&lt;&lt; fromByteString
--   </pre>
--   
--   but it might be faster for some combinations of encodings.
--   
--   Fails if the ByteString is not a valid encoded string
decode :: (Encoding e, MonadPlus m) => e -> ByteString -> m (CompactString)

-- | Decode a ByteString to a CompactString using the given encoding.
--   
--   <pre>
--   decode_ e = recode_ . fromByteString_
--   </pre>
--   
--   but it might be faster for some combinations of encodings.
--   
--   Raises an error if the ByteString is not a valid encoded string
decode_ :: Encoding e => e -> ByteString -> CompactString

-- | Encode a <a>CompactString</a> using the given encoding, and add a Byte
--   Order Mark. Byte Order Marks are common on Windows, but not on other
--   platforms.
--   
--   Fails if the string is cannot be encoded in the target encoding.
encodeBOM :: (Encoding e, MonadPlus m) => e -> CompactString -> m ByteString

-- | Encode a <a>CompactString</a> using the given encoding, and add a Byte
--   Order Mark. Byte Order Marks are common on Windows, but not on other
--   platforms.
--   
--   Raises an error if the string is cannot be encoded in the target
--   encoding.
encodeBOM_ :: Encoding e => e -> CompactString -> ByteString

-- | Decode a <a>ByteString</a> into a <a>CompactString</a>, by
--   investigating the Byte Order Mark. If there is no BOM assumes UTF-8.
--   Fails if the input is not a valid encoded string
--   
--   For portability, this function should be prefered over <tt>decode
--   UTF8</tt> when reading files.
decodeBOM :: MonadPlus m => ByteString -> m (CompactString)

-- | Decode a <a>ByteString</a> into a <a>CompactString</a>, by
--   investigating the Byte Order Mark. If there is no BOM assumes UTF-8.
--   Raises an error if the input is not a valid encoded string
--   
--   For portability, this function should be prefered over <tt>decode
--   UTF8</tt> when reading files.
decodeBOM_ :: ByteString -> CompactString

-- | Read a line from stdin.
getLine :: IO (CompactString)

-- | getContents. Equivalent to <tt>hGetContents stdin</tt>
--   
--   Input is assumed to be in UTF-16, this may not be appropriate.
getContents :: IO (CompactString)

-- | Write a <a>CompactString</a> to stdout.
--   
--   Output is written in UTF-16, this may not be appropriate.
putStr :: CompactString -> IO ()

-- | Write a <a>CompactString</a> to stdout, appending a newline character.
--   
--   Output is written in UTF-16, this may not be appropriate.
putStrLn :: CompactString -> IO ()

-- | The interact function takes a function of type <tt>CompactString -&gt;
--   CompactString</tt> as its argument. The entire input from the standard
--   input device is passed to this function as its argument, and the
--   resulting string is output on the standard output device. It's great
--   for writing one line programs!
interact :: (CompactString -> CompactString) -> IO ()

-- | Read an entire file strictly into a <a>CompactString</a>. This is far
--   more efficient than reading the characters into a <a>String</a> and
--   then using <a>pack</a>. Files are read using 'text mode' on Windows.
--   
--   Files are assumed to be in UTF-16.
readFile :: FilePath -> IO (CompactString)

-- | Read an entire file strictly into a <a>CompactString</a>. This is far
--   more efficient than reading the characters into a <a>String</a> and
--   then using <a>pack</a>. Files are read using 'text mode' on Windows.
--   
--   The encoding of the file is determined based on a Byte Order Mark, see
--   <a>decodeBOM</a>.
readFile' :: FilePath -> IO (CompactString)

-- | Write a <a>CompactString</a> to a file.
--   
--   Files are written using UTF-16.
writeFile :: FilePath -> CompactString -> IO ()

-- | Write a <a>CompactString</a> to a file.
--   
--   Files are written using UTF-16. A Byte Order Mark is also written.
writeFile' :: FilePath -> CompactString -> IO ()

-- | Append a <a>CompactString</a> to a file.
--   
--   Files are written using UTF-16.
appendFile :: FilePath -> CompactString -> IO ()

-- | Append a <a>CompactString</a> to a file.
--   
--   The encoding of the file is determined based on a Byte Order Mark. If
--   the file is empty, it is written using UTF-16 with a Byte Order Mark.
--   If the encoding can not be determined the file is assumed to be UTF-8.
appendFile' :: FilePath -> CompactString -> IO ()

-- | Read a line from a handle
hGetLine :: Handle -> IO (CompactString)

-- | Read entire handle contents into a <a>CompactString</a>.
--   
--   The handle is interpreted as UTF-16.
hGetContents :: Handle -> IO (CompactString)

-- | Read entire handle contents into a <a>CompactString</a>.
--   
--   The encoding is determined based on a Byte Order Mark, see
--   <a>decodeBOM</a>.
hGetContents' :: Handle -> IO (CompactString)

-- | Read a <a>CompactString</a> directly from the specified <a>Handle</a>.
--   
--   The handle is interpreted as UTF-16.
hGet :: Handle -> Int -> IO (CompactString)

-- | hGetNonBlocking is identical to <a>hGet</a>, except that it will never
--   block waiting for data to become available, instead it returns only
--   whatever data is available.
--   
--   The handle is interpreted as UTF-16.
hGetNonBlocking :: Handle -> Int -> IO (CompactString)

-- | Outputs a <a>CompactString</a> to the specified <a>Handle</a>.
--   
--   Output is written in UTF-16.
hPut :: Handle -> CompactString -> IO ()

-- | A synonym for <tt>hPut</tt>, for compatibility
hPutStr :: Handle -> CompactString -> IO ()

-- | Write a <a>CompactString</a> to a handle, appending a newline byte
--   
--   Output is written in UTF-16.
hPutStrLn :: Handle -> CompactString -> IO ()


-- | CompactString specialized to UTF-8.
--   
--   This module can be used to reduce the need for type signatures, since
--   in most cases only a single encoding is used.
module Data.CompactString.UTF8

-- | CompactString specialized to UTF-8.
type CompactString = CompactString UTF8

-- | <i>O(1)</i> The empty <a>CompactString</a>
empty :: CompactString

-- | <i>O(1)</i> Convert a <a>Char</a> into a <a>CompactString</a>
singleton :: Char -> CompactString

-- | <i>O(n)</i> Convert a <a>String</a> into a <a>CompactString</a>.
pack :: String -> CompactString

-- | <i>O(n)</i> Converts a <a>CompactString</a> to a <a>String</a>.
unpack :: CompactString -> String

-- | <i>O(n)</i> <a>cons</a> is analogous to (:) for lists, but of
--   different complexity, as it requires a memcpy.
cons :: Char -> CompactString -> CompactString

-- | <i>O(n)</i> Append a byte to the end of a <a>CompactString</a>
snoc :: CompactString -> Char -> CompactString

-- | <i>O(n)</i> Append two CompactStrings
append :: CompactString -> CompactString -> CompactString

-- | <i>O(1)</i> Extract the first element of a CompactString, which must
--   be non-empty. An exception will be thrown in the case of an empty
--   CompactString.
head :: CompactString -> Char

-- | <i>O(1)</i> Extract the last element of a ByteString, which must be
--   finite and non-empty. An exception will be thrown in the case of an
--   empty ByteString.
last :: CompactString -> Char

-- | <i>O(1)</i> Extract the elements after the head of a CompactString,
--   which must be non-empty. An exception will be thrown in the case of an
--   empty CompactString.
tail :: CompactString -> CompactString

-- | <i>O(1)</i> Return all the elements of a <a>CompactString</a> except
--   the last one. An exception will be thrown in the case of an empty
--   ByteString.
init :: CompactString -> CompactString

-- | <i>O(1)</i> A view of the front of a <a>CompactString</a>.
--   
--   <pre>
--   headView s = if null s then Nothing else Just (head s, tail s)
--   </pre>
headView :: CompactString -> Maybe (Char, CompactString)

-- | <i>O(1)</i> A view of the back of a <a>CompactString</a>.
--   
--   <pre>
--   lastView s = if null s then Nothing else Just (init s, last s)
--   </pre>
lastView :: CompactString -> Maybe (CompactString, Char)

-- | <i>O(1)</i> Test whether a CompactString is empty.
null :: CompactString -> Bool

-- | <i>O(n)</i> <a>length</a> returns the length of a CompactString as an
--   <a>Int</a>.
length :: CompactString -> Int

-- | <i>O(n)</i> <a>map</a> <tt>f xs</tt> is the CompactString obtained by
--   applying <tt>f</tt> to each element of <tt>xs</tt>. This function is
--   subject to array fusion.
map :: (Char -> Char) -> CompactString -> CompactString

-- | Reverse a <a>CompactString</a>
reverse :: CompactString -> CompactString

-- | <i>O(n)</i> The <a>intersperse</a> function takes a <a>Char</a> and a
--   <a>CompactString</a> and `intersperses' that character between the
--   elements of the <a>CompactString</a>. It is analogous to the
--   intersperse function on Lists.
intersperse :: Char -> CompactString -> CompactString

-- | <i>O(n)</i> The <a>intercalate</a> function takes a
--   <a>CompactString</a> and a list of <a>CompactString</a>s and
--   concatenates the list after interspersing the first argument between
--   each element of the list.
intercalate :: CompactString -> [CompactString] -> CompactString

-- | The <a>transpose</a> function transposes the rows and columns of its
--   <a>CompactString</a> argument.
transpose :: [CompactString] -> [CompactString]

-- | <a>foldl</a>, applied to a binary operator, a starting value
--   (typically the left-identity of the operator), and a CompactString,
--   reduces the CompactString using the binary operator, from left to
--   right. This function is subject to array fusion.
foldl :: (acc -> Char -> acc) -> acc -> CompactString -> acc

-- | 'foldl\'' is like <a>foldl</a>, but strict in the accumulator. Though
--   actually foldl is also strict in the accumulator.
foldl' :: (acc -> Char -> acc) -> acc -> CompactString -> acc

-- | <a>foldl1</a> is a variant of <a>foldl</a> that has no starting value
--   argument, and thus must be applied to non-empty <a>CompactString</a>.
--   This function is subject to array fusion. An exception will be thrown
--   in the case of an empty CompactString.
foldl1 :: (Char -> Char -> Char) -> CompactString -> Char

-- | 'foldl1\'' is like <a>foldl1</a>, but strict in the accumulator. An
--   exception will be thrown in the case of an empty CompactString.
foldl1' :: (Char -> Char -> Char) -> CompactString -> Char

-- | <a>foldr</a>, applied to a binary operator, a starting value
--   (typically the right-identity of the operator), and a CompactString,
--   reduces the CompactString using the binary operator, from right to
--   left.
foldr :: (Char -> acc -> acc) -> acc -> CompactString -> acc

-- | <a>foldr</a>, applied to a binary operator, a starting value
--   (typically the right-identity of the operator), and a CompactString,
--   reduces the CompactString using the binary operator, from right to
--   left.
foldr' :: (Char -> acc -> acc) -> acc -> CompactString -> acc

-- | <a>foldr1</a> is a variant of <a>foldr</a> that has no starting value
--   argument, and thus must be applied to non-empty <a>CompactString</a>s
--   An exception will be thrown in the case of an empty CompactString.
foldr1 :: (Char -> Char -> Char) -> CompactString -> Char

-- | 'foldr1\'' is a variant of <a>foldr1</a>, but is strict in the
--   accumulator. An exception will be thrown in the case of an empty
--   CompactString.
foldr1' :: (Char -> Char -> Char) -> CompactString -> Char

-- | <i>O(n)</i> Concatenate a list of <a>CompactString</a>s.
concat :: [CompactString] -> CompactString

-- | Map a function over a <a>CompactString</a> and concatenate the results
concatMap :: (Char -> CompactString) -> CompactString -> CompactString

-- | <i>O(n)</i> Applied to a predicate and a CompactString, <a>any</a>
--   determines if any element of the <a>CompactString</a> satisfies the
--   predicate.
any :: (Char -> Bool) -> CompactString -> Bool

-- | <i>O(n)</i> Applied to a predicate and a CompactString, <a>any</a>
--   determines if all elements of the <a>CompactString</a> satisfy the
--   predicate.
all :: (Char -> Bool) -> CompactString -> Bool

-- | <i>O(n)</i> <a>maximum</a> returns the maximum value from a
--   <a>CompactString</a> An exception will be thrown in the case of an
--   empty CompactString.
maximum :: CompactString -> Char

-- | <i>O(n)</i> <a>minimum</a> returns the minimum value from a
--   <a>CompactString</a> An exception will be thrown in the case of an
--   empty CompactString.
minimum :: CompactString -> Char

-- | <a>scanl</a> is similar to <a>foldl</a>, but returns a list of
--   successive reduced values from the left. This function will fuse.
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Note that
--   
--   <pre>
--   last (scanl f z xs) == foldl f z xs.
--   </pre>
scanl :: (Char -> Char -> Char) -> Char -> CompactString -> CompactString

-- | <a>scanl1</a> is a variant of <a>scanl</a> that has no starting value
--   argument. This function will fuse.
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
scanl1 :: (Char -> Char -> Char) -> CompactString -> CompactString

-- | scanr is the right-to-left dual of scanl.
scanr :: (Char -> Char -> Char) -> Char -> CompactString -> CompactString

-- | <a>scanr1</a> is a variant of <a>scanr</a> that has no starting value
--   argument.
scanr1 :: (Char -> Char -> Char) -> CompactString -> CompactString

-- | The <a>mapAccumL</a> function behaves like a combination of <a>map</a>
--   and <a>foldl</a>; it applies a function to each element of a
--   CompactString, passing an accumulating parameter from left to right,
--   and returning a final value of this accumulator together with the new
--   CompactString.
mapAccumL :: (acc -> Char -> (acc, Char)) -> acc -> CompactString -> (acc, CompactString)

-- | The <a>mapAccumR</a> function behaves like a combination of <a>map</a>
--   and <a>foldr</a>; it applies a function to each element of a
--   CompactString, passing an accumulating parameter from right to left,
--   and returning a final value of this accumulator together with the new
--   CompactString.
mapAccumR :: (acc -> Char -> (acc, Char)) -> acc -> CompactString -> (acc, CompactString)

-- | <i>O(n)</i> map Char functions, provided with the index at each
--   position.
mapIndexed :: (Int -> Char -> Char) -> CompactString -> CompactString

-- | <i>O(n)</i> <a>replicate</a> <tt>n x</tt> is a CompactString of length
--   <tt>n</tt> with <tt>x</tt> the value of every element. The following
--   holds:
--   
--   <pre>
--   replicate w c = unfoldr w (\u -&gt; Just (u,u)) c
--   </pre>
replicate :: Int -> Char -> CompactString

-- | <i>O(n)</i>, where <i>n</i> is the length of the result. The
--   <a>unfoldr</a> function is analogous to the List 'unfoldr'.
--   <a>unfoldr</a> builds a ByteString from a seed value. The function
--   takes the element and returns <a>Nothing</a> if it is done producing
--   the CompactString or returns <a>Just</a> <tt>(a,b)</tt>, in which
--   case, <tt>a</tt> is the next byte in the string, and <tt>b</tt> is the
--   seed value for further production.
--   
--   Examples:
--   
--   <pre>
--      unfoldr (\x -&gt; if x &lt;= 5 then Just (x, x + 1) else Nothing) 0
--   == pack [0, 1, 2, 3, 4, 5]
--   </pre>
unfoldr :: (acc -> Maybe (Char, acc)) -> acc -> CompactString

-- | <i>O(n)</i> Like <a>unfoldr</a>, <a>unfoldrN</a> builds a ByteString
--   from a seed value. However, the length of the result is limited by the
--   first argument to <a>unfoldrN</a>. This function is more efficient
--   than <a>unfoldr</a> when the maximum length of the result is known.
--   
--   The following equation relates <a>unfoldrN</a> and <a>unfoldr</a>:
--   
--   <pre>
--   fst (unfoldrN n f s) == take n (unfoldr f s)
--   </pre>
unfoldrN :: Int -> (acc -> Maybe (Char, acc)) -> acc -> (CompactString, Maybe acc)

-- | <i>O(n)</i> <a>take</a> <tt>n</tt>, applied to a CompactString
--   <tt>xs</tt>, returns the prefix of <tt>xs</tt> of length <tt>n</tt>,
--   or <tt>xs</tt> itself if <tt>n &gt; <a>length</a> xs</tt>.
take :: Int -> CompactString -> CompactString

-- | <i>O(n)</i> <a>drop</a> <tt>n xs</tt> returns the suffix of
--   <tt>xs</tt> after the first <tt>n</tt> elements, or <tt>empty</tt> if
--   <tt>n &gt; <a>length</a> xs</tt>.
drop :: Int -> CompactString -> CompactString

-- | <i>O(n)</i> <a>splitAt</a> <tt>n xs</tt> is equivalent to
--   <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt>.
splitAt :: Int -> CompactString -> (CompactString, CompactString)

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a
--   CompactString <tt>xs</tt>, returns the longest prefix (possibly empty)
--   of <tt>xs</tt> of elements that satisfy <tt>p</tt>.
takeWhile :: (Char -> Bool) -> CompactString -> CompactString

-- | <a>dropWhile</a> <tt>p xs</tt> returns the suffix remaining after
--   <a>takeWhile</a> <tt>p xs</tt>.
dropWhile :: (Char -> Bool) -> CompactString -> CompactString

-- | <a>span</a> <tt>p xs</tt> breaks the ByteString into two segments. It
--   is equivalent to <tt>(<a>takeWhile</a> p xs, <a>dropWhile</a> p
--   xs)</tt>
span :: (Char -> Bool) -> CompactString -> (CompactString, CompactString)

-- | <a>spanEnd</a> behaves like <a>span</a> but from the end of the
--   <a>CompactString</a>
--   
--   We have
--   
--   <pre>
--   spanEnd (not.isSpace) "x y z" == ("x y ","z")
--   </pre>
--   
--   and
--   
--   <pre>
--   spanEnd (not . isSpace) cs
--      == 
--   let (x,y) = span (not.isSpace) (reverse cs) in (reverse y, reverse x)
--   </pre>
spanEnd :: (Char -> Bool) -> CompactString -> (CompactString, CompactString)

-- | <a>break</a> <tt>p</tt> is equivalent to <tt><a>span</a> (<a>not</a> .
--   p)</tt>.
break :: (Char -> Bool) -> CompactString -> (CompactString, CompactString)

-- | <a>breakEnd</a> behaves like <a>break</a> but from the end of the
--   <a>CompactString</a>
--   
--   <pre>
--   breakEnd p == spanEnd (not.p)
--   </pre>
breakEnd :: (Char -> Bool) -> CompactString -> (CompactString, CompactString)

-- | The <a>group</a> function takes a <a>CompactString</a> and returns a
--   list of CompactStrings such that the concatenation of the result is
--   equal to the argument. Moreover, each sublist in the result contains
--   only equal elements. For example,
--   
--   <pre>
--   group "Mississippi" = ["M","i","ss","i","ss","i","pp","i"]
--   </pre>
--   
--   It is a special case of <a>groupBy</a>, which allows the programmer to
--   supply their own equality test.
group :: CompactString -> [CompactString]

-- | The <a>groupBy</a> function is the non-overloaded version of
--   <a>group</a>.
groupBy :: (Char -> Char -> Bool) -> CompactString -> [CompactString]

-- | <i>O(n)</i> Return all initial segments of the given
--   <a>CompactString</a>, shortest first.
inits :: CompactString -> [CompactString]

-- | <i>O(n)</i> Return all final segments of the given
--   <a>CompactString</a>, longest first.
tails :: CompactString -> [CompactString]

-- | <i>O(n)</i> Break a <a>ByteString</a> into pieces separated by the
--   byte argument, consuming the delimiter. I.e.
--   
--   <pre>
--   split '\n' "a\nb\nd\ne" == ["a","b","d","e"]
--   split 'a'  "aXaXaXa"    == ["","X","X","X",""]
--   split 'x'  "x"          == ["",""]
--   </pre>
--   
--   and
--   
--   <pre>
--   intercalate [c] . split c == id
--   split == splitWith . (==)
--   </pre>
--   
--   As for all splitting functions in this library, this function does not
--   copy the substrings, it just constructs new <a>CompactString</a> that
--   are slices of the original.
split :: Char -> CompactString -> [CompactString]

-- | <i>O(n)</i> Splits a <a>CompactString</a> into components delimited by
--   separators, where the predicate returns True for a separator element.
--   The resulting components do not contain the separators. Two adjacent
--   separators result in an empty component in the output. eg.
--   
--   <pre>
--   splitWith (=='a') "aabbaca" == ["","","bb","c",""]
--   splitWith (=='a') []        == []
--   </pre>
splitWith :: (Char -> Bool) -> CompactString -> [CompactString]

-- | <a>lines</a> breaks a <a>CompactString</a> up into a list of
--   CompactStrings at newline Chars. The resulting strings do not contain
--   newlines.
lines :: CompactString -> [CompactString]

-- | <a>words</a> breaks a ByteString up into a list of words, which were
--   delimited by Chars representing white space. And
--   
--   <pre>
--   words = filter (not . null) . splitWith isSpace
--   </pre>
words :: CompactString -> [CompactString]

-- | <a>unlines</a> is an inverse operation to <a>lines</a>. It joins
--   lines, after appending a terminating newline to each.
unlines :: [CompactString] -> CompactString

-- | The <a>unwords</a> function is analogous to the <a>unlines</a>
--   function, on words.
unwords :: [CompactString] -> CompactString

-- | <i>O(n)</i> The <a>isPrefixOf</a> function takes two CompactString and
--   returns <a>True</a> iff the first is a prefix of the second.
isPrefixOf :: CompactString -> CompactString -> Bool

-- | <i>O(n)</i> The <a>isSuffixOf</a> function takes two CompactString and
--   returns <a>True</a> iff the first is a suffix of the second.
--   
--   The following holds:
--   
--   <pre>
--   isSuffixOf x y == reverse x `isPrefixOf` reverse y
--   </pre>
isSuffixOf :: CompactString -> CompactString -> Bool

-- | Check whether one string is a substring of another. <tt>isInfixOf p
--   s</tt> is equivalent to <tt>not (null (findSubstrings p s))</tt>.
isInfixOf :: CompactString -> CompactString -> Bool

-- | Get the first index of a substring in another string, or
--   <a>Nothing</a> if the string is not found. <tt>findSubstring p s</tt>
--   is equivalent to <tt>listToMaybe (findSubstrings p s)</tt>.
findSubstring :: CompactString -> CompactString -> Maybe Int

-- | Find the indexes of all (possibly overlapping) occurances of a
--   substring in a string. This function uses the Knuth-Morris-Pratt
--   string matching algorithm.
findSubstrings :: CompactString -> CompactString -> [Int]

-- | <i>O(n)</i> <a>elem</a> is the <a>CompactString</a> membership
--   predicate.
elem :: Char -> CompactString -> Bool

-- | <i>O(n)</i> <a>notElem</a> is the inverse of <a>elem</a>
notElem :: Char -> CompactString -> Bool

-- | <i>O(n)</i> The <a>find</a> function takes a predicate and a
--   <a>CompactString</a>, and returns the first element in matching the
--   predicate, or <a>Nothing</a> if there is no such element.
--   
--   <pre>
--   find f p = case findIndex f p of Just n -&gt; Just (p `index` n) ; _ -&gt; Nothing
--   </pre>
find :: (Char -> Bool) -> CompactString -> Maybe Char

-- | <i>O(n)</i> <a>filter</a>, applied to a predicate and a
--   <a>CompactString</a>, returns a CompactString containing those
--   characters that satisfy the predicate. This function is subject to
--   array fusion.
filter :: (Char -> Bool) -> CompactString -> CompactString

-- | <i>O(n)</i> <a>partition</a>, applied to a predicate and a
--   <a>CompactString</a>, returns a pair of CompactStrings. The first
--   containing those characters that satisfy the predicate, the second
--   containg those that don't.
partition :: (Char -> Bool) -> CompactString -> (CompactString, CompactString)

-- | <i>O(n)</i> <a>CompactString</a> index (subscript) operator, starting
--   from 0.
index :: CompactString -> Int -> Char

-- | <i>O(n)</i> The <a>elemIndex</a> function returns the index of the
--   first element in the given <a>ByteString</a> which is equal to the
--   query element, or <a>Nothing</a> if there is no such element.
elemIndex :: Char -> CompactString -> Maybe Int

-- | <i>O(n)</i> The <a>elemIndices</a> function extends <a>elemIndex</a>,
--   by returning the indices of all elements equal to the query element,
--   in ascending order.
elemIndices :: Char -> CompactString -> [Int]

-- | <i>O(n)</i> The <a>elemIndexEnd</a> function returns the last index of
--   the element in the given <a>CompactString</a> which is equal to the
--   query element, or <a>Nothing</a> if there is no such element. The
--   following holds:
--   
--   <pre>
--   elemIndexEnd c xs == 
--   (-) (length xs - 1) `fmap` elemIndex c (reverse xs)
--   </pre>
elemIndexEnd :: Char -> CompactString -> Maybe Int

-- | The <a>findIndex</a> function takes a predicate and a
--   <a>CompactString</a> and returns the index of the first element in the
--   CompactString satisfying the predicate.
findIndex :: (Char -> Bool) -> CompactString -> Maybe Int

-- | <i>O(n)</i> The <a>findIndexEnd</a> function returns the last index of
--   the element in the given <a>CompactString</a> which satisfies the
--   predicate, or <a>Nothing</a> if there is no such element. The
--   following holds:
--   
--   <pre>
--   findIndexEnd c xs == 
--   (-) (length xs - 1) `fmap` findIndex c (reverse xs)
--   </pre>
findIndexEnd :: (Char -> Bool) -> CompactString -> Maybe Int

-- | The <a>findIndices</a> function extends <a>findIndex</a>, by returning
--   the indices of all elements satisfying the predicate, in ascending
--   order.
findIndices :: (Char -> Bool) -> CompactString -> [Int]

-- | count returns the number of times its argument appears in the
--   <a>CompactString</a>
--   
--   <pre>
--   count c = length . elemIndices c
--   </pre>
count :: Char -> CompactString -> Int

-- | <i>O(n)</i> <a>zip</a> takes two ByteStrings and returns a list of
--   corresponding pairs of bytes. If one input ByteString is short, excess
--   elements of the longer ByteString are discarded. This is equivalent to
--   a pair of <a>unpack</a> operations.
zip :: CompactString -> CompactString -> [(Char, Char)]

-- | <a>zipWith</a> generalises <a>zip</a> by zipping with the function
--   given as the first argument, instead of a tupling function. For
--   example, <tt><a>zipWith</a> (+)</tt> is applied to two ByteStrings to
--   produce the list of corresponding sums.
zipWith :: (Char -> Char -> b) -> CompactString -> CompactString -> [b]

-- | A specialised version of <a>zipWith</a> for the common case of a
--   simultaneous map over two <a>CompactString</a>s, to build a 3rd.
--   Rewrite rules are used to automatically covert zipWith into zipWith'
--   when a pack is performed on the result of zipWith, but we also export
--   it for convenience.
zipWith' :: (Char -> Char -> Char) -> CompactString -> CompactString -> CompactString

-- | <i>O(n)</i> <a>unzip</a> transforms a list of pairs of bytes into a
--   pair of CompactStrings. Note that this performs two <a>pack</a>
--   operations.
unzip :: [(Char, Char)] -> (CompactString, CompactString)

-- | <i>O(n log n)</i> Sort a CompactString
sort :: CompactString -> CompactString

-- | Convert a CompactString to a ByteString
toByteString :: CompactString -> ByteString

-- | Convert a ByteString to a CompactString. Fails if the ByteString is
--   not a valid encoded string.
fromByteString :: MonadPlus m => ByteString -> m (CompactString)

-- | Convert a ByteString to a CompactString. Raises an error if the
--   ByteString is not a valid encoded string.
fromByteString_ :: ByteString -> CompactString

-- | Validates a CompactString. If the string is invalid, fails, otherwise
--   returns the input.
validate :: MonadPlus m => CompactString -> m (CompactString)

-- | Validates a CompactString. If the string is invalid, throws an error,
--   otherwise returns the input.
validate_ :: CompactString -> CompactString

-- | Encode a CompactString to a ByteString using the given encoding.
--   
--   <pre>
--   encode e = liftM toByteString . recode
--   </pre>
--   
--   But it might be faster for some combinations of encodings.
--   
--   Fails if the string is cannot be encoded in the target encoding.
encode :: (Encoding e, MonadPlus m) => e -> CompactString -> m ByteString

-- | Encode a CompactString to a ByteString using the given encoding.
--   
--   <pre>
--   encode_ e = toByteString . recode
--   </pre>
--   
--   But it might be faster for some combinations of encodings.
--   
--   Raises an error if the string is cannot be encoded in the target
--   encoding.
encode_ :: Encoding e => e -> CompactString -> ByteString

-- | Decode a ByteString to a CompactString using the given encoding.
--   
--   <pre>
--   decode e = recode =&lt;&lt; fromByteString
--   </pre>
--   
--   but it might be faster for some combinations of encodings.
--   
--   Fails if the ByteString is not a valid encoded string
decode :: (Encoding e, MonadPlus m) => e -> ByteString -> m (CompactString)

-- | Decode a ByteString to a CompactString using the given encoding.
--   
--   <pre>
--   decode_ e = recode_ . fromByteString_
--   </pre>
--   
--   but it might be faster for some combinations of encodings.
--   
--   Raises an error if the ByteString is not a valid encoded string
decode_ :: Encoding e => e -> ByteString -> CompactString

-- | Encode a <a>CompactString</a> using the given encoding, and add a Byte
--   Order Mark. Byte Order Marks are common on Windows, but not on other
--   platforms.
--   
--   Fails if the string is cannot be encoded in the target encoding.
encodeBOM :: (Encoding e, MonadPlus m) => e -> CompactString -> m ByteString

-- | Encode a <a>CompactString</a> using the given encoding, and add a Byte
--   Order Mark. Byte Order Marks are common on Windows, but not on other
--   platforms.
--   
--   Raises an error if the string is cannot be encoded in the target
--   encoding.
encodeBOM_ :: Encoding e => e -> CompactString -> ByteString

-- | Decode a <a>ByteString</a> into a <a>CompactString</a>, by
--   investigating the Byte Order Mark. If there is no BOM assumes UTF-8.
--   Fails if the input is not a valid encoded string
--   
--   For portability, this function should be prefered over <tt>decode
--   UTF8</tt> when reading files.
decodeBOM :: MonadPlus m => ByteString -> m (CompactString)

-- | Decode a <a>ByteString</a> into a <a>CompactString</a>, by
--   investigating the Byte Order Mark. If there is no BOM assumes UTF-8.
--   Raises an error if the input is not a valid encoded string
--   
--   For portability, this function should be prefered over <tt>decode
--   UTF8</tt> when reading files.
decodeBOM_ :: ByteString -> CompactString

-- | Read a line from stdin.
getLine :: IO (CompactString)

-- | getContents. Equivalent to <tt>hGetContents stdin</tt>
--   
--   Input is assumed to be in UTF-8, this may not be appropriate.
getContents :: IO (CompactString)

-- | Write a <a>CompactString</a> to stdout.
--   
--   Output is written in UTF-8, this may not be appropriate.
putStr :: CompactString -> IO ()

-- | Write a <a>CompactString</a> to stdout, appending a newline character.
--   
--   Output is written in UTF-8, this may not be appropriate.
putStrLn :: CompactString -> IO ()

-- | The interact function takes a function of type <tt>CompactString -&gt;
--   CompactString</tt> as its argument. The entire input from the standard
--   input device is passed to this function as its argument, and the
--   resulting string is output on the standard output device. It's great
--   for writing one line programs!
interact :: (CompactString -> CompactString) -> IO ()

-- | Read an entire file strictly into a <a>CompactString</a>. This is far
--   more efficient than reading the characters into a <a>String</a> and
--   then using <a>pack</a>. Files are read using 'text mode' on Windows.
--   
--   Files are assumed to be in UTF-8.
readFile :: FilePath -> IO (CompactString)

-- | Read an entire file strictly into a <a>CompactString</a>. This is far
--   more efficient than reading the characters into a <a>String</a> and
--   then using <a>pack</a>. Files are read using 'text mode' on Windows.
--   
--   The encoding of the file is determined based on a Byte Order Mark, see
--   <a>decodeBOM</a>.
readFile' :: FilePath -> IO (CompactString)

-- | Write a <a>CompactString</a> to a file.
--   
--   Files are written using UTF-8.
writeFile :: FilePath -> CompactString -> IO ()

-- | Write a <a>CompactString</a> to a file.
--   
--   Files are written using UTF-8. A Byte Order Mark is also written.
writeFile' :: FilePath -> CompactString -> IO ()

-- | Append a <a>CompactString</a> to a file.
--   
--   Files are written using UTF-8.
appendFile :: FilePath -> CompactString -> IO ()

-- | Append a <a>CompactString</a> to a file.
--   
--   The encoding of the file is determined based on a Byte Order Mark. If
--   the file is empty, it is written using UTF-8 with a Byte Order Mark.
--   If the encoding can not be determined the file is assumed to be UTF-8.
appendFile' :: FilePath -> CompactString -> IO ()

-- | Read a line from a handle
hGetLine :: Handle -> IO (CompactString)

-- | Read entire handle contents into a <a>CompactString</a>.
--   
--   The handle is interpreted as UTF-8.
hGetContents :: Handle -> IO (CompactString)

-- | Read entire handle contents into a <a>CompactString</a>.
--   
--   The encoding is determined based on a Byte Order Mark, see
--   <a>decodeBOM</a>.
hGetContents' :: Handle -> IO (CompactString)

-- | Read a <a>CompactString</a> directly from the specified <a>Handle</a>.
--   
--   The handle is interpreted as UTF-8.
hGet :: Handle -> Int -> IO (CompactString)

-- | hGetNonBlocking is identical to <a>hGet</a>, except that it will never
--   block waiting for data to become available, instead it returns only
--   whatever data is available.
--   
--   The handle is interpreted as UTF-8.
hGetNonBlocking :: Handle -> Int -> IO (CompactString)

-- | Outputs a <a>CompactString</a> to the specified <a>Handle</a>.
--   
--   Output is written in UTF-8.
hPut :: Handle -> CompactString -> IO ()

-- | A synonym for <tt>hPut</tt>, for compatibility
hPutStr :: Handle -> CompactString -> IO ()

-- | Write a <a>CompactString</a> to a handle, appending a newline byte
--   
--   Output is written in UTF-8.
hPutStrLn :: Handle -> CompactString -> IO ()
