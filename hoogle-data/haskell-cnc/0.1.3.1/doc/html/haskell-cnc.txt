-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Library for parallel programming in the Intel Concurrent Collections paradigm.
--   
--   Intel (Concurrent Collections) CnC is a data-flow like deterministic
--   parallel programming model, similar to stream-processing but in which
--   nodes in the computation graph share data in tables.
@package haskell-cnc
@version 0.1.3.1


-- | This module is an alternative implementation exposing the same
--   inteface as <a>Intel.Cnc</a>.
module Intel.CncPure
instance Ord (ItemCol a b)
instance Eq (ItemCol a b)
instance Show (ItemCol a b)
instance Ord (TagCol a)
instance Eq (TagCol a)
instance Show (TagCol a)
instance Monad GraphCode
instance Monad StepCode


-- | This module implements the Intel Concurrent Collections (CnC)
--   programming model. The variations of this module (<a>Intel.Cnc3</a>,
--   <a>Intel.Cnc5</a>, <a>Intel.Cnc6</a>, and <a>Intel.Cnc8</a>) each
--   implement the same programming model using different runtime
--   schedulers. All of them internally use the IO monad but expose a pure
--   interface. (The module <a>Intel.CncPure</a> is an alternative
--   implementation that exposes the same interface as this module but is
--   internally pure.)
--   
--   CnC is a data-flow like deterministic parallel programming model. To
--   use it, one constructs a <i>CnC graph</i> of computation steps. Steps
--   are arbitrary Haskell functions (which may themselves expose
--   parallelism through <a>par</a>). Edges in the graph are control and
--   data relationships, implemented by <i>tag</i> and <i>item</i>
--   collections respectively.
--   
--   A brief introduction to CnC using this module can be found at
--   <a>http://software.intel.com/en-us/blogs/2010/05/27/announcing-intel-concurrent-collections-for-haskell-01/</a>.
--   General documentation on the CnC model can be found at
--   <a>http://software.intel.com/en-us/articles/intel-concurrent-collections-for-cc/</a>.
module Intel.Cnc3

-- | Steps are functions that take a single <tt>tag</tt> as input and
--   perform a computation in the <a>StepCode</a> monad, which may perform
--   <a>put</a>s and <a>get</a>s.
type Step a = a -> StepCode ()

-- | Construct a new item collection.
newItemCol :: (Eq tag, Ord tag, Show tag) => GraphCode (ItemCol tag val)

-- | Construct a new tag collection.
newTagCol :: GraphCode (TagCol tag)

-- | Attach a computation step to a supply of control tags. This adds a new
--   node in the computation graph.
prescribe :: TagCol tag -> Step tag -> GraphCode ()

-- | Put-Tag. Push a control tag out into the computation graph.
putt :: TagCol tag -> tag -> StepCode ()

-- | Put an item. Subsequently, any steps waiting on the item may
--   subsequently execute.
put :: (Eq tag, Ord tag, Show tag) => ItemCol tag val -> tag -> val -> StepCode ()

-- | Get an item. Synchronous read-data operation.
get :: (Eq tag, Ord tag, Show tag) => ItemCol tag val -> tag -> StepCode val

-- | Run an initial step which populates the CnC graph with input tags and
--   items. Presently only a single initialize is allowed within a graph
--   execution.
initialize :: StepCode a -> GraphCode a

-- | Run a final step which collects outputs of the graph that are of
--   interest to the larger application. Presently only a single finalize
--   is allowed within a graph execution.
finalize :: StepCode a -> GraphCode a

-- | Construct a CnC graph and execute it to completion. Completion is
--   defined as the <a>finalize</a> action having completed.
runGraph :: GraphCode a -> a

-- | Convert an entire item collection into an association list. In
--   general, this can only be done from the <a>finalize</a> step and
--   requires selecting a runtime scheduler which supports
--   <i>quiescence</i>, that is, a scheduler that waits for all active
--   steps to complete before executing <a>finalize</a>. (Currently, all
--   schedulers but version 3 support quiescence.)
itemsToList :: (Eq tag, Ord tag, Show tag) => ItemCol tag b -> StepCode [(tag, b)]

-- | Print a message within a step (unsafe side effect).
stepPutStr :: String -> StepCode ()

-- | Print a message within the graph construction code (unsafe side
--   effect).
cncPutStr :: String -> GraphCode ()

-- | An informal identifier of the CnC version presently in use (for
--   example, identifying a scheduler implementation).
cncVariant :: String

-- | "<tt>cncFor start end body</tt>" runs <tt>body</tt> in parallel over
--   the inclusive range <tt>[start..end]</tt>.
--   
--   Frequently, CnC graphs are serial within steps but parallel at the
--   level of the graph. In contrast, <a>cncFor</a> exposes parallelism
--   <i>within a step</i>. Whether the body of the parallel for is doing
--   work, or just spawning work via <a>putt</a>, <a>cncFor</a> can help
--   distribute the work more efficiently.
cncFor :: Int -> Int -> (Int -> StepCode ()) -> StepCode ()

-- | A two dimensional loop.
cncFor2D :: (Int, Int) -> (Int, Int) -> (Int -> Int -> StepCode ()) -> StepCode ()


-- | This module implements the Intel Concurrent Collections (CnC)
--   programming model. The variations of this module (<a>Intel.Cnc3</a>,
--   <a>Intel.Cnc5</a>, <a>Intel.Cnc6</a>, and <a>Intel.Cnc8</a>) each
--   implement the same programming model using different runtime
--   schedulers. All of them internally use the IO monad but expose a pure
--   interface. (The module <a>Intel.CncPure</a> is an alternative
--   implementation that exposes the same interface as this module but is
--   internally pure.)
--   
--   CnC is a data-flow like deterministic parallel programming model. To
--   use it, one constructs a <i>CnC graph</i> of computation steps. Steps
--   are arbitrary Haskell functions (which may themselves expose
--   parallelism through <a>par</a>). Edges in the graph are control and
--   data relationships, implemented by <i>tag</i> and <i>item</i>
--   collections respectively.
--   
--   A brief introduction to CnC using this module can be found at
--   <a>http://software.intel.com/en-us/blogs/2010/05/27/announcing-intel-concurrent-collections-for-haskell-01/</a>.
--   General documentation on the CnC model can be found at
--   <a>http://software.intel.com/en-us/articles/intel-concurrent-collections-for-cc/</a>.
module Intel.Cnc5

-- | Steps are functions that take a single <tt>tag</tt> as input and
--   perform a computation in the <a>StepCode</a> monad, which may perform
--   <a>put</a>s and <a>get</a>s.
type Step a = a -> StepCode ()

-- | Construct a new item collection.
newItemCol :: (Eq tag, Ord tag, Show tag) => GraphCode (ItemCol tag val)

-- | Construct a new tag collection.
newTagCol :: GraphCode (TagCol tag)

-- | Attach a computation step to a supply of control tags. This adds a new
--   node in the computation graph.
prescribe :: TagCol tag -> Step tag -> GraphCode ()

-- | Put-Tag. Push a control tag out into the computation graph.
putt :: TagCol tag -> tag -> StepCode ()

-- | Put an item. Subsequently, any steps waiting on the item may
--   subsequently execute.
put :: (Eq tag, Ord tag, Show tag) => ItemCol tag val -> tag -> val -> StepCode ()

-- | Get an item. Synchronous read-data operation.
get :: (Eq tag, Ord tag, Show tag) => ItemCol tag val -> tag -> StepCode val

-- | Run an initial step which populates the CnC graph with input tags and
--   items. Presently only a single initialize is allowed within a graph
--   execution.
initialize :: StepCode a -> GraphCode a

-- | Run a final step which collects outputs of the graph that are of
--   interest to the larger application. Presently only a single finalize
--   is allowed within a graph execution.
finalize :: StepCode a -> GraphCode a

-- | Construct a CnC graph and execute it to completion. Completion is
--   defined as the <a>finalize</a> action having completed.
runGraph :: GraphCode a -> a

-- | Convert an entire item collection into an association list. In
--   general, this can only be done from the <a>finalize</a> step and
--   requires selecting a runtime scheduler which supports
--   <i>quiescence</i>, that is, a scheduler that waits for all active
--   steps to complete before executing <a>finalize</a>. (Currently, all
--   schedulers but version 3 support quiescence.)
itemsToList :: (Eq tag, Ord tag, Show tag) => ItemCol tag b -> StepCode [(tag, b)]

-- | Print a message within a step (unsafe side effect).
stepPutStr :: String -> StepCode ()

-- | Print a message within the graph construction code (unsafe side
--   effect).
cncPutStr :: String -> GraphCode ()

-- | An informal identifier of the CnC version presently in use (for
--   example, identifying a scheduler implementation).
cncVariant :: String

-- | "<tt>cncFor start end body</tt>" runs <tt>body</tt> in parallel over
--   the inclusive range <tt>[start..end]</tt>.
--   
--   Frequently, CnC graphs are serial within steps but parallel at the
--   level of the graph. In contrast, <a>cncFor</a> exposes parallelism
--   <i>within a step</i>. Whether the body of the parallel for is doing
--   work, or just spawning work via <a>putt</a>, <a>cncFor</a> can help
--   distribute the work more efficiently.
cncFor :: Int -> Int -> (Int -> StepCode ()) -> StepCode ()

-- | A two dimensional loop.
cncFor2D :: (Int, Int) -> (Int, Int) -> (Int -> Int -> StepCode ()) -> StepCode ()
instance [overlap ok] Show HiddenState5
instance [overlap ok] Show (IO a)
instance [overlap ok] Show (IORef a)


-- | This module implements the Intel Concurrent Collections (CnC)
--   programming model. The variations of this module (<a>Intel.Cnc3</a>,
--   <a>Intel.Cnc5</a>, <a>Intel.Cnc6</a>, and <a>Intel.Cnc8</a>) each
--   implement the same programming model using different runtime
--   schedulers. All of them internally use the IO monad but expose a pure
--   interface. (The module <a>Intel.CncPure</a> is an alternative
--   implementation that exposes the same interface as this module but is
--   internally pure.)
--   
--   CnC is a data-flow like deterministic parallel programming model. To
--   use it, one constructs a <i>CnC graph</i> of computation steps. Steps
--   are arbitrary Haskell functions (which may themselves expose
--   parallelism through <a>par</a>). Edges in the graph are control and
--   data relationships, implemented by <i>tag</i> and <i>item</i>
--   collections respectively.
--   
--   A brief introduction to CnC using this module can be found at
--   <a>http://software.intel.com/en-us/blogs/2010/05/27/announcing-intel-concurrent-collections-for-haskell-01/</a>.
--   General documentation on the CnC model can be found at
--   <a>http://software.intel.com/en-us/articles/intel-concurrent-collections-for-cc/</a>.
module Intel.Cnc6

-- | Steps are functions that take a single <tt>tag</tt> as input and
--   perform a computation in the <a>StepCode</a> monad, which may perform
--   <a>put</a>s and <a>get</a>s.
type Step a = a -> StepCode ()

-- | Construct a new item collection.
newItemCol :: (Eq tag, Ord tag, Show tag) => GraphCode (ItemCol tag val)

-- | Construct a new tag collection.
newTagCol :: GraphCode (TagCol tag)

-- | Attach a computation step to a supply of control tags. This adds a new
--   node in the computation graph.
prescribe :: TagCol tag -> Step tag -> GraphCode ()

-- | Put-Tag. Push a control tag out into the computation graph.
putt :: TagCol tag -> tag -> StepCode ()

-- | Put an item. Subsequently, any steps waiting on the item may
--   subsequently execute.
put :: (Eq tag, Ord tag, Show tag) => ItemCol tag val -> tag -> val -> StepCode ()

-- | Get an item. Synchronous read-data operation.
get :: (Eq tag, Ord tag, Show tag) => ItemCol tag val -> tag -> StepCode val

-- | Run an initial step which populates the CnC graph with input tags and
--   items. Presently only a single initialize is allowed within a graph
--   execution.
initialize :: StepCode a -> GraphCode a

-- | Run a final step which collects outputs of the graph that are of
--   interest to the larger application. Presently only a single finalize
--   is allowed within a graph execution.
finalize :: StepCode a -> GraphCode a

-- | Construct a CnC graph and execute it to completion. Completion is
--   defined as the <a>finalize</a> action having completed.
runGraph :: GraphCode a -> a

-- | Convert an entire item collection into an association list. In
--   general, this can only be done from the <a>finalize</a> step and
--   requires selecting a runtime scheduler which supports
--   <i>quiescence</i>, that is, a scheduler that waits for all active
--   steps to complete before executing <a>finalize</a>. (Currently, all
--   schedulers but version 3 support quiescence.)
itemsToList :: (Eq tag, Ord tag, Show tag) => ItemCol tag b -> StepCode [(tag, b)]

-- | Print a message within a step (unsafe side effect).
stepPutStr :: String -> StepCode ()

-- | Print a message within the graph construction code (unsafe side
--   effect).
cncPutStr :: String -> GraphCode ()

-- | An informal identifier of the CnC version presently in use (for
--   example, identifying a scheduler implementation).
cncVariant :: String

-- | "<tt>cncFor start end body</tt>" runs <tt>body</tt> in parallel over
--   the inclusive range <tt>[start..end]</tt>.
--   
--   Frequently, CnC graphs are serial within steps but parallel at the
--   level of the graph. In contrast, <a>cncFor</a> exposes parallelism
--   <i>within a step</i>. Whether the body of the parallel for is doing
--   work, or just spawning work via <a>putt</a>, <a>cncFor</a> can help
--   distribute the work more efficiently.
cncFor :: Int -> Int -> (Int -> StepCode ()) -> StepCode ()

-- | A two dimensional loop.
cncFor2D :: (Int, Int) -> (Int, Int) -> (Int -> Int -> StepCode ()) -> StepCode ()
instance [overlap ok] Show HiddenState5
instance [overlap ok] Show (IO a)
instance [overlap ok] Show (IORef a)


-- | This module implements the Intel Concurrent Collections (CnC)
--   programming model. The variations of this module (<a>Intel.Cnc3</a>,
--   <a>Intel.Cnc5</a>, <a>Intel.Cnc6</a>, and <a>Intel.Cnc8</a>) each
--   implement the same programming model using different runtime
--   schedulers. All of them internally use the IO monad but expose a pure
--   interface. (The module <a>Intel.CncPure</a> is an alternative
--   implementation that exposes the same interface as this module but is
--   internally pure.)
--   
--   CnC is a data-flow like deterministic parallel programming model. To
--   use it, one constructs a <i>CnC graph</i> of computation steps. Steps
--   are arbitrary Haskell functions (which may themselves expose
--   parallelism through <a>par</a>). Edges in the graph are control and
--   data relationships, implemented by <i>tag</i> and <i>item</i>
--   collections respectively.
--   
--   A brief introduction to CnC using this module can be found at
--   <a>http://software.intel.com/en-us/blogs/2010/05/27/announcing-intel-concurrent-collections-for-haskell-01/</a>.
--   General documentation on the CnC model can be found at
--   <a>http://software.intel.com/en-us/articles/intel-concurrent-collections-for-cc/</a>.
module Intel.Cnc8

-- | Steps are functions that take a single <tt>tag</tt> as input and
--   perform a computation in the <a>StepCode</a> monad, which may perform
--   <a>put</a>s and <a>get</a>s.
type Step a = a -> StepCode ()

-- | Construct a new item collection.
newItemCol :: (Eq tag, Ord tag, Show tag) => GraphCode (ItemCol tag val)

-- | Construct a new tag collection.
newTagCol :: GraphCode (TagCol tag)

-- | Attach a computation step to a supply of control tags. This adds a new
--   node in the computation graph.
prescribe :: TagCol tag -> Step tag -> GraphCode ()

-- | Put-Tag. Push a control tag out into the computation graph.
putt :: TagCol tag -> tag -> StepCode ()

-- | Put an item. Subsequently, any steps waiting on the item may
--   subsequently execute.
put :: (Eq tag, Ord tag, Show tag) => ItemCol tag val -> tag -> val -> StepCode ()

-- | Get an item. Synchronous read-data operation.
get :: (Eq tag, Ord tag, Show tag) => ItemCol tag val -> tag -> StepCode val

-- | Run an initial step which populates the CnC graph with input tags and
--   items. Presently only a single initialize is allowed within a graph
--   execution.
initialize :: StepCode a -> GraphCode a

-- | Run a final step which collects outputs of the graph that are of
--   interest to the larger application. Presently only a single finalize
--   is allowed within a graph execution.
finalize :: StepCode a -> GraphCode a

-- | Construct a CnC graph and execute it to completion. Completion is
--   defined as the <a>finalize</a> action having completed.
runGraph :: GraphCode a -> a

-- | Convert an entire item collection into an association list. In
--   general, this can only be done from the <a>finalize</a> step and
--   requires selecting a runtime scheduler which supports
--   <i>quiescence</i>, that is, a scheduler that waits for all active
--   steps to complete before executing <a>finalize</a>. (Currently, all
--   schedulers but version 3 support quiescence.)
itemsToList :: (Eq tag, Ord tag, Show tag) => ItemCol tag b -> StepCode [(tag, b)]

-- | Print a message within a step (unsafe side effect).
stepPutStr :: String -> StepCode ()

-- | Print a message within the graph construction code (unsafe side
--   effect).
cncPutStr :: String -> GraphCode ()

-- | An informal identifier of the CnC version presently in use (for
--   example, identifying a scheduler implementation).
cncVariant :: String

-- | "<tt>cncFor start end body</tt>" runs <tt>body</tt> in parallel over
--   the inclusive range <tt>[start..end]</tt>.
--   
--   Frequently, CnC graphs are serial within steps but parallel at the
--   level of the graph. In contrast, <a>cncFor</a> exposes parallelism
--   <i>within a step</i>. Whether the body of the parallel for is doing
--   work, or just spawning work via <a>putt</a>, <a>cncFor</a> can help
--   distribute the work more efficiently.
cncFor :: Int -> Int -> (Int -> StepCode ()) -> StepCode ()

-- | A two dimensional loop.
cncFor2D :: (Int, Int) -> (Int, Int) -> (Int -> Int -> StepCode ()) -> StepCode ()
instance [overlap ok] Typeable EscapeStep
instance [overlap ok] Show EscapeStep
instance [overlap ok] Exception EscapeStep


-- | This module implements the Intel Concurrent Collections (CnC)
--   programming model. The variations of this module (<a>Intel.Cnc3</a>,
--   <a>Intel.Cnc5</a>, <a>Intel.Cnc6</a>, and <a>Intel.Cnc8</a>) each
--   implement the same programming model using different runtime
--   schedulers. All of them internally use the IO monad but expose a pure
--   interface. (The module <a>Intel.CncPure</a> is an alternative
--   implementation that exposes the same interface as this module but is
--   internally pure.)
--   
--   CnC is a data-flow like deterministic parallel programming model. To
--   use it, one constructs a <i>CnC graph</i> of computation steps. Steps
--   are arbitrary Haskell functions (which may themselves expose
--   parallelism through <a>par</a>). Edges in the graph are control and
--   data relationships, implemented by <i>tag</i> and <i>item</i>
--   collections respectively.
--   
--   A brief introduction to CnC using this module can be found at
--   <a>http://software.intel.com/en-us/blogs/2010/05/27/announcing-intel-concurrent-collections-for-haskell-01/</a>.
--   General documentation on the CnC model can be found at
--   <a>http://software.intel.com/en-us/articles/intel-concurrent-collections-for-cc/</a>.
module Intel.Cnc

-- | Steps are functions that take a single <tt>tag</tt> as input and
--   perform a computation in the <a>StepCode</a> monad, which may perform
--   <a>put</a>s and <a>get</a>s.
type Step a = a -> StepCode ()

-- | Construct a new item collection.
newItemCol :: (Eq tag, Ord tag, Show tag) => GraphCode (ItemCol tag val)

-- | Construct a new tag collection.
newTagCol :: GraphCode (TagCol tag)

-- | Attach a computation step to a supply of control tags. This adds a new
--   node in the computation graph.
prescribe :: TagCol tag -> Step tag -> GraphCode ()

-- | Put-Tag. Push a control tag out into the computation graph.
putt :: TagCol tag -> tag -> StepCode ()

-- | Put an item. Subsequently, any steps waiting on the item may
--   subsequently execute.
put :: (Eq tag, Ord tag, Show tag) => ItemCol tag val -> tag -> val -> StepCode ()

-- | Get an item. Synchronous read-data operation.
get :: (Eq tag, Ord tag, Show tag) => ItemCol tag val -> tag -> StepCode val

-- | Run an initial step which populates the CnC graph with input tags and
--   items. Presently only a single initialize is allowed within a graph
--   execution.
initialize :: StepCode a -> GraphCode a

-- | Run a final step which collects outputs of the graph that are of
--   interest to the larger application. Presently only a single finalize
--   is allowed within a graph execution.
finalize :: StepCode a -> GraphCode a

-- | Construct a CnC graph and execute it to completion. Completion is
--   defined as the <a>finalize</a> action having completed.
runGraph :: GraphCode a -> a

-- | Convert an entire item collection into an association list. In
--   general, this can only be done from the <a>finalize</a> step and
--   requires selecting a runtime scheduler which supports
--   <i>quiescence</i>, that is, a scheduler that waits for all active
--   steps to complete before executing <a>finalize</a>. (Currently, all
--   schedulers but version 3 support quiescence.)
itemsToList :: (Eq tag, Ord tag, Show tag) => ItemCol tag b -> StepCode [(tag, b)]

-- | Print a message within a step (unsafe side effect).
stepPutStr :: String -> StepCode ()

-- | Print a message within the graph construction code (unsafe side
--   effect).
cncPutStr :: String -> GraphCode ()

-- | An informal identifier of the CnC version presently in use (for
--   example, identifying a scheduler implementation).
cncVariant :: String

-- | "<tt>cncFor start end body</tt>" runs <tt>body</tt> in parallel over
--   the inclusive range <tt>[start..end]</tt>.
--   
--   Frequently, CnC graphs are serial within steps but parallel at the
--   level of the graph. In contrast, <a>cncFor</a> exposes parallelism
--   <i>within a step</i>. Whether the body of the parallel for is doing
--   work, or just spawning work via <a>putt</a>, <a>cncFor</a> can help
--   distribute the work more efficiently.
cncFor :: Int -> Int -> (Int -> StepCode ()) -> StepCode ()

-- | A two dimensional loop.
cncFor2D :: (Int, Int) -> (Int, Int) -> (Int -> Int -> StepCode ()) -> StepCode ()
instance [overlap ok] Show HiddenState5
instance [overlap ok] Show (IO a)
instance [overlap ok] Show (IORef a)
