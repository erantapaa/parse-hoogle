-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Library to handle abstract music
--   
--   This library consists on abstract music manipulation. It also supports
--   interfaces with MusicXML.
@package hamusic
@version 0.1.2.1


-- | This module implements chords
module Music.Analysis.Chord
data Mode
Major :: Mode
Minor :: Mode


-- | Implements interface to Lilypond
module Music.Analysis.Lilypond


-- | This module implements lite interface to Haskore
--   
--   Bugs: - Chords - more than one Divisions(changes duration)
module Music.Analysis.Haskore

module Music.Analysis.ABC
data ABCMusic
ABCMusic :: ABCMetaData -> [ABCMusicData] -> ABCMusic
data ABCMetaData
ABCMetaData :: ABCIndex -> ABCTitle -> ABCMeter -> ABCKey -> ABCL -> ABCMetaData
data ABCIndex
ABCIndex :: String -> ABCIndex
data ABCTitle
ABCTitle :: String -> ABCTitle
data ABCMeter
ABCMeter :: String -> ABCMeter
data ABCKey
ABCKey :: String -> ABCKey
data ABCL
ABCL :: ABCL
data ABCMusicData
Single :: ABCNote -> ABCMusicData
Tuplet :: Int -> [ABCMusicData] -> ABCMusicData
Chord :: [ABCMusicData] -> ABCMusicData
Tie :: ABCMusicData -> ABCMusicData -> ABCMusicData
Slur :: [ABCMusicData] -> ABCMusicData
Staccato :: ABCMusicData -> ABCMusicData
GraceNotes :: [ABCNote] -> ABCMusicData -> ABCMusicData
Symbol :: String -> ABCNote -> ABCMusicData
Bar :: ABCMusicData
data ABCNote
Pitch :: Pitch -> Octave -> Accident -> Duration -> Dotted -> ABCNote
Rest :: Bool -> Duration -> ABCNote
data Pitch
C :: Pitch
D :: Pitch
E :: Pitch
F :: Pitch
G :: Pitch
A :: Pitch
B :: Pitch
data Accident
Accident :: (Maybe Accidental) -> Accident
data Accidental
Sharp :: Int -> Accidental
Natural :: Accidental
Flat :: Int -> Accidental
data Dotted
Increase :: Int -> Dotted
Decrease :: Int -> Dotted
data Octave
Octave :: Int -> Octave
data Duration
Duration :: (Int, Int) -> Duration
instance Eq Duration
instance Eq Octave
instance Eq Dotted
instance Eq Accidental
instance Eq Accident
instance Show Pitch
instance Eq Pitch
instance Eq ABCNote
instance Eq ABCMusicData
instance Eq ABCL
instance Eq ABCKey
instance Eq ABCMeter
instance Eq ABCTitle
instance Eq ABCIndex
instance Eq ABCMetaData
instance Eq ABCMusic
instance Show Duration
instance Show Dotted
instance Show Accidental
instance Show Accident
instance Show Octave
instance Show ABCNote
instance Show ABCMusicData
instance Show ABCL
instance Show ABCKey
instance Show ABCMeter
instance Show ABCTitle
instance Show ABCIndex
instance Show ABCMetaData
instance Show ABCMusic

module Script
data Script
Script :: Script_Attrs -> [Action] -> Script
data Script_Attrs
Script_Attrs :: (Maybe String) -> (Maybe String) -> (Maybe String) -> Script_Attrs
scriptAuthor :: Script_Attrs -> (Maybe String)
scriptDate :: Script_Attrs -> (Maybe String)
scriptDescription :: Script_Attrs -> (Maybe String)
data Action
Action :: Action_Attrs -> [(OneOf7 Filter Reification Stat Parttime Timepart Haskore Midi)] -> Action
data Action_Attrs
Action_Attrs :: String -> (Maybe String) -> (Maybe Action_warnings) -> Action_Attrs
actionInput :: Action_Attrs -> String
actionOutput :: Action_Attrs -> (Maybe String)
actionWarnings :: Action_Attrs -> (Maybe Action_warnings)
data Action_warnings
Action_warnings_yes :: Action_warnings
Action_warnings_no :: Action_warnings
data Filter
Filter :: Filter_select -> (Maybe Filter_mode) -> Filter
filterSelect :: Filter -> Filter_select
filterMode :: Filter -> (Maybe Filter_mode)
data Filter_select
Filter_select_note :: Filter_select
Filter_select_note_grace :: Filter_select
Filter_select_note_cue :: Filter_select
Filter_select_note_normal :: Filter_select
data Filter_mode
Filter_mode_yes :: Filter_mode
Filter_mode_no :: Filter_mode
data Reification
Reification :: Reification_value -> Reification
reificationValue :: Reification -> Reification_value
data Reification_value
Reification_value_1 :: Reification_value
Reification_value_2 :: Reification_value
Reification_value_3 :: Reification_value
Reification_value_4 :: Reification_value
Reification_value_5 :: Reification_value
data Stat
Stat :: Stat_Attrs -> [Count] -> Stat
data Stat_Attrs
Stat_Attrs :: (Maybe Stat_verbose) -> Stat_Attrs
statVerbose :: Stat_Attrs -> (Maybe Stat_verbose)
data Stat_verbose
Stat_verbose_yes :: Stat_verbose
Stat_verbose_no :: Stat_verbose
data Count
Count :: Count_select -> Count
countSelect :: Count -> Count_select
data Count_select
Count_select_part :: Count_select
Count_select_measure :: Count_select
Count_select_music_data :: Count_select
Count_select_note :: Count_select
Count_select_note_grace :: Count_select
Count_select_note_cue :: Count_select
Count_select_note_normal :: Count_select
data Parttime
Parttime :: Parttime
data Timepart
Timepart :: Timepart
data Haskore
Haskore :: Haskore
data Midi
Midi :: (Maybe Midi_play) -> Midi
midiPlay :: Midi -> (Maybe Midi_play)
data Midi_play
Midi_play_yes :: Midi_play
Midi_play_no :: Midi_play
instance Eq Midi_play
instance Show Midi_play
instance Eq Midi
instance Show Midi
instance Eq Haskore
instance Show Haskore
instance Eq Timepart
instance Show Timepart
instance Eq Parttime
instance Show Parttime
instance Eq Count_select
instance Show Count_select
instance Eq Count
instance Show Count
instance Eq Stat_verbose
instance Show Stat_verbose
instance Eq Stat_Attrs
instance Show Stat_Attrs
instance Eq Stat
instance Show Stat
instance Eq Reification_value
instance Show Reification_value
instance Eq Reification
instance Show Reification
instance Eq Filter_mode
instance Show Filter_mode
instance Eq Filter_select
instance Show Filter_select
instance Eq Filter
instance Show Filter
instance Eq Action_warnings
instance Show Action_warnings
instance Eq Action_Attrs
instance Show Action_Attrs
instance Eq Action
instance Show Action
instance Eq Script_Attrs
instance Show Script_Attrs
instance Eq Script
instance Show Script
instance XmlAttrType Midi_play
instance XmlAttributes Midi
instance XmlContent Midi
instance HTypeable Midi
instance XmlContent Haskore
instance HTypeable Haskore
instance XmlContent Timepart
instance HTypeable Timepart
instance XmlContent Parttime
instance HTypeable Parttime
instance XmlAttrType Count_select
instance XmlAttributes Count
instance XmlContent Count
instance HTypeable Count
instance XmlAttrType Stat_verbose
instance XmlAttributes Stat_Attrs
instance XmlContent Stat
instance HTypeable Stat
instance XmlAttrType Reification_value
instance XmlAttributes Reification
instance XmlContent Reification
instance HTypeable Reification
instance XmlAttrType Filter_mode
instance XmlAttrType Filter_select
instance XmlAttributes Filter
instance XmlContent Filter
instance HTypeable Filter
instance XmlAttrType Action_warnings
instance XmlAttributes Action_Attrs
instance XmlContent Action
instance HTypeable Action
instance XmlAttributes Script_Attrs
instance XmlContent Script
instance HTypeable Script


-- | This module implements common types
module Music.Analysis.Base

-- | Number is Double
type Number = Double

-- | Delta type is a number
type Delta = Number

-- | Text is String
type Text = String

-- | Integer Number definition
type IntegerNumber = Int

-- | Ratio Number definition
type RatioNumber = Ratio IntegerNumber

-- | wrapper to get Integer Number
toInteger :: Number -> IntegerNumber

-- | wrapper to get Ratio Number
toRatio :: IntegerNumber -> RatioNumber

-- | Invariant class specification
class Invariant a
invariant :: (Invariant a) => a -> Bool

-- | like <tt>unzip</tt>
unzipMaybe :: [Maybe (a, b)] -> ([Maybe a], [Maybe b])

-- | like <tt>zip</tt>
zipMaybe :: ([Maybe a], [Maybe b]) -> [Maybe (a, b)]


module Music.Analysis.MusicXML.Level1
type Score_Partwise = [Music_Data]
data Music_Data
Music_Data_1 :: Note -> Music_Data
type Note = (Note_, Maybe Type, [Dot], Maybe Accidental)
data Note_
Note_3 :: Full_Note -> Note_
type Full_Note = Full_Note_
data Full_Note_
Full_Note_1 :: Pitch -> Full_Note_
Full_Note_3 :: Rest -> Full_Note_
type Pitch = (Step, Maybe Alter, Octave)
data Step
C :: Step
D :: Step
E :: Step
F :: Step
G :: Step
A :: Step
B :: Step
type Alter = Number
type Octave = IntegerNumber
type Rest = ()
type Type = Type_
data Type_
Long :: Type_
Breve :: Type_
Whole :: Type_
Half :: Type_
Quarter :: Type_
Eighth :: Type_
Th16 :: Type_
Th32 :: Type_
Th64 :: Type_
Th128 :: Type_
Th256 :: Type_
type Dot = ()
type Accidental = Accidental_
data Accidental_
Sharp :: Accidental_
Natural :: Accidental_
Flat :: Accidental_
Double_Sharp :: Accidental_
Sharp_Sharp :: Accidental_
Flat_Flat :: Accidental_
Natural_Sharp :: Accidental_
Natural_Flat :: Accidental_
Quarter_Sharp :: Accidental_
Quarter_Flat :: Accidental_
Three_Quarters_Sharp :: Accidental_
Three_Quarters_Flat :: Accidental_
instance Eq Accidental_
instance Show Accidental_
instance Ord Accidental_
instance Enum Accidental_
instance Eq Type_
instance Show Type_
instance Ord Type_
instance Enum Type_
instance Eq Step
instance Show Step
instance Ord Step
instance Enum Step
instance Eq Full_Note_
instance Show Full_Note_
instance Eq Note_
instance Show Note_
instance Eq Music_Data
instance Show Music_Data

module Music.Analysis.MusicXML.Level1Num
type Score_Partwise = [Music_Data]
data Music_Data
Music_Data_1 :: Note -> Music_Data
type Note = (Note_, Maybe Type, [Dot], Maybe Accidental)
data Note_
Note_3 :: Full_Note -> Note_
type Full_Note = Full_Note_
data Full_Note_
Full_Note_1 :: Pitch -> Full_Note_
Full_Note_3 :: Rest -> Full_Note_
type Pitch = (IntegerNumber, Maybe Alter)
type Alter = Number
type Rest = ()
type Type = Type_
type Type_ = IntegerNumber
type Dot = ()
type Accidental = Accidental_
type Accidental_ = IntegerNumber
instance Eq Full_Note_
instance Show Full_Note_
instance Eq Note_
instance Show Note_
instance Eq Music_Data
instance Show Music_Data


-- | This module implements Point-Free library
module Music.Analysis.PF

-- | split
split :: (a -> b) -> (a -> c) -> a -> (b, c)

-- | product
(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)

-- | the 0-adic split
(!) :: a -> ()

-- | fst
p1 :: (a, b) -> a

-- | snd
p2 :: (a, b) -> b

-- | Left
i1 :: a -> Either a b

-- | Right
i2 :: b -> Either a b

-- | sum
(-|-) :: (a -> b) -> (c -> d) -> Either a c -> Either b d

-- | McCarthy's conditional:
cond :: (b -> Bool) -> (b -> c) -> (b -> c) -> b -> c

-- | ap
ap :: (a -> b, a) -> b

-- | expn
expn :: (b -> c) -> (a -> b) -> a -> c

-- | guard
grd :: (a -> Bool) -> a -> Either a a

-- | swap
swap :: (a, b) -> (b, a)

-- | assoc right
assocr :: ((a, b), c) -> (a, (b, c))

-- | assoc left
assocl :: (a, (b, c)) -> ((a, b), c)

-- | dist right
distr :: (a, Either b c) -> Either (a, b) (a, c)

-- | undist right
undistr :: Either (a, b) (a, c) -> (a, Either b c)

-- | flat right
flatr :: (a, (b, c)) -> (a, b, c)

-- | flat left
flatl :: ((a, b), c) -> (a, b, c)

-- | unflat right
unflatr :: (a, b, c) -> (a, (b, c))

-- | unflat left
unflatl :: (a, b, c) -> ((a, b), c)

-- | pair with nil
pwnil :: a -> (a, ())

-- | coswap
coswap :: Either a b -> Either b a

-- | coassoc right
coassocr :: Either (Either a b) c -> Either a (Either b c)

-- | maybe 2 Either
maybe2either :: Maybe a -> Either () a

-- | either 2 maybe
either2maybe :: Either () a -> Maybe a

-- | Binding to either2maybe
e2m :: Either () a -> Maybe a

-- | Binding to maybe2either
m2e :: Maybe a -> Either () a

-- | out
outL :: [a] -> Maybe (a, [a])

-- | catamorphism
cataL :: (Maybe (a, c) -> c) -> [a] -> c

-- | in
inL :: Maybe (a, [a]) -> [a]

-- | anamorphism
anaL :: (c -> Maybe (a, c)) -> c -> [a]

-- | hylomorphism
hyloL :: (Maybe (c, b) -> b) -> (a -> Maybe (c, a)) -> a -> b

-- | mapping
mapL :: (a -> b) -> [a] -> [b]

-- | concat
concatL :: [[a]] -> [a]

-- | reverse
reverseL :: [a] -> [a]

-- | out
outL1 :: [a] -> Maybe (Either a (a, [a]))

-- | catamorphism
cataL1 :: (Maybe (Either a (a, c)) -> c) -> [a] -> c

-- | in
inL1 :: Maybe (Either a (a, [a])) -> [a]

-- | anamorphism
anaL1 :: (c -> Maybe (Either a (a, c))) -> c -> [a]

-- | hylomorphism
hyloL1 :: (Maybe (Either d (c, b)) -> b) -> (a -> Maybe (Either d (c, a))) -> a -> b


-- | This module implements configurations
module Music.Analysis.Abstract.Settings

-- | Definition of Settings to make general configurations It is possible
--   grow
type Settings = Map Text (Bool, Either Text Number)

-- | empty configurations
empty :: Settings

-- | fromList
fromList :: [(Text, (Bool, Either Text Number))] -> Settings

-- | wrapper to settings
text' :: Text -> (Bool, Either Text Number)
text :: Text -> Bool -> (Bool, Either Text Number)

-- | wrapper to settings
number' :: Number -> (Bool, Either Text Number)
number :: Number -> Bool -> (Bool, Either Text Number)
priority :: Bool

-- | Get value from configuration
getSettings :: Text -> Settings -> Maybe (Either Text Number)
changeSettings' :: Text -> (Bool, Either Text Number) -> Settings -> Settings
changeSettings :: Text -> (Bool -> (Bool, Either Text Number)) -> Settings -> Settings

-- | get Text value from Configurations
getText :: Text -> Settings -> Maybe Text

-- | get Number value from Configurations
getNumber :: Text -> Settings -> Maybe Number

-- | Change Text
changeText :: Text -> Text -> Settings -> Settings

-- | Change Number
changeNumber :: Text -> Number -> Settings -> Settings

-- | Union
union :: Settings -> Settings -> Settings
union1 :: Settings -> Settings -> Settings


-- | This module implements a generic Motive
module Music.Analysis.Abstract.Motive

-- | Motive Definition
data Motive a
Motive :: (Settings, [a]) -> Motive a

-- | make new motive
mkMotive :: Settings -> [a] -> Motive a

-- | get Internal Motive representation
fromMotive :: Motive a -> (Settings, [a])

-- | get Motive from internal representation
toMotive :: (Settings, [a]) -> Motive a
meta :: (Settings -> Settings) -> Motive a -> Motive a

-- | General cata
cataMotive :: b -> (Settings -> (a, b) -> b) -> Motive a -> (Settings, b)

-- | General map
mapMotive :: (Settings -> a -> b) -> Motive a -> Motive b

-- | join Pair of Motive into Motive of Pair
joinMotivePair :: (Motive a, Motive b) -> Motive (a, b)

-- | Split Motive of Pair into Pair of Motive
splitMotivePair :: Motive (a, b) -> (Motive a, Motive b)

-- | join List of Motive into Motive of List
joinMotiveList :: [Motive a] -> Motive [a]

-- | split Motive of List into List of Motive
splitMotiveList :: (Eq a) => Motive [a] -> [Motive a]
instance (Eq a) => Eq (Motive a)
instance (Show a) => Show (Motive a)
instance (Read a) => Read (Motive a)


-- | This module implements Melodic Motive
module Music.Analysis.Abstract.Melodic

-- | Melodic node
type Pitch = Number
type MelodicNode = Maybe (Delta, Accident)
type MelodicRelative = Maybe (Delta, Accident)
type MelodicAbsolute = Maybe (Pitch, Accident)
type MelodicClass = Maybe (PitchClass, Accident)

-- | Accident is defined as number <i>provisional</i>. It doesn't support
--   natural (only supports flats and sharps) To supports sharps, flats and
--   natural, it will be <tt>Maybe Number</tt> This number is number of
--   half-tones.
type Accident = Maybe Number
data AccidentClass
DoubleSharp :: AccidentClass
Sharp :: AccidentClass
Natural :: AccidentClass
Flat :: AccidentClass
DoubleFlat :: AccidentClass
UnknowAccident :: Text -> AccidentClass

-- | Pitch Class definition
data PitchClass

-- | C
C :: PitchClass

-- | D
D :: PitchClass

-- | E
E :: PitchClass

-- | F
F :: PitchClass

-- | G
G :: PitchClass

-- | A
A :: PitchClass

-- | B
B :: PitchClass

-- | MelodicNode with PitchClass
type MelodicClassNode = Maybe (PitchClass, Accident)

-- | default settings
settings :: Settings

-- | rest combinator
rest :: b -> ((Delta, Accident) -> b) -> MelodicNode -> b

-- | Default rest
mkRest :: MelodicNode

-- | default non-rest
mkNoRest :: MelodicNode

-- | Transforms 7-number into Char notation
pitch :: (Number, Accident) -> (IntegerNumber, (PitchClass, Accident))

-- | Transforms 7-number into Char notation
pitch' :: (Number, Accident) -> (PitchClass, Accident)

-- | Transforms Char into 7-Number notation
absPitch :: (PitchClass, Accident) -> (Number, Accident)

-- | Transpose to 12 level
transpose12 :: Number -> MelodicAbsolute -> MelodicAbsolute

-- | transforms 7 level to 12-level notation
f7to12 :: (Number, Accident) -> (Number, Accident)

-- | transforms 12-level into 7-level notation
f12to7 :: (Number, Accident) -> (Number, Accident)

-- | Transposes over 7 absolute level
transpose :: Number -> Motive MelodicAbsolute -> Motive MelodicAbsolute

-- | Reverse
reverse :: Motive MelodicNode -> Motive MelodicNode

-- | symmetric melodic
symmetric :: Number -> Motive MelodicAbsolute -> Motive MelodicAbsolute

-- | Convert to alpha notation
toAlpha :: Motive MelodicAbsolute -> Motive (Maybe (IntegerNumber, (PitchClass, Accident)))

-- | Convert to alpha notation
toAlpha' :: Motive MelodicNode -> Motive MelodicClassNode

-- | get 7-Absolute music from alpha notation
fromAlpha :: Motive MelodicClassNode -> Motive MelodicAbsolute

-- | Convert 7-absolute into 12-absolute notation
to12 :: Motive MelodicAbsolute -> Motive MelodicAbsolute

-- | Convert 12-absolute into 7-absolute notation
from12 :: Motive MelodicAbsolute -> Motive MelodicAbsolute

-- | relative melodic.
relative :: Motive MelodicAbsolute -> Motive MelodicRelative

-- | absolute PF
absolute :: Motive MelodicRelative -> Motive MelodicAbsolute
instance Eq PitchClass
instance Show PitchClass
instance Read PitchClass
instance Eq AccidentClass
instance Show AccidentClass


-- | This module implements Rhythm Motive
module Music.Analysis.Abstract.Rhythm

-- | Rhythm node
type RhythmNode = (Delta, Dots)
type RhythmAbsolute = (RatioNumber, Dots)
type RhythmRelative = (RatioNumber, Dots)

-- | Dots is defined by number. Only Integers and positive numbers are
--   allowed.
type Dots = IntegerNumber
type Duration = Number
data DurationClass
Whole :: DurationClass
Half :: DurationClass
Quarter :: DurationClass
Eighth :: DurationClass
Th16 :: DurationClass
Th32 :: DurationClass
Th64 :: DurationClass
UnkownDuration :: Text -> DurationClass

-- | sefault settings
settings :: Settings

-- | computes duration <i>PW</i>
durationNode :: RhythmNode -> Number

-- | computes compass duration
compass :: (Number, Number) -> Number

-- | changes duration
tempo :: RatioNumber -> Motive RhythmAbsolute -> Motive RhythmAbsolute

-- | computes duration
duration :: Motive RhythmNode -> Number

-- | reverse
reverse :: Motive RhythmNode -> Motive RhythmNode

-- | symmetric trsnformation
symmetric :: RatioNumber -> Motive RhythmAbsolute -> Motive RhythmAbsolute

-- | Computes relative Rhythm
relative :: Motive RhythmAbsolute -> Motive RhythmRelative

-- | Absolute PF
absolute :: Motive RhythmRelative -> Motive RhythmAbsolute
durationNumber :: DurationClass -> Duration
durationTotalNumber :: (DurationClass, Dots) -> Duration
getDurationClass :: (Duration, Dots) -> DurationClass
getDuration :: (DurationClass, Dots) -> Duration
getDuration_aux1 :: DurationClass -> Duration
instance Eq DurationClass
instance Show DurationClass


-- | This module join Melodic and Rhythm
module Music.Analysis.Abstract.Zip

-- | VoiceZipNode definition
type VoiceZipNode = (MelodicNode, RhythmNode)
type VoiceZipAbsolute = (MelodicAbsolute, RhythmAbsolute)
type VoiceZipRelative = (MelodicRelative, RhythmRelative)

-- | default settings
settings :: Settings

-- | transposes
transpose :: Number -> Motive VoiceZipAbsolute -> Motive VoiceZipAbsolute

-- | changes duration
tempo :: Number -> Motive VoiceZipAbsolute -> Motive VoiceZipAbsolute

-- | computes duration
duration :: Motive VoiceZipNode -> Number

-- | reverse
reverse :: Motive VoiceZipNode -> Motive VoiceZipNode

-- | relative
relative :: Motive VoiceZipAbsolute -> Motive VoiceZipRelative

-- | absolute
absolute :: Motive VoiceZipRelative -> Motive VoiceZipAbsolute


-- | This module implements specific music notation
module Music.Analysis.Abstract.Notations

-- | Info
type NotationInfo = Either Text Number

-- | New Notation Node
type NotationNode = [(NotationPosition, NotationInfo)]

-- | New Notation Position
type NotationPosition = Maybe Position

-- | Position
type Position = Number

-- | sefault settings
settings :: Settings
addNotation :: NotationPosition -> NotationInfo -> NotationNode -> NotationNode

-- | transpose using above layers
transpose :: Number -> Motive (VoiceZipAbsolute, NotationNode) -> Motive (VoiceZipAbsolute, NotationNode)

-- | tempo transformation using above layers
tempo :: Number -> Motive (VoiceZipAbsolute, NotationNode) -> Motive (VoiceZipAbsolute, NotationNode)

-- | duration computation using above layers
duration :: Motive (VoiceZipNode, NotationNode) -> Number

-- | reverse using above layers
reverse :: Motive (VoiceZipNode, NotationNode) -> Motive (VoiceZipNode, NotationNode)

-- | relative transformation using above layers
relative :: Motive (VoiceZipAbsolute, NotationNode) -> Motive (VoiceZipRelative, NotationNode)

-- | absolute transformation using above layers
absolute :: Motive (VoiceZipRelative, NotationNode) -> Motive (VoiceZipAbsolute, NotationNode)
instance Invariant NotationPosition


-- | This module implements multiple voices
module Music.Analysis.Abstract.Voices
type MultiVoiceNode = ((VoiceZipNode, IntegerNumber), NotationNode)
type MultiVoiceAbsolute = ((VoiceZipAbsolute, IntegerNumber), NotationNode)
type MultiVoiceRelative = ((VoiceZipRelative, IntegerNumber), NotationNode)

-- | default settings
settings :: Settings
joinVoices :: IntegerNumber -> (a, NotationNode) -> ((a, IntegerNumber), NotationNode)
splitVoices :: ((a, IntegerNumber), NotationNode) -> (IntegerNumber, (a, NotationNode))

-- | Transpose using above layers
transpose :: Number -> Motive MultiVoiceAbsolute -> Motive MultiVoiceAbsolute

-- | tempo transformation using above layers
tempo :: Number -> Motive MultiVoiceAbsolute -> Motive MultiVoiceAbsolute

-- | duration computation using above layers
duration :: Motive MultiVoiceNode -> Number

-- | reverse using above layers
reverse :: Motive MultiVoiceNode -> Motive MultiVoiceNode

-- | absolute transformation using above layers
absolute :: Motive MultiVoiceRelative -> Motive MultiVoiceAbsolute

-- | relative transformation using above layers
relative :: Motive MultiVoiceAbsolute -> Motive MultiVoiceRelative


-- | This module implements multiple instruments
module Music.Analysis.Abstract.Instruments
type MultiInstrumentNode = [MultiVoiceNode]
type MultiInstrumentAbsolute = [MultiVoiceAbsolute]
type MultiInstrumentRelative = [MultiVoiceRelative]

-- | default settings
settings :: Settings

-- | Transpose using above layers
transpose :: Number -> Motive MultiInstrumentAbsolute -> Motive MultiInstrumentAbsolute

-- | tempo transformation using above layers
tempo :: Number -> Motive MultiInstrumentAbsolute -> Motive MultiInstrumentAbsolute

-- | duration computation using above layers
duration :: Motive MultiInstrumentNode -> [Number]

-- | reverse using above layers
reverse :: Motive MultiInstrumentNode -> Motive MultiInstrumentNode

-- | absolute transformation using above layers
absolute :: Motive MultiInstrumentRelative -> Motive MultiInstrumentAbsolute

-- | relative transformation using above layers
relative :: Motive MultiInstrumentAbsolute -> Motive MultiInstrumentRelative


-- | This module implements annotation over music notation
module Music.Analysis.Abstract.Annotation
type A = Text
type Annot = ([((((MelodicNode, A), (RhythmNode, A)), Bool), [((NotationPosition, NotationInfo), A)])], A)
type AnnotationNode = [(Maybe Number, Text)]

-- | Definition of annotation
type MultiAnnotationNode = (MultiInstrumentNode, AnnotationNode)
type AnnotationAbsolute = (MultiInstrumentAbsolute, AnnotationNode)
type AnnotationRelative = (MultiInstrumentRelative, AnnotationNode)

-- | sefault settings
settings :: Settings

-- | Transpose using above layers
transpose :: Number -> Motive AnnotationAbsolute -> Motive AnnotationAbsolute

-- | tempo transformation using above layers
tempo :: Number -> Motive AnnotationAbsolute -> Motive AnnotationAbsolute

-- | duration computation using above layers
duration :: Motive MultiAnnotationNode -> [Number]

-- | reverse using above layers
reverse :: Motive MultiAnnotationNode -> Motive MultiAnnotationNode

-- | absolute transformation using above layers
absolute :: Motive AnnotationRelative -> Motive AnnotationAbsolute

-- | relative transformation using above layers
relative :: Motive AnnotationAbsolute -> Motive AnnotationRelative


-- | This module implements common types
module Music.Analysis.Abstract

module Music.Analysis.MusicXML.Level2
type Score_Partwise = [Measure]
type Measure = [Music_Data]
data Music_Data
Music_Data_1 :: Note -> Music_Data
Music_Data_5 :: Attributes -> Music_Data
type Note = (Note_, Maybe Type, [Dot], Maybe Accidental)
data Note_
Note_3 :: (Full_Note, Duration) -> Note_
type Full_Note = Full_Note_
data Full_Note_
Full_Note_1 :: Pitch -> Full_Note_
Full_Note_3 :: Rest -> Full_Note_
type Pitch = (Step, Maybe Alter, Octave)
type Duration = IntegerNumber
type Type = Type_
type Dot = ()
type Accidental = Accidental_
type Attributes = (Maybe Divisions, [Key], [Time], [Clef])
type Divisions = IntegerNumber
type Key = (Key_, [Key_Octave])
data Key_
Key_1 :: (Fifths, Maybe Mode) -> Key_
Key_2 :: [(Key_Step, Key_Alter)] -> Key_
type Fifths = IntegerNumber
data Mode
Major :: Mode
Minor :: Mode
Dorian :: Mode
Phrygian :: Mode
Lydian :: Mode
Mixolydian :: Mode
Aeolian :: Mode
Ionian :: Mode
Locrian :: Mode
type Key_Step = Step
type Key_Alter = Alter
type Key_Octave = Octave
type Time = Time_B
data Time_B
Time_5 :: [(Beats, Beat_Type)] -> Time_B

-- | MusicXML Schema specify <a>xs:string</a>
type Beats = (IntegerNumber, Maybe IntegerNumber)

-- | MusicXML Schema specify <a>xs:string</a>
type Beat_Type = IntegerNumber
type Clef = (Sign, Maybe Line, Maybe Clef_Octave_Change)
data Sign
Clef_Sign_G :: Sign
Clef_Sign_F :: Sign
Clef_Sign_C :: Sign
Clef_Sign_Percussion :: Sign
Clef_Sign_TAB :: Sign
Clef_Sign_None :: Sign
type Line = IntegerNumber
type Clef_Octave_Change = IntegerNumber
abst_Score_Partwise :: Score_Partwise -> Score_Partwise
abst_Music_Data :: Music_Data -> Maybe Music_Data
abst_Note :: Note -> Note
abst_Note_ :: Note_ -> Note_
abst_Full_Note :: Full_Note -> Full_Note
abst_Full_Note_ :: Full_Note_ -> Full_Note_
abst_Pitch :: Pitch -> Pitch
abst_Type :: Type -> Type
abst_Dot :: Dot -> Dot
abst_Accidental :: Accidental -> Accidental
split_Measure :: Measure -> ((), [Maybe Music_Data])
split_Music_Data :: Music_Data -> (Music_Data, Maybe Music_Data)
split_Note :: Note -> (Note, Note)
split_Note_ :: Note_ -> (Duration, Full_Note_)
split_Full_Note :: Full_Note -> (Full_Note, Full_Note)
split_Full_Note_ :: Full_Note_ -> (Full_Note_, Full_Note_)
split_Pitch :: Pitch -> (Pitch, Pitch)
split_Type :: Type -> (Type, Type)
split_Dot :: Dot -> (Dot, Dot)
split_Accidental :: Accidental -> (Accidental, Accidental)
instance Eq Sign
instance Show Sign
instance Enum Sign
instance Eq Time_B
instance Show Time_B
instance Eq Mode
instance Show Mode
instance Eq Key_
instance Show Key_
instance Eq Full_Note_
instance Show Full_Note_
instance Eq Note_
instance Show Note_
instance Eq Music_Data
instance Show Music_Data


-- | This module implements common types
module Music.Analysis.MusicXML2Abstract
mk_Music :: Score_Partwise -> Motive (MelodicClass, RhythmAbsolute)
mk_MusicData :: [Music_Data] -> [(MelodicClass, RhythmAbsolute)]
mk_Note :: Note -> (MelodicClass, RhythmAbsolute)
mk_MelodicNode :: Full_Note -> Maybe Accidental -> MelodicClass
mk_Pitch :: Step -> PitchClass
mk_RhythmNode :: Duration -> Maybe Type -> [Dot] -> RhythmAbsolute


-- | This module implements functions on MusicXML format
module Music.Analysis.MusicXML.Functions
isNote :: Music_Data_ -> Bool
isGraceNote :: Note -> Bool
isCueNote :: Note -> Bool
isNormalNote :: Note -> Bool
filterNote :: Music_Data -> Music_Data
filterNotNote :: Music_Data -> Music_Data
filterGraceNote :: Music_Data -> Music_Data
filterNotGraceNote :: Music_Data -> Music_Data
filterCueNote :: Music_Data -> Music_Data
filterNotCueNote :: Music_Data -> Music_Data
filterNormalNote :: Music_Data -> Music_Data
filterNotNormalNote :: Music_Data -> Music_Data
filterNote' :: (Note -> Bool) -> Music_Data -> Music_Data
count_part :: MusicXMLDoc -> Int
count_measure :: MusicXMLDoc -> Int
count_music_data :: MusicXMLDoc -> Int
count_note :: MusicXMLDoc -> Int
count_note_grace :: MusicXMLDoc -> Int
count_note_cue :: MusicXMLDoc -> Int
count_note_normal :: MusicXMLDoc -> Int
mapMusicXML :: (Music_Data -> Music_Data) -> MusicXMLDoc -> MusicXMLDoc

module Music.Analysis.MusicXML.Level2Num
type Score_Partwise = [Measure]
type Measure = [Music_Data]
data Music_Data
Music_Data_1 :: Note -> Music_Data
Music_Data_5 :: Attributes -> Music_Data
type Note = (Note_, Maybe Type, [Dot], Maybe Accidental)
data Note_
Note_3 :: (Full_Note, Duration) -> Note_
type Full_Note = Full_Note_
data Full_Note_
Full_Note_1 :: Pitch -> Full_Note_
Full_Note_3 :: Rest -> Full_Note_
type Pitch = Pitch
type Duration = IntegerNumber
type Type = Type_
type Dot = ()
type Accidental = Accidental_
type Attributes = (Maybe Divisions, [Key], [Time], [Clef])
type Divisions = IntegerNumber
type Key = (Key_, [IntegerNumber])
data Key_
Key_1 :: (Fifths, Maybe Mode) -> Key_
Key_2 :: [(IntegerNumber, Number)] -> Key_
type Fifths = IntegerNumber
data Mode
Major :: Mode
Minor :: Mode
Dorian :: Mode
Phrygian :: Mode
Lydian :: Mode
Mixolydian :: Mode
Aeolian :: Mode
Ionian :: Mode
Locrian :: Mode
type Time = Time_B
data Time_B
Time_5 :: [(Beats, Beat_Type)] -> Time_B

-- | MusicXML Schema specify <a>xs:string</a>
type Beats = (IntegerNumber, Maybe IntegerNumber)

-- | MusicXML Schema specify <a>xs:string</a>
type Beat_Type = IntegerNumber
type Clef = (Sign, Maybe Line, Maybe Clef_Octave_Change)
type Sign = IntegerNumber
type Line = IntegerNumber
type Clef_Octave_Change = IntegerNumber
abst_Score_Partwise :: Score_Partwise -> Score_Partwise
abst_Music_Data :: Music_Data -> Maybe Music_Data
abst_Note :: Note -> Note
abst_Note_ :: Note_ -> Note_
abst_Full_Note :: Full_Note -> Full_Note
abst_Full_Note_ :: Full_Note_ -> Full_Note_
abst_Pitch :: Pitch -> Pitch
abst_Type :: Type -> Type
abst_Dot :: Dot -> Dot
abst_Accidental :: Accidental -> Accidental
split_Measure :: Measure -> ((), [Maybe Music_Data])
split_Music_Data :: Music_Data -> (Music_Data, Maybe Music_Data)
split_Note :: Note -> (Note, Note)
split_Note_ :: Note_ -> (Duration, Full_Note_)
split_Full_Note :: Full_Note -> (Full_Note, Full_Note)
split_Full_Note_ :: Full_Note_ -> (Full_Note_, Full_Note_)
split_Pitch :: Pitch -> (Pitch, Pitch)
split_Type :: Type -> (Type, Type)
split_Dot :: Dot -> (Dot, Dot)
split_Accidental :: Accidental -> (Accidental, Accidental)
instance Eq Time_B
instance Show Time_B
instance Eq Mode
instance Show Mode
instance Eq Key_
instance Show Key_
instance Eq Full_Note_
instance Show Full_Note_
instance Eq Note_
instance Show Note_
instance Eq Music_Data
instance Show Music_Data

module Music.Analysis.MusicXML.Level3Num
type Score_Partwise = (Document_Attributes, (Score_Header, [Part]))
type Part = [Measure]
type Measure = [Music_Data]
data Music_Data
Music_Data_1 :: Note -> Music_Data
Music_Data_2 :: Backup -> Music_Data
Music_Data_3 :: Forward -> Music_Data
Music_Data_5 :: Attributes -> Music_Data
Music_Data_10 :: Barline -> Music_Data
type Barline = Barline
type Note = (Note_, Maybe Instrument, Editorial_Voice, Maybe Type, [Dot], Maybe Accidental, Maybe Staff)
data Note_
Note_3 :: (Full_Note, Duration) -> Note_
type Full_Note = (Maybe Chord, Full_Note_)
data Full_Note_
Full_Note_1 :: Pitch -> Full_Note_
Full_Note_3 :: Rest -> Full_Note_
type Rest = ()
type Duration = IntegerNumber
type Editorial_Voice = Editorial_Voice
type Instrument = Instrument
type Type = Type_
type Dot = Dot
type Accidental = Accidental_

-- | positive number
type Staff = IntegerNumber
type Attributes = (Maybe Divisions, [Key], [Time], Maybe Staves, Maybe Instruments, [Clef], Maybe Transpose)
type Editorial = Editorial
type Divisions = IntegerNumber
type Key = (Key_, [IntegerNumber])
data Key_
Key_1 :: (Maybe Cancel, Fifths, Maybe Mode) -> Key_
Key_2 :: [(IntegerNumber, Number)] -> Key_
type Time = Time_B
data Time_B
Time_5 :: [(Beats, Beat_Type)] -> Time_B
Time_6 :: Senza_Misura -> Time_B

-- | MusicXML Schema specify <a>xs:string</a>
type Beats = (IntegerNumber, Maybe IntegerNumber)

-- | MusicXML Schema specify <a>xs:string</a>
type Beat_Type = IntegerNumber
type Staves = Staves
type Part_Symbol = Part_Symbol
type Instruments = Instruments
type Clef = Clef
type Staff_Details = Staff_Details
type Transpose = Transpose
type Directive = Directive
type Measure_Style = Measure_Style
abst_Score_Partwise :: Score_Partwise -> Score_Partwise
abst_Measure :: Measure -> Measure
abst_Music_Data :: Music_Data -> Maybe Music_Data
abst_Note :: Note -> Note
abst_Note_ :: Note_ -> Note_
abst_Full_Note :: Full_Note -> Full_Note
abst_Full_Note_ :: Full_Note_ -> Full_Note_
abst_Duration :: Duration -> Duration
abst_Type :: Type -> Type
abst_Dot :: Dot -> Dot
abst_Accidental :: Accidental -> Accidental
abst_Divisions :: Divisions -> Divisions
abst_Attributes :: Attributes -> Attributes
abst_Key :: Key -> Key
abst_Key_ :: Key_ -> Key_
abst_Time :: Time -> Time
abst_Clef :: Clef -> Clef
map_Score_Partwise :: (Music_Data -> Music_Data) -> Score_Partwise -> Score_Partwise
map_Part :: (Music_Data -> Music_Data) -> Part -> Part
map_Measure :: (Music_Data -> Music_Data) -> Measure -> Measure
map_Music_Data :: (Music_Data -> Music_Data) -> Music_Data -> Music_Data
instance Eq Time_B
instance Show Time_B
instance Eq Key_
instance Show Key_
instance Eq Full_Note_
instance Show Full_Note_
instance Eq Note_
instance Show Note_
instance Eq Music_Data
instance Show Music_Data

module Music.Analysis.MusicXML.Level3
type Score_Partwise = (Document_Attributes, (Score_Header, [Part]))
type Part = [Measure]
type Measure = [Music_Data]
data Music_Data
Music_Data_1 :: Note -> Music_Data
Music_Data_2 :: Backup -> Music_Data
Music_Data_3 :: Forward -> Music_Data
Music_Data_5 :: Attributes -> Music_Data
Music_Data_10 :: Barline -> Music_Data
type Barline = Barline
type Note = (Note_, Maybe Instrument, Editorial_Voice, Maybe Type, [Dot], Maybe Accidental, Maybe Staff)
data Note_
Note_3 :: (Full_Note, Duration) -> Note_
type Full_Note = (Maybe Chord, Full_Note_)
data Full_Note_
Full_Note_1 :: Pitch -> Full_Note_
Full_Note_3 :: Rest -> Full_Note_
type Rest = ()
type Duration = IntegerNumber
type Editorial_Voice = Editorial_Voice
type Instrument = Instrument
type Type = Type_
type Dot = Dot
type Accidental = Accidental_

-- | positive number
type Staff = IntegerNumber
type Attributes = (Maybe Divisions, [Key], [Time], Maybe Staves, Maybe Instruments, [Clef], Maybe Transpose)
type Editorial = Editorial
type Divisions = IntegerNumber
type Key = (Key_, [Key_Octave])
data Key_
Key_1 :: (Maybe Cancel, Fifths, Maybe Mode) -> Key_
Key_2 :: [(Key_Step, Key_Alter)] -> Key_
type Time = Time_B
data Time_B
Time_5 :: [(Beats, Beat_Type)] -> Time_B
Time_6 :: Senza_Misura -> Time_B

-- | MusicXML Schema specify <a>xs:string</a>
type Beats = (IntegerNumber, Maybe IntegerNumber)

-- | MusicXML Schema specify <a>xs:string</a>
type Beat_Type = IntegerNumber
type Staves = Staves
type Part_Symbol = Part_Symbol
type Instruments = Instruments
type Clef = Clef
type Staff_Details = Staff_Details
type Transpose = Transpose
type Directive = Directive
type Measure_Style = Measure_Style
abst_Score_Partwise :: Score_Partwise -> Score_Partwise
abst_Measure :: Measure -> Measure
abst_Music_Data :: Music_Data -> Maybe Music_Data
abst_Note :: Note -> Note
abst_Note_ :: Note_ -> Note_
abst_Full_Note :: Full_Note -> Full_Note
abst_Full_Note_ :: Full_Note_ -> Full_Note_
abst_Duration :: Duration -> Duration
abst_Type :: Type -> Type
abst_Dot :: Dot -> Dot
abst_Accidental :: Accidental -> Accidental
abst_Divisions :: Divisions -> Divisions
abst_Attributes :: Attributes -> Attributes
abst_Key :: Key -> Key
abst_Key_ :: Key_ -> Key_
abst_Time :: Time -> Time
abst_Clef :: Clef -> Clef
map_Score_Partwise :: (Music_Data -> b) -> Score_Partwise -> (Document_Attributes, (Score_Header, [[[b]]]))
map_Part :: (Music_Data -> b) -> Part -> [[b]]
map_Measure :: (Music_Data -> b) -> Measure -> [b]
map_Music_Data :: (Music_Data -> b) -> Music_Data -> b
toNum_Music_Data :: Music_Data -> Music_Data
toNum_Note :: Note -> Note
toNum_Full_Note :: Full_Note -> Full_Note
toNum_Attributes :: Attributes -> Attributes
toNum_Key :: Key -> Key
toNum_Mode :: Mode -> Mode
toNum_Time :: Time -> Time
toNum_Clef :: Clef -> Clef
instance Eq Time_B
instance Show Time_B
instance Eq Key_
instance Show Key_
instance Eq Full_Note_
instance Show Full_Note_
instance Eq Note_
instance Show Note_
instance Eq Music_Data
instance Show Music_Data

module Music.Analysis.MusicXML.Level4
type Score_Partwise = (Document_Attributes, (Score_Header, [Part]))
type Part = [Measure]
type Measure = [Music_Data]
data Music_Data
Music_Data_1 :: Note -> Music_Data
Music_Data_2 :: Backup -> Music_Data
Music_Data_3 :: Forward -> Music_Data
Music_Data_4 :: Direction -> Music_Data
Music_Data_5 :: Attributes -> Music_Data
Music_Data_6 :: Harmony -> Music_Data
Music_Data_7 :: Figured_Bass -> Music_Data
Music_Data_8 :: Print -> Music_Data
Music_Data_9 :: Sound -> Music_Data
Music_Data_10 :: Barline -> Music_Data
Music_Data_11 :: Grouping -> Music_Data
Music_Data_12 :: Link -> Music_Data
Music_Data_13 :: Bookmark -> Music_Data
type Note = (Note_, Maybe Instrument, Editorial_Voice, Maybe Type, [Dot], Maybe Accidental, Maybe Time_Modification, Maybe Stem, Maybe Notehead, Maybe Staff, [Beam], [Notations], [Lyric])
data Note_
Note_1 :: (Grace, Full_Note, Maybe (Tie, Maybe Tie)) -> Note_
Note_2 :: (Cue, Full_Note, Duration) -> Note_
Note_3 :: (Full_Note, Duration, Maybe (Tie, Maybe Tie)) -> Note_
type Grace = Grace
type Cue = Cue
type Tie = Tie
type Full_Note = (Maybe Chord, Full_Note_)
data Full_Note_
Full_Note_1 :: Pitch -> Full_Note_
Full_Note_2 :: Unpitched -> Full_Note_
Full_Note_3 :: Rest -> Full_Note_
type Unpitched = Unpitched
type Rest = Rest
type Duration = IntegerNumber
type Editorial_Voice = Editorial_Voice
type Instrument = Instrument
type Type = Type_
type Dot = Dot
type Accidental = Accidental_
type Time_Modification = Time_Modification
type Stem = Stem
type Notehead = Notehead
type Beam = Beam

-- | positive number
type Staff = IntegerNumber
type Lyric = Lyric
type Notations = Notations
type Attributes = (Editorial, Maybe Divisions, [Key], [Time], Maybe Staves, Maybe Part_Symbol, Maybe Instruments, [Clef], [Staff_Details], Maybe Transpose, [Directive], [Measure_Style])
type Editorial = Editorial
type Divisions = IntegerNumber
type Key = (Key_, [Key_Octave])
data Key_
Key_1 :: (Maybe Cancel, Fifths, Maybe Mode) -> Key_
Key_2 :: [(Key_Step, Key_Alter)] -> Key_
type Time = Time_B
type Staves = Staves
type Part_Symbol = Part_Symbol
type Instruments = Instruments
type Clef = (Sign, Maybe Line, Maybe Clef_Octave_Change)
type Staff_Details = Staff_Details
type Transpose = Transpose
type Directive = Directive
type Measure_Style = Measure_Style
abst_Score_Partwise :: Score_Partwise -> Score_Partwise
abst_Part :: Part -> Part
abst_Measure :: Measure -> Measure
abst_Music_Data :: Music_Data -> Maybe Music_Data
abst_Note :: Note -> Maybe Note
abst_Note_ :: Note_ -> Maybe Note_
abst_Full_Note :: Full_Note -> Maybe Full_Note
abst_Full_Note_ :: Full_Note_ -> Maybe Full_Note_
abst_Duration :: Duration -> Duration
abst_Editorial_Voice :: Editorial_Voice -> Editorial_Voice
abst_Instrument :: Instrument -> Instrument
abst_Type :: Type -> Type
abst_Dot :: Dot -> Dot
abst_Accidental :: Accidental -> Accidental
abst_Staff :: Staff -> Staff
abst_Editorial :: Editorial -> Editorial
abst_Divisions :: Divisions -> Divisions
abst_Staves :: Staves -> Staves
abst_Attributes :: Attributes -> Attributes
abst_Key :: Key -> Key
abst_Key_ :: Key_ -> Key_
abst_Time :: Time -> Time
abst_Part_Symbol :: Part_Symbol -> Part_Symbol
abst_Instruments :: Instruments -> Instruments
abst_Clef :: Clef -> Clef
abst_Staff_Details :: Staff_Details -> Staff_Details
abst_Transpose :: Transpose -> Transpose
abst_Directive :: Directive -> Directive
abst_Measure_Style :: Measure_Style -> Measure_Style
rep_Score_Partwise :: Score_Partwise -> Score_Partwise
rep_Part :: Part -> Part
rep_Measure :: Measure -> Measure
rep_Music_Data :: Music_Data -> Music_Data
rep_Note :: Note -> Note
rep_Note_ :: Note_ -> Note_
rep_Full_Note :: Full_Note -> Full_Note
rep_Full_Note_ :: Full_Note_ -> Full_Note_
rep_Duration :: Duration -> Duration
rep_Editorial_Voice :: Editorial_Voice -> Editorial_Voice
rep_Instrument :: Instrument -> Instrument
rep_Type :: Type -> Type
rep_Dot :: Dot -> Dot
rep_Accidental :: Accidental -> Accidental
rep_Staff :: Staff -> Staff
rep_Editorial :: Editorial -> Editorial
rep_Divisions :: Divisions -> Divisions
rep_Staves :: Staves -> Staves
rep_Attributes :: Attributes -> Attributes
rep_Key :: Key -> Key
rep_Key_ :: Key_ -> Key_
rep_Time :: Time -> Time
rep_Part_Symbol :: Part_Symbol -> Part_Symbol
rep_Instruments :: Instruments -> Instruments
rep_Clef :: Clef -> Clef
rep_Staff_Details :: Staff_Details -> Staff_Details
rep_Transpose :: Transpose -> Transpose
rep_Directive :: Directive -> Directive
rep_Measure_Style :: Measure_Style -> Measure_Style
map_Score_Partwise :: (Music_Data -> Music_Data) -> Score_Partwise -> Score_Partwise
map_Part :: (Music_Data -> Music_Data) -> Part -> Part
map_Measure :: (Music_Data -> Music_Data) -> Measure -> Measure
map_Music_Data :: (Music_Data -> Music_Data) -> Music_Data -> Music_Data
instance Eq Key_
instance Show Key_
instance Eq Full_Note_
instance Show Full_Note_
instance Eq Note_
instance Show Note_
instance Eq Music_Data
instance Show Music_Data

module Music.Analysis.MusicXML.Level5
type Score_Partwise = (Document_Attributes, (Score_Header, [Part]))
type Part = (ID, [Measure])
type Measure = ((CDATA, Maybe Yes_No, Maybe Yes_No, Maybe Tenths), [Music_Data])
data Music_Data
Music_Data_1 :: Note -> Music_Data
Music_Data_2 :: Backup -> Music_Data
Music_Data_3 :: Forward -> Music_Data
Music_Data_4 :: Direction -> Music_Data
Music_Data_5 :: Attributes -> Music_Data
Music_Data_6 :: Harmony -> Music_Data
Music_Data_7 :: Figured_Bass -> Music_Data
Music_Data_8 :: Print -> Music_Data
Music_Data_9 :: Sound -> Music_Data
Music_Data_10 :: Barline -> Music_Data
Music_Data_11 :: Grouping -> Music_Data
Music_Data_12 :: Link -> Music_Data
Music_Data_13 :: Bookmark -> Music_Data
type Note = ((Print_Style, Printout, Maybe CDATA, Maybe CDATA, Maybe CDATA, Maybe CDATA, Maybe CDATA, Maybe Yes_No), (Note_, Maybe Instrument, Editorial_Voice, Maybe Type, [Dot], Maybe Accidental, Maybe Time_Modification, Maybe Stem, Maybe Notehead, Maybe Staff, [Beam], [Notations], [Lyric]))
data Note_
Note_1 :: (Grace, Full_Note, Maybe (Tie, Maybe Tie)) -> Note_
Note_2 :: (Cue, Full_Note, Duration) -> Note_
Note_3 :: (Full_Note, Duration, Maybe (Tie, Maybe Tie)) -> Note_
type Grace = Grace
type Cue = Cue
type Tie = Tie
type Full_Note = (Maybe Chord, Full_Note_)
data Full_Note_
Full_Note_1 :: Pitch -> Full_Note_
Full_Note_2 :: Unpitched -> Full_Note_
Full_Note_3 :: Rest -> Full_Note_
type Duration = IntegerNumber
type Editorial_Voice = Editorial_Voice
type Instrument = Instrument
type Type = (Maybe Symbol_Size, Type_)
type Dot = Dot
type Accidental = ((Maybe Yes_No, Maybe Yes_No, Level_Display, Print_Style), Accidental_)
type Time_Modification = Time_Modification
type Stem = Stem
type Notehead = Notehead
type Beam = Beam

-- | positive number
type Staff = IntegerNumber
type Lyric = Lyric
type Notations = Notations
type Attributes = (Editorial, Maybe Divisions, [Key], [Time], Maybe Staves, Maybe Part_Symbol, Maybe Instruments, [Clef], [Staff_Details], Maybe Transpose, [Directive], [Measure_Style])
type Editorial = Editorial
type Divisions = IntegerNumber
type Key = ((Maybe CDATA, Print_Style, Print_Object), (Key_, [Key_Octave]))
data Key_
Key_1 :: (Maybe Cancel, Fifths, Maybe Mode) -> Key_
Key_2 :: [(Key_Step, Key_Alter)] -> Key_
type Key_Octave = ((CDATA, Maybe Yes_No), Octave)
type Time = ((Maybe CDATA, Maybe Time_A, Print_Style, Print_Object), Time_B)
type Staves = Staves
type Part_Symbol = Part_Symbol
type Instruments = Instruments
type Clef = ((Maybe CDATA, Maybe Yes_No, Maybe Symbol_Size, Print_Style, Print_Object), (Sign, Maybe Line, Maybe Clef_Octave_Change))
type Staff_Details = Staff_Details
type Transpose = Transpose
type Directive = Directive
type Measure_Style = Measure_Style
abst_Score_Partwise :: Score_Partwise -> Score_Partwise
abst_Part :: Part -> Part
abst_Measure :: Measure -> Measure
abst_Music_Data :: Music_Data -> Music_Data
abst_Note :: Note -> Note
abst_Note_ :: Note_ -> Note_
abst_Grace :: Grace -> Grace
abst_Cue :: Cue -> Cue
abst_Tie :: Tie -> Tie
abst_Full_Note :: Full_Note -> Full_Note
abst_Full_Note_ :: Full_Note_ -> Full_Note_
abst_Duration :: Duration -> Duration
abst_Editorial_Voice :: Editorial_Voice -> Editorial_Voice
abst_Instrument :: Instrument -> Instrument
abst_Type :: Type -> Type
abst_Dot :: Dot -> Dot
abst_Accidental :: Accidental -> Accidental
abst_Time_Modification :: Time_Modification -> Time_Modification
abst_Stem :: Stem -> Stem
abst_Notehead :: Notehead -> Notehead
abst_Beam :: Beam -> Beam
abst_Staff :: Staff -> Staff
abst_Notations :: Notations -> Notations
abst_Editorial :: Editorial -> Editorial
abst_Divisions :: Divisions -> Divisions
abst_Key_Octave :: Key_Octave -> Key_Octave
abst_Staves :: Staves -> Staves
abst_Attributes :: Attributes -> Attributes
abst_Lyric :: Lyric -> Lyric
abst_Key :: Key -> Key
abst_Key_ :: Key_ -> Key_
abst_Time :: Time -> Time
abst_Part_Symbol :: Part_Symbol -> Part_Symbol
abst_Instruments :: Instruments -> Instruments
abst_Clef :: Clef -> Clef
abst_Staff_Details :: Staff_Details -> Staff_Details
abst_Transpose :: Transpose -> Transpose
abst_Directive :: Directive -> Directive
abst_Measure_Style :: Measure_Style -> Measure_Style
empty_Print_Style :: Print_Style
empty_Printout :: Printout
empty_Level_Display :: Level_Display
rep_Score_Partwise :: Score_Partwise -> Score_Partwise
rep_Part :: Part -> Part
rep_Measure :: Measure -> Measure
rep_Music_Data :: Music_Data -> Music_Data
rep_Note :: Note -> Note
rep_Note_ :: Note_ -> Note_
rep_Grace :: Grace -> Grace
rep_Cue :: Cue -> Cue
rep_Tie :: Tie -> Tie
rep_Full_Note :: Full_Note -> Full_Note
rep_Full_Note_ :: Full_Note_ -> Full_Note_
rep_Duration :: Duration -> Duration
rep_Editorial_Voice :: Editorial_Voice -> Editorial_Voice
rep_Instrument :: Instrument -> Instrument
rep_Type :: Type -> Type
rep_Dot :: Dot -> Dot
rep_Accidental :: Accidental -> Accidental
rep_Time_Modification :: Time_Modification -> Time_Modification
rep_Stem :: Stem -> Stem
rep_Notehead :: Notehead -> Notehead
rep_Beam :: Beam -> Beam
rep_Staff :: Staff -> Staff
rep_Notations :: Notations -> Notations
rep_Editorial :: Editorial -> Editorial
rep_Divisions :: Divisions -> Divisions
rep_Key_Octave :: Key_Octave -> Key_Octave
rep_Staves :: Staves -> Staves
rep_Attributes :: Attributes -> Attributes
rep_Lyric :: Lyric -> Lyric
rep_Key :: Key -> Key
rep_Key_ :: Key_ -> Key_
rep_Time :: Time -> Time
rep_Part_Symbol :: Part_Symbol -> Part_Symbol
rep_Instruments :: Instruments -> Instruments
rep_Clef :: Clef -> Clef
rep_Staff_Details :: Staff_Details -> Staff_Details
rep_Transpose :: Transpose -> Transpose
rep_Directive :: Directive -> Directive
rep_Measure_Style :: Measure_Style -> Measure_Style
map_Score_Partwise :: (Music_Data -> Music_Data) -> Score_Partwise -> Score_Partwise
map_Part :: (Music_Data -> Music_Data) -> Part -> Part
map_Measure :: (Music_Data -> Music_Data) -> Measure -> Measure
map_Music_Data :: (Music_Data -> Music_Data) -> Music_Data -> Music_Data
instance Eq Key_
instance Show Key_
instance Eq Full_Note_
instance Show Full_Note_
instance Eq Note_
instance Show Note_
instance Eq Music_Data
instance Show Music_Data

module Music.Analysis.MusicXML.Level6
type Score_Partwise = (Document_Attributes, (Score_Header, [Part]))
type Part = (ID, [Measure])
type Measure = ((CDATA, Maybe Yes_No, Maybe Yes_No, Maybe Tenths), [Music_Data])
data Music_Data
Music_Data_1 :: Note -> Music_Data
Music_Data_2 :: Backup -> Music_Data
Music_Data_3 :: Forward -> Music_Data
Music_Data_4 :: Direction -> Music_Data
Music_Data_5 :: Attributes -> Music_Data
Music_Data_6 :: Harmony -> Music_Data
Music_Data_7 :: Figured_Bass -> Music_Data
Music_Data_8 :: Print -> Music_Data
Music_Data_9 :: Sound -> Music_Data
Music_Data_10 :: Barline -> Music_Data
Music_Data_11 :: Grouping -> Music_Data
Music_Data_12 :: Link -> Music_Data
Music_Data_13 :: Bookmark -> Music_Data
Music_Data_14 :: Annotation -> Music_Data
type Annotation = (Maybe Start_Stop, PCDATA)
type Note = Note
type Attributes = Attributes
abst_Score_Partwise :: Score_Partwise -> Score_Partwise
abst_Part :: Part -> Part
abst_Measure :: Measure -> Measure
abst_Music_Data :: Music_Data -> Maybe Music_Data
abst_Note :: Note -> Note
abst_Attributes :: Attributes -> Attributes
abst_Annotation :: Annotation -> Grouping
abst_SSS :: Maybe Start_Stop -> Start_Stop_Single
rep_Score_Partwise :: Score_Partwise -> Score_Partwise
rep_Part :: Part -> Part
rep_Measure :: Measure -> Measure
rep_Music_Data :: Music_Data -> Music_Data
rep_Note :: Note -> Note
rep_Attributes :: Attributes -> Attributes
rep_Annotation :: Grouping -> Either Annotation Grouping
rep_SSS :: Start_Stop_Single -> Maybe Start_Stop
map_Score_Partwise :: (Music_Data -> Music_Data) -> Score_Partwise -> Score_Partwise
map_Part :: (Music_Data -> Music_Data) -> Part -> Part
map_Measure :: (Music_Data -> Music_Data) -> Measure -> Measure
map_Music_Data :: (Music_Data -> Music_Data) -> Music_Data -> Music_Data
instance Eq Music_Data
instance Show Music_Data


-- | This module make interface with MusicXML using HaXML library.
module Music.Analysis.MusicXML
toTimewise :: Score_Partwise -> Score_Timewise
toPartwise :: Score_Timewise -> Score_Partwise
transpose :: [(a, [(b, c)])] -> [(b, [(a, c)])]
abst_Score_Partwise :: Score_Partwise -> Score_Partwise
abst_Part :: Part -> Part
abst_Measure :: Measure -> Measure
abst_Music_Data :: Music_Data_ -> Music_Data
abst_Note :: Note -> Note
abst_Note_ :: Note_ -> Note_
abst_Grace :: Grace -> Grace
abst_Cue :: Cue -> Cue
abst_Instrument :: Instrument -> Instrument
abst_Duration :: Duration -> Duration
abst_Full_Note :: Full_Note -> Full_Note
abst_Full_Note_ :: Full_Note_ -> Full_Note_
abst_Pitch :: Pitch -> Pitch
abst_Step :: Step -> Maybe Step
abst_Alter :: Alter -> Maybe Alter
abst_Octave :: Octave -> Octave
abst_Unpitched :: Unpitched -> Unpitched
abst_Rest :: Rest -> Rest
abst_Tie :: Tie -> Tie
abst_Editorial_Voice :: Editorial_Voice -> Editorial_Voice
abst_Type :: Type -> Maybe Type
abst_Type_ :: PCDATA -> Maybe Type_
abst_Dot :: Dot -> Dot
abst_Accidental :: Accidental -> Maybe Accidental
abst_Accidental_ :: PCDATA -> Maybe Accidental_
abst_Time_Modification :: Time_Modification -> Time_Modification
abst_Stem :: Stem -> Stem
abst_Notehead :: Notehead -> Notehead
abst_Staff :: Staff -> Staff
abst_Beam :: Beam -> Beam
abst_Notations :: Notations -> Notations
abst_Lyric :: Lyric -> Lyric
abst_Attributes :: Attributes -> Attributes
abst_Editorial :: Editorial -> Editorial
abst_Divisions :: Divisions -> Divisions
abst_Key :: Key -> Key
abst_Key_ :: Key_ -> Key_
abst_Fifths :: Fifths -> Fifths
abst_Mode :: Mode -> Maybe Mode
abst_Key_Step :: Key_Step -> Key_Step
abst_Key_Alter :: Key_Alter -> Key_Alter
abst_Key_Octave :: Key_Octave -> Key_Octave
abst_Time :: Time -> Time
abst_Time_B :: Time_B -> Time_B
abst_Beats :: Beats -> Beats
abst_Beat_Type :: Beat_Type -> Beat_Type
abst_Staves :: Staves -> Staves
abst_Part_Symbol :: Part_Symbol -> Part_Symbol
abst_Instruments :: Instruments -> Instruments
abst_Clef :: Clef -> Clef
abst_Sign :: Sign -> Maybe Sign
abst_Line :: Line -> Line
abst_Clef_Octave_Change :: Clef_Octave_Change -> Clef_Octave_Change
abst_Staff_Details :: Staff_Details -> Staff_Details
abst_Transpose :: Transpose -> Transpose
abst_Directive :: Directive -> Directive
abst_Measure_Style :: Measure_Style -> Measure_Style
rep_Score_Partwise :: Score_Partwise -> Score_Partwise
rep_Part :: Part -> Part
rep_Measure :: Measure -> Measure
rep_Music_Data :: Music_Data -> Music_Data_
rep_Note :: Note -> Note
rep_Note_ :: Note_ -> Note_
rep_Grace :: Grace -> Grace
rep_Cue :: Cue -> Cue
rep_Instrument :: Instrument -> Instrument
rep_Duration :: Duration -> Duration
rep_Full_Note :: Full_Note -> Full_Note
rep_Full_Note_ :: Full_Note_ -> Full_Note_
rep_Pitch :: Pitch -> Pitch
rep_Step :: Step -> Step
rep_Alter :: Alter -> Alter
rep_Octave :: Octave -> Octave
rep_Unpitched :: Unpitched -> Unpitched
rep_Rest :: Rest -> Rest
rep_Tie :: Tie -> Tie
rep_Editorial_Voice :: Editorial_Voice -> Editorial_Voice
rep_Type :: Type -> Type
rep_Type_ :: Type_ -> PCDATA
rep_Dot :: Dot -> Dot
rep_Accidental :: Accidental -> Accidental
rep_Accidental_ :: Accidental_ -> PCDATA
rep_Time_Modification :: Time_Modification -> Time_Modification
rep_Stem :: Stem -> Stem
rep_Notehead :: Notehead -> Notehead
rep_Staff :: Staff -> Staff
rep_Beam :: Beam -> Beam
rep_Notations :: Notations -> Notations
rep_Lyric :: Lyric -> Lyric
rep_Attributes :: Attributes -> Attributes
rep_Editorial :: Editorial -> Editorial
rep_Divisions :: Divisions -> Divisions
rep_Key :: Key -> Key
rep_Key_ :: Key_ -> Key_
rep_Fifths :: Fifths -> Fifths
rep_Mode :: Mode -> Mode
rep_Key_Step :: Key_Step -> Key_Step
rep_Key_Alter :: Key_Alter -> Key_Alter
rep_Key_Octave :: Key_Octave -> Key_Octave
rep_Time :: Time -> Time
rep_Time_B :: Time_B -> Time_B
rep_Beats :: Beats -> Beats
rep_Beat_Type :: Beat_Type -> Beat_Type
rep_Staves :: Staves -> Staves
rep_Part_Symbol :: Part_Symbol -> Part_Symbol
rep_Instruments :: Instruments -> Instruments
rep_Clef :: Clef -> Clef
rep_Sign :: Sign -> Sign
rep_Line :: Line -> Line
rep_Clef_Octave_Change :: Clef_Octave_Change -> Clef_Octave_Change
rep_Staff_Details :: Staff_Details -> Staff_Details
rep_Transpose :: Transpose -> Transpose
rep_Directive :: Directive -> Directive
rep_Measure_Style :: Measure_Style -> Measure_Style
dur_Duration :: String -> IntegerNumber
dur_Backup :: Backup -> IntegerNumber -> IntegerNumber
dur_Forward :: Forward -> IntegerNumber -> IntegerNumber
dur_Note_ :: Note_ -> IntegerNumber -> IntegerNumber
dur_Note :: Note -> IntegerNumber -> IntegerNumber
dur_Attributes :: Attributes -> Maybe Divisions
dur_Divisions :: Maybe a -> Maybe a
dur_Music_Data_ :: Music_Data_ -> (Divisions, IntegerNumber) -> (Divisions, IntegerNumber)
map_Score_Partwise' :: (Music_Data_ -> Music_Data_) -> Score_Partwise -> Score_Partwise
map_Part' :: (Music_Data_ -> Music_Data_) -> Part -> Part
map_Measure' :: (Music_Data_ -> Music_Data_) -> Measure -> Measure
map_Music_Data' :: (Music_Data_ -> Music_Data_) -> Music_Data_ -> Music_Data_
read_Number :: String -> Maybe Number
read_IntegerNumber :: String -> Maybe IntegerNumber
coread_Number :: String -> Either Number String
coread_IntegerNumber :: String -> Either IntegerNumber String

-- | get offset from music_data elements
getOffSet :: Music_Data_ -> IntegerNumber

-- | generic sort of Music_Data
arrangeBy :: (Ord b, Num b) => (a -> b) -> [a] -> [[((b, Integer), a)]]

-- | sort of Music_Data
arrange :: Music_Data -> [[((IntegerNumber, Integer), Music_Data_)]]


-- | This module implements
module Music.Analysis.Abstract2ABC
mk_Music :: Motive (MelodicClass, RhythmAbsolute) -> ABCMusic
mk_Meta :: Motive (MelodicClass, RhythmAbsolute) -> ABCMetaData
mk_Notes :: Motive (MelodicClass, RhythmAbsolute) -> [ABCMusicData]
mk_Note :: (MelodicClass, RhythmAbsolute) -> ABCNote
mk_Duration :: RhythmAbsolute -> (Duration, Dotted)
mk_Note' :: MelodicClass -> Maybe (Pitch, Accident)
mk_Pitch :: PitchClass -> Pitch
mk_Accident :: Accident -> Accident


-- | Implements interface to Lilypond
module Music.Analysis.Abstract2Lilypond
output :: VoiceZipNode -> String
outputDots :: IntegerNumber -> String
outputAccidents :: Accident -> String


-- | This module implements lite interface to Haskore
--   
--   Bugs: - Chords - more than one Divisions(changes duration)
module Music.Analysis.MusicXML2Haskore
from_Score_Partwise :: Score_Partwise -> Score_Partwise
from_Part :: Part -> Part
from_Measure :: Measure -> Measure
from_Music_Data :: Music_Data_ -> Music_Data_
from_Note :: Note -> Note
group_Part :: Part -> [[[[Note]]]]
group_Measure :: Measure -> [[[[Note]]]]
toNote :: [Music_Data_] -> [Note]
group_Music_Data_ :: (Note -> Note -> Bool) -> Music_Data_ -> Music_Data_ -> Bool
group_Instrument :: Note -> Note -> Bool
group_Voice :: Note -> Note -> Bool
group_Staff :: Note -> Note -> Bool
cmp_Instrument :: Note -> Note -> Ordering
cmp_Voice :: Note -> Note -> Ordering
cmp_Staff :: Note -> Note -> Ordering
get_Instrument :: Note -> Maybe Instrument
get_Voice :: Note -> Maybe Voice
get_Staff :: Note -> Maybe Staff
group_Measure' :: Measure -> [(Maybe Instrument, [(Maybe Staff, [(Maybe Voice, [Note])])])]
headM :: (Monad m) => [m a] -> m a
toMedium_ :: [[[[T control a]]]] -> T control a
toMedium :: [[[[a]]]] -> T control a
toMedium' :: [(Maybe Instrument, [(Maybe Staff, [(Maybe Voice, [Note])])])] -> T ControlID Note
data ControlID
Control_Instrument :: (Maybe Instrument) -> ControlID
Control_Staff :: (Maybe Staff) -> ControlID
Control_Voice :: (Maybe Voice) -> ControlID
abst_Step :: Step -> Maybe Step
abst_Octave :: Octave -> Octave
abst_Alter :: Alter -> Maybe Alter
toClass :: Step -> Maybe Alter -> Class
abst_Pitch :: Pitch -> (Octave, Class)
abst_Full_Note_ :: Full_Note_ -> Maybe T
abst_Full_Note :: Full_Note -> Maybe T
abst_Note_ :: Note_ -> (Maybe T, Maybe Duration)
abst_Duration :: Duration -> Duration
toDur :: Duration -> Dur
abst_Note :: Note -> T T
abst_Note' :: Note -> T Note
measure2haskore :: Measure -> T Note
part2haskore :: Part -> T Note
partwise2haskore :: Score_Partwise -> T Note
toMidi :: MusicXMLDoc -> T
saveMidi :: FilePath -> T -> IO ()
playMidi :: FilePath -> T -> IO ExitCode
playGeneric :: FilePath -> IO ExitCode
instance Eq ControlID
instance Show ControlID


module Music.Analysis.Script
procFilter :: Filter -> MusicXMLDoc -> MusicXMLDoc
onlyPartwise :: (Score_Partwise -> Score_Partwise) -> MusicXMLDoc -> MusicXMLDoc
procReification :: Reification -> Score_Partwise -> Score_Partwise
procCount :: Count -> MusicXMLDoc -> (String, Int)
procStat :: Stat -> MusicXMLDoc -> String
procParttime :: a -> MusicXMLDoc -> MusicXMLDoc
procTimepart :: a -> MusicXMLDoc -> MusicXMLDoc
procHaskore :: a -> MusicXMLDoc -> String
procMidi :: Midi -> MusicXMLDoc -> Either T ()
procWarn :: Maybe Action_warnings -> Bool
procOutput :: Maybe FilePath -> Either (Either MusicXMLDoc String) (Either T ()) -> IO ()
fromError :: Result a -> String
procAction_ :: [OneOf7 Filter Reification Stat Parttime Timepart Haskore Midi] -> MusicXMLDoc -> Either (Either MusicXMLDoc String) (Either T ())
procAction :: Action -> IO ()
procScript :: Script -> IO ()


-- | This module implements
module Music.Analysis.MusicXML2ABC
mk_Pitch :: Step -> Pitch
mk_Accident :: Maybe Alter -> Maybe Accidental -> Accident
mk_Duration :: Int -> Duration -> Maybe Type -> [Dot] -> Duration
mk_Octave :: Octave -> Octave
mk_Dotted :: [Dot] -> Dotted
mk_Note :: Int -> Note -> ABCNote
mk_Music :: Score_Partwise -> ABCMusic
mk_MusicDatas :: Int -> [[Music_Data]] -> [ABCMusicData]
mk_MetaData :: Score_Partwise -> ABCMetaData
mk_Title :: Score_Partwise -> ABCTitle
mk_Meter :: Time -> ABCMeter
get_Meter_MusicData :: [Music_Data] -> ABCMeter
get_Meter :: Attributes -> ABCMeter
get_Key_MusicData :: [Music_Data] -> ABCKey
get_Key :: Attributes -> ABCKey
get_KeyN :: Int -> String
get_Key_1b :: Mode -> String
get_Key_adjust :: Mode -> Int
mk_MusicData :: Int -> [Music_Data] -> [ABCMusicData]
get_Divisions :: Attributes -> Maybe Int
get_Divisions_MusicData :: [Music_Data] -> Maybe Int


-- | This module implements interface between Haskell representation and
--   file representation
module Music.Analysis.Interface

-- | makes generic interface
class Interface a
input :: (Interface a) => String -> a
output :: (Interface a) => a -> String

-- | destroy measures
catMeasures :: Motive [a] -> Motive a

-- | build measures
uncatMeasures :: (Measure a) => Motive a -> Motive [a]

-- | Measure class.
class Measure a
nodeDuration :: (Measure a) => a -> Number
instance Measure (((a, RhythmNode), b), c)
instance Measure ((a, RhythmNode), b)
instance Measure (a, RhythmNode)
instance Measure RhythmNode


-- | main module
module Music.Analysis
