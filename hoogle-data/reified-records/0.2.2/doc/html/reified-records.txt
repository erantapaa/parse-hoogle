-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Reify records to Maps and back again
--   
--   This package provides a series of functions to do introspect records
--   and allow records to be manipulated dynamically as <tt>Map</tt>s.
--   Currently this works using <tt>Data.Data</tt> however in future this
--   will likely change to <tt>GHC.Generics</tt> and allow more user hooks
--   into how types are reified and reflected.
@package reified-records
@version 0.2.2

module Data.Generics.Record

-- | A phantom type used to parameterize functions based on records. This
--   let's us avoid passing <tt>undefined</tt>s or manually creating
--   instances all the time. It can only be created for types which are
--   records and is used as a token to most of the API's functions.
data RecordT a

-- | Returns <tt>True</tt> if <tt>a</tt> is a data type with a single
--   constructor and is a record. <tt>a</tt> may be bottom.
isRecord :: Data a => a -> Bool

-- | The smart constructor for <tt>RecordT</tt>s. This will return a
--   <tt>RecordT</tt> if and only if the type is a record.
recordT :: Data a => Maybe (RecordT a)

-- | Returns the fields for the record <tt>a</tt>
fields :: Data a => RecordT a -> [String]

-- | Return a record where all fields are _|_
emptyRecord :: Data a => RecordT a -> a

-- | Return a records structure of as a list of types paired with field
--   names.
recordStructure :: Data a => RecordT a -> [(TypeRep, String)]

module Data.Generics.Record.Reify

-- | Reify a record to a <tt>Map</tt>
reify :: Data a => RecordT a -> a -> Map String Dynamic

-- | If <tt>a</tt> is a record, this will return a <tt>Map</tt> where the
--   keys are the field names and the values are wrapped in <tt>toDyn</tt>.
--   Otherwise <tt>Nothing</tt> will be returned.
reifyMay :: Data a => a -> Maybe (Map String Dynamic)

-- | Reflect a <tt>Map</tt> of strings to an arbitrary type. If the type is
--   a record, each of its field names will be looked up in the record. If
--   any of the types don't match or if <tt>a</tt> isn't a record,
--   <tt>Nothing</tt> will be returned.
reflect :: Data a => Map String Dynamic -> Maybe a

module Data.Generics.Record.Subtype

-- | A witness for a subtyping relation between two records so that <tt> a
--   &lt;: b </tt>
data (:<:) a b

-- | Returns a witness for a subtyping relation for <tt>a</tt> and
--   <tt>b</tt> by traversing the fields of <tt>a</tt> and <tt>b</tt> and
--   pairing each field of <tt>a</tt> with the first one of the same type
--   in <tt>b</tt>.
genSubtype :: (Data a, Data b) => RecordT a -> RecordT b -> Maybe (a :<: b)

-- | Returns true if <tt> a &lt;: b </tt> according to the algorithm for
--   <tt>genSubtype</tt>
isSubtype :: (Data a, Data b) => RecordT a -> RecordT b -> Bool

-- | Upcast a type according to a subtyping witness.
upcast :: (Data a, Data b) => a :<: b -> a -> b
