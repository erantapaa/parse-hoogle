-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Linear algebra and interpolation using the Accelerate framework
--   
@package accelerate-arithmetic
@version 0.0.1

module Data.Array.Accelerate.Arithmetic.LinearAlgebra
type Scalar ix a = Acc (Array ix a)
type Vector ix a = Acc (Array (ix :. Int) a)
type Matrix ix a = Acc (Array ((ix :. Int) :. Int) a)
transpose :: (Shape ix, Slice ix, Elt a) => Matrix ix a -> Matrix ix a
swapIndex :: (Exp ix :. Exp Int) :. Exp Int -> (Exp ix :. Exp Int) :. Exp Int
numElems :: (Shape ix, Slice ix, Elt a) => Vector ix a -> Exp Int
numRows :: (Shape ix, Slice ix, Elt a) => Matrix ix a -> Exp Int
numCols :: (Shape ix, Slice ix, Elt a) => Matrix ix a -> Exp Int
vectorShape :: (Shape ix, Slice ix, Elt a) => Vector ix a -> Exp ix :. Exp Int
matrixShape :: (Shape ix, Slice ix, Elt a) => Matrix ix a -> (Exp ix :. Exp Int) :. Exp Int
withVectorIndex :: (Shape ix, Slice ix, Lift Exp a) => (Exp ix :. Exp Int -> a) -> (Exp (ix :. Int) -> Exp (Plain a))
withMatrixIndex :: (Shape ix, Slice ix, Lift Exp a) => ((Exp ix :. Exp Int) :. Exp Int -> a) -> (Exp ((ix :. Int) :. Int) -> Exp (Plain a))
outer :: (Shape ix, Slice ix, IsNum a, Elt a) => Vector ix a -> Vector ix a -> Matrix ix a
multiplyMatrixVector :: (Shape ix, Slice ix, IsNum a, Elt a) => Matrix ix a -> Vector ix a -> Vector ix a
multiplyMatrixMatrix :: (Shape ix, Slice ix, IsNum a, Elt a) => Matrix ix a -> Matrix ix a -> Matrix ix a
newtonInverseStep :: (Shape ix, Slice ix, IsNum a, Elt a) => Matrix ix a -> Matrix ix a -> Matrix ix a
identity :: (Shape ix, Slice ix, IsNum a, Elt a) => Exp ((ix :. Int) :. Int) -> Matrix ix a
newtonInverse :: (Shape ix, Slice ix, IsNum a, Elt a) => Exp Int -> Matrix ix a -> Matrix ix a -> Matrix ix a
scaleRows :: (Slice ix, Shape ix, Elt a, IsNum a) => Vector ix a -> Matrix ix a -> Matrix ix a
zipScalarVectorWith :: (Slice ix, Shape ix, Elt a, Elt b, Elt c) => (Exp a -> Exp b -> Exp c) -> Scalar ix a -> Vector ix b -> Vector ix c
zipScalarMatrixWith :: (Slice ix, Shape ix, Elt a, Elt b, Elt c) => (Exp a -> Exp b -> Exp c) -> Scalar ix a -> Matrix ix b -> Matrix ix c
columnFromVector :: (Shape ix, Slice ix, Elt a) => Vector ix a -> Matrix ix a

-- | input must be a matrix with exactly one column
vectorFromColumn :: (Shape ix, Slice ix, Elt a) => Matrix ix a -> Vector ix a
flattenMatrix :: (Slice ix, Shape ix, Elt a) => Matrix ix a -> Vector ix a
flattenMatrixBackPermute :: (Slice ix, Shape ix, Elt a) => Matrix ix a -> Vector ix a
flattenMatrixReshape :: (Slice ix, Shape ix, Elt a) => Matrix ix a -> Vector ix a
accDivMod :: Integral a => a -> a -> (a, a)
restoreMatrix :: (Slice ix, Shape ix, Elt a) => Exp Int -> Vector ix a -> Matrix ix a
restoreMatrixBackPermute :: (Slice ix, Shape ix, Elt a) => Exp Int -> Vector ix a -> Matrix ix a
restoreMatrixReshape :: (Slice ix, Shape ix, Elt a) => Exp Int -> Vector ix a -> Matrix ix a
extrudeVector :: (Shape ix, Slice ix, Elt a) => Exp ix -> Vector Z a -> Vector ix a
extrudeMatrix :: (Shape ix, Slice ix, Elt a) => Exp ix -> Matrix Z a -> Matrix ix a
zipExtrudedVectorWith :: (Slice ix, Shape ix, Elt a, Elt b, Elt c) => (Exp a -> Exp b -> Exp c) -> Vector Z a -> Vector ix b -> Vector ix c
zipExtrudedMatrixWith :: (Slice ix, Shape ix, Elt a, Elt b, Elt c) => (Exp a -> Exp b -> Exp c) -> Matrix Z a -> Matrix ix b -> Matrix ix c
gatherFromVector :: (Shape ix, Elt a) => Scalar ix Int -> Vector Z a -> Scalar ix a

module Data.Array.Accelerate.Arithmetic.Sparse

-- | Sparse matrix with a definite number of non-zero entries per column.
data ColumnMatrix ix a
ColumnMatrix :: Exp Int -> Matrix ix (Int, a) -> ColumnMatrix ix a
numRows :: ColumnMatrix ix a -> Exp Int
columnMatrix :: ColumnMatrix ix a -> Matrix ix (Int, a)
realIndex :: (Shape ix, Slice ix, Elt a) => Matrix ix (Int, a) -> Matrix ix (ix :. Int)
multiplyColumnMatrixVector :: (Shape ix, Slice ix, IsNum a, Elt a) => ColumnMatrix ix a -> Vector ix a -> Vector ix a
transposeColumnMatrix :: (Shape ix, Slice ix, IsNum a, Elt a) => ColumnMatrix ix a -> RowMatrix ix a

-- | Sparse matrix with a definite number of non-zero entries per row.
data RowMatrix ix a
RowMatrix :: Exp Int -> Matrix ix (Int, a) -> RowMatrix ix a
numCols :: RowMatrix ix a -> Exp Int
rowMatrix :: RowMatrix ix a -> Matrix ix (Int, a)
multiplyRowMatrixVector :: (Shape ix, Slice ix, IsNum a, Elt a) => RowMatrix ix a -> Vector ix a -> Vector ix a
transposeRowMatrix :: (Shape ix, Slice ix, IsNum a, Elt a) => RowMatrix ix a -> ColumnMatrix ix a
multiplyMatrixMatrix :: (Shape ix, Slice ix, IsNum a, Elt a) => ColumnMatrix ix a -> RowMatrix ix a -> Matrix ix a
matchMatrices :: (Shape ix, Slice ix, IsNum a, Elt a) => Matrix ix (Int, a) -> Matrix ix (Int, a) -> Matrix (ix :. Int) ((Int, Int), a)
scaleRowRows :: (Slice ix, Shape ix, Elt a, IsNum a) => Vector ix a -> RowMatrix ix a -> RowMatrix ix a

module Data.Array.Accelerate.Arithmetic.Interpolation
bisect :: (Slice ix, Shape ix, IsScalar a, Elt a) => Vector ix a -> Scalar ix a -> Scalar ix (Int, Int) -> Scalar ix (Int, Int)
lookupInterval :: (Slice ix, Shape ix, IsScalar a, Elt a) => Vector ix a -> Scalar ix a -> Scalar ix Int

-- | One node before index 0 and three nodes starting from index 0.
type Interpolator13 a = (a, a) -> (a, a) -> (a, a) -> (a, a) -> a -> a
sampleBasisFunctions13 :: (Slice ix, Shape ix, Elt a, IsFloating a, Num a) => Interpolator13 (Exp a) -> Vector Z a -> Vector ix a -> RowMatrix ix a
