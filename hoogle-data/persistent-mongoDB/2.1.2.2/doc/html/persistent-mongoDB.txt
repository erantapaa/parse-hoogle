-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Backend for the persistent library using mongoDB.
--   
@package persistent-mongoDB
@version 2.1.2.2


-- | Use persistent-mongodb the same way you would use other persistent
--   libraries and refer to the general persistent documentation. There are
--   some new MongoDB specific filters under the filters section. These
--   help extend your query into a nested document.
--   
--   However, at some point you will find the normal Persistent APIs
--   lacking. and want lower level-level MongoDB access. There are
--   functions available to make working with the raw driver easier: they
--   are under the Entity conversion section. You should still use the same
--   connection pool that you are using for Persistent.
--   
--   MongoDB is a schema-less database. The MongoDB Persistent backend does
--   not help perform migrations. Unlike SQL backends, uniqueness
--   constraints cannot be created for you. You must place a unique index
--   on unique fields.
module Database.Persist.MongoDB
collectionName :: (PersistEntity record, PersistEntityBackend record ~ MongoContext) => record -> Text
docToEntityEither :: PersistEntity record => Document -> Either Text (Entity record)
docToEntityThrow :: (MonadIO m, PersistEntity record, PersistEntityBackend record ~ MongoContext) => Document -> m (Entity record)

-- | <i>Deprecated: use recordToDocument</i>
entityToDocument :: (PersistEntity record, PersistEntityBackend record ~ MongoContext) => record -> Document

-- | convert a PersistEntity into document fields. unlike
--   <a>toInsertDoc</a>, nulls are included.
recordToDocument :: (PersistEntity record, PersistEntityBackend record ~ MongoContext) => record -> Document
documentFromEntity :: (PersistEntity record, PersistEntityBackend record ~ MongoContext) => Entity record -> Document

-- | convert a PersistEntity into document fields. for inserts only: nulls
--   are ignored so they will be unset in the document.
--   <a>entityToDocument</a> includes nulls
toInsertDoc :: (PersistEntity record, PersistEntityBackend record ~ MongoContext) => record -> Document
entityToInsertDoc :: (PersistEntity record, PersistEntityBackend record ~ MongoContext) => Entity record -> Document
updatesToDoc :: (PersistEntity record, PersistEntityBackend record ~ MongoContext) => [Update record] -> Document
filtersToDoc :: (PersistEntity record, PersistEntityBackend record ~ MongoContext) => [Filter record] -> Document

-- | convert a unique key into a MongoDB document
toUniquesDoc :: PersistEntity record => Unique record -> [Field]

-- | Point to an array field with an embedded object and give a deeper
--   query into the embedded object. Use with <a>nestEq</a>.
(->.) :: PersistEntity emb => EntityField record [emb] -> EntityField emb typ -> NestedField record typ

-- | Point to an array field with an embedded object and give a deeper
--   query into the embedded object. This level of nesting is not the final
--   level. Use <a>-&gt;.</a> or <a>&amp;-&gt;.</a> to point to the final
--   level.
(~>.) :: PersistEntity emb => EntityField record [emb] -> NestedField emb typ -> NestedField record typ

-- | Same as <a>&amp;-&gt;.</a>, but Works against a Maybe type
(?&->.) :: PersistEntity nest => EntityField record (Maybe nest) -> EntityField nest typ -> NestedField record typ

-- | Same as <a>&amp;~&gt;.</a>, but works against a Maybe type
(?&~>.) :: PersistEntity nes1 => EntityField val (Maybe nes1) -> NestedField nes1 nes -> NestedField val nes

-- | Point to a nested field to query. This field is not an array type. Use
--   with <a>nestEq</a>.
(&->.) :: PersistEntity nest => EntityField record nest -> EntityField nest typ -> NestedField record typ

-- | Point to a nested field to query. This field is not an array type.
--   This level of nesting is not the final level. Use <a>-&gt;.</a> or
--   <tt>&amp;&gt;.</tt> to point to the final level.
(&~>.) :: PersistEntity nes1 => EntityField val nes1 -> NestedField nes1 nes -> NestedField val nes

-- | The normal Persistent equality test <a>==.</a> is not generic enough.
--   Instead use this with the drill-down arrow operaters such as
--   <a>-&gt;.</a>
--   
--   using this as the only query filter is similar to the following in the
--   mongoDB shell
--   
--   <pre>
--   db.Collection.find({"object.field": item})
--   </pre>
nestEq :: (PersistField typ, PersistEntityBackend record ~ MongoContext) => NestedField record typ -> typ -> Filter record

-- | The normal Persistent equality test <a>==.</a> is not generic enough.
--   Instead use this with the drill-down arrow operaters such as
--   <a>-&gt;.</a>
--   
--   using this as the only query filter is similar to the following in the
--   mongoDB shell
--   
--   <pre>
--   db.Collection.find({"object.field": item})
--   </pre>
nestNe :: (PersistField typ, PersistEntityBackend record ~ MongoContext) => NestedField record typ -> typ -> Filter record

-- | The normal Persistent equality test <a>==.</a> is not generic enough.
--   Instead use this with the drill-down arrow operaters such as
--   <a>-&gt;.</a>
--   
--   using this as the only query filter is similar to the following in the
--   mongoDB shell
--   
--   <pre>
--   db.Collection.find({"object.field": item})
--   </pre>
nestGe :: (PersistField typ, PersistEntityBackend record ~ MongoContext) => NestedField record typ -> typ -> Filter record

-- | The normal Persistent equality test <a>==.</a> is not generic enough.
--   Instead use this with the drill-down arrow operaters such as
--   <a>-&gt;.</a>
--   
--   using this as the only query filter is similar to the following in the
--   mongoDB shell
--   
--   <pre>
--   db.Collection.find({"object.field": item})
--   </pre>
nestLe :: (PersistField typ, PersistEntityBackend record ~ MongoContext) => NestedField record typ -> typ -> Filter record

-- | The normal Persistent equality test <a>==.</a> is not generic enough.
--   Instead use this with the drill-down arrow operaters such as
--   <a>-&gt;.</a>
--   
--   using this as the only query filter is similar to the following in the
--   mongoDB shell
--   
--   <pre>
--   db.Collection.find({"object.field": item})
--   </pre>
nestIn :: (PersistField typ, PersistEntityBackend record ~ MongoContext) => NestedField record typ -> typ -> Filter record

-- | The normal Persistent equality test <a>==.</a> is not generic enough.
--   Instead use this with the drill-down arrow operaters such as
--   <a>-&gt;.</a>
--   
--   using this as the only query filter is similar to the following in the
--   mongoDB shell
--   
--   <pre>
--   db.Collection.find({"object.field": item})
--   </pre>
nestNotIn :: (PersistField typ, PersistEntityBackend record ~ MongoContext) => NestedField record typ -> typ -> Filter record

-- | Like '(==.)' but for an embedded list. Checks to see if the list
--   contains an item.
--   
--   In Haskell we need different equality functions for embedded fields
--   that are lists or non-lists to keep things type-safe.
--   
--   using this as the only query filter is similar to the following in the
--   mongoDB shell
--   
--   <pre>
--   db.Collection.find({arrayField: arrayItem})
--   </pre>
anyEq :: (PersistField typ, PersistEntityBackend record ~ MongoContext) => EntityField record [typ] -> typ -> Filter record

-- | Like nestEq, but for an embedded list. Checks to see if the nested
--   list contains an item.
nestAnyEq :: (PersistField typ, PersistEntityBackend record ~ MongoContext) => NestedField record [typ] -> typ -> Filter record

-- | same as <a>nestEq</a>, but give a BSON Value
nestBsonEq :: (PersistField typ, PersistEntityBackend record ~ MongoContext) => NestedField record typ -> Value -> Filter record

-- | same as <a>anyEq</a>, but give a BSON Value
anyBsonEq :: (PersistField typ, PersistEntityBackend record ~ MongoContext) => EntityField record [typ] -> Value -> Filter record

-- | <i>Deprecated: Please use anyBsonEq instead</i>
multiBsonEq :: (PersistField typ, PersistEntityBackend record ~ MongoContext) => EntityField record [typ] -> Value -> Filter record

-- | Filter using a Regular expression.
(=~.) :: (MongoRegexSearchable searchable, PersistEntity record, PersistEntityBackend record ~ MongoContext) => EntityField record searchable -> MongoRegex -> Filter record
data NestedField record typ
LastEmbFld :: EntityField record [emb] -> EntityField emb typ -> NestedField record typ
MidEmbFld :: EntityField record [emb] -> NestedField emb typ -> NestedField record typ
MidNestFlds :: EntityField record nest -> NestedField nest typ -> NestedField record typ
MidNestFldsNullable :: EntityField record (Maybe nest) -> NestedField nest typ -> NestedField record typ
LastNestFld :: EntityField record nest -> EntityField nest typ -> NestedField record typ
LastNestFldNullable :: EntityField record (Maybe nest) -> EntityField nest typ -> NestedField record typ

-- | Mark the subset of <a>PersistField</a>s that can be searched by a
--   mongoDB regex Anything stored as PersistText or an array of
--   PersistText would be valid
class PersistField typ => MongoRegexSearchable typ

-- | A MongoRegex represents a Regular expression. It is a tuple of the
--   expression and the options for the regular expression, respectively
--   Options are listed here:
--   <a>http://docs.mongodb.org/manual/reference/operator/query/regex/</a>
--   If you use the same options you may want to define a helper such as
--   <tt>r t = (t, "ims")</tt>
type MongoRegex = (Text, Text)
nestSet :: (PersistField typ, PersistEntityBackend record ~ MongoContext) => NestedField record typ -> typ -> Update record
nestInc :: (PersistField typ, PersistEntityBackend record ~ MongoContext) => NestedField record typ -> typ -> Update record
nestDec :: (PersistField typ, PersistEntityBackend record ~ MongoContext) => NestedField record typ -> typ -> Update record
nestMul :: (PersistField typ, PersistEntityBackend record ~ MongoContext) => NestedField record typ -> typ -> Update record
push :: (PersistField typ, PersistEntityBackend record ~ MongoContext) => EntityField record [typ] -> typ -> Update record
pull :: (PersistField typ, PersistEntityBackend record ~ MongoContext) => EntityField record [typ] -> typ -> Update record
pullAll :: (PersistField typ, PersistEntityBackend record ~ MongoContext) => EntityField record [typ] -> [typ] -> Update record
addToSet :: (PersistField typ, PersistEntityBackend record ~ MongoContext) => EntityField record [typ] -> typ -> Update record

-- | equivalent to $each
--   
--   <pre>
--   eachOp push field []
--   </pre>
--   
--   <tt>eachOp pull</tt> will get translated to <tt>$pullAll</tt>
eachOp :: (PersistField typ, PersistEntityBackend record ~ MongoContext) => (EntityField record [typ] -> typ -> Update record) -> EntityField record [typ] -> [typ] -> Update record
keyToOid :: ToBackendKey MongoContext record => Key record -> ObjectId
oidToKey :: ToBackendKey MongoContext record => ObjectId -> Key record
recordTypeFromKey :: Key record -> record
readMayObjectId :: Text -> Maybe ObjectId

-- | Convert a Text to a Key
readMayMongoKey :: Text -> Maybe (BackendKey MongoContext)
keyToText :: BackendKey MongoContext -> Text
fieldName :: PersistEntity record => EntityField record typ -> Label
withConnection :: (MonadIO m, Applicative m) => MongoConf -> (ConnectionPool -> m b) -> m b
withMongoPool :: (MonadIO m, Applicative m) => MongoConf -> (ConnectionPool -> m b) -> m b
withMongoDBConn :: (MonadIO m, Applicative m) => Database -> HostName -> PortID -> Maybe MongoAuth -> NominalDiffTime -> (ConnectionPool -> m b) -> m b
withMongoDBPool :: (MonadIO m, Applicative m) => Database -> HostName -> PortID -> Maybe MongoAuth -> Int -> Int -> NominalDiffTime -> (ConnectionPool -> m b) -> m b
createMongoDBPool :: (MonadIO m, Applicative m) => Database -> HostName -> PortID -> Maybe MongoAuth -> Int -> Int -> NominalDiffTime -> m ConnectionPool
runMongoDBPool :: (MonadIO m, MonadBaseControl IO m) => AccessMode -> Action m a -> ConnectionPool -> m a

-- | use default <tt>AccessMode</tt>
runMongoDBPoolDef :: (MonadIO m, MonadBaseControl IO m) => Action m a -> ConnectionPool -> m a
type ConnectionPool = Pool Connection
data Connection
data MongoAuth
MongoAuth :: Username -> Password -> MongoAuth

-- | Information required to connect to a mongo database
data MongoConf
MongoConf :: Text -> Text -> PortID -> Maybe MongoAuth -> AccessMode -> Int -> Int -> NominalDiffTime -> Maybe ReplicaSetConfig -> MongoConf
mgDatabase :: MongoConf -> Text
mgHost :: MongoConf -> Text
mgPort :: MongoConf -> PortID
mgAuth :: MongoConf -> Maybe MongoAuth
mgAccessMode :: MongoConf -> AccessMode
mgPoolStripes :: MongoConf -> Int
mgStripeConnections :: MongoConf -> Int
mgConnectionIdleTime :: MongoConf -> NominalDiffTime

-- | YAML fields for this are <tt>rsName</tt> and <tt>rsSecondaries</tt>
--   mgHost is assumed to be the primary
mgReplicaSetConfig :: MongoConf -> Maybe ReplicaSetConfig
defaultMongoConf :: Text -> MongoConf
defaultHost :: Text
defaultAccessMode :: AccessMode
defaultPoolStripes :: Int
defaultConnectionIdleTime :: NominalDiffTime
defaultStripeConnections :: Int

-- | docker integration: change the host to the mongodb link
applyDockerEnv :: MongoConf -> IO MongoConf
type PipePool = Pool Pipe

-- | A pool of plain MongoDB pipes. The database parameter has not yet been
--   applied yet. This is useful for switching between databases (on the
--   same host and port) Unlike the normal pool, no authentication is
--   available
createMongoDBPipePool :: (MonadIO m, Applicative m) => HostName -> PortID -> Int -> Int -> NominalDiffTime -> m PipePool

-- | run a pool created with <a>createMongoDBPipePool</a>
runMongoDBPipePool :: (MonadIO m, MonadBaseControl IO m) => AccessMode -> Database -> Action m a -> PipePool -> m a

-- | Either a host name e.g., <tt>"haskell.org"</tt> or a numeric host
--   address string consisting of a dotted decimal IPv4 address or an IPv6
--   address e.g., <tt>"192.168.0.1"</tt>.
type HostName = String
data PortID :: *
type Database = Text

-- | A monad on top of m (which must be a MonadIO) that may access the
--   database and may fail with a DB <a>Failure</a>
type Action = ReaderT MongoContext

-- | Type of reads and writes to perform
data AccessMode :: *

-- | Read-only action, reading stale data from a slave is OK.
ReadStaleOk :: AccessMode

-- | Read-write action, slave not OK, every write is fire &amp; forget.
UnconfirmedWrites :: AccessMode

-- | Read-write action, slave not OK, every write is confirmed with
--   getLastError.
ConfirmWrites :: GetLastError -> AccessMode

-- | Same as <a>ConfirmWrites</a> []
master :: AccessMode

-- | Same as <a>ReadStaleOk</a>
slaveOk :: AccessMode

-- | Field with given label and typed value
(=:) :: Val v => Label -> v -> Field

-- | A BSON ObjectID is a 12-byte value consisting of a 4-byte timestamp
--   (seconds since epoch), a 3-byte machine id, a 2-byte process id, and a
--   3-byte counter. Note that the timestamp and counter fields must be
--   stored big endian unlike the rest of BSON. This is because they are
--   compared byte-by-byte and we want to ensure a mostly increasing order.
data ObjectId :: *

-- | Values needed when executing a db operation
data MongoContext :: *
instance Show NoOrphanNominalDiffTime
instance Eq NoOrphanNominalDiffTime
instance Num NoOrphanNominalDiffTime
instance Show NoOrphanPortID
instance Eq NoOrphanPortID
instance Show MultiFilter
instance Show MongoAuth
instance Show ReplicaSetConfig
instance Show MongoConf
instance Show MongoUpdateOperator
instance Show MongoUpdateOperation
instance Show typ => Show (UpdateValueOp typ)
instance Show (BackendKey MongoContext)
instance Read (BackendKey MongoContext)
instance Eq (BackendKey MongoContext)
instance Ord (BackendKey MongoContext)
instance PersistField (BackendKey MongoContext)
instance MongoRegexSearchable rs => MongoRegexSearchable [rs]
instance MongoRegexSearchable rs => MongoRegexSearchable (Maybe rs)
instance MongoRegexSearchable Text
instance PersistConfig MongoConf
instance FromJSON MongoConf
instance Serialize ObjectId
instance Val PersistValue
instance PersistQuery MongoContext
instance PersistUnique MongoContext
instance PersistStore MongoContext
instance FromJSON (BackendKey MongoContext)
instance ToJSON (BackendKey MongoContext)
instance PersistFieldSql (BackendKey MongoContext)
instance PersistFieldSql ObjectId
instance PersistField ObjectId
instance PathPiece (BackendKey MongoContext)
instance FromJSON NoOrphanPortID
instance FromJSON NoOrphanNominalDiffTime
instance HasPersistBackend MongoContext MongoContext
