-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | RethinkDB driver for Haskell
--   
@package rethinkdb-wereHamster
@version 1.8.0.5

module Database.RethinkDB.Protobuf.Ql2.VersionDummy.Version
data Version
V0_1 :: Version
V0_2 :: Version
instance Typeable Version
instance Read Version
instance Show Version
instance Eq Version
instance Ord Version
instance Data Version
instance ReflectEnum Version
instance MessageAPI msg' (msg' -> Version) Version
instance GPB Version
instance Wire Version
instance Enum Version
instance Default Version
instance Bounded Version
instance Mergeable Version

module Database.RethinkDB.Protobuf.Ql2.VersionDummy
data VersionDummy
VersionDummy :: VersionDummy
instance Typeable VersionDummy
instance Show VersionDummy
instance Eq VersionDummy
instance Ord VersionDummy
instance Data VersionDummy
instance ReflectDescriptor VersionDummy
instance GPB VersionDummy
instance MessageAPI msg' (msg' -> VersionDummy) VersionDummy
instance Wire VersionDummy
instance Default VersionDummy
instance Mergeable VersionDummy

module Database.RethinkDB.Protobuf.Ql2.Response.ResponseType
data ResponseType
SUCCESS_ATOM :: ResponseType
SUCCESS_SEQUENCE :: ResponseType
SUCCESS_PARTIAL :: ResponseType
CLIENT_ERROR :: ResponseType
COMPILE_ERROR :: ResponseType
RUNTIME_ERROR :: ResponseType
instance Typeable ResponseType
instance Read ResponseType
instance Show ResponseType
instance Eq ResponseType
instance Ord ResponseType
instance Data ResponseType
instance ReflectEnum ResponseType
instance MessageAPI msg' (msg' -> ResponseType) ResponseType
instance GPB ResponseType
instance Wire ResponseType
instance Enum ResponseType
instance Default ResponseType
instance Bounded ResponseType
instance Mergeable ResponseType

module Database.RethinkDB.Protobuf.Ql2.Frame.FrameType
data FrameType
POS :: FrameType
OPT :: FrameType
instance Typeable FrameType
instance Read FrameType
instance Show FrameType
instance Eq FrameType
instance Ord FrameType
instance Data FrameType
instance ReflectEnum FrameType
instance MessageAPI msg' (msg' -> FrameType) FrameType
instance GPB FrameType
instance Wire FrameType
instance Enum FrameType
instance Default FrameType
instance Bounded FrameType
instance Mergeable FrameType

module Database.RethinkDB.Protobuf.Ql2.Frame
data Frame
Frame :: !(Maybe FrameType) -> !(Maybe Int64) -> !(Maybe Utf8) -> Frame
type' :: Frame -> !(Maybe FrameType)
pos :: Frame -> !(Maybe Int64)
opt :: Frame -> !(Maybe Utf8)
instance Typeable Frame
instance Show Frame
instance Eq Frame
instance Ord Frame
instance Data Frame
instance ReflectDescriptor Frame
instance GPB Frame
instance MessageAPI msg' (msg' -> Frame) Frame
instance Wire Frame
instance Default Frame
instance Mergeable Frame

module Database.RethinkDB.Protobuf.Ql2.Backtrace
data Backtrace
Backtrace :: !(Seq Frame) -> Backtrace
frames :: Backtrace -> !(Seq Frame)
instance Typeable Backtrace
instance Show Backtrace
instance Eq Backtrace
instance Ord Backtrace
instance Data Backtrace
instance ReflectDescriptor Backtrace
instance GPB Backtrace
instance MessageAPI msg' (msg' -> Backtrace) Backtrace
instance Wire Backtrace
instance Default Backtrace
instance Mergeable Backtrace

module Database.RethinkDB.Protobuf.Ql2.Query.QueryType
data QueryType
START :: QueryType
CONTINUE :: QueryType
STOP :: QueryType
instance Typeable QueryType
instance Read QueryType
instance Show QueryType
instance Eq QueryType
instance Ord QueryType
instance Data QueryType
instance ReflectEnum QueryType
instance MessageAPI msg' (msg' -> QueryType) QueryType
instance GPB QueryType
instance Wire QueryType
instance Enum QueryType
instance Default QueryType
instance Bounded QueryType
instance Mergeable QueryType

module Database.RethinkDB.Protobuf.Ql2.Datum.DatumType
data DatumType
R_NULL :: DatumType
R_BOOL :: DatumType
R_NUM :: DatumType
R_STR :: DatumType
R_ARRAY :: DatumType
R_OBJECT :: DatumType
instance Typeable DatumType
instance Read DatumType
instance Show DatumType
instance Eq DatumType
instance Ord DatumType
instance Data DatumType
instance ReflectEnum DatumType
instance MessageAPI msg' (msg' -> DatumType) DatumType
instance GPB DatumType
instance Wire DatumType
instance Enum DatumType
instance Default DatumType
instance Bounded DatumType
instance Mergeable DatumType

module Database.RethinkDB.Protobuf.Ql2.Datum
data Datum
Datum :: !(Maybe DatumType) -> !(Maybe Bool) -> !(Maybe Double) -> !(Maybe Utf8) -> !(Seq Datum) -> !(Seq AssocPair) -> !ExtField -> Datum
type' :: Datum -> !(Maybe DatumType)
r_bool :: Datum -> !(Maybe Bool)
r_num :: Datum -> !(Maybe Double)
r_str :: Datum -> !(Maybe Utf8)
r_array :: Datum -> !(Seq Datum)
r_object :: Datum -> !(Seq AssocPair)
ext'field :: Datum -> !ExtField
instance Typeable Datum
instance Show Datum
instance Eq Datum
instance Ord Datum
instance Data Datum
instance ReflectDescriptor Datum
instance GPB Datum
instance MessageAPI msg' (msg' -> Datum) Datum
instance Wire Datum
instance Default Datum
instance Mergeable Datum
instance ExtendMessage Datum

module Database.RethinkDB.Protobuf.Ql2.Datum.AssocPair
data AssocPair
AssocPair :: !(Maybe Utf8) -> !(Maybe Datum) -> AssocPair
key :: AssocPair -> !(Maybe Utf8)
val :: AssocPair -> !(Maybe Datum)
instance Typeable AssocPair
instance Show AssocPair
instance Eq AssocPair
instance Ord AssocPair
instance Data AssocPair
instance ReflectDescriptor AssocPair
instance GPB AssocPair
instance MessageAPI msg' (msg' -> AssocPair) AssocPair
instance Wire AssocPair
instance Default AssocPair
instance Mergeable AssocPair

module Database.RethinkDB.Protobuf.Ql2.Response
data Response
Response :: !(Maybe ResponseType) -> !(Maybe Int64) -> !(Seq Datum) -> !(Maybe Backtrace) -> Response
type' :: Response -> !(Maybe ResponseType)
token :: Response -> !(Maybe Int64)
response :: Response -> !(Seq Datum)
backtrace :: Response -> !(Maybe Backtrace)
instance Typeable Response
instance Show Response
instance Eq Response
instance Ord Response
instance Data Response
instance ReflectDescriptor Response
instance GPB Response
instance MessageAPI msg' (msg' -> Response) Response
instance Wire Response
instance Default Response
instance Mergeable Response

module Database.RethinkDB.Protobuf.Ql2.Term.TermType
data TermType
DATUM :: TermType
MAKE_ARRAY :: TermType
MAKE_OBJ :: TermType
VAR :: TermType
JAVASCRIPT :: TermType
ERROR :: TermType
IMPLICIT_VAR :: TermType
DB :: TermType
TABLE :: TermType
GET :: TermType
GET_ALL :: TermType
EQ :: TermType
NE :: TermType
LT :: TermType
LE :: TermType
GT :: TermType
GE :: TermType
NOT :: TermType
ADD :: TermType
SUB :: TermType
MUL :: TermType
DIV :: TermType
MOD :: TermType
APPEND :: TermType
PREPEND :: TermType
DIFFERENCE :: TermType
SET_INSERT :: TermType
SET_INTERSECTION :: TermType
SET_UNION :: TermType
SET_DIFFERENCE :: TermType
SLICE :: TermType
SKIP :: TermType
LIMIT :: TermType
INDEXES_OF :: TermType
CONTAINS :: TermType
GET_FIELD :: TermType
KEYS :: TermType
HAS_FIELDS :: TermType
WITH_FIELDS :: TermType
PLUCK :: TermType
WITHOUT :: TermType
MERGE :: TermType
BETWEEN :: TermType
REDUCE :: TermType
MAP :: TermType
FILTER :: TermType
CONCATMAP :: TermType
ORDERBY :: TermType
DISTINCT :: TermType
COUNT :: TermType
IS_EMPTY :: TermType
UNION :: TermType
NTH :: TermType
GROUPED_MAP_REDUCE :: TermType
GROUPBY :: TermType
INNER_JOIN :: TermType
OUTER_JOIN :: TermType
EQ_JOIN :: TermType
ZIP :: TermType
INSERT_AT :: TermType
DELETE_AT :: TermType
CHANGE_AT :: TermType
SPLICE_AT :: TermType
COERCE_TO :: TermType
TYPEOF :: TermType
UPDATE :: TermType
DELETE :: TermType
REPLACE :: TermType
INSERT :: TermType
DB_CREATE :: TermType
DB_DROP :: TermType
DB_LIST :: TermType
TABLE_CREATE :: TermType
TABLE_DROP :: TermType
TABLE_LIST :: TermType
INDEX_CREATE :: TermType
INDEX_DROP :: TermType
INDEX_LIST :: TermType
FUNCALL :: TermType
BRANCH :: TermType
ANY :: TermType
ALL :: TermType
FOREACH :: TermType
FUNC :: TermType
ASC :: TermType
DESC :: TermType
INFO :: TermType
MATCH :: TermType
SAMPLE :: TermType
DEFAULT :: TermType
JSON :: TermType
ISO8601 :: TermType
TO_ISO8601 :: TermType
EPOCH_TIME :: TermType
TO_EPOCH_TIME :: TermType
NOW :: TermType
IN_TIMEZONE :: TermType
DURING :: TermType
DATE :: TermType
TIME_OF_DAY :: TermType
TIMEZONE :: TermType
YEAR :: TermType
MONTH :: TermType
DAY :: TermType
DAY_OF_WEEK :: TermType
DAY_OF_YEAR :: TermType
HOURS :: TermType
MINUTES :: TermType
SECONDS :: TermType
TIME :: TermType
MONDAY :: TermType
TUESDAY :: TermType
WEDNESDAY :: TermType
THURSDAY :: TermType
FRIDAY :: TermType
SATURDAY :: TermType
SUNDAY :: TermType
JANUARY :: TermType
FEBRUARY :: TermType
MARCH :: TermType
APRIL :: TermType
MAY :: TermType
JUNE :: TermType
JULY :: TermType
AUGUST :: TermType
SEPTEMBER :: TermType
OCTOBER :: TermType
NOVEMBER :: TermType
DECEMBER :: TermType
LITERAL :: TermType
instance Typeable TermType
instance Read TermType
instance Show TermType
instance Eq TermType
instance Ord TermType
instance Data TermType
instance ReflectEnum TermType
instance MessageAPI msg' (msg' -> TermType) TermType
instance GPB TermType
instance Wire TermType
instance Enum TermType
instance Default TermType
instance Bounded TermType
instance Mergeable TermType

module Database.RethinkDB.Protobuf.Ql2.Term
data Term
Term :: !(Maybe TermType) -> !(Maybe Datum) -> !(Seq Term) -> !(Seq AssocPair) -> !ExtField -> Term
type' :: Term -> !(Maybe TermType)
datum :: Term -> !(Maybe Datum)
args :: Term -> !(Seq Term)
optargs :: Term -> !(Seq AssocPair)
ext'field :: Term -> !ExtField
instance Typeable Term
instance Show Term
instance Eq Term
instance Ord Term
instance Data Term
instance ReflectDescriptor Term
instance GPB Term
instance MessageAPI msg' (msg' -> Term) Term
instance Wire Term
instance Default Term
instance Mergeable Term
instance ExtendMessage Term

module Database.RethinkDB.Protobuf.Ql2.Term.AssocPair
data AssocPair
AssocPair :: !(Maybe Utf8) -> !(Maybe Term) -> AssocPair
key :: AssocPair -> !(Maybe Utf8)
val :: AssocPair -> !(Maybe Term)
instance Typeable AssocPair
instance Show AssocPair
instance Eq AssocPair
instance Ord AssocPair
instance Data AssocPair
instance ReflectDescriptor AssocPair
instance GPB AssocPair
instance MessageAPI msg' (msg' -> AssocPair) AssocPair
instance Wire AssocPair
instance Default AssocPair
instance Mergeable AssocPair

module Database.RethinkDB.Protobuf.Ql2.Query.AssocPair
data AssocPair
AssocPair :: !(Maybe Utf8) -> !(Maybe Term) -> AssocPair
key :: AssocPair -> !(Maybe Utf8)
val :: AssocPair -> !(Maybe Term)
instance Typeable AssocPair
instance Show AssocPair
instance Eq AssocPair
instance Ord AssocPair
instance Data AssocPair
instance ReflectDescriptor AssocPair
instance GPB AssocPair
instance MessageAPI msg' (msg' -> AssocPair) AssocPair
instance Wire AssocPair
instance Default AssocPair
instance Mergeable AssocPair

module Database.RethinkDB.Protobuf.Ql2.Query
data Query
Query :: !(Maybe QueryType) -> !(Maybe Term) -> !(Maybe Int64) -> !(Maybe Bool) -> !(Seq AssocPair) -> Query
type' :: Query -> !(Maybe QueryType)
query :: Query -> !(Maybe Term)
token :: Query -> !(Maybe Int64)
oBSOLETE_noreply :: Query -> !(Maybe Bool)
global_optargs :: Query -> !(Seq AssocPair)
instance Typeable Query
instance Show Query
instance Eq Query
instance Ord Query
instance Data Query
instance ReflectDescriptor Query
instance GPB Query
instance MessageAPI msg' (msg' -> Query) Query
instance Wire Query
instance Default Query
instance Mergeable Query

module Database.RethinkDB.Protobuf.Ql2
protoInfo :: ProtoInfo
fileDescriptorProto :: FileDescriptorProto

module Database.RethinkDB.Objects

-- | A database, referenced by name
data Database
Database :: Text -> Database
databaseName :: Database -> Text

-- | Options used to create a table
data TableCreateOptions
TableCreateOptions :: Maybe Text -> Maybe Int64 -> TableCreateOptions
tableDataCenter :: TableCreateOptions -> Maybe Text
tableCacheSize :: TableCreateOptions -> Maybe Int64

-- | Options used to create an index
data IndexCreateOptions
IndexCreateOptions :: Maybe Bool -> IndexCreateOptions
indexMulti :: IndexCreateOptions -> Maybe Bool

-- | A table description
data Table
Table :: Maybe Database -> Text -> Maybe Key -> Table

-- | when Nothing, use the connection's database
tableDatabase :: Table -> Maybe Database
tableName :: Table -> Text
tablePrimaryKey :: Table -> Maybe Key
type Datum = Value
type Key = Text
instance Eq Database
instance Ord Database
instance Eq Table
instance Ord Table
instance Show Table
instance Default IndexCreateOptions
instance Default TableCreateOptions
instance Show Database


-- | Building RQL queries in Haskell
module Database.RethinkDB.ReQL

-- | An RQL term
data ReQL
ReQL :: State QuerySettings BaseReQL -> ReQL
baseReQL :: ReQL -> State QuerySettings BaseReQL

-- | Build a term
op :: (Arr a, Obj o) => TermType -> a -> o -> ReQL
data BaseReQL
BaseReQL :: TermType -> Maybe Datum -> BaseArray -> [BaseAttribute] -> BaseReQL
termType :: BaseReQL -> TermType
termDatum :: BaseReQL -> Maybe Datum
termArgs :: BaseReQL -> BaseArray
termOptArgs :: BaseReQL -> [BaseAttribute]
data BaseAttribute
BaseAttribute :: Text -> BaseReQL -> BaseAttribute
buildQuery :: ReQL -> Int64 -> Database -> (Query, BaseReQL)
type BaseArray = [BaseReQL]
type Backtrace = [Frame]
convertBacktrace :: Backtrace -> Backtrace

-- | Convert other types into ReqL expressions
class Expr e
expr :: Expr e => e -> ReQL
data QuerySettings
QuerySettings :: Int64 -> Database -> Int -> Maybe Bool -> Maybe Bool -> Maybe Bool -> QuerySettings
queryToken :: QuerySettings -> Int64
queryDefaultDatabase :: QuerySettings -> Database
queryVarIndex :: QuerySettings -> Int
queryUseOutdated :: QuerySettings -> Maybe Bool
queryReturnVals :: QuerySettings -> Maybe Bool
queryAtomic :: QuerySettings -> Maybe Bool
newVarId :: State QuerySettings Int

-- | A shortcut for inserting strings into ReQL expressions Useful when
--   OverloadedStrings makes the type ambiguous
str :: String -> ReQL

-- | A shortcut for inserting numbers into ReQL expressions
num :: Double -> ReQL

-- | A key/value pair used for building objects
data Attribute
(:=) :: Text -> e -> Attribute
cons :: Expr e => e -> Array -> Array
arr :: Arr a => a -> Array
baseArray :: Array -> State QuerySettings BaseArray
withQuerySettings :: (QuerySettings -> ReQL) -> ReQL

-- | A list of key/value pairs
data Object
Object :: State QuerySettings [BaseAttribute] -> Object
baseObject :: Object -> State QuerySettings [BaseAttribute]

-- | Convert into a ReQL object
class Obj o
obj :: Obj o => o -> Object

-- | Include the value of single write operations in the returned object
returnVals :: ReQL -> ReQL

-- | Allow non-atomic replace
nonAtomic :: ReQL -> ReQL
canReturnVals :: ReQL -> ReQL
canNonAtomic :: ReQL -> ReQL
reqlToProtobuf :: ReQL -> Query

-- | An upper or lower bound for between and during
data Bound a

-- | An inclusive bound
Open :: a -> Bound a
getBound :: Bound a -> a

-- | An exclusive bound
Closed :: a -> Bound a
getBound :: Bound a -> a
closedOrOpen :: Bound a -> Text
instance (Expr a, Expr b, Expr c, Expr d, Expr e) => Expr (a, b, c, d, e)
instance (Expr a, Expr b, Expr c, Expr d) => Expr (a, b, c, d)
instance (Expr a, Expr b, Expr c) => Expr (a, b, c)
instance (Expr a, Expr b) => Expr (a, b)
instance Expr BaseReQL
instance Expr ZonedTime
instance Expr UTCTime
instance Show Frame
instance Show ReQL
instance Expr Object
instance Expr e => Expr (HashMap Text e)
instance Expr Array
instance Expr a => Expr [a]
instance Expr x => Expr (Vector x)
instance Expr Rational
instance Expr Double
instance Expr Value
instance Expr Database
instance Expr Table
instance Expr Datum
instance (a ~ ReQL, b ~ ReQL) => Expr (a -> b -> ReQL)
instance a ~ ReQL => Expr (a -> ReQL)
instance IsString ReQL
instance Expr ()
instance Expr Bool
instance Expr Text
instance Num ReQL
instance Expr Integer
instance Expr Int
instance Expr Int64
instance Obj ()
instance Obj Object
instance Obj [BaseAttribute]
instance Obj [Attribute]
instance Show BaseAttribute
instance Arr Array
instance (Expr a, Expr b, Expr c, Expr d) => Arr (a, b, c, d)
instance (Expr a, Expr b, Expr c) => Arr (a, b, c)
instance (Expr a, Expr b) => Arr (a, b)
instance Expr a => Arr [a]
instance Arr ()
instance Expr ReQL
instance Show BaseReQL
instance Default QuerySettings

module Database.RethinkDB.Network

-- | A connection to the database server
data RethinkDBHandle
RethinkDBHandle :: Handle -> MVar (Maybe SomeException) -> IORef Token -> Database -> IORef (Map Token (Chan Response, BaseReQL, IO ())) -> ThreadId -> RethinkDBHandle
rdbHandle :: RethinkDBHandle -> Handle
rdbWriteLock :: RethinkDBHandle -> MVar (Maybe SomeException)

-- | The next token to use
rdbToken :: RethinkDBHandle -> IORef Token

-- | The default database
rdbDatabase :: RethinkDBHandle -> Database
rdbWait :: RethinkDBHandle -> IORef (Map Token (Chan Response, BaseReQL, IO ()))
rdbThread :: RethinkDBHandle -> ThreadId

-- | Create a new connection to the database server
--   
--   <i>Example:</i> connect using the default port with no passphrase
--   
--   <pre>
--   &gt;&gt;&gt; h &lt;- connect "localhost" 28015 Nothing
--   </pre>
connect :: HostName -> Integer -> Maybe String -> IO RethinkDBHandle

-- | Close an open connection
close :: RethinkDBHandle -> IO ()

-- | Set the default database
--   
--   The new handle is an alias for the old one. Calling close on either
--   one will close both.
use :: RethinkDBHandle -> Database -> RethinkDBHandle
runQLQuery :: RethinkDBHandle -> Query -> BaseReQL -> IO (MVar Response)
data Cursor a
makeCursor :: MVar Response -> IO (Cursor Datum)

-- | Get the next value from a cursor
next :: Cursor a -> IO (Maybe a)

-- | A lazy stream of all the elements in the cursor
collect :: Cursor a -> IO [a]
nextResponse :: Response -> IO ()

-- | The raw response to a query
data Response
ErrorResponse :: RethinkDBError -> Response
errorResponse :: Response -> RethinkDBError
SuccessResponse :: SuccessCode -> [Datum] -> Response
successCode :: Response -> SuccessCode
successDatums :: Response -> [Datum]
data SuccessCode
SuccessPartial :: RethinkDBHandle -> Int64 -> SuccessCode
Success :: SuccessCode
data ErrorCode
ErrorBrokenClient :: ErrorCode
ErrorBadQuery :: ErrorCode
ErrorRuntime :: ErrorCode
ErrorUnexpectedResponse :: ErrorCode
data RethinkDBError
RethinkDBError :: ErrorCode -> BaseReQL -> String -> Backtrace -> RethinkDBError
errorCode :: RethinkDBError -> ErrorCode
errorTerm :: RethinkDBError -> BaseReQL
errorMessage :: RethinkDBError -> String
errorBacktrace :: RethinkDBError -> Backtrace
data RethinkDBConnectionError
RethinkDBConnectionError :: ByteString -> RethinkDBConnectionError
instance Typeable RethinkDBConnectionError
instance Typeable RethinkDBError
instance Typeable RethinkDBReadError
instance Show RethinkDBConnectionError
instance Show RethinkDBError
instance Show SuccessCode
instance Show RethinkDBReadError
instance Exception RethinkDBReadError
instance Show Response
instance Show ErrorCode
instance Exception RethinkDBError
instance Exception RethinkDBConnectionError
instance Show RethinkDBHandle
instance Functor Cursor

module Database.RethinkDB.Driver

-- | Run a given query and return a Result
run :: (Expr query, Result r) => RethinkDBHandle -> query -> IO r

-- | Run a given query and return a JSON
run' :: Expr query => RethinkDBHandle -> query -> IO [JSON]

-- | Convert the raw query response into useful values
class Result r
convertResult :: Result r => MVar Response -> IO r

-- | Run a query with the given options
runOpts :: (Expr query, Result r) => RethinkDBHandle -> [RunOptions] -> query -> IO r

-- | Per-query settings
data RunOptions
UseOutdated :: RunOptions
NoReply :: RunOptions
SoftDurability :: Bool -> RunOptions
data WriteResponse
WriteResponse :: Int -> Int -> Int -> Int -> Int -> Int -> Maybe Text -> Maybe [Text] -> Maybe Value -> Maybe Value -> WriteResponse
writeResponseInserted :: WriteResponse -> Int
writeResponseDeleted :: WriteResponse -> Int
writeResponseReplaced :: WriteResponse -> Int
writeResponseUnchanged :: WriteResponse -> Int
writeResponseSkipped :: WriteResponse -> Int
writeResponseErrors :: WriteResponse -> Int
writeResponseFirstError :: WriteResponse -> Maybe Text
writeResponseGeneratedKeys :: WriteResponse -> Maybe [Text]
writeResponseOldVal :: WriteResponse -> Maybe Value
writeResponseNewVal :: WriteResponse -> Maybe Value
data JSON
JSON :: Value -> JSON
instance Show WriteResponse
instance FromJSON JSON
instance Show JSON
instance FromJSON WriteResponse
instance FromJSON a => Result (Maybe a)
instance FromJSON a => Result [a]
instance FromJSON a => Result (Cursor a)
instance Result Response

module Database.RethinkDB.Time

-- | The time and date when the query is executed
--   
--   <pre>
--   &gt;&gt;&gt; run h $ now :: IO (Maybe R.ZonedTime)
--   Just 2013-10-28 00:01:43.930000066757 +0000
--   </pre>
now :: ReQL

-- | Build a time object from the year, month, day, hour, minute, second
--   and timezone fields
--   
--   <pre>
--   &gt;&gt;&gt; run h $ time 2011 12 24 23 59 59 "Z" :: IO (Maybe R.ZonedTime)
--   Just 2011-12-24 23:59:59 +0000
--   </pre>
time :: ReQL -> ReQL -> ReQL -> ReQL -> ReQL -> ReQL -> ReQL -> ReQL

-- | Build a time object given the number of seconds since the unix epoch
--   
--   <pre>
--   &gt;&gt;&gt; run h $ epochTime 1147162826 :: IO (Maybe R.ZonedTime)
--   Just 2006-05-09 08:20:26 +0000
--   </pre>
epochTime :: ReQL -> ReQL

-- | Build a time object given an iso8601 string
--   
--   <pre>
--   &gt;&gt;&gt; run h $ iso8601 "2012-01-07T08:34:00-0700" :: IO (Maybe R.UTCTime)
--   Just 2012-01-07 15:34:00 UTC
--   </pre>
iso8601 :: ReQL -> ReQL

-- | The same time in a different timezone
--   
--   <pre>
--   &gt;&gt;&gt; run h $ inTimezone "+0800" now :: IO (Maybe R.ZonedTime)
--   Just 2013-10-28 08:16:39.22000002861 +0800
--   </pre>
inTimezone :: Expr time => ReQL -> time -> ReQL

-- | Test if a time is between two other times
--   
--   <pre>
--   &gt;&gt;&gt; run h $ during (Open $ now - (60*60)) (Closed now) $ epochTime 1382919271 :: IO (Maybe Bool)
--   Just True
--   </pre>
during :: (Expr left, Expr right, Expr time) => Bound left -> Bound right -> time -> ReQL

-- | Extract part of a time value
timezone :: Expr time => time -> ReQL

-- | Extract part of a time value
seconds :: Expr time => time -> ReQL

-- | Extract part of a time value
minutes :: Expr time => time -> ReQL

-- | Extract part of a time value
hours :: Expr time => time -> ReQL

-- | Extract part of a time value
dayOfYear :: Expr time => time -> ReQL

-- | Extract part of a time value
dayOfWeek :: Expr time => time -> ReQL

-- | Extract part of a time value
day :: Expr time => time -> ReQL

-- | Extract part of a time value
month :: Expr time => time -> ReQL

-- | Extract part of a time value
year :: Expr time => time -> ReQL

-- | Extract part of a time value
timeOfDay :: Expr time => time -> ReQL

-- | Extract part of a time value
date :: Expr time => time -> ReQL

-- | Convert a time to another representation
toIso8601 :: Expr t => t -> ReQL

-- | Convert a time to another representation
toEpochTime :: Expr t => t -> ReQL

-- | Time with no time zone
--   
--   The default FromJSON instance for Data.Time.UTCTime is incompatible
--   with ReQL's time type
newtype UTCTime
UTCTime :: UTCTime -> UTCTime
timeToDouble :: UTCTime -> Double
doubleToTime :: Double -> UTCTime

-- | Time with a time zone
--   
--   The default FromJSON instance for Data.Time.ZonedTime is incompatible
--   with ReQL's time type
newtype ZonedTime
ZonedTime :: ZonedTime -> ZonedTime
parseTimeZone :: String -> Parser TimeZone
instance Expr ZonedTime
instance Expr UTCTime
instance FromJSON ZonedTime
instance ToJSON ZonedTime
instance Show ZonedTime
instance ToJSON UTCTime
instance FromJSON UTCTime
instance Show UTCTime

module Database.RethinkDB.MapReduce
termToMapReduce :: (ReQL -> ReQL) -> State QuerySettings (ReQL -> ReQL, ReQL -> ReQL -> ReQL, Maybe (ReQL -> ReQL))
toReduce :: MapReduce -> (ReQL -> ReQL, ReQL -> ReQL -> ReQL, Maybe (ReQL -> ReQL))
unionReduce :: ReQL -> ReQL -> ReQL
sameVar :: Int -> BaseArray -> Bool
notNone :: MapReduce -> Bool
wrap :: BaseReQL -> ReQL
toFun1 :: ReQL -> (ReQL -> ReQL)
toFun2 :: ReQL -> (ReQL -> ReQL -> ReQL)
toMapReduce :: Int -> BaseReQL -> MapReduce
optargsToBase :: [BaseAttribute] -> Maybe (Maybe ReQL)
baseAttrToAttr :: BaseAttribute -> Attribute
noRecurse :: Attribute
mappableTypes :: [TermType]
data MapReduce
None :: ReQL -> MapReduce
Map :: (ReQL -> ReQL) -> MapReduce
MapReduce :: (ReQL -> ReQL) -> (ReQL -> ReQL -> ReQL) -> (Maybe (ReQL -> ReQL)) -> MapReduce
rebuild0 :: TermType -> [MapReduce] -> [(Text, MapReduce)] -> MapReduce
rebuildx :: TermType -> [MapReduce] -> [(Key, MapReduce)] -> MapReduce
fst3 :: (a, b, c) -> a
snd3 :: (a, b, c) -> b
thrd3 :: (a, b, c) -> c
extract :: Maybe Int -> TermType -> [MapReduce] -> [(Key, MapReduce)] -> (ReQL -> ReQL, [MapReduce])
extractOne :: MapReduce -> WriterT [MapReduce] (State (Maybe Int)) (ReQL -> ReQL)


-- | Functions from the ReQL (RethinkDB Query Language)
module Database.RethinkDB.Functions

-- | Addition or concatenation
--   
--   Use the Num instance, or a qualified operator.
--   
--   <pre>
--   &gt;&gt;&gt; run h $ 2 + 5 :: IO (Maybe Int)
--   Just 7
--   &gt;&gt;&gt; run h $ 2 R.+ 5 :: IO (Maybe Int)
--   Just 7
--   &gt;&gt;&gt; run h $ (str "foo") + (str "bar") :: IO (Just String)
--   Just "foobar"
--   </pre>
(+) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Subtraction
--   
--   <pre>
--   &gt;&gt;&gt; run h $ 2 - 5 :: IO (Maybe Int)
--   Just (-3)
--   </pre>
(-) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Multiplication
--   
--   <pre>
--   &gt;&gt;&gt; run h $ 2 * 5 :: IO (Maybe Int)
--   Just 10
--   </pre>
(*) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Division
--   
--   <pre>
--   &gt;&gt;&gt; run h $ 2 R./ 5 :: IO (Maybe Double)
--   Just 0.4
--   </pre>
(/) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Mod
--   
--   <pre>
--   &gt;&gt;&gt; run h $ 5 `mod` 2 :: IO (Maybe Int)
--   Just 1
--   </pre>
mod :: (Expr a, Expr b) => a -> b -> ReQL

-- | Boolean or
--   
--   <pre>
--   &gt;&gt;&gt; run h $ True R.|| False :: IO (Maybe Bool)
--   Just True
--   </pre>
(||) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Boolean and
--   
--   <pre>
--   &gt;&gt;&gt; run h $ True R.&amp;&amp; False :: IO (Maybe Bool)
--   Just False
--   </pre>
(&&) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Test for equality
--   
--   <pre>
--   &gt;&gt;&gt; run h $ obj ["a" := 1] R.== obj ["a" := 1] :: IO (Maybe Bool)
--   Just True
--   </pre>
(==) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Test for inequality
--   
--   <pre>
--   &gt;&gt;&gt; run h $ 1 R./= False :: IO (Maybe Bool)
--   Just True
--   </pre>
(/=) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Greater than
--   
--   <pre>
--   &gt;&gt;&gt; run h $ 3 R.&gt; 2 :: IO (Maybe Bool)
--   Just True
--   </pre>
(>) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Lesser than
--   
--   <pre>
--   &gt;&gt;&gt; run h $ (str "a") R.&lt; (str "b") :: IO (Maybe Bool)
--   Just True
--   </pre>
(<) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Greater than or equal to
--   
--   <pre>
--   &gt;&gt;&gt; run h $ [1] R.&gt;= () :: IO (Maybe Bool)
--   Just False
--   </pre>
(>=) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Lesser than or equal to
--   
--   <pre>
--   &gt;&gt;&gt; run h $ 2 R.&lt;= 2 :: IO (Maybe Bool)
--   Just True
--   </pre>
(<=) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Negation
--   
--   <pre>
--   &gt;&gt;&gt; run h $ R.not False :: IO (Maybe Bool)
--   Just True
--   &gt;&gt;&gt; run h $ R.not () :: IO (Maybe Bool)
--   Just True
--   </pre>
not :: Expr a => a -> ReQL

-- | The size of a sequence or an array.
--   
--   Called <i>count</i> in the official drivers
--   
--   <pre>
--   &gt;&gt;&gt; run h $ R.length (table "foo") :: IO (Maybe Int)
--   Just 17
--   </pre>
length :: Expr a => a -> ReQL

-- | Join two sequences.
--   
--   Called <i>union</i> in the official drivers
--   
--   <pre>
--   &gt;&gt;&gt; run h $ [1,2,3] R.++ ["a", "b", "c" :: Text] :: IO (Maybe [JSON])
--   Just [1.0,2.0,3.0,"a","b","c"]
--   </pre>
(++) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Map a function over a sequence
--   
--   <pre>
--   &gt;&gt;&gt; run h $ R.map (!"a") [obj ["a" := 1], obj ["a" := 2]] :: IO (Maybe [Int])
--   Just [1,2]
--   </pre>
map :: (Expr a, Expr b) => (ReQL -> b) -> a -> ReQL

-- | Filter a sequence given a predicate
--   
--   <pre>
--   &gt;&gt;&gt; run h $ R.filter (R.&lt; 4) [3, 1, 4, 1, 5, 9, 2, 6] :: IO (Maybe [Int])
--   Just [3,1,1,2]
--   </pre>
filter :: (Expr predicate, Expr seq) => predicate -> seq -> ReQL

-- | Query all the documents whose value for the given index is in a given
--   range
--   
--   <pre>
--   &gt;&gt;&gt; run h $ table "users" # between "id" (Closed $ str "a") (Open $ str "n") :: IO [JSON]
--   [{"post_count":4.0,"name":"bob","id":"b6a9df6a-b92c-46d1-ae43-1d2dd8ec293c"},{"post_count":4.0,"name":"bill","id":"b2908215-1d3c-4ff5-b9ee-1a003fa9690c"}]
--   </pre>
between :: (Expr left, Expr right, Expr seq) => Key -> Bound left -> Bound right -> seq -> ReQL

-- | Append a datum to a sequence
--   
--   <pre>
--   &gt;&gt;&gt; run h $ append 3 [1, 2] :: IO (Maybe [Int])
--   Just [1,2,3]
--   </pre>
append :: (Expr a, Expr b) => a -> b -> ReQL

-- | Map a function of a sequence and concat the results
--   
--   <pre>
--   &gt;&gt;&gt; run h $ concatMap id [[1, 2], [3], [4, 5]] :: IO (Maybe [Int])
--   Just [1,2,3,4,5]
--   </pre>
concatMap :: (Expr a, Expr b) => (ReQL -> b) -> a -> ReQL

-- | SQL-like inner join of two sequences
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ innerJoin (\user post -&gt; user!"id" R.== post!"author") (table "users") (table "posts") # mergeLeftRight # without ["id", "author"]
--   [[{"name":"bob","message":"lorem ipsum"},{"name":"bill","message":"hello"},{"name":"bill","message":"hi"}]]
--   </pre>
innerJoin :: (Expr a, Expr b, Expr c) => (ReQL -> ReQL -> c) -> a -> b -> ReQL

-- | SQL-like outer join of two sequences
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ outerJoin (\user post -&gt; user!"id" R.== post!"author") (table "users") (table "posts") # mergeLeftRight # without ["id", "author"]
--   [[{"name":"nancy"},{"name":"bill","message":"hello"},{"name":"bill","message":"hi"},{"name":"bob","message":"lorem ipsum"}]]
--   </pre>
outerJoin :: (Expr a, Expr b, Expr c) => (ReQL -> ReQL -> c) -> a -> b -> ReQL

-- | An efficient inner_join that uses a key for the left table and an
--   index for the right table.
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "posts" # eqJoin "author" (table "users") "id" # mergeLeftRight # without ["id", "author"]
--   [[{"name":"bill","message":"hi"},{"name":"bob","message":"lorem ipsum"},{"name":"bill","message":"hello"}]]
--   </pre>
eqJoin :: (Expr right, Expr left) => Key -> right -> Key -> left -> ReQL

-- | Drop elements from the head of a sequence.
--   
--   Called <i>skip</i> in the official drivers
--   
--   <pre>
--   &gt;&gt;&gt; run h $ R.drop 2 [1, 2, 3, 4] :: IO (Maybe [Int])
--   Just [3,4]
--   </pre>
drop :: (Expr a, Expr b) => a -> b -> ReQL

-- | Limit the size of a sequence.
--   
--   Called <i>limit</i> in the official drivers
--   
--   <pre>
--   &gt;&gt;&gt; run h $ R.take 2 [1, 2, 3, 4] :: IO (Maybe [Int])
--   Just [1,2]
--   </pre>
take :: (Expr n, Expr seq) => n -> seq -> ReQL

-- | Cut out part of a sequence
--   
--   <pre>
--   &gt;&gt;&gt; run h $ slice 2 4 [1, 2, 3, 4, 5] :: IO (Maybe [Int])
--   Just [3,4]
--   </pre>
slice :: (Expr a, Expr b, Expr c) => a -> b -> c -> ReQL

-- | Get the nth value of a sequence or array
--   
--   <pre>
--   &gt;&gt;&gt; run h $ [1, 2, 3] !! 0 :: IO (Maybe Int)
--   Just 1
--   </pre>
(!!) :: Expr a => a -> ReQL -> ReQL

-- | Reduce a sequence to a single value
--   
--   <pre>
--   &gt;&gt;&gt; run h $ reduce (+) 0 [1, 2, 3] :: IO (Maybe Int)
--   Just 6
--   </pre>
reduce :: (Expr base, Expr seq, Expr a) => (ReQL -> ReQL -> a) -> base -> seq -> ReQL

-- | Reduce a non-empty sequence to a single value
--   
--   <pre>
--   &gt;&gt;&gt; run h $ reduce1 (+) [1, 2, 3] :: IO (Maybe Int)
--   Just 6
--   </pre>
reduce1 :: (Expr a, Expr s) => (ReQL -> ReQL -> a) -> s -> ReQL

-- | Filter out identical elements of the sequence
--   
--   Called <i>distint</i> in the official drivers
--   
--   <pre>
--   &gt;&gt;&gt; run h $ nub (table "posts" ! "flag") :: IO (Maybe [String])
--   Just ["pinned", "deleted"]
--   </pre>
nub :: Expr s => s -> ReQL

-- | Like map but for write queries
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "users" # replace (without ["post_count"])
--   &gt;&gt;&gt; run' h $ forEach (table "posts") $ \post -&gt; table "users" # get (post!"author") # update (\user -&gt; obj ["post_count" := (handle 0 (user!"post_count") + 1)])
--   [{"skipped":0.0,"inserted":0.0,"unchanged":0.0,"deleted":0.0,"replaced":3.0,"errors":0.0}]
--   </pre>
forEach :: (Expr s, Expr a) => s -> (ReQL -> a) -> ReQL

-- | Merge the "left" and "right" attributes of the objects in a sequence.
--   
--   Called <i>zip</i> in the official drivers
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "posts" # eqJoin "author" (table "users") "id" # mergeLeftRight
--   </pre>
mergeLeftRight :: Expr a => a -> ReQL

-- | Ordering specification for orderBy
data Order

-- | Ascending order
Asc :: Key -> Order
orderAttr :: Order -> Key

-- | Descending order
Desc :: Key -> Order
orderAttr :: Order -> Key

-- | Order a sequence by the given keys
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "users" # orderBy [Desc "post_count", Asc "name"] # pluck ["name", "post_count"]
--   [[{"post_count":2.0,"name":"bill"},{"post_count":1.0,"name":"bob"},{"name":"nancy"}]]
--   </pre>
orderBy :: Expr s => [Order] -> s -> ReQL

-- | Turn a grouping function and a reduction function into a grouped map
--   reduce operation
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "posts" # groupBy (!"author") (reduce1 (\a b -&gt; a + "\n" + b) . R.map (!"message"))
--   [[{"group":"b2908215-1d3c-4ff5-b9ee-1a003fa9690c","reduction":"hi\nhello"},{"group":"b6a9df6a-b92c-46d1-ae43-1d2dd8ec293c","reduction":"lorem ipsum"}]]
--   &gt;&gt;&gt; run' h $ table "users" # groupBy (!"level") (\users -&gt; let pc = users!"post_count" in [avg pc, R.sum pc])
--   [[{"group":1,"reduction":[1.5,3.0]},{"group":2,"reduction":[0.0,0.0]}]]
--   </pre>
groupBy :: (Expr group, Expr reduction, Expr seq) => (ReQL -> group) -> (ReQL -> reduction) -> seq -> ReQL

-- | The sum of a sequence
--   
--   <pre>
--   &gt;&gt;&gt; run h $ sum [1, 2, 3] :: IO (Maybe Int)
--   Just 6
--   </pre>
sum :: Expr s => s -> ReQL

-- | The average of a sequence
--   
--   <pre>
--   &gt;&gt;&gt; run h $ avg [1, 2, 3, 4] :: IO (Maybe Double)
--   Just 2.5
--   </pre>
avg :: Expr s => s -> ReQL

-- | Get a single field from an object
--   
--   <pre>
--   &gt;&gt;&gt; run h $ (obj ["foo" := True]) ! "foo" :: IO (Maybe Bool)
--   Just True
--   </pre>
--   
--   Or a single field from each object in a sequence
--   
--   <pre>
--   &gt;&gt;&gt; run h $ [obj ["foo" := True], obj ["foo" := False]] ! "foo" :: IO (Maybe [Bool])
--   Just [True,False]
--   </pre>
(!) :: Expr s => s -> ReQL -> ReQL

-- | Keep only the given attributes
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ map obj [["a" := 1, "b" := 2], ["a" := 2, "c" := 7], ["b" := 4]] # pluck ["a"]
--   [[{"a":1.0},{"a":2.0},{}]]
--   </pre>
pluck :: Expr o => [ReQL] -> o -> ReQL

-- | Remove the given attributes from an object
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ map obj [["a" := 1, "b" := 2], ["a" := 2, "c" := 7], ["b" := 4]] # without ["a"]
--   [[{"b":2.0},{"c":7.0},{"b":4.0}]]
--   </pre>
without :: Expr o => [ReQL] -> o -> ReQL

-- | Test if a sequence contains a given element
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ 1 `R.elem` [1,2,3]
--   [true]
--   </pre>
elem :: (Expr x, Expr seq) => x -> seq -> ReQL

-- | Merge two objects together
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ merge (obj ["a" := 1, "b" := 1]) (obj ["b" := 2, "c" := 2])
--   [{"a":1.0,"b":2.0,"c":2.0}]
--   </pre>
merge :: (Expr a, Expr b) => a -> b -> ReQL

-- | Evaluate a JavaScript expression
--   
--   <pre>
--   &gt;&gt;&gt; run h $ js "Math.random()" :: IO (Maybe Double)
--   Just 0.9119815775193274
--   &gt;&gt;&gt; run h $ R.map (\x -&gt; js "Math.sin" `apply` [x]) [pi, pi/2] :: IO (Maybe [Double])
--   Just [1.2246063538223773e-16,1.0]
--   </pre>
js :: ReQL -> ReQL

-- | Called <i>branch</i> in the official drivers
--   
--   <pre>
--   &gt;&gt;&gt; run h $ if' (1 R.&lt; 2) 3 4 :: IO (Maybe Int)
--   Just 3
--   </pre>
if' :: (Expr a, Expr b, Expr c) => a -> b -> c -> ReQL

-- | Abort the query with an error
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ R.error (str "haha") R./ 2 + 1
--   *** Exception: RethinkDBError {errorCode = runtime error, errorTerm = ADD(DIV(ERROR("haha"), 2.0), 1.0), errorMessage = "haha", errorBacktrace = [0,0]}
--   </pre>
error :: Expr s => s -> ReQL

-- | Create a Database reference
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ db "test" # info
--   [{"name":"test","type":"DB"}]
--   </pre>
db :: Text -> Database

-- | Create a database on the server
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ dbCreate "dev"
--   [{"created":1.0}]
--   </pre>
dbCreate :: String -> ReQL

-- | Drop a database
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ dbDrop (db "dev")
--   [{"dropped":1.0}]
--   </pre>
dbDrop :: Database -> ReQL

-- | List the databases on the server
--   
--   <pre>
--   &gt;&gt;&gt; run h $ dbList :: IO (Maybe [String])
--   Just ["test"]
--   </pre>
dbList :: ReQL

-- | Create an index on the table from the given function
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "users" # indexCreate "name" (!"name") def
--   [{"created":1.0}]
--   </pre>
indexCreate :: Expr fun => String -> fun -> IndexCreateOptions -> Table -> ReQL

-- | Drop an index
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "users" # indexDrop "name"
--   [{"dropped":1.0}]
--   </pre>
indexDrop :: Key -> Table -> ReQL

-- | List the indexes on the table
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ indexList (table "users")
--   [["name"]]
--   </pre>
indexList :: Table -> ReQL

-- | Retreive documents by their indexed value
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "users" # getAll "name" ["bob"]
--   [{"post_count":1.0,"name":"bob","id":"b6a9df6a-b92c-46d1-ae43-1d2dd8ec293c"}]
--   </pre>
getAll :: Expr value => Key -> [value] -> Table -> ReQL

-- | A table
--   
--   <pre>
--   &gt;&gt;&gt; (mapM_ print =&lt;&lt;) $ run' h $ table "users"
--   {"post_count":0.0,"name":"nancy","id":"8d674d7a-873c-4c0f-8a4a-32a4bd5bdee8"}
--   {"post_count":1.0,"name":"bob","id":"b6a9df6a-b92c-46d1-ae43-1d2dd8ec293c"}
--   {"post_count":2.0,"name":"bill","id":"b2908215-1d3c-4ff5-b9ee-1a003fa9690c"}
--   </pre>
table :: Text -> Table

-- | Create a table on the server
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ tableCreate (table "posts") def
--   &gt;&gt;&gt; run' h $ tableCreate (table "users") def
--   &gt;&gt;&gt; run' h $ tableCreate (Table (db "prod") "bar" (Just "name")) def{ tableDataCenter = Just "cloud", tableCacheSize = Just 10 }
--   </pre>
tableCreate :: Table -> TableCreateOptions -> ReQL

-- | Drop a table
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ tableDrop (table "bar")
--   [{"dropped":1.0}]
--   </pre>
tableDrop :: Table -> ReQL

-- | List the tables in a database
--   
--   <pre>
--   &gt;&gt;&gt; run h $ tableList (db "test") :: IO (Maybe [String])
--   Just ["foo","posts","users"]
--   </pre>
tableList :: Database -> ReQL

-- | Get a document by primary key
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "users" # get "8d674d7a-873c-4c0f-8a4a-32a4bd5bdee8"
--   [{"post_count":0.0,"name":"nancy","id":"8d674d7a-873c-4c0f-8a4a-32a4bd5bdee8"}]
--   </pre>
get :: Expr s => ReQL -> s -> ReQL

-- | Insert a document or a list of documents into a table
--   
--   <pre>
--   &gt;&gt;&gt; Just wr@WriteResponse{} &lt;- run h $ table "users" # insert (map (\x -&gt; obj ["name":=x]) ["bill", "bob", "nancy" :: Text])
--   &gt;&gt;&gt; let Just [bill, bob, nancy] = writeResponseGeneratedKeys wr
--   &gt;&gt;&gt; run' h $ table "posts" # insert (obj ["author" := bill, "message" := str "hi"])
--   &gt;&gt;&gt; run' h $ table "posts" # insert (obj ["author" := bill, "message" := str "hello"])
--   &gt;&gt;&gt; run' h $ table "posts" # insert (obj ["author" := bob, "message" := str "lorem ipsum"])
--   </pre>
insert :: Expr object => object -> Table -> ReQL

-- | Like insert, but update existing documents with the same primary key
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "users" # upsert (obj ["id" := "79bfe377-9593-402a-ad47-f94c76c36a51", "name" := "rupert"])
--   [{"skipped":0.0,"inserted":0.0,"unchanged":0.0,"deleted":0.0,"replaced":1.0,"errors":0.0}]
--   </pre>
upsert :: (Expr table, Expr object) => object -> table -> ReQL

-- | Add to or modify the contents of a document
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "users" # getAll "name" [str "bob"] # update (const $ obj ["name" := str "benjamin"])
--   [{"skipped":0.0,"inserted":0.0,"unchanged":0.0,"deleted":0.0,"replaced":1.0,"errors":0.0}]
--   </pre>
update :: (Expr selection, Expr a) => (ReQL -> a) -> selection -> ReQL

-- | Replace a document with another
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ replace (\bill -&gt; obj ["name" := str "stoyan", "id" := bill!"id"]) . R.filter ((R.== str "bill") . (!"name")) $ table "users"
--   [{"skipped":0.0,"inserted":0.0,"unchanged":0.0,"deleted":0.0,"replaced":1.0,"errors":0.0}]
--   </pre>
replace :: (Expr selection, Expr a) => (ReQL -> a) -> selection -> ReQL

-- | Delete the documents
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ delete . getAll "name" [str "bob"] $ table "users"
--   [{"skipped":0.0,"inserted":0.0,"unchanged":0.0,"deleted":1.0,"replaced":0.0,"errors":0.0}]
--   </pre>
delete :: Expr selection => selection -> ReQL

-- | Convert a value to a different type
--   
--   <pre>
--   &gt;&gt;&gt; run h $ coerceTo "STRING" 1 :: IO (Maybe String)
--   Just "1"
--   </pre>
coerceTo :: Expr x => ReQL -> x -> ReQL

-- | Convert a value to an array
--   
--   <pre>
--   &gt;&gt;&gt; run h $ asArray $ obj ["a" := 1, "b" := 2] :: IO (Maybe [(String, Int)])
--   Just [("a",1),("b",2)]
--   </pre>
asArray :: Expr x => x -> ReQL

-- | Convert a value to a string
--   
--   <pre>
--   &gt;&gt;&gt; run h $ asString $ obj ["a" := 1, "b" := 2] :: IO (Maybe String)
--   Just "{\n\t\"a\":\t1,\n\t\"b\":\t2\n}"
--   </pre>
asString :: Expr x => x -> ReQL

-- | Convert a value to a number
--   
--   <pre>
--   &gt;&gt;&gt; run h $ asNumber (str "34") :: IO (Maybe Int)
--   Just 34
--   </pre>
asNumber :: Expr x => x -> ReQL

-- | Convert a value to an object
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ asObject $ [(str "a",1),("b",2)]
--   [{"a":1.0,"b":2.0}]
--   </pre>
asObject :: Expr x => x -> ReQL

-- | Convert a value to a boolean
asBool :: Expr x => x -> ReQL

-- | Like hasFields followed by pluck
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ map obj [["a" := 1, "b" := 2], ["a" := 2, "c" := 7], ["b" := 4]] # withFields ["a"]
--   [[{"a":1.0},{"a":2.0}]]
--   </pre>
withFields :: Expr seq => [ReQL] -> seq -> ReQL

-- | The position in the sequence of the elements that match the predicate
--   
--   <pre>
--   &gt;&gt;&gt; run h $ indexesOf (=~ "ba.") [str "foo", "bar", "baz"] :: IO (Maybe [Int])
--   Just [1,2]
--   </pre>
indexesOf :: (Expr fun, Expr seq) => fun -> seq -> ReQL

-- | Test if a sequence is empty
--   
--   <pre>
--   &gt;&gt;&gt; run h $ isEmpty [1] :: IO (Maybe Bool)
--   Just False
--   </pre>
isEmpty :: Expr seq => seq -> ReQL

-- | Select a given number of elements from a sequence with uniform random
--   distribution
--   
--   <pre>
--   &gt;&gt;&gt; run h $ sample 3 [0,1,2,3,4,5,6,7,8,9] :: IO (Maybe [Int])
--   Just [4,3,8]
--   </pre>
sample :: (Expr n, Expr seq) => n -> seq -> ReQL

-- | Prepend an element to an array
--   
--   <pre>
--   &gt;&gt;&gt; run h $ prepend 1 [2,3] :: IO (Maybe [Int])
--   Just [1,2,3]
--   </pre>
prepend :: (Expr datum, Expr array) => datum -> array -> ReQL

-- | Called <i>difference</i> in the official drivers
--   
--   <pre>
--   &gt;&gt;&gt; run h $ [1,2,3,4,5] \\ [2,5] :: IO (Maybe [Int])
--   Just [1,3,4]
--   </pre>
(\\) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Insert a datum into an array if it is not yet present
--   
--   <pre>
--   &gt;&gt;&gt; run h $ setInsert 3 [1,2,4,4,5] :: IO (Maybe [Int])
--   Just [1,2,4,5,3]
--   </pre>
setInsert :: (Expr datum, Expr array) => datum -> array -> ReQL

-- | The union of two sets
--   
--   <pre>
--   &gt;&gt;&gt; run h $ [1,2] `setUnion` [2,3]  :: IO (Maybe [Int])
--   Just [2,3,1]
--   </pre>
setUnion :: (Expr a, Expr b) => a -> b -> ReQL

-- | The intersection of two sets
--   
--   <pre>
--   &gt;&gt;&gt; run h $ [1,2] `setIntersection` [2,3]  :: IO (Maybe [Int])
--   Just [2]
--   </pre>
setIntersection :: (Expr a, Expr b) => a -> b -> ReQL

-- | The difference of two sets
--   
--   <pre>
--   &gt;&gt;&gt; run h $ [2,3] # setDifference [1,2]  :: IO (Maybe [Int])
--   Just [3]
--   </pre>
setDifference :: (Expr set, Expr remove) => remove -> set -> ReQL

-- | Test if an object has the given fields
--   
--   <pre>
--   &gt;&gt;&gt; run h $ hasFields ["a"] $ obj ["a" := 1] :: IO (Maybe Bool)
--   Just True
--   </pre>
hasFields :: Expr obj => ReQL -> obj -> ReQL

-- | Insert a datum at the given position in an array
--   
--   <pre>
--   &gt;&gt;&gt; run h $ insertAt 1 4 [1,2,3] :: IO (Maybe [Int])
--   Just [1,4,2,3]
--   </pre>
insertAt :: (Expr n, Expr datum, Expr array) => n -> datum -> array -> ReQL

-- | Splice an array at a given position inside another array
--   
--   <pre>
--   &gt;&gt;&gt; run h $ spliceAt 2 [4,5] [1,2,3] :: IO (Maybe [Int])
--   Just [1,2,4,5,3]
--   </pre>
spliceAt :: (Expr n, Expr replace, Expr array) => n -> replace -> array -> ReQL

-- | Delete an element from an array
--   
--   <pre>
--   &gt;&gt;&gt; run h $ deleteAt 1 [1,2,3] :: IO (Maybe [Int])
--   Just [1,3]
--   </pre>
deleteAt :: (Expr n, Expr array) => n -> array -> ReQL

-- | Change an element in an array
--   
--   <pre>
--   &gt;&gt;&gt; run h $ changeAt 1 4 [1,2,3] :: IO (Maybe [Int])
--   Just [1,4,3]
--   </pre>
changeAt :: (Expr n, Expr datum, Expr array) => n -> datum -> array -> ReQL

-- | The list of keys of the given object
--   
--   <pre>
--   &gt;&gt;&gt; run h $ keys (obj ["a" := 1, "b" := 2]) :: IO (Maybe [String])
--   Just ["a","b"]
--   </pre>
keys :: Expr obj => obj -> ReQL

-- | Match a string to a regular expression.
--   
--   Called <i>match</i> in the official drivers
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ str "foobar" =~ "f(.)+[bc](.+)"
--   [{"groups":[{"start":2.0,"end":3.0,"str":"o"},{"start":4.0,"end":6.0,"str":"ar"}],"start":0.0,"end":6.0,"str":"foobar"}]
--   </pre>
(=~) :: Expr string => string -> ReQL -> ReQL

-- | Apply a function to a list of arguments.
--   
--   Called <i>do</i> in the official drivers
--   
--   <pre>
--   &gt;&gt;&gt; run h $ (\x -&gt; x R.* 2) `apply` [4] :: IO (Maybe Int)
--   Just 8
--   </pre>
apply :: (Expr fun, Expr arg) => fun -> [arg] -> ReQL

-- | Catch some expections inside the query.
--   
--   Called <i>default</i> in the official drivers
--   
--   <pre>
--   &gt;&gt;&gt; run h $ handle 0 $ obj ["a" := 1] ! "b" :: IO (Maybe Int)
--   Just 0
--   &gt;&gt;&gt; run h $ handle (expr . id) $ obj ["a" := 1] ! "b" :: IO (Maybe String)
--   Just "No attribute `b` in object:\n{\n\t\"a\":\t1\n}"
--   </pre>
handle :: (Expr handler, Expr reql) => handler -> reql -> ReQL

-- | A string representing the type of an expression
--   
--   <pre>
--   &gt;&gt;&gt; run h $ typeOf 1 :: IO (Maybe String)
--   Just "NUMBER"
--   </pre>
typeOf :: Expr a => a -> ReQL

-- | Get information on a given expression. Useful for tables and
--   databases.
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ info $ table "foo"
--   [{"primary_key":"id","name":"foo","indexes":[],"type":"TABLE","db":{"name":"test","type":"DB"}}]
--   </pre>
info :: Expr a => a -> ReQL

-- | Parse a json string into an object
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ json "{a:1}"
--   [{"a":1.0}]
--   </pre>
json :: ReQL -> ReQL

-- | Flipped function application
(#) :: (Expr a, Expr b) => a -> (a -> b) -> ReQL

-- | Specialised function composition
(.) :: (Expr a, Expr b, Expr c) => (ReQL -> b) -> (ReQL -> a) -> c -> ReQL


-- | Haskell client driver for RethinkDB
--   
--   Based upon the official Javascript, Python and Ruby API:
--   <a>http://www.rethinkdb.com/api/</a>
--   
--   <i>How to use</i>
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   import qualified Database.RethinkDB as R
--   import qualified Database.RethinkDB.NoClash
--   </pre>
module Database.RethinkDB

-- | A connection to the database server
data RethinkDBHandle

-- | Create a new connection to the database server
--   
--   <i>Example:</i> connect using the default port with no passphrase
--   
--   <pre>
--   &gt;&gt;&gt; h &lt;- connect "localhost" 28015 Nothing
--   </pre>
connect :: HostName -> Integer -> Maybe String -> IO RethinkDBHandle

-- | Close an open connection
close :: RethinkDBHandle -> IO ()

-- | Set the default database
--   
--   The new handle is an alias for the old one. Calling close on either
--   one will close both.
use :: RethinkDBHandle -> Database -> RethinkDBHandle

-- | Run a given query and return a Result
run :: (Expr query, Result r) => RethinkDBHandle -> query -> IO r

-- | Run a given query and return a JSON
run' :: Expr query => RethinkDBHandle -> query -> IO [JSON]

-- | Run a query with the given options
runOpts :: (Expr query, Result r) => RethinkDBHandle -> [RunOptions] -> query -> IO r

-- | Get the next value from a cursor
next :: Cursor a -> IO (Maybe a)

-- | A lazy stream of all the elements in the cursor
collect :: Cursor a -> IO [a]

-- | Per-query settings
data RunOptions
UseOutdated :: RunOptions
NoReply :: RunOptions
SoftDurability :: Bool -> RunOptions
data Cursor a

-- | The raw response to a query
data Response

-- | Convert the raw query response into useful values
class Result r
convertResult :: Result r => MVar Response -> IO r
data RethinkDBError
RethinkDBError :: ErrorCode -> BaseReQL -> String -> Backtrace -> RethinkDBError
errorCode :: RethinkDBError -> ErrorCode
errorTerm :: RethinkDBError -> BaseReQL
errorMessage :: RethinkDBError -> String
errorBacktrace :: RethinkDBError -> Backtrace
data SuccessCode
SuccessPartial :: RethinkDBHandle -> Int64 -> SuccessCode
Success :: SuccessCode
data ErrorCode
ErrorBrokenClient :: ErrorCode
ErrorBadQuery :: ErrorCode
ErrorRuntime :: ErrorCode
ErrorUnexpectedResponse :: ErrorCode

-- | An RQL term
data ReQL
data JSON
JSON :: Value -> JSON

-- | A database, referenced by name
data Database
Database :: Text -> Database
databaseName :: Database -> Text

-- | Create a Database reference
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ db "test" # info
--   [{"name":"test","type":"DB"}]
--   </pre>
db :: Text -> Database

-- | Create a database on the server
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ dbCreate "dev"
--   [{"created":1.0}]
--   </pre>
dbCreate :: String -> ReQL

-- | Drop a database
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ dbDrop (db "dev")
--   [{"dropped":1.0}]
--   </pre>
dbDrop :: Database -> ReQL

-- | List the databases on the server
--   
--   <pre>
--   &gt;&gt;&gt; run h $ dbList :: IO (Maybe [String])
--   Just ["test"]
--   </pre>
dbList :: ReQL

-- | A table description
data Table
Table :: Maybe Database -> Text -> Maybe Key -> Table

-- | when Nothing, use the connection's database
tableDatabase :: Table -> Maybe Database
tableName :: Table -> Text
tablePrimaryKey :: Table -> Maybe Key

-- | Options used to create a table
data TableCreateOptions
TableCreateOptions :: Maybe Text -> Maybe Int64 -> TableCreateOptions
tableDataCenter :: TableCreateOptions -> Maybe Text
tableCacheSize :: TableCreateOptions -> Maybe Int64

-- | Options used to create an index
data IndexCreateOptions
IndexCreateOptions :: Maybe Bool -> IndexCreateOptions
indexMulti :: IndexCreateOptions -> Maybe Bool

-- | A table
--   
--   <pre>
--   &gt;&gt;&gt; (mapM_ print =&lt;&lt;) $ run' h $ table "users"
--   {"post_count":0.0,"name":"nancy","id":"8d674d7a-873c-4c0f-8a4a-32a4bd5bdee8"}
--   {"post_count":1.0,"name":"bob","id":"b6a9df6a-b92c-46d1-ae43-1d2dd8ec293c"}
--   {"post_count":2.0,"name":"bill","id":"b2908215-1d3c-4ff5-b9ee-1a003fa9690c"}
--   </pre>
table :: Text -> Table

-- | Create a table on the server
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ tableCreate (table "posts") def
--   &gt;&gt;&gt; run' h $ tableCreate (table "users") def
--   &gt;&gt;&gt; run' h $ tableCreate (Table (db "prod") "bar" (Just "name")) def{ tableDataCenter = Just "cloud", tableCacheSize = Just 10 }
--   </pre>
tableCreate :: Table -> TableCreateOptions -> ReQL

-- | Drop a table
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ tableDrop (table "bar")
--   [{"dropped":1.0}]
--   </pre>
tableDrop :: Table -> ReQL

-- | List the tables in a database
--   
--   <pre>
--   &gt;&gt;&gt; run h $ tableList (db "test") :: IO (Maybe [String])
--   Just ["foo","posts","users"]
--   </pre>
tableList :: Database -> ReQL

-- | Create an index on the table from the given function
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "users" # indexCreate "name" (!"name") def
--   [{"created":1.0}]
--   </pre>
indexCreate :: Expr fun => String -> fun -> IndexCreateOptions -> Table -> ReQL

-- | Drop an index
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "users" # indexDrop "name"
--   [{"dropped":1.0}]
--   </pre>
indexDrop :: Key -> Table -> ReQL

-- | List the indexes on the table
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ indexList (table "users")
--   [["name"]]
--   </pre>
indexList :: Table -> ReQL
data WriteResponse
WriteResponse :: Int -> Int -> Int -> Int -> Int -> Int -> Maybe Text -> Maybe [Text] -> Maybe Value -> Maybe Value -> WriteResponse
writeResponseInserted :: WriteResponse -> Int
writeResponseDeleted :: WriteResponse -> Int
writeResponseReplaced :: WriteResponse -> Int
writeResponseUnchanged :: WriteResponse -> Int
writeResponseSkipped :: WriteResponse -> Int
writeResponseErrors :: WriteResponse -> Int
writeResponseFirstError :: WriteResponse -> Maybe Text
writeResponseGeneratedKeys :: WriteResponse -> Maybe [Text]
writeResponseOldVal :: WriteResponse -> Maybe Value
writeResponseNewVal :: WriteResponse -> Maybe Value

-- | Insert a document or a list of documents into a table
--   
--   <pre>
--   &gt;&gt;&gt; Just wr@WriteResponse{} &lt;- run h $ table "users" # insert (map (\x -&gt; obj ["name":=x]) ["bill", "bob", "nancy" :: Text])
--   &gt;&gt;&gt; let Just [bill, bob, nancy] = writeResponseGeneratedKeys wr
--   &gt;&gt;&gt; run' h $ table "posts" # insert (obj ["author" := bill, "message" := str "hi"])
--   &gt;&gt;&gt; run' h $ table "posts" # insert (obj ["author" := bill, "message" := str "hello"])
--   &gt;&gt;&gt; run' h $ table "posts" # insert (obj ["author" := bob, "message" := str "lorem ipsum"])
--   </pre>
insert :: Expr object => object -> Table -> ReQL

-- | Like insert, but update existing documents with the same primary key
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "users" # upsert (obj ["id" := "79bfe377-9593-402a-ad47-f94c76c36a51", "name" := "rupert"])
--   [{"skipped":0.0,"inserted":0.0,"unchanged":0.0,"deleted":0.0,"replaced":1.0,"errors":0.0}]
--   </pre>
upsert :: (Expr table, Expr object) => object -> table -> ReQL

-- | Add to or modify the contents of a document
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "users" # getAll "name" [str "bob"] # update (const $ obj ["name" := str "benjamin"])
--   [{"skipped":0.0,"inserted":0.0,"unchanged":0.0,"deleted":0.0,"replaced":1.0,"errors":0.0}]
--   </pre>
update :: (Expr selection, Expr a) => (ReQL -> a) -> selection -> ReQL

-- | Replace a document with another
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ replace (\bill -&gt; obj ["name" := str "stoyan", "id" := bill!"id"]) . R.filter ((R.== str "bill") . (!"name")) $ table "users"
--   [{"skipped":0.0,"inserted":0.0,"unchanged":0.0,"deleted":0.0,"replaced":1.0,"errors":0.0}]
--   </pre>
replace :: (Expr selection, Expr a) => (ReQL -> a) -> selection -> ReQL

-- | Delete the documents
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ delete . getAll "name" [str "bob"] $ table "users"
--   [{"skipped":0.0,"inserted":0.0,"unchanged":0.0,"deleted":1.0,"replaced":0.0,"errors":0.0}]
--   </pre>
delete :: Expr selection => selection -> ReQL

-- | Include the value of single write operations in the returned object
returnVals :: ReQL -> ReQL

-- | Allow non-atomic replace
nonAtomic :: ReQL -> ReQL

-- | An upper or lower bound for between and during
data Bound a

-- | An inclusive bound
Open :: a -> Bound a
getBound :: Bound a -> a

-- | An exclusive bound
Closed :: a -> Bound a
getBound :: Bound a -> a

-- | Get a document by primary key
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "users" # get "8d674d7a-873c-4c0f-8a4a-32a4bd5bdee8"
--   [{"post_count":0.0,"name":"nancy","id":"8d674d7a-873c-4c0f-8a4a-32a4bd5bdee8"}]
--   </pre>
get :: Expr s => ReQL -> s -> ReQL

-- | Filter a sequence given a predicate
--   
--   <pre>
--   &gt;&gt;&gt; run h $ R.filter (R.&lt; 4) [3, 1, 4, 1, 5, 9, 2, 6] :: IO (Maybe [Int])
--   Just [3,1,1,2]
--   </pre>
filter :: (Expr predicate, Expr seq) => predicate -> seq -> ReQL

-- | Query all the documents whose value for the given index is in a given
--   range
--   
--   <pre>
--   &gt;&gt;&gt; run h $ table "users" # between "id" (Closed $ str "a") (Open $ str "n") :: IO [JSON]
--   [{"post_count":4.0,"name":"bob","id":"b6a9df6a-b92c-46d1-ae43-1d2dd8ec293c"},{"post_count":4.0,"name":"bill","id":"b2908215-1d3c-4ff5-b9ee-1a003fa9690c"}]
--   </pre>
between :: (Expr left, Expr right, Expr seq) => Key -> Bound left -> Bound right -> seq -> ReQL

-- | Retreive documents by their indexed value
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "users" # getAll "name" ["bob"]
--   [{"post_count":1.0,"name":"bob","id":"b6a9df6a-b92c-46d1-ae43-1d2dd8ec293c"}]
--   </pre>
getAll :: Expr value => Key -> [value] -> Table -> ReQL

-- | SQL-like inner join of two sequences
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ innerJoin (\user post -&gt; user!"id" R.== post!"author") (table "users") (table "posts") # mergeLeftRight # without ["id", "author"]
--   [[{"name":"bob","message":"lorem ipsum"},{"name":"bill","message":"hello"},{"name":"bill","message":"hi"}]]
--   </pre>
innerJoin :: (Expr a, Expr b, Expr c) => (ReQL -> ReQL -> c) -> a -> b -> ReQL

-- | SQL-like outer join of two sequences
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ outerJoin (\user post -&gt; user!"id" R.== post!"author") (table "users") (table "posts") # mergeLeftRight # without ["id", "author"]
--   [[{"name":"nancy"},{"name":"bill","message":"hello"},{"name":"bill","message":"hi"},{"name":"bob","message":"lorem ipsum"}]]
--   </pre>
outerJoin :: (Expr a, Expr b, Expr c) => (ReQL -> ReQL -> c) -> a -> b -> ReQL

-- | An efficient inner_join that uses a key for the left table and an
--   index for the right table.
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "posts" # eqJoin "author" (table "users") "id" # mergeLeftRight # without ["id", "author"]
--   [[{"name":"bill","message":"hi"},{"name":"bob","message":"lorem ipsum"},{"name":"bill","message":"hello"}]]
--   </pre>
eqJoin :: (Expr right, Expr left) => Key -> right -> Key -> left -> ReQL

-- | Merge the "left" and "right" attributes of the objects in a sequence.
--   
--   Called <i>zip</i> in the official drivers
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "posts" # eqJoin "author" (table "users") "id" # mergeLeftRight
--   </pre>
mergeLeftRight :: Expr a => a -> ReQL

-- | Map a function over a sequence
--   
--   <pre>
--   &gt;&gt;&gt; run h $ R.map (!"a") [obj ["a" := 1], obj ["a" := 2]] :: IO (Maybe [Int])
--   Just [1,2]
--   </pre>
map :: (Expr a, Expr b) => (ReQL -> b) -> a -> ReQL

-- | Like hasFields followed by pluck
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ map obj [["a" := 1, "b" := 2], ["a" := 2, "c" := 7], ["b" := 4]] # withFields ["a"]
--   [[{"a":1.0},{"a":2.0}]]
--   </pre>
withFields :: Expr seq => [ReQL] -> seq -> ReQL

-- | Map a function of a sequence and concat the results
--   
--   <pre>
--   &gt;&gt;&gt; run h $ concatMap id [[1, 2], [3], [4, 5]] :: IO (Maybe [Int])
--   Just [1,2,3,4,5]
--   </pre>
concatMap :: (Expr a, Expr b) => (ReQL -> b) -> a -> ReQL

-- | Drop elements from the head of a sequence.
--   
--   Called <i>skip</i> in the official drivers
--   
--   <pre>
--   &gt;&gt;&gt; run h $ R.drop 2 [1, 2, 3, 4] :: IO (Maybe [Int])
--   Just [3,4]
--   </pre>
drop :: (Expr a, Expr b) => a -> b -> ReQL

-- | Limit the size of a sequence.
--   
--   Called <i>limit</i> in the official drivers
--   
--   <pre>
--   &gt;&gt;&gt; run h $ R.take 2 [1, 2, 3, 4] :: IO (Maybe [Int])
--   Just [1,2]
--   </pre>
take :: (Expr n, Expr seq) => n -> seq -> ReQL

-- | Get the nth value of a sequence or array
--   
--   <pre>
--   &gt;&gt;&gt; run h $ [1, 2, 3] !! 0 :: IO (Maybe Int)
--   Just 1
--   </pre>
(!!) :: Expr a => a -> ReQL -> ReQL

-- | Cut out part of a sequence
--   
--   <pre>
--   &gt;&gt;&gt; run h $ slice 2 4 [1, 2, 3, 4, 5] :: IO (Maybe [Int])
--   Just [3,4]
--   </pre>
slice :: (Expr a, Expr b, Expr c) => a -> b -> c -> ReQL

-- | Order a sequence by the given keys
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "users" # orderBy [Desc "post_count", Asc "name"] # pluck ["name", "post_count"]
--   [[{"post_count":2.0,"name":"bill"},{"post_count":1.0,"name":"bob"},{"name":"nancy"}]]
--   </pre>
orderBy :: Expr s => [Order] -> s -> ReQL

-- | Ordering specification for orderBy
data Order

-- | Ascending order
Asc :: Key -> Order
orderAttr :: Order -> Key

-- | Descending order
Desc :: Key -> Order
orderAttr :: Order -> Key

-- | The position in the sequence of the elements that match the predicate
--   
--   <pre>
--   &gt;&gt;&gt; run h $ indexesOf (=~ "ba.") [str "foo", "bar", "baz"] :: IO (Maybe [Int])
--   Just [1,2]
--   </pre>
indexesOf :: (Expr fun, Expr seq) => fun -> seq -> ReQL

-- | Test if a sequence is empty
--   
--   <pre>
--   &gt;&gt;&gt; run h $ isEmpty [1] :: IO (Maybe Bool)
--   Just False
--   </pre>
isEmpty :: Expr seq => seq -> ReQL

-- | Join two sequences.
--   
--   Called <i>union</i> in the official drivers
--   
--   <pre>
--   &gt;&gt;&gt; run h $ [1,2,3] R.++ ["a", "b", "c" :: Text] :: IO (Maybe [JSON])
--   Just [1.0,2.0,3.0,"a","b","c"]
--   </pre>
(++) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Select a given number of elements from a sequence with uniform random
--   distribution
--   
--   <pre>
--   &gt;&gt;&gt; run h $ sample 3 [0,1,2,3,4,5,6,7,8,9] :: IO (Maybe [Int])
--   Just [4,3,8]
--   </pre>
sample :: (Expr n, Expr seq) => n -> seq -> ReQL

-- | Reduce a sequence to a single value
--   
--   <pre>
--   &gt;&gt;&gt; run h $ reduce (+) 0 [1, 2, 3] :: IO (Maybe Int)
--   Just 6
--   </pre>
reduce :: (Expr base, Expr seq, Expr a) => (ReQL -> ReQL -> a) -> base -> seq -> ReQL

-- | Reduce a non-empty sequence to a single value
--   
--   <pre>
--   &gt;&gt;&gt; run h $ reduce1 (+) [1, 2, 3] :: IO (Maybe Int)
--   Just 6
--   </pre>
reduce1 :: (Expr a, Expr s) => (ReQL -> ReQL -> a) -> s -> ReQL

-- | Filter out identical elements of the sequence
--   
--   Called <i>distint</i> in the official drivers
--   
--   <pre>
--   &gt;&gt;&gt; run h $ nub (table "posts" ! "flag") :: IO (Maybe [String])
--   Just ["pinned", "deleted"]
--   </pre>
nub :: Expr s => s -> ReQL

-- | Turn a grouping function and a reduction function into a grouped map
--   reduce operation
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "posts" # groupBy (!"author") (reduce1 (\a b -&gt; a + "\n" + b) . R.map (!"message"))
--   [[{"group":"b2908215-1d3c-4ff5-b9ee-1a003fa9690c","reduction":"hi\nhello"},{"group":"b6a9df6a-b92c-46d1-ae43-1d2dd8ec293c","reduction":"lorem ipsum"}]]
--   &gt;&gt;&gt; run' h $ table "users" # groupBy (!"level") (\users -&gt; let pc = users!"post_count" in [avg pc, R.sum pc])
--   [[{"group":1,"reduction":[1.5,3.0]},{"group":2,"reduction":[0.0,0.0]}]]
--   </pre>
groupBy :: (Expr group, Expr reduction, Expr seq) => (ReQL -> group) -> (ReQL -> reduction) -> seq -> ReQL

-- | Test if a sequence contains a given element
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ 1 `R.elem` [1,2,3]
--   [true]
--   </pre>
elem :: (Expr x, Expr seq) => x -> seq -> ReQL

-- | The size of a sequence or an array.
--   
--   Called <i>count</i> in the official drivers
--   
--   <pre>
--   &gt;&gt;&gt; run h $ R.length (table "foo") :: IO (Maybe Int)
--   Just 17
--   </pre>
length :: Expr a => a -> ReQL

-- | The sum of a sequence
--   
--   <pre>
--   &gt;&gt;&gt; run h $ sum [1, 2, 3] :: IO (Maybe Int)
--   Just 6
--   </pre>
sum :: Expr s => s -> ReQL

-- | The average of a sequence
--   
--   <pre>
--   &gt;&gt;&gt; run h $ avg [1, 2, 3, 4] :: IO (Maybe Double)
--   Just 2.5
--   </pre>
avg :: Expr s => s -> ReQL

-- | Keep only the given attributes
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ map obj [["a" := 1, "b" := 2], ["a" := 2, "c" := 7], ["b" := 4]] # pluck ["a"]
--   [[{"a":1.0},{"a":2.0},{}]]
--   </pre>
pluck :: Expr o => [ReQL] -> o -> ReQL

-- | Remove the given attributes from an object
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ map obj [["a" := 1, "b" := 2], ["a" := 2, "c" := 7], ["b" := 4]] # without ["a"]
--   [[{"b":2.0},{"c":7.0},{"b":4.0}]]
--   </pre>
without :: Expr o => [ReQL] -> o -> ReQL

-- | Merge two objects together
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ merge (obj ["a" := 1, "b" := 1]) (obj ["b" := 2, "c" := 2])
--   [{"a":1.0,"b":2.0,"c":2.0}]
--   </pre>
merge :: (Expr a, Expr b) => a -> b -> ReQL

-- | Append a datum to a sequence
--   
--   <pre>
--   &gt;&gt;&gt; run h $ append 3 [1, 2] :: IO (Maybe [Int])
--   Just [1,2,3]
--   </pre>
append :: (Expr a, Expr b) => a -> b -> ReQL

-- | Prepend an element to an array
--   
--   <pre>
--   &gt;&gt;&gt; run h $ prepend 1 [2,3] :: IO (Maybe [Int])
--   Just [1,2,3]
--   </pre>
prepend :: (Expr datum, Expr array) => datum -> array -> ReQL

-- | Called <i>difference</i> in the official drivers
--   
--   <pre>
--   &gt;&gt;&gt; run h $ [1,2,3,4,5] \\ [2,5] :: IO (Maybe [Int])
--   Just [1,3,4]
--   </pre>
(\\) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Insert a datum into an array if it is not yet present
--   
--   <pre>
--   &gt;&gt;&gt; run h $ setInsert 3 [1,2,4,4,5] :: IO (Maybe [Int])
--   Just [1,2,4,5,3]
--   </pre>
setInsert :: (Expr datum, Expr array) => datum -> array -> ReQL

-- | The union of two sets
--   
--   <pre>
--   &gt;&gt;&gt; run h $ [1,2] `setUnion` [2,3]  :: IO (Maybe [Int])
--   Just [2,3,1]
--   </pre>
setUnion :: (Expr a, Expr b) => a -> b -> ReQL

-- | The intersection of two sets
--   
--   <pre>
--   &gt;&gt;&gt; run h $ [1,2] `setIntersection` [2,3]  :: IO (Maybe [Int])
--   Just [2]
--   </pre>
setIntersection :: (Expr a, Expr b) => a -> b -> ReQL

-- | The difference of two sets
--   
--   <pre>
--   &gt;&gt;&gt; run h $ [2,3] # setDifference [1,2]  :: IO (Maybe [Int])
--   Just [3]
--   </pre>
setDifference :: (Expr set, Expr remove) => remove -> set -> ReQL

-- | Get a single field from an object
--   
--   <pre>
--   &gt;&gt;&gt; run h $ (obj ["foo" := True]) ! "foo" :: IO (Maybe Bool)
--   Just True
--   </pre>
--   
--   Or a single field from each object in a sequence
--   
--   <pre>
--   &gt;&gt;&gt; run h $ [obj ["foo" := True], obj ["foo" := False]] ! "foo" :: IO (Maybe [Bool])
--   Just [True,False]
--   </pre>
(!) :: Expr s => s -> ReQL -> ReQL

-- | Test if an object has the given fields
--   
--   <pre>
--   &gt;&gt;&gt; run h $ hasFields ["a"] $ obj ["a" := 1] :: IO (Maybe Bool)
--   Just True
--   </pre>
hasFields :: Expr obj => ReQL -> obj -> ReQL

-- | Insert a datum at the given position in an array
--   
--   <pre>
--   &gt;&gt;&gt; run h $ insertAt 1 4 [1,2,3] :: IO (Maybe [Int])
--   Just [1,4,2,3]
--   </pre>
insertAt :: (Expr n, Expr datum, Expr array) => n -> datum -> array -> ReQL

-- | Splice an array at a given position inside another array
--   
--   <pre>
--   &gt;&gt;&gt; run h $ spliceAt 2 [4,5] [1,2,3] :: IO (Maybe [Int])
--   Just [1,2,4,5,3]
--   </pre>
spliceAt :: (Expr n, Expr replace, Expr array) => n -> replace -> array -> ReQL

-- | Delete an element from an array
--   
--   <pre>
--   &gt;&gt;&gt; run h $ deleteAt 1 [1,2,3] :: IO (Maybe [Int])
--   Just [1,3]
--   </pre>
deleteAt :: (Expr n, Expr array) => n -> array -> ReQL

-- | Change an element in an array
--   
--   <pre>
--   &gt;&gt;&gt; run h $ changeAt 1 4 [1,2,3] :: IO (Maybe [Int])
--   Just [1,4,3]
--   </pre>
changeAt :: (Expr n, Expr datum, Expr array) => n -> datum -> array -> ReQL

-- | The list of keys of the given object
--   
--   <pre>
--   &gt;&gt;&gt; run h $ keys (obj ["a" := 1, "b" := 2]) :: IO (Maybe [String])
--   Just ["a","b"]
--   </pre>
keys :: Expr obj => obj -> ReQL

-- | Addition or concatenation
--   
--   Use the Num instance, or a qualified operator.
--   
--   <pre>
--   &gt;&gt;&gt; run h $ 2 + 5 :: IO (Maybe Int)
--   Just 7
--   &gt;&gt;&gt; run h $ 2 R.+ 5 :: IO (Maybe Int)
--   Just 7
--   &gt;&gt;&gt; run h $ (str "foo") + (str "bar") :: IO (Just String)
--   Just "foobar"
--   </pre>
(+) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Subtraction
--   
--   <pre>
--   &gt;&gt;&gt; run h $ 2 - 5 :: IO (Maybe Int)
--   Just (-3)
--   </pre>
(-) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Multiplication
--   
--   <pre>
--   &gt;&gt;&gt; run h $ 2 * 5 :: IO (Maybe Int)
--   Just 10
--   </pre>
(*) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Division
--   
--   <pre>
--   &gt;&gt;&gt; run h $ 2 R./ 5 :: IO (Maybe Double)
--   Just 0.4
--   </pre>
(/) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Mod
--   
--   <pre>
--   &gt;&gt;&gt; run h $ 5 `mod` 2 :: IO (Maybe Int)
--   Just 1
--   </pre>
mod :: (Expr a, Expr b) => a -> b -> ReQL

-- | Boolean and
--   
--   <pre>
--   &gt;&gt;&gt; run h $ True R.&amp;&amp; False :: IO (Maybe Bool)
--   Just False
--   </pre>
(&&) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Boolean or
--   
--   <pre>
--   &gt;&gt;&gt; run h $ True R.|| False :: IO (Maybe Bool)
--   Just True
--   </pre>
(||) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Test for equality
--   
--   <pre>
--   &gt;&gt;&gt; run h $ obj ["a" := 1] R.== obj ["a" := 1] :: IO (Maybe Bool)
--   Just True
--   </pre>
(==) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Test for inequality
--   
--   <pre>
--   &gt;&gt;&gt; run h $ 1 R./= False :: IO (Maybe Bool)
--   Just True
--   </pre>
(/=) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Greater than
--   
--   <pre>
--   &gt;&gt;&gt; run h $ 3 R.&gt; 2 :: IO (Maybe Bool)
--   Just True
--   </pre>
(>) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Lesser than
--   
--   <pre>
--   &gt;&gt;&gt; run h $ (str "a") R.&lt; (str "b") :: IO (Maybe Bool)
--   Just True
--   </pre>
(<) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Lesser than or equal to
--   
--   <pre>
--   &gt;&gt;&gt; run h $ 2 R.&lt;= 2 :: IO (Maybe Bool)
--   Just True
--   </pre>
(<=) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Greater than or equal to
--   
--   <pre>
--   &gt;&gt;&gt; run h $ [1] R.&gt;= () :: IO (Maybe Bool)
--   Just False
--   </pre>
(>=) :: (Expr a, Expr b) => a -> b -> ReQL

-- | Negation
--   
--   <pre>
--   &gt;&gt;&gt; run h $ R.not False :: IO (Maybe Bool)
--   Just True
--   &gt;&gt;&gt; run h $ R.not () :: IO (Maybe Bool)
--   Just True
--   </pre>
not :: Expr a => a -> ReQL

-- | Match a string to a regular expression.
--   
--   Called <i>match</i> in the official drivers
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ str "foobar" =~ "f(.)+[bc](.+)"
--   [{"groups":[{"start":2.0,"end":3.0,"str":"o"},{"start":4.0,"end":6.0,"str":"ar"}],"start":0.0,"end":6.0,"str":"foobar"}]
--   </pre>
(=~) :: Expr string => string -> ReQL -> ReQL

-- | Time with no time zone
--   
--   The default FromJSON instance for Data.Time.UTCTime is incompatible
--   with ReQL's time type
newtype UTCTime
UTCTime :: UTCTime -> UTCTime

-- | Time with a time zone
--   
--   The default FromJSON instance for Data.Time.ZonedTime is incompatible
--   with ReQL's time type
newtype ZonedTime
ZonedTime :: ZonedTime -> ZonedTime

-- | The time and date when the query is executed
--   
--   <pre>
--   &gt;&gt;&gt; run h $ now :: IO (Maybe R.ZonedTime)
--   Just 2013-10-28 00:01:43.930000066757 +0000
--   </pre>
now :: ReQL

-- | Build a time object from the year, month, day, hour, minute, second
--   and timezone fields
--   
--   <pre>
--   &gt;&gt;&gt; run h $ time 2011 12 24 23 59 59 "Z" :: IO (Maybe R.ZonedTime)
--   Just 2011-12-24 23:59:59 +0000
--   </pre>
time :: ReQL -> ReQL -> ReQL -> ReQL -> ReQL -> ReQL -> ReQL -> ReQL

-- | Build a time object given the number of seconds since the unix epoch
--   
--   <pre>
--   &gt;&gt;&gt; run h $ epochTime 1147162826 :: IO (Maybe R.ZonedTime)
--   Just 2006-05-09 08:20:26 +0000
--   </pre>
epochTime :: ReQL -> ReQL

-- | Build a time object given an iso8601 string
--   
--   <pre>
--   &gt;&gt;&gt; run h $ iso8601 "2012-01-07T08:34:00-0700" :: IO (Maybe R.UTCTime)
--   Just 2012-01-07 15:34:00 UTC
--   </pre>
iso8601 :: ReQL -> ReQL

-- | The same time in a different timezone
--   
--   <pre>
--   &gt;&gt;&gt; run h $ inTimezone "+0800" now :: IO (Maybe R.ZonedTime)
--   Just 2013-10-28 08:16:39.22000002861 +0800
--   </pre>
inTimezone :: Expr time => ReQL -> time -> ReQL

-- | Test if a time is between two other times
--   
--   <pre>
--   &gt;&gt;&gt; run h $ during (Open $ now - (60*60)) (Closed now) $ epochTime 1382919271 :: IO (Maybe Bool)
--   Just True
--   </pre>
during :: (Expr left, Expr right, Expr time) => Bound left -> Bound right -> time -> ReQL

-- | Extract part of a time value
timezone :: Expr time => time -> ReQL

-- | Extract part of a time value
date :: Expr time => time -> ReQL

-- | Extract part of a time value
timeOfDay :: Expr time => time -> ReQL

-- | Extract part of a time value
year :: Expr time => time -> ReQL

-- | Extract part of a time value
month :: Expr time => time -> ReQL

-- | Extract part of a time value
day :: Expr time => time -> ReQL

-- | Extract part of a time value
dayOfWeek :: Expr time => time -> ReQL

-- | Extract part of a time value
dayOfYear :: Expr time => time -> ReQL

-- | Extract part of a time value
hours :: Expr time => time -> ReQL

-- | Extract part of a time value
minutes :: Expr time => time -> ReQL

-- | Extract part of a time value
seconds :: Expr time => time -> ReQL

-- | Convert a time to another representation
toIso8601 :: Expr t => t -> ReQL

-- | Convert a time to another representation
toEpochTime :: Expr t => t -> ReQL

-- | Apply a function to a list of arguments.
--   
--   Called <i>do</i> in the official drivers
--   
--   <pre>
--   &gt;&gt;&gt; run h $ (\x -&gt; x R.* 2) `apply` [4] :: IO (Maybe Int)
--   Just 8
--   </pre>
apply :: (Expr fun, Expr arg) => fun -> [arg] -> ReQL

-- | Evaluate a JavaScript expression
--   
--   <pre>
--   &gt;&gt;&gt; run h $ js "Math.random()" :: IO (Maybe Double)
--   Just 0.9119815775193274
--   &gt;&gt;&gt; run h $ R.map (\x -&gt; js "Math.sin" `apply` [x]) [pi, pi/2] :: IO (Maybe [Double])
--   Just [1.2246063538223773e-16,1.0]
--   </pre>
js :: ReQL -> ReQL

-- | Called <i>branch</i> in the official drivers
--   
--   <pre>
--   &gt;&gt;&gt; run h $ if' (1 R.&lt; 2) 3 4 :: IO (Maybe Int)
--   Just 3
--   </pre>
if' :: (Expr a, Expr b, Expr c) => a -> b -> c -> ReQL

-- | Like map but for write queries
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ table "users" # replace (without ["post_count"])
--   &gt;&gt;&gt; run' h $ forEach (table "posts") $ \post -&gt; table "users" # get (post!"author") # update (\user -&gt; obj ["post_count" := (handle 0 (user!"post_count") + 1)])
--   [{"skipped":0.0,"inserted":0.0,"unchanged":0.0,"deleted":0.0,"replaced":3.0,"errors":0.0}]
--   </pre>
forEach :: (Expr s, Expr a) => s -> (ReQL -> a) -> ReQL

-- | Abort the query with an error
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ R.error (str "haha") R./ 2 + 1
--   *** Exception: RethinkDBError {errorCode = runtime error, errorTerm = ADD(DIV(ERROR("haha"), 2.0), 1.0), errorMessage = "haha", errorBacktrace = [0,0]}
--   </pre>
error :: Expr s => s -> ReQL

-- | Catch some expections inside the query.
--   
--   Called <i>default</i> in the official drivers
--   
--   <pre>
--   &gt;&gt;&gt; run h $ handle 0 $ obj ["a" := 1] ! "b" :: IO (Maybe Int)
--   Just 0
--   &gt;&gt;&gt; run h $ handle (expr . id) $ obj ["a" := 1] ! "b" :: IO (Maybe String)
--   Just "No attribute `b` in object:\n{\n\t\"a\":\t1\n}"
--   </pre>
handle :: (Expr handler, Expr reql) => handler -> reql -> ReQL

-- | Convert other types into ReqL expressions
class Expr e
expr :: Expr e => e -> ReQL

-- | Convert a value to a different type
--   
--   <pre>
--   &gt;&gt;&gt; run h $ coerceTo "STRING" 1 :: IO (Maybe String)
--   Just "1"
--   </pre>
coerceTo :: Expr x => ReQL -> x -> ReQL

-- | Convert a value to an array
--   
--   <pre>
--   &gt;&gt;&gt; run h $ asArray $ obj ["a" := 1, "b" := 2] :: IO (Maybe [(String, Int)])
--   Just [("a",1),("b",2)]
--   </pre>
asArray :: Expr x => x -> ReQL

-- | Convert a value to a string
--   
--   <pre>
--   &gt;&gt;&gt; run h $ asString $ obj ["a" := 1, "b" := 2] :: IO (Maybe String)
--   Just "{\n\t\"a\":\t1,\n\t\"b\":\t2\n}"
--   </pre>
asString :: Expr x => x -> ReQL

-- | Convert a value to a number
--   
--   <pre>
--   &gt;&gt;&gt; run h $ asNumber (str "34") :: IO (Maybe Int)
--   Just 34
--   </pre>
asNumber :: Expr x => x -> ReQL

-- | Convert a value to an object
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ asObject $ [(str "a",1),("b",2)]
--   [{"a":1.0,"b":2.0}]
--   </pre>
asObject :: Expr x => x -> ReQL

-- | Convert a value to a boolean
asBool :: Expr x => x -> ReQL

-- | A string representing the type of an expression
--   
--   <pre>
--   &gt;&gt;&gt; run h $ typeOf 1 :: IO (Maybe String)
--   Just "NUMBER"
--   </pre>
typeOf :: Expr a => a -> ReQL

-- | Get information on a given expression. Useful for tables and
--   databases.
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ info $ table "foo"
--   [{"primary_key":"id","name":"foo","indexes":[],"type":"TABLE","db":{"name":"test","type":"DB"}}]
--   </pre>
info :: Expr a => a -> ReQL

-- | Parse a json string into an object
--   
--   <pre>
--   &gt;&gt;&gt; run' h $ json "{a:1}"
--   [{"a":1.0}]
--   </pre>
json :: ReQL -> ReQL

-- | Convert into a ReQL object
class Obj o
obj :: Obj o => o -> Object

-- | A list of key/value pairs
data Object

-- | A key/value pair used for building objects
data Attribute
(:=) :: Text -> e -> Attribute

-- | A shortcut for inserting strings into ReQL expressions Useful when
--   OverloadedStrings makes the type ambiguous
str :: String -> ReQL

-- | A shortcut for inserting numbers into ReQL expressions
num :: Double -> ReQL

-- | Specialised function composition
(.) :: (Expr a, Expr b, Expr c) => (ReQL -> b) -> (ReQL -> a) -> c -> ReQL

-- | Flipped function application
(#) :: (Expr a, Expr b) => a -> (a -> b) -> ReQL

-- | The default value for this type.
def :: Default a => a


-- | This module exports all of Database.RethinkDB except for the names
--   that clash with Prelude or Data.Time
module Database.RethinkDB.NoClash
