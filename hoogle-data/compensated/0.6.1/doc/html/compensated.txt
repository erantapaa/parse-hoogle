-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Compensated floating-point arithmetic
--   
--   This package provides compensated floating point arithmetic.
@package compensated
@version 0.6.1


-- | This module provides a fairly extensive API for compensated floating
--   point arithmetic based on Knuth's error free transformation, various
--   algorithms by Ogita, Rump and Oishi, Hida, Li and Bailey, Kahan
--   summation, etc. with custom compensated arithmetic circuits to do
--   multiplication, division, etc. of compensated numbers.
--   
--   In general if <tt>a</tt> has x bits of significand, <tt>Compensated
--   a</tt> gives you twice that. You can iterate this construction for
--   arbitrary precision.
--   
--   References:
--   
--   <ul>
--   
--   <li><a>http://web.mit.edu/tabbott/Public/quaddouble-debian/qd-2.3.4-old/docs/qd.pdf</a></li>
--   <li><a>http://www.ti3.tuhh.de/paper/rump/OgRuOi05.pdf</a></li>
--   <li>Donald Knuth's "The Art of Computer Programming, Volume 2:
--   Seminumerical Algorithms"</li>
--   <li><a>http://en.wikipedia.org/wiki/Kahan_summation_algorithm</a></li>
--   </ul>
module Numeric.Compensated
class (RealFrac a, Precise a, Floating a) => Compensable a where data family Compensated a
with :: (Compensable a, Compensable a) => Compensated a -> (a -> a -> r) -> r
compensated :: (Compensable a, Compensable a) => a -> a -> Compensated a
magic :: Compensable a => a

-- | This provides the isomorphism between the compact representation we
--   store these in internally and the naive pair of the <a>primal</a> and
--   <a>residual</a> components.
_Compensated :: Compensable a => Iso' (Compensated a) (a, a)
type Overcompensated a = Compensated (Compensated a)

-- | This <a>Lens</a> lets us edit the <a>primal</a> directly, leaving the
--   <a>residual</a> untouched.
primal :: Compensable a => Lens' (Compensated a) a

-- | This <a>Lens</a> lets us edit the <a>residual</a> directly, leaving
--   the <a>primal</a> untouched.
residual :: Compensable a => Lens' (Compensated a) a

-- | Extract the <a>primal</a> component of a <a>compensated</a> value,
--   when and if compensation is no longer required.
uncompensated :: Compensable a => Compensated a -> a

-- | <tt><a>fadd</a> a b k</tt> computes <tt>k x y</tt> such that
--   
--   <pre>
--   x + y = a + b
--   x = fl(a + b)
--   </pre>
--   
--   but only under the assumption that <tt><a>abs</a> a <a>&gt;=</a>
--   <a>abs</a> b</tt>. If you aren't sure, use <a>add</a>.
--   
--   Which is to say that <tt>x</tt> is the floating point image of <tt>(a
--   + b)</tt> and <tt>y</tt> stores the residual error term.
fadd :: Num a => a -> a -> (a -> a -> r) -> r

-- | <tt><a>add</a> a b k</tt> computes <tt>k x y</tt> such that
--   
--   <pre>
--   x + y = a + b
--   x = fl(a + b)
--   </pre>
--   
--   Which is to say that <tt>x</tt> is the floating point image of <tt>(a
--   + b)</tt> and <tt>y</tt> stores the residual error term.
add :: Num a => a -> a -> (a -> a -> r) -> r

-- | <tt><a>times</a> a b k</tt> computes <tt>k x y</tt> such that
--   
--   <pre>
--   x + y = a * b
--   x = fl(a * b)
--   </pre>
--   
--   Which is to say that <tt>x</tt> is the floating point image of <tt>(a
--   * b)</tt> and <tt>y</tt> stores the residual error term.
--   
--   This could be nicer if we had access to a hardware fused multiply-add.
times :: Compensable a => a -> a -> (a -> a -> r) -> r

-- | <tt><a>squared</a> a k</tt> computes <tt>k x y</tt> such that
--   
--   <pre>
--   x + y = a * a
--   x = fl(a * a)
--   </pre>
--   
--   Which is to say that <tt>x</tt> is the floating point image of <tt>(a
--   * a)</tt> and <tt>y</tt> stores the residual error term.
squared :: Compensable a => a -> (a -> a -> r) -> r
divide :: Compensable a => a -> a -> (a -> a -> r) -> r

-- | error-free split of a floating point number into two parts.
--   
--   Note: these parts do not satisfy the <a>compensated</a> contract
split :: Compensable a => a -> (a -> a -> r) -> r

-- | Perform Kahan summation over a list.
kahan :: (Foldable f, Compensable a) => f a -> Compensated a

-- | Calculate a scalar + compensated sum with Kahan summation.
(+^) :: Compensable a => a -> Compensated a -> Compensated a

-- | Compute <tt>a * <a>Compensated</a> a</tt>
(*^) :: Compensable a => a -> Compensated a -> Compensated a

-- | Calculate a fast square of a compensated number.
square :: Compensable a => Compensated a -> Compensated a
instance (Compensable a, Precise a) => Precise (Compensated a)
instance Compensable a => Floating (Compensated a)
instance (Compensable a, Unbox a) => Vector Vector (Compensated a)
instance (Compensable a, Unbox a) => MVector MVector (Compensated a)
instance (Compensable a, Storable a) => Storable (Compensated a)
instance (Compensable a, Serialize a) => SafeCopy (Compensated a)
instance (Compensable a, Serial a) => Serial (Compensated a)
instance (Compensable a, Serialize a) => Serialize (Compensated a)
instance (Compensable a, Binary a) => Binary (Compensated a)
instance Compensable a => RealFrac (Compensated a)
instance Compensable a => Real (Compensated a)
instance Compensable a => Fractional (Compensated a)
instance Compensable a => Enum (Compensated a)
instance Compensable a => Num (Compensated a)
instance Compensable a => Monoid (Compensated a)
instance Compensable a => Semigroup (Compensated a)
instance Compensable a => Ord (Compensated a)
instance Compensable a => Eq (Compensated a)
instance (Compensable a, Compensable b) => Each (Compensated a) (Compensated b) a b
instance (Compensable a, Read a) => Read (Compensated a)
instance (Compensable a, Show a) => Show (Compensated a)
instance (Compensable a, NFData a) => NFData (Compensated a)
instance (Compensable a, Data a) => Data (Compensated a)
instance (Compensable a, Hashable a) => Hashable (Compensated a)
instance Typeable1 Compensated
instance Compensable a => Compensable (Compensated a)
instance Compensable Float
instance Compensable Double
