-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Memoize Strings as Atoms for fast comparison and sorting, with maps and sets
--   
--   Memoize Strings as Atoms for fast comparison and sorting, with maps
--   and sets
@package stringtable-atom
@version 0.0.7

module StringTable.Atom
data Atom
class ToAtom a where toAtomIO a = return (toAtom a) toAtom a = unsafePerformIO (toAtomIO a)
toAtom :: ToAtom a => a -> Atom
toAtomIO :: ToAtom a => a -> IO Atom
class FromAtom a where fromAtomIO a = return (fromAtom a) fromAtom a = unsafePerformIO (fromAtomIO a)
fromAtom :: FromAtom a => Atom -> a
fromAtomIO :: FromAtom a => Atom -> IO a
class HasHash a
hash32 :: HasHash a => a -> Word32
intToAtom :: Monad m => Int -> m Atom
isValidAtom :: Int -> Bool
unsafeIntToAtom :: Int -> Atom
atomCompare :: Atom -> Atom -> Ordering
unsafeByteIndex :: Atom -> Int -> Word8
dumpTable :: IO ()
dumpToFile :: IO ()
dumpStringTableStats :: IO ()
instance Typeable Atom
instance Eq Atom
instance Ord Atom
instance Data Atom
instance Binary Atom
instance Read Atom
instance Show Atom
instance Monoid Atom
instance FromAtom ByteString
instance FromAtom Int
instance FromAtom Word
instance FromAtom CStringLen
instance ToAtom ByteString
instance FromAtom String
instance ToAtom String
instance ToAtom CString
instance ToAtom CStringLen
instance ToAtom Char
instance FromAtom Atom
instance ToAtom Atom
instance FromAtom (String -> String)
instance HasHash String
instance HasHash ByteString
instance HasHash Atom

module StringTable.AtomSet
newtype AtomSet
MkAtomSet :: IntSet -> AtomSet
fromAtomSet :: AtomSet -> IntSet
(\\) :: AtomSet -> AtomSet -> AtomSet
null :: AtomSet -> Bool
size :: AtomSet -> Atom
member :: Atom -> AtomSet -> Bool
notMember :: Atom -> AtomSet -> Bool
isSubsetOf :: AtomSet -> AtomSet -> Bool
isProperSubsetOf :: AtomSet -> AtomSet -> Bool
empty :: AtomSet
singleton :: Atom -> AtomSet
insert :: Atom -> AtomSet -> AtomSet
delete :: Atom -> AtomSet -> AtomSet
union :: AtomSet -> AtomSet -> AtomSet
unions :: [AtomSet] -> AtomSet
difference :: AtomSet -> AtomSet -> AtomSet
intersection :: AtomSet -> AtomSet -> AtomSet
filter :: (Atom -> Bool) -> AtomSet -> AtomSet
partition :: (Atom -> Bool) -> AtomSet -> (AtomSet, AtomSet)
split :: Atom -> AtomSet -> (AtomSet, AtomSet)
splitMember :: Atom -> AtomSet -> (AtomSet, Bool, AtomSet)
findMin :: AtomSet -> Atom
findMax :: AtomSet -> Atom
deleteMin :: AtomSet -> AtomSet
deleteMax :: AtomSet -> AtomSet
deleteFindMin :: AtomSet -> (Atom, AtomSet)
deleteFindMax :: AtomSet -> (Atom, AtomSet)
maxView :: Monad m => AtomSet -> m (Atom, AtomSet)
minView :: Monad m => AtomSet -> m (Atom, AtomSet)
map :: (Atom -> Atom) -> AtomSet -> AtomSet
fold :: (Atom -> b -> b) -> b -> AtomSet -> b
elems :: AtomSet -> [Atom]
toList :: AtomSet -> [Atom]
fromList :: [Atom] -> AtomSet
toAscList :: AtomSet -> [Atom]
fromAscList :: [Atom] -> AtomSet
fromDistinctAscList :: [Atom] -> AtomSet
showTree :: AtomSet -> String
showTreeWith :: Bool -> Bool -> AtomSet -> String
instance Eq AtomSet
instance Ord AtomSet

module StringTable.AtomMap
newtype AtomMap a
MkAtomMap :: IntMap a -> AtomMap a
fromAtomMap :: AtomMap a -> IntMap a
type Key = Atom
(!) :: AtomMap a -> Key -> a
(\\) :: AtomMap a -> AtomMap b -> AtomMap a

-- | Test whether a list is empty.
null :: [a] -> Bool
size :: AtomMap a -> Int
member :: Atom -> AtomMap a -> Bool
notMember :: Key -> AtomMap a -> Bool
lookup :: Atom -> AtomMap a -> Maybe a
findWithDefault :: a -> Key -> AtomMap a -> a
empty :: AtomMap a
singleton :: Key -> a -> AtomMap a
insert :: Atom -> a -> AtomMap a -> AtomMap a
insertWith :: (a -> a -> a) -> Atom -> a -> AtomMap a -> AtomMap a
insertWithKey :: (Key -> a -> a -> a) -> Key -> a -> AtomMap a -> AtomMap a
insertLookupWithKey :: (Key -> a -> a -> a) -> Key -> a -> AtomMap a -> (Maybe a, AtomMap a)
delete :: Key -> AtomMap a -> AtomMap a
adjust :: (a -> a) -> Key -> AtomMap a -> AtomMap a
adjustWithKey :: (Key -> a -> a) -> Key -> AtomMap a -> AtomMap a
update :: (a -> Maybe a) -> Key -> AtomMap a -> AtomMap a
updateWithKey :: (Key -> a -> Maybe a) -> Key -> AtomMap a -> AtomMap a
updateLookupWithKey :: (Key -> a -> Maybe a) -> Key -> AtomMap a -> (Maybe a, AtomMap a)
alter :: (Maybe a -> Maybe a) -> Key -> AtomMap a -> AtomMap a
union :: AtomMap a -> AtomMap a -> AtomMap a
unionWith :: (a -> a -> a) -> AtomMap a -> AtomMap a -> AtomMap a
unionWithKey :: (Key -> a -> a -> a) -> AtomMap a -> AtomMap a -> AtomMap a
unions :: [AtomMap a] -> AtomMap a
unionsWith :: (a -> a -> a) -> [AtomMap a] -> AtomMap a
difference :: AtomMap a -> AtomMap b -> AtomMap a
differenceWith :: (a -> b -> Maybe a) -> AtomMap a -> AtomMap b -> AtomMap a
differenceWithKey :: (Key -> a -> b -> Maybe a) -> AtomMap a -> AtomMap b -> AtomMap a
intersection :: AtomMap a -> AtomMap b -> AtomMap a
intersectionWith :: (a -> b -> a) -> AtomMap a -> AtomMap b -> AtomMap a
intersectionWithKey :: (Key -> a -> b -> a) -> AtomMap a -> AtomMap b -> AtomMap a
map :: (a -> b) -> AtomMap a -> AtomMap b
mapWithKey :: (Atom -> a -> b) -> AtomMap a -> AtomMap b
mapAccum :: (a -> b -> (a, c)) -> a -> AtomMap b -> (a, AtomMap c)
mapAccumWithKey :: (a -> Key -> b -> (a, c)) -> a -> AtomMap b -> (a, AtomMap c)
fold :: (a -> b -> b) -> b -> AtomMap a -> b
foldWithKey :: (Key -> a -> b -> b) -> b -> AtomMap a -> b
elems :: AtomMap a -> [a]
keys :: AtomMap a -> [Atom]
keysSet :: AtomMap a -> AtomSet
assocs :: AtomMap a -> [(Key, a)]
toList :: AtomMap a -> [(Atom, a)]
fromList :: [(Atom, a)] -> AtomMap a
fromListWith :: (a -> a -> a) -> [(Atom, a)] -> AtomMap a
fromListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> AtomMap a
toAscList :: AtomMap a -> [(Key, a)]
fromAscList :: [(Key, a)] -> AtomMap a
fromAscListWith :: (a -> a -> a) -> [(Key, a)] -> AtomMap a
fromAscListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> AtomMap a
fromDistinctAscList :: [(Key, a)] -> AtomMap a
filter :: (a -> Bool) -> AtomMap a -> AtomMap a
filterWithKey :: (Key -> a -> Bool) -> AtomMap a -> AtomMap a
partition :: (a -> Bool) -> AtomMap a -> (AtomMap a, AtomMap a)
partitionWithKey :: (Key -> a -> Bool) -> AtomMap a -> (AtomMap a, AtomMap a)
mapMaybe :: (a -> Maybe b) -> AtomMap a -> AtomMap b
mapMaybeWithKey :: (Atom -> a -> Maybe b) -> AtomMap a -> AtomMap b
mapEither :: (a -> Either b c) -> AtomMap a -> (AtomMap b, AtomMap c)
mapEitherWithKey :: (Key -> a -> Either b c) -> AtomMap a -> (AtomMap b, AtomMap c)
split :: Key -> AtomMap a -> (AtomMap a, AtomMap a)
splitLookup :: Key -> AtomMap a -> (AtomMap a, Maybe a, AtomMap a)
isSubmapOf :: Eq a => AtomMap a -> AtomMap a -> Bool
isSubmapOfBy :: (a -> b -> Bool) -> AtomMap a -> AtomMap b -> Bool
isProperSubmapOf :: Eq a => AtomMap a -> AtomMap a -> Bool
isProperSubmapOfBy :: (a -> b -> Bool) -> AtomMap a -> AtomMap b -> Bool
maxView :: Monad m => AtomMap a -> m (a, AtomMap a)
minView :: Monad m => AtomMap a -> m (a, AtomMap a)
deleteMin :: AtomMap a -> AtomMap a
deleteMax :: AtomMap a -> AtomMap a
deleteFindMin :: AtomMap a -> ((Key, a), AtomMap a)
deleteFindMax :: AtomMap a -> ((Key, a), AtomMap a)
updateMin :: (a -> Maybe a) -> AtomMap a -> AtomMap a
updateMax :: (a -> Maybe a) -> AtomMap a -> AtomMap a
updateMinWithKey :: (Key -> a -> Maybe a) -> AtomMap a -> AtomMap a
updateMaxWithKey :: (Key -> a -> Maybe a) -> AtomMap a -> AtomMap a
minViewWithKey :: Monad m => AtomMap a -> m ((Key, a), AtomMap a)
maxViewWithKey :: Monad m => AtomMap a -> m ((Key, a), AtomMap a)
showTree :: Show a => AtomMap a -> String
showTreeWith :: Show a => Bool -> Bool -> AtomMap a -> String
instance Eq a => Eq (AtomMap a)
instance Ord a => Ord (AtomMap a)
instance Functor AtomMap
instance Monoid (AtomMap a)
instance Show a => Show (AtomMap a)
