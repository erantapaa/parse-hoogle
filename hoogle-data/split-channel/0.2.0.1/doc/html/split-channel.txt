-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Control.Concurrent.Chan split into sending and receiving halves.
--   
--   This module splits Control.Concurrent.Chan into sending and receiving
--   halves, which allows the type system to more finely constrain program
--   behavior. As a secondary benefit, messages written to channels with no
--   receive ports associated with them can be reliably garbage collected.
--   
--   In addition, this module incorporates several of clean-ups and
--   additions to the venerable Chan. Most notably, the deprecated
--   thread-unsafe functions have been removed, the ability to
--   <tt>duplicate</tt> Receive Ports has been added, the <tt>sendMany</tt>
--   operation allows for multiple messages to be sent atomically, and the
--   <tt>split</tt> operation turns a single channel into two.
@package split-channel
@version 0.2.0.1


-- | This package provides an unbounded, imperative queue that is supposed
--   to be thread safe and asynchronous exception safe. It is essentially
--   the same communication mechanism as <a>Chan</a>, except that each
--   channel is split into separate sending and receiving ends, called
--   <a>SendPort</a> and <a>ReceivePort</a> respectively. This has at least
--   two advantages:
--   
--   <ol>
--   <li>Program behavior can be more finely constrained via the type
--   system.</li>
--   <li>Channels can have zero <tt>ReceivePorts</tt> associated with them.
--   Messages written to such a channel disappear into the aether and can
--   be garbage collected. Note that <tt>ReceivePorts</tt> can be
--   subsequently attached to such a channel via <a>listen</a>, and can be
--   detached via garbage collection.</li>
--   </ol>
--   
--   By contrast, <a>Chan</a> couples a <tt>SendPort</tt> and a
--   <tt>ReceivePort</tt> together in a pair. Thus keeping a reference to a
--   <tt>SendPort</tt> implies that there is at least one reference to a
--   <tt>ReceivePort</tt>, which means that messages cannot be garbage
--   collected from an active channel if nobody is listening.
--   
--   A channel can have multiple <tt>ReceivePorts</tt>. This results in a
--   publish- subscribe pattern of communication: every message will be
--   delivered to every port. Alternatively, multiple threads can read from
--   a single port. This results in a push-pull pattern of communication,
--   similar to ZeroMQ: every message will be delivered to exactly one
--   thread. Of course both can be used together to form hybrid patterns of
--   communication.
--   
--   A channel can only have one <tt>SendPort</tt>. However multiple
--   threads can can safely write to a single port, allowing effects
--   similar to multiple <tt>SendPorts</tt>.
--   
--   Some of the tradeoffs of <tt>split-channel</tt> compared to Cloud
--   Haskell's <tt>Remote.Channel</tt> are:
--   
--   <ol>
--   <li><tt>split-channel</tt> is restricted to in-process communications
--   only.</li>
--   <li><tt>split-channel</tt> has no restriction on the type of values
--   that may be communicated.</li>
--   <li>There is a quasi-duality between the two approaches: Cloud
--   Haskell's <tt>ReceivePorts</tt> are special whereas
--   <tt>split-channel</tt>'s <tt>SendPorts</tt> are special.</li>
--   <li><tt>ReceivePorts</tt> can be <tt><a>duplicate</a>d</tt>, which
--   allows for considerably more efficient publish-subscribe
--   communications than supported by Cloud Haskell at the present
--   time.</li>
--   </ol>
module Control.Concurrent.Chan.Split

-- | <tt>SendPorts</tt> represent one end of the channel. There is only one
--   <tt>SendPort</tt> per channel, though it can be used from multiple
--   threads. Messages can be sent to the channel using <a>send</a>.
data SendPort a

-- | <tt>ReceivePorts</tt> represent the other end of a channel. A channel
--   can have many <tt>ReceivePorts</tt>, which all receive the same
--   messages in a publish/subscribe like manner. A single
--   <tt>ReceivePort</tt> can be used from multiple threads, where every
--   message will be delivered to a single thread in a push/pull like
--   manner. Use <a>receive</a> to fetch messages from the channel.
data ReceivePort a

-- | Creates a new channel and a <tt>(SendPort, ReceivePort)</tt> pair
--   representing the two sides of the channel.
new :: IO (SendPort a, ReceivePort a)

-- | Produces a new channel that initially has zero <tt>ReceivePorts</tt>.
--   Any messages written to this channel before a reader is
--   <tt><a>listen</a>ing</tt> will be eligible for garbage collection.
--   Note that one can one can implement <a>newSendPort</a> in terms of
--   <a>new</a> by throwing away the <a>ReceivePort</a> and letting it be
--   garbage collected, and that one can implement <a>new</a> in terms of
--   <a>newSendPort</a> and <a>listen</a>.
newSendPort :: IO (SendPort a)

-- | Send a message to a channel. This is asynchronous and does not block.
send :: SendPort a -> a -> IO ()

-- | Fetch a message from a channel. If no message is available, it blocks
--   until one is. Can be used in conjunction with <tt>System.Timeout</tt>.
receive :: ReceivePort a -> IO a

-- | Atomically send many messages at once. Note that this function forces
--   the spine of the list beforehand to minimize the critical section,
--   which also helps prevent exceptions at inopportune times. Trying to
--   send an infinite list will never send anything, though it will
--   allocate and retain a lot of memory trying to do so.
sendMany :: SendPort a -> [a] -> IO ()

-- | Create a new <tt>ReceivePort</tt> attached the same channel as a given
--   <tt>SendPort</tt>. This <tt>ReceivePort</tt> starts out empty, and
--   remains so until more messages are written to the <tt>SendPort</tt>.
listen :: SendPort a -> IO (ReceivePort a)

-- | Create a new <tt>ReceivePort</tt> attached to the same channel as
--   another <tt>ReceivePort</tt>. These two ports will receive the same
--   messages. Any messages in the channel that have not been consumed by
--   the existing port will also appear in the new port.
duplicate :: ReceivePort a -> IO (ReceivePort a)

-- | This function splits an existing channel in two; associating a new
--   receive port with the old send port, and a new send port with the
--   existing receive ports. The new receive port starts out empty, while
--   the existing receive ports retain any unprocessed messages.
--   
split :: SendPort a -> IO (ReceivePort a, SendPort a)

-- | A right fold over a receiver. <tt>fold (:)</tt> is quite similar to
--   <tt>getChanContents</tt>. The one difference is that that
--   <tt>fold</tt> does not produce any observable side-effects on the
--   <tt>ReceivePort</tt>; unlike <tt>getChanContents</tt> any messages
--   observed by <tt>fold</tt> are not removed from the port.
--   
--   Note that the type of <a>fold</a> implies that the folding function
--   needs to be sufficiently non-strict, otherwise the result cannot be
--   productive.
fold :: (a -> b -> b) -> ReceivePort a -> IO b
