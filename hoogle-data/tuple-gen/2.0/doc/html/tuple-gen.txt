-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Enum instances for tuples where the digits increase with the same speed
--   
--   Generating tuples like this: [(x, y) | x &lt;- [1..], y &lt;- [1..]]
--   generates tuples that change only in the second position.
--   
--   This library uses increasingly bigger hyperplanes to generate tuples.
--   
--   It uses the Enum instances that are also used in the Prelude.
--   
--   Thereby tuples with arbitrary starting values and types can be
--   enumerated.
--   
--   Example: ( enumFrom (0,(1,2),3) ) :: [(Word8,(Word8,Word8),Word8)]
--   
--   evaluates to [(0,(1,2),3), (0,(2,1),4), (0,(3,0),5), ...].
--   
--   Further explanations are planned to appear in the Monad Reader issue
--   20.
@package tuple-gen
@version 2.0

module Data.Tuple.Enum

-- | generate all 2-tuples (of enumerable values) so that the sum of the 2
--   fromEnum-values is monotonic increasing fromEnum :: a -&gt; Int
all2s :: (Enum a, Enum b, Eq a, Eq b, Bounded a, Bounded b) => [(a, b)]

-- | generate all 3-tuples (of enumerable values) so that the sum of the 3
--   fromEnum-values is monotonic increasing fromEnum :: a -&gt; Int
all3s :: (Enum a, Enum b, Enum c, Eq a, Eq b, Eq c, Bounded a, Bounded b, Bounded c) => [(a, b, c)]

-- | generate all 4-tuples (of enumerable values) so that the sum of the 4
--   fromEnum-values is monotonic increasing fromEnum :: a -&gt; Int
all4s :: (Enum a, Enum b, Enum c, Enum d, Eq a, Eq b, Eq c, Eq d, Bounded a, Bounded b, Bounded c, Bounded d) => [(a, b, c, d)]

-- | generate all 5-tuples (of enumerable values) so that the sum of the 5
--   fromEnum-values is monotonic increasing fromEnum :: a -&gt; Int
all5s :: (Enum a, Enum b, Enum c, Enum d, Enum e, Eq a, Eq b, Eq c, Eq d, Eq e, Bounded a, Bounded b, Bounded c, Bounded d, Bounded e) => [(a, b, c, d, e)]

-- | generate all 6-tuples (of enumerable values) so that the sum of the 6
--   fromEnum-values is monotonic increasing fromEnum :: a -&gt; Int
all6s :: (Enum a, Enum b, Enum c, Enum d, Enum e, Enum f, Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f) => [(a, b, c, d, e, f)]

-- | generate all 7-tuples (of enumerable values) so that the sum of the 7
--   fromEnum-values is monotonic increasing fromEnum :: a -&gt; Int
all7s :: (Enum a, Enum b, Enum c, Enum d, Enum e, Enum f, Enum g, Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g) => [(a, b, c, d, e, f, g)]

-- | generate all 8-tuples (of enumerable values) so that the sum of the 8
--   fromEnum-values is monotonic increasing fromEnum :: a -&gt; Int
all8s :: (Enum a, Enum b, Enum c, Enum d, Enum e, Enum f, Enum g, Enum h, Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g, Bounded h) => [(a, b, c, d, e, f, g, h)]

-- | generate all 9-tuples (of enumerable values) so that the sum of the 9
--   fromEnum-values is monotonic increasing fromEnum :: a -&gt; Int
all9s :: (Enum a, Enum b, Enum c, Enum d, Enum e, Enum f, Enum g, Enum h, Enum i, Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g, Bounded h, Bounded i) => [(a, b, c, d, e, f, g, h, i)]

-- | generate all 10-tuples (of enumerable values) so that the sum of the
--   10 fromEnum-values is monotonic increasing fromEnum :: a -&gt; Int
all10s :: (Enum a, Enum b, Enum c, Enum d, Enum e, Enum f, Enum g, Enum h, Enum i, Enum j, Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g, Bounded h, Bounded i, Bounded j) => [(a, b, c, d, e, f, g, h, i, j)]

-- | generate all 11-tuples (of enumerable values) so that the sum of the
--   11 fromEnum-values is monotonic increasing fromEnum :: a -&gt; Int
all11s :: (Enum a, Enum b, Enum c, Enum d, Enum e, Enum f, Enum g, Enum h, Enum i, Enum j, Enum k, Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k, Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g, Bounded h, Bounded i, Bounded j, Bounded k) => [(a, b, c, d, e, f, g, h, i, j, k)]

-- | generate all 12-tuples (of enumerable values) so that the sum of the
--   12 fromEnum-values is monotonic increasing fromEnum :: a -&gt; Int
all12s :: (Enum a, Enum b, Enum c, Enum d, Enum e, Enum f, Enum g, Enum h, Enum i, Enum j, Enum k, Enum l, Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k, Eq l, Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g, Bounded h, Bounded i, Bounded j, Bounded k, Bounded l) => [(a, b, c, d, e, f, g, h, i, j, k, l)]

-- | generate all 13-tuples (of enumerable values) so that the sum of the
--   13 fromEnum-values is monotonic increasing fromEnum :: a -&gt; Int
all13s :: (Enum a, Enum b, Enum c, Enum d, Enum e, Enum f, Enum g, Enum h, Enum i, Enum j, Enum k, Enum l, Enum m, Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k, Eq l, Eq m, Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g, Bounded h, Bounded i, Bounded j, Bounded k, Bounded l, Bounded m) => [(a, b, c, d, e, f, g, h, i, j, k, l, m)]

-- | generate all 14-tuples (of enumerable values) so that the sum of the
--   14 fromEnum-values is monotonic increasing fromEnum :: a -&gt; Int
all14s :: (Enum a, Enum b, Enum c, Enum d, Enum e, Enum f, Enum g, Enum h, Enum i, Enum j, Enum k, Enum l, Enum m, Enum n, Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k, Eq l, Eq m, Eq n, Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g, Bounded h, Bounded i, Bounded j, Bounded k, Bounded l, Bounded m, Bounded n) => [(a, b, c, d, e, f, g, h, i, j, k, l, m, n)]

-- | generate all 15-tuples (of enumerable values) so that the sum of the
--   15 fromEnum-values is monotonic increasing fromEnum :: a -&gt; Int
all15s :: (Enum a, Enum b, Enum c, Enum d, Enum e, Enum f, Enum g, Enum h, Enum i, Enum j, Enum k, Enum l, Enum m, Enum n, Enum o, Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k, Eq l, Eq m, Eq n, Eq o, Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g, Bounded h, Bounded i, Bounded j, Bounded k, Bounded l, Bounded m, Bounded n, Bounded o) => [(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)]
hyperplaneSize :: Int -> Int -> Int
fe :: [Int] -> Int
te :: Int -> Int -> [Int]
to2Tuple :: (J t, J t1) -> (t, t1)
to3Tuple :: ((J t, J t1), J t2) -> (t, t1, t2)
to4Tuple :: (((J t, J t1), J t2), J t3) -> (t, t1, t2, t3)
to5Tuple :: ((((J t, J t1), J t2), J t3), J t4) -> (t, t1, t2, t3, t4)
to6Tuple :: (((((J t, J t1), J t2), J t3), J t4), J t5) -> (t, t1, t2, t3, t4, t5)
to7Tuple :: ((((((J t, J t1), J t2), J t3), J t4), J t5), J t6) -> (t, t1, t2, t3, t4, t5, t6)
to8Tuple :: (((((((J t, J t1), J t2), J t3), J t4), J t5), J t6), J t7) -> (t, t1, t2, t3, t4, t5, t6, t7)
to9Tuple :: ((((((((J t, J t1), J t2), J t3), J t4), J t5), J t6), J t7), J t8) -> (t, t1, t2, t3, t4, t5, t6, t7, t8)
to10Tuple :: (((((((((J t, J t1), J t2), J t3), J t4), J t5), J t6), J t7), J t8), J t9) -> (t, t1, t2, t3, t4, t5, t6, t7, t8, t9)
to11Tuple :: ((((((((((J t, J t1), J t2), J t3), J t4), J t5), J t6), J t7), J t8), J t9), J t10) -> (t, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10)
to12Tuple :: (((((((((((J t, J t1), J t2), J t3), J t4), J t5), J t6), J t7), J t8), J t9), J t10), J t11) -> (t, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11)
to13Tuple :: ((((((((((((J t, J t1), J t2), J t3), J t4), J t5), J t6), J t7), J t8), J t9), J t10), J t11), J t12) -> (t, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12)
to14Tuple :: (((((((((((((J t, J t1), J t2), J t3), J t4), J t5), J t6), J t7), J t8), J t9), J t10), J t11), J t12), J t13) -> (t, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13)
to15Tuple :: ((((((((((((((J t, J t1), J t2), J t3), J t4), J t5), J t6), J t7), J t8), J t9), J t10), J t11), J t12), J t13), J t14) -> (t, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14)
from2Tuple :: (a, a1) -> (J a, J a1)
from3Tuple :: (a, a1, a2) -> ((J a, J a1), J a2)
from4Tuple :: (a, a1, a2, a3) -> (((J a, J a1), J a2), J a3)
from5Tuple :: (a, a1, a2, a3, a4) -> ((((J a, J a1), J a2), J a3), J a4)
from6Tuple :: (a, a1, a2, a3, a4, a5) -> (((((J a, J a1), J a2), J a3), J a4), J a5)
from7Tuple :: (a, a1, a2, a3, a4, a5, a6) -> ((((((J a, J a1), J a2), J a3), J a4), J a5), J a6)
from8Tuple :: (a, a1, a2, a3, a4, a5, a6, a7) -> (((((((J a, J a1), J a2), J a3), J a4), J a5), J a6), J a7)
from9Tuple :: (a, a1, a2, a3, a4, a5, a6, a7, a8) -> ((((((((J a, J a1), J a2), J a3), J a4), J a5), J a6), J a7), J a8)
from10Tuple :: (a, a1, a2, a3, a4, a5, a6, a7, a8, a9) -> (((((((((J a, J a1), J a2), J a3), J a4), J a5), J a6), J a7), J a8), J a9)
from11Tuple :: (a, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) -> ((((((((((J a, J a1), J a2), J a3), J a4), J a5), J a6), J a7), J a8), J a9), J a10)
from12Tuple :: (a, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) -> (((((((((((J a, J a1), J a2), J a3), J a4), J a5), J a6), J a7), J a8), J a9), J a10), J a11)
from13Tuple :: (a, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) -> ((((((((((((J a, J a1), J a2), J a3), J a4), J a5), J a6), J a7), J a8), J a9), J a10), J a11), J a12)
from14Tuple :: (a, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) -> (((((((((((((J a, J a1), J a2), J a3), J a4), J a5), J a6), J a7), J a8), J a9), J a10), J a11), J a12), J a13)
from15Tuple :: (a, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) -> ((((((((((((((J a, J a1), J a2), J a3), J a4), J a5), J a6), J a7), J a8), J a9), J a10), J a11), J a12), J a13), J a14)

-- | Class <a>Enum</a> defines operations on sequentially ordered types.
--   
--   The <tt>enumFrom</tt>... methods are used in Haskell's translation of
--   arithmetic sequences.
--   
--   Instances of <a>Enum</a> may be derived for any enumeration type
--   (types whose constructors have no fields). The nullary constructors
--   are assumed to be numbered left-to-right by <a>fromEnum</a> from
--   <tt>0</tt> through <tt>n-1</tt>. See Chapter 10 of the <i>Haskell
--   Report</i> for more details.
--   
--   For any type that is an instance of class <a>Bounded</a> as well as
--   <a>Enum</a>, the following should hold:
--   
--   <ul>
--   <li>The calls <tt><a>succ</a> <a>maxBound</a></tt> and <tt><a>pred</a>
--   <a>minBound</a></tt> should result in a runtime error.</li>
--   <li><a>fromEnum</a> and <a>toEnum</a> should give a runtime error if
--   the result value is not representable in the result type. For example,
--   <tt><a>toEnum</a> 7 :: <a>Bool</a></tt> is an error.</li>
--   <li><a>enumFrom</a> and <a>enumFromThen</a> should be defined with an
--   implicit bound, thus:</li>
--   </ul>
--   
--   <pre>
--   enumFrom     x   = enumFromTo     x maxBound
--   enumFromThen x y = enumFromThenTo x y bound
--     where
--       bound | fromEnum y &gt;= fromEnum x = maxBound
--             | otherwise                = minBound
--   </pre>
class Enum a
succ :: Enum a => a -> a
pred :: Enum a => a -> a
toEnum :: Enum a => Int -> a
fromEnum :: Enum a => a -> Int
enumFrom :: Enum a => a -> [a]
enumFromThen :: Enum a => a -> a -> [a]
enumFromTo :: Enum a => a -> a -> [a]
enumFromThenTo :: Enum a => a -> a -> a -> [a]
instance (Enum a, Enum b, Enum c, Enum d, Enum e, Enum f, Enum g, Enum h, Enum i, Enum j, Enum k, Enum l, Enum m, Enum n, Enum o, Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k, Eq l, Eq m, Eq n, Eq o, Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g, Bounded h, Bounded i, Bounded j, Bounded k, Bounded l, Bounded m, Bounded n, Bounded o) => Enum (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance (Enum a, Enum b, Enum c, Enum d, Enum e, Enum f, Enum g, Enum h, Enum i, Enum j, Enum k, Enum l, Enum m, Enum n, Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k, Eq l, Eq m, Eq n, Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g, Bounded h, Bounded i, Bounded j, Bounded k, Bounded l, Bounded m, Bounded n) => Enum (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance (Enum a, Enum b, Enum c, Enum d, Enum e, Enum f, Enum g, Enum h, Enum i, Enum j, Enum k, Enum l, Enum m, Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k, Eq l, Eq m, Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g, Bounded h, Bounded i, Bounded j, Bounded k, Bounded l, Bounded m) => Enum (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance (Enum a, Enum b, Enum c, Enum d, Enum e, Enum f, Enum g, Enum h, Enum i, Enum j, Enum k, Enum l, Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k, Eq l, Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g, Bounded h, Bounded i, Bounded j, Bounded k, Bounded l) => Enum (a, b, c, d, e, f, g, h, i, j, k, l)
instance (Enum a, Enum b, Enum c, Enum d, Enum e, Enum f, Enum g, Enum h, Enum i, Enum j, Enum k, Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k, Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g, Bounded h, Bounded i, Bounded j, Bounded k) => Enum (a, b, c, d, e, f, g, h, i, j, k)
instance (Enum a, Enum b, Enum c, Enum d, Enum e, Enum f, Enum g, Enum h, Enum i, Enum j, Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g, Bounded h, Bounded i, Bounded j) => Enum (a, b, c, d, e, f, g, h, i, j)
instance (Enum a, Enum b, Enum c, Enum d, Enum e, Enum f, Enum g, Enum h, Enum i, Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g, Bounded h, Bounded i) => Enum (a, b, c, d, e, f, g, h, i)
instance (Enum a, Enum b, Enum c, Enum d, Enum e, Enum f, Enum g, Enum h, Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g, Bounded h) => Enum (a, b, c, d, e, f, g, h)
instance (Enum a, Enum b, Enum c, Enum d, Enum e, Enum f, Enum g, Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g) => Enum (a, b, c, d, e, f, g)
instance (Enum a, Enum b, Enum c, Enum d, Enum e, Enum f, Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f) => Enum (a, b, c, d, e, f)
instance (Enum a, Enum b, Enum c, Enum d, Enum e, Eq a, Eq b, Eq c, Eq d, Eq e, Bounded a, Bounded b, Bounded c, Bounded d, Bounded e) => Enum (a, b, c, d, e)
instance (Enum a, Enum b, Enum c, Enum d, Eq a, Eq b, Eq c, Eq d, Bounded a, Bounded b, Bounded c, Bounded d) => Enum (a, b, c, d)
instance (Enum a, Enum b, Enum c, Eq a, Eq b, Eq c, Bounded a, Bounded b, Bounded c) => Enum (a, b, c)
instance (Enum a, Enum b, Eq a, Eq b, Bounded a, Bounded b) => Enum (a, b)
instance Show a => Show (J a)
