-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Asymptotically optimal, Coq-verified meldable heaps, AKA priority queues
--   
--   A heap is a container supporting the insertion of elements and the
--   extraction of the minimum element. This library additionally supports
--   melding two heaps. This library models the implementation of
--   asymptotically optimal purely functional heaps given by Brodal and
--   Okasaki in their paper "Optimal Purely Functional Priority Queues". It
--   has been proved correct using the Coq proof assistant. The proofs are
--   included in the Cabal package.
--   
--   A description of the differences between versions of this package is
--   available at
--   <a>http://priority-queues.googlecode.com/hg/brodal-okasaki/cabal/CHANGELOG</a>.
@package meldable-heap
@version 2.0.3


-- | A heap is a container supporting the insertion of elements and the
--   extraction of the minimum element. This library models the
--   implementation of asymptotically optimal purely functional heaps given
--   by Brodal and Okasaki in their paper "Optimal Purely Functional
--   Priority Queues". The Coq proof assistant has been used to prove this
--   implementation correct. The proofs are available in the Cabal package
--   or at <a>http://code.google.com/p/priority-queues/</a>.
--   
--   This implementation is strict. A lazy implementation is available in
--   this package as <a>Data.MeldableHeap.Lazy</a>.
module Data.MeldableHeap.Strict
type PQ = BootWrap Integer

-- | <a>empty</a> is the heap with no elements
empty :: Ord a => PQ a

-- | <a>toList</a> (O(n)) returns a list of the elements in the heap in
--   some arbitrary order.
--   
--   <pre>
--   [] == toList empty
--   </pre>
toList :: Ord a => PQ a -> [a]

-- | <a>insert</a> (O(1)) adds an element to a heap.
--   
--   <pre>
--   [1,2,1,0] == toList $ insert 1 $ insert 0 $ insert 2 $ insert 1 $ empty
--   </pre>
insert :: Ord a => a -> PQ a -> PQ a

-- | <a>findMin</a> (O(1)) returns the minimum element of a nonempty heap.
--   
--   <pre>
--   Just 0 == findMin $ insert 0 $ insert 2 $ insert 1 $ empty
--   </pre>
findMin :: Ord a => PQ a -> Maybe a

-- | <a>extractMin</a> (O(lg n)) returns (if the heap is nonempty) a pair
--   containing the minimum element and a heap that contains all of the
--   other elements. It does not remove copies of the minimum element if
--   some exist in the heap.
--   
--   <pre>
--   (0,[2,1]) == let x = insert 0 $ insert 2 $ insert 1 $ empty in let Just (p,q) = extractMin x in (p,toList q)
--   </pre>
extractMin :: Ord a => PQ a -> Maybe (a, PQ a)

-- | <a>meld</a> (O(1)) joins two heaps P and Q into a heap containing
--   exactly the elements in P and Q. It does not remove duplicates.
--   
--   <pre>
--   [2,1,0,2,1,0] == let x = insert 0 $ insert 2 $ insert 1 $ empty in toList (meld x x)
--   </pre>
meld :: Ord a => PQ a -> PQ a -> PQ a


-- | A heap is a container supporting the insertion of elements and the
--   extraction of the minimum element. This library models the
--   implementation of asymptotically optimal purely functional heaps given
--   by Brodal and Okasaki in their paper "Optimal Purely Functional
--   Priority Queues". The Coq proof assistant has been used to prove this
--   implementation correct. The proofs are available in the Cabal package
--   or at <a>http://code.google.com/p/priority-queues/</a>.
--   
--   This implementation is lazy. A strict implementation is available in
--   this package as <a>Data.MeldableHeap.Strict</a>.
module Data.MeldableHeap.Lazy
type PQ = BootWrap Integer

-- | <a>empty</a> is the heap with no elements
empty :: Ord a => PQ a

-- | <a>toList</a> (O(n)) returns a list of the elements in the heap in
--   some arbitrary order.
--   
--   <pre>
--   [] == toList empty
--   </pre>
toList :: Ord a => PQ a -> [a]

-- | <a>insert</a> (O(1)) adds an element to a heap.
--   
--   <pre>
--   [1,2,1,0] == toList $ insert 1 $ insert 0 $ insert 2 $ insert 1 $ empty
--   </pre>
insert :: Ord a => a -> PQ a -> PQ a

-- | <a>findMin</a> (O(1)) returns the minimum element of a nonempty heap.
--   
--   <pre>
--   Just 0 == findMin $ insert 0 $ insert 2 $ insert 1 $ empty
--   </pre>
findMin :: Ord a => PQ a -> Maybe a

-- | <a>extractMin</a> (O(lg n)) returns (if the heap is nonempty) a pair
--   containing the minimum element and a heap that contains all of the
--   other elements. It does not remove copies of the minimum element if
--   some exist in the heap.
--   
--   <pre>
--   (0,[2,1]) == let x = insert 0 $ insert 2 $ insert 1 $ empty in let Just (p,q) = extractMin x in (p,toList q)
--   </pre>
extractMin :: Ord a => PQ a -> Maybe (a, PQ a)

-- | <a>meld</a> (O(1)) joins two heaps P and Q into a heap containing
--   exactly the elements in P and Q. It does not remove duplicates.
--   
--   <pre>
--   [2,1,0,2,1,0] == let x = insert 0 $ insert 2 $ insert 1 $ empty in toList (meld x x)
--   </pre>
meld :: Ord a => PQ a -> PQ a -> PQ a


-- | A heap is a container supporting the insertion of elements and the
--   extraction of the minimum element. This library models the
--   implementation of asymptotically optimal purely functional heaps given
--   by Brodal and Okasaki in their paper "Optimal Purely Functional
--   Priority Queues". The Coq proof assistant has been used to prove this
--   implementation correct. The proofs are available in the Cabal package
--   or at <a>http://code.google.com/p/priority-queues/</a>.
--   
--   The default implementation is lazy. A strict implementation is
--   available in this package as <a>Data.MeldableHeap.Strict</a>. The lazy
--   implementation is available in this module (<a>Data.MeldableHeap</a>)
--   or in <a>Data.MeldableHeap.Lazy</a>.
module Data.MeldableHeap
type PQ = PQ

-- | <a>empty</a> is the heap with no elements
empty :: Ord a => PQ a

-- | <a>toList</a> (O(n)) returns a list of the elements in the heap in
--   some arbitrary order.
--   
--   <pre>
--   [] == toList empty
--   </pre>
toList :: Ord a => PQ a -> [a]

-- | <a>insert</a> (O(1)) adds an element to a heap.
--   
--   <pre>
--   [1,2,1,0] == toList $ insert 1 $ insert 0 $ insert 2 $ insert 1 $ empty
--   </pre>
insert :: Ord a => a -> PQ a -> PQ a

-- | <a>findMin</a> (O(1)) returns the minimum element of a nonempty heap.
--   
--   <pre>
--   Just 0 == findMin $ insert 0 $ insert 2 $ insert 1 $ empty
--   </pre>
findMin :: Ord a => PQ a -> Maybe a

-- | <a>extractMin</a> (O(lg n)) returns (if the heap is nonempty) a pair
--   containing the minimum element and a heap that contains all of the
--   other elements. It does not remove copies of the minimum element if
--   some exist in the heap.
--   
--   <pre>
--   (0,[2,1]) == let x = insert 0 $ insert 2 $ insert 1 $ empty in let Just (p,q) = extractMin x in (p,toList q)
--   </pre>
extractMin :: Ord a => PQ a -> Maybe (a, PQ a)

-- | <a>meld</a> (O(1)) joins two heaps P and Q into a heap containing
--   exactly the elements in P and Q. It does not remove duplicates.
--   
--   <pre>
--   [2,1,0,2,1,0] == let x = insert 0 $ insert 2 $ insert 1 $ empty in toList (meld x x)
--   </pre>
meld :: Ord a => PQ a -> PQ a -> PQ a
