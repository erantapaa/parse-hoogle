-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Visualization of computation decomposition trees.
--   
--   This Haskell package provides some tools for visualizing the
--   decomposition of different divide and conquer algorithms.
@package treeviz
@version 1.0.0


module Data.Newtypes.PrettyDouble

-- | A custom double precision floating point type, which overides the
--   <a>Show</a> and <a>Eq</a> instances, in order to:
--   
--   <ul>
--   <li>Limit precision to 3 places after the decimal.</li>
--   <li>Print ridiculously small numbers as simply zero.</li>
--   <li>Define equality as difference being less than some threshold.</li>
--   </ul>
newtype PrettyDouble
PrettyDouble :: Double -> PrettyDouble
uglyDouble :: PrettyDouble -> Double
instance Num PrettyDouble
instance Ord PrettyDouble
instance Fractional PrettyDouble
instance Floating PrettyDouble
instance Real PrettyDouble
instance RealFrac PrettyDouble
instance RealFloat PrettyDouble
instance Eq PrettyDouble
instance Show PrettyDouble


-- | Typical usage (a 4-point FFT, using 2 radix-2, DIT stages):
--   
--   <pre>
--   -- Main
--   exeMain = do
--       let tData = newTreeData [(2, False), (2, False)] [1.0, 0.0, 0.0, 0.0]
--       let tree  = buildTree newFFTTree tData
--       case tree of
--         Left msg -&gt; putStrLn msg
--         Right  _ -&gt; do
--           -- If you're interested in the numerical result:
--           let res = getEval tree
--           putStrLn $ <a>Result = tt</a> ++ show res
--           -- If you want to visualize how the computation breaks down:
--           let (treePlot, legendPlot) = dotLogTree tree
--           writeFile treeFileName   treePlot
--           writeFile legendFileName legendPlot
--   </pre>
--   
--   And, to get easily viewable *.PNGs from the two files written, above:
--   
--   <pre>
--   &gt;&gt;&gt; dot &lt;treeFileName&gt; -Tpng &gt;tree.png
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; dot &lt;legendFileName&gt; -Tpng &gt;legend.png
--   </pre>
module Data.Tree.LogTree

-- | A class of tree structures representing logarithmic decomposition of
--   arbitrary radix and using either decimation-in-time (DIT), or
--   decimation-in-frequency (DIF) approach (or, a mix of both).
class (Show a, t ~ GenericLogTree a) => LogTree t a | t -> a where getTwiddleStrs = map (map show) . getTwiddles
evalNode :: LogTree t a => (t, [Int]) -> [a]
getTwiddles :: LogTree t a => t -> [[a]]
calcTwiddles :: LogTree t a => DecimationType -> Int -> Int -> [[a]]
getTwiddleStrs :: LogTree t a => t -> [[String]]
getCompNodes :: LogTree t a => t -> [CompNode a]

-- | A convenient type synonym, used as shorthand to specify the actual
--   Tree type.
--   
--   <a>a</a> is the data type of the original input list elements.
--   
--   Tree type tuple, from left to right:
--   
--   <ul>
--   <li>Maybe (a, [[a]]) = original list element value, for leaf; Nothing,
--   otherwise. The list of lists contains the accumulated twiddles.</li>
--   <li>[Int] = starting indeces, in original input list, of children</li>
--   <li>Int = index skip factor, in original input list, of children</li>
--   <li>Bool = True, if decimation in frequency (DIF) was used to form
--   children.</li>
--   </ul>
--   
--   Notes:
--   
--   <ul>
--   <li>The radix of the decomposition at any level of a tree is equal to
--   the number of children at that node (i.e. - length subForest), which
--   should also equal the length of the second element in the Tree type
--   tuple.</li>
--   </ul>
type GenericLogTree a = Tree (Maybe (a, [[a]]), [Int], Int, DecimationType)

-- | Data structure used by tree builders.
--   
--   Fields:
--   
--   <ul>
--   <li><i><tt>modes</tt></i> A list of <a>DecompositionMode</a>s</li>
--   <li><i><tt>values</tt></i> The list of values to be transformed.</li>
--   </ul>
data TreeData a

-- | Example: tree = buildTree newFFTTree tData
--   
--   Note:
--   
--   Please, don't use the <a>TreeBuilder</a> data constructor directly, in
--   your client code, unless you are defining a new instance of typeclass
--   <a>LogTree</a>. You will short circuit our data abstraction strategy,
--   if you do this. This will expose your client code to potential
--   breakage, in the future. (See the FFTTree.hs file for an example of
--   how to create a new instance of typeclass, LogTree.)
newtype TreeBuilder t
TreeBuilder :: (forall a. LogTree t a => TreeData a -> Either String t) -> TreeBuilder t
buildTree :: TreeBuilder t -> forall a. LogTree t a => TreeData a -> Either String t

-- | Enumerates the possible computational operations performed by a
--   computational node.
data CompOp

-- | Node sums its inputs.
Sum :: CompOp

-- | Node multiplies its inputs.
Prod :: CompOp

-- | Our computational node type; tuple members are:
--   
--   <ul>
--   <li>type of operation (i.e. - CompOp)</li>
--   <li>list of multiplicative coefficients (type a) to be applied to the
--   inputs</li>
--   </ul>
type CompNodeOutput a = (CompOp, [a])

-- | Completely defines a particular computational node, by specifying all
--   of its outputs.
--   
--   Each tuple in the list corresponds to a unique element of the output
--   list.
type CompNode a = [CompNodeOutput a]

-- | Enumerates the possible decimation styles of a computation breakdown
--   stage.
data DecimationType

-- | Decimation in Time.
DIT :: DecimationType

-- | Decimation in Frequency.
DIF :: DecimationType

-- | A convenient type alias to help make the code more readable.
type Radix = Int

-- | A convenient type alias.
--   
--   Each stage of a computation breakdown can be uniquely identified by a
--   pair containing:
--   
--   <ul>
--   <li><i>Radix</i> Typically, an integer defining the number of
--   sub-computations being combined in this stage.</li>
--   <li><i>DecimationType</i> A flag giving the decimation style used in
--   forming the list of elements in the sub-computations.</li>
--   </ul>
type DecompositionMode = (Radix, DecimationType)

-- | Build a data structure suitable for passing to a tree constructor.
--   
--   Example: tData = newTreeData [(2, DIT), (2, DIT)] [1.0, 0.0, 0.0, 0.0]
newTreeData :: [DecompositionMode] -> [a] -> TreeData a

-- | NOT FOR USE BY GENERAL CLIENT CODE!
--   
--   This has been exported, solely for use by definers of new instances of
--   typeclass, LogTree. (See the FFTTree.hs file, for an example of how to
--   do this.)
buildMixedRadixTree :: LogTree t a => TreeData a -> Either String t
instance Eq CompOp
instance Eq DecimationType
instance Show DecimationType
instance Show a => Show (TreeData a)


module Data.Tree.LogTreeUtil

-- | Converts a GenericLogTree to a GraphViz dot diagram.
dotLogTree :: (Show a, Eq a, Num a, LogTree t a) => Either String t -> (String, String)

-- | These helper functions just unwrap the <a>Either</a> from arround a
--   <a>LogTree</a>, so that the equivalent functions from <a>Tree</a> can
--   be used.
getLevels :: Either t (Tree a) -> [[a]]

-- | These helper functions just unwrap the <a>Either</a> from arround a
--   <a>LogTree</a>, so that the equivalent functions from <a>Tree</a> can
--   be used.
getFlatten :: Either t (Tree a) -> [a]

-- | Helper function to evaluate a node.
getEval :: LogTree (GenericLogTree a) a => Either t (GenericLogTree a) -> [a]


module Data.Tree.LogTrees.FFTTree

-- | An instance of LogTree, this type represents the Fast Fourier
--   Transform (FFT) of arbitrary radix and decimation scheme.
type FFTTree = GenericLogTree (Complex PrettyDouble)

-- | Returns a tree builder suitable for constructing Fast Fourier
--   Transform (FFT) decomposition trees of arbitrary radices and either
--   decimation style (i.e. - DIT or DIF).
newFFTTree :: TreeBuilder FFTTree
instance LogTree FFTTree (Complex PrettyDouble)
