-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A Range type with vector-space instances
--   
--   Provides functions for converting between ranges and spans
@package range-space
@version 0.1.1.0

module Data.RangeSpace.TwoD

-- | A wrapper for two-dimensional vector types.
data D2V a b
D2V :: !a -> !b -> D2V a b
xAxis :: D2V a b -> !a
yAxis :: D2V a b -> !b
instance (Eq a, Eq b) => Eq (D2V a b)
instance (Ord a, Ord b) => Ord (D2V a b)
instance (Show a, Show b) => Show (D2V a b)
instance (HasBasis a, HasBasis b, Scalar a ~ Scalar b) => HasBasis (D2V a b)
instance (VectorSpace a, VectorSpace b, Scalar a ~ Scalar b) => VectorSpace (D2V a b)
instance (AffineSpace a, AffineSpace b) => AffineSpace (D2V a b)
instance (AdditiveGroup a, AdditiveGroup b) => AdditiveGroup (D2V a b)
instance (Num a, Num b) => Num (D2V a b)


module Data.RangeSpace

-- | Define a Range over some domain
data Range t
Range :: !t -> !t -> Range t

-- | A '(minimum,maximum)' pair
type Bounds t = (t, t)

-- | A starting point and duration
type Span t = (t, Diff t)

-- | Convert a <tt>Range</tt> to a '(min,max)' pair.
toBounds :: Ord t => Range t -> Bounds t

-- | Create a <tt>Range</tt> from a '(min,max)' <a>Bounds</a> pair.
--   
--   <a>fromBounds</a> uses the <a>Ord</a> instance to construct a
--   <a>Range</a>. For multi-dimensional types, this probably isn't
--   correct. For that case, see <a>newRange</a>
fromBounds :: Ord t => Bounds t -> Range t

-- | A curried form of <tt>fromBounds</tt>
--   
--   See the notes for <tt>fromBounds</tt>.
fromBoundsC :: Ord t => t -> t -> Range t

-- | Create a range from a 'start,stop' pair. For multi-dimensional ranges,
--   the resulting range will be the union of the two points.
newRange :: BasisRange t => t -> t -> Range t
rangeStart :: Ord t => Range t -> t
rangeEnd :: Ord t => Range t -> t

-- | Get the range covered by a <tt>Range</tt>
range :: AffineSpace t => Range t -> Diff t

-- | Generate a <tt>Span</tt>, '(start, distance)' from a <a>Range</a>
toSpan :: AffineSpace t => Range t -> (t, Diff t)

-- | Generate a <tt>Range</tt> from a <tt>Span</tt> '(start, distance)'
fromSpan :: AffineSpace t => Span t -> Range t

-- | A curried <tt>fromSpan</tt>
fromSpanC :: AffineSpace t => t -> Diff t -> Range t

-- | Create a 2D range from two independent axes.
range2D :: (Ord a, Ord b) => Range a -> Range b -> Range (D2V a b)

-- | Decompose a 2D range into X/Y axes.
fromRange2D :: (Ord a, Ord b) => Range (D2V a b) -> (Range a, Range b)

-- | Calculate the union of two <a>Bounds</a>. See the notes for
--   <tt>unionRange</tt>.
unionBounds :: BasisRange t => Bounds t -> Bounds t -> Bounds t

-- | Translate a <a>Range</a> by the given amount.
translateRange :: AffineSpace t => Diff t -> Range t -> Range t

-- | Calculate the union of two <a>Range</a>s, per-basis.
--   
--   The union is constructed by calculating the difference vector between
--   two points, performing a basis decomposition on that vector,
--   performing comparisons and adjustments on each basis vector,
--   recomposing, and adding the result back to the starting position.
--   
--   The advantage of this method is that it works on an <a>AffineSpace</a>
--   and doesn't require a full <a>VectorSpace</a>. It does require that
--   the affine space scalars are in a vector space, but this is more
--   easily satisfiable.
unionRange :: BasisRange t => Range t -> Range t -> Range t

-- | Restrict a <a>Range</a> by applying a sub-<a>Range</a> mask.
--   
--   For ranges with multiple dimensions, the masking is performed
--   independently for each basis. If the range lies entirely outside the
--   mask, the returned value is 'Range rmin rmin' (per-basis)
maskRange :: (Eq (Basis (Diff t)), BasisRange t) => Range t -> Range t -> Range t

-- | True if a value lies inside a <a>Range</a>.
inRange :: (BasisRange a, Eq (Basis (Diff a))) => a -> Range a -> Bool

-- | Check if a value is in a <tt>Range</tt>, using <a>Ord</a> comparison.
--   
--   If <a>Ord</a> is usable, this is likely to be faster than
--   <tt>inRange</tt>.
inOrdRange :: Ord a => a -> Range a -> Bool

-- | Compare a value to a <tt>Range</tt>. Returns <tt>EQ</tt> if the value
--   is inside the range, <tt>LT</tt> or <tt>GT</tt> if it's outside.
--   
--   Uses <tt>Ord</tt> for comparison.
compareRange :: Ord a => a -> Range a -> Ordering

-- | Calculate the X extent of a 2D pointwise range
extentX :: (Ord b, Ord a) => Range (Point (D2V a b)) -> Range a

-- | Calculate the Y extent of a 2D pointwise range
extentY :: (Ord b, Ord a) => Range (Point (D2V a b)) -> Range b
instance Eq t => Eq (Range t)
instance Show t => Show (Range t)
instance Ord t => Ord (Range t)
instance Functor Range
instance (BasisRange t) => Semigroup (Range t)
instance Applicative Range
