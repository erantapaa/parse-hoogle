-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An implementation of the Spritz RC4-like stream cipher in Haskell
--   
--   An implementation of the Spritz RC4-like stream cipher in Haskell
@package spritz
@version 0.1.0.0


-- | The original paper for the Spritz cipher can be found here:
--   
--   <a>https://people.csail.mit.edu/rivest/pubs/RS14.pdf</a>
--   
--   This package provides a Haskell implementation of the pseudocode in
--   the paper listed above. It intends to be a direct implementation of
--   the cipher, so we rely heavily on use of the State monad. We also make
--   heavy use of the lens library's combinators, internally, to ease our
--   use of State.
--   
--   Please report any and all bugs to
--   <a>https://github.com/relrod/spritz</a>.
--   
--   Lastly, I must give a shout-out to <a>spritzjs</a> for the bitmasking
--   parts and for existing so that I had something to test against when I
--   was done.
module Crypto.Cipher.Spritz

-- | Register values and <a>s</a>. As a <b>difference to the paper</b>, we
--   also include <a>n</a> in the state, for easy access to it within the
--   various functions.
--   
--   See §3.1 <a>State</a>.
data SpritzState
SpritzState :: Int -> Int -> Int -> Int -> Int -> Int -> Vector Int -> Int -> SpritzState

-- | Register: Always incremented by <tt><a>w</a> `'mod'` <a>n</a></tt>
--   whenever changed.
_i :: SpritzState -> Int

-- | Register
_j :: SpritzState -> Int

-- | Register
_k :: SpritzState -> Int

-- | Register: Last value produced by <a>output</a>
_z :: SpritzState -> Int

-- | Register: Modified when <a>whip</a> is called. Always relatively prime
--   to <a>n</a>.
_w :: SpritzState -> Int

-- | Register: Number of nibbles absorbed since start of last
--   <a>shuffle</a> of <a>s</a>.
_a :: SpritzState -> Int

-- | Length <a>n</a>. Permutation of Z_n.
_s :: SpritzState -> Vector Int

-- | All values in Spritz are modulo <a>n</a>.
_n :: SpritzState -> Int
i :: Lens' SpritzState Int
j :: Lens' SpritzState Int
k :: Lens' SpritzState Int
z :: Lens' SpritzState Int
w :: Lens' SpritzState Int
a :: Lens' SpritzState Int
s :: Lens' SpritzState (Vector Int)
n :: Lens' SpritzState Int

-- | Returns the standard initial state. See §3.2 <a>InitializeState</a>.
initializeState :: Int -> SpritzState

-- | Takes a variable-lenght input and updates the state based on it.
--   Spritz absorbs input in blocks of <tt><a>floor</a> (<a>n</a> / 2)</tt>
--   nibbles each (low-order nibble of each byte first). After each block
--   is absorbed, we call <a>shuffle</a>.
--   
--   Satisfies the following law:
--   
--   <pre>
--   <a>absorb</a> x1 &gt;&gt; <a>absorb</a> x2 = 'absorb (x1 ++ x2)'
--   </pre>
--   
--   See §3.2 <a>Absorb</a>.
absorb :: Vector Int -> State SpritzState ()

-- | Splits the given input byte into two nibbles and updates state based
--   on each nibble, low-order nibble first. See §3.2 <a>AbsorbByte</a>.
absorbByte :: Int -> State SpritzState ()

-- | Tests whether Spritz is full of absorbed data (i.e. <tt><a>a</a> =
--   <a>floor</a> (<a>n</a> / 2)</tt>. If it is, calls <a>shuffle</a> to
--   mix in the absorbed data and reset <a>a</a> to 0. Then updates the
--   state based on the value of the supplied nibble. See §3.2
--   <a>AbsorbNibble</a>.
absorbNibble :: Int -> State SpritzState ()

-- | Equivalent to absorbing a special "stop" symbol outside of the
--   oridnary input alphabet. The intent is to provide a clean way to
--   separate different inputs being absorbed. See §2.1.
absorbStop :: State SpritzState ()

-- | <a>whip</a>s, <a>crush</a>es, <a>whip</a>s, <a>crush</a>es, and
--   finally <a>whip</a>s again. According to the paper, each <a>whip</a>
--   randomizes the state. Calling <a>crush</a> between each <a>whip</a>
--   causes the effects of <a>crush</a> to be not easily determined by
--   manipulating the input. See §3.2 <a>Shuffle</a>.
shuffle :: State SpritzState ()

-- | Calls <a>update</a> <tt>r</tt> times. Also updates <a>w</a> to the
--   next largest value that is relatively prime to <a>n</a>.
whip :: Int -> State SpritzState ()

-- | Provides a non-invertable transformation from states to states.
--   Intentionally loses information about the current state by mapping
--   2^(n<i>2) states to 1 state, since each of @<a>n</a></i>2@ pairs of
--   compared values in <a>s</a> are sorted into increasing order. See §3.2
--   "crush".
crush :: State SpritzState ()

-- | Main output function for Spritz. The <a>Int</a> parameter states how
--   many bytes to produce. Calls <a>shuffle</a> if <tt><a>a</a> &gt;
--   0</tt>, which shuffles any unabsorbed input and puts Spritz into
--   "squeeze mode" (<tt><a>a</a> &gt; 0</tt>). See §3.2 "squeeze".
squeeze :: Int -> State SpritzState (Vector Int)

-- | Basic pseudorandom output routine. Calls <a>shuffle</a> when
--   <tt><a>a</a> &gt; 0</tt>, updates state using <a>update</a>, and
--   produces one output byte using <a>output</a>. See §3.2 "drip".
drip :: State SpritzState Int

-- | Advances the system to the next state by adding <a>w</a> to <a>i</a>,
--   giving <a>j</a> and <a>k</a> their next values, and swapping
--   <tt>s'_'i</tt> with <tt>s'_'j</tt>. <a>w</a> being relatively prime to
--   <a>n</a> means that the value of <a>i</a> cycles modulo <a>n</a> as
--   repeated updates are performed. See §3.2 "update".
update :: State SpritzState ()

-- | Computes a single byte (<a>n</a>-value) to output, saves it in
--   register <a>z</a> and returns it.
output :: State SpritzState Int

-- | See §3.1 <a>Nibbles</a>.
low :: (Bits a, Num a, Show a) => a -> a

-- | See §3.1 <a>Nibbles</a>.
high :: (Bits a, Num a, Show a) => a -> a

-- | A utility function that adds the first parameter to the second then
--   returns that modulo the third parameter (<a>n</a>). This is used
--   throughout Spritz in place of a more traditional <a>xor</a> approach
--   so that <a>n</a> can be any value and is not limited to being a power
--   of 2.
plusmod :: Integral a => a -> a -> a -> a

-- | See <a>plusmod</a>. This is very similar except it subtracts the first
--   two arguments instead of adding them.
submod :: Integral a => a -> a -> a -> a

-- | Swap two elements given indices of S.
swap :: Int -> Int -> State SpritzState ()

-- | Adds-modulo-N (<a>plusmod</a>) each byte of the message with the
--   corresponding byte of the output of <a>squeeze</a> yielding an
--   ecrypted ciphertext. See §2.2.
encrypt :: Vector Int -> Vector Int -> SpritzState -> Vector Int

-- | Decrypts a message encrypted with <a>encrypt</a>. Identical to
--   <a>encrypt</a> except uses <a>submod</a> instead. See §2.2.
decrypt :: Vector Int -> Vector Int -> SpritzState -> Vector Int

-- | Used in the paper at the top of <a>encrypt</a>* and <a>decrypt</a>,
--   but not used by default in this library. Still, we provide it in case
--   it's needed.
--   
--   <pre>
--   keySetup n' k' = put (initializeState n') &gt;&gt; absorb k'
--   </pre>
keySetup :: Int -> Vector Int -> State SpritzState ()

-- | Produces an <tt>r</tt>-byte hash of the input message.
--   
--   <a>hash</a> absorbs the input message, calls <a>absorbStop</a> to
--   signal the end of the input message, then absorbs the desired hash
--   length (<tt>r</tt>).
--   
--   The given <tt>r</tt> is absorbed for functional separation.
--   
--   See §2.3.
hash :: Vector Int -> Int -> SpritzState -> Vector Int

-- | Message authentication code. See §2.4.
mac :: Vector Int -> Vector Int -> Int -> SpritzState -> Vector Int
instance Show SpritzState
instance Eq SpritzState
instance Ord SpritzState
