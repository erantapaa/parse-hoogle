-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Play, write, read, convert audio signals using Sox
--   
--   This is a wrapper to Sox the Sound Exchanger
--   <a>http://sox.sourceforge.net/</a> which lets you play, write, read
--   and convert audio signals in various formats, resolutions, and numbers
--   of channels.
--   
--   The functions call sox commands via the shell, that is, the <a>sox</a>
--   and <a>play</a> executables must be installed and in the path to the
--   executables must be set.
--   
--   In the past this was part of the synthesizer package.
--   
--   There is some ancient code, which allows interactive playback using
--   the shell-pipe package on GHC-6.2, where no runInteractiveProcess was
--   available.
@package sox
@version 0.2.2.5


-- | This module calls the <tt>soxi</tt> command which is available since
--   <tt>sox</tt> version 14.
--   
--   We have to call <tt>soxi</tt> for every option. However we hide this
--   in our interface, such that we could do more efficiently, if
--   <tt>soxi</tt> supports multiple outputs in future.
module Sound.Sox.Information
newtype T a
Cons :: (ReaderT FilePath IO a) -> T a
simple :: Read a => (String -> Maybe a) -> String -> T a
format :: T String
sampleRate :: T Int
numberOfChannels :: T Int
length :: T Int
bitsPerSample :: T Int
get :: T a -> FilePath -> IO a
exampleMulti :: IO (String, Int, Int)
exampleSingle :: IO Int
instance Applicative T
instance Functor T


-- | Functions for reading and writing data using the endianess of the
--   machine. This is the way Sox handles raw data. This module is more or
--   less provided for completeness, since it is based on lists, which
--   means that it is too slow to process real world data. For serious
--   applications use Data.StorableVector.Lazy.
module Sound.Sox.Signal.List
writeFile :: Storable a => FilePath -> [a] -> IO ()
put :: Storable a => Handle -> [a] -> IO ()
withReadFile :: Storable a => FilePath -> (Exceptional IOReadException [a] -> IO b) -> IO b
getContents :: Storable a => Handle -> IO (Exceptional IOReadException [a])
data ReadException
type IOReadException = Either ReadException SomeException
instance Show ReadException
instance Eq ReadException
instance Enum ReadException


-- | We just re-export the type from sample-frame:Sound.Frame.Stereo.
module Sound.Sox.Frame.Stereo
data T a :: * -> *
left :: T a -> a
right :: T a -> a
cons :: a -> a -> T a

module Sound.Sox.Format
custom :: String -> T
aiff :: T
wave :: T
ogg :: T
mp3 :: T
iff8svx :: T
muLaw :: T
signedByte :: T
unsignedByte :: T
signedWord :: T
unsignedWord :: T
signedLong :: T
unsignedLong :: T
ieeeSinglePrecision :: T
ieeeDoublePrecision :: T
data T

module Sound.Sox.Convert

-- | <pre>
--   :load Sound.Sox.Convert
--   
--   simple Option.none "test.aiff" Option.none "test.wav"
--   </pre>
simple :: T -> FilePath -> T -> FilePath -> IO ExitCode

module Sound.Sox.Option.Format
none :: T
numberOfChannels :: Int -> T
numberOfChannelsAuto :: Int -> T
sampleRate :: Int -> T
bitsPerSample :: Int -> T
format :: T -> T

-- | You can combine options using the <a>Monoid</a> functions
--   <a>mappend</a> and <a>mconcat</a>. When the same option is given
--   multiple times, only the first occurence is respected.
data T
single :: String -> [String] -> T

module Sound.Sox.Frame
class C y => C y
format :: C y => y -> T
withSignal :: (y -> a) -> sig y -> a

-- | The argument is not touched and can be undefined
numberOfChannels :: C y => y -> Int
instance C a => C (T a)
instance C T
instance C Double
instance C Float
instance C Int32
instance C Word32
instance C Int16
instance C Word16
instance C Int8
instance C Word8

module Sound.Sox.Read
data Handle signal

-- | Unfortunately we cannot retrieve the sample rate using <tt>sox</tt>.
--   However there is <tt>soxi</tt> for this purpose, which we may support
--   in future.
--   
--   <pre>
--   :load Sound.Sox.Read Sound.Sox.Signal.List
--   :module + Control.Exception
--   bracket (open Option.none "test.aiff") close $ \h -&gt; withHandle2 Sound.Sox.Signal.List.getContents h &gt;&gt;= \x -&gt; print (Control.Monad.Exception.Asynchronous.result x :: [Data.Int.Int16])
--   </pre>
open :: C y => T -> FilePath -> IO (Handle (sig y))
close :: Handle signal -> IO ExitCode
withHandle1 :: (Handle -> m signal) -> (Handle signal -> m signal)
withHandle2 :: (Handle -> m (f signal)) -> (Handle signal -> m (f signal))

module Sound.Sox.Write

-- | Sox determines the output format from the filename extension or from
--   <a>format</a>. Make sure that you provide one of them.
--   
--   <pre>
--   :load Sound.Sox.Write Sound.Sox.Signal.List
--   
--   simple Sound.Sox.Signal.List.put Option.none "test.aiff" 11025 (take 100 $ iterate (1000+) (0::Data.Int.Int16))
--   </pre>
simple :: C y => (Handle -> sig y -> IO ()) -> T -> FilePath -> Int -> sig y -> IO ExitCode
extended :: C y => (Handle -> sig y -> IO ()) -> T -> T -> FilePath -> Int -> sig y -> IO ExitCode

-- | The traversable functor <tt>f</tt> might be <a>Maybe</a> or '[]'. It
--   allows you to write to many files simultaneously and returns the exit
--   codes of all writing processes.
manyExtended :: (C y, Traversable f) => (f Handle -> sig y -> IO ()) -> T -> T -> f FilePath -> Int -> sig y -> IO (f ExitCode)

module Sound.Sox.Play

-- | <pre>
--   :load Sound.Sox.Play Sound.Sox.Signal.List
--   
--   simple Sound.Sox.Signal.List.put Option.none 11025 (iterate (1000+) (0::Data.Int.Int16))
--   </pre>
simple :: C y => (Handle -> sig y -> IO ()) -> T -> Int -> sig y -> IO ExitCode
extended :: C y => (Handle -> sig y -> IO ()) -> T -> T -> Int -> sig y -> IO ExitCode
