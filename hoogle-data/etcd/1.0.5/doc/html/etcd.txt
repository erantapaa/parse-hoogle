-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Client for etcd, a highly-available key value store
--   
@package etcd
@version 1.0.5


-- | This module contains an implementation of the etcd client.
module Network.Etcd

-- | The <a>Client</a> holds all data required to make requests to the etcd
--   cluster. You should use <a>createClient</a> to initialize a new
--   client.
data Client

-- | Create a new client and initialize it with a list of seed machines.
--   The list must be non-empty.
createClient :: [Text] -> IO Client

-- | The <a>Node</a> corresponds to the node object as returned by the etcd
--   API.
--   
--   There are two types of nodes in etcd. One is a leaf node which holds a
--   value, the other is a directory node which holds zero or more child
--   nodes. A directory node can not hold a value, the two types are
--   exclusive.
--   
--   On the wire, the two are not really distinguished, except that the
--   JSON objects have different fields.
--   
--   A node may be set to expire after a number of seconds. This is
--   indicated by the two fields <tt>ttl</tt> and <tt>expiration</tt>.
data Node
Node :: !Key -> !Index -> !Index -> !Bool -> !(Maybe Value) -> !(Maybe [Node]) -> !(Maybe TTL) -> !(Maybe UTCTime) -> Node

-- | The key of the node. It always starts with a slash character (0x47).
_nodeKey :: Node -> !Key

-- | A unique index, reflects the point in the etcd state machine at which
--   the given key was created.
_nodeCreatedIndex :: Node -> !Index

-- | Like <a>_nodeCreatedIndex</a>, but reflects when the node was last
--   changed.
_nodeModifiedIndex :: Node -> !Index

-- | <a>True</a> if this node is a directory.
_nodeDir :: Node -> !Bool

-- | The value is only present on leaf nodes. If the node is a directory,
--   then this field is <a>Nothing</a>.
_nodeValue :: Node -> !(Maybe Value)

-- | If this node is a directory, then these are its children. The list may
--   be empty.
_nodeNodes :: Node -> !(Maybe [Node])

-- | If the node has TTL set, this is the number of seconds how long the
--   node will exist.
_nodeTTL :: Node -> !(Maybe TTL)

-- | If TTL is set, then this is the time when it expires.
_nodeExpiration :: Node -> !(Maybe UTCTime)

-- | The etcd index is a unique, monotonically-incrementing integer created
--   for each change to etcd. See etcd documentation for more details.
type Index = Int

-- | Keys are strings, formatted like filesystem paths (ie. slash-delimited
--   list of path components).
type Key = Text

-- | Values attached to leaf nodes are strings. If you want to store
--   structured data in the values, you'll need to encode it into a string.
type Value = Text

-- | TTL is specified in seconds. The server accepts negative values, but
--   they don't make much sense.
type TTL = Int

-- | Get the node at the given key.
get :: Client -> Key -> IO (Maybe Node)

-- | Set the value at the given key.
set :: Client -> Key -> Value -> Maybe TTL -> IO (Maybe Node)

-- | Create a value in the given key. The key must be a directory.
create :: Client -> Key -> Value -> Maybe TTL -> IO Node

-- | Wait for changes on the node at the given key.
wait :: Client -> Key -> IO (Maybe Node)

-- | Same as <a>wait</a> but at a given index.
waitIndex :: Client -> Key -> Index -> IO (Maybe Node)

-- | Same as <a>wait</a> but includes changes on children.
waitRecursive :: Client -> Key -> IO (Maybe Node)

-- | Same as <a>waitIndex</a> but includes changes on children.
waitIndexRecursive :: Client -> Key -> Index -> IO (Maybe Node)

-- | Create a directory at the given key.
createDirectory :: Client -> Key -> Maybe TTL -> IO ()

-- | List all nodes within the given directory.
listDirectoryContents :: Client -> Key -> IO [Node]

-- | Same as <a>listDirectoryContents</a> but includes all descendant
--   nodes. Note that directory <a>Node</a>s will not contain their
--   children.
listDirectoryContentsRecursive :: Client -> Key -> IO [Node]

-- | Remove the directory at the given key. The directory MUST be empty,
--   otherwise the removal fails. If you don't care about the keys within,
--   you can use <a>removeDirectoryRecursive</a>.
removeDirectory :: Client -> Key -> IO ()

-- | Remove the directory at the given key, including all its children.
removeDirectoryRecursive :: Client -> Key -> IO ()
instance Show Action
instance Eq Action
instance Ord Action
instance Show Error
instance Eq Error
instance Ord Error
instance Show Node
instance Eq Node
instance Ord Node
instance Show Response
instance Eq Response
instance Ord Response
instance FromJSON Node
instance FromJSON Response
instance FromJSON Action
