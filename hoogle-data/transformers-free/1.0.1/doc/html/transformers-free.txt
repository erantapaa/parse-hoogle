-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Free monad transformers
--   
--   This package is obsolete and all functionality has been merged into
--   the <tt>free</tt> package.
--   
--   This library generalizes free monads to free monad transformers.
@package transformers-free
@version 1.0.1


-- | Free monads build syntax trees. See the example sections for details.
--   
--   A free monad over a functor resembles a list of that functor:
--   
--   <ul>
--   <li><a>return</a> behaves like <tt>[]</tt> by not using the functor at
--   all</li>
--   <li><a>wrap</a> behaves like <tt>(:)</tt> by prepending another layer
--   of the functor</li>
--   <li><a>liftF</a> behaves like <tt>singleton</tt> by creating a list
--   from a single layer of the functor.</li>
--   </ul>
module Control.Monad.Trans.Free

-- | <tt>Free f a</tt> is a list of nested <tt>f</tt>s terminating with a
--   return value of type <tt>a</tt>.
--   
--   <ul>
--   <li><tt>f</tt> - The functor that generates the free monad</li>
--   <li><tt>a</tt> - The return value</li>
--   </ul>
type Free f = FreeT f Identity

-- | The signature for <a>Free</a>
data FreeF f a x
Pure :: a -> FreeF f a x
Free :: (f x) -> FreeF f a x

-- | Observation function that exposes the next step
runFree :: Free f r -> FreeF f r (Free f r)

-- | A free monad transformer alternates nesting the base monad <tt>m</tt>
--   and the base functor <tt>f</tt>, terminating with a value of type
--   <tt>a</tt>.
--   
--   <ul>
--   <li><tt>f</tt> - The functor that generates the free monad
--   transformer</li>
--   <li><tt>m</tt> - The base monad</li>
--   <li><tt>a</tt> - The return value</li>
--   </ul>
newtype FreeT f m a
FreeT :: m (FreeF f a (FreeT f m a)) -> FreeT f m a
runFreeT :: FreeT f m a -> m (FreeF f a (FreeT f m a))

-- | Prepend one layer of the functor to the free monad
wrap :: Monad m => f (FreeT f m a) -> FreeT f m a

-- | Convert one layer of a functor into an operation in the free monad
liftF :: (Functor f, Monad m) => f a -> FreeT f m a
instance (Functor f, MonadIO m) => MonadIO (FreeT f m)
instance MonadTrans (FreeT f)
instance (Functor f, Monad m) => Monad (FreeT f m)
instance (Functor f, Monad m) => Applicative (FreeT f m)
instance (Functor f, Monad m) => Functor (FreeT f m)
