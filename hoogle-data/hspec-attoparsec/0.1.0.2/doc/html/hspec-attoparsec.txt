-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Utility functions for testing your attoparsec parsers with hspec
--   
@package hspec-attoparsec
@version 0.1.0.2


-- | A <a>Source</a> class that ties parser types and input types to give
--   you a uniform interface for testing your parsers, without caring about
--   the input type.
module Test.Hspec.Attoparsec.Source

-- | A class where each instance will just teach how to get an Either or
--   the specific result type associated to the parser for the given input
--   type.
class (Eq string, Show string, IsString string) => Source parser string string' result | string -> parser, string -> result, string -> string'
(~>) :: Source parser string string' result => string -> parser string' a -> Either String a
(~?>) :: Source parser string string' result => string -> parser string' a -> result a

-- | Class for generically inspecting unconsumed input
class Leftover r s | r -> s
leftover :: Leftover r s => r a -> Maybe s
instance Leftover Result Text
instance Leftover Result Text
instance Leftover Result ByteString
instance Leftover Result ByteString
instance Source Parser Text Text Result
instance Source Parser Text Text Result
instance Source Parser ByteString ByteString Result
instance Source Parser ByteString ByteString Result


-- | Utility functions for testing <tt>attoparsec</tt> parsers, each one
--   providing an example of how to use it.
module Test.Hspec.Attoparsec

-- | Create an expectation by saying what the result should be. Intended to
--   be used with <a>~&gt;</a> as follows:
--   
--   <pre>
--   "&lt;!-- foo --&gt;" ~&gt; htmlCommentParser
--     `shouldParse` TagComment " foo "
--   </pre>
shouldParse :: (Eq a, Show a) => Either String a -> a -> Expectation

-- | Create an expectation by saying that the parser should successfully
--   parse a value and that this value should satisfy some predicate.
--   
--   This can fail if the parsing doesn't succeed or if it succeeds but the
--   value doesn't match the predicate.
--   
--   <pre>
--   "&gt;&gt;&gt;" ~&gt; many (char '&gt;')
--     `parseSatisfies` ((==3) . length)
--   </pre>
parseSatisfies :: Show a => Either String a -> (a -> Bool) -> Expectation

-- | Check that a parser succeeds on some given input
--   
--   <pre>
--   char 'x' `shouldSucceedOn` "x"
--   </pre>
shouldSucceedOn :: (Source p s s' r, Show a) => p s' a -> s -> Expectation

-- | Check that a parser fails on some given input
--   
--   <pre>
--   char 'x' `shouldFailOn` "a"
--   </pre>
shouldFailOn :: (Source p s s' r, Show a) => p s' a -> s -> Expectation

-- | Checking that the given parser succeeds and yields the given part of
--   the input unconsumed. Intended to be used in conjunction with
--   <a>~?&gt;</a>
--   
--   <pre>
--   ("xa" :: Text) ~?&gt; char 'x'
--     `leavesUnconsumed` "a"
--   </pre>
leavesUnconsumed :: (Source p s s' r, Leftover r s) => r a -> s -> Expectation

-- | A class where each instance will just teach how to get an Either or
--   the specific result type associated to the parser for the given input
--   type.
class (Eq string, Show string, IsString string) => Source parser string string' result | string -> parser, string -> result, string -> string'
(~>) :: Source parser string string' result => string -> parser string' a -> Either String a
(~?>) :: Source parser string string' result => string -> parser string' a -> result a

-- | Class for generically inspecting unconsumed input
class Leftover r s | r -> s
leftover :: Leftover r s => r a -> Maybe s
