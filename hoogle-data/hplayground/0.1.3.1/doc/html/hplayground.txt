-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | monadic, reactive Formlets running in the Web browser
--   
@package hplayground
@version 0.1.3.1


-- | The haste-hplayground framework.
--   <a>http://github.com/agocorona/hplayground</a>
module Haste.HPlay.View
type Widget a = View Perch IO a

-- | Join two widgets in the same page the resulting widget, when
--   <tt>ask</tt>ed with it, return a 2 tuple of their validation results
--   if both return Noting, the widget return <tt>Nothing</tt> (invalid).
--   
--   it has a low infix priority: <tt>infixr 2</tt>
--   
--   <pre>
--   r &lt;- ask  widget1 &lt;+&gt;  widget2
--   case r of (Just x, Nothing) -&gt; ..
--   </pre>
(<+>) :: (Monad m, FormInput view) => View view m a -> View view m b -> View view m (Maybe a, Maybe b)

-- | The first elem result (even if it is not validated) is discarded, and
--   the secod is returned . This contrast with the applicative operator
--   <a>*&gt;</a> which fails the whole validation if the validation of the
--   first elem fails.
--   
--   The first element is displayed however, as happens in the case of
--   <a>*&gt;</a> .
--   
--   Here <tt>w's</tt> are widgets and <tt>r's</tt> are returned values
--   
--   <tt>(w1 &lt;* w2)</tt> will return <tt>Just r1</tt> only if w1 and w2
--   are validated
--   
--   <tt>(w1 &lt;** w2)</tt> will return <tt>Just r1</tt> even if w2 is not
--   validated
--   
--   it has a low infix priority: <tt>infixr 1</tt>
(**>) :: (Functor m, Monad m, FormInput view) => View view m a -> View view m b -> View view m b

-- | The second elem result (even if it is not validated) is discarded, and
--   the first is returned . This contrast with the applicative operator
--   <a>*&gt;</a> which fails the whole validation if the validation of the
--   second elem fails. The second element is displayed however, as in the
--   case of <a>&lt;*</a>. see the <a>&lt;**</a> examples
--   
--   it has a low infix priority: <tt>infixr 1</tt>
(<**) :: (Functor m, Monad m, FormInput view) => View view m a -> View view m b -> View view m a

-- | Validates a form or widget result against a validating procedure
--   
--   <pre>
--   getOdd= getInt Nothing <a>validate</a> (x -&gt; return $ if mod x 2==0 then  Nothing else Just "only odd numbers, please")
--   </pre>
validate :: Widget a -> (a -> WState Perch IO (Maybe Perch)) -> Widget a

-- | Concat a list of widgets of the same type, return a the first
--   validated result
firstOf :: [Widget a] -> Widget a

-- | from a list of widgets, it return the validated ones.
manyOf :: [Widget a] -> Widget [a]

-- | like manyOf, but does not validate if one or more of the widgets does
--   not validate
allOf :: [Widget a] -> Widget [a]

-- | Enclose Widgets within some formating. <tt>view</tt> is intended to be
--   instantiated to a particular format
--   
--   NOTE: It has a infix priority : <tt>infixr 5</tt> less than the one of
--   <tt>++&gt;</tt> and <tt>&lt;++</tt> of the operators, so use
--   parentheses when appropriate, unless the we want to enclose all the
--   widgets in the right side. Most of the type errors in the DSL are due
--   to the low priority of this operator.
(<<<) :: (Perch -> Perch) -> Widget a -> Widget a

-- | A parameter application with lower priority than ($) and direct
--   function application
(<<) :: (t1 -> t) -> t1 -> t

-- | Append formatting code to a widget
--   
--   <pre>
--   getString "hi" &lt;++ H1 &lt;&lt; "hi there"
--   </pre>
--   
--   It has a infix prority: <tt>infixr 6</tt> higuer that
--   <a>&lt;&lt;&lt;</a> and most other operators
(<++) :: (Monad m, Monoid v) => View v m a -> v -> View v m a

-- | Prepend formatting code to a widget
--   
--   <pre>
--   bold <a>"enter name" ++</a> getString Nothing
--   </pre>
--   
--   It has a infix prority: <tt>infixr 6</tt> higuer that
--   <a>&lt;&lt;&lt;</a> and most other operators
(++>) :: Perch -> Widget a -> Widget a

-- | Add attributes to the topmost tag of a widget
--   
--   it has a fixity <tt>infix 8</tt>
(<!) :: (FormInput v, Monad m) => View v m a -> Attribs -> View v m a

-- | It is a callback in the view monad. The rendering of the second
--   parameter substitutes the rendering of the first paramenter when the
--   latter validates without afecting the rendering of other widgets. This
--   allow the simultaneous execution of different dynamic behaviours in
--   different page locations at the same page.
wcallback :: Widget a -> (a -> Widget b) -> Widget b

-- | show something enclosed in the <a>pre</a> tag, so ASCII formatting
--   chars are honored
wprint :: ToElem a => a -> Widget ()

-- | Display a text box and return a non empty String
getString :: (StateType (View view m) ~ MFlowState, FormInput view, Monad (View view m), MonadIO m) => Maybe String -> View view m String
inputString :: (StateType (View view m) ~ MFlowState, FormInput view, Monad (View view m), MonadIO m) => Maybe String -> View view m String

-- | Display a text box and return an Integer (if the value entered is not
--   an Integer, fails the validation)
getInteger :: (StateType (View view m) ~ MFlowState, FormInput view, MonadIO m) => Maybe Integer -> View view m Integer
inputInteger :: (StateType (View view m) ~ MFlowState, FormInput view, MonadIO m) => Maybe Integer -> View view m Integer

-- | Display a text box and return a Int (if the value entered is not an
--   Int, fails the validation)
getInt :: (StateType (View view m) ~ MFlowState, FormInput view, MonadIO m) => Maybe Int -> View view m Int
inputInt :: (StateType (View view m) ~ MFlowState, FormInput view, MonadIO m) => Maybe Int -> View view m Int
inputFloat :: (StateType (View view m) ~ MFlowState, FormInput view, MonadIO m) => Maybe Float -> View view m Float
inputDouble :: (StateType (View view m) ~ MFlowState, FormInput view, MonadIO m) => Maybe Double -> View view m Double

-- | Display a password box
getPassword :: (FormInput view, StateType (View view m) ~ MFlowState, MonadIO m) => View view m String
inputPassword :: (StateType (View view m) ~ MFlowState, FormInput view, MonadIO m) => View view m String

-- | Implement a radio button the parameter is the name of the radio group
setRadio :: (FormInput view, MonadIO m, Typeable a, Eq a, Show a) => a -> String -> View view m (Radio a)
setRadioActive :: (Typeable a, Eq a, Show a) => a -> String -> Widget (Radio a)

-- | encloses a set of Radio boxes. Return the option selected
getRadio :: (Monad (View view m), Monad m, Functor m, FormInput view) => [String -> View view m (Radio a)] -> View view m a

-- | Display a text box and return the value entered if it is readable(
--   Otherwise, fail the validation)
setCheckBox :: (FormInput view, MonadIO m, Typeable a, Show a) => Bool -> a -> View view m (CheckBoxes a)
getCheckBoxes :: (Monad m, FormInput view) => View view m (CheckBoxes a) -> View view m [a]
getTextBox :: (FormInput view, StateType (View view m) ~ MFlowState, MonadIO m, Typeable a, Show a, Read a) => Maybe a -> View view m a

-- | Display a multiline text box and return its content
getMultilineText :: (FormInput view, MonadIO m) => String -> View view m String

-- | A synonim of getMultilineText
textArea :: (FormInput view, MonadIO m) => String -> View view m String
getBool :: (FormInput view, MonadIO m, Functor m, Monad (View view m)) => Bool -> String -> String -> View view m Bool

-- | Display a dropdown box with the options in the first parameter is
--   optionally selected . It returns the selected option.
getSelect :: (FormInput view, MonadIO m, Typeable a, Read a) => View view m (MFOption a) -> View view m a

-- | Set the option for getSelect. Options are concatenated with
--   <a>&lt;|&gt;</a>
setOption :: (Monad m, Monad (View view m), Show a, Eq a, Typeable a, FormInput view) => a -> view -> View view m (MFOption a)

-- | Set the selected option for getSelect. Options are concatenated with
--   <a>&lt;|&gt;</a>
setSelectedOption :: (Monad m, Monad (View view m), Show a, Eq a, Typeable a, FormInput view) => a -> view -> View view m (MFOption a)
wlabel :: (Monad m, FormInput view) => view -> View view m a -> View view m a
resetButton :: (FormInput view, Monad m) => String -> View view m ()
inputReset :: (FormInput view, Monad m) => String -> View view m ()
submitButton :: (Monad (View view m), StateType (View view m) ~ MFlowState, FormInput view, MonadIO m) => String -> View view m String
inputSubmit :: (Monad (View view m), StateType (View view m) ~ MFlowState, FormInput view, MonadIO m) => String -> View view m String

-- | active button. When clicked, return the first parameter
wbutton :: a -> String -> Widget a

-- | Present a link. Return the first parameter when clicked
wlink :: (Show a, Typeable a) => a -> Perch -> Widget a

-- | Empty widget that does not validate. May be used as "empty boxes"
--   inside larger widgets.
--   
--   It returns a non valid value.
noWidget :: Widget a

-- | a sinonym of noWidget that can be used in a monadic expression in the
--   View monad. it stop the computation in the Widget monad.
stop :: Widget a

-- | Render raw view formatting. It is useful for displaying information.
wraw :: Perch -> Widget ()

-- | True if the widget has no valid input
isEmpty :: Widget a -> Widget Bool

-- | Run the widget as the content of the element with the given id. The
--   content can be appended, prepended to the previous content or it can
--   be the internal(Insert) or external(Outer) content depending on the
--   update method.
at :: String -> UpdateMethod -> Widget a -> Widget a

-- | A generalized version of <a>at</a> that include the widget rendering
--   at the elements that meet the selector criteria (the first parameter)
--   in the style of jQuery. the selector can match classes etc not only
--   identifiers.
at' :: String -> UpdateMethod -> Widget a -> Widget a
data UpdateMethod
Append :: UpdateMethod
Prepend :: UpdateMethod
Insert :: UpdateMethod
Outer :: UpdateMethod

-- | Get the session data of the desired type if there is any.
getSessionData :: (StateType m ~ MFlowState, MonadState m, Typeable a) => m (Maybe a)

-- | getSessionData specialized for the View monad. if Nothing, the monadic
--   computation does not continue. getSData is a widget that does not
--   validate when there is no data of that type in the session.
getSData :: Typeable a => Widget a

-- | setSessionData :: (StateType m ~ MFlowState, Typeable a) =&gt; a -&gt;
--   m ()
setSessionData :: (MonadState m, Typeable * a, (~) * (StateType m) MFlowState) => a -> m ()

-- | a shorter name for setSessionData
setSData :: (StateType m ~ MFlowState, MonadState m, Typeable a) => a -> m ()
delSessionData :: (MonadState m, Typeable * a, (~) * (StateType m) MFlowState) => a -> m ()
delSData :: (StateType m ~ MFlowState, MonadState m, Typeable a) => a -> m ()
resetEventData :: (StateType m ~ MFlowState, MonadState m) => m ()
getEventData :: Typeable a => Widget a
getMEventData :: (Typeable a, StateType m ~ MFlowState, MonadState m) => m (Maybe a)
setIOEventData :: Typeable a => a -> IO ()
setEventData :: (Typeable a, StateType m ~ MFlowState, MonadState m) => a -> m ()
class IsEvent a b | a -> b
eventName :: IsEvent a b => a -> String
buildHandler :: IsEvent a b => a -> IO () -> b
data EventData
EventData :: String -> EvData -> EventData
evName :: EventData -> String
evData :: EventData -> EvData
data EvData
NoData :: EvData
Click :: Int -> (Int, Int) -> EvData
Mouse :: (Int, Int) -> EvData
MouseOut :: EvData
Key :: Int -> EvData

-- | triggers the event when it happens in the widget.
--   
--   What happens then?
--   
--   1)The event reexecutes all the monadic sentence where the widget is,
--   (with no re-rendering)
--   
--   2) with the result of this reevaluaution, executes the rest of the
--   monadic computation
--   
--   3) update the DOM tree with the rendering of the reevaluation in 2).
--   
--   As usual, If one step of the monadic computation return empty, the
--   reevaluation finish So the effect of an event can be restricted as
--   much as you may need.
--   
--   Neither the computation nor the tree in the upstream flow is touched.
--   (unless you use out of stream directives, like <a>at</a>)
--   
--   monadic computations inside monadic computations are executed
--   following recursively the steps mentioned above. So an event in a
--   component deep down could or could not trigger the reexecution of the
--   rest of the whole.
raiseEvent :: IsEvent event callback => Widget a -> event -> Widget a

-- | A shorter synonym for <a>raiseEvent</a>
fire :: IsEvent event callback => Widget a -> event -> Widget a

-- | A shorter and smoother synonym for <a>raiseEvent</a>
wake :: IsEvent event callback => Widget a -> event -> Widget a

-- | A professional synonym for <a>raiseEvent</a>
react :: IsEvent event callback => Widget a -> event -> Widget a

-- | pass trough only if the event is fired in this DOM element. Otherwise,
--   if the code is executing from a previous event, the computation will
--   stop
pass :: Perch -> Event IO b -> Widget EventData

-- | return empty and the monadic computation stop if the condition is
--   false. If true, return the second parameter.
continueIf :: Bool -> a -> Widget a

-- | executes a widget each t milliseconds until it validates and return ()
wtimeout :: Int -> Widget () -> Widget ()

-- | These constructors correspond to their namesake DOM events. Mouse
--   related callbacks receive the coordinates of the mouse pointer at the
--   time the event was fired, relative to the top left corner of the
--   element that fired the event. The click events also receive the mouse
--   button that was pressed.
--   
--   The key up<i>down</i>press events receive the character code of the
--   key that was pressed.
data Event (m :: * -> *) a :: (* -> *) -> * -> *
OnLoad :: Event m (m ())
OnUnload :: Event m (m ())
OnChange :: Event m (m ())
OnFocus :: Event m (m ())
OnBlur :: Event m (m ())
OnMouseMove :: Event m ((Int, Int) -> m ())
OnMouseOver :: Event m ((Int, Int) -> m ())
OnMouseOut :: Event m (m ())
OnClick :: Event m (Int -> (Int, Int) -> m ())
OnDblClick :: Event m (Int -> (Int, Int) -> m ())
OnMouseDown :: Event m (Int -> (Int, Int) -> m ())
OnMouseUp :: Event m (Int -> (Int, Int) -> m ())
OnKeyPress :: Event m (Int -> m ())
OnKeyUp :: Event m (Int -> m ())
OnKeyDown :: Event m (Int -> m ())
OnSubmit :: Event m (m ())
OnWheel :: Event m ((Int, Int) -> (Double, Double, Double) -> m ())

-- | run the widget as the content of a DOM element the new rendering is
--   added to the element
runWidget :: Widget b -> Elem -> IO (Maybe b)

-- | run the widget as the content of a DOM element, the id is passed as
--   parameter. All the content of the element is erased previously and it
--   is substituted by the new rendering
runWidgetId :: Widget b -> ElemID -> IO (Maybe b)

-- | run the widget as the body of the HTML
runBody :: Widget a -> IO (Maybe a)

-- | add a header in the <a>header</a> tag
addHeader :: Perch -> IO ()

-- | To produce updates, each line of html produced by a "do" sequence in
--   the Widget monad is included within a <a>span</a> tag. When the line
--   is reexecuted after a event, the span is updated with the new
--   rendering.
--   
--   static tell to the rendering that this widget does not change, so the
--   extra <a>span</a> tag for each line in the sequence and the rewriting
--   is not necessary. Thus the size of the HTML and the performance is
--   improved.
static :: Monad m => View v m a -> View v m a

-- | override static locally to permit dynamic effects inside a static
--   widget. It is useful when a monadic Widget computation which perform
--   no rendering changes has a to do some update:
--   
--   <pre>
--   launchMissiles= static $ do
--      t &lt;- armLauncher
--      c &lt;- fixTarget t
--      f &lt;- fire c
--      dynamic $ displayUpdate t c f
--      return ()
--   </pre>
dynamic :: Monad m => View v m a -> View v m a

-- | Invoke AJAX. <tt>ToJSString</tt> is a class coverter to-from
--   JavaScript strings `(a,b)` are the lists of parameters, a is normally
--   <a>String</a> or <a>JSString</a>. JSON is also supported for <a>b</a>
--   and <tt>c</tt>. If you want to handle your data types, make a instance
--   of <a>JSType</a>
--   
--   Note the de-inversion of control. There is no callback.
--   
--   <a>ajax</a> can be combined with other Widgets using monadic,
--   applicative or alternative combinators.
ajax :: (JSType a, JSType b, JSType c, Typeable c) => Method -> URL -> [(a, b)] -> Widget (Maybe c)
data Method :: *
GET :: Method
POST :: Method

-- | get the next ideitifier that will be created by genNewId
getNextId :: (StateType m ~ MFlowState, MonadState m) => m String

-- | Generate a new string. Useful for creating tag identifiers and other
--   attributes.
--   
--   if the page is refreshed, the identifiers generated are the same.
genNewId :: (StateType m ~ MFlowState, MonadState m) => m String

-- | when creating a complex widget with many tags, this call indentifies
--   which tag will receive the attributes of the (!) operator.
continuePerch :: Widget a -> ElemID -> Widget a
getParam :: (FormInput view, StateType (View view m) ~ MFlowState, MonadIO m, Typeable a, Show a, Read a) => Maybe String -> String -> Maybe a -> View view m a
getCont :: (StateType m ~ MFlowState, MonadState m) => m EventF
runCont :: EventF -> IO ()

-- | Minimal interface for defining the basic form and link elements. The
--   core of MFlow is agnostic about the rendering package used. Every
--   formatting (either HTML or not) used with MFlow must have an instance
--   of this class. See "MFlow.Forms.Blaze.Html for the instance for
--   blaze-html" <a>MFlow.Forms.XHtml</a> for the instance for
--   <tt>Text.XHtml</tt> and MFlow.Forms.HSP for the instance for Haskell
--   Server Pages.
class (Monoid view, Typeable view) => FormInput view where flink1 verb = flink verb (fromStr verb) foption1 val msel = foption val (fromStr val) msel
fromStr :: FormInput view => String -> view
fromStrNoEncode :: FormInput view => String -> view
ftag :: FormInput view => String -> view -> view
inred :: FormInput view => view -> view
flink :: FormInput view => String -> view -> view
flink1 :: FormInput view => String -> view
finput :: FormInput view => Name -> Type -> Value -> Checked -> OnClick -> view
ftextarea :: FormInput view => String -> String -> view
fselect :: FormInput view => String -> view -> view
foption :: FormInput view => String -> view -> Bool -> view
foption1 :: FormInput view => String -> Bool -> view
formAction :: FormInput view => String -> String -> view -> view
attrs :: FormInput view => view -> Attribs -> view
newtype View v m a
View :: WState v m (FormElm v a) -> View v m a
runView :: View v m a -> WState v m (FormElm v a)
data FormElm view a
FormElm :: view -> (Maybe a) -> FormElm view a
data EventF
EventF :: (IO (Maybe b)) -> (b -> IO (Maybe c)) -> EventF
data MFlowState
MFlowState :: String -> Int -> NeedForm -> EventF -> Bool -> Dynamic -> Map TypeRep SData -> MFlowState
mfPrefix :: MFlowState -> String
mfSequence :: MFlowState -> Int
needForm :: MFlowState -> NeedForm
process :: MFlowState -> EventF
fixed :: MFlowState -> Bool
lastEvent :: MFlowState -> Dynamic
mfData :: MFlowState -> Map TypeRep SData
instance Typeable MFOption
instance Typeable EvData
instance Typeable EventData
instance Show NeedForm
instance (Read v, Read a) => Read (ParamResult v a)
instance (Show v, Show a) => Show (ParamResult v a)
instance Show EvData
instance Eq EvData
instance Show EventData
instance Show UpdateMethod
instance IsEvent (Event m a) a
instance FormInput Perch
instance Attributable (Widget a)
instance (FormInput view, Monad m, Functor m, Monad (View view m)) => Monoid (View view m (MFOption a))
instance Monoid (CheckBoxes a)
instance Monoid view => MonadTrans (View view)
instance (FormInput view, Monad (View view m), MonadIO m) => MonadIO (View view m)
instance (FormInput view, Monad m, Monad (View view m)) => MonadState (View view m)
instance (FormInput v, Monad (View v m), Monad m, Functor m, Monoid a) => Monoid (View v m a)
instance Monad (View Perch IO)
instance (Monoid view, Functor m, Monad m, Monad (View view m)) => Alternative (View view m)
instance (Monoid view, Functor m, Monad m, Monad (View view m)) => Applicative (View view m)
instance (Monad m, Functor m, Monad (View view m)) => Functor (View view m)
instance Monoid view => Monoid (FormElm view a)
instance Functor (FormElm view)


module Haste.HPlay.Cell
data Cell a
Cell :: (Maybe a -> Widget a) -> (a -> IO ()) -> IO (Maybe a) -> Cell a
mk :: Cell a -> Maybe a -> Widget a
setter :: Cell a -> a -> IO ()
getter :: Cell a -> IO (Maybe a)
boxCell :: (Show a, Read a, Typeable a) => ElemID -> Cell a

-- | Cell assignment
(.=) :: MonadIO m => Cell a -> a -> m ()
get :: MonadIO m => Cell a -> View Perch m a

-- | get a cell for the spreadsheet expression
gcell :: Num a => String -> Map String a -> a
type Expr a = Map String a -> a
rtries :: IORef Int
maxtries :: Int
rexprs :: IORef (Map String (Expr Float))
rmodified :: IORef (Map String (Expr Float))
mkscell :: ElemID -> Maybe Float -> Expr Float -> Widget Float
scell :: ElemID -> Expr Float -> Cell Float
calc :: Widget ()
instance (Num a, Eq a) => Num (x -> a)
instance (Num a, Eq a, Fractional a) => Fractional (x -> a)
instance Eq (Expr a)
instance Show (Expr a)


-- | Hplayground WebSockets have de-inversion of control. it uses wsAsk for
--   syncronous request-responses.
--   
--   wsAsk can also handle asynchronous traffic too since it catches every
--   received message, not only the next message
--   
--   For an example, see
--   <a>http://tryplayg.herokuapp.com/try/hplay-sockets.hs/edit</a>
module Haste.HPlay.WebSockets

-- | open the socket and continue the flow when it is opened.
wsOpen :: URL -> Widget SockId

-- | syncronous request-responses. wsAsk can also handle asynchronous
--   traffic too since it catches every received message, not only the next
--   message and executes the rest of the computation as is usual in a
--   active widget
wsAsk :: (JSType a, JSType b) => SockId -> a -> Widget b
wsClose :: SockId -> Widget ()
instance Unpack WSOnMsg
instance Pack WSOnMsg
instance Unpack WSOnError
instance Pack WSOnError
instance Unpack WSComputation
instance Pack WSComputation
instance Unpack WebSocket
instance Pack WebSocket
