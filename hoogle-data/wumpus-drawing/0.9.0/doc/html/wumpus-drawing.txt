-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | High-level drawing objects built on Wumpus-Basic.
--   
--   ** WARNING ** - this package is sub-alpha. Although many of the
--   drawing objects have been improved since the code was split from
--   Wumpus-Basic, the code is still prototypical. Essentially this package
--   is a <i>technology preview</i> and not yet a re-usable library.
--   
--   NOTE - many of the demos use font metrics. Font metrics for the "Core
--   14" PostScript fonts are distributed as <tt>*.afm</tt> files with
--   GhostScript in the <tt>fonts</tt> directory. Wumpus expects the
--   GhostScript font metrics to be AFM version 2.0 files (this matches
--   GhostScript 8.63). Alternatively, metrics for the Core 14 fonts are
--   available from Adode (AFM version 4.1), see the links below. To run
--   the demos properly you will need one of these sets of metrics.
--   
--   Adobe Font technical notes:
--   <a>https://www.adobe.com/devnet/font.html</a>
--   
--   Core 14 AFM metrics:
--   <a>https://www.adobe.com/content/dam/Adobe/en/devnet/font/pdfs/Core14_AFMs.tar</a>
--   
--   Also note that Wumpus uses fallback metrics (derived from the
--   monospaced Courier font) when font loading fails, rather than throwing
--   a terminal error. Applications should ideally check the font loading
--   log to ensure that fonts have loaded correctly (the demos print this
--   log to standard out).
--   
--   Changelog:
--   
--   v0.8.0 to v0.9.0:
--   
--   <ul>
--   <li>Updated to work with wumpus-basic-0.24.0.</li>
--   <li>Removed monoid mappend alias <tt>(<a></a>)</tt> as it is now
--   defined by Data.Monoid.</li>
--   </ul>
--   
--   v0.7.0 to v0.8.0:
--   
--   <ul>
--   <li>Changed API to make Connectors.</li>
--   <li>Added InclineTrails to Drawing.Basis.</li>
--   <li>Reworked <tt>Extras.Loop</tt>.</li>
--   </ul>
--   
--   v0.6.0 to v0.7.0:
--   
--   <ul>
--   <li>Changed paths - <tt>RelPath</tt> has been removed and there are
--   now only absolute paths. <tt>PathBuilder</tt> builds absolute paths.
--   Pen updating in <tt>PathBuilder</tt> now works like a State monad
--   rather than <tt>local</tt> in a Reader monad.</li>
--   <li>Changed argument order of the run functions to <tt>monadLib</tt>
--   style (params * monadic action) rather than <tt>MTL</tt> style
--   (monadic action * params).</li>
--   <li>Added Symbols to Drawing.Basis.</li>
--   <li>Added a tube box connector.</li>
--   </ul>
--   
--   v0.5.0 to v0.6.0:
--   
--   <ul>
--   <li>Removed <tt>LocTrace</tt> and <tt>RefTrace</tt> from
--   <tt>Wumpus.Drawing.Basis</tt>, they are superseded by
--   <tt>LocDrawing</tt> in Wumpus-Basic.</li>
--   <li>Remaned path building operations in <tt>RelPathBuilder</tt>.</li>
--   </ul>
@package wumpus-drawing
@version 0.9.0


-- | Version number
module Wumpus.Drawing.VersionNumber

-- | Version number
--   
--   <pre>
--   (0,9,0)
--   </pre>
wumpus_drawing_version :: (Int, Int, Int)


-- | Safe to use "Core 13" fonts that are expected to be present for any
--   PostScript interpreter.
--   
--   Note - regrettably Symbol is not safe to use for SVG.
module Wumpus.Drawing.Text.StandardFontDefs

-- | <a>FontFamily</a> definition for Times-Roman.
times_roman_family :: FontFamily

-- | Times-Roman
times_roman :: FontDef

-- | Times Italic
times_italic :: FontDef

-- | Times Bold
times_bold :: FontDef

-- | Times Bold Italic
times_bold_italic :: FontDef

-- | <a>FontFamily</a> definition for Helvetica.
helvetica_family :: FontFamily

-- | Helvetica regular weight.
helvetica :: FontDef

-- | Helvetica Oblique
helvetica_oblique :: FontDef

-- | Helvetica Bold
helvetica_bold :: FontDef

-- | Helvetica Bold Oblique
helvetica_bold_oblique :: FontDef

-- | <a>FontFamily</a> definition for Courier.
courier_family :: FontFamily

-- | Courier
courier :: FontDef

-- | Courier Oblique
courier_oblique :: FontDef

-- | Courier Bold
courier_bold :: FontDef

-- | Courier Bold Oblique
courier_bold_oblique :: FontDef

-- | Symbol
--   
--   Note - Symbol is intentionally not supported for SVG by some renderers
--   (Firefox). Chrome is fine, but the use of symbol should be still be
--   avoided for web graphics.
symbol :: FontDef


-- | Flexible text type, composable with <tt>pretty-print</tt> style
--   operators.
--   
--   Direction zero (left-to-right) only.
module Wumpus.Drawing.Text.Base.DocTextZero

-- | Doc type.
data GenDoc st u a
type Doc u a = GenDoc () u a
type GenDocGraphic st u = GenDoc st u (UNil u)
type DocGraphic u = Doc u (UNil u)
runGenDoc :: VAlign -> FontFamily -> GenDoc st u a -> GenPosObject st u a

-- | Concatenate two Docs separated with a space.
--   
--   (infixr 6)
(<+>) :: InterpretUnit u => GenDocGraphic st u -> GenDocGraphic st u -> GenDocGraphic st u
blank :: InterpretUnit u => GenDocGraphic st u
space :: InterpretUnit u => GenDocGraphic st u
string :: InterpretUnit u => String -> GenDocGraphic st u
escaped :: InterpretUnit u => EscapedText -> GenDocGraphic st u
embedPosObject :: GenPosObject st u a -> GenDoc st u a
bold :: GenDoc st u a -> GenDoc st u a
italic :: GenDoc st u a -> GenDoc st u a
boldItalic :: GenDoc st u a -> GenDoc st u a
monospace :: InterpretUnit u => EscapedChar -> EscapedText -> GenDocGraphic st u
int :: InterpretUnit u => Int -> GenDocGraphic st u
integer :: InterpretUnit u => Integer -> GenDocGraphic st u

-- | Specialized version of <a>ffloat</a> - the answer is always rendered
--   at "full precision".
float :: (RealFloat a, InterpretUnit u) => a -> GenDocGraphic st u

-- | This is equivalent to <a>showFFloat</a> in the Numeric module.
--   
--   Like <a>showFFloat</a>, the answer is rendered to supplied precision.
--   <tt>Nothing</tt> indicated full precision.
ffloat :: (RealFloat a, InterpretUnit u) => (Maybe Int) -> a -> GenDocGraphic st u
strikethrough :: (Fractional u, InterpretUnit u) => GenDoc st u a -> GenDoc st u a
underline :: (Fractional u, InterpretUnit u) => GenDoc st u a -> GenDoc st u a
highlight :: (Fractional u, InterpretUnit u) => RGBi -> GenDoc st u a -> GenDoc st u a
instance (Monoid a, Fractional u, InterpretUnit u) => Concat (GenDoc st u a)
instance UserStateM (GenDoc st u)
instance DrawingCtxM (GenDoc st u)
instance (Monoid a, InterpretUnit u) => Monoid (GenDoc st u a)
instance Monad (GenDoc st u)
instance Applicative (GenDoc st u)
instance Functor (GenDoc st u)


-- | Common import module for the Writing Direction 0 modules
module Wumpus.Drawing.Text.DirectionZero

-- | Note - this is likely to be moved...
--   
--   Also, reversed argument order would be more convenient as RectAddress
--   always short but String could be long.
textline :: InterpretUnit u => RectAddress -> String -> BoundedLocGraphic u

-- | Note - this is likely to be moved too...
rtextline :: (Real u, Floating u, InterpretUnit u) => Radian -> RectAddress -> String -> BoundedLocGraphic u
multilineText :: (Fractional u, InterpretUnit u) => VAlign -> RectAddress -> String -> BoundedLocGraphic u


-- | Connectors...
module Wumpus.Drawing.Connectors.ConnectorProps

-- | ConnectorProps control the drawing of connectors in Wumpus-Drawing.
--   
--   <pre>
--   conn_src_space     :: Em
--   conn_dst_space     :: Em
--   </pre>
--   
--   Source and destination offsets - these offset the drawing of the
--   connector perpendicular to the direction of line formed between the
--   connector points (a positive offset is drawn above, a negative offset
--   below). The main use of offsets is to draw parallel line connectors.
--   
--   <pre>
--   conn_arc_ang       :: Radian 
--   </pre>
--   
--   Control the <i>bend</i> of an arc connector.
--   
--   <pre>
--   conn_src_arm       :: Em
--   conn_dst_arm       :: Em 
--   </pre>
--   
--   Control the <i>arm</i> length of a jointed connector - arms are the
--   initial segments of the connector.
--   
--   <pre>
--   conn_loop_size     :: Em
--   </pre>
--   
--   Control the <i>height</i> of a loop connector.
--   
--   <pre>
--   conn_box_halfsize  :: Em
--   </pre>
--   
--   Control the size of a connector box. Connector boxes are drawn with
--   the exterior lines projected out from the connector points a halfsize
--   above and below.
data ConnectorProps
ConnectorProps :: !Em -> !Em -> !Radian -> !Em -> !Em -> !Em -> !Em -> ConnectorProps
conn_src_space :: ConnectorProps -> !Em
conn_dst_space :: ConnectorProps -> !Em
conn_arc_ang :: ConnectorProps -> !Radian
conn_src_arm :: ConnectorProps -> !Em
conn_dst_arm :: ConnectorProps -> !Em
conn_loop_size :: ConnectorProps -> !Em
conn_box_halfsize :: ConnectorProps -> !Em

-- | Default connector properties.
--   
--   <pre>
--   conn_src_sep:        0
--   conn_dst_sep:        0
--   conn_arc_ang:        pi / 12
--   conn_src_arm:        1
--   conn_dst_arm:        1
--   conn_loop_size:      2 
--   conn_box_half_size:  2
--   </pre>
--   
--   Arc angle is 15deg - quite shallow.
default_connector_props :: ConnectorProps
connectorSrcSpace :: (DrawingCtxM m, InterpretUnit u) => ConnectorProps -> m u
connectorDstSpace :: (DrawingCtxM m, InterpretUnit u) => ConnectorProps -> m u
connectorArms :: (DrawingCtxM m, InterpretUnit u) => ConnectorProps -> m (u, u)

-- | <i>legs</i> are Arms + spacing.
connectorLegs :: (DrawingCtxM m, InterpretUnit u) => ConnectorProps -> m (u, u)
connectorLoopSize :: (DrawingCtxM m, InterpretUnit u) => ConnectorProps -> m u
connectorBoxHalfSize :: (DrawingCtxM m, InterpretUnit u) => ConnectorProps -> m u
instance Eq ConnectorProps
instance Show ConnectorProps


-- | The X11 'named colours', as rgb [0,1] values
module Wumpus.Drawing.Colour.X11Colours
antique_white1 :: RGBi
antique_white2 :: RGBi
antique_white3 :: RGBi
antique_white4 :: RGBi
aquamarine1 :: RGBi
aquamarine2 :: RGBi
aquamarine3 :: RGBi
aquamarine4 :: RGBi
azure1 :: RGBi
azure2 :: RGBi
azure3 :: RGBi
azure4 :: RGBi
bisque1 :: RGBi
bisque2 :: RGBi
bisque3 :: RGBi
bisque4 :: RGBi
blue1 :: RGBi
blue2 :: RGBi
blue3 :: RGBi
blue4 :: RGBi
brown1 :: RGBi
brown2 :: RGBi
brown3 :: RGBi
brown4 :: RGBi
burlywood1 :: RGBi
burlywood2 :: RGBi
burlywood3 :: RGBi
burlywood4 :: RGBi
cadet_blue1 :: RGBi
cadet_blue2 :: RGBi
cadet_blue3 :: RGBi
cadet_blue4 :: RGBi
chartreuse1 :: RGBi
chartreuse2 :: RGBi
chartreuse3 :: RGBi
chartreuse4 :: RGBi
chocolate1 :: RGBi
chocolate2 :: RGBi
chocolate3 :: RGBi
chocolate4 :: RGBi
coral1 :: RGBi
coral2 :: RGBi
coral3 :: RGBi
coral4 :: RGBi
cornsilk1 :: RGBi
cornsilk2 :: RGBi
cornsilk3 :: RGBi
cornsilk4 :: RGBi
cyan1 :: RGBi
cyan2 :: RGBi
cyan3 :: RGBi
cyan4 :: RGBi
dark_goldenrod1 :: RGBi
dark_goldenrod2 :: RGBi
dark_goldenrod3 :: RGBi
dark_goldenrod4 :: RGBi
dark_olive_green1 :: RGBi
dark_olive_green2 :: RGBi
dark_olive_green3 :: RGBi
dark_olive_green4 :: RGBi
dark_orange1 :: RGBi
dark_orange2 :: RGBi
dark_orange3 :: RGBi
dark_orange4 :: RGBi
dark_orchid1 :: RGBi
dark_orchid2 :: RGBi
dark_orchid3 :: RGBi
dark_orchid4 :: RGBi
dark_sea_green1 :: RGBi
dark_sea_green2 :: RGBi
dark_sea_green3 :: RGBi
dark_sea_green4 :: RGBi
dark_slate_gray1 :: RGBi
dark_slate_gray2 :: RGBi
dark_slate_gray3 :: RGBi
dark_slate_gray4 :: RGBi
deep_pink1 :: RGBi
deep_pink2 :: RGBi
deep_pink3 :: RGBi
deep_pink4 :: RGBi
deep_sky_blue1 :: RGBi
deep_sky_blue2 :: RGBi
deep_sky_blue3 :: RGBi
deep_sky_blue4 :: RGBi
dodger_blue1 :: RGBi
dodger_blue2 :: RGBi
dodger_blue3 :: RGBi
dodger_blue4 :: RGBi
firebrick1 :: RGBi
firebrick2 :: RGBi
firebrick3 :: RGBi
firebrick4 :: RGBi
gold1 :: RGBi
gold2 :: RGBi
gold3 :: RGBi
gold4 :: RGBi
goldenrod1 :: RGBi
goldenrod2 :: RGBi
goldenrod3 :: RGBi
goldenrod4 :: RGBi
green1 :: RGBi
green2 :: RGBi
green3 :: RGBi
green4 :: RGBi
honeydew1 :: RGBi
honeydew2 :: RGBi
honeydew3 :: RGBi
honeydew4 :: RGBi
hot_pink1 :: RGBi
hot_pink2 :: RGBi
hot_pink3 :: RGBi
hot_pink4 :: RGBi
indian_red1 :: RGBi
indian_red2 :: RGBi
indian_red3 :: RGBi
indian_red4 :: RGBi
ivory1 :: RGBi
ivory2 :: RGBi
ivory3 :: RGBi
ivory4 :: RGBi
khaki1 :: RGBi
khaki2 :: RGBi
khaki3 :: RGBi
khaki4 :: RGBi
lavender_blush1 :: RGBi
lavender_blush2 :: RGBi
lavender_blush3 :: RGBi
lavender_blush4 :: RGBi
lemon_chiffon1 :: RGBi
lemon_chiffon2 :: RGBi
lemon_chiffon3 :: RGBi
lemon_chiffon4 :: RGBi
light_blue1 :: RGBi
light_blue2 :: RGBi
light_blue3 :: RGBi
light_blue4 :: RGBi
light_cyan1 :: RGBi
light_cyan2 :: RGBi
light_cyan3 :: RGBi
light_cyan4 :: RGBi
light_goldenrod1 :: RGBi
light_goldenrod2 :: RGBi
light_goldenrod3 :: RGBi
light_goldenrod4 :: RGBi
light_pink1 :: RGBi
light_pink2 :: RGBi
light_pink3 :: RGBi
light_pink4 :: RGBi
light_salmon1 :: RGBi
light_salmon2 :: RGBi
light_salmon3 :: RGBi
light_salmon4 :: RGBi
light_sky_blue1 :: RGBi
light_sky_blue2 :: RGBi
light_sky_blue3 :: RGBi
light_sky_blue4 :: RGBi
light_steel_blue1 :: RGBi
light_steel_blue2 :: RGBi
light_steel_blue3 :: RGBi
light_steel_blue4 :: RGBi
light_yellow1 :: RGBi
light_yellow2 :: RGBi
light_yellow3 :: RGBi
light_yellow4 :: RGBi
magenta1 :: RGBi
magenta2 :: RGBi
magenta3 :: RGBi
magenta4 :: RGBi
maroon1 :: RGBi
maroon2 :: RGBi
maroon3 :: RGBi
maroon4 :: RGBi
medium_orchid1 :: RGBi
medium_orchid2 :: RGBi
medium_orchid3 :: RGBi
medium_orchid4 :: RGBi
medium_purple1 :: RGBi
medium_purple2 :: RGBi
medium_purple3 :: RGBi
medium_purple4 :: RGBi
misty_rose1 :: RGBi
misty_rose2 :: RGBi
misty_rose3 :: RGBi
misty_rose4 :: RGBi
navajo_white1 :: RGBi
navajo_white2 :: RGBi
navajo_white3 :: RGBi
navajo_white4 :: RGBi
olive_drab1 :: RGBi
olive_drab2 :: RGBi
olive_drab3 :: RGBi
olive_drab4 :: RGBi
orange1 :: RGBi
orange2 :: RGBi
orange3 :: RGBi
orange4 :: RGBi
orange_red1 :: RGBi
orange_red2 :: RGBi
orange_red3 :: RGBi
orange_red4 :: RGBi
orchid1 :: RGBi
orchid2 :: RGBi
orchid3 :: RGBi
orchid4 :: RGBi
pale_green1 :: RGBi
pale_green2 :: RGBi
pale_green3 :: RGBi
pale_green4 :: RGBi
pale_turquoise1 :: RGBi
pale_turquoise2 :: RGBi
pale_turquoise3 :: RGBi
pale_turquoise4 :: RGBi
pale_violet_red1 :: RGBi
pale_violet_red2 :: RGBi
pale_violet_red3 :: RGBi
pale_violet_red4 :: RGBi
peach_puff1 :: RGBi
peach_puff2 :: RGBi
peach_puff3 :: RGBi
peach_puff4 :: RGBi
pink1 :: RGBi
pink2 :: RGBi
pink3 :: RGBi
pink4 :: RGBi
plum1 :: RGBi
plum2 :: RGBi
plum3 :: RGBi
plum4 :: RGBi
purple1 :: RGBi
purple2 :: RGBi
purple3 :: RGBi
purple4 :: RGBi
red1 :: RGBi
red2 :: RGBi
red3 :: RGBi
red4 :: RGBi
rosy_brown1 :: RGBi
rosy_brown2 :: RGBi
rosy_brown3 :: RGBi
rosy_brown4 :: RGBi
royal_blue1 :: RGBi
royal_blue2 :: RGBi
royal_blue3 :: RGBi
royal_blue4 :: RGBi
salmon1 :: RGBi
salmon2 :: RGBi
salmon3 :: RGBi
salmon4 :: RGBi
sea_green1 :: RGBi
sea_green2 :: RGBi
sea_green3 :: RGBi
sea_green4 :: RGBi
seashell1 :: RGBi
seashell2 :: RGBi
seashell3 :: RGBi
seashell4 :: RGBi
sienna1 :: RGBi
sienna2 :: RGBi
sienna3 :: RGBi
sienna4 :: RGBi
sky_blue1 :: RGBi
sky_blue2 :: RGBi
sky_blue3 :: RGBi
sky_blue4 :: RGBi
slate_blue1 :: RGBi
slate_blue2 :: RGBi
slate_blue3 :: RGBi
slate_blue4 :: RGBi
slate_gray1 :: RGBi
slate_gray2 :: RGBi
slate_gray3 :: RGBi
slate_gray4 :: RGBi
snow1 :: RGBi
snow2 :: RGBi
snow3 :: RGBi
snow4 :: RGBi
spring_green1 :: RGBi
spring_green2 :: RGBi
spring_green3 :: RGBi
spring_green4 :: RGBi
steel_blue1 :: RGBi
steel_blue2 :: RGBi
steel_blue3 :: RGBi
steel_blue4 :: RGBi
tan1 :: RGBi
tan2 :: RGBi
tan3 :: RGBi
tan4 :: RGBi
thistle1 :: RGBi
thistle2 :: RGBi
thistle3 :: RGBi
thistle4 :: RGBi
tomato1 :: RGBi
tomato2 :: RGBi
tomato3 :: RGBi
tomato4 :: RGBi
turquoise1 :: RGBi
turquoise2 :: RGBi
turquoise3 :: RGBi
turquoise4 :: RGBi
violet_red1 :: RGBi
violet_red2 :: RGBi
violet_red3 :: RGBi
violet_red4 :: RGBi
wheat1 :: RGBi
wheat2 :: RGBi
wheat3 :: RGBi
wheat4 :: RGBi
yellow1 :: RGBi
yellow2 :: RGBi
yellow3 :: RGBi
yellow4 :: RGBi


-- | The SVG 'named colours', as rgb [0,1] values
module Wumpus.Drawing.Colour.SVGColours
alice_blue :: RGBi
antique_white :: RGBi
aqua :: RGBi
aquamarine :: RGBi
azure :: RGBi
beige :: RGBi
bisque :: RGBi
black :: RGBi
blanched_almond :: RGBi
blue :: RGBi
blue_violet :: RGBi
brown :: RGBi
burlywood :: RGBi
cadet_blue :: RGBi
chartreuse :: RGBi
chocolate :: RGBi
coral :: RGBi
cornflower_blue :: RGBi
cornsilk :: RGBi
crimson :: RGBi
cyan :: RGBi
dark_blue :: RGBi
dark_cyan :: RGBi
dark_goldenrod :: RGBi
dark_gray :: RGBi
dark_green :: RGBi
dark_grey :: RGBi
dark_khaki :: RGBi
dark_magenta :: RGBi
dark_olive_green :: RGBi
dark_orange :: RGBi
dark_orchid :: RGBi
dark_red :: RGBi
dark_salmon :: RGBi
dark_sea_green :: RGBi
dark_slate_blue :: RGBi
dark_slate_gray :: RGBi
dark_slate_grey :: RGBi
dark_turquoise :: RGBi
dark_violet :: RGBi
deep_pink :: RGBi
deep_sky_blue :: RGBi
dim_gray :: RGBi
dim_grey :: RGBi
dodger_blue :: RGBi
firebrick :: RGBi
floral_white :: RGBi
forest_green :: RGBi
fuchsia :: RGBi
gainsboro :: RGBi
ghost_white :: RGBi
gold :: RGBi
goldenrod :: RGBi
gray :: RGBi
grey :: RGBi
green :: RGBi
green_yellow :: RGBi
honeydew :: RGBi
hot_pink :: RGBi
indian_red :: RGBi
indigo :: RGBi
ivory :: RGBi
khaki :: RGBi
lavender :: RGBi
lavender_blush :: RGBi
lawn_green :: RGBi
lemon_chiffon :: RGBi
light_blue :: RGBi
light_coral :: RGBi
light_cyan :: RGBi
light_goldenrod_yellow :: RGBi
light_gray :: RGBi
light_green :: RGBi
light_grey :: RGBi
light_pink :: RGBi
light_salmon :: RGBi
light_sea_green :: RGBi
light_sky_blue :: RGBi
light_slate_gray :: RGBi
light_slate_grey :: RGBi
light_steel_blue :: RGBi
light_yellow :: RGBi
lime :: RGBi
lime_green :: RGBi
linen :: RGBi
magenta :: RGBi
maroon :: RGBi
medium_aquamarine :: RGBi
medium_blue :: RGBi
medium_orchid :: RGBi
medium_purple :: RGBi
medium_sea_green :: RGBi
medium_slate_blue :: RGBi
medium_spring_green :: RGBi
medium_turquoise :: RGBi
medium_violet_red :: RGBi
midnight_blue :: RGBi
mintcream :: RGBi
mistyrose :: RGBi
moccasin :: RGBi
navajo_white :: RGBi
navy :: RGBi
old_lace :: RGBi
olive :: RGBi
olive_drab :: RGBi
orange :: RGBi
orange_red :: RGBi
orchid :: RGBi
pale_goldenrod :: RGBi
pale_green :: RGBi
pale_turquoise :: RGBi
pale_violet_red :: RGBi
papaya_whip :: RGBi
peach_puff :: RGBi
peru :: RGBi
pink :: RGBi
plum :: RGBi
powder_blue :: RGBi
purple :: RGBi
red :: RGBi
rosy_brown :: RGBi
royal_blue :: RGBi
saddle_brown :: RGBi
salmon :: RGBi
sandy_brown :: RGBi
sea_green :: RGBi
seashell :: RGBi
sienna :: RGBi
silver :: RGBi
sky_blue :: RGBi
slate_blue :: RGBi
slate_gray :: RGBi
slate_grey :: RGBi
snow :: RGBi
spring_green :: RGBi
steel_blue :: RGBi
tan :: RGBi
teal :: RGBi
thistle :: RGBi
tomato :: RGBi
turquoise :: RGBi
violet :: RGBi
wheat :: RGBi
white :: RGBi
whitesmoke :: RGBi
yellow :: RGBi
yellow_green :: RGBi


module Wumpus.Drawing.Basis.InclineTrails
incline_circle :: (Real u, Floating u) => Vec2 u -> AnaTrail u
incline_ellipse :: (Real u, Floating u) => u -> Vec2 u -> AnaTrail u
incline_square :: (Real u, Floating u) => Vec2 u -> AnaTrail u
incline_rect :: (Real u, Floating u) => u -> Vec2 u -> AnaTrail u
incline_diamond :: (Real u, Floating u) => u -> Vec2 u -> AnaTrail u

-- | Note - vector represents midpoint of the baseline to the tip. Angle is
--   the ang of the tip.
--   
--   This trail is primarily for drawing arrowheads.
incline_triangle :: (Real u, Floating u) => Radian -> Vec2 u -> AnaTrail u

-- | Note - vector represents midpoint of the baseline to the tip. Angle is
--   the ang of the tip.
--   
--   This trail is primarily for drawing arrowheads. The resulting path is
--   <i>open</i>.
incline_barb :: (Real u, Floating u) => Radian -> Vec2 u -> AnaTrail u

-- | <tt>v1</tt> is the <i>interior</i> vector.
incline_tube :: (Real u, Floating u) => u -> Vec2 u -> AnaTrail u
incline_chamf_rect :: (Real u, Floating u) => u -> Vec2 u -> AnaTrail u

-- | Diagonal-horizontal trail.
--   
--   <pre>
--     --@
--    /
--   o
--   </pre>
trail_diagh :: (Real u, Floating u) => u -> Vec2 u -> CatTrail u
trail_diagv :: (Real u, Floating u) => u -> Vec2 u -> CatTrail u
trail_hdiag :: (Real u, Floating u) => u -> Vec2 u -> CatTrail u
trail_vdiag :: (Real u, Floating u) => u -> Vec2 u -> CatTrail u

-- | Horizontal-diagonal-horizontal trail.
--   
--   <pre>
--       --@
--      /
--   o--
--   </pre>
trail_hdiagh :: (Real u, Floating u) => u -> u -> Vec2 u -> CatTrail u
trail_vdiagv :: (Real u, Floating u) => u -> u -> Vec2 u -> CatTrail u

-- | Uniform leg size.
trail_perp_bar :: (Real u, Floating u) => ClockDirection -> u -> Vec2 u -> CatTrail u

-- | Bar connector - independent leg size, legs perpendicular.
--   
--   <pre>
--   o    @ 
--   |    |
--   '----'  
--   </pre>
--   
--   The bar is drawn <i>below</i> the points.
trail_perp_bar2 :: (Real u, Floating u) => ClockDirection -> u -> u -> Vec2 u -> CatTrail u

-- | Independent leg size.
trail_vflam :: (Real u, Floating u) => ClockDirection -> u -> u -> Vec2 u -> CatTrail u

-- | Height is minimum leg height. Ortho bar is horizontal.
trail_ortho_hbar :: (Real u, Floating u) => ClockDirection -> u -> Vec2 u -> CatTrail u

-- | Width is minimum leg width. Ortho bar is vertical.
trail_ortho_vbar :: (Real u, Floating u) => ClockDirection -> u -> Vec2 u -> CatTrail u
trail_hright :: Num u => Vec2 u -> CatTrail u
trail_vright :: Num u => Vec2 u -> CatTrail u
trail_hrr :: (Floating u, Ord u) => u -> Vec2 u -> CatTrail u
trail_vrr :: (Floating u, Ord u) => u -> Vec2 u -> CatTrail u
trail_rrh :: (Floating u, Ord u) => u -> Vec2 u -> CatTrail u
trail_rrv :: (Floating u, Ord u) => u -> Vec2 u -> CatTrail u
trail_rect_loop :: (Real u, Floating u) => ClockDirection -> u -> u -> u -> Vec2 u -> CatTrail u

-- | <a>triCurve</a> formulated with a <i>base vector</i> rather than
--   base-width and angle of inclination.
vtriCurve :: (Real u, Floating u) => ClockDirection -> u -> Vec2 u -> CatTrail u

-- | <a>rectCurve</a> formulated with a <i>base vector</i> rather than
--   base-width and angle of inclination.
vrectCurve :: (Real u, Floating u) => ClockDirection -> u -> Vec2 u -> CatTrail u

-- | <a>trapCurve</a> formulated with a <i>base vector</i> rather than
--   base-width and angle of inclination.
vtrapCurve :: (Real u, Floating u) => ClockDirection -> u -> Radian -> Vec2 u -> CatTrail u

-- | <a>bowCurve</a> formulated with a <i>base vector</i> rather than
--   base-width and angle of inclination.
vbowCurve :: (Real u, Floating u) => ClockDirection -> u -> Vec2 u -> CatTrail u

-- | <a>wedgeCurve</a> formulated with a <i>base vector</i> rather than
--   base-width and angle of inclination.
vwedgeCurve :: (Real u, Floating u) => ClockDirection -> u -> Vec2 u -> CatTrail u


module Wumpus.Drawing.Basis.ShapeTrails
circle_trail :: (Real u, Floating u) => u -> AnaTrail u
rcircle_trail :: (Real u, Floating u) => u -> Radian -> AnaTrail u
ellipse_trail :: (Real u, Floating u) => u -> u -> AnaTrail u
rellipse_trail :: (Real u, Floating u) => u -> u -> Radian -> AnaTrail u
rectangle_trail :: (Real u, Floating u) => u -> u -> AnaTrail u
rrectangle_trail :: (Real u, Floating u) => u -> u -> Radian -> AnaTrail u
diamond_trail :: (Real u, Floating u) => u -> u -> AnaTrail u
rdiamond_trail :: (Real u, Floating u) => u -> u -> Radian -> AnaTrail u
isosceles_triangle_trail :: (Real u, Floating u) => u -> u -> AnaTrail u

-- | Drawn at the centroid (1/3 * h).
risosceles_triangle_trail :: (Real u, Floating u) => u -> u -> Radian -> AnaTrail u
semicircle_trail :: (Real u, Floating u) => u -> AnaTrail u
rsemicircle_trail :: (Real u, Floating u) => u -> Radian -> AnaTrail u
semiellipse_trail :: (Real u, Floating u) => u -> u -> AnaTrail u
rsemiellipse_trail :: (Real u, Floating u) => u -> u -> Radian -> AnaTrail u

-- | Note - bottom left angle must be smaller than 180deg, otherwise a
--   runtime error is thrown.
parallelogram_trail :: Floating u => u -> u -> Radian -> AnaTrail u

-- | Note - bottom left angle must be smaller than 180deg, otherwise a
--   runtime error is thrown.
rparallelogram_trail :: Floating u => u -> u -> Radian -> Radian -> AnaTrail u

-- | Note - bottom left angle must be smaller than 180deg, otherwise a
--   runtime error is thrown.
--   
--   Also, no checking is perfomed on the relation between height and
--   bottom_left ang. Out of range values will draw "twisted" trapezoids.
trapezium_trail :: Floating u => u -> u -> Radian -> AnaTrail u

-- | Note - bottom left angle must be smaller than 180deg, otherwise a
--   runtime error is thrown.
rtrapezium_trail :: Floating u => u -> u -> Radian -> Radian -> AnaTrail u


-- | Box connectors
module Wumpus.Drawing.Connectors.BoxConnectors

-- | The type of BoxConnectors - a query from start and end point to a
--   Path.
--   
--   Note - unlike a <tt>Connector</tt>, a BoxConnnector is expected to be
--   closed, then filled, stroked or bordered.
type ConnectorBox u = ConnectorGraphic u
newtype ConnectorBoxSpec u
ConnectorBoxSpec :: (ConnectorProps -> ConnectorBox u) -> ConnectorBoxSpec u
getConnectorBoxSpec :: ConnectorBoxSpec u -> ConnectorProps -> ConnectorBox u
renderConnectorBoxSpec :: (Real u, Floating u, InterpretUnit u) => ConnectorProps -> ConnectorBoxSpec u -> ConnectorBox u

-- | Draw a stroked, rectangular box around the connector points.
--   
--   The rectangle will be inclined to the line.
conn_box :: (Real u, Floating u, InterpretUnit u) => ConnectorBoxSpec u

-- | Draw a stroked, tube around the connector points.
--   
--   The tube will be inclined to the line.
conn_tube :: (Real u, Floating u, InterpretUnit u) => ConnectorBoxSpec u

-- | Draw a stroked, chamfered box around the connector points.
--   
--   The tube will be inclined to the line.
conn_chamf_box :: (Real u, Floating u, InterpretUnit u) => ConnectorBoxSpec u


-- | Alternative to the <tt>DrawingPrimitives</tt> module in Wumpus-Basic.
--   
--   The drawing primitives here are either slightly higher level or less
--   general (more quirky).
--   
--   This module is expected to be imported qualified - other modules (e.g.
--   shapes and paths) are likely to export conflicting names.
--   
--   ** WARNING ** - much of this module is probably obsolete (except
--   wedge).
module Wumpus.Drawing.Basis.DrawingPrimitives

-- | Draw a horizontal line.
horizontalLine :: InterpretUnit u => u -> LocGraphic u

-- | Draw a vertical line.
verticalLine :: InterpretUnit u => u -> LocGraphic u

-- | <tt>pivotLine</tt> : <tt> left_length * right_length * incline -&gt;
--   LocGraphic </tt>
--   
--   Draw a <i>pivot</i> line. The start point is a pivot along the line,
--   not the end. The left and right distances are the extension of the
--   line from the pivot.
pivotLine :: (Floating u, InterpretUnit u) => u -> u -> Radian -> LocGraphic u

-- | Draw a rectangle, start point is bottom left.
blRectangle :: InterpretUnit u => DrawMode -> u -> u -> LocGraphic u

-- | Draw a rectangle, start point is bottom left.
ctrRectangle :: (Fractional u, InterpretUnit u) => DrawMode -> u -> u -> LocGraphic u

-- | wedge : mode * radius * apex_angle
--   
--   Wedge is drawn at the apex.
wedge :: (Real u, Floating u, InterpretUnit u) => DrawMode -> u -> Radian -> LocThetaGraphic u


-- | Symbols - many symbols expected to be re-defined as Dots or character
--   size PosObjects for DocText.
--   
--   ** WARNING ** - naming conventention is to be determined...
module Wumpus.Drawing.Basis.Symbols

-- | Stroked circle.
--   
--   Start pos - center.
scircle :: InterpretUnit u => u -> LocGraphic u

-- | Filled circle.
--   
--   Start pos - center.
fcircle :: InterpretUnit u => u -> LocGraphic u

-- | Filled-stroked circle.
--   
--   Start pos - center.
fscircle :: InterpretUnit u => u -> LocGraphic u

-- | Stroked square.
--   
--   Start pos - center.
ssquare :: (Fractional u, InterpretUnit u) => u -> LocGraphic u

-- | Filled square.
--   
--   Start pos - center.
fsquare :: (Fractional u, InterpretUnit u) => u -> LocGraphic u

-- | Filled-stroked square.
--   
--   Start pos - center.
fssquare :: (Fractional u, InterpretUnit u) => u -> LocGraphic u

-- | Stroked left slice (wedge).
--   
--   Start pos - ....
sleft_slice :: (Real u, Floating u, InterpretUnit u) => u -> LocGraphic u

-- | Filled left slice (wedge).
--   
--   Start pos - ....
fleft_slice :: (Real u, Floating u, InterpretUnit u) => u -> LocGraphic u

-- | Filled-stroked left slice (wedge).
--   
--   Start pos - ....
fsleft_slice :: (Real u, Floating u, InterpretUnit u) => u -> LocGraphic u

-- | Stroked right slice (wedge).
--   
--   Start pos - ....
sright_slice :: (Real u, Floating u, InterpretUnit u) => u -> LocGraphic u

-- | Filled right slice (wedge).
--   
--   Start pos - ....
fright_slice :: (Real u, Floating u, InterpretUnit u) => u -> LocGraphic u

-- | Filled-stroked right slice (wedge).
--   
--   Start pos - ....
fsright_slice :: (Real u, Floating u, InterpretUnit u) => u -> LocGraphic u

-- | Stroked left triangle.
--   
--   Start pos - ....
sleft_triangle :: (Real u, Floating u, InterpretUnit u) => u -> LocGraphic u

-- | Filled left triangle.
--   
--   Start pos - ....
fleft_triangle :: (Real u, Floating u, InterpretUnit u) => u -> LocGraphic u

-- | Filled-stroked left triangle.
--   
--   Start pos - ....
fsleft_triangle :: (Real u, Floating u, InterpretUnit u) => u -> LocGraphic u

-- | Stroked right triangle.
--   
--   Start pos - ....
sright_triangle :: (Real u, Floating u, InterpretUnit u) => u -> LocGraphic u

-- | Filled right triangle.
--   
--   Start pos - ....
fright_triangle :: (Real u, Floating u, InterpretUnit u) => u -> LocGraphic u

-- | Filled-stroked right triangle.
--   
--   Start pos - ....
fsright_triangle :: (Real u, Floating u, InterpretUnit u) => u -> LocGraphic u

-- | Note this looks horrible for chars with descenders.
ochar :: (Fractional u, InterpretUnit u) => EscapedChar -> LocGraphic u
ocharUpright :: (Fractional u, InterpretUnit u) => EscapedChar -> LocGraphic u
ocharDescender :: (Fractional u, InterpretUnit u) => EscapedChar -> LocGraphic u
ocurrency :: (Floating u, InterpretUnit u) => u -> LocGraphic u
empty_box :: (Fractional u, InterpretUnit u) => u -> LocGraphic u
hbar :: (Fractional u, InterpretUnit u) => u -> LocGraphic u
vbar :: (Fractional u, InterpretUnit u) => u -> LocGraphic u
dbl_hbar :: (Fractional u, InterpretUnit u) => u -> LocGraphic u
dbl_vbar :: (Fractional u, InterpretUnit u) => u -> LocGraphic u


-- | Simple dots - no anchor handles.
--   
--   Use these where you just want to draw Dots, and do not need connectors
--   between them.
--   
--   The text and char marks need loaded glyph metrics for proper
--   centering.
--   
--   ** WARNING ** - names are expected to change - filled and
--   background-filled marks need a naming convention.
module Wumpus.Drawing.Dots.SimpleDots

-- | MarkUnit is a contextual unit like <a>Em</a> and <a>En</a>.
--   
--   It is 3/4 of the current font size.
data MarkSize

-- | Filled disk - radius 0.25 MarkSize.
smallDisk :: InterpretUnit u => LocGraphic u

-- | Filled disk - radius 1.0 MarkSize.
largeDisk :: InterpretUnit u => LocGraphic u

-- | Stroked disk (circle) - radius 0.25 MarkSize.
smallCirc :: InterpretUnit u => LocGraphic u

-- | Stroked disk (circle) - radius 1.0 MarkSize.
largeCirc :: InterpretUnit u => LocGraphic u
dotNone :: InterpretUnit u => LocGraphic u
dotChar :: (Real u, Floating u, InterpretUnit u) => Char -> LocGraphic u
dotText :: (Real u, Floating u, InterpretUnit u) => String -> LocGraphic u
dotEscChar :: (Real u, Floating u, InterpretUnit u) => EscapedChar -> LocGraphic u
dotEscText :: (Real u, Floating u, InterpretUnit u) => EscapedText -> LocGraphic u
dotHBar :: (Fractional u, InterpretUnit u) => LocGraphic u
dotVBar :: (Fractional u, InterpretUnit u) => LocGraphic u
dotX :: (Fractional u, InterpretUnit u) => LocGraphic u
dotPlus :: (Fractional u, InterpretUnit u) => LocGraphic u
dotCross :: (Floating u, InterpretUnit u) => LocGraphic u
dotDiamond :: (Fractional u, InterpretUnit u) => LocGraphic u
dotFDiamond :: (Fractional u, InterpretUnit u) => LocGraphic u
dotBDiamond :: (Fractional u, InterpretUnit u) => LocGraphic u

-- | Note disk is filled.
dotDisk :: (Fractional u, InterpretUnit u) => LocGraphic u
dotSquare :: (Fractional u, InterpretUnit u) => LocGraphic u
dotCircle :: (Fractional u, InterpretUnit u) => LocGraphic u
dotPentagon :: (Floating u, InterpretUnit u) => LocGraphic u
dotStar :: (Floating u, Ord u, InterpretUnit u, Tolerance u) => LocGraphic u
dotAsterisk :: (Floating u, InterpretUnit u) => LocGraphic u
dotOPlus :: (Fractional u, InterpretUnit u) => LocGraphic u
dotOCross :: (Floating u, InterpretUnit u) => LocGraphic u
dotFOCross :: (Floating u, InterpretUnit u) => LocGraphic u
dotTriangle :: (Floating u, InterpretUnit u) => LocGraphic u
instance Eq MarkSize
instance Ord MarkSize
instance Num MarkSize
instance Floating MarkSize
instance Fractional MarkSize
instance Real MarkSize
instance RealFrac MarkSize
instance RealFloat MarkSize
instance Tolerance MarkSize
instance InterpretUnit MarkSize
instance Show MarkSize


-- | Symbols - redefined Basis.Symbols.
module Wumpus.Drawing.Text.DocSymbols
ocircle :: (Fractional u, InterpretUnit u) => GenDocGraphic st u
small_ocircle :: (Fractional u, InterpretUnit u) => GenDocGraphic st u
empty_box :: (Fractional u, InterpretUnit u) => GenDocGraphic st u
left_slice :: (Real u, Floating u, InterpretUnit u) => GenDocGraphic st u
right_slice :: (Real u, Floating u, InterpretUnit u) => GenDocGraphic st u


-- | Drawing grids
module Wumpus.Drawing.Extras.Grids
type GridContextF = GridProps -> GridProps
grid :: (Fractional u, InterpretUnit u) => GridContextF -> Int -> Int -> LocGraphic u
standard_grid :: GridContextF
dotted_major_grid :: GridContextF
grid_major_colour :: RGBi -> GridContextF
grid_major_line_width :: Double -> GridContextF
grid_major_dotnum :: Int -> GridContextF
grid_minor_subdivisions :: Int -> GridContextF
grid_minor_colour :: RGBi -> GridContextF
grid_minor_line_width :: Double -> GridContextF
grid_minor_dotnum :: Int -> GridContextF
grid_point_size :: FontSize -> GridContextF
grid_label_colour :: RGBi -> GridContextF


-- | Misc geometric operations.
module Wumpus.Drawing.Basis.Geometry

-- | <a>midpoint</a> : <tt> start_point * end_point -&gt; Midpoint </tt>
--   
--   Mid-point on the line formed between the two supplied points.
midpoint :: Fractional u => Point2 u -> Point2 u -> Point2 u

-- | Affine combination...
affineComb :: Real u => u -> Point2 u -> Point2 u -> Point2 u


-- | Datatype for cubic Bezier curve.
module Wumpus.Drawing.Basis.BezierCurve

-- | A Strict cubic Bezier curve.
data BezierCurve u
BezierCurve :: !Point2 u -> !Point2 u -> !Point2 u -> !Point2 u -> BezierCurve u
vbezierCurve :: Num u => Vec2 u -> Vec2 u -> Vec2 u -> Point2 u -> BezierCurve u

-- | Curve subdivision via de Casteljau's algorithm.
subdivide :: Fractional u => BezierCurve u -> (BezierCurve u, BezierCurve u)

-- | subdivide with an affine weight along the line...
subdividet :: Real u => u -> BezierCurve u -> (BezierCurve u, BezierCurve u)

-- | <a>bezierLength</a> : <tt> start_point * control_1 * control_2 *
--   end_point -&gt; Length </tt>
--   
--   Find the length of a Bezier curve. The result is an approximation,
--   with the <i>tolerance</i> is 0.1 of a point. This seems good enough
--   for drawing (potentially the tolerance could be larger still).
--   
--   The result is found through repeated subdivision so the calculation is
--   potentially costly.
bezierLength :: (Floating u, Ord u, Tolerance u) => BezierCurve u -> u
instance (Ord u, Tolerance u) => Eq (BezierCurve u)
instance (Ord u, Tolerance u) => Ord (BezierCurve u)
instance Show u => Show (BezierCurve u)


-- | Absolute path type - this should be more amenable for building complex
--   drawings than the PrimPath type in Wumpus-Core.
--   
--   Note - there is no concatenation (i.e. no Monoid instance), this is
--   because concatenating ** absolute ** paths has no obvious
--   interpretation - draw a join between the paths, move the second path
--   to start where the first ends...
--   
--   Use <tt>CatTrail</tt> from Wumpus-Basic if you need a relative-path
--   like object that supports concatenation, then convert it in a final
--   step to an <tt>AbsPath</tt>.
module Wumpus.Drawing.Paths.Base

-- | Absolute path data type.
data AbsPath u
type DAbsPath = AbsPath Double

-- | Create the empty path.
--   
--   Note - an absolute path needs <i>locating</i> and cannot be built
--   without a start point. Figuratively, the empty path is a path from the
--   start point to the end point.
--   
--   Thus AbsPath operates as a semigroup but not a monoid.
emptyPath :: Floating u => Point2 u -> AbsPath u

-- | Create an absolute path as a straight line between the supplied
--   points.
line1 :: Floating u => Point2 u -> Point2 u -> AbsPath u

-- | Create an absolute path from a single cubic Bezier curve.
curve1 :: (Floating u, Ord u, Tolerance u) => Point2 u -> Point2 u -> Point2 u -> Point2 u -> AbsPath u

-- | <a>vertexPath</a> throws a runtime error if the supplied list is
--   empty.
vertexPath :: (Floating u, Ord u, Tolerance u) => [Point2 u] -> AbsPath u

-- | <a>curvePath</a> consumes 4 points from the list on the intial step
--   (start, control1, control2, end) then steps through the list taking 3
--   points at a time thereafter (control1,control2, end). Leftover points
--   are discarded.
--   
--   <a>curvePath</a> throws a runtime error if the supplied list is has
--   less than 4 elements (start, control1, control2, end).
curvePath :: (Floating u, Ord u, Tolerance u) => [Point2 u] -> AbsPath u

-- | This is not an arc...
controlCurve :: (Floating u, Ord u, Tolerance u) => Point2 u -> Radian -> Radian -> Point2 u -> AbsPath u
vectorPath :: (Floating u, Ord u, Tolerance u) => [Vec2 u] -> Point2 u -> AbsPath u
vectorPathTheta :: (Real u, Floating u, Tolerance u) => [Vec2 u] -> Radian -> Point2 u -> AbsPath u
anaTrailPath :: (Floating u, Ord u, Tolerance u) => Point2 u -> AnaTrail u -> AbsPath u
catTrailPath :: (Floating u, Ord u, Tolerance u) => Point2 u -> CatTrail u -> AbsPath u

-- | Is the path empty?
null :: AbsPath u -> Bool

-- | Length of the Path.
--   
--   Length is the length of the path as it is drawn, it is not a count of
--   the number or path segments.
--   
--   Length is cached so this operation is cheap - though this puts a tax
--   on the build operations.
length :: Num u => AbsPath u -> u

-- | Extend the path with a straight line segment from the end-point
--   defined by the supplied vector.
--   
--   <pre>
--   infixl 5 `snocLine`
--   </pre>
snocLine :: Floating u => AbsPath u -> Vec2 u -> AbsPath u

-- | Extend the path with a straight line segment from the end-point to the
--   supplied point.
--   
--   <pre>
--   infixl 5 `snocLineTo`
--   </pre>
snocLineTo :: Floating u => AbsPath u -> Point2 u -> AbsPath u

-- | Extend the path from the end-point with a Bezier curve segment formed
--   by the supplied points.
--   
--   <pre>
--   infixl 5 `snocCurve`
--   </pre>
snocCurve :: (Floating u, Ord u, Tolerance u) => AbsPath u -> (Vec2 u, Vec2 u, Vec2 u) -> AbsPath u

-- | Extend the path from the end-point with a Bezier curve segment formed
--   by the supplied points.
--   
--   <pre>
--   infixl 5 `snocCurveTo`
--   </pre>
snocCurveTo :: (Floating u, Ord u, Tolerance u) => AbsPath u -> (Point2 u, Point2 u, Point2 u) -> AbsPath u

-- | Turn a Path into an ordinary PrimPath.
--   
--   Assumes path is properly formed - i.e. end point of one segment is the
--   same point as the start point of the next segment.
toPrimPath :: InterpretUnit u => AbsPath u -> Query u PrimPath
renderPath :: InterpretUnit u => PathMode -> AbsPath u -> Image u (AbsPath u)
renderPath_ :: InterpretUnit u => PathMode -> AbsPath u -> Graphic u

-- | <tt>sortenPath</tt> : <tt> left_dist * right_dist * path -&gt; Path
--   </tt>
shortenPath :: (Real u, Floating u) => u -> u -> AbsPath u -> AbsPath u

-- | Note - shortening a line from the left by greater-than-or-equal its
--   length is operationally equivalent to making a zero-length line at the
--   end point.
shortenL :: (Real u, Floating u) => u -> AbsPath u -> AbsPath u

-- | Note - shortening a line from the right by greater-than-or-equal its
--   length is operationally equivalent to making a zero-length line at the
--   start point.
shortenR :: (Real u, Floating u) => u -> AbsPath u -> AbsPath u
tipL :: AbsPath u -> Point2 u
tipR :: AbsPath u -> Point2 u

-- | Direction of empty path is considered to be 0.
inclinationL :: (Real u, Floating u) => AbsPath u -> Radian

-- | Direction of empty path is considered to be 0.
inclinationR :: (Real u, Floating u) => AbsPath u -> Radian

-- | Is the left tip a Bezier curve?
isBezierL :: AbsPath u -> Bool

-- | Is the right tip a Bezier curve?
isBezierR :: AbsPath u -> Bool
midway :: (Real u, Floating u) => AbsPath u -> (Point2 u, Radian)
midway_ :: (Real u, Floating u) => AbsPath u -> Point2 u
atstart :: (Real u, Floating u) => AbsPath u -> (Point2 u, Radian)
atstart_ :: AbsPath u -> Point2 u
atend :: (Real u, Floating u) => AbsPath u -> (Point2 u, Radian)
atend_ :: AbsPath u -> Point2 u
data PathViewL u
EmptyPathL :: PathViewL u
(:<<) :: PathSegment u -> AbsPath u -> PathViewL u
type DPathViewL = PathViewL Double
data PathViewR u
EmptyPathR :: PathViewR u
(:>>) :: AbsPath u -> PathSegment u -> PathViewR u
type DPathViewR = PathViewR Double

-- | PathSegments are annotated with length.
data PathSegment u
LineSeg :: u -> (Point2 u) -> (Point2 u) -> PathSegment u
CurveSeg :: u -> (Point2 u) -> (Point2 u) -> (Point2 u) -> (Point2 u) -> PathSegment u
type DPathSegment = PathSegment Double
pathViewL :: Num u => AbsPath u -> PathViewL u
pathViewR :: Num u => AbsPath u -> PathViewR u
optimizeLines :: (Real u, Floating u, Ord u, Tolerance u) => AbsPath u -> AbsPath u

-- | Round a "closed" path.
--   
--   Caution - all path sgements are expected to be longer than 2x the
--   round corner length, though this is not checked..
roundExterior :: (Real u, Floating u, Tolerance u) => u -> AbsPath u -> AbsPath u

-- | Round interior corners of a Path.
--   
--   The path is treated as open - the start of the initial and end of the
--   final segments are not rounded. Only straight line to straight line
--   joins are rounded, joins to or from Bezier curves are not rounded.
--   
--   Caution - all path segments are expected to be longer than 2x the
--   round corner length, though this is not checked..
roundInterior :: (Real u, Floating u, Tolerance u) => u -> AbsPath u -> AbsPath u

-- | Redraw an <a>AbsPath</a> replacing the Bezier curves with three lines
--   along the control vectors.
deBezier :: Floating u => AbsPath u -> AbsPath u

-- | This does not extract the control points of Bezier curves.
pathMajorPoints :: Num u => AbsPath u -> [Point2 u]

-- | This extracts the control points of Bezier curves.
pathAllPoints :: Num u => AbsPath u -> [Point2 u]

-- | Divide a path returning intermediate points and direction
--   
--   Args are initial-prefix, division size, trailing size.
--   
--   Generation is stopped if the remainder of the path is shorter than the
--   trailing size.
pathdiv :: (Real u, Floating u) => u -> u -> u -> AbsPath u -> [(Point2 u, Radian)]
instance (Ord u, Tolerance u) => Eq (AbsPathSeg u)
instance Show u => Show (AbsPathSeg u)
instance (Ord u, Tolerance u) => Eq (AbsPath u)
instance Show u => Show (AbsPath u)
instance (Ord u, Tolerance u) => Eq (PathSegment u)
instance Show u => Show (PathSegment u)
instance (Ord u, Tolerance u) => Eq (PathViewR u)
instance Show u => Show (PathViewR u)
instance (Ord u, Tolerance u) => Eq (PathViewL u)
instance Show u => Show (PathViewL u)
instance Functor PathViewR
instance Functor PathViewL
instance Functor PathSegment
instance (Real u, Floating u, Ord u, Tolerance u) => RotateAbout (AbsPath u)
instance (Real u, Floating u, Ord u, Tolerance u) => Rotate (AbsPath u)
instance (Floating u, Ord u, Tolerance u) => Scale (AbsPath u)
instance Num u => Translate (AbsPath u)
instance (Floating u, Ord u, Tolerance u) => Scale (AbsPathSeg u)
instance Num u => Translate (AbsPathSeg u)
instance Functor AbsPathSeg
instance Functor AbsPath


-- | Intersection of Paths with (infinite) lines.
module Wumpus.Drawing.Paths.Intersection

-- | Infinite line represented by two points.
data Line u
Line :: (Point2 u) -> (Point2 u) -> Line u

-- | <a>inclinedLine</a> : <tt> point * ang -&gt; Line </tt>
--   
--   Make an infinite line passing through the supplied point inclined by
--   <tt>ang</tt>.
inclinedLine :: Floating u => Point2 u -> Radian -> Line u
vectorLine :: Num u => Vec2 u -> Point2 u -> Line u

-- | A <a>Ray</a> extends from the first point, through the second to
--   infinity.
--   
--   (<a>Line</a> extends to infinity in both directions.
data Ray u
Ray :: (Point2 u) -> (Point2 u) -> Ray u

-- | Make an infinite ray starting from the supplied point inclined by
--   <tt>ang</tt>.
inclinedRay :: Floating u => Point2 u -> Radian -> Ray u

-- | <tt>interLineLine</tt> : <tt> line1 * line2 -&gt; Maybe Point </tt>
--   
--   Find the intersection of two lines, if there is one.
--   
--   Lines are infinite they are represented by points on them, they are
--   not line segments.
--   
--   An answer of <tt>Nothing</tt> may indicate either the lines coincide
--   or the are parallel.
lineLineIntersection :: (Fractional u, Ord u, Tolerance u) => Line u -> Line u -> Maybe (Point2 u)
linePathIntersection :: (Real u, Floating u, Ord u, Tolerance u) => Line u -> AbsPath u -> Maybe (Point2 u)
linePathSegmentIntersection :: (Real u, Floating u, Ord u, Tolerance u) => Line u -> PathSegment u -> Maybe (Point2 u)
rayPathIntersection :: (Real u, Floating u, Ord u, Tolerance u) => Ray u -> AbsPath u -> Maybe (Point2 u)
rayPathSegmentIntersection :: (Real u, Floating u, Ord u, Tolerance u) => Ray u -> PathSegment u -> Maybe (Point2 u)

-- | Answer is vector from center.
rectangleRadialIntersect :: (Real u, Floating u, InterpretUnit u, Tolerance u) => u -> u -> Radian -> Maybe (Vec2 u)

-- | Answer is vector from centroid.
isoscelesTriangleRadialIntersect :: (Real u, Floating u, InterpretUnit u, Tolerance u) => u -> u -> Radian -> Maybe (Vec2 u)
instance Eq u => Eq (LineEquation u)
instance Show u => Show (LineEquation u)
instance Eq u => Eq (Matrix2'2 u)
instance (Ord u, Tolerance u) => Eq (Line u)
instance Show u => Show (Line u)
instance (Ord u, Tolerance u) => Eq (Ray u)
instance Show u => Show (Ray u)


-- | Dots with anchors.
--   
--   In many cases a surrounding circle is used to locate anchor points -
--   this could be improved to use the actual dot border at some point.
module Wumpus.Drawing.Dots.AnchorDots

-- | All dots return the same thing a <a>DotAnchor</a> which supports the
--   same (limited) see of anchors.
data DotAnchor u
type DotLocImage u = LocImage u (DotAnchor u)
type DDotLocImage = DotLocImage Double
smallDisk :: (Floating u, Real u, InterpretUnit u) => DotLocImage u
largeDisk :: (Floating u, Real u, InterpretUnit u) => DotLocImage u
smallCirc :: (Floating u, Real u, InterpretUnit u) => DotLocImage u
largeCirc :: (Floating u, Real u, InterpretUnit u) => DotLocImage u
dotNone :: InterpretUnit u => DotLocImage u
dotChar :: (Floating u, Real u, InterpretUnit u, Tolerance u) => Char -> DotLocImage u
dotText :: (Floating u, Real u, InterpretUnit u, Tolerance u) => String -> DotLocImage u
dotHBar :: (Floating u, InterpretUnit u) => DotLocImage u
dotVBar :: (Floating u, InterpretUnit u) => DotLocImage u
dotX :: (Floating u, InterpretUnit u) => DotLocImage u
dotPlus :: (Floating u, InterpretUnit u) => DotLocImage u
dotCross :: (Floating u, InterpretUnit u) => DotLocImage u
dotDiamond :: (Floating u, InterpretUnit u) => DotLocImage u
dotFDiamond :: (Floating u, InterpretUnit u) => DotLocImage u
dotDisk :: (Floating u, InterpretUnit u) => DotLocImage u
dotSquare :: (Floating u, Real u, InterpretUnit u, Tolerance u) => DotLocImage u
dotCircle :: (Floating u, InterpretUnit u) => DotLocImage u
dotPentagon :: (Floating u, InterpretUnit u) => DotLocImage u
dotStar :: (Floating u, Ord u, InterpretUnit u, Tolerance u) => DotLocImage u
dotAsterisk :: (Floating u, InterpretUnit u) => DotLocImage u
dotOPlus :: (Floating u, InterpretUnit u) => DotLocImage u
dotOCross :: (Floating u, InterpretUnit u) => DotLocImage u
dotFOCross :: (Floating u, InterpretUnit u) => DotLocImage u
dotTriangle :: (Real u, Floating u, InterpretUnit u, Tolerance u) => DotLocImage u
instance CardinalAnchor2 (DotAnchor u)
instance CardinalAnchor (DotAnchor u)
instance RadialAnchor (DotAnchor u)
instance CenterAnchor (DotAnchor u)
instance Num u => Translate (DotAnchor u)


-- | Build relative paths monadically.
--   
--   ** WARNING ** this module is an experiment, and may change
--   significantly or even be dropped from future revisions.
module Wumpus.Drawing.Paths.PathBuilder

-- | Note - a path spec has an immutable start point like
--   <tt>LocDrawing</tt>.
--   
--   Effectively a path is draw in a local coordinate system with
--   <tt>(0,0)</tt> as the origin.
data GenPathSpec st u a
type PathSpec u a = GenPathSpec () u a
data Vamp u
Vamp :: Vec2 u -> ConnectorGraphic u -> Vamp u
vamp_move :: Vamp u -> Vec2 u
vamp_conn :: Vamp u -> ConnectorGraphic u
runGenPathSpec :: InterpretUnit u => st -> PathMode -> GenPathSpec st u a -> LocImage u (a, st, AbsPath u)
execGenPathSpec :: InterpretUnit u => st -> PathMode -> GenPathSpec st u a -> LocImage u (st, AbsPath u)
evalGenPathSpec :: InterpretUnit u => st -> PathMode -> GenPathSpec st u a -> LocImage u (a, AbsPath u)
stripGenPathSpec :: InterpretUnit u => st -> PathMode -> GenPathSpec st u a -> LocQuery u (a, st, AbsPath u)
runPathSpec :: InterpretUnit u => PathMode -> PathSpec u a -> LocImage u (a, AbsPath u)
runPathSpec_ :: InterpretUnit u => PathMode -> PathSpec u a -> LocGraphic u

-- | Form a "pivot path" drawing from two path specifications. The start
--   point of the drawing is the pivot formed by joining the paths.
runPivot :: (Floating u, InterpretUnit u) => PathSpec u a -> PathSpec u a -> LocGraphic u

-- | Extend the path with a line, drawn by the pen.
penline :: InterpretUnit u => Vec2 u -> GenPathSpec st u ()

-- | Extend the path with a curve, drawn by the pen.
pencurve :: InterpretUnit u => Vec2 u -> Vec2 u -> Vec2 u -> GenPathSpec st u ()
breakPath :: InterpretUnit u => GenPathSpec st u ()
hpenline :: InterpretUnit u => u -> GenPathSpec st u ()
vpenline :: InterpretUnit u => u -> GenPathSpec st u ()
apenline :: (Floating u, InterpretUnit u) => Radian -> u -> GenPathSpec st u ()
penlines :: InterpretUnit u => [Vec2 u] -> GenPathSpec st u ()
pathmoves :: InterpretUnit u => [Vec2 u] -> GenPathSpec st u ()
vamp :: InterpretUnit u => Vamp u -> GenPathSpec st u ()
cycleSubPath :: DrawMode -> GenPathSpec st u ()

-- | Note - updates the pen but doesn't draw, the final path will be
--   drawing with the last updated context.
updatePen :: DrawingContextF -> GenPathSpec st u ()
instance InterpretUnit u => InsertlM (GenPathSpec st u)
instance InterpretUnit u => CursorM (GenPathSpec st u)
instance InterpretUnit u => LocationM (GenPathSpec st u)
instance UserStateM (GenPathSpec st u)
instance DrawingCtxM (GenPathSpec st u)
instance Monoid a => Monoid (GenPathSpec st u a)
instance Monad (GenPathSpec st u)
instance Applicative (GenPathSpec st u)
instance Functor (GenPathSpec st u)


-- | Library of vamps (currently small).
module Wumpus.Drawing.Paths.Vamps
squareWE :: (Real u, Floating u, Ord u, Tolerance u, InterpretUnit u) => u -> Vamp u


-- | Shim import module for the Absolute Path modules.
module Wumpus.Drawing.Paths


-- | Connectors...
module Wumpus.Drawing.Connectors.Base

-- | The type of Connectors - a query from start and end point returning an
--   AbsPath.
type ConnectorPathQuery u = ConnectorQuery u (AbsPath u)
type SpacingProjection u = ConnectorProps -> Point2 u -> Point2 u -> Query u (Point2 u)

-- | Arrowhead <i>algorithm</i> - the components of an arrowhead.
--   
--   Retract distance is rather vague - depending on the arrowhead it may
--   represent a flush join between the path and the tip or a join that
--   uses the z-order (tip over path) to create the join.
--   
--   ** WARNING ** - pending revision...
data ArrowTip
ArrowTip :: En -> En -> LocThetaGraphic En -> ArrowTip
retract_distance :: ArrowTip -> En
tip_half_len :: ArrowTip -> En
tip_deco :: ArrowTip -> LocThetaGraphic En
type ArrowConnector u = ConnectorImage u (AbsPath u)

-- | total_path is the path before accounting for arrow retract distances.
data ConnectorConfig u
ConnectorConfig :: Maybe ArrowTip -> Maybe ArrowTip -> ConnectorPathSpec u -> ConnectorConfig u
conn_arrowl :: ConnectorConfig u -> Maybe ArrowTip
conn_arrowr :: ConnectorConfig u -> Maybe ArrowTip
conn_path_spec :: ConnectorConfig u -> ConnectorPathSpec u
newtype ConnectorPathSpec u
ConnectorPathSpec :: (ConnectorProps -> ConnectorPathQuery u) -> ConnectorPathSpec u
getConnectorPathSpec :: ConnectorPathSpec u -> ConnectorProps -> ConnectorPathQuery u

-- | NOTE - the prefix <i>render</i> needs (re-) consideration...
--   
--   If it is a good prefix other functions e.g. drawPath should use render
--   rather than draw.
renderConnectorConfig :: (Real u, Floating u, InterpretUnit u) => ConnectorProps -> ConnectorConfig u -> ConnectorImage u (AbsPath u)
arrowDecoratePath :: (Real u, Floating u, InterpretUnit u) => Maybe ArrowTip -> Maybe ArrowTip -> (AbsPath u) -> Image u (AbsPath u)

-- | Shorthand...
leftArrowConnector :: (Real u, Floating u, InterpretUnit u) => ConnectorProps -> ConnectorPathSpec u -> ArrowTip -> ConnectorImage u (AbsPath u)
rightArrowConnector :: (Real u, Floating u, InterpretUnit u) => ConnectorProps -> ConnectorPathSpec u -> ArrowTip -> ConnectorImage u (AbsPath u)
uniformArrowConnector :: (Real u, Floating u, InterpretUnit u) => ConnectorProps -> ConnectorPathSpec u -> ArrowTip -> ConnectorImage u (AbsPath u)


-- | Arrowheads.
--   
--   ** WARNING ** - naming scheme due to change.
module Wumpus.Drawing.Connectors.Arrowheads

-- | Filled triangle - apex is 90 deg.
tri90 :: ArrowTip

-- | Filled triangle - apex is 60 deg.
tri60 :: ArrowTip

-- | Filled triangle - apex is 45 deg.
tri45 :: ArrowTip
otri90 :: ArrowTip
otri60 :: ArrowTip
otri45 :: ArrowTip
revtri90 :: ArrowTip
revtri60 :: ArrowTip
revtri45 :: ArrowTip
orevtri90 :: ArrowTip
orevtri60 :: ArrowTip
orevtri45 :: ArrowTip
barb90 :: ArrowTip
barb60 :: ArrowTip
barb45 :: ArrowTip
revbarb90 :: ArrowTip
revbarb60 :: ArrowTip
revbarb45 :: ArrowTip
perp :: ArrowTip
bracket :: ArrowTip
diskTip :: ArrowTip
odiskTip :: ArrowTip
squareTip :: ArrowTip
osquareTip :: ArrowTip
diamondTip :: ArrowTip
odiamondTip :: ArrowTip
diamondWideTip :: ArrowTip
odiamondWideTip :: ArrowTip
curveTip :: ArrowTip
revcurveTip :: ArrowTip


-- | Shim module for Connectors.
--   
--   ** WARNING ** - this is due to change...
module Wumpus.Drawing.Connectors


-- | Primitive connectors
module Wumpus.Drawing.Connectors.ConnectorPaths

-- | Straight line connector.
conn_line :: (Real u, Floating u, InterpretUnit u, Tolerance u) => ConnectorPathSpec u

-- | Form an arc connector.
--   
--   If the conn_arc_angle in the Drawing context is positive the arc will
--   be formed <i>above</i> the straight line joining the points. If the
--   angle is negative it will be drawn below.
--   
--   The notion of <i>above</i> is respective to the line direction, of
--   course.
--   
--   TODO - above and below versions...
conna_arc :: (Real u, Floating u, Ord u, InterpretUnit u, Tolerance u) => ConnectorPathSpec u

-- | Below version of <a>conna_arc</a>.
connb_arc :: (Real u, Floating u, Ord u, InterpretUnit u, Tolerance u) => ConnectorPathSpec u

-- | Horizontal-diagonal-horizontal connector.
--   
--   <pre>
--       --@
--      /
--   o--
--   </pre>
--   
--   Horizontal <i>arms</i> are drawn from the start and end points, a
--   diagonal segment joins the arms.
conn_hdiagh :: (Real u, Floating u, Tolerance u, InterpretUnit u) => ConnectorPathSpec u

-- | Vertical-diagonal-vertical connector.
--   
--   <pre>
--   @
--   |
--    \
--     |
--     o
--   </pre>
--   
--   Vertical <i>arms</i> are drawn from the start and end points, a
--   diagonal segment joins the arms.
conn_vdiagv :: (Real u, Floating u, Tolerance u, InterpretUnit u) => ConnectorPathSpec u

-- | Diagonal-horizontal connector.
--   
--   <pre>
--     --@
--    /
--   o
--   </pre>
--   
--   Restricted variant of <tt>hconndiag</tt> - a diagonal segment is drawn
--   from the start point joining a horizontal arm drawn from the end point
conn_diagh :: (Real u, Floating u, Tolerance u, InterpretUnit u) => ConnectorPathSpec u

-- | Diagonal-vertical connector.
--   
--   <pre>
--     @
--     |
--    /
--   o
--   </pre>
--   
--   Restricted variant of <tt>vconndiag</tt> - a diagonal segment is drawn
--   from the start point joining a vertical arm drawn from the end point.
conn_diagv :: (Real u, Floating u, Tolerance u, InterpretUnit u) => ConnectorPathSpec u

-- | Horizontal-diagonal connector.
--   
--   <pre>
--       @
--      /
--   o--
--   </pre>
--   
--   Restricted variant of <tt>hconndiag</tt> - a horizontal arm is drawn
--   from the start point joining a diagonal segment drawn from the end
--   point.
conn_hdiag :: (Real u, Floating u, Tolerance u, InterpretUnit u) => ConnectorPathSpec u

-- | Vertical-diagonal connector.
--   
--   <pre>
--     @
--    /
--   |
--   o
--   </pre>
--   
--   Restricted variant of <tt>vconndiag</tt> - a horizontal arm is drawn
--   from the start point joining a vertical segment drawn from the end
--   point.
conn_vdiag :: (Real u, Floating u, Tolerance u, InterpretUnit u) => ConnectorPathSpec u

-- | Bar connector.
--   
--   <pre>
--   ,----, 
--   |    |
--   o    @  
--   </pre>
--   
--   The bar is drawn <i>above</i> the points.
conna_bar :: (Real u, Floating u, Tolerance u, InterpretUnit u) => ConnectorPathSpec u

-- | Bar connector.
--   
--   <pre>
--   o    @ 
--   |    |
--   '----'  
--   </pre>
--   
--   The bar is drawn <i>below</i> the points.
connb_bar :: (Real u, Floating u, Tolerance u, InterpretUnit u) => ConnectorPathSpec u

-- | <i>Flam</i> connector.
--   
--   <pre>
--     ,- '
--   ,-   | 
--   |    |
--   o    @  
--   </pre>
--   
--   The bar is drawn <i>above</i> the points.
conna_flam :: (Real u, Floating u, Tolerance u, InterpretUnit u) => ConnectorPathSpec u

-- | <i>Flam</i> connector - bleow.
connb_flam :: (Real u, Floating u, Tolerance u, InterpretUnit u) => ConnectorPathSpec u

-- | Bar connector - always orthonormal .
--   
--   <pre>
--   
--   ,----, 
--   |    |
--   o    @  
--   </pre>
--   
--   The bar is drawn <i>above</i> the points.
conna_orthohbar :: (Real u, Floating u, Tolerance u, InterpretUnit u) => ConnectorPathSpec u

-- | Bar connector orthonormal - below.
connb_orthohbar :: (Real u, Floating u, Tolerance u, InterpretUnit u) => ConnectorPathSpec u

-- | Bar connector - always orthonormal.
--   
--   <pre>
--   
--   ,--- o 
--   |   
--   '--- @  
--   
--   </pre>
--   
--   The bar is drawn <i>left</i> of the points.
conna_orthovbar :: (Real u, Floating u, Tolerance u, InterpretUnit u) => ConnectorPathSpec u

-- | Bar connector orthonormal - right of the points.
connb_orthovbar :: (Real u, Floating u, Tolerance u, InterpretUnit u) => ConnectorPathSpec u

-- | Right angle connector.
--   
--   <pre>
--   ,----@ 
--   | 
--   o   
--   </pre>
--   
--   The bar is drawn <i>above</i> the points.
conna_right :: (Real u, Floating u, Tolerance u, InterpretUnit u) => ConnectorPathSpec u

-- | Right angle connector.
--   
--   <pre>
--        @ 
--        |
--   o----'  
--   </pre>
--   
--   The bar is drawn <i>below</i> the points.
connb_right :: (Real u, Floating u, Tolerance u, InterpretUnit u) => ConnectorPathSpec u

-- | Connector with two horizontal segments and a joining vertical segment.
--   
--   <pre>
--        ,--@
--        |
--   o----'  
--   </pre>
--   
--   The length of the first horizontal segment is the source arm length.
--   The length of the final segment is the remaining horizontal distance.
conn_hrr :: (Real u, Floating u, Tolerance u, InterpretUnit u) => ConnectorPathSpec u

-- | Connector with two horizontal segements and a joining vertical
--   segment.
--   
--   <pre>
--      ,----@
--      |
--   o--'  
--   </pre>
--   
--   The length of the final horizontal segment is the destination arm
--   length. The length of the initial segment is the remaining horizontal
--   distance.
conn_rrh :: (Real u, Floating u, Tolerance u, InterpretUnit u) => ConnectorPathSpec u

-- | Connector with two right angles...
--   
--   <pre>
--        @
--        |
--   ,----'
--   |
--   o  
--   </pre>
--   
--   The length of the first vertical segment is the source arm length. The
--   length of the final segment is the remaining vertical distance.
conn_vrr :: (Real u, Floating u, Tolerance u, InterpretUnit u) => ConnectorPathSpec u

-- | Connector with two right angles...
--   
--   <pre>
--        @
--        |
--   ,----'
--   |
--   o  
--   </pre>
--   
--   The length of the final vertical segment is the destination arm
--   length. The length of the initial segment is the remaining vertical
--   distance.
conn_rrv :: (Real u, Floating u, Tolerance u, InterpretUnit u) => ConnectorPathSpec u

-- | Loop connector.
--   
--   <pre>
--   ,---------, 
--   |         |
--   '-o    @--'
--   </pre>
--   
--   The loop is drawn <i>above</i> the points.
conna_loop :: (Real u, Floating u, Tolerance u, InterpretUnit u) => ConnectorPathSpec u

-- | Loop connector.
--   
--   <pre>
--   ,-o    @--, 
--   |         |
--   '---------'
--   </pre>
--   
--   The loop is drawn <i>below</i> the points.
connb_loop :: (Real u, Floating u, Tolerance u, InterpretUnit u) => ConnectorPathSpec u

-- | Bezier curve connector - the control points are positioned
--   horizontally respective to the source and dest.
--   
--   <pre>
--   *--@ 
--     .  
--    . 
--   o--*  
--   </pre>
--   
--   Note - the source and dest arm lengths are doubled, generally this
--   produces nicer curves.
conn_hbezier :: (Real u, Floating u, InterpretUnit u, Tolerance u) => ConnectorPathSpec u

-- | Bezier curve connector - the control points are positioned vertically
--   respective to the source and dest.
--   
--   <pre>
--         @ 
--        .|  
--   *  .  *
--   |.
--   o
--   </pre>
--   
--   Note - the source and dest arm lengths are doubled, generally this
--   produces nicer curves.
conn_vbezier :: (Real u, Floating u, InterpretUnit u, Tolerance u) => ConnectorPathSpec u


-- | Drawing grids
module Wumpus.Drawing.Extras.Axes

-- | Simple orthonormal axes using snap grid units.
orthontAxes :: (Real u, Floating u, InterpretUnit u, Tolerance u) => (Int, Int) -> (Int, Int) -> LocGraphic u
horizontalLabels :: (Num a, Show a, Fractional u, InterpretUnit u) => RectAddress -> [a] -> LocGraphic u
verticalLabels :: (Num a, Show a, Fractional u, InterpretUnit u) => RectAddress -> [a] -> LocGraphic u


-- | Clipping paths.
--   
--   Note - at the moment there is nothing much to this module. Ideally,
--   clipping would be defined in Wumpus-Basic, but clipping needs a higher
--   level path object than Wumpus-Basic provides.
--   
--   ** WARNING ** names need improving.
module Wumpus.Drawing.Extras.Clip

-- | Clip a LocGraphic.
--   
--   ** WARNING ** - AbsPath (coordinate-specific) is the wrong object to
--   clip a LocGraphic (coordinate-free).
locClip :: InterpretUnit u => AbsPath u -> LocGraphic u -> LocGraphic u


-- | Open loop for a circle (useful for automata diagrams).
module Wumpus.Drawing.Extras.Loop
loopPath :: (Real u, Floating u, InterpretUnit u, Tolerance u) => u -> Point2 u -> Radian -> AbsPath u
loopTrail :: (Real u, Floating u) => u -> Radian -> AnaTrail u


-- | Common core for shapes
module Wumpus.Drawing.Shapes.Base

-- | Shape is a record of three <i>LocTheta</i> functions - functions
--   <i>from Point and Angle to answer</i>.
--   
--   The <tt>shape_path_fun</tt> returns a path. When the Shape is drawn,
--   the rendering function (<tt>strokedShape</tt>, etc.) uses the path for
--   drawing and returns the polymorphic answer <tt>a</tt> of the
--   <tt>shape_ans_fun</tt>. Lastly the <tt>shape_decoration</tt> function
--   can instantiated to add decoration (e.g. text) to the Shape as it is
--   rendered.
--   
--   The <tt>a</tt> of the <tt>shape_ans_fun</tt> represents some concrete
--   shape object (e.g. a Rectangle, Triangle etc.). Crucial for shape
--   objects is that they support Anchors - this allows connectors to
--   address specific locations on the Shape border so "node and link"
--   diagrams can be made easily.
data Shape t u
type DShape t = Shape t Double
shapeMap :: InterpretUnit u => (t u -> t' u) -> Shape t u -> Shape t' u
makeShape :: InterpretUnit u => LocThetaQuery u (t u) -> LocThetaQuery u (AbsPath u) -> Shape t u
strokedShape :: InterpretUnit u => Shape t u -> LocImage u (t u)

-- | Note - this is simplistic double stroking - draw a background line
--   with triple thickness and draw a white line on top.
--   
--   I think this is what TikZ does, but it works better for TikZ where the
--   extra thickness seems to be accounted for by the anchors. For Wumpus,
--   arrows cut into the outside black line.
--   
--   Probably Wumpus should calculate two paths instead.
dblStrokedShape :: InterpretUnit u => Shape t u -> LocImage u (t u)
filledShape :: InterpretUnit u => Shape t u -> LocImage u (t u)
borderedShape :: InterpretUnit u => Shape t u -> LocImage u (t u)
rstrokedShape :: InterpretUnit u => Shape t u -> LocThetaImage u (t u)
rfilledShape :: InterpretUnit u => Shape t u -> LocThetaImage u (t u)
rborderedShape :: InterpretUnit u => Shape t u -> LocThetaImage u (t u)

-- | Draw the shape path with round corners.
roundCornerShapePath :: (Real u, Floating u, InterpretUnit u, Tolerance u) => u -> [Point2 u] -> Query u (AbsPath u)

-- | The path angle can be modified. This allows <i>inverse</i> versions of
--   shapes (e.g. InvTriangle) to be made by wrapping a base Shape but
--   rotating the path prior to drawing it.
--   
--   Only the Path needs rotating, the decoration takes the original angle.
--   The anchors are typically implemented by rotating the correspoding
--   anchor of the wrapped Shape about its center.
updatePathAngle :: InterpretUnit u => (Radian -> Radian) -> Shape t u -> Shape t u
setDecoration :: LocThetaGraphic u -> Shape t u -> Shape t u
data ShapeCTM u
makeShapeCTM :: Point2 u -> Radian -> ShapeCTM u
ctmCenter :: ShapeCTM u -> Point2 u
ctmAngle :: ShapeCTM u -> Radian
ctmLocale :: ShapeCTM u -> (Point2 u, Radian)
projectFromCtr :: (Real u, Floating u) => Vec2 u -> ShapeCTM u -> Anchor u
instance (Ord u, Tolerance u) => Eq (ShapeCTM u)
instance (Ord u, Tolerance u) => Ord (ShapeCTM u)
instance Show u => Show (ShapeCTM u)
instance Num u => Translate (ShapeCTM u)
instance (Real u, Floating u) => RotateAbout (ShapeCTM u)
instance (Real u, Floating u) => Rotate (ShapeCTM u)
instance Fractional u => Scale (ShapeCTM u)
instance Functor ShapeCTM


-- | Simple shapes - rectangle, circle diamond, ellipse.
module Wumpus.Drawing.Shapes.Circle
data Circle u
type DCircle = Circle Double

-- | <a>circle</a> : <tt> radius -&gt; Shape </tt>
circle :: (Real u, Floating u, InterpretUnit u, Tolerance u) => u -> Shape Circle u
instance (Real u, Floating u) => RadialAnchor (Circle u)
instance (Real u, Floating u) => CardinalAnchor2 (Circle u)
instance (Real u, Floating u) => CardinalAnchor (Circle u)
instance (Real u, Floating u) => CenterAnchor (Circle u)
instance Num u => Translate (Circle u)
instance Fractional u => Scale (Circle u)
instance (Real u, Floating u) => RotateAbout (Circle u)
instance (Real u, Floating u) => Rotate (Circle u)
instance Functor Circle


-- | Diamond (rhombus).
module Wumpus.Drawing.Shapes.Diamond
data Diamond u
type DDiamond = Diamond Double

-- | <a>diamond</a> : <tt> half_width * half_height -&gt; shape </tt>
--   
--   Note - args might change to tull_width and full_height...
diamond :: (Real u, Floating u, InterpretUnit u, Tolerance u) => u -> u -> Shape Diamond u
instance (Real u, Floating u, InterpretUnit u, Tolerance u) => RadialAnchor (Diamond u)
instance (Real u, Floating u) => CardinalAnchor2 (Diamond u)
instance (Real u, Floating u) => CardinalAnchor (Diamond u)
instance (Real u, Floating u) => SideMidpointAnchor (Diamond u)
instance (Real u, Floating u) => ApexAnchor (Diamond u)
instance (Real u, Floating u) => CenterAnchor (Diamond u)
instance Num u => Translate (Diamond u)
instance Fractional u => Scale (Diamond u)
instance (Real u, Floating u) => RotateAbout (Diamond u)
instance (Real u, Floating u) => Rotate (Diamond u)
instance Functor Diamond


-- | Ellipse shape.
module Wumpus.Drawing.Shapes.Ellipse
data Ellipse u
type DEllipse = Ellipse Double

-- | <a>ellipse</a> : <tt> x_radii * y_radii -&gt; shape </tt>
ellipse :: (Real u, Floating u, Ord u, InterpretUnit u, Tolerance u) => u -> u -> Shape Ellipse u
instance (Real u, Floating u) => CardinalAnchor2 (Ellipse u)
instance (Real u, Floating u) => CardinalAnchor (Ellipse u)
instance (Real u, Floating u) => RadialAnchor (Ellipse u)
instance (Real u, Floating u) => CenterAnchor (Ellipse u)
instance InterpretUnit u => Translate (Ellipse u)
instance Fractional u => Scale (Ellipse u)
instance (Real u, Floating u) => RotateAbout (Ellipse u)
instance (Real u, Floating u) => Rotate (Ellipse u)
instance Functor Ellipse


-- | Parallelogram.
module Wumpus.Drawing.Shapes.Parallelogram

-- | A Paralleogram.
data Parallelogram u
type DParallelogram = Parallelogram Double

-- | <a>parallelogram</a> : <tt> width * height * bottom_left_ang -&gt;
--   Parallelogram </tt>
parallelogram :: (Real u, Floating u, InterpretUnit u, Tolerance u) => u -> u -> Radian -> Shape Parallelogram u

-- | <a>zparallelogram</a> : <tt> base_width * height -&gt; Parallelogram
--   </tt>
zparallelogram :: (Real u, Floating u, InterpretUnit u, Tolerance u) => u -> u -> Shape Parallelogram u
instance (Real u, Floating u, InterpretUnit u, Tolerance u) => RadialAnchor (Parallelogram u)
instance (Real u, Floating u, InterpretUnit u, Tolerance u) => CardinalAnchor2 (Parallelogram u)
instance (Real u, Floating u, InterpretUnit u, Tolerance u) => CardinalAnchor (Parallelogram u)
instance (Real u, Floating u) => SideMidpointAnchor (Parallelogram u)
instance (Real u, Floating u) => BottomCornerAnchor (Parallelogram u)
instance (Real u, Floating u) => TopCornerAnchor (Parallelogram u)
instance (Real u, Floating u) => CenterAnchor (Parallelogram u)
instance InterpretUnit u => Translate (Parallelogram u)
instance Fractional u => Scale (Parallelogram u)
instance (Real u, Floating u) => RotateAbout (Parallelogram u)
instance (Real u, Floating u) => Rotate (Parallelogram u)
instance Functor Parallelogram


-- | Rectangle shape.
--   
--   Note - CardinalAnchor2 (northeast etc.) point to their radial
--   positions (this is a change since earlier versions).
module Wumpus.Drawing.Shapes.Rectangle
data Rectangle u
type DRectangle = Rectangle Double

-- | <a>rectangle</a> : <tt> width * height -&gt; shape </tt>
rectangle :: (Real u, Floating u, InterpretUnit u, Tolerance u) => u -> u -> Shape Rectangle u
instance (Ord u, Tolerance u) => Eq (Rectangle u)
instance (Ord u, Tolerance u) => Ord (Rectangle u)
instance Show u => Show (Rectangle u)
instance (Real u, Floating u, InterpretUnit u, Tolerance u) => RadialAnchor (Rectangle u)
instance (Real u, Floating u, InterpretUnit u, Tolerance u) => CardinalAnchor2 (Rectangle u)
instance (Real u, Floating u) => CardinalAnchor (Rectangle u)
instance (Real u, Floating u) => SideMidpointAnchor (Rectangle u)
instance (Real u, Floating u) => BottomCornerAnchor (Rectangle u)
instance (Real u, Floating u) => TopCornerAnchor (Rectangle u)
instance (Real u, Floating u) => CenterAnchor (Rectangle u)
instance InterpretUnit u => Translate (Rectangle u)
instance Fractional u => Scale (Rectangle u)
instance (Real u, Floating u) => RotateAbout (Rectangle u)
instance (Real u, Floating u) => Rotate (Rectangle u)
instance Functor Rectangle


-- | Semicircle.
module Wumpus.Drawing.Shapes.Semicircle
data Semicircle u
type DSemicircle = Semicircle Double

-- | <a>semicircle</a> : <tt> radius -&gt; Shape </tt>
semicircle :: (Real u, Floating u, InterpretUnit u, Tolerance u) => u -> Shape Semicircle u
instance (Real u, Floating u, InterpretUnit u, Tolerance u) => RadialAnchor (Semicircle u)
instance (Real u, Floating u, InterpretUnit u, Tolerance u) => CardinalAnchor2 (Semicircle u)
instance (Real u, Floating u) => CardinalAnchor (Semicircle u)
instance (Real u, Floating u) => BottomCornerAnchor (Semicircle u)
instance (Real u, Floating u) => ApexAnchor (Semicircle u)
instance (Real u, Floating u) => CenterAnchor (Semicircle u)
instance InterpretUnit u => Translate (Semicircle u)
instance Fractional u => Scale (Semicircle u)
instance (Real u, Floating u) => RotateAbout (Semicircle u)
instance (Real u, Floating u) => Rotate (Semicircle u)
instance Functor Semicircle


-- | Inverse semicircle.
module Wumpus.Drawing.Shapes.InvSemicircle
data InvSemicircle u
type DInvSemicircle = InvSemicircle Double

-- | <a>invsemicircle</a> : <tt> radius -&gt; Shape </tt>
invsemicircle :: (Real u, Floating u, InterpretUnit u, Tolerance u) => u -> Shape InvSemicircle u
instance (Real u, Floating u, InterpretUnit u, Tolerance u) => RadialAnchor (InvSemicircle u)
instance (Real u, Floating u, InterpretUnit u, Tolerance u) => CardinalAnchor2 (InvSemicircle u)
instance (Real u, Floating u) => CardinalAnchor (InvSemicircle u)
instance (Real u, Floating u) => TopCornerAnchor (InvSemicircle u)
instance (Real u, Floating u) => ApexAnchor (InvSemicircle u)
instance (Real u, Floating u) => CenterAnchor (InvSemicircle u)
instance InterpretUnit u => Translate (InvSemicircle u)
instance Fractional u => Scale (InvSemicircle u)
instance (Real u, Floating u) => RotateAbout (InvSemicircle u)
instance (Real u, Floating u) => Rotate (InvSemicircle u)
instance Functor InvSemicircle


-- | Semiellipse.
module Wumpus.Drawing.Shapes.Semiellipse
data Semiellipse u
type DSemiellipse = Semiellipse Double

-- | <a>semiellipse</a> : <tt> x_radius * y_radius -&gt; Shape </tt>
semiellipse :: (Real u, Floating u, InterpretUnit u, Tolerance u) => u -> u -> Shape Semiellipse u
instance (Real u, Floating u, InterpretUnit u, Tolerance u) => RadialAnchor (Semiellipse u)
instance (Real u, Floating u, InterpretUnit u, Tolerance u) => CardinalAnchor2 (Semiellipse u)
instance (Real u, Floating u, InterpretUnit u, Tolerance u) => CardinalAnchor (Semiellipse u)
instance (Real u, Floating u) => BottomCornerAnchor (Semiellipse u)
instance (Real u, Floating u, Tolerance u) => ApexAnchor (Semiellipse u)
instance (Real u, Floating u) => CenterAnchor (Semiellipse u)
instance InterpretUnit u => Translate (Semiellipse u)
instance Fractional u => Scale (Semiellipse u)
instance (Real u, Floating u) => RotateAbout (Semiellipse u)
instance (Real u, Floating u) => Rotate (Semiellipse u)
instance Functor Semiellipse


-- | Inverse semiellipse.
module Wumpus.Drawing.Shapes.InvSemiellipse
data InvSemiellipse u
type DInvSemiellipse = InvSemiellipse Double

-- | <a>invsemiellipse</a> : <tt> rx * ry -&gt; Shape </tt>
invsemiellipse :: (Real u, Floating u, InterpretUnit u, Tolerance u) => u -> u -> Shape InvSemiellipse u
instance (Real u, Floating u, InterpretUnit u, Tolerance u) => RadialAnchor (InvSemiellipse u)
instance (Real u, Floating u, InterpretUnit u, Tolerance u) => CardinalAnchor2 (InvSemiellipse u)
instance (Real u, Floating u, InterpretUnit u, Tolerance u) => CardinalAnchor (InvSemiellipse u)
instance (Real u, Floating u, Tolerance u) => TopCornerAnchor (InvSemiellipse u)
instance (Real u, Floating u, Tolerance u) => ApexAnchor (InvSemiellipse u)
instance (Real u, Floating u, Tolerance u) => CenterAnchor (InvSemiellipse u)
instance InterpretUnit u => Translate (InvSemiellipse u)
instance Fractional u => Scale (InvSemiellipse u)
instance (Real u, Floating u) => RotateAbout (InvSemiellipse u)
instance (Real u, Floating u) => Rotate (InvSemiellipse u)
instance Functor InvSemiellipse


-- | Isoceles Trapezium.
module Wumpus.Drawing.Shapes.Trapezium

-- | A trapezium.
data Trapezium u
type DTrapezium = Trapezium Double

-- | <a>trapezium</a> : <tt> base_width * height * bottom_left_ang *
--   bottom_right_ang -&gt; Shape </tt>
trapezium :: (Real u, Floating u, InterpretUnit u, Tolerance u) => u -> u -> Radian -> Shape Trapezium u
instance (Real u, Floating u, Tolerance u) => RadialAnchor (Trapezium u)
instance (Real u, Floating u, Tolerance u) => CardinalAnchor2 (Trapezium u)
instance (Real u, Floating u, Tolerance u) => CardinalAnchor (Trapezium u)
instance (Real u, Floating u, Tolerance u) => SideMidpointAnchor (Trapezium u)
instance (Real u, Floating u) => TopCornerAnchor (Trapezium u)
instance (Real u, Floating u) => BottomCornerAnchor (Trapezium u)
instance (Real u, Floating u) => CenterAnchor (Trapezium u)
instance InterpretUnit u => Translate (Trapezium u)
instance Fractional u => Scale (Trapezium u)
instance (Real u, Floating u) => RotateAbout (Trapezium u)
instance (Real u, Floating u) => Rotate (Trapezium u)
instance Functor Trapezium


-- | Isosceles triangle.
module Wumpus.Drawing.Shapes.Triangle

-- | An isosceles triangle, oriented <i>upwards</i>.
data Triangle u
type DTriangle = Triangle Double

-- | <a>triangle</a> : <tt> base_width * height -&gt; Shape </tt>
triangle :: (Real u, Floating u, InterpretUnit u, Tolerance u) => u -> u -> Shape Triangle u
instance (Real u, Floating u, InterpretUnit u, Tolerance u) => RadialAnchor (Triangle u)
instance (Real u, Floating u, InterpretUnit u, Tolerance u) => CardinalAnchor2 (Triangle u)
instance (Real u, Floating u) => SideMidpointAnchor (Triangle u)
instance (Real u, Floating u) => CardinalAnchor (Triangle u)
instance (Real u, Floating u) => BottomCornerAnchor (Triangle u)
instance (Real u, Floating u) => ApexAnchor (Triangle u)
instance (Real u, Floating u) => CenterAnchor (Triangle u)
instance InterpretUnit u => Translate (Triangle u)
instance Fractional u => Scale (Triangle u)
instance (Real u, Floating u) => RotateAbout (Triangle u)
instance (Real u, Floating u) => Rotate (Triangle u)
instance Functor Triangle


-- | Inverse version of the Triangle shape.
module Wumpus.Drawing.Shapes.InvTriangle
data InvTriangle u
type DInvTriangle = InvTriangle Double

-- | <a>invtriangle</a> : <tt> top_base_width * height -&gt; Triangle </tt>
invtriangle :: (Real u, Floating u, InterpretUnit u, Tolerance u) => u -> u -> Shape InvTriangle u
instance (Real u, Floating u, InterpretUnit u, Tolerance u) => RadialAnchor (InvTriangle u)
instance (Real u, Floating u, InterpretUnit u, Tolerance u) => CardinalAnchor2 (InvTriangle u)
instance (Real u, Floating u) => CardinalAnchor (InvTriangle u)
instance (Real u, Floating u) => SideMidpointAnchor (InvTriangle u)
instance (Real u, Floating u) => TopCornerAnchor (InvTriangle u)
instance (Real u, Floating u) => ApexAnchor (InvTriangle u)
instance (Real u, Floating u) => CenterAnchor (InvTriangle u)
instance InterpretUnit u => Translate (InvTriangle u)
instance Fractional u => Scale (InvTriangle u)
instance (Real u, Floating u) => RotateAbout (InvTriangle u)
instance (Real u, Floating u) => Rotate (InvTriangle u)
instance Functor InvTriangle


-- | Shim module for Shapes.
module Wumpus.Drawing.Shapes


-- | Annotation labels.
module Wumpus.Drawing.Text.Base.Label
locImageLabel :: InterpretUnit u => (a -> Anchor u) -> RectAddress -> (RectAddress -> LocImage u (BoundingBox u)) -> LocImage u a -> LocImage u a
label_center_of :: (InterpretUnit u, CenterAnchor a, u ~ DUnit a) => BoundedLocRectGraphic u -> LocImage u a -> LocImage u a
label_left_of :: (InterpretUnit u, CardinalAnchor a, u ~ DUnit a) => BoundedLocRectGraphic u -> LocImage u a -> LocImage u a
label_right_of :: (InterpretUnit u, CardinalAnchor a, u ~ DUnit a) => BoundedLocRectGraphic u -> LocImage u a -> LocImage u a
label_above :: (InterpretUnit u, CardinalAnchor a, u ~ DUnit a) => BoundedLocRectGraphic u -> LocImage u a -> LocImage u a
label_below :: (InterpretUnit u, CardinalAnchor a, u ~ DUnit a) => BoundedLocRectGraphic u -> LocImage u a -> LocImage u a
connectorPathLabel :: InterpretUnit u => (AbsPath u -> Point2 u) -> RectAddress -> BoundedLocRectGraphic u -> Image u (AbsPath u) -> Image u (AbsPath u)
label_midway_of :: (Real u, Floating u, InterpretUnit u) => RectAddress -> BoundedLocRectGraphic u -> Image u (AbsPath u) -> Image u (AbsPath u)
label_atstart_of :: (Real u, Floating u, InterpretUnit u) => RectAddress -> BoundedLocRectGraphic u -> Image u (AbsPath u) -> Image u (AbsPath u)
label_atend_of :: (Real u, Floating u, InterpretUnit u) => RectAddress -> BoundedLocRectGraphic u -> Image u (AbsPath u) -> Image u (AbsPath u)

-- | Absolute units.
centerRelative :: (CenterAnchor a, Fractional u, InterpretUnit u, u ~ DUnit a) => (Int, Int) -> a -> Query u (Anchor u)

-- | Value is 1 snap unit right.
--   
--   This function should be considered obsolete, pending a re-think.
right_of :: (CenterAnchor a, Fractional u, InterpretUnit u, u ~ DUnit a) => a -> Query u (Anchor u)

-- | Value is 1 snap move left.
--   
--   This function should be considered obsolete, pending a re-think.
left_of :: (CenterAnchor a, Fractional u, InterpretUnit u, u ~ DUnit a) => a -> Query u (Anchor u)

-- | Value is 1 snap move up, 1 snap move right.
--   
--   This function should be considered obsolete, pending a re-think.
above_right_of :: (CenterAnchor a, Fractional u, InterpretUnit u, u ~ DUnit a) => a -> Query u (Anchor u)

-- | Value is 1 snap move below, 1 snap move right.
--   
--   This function should be considered obsolete, pending a re-think.
below_right_of :: (CenterAnchor a, Fractional u, InterpretUnit u, u ~ DUnit a) => a -> Query u (Anchor u)

-- | Value is 1 snap move up, 1 snap move left.
--   
--   This function should be considered obsolete, pending a re-think.
above_left_of :: (CenterAnchor a, Fractional u, InterpretUnit u, u ~ DUnit a) => a -> Query u (Anchor u)

-- | Value is 1 snap move down, 1 snap move left.
--   
--   This function should be considered obsolete, pending a re-think.
below_left_of :: (CenterAnchor a, Fractional u, InterpretUnit u, u ~ DUnit a) => a -> Query u (Anchor u)


-- | Illustrate a path - show the construction of its Bezier curves.
module Wumpus.Drawing.Paths.Illustrate

-- | Illustrate the control points as a <i>boxed</i> path - Bezier curves
--   are replaced with straight lines spanning the control points.
path_as_control_box :: (Floating u, InterpretUnit u) => AbsPath u -> Graphic u
path_with_control_points :: (Floating u, InterpretUnit u) => AbsPath u -> Graphic u
