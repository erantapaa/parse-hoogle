-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Free monads and monad transformers
--   
--   This package provides datatypes to construct Free monads, Free monad
--   transformers, and useful instances. In addition it provides the
--   constructs to avoid quadratic complexity of left associative bind, as
--   explained in:
--   
--   <ul>
--   <li>Janis Voigtlander, <i>Asymptotic Improvement of Computations over
--   Free Monads, MPC'08</i></li>
--   </ul>
@package control-monad-free
@version 0.6.1

module Control.Monad.Free

-- | This type class generalizes over encodings of Free Monads.
class (Functor f, Monad m) => MonadFree f m
free :: MonadFree f m => m a -> m (Either a (f (m a)))
wrap :: MonadFree f m => f (m a) -> m a
data Free f a
Impure :: (f (Free f a)) -> Free f a
Pure :: a -> Free f a
isPure :: Free t t1 -> Bool
isImpure :: Free t t1 -> Bool
foldFree :: Functor f => (a -> b) -> (f b -> b) -> Free f a -> b
evalFree :: (a -> b) -> (f (Free f a) -> b) -> Free f a -> b
mapFree :: (Functor f, Functor g) => (f (Free g a) -> g (Free g a)) -> Free f a -> Free g a
mapFreeM :: (Traversable f, Functor g, Monad m) => (f (Free g a) -> m (g (Free g a))) -> Free f a -> m (Free g a)
mapFreeM' :: (Functor f, Traversable g, Monad m) => (forall a. f a -> m (g a)) -> Free f a -> m (Free g a)
foldFreeM :: (Traversable f, Monad m) => (a -> m b) -> (f b -> m b) -> Free f a -> m b
induce :: (Functor f, Monad m) => (forall a. f a -> m a) -> Free f a -> m a
newtype FreeT f m a
FreeT :: m (Either a (f (FreeT f m a))) -> FreeT f m a
unFreeT :: FreeT f m a -> m (Either a (f (FreeT f m a)))
foldFreeT :: (Traversable f, Monad m) => (a -> m b) -> (f b -> m b) -> FreeT f m a -> m b
foldFreeT' :: (Traversable f, Monad m) => (a -> b) -> (f b -> b) -> FreeT f m a -> m b
mapFreeT :: (Functor f, Functor m) => (forall a. m a -> m' a) -> FreeT f m a -> FreeT f m' a
foldFreeA :: (Traversable f, Applicative m) => (a -> m b) -> m (f b -> b) -> Free f a -> m b
mapFreeA :: (Traversable f, Functor g, Applicative m) => m (f (Free g a) -> g (Free g a)) -> Free f a -> m (Free g a)
trans :: MonadFree f m => Free f a -> m a
trans' :: (Functor f, Monad m) => m (Free f a) -> FreeT f m a
untrans :: (Traversable f, Monad m) => FreeT f m a -> m (Free f a)
liftFree :: (Functor f, Monad m) => (a -> Free f b) -> (a -> FreeT f m b)
instance [overlap ok] Typeable Free
instance [overlap ok] Generic (Free f a)
instance Datatype D1Free
instance Constructor C1_0Free
instance Constructor C1_1Free
instance [overlap ok] (Functor f, Functor m, Monad m, MonadPlus m) => Alternative (FreeT f m)
instance [overlap ok] (Functor f, Monad m, MonadPlus m) => MonadPlus (FreeT f m)
instance [overlap ok] (Functor f, Monad m, MonadIO m) => MonadIO (FreeT f m)
instance [overlap ok] Functor f => MonadTrans (FreeT f)
instance [overlap ok] (Functor f, Monad m) => MonadFree f (FreeT f m)
instance [overlap ok] (Functor f, Monad m) => Monad (FreeT f m)
instance [overlap ok] (Functor f, Functor a, Monad a) => Applicative (FreeT f a)
instance [overlap ok] (Functor f, Functor m) => Functor (FreeT f m)
instance [overlap ok] (Traversable m, Traversable f) => Traversable (FreeT f m)
instance [overlap ok] (Traversable m, Traversable f) => Foldable (FreeT f m)
instance [overlap ok] Functor f => Applicative (Free f)
instance [overlap ok] Functor f => Monad (Free f)
instance [overlap ok] Traversable f => Traversable (Free f)
instance [overlap ok] (Functor f, Foldable f) => Foldable (Free f)
instance [overlap ok] Functor f => Functor (Free f)
instance [overlap ok] (Show a, Show1 f) => Show (Free f a)
instance [overlap ok] (Ord a, Ord1 f) => Ord (Free f a)
instance [overlap ok] Ord1 f => Ord1 (Free f)
instance [overlap ok] (Eq a, Eq1 f) => Eq (Free f a)
instance [overlap ok] Eq1 f => Eq1 (Free f)
instance [overlap ok] Functor f => MonadFree f (Free f)

module Control.Monad.Free.Zip
zipFree :: (Traversable f, Eq (f ()), Monad m) => (Free f a -> Free f b -> m (Free f c)) -> Free f a -> Free f b -> m (Free f c)
zipFree_ :: (Traversable f, Eq (f ()), Monad m) => (Free f a -> Free f b -> m ()) -> Free f a -> Free f b -> m ()


-- | Naive Free monads suffer from a quadratic complexity, as explained in
--   
--   <ul>
--   <li>Janis Voigtlander, <i>Asymptotic Improvement of Computations over
--   Free Monads, MPC'08</i></li>
--   </ul>
--   
--   The solution is to redefine the Free datatype in CPS, similar to what
--   is done in difference lists to solve the problem on quadratic append
--   for lists.
module Control.Monad.Free.Improve
newtype C mu a
C :: (forall b. (a -> mu b) -> mu b) -> C mu a
rep :: Monad mu => mu a -> C mu a
improve :: Monad mu => C mu a -> mu a
instance [overlap ok] MonadTrans C
instance [overlap ok] MonadPlus mu => Alternative (C mu)
instance [overlap ok] MonadPlus mu => MonadPlus (C mu)
instance [overlap ok] (Monad m, Functor f) => MonadFree f (C (FreeT f m))
instance [overlap ok] Functor f => MonadFree f (C (Free f))
instance [overlap ok] Applicative (C mu)
instance [overlap ok] Monad (C mu)
instance [overlap ok] Functor (C mu)
