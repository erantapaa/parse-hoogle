-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Apple property list parser
--   
@package property-list
@version 0.1.0.5


-- | The internal "algebraic" interface for working with property-list-like
--   things. The classes defined here are the basis for a very general
--   system supporting transformations between many property-list
--   representations, including both internal and external formats. The
--   transformations are based on algebra and are very well-behaved
--   mathematically. It is possible to "fuse" operations so that, for
--   example, reading from XML and writing to a text plist can be done
--   without creating any intermediate representations other than those
--   used by the XML parser and the text renderer. Or, expressions using
--   the "smart constructors" can be evaluated to directly synthesize
--   XML-formatted plists, or the view-pattern destructors can be used to
--   directly analyze them.
--   
--   The interface defined in this module is very heavily influenced by
--   category-theoretical constructions. In particular, F-algebras and
--   F-coalgebras, initiality, and terminality. For those not familiar with
--   these concepts, this will probably be quite incomprehensible. Sorry
--   about that. The basic idea, though, is the use of the
--   <a>PropertyListS</a> type as a sort of a central junction point
--   through which all conversions between property-list-like types and
--   property-list-item types are routed. The classes defined here are
--   chosen to minimize the inderdependence of these types and hence
--   maximize the flexibility of the system as a whole.
--   
--   More simply stated, these weird math thingies make the design as
--   flexible as possible (in a well-defined and useful sense).
module Data.PropertyList.Algebra

-- | The signature of the base property list algebra. This algebra is
--   "lifted" in various ways to support several different but similar
--   representations of property lists as well as projections and
--   injections. All the different representations are <tt>connected</tt>
--   through this signature.
--   
--   For example, <tt>PropertyList</tt> is a fixed-point of this signature
--   - that is, a recursive version where <tt>a</tt> is instantiated as
--   <tt><a>PropertyListS</a> a</tt>. That gives the "expected" structure
--   of a basic property list. It is both initial and terminal for this
--   signature in its 'un-lifted' form - which is to say, any other type
--   with an algebra for this signature (such as an XML representation) can
--   be made from a <tt>PropertyList</tt>, and any type with a coalgebra
--   for this signature (such as a <a>String</a>, an <a>Integer</a>, etc.)
--   can be converted directly to a <tt>PropertyList</tt>. This also means
--   that any transformation or series of transformations involving the
--   <tt>PropertyList</tt> type can be fused to "skip" generating
--   intermediate property lists, although there are currently no rewrite
--   rules set up to do so.
--   
--   Similarly, <tt>PartialPropertyList</tt> is a fixed point of an
--   arbitrarily- augmented version of this signature (also known as the
--   free monad generated by the signature). Depending on its type
--   parameter, <tt>PartialPropertyList</tt> can be terminal among many
--   simple extensions to the signature. Thus many types with a coalgebra
--   for an extension of this signature (such as XML given an appropriate
--   tree destructor, or the <tt>PropertyList</tt> type itself) can be
--   trivially converted to a <tt>PartialPropertyList</tt>.
data PropertyListS a
PLArray :: [a] -> PropertyListS a
PLData :: ByteString -> PropertyListS a
PLDate :: UTCTime -> PropertyListS a
PLDict :: (Map String a) -> PropertyListS a
PLReal :: Double -> PropertyListS a
PLInt :: Integer -> PropertyListS a
PLString :: String -> PropertyListS a
PLBool :: Bool -> PropertyListS a

-- | Construct a basic non-recursive algebra of property list items. This
--   is equivalent to pattern matching on <a>PropertyListS</a>.
foldPropertyListS :: ([a] -> t) -> (ByteString -> t) -> (UTCTime -> t) -> (Map String a -> t) -> (Double -> t) -> (Integer -> t) -> (String -> t) -> (Bool -> t) -> PropertyListS a -> t

-- | A class for types which can be constructed algebraically from the
--   <a>PropertyListS</a> signature (lifted by <tt>f</tt>) - in other
--   words, types which you can put property lists into.
--   
--   The <tt>f</tt>-lifting is provided to support extending the algebra.
--   The algebra is defined in a class rather than passing around functions
--   because most of the time for any given type there is only one algebra
--   you care about.
--   
--   Typically a renderer for an output format will be implemented as a
--   type with an <tt>instance <a>PListAlgebra</a> <a>Identity</a></tt>.
--   For example, the XML output system is implemented in the <tt>instance
--   <a>PListAlgebra</a> <a>Identity</a> <a>Plist</a></tt>.
class Functor f => PListAlgebra f a
plistAlgebra :: PListAlgebra f a => f (PropertyListS a) -> a

-- | An identification of the fact that the type <tt>a</tt> has an initial
--   plist algebra (under some lifting <tt>f</tt>). Functional dependencies
--   are in use - for any type, only one of its initial algebras (if
--   multiple apply, which they may because the same type may be initial
--   for multiple distinct liftings) can be chosen, and for any lifting
--   only one type's algebra may be chosen. This is to make types decidable
--   in the not-so-uncommon case where the lifting is encapsulated (eg, any
--   time <a>foldPList</a> is partially applied - for example, see the
--   signature of <a>fromPlist</a>).
--   
--   For cases where the lifting either needs to be chosen or needs to be
--   transformed to another lifting, <a>fromPlistWith</a> is provided. It
--   is based on the same definition as the default implementation of
--   <a>foldPList</a> but also inserts a chosen transformation of the
--   lifting.
--   
--   Question for self: Is the PListCoalgebra context reasonable here? Some
--   rough calculations suggest that in the presence of fixed point type
--   operators, it is possible to construct a PListCoalgebra for any
--   InitialPList, which essentially is defined as pattern matching. So,
--   I'm not totally sure but I think this is reasonable - at least, for
--   finitary signatures, which we're using as long as <tt>f</tt> doesn't
--   go crazy.
class (PListAlgebra f a, PListCoalgebra f a) => InitialPList f a | f -> a, a -> f where foldPList f = go where go = f . fmap (fmap go) . plistCoalgebra
foldPList :: InitialPList f a => (f (PropertyListS t) -> t) -> a -> t

-- | Convert from an initial plist to any other plist with the same lifted
--   algebra.
fromPlist :: (InitialPList f pl, PListAlgebra f t) => pl -> t
fromPlistWith :: (PListCoalgebra f pl, PListAlgebra g t) => (f (PropertyListS t) -> g (PropertyListS t)) -> pl -> t

-- | A class for types which can be dissected (pattern-matched) into the
--   <a>PropertyListS</a> signature (lifted by <tt>f</tt>) - in other
--   words, types which you can take property lists out of.
--   
--   Typically a property list parser will be implemented as a type with a
--   <a>PListCoalgebra</a> instance, where <tt>f</tt> is either
--   <a>Identity</a> in the case where the parser guarantees to return a
--   fully well-formed property list (assuming it returns anything at all)
--   or <a>Either</a> <tt>something</tt> when the parser only guarantees
--   that the structure is sound (but that some elements might be
--   defective, in which case a value of type <tt>something</tt> would be
--   substituted). The XML parser, for example, is based on the latter
--   approach, where <tt>something</tt> is <tt>UnparsedPlistItem</tt>.
class Functor f => PListCoalgebra f a
plistCoalgebra :: PListCoalgebra f a => a -> f (PropertyListS a)

-- | Chosen terminal coalgebra for the given lifting, and chosen lifting
--   for the given type. See also <a>InitialPList</a>.
class (PListCoalgebra f a, PListAlgebra f a) => TerminalPList f a | f -> a, a -> f where unfoldPList f = go where go = plistAlgebra . fmap (fmap go) . f
unfoldPList :: TerminalPList f a => (t -> f (PropertyListS t)) -> t -> a

-- | Convert from any plist-like thing to a plist which is terminal for a
--   some lifted algebra.
toPlist :: (PListCoalgebra f t, TerminalPList f pl) => t -> pl
toPlistWith :: (PListCoalgebra f t, PListAlgebra g pl) => (f (PropertyListS t) -> g (PropertyListS t)) -> t -> pl
plArray :: PListAlgebra Identity a => [a] -> a
plData :: PListAlgebra Identity a => ByteString -> a
plDate :: PListAlgebra Identity a => UTCTime -> a
plDict :: PListAlgebra Identity a => Map String a -> a
plReal :: PListAlgebra Identity a => Double -> a
plInt :: PListAlgebra Identity a => Integer -> a
plString :: PListAlgebra Identity a => String -> a
plBool :: PListAlgebra Identity a => Bool -> a
fromPlArray :: PListCoalgebra Maybe a => a -> Maybe [a]
fromPlData :: PListCoalgebra Maybe a => a -> Maybe ByteString
fromPlDate :: PListCoalgebra Maybe a => a -> Maybe UTCTime
fromPlDict :: PListCoalgebra Maybe a => a -> Maybe (Map String a)
fromPlReal :: PListCoalgebra Maybe a => a -> Maybe Double
fromPlInt :: PListCoalgebra Maybe a => a -> Maybe Integer
fromPlString :: PListCoalgebra Maybe a => a -> Maybe String
fromPlBool :: PListCoalgebra Maybe a => a -> Maybe Bool
instance Eq a => Eq (PropertyListS a)
instance Ord a => Ord (PropertyListS a)
instance Show a => Show (PropertyListS a)
instance Read a => Read (PropertyListS a)
instance Traversable PropertyListS
instance Foldable PropertyListS
instance Functor PropertyListS

module Data.PropertyList.Binary
newtype BPListHeader
BPListHeader :: Word16 -> BPListHeader
bplistVersion :: BPListHeader -> Word16
data BPListTrailer
BPListTrailer :: !Word8 -> !Word8 -> !Word8 -> !Word64 -> !Word64 -> !Word64 -> BPListTrailer
sortVersion :: BPListTrailer -> !Word8
offsetIntSize :: BPListTrailer -> !Word8
objectRefSize :: BPListTrailer -> !Word8
numObjects :: BPListTrailer -> !Word64
topObject :: BPListTrailer -> !Word64
offsetTableOffset :: BPListTrailer -> !Word64
data BPListRecord
BPLNull :: BPListRecord
BPLFill :: BPListRecord
BPLArray :: [Word64] -> BPListRecord
BPLSet :: [Word64] -> BPListRecord
BPLData :: ByteString -> BPListRecord
BPLDate :: UTCTime -> BPListRecord
BPLDict :: [Word64] -> [Word64] -> BPListRecord
BPLReal :: Double -> BPListRecord
BPLInt :: Integer -> BPListRecord
BPLString :: String -> BPListRecord
BPLUID :: Integer -> BPListRecord
BPLBool :: Bool -> BPListRecord
data BPListRecords mode
BPListRecords :: Word64 -> Seq BPListRecord -> BPListRecords mode
rootObject :: BPListRecords mode -> Word64
records :: BPListRecords mode -> Seq BPListRecord
readBPListRecords :: ByteString -> Either String (BPListRecords Abs)
putBPList :: BPListRecords t -> PutM ()
data Abs
data Rel

-- | Flatten a <a>PropertyList</a> to a sequence of <a>BPListRecords</a>.
--   The resulting records will use absolute addressing and will not have
--   any duplicates.
linearize :: PropertyList -> BPListRecords Abs

-- | Reconstruct a property list from a collection of <a>BPListRecords</a>
delinearize :: BPListRecords Abs -> PartialPropertyList UnparsedBPListRecord

-- | Take some <a>BPListRecords</a> using relative addressing and change
--   them to use absolute addressing
absolutize :: BPListRecords Rel -> BPListRecords Abs

-- | Take some <a>BPListRecords</a> using absolute addressing and eliminate
--   all duplicate records, compact the table and update all internal
--   references.
--   
--   Does not necessarily yield a totally deduplicated table; The process
--   of interning can introduce duplicate records (because it alters
--   arrays, dicts and sets). All other node types will be deduplicated in
--   one pass, though, which is usually sufficient.
intern :: BPListRecords Abs -> BPListRecords Abs
data UnparsedBPListRecord
UnparsedNull :: UnparsedBPListRecord
UnparsedFill :: UnparsedBPListRecord
MissingObjectRef :: Word64 -> UnparsedBPListRecord
UnparsedDict :: [Word64] -> [Word64] -> UnparsedBPListRecord
UnparsedSet :: [Word64] -> UnparsedBPListRecord
UnparsedUID :: Integer -> UnparsedBPListRecord
readBinaryPartialPropertyList :: ByteString -> Either String (PartialPropertyList UnparsedBPListRecord)
readBinaryPartialPropertyListFromFile :: FilePath -> IO (PartialPropertyList UnparsedBPListRecord)
readBinaryPropertyList :: ByteString -> Either String PropertyList
readBinaryPropertyListFromFile :: FilePath -> IO PropertyList
encodeBinaryPropertyList :: PropertyList -> ByteString
writeBinaryPropertyListToFile :: FilePath -> PropertyList -> IO ()

module Data.PropertyList.Xml

-- | A representation of values that were structurally sound in the
--   property list file but the contents of which couldn't be interpreted
--   as what they claimed to be. The result of the initial parse phase will
--   typically be a <tt>PartialPropertyList UnparsedXmlPlistItem</tt>, and
--   if the whole plist was parsed properly will contain no actual values
--   of this type.
data UnparsedXmlPlistItem
UnparsedData :: String -> UnparsedXmlPlistItem
UnparsedDate :: String -> UnparsedXmlPlistItem
UnparsedInt :: String -> UnparsedXmlPlistItem
UnparsedReal :: String -> UnparsedXmlPlistItem
UnparsedXml :: Element -> UnparsedXmlPlistItem
unparsedXmlPlistItemToElement :: UnparsedXmlPlistItem -> Element

-- | Read a property list from a <a>String</a> in the xml1 format. If
--   parsing fails, returns a description of the problem in the <a>Left</a>
--   result.
readXmlPropertyList :: String -> Either String PropertyList

-- | Read a property list from a file in the xml1 format. If parsing fails,
--   calls <a>fail</a>.
readXmlPropertyListFromFile :: FilePath -> IO PropertyList

-- | Read an XML property list from a <a>String</a> in the xml1 plist
--   format, leaving unparseable elements in the tree.
readXmlPartialPropertyList :: String -> Either String (PartialPropertyList UnparsedXmlPlistItem)

-- | Render a propertylist to a <a>String</a> in the xml1 plist format from
--   any initial propertylist type (which includes <a>PropertyList</a>,
--   <tt><a>PartialPropertyList</a> <tt>UnparsedPlistItem</tt></tt>, and
--   <tt><a>PartialPropertyList</a> <tt>PlistItem</tt></tt>).
showXmlPropertyList :: (InitialPList f pl, PListAlgebra f Element) => pl -> String

-- | Read an XML propertylist from a file in the xml1 plist format to a
--   partial propertylist which is structurally sound but may contain some
--   unparseable nodes.
readXmlPartialPropertyListFromFile :: FilePath -> IO (PartialPropertyList UnparsedXmlPlistItem)

-- | Output a propertylist to a file in the xml1 plist format from any
--   initial propertylist type (which includes <a>PropertyList</a>,
--   <tt><a>PartialPropertyList</a> <tt>UnparsedPlistItem</tt></tt>, and
--   <tt><a>PartialPropertyList</a> <tt>PlistItem</tt></tt>).
writeXmlPropertyListToFile :: FilePath -> PropertyList -> IO ()

module Data.PropertyList

-- | A fully-parsed property list.
data PropertyList

-- | A partially-parsed property-list term algebra, parameterized over the
--   type of "structural holes" in the terms.
data PartialPropertyList a
data UnparsedBPListRecord
UnparsedNull :: UnparsedBPListRecord
UnparsedFill :: UnparsedBPListRecord
MissingObjectRef :: Word64 -> UnparsedBPListRecord
UnparsedDict :: [Word64] -> [Word64] -> UnparsedBPListRecord
UnparsedSet :: [Word64] -> UnparsedBPListRecord
UnparsedUID :: Integer -> UnparsedBPListRecord

-- | A representation of values that were structurally sound in the
--   property list file but the contents of which couldn't be interpreted
--   as what they claimed to be. The result of the initial parse phase will
--   typically be a <tt>PartialPropertyList UnparsedXmlPlistItem</tt>, and
--   if the whole plist was parsed properly will contain no actual values
--   of this type.
data UnparsedXmlPlistItem
UnparsedData :: String -> UnparsedXmlPlistItem
UnparsedDate :: String -> UnparsedXmlPlistItem
UnparsedInt :: String -> UnparsedXmlPlistItem
UnparsedReal :: String -> UnparsedXmlPlistItem
UnparsedXml :: Element -> UnparsedXmlPlistItem
plArray :: PListAlgebra Identity a => [a] -> a
fromPlArray :: PListCoalgebra Maybe a => a -> Maybe [a]
plData :: PListAlgebra Identity a => ByteString -> a
fromPlData :: PListCoalgebra Maybe a => a -> Maybe ByteString
plDate :: PListAlgebra Identity a => UTCTime -> a
fromPlDate :: PListCoalgebra Maybe a => a -> Maybe UTCTime
plDict :: PListAlgebra Identity a => Map String a -> a
fromPlDict :: PListCoalgebra Maybe a => a -> Maybe (Map String a)
plReal :: PListAlgebra Identity a => Double -> a
fromPlReal :: PListCoalgebra Maybe a => a -> Maybe Double
plInt :: PListAlgebra Identity a => Integer -> a
fromPlInt :: PListCoalgebra Maybe a => a -> Maybe Integer
plString :: PListAlgebra Identity a => String -> a
fromPlString :: PListCoalgebra Maybe a => a -> Maybe String
plBool :: PListAlgebra Identity a => Bool -> a
fromPlBool :: PListCoalgebra Maybe a => a -> Maybe Bool

-- | A class for types which can be constructed algebraically from the
--   <a>PropertyListS</a> signature (lifted by <tt>f</tt>) - in other
--   words, types which you can put property lists into.
--   
--   The <tt>f</tt>-lifting is provided to support extending the algebra.
--   The algebra is defined in a class rather than passing around functions
--   because most of the time for any given type there is only one algebra
--   you care about.
--   
--   Typically a renderer for an output format will be implemented as a
--   type with an <tt>instance <a>PListAlgebra</a> <a>Identity</a></tt>.
--   For example, the XML output system is implemented in the <tt>instance
--   <a>PListAlgebra</a> <a>Identity</a> <a>Plist</a></tt>.
class Functor f => PListAlgebra f a

-- | A class for types which can be dissected (pattern-matched) into the
--   <a>PropertyListS</a> signature (lifted by <tt>f</tt>) - in other
--   words, types which you can take property lists out of.
--   
--   Typically a property list parser will be implemented as a type with a
--   <a>PListCoalgebra</a> instance, where <tt>f</tt> is either
--   <a>Identity</a> in the case where the parser guarantees to return a
--   fully well-formed property list (assuming it returns anything at all)
--   or <a>Either</a> <tt>something</tt> when the parser only guarantees
--   that the structure is sound (but that some elements might be
--   defective, in which case a value of type <tt>something</tt> would be
--   substituted). The XML parser, for example, is based on the latter
--   approach, where <tt>something</tt> is <tt>UnparsedPlistItem</tt>.
class Functor f => PListCoalgebra f a

-- | An identification of the fact that the type <tt>a</tt> has an initial
--   plist algebra (under some lifting <tt>f</tt>). Functional dependencies
--   are in use - for any type, only one of its initial algebras (if
--   multiple apply, which they may because the same type may be initial
--   for multiple distinct liftings) can be chosen, and for any lifting
--   only one type's algebra may be chosen. This is to make types decidable
--   in the not-so-uncommon case where the lifting is encapsulated (eg, any
--   time <a>foldPList</a> is partially applied - for example, see the
--   signature of <a>fromPlist</a>).
--   
--   For cases where the lifting either needs to be chosen or needs to be
--   transformed to another lifting, <a>fromPlistWith</a> is provided. It
--   is based on the same definition as the default implementation of
--   <a>foldPList</a> but also inserts a chosen transformation of the
--   lifting.
--   
--   Question for self: Is the PListCoalgebra context reasonable here? Some
--   rough calculations suggest that in the presence of fixed point type
--   operators, it is possible to construct a PListCoalgebra for any
--   InitialPList, which essentially is defined as pattern matching. So,
--   I'm not totally sure but I think this is reasonable - at least, for
--   finitary signatures, which we're using as long as <tt>f</tt> doesn't
--   go crazy.
class (PListAlgebra f a, PListCoalgebra f a) => InitialPList f a | f -> a, a -> f where foldPList f = go where go = f . fmap (fmap go) . plistCoalgebra

-- | Chosen terminal coalgebra for the given lifting, and chosen lifting
--   for the given type. See also <a>InitialPList</a>.
class (PListCoalgebra f a, PListAlgebra f a) => TerminalPList f a | f -> a, a -> f where unfoldPList f = go where go = plistAlgebra . fmap (fmap go) . f

-- | Read a property list from a file, trying all supported property list
--   formats. Presently, the "XML1" and "bplist00" formats are supported.
--   See also <a>readXmlPropertyListFromFile</a> and
--   <a>readBinaryPropertyListFromFile</a>.
readPropertyListFromFile :: FilePath -> IO PropertyList

-- | Write a property list to a file, using a "preferred" property list
--   format. Presently, that is the "XML1" format. See also
--   <a>writeXmlPropertyListToFile</a>.
writePropertyListToFile :: FilePath -> PropertyList -> IO ()
readBinaryPropertyList :: ByteString -> Either String PropertyList
encodeBinaryPropertyList :: PropertyList -> ByteString
readBinaryPropertyListFromFile :: FilePath -> IO PropertyList
writeBinaryPropertyListToFile :: FilePath -> PropertyList -> IO ()

-- | Read a property list from a <a>String</a> in the xml1 format. If
--   parsing fails, returns a description of the problem in the <a>Left</a>
--   result.
readXmlPropertyList :: String -> Either String PropertyList

-- | Render a propertylist to a <a>String</a> in the xml1 plist format from
--   any initial propertylist type (which includes <a>PropertyList</a>,
--   <tt><a>PartialPropertyList</a> <tt>UnparsedPlistItem</tt></tt>, and
--   <tt><a>PartialPropertyList</a> <tt>PlistItem</tt></tt>).
showXmlPropertyList :: (InitialPList f pl, PListAlgebra f Element) => pl -> String

-- | Read a property list from a file in the xml1 format. If parsing fails,
--   calls <a>fail</a>.
readXmlPropertyListFromFile :: FilePath -> IO PropertyList

-- | Output a propertylist to a file in the xml1 plist format from any
--   initial propertylist type (which includes <a>PropertyList</a>,
--   <tt><a>PartialPropertyList</a> <tt>UnparsedPlistItem</tt></tt>, and
--   <tt><a>PartialPropertyList</a> <tt>PlistItem</tt></tt>).
writeXmlPropertyListToFile :: FilePath -> PropertyList -> IO ()

-- | A class for items which can be converted to and from property lists.
--   This is more general than <a>PListAlgebra</a> and
--   <a>PListCoalgebra</a>, in that it allows for transformations that are
--   not primitive-recursive. This relaxation is necessary and desirable in
--   the <a>PropertyListItem</a> situation because we are more interested
--   in composable injection/projection operations on than in universal
--   maps.
--   
--   The algebraic interface also cannot work for arrays or dictionaries,
--   because it only allows primitive (co-)recursion - the conversions can
--   only operate on one "layer" of <a>PropertyListS</a> at a time. This
--   could be handled by enlarging the types (from [t] to Either t [t], for
--   example) or by encoding in-band (by taking a singleton list to be an
--   element instead of a list, for example), but both of those "solutions"
--   create headaches of their own, and in any case the algebraic interface
--   is probably too bizarre for most users.
class PropertyListItem i where listToPropertyList = plArray . map toPropertyList listFromPropertyList (fromPlArray -> Just x) = mapM fromPropertyList x listFromPropertyList _ = Nothing
toPropertyList :: PropertyListItem i => i -> PropertyList
fromPropertyList :: PropertyListItem i => PropertyList -> Maybe i
listToPropertyList :: PropertyListItem i => [i] -> PropertyList
listFromPropertyList :: PropertyListItem i => PropertyList -> Maybe [i]

-- | <tt>alterItemAtKeyPathM path f</tt> applies the function <tt>f</tt>
--   deep inside the <a>PropertyList</a> on the property list item at the
--   given key-path <tt>path</tt> (if possible). This is the same notion of
--   key path as is used in the Apple plist APIs - each component of the
--   path indicates descending into a dictionary by selecting the element
--   with that key (if any). If a key is not found, it is created. If a key
--   is found but is not a dictionary, the operation fails (with
--   <a>fail</a> from the <a>Monad</a> class).
--   
--   If the result of <tt>f</tt> is <a>Nothing</a>, and the resulting
--   dictionary is empty, that dictionary is deleted in the result (and any
--   empty parent dictionaries). If this is not the behavior you want, you
--   should alter the parent dictionary itself and return an empty one.
alterItemAtKeyPathM :: (Monad m, PropertyListItem i, PropertyListItem i') => [String] -> (Maybe i -> m (Maybe i')) -> Maybe PropertyList -> m (Maybe PropertyList)

-- | <tt>alterItemAtKeyPath path f</tt> applies the function <tt>f</tt>
--   deep inside the <a>PropertyList</a> on the property list item at the
--   given key-path <tt>path</tt> (if possible). This is the same notion of
--   key path as is used in the Apple plist APIs - namely, each component
--   of the path indicates descending into a dictionary by selecting the
--   element with that key (if any). If a key is not found, it is created.
--   If a key is found but is not a dictionary, the operation fails (with
--   <a>error</a>).
--   
--   If the result of <tt>f</tt> is <a>Nothing</a>, and the resulting
--   dictionary is empty, that dictionary is deleted in the result (and any
--   empty parent dictionaries). If this is not the behavior you want, you
--   should alter the parent dictionary itself and return an empty one.
alterItemAtKeyPath :: (PropertyListItem i, PropertyListItem i') => [String] -> (Maybe i -> Maybe i') -> Maybe PropertyList -> Maybe PropertyList

-- | Gets the item, if any (and if convertible to the required type), at a
--   given key path. If the key path passes through something that is not a
--   dictionary, the operation returns <a>Nothing</a>.
getItemAtKeyPath :: PropertyListItem i => [String] -> Maybe PropertyList -> Maybe i

-- | Sets the item at a given key-path. If the key path does not exist, it
--   is created. If it exists but passes through something that is not a
--   dictionary, the operation fails (with <a>error</a>)
setItemAtKeyPath :: PropertyListItem i => [String] -> Maybe i -> Maybe PropertyList -> Maybe PropertyList
