-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Combinators for rendering EDE templates in servant web applications
--   
@package servant-ede
@version 0.5

module Servant.EDE.Internal.Validate
data Validated e a
OK :: a -> Validated e a
NotOK :: e -> Validated e a
validateEither :: Either e a -> Validated e a
eitherValidate :: Validated e a -> Either e a
ok :: Applicative m => a -> ValidateT e m a
no :: Applicative m => e -> ValidateT e m a
validated :: (e -> r) -> (a -> r) -> Validated e a -> r
newtype ValidateT e m a
VT :: m (Validated e a) -> ValidateT e m a
runValidateT :: ValidateT e m a -> m (Validated e a)
validate :: m (Validated e a) -> ValidateT e m a
instance (Eq e, Eq a) => Eq (Validated e a)
instance (Show e, Show a) => Show (Validated e a)
instance (Applicative m, Semigroup e, Semigroup a) => Semigroup (ValidateT e m a)
instance (Applicative m, Semigroup e) => Applicative (ValidateT e m)
instance Functor m => Functor (ValidateT e m)
instance (Semigroup e, Semigroup a) => Semigroup (Validated e a)
instance Traversable (Validated e)
instance Foldable (Validated e)
instance Semigroup e => Applicative (Validated e)
instance Functor (Validated e)

module Servant.EDE.Internal.ToObject

-- | Turn haskell values into JSON objects.
--   
--   This is the mechanism used by EDE to marshall data from Haskell to the
--   templates. The rendering is then just about feeding the resulting
--   <a>Object</a> to a compiled <tt>Template</tt>. Example:
--   
--   <pre>
--   import Text.EDE
--   
--   data User = User { name :: String, age :: Int }
--   
--   instance ToObject User where
--     toObject user =
--       fromPairs [ "name" .= name user
--                 , "age"  .= age user
--                 ]
--   </pre>
--   
--   However, you're not forced to write the instance yourself for such a
--   type. Indeed, for any record type (i.e a datatype with a single
--   constructor and with field selectors) you can let
--   <tt>GHC.Generics</tt> derive the <a>ToObject</a> instance for you.
--   
--   <pre>
--   data User = User { name :: String, age :: Int } deriving Generic
--   instance ToObject User
--   </pre>
--   
--   This will generate an equivalent instance to the previous one.
class ToObject a where toObject = genericToObject
toObject :: ToObject a => a -> Object
class GToObject f
gtoObject :: GToObject f => f a -> Object
genericToObject :: (Generic a, GToObject (Rep a)) => a -> Object
instance (Selector s, ToJSON a) => GToObject (M1 S s (K1 r a))
instance GToObject a => GToObject (M1 C c a)
instance GToObject a => GToObject (M1 D d a)
instance (GToObject f, GToObject g) => GToObject (f :*: g)
instance GToObject U1
instance GToObject V1
instance ToObject (HashMap Text Value)

module Servant.EDE.Internal.Reify

-- | Helper class to reify a type-level list of strings into a value-level
--   list of string. Used to turn the type-level list of template file
--   names into a value-level list.
class Reify (symbols :: [Symbol])
reify :: Reify symbols => Proxy symbols -> [String]
instance (KnownSymbol s, Reify symbols) => Reify (s : symbols)
instance Reify '[]

module Servant.EDE.Internal


-- | Rendering EDE templates with servant.
--   
--   This package provides two combinators to be used as content-types with
--   servant (i.e just like <a>JSON</a>), <a>HTML</a> and <a>Tpl</a>.
--   
--   <ul>
--   <li><a>HTML</a> takes a filename as parameter and lets you render the
--   template with that name against the data returned by a request handler
--   using the <tt>text/html;charset=utf-8</tt> MIME type, XSS-sanitizing
--   the said data along the way. See <a>HTML</a> for an example.</li>
--   <li><a>Tpl</a> does the same except that it's parametrized over the
--   content type to be sent along with the rendered template. Any type
--   that has an <a>Accept</a> instance will do. See <a>Tpl</a> for an
--   example.</li>
--   </ul>
module Servant.EDE

-- | <a>HTML</a> content type, but more than just that.
--   
--   <a>HTML</a> takes a type-level string which is a filename for the
--   template you want to use to render values. Just like <a>Tpl</a>, types
--   used with the <a>HTML</a> content type (like <tt>User</tt> below) must
--   provide a <a>ToObject</a> instance.
--   
--   Example:
--   
--   <pre>
--   type UserAPI = "user" :&gt; Get '[JSON, HTML "user.tpl"] User
--   
--   userAPI :: Proxy UserAPI
--   userAPI = Proxy
--   
--   data User = User { name :: String, age :: Int } deriving Generic
--   
--   instance ToObject User
--   
--   server :: Server API
--   server = return (User "lambdabot" 31)
--   
--   main :: IO ()
--   main = do
--     loadTemplates userAPI "./templates"
--     run 8082 (serve userAPI server)
--   </pre>
--   
--   This will look for a template at <tt>./templates/user.tpl</tt>, which
--   could for example be:
--   
--   <pre>
--   &lt;ul&gt;
--     &lt;li&gt;&lt;strong&gt;Name:&lt;/strong&gt; {{ name }}&lt;/li&gt;
--     &lt;li&gt;&lt;strong&gt;Age:&lt;/strong&gt; {{ age }}&lt;/li&gt;
--   &lt;/ul&gt;
--   </pre>
--   
--   <i>IMPORTANT</i>: it XSS-sanitizes every bit of text in the
--   <a>Object</a> passed to the template.
data HTML (file :: Symbol)

-- | A generic template combinator, parametrized over the content-type (or
--   MIME) associated to the template.
--   
--   The first parameter is the content-type you want to send along with
--   rendered templates (must be an instance of <a>Accept</a>).
--   
--   The second parameter is the name of (or path to) the template file. It
--   must live under the <a>FilePath</a> argument of <a>loadTemplates</a>.
--   
--   Any type used with this content-type (like <tt>CSSData</tt> below)
--   must have an instance of the <a>ToObject</a> class. The field names
--   become the variable names in the template world.
--   
--   Here is how you could render and serve, say, <i>CSS</i> (Cascading
--   Style Sheets) templates that make use of some <tt>CSSData</tt> data
--   type to tweak the styling.
--   
--   <pre>
--   data CSS
--   
--   instance Accept CSS where
--     contentType _ = "text" // "css"
--   
--   type StyleAPI = "style.css" :&gt; Get '[Tpl CSS "style.tpl"] CSSData
--   
--   styleAPI :: Proxy StyleAPI
--   styleAPI = Proxy
--   
--   data CSSData = CSSData
--     { darken :: Bool
--     , pageWidth :: Int
--     } deriving Generic
--   
--   instance ToObject CSSData
--   
--   server :: Server API
--   server = -- produce a CSSData value depending on whatever is relevant...
--   
--   main :: IO ()
--   main = do
--     loadTemplates styleAPI "./templates"
--     run 8082 (serve styleAPI server)
--   </pre>
--   
--   This will look for a template at <tt>./templates/style.tpl</tt>, which
--   could for example be:
--   
--   <pre>
--   body {
--     {% if darken %}
--     background-color: #222222;
--     color: blue;
--     {% else %}
--     background-color: white;
--     color: back;
--     {% endif %}
--   }
--   
--   #content {
--     width: {{ pageWidth }};
--     margin: 0 auto;
--   }
--   </pre>
--   
--   A complete, runnable version of this can be found in the
--   <tt>examples</tt> folder of the git repository.
data Tpl (ct :: *) (file :: Symbol)

-- | Turn haskell values into JSON objects.
--   
--   This is the mechanism used by EDE to marshall data from Haskell to the
--   templates. The rendering is then just about feeding the resulting
--   <a>Object</a> to a compiled <tt>Template</tt>. Example:
--   
--   <pre>
--   import Text.EDE
--   
--   data User = User { name :: String, age :: Int }
--   
--   instance ToObject User where
--     toObject user =
--       fromPairs [ "name" .= name user
--                 , "age"  .= age user
--                 ]
--   </pre>
--   
--   However, you're not forced to write the instance yourself for such a
--   type. Indeed, for any record type (i.e a datatype with a single
--   constructor and with field selectors) you can let
--   <tt>GHC.Generics</tt> derive the <a>ToObject</a> instance for you.
--   
--   <pre>
--   data User = User { name :: String, age :: Int } deriving Generic
--   instance ToObject User
--   </pre>
--   
--   This will generate an equivalent instance to the previous one.
class ToObject a where toObject = genericToObject
toObject :: ToObject a => a -> Object

-- | This function initializes a global template store (i.e a
--   <a>Templates</a> value) and fills it with the resulting compiled
--   templates if all of them are compiled successfully. If that's not the
--   case, the global template store (under an <a>MVar</a>) is left empty.
--   
--   <i>IMPORTANT</i>: Must <i>always</i> be called before starting your
--   <i>servant</i> application. Example:
--   
--   <pre>
--   type API = Get '[HTML "home.tpl"] HomeData
--   
--   api :: Proxy API
--   api = Proxy
--   
--   main :: IO ()
--   main = loadTemplates api "path/to/templates" &gt;&gt;= print
--   </pre>
--   
--   This would try to load <tt>home.tpl</tt>, printing any error or
--   registering the compiled template in a global (but safe) compiled
--   template store, if successfully compiled.
loadTemplates :: (Reify (TemplateFiles api), Applicative m, MonadIO m) => Proxy api -> FilePath -> m Errors

-- | Collect all the template filenames of an API as a type-level list of
--   strings, by simply looking at all occurences of the <a>Tpl</a> and
--   <a>HTML</a> combinators and keeping the filenames associated to them.

-- | Helper class to reify a type-level list of strings into a value-level
--   list of string. Used to turn the type-level list of template file
--   names into a value-level list.
class Reify (symbols :: [Symbol])

-- | An opaque "compiled-template store".
--   
--   The only way to get a value of this type is to use
--   <a>loadTemplates</a> on a proxy of your API.
--   
--   This ensures that when we lookup a template (in order to render it) in
--   our <a>Templates</a> store, we are guaranteed to find it.
data Templates

-- | A list of <a>TemplateError</a>s.
type Errors = [TemplateError]

-- | A <a>TemplateError</a> is a pair of a template filename and the error
--   string for that file.
type TemplateError = (FilePath, String)
instance Eq Templates
instance Monoid Templates
instance Semigroup Templates
instance (KnownSymbol file, ToObject a) => MimeRender (HTML file) a
instance Accept (HTML file)
instance (KnownSymbol file, Accept ct, ToObject a) => MimeRender (Tpl ct file) a
instance Accept ct => Accept (Tpl ct file)
