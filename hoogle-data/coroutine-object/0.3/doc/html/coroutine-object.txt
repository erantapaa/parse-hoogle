-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Object-oriented programming realization using coroutine
--   
@package coroutine-object
@version 0.3

module Control.Monad.Trans.Crtn.Queue
data Queue a
Queue :: [a] -> [a] -> Queue a
fqueue :: Queue a -> [a]
bqueue :: Queue a -> [a]
emptyQueue :: Queue a
enqueue :: a -> Queue a -> Queue a
dequeue :: Queue a -> (Queue a, Maybe a)
instance Show a => Show (Queue a)


-- | coroutine that can be interpreted as an object
module Control.Monad.Trans.Crtn.Event

-- | action order
data ActionOrder e
ActionOrder :: ((e -> IO ()) -> IO e) -> ActionOrder e

-- | event or action
type EvOrAct e = Either (ActionOrder e) e


-- | definition of coroutine
module Control.Monad.Trans.Crtn

-- | yield command functor
data Yld o x
Yld :: o -> x -> Yld o x

-- | Generator type is single-sided coroutine which only gives an output
--   without getting any request.
type GenT o = FreeT (Yld o)

-- | primitive coroutine action yielding an output
yield :: Monad m => o -> GenT o m ()

-- | await command functor for consumer coroutine
newtype Awt a x
Awt :: (a -> x) -> Awt a x

-- | Consumer type is a single-sided coroutine which only gets an input
--   without producing output.
type CnsmT a = FreeT (Awt a)

-- | primitive coroutine action awaiting an input
await :: Monad m => CnsmT a m a

-- | command functor of general bidirectional coroutine
data Rqst req ans x
Rqst :: req -> (ans -> x) -> Rqst req ans x

-- | general symmetric bidirectional coroutine
type CrtnT req ans = FreeT (Rqst req ans)

-- | primitive request coroutine
request :: Monad m => req -> CrtnT req ans m ans

-- | Server type
type SrvT req ans m = ReaderT req (CrtnT ans req m)

-- | Coroutine type is regarded as a Client type which can be paired with
--   Server type with opposite request and answer type.
type CliT req ans = CrtnT req ans

-- | type for coroutine status after execution
data CrtnErr
ServerFinished :: CrtnErr
Other :: String -> CrtnErr

-- | connecting server and client in error monad
(<==|) :: Monad m => SrvT req ans m r' -> CliT req ans m r -> m (Either CrtnErr (SrvT req ans m r', r))

-- | combine state and free monad with base state monad transformer with a
--   base monad m to free monad with the base monad m Think this as fusing
--   down the state monad
mapStateDown :: (Monad m, Functor f) => s -> FreeT f (StateT s m) a -> FreeT f m a
instance Show CrtnErr
instance Functor (Rqst req ans)
instance Functor (Awt g)
instance Functor (Yld o)
instance (Monad m, MonadState st m, Functor f) => MonadState st (FreeT f m)


-- | coroutine that can be interpreted as an object
module Control.Monad.Trans.Crtn.Object

-- | input of method of an object with signature s
data Arg s
Arg :: (s i o) -> i -> Arg s

-- | output of methdo of an object with signature s
data Res s
Res :: (s i o) -> o -> Res s
Ign :: Res s

-- | Server object
type SObjT s m = SrvT (Arg s) (Res s) m

-- | Client object
type CObjT s = CliT (Arg s) (Res s)

-- | Server object base coroutine
type SObjBT s m = CrtnT (Res s) (Arg s) m

-- | convenient error state monad for object
type EStT s m = EitherT CrtnErr (StateT s m)
query :: Monad m => CObjT s m r -> EStT (SObjT s m ()) m r


-- | describe logger
module Control.Monad.Trans.Crtn.Logger
class Monad m => MonadLog m
scribe :: MonadLog m => String -> m ()
data LogOp i o
WriteLog :: LogOp String ()
type LogInput = Arg LogOp
type LogServer m r = SObjT LogOp m r
type LogClient m r = CObjT LogOp m r
writeLog :: Monad m => String -> LogClient m ()
instance [overlap ok] MonadLog IO
instance [overlap ok] (MonadTrans t, MonadLog m, Monad (t m)) => MonadLog (t m)


-- | describe world object
module Control.Monad.Trans.Crtn.World
data WorldOp e m i o
GiveEvent :: WorldOp e m e ()
FlushLog :: WorldOp e m (LogServer m ()) (LogServer m ())
FlushQueue :: WorldOp e m () [Either (ActionOrder e) e]
type World e m r = SObjT (WorldOp e m) m r
giveEvent :: Monad m => e -> CObjT (WorldOp e m) m ()
flushLog :: Monad m => LogServer m () -> CObjT (WorldOp e m) m (LogServer m ())
flushQueue :: Monad m => CObjT (WorldOp e m) m [Either (ActionOrder e) e]


-- | IO event driverzo
module Control.Monad.Trans.Crtn.Driver

-- | signature of IO event driver
data DrvOp e i o
Dispatch :: DrvOp e e (Maybe (ActionOrder e))

-- | driver
type Driver e m = SObjT (DrvOp e) m

-- | driver client
type DrvClient e m r = CObjT (DrvOp e) m r
dispatch :: Monad m => e -> DrvClient e m (Maybe (ActionOrder e))

-- | basic driver
driver :: (Monad m, MonadLog m, MonadIO m) => LogServer (SObjBT (DrvOp e) m) () -> SObjT (WorldOp e (SObjBT (DrvOp e) m)) (SObjBT (DrvOp e) m) () -> Driver e m ()

-- | single event dispatch
singleDispatch :: Monad m => Either (ActionOrder e) e -> (LogServer (SObjBT (DrvOp e) m) (), World e (SObjBT (DrvOp e) m) (), [EvOrAct e]) -> SObjBT (DrvOp e) m (LogServer (SObjBT (DrvOp e) m) (), World e (SObjBT (DrvOp e) m) (), [EvOrAct e])

-- | a single feedback step of multiple event dispatch
multiDispatch :: Monad m => (LogServer (SObjBT (DrvOp e) m) (), World e (SObjBT (DrvOp e) m) ()) -> [EvOrAct e] -> SObjBT (DrvOp e) m (LogServer (SObjBT (DrvOp e) m) (), World e (SObjBT (DrvOp e) m) (), [EvOrAct e])

-- | full multiple event dispatch with feedback
multiDispatchTillEnd :: Monad m => (LogServer (SObjBT (DrvOp e) m) (), World e (SObjBT (DrvOp e) m) ()) -> [EvOrAct e] -> SObjBT (DrvOp e) m (LogServer (SObjBT (DrvOp e) m) (), World e (SObjBT (DrvOp e) m) ())

-- | convenience routine for driver
fire :: (Monad m, MonadLog m) => e -> EStT (Driver e m ()) m (Maybe (ActionOrder e))


-- | Common event handling
module Control.Monad.Trans.Crtn.EventHandler
eventHandler :: MVar (Maybe (Driver e IO ())) -> e -> IO ()


-- | special actor for IO action
module Control.Monad.Trans.Crtn.IOActor

-- | first is
data IOOp e i o
DoIOAction :: IOOp e ((e -> IO ()) -> IO ()) (Either String ())
type IOActor e m r = SObjT (IOOp e) m r
doIOAction :: Monad m => ((e -> IO ()) -> IO ()) -> CObjT (IOOp e) m (Either String ())
ioactorgen :: MonadIO m => (e -> IO ()) -> SObjT (IOOp e) m ()

module Control.Monad.Trans.Crtn.Logger.Simple
simplelogger :: MonadLog m => LogServer m ()
loggerW :: MonadLog m => Int -> LogServer m ()
