-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A high level driver for the Cassandra datastore
--   
--   The objective is to completely isolate away the thrift layer,
--   providing a more idiomatic and naruall Haskell experience working with
--   Cassandra. Be sure to check out the README on Github for some more
--   explanation and Release Notes, which is helpful in talking about what
--   this library can do.
--   
--   Certain parts of the API was inspired by pycassa (Python client) and
--   hscassandra (on Hackage).
--   
--   Please see the Github repository for more detailed documentation,
--   release notes and examples.
--   
--   A brief explanation of modules:
--   
--   <ul>
--   <li><i>Database.Cassandra.Basic</i>: Contains a low level, simple
--   implementation of Cassandra interaction using the thrift API
--   underneath.</li>
--   <li><i>Database.Cassandra.Marshall</i>: Intended to be the main high
--   level module that you should use, Marshall allows you to pick the
--   serialization strategy you would like to use at each function call. We
--   recommend using <a>casSafeCopy</a> due to its support for evolving
--   data types, although casJSON maybe another popular choice.</li>
--   <li><i>Database.Cassandra.JSON</i>: (Now deprecated; use Marshall
--   instead) A higher level API that operates on values with ToJSON and
--   FromJSON isntances from the <i>aeson</i> library. This module has in
--   part been inspired by Bryan O'Sullivan's <i>riak</i> client for
--   Haskell.</li>
--   <li><i>Database.Cassandra.Pool</i>: Handles a <i>pool</i> of
--   connections to multiple servers in a cluster, splitting the load among
--   them.</li>
--   <li><i>Database.Cassandra.Pack</i>: Handles column types that
--   Cassandra recognizes and adds support for Composite Columns.</li>
--   <li><i>Database.Cassandra.Types</i>: A common set of types used
--   everywhere.</li>
--   </ul>
--   
--   Potential TODOs include:
--   
--   <ul>
--   <li>Support for counters and batch mutators</li>
--   <li>Support for database admin operations</li>
--   </ul>
@package cassy
@version 0.7.1

module Database.Cassandra.Pool

-- | A round-robin pool of cassandra connections
type CPool = Pool Cassandra

-- | A (ServerName, Port) tuple
type Server = (HostName, Int)

-- | A localhost server with default configuration
defServer :: Server

-- | A single localhost server with default configuration
defServers :: [Server]
type KeySpace = String
data Cassandra
Cassandra :: Handle -> FramedTransport Handle -> BinaryProtocol (FramedTransport Handle) -> Cassandra
cHandle :: Cassandra -> Handle
cFramed :: Cassandra -> FramedTransport Handle
cProto :: Cassandra -> BinaryProtocol (FramedTransport Handle)

-- | Create a pool of connections to a cluster of Cassandra boxes
--   
--   Each box in the cluster will get up to n connections. The pool will
--   send queries in round-robin fashion to balance load on each box in the
--   cluster.
createCassandraPool :: [Server] -> Int -> Int -> NominalDiffTime -> KeySpace -> IO CPool

-- | Temporarily take a resource from a <a>Pool</a>, perform an action with
--   it, and return it to the pool afterwards.
--   
--   <ul>
--   <li>If the pool has an idle resource available, it is used
--   immediately.</li>
--   <li>Otherwise, if the maximum number of resources has not yet been
--   reached, a new resource is created and used.</li>
--   <li>If the maximum number of resources has been reached, this function
--   blocks until a resource becomes available.</li>
--   </ul>
--   
--   If the action throws an exception of any type, the resource is
--   destroyed, and not returned to the pool.
--   
--   It probably goes without saying that you should never manually destroy
--   a pooled resource, as doing so will almost certainly cause a
--   subsequent user (who expects the resource to be valid) to throw an
--   exception.
withResource :: MonadBaseControl IO m => Pool a -> (a -> m b) -> m b

-- | Open underlying thrift connection
openThrift :: (Integral a, HandleSource (t, PortID)) => t -> a -> IO (Handle, FramedTransport Handle, BinaryProtocol (FramedTransport Handle))


-- | A Collection of utilities for binary packing values into Bytestring |
module Database.Cassandra.Pack

-- | This typeclass defines and maps to haskell types that Cassandra
--   natively knows about and uses in sorting and potentially validating
--   column key values.
--   
--   All column keys are eventually sent to and received from Cassandra in
--   binary form. This typeclass allows us to map some Haskell type
--   definitions to their binary representation. The correct binary
--   serialization is handled for you behind the scenes.
--   
--   For simplest cases, just use one of the string-like instances, e.g.
--   <a>ByteString</a>, <a>String</a> or <a>Text</a>. Please keep in mind
--   that these are just mapped to untyped BytesType.
--   
--   Remember that for special column types, such as <a>TLong</a>, to have
--   any effect, your ColumnFamily must have been created with that
--   comparator or validator. Otherwise you're just encoding/decoding
--   integer values without any Cassandra support for sorting or
--   correctness.
--   
--   The Python library pycassa has a pretty good tutorial to learn more.
--   
--   Tuple instances support fixed ComponentType columns. Example:
--   
--   <pre>
--   insert "testCF" "row1" [packCol ((TLong 124, TAscii "Hello"), "some content")]
--   </pre>
class CasType a
encodeCas :: CasType a => a -> ByteString
decodeCas :: CasType a => ByteString -> a
newtype TAscii
TAscii :: ByteString -> TAscii
getAscii :: TAscii -> ByteString
newtype TBytes
TBytes :: ByteString -> TBytes
getTBytes :: TBytes -> ByteString
newtype TCounter
TCounter :: ByteString -> TCounter
getCounter :: TCounter -> ByteString
newtype TInt32
TInt32 :: Int32 -> TInt32
getInt32 :: TInt32 -> Int32
newtype TInt64
TInt64 :: Int64 -> TInt64
getInt64 :: TInt64 -> Int64
newtype TUtf8
TUtf8 :: Text -> TUtf8
getUtf8 :: TUtf8 -> Text
newtype TUUID
TUUID :: ByteString -> TUUID
getUUID :: TUUID -> ByteString
newtype TLong
TLong :: Integer -> TLong
getLong :: TLong -> Integer

-- | Timestamp that stores micro-seconds since epoch as <a>TLong</a>
--   underneath.
newtype TTimeStamp
TTimeStamp :: TLong -> TTimeStamp
getTimeStamp :: TTimeStamp -> TLong

-- | Convert commonly used <a>UTCTime</a> to <a>TTimeStamp</a>.
--   
--   First converts to seconds since epoch (POSIX seconds), then multiplies
--   by a million and floors the resulting value. The value, therefore, is
--   in micro-seconds and is accurate to within a microsecond.
toTimeStamp :: UTCTime -> TTimeStamp
fromTimeStamp :: TTimeStamp -> UTCTime

-- | Exclusive tag for composite column. You may tag the end of a composite
--   range with this to make the range exclusive. See pycassa documentation
--   for more information.
newtype Exclusive a
Exclusive :: a -> Exclusive a

-- | Use the Single wrapper when you want to refer only to the first
--   coolumn of a CompositeType column.
newtype Single a
Single :: a -> Single a

-- | Wrap your composite columns in this type when you're starting an
--   inclusive column slice.
newtype SliceStart a
SliceStart :: a -> SliceStart a
instance [overlap ok] Eq TAscii
instance [overlap ok] Show TAscii
instance [overlap ok] Read TAscii
instance [overlap ok] Ord TAscii
instance [overlap ok] Eq TBytes
instance [overlap ok] Show TBytes
instance [overlap ok] Read TBytes
instance [overlap ok] Ord TBytes
instance [overlap ok] Eq TCounter
instance [overlap ok] Show TCounter
instance [overlap ok] Read TCounter
instance [overlap ok] Ord TCounter
instance [overlap ok] Eq TInt32
instance [overlap ok] Show TInt32
instance [overlap ok] Read TInt32
instance [overlap ok] Ord TInt32
instance [overlap ok] Eq TInt64
instance [overlap ok] Show TInt64
instance [overlap ok] Read TInt64
instance [overlap ok] Ord TInt64
instance [overlap ok] Enum TInt64
instance [overlap ok] Real TInt64
instance [overlap ok] Integral TInt64
instance [overlap ok] Num TInt64
instance [overlap ok] Eq TUUID
instance [overlap ok] Show TUUID
instance [overlap ok] Read TUUID
instance [overlap ok] Ord TUUID
instance [overlap ok] Eq TLong
instance [overlap ok] Show TLong
instance [overlap ok] Read TLong
instance [overlap ok] Ord TLong
instance [overlap ok] Enum TLong
instance [overlap ok] Real TLong
instance [overlap ok] Integral TLong
instance [overlap ok] Num TLong
instance [overlap ok] Eq TUtf8
instance [overlap ok] Show TUtf8
instance [overlap ok] Read TUtf8
instance [overlap ok] Ord TUtf8
instance [overlap ok] Eq TTimeStamp
instance [overlap ok] Show TTimeStamp
instance [overlap ok] Read TTimeStamp
instance [overlap ok] Ord TTimeStamp
instance [overlap ok] Enum TTimeStamp
instance [overlap ok] Num TTimeStamp
instance [overlap ok] Real TTimeStamp
instance [overlap ok] Integral TTimeStamp
instance [overlap ok] CasType TTimeStamp
instance [overlap ok] Eq a => Eq (Exclusive a)
instance [overlap ok] Show a => Show (Exclusive a)
instance [overlap ok] Read a => Read (Exclusive a)
instance [overlap ok] Ord a => Ord (Exclusive a)
instance [overlap ok] Eq a => Eq (Single a)
instance [overlap ok] Show a => Show (Single a)
instance [overlap ok] Read a => Read (Single a)
instance [overlap ok] Ord a => Ord (Single a)
instance [overlap ok] Eq a => Eq (SliceStart a)
instance [overlap ok] Show a => Show (SliceStart a)
instance [overlap ok] Read a => Read (SliceStart a)
instance [overlap ok] Ord a => Ord (SliceStart a)
instance [overlap ok] (CasType a, CasType b, CasType c, CasType d) => CasType (a, b, c, Exclusive d)
instance [overlap ok] (CasType a, CasType b, CasType c) => CasType (a, b, Exclusive c)
instance [overlap ok] (CasType a, CasType b) => CasType (a, Exclusive b)
instance [overlap ok] CasType a => CasType (Exclusive (Single a))
instance [overlap ok] (CasType a, CasType b, CasType c, CasType d) => CasType (SliceStart (a, b, c, d))
instance [overlap ok] (CasType a, CasType b, CasType c) => CasType (SliceStart (a, b, c))
instance [overlap ok] (CasType a, CasType b) => CasType (SliceStart (a, b))
instance [overlap ok] CasType a => CasType (SliceStart (Single a))
instance [overlap ok] (CasType a, CasType b, CasType c, CasType d) => CasType (a, b, c, d)
instance [overlap ok] (CasType a, CasType b, CasType c) => CasType (a, b, c)
instance [overlap ok] (CasType a, CasType b) => CasType (a, b)
instance [overlap ok] CasType a => CasType (Single a)
instance [overlap ok] CasType UTCTime
instance [overlap ok] CasType Day
instance [overlap ok] CasType TUtf8
instance [overlap ok] CasType TLong
instance [overlap ok] CasType Int
instance [overlap ok] CasType Int64
instance [overlap ok] CasType Int32
instance [overlap ok] CasType TInt64
instance [overlap ok] CasType TInt32
instance [overlap ok] CasType TCounter
instance [overlap ok] CasType TBytes
instance [overlap ok] CasType TAscii
instance [overlap ok] CasType ByteString
instance [overlap ok] CasType Text
instance [overlap ok] CasType Text
instance [overlap ok] CasType String
instance [overlap ok] CasType ByteString

module Database.Cassandra.Types

-- | Possible outcomes of a modify operation
data ModifyOperation a
Update :: a -> ModifyOperation a
Delete :: ModifyOperation a
DoNothing :: ModifyOperation a

-- | A <a>Key</a> range selector to use with <tt>getMulti</tt>.
data KeySelector

-- | Just a list of keys to get
Keys :: [Key] -> KeySelector

-- | A range of keys to get. Remember that RandomPartitioner ranges may not
--   mean much as keys are randomly assigned to nodes.
KeyRange :: KeyRangeType -> Key -> Key -> Int32 -> KeySelector

-- | Encodes the Key vs. Token options in the thrift API.
--   
--   <a>InclusiveRange</a> ranges are just plain intuitive range queries.
--   <a>WrapAround</a> ranges are also inclusive, but they wrap around the
--   ring.
data KeyRangeType
InclusiveRange :: KeyRangeType
WrapAround :: KeyRangeType
mkKeyRange :: KeySelector -> KeyRange

-- | A column selector/filter statement for queries.
--   
--   Remember that SuperColumns are always fully deserialized, so we don't
--   offer a way to filter columns within a <a>SuperColumn</a>.
--   
--   Column names and ranges are specified by any type that can be packed
--   into a Cassandra column using the <a>CasType</a> typeclass.
data Selector

-- | Return everything in <a>Row</a>
All :: Selector

-- | Return specific columns or super-columns depending on the
--   <a>ColumnFamily</a>
ColNames :: [a] -> Selector

-- | When deleting specific columns in a super column
SupNames :: a -> [b] -> Selector

-- | Return a range of columns or super-columns.
Range :: Maybe a -> Maybe b -> Order -> Int32 -> Selector
rangeStart :: Selector -> Maybe a
rangeEnd :: Selector -> Maybe b
rangeOrder :: Selector -> Order
rangeLimit :: Selector -> Int32

-- | A default starting point for range <a>Selector</a>. Use this so you
--   don't run into ambiguous type variables when using Nothing.
--   
--   <pre>
--   range = Range (Nothing :: Maybe ByteString) (Nothing :: Maybe ByteString) Regular 1024
--   </pre>
range :: Selector
boundless :: Maybe ByteString
showCas :: CasType a => a -> String
mkPredicate :: Selector -> SlicePredicate

-- | Order in a range query
data Order
Regular :: Order
Reversed :: Order
renderOrd :: Order -> Bool
reverseOrder :: Order -> Order
type ColumnFamily = String
type Key = ByteString
type RowKey = Key
type ColumnName = ByteString
type Value = ByteString

-- | A Column is either a single key-value pair or a SuperColumn with an
--   arbitrary number of key-value pairs
data Column
SuperColumn :: ColumnName -> [Column] -> Column
Column :: ColumnName -> Value -> Maybe Int64 -> Maybe Int32 -> Column
colKey :: Column -> ColumnName
colVal :: Column -> Value

-- | Last update timestamp; will be overridden during write/update ops
colTS :: Column -> Maybe Int64

-- | A TTL after which Cassandra will erase the column
colTTL :: Column -> Maybe Int32

-- | A full row is simply a sequence of columns
type Row = [Column]

-- | A short-hand for creating key-value <a>Column</a> values. This is
--   pretty low level; you probably want to use <tt>packCol</tt>.
col :: ByteString -> ByteString -> Column
mkThriftCol :: Column -> IO Column
castColumn :: ColumnOrSuperColumn -> Either CassandraException Column
castCol :: Column -> Either CassandraException Column
castSuperCol :: SuperColumn -> Either CassandraException Column
data CassandraException
NotFoundException :: CassandraException
InvalidRequestException :: String -> CassandraException
UnavailableException :: CassandraException
TimedOutException :: CassandraException
AuthenticationException :: String -> CassandraException
AuthorizationException :: String -> CassandraException
SchemaDisagreementException :: CassandraException
ConversionException :: String -> CassandraException
OperationNotSupported :: String -> CassandraException

-- | Exception handler that returns <tt>True</tt> for errors that may be
--   resolved after a retry. So they are good candidates for
--   <tt>retrying</tt> queries.
casRetryH :: Monad m => Int -> Handler m Bool

-- | <a>IOException</a>s should be retried
networkRetryH :: Monad m => Int -> Handler m Bool

-- | Cassandra is VERY sensitive to its timestamp values. As a convention,
--   timestamps are always in microseconds
getTime :: IO Int64

-- | Describes the result of a single pagination action
data PageResult m a

-- | Done, this is all I have.
PDone :: [a] -> PageResult m a
pCache :: PageResult m a -> [a]

-- | Here's a batch and there is more when you call the action.
PMore :: [a] -> m (PageResult m a) -> PageResult m a
pCache :: PageResult m a -> [a]
pMore :: PageResult m a -> m (PageResult m a)
pIsDry :: PageResult m a -> Bool
pIsDone :: PageResult t t1 -> Bool
pHasMore :: PageResult t t1 -> Bool

-- | A typeclass to enable using any string-like type for row and column
--   keys
class CKey a
toColKey :: CKey a => a -> ByteString
fromColKey :: CKey a => ByteString -> Either String a

-- | Raise an error if conversion fails
fromColKey' :: CKey a => ByteString -> a
instance Typeable CassandraException
instance Eq a => Eq (ModifyOperation a)
instance Show a => Show (ModifyOperation a)
instance Ord a => Ord (ModifyOperation a)
instance Read a => Read (ModifyOperation a)
instance Show KeyRangeType
instance Show Order
instance Show KeySelector
instance Eq Column
instance Show Column
instance Read Column
instance Ord Column
instance Eq CassandraException
instance Show CassandraException
instance Read CassandraException
instance Ord CassandraException
instance Data CassandraException
instance CKey ByteString
instance CKey ByteString
instance CKey Text
instance CKey Text
instance CKey String
instance CKey [ByteString]
instance Monad m => Functor (PageResult m)
instance Exception CassandraException
instance Show Selector
instance Default Selector


-- | Low-level functionality for working with Cassandra at the most basic
--   level.
module Database.Cassandra.Basic

-- | A round-robin pool of cassandra connections
type CPool = Pool Cassandra

-- | A (ServerName, Port) tuple
type Server = (HostName, Int)

-- | A localhost server with default configuration
defServer :: Server

-- | A single localhost server with default configuration
defServers :: [Server]
type KeySpace = String

-- | Create a pool of connections to a cluster of Cassandra boxes
--   
--   Each box in the cluster will get up to n connections. The pool will
--   send queries in round-robin fashion to balance load on each box in the
--   cluster.
createCassandraPool :: [Server] -> Int -> Int -> NominalDiffTime -> KeySpace -> IO CPool

-- | All Cassy operations are designed to run inside <a>MonadCassandra</a>
--   context.
--   
--   We provide a default concrete <a>Cas</a> datatype, but you can simply
--   make your own application monads an instance of <a>MonadCassandra</a>
--   for conveniently using all operations of this package.
--   
--   Please keep in mind that all Cassandra operations may raise
--   <a>CassandraException</a>s at any point in time.
class MonadIO m => MonadCassandra m
getCassandraPool :: MonadCassandra m => m CPool
type Cas a = ReaderT CPool IO a

-- | Main running function when using the ad-hoc Cas monad. Just write your
--   cassandra actions within the <a>Cas</a> monad and supply them with a
--   <a>CPool</a> to execute.
runCas :: CPool -> Cas a -> IO a

-- | Unwrap a Cassandra action and return an IO continuation that can then
--   be run in a pure IO context.
--   
--   This is useful when you design all your functions in a generic form
--   with <a>MonadCassandra</a> m constraints and then one day need to feed
--   your function to a utility that can only run in an IO context. This
--   function is then your friendly utility for extracting an IO action.
transCas :: MonadCassandra m => Cas a -> m (IO a)

-- | Run a list of cassandra computations in parallel using the async
--   library
mapCassandra :: (Traversable t, MonadCassandra m) => t (Cas b) -> m (t b)

-- | Get a single key-column value.
getCol :: (MonadCassandra m, CasType k) => ColumnFamily -> ByteString -> k -> ConsistencyLevel -> m (Maybe Column)

-- | An arbitrary get operation - slice with <a>Selector</a>
get :: MonadCassandra m => ColumnFamily -> ByteString -> Selector -> ConsistencyLevel -> m [Column]

-- | Do multiple <a>get</a>s in one DB hit
getMulti :: MonadCassandra m => ColumnFamily -> KeySelector -> Selector -> ConsistencyLevel -> m (Map ByteString Row)

-- | Insert an entire row into the db.
--   
--   This will do as many round-trips as necessary to insert the full row.
--   Please keep in mind that each column and each column of each
--   super-column is sent to the server one by one.
--   
--   <pre>
--   insert "testCF" "row1" ONE [packCol ("column key", "some column content")]
--   </pre>
insert :: MonadCassandra m => ColumnFamily -> ByteString -> ConsistencyLevel -> [Column] -> m ()

-- | Delete an entire row, specific columns or a specific sub-set of
--   columns within a SuperColumn.
delete :: MonadCassandra m => ColumnFamily -> Key -> Selector -> ConsistencyLevel -> m ()

-- | <a>retrying</a> with direct cassandra support. Server-related failures
--   will be retried.
--   
--   <a>UnavailableException</a>, <a>TimedOutException</a> and
--   <a>SchemaDisagreementException</a> will be automatically retried.
retryCas :: (MonadCatch m, MonadIO m) => RetryPolicy -> m a -> m a

-- | Exception handler that returns <tt>True</tt> for errors that may be
--   resolved after a retry. So they are good candidates for
--   <tt>retrying</tt> queries.
casRetryH :: Monad m => Int -> Handler m Bool

-- | <a>IOException</a>s should be retried
networkRetryH :: Monad m => Int -> Handler m Bool

-- | A column selector/filter statement for queries.
--   
--   Remember that SuperColumns are always fully deserialized, so we don't
--   offer a way to filter columns within a <a>SuperColumn</a>.
--   
--   Column names and ranges are specified by any type that can be packed
--   into a Cassandra column using the <a>CasType</a> typeclass.
data Selector

-- | Return everything in <a>Row</a>
All :: Selector

-- | Return specific columns or super-columns depending on the
--   <a>ColumnFamily</a>
ColNames :: [a] -> Selector

-- | When deleting specific columns in a super column
SupNames :: a -> [b] -> Selector

-- | Return a range of columns or super-columns.
Range :: Maybe a -> Maybe b -> Order -> Int32 -> Selector
rangeStart :: Selector -> Maybe a
rangeEnd :: Selector -> Maybe b
rangeOrder :: Selector -> Order
rangeLimit :: Selector -> Int32

-- | A default starting point for range <a>Selector</a>. Use this so you
--   don't run into ambiguous type variables when using Nothing.
--   
--   <pre>
--   range = Range (Nothing :: Maybe ByteString) (Nothing :: Maybe ByteString) Regular 1024
--   </pre>
range :: Selector
boundless :: Maybe ByteString

-- | Order in a range query
data Order
Regular :: Order
Reversed :: Order
reverseOrder :: Order -> Order

-- | A <a>Key</a> range selector to use with <tt>getMulti</tt>.
data KeySelector

-- | Just a list of keys to get
Keys :: [Key] -> KeySelector

-- | A range of keys to get. Remember that RandomPartitioner ranges may not
--   mean much as keys are randomly assigned to nodes.
KeyRange :: KeyRangeType -> Key -> Key -> Int32 -> KeySelector

-- | Encodes the Key vs. Token options in the thrift API.
--   
--   <a>InclusiveRange</a> ranges are just plain intuitive range queries.
--   <a>WrapAround</a> ranges are also inclusive, but they wrap around the
--   ring.
data KeyRangeType
InclusiveRange :: KeyRangeType
WrapAround :: KeyRangeType
data CassandraException
NotFoundException :: CassandraException
InvalidRequestException :: String -> CassandraException
UnavailableException :: CassandraException
TimedOutException :: CassandraException
AuthenticationException :: String -> CassandraException
AuthorizationException :: String -> CassandraException
SchemaDisagreementException :: CassandraException
ConversionException :: String -> CassandraException
OperationNotSupported :: String -> CassandraException

-- | Cassandra is VERY sensitive to its timestamp values. As a convention,
--   timestamps are always in microseconds
getTime :: IO Int64

-- | Make exceptions implicit.
throwing :: IO (Either CassandraException a) -> IO a

-- | Wrap exceptions of the underlying thrift library into the exception
--   types defined here.
wrapException :: IO a -> IO a
type ColumnFamily = String
type Key = ByteString
type ColumnName = ByteString
type Value = ByteString

-- | A Column is either a single key-value pair or a SuperColumn with an
--   arbitrary number of key-value pairs
data Column
SuperColumn :: ColumnName -> [Column] -> Column
Column :: ColumnName -> Value -> Maybe Int64 -> Maybe Int32 -> Column
colKey :: Column -> ColumnName
colVal :: Column -> Value

-- | Last update timestamp; will be overridden during write/update ops
colTS :: Column -> Maybe Int64

-- | A TTL after which Cassandra will erase the column
colTTL :: Column -> Maybe Int32

-- | A short-hand for creating key-value <a>Column</a> values. This is
--   pretty low level; you probably want to use <tt>packCol</tt>.
col :: ByteString -> ByteString -> Column

-- | Pack key-value pair into <a>Column</a> form ready to be written to
--   Cassandra
packCol :: CasType k => (k, ByteString) -> Column

-- | Unpack a Cassandra <a>Column</a> into a more convenient (k,v) form
unpackCol :: CasType k => Column -> (k, Value)

-- | Pack a column key into binary, ready for submission to Cassandra
packKey :: CasType a => a -> ByteString

-- | A full row is simply a sequence of columns
type Row = [Column]
data ConsistencyLevel :: *
ONE :: ConsistencyLevel
QUORUM :: ConsistencyLevel
LOCAL_QUORUM :: ConsistencyLevel
EACH_QUORUM :: ConsistencyLevel
ALL :: ConsistencyLevel
ANY :: ConsistencyLevel
TWO :: ConsistencyLevel
THREE :: ConsistencyLevel

-- | A typeclass to enable using any string-like type for row and column
--   keys
class CKey a
toColKey :: CKey a => a -> ByteString
fromColKey :: CKey a => ByteString -> Either String a

-- | Raise an error if conversion fails
fromColKey' :: CKey a => ByteString -> a
instance MonadIO m => MonadCassandra (ReaderT CPool m)


-- | Defines Cassandra operations for persistence of complex Haskell data
--   objects with custom-selected but implicitly performed serialization.
--   
--   The main design choice is to require a dictionary dictating
--   marshalling/serialization policy for every operation, rather than a
--   typeclass that can be instantiated once.
module Database.Cassandra.Marshall

-- | A round-robin pool of cassandra connections
type CPool = Pool Cassandra

-- | A (ServerName, Port) tuple
type Server = (HostName, Int)

-- | A localhost server with default configuration
defServer :: Server

-- | A single localhost server with default configuration
defServers :: [Server]
type KeySpace = String

-- | Create a pool of connections to a cluster of Cassandra boxes
--   
--   Each box in the cluster will get up to n connections. The pool will
--   send queries in round-robin fashion to balance load on each box in the
--   cluster.
createCassandraPool :: [Server] -> Int -> Int -> NominalDiffTime -> KeySpace -> IO CPool

-- | All Cassy operations are designed to run inside <a>MonadCassandra</a>
--   context.
--   
--   We provide a default concrete <a>Cas</a> datatype, but you can simply
--   make your own application monads an instance of <a>MonadCassandra</a>
--   for conveniently using all operations of this package.
--   
--   Please keep in mind that all Cassandra operations may raise
--   <a>CassandraException</a>s at any point in time.
class MonadIO m => MonadCassandra m
getCassandraPool :: MonadCassandra m => m CPool
type Cas a = ReaderT CPool IO a

-- | Main running function when using the ad-hoc Cas monad. Just write your
--   cassandra actions within the <a>Cas</a> monad and supply them with a
--   <a>CPool</a> to execute.
runCas :: CPool -> Cas a -> IO a

-- | Unwrap a Cassandra action and return an IO continuation that can then
--   be run in a pure IO context.
--   
--   This is useful when you design all your functions in a generic form
--   with <a>MonadCassandra</a> m constraints and then one day need to feed
--   your function to a utility that can only run in an IO context. This
--   function is then your friendly utility for extracting an IO action.
transCas :: MonadCassandra m => Cas a -> m (IO a)

-- | Run a list of cassandra computations in parallel using the async
--   library
mapCassandra :: (Traversable t, MonadCassandra m) => t (Cas b) -> m (t b)

-- | A Haskell dictionary containing a pair of encode/decode functions.
--   
--   This is the main design choice in this module. We require that each
--   operation takes an explicit marshalling policy rather than a typeclass
--   which makes it possible to do it in a single way per data type.
--   
--   You can create your own objects of this type with great ease. Just
--   look at one of the examples here (<a>casJSON</a>, <a>casSerialize</a>,
--   etc.)
data Marshall a
Marshall :: (a -> ByteString) -> (ByteString -> Either String a) -> Marshall a

-- | An encoding function
marshallEncode :: Marshall a -> a -> ByteString

-- | A decoding function
marshallDecode :: Marshall a -> ByteString -> Either String a

-- | Marshall data using <a>Show</a> and <a>Read</a>. Not meant for serious
--   production cases.
casShow :: (Show a, Read a) => Marshall a

-- | Marshall data using JSON encoding. Good interoperability, but not very
--   efficient for data storage.
casJSON :: (ToJSON a, FromJSON a) => Marshall a

-- | Marshall data using the <tt>Serialize</tt> instance. Like
--   <tt>Binary</tt>, <tt>Serialize</tt> is very efficient.
casSerialize :: Serialize a => Marshall a

-- | Marshall data using the <tt>SafeCopy</tt> instance. This is quite well
--   suited for production because it is both very efficient and provides a
--   systematic way to migrate your data types over time.
casSafeCopy :: SafeCopy a => Marshall a

-- | An arbitrary get operation - slice with <a>Selector</a>.
--   
--   Internally based on Basic.get. Table is assumed to be a regular
--   ColumnFamily and contents of returned columns are cast into the target
--   type.
get :: (MonadCassandra m, CasType k) => Marshall a -> ColumnFamily -> RowKey -> Selector -> ConsistencyLevel -> m [(k, a)]

-- | A version of <a>get</a> that discards the column names for the common
--   scenario. Useful because you would otherwise be forced to manually
--   supply type signatures to get rid of the <a>CasType</a> ambiguity.
get_ :: MonadCassandra m => Marshall a -> ColumnFamily -> RowKey -> Selector -> ConsistencyLevel -> m [a]

-- | Get a single column from a single row
getCol :: (MonadCassandra m, CasType k) => Marshall a -> ColumnFamily -> RowKey -> k -> ConsistencyLevel -> m (Maybe a)

-- | Get a slice of columns from multiple rows at once. Note that since we
--   are auto-serializing from JSON, all the columns must be of the same
--   data type.
getMulti :: MonadCassandra m => Marshall a -> ColumnFamily -> KeySelector -> Selector -> ConsistencyLevel -> m (Map RowKey [(ColumnName, a)])
insertCol :: (MonadCassandra m, CasType k) => Marshall a -> ColumnFamily -> RowKey -> k -> ConsistencyLevel -> a -> m ()
insertColTTL :: (MonadCassandra m, CasType k) => Marshall a -> ColumnFamily -> RowKey -> k -> ConsistencyLevel -> a -> Int32 -> m ()

-- | A modify function that will fetch a specific column, apply
--   modification function on it and save results back to Cassandra.
--   
--   A <tt>b</tt> side value is returned for computational convenience.
--   
--   This is intended to be a workhorse function, in that you should be
--   able to do all kinds of relatively straightforward operations just
--   using this function.
--   
--   This method may throw a <a>CassandraException</a> for all exceptions
--   other than <a>NotFoundException</a>.
modify :: (MonadCassandra m, MonadThrow m, CasType k) => Marshall a -> ColumnFamily -> RowKey -> k -> ConsistencyLevel -> ConsistencyLevel -> (Maybe a -> m (ModifyOperation a, b)) -> m b

-- | Same as <a>modify</a> but does not offer a side value.
--   
--   This method may throw a <a>CassandraException</a> for all exceptions
--   other than <a>NotFoundException</a>.
modify_ :: (MonadCassandra m, CasType k, MonadThrow m) => Marshall a -> ColumnFamily -> RowKey -> k -> ConsistencyLevel -> ConsistencyLevel -> (Maybe a -> m (ModifyOperation a)) -> m ()

-- | Same as the <a>delete</a> in the <a>Basic</a> module, except that it
--   throws an exception rather than returning an explicit Either value.
delete :: MonadCassandra m => ColumnFamily -> RowKey -> Selector -> ConsistencyLevel -> m ()

-- | <a>retrying</a> with direct cassandra support. Server-related failures
--   will be retried.
--   
--   <a>UnavailableException</a>, <a>TimedOutException</a> and
--   <a>SchemaDisagreementException</a> will be automatically retried.
retryCas :: (MonadCatch m, MonadIO m) => RetryPolicy -> m a -> m a

-- | Exception handler that returns <tt>True</tt> for errors that may be
--   resolved after a retry. So they are good candidates for
--   <tt>retrying</tt> queries.
casRetryH :: Monad m => Int -> Handler m Bool
type RowKey = Key
type ColumnName = ByteString

-- | Possible outcomes of a modify operation
data ModifyOperation a
Update :: a -> ModifyOperation a
Delete :: ModifyOperation a
DoNothing :: ModifyOperation a
type ColumnFamily = String
data ConsistencyLevel :: *
ONE :: ConsistencyLevel
QUORUM :: ConsistencyLevel
LOCAL_QUORUM :: ConsistencyLevel
EACH_QUORUM :: ConsistencyLevel
ALL :: ConsistencyLevel
ANY :: ConsistencyLevel
TWO :: ConsistencyLevel
THREE :: ConsistencyLevel
data CassandraException
NotFoundException :: CassandraException
InvalidRequestException :: String -> CassandraException
UnavailableException :: CassandraException
TimedOutException :: CassandraException
AuthenticationException :: String -> CassandraException
AuthorizationException :: String -> CassandraException
SchemaDisagreementException :: CassandraException
ConversionException :: String -> CassandraException
OperationNotSupported :: String -> CassandraException

-- | A column selector/filter statement for queries.
--   
--   Remember that SuperColumns are always fully deserialized, so we don't
--   offer a way to filter columns within a <a>SuperColumn</a>.
--   
--   Column names and ranges are specified by any type that can be packed
--   into a Cassandra column using the <a>CasType</a> typeclass.
data Selector

-- | Return everything in <a>Row</a>
All :: Selector

-- | Return specific columns or super-columns depending on the
--   <a>ColumnFamily</a>
ColNames :: [a] -> Selector

-- | When deleting specific columns in a super column
SupNames :: a -> [b] -> Selector

-- | Return a range of columns or super-columns.
Range :: Maybe a -> Maybe b -> Order -> Int32 -> Selector
rangeStart :: Selector -> Maybe a
rangeEnd :: Selector -> Maybe b
rangeOrder :: Selector -> Order
rangeLimit :: Selector -> Int32

-- | A default starting point for range <a>Selector</a>. Use this so you
--   don't run into ambiguous type variables when using Nothing.
--   
--   <pre>
--   range = Range (Nothing :: Maybe ByteString) (Nothing :: Maybe ByteString) Regular 1024
--   </pre>
range :: Selector
boundless :: Maybe ByteString

-- | Order in a range query
data Order
Regular :: Order
Reversed :: Order
reverseOrder :: Order -> Order

-- | A <a>Key</a> range selector to use with <tt>getMulti</tt>.
data KeySelector

-- | Just a list of keys to get
Keys :: [Key] -> KeySelector

-- | A range of keys to get. Remember that RandomPartitioner ranges may not
--   mean much as keys are randomly assigned to nodes.
KeyRange :: KeyRangeType -> Key -> Key -> Int32 -> KeySelector

-- | Encodes the Key vs. Token options in the thrift API.
--   
--   <a>InclusiveRange</a> ranges are just plain intuitive range queries.
--   <a>WrapAround</a> ranges are also inclusive, but they wrap around the
--   ring.
data KeyRangeType
InclusiveRange :: KeyRangeType
WrapAround :: KeyRangeType

-- | Describes the result of a single pagination action
data PageResult m a

-- | Done, this is all I have.
PDone :: [a] -> PageResult m a
pCache :: PageResult m a -> [a]

-- | Here's a batch and there is more when you call the action.
PMore :: [a] -> m (PageResult m a) -> PageResult m a
pCache :: PageResult m a -> [a]
pMore :: PageResult m a -> m (PageResult m a)
pIsDry :: PageResult m a -> Bool
pIsDone :: PageResult t t1 -> Bool
pHasMore :: PageResult t t1 -> Bool

-- | Paginate over columns in a given key, repeatedly applying the given
--   <a>Selector</a>. The <a>Selector</a> must be a <a>Range</a> selector,
--   or else this funtion will raise an exception.
paginate :: (MonadCassandra m, MonadCatch m, CasType k) => Marshall a -> ColumnFamily -> RowKey -> Selector -> ConsistencyLevel -> RetryPolicy -> m (PageResult m (k, a))

-- | Just like <a>paginate</a>, but we instead return a conduit
--   <a>Source</a>.
paginateSource :: (CasType k, MonadCassandra m, MonadCatch m) => Marshall a -> ColumnFamily -> RowKey -> Selector -> ConsistencyLevel -> RetryPolicy -> Source m (k, a)

-- | Convenience layer: Convert a pagination scheme to a conduit
--   <a>Source</a>.
pageToSource :: Monad m => PageResult m a -> Source m a

-- | A typeclass to enable using any string-like type for row and column
--   keys
class CKey a
toColKey :: CKey a => a -> ByteString
fromColKey :: CKey a => ByteString -> Either String a

-- | Raise an error if conversion fails
fromColKey' :: CKey a => ByteString -> a


-- | This module has been deprecated and will be removed in version 0.7.
--   Every bit of functionality here is also available in the
--   Database.Cassandra.Marshall module, which is what you should use
--   instead.
module Database.Cassandra.JSON

-- | A round-robin pool of cassandra connections
type CPool = Pool Cassandra

-- | A (ServerName, Port) tuple
type Server = (HostName, Int)

-- | A localhost server with default configuration
defServer :: Server

-- | A single localhost server with default configuration
defServers :: [Server]
type KeySpace = String

-- | Create a pool of connections to a cluster of Cassandra boxes
--   
--   Each box in the cluster will get up to n connections. The pool will
--   send queries in round-robin fashion to balance load on each box in the
--   cluster.
createCassandraPool :: [Server] -> Int -> Int -> NominalDiffTime -> KeySpace -> IO CPool

-- | All Cassy operations are designed to run inside <a>MonadCassandra</a>
--   context.
--   
--   We provide a default concrete <a>Cas</a> datatype, but you can simply
--   make your own application monads an instance of <a>MonadCassandra</a>
--   for conveniently using all operations of this package.
--   
--   Please keep in mind that all Cassandra operations may raise
--   <a>CassandraException</a>s at any point in time.
class MonadIO m => MonadCassandra m
getCassandraPool :: MonadCassandra m => m CPool
type Cas a = ReaderT CPool IO a

-- | Main running function when using the ad-hoc Cas monad. Just write your
--   cassandra actions within the <a>Cas</a> monad and supply them with a
--   <a>CPool</a> to execute.
runCas :: CPool -> Cas a -> IO a

-- | Unwrap a Cassandra action and return an IO continuation that can then
--   be run in a pure IO context.
--   
--   This is useful when you design all your functions in a generic form
--   with <a>MonadCassandra</a> m constraints and then one day need to feed
--   your function to a utility that can only run in an IO context. This
--   function is then your friendly utility for extracting an IO action.
transCas :: MonadCassandra m => Cas a -> m (IO a)

-- | Run a list of cassandra computations in parallel using the async
--   library
mapCassandra :: (Traversable t, MonadCassandra m) => t (Cas b) -> m (t b)

-- | An arbitrary get operation - slice with <a>Selector</a>.
--   
--   Internally based on Basic.get. Table is assumed to be a regular
--   ColumnFamily and contents of returned columns are cast into the target
--   type.
get :: (MonadCassandra m, FromJSON a, CasType k) => ColumnFamily -> RowKey -> Selector -> ConsistencyLevel -> m [(k, a)]

-- | A version of <a>get</a> that discards the column names for the common
--   scenario. Useful because you would otherwise be forced to manually
--   supply type signatures to get rid of the <a>CasType</a> ambiguity.
get_ :: (MonadCassandra m, FromJSON a) => ColumnFamily -> RowKey -> Selector -> ConsistencyLevel -> m [a]

-- | Get a single column from a single row
getCol :: (MonadCassandra m, FromJSON a, CasType k) => ColumnFamily -> RowKey -> k -> ConsistencyLevel -> m (Maybe a)

-- | Get a slice of columns from multiple rows at once. Note that since we
--   are auto-serializing from JSON, all the columns must be of the same
--   data type.
getMulti :: (MonadCassandra m, FromJSON a) => ColumnFamily -> KeySelector -> Selector -> ConsistencyLevel -> m (Map RowKey [(ColumnName, a)])
insertCol :: (MonadCassandra m, ToJSON a, CasType k) => ColumnFamily -> RowKey -> k -> ConsistencyLevel -> a -> m ()
insertColTTL :: (MonadCassandra m, ToJSON a, CasType k) => ColumnFamily -> RowKey -> k -> ConsistencyLevel -> a -> Int32 -> m ()

-- | A modify function that will fetch a specific column, apply
--   modification function on it and save results back to Cassandra.
--   
--   A <tt>b</tt> side value is returned for computational convenience.
--   
--   This is intended to be a workhorse function, in that you should be
--   able to do all kinds of relatively straightforward operations just
--   using this function.
--   
--   This method may throw a <a>CassandraException</a> for all exceptions
--   other than <a>NotFoundException</a>.
modify :: (MonadCassandra m, ToJSON a, FromJSON a, CasType k) => ColumnFamily -> RowKey -> k -> ConsistencyLevel -> ConsistencyLevel -> (Maybe a -> m (ModifyOperation a, b)) -> m b

-- | Same as <a>modify</a> but does not offer a side value.
--   
--   This method may throw a <a>CassandraException</a> for all exceptions
--   other than <a>NotFoundException</a>.
modify_ :: (MonadCassandra m, ToJSON a, FromJSON a, CasType k) => ColumnFamily -> RowKey -> k -> ConsistencyLevel -> ConsistencyLevel -> (Maybe a -> m (ModifyOperation a)) -> m ()

-- | Same as the <a>delete</a> in the <a>Basic</a> module, except that it
--   throws an exception rather than returning an explicit Either value.
delete :: MonadCassandra m => ColumnFamily -> RowKey -> Selector -> ConsistencyLevel -> m ()
type RowKey = ByteString
type ColumnName = ByteString

-- | Possible outcomes of a modify operation
data ModifyOperation a
Update :: a -> ModifyOperation a
Delete :: ModifyOperation a
DoNothing :: ModifyOperation a
type ColumnFamily = String
data ConsistencyLevel :: *
ONE :: ConsistencyLevel
QUORUM :: ConsistencyLevel
LOCAL_QUORUM :: ConsistencyLevel
EACH_QUORUM :: ConsistencyLevel
ALL :: ConsistencyLevel
ANY :: ConsistencyLevel
TWO :: ConsistencyLevel
THREE :: ConsistencyLevel
data CassandraException
NotFoundException :: CassandraException
InvalidRequestException :: String -> CassandraException
UnavailableException :: CassandraException
TimedOutException :: CassandraException
AuthenticationException :: String -> CassandraException
AuthorizationException :: String -> CassandraException
SchemaDisagreementException :: CassandraException
ConversionException :: String -> CassandraException
OperationNotSupported :: String -> CassandraException

-- | A column selector/filter statement for queries.
--   
--   Remember that SuperColumns are always fully deserialized, so we don't
--   offer a way to filter columns within a <a>SuperColumn</a>.
--   
--   Column names and ranges are specified by any type that can be packed
--   into a Cassandra column using the <a>CasType</a> typeclass.
data Selector

-- | Return everything in <a>Row</a>
All :: Selector

-- | Return specific columns or super-columns depending on the
--   <a>ColumnFamily</a>
ColNames :: [a] -> Selector

-- | When deleting specific columns in a super column
SupNames :: a -> [b] -> Selector

-- | Return a range of columns or super-columns.
Range :: Maybe a -> Maybe b -> Order -> Int32 -> Selector
rangeStart :: Selector -> Maybe a
rangeEnd :: Selector -> Maybe b
rangeOrder :: Selector -> Order
rangeLimit :: Selector -> Int32

-- | A default starting point for range <a>Selector</a>. Use this so you
--   don't run into ambiguous type variables when using Nothing.
--   
--   <pre>
--   range = Range (Nothing :: Maybe ByteString) (Nothing :: Maybe ByteString) Regular 1024
--   </pre>
range :: Selector
boundless :: Maybe ByteString

-- | Order in a range query
data Order
Regular :: Order
Reversed :: Order
reverseOrder :: Order -> Order
data KeySelector
Keys :: [RowKey] -> KeySelector
KeyRange :: KeyRangeType -> RowKey -> RowKey -> Int32 -> KeySelector

-- | Encodes the Key vs. Token options in the thrift API.
--   
--   <a>InclusiveRange</a> ranges are just plain intuitive range queries.
--   <a>WrapAround</a> ranges are also inclusive, but they wrap around the
--   ring.
data KeyRangeType
InclusiveRange :: KeyRangeType
WrapAround :: KeyRangeType

-- | A typeclass to enable using any string-like type for row and column
--   keys
class CKey a
toColKey :: CKey a => a -> ByteString
fromColKey :: CKey a => ByteString -> Either String a

-- | Raise an error if conversion fails
fromColKey' :: CKey a => ByteString -> a
instance Eq a => Eq (ModifyOperation a)
instance Show a => Show (ModifyOperation a)
instance Ord a => Ord (ModifyOperation a)
instance Read a => Read (ModifyOperation a)
