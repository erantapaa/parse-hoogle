-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Session support for the Salvia webserver.
--   
--   Session support for the Salvia webserver.
@package salvia-sessions
@version 1.0.0

module Network.Salvia.Handler.Session

-- | A session identifier. Should be unique for every session.
newtype SessionID
SID :: Integer -> SessionID
_sid :: SessionID -> Integer
sid :: SessionID :-> Integer

-- | The session data type with polymorphic payload.
data Session p
Session :: SessionID -> UTCTime -> UTCTime -> Integer -> Maybe p -> Session p
_sID :: Session p -> SessionID
_sStart :: Session p -> UTCTime
_sLast :: Session p -> UTCTime
_sExpire :: Session p -> Integer
_sPayload :: Session p -> Maybe p

-- | A globally unique session identifier.
sID :: Session p :-> SessionID

-- | The time the session started.
sStart :: Session p :-> UTCTime

-- | Last time session was used.
sLast :: Session p :-> UTCTime

-- | Expire after this amount of time when unused.
sExpire :: Session p :-> Integer

-- | The information this session stores.
sPayload :: Session p :-> Maybe p

-- | Session type classes that hides the inner workings from the outside
--   world.
class (Applicative m, Monad m) => SessionM p m | m -> p
prolongSession :: (SessionM p m) => Integer -> m ()
getSession :: (SessionM p m) => m (Session p)
putSession :: (SessionM p m) => Session p -> m ()
delSession :: (SessionM p m) => m ()
withSession :: (SessionM p m) => (Session p -> Session p) -> m ()

-- | A mapping from unique session IDs to shared session variables.
type SessionMap p = Map SessionID (TVar (Session p))
newtype Sessions p
Sessions :: SessionMap p -> Sessions p
unSessions :: Sessions p -> SessionMap p

-- | Apply a function to the sessions in the <a>Sessions</a> newtype.
withSessions :: (SessionMap p -> SessionMap p) -> Sessions p -> Sessions p

-- | Create a new, empty, store of sessions.
mkSessions :: Sessions p

-- | todo doc: The session handler. This handler will try to return an
--   existing session from the sessions map based on a session identifier
--   found in the HTTP <a>cookie</a>. When such a session can be found the
--   expiration date will be updated to a number of seconds in the future.
--   When no session can be found a new one will be created. A cookie will
--   be set that informs the client of the current session.
hProlongSession :: (MonadIO m, HttpM' m, ServerM m, ServerAddressM m, PayloadM q (Sessions p) m) => p -> Integer -> m ()
hGetSession :: (MonadIO m, HttpM' m, ServerM m, PayloadM q (Sessions p) m) => m (Session p)
hPutSession :: (MonadIO m, HttpM' m, ServerM m, ServerAddressM m, PayloadM q (Sessions p) m) => Session p -> m ()
hDelSession :: (PayloadM q (Sessions p) m, HttpM' m, MonadIO m) => p -> m ()
hWithSession :: (PayloadM q (Sessions p) m, MonadIO m, HttpM Request m) => (Session p -> Session p) -> m ()
hSessionInfo :: (SessionM p m, SendM m) => m ()

-- | todo: Given an existing session identifier lookup a session from the
--   session map. When no session is available, or the session is expired,
--   create a new one using the <a>newSessionVar</a> function. Otherwise
--   the expiration date of the existing session is updated.
existingSessionVarOrNew :: (Applicative m, MonadIO m, HttpM Request m, PayloadM q (Sessions p) m) => m (TVar (Session p))
whenNotExpired :: (MonadIO m) => TVar (Session p) -> m (Maybe (TVar (Session p)))

-- | This handler sets the HTTP cookie for the specified session. It will
--   use a default cookie with an additional <a>sid</a> attribute with the
--   session identifier as value. The session expiration date will be used
--   as the cookie expire field. The session is valid for all subdomains.
setCookieSession :: (MonadIO m, ServerM m, ServerAddressM m, HttpM Response m) => SessionID -> UTCTime -> m ()

-- | Given the (possibly wrong) request cookie, try to recover the existing
--   session identifier.
getCookieSessionID :: (MonadIO m, HttpM Request m) => m (Maybe SessionID)
delCookieSession :: (HttpM Response m) => m ()

-- | Create a new session with a specified expiration date. The session
--   will be stored in the session map.
newSessionVar :: (MonadIO m, PayloadM q (Sessions p) m) => m (TVar (Session p))
newSessionID :: (MonadState (Sessions p) m, Functor m) => [SessionID] -> m SessionID
willExpireAt :: Session p -> UTCTime
lookupSessionVar :: (MonadIO m, PayloadM q (Sessions p) m) => SessionID -> m (Maybe (TVar (Session p)))
newVar :: (MonadIO m) => a -> m (TVar a)
getVar :: (MonadIO m) => TVar a -> m a
putVar :: (MonadIO m) => TVar a -> a -> m ()
modVar :: (MonadIO m) => (a -> a) -> TVar a -> m (TVar a)
instance (Contains q (TVar (Sessions p))) => SessionM p (Handler q)
instance (Show p) => Show (Session p)
instance Show SessionID
instance Eq SessionID
instance Ord SessionID
instance Random SessionID

module Network.Salvia.Handler.Login

-- | User containg a username, password and a list of actions this user is
--   allowed to perform within the system.
type Username = String
type Password = String
type Email = String
type Action = String
data User
User :: Username -> Email -> Password -> [Action] -> User
email :: User :-> Email
username :: User :-> Username
password :: User :-> Password
actions :: User :-> [Action]
class (Applicative m, Monad m) => LoginM p m | m -> p
login :: (LoginM p m) => m a -> (User -> m a) -> m a
loginfo :: (LoginM p m) => m ()
logout :: (LoginM p m) => m ()
signup :: (LoginM p m) => [Action] -> m a -> (User -> m a) -> m a
authorized :: (LoginM p m) => Maybe Action -> m a -> (User -> m a) -> m a

-- | A user payload instance contains user related session information and
--   can be used as the payload for regular sessions. It contains a
--   reference to the user it belongs to, a flag to indicate whether the
--   user is logged in or not and a possible user specific session payload.
data UserPayload a
UserPayload :: User -> Bool -> Maybe a -> UserPayload a
upUser :: UserPayload a -> User
upLoggedIn :: UserPayload a -> Bool
upPayload :: UserPayload a -> Maybe a
type UserSession a = Session (UserPayload a)

-- | A user database containing a list of users and a reference to the
--   backend the database originates from and can be synchronized back to.
data UserDatabase
UserDatabase :: Backend -> [User] -> UserDatabase
users :: UserDatabase :-> [User]
backend :: UserDatabase :-> Backend
data Backend
Backend :: (forall m. (MonadIO m) => m UserDatabase) -> (forall m. (MonadIO m) => User -> m ()) -> Backend
read :: Backend -> forall m. (MonadIO m) => m UserDatabase
add :: Backend -> forall m. (MonadIO m) => User -> m ()

-- | User database backend that does nothing and discards all changes made.
noBackend :: Backend

-- | File based user database backend. Format: <i>username password
--   action*</i>.
fileBackend :: FilePath -> Backend
hGetUser :: (LoginM p m) => m (Maybe User)

-- | The signup handler is used to create a new entry in the user database.
--   It reads a new username and password from the post parameters and adds
--   a new entry into the backend of the user database when no user with
--   such name exists. The user gets the specified initial set of actions
--   assigned. When the signup fails the first handler will be executed
--   when the signup succeeds the second handler will be executed which may
--   access the fresh user object.
hSignup :: (MonadIO m, PayloadM q UserDatabase m, SessionM (UserPayload p) m, BodyM Request m, HttpM Request m) => p -> [Action] -> m a -> (User -> m a) -> m a

-- | The login handler. Read the username and password values from the post
--   data and use that to authenticate the user. When the user can be found
--   in the database the user is logged in and stored in the session
--   payload. When the login fails the first handler will be executed when
--   the login succeeds the second handler will be executed which may
--   access the fresh user object.
hLogin :: (PayloadM q UserDatabase m, SessionM (UserPayload p) m, HttpM Request m, MonadIO m, BodyM Request m) => p -> m a -> (User -> m a) -> m a

-- | Logout the current user by emptying the session payload.
hLogout :: (SessionM (UserPayload p) m) => p -> m ()

-- | The <a>loginfo</a> handler exposes the current user session to the
--   world using a simple text based response. The response contains
--   information about the current session identifier, session start and
--   expiration date and the possible user payload that is included.
hLoginfo :: (SessionM (UserPayload p) m, SendM m) => p -> m ()

-- | Execute a handler only when the user for the current session is
--   authorized to do so. The user must have the specified action contained
--   in its actions list in order to be authorized. When the authorization
--   fails the first handler will be executed when the authorization
--   succeeds the second handler will be executed which may access the
--   current user object.
hAuthorized :: (SessionM (UserPayload p) m) => p -> Maybe Action -> m b -> (User -> m b) -> m b
instance (Contains q (TVar (Sessions (UserPayload p))), Contains q (TVar UserDatabase)) => LoginM p (Handler q)
instance (Eq a) => Eq (UserPayload a)
instance (Show a) => Show (UserPayload a)
instance Eq User
instance Show User
