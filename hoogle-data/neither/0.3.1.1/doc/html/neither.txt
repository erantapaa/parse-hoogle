-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Provide versions of Either with good monad and applicative instances. (deprecated)
--   
--   The standard Either datatype suffers from a lack of monad and
--   applicative instances. To make matters worse, the mtl and transformers
--   packages provide orphan instances which conflict with each other, as
--   well as defining a transformer version which has an usually
--   unnecessary superclass constraint.
--   
--   Besides these annoyances, there is another issue: there exist two
--   reasonable definitions of the Applicative instance for Either: one the
--   holds onto only the first Left value, or one that appends all Left
--   values together via a Monoid instance. The former is compatible with
--   the monad instance, while the latter is not.
--   
--   This package defines three datatypes, some helpers functions and
--   instances. The data types are AEither, MEither and MEitherT. AEither
--   provides an Applicative instance which appends Left values, MEither
--   provides the monadic definition, and MEitherT is a monad transformer.
@package neither
@version 0.3.1.1


-- | This module provides three different datatypes: <a>AEither</a> is the
--   applicative version of Either. It does not provide a monad instance,
--   and <a>mappend</a>s together error values. <a>MEither</a> is the
--   monadic version, which only holds onto the first error value.
--   <a>MEitherT</a> is a monad transformer.
--   
--   Also, *Either datatypes and utility functions from Data.Either are
--   generalized with <a>Neither</a> type class.
module Data.Neither
data AEither a b
ALeft :: a -> AEither a b
ARight :: b -> AEither a b
aeither :: (a -> c) -> (b -> c) -> AEither a b -> c
data MEither a b
MLeft :: a -> MEither a b
MRight :: b -> MEither a b
meither :: (a -> c) -> (b -> c) -> MEither a b -> c
newtype MEitherT e m a
MEitherT :: m (MEither e a) -> MEitherT e m a
runMEitherT :: MEitherT e m a -> m (MEither e a)
mapMEitherT :: (m (MEither e a) -> n (MEither e' b)) -> MEitherT e m a -> MEitherT e' n b
throwMEither :: Monad m => e -> MEitherT e m a
class Neither e
left :: Neither e => a -> e a b
right :: Neither e => b -> e a b
either :: Neither e => (a -> c) -> (b -> c) -> e a b -> c
mapLeft :: Neither e => (a -> c) -> e a b -> e c b
mapRight :: Neither e => (b -> c) -> e a b -> e a c
mapEither :: Neither e => (a -> c) -> (b -> d) -> e a b -> e c d
lefts :: (Neither e, MonadPlus m) => m (e a b) -> m a
rights :: (Neither e, MonadPlus m) => m (e a b) -> m b
partitionEithers :: (Neither e, MonadPlus m) => m (e a b) -> (m a, m b)
instance Typeable2 MEither
instance Typeable2 AEither
instance (Eq a, Eq b) => Eq (MEither a b)
instance (Data a, Data b) => Data (MEither a b)
instance (Ord a, Ord b) => Ord (MEither a b)
instance (Read a, Read b) => Read (MEither a b)
instance (Show a, Show b) => Show (MEither a b)
instance (Eq a, Eq b) => Eq (AEither a b)
instance (Data a, Data b) => Data (AEither a b)
instance (Ord a, Ord b) => Ord (AEither a b)
instance (Read a, Read b) => Read (AEither a b)
instance (Show a, Show b) => Show (AEither a b)
instance MonadIO m => MonadIO (MEitherT e m)
instance MonadTrans (MEitherT e)
instance Monad m => Failure e (MEitherT e m)
instance Monad m => Monad (MEitherT e m)
instance (Functor m, Monad m) => Applicative (MEitherT e m)
instance Functor m => Functor (MEitherT e m)
instance Monoid a => Applicative (AEither a)
instance Functor (AEither a)
instance Failure e (MEither e)
instance Applicative (MEither a)
instance Functor (MEither a)
instance Monad (MEither a)
instance Neither AEither
instance Neither MEither
instance Neither Either
