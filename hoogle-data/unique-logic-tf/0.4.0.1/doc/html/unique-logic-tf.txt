-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Solve simple simultaneous equations
--   
--   Solve a number of equations simultaneously. This is not Computer
--   Algebra, better think of a kind of type inference algorithm or logic
--   programming with only one allowed solution.
--   
--   Only one solution is computed. Simultaneous equations with multiple
--   solutions are not allowed. However, variables may remain undefined.
--   The solver may optionally check for consistency. It does not do so by
--   default since with floating point numbers or symbolic expressions even
--   simple rules may not be consistent.
--   
--   The modules ordered with respect to abstraction level are:
--   
--   <ul>
--   <li><a>UniqueLogic.ST.TF.System</a>: Construct and solve sets of
--   functional dependencies. Example: <tt>assignment3 (+) a b c</tt>
--   meaning dependency <tt>a+b -&gt; c</tt>.</li>
--   <li><a>UniqueLogic.ST.TF.Rule</a>: Combine functional dependencies to
--   rules that can apply in multiple directions. Example: <tt>add a b
--   c</tt> means relation <tt>a+b = c</tt> which resolves to dependencies
--   <tt>a+b -&gt; c, c-a -&gt; b, c-b -&gt; a</tt>. For an executable
--   example see <a>UniqueLogic.ST.TF.Example.Rule</a>.</li>
--   <li><a>UniqueLogic.ST.TF.Expression</a>: Allows to write rules using
--   arithmetic operators. It creates temporary variables automatically.
--   Example: <tt>(a+b)*c =:= d</tt> resolves to <tt>a+b = x, x*c = d</tt>.
--   For an executable example see
--   <a>UniqueLogic.ST.TF.Example.Expression</a>.</li>
--   <li><a>UniqueLogic.ST.TF.System.Simple</a>: Provides specialised
--   functions from <a>UniqueLogic.ST.TF.System</a> for the case of a
--   system without labels and consistency checks.</li>
--   <li><a>UniqueLogic.ST.TF.System.Label</a>: Provides a custom
--   constructor for variables. When creating a variable you decide whether
--   and how an assignment to this variable shall be logged. There is an
--   example that shows how to solve a logic system using symbolic
--   expressions. The naming and logging allows us to observe shared
--   intermediate results. For an executable example see
--   <a>UniqueLogic.ST.TF.Example.Label</a>.</li>
--   <li>By using more sophisticated monad transformers, we can check the
--   equations for consistency, report inconsistencies and how they arised.
--   We demonstrate that in <a>UniqueLogic.ST.TF.Example.Verify</a>.</li>
--   </ul>
--   
--   This variant of the package requires type families.
@package unique-logic-tf
@version 0.4.0.1


-- | This module is intended for documentation purposes. Do not import it!
module UniqueLogic.ST.TF.Example.Term
data T
Const :: Rational -> T
Var :: Name -> T
Max :: T -> T -> T
Add :: T -> T -> T
Sub :: T -> T -> T
Mul :: T -> T -> T
Div :: T -> T -> T
Abs :: T -> T
Signum :: T -> T
type Name = String
instance Show T
instance Fractional T
instance Num T

module UniqueLogic.ST.TF.MonadTrans

-- | Provide the methods that make a transformed monad a monad.
class MonadTrans t => C t
point :: (C t, Monad m) => a -> t m a
bind :: (C t, Monad m) => t m a -> (a -> t m b) -> t m b

-- | Build a regular monad for generic monad transformer and monad. The
--   <a>Const</a> type allows us to force the kind (m :: * -&gt; *) without
--   using ExplicitKindSignatures.
newtype Wrap t m a
Wrap :: (Const (t m a) (m a)) -> Wrap t m a
wrap :: t m a -> Wrap t m a
unwrap :: Wrap t m a -> t m a
lift :: (C t, Monad m) => m a -> Wrap t m a
instance (C t, Monad m) => Monad (Wrap t m)
instance (C t, Monad m) => Applicative (Wrap t m)
instance (C t, Monad m) => Functor (Wrap t m)
instance C MaybeT
instance C (ExceptionalT e)
instance Monoid w => C (WriterT w)
instance C IdentityT

module UniqueLogic.ST.TF.System
data Variable w s a
globalVariable :: (C w, Value w a) => SimpleUpdater w s a -> ST s (Variable w s a)
class C w => C w
update :: (C w, Value w a) => Updater w s a
simpleUpdate :: (C w, Value w a) => SimpleUpdater w s a
updateIfNew :: C w => Updater w s a
updateAndCheck :: C w => (a -> a -> Wrap w (ST s) ()) -> Updater w s a
class C t => Fragile t
break :: (Fragile t, Monad m) => Wrap t m a
class C w => Value w a where data family ValueConstraint w a :: *
valueConstraint :: Value w a => STRef s (Updates w s) -> STRef s (Maybe a) -> ValueConstraint w a
data T w s a
localVariable :: (C w, Value w a) => T w s (Variable w s a)
constant :: (C w, Value w a) => a -> T w s (Variable w s a)
assignment2 :: C w => (a -> b) -> Variable w s a -> Variable w s b -> T w s ()
assignment3 :: C w => (a -> b -> c) -> Variable w s a -> Variable w s b -> Variable w s c -> T w s ()
data Apply w s a

-- | This function allows to generalize <a>assignment2</a> and
--   <a>assignment3</a> to more arguments. You could achieve the same with
--   nested applications of <tt>assignment3 (,)</tt>.
arg :: Variable w s a -> Apply w s a
runApply :: C w => Apply w s a -> Variable w s a -> T w s ()
solve :: C w => T w s a -> w (ST s) a
solveDepthFirst :: C w => T w s a -> w (ST s) a
solveBreadthFirst :: C w => T w s a -> w (ST s) a
query :: Variable w s a -> ST s (Maybe a)
instance Eq Order
instance Enum Order
instance Applicative (Apply w s)
instance Functor (Apply w s)
instance Inconsistency e => C (ExceptionalT e)
instance (Inconsistency e, Eq a) => Value (ExceptionalT e) a
instance Monoid w => C (WriterT w)
instance Monoid w => Value (WriterT w) a
instance C IdentityT
instance Value IdentityT a
instance Inconsistency e => Fragile (ExceptionalT e)
instance Monad (T w s)
instance Applicative (T w s)
instance Functor (T w s)
instance Monoid (Updates w s)

module UniqueLogic.ST.TF.System.Simple
type Variable s a = Variable IdentityT s a
globalVariable :: ST s (Variable s a)
type T = T IdentityT
localVariable :: T s (Variable s a)
constant :: a -> T s (Variable s a)
assignment2 :: C w => (a -> b) -> Variable w s a -> Variable w s b -> T w s ()
assignment3 :: C w => (a -> b -> c) -> Variable w s a -> Variable w s b -> Variable w s c -> T w s ()
data Apply w s a

-- | This function allows to generalize <a>assignment2</a> and
--   <a>assignment3</a> to more arguments. You could achieve the same with
--   nested applications of <tt>assignment3 (,)</tt>.
arg :: Variable w s a -> Apply w s a
runApply :: C w => Apply w s a -> Variable w s a -> T w s ()
solve :: T s a -> ST s a
query :: Variable s a -> ST s (Maybe a)

module UniqueLogic.ST.TF.System.Label
type Variable w = Variable (WriterT w)
globalVariable :: Monoid w => (a -> Writer w a) -> ST s (Variable w s a)
type T w = T (WriterT w)
localVariable :: (C w, Value w a) => T w s (Variable w s a)
constant :: (C w, Value w a) => a -> T w s (Variable w s a)
assignment2 :: C w => (a -> b) -> Variable w s a -> Variable w s b -> T w s ()
assignment3 :: C w => (a -> b -> c) -> Variable w s a -> Variable w s b -> Variable w s c -> T w s ()
data Apply w s a

-- | This function allows to generalize <a>assignment2</a> and
--   <a>assignment3</a> to more arguments. You could achieve the same with
--   nested applications of <tt>assignment3 (,)</tt>.
arg :: Variable w s a -> Apply w s a
runApply :: C w => Apply w s a -> Variable w s a -> T w s ()
solve :: C w => T w s a -> w (ST s) a
query :: Variable w s a -> ST s (Maybe a)

module UniqueLogic.ST.TF.Rule
generic2 :: C w => (b -> a) -> (a -> b) -> Variable w s a -> Variable w s b -> T w s ()
generic3 :: C w => (b -> c -> a) -> (c -> a -> b) -> (a -> b -> c) -> Variable w s a -> Variable w s b -> Variable w s c -> T w s ()
equ :: C w => Variable w s a -> Variable w s a -> T w s ()

-- | You might be tempted to use the <a>pair</a> rule to collect parameters
--   for rules with more than three arguments. This is generally not a good
--   idea since this way you lose granularity. For building rules with more
--   than three arguments, please build according assignments with
--   <a>arg</a> and <a>runApply</a> and bundle these assignments to rules.
--   This is the way, <a>generic2</a> and <a>generic3</a> work.
pair :: C w => Variable w s a -> Variable w s b -> Variable w s (a, b) -> T w s ()
max :: (Ord a, C w) => Variable w s a -> Variable w s a -> Variable w s a -> T w s ()
add :: (Num a, C w) => Variable w s a -> Variable w s a -> Variable w s a -> T w s ()
mul :: (Fractional a, C w) => Variable w s a -> Variable w s a -> Variable w s a -> T w s ()
square :: (Floating a, C w) => Variable w s a -> Variable w s a -> T w s ()
pow :: (Floating a, C w) => Variable w s a -> Variable w s a -> Variable w s a -> T w s ()

module UniqueLogic.ST.TF.Expression

-- | An expression is defined by a set of equations and the variable at the
--   top-level. The value of the expression equals the value of the top
--   variable.
data T w s a

-- | Make a constant expression of a simple numeric value.
constant :: (C w, Value w a) => a -> T w s a
fromVariable :: Variable w s a -> T w s a
fromRule1 :: (C w, Value w a) => (Variable w s a -> T w s ()) -> (T w s a)
fromRule2 :: (C w, Value w b) => (Variable w s a -> Variable w s b -> T w s ()) -> (T w s a -> T w s b)
fromRule3 :: (C w, Value w c) => (Variable w s a -> Variable w s b -> Variable w s c -> T w s ()) -> (T w s a -> T w s b -> T w s c)
data Apply w s f

-- | This function allows to generalize <a>fromRule2</a> and
--   <a>fromRule3</a> to more arguments using <a>Applicative</a>
--   combinators.
--   
--   Example:
--   
--   <pre>
--   fromRule3 rule x y
--      = runApply $ liftA2 rule (arg x) (arg y)
--      = runApply $ pure rule &lt;*&gt; arg x &lt;*&gt; arg y
--   </pre>
--   
--   Building rules with <a>arg</a> provides more granularity than using
--   auxiliary <a>pair</a> rules!
arg :: T w s a -> Apply w s (Variable w s a)
runApply :: (C w, Value w a) => Apply w s (Variable w s a -> T w s ()) -> T w s a
(=:=) :: C w => T w s a -> T w s a -> T w s ()
(=!=) :: C w => T w s a -> T w s a -> T w s a
sqr :: (C w, Value w a, Floating a) => T w s a -> T w s a
sqrt :: (C w, Value w a, Floating a) => T w s a -> T w s a

-- | We are not able to implement a full Ord instance including Eq
--   superclass and comparisons, but we need to compute maxima.
max :: (C w, Ord a, Value w a) => T w s a -> T w s a -> T w s a
maximum :: (C w, Ord a, Value w a) => [T w s a] -> T w s a

-- | Construct or decompose a pair.
pair :: (C w, Value w a, Value w b, Value w (a, b)) => T w s a -> T w s b -> T w s (a, b)
instance (C w, Value w a, Fractional a) => Fractional (T w s a)
instance (C w, Value w a, Fractional a) => Num (T w s a)
instance Applicative (Apply w s)
instance Functor (Apply w s)


-- | <i>Warning: This module is intended for documentation purposes. Do not
--   import it! </i>
module UniqueLogic.ST.TF.Example.Expression
example :: (Maybe Double, Maybe Double)


-- | <i>Warning: This module is intended for documentation purposes. Do not
--   import it! </i>
module UniqueLogic.ST.TF.Example.Rule

-- | <pre>
--   x=1
--   y=2
--   z=3
--   w=3
--   </pre>
--   
--   <pre>
--   x+y=3
--   y*z=6
--   z=3
--   y^w=8
--   </pre>
example :: (Maybe Double, Maybe Double, Maybe Double, Maybe Double)


-- | <i>Warning: This module is intended for documentation purposes. Do not
--   import it! </i>
module UniqueLogic.ST.TF.Example.Label
data Assign
Assign :: Name -> T -> Assign
type Assigns = [Assign]
type Variable s = Variable Assigns s T
globalVariable :: Name -> ST s (Variable s)
constant :: Rational -> T Assigns s (Variable s)

-- | <pre>
--   x=1
--   y=2
--   z=3
--   </pre>
--   
--   <pre>
--   x+y=3
--   y*z=6
--   z=3
--   </pre>
rule :: ((Maybe T, Maybe T, Maybe T), Assigns)
expression :: ((Maybe T, Maybe T), Assigns)
instance Show Assign


-- | <i>Warning: This module is intended for documentation purposes. Do not
--   import it! </i>
module UniqueLogic.ST.TF.Example.Verify
data Assign
Assign :: Name -> (TrackedNumber Rational) -> Assign
type Assigns = [Assign]
data TrackedNumber a
TrackedNumber :: T -> a -> TrackedNumber a
tn1 :: (T -> T) -> (a -> b) -> TrackedNumber a -> TrackedNumber b
tn2 :: (T -> T -> T) -> (a -> b -> c) -> TrackedNumber a -> TrackedNumber b -> TrackedNumber c
class ToTrackedNumber a
toTrackedNumber :: ToTrackedNumber a => a -> TrackedNumber Rational
newtype Track m a
Track :: ExceptionalT Exception (WriterT Assigns m) a -> Track m a
runTrack :: Track m a -> ExceptionalT Exception (WriterT Assigns m) a
data Exception
Exception :: (Maybe Name) -> (TrackedNumber Rational) -> (TrackedNumber Rational) -> Exception
type Variable s = Variable Track s (TrackedNumber Rational)
globalVariable :: Name -> ST s (Variable s)
match :: Eq a => TrackedNumber a -> TrackedNumber a -> Bool
inconsistency :: Monad m => Maybe Name -> TrackedNumber Rational -> TrackedNumber Rational -> Wrap Track m ()
logUpdate :: Real a => Name -> MaybeT (ST s) (TrackedNumber a) -> MaybeT (Wrap Track (ST s)) (TrackedNumber a)
example :: (Exceptional Exception (Maybe (TrackedNumber Rational), Maybe (TrackedNumber Rational)), Assigns)
instance Show a => Show (TrackedNumber a)
instance Show Assign
instance Show Exception
instance C Track
instance ToTrackedNumber tn => Value Track tn
instance Real a => ToTrackedNumber (TrackedNumber a)
instance C Track
instance MonadTrans Track
instance Monad m => Monad (Track m)
instance Monad m => Applicative (Track m)
instance Monad m => Functor (Track m)
instance Fractional a => Fractional (TrackedNumber a)
instance Num a => Num (TrackedNumber a)
instance Functor TrackedNumber
