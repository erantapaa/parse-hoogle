-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Parsing and unambiguously representing musical chords.
--   
@package HarmTrace-Base
@version 1.4.0.1


-- | Summary: A set of types and classes for representing musical time,
--   mainly (but not necessarily) in the context of recognising chords from
--   an arbitrary audio source.
module HarmTrace.Base.Time

-- | A type synonym is defined for our main numerical representation, this
--   allows us to easily change the precision.
type NumData = Double

-- | A datatype that wraps around an (musical) datatype, adding information
--   about the musical time to this datatype. Musical time is stored as a
--   list of <a>BeatTime</a> time stamps that can optionally be augmented
--   with information about the <a>Beat</a> position of the particular time
--   stamp inside the bar.
data Timed a
Timed :: a -> [BeatTime] -> Timed a

-- | Returns the contained datatype
getData :: Timed a -> a

-- | Returns the list of TimeStamps
getTimeStamps :: Timed a -> [BeatTime]

-- | For now, we fix the number of available beats to four, because this is
--   also hard-coded into the bar and beat-tracker.
data Beat
One :: Beat
Two :: Beat
Three :: Beat
Four :: Beat
NoBeat :: Beat

-- | Represents a musical time stamp, which is a <a>NumData</a> possibly
--   augmented with a <a>Beat</a> denoting the position of the time stamp
--   within a bar.
data BeatTime
BeatTime :: NumData -> Beat -> BeatTime
Time :: NumData -> BeatTime

-- | alternative <a>Timed</a> constructor
timed :: a -> NumData -> NumData -> Timed a

-- | alternative <a>Timed</a> constructor
timedBT :: a -> BeatTime -> BeatTime -> Timed a

-- | Returns the start time stamp
getBeatTime :: Timed a -> BeatTime

-- | Returns the start <a>Beat</a>
getBeat :: Timed a -> Beat

-- | Returns the onset time stamp
onset :: Timed a -> NumData

-- | Returns the offset time stamp
offset :: Timed a -> NumData

-- | Returns the duration of <a>Timed</a>
duration :: Timed a -> NumData

-- | wraps a datatype in <a>Timed</a>
setData :: Timed a -> b -> Timed b

-- | Given a list of <a>Timed</a> values, returns the end time of the
--   latest element in the list.
getEndTime :: [Timed a] -> NumData

-- | merges consecutive <a>Timed</a> values that store the same element
--   (using ('(==)'). For example:
--   
--   <pre>
--   &gt;&gt;&gt; mergeTimed [timed "c" 0 1, timed "c" 1 2, timed "d" 3 4, timed "d" 4 5, timed "e" 5 6]
--   
--   &gt;&gt;&gt; [Timed {getData = "c", getTimeStamps = [(0.0),(1.0),(2.0)]}
--   
--   &gt;&gt;&gt; ,Timed {getData = "d", getTimeStamps = [(3.0),(4.0),(5.0)]}
--   
--   &gt;&gt;&gt; ,Timed {getData = "e", getTimeStamps = [(5.0),(6.0)]}]
--   </pre>
mergeTimed :: Eq a => [Timed a] -> [Timed a]

-- | Does exactly what <a>mergeTimed</a> does, but allows for a custom
--   equality function
mergeTimedWith :: Eq a => (a -> a -> Bool) -> [Timed a] -> [Timed a]

-- | the inverse of <a>mergeTimed</a>, expanding the list <a>Timed</a>
--   elements to all timestamps stored in the <a>getTimeStamps</a> list.
--   N.B.
--   
--   <pre>
--   &gt;&gt;&gt; expandTimed (mergeTimed x) = x :: [Timed a]
--   </pre>
--   
--   also,
--   
--   <pre>
--   &gt;&gt;&gt; (expandTimed cs) = cs
--   </pre>
--   
--   and,
--   
--   <pre>
--   &gt;&gt;&gt; mergeTimed (mergeTimed (mergeTimed cs)) = (mergeTimed cs)
--   </pre>
--   
--   hold. This has been tested on the first tranche of 649 Billboard
--   songs.
expandTimed :: [Timed a] -> [Timed a]

-- | concatenates the <a>BeatTime</a> timestamps of two <a>Timed</a>s and
--   creates a new <a>Timed</a> that stores the first argument. N.B. this
--   function uses <a>timeComp</a> to allow for very small timing
--   deviations
concatTimed :: a -> Timed a -> Timed a -> Timed a

-- | Splits a <a>Timed</a> in two <a>Timed</a>s at the specified position.
--   If the position is out of range, an error is thrown.
--   
--   <pre>
--   &gt;&gt;&gt; splitTimed (Timed "x" [Time 2, Time 5]) 4
--   
--   &gt;&gt;&gt; ( Timed {getData = "x", getTimeStamps = [(2.0),(4.0)]}
--   
--   &gt;&gt;&gt; , Timed {getData = "x", getTimeStamps = [(4.0),(5.0)]} )
--   </pre>
splitTimed :: Show a => Timed a -> NumData -> (Timed a, Timed a)

-- | returns the next beat, e.g. <tt> nextBeat Two = Three </tt>. Following
--   the (current) definition of <a>Beat</a>, we still assume 4/4, in the
--   future this function should also have the meter as an argument.
nextBeat :: Beat -> Beat

-- | returns the previous <a>Beat</a>, similar to <a>prevBeat</a>.
--   
--   returns the next beat, e.g. <tt> nextBeat Two = Three </tt>. Following
--   the (current) definition of <a>Beat</a>, we still assume 4/4, in the
--   future this function should also have the meter as an argument.
prevBeat :: Beat -> Beat

-- | drops the time (with or without <a>Beat</a>) information of a list
--   <a>Timed</a> data structure
dropTimed :: [Timed a] -> [a]

-- | Returns the <a>NumData</a> timestamp, given a <a>BeatTime</a>
timeStamp :: BeatTime -> NumData

-- | compares to <a>NumData</a> timestamps taking a rounding error
--   <a>roundingError</a> into account.
timeComp :: NumData -> NumData -> Ordering

-- | When reducing and expanding <a>Timed</a> types there might be rounding
--   errors in the floating point time stamps. The <a>roundingError</a>
--   parameter sets the acceptable rounding error that is used in the
--   comparison of time stamps (e.g. see <a>timeComp</a>)
roundingError :: NumData

-- | Returns the <a>NumData</a> timestamp, given a <a>BeatTime</a>
beat :: BeatTime -> Beat

-- | Pretty prints a single <a>Timed</a>
pprint :: Show a => Timed a -> String

-- | Pretty prints a list of <a>Timed</a>s, one per line
prettyPrint :: Show a => [Timed a] -> String
instance Eq Beat
instance Ord Beat
instance Enum Beat
instance Eq BeatTime
instance Functor Timed
instance Show a => Show (Timed a)
instance Eq a => Eq (Timed a)
instance Ord BeatTime
instance Show BeatTime
instance Show Beat


-- | Summary: Some general parsing utilities used for parsing textual chord
--   representations.
module HarmTrace.Base.Parse.General

-- | Top-level parser that ignores error-reporting, regardless of there
--   were error in the parse
parseData :: (ListLike s a, Show a) => P (Str a s LineColPos) b -> s -> b

-- | Top-level parser that returns both the result as well as a (possibly
--   empty) list of error-corrections.
parseDataWithErrors :: (ListLike s a, Show a) => P (Str a s LineColPos) b -> s -> (b, [Error LineColPos])

-- | This is identical to <a>parseData</a> however it will throw an
--   <a>error</a> when the the list with parsing errors is not empty. No,
--   this will not make your program more safe. However, in certain cases
--   you really want to be sure that parsing has finished without errors.
--   In those cases you should use <a>parseDataSafe</a>.
parseDataSafe :: (ListLike s a, Show a, Show s) => P (Str a s LineColPos) b -> s -> b

-- | Parses a specific string
pString :: (ListLike state a, IsLocationUpdatedBy loc a, Show a, Eq a) => [a] -> P (Str a state loc) [a]

-- | Parses UNIX and DOS/WINDOWS line endings including trailing whitespace
pLineEnd :: Parser String

-- | Parses an arbitrary times the first parsing combinator until the
--   parsing second parsing combinator is encountered. The result of the
--   second parsing combinator is ignored.
pManyTill :: P st a -> P st b -> P st [a]


-- | Summary: A set of types and classes for representing musical chords.
--   The chord datatypes are based on the unambiguous chord representation
--   presented in: Christopher Harte, Mark Sandler and Samer Abdallah
--   (2005), <i>Symbolic representation of musical chords: a proposed
--   syntax for text annotations</i>, In: Proceedings of 6th International
--   Conference on Music Information Retrieval
--   (<a>http://ismir2005.ismir.net/proceedings/1080.pdf</a>).
module HarmTrace.Base.Chord.Datatypes

-- | A musical note is a pitch (either absolute or relative) possibly
--   modified by an <a>Accidental</a>
data Note a
Note :: Accidental -> a -> Note a

-- | A musical <a>Accidental</a>
data Accidental

-- | natural
Nat :: Accidental

-- | sharp
Sh :: Accidental

-- | flat
Fl :: Accidental

-- | double sharp
SS :: Accidental

-- | double flat
FF :: Accidental

-- | Representing absolute <a>Root</a> notes
type Root = Note DiatonicNatural

-- | The seven diatonic naturals
data DiatonicNatural
C :: DiatonicNatural
D :: DiatonicNatural
E :: DiatonicNatural
F :: DiatonicNatural
G :: DiatonicNatural
A :: DiatonicNatural
B :: DiatonicNatural

-- | Key relative scale degrees to abstract from the absolute Root notes
type ScaleDegree = Note DiatonicDegree

-- | All Diatonic scale degrees
data DiatonicDegree
I :: DiatonicDegree
II :: DiatonicDegree
III :: DiatonicDegree
IV :: DiatonicDegree
V :: DiatonicDegree
VI :: DiatonicDegree
VII :: DiatonicDegree

-- | for unrepresentable scale degrees
Imp :: DiatonicDegree

-- | A musical key consising of a <a>Root</a> and <a>Mode</a>
data Key
Key :: Root -> Mode -> Key
keyRoot :: Key -> Root
keyMode :: Key -> Mode

-- | The <a>Mode</a> of a key, which can be major or minor
data Mode
MajMode :: Mode
MinMode :: Mode

-- | The representation for a single chord consisting of a root, a
--   <a>Shorthand</a> representing the interval structure of the chord, a
--   list of <tt>Additions</tt>, for representing other (additional)
--   structure, and the base <tt>Inversion</tt>
data Chord a

-- | a regular chord
Chord :: a -> Shorthand -> [Addition] -> Interval -> Chord a

-- | No sounding chord (silence, noise, etc.)
NoChord :: Chord a

-- | An undefined chord
UndefChord :: Chord a

-- | Returns the root of a <a>Chord</a>, and throws an error in case of a
--   <a>NoChord</a> or an <a>UndefChord</a>.
chordRoot :: Show a => Chord a -> a

-- | Returns the <a>Shorthand</a> of a <a>Chord</a>, and throws an error in
--   case of a <a>NoChord</a> or an <a>UndefChord</a>.
chordShorthand :: Show a => Chord a -> Shorthand

-- | Returns the list of <tt>Additions</tt> of a <a>Chord</a>, and throws
--   an error in case of a <a>NoChord</a> or an <a>UndefChord</a>.
chordAdditions :: Show a => Chord a -> [Addition]

-- | Returns the bass <a>Interval</a> of a <a>Chord</a>, and throws an
--   error in case of a <a>NoChord</a> or an <a>UndefChord</a>.
chordBass :: Show a => Chord a -> Interval
data Shorthand

-- | Triadic chords
Maj :: Shorthand
Min :: Shorthand
Dim :: Shorthand
Aug :: Shorthand

-- | Seventh chords
Maj7 :: Shorthand
Min7 :: Shorthand
Sev :: Shorthand
Dim7 :: Shorthand
HDim7 :: Shorthand
MinMaj7 :: Shorthand
Aug7 :: Shorthand

-- | Sixth chords
Maj6 :: Shorthand
Min6 :: Shorthand

-- | Extended chords
Nin :: Shorthand
Maj9 :: Shorthand
Min9 :: Shorthand

-- | Suspended chords
Sus4 :: Shorthand
Sus2 :: Shorthand
SevSus4 :: Shorthand

-- | Power chords
Five :: Shorthand
None :: Shorthand
Eleven :: Shorthand
Thirteen :: Shorthand
Min11 :: Shorthand
Maj13 :: Shorthand
Min13 :: Shorthand

-- | Intervals for additional chord notes
data Addition
Add :: Interval -> Addition
NoAdd :: Interval -> Addition

-- | Diatonic major intervals used to denote <a>Chord</a> <a>Addition</a>s
--   and bass <a>Interval</a>s
data IntNat
I1 :: IntNat
I2 :: IntNat
I3 :: IntNat
I4 :: IntNat
I5 :: IntNat
I6 :: IntNat
I7 :: IntNat
I8 :: IntNat
I9 :: IntNat
I10 :: IntNat
I11 :: IntNat
I12 :: IntNat
I13 :: IntNat
type Interval = Note IntNat

-- | A chord based on absolute <a>Root</a> notes
type ChordLabel = Chord Root

-- | A chord based on relative <a>ScaleDegree</a>s
type ChordDegree = Chord ScaleDegree

-- | Updates the root field of a <a>Chord</a> updateRoot :: Chord a -&gt; a
--   -&gt; Chord a updateRoot (Chord r sh a b) r' = Chord r' sh a b
--   
--   We introduce four chord categories: major chords, minor chords,
--   dominant seventh chords, and diminished seventh chords
data ClassType
MajClass :: ClassType
MinClass :: ClassType
DomClass :: ClassType
DimClass :: ClassType
NoClass :: ClassType

-- | A <a>Triad</a> comes in four flavours: major, minor, augmented,
--   diminished, and sometimes a chord does not have a triad (e.g.
--   suspended chords, etc.)
data Triad
MajTriad :: Triad
MinTriad :: Triad
AugTriad :: Triad
DimTriad :: Triad
NoTriad :: Triad

-- | A Constructor for a simple chord based on a <a>Root</a> and
--   <a>Shorthand</a> only
shortChord :: Root -> Shorthand -> ChordLabel

-- | Discards a base note by replacing the bass <a>Interval</a> by a
--   <a>Note</a> <a>Nat</a> <a>I1</a>
discardBass :: Chord a -> Chord a

-- | Returns True if the <a>ChordLabel</a> is not a chord, and False
--   otherwise
isNoneChord :: ChordLabel -> Bool

-- | Returns true if the <a>Chord</a> <a>Addition</a> represents an
--   addition and not a degree that has to be removed (*).
isAddition :: Addition -> Bool

-- | Checks if the <a>ChordLabel</a> is a <a>NoChord</a> or
--   <a>UndefChord</a> and throws an error using the first argument as an
--   function identifier for debugging. In case of a <a>ChordLabel</a> the
--   second argument is applied to the third argument.
catchNoChord :: Show a => String -> (Chord a -> b) -> Chord a -> b
instance Eq Mode
instance Ord Mode
instance Generic Mode
instance Eq ClassType
instance Enum ClassType
instance Ord ClassType
instance Bounded ClassType
instance Generic ClassType
instance Eq Shorthand
instance Ord Shorthand
instance Enum Shorthand
instance Bounded Shorthand
instance Generic Shorthand
instance Show DiatonicDegree
instance Eq DiatonicDegree
instance Enum DiatonicDegree
instance Ord DiatonicDegree
instance Bounded DiatonicDegree
instance Generic DiatonicDegree
instance Show DiatonicNatural
instance Eq DiatonicNatural
instance Enum DiatonicNatural
instance Ord DiatonicNatural
instance Bounded DiatonicNatural
instance Generic DiatonicNatural
instance Eq IntNat
instance Enum IntNat
instance Ord IntNat
instance Bounded IntNat
instance Generic IntNat
instance Eq Accidental
instance Ord Accidental
instance Generic Accidental
instance Eq a => Eq (Note a)
instance Ord a => Ord (Note a)
instance Generic (Note a)
instance Eq Addition
instance Ord Addition
instance Generic Addition
instance Eq a => Eq (Chord a)
instance Ord a => Ord (Chord a)
instance Generic (Chord a)
instance Functor Chord
instance Eq Key
instance Ord Key
instance Generic Key
instance Ord Triad
instance Eq Triad
instance Generic Triad
instance Datatype D1Mode
instance Constructor C1_0Mode
instance Constructor C1_1Mode
instance Datatype D1ClassType
instance Constructor C1_0ClassType
instance Constructor C1_1ClassType
instance Constructor C1_2ClassType
instance Constructor C1_3ClassType
instance Constructor C1_4ClassType
instance Datatype D1Shorthand
instance Constructor C1_0Shorthand
instance Constructor C1_1Shorthand
instance Constructor C1_2Shorthand
instance Constructor C1_3Shorthand
instance Constructor C1_4Shorthand
instance Constructor C1_5Shorthand
instance Constructor C1_6Shorthand
instance Constructor C1_7Shorthand
instance Constructor C1_8Shorthand
instance Constructor C1_9Shorthand
instance Constructor C1_10Shorthand
instance Constructor C1_11Shorthand
instance Constructor C1_12Shorthand
instance Constructor C1_13Shorthand
instance Constructor C1_14Shorthand
instance Constructor C1_15Shorthand
instance Constructor C1_16Shorthand
instance Constructor C1_17Shorthand
instance Constructor C1_18Shorthand
instance Constructor C1_19Shorthand
instance Constructor C1_20Shorthand
instance Constructor C1_21Shorthand
instance Constructor C1_22Shorthand
instance Constructor C1_23Shorthand
instance Constructor C1_24Shorthand
instance Constructor C1_25Shorthand
instance Datatype D1DiatonicDegree
instance Constructor C1_0DiatonicDegree
instance Constructor C1_1DiatonicDegree
instance Constructor C1_2DiatonicDegree
instance Constructor C1_3DiatonicDegree
instance Constructor C1_4DiatonicDegree
instance Constructor C1_5DiatonicDegree
instance Constructor C1_6DiatonicDegree
instance Constructor C1_7DiatonicDegree
instance Datatype D1DiatonicNatural
instance Constructor C1_0DiatonicNatural
instance Constructor C1_1DiatonicNatural
instance Constructor C1_2DiatonicNatural
instance Constructor C1_3DiatonicNatural
instance Constructor C1_4DiatonicNatural
instance Constructor C1_5DiatonicNatural
instance Constructor C1_6DiatonicNatural
instance Datatype D1IntNat
instance Constructor C1_0IntNat
instance Constructor C1_1IntNat
instance Constructor C1_2IntNat
instance Constructor C1_3IntNat
instance Constructor C1_4IntNat
instance Constructor C1_5IntNat
instance Constructor C1_6IntNat
instance Constructor C1_7IntNat
instance Constructor C1_8IntNat
instance Constructor C1_9IntNat
instance Constructor C1_10IntNat
instance Constructor C1_11IntNat
instance Constructor C1_12IntNat
instance Datatype D1Accidental
instance Constructor C1_0Accidental
instance Constructor C1_1Accidental
instance Constructor C1_2Accidental
instance Constructor C1_3Accidental
instance Constructor C1_4Accidental
instance Datatype D1Note
instance Constructor C1_0Note
instance Datatype D1Addition
instance Constructor C1_0Addition
instance Constructor C1_1Addition
instance Datatype D1Chord
instance Constructor C1_0Chord
instance Constructor C1_1Chord
instance Constructor C1_2Chord
instance Datatype D1Key
instance Constructor C1_0Key
instance Selector S1_0_0Key
instance Selector S1_0_1Key
instance Datatype D1Triad
instance Constructor C1_0Triad
instance Constructor C1_1Triad
instance Constructor C1_2Triad
instance Constructor C1_3Triad
instance Constructor C1_4Triad
instance Binary Triad
instance Binary Accidental
instance Binary a => Binary (Note a)
instance Binary IntNat
instance Binary Addition
instance Binary DiatonicNatural
instance Binary DiatonicDegree
instance Binary Shorthand
instance Binary ClassType
instance Binary a => Binary (Chord a)
instance Binary Mode
instance Binary Key
instance Show Triad
instance Show Addition
instance Show Accidental
instance Show IntNat
instance Show (Note DiatonicDegree)
instance Show (Note DiatonicNatural)
instance Show (Note IntNat)
instance Show ClassType
instance Show Shorthand
instance Show ChordLabel
instance Show Mode
instance Show Key


-- | Summary: We can represent a chord as a set of intervals relative to
--   the root of the chord.
module HarmTrace.Base.Chord.Intervals

-- | Converts an <a>Int</a>erval class to an <a>Interval</a>
icToInterval :: Int -> Interval

-- | Similar to <tt>toPitchClss</tt>, this function calculates an
--   enharmonic interval class for each 'Note Interval' in the range of [0
--   .. 23] ( == ['Note Nat I1' .. 'Note SS I13']
toIntervalClss :: Interval -> Int

-- | Transforms a Chord into a list of relative intervals stored as an
--   <a>IntSet</a> without the root an bass note represented as the number
--   of semitones above the root.
--   
--   <pre>
--   &gt;&gt;&gt; toIntSet (Chord (Note Nat C) HDim7 [Add (Note Sh I11)] (Note Fl I3))
--   fromList [3,6,10,18]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toIntSet (Chord (Note Nat C) Min13 [NoAdd (Note Nat I11)] (Note Nat I1))
--   fromList [3,7,10,14,21]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toIntSet (parseData pChord "D:7(b9)")
--   fromList [4,7,10,13]
--   </pre>
toIntSet :: Chord a -> IntSet

-- | Converts a list of addition to an <a>IntSet</a> containing the
--   relative structure of the (<a>Addition</a> list of the) <a>Chord</a>
addToIntSet :: [Addition] -> IntSet

-- | Expands a <a>Shorthand</a> to its list of degrees
shToIntSet :: Shorthand -> IntSet


-- | Summary: this module provides some functions that transform notes and
--   chords into pitch classes and pitch class sets. See for more info:
--   <a>http://en.wikipedia.org/wiki/Pitch_class</a>
module HarmTrace.Base.Chord.PitchClass

-- | We hide the constructors, such that a PCSet can only be constructed
--   with <a>toPitchClasses</a>, this to overcome confusion between
--   interval sets and pitch class sets, which are both <a>IntSet</a>s
data PCSet
pc :: PCSet -> IntSet

-- | Returns the semitone value [0 .. 11] of a <a>ScaleDegree</a> where 0 =
--   C, e.g. F# = 6. For the constructors <tt>N</tt> and <tt>X</tt> an
--   error is thrown.
toPitchClass :: Diatonic a => Note a -> Int

-- | The reverse of <a>toPitchClass</a> returning the 'Note
--   DiatonicNatural' given a Integer [0..11] semitone, where 0 represents
--   C. All pitch spelling is ignored and the the following twelve pitch
--   names will be output: C, C#, D, Eb, E, F F#, G, Ab, A, Bb, B. When the
--   integer is out of the range [0..11] an error is thrown.
pcToRoot :: Int -> Root

-- | Similar to <a>toIntSet</a> but returns <a>Int</a> pitch classes and
--   includes the <a>Root</a> and the bass <a>Note</a> of the the
--   <a>Chord</a>. <a>toPitchClasses</a> throws an error when applied to a
--   <a>NoChord</a> or <a>UndefChord</a>.
toPitchClasses :: ChordLabel -> PCSet

-- | A short-cut applying <a>toPitchClass</a> to a <a>Chord</a>.
--   <a>rootPC</a> throws an error when applied to a <a>NoChord</a> or
--   <a>UndefChord</a>.
rootPC :: ChordLabel -> Int

-- | A short-cut applying <a>intValToPitchClss</a> to a <a>Chord</a>.
--   <a>bassPC</a> throws an error when applied to a <a>NoChord</a> or
--   <a>UndefChord</a>.
bassPC :: ChordLabel -> Int

-- | Ignores the pitch spelling of a chord by applying <a>pcToRoot</a> and
--   <a>toPitchClass</a> to the root of a <a>ChordLabel</a>.
ignorePitchSpelling :: ChordLabel -> ChordLabel

-- | As <a>toIntervalClss</a>, but returns the <a>Int</a> pitch class.
intValToPitchClss :: Root -> Interval -> Int

-- | Transforms an interval set to and a root into a <a>PCSet</a>
intSetToPC :: IntSet -> Root -> PCSet

-- | A class to compare datatypes that sound the same (they contain the
--   same pitch class content):
--   <a>http://en.wikipedia.org/wiki/Enharmonic</a>
class EnHarEq a where a &== b = not (a &/= b) a &/= b = not (a &== b)
(&==) :: EnHarEq a => a -> a -> Bool
(&/=) :: EnHarEq a => a -> a -> Bool

-- | A class to mark certain datatypes to have a diatonic structure:
--   <a>http://en.wikipedia.org/wiki/Diatonic_and_chromatic</a>
class (Generic a, Show a, Enum a, Bounded a) => Diatonic a
instance Show PCSet
instance Eq PCSet
instance Generic PCSet
instance Datatype D1PCSet
instance Constructor C1_0PCSet
instance Selector S1_0_0PCSet
instance Diatonic DiatonicDegree
instance Diatonic DiatonicNatural
instance EnHarEq ChordLabel
instance Diatonic a => EnHarEq (Note a)
instance Binary PCSet


-- | Summary: Analyses and transforms musical chords
module HarmTrace.Base.Chord.Analysis

-- | Analyses a degree list and returns <a>MajTriad</a>, <a>MinTriad</a> or
--   <a>NoTriad</a> if the degrees make a chord a major, minor, or no
--   triad, respectively.
analyseTriad :: IntSet -> Triad

-- | Analyses the structure of an <a>IntSet</a> and returns an appropriate
--   <tt>ShortHand</tt>, if possible
analyseTetra :: IntSet -> Shorthand

-- | Takes a <a>Chord</a> and determines the <a>Triad</a>
--   
--   <pre>
--   &gt;&gt;&gt; toTriad (Chord (Note Nat C) Min [NoAdd (Note Fl I3),Add (Note Nat I3)] 0 0)
--   maj 
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toTriad (Chord (Note Nat C) HDim7 [Add (Note Sh I11)] 0 0)
--   dim
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toTriad (Chord (Note Nat C) Min [NoAdd (Note Fl I3)] 0 0)
--   NoTriad
--   </pre>
--   
--   N.B. <a>toTriad</a> throws an error when applied to a <a>NoChord</a>
--   or <a>UndefChord</a>.
toTriad :: Chord a -> Triad

-- | applies <a>toMajMin</a> to a <a>Chord</a>, in case there is no triad,
--   e.g. <tt>:sus4</tt> or <tt>:sus2</tt>, an <a>UndefChord</a> is
--   returned. Also, chord additions are removed. <a>NoChord</a>s and
--   <a>UndefChord</a>s are returned untouched.
toMajMinChord :: ChordLabel -> ChordLabel

-- | A <a>Third</a> can by major, minor or absent
data Third
MajThird :: Third
MinThird :: Third
NoThird :: Third

-- | A <a>Fifth</a> can be perfect, diminished, augmented or absent
data Fifth
DimFifth :: Fifth
PerfFifth :: Fifth
AugFifth :: Fifth
NoFifth :: Fifth

-- | A seventh can be major, minor, diminished, or absent
data Sevth
DimSev :: Sevth
MinSev :: Sevth
MajSev :: Sevth
NoSev :: Sevth

-- | analyses the third in a degree list
analyseThird :: IntSet -> Third

-- | analyses the fifth in a degree list
analyseFifth :: IntSet -> Fifth

-- | analyses the fifth in a degree list
analyseSevth :: IntSet -> Sevth

-- | Converts a <a>Shorthand</a> to a <a>Mode</a>
toMode :: Triad -> Mode

-- | Converts a <a>Shorthand</a> to either a <a>MajClass</a>,
--   <a>MinClass</a> or <a>NoClass</a> <a>ClassType</a>.
toMajMin :: Triad -> ClassType

-- | Returns the <a>ClassType</a> given a <a>Chord</a>. This function uses
--   <a>analyseDegClassType</a> to analyse a chord and derive the
--   <a>ClassType</a>
toClassType :: Chord a -> ClassType

-- | Returns True if the <a>ChordLabel</a> has a major second, no third,
--   and no fourth.
isSus2 :: ChordLabel -> Bool

-- | Returns True if the <a>ChordLabel</a> has a no major second, no third,
--   but has a fourth.
isSus4 :: ChordLabel -> Bool

-- | Transposes a Root with a <a>Int</a> semitones up
transposeRoot :: Root -> Int -> Root

-- | Transposes a scale degree with <a>Int</a> semitones up
transposeSD :: ScaleDegree -> Int -> ScaleDegree

-- | Given a <a>Key</a>, calculates the the <a>ChordDegree</a> (i.e.
--   relative, <a>ScaleDegree</a> based <a>Chord</a>) for an absolute
--   <a>ChordLabel</a> using <a>toScaleDegree</a>.
toChordDegree :: Key -> ChordLabel -> ChordDegree

-- | Transformes a absolute <a>Root</a> <a>Note</a> into a relative
--   <a>ScaleDegree</a>, given a <a>Key</a>.
toScaleDegree :: Key -> Root -> ScaleDegree

-- | Similar to <a>toScaleDegree</a>, an interval is transformed into an
--   absolute <a>Root</a> pitch, given another <a>Root</a> that serves as a
--   basis.
--   
--   <pre>
--   &gt;&gt;&gt; intervalToPitch (Note Sh G) (Note Fl I13)
--   
--   &gt;&gt;&gt; E
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intervalToPitch (Note Nat C) (Note Sh I11)
--   
--   &gt;&gt;&gt; F#
--   </pre>
intervalToPitch :: Root -> Interval -> Root

-- | Converts an <a>Int</a>erval class to an <a>Interval</a>
icToInterval :: Int -> Interval

-- | Given an <a>IntSet</a> (Interval Set), a <a>Root</a> <a>Note</a> and
--   an optional bass <a>Interval</a>, returns a <a>Chord</a>
toChord :: Root -> IntSet -> Maybe Interval -> Chord Root
instance Eq Third
instance Show Third
instance Eq Fifth
instance Show Fifth
instance Eq Sevth
instance Show Sevth


-- | Summary: An interface to all the sub modules of HarmTrace.Base.Chord
module HarmTrace.Base.Chord


-- | Summary: Some general parsing utilities used for parsing textual chord
--   representations.
module HarmTrace.Base.Parse.ChordParser

-- | Parses a <a>ChordLabel</a> in Harte et al. syntax including possible
--   additions, and removal of chord additions. If a chord has no
--   <a>Shorthand</a>, the <tt>Degree</tt> list (if any) is analysed and
--   depending on the <a>Triad</a> (if any) a <a>Maj</a>,
--   <a>Min</a>,<a>Aug</a>, or <a>Dim</a> <a>Shorthand</a> is stored. By
--   default all the duration stored in every <a>Chord</a> is 1 (where the
--   unit is application depended, often these are beats, but they can also
--   be eighth notes)
pChord :: Parser ChordLabel

-- | Parses a shorthand following Harte et al. syntax, but also the
--   <a>Shorthand</a>s added to the Billboard dataset, e.g. <tt>maj</tt>,
--   <tt>min</tt>, or <tt>9</tt>.
pShorthand :: Parser Shorthand

-- | Parses a <a>Root</a> <a>Note</a>, e.g. <tt>A</tt>, <tt>Bb</tt>, or
--   <tt>F#</tt>.
pRoot :: Parser Root

-- | Parses a list of <a>Chord</a> <a>Addition</a>s within parenthesis
pAdditions :: Parser [Addition]

-- | Parses the a <a>Chord</a> <a>Addition</a> (or the removal of a chord
--   addition, prefixed by a <tt>*</tt>)
pAddition :: Parser Addition

-- | parses a musical key description, e.g. <tt>C:maj</tt>, or
--   <tt>D:min</tt>
pKey :: Parser Key


-- | Summary: An interface to all the sub modules of HarmTrace.Base.Parse
module HarmTrace.Base.Parse
