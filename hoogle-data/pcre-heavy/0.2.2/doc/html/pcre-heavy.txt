-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A regexp library on top of pcre-light you can actually use.
--   
@package pcre-heavy
@version 0.2.2


-- | A usable regular expressions library on top of pcre-light.
module Text.Regex.PCRE.Heavy

-- | Checks whether a string matches a regex.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XQuasiQuotes
--   
--   &gt;&gt;&gt; "https://unrelenting.technology" =~ [re|^http.*|]
--   True
--   </pre>
(=~) :: Stringable a => a -> Regex -> Bool

-- | Same as =~.
(≈) :: Stringable a => a -> Regex -> Bool

-- | Searches the string for all matches of a given regex.
--   
--   <pre>
--   &gt;&gt;&gt; scan [re|\s*entry (\d+) (\w+)\s*&amp;?|] " entry 1 hello  &amp;entry 2 hi"
--   [(" entry 1 hello  &amp;",["1","hello"]),("entry 2 hi",["2","hi"])]
--   </pre>
--   
--   It is lazy! If you only need the first match, just apply <a>head</a>
--   (or <tt>headMay</tt> from the "safe" library) -- no extra work will be
--   performed!
--   
--   <pre>
--   &gt;&gt;&gt; head $ scan [re|\s*entry (\d+) (\w+)\s*&amp;?|] " entry 1 hello  &amp;entry 2 hi"
--   (" entry 1 hello  &amp;",["1","hello"])
--   </pre>
scan :: Stringable a => Regex -> a -> [(a, [a])]

-- | Exactly like <a>scan</a>, but passes runtime options to PCRE.
scanO :: Stringable a => Regex -> [PCREExecOption] -> a -> [(a, [a])]

-- | Searches the string for all matches of a given regex, like
--   <a>scan</a>, but returns positions inside of the string.
--   
--   <pre>
--   &gt;&gt;&gt; scanRanges [re|\s*entry (\d+) (\w+)\s*&amp;?|] " entry 1 hello  &amp;entry 2 hi"
--   [((0,17),[(7,8),(9,14)]),((17,27),[(23,24),(25,27)])]
--   </pre>
--   
--   And just like <a>scan</a>, it's lazy.
scanRanges :: Stringable a => Regex -> a -> [((Int, Int), [(Int, Int)])]

-- | Exactly like <a>scanRanges</a>, but passes runtime options to PCRE.
scanRangesO :: Stringable a => Regex -> [PCREExecOption] -> a -> [((Int, Int), [(Int, Int)])]

-- | Replaces the first occurence of a given regex.
--   
--   <pre>
--   &gt;&gt;&gt; sub [re|thing|] "world" "Hello, thing thing" :: String
--   "Hello, world thing"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sub [re|a|] "b" "c" :: String
--   "c"
--   </pre>
--   
--   You can use functions! A function of Stringable gets the full match. A
--   function of [Stringable] gets the groups. A function of Stringable →
--   [Stringable] gets both.
--   
--   <pre>
--   &gt;&gt;&gt; sub [re|%(\d+)(\w+)|] (\(d:w:_) -&gt; "{" ++ d ++ " of " ++ w ++ "}" :: String) "Hello, %20thing" :: String
--   "Hello, {20 of thing}"
--   </pre>
sub :: (Stringable a, RegexReplacement r) => Regex -> r -> a -> a

-- | Exactly like <a>sub</a>, but passes runtime options to PCRE.
subO :: (Stringable a, RegexReplacement r) => Regex -> [PCREExecOption] -> r -> a -> a

-- | Replaces all occurences of a given regex.
--   
--   See <a>sub</a> for more documentation.
--   
--   <pre>
--   &gt;&gt;&gt; gsub [re|thing|] "world" "Hello, thing thing" :: String
--   "Hello, world world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; gsub [re||] "" "Hello, world" :: String
--   "Hello, world"
--   </pre>
gsub :: (Stringable a, RegexReplacement r) => Regex -> r -> a -> a

-- | Exactly like <a>gsub</a>, but passes runtime options to PCRE.
gsubO :: (Stringable a, RegexReplacement r) => Regex -> [PCREExecOption] -> r -> a -> a

-- | Splits the string using the given regex.
--   
--   Is lazy.
--   
--   <pre>
--   &gt;&gt;&gt; split [re|%(begin|next|end)%|] "%begin%hello%next%world%end%"
--   ["","hello","world",""]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; split [re|%(begin|next|end)%|] ""
--   [""]
--   </pre>
split :: Stringable a => Regex -> a -> [a]

-- | Exactly like <a>split</a>, but passes runtime options to PCRE.
splitO :: Stringable a => Regex -> [PCREExecOption] -> a -> [a]

-- | A QuasiQuoter for regular expressions that does a compile time check.
re :: QuasiQuoter

-- | Returns a QuasiQuoter like <a>re</a>, but with given PCRE options.
mkRegexQQ :: [PCREOption] -> QuasiQuoter

-- | An abstract pointer to a compiled PCRE Regex structure The structure
--   allocated by the PCRE library will be deallocated automatically by the
--   Haskell storage manager.
data Regex :: *

-- | A type for PCRE compile-time options. These are newtyped CInts, which
--   can be bitwise-or'd together, using '(Data.Bits..|.)'
data PCREOption :: *

-- | <a>compileM</a> A safe version of <a>compile</a> with failure wrapped
--   in an Either.
--   
--   Examples,
--   
--   <pre>
--   &gt; compileM ".*" [] :: Either String Regex
--   Right (Regex 0x000000004bb5b980 ".*")
--   </pre>
--   
--   <pre>
--   &gt; compileM "*" [] :: Either String Regex
--   Left "nothing to repeat"
--   </pre>
compileM :: ByteString -> [PCREOption] -> Either String Regex

-- | Does raw PCRE matching (you probably shouldn't use this directly).
--   
--   <pre>
--   &gt;&gt;&gt; :set -XOverloadedStrings
--   
--   &gt;&gt;&gt; rawMatch [re|\w{2}|] "a a ab abc ba" 0 []
--   Just [(4,6)]
--   
--   &gt;&gt;&gt; rawMatch [re|\w{2}|] "a a ab abc ba" 6 []
--   Just [(7,9)]
--   
--   &gt;&gt;&gt; rawMatch [re|(\w)(\w)|] "a a ab abc ba" 0 []
--   Just [(4,6),(4,5),(5,6)]
--   </pre>
rawMatch :: Regex -> ByteString -> Int -> [PCREExecOption] -> Maybe [(Int, Int)]
rawSub :: RegexReplacement r => Regex -> r -> ByteString -> Int -> [PCREExecOption] -> Maybe (ByteString, Int)
instance [overlap ok] Lift PCREOption
instance [overlap ok] Stringable a => RegexReplacement ([a] -> a)
instance [overlap ok] Stringable a => RegexReplacement (a -> a)
instance [overlap ok] Stringable a => RegexReplacement (a -> [a] -> a)
instance [overlap ok] Stringable a => RegexReplacement a
