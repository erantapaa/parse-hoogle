-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Packing and unpacking binary data.
--   
@package repa-convert
@version 4.1.0.1

module Data.Repa.Product

-- | Strict product type, written infix.
data (:*:) a b
(:*:) :: !a -> !b -> (:*:) a b
instance (Eq a, Eq b) => Eq (a :*: b)
instance (Show a, Show b) => Show (a :*: b)
instance (Unbox a, Unbox b) => Vector Vector (a :*: b)
instance (Unbox a, Unbox b) => MVector MVector (a :*: b)
instance (Unbox a, Unbox b) => Unbox (a :*: b)


-- | Convert Haskell values to and from a compact binary representation.
--   
--   For testing purposes, use <a>packToList</a> which takes a format, a
--   record, and returns a list of bytes.
--   
--   <pre>
--   &gt; import Data.Repa.Convert.Format
--   
--   &gt; let Just bytes = packToList (FixString ASCII 10 :*: Word16be :*: Float64be) ("foo" :*: 66 :*: 93.42)
--   &gt; bytes
--   [102,111,111,0,0,0,0,0,0,0,0,66,64,87,90,225,71,174,20,123]
--   </pre>
--   
--   We can then unpack the raw bytes back to Haskell values with
--   <a>unpackFromList</a>.
--   
--   <pre>
--   &gt; unpackFromList (FixString ASCII 10 :*: Word16be :*: Float64be) bytes 
--   Just ("foo" :*: (66 :*: 93.42))
--   </pre>
--   
--   In production code use <a>pack</a> and <a>unpack</a> to work directly
--   with a buffer in foreign memory.
module Data.Repa.Convert.Format

-- | Relates a storage format to the Haskell type of the value that is
--   stored in that format.
class Format f where type family Value f
fixedSize :: Format f => f -> Maybe Int
packedSize :: Format f => f -> Value f -> Maybe Int

-- | Class of storage formats that can have values packed and unpacked from
--   foreign bufferes.
--   
--   The methods are written using continuations to make it easier for GHC
--   to optimise its core code when packing/unpacking many fields.
class Format format => Packable format
pack :: Packable format => Ptr Word8 -> format -> Value format -> (Int -> IO (Maybe a)) -> IO (Maybe a)
unpack :: Packable format => Ptr Word8 -> format -> ((Value format, Int) -> IO (Maybe a)) -> IO (Maybe a)

-- | Pack a value into a list of <a>Word8</a>.
packToList :: Packable format => format -> Value format -> Maybe [Word8]

-- | Unpack a value from a list of <a>Word8</a>.
unpackFromList :: Packable format => format -> [Word8] -> Maybe (Value format)

-- | Constrain the type of a value to match the given format.
--   
--   The value itself is not used.
forFormat :: format -> Value format -> Value format

-- | Constrain the type of some values to match the given format.
--   
--   The value itself is not used.
listFormat :: format -> [Value format] -> [Value format]

-- | Strict product type, written infix.
data (:*:) a b
(:*:) :: !a -> !b -> (:*:) a b

-- | Fixed length list.
data FixList f
FixList :: f -> Int -> FixList f

-- | Variable length list.
data VarList f
VarList :: f -> VarList f

-- | Fixed length string.
--   
--   <ul>
--   <li>When packing, if the provided string is shorter than the fixed
--   length then the extra bytes are zero-filled.</li>
--   </ul>
data FixString t
FixString :: t -> Int -> FixString t

-- | Variable length string.
data VarString t
VarString :: t -> VarString t

-- | String is encoded as 8-bit ASCII characters.
data ASCII
ASCII :: ASCII

-- | Big-endian 8-bit unsigned word.
data Word8be
Word8be :: Word8be

-- | Big-endian 8-bit signed integer.
data Int8be
Int8be :: Int8be

-- | Big-endian 32-bit unsigned word.
data Word16be
Word16be :: Word16be
data Int16be
Int16be :: Int16be

-- | Big-endian 32-bit unsigned word.
data Word32be
Word32be :: Word32be

-- | Big-endian 32-bit signed integer.
data Int32be
Int32be :: Int32be

-- | Big-endian 32-bit IEEE 754 float.
data Float32be
Float32be :: Float32be

-- | Big-endian 64-bit unsigned word.
data Word64be
Word64be :: Word64be

-- | Big-endian 64-bit signed integer.
data Int64be
Int64be :: Int64be

-- | Big-endian 64-bit IEEE 754 float.
data Float64be
Float64be :: Float64be
