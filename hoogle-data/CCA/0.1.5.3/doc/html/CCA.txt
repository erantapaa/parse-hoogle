-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | preprocessor and library for Causal Commutative Arrows (CCA)
--   
@package CCA
@version 0.1.5.3

module Language.Haskell.TH.Instances
fromInt :: Int -> Int#
instance Lift Double
instance Lift Rational
instance Lift Callconv
instance Lift Safety
instance Lift Strict
instance Lift Guard
instance Lift Foreign
instance Lift FunDep
instance Lift Con
instance Lift Clause
instance Lift Body
instance Lift NameSpace
instance Lift Dec
instance Lift Lit
instance Lift Pat
instance Lift Match
instance Lift Stmt
instance Lift Range
instance Lift NameFlavour
instance Lift TyVarBndr
instance Lift Kind
instance Lift Pred
instance Lift PkgName
instance Lift ModName
instance Lift OccName
instance Lift Name
instance Lift Exp
instance Lift a => Lift (Q a)

module Control.CCA.Types
class (Arrow a, ArrowLoop a) => ArrowInit a where arr' _ = arr init' _ = init loopD i f = loop (arr f >>> second (init i))
init :: ArrowInit a => b -> a b b
arr' :: ArrowInit a => ExpQ -> (b -> c) -> a b c
init' :: ArrowInit a => ExpQ -> b -> a b b
loopD :: ArrowInit a => e -> ((b, e) -> (c, e)) -> a b c

module Control.CCA.CCNF
norm :: ASyn t t1 -> ExpQ
normOpt :: ASyn t t1 -> ExpQ
pprNorm :: ASyn t t1 -> Q Exp
pprNormOpt :: ASyn t t1 -> Q Exp
printCCA :: ASyn t t1 -> IO ()
data ASyn b c
cross :: (t -> t2) -> (t1 -> t3) -> (t, t1) -> (t2, t3)
dup :: t -> (t, t)
swap :: (t1, t) -> (t, t1)
assoc :: ((t, t1), t2) -> (t, (t1, t2))
unassoc :: (t1, (t2, t)) -> ((t1, t2), t)
juggle :: ((t1, t), t2) -> ((t1, t2), t)
trace :: ((t1, t2) -> (t, t2)) -> t1 -> t
mirror :: Either b a -> Either a b
untag :: Either t t -> t
tagT :: (Either t t1, t2) -> Either (t, t2) (t1, t2)
untagT :: Either (a, t) (b, t) -> (Either a b, t)
instance ArrowChoice ASyn
instance ArrowInit ASyn
instance ArrowLoop ASyn
instance Arrow ASyn
instance Category ASyn

module Control.CCA

-- | Left-to-right composition
(>>>) :: Category k cat => cat a b -> cat b c -> cat a c

-- | Right-to-left composition
(<<<) :: Category k cat => cat b c -> cat a b -> cat a c

-- | Send the first component of the input through the argument arrow, and
--   copy the rest unchanged to the output.
first :: Arrow a => forall b c d. a b c -> a (b, d) (c, d)

-- | A mirror image of <a>first</a>.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
second :: Arrow a => forall b c d. a b c -> a (d, b) (d, c)

-- | Split the input between the two argument arrows and combine their
--   output. Note that this is in general not a functor.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
(***) :: Arrow a => forall b c b' c'. a b c -> a b' c' -> a (b, b') (c, c')

-- | Fanout: send the input to both argument arrows and combine their
--   output.
--   
--   The default definition may be overridden with a more efficient version
--   if desired.
(&&&) :: Arrow a => forall b c c'. a b c -> a b c' -> a b (c, c')
loop :: ArrowLoop a => forall b d c. a (b, d) (c, d) -> a b c

-- | The basic arrow class.
--   
--   Minimal complete definition: <a>arr</a> and <a>first</a>, satisfying
--   the laws
--   
--   <ul>
--   <li><pre><a>arr</a> id = <a>id</a></pre></li>
--   <li><pre><a>arr</a> (f &gt;&gt;&gt; g) = <a>arr</a> f &gt;&gt;&gt;
--   <a>arr</a> g</pre></li>
--   <li><pre><a>first</a> (<a>arr</a> f) = <a>arr</a> (<a>first</a>
--   f)</pre></li>
--   <li><pre><a>first</a> (f &gt;&gt;&gt; g) = <a>first</a> f &gt;&gt;&gt;
--   <a>first</a> g</pre></li>
--   <li><pre><a>first</a> f &gt;&gt;&gt; <a>arr</a> <a>fst</a> =
--   <a>arr</a> <a>fst</a> &gt;&gt;&gt; f</pre></li>
--   <li><pre><a>first</a> f &gt;&gt;&gt; <a>arr</a> (<a>id</a> *** g) =
--   <a>arr</a> (<a>id</a> *** g) &gt;&gt;&gt; <a>first</a> f</pre></li>
--   <li><pre><a>first</a> (<a>first</a> f) &gt;&gt;&gt; <a>arr</a>
--   <tt>assoc</tt> = <a>arr</a> <tt>assoc</tt> &gt;&gt;&gt; <a>first</a>
--   f</pre></li>
--   </ul>
--   
--   where
--   
--   <pre>
--   assoc ((a,b),c) = (a,(b,c))
--   </pre>
--   
--   The other combinators have sensible default definitions, which may be
--   overridden for efficiency.
class Category * a => Arrow (a :: * -> * -> *)
first :: Arrow a => a b c -> a (b, d) (c, d)
second :: Arrow a => a b c -> a (d, b) (d, c)
(***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
(&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')

-- | The <a>loop</a> operator expresses computations in which an output
--   value is fed back as input, although the computation occurs only once.
--   It underlies the <tt>rec</tt> value recursion construct in arrow
--   notation. <a>loop</a> should satisfy the following laws:
--   
--   <ul>
--   <li><i><i>extension</i></i> <tt><a>loop</a> (<a>arr</a> f) =
--   <a>arr</a> (\ b -&gt; <a>fst</a> (<a>fix</a> (\ (c,d) -&gt; f
--   (b,d))))</tt></li>
--   <li><i><i>left tightening</i></i> <tt><a>loop</a> (<a>first</a> h
--   &gt;&gt;&gt; f) = h &gt;&gt;&gt; <a>loop</a> f</tt></li>
--   <li><i><i>right tightening</i></i> <tt><a>loop</a> (f &gt;&gt;&gt;
--   <a>first</a> h) = <a>loop</a> f &gt;&gt;&gt; h</tt></li>
--   <li><i><i>sliding</i></i> <tt><a>loop</a> (f &gt;&gt;&gt; <a>arr</a>
--   (<a>id</a> *** k)) = <a>loop</a> (<a>arr</a> (<a>id</a> *** k)
--   &gt;&gt;&gt; f)</tt></li>
--   <li><i><i>vanishing</i></i> <tt><a>loop</a> (<a>loop</a> f) =
--   <a>loop</a> (<a>arr</a> unassoc &gt;&gt;&gt; f &gt;&gt;&gt; <a>arr</a>
--   assoc)</tt></li>
--   <li><i><i>superposing</i></i> <tt><a>second</a> (<a>loop</a> f) =
--   <a>loop</a> (<a>arr</a> assoc &gt;&gt;&gt; <a>second</a> f
--   &gt;&gt;&gt; <a>arr</a> unassoc)</tt></li>
--   </ul>
--   
--   where
--   
--   <pre>
--   assoc ((a,b),c) = (a,(b,c))
--   unassoc (a,(b,c)) = ((a,b),c)
--   </pre>
class Arrow a => ArrowLoop (a :: * -> * -> *)
loop :: ArrowLoop a => a (b, d) (c, d) -> a b c
class (Arrow a, ArrowLoop a) => ArrowInit a where arr' _ = arr init' _ = init loopD i f = loop (arr f >>> second (init i))
arr' :: ArrowInit a => ExpQ -> (b -> c) -> a b c
init' :: ArrowInit a => ExpQ -> b -> a b b
arr :: ExpQ -> ExpQ
init :: ExpQ -> ExpQ
constant :: (ArrowInit a, Lift b) => b -> a () b
norm :: ASyn t t1 -> ExpQ
normOpt :: ASyn t t1 -> ExpQ
