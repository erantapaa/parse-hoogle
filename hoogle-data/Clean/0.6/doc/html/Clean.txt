-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A light, clean and powerful utility library
--   
--   A collection of the most useful stuff I've found cleaned up and
--   bundled in one convenient location
@package Clean
@version 0.6

module Clean.Core
type (:*:) a b = (a, b)
type (:+:) a b = Either a b

-- | The class of all types that have a binary operation. Note that the
--   operation isn't necesarily commutative (in the case of lists, for
--   example)
class Semigroup m where + = (+)
(+) :: Semigroup m => m -> m -> m
class (Semigroup a, Semigroup b) => SubSemi a b
to :: SubSemi a b => b -> a

-- | A monoid is a semigroup with a null element such that <tt>zero + a ==
--   a + zero == a</tt>
class Semigroup m => Monoid m where zero = 0
zero :: Monoid m => m
class Monoid m => Ring m where one = 1 * = (*)
one :: Ring m => m
(*) :: Ring m => m -> m -> m
class Unit f
pure :: Unit f => a -> f a

-- | A monoid on category endomorphisms under composition
newtype Endo k a
Endo :: k a a -> Endo k a
runEndo :: Endo k a -> k a a

-- | The dual of a monoid is the same as the original, with arguments
--   reversed
newtype Dual m
Dual :: m -> Dual m
getDual :: Dual m -> m

-- | An ordered list
newtype OrdList a
OrdList :: [a] -> OrdList a
getOrdList :: OrdList a -> [a]
newtype Interleave a
Interleave :: [a] -> Interleave a
interleave :: Interleave a -> [a]
class Category k
id :: Category k => k a a
(.) :: Category k => k b c -> k a b -> k a c
class Category k => Choice k
(<|>) :: Choice k => k a c -> k b c -> k (a :+: b) c
class Category k => Split k
(<#>) :: Split k => k a c -> k b d -> k (a, b) (c, d)
const :: Unit f => a -> f a
(&) :: b -> (b -> c) -> c
first :: Split k => k a c -> k (a, d) (c, d)
second :: Split k => k b d -> k (c, b) (c, d)
left :: Choice k => k a c -> k (:+: a c) c
right :: Choice k => k b c -> k (:+: c b) c
ifThenElse :: Bool -> t -> t -> t
guard :: (Unit f, Monoid (f ())) => Bool -> f ()
fail :: [Char] -> a
instance Monoid (Interleave a)
instance Unit OrdList
instance Ord a => Monoid (OrdList a)
instance Monoid m => Monoid (Dual m)
instance Semigroup (Interleave a)
instance Ord a => Semigroup (OrdList a)
instance Ring m => Ring (Dual m)
instance Semigroup m => Semigroup (Dual m)
instance Category k => Monoid (Endo k a)
instance Category k => Semigroup (Endo k a)
instance Ring a => Monoid (Product a)
instance Ring a => Semigroup (Product a)
instance Split (->)
instance Choice (->)
instance Category (->)
instance Unit IO
instance Unit Tree
instance Unit []
instance Unit ((->) b)
instance Monoid w => Unit ((,) w)
instance Unit (Either a)
instance Monoid a => Ring [a]
instance Ring Float
instance Ring Integer
instance Ring Int
instance Ring Bool
instance Monoid a => SubSemi a ()
instance Monoid Bool
instance (SubSemi b a, Monoid a) => Monoid (a :+: b)
instance (Monoid a, Monoid b) => Monoid (a :*: b)
instance Monoid [a]
instance Ord a => Monoid (Set a)
instance Monoid Float
instance Monoid Integer
instance Monoid Int
instance Monoid ()
instance Monoid Void
instance SubSemi b a => Semigroup (a :+: b)
instance (Semigroup a, Semigroup b) => Semigroup (a :*: b)
instance Semigroup [a]
instance Ord a => Semigroup (Set a)
instance Semigroup Integer
instance Semigroup Float
instance Semigroup Int
instance Semigroup Bool
instance Semigroup ()
instance Semigroup Void


-- | A module for functors
module Clean.Functor
class Functor f where map f = (<*>) (pure f)
map :: Functor f => (a -> b) -> f a -> f b
class Cofunctor f
comap :: Cofunctor f => (a -> b) -> f b -> f a
class Bifunctor p where dimap f g = promap f . map g
dimap :: Bifunctor p => (c -> a) -> (b -> d) -> p a b -> p c d

-- | The Identity Functor
newtype Id a
Id :: a -> Id a
getId :: Id a -> a

-- | The Constant Functor
newtype Const a b
Const :: a -> Const a b
getConst :: Const a b -> a

-- | A motherflippin' functor
newtype Flip f a b
Flip :: f b a -> Flip f a b
unFlip :: Flip f a b -> f b a

-- | The Composition functor
newtype Compose f g a
Compose :: f (g a) -> Compose f g a
getCompose :: Compose f g a -> f (g a)
(<$>) :: Functor f => (a -> b) -> f a -> f b
(<$) :: Functor f => a1 -> f a -> f a1
(<&>) :: Functor f => f a -> (a -> b) -> f b
void :: Functor f => f a -> f ()
promap :: Cofunctor (Flip f a) => (b -> b1) -> f b1 a -> f b a
instance Functor Interleave
instance Monoid a => Monoid (Const a b)
instance Semigroup w => Semigroup (Const w a)
instance Ring w => Ring (Id w)
instance Monoid w => Monoid (Id w)
instance Semigroup a => Semigroup (Id a)
instance Monad IO
instance Applicative IO
instance Functor IO
instance Functor ((->) a)
instance Functor ((,) b)
instance Functor (Either b)
instance (Functor f, Functor g) => Functor (Sum f g)
instance (Functor f, Functor g) => Functor (Product f g)
instance (Functor f, Functor g) => Functor (Compose f g)
instance (Unit f, Unit g) => Unit (Compose f g)
instance Monad (Const a)
instance Applicative (Const a)
instance Functor (Const a)
instance Unit (Const a)
instance Monad Id
instance Applicative Id
instance Functor Id
instance Unit Id
instance Functor Tree
instance Functor []
instance Bifunctor (->)
instance (Functor f, Cofunctor g) => Cofunctor (Compose f g)
instance Cofunctor (Flip (->) r)

module Clean.Foldable
class Functor t => Foldable t
fold :: (Foldable t, Monoid m) => t m -> m
foldMap :: (Monoid m, Foldable t) => (a -> m) -> t a -> m
concat :: (Monoid m, Foldable t) => t m -> m
sum :: (Monoid m, Foldable t) => t m -> m
split :: (Monoid t1, Monoid t2, Foldable t) => (a -> Either t1 t2) -> t a -> (t1, t2)
partition :: (Unit f, Monoid (f a), Foldable t) => (a -> Bool) -> t a -> (f a, f a)
filter :: (Unit f, Monoid (f a), Foldable t) => (a -> Bool) -> t a -> f a
count :: (Num a1, Monoid a1, Foldable t) => t a -> a1
length :: (Num n, Monoid n) => [a] -> n
foldl :: Foldable t => (a -> a1 -> a) -> a -> t a1 -> a
foldr :: Foldable t => (a1 -> a -> a) -> a -> t a1 -> a
instance Foldable Interleave
instance Foldable Tree
instance Foldable []
instance Foldable (Either a)
instance Foldable Id


-- | A module describing applicative functors
module Clean.Applicative
class (Unit f, Functor f) => Applicative f where f <*> x = f >>= \ f -> x >>= \ x -> pure (f x)
(<*>) :: Applicative f => f (a -> b) -> f a -> f b

-- | A wrapper type for lists with zipping Applicative instances, such that
--   <tt>ZipList [f1,...,fn] <a>&lt;*&gt;</a> ZipList [x1,...,xn] ==
--   ZipList [f1 x1,...,fn xn]</tt>
newtype ZipList a
ZipList :: [a] -> ZipList a
getZipList :: ZipList a -> [a]

-- | The Tree equivalent to ZipList
newtype ZipTree a
ZipTree :: (Tree a) -> ZipTree a

-- | A wrapper for applicative functors with actions executed in the
--   reverse order
newtype Backwards f a
Backwards :: f a -> Backwards f a
forwards :: Backwards f a -> f a
(*>) :: Applicative f => f a1 -> f a -> f a
(<*) :: Applicative f => f a1 -> f a -> f a1
ap :: Applicative f => f (a -> b) -> f a -> f b
liftA :: Functor f => (a -> b) -> f a -> f b
liftA2 :: Applicative f => (a1 -> a -> b) -> f a1 -> f a -> f b
liftA3 :: Applicative f => (a2 -> a1 -> a -> b) -> f a2 -> f a1 -> f a -> f b
liftA4 :: Applicative f => (a3 -> a2 -> a1 -> a -> b) -> f a3 -> f a2 -> f a1 -> f a -> f b
plusA :: (Semigroup b, Applicative f) => f b -> f b -> f b
zeroA :: (Unit f, Monoid a) => f a
instance Functor f => Functor (Backwards f)
instance Unit f => Unit (Backwards f)
instance Ring (f a) => Ring (Backwards f a)
instance Monoid (f a) => Monoid (Backwards f a)
instance Semigroup (f a) => Semigroup (Backwards f a)
instance Foldable ZipTree
instance Foldable ZipList
instance Unit Interleave
instance Applicative f => Applicative (Backwards f)
instance Applicative ZipTree
instance Unit ZipTree
instance Functor ZipTree
instance Applicative ZipList
instance Unit ZipList
instance Functor ZipList
instance Monoid a => Monoid (ZipList a)
instance Semigroup a => Semigroup (ZipList a)
instance Monad Interleave
instance Applicative Interleave
instance (Applicative f, Applicative g) => Applicative (Compose f g)
instance Monad Tree
instance Applicative Tree
instance Monad []
instance Applicative []
instance Monoid w => Monad ((,) w)
instance Monoid w => Applicative ((,) w)
instance Monad ((->) a)
instance Ring b => Ring (a -> b)
instance Monoid b => Monoid (a -> b)
instance Semigroup b => Semigroup (a -> b)
instance Applicative ((->) a)
instance Monad (Either a)
instance Applicative (Either a)

module Clean.Traversable
class Traversable t
sequence :: (Traversable t, Applicative f) => t (f a) -> f (t a)
class Contravariant t
collect :: (Contravariant t, Functor f) => f (t a) -> t (f a)
traverse :: (Applicative f, Functor t, Traversable t) => (a1 -> f a) -> t a1 -> f (t a)
foreach :: (Applicative f, Functor t, Traversable t) => t a1 -> (a1 -> f a) -> f (t a)
transpose :: (Applicative f, Traversable t) => t (f a) -> f (t a)
flip :: (Functor f, Contravariant t) => f (t a) -> t (f a)
instance Traversable ZipTree
instance Traversable ZipList
instance Contravariant ((->) a)
instance Contravariant Id
instance Traversable Tree
instance Traversable []
instance Traversable (Either a)


-- | A module providing simple Lens functionality
module Clean.Lens
type Iso s t a b = forall p f. (Functor f, Bifunctor p) => p s (f t) -> p a (f b)
type Iso' a b = Iso b b a a
data MkIso a b s t
MkIso :: (s -> a) -> (b -> t) -> MkIso a b s t
type LensLike f s t a b = (s -> f t) -> (a -> f b)
type LensLike' f a b = LensLike f b b a a
type Lens s t a b = forall f. Functor f => LensLike f s t a b
type Lens' a b = Lens b b a a
type Traversal s t a b = forall f. Applicative f => LensLike f s t a b
type Traversal' a b = Traversal b b a a
iso :: (a -> s) -> (t -> b) -> Iso s t a b
from :: MkIso t s b a -> Iso a b s t
lens :: (a -> s) -> (a -> t -> b) -> Lens s t a b
lam :: Functor f => (a -> s) -> LensLike f s t a a
prism :: (a -> (b :+: s)) -> (a -> t -> b) -> Traversal s t a b
(^.) :: a -> Lens' a b -> b
(%~) :: Traversal' a b -> (b -> b) -> (a -> a)
(.~) :: Traversal' a b -> b -> (a -> a)
_1 :: Lens' (a :*: b) a
_2 :: Lens' (a :*: b) b
_l :: Traversal' (a :+: b) a
_r :: Traversal' (a :+: b) b
_both :: Traversal a b (a, a) (b, b)
_list :: Iso' [a] (() :+: (a :*: [a]))
_head :: Traversal' [a] a
_tail :: Traversal' [a] [a]
_dropping :: Int -> Traversal' [a] [a]
class Wrapped s t a b | a -> s, b -> t, a t -> s, b s -> t
wrapped :: Wrapped s t a b => Iso s t a b
wrapping :: Wrapped b b a a => (a -> b) -> Iso' a b
instance Bifunctor (MkIso a b)
instance Cofunctor (Flip (MkIso a b) t)
instance Functor (MkIso a b s)

module Clean.Monad
class Applicative m => Monad m where join m = m >>= id ma >>= k = join (map k ma)
join :: Monad m => m (m a) -> m a
(>>=) :: Monad m => m a -> (a -> m b) -> m b
class Monad m => MonadFix m
mfix :: MonadFix m => (a -> m a) -> m a
class MonadTrans t
lift :: (MonadTrans t, Monad m) => m a -> t m a
internal :: (MonadTrans t, Monad m) => (forall c. m (c, a) -> m (c, b)) -> t m a -> t m b
(=<<) :: Monad m => (a -> m b) -> m a -> m b
(>>) :: Applicative f => f a1 -> f a -> f a
return :: Unit f => a -> f a
class Monad m => MonadState s m where put = modify . const modify f = get >>= put . f
get :: MonadState s m => m s
put :: MonadState s m => s -> m ()
modify :: MonadState s m => (s -> s) -> m ()

-- | A simple State Monad
newtype StateT s m a
StateT :: (s -> m (s, a)) -> StateT s m a
runStateT :: StateT s m a -> s -> m (s, a)
type State s a = StateT s Id a
evalStateT :: Functor f => StateT a f b -> a -> f b
execStateT :: Functor f => StateT b f b1 -> b -> f b
runState :: State s a -> s -> (s, a)
execState :: State s a -> s -> s
evalState :: State s a -> s -> a
class Monad m => MonadReader r m
ask :: MonadReader r m => m r
local :: MonadReader r m => (r -> r) -> m a -> m a

-- | A simple Reader monad
newtype ReaderT r m a
ReaderT :: (r -> m a) -> ReaderT r m a
runReaderT :: ReaderT r m a -> r -> m a
type Reader r a = ReaderT r Id a
class (Monad m, Monoid w) => MonadWriter w m
tell :: MonadWriter w m => w -> m ()
listen :: MonadWriter w m => m a -> m (w, a)
censor :: MonadWriter w m => m (a, w -> w) -> m a

-- | A simple Writer monad
newtype WriterT w m a
WriterT :: m (w, a) -> WriterT w m a
runWriterT :: WriterT w m a -> m (w, a)
type Writer w a = WriterT w Id a
runWriter :: WriterT w Id a -> (w, a)

-- | A simple continuation monad implementation
class Monad m => MonadCont m
callCC :: MonadCont m => ((a -> m b) -> m a) -> m a
newtype ContT r m a
ContT :: ((a -> m r) -> m r) -> ContT r m a
runContT :: ContT r m a -> (a -> m r) -> m r
type Cont r a = ContT r Id a
evalContT :: Unit m => ContT r m r -> m r
evalCont :: ContT a Id a -> a
instance Ring (m (w, a)) => Ring (WriterT w m a)
instance Monoid (m (w, a)) => Monoid (WriterT w m a)
instance Semigroup (m (w, a)) => Semigroup (WriterT w m a)
instance Ring (m (s, a)) => Ring (StateT s m a)
instance Monoid (m (s, a)) => Monoid (StateT s m a)
instance Semigroup (m (s, a)) => Semigroup (StateT s m a)
instance Semigroup (m a) => Semigroup (ReaderT r m a)
instance Monoid (m a) => Monoid (ReaderT r m a)
instance Ring (m a) => Ring (ReaderT r m a)
instance Semigroup (m r) => Semigroup (ContT r m a)
instance Monoid (m r) => Monoid (ContT r m a)
instance Ring (m r) => Ring (ContT r m a)
instance MonadFix m => Monad (Backwards m)
instance MonadTrans Backwards
instance Monad m => MonadCont (ContT r m)
instance MonadTrans (ContT r)
instance Monad m => Monad (ContT r m)
instance Monad m => Applicative (ContT r m)
instance Monad m => Functor (ContT r m)
instance Unit m => Unit (ContT r m)
instance (Monoid w, MonadFix m) => MonadFix (WriterT w m)
instance (Monoid w, MonadState r m) => MonadState r (WriterT w m)
instance (Monoid w, MonadReader r m) => MonadReader r (WriterT w m)
instance (Monad m, Monoid w) => MonadWriter w (WriterT w m)
instance (Monoid w, Monad m) => Monad (WriterT w m)
instance (Monoid w, Monad m) => Applicative (WriterT w m)
instance (Monoid w, Monad m) => Functor (WriterT w m)
instance (Monoid w, Monad m) => Unit (WriterT w m)
instance Monoid w => MonadTrans (WriterT w)
instance MonadFix m => MonadFix (ReaderT r m)
instance MonadCont m => MonadCont (ReaderT r m)
instance MonadWriter w m => MonadWriter w (ReaderT r m)
instance MonadState s m => MonadState s (ReaderT r m)
instance Monad m => MonadReader r (ReaderT r m)
instance Monad m => Monad (ReaderT r m)
instance Monad m => Applicative (ReaderT r m)
instance Monad m => Functor (ReaderT r m)
instance Monad m => Unit (ReaderT r m)
instance MonadTrans (ReaderT r)
instance MonadFix m => MonadFix (StateT s m)
instance MonadCont m => MonadCont (StateT s m)
instance MonadWriter w m => MonadWriter w (StateT s m)
instance MonadReader r m => MonadReader r (StateT s m)
instance Monad m => MonadState s (StateT s m)
instance MonadTrans (StateT s)
instance Monad m => Monad (StateT s m)
instance Monad m => Applicative (StateT s m)
instance Monad m => Functor (StateT s m)
instance Unit m => Unit (StateT s m)
instance MonadFix []
instance MonadFix ((->) b)
instance MonadFix Id

module Clean.Arrow
class (Split k, Choice k) => Arrow k
arr :: Arrow k => (a -> b) -> k a b
(>>>) :: Category k => k a b -> k b c -> k a c
(<<<) :: Category k => k b c -> k a b -> k a c
(>>^) :: Functor f => f a -> (a -> b) -> f b
(^>>) :: Cofunctor (Flip f a) => (b -> b1) -> f b1 a -> f b a
(|||) :: (Choice k, Functor (k a), Functor (k b)) => k a a1 -> k b b1 -> k (:+: a b) (Either a1 b1)
class Arrow k => Apply k
apply :: Apply k => k (k a b, a) b
app :: Apply k => k a c -> k a c
newtype Kleisli m a b
Kleisli :: (a -> m b) -> Kleisli m a b
runKleisli :: Kleisli m a b -> a -> m b
instance Monad m => Arrow (Kleisli m)
instance Monad m => Apply (Kleisli m)
instance Monad m => Split (Kleisli m)
instance Monad m => Choice (Kleisli m)
instance Monad m => Category (Kleisli m)
instance Monad m => Monad (Kleisli m a)
instance Monad m => Applicative (Kleisli m a)
instance Functor f => Functor (Kleisli f a)
instance Unit m => Unit (Kleisli m a)
instance (Monad f, Contravariant f, Monad g) => Monad (Compose f g)
instance Arrow k => Cofunctor (Flip k a)
instance Apply (->)
instance Arrow (->)

module Clean
