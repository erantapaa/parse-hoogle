-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Sieve is an implementation of the Sieve abstract data type.
--   
--   A Sieve is a data type with properties analogous to a physical Sieve
--   and it is useful for building up lists of data wherein a specific
--   constraint must be met that cannot be achieved using normal type
--   semantics. A Sieve encapsulates a list that can only hold a certain
--   type, specified by a identity function and is preferable to creating
--   or building up lists by using conditional blocks or by the progressive
--   use of filter. This is especially advantageous if a list is to be
--   passed around and used as an accumulator. In such a configuration, the
--   original declaring type is passed around with the Sieve so that it can
--   be used transparently in subsequent areas of the program.
@package sieve
@version 0.1.0.1


-- | An implementation of the Sieve abstract data type in Haskell.
--   
--   A Sieve is a data type with properties analogous to a physical Sieve
--   and it is useful for building up lists of data wherein a specific
--   constraint must be met that cannot be achieved using normal type
--   semantics. A Sieve encapsulates a list that can only hold a certain
--   type, specified by a identity function and is preferable to creating
--   or building up lists by using conditional blocks or by the progressive
--   use of <a>filter</a>. This is especially advantageous if a list is to
--   be passed around and used as an accumulator. In such a configuration,
--   the original declaring type is passed around with the Sieve so that it
--   can be used transparently in subsequent areas of the program.
--   
--   A Sieve is especially useful for applications that:
--   
--   <ul>
--   <li>Will hold onto a list for longer than a single function</li>
--   <li>Need to perform asynchronous stream processing</li>
--   </ul>
--   
--   Consider the following example wherein we wish to create and maintain
--   a list with <a>Integer</a> values greater than 2.
--   
--   <pre>
--   f2 :: Sieve Int -&gt; Sieve Int
--   f2 s = [7,8,1] ++? s
--   </pre>
--   
--   <pre>
--   f1 :: Sieve Int 
--   f1 = let numbersGreaterThanTwo = newSieve (\x -&gt; x &gt; 2) [1,2,3] in f2 $ [4,5,6] ++? numbersGreaterThanTwo
--   </pre>
--   
--   This example produces the list: <tt>[7,8,4,5,6,3]</tt>.
module Data.Sieve

-- | The type that backs created Sieves.
data Sieve a

-- | The function <a>newSieve</a> is the preferred method of creating a new
--   <a>Sieve</a>. The sieve that is constructed will immediately filter
--   the list passed as the second parameter to <a>newSieve</a>.
newSieve :: (a -> Bool) -> [a] -> Sieve a

-- | The <a>toList</a> function returns the resulting backing list.
toList :: Sieve a -> [a]

-- | Returns the backing relation used to determine if a given element is a
--   member of the list.
relation :: Sieve a -> (a -> Bool)

-- | The operator for building up lists with a Sieve. The operator should
--   be read as "Conditionally Add." All interaction with Sieve should
--   ideally be through this function/operator. The most basic usage of it
--   can be seen in the following example:
--   
--   <pre>
--   f3 =  [0,11,10] ++? ([7,8,9]  ++?  ([4,5,6] ++? newSieve (\x -&gt; x &gt; 2) [1,2,3]))
--   </pre>
--   
--   This produces the list <tt>[11,10,7,8,9,4,5,6,3]</tt>.
(++?) :: [a] -> Sieve a -> Sieve a
