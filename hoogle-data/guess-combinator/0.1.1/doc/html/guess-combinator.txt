-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Generate simple combinators given their type
--   
--   Based on De-typechecker: converting from a type to a term by <a>oleg
--   at pobox.com</a>
--   http:<i></i>www.haskell.org<i>pipermail</i>haskell<i>2005-March</i>015423.html
@package guess-combinator
@version 0.1.1


-- | Guess a value for a combinator
--   
--   Based on De-typechecker: converting from a type to a term by <a>oleg
--   at pobox.com</a>
--   http:<i></i>www.haskell.org<i>pipermail</i>haskell<i>2005-March</i>015423.html
module Guess.Combinator

-- | Guess a combinator given its type
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; let f = combinator :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
--   
--   &gt;&gt;&gt; f (:[]) ((,) True) 10
--   [(True, 10)]
--   </pre>
combinator :: GuessCombinator t HNil => t
instance Show t => Show (TypeToTermT tl t)
instance RHLookup t r w => RHLookup' HFalse t (TypeToTermT tl' t' :*: r) w
instance RHLookup' HTrue t (TypeToTermT (t :*: at) tt :*: r) (TypeToTermT (t :*: at) tt)
instance (TypeEq t t' flag, RHLookup' flag t (TypeToTermT (t' :*: at) tt' :*: r) w) => RHLookup t (TypeToTermT (t' :*: at) tt' :*: r) w
instance (ExtendEnv env rest ret env' fun, ListToFun pt t) => ExtendEnv env (pt :*: rest) ret (TypeToTermT pt t :*: env') (t -> fun)
instance ExtendEnv env HNil ret env ret
instance (HReverse (gc :*: gcr) revr, ExtendEnv env revr ra env' f, RResolve env' ((g :*: HNil) :*: HNil) HNil ra, RResolve env gr (f :*: pt) t) => RResolve env ((g :*: (gc :*: gcr)) :*: gr) pt t
instance (RHLookup g env (TypeToTermT (g :*: assum) g'), HReverse assum assum', RResolve env assum' (g' :*: HNil) ra, RResolve env gr (ra :*: pt) t) => RResolve env ((g :*: HNil) :*: gr) pt t
instance RResolve env HNil (t1 :*: tr) (t -> r) => RResolve env HNil (t :*: (t1 :*: tr)) r
instance RResolve env HNil (t :*: HNil) t
instance RResolve env ((t :*: HNil) :*: HNil) HNil t => GuessWith' HFalse t env
instance (IsFunction x flagx, FunToList' flagx x tlx, IsFunction y flagy, GuessWith' flagy y (TypeToTermT tlx x :*: env)) => GuessWith' HTrue (x -> y) env
instance (IsFunction t flag, GuessWith' flag t env) => GuessCombinator t env
