-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Data structures and support functions for working with random processes
--   
--   RandProc.hs - a Haskell library for working with random processes in a
--   mathematically rigorous way (Concepts taken from <i>Random Processes -
--   a Mathematical Approach for Engineers</i> by: - Robert M. Gray - Lee
--   D. Davisson Prentice-Hall Information and System Sciences Series,
--   Thomas Kailath, Series Editor)
@package randproc
@version 0.4


-- | RandProc.hs - a Haskell library for working with random processes in a
--   mathematically rigorous way
--   
--   (Concepts taken from <i>Random Processes - a Mathematical Approach for
--   Engineers</i> by:
--   
--   <ul>
--   <li>Robert M. Gray</li>
--   <li>Lee D. Davisson</li>
--   </ul>
--   
--   Prentice-Hall Information and System Sciences Series, Thomas Kailath,
--   Series Editor)
--   
--   $Id: RandProc.hs 31 2011-06-22 13:49:48Z dbanas $
--   
--   David Banas
--   
--   12 March 2011
--   
--   Copyright (c) 2011 by David Banas; All rights reserved World wide.
--   
--   <i>Revision History:</i>
--   
--   <ul>
--   <li><i><tt>Date SVN #</tt></i> Description</li>
--   <li><i><tt>2011-03-13 3</tt></i> Data structures stabilized.
--   <tt>isSigma</tt> working under minimal, discrete sample testing.</li>
--   <li><i><tt>2011-03-18 4</tt></i> Added <tt>isProbMeas</tt>, as well as
--   monadic debugging versions of both it and <tt>isSigma</tt>. Added an
--   example probability space representing a fair die.</li>
--   <li><i><tt>2011-03-29 7</tt></i> Custom intersection functions added
--   and briefly tested.</li>
--   <li><i><tt>2011-04-02 8</tt></i> Custom union functions added and
--   briefly tested. Solution is crude: it is O(N^2), and requires 2 passes
--   over the sample list every time a join is successful. Perhaps, a
--   pre-sort?</li>
--   <li><i><tt>2011-06-06 9</tt></i> Attempted fix of <a>getCompEvent</a>
--   Added <a>smplComp</a> function, as helper to revised
--   <a>getCompEvent</a>. Changed <a>Point</a> to accept Double. Moved all
--   sample spaces to new file, <tt>Main.hs</tt>. Added input sorting to
--   <a>range</a>. Changed Ranges to be open intervals, in order to allow
--   for complementing out a Point from them.</li>
--   <li><i><tt>2011-06-11 10</tt></i> Major re-write. <a>getCompEvent</a>
--   fixed. All 5 test spaces checking out ok.</li>
--   <li><i><tt>2011-06-18 21</tt></i> Removed sample set order dependency
--   from <a>checkSigma</a>. All 7 test spaces checking out ok.</li>
--   <li><i><tt>2011-06-19 22</tt></i> Added 'union of events is an event'
--   test to <a>checkSigma</a>.</li>
--   <li><i><tt>2011-06-20 23</tt></i> Changed <a>Event</a> from data
--   constructor to type alias, in order to eliminate many instances of
--   'Event . f . getSamps' code.</li>
--   <li><i><tt>2011-06-20 25</tt></i> Modified <tt>smpsSetInt</tt> to use
--   a fold.</li>
--   <li><i><tt>2011-06-20 26</tt></i> Defined public interface.</li>
--   <li><i><tt>2011-06-21 27</tt></i> Modified comments for Haddock, and
--   generated HTML docs.</li>
--   <li><i><tt>2011-06-22 31</tt></i> Moved into <tt>Data</tt>
--   directory.</li>
--   <li><i>End of Subversion revision history</i> This source has been
--   moved to darcs.</li>
--   <li><i><tt>2011-06-27</tt></i> Made <a>smplSetUnion</a> more
--   efficient, and tuned remaining performance bottlenecks.</li>
--   </ul>
--   
--   <i>To Do:</i>
module Data.RandProc

-- | We take a probability space to consist of the following:
--   
--   <ul>
--   <li>an 'abstract space' composed of either discrete or continuous (or
--   a mix) samples</li>
--   <li>an 'event space', which must be a Sigma field defined over the
--   abstract space</li>
--   <li>a 'probability measure' defined over the event space</li>
--   </ul>
--   
--   <ul>
--   <li><i>Note:</i> For the sake of efficient coding, the <i>event
--   space</i> and the <i>probability measure</i> are combined in the
--   Haskell data structure, below. This is permissable, because there has
--   to be a 1:1 correspondance between them anyway. And it is preferable,
--   because it:</li>
--   </ul>
--   
--   <ul>
--   <li>keeps the probabilities more closely associated w/ the events,
--   and</li>
--   <li>avoids duplication of code (i.e. - the list of events).</li>
--   </ul>
data ProbSpace
ProbSpace :: [Sample] -> [Measure] -> ProbSpace

-- | <i>Measure</i> has 2 fields:
--   
--   <ul>
--   <li><i>event</i> - a list of samples from the space, and</li>
--   <li><i>prob</i> - a number between 0 and 1 giving the events
--   probability of occurence.</li>
--   </ul>
data Measure
Measure :: Event -> Double -> Measure

-- | This is our abstract data type, which represents a sample in the
--   abstract space.
--   
--   It has a constructor representing every possible element in the
--   abstract space we're modeling. (Currently, just points and ranges of
--   <i>Double</i>s.)
--   
--   Normally, none of the constructors of this type will be called
--   directly. Instead, helper functions are provided, such as <a>point</a>
--   and <a>range</a>, which hide the implementation details from the user,
--   and present a stable interface.
--   
--   Currently, the sole exception to the above is the <i>Empty</i>
--   constructor, which is really just a hack intended to put off the job
--   of making the functions in this library more intelligent, with regard
--   to their handling of empty lists.
data Sample
Empty :: Sample

-- | Custom data type used for test results and error reporting.
data TestResult
Fail :: ErrType -> TestResult
err :: TestResult -> ErrType
Pass :: TestResult

-- | Custom data type for reporting different errors
data ErrType
UnknownErr :: ErrType
EmptySampleSpace :: ErrType
EmptyEventSpace :: ErrType
MissingNullEvent :: ErrType
MissingCertainEvent :: ErrType
BadEventSamples :: ErrType
MissingCompEvent :: ErrType
MissingUnionEvent :: ErrType
EventMeasLenMismatch :: ErrType
DupEventsInMeas :: ErrType
MissingEventsInMeas :: ErrType
NullEventNonZeroProb :: ErrType
CertainEventNonUnityProb :: ErrType
EventAndCompNoSumOne :: ErrType

-- | Custom data structure, used for constructing individual test cases.
--   
--   <i>Fields:</i>
--   
--   <ul>
--   <li>ps - a pointer to the ProbSpace being tested</li>
--   <li>res - the expected result</li>
--   <li>name - a label for identifying this test</li>
--   </ul>
data ProbSpaceTest
ProbSpaceTest :: ProbSpace -> TestResult -> String -> ProbSpaceTest

-- | This is the helper function intended to be used for constructing a
--   point sample.
point :: Double -> Sample

-- | This is the helper function intended to be used for constructing a
--   range sample. The range is considered <i>open</i>. That is, its end
--   points are not included.
range :: (Double, Double) -> Sample

-- | This helper function generates a complete and valid probability space,
--   given a discrete sample space and set of probabilities.
makeProbSpace :: [(Sample, Double)] -> ProbSpace

-- | Takes a test case and returns a string indicating the result of the
--   test.
checkSpace :: ProbSpaceTest -> IO Bool

-- | Turns a value of type <i>TestResult</i> into a human readable string.
getRsltStr :: TestResult -> String

-- | Checks a value of type <a>ProbSpace</a> for correctness, and returns a
--   value of type <a>TestResult</a>.
checkProbMeas :: ProbSpace -> TestResult

-- | Checks whether event space is actually a Sigma field over the sample
--   space.
checkSigma :: ProbSpace -> TestResult

-- | Gets the beginning point of a range, which is <i>not</i> included in
--   the range, since ranges are considered to be open.
rangeBegin :: Sample -> Double

-- | Gets the ending point of a range, which is <i>not</i> included in the
--   range,
rangeEnd :: Sample -> Double

-- | Extracts the probability from a Measure.
getProb :: Measure -> Double

-- | Extracts the Event from a Measure.
getEvent :: Measure -> Event

-- | Get the complement of an event from the sample space.
getCompEvent :: [Sample] -> Event -> Event

-- | Calculates the intersection of 2 events (i.e. - list of samples).
eventInt :: Event -> Event -> Event

-- | Returns that portion of the first sample that is disjoint from the
--   second.
smplComp :: Sample -> Sample -> [Sample]

-- | Determine if a sample is an element of a space.
--   
--   (Need this, as opposed to just using <a>elem</a>, in order to
--   accomodate ranges.)
isElem :: [Sample] -> Sample -> Bool

-- | Checks a list of measures against duplicate events.
noDupEvents :: [Measure] -> Bool

-- | Returns the intersection between 2 samples.
smplInt :: Sample -> Sample -> Sample

-- | Reduces a list of samples to a single sample representing their
--   intersection.
smplSetInt :: [Sample] -> Sample

-- | Returns the union of 2 samples.
--   
--   Unlike <a>smplInt</a>, <i>smplUnion</i> must return a list since, if
--   the 2 input samples aren't adjacent or overlapping, the union of them
--   is a list containing both.
smplUnion :: Sample -> Sample -> [Sample]

-- | Collapses a list of samples down to the maximally reduced set, which
--   still composes a proper union of the input.
smplSetUnion :: [Sample] -> [Sample]

-- | Power set generator
subs :: [a] -> [[a]]
instance [overlap ok] Eq Sample
instance [overlap ok] Show Sample
instance [overlap ok] Eq SampleType
instance [overlap ok] Show SampleType
instance [overlap ok] Eq Measure
instance [overlap ok] Ord Measure
instance [overlap ok] Show Measure
instance [overlap ok] Show ProbSpace
instance [overlap ok] Eq ErrType
instance [overlap ok] Show ErrType
instance [overlap ok] Show TestResult
instance [overlap ok] Eq TestResult
instance [overlap ok] Ord Sample
