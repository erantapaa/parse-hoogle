-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Derivation of Aeson instances using GHC generics.
--   
@package generic-aeson
@version 0.2.0.7


-- | Test if a data type is an enumeration (only zero-argument
--   constructors) generically using <a>GHC.Generics</a>.
module Generics.Generic.IsEnum

-- | Generically test if a data type is an enumeration.
isEnum :: (Generic a, GIsEnum (Rep a)) => Proxy a -> Bool

-- | Class for testing if the functors from <a>GHC.Generics</a> are
--   enumerations. You generally don't need to give any custom instances.
--   Just call <a>isEnum</a>.
class GIsEnum f
gIsEnum :: GIsEnum f => Proxy (f a) -> Bool
instance GIsEnum f => GIsEnum (M1 D c f)
instance GIsEnum (M1 S c a)
instance GIsEnum f => GIsEnum (M1 C c f)
instance (GIsEnum f, GIsEnum g) => GIsEnum (f :*: g)
instance (GIsEnum f, GIsEnum g) => GIsEnum (f :+: g)
instance GIsEnum (Rec1 f)
instance GIsEnum Par1
instance GIsEnum U1
instance GIsEnum (K1 i a)
instance GIsEnum V1


-- | Helper functions that can be reused by libraries interoperating with
--   generic-aeson.
module Generics.Generic.Aeson.Util

-- | Lowercases the first letter and strips leading and trailing
--   underscores.
formatLabel :: Settings -> Text -> Text
multipleConstructors :: [a] -> Bool
conNameT :: Constructor c => Settings -> t c f a -> Text
selNameT :: Selector s => Settings -> t s f a -> Maybe Text
data Settings
Settings :: Maybe String -> Settings
stripPrefix :: Settings -> Maybe String
defaultSettings :: Settings
instance Show Settings


-- | This module offers generic conversions to an from JSON <a>Value</a>s
--   for data types with a <a>Generic</a> instance.
--   
--   The structure of the generated JSON is meant to be close to idiomatic
--   JSON. This means:
--   
--   <ul>
--   <li>Enumerations are converted to JSON strings.</li>
--   <li>Record fields become JSON keys.</li>
--   <li>Data types with one unlabeled field convert to just that
--   field.</li>
--   <li>Data types with multiple unlabeled fields become arrays.</li>
--   <li>Multiple constructors are represented by keys.</li>
--   <li><a>Maybe</a> values are either an absent key, or the value.</li>
--   </ul>
--   
--   See 'tests/Main.hs' for more examples.
module Generics.Generic.Aeson

-- | Convert any datatype with a <a>Generic</a> instance to a JSON
--   <a>Value</a>.
gtoJson :: (Generic a, GtoJson (Rep a), ConNames (Rep a), GIsEnum (Rep a)) => a -> Value

-- | Parse any datatype with a <a>Generic</a> instance from a JSON
--   <a>Value</a>.
gparseJson :: (Generic a, GfromJson (Rep a), ConNames (Rep a), GIsEnum (Rep a)) => Value -> Parser a

-- | Class for converting the functors from <a>GHC.Generics</a> to JSON.
--   You generally don't need to give any custom instances. Just add
--   'deriving Generic' and call <tt>gToJson</tt>.
class GtoJson f
gtoJSONf :: GtoJson f => Settings -> Bool -> Bool -> f a -> Either [Value] [(Text, Value)]

-- | Class for parsing the functors from <a>GHC.Generics</a> from JSON. You
--   generally don't need to give any custom instances. Just add 'deriving
--   Generic' and call <tt>gFromJson</tt>.
class GfromJson f
gparseJSONf :: GfromJson f => Settings -> Bool -> Bool -> Bool -> StateT [Value] Parser (f a)

-- | Lowercases the first letter and strips leading and trailing
--   underscores.
formatLabel :: Settings -> Text -> Text
data Settings
Settings :: Maybe String -> Settings
stripPrefix :: Settings -> Maybe String
defaultSettings :: Settings
gtoJsonWithSettings :: (Generic a, GtoJson (Rep a), ConNames (Rep a), GIsEnum (Rep a)) => Settings -> a -> Value
gparseJsonWithSettings :: (Generic a, GfromJson (Rep a), ConNames (Rep a), GIsEnum (Rep a)) => Settings -> Value -> Parser a
instance [overlap ok] (Selector c, FromJSON a) => GfromJson (M1 S c (K1 i (Maybe a)))
instance [overlap ok] (Selector c, ToJSON a) => GtoJson (M1 S c (K1 i (Maybe a)))
instance [overlap ok] (Selector c, GfromJson f) => GfromJson (M1 S c f)
instance [overlap ok] (Selector c, GtoJson f) => GtoJson (M1 S c f)
instance [overlap ok] (Constructor c, GfromJson f) => GfromJson (M1 C c f)
instance [overlap ok] (Constructor c, GtoJson f) => GtoJson (M1 C c f)
instance [overlap ok] GfromJson f => GfromJson (M1 D c f)
instance [overlap ok] GtoJson f => GtoJson (M1 D c f)
instance [overlap ok] (GfromJson f, GfromJson g) => GfromJson (f :*: g)
instance [overlap ok] (GtoJson f, GtoJson g) => GtoJson (f :*: g)
instance [overlap ok] (GfromJson f, GfromJson g) => GfromJson (f :+: g)
instance [overlap ok] (GtoJson f, GtoJson g) => GtoJson (f :+: g)
instance [overlap ok] FromJSON c => GfromJson (K1 a c)
instance [overlap ok] ToJSON c => GtoJson (K1 a c)
instance [overlap ok] GfromJson U1
instance [overlap ok] GtoJson U1
