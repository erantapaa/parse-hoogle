-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Heterogeneous map by open unions.
--   
@package union-map
@version 0.1


-- | An implementation of heterogeneous tree-map by open unions. This
--   module uses the <tt>Data.IntMap</tt> inside, see also
--   <a>https://hackage.haskell.org/package/containers</a>.
module Data.UnionIntMap
data UnionIntMap r
type Key = Int
(\\) :: UnionIntMap r -> UnionIntMap r -> UnionIntMap r
(!) :: Member as a => UnionIntMap as -> Key -> a
empty :: UnionIntMap r
singleton :: Member as a => Key -> a -> UnionIntMap as
null :: UnionIntMap r -> Bool
size :: UnionIntMap r -> Int
member :: Key -> UnionIntMap r -> Bool
notMember :: Key -> UnionIntMap r -> Bool
lookup :: Member as a => Key -> UnionIntMap as -> Maybe a
lookupU :: Key -> UnionIntMap r -> Maybe (K0 :| r)
find :: Member as a => Key -> UnionIntMap as -> a
findU :: Key -> UnionIntMap r -> K0 :| r
findWithDefault :: Member as a => a -> Key -> UnionIntMap as -> a
insert :: Member as a => Key -> a -> UnionIntMap as -> UnionIntMap as
insertWith :: Member as a => (a -> a -> a) -> Key -> a -> UnionIntMap as -> UnionIntMap as
insertWithKey :: Member as a => (Key -> a -> a -> a) -> Key -> a -> UnionIntMap as -> UnionIntMap as
delete :: Key -> UnionIntMap as -> UnionIntMap as
adjust :: Member as a => (a -> a) -> Key -> UnionIntMap as -> UnionIntMap as
adjustWithKey :: Member as a => (Key -> a -> a) -> Key -> UnionIntMap as -> UnionIntMap as
update :: Member as a => (a -> Maybe a) -> Key -> UnionIntMap as -> UnionIntMap as
updateWithKey :: Member as a => (Key -> a -> Maybe a) -> Key -> UnionIntMap as -> UnionIntMap as
union :: UnionIntMap r -> UnionIntMap r -> UnionIntMap r
unions :: [UnionIntMap r] -> UnionIntMap r
difference :: UnionIntMap r -> UnionIntMap r -> UnionIntMap r
intersection :: UnionIntMap r -> UnionIntMap r -> UnionIntMap r
keys :: UnionIntMap r -> [Key]
rebuild :: Include s r => UnionIntMap r -> UnionIntMap s
mapU :: (K0 :| r -> K0 :| s) -> UnionIntMap r -> UnionIntMap s
mapWithKeyU :: (Key -> K0 :| r -> K0 :| s) -> UnionIntMap r -> UnionIntMap s
mapU' :: (K0 :| r -> a) -> UnionIntMap r -> IntMap a
mapWithKeyU' :: (Key -> K0 :| r -> a) -> UnionIntMap r -> IntMap a
filterU :: (K0 :| r -> Bool) -> UnionIntMap r -> UnionIntMap r
filterWithKeyU :: (Key -> K0 :| r -> Bool) -> UnionIntMap r -> UnionIntMap r
foldrU :: (K0 :| r -> b -> b) -> b -> UnionIntMap r -> b
foldrWithKeyU :: (Key -> K0 :| r -> b -> b) -> b -> UnionIntMap r -> b
foldlU' :: (a -> K0 :| r -> a) -> a -> UnionIntMap r -> a
foldlWithKeyU' :: (a -> Key -> K0 :| r -> a) -> a -> UnionIntMap r -> a
showTree :: Show (K0 :| r) => UnionIntMap r -> String


-- | An implementation of heterogeneous tree-map by open unions. This
--   module uses the <tt>Data.Map</tt> module inside, see also
--   <a>https://hackage.haskell.org/package/containers</a>.
module Data.UnionMap
data UnionMap k r
(\\) :: Ord k => UnionMap k r -> UnionMap k r -> UnionMap k r
(!) :: (Ord k, Member as a) => UnionMap k as -> k -> a
empty :: UnionMap k r
singleton :: (Ord k, Member as a) => k -> a -> UnionMap k as
null :: UnionMap k r -> Bool
size :: UnionMap k r -> Int
member :: Ord k => k -> UnionMap k r -> Bool
notMember :: Ord k => k -> UnionMap k r -> Bool
lookup :: (Ord k, Member as a) => k -> UnionMap k as -> Maybe a
lookupU :: Ord k => k -> UnionMap k r -> Maybe (K0 :| r)
find :: (Ord k, Member as a) => k -> UnionMap k as -> a
findU :: Ord k => k -> UnionMap k r -> K0 :| r
findWithDefault :: (Ord k, Member as a) => a -> k -> UnionMap k as -> a
insert :: (Ord k, Member as a) => k -> a -> UnionMap k as -> UnionMap k as
insertWith :: (Ord k, Member as a) => (a -> a -> a) -> k -> a -> UnionMap k as -> UnionMap k as
insertWithKey :: (Ord k, Member as a) => (k -> a -> a -> a) -> k -> a -> UnionMap k as -> UnionMap k as
delete :: Ord k => k -> UnionMap k as -> UnionMap k as
adjust :: (Ord k, Member as a) => (a -> a) -> k -> UnionMap k as -> UnionMap k as
adjustWithKey :: (Ord k, Member as a) => (k -> a -> a) -> k -> UnionMap k as -> UnionMap k as
update :: (Ord k, Member as a) => (a -> Maybe a) -> k -> UnionMap k as -> UnionMap k as
updateWithKey :: (Ord k, Member as a) => (k -> a -> Maybe a) -> k -> UnionMap k as -> UnionMap k as
union :: Ord k => UnionMap k r -> UnionMap k r -> UnionMap k r
unions :: Ord k => [UnionMap k r] -> UnionMap k r
difference :: Ord k => UnionMap k r -> UnionMap k r -> UnionMap k r
intersection :: Ord k => UnionMap k r -> UnionMap k r -> UnionMap k r
keys :: UnionMap k r -> [k]
rebuild :: Include s r => UnionMap k r -> UnionMap k s
mapU :: (K0 :| r -> K0 :| s) -> UnionMap k r -> UnionMap k s
mapWithKeyU :: (k -> K0 :| r -> K0 :| s) -> UnionMap k r -> UnionMap k s
mapU' :: (K0 :| r -> a) -> UnionMap k r -> Map k a
mapWithKeyU' :: (k -> K0 :| r -> a) -> UnionMap k r -> Map k a
filterU :: (K0 :| r -> Bool) -> UnionMap k r -> UnionMap k r
filterWithKeyU :: (k -> K0 :| r -> Bool) -> UnionMap k r -> UnionMap k r
foldrU :: (K0 :| r -> b -> b) -> b -> UnionMap k r -> b
foldrWithKeyU :: (k -> K0 :| r -> b -> b) -> b -> UnionMap k r -> b
foldlU' :: (a -> K0 :| r -> a) -> a -> UnionMap k r -> a
foldlWithKeyU' :: (a -> k -> K0 :| r -> a) -> a -> UnionMap k r -> a
showTree :: (Show k, Show (K0 :| r)) => UnionMap k r -> String
