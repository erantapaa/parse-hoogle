-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Conversion between storablevector and stream-fusion lists with fusion
--   
--   This package brings together the best of two worlds: The flexibility
--   of plain lists and speed of low-level arrays. Lists are lazy per
--   element, thus allowing for elegant tying-the-knot algorithms and
--   correct fusion of subsequent operations, and they support any element
--   type, including functions. Storablevectors do not have these features.
--   Instead they are fast, including very fast access via indices, they
--   are memory efficient and allow simple exchange with C.
--   
--   This package provides the canonical functions for conversion from
--   StorableVector to Stream and back. By a simple fusion rule they let
--   the interim Stream based lists disappear in many situations, resulting
--   in fast low-level loops. Such fusion could not be correct on
--   StorableVectors. E.g. consider
--   
--   <pre>
--   import qualified Data.StorableVector.Lazy as SV
--   SV.zipWith f (SV.unfoldr size g a) (SV.cons b (SV.unfoldr size h c))
--   </pre>
--   
--   which yields a storable vector with the chunk structure
--   
--   <pre>
--   [1, size, size, ...]
--   </pre>
--   
--   and the following strictness behaviour: For computation of the first
--   value of the result, the first chunk with size <tt>size</tt> of
--   <tt>SV.unfoldr size g a</tt> has to be fully evaluated. This has two
--   advantages: Firstly, you do not really want that behaviour, but you
--   accept it for the sake of overall performance. Secondly, the odd
--   behaviour cannot easily be preserved by fusion, and we must resist to
--   tell the optimizer incorrect rules.
--   
--   So here is the solution: Write
--   
--   <pre>
--   import qualified Data.StorableVector.Lazy.Stream as SVG
--   import qualified Data.List.Stream as Stream
--   SVG.from chunkSize $
--      Stream.zipWith f
--         (Stream.unfoldr g a)
--         (Stream.cons b (Stream.unfoldr h c))
--   </pre>
--   
--   and get two advantages. First: You do not have to pass the
--   <tt>size</tt> parameter at the leaves, but only once at the top.
--   Second: Fusion jumps in and turns everything in a single efficient
--   <tt>SV.unfoldr</tt>.
@package storablevector-streamfusion
@version 0.0

module Data.StorableVector.Stream
from :: (Storable a) => Int -> Stream a -> Vector a
fromList :: (Storable a) => Int -> [a] -> Vector a
to :: (Storable a) => Vector a -> Stream a
toList :: (Storable a) => Vector a -> [a]

module Data.StorableVector.Lazy.Stream
from :: (Storable a) => ChunkSize -> Stream a -> Vector a
fromList :: (Storable a) => ChunkSize -> [a] -> Vector a
to :: (Storable a) => Vector a -> Stream a
toList :: (Storable a) => Vector a -> [a]
