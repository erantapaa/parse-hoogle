-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Rational numbers in scientific notation.
--   
--   Parsing and pretty-printing of exact rational numbers with arbitrarily
--   large exponents.
@package sci-ratio
@version 0.2.1.0


module Data.SciRatio

-- | Represents a fractional number stored in scientific notation: a
--   product of a fractional significand and an integral power of 10.
--   
--   <ul>
--   <li>The significand has type <tt>a</tt> and should be both
--   <tt><a>Fractional</a></tt> and <tt><a>Real</a></tt>. Although this
--   could be a floating-point type, it is not recommended as
--   floating-points use inexact arithmetic and strange bugs will occur as
--   a result.</li>
--   <li>The exponent has type <tt>b</tt> and should be
--   <tt><a>Integral</a></tt>.</li>
--   </ul>
--   
--   <tt><a>SciRatio</a></tt> behaves in the same way as an ordinary
--   <tt><a>Ratio</a></tt> and supports the same operations. The main
--   property is that it is more efficient than <tt><a>Ratio</a></tt> when
--   the exponent is large:
--   
--   <pre>
--   &gt;&gt;&gt; 5 .^ 99999999 :: SciRational   -- works fine
--   
--   &gt;&gt;&gt; 5e99999999    :: Rational      -- takes forever
--   </pre>
--   
--   Specialized functions are provided in cases where they can be
--   implemented more efficiently than the default implementation.
--   
--   The number is always stored in a unique, canonical form: the
--   significand shall never contain factors of 2 and 5 simultaneously, and
--   their multiplicities shall always be nonnegative. (The significand is
--   treated as a rational number factorized into a product of prime
--   numbers with integral exponents that are not necessarily positive.)
--   
--   <b>Note</b>: If inputs differ greatly in magnitude,
--   <tt>(<a>+</a>)</tt> and <tt>(<a>-</a>)</tt> can be quite slow:
--   complexity is linear with the absolute difference of the exponents.
--   Furthermore, the complexity of <tt><a>toRational</a></tt> is linear
--   with the magnitude of the exponent. These also apply to any functions
--   that indirectly use these operations (including all operations in
--   <tt><a>RealFrac</a></tt> and <tt><a>Enum</a></tt>).
data SciRatio a b

-- | A specialization of <a>SciRatio</a>.
type SciRational = SciRatio Rational Integer

-- | Construct a number such that <tt>significand .^ exponent ==
--   significand * 10 ^^ exponent</tt>.
(.^) :: (Fractional a, Real a, Integral b) => a -> b -> SciRatio a b

-- | Extract the fractional significand.
fracSignificand :: SciRatio a b -> a

-- | Extract the base-10 exponent.
base10Exponent :: SciRatio a b -> b

-- | Specialized, more efficient version of <tt>(<a>^</a>)</tt>.
(^!) :: (Real a, Integral b, Integral c) => SciRatio a b -> c -> SciRatio a b

-- | Specialized, more efficient version of <tt>(<a>^^</a>)</tt>.
(^^!) :: (Fractional a, Real a, Integral b, Integral c) => SciRatio a b -> c -> SciRatio a b

-- | Convert into a <a>Fractional</a> number.
--   
--   This is similar to <a>realToFrac</a> but much more efficient for large
--   exponents.
fromSciRatio :: (Real a, Integral b, Fractional c) => SciRatio a b -> c

-- | Factorize a nonzero integer into a significand and a power of the base
--   such that the exponent is maximized:
--   
--   <pre>
--   inputInteger = significand * base ^ exponent
--   </pre>
--   
--   That is, the significand shall not divisible by the base. The base
--   must be greater than one.
factorizeBase :: (Integral a, Integral b) => a -> a -> (a, b)

-- | Calculate the floored logarithm of a positive integer. The base must
--   be greater than one.
ilogBase :: (Integral a, Integral b) => a -> a -> b

-- | Alias of <tt><a>factorizeBase</a></tt>.
--   
--   Note: Despite what the name suggests, the function does <i>not</i>
--   compute the floored logarithm.

-- | <i>Deprecated: use <tt><a>factorizeBase</a></tt> instead.</i>
intLog :: (Integral a, Integral b) => a -> a -> (a, b)
instance (Eq a, Eq b) => Eq (SciRatio a b)
instance (Fractional a, Real a, Integral b) => Enum (SciRatio a b)
instance (Fractional a, Real a, Integral b) => RealFrac (SciRatio a b)
instance (Fractional a, Real a, Integral b) => Real (SciRatio a b)
instance (Fractional a, Real a, Integral b) => Fractional (SciRatio a b)
instance (Fractional a, Real a, Integral b) => Num (SciRatio a b)
instance (Hashable a, Hashable b) => Hashable (SciRatio a b)
instance (Real a, Integral b, Ord a) => Ord (SciRatio a b)
instance (Show a, Show b) => Show (SciRatio a b)
instance (Fractional a, Real a, Integral b, Read a, Read b) => Read (SciRatio a b)


-- | The functions here parse numbers in a variety of formats. Examples:
--   
--   <pre>
--   &gt;&gt;&gt; readSciRational "-0.0e+3"         -- result: Just ((0 % 1) .^ 0)
--   
--   &gt;&gt;&gt; readSciRational "0.25e+2"         -- result: Just ((25 % 1) .^ 0)
--   
--   &gt;&gt;&gt; readSciRational "-1.0e-1"         -- result: Just (((-1) % 1) .^ (-1))
--   
--   &gt;&gt;&gt; readSciRational "5.0e+20/6.e0"    -- result: Just ((25 % 3) .^ 19)
--   
--   &gt;&gt;&gt; readSciRational "0xfeedface"      -- result: Just ((4277009102 % 1) .^ 0)
--   
--   &gt;&gt;&gt; readSciRational "1e99999999"      -- result: Just ((1 % 1) .^ 99999999)
--   </pre>
--   
--   All the <tt><a>ReadP</a></tt> parsers here can be safely used with
--   <tt><a>gather</a></tt> as they do not contain any occurences of
--   <tt><a>readS_to_P</a></tt>.
--   
--   For writing lexers, a simple regular expression to detect numbers
--   would be:
--   
--   <pre>
--   [-+]? [.]? [0-9] [-+/.0-9a-zA-Z]*
--   </pre>
--   
--   Note that this is more lenient than what the grammar of
--   <tt><a>readNumber</a></tt> accepts. If Unicode is supported, one can
--   also include:
--   
--   <ul>
--   <li><tt>U+23E8</tt> (DECIMAL EXPONENT SYMBOL)</li>
--   <li><tt>U+2044</tt> (FRACTION SLASH) and <tt>U+2215</tt> (DIVISION
--   SLASH)</li>
--   <li><tt>U+2212</tt> (MINUS SIGN)</li>
--   </ul>
module Data.SciRatio.Read

-- | Read a number (see <tt><a>readNumberP</a></tt>).
readNumber :: Fractional a => String -> Maybe a

-- | Read a number (see <tt><a>readNumberP</a></tt>).
readSciRational :: String -> Maybe SciRational

-- | Interpret a sign:
--   
--   <pre>
--   sign = [-+]
--   </pre>
--   
--   Note: <tt>U+2212</tt> (MINUS SIGN) is also accepted.
readSign :: Num a => Char -> Maybe a

-- | Read a rational number in scientific notation:
--   
--   <pre>
--   number = [0] [bB] [0-1]+
--          | [0] [oO] [0-7]+
--          | [0] [xX] [0-9a-fA-F]+
--          | scientific ( fraction_slash scientific )?
--   </pre>
readNumberP :: Fractional a => ReadP a

-- | Read a number (see <tt><a>readNumberP</a></tt>).
readSciRationalP :: ReadP SciRational

-- | Read a decimal fraction in scientific notation:
--   
--   <pre>
--   scientific = decimal (decimal_exponent_symbol sign? dec)?
--   </pre>
readScientificP :: Fractional a => ReadP a

-- | Read a decimal fraction:
--   
--   <pre>
--   decimal = sign? ( [0-9]+ [.]? [0-9]*
--                   | [.] [0-9]+ )
--   </pre>
readDecimalP :: Fractional a => ReadP a

-- | Read a signed integer in base 10.
--   
--   <pre>
--   integer = sign? [0-9]+
--   </pre>
readIntegerP :: Num a => ReadP a

-- | Read an unsigned number in either binary (<tt>0b</tt>), octal
--   (<tt>0o</tt>), decimal, or hexadecimal (<tt>0x</tt>) format:
--   
--   <pre>
--   unsigned = [0] [bB] [0-1]+
--            | [0] [oO] [0-7]+
--            | [0] [xX] [0-9a-fA-F]+
--            | dec
--   </pre>
readUnsignedP :: Num a => ReadP a

-- | Read an unsigned integer in hexadecimal notation:
--   
--   <pre>
--   hex = [0-9A-Fa-f]+
--   </pre>
readHexP :: Num a => ReadP a

-- | Read an unsigned integer in base 10.
--   
--   <pre>
--   dec = [0-9]+
--   </pre>
--   
--   Note: Although similar functions exist in <tt><a>Lex</a></tt>, the
--   versions here do not require <tt><a>Eq</a></tt>.
readDecP :: Num a => ReadP a

-- | Read an unsigned integer in octal notation:
--   
--   <pre>
--   oct = [0-7]+
--   </pre>
readOctP :: Num a => ReadP a

-- | Read an unsigned integer in binary notation:
--   
--   <pre>
--   bin = [01]+
--   </pre>
readBinP :: Num a => ReadP a

-- | Whether the character is a binary digit:
--   
--   <pre>
--   bin_digit = [01]
--   </pre>
isBinDigit :: Char -> Bool

-- | Whether the character can be used as an exponent symbol in scientific
--   notation:
--   
--   <pre>
--   decimal_exponent_symbol = [eE]
--   </pre>
--   
--   Note: <tt>U+23E8</tt> (DECIMAL EXPONENT SYMBOL) is also accepted.
isDecimalExponentSymbol :: Char -> Bool

-- | Whether the character is a fraction slash:
--   
--   <pre>
--   fraction_slash = [/]
--   </pre>
--   
--   Note: <tt>U+2044</tt> (FRACTION SLASH) and <tt>U+2215</tt> (DIVISION
--   SLASH) are also accepted.
isFractionSlash :: Char -> Bool


-- | The functions here pretty-print numbers in a compact format. Examples:
--   
--   <pre>
--   &gt;&gt;&gt; showSciRational (-0.0e+3)         -- result: "0"
--   
--   &gt;&gt;&gt; showSciRational (0.25e+2)         -- result: "25"
--   
--   &gt;&gt;&gt; showSciRational (-1.0e-1)         -- result: "-.1"
--   
--   &gt;&gt;&gt; showSciRational (5.0e+20 / 6)     -- result: "2.5e20/3"
--   
--   &gt;&gt;&gt; showSciRational (0xfeedface)      -- result: "4277009102"
--   
--   &gt;&gt;&gt; showSciRational (1 .^ 99999999)   -- result: "1e99999999"
--   </pre>
--   
--   <b>Note</b>: Without taking optimizations into account, the
--   specialized functions (<tt><a>showSciRational</a></tt> and
--   <tt><a>showsSciRational</a></tt>) are much more efficient than the
--   generic functions (<tt><a>showNumber</a></tt> and
--   <tt><a>showsNumber</a></tt> respectively).
module Data.SciRatio.Show

-- | Show a number (see <tt><a>showsNumber</a></tt>).
--   
--   Note: for <tt><a>SciRational</a></tt>, consider using the more
--   efficient, specialized function <tt><a>showSciRational</a></tt>
--   instead.
showNumber :: Real a => a -> String

-- | Show a number (see <tt><a>showsNumber</a></tt>).
showSciRational :: SciRational -> String

-- | Show a rational number in scientific notation:
--   
--   <pre>
--   [-+]?
--   ( [0-9]+ [.]? [0-9]* | [.] [0-9]+ )
--   ( [e] [-+]? [0-9]+ )?
--   ( [/] [0-9]+ )?
--   </pre>
--   
--   Note: for <tt><a>SciRational</a></tt>, consider using the more
--   efficient, specialized function <tt><a>showsSciRational</a></tt>
--   instead.
showsNumber :: Real a => a -> ShowS

-- | Show a number (see <tt><a>showNumber</a></tt>).
showsSciRational :: SciRational -> ShowS
