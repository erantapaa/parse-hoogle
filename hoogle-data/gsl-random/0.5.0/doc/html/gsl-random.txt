-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Bindings the the GSL random number generation facilities.
--   
--   Bindings to the GNU Scientific Library random and quasi-random number
--   generators and random distributions.
@package gsl-random
@version 0.5.0


-- | Quasi-random number generators.
module GSL.Random.Quasi
newtype QRNG
MkQRNG :: (ForeignPtr QRNG) -> QRNG
data QRNGType

-- | Allocate a new quasi-random number generator of the given type,
--   generating points with the given number of dimensions.
newQRNG :: QRNGType -> Int -> IO QRNG

-- | Reset the generator to the beginning of its sequence.
resetQRNG :: QRNG -> IO ()

-- | Stores the next point from the generator in the given buffer. The
--   space available in the buffer must match the dimension of the
--   generator. The components of the sample will each lie in the range
--   (0,1).
getSample :: QRNG -> Ptr Double -> IO ()

-- | Gets the next sample point as a list.
getListSample :: QRNG -> IO [Double]

-- | Get the name of the generator.
getName :: QRNG -> IO String

-- | The dimension of the sequence.
getDimension :: QRNG -> IO Int

-- | Get the size of the generator state, in bytes.
getSize :: QRNG -> IO Word64

-- | Get the generator state.
getState :: QRNG -> IO [Word8]

-- | Set the generator state. The input array should have size equal to
--   <tt>getSize</tt> of the generator; otherwise, strange things will
--   happen.
setState :: QRNG -> [Word8] -> IO ()

-- | <tt>copyQRNG dst src</tt> copies the state from one generator to
--   another. The two generators must have the same type.
copyQRNG :: QRNG -> QRNG -> IO ()

-- | Allocate a new quasi-random number generator that is exact copy of
--   another generator.
cloneQRNG :: QRNG -> IO QRNG
niederreiter :: QRNGType
sobol :: QRNGType
halton :: QRNGType
reverseHalton :: QRNGType

-- | The maximum dimension of samples that the given generator supports.
maxDimension :: QRNGType -> Int


-- | Random number distributions. Functions for generating random variates
--   and computing their probability distributions.
module GSL.Random.Dist

-- | <tt>gaussianPdf x sigma</tt> computes the probabililty density p(x)
--   for a Gaussian distribution with mean <tt>0</tt> and standard
--   deviation <tt>sigma</tt>.
gaussianPdf :: Double -> Double -> Double

-- | <tt>gaussianP x sigma</tt> computes the cumulative distribution
--   function P(x) for a Gaussian distribution with mean <tt>0</tt> and
--   standard deviation <tt>sigma</tt>.
gaussianP :: Double -> Double -> Double

-- | <tt>gaussianQ x sigma</tt> computes the cumulative distribution
--   function Q(x) for a Gaussian distribution with mean <tt>0</tt> and
--   standard deviation <tt>sigma</tt>.
gaussianQ :: Double -> Double -> Double

-- | <tt>gaussianPInv p sigma</tt> computes the inverse of the cumulative
--   distribution function of a Gaussian distribution with mean <tt>0</tt>
--   and standard deviation <tt>sigma</tt>. It returns <tt>x</tt> such that
--   <tt>P(x) = p</tt>.
gaussianPInv :: Double -> Double -> Double

-- | <tt>gaussianPInv q sigma</tt> computes the inverse of the cumulative
--   distribution function of a Gaussian distribution with mean <tt>0</tt>
--   and standard deviation <tt>sigma</tt>. It returns <tt>x</tt> such that
--   <tt>Q(x) = q</tt>.
gaussianQInv :: Double -> Double -> Double

-- | <tt>getGaussian r sigma</tt> gets a normal random variable with mean
--   <tt>0</tt> and standard deviation <tt>sigma</tt>. This uses the
--   Box-Mueller algorithm.
getGaussian :: RNG -> Double -> IO Double

-- | <tt>getGaussianZiggurat r sigma</tt> gets a normal random variable
--   with mean <tt>0</tt> and standard deviation <tt>sigma</tt>. This uses
--   the Marsaglia-Tsang ziggurat algorithm.
getGaussianZiggurat :: RNG -> Double -> IO Double

-- | <tt>getGaussianRatioMethod r sigma</tt> gets a normal random variable
--   with mean <tt>0</tt> and standard deviation <tt>sigma</tt>. This uses
--   the Kinderman-Monahan-Leva ratio method.
getGaussianRatioMethod :: RNG -> Double -> IO Double

-- | <tt>ugaussianPdf x</tt> computes the probabililty density p(x) for a
--   Gaussian distribution with mean <tt>0</tt> and standard deviation
--   <tt>1</tt>.
ugaussianPdf :: Double -> Double

-- | <tt>ugaussianP x</tt> computes the cumulative distribution function
--   P(x) for a Gaussian distribution with mean <tt>0</tt> and standard
--   deviation <tt>1</tt>.
ugaussianP :: Double -> Double

-- | <tt>ugaussianQ x</tt> computes the cumulative distribution function
--   Q(x) for a Gaussian distribution with mean <tt>0</tt> and standard
--   deviation <tt>1</tt>.
ugaussianQ :: Double -> Double

-- | <tt>ugaussianPInv p</tt> computes the inverse of the cumulative
--   distribution function of a Gaussian distribution with mean <tt>0</tt>
--   and standard deviation <tt>1</tt>. It returns <tt>x</tt> such that
--   <tt>P(x) = p</tt>.
ugaussianPInv :: Double -> Double

-- | <tt>ugaussianPInv q</tt> computes the inverse of the cumulative
--   distribution function of a Gaussian distribution with mean <tt>0</tt>
--   and standard deviation <tt>1</tt>. It returns <tt>x</tt> such that
--   <tt>Q(x) = q</tt>.
ugaussianQInv :: Double -> Double

-- | <tt>getUGaussian r</tt> gets a normal random variable with mean
--   <tt>0</tt> and standard deviation <tt>1</tt>. This uses the
--   Box-Mueller algorithm.
getUGaussian :: RNG -> IO Double

-- | <tt>getUGaussianRatioMethod r</tt> gets a normal random variable with
--   mean <tt>0</tt> and standard deviation <tt>1</tt>. This uses the
--   Kinderman-Monahan-Leva ratio method.
getUGaussianRatioMethod :: RNG -> IO Double

-- | <tt>flatPdf x a b</tt> computes the probability density <tt>p(x)</tt>
--   at <tt>x</tt> for a uniform distribution from <tt>a</tt> to
--   <tt>b</tt>.
flatPdf :: Double -> Double -> Double -> Double

-- | <tt>flatP x a b</tt> computes the cumulative distribution function
--   <tt>P(x)</tt>.
flatP :: Double -> Double -> Double -> Double

-- | <tt>flatQ x a b</tt> computes the cumulative distribution function
--   <tt>Q(x)</tt>.
flatQ :: Double -> Double -> Double -> Double

-- | <tt>flatPInv p a b</tt> computes the inverse of the cumulative
--   distribution and returns <tt>x</tt> so that function <tt>P(x) =
--   p</tt>.
flatPInv :: Double -> Double -> Double -> Double

-- | <tt>flatQInv q a b</tt> computes the inverse of the cumulative
--   distribution and returns <tt>x</tt> so that function <tt>Q(x) =
--   q</tt>.
flatQInv :: Double -> Double -> Double -> Double

-- | <tt>getFlat r a b</tt> gets a value uniformly chosen in
--   <tt>[a,b)</tt>.
getFlat :: RNG -> Double -> Double -> IO (Double)

-- | <tt>exponentialPdf x mu</tt> computes the density at <tt>x</tt> of an
--   exponential with mean <tt>mu</tt>.
exponentialPdf :: Double -> Double -> Double
exponentialP :: Double -> Double -> Double
exponentialQ :: Double -> Double -> Double
exponentialPInv :: Double -> Double -> Double
exponentialQInv :: Double -> Double -> Double

-- | <tt>getExponential r mu</tt> gets a random exponential with mean
--   <tt>mu</tt>.
getExponential :: RNG -> Double -> IO Double

-- | <tt>getLevy r c alpha</tt> gets a variate from the Levy symmetric
--   stable distribution with scale <tt>c</tt> and exponent <tt>alpha</tt>.
--   The algorithm only works for <tt>0 &lt;= alpha &lt;= 2</tt>.
getLevy :: RNG -> Double -> Double -> IO (Double)

-- | <tt>getLevySkew r c alpha beta</tt> gets a variate from the Levy skew
--   stable distribution with scale <tt>c</tt>, exponent <tt>alpha</tt>,
--   and skewness parameter <tt>beta</tt>. The skewness parameter must lie
--   in the range <tt>[-1,1]</tt>. The algorithm only works for <tt>0 &lt;=
--   alpha &lt;= 2</tt>.
getLevySkew :: RNG -> Double -> Double -> Double -> IO (Double)

-- | <tt>poissonPdf k mu</tt> evaluates the probability density
--   <tt>p(k)</tt> at <tt>k</tt> for a Poisson distribution with mean
--   <tt>mu</tt>.
poissonPdf :: Int -> Double -> Double

-- | <tt>poissonP k mu</tt> evaluates the cumulative distribution function
--   <tt>P(k)</tt> at <tt>k</tt> for a Poisson distribution with mean
--   <tt>mu</tt>.
poissonP :: Int -> Double -> Double

-- | <tt>poissonQ k mu</tt> evaluates the cumulative distribution function
--   <tt>Q(k)</tt> at <tt>k</tt> for a Poisson distribution with mean
--   <tt>mu</tt>.
poissonQ :: Int -> Double -> Double

-- | <tt>getPoisson r mu</tt> gets a poisson random variable with mean
--   <tt>mu</tt>.
getPoisson :: RNG -> Double -> IO Int

-- | <tt>getCauchy r a</tt> gets a random cauchy with scale <tt>a</tt>.
getCauchy :: RNG -> Double -> IO Double

-- | <tt>cauchyPdf x a</tt> evaluates the probability density <tt>p(x)</tt>
--   at <tt>x</tt> for a Cauchy distribution with scale parameter
--   <tt>a</tt>. The density is given by <tt>p(x) dx = { 1 over api (1 +
--   (x/a^2)) } dx</tt>.
cauchyPdf :: Double -> Double -> Double
cauchyP :: Double -> Double -> Double
cauchyQ :: Double -> Double -> Double
cauchyPInv :: Double -> Double -> Double
cauchyQInv :: Double -> Double -> Double

-- | <tt>getBeta r a b</tt> gets a random beta with parameters <tt>a</tt>
--   and <tt>b</tt>.
getBeta :: RNG -> Double -> Double -> IO Double

-- | <tt>betaPdf x a b</tt> evaluates the probability density <tt>p(x)</tt>
--   at <tt>x</tt> for a Beta distribution with parameters <tt>a</tt> and
--   <tt>b</tt>. The density is given by <tt>p(x) dx = {Gamma(a+b) over
--   Gamma(a) Gamma(b)} x^{a-1} (1-x)^{b-1} dx</tt> for <tt>0 &lt;= x &lt;=
--   1</tt>.
betaPdf :: Double -> Double -> Double -> Double
betaP :: Double -> Double -> Double -> Double
betaQ :: Double -> Double -> Double -> Double
betaPInv :: Double -> Double -> Double -> Double
betaQInv :: Double -> Double -> Double -> Double

-- | <tt>getLogistic r a</tt> gets a random logistic with scale <tt>a</tt>.
getLogistic :: RNG -> Double -> IO Double

-- | <tt>logisticPdf x a</tt> evaluates the probability density
--   <tt>p(x)</tt> at <tt>x</tt> for a logistic distribution with scale
--   parameter <tt>a</tt>. The density is given by <tt>p(x) dx = {
--   exp(-x<i>a) \over a (1 + \exp(-x</i>a))^2 } dx</tt>.
logisticPdf :: Double -> Double -> Double
logisticP :: Double -> Double -> Double
logisticQ :: Double -> Double -> Double
logisticPInv :: Double -> Double -> Double
logisticQInv :: Double -> Double -> Double

-- | <tt>getLognormal zeta sigma</tt> gets a random lognormal with
--   parameters <tt>zeta</tt> and <tt>sigma</tt>.
getLognormal :: RNG -> Double -> Double -> IO Double

-- | <tt>lognormalPdf x zeta sigma</tt> evaluates the probability density
--   <tt>p(x)</tt> at <tt>x</tt> for a log-normal distribution with
--   parameters <tt>zeta</tt> and <tt>sigma</tt>, given. The density is
--   given by <tt>p(x) dx = p(x) {1 over x sqrt{2 pi sigma^2} } exp(-(ln(x)
--   - zeta)^2/2 sigma^2) dx</tt>
lognormalPdf :: Double -> Double -> Double -> Double
lognormalP :: Double -> Double -> Double -> Double
lognormalQ :: Double -> Double -> Double -> Double
lognormalPInv :: Double -> Double -> Double -> Double
lognormalQInv :: Double -> Double -> Double -> Double

-- | <tt>getPareto r a b</tt> gets a random Pareto with exponent <tt>a</tt>
--   and scale <tt>b</tt>.
getPareto :: RNG -> Double -> Double -> IO Double

-- | <tt>paretoPdf x a b</tt> evaluates the probability density
--   <tt>p(x)</tt> at <tt>x</tt> for a Pareto distribution with exponent
--   <tt>a</tt> and scale <tt>b</tt>. The density is given by <tt>p(x) dx =
--   (a<i>b) </i> (x/b)^{a+1} dx</tt> for <tt>x &gt;= b</tt>.
paretoPdf :: Double -> Double -> Double -> Double
paretoP :: Double -> Double -> Double -> Double
paretoQ :: Double -> Double -> Double -> Double
paretoPInv :: Double -> Double -> Double -> Double
paretoQInv :: Double -> Double -> Double -> Double

-- | <tt>getWeibull r a b</tt> gets a random Weibull with scale <tt>a</tt>
--   and exponent <tt>b</tt>.
getWeibull :: RNG -> Double -> Double -> IO Double

-- | <tt>weibullPdf x a b</tt> evaluates the probability density
--   <tt>p(x)</tt> at <tt>x</tt> for a Weibull distribution with scale
--   <tt>a</tt> and exponent <tt>b</tt>. The density is given by <tt>p(x)
--   dx = {b over a^b} x^{b-1} exp(-(x/a)^b) dx</tt> for <tt>x &gt;=
--   0</tt>.
weibullPdf :: Double -> Double -> Double -> Double
weibullP :: Double -> Double -> Double -> Double
weibullQ :: Double -> Double -> Double -> Double
weibullPInv :: Double -> Double -> Double -> Double
weibullQInv :: Double -> Double -> Double -> Double

-- | <tt>getGamma r a b</tt> gets a random gamma with parameters <tt>a</tt>
--   and <tt>b</tt>. Uses the Marsagli-Tsang fast gamma method.
getGamma :: RNG -> Double -> Double -> IO Double

-- | <tt>getGammaKnuth r a b</tt> gets a random gamma with parameters
--   <tt>a</tt> and <tt>b</tt>. Uses the algorithms from Knuth (vol 2).
getGammaKnuth :: RNG -> Double -> Double -> IO Double

-- | <tt>gammaPdf x a b</tt> evaluates the probability density
--   <tt>p(x)</tt> at <tt>x</tt> for a gamma distribution with parameters
--   <tt>a</tt> and <tt>b</tt>. The density is given by <tt>p(x) dx = p(x)
--   dx = {1 over Gamma(a) b^a} x^{a-1} e^{-x/b} dx</tt> for <tt>x &gt;
--   0</tt>.
gammaPdf :: Double -> Double -> Double -> Double
gammaP :: Double -> Double -> Double -> Double
gammaQ :: Double -> Double -> Double -> Double
gammaPInv :: Double -> Double -> Double -> Double
gammaQInv :: Double -> Double -> Double -> Double

-- | <tt>getMultinomial r n ps</tt> gets a random sample from a multinomial
--   distribution with parameters <tt>ps</tt> formed by <tt>n</tt> trials.
getMultinomial :: RNG -> Int -> Vector Double -> IO (Vector Int)

-- | <tt>multinomialPdf ns ps</tt> evaluates the probability density
--   <tt>p(ns)</tt> at <tt>ns</tt> for a multinomial distribution with
--   parameters <tt>ps</tt>, where all <tt>ps</tt> are non-negative and sum
--   to <tt>1</tt>. Note that <tt>xs</tt> and <tt>alphas</tt> should have
--   the same length.
multinomialPdf :: Vector Int -> Vector Double -> Double

-- | <tt>multinomialLnPdf xs alphas == log (multinomialPdf xs alphas)</tt>,
--   but more efficient.
multinomialLnPdf :: Vector Int -> Vector Double -> Double

-- | <tt>getDirichlet r alphas</tt> gets a random sample from a Dirichlet
--   distribution with parameters <tt>alphas</tt>, where all
--   <tt>alphas</tt> are positive.
getDirichlet :: RNG -> Vector Double -> IO (Vector Double)

-- | <tt>dirichletPdf xs alphas</tt> evaluates the probability density
--   <tt>p(xs)</tt> at <tt>xs</tt> for a Dirichlet distribution with
--   parameters <tt>alphas</tt>, where all <tt>alphas</tt> are positive
--   (strictly greater than zero). Note that <tt>xs</tt> and
--   <tt>alphas</tt> should have the same length.
dirichletPdf :: Vector Double -> Vector Double -> Double

-- | <tt>dirichletLnPdf xs alphas == log (dirichletPdf xs alphas)</tt>, but
--   more efficient.
dirichletLnPdf :: Vector Double -> Vector Double -> Double


-- | Random number generators.
module GSL.Random.Gen
newtype RNG
MkRNG :: (ForeignPtr ()) -> RNG
data RNGType

-- | Allocate a new random number generator of the given type and
--   initialize it with the default seed.
newRNG :: RNGType -> IO RNG

-- | Seed the generator with the given value.
setSeed :: RNG -> Word64 -> IO ()

-- | Returns a value uniform in [rngMin, rngMax]
getSample :: RNG -> IO Word64

-- | Returns a value uniform on [0,1)
getUniform :: RNG -> IO Double

-- | Returns a value uniform on (0,1)
getUniformPos :: RNG -> IO Double

-- | Returns an integer uniform on [0,n-1]. <tt>n</tt> must be greater than
--   <tt>0</tt>.
getUniformInt :: RNG -> Int -> IO Int

-- | Get the name of the generator.
getName :: RNG -> IO String

-- | Get the largest value that the generator can return.
getMax :: RNG -> IO Word64

-- | Get the smallest value that the generator can return.
getMin :: RNG -> IO Word64

-- | Get the size of the generator state, in bytes.
getSize :: RNG -> IO Word64

-- | Get the generator state.
getState :: RNG -> IO [Word8]

-- | Set the generator state. The input array should have size equal to
--   <tt>getSize</tt> of the generator; otherwise, strange things will
--   happen.
setState :: RNG -> [Word8] -> IO ()

-- | <tt>copyRNG dst src</tt> copies the state from one generator to
--   another. The two generators must have the same type.
copyRNG :: RNG -> RNG -> IO ()

-- | Allocate a new random number generator that is an exact copy of
--   another generator
cloneRNG :: RNG -> IO RNG
mt19937 :: RNGType
rngType :: String -> Maybe RNGType
