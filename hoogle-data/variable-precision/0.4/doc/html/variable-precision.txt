-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | variable-precision floating point
--   
--   Software floating point with type-tagged variable mantissa precision,
--   implemented using a strict pair of <a>Integer</a> and <a>Int</a>
--   scaled alike to <a>decodeFloat</a>. Version 0.4 adds more
--   number-type-agnostic numerical algorithms (<a>sin</a>, <a>cos</a>,
--   <a>tan</a>).
--   
--   Instances of the usual numeric type classes are provided, along with
--   additional operators (with carefully chosen fixities) to coerce,
--   adjust and reify precisions.
--   
--   The intention with this library is to be relatively simple but still
--   useful, refer to the documentation for caveats concerning accuracy and
--   assorted ill-behaviour.
--   
--   Usage with ghc(i)-7.0.4 might require <tt>-fcontext-stack=100</tt>.
@package variable-precision
@version 0.4


-- | Boilerplate definitions generated by:
--   
--   <pre>
--   flip mapM_ [16..53] $ \p -&gt; let s = show p in
--     putStrLn $ "type N" ++ s ++ " = SuccessorTo N" ++ show (p - 1) ++
--       " ; n" ++ s ++ " :: N" ++ s ++ " ; n" ++ s ++ " = undefined"
--   </pre>
module TypeLevel.NaturalNumber.ExtraNumbers
type N16 = SuccessorTo N15
n16 :: N16
type N17 = SuccessorTo N16
n17 :: N17
type N18 = SuccessorTo N17
n18 :: N18
type N19 = SuccessorTo N18
n19 :: N19
type N20 = SuccessorTo N19
n20 :: N20
type N21 = SuccessorTo N20
n21 :: N21
type N22 = SuccessorTo N21
n22 :: N22
type N23 = SuccessorTo N22
n23 :: N23
type N24 = SuccessorTo N23
n24 :: N24
type N25 = SuccessorTo N24
n25 :: N25
type N26 = SuccessorTo N25
n26 :: N26
type N27 = SuccessorTo N26
n27 :: N27
type N28 = SuccessorTo N27
n28 :: N28
type N29 = SuccessorTo N28
n29 :: N29
type N30 = SuccessorTo N29
n30 :: N30
type N31 = SuccessorTo N30
n31 :: N31
type N32 = SuccessorTo N31
n32 :: N32
type N33 = SuccessorTo N32
n33 :: N33
type N34 = SuccessorTo N33
n34 :: N34
type N35 = SuccessorTo N34
n35 :: N35
type N36 = SuccessorTo N35
n36 :: N36
type N37 = SuccessorTo N36
n37 :: N37
type N38 = SuccessorTo N37
n38 :: N38
type N39 = SuccessorTo N38
n39 :: N39
type N40 = SuccessorTo N39
n40 :: N40
type N41 = SuccessorTo N40
n41 :: N41
type N42 = SuccessorTo N41
n42 :: N42
type N43 = SuccessorTo N42
n43 :: N43
type N44 = SuccessorTo N43
n44 :: N44
type N45 = SuccessorTo N44
n45 :: N45
type N46 = SuccessorTo N45
n46 :: N46
type N47 = SuccessorTo N46
n47 :: N47
type N48 = SuccessorTo N47
n48 :: N48
type N49 = SuccessorTo N48
n49 :: N49
type N50 = SuccessorTo N49
n50 :: N50
type N51 = SuccessorTo N50
n51 :: N51
type N52 = SuccessorTo N51
n52 :: N52
type N53 = SuccessorTo N52
n53 :: N53


-- | Implementations of various floating point algorithms. Accuracy has not
--   been extensively verified, and termination has not been proven.
--   
--   Everything assumes that <a>floatRadix</a> is 2. This is *not* checked.
--   
--   Functions taking an <tt>accuracy</tt> parameter may fail to terminate
--   if <tt>accuracy</tt> is too small. Accuracy is measured in least
--   significant bits, similarly to '(=~=)'.
--   
--   In this documentation, <i>basic functionality</i> denotes that methods
--   used are from classes:
--   
--   <ul>
--   <li><a>Num</a>, <a>Eq</a>, <a>Ord</a>.</li>
--   </ul>
--   
--   Further, <i>basic RealFloat functionality</i> denotes <i>basic
--   functionality</i> with the addition of:
--   
--   <ul>
--   <li>Anything in <a>RealFloat</a> except for <a>atan2</a>.</li>
--   </ul>
--   
--   The intention behind the used functionality documentation is to help
--   users decide when it is appropriate to use these generic
--   implementations to implement instances.
module Numeric.VariablePrecision.Algorithms

-- | Convert between generic <a>RealFloat</a> types more efficiently than
--   <a>realToFrac</a>. Tries hard to preserve special values like
--   infinities and negative zero, but any NaN payload is lost.
--   
--   Uses only basic RealFloat functionality.
recodeFloat :: (RealFloat a, RealFloat b) => a -> b

-- | Lift a function from Double to generic <a>RealFloat</a> types.
viaDouble :: (RealFloat a, RealFloat b) => (Double -> Double) -> a -> b

-- | Approximate equality. <tt>(a =~= b) c</tt> when adding the difference
--   to the larger in magnitude changes at most <tt>c</tt> least
--   significant mantissa bits.
--   
--   Uses only basic RealFloat functionality.
(=~=) :: RealFloat a => a -> a -> Int -> Bool

-- | Compute a reciprocal using the Newton-Raphson division algorithm, as
--   described in
--   <a>http://en.wikipedia.org/wiki/Division_%28digital%29#Newton.E2.80.93Raphson_division</a>.
--   
--   Uses only basic RealFloat functionality.
genericRecip :: RealFloat a => Int -> a -> a

-- | Compute a square root using Newton's method.
--   
--   Uses basic RealFloat functionality and '(/)'.
genericSqrt :: RealFloat a => Int -> a -> a

-- | Compute an exponential using power series.
--   
--   Uses basic RealFloat functionality, '(/)' and <a>recip</a>.
genericExp :: RealFloat a => Int -> a -> a

-- | Compute a logarithm.
--   
--   See <a>genericLog''</a> for algorithmic references.
--   
--   Uses basic RealFloat functionality, <a>sqrt</a> and <a>recip</a>.
genericLog :: RealFloat a => Int -> a -> a

-- | Compute a logarithm using decomposition and a value for <tt>log
--   2</tt>.
--   
--   See <a>genericLog''</a> for algorithmic references.
--   
--   Uses basic RealFloat functionality, <a>sqrt</a>, and <a>recip</a>.
genericLog' :: RealFloat a => Int -> a -> a -> a

-- | Compute log 2.
--   
--   See <a>genericLog''</a> for algorithmic references.
--   
--   Uses basic RealFloat functionality, <a>sqrt</a> and <a>recip</a>.
genericLog2 :: RealFloat a => Int -> a

-- | Compute a logarithm for a value in [0.5,1) using the AGM method as
--   described in section 7 of <i>The Logarithmic Constant: log 2</i>
--   Xavier Gourdon and Pascal Sebah, May 18, 2010,
--   <a>http://numbers.computation.free.fr/Constants/Log2/log2.ps</a>.
--   
--   The precondition is not checked.
--   
--   Uses basic RealFloat functionality, <a>sqrt</a>, and <a>recip</a>.
genericLog'' :: RealFloat a => Int -> a -> a

-- | Compute pi using the method described in section 8 of
--   <i>Multiple-precision zero-finding methods and the complexity of
--   elementary function evaluation</i> Richard P Brent, 1975 (revised May
--   30, 2010), <a>http://arxiv.org/abs/1004.3412</a>.
--   
--   Uses basic RealFloat functionality, '(/)', and <a>sqrt</a>.
genericPi :: RealFloat a => Int -> a

-- | Compute <a>sin</a> using the method described in section 3 of
--   <i>Efficient multiple-precision evaluation of elementary functions</i>
--   David M Smith, 1989, <a>http://digitalcommons.lmu.edu/math_fac/1/</a>
--   
--   Requires a value for pi.
--   
--   Uses basic RealFloat functionality, '(/)', and sqrt.
genericSin :: RealFloat a => Int -> a -> a -> a

-- | Special values implemented using basic RealFloat functionality.
genericPositiveZero :: RealFloat a => a

-- | Special values implemented using basic RealFloat functionality.
genericNegativeZero :: RealFloat a => a

-- | Special values implemented using basic RealFloat functionality.
genericPositiveInfinity :: RealFloat a => a

-- | Special values implemented using basic RealFloat functionality.
genericNegativeInfinity :: RealFloat a => a

-- | Special values implemented using basic RealFloat functionality.
genericNotANumber :: RealFloat a => a

-- | Check if two numbers have the same sign. May give a nonsense result if
--   an argument is NaN.
sameSign :: (Ord a, Num a) => a -> a -> Bool


-- | Classes for types with precision represented by a type-level natural
--   number, and variable precision types.
--   
--   Note that performance may be (even) slow(er) with some versions of the
--   type-level-natural-number package.
module Numeric.VariablePrecision.Precision

-- | A class for types with precision. The methods must not evaluate their
--   arguments, and their results must not be evaluated. Minimal complete
--   definition: (none).
class HasPrecision t where precisionOf _ = undefined
precisionOf :: (HasPrecision t, NaturalNumber p) => t p -> p

-- | Much like <a>naturalNumberAsInt</a> combined with <a>precisionOf</a>.
precision :: (NaturalNumber p, HasPrecision t) => t p -> Word

-- | Much like <a>const</a> with a restricted type.
atPrecision :: (NaturalNumber p, HasPrecision t) => t p -> p -> t p

-- | Much like <a>const</a> with a restricted type. Precedence between
--   <a>&lt;</a> and <a>+</a>.
atPrecisionOf :: (HasPrecision t, HasPrecision s) => t p -> s p -> t p

-- | An alias for <a>atPrecisionOf</a>. Precedence between <a>&lt;</a> and
--   <a>+</a>.
(.@) :: (HasPrecision t, HasPrecision s) => t p -> s p -> t p

-- | A class for types with adjustable precision. Minimal complete
--   definition: <a>adjustPrecision</a>.
class HasPrecision t => VariablePrecision t
adjustPrecision :: (VariablePrecision t, NaturalNumber p, NaturalNumber q) => t p -> t q

-- | Synonym for <a>adjustPrecision</a>.
auto :: (VariablePrecision t, NaturalNumber p, NaturalNumber q) => t p -> t q

-- | Much like <a>adjustPrecision</a> combined with <a>atPrecision</a>.
withPrecision :: (NaturalNumber p, NaturalNumber q, VariablePrecision t) => t p -> q -> t q

-- | Much like <a>withPrecision</a> combined with <a>precisionOf</a>.
--   Precedence between <a>&lt;</a> and <a>+</a>.
withPrecisionOf :: (NaturalNumber p, NaturalNumber q, VariablePrecision t, HasPrecision s) => t p -> s q -> t q

-- | An alias for <a>withPrecisionOf</a>. Precedence between <a>&lt;</a>
--   and <a>+</a>.
(.@~) :: (NaturalNumber p, NaturalNumber q, VariablePrecision t, HasPrecision s) => t p -> s q -> t q


-- | Reify from value-level to type-level using Rank2Types.
module Numeric.VariablePrecision.Precision.Reify

-- | Reify a precision from value-level to type-level.
reifyPrecision :: Word -> (forall p. NaturalNumber p => p -> a) -> a

-- | Much like <a>reifyPrecision</a> combined with <a>withPrecision</a>.
withReifiedPrecision :: (VariablePrecision t, NaturalNumber p) => t p -> Word -> (forall q. NaturalNumber q => t q -> a) -> a

-- | An alias for <a>withReifiedPrecision</a>.
(.@$) :: (VariablePrecision t, NaturalNumber p) => t p -> Word -> (forall q. NaturalNumber q => t q -> a) -> a


-- | Variable precision software fixed point based on <tt>Integer</tt>.
--   
--   Accuracy has not been extensively verified.
--   
--   Example:
--   
--   <pre>
--   reifyPrecision 1000 $ \prec -&gt;
--      show $ auto (355 :: VFixed N15) / 113 `atPrecision` prec
--   </pre>
module Numeric.VariablePrecision.Fixed

-- | A software implementation of fixed point arithmetic, using an
--   <a>Integer</a> adjusted to <tt>p</tt> bits after the binary point.
data VFixed p

-- | A concrete format suitable for storage or wire transmission.
data DFixed
DFixed :: !Word -> !Integer -> DFixed
dxPrecision :: DFixed -> !Word
dxMantissa :: DFixed -> !Integer

-- | Freeze a <a>VFixed</a>.
toDFixed :: NaturalNumber p => VFixed p -> DFixed

-- | Thaw a <a>DFixed</a>. Results in <a>Nothing</a> on precision mismatch.
fromDFixed :: NaturalNumber p => DFixed -> Maybe (VFixed p)

-- | Thaw a <a>DFixed</a> to its natural precision.
withDFixed :: DFixed -> (forall p. NaturalNumber p => VFixed p -> r) -> r
instance Typeable1 VFixed
instance Typeable DFixed
instance Data p => Data (VFixed p)
instance Eq DFixed
instance Ord DFixed
instance Read DFixed
instance Show DFixed
instance Data DFixed
instance NaturalNumber p => RealFrac (VFixed p)
instance NaturalNumber p => Real (VFixed p)
instance NaturalNumber p => Fractional (VFixed p)
instance NaturalNumber p => Num (VFixed p)
instance NaturalNumber p => Ord (VFixed p)
instance NaturalNumber p => Eq (VFixed p)
instance NaturalNumber p => Read (VFixed p)
instance NaturalNumber p => Show (VFixed p)
instance NaturalNumber p => BinDecode (VFixed p)
instance VariablePrecision VFixed
instance HasPrecision VFixed


-- | Variable precision software floating point based on <tt>(Integer,
--   Int)</tt> as used by <a>decodeFloat</a>. Supports infinities and NaN,
--   but not negative zero or denormalization.
--   
--   Accuracy has not been extensively verified, and termination of
--   numerical algorithms has not been proven.
module Numeric.VariablePrecision.Float

-- | A software implementation of floating point arithmetic, using a strict
--   pair of <a>Integer</a> and <a>Int</a>, scaled similarly to
--   <a>decodeFloat</a>, along with additional values representing:
--   
--   <ul>
--   <li>positive infinity (<tt>1/0</tt>),</li>
--   <li>negative infinity (<tt>-1/0</tt>),</li>
--   <li>not a number (<tt>0/0</tt>).</li>
--   </ul>
--   
--   The <a>Floating</a> instance so far only implements algorithms for:
--   
--   <ul>
--   <li><a>pi</a>,</li>
--   <li><a>sqrt</a>,</li>
--   <li><a>exp</a>,</li>
--   <li><a>log</a>,</li>
--   <li><a>sin</a>, <a>cos</a>, <a>tan</a>.</li>
--   </ul>
--   
--   These <a>Floating</a> methods transit via <a>Double</a> and so have
--   limited precision:
--   
--   <ul>
--   <li><a>asin</a>, <a>acos</a>, <a>atan</a>,</li>
--   <li><a>sinh</a>, <a>cosh</a>, <a>tanh</a>,</li>
--   <li><a>asinh</a>, <a>acosh</a>, <a>atanh</a>.</li>
--   </ul>
--   
--   <a>floatRange</a> is arbitrarily limited to mitigate the problems that
--   occur when enormous integers might be needed during some number type
--   conversions (worst case consequence: program abort in gmp).
data VFloat p

-- | A selection of norms.
class HasPrecision t => Normed t
norm1 :: (Normed t, NaturalNumber p) => t p -> VFloat p
norm2 :: (Normed t, NaturalNumber p) => t p -> VFloat p
norm2Squared :: (Normed t, NaturalNumber p) => t p -> VFloat p
normInfinity :: (Normed t, NaturalNumber p) => t p -> VFloat p

-- | A measure of meaningful precision in the difference of two finite
--   non-zero values.
--   
--   Values of very different magnitude have little meaningful difference,
--   because <tt>a + b <tt>approxEq</tt> a</tt> when <tt>|a| &gt;&gt;
--   |b|</tt>.
--   
--   Very close values have little meaningful difference, because <tt>a +
--   (a - b) <tt>approxEq</tt> a</tt> as <tt>|a| &gt;&gt; |a - b|</tt>.
--   
--   <a>effectivePrecisionWith</a> attempts to quantify this.
effectivePrecisionWith :: (Num t, RealFloat r) => (t -> r) -> t -> t -> Int

-- | Much like <a>effectivePrecisionWith</a> combined with
--   <a>normInfinity</a>.
effectivePrecision :: (NaturalNumber p, HasPrecision t, Normed t, Num (t p)) => t p -> t p -> Int

-- | An alias for <a>effectivePrecision</a>.
(-@?) :: (NaturalNumber p, HasPrecision t, Normed t, Num (t p)) => t p -> t p -> Int

-- | A concrete format suitable for storage or wire transmission.
data DFloat
DFloat :: !Word -> !Integer -> !Int -> DFloat
dPrecision :: DFloat -> !Word
dMantissa :: DFloat -> !Integer
dExponent :: DFloat -> !Int
DZero :: !Word -> DFloat
dPrecision :: DFloat -> !Word
DPositiveInfinity :: !Word -> DFloat
dPrecision :: DFloat -> !Word
DNegativeInfinity :: !Word -> DFloat
dPrecision :: DFloat -> !Word
DNotANumber :: !Word -> DFloat
dPrecision :: DFloat -> !Word

-- | Freeze a <a>VFloat</a>.
toDFloat :: NaturalNumber p => VFloat p -> DFloat

-- | Thaw a <a>DFloat</a>. Results in <a>Nothing</a> on precision mismatch.
fromDFloat :: NaturalNumber p => DFloat -> Maybe (VFloat p)

-- | Thaw a <a>DFloat</a> to its natural precision.
withDFloat :: DFloat -> (forall p. NaturalNumber p => VFloat p -> r) -> r
instance Typeable1 VFloat
instance Typeable DFloat
instance Data p => Data (VFloat p)
instance Eq DFloat
instance Ord DFloat
instance Read DFloat
instance Show DFloat
instance Data DFloat
instance Normed VFloat
instance NaturalNumber p => Floating (VFloat p)
instance NaturalNumber p => RealFloat (VFloat p)
instance NaturalNumber p => RealFrac (VFloat p)
instance NaturalNumber p => Fractional (VFloat p)
instance NaturalNumber p => Real (VFloat p)
instance NaturalNumber p => Num (VFloat p)
instance Ord (VFloat p)
instance Eq (VFloat p)
instance VariablePrecision VFloat
instance HasPrecision VFloat
instance NaturalNumber p => Read (VFloat p)
instance NaturalNumber p => Show (VFloat p)
instance NaturalNumber p => FShow (VFloat p)
instance NaturalNumber p => DispFloat (VFloat p)


-- | Complex numbers with variable precision.
module Numeric.VariablePrecision.Complex

-- | Newtype wrapper around <a>Complex</a> so that instances can be written
--   for <a>HasPrecision</a> and <a>VariablePrecision</a>.
data VComplex t p

-- | Convert <a>VComplex</a> to <a>Complex</a>.
toComplex :: VComplex t p -> Complex (t p)

-- | Convert <a>Complex</a> to <a>VComplex</a>.
fromComplex :: Complex (t p) -> VComplex t p

-- | Lift an operation on <a>Complex</a> to one on <a>VComplex</a>.
withComplex :: (Complex (t p) -> Complex (t q)) -> (VComplex t p -> VComplex t q)

-- | Much like <tt>mapComplex</tt> <a>recodeFloat</a>.
recodeComplex :: (RealFloat a, RealFloat b) => Complex a -> Complex b

-- | Much like <tt>mapComplex</tt> <a>scaleFloat</a>.
scaleComplex :: RealFloat r => Int -> Complex r -> Complex r

-- | Much like <a>withComplex</a> <tt>scaleComplex'</tt>.
scaleVComplex :: NaturalNumber p => Int -> VComplex VFloat p -> VComplex VFloat p

-- | Freeze a 'VComplex VFloat'.
toComplexDFloat :: NaturalNumber p => VComplex VFloat p -> Complex DFloat

-- | Freeze a 'VComplex VFixed'.
toComplexDFixed :: NaturalNumber p => VComplex VFixed p -> Complex DFixed

-- | Thaw a 'Complex DFloat'. Results in <a>Nothing</a> on precision
--   mismatch.
fromComplexDFloat :: NaturalNumber p => Complex DFloat -> Maybe (VComplex VFloat p)

-- | Thaw a 'Complex DFixed'. Results in <a>Nothing</a> on precision
--   mismatch.
fromComplexDFixed :: NaturalNumber p => Complex DFixed -> Maybe (VComplex VFixed p)

-- | Thaw a 'Complex DFloat' to its natural precision. <a>Nothing</a> is
--   passed on precision mismatch between real and imaginary parts.
withComplexDFloat :: Complex DFloat -> (forall p. NaturalNumber p => Maybe (VComplex VFloat p) -> r) -> r

-- | Thaw a 'Complex DFixed' to its natural precision. <a>Nothing</a> is
--   passed on precision mismatch between real and imaginary parts.
withComplexDFixed :: Complex DFixed -> (forall p. NaturalNumber p => Maybe (VComplex VFixed p) -> r) -> r
instance Floating (Complex (t p)) => Floating (VComplex t p)
instance Fractional (Complex (t p)) => Fractional (VComplex t p)
instance Num (Complex (t p)) => Num (VComplex t p)
instance Eq (t p) => Eq (VComplex t p)
instance NaturalNumber p => Read (VComplex VFixed p)
instance NaturalNumber p => Read (VComplex VFloat p)
instance NaturalNumber p => Show (VComplex VFixed p)
instance NaturalNumber p => Show (VComplex VFloat p)
instance Normed (VComplex VFloat)
instance VariablePrecision (VComplex VFixed)
instance VariablePrecision (VComplex VFloat)
instance HasPrecision (VComplex VFixed)
instance HasPrecision (VComplex VFloat)
instance NaturalNumber p => ComplexPolar (VComplex VFloat p) (VFloat p)
instance NaturalNumber p => ComplexRect (VComplex VFixed p) (VFixed p)
instance NaturalNumber p => ComplexRect (VComplex VFloat p) (VFloat p)
instance NaturalNumber p => ComplexPolar (Complex (VFloat p)) (VFloat p)
instance NaturalNumber p => ComplexRect (Complex (VFixed p)) (VFixed p)
instance NaturalNumber p => ComplexRect (Complex (VFloat p)) (VFloat p)
instance NaturalNumber p => Floating (Complex (VFloat p))
instance NaturalNumber p => Fractional (Complex (VFixed p))
instance NaturalNumber p => Fractional (Complex (VFloat p))
instance NaturalNumber p => Num (Complex (VFixed p))
instance NaturalNumber p => Num (Complex (VFloat p))


-- | Aliases for <a>recodeFloat</a> and <a>recodeComplex</a> with
--   specialized types.
--   
--   Aliases for commonly desired types.
module Numeric.VariablePrecision.Aliases

-- | Convert to a Float from the same precision.
toFloat :: F24 -> Float

-- | Convert from a Float to the same precision.
fromFloat :: Float -> F24

-- | Convert to a Double from the same precision.
toDouble :: F53 -> Double

-- | Convert from a Double to the same precision.
fromDouble :: Double -> F53

-- | Convert to a Float from the same precision.
toComplexFloat :: CF24 -> Complex Float

-- | Convert from a Float to the same precision.
fromComplexFloat :: Complex Float -> CF24

-- | Convert to a Double from the same precision.
toComplexDouble :: CF53 -> Complex Double

-- | Convert from a Double to the same precision.
fromComplexDouble :: Complex Double -> CF53
type F = VFloat
type X = VFixed
type C = VComplex
type CF = C F
type CX = C X
type F8 = F N8
type F16 = F N16
type F24 = F N24
type F32 = F N32
type F40 = F N40
type F48 = F N48
type F53 = F N53
f8 :: F8
f16 :: F16
f24 :: F24
f32 :: F32
f40 :: F40
f48 :: F48
f53 :: F53
type X8 = X N8
type X16 = X N16
type X24 = X N24
type X32 = X N32
type X40 = X N40
type X48 = X N48
type X53 = X N53
x8 :: X8
x16 :: X16
x24 :: X24
x32 :: X32
x40 :: X40
x48 :: X48
x53 :: X53
type CF8 = CF N8
type CF16 = CF N16
type CF24 = CF N24
type CF32 = CF N32
type CF40 = CF N40
type CF48 = CF N48
type CF53 = CF N53
cf8 :: CF8
cf16 :: CF16
cf24 :: CF24
cf32 :: CF32
cf40 :: CF40
cf48 :: CF48
cf53 :: CF53
type CX8 = CX N8
type CX16 = CX N16
type CX24 = CX N24
type CX32 = CX N32
type CX40 = CX N40
type CX48 = CX N48
type CX53 = CX N53
cx8 :: CX8
cx16 :: CX16
cx24 :: CX24
cx32 :: CX32
cx40 :: CX40
cx48 :: CX48
cx53 :: CX53


-- | Convenience module.
module Numeric.VariablePrecision
