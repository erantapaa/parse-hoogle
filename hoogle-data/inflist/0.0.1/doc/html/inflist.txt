-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An infinite list type and operations thereon.
--   
--   An infinite list type and operations thereon.
@package inflist
@version 0.0.1


-- | This module provides an infinite list type and operations thereon.
--   
--   Haskell has two outstanding features:
--   
--   <ul>
--   <li>laziness, which in particular allows infinite data
--   structures;</li>
--   <li>a very strong type system.</li>
--   </ul>
--   
--   In that light, it's a bit embarrassing that its default libraries do
--   not allow one to express the infinitude of, say, a list. For example,
--   <a>repeat</a> has type <tt>a â†’ [a]</tt>, when it of course should not
--   return a finite list.
--   
--   This module defines an infinite list data structure and provides all
--   the standard list-manipulating functions that make sense on them. The
--   advantages of using this over a standard list are:
--   
--   <ul>
--   <li><i>Type safety and clarity.</i> We are prevented from using
--   nonsensical functions on infinite lists. These include the functions:
--   <a>last</a>, <a>init</a>, <a>null</a>, <a>length</a>, <a>foldl</a>,
--   <a>scanr</a>, <a>scanl</a>, <a>replicate</a>, <a>reverse</a>,
--   <a>any</a> (etc.), <a>isSuffixOf</a>, 'Data.List.(\)', <a>union</a>,
--   <a>unionBy</a>, <a>intersect</a>, <a>intersectBy</a>,
--   <a>transpose</a>, <a>deleteFirstsBy</a>, <a>subsequences</a>,
--   <a>nonEmptySubsequences</a>, <a>permutations</a>, <a>sort</a>,
--   <a>sortBy</a>, <a>sum</a> (etc.), <a>elem</a> (etc.), <a>lookup</a>,
--   <a>findIndex</a>, <a>elemIndex</a>, <a>isInfixOf</a>, <a>nub</a>.</li>
--   <li><i>No pattern-matching on nil</i>. Where you can identify that
--   <tt>[]</tt> will never be present, using a list forces you to either
--   write clunky error-generating pattern matches, or alternatively put up
--   with compiler warnings about incompete pattern matches. Code is
--   simplified.</li>
--   <li><i>Faster code.</i> We do not need or want runtime pattern-matches
--   on a data constructor which will never occur. Haskell compilers love
--   single-constructor datatypes:
--   <a>http://www.haskell.org/haskellwiki/Performance/Data_types#Single-constructor_datatypes</a></li>
--   </ul>
--   
--   See for comparison the <a>List</a> and <a>List</a> modules.
module Data.InfList

-- | The infinite list data type. This is identical to the normal list data
--   type with the sole exception that it lacks the <tt>[]</tt>
--   constructor.
data InfList a

-- | Cons an element onto an infinite list to yield another infinite list.
(:::) :: a -> InfList a -> InfList a

-- | A simple type synonym for predicates.
type Pred a = a -> Bool

-- | Repeatedly apply a generating function on an initial value, generating
--   an infinite list.
iterate :: (a -> a) -> a -> InfList a

-- | Given a list element, use that as every element in an infinite list.
repeat :: a -> InfList a

-- | Repeat the elements of a non-empty finite list.
cycle :: [a] -> InfList a

-- | Get the first element of a list. This is guaranteed to exist.
head :: InfList a -> a

-- | Get the tail of a list. This is guaranteed to exist.
tail :: InfList a -> InfList a

-- | Convert an <a>InfList</a> to an infinite list. Use sparingly.
toList :: InfList a -> [a]

-- | Convert an infinite list to an <a>InfList</a>. Throws an error if the
--   given list runs out of elements. Use sparingly.
fromList :: [a] -> InfList a

-- | Apply a function to each element of the list, yielding a new list of
--   the results.
map :: (a -> b) -> InfList a -> InfList b

-- | Applies a function to each element of a list, passing an accumulating
--   parameter from left to right, returning a new list. This is not quite
--   the same as <a>mapAccumL</a>: there is no final accumulator returned.
mapAccumL :: (acc -> a -> (acc, b)) -> acc -> InfList a -> InfList b

-- | Catamorphism. This is not the same as <a>foldr</a> on lists, as it
--   contains no base value.
foldr :: (a -> b -> b) -> InfList a -> b

-- | Build a list from a seed value. The iterating function takes the seed
--   value and produces the next element in the list along with a new seed
--   value to use for the next element. Not the same as <a>unfoldr</a>.
unfoldr :: (a -> (b, a)) -> a -> InfList b

-- | Place a given element between every adjacent two elements of a given
--   infinite list.
intersperse :: a -> InfList a -> InfList a

-- | Given an infinite list of finite lists, intersperse the infinite list
--   with a given finite list, and concatenate it.
intercalate :: [a] -> InfList [a] -> InfList a

-- | Prepend a finite list to a infinite list yielding a new infinite list.
(+++) :: [a] -> InfList a -> InfList a

-- | Expand all elements of an infinite list into finite lists and
--   concatenate them.
concatMap :: (a -> [b]) -> InfList a -> InfList b

-- | Concatenate an infinite list of finite lists into an infinite list of
--   elements. That is, remove one level of nesting.
concat :: InfList [a] -> InfList a

-- | Given a natural number, get a two-tuple of the finite list of that
--   many elements from the start of a given infinite list, and the
--   infinite list that follows them.
splitAt :: Int -> InfList a -> ([a], InfList a)

-- | Split an infinite list into a longest prefix such that all the
--   elements of it satisfy a given predicate, and the rest of the list
--   following them.
span :: Pred a -> InfList a -> ([a], InfList a)

-- | Split an infinite list into a longest prefix such that all the
--   elements of it do not satisfy a given predicate, and the rest of the
--   list following them.
break :: Pred a -> InfList a -> ([a], InfList a)

-- | Given a predicate over two elements, split an infinite list of
--   elements of that type into maximal-length finite lists where each
--   adjacent pair of elements in each list satisfies the predicate in that
--   order.
--   
--   In practise, the predicate is associative and commutative, e.g. an
--   equality relation, as used in the <a>group</a> function.
groupBy :: (a -> a -> Bool) -> InfList a -> InfList [a]

-- | Given an infinite list, split it into maximal-length finite lists
--   where every element in each list is equal.
group :: Eq a => InfList a -> InfList [a]

-- | Given a predicate and an infinite list, return a pair of infinite
--   lists of elements which do and do not satisfy the predicate,
--   respectively.
partition :: Pred a -> InfList a -> (InfList a, InfList a)

-- | Is a given finite list a prefix of a given infinite list?
isPrefixOf :: Eq a => [a] -> InfList a -> Bool

-- | Given a potential prefix of an infinite list, if the infinite list has
--   that prefix, return just the rest of the infinite list; otherwise,
--   return <a>Nothing</a>.
stripPrefix :: Eq a => [a] -> InfList a -> Maybe (InfList a)

-- | List the prefixes of an infinite list in ascending order of length.
inits :: InfList a -> InfList [a]

-- | List the tails of an infinite list in ascending order of distance from
--   the head of the list.
tails :: InfList a -> InfList (InfList a)

-- | Given a natural number, return that many elements from the start of an
--   infinite list.
take :: Int -> InfList a -> [a]

-- | Given a natural number, drop that many elements from the start of an
--   infinite list.
drop :: Int -> InfList a -> InfList a

-- | The longest prefix of an infinite list such that all elements of that
--   prefix satisfy a given predicate.
takeWhile :: Pred a -> InfList a -> [a]

-- | Remove the longest prefix of an infinite list where all elements of
--   that prefix satisfy a given predicate.
dropWhile :: Pred a -> InfList a -> InfList a

-- | Zip two infinite lists into an infinite list of two-tuples, where
--   `(a,b)` in the nth tuple are the nth elements of the first and second
--   list respectively.
zip :: InfList a -> InfList b -> InfList (a, b)
zip3 :: InfList a -> InfList b -> InfList c -> InfList (a, b, c)

-- | Zip two infinite lists into a third list where the nth element of the
--   third list is the result of applying a given function to the nth
--   elements of the first and second lists.
zipWith :: (a -> b -> c) -> InfList a -> InfList b -> InfList c
zipWith3 :: (a -> b -> c -> d) -> InfList a -> InfList b -> InfList c -> InfList d

-- | Reverse the operation of <a>zip</a>. That is, given an infinite list
--   of two-tuples, return a two-tuple of infinite lists where the nth
--   element of the first list in the result is the first element of the
--   nth tuple of the first list, and correspondingly for the second list
--   in the result tuple.
unzip :: InfList (a, b) -> (InfList a, InfList b)
unzip3 :: InfList (a, b, c) -> (InfList a, InfList b, InfList c)

-- | Select the elements of a list that satisfy a predicate.
filter :: Pred a -> InfList a -> InfList a

-- | Delete the first element satisfying a given predicate. Notice that
--   this is not the same as <a>deleteBy</a>.
deleteBy :: Eq a => Pred a -> InfList a -> InfList a

-- | Delete the first element equal to a given element.
delete :: Eq a => a -> InfList a -> InfList a

-- | Given a natural number, get that the element at that index of a given
--   infinite list.
(!!!) :: InfList a -> Int -> a

-- | Get the indices into an infinite list where each element at that index
--   satisfies a given predicate.
findIndices :: Pred a -> InfList a -> InfList Int

-- | Get the indices into an infinite list where each element at that index
--   is equal to the given element.
elemIndices :: Eq a => a -> InfList a -> InfList Int
instance [safe] Show a => Show (InfList a)
instance [safe] Ord a => Ord (InfList a)
instance [safe] Eq a => Eq (InfList a)
instance [safe] Functor InfList

module Data.InfList.InfString

-- | Analogous to the <a>String</a> data type.
type InfString = InfList Char

-- | Convert an <a>InfString</a> to the equivalent infinite <a>String</a>.
toString :: InfString -> String

-- | Declaring <a>InfString</a> an instance of <a>Show</a> results in
--   overlapping typeclasses. We instead use a simple function that
--   converts an <a>InfString</a> to an infinite <a>String</a>.
showInfString :: InfString -> String

-- | Split an <a>InfString</a> into an infinite list of lines.
lines :: InfString -> InfList String

-- | Join an infinite list of lines into an infinite string.
unlines :: InfList String -> InfString

-- | Split an infinite string by whitespace.
words :: InfString -> InfList String

-- | Join an infinite list of words into an infinite string. A space is
--   inserted between each word.
unwords :: InfList String -> InfString

module Data.InfList.Common
nats :: InfList Integer
nats1 :: InfList Integer
evens :: InfList Integer
odds :: InfList Integer
fibs :: InfList Integer
lucas :: InfList Integer
facts :: InfList Integer
pascalTriangle :: InfList [Integer]
bells :: InfList Integer
collatz :: Integer -> InfList Integer

module Data.InfList.Arbitrary
instance Arbitrary a => Arbitrary (InfList a)
