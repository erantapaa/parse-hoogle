-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A simple web framework.
--   
--   A simple web framework.
@package frame
@version 0.1


-- | Module to define a configuration to be provided when launching
--   framework applications
module Frame.Config
data Config
Config :: DBInfo -> String -> String -> String -> String -> [String] -> Config

-- | The database info
database :: Config -> DBInfo

-- | The name for the database
dbName :: Config -> String

-- | The ODBC URL for the database
dbURL :: Config -> String

-- | File system path to sessions
sessionPath :: Config -> String

-- | Session ID
sessionId :: Config -> String

-- | Stylesheets to attach to the view
css :: Config -> [String]
class (MonadReader Config m) => FrameConfig m

-- | Retrieves a function of the current environment. Parameters:
--   
--   <ul>
--   <li>The selector function to apply to the environment.</li>
--   </ul>
--   
--   See an example in <a>Control.Monad.Reader</a>.
asks :: (MonadReader r m) => (r -> a) -> m a
instance (MonadReader Config m) => FrameConfig m


-- | Common helper functions
module Frame.Utilities

-- | Similar to <a>words</a> except splitting against arbitrary <a>Char</a>
explode :: Char -> String -> [String]

-- | Explode for URLs
explodeURL :: String -> [String]

-- | Explode for field names
explodeFieldName :: String -> (Int, [String])

-- | Opposite of explode
implode :: Char -> [String] -> String

-- | Implode for URLs
implodeUrl :: [String] -> String

-- | ''hi there'' to ''Hi There''
humanise :: String -> String

-- | ''camelCase'' to ''Camel Case''
humaniseCamel :: String -> String

-- | ''/a/url'' to ''A Url''
humaniseUrl :: String -> String -> String

-- | [''a'', ''url''] to ''A Url''
humanisePath :: [String] -> String -> String

-- | <a>Maybe</a> <a>Maybe</a> == <a>Maybe</a>
maybeMaybe :: Maybe (Maybe a) -> Maybe a

-- | Safe head
headMaybe :: [a] -> Maybe a

-- | Monadic safe head
pop :: (Monad m) => m [a] -> m (Maybe a)

-- | Function application within <a>Maybe</a>
appMaybe :: (a -> b) -> Maybe a -> Maybe b

-- | List of <a>Nothing</a> == True
allNothing :: [Maybe a] -> Bool

-- | Captures failure
(?) :: Bool -> String -> Maybe String

-- | Same as (?), always returns a string ('''' on success)
(??) :: Bool -> String -> String


-- | Defines a homogenous collection of field types to interface typeless
--   HTTP and HTML with the application and with HaskellDB
module Frame.Types

-- | Label for a specific field
type FieldName = String

-- | Heterogeneous type wrapper
data WrapperType

-- | String wrapper
WrapString :: (Maybe Int) -> String -> WrapperType

-- | Int wrappr
WrapInt :: Int -> WrapperType

-- | Bool wrapper
WrapBool :: Bool -> WrapperType

-- | Type error (specific case of error)
WrapError :: FieldType -> String -> WrapperType

-- | Empty type
WrapEmpty :: FieldType -> WrapperType

-- | Collection of heterogenous fields associated by <a>FieldName</a>
type Fields = Map FieldName WrapperType

-- | Casts the <a>FieldName</a> in fields to string
showField :: FieldName -> Fields -> String

-- | Purge non mandatory empty fields
purge :: DBInfo -> Fields -> Fields
class Wrappable a
wrap :: (Wrappable a) => DBInfo -> FieldName -> a -> WrapperType
unwrap :: (Wrappable a) => WrapperType -> a

-- | Wrap a <a>String</a> representation of an <a>Int</a>
wrapInt :: String -> WrapperType

-- | Wrap a <a>String</a> representation of a <a>Bool</a>
wrapBool :: String -> WrapperType

-- | Returns an error message if there has been a wrapping error
wrapError :: WrapperType -> String
isMandatory :: DBInfo -> FieldName -> Maybe Bool

-- | A potential <a>WrapperType</a> is <a>WrapEmpty</a> if <a>Nothing</a>
maybeUnwrap :: Maybe WrapperType -> WrapperType

-- | Special version of <a>fromList</a> that also wraps fields as it goes
fromList' :: DBInfo -> [(FieldName, String)] -> Map FieldName WrapperType
unwrapField :: (Wrappable a) => FieldName -> Fields -> Maybe a
instance Binary WrapperType
instance Binary FieldType
instance (Show a) => Wrappable (Maybe a)
instance (Size n) => Wrappable (BoundedList Char n)
instance Wrappable Bool
instance Wrappable [Char]
instance Wrappable WrapperType
instance Wrappable Int
instance Show WrapperType


-- | Functions for validation of fields
module Frame.Validation

-- | A validator is a map associating field names to a list of functions
--   taking a wrapped type to a potential (error) string
type Validators = Map FieldName [WrapperType -> Maybe String]

-- | Validate a whole set of fields against a set of validators
validate :: Validators -> Fields -> Map FieldName [Maybe String]

-- | Validate a particular field against a list of validators
validateField :: [WrapperType -> Maybe String] -> WrapperType -> [Maybe String]

-- | True if all fields validate against a set of validators
allValidated :: Validators -> Fields -> Bool

-- | Cannot be empty
notEmpty :: WrapperType -> Maybe String

-- | Must be shorter than a given length
shorterThan :: Int -> WrapperType -> Maybe String

-- | Must be greater than a given number
greaterThan :: Int -> WrapperType -> Maybe String

-- | A type level check to make sure a string is within the bounds defined
withinBounds :: WrapperType -> Maybe String


-- | The state contains mutable environmental variables such as posted form
--   fields, field validators and the session
module Frame.State

-- | The state record
data Vars
Vars :: Fields -> Validators -> Bool -> Fields -> Bool -> Vars

-- | Posted fields
fields :: Vars -> Fields

-- | Field validation functions
validators :: Vars -> Validators

-- | Has a form been posted?
post :: Vars -> Bool

-- | Session fields
session :: Vars -> Fields

-- | Is this an AJAX request?
ajax :: Vars -> Bool
class (MonadStateGet Vars m, MonadStatePut Vars m) => FrameState m
class (MonadStateGet Vars m) => FrameReader m

-- | Provides get access to the state, mirroring Control.Monad.State.get
get :: (MonadStateGet s m) => m s

-- | Provides get access to the state, mirroring Control.Monad.State.put
put :: (MonadStatePut s m) => s -> m ()

-- | Gets a specific component from the state, using the supplied
--   projection function
gets :: (MonadStateGet s m) => (s -> a) -> m a

-- | A default empty start state
startState :: Vars
setPost :: (FrameState m) => Bool -> m ()

-- | Looks up a specific field in the state by the given field name
getField :: (FrameReader m) => FieldName -> m (Maybe WrapperType)

-- | Replaces the fields in the state
putFields :: (FrameState m) => Fields -> m ()

-- | Merges the given fields with the existing state (existing state fields
--   are favoured)
mergeFields :: (FrameState m) => Maybe Fields -> m ()

-- | Associate a value with a FieldName in the state
putField :: (FrameState m, FrameConfig m, Wrappable a) => FieldName -> a -> m ()

-- | Deletes a specific field in the state by the given field name
delField :: (FrameState m) => FieldName -> m ()

-- | Look up validators functions for a particular field
getValidator :: (FrameReader m) => FieldName -> m (Maybe [WrapperType -> Maybe String])

-- | Replaces the Validators in the state
putValidators :: (FrameState m) => Validators -> m ()

-- | Associate a set of validator functions with a FieldName in the state
putValidator :: (FrameState m) => FieldName -> [WrapperType -> Maybe String] -> m ()
instance (MonadStateGet Vars m) => FrameReader m
instance (MonadStateGet Vars m, MonadStatePut Vars m) => FrameState m
instance (Monad m) => MonadStatePut s (StateT s m)
instance (Monad m) => MonadStateGet s (StateT s m)


-- | High level model helpers
module Frame.Model
class (MonadIO m) => FrameIO m
class (FrameConfig m, FrameState m, FrameIO m) => FrameModel m
liftIO :: (MonadIO m) => forall a. IO a -> m a

-- | Convenience function for creating a qualified attribute name
fieldName :: String -> String -> String

-- | Get the name of a table.
tableName :: Table t -> TableName

-- | Convenience function for a stringed representation fo a table and
--   attribute
(-.-) :: Table r -> Attr f a -> String

-- | Execute a database function against the DB
run :: (FrameModel m) => (Database -> m a) -> m a

-- | Take the fields updated by some model action and merge them in to the
--   state
merge :: (FrameModel m) => m (Maybe Fields) -> m (Maybe Fields)
field :: (Wrappable a) => DBInfo -> FieldName -> a -> (FieldName, WrapperType)

-- | Should a form have been posted and all of the fields validate, run
--   some computation which maps fields to a model (with an empty return
--   type)
posted :: (FrameModel m) => (Fields -> m a) -> m Bool
wrapStringField :: (Size n) => FieldName -> BoundedList Char n -> (FieldName, WrapperType)
wrapIntField :: FieldName -> Int -> (FieldName, WrapperType)
wrapMaybeIntField :: FieldName -> Maybe Int -> (FieldName, WrapperType)
wrapBoolField :: FieldName -> Bool -> (FieldName, WrapperType)
instance (FrameConfig m, FrameState m, FrameIO m) => FrameModel m
instance (MonadIO m) => FrameIO m


-- | A subset of the GUI required to build a useful view
module Frame.GUI

-- | A generic GUI whose various instances define how it should be output
--   (e.g. Show outputs HTML).
data GUI

-- | A frame with a title, some style and a set of containers
Frame :: String -> [URL] -> [Container] -> GUI
class Composable a
(<+) :: (Composable a) => a -> Container -> a
(+>) :: (Composable a) => Container -> a -> a

-- | Contains various 'block level' elements
data Container

-- | Panel matches up with a div when output as HTML
Panel :: [Container] -> [Class] -> Container

-- | Paragraphs can only only contain elements
Paragraph :: [Element] -> [Class] -> Container

-- | Code
Code :: String -> Container

-- | Quote
Quote :: [Container] -> Container

-- | Header (int is size)
Header :: Int -> [Element] -> Container

-- | Lists contain list items
List :: [[Container]] -> [Class] -> Container

-- | Lists contain list items
NumList :: [[Container]] -> [Class] -> Container

-- | A form
Form :: [FormElement] -> [Class] -> Container

-- | Error pane
Error :: [Container] -> Container
Line :: Container
Empty :: Container
type Class = String

-- | A URL
type URL = String
data Element

-- | Plain element
Element :: Element' -> Element

-- | Element wrapped in a link
Link :: URL -> Element' -> Element

-- | Element wrapped in a link
Strong :: [Element] -> Element

-- | Element wrapped in a link
Emphasis :: [Element] -> Element

-- | Line break
Break :: Element
data Element'

-- | Textual element
Text :: String -> Element'

-- | Image element
Image :: URL -> String -> Element'

-- | A label
type Label = String
data FormElement

-- | For grouping elements
FormGroup :: [FormElement] -> Label -> FormElement

-- | Standard text box
TextField :: FieldName -> Label -> FormValue -> (Maybe Int) -> (Maybe Container) -> FormElement

-- | Hidden field
HiddenField :: FieldName -> FormValue -> FormElement

-- | Larger text box
TextArea :: FieldName -> Label -> FormValue -> (Maybe Container) -> FormElement

-- | Submit button
Button :: FieldName -> FormValue -> FormElement

-- | Special textual button
ButtonLink :: Label -> URL -> FormElement

-- | Form values are just wrapped types
type FormValue = WrapperType
instance Show FormElement
instance Show Element'
instance Show Element
instance Show Container
instance Composable Container
instance Show GUI
instance Composable GUI

module Frame.Data

-- | A collection of views which can be streamed to the client by the
--   server
data Data

-- | A full view
View :: GUI -> Data

-- | A partial view
ViewPart :: [Container] -> Data

-- | A file
File :: ByteString -> Data

-- | File not found, 404 HTTP response
Error404 :: Data

-- | Redirection
Redirect :: URL -> Data
instance Composable Data


-- | High level view helpers
module Frame.View
class (FrameConfig m, FrameReader m) => FrameView m

-- | Convenience function for a stringed representation fo a table and
--   attribute
(-.-) :: Table r -> Attr f a -> String

-- | The <a>title</a> function wraps a ViewPart in a View if not an Ajax
--   request
title :: (FrameView m) => String -> m Data -> m Data

-- | Abstract list generator
list :: (a -> Container) -> [a] -> [Class] -> Container

-- | Helper function for generating a potential error list
errorList :: [String] -> Maybe Container

-- | Creates element level text
text :: String -> Element

-- | Creates a link with just a text element
link :: URL -> String -> Element

-- | Generates a form based on a database description
formGen :: (FrameView m) => (Table r) -> [FormElement] -> [String] -> m Container

-- | Helper function to create a simple form with a single group
form :: Label -> [FormElement] -> [String] -> Container

-- | Helper function for creating a form field
formField :: FieldName -> Label -> FormValue -> Maybe Int -> [String] -> Bool -> FormElement

-- | Helper function for a submit button
submitButton :: FormElement

-- | Helper function for a delete link
deleteLink :: URL -> FormElement

-- | Helper function for a cancel link
cancelLink :: URL -> FormElement

-- | Helper function to create a single simple element paragraph
paragraph :: Element -> Container
instance (FrameConfig m, FrameReader m) => FrameView m


-- | Definitions and functions for building a router
module Frame.Router
class (FrameConfig m, FrameState m, FrameIO m) => FrameRouter m

-- | The <a>fileFolder</a> function maps a URL to a filesystem folder
fileFolder :: (FrameRouter m) => String -> [String] -> m Data

-- | A router maps from a path (list of URL parts) to some <a>Data</a>
type Router = [String] -> StateT Vars (ReaderT Config IO) Data

-- | Executes a given router and validators against request information
--   from the server
startRouter :: Router -> Config -> Validators -> [(FieldName, String)] -> String -> String -> Bool -> IO Data
instance (FrameConfig m, FrameState m, FrameIO m) => FrameRouter m


-- | Defines functions for state that can persist accross server requests
module Frame.Session

-- | Recovers a session from persistent storage
startSession :: (FrameRouter m) => m Fields

-- | Saves a session to persistent storage
saveSession :: (FrameRouter m) => m ()

-- | Deletes a session from persistent storage
deleteSession :: (FrameRouter m) => m ()

-- | A convenience function when running a router, starting and saving a
--   function before and after the router is run
withSession :: (FrameRouter m) => ([String] -> m a) -> ([String] -> m a)

-- | Generate a unique session ID
genSessionId :: IO String

-- | Get a field from the session by FieldName
getSessionField :: (FrameReader m) => FieldName -> m (Maybe WrapperType)

-- | Deletes a specific field in the session by the given field name
delSessionField :: (FrameState m) => FieldName -> m ()

-- | Copy a particular field to the session from the fields in the state
copyToSession :: (FrameState m) => FieldName -> m ()

-- | Copy a particular field to the session from the fields in the state
copyFromSession :: (FrameState m, FrameConfig m) => FieldName -> m ()

-- | Overwrite a message to be flashed to the screen (persisting across
--   requests)
updateFlash :: (FrameState m) => String -> m ()
getDelFlash :: (FrameState m) => m (Maybe String)

-- | Given a router, flashes the current message to screen before deleting
--   it
flash :: (FrameRouter m) => m Data -> m Data

module Frame.Server

-- | Start Frame using FastCGI
server :: Router -> Config -> Validators -> IO ()

-- | Start a test server
testServer :: Router -> Config -> Validators -> IO ()

module Frame

-- | Convenience function for a stringed representation fo a table and
--   attribute
(-.-) :: Table r -> Attr f a -> String
