-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Genetic programming library
--   
--   This package provides a <i>genetic programming</i> framework. Genetic
--   programming is an evolutionary technique, inspired by biological
--   evolution, to evolve programs for solving specific problems. A genetic
--   program is represented by a value of an algebraic datatype and
--   associated with a custom-defined <i>fitness</i> value indicating the
--   quality of the solution. Starting from a randomly generated initial
--   population of genetic programs, the genetic operators of
--   <i>selection</i>, <i>crossover</i>, and <i>mutation</i> are used to
--   evolve programs of increasingly better quality.
@package genprog
@version 0.1.0.2


-- | An interface to genetically programmable expressions.
module GenProg.GenExpr

-- | This typeclass defines an interface to expressions that can be
--   genetically programmed. The operations that must be provided by
--   instances of this class are used for the generation of random
--   individuals as well as crossover and mutation operations. (An instance
--   for members of the <tt>Data</tt> typeclass is provided in
--   <a>GenProg.GenExpr.Data</a>.)
--   
--   Minimal complete definition: <a>exchange</a>, <a>nodeMapM</a>,
--   <a>nodeMapQ</a>, and <a>nodeIndices</a>.
class GenExpr e where adjustM f e n = replace e n `liftM` f (get e n) where get e n = fst $ exchange e 0 e n replace e1 n1 e2 = fst $ exchange e1 n1 e2 0 nodes = (+ 1) . foldr (+) 0 . nodeMapQ nodes depth = (+ 1) . foldr max 0 . nodeMapQ depth
exchange :: GenExpr e => e -> Int -> e -> Int -> (e, e)
nodeMapM :: (GenExpr e, Monad m) => (e -> m e) -> e -> m e
nodeMapQ :: GenExpr e => (e -> a) -> e -> [a]
nodeIndices :: GenExpr e => e -> ([Int], [Int])
adjustM :: (GenExpr e, Monad m) => (e -> m e) -> e -> Int -> m e
nodes :: GenExpr e => e -> Int
depth :: GenExpr e => e -> Int


-- | Implementation of the <tt>GenProg.GenExpr</tt> interface for members
--   of the <a>Data</a> typeclass. The implementation is based on SYB and
--   SYZ generic programming frameworks (see
--   <a>http://hackage.haskell.org/package/syb</a> and
--   <a>http://hackage.haskell.org/package/syz</a> for details).
--   
--   NB: Subexpressions that are candidates for crossover points or
--   mutation must be of the same type as the expression itself, and must
--   be reachable from the root node by type-preserving traversal. See
--   below for an example.
module GenProg.GenExpr.Data

-- | This typeclass defines an interface to expressions that can be
--   genetically programmed. The operations that must be provided by
--   instances of this class are used for the generation of random
--   individuals as well as crossover and mutation operations. (An instance
--   for members of the <tt>Data</tt> typeclass is provided in
--   <a>GenProg.GenExpr.Data</a>.)
--   
--   Minimal complete definition: <a>exchange</a>, <a>nodeMapM</a>,
--   <a>nodeMapQ</a>, and <a>nodeIndices</a>.
class GenExpr e where adjustM f e n = replace e n `liftM` f (get e n) where get e n = fst $ exchange e 0 e n replace e1 n1 e2 = fst $ exchange e1 n1 e2 0 nodes = (+ 1) . foldr (+) 0 . nodeMapQ nodes depth = (+ 1) . foldr max 0 . nodeMapQ depth
exchange :: GenExpr e => e -> Int -> e -> Int -> (e, e)
nodeMapM :: (GenExpr e, Monad m) => (e -> m e) -> e -> m e
nodeMapQ :: GenExpr e => (e -> a) -> e -> [a]
nodeIndices :: GenExpr e => e -> ([Int], [Int])
adjustM :: (GenExpr e, Monad m) => (e -> m e) -> e -> Int -> m e
nodes :: GenExpr e => e -> Int
depth :: GenExpr e => e -> Int
instance Data a => GenExpr a


-- | The Genetic Programming Library.
--   
--   <i>Genetic programming</i> is an evolutionary optimization technique
--   inspired by biological evolution. It is similar to <i>genetic
--   algorithms</i> except that the individual solutions are programs (or,
--   more generally, <i>expressions</i>) representing a solution to a given
--   problem. A genetic program is represented as an <i>abstract syntax
--   tree</i> and associated with a custom-defined <i>fitness</i> value
--   indicating the quality of the solution. Starting from a randomly
--   generated initial population of genetic programs, the genetic
--   operators of <i>selection</i>, <i>crossover</i>, and (occasionally)
--   <i>mutation</i> are used to evolve programs of increasingly better
--   quality.
--   
--   Standard reference is: John Koza. <i>Genetic programming:</i> <i>On
--   the Programming of Computers by Means of Natural Selection</i>. MIT
--   Press, 1992.
--   
--   In GenProg, a genetic program is represented by a value of an
--   algebraic datatype. To use a datatype as a genetic program, it
--   suffices to define it as an instance of the <a>GenProg</a> typeclass.
--   A custom datatype can be made an instance of the <a>GenProg</a>
--   typeclass, provided it is an instance of the <tt>Data</tt> typeclass
--   (see <a>GenProg.GenExpr.Data</a>).
--   
--   An example of how to use this library is given below.
module GenProg

-- | A typeclass defining a genetic program interface. Datatypes <tt>e</tt>
--   that are to be used as genetic programs must be instances of the
--   <a>GenExpr</a> typeclass and must implement this interface.
class (Eq e, GenExpr e, MonadRandom m) => GenProg m e | e -> m
terminal :: GenProg m e => m e
nonterminal :: GenProg m e => m e

-- | Generates a random expression fully expanded to the specified depth.
generateFullExpr :: GenProg m e => Int -> m e

-- | Generates a random expression of limited depth. The maximum depth of
--   the resulting expression may be less than the specified depth limit,
--   and paths may be of different length.
generateGrownExpr :: GenProg m e => Int -> m e

-- | The depth of an expression. Equals 1 for single-node expressions.
depth :: GenExpr e => e -> Int

-- | Number of nodes an expression has.
nodes :: GenExpr e => e -> Int

-- | A genetically programmed individual, representing a basic unit of
--   evolution. (Basically a wrapper around a genetically programmable
--   expression.)
data Ind e

-- | Returns the expression wrapped by an individual.
unInd :: Ind e -> e

-- | Wraps an expression into an individual.
mkInd :: GenProg m e => Fitness e -> e -> Ind e

-- | Adjusted fitness of an individual. Adjusted fitness equals
--   <tt>1/(1+s)</tt>, where <tt>s</tt> is the standardized fitness as
--   computed by <a>fitness</a>. To reduce computational costs, this value
--   is computed only once and then cached.
aFitness :: Ind e -> Double

-- | Standardized fitness of an individual as computed by <a>fitness</a>
sFitness :: Ind e -> Double

-- | A population of individuals. (Basically a wrapper around a list of
--   individuals.)
data Pop e

-- | Unwraps a population.
unPop :: Pop e -> [Ind e]

-- | Wraps a list of individuals into a population.
mkPop :: [Ind e] -> Pop e

-- | Generate population of given size and given depth limit using
--   <i>ramped half-and-half</i> method (Koza, 1992): for each depth value
--   from 0 to the initial depth limit <a>iDepth</a>, 50% of individuals
--   are generated using <a>generateFullExpr</a> and 50% are generated
--   using <a>generateGrownExpr</a>. Afterwards, duplicates are removed,
--   thus the size of the resulting population may actually be less than
--   the specified size.
generatePop :: GenProg m e => EvolParams m e -> m (Pop e)

-- | Replenishes a population up to <a>popSize</a> by randomly generating
--   new individuals.
replenishPop :: GenProg m e => EvolParams m e -> Pop e -> m (Pop e)

-- | Merges two populations by taking <a>popSize</a> best-fitted
--   individuals from the union of the two populations.
mergePop :: GenProg m e => EvolParams m e -> Pop e -> Pop e -> Pop e

-- | Population's best-fitted individual.
best :: Pop e -> Ind e

-- | Population's average standardized fitness.
avgFitness :: Pop e -> Double

-- | Average depth of expressions in the population.
avgDepth :: GenProg m e => Pop e -> Double

-- | Average number of expression nodes in the population.
avgNodes :: GenProg m e => Pop e -> Double

-- | Crossover operation of two individuals, resulting in two offsprings.
--   Crossover is performed by choosing at random two nodes in each
--   expressions, and then by exchanging the subexpressions rooted at these
--   nodes between the two individuals. The probability that an internal
--   (functional) node is chosen as crossover point is set by the
--   <a>ciProb</a> parameter in <a>EvolParams</a>, whereas the probability
--   that an external (terminal) node is chosen equals <tt>1-ciProb</tt>.
--   Among internal and external nodes, nodes are chosen uniformly at
--   random. If the depth of a created offspring exceeds the depth limit
--   <a>cDepth</a> specified by evolution parameters <a>EvolParams</a>,
--   that offspring is discarded and a parent is reproduced (i.e., copied
--   as-is).
crossoverInd :: GenProg m e => EvolParams m e -> Ind e -> Ind e -> m (Ind e, Ind e)

-- | Mutates an individual by applying the mutation function
--   <tt>mutate</tt> to a randomly selected node. The probability that an
--   internal (functional) node is chosen for muration is set by the
--   <a>miProb</a> parameter in <a>EvolParams</a>, whereas the probability
--   that an external (terminal) node is chosen equals <tt>1-miProb</tt>.
--   Among internal and external nodes, nodes are chosen uniformly at
--   random. If the depth of the mutated expression exceeds the depth limit
--   <a>cDepth</a> specified by evolution parameters <a>EvolParams</a>, the
--   individual is left unaltered.
mutateInd :: GenProg m e => EvolParams m e -> Ind e -> m (Ind e)

-- | Applies crossover to two randomly chosen individuals from a
--   population. The probability of an individual being chosen as parent is
--   fitness-proportionate (individuals with better fitness have better
--   chanches of being chosen for crossover).
crossoverPop :: GenProg m e => EvolParams m e -> Pop e -> m (Ind e, Ind e)

-- | Applies mutation operation to individuals from a population. The
--   probability of mutating each individual is determined by <a>mProb</a>
--   parameter from <tt>EvalParams</tt>.
mutatePop :: GenProg m e => EvolParams m e -> Pop e -> m (Pop e)

-- | The state of the evolution.
data EvolState e
EvolState :: Pop e -> Int -> Ind e -> EvolState e

-- | Current population.
pop :: EvolState e -> Pop e

-- | Iteration (current generation number).
iter :: EvolState e -> Int

-- | Best individual evolved so far.
cachedBest :: EvolState e -> Ind e

-- | Standardized fitness. It takes on values from 0 (best fitness) to
--   +infinity (worst fitness).
type Fitness e = e -> Double

-- | A function to mutate a chosen expression node.
type Mutate m e = e -> m e

-- | Default mutation. Replaces a node, irrespective of its value, with a
--   randomly generated subexpression whose depth is limited to
--   <a>iDepth</a>.
defaultMutation :: GenProg m e => EvolParams m e -> Mutate m e

-- | Termination predicate.
type Terminate e = EvolState e -> Bool

-- | Termination predicate: terminate if any individual satisfies the
--   specified predicate.
tSuccess :: (e -> Bool) -> Terminate e

-- | Termination predicate: terminate if best individual's standardized
--   fitness is greater than or equal to the specified value.
tFitness :: GenProg m e => Double -> Terminate e

-- | Termination predicate: terminate after running for the specified
--   number of iterations.
tGeneration :: Int -> Terminate e

-- | Parameters governing the evolution.
--   
--   Default evolution parameters, as used in (Koza, 1992), are defined by
--   <a>defaultEvolParams</a> and indicated below. At least the fitness
--   function <a>fitness</a> should be overriden.
data EvolParams m e
EvolParams :: Int -> Int -> Int -> Double -> Double -> Double -> Double -> Fitness e -> Mutate m e -> Int -> Terminate e -> EvolParams m e

-- | Population size (number of individuals). Default is <tt>500</tt>.
popSize :: EvolParams m e -> Int

-- | Depth of expressions in initial population. Default is <tt>6</tt>.
iDepth :: EvolParams m e -> Int

-- | Maximum depth of expressions created during the evolution. Default is
--   <tt>17</tt>.
cDepth :: EvolParams m e -> Int

-- | Probability of crossover. Default is <tt>0.9</tt>. If crossover is not
--   chosen, an individual is simply reproduced (copied as-is) into the
--   next generation.
cProb :: EvolParams m e -> Double

-- | Probability that an internal (functional) node is chosen as a
--   crossover point. Default is <tt>0.9</tt>. If an internal node is not
--   chosen, an external (terminal) node is chosen.
ciProb :: EvolParams m e -> Double

-- | Probability that an individual gets mutated. Default is <tt>0</tt> (no
--   mutation).
mProb :: EvolParams m e -> Double

-- | Probability that an internal (functional) node is chosen for mutation.
--   Default is <tt>0.1</tt>.
miProb :: EvolParams m e -> Double

-- | Standardized fitness function. Default value is <tt>undefined</tt>
--   (must be overriden).
fitness :: EvolParams m e -> Fitness e

-- | Mutation function. Defines how to change a randomly chosen node.
--   Default is <tt>defaultMutation defaultEvolParams</tt> (replacement of
--   a chosen node with a randomly generated subexpression).
mutate :: EvolParams m e -> Mutate m e

-- | Elitist factor: number of best-fitted individuals that are preserved
--   from each generation (reproduced as-is into next evolution state).
--   Default is <tt>0</tt>.
elitists :: EvolParams m e -> Int

-- | Termination predicate. Default is <tt>50</tt> (terminate after 50
--   generations).
terminate :: EvolParams m e -> Terminate e
defaultEvolParams :: GenProg m e => EvolParams m e

-- | Creates an initial population and evolves it until termination
--   predicate is satisfied, returning the last evolution state.
evolve :: GenProg m e => EvolParams m e -> m (EvolState e)

-- | Evolves a given initial population until termination predicate is
--   satisfied, returning the last evolution state. If the size of the
--   initial population is less than <a>popSize</a>, the population will be
--   replenished (see <a>replenishPop</a>).
evolveFrom :: GenProg m e => EvolParams m e -> Pop e -> m (EvolState e)

-- | Creates an initial population and runs evolution until termination
--   predicate is satisfied. Returns a list of successive evolution states.
evolveTrace :: GenProg m e => EvolParams m e -> m [EvolState e]

-- | Runs evolution on a given initial population until termination
--   predicate is satisfied and returns a list of successive evolution
--   states. If the size of the initial population is less than
--   <a>popSize</a>, the population will be replenished (see
--   <a>replenishPop</a>).
evolveTraceFrom :: GenProg m e => EvolParams m e -> Pop e -> m [EvolState e]
instance Show e => Show (Ind e)
instance Show e => Show (Pop e)
instance Eq e => Eq (Pop e)
instance Show e => Show (EvolState e)
instance Eq e => Eq (EvolState e)
instance Eq e => Ord (Ind e)
instance Eq e => Eq (Ind e)
