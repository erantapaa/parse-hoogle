-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Reflect exceptions using phantom types.
--   
@package tagged-exception-core
@version 2.0.0.0


-- | Data type for associating monadic value with phantom type. In case of
--   this library it will always be associated with a type of exception it
--   may throw.
module Control.Monad.TaggedException.Internal.Throws

-- | Exception tag.
newtype Throws e m a
Throws :: m a -> Throws e m a

-- | Hide one exception.
hideException :: Throws e m a -> m a

-- | Lift <tt>mask</tt> operation in to <a>Throws</a> context.
liftMask :: (((forall a. m a -> m a) -> m b) -> m b) -> ((forall a. Throws e m a -> Throws e m a) -> Throws e m b) -> Throws e m b
instance Typeable Throws
instance Generic (Throws e m a)
instance Datatype D1Throws
instance Constructor C1_0Throws
instance Selector S1_0_0Throws
instance MonadMask m => MonadMask (Throws e m)
instance MonadCatch m => MonadCatch (Throws e m)
instance MonadThrow m => MonadThrow (Throws e m)
instance MMonad (Throws e)
instance MFunctor (Throws e)
instance MonadTrans (Throws e)
instance MonadIO m => MonadIO (Throws e m)
instance MonadPlus m => MonadPlus (Throws e m)
instance Monad m => Monad (Throws e m)
instance Alternative f => Alternative (Throws e f)
instance Applicative f => Applicative (Throws e f)
instance Functor f => Functor (Throws e f)


-- | Unsafe exception tag cobinators and specific lifting functions. Import
--   this module if creating new <tt>MonadException</tt> instance(s) that
--   can not be created otherwise.
--   
--   Preferably import as:
--   
--   <pre>
--   import qualified Control.Monad.TaggedException.Unsafe as Unsafe
--   </pre>
module Control.Monad.TaggedException.Unsafe

-- | Exception tag.
data Throws e m a

-- | Construct exception tag, but without <a>MonadThrow</a> restriction.
throwsOne :: m a -> Throws e m a

-- | Shorthand for <tt><a>throwsOne</a> . <a>throwsOne</a></tt>.
throwsTwo :: m a -> Throws e' (Throws e m) a

-- | Shorthand for <tt><a>throwsOne</a> . <a>throwsOne</a> .
--   <a>throwsOne</a></tt>.
throwsThree :: m a -> Throws e'' (Throws e' (Throws e m)) a

-- | Hide one exceptions, but without <a>MonadThrow</a> restriction.
hideOne :: Throws e m a -> m a

-- | Hide two exceptions, but without <a>MonadThrow</a> restriction.
hideTwo :: Throws e (Throws e' m) a -> m a

-- | Hide three exceptions, but without <a>MonadThrow</a> restriction.
hideThree :: Throws e (Throws e' (Throws e'' m)) a -> m a

-- | <tt>liftT</tt> for functions with arity one. Isn't restricted just to
--   <a>MonadThrow</a> instances.
liftT1 :: (m a -> m b) -> Throws e m a -> Throws e m b

-- | <tt>liftT</tt> for functions with arity two. Isn't restricted just to
--   <a>MonadThrow</a> instances.
liftT2 :: (m a -> m b -> m c) -> Throws e m a -> Throws e m b -> Throws e m c

-- | <tt>liftT</tt> for functions with arity three. Isn't restricted just
--   to <a>MonadThrow</a> instances.
liftT3 :: (m a -> m b -> m c -> m d) -> Throws e m a -> Throws e m b -> Throws e m c -> Throws e m d

-- | Generalized <tt>liftT</tt>.
insideT :: (m a -> m' b) -> Throws e m a -> Throws e m' b

-- | Variant <a>insideT</a>.
insideTf :: Functor f => (f (m a) -> m' b) -> f (Throws e m a) -> Throws e m' b

-- | Variant <a>insideT</a>.
insideTf2 :: (Functor f, Functor f') => (f (f' (m a)) -> m' b) -> f (f' (Throws e m a)) -> Throws e m' b

-- | Generalized <a>liftT2</a>.
insideT2 :: (m1 a -> m2 b -> m3 c) -> Throws e m1 a -> Throws e m2 b -> Throws e m3 c

-- | Generalized <a>liftT3</a>.
insideT3 :: (m1 a -> m2 b -> m3 c -> m4 d) -> Throws e m1 a -> Throws e m2 b -> Throws e m3 c -> Throws e m4 d

-- | Join two exception tags in to one. Isn't restricted just to
--   <a>MonadThrow</a> instances.
joinT :: Throws e (Throws e m) a -> Throws e m a

-- | Join three exception tags in to one. Isn't restricted just to
--   <a>MonadThrow</a> instances.
joinT3 :: Throws e (Throws e (Throws e m)) a -> Throws e m a

-- | Flip two outermost exception tags. Isn't restricted just to
--   <a>MonadThrow</a> instances.
flipT :: Throws e' (Throws e m) a -> Throws e (Throws e' m) a

-- | Since <tt>1.2.0.0</tt>.
embedT :: (m a -> Throws e n b) -> Throws e m a -> Throws e n b

-- | Lift <tt>mask</tt> operation in to <a>Throws</a> context.
liftMask :: (((forall a. m a -> m a) -> m b) -> m b) -> ((forall a. Throws e m a -> Throws e m a) -> Throws e m b) -> Throws e m b

-- | Lift operations with type similar to monadic bind. In example:
--   
--   <pre>
--   (<a>&gt;&gt;=</a>) :: <a>Monad</a> m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
--   </pre>
--   
--   <pre>
--   <a>catch</a>
--       :: <a>IO</a> a
--       -&gt; (<a>IOError</a> -&gt; <a>IO</a> a)
--       -&gt; <a>IO</a> a
--   </pre>
--   
--   <pre>
--   <a>catch</a>
--       :: <a>Exception</a> e
--       =&gt; <a>IO</a> a -&gt; (e -&gt; <a>IO</a> a) -&gt; <a>IO</a> a
--   </pre>
--   
--   Since <tt>1.2.0.0</tt>.
liftBindLike :: (m a -> (b -> m c) -> m d) -> Throws e m a -> (b -> Throws e m c) -> Throws e m d

-- | Lift operations with type similar to flipped monadic bind. In example:
--   
--   <pre>
--   (<a>=&lt;&lt;</a>) :: <a>Monad</a> m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
--   </pre>
--   
--   <pre>
--   <a>handle</a>
--       :: <a>Exception</a> e
--       =&gt; (e -&gt; <a>IO</a> a) -&gt; <a>IO</a> a -&gt; <a>IO</a> a
--   </pre>
--   
--   Since <tt>1.2.0.0</tt>.
liftFlipBindLike :: ((a -> m b) -> m c -> m d) -> (a -> Throws e m b) -> Throws e m c -> Throws e m d

-- | Lift klieisli composition like operations. In example:
--   
--   <pre>
--   (<a>&gt;=&gt;</a>)
--       :: <a>Monad</a> m =&gt; (a -&gt; m b) -&gt; (b -&gt; m c) -&gt; a -&gt; m c
--   </pre>
--   
--   <pre>
--   (<a>&lt;=&lt;</a>)
--       :: <a>Monad</a> m =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; a -&gt; m c
--   </pre>
--   
--   Since <tt>1.2.0.0</tt>.
liftKleisliLike :: ((a -> m a') -> (b -> m b') -> c -> m c') -> (a -> Throws e m a') -> (b -> Throws e m b') -> c -> Throws e m c'


module Control.Monad.TaggedException.Hidden

-- | Class for exception that can be removed from the type signature.
--   Default implementation for <a>hideException</a> method is provided.
class Exception e => HiddenException e where hideException = hideException
hideException :: (HiddenException e, MonadThrow m) => Throws e m a -> m a

-- | Map exception before hiding it.
--   
--   This is the preferred way to do exception hiding, by mapping it in to
--   a different exception that better describes its fatality.
hideWith :: (Exception e, HiddenException e', MonadCatch m) => (e -> e') -> Throws e m a -> m a

-- | Throw exceptions and then disregard type tag.
throwHidden :: (HiddenException e, MonadThrow m) => e -> m a

-- | Alias for <tt>throwHidden</tt>.
throw' :: (HiddenException e, MonadThrow m) => e -> m a
instance HiddenException ExitCode
instance HiddenException SomeException
instance HiddenException SomeAsyncException
instance HiddenException RecUpdError
instance HiddenException RecSelError
instance HiddenException RecConError
instance HiddenException PatternMatchFail
instance HiddenException NonTermination
instance HiddenException NoMethodError
instance HiddenException NestedAtomically
instance HiddenException IOException
instance HiddenException ErrorCall
instance HiddenException Deadlock
instance HiddenException BlockedIndefinitelyOnSTM
instance HiddenException BlockedIndefinitelyOnMVar
instance HiddenException AsyncException
instance HiddenException AssertionFailed
instance HiddenException ArrayException
instance HiddenException ArithException
instance HiddenException Dynamic


-- | Core functionality.
module Control.Monad.TaggedException.Core

-- | Throw an exception. To raise an "inner" exception following can be
--   used:
--   
--   <pre>
--   <a>liftT</a> . <a>throw</a>
--       :: (<a>MonadCatch</a> m, <a>Exception</a> e, <a>Exception</a> e')
--       =&gt; e
--       -&gt; <a>Throws</a> e' (<a>Throws</a> e m) a
--   </pre>
throw :: (Exception e, MonadThrow m) => e -> Throws e m a

-- | Catch exception.
--   
--   To catch inner exception following construct can be used:
--   
--   <pre>
--   <a>catch</a> . <a>flipT</a>
--       :: (<a>Exception</a> e, <a>Exception</a> e', <a>MonadCatch</a> m)
--       =&gt; <a>Throws</a> e' (<a>Throws</a> e m) a
--       -&gt; (e -&gt; <a>Throws</a> e' m a)
--       -&gt; <a>Throws</a> e' m a
--   </pre>
catch :: (Exception e, MonadCatch m) => Throws e m a -> (e -> m a) -> m a

-- | Catch any exception.
catch' :: (Exception e, MonadCatch m) => m a -> (e -> m a) -> m a

-- | Flipped version of <a>catch</a>. Usage example:
--   
--   <pre>
--   foo = <a>handle</a> exceptionHandler $ do
--       ...
--     where exceptionHandler = ...
--   </pre>
--   
--   Handle "inner" exception:
--   
--   <pre>
--   <a>insideT</a> . <a>handle</a>
--       :: (<a>MonadCatch</a> m, <a>Exception</a> e, <a>Exception</a> e')
--       =&gt; (e' -&gt; m a)
--       -&gt; <a>Throws</a> e (<a>Throws</a> e' m) a
--       -&gt; <a>Throws</a> e m a
--   </pre>
handle :: (Exception e, MonadCatch m) => (e -> m a) -> Throws e m a -> m a

-- | Flipped version of <a>catch'</a>
handle' :: (Exception e, MonadCatch m) => (e -> m a) -> m a -> m a

-- | Similar to <a>catch</a>, but returns <a>Either</a> exception or
--   result.
--   
--   Inner try:
--   
--   <pre>
--   <a>try</a> . <a>flipT</a>
--       :: (<a>Exception</a> e, <a>Exception</a> e', MonadCatch m)
--       =&gt; <a>Throws</a> e' (<a>Throws</a> e m) a
--       -&gt; <a>Throws</a> e' m (<a>Either</a> e a)
--   </pre>
try :: (Exception e, MonadCatch m) => Throws e m a -> m (Either e a)

-- | Map one exception to another.
--   
--   Mapping "inner" exception has generally two forms:
--   
--   1. Modifying raised exception, but not changing its type:
--   
--   <pre>
--   <a>liftT1</a> . <a>mapException</a>
--       :: (<a>Exception</a> e, <a>Exception</a> e', <a>MonadCatch</a> m)
--       =&gt; (e -&gt; e)
--       -&gt; <a>Throws</a> e' (<a>Throws</a> e m) a
--       -&gt; <a>Throws</a> e' (<a>Throws</a> e m) a
--   </pre>
--   
--   2. Modifying raised exception, including its type:
--   
--   <pre>
--   <a>insideT</a> . <a>mapException</a>
--       :: (<a>Exception</a> e, <a>Exception</a> e1, <a>Exception</a> e2, <a>MonadCatch</a> m)
--       =&gt; (e1 -&gt; e2)
--       -&gt; <a>Throws</a> e (<a>Throws</a> e1 m) a
--       -&gt; <a>Throws</a> e (<a>Throws</a> e2 m) a
--   </pre>
--   
--   Unhiding exception by mapping it in to a different type of exception:
--   
--   <pre>
--   \f -&gt; <a>mapException</a> f . <a>liftT</a>
--       :: (<a>Exception</a> e, <a>Exception</a> e', <a>MonadCatch</a> m)
--       =&gt; (e -&gt; e')
--       -&gt; m a
--       -&gt; <a>Throws</a> e' m a
--   </pre>
mapException :: (Exception e, Exception e', MonadCatch m) => (e -> e') -> Throws e m a -> Throws e' m a

-- | Run computation if exception was raised. Basically:
--   
--   <pre>
--   m ``onException`` n = <a>liftT</a> m ``catch`` \e -&gt; <a>liftT</a> n &gt;&gt; <a>throw</a> e
--   </pre>
onException :: (Exception e, MonadCatch m) => Throws e m a -> m b -> Throws e m a

-- | Same as <a>onException</a>, but uses <a>catch'</a> and so second
--   computation is executed if any exception is raised.
onException' :: MonadCatch m => m a -> m b -> m a

-- | Exception tag.
data Throws e m a

-- | Construct exception tag, with type restrictions.
--   
--   Reflect raised exception in function's type:
--   
--   <pre>
--   import Control.Monad.TaggedException (Throws, liftT)
--   import System.IO (Handle, IOMode)
--   import qualified System.IO as IO (openFile)
--   
--   
--   openFile :: FilePath -&gt; IOMode -&gt; Throws IOError IO Handle
--   openFile = (liftT .) . IO.openFile
--   </pre>
--   
--   Lifting <tt>m</tt> to <tt><a>Throws</a> e m</tt>:
--   
--   <pre>
--   import Control.Exception (Exception)
--   
--   import Control.Monad.TaggedException (Throws, liftT, throw)
--   import Data.Typeable (Typeable)
--   
--   
--   data EmptyString = EmptyString
--       deriving (Show, Typeable)
--   
--   instance Exception EmptyString
--   
--   writeIfNotEmpty
--       :: FilePath
--       -&gt; String
--       -&gt; Throws EmptyString IO ()
--   writeIfNotEmpty filename str = do
--       when (null str) $ throw EmptyString
--       liftT $ writeFile filename str
--   </pre>
--   
--   We have a some commonly used patterns:
--   
--   <pre>
--   (<a>liftT</a> .)
--       :: (<a>Exception</a> e, <a>MonadThrow</a> m)
--       =&gt; (a -&gt; m b)
--       -&gt; a -&gt; <a>Throws</a> e m b
--   </pre>
--   
--   Above is also usable for lifting throw-like functions:
--   
--   <pre>
--   import Control.Monad.Trans.Class (MonadTrans(lift))
--   
--   ((<a>liftT</a> . <a>lift</a>) .)
--       ::  ( <a>Exception</a> e
--           , <a>MonadThrow</a> m
--           , <a>MonadThrow</a> (t m)
--           , <a>MonadTrans</a> t)
--       =&gt; (a -&gt; m b)
--       -&gt; a -&gt; <a>Throws</a> e (t m) b
--   </pre>
liftT :: (Exception e, MonadThrow m) => m a -> Throws e m a

-- | Shorthand for <tt><a>liftT</a> . <a>liftT</a></tt>.
lift2T :: (Exception e, Exception e', MonadThrow m) => m a -> Throws e' (Throws e m) a

-- | Shorthand for <tt><a>liftT</a> . <a>liftT</a> . <a>liftT</a></tt>.
lift3T :: (Exception e, Exception e', Exception e'', MonadThrow m) => m a -> Throws e'' (Throws e' (Throws e m)) a

-- | <a>liftT</a> for functions with arity one.
liftT1 :: (Exception e, MonadThrow m) => (m a -> m b) -> Throws e m a -> Throws e m b

-- | <a>liftT</a> for functions with arity two.
liftT2 :: (Exception e, MonadThrow m) => (m a -> m b -> m c) -> Throws e m a -> Throws e m b -> Throws e m c

-- | <a>liftT</a> for functions with arity three.
liftT3 :: (Exception e, MonadThrow m) => (m a -> m b -> m c -> m d) -> Throws e m a -> Throws e m b -> Throws e m c -> Throws e m d

-- | Join two outermost exception tags.
joinT :: (Exception e, MonadThrow m) => Throws e (Throws e m) a -> Throws e m a

-- | Join three outermost exception tags.
joinT3 :: (Exception e, MonadThrow m) => Throws e (Throws e (Throws e m)) a -> Throws e m a

-- | Flip two outermost exception tags.
flipT :: (Exception e, Exception e', MonadThrow m) => Throws e' (Throws e m) a -> Throws e (Throws e' m) a

-- | Generalized <a>liftT</a>. Usage examples:
--   
--   <pre>
--   <a>insideT</a> lift
--      :: (<a>MonadThrow</a> (t m), <a>MonadThrow</a> m, <a>Exception</a> e, MonadTrans t)
--      =&gt; <a>Throws</a> e m b
--      -&gt; <a>Throws</a> e (t m) b
--   </pre>
--   
--   This is variation on the first example that explicitly lifts monad:
--   
--   <a>insideT</a> WriterT :: (<a>Exception</a> e, <a>MonadThrow</a> m,
--   Monoid w) =&gt; <a>Throws</a> e m (b, w) -&gt; <a>Throws</a> e
--   (WriterT w m) b
--   
--   Some useful compositions of exception tag combinators:
--   
--   <pre>
--   <a>insideT</a> <a>flipT</a>
--       :: (<a>Exception</a> e0, <a>Exception</a> e1, <a>Exception</a> e2, <a>MonadThrow</a> m)
--       =&gt; <a>Throws</a> e0 (<a>Throws</a> e1 (<a>Throws</a> e2 m)) a
--       -&gt; <a>Throws</a> e0 (<a>Throws</a> e2 (<a>Throws</a> e1 m)) a
--   </pre>
--   
--   <pre>
--   <a>flipT</a> . <a>insideT</a> <a>flipT</a>
--       :: (<a>Exception</a> e0, <a>Exception</a> e1, <a>Exception</a> e2, <a>MonadThrow</a> m)
--       =&gt; <a>Throws</a> e0 (<a>Throws</a> e1 (<a>Throws</a> e2 m)) a
--       -&gt; <a>Throws</a> e2 (<a>Throws</a> e0 (<a>Throws</a> e1 m)) a
--   </pre>
insideT :: (Exception e, MonadThrow m, MonadThrow m') => (m a -> m' b) -> Throws e m a -> Throws e m' b

-- | Generalized <a>liftT2</a>.
insideT2 :: (Exception e, MonadThrow m1, MonadThrow m2, MonadThrow m3) => (m1 a -> m2 b -> m3 c) -> Throws e m1 a -> Throws e m2 b -> Throws e m3 c

-- | Generalized <a>liftT3</a>.
insideT3 :: (Exception e, MonadThrow m1, MonadThrow m2, MonadThrow m3, MonadThrow m4) => (m1 a -> m2 b -> m3 c -> m4 d) -> Throws e m1 a -> Throws e m2 b -> Throws e m3 c -> Throws e m4 d

-- | Variant of <a>insideT</a>.
--   
--   Usage example:
--   
--   <pre>
--   <a>insideTf</a> StateT
--       :: (<a>Exception</a> e, <a>MonadThrow</a> m)
--       =&gt; (s -&gt; <a>Throws</a> e m (a, s))
--       -&gt; <a>Throws</a> e (StateT s m) a
--   </pre>
insideTf :: (Exception e, Functor f, MonadThrow m, MonadThrow m') => (f (m a) -> m' b) -> f (Throws e m a) -> Throws e m' b

-- | Variant of <a>insideT</a>.
--   
--   Usage example:
--   
--   <pre>
--   <a>insideTf2</a> RWST
--       :: (<a>Exception</a> e, <a>MonadThrow</a> m)
--       =&gt; (r -&gt; s -&gt; <a>Throws</a> e m (a, s, w))
--       -&gt; <a>Throws</a> e (RWST r w s m) a
--   </pre>
insideTf2 :: (Exception e, Functor f, Functor f', MonadThrow m, MonadThrow m') => (f (f' (m a)) -> m' b) -> f (f' (Throws e m a)) -> Throws e m' b

-- | Since <tt>1.2.0.0</tt>
embedT :: (Exception e, MonadThrow m, MonadThrow m') => (m a -> Throws e m' b) -> Throws e m a -> Throws e m' b


-- | Introduces <tt>MonadExceptionUtilities</tt> type class that provides
--   means for overriding default implementation of functions like
--   <a>bracket</a>.
module Control.Monad.TaggedException.Utilities

-- | Run computation surrounded by acquire and release computations. The
--   release computation is executed even if "in-between" computation
--   raises exception. See also <a>bracket'</a>, <a>bracket_</a>,
--   <a>bracketOnError</a>, and <a>bracketOnError'</a>.
bracket :: (Exception e, MonadMask m) => m a -> (a -> m b) -> (a -> Throws e m c) -> Throws e m c

-- | Run computation surrounded by acquire and release computations. The
--   release computation is executed even if "in-between" computation
--   raises exception. See also <a>bracket</a>, <a>bracket_</a>,
--   <a>bracketOnError</a>, and <a>bracketOnError'</a>.
--   
--   Default implementation:
--   
--   <pre>
--   bracket' acq rel go = mask' $ \ restore -&gt; do
--       x &lt;- acq
--       r &lt;- restore (go x) `onException'` rel x
--       _ &lt;- rel x
--       return r
--   </pre>
bracket' :: MonadMask m => m a -> (a -> m b) -> (a -> m c) -> m c

-- | Variant of <a>bracket</a>.
--   
--   <pre>
--   bracket_ acq rel go = bracket acq (const rel) (const go)
--   </pre>
bracket_ :: (Exception e, MonadMask m) => m a -> m b -> Throws e m c -> Throws e m c

-- | Version of <a>bracket</a> where "after" computation is executed only
--   if "in-between" computation raises exception.
--   
--   Default implementation:
--   
--   <pre>
--   bracketOnError acq rel go = mask $ \ restore -&gt; do
--       x &lt;- liftT acq
--       restore (go x) `onException` rel x
--   </pre>
bracketOnError :: (Exception e, MonadMask m) => m a -> (a -> m b) -> (a -> Throws e m c) -> Throws e m c

-- | Version of <a>bracket</a> where "after" computation is executed only
--   if "in-between" computation raises exception.
--   
--   Default implementation:
--   
--   <pre>
--   bracketOnError' acq rel go = mask' $ \ restore -&gt; do
--       x &lt;- liftT acq
--       restore (go x) `onException'` rel x
--   </pre>
bracketOnError' :: MonadMask m => m a -> (a -> m b) -> (a -> m c) -> m c

-- | Run computation afeter another even if exception was thrown. See also
--   <a>finally'</a>, <a>onException</a> and <a>onException'</a>.
--   
--   Default implementation:
--   
--   <pre>
--   m `finally` n = mask $ \ restore -&gt; do
--       r &lt;- restore m `onException` n
--       _ &lt;- liftT n
--       return r
--   </pre>
finally :: (Exception e, MonadMask m) => Throws e m a -> m b -> Throws e m a

-- | Run computation afeter another even if exception was thrown. See also
--   <a>finally</a>, <a>onException</a> and <a>onException'</a>.
finally' :: MonadMask m => m a -> m b -> m a


module Control.Monad.TaggedException
