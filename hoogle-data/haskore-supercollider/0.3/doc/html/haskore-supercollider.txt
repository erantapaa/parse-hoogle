-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskore back-end for SuperCollider
--   
@package haskore-supercollider
@version 0.3


-- | Bookkeeping of SuperCollider channels
module Haskore.Interface.SuperCollider.Channel
type Channel = Int
type NumberChannels = Int

-- | We reserve the first two channels for the stereo output. We must not
--   use them for instruments. This is too unflexible and will certainly
--   change in the future.
least :: Channel
data T m
Cons :: (NumberChannels -> m Channel) -> m () -> T m
next :: T m -> NumberChannels -> m Channel
reset :: T m -> m ()
readUGen :: NumberChannels -> Channel -> UGen
writeUGen :: Channel -> UGen -> UGen


-- | An instance of <a>T</a> using a <a>StateT</a> monad transformer.
module Haskore.Interface.SuperCollider.Channel.State
manager :: Monad m => T (StateT Channel m)
next :: Monad m => NumberChannels -> StateT Channel m Channel
reset :: Monad m => StateT Channel m ()


-- | An instance of <a>T</a> using a temporary file.
module Haskore.Interface.SuperCollider.Channel.File
manager :: T IO
next :: NumberChannels -> IO Channel
reset :: IO ()
fileName :: FilePath


-- | An instance of <a>T</a> using environment variables. Since we need
--   writing of variables, we need <a>System.Posix.Env</a> module rather
--   than the generic <a>System.Environment</a>.
module Haskore.Interface.SuperCollider.Channel.Env
manager :: T IO
next :: NumberChannels -> IO Channel
reset :: IO ()
envName :: String


-- | This module is quite specific to <a>Haskore.Music.Rhythmic</a>. Maybe
--   the module name should reflect this?
module Haskore.Interface.SuperCollider.SoundMap
type Name = String

-- | <a>Attribute</a> means an optional information for a note. Compare
--   with <a>InstrumentParameters</a>.
type Attribute = Double
type AttributeList = [Attribute]
type ToSound instr = instr -> (AttributeList, Name)
attributeControl :: Int -> UGen
attributeName :: Int -> String
attributeNames :: [String]
control :: String -> UGen
pitchName :: String
velocityName :: String
durationName :: String
with0Attributes :: (() -> AttributeList, (sound) -> sound)
with1Attribute :: ((Attribute) -> AttributeList, (UGen -> sound) -> sound)
with2Attributes :: ((Attribute, Attribute) -> AttributeList, (UGen -> UGen -> sound) -> sound)
with3Attributes :: ((Attribute, Attribute, Attribute) -> AttributeList, (UGen -> UGen -> UGen -> sound) -> sound)
with4Attributes :: ((Attribute, Attribute, Attribute, Attribute) -> AttributeList, (UGen -> UGen -> UGen -> UGen -> sound) -> sound)
type Table params sound = [(sound, Sound params)]
type TableWithAttributes params sound = [Assign params sound]
type TableWithChannels params sound = [(Channel, Assign params sound)]
type Sound params = params -> UGen
class SoundParameters params
soundParameters :: SoundParameters params => params
ugenFromSound :: SoundParameters params => Sound params -> UGen
data Assign params sound
Assign :: Name -> (sound -> Maybe AttributeList) -> (Sound params) -> Assign params sound
lookup :: TableWithAttributes params sound -> ToSound sound
assignGeneric :: (attributeTuple -> AttributeList, soundGen -> Sound params) -> Name -> (sound -> Maybe attributeTuple) -> soundGen -> Assign params sound
assign :: Name -> (sound -> Maybe ()) -> Sound params -> Assign params sound
assignEq :: Eq sound => Name -> sound -> Sound params -> Assign params sound
assign1 :: Name -> (sound -> Maybe Attribute) -> (UGen -> Sound params) -> Assign params sound
assign2 :: Name -> (sound -> Maybe (Attribute, Attribute)) -> (UGen -> UGen -> Sound params) -> Assign params sound
assign3 :: Name -> (sound -> Maybe (Attribute, Attribute, Attribute)) -> (UGen -> UGen -> UGen -> Sound params) -> Assign params sound
assign4 :: Name -> (sound -> Maybe (Attribute, Attribute, Attribute, Attribute)) -> (UGen -> UGen -> UGen -> UGen -> Sound params) -> Assign params sound
withDuration :: (UGen -> Sound params) -> Sound params

-- | <tt>Parameter</tt> means an obligatory information for a note, like
--   <tt>frequency</tt>, <tt>velocity</tt>, <tt>duration</tt>. Compare with
--   <a>Attribute</a>.
data InstrumentParameters
InstrumentParameters :: UGen -> UGen -> UGen -> InstrumentParameters
instrumentDuration :: InstrumentParameters -> UGen
instrumentVelocity :: InstrumentParameters -> UGen
instrumentFrequency :: InstrumentParameters -> UGen
instrumentParameters :: InstrumentParameters
type InstrumentTable instr = Table InstrumentParameters instr
type InstrumentTableWithAttributes instr = TableWithAttributes InstrumentParameters instr
type InstrumentTableWithChannels instr = TableWithChannels InstrumentParameters instr
type Instrument = Sound InstrumentParameters
type InstrumentAssign instr = Assign InstrumentParameters instr
instrumentFromUGen :: (UGen -> UGen -> UGen) -> Instrument
data DrumParameters
DrumParameters :: UGen -> UGen -> DrumParameters
drumDuration :: DrumParameters -> UGen
drumVelocity :: DrumParameters -> UGen
drumParameters :: DrumParameters
type DrumTable instr = Table DrumParameters instr
type DrumTableWithAttributes instr = TableWithAttributes DrumParameters instr
type DrumTableWithChannels instr = TableWithChannels DrumParameters instr
type Drum = Sound DrumParameters
type DrumAssign instr = Assign DrumParameters instr
drumFromUGen :: (UGen -> UGen) -> Drum

-- | Like a State+Writer monad with the binding operation baked into
--   <a>registerInstrument</a>. This way we can suppress ignoring of
--   results of <a>registerInstrument</a>, which is easily possible with
--   'do' notation.
newtype ChannelMap drum instr
ChannelMap :: (Channel -> (UGen, (DrumTableWithChannels drum, InstrumentTableWithChannels instr))) -> ChannelMap drum instr
runChannelMap :: ChannelMap drum instr -> Channel -> (UGen, (DrumTableWithChannels drum, InstrumentTableWithChannels instr))
registerSound :: params -> ((Channel, Assign params sound) -> (DrumTableWithChannels drum, InstrumentTableWithChannels instr) -> (DrumTableWithChannels drum, InstrumentTableWithChannels instr)) -> Assign params sound -> (UGen -> ChannelMap drum instr) -> ChannelMap drum instr
registerInstrument :: InstrumentAssign instr -> (UGen -> ChannelMap drum instr) -> ChannelMap drum instr
registerDrum :: DrumAssign drum -> (UGen -> ChannelMap drum instr) -> ChannelMap drum instr
soundEffect :: UGen -> ChannelMap drum instr
instance SoundParameters DrumParameters
instance SoundParameters InstrumentParameters

module Haskore.Interface.SuperCollider.Note
data T
Cons :: [Attribute] -> Double -> String -> Maybe Double -> T
parameters :: T -> [Attribute]
velocity :: T -> Double
instrument :: T -> String
pitch :: T -> Maybe Double
type FromNote dyn note = dyn -> Relative -> note -> T
fromRhythmicNoteWithAttributes :: Real dyn => ToSound drum -> ToSound instr -> FromNote dyn (Note drum instr)
fromRhythmicNote :: Real dyn => (drum -> String) -> (instr -> String) -> FromNote dyn (Note drum instr)
fromGMNote :: Real dyn => FromNote dyn Note
fromStdNote :: Real dyn => FromNote dyn Note
velocityFromStd :: Real dyn => dyn -> Rational -> Double
pitchFromStd :: Relative -> T -> Double
instance Show T
instance Ord T
instance Eq T

module Haskore.Interface.SuperCollider.Performance
fromMelody :: (C time, Floating time, RealFrac time) => T () -> Padded time T
fancyPaddedPerformanceFromMusic :: (Ord note, C time, RealFrac time) => T note -> Padded time Double note
type NodeId = Int
type NodeIdGen a = T NodeId a
type T time = T time (NodeId, Maybe (time, T))
eventsFromNotes :: C time => Padded time T -> NodeIdGen (T time)
eventsFromNotesEither :: C time => Padded time T -> NodeIdGen (T time)
eventsFromNotesQueue :: C time => Padded time T -> NodeIdGen (T time)

-- | This variant does not need a list of <a>Either</a>s, instead it uses
--   two separate lists for start and stop events. We would like to use a
--   standard datatype for priority queues, however it must be efficient to
--   remove the first element which means that the time stamp of all
--   following elements must be decreased. Since we have no such data
--   structure, we simply use a TimeList. But then again, without the
--   <a>Either</a> list, we have to merge the queue of stop events and the
--   list of start events manually. This makes the implementation less
--   beautiful.
eventsFromNotesQueueAux :: C time => T time NodeId -> Padded time T -> NodeIdGen (T time)
eventsFromNotesEitherAux :: C time => T time (Either NodeId (Event time T)) -> NodeIdGen (T time)
instrStartNodeId :: NodeId
fixNodeIds :: NodeIdGen a -> a
fromMusic :: (Ord note, C time, RealFrac time) => FromNote time note -> T note -> NodeIdGen (T time)
fromRhythmicMusicWithAttributes :: (Ord drum, Ord instr, C time, Floating time, RealFrac time) => ToSound drum -> ToSound instr -> T drum instr -> NodeIdGen (T time)

module Haskore.Interface.SuperCollider.Schedule
data T
Cons :: [Message] -> T Time Message -> T

-- | All of these messages must be synchronous! Otherwise the player might
--   wait forever.
initial :: T -> [Message]
body :: T -> T Time Message
type SoundHandler note = (FromNote Double note, [SoundAssign])
type Time = Double
fromMelody :: Instrument -> T () -> T
fromMusic :: Ord note => SoundHandler note -> T note -> T
fromMusicGlobalEffect :: Ord note => SoundHandler note -> (UGen -> UGen, NumberChannels) -> T note -> T
fromRhythmicMusicSoundEffects :: (Ord drum, Ord instr) => ChannelMap instr drum -> NumberChannels -> T instr drum -> T
fromPerformance :: [Message] -> [Message] -> T Time -> T
rhythmicMusic :: (Show instr, Show drum, Ord instr, Ord drum) => DrumTable drum -> InstrumentTable instr -> SoundHandler (Note drum instr)
rhythmicMusicWithAttributes :: (Ord instr, Ord drum) => DrumTableWithAttributes drum -> InstrumentTableWithAttributes instr -> SoundHandler (Note drum instr)
installUGenMsg :: String -> Channel -> UGen -> Message
installSoundMsg :: SoundParameters params => String -> Channel -> Sound params -> Message
defaultChannel :: Channel
atomPlayMsg :: NodeId -> String -> [(String, Double)] -> Message
fromMusicMsgs :: Ord note => (FromNote Double note, [Message]) -> T note -> T
eventToMark :: (NodeId, Maybe T) -> (NodeId, Bool)
instance Show T

module Haskore.Interface.SuperCollider.Play
music :: Ord note => Time -> SoundHandler note -> T note -> IO ()
melody :: Time -> Instrument -> T () -> IO ()
performance :: Time -> [Message] -> T Time -> IO ()
schedule :: Time -> T -> IO ()
scheduleWithPlayer :: Transport m => (T Time Message -> m ()) -> T -> m ()
shutUp :: IO ()

-- | Default value for latency used in
--   <a>Haskore.Interface.SuperCollider.Play.Live</a> and connected
--   modules.
defaultLatency :: Time
timeStamp :: Time -> Time -> [Message] -> Bundle
installSound :: (Transport m, SoundParameters params) => String -> Sound params -> m ()
playAtom :: Transport m => NodeId -> String -> [(String, Double)] -> m ()
performanceTrans :: (Transport m, MonadIO m) => Time -> [Message] -> T Time -> m ()

-- | Uses <tt>threadDelay</tt> and <tt>getClockTime</tt> for a long-time
--   stable, but not very accurate timing. Use time stamped messages for
--   SuperCollider in order to achieve exact scheduling. You have to
--   specify the latency, that is, the maximal expected delay of creating
--   and sending messages to the SuperCollider server.
messagesGrouped :: Transport m => T m -> Time -> T Time Message -> m ()
messagesGroupedManual :: Transport m => T m -> Time -> T Time Message -> m ()
messagesSingly :: Transport m => T m -> Time -> T Time Message -> m ()
messagesSimple :: Transport m => T m -> T Time Message -> m ()

module Haskore.Interface.SuperCollider.Render
fileFromMelody :: FilePath -> Instrument -> T () -> IO ()
fileFromMelodyMonad :: FilePath -> Instrument -> T () -> IO ()
byteStringFromSchedule :: T -> ByteString
runSCSynth :: [String] -> Int -> HeaderFormat -> SampleFormat -> Int -> FilePath -> IO ExitCode
data HeaderFormat
AIFF :: HeaderFormat
Wave :: HeaderFormat
NeXT :: HeaderFormat
data SampleFormat
Int16 :: SampleFormat
Int24 :: SampleFormat
Int32 :: SampleFormat
Float :: SampleFormat
Double :: SampleFormat
instance Read HeaderFormat
instance Show HeaderFormat
instance Eq HeaderFormat
instance Ord HeaderFormat
instance Ix HeaderFormat
instance Bounded HeaderFormat
instance Read SampleFormat
instance Show SampleFormat
instance Eq SampleFormat
instance Ord SampleFormat
instance Ix SampleFormat
instance Bounded SampleFormat

module Haskore.Interface.SuperCollider.Example
latency :: Time
type Song = (String, T)
play :: Song -> IO ()
render :: Song -> IO ExitCode
glissandoStringsUGen :: UGen -> UGen -> UGen
reverb :: UGen -> UGen -> UGen
filterStrings :: Instrument
glissando :: Song

-- | normalize a list of numbers, such that they have a specific average
normalizeLevel :: Fractional a => a -> [a] -> [a]
strings :: Instrument
modulatedStrings :: Instrument
brass :: Instrument
sawPerc :: Instrument
sawPercUGen :: UGen -> UGen -> UGen
dynPerc :: UGen -> Instrument
dynPercUGen :: UGen -> UGen -> UGen -> UGen
fmBass :: UGen -> Instrument
fmGuitar :: UGen -> Instrument
xylophone :: Instrument
harpsichord :: Instrument

-- | The <tt>dust</tt> UGen as provided by SuperCollider has a problem: The
--   higher the sample rate, the more narrow are the impulses, the less
--   volume you obtain. We work-around this by choosing a larger impulse.
--   (We could also use a fixed width for the impulses.)
colorDust :: Double -> Instrument
flangerSquare :: UGen -> UGen
cubicSine :: UGen -> UGen
cubicPhaserSaw :: UGen -> UGen
midiInstrMap :: InstrumentTable Instr
childSong :: Song
bassMusic :: T
bass :: Song
bassFinite :: Song

-- | Oscillator with the waveform of a parabola.
--   
--   The parabola is created by moving a saw up or down, and squaring it.
--   That is we repeat the function <tt>x -&gt; (x+s)^2</tt>.
--   
--   The crux is the subsequent normalization to zero DC offset. This boils
--   down to a parabola plus a saw.
parabolaOsci :: UGen -> UGen -> UGen
kantate147 :: Song
pad :: UGen -> Instrument
bridge :: UGen -> UGen -> UGen -> Envelope UGen
seed :: Int
hihat :: Drum
bassdrum :: Drum
bassdrumOnk :: Drum
bassdrumPM :: Drum
bassdrumNoisy :: Drum
data Instrument
SynthBass :: Double -> Instrument
Pad :: Double -> Instrument
data Drum
Hihat :: Drum
BassDrum :: Drum
instrMap :: InstrumentTableWithAttributes Instrument
drumMap :: DrumTableWithAttributes Drum
synthBassAttrsToInstr :: (Rational, Double) -> (Rational, Instrument)
synthBassMelody :: T (Rational, Double)
padAttrsToInstr :: Double -> (Rational, Instrument)
padMelody :: T Double
rhythm :: T Drum Instrument
chillOutMusic :: T Drum Instrument
chillOut :: Song
chillOutFinite :: Song
data InstrumentTriplet
SawPerc :: InstrumentTriplet
DynPerc :: Double -> InstrumentTriplet
sawPercAssign :: InstrumentAssign InstrumentTriplet
dynPercAssign :: InstrumentAssign InstrumentTriplet
tripletsMusic :: T Drum InstrumentTriplet
triplets :: Song
instance Eq Instrument
instance Ord Instrument
instance Show Drum
instance Eq Drum
instance Ord Drum
instance Eq InstrumentTriplet
instance Ord InstrumentTriplet


-- | This is a variant of the
--   <a>Haskore.Interface.SuperCollider.Schedule</a> module. Instead of an
--   abstract <tt>Instrument</tt> type and a
--   <a>Haskore.Interface.SuperCollider.SoundMap</a>, we attach
--   SuperCollider instrument information to each note.
module Haskore.Interface.SuperCollider.Schedule.Install

-- | The <tt>[OSC.Message]</tt> state is used for messages for installing
--   the instruments. We cannot use a Writer monad for this purpose because
--   we have to read the generated messages for <tt>playMusic</tt>.
newtype Environment a
Environment :: Writer [Message] a -> Environment a
unwrapEnvironment :: Environment a -> Writer [Message] a
writeOSC :: [Message] -> Environment ()
data Sound params attr
Sound :: String -> (attr -> AttributeList) -> Sound params attr
nameFromSound :: Sound params attr -> String
flattenAttrFromSound :: Sound params attr -> (attr -> AttributeList)
type Instrument attr = Sound InstrumentParameters attr
type Drum attr = Sound DrumParameters attr
installSound :: SoundParameters params => (parameterTuple -> AttributeList, graph -> Sound params) -> String -> graph -> Environment (Sound params parameterTuple)
installSound0 :: SoundParameters params => String -> Sound params -> Environment (Sound params ())
installSound1 :: SoundParameters params => String -> (UGen -> Sound params) -> Environment (Sound params Double)
installSound2 :: SoundParameters params => String -> (UGen -> UGen -> Sound params) -> Environment (Sound params (Double, Double))
data SoundAttributes params
SoundAttributes :: AttributeList -> String -> SoundAttributes params
type DrumAttributes = SoundAttributes DrumParameters
type InstrumentAttributes = SoundAttributes InstrumentParameters
rhythmicMusicFromDynamicMelody :: Instrument attr -> T (Rational, attr) -> T DrumAttributes InstrumentAttributes
rhythmicMusicFromMelody :: Instrument attr -> T attr -> T DrumAttributes InstrumentAttributes
rhythmicMusicFromRhythm :: Drum () -> Dur -> String -> T DrumAttributes InstrumentAttributes
rhythmicMusicFromDrum :: Drum () -> Dur -> T DrumAttributes InstrumentAttributes
fromRhythmicMusic :: Environment (T DrumAttributes InstrumentAttributes) -> T
example :: IO ()
instance Eq (SoundAttributes params)
instance Ord (SoundAttributes params)
instance Monad Environment
instance Applicative Environment
instance Functor Environment


-- | This is a variant of the <a>Haskore.Interface.SuperCollider.Play</a>
--   module. Instead of an abstract <tt>Instrument</tt> type and a
--   <a>Haskore.Interface.SuperCollider.SoundMap</a>, we attach
--   SuperCollider instrument information to each note.
--   
--   This module can be used as basis for life performances.

-- | <i>Deprecated: use Haskore.Interface.SuperCollider.Schedule.Install
--   instead</i>
module Haskore.Interface.SuperCollider.Play.Install
installSound :: (Transport m, SoundParameters params) => (parameterTuple -> AttributeList, graph -> Sound params) -> String -> graph -> m (Sound params parameterTuple)
installSound0 :: (Transport m, SoundParameters params) => String -> Sound params -> m (Sound params ())
installSound1 :: (Transport m, SoundParameters params) => String -> (UGen -> Sound params) -> m (Sound params Double)
installSound2 :: (Transport m, SoundParameters params) => String -> (UGen -> UGen -> Sound params) -> m (Sound params (Double, Double))
playMusic :: (Transport m, MonadIO m) => T DrumAttributes InstrumentAttributes -> m ()
example :: IO ()


-- | This is a variant of the
--   <a>Haskore.Interface.SuperCollider.Schedule.Install</a> module. It
--   assigns output channels to instruments such that instrument specific
--   global effects can be applied to them.
module Haskore.Interface.SuperCollider.Schedule.Channel
newtype Environment a
Environment :: StateT (Channel, NumberChannels) (Writer [Message]) a -> Environment a
unwrapEnvironment :: Environment a -> StateT (Channel, NumberChannels) (Writer [Message]) a
writeOSC :: [Message] -> Environment ()
nextChannel :: NumberChannels -> Environment Channel
data Sound params attr
Sound :: String -> (Channel, NumberChannels) -> (attr -> AttributeList) -> Sound params attr
type Instrument attr = Sound InstrumentParameters attr
type Drum attr = Sound DrumParameters attr
installUGen :: String -> UGen -> Environment (Channel, NumberChannels)
installSound :: SoundParameters params => (parameterTuple -> AttributeList, graph -> Sound params) -> String -> graph -> Environment (Sound params parameterTuple)
ugenFromSound :: Sound params attr -> UGen

-- | These types are identically defined to those from
--   <a>Haskore.Interface.SuperCollider.Schedule.Install</a> but they shall
--   be distinct. Instruments that are installed for use of global effects
--   cannot be used with the simple <tt>playMusic</tt> routine.
data SoundAttributes params
SoundAttributes :: AttributeList -> String -> SoundAttributes params
type DrumAttributes = SoundAttributes DrumParameters
type InstrumentAttributes = SoundAttributes InstrumentParameters
rhythmicMusicFromDynamicMelody :: Instrument attr -> T (Rational, attr) -> T DrumAttributes InstrumentAttributes
rhythmicMusicFromMelody :: Instrument attr -> T attr -> T DrumAttributes InstrumentAttributes
rhythmicMusicFromRhythm :: Drum () -> Dur -> String -> T DrumAttributes InstrumentAttributes
rhythmicMusicFromDrum :: Drum () -> Dur -> T DrumAttributes InstrumentAttributes
fromRhythmicMusic :: Environment (UGen, T DrumAttributes InstrumentAttributes) -> T
example :: IO ()
instance Eq (SoundAttributes params)
instance Ord (SoundAttributes params)
instance Monad Environment
instance Applicative Environment
instance Functor Environment


-- | This is a variant of the
--   <a>Haskore.Interface.SuperCollider.Play.Install</a> module. It assigns
--   output channels to instruments such that instrument specific global
--   effects can be applied to them.

-- | <i>Deprecated: use Haskore.Interface.SuperCollider.Schedule.Channel
--   instead</i>
module Haskore.Interface.SuperCollider.Play.Channel
type Environment t a = StateT Channel (ReaderT t IO) a
installUGen :: Transport t => String -> UGen -> Environment t (Channel, NumberChannels)
installSound :: (Transport t, SoundParameters params) => (parameterTuple -> AttributeList, graph -> Sound params) -> String -> graph -> Environment t (Sound params parameterTuple)
reset :: Transport t => Environment t ()
playMusic :: Transport t => UGen -> T DrumAttributes InstrumentAttributes -> Environment t ()
run :: Environment UDP a -> IO a
writeScript :: FilePath -> Environment T a -> IO a
example :: IO ()


-- | This is a module specialised to life performances.
--   
--   You can create and install instruments in SuperCollider, obtain a
--   handle and use that in your song.
--   
--   The alternative way would be to upload an instrument whenever one tone
--   shall be played. This is less efficient but simpler and certainly more
--   flexible.
--   
--   It is certainly not sensible to import that module. Maybe I should
--   provide it as Extra-Source-File or as Main module of a dummy
--   executable in order to ship it via Cabal.
module Haskore.Interface.SuperCollider.Play.Live
type InstrumentUGen = UGen -> UGen -> UGen
installInstr :: (parameterTuple -> AttributeList, graph -> InstrumentUGen) -> String -> graph -> IO (Instrument parameterTuple)
installInstr0 :: String -> InstrumentUGen -> IO (Instrument ())
installInstr1 :: String -> (UGen -> InstrumentUGen) -> IO (Instrument Double)
installInstr2 :: String -> (UGen -> UGen -> InstrumentUGen) -> IO (Instrument (Double, Double))
type DrumUGen = UGen -> UGen
installDrum :: (parameterTuple -> AttributeList, graph -> DrumUGen) -> String -> graph -> IO (Drum parameterTuple)
installSoundChan :: SoundParameters params => String -> Sound params -> IO (Channel, NumberChannels)
installInstrChan :: (parameterTuple -> AttributeList, graph -> InstrumentUGen) -> String -> graph -> IO (Instrument parameterTuple)
installDrumChan :: (parameterTuple -> AttributeList, graph -> DrumUGen) -> String -> graph -> IO (Drum parameterTuple)
reset :: IO ()
playSound :: UGen -> IO ()
playMusic :: T DrumAttributes InstrumentAttributes -> IO ()
playMusicEffect :: UGen -> T DrumAttributes InstrumentAttributes -> IO ()
germanLatin1Keyboard :: [Char]
playKey :: Instrument () -> Char -> IO ()

-- | Interprets the keyboard as piano and play according tones, when keys
--   are hit.
--   
--   Is it more convenient to have a UGen parameter and install the
--   instrument automatically?
playKeyboard :: Instrument () -> IO ()
example :: IO ()
exampleEffect :: IO ()
