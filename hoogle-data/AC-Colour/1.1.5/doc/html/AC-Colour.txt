-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Efficient RGB colour types.
--   
@package AC-Colour
@version 1.1.5


-- | This module provides <a>Colour8</a>, which stores linear RGB (red,
--   green, blue) colour values where each channel is a <tt>Word8</tt>. It
--   also provides arithmetic over such colours, and a few predefined
--   colours.
--   
--   It is the general intention that "most" work will be done with
--   <a>Data.Colour.Double</a>, with values converted to <tt>Colour8</tt>
--   only as a final step. However, full arithmetic is supported anyway, in
--   case anybody wants to work that way. It is slightly less efficient and
--   flexible, however.
--   
--   Beware that "most" RGB data found in external sources is in the
--   (non-linear) sRGB colour space, not the <i>linear</i> RGB colour space
--   used here. See <a>Data.Colour.Nonlinear</a> for conversion functions.
module Data.Colour.Word8

-- | The integral colour. It stores three channels (red, green and blue) as
--   linear <a>Word8</a> values ranging from 0 to 255. (0 represents
--   minimum intensity, 255 represents maximum. Black is therefore
--   <tt>Colour8 0 0 0</tt> and white is <tt>Colour8 255 255 255</tt>.)
--   
--   The channel values are stored as strict, unboxed fields, so operating
--   on <tt>Colour8</tt>s should be quite efficient in time and space.
--   
--   The <a>Num</a> and <a>Fractional</a> instances provide arithmetic for
--   <tt>Colour8</tt>s. Note that <tt>(*)</tt> acts channel-wise; this is
--   usually what is wanted.
data Colour8
Colour8 :: {-# UNPACK #-} !Word8 -> {-# UNPACK #-} !Word8 -> {-# UNPACK #-} !Word8 -> Colour8
red8 :: Colour8 -> {-# UNPACK #-} !Word8
green8 :: Colour8 -> {-# UNPACK #-} !Word8
blue8 :: Colour8 -> {-# UNPACK #-} !Word8

-- | Apply a function to every channel of a <tt>Colour8</tt>. (Mostly used
--   internally; exposed here in case it might be useful.)
c8map :: (Word8 -> Word8) -> Colour8 -> Colour8

-- | The colour equivilent of <a>zipWith</a>. (Mostly used internally;
--   exposed here in case it might be useful.)
c8zip :: (Word8 -> Word8 -> Word8) -> Colour8 -> Colour8 -> Colour8

-- | Use a function to fold the three values in a <tt>Colour8</tt> into a
--   single value. No particular order of application is promised.
c8fold :: (Word8 -> Word8 -> Word8) -> Colour8 -> Word8

-- | Convert a <tt>Word8</tt> into a shade of grey.
grey8 :: Word8 -> Colour8

-- | Scale a <tt>Colour8</tt> by the specified amount. Recall that 0x00
--   means zero, and 0xFF means one. This means that it is impossible to
--   make a colour <i>brighter</i>, only darker. It also means this
--   operation is modestly inefficient due to the renormalisation steps.
c8scale :: Word8 -> Colour8 -> Colour8

-- | Convert a <a>Colour8</a> to a tuple.
unpack8 :: Colour8 -> (Word8, Word8, Word8)

-- | Convert a tuple to a <a>Colour8</a>.
pack8 :: (Word8, Word8, Word8) -> Colour8

-- | Constant: Black.
c8Black :: Colour8

-- | Constant: Red.
c8Red :: Colour8

-- | Constant: Yellow.
c8Yellow :: Colour8

-- | Constant: Green.
c8Green :: Colour8

-- | Constant: Cyan.
c8Cyan :: Colour8

-- | Constant: Blue.
c8Blue :: Colour8

-- | Constant: Magenta.
c8Magenta :: Colour8

-- | Constant: White.
c8White :: Colour8
instance Eq Colour8
instance Ord Colour8
instance Show Colour8
instance Num Colour8


-- | This module provides <a>Colour</a>, which stores linear RGB (red,
--   green, blue) colour values where each channel is a <a>Double</a>. It
--   also provides arithmetic over such colours, and a few predefined
--   colours.
module Data.Colour.Double

-- | The main colour type. It stores three channels (red, green and blue)
--   as linear <a>Double</a> values normally ranging from 0 to 1. (0
--   represents minimum intensity, 1 represents maximum. Black is therefore
--   <tt>Colour 0 0 0</tt> and white is <tt>Colour 1 1 1</tt>.)
--   
--   The channel values are stored as strict, unboxed fields, so operating
--   on <tt>Colour</tt>s should be quite efficient in time and space.
--   
--   The <a>Num</a> and <a>Fractional</a> instances provide arithmetic for
--   <tt>Colour</tt>s. Note that <tt>(*)</tt> acts channel-wise; this is
--   usually what is wanted.
data Colour
Colour :: {-# UNPACK #-} !Double -> {-# UNPACK #-} !Double -> {-# UNPACK #-} !Double -> Colour
red :: Colour -> {-# UNPACK #-} !Double
green :: Colour -> {-# UNPACK #-} !Double
blue :: Colour -> {-# UNPACK #-} !Double

-- | Apply a function to every channel in a colour. (Mostly used
--   internally, but exposed here in case it may be useful.)
cmap :: (Double -> Double) -> Colour -> Colour

-- | This is similar to <a>zipWith</a>. (Mostly used internally, but
--   exposed here in case it may be useful.)
czip :: (Double -> Double -> Double) -> Colour -> Colour -> Colour

-- | Use a function to collapse a <tt>Colour</tt> into a <tt>Double</tt>.
--   No particular order of application is promised.
cfold :: (Double -> Double -> Double) -> Colour -> Double

-- | Turn a <tt>Double</tt> into a shade of grey.
grey :: Double -> Colour

-- | Scale a <tt>Colour</tt> by a specified amount. (That is, change the
--   brightness while not affecting the shade.)
cscale :: Double -> Colour -> Colour

-- | Take a <tt>Colour</tt> and clip all channels to the range 0--1
--   inclusive. Any value outside that range will be replaced with the
--   nearest endpoint (i.e., 0 for negative numbers, 1 for positive numbers
--   higher than 1). Values inside the range are unaffected.
clip :: Colour -> Colour

-- | Convert a <a>Colour</a> into a tuple.
unpack :: Colour -> (Double, Double, Double)

-- | Convert a tuple into a <a>Colour</a>.
pack :: (Double, Double, Double) -> Colour

-- | Constant: Black.
cBlack :: Colour

-- | Constant: Red.
cRed :: Colour

-- | Constant: Yellow.
cYellow :: Colour

-- | Constant: Green.
cGreen :: Colour

-- | Constant: Cyan.
cCyan :: Colour

-- | Constant: Blue.
cBlue :: Colour

-- | Constant: Magenta.
cMagenta :: Colour

-- | Constant: White.
cWhite :: Colour
instance Eq Colour
instance Ord Colour
instance Show Colour
instance Fractional Colour
instance Num Colour


-- | This module provides 1-dimensional colour maps with smooth (linear)
--   colour blending between control points.
module Data.Colour.Map

-- | Takes a range and a value, and returns a value inside the given range.
--   If the value is already in the range, it is unchanged. Otherwise it
--   "wraps around". For example, if the range is <tt>(0, 1)</tt> then, in
--   effect, the fractional part of the value is returned.
--   
--   Note that extremely narrow ranges may exhibit numerical instability.
range_cycle :: (Double, Double) -> Double -> Double

-- | This is the basic colour map type. It consists of a list of control
--   points, each one being a parameter value and the colour at that
--   parameter value. The colour at other parameter values is linearly
--   interpolated between the control points.
--   
--   Parameter values outside the range (i.e., below the first point or
--   above the last point) take the colour of the end control point. This
--   means that in the degenerate case of a single control point, the
--   colour is applied everywhere (and the parameter value is ignored).
--   
--   A map with <i>zero</i> control points is not permitted.
type ColourMap = [(Double, Colour)]

-- | Compute the value of a colour map at a particular parameter value.
colour_map :: ColourMap -> Double -> Colour

-- | This is a colour map with has optional repeating behaviour using
--   <a>range_cycle</a> above.
--   
--   Notice that the parameter range that gets repeated need not cover the
--   entire range of the underlying <a>ColourMap</a>.
data FullColourMap

-- | Colour map which does not repeat.
SimpleMap :: ColourMap -> FullColourMap

-- | Colour map which repeats.
RepeatingMap :: (Double, Double) -> ColourMap -> FullColourMap

-- | Compute the value of a full colour map at a particular parameter
--   value, similar to <a>colour_map</a>.
full_colour_map :: FullColourMap -> Double -> Colour


-- | This module exports all the main interesting parts of the various
--   colour modules. It also provides functions for converting between
--   <a>Colour</a> and <a>Colour8</a>.
--   
--   It is the general intention that "most" work will be done with
--   <a>Colour</a>, with values converted to <tt>Colour8</tt> only as a
--   final step. However, full arithmetic on <a>Colour8</a> is supported
--   anyway, in case anybody wants to work that way. It is slightly less
--   efficient and flexible, however.
--   
--   Note that most colour values from external sources are typically
--   colour values in the non-linear sRGB colour space, rather than the
--   linear RGB values handled here. See <a>Data.Colour.Nonlinear</a> for
--   conversion functions.
module Data.Colour

-- | The main colour type. It stores three channels (red, green and blue)
--   as linear <a>Double</a> values normally ranging from 0 to 1. (0
--   represents minimum intensity, 1 represents maximum. Black is therefore
--   <tt>Colour 0 0 0</tt> and white is <tt>Colour 1 1 1</tt>.)
--   
--   The channel values are stored as strict, unboxed fields, so operating
--   on <tt>Colour</tt>s should be quite efficient in time and space.
--   
--   The <a>Num</a> and <a>Fractional</a> instances provide arithmetic for
--   <tt>Colour</tt>s. Note that <tt>(*)</tt> acts channel-wise; this is
--   usually what is wanted.
data Colour
Colour :: {-# UNPACK #-} !Double -> {-# UNPACK #-} !Double -> {-# UNPACK #-} !Double -> Colour
red :: Colour -> {-# UNPACK #-} !Double
green :: Colour -> {-# UNPACK #-} !Double
blue :: Colour -> {-# UNPACK #-} !Double

-- | Turn a <tt>Double</tt> into a shade of grey.
grey :: Double -> Colour

-- | Scale a <tt>Colour</tt> by a specified amount. (That is, change the
--   brightness while not affecting the shade.)
cscale :: Double -> Colour -> Colour

-- | Take a <tt>Colour</tt> and clip all channels to the range 0--1
--   inclusive. Any value outside that range will be replaced with the
--   nearest endpoint (i.e., 0 for negative numbers, 1 for positive numbers
--   higher than 1). Values inside the range are unaffected.
clip :: Colour -> Colour

-- | Convert a tuple into a <a>Colour</a>.
pack :: (Double, Double, Double) -> Colour

-- | Convert a <a>Colour</a> into a tuple.
unpack :: Colour -> (Double, Double, Double)

-- | Constant: Black.
cBlack :: Colour

-- | Constant: White.
cWhite :: Colour

-- | Constant: Red.
cRed :: Colour

-- | Constant: Yellow.
cYellow :: Colour

-- | Constant: Green.
cGreen :: Colour

-- | Constant: Cyan.
cCyan :: Colour

-- | Constant: Blue.
cBlue :: Colour

-- | Constant: Magenta.
cMagenta :: Colour

-- | The integral colour. It stores three channels (red, green and blue) as
--   linear <a>Word8</a> values ranging from 0 to 255. (0 represents
--   minimum intensity, 255 represents maximum. Black is therefore
--   <tt>Colour8 0 0 0</tt> and white is <tt>Colour8 255 255 255</tt>.)
--   
--   The channel values are stored as strict, unboxed fields, so operating
--   on <tt>Colour8</tt>s should be quite efficient in time and space.
--   
--   The <a>Num</a> and <a>Fractional</a> instances provide arithmetic for
--   <tt>Colour8</tt>s. Note that <tt>(*)</tt> acts channel-wise; this is
--   usually what is wanted.
data Colour8
Colour8 :: {-# UNPACK #-} !Word8 -> {-# UNPACK #-} !Word8 -> {-# UNPACK #-} !Word8 -> Colour8
red8 :: Colour8 -> {-# UNPACK #-} !Word8
green8 :: Colour8 -> {-# UNPACK #-} !Word8
blue8 :: Colour8 -> {-# UNPACK #-} !Word8

-- | Convert a <tt>Word8</tt> into a shade of grey.
grey8 :: Word8 -> Colour8

-- | Scale a <tt>Colour8</tt> by the specified amount. Recall that 0x00
--   means zero, and 0xFF means one. This means that it is impossible to
--   make a colour <i>brighter</i>, only darker. It also means this
--   operation is modestly inefficient due to the renormalisation steps.
c8scale :: Word8 -> Colour8 -> Colour8

-- | Convert a tuple to a <a>Colour8</a>.
pack8 :: (Word8, Word8, Word8) -> Colour8

-- | Convert a <a>Colour8</a> to a tuple.
unpack8 :: Colour8 -> (Word8, Word8, Word8)

-- | Constant: Black.
c8Black :: Colour8

-- | Constant: White.
c8White :: Colour8

-- | Constant: Red.
c8Red :: Colour8

-- | Constant: Yellow.
c8Yellow :: Colour8

-- | Constant: Green.
c8Green :: Colour8

-- | Constant: Cyan.
c8Cyan :: Colour8

-- | Constant: Blue.
c8Blue :: Colour8

-- | Constant: Magenta.
c8Magenta :: Colour8

-- | Convert a <a>Colour8</a> into a <a>Colour</a>. Recall that 0x00 means
--   zero and 0xFF means one; this function will remap such values
--   appropriately.
cpromote :: Colour8 -> Colour

-- | Convert a <a>Colour</a> into a <a>Colour8</a>. Any values outside the
--   range 0--1 will be <tt>wrapped</tt> to that range. You may want to run
--   <a>clip</a> before calling this function to prevent this behaviour
--   (unless you know the values can't be outside the permitted range).
--   This function is the exact inverse of <a>cpromote</a>; 0 is mapped to
--   0x00 and 1 is mapped to 0xFF.
cdemote :: Colour -> Colour8


-- | Support for the "sRGB" colour space.
--   
--   This colour space is the <i>de facto</i> standard colour space for
--   computer data, unless some more specific colour space is explicitly
--   specified. Unless you know differently, any image data received from
--   the outside world is probably sRGB, and and data output is probably
--   expected to be sRGB.
--   
--   Unfortunately, sRGB is a non-linear colour space, so it is not
--   feasible to perform arithmetic in it directly. (The sRGB colour space
--   basically standardises the defective non-linear behaviour of obsolete
--   CRT display technology.)
module Data.Colour.Nonlinear

-- | Type for holding sRGB colour values (with <a>Double</a> components).
--   
--   The standard <a>Colour</a> type is for <i>linear</i> RGB values. This
--   type is for sRGB colours, which are non-linear.
newtype Colour_sRGB
Colour_sRGB :: Colour -> Colour_sRGB

-- | Type for holding sRGB colour values (with <a>Word8</a> components).
--   
--   The standard <a>Colour8</a> type is for <i>linear</i> RGB values. This
--   type is for sRGB colours, which are non-linear.
newtype Colour8_sRGB
Colour8_sRGB :: Colour8 -> Colour8_sRGB

-- | Convert a linear RGB value into a non-linear sRGB value.
colour_to_sRGB :: Colour -> Colour_sRGB

-- | Convert from <a>Double</a> components to <a>Word8</a> components.
cdemote_sRGB :: Colour_sRGB -> Colour8_sRGB

-- | Convert from <a>Word8</a> components to <a>Double</a> components.
cpromote_sRGB :: Colour8_sRGB -> Colour_sRGB

-- | Convert a non-linear sRGB value into a linear RGB value.
colour_from_sRGB :: Colour_sRGB -> Colour
instance Eq Colour_sRGB
instance Ord Colour_sRGB
instance Show Colour_sRGB
instance Eq Colour8_sRGB
instance Ord Colour8_sRGB
instance Show Colour8_sRGB
