-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Infernal data structures and tools
--   
--   Provides import and export facilities for Infernal/Rfam data formats.
--   We include Stockholm, CM, verbose Infernal results, and tabulated
--   Infernal results. Some small tools are included.
--   
--   The VerboseHit format is slightly extended to allow simple
--   annotations. This extension should be backward-compatible with
--   standard-compliant parsers.
--   
--   This package uses Int's to store sequence position information. Don't
--   compile for 32bit. (And yes, this is a TODO, to change to Int64).
--   
--   Changes in 0.7.1.0
--   
--   <ul>
--   <li>bumped dependencies, compatible to newest BiobaseXNA,
--   PrimitiveArray</li>
--   </ul>
--   
--   Changes in 0.7.0.0
--   
--   <ul>
--   <li>work-in-progress release (some features missing)</li>
--   <li>working CM parsing</li>
--   <li>type defns have changed. using phantom types to specify what kind
--   of model we are working with</li>
--   <li>using conduit instead of iteratee</li>
--   </ul>
@package BiobaseInfernal
@version 0.7.1.0


-- | Infernal Stockholm files and covariance models, and other related
--   files use a bunch of different identifiers. We provide newtypes for
--   more type safety.
--   
--   TODO Use (Bio.Core.Sequence.Offset) instead of Int for sequence info
--   
--   TODO move <a>BitScore</a>s, null models, probabilities into its own
--   library.
module Biobase.SElab.Types

-- | Accession number, in the format of RFxxxxx, PFxxxxx, or CLxxxxx. We
--   keep only the Int-part. A phantom type specifies which kind of
--   accession number this is. For Species, we just have an index, it
--   seems.
newtype Accession t
ACC :: Int -> Accession t
unACC :: Accession t -> Int

-- | One word name for the family or clan. Phantom-typed with the correct
--   type of model. Can be a longer name for species.
newtype Identification t
IDD :: ByteString -> Identification t
unIDD :: Identification t -> ByteString

-- | Tag as being a clan.
data Clan

-- | Tag as being a Pfam model.
data Pfam

-- | Tag as being an Rfam model. Used for Stockholm and CM files.
data Rfam

-- | Species have an accession number, too.
data Species

-- | Infernal bit score. Behaves like a double (deriving Num).
--   
--   Infernal users guide, p.42: log-odds score in log_2 (aka bits).
--   
--   S = log_2 (P(seq|CM) / P(seq|null))
newtype BitScore
BitScore :: Double -> BitScore
unBitScore :: BitScore -> Double

-- | Given a null model and a probability, calculate the corresponding
--   <a>BitScore</a>.
prob2Score :: Double -> Double -> BitScore

-- | Given a null model and a <a>BitScore</a> return the corresponding
--   probability.
score2Prob :: Double -> BitScore -> Double

-- | Classification names (taxonomic classification)
newtype Classification
Classification :: ByteString -> Classification
unClassification :: Classification -> ByteString
instance Vector Vector BitScore
instance MVector MVector BitScore
instance Unbox BitScore
instance Eq (Accession t)
instance Ord (Accession t)
instance Read (Accession t)
instance Show (Accession t)
instance Eq (Identification t)
instance Ord (Identification t)
instance Read (Identification t)
instance Show (Identification t)
instance Eq BitScore
instance Ord BitScore
instance Read BitScore
instance Show BitScore
instance Num BitScore
instance Prim BitScore
instance Eq Classification
instance Ord Classification
instance Read Classification
instance Show Classification

module Biobase.SElab.HMM
data HMM
data Alphabet
Amino :: Alphabet
DNA :: Alphabet
RNA :: Alphabet
Coins :: Alphabet
Dice :: Alphabet
Custom :: Alphabet

-- | Negated natural logarithm of probability.
--   
--   TODO put into types stuff
newtype NegLogProb
NLP :: Double -> NegLogProb

-- | The nodes in an HMM. Starting with Node <a>0</a> for BEGIN.
data Node
Node :: Int -> [NegLogProb] -> [NegLogProb] -> [NegLogProb] -> Node
_nid :: Node -> Int
_matchE :: Node -> [NegLogProb]
_insertE :: Node -> [NegLogProb]
_trans :: Node -> [NegLogProb]
trans :: Lens' Node [NegLogProb]
nid :: Lens' Node Int
matchE :: Lens' Node [NegLogProb]
insertE :: Lens' Node [NegLogProb]

-- | The HMM3 data structure in ``slow mode''.
--   
--   TODO shouldn't this be <a>Identification Pfam</a> ?
--   
--   TODO maybe redo the whole <a>idd</a> idea and just keep the string?
data HMM3
HMM3 :: (ByteString, ByteString) -> Identification HMM -> Maybe (Accession HMM) -> Maybe ByteString -> Int -> Alphabet -> Bool -> Bool -> Bool -> ByteString -> [ByteString] -> [ByteString] -> [NegLogProb] -> [Node] -> HMM3
_version :: HMM3 -> (ByteString, ByteString)
_idd :: HMM3 -> Identification HMM
_acc :: HMM3 -> Maybe (Accession HMM)
_description :: HMM3 -> Maybe ByteString
_leng :: HMM3 -> Int
_alph :: HMM3 -> Alphabet
_rf :: HMM3 -> Bool
_cs :: HMM3 -> Bool
_alignMap :: HMM3 -> Bool
_date :: HMM3 -> ByteString
_symAlph :: HMM3 -> [ByteString]
_transHeaders :: HMM3 -> [ByteString]
_compo :: HMM3 -> [NegLogProb]
_nodes :: HMM3 -> [Node]
version :: Lens' HMM3 (ByteString, ByteString)
transHeaders :: Lens' HMM3 [ByteString]
symAlph :: Lens' HMM3 [ByteString]
rf :: Lens' HMM3 Bool
nodes :: Lens' HMM3 [Node]
leng :: Lens' HMM3 Int
idd :: Lens' HMM3 (Identification HMM)
description :: Lens' HMM3 (Maybe ByteString)
date :: Lens' HMM3 ByteString
cs :: Lens' HMM3 Bool
compo :: Lens' HMM3 [NegLogProb]
alph :: Lens' HMM3 Alphabet
alignMap :: Lens' HMM3 Bool
acc :: Lens' HMM3 (Maybe (Accession HMM))
instance Show HMM3
instance Read HMM3
instance Eq Alphabet
instance Show Alphabet
instance Read Alphabet
instance Show NegLogProb
instance Read NegLogProb
instance Show Node
instance Read Node


-- | Import HMMER3 HMM models.
module Biobase.SElab.HMM.Import

-- | TODO not everything is currently being parsed. Notably the
--   rf,cs,alignmap annotations.
parseHMM3 :: Monad m => Pipe ByteString ByteString o u m HMM3

-- | Check, if we have a legal HMMER3 model.
legalHMM :: Maybe ByteString -> Bool

-- | Read boolean flags.
readBoolean :: ByteString -> Bool

-- | Determine which alphabet is in use by the HMM.
readAlph :: ByteString -> Alphabet

-- | Read from a bytestring into a structure.
readBS :: Read c => ByteString -> c

-- | create associative map of the key/value data.
headerMap :: [ByteString] -> Map ByteString ByteString

-- | Parse the two beginning lines.
parseBegin :: Monad m => t -> Pipe l ByteString o u m Node

-- | Parse all individual nodes, except the first one, which uses
--   <a>parseBegin</a>.
parseNodes :: Monad m => Int -> Pipe ByteString ByteString o u m [Node]

-- | Read a HMMER negated log-probability.
readNLP :: String -> NegLogProb

-- | Read the optional COMPO line.
compoLine :: Monad m => Pipe ByteString ByteString o u m [NegLogProb]

-- | Read the alphabet and transition lines.
sathLines :: Monad m => Pipe l ByteString o u m ([ByteString], [ByteString])

-- | All the header lines until we see <a>HMM</a>.
headerLines :: Monad m => Pipe ByteString ByteString o u m [ByteString]

-- | Simple test for the HMMer parser.
test :: IO ()


-- | The database of Rfam <a>names</a>. For each model, we get to know
--   which sequences it is built of, what the AC of the species is, and its
--   name (or ID).
module Biobase.SElab.RfamNames
data ModelNames
ModelNames :: !(Accession Rfam) -> !(Identification Rfam) -> Maybe (Accession Species) -> Maybe (Identification Species) -> ModelNames
_modelAC :: ModelNames -> !(Accession Rfam)
_modelID :: ModelNames -> !(Identification Rfam)
_speciesAC :: ModelNames -> Maybe (Accession Species)
_speciesID :: ModelNames -> Maybe (Identification Species)
speciesID :: Lens' ModelNames (Maybe (Identification Species))
speciesAC :: Lens' ModelNames (Maybe (Accession Species))
modelID :: Lens' ModelNames (Identification Rfam)
modelAC :: Lens' ModelNames (Accession Rfam)
instance Show ModelNames

module Biobase.SElab.RfamNames.Import
parse :: Monad m => Sink ByteString m (Map (Identification Rfam) [ModelNames], Map (Accession Rfam) [ModelNames])
mkRfamName :: Parser ByteString ModelNames
mapIdRfamNames :: Monad m => Pipe l ModelNames o u m (Map (Identification Rfam) [ModelNames])
mapAcRfamNames :: Monad m => Pipe l ModelNames o u m (Map (Accession Rfam) [ModelNames])
fromFile :: String -> IO (Map (Identification Rfam) [ModelNames], Map (Accession Rfam) [ModelNames])


-- | Infernal contains a taxonomy database. This is a simple module
--   reflecting said database.
module Biobase.SElab.Taxonomy

-- | For each species, we store the name and a classification list from
--   most general (head) to most specific (last). The database comes with
--   the NCBI taxon identifier (taxid).
data Taxonomy
Taxonomy :: !(Accession Species) -> !(Identification Species) -> [Classification] -> Taxonomy
_accession :: Taxonomy -> !(Accession Species)
_name :: Taxonomy -> !(Identification Species)
_classification :: Taxonomy -> [Classification]
name :: Lens' Taxonomy (Identification Species)
classification :: Lens' Taxonomy [Classification]
accession :: Lens' Taxonomy (Accession Species)

-- | Given a name such as <a>Drosophila Melanogaster</a>, returns
--   <a>d.melanogaster</a>.
shortenName :: Identification Species -> Identification Species
instance Show Taxonomy


-- | Iteratee-based importer. Provides a simple <a>fromFile</a> function
--   that produces both maps in one pass.
module Biobase.SElab.Taxonomy.Import
parse :: Monad m => Sink ByteString m (Map (Identification Species) Taxonomy, Map (Accession Species) Taxonomy)
mkTaxonomy :: Parser Taxonomy
mapIdTaxonomy :: Monad m => GSink Taxonomy m (Map (Identification Species) Taxonomy)
mapAcTaxonomy :: Monad m => GSink Taxonomy m (Map (Accession Species) Taxonomy)
fromFile :: String -> IO (Map (Identification Species) Taxonomy, Map (Accession Species) Taxonomy)


-- | Infernal CMs.
--   
--   TODO order of nucleotides? ACGU?
--   
--   TODO <a>fastCM :: CM -&gt; FastCM</a> to make a data structure that is
--   suitable for high-performance applications.
module Biobase.SElab.CM

-- | Encode the CM versions we can parse
data CMVersion
Infernal10 :: ByteString -> CMVersion
Infernal11 :: ByteString -> CMVersion

-- | Encode CM node types.
data NodeType
BIF :: NodeType
MATP :: NodeType
MATL :: NodeType
MATR :: NodeType
BEGL :: NodeType
BEGR :: NodeType
ROOT :: NodeType
END :: NodeType

-- | Node IDs
newtype NodeID
NodeID :: Int -> NodeID
unNodeID :: NodeID -> Int

-- | Encode CM state types.
data StateType
D :: StateType
MP :: StateType
ML :: StateType
MR :: StateType
IL :: StateType
IR :: StateType
S :: StateType
E :: StateType
B :: StateType
EL :: StateType

-- | State IDs
newtype StateID
StateID :: Int -> StateID
unStateID :: StateID -> Int
illegalState :: StateID

-- | Certain states (IL,IR,ML,MR) emit a single nucleotide, one state emits
--   a pair (MP), other states emit nothing.
data Emits
EmitsSingle :: [(Char, BitScore)] -> Emits
_single :: Emits -> [(Char, BitScore)]
EmitsPair :: [(Char, Char, BitScore)] -> Emits
_pair :: Emits -> [(Char, Char, BitScore)]
EmitNothing :: Emits
single :: Traversal' Emits [(Char, BitScore)]
pair :: Traversal' Emits [(Char, Char, BitScore)]

-- | A single state.
data State
State :: StateID -> NodeID -> NodeType -> StateType -> [(StateID, BitScore)] -> Emits -> State

-- | The ID of this state
_stateID :: State -> StateID

-- | to which node does this state belong
_nodeID :: State -> NodeID

-- | node type for this state
_nodeType :: State -> NodeType

-- | type of the state
_stateType :: State -> StateType

-- | which transitions, id and bitscore
_transitions :: State -> [(StateID, BitScore)]

-- | do we emit characters
_emits :: State -> Emits
transitions :: Lens' State [(StateID, BitScore)]
stateType :: Lens' State StateType
stateID :: Lens' State StateID
nodeType :: Lens' State NodeType
nodeID :: Lens' State NodeID
emits :: Lens' State Emits

-- | This is an Infernal covariance model. We have a number of blocks:
--   
--   <ul>
--   <li>basic information like the name of the CM, accession number,
--   etc.</li>
--   <li>advanced information: nodes and their states, and the states
--   themselves.</li>
--   <li>unsorted information from the header / blasic block</li>
--   </ul>
--   
--   The <a>CM</a> data structure is not suitable for high-performance
--   applications.
--   
--   <ul>
--   <li>score inequalities: trusted (lowest seed score) &gt;= gathering
--   (lowest full score) &gt;= noise (random strings)</li>
--   </ul>
--   
--   Local entries into the CM.
--   
--   The <a>localBegin</a> lens returns a map of state id's. We either have
--   just the root node (with the <a>S</a> state), or a set of states with
--   type: MP,ML,MR,B.
--   
--   The <a>localEnd</a> lens on the other hand is the set of possible
--   early exits from the model.
data CM
CM :: Identification Rfam -> Accession Rfam -> CMVersion -> BitScore -> BitScore -> Maybe BitScore -> Vector BitScore -> Map NodeID (NodeType, [StateID]) -> Map StateID State -> Map StateID BitScore -> Map StateID BitScore -> Map ByteString ByteString -> Maybe HMM3 -> CM

-- | name of model as in <a>tRNA</a>
_name :: CM -> Identification Rfam

-- | RFxxxxx identification
_accession :: CM -> Accession Rfam

-- | We can parse version 1.0 and 1.1 CMs
_version :: CM -> CMVersion

-- | lowest score of any seed member
_trustedCutoff :: CM -> BitScore

-- | all scores at or above <a>gathering</a> score are in the <a>full</a>
--   alignment
_gathering :: CM -> BitScore

-- | highest score NOT included as member
_noiseCutoff :: CM -> Maybe BitScore

-- | Null-model: categorical distribution on ACGU
_nullModel :: CM -> Vector BitScore

-- | each node has a set of states
_nodes :: CM -> Map NodeID (NodeType, [StateID])

-- | each state has a type, some emit characters, and some have children
_states :: CM -> Map StateID State

-- | Entries into the CM.
_localBegin :: CM -> Map StateID BitScore

-- | Exits out of the CM.
_localEnd :: CM -> Map StateID BitScore

-- | all lines that are not handled. Multiline entries are
--   key-&gt;multi-line entry
_unsorted :: CM -> Map ByteString ByteString
_hmm :: CM -> Maybe HMM3
version :: Lens' CM CMVersion
unsorted :: Lens' CM (Map ByteString ByteString)
trustedCutoff :: Lens' CM BitScore
states :: Lens' CM (Map StateID State)
nullModel :: Lens' CM (Vector BitScore)
noiseCutoff :: Lens' CM (Maybe BitScore)
nodes :: Lens' CM (Map NodeID (NodeType, [StateID]))
name :: Lens' CM (Identification Rfam)
localEnd :: Lens' CM (Map StateID BitScore)
localBegin :: Lens' CM (Map StateID BitScore)
hmm :: Lens' CM (Maybe HMM3)
gathering :: Lens' CM BitScore
accession :: Lens' CM (Accession Rfam)

-- | Map of model names to individual CMs.
type ID2CM = Map (Identification Rfam) CM

-- | Map of model accession numbers to individual CMs.
type AC2CM = Map (Accession Rfam) CM

-- | Make a CM have local start/end behaviour, with <a>pbegin</a> and
--   <a>pend</a> probabilities given.
makeLocal :: Double -> Double -> CM -> CM

-- | Insert all legal local beginnings, disable root node (and root
--   states). The <tt>pbegin</tt> probability the the total probability for
--   local begins. The remaining <a>1-pbegin</a> is the probability to
--   start with node 1.
makeLocalBegin :: Double -> CM -> CM

-- | Insert all legal local ends.
makeLocalEnd :: Double -> CM -> CM
instance ExtShape sh => ExtShape (sh :. StateID)
instance Shape sh => Shape (sh :. StateID)
instance Show CM
instance Read CM
instance Eq State
instance Ord State
instance Show State
instance Read State
instance Eq CMVersion
instance Ord CMVersion
instance Show CMVersion
instance Read CMVersion
instance Eq NodeType
instance Ord NodeType
instance Enum NodeType
instance Show NodeType
instance Read NodeType
instance Eq NodeID
instance Ord NodeID
instance Show NodeID
instance Read NodeID
instance Eq StateType
instance Ord StateType
instance Enum StateType
instance Show StateType
instance Read StateType
instance Eq StateID
instance Ord StateID
instance Show StateID
instance Read StateID
instance Prim StateID
instance Ix StateID
instance Enum StateID
instance Num StateID
instance Eq Emits
instance Ord Emits
instance Show Emits
instance Read Emits


-- | Parses text-based covariance-model descriptions.
module Biobase.SElab.CM.Import
parseHeader :: Parser CMVersion
lineParser :: Monad m => Parser b -> Pipe l ByteString o u m b

-- | Top-level parser for Infernal 1.0 and 1.1 human-readable covariance
--   models. Reads all lines first, then builds up the CM.
parseCM1x :: (Monad m, MonadIO m) => Conduit ByteString m CM
readBS :: Read c => ByteString -> c
readBitScore :: ByteString -> BitScore
readAccession :: Read a => ByteString -> a

-- | Infernal 1.0 header parser. Greps all lines until the <a>MODEL:</a>
--   line, then return lines to top-level parser. Parses three lines at
--   once in case of <a>FT-</a> lines.
parseHeaders :: Monad m => [ByteString] -> Pipe l ByteString o u m (Map ByteString ByteString)
finishedHeader :: Maybe ByteString -> Bool
parseNodes :: Monad m => CMVersion -> [(NodeType, NodeID, [State])] -> Pipe ByteString ByteString o u m [(NodeType, NodeID, [State])]
parseStates :: Monad m => CMVersion -> NodeType -> NodeID -> [State] -> Pipe ByteString ByteString o u m [State]
parseState :: CMVersion -> NodeType -> NodeID -> ByteString -> State

-- | Determine if a line is a node line (<a>Just</a>). If yes, we'll get
--   the node type as string and the node identifier, too.
isNode :: Maybe ByteString -> Maybe (NodeType, NodeID)
fromFile :: FilePath -> IO [CM]
test :: IO ()
