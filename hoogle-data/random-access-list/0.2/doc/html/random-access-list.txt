-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Random-access lists in Haskell
--   
--   A purely functional random-access list implementation using skew
--   binary number representation. These lists offer indexed random-access
--   in logarithmic time while still providing typical list functionality
--   (head, tail, cons) in constant time. See "Purely Functional Data
--   Structures" by Chris Okasaki.
@package random-access-list
@version 0.2


-- | A random-access list implementation based on Chris Okasaki's approach
--   on his book "Purely Functional Data Structures", Cambridge University
--   Press, 1998, chapter 9.3.
--   
--   <a>RandomAccessList</a>s are finite lists providing random-access
--   (<a>lookup</a>, <a>update</a>, etc.) in <i>O(log n)</i> while the list
--   functionality <a>head</a>, <a>tail</a> and <a>cons</a> still works in
--   <i>O(1)</i>.
--   
--   A <a>RandomAccessList</a> uses <a>Int</a>s for effective indexing. The
--   valid index range of a <a>RandomAccessList</a> of size <tt>n</tt> is
--   <tt>[0 .. n-1]</tt>. If an index is out of range, an <a>error</a> is
--   raised.
module Data.RandomAccessList

-- | Random-access lists allowing <i>O(1)</i> list operations and <i>O(log
--   n)</i> indexed access.
data RandomAccessList a

-- | View the end of a <a>RandomAccessList</a> which is either empty or has
--   been constructed by <a>head</a> and <a>tail</a>.
data View a

-- | An empty <a>RandomAccessList</a>.
Empty :: View a

-- | <a>head</a> and <a>tail</a> of a non-empty <a>RandomAccessList</a>.
Cons :: a -> (RandomAccessList a) -> View a

-- | <i>O(1)</i>. Builds an empty <a>RandomAccessList</a>.
empty :: RandomAccessList a

-- | <i>O(1)</i>. Builds a singleton <a>RandomAccessList</a>.
singleton :: a -> RandomAccessList a

-- | <i>O(n)</i>. <tt><a>replicate</a> n x</tt> constructs a
--   <a>RandomAccessList</a> that contains the same element <tt>x</tt>
--   <tt>n</tt> times.
replicate :: Int -> a -> RandomAccessList a

-- | <i>O(1)</i>. Is the <a>RandomAccessList</a> empty?
null :: RandomAccessList a -> Bool

-- | <i>O(1)</i>. Is the <a>RandomAccessList</a> empty?
isEmpty :: RandomAccessList a -> Bool

-- | <i>O(1)</i>. The number of elements contained in a
--   <a>RandomAccessList</a>.
length :: RandomAccessList a -> Int

-- | <i>O(1)</i>. The number of elements contained in a
--   <a>RandomAccessList</a>.
size :: RandomAccessList a -> Int

-- | <i>O(n)</i>. Is the given element a member of the
--   <a>RandomAccessList</a>?
member :: Eq a => a -> RandomAccessList a -> Bool

-- | <i>O(n)</i>. Find the index of a given element.
index :: Eq a => a -> RandomAccessList a -> Maybe Int

-- | <i>O(1)</i>. Returns the head of a <a>RandomAccessList</a>.
head :: RandomAccessList a -> a

-- | <i>O(1)</i>. Retrieve the tail of a <a>RandomAccessList</a>.
tail :: RandomAccessList a -> RandomAccessList a

-- | <i>O(1)</i>. Retrieve both, <a>head</a> and <a>tail</a> of a
--   <a>RandomAccessList</a>.
uncons :: RandomAccessList a -> (a, RandomAccessList a)

-- | <i>O(1)</i>. Examine a <a>RandomAccessList</a>: Either it is
--   <a>Empty</a> or it has a <a>head</a> and a <a>tail</a> (packed in
--   <a>Cons</a>).
view :: RandomAccessList a -> View a

-- | <i>O(1)</i>. Prepend an element to the <a>RandomAccessList</a>.
cons :: a -> RandomAccessList a -> RandomAccessList a

-- | <i>O(n)</i> where <i>n</i> is the <a>length</a> of the first list.
--   Appends the second list to the first list.
append :: RandomAccessList a -> RandomAccessList a -> RandomAccessList a

-- | <i>O(log n)</i>. Retrieve the <i>i</i>th element of the list. Unless
--   <i>0 &lt;= i &lt; n</i>, an <a>error</a> is raised.
lookup :: Int -> RandomAccessList a -> a

-- | <i>O(log n)</i>. Set the <i>i</i>th element of the list. Unless <i>0
--   &lt;= i &lt; n</i>, an <a>error</a> is raised.
update :: Int -> a -> RandomAccessList a -> RandomAccessList a

-- | <i>O(log n)</i>. Adjust <i>i</i>th element of the list according to
--   the given function. Unless <i>0 &lt;= i &lt; n</i>, an <a>error</a> is
--   raised.
adjust :: (a -> a) -> Int -> RandomAccessList a -> RandomAccessList a

-- | <i>O(log n)</i>. Find the <i>i</i>th element of the list and change
--   it. This function returns the element that is at index <i>i</i> in the
--   original <a>RandomAccessList</a> and a new <a>RandomAccessList</a>
--   with the <i>i</i>th element replaced according to the given function:
--   
--   <pre>
--   lookup   index list === fst (adjustLookup undefined index list)
--   adjust f index list === snd (adjustLookup f         index list)
--   </pre>
--   
--   Unless <i>0 &lt;= i &lt; n</i>, an <a>error</a> is raised.
adjustLookup :: (a -> a) -> Int -> RandomAccessList a -> (a, RandomAccessList a)

-- | <i>O(n)</i>. Remove all elements from a <a>RandomAccessList</a> not
--   fulfilling a predicate.
filter :: (a -> Bool) -> RandomAccessList a -> RandomAccessList a

-- | <i>O(n)</i>. Split a <a>RandomAccessList</a> into two: The elements in
--   the first fulfill the given prefix, the others don't.
partition :: (a -> Bool) -> RandomAccessList a -> (RandomAccessList a, RandomAccessList a)

-- | <i>O(min(n, m))</i>. List-like <a>zip</a>. This function is slightly
--   faster when called with two <a>RandomAccessList</a>s of equal
--   <a>length</a>.
zip :: RandomAccessList a -> RandomAccessList b -> RandomAccessList (a, b)

-- | <i>O(min(n, m))</i>. List-like <a>zipWith</a>. This function is
--   slightly faster when called with two <a>RandomAccessList</a>s of equal
--   <a>length</a>.
zipWith :: (a -> b -> c) -> RandomAccessList a -> RandomAccessList b -> RandomAccessList c

-- | <i>O(n)</i>. List-like <tt>Prelude.unzip</tt> for
--   <a>RandomAccessList</a>s.
unzip :: RandomAccessList (a, b) -> (RandomAccessList a, RandomAccessList b)

-- | <i>O(n)</i>. Build a <a>RandomAccessList</a> from a list.
fromList :: [a] -> RandomAccessList a

-- | <i>O(n)</i>. Convert a <a>RandomAccessList</a> to a list.
toList :: RandomAccessList a -> [a]

-- | <i>O(n)</i>. Convert a <a>RandomAccessList</a> to a list of tuples
--   each holding an element and its index. The list is ordered ascending
--   regarding the indices.
toIndexedList :: RandomAccessList a -> [(Int, a)]

-- | <i>O(n)</i>. Build a <a>Map</a> from a <a>RandomAccessList</a>. The
--   keys in the <a>Map</a> are the indices of the elements in the
--   <a>RandomAccessList</a>.
toMap :: RandomAccessList a -> Map Int a

-- | <i>O(n)</i>. Build an <a>IntMap</a> from a <a>RandomAccessList</a>.
--   The keys in the <a>IntMap</a> are the indices of the elements in the
--   <a>RandomAccessList</a>.
toIntMap :: RandomAccessList a -> IntMap a

-- | <i>O(n)</i>. Given an <a>IArray</a>, generate a
--   <a>RandomAccessList</a>. The elements' order will be preserved.
fromArray :: (IArray a e, Ix i) => a i e -> RandomAccessList e

-- | <i>O(n)</i>. Build an <a>IArray</a> from the <a>RandomAccessList</a>.
--   It will have an index range from <tt>[0 .. n-1]</tt>, where <tt>n</tt>
--   is the <a>RandomAccessList</a>s <a>length</a>.
toArray :: IArray a e => RandomAccessList e -> a Int e
instance Show a => Show (View a)
instance Read a => Read (View a)
instance Eq a => Eq (View a)
instance Ord a => Ord (View a)
instance Eq a => Eq (CBTree a)
instance Foldable View
instance Functor View
instance Functor CBTree
instance Foldable RandomAccessList
instance Functor RandomAccessList
instance Monoid (RandomAccessList a)
instance Ord a => Ord (RandomAccessList a)
instance Eq a => Eq (RandomAccessList a)
instance Read a => Read (RandomAccessList a)
instance Show a => Show (RandomAccessList a)
