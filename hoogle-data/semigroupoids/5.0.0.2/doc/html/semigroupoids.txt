-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Semigroupoids: Category sans id
--   
@package semigroupoids
@version 5.0.0.2


-- | Placeholders for missing instances of <tt>Traversable</tt>, and
--   <tt>Foldable</tt> until base catches up and adds them. Many of these
--   are re-exports from the `base-orphans` package.
module Data.Traversable.Instances


module Data.Semigroup.Foldable.Class
class Foldable t => Foldable1 t where foldMap1 f = maybe (error "foldMap1") id . getOption . foldMap (Option . Just . f) fold1 = foldMap1 id
fold1 :: (Foldable1 t, Semigroup m) => t m -> m
foldMap1 :: (Foldable1 t, Semigroup m) => (a -> m) -> t a -> m
class Bifoldable t => Bifoldable1 t where bifold1 = bifoldMap1 id id bifoldMap1 f g = maybe (error "bifoldMap1") id . getOption . bifoldMap (Option . Just . f) (Option . Just . g)
bifold1 :: (Bifoldable1 t, Semigroup m) => t m m -> m
bifoldMap1 :: (Bifoldable1 t, Semigroup m) => (a -> m) -> (b -> m) -> t a b -> m
instance Foldable1 g => Foldable1 (Joker g a)
instance Foldable1 ((,) a)
instance Foldable1 NonEmpty
instance (Foldable1 f, Foldable1 g) => Foldable1 (Coproduct f g)
instance (Foldable1 f, Foldable1 g) => Foldable1 (Sum f g)
instance Foldable1 f => Foldable1 (Reverse f)
instance (Foldable1 f, Foldable1 g) => Foldable1 (Product f g)
instance Foldable1 f => Foldable1 (Lift f)
instance (Foldable1 f, Foldable1 g) => Foldable1 (Compose f g)
instance Foldable1 f => Foldable1 (Backwards f)
instance Foldable1 m => Foldable1 (IdentityT m)
instance Foldable1 Identity
instance Foldable1 Tree
instance Bifoldable1 p => Bifoldable1 (WrappedBifunctor p)
instance (Foldable1 f, Bifoldable1 p) => Bifoldable1 (Tannen f p)
instance (Bifoldable1 f, Bifoldable1 g) => Bifoldable1 (Product f g)
instance Foldable1 g => Bifoldable1 (Joker g)
instance Bifoldable1 p => Foldable1 (Join p)
instance Bifoldable1 p => Bifoldable1 (Flip p)
instance Foldable1 f => Bifoldable1 (Clown f)
instance (Bifoldable1 p, Foldable1 f, Foldable1 g) => Bifoldable1 (Biff p f g)
instance Bifoldable1 Tagged
instance Bifoldable1 Const
instance Bifoldable1 ((,,,,) x y z)
instance Bifoldable1 ((,,,) x y)
instance Bifoldable1 ((,,) x)
instance Bifoldable1 (,)
instance Bifoldable1 Either
instance Bifoldable1 Arg


module Data.Functor.Extend
class Functor w => Extend w where extended f = fmap f . duplicated duplicated = extended id
duplicated :: Extend w => w a -> w (w a)
extended :: Extend w => (w a -> b) -> w a -> w b
instance [safe] Extend NonEmpty
instance [safe] Extend w => Extend (IdentityT w)
instance [safe] Extend Identity
instance [safe] (Extend w, Semigroup m) => Extend (TracedT m w)
instance [safe] Extend w => Extend (StoreT s w)
instance [safe] Extend w => Extend (EnvT e w)
instance [safe] (Extend f, Extend g) => Extend (Coproduct f g)
instance [safe] Extend Tree
instance [safe] Extend Seq
instance [safe] Semigroup m => Extend ((->) m)
instance [safe] Extend ((,) e)
instance [safe] Extend (Either a)
instance [safe] Extend Maybe
instance [safe] Extend []


-- | This module is used to resolve the cyclic we get from defining these
--   classes here rather than in a package upstream. Otherwise we'd get
--   orphaned heads for many instances on the types in
--   <tt>transformers</tt> and <tt>bifunctors</tt>.
module Data.Functor.Bind.Class

-- | A strong lax semi-monoidal endofunctor. This is equivalent to an
--   <a>Applicative</a> without <a>pure</a>.
--   
--   Laws:
--   
--   <pre>
--   associative composition: (.) &lt;$&gt; u &lt;.&gt; v &lt;.&gt; w = u &lt;.&gt; (v &lt;.&gt; w)
--   </pre>
class Functor f => Apply f where a .> b = const id <$> a <.> b a <. b = const <$> a <.> b
(<.>) :: Apply f => f (a -> b) -> f a -> f b
(.>) :: Apply f => f a -> f b -> f b
(<.) :: Apply f => f a -> f b -> f a

-- | Wrap an <a>Applicative</a> to be used as a member of <a>Apply</a>
newtype WrappedApplicative f a
WrapApplicative :: f a -> WrappedApplicative f a
unwrapApplicative :: WrappedApplicative f a -> f a

-- | Transform a Apply into an Applicative by adding a unit.
newtype MaybeApply f a
MaybeApply :: Either (f a) a -> MaybeApply f a
runMaybeApply :: MaybeApply f a -> Either (f a) a

-- | A <a>Monad</a> sans <a>return</a>.
--   
--   Minimal definition: Either <a>join</a> or <a>&gt;&gt;-</a>
--   
--   If defining both, then the following laws (the default definitions)
--   must hold:
--   
--   <pre>
--   join = (&gt;&gt;- id)
--   m &gt;&gt;- f = join (fmap f m)
--   </pre>
--   
--   Laws:
--   
--   <pre>
--   induced definition of &lt;.&gt;: f &lt;.&gt; x = f &gt;&gt;- (&lt;$&gt; x)
--   </pre>
--   
--   Finally, there are two associativity conditions:
--   
--   <pre>
--   associativity of (&gt;&gt;-):    (m &gt;&gt;- f) &gt;&gt;- g == m &gt;&gt;- (\x -&gt; f x &gt;&gt;- g)
--   associativity of join:     join . join = join . fmap join
--   </pre>
--   
--   These can both be seen as special cases of the constraint that
--   
--   <pre>
--   associativity of (-&gt;-): (f -&gt;- g) -&gt;- h = f -&gt;- (g -&gt;- h)
--   </pre>
class Apply m => Bind m where m >>- f = join (fmap f m) join = (>>- id)
(>>-) :: Bind m => m a -> (a -> m b) -> m b
join :: Bind m => m (m a) -> m a
apDefault :: Bind f => f (a -> b) -> f a -> f b
returning :: Functor f => f a -> (a -> b) -> f b
class Bifunctor p => Biapply p where a .>> b = bimap (const id) (const id) <<$>> a <<.>> b a <<. b = bimap const const <<$>> a <<.>> b
(<<.>>) :: Biapply p => p (a -> b) (c -> d) -> p a c -> p b d
(.>>) :: Biapply p => p a b -> p c d -> p c d
(<<.) :: Biapply p => p a b -> p c d -> p a b
instance [safe] Biapply p => Biapply (WrappedBifunctor p)
instance [safe] (Apply f, Biapply p) => Biapply (Tannen f p)
instance [safe] (Biapply p, Biapply q) => Biapply (Product p q)
instance [safe] Biapply p => Apply (Join p)
instance [safe] Apply g => Biapply (Joker g)
instance [safe] Biapply p => Biapply (Flip p)
instance [safe] Apply f => Biapply (Clown f)
instance [safe] (Biapply p, Apply f, Apply g) => Biapply (Biff p f g)
instance [safe] Biapply Tagged
instance [safe] Biapply Const
instance [safe] (Semigroup x, Semigroup y, Semigroup z) => Biapply ((,,,,) x y z)
instance [safe] (Semigroup x, Semigroup y) => Biapply ((,,,) x y)
instance [safe] Semigroup x => Biapply ((,,) x)
instance [safe] Biapply Arg
instance [safe] Biapply (,)
instance [safe] Bind Tree
instance [safe] Bind Seq
instance [safe] Bind IntMap
instance [safe] Ord k => Bind (Map k)
instance [safe] Bind (ContT r m)
instance [safe] (Bind m, Semigroup w) => Bind (RWST r w s m)
instance [safe] (Bind m, Semigroup w) => Bind (RWST r w s m)
instance [safe] Bind m => Bind (StateT s m)
instance [safe] Bind m => Bind (StateT s m)
instance [safe] (Bind m, Semigroup w) => Bind (WriterT w m)
instance [safe] (Bind m, Semigroup w) => Bind (WriterT w m)
instance [safe] Bind m => Bind (ReaderT e m)
instance [safe] (Functor m, Monad m) => Bind (ExceptT e m)
instance [safe] (Functor m, Monad m) => Bind (ErrorT e m)
instance [safe] (Apply m, Monad m) => Bind (ListT m)
instance [safe] (Functor m, Monad m) => Bind (MaybeT m)
instance [safe] Monad m => Bind (WrappedMonad m)
instance [safe] Bind m => Bind (IdentityT m)
instance [safe] Bind Identity
instance [safe] Bind Option
instance [safe] Bind Maybe
instance [safe] Bind IO
instance [safe] Bind NonEmpty
instance [safe] Bind []
instance [safe] Bind ((->) m)
instance [safe] (Bind f, Bind g) => Bind (Product f g)
instance [safe] Bind (Either a)
instance [safe] Semigroup m => Bind ((,) m)
instance [safe] Apply (Cokleisli w a)
instance [safe] Comonad f => Comonad (MaybeApply f)
instance [safe] Extend f => Extend (MaybeApply f)
instance [safe] Apply f => Applicative (MaybeApply f)
instance [safe] Apply f => Apply (MaybeApply f)
instance [safe] Functor f => Functor (MaybeApply f)
instance [safe] Alternative f => Alternative (WrappedApplicative f)
instance [safe] Applicative f => Applicative (WrappedApplicative f)
instance [safe] Applicative f => Apply (WrappedApplicative f)
instance [safe] Functor f => Functor (WrappedApplicative f)
instance [safe] Apply w => Apply (TracedT m w)
instance [safe] (Apply w, Semigroup s) => Apply (StoreT s w)
instance [safe] (Semigroup e, Apply w) => Apply (EnvT e w)
instance [safe] Apply (ContT r m)
instance [safe] (Bind m, Semigroup w) => Apply (RWST r w s m)
instance [safe] (Bind m, Semigroup w) => Apply (RWST r w s m)
instance [safe] Bind m => Apply (StateT s m)
instance [safe] Bind m => Apply (StateT s m)
instance [safe] (Apply m, Semigroup w) => Apply (WriterT w m)
instance [safe] (Apply m, Semigroup w) => Apply (WriterT w m)
instance [safe] Apply m => Apply (ListT m)
instance [safe] Apply m => Apply (ReaderT e m)
instance [safe] (Functor m, Monad m) => Apply (ExceptT e m)
instance [safe] (Functor m, Monad m) => Apply (ErrorT e m)
instance [safe] (Functor m, Monad m) => Apply (MaybeT m)
instance [safe] Apply Tree
instance [safe] Apply Seq
instance [safe] Apply IntMap
instance [safe] Ord k => Apply (Map k)
instance [safe] Arrow a => Apply (WrappedArrow a b)
instance [safe] Monad m => Apply (WrappedMonad m)
instance [safe] Apply w => Apply (IdentityT w)
instance [safe] Apply Identity
instance [safe] Apply Option
instance [safe] Apply Maybe
instance [safe] Apply IO
instance [safe] Apply []
instance [safe] Apply ZipList
instance [safe] Apply ((->) m)
instance [safe] Semigroup m => Apply (Const m)
instance [safe] Apply (Either a)
instance [safe] Apply NonEmpty
instance [safe] Semigroup m => Apply ((,) m)
instance [safe] Apply f => Apply (Reverse f)
instance [safe] (Apply f, Apply g) => Apply (Product f g)
instance [safe] Apply f => Apply (Lift f)
instance [safe] Semigroup f => Apply (Constant f)
instance [safe] (Apply f, Apply g) => Apply (Compose f g)
instance [safe] Apply f => Apply (Backwards f)


module Data.Functor.Apply

-- | The <a>Functor</a> class is used for types that can be mapped over.
--   Instances of <a>Functor</a> should satisfy the following laws:
--   
--   <pre>
--   fmap id  ==  id
--   fmap (f . g)  ==  fmap f . fmap g
--   </pre>
--   
--   The instances of <a>Functor</a> for lists, <a>Maybe</a> and <a>IO</a>
--   satisfy these laws.
class Functor (f :: * -> *)
fmap :: Functor f => (a -> b) -> f a -> f b
(<$) :: Functor f => a -> f b -> f a

-- | An infix synonym for <a>fmap</a>.
(<$>) :: Functor f => (a -> b) -> f a -> f b

-- | Flipped version of <a>&lt;$</a>.
--   
--   <i>Since: 4.7.0.0</i>
($>) :: Functor f => f a -> b -> f b

-- | A strong lax semi-monoidal endofunctor. This is equivalent to an
--   <a>Applicative</a> without <a>pure</a>.
--   
--   Laws:
--   
--   <pre>
--   associative composition: (.) &lt;$&gt; u &lt;.&gt; v &lt;.&gt; w = u &lt;.&gt; (v &lt;.&gt; w)
--   </pre>
class Functor f => Apply f where a .> b = const id <$> a <.> b a <. b = const <$> a <.> b
(<.>) :: Apply f => f (a -> b) -> f a -> f b
(.>) :: Apply f => f a -> f b -> f b
(<.) :: Apply f => f a -> f b -> f a

-- | A variant of <a>&lt;.&gt;</a> with the arguments reversed.
(<..>) :: Apply w => w a -> w (a -> b) -> w b

-- | Lift a binary function into a comonad with zipping
liftF2 :: Apply w => (a -> b -> c) -> w a -> w b -> w c

-- | Lift a ternary function into a comonad with zipping
liftF3 :: Apply w => (a -> b -> c -> d) -> w a -> w b -> w c -> w d

-- | Wrap an <a>Applicative</a> to be used as a member of <a>Apply</a>
newtype WrappedApplicative f a
WrapApplicative :: f a -> WrappedApplicative f a
unwrapApplicative :: WrappedApplicative f a -> f a

-- | Transform a Apply into an Applicative by adding a unit.
newtype MaybeApply f a
MaybeApply :: Either (f a) a -> MaybeApply f a
runMaybeApply :: MaybeApply f a -> Either (f a) a


module Data.Semigroup.Bifoldable
class Bifoldable t => Bifoldable1 t where bifold1 = bifoldMap1 id id bifoldMap1 f g = maybe (error "bifoldMap1") id . getOption . bifoldMap (Option . Just . f) (Option . Just . g)
bifold1 :: (Bifoldable1 t, Semigroup m) => t m m -> m
bifoldMap1 :: (Bifoldable1 t, Semigroup m) => (a -> m) -> (b -> m) -> t a b -> m
bitraverse1_ :: (Bifoldable1 t, Apply f) => (a -> f b) -> (c -> f d) -> t a c -> f ()
bifor1_ :: (Bifoldable1 t, Apply f) => t a c -> (a -> f b) -> (c -> f d) -> f ()
bisequenceA1_ :: (Bifoldable1 t, Apply f) => t (f a) (f b) -> f ()

-- | Usable default for foldMap, but only if you define bifoldMap1 yourself
bifoldMapDefault1 :: (Bifoldable1 t, Monoid m) => (a -> m) -> (b -> m) -> t a b -> m
instance Functor f => Functor (Act f)
instance Apply f => Semigroup (Act f a)


module Data.Functor.Bind

-- | The <a>Functor</a> class is used for types that can be mapped over.
--   Instances of <a>Functor</a> should satisfy the following laws:
--   
--   <pre>
--   fmap id  ==  id
--   fmap (f . g)  ==  fmap f . fmap g
--   </pre>
--   
--   The instances of <a>Functor</a> for lists, <a>Maybe</a> and <a>IO</a>
--   satisfy these laws.
class Functor (f :: * -> *)
fmap :: Functor f => (a -> b) -> f a -> f b
(<$) :: Functor f => a -> f b -> f a

-- | An infix synonym for <a>fmap</a>.
(<$>) :: Functor f => (a -> b) -> f a -> f b

-- | Flipped version of <a>&lt;$</a>.
--   
--   <i>Since: 4.7.0.0</i>
($>) :: Functor f => f a -> b -> f b

-- | A strong lax semi-monoidal endofunctor. This is equivalent to an
--   <a>Applicative</a> without <a>pure</a>.
--   
--   Laws:
--   
--   <pre>
--   associative composition: (.) &lt;$&gt; u &lt;.&gt; v &lt;.&gt; w = u &lt;.&gt; (v &lt;.&gt; w)
--   </pre>
class Functor f => Apply f where a .> b = const id <$> a <.> b a <. b = const <$> a <.> b
(<.>) :: Apply f => f (a -> b) -> f a -> f b
(.>) :: Apply f => f a -> f b -> f b
(<.) :: Apply f => f a -> f b -> f a

-- | A variant of <a>&lt;.&gt;</a> with the arguments reversed.
(<..>) :: Apply w => w a -> w (a -> b) -> w b

-- | Lift a binary function into a comonad with zipping
liftF2 :: Apply w => (a -> b -> c) -> w a -> w b -> w c

-- | Lift a ternary function into a comonad with zipping
liftF3 :: Apply w => (a -> b -> c -> d) -> w a -> w b -> w c -> w d

-- | Wrap an <a>Applicative</a> to be used as a member of <a>Apply</a>
newtype WrappedApplicative f a
WrapApplicative :: f a -> WrappedApplicative f a
unwrapApplicative :: WrappedApplicative f a -> f a

-- | Transform a Apply into an Applicative by adding a unit.
newtype MaybeApply f a
MaybeApply :: Either (f a) a -> MaybeApply f a
runMaybeApply :: MaybeApply f a -> Either (f a) a

-- | A <a>Monad</a> sans <a>return</a>.
--   
--   Minimal definition: Either <a>join</a> or <a>&gt;&gt;-</a>
--   
--   If defining both, then the following laws (the default definitions)
--   must hold:
--   
--   <pre>
--   join = (&gt;&gt;- id)
--   m &gt;&gt;- f = join (fmap f m)
--   </pre>
--   
--   Laws:
--   
--   <pre>
--   induced definition of &lt;.&gt;: f &lt;.&gt; x = f &gt;&gt;- (&lt;$&gt; x)
--   </pre>
--   
--   Finally, there are two associativity conditions:
--   
--   <pre>
--   associativity of (&gt;&gt;-):    (m &gt;&gt;- f) &gt;&gt;- g == m &gt;&gt;- (\x -&gt; f x &gt;&gt;- g)
--   associativity of join:     join . join = join . fmap join
--   </pre>
--   
--   These can both be seen as special cases of the constraint that
--   
--   <pre>
--   associativity of (-&gt;-): (f -&gt;- g) -&gt;- h = f -&gt;- (g -&gt;- h)
--   </pre>
class Apply m => Bind m where m >>- f = join (fmap f m) join = (>>- id)
(>>-) :: Bind m => m a -> (a -> m b) -> m b
join :: Bind m => m (m a) -> m a
(-<<) :: Bind m => (a -> m b) -> m a -> m b
(-<-) :: Bind m => (b -> m c) -> (a -> m b) -> a -> m c
(->-) :: Bind m => (a -> m b) -> (b -> m c) -> a -> m c
apDefault :: Bind f => f (a -> b) -> f a -> f b
returning :: Functor f => f a -> (a -> b) -> f b


module Data.Functor.Alt

-- | Laws:
--   
--   <pre>
--   &lt;!&gt; is associative:             (a &lt;!&gt; b) &lt;!&gt; c = a &lt;!&gt; (b &lt;!&gt; c)
--   &lt;$&gt; left-distributes over &lt;!&gt;:  f &lt;$&gt; (a &lt;!&gt; b) = (f &lt;$&gt; a) &lt;!&gt; (f &lt;$&gt; b)
--   </pre>
--   
--   If extended to an <a>Alternative</a> then <a>&lt;!&gt;</a> should
--   equal <a>&lt;|&gt;</a>.
--   
--   Ideally, an instance of <a>Alt</a> also satisfies the "left
--   distributon" law of MonadPlus with respect to <a>&lt;.&gt;</a>:
--   
--   <pre>
--   &lt;.&gt; right-distributes over &lt;!&gt;: (a &lt;!&gt; b) &lt;.&gt; c = (a &lt;.&gt; c) &lt;!&gt; (b &lt;.&gt; c)
--   </pre>
--   
--   But <a>Maybe</a>, <a>IO</a>, <tt><a>Either</a> a</tt>,
--   <tt><a>ErrorT</a> e m</tt>, and <tt>STM</tt> satisfy the alternative
--   "left catch" law instead:
--   
--   <pre>
--   pure a &lt;!&gt; b = pure a
--   </pre>
--   
--   However, this variation cannot be stated purely in terms of the
--   dependencies of <a>Alt</a>.
--   
--   When and if MonadPlus is successfully refactored, this class should
--   also be refactored to remove these instances.
--   
--   The right distributive law should extend in the cases where the a
--   <a>Bind</a> or <a>Monad</a> is provided to yield variations of the
--   right distributive law:
--   
--   <pre>
--   (m &lt;!&gt; n) &gt;&gt;- f = (m &gt;&gt;- f) &lt;!&gt; (m &gt;&gt;- f)
--   (m &lt;!&gt; n) &gt;&gt;= f = (m &gt;&gt;= f) &lt;!&gt; (m &gt;&gt;= f)
--   </pre>
class Functor f => Alt f where some v = some_v where many_v = some_v <!> pure [] some_v = (:) <$> v <*> many_v many v = many_v where many_v = some_v <!> pure [] some_v = (:) <$> v <*> many_v
(<!>) :: Alt f => f a -> f a -> f a
some :: (Alt f, Applicative f) => f a -> f [a]
many :: (Alt f, Applicative f) => f a -> f [a]
instance [safe] Alt f => Alt (Reverse f)
instance [safe] (Alt f, Alt g) => Alt (Product f g)
instance [safe] Alt f => Alt (Lift f)
instance [safe] (Alt f, Functor g) => Alt (Compose f g)
instance [safe] Alt f => Alt (Backwards f)
instance [safe] Alt f => Alt (RWST r w s f)
instance [safe] Alt f => Alt (RWST r w s f)
instance [safe] Alt f => Alt (WriterT w f)
instance [safe] Alt f => Alt (WriterT w f)
instance [safe] Alt f => Alt (StateT e f)
instance [safe] Alt f => Alt (StateT e f)
instance [safe] Apply f => Alt (ListT f)
instance [safe] (Bind f, Monad f, Semigroup e) => Alt (ExceptT e f)
instance [safe] (Bind f, Monad f) => Alt (ErrorT e f)
instance [safe] (Bind f, Monad f) => Alt (MaybeT f)
instance [safe] Alt f => Alt (ReaderT e f)
instance [safe] Alt f => Alt (IdentityT f)
instance [safe] Alternative f => Alt (WrappedApplicative f)
instance [safe] Alt NonEmpty
instance [safe] Alt Seq
instance [safe] Alt IntMap
instance [safe] Ord k => Alt (Map k)
instance [safe] ArrowPlus a => Alt (WrappedArrow a b)
instance [safe] MonadPlus m => Alt (WrappedMonad m)
instance [safe] Alt Option
instance [safe] Alt Maybe
instance [safe] Alt []
instance [safe] Alt IO
instance [safe] Alt (Either a)


module Data.Semigroup.Foldable
class Foldable t => Foldable1 t where foldMap1 f = maybe (error "foldMap1") id . getOption . foldMap (Option . Just . f) fold1 = foldMap1 id
fold1 :: (Foldable1 t, Semigroup m) => t m -> m
foldMap1 :: (Foldable1 t, Semigroup m) => (a -> m) -> t a -> m

-- | Insert an <tt>m</tt> between each pair of 't m'. Equivalent to
--   <a>intercalateMap1</a> with <a>id</a> as the second argument.
--   
--   <pre>
--   &gt;&gt;&gt; intercalate1 ", " $ "hello" :| ["how", "are", "you"]
--   "hello, how, are, you"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intercalate1 ", " $ "hello" :| []
--   "hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intercalate1 mempty $ "I" :| ["Am", "Fine", "You?"]
--   "IAmFineYou?"
--   </pre>
intercalate1 :: (Foldable1 t, Semigroup m) => m -> t m -> m

-- | Insert <tt>m</tt> between each pair of <tt>m</tt> derived from
--   <tt>a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; intercalateMap1 " " show $ True :| [False, True]
--   "True False True"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intercalateMap1 " " show $ True :| []
--   "True"
--   </pre>
intercalateMap1 :: (Foldable1 t, Semigroup m) => m -> (a -> m) -> t a -> m
traverse1_ :: (Foldable1 t, Apply f) => (a -> f b) -> t a -> f ()
for1_ :: (Foldable1 t, Apply f) => t a -> (a -> f b) -> f ()
sequenceA1_ :: (Foldable1 t, Apply f) => t (f a) -> f ()

-- | Usable default for foldMap, but only if you define foldMap1 yourself
foldMapDefault1 :: (Foldable1 t, Monoid m) => (a -> m) -> t a -> m
asum1 :: (Foldable1 t, Alt m) => t (m a) -> m a
instance Alt f => Semigroup (Alt_ f a)
instance Functor f => Functor (Act f)
instance Apply f => Semigroup (Act f a)
instance Semigroup a => Semigroup (JoinWith a)


module Data.Semigroup.Traversable.Class
class (Bifoldable1 t, Bitraversable t) => Bitraversable1 t where bitraverse1 f g = bisequence1 . bimap f g bisequence1 = bitraverse1 id id
bitraverse1 :: (Bitraversable1 t, Apply f) => (a -> f b) -> (c -> f d) -> t a c -> f (t b d)
bisequence1 :: (Bitraversable1 t, Apply f) => t (f a) (f b) -> f (t a b)
class (Foldable1 t, Traversable t) => Traversable1 t where sequence1 = traverse1 id traverse1 f = sequence1 . fmap f
traverse1 :: (Traversable1 t, Apply f) => (a -> f b) -> t a -> f (t b)
sequence1 :: (Traversable1 t, Apply f) => t (f b) -> f (t b)
instance Traversable1 g => Traversable1 (Joker g a)
instance Traversable1 ((,) a)
instance Traversable1 NonEmpty
instance Traversable1 Tree
instance (Traversable1 f, Traversable1 g) => Traversable1 (Coproduct f g)
instance (Traversable1 f, Traversable1 g) => Traversable1 (Sum f g)
instance Traversable1 f => Traversable1 (Reverse f)
instance (Traversable1 f, Traversable1 g) => Traversable1 (Product f g)
instance Traversable1 f => Traversable1 (Lift f)
instance (Traversable1 f, Traversable1 g) => Traversable1 (Compose f g)
instance Traversable1 f => Traversable1 (Backwards f)
instance Traversable1 f => Traversable1 (IdentityT f)
instance Traversable1 Identity
instance Bitraversable1 p => Bitraversable1 (WrappedBifunctor p)
instance (Traversable1 f, Bitraversable1 p) => Bitraversable1 (Tannen f p)
instance (Bitraversable1 f, Bitraversable1 g) => Bitraversable1 (Product f g)
instance Traversable1 g => Bitraversable1 (Joker g)
instance Bitraversable1 p => Traversable1 (Join p)
instance Bitraversable1 p => Bitraversable1 (Flip p)
instance Traversable1 f => Bitraversable1 (Clown f)
instance (Bitraversable1 p, Traversable1 f, Traversable1 g) => Bitraversable1 (Biff p f g)
instance Bitraversable1 Tagged
instance Bitraversable1 Const
instance Bitraversable1 ((,,,,) x y z)
instance Bitraversable1 ((,,,) x y)
instance Bitraversable1 ((,,) x)
instance Bitraversable1 (,)
instance Bitraversable1 Either
instance Bitraversable1 Arg


module Data.Semigroup.Bitraversable
class (Bifoldable1 t, Bitraversable t) => Bitraversable1 t where bitraverse1 f g = bisequence1 . bimap f g bisequence1 = bitraverse1 id id
bitraverse1 :: (Bitraversable1 t, Apply f) => (a -> f b) -> (c -> f d) -> t a c -> f (t b d)
bisequence1 :: (Bitraversable1 t, Apply f) => t (f a) (f b) -> f (t a b)
bifoldMap1Default :: (Bitraversable1 t, Semigroup m) => (a -> m) -> (b -> m) -> t a b -> m


module Data.Semigroup.Traversable
class (Foldable1 t, Traversable t) => Traversable1 t where sequence1 = traverse1 id traverse1 f = sequence1 . fmap f
traverse1 :: (Traversable1 t, Apply f) => (a -> f b) -> t a -> f (t b)
sequence1 :: (Traversable1 t, Apply f) => t (f b) -> f (t b)
foldMap1Default :: (Traversable1 f, Semigroup m) => (a -> m) -> f a -> m


module Data.Functor.Bind.Trans

-- | A subset of monad transformers can transform any <a>Bind</a> as well.
class MonadTrans t => BindTrans t
liftB :: (BindTrans t, Bind b) => b a -> t b a
instance BindTrans (ContT r)
instance (Semigroup w, Monoid w) => BindTrans (RWST r w s)
instance (Semigroup w, Monoid w) => BindTrans (RWST r w s)
instance BindTrans (StateT s)
instance BindTrans (StateT s)
instance (Semigroup w, Monoid w) => BindTrans (WriterT w)
instance (Semigroup w, Monoid w) => BindTrans (WriterT w)
instance BindTrans (ReaderT e)
instance BindTrans IdentityT


module Data.Functor.Plus

-- | Laws:
--   
--   <pre>
--   zero &lt;!&gt; m = m
--   m &lt;!&gt; zero = m
--   </pre>
--   
--   If extended to an <a>Alternative</a> then <a>zero</a> should equal
--   <a>empty</a>.
class Alt f => Plus f
zero :: Plus f => f a
instance [safe] Plus f => Plus (Reverse f)
instance [safe] (Plus f, Plus g) => Plus (Product f g)
instance [safe] Plus f => Plus (Lift f)
instance [safe] (Plus f, Functor g) => Plus (Compose f g)
instance [safe] Plus f => Plus (Backwards f)
instance [safe] Plus f => Plus (RWST r w s f)
instance [safe] Plus f => Plus (RWST r w s f)
instance [safe] Plus f => Plus (WriterT w f)
instance [safe] Plus f => Plus (WriterT w f)
instance [safe] Plus f => Plus (StateT e f)
instance [safe] Plus f => Plus (StateT e f)
instance [safe] (Apply f, Applicative f) => Plus (ListT f)
instance [safe] (Bind f, Monad f, Semigroup e, Monoid e) => Plus (ExceptT e f)
instance [safe] (Bind f, Monad f, Error e) => Plus (ErrorT e f)
instance [safe] (Bind f, Monad f) => Plus (MaybeT f)
instance [safe] Plus f => Plus (ReaderT e f)
instance [safe] Plus f => Plus (IdentityT f)
instance [safe] Alternative f => Plus (WrappedApplicative f)
instance [safe] Plus Seq
instance [safe] Plus IntMap
instance [safe] Ord k => Plus (Map k)
instance [safe] ArrowPlus a => Plus (WrappedArrow a b)
instance [safe] MonadPlus m => Plus (WrappedMonad m)
instance [safe] Plus Option
instance [safe] Plus Maybe
instance [safe] Plus []
instance [safe] Plus IO


-- | A semigroupoid satisfies all of the requirements to be a Category
--   except for the existence of identity arrows.
module Data.Semigroupoid

-- | <a>Category</a> sans <a>id</a>
class Semigroupoid c
o :: Semigroupoid c => c j k -> c i j -> c i k
newtype WrappedCategory k a b
WrapCategory :: k a b -> WrappedCategory k a b
unwrapCategory :: WrappedCategory k a b -> k a b
newtype Semi m a b
Semi :: m -> Semi m a b
getSemi :: Semi m a b -> m
instance [safe] Monoid m => Category (Semi m)
instance [safe] Semigroup m => Semigroupoid (Semi m)
instance [safe] Category k1 => Category (WrappedCategory k1)
instance [safe] Category k1 => Semigroupoid (WrappedCategory k1)
instance [safe] Semigroupoid Op
instance [safe] Extend w => Semigroupoid (Cokleisli w)
instance [safe] Bind m => Semigroupoid (Kleisli m)
instance [safe] Semigroupoid (,)
instance [safe] Semigroupoid (->)


-- | A semigroupoid satisfies all of the requirements to be a Category
--   except for the existence of identity arrows.
module Data.Semigroupoid.Dual
newtype Dual k a b
Dual :: k b a -> Dual k a b
getDual :: Dual k a b -> k b a
instance Category k1 => Category (Dual k1)
instance Semigroupoid k1 => Semigroupoid (Dual k1)


module Data.Groupoid

-- | semigroupoid with inverses. This technically should be a category with
--   inverses, except we need to use Ob to define the valid objects for the
--   category
class Semigroupoid k => Groupoid k
inv :: Groupoid k => k a b -> k b a
instance Groupoid k1 => Groupoid (Dual k1)


module Data.Isomorphism
data Iso k a b
Iso :: k a b -> k b a -> Iso k a b
embed :: Iso k a b -> k a b
project :: Iso k a b -> k b a
instance Category k1 => Category (Iso k1)
instance Semigroupoid k1 => Groupoid (Iso k1)
instance Semigroupoid k1 => Semigroupoid (Iso k1)


module Data.Semigroupoid.Static
newtype Static f a b
Static :: f (a -> b) -> Static f a b
runStatic :: Static f a b -> f (a -> b)
instance [safe] Applicative f => ArrowChoice (Static f)
instance [safe] Alternative f => ArrowPlus (Static f)
instance [safe] Alternative f => ArrowZero (Static f)
instance [safe] Applicative f => Arrow (Static f)
instance [safe] Applicative f => Category (Static f)
instance [safe] Apply f => Semigroupoid (Static f)
instance [safe] (Comonad f, Monoid a) => Comonad (Static f a)
instance [safe] (Extend f, Semigroup a) => Extend (Static f a)
instance [safe] Applicative f => Applicative (Static f a)
instance [safe] Plus f => Plus (Static f a)
instance [safe] Alt f => Alt (Static f a)
instance [safe] Apply f => Apply (Static f a)
instance [safe] Functor f => Functor (Static f a)


module Data.Semigroupoid.Ob
class Semigroupoid k => Ob k a
semiid :: Ob k a => k a a
instance Ob (->) a
instance (Extend w, Comonad w) => Ob (Cokleisli w) a
instance (Bind m, Monad m) => Ob (Kleisli m) a


module Data.Bifunctor.Apply

-- | Minimal definition either <a>bimap</a> or <a>first</a> and
--   <a>second</a>
--   
--   Formally, the class <a>Bifunctor</a> represents a bifunctor from
--   <tt>Hask</tt> -&gt; <tt>Hask</tt>.
--   
--   Intuitively it is a bifunctor where both the first and second
--   arguments are covariant.
--   
--   You can define a <a>Bifunctor</a> by either defining <a>bimap</a> or
--   by defining both <a>first</a> and <a>second</a>.
--   
--   If you supply <a>bimap</a>, you should ensure that:
--   
--   <pre>
--   <a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply <a>first</a> and <a>second</a>, ensure:
--   
--   <pre>
--   <a>first</a> <a>id</a> ≡ <a>id</a>
--   <a>second</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply both, you should also ensure:
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   These ensure by parametricity:
--   
--   <pre>
--   <a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i
--   <a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g
--   <a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g
--   </pre>
class Bifunctor (p :: * -> * -> *)
bimap :: Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
first :: Bifunctor p => (a -> b) -> p a c -> p b c
second :: Bifunctor p => (b -> c) -> p a b -> p a c
class Bifunctor p => Biapply p where a .>> b = bimap (const id) (const id) <<$>> a <<.>> b a <<. b = bimap const const <<$>> a <<.>> b
(<<.>>) :: Biapply p => p (a -> b) (c -> d) -> p a c -> p b d
(.>>) :: Biapply p => p a b -> p c d -> p c d
(<<.) :: Biapply p => p a b -> p c d -> p a b
(<<$>>) :: (a -> b) -> a -> b
(<<..>>) :: Biapply p => p a c -> p (a -> b) (c -> d) -> p b d

-- | Lift binary functions
bilift2 :: Biapply w => (a -> b -> c) -> (d -> e -> f) -> w a d -> w b e -> w c f

-- | Lift ternary functions
bilift3 :: Biapply w => (a -> b -> c -> d) -> (e -> f -> g -> h) -> w a e -> w b f -> w c g -> w d h
