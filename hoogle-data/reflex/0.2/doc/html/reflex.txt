-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Higher-order Functional Reactive Programming
--   
@package reflex
@version 0.2

module Data.Functor.Misc
data WrapArg :: (* -> *) -> (* -> *) -> * -> *
WrapArg :: f a -> WrapArg g f (g a)
data Const2 :: * -> * -> * -> *
Const2 :: k -> Const2 k v v
sequenceDmap :: (Monad m, GCompare f) => DMap (WrapArg m f) -> m (DMap f)
combineDMapsWithKey :: GCompare f => (forall a. f a -> These (g a) (h a) -> i a) -> DMap (WrapArg g f) -> DMap (WrapArg h f) -> DMap (WrapArg i f)
wrapDMap :: (forall a. a -> f a) -> DMap k -> DMap (WrapArg f k)
rewrapDMap :: (forall a. f a -> g a) -> DMap (WrapArg f k) -> DMap (WrapArg g k)
unwrapDMap :: (forall a. f a -> a) -> DMap (WrapArg f k) -> DMap k
mapToDMap :: Map k v -> DMap (Const2 k v)
mapWithFunctorToDMap :: Map k (f v) -> DMap (WrapArg f (Const2 k v))
dmapToMap :: DMap (Const2 k v) -> Map k v
instance Typeable Const2
instance Ord k => GCompare (Const2 k v)
instance Eq k => GEq (Const2 k v)
instance GCompare f => GCompare (WrapArg g f)
instance GEq f => GEq (WrapArg g f)

module Reflex.Class
class (MonadHold t (PushM t), MonadSample t (PullM t), Functor (Event t), Functor (Behavior t)) => Reflex t where data family Behavior t :: * -> * data family Event t :: * -> * type family PushM t :: * -> * type family PullM t :: * -> *
never :: Reflex t => Event t a
constant :: Reflex t => a -> Behavior t a
push :: Reflex t => (a -> PushM t (Maybe b)) -> Event t a -> Event t b
pull :: Reflex t => PullM t a -> Behavior t a
merge :: (Reflex t, GCompare k) => DMap (WrapArg (Event t) k) -> Event t (DMap k)
fan :: (Reflex t, GCompare k) => Event t (DMap k) -> EventSelector t k
switch :: Reflex t => Behavior t (Event t a) -> Event t a
coincidence :: Reflex t => Event t (Event t a) -> Event t a
class Monad m => MonadSample t m | m -> t
sample :: MonadSample t m => Behavior t a -> m a
class MonadSample t m => MonadHold t m
hold :: MonadHold t m => a -> Event t a -> m (Behavior t a)
newtype EventSelector t k
EventSelector :: (forall a. k a -> Event t a) -> EventSelector t k
select :: EventSelector t k -> forall a. k a -> Event t a

-- | Create an Event from another Event. The provided function can sample
--   <a>Behavior</a>s and hold <a>Event</a>s.
pushAlways :: Reflex t => (a -> PushM t b) -> Event t a -> Event t b

-- | Flipped version of <a>fmap</a>.
ffor :: Functor f => f a -> (a -> b) -> f b

-- | A class for values that combines filtering and mapping using
--   <a>Maybe</a>.
class FunctorMaybe f
fmapMaybe :: FunctorMaybe f => (a -> Maybe b) -> f a -> f b

-- | Flipped version of <a>fmapMaybe</a>.
fforMaybe :: FunctorMaybe f => f a -> (a -> Maybe b) -> f b

-- | Filter 'f a' using the provided predicate. Relies on <a>fforMaybe</a>.
ffilter :: FunctorMaybe f => (a -> Bool) -> f a -> f a

-- | Create a new <a>Event</a> by combining each occurence with the next
--   value of the list using the supplied function. If the list runs out of
--   items, all subsequent <a>Event</a> occurrences will be ignored.
zipListWithEvent :: (Reflex t, MonadHold t m, MonadFix m) => (a -> b -> c) -> [a] -> Event t b -> m (Event t c)

-- | Replace each occurrence value of the <a>Event</a> with the value of
--   the <a>Behavior</a> at the time of that occurrence.
tag :: Reflex t => Behavior t b -> Event t a -> Event t b

-- | Create a new <a>Event</a> that combines occurences of supplied
--   <a>Event</a> with the current value of the <a>Behavior</a>.
attach :: Reflex t => Behavior t a -> Event t b -> Event t (a, b)

-- | Create a new <a>Event</a> that occurs when the supplied <a>Event</a>
--   occurs by combining it with the current value of the <a>Behavior</a>.
attachWith :: Reflex t => (a -> b -> c) -> Behavior t a -> Event t b -> Event t c

-- | Create a new <a>Event</a> by combining each occurence with the current
--   value of the <a>Behavior</a>. The occurrence is discarded if the
--   combining function returns Nothing
attachWithMaybe :: Reflex t => (a -> b -> Maybe c) -> Behavior t a -> Event t b -> Event t c

-- | Alias for <a>headE</a>
onceE :: (Reflex t, MonadHold t m, MonadFix m) => Event t a -> m (Event t a)

-- | Create a new <a>Event</a> that only occurs on the first occurence of
--   the supplied <a>Event</a>.
headE :: (Reflex t, MonadHold t m, MonadFix m) => Event t a -> m (Event t a)

-- | Create a new <a>Event</a> that occurs on all but the first occurence
--   of the supplied <a>Event</a>.
tailE :: (Reflex t, MonadHold t m, MonadFix m) => Event t a -> m (Event t a)

-- | Create a tuple of two <a>Event</a>s with the first one occuring only
--   the first time the supplied <a>Event</a> occurs and the second
--   occuring on all but the first occurence.
headTailE :: (Reflex t, MonadHold t m, MonadFix m) => Event t a -> m (Event t a, Event t a)

-- | Split the supplied <a>Event</a> into two individual <a>Event</a>s
--   occuring at the same time with the respective values from the tuple.
splitE :: Reflex t => Event t (a, b) -> (Event t a, Event t b)

-- | Print the supplied <a>String</a> and the value of the <a>Event</a> on
--   each occurence. This should <i>only</i> be used for debugging.
--   
--   Note: As with Debug.Trace.trace, the message will only be printed if
--   the <a>Event</a> is actually used.
traceEvent :: (Reflex t, Show a) => String -> Event t a -> Event t a

-- | Print the output of the supplied function on each occurence of the
--   <a>Event</a>. This should <i>only</i> be used for debugging.
--   
--   Note: As with Debug.Trace.trace, the message will only be printed if
--   the <a>Event</a> is actually used.
traceEventWith :: Reflex t => (a -> String) -> Event t a -> Event t a

-- | Tag type for <a>Either</a> to use it as a <a>DSum</a>.
data EitherTag l r a
LeftTag :: EitherTag l r l
RightTag :: EitherTag l r r

-- | Convert <a>Either</a> to a <a>DSum</a>. Inverse of
--   <a>dsumToEither</a>.
eitherToDSum :: Either a b -> DSum (EitherTag a b)

-- | Convert <a>DSum</a> to <a>Either</a>. Inverse of <a>eitherToDSum</a>.
dsumToEither :: DSum (EitherTag a b) -> Either a b

-- | Extract the values of a <a>DMap</a> of <a>EitherTag</a>s.
dmapToThese :: DMap (EitherTag a b) -> Maybe (These a b)

-- | Create a new <a>Event</a> that occurs if at least one of the supplied
--   <a>Event</a>s occurs. If both occur at the same time they are combined
--   using <a>mappend</a>.
appendEvents :: (Reflex t, Monoid a) => Event t a -> Event t a -> Event t a

-- | <i>Deprecated: Use bisequenceA or bisequence from the bifunctors
--   package instead</i>
sequenceThese :: Monad m => These (m a) (m b) -> m (These a b)

-- | Create a new <a>Event</a> that occurs if at least one of the
--   <a>Event</a>s in the list occurs. If multiple occur at the same time
--   they are folded from the left with the given function.
mergeWith :: Reflex t => (a -> a -> a) -> [Event t a] -> Event t a

-- | Create a new <a>Event</a> that occurs if at least one of the
--   <a>Event</a>s in the list occurs. If multiple occur at the same time
--   the value is the value of the leftmost event.
leftmost :: Reflex t => [Event t a] -> Event t a

-- | Create a new <a>Event</a> that occurs if at least one of the
--   <a>Event</a>s in the list occurs and has a list of the values of all
--   <a>Event</a>s occuring at that time.
mergeList :: Reflex t => [Event t a] -> Event t (NonEmpty a)

-- | Create a new <a>Event</a> combining the map of <a>Event</a>s into an
--   <a>Event</a> that occurs if at least one of them occurs and has a map
--   of values of all <a>Event</a>s occuring at that time.
mergeMap :: (Reflex t, Ord k) => Map k (Event t a) -> Event t (Map k a)

-- | Split the event into an <a>EventSelector</a> that allows efficient
--   selection of the individual <a>Event</a>s.
fanMap :: (Reflex t, Ord k) => Event t (Map k a) -> EventSelector t (Const2 k a)

-- | Switches to the new event whenever it receives one; the new event is
--   used immediately, on the same frame that it is switched to
switchPromptly :: (Reflex t, MonadHold t m) => Event t a -> Event t (Event t a) -> m (Event t a)

-- | Create a new <a>Event</a> that only occurs if the supplied
--   <a>Event</a> occurs and the <a>Behavior</a> is true at the time of
--   occurence.
gate :: Reflex t => Behavior t Bool -> Event t a -> Event t a
instance Reflex t => Align (Event t)
instance (Semigroup a, Reflex t) => Monoid (Event t a)
instance (Show l, Show r) => ShowTag (EitherTag l r)
instance GShow (EitherTag l r)
instance GCompare (EitherTag l r)
instance GEq (EitherTag l r)
instance Reflex t => Functor (Event t)
instance Reflex t => FunctorMaybe (Event t)
instance Reflex t => Functor (Behavior t)
instance MonadHold t m => MonadHold t (ReaderT r m)
instance MonadSample t m => MonadSample t (ReaderT r m)

module Reflex.Dynamic

-- | A container for a value that can change over time and allows
--   notifications on changes. Basically a combination of a <a>Behavior</a>
--   and an <a>Event</a>, with a rule that the Behavior will change if and
--   only if the Event fires.
data Dynamic t a

-- | Extract the <a>Behavior</a> of a <a>Dynamic</a>.
current :: Dynamic t a -> Behavior t a

-- | Extract the <a>Event</a> of the <a>Dynamic</a>.
updated :: Dynamic t a -> Event t a

-- | <a>Dynamic</a> with the constant supplied value.
constDyn :: Reflex t => a -> Dynamic t a

-- | Create a <a>Dynamic</a> using the initial value that changes every
--   time the <a>Event</a> occurs.
holdDyn :: MonadHold t m => a -> Event t a -> m (Dynamic t a)

-- | Create a new <a>Dynamic</a> that only signals changes if the values
--   actually changed.
nubDyn :: (Reflex t, Eq a) => Dynamic t a -> Dynamic t a

-- | Create a new <a>Dynamic</a> that counts the occurences of the
--   <a>Event</a>.
count :: (Reflex t, MonadHold t m, MonadFix m, Num b) => Event t a -> m (Dynamic t b)

-- | Create a new <a>Dynamic</a> using the initial value that flips its
--   value every time the <a>Event</a> occurs.
toggle :: (Reflex t, MonadHold t m, MonadFix m) => Bool -> Event t a -> m (Dynamic t Bool)

-- | Switches to the new <a>Event</a> whenever it receives one. Switching
--   occurs *before* the inner <a>Event</a> fires - so if the
--   <a>Dynamic</a> changes and both the old and new inner Events fire
--   simultaneously, the output will fire with the value of the *new*
--   <a>Event</a>.
switchPromptlyDyn :: Reflex t => Dynamic t (Event t a) -> Event t a

-- | Replace the value of the <a>Event</a> with the current value of the
--   <a>Dynamic</a> each time the <a>Event</a> occurs.
--   
--   Note: `tagDyn d e` differs from `tag (current d) e` in the case that
--   <tt>e</tt> is firing at the same time that <tt>d</tt> is changing.
--   With `tagDyn d e`, the *new* value of <tt>d</tt> will replace the
--   value of <tt>e</tt>, whereas with `tag (current d) e`, the *old* value
--   will be used, since the <a>Behavior</a> won't be updated until the end
--   of the frame. Additionally, this means that the output <a>Event</a>
--   may not be used to directly change the input <a>Dynamic</a>, because
--   that would mean its value depends on itself. When creating cyclic data
--   flows, generally `tag (current d) e` is preferred.
tagDyn :: Reflex t => Dynamic t a -> Event t b -> Event t a

-- | Attach the current value of the <a>Dynamic</a> to the value of the
--   <a>Event</a> each time it occurs.
--   
--   Note: `attachDyn d` is not the same as `attach (current d)`. See
--   <a>tagDyn</a> for details.
attachDyn :: Reflex t => Dynamic t a -> Event t b -> Event t (a, b)

-- | Combine the current value of the <a>Dynamic</a> with the value of the
--   <a>Event</a> each time it occurs.
--   
--   Note: `attachDynWith f d` is not the same as `attachWith f (current
--   d)`. See <a>tagDyn</a> for details.
attachDynWith :: Reflex t => (a -> b -> c) -> Dynamic t a -> Event t b -> Event t c

-- | Create a new <a>Event</a> by combining the value at each occurence
--   with the current value of the <a>Dynamic</a> value and possibly
--   filtering if the combining function returns <a>Nothing</a>.
--   
--   Note: `attachDynWithMaybe f d` is not the same as `attachWithMaybe f
--   (current d)`. See <a>tagDyn</a> for details.
attachDynWithMaybe :: Reflex t => (a -> b -> Maybe c) -> Dynamic t a -> Event t b -> Event t c

-- | Map a function over a <a>Dynamic</a>.
mapDyn :: (Reflex t, MonadHold t m) => (a -> b) -> Dynamic t a -> m (Dynamic t b)

-- | Flipped version of <a>mapDyn</a>.
forDyn :: (Reflex t, MonadHold t m) => Dynamic t a -> (a -> b) -> m (Dynamic t b)

-- | Map a monadic function over a <a>Dynamic</a>. The only monadic action
--   that the given function can perform is <a>sample</a>.
mapDynM :: (Reflex t, MonadHold t m) => (forall m'. MonadSample t m' => a -> m' b) -> Dynamic t a -> m (Dynamic t b)

-- | Create a <a>Dynamic</a> using the initial value and change it each
--   time the <a>Event</a> occurs using a folding function on the previous
--   value and the value of the <a>Event</a>.
foldDyn :: (Reflex t, MonadHold t m, MonadFix m) => (a -> b -> b) -> b -> Event t a -> m (Dynamic t b)

-- | Create a <a>Dynamic</a> using the initial value and change it each
--   time the <a>Event</a> occurs using a monadic folding function on the
--   previous value and the value of the <a>Event</a>.
foldDynM :: (Reflex t, MonadHold t m, MonadFix m) => (a -> b -> PushM t b) -> b -> Event t a -> m (Dynamic t b)

-- | Merge two <a>Dynamic</a>s into a new one using the provided function.
--   The new <a>Dynamic</a> changes its value each time one of the original
--   <a>Dynamic</a>s changes its value.
combineDyn :: (Reflex t, MonadHold t m) => (a -> b -> c) -> Dynamic t a -> Dynamic t b -> m (Dynamic t c)
collectDyn :: (RebuildSortedHList (HListElems b), IsHList a, IsHList b, AllAreFunctors (Dynamic t) (HListElems b), Reflex t, MonadHold t m, HListElems a ~ FunctorList (Dynamic t) (HListElems b)) => a -> m (Dynamic t b)

-- | Merge the <a>Dynamic</a> values using their <a>Monoid</a> instance.
mconcatDyn :: (Reflex t, MonadHold t m, Monoid a) => [Dynamic t a] -> m (Dynamic t a)

-- | Create a <a>Dynamic</a> with a <a>DMap</a> of values out of a
--   <a>DMap</a> of Dynamic values.
distributeDMapOverDyn :: (Reflex t, MonadHold t m, GCompare k) => DMap (WrapArg (Dynamic t) k) -> m (Dynamic t (DMap k))

-- | Join a nested <a>Dynamic</a> into a new <a>Dynamic</a> that has the
--   value of the inner <a>Dynamic</a>.
joinDyn :: Reflex t => Dynamic t (Dynamic t a) -> Dynamic t a

-- | Combine a <a>Dynamic</a> of a <a>Map</a> of <a>Dynamic</a>s into a
--   <a>Dynamic</a> with the current values of the <a>Dynamic</a>s in a
--   map.
joinDynThroughMap :: (Reflex t, Ord k) => Dynamic t (Map k (Dynamic t a)) -> Dynamic t (Map k a)

-- | Print the value of the <a>Dynamic</a> on each change and prefix it
--   with the provided string. This should <i>only</i> be used for
--   debugging.
--   
--   Note: Just like Debug.Trace.trace, the value will only be shown if
--   something else in the system is depending on it.
traceDyn :: (Reflex t, Show a) => String -> Dynamic t a -> Dynamic t a

-- | Print the result of applying the provided function to the value of the
--   <a>Dynamic</a> on each change. This should <i>only</i> be used for
--   debugging.
--   
--   Note: Just like Debug.Trace.trace, the value will only be shown if
--   something else in the system is depending on it.
traceDynWith :: Reflex t => (a -> String) -> Dynamic t a -> Dynamic t a

-- | Split the <a>Dynamic</a> into two <a>Dynamic</a>s, each taking the
--   respective value of the tuple.
splitDyn :: (Reflex t, MonadHold t m) => Dynamic t (a, b) -> m (Dynamic t a, Dynamic t b)

-- | Represents a time changing value together with an <a>EventSelector</a>
--   that can efficiently detect when the underlying Dynamic has a
--   particular value. This is useful for representing data like the
--   current selection of a long list.
--   
--   Semantically, &gt; getDemuxed (demux d) k === mapDyn (== k) d However,
--   the when getDemuxed is used multiple times, the complexity is only
--   <i>O(log(n))</i>, rather than <i>O(n)</i> for mapDyn.
data Demux t k

-- | Demultiplex an input value to a <a>Demux</a> with many outputs. At any
--   given time, whichever output is indicated by the given <a>Dynamic</a>
--   will be <a>True</a>.
demux :: (Reflex t, Ord k) => Dynamic t k -> Demux t k

-- | Select a particular output of the <a>Demux</a>; this is equivalent to
--   (but much faster than) mapping over the original <a>Dynamic</a> and
--   checking whether it is equal to the given key.
getDemuxed :: (Reflex t, MonadHold t m, Eq k) => Demux t k -> k -> m (Dynamic t Bool)
data HList (l :: [*])
HNil :: HList []
HCons :: e -> HList l -> HList (e : l)
data FHList f l
FHNil :: FHList f []
FHCons :: f e -> FHList f l -> FHList f (e : l)
distributeFHListOverDyn :: (Reflex t, MonadHold t m, RebuildSortedHList l) => FHList (Dynamic t) l -> m (Dynamic t (HList l))
unsafeDynamic :: Behavior t a -> Event t a -> Dynamic t a
instance IsHList (a, b, c, d, e, f)
instance IsHList (a, b, c, d)
instance IsHList (a, b)
instance AllAreFunctors f t => AllAreFunctors f (h : t)
instance AllAreFunctors f '[]
instance RebuildSortedHList t => RebuildSortedHList (h : t)
instance RebuildSortedHList '[]
instance GCompare (HListPtr l)
instance GEq (HListPtr l)
instance HBuild' (a : l) r => HBuild' l (a -> r)
instance l' ~ HRevApp l '[] => HBuild' l (HList l')

module Reflex.Dynamic.TH

-- | Quote a Dynamic expression. Within the quoted expression, you can use
--   '$(unqDyn [| x |])' to refer to any expression <tt>x</tt> of type
--   'Dynamic t a'; the unquoted result will be of type <tt>a</tt>
qDyn :: Q Exp -> Q Exp
unqDyn :: Q Exp -> Q Exp

module Reflex.Host.Class
class Reflex t => ReflexHost t where type family EventTrigger t :: * -> * type family EventHandle t :: * -> * type family HostFrame t :: * -> *
class (ReflexHost t, Monad m) => MonadReadEvent t m | m -> t
readEvent :: MonadReadEvent t m => EventHandle t a -> m (Maybe (m a))
class (Monad m, ReflexHost t) => MonadReflexCreateTrigger t m | m -> t
newEventWithTrigger :: MonadReflexCreateTrigger t m => (EventTrigger t a -> IO (IO ())) -> m (Event t a)
class (Monad m, ReflexHost t, MonadReflexCreateTrigger t m) => MonadReflexHost t m | m -> t
fireEventsAndRead :: MonadReflexHost t m => [DSum (EventTrigger t)] -> (forall m'. MonadReadEvent t m' => m' a) -> m a
subscribeEvent :: MonadReflexHost t m => Event t a -> m (EventHandle t a)
runFrame :: MonadReflexHost t m => PushM t a -> m a
runHostFrame :: MonadReflexHost t m => HostFrame t a -> m a
fireEvents :: MonadReflexHost t m => [DSum (EventTrigger t)] -> m ()
newEventWithTriggerRef :: (MonadReflexCreateTrigger t m, MonadRef m, Ref m ~ Ref IO) => m (Event t a, Ref m (Maybe (EventTrigger t a)))
instance (Reflex t, MonadReflexHost t m) => MonadReflexHost t (ReaderT r m)
instance (Reflex t, MonadReflexCreateTrigger t m) => MonadReflexCreateTrigger t (ReaderT r m)

module Reflex.Spider.Internal
debugPropagate :: Bool
debugInvalidateHeight :: Bool
showNodeId :: a -> String
data Hold a
Hold :: !(IORef a) -> !(IORef [Weak Invalidator]) -> !(IORef Any) -> !(IORef Any) -> Hold a
holdValue :: Hold a -> !(IORef a)
holdInvalidators :: Hold a -> !(IORef [Weak Invalidator])
holdSubscriber :: Hold a -> !(IORef Any)
holdParent :: Hold a -> !(IORef Any)
data EventEnv
EventEnv :: !(IORef [SomeAssignment]) -> !(IORef [SomeHoldInit]) -> !(IORef [SomeMaybeIORef]) -> !(IORef Int) -> !(IORef [SomeCoincidenceInfo]) -> !(IORef (IntMap [DelayedMerge])) -> EventEnv
eventEnvAssignments :: EventEnv -> !(IORef [SomeAssignment])
eventEnvHoldInits :: EventEnv -> !(IORef [SomeHoldInit])
eventEnvClears :: EventEnv -> !(IORef [SomeMaybeIORef])
eventEnvCurrentHeight :: EventEnv -> !(IORef Int)
eventEnvCoincidenceInfos :: EventEnv -> !(IORef [SomeCoincidenceInfo])
eventEnvDelayedMerges :: EventEnv -> !(IORef (IntMap [DelayedMerge]))
runEventM :: EventM a -> EventEnv -> IO a
askToAssignRef :: EventM (IORef [SomeAssignment])
askHoldInitRef :: EventM (IORef [SomeHoldInit])
getCurrentHeight :: EventM Int
putCurrentHeight :: Int -> EventM ()
scheduleClear :: IORef (Maybe a) -> EventM ()
scheduleMerge :: Int -> MergeSubscribed a -> EventM ()
emitCoincidenceInfo :: SomeCoincidenceInfo -> EventM ()
hold :: a -> Event a -> EventM (Behavior a)
subscribeHold :: Event a -> Hold a -> EventM ()
newtype BehaviorM a
BehaviorM :: ReaderT (Maybe (Weak Invalidator, IORef [SomeBehaviorSubscribed])) IO a -> BehaviorM a
unBehaviorM :: BehaviorM a -> ReaderT (Maybe (Weak Invalidator, IORef [SomeBehaviorSubscribed])) IO a
data BehaviorSubscribed a
BehaviorSubscribedHold :: (Hold a) -> BehaviorSubscribed a
BehaviorSubscribedPull :: (PullSubscribed a) -> BehaviorSubscribed a
data SomeBehaviorSubscribed
SomeBehaviorSubscribed :: (BehaviorSubscribed a) -> SomeBehaviorSubscribed
data PullSubscribed a
PullSubscribed :: !a -> !(IORef [Weak Invalidator]) -> !Invalidator -> ![SomeBehaviorSubscribed] -> PullSubscribed a
pullSubscribedValue :: PullSubscribed a -> !a
pullSubscribedInvalidators :: PullSubscribed a -> !(IORef [Weak Invalidator])
pullSubscribedOwnInvalidator :: PullSubscribed a -> !Invalidator
pullSubscribedParents :: PullSubscribed a -> ![SomeBehaviorSubscribed]
data Pull a
Pull :: !(IORef (Maybe (PullSubscribed a))) -> !(BehaviorM a) -> Pull a
pullValue :: Pull a -> !(IORef (Maybe (PullSubscribed a)))
pullCompute :: Pull a -> !(BehaviorM a)
data Invalidator
InvalidatorPull :: (Pull a) -> Invalidator
InvalidatorSwitch :: (SwitchSubscribed a) -> Invalidator
data RootSubscribed a
RootSubscribed :: !(IORef [WeakSubscriber a]) -> !(IORef (Maybe a)) -> RootSubscribed a
rootSubscribedSubscribers :: RootSubscribed a -> !(IORef [WeakSubscriber a])
rootSubscribedOccurrence :: RootSubscribed a -> !(IORef (Maybe a))
data Root a
Root :: !(IORef (Maybe a)) -> !(IORef (Maybe (RootSubscribed a))) -> !(RootTrigger a -> IO (IO ())) -> Root a
rootOccurrence :: Root a -> !(IORef (Maybe a))
rootSubscribed :: Root a -> !(IORef (Maybe (RootSubscribed a)))
rootInit :: Root a -> !(RootTrigger a -> IO (IO ()))
data SomeHoldInit
SomeHoldInit :: (Event a) -> (Hold a) -> SomeHoldInit
newtype EventM a
EventM :: ReaderT EventEnv IO a -> EventM a
unEventM :: EventM a -> ReaderT EventEnv IO a
data PushSubscribed a b
PushSubscribed :: !(IORef (Maybe b)) -> !(IORef Int) -> !(IORef [WeakSubscriber b]) -> !(Subscriber a) -> !(EventSubscribed a) -> PushSubscribed a b
pushSubscribedOccurrence :: PushSubscribed a b -> !(IORef (Maybe b))
pushSubscribedHeight :: PushSubscribed a b -> !(IORef Int)
pushSubscribedSubscribers :: PushSubscribed a b -> !(IORef [WeakSubscriber b])
pushSubscribedSelf :: PushSubscribed a b -> !(Subscriber a)
pushSubscribedParent :: PushSubscribed a b -> !(EventSubscribed a)
data Push a b
Push :: !(a -> EventM (Maybe b)) -> !(Event a) -> !(IORef (Maybe (PushSubscribed a b))) -> Push a b
pushCompute :: Push a b -> !(a -> EventM (Maybe b))
pushParent :: Push a b -> !(Event a)
pushSubscribed :: Push a b -> !(IORef (Maybe (PushSubscribed a b)))
data MergeSubscribed k
MergeSubscribed :: !(IORef (Maybe (DMap k))) -> !(IORef (DMap k)) -> !(IORef Int) -> !(IORef [WeakSubscriber (DMap k)]) -> !Any -> !(DMap (WrapArg EventSubscribed k)) -> MergeSubscribed k
mergeSubscribedOccurrence :: MergeSubscribed k -> !(IORef (Maybe (DMap k)))
mergeSubscribedAccum :: MergeSubscribed k -> !(IORef (DMap k))
mergeSubscribedHeight :: MergeSubscribed k -> !(IORef Int)
mergeSubscribedSubscribers :: MergeSubscribed k -> !(IORef [WeakSubscriber (DMap k)])
mergeSubscribedSelf :: MergeSubscribed k -> !Any
mergeSubscribedParents :: MergeSubscribed k -> !(DMap (WrapArg EventSubscribed k))
data Merge k
Merge :: !(DMap (WrapArg Event k)) -> !(IORef (Maybe (MergeSubscribed k))) -> Merge k
mergeParents :: Merge k -> !(DMap (WrapArg Event k))
mergeSubscribed :: Merge k -> !(IORef (Maybe (MergeSubscribed k)))
data FanSubscriberKey k a
FanSubscriberKey :: k a -> FanSubscriberKey k [WeakSubscriber a]
data FanSubscribed k
FanSubscribed :: !(IORef (DMap (FanSubscriberKey k))) -> !(EventSubscribed (DMap k)) -> {-# NOUNPACK #-} !(Subscriber (DMap k)) -> FanSubscribed k
fanSubscribedSubscribers :: FanSubscribed k -> !(IORef (DMap (FanSubscriberKey k)))
fanSubscribedParent :: FanSubscribed k -> !(EventSubscribed (DMap k))
fanSubscribedSelf :: FanSubscribed k -> {-# NOUNPACK #-} !(Subscriber (DMap k))
data Fan k
Fan :: !(Event (DMap k)) -> !(IORef (Maybe (FanSubscribed k))) -> Fan k
fanParent :: Fan k -> !(Event (DMap k))
fanSubscribed :: Fan k -> !(IORef (Maybe (FanSubscribed k)))
data SwitchSubscribed a
SwitchSubscribed :: !(IORef (Maybe a)) -> !(IORef Int) -> !(IORef [WeakSubscriber a]) -> {-# NOUNPACK #-} !(Subscriber a) -> !(IORef (Weak (Subscriber a))) -> {-# NOUNPACK #-} !Invalidator -> !(IORef (Weak Invalidator)) -> !(IORef [SomeBehaviorSubscribed]) -> !(Behavior (Event a)) -> !(IORef (EventSubscribed a)) -> SwitchSubscribed a
switchSubscribedOccurrence :: SwitchSubscribed a -> !(IORef (Maybe a))
switchSubscribedHeight :: SwitchSubscribed a -> !(IORef Int)
switchSubscribedSubscribers :: SwitchSubscribed a -> !(IORef [WeakSubscriber a])
switchSubscribedSelf :: SwitchSubscribed a -> {-# NOUNPACK #-} !(Subscriber a)
switchSubscribedSelfWeak :: SwitchSubscribed a -> !(IORef (Weak (Subscriber a)))
switchSubscribedOwnInvalidator :: SwitchSubscribed a -> {-# NOUNPACK #-} !Invalidator
switchSubscribedOwnWeakInvalidator :: SwitchSubscribed a -> !(IORef (Weak Invalidator))
switchSubscribedBehaviorParents :: SwitchSubscribed a -> !(IORef [SomeBehaviorSubscribed])
switchSubscribedParent :: SwitchSubscribed a -> !(Behavior (Event a))
switchSubscribedCurrentParent :: SwitchSubscribed a -> !(IORef (EventSubscribed a))
data Switch a
Switch :: !(Behavior (Event a)) -> !(IORef (Maybe (SwitchSubscribed a))) -> Switch a
switchParent :: Switch a -> !(Behavior (Event a))
switchSubscribed :: Switch a -> !(IORef (Maybe (SwitchSubscribed a)))
data CoincidenceSubscribed a
CoincidenceSubscribed :: !(IORef (Maybe a)) -> !(IORef [WeakSubscriber a]) -> !(IORef Int) -> {-# NOUNPACK #-} !(Subscriber (Event a)) -> !(EventSubscribed (Event a)) -> !(IORef (Maybe (EventSubscribed a))) -> CoincidenceSubscribed a
coincidenceSubscribedOccurrence :: CoincidenceSubscribed a -> !(IORef (Maybe a))
coincidenceSubscribedSubscribers :: CoincidenceSubscribed a -> !(IORef [WeakSubscriber a])
coincidenceSubscribedHeight :: CoincidenceSubscribed a -> !(IORef Int)
coincidenceSubscribedOuter :: CoincidenceSubscribed a -> {-# NOUNPACK #-} !(Subscriber (Event a))
coincidenceSubscribedOuterParent :: CoincidenceSubscribed a -> !(EventSubscribed (Event a))
coincidenceSubscribedInnerParent :: CoincidenceSubscribed a -> !(IORef (Maybe (EventSubscribed a)))
data Coincidence a
Coincidence :: !(Event (Event a)) -> !(IORef (Maybe (CoincidenceSubscribed a))) -> Coincidence a
coincidenceParent :: Coincidence a -> !(Event (Event a))
coincidenceSubscribed :: Coincidence a -> !(IORef (Maybe (CoincidenceSubscribed a)))
data Box a
Box :: a -> Box a
unBox :: Box a -> a
data WeakSubscriber a
WeakSubscriberMerge :: !(k a) -> !(Weak (Box (MergeSubscribed k))) -> WeakSubscriber a
WeakSubscriberSimple :: !(Weak (Subscriber a)) -> WeakSubscriber a
showWeakSubscriberType :: WeakSubscriber a -> String
deRefWeakSubscriber :: WeakSubscriber a -> IO (Maybe (Subscriber a))
data Subscriber a
SubscriberPush :: !(a -> EventM (Maybe b)) -> (PushSubscribed a b) -> Subscriber a
SubscriberMerge :: !(k a) -> (MergeSubscribed k) -> Subscriber a
SubscriberFan :: (FanSubscribed k) -> Subscriber a
SubscriberHold :: !(Hold a) -> Subscriber a
SubscriberSwitch :: (SwitchSubscribed a) -> Subscriber a
SubscriberCoincidenceOuter :: (CoincidenceSubscribed b) -> Subscriber a
SubscriberCoincidenceInner :: (CoincidenceSubscribed a) -> Subscriber a
showSubscriberType :: Subscriber a -> String
data Event a
EventRoot :: !(Root a) -> Event a
EventNever :: Event a
EventPush :: !(Push b a) -> Event a
EventMerge :: !(Merge k) -> Event a
EventFan :: !(k a) -> !(Fan k) -> Event a
EventSwitch :: !(Switch a) -> Event a
EventCoincidence :: !(Coincidence a) -> Event a
showEventType :: Event a -> String
data EventSubscribed a
EventSubscribedRoot :: {-# NOUNPACK #-} !(RootSubscribed a) -> EventSubscribed a
EventSubscribedNever :: EventSubscribed a
EventSubscribedPush :: !(PushSubscribed b a) -> EventSubscribed a
EventSubscribedMerge :: !(MergeSubscribed k) -> EventSubscribed a
EventSubscribedFan :: !(k a) -> !(FanSubscribed k) -> EventSubscribed a
EventSubscribedSwitch :: !(SwitchSubscribed a) -> EventSubscribed a
EventSubscribedCoincidence :: !(CoincidenceSubscribed a) -> EventSubscribed a
newRootSubscribed :: IORef (Maybe a) -> IORef [WeakSubscriber a] -> IO (RootSubscribed a)
newSubscriberPush :: (a -> EventM (Maybe b)) -> PushSubscribed a b -> IO (Subscriber a)
newSubscriberHold :: Hold a -> IO (Subscriber a)
newSubscriberFan :: GCompare k => FanSubscribed k -> IO (Subscriber (DMap k))
newSubscriberSwitch :: SwitchSubscribed a -> IO (Subscriber a)
newSubscriberCoincidenceOuter :: CoincidenceSubscribed b -> IO (Subscriber (Event b))
newSubscriberCoincidenceInner :: CoincidenceSubscribed a -> IO (Subscriber a)
newInvalidatorSwitch :: SwitchSubscribed a -> IO Invalidator
newInvalidatorPull :: Pull a -> IO Invalidator
newBox :: a -> IO (Box a)
data Behavior a
BehaviorHold :: !(Hold a) -> Behavior a
BehaviorConst :: !a -> Behavior a
BehaviorPull :: !(Pull a) -> Behavior a
type ResultM = EventM
unsafeNewIORef :: a -> b -> IORef b
push :: (a -> EventM (Maybe b)) -> Event a -> Event b
pull :: BehaviorM a -> Behavior a
switch :: Behavior (Event a) -> Event a
coincidence :: Event (Event a) -> Event a
newRoot :: IO (Root a)
propagateAndUpdateSubscribersRef :: IORef [WeakSubscriber a] -> a -> EventM ()
run :: [DSum RootTrigger] -> ResultM b -> IO b
data SomeMaybeIORef
SomeMaybeIORef :: (IORef (Maybe a)) -> SomeMaybeIORef
data SomeAssignment
SomeAssignment :: (Hold a) -> a -> SomeAssignment
data DelayedMerge
DelayedMerge :: (MergeSubscribed k) -> DelayedMerge
debugFinalize :: Bool
mkWeakPtrWithDebug :: a -> String -> IO (Weak a)
type WeakList a = [Weak a]
traverseAndCleanWeakList_ :: Monad m => (wa -> m (Maybe a)) -> [wa] -> (a -> m ()) -> m [wa]

-- | Propagate everything at the current height
propagate :: a -> [WeakSubscriber a] -> EventM [WeakSubscriber a]
data SomeCoincidenceInfo
SomeCoincidenceInfo :: (Weak (Subscriber a)) -> (Subscriber a) -> (Maybe (CoincidenceSubscribed a)) -> SomeCoincidenceInfo
subscribeCoincidenceInner :: Event a -> Int -> CoincidenceSubscribed a -> EventM (Maybe a, Int, EventSubscribed a)
readBehavior :: Behavior a -> IO a
runBehaviorM :: BehaviorM a -> Maybe (Weak Invalidator, IORef [SomeBehaviorSubscribed]) -> IO a
askInvalidator :: BehaviorM (Maybe (Weak Invalidator))
askParentsRef :: BehaviorM (Maybe (IORef [SomeBehaviorSubscribed]))
readBehaviorTracked :: Behavior a -> BehaviorM a
readEvent :: Event a -> ResultM (Maybe a)
zeroRef :: IORef Int
getEventSubscribed :: Event a -> EventM (EventSubscribed a)
debugSubscribe :: Bool
subscribeEventSubscribed :: EventSubscribed a -> WeakSubscriber a -> IO ()
getEventSubscribedOcc :: EventSubscribed a -> IO (Maybe a)
eventSubscribedHeightRef :: EventSubscribed a -> IORef Int
subscribe :: Event a -> WeakSubscriber a -> EventM (EventSubscribed a)
noinlineFalse :: Bool
getRootSubscribed :: Root a -> EventM (RootSubscribed a)
getPushSubscribed :: Push a b -> EventM (PushSubscribed a b)
getMergeSubscribed :: GCompare k => Merge k -> EventM (MergeSubscribed k)
getFanSubscribed :: GCompare k => Fan k -> EventM (FanSubscribed k)
getSwitchSubscribed :: Switch a -> EventM (SwitchSubscribed a)
getCoincidenceSubscribed :: Coincidence a -> EventM (CoincidenceSubscribed a)
merge :: GCompare k => DMap (WrapArg Event k) -> Event (DMap k)
newtype EventSelector k
EventSelector :: (forall a. k a -> Event a) -> EventSelector k
select :: EventSelector k -> forall a. k a -> Event a
fan :: GCompare k => Event (DMap k) -> EventSelector k

-- | Run an event action outside of a frame
runFrame :: EventM a -> IO a
invalidHeight :: Int
invalidateSubscriberHeight :: WeakSubscriber a -> IO ()
invalidateCoincidenceHeight :: CoincidenceSubscribed a -> IO ()
recalculateSubscriberHeight :: WeakSubscriber a -> IO ()
recalculateCoincidenceHeight :: CoincidenceSubscribed a -> IO ()
calculateMergeHeight :: MergeSubscribed k -> IO Int
calculateSwitchHeight :: SwitchSubscribed a -> IO Int
calculateCoincidenceHeight :: CoincidenceSubscribed a -> IO Int
data SomeSwitchSubscribed
SomeSwitchSubscribed :: (SwitchSubscribed a) -> SomeSwitchSubscribed
debugInvalidate :: Bool
invalidate :: IORef [SomeSwitchSubscribed] -> WeakList Invalidator -> IO (WeakList Invalidator)
data Spider
newtype RootTrigger a
RootTrigger :: (IORef [WeakSubscriber a], IORef (Maybe a)) -> RootTrigger a
newtype SpiderHost a
SpiderHost :: IO a -> SpiderHost a
runSpiderHost :: SpiderHost a -> IO a
newtype SpiderHostFrame a
SpiderHostFrame :: EventM a -> SpiderHostFrame a
runSpiderHostFrame :: SpiderHostFrame a -> EventM a
newEventWithTriggerIO :: (RootTrigger a -> IO (IO ())) -> IO (Event Spider a)
instance Functor BehaviorM
instance Applicative BehaviorM
instance Monad BehaviorM
instance MonadIO BehaviorM
instance MonadFix BehaviorM
instance Functor EventM
instance Applicative EventM
instance Monad EventM
instance MonadFix EventM
instance MonadIO EventM
instance Functor SpiderHost
instance Applicative SpiderHost
instance Monad SpiderHost
instance MonadFix SpiderHost
instance MonadIO SpiderHost
instance Functor SpiderHostFrame
instance Applicative SpiderHostFrame
instance Monad SpiderHostFrame
instance MonadFix SpiderHostFrame
instance MonadIO SpiderHostFrame
instance MonadAtomicRef SpiderHostFrame
instance MonadRef SpiderHostFrame
instance MonadAtomicRef SpiderHost
instance MonadRef SpiderHost
instance MonadReflexHost Spider SpiderHost
instance MonadReflexCreateTrigger Spider SpiderHostFrame
instance MonadReflexCreateTrigger Spider SpiderHost
instance MonadHold Spider SpiderHostFrame
instance MonadSample Spider SpiderHostFrame
instance MonadAtomicRef EventM
instance MonadRef EventM
instance MonadReadEvent Spider ResultM
instance ReflexHost Spider
instance MonadHold Spider EventM
instance MonadSample Spider EventM
instance MonadSample Spider BehaviorM
instance MonadHold Spider SpiderHost
instance MonadSample Spider SpiderHost
instance Reflex Spider
instance Functor Behavior
instance Functor Event
instance GCompare k => GCompare (FanSubscriberKey k)
instance GEq k => GEq (FanSubscriberKey k)

module Reflex.Spider
data Spider
newtype SpiderHost a
SpiderHost :: IO a -> SpiderHost a
runSpiderHost :: SpiderHost a -> IO a

module Reflex
