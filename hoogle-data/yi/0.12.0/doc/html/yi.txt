-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The Haskell-Scriptable Editor
--   
@package yi
@version 0.12.0

module Yi.Char.Unicode
greek :: [(String, String)]
symbols :: [(String, String)]
subscripts :: [(String, String)]
superscripts :: [(String, String)]
checkAmbs :: [(String, String)] -> [(String, String)]
disamb :: [(String, String)] -> [(String, String)]

module Yi.Syntax.Layout

-- | Transform a scanner into a scanner that also adds opening, closing and
--   "next" tokens to indicate layout.
layoutHandler :: (Show t, Eq t) => (t -> Bool) -> [(t, t)] -> (Tok t -> Bool) -> (t, t, t) -> (Tok t -> Bool) -> Scanner (AlexState lexState) (Tok t) -> Scanner (State t lexState) (Tok t)
type State t lexState = (IState t, AlexState lexState)
instance Show t => Show (BlockOpen t)
instance Show t => Show (IState t)


module Yi.Keymap.Vim.MatchResult
data MatchResult a
NoMatch :: MatchResult a
PartialMatch :: MatchResult a
WholeMatch :: a -> MatchResult a
instance Functor MatchResult
instance Show (MatchResult a)
instance Alternative MatchResult
instance Applicative MatchResult

module Yi.Keymap.Vim.Digraph
charFromDigraph :: [(String, Char)] -> Char -> Char -> Maybe Char
defDigraphs :: [(String, Char)]


-- | This is a little helper for completion interfaces.
module Yi.Keymap.Completion
data CompletionTree a
CT :: [(a, CompletionTree a)] -> CompletionTree a
stepTree :: Eq a => CompletionTree a -> a -> Maybe ([a], CompletionTree a)
obvious :: CompletionTree a -> ([a], CompletionTree a)
mergeTrees :: Ord a => [CompletionTree a] -> CompletionTree a
listToTree :: [a] -> CompletionTree a
complete :: Eq a => CompletionTree a -> [a] -> ([a], CompletionTree a)
instance Show a => Show (CompletionTree a)

module Yi.IncrementalParse

-- | Parse the same thing as the argument, but will be used only as backup.
--   ie, it will be used only if disjuncted with a failing parser.
recoverWith :: Parser s a -> Parser s a
symbol :: (s -> Bool) -> Parser s s
eof :: Parser s ()
lookNext :: Parser s (Maybe s)
testNext :: (Maybe s -> Bool) -> Parser s ()
type State st token result = (st, Process token result)
type P s a = Parser s a

-- | Parser specification
data Parser s a
Look :: Parser s a -> (s -> Parser s a) -> Parser s a
Yuck :: Parser s a -> Parser s a
Enter :: String -> Parser s a -> Parser s a

-- | Lexer state
data AlexState lexerState :: * -> *
AlexState :: lexerState -> SrictNotUnpackedPoint -> SrictNotUnpackedPosn -> AlexState lexerState
stLexer :: AlexState lexerState -> lexerState
lookedOffset :: AlexState lexerState -> SrictNotUnpackedPoint
stPosn :: AlexState lexerState -> SrictNotUnpackedPosn
scanner :: Parser token result -> Scanner st token -> Scanner (State st token result) result

module Yi.Event
data Event
Event :: Key -> [Modifier] -> Event
prettyEvent :: Event -> String
data Key
KEsc :: Key
KFun :: Int -> Key
KPrtScr :: Key
KPause :: Key
KASCII :: Char -> Key
KBS :: Key
KIns :: Key
KHome :: Key
KPageUp :: Key
KDel :: Key
KEnd :: Key
KPageDown :: Key
KNP5 :: Key
KUp :: Key
KMenu :: Key
KLeft :: Key
KDown :: Key
KRight :: Key
KEnter :: Key
KTab :: Key
data Modifier
MShift :: Modifier
MCtrl :: Modifier
MMeta :: Modifier
MSuper :: Modifier
MHyper :: Modifier

-- | Map an Event to a Char. This is used in the emacs keymap for Ctrl-Q
--   and vim keymap <tt>insertSpecialChar</tt>
eventToChar :: Event -> Char
instance Show Modifier
instance Eq Modifier
instance Ord Modifier
instance Eq Key
instance Show Key
instance Ord Key
instance Eq Event
instance Show Event
instance Ord Event

module Yi.UI.Vty.Conversions

-- | Convert a Yi Attr into a Vty attribute change.
colorToAttr :: (Color -> Attr -> Attr) -> Color -> Attr -> Attr
fromVtyEvent :: Event -> Event
fromVtyKey :: Key -> Key
fromVtyMod :: Modifier -> Modifier

module Yi.JumpList
type JumpList = Maybe (PointedList Jump)
data Jump
Jump :: Mark -> BufferRef -> Jump
jumpMark :: Jump -> Mark
jumpBufferRef :: Jump -> BufferRef
addJump :: Jump -> JumpList -> JumpList
jumpBack :: JumpList -> JumpList
jumpForward :: JumpList -> JumpList
instance Generic Jump
instance Datatype D1Jump
instance Constructor C1_0Jump
instance Selector S1_0_0Jump
instance Selector S1_0_1Jump
instance Show Jump
instance Binary Jump


-- | Killring operations.
module Yi.KillRing
data Killring
_krKilled :: Killring -> Bool
_krContents :: Killring -> NonEmpty YiString
krKilled :: Lens' Killring Bool
krContents :: Lens' Killring (NonEmpty YiString)

-- | Finish an atomic command, for the purpose of killring accumulation.
krEndCmd :: Killring -> Killring

-- | Put some text in the killring. It's accumulated if the last command
--   was a kill too
krPut :: Direction -> YiString -> Killring -> Killring

-- | Set the top of the killring. Never accumulate the previous content.
krSet :: YiString -> Killring -> Killring

-- | Get the top of the killring.
krGet :: Killring -> YiString
krEmpty :: Killring
krLastYank :: Lens' Killring Bool
instance Show Killring
instance Eq Killring
instance Binary Killring


-- | Debug utilities used throughout Yi.
module Yi.Debug

-- | Set the file to which debugging output should be written. Though this
--   is called <i>init</i>Debug. Debugging output is not created by default
--   (i.e., if this function is never called.) The target file can not be
--   changed, nor debugging disabled.
initDebug :: FilePath -> IO ()

-- | Outputs the given string before returning the second argument.
trace :: Text -> a -> a

-- | Traces <tt>x</tt> and returns <tt>y</tt>.
traceM :: Monad m => Text -> a -> m a

-- | Like traceM, but returns ().
traceM_ :: Monad m => Text -> m ()
logPutStrLn :: MonadBase IO m => Text -> m ()
logError :: MonadBase IO m => Text -> m ()
logStream :: Show a => Text -> Chan a -> IO ()
error :: Text -> a


-- | This module defines the layout manager interface (see
--   <a>LayoutManager</a>). To desgin a new layout manager, just make an
--   instance of this class.
module Yi.Layout

-- | UI-agnostic layout schema. The basic constructs are
--   (horizontal/vertical) stacks with fixed ratios between window sizes;
--   and (horizontal/vertical) pairs with a slider in between (if
--   available).
data Layout a
SingleWindow :: a -> Layout a
Stack :: !Orientation -> [(Layout a, RelativeSize)] -> Layout a

-- | Orientation
orientation :: Layout a -> !Orientation

-- | The layout stack, with the given weights TODO: fix strictness for
--   stack (it's still lazy)
wins :: Layout a -> [(Layout a, RelativeSize)]
Pair :: !Orientation -> !DividerPosition -> !DividerRef -> !(Layout a) -> !(Layout a) -> Layout a

-- | Orientation
orientation :: Layout a -> !Orientation

-- | Initial position of the divider
divPos :: Layout a -> !DividerPosition

-- | Index of the divider (for updating the divider position)
divRef :: Layout a -> !DividerRef

-- | Upper of of the pair
pairFst :: Layout a -> !(Layout a)

-- | Lower of the pair
pairSnd :: Layout a -> !(Layout a)

-- | Orientations for <a>Stack</a> and <a>Pair</a>
data Orientation
Horizontal :: Orientation
Vertical :: Orientation

-- | Divider position, in the range (0,1)
type DividerPosition = Double

-- | Divider reference
type DividerRef = Int

-- | Relative sizes, for <a>Stack</a>
type RelativeSize = Double

-- | Accessor for the <a>DividerPosition</a> with given reference
dividerPositionA :: DividerRef -> Lens' (Layout a) DividerPosition

-- | The type of layout managers. See the layout managers <a>tall</a>,
--   <a>hPairNStack</a> and <a>slidyTall</a> for some example
--   implementations.
class (Typeable m, Eq m) => LayoutManager m where nextVariant = id previousVariant = id
pureLayout :: LayoutManager m => m -> Layout a -> [a] -> Layout a
describeLayout :: LayoutManager m => m -> String
nextVariant :: LayoutManager m => m -> m
previousVariant :: LayoutManager m => m -> m

-- | Existential wrapper for <a>Layout</a>
data AnyLayoutManager
AnyLayoutManager :: !m -> AnyLayoutManager

-- | True if the internal layout managers have the same type (but are not
--   necessarily equal).
layoutManagerSameType :: AnyLayoutManager -> AnyLayoutManager -> Bool

-- | Windows placed on top of one another, equally spaced
wide :: AnyLayoutManager

-- | Windows placed side-by-side, equally spaced.
tall :: AnyLayoutManager

-- | Tall windows, arranged in a balanced binary tree with sliders in
--   between them.
slidyTall :: AnyLayoutManager

-- | Transposed version of <a>slidyTall</a>
slidyWide :: AnyLayoutManager

-- | <tt>n</tt> windows on the left; stack of windows on the right.
hPairNStack :: Int -> AnyLayoutManager

-- | Transposed version of <a>hPairNStack</a>.
vPairNStack :: Int -> AnyLayoutManager

-- | A general bounding box
data Rectangle
Rectangle :: !Double -> !Double -> !Double -> !Double -> Rectangle
rectX :: Rectangle -> !Double
rectY :: Rectangle -> !Double
rectWidth :: Rectangle -> !Double
rectHeight :: Rectangle -> !Double
layoutToRectangles :: Rectangle -> Layout a -> [(a, Rectangle)]

-- | Things with orientations which can be flipped
class Transposable r
transpose :: Transposable r => r -> r

-- | Same as <tt>lm</tt>, but with all <a>Orientation</a>s
--   <a>transpose</a>d. See <a>slidyWide</a> for an example of its use.
newtype Transposed lm
Transposed :: lm -> Transposed lm

-- | A 'Layout a' wrapped in a state monad for tracking <a>DividerRef</a>s.
--   This type is <i>not</i> itself a monad, but should rather be thought
--   of as a <a>DividerRef</a>-free version of the <a>Layout</a> type.
data LayoutM a
pair :: Orientation -> DividerPosition -> LayoutM a -> LayoutM a -> LayoutM a
singleWindow :: a -> LayoutM a
stack :: Orientation -> [(LayoutM a, RelativeSize)] -> LayoutM a

-- | Special case of <a>stack</a> with all <a>RelativeSize</a>s equal.
evenStack :: Orientation -> [LayoutM a] -> LayoutM a
runLayoutM :: LayoutM a -> Layout a
instance Typeable Layout
instance Typeable AnyLayoutManager
instance Typeable Tall
instance Typeable Wide
instance Typeable SlidyTall
instance Typeable HPairNStack
instance Typeable Transposed
instance Typeable VPairNStack
instance Typeable SlidyWide
instance Eq Orientation
instance Show Orientation
instance Eq a => Eq (Layout a)
instance Functor Layout
instance Eq Tall
instance Eq Wide
instance Eq SlidyTall
instance Eq HPairNStack
instance Eq Rectangle
instance Show Rectangle
instance Eq lm => Eq (Transposed lm)
instance Eq VPairNStack
instance Eq SlidyWide
instance LayoutManager lm => LayoutManager (Transposed lm)
instance Transposable (Layout a)
instance Transposable Orientation
instance LayoutManager VPairNStack
instance LayoutManager HPairNStack
instance LayoutManager SlidyWide
instance LayoutManager SlidyTall
instance LayoutManager Wide
instance LayoutManager Tall
instance Default AnyLayoutManager
instance LayoutManager AnyLayoutManager
instance Eq AnyLayoutManager
instance Default a => Default (Layout a)
instance Show a => Show (Layout a)

module Yi.Monad

-- | Gets specific component of the state, using a projection function
--   supplied.
gets :: MonadState s m => (s -> a) -> m a

-- | Combination of the Control.Monad.State <tt>modify</tt> and <a>gets</a>
getsAndModify :: MonadState s m => (s -> (s, a)) -> m a
maybeM :: Monad m => (x -> m ()) -> Maybe x -> m ()

-- | Rerun the monad until the boolean result is false, collecting list of
--   results.
repeatUntilM :: Monad m => m (Bool, a) -> m [a]
whenM :: Monad m => m Bool -> m () -> m ()
with :: (MonadReader r m, MonadBase b m) => (r -> a) -> (a -> b c) -> m c

module Yi.Process
runProgCommand :: String -> [String] -> IO (ExitCode, String, String)
runShellCommand :: String -> IO (ExitCode, String, String)

-- | Run a command using the system shell, returning stdout, stderr and
--   exit code
shellFileName :: IO String
createSubprocess :: FilePath -> [String] -> BufferRef -> IO SubprocessInfo
readAvailable :: Handle -> IO String
data SubprocessInfo
SubprocessInfo :: FilePath -> [String] -> ProcessHandle -> Handle -> Handle -> Handle -> BufferRef -> Bool -> SubprocessInfo
procCmd :: SubprocessInfo -> FilePath
procArgs :: SubprocessInfo -> [String]
procHandle :: SubprocessInfo -> ProcessHandle
hIn :: SubprocessInfo -> Handle
hOut :: SubprocessInfo -> Handle
hErr :: SubprocessInfo -> Handle
bufRef :: SubprocessInfo -> BufferRef
separateStdErr :: SubprocessInfo -> Bool
type SubprocessId = Integer


-- | This is a library of interactive processes combinators, usable to
--   define extensible keymaps.
--   
--   (Inspired by the Parsec library, written by Koen Claessen)
--   
--   The processes are:
--   
--   <ul>
--   <li>composable: in parallel using <a>&lt;|&gt;</a>, in sequence using
--   monadic bind.</li>
--   <li>extensible: it is always possible to override a behaviour by
--   combination of <a>adjustPriority</a> and <a>&lt;|&gt;</a>. (See also
--   <a>&lt;||</a> for a convenient combination of the two.)</li>
--   <li>monadic: sequencing is done via monadic bind. (leveraging the
--   whole battery of monadic tools that Haskell provides)</li>
--   </ul>
--   
--   The processes can parse input, and write output that depends on it.
--   
--   The semantics are quite obvious; only disjunction deserve a bit more
--   explanation:
--   
--   in <tt>p = (a <a>&lt;|&gt;</a> b)</tt>, what happens if <tt>a</tt> and
--   <tt>b</tt> recognize the same input (prefix), but produce conflicting
--   output?
--   
--   <ul>
--   <li>if the output is the same (as by the Eq class), then the processes
--   (prefixes) are "merged"</li>
--   <li>if a Write is more prioritized than the other, the one with low
--   priority will be discarded</li>
--   <li>otherwise, the output will be delayed until one of the branches
--   can be discarded.</li>
--   <li>if there is no way to disambiguate, then no output will be
--   generated anymore. This situation can be detected by using
--   <tt>possibleActions</tt> however.</li>
--   </ul>
module Yi.Interact

-- | Interactive process description
data I ev w a

-- | Operational representation of a process
data P event w
End :: P event w
Chain :: (P event mid) -> (P mid w) -> P event w

-- | Abstraction of the automaton state.
data InteractState event w
Ambiguous :: [(Int, w, P event w)] -> InteractState event w
Waiting :: InteractState event w
Dead :: InteractState event w
Running :: w -> (P event w) -> InteractState event w

-- | Abstraction of monadic interactive processes
class (Eq w, Monad m, Alternative m, Applicative m, MonadPlus m) => MonadInteract m w e | m -> w e
write :: MonadInteract m w e => w -> m ()
eventBounds :: (MonadInteract m w e, Ord e) => Maybe e -> Maybe e -> m e
adjustPriority :: MonadInteract m w e => Int -> m ()
deprioritize :: MonadInteract f w e => f ()

-- | Just like '(&lt;||)' but in prefix form. It <a>deprioritize</a>s the
--   second argument.
important :: MonadInteract f w e => f a -> f a -> f a
(<||) :: MonadInteract f w e => f a -> f a -> f a
(||>) :: MonadInteract f w e => f a -> f a -> f a

-- | <tt>option x p</tt> will either parse <tt>p</tt> or return <tt>x</tt>
--   without consuming any input.
option :: MonadInteract m w e => a -> m a -> m a
oneOf :: (Ord event, MonadInteract m w event) => [event] -> m event
processOneEvent :: Eq w => P event w -> event -> ([w], P event w)
computeState :: Eq w => P event w -> InteractState event w

-- | Parses and returns the specified character.
event :: (Ord event, MonadInteract m w event) => event -> m event

-- | Parses and returns the specified list of events (lazily).
events :: (Ord event, MonadInteract m w event) => [event] -> m [event]

-- | Combines all parsers in the specified list.
choice :: MonadInteract m w e => [m a] -> m a
mkAutomaton :: Eq w => I ev w a -> P ev w
idAutomaton :: (Ord a, Eq a) => P a a
runWrite :: Eq w => P event w -> [event] -> [w]
anyEvent :: (Ord event, MonadInteract m w event) => m event
eventBetween :: (Ord e, MonadInteract m w e) => e -> e -> m e
accepted :: Show ev => Int -> P ev w -> [[Text]]
instance (Show w, Show ev) => Show (P ev w)
instance Monoid (InteractState event w)
instance Eq w => MonadInteract (I event w) w event
instance Eq w => MonadPlus (I event w)
instance Monad (I event w)
instance Alternative (I ev w)
instance Applicative (I ev w)
instance Functor (I event w)
instance MonadInteract m w e => MonadInteract (StateT s m) w e


-- | Operations on <a>Window</a>s, in the emacs sense of the word.
module Yi.Window

-- | A window onto a buffer.
data Window
Window :: !Bool -> !BufferRef -> ![BufferRef] -> !Int -> !Int -> !Region -> !WindowRef -> !Int -> !JumpList -> Window

-- | regular or mini window?
isMini :: Window -> !Bool

-- | the buffer this window opens to
bufkey :: Window -> !BufferRef

-- | list of last accessed buffers (former bufKeys). Last accessed one is
--   first element
bufAccessList :: Window -> ![BufferRef]

-- | height of the window (in number of screen lines displayed)
height :: Window -> !Int

-- | width of the window (in number of chars)
width :: Window -> !Int

-- | view area. note that the top point is also available as a buffer mark.
winRegion :: Window -> !Region

-- | identifier for the window (for UI sync) This is required for accurate
--   scrolling. Scrolling depends on the actual number of buffer lines
--   displayed. Line wrapping changes that number relative to the height so
--   we can't use height for that purpose.
wkey :: Window -> !WindowRef

-- | The actual number of buffer lines displayed. Taking into account line
--   wrapping
actualLines :: Window -> !Int
jumpList :: Window -> !JumpList
wkeyA :: Lens' Window WindowRef
winRegionA :: Lens' Window Region
widthA :: Lens' Window Int
jumpListA :: Lens' Window JumpList
isMiniA :: Lens' Window Bool
heightA :: Lens' Window Int
bufkeyA :: Lens' Window BufferRef
bufAccessListA :: Lens' Window [BufferRef]
actualLinesA :: Lens' Window Int

-- | Get the identification of a window.
winkey :: Window -> (Bool, BufferRef)

-- | Return a "fake" window onto a buffer.
dummyWindow :: BufferRef -> Window
instance Eq Window
instance Show Window
instance Binary Window
instance Typeable Window

module Yi.Tab

-- | A tab, containing a collection of windows.
data Tab
type TabRef = Int

-- | Accessor for the windows. If the windows (but not the focus) have
--   changed when setting, then a relayout will be triggered to preserve
--   the internal invariant.
tabWindowsA :: Functor f => (PointedList Window -> f (PointedList Window)) -> Tab -> f Tab

-- | Accessor for the layout manager. When setting, will trigger a relayout
--   if the layout manager has changed.
tabLayoutManagerA :: Functor f => (AnyLayoutManager -> f AnyLayoutManager) -> Tab -> f Tab

-- | Gets / sets the position of the divider with the given reference. The
--   caller must ensure that the DividerRef is valid, otherwise an error
--   will (might!) occur.
tabDividerPositionA :: DividerRef -> Lens' Tab DividerPosition

-- | For UI sync; fixes #304
tkey :: Tab -> TabRef

-- | Returns a list of all mini windows associated with the given tab
tabMiniWindows :: Tab -> [Window]
tabFocus :: Tab -> Window

-- | Forces all windows in the tab
forceTab :: Tab -> Tab

-- | A specialised version of "fmap".
mapWindows :: (Window -> Window) -> Tab -> Tab

-- | Current layout. Invariant: must be the layout generated by
--   <a>tabLayoutManager</a>, up to changing the <a>divPos</a>s.
tabLayout :: Tab -> (Layout WindowRef)

-- | Folds over the windows in the tab
tabFoldl :: (a -> Window -> a) -> a -> Tab -> a

-- | Make a tab from multiple windows
makeTab :: TabRef -> PointedList Window -> Tab

-- | Make a tab from one window
makeTab1 :: TabRef -> Window -> Tab
instance Typeable Tab
instance Show Tab
instance Eq Tab
instance Binary Tab


-- | String manipulation utilities
module Yi.String
isBlank :: YiString -> Bool

-- | Remove any trailing strings matching <i>irs</i> (input record
--   separator) from input string. Like perl's chomp(1).
chomp :: String -> String -> String
capitalize :: String -> String
capitalizeFirst :: YiString -> YiString

-- | Trim spaces at beginning <i>and</i> end
dropSpace :: String -> String

-- | Fills lines up to the given length, splitting the text up if
--   necessary.
fillText :: Int -> YiString -> [YiString]
onLines :: ([YiString] -> [YiString]) -> YiString -> YiString

-- | A helper function for creating functions suitable for
--   <tt>modifySelectionB</tt> and <tt>modifyRegionB</tt>. To be used when
--   the desired function should map across the lines of a region.
mapLines :: (YiString -> YiString) -> YiString -> YiString

-- | Split a Text in lines. Unlike <a>lines</a>, this does not remove any
--   empty line at the end.
lines' :: Text -> [Text]

-- | Inverse of <a>lines'</a>. In contrast to <a>unlines</a>, this does not
--   add an empty line at the end.
unlines' :: [Text] -> Text
padLeft :: Int -> String -> String
padRight :: Int -> String -> String

-- | Works by resupplying the found prefix back into the list, eventually
--   either finding the prefix or not matching.
commonTPrefix :: [Text] -> Maybe Text

-- | Like <a>commonTPrefix</a> but returns empty text on failure.
commonTPrefix' :: [Text] -> Text

-- | This is kind of like the default Show instance for lists except over
--   <a>Text</a>. It does not leave the elements in extra quotes and should
--   not be attempted to be <a>show</a>n and <a>read</a> back.
listify :: [YiString] -> YiString

-- | Helper that shows then packs the <tt>Text</tt>, for all those cases
--   where we use <a>show</a>.
showT :: Show a => a -> Text

-- | <tt>overInit f</tt> runs f over the <a>init</a> of the input if
--   possible, preserving the <a>last</a> element as-is. If given a string
--   with length ≤ 1, it effectively does nothing.
--   
--   Also see <a>overTail</a>.
overInit :: (YiString -> YiString) -> YiString -> YiString

-- | <tt>overInit f</tt> runs f over the <a>tail</a> of the input if
--   possible, preserving the <a>head</a> element as-is. If given a string
--   with length ≤ 1, it effectively does nothing.
--   
--   Also see <a>overInit</a>.
overTail :: (YiString -> YiString) -> YiString -> YiString


module Yi.Syntax.Tree
class Foldable tree => IsTree tree where subtrees = fst . uniplate
subtrees :: IsTree tree => tree t -> [tree t]
uniplate :: IsTree tree => tree t -> ([tree t], [tree t] -> tree t)
emptyNode :: IsTree tree => tree t
toksAfter :: Foldable t1 => t -> t1 a -> [a]
allToks :: Foldable t => t a -> [a]
tokAtOrBefore :: Foldable t => Point -> t (Tok t1) -> Maybe (Tok t1)
toksInRegion :: Foldable t1 => Region -> t1 (Tok t) -> [Tok t]
sepBy :: Alternative f => f a -> f v -> f [a]
sepBy1 :: Alternative f => f a -> f v -> f [a]
getLastOffset :: Foldable t => t (Tok t1) -> Point
getFirstOffset :: Foldable t => t (Tok t1) -> Point

-- | Return the 1st token of a subtree.
getFirstElement :: Foldable t => t a -> Maybe a

-- | Return the last token of a subtree.
getLastElement :: Foldable t => t a -> Maybe a

-- | Search the given list, and return the last tree before the given
--   point; with path to the root. (Root is at the start of the path)
getLastPath :: IsTree tree => [tree (Tok t)] -> Point -> Maybe [tree (Tok t)]

-- | Return all subtrees in a tree, in preorder.
getAllSubTrees :: IsTree tree => tree t -> [tree t]
tokenBasedAnnots :: Foldable t1 => (a1 -> Maybe a) -> t1 a1 -> t -> [a]
tokenBasedStrokes :: Foldable t3 => (a -> b) -> t3 a -> t -> t2 -> t1 -> [b]
subtreeRegion :: Foldable t => t (Tok t1) -> Region

-- | Search the tree in pre-order starting at a given node, until finding a
--   leaf which is at or after the given point. An effort is also made to
--   return a leaf as close as possible to <tt>p</tt>.
--   
--   TODO: rename to fromLeafToLeafAt
fromLeafToLeafAfter :: IsTree tree => Point -> Node (tree (Tok a)) -> Node (tree (Tok a))

-- | Given an approximate path to a leaf at the end of the region, return:
--   (path to leaf at the end of the region,path from focused node to the
--   leaf, small node encompassing the region)
fromNodeToFinal :: IsTree tree => Region -> Node (tree (Tok a)) -> Node (tree (Tok a))
instance Show a => Show (Test a)
instance Eq a => Eq (Test a)
instance Foldable Test
instance Show NTTT
instance Arbitrary NTTT
instance Arbitrary (Test TT)
instance IsTree Test


-- | Module defining the <a>Tree</a> used as part of many <tt>Mode</tt>s.
module Yi.Syntax.OnlineTree
data Tree a
Bin :: (Tree a) -> (Tree a) -> Tree a
Leaf :: a -> Tree a
Tip :: Tree a
manyToks :: P (Tok t) (Tree (Tok t))
tokAtOrBefore :: Foldable t => Point -> t (Tok t1) -> Maybe (Tok t1)
instance Show a => Show (Tree a)
instance Functor Tree
instance Foldable Tree
instance Traversable Tree
instance IsTree Tree


-- | This module defines implementations of syntax-awareness drivers.
module Yi.Syntax.Driver
type Path = [Int]
data Cache state tree tt
Cache :: Map WindowRef Path -> [state] -> tree (Tok tt) -> !(Map WindowRef (tree (Tok tt))) -> Cache state tree tt
path :: Cache state tree tt -> Map WindowRef Path
cachedStates :: Cache state tree tt -> [state]
root :: Cache state tree tt -> tree (Tok tt)
focused :: Cache state tree tt -> !(Map WindowRef (tree (Tok tt)))
mkHighlighter :: (IsTree tree, Show state) => (Scanner Point Char -> Scanner state (tree (Tok tt))) -> Highlighter (Cache state tree tt) (tree (Tok tt))
unzipFM :: Ord k => [(k, (u, v))] -> (Map k u, Map k v)
zipWithFM :: Ord k => (u -> v -> w) -> v -> Map k u -> Map k v -> [(k, w)]


-- | NOTES: Note if the layout of the first line (not comments) is wrong
--   the parser will only parse what is in the blocks given by Layout.hs
module Yi.Syntax.Haskell
type PModule = Exp
type PModuleDecl = Exp
type PImport = Exp

-- | Exp can be expression or declaration
data Exp t
PModule :: [t] -> Maybe (PModule t) -> Exp t
comments :: Exp t -> [t]
progMod :: Exp t -> Maybe (PModule t)
ProgMod :: PModuleDecl t -> PModule t -> Exp t
modDecl :: Exp t -> PModuleDecl t

-- | The module declaration part
body :: Exp t -> PModule t
Body :: Exp t -> Block t -> Block t -> Exp t
imports :: Exp t -> Exp t
content :: Exp t -> Block t

-- | The body of the module
extraContent :: Exp t -> Block t
PModuleDecl :: PAtom t -> PAtom t -> Exp t -> Exp t -> Exp t
moduleKeyword :: Exp t -> PAtom t
name :: Exp t -> PAtom t
exports :: Exp t -> Exp t
whereKeyword :: Exp t -> Exp t
PImport :: PAtom t -> Exp t -> PAtom t -> Exp t -> Exp t -> Exp t
importKeyword :: Exp t -> PAtom t
qual :: Exp t -> Exp t
name' :: Exp t -> PAtom t
as :: Exp t -> Exp t
specification :: Exp t -> Exp t

-- | Type signature
TS :: t -> [Exp t] -> Exp t

-- | Type declaration
PType :: PAtom t -> Exp t -> PAtom t -> Exp t -> Exp t
typeKeyword :: Exp t -> PAtom t
typeCons :: Exp t -> Exp t
equal :: Exp t -> PAtom t
btype :: Exp t -> Exp t

-- | Data declaration
PData :: PAtom t -> Exp t -> Exp t -> Exp t -> Exp t
dataKeyword :: Exp t -> PAtom t
dtypeCons :: Exp t -> Exp t
dEqual :: Exp t -> Exp t
dataRhs :: Exp t -> Exp t
PData' :: PAtom t -> Exp t -> Exp t
dEqual :: Exp t -> PAtom t

-- | Data declaration RHS
dataCons :: Exp t -> Exp t
PClass :: PAtom t -> Exp t -> Exp t -> Exp t
cKeyword :: Exp t -> PAtom t
cHead :: Exp t -> Exp t

-- | Class declaration
cwhere :: Exp t -> Exp t

-- | A parenthesized, bracked or braced
Paren :: (PAtom t) -> [Exp t] -> (PAtom t) -> Exp t

-- | A block of things separated by layout
Block :: [Exp t] -> Exp t

-- | An atom is a token followed by many comments
PAtom :: t -> [t] -> Exp t
Expr :: [Exp t] -> Exp t

-- | Where clause
PWhere :: (PAtom t) -> (Exp t) -> (Exp t) -> Exp t
Bin :: (Exp t) -> (Exp t) -> Exp t
PError :: t -> t -> [t] -> Exp t
errorTok :: Exp t -> t
marker :: Exp t -> t

-- | An wrapper for errors
commentList :: Exp t -> [t]

-- | Righthandside of functions with =
RHS :: (PAtom t) -> (Exp t) -> Exp t

-- | An optional
Opt :: (Maybe (Exp t)) -> Exp t

-- | Module identifier
Modid :: t -> [t] -> Exp t
Context :: (Exp t) -> (Exp t) -> (PAtom t) -> Exp t

-- | Righthandside of functions with | the PAtom in PGuard' does not
--   contain any comments
PGuard :: [PGuard t] -> Exp t
PGuard' :: (PAtom t) -> (Exp t) -> (PAtom t) -> Exp t

-- | Type constructor data constructor same as with the TC constructor
TC :: (Exp t) -> Exp t

-- | Data constructor
DC :: (Exp t) -> Exp t

-- | let expression
PLet :: (PAtom t) -> (Exp t) -> (Exp t) -> Exp t
PIn :: t -> [Exp t] -> Exp t
type Tree = PModule

-- | The parser
parse :: P TT (Tree TT)
indentScanner :: Scanner (AlexState lexState) TT -> Scanner (State Token lexState) TT
instance Show t => Show (Exp t)
instance Foldable Exp
instance IsTree Exp


-- | Parser for Haskell that only cares about parenthesis and layout.
module Yi.Syntax.Paren
indentScanner :: Scanner (AlexState lexState) TT -> Scanner (State Token lexState) TT
isBrace :: TT -> Bool
ignoredToken :: TT -> Bool
isNoise :: Token -> Bool
type Expr t = [Tree t]
data Tree t
Paren :: t -> (Expr t) -> t -> Tree t
Block :: ([Tree t]) -> Tree t
Atom :: t -> Tree t
Error :: t -> Tree t
Expr :: [Tree t] -> Tree t

-- | Search the given list, and return the 1st tree after the given point
--   on the given line. This is the tree that will be moved if something is
--   inserted at the point. Precondition: point is in the given line.
getIndentingSubtree :: Tree TT -> Point -> Int -> Maybe (Tree TT)

-- | Given a tree, return (first offset, number of lines).
getSubtreeSpan :: Tree TT -> (Point, Int)
parse :: P TT (Tree TT)
parse' :: (TT -> Token) -> (Token -> TT) -> P TT [Tree TT]
getStrokes :: Point -> Point -> Point -> Tree TT -> [Stroke]
tokenToStroke :: TT -> Stroke
modStroke :: StyleName -> Stroke -> Stroke
tokenToAnnot :: TT -> Maybe (Span String)

-- | Create a special error token. (e.g. fill in where there is no correct
--   token to parse) Note that the position of the token has to be correct
--   for correct computation of node spans.
errTok :: Parser (Tok t) (Tok Token)
instance Show t => Show (Tree t)
instance Foldable Tree
instance Functor Tree
instance IsTree Tree


-- | Produces <a>Stroke</a>s from a tree of tokens, used by some of the
--   Haskell modes.
module Yi.Syntax.Strokes.Haskell
getStrokes :: Point -> Point -> Point -> Tree TT -> [Stroke]
tokenToAnnot :: TT -> Maybe (Span String)


-- | Parser used by the LaTeX modes.
module Yi.Syntax.Latex
isNoise :: Token -> Bool
type TT = Tok Token
type Expr t = [Tree t]
data Tree t
Paren :: t -> (Tree t) -> t -> Tree t
Atom :: t -> Tree t
Error :: t -> Tree t
Expr :: (Expr t) -> Tree t
parse :: P TT (Tree TT)
getStrokes :: Point -> Point -> Point -> Tree TT -> [Stroke]
modStroke :: StyleName -> Stroke -> Stroke
tokenToStroke :: TT -> Stroke
tokenToAnnot :: TT -> Maybe (Span String)
tokenToStyle :: Token -> StyleName
isSpecial :: String -> Token -> Bool
isBegin :: Token -> Bool
isEnd :: Token -> Bool
isErrorTok :: Token -> Bool
instance Show t => Show (Tree t)
instance Functor Tree
instance Foldable Tree
instance IsTree Tree


-- | Parser for the JavaScript language as described at <a>Dogan 2009</a>.
--   
--   The mode using this parser can be found at <a>Yi.Mode.JavaScript</a>.
module Yi.Syntax.JavaScript

-- | Instances of <tt>Strokable</tt> are datatypes which can be syntax
--   highlighted.
class Strokable a
toStrokes :: Strokable a => a -> Endo [Stroke]

-- | Instances of <tt>Failable</tt> can represent failure. This is a useful
--   class for future work, since then we can make stroking much easier.
class Failable f
stupid :: Failable f => t -> f t
hasFailed :: Failable f => f t -> Bool
type BList a = [a]
type Tree t = BList (Statement t)
type Semicolon t = Maybe t
data Statement t
FunDecl :: t -> t -> (Parameters t) -> (Block t) -> Statement t
VarDecl :: t -> (BList (VarDecAss t)) -> (Semicolon t) -> Statement t
Return :: t -> (Maybe (Expr t)) -> (Semicolon t) -> Statement t
While :: t -> (ParExpr t) -> (Block t) -> Statement t
DoWhile :: t -> (Block t) -> t -> (ParExpr t) -> (Semicolon t) -> Statement t
For :: t -> t -> (Expr t) -> (ForContent t) -> t -> (Block t) -> Statement t
If :: t -> (ParExpr t) -> (Block t) -> (Maybe (Statement t)) -> Statement t
Else :: t -> (Block t) -> Statement t
With :: t -> (ParExpr t) -> (Block t) -> Statement t
Comm :: t -> Statement t
Expr :: (Expr t) -> (Semicolon t) -> Statement t
data Parameters t
Parameters :: t -> (BList t) -> t -> Parameters t
ParErr :: t -> Parameters t
data ParExpr t
ParExpr :: t -> (BList (Expr t)) -> t -> ParExpr t
ParExprErr :: t -> ParExpr t
data ForContent t
ForNormal :: t -> (Expr t) -> t -> (Expr t) -> ForContent t
ForIn :: t -> (Expr t) -> ForContent t
ForErr :: t -> ForContent t
data Block t
Block :: t -> (BList (Statement t)) -> t -> Block t
BlockOne :: (Statement t) -> Block t
BlockErr :: t -> Block t

-- | Represents either a variable name or a variable name assigned to an
--   expression. <tt>AssBeg</tt> is a variable name <i>maybe</i> followed
--   by an assignment. <tt>AssRst</tt> is an equals sign and an expression.
--   <tt>(AssBeg <tt>x</tt> (Just (AssRst '=' '5')))</tt> means <tt>x =
--   5</tt>.
data VarDecAss t
AssBeg :: t -> (Maybe (VarDecAss t)) -> VarDecAss t
AssRst :: t -> (Expr t) -> VarDecAss t
AssErr :: t -> VarDecAss t
data Expr t
ExprObj :: t -> (BList (KeyValue t)) -> t -> Expr t
ExprPrefix :: t -> (Expr t) -> Expr t
ExprNew :: t -> (Expr t) -> Expr t
ExprSimple :: t -> (Maybe (Expr t)) -> Expr t
ExprParen :: t -> (Expr t) -> t -> (Maybe (Expr t)) -> Expr t
ExprAnonFun :: t -> (Parameters t) -> (Block t) -> Expr t
ExprTypeOf :: t -> (Expr t) -> Expr t
ExprFunCall :: t -> (ParExpr t) -> (Maybe (Expr t)) -> Expr t
OpExpr :: t -> (Expr t) -> Expr t
ExprCond :: t -> (Expr t) -> t -> (Expr t) -> Expr t
ExprArr :: t -> (Maybe (Array t)) -> t -> (Maybe (Expr t)) -> Expr t
PostExpr :: t -> Expr t
ExprErr :: t -> Expr t
data Array t
ArrCont :: (Expr t) -> (Maybe (Array t)) -> Array t
ArrRest :: t -> (Array t) -> (Maybe (Array t)) -> Array t
ArrErr :: t -> Array t
data KeyValue t
KeyValue :: t -> t -> (Expr t) -> KeyValue t
KeyValueErr :: t -> KeyValue t

-- | TODO: This code is *screaming* for some generic programming.
--   
--   TODO: Somehow fix Failable and failStroker to be more "generic". This
--   will make these instances much nicer and we won't have to make ad-hoc
--   stuff like this.

-- | Normal stroker.
normal :: TT -> Endo [Stroke]

-- | Error stroker.
error :: TT -> Endo [Stroke]
one :: (t -> a) -> t -> Endo [a]

-- | Given a new style and a stroke, return a stroke with the new style
--   appended to the old one.
modStroke :: StyleName -> Stroke -> Stroke

-- | Given a list of tokens to check for errors (<tt>xs</tt>) and a list of
--   tokens to stroke (<tt>xs'</tt>), returns normal strokes for
--   <tt>xs'</tt> if there were no errors. Otherwise returns error strokes
--   for <tt>xs'</tt>.
nError :: [TT] -> [TT] -> Endo [Stroke]

-- | Given a list of <tt>TT</tt>, if any of them is an error, returns an
--   error stroker, otherwise a normal stroker. Using e.g. existentials, we
--   could make this more general and have support for heterogeneous lists
--   of elements which implement Failable, but I haven't had the time to
--   fix this.
failStroker :: [TT] -> TT -> Endo [Stroke]

-- | Given a <tt>TT</tt>, return a <tt>Stroke</tt> for it.
tokenToStroke :: TT -> Stroke

-- | The main stroking function.
getStrokes :: Tree TT -> Point -> Point -> Point -> [Stroke]

-- | Main parser.
parse :: P TT (Tree TT)

-- | Parser for statements such as "return", "while", "do-while", "for",
--   etc.
statement :: P TT (Statement TT)

-- | Parser for "blocks", i.e. a bunch of statements wrapped in curly
--   brackets <i>or</i> just a single statement.
--   
--   Note that this works for JavaScript 1.8 "lambda" style function bodies
--   as well, e.g. "function hello() 5", since expressions are also
--   statements and we don't require a trailing semi-colon.
--   
--   TODO: function hello() var x; is not a valid program.
block :: P TT (Block TT)

-- | Parser for expressions which may be statements. In reality, any
--   expression is also a valid statement, but this is a slight compromise
--   to get rid of the massive performance loss which is introduced when
--   allowing JavaScript objects to be valid statements.
stmtExpr :: P TT (Expr TT)

-- | The basic idea here is to parse "the rest" of expressions, e.g. <tt>+
--   3</tt> in <tt>x + 3</tt> or <tt>[i]</tt> in <tt>x[i]</tt>. Anything
--   which is useful in such a scenario goes here. TODO: This accepts [],
--   but shouldn't, since x[] is invalid.
opExpr :: P TT (Expr TT)

-- | Parser for expressions.
expression :: P TT (Expr TT)

-- | Parses both empty and non-empty arrays. Should probably be split up
--   into further parts to allow for the separation of <tt>[]</tt> and
--   <tt>[1, 2, 3]</tt>.
array :: P TT (Expr TT)

-- | Parses a semicolon if it's there.
semicolon :: P TT (Maybe TT)

-- | Parses a comma-separated list of valid identifiers.
parameters :: P TT (Parameters TT)
parExpr :: P TT (ParExpr TT)

-- | Parses a comment.
comment :: P TT TT

-- | Parses a prefix operator.
preOp :: P TT TT

-- | Parses a infix operator.
inOp :: P TT TT

-- | Parses a postfix operator.
postOp :: P TT TT

-- | Parses any literal.
opTok :: P TT TT

-- | Parses any literal.
simpleTok :: P TT TT

-- | Parses any string.
strTok :: P TT TT

-- | Parses any valid number.
numTok :: P TT TT

-- | Parses any valid identifier.
name :: P TT TT

-- | Parses any boolean.
boolean :: P TT TT

-- | Parses a reserved word.
res :: Reserved -> P TT TT

-- | Parses a special token.
spc :: Char -> P TT TT

-- | Parses an operator.
oper :: Operator -> P TT TT

-- | Expects a token x, recovers with <a>errorToken</a>.
plzTok :: P TT TT -> P TT TT

-- | Expects a special token.
plzSpc :: Char -> P TT TT

-- | Expects an expression.
plzExpr :: P TT (Expr TT)
plz :: Failable f => P TT (f TT) -> P TT (f TT)

-- | General recovery parser, inserts an error token.
anything :: P s TT

-- | Weighted recovery.
hate :: Int -> P s a -> P s a
fromBlock :: Block t -> [Statement t]
firstTok :: Foldable f => f t -> t
errorToken :: TT
isError :: TT -> Bool

-- | Better name for <a>tokFromT</a>.
toTT :: t -> Tok t

-- | Better name for <a>tokT</a>.
fromTT :: Tok t -> t
instance Typeable Parameters
instance Typeable KeyValue
instance Typeable Expr
instance Typeable Array
instance Typeable Block
instance Typeable Statement
instance Typeable VarDecAss
instance Typeable ForContent
instance Typeable ParExpr
instance Show t => Show (Parameters t)
instance Data t => Data (Parameters t)
instance Foldable Parameters
instance Show t => Show (KeyValue t)
instance Data t => Data (KeyValue t)
instance Foldable KeyValue
instance Show t => Show (Expr t)
instance Data t => Data (Expr t)
instance Foldable Expr
instance Show t => Show (Array t)
instance Data t => Data (Array t)
instance Foldable Array
instance Show t => Show (Block t)
instance Data t => Data (Block t)
instance Foldable Block
instance Show t => Show (Statement t)
instance Data t => Data (Statement t)
instance Foldable Statement
instance Show t => Show (VarDecAss t)
instance Data t => Data (VarDecAss t)
instance Foldable VarDecAss
instance Show t => Show (ForContent t)
instance Data t => Data (ForContent t)
instance Foldable ForContent
instance Show t => Show (ParExpr t)
instance Data t => Data (ParExpr t)
instance Foldable ParExpr
instance Strokable (Array TT)
instance Strokable (Tok Token)
instance Strokable (KeyValue TT)
instance Strokable (ParExpr TT)
instance Strokable (Parameters TT)
instance Strokable (Expr TT)
instance Strokable (VarDecAss TT)
instance Strokable (Block TT)
instance Strokable (ForContent TT)
instance Strokable (Statement TT)
instance Failable KeyValue
instance Failable Expr
instance Failable ParExpr
instance Failable Parameters
instance Failable VarDecAss
instance Failable Block
instance Failable ForContent
instance IsTree Statement

module Yi.Verifier.JavaScript
data Error
MultipleFunctionDeclaration :: String -> [Posn] -> Error
data Warning
UnreachableCode :: Posn -> Warning
data Report
Err :: Error -> Report
Warn :: Warning -> Report

-- | The main verifier which calls the sub-verifiers.
verify :: Tree TT -> Writer (DList Report) ()

-- | Given a list of function declarations, checks for multiple function
--   declarations, including the functions' subfunctions.
checkMultipleFuns :: [Statement TT] -> Writer (DList Report) ()
checkUnreachable :: [Statement TT] -> Writer (DList Report) ()

-- | Given two <tt>Tok t</tt>, compares the <tt>t</tt>s.
ttEq :: Eq t => Tok t -> Tok t -> Bool
say :: MonadWriter (DList a) m => a -> m ()
isReturn :: Statement t -> Bool

-- | Returns a list of the functions in the given block.
findFunctions :: [Statement t] -> [Statement t]

-- | Given a <a>FunDecl</a>, returns the token representing the name.
funName :: Statement t -> t

-- | Given a <a>FunDecl</a>, returns its inner body as a list.
funBody :: Statement t -> [Statement t]

-- | Given a <tt>ValidName</tt> returns the string representing the name.
nameOf :: Token -> String

-- | Like <a>dropWhile</a> but drops the first element in the result.
dropWhile' :: (a -> Bool) -> [a] -> [a]
dupsBy :: (a -> a -> Bool) -> [a] -> [a]
instance Eq Error
instance Eq Warning
instance Eq Report
instance Show Report
instance Show Warning
instance Show Error

module Yi.Config.Misc
data ScrollStyle
SnapToCenter :: ScrollStyle
SingleLine :: ScrollStyle


-- | An implementation of restricted, linear undo, as described in:
--   
--   <pre>
--   T. Berlage, "A selective undo mechanism for graphical user interfaces
--   based on command objects", ACM Transactions on Computer-Human
--   Interaction 1(3), pp. 269-294, 1994.
--   </pre>
--   
--   Implementation based on a proposal by sjw.
--   
--   From Berlage:
--   
--   <pre>
--   All buffer-mutating commands are stored (in abstract form) in an
--   Undo list. The most recent item in this list is the action that
--   will be undone next. When it is undone, it is removed from the Undo
--   list, and its inverse is added to the Redo list. The last command
--   put into the Redo list can be redone, and again prepended to the
--   Undo list. New commands are added to the Undo list without
--   affecting the Redo list.
--   </pre>
--   
--   Now, the above assumes that commands can be _redone_ in a state other
--   than that in which it was orginally done. This is not the case in our
--   text editor: a user may delete, for example, between an undo and a
--   redo. Berlage addresses this in S2.3. A Yi example:
--   
--   <pre>
--   Delete some characters
--   Undo partialy
--   Move prior in the file, and delete another _chunk_
--   Redo some things  == corruption.
--   </pre>
--   
--   Berlage describes the <i>stable execution property</i>:
--   
--   <pre>
--   A command is always redone in the same state that it was originally
--   executed in, and is always undone in the state that was reached
--   after the original execution.
--   </pre>
--   
--   <pre>
--   The only case where the linear undo model violates the stable
--   execution property is when _a new command is submitted while the
--   redo list is not empty_. The _restricted linear undo model_ ...
--   clears the redo list in this case.
--   </pre>
--   
--   Also some discussion of this in: <i>The Text Editor Sam</i>, Rob Pike,
--   pg 19.
module Yi.Buffer.Undo

-- | A new empty <a>URList</a>. Notice we must have a saved file point as
--   this is when we assume we are opening the file so it is currently the
--   same as the one on disk
emptyU :: URList

-- | Add an action to the undo list. According to the restricted, linear
--   undo model, if we add a command whilst the redo list is not empty, we
--   will lose our redoable changes.
addChangeU :: Change -> URList -> URList

-- | Add a saved file point so that we can tell that the buffer has not
--   been modified since the previous saved file point. Notice that we must
--   be sure to remove the previous saved file points since they are now
--   worthless.
setSavedFilePointU :: URList -> URList

-- | undoIsAtSavedFilePoint. <tt>True</tt> if the undo list is at a
--   SavedFilePoint indicating that the buffer has not been modified since
--   we last saved the file. Note: that an empty undo list does NOT mean
--   that the buffer is not modified since the last save. Because we may
--   have saved the file and then undone actions done before the save.
isAtSavedFilePointU :: URList -> Bool

-- | This undoes one interaction step.
undoU :: Mark -> URList -> BufferImpl syntax -> (BufferImpl syntax, (URList, [Update]))

-- | This redoes one iteraction step.
redoU :: Mark -> URList -> BufferImpl syntax -> (BufferImpl syntax, (URList, [Update]))

-- | A URList consists of an undo and a redo list.
data URList
data Change
InteractivePoint :: Change
AtomicChange :: !Update -> Change
instance Show Change
instance Generic Change
instance Show URList
instance Generic URList
instance Datatype D1Change
instance Constructor C1_0Change
instance Constructor C1_1Change
instance Constructor C1_2Change
instance Datatype D1URList
instance Constructor C1_0URList
instance Binary URList
instance Binary Change

module Yi.UI.Common

-- | Record presenting a frontend's interface.
--   
--   The functions <a>layout</a> and <a>refresh</a> are both run by the
--   editor's main loop, in response to user actions and so on. Their
--   relation is a little subtle, and is discussed here:
--   
--   <ul>
--   <li>to see some code, look at the function <tt>refreshEditor</tt> in
--   <a>Yi.Core</a>. This is the only place where <a>layout</a> and
--   <a>refresh</a> are used.</li>
--   <li>the function <a>layout</a> is responsible for updating the
--   <tt>Editor</tt> with the width and height of the windows. Some
--   frontends, such as Pango, need to modify their internal state to do
--   this, and will consequently change their display. This is
--   expected.</li>
--   <li>the function <a>refresh</a> should cause the UI to update its
--   display with the information given in the <tt>Editor</tt>.</li>
--   <li>the functionalities of <a>layout</a> and <a>refresh</a> overlap to
--   some extent, in the sense that both may cause the frontend to update
--   its display. The Yi core provides the following guarantees which the
--   frontend may take advantage of:<ul><li>in the main editor loop (i.e.
--   in the <tt>refreshEditor</tt> function), <a>layout</a> will be run
--   (possibly multiple times) and then <a>refresh</a> will be run. This
--   guarantee will hold even in the case of threading (the function
--   <tt>refreshEditor</tt> will always be run atomically, using
--   <tt>MVar</tt>s).</li><li>between the last run of <a>layout</a> and the
--   run of <a>refresh</a>, some changes may be made to the
--   <tt>Editor</tt>. However, the text, text attributes, and (displayed)
--   window region of all windows will remain the same. However, the cursor
--   location may change.This guarantee allows frontends which calculate
--   rendering of the text during the <a>layout</a> stage to avoid
--   recalculating the render again during <a>refresh</a>. Pango is an
--   example of such a frontend.</li></ul></li>
--   </ul>
--   
--   The Yi core provides no guarantee about the OS thread from which the
--   functions <a>layout</a> and <a>refresh</a> are called from. In
--   particular, subprocesses (e.g. compilation, ghci) will run
--   <a>layout</a> and <a>refresh</a> from new OS threads (see
--   <tt>startSubprocessWatchers</tt> in <a>Yi.Core</a>). The frontend must
--   be preparaed for this: for instance, Gtk-based frontends should wrap
--   GUI updates in <tt>postGUIAsync</tt>.
data UI e
UI :: IO () -> (Bool -> IO ()) -> IO () -> (e -> IO ()) -> IO () -> (e -> IO e) -> (FilePath -> IO ()) -> UI e

-- | Main loop
main :: UI e -> IO ()

-- | Clean up, and also terminate if given <tt>true</tt>
end :: UI e -> Bool -> IO ()

-- | Suspend (or minimize) the program
suspend :: UI e -> IO ()

-- | Refresh the UI with the given state
refresh :: UI e -> e -> IO ()

-- | User force-refresh (in case the screen has been messed up from
--   outside)
userForceRefresh :: UI e -> IO ()

-- | Set window width and height
layout :: UI e -> e -> IO e

-- | Reload cabal project views
reloadProject :: UI e -> FilePath -> IO ()
dummyUI :: UI e


-- | This module is the host of the most prevalent types throughout Yi. It
--   is unfortunately a necessary evil to avoid use of bootfiles.
--   
--   You're encouraged to import from more idiomatic modules which will
--   re-export these where appropriate.
module Yi.Types
data Action
YiA :: (YiM a) -> Action
EditorA :: (EditorM a) -> Action
BufferA :: (BufferM a) -> Action
emptyAction :: Action
class (Default a, Binary a, Typeable a) => YiVariable a
class (Default a, Typeable a) => YiConfigVariable a
type Interact ev a = I ev Action a
type KeymapM a = Interact Event a
type Keymap = KeymapM ()
type KeymapEndo = Keymap -> Keymap
type KeymapProcess = P Event Action
data IsRefreshNeeded
MustRefresh :: IsRefreshNeeded
NoNeedToRefresh :: IsRefreshNeeded
data Yi
Yi :: UI Editor -> ([Event] -> IO ()) -> (IsRefreshNeeded -> [Action] -> IO ()) -> Config -> MVar YiVar -> Yi
yiUi :: Yi -> UI Editor

-- | input stream
yiInput :: Yi -> [Event] -> IO ()

-- | output stream
yiOutput :: Yi -> IsRefreshNeeded -> [Action] -> IO ()
yiConfig :: Yi -> Config

-- | The only mutable state in the program
yiVar :: Yi -> MVar YiVar
data YiVar
YiVar :: !Editor -> !SubprocessId -> !(Map SubprocessId SubprocessInfo) -> YiVar
yiEditor :: YiVar -> !Editor
yiSubprocessIdSupply :: YiVar -> !SubprocessId
yiSubprocesses :: YiVar -> !(Map SubprocessId SubprocessInfo)

-- | The type of user-bindable functions TODO: doc how these are actually
--   user-bindable are they?
newtype YiM a
YiM :: ReaderT Yi IO a -> YiM a
runYiM :: YiM a -> ReaderT Yi IO a
unsafeWithEditor :: Config -> MVar YiVar -> EditorM a -> IO a
data KeymapSet
KeymapSet :: Keymap -> Keymap -> KeymapSet

-- | Content of the top-level loop.
topKeymap :: KeymapSet -> Keymap

-- | For insertion-only modes
insertKeymap :: KeymapSet -> Keymap
extractTopKeymap :: KeymapSet -> Keymap

-- | The BufferM monad writes the updates performed.
newtype BufferM a
BufferM :: RWS Window [Update] FBuffer a -> BufferM a
fromBufferM :: BufferM a -> RWS Window [Update] FBuffer a

-- | Currently duplicates some of Vim's indent settings. Allowing a buffer
--   to specify settings that are more dynamic, perhaps via closures, could
--   be useful.
data IndentSettings
IndentSettings :: Bool -> Int -> Int -> IndentSettings

-- | Insert spaces instead of tabs as possible
expandTabs :: IndentSettings -> Bool

-- | Size of a Tab
tabSize :: IndentSettings -> Int

-- | Indent by so many columns
shiftWidth :: IndentSettings -> Int
data FBuffer
FBuffer :: !(Mode syntax) -> !(BufferImpl syntax) -> !Attributes -> FBuffer
bmode :: FBuffer -> !(Mode syntax)
rawbuf :: FBuffer -> !(BufferImpl syntax)
attributes :: FBuffer -> !Attributes
type WinMarks = MarkSet Mark
data MarkSet a
MarkSet :: !a -> !a -> !a -> MarkSet a
fromMark :: MarkSet a -> !a
insMark :: MarkSet a -> !a
selMark :: MarkSet a -> !a
data Attributes
Attributes :: !BufferId -> !BufferRef -> !URList -> !DynamicState -> !(Maybe Int) -> !(Maybe Int) -> ![UIUpdate] -> !SelectionStyle -> !KeymapProcess -> !(Map WindowRef WinMarks) -> !Window -> !UTCTime -> !Bool -> !Bool -> !Bool -> !(WindowRef -> Bool) -> !Bool -> ![Update] -> !Int -> Maybe ConverterName -> Attributes
ident :: Attributes -> !BufferId

-- | immutable unique key
bkey__ :: Attributes -> !BufferRef

-- | undo/redo list
undos :: Attributes -> !URList

-- | dynamic components
bufferDynamic :: Attributes -> !DynamicState

-- | prefered column to arrive at when we do a lineDown / lineUp
preferCol :: Attributes -> !(Maybe Int)

-- | prefered column to arrive at visually (ie, respecting wrap)
preferVisCol :: Attributes -> !(Maybe Int)

-- | updates that haven't been synched in the UI yet
pendingUpdates :: Attributes -> ![UIUpdate]
selectionStyle :: Attributes -> !SelectionStyle
keymapProcess :: Attributes -> !KeymapProcess
winMarks :: Attributes -> !(Map WindowRef WinMarks)
lastActiveWindow :: Attributes -> !Window

-- | time of the last synchronization with disk
lastSyncTime :: Attributes -> !UTCTime

-- | read-only flag
readOnly :: Attributes -> !Bool

-- | the keymap is ready for insertion into this buffer
inserting :: Attributes -> !Bool

-- | does buffer contain directory contents
directoryContent :: Attributes -> !Bool
pointFollowsWindow :: Attributes -> !(WindowRef -> Bool)
updateTransactionInFlight :: Attributes -> !Bool
updateTransactionAccum :: Attributes -> ![Update]
fontsizeVariation :: Attributes -> !Int

-- | How many points (frontend-specific) to change the font by in this
--   buffer
encodingConverterName :: Attributes -> Maybe ConverterName
data BufferId
MemBuffer :: Text -> BufferId
FileBuffer :: FilePath -> BufferId
data SelectionStyle
SelectionStyle :: !Bool -> !Bool -> SelectionStyle
highlightSelection :: SelectionStyle -> !Bool
rectangleSelection :: SelectionStyle -> !Bool
data AnyMode
AnyMode :: (Mode syntax) -> AnyMode

-- | A Mode customizes the Yi interface for editing a particular data
--   format. It specifies when the mode should be used and controls
--   file-specific syntax highlighting and command input, among other
--   things.
data Mode syntax
Mode :: Text -> (FilePath -> YiString -> Bool) -> ExtHL syntax -> (syntax -> BufferM ()) -> (KeymapSet -> KeymapSet) -> (syntax -> IndentBehaviour -> BufferM ()) -> (syntax -> Int -> BufferM ()) -> (syntax -> Action) -> IndentSettings -> Maybe (BufferM ()) -> (syntax -> Point -> Point -> Point -> [Stroke]) -> BufferM () -> ([Text] -> BufferM Text) -> BufferM () -> Mode syntax

-- | so this can be serialized, debugged.
modeName :: Mode syntax -> Text

-- | What type of files does this mode apply to?
modeApplies :: Mode syntax -> FilePath -> YiString -> Bool

-- | Syntax highlighter
modeHL :: Mode syntax -> ExtHL syntax

-- | Prettify current "paragraph"
modePrettify :: Mode syntax -> syntax -> BufferM ()

-- | Buffer-local keymap modification
modeKeymap :: Mode syntax -> KeymapSet -> KeymapSet

-- | emacs-style auto-indent line
modeIndent :: Mode syntax -> syntax -> IndentBehaviour -> BufferM ()

-- | adjust the indentation after modification
modeAdjustBlock :: Mode syntax -> syntax -> Int -> BufferM ()

-- | Follow a "link" in the file. (eg. go to location of error message)
modeFollow :: Mode syntax -> syntax -> Action
modeIndentSettings :: Mode syntax -> IndentSettings
modeToggleCommentSelection :: Mode syntax -> Maybe (BufferM ())

-- | Strokes that should be applied when displaying a syntax element should
--   this be an Action instead?
modeGetStrokes :: Mode syntax -> syntax -> Point -> Point -> Point -> [Stroke]

-- | An action that is to be executed when this mode is set
modeOnLoad :: Mode syntax -> BufferM ()

-- | buffer-local modeline formatting method
modeModeLine :: Mode syntax -> [Text] -> BufferM Text

-- | go to the point where the variable is declared
modeGotoDeclaration :: Mode syntax -> BufferM ()

-- | Used to specify the behaviour of the automatic indent command.
data IndentBehaviour

-- | Increase the indentation to the next higher indentation hint. If we
--   are currently at the highest level of indentation then cycle back to
--   the lowest.
IncreaseCycle :: IndentBehaviour

-- | Decrease the indentation to the next smaller indentation hint. If we
--   are currently at the smallest level then cycle back to the largest
DecreaseCycle :: IndentBehaviour

-- | Increase the indentation to the next higher hint if no such hint
--   exists do nothing.
IncreaseOnly :: IndentBehaviour

-- | Decrease the indentation to the next smaller indentation hint, if no
--   such hint exists do nothing.
DecreaseOnly :: IndentBehaviour
type Status = ([Text], StyleName)
type Statuses = DelayList Status

-- | The Editor state
data Editor
Editor :: !(NonEmpty BufferRef) -> !(Map BufferRef FBuffer) -> !Int -> !(PointedList Tab) -> !DynamicState -> !Statuses -> !Int -> !Killring -> !(Maybe SearchExp) -> !Direction -> ![Event] -> !(Map BufferRef (EditorM ())) -> Editor

-- | Stack of all the buffers. Invariant: first buffer is the current one.
bufferStack :: Editor -> !(NonEmpty BufferRef)
buffers :: Editor -> !(Map BufferRef FBuffer)

-- | Supply for buffer, window and tab ids.
refSupply :: Editor -> !Int

-- | current tab contains the visible windows pointed list.
tabs_ :: Editor -> !(PointedList Tab)

-- | dynamic components
dynamic :: Editor -> !DynamicState
statusLines :: Editor -> !Statuses
maxStatusHeight :: Editor -> !Int
killring :: Editor -> !Killring

-- | currently highlighted regex (also most recent regex for use in vim
--   bindings)
currentRegex :: Editor -> !(Maybe SearchExp)
searchDirection :: Editor -> !Direction

-- | Processed events that didn't yield any action yet.
pendingEvents :: Editor -> ![Event]

-- | Actions to be run when the buffer is closed; should be scrapped.
onCloseActions :: Editor -> !(Map BufferRef (EditorM ()))
newtype EditorM a
EditorM :: ReaderT Config (State Editor) a -> EditorM a
fromEditorM :: EditorM a -> ReaderT Config (State Editor) a
class (Monad m, MonadState Editor m) => MonadEditor m where withEditor f = do { cfg <- askCfg; getsAndModify (runEditor cfg f) } withEditor_ = withEditor . void
askCfg :: MonadEditor m => m Config
withEditor :: MonadEditor m => EditorM a -> m a
withEditor_ :: MonadEditor m => EditorM a -> m ()
runEditor :: Config -> EditorM a -> Editor -> (Editor, a)
data UIConfig
UIConfig :: Config -> Maybe String -> Maybe Int -> Maybe ScrollStyle -> Int -> Bool -> Bool -> Bool -> Bool -> CursorStyle -> Char -> Theme -> UIConfig
configVty :: UIConfig -> Config

-- | Font name, for the UI that support it.
configFontName :: UIConfig -> Maybe String

-- | Font size, for the UI that support it.
configFontSize :: UIConfig -> Maybe Int

-- | Style of scroll
configScrollStyle :: UIConfig -> Maybe ScrollStyle

-- | Amount to move the buffer when using the scroll wheel
configScrollWheelAmount :: UIConfig -> Int

-- | Should the scrollbar be shown on the left side?
configLeftSideScrollBar :: UIConfig -> Bool

-- | Hide scrollbar automatically if text fits on one page.
configAutoHideScrollBar :: UIConfig -> Bool

-- | Hide the tabbar automatically if only one tab is present
configAutoHideTabBar :: UIConfig -> Bool

-- | Wrap lines at the edge of the window if too long to display.
configLineWrap :: UIConfig -> Bool
configCursorStyle :: UIConfig -> CursorStyle

-- | The char with which to fill empty window space. Usually '~' for
--   vi-like editors, ' ' for everything else.
configWindowFill :: UIConfig -> Char

-- | UI colours
configTheme :: UIConfig -> Theme
type UIBoot = Config -> ([Event] -> IO ()) -> ([Action] -> IO ()) -> Editor -> IO (UI Editor)

-- | When should we use a "fat" cursor (i.e. 2 pixels wide, rather than 1)?
--   Fat cursors have only been implemented for the Pango frontend.
data CursorStyle
AlwaysFat :: CursorStyle
NeverFat :: CursorStyle
FatWhenFocused :: CursorStyle
FatWhenFocusedAndInserting :: CursorStyle

-- | Configuration record. All Yi hooks can be set here.
data Config
Config :: UIBoot -> UIConfig -> [Action] -> [Action] -> KeymapSet -> P Event Event -> [AnyMode] -> Bool -> RegionStyle -> Bool -> Bool -> [[Update] -> BufferM ()] -> [AnyLayoutManager] -> DynamicState -> Config

-- | UI to use.
startFrontEnd :: Config -> UIBoot

-- | UI-specific configuration.
configUI :: Config -> UIConfig

-- | Actions to run when the editor is started.
startActions :: Config -> [Action]

-- | Actions to run after startup (after startActions) or reload.
initialActions :: Config -> [Action]

-- | Default keymap to use.
defaultKm :: Config -> KeymapSet
configInputPreprocess :: Config -> P Event Event

-- | List modes by order of preference.
modeTable :: Config -> [AnyMode]

-- | Produce a .yi.dbg file with a lot of debug information.
debugMode :: Config -> Bool

-- | Set to <a>Exclusive</a> for an emacs-like behaviour.
configRegionStyle :: Config -> RegionStyle

-- | Set to <a>True</a> for an emacs-like behaviour, where all deleted text
--   is accumulated in a killring.
configKillringAccumulate :: Config -> Bool
configCheckExternalChangesObsessively :: Config -> Bool
bufferUpdateHandler :: Config -> [[Update] -> BufferM ()]

-- | List of layout managers for <tt>cycleLayoutManagersNext</tt>
layoutManagers :: Config -> [AnyLayoutManager]

-- | Custom configuration, containing the <a>YiConfigVariable</a>s.
--   Configure with <tt>configVariableA</tt>.
configVars :: Config -> DynamicState
data RegionStyle
LineWise :: RegionStyle
Inclusive :: RegionStyle
Exclusive :: RegionStyle
Block :: RegionStyle
instance Typeable IndentSettings
instance Typeable SelectionStyle
instance Typeable RegionStyle
instance Typeable Editor
instance Typeable EditorM
instance Typeable FBuffer
instance Typeable BufferM
instance Typeable Action
instance Typeable YiM
instance Typeable Yi
instance Typeable Attributes
instance Typeable AnyMode
instance Show IsRefreshNeeded
instance Eq IsRefreshNeeded
instance Eq IndentSettings
instance Show IndentSettings
instance Traversable MarkSet
instance Foldable MarkSet
instance Functor MarkSet
instance Show BufferId
instance Eq BufferId
instance Ord BufferId
instance Eq IndentBehaviour
instance Show IndentBehaviour
instance Eq RegionStyle
instance Show RegionStyle
instance Monad EditorM
instance Applicative EditorM
instance MonadState Editor EditorM
instance MonadReader Config EditorM
instance Functor EditorM
instance Monad BufferM
instance Functor BufferM
instance MonadWriter [Update] BufferM
instance MonadState FBuffer BufferM
instance MonadReader Window BufferM
instance Monad YiM
instance Applicative YiM
instance MonadReader Yi YiM
instance MonadBase IO YiM
instance Functor YiM
instance YiVariable RegionStyle
instance Default RegionStyle
instance Binary RegionStyle
instance MonadEditor EditorM
instance Binary SelectionStyle
instance Binary BufferId
instance Binary Attributes
instance Binary a => Binary (MarkSet a)
instance Eq FBuffer
instance Applicative BufferM
instance MonadEditor YiM
instance MonadState Editor YiM
instance Show Action
instance Eq Action


-- | Lenses for types exported in Yi.Config. This module serves as a
--   convenience module, for easy re-exporting.
module Yi.Config.Lens
startFrontEndA :: Lens' Config UIBoot
startActionsA :: Lens' Config [Action]
modeTableA :: Lens' Config [AnyMode]
layoutManagersA :: Lens' Config [AnyLayoutManager]
initialActionsA :: Lens' Config [Action]
defaultKmA :: Lens' Config KeymapSet
debugModeA :: Lens' Config Bool
configVarsA :: Lens' Config DynamicState
configUIA :: Lens' Config UIConfig
configRegionStyleA :: Lens' Config RegionStyle
configKillringAccumulateA :: Lens' Config Bool
configInputPreprocessA :: Lens' Config (P Event Event)
configCheckExternalChangesObsessivelyA :: Lens' Config Bool
bufferUpdateHandlerA :: Lens' Config [[Update] -> BufferM ()]
configWindowFillA :: Lens' UIConfig Char
configVtyA :: Lens' UIConfig Config
configThemeA :: Lens' UIConfig Theme
configScrollWheelAmountA :: Lens' UIConfig Int
configScrollStyleA :: Lens' UIConfig (Maybe ScrollStyle)
configLineWrapA :: Lens' UIConfig Bool
configLeftSideScrollBarA :: Lens' UIConfig Bool
configFontSizeA :: Lens' UIConfig (Maybe Int)
configFontNameA :: Lens' UIConfig (Maybe String)
configCursorStyleA :: Lens' UIConfig CursorStyle
configAutoHideTabBarA :: Lens' UIConfig Bool
configAutoHideScrollBarA :: Lens' UIConfig Bool
configVariable :: YiConfigVariable a => Lens Config Config a a

module Yi.Paths

-- | Get path to environment file that defines namespace used by Yi command
--   evaluator.
getEvaluatorContextFilename :: MonadBase IO m => m FilePath

-- | Get Yi master configuration script.
getConfigFilename :: MonadBase IO m => m FilePath
getConfigModules :: MonadBase IO m => m FilePath

-- | Get articles.db database of locations to visit (for Yi.IReader.)
getArticleDbFilename :: MonadBase IO m => m FilePath

-- | Get path to Yi history that stores state between runs.
getPersistentStateFilename :: MonadBase IO m => m FilePath
getConfigDir :: MonadBase IO m => m FilePath

-- | Given a path relative to application configuration directory, this
--   function finds a path to a given configuration file.
getConfigPath :: MonadBase IO m => FilePath -> m FilePath

-- | Given an action that retrieves config path, and a path relative to it,
--   this function joins the two together to create a config file path.
getCustomConfigPath :: MonadBase IO m => m FilePath -> FilePath -> m FilePath

-- | Given a path relative to application data directory, this function
--   finds a path to a given data file.
getDataPath :: MonadBase IO m => FilePath -> m FilePath


-- | The <tt>Buffer</tt> module defines monadic editing operations over
--   one-dimensional buffers, maintaining a current <i>point</i>.
module Yi.Buffer.Misc
data FBuffer
FBuffer :: !(Mode syntax) -> !(BufferImpl syntax) -> !Attributes -> FBuffer

-- | The BufferM monad writes the updates performed.
newtype BufferM a
BufferM :: RWS Window [Update] FBuffer a -> BufferM a
fromBufferM :: BufferM a -> RWS Window [Update] FBuffer a
type WinMarks = MarkSet Mark
data MarkSet a
MarkSet :: !a -> !a -> !a -> MarkSet a
fromMark :: MarkSet a -> !a
insMark :: MarkSet a -> !a
selMark :: MarkSet a -> !a
bkey :: FBuffer -> BufferRef
getMarks :: Window -> BufferM (Maybe WinMarks)

-- | Execute a <tt>BufferM</tt> value on a given buffer and window. The new
--   state of the buffer is returned alongside the result of the
--   computation.
runBuffer :: Window -> FBuffer -> BufferM a -> (a, FBuffer)
runBufferFull :: Window -> FBuffer -> BufferM a -> (a, [Update], FBuffer)

-- | Execute a <tt>BufferM</tt> value on a given buffer, using a dummy
--   window. The new state of the buffer is discarded.
runBufferDummyWindow :: FBuffer -> BufferM a -> a

-- | Top line of the screen
screenTopLn :: BufferM Int

-- | Middle line of the screen
screenMidLn :: BufferM Int

-- | Bottom line of the screen
screenBotLn :: BufferM Int

-- | Return the current line number
curLn :: BufferM Int

-- | Current column. Note that this is different from offset or number of
--   chars from sol. (This takes into account tabs, unicode chars, etc.)
curCol :: BufferM Int
colOf :: Point -> BufferM Int
lineOf :: Point -> BufferM Int
lineCountB :: BufferM Int

-- | Point of eof
sizeB :: BufferM Point

-- | Extract the current point
pointB :: BufferM Point
pointOfLineColB :: Int -> Int -> BufferM Point

-- | Returns start of line point for a given point <tt>p</tt>
solPointB :: Point -> BufferM Point

-- | Returns end of line for given point.
eolPointB :: Point -> BufferM Point

-- | Return line numbers of marks
markLines :: BufferM (MarkSet Int)

-- | Move point in buffer to the given index
moveTo :: Point -> BufferM ()
moveToColB :: Int -> BufferM ()
moveToLineColB :: Int -> Int -> BufferM ()

-- | Move point down by <tt>n</tt> lines. <tt>n</tt> can be negative.
--   Returns the actual difference in lines which we moved which may be
--   negative if the requested line difference is negative.
lineMoveRel :: Int -> BufferM Int

-- | Move point up one line
lineUp :: BufferM ()

-- | Move point down one line
lineDown :: BufferM ()

-- | Create buffer named <tt>nm</tt> with contents <tt>s</tt>
newB :: BufferRef -> BufferId -> YiString -> FBuffer
data MarkValue
MarkValue :: !Point -> !Direction -> MarkValue
markPoint :: MarkValue -> !Point
markGravity :: MarkValue -> !Direction
data Overlay

-- | Create an "overlay" for the style <tt>sty</tt> between points
--   <tt>s</tt> and <tt>e</tt>
mkOverlay :: YiString -> Region -> StyleName -> YiString -> Overlay

-- | Go to line number <tt>n</tt>. <tt>n</tt> is indexed from 1. Returns
--   the actual line we went to (which may be not be the requested line, if
--   it was out of range)
gotoLn :: Int -> BufferM Int

-- | Go to line indexed from current point Returns the actual moved
--   difference which of course may be negative if the requested difference
--   was negative.
gotoLnFrom :: Int -> BufferM Int

-- | Move point -1
leftB :: BufferM ()

-- | Move cursor +1
rightB :: BufferM ()

-- | Move point by the given number of characters. A negative offset moves
--   backwards a positive one forward.
moveN :: Int -> BufferM ()

-- | Move cursor -n
leftN :: Int -> BufferM ()

-- | Move cursor +n
rightN :: Int -> BufferM ()

-- | Insert the <a>YiString</a> at current point, extending size of buffer
insertN :: YiString -> BufferM ()

-- | Insert given <a>YiString</a> at specified point, extending size of the
--   buffer.
insertNAt :: YiString -> Point -> BufferM ()

-- | Insert the char at current point, extending size of buffer
--   
--   Implementation note: This just <a>insertB</a>s a <a>singleton</a>.
--   This seems sub-optimal because we should be able to do much better
--   without spewing chunks of size 1 everywhere. This approach is
--   necessary however so an <a>Update</a> can be recorded. A possible
--   improvement for space would be to have ‘yi-rope’ package optimise for
--   appends with length 1.
insertB :: Char -> BufferM ()

-- | Delete <tt>n</tt> characters forward from the current point
deleteN :: Int -> BufferM ()
nelemsB :: Int -> Point -> BufferM YiString

-- | Write an element into the buffer at the current point.
writeB :: Char -> BufferM ()

-- | Write the list into the buffer at current point.
writeN :: YiString -> BufferM ()

-- | Insert newline at current point.
newlineB :: BufferM ()

-- | <tt>deleteNAt n p</tt> deletes <tt>n</tt> characters forwards from
--   position <tt>p</tt>
deleteNAt :: Direction -> Int -> Point -> BufferM ()

-- | Read the character at the current point
readB :: BufferM Char

-- | Return the contents of the buffer.
elemsB :: BufferM YiString
undosA :: HasAttributes c_a1gYl => Lens' c_a1gYl URList
undoB :: BufferM ()
redoB :: BufferM ()
getMarkB :: Maybe String -> BufferM Mark
setMarkHereB :: BufferM Mark
setNamedMarkHereB :: String -> BufferM ()
mayGetMarkB :: String -> BufferM (Maybe Mark)
getMarkValueB :: Mark -> BufferM MarkValue
markPointA :: Mark -> Lens' FBuffer Point
modifyMarkB :: Mark -> (MarkValue -> MarkValue) -> BufferM ()
newMarkB :: MarkValue -> BufferM Mark
deleteMarkB :: Mark -> BufferM ()

-- | Whether the selection is highlighted
getVisibleSelection :: BufferM Bool

-- | Highlight the selection
setVisibleSelection :: Bool -> BufferM ()
isUnchangedBuffer :: FBuffer -> Bool

-- | Set the mode
setAnyMode :: AnyMode -> BufferM ()
setMode :: Mode syntax -> BufferM ()
setMode0 :: Mode syntax -> FBuffer -> FBuffer

-- | Modify the mode
modifyMode :: (forall syntax. Mode syntax -> Mode syntax) -> BufferM ()

-- | Return indices of strings in buffer matched by regex in the given
--   region.
regexRegionB :: SearchExp -> Region -> BufferM [Region]

-- | Return indices of next string in buffer matched by regex in the given
--   direction
regexB :: Direction -> SearchExp -> BufferM [Region]

-- | Read the character at the given index This is an unsafe operation:
--   character NUL is returned when out of bounds
readAtB :: Point -> BufferM Char

-- | Given a buffer, and some information update the modeline
--   
--   N.B. the contents of modelines should be specified by user, and not
--   hardcoded.
getModeLine :: [Text] -> BufferM Text

-- | Given a point, and the file size, gives us a percent string
getPercent :: Point -> Point -> Text
setInserting :: Bool -> BufferM ()
savingPrefCol :: BufferM a -> BufferM a
forgetPreferCol :: BufferM ()
movingToPrefCol :: BufferM a -> BufferM a

-- | Moves to a visual column within the current line as shown on the
--   editor (ie, moving within the current width of a single visual line)
movingToPrefVisCol :: BufferM a -> BufferM a
preferColA :: HasAttributes c_a1gYl => Lens' c_a1gYl (Maybe Int)

-- | Mark the current point in the undo list as a saved state.
markSavedB :: UTCTime -> BufferM ()

-- | Undo all updates that happened since last save, perform a given action
--   and redo all updates again. Given action must not modify undo history.
retroactivelyAtSavePointB :: BufferM a -> BufferM a

-- | Adds an "overlay" to the buffer
addOverlayB :: Overlay -> BufferM ()

-- | Remove an existing "overlay"
delOverlayB :: Overlay -> BufferM ()
delOverlaysOfOwnerB :: YiString -> BufferM ()
getOverlaysOfOwnerB :: YiString -> BufferM (Set Overlay)
isPointInsideOverlay :: Point -> Overlay -> Bool

-- | perform a <tt>BufferM a</tt>, and return to the current point. (by
--   using a mark)
savingExcursionB :: BufferM a -> BufferM a

-- | Perform an <tt>BufferM a</tt>, and return to the current point.
savingPointB :: BufferM a -> BufferM a

-- | Perform an <tt>BufferM a</tt>, and return to the current line and
--   column number. The difference between this and <a>savingPointB</a> is
--   that here we attempt to return to the specific line and column number,
--   rather than a specific number of characters from the beginning of the
--   buffer.
--   
--   In case the column is further away than EOL, the point is left at EOL:
--   <a>moveToLineColB</a> is used internally.
savingPositionB :: BufferM a -> BufferM a
pendingUpdatesA :: HasAttributes c_a1gYl => Lens' c_a1gYl [UIUpdate]
highlightSelectionA :: Lens' FBuffer Bool
rectangleSelectionA :: Lens' FBuffer Bool
readOnlyA :: HasAttributes c_a1gYl => Lens' c_a1gYl Bool
insertingA :: HasAttributes c_a1gYl => Lens' c_a1gYl Bool
pointFollowsWindowA :: HasAttributes c_a1gYl => Lens' c_a1gYl (WindowRef -> Bool)

-- | Revert all the pending updates; don't touch the point.
revertPendingUpdatesB :: BufferM ()
askWindow :: (Window -> a) -> BufferM a

-- | update the syntax information (clear the dirty "flag")
clearSyntax :: FBuffer -> FBuffer
focusSyntax :: Map WindowRef Region -> FBuffer -> FBuffer

-- | A Mode customizes the Yi interface for editing a particular data
--   format. It specifies when the mode should be used and controls
--   file-specific syntax highlighting and command input, among other
--   things.
data Mode syntax
Mode :: Text -> (FilePath -> YiString -> Bool) -> ExtHL syntax -> (syntax -> BufferM ()) -> (KeymapSet -> KeymapSet) -> (syntax -> IndentBehaviour -> BufferM ()) -> (syntax -> Int -> BufferM ()) -> (syntax -> Action) -> IndentSettings -> Maybe (BufferM ()) -> (syntax -> Point -> Point -> Point -> [Stroke]) -> BufferM () -> ([Text] -> BufferM Text) -> BufferM () -> Mode syntax

-- | so this can be serialized, debugged.
modeName :: Mode syntax -> Text

-- | What type of files does this mode apply to?
modeApplies :: Mode syntax -> FilePath -> YiString -> Bool

-- | Syntax highlighter
modeHL :: Mode syntax -> ExtHL syntax

-- | Prettify current "paragraph"
modePrettify :: Mode syntax -> syntax -> BufferM ()

-- | Buffer-local keymap modification
modeKeymap :: Mode syntax -> KeymapSet -> KeymapSet

-- | emacs-style auto-indent line
modeIndent :: Mode syntax -> syntax -> IndentBehaviour -> BufferM ()

-- | adjust the indentation after modification
modeAdjustBlock :: Mode syntax -> syntax -> Int -> BufferM ()

-- | Follow a "link" in the file. (eg. go to location of error message)
modeFollow :: Mode syntax -> syntax -> Action
modeIndentSettings :: Mode syntax -> IndentSettings
modeToggleCommentSelection :: Mode syntax -> Maybe (BufferM ())

-- | Strokes that should be applied when displaying a syntax element should
--   this be an Action instead?
modeGetStrokes :: Mode syntax -> syntax -> Point -> Point -> Point -> [Stroke]

-- | An action that is to be executed when this mode is set
modeOnLoad :: Mode syntax -> BufferM ()

-- | buffer-local modeline formatting method
modeModeLine :: Mode syntax -> [Text] -> BufferM Text

-- | go to the point where the variable is declared
modeGotoDeclaration :: Mode syntax -> BufferM ()
modeNameA :: Lens' (Mode syntax_a1adX) Text
modeAppliesA :: Lens' (Mode syntax_a1adX) (FilePath -> YiString -> Bool)
modeHLA :: Lens' (Mode syntax_a1adX) (ExtHL syntax_a1adX)
modePrettifyA :: Lens' (Mode syntax_a1adX) (syntax_a1adX -> BufferM ())
modeKeymapA :: Lens' (Mode syntax_a1adX) (KeymapSet -> KeymapSet)
modeIndentA :: Lens' (Mode syntax_a1adX) (syntax_a1adX -> IndentBehaviour -> BufferM ())
modeAdjustBlockA :: Lens' (Mode syntax_a1adX) (syntax_a1adX -> Int -> BufferM ())
modeFollowA :: Lens' (Mode syntax_a1adX) (syntax_a1adX -> Action)
modeIndentSettingsA :: Lens' (Mode syntax_a1adX) IndentSettings
modeToggleCommentSelectionA :: Lens' (Mode syntax_a1adX) (Maybe (BufferM ()))
modeGetStrokesA :: Lens' (Mode syntax_a1adX) (syntax_a1adX -> Point -> Point -> Point -> [Stroke])
modeOnLoadA :: Lens' (Mode syntax_a1adX) (BufferM ())
modeGotoDeclarationA :: Lens' (Mode syntax_a1adX) (BufferM ())
modeModeLineA :: Lens' (Mode syntax_a1adX) ([Text] -> BufferM Text)
data AnyMode
AnyMode :: (Mode syntax) -> AnyMode

-- | Used to specify the behaviour of the automatic indent command.
data IndentBehaviour

-- | Increase the indentation to the next higher indentation hint. If we
--   are currently at the highest level of indentation then cycle back to
--   the lowest.
IncreaseCycle :: IndentBehaviour

-- | Decrease the indentation to the next smaller indentation hint. If we
--   are currently at the smallest level then cycle back to the largest
DecreaseCycle :: IndentBehaviour

-- | Increase the indentation to the next higher hint if no such hint
--   exists do nothing.
IncreaseOnly :: IndentBehaviour

-- | Decrease the indentation to the next smaller indentation hint, if no
--   such hint exists do nothing.
DecreaseOnly :: IndentBehaviour

-- | Currently duplicates some of Vim's indent settings. Allowing a buffer
--   to specify settings that are more dynamic, perhaps via closures, could
--   be useful.
data IndentSettings
IndentSettings :: Bool -> Int -> Int -> IndentSettings

-- | Insert spaces instead of tabs as possible
expandTabs :: IndentSettings -> Bool

-- | Size of a Tab
tabSize :: IndentSettings -> Int

-- | Indent by so many columns
shiftWidth :: IndentSettings -> Int
expandTabsA :: Lens' IndentSettings Bool
tabSizeA :: Lens' IndentSettings Int
shiftWidthA :: Lens' IndentSettings Int

-- | Mode applies function that always returns True.
modeAlwaysApplies :: a -> b -> Bool

-- | Mode applies function that always returns False.
modeNeverApplies :: a -> b -> Bool
emptyMode :: Mode syntax
withModeB :: (forall syntax. Mode syntax -> BufferM a) -> BufferM a
withMode0 :: (forall syntax. Mode syntax -> a) -> FBuffer -> a
onMode :: (forall syntax. Mode syntax -> Mode syntax) -> AnyMode -> AnyMode
withSyntaxB :: (forall syntax. Mode syntax -> syntax -> a) -> BufferM a
withSyntaxB' :: (forall syntax. Mode syntax -> syntax -> BufferM a) -> BufferM a
keymapProcessA :: HasAttributes c_a1gYl => Lens' c_a1gYl KeymapProcess
strokesRangesB :: Maybe SearchExp -> Region -> BufferM [[Stroke]]
streamB :: Direction -> Point -> BufferM YiString
indexedStreamB :: Direction -> Point -> BufferM [(Point, Char)]
askMarks :: BufferM WinMarks
pointAt :: BufferM a -> BufferM Point
data SearchExp :: *
lastActiveWindowA :: HasAttributes c_a1gYl => Lens' c_a1gYl Window

-- | Access to a value into the extensible state, keyed by its type. This
--   allows you to save inside a <a>BufferM</a> monad, ie:
--   
--   <pre>
--   putBufferDyn updatedvalue
--   </pre>
putBufferDyn :: (YiVariable a, MonadState FBuffer m, Functor m) => a -> m ()

-- | Access to a value into the extensible state, keyed by its type. This
--   allows you to retrieve inside a <a>BufferM</a> monad, ie:
--   
--   <pre>
--   value &lt;- getBufferDyn
--   </pre>
getBufferDyn :: (YiVariable a, MonadState FBuffer m, Functor m) => m a

-- | Gets a short identifier of a buffer. If we're given a <a>MemBuffer</a>
--   then just wraps the buffer name like so: <tt>*name*</tt>. If we're
--   given a <a>FileBuffer</a>, it drops the the number of characters
--   specified.
--   
--   <pre>
--   &gt;&gt;&gt; shortIdentString 3 (MemBuffer "hello")
--   "*hello*"
--   
--   &gt;&gt;&gt; shortIdentString 3 (FileBuffer "hello")
--   "lo"
--   </pre>
shortIdentString :: Int -> FBuffer -> Text

-- | Gets the buffer's identifier string, emphasising the <a>MemBuffer</a>:
--   
--   <pre>
--   &gt;&gt;&gt; identString (MemBuffer "hello")
--   "*hello*"
--   
--   &gt;&gt;&gt; identString (FileBuffer "hello")
--   "hello"
--   </pre>
identString :: FBuffer -> Text
miniIdentString :: FBuffer -> Text
identA :: HasAttributes c_a1gYl => Lens' c_a1gYl BufferId
directoryContentA :: HasAttributes c_a1gYl => Lens' c_a1gYl Bool
data BufferId
MemBuffer :: Text -> BufferId
FileBuffer :: FilePath -> BufferId
file :: FBuffer -> Maybe FilePath
lastSyncTimeA :: HasAttributes c_a1gYl => Lens' c_a1gYl UTCTime
replaceCharB :: Char -> BufferM ()
replaceCharWithBelowB :: BufferM ()
replaceCharWithAboveB :: BufferM ()
insertCharWithBelowB :: BufferM ()
insertCharWithAboveB :: BufferM ()
pointAfterCursorB :: Point -> BufferM Point

-- | What would be the point after doing the given action? The argument
--   must not modify the buffer.
destinationOfMoveB :: BufferM a -> BufferM Point
withEveryLineB :: BufferM () -> BufferM ()
startUpdateTransactionB :: BufferM ()
commitUpdateTransactionB :: BufferM ()
applyUpdate :: Update -> BufferM ()

-- | Returns the contents of the buffer between the two points.
--   
--   If the <tt>startPoint &gt;= endPoint</tt>, empty string is returned.
--   If the points are out of bounds, as much of the content as possible is
--   taken: you're not guaranteed to get <tt>endPoint - startPoint</tt>
--   characters.
betweenB :: Point -> Point -> BufferM YiString

-- | Decreases the font size in the buffer by specified number. What this
--   number actually means depends on the front-end.
decreaseFontSize :: Int -> BufferM ()

-- | Increases the font size in the buffer by specified number. What this
--   number actually means depends on the front-end.
increaseFontSize :: Int -> BufferM ()

-- | Gives the <a>IndentSettings</a> for the current buffer.
indentSettingsB :: BufferM IndentSettings
fontsizeVariationA :: HasAttributes c_a1gYl => Lens' c_a1gYl Int
encodingConverterNameA :: HasAttributes c_a1gYl => Lens' c_a1gYl (Maybe ConverterName)
instance Binary (Mode syntax)
instance Binary FBuffer
instance Show FBuffer
instance HasAttributes FBuffer
instance HasAttributes Attributes


-- | This module defines buffer operation on regions
module Yi.Buffer.Region

-- | Swap the content of two Regions
swapRegionsB :: Region -> Region -> BufferM ()

-- | Delete an arbitrary part of the buffer
deleteRegionB :: Region -> BufferM ()

-- | Replace a region with a given rope.
replaceRegionB :: Region -> YiString -> BufferM ()
readRegionB :: Region -> BufferM YiString

-- | Map the given function over the characters in the region.
mapRegionB :: Region -> (Char -> Char) -> BufferM ()

-- | Modifies the given region according to the given string transformation
--   function
modifyRegionB :: (YiString -> YiString) -> Region -> BufferM ()
winRegionB :: BufferM Region

-- | Extend the right bound of a region to include it.
inclusiveRegionB :: Region -> BufferM Region

-- | See a region as a block/rectangular region, since regions are
--   represented by two point, this returns a list of small regions form
--   this block region.
blockifyRegion :: Region -> BufferM [Region]

-- | Joins lines in the region with a single space, skipping any empty
--   lines.
joinLinesB :: Region -> BufferM ()

-- | Concatenates lines in the region preserving the trailing newline if
--   any.
concatLinesB :: Region -> BufferM ()


-- | Working with blocks (units) of text.
module Yi.Buffer.TextUnit

-- | Designate a given "unit" of text.
data TextUnit

-- | a single character
Character :: TextUnit

-- | a line of text (between newlines)
Line :: TextUnit

-- | a "vertical" line of text (area of text between two characters at the
--   same column number)
VLine :: TextUnit

-- | the whole document
Document :: TextUnit
GenUnit :: TextUnit -> (Direction -> BufferM Bool) -> TextUnit
genEnclosingUnit :: TextUnit -> TextUnit
genUnitBoundary :: TextUnit -> Direction -> BufferM Bool

-- | Turns a unit into its "negative" by inverting the boundaries. For
--   example, <tt>outsideUnit unitViWord</tt> will be the unit of spaces
--   between words. For units without boundaries (<a>Character</a>,
--   <a>Document</a>, ...), this is the identity function.
outsideUnit :: TextUnit -> TextUnit

-- | Unit that have its left and right boundaries at the left boundary of
--   the argument unit.
leftBoundaryUnit :: TextUnit -> TextUnit

-- | a word as in use in Emacs (fundamental mode)
unitWord :: TextUnit
unitViWord :: TextUnit
unitViWORD :: TextUnit
unitViWordAnyBnd :: TextUnit
unitViWORDAnyBnd :: TextUnit
unitViWordOnLine :: TextUnit
unitViWORDOnLine :: TextUnit

-- | delimited on the left and right by given characters, boolean argument
--   tells if whether those are included.
unitDelimited :: Char -> Char -> Bool -> TextUnit
unitSentence :: TextUnit

-- | Paragraph to implement emacs-like forward-paragraph/backward-paragraph
unitEmacsParagraph :: TextUnit

-- | Paragraph that begins and ends in the paragraph, not the empty lines
--   surrounding it.
unitParagraph :: TextUnit

-- | Separator characters (space, tab, unicode separators). Most of the
--   units above attempt to identify "words" with various punctuation and
--   symbols included or excluded. This set of units is a simple inverse:
--   it is true for "whitespace" or "separators" and false for anything
--   that is not (letters, numbers, symbols, punctuation, whatever).
isAnySep :: Char -> Bool

-- | unitSep is true for any kind of whitespace/separator
unitSep :: TextUnit

-- | unitSepThisLine is true for any kind of whitespace/separator on this
--   line only
unitSepThisLine :: TextUnit
isWordChar :: Char -> Bool

-- | Move to the next unit boundary
moveB :: TextUnit -> Direction -> BufferM ()

-- | As <a>moveB</a>, unless the point is at a unit boundary
maybeMoveB :: TextUnit -> Direction -> BufferM ()

-- | Transforms the region given by <a>TextUnit</a> in the <a>Direction</a>
--   with user-supplied function.
transformB :: (YiString -> YiString) -> TextUnit -> Direction -> BufferM ()
transposeB :: TextUnit -> Direction -> BufferM ()

-- | Region of the whole textunit where the current point is.
regionOfB :: TextUnit -> BufferM Region

-- | Non empty region of the whole textunit where the current point is.
regionOfNonEmptyB :: TextUnit -> BufferM Region

-- | Region between the point and the next boundary. The region is empty if
--   the point is at the boundary.
regionOfPartB :: TextUnit -> Direction -> BufferM Region
regionWithTwoMovesB :: BufferM a -> BufferM b -> BufferM Region

-- | Non empty region between the point and the next boundary, In fact the
--   region can be empty if we are at the end of file.
regionOfPartNonEmptyB :: TextUnit -> Direction -> BufferM Region

-- | Non empty region at given point and the next boundary,
regionOfPartNonEmptyAtB :: TextUnit -> Direction -> Point -> BufferM Region
readPrevUnitB :: TextUnit -> BufferM YiString
readUnitB :: TextUnit -> BufferM YiString

-- | Repeat an action until the condition is fulfilled or the cursor stops
--   moving. The Action may be performed zero times.
untilB :: BufferM Bool -> BufferM a -> BufferM [a]
doUntilB_ :: BufferM Bool -> BufferM a -> BufferM ()
untilB_ :: BufferM Bool -> BufferM a -> BufferM ()
whileB :: BufferM Bool -> BufferM a -> BufferM [a]

-- | Do an action if the current buffer character passes the predicate
doIfCharB :: (Char -> Bool) -> BufferM a -> BufferM ()
atBoundaryB :: TextUnit -> Direction -> BufferM Bool
numberOfB :: TextUnit -> TextUnit -> BufferM Int

-- | Delete between point and next unit boundary, return the deleted
--   region.
deleteB :: TextUnit -> Direction -> BufferM ()

-- | Generic maybe move operation. As genMoveB, but don't move if we are at
--   boundary already.
genMaybeMoveB :: TextUnit -> (Direction, BoundarySide) -> Direction -> BufferM ()

-- | Generic move operation Warning: moving To the (OutsideBound, Backward)
--   bound of Document is impossible (offset -1!) <tt>genMoveB u b d</tt>:
--   move in direction d until encountering boundary b or unit u. See
--   <a>genAtBoundaryB</a> for boundary explanation.
genMoveB :: TextUnit -> (Direction, BoundarySide) -> Direction -> BufferM ()

-- | Boundary side
data BoundarySide
InsideBound :: BoundarySide
OutsideBound :: BoundarySide

-- | <tt>genAtBoundaryB u d s</tt> returns whether the point is at a given
--   boundary <tt>(d,s)</tt> . Boundary <tt>(d,s)</tt> , taking Word as
--   example, means: Word ^^ ^^ 12 34 1: (Backward,OutsideBound) 2:
--   (Backward,InsideBound) 3: (Forward,InsideBound) 4:
--   (Forward,OutsideBound)
--   
--   rules: genAtBoundaryB u Backward InsideBound = atBoundaryB u Backward
--   genAtBoundaryB u Forward OutsideBound = atBoundaryB u Forward
genAtBoundaryB :: TextUnit -> Direction -> BoundarySide -> BufferM Bool
checkPeekB :: Int -> [Char -> Bool] -> Direction -> BufferM Bool
halfUnit :: Direction -> TextUnit -> TextUnit
deleteUnitB :: TextUnit -> Direction -> BufferM ()
instance Typeable TextUnit
instance Eq BoundarySide


-- | A normalized API to many buffer operations.
module Yi.Buffer.Normal

-- | Designate a given "unit" of text.
data TextUnit

-- | a single character
Character :: TextUnit

-- | a line of text (between newlines)
Line :: TextUnit

-- | a "vertical" line of text (area of text between two characters at the
--   same column number)
VLine :: TextUnit

-- | the whole document
Document :: TextUnit
GenUnit :: TextUnit -> (Direction -> BufferM Bool) -> TextUnit
genEnclosingUnit :: TextUnit -> TextUnit
genUnitBoundary :: TextUnit -> Direction -> BufferM Bool

-- | Separator characters (space, tab, unicode separators). Most of the
--   units above attempt to identify "words" with various punctuation and
--   symbols included or excluded. This set of units is a simple inverse:
--   it is true for "whitespace" or "separators" and false for anything
--   that is not (letters, numbers, symbols, punctuation, whatever).
isAnySep :: Char -> Bool
isWordChar :: Char -> Bool

-- | Unit that have its left and right boundaries at the left boundary of
--   the argument unit.
leftBoundaryUnit :: TextUnit -> TextUnit

-- | Turns a unit into its "negative" by inverting the boundaries. For
--   example, <tt>outsideUnit unitViWord</tt> will be the unit of spaces
--   between words. For units without boundaries (<a>Character</a>,
--   <a>Document</a>, ...), this is the identity function.
outsideUnit :: TextUnit -> TextUnit

-- | delimited on the left and right by given characters, boolean argument
--   tells if whether those are included.
unitDelimited :: Char -> Char -> Bool -> TextUnit

-- | Paragraph to implement emacs-like forward-paragraph/backward-paragraph
unitEmacsParagraph :: TextUnit

-- | Paragraph that begins and ends in the paragraph, not the empty lines
--   surrounding it.
unitParagraph :: TextUnit
unitSentence :: TextUnit

-- | unitSep is true for any kind of whitespace/separator
unitSep :: TextUnit

-- | unitSepThisLine is true for any kind of whitespace/separator on this
--   line only
unitSepThisLine :: TextUnit
unitViWORD :: TextUnit
unitViWORDAnyBnd :: TextUnit
unitViWORDOnLine :: TextUnit
unitViWord :: TextUnit
unitViWordAnyBnd :: TextUnit
unitViWordOnLine :: TextUnit

-- | a word as in use in Emacs (fundamental mode)
unitWord :: TextUnit
atBoundaryB :: TextUnit -> Direction -> BufferM Bool

-- | Delete between point and next unit boundary, return the deleted
--   region.
deleteB :: TextUnit -> Direction -> BufferM ()

-- | Do an action if the current buffer character passes the predicate
doIfCharB :: (Char -> Bool) -> BufferM a -> BufferM ()
doUntilB_ :: BufferM Bool -> BufferM a -> BufferM ()

-- | Generic maybe move operation. As genMoveB, but don't move if we are at
--   boundary already.
genMaybeMoveB :: TextUnit -> (Direction, BoundarySide) -> Direction -> BufferM ()

-- | Generic move operation Warning: moving To the (OutsideBound, Backward)
--   bound of Document is impossible (offset -1!) <tt>genMoveB u b d</tt>:
--   move in direction d until encountering boundary b or unit u. See
--   <a>genAtBoundaryB</a> for boundary explanation.
genMoveB :: TextUnit -> (Direction, BoundarySide) -> Direction -> BufferM ()

-- | As <a>moveB</a>, unless the point is at a unit boundary
maybeMoveB :: TextUnit -> Direction -> BufferM ()

-- | Move to the next unit boundary
moveB :: TextUnit -> Direction -> BufferM ()
numberOfB :: TextUnit -> TextUnit -> BufferM Int
readPrevUnitB :: TextUnit -> BufferM YiString
readUnitB :: TextUnit -> BufferM YiString

-- | Region of the whole textunit where the current point is.
regionOfB :: TextUnit -> BufferM Region

-- | Non empty region of the whole textunit where the current point is.
regionOfNonEmptyB :: TextUnit -> BufferM Region

-- | Region between the point and the next boundary. The region is empty if
--   the point is at the boundary.
regionOfPartB :: TextUnit -> Direction -> BufferM Region

-- | Non empty region at given point and the next boundary,
regionOfPartNonEmptyAtB :: TextUnit -> Direction -> Point -> BufferM Region

-- | Non empty region between the point and the next boundary, In fact the
--   region can be empty if we are at the end of file.
regionOfPartNonEmptyB :: TextUnit -> Direction -> BufferM Region

-- | Transforms the region given by <a>TextUnit</a> in the <a>Direction</a>
--   with user-supplied function.
transformB :: (YiString -> YiString) -> TextUnit -> Direction -> BufferM ()
transposeB :: TextUnit -> Direction -> BufferM ()

-- | Repeat an action until the condition is fulfilled or the cursor stops
--   moving. The Action may be performed zero times.
untilB :: BufferM Bool -> BufferM a -> BufferM [a]
untilB_ :: BufferM Bool -> BufferM a -> BufferM ()
whileB :: BufferM Bool -> BufferM a -> BufferM [a]

-- | Boundary side
data BoundarySide
InsideBound :: BoundarySide
OutsideBound :: BoundarySide
checkPeekB :: Int -> [Char -> Bool] -> Direction -> BufferM Bool

-- | <tt>genAtBoundaryB u d s</tt> returns whether the point is at a given
--   boundary <tt>(d,s)</tt> . Boundary <tt>(d,s)</tt> , taking Word as
--   example, means: Word ^^ ^^ 12 34 1: (Backward,OutsideBound) 2:
--   (Backward,InsideBound) 3: (Forward,InsideBound) 4:
--   (Forward,OutsideBound)
--   
--   rules: genAtBoundaryB u Backward InsideBound = atBoundaryB u Backward
--   genAtBoundaryB u Forward OutsideBound = atBoundaryB u Forward
genAtBoundaryB :: TextUnit -> Direction -> BoundarySide -> BufferM Bool
data RegionStyle
LineWise :: RegionStyle
Inclusive :: RegionStyle
Exclusive :: RegionStyle
Block :: RegionStyle
convertRegionToStyleB :: Region -> RegionStyle -> BufferM Region

-- | Extend the given region to boundaries of the text unit. For instance
--   one can extend the selection to complete lines, or paragraphs.
extendRegionToBoundaries :: TextUnit -> BoundarySide -> BoundarySide -> Region -> BufferM Region
getRegionStyle :: BufferM RegionStyle
mkRegionOfStyleB :: Point -> Point -> RegionStyle -> BufferM Region
putRegionStyle :: RegionStyle -> BufferM ()
unitWiseRegion :: TextUnit -> Region -> BufferM Region


-- | High level operations on buffers.
module Yi.Buffer.HighLevel

-- | True if point at end of file
atEof :: BufferM Bool

-- | Return true if the current point is the end of a line
atEol :: BufferM Bool

-- | True if point at the last line
atLastLine :: BufferM Bool

-- | Return true if the current point is the start of a line
atSol :: BufferM Bool

-- | True if point at start of file
atSof :: BufferM Bool

-- | Delete one character backward
bdeleteB :: BufferM ()

-- | Delete backward to the sof or the new line character
bdeleteLineB :: BufferM ()

-- | Delete backward whitespace or non-whitespace depending on the
--   character before point.
bkillWordB :: BufferM ()

-- | Move cursor to end of buffer
botB :: BufferM ()

-- | File info, size in chars, line no, col num, char num, percent
bufInfoB :: BufferM BufferFileInfo
data BufferFileInfo
BufferFileInfo :: FilePath -> Int -> Int -> Int -> Point -> Text -> Bool -> BufferFileInfo
bufInfoFileName :: BufferFileInfo -> FilePath
bufInfoSize :: BufferFileInfo -> Int
bufInfoLineNo :: BufferFileInfo -> Int
bufInfoColNo :: BufferFileInfo -> Int
bufInfoCharNo :: BufferFileInfo -> Point
bufInfoPercent :: BufferFileInfo -> Text
bufInfoModified :: BufferFileInfo -> Bool

-- | capitalise the first letter of this word
capitaliseWordB :: BufferM ()
deleteBlankLinesB :: BufferM ()

-- | emacs' <tt>delete-horizontal-space</tt> with the optional argument.
deleteHorizontalSpaceB :: Maybe Int -> BufferM ()
deleteRegionWithStyleB :: Region -> RegionStyle -> BufferM Point

-- | Delete to the end of line, excluding it.
deleteToEol :: BufferM ()

-- | Delete trailing whitespace from all lines. Uses <a>savingPositionB</a>
--   to get back to where it was.
deleteTrailingSpaceB :: BufferM ()

-- | Move to <tt>n</tt> lines down from top of screen
downFromTosB :: Int -> BufferM ()

-- | Scroll down 1 screen
downScreenB :: BufferM ()
downScreensB :: Int -> BufferM ()

-- | Exchange point &amp; mark.
exchangePointAndMarkB :: BufferM ()
fillParagraph :: BufferM ()
findMatchingPairB :: BufferM ()

-- | Move to first non-space character in this line
firstNonSpaceB :: BufferM ()
flipRectangleB :: Point -> Point -> BufferM (Point, Point)
getBookmarkB :: String -> BufferM Mark

-- | Get the current line and column number
getLineAndCol :: BufferM (Int, Int)
getLineAndColOfPoint :: Point -> BufferM (Int, Int)

-- | The same as <a>getMaybeNextLineB</a> but avoids the use of the
--   <a>Maybe</a> type in the return by returning the empty string if there
--   is no next line.
getNextLineB :: Direction -> BufferM YiString

-- | Returns the closest line to the current line which is non-blank, in
--   the given direction. Returns the empty string if there is no such line
--   (for example if we are on the top line already).
getNextNonBlankLineB :: Direction -> BufferM YiString

-- | Return the region between point and mark
getRawestSelectRegionB :: BufferM Region

-- | Get the current buffer selection mark
getSelectionMarkPointB :: BufferM Point

-- | Get the current region boundaries. Extended to the current selection
--   unit.
getSelectRegionB :: BufferM Region
gotoCharacterB :: Char -> Direction -> RegionStyle -> Bool -> BufferM ()
hasWhiteSpaceBefore :: BufferM Bool

-- | Increase (or decrease if negative) next number on line by n.
incrementNextNumberByB :: Int -> BufferM ()
insertRopeWithStyleB :: YiString -> RegionStyle -> BufferM ()

-- | Note: Returns False if line doesn't have any characters besides a
--   newline
isCurrentLineAllWhiteSpaceB :: BufferM Bool

-- | True if current line consists of just a newline (no whitespace)
isCurrentLineEmptyB :: BufferM Bool

-- | Is character under cursor a number.
isNumberB :: BufferM Bool

-- | Delete forward whitespace or non-whitespace depending on the character
--   under point.
killWordB :: BufferM ()

-- | Move to the last non-space character in this line
lastNonSpaceB :: BufferM ()
leftEdgesOfRegionB :: RegionStyle -> Region -> BufferM [Point]

-- | Move left if on eol, but not on blank line
leftOnEol :: BufferM ()

-- | Move point down by <tt>n</tt> lines If line extends past width of
--   window, count moving a single line as moving width points to the
--   right.
lineMoveVisRel :: Int -> BufferM ()

-- | Prefix each line in the selection using the given string.
linePrefixSelectionB :: YiString -> BufferM ()

-- | Get a (lazy) stream of lines in the buffer, starting at the
--   <i>next</i> line in the given direction.
lineStreamB :: Direction -> BufferM [YiString]

-- | lowerise word under the cursor
lowercaseWordB :: BufferM ()

-- | Move to middle line in screen
middleB :: BufferM ()
modifyExtendedSelectionB :: TextUnit -> (YiString -> YiString) -> BufferM ()

-- | Go to the first non space character in the line; if already there,
--   then go to the beginning of the line.
moveNonspaceOrSol :: BufferM ()
movePercentageFileB :: Int -> BufferM ()

-- | Move point between the middle, top and bottom of the screen If the
--   point stays at the middle, it'll be gone to the top else if the point
--   stays at the top, it'll be gone to the bottom else it'll be gone to
--   the middle
moveToMTB :: BufferM ()

-- | Move point to end of line
moveToEol :: BufferM ()

-- | Move point to start of line
moveToSol :: BufferM ()

-- | Move <tt>x</tt> chars forward, or to the eol, whichever is less
moveXorEol :: Int -> BufferM ()

-- | Move <tt>x</tt> chars back, or to the sol, whichever is less
moveXorSol :: Int -> BufferM ()

-- | Move to the character before the next occurence of <tt>c</tt>
nextCExc :: Char -> BufferM ()

-- | Move to the next occurence of <tt>c</tt>
nextCInc :: Char -> BufferM ()
nextCInLineExc :: Char -> BufferM ()
nextCInLineInc :: Char -> BufferM ()

-- | Move down next <tt>n</tt> paragraphs
nextNParagraphs :: Int -> BufferM ()

-- | Move to first char of next word forwards
nextWordB :: BufferM ()

-- | Move to the character after the previous occurence of <tt>c</tt>
prevCExc :: Char -> BufferM ()

-- | Move to the previous occurence of <tt>c</tt>
prevCInc :: Char -> BufferM ()
prevCInLineExc :: Char -> BufferM ()
prevCInLineInc :: Char -> BufferM ()

-- | Move up prev <tt>n</tt> paragraphs
prevNParagraphs :: Int -> BufferM ()

-- | Move to first char of next word backwards
prevWordB :: BufferM ()

-- | Reads in word at point.
readCurrentWordB :: BufferM YiString

-- | Read the line the point is on
readLnB :: BufferM YiString

-- | Reads in word before point.
readPrevWordB :: BufferM YiString
readRegionRopeWithStyleB :: Region -> RegionStyle -> BufferM YiString

-- | Replace the contents of the buffer with some string
replaceBufferContent :: YiString -> BufferM ()

-- | Helper function: revert the buffer contents to its on-disk version
revertB :: YiString -> Maybe ConverterName -> UTCTime -> BufferM ()
rightEdgesOfRegionB :: RegionStyle -> Region -> BufferM [Point]

-- | Scroll by n lines.
scrollB :: Int -> BufferM ()

-- | Move cursor to the bottom of the screen
scrollCursorToBottomB :: BufferM ()

-- | Move cursor to the top of the screen
scrollCursorToTopB :: BufferM ()

-- | Scroll by n screens (negative for up)
scrollScreensB :: Int -> BufferM ()

-- | Move to middle line in screen
scrollToCursorB :: BufferM ()
scrollToLineAboveWindowB :: BufferM ()
scrollToLineBelowWindowB :: BufferM ()

-- | Marks
--   
--   Set the current buffer selection mark
setSelectionMarkPointB :: Point -> BufferM ()

-- | Select the given region: set the selection mark at the
--   <a>regionStart</a> and the current point at the <a>regionEnd</a>.
setSelectRegionB :: Region -> BufferM ()
shapeOfBlockRegionB :: Region -> BufferM (Point, [Int])

-- | Sort the lines of the region.
sortLines :: BufferM ()
sortLinesWithRegion :: Region -> BufferM ()

-- | Move the point to inside the viewable region
snapInsB :: BufferM ()

-- | Move the visible region to include the point
snapScreenB :: Maybe ScrollStyle -> BufferM Bool
splitBlockRegionToContiguousSubRegionsB :: Region -> BufferM [Region]

-- | Transpose two characters, (the Emacs C-t action)
swapB :: BufferM ()
switchCaseChar :: Char -> Char

-- | Used by isNumber to test if current character under cursor is a
--   number.
test3CharB :: BufferM Bool

-- | Characters ['a'..'f'] are part of a hex number only if preceded by 0x.
--   Test if the current occurence of ['a'..'f'] is part of a hex number.
testHexB :: BufferM Bool

-- | Just like <a>toggleCommentSelectionB</a> but automatically inserts a
--   whitespace suffix to the inserted comment string. In fact:
toggleCommentB :: YiString -> BufferM ()

-- | Move cursor to origin
topB :: BufferM ()

-- | Uncomments the selection using the given line comment starting string.
--   This only works for the comments which begin at the start of the line.
unLineCommentSelectionB :: YiString -> YiString -> BufferM ()

-- | Move to <tt>n</tt> lines up from the bottom of the screen
upFromBosB :: Int -> BufferM ()

-- | capitalise the word under the cursor
uppercaseWordB :: BufferM ()

-- | Scroll up 1 screen
upScreenB :: BufferM ()
upScreensB :: Int -> BufferM ()

-- | Same as scrollB, but also moves the cursor
vimScrollB :: Int -> BufferM ()

-- | Same as scrollByB, but also moves the cursor
vimScrollByB :: (Int -> Int) -> Int -> BufferM ()

-- | Implements the same logic that emacs' `mark-word` does. Checks the
--   mark point and moves it forth (or backward) for one word.
markWord :: BufferM ()
instance Show RelPosition


-- | Handles indentation in the keymaps. Includes:
--   
--   <ul>
--   <li>(TODO) Auto-indentation to the previous lines indentation</li>
--   <li>Tab-expansion</li>
--   <li>Shifting of the indentation for a region of text</li>
--   </ul>
module Yi.Buffer.Indent

-- | A specialisation of <a>autoIndentHelperB</a>. This is the most basic
--   and the user is encouraged to specialise <a>autoIndentHelperB</a> on
--   their own.
autoIndentB :: IndentBehaviour -> BufferM ()

-- | Cycles through the indentation hints. It does this without requiring
--   to set/get any state. We just look at the current indentation of the
--   current line and moving to the largest indent that is
cycleIndentsB :: IndentBehaviour -> [Int] -> BufferM ()

-- | Indent as much as the next line
indentAsNextB :: BufferM ()

-- | Indent as much as the previous line
indentAsPreviousB :: BufferM ()
indentAsTheMostIndentedNeighborLineB :: BufferM ()

-- | Returns the indentation of a given string. Note that this depends on
--   the current indentation settings.
indentOfB :: YiString -> BufferM Int

-- | Return the number of spaces at the beginning of the line, up to the
--   point.
indentOfCurrentPosB :: BufferM Int

-- | Gives the <a>IndentSettings</a> for the current buffer.
indentSettingsB :: BufferM IndentSettings

-- | Indents the current line to the given indentation level. In addition
--   moves the point according to where it was on the line originally. If
--   we were somewhere within the indentation (ie at the start of the line
--   or on an empty line) then we want to just go to the end of the (new)
--   indentation. However if we are currently pointing somewhere within the
--   text of the line then we wish to remain pointing to the same
--   character.
indentToB :: Int -> BufferM ()

-- | Modifies current line indent measured in visible spaces. Respects
--   indent settings. Calling this with value (+ 4) will turn "t" into "tt"
--   if shiftwidth is 4 and into "t " if shiftwidth is 8 If current line is
--   empty nothing happens.
modifyIndentB :: (Int -> Int) -> BufferM ()

-- | Insert a newline at point and indent the new line as the previous one.
newlineAndIndentB :: BufferM ()

-- | Increases the indentation on the region by the given amount of
--   shiftWidth
shiftIndentOfRegionB :: Int -> Region -> BufferM ()

-- | Return either a t or the number of spaces specified by tabSize in the
--   IndentSettings. Note that if you actually want to insert a tab
--   character (for example when editing makefiles) then you should use:
--   <tt>insertB '\t'</tt>.
tabB :: BufferM String


-- | Module exposing common user settings. Users most likely want to be
--   starting with <a>Yi.Config.Default</a>.
module Yi.Config

-- | Configuration record. All Yi hooks can be set here.
data Config
Config :: UIBoot -> UIConfig -> [Action] -> [Action] -> KeymapSet -> P Event Event -> [AnyMode] -> Bool -> RegionStyle -> Bool -> Bool -> [[Update] -> BufferM ()] -> [AnyLayoutManager] -> DynamicState -> Config

-- | UI to use.
startFrontEnd :: Config -> UIBoot

-- | UI-specific configuration.
configUI :: Config -> UIConfig

-- | Actions to run when the editor is started.
startActions :: Config -> [Action]

-- | Actions to run after startup (after startActions) or reload.
initialActions :: Config -> [Action]

-- | Default keymap to use.
defaultKm :: Config -> KeymapSet
configInputPreprocess :: Config -> P Event Event

-- | List modes by order of preference.
modeTable :: Config -> [AnyMode]

-- | Produce a .yi.dbg file with a lot of debug information.
debugMode :: Config -> Bool

-- | Set to <a>Exclusive</a> for an emacs-like behaviour.
configRegionStyle :: Config -> RegionStyle

-- | Set to <a>True</a> for an emacs-like behaviour, where all deleted text
--   is accumulated in a killring.
configKillringAccumulate :: Config -> Bool
configCheckExternalChangesObsessively :: Config -> Bool
bufferUpdateHandler :: Config -> [[Update] -> BufferM ()]

-- | List of layout managers for <tt>cycleLayoutManagersNext</tt>
layoutManagers :: Config -> [AnyLayoutManager]

-- | Custom configuration, containing the <a>YiConfigVariable</a>s.
--   Configure with <tt>configVariableA</tt>.
configVars :: Config -> DynamicState
data UIConfig
UIConfig :: Config -> Maybe String -> Maybe Int -> Maybe ScrollStyle -> Int -> Bool -> Bool -> Bool -> Bool -> CursorStyle -> Char -> Theme -> UIConfig
configVty :: UIConfig -> Config

-- | Font name, for the UI that support it.
configFontName :: UIConfig -> Maybe String

-- | Font size, for the UI that support it.
configFontSize :: UIConfig -> Maybe Int

-- | Style of scroll
configScrollStyle :: UIConfig -> Maybe ScrollStyle

-- | Amount to move the buffer when using the scroll wheel
configScrollWheelAmount :: UIConfig -> Int

-- | Should the scrollbar be shown on the left side?
configLeftSideScrollBar :: UIConfig -> Bool

-- | Hide scrollbar automatically if text fits on one page.
configAutoHideScrollBar :: UIConfig -> Bool

-- | Hide the tabbar automatically if only one tab is present
configAutoHideTabBar :: UIConfig -> Bool

-- | Wrap lines at the edge of the window if too long to display.
configLineWrap :: UIConfig -> Bool
configCursorStyle :: UIConfig -> CursorStyle

-- | The char with which to fill empty window space. Usually '~' for
--   vi-like editors, ' ' for everything else.
configWindowFill :: UIConfig -> Char

-- | UI colours
configTheme :: UIConfig -> Theme
type UIBoot = Config -> ([Event] -> IO ()) -> ([Action] -> IO ()) -> Editor -> IO (UI Editor)

-- | When should we use a "fat" cursor (i.e. 2 pixels wide, rather than 1)?
--   Fat cursors have only been implemented for the Pango frontend.
data CursorStyle
AlwaysFat :: CursorStyle
NeverFat :: CursorStyle
FatWhenFocused :: CursorStyle
FatWhenFocusedAndInserting :: CursorStyle
configStyle :: UIConfig -> UIStyle
configFundamentalMode :: Config -> AnyMode
configTopLevelKeymap :: Config -> Keymap

module Yi.UI.Batch

-- | Initialise the ui
start :: UIBoot


-- | exports from <a>Yi.Config.Simple</a> which are useful to "core yi"
--   rather than just config files.
module Yi.Config.Simple.Types

-- | The configuration monad. Run it with <tt>configMain</tt>.
newtype ConfigM a
ConfigM :: StateT Config IO a -> ConfigM a
runConfigM :: ConfigM a -> StateT Config IO a

-- | Fields that can be modified with all lens machinery.
type Field a = Lens' Config a

-- | Accessor for any <a>YiConfigVariable</a>, to be used by modules
--   defining <a>YiConfigVariable</a>s. Such modules should provide a
--   custom-named field. For instance, take the following hypothetical
--   <a>YiConfigVariable</a>:
--   
--   @newtype UserName = UserName { unUserName :: String }
--   deriving(Typeable, Binary, Default) instance YiConfigVariable UserName
--   
--   $(nameDeriveAccessors ''UserName (n -&gt; Just (n ++ "A")))
--   
--   userName :: <a>Field</a> <a>String</a> userName = unUserNameA <a>.</a>
--   <a>customVariable</a>@
--   
--   Here, the hypothetical library would provide the field
--   <tt>userName</tt> to be used in preference to <tt>customVariable</tt>.
customVariable :: YiConfigVariable a => Field a
instance Monad ConfigM
instance Functor ConfigM
instance Applicative ConfigM
instance MonadState Config ConfigM
instance MonadBase IO ConfigM


-- | The <tt>Buffer</tt> module defines monadic editing operations over
--   one-dimensional buffers, maintaining a current <i>point</i>.
--   
--   This module acts as a facade for the Buffer.* modules.
module Yi.Buffer
data UIUpdate
TextUpdate :: !Update -> UIUpdate
StyleUpdate :: !Point -> !Size -> UIUpdate

-- | Mutation actions (also used the undo or redo list)
--   
--   For the undo<i>redo, we use the </i>partial checkpoint/ (Berlage,
--   pg16) strategy to store just the components of the state that change.
--   
--   Note that the update direction is only a hint for moving the cursor
--   (mainly for undo purposes); the insertions and deletions are always
--   applied Forward.
--   
--   Note that keeping the text does not cost much: we keep the updates in
--   the undo list; if it's a <a>Delete</a> it means we have just inserted
--   the text in the buffer, so the update shares the data with the buffer.
--   If it's an <a>Insert</a> we have to keep the data any way.
data Update
Insert :: !Point -> !Direction -> !YiString -> Update
updatePoint :: Update -> !Point
updateDirection :: Update -> !Direction
_insertUpdateString :: Update -> !YiString
Delete :: !Point -> !Direction -> !YiString -> Update
updatePoint :: Update -> !Point
updateDirection :: Update -> !Direction
_deleteUpdateString :: Update -> !YiString
updateIsDelete :: Update -> Bool
markGravityAA :: Lens' MarkValue Direction
markPointAA :: Lens' MarkValue Point


-- | The top level editor state, and operations on it. This is inside an
--   internal module for easy re-export with Yi.Types bits.
module Yi.Editor

-- | The Editor state
data Editor
Editor :: !(NonEmpty BufferRef) -> !(Map BufferRef FBuffer) -> !Int -> !(PointedList Tab) -> !DynamicState -> !Statuses -> !Int -> !Killring -> !(Maybe SearchExp) -> !Direction -> ![Event] -> !(Map BufferRef (EditorM ())) -> Editor

-- | Stack of all the buffers. Invariant: first buffer is the current one.
bufferStack :: Editor -> !(NonEmpty BufferRef)
buffers :: Editor -> !(Map BufferRef FBuffer)

-- | Supply for buffer, window and tab ids.
refSupply :: Editor -> !Int

-- | current tab contains the visible windows pointed list.
tabs_ :: Editor -> !(PointedList Tab)

-- | dynamic components
dynamic :: Editor -> !DynamicState
statusLines :: Editor -> !Statuses
maxStatusHeight :: Editor -> !Int
killring :: Editor -> !Killring

-- | currently highlighted regex (also most recent regex for use in vim
--   bindings)
currentRegex :: Editor -> !(Maybe SearchExp)
searchDirection :: Editor -> !Direction

-- | Processed events that didn't yield any action yet.
pendingEvents :: Editor -> ![Event]

-- | Actions to be run when the buffer is closed; should be scrapped.
onCloseActions :: Editor -> !(Map BufferRef (EditorM ()))
data EditorM a
class (Monad m, MonadState Editor m) => MonadEditor m where withEditor f = do { cfg <- askCfg; getsAndModify (runEditor cfg f) } withEditor_ = withEditor . void
askCfg :: MonadEditor m => m Config
withEditor :: MonadEditor m => EditorM a -> m a
withEditor_ :: MonadEditor m => EditorM a -> m ()
runEditor :: Config -> EditorM a -> Editor -> (Editor, a)

-- | Shows the current key bindings in a new window
acceptedInputsOtherWindow :: EditorM ()
addJumpAtE :: Point -> EditorM ()
addJumpHereE :: EditorM ()
alternateBufferE :: Int -> EditorM ()
askConfigVariableA :: (YiConfigVariable b, MonadEditor m) => m b

-- | Return the buffers we have, <i>in no particular order</i>
bufferSet :: Editor -> [FBuffer]
buffersA :: Lens' Editor (Map BufferRef FBuffer)

-- | Close current buffer and window, unless it's the last one.
closeBufferAndWindowE :: EditorM ()

-- | Close a buffer. Note: close the current buffer if the empty string is
--   given
closeBufferE :: Text -> EditorM ()

-- | Make the current window the only window on the screen
closeOtherE :: EditorM ()

-- | Clear the status line
clrStatus :: EditorM ()

-- | Return a prefix that can be removed from all buffer paths while
--   keeping them unique.
commonNamePrefix :: Editor -> [FilePath]

-- | Return the current buffer
currentBuffer :: Editor -> BufferRef
currentRegexA :: Lens' Editor (Maybe SearchExp)
currentWindowA :: Lens' Editor Window

-- | Delete a buffer (and release resources associated with it).
deleteBuffer :: MonadEditor m => BufferRef -> m ()

-- | Deletes the current tab. If there is only one tab open then error out.
--   When the last tab is focused, move focus to the left, otherwise move
--   focus to the right.
deleteTabE :: EditorM ()

-- | The initial state
emptyEditor :: Editor
findBuffer :: MonadEditor m => BufferRef -> m (Maybe FBuffer)

-- | Find buffer with this key
findBufferWith :: BufferRef -> Editor -> FBuffer

-- | Find buffers with this name
findBufferWithName :: Text -> Editor -> [BufferRef]
findWindowWith :: WindowRef -> Editor -> Window

-- | bring the editor focus the window with the given key.
--   
--   Fails if no window with the given key is found.
focusWindowE :: WindowRef -> EditorM ()
getBufferStack :: MonadEditor m => m (NonEmpty FBuffer)

-- | Find buffer with given name. Fail if not found.
getBufferWithName :: MonadEditor m => Text -> m BufferRef
getBufferWithNameOrCurrent :: MonadEditor m => Text -> m BufferRef

-- | Dynamically-extensible state components.
--   
--   These hooks are used by keymaps to store values that result from
--   Actions (i.e. that restult from IO), as opposed to the pure values
--   they generate themselves, and can be stored internally.
--   
--   The <a>dynamic</a> field is a type-indexed map.
--   
--   Retrieve a value from the extensible state
getEditorDyn :: (MonadEditor m, YiVariable a, Default a, Functor m) => m a

-- | Return the contents of the yank register
getRegE :: EditorM YiString
jumpBackE :: EditorM ()
jumpForwardE :: EditorM ()
killringA :: Lens' Editor Killring

-- | Next variant of the current layout manager, as given by
--   <a>nextVariant</a>
layoutManagerNextVariantE :: EditorM ()

-- | Previous variant of the current layout manager, as given by
--   <a>previousVariant</a>
layoutManagerPreviousVariantE :: EditorM ()

-- | Cycle to the next layout manager, or the first one if the current one
--   is nonstandard.
layoutManagersNextE :: EditorM ()

-- | Cycle to the previous layout manager, or the first one if the current
--   one is nonstandard.
layoutManagersPreviousE :: EditorM ()
maxStatusHeightA :: Lens' Editor Int

-- | Moves the focused tab to the given index, or to the end if the index
--   is not specified.
moveTabE :: Maybe Int -> EditorM ()

-- | Swap focused window with the next one
moveWinNextE :: EditorM ()

-- | Swap focused window with the previous one
moveWinPrevE :: EditorM ()

-- | Like fnewE, create a new buffer filled with the String <tt>s</tt>,
--   Switch the current window to this buffer. Doesn't associate any file
--   with the buffer (unlike fnewE) and so is good for popup internal
--   buffers (like scratch)
newBufferE :: BufferId -> YiString -> EditorM BufferRef

-- | Like <a>newBufferE</a> but defaults to empty contents.
newEmptyBufferE :: BufferId -> EditorM BufferRef

-- | Creates a new tab containing a window that views the current buffer.
newTabE :: EditorM ()

-- | Creates an in-memory buffer with a unique name.
newTempBufferE :: EditorM BufferRef

-- | Create a new window onto the given buffer.
newWindowE :: Bool -> BufferRef -> EditorM Window

-- | Moves to the next tab in the round robin set of tabs
nextTabE :: EditorM ()

-- | Rotate focus to the next window
nextWinE :: EditorM ()
onCloseActionsA :: Lens' Editor (Map BufferRef (EditorM ()))
pendingEventsA :: Lens' Editor [Event]

-- | Rotate focus to the previous window
prevWinE :: EditorM ()

-- | Moves to the previous tab in the round robin set of tabs
previousTabE :: EditorM ()

-- | Prints a message with <a>defaultStyle</a>.
printMsg :: MonadEditor m => Text -> m ()

-- | Prints a all given messages with <a>defaultStyle</a>.
printMsgs :: MonadEditor m => [Text] -> m ()
printStatus :: MonadEditor m => Status -> m ()

-- | Moves the focused window to the first window, and moves all other
--   windows down the stack.
pushWinToFirstE :: EditorM ()

-- | Insert a value into the extensible state, keyed by its type
putEditorDyn :: (MonadEditor m, YiVariable a, Functor m) => a -> m ()
searchDirectionA :: Lens' Editor Direction

-- | Sets the given divider position on the current tab
setDividerPosE :: DividerRef -> DividerPosition -> EditorM ()

-- | Put string into yank register
setRegE :: YiString -> EditorM ()

-- | Set the "background" status line
setStatus :: MonadEditor m => Status -> m ()

-- | Switch focus to some other window. If none is available, create one.
shiftOtherWindow :: MonadEditor m => m ()

-- | Split the current window, opening a second window onto current buffer.
--   TODO: unfold newWindowE here?
splitE :: EditorM ()
statusLine :: Editor -> [Text]
statusLineInfo :: Editor -> Status
statusLinesA :: Lens' Editor Statuses

-- | Create and fill a new buffer, using contents of string. | Does not
--   focus the window, or make it the current window. | Call newWindowE or
--   switchToBufferE to take care of that.
stringToNewBuffer :: MonadEditor m => BufferId -> YiString -> m BufferRef

-- | Swaps the focused window with the first window. Useful for layouts
--   such as <tt>HPairOneStack</tt>, for which the first window is the
--   largest.
swapWinWithFirstE :: EditorM ()

-- | Attach the specified buffer to the current window
switchToBufferE :: BufferRef -> EditorM ()

-- | Switch to the buffer specified as parameter. If the buffer name is
--   empty, switch to the next buffer.
switchToBufferWithNameE :: Text -> EditorM ()
tabsA :: Lens' Editor (PointedList Tab)

-- | Close the current window. If there is only one tab open and the tab
--   contains only one window then do nothing.
tryCloseE :: EditorM ()
windows :: Editor -> PointedList Window
windowsA :: Lens' Editor (PointedList Window)

-- | Return the windows that are currently open on the buffer whose key is
--   given
windowsOnBufferE :: BufferRef -> EditorM [Window]

-- | Perform action with current window's buffer
withCurrentBuffer :: MonadEditor m => BufferM a -> m a
withEveryBuffer :: MonadEditor m => BufferM a -> m [a]

-- | Perform action with any given buffer, using the last window that was
--   used for that buffer.
withGivenBuffer :: MonadEditor m => BufferRef -> BufferM a -> m a

-- | Perform action with any given buffer
withGivenBufferAndWindow :: MonadEditor m => Window -> BufferRef -> BufferM a -> m a

-- | Execute the argument in the context of an other window. Create one if
--   necessary. The current window is re-focused after the argument has
--   completed.
withOtherWindow :: MonadEditor m => m a -> m a
withWindowE :: Window -> BufferM a -> EditorM a
instance Binary Editor


-- | Collection of functions for completion and matching.
module Yi.Completion

-- | Complete a string given a user input string, a matching function and a
--   list of possibilites. Matching function should return the part of the
--   string that matches the user string.
completeInList :: Text -> (Text -> Maybe Text) -> [Text] -> EditorM Text
completeInList' :: Text -> (Text -> Maybe Text) -> [Text] -> EditorM Text

-- | Same as <a>completeInList</a>, but maps <tt>showFunction</tt> on
--   possible matches when printing
completeInListCustomShow :: (Text -> Text) -> Text -> (Text -> Maybe Text) -> [Text] -> EditorM Text

-- | Return the longest common prefix of a set of lists.
--   
--   <pre>
--   P(xs) === all (isPrefixOf (commonPrefix xs)) xs
--   length s &gt; length (commonPrefix xs) --&gt; not (all (isPrefixOf s) xs)
--   </pre>
commonPrefix :: Eq a => [[a]] -> [a]

-- | Prefix matching function, for use with <a>completeInList</a>
prefixMatch :: Text -> Text -> Maybe Text

-- | Infix matching function, for use with <a>completeInList</a>
infixMatch :: Text -> Text -> Maybe Text

-- | Example: "abc" matches "a1b2c"
subsequenceMatch :: String -> String -> Bool

-- | TODO: this is a terrible function, isn't this just case-insensitive
--   infix? – Fūzetsu
containsMatch' :: Bool -> Text -> Text -> Maybe Text
containsMatch :: Text -> Text -> Maybe Text
containsMatchCaseInsensitive :: Text -> Text -> Maybe Text

-- | Like usual <a>isPrefixOf</a> but user can specify case sensitivity.
--   See <a>toCaseFold</a> for exotic unicode gotchas.
mkIsPrefixOf :: Bool -> Text -> Text -> Bool


-- | A module for CTags integration. Note that this reads the ‘tags’ file
--   produced by <tt>hasktags</tt>, not the ‘TAGS’ file which uses a
--   different format (etags).
module Yi.Tag

-- | Find the location of a tag using the tag table. Returns a full path
--   and line number
lookupTag :: Tag -> TagTable -> [(FilePath, Int)]

-- | Read in a tag file from the system
importTagTable :: FilePath -> IO TagTable

-- | Gives all the possible expanded tags that could match a given
--   <tt>prefix</tt>
hintTags :: TagTable -> Text -> [Text]

-- | Extends the string to the longest certain length
completeTag :: TagTable -> Text -> Text
newtype Tag
Tag :: Text -> Tag
_unTag :: Tag -> Text
unTag' :: Tag -> Text
data TagTable
TagTable :: FilePath -> FilePath -> Map Tag [(FilePath, Int)] -> Trie -> TagTable

-- | local name of the tag file TODO: reload if this file is changed
tagFileName :: TagTable -> FilePath

-- | path to the tag file directory tags are relative to this path
tagBaseDir :: TagTable -> FilePath

-- | map from tags to files
tagFileMap :: TagTable -> Map Tag [(FilePath, Int)]

-- | trie to speed up tag hinting
tagTrie :: TagTable -> Trie

-- | Get the currently registered tag table
getTags :: EditorM (Maybe TagTable)

-- | Set a new TagTable
setTags :: TagTable -> EditorM ()

-- | Reset the TagTable
resetTags :: EditorM ()
tagsFileList :: Field [FilePath]
instance Typeable TagTable
instance Typeable Tags
instance Show Tag
instance Eq Tag
instance Ord Tag
instance Generic TagTable
instance Generic Tags
instance Datatype D1TagTable
instance Constructor C1_0TagTable
instance Selector S1_0_0TagTable
instance Selector S1_0_1TagTable
instance Selector S1_0_2TagTable
instance Selector S1_0_3TagTable
instance Datatype D1Tags
instance Constructor C1_0Tags
instance Binary TagsFileList
instance Binary TagTable
instance Binary Tags
instance Binary Tag
instance YiVariable Tags
instance Default Tags
instance Typeable TagsFileList
instance Generic TagsFileList
instance Datatype D1TagsFileList
instance Constructor C1_0TagsFileList
instance Selector S1_0_0TagsFileList
instance YiConfigVariable TagsFileList
instance Default TagsFileList


-- | Internal use for Yi.Search.
module Yi.Search.Internal

-- | Put regex into regex <tt>register</tt>
setRegexE :: SearchExp -> EditorM ()

-- | Clear the regex <tt>register</tt>
resetRegexE :: EditorM ()

-- | Return contents of regex register
getRegexE :: EditorM (Maybe SearchExp)


-- | <a>Keymap</a>, <a>YiM</a> and <a>Action</a>s.
module Yi.Keymap
data Action
YiA :: (YiM a) -> Action
EditorA :: (EditorM a) -> Action
BufferA :: (BufferM a) -> Action
emptyAction :: Action
type Interact ev a = I ev Action a
type KeymapM a = Interact Event a
type Keymap = KeymapM ()
type KeymapEndo = Keymap -> Keymap
type KeymapProcess = P Event Action
data KeymapSet
KeymapSet :: Keymap -> Keymap -> KeymapSet

-- | Content of the top-level loop.
topKeymap :: KeymapSet -> Keymap

-- | For insertion-only modes
insertKeymap :: KeymapSet -> Keymap
topKeymapA :: Lens' KeymapSet Keymap
insertKeymapA :: Lens' KeymapSet Keymap
extractTopKeymap :: KeymapSet -> Keymap
modelessKeymapSet :: Keymap -> KeymapSet

-- | The type of user-bindable functions TODO: doc how these are actually
--   user-bindable are they?
newtype YiM a
YiM :: ReaderT Yi IO a -> YiM a
runYiM :: YiM a -> ReaderT Yi IO a
withUI :: (UI Editor -> IO a) -> YiM a
unsafeWithEditor :: Config -> MVar YiVar -> EditorM a -> IO a
readEditor :: MonadEditor m => (Editor -> a) -> m a
catchDynE :: Exception exception => YiM a -> (exception -> YiM a) -> YiM a
catchJustE :: Exception e => (e -> Maybe b) -> YiM a -> (b -> YiM a) -> YiM a
handleJustE :: Exception e => (e -> Maybe b) -> (b -> YiM a) -> YiM a -> YiM a
class YiAction a x | a -> x
makeAction :: (YiAction a x, Show x) => a -> Action
data Yi
Yi :: UI Editor -> ([Event] -> IO ()) -> (IsRefreshNeeded -> [Action] -> IO ()) -> Config -> MVar YiVar -> Yi
yiUi :: Yi -> UI Editor

-- | input stream
yiInput :: Yi -> [Event] -> IO ()

-- | output stream
yiOutput :: Yi -> IsRefreshNeeded -> [Action] -> IO ()
yiConfig :: Yi -> Config

-- | The only mutable state in the program
yiVar :: Yi -> MVar YiVar
data IsRefreshNeeded
MustRefresh :: IsRefreshNeeded
NoNeedToRefresh :: IsRefreshNeeded
data YiVar
YiVar :: !Editor -> !SubprocessId -> !(Map SubprocessId SubprocessInfo) -> YiVar
yiEditor :: YiVar -> !Editor
yiSubprocessIdSupply :: YiVar -> !SubprocessId
yiSubprocesses :: YiVar -> !(Map SubprocessId SubprocessInfo)

-- | <tt>write a</tt> returns a keymap that just outputs the action
--   <tt>a</tt>.
write :: (MonadInteract m Action ev, YiAction a x, Show x) => a -> m ()

-- | <tt>withModeY f</tt> runs <tt>f</tt> on the current buffer's mode. As
--   this runs in the YiM monad, we're able to do more than with just
--   <tt>withModeB</tt> such as prompt the user for something before
--   running the action.
withModeY :: (forall syntax. Mode syntax -> YiM ()) -> YiM ()
yiSubprocessesA :: Lens' YiVar (Map SubprocessId SubprocessInfo)
yiEditorA :: Lens' YiVar Editor
yiSubprocessIdSupplyA :: Lens' YiVar SubprocessId
yiConfigA :: Lens' Yi Config
yiInputA :: Lens' Yi ([Event] -> IO ())
yiOutputA :: Lens' Yi (IsRefreshNeeded -> [Action] -> IO ())
yiUiA :: Lens' Yi (UI Editor)
yiVarA :: Lens' Yi (MVar YiVar)
instance YiAction Action ()
instance YiAction (BufferM x) x
instance YiAction (EditorM x) x
instance YiAction (YiM x) x
instance YiAction (IO x) x


-- | Combinators for building keymaps.
module Yi.Keymap.Keys
printableChar :: MonadInteract m w Event => m Char

-- | Parse any character that can be inserted in the text.
textChar :: KeymapM Char
charOf :: MonadInteract m w Event => (Event -> Event) -> Char -> Char -> m Char
shift :: Event -> Event
meta :: Event -> Event
ctrl :: Event -> Event
super :: Event -> Event
hyper :: Event -> Event

-- | Convert a special key into an event
spec :: Key -> Event
char :: Char -> Event

-- | <pre>
--   p &gt;&gt;! act = p &gt;&gt; 'write' act
--   </pre>
(>>!) :: (MonadInteract m Action Event, YiAction a x, Show x) => m b -> a -> m ()

-- | <pre>
--   p &gt;&gt;=! act = p &gt;&gt;= 'write' . act
--   </pre>
(>>=!) :: (MonadInteract m Action Event, YiAction a x, Show x) => m b -> (b -> a) -> m ()

-- | <pre>
--   ev ?&gt;&gt; proc = <a>event</a> ev &gt;&gt; proc
--   </pre>
(?>>) :: MonadInteract m action Event => Event -> m a -> m a

-- | <pre>
--   ev ?&gt;&gt;! act = <a>event</a> ev &gt;&gt; <a>write</a> act
--   </pre>
(?>>!) :: (MonadInteract m Action Event, YiAction a x, Show x) => Event -> a -> m ()

-- | <pre>
--   ev ?*&gt;&gt; proc = <a>events</a> ev &gt;&gt; proc
--   </pre>
(?*>>) :: MonadInteract m action Event => [Event] -> m a -> m a

-- | <pre>
--   ev ?*&gt;&gt;! act = <a>events</a> ev &gt;&gt; <a>write</a> act
--   </pre>
(?*>>!) :: (MonadInteract m Action Event, YiAction a x, Show x) => [Event] -> a -> m ()
ctrlCh :: Char -> Event
metaCh :: Char -> Event
hyperCh :: Char -> Event

-- | <tt>optMod f ev</tt> produces a <a>MonadInteract</a> that consumes
--   <tt>ev</tt> or <tt>f ev</tt>
optMod :: MonadInteract m w Event => (Event -> Event) -> Event -> m Event
pString :: MonadInteract m w Event => String -> m [Event]


-- | Internal use for Yi.Boot
module Yi.Boot.Internal

-- | "reloads" the configuration
--   
--   Serializes the editor state and relaunches Yi using the serialized
--   state. The launch of Yi will result in recompilation of the user's
--   custom Yi. This, in effect, "reloads" the configuration.
reload :: YiM ()


-- | This module defines a list type and operations on it; it further
--   provides functions which write in and out the list. The goal is to
--   make it easy for the user to store a large number of text buffers and
--   cycle among them, making edits as she goes. The idea is inspired by
--   "incremental reading", see
--   <a>http://en.wikipedia.org/wiki/Incremental_reading</a>.
module Yi.IReader

-- | TODO: Why <a>ByteString</a>?
type Article = ByteString
newtype ArticleDB
ADB :: Seq Article -> ArticleDB
unADB :: ArticleDB -> Seq Article

-- | Take an <a>ArticleDB</a>, and return the first <a>Article</a> and an
--   ArticleDB - *without* that article.
split :: ArticleDB -> (Article, ArticleDB)

-- | Get the first article in the list. We use the list to express relative
--   priority; the first is the most, the last least. We then just cycle
--   through - every article gets equal time.
getLatestArticle :: ArticleDB -> Article

-- | We remove the old first article, and we stick it on the end of the
--   list using the presumably modified version.
removeSetLast :: ArticleDB -> Article -> ArticleDB
shift :: Int -> ArticleDB -> ArticleDB

-- | Insert a new article with top priority (that is, at the front of the
--   list).
insertArticle :: ArticleDB -> Article -> ArticleDB

-- | Serialize given <a>ArticleDB</a> out.
writeDB :: ArticleDB -> YiM ()

-- | Read in database from <a>getArticleDbFilename</a> and then parse it
--   into an <a>ArticleDB</a>.
readDB :: YiM ArticleDB

-- | Returns the database as it exists on the disk, and the current Yi
--   buffer contents. Note that the Default typeclass gives us an empty
--   Seq. So first we try the buffer state in the hope we can avoid a very
--   expensive read from disk, and if we find nothing (that is, if we get
--   an empty Seq), only then do we call <a>readDB</a>.
oldDbNewArticle :: YiM (ArticleDB, Article)

-- | Given an <a>ArticleDB</a>, dump the scheduled article into the buffer
--   (replacing previous contents).
setDisplayedArticle :: ArticleDB -> YiM ()

-- | Go to next one. This ignores the buffer, but it doesn't remove
--   anything from the database. However, the ordering does change.
nextArticle :: YiM ()

-- | Delete current article (the article as in the database), and go to
--   next one.
deleteAndNextArticle :: YiM ()

-- | The main action. We fetch the old database, we fetch the modified
--   article from the buffer, then we call the function
--   <tt>updateSetLast</tt> which removes the first article and pushes our
--   modified article to the end of the list.
saveAndNextArticle :: Int -> YiM ()

-- | Assume the buffer is an entirely new article just imported this
--   second, and save it. We don't want to use <tt>updateSetLast</tt> since
--   that will erase an article.
saveAsNewArticle :: YiM ()
instance Typeable ArticleDB
instance Binary ArticleDB
instance YiVariable ArticleDB
instance Default ArticleDB


-- | This module provides assistance in implementing "hooks" in Yi. This
--   module provides no major new functionality -- only assistance in using
--   <a>YiConfigVariable</a>s more easily to implement hooks.
--   
--   We consider a simple example. Suppose we have a function
--   
--   <pre>
--   promptForFile :: Maybe FilePath -&gt; YiM FilePath
--   </pre>
--   
--   which prompts the user to select a file from their file system,
--   starting with the provided directory (if actually provided). Since
--   this is a frequent task in Yi, it is important for it to be as
--   user-friendly as possible. If opinions vary on the meaning of
--   "user-friendly", then we would really like to provide multiple
--   implementations of <tt>promptForFile</tt>, and allow users to select
--   which implementation to use in their config files.
--   
--   A way to achieve this is using hooks, as follows:
--   
--   <pre>
--   -- create a new type
--   newtype FilePrompter = FilePrompter
--     { runFilePrompter :: Maybe FilePath -&gt; YiM FilePath }
--     deriving (Typeable)
--   $(nameDeriveAccessors ''FilePrompter (n -&gt; Just (n ++ "A")))
--   
--   -- give some implementations
--   filePrompter1, filePrompter2, filePrompter3 :: FilePrompter
--   ...
--   
--   -- declare FilePrompter as a YiConfigVariable (so it can go in the Config)
--   instance YiConfigVariable FilePrompter
--   
--   -- specify the default FilePrompter
--   instance Default FilePrompter where
--      def = filePrompter1
--   
--   -- replace the old promptForFile function with a shim
--   promptForFile :: Maybe FilePath -&gt; YiM FilePath
--   promptForFile = runHook runFilePrompter
--   
--   -- provide a custom-named Field for Yi.Config.Simple (not
--   -- strictly necessary, but user-friendly)
--   filePrompter :: Field FilePrompter
--   filePrompter = customVariable
--   </pre>
--   
--   The user can write
--   
--   <pre>
--   ...
--      filePrompter %= filePrompter2
--   ...
--   </pre>
--   
--   in their config file, and calls to <tt>promptForFile</tt> will now use
--   the different prompter. Library code which called
--   <tt>promptForFile</tt> does not need to be changed, but it gets the
--   new <tt>filePrompter2</tt> behaviour automatically.
--   
--   See <a>Yi.Eval</a> for a real example of hooks.
module Yi.Hooks

-- | Looks up the configured value for the hook, and runs it. The argument
--   to <a>runHook</a> will typically be a record accessor. See
--   <a>HookType</a> for the valid hook types.
runHook :: (HookType ty, YiConfigVariable var) => (var -> ty) -> ty

-- | The class of "valid hooks". This class is exported abstractly, but the
--   instances can be phrased quite simply: the functions (of arbitrarily
--   many arguments, including zero) which run in either the <a>EditorM</a>
--   or <a>YiM</a> monads.
--   
--   A typical example would be something like
--   
--   <tt>Int -&gt; String -&gt; <a>EditorM</a> String</tt>.
class HookType ty

-- | Accessor for any <a>YiConfigVariable</a>, to be used by modules
--   defining <a>YiConfigVariable</a>s. Such modules should provide a
--   custom-named field. For instance, take the following hypothetical
--   <a>YiConfigVariable</a>:
--   
--   @newtype UserName = UserName { unUserName :: String }
--   deriving(Typeable, Binary, Default) instance YiConfigVariable UserName
--   
--   $(nameDeriveAccessors ''UserName (n -&gt; Just (n ++ "A")))
--   
--   userName :: <a>Field</a> <a>String</a> userName = unUserNameA <a>.</a>
--   <a>customVariable</a>@
--   
--   Here, the hypothetical library would provide the field
--   <tt>userName</tt> to be used in preference to <tt>customVariable</tt>.
customVariable :: YiConfigVariable a => Field a

-- | Fields that can be modified with all lens machinery.
type Field a = Lens' Config a
instance HookType b => HookType (a -> b)
instance HookType (YiM a)
instance HookType (EditorM a)


-- | ‘Command history’ implementation.
module Yi.History
newtype Histories
Histories :: (Map Text History) -> Histories
data History
History :: Int -> [Text] -> Text -> History
_historyCurrent :: History -> Int
_historyContents :: History -> [Text]
_historyPrefix :: History -> Text
dynKeyA :: (Default v, Ord k) => k -> Lens' (Map k v) v
miniBuffer :: Text
historyUp :: EditorM ()
historyDown :: EditorM ()
historyStart :: EditorM ()

-- | Start an input session with History
historyStartGen :: Text -> EditorM ()
historyFinish :: EditorM ()

-- | Finish the current input session with history.
historyFinishGen :: Text -> EditorM Text -> EditorM ()
historyFind :: [Text] -> Int -> Int -> Int -> Text -> Int
historyMove :: Text -> Int -> EditorM ()
historyMoveGen :: Text -> Int -> EditorM Text -> EditorM Text
historyPrefixSet :: Text -> EditorM ()
historyPrefixSet' :: Text -> Text -> EditorM ()

-- | Helper that sets the given history at ident and <a>putEditorDyn</a>s
--   the result.
setHistory :: (MonadEditor m, Functor m) => Text -> History -> Map Text History -> m ()
instance Typeable History
instance Typeable Histories
instance Show History
instance Eq History
instance Show Histories
instance Eq Histories
instance YiVariable Histories
instance Binary History
instance Default History
instance Default Histories
instance Binary Histories


-- | Search/Replace functions
module Yi.Search

-- | Put regex into regex <tt>register</tt>
setRegexE :: SearchExp -> EditorM ()

-- | Clear the regex <tt>register</tt>
resetRegexE :: EditorM ()

-- | Return contents of regex register
getRegexE :: EditorM (Maybe SearchExp)

-- | Global searching. Search for regex and move point to that position.
--   <tt>Nothing</tt> means reuse the last regular expression. <tt>Just
--   s</tt> means use <tt>s</tt> as the new regular expression. Direction
--   of search can be specified as either <tt>Backward</tt> or
--   <tt>Forward</tt> (forwards in the buffer). Arguments to modify the
--   compiled regular expression can be supplied as well.
type SearchMatch = Region
data SearchResult
PatternFound :: SearchResult
PatternNotFound :: SearchResult
SearchWrapped :: SearchResult
data SearchOption :: *

-- | Compile for matching that ignores char case
IgnoreCase :: SearchOption

-- | Compile for newline-insensitive matching
NoNewLine :: SearchOption

-- | Treat the input not as a regex but as a literal string to search for.
QuoteRegex :: SearchOption
doSearch :: Maybe String -> [SearchOption] -> Direction -> EditorM SearchResult

-- | Set up a search.
searchInit :: String -> Direction -> [SearchOption] -> EditorM (SearchExp, Direction)

-- | Do a search, placing cursor at first char of pattern, if found.
--   Keymaps may implement their own regex language. How do we provide for
--   this? Also, what's happening with ^ not matching sol?
continueSearch :: (SearchExp, Direction) -> BufferM SearchResult

-- | Create a SearchExp that matches exactly its argument
makeSimpleSearch :: YiString -> SearchExp

-- | Search and Replace all within the current region. Note the region is
--   the final argument since we might perform the same search and replace
--   over multiple regions however we are unlikely to perform several
--   search and replaces over the same region since the first such may
--   change the bounds of the region.
searchReplaceRegionB :: YiString -> YiString -> Region -> BufferM Int

-- | Peform a search and replace on the selection
searchReplaceSelectionB :: YiString -> YiString -> BufferM Int

-- | Replace a string by another everywhere in the document
replaceString :: YiString -> YiString -> BufferM Int
searchAndRepRegion :: YiString -> YiString -> Bool -> Region -> EditorM Bool

-- | Search and replace in the given region.
--   
--   If the input boolean is True, then the replace is done globally,
--   otherwise only the first match is replaced. Returns the number of
--   replacements done.
searchAndRepRegion0 :: SearchExp -> YiString -> Bool -> Region -> BufferM Int

-- | Search and replace in the region defined by the given unit. The rest
--   is as in <a>searchAndRepRegion</a>.
searchAndRepUnit :: YiString -> YiString -> Bool -> TextUnit -> EditorM Bool
isearchInitE :: Direction -> EditorM ()
isearchIsEmpty :: EditorM Bool
isearchAddE :: Text -> EditorM ()
isearchPrevE :: EditorM ()
isearchNextE :: EditorM ()
isearchWordE :: EditorM ()
isearchHistory :: Int -> EditorM ()
isearchDelE :: EditorM ()

-- | Cancel a search. Also see <a>isearchCancelWithE</a>.
isearchCancelE :: EditorM ()

-- | Succesfully finish a search. Also see <a>isearchFinishWithE</a>.
isearchFinishE :: EditorM ()

-- | Wrapper over <a>isearchEndWith</a> that passes through the action and
--   marks the search as unsuccessful (i.e. when the user wants to jump
--   back to where the search started).
isearchCancelWithE :: EditorM a -> EditorM ()

-- | Wrapper over <a>isearchEndWith</a> that passes through the action and
--   accepts the search as successful (i.e. when the user wants to stay at
--   the result).
isearchFinishWithE :: EditorM a -> EditorM ()

-- | Find the next match and select it. Point is end, mark is beginning.
qrNext :: Window -> BufferRef -> SearchExp -> EditorM ()

-- | Replace all the remaining occurrences.
qrReplaceAll :: Window -> BufferRef -> SearchExp -> YiString -> EditorM ()

-- | We replace the currently selected match and then move to the next
--   match.
qrReplaceOne :: Window -> BufferRef -> SearchExp -> YiString -> EditorM ()

-- | Exit from query/replace.
qrFinish :: EditorM ()
instance Typeable Isearch
instance Eq SearchResult
instance Show Isearch
instance YiVariable Isearch
instance Default Isearch
instance Binary Isearch


-- | This module implements persistence across different Yi runs. It
--   includes minibuffer command history, marks etc. Warning: Current
--   version will _not_ check whether two or more instances of Yi are run
--   at the same time.
module Yi.PersistentState

-- | Loads a persistent state, and sets Yi state variables accordingly.
loadPersistentState :: YiM ()

-- | Here is a persistent history saving part. We assume each command is a
--   single line. To add new components, one has to:
--   
--   <ul>
--   <li>add new field in <tt>PersistentState</tt> structure,</li>
--   <li>add write and read parts in
--   <tt>loadPersistentState</tt>/<tt>savePersistentState</tt>,</li>
--   <li>add a trimming code in <tt>savePersistentState</tt> to prevent
--   blowing up of save file.</li>
--   </ul>
savePersistentState :: YiM ()
maxHistoryEntries :: Field Int
persistentSearch :: Field Bool
instance Typeable PersistentSearch
instance Binary PersistentSearch
instance YiConfigVariable PersistentSearch
instance Default PersistentSearch
instance Typeable MaxHistoryEntries
instance Generic PersistentState
instance Binary MaxHistoryEntries
instance Datatype D1PersistentState
instance Constructor C1_0PersistentState
instance Selector S1_0_0PersistentState
instance Selector S1_0_1PersistentState
instance Selector S1_0_2PersistentState
instance YiConfigVariable MaxHistoryEntries
instance Default MaxHistoryEntries
instance Binary PersistentState


-- | The core actions of Yi. This module is the link between the editor and
--   the UI. Key bindings, and libraries should manipulate Yi through the
--   interface defined here.
module Yi.Core

-- | Start up the editor, setting any state with the user preferences and
--   file names passed in, and turning on the UI
startEditor :: Config -> Maybe Editor -> IO ()

-- | Quit.
quitEditor :: YiM ()

-- | Redraw
refreshEditor :: YiM ()

-- | Suspend the program
suspendEditor :: YiM ()
userForceRefresh :: YiM ()

-- | Show an error on the status line and log it.
errorEditor :: Text -> YiM ()

-- | Close the current window. If this is the last window open, quit the
--   program.
--   
--   CONSIDER: call quitEditor when there are no other window in the
--   <a>interactive</a> function. (Not possible since the windowset type
--   disallows it -- should it be relaxed?)
closeWindow :: YiM ()

-- | This is a like <a>closeWindow</a> but with emacs behaviour of C-x 0:
--   if we're trying to close the minibuffer or last buffer in the editor,
--   then just print a message warning the user about it rather closing
--   mini or quitting editor.
closeWindowEmacs :: YiM ()

-- | Pipe a string through an external command, returning the stdout chomp
--   any trailing newline (is this desirable?)
--   
--   Todo: varients with marks?
runProcessWithInput :: String -> String -> YiM String

-- | Start a subprocess with the given command and arguments.
startSubprocess :: FilePath -> [String] -> (Either SomeException ExitCode -> YiM x) -> YiM BufferRef
sendToProcess :: BufferRef -> String -> YiM ()
runAction :: Action -> YiM ()
withSyntax :: (Show x, YiAction a x) => (forall syntax. Mode syntax -> syntax -> a) -> YiM ()
focusAllSyntax :: Editor -> Editor

-- | Runs a <a>YiM</a> action in a separate thread.
--   
--   Notes:
--   
--   <ul>
--   <li>It seems to work but I don't know why</li>
--   <li>Maybe deadlocks?</li>
--   <li>If you're outputting into the Yi window, you should really limit
--   the rate at which you do so: for example, the Pango front-end will
--   quite happily segfault/double-free if you output too fast.</li>
--   </ul>
--   
--   I am exporting this for those adventurous to play with but I have only
--   discovered how to do this a night before the release so it's rather
--   experimental. A simple function that prints a message once a second, 5
--   times, could be written like this:
--   
--   <pre>
--   printer :: YiM ThreadId
--   printer = do
--     mv &lt;- io $ newMVar (0 :: Int)
--     forkAction (suicide mv) MustRefresh $ do
--       c &lt;- io $ do
--         modifyMVar_ mv (return . succ)
--         tryReadMVar mv
--       case c of
--         Nothing -&gt; printMsg "messaging unknown time"
--         Just x -&gt; printMsg $ "message #" &lt;&gt; showT x
--     where
--       suicide mv = tryReadMVar mv &gt;&gt;= case
--         Just i | i &gt;= 5 -&gt; return True
--         _ -&gt; threadDelay 1000000 &gt;&gt; return False
--   </pre>
forkAction :: (YiAction a x, Show x) => IO Bool -> IsRefreshNeeded -> a -> YiM ThreadId


-- | Functions working with the minibuffer.
module Yi.MiniBuffer

-- | Open a minibuffer window with the given prompt and keymap The third
--   argument is an action to perform after the minibuffer is opened such
--   as move to the first occurence of a searched for string. If you don't
--   need this just supply <tt>return ()</tt>
spawnMinibufferE :: Text -> KeymapEndo -> EditorM BufferRef

-- | <tt>withMinibufferFree prompt act</tt>: Simple version of
--   <tt><a>withMinibufferGen</a></tt>
withMinibufferFree :: Text -> (Text -> YiM ()) -> YiM ()

-- | <tt>withMinibuffer prompt completer act</tt>: open a minibuffer with
--   <tt>prompt</tt>. Once a string <tt>s</tt> is obtained, run <tt>act
--   s</tt>. <tt>completer</tt> can be used to complete functions: it
--   returns a list of possible matches.
withMinibuffer :: Text -> (Text -> YiM [Text]) -> (Text -> YiM ()) -> YiM ()

-- | <tt>withMinibufferGen proposal getHint prompt completer onTyping
--   act</tt>: open a minibuffer with <tt>prompt</tt>, and initial content
--   <tt>proposal</tt>. Once a string <tt>s</tt> is obtained, run <tt>act
--   s</tt>. <tt>completer</tt> can be used to complete inputs by returning
--   an incrementally better match, and getHint can give an immediate
--   feedback to the user on the current input.
--   
--   <tt>on Typing</tt> is an extra action which will fire with every user
--   key-press and receives minibuffer contents. Use something like
--   <tt>const $ return ()</tt> if you don't need this.
withMinibufferGen :: Text -> (Text -> YiM [Text]) -> Text -> (Text -> YiM Text) -> (Text -> YiM ()) -> (Text -> YiM ()) -> YiM ()

-- | Open a minibuffer, given a finite number of suggestions.
withMinibufferFin :: Text -> [Text] -> (Text -> YiM ()) -> YiM ()

-- | Hint function that does nothing, for use with
--   <tt><a>withMinibufferGen</a></tt>
noHint :: a -> YiM [a]
noPossibilities :: String -> YiM [String]

-- | Makes a completion function.
mkCompleteFn :: (Text -> (Text -> Maybe Text) -> [Text] -> EditorM Text) -> (Text -> Text -> Maybe Text) -> (Text -> YiM [Text]) -> Text -> YiM Text
simpleComplete :: (Text -> YiM [Text]) -> Text -> YiM Text
infixComplete :: (Text -> YiM [Text]) -> Text -> YiM Text
infixComplete' :: Bool -> (Text -> YiM [Text]) -> Text -> YiM Text
anyModeByName :: Text -> YiM AnyMode
getAllModeNames :: YiM [Text]

-- | Returns all the buffer names
matchingBufferNames :: YiM [Text]
anyModeByNameM :: Text -> YiM (Maybe AnyMode)
anyModeName :: AnyMode -> Text

-- | Tag a type with a documentation
newtype (:::) t doc
Doc :: t -> (:::) t doc
fromDoc :: (:::) t doc -> t
data LineNumber
data RegexTag
data FilePatternTag
data ToKill
newtype CommandArguments
CommandArguments :: [Text] -> CommandArguments

-- | Prompts the user for comment syntax to use for the current mode.
commentRegion :: YiM ()

-- | Prompts for a buffer name, turns it into a <a>BufferRef</a> and passes
--   it on to the handler function. Uses all known buffers for hinting.
promptingForBuffer :: Text -> (BufferRef -> YiM ()) -> ([BufferRef] -> [BufferRef] -> [BufferRef]) -> YiM ()

-- | Prints out the rope of the current buffer as-is to stdout.
--   
--   The only way to stop it is to close the buffer in question which
--   should free up the <a>BufferRef</a>.
debugBufferContent :: YiM ()
instance Typeable (:::)
instance Typeable RegexTag
instance Typeable FilePatternTag
instance Typeable CommandArguments
instance Eq t => Eq (t ::: doc)
instance Num t => Num (t ::: doc)
instance IsString t => IsString (t ::: doc)
instance Show CommandArguments
instance Eq CommandArguments
instance Promptable CommandArguments
instance DocType FilePatternTag
instance DocType RegexTag
instance DocType ToKill
instance DocType LineNumber
instance (DocType doc, Promptable t) => Promptable (t ::: doc)
instance Show x => Show (x ::: t)
instance (YiAction a x, Promptable r) => YiAction (r -> a) x
instance Promptable BufferRef
instance Promptable AnyMode
instance Promptable Point
instance Promptable TextUnit
instance Promptable Direction
instance Promptable YiString
instance Promptable Text
instance Promptable Int
instance Promptable Char
instance Promptable String


-- | Various high-level functions to further classify.
module Yi.Misc

-- | Given a possible starting path (which if not given defaults to the
--   current directory) and a fragment of a path we find all files within
--   the given (or current) directory which can complete the given path
--   fragment. We return a pair of both directory plus the filenames on
--   their own that is without their directories. The reason for this is
--   that if we return all of the filenames then we get a <tt>hint</tt>
--   which is way too long to be particularly useful.
getAppropriateFiles :: Maybe Text -> Text -> YiM (Text, [Text])

-- | Given a path, trim the file name bit if it exists. If no path given,
--   return current directory.
getFolder :: Maybe String -> IO String

-- | Like <tt>M-x cd</tt>, it changes the current working directory. Mighty
--   useful when we don't start Yi from the project directory or want to
--   switch projects, as many tools only use the current working directory.
cd :: YiM ()

-- | Shows current working directory. Also see <a>cd</a>.
pwd :: YiM ()

-- | Given a possible path and a prefix, return matching file names.
matchingFileNames :: Maybe Text -> Text -> YiM [Text]
rot13Char :: Char -> Char

-- | Place mark at current point. If there's an existing mark at point
--   already, deactivate mark.
placeMark :: BufferM ()

-- | Select the contents of the whole buffer
selectAll :: BufferM ()
adjBlock :: Int -> BufferM ()

-- | A simple wrapper to adjust the current indentation using the mode
--   specific indentation function but according to the given indent
--   behaviour.
adjIndent :: IndentBehaviour -> BufferM ()

-- | Generic emacs style prompt file action. Takes a <tt>prompt</tt> and a
--   continuation <tt>act</tt> and prompts the user with file hints.
promptFile :: Text -> (Text -> YiM ()) -> YiM ()

-- | As <a>promptFile</a> but additionally allows the caller to transform
--   the list of hints arbitrarily, such as only showing directories.
promptFileChangingHints :: Text -> (Text -> [Text] -> YiM [Text]) -> (Text -> YiM ()) -> YiM ()
matchFile :: Text -> Text -> Maybe Text
completeFile :: Text -> Text -> YiM Text
printFileInfoE :: EditorM ()

-- | Prints out the rope of the current buffer as-is to stdout.
--   
--   The only way to stop it is to close the buffer in question which
--   should free up the <a>BufferRef</a>.
debugBufferContent :: YiM ()


-- | A simple <a>dired</a> implementation for Yi.
--   
--   <h1>TODO</h1>
--   
--   <ul>
--   <li>add more comments</li>
--   <li>Support symlinks</li>
--   <li>Mark operations<ul><li>search</li></ul></li>
--   </ul>
--   
--   <ul>
--   <li>Improve the colouring to show<ul><li>loaded buffers</li><li>.hs
--   files</li><li>marked files</li></ul></li>
--   <li>Fix old mod dates (&gt; 6months) to show year</li>
--   <li>Fix the 'number of links' field to show actual values not just
--   1...</li>
--   <li>Automatic support for browsing .zip, .gz files etc...</li>
--   </ul>
module Yi.Dired
dired :: YiM ()
diredDir :: FilePath -> YiM ()
diredDirBuffer :: FilePath -> YiM BufferRef

-- | If file exists, read contents of file into a new buffer, otherwise
--   creating a new empty buffer. Replace the current window with a new
--   window onto the new buffer.
--   
--   If the file is already open, just switch to the corresponding buffer.
--   
--   Need to clean up semantics for when buffers exist, and how to attach
--   windows to buffers.
--   
--   <tt>Yi.File</tt> module re-exports this, you probably want to import
--   that instead.
--   
--   In case of a decoding failure, failure message is returned instead of
--   the <a>BufferRef</a>.
editFile :: FilePath -> YiM (Either Text BufferRef)
instance Binary DiredFileInfo
instance Binary DiredEntry
instance YiVariable DiredState
instance Default DiredState
instance Binary DiredState
instance Typeable DiredFileInfo
instance Typeable DiredEntry
instance Typeable DiredState
instance Show DiredFileInfo
instance Eq DiredFileInfo
instance Generic DiredFileInfo
instance Show DiredEntry
instance Eq DiredEntry
instance Generic DiredEntry
instance Show DiredState
instance Eq DiredState
instance Generic DiredState
instance Datatype D1DiredFileInfo
instance Constructor C1_0DiredFileInfo
instance Selector S1_0_0DiredFileInfo
instance Selector S1_0_1DiredFileInfo
instance Selector S1_0_2DiredFileInfo
instance Selector S1_0_3DiredFileInfo
instance Selector S1_0_4DiredFileInfo
instance Selector S1_0_5DiredFileInfo
instance Datatype D1DiredEntry
instance Constructor C1_0DiredEntry
instance Constructor C1_1DiredEntry
instance Constructor C1_2DiredEntry
instance Constructor C1_3DiredEntry
instance Constructor C1_4DiredEntry
instance Constructor C1_5DiredEntry
instance Constructor C1_6DiredEntry
instance Constructor C1_7DiredEntry
instance Datatype D1DiredState
instance Constructor C1_0DiredState
instance Selector S1_0_0DiredState
instance Selector S1_0_1DiredState
instance Selector S1_0_2DiredState
instance Selector S1_0_3DiredState
instance Selector S1_0_4DiredState
instance Selector S1_0_5DiredState
instance Typeable DiredOpState
instance Show DiredOpState
instance Eq DiredOpState
instance Generic DiredOpState
instance Datatype D1DiredOpState
instance Constructor C1_0DiredOpState
instance Selector S1_0_0DiredOpState
instance Selector S1_0_1DiredOpState
instance YiVariable DiredOpState
instance Binary DiredOpState
instance Default DiredOpState


module Yi.File

-- | If file exists, read contents of file into a new buffer, otherwise
--   creating a new empty buffer. Replace the current window with a new
--   window onto the new buffer.
--   
--   If the file is already open, just switch to the corresponding buffer.
--   
--   Need to clean up semantics for when buffers exist, and how to attach
--   windows to buffers.
--   
--   <tt>Yi.File</tt> module re-exports this, you probably want to import
--   that instead.
--   
--   In case of a decoding failure, failure message is returned instead of
--   the <a>BufferRef</a>.
editFile :: FilePath -> YiM (Either Text BufferRef)

-- | Tries to open a new buffer with <a>editFile</a> and runs the given
--   action on the buffer handle if it succeeds.
--   
--   If the <a>editFile</a> fails, just the failure message is printed.
openingNewFile :: FilePath -> BufferM a -> YiM ()

-- | Same as <tt>openingNewFile</tt> with no action to run after.
openNewFile :: FilePath -> YiM ()

-- | Try to write a file in the manner of vi/vim Need to catch any
--   exception to avoid losing bindings
viWrite :: YiM ()

-- | Try to write to a named file in the manner of vi/vim
viWriteTo :: Text -> YiM ()

-- | Try to write to a named file if it doesn't exist. Error out if it
--   does.
viSafeWriteTo :: Text -> YiM ()

-- | Write current buffer to disk, if this buffer is associated with a file
fwriteE :: YiM Bool

-- | Write a given buffer to disk if it is associated with a file.
fwriteBufferE :: BufferRef -> YiM Bool

-- | Write all open buffers
fwriteAllY :: YiM Bool

-- | Write current buffer to disk as <tt>f</tt>. The file is also set to
--   <tt>f</tt>.
fwriteToE :: Text -> YiM Bool

-- | Make a backup copy of file
backupE :: FilePath -> YiM ()

-- | Revert to the contents of the file on disk
revertE :: YiM ()

-- | Associate buffer with file; canonicalize the given path name.
setFileName :: BufferRef -> FilePath -> YiM ()

-- | Checks if the given buffer deserves a save: whether it's a file buffer
--   and whether it's pointing at a file rather than a directory.
deservesSave :: FBuffer -> YiM Bool
preSaveHooks :: Field [Action]
instance Typeable PreSaveHooks
instance YiConfigVariable PreSaveHooks
instance Default PreSaveHooks


-- | Evaluator for actions (<a>Action</a>, <a>YiAction</a>). Uses a
--   <tt>GHCi</tt> session under the hood.
module Yi.Eval

-- | Runs the action, as written by the user.
--   
--   The behaviour of this function can be customised by modifying the
--   <a>Evaluator</a> variable.
execEditorAction :: String -> YiM ()

-- | Lists the action names in scope, for use by <a>execEditorAction</a>,
--   and <tt>help</tt> index.
--   
--   The behaviour of this function can be customised by modifying the
--   <a>Evaluator</a> variable.
getAllNamesInScope :: YiM [String]

-- | Describes the named action in scope, for use by <tt>help</tt>.
--   
--   The behaviour of this function can be customised by modifying the
--   <a>Evaluator</a> variable.
describeNamedAction :: String -> YiM String

-- | Config variable for customising the behaviour of
--   <a>execEditorAction</a> and <a>getAllNamesInScope</a>.
--   
--   Set this variable using <a>evaluator</a>. See <tt>ghciEvaluator</tt>
--   and <tt>finiteListEvaluator</tt> for two implementation.
data Evaluator
Evaluator :: (String -> YiM ()) -> YiM [String] -> (String -> YiM String) -> Evaluator

-- | implementation of <a>execEditorAction</a>
execEditorActionImpl :: Evaluator -> String -> YiM ()

-- | implementation of <a>getAllNamesInScope</a>
getAllNamesInScopeImpl :: Evaluator -> YiM [String]

-- | describe named action (or at least its type.), simplest implementation
--   is at least <tt>return</tt>.
describeNamedActionImpl :: Evaluator -> String -> YiM String

-- | The evaluator to use for <a>execEditorAction</a> and
--   <a>getAllNamesInScope</a>.
evaluator :: Field Evaluator

-- | Evaluator based on a fixed list of published actions. Has a few
--   differences from <tt>ghciEvaluator</tt>:
--   
--   <ul>
--   <li>expressions can't be evaluated</li>
--   <li>all suggested actions are actually valued</li>
--   <li>(related to the above) doesn't contain junk actions from
--   Prelude</li>
--   <li>doesn't require GHCi backend, so uses less memory</li>
--   </ul>
publishedActionsEvaluator :: Evaluator

-- | Accessor for the published actions. Consider using
--   <a>publishAction</a>.
publishedActions :: Field (HashMap String Action)

-- | Publish the given action, by the given name. This will overwrite any
--   existing actions by the same name.
publishAction :: (YiAction a x, Show x) => String -> a -> ConfigM ()

-- | Tries to jump to error at the current line. See
--   <a>parseErrorMessageB</a>.
jumpToErrorE :: YiM ()

-- | Jumps to specified position in a given file.
jumpToE :: FilePath -> Int -> Int -> YiM ()
consoleKeymap :: Keymap
instance Default Evaluator
instance YiConfigVariable PublishedActions
instance Typeable Evaluator
instance Typeable NamesCache
instance Typeable HelpCache
instance Typeable PublishedActions
instance Binary NamesCache
instance Binary HelpCache
instance Monoid PublishedActions
instance Default PublishedActions
instance YiVariable HelpCache
instance Default HelpCache
instance YiVariable NamesCache
instance Default NamesCache
instance YiConfigVariable Evaluator


-- | Help command support This module uses Yi.Eval.describeNamedAction to
--   show whatever information about particular action is available from
--   current evaluator (ghciEvaluator currently presents only type.) TODO:
--   Would be nice to show excerpt from Haddock documentation in the
--   future.
--   
--   If given no arguments, the help index is shown (using
--   <tt>getAllNamesInScope</tt>).
--   
--   Please do not try to show descriptions for the whole index, as our
--   interface to GHCi is too slow.
module Yi.Command.Help

-- | Displays help for a given name, or help index, if no name is given
displayHelpFor :: Text -> YiM ()
instance Typeable HelpBuffer
instance Default HelpBuffer
instance Binary HelpBuffer
instance YiVariable HelpBuffer


-- | This module re-exports Yi.Buffer overriding insert* and delete*
--   functions with their more indent-aware variants. It is intended to be
--   imported instead of Yi.Buffer or qualified to avoid name clashes.
module Yi.Buffer.Adjusted
bdeleteB :: BufferM ()

-- | Insert the char at current point, extending size of buffer
insertB :: Char -> BufferM ()

-- | Insert the list at current point, extending size of buffer
insertN :: YiString -> BufferM ()
insertNAt :: YiString -> Point -> BufferM ()
deleteB :: TextUnit -> Direction -> BufferM ()
deleteN :: Int -> BufferM ()
deleteRegionB :: Region -> BufferM ()
deleteRegionWithStyleB :: Region -> RegionStyle -> BufferM Point


-- | Common types used by the vim keymap.
module Yi.Keymap.Vim.Common
data VimMode
Normal :: VimMode
NormalOperatorPending :: OperatorName -> VimMode

-- | char denotes how state got into insert mode (<tt>i</tt>, <tt>a</tt>,
--   etc.)
Insert :: Char -> VimMode
Replace :: VimMode
ReplaceSingleChar :: VimMode

-- | after C-o
InsertNormal :: VimMode

-- | after C-o and one of v, V, C-v
InsertVisual :: VimMode
Visual :: RegionStyle -> VimMode
Ex :: VimMode
Search :: VimMode -> Direction -> VimMode
previousMode :: VimMode -> VimMode
direction :: VimMode -> Direction
data VimBinding
VimBindingY :: (EventString -> VimState -> MatchResult (YiM RepeatToken)) -> VimBinding
VimBindingE :: (EventString -> VimState -> MatchResult (EditorM RepeatToken)) -> VimBinding
data GotoCharCommand
GotoCharCommand :: !Char -> !Direction -> !RegionStyle -> GotoCharCommand
data VimState
VimState :: !VimMode -> !(Maybe Int) -> !EventString -> !EventString -> !(HashMap RegisterName Register) -> !RegisterName -> !(Maybe RepeatableAction) -> !EventString -> !Bool -> !EventString -> !(Maybe GotoCharCommand) -> !EventString -> ![Point] -> !Bool -> !(Maybe (MacroName, EventString)) -> VimState
vsMode :: VimState -> !VimMode
vsCount :: VimState -> !(Maybe Int)

-- | for repeat and potentially macros
vsAccumulator :: VimState -> !EventString
vsTextObjectAccumulator :: VimState -> !EventString
vsRegisterMap :: VimState -> !(HashMap RegisterName Register)
vsActiveRegister :: VimState -> !RegisterName
vsRepeatableAction :: VimState -> !(Maybe RepeatableAction)

-- | see Yi.Keymap.Vim.vimEval comment
vsStringToEval :: VimState -> !EventString

-- | is set on $, allows j and k walk the right edge of lines
vsStickyEol :: VimState -> !Bool
vsOngoingInsertEvents :: VimState -> !EventString
vsLastGotoCharCommand :: VimState -> !(Maybe GotoCharCommand)
vsBindingAccumulator :: VimState -> !EventString
vsSecondaryCursors :: VimState -> ![Point]

-- | like vim's :help paste
vsPaste :: VimState -> !Bool
vsCurrentMacroRecording :: VimState -> !(Maybe (MacroName, EventString))
data Register
Register :: RegionStyle -> YiString -> Register
regRegionStyle :: Register -> RegionStyle
regContent :: Register -> YiString
data RepeatToken
Finish :: RepeatToken
Drop :: RepeatToken
Continue :: RepeatToken
data RepeatableAction
RepeatableAction :: !Int -> !EventString -> RepeatableAction
raPreviousCount :: RepeatableAction -> !Int
raActionString :: RepeatableAction -> !EventString
data MatchResult a
NoMatch :: MatchResult a
PartialMatch :: MatchResult a
WholeMatch :: a -> MatchResult a
newtype EventString
Ev :: Text -> EventString
_unEv :: EventString -> Text
unEv :: Iso' EventString Text
newtype OperatorName
Op :: Text -> OperatorName
_unOp :: OperatorName -> Text
unOp :: Iso' OperatorName Text
type RegisterName = Char
lookupBestMatch :: EventString -> [(EventString, a)] -> MatchResult a
matchesString :: EventString -> EventString -> MatchResult ()
instance Typeable RepeatableAction
instance Typeable VimMode
instance Typeable VimState
instance Eq RepeatableAction
instance Show RepeatableAction
instance Generic RepeatableAction
instance Generic Register
instance Eq VimMode
instance Show VimMode
instance Generic VimMode
instance Generic GotoCharCommand
instance Generic VimState
instance Show RepeatToken
instance Datatype D1RepeatableAction
instance Constructor C1_0RepeatableAction
instance Selector S1_0_0RepeatableAction
instance Selector S1_0_1RepeatableAction
instance Datatype D1Register
instance Constructor C1_0Register
instance Selector S1_0_0Register
instance Selector S1_0_1Register
instance Datatype D1VimMode
instance Constructor C1_0VimMode
instance Constructor C1_1VimMode
instance Constructor C1_2VimMode
instance Constructor C1_3VimMode
instance Constructor C1_4VimMode
instance Constructor C1_5VimMode
instance Constructor C1_6VimMode
instance Constructor C1_7VimMode
instance Constructor C1_8VimMode
instance Constructor C1_9VimMode
instance Selector S1_9_0VimMode
instance Selector S1_9_1VimMode
instance Datatype D1GotoCharCommand
instance Constructor C1_0GotoCharCommand
instance Datatype D1VimState
instance Constructor C1_0VimState
instance Selector S1_0_0VimState
instance Selector S1_0_1VimState
instance Selector S1_0_2VimState
instance Selector S1_0_3VimState
instance Selector S1_0_4VimState
instance Selector S1_0_5VimState
instance Selector S1_0_6VimState
instance Selector S1_0_7VimState
instance Selector S1_0_8VimState
instance Selector S1_0_9VimState
instance Selector S1_0_10VimState
instance Selector S1_0_11VimState
instance Selector S1_0_12VimState
instance Selector S1_0_13VimState
instance Selector S1_0_14VimState
instance YiVariable VimState
instance Binary VimState
instance Default VimState
instance Binary VimMode
instance Default VimMode
instance Binary GotoCharCommand
instance Binary Register
instance Binary RepeatableAction
instance Show EventString
instance Eq EventString
instance Ord EventString
instance Show OperatorName
instance Eq OperatorName
instance Binary OperatorName
instance Binary EventString
instance Monoid OperatorName
instance Monoid EventString
instance IsString OperatorName
instance IsString EventString


module Yi.Keymap.Vim.EventUtils
stringToEvent :: String -> Event
eventToEventString :: Event -> EventString
parseEvents :: EventString -> [Event]
stringToRepeatableAction :: EventString -> RepeatableAction
normalizeCount :: EventString -> EventString
splitCountedCommand :: EventString -> (Int, EventString)


module Yi.Keymap.Vim.StateUtils
switchMode :: VimMode -> VimState -> VimState
switchModeE :: VimMode -> EditorM ()
resetCount :: VimState -> VimState
resetCountE :: EditorM ()
setCountE :: Int -> EditorM ()
modifyStateE :: (VimState -> VimState) -> EditorM ()
getMaybeCountE :: EditorM (Maybe Int)
getCountE :: EditorM Int
accumulateEventE :: Event -> EditorM ()
accumulateBindingEventE :: Event -> EditorM ()
accumulateTextObjectEventE :: EventString -> EditorM ()
flushAccumulatorE :: EditorM ()
dropAccumulatorE :: EditorM ()
dropBindingAccumulatorE :: EditorM ()
dropTextObjectAccumulatorE :: EditorM ()
setRegisterE :: RegisterName -> RegionStyle -> YiString -> EditorM ()
getRegisterE :: RegisterName -> EditorM (Maybe Register)
normalizeCountE :: Maybe Int -> EditorM ()
setStickyEolE :: Bool -> EditorM ()
maybeMult :: Num a => Maybe a -> Maybe a -> Maybe a
updateModeIndicatorE :: VimState -> EditorM ()
saveInsertEventStringE :: EventString -> EditorM ()
resetActiveRegisterE :: EditorM ()


-- | This module doesn't contains actual eval, see <a>vimEval</a> comment.
module Yi.Keymap.Vim.Eval
scheduleActionStringForEval :: EventString -> EditorM ()


module Yi.Keymap.Vim.Ex.Types
data ExCommand
ExCommand :: YiM [Text] -> Bool -> Action -> Bool -> Text -> ExCommand
cmdComplete :: ExCommand -> YiM [Text]
cmdIsPure :: ExCommand -> Bool
cmdAction :: ExCommand -> Action
cmdAcceptsRange :: ExCommand -> Bool
cmdShow :: ExCommand -> Text
data LineRange

-- | 'a,'b
MarkRange :: String -> String -> LineRange

-- | %
FullRange :: LineRange
CurrentLineRange :: LineRange
evStringToExCommand :: [EventString -> Maybe ExCommand] -> EventString -> Maybe ExCommand
instance Show ExCommand


module Yi.Keymap.Vim.Ex.Eval
exEvalE :: [EventString -> Maybe ExCommand] -> EventString -> EditorM ()
exEvalY :: [EventString -> Maybe ExCommand] -> EventString -> YiM ()


-- | I'm a module waiting for some kind soul to give me a commentary!
module Yi.Keymap.Vim.StyledRegion
data StyledRegion
StyledRegion :: !RegionStyle -> !Region -> StyledRegion

-- | from vim help:
--   
--   <ol>
--   <li>If the motion is exclusive and the end of the motion is in column
--   1, the end of the motion is moved to the end of the previous line and
--   the motion becomes inclusive. Example: "}" moves to the first line
--   after a paragraph, but "d}" will not include that line.</li>
--   <li>If the motion is exclusive, the end of the motion is in column 1
--   and the start of the motion was at or before the first non-blank in
--   the line, the motion becomes linewise. Example: If a paragraph begins
--   with some blanks and you do "d}" while standing on the first
--   non-blank, all the lines of the paragraph are deleted, including the
--   blanks. If you do a put now, the deleted lines will be inserted below
--   the cursor position.</li>
--   </ol>
--   
--   TODO: case 2
normalizeRegion :: StyledRegion -> BufferM StyledRegion
transformCharactersInRegionB :: StyledRegion -> (Char -> Char) -> BufferM ()
transformCharactersInLineN :: Int -> (Char -> Char) -> BufferM ()


-- | TODO:
--   
--   respecting wrap in gj, g0, etc
--   
--   gm, go ]], [[, [], ][ [(, [{, ]), ]} ]m, ]M, [m, [M [ [*, [<i>, ]*,
--   ]</i>
--   
--   Traversing changelist
module Yi.Keymap.Vim.Motion
data Move
Move :: !RegionStyle -> !Bool -> (Maybe Int -> BufferM ()) -> Move
moveStyle :: Move -> !RegionStyle
moveIsJump :: Move -> !Bool
moveAction :: Move -> Maybe Int -> BufferM ()
data CountedMove
CountedMove :: !(Maybe Int) -> !Move -> CountedMove
stringToMove :: EventString -> MatchResult Move
regionOfMoveB :: CountedMove -> BufferM StyledRegion
changeMoveStyle :: (RegionStyle -> RegionStyle) -> Move -> Move


-- | Utils for the Vim keymap.
module Yi.Keymap.Vim.Utils
mkBindingE :: VimMode -> RepeatToken -> (Event, EditorM (), VimState -> VimState) -> VimBinding
mkBindingY :: VimMode -> (Event, YiM (), VimState -> VimState) -> VimBinding
mkStringBindingE :: VimMode -> RepeatToken -> (EventString, EditorM (), VimState -> VimState) -> VimBinding
mkStringBindingY :: VimMode -> (EventString, YiM (), VimState -> VimState) -> VimBinding
splitCountedCommand :: EventString -> (Int, EventString)
selectBinding :: EventString -> VimState -> [VimBinding] -> MatchResult (YiM RepeatToken)

-- | All impure bindings will be ignored.
selectPureBinding :: EventString -> VimState -> [VimBinding] -> MatchResult (EditorM RepeatToken)
matchFromBool :: Bool -> MatchResult ()
mkMotionBinding :: RepeatToken -> (VimMode -> Bool) -> VimBinding
mkChooseRegisterBinding :: (VimState -> Bool) -> VimBinding
pasteInclusiveB :: YiString -> RegionStyle -> BufferM ()
addNewLineIfNecessary :: YiString -> YiString
indentBlockRegionB :: Int -> Region -> BufferM ()
addVimJumpHereE :: EditorM ()


module Yi.Keymap.Vim.ReplaceMap
defReplaceMap :: [VimBinding]


module Yi.Keymap.Vim.ReplaceSingleCharMap
defReplaceSingleMap :: [VimBinding]


module Yi.Keymap.Vim.Search
doVimSearch :: Maybe String -> [SearchOption] -> Direction -> EditorM ()
continueVimSearch :: (SearchExp, Direction) -> BufferM ()

module Yi.Keymap.Vim.TextObject
data TextObject
TextObject :: !RegionStyle -> !TextUnit -> TextObject
data CountedTextObject
CountedTextObject :: !Int -> !TextObject -> CountedTextObject
regionOfTextObjectB :: CountedTextObject -> BufferM StyledRegion
changeTextObjectCount :: Int -> CountedTextObject -> CountedTextObject
changeTextObjectStyle :: (RegionStyle -> RegionStyle) -> TextObject -> TextObject
stringToTextObject :: String -> Maybe TextObject


-- | Implements some operators for the Vim keymap.
module Yi.Keymap.Vim.Operator
data VimOperator
VimOperator :: !OperatorName -> (Int -> StyledRegion -> EditorM RepeatToken) -> VimOperator
operatorName :: VimOperator -> !OperatorName
operatorApplyToRegionE :: VimOperator -> Int -> StyledRegion -> EditorM RepeatToken
defOperators :: [VimOperator]
opDelete :: VimOperator
opChange :: VimOperator
opYank :: VimOperator
opFormat :: VimOperator
stringToOperator :: [VimOperator] -> OperatorName -> Maybe VimOperator
mkCharTransformOperator :: OperatorName -> (Char -> Char) -> VimOperator
operatorApplyToTextObjectE :: VimOperator -> Int -> CountedTextObject -> EditorM RepeatToken
lastCharForOperator :: VimOperator -> String


module Yi.Keymap.Vim.NormalOperatorPendingMap
defNormalOperatorPendingMap :: [VimOperator] -> [VimBinding]


-- | Definitions for the bulk of modes shipped with Yi.
module Yi.Modes
type TokenBasedMode tok = Mode (Tree (Tok tok))
fundamentalMode :: Mode syntax
cMode :: StyleBasedMode
objectiveCMode :: StyleBasedMode
cppMode :: StyleBasedMode
cabalMode :: StyleBasedMode
clojureMode :: StyleBasedMode
srmcMode :: StyleBasedMode
ocamlMode :: TokenBasedMode Token
ottMode :: StyleBasedMode
gnuMakeMode :: StyleBasedMode
perlMode :: StyleBasedMode
pythonMode :: StyleBasedMode
javaMode :: StyleBasedMode
jsonMode :: StyleBasedMode

-- | When applied to an extensions list, creates a <a>modeApplies</a>
--   function.
anyExtension :: [String] -> FilePath -> a -> Bool

-- | When applied to an extensions list and regular expression pattern,
--   creates a <a>modeApplies</a> function.
extensionOrContentsMatch :: [String] -> String -> FilePath -> YiString -> Bool

-- | Specialised version of <a>linearSyntaxMode'</a> for the common case,
--   wrapping up into a <a>Lexer</a> with <a>commonLexer</a>.
linearSyntaxMode :: Show s => s -> TokenLexer AlexState s (Tok t) AlexInput -> (t -> StyleName) -> TokenBasedMode t
svnCommitMode :: StyleBasedMode

-- | Adds a hook to all matching hooks in a list
hookModes :: (AnyMode -> Bool) -> BufferM () -> [AnyMode] -> [AnyMode]

-- | Apply a list of mode hooks to a list of AnyModes
applyModeHooks :: [(AnyMode -> Bool, BufferM ())] -> [AnyMode] -> [AnyMode]

-- | Check whether a mode of the same name is already in modeTable and
--   returns the original mode, if it isn't the case.
lookupMode :: AnyMode -> YiM AnyMode
whitespaceMode :: StyleBasedMode
gitCommitMode :: TokenBasedMode Token
rubyMode :: StyleBasedMode
styleMode :: Show (l s) => StyleLexer l s t i -> TokenBasedMode t


-- | A simple text mode; it does very little besides define a comment
--   syntax. We have it as a separate mode so users can bind the commands
--   to this mode specifically.
module Yi.Mode.IReader
abstract :: Mode syntax
ireaderMode :: Mode syntax
ireadMode :: YiM ()


-- | Collection of <a>Mode</a>s for working with LaTeX.
module Yi.Mode.Latex

-- | syntax-based latex mode
latexMode3 :: Mode (Tree TT)

-- | syntax-based latex mode
latexMode2 :: Mode (Tree TT)
fastMode :: Mode (Tree TT)


-- | A <a>Mode</a> for working with buffers showing the results of
--   compilations.
module Yi.Mode.Compilation
mode :: TokenBasedMode Token


-- | Collection of <a>Mode</a>s for working with Haskell.
module Yi.Mode.Interactive
mode :: Mode (Tree (Tok Token))
interactId :: Text

-- | TODO: we're just converting back and forth here, <a>historyMoveGen</a>
--   and friends need to migrate to YiString it seems.
interactHistoryMove :: Int -> EditorM ()
interactHistoryFinish :: EditorM ()
interactHistoryStart :: EditorM ()
getInputRegion :: BufferM Region
getInput :: BufferM YiString
setInput :: YiString -> BufferM ()

-- | Open a new buffer for interaction with a process.
spawnProcess :: String -> [String] -> YiM BufferRef

-- | open a new buffer for interaction with a process, using any
--   interactive-derived mode
spawnProcessMode :: Mode syntax -> FilePath -> [String] -> YiM BufferRef

-- | Send the type command to the process
feedCommand :: YiM ()

-- | Send command, recieve reply
queryReply :: BufferRef -> String -> YiM YiString


-- | Various high-level functions to further classify.
module Yi.Command

-- | Changing the buffer name quite useful if you have several the same.
--   This also breaks the relation with the file.
changeBufferNameE :: YiM ()

-- | shell-command with argument prompt
shellCommandE :: YiM ()

-- | shell-command with a known argument
shellCommandV :: Text -> YiM ()
newtype CabalBuffer
CabalBuffer :: Maybe BufferRef -> CabalBuffer
cabalBuffer :: CabalBuffer -> Maybe BufferRef

-- | cabal-configure
cabalConfigureE :: CommandArguments -> YiM ()
configureExit :: Either SomeException ExitCode -> YiM ()
reloadProjectE :: String -> YiM ()

-- | Run the given commands with args and pipe the ouput into the build
--   buffer, which is shown in an other window.
buildRun :: Text -> [Text] -> (Either SomeException ExitCode -> YiM x) -> YiM ()
makeBuild :: CommandArguments -> YiM ()
cabalRun :: Text -> (Either SomeException ExitCode -> YiM x) -> CommandArguments -> YiM ()
makeRun :: (Either SomeException ExitCode -> YiM x) -> CommandArguments -> YiM ()

-- | cabal-build
cabalBuildE :: CommandArguments -> YiM ()
makeBuildE :: CommandArguments -> YiM ()
shell :: YiM BufferRef

-- | Search the source files in the project.
searchSources :: String ::: RegexTag -> YiM ()

-- | Perform a find+grep operation
grepFind :: String ::: FilePatternTag -> String ::: RegexTag -> YiM ()
instance Typeable CabalBuffer
instance Default CabalBuffer
instance Binary CabalBuffer
instance YiVariable CabalBuffer


-- | <a>Mode</a>s and utility function for working with the Abella
--   interactive theorem prover.
module Yi.Mode.Abella
abellaModeEmacs :: TokenBasedMode Token

-- | Start Abella in a buffer
abella :: CommandArguments -> YiM BufferRef
abellaEval :: YiM ()
abellaEvalFromProofPoint :: YiM ()
abellaUndo :: YiM ()

-- | Return Abella's buffer; create it if necessary. Show it in another
--   window.
abellaGet :: YiM BufferRef

-- | Send a command to Abella
abellaSend :: YiString -> YiM ()
instance Typeable AbellaBuffer
instance Default AbellaBuffer
instance Binary AbellaBuffer
instance YiVariable AbellaBuffer


-- | Module defining the <a>Mode</a> for JavaScript. <a>javaScriptMode</a>
--   uses the parser defined at <a>Yi.Syntax.JavaScript</a>.
module Yi.Mode.JavaScript
javaScriptMode :: Mode (Tree TT)

-- | Hooks for the JavaScript mode.
hooks :: Mode (Tree TT) -> Mode (Tree TT)
instance Typeable JSBuffer
instance Default JSBuffer
instance Binary JSBuffer
instance YiVariable JSBuffer


module Yi.Keymap.Vim.SearchMotionMap
defSearchMotionMap :: [VimBinding]


-- | Provides functions for calling Hoogle on the commandline, and
--   processing results into a form useful for completion or insertion.
module Yi.Hoogle

-- | Remove anything starting with uppercase letter. These denote either
--   module names or types.
caseSensitize :: [YiString] -> [YiString]

-- | Hoogle's output includes a sort of type keyword, telling whether a hit
--   is a package name, syntax, a module name, etc. But we care primarily
--   about the function names, so we filter out anything containing the
--   keywords.
gv :: [YiString] -> [YiString]

-- | Query Hoogle, with given search and options. This errors out on no
--   results or if the hoogle command is not on path.
hoogleRaw :: YiString -> YiString -> IO [YiString]

-- | Filter the output of <a>hoogleRaw</a> to leave just functions.
hoogleFunctions :: YiString -> IO [YiString]

-- | Return module-function pairs.
hoogleFunModule :: YiString -> IO [(YiString, YiString)]

-- | Call out to <a>hoogleFunModule</a>, and overwrite the word at point
--   with the first returned function.
hoogle :: YiM YiString

-- | Call out to <a>hoogleRaw</a>, and print inside the Minibuffer the
--   results of searching Hoogle with the word at point.
hoogleSearch :: YiM ()


-- | emacs-style rectangle manipulation functions.
module Yi.Rectangle
alignRegion :: Text -> BufferM ()

-- | Align each line of the region on the given regex. Fails if it is not
--   found in any line.
alignRegionOn :: Text -> BufferM ()

-- | Get the selected region as a rectangle. Returns the region extended to
--   lines, plus the start and end columns of the rectangle.
getRectangle :: BufferM (Region, Int, Int)

-- | Split text at the boundaries given
multiSplit :: [Int] -> YiString -> [YiString]
onRectangle :: (Int -> Int -> YiString -> YiString) -> BufferM ()
openRectangle :: BufferM ()
stringRectangle :: YiString -> BufferM ()
killRectangle :: EditorM ()
yankRectangle :: EditorM ()


-- | This module is aimed at being a helper for the Emacs keybindings. In
--   particular this should be useful for anyone that has a custom keymap
--   derived from or based on the Emacs one.
module Yi.Keymap.Emacs.Utils
type UnivArgument = Maybe Int

-- | Convert the universal argument to a number of repetitions
argToInt :: UnivArgument -> Int

-- | Quits the editor if there are no unmodified buffers if there are
--   unmodified buffers then we ask individually for each modified buffer
--   whether or not the user wishes to save it or not. If we get to the end
--   of this list and there are still some modified buffers then we ask
--   again if the user wishes to quit, but this is then a simple yes or no.
askQuitEditor :: YiM ()
askSaveEditor :: YiM ()

-- | Quits the editor if there are no unmodified buffers if there are then
--   simply confirms with the user that they with to quit.
modifiedQuitEditor :: YiM ()

-- | <tt>withMinibuffer prompt completer act</tt>: open a minibuffer with
--   <tt>prompt</tt>. Once a string <tt>s</tt> is obtained, run <tt>act
--   s</tt>. <tt>completer</tt> can be used to complete functions: it
--   returns a list of possible matches.
withMinibuffer :: Text -> (Text -> YiM [Text]) -> (Text -> YiM ()) -> YiM ()
queryReplaceE :: YiM ()
isearchKeymap :: Direction -> Keymap

-- | cabal-configure
cabalConfigureE :: CommandArguments -> YiM ()

-- | cabal-build
cabalBuildE :: CommandArguments -> YiM ()
reloadProjectE :: String -> YiM ()
executeExtendedCommandE :: YiM ()
evalRegionE :: YiM ()
readUniversalArg :: KeymapM (Maybe Int)
scrollDownE :: UnivArgument -> BufferM ()
scrollUpE :: UnivArgument -> BufferM ()

-- | Prompts the user for a buffer name and switches to the chosen buffer.
switchBufferE :: YiM ()

-- | Prompts the user for a buffer name and kills the chosen buffer.
--   Prompts about really closing if the buffer is marked as changed since
--   last save.
killBufferE :: YiM ()

-- | Insert next character, "raw"
insertNextC :: UnivArgument -> KeymapM ()

-- | Open a file using the minibuffer. We have to set up some stuff to
--   allow hints and auto-completion.
findFile :: YiM ()

-- | Like <a>findFile</a> but sets the resulting buffer to read-only.
findFileReadOnly :: YiM ()

-- | Open a file in a new tab using the minibuffer.
findFileNewTab :: YiM ()

-- | Generic emacs style prompt file action. Takes a <tt>prompt</tt> and a
--   continuation <tt>act</tt> and prompts the user with file hints.
promptFile :: Text -> (Text -> YiM ()) -> YiM ()

-- | Prompt the user to give a tag and then jump to that tag
promptTag :: YiM ()

-- | If on separators (space, tab, unicode seps), reduce multiple
--   separators to just a single separator (or however many given through
--   <a>UnivArgument</a>).
--   
--   If we aren't looking at a separator, insert a single space. This is
--   like emacs ‘just-one-space’ but doesn't deal with negative argument
--   case but works with other separators than just space. What counts as a
--   separator is decided by <a>isAnySep</a> modulo <tt>n</tt> character.
--   
--   Further, it will only reduce a single type of separator at once: if we
--   have hard tabs followed by spaces, we are able to reduce one and not
--   the other.
justOneSep :: UnivArgument -> BufferM ()

-- | Join this line to previous (or next N if universal)
joinLinesE :: UnivArgument -> BufferM ()

-- | Counts the number of lines, words and characters inside selected
--   region. Coresponds to emacs' <tt>count-words-region</tt>.
countWordsRegion :: YiM ()


-- | Cua keymap.
module Yi.Keymap.Cua
keymap :: KeymapSet

-- | Introduce a keymap that is compatible with both windows and osx, by
--   parameterising the event modifier required for commands
portableKeymap :: (Event -> Event) -> KeymapSet
customizedCuaKeymapSet :: Keymap -> KeymapSet
cut :: EditorM ()
paste :: EditorM ()
copy :: EditorM ()
del :: EditorM ()


module Yi.Keymap.Emacs.KillRing

-- | C-w
--   
--   This is like <tt>kill-region-or-backward-word</tt>.
killRegion :: BufferM ()

-- | C-k
killLineE :: Maybe Int -> YiM ()
killringPut :: Direction -> YiString -> EditorM ()

-- | Kill the rest of line
killRestOfLine :: BufferM ()

-- | C-y
yankE :: EditorM ()

-- | M-w
killRingSaveE :: EditorM ()

-- | M-y
yankPopE :: EditorM ()

-- | C-M-w
appendNextKillE :: EditorM ()


-- | A minimalist emulation of emacs buffer menu mode, to be fleshed out
--   later
module Yi.Mode.Buffers

-- | Retrieve buffer list and open a them in buffer mode using the
--   <a>bufferKeymap</a>.
listBuffers :: YiM ()


-- | Module providing text completion functions.
module Yi.TextCompletion
wordComplete :: YiM ()
wordComplete' :: Bool -> YiM ()
wordCompleteString :: YiM Text
wordCompleteString' :: Bool -> YiM Text

-- | Try to complete the current word with occurences found elsewhere in
--   the editor. Further calls try other options.
mkWordComplete :: YiM Text -> (Text -> YiM [Text]) -> ([Text] -> YiM ()) -> (Text -> Text -> Bool) -> YiM Text

-- | Switch out of completion mode.
resetComplete :: EditorM ()
completeWordB :: CompletionScope -> EditorM ()
data CompletionScope
FromCurrentBuffer :: CompletionScope
FromAllBuffers :: CompletionScope
instance Typeable Completion
instance Show Completion
instance Eq Completion
instance Eq CompletionScope
instance Show CompletionScope
instance YiVariable Completion
instance Default Completion
instance Binary Completion


-- | This module aims at a mode that should be (mostly) intuitive to emacs
--   users, but mapping things into the Yi world when convenient. Hence, do
--   not go into the trouble of trying 100% emulation. For example,
--   <tt>M-x</tt> gives access to Yi (Haskell) functions, with their native
--   names.
module Yi.Keymap.Emacs
keymap :: KeymapSet
mkKeymap :: Proto ModeMap -> KeymapSet
defKeymap :: Proto ModeMap
data ModeMap
ModeMap :: Keymap -> Bool -> ModeMap
_eKeymap :: ModeMap -> Keymap
_completionCaseSensitive :: ModeMap -> Bool
eKeymap :: Lens' ModeMap Keymap
completionCaseSensitive :: Lens' ModeMap Bool


module Yi.Keymap.Vim.InsertMap
defInsertMap :: [(String, Char)] -> [VimBinding]


-- | Implements common <a>ExCommand</a>s for the Vim keymap.
module Yi.Keymap.Vim.Ex.Commands.Common
parse :: GenParser Char () ExCommand -> EventString -> Maybe ExCommand
parseWithBang :: GenParser Char () a -> (a -> Bool -> GenParser Char () ExCommand) -> EventString -> Maybe ExCommand
parseWithBangAndCount :: GenParser Char () a -> (a -> Bool -> Maybe Int -> GenParser Char () ExCommand) -> EventString -> Maybe ExCommand
parseRange :: GenParser Char s (Maybe (BufferM Region))
data BoolOptionAction
BoolOptionSet :: !Bool -> BoolOptionAction
BoolOptionInvert :: BoolOptionAction
BoolOptionAsk :: BoolOptionAction
data TextOptionAction
TextOptionSet :: !Text -> TextOptionAction
TextOptionAsk :: TextOptionAction
parseBoolOption :: Text -> (BoolOptionAction -> Action) -> EventString -> Maybe ExCommand
parseTextOption :: Text -> (TextOptionAction -> Action) -> EventString -> Maybe ExCommand
filenameComplete :: Text -> YiM [Text]
forAllBuffers :: MonadEditor m => (BufferRef -> m ()) -> m ()
pureExCommand :: ExCommand
impureExCommand :: ExCommand

-- | Show the common error message about an unsaved file on the status
--   line.
errorNoWrite :: EditorM ()

-- | Useful parser for any Ex command that acts kind of like a shell
commandArgs :: GenParser Char () [Text]
needsSaving :: BufferRef -> YiM Bool


-- | :buffer ex command to switch to named or numbered buffer.
module Yi.Keymap.Vim.Ex.Commands.Buffer
parse :: EventString -> Maybe ExCommand


module Yi.Keymap.Vim.Ex.Commands.BufferDelete
parse :: EventString -> Maybe ExCommand


-- | :buffers or :ls ex command to list buffers.
module Yi.Keymap.Vim.Ex.Commands.Buffers
parse :: EventString -> Maybe ExCommand


module Yi.Keymap.Vim.Ex.Commands.Cabal
parse :: EventString -> Maybe ExCommand


module Yi.Keymap.Vim.Ex.Commands.Delete
parse :: EventString -> Maybe ExCommand


-- | Implements quit commands.
module Yi.Keymap.Vim.Ex.Commands.Edit
parse :: EventString -> Maybe ExCommand


module Yi.Keymap.Vim.Ex.Commands.GotoLine
parse :: EventString -> Maybe ExCommand


module Yi.Keymap.Vim.Ex.Commands.Help
parse :: EventString -> Maybe ExCommand


module Yi.Keymap.Vim.Ex.Commands.Make
parse :: EventString -> Maybe ExCommand


module Yi.Keymap.Vim.Ex.Commands.Nohl
parse :: EventString -> Maybe ExCommand


-- | Implements quit commands.
module Yi.Keymap.Vim.Ex.Commands.Paste
parse :: EventString -> Maybe ExCommand


-- | Implements quit commands.
module Yi.Keymap.Vim.Ex.Commands.Quit
parse :: EventString -> Maybe ExCommand


module Yi.Keymap.Vim.Ex.Commands.Reload
parse :: EventString -> Maybe ExCommand


module Yi.Keymap.Vim.Ex.Commands.Shell
parse :: EventString -> Maybe ExCommand


module Yi.Keymap.Vim.Ex.Commands.Sort
parse :: EventString -> Maybe ExCommand


module Yi.Keymap.Vim.Ex.Commands.Substitute
parse :: EventString -> Maybe ExCommand


module Yi.Keymap.Vim.Ex.Commands.Global
parse :: EventString -> Maybe ExCommand


module Yi.Keymap.Vim.Ex.Commands.Undo
parse :: EventString -> Maybe ExCommand


module Yi.Keymap.Vim.Ex.Commands.Write
parse :: EventString -> Maybe ExCommand


module Yi.Keymap.Vim.Ex.Commands.Yi
parse :: EventString -> Maybe ExCommand


module Yi.Keymap.Vim.Tag
completeVimTag :: Text -> YiM [Text]

-- | Opens the file that contains <tt>tag</tt>. Uses the global tag table
--   or uses the first valid tag file in <tt>TagsFileList</tt>.
gotoTag :: Tag -> Int -> Maybe (FilePath, Int, Int) -> YiM ()

-- | Goes to the next tag. (:tnext)
nextTag :: YiM ()

-- | Return to location from before last tag jump.
popTag :: YiM ()

-- | Go to next tag in the tag stack. Represents :tag without any specified
--   tag.
unpopTag :: YiM ()
instance Typeable VimTagStack
instance Generic VimTagStack
instance Datatype D1VimTagStack
instance Constructor C1_0VimTagStack
instance Selector S1_0_0VimTagStack
instance Selector S1_0_1VimTagStack
instance Binary VimTagStack
instance YiVariable VimTagStack
instance Default VimTagStack


module Yi.Keymap.Vim.NormalMap
defNormalMap :: [VimOperator] -> [VimBinding]
instance Eq EOLStickiness


-- | I'm a module waiting for some kind soul to give me a commentary!
module Yi.Keymap.Vim.VisualMap
defVisualMap :: [VimOperator] -> [VimBinding]


module Yi.Keymap.Vim.Ex.Commands.Tag
parse :: EventString -> Maybe ExCommand


module Yi.Keymap.Vim.Ex
exEvalE :: [EventString -> Maybe ExCommand] -> EventString -> EditorM ()
exEvalY :: [EventString -> Maybe ExCommand] -> EventString -> YiM ()
evStringToExCommand :: [EventString -> Maybe ExCommand] -> EventString -> Maybe ExCommand
data ExCommand
ExCommand :: YiM [Text] -> Bool -> Action -> Bool -> Text -> ExCommand
cmdComplete :: ExCommand -> YiM [Text]
cmdIsPure :: ExCommand -> Bool
cmdAction :: ExCommand -> Action
cmdAcceptsRange :: ExCommand -> Bool
cmdShow :: ExCommand -> Text
defExCommandParsers :: [EventString -> Maybe ExCommand]


-- | I'm a module waiting for some kind soul to give me a commentary!
module Yi.Keymap.Vim.ExMap
defExMap :: [EventString -> Maybe ExCommand] -> [VimBinding]


-- | The vim keymap.
module Yi.Keymap.Vim
keymapSet :: KeymapSet
mkKeymapSet :: Proto VimConfig -> KeymapSet
defVimConfig :: Proto VimConfig
data VimBinding
VimBindingY :: (EventString -> VimState -> MatchResult (YiM RepeatToken)) -> VimBinding
VimBindingE :: (EventString -> VimState -> MatchResult (EditorM RepeatToken)) -> VimBinding
data VimOperator
VimOperator :: !OperatorName -> (Int -> StyledRegion -> EditorM RepeatToken) -> VimOperator
operatorName :: VimOperator -> !OperatorName
operatorApplyToRegionE :: VimOperator -> Int -> StyledRegion -> EditorM RepeatToken
data VimConfig
VimConfig :: Keymap -> [VimBinding] -> [VimOperator] -> [EventString -> Maybe ExCommand] -> [(String, Char)] -> (Char -> Char) -> VimConfig
vimKeymap :: VimConfig -> Keymap
vimBindings :: VimConfig -> [VimBinding]
vimOperators :: VimConfig -> [VimOperator]
vimExCommandParsers :: VimConfig -> [EventString -> Maybe ExCommand]
vimDigraphs :: VimConfig -> [(String, Char)]
vimRelayout :: VimConfig -> Char -> Char
pureEval :: VimConfig -> EventString -> EditorM ()
impureEval :: VimConfig -> EventString -> Bool -> YiM ()
relayoutFromTo :: String -> String -> (Char -> Char)


-- | A mode for GHCi, implemented as tweaks on Interaction mode
module Yi.Mode.GHCi

-- | The process name to use to spawn GHCi.
data GhciProcessName
GhciProcessName :: FilePath -> [String] -> GhciProcessName

-- | Command to run when spawning GHCi.
_ghciProcessName :: GhciProcessName -> FilePath

-- | Args to pass to the process.
_ghciProcessArgs :: GhciProcessName -> [String]

-- | The process name defaults to <tt>ghci</tt>.
ghciProcessName :: Lens' GhciProcessName FilePath
ghciProcessArgs :: Lens' GhciProcessName [String]

-- | Setting this is a bit like '(setq haskell-program-name foo)' in emacs'
--   <tt>haskell-mode</tt>.

-- | Mode used for GHCi. Currently it just overrides <a>KHome</a> key to go
--   just before the prompt through the use of <a>homeKey</a>.
mode :: Mode (Tree (Tok Token))

-- | The GHCi prompt always begins with "&gt;"; this goes to just before
--   it, or if one is already at the start of the prompt, goes to the
--   beginning of the line. (If at the beginning of the line, this pushes
--   you forward to it.)
homeKey :: BufferM ()

-- | Spawns an interactive process (<a>Yi.Mode.Interactive</a>) with GHCi
--   <a>mode</a> over it.
spawnProcess :: FilePath -> [String] -> YiM BufferRef
instance YiVariable GhciProcessName
instance Typeable GhciProcessName
instance Show GhciProcessName
instance Generic GhciProcessName
instance Datatype D1GhciProcessName
instance Constructor C1_0GhciProcessName
instance Selector S1_0_0GhciProcessName
instance Selector S1_0_1GhciProcessName
instance Binary GhciProcessName
instance Default GhciProcessName


-- | Collection of <a>Mode</a>s for working with Haskell.
module Yi.Mode.Haskell

-- | General ‘template’ for actual Haskell modes.
--   
--   It applies over <tt>extensions = ["hs", "x", "hsc", "hsinc"]</tt>
--   which may be a little questionable but for now Yi is mostly used by
--   Haskell hackers so it should be fine, at least for now.
haskellAbstract :: Mode (tree TT)

-- | <a>Clever</a> haskell mode, using the paren-matching syntax.
cleverMode :: Mode (Tree (Tok Token))

-- | Experimental Haskell mode, using a rather precise parser for the
--   syntax.
preciseMode :: Mode (Tree TT)
literateMode :: Mode (Tree TT)
fastMode :: Mode (Tree TT)

-- | Return GHCi's buffer; create it if necessary. Show it in another
--   window.
ghciGet :: YiM BufferRef

-- | Send a command to GHCi
ghciSend :: String -> YiM ()

-- | Load current buffer in GHCi
ghciLoadBuffer :: YiM ()
ghciInferType :: YiM ()
ghciSetProcessName :: YiM ()
ghciSetProcessArgs :: YiM ()
instance Typeable GhciBuffer
instance Default GhciBuffer
instance Binary GhciBuffer
instance YiVariable GhciBuffer


module Yi.Mode.Haskell.Dollarify
dollarify :: Tree TT -> BufferM ()
dollarifyWithin :: Tree TT -> BufferM ()
data QueuedUpdate
QueuedUpdate :: Point -> YiString -> Int -> QueuedUpdate
qUpdatePoint :: QueuedUpdate -> Point
qInsert :: QueuedUpdate -> YiString
qDelete :: QueuedUpdate -> Int
runQ :: [QueuedUpdate] -> BufferM ()
openParen :: Token
closeParen :: Token
isNormalParen :: Tree TT -> Bool
isTuple :: Tree TT -> Bool
queueDelete :: TT -> QueuedUpdate
queueReplaceWith :: YiString -> TT -> QueuedUpdate
stripComments :: Expr TT -> Expr TT
dollarifyTop :: Tree TT -> [QueuedUpdate]
dollarifyExpr :: Expr TT -> [QueuedUpdate]
isSimple :: Tree TT -> Bool
isCollapsible :: Expr TT -> Bool
selectedTree :: Expr TT -> Region -> Maybe (Tree TT)
findLargestWithin :: Region -> [Tree TT] -> Tree TT
within :: Region -> Tree TT -> Bool
safeLast :: [a] -> Maybe a
dollarifyP :: Tree TT -> BufferM ()
dollarifyWithinP :: Exp TT -> BufferM ()
isNormalParenP :: Exp TT -> Bool
isTupleP :: Exp TT -> Bool
stripCommentsP :: [Exp TT] -> [Exp TT]
dollarifyTopP :: Exp TT -> [QueuedUpdate]
dollarifyExprP :: [Exp TT] -> [QueuedUpdate]
isSimpleP :: Exp TT -> Bool
isCollapsibleP :: [Exp TT] -> Bool
selectedTreeP :: [Exp TT] -> Region -> Maybe (Exp TT)
findLargestWithinP :: Region -> [Exp TT] -> Exp TT
withinP :: Region -> Exp TT -> Bool
safeLastP :: [a] -> Maybe a
instance Eq QueuedUpdate
instance Ord QueuedUpdate
instance Show QueuedUpdate


module Yi.Snippets
type SnippetCmd = RWST (Int, Int) [MarkInfo] () BufferM
data SnippetMark
SimpleMark :: !Int -> SnippetMark
ValuedMark :: !Int -> YiString -> SnippetMark
DependentMark :: !Int -> SnippetMark
data MarkInfo
SimpleMarkInfo :: !Int -> !Mark -> MarkInfo
userIndex :: MarkInfo -> !Int
startMark :: MarkInfo -> !Mark
ValuedMarkInfo :: !Int -> !Mark -> !Mark -> MarkInfo
userIndex :: MarkInfo -> !Int
startMark :: MarkInfo -> !Mark
endMark :: MarkInfo -> !Mark
DependentMarkInfo :: !Int -> !Mark -> !Mark -> MarkInfo
userIndex :: MarkInfo -> !Int
startMark :: MarkInfo -> !Mark
endMark :: MarkInfo -> !Mark
newtype BufferMarks
BufferMarks :: [MarkInfo] -> BufferMarks
bufferMarks :: BufferMarks -> [MarkInfo]
newtype DependentMarks
DependentMarks :: [[MarkInfo]] -> DependentMarks
marks :: DependentMarks -> [[MarkInfo]]
cursor :: Int -> SnippetMark
cursorWith :: Int -> YiString -> SnippetMark
dep :: Int -> SnippetMark
isDependentMark :: MarkInfo -> Bool
bufferMarkers :: MarkInfo -> [Mark]
class MkSnippetCmd a b | a -> b
mkSnippetCmd :: MkSnippetCmd a b => a -> SnippetCmd b
mkMark :: MonadTrans t => t BufferM Mark
text :: YiString -> SnippetCmd ()
(&) :: (MkSnippetCmd a any, MkSnippetCmd b c) => a -> b -> SnippetCmd c
(&>) :: (MkSnippetCmd a b, MkSnippetCmd c d) => a -> (b -> c) -> SnippetCmd d
runSnippet :: Bool -> SnippetCmd a -> BufferM a
updateUpdatedMarks :: [Update] -> BufferM ()
findEditedMarks :: [Update] -> BufferM [MarkInfo]
dependentSiblings :: MarkInfo -> [[MarkInfo]] -> [MarkInfo]
updateDependents :: MarkInfo -> BufferM ()
updateDependents' :: MarkInfo -> [[MarkInfo]] -> BufferM ()
markText :: MarkInfo -> BufferM YiString
setMarkText :: YiString -> MarkInfo -> BufferM ()
withSimpleRegion :: MarkInfo -> (Region -> BufferM Region) -> BufferM Region
markRegion :: MarkInfo -> BufferM Region
safeMarkRegion :: MarkInfo -> BufferM Region
adjMarkRegion :: MarkInfo -> BufferM Region
findOverlappingMarksWith :: (MarkInfo -> BufferM Region) -> ([[MarkInfo]] -> [MarkInfo]) -> Bool -> Region -> MarkInfo -> BufferM [MarkInfo]
findOverlappingMarks :: ([[MarkInfo]] -> [MarkInfo]) -> Bool -> Region -> MarkInfo -> BufferM [MarkInfo]
regionsOverlappingMarks :: Bool -> Region -> MarkInfo -> BufferM [MarkInfo]
overlappingMarks :: Bool -> Bool -> MarkInfo -> BufferM [MarkInfo]
allOverlappingMarks :: Bool -> MarkInfo -> BufferM [MarkInfo]
dependentOverlappingMarks :: Bool -> MarkInfo -> BufferM [MarkInfo]
nextBufferMark :: Bool -> BufferM (Maybe MarkInfo)
isDependentMarker :: (MonadState FBuffer m, Functor m) => Mark -> m Bool
safeDeleteMarkB :: Mark -> BufferM ()
moveToNextBufferMark :: Bool -> BufferM ()
newtype SupertabExt
Supertab :: (YiString -> Maybe (BufferM ())) -> SupertabExt
superTab :: MonadInteract m Action Event => Bool -> SupertabExt -> m ()

-- | Convert snippet description list into a SuperTab extension
fromSnippets :: Bool -> [(YiString, SnippetCmd ())] -> SupertabExt
snippet :: MkSnippetCmd a b => a -> SnippetCmd b
instance Typeable BufferMarks
instance Typeable DependentMarks
instance Eq MarkInfo
instance Show MarkInfo
instance Generic MarkInfo
instance Eq BufferMarks
instance Show BufferMarks
instance Monoid BufferMarks
instance Binary BufferMarks
instance Eq DependentMarks
instance Show DependentMarks
instance Monoid DependentMarks
instance Binary DependentMarks
instance Datatype D1MarkInfo
instance Constructor C1_0MarkInfo
instance Constructor C1_1MarkInfo
instance Constructor C1_2MarkInfo
instance Selector S1_0_0MarkInfo
instance Selector S1_0_1MarkInfo
instance Selector S1_1_0MarkInfo
instance Selector S1_1_1MarkInfo
instance Selector S1_1_2MarkInfo
instance Selector S1_2_0MarkInfo
instance Selector S1_2_1MarkInfo
instance Selector S1_2_2MarkInfo
instance Monoid SupertabExt
instance MkSnippetCmd SnippetMark ()
instance MkSnippetCmd (SnippetCmd a) a
instance MkSnippetCmd Text ()
instance MkSnippetCmd YiString ()
instance MkSnippetCmd String ()
instance Ord MarkInfo
instance YiVariable DependentMarks
instance YiVariable BufferMarks
instance Default DependentMarks
instance Default BufferMarks
instance Binary MarkInfo


module Yi.Snippets.Haskell
hsFunction :: SnippetCmd ()
hsClass :: SnippetCmd ()


-- | Utilities shared by various UIs
module Yi.UI.Utils
applyHeights :: Traversable t => [Int] -> t Window -> t Window
spliceAnnots :: [(Point, Char)] -> [Span String] -> [(Point, Char)]

-- | Turn a sequence of (from,style,to) strokes into a sequence of picture
--   points (from,style), taking special care to ensure that the points are
--   strictly increasing and introducing padding segments where neccessary.
--   Precondition: Strokes are ordered and not overlapping.
strokePicture :: [Span (Endo a)] -> [(Point, a -> a)]

-- | Paint the given stroke-picture on top of an existing picture
paintStrokes :: (a -> a) -> a -> [(Point, a -> a)] -> [(Point, a)] -> [(Point, a)]
paintPicture :: a -> [[Span (Endo a)]] -> [(Point, a)]
attributesPictureB :: UIStyle -> Maybe SearchExp -> Region -> [[Span StyleName]] -> BufferM [(Point, Attributes)]
attributesPictureAndSelB :: UIStyle -> Maybe SearchExp -> Region -> BufferM [(Point, Attributes)]

-- | Arrange a list of items in columns over maximum
--   <tt>maxNumberOfLines</tt> lines
arrangeItems :: [Text] -> Int -> Int -> [Text]

-- | Arrange a list of items in columns over <tt>numberOfLines</tt> lines.
--   
--   TODO: proper Text/YiString implementation
arrangeItems' :: [Text] -> Int -> Int -> (Int, [Text])

module Yi.UI.SimpleLayout
data Rect
Rect :: !Int -> !Int -> !Int -> !Int -> Rect
offsetX :: Rect -> !Int
offsetY :: Rect -> !Int
sizeX :: Rect -> !Int
sizeY :: Rect -> !Int
data Layout
Layout :: !Rect -> !(Map WindowRef Rect) -> !Rect -> Layout
tabbarRect :: Layout -> !Rect
windowRects :: Layout -> !(Map WindowRef Rect)
promptRect :: Layout -> !Rect
data Point2D
Point2D :: !Int -> !Int -> Point2D
pointCol :: Point2D -> !Int
pointRow :: Point2D -> !Int
data Size2D
Size2D :: !Int -> !Int -> Size2D
sizeWidth :: Size2D -> !Int
sizeHeight :: Size2D -> !Int
coordsOfCharacterB :: Size2D -> Point -> Point -> BufferM (Maybe Point2D)
layout :: Int -> Int -> Editor -> (Editor, Layout)
verticalOffsetsForWindows :: Int -> PointedList Window -> PointedList Int


-- | Tabs.
module Yi.UI.TabBar

-- | A TabDescr describes the properties of a UI tab independent of the
--   particular GUI in use.
data TabDescr
TabDescr :: Text -> Bool -> TabDescr
tabText :: TabDescr -> Text
tabInFocus :: TabDescr -> Bool
type TabBarDescr = PointedList TabDescr
tabBarDescr :: Editor -> TabBarDescr
tabAbbrevTitle :: Text -> Text
instance Show TabDescr
instance Eq TabDescr


-- | This module defines a user interface implemented using vty.
--   
--   Originally derived from: riot/UI.hs Copyright (c) Tuomo Valkonen 2004.
module Yi.UI.Vty
start :: UIBoot

module Yi.Config.Default
defaultConfig :: Config
availableFrontends :: [(String, UIBoot)]
defaultEmacsConfig :: Config
defaultVimConfig :: Config
defaultCuaConfig :: Config
toVimStyleConfig :: Config -> Config
toEmacsStyleConfig :: Config -> Config
toCuaStyleConfig :: Config -> Config


-- | This is the main module of Yi, called with configuration from the
--   user. Here we mainly process command line arguments.
module Yi.Main

-- | Static main. This is the front end to the statically linked
--   application, and the real front end, in a sense. <tt>dynamic_main</tt>
--   calls this after setting preferences passed from the boot loader.
main :: (Config, ConsoleConfig) -> Maybe Editor -> IO ()

-- | Transform the config with options
do_args :: Config -> [String] -> Either Err (Config, ConsoleConfig)

-- | Configuration information which can be set in the command-line, but
--   not in the user's configuration file.
data ConsoleConfig
ConsoleConfig :: [String] -> Bool -> IO FilePath -> ConsoleConfig
ghcOptions :: ConsoleConfig -> [String]
selfCheck :: ConsoleConfig -> Bool
userConfigDir :: ConsoleConfig -> IO FilePath
data Err
Err :: String -> ExitCode -> Err
instance Error Err


-- | Boot process of Yi.
--   
--   Uses Dyre to implement the XMonad-style dynamic reconfiguration.
module Yi.Boot

-- | Handy alias for <a>yiDriver</a>.
yi :: Config -> IO ()

-- | Used by both the yi executable and the custom yi that is built from
--   the user's configuration. The yi executable uses a default config.
yiDriver :: Config -> IO ()

-- | "reloads" the configuration
--   
--   Serializes the editor state and relaunches Yi using the serialized
--   state. The launch of Yi will result in recompilation of the user's
--   custom Yi. This, in effect, "reloads" the configuration.
reload :: YiM ()


-- | A simplified configuration interface for Yi.
--   
--   This module provides a simple configuration API, allowing users to
--   start with an initial configuration and imperatively (monadically)
--   modify it. Some common actions (keybindings, selecting modes, choosing
--   the frontend) have been given special commands (<a>globalBindKeys</a>,
--   <a>setFrontendPreferences</a>, <a>addMode</a>, and so on).
--   
--   A simple configuration might look like the following:
--   
--   <pre>
--   import Yi.Config.Simple
--   import qualified Yi.Mode.Haskell as Haskell
--   -- note: don't import <a>Yi</a>, or else there will be name clashes
--   
--   main = <a>configMain</a> <a>defaultEmacsConfig</a> $ do
--     <a>setFrontendPreferences</a> ["pango", "vty"]
--     <a>fontSize</a> <a>%=</a> <a>Just</a> 10
--     <a>modeBindKeys</a> Haskell.cleverMode (<a>metaCh</a> 'q' <a>?&gt;&gt;!</a> <a>reload</a>)
--     <a>globalBindKeys</a> (<a>metaCh</a> 'r' <a>?&gt;&gt;!</a> <a>reload</a>)
--   </pre>
--   
--   A lot of the fields here are specified with the <a>Field</a> type. To
--   write a field, use (<a>%=</a>). To read, use <tt>get</tt>. For
--   modification, use (<tt>modify</tt>). For example, the functions
--   <tt>foo</tt> and <tt>bar</tt> are equivalent:
--   
--   <pre>
--   foo = <tt>modify</tt> <a>layoutManagers</a> <a>reverse</a>
--   bar = do
--    lms &lt;- <tt>get</tt> <a>layoutManagers</a>
--    <a>layoutManagers</a> <a>%=</a> <a>reverse</a> lms
--   </pre>
module Yi.Config.Simple

-- | The configuration monad. Run it with <tt>configMain</tt>.
data ConfigM a

-- | Starts with the given initial config, makes the described
--   modifications, then starts yi.
configMain :: Config -> ConfigM () -> IO ()

-- | Fields that can be modified with all lens machinery.
type Field a = Lens' Config a

-- | Sets the frontend to the first frontend from the list which is
--   installed.
--   
--   Available frontends are a subset of: "vty", "pango", and "batch".
setFrontendPreferences :: [String] -> ConfigM ()

-- | Sets the frontend, if it is available.
setFrontend :: String -> ConfigM ()

-- | Adds the given key bindings to the `global keymap'. The bindings will
--   override existing bindings in the case of a clash.
globalBindKeys :: Keymap -> ConfigM ()

-- | <tt>modeBindKeys mode keys</tt> adds the keybindings in <tt>keys</tt>
--   to all modes with the same name as <tt>mode</tt>.
--   
--   As with <a>modifyMode</a>, a mode by the given name must already be
--   registered, or the function will have no effect, and issue a
--   command-line warning.
modeBindKeys :: Mode syntax -> Keymap -> ConfigM ()

-- | <tt>modeBindKeysByName name keys</tt> adds the keybindings in
--   <tt>keys</tt> to all modes with name <tt>name</tt> (if it is
--   registered). Consider using <a>modeBindKeys</a> instead.
modeBindKeysByName :: Text -> Keymap -> ConfigM ()

-- | Register the given mode. It will be preferred over any modes already
--   defined.
addMode :: Mode syntax -> ConfigM ()

-- | <tt>modifyMode mode f</tt> modifies all modes with the same name as
--   <tt>mode</tt>, using the function <tt>f</tt>.
--   
--   Note that the <tt>mode</tt> argument is only used by its
--   <a>modeName</a>. In particular, a mode by the given name must already
--   be registered, or this function will have no effect, and issue a
--   command-line warning.
--   
--   <pre>
--   <a>modifyMode</a> mode f = <a>modifyModeByName</a> (<a>modeName</a> mode) f
--   </pre>
modifyMode :: Mode syntax -> (forall syntax'. Mode syntax' -> Mode syntax') -> ConfigM ()

-- | <tt>modifyModeByName name f</tt> modifies the mode with name
--   <tt>name</tt> using the function <tt>f</tt>. Consider using
--   <a>modifyMode</a> instead.
modifyModeByName :: Text -> (forall syntax. Mode syntax -> Mode syntax) -> ConfigM ()

-- | The evaluator to use for <a>execEditorAction</a> and
--   <a>getAllNamesInScope</a>.
evaluator :: Field Evaluator

-- | Evaluator based on a fixed list of published actions. Has a few
--   differences from <tt>ghciEvaluator</tt>:
--   
--   <ul>
--   <li>expressions can't be evaluated</li>
--   <li>all suggested actions are actually valued</li>
--   <li>(related to the above) doesn't contain junk actions from
--   Prelude</li>
--   <li>doesn't require GHCi backend, so uses less memory</li>
--   </ul>
publishedActionsEvaluator :: Evaluator

-- | Publish the given action, by the given name. This will overwrite any
--   existing actions by the same name.
publishAction :: (YiAction a x, Show x) => String -> a -> ConfigM ()

-- | Accessor for the published actions. Consider using
--   <a>publishAction</a>.
publishedActions :: Field (HashMap String Action)

-- | <a>Just</a> the font name, or <a>Nothing</a> for default.
fontName :: Field (Maybe String)

-- | <a>Just</a> the font size, or <a>Nothing</a> for default.
fontSize :: Field (Maybe Int)

-- | Amount to move the buffer when using the scroll wheel.
scrollWheelAmount :: Field Int

-- | <a>Just</a> the scroll style, or <a>Nothing</a> for default.
scrollStyle :: Field (Maybe ScrollStyle)
data ScrollStyle
SnapToCenter :: ScrollStyle
SingleLine :: ScrollStyle

-- | See <a>CursorStyle</a> for documentation.
cursorStyle :: Field CursorStyle

-- | When should we use a "fat" cursor (i.e. 2 pixels wide, rather than 1)?
--   Fat cursors have only been implemented for the Pango frontend.
data CursorStyle
AlwaysFat :: CursorStyle
NeverFat :: CursorStyle
FatWhenFocused :: CursorStyle
FatWhenFocusedAndInserting :: CursorStyle
data Side
LeftSide :: Side
RightSide :: Side

-- | Which side to display the scroll bar on.
scrollBarSide :: Field Side

-- | Should the scroll bar autohide?
autoHideScrollBar :: Field Bool

-- | Should the tab bar autohide?
autoHideTabBar :: Field Bool

-- | Should lines be wrapped?
lineWrap :: Field Bool

-- | The character with which to fill empty window space. Usually '~' for
--   vi-like editors, ' ' for everything else.
windowFill :: Field Char

-- | UI colour theme.
theme :: Field Theme

-- | List of registered layout managers. When cycling through layouts, this
--   list will be consulted.
layoutManagers :: Field [AnyLayoutManager]

-- | Produce a .yi.dbg file with debugging information?
debug :: Field Bool

-- | Run when the editor is started (this is run after all actions which
--   have already been registered)
runOnStartup :: Action -> ConfigM ()

-- | Run after the startup actions have completed, or on reload (this is
--   run after all actions which have already been registered)
runAfterStartup :: Action -> ConfigM ()

-- | Actions to run when the editor is started. Consider using
--   <a>runOnStartup</a> or <a>runManyOnStartup</a> instead.
startActions :: Field [Action]

-- | Actions to run after startup or reload. Consider using
--   <a>runAfterStartup</a> or <a>runManyAfterStartup</a> instead.
initialActions :: Field [Action]

-- | Default keymap to use.
defaultKm :: Field KeymapSet

-- | ?
inputPreprocess :: Field (P Event Event)

-- | List of modes by order of preference. Consider using <a>addMode</a>,
--   <a>modeBindKeys</a>, or <a>modifyMode</a> instead.
modes :: Field [AnyMode]

-- | Set to <a>Exclusive</a> for an emacs-like behaviour. Consider starting
--   with <a>defaultEmacsConfig</a>, <a>defaultVimConfig</a>, or
--   <a>defaultCuaConfig</a> to instead.
regionStyle :: Field RegionStyle

-- | Set to <a>True</a> for an emacs-like behaviour, where all deleted text
--   is accumulated in a killring. Consider starting with
--   <a>defaultEmacsConfig</a>, <a>defaultVimConfig</a>, or
--   <a>defaultCuaConfig</a> instead.
killringAccumulate :: Field Bool

-- | ?
bufferUpdateHandler :: Field [[Update] -> BufferM ()]


-- | Facade of the Yi library, for use by confguration file. Just
--   re-exports a bunch of modules.
--   
--   You should therefore:
--   
--   <pre>
--   import Yi
--   </pre>
--   
--   in your <tt>~<i>.config</i>yi/yi.hs</tt>.
module Yi
