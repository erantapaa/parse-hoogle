-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Pure Haskell PostScript and SVG generation.
--   
--   Wumpus-Core is a low-level library for generating static 2D vector
--   pictures, its salient feature is portability due to no FFI
--   dependencies. It can generate PostScript (EPS) files and SVG files.
--   The generated PostScript code is plain and someways efficient as the
--   use of stack operations, i.e <tt>gsave</tt> and <tt>grestore</tt>, is
--   minimized (unfortunately there is no sharing so the generated
--   PostScript can be huge...).
--   
--   Although Wumpus-Core only generates vector output, the generated
--   PostScript can be interpreted by GraphicsMagick or a similar tool to
--   convert EPS files into bitmap image files (e.g JPEGs).
--   
--   Wumpus-Core makes pictures from <i>paths</i> and text <i>labels</i>.
--   Paths themselves are made from points. The usual affine
--   transformations (rotations, scaling, translations) can be applied to
--   Pictures. Unlike PostScript there is no notion of a current point,
--   Wumpus-Core builds pictures by direct positioning of each element.
--   
--   GENERAL DRAWBACKS...
--   
--   For actually building pictures, diagrams, etc. Wumpus-Core is very
--   low-level. There are two supplementary packages <tt>Wumpus-Basic</tt>
--   and <tt>Wumpus-Drawing</tt> also on Hackage that aim to be a
--   higher-level basis for creating certain types of diagram, but they are
--   experimental - functionality is added and dropped between releases and
--   curently the API is too unstable to write code upon (they should be
--   considered a technology preview rather than re-usable libraries).
--   
--   Also, some of the design decisions made for Wumpus-Core are not
--   sophisticated - e.g. how path and text attributes like colour are
--   handled, and how the bounding boxes of text labels are calculated.
--   Compared to other systems, Wumpus might be rather limited, however,
--   the design permits a fairly simple implementation.
--   
--   Changelog:
--   
--   v0.52.0 to v0.52.1:
--   
--   <ul>
--   <li>Removed internal <tt>(<a></a>)</tt> format combinator that caused
--   problems for GHC 7.4.</li>
--   </ul>
--   
--   v0.51.0 to v0.52.0:
--   
--   <ul>
--   <li>Added limited support for adding SVG ids to text and
--   Primitives.</li>
--   <li>Fixed types of <tt>d2r</tt> and <tt>r2d</tt> to Double for
--   degrees, rather than a parametric (Real a, Floating a) type. Although
--   this is less general, it removes the burden of type annotating the
--   common case.</li>
--   <li>Added the vector functions <tt>orthoVec</tt>, <tt>vsum</tt> and
--   <tt>vdiff</tt> to <tt>Core.Geometry</tt>.</li>
--   <li>Re-named <tt>clip</tt> to <tt>clipPrimitive</tt></li>
--   </ul>
--   
--   v0.50.0 to v0.51.0:
--   
--   <ul>
--   <li>Added special cases to handle continuity to the function
--   <tt>lineDirection</tt> in <tt>Core.Geometry</tt>.</li>
--   <li>Added <tt>zeroVec</tt> to <tt>Core.Geometry</tt>.</li>
--   <li>Extended some Haddock documentation.</li>
--   </ul>
--   
--   v0.43.0 to v0.50.0:
--   
--   <ul>
--   <li>Major change hence the version number jump - the notion of
--   parametric unit has been removed from the <tt>Picture</tt> objects (it
--   for remains the <tt>Geometric</tt> objects <tt>Point2</tt>,
--   <tt>Vec2</tt> etc.). Certain useful units, e.g. <tt>em</tt> and
--   <tt>en</tt>, are contextual on the "current point size", and having a
--   parametric unit here was actually a hinderance to supporting units
--   properly in higher-level layers. Now all Picture objects (those
--   defined or exported from <tt>Core.Picture</tt>) are fixed to use
--   Double - representing PostScript points. Higher level layers that
--   intend to support alternative units must translate drawing objects to
--   PostScript point measurements <i>before</i> calling the Picture API.
--   Geometric objects - objects defined in <tt>Core.Geometry</tt>, e.g.
--   <tt>Point2</tt>, <tt>Vec2</tt> - are still polymorphic on unit.</li>
--   <li>Picture API change - Various function names changed.
--   <tt>lineTo</tt> becomes <tt>absLineTo</tt> and <tt>curveTo</tt>
--   becomes <tt>absCurveTo</tt>. The path builders are qualified with
--   <i>Prim</i>, <tt>vertexPath</tt> becomes <tt>vertexPrimPath</tt>,
--   <tt>vectorPath</tt> becomes <tt>vectorPrimPath</tt>,
--   <tt>emptyPath</tt> becomes <tt>emptyPrimPath</tt> and
--   <tt>curvedPath</tt> becomes <tt>curvedPrimPath</tt>. <tt>xlink</tt>
--   becomes <tt>xlinkPrim</tt>.</li>
--   <li>API change - <tt>PtSize</tt> data type replaced by
--   <tt>AfmUnit</tt> for font measurements.</li>
--   <li>API and representation change - clipping paths are represented as
--   <tt>Primitive</tt> constructor rather than a <tt>Picture</tt>
--   constructor. This should make them more useful. The type of the
--   function <tt>clip</tt> in <tt>Core.Picture</tt> has likewise
--   changed.</li>
--   <li>Picture API change - changed <tt>primPath</tt> to
--   <tt>absPrimPath</tt>, added the functions <tt>relPrimPath</tt>,
--   <tt>relLineTo</tt>, <tt>relCurveTo</tt>.</li>
--   <li>Added the class <tt>Tolerance</tt> to <tt>Core.Geometry</tt> and
--   made the Eq instances of <tt>Point2</tt>, <tt>Vec2</tt> and
--   <tt>BoundingBox</tt> tolerant. Tolerance accounts for a fairly lax
--   equality on floating point numbers - it is suitable for Wumpus
--   (printing) where high accuracy is needed.</li>
--   </ul>
--   
--   v0.42.1 to v0.43.0:
--   
--   <ul>
--   <li>API change - the function <tt>bezierCircle</tt> in
--   <tt>Core.Geometry</tt> has changed. It now implements a better method
--   of drawing circles with Bezier curves and no longer needs the
--   subvision factor. The old circle drawing function has been retained as
--   <tt>subdivisionCircle</tt> as it is useful for corroborating
--   <tt>bezierCircle</tt>, but the general use of
--   <tt>subdivisionCircle</tt> should be avoided.</li>
--   <li>Added a function <tt>bezierEllipse</tt> to
--   <tt>Core.Geometry</tt>.</li>
--   </ul>
@package wumpus-core
@version 0.52.1


-- | Map of PostScript glyph names to Unicode code points.
--   
--   ** This file is auto-generated. **
--   
--   Generated - 2010-11-13 15:30
module Wumpus.Core.Text.GlyphIndices

-- | Lookup table mapping from PostScript glyph name to the corresponding
--   Unicode code point.
ps_glyph_indices :: Map String Int


-- | Map of Unicode code points to PostScript glyph names.
--   
--   ** This file is auto-generated. **
--   
--   Generated - 2010-11-13 15:30
module Wumpus.Core.Text.GlyphNames

-- | Index table mapping from Unicode code point to the corresponding
--   PostScript name defined by the Adobe glyphlist.
ps_glyph_names :: IntMap String


-- | Version number.
module Wumpus.Core.VersionNumber

-- | Version number.
--   
--   <pre>
--   (0,52,1)
--   </pre>
wumpus_core_version :: (Int, Int, Int)


-- | Extended character code handling.
--   
--   Wumpus uses an escaping style derived from SVG to embed character
--   codes and PostScript glyph names in regular strings.
--   
--   <pre>
--   "regular ascii text &amp;#38; more ascii text"
--   </pre>
--   
--   i.e. character codes are delimited by <tt>&amp;#</tt> on the left and
--   <tt>;</tt> on the right.
--   
--   Glyph names are delimited by <tt>&amp;</tt> on the left and <tt>;</tt>
--   on the right.
--   
--   <pre>
--   "regular ascii text &amp;ampersand; more ascii text"
--   </pre>
--   
--   Note that glyph names ** <i>should always</i> ** correspond to
--   PostScript glyph names not SVG / HTML glyph names.
--   
--   In Wumpus both glyph names and character codes can be embedded in
--   strings - (e.g. <tt>&amp;egrave;</tt> or <tt>&amp;#232;</tt>) although
--   glyph names are preferred for PostScript (see below).
--   
--   Character codes can be also be expressed as octal or hexadecimal
--   numbers:
--   
--   <pre>
--   myst&amp;#0o350;re
--   </pre>
--   
--   <pre>
--   myst&amp;#0xE8;re
--   </pre>
--   
--   In the generated PostScript, Wumpus uses the character name, e.g.:
--   
--   <pre>
--   (myst) show /egrave glyphshow (re) show
--   </pre>
--   
--   The generated SVG uses the numeric code, e.g.:
--   
--   <pre>
--   myst&amp;#232;re
--   </pre>
--   
--   Unless you are generating only SVG, you should favour glyph names
--   rather than code points as they are unambiguously interpreted by
--   Wumpus. Character codes are context-dependent on the encoding of the
--   font used to render the text. <i>Standard</i> fonts (e.g. Helvetica,
--   Times, Courier) use the Standard Encoding is which has some
--   differences to the common Latin1 character set.
--   
--   Unfortunately if a glyph is not present in a font it cannot be
--   rendered in PostScript. Wumpus-Core is oblivious to the contents of
--   fonts, it does not warn about missing glyphs or attempt to substitute
--   them.
module Wumpus.Core.Text.Base

-- | Internal string representation for Wumpus-Core.
--   
--   <a>EscapedText</a> is a list of characters, where each character may
--   be either a regular character, an integer representing a Unicode
--   code-point or a PostScript glyph name.
data EscapedText

-- | Internal character representation for Wumpus-Core.
--   
--   An <a>EscapedChar</a> may be either a regular character, an integer
--   representing a Unicode code-point or a PostScript glyph name.
--   
--   PostScript glyph names are generally made up only of chars
--   <tt>[a-zA-Z]</tt>.
data EscapedChar
CharLiteral :: Char -> EscapedChar
CharEscInt :: Int -> EscapedChar
CharEscName :: String -> EscapedChar

-- | <tt>EncodingVecor</tt> - a map from code point to PostScript glyph
--   name.
type EncodingVector = IntMap String

-- | <a>escapeString</a> input is regular text and escaped glyph names or
--   decimal character codes. Escaping in the input string should follow
--   the SVG convention - the escape sequence starts with <tt>&amp;</tt>
--   (ampresand) for glyph names or <tt>&amp;#</tt> (ampersand hash) for
--   char codes and ends with <tt>;</tt> (semicolon).
--   
--   Escaped characters are output to PostScript as their respective glyph
--   names:
--   
--   <pre>
--   /egrave glyphshow
--   </pre>
--   
--   Escaped chararacters are output to SVG as an escaped decimal, e.g.:
--   
--   <pre>
--   &amp;#232;
--   </pre>
--   
--   Note - for SVG output, Wumpus automatically escapes characters where
--   the char code is above 128. This is the convention used by the
--   <tt>Text.XHtml</tt> library.
escapeString :: String -> EscapedText

-- | Build an <a>EscapedText</a> from a single <tt>EscChar</tt>.
wrapEscChar :: EscapedChar -> EscapedText

-- | <i>Destructor</i> for <a>EscapedText</a>.
destrEscapedText :: ([EscapedChar] -> a) -> EscapedText -> a

-- | Get the character count of an <a>EscapedText</a> string.
textLength :: EscapedText -> Int
instance Eq EscapedChar
instance Show EscapedChar
instance Monoid EscapedText
instance Format EscapedChar
instance Format EscapedText
instance Show EscapedText
instance Eq EscapedText


-- | Encoding vector for the Standard Encoding.
--   
--   ** This file is auto-generated. **
--   
--   Generated - 2010-11-17 15:24
module Wumpus.Core.Text.StandardEncoding

-- | Table mapping character numbers to glyph names for the Standard
--   Encoding.
standard_encoding :: EncodingVector


-- | Encoding vector for the Latin1 Encoding.
--   
--   ** This file is auto-generated. **
--   
--   Generated - 2010-11-17 15:24
module Wumpus.Core.Text.Latin1Encoding

-- | Table mapping character numbers to glyph names for the Latin1
--   Encoding.
latin1_encoding :: EncodingVector


-- | Encoding vector for the Symbol font.
--   
--   ** This file is auto-generated. **
--   
--   Generated - 2010-11-17 15:24
module Wumpus.Core.Text.Symbol

-- | Table mapping character numbers to glyph names for the Symbol font.
symbol_encoding :: EncodingVector


-- | Objects and operations for 2D geometry.
--   
--   Vector, point, 3x3 matrix, and radian representations, plus a type
--   family <tt>DUnit</tt> for parameterizing type classes with some
--   <i>dimension</i>.
module Wumpus.Core.Geometry

-- | Some unit of dimension usually Double.
--   
--   This very useful for reducing the kind of type classes to *.
--   
--   Then constraints on the Unit type can be declared on the instances
--   rather than in the class declaration.

-- | Class for tolerance on floating point numbers.
--   
--   Two tolerances are required tolerance for equality - commonly used for
--   testing if two points are equal - and tolerance for path length
--   measurement.
--   
--   Path length measurement in Wumpus does not have a strong need to be
--   exact (precision is computational costly) - by default it is 100x the
--   equality tolerance.
--   
--   Bezier path lengths are calculated by iteration, so greater accuracy
--   requires more compution. As it is hard to visually differentiate
--   measures of less than a point the tolerance for Points is quite high
--   quite high (0.1).
--   
--   The situation is more complicated for contextual units (Em and En) as
--   they are really scaling factors. The bigger the point size the less
--   accurate the measure is.
class Num u => Tolerance u where length_tolerance = 100 * eq_tolerance
eq_tolerance :: Tolerance u => u
length_tolerance :: Tolerance u => u

-- | 2D Vector - both components are strict.
--   
--   Note - equality is defined with <a>Tolerance</a> and tolerance is
--   quite high for the usual units. See the note for <a>Point2</a>.
data Vec2 u
V2 :: !u -> !u -> Vec2 u
vector_x :: Vec2 u -> !u
vector_y :: Vec2 u -> !u
type DVec2 = Vec2 Double

-- | 2D Point - both components are strict.
--   
--   Note - equality is defined with <a>Tolerance</a> and tolerance is
--   quite high for the usual units.
--   
--   This is useful for drawing, *but* unacceptable data centric work. If
--   more accurate equality is needed define a newtype wrapper over the
--   unit type and make a <tt>Tolerance</tt> instance with much greater
--   accuracy.
data Point2 u
P2 :: !u -> !u -> Point2 u
point_x :: Point2 u -> !u
point_y :: Point2 u -> !u
type DPoint2 = Point2 Double

-- | 3x3 matrix, considered to be in row-major form.
--   
--   <pre>
--   (M3'3 a b c
--         d e f
--         g h i)
--   </pre>
--   
--   For instance the rotation matrix is represented as
--   
--   <pre>
--   ( cos(a) -sin(a) 0
--     sin(a)  cos(a) 0  
--       0         0  1 )
--   </pre>
--   
--   This seems commplace in geometry texts, but PostScript represents the
--   <tt>current-transformation-matrix</tt> in column-major form.
--   
--   The right-most column is considered to represent a coordinate:
--   
--   <pre>
--   ( 1 0 x
--     0 1 y  
--     0 0 1 ) 
--   </pre>
--   
--   So a translation matrix representing the displacement in x of 40 and
--   in y of 10 would be:
--   
--   <pre>
--   ( 1 0 40
--     0 1 10  
--     0 0 1  ) 
--   </pre>
data Matrix3'3 u
M3'3 :: !u -> !u -> !u -> !u -> !u -> !u -> !u -> !u -> !u -> Matrix3'3 u
type DMatrix3'3 = Matrix3'3 Double

-- | Radian is represented with a distinct type. Equality and ordering are
--   approximate where the epsilon is 0.0001.
data Radian

-- | Matrix multiplication - typically of points and vectors represented as
--   homogeneous coordinates.
class MatrixMult t
(*#) :: (MatrixMult t, Num u) => Matrix3'3 u -> t u -> t u

-- | Tolerant equality - helper function for defining Eq instances that use
--   tolerance.
--   
--   Note - the definition actually needs Ord which is unfortunate (as Ord
--   is <i>inaccurate</i>).
tEQ :: (Tolerance u, Ord u) => u -> u -> Bool

-- | Tolerant greater than.
--   
--   Note - the definition actually needs Ord which is unfortunate (as Ord
--   is <i>inaccurate</i>).
tGT :: (Tolerance u, Ord u) => u -> u -> Bool

-- | Tolerant less than.
--   
--   Note - the definition actually needs Ord which is unfortunate (as Ord
--   is <i>inaccurate</i>).
tLT :: (Tolerance u, Ord u) => u -> u -> Bool

-- | Tolerant greater than or equal.
--   
--   Note - the definition actually needs Ord which is unfortunate (as Ord
--   is <i>inaccurate</i>).
tGTE :: (Tolerance u, Ord u) => u -> u -> Bool

-- | Tolerant less than or equal.
--   
--   Note - the definition actually needs Ord which is unfortunate (as Ord
--   is <i>inaccurate</i>).
tLTE :: (Tolerance u, Ord u) => u -> u -> Bool

-- | Tolerant <tt>compare</tt>.
tCompare :: (Tolerance u, Ord u) => u -> u -> Ordering

-- | Construct a the empty vector (0,0).
--   
--   Note - this is equivalent to <tt>zeroV</tt> in
--   <tt>Data.AdditiveGroup</tt>. It is provided here for convenience as it
--   may save an extra module import in client code.
zeroVec :: Num u => Vec2 u

-- | <a>vec</a> : <tt> x_component * y_component -&gt; Vec2 </tt>
--   
--   A synonym for the constructor <a>V2</a> with a Num constraint on the
--   arguments.
--   
--   Essentially this function is superfluous, but it is slightly more
--   pleasant typographically when used in lists of vectors:
--   
--   <pre>
--   [ vec 2 2, vvec 4, hvec 4, vec 2 2 ]
--   </pre>
--   
--   Versus:
--   
--   <pre>
--   [ V2 2 2, vvec 4, hvec 4, V2 2 2 ]
--   </pre>
vec :: Num u => u -> u -> Vec2 u

-- | <a>hvec</a> : <tt> x_component -&gt; Vec2 </tt>
--   
--   Construct a vector with horizontal displacement.
hvec :: Num u => u -> Vec2 u

-- | <a>vvec</a> <tt> y_component -&gt; Vec2 </tt>
--   
--   Construct a vector with vertical displacement.
vvec :: Num u => u -> Vec2 u

-- | <a>avec</a> : <tt> angle * distance -&gt; Vec2 </tt>
--   
--   Construct a vector from an angle and magnitude.
avec :: Floating u => Radian -> u -> Vec2 u

-- | <a>pvec</a> : <tt> point_from * point_to -&gt; Vec2 </tt>
--   
--   The vector between two points
--   
--   <pre>
--   pvec = flip (.-.)
--   </pre>
pvec :: Num u => Point2 u -> Point2 u -> Vec2 u

-- | Build a vector form its parallel and perpendicular components and
--   inclination.
orthoVec :: Floating u => u -> u -> Radian -> Vec2 u

-- | <a>vreverse</a> : <tt> vec -&gt; Vec2 </tt>
--   
--   Reverse a vector.
vreverse :: Num u => Vec2 u -> Vec2 u

-- | <a>vdirection</a> : <tt> vec -&gt; Radian </tt>
--   
--   Direction of a vector - i.e. the counter-clockwise angle from the
--   x-axis.
vdirection :: (Floating u, Real u) => Vec2 u -> Radian

-- | <a>vlength</a> : <tt> vec -&gt; Length </tt>
--   
--   Length of a vector.
vlength :: Floating u => Vec2 u -> u

-- | <a>vangle</a> : <tt> vec1 * vec2 -&gt; Radian </tt>
--   
--   Extract the angle between two vectors.
vangle :: (Floating u, Real u, InnerSpace (Vec2 u)) => Vec2 u -> Vec2 u -> Radian

-- | Sum a list of Vectors.
vsum :: Num u => [Vec2 u] -> Vec2 u

-- | Find the <i>difference</i> between two vectors - i.e. flipped vector
--   subtraction:
--   
--   <pre>
--   vdiff = flip (^-^)
--   </pre>
vdiff :: Num u => Vec2 u -> Vec2 u -> Vec2 u

-- | Construct a point at (0,0).
zeroPt :: Num u => Point2 u

-- | <a>minPt</a> : <tt> point1 * point2 -&gt; Point2 </tt>
--   
--   Synthetic, <i>component-wise</i> min on points. Standard <a>min</a>
--   and <a>max</a> via Ord are defined lexographically on pairs, e.g.:
--   
--   <pre>
--   min (1,2) (2,1) = (1,2)
--   </pre>
--   
--   For Points we want the component-wise min and max, that potentially
--   synthesizes a new point, e.g:
--   
--   <pre>
--   minPt (P2 1 2) (Pt 2 1) = Pt 1 1 
--   maxPt (P2 1 2) (Pt 2 1) = Pt 2 2
--   </pre>
minPt :: Ord u => Point2 u -> Point2 u -> Point2 u

-- | <a>maxPt</a> : <tt> point1 * point2 -&gt; Point </tt>
--   
--   Synthetic, <i>component-wise</i> max on points.
--   
--   <pre>
--   maxPt (P2 1 2) (Pt 2 1) = Pt 2 2
--   </pre>
maxPt :: Ord u => Point2 u -> Point2 u -> Point2 u

-- | <a>lineDirection</a> : <tt> start_point * end_point -&gt; Radian </tt>
--   
--   Calculate the counter-clockwise angle between two points and the
--   x-axis.
lineDirection :: (Floating u, Real u) => Point2 u -> Point2 u -> Radian

-- | Construct the identity matrix:
--   
--   <pre>
--   (M3'3 1 0 0
--         0 1 0
--         0 0 1 )
--   </pre>
identityMatrix :: Num u => Matrix3'3 u

-- | <a>scalingMatrix</a> : <tt> x_scale_factor * y_scale_factor -&gt;
--   Matrix </tt>
--   
--   Construct a scaling matrix:
--   
--   <pre>
--   (M3'3 sx 0  0
--         0  sy 0
--         0  0  1 )
--   </pre>
scalingMatrix :: Num u => u -> u -> Matrix3'3 u

-- | <a>translationMatrix</a> : <tt> x_displacement * y_displacement -&gt;
--   Matrix </tt>
--   
--   Construct a translation matrix:
--   
--   <pre>
--   (M3'3 1  0  x
--         0  1  y
--         0  0  1 )
--   </pre>
translationMatrix :: Num u => u -> u -> Matrix3'3 u

-- | <a>rotationMatrix</a> : <tt> ang -&gt; Matrix </tt>
--   
--   Construct a rotation matrix:
--   
--   <pre>
--   (M3'3 cos(a)  -sin(a)  0
--         sin(a)   cos(a)  0
--         0        0       1 )
--   </pre>
rotationMatrix :: (Floating u, Real u) => Radian -> Matrix3'3 u

-- | <a>originatedRotationMatrix</a> : <tt> ang * point -&gt; Matrix </tt>
--   
--   Construct a matrix for rotation about some <i>point</i>.
--   
--   This is the product of three matrices: T R T^-1
--   
--   (T being the translation matrix, R the rotation matrix and T^-1 the
--   inverse of the translation matrix).
originatedRotationMatrix :: (Floating u, Real u) => Radian -> (Point2 u) -> Matrix3'3 u

-- | Invert a matrix.
invert :: Fractional u => Matrix3'3 u -> Matrix3'3 u

-- | Determinant of a matrix.
determinant :: Num u => Matrix3'3 u -> u

-- | Transpose a matrix.
transpose :: Matrix3'3 u -> Matrix3'3 u

-- | Convert to radians.
toRadian :: Real a => a -> Radian

-- | Convert from radians.
fromRadian :: Fractional a => Radian -> a

-- | Degrees to radians.
--   
--   Degree type fixed to <tt>Double</tt>, compose <tt>d2r</tt> with
--   <tt>realToFrac</tt> for <tt>Float</tt> etc.
d2r :: Double -> Radian

-- | Radians to degrees.
--   
--   Degree type fixed to <tt>Double</tt>, compose <tt>r2d</tt> with
--   <tt>realToFrac</tt> for <tt>Float</tt> etc.
r2d :: Radian -> Double

-- | Modulo a (positive) angle into the range <tt>0..2*pi</tt>.
circularModulo :: Radian -> Radian

-- | <a>bezierCircle</a> : <tt> radius * center -&gt; [Point] </tt>
--   
--   Make a circle from four Bezier curves. Although this function produces
--   an approximation of a circle, the approximation seems fine in
--   practice.
bezierCircle :: (Fractional u, Floating u) => u -> Point2 u -> [Point2 u]

-- | <a>bezierEllipse</a> : <tt> x_radius * y_radius * center -&gt; [Point]
--   </tt>
--   
--   Make an ellipse from four Bezier curves. Although this function
--   produces an approximation of a ellipse, the approximation seems fine
--   in practice.
bezierEllipse :: (Fractional u, Floating u) => u -> u -> Point2 u -> [Point2 u]

-- | <a>rbezierEllipse</a> : <tt> x_radius * y_radius * center * angle
--   -&gt; [Point] </tt>
--   
--   Make an rotated ellipse from four Bezier curves.
--   
--   Although this function produces an approximation of a ellipse, the
--   approximation seems fine in practice.
rbezierEllipse :: (Real u, Floating u) => u -> u -> Radian -> Point2 u -> [Point2 u]

-- | <a>bezierArc</a> : <tt> radius * ang1 * ang2 * center -&gt;
--   (start_point, control_point1, control_point2, end_point) </tt>
--   
--   Create an arc - this construction is the analogue of PostScript's
--   <tt>arc</tt> command, but the arc is created as a Bezier curve so it
--   should span less than 90deg.
--   
--   CAVEAT - ang2 must be greater than ang1
bezierArc :: Floating u => u -> Radian -> Radian -> Point2 u -> (Point2 u, Point2 u, Point2 u, Point2 u)

-- | <tt>subvisionCircle</tt> : <tt> subdivisions * radius * center -&gt;
--   [Point] </tt>
--   
--   Make a circle from Bezier curves - the number of subdivsions controls
--   the accuracy or the curve, more subdivisions produce better curves,
--   but less subdivisions are better for rendering (producing more
--   efficient PostScript).
--   
--   Before revision 0.43.0, this was the only method in Wumpus to draw
--   Bezier circles in Wumpus. However the kappa method seems to draw
--   equally good circles and is more efficient both in the Haskell
--   implementation and the generated PostScript code. This function is
--   retained for completeness and testing.
subdivisionCircle :: (Fractional u, Floating u) => Int -> u -> Point2 u -> [Point2 u]
instance Show u => Show (Vec2 u)
instance Show u => Show (Point2 u)
instance Eq u => Eq (Matrix3'3 u)
instance Num Radian
instance Real Radian
instance Fractional Radian
instance Floating Radian
instance RealFrac Radian
instance RealFloat Radian
instance MatrixMult Point2
instance MatrixMult Vec2
instance Num u => VectorSpace (Matrix3'3 u)
instance Num u => AdditiveGroup (Matrix3'3 u)
instance Num u => AffineSpace (Point2 u)
instance (Num u, InnerSpace u, u ~ Scalar u) => InnerSpace (Vec2 u)
instance Num u => VectorSpace (Vec2 u)
instance Num u => AdditiveGroup (Vec2 u)
instance Format Radian
instance Format u => Format (Matrix3'3 u)
instance Format u => Format (Point2 u)
instance Format u => Format (Vec2 u)
instance Ord Radian
instance Eq Radian
instance Show Radian
instance Num u => Num (Matrix3'3 u)
instance Show u => Show (Matrix3'3 u)
instance Functor Matrix3'3
instance Functor Point2
instance Functor Vec2
instance (Tolerance u, Ord u) => Ord (Point2 u)
instance (Tolerance u, Ord u) => Ord (Vec2 u)
instance (Tolerance u, Ord u) => Eq (Point2 u)
instance (Tolerance u, Ord u) => Eq (Vec2 u)
instance Tolerance Double


-- | Colour represented as RGB with each component in the range [0..255].
--   
--   Note - the predefined colours are hidden when importing the
--   <i>top-level</i> shim module <tt>Wumpus.Core</tt>, import
--   <tt>Wumpus.Core.Colour</tt> directly to use them.
--   
--   PostScript has no support for RGB-alpha and hence does not support
--   transparency. Thus Wumpus in turn cannot support transparency.
module Wumpus.Core.Colour

-- | Colours levels are in the range [0..255]
--   
--   Note - this is the format used by SVG, whereas PostScript uses [0..1].
--   
--   It is more efficient to prefer SVG here.
data RGBi
RGBi :: !Word8 -> !Word8 -> !Word8 -> RGBi

-- | Black - 0, 0, 0.
black :: RGBi

-- | White - 255, 255, 255.
white :: RGBi

-- | Red - 255, 0, 0.
red :: RGBi

-- | Green - 0, 255, 0.
green :: RGBi

-- | Blue - 0, 0, 255.
blue :: RGBi

-- | Yellow - 255, 255, 0.
yellow :: RGBi

-- | Cyan - 0, 255, 255.
cyan :: RGBi

-- | Magenta - 255, 0, 255.
magenta :: RGBi
instance Eq RGBi
instance Ord RGBi
instance Show RGBi
instance Format RGBi


-- | Data types for stroke and label styles corresponding to the styles
--   provided by PostScript / SVG (<tt>StrokeAttr</tt>, etc.).
--   
--   Data types for annotating Primitives with their drawing style
--   (<tt>PathProps</tt>, etc.). Wumpus represents pictures as trees and
--   decorates all elements (paths, text-labels) with their drawing style.
--   This is boardly similar to how SVG handles attributes. For PostScript
--   output, Wumpus renders attribute changes as graphics state updates.
module Wumpus.Core.GraphicProps

-- | Stroke attributes for drawing paths.
data StrokeAttr
StrokeAttr :: Double -> Double -> LineCap -> LineJoin -> DashPattern -> StrokeAttr
line_width :: StrokeAttr -> Double
miter_limit :: StrokeAttr -> Double
line_cap :: StrokeAttr -> LineCap
line_join :: StrokeAttr -> LineJoin
dash_pattern :: StrokeAttr -> DashPattern

-- | Line cap - default in output is butt.
--   
--   <pre>
--   Cap Butt:
--   </pre>
--   
--   <pre>
--   .-------.
--   |=======|
--   '-------'
--   </pre>
--   
--   <pre>
--   Cap Round:
--   </pre>
--   
--   <pre>
--    .-------.
--   ( ======= )
--    '-------'
--   </pre>
--   
--   <pre>
--   Cap Square:
--   </pre>
--   
--   <pre>
--   .---------.
--   | ======= |
--   '---------'
--   </pre>
data LineCap
CapButt :: LineCap
CapRound :: LineCap
CapSquare :: LineCap

-- | Line join - default in output is miter.
--   
--   <pre>
--   Join Miter:
--   </pre>
--   
--   <pre>
--       /\
--      /..\ 
--     /./\.\
--    /./  \.\
--   /./    \.\
--   </pre>
--   
--   <pre>
--   Join Round:
--   </pre>
--   
--   <pre>
--   \.\  
--    \.\ 
--     ,.)
--    /./
--   /./
--   </pre>
--   
--   <pre>
--   Join Bevel:
--   </pre>
--   
--   <pre>
--       __
--      /..\ 
--     /./\.\
--    /./  \.\
--   /./    \.\
--   </pre>
data LineJoin
JoinMiter :: LineJoin
JoinRound :: LineJoin
JoinBevel :: LineJoin

-- | Dash pattern - either a solid line or a list of on-off pairs together
--   with an <i>offset</i> into the dashes.
--   
--   <pre>
--   Solid
--   </pre>
--   
--   <pre>
--   Dash offset [(on,off )..]
--   </pre>
data DashPattern
Solid :: DashPattern
Dash :: Int -> [(Int, Int)] -> DashPattern

-- | Font face and size. Equivalent fonts have different names in
--   PostScript and SVG. A PostScript font name includes the font style
--   (e.g. <tt>Times-BoldItalic</tt>) whereas an SVG font has a name (the
--   <tt>font-family</tt> attribute) and a style.
--   
--   For PostScript, the following fonts are expected to exist:
--   
--   <pre>
--   Times-Roman  Times-Italic  Times-Bold  Times-BoldOtalic
--   Helvetica  Helvetica-Oblique  Helvetica-Bold  Helvetica-Bold-Oblique
--   Courier  Courier-Oblique  Courier-Bold  Courier-Bold-Oblique
--   Symbol
--   </pre>
--   
--   See the PostScript Language Reference Manual.
data FontAttr
FontAttr :: Int -> FontFace -> FontAttr
font_size :: FontAttr -> Int
font_face :: FontAttr -> FontFace

-- | <a>FontFace</a> : <tt> postscript_name * svg_font_family *
--   svg_font_style * encoding_vector </tt>
--   
--   For the writing fonts in the Core 14 set the definitions are:
--   
--   <pre>
--   "Times-Roman"       "Times New Roman" SVG_REGULAR     standard_encoding
--   "Times-Italic"      "Times New Roman" SVG_ITALIC      standard_encoding
--   "Times-Bold"        "Times New Roman" SVG_BOLD        standard_encoding
--   "Times-BoldItalic"  "Times New Roman" SVG_BOLD_ITALIC standard_encoding
--   
--   "Helvetica"              "Helvetica" SVG_REGULAR      standard_encoding
--   "Helvetica-Oblique"      "Helvetica" SVG_OBLIQUE      standard_encoding
--   "Helvetica-Bold"         "Helvetica" SVG_BOLD         standard_encoding
--   "Helvetica-Bold-Oblique" "Helvetica" SVG_BOLD_OBLIQUE standard_encoding
--   
--   "Courier"              "Courier New"    SVG_REGULAR      standard_encoding
--   "Courier-Oblique"      "Courier New"    SVG_OBLIQUE      standard_encoding
--   "Courier-Bold"         "Courier New"    SVG_BOLD         standard_encoding
--   "Courier-Bold-Oblique" "Courier New"    SVG_BOLD_OBLIQUE standard_encoding
--   </pre>
data FontFace
FontFace :: String -> String -> SVGFontStyle -> EncodingVector -> FontFace
ps_font_name :: FontFace -> String
svg_font_family :: FontFace -> String
svg_font_style :: FontFace -> SVGFontStyle
font_enc_vector :: FontFace -> EncodingVector

-- | SVG font styles - potentially a style may generate both
--   <tt>font-weight</tt> and <tt>font-style</tt> attributes in the SVG
--   output.
data SVGFontStyle
SVG_REGULAR :: SVGFontStyle
SVG_BOLD :: SVGFontStyle
SVG_ITALIC :: SVGFontStyle
SVG_BOLD_ITALIC :: SVGFontStyle
SVG_OBLIQUE :: SVGFontStyle
SVG_BOLD_OBLIQUE :: SVGFontStyle

-- | Note when drawn <i>filled</i> and drawn <i>stroked</i> the same
--   polygon will have (slightly) different size:
--   
--   <ul>
--   <li>A filled shape fills <i>within</i> the boundary of the shape</li>
--   <li>A stroked shape draws a pen line around the boundary of the shape.
--   The actual size depends on the thickness of the line (stroke
--   width).</li>
--   </ul>
--   
--   <pre>
--   CFill - closed path filled with the colour.
--   </pre>
--   
--   <pre>
--   CStroke - closed path, stroked with the colour.
--   </pre>
--   
--   <pre>
--   OStroke - open path, stroked with the colour.
--   </pre>
--   
--   <pre>
--   CFillStroke - closed path, filled with the first colour, 
--   stroked with the stroke attributes and second colour.
--   </pre>
data PathProps
CFill :: RGBi -> PathProps
CStroke :: StrokeAttr -> RGBi -> PathProps
OStroke :: StrokeAttr -> RGBi -> PathProps
CFillStroke :: RGBi -> StrokeAttr -> RGBi -> PathProps

-- | Font rendering properties for a PrimLabel.
data LabelProps
LabelProps :: RGBi -> FontAttr -> LabelProps
label_colour :: LabelProps -> RGBi
label_font :: LabelProps -> FontAttr

-- | Ellipses and circles are always closed.
--   
--   <pre>
--   EFill - filled ellipse.
--   </pre>
--   
--   <pre>
--   EStroke - stroked ellipse.
--   </pre>
--   
--   <pre>
--   EFillStroke - ellipse filled with the first colour and stroked 
--   with the stroke attributes and second colour.
--   </pre>
data EllipseProps
EFill :: RGBi -> EllipseProps
EStroke :: StrokeAttr -> RGBi -> EllipseProps
EFillStroke :: RGBi -> StrokeAttr -> RGBi -> EllipseProps

-- | Default stroke attributes.
--   
--   <pre>
--   line_width      = 1
--   miter_limit     = 1
--   line_cap        = CapButt
--   line_join       = JoinMiter
--   dash_pattern    = Solid
--   </pre>
default_stroke_attr :: StrokeAttr

-- | <a>defaultFont</a> :<tt> font_size -&gt; FontAttr </tt>
--   
--   Constructor for the default font, which is <tt>Courier</tt> (aliased
--   to <tt>Courier New</tt> for SVG) at the supplied size.
--   
--   Note - the font uses the Standard encoding - this is common to fonts
--   but uses different indices to the more common Latin1.
--   
--   For instance 232 is Lslash not egrave.
--   
--   Both GhostScript and the standard AFM <i>Core 14</i> metrics supplied
--   by Adobe use Standard Encoding but include further characters (e.g.
--   egrave) in the non-indexed <i>higher-region</i>.
defaultFont :: Int -> FontAttr

-- | Constant for the default font (<tt>Courier</tt>) at 14 point.
wumpus_default_font :: FontAttr
instance Enum LineCap
instance Eq LineCap
instance Show LineCap
instance Enum LineJoin
instance Eq LineJoin
instance Show LineJoin
instance Eq DashPattern
instance Show DashPattern
instance Eq StrokeAttr
instance Show StrokeAttr
instance Eq SVGFontStyle
instance Ord SVGFontStyle
instance Show SVGFontStyle
instance Eq FontFace
instance Ord FontFace
instance Show FontFace
instance Eq FontAttr
instance Ord FontAttr
instance Show FontAttr
instance Eq PathProps
instance Show PathProps
instance Eq LabelProps
instance Ord LabelProps
instance Show LabelProps
instance Eq EllipseProps
instance Show EllipseProps
instance Format EllipseProps
instance Format LabelProps
instance Format PathProps

module Wumpus.Core.AffineTrans

-- | Apply a matrix transformation directly.
class Transform t
transform :: (Transform t, u ~ DUnit t) => Matrix3'3 u -> t -> t

-- | Type class for rotation.
class Rotate t
rotate :: Rotate t => Radian -> t -> t

-- | Type class for rotation about a point.
--   
--   Note - the point is a <tt>DPoint2</tt> - i.e. it has PostScript points
--   for x and y-units.
class RotateAbout t
rotateAbout :: (RotateAbout t, u ~ DUnit t) => Radian -> Point2 u -> t -> t

-- | Type class for scaling.
class Scale t
scale :: Scale t => Double -> Double -> t -> t

-- | Type class for translation.
class Translate t
translate :: (Translate t, u ~ DUnit t) => u -> u -> t -> t

-- | Rotate by 30 degrees about the origin.
rotate30 :: Rotate t => t -> t

-- | Rotate by 30 degrees about the supplied point.
rotate30About :: (RotateAbout t, DUnit t ~ u) => Point2 u -> t -> t

-- | Rotate by 45 degrees about the origin.
rotate45 :: Rotate t => t -> t

-- | Rotate by 45 degrees about the supplied point.
rotate45About :: (RotateAbout t, DUnit t ~ u) => Point2 u -> t -> t

-- | Rotate by 60 degrees about the origin.
rotate60 :: Rotate t => t -> t

-- | Rotate by 60 degrees about the supplied point.
rotate60About :: (RotateAbout t, DUnit t ~ u) => Point2 u -> t -> t

-- | Rotate by 90 degrees about the origin.
rotate90 :: Rotate t => t -> t

-- | Rotate by 90 degrees about the supplied point.
rotate90About :: (RotateAbout t, DUnit t ~ u) => Point2 u -> t -> t

-- | Rotate by 120 degrees about the origin.
rotate120 :: Rotate t => t -> t

-- | Rotate by 120 degrees about the supplied point.
rotate120About :: (RotateAbout t, DUnit t ~ u) => Point2 u -> t -> t

-- | Scale both x and y dimensions by the same amount.
uniformScale :: Scale t => Double -> t -> t

-- | Reflect in the X-plane about the origin.
reflectX :: Scale t => t -> t

-- | Reflect in the Y-plane about the origin.
reflectY :: Scale t => t -> t

-- | Translate by the x and y components of a vector.
translateBy :: (Translate t, DUnit t ~ u) => Vec2 u -> t -> t

-- | Reflect in the X plane that intersects the supplied point.
reflectXPlane :: (Num u, Scale t, Translate t, u ~ DUnit t) => Point2 u -> t -> t

-- | Reflect in the Y plane that intersects the supplied point.
reflectYPlane :: (Num u, Scale t, Translate t, u ~ DUnit t) => Point2 u -> t -> t
instance Translate (Vec2 u)
instance Num u => Translate (Point2 u)
instance (u ~ DUnit a, u ~ DUnit b, Translate a, Translate b) => Translate (a, b)
instance Translate a => Translate (Maybe a)
instance Fractional u => Scale (Vec2 u)
instance Fractional u => Scale (Point2 u)
instance (Scale a, Scale b) => Scale (a, b)
instance Scale a => Scale (Maybe a)
instance (Real u, Floating u) => RotateAbout (Vec2 u)
instance (Real u, Floating u) => RotateAbout (Point2 u)
instance (u ~ DUnit a, u ~ DUnit b, RotateAbout a, RotateAbout b) => RotateAbout (a, b)
instance RotateAbout a => RotateAbout (Maybe a)
instance (Real u, Floating u) => Rotate (Vec2 u)
instance (Real u, Floating u) => Rotate (Point2 u)
instance (Rotate a, Rotate b) => Rotate (a, b)
instance Rotate a => Rotate (Maybe a)
instance Num u => Transform (Vec2 u)
instance Num u => Transform (Point2 u)
instance (u ~ DUnit a, u ~ DUnit b, Transform a, Transform b) => Transform (a, b)
instance Transform a => Transform (Maybe a)


-- | Bounding box with no notion of 'empty'.
--   
--   Empty pictures cannot be created with Wumpus. This significantly
--   simplifies the implementation of pictures and bounding boxes.
--   
--   Note - some of the functions exposed by this module are expected to be
--   pertinent only to Wumpus-Core itself.
module Wumpus.Core.BoundingBox

-- | Bounding box of a picture, path, etc. represented by the lower-left
--   and upper-right corners.
--   
--   Wumpus cannot construct empty pictures - so bounding boxes are spared
--   the obligation to be <i>empty</i>. This greatly helps keep the
--   implementation relatively simple.
--   
--   BoundingBox operates as a semigroup where <tt>boundaryUnion</tt> is
--   the addition.
data BoundingBox u
BBox :: Point2 u -> Point2 u -> BoundingBox u
ll_corner :: BoundingBox u -> Point2 u
ur_corner :: BoundingBox u -> Point2 u
type DBoundingBox = BoundingBox Double

-- | Type class extracting the bounding box of an object - Picture, Path
--   etc.
class Boundary t
boundary :: (Boundary t, u ~ DUnit t) => t -> BoundingBox u

-- | <a>boundingBox</a> : <tt>lower_left_corner * upper_right_corner -&gt;
--   BoundingBox</tt>
--   
--   Contruct a bounding box, vis the BBox constructor with range checking
--   on the corner points.
--   
--   <a>boundingBox</a> throws an error if the width or height of the
--   constructed bounding box is negative.
boundingBox :: Ord u => Point2 u -> Point2 u -> BoundingBox u

-- | <a>destBoundingBox</a> : <tt> bbox -&gt; (lower_left_x, lower_left_y,
--   upper_right_x, upper_right_y)</tt>
--   
--   Destructor for BoundingBox, assembles a four-tuple of the x and y
--   values of the corner points.
--   
--   Arguably this is easier to pattern match upon, as it removes a layer
--   of nesting.
destBoundingBox :: BoundingBox u -> (u, u, u, u)

-- | The union of two bounding boxes.
boundaryUnion :: Ord u => BoundingBox u -> BoundingBox u -> BoundingBox u

-- | <a>traceBoundary</a> : <tt> points -&gt; BoundingBox </tt>
--   
--   Trace a list of points, retuning the BoundingBox of their boundary.
--   
--   ** WARNING ** - <tt>trace</tt> throws a run-time error when supplied
--   with the empty list.
traceBoundary :: (Num u, Ord u) => [Point2 u] -> BoundingBox u

-- | Perform the supplied transformation on the four corners of the
--   bounding box. Trace the new corners to calculate the resulting
--   bounding box.
--   
--   NOTE - this helper function is used within Wumpus-Core to re-calculate
--   a bounding box after a rotation for example. It is probably useful
--   only to Wumpus-Core.
retraceBoundary :: (Num u, Ord u) => (Point2 u -> Point2 u) -> BoundingBox u -> BoundingBox u

-- | <a>boundaryCorners</a> : <tt>bbox -&gt; (bottom_left, bottom_right,
--   top_right, top_left)</tt>
--   
--   Generate all the corners of a bounding box, counter-clock wise from
--   the bottom left, i.e. <tt>(bl, br, tr, tl)</tt>.
boundaryCorners :: BoundingBox u -> (Point2 u, Point2 u, Point2 u, Point2 u)

-- | <a>boundaryCornerList</a> : <tt>bbox -&gt; [bottom_left, bottom_right,
--   top_right, top_left]</tt>
--   
--   Generate all the corners of a bounding box, counter-clock wise from
--   the bottom left, i.e. <tt>[bl, br, tr, tl]</tt>.
--   
--   This is a list version of <a>boundaryCorners</a> which is sometimes
--   more convenient. For instance, to create a vertex path it is more
--   direct to use this list rather than build one from the 4-tuple
--   returned by <a>boundaryCorners</a>.
boundaryCornerList :: BoundingBox u -> [Point2 u]

-- | <a>boundaryCenter</a> : <tt>bbox -&gt; Point</tt>
--   
--   Return the center of a bounding box.
boundaryCenter :: Fractional u => BoundingBox u -> Point2 u

-- | <a>withinBoundary</a> : <tt> point * bbox -&gt; Bool </tt>
--   
--   Within test - is the supplied point within the bounding box?
withinBoundary :: (Tolerance u, Ord u) => Point2 u -> BoundingBox u -> Bool

-- | <a>boundaryWidth</a> : <tt> bbox -&gt; Width </tt>
--   
--   Extract the width of a bounding box.
boundaryWidth :: Num u => BoundingBox u -> u

-- | <a>boundaryHeight</a> : <tt> bbox -&gt; Height </tt>
--   
--   Extract the height of a bounding box.
boundaryHeight :: Num u => BoundingBox u -> u
instance Show u => Show (BoundingBox u)
instance Boundary (BoundingBox u)
instance (Num u, Ord u) => Translate (BoundingBox u)
instance (Fractional u, Ord u) => Scale (BoundingBox u)
instance (Real u, Floating u, Ord u) => RotateAbout (BoundingBox u)
instance (Real u, Floating u, Ord u) => Rotate (BoundingBox u)
instance (Num u, Ord u) => Transform (BoundingBox u)
instance Format u => Format (BoundingBox u)
instance Functor BoundingBox
instance (Tolerance u, Ord u) => Eq (BoundingBox u)


-- | Approximate glyph size calculations for Label's and their bounding
--   boxes.
--   
--   Calculations are based on metrics derived from the Courier font. As
--   Courier is a monospaced font, applying these metrics to other font
--   families will usually produce over-estimates (bounding boxes will be
--   longer than the true visual length of the text). Furthermore, even
--   italic or bold Courier will have different metrics.
--   
--   This is a deficiency of Wumpus, and limits its text handling
--   capabilities - for example, text cannot be reliably centered or right
--   aligned as its true length is not known. However, more powerful
--   alternatives would need access to the metrics embedded within font
--   files. This would require a font loader and add significant
--   implementation complexity.
module Wumpus.Core.FontSize
type FontSize = Int
type CharCount = Int

-- | Wrapped Double representing 1/1000 of the scale factor (Point size) of
--   a font. AFM files encode all measurements as these units.
data AfmUnit

-- | Compute the size of a measurement in Afm units scaled by the point
--   size of the font.
afmUnit :: FontSize -> Double -> AfmUnit

-- | Compute the size of a measurement in PostScript points scaling the Afm
--   unit size by the point size of the font.
afmValue :: FontSize -> AfmUnit -> Double

-- | The ratio of width to point size of a letter in Courier.
--   
--   <pre>
--   mono_width = 600
--   </pre>
mono_width :: AfmUnit

-- | The ratio of cap height to point size of a letter in Courier.
--   
--   <pre>
--   mono_cap_height = 562
--   </pre>
mono_cap_height :: AfmUnit

-- | The ratio of x height to point size of a letter in Courier.
--   
--   This is also known as the "body height".
--   
--   <pre>
--   mono_x_height = 426
--   </pre>
mono_x_height :: AfmUnit

-- | The ratio of descender depth to point size of a letter in Courier.
--   
--   <pre>
--   mono_descender = -157
--   </pre>
mono_descender :: AfmUnit

-- | The ratio of ascender to point size of a letter in Courier.
--   
--   <pre>
--   mono_ascender = 629
--   </pre>
mono_ascender :: AfmUnit

-- | The left margin for the bounding box of printed text as a ratio to
--   point size for Courier.
--   
--   <pre>
--   mono_left_margin = -46
--   </pre>
mono_left_margin :: AfmUnit

-- | The right margin for the bounding box of printed text as a ratio to
--   point size for Courier.
--   
--   <pre>
--   mono_right_margin = 50
--   </pre>
mono_right_margin :: AfmUnit

-- | Approximate the width of a monospace character using metrics derived
--   from the Courier font.
charWidth :: FontSize -> Double

-- | <a>textWidth</a> : <tt> font_size * char_count -&gt; PtSize </tt>
--   
--   Text width at the supplied font_size. It is expected that the
--   <tt>char_ount</tt> has been calculated with the <tt>charCount</tt>
--   function.
--   
--   NOTE - this does not account for any left and right margins around the
--   printed text.
textWidth :: FontSize -> CharCount -> Double

-- | Height of capitals e.g. 'A' using metrics derived the Courier
--   monospaced font.
capHeight :: FontSize -> Double

-- | Height of the lower-case char 'x' using metrics derived the Courier
--   monospaced font.
xcharHeight :: FontSize -> Double

-- | The total height span of the glyph bounding box for the Courier
--   monospaced font.
totalCharHeight :: FontSize -> Double

-- | Ascender height for font size <tt>sz</tt> using metrics from the
--   Courier monospaced font.
ascenderHeight :: FontSize -> Double

-- | Descender depth for font size <tt>sz</tt> using metrics from the
--   Courier monospaced font.
descenderDepth :: FontSize -> Double

-- | <a>textBounds</a> : <tt> font_size * baseline_left * text -&gt; BBox
--   </tt>
--   
--   Find the bounding box for the character count at the supplied
--   font-size.
--   
--   The supplied point represents the baseline left corner of the a
--   regular upper-case letter (that is without descenders). The bounding
--   box adds a margin around all sides of the text.
--   
--   The metrics used are derived from Courier - a monospaced font. For
--   proportional fonts the calculated bounding box will usually be too
--   long.
textBounds :: FontSize -> DPoint2 -> String -> BoundingBox Double

-- | <a>textBoundsEsc</a> : <tt> font_size * baseline_left * escaped_text
--   -&gt; BBox </tt>
--   
--   Version of textBounds for already escaped text.
textBoundsEsc :: FontSize -> DPoint2 -> EscapedText -> BoundingBox Double

-- | <a>charCount</a> : <tt> string -&gt; CharCount </tt>
--   
--   Count the characters in the supplied string, escaping the string as
--   necessary.
--   
--   Escapes count as one character - for instance, the length of this
--   string:
--   
--   <pre>
--   abcd&amp;#egrave;f
--   </pre>
--   
--   ... is 6.
charCount :: String -> CharCount
instance Eq AfmUnit
instance Ord AfmUnit
instance Num AfmUnit
instance Floating AfmUnit
instance Fractional AfmUnit
instance Real AfmUnit
instance RealFrac AfmUnit
instance RealFloat AfmUnit
instance Tolerance AfmUnit
instance Show AfmUnit


-- | Construction of pictures, paths and text labels.
--   
--   Note - the text label functions are only appropriate for single
--   printed lines of text. Wumpus-Core does not interpret special
--   white-space characters (i.e. tab or newline) and passes them forward
--   into the output file. Renderers will then deal with white-space as
--   they please, which is usually to ignore it.
--   
--   Also, SVG output does not currently use <tt>space="preserve"</tt>. It
--   would be desirable to do so, as the PostScript generated by Wumpus can
--   use doubled up spaces to print wide spaces. Unfortunately, SVG
--   renderers seem to differ as to whether they can inherit
--   <tt>space="preserve"</tt> from a top level attribute or whether it
--   must be annotated on every <tt>&lt;text&gt;</tt> element. Wumpus
--   considers the latter to be a too-high burden as it will expand the
--   code size (this view may change).
module Wumpus.Core.Picture

-- | Lift a list of primitives to a composite picture.
--   
--   The order of the list maps to the order of printing - the front of the
--   list is drawn first in the file. This also means that the front of the
--   list is drawn <i>underneath</i> in the Z-Order.
--   
--   ** WARNING ** - this function throws a runtime error when supplied the
--   empty list.
frame :: [Primitive] -> Picture

-- | Place multiple pictures within the standard affine frame.
--   
--   ** WARNING ** - this function throws a runtime error when supplied the
--   empty list.
multi :: [Picture] -> Picture

-- | Update the font <i>delta</i> attributes for SVG output.
--   
--   Note - <a>fontDeltaContext</a> does not set the font properties of
--   elements in the supplied Picture, it is solely a mechanism to help
--   reduce the code size of the generated SVG by factoring common
--   attributes into a group (g) element. For instance, settting the font
--   properties with <a>fontDeltaContext</a> can eliminate the repeated use
--   of font-family and font-size in this code:
--   
--   <pre>
--   &lt;text font-family="Helvetica" font-size="12"&gt; ... &lt;/text&gt;
--   &lt;text font-family="Helvetica" font-size="12"&gt; ... &lt;/text&gt;
--   &lt;text font-family="Helvetica" font-size="12"&gt; ... &lt;/text&gt;
--   </pre>
--   
--   With the appropriate font delta context, this code will be generated:
--   
--   <pre>
--   &lt;g font-family="Helvetica" font-size="12"&gt;
--     &lt;text &gt; ... &lt;/text&gt;
--     &lt;text &gt; ... &lt;/text&gt;
--     &lt;text &gt; ... &lt;/text&gt;
--   &lt;/g&gt;
--   </pre>
--   
--   Wumpus ignores <a>fontDeltaContext</a> directives when generating
--   PostScript. Unlike SVG, PostScript is not naturally nested, so
--   introducing nesting with <tt>gsave</tt> and <tt>grestore</tt> is not
--   likely to improve the PostScript Wumpus generates.
fontDeltaContext :: FontAttr -> Primitive -> Primitive

-- | <a>absPrimPath</a> : <tt> start_point * [abs_path_segment] -&gt;
--   PrimPath </tt>
--   
--   Create a <a>PrimPath</a> from a start point and a list of
--   <i>absolute</i> path segments.
absPrimPath :: DPoint2 -> [AbsPathSegment] -> PrimPath

-- | <a>absLineTo</a> : <tt> end_point -&gt; path_segment </tt>
--   
--   Create a straight-line <a>AbsPathSegment</a>, the start point is
--   implicitly the previous point in a path.
absLineTo :: DPoint2 -> AbsPathSegment

-- | <a>absCurveTo</a> : <tt> control_point1 * control_point2 * end_point
--   -&gt; path_segment </tt>
--   
--   Create a curved <a>AbsPathSegment</a>, the start point is implicitly
--   the previous point in a path.
absCurveTo :: DPoint2 -> DPoint2 -> DPoint2 -> AbsPathSegment

-- | <a>relPrimPath</a> : <tt> start_point * [rel_path_segment] -&gt;
--   PrimPath </tt>
--   
--   Create a <a>PrimPath</a> from a start point and a list of
--   <i>relative</i> path segments.
--   
--   Note - internally Wumpus works with relative paths so constructing
--   them directly with <a>relPrimPath</a> is more efficient than using
--   <a>absPrimPath</a>.
relPrimPath :: DPoint2 -> [PrimPathSegment] -> PrimPath

-- | <a>relLineTo</a> : <tt> vec_to_end -&gt; path_segment </tt>
--   
--   Create a straight-line <a>PrimPathSegment</a>, the vector is the
--   relative displacement.
relLineTo :: DVec2 -> PrimPathSegment

-- | <a>relCurveTo</a> : <tt> vec_to_cp1 * vec_to_cp2 * vec_to_end -&gt;
--   path_segment </tt>
--   
--   Create a curved <tt>RelPathSegment</tt>.
relCurveTo :: DVec2 -> DVec2 -> DVec2 -> PrimPathSegment

-- | <a>vertexPrimPath</a> : <tt> [point] -&gt; PrimPath </tt>
--   
--   Convert the list of vertices to a path of straight line segments.
--   
--   ** WARNING ** - this function throws a runtime error when supplied the
--   empty list.
vertexPrimPath :: [DPoint2] -> PrimPath

-- | <a>vectorPrimPath</a> : <tt> start_point -&gt; [next_vector] -&gt;
--   PrimPath </tt>
--   
--   Build a "relative" path from the start point, appending successive
--   straight line segments formed from the list of next_vectors.
--   
--   This function can be supplied with an empty list - this simulates a
--   null graphic.
vectorPrimPath :: DPoint2 -> [DVec2] -> PrimPath

-- | <a>emptyPrimPath</a> : <tt> start_point -&gt; PrimPath </tt>
--   
--   Build an empty path. The start point must be specified even though the
--   path is not drawn - a start point is the minimum information needed to
--   calculate a bounding box.
emptyPrimPath :: DPoint2 -> PrimPath

-- | <a>curvedPrimPath</a> : <tt> points -&gt; PrimPath </tt>
--   
--   Convert a list of vertices to a path of curve segments. The first
--   point in the list makes the start point, each curve segment thereafter
--   takes 3 points. <i>Spare</i> points at the end are discarded.
--   
--   ** WARNING - this function throws an error when supplied the empty
--   list.
curvedPrimPath :: [DPoint2] -> PrimPath

-- | Create a hyperlink for SVG output.
--   
--   Note - hyperlinks are ignored in the PostScript output.
xlinkhref :: String -> XLink

-- | Hyperlinked Primitive.
--   
--   This encloses the Primitive in an addition <tt>&lt;g&gt;</tt> element.
--   
--   Note - hyperlinks are ignored in the PostScript output.
xlinkPrim :: XLink -> Primitive -> Primitive

-- | Annotate a Primitive with an <tt>id</tt>.
--   
--   For text labels this annotates the label directly, for other
--   primitives the annotation adds extra nesting with a <tt>&lt;g&gt;</tt>
--   element.
--   
--   Note - ids are ignored in the PostScript output.
xidPrim :: String -> Primitive -> Primitive

-- | Create an attribute for SVG output.
--   
--   Attributes are expected to be <i>non-graphical</i> e.g.
--   <tt>onclick</tt> events or similar. Wumpus does not check the syntax
--   and simply emits the Strings as-is in the output.
--   
--   Graphical properties should not be encoded, they may conflict with
--   output that Wumpus produces.
--   
--   ** WARNING ** - currently this functionality is undercooked. Because
--   SVG has more <i>extra-graphical</i> facilities than PostScript
--   (hyperlinks, mouseovers, etc.) it seems important to have an escape
--   hatch to them, yet so far the escape hatch has not been needed.
svgattr :: String -> String -> SvgAttr

-- | Add SVG attribute annotations to a Primitive.
--   
--   The primitive will be printed in a <tt>g</tt> (group) element labelled
--   with the annotations.
annotateGroup :: [SvgAttr] -> Primitive -> Primitive

-- | Add SVG XLink and attribute annotations to a Primitive.
--   
--   The primitive will be printed in a <tt>g</tt> (group) element, itself
--   inside an <tt>a</tt> link.
annotateXLink :: XLink -> [SvgAttr] -> Primitive -> Primitive

-- | Group a list of Primitives.
--   
--   ** WARNING ** - this function throws a runtime error when supplied the
--   empty list.
primGroup :: [Primitive] -> Primitive

-- | Concatenate two Primitives.
--   
--   If both primitves are groups, then the groups are merged.
--   
--   If one or other primitive is a group, the singleton is added into the
--   group at the respective end.
--   
--   Otherwise a group is formed adding both elements as <i>children</i>.
--   
--   The Primitive type in Wumpus is a tree. In theory <a>primCat</a> can
--   make flatter and wider trees than <a>primGroup</a>, though in practice
--   this may have no noticeable benefit as Wumpus has very simple access
--   patterns into the Primitive tree.
primCat :: Primitive -> Primitive -> Primitive

-- | <a>ostroke</a> : <tt> rgb * stroke_attr * path -&gt; Primitive </tt>
--   
--   Create an open, stroked path from the <a>PrimPath</a> specification.
ostroke :: RGBi -> StrokeAttr -> PrimPath -> Primitive

-- | <a>cstroke</a> : <tt> rgb * stroke_attr * path -&gt; Primitive </tt>
--   
--   Create a closed, stroked path from the <a>PrimPath</a> specfication.
cstroke :: RGBi -> StrokeAttr -> PrimPath -> Primitive

-- | <a>zostroke</a> : <tt> path -&gt; Primitive </tt>
--   
--   Create an open, stroked path using the default stroke attributes and
--   coloured black.
zostroke :: PrimPath -> Primitive

-- | <a>zcstroke</a> : <tt> path -&gt; Primitive </tt>
--   
--   Create a closed stroked path using the default stroke attributes and
--   coloured black.
zcstroke :: PrimPath -> Primitive

-- | <a>fill</a> : <tt> rgb * path -&gt; Primitive </tt>
--   
--   Create a filled path from the <a>PrimPath</a> specification.
fill :: RGBi -> PrimPath -> Primitive

-- | <a>zfill</a> : <tt> path -&gt; Primitive </tt>
--   
--   Draw a filled path coloured black.
zfill :: PrimPath -> Primitive

-- | <a>fillStroke</a> : <tt> fill_rgb * stroke_attr * stroke_rgb * path
--   -&gt; Primitive </tt>
--   
--   Create a closed path that is both filled and stroked (the fill is
--   below in the zorder).
fillStroke :: RGBi -> StrokeAttr -> RGBi -> PrimPath -> Primitive

-- | <a>clipPrim</a> : <tt> path * primitive -&gt; Primitive </tt>
--   
--   Clip a primitive to be inside the supplied path.
clipPrim :: PrimPath -> Primitive -> Primitive

-- | <a>textlabel</a> : <tt> rgb * font_attr * string * baseline_left -&gt;
--   Primitive </tt>
--   
--   Create a text label. The string should not contain newline or tab
--   characters. Also double-spaces should not be used - a rendering agent
--   for SVG will coalesce double-spaces into a single space. For precise
--   control of spacing and kerning use <a>hkernlabel</a>.
--   
--   The supplied point is the left baseline.
textlabel :: RGBi -> FontAttr -> String -> DPoint2 -> Primitive

-- | <a>rtextlabel</a> : <tt> rgb * font_attr * string * theta *
--   baseline_left -&gt; Primitive </tt>
--   
--   Create a text label rotated by the supplied angle about the
--   baseline-left.
--   
--   The supplied point is the left baseline.
rtextlabel :: RGBi -> FontAttr -> String -> Radian -> DPoint2 -> Primitive

-- | <a>ztextlabel</a> : <tt> string * baseline_left -&gt; Primitive </tt>
--   
--   Create a label where the font is <tt>Courier</tt>, text size is 14pt
--   and colour is black.
ztextlabel :: String -> DPoint2 -> Primitive

-- | <a>escapedlabel</a> : <tt> rgb * font_attr * escaped_text *
--   baseline_left -&gt; Primitive </tt>
--   
--   Version of <a>textlabel</a> where the label text has already been
--   parsed for special characters.
--   
--   The supplied point is the left baseline.
escapedlabel :: RGBi -> FontAttr -> EscapedText -> DPoint2 -> Primitive

-- | <a>rescapedlabel</a> : <tt> rgb * font_attr * escaped_text * theta *
--   baseline_left -&gt; Primitive </tt>
--   
--   Version of <a>rtextlabel</a> where the label text has already been
--   parsed for special characters.
--   
--   The supplied point is the left baseline.
rescapedlabel :: RGBi -> FontAttr -> EscapedText -> Radian -> DPoint2 -> Primitive

-- | <a>zescapedlabel</a> : <tt> escaped_text * baseline_left -&gt;
--   Primitive </tt>
--   
--   Version of <a>ztextlabel</a> where the label text has already been
--   encoded.
zescapedlabel :: EscapedText -> DPoint2 -> Primitive

-- | <a>hkernlabel</a> : <tt> rgb * font_attr * kerning_chars *
--   baseline_left -&gt; Primitive </tt>
--   
--   Create a text label with horizontal <i>kerning</i> for each character.
--   
--   Note - kerning is relative to the left baseline of the previous
--   character, it is *not relative* to the right-hand boundary of the
--   previous char. While the later would be more obvious it would take a
--   lot of effort to implement as it would need access to the metrics
--   encoded in font files.
--   
--   Characters are expected to be drawn left to right, so displacements
--   should not be negative. If the displacement is zero the character will
--   be drawn ontop of the previous char.
--   
--   The charcters should not contain newline or tab characters.
--   
--   The supplied point is the left baseline.
--   
--   ** CAUTION ** - for SVG, <tt>hkernlabel</tt> generates a coordinate
--   list of X-positions rather than a single start point. This is
--   syntactically valid SVG, but it is not universally supported by
--   renderers. Chrome support is fine, but Firefox and Safari currently
--   seem lacking.
--   
--   Also, note this feature does not have a directly compatible PostScript
--   analogue. While the same picture is generated in both cases, the
--   PostScript code is not particularly inefficient.
hkernlabel :: RGBi -> FontAttr -> [KerningChar] -> DPoint2 -> Primitive

-- | <a>vkernlabel</a> : <tt> rgb * font_attr * kerning_chars *
--   baseline_left -&gt; Primitive </tt>
--   
--   Create a text label with vertical <i>kerning</i> for each character -
--   the text is expected to grow downwards.
--   
--   Note - <i>kerning</i> here is the measure between baselines of
--   sucessive characters, it is *not* the distance between the bottom of
--   one chararter and the top of the next character.
--   
--   While the later maybe be more obvious from a drawing perspective, it
--   would take a lot of effort to implement as it would need access to the
--   metrics encoded in font files.
--   
--   Characters are expected to be drawn downwards - a positive number
--   represents the downward displacement - so displacements should not be
--   negative. If the displacement is zero the character will be drawn
--   ontop of the previous char.
--   
--   The charcters should not contain newline or tab characters.
--   
--   The supplied point is the left baseline of the top character.
--   
--   ** CAUTION ** - for SVG, <tt>hkernlabel</tt> generates a coordinate
--   list of Y-positions rather than a single start point. This is
--   syntactically valid SVG, but it is not universally supported by
--   renderers. Chrome support is fine, but Firefox and Safari currently
--   seem lacking.
--   
--   Also, note this feature does not have a directly compatible PostScript
--   analogue. While the same picture is generated in both cases, the
--   PostScript code is not particularly inefficient.
vkernlabel :: RGBi -> FontAttr -> [KerningChar] -> DPoint2 -> Primitive

-- | <a>kernchar</a> : <tt> displacement * char -&gt; KerningChar </tt>
--   
--   Construct a regular (i.e. non-special) Char along with its
--   displacement from the left-baseline of the previous Char.
kernchar :: Double -> Char -> KerningChar

-- | <a>kernEscInt</a> : <tt> displacement * char_code -&gt; KerningChar
--   </tt>
--   
--   Construct a Char by its character code along with its displacement
--   from the left-baseline of the previous Char.
kernEscInt :: Double -> Int -> KerningChar

-- | <a>kernEscName</a> : <tt> displacement * char_name -&gt; KerningChar
--   </tt>
--   
--   Construct a Char by its character name along with its displacement
--   from the left-baseline of the previous Char.
kernEscName :: Double -> String -> KerningChar

-- | <a>strokeEllipse</a> : <tt> rgb * stroke_attr * rx * ry * center -&gt;
--   Primtive </tt>
--   
--   Create a stroked ellipse.
--   
--   Note - within Wumpus, ellipses are considered an unfortunate but
--   useful <i>optimization</i>. Drawing good cicles with Beziers needs
--   four curves, but drawing them with PostScript's <tt>arc</tt> command
--   uses a single operation. For drawings with many dots (e.g. scatter
--   plots) it seems sensible to employ this optimization.
--   
--   A deficiency of using PostScript's <tt>arc</tt> command to draw
--   ellipses is that (non-uniformly) scaling a stroked ellipse also
--   (non-uniformly) scales the pen it is drawn with. Where the ellipse is
--   wider, the pen stroke will be wider too.
--   
--   Avoid non-uniform scaling stroked ellipses!
strokeEllipse :: RGBi -> StrokeAttr -> Double -> Double -> DPoint2 -> Primitive

-- | <a>rstrokeEllipse</a> : <tt> rgb * stroke_attr * rx * ry * theta *
--   center -&gt; Primtive </tt>
--   
--   Create a stroked primitive ellipse rotated about the center by
--   <i>theta</i>.
rstrokeEllipse :: RGBi -> StrokeAttr -> Double -> Double -> Radian -> DPoint2 -> Primitive

-- | <a>fillEllipse</a> : <tt> rgb * rx * ry * center -&gt; Primtive </tt>
--   
--   Create a filled primitive ellipse.
fillEllipse :: RGBi -> Double -> Double -> DPoint2 -> Primitive

-- | <a>rfillEllipse</a> : <tt> rgb * rx * ry * theta * center -&gt;
--   Primitive </tt>
--   
--   Create a filled primitive ellipse rotated about the center by
--   <i>theta</i>.
rfillEllipse :: RGBi -> Double -> Double -> Radian -> DPoint2 -> Primitive

-- | <a>zellipse</a> : <tt> rx * ry * center -&gt; Primtive </tt>
--   
--   Create a black, filled ellipse.
zellipse :: Double -> Double -> DPoint2 -> Primitive

-- | <a>fillStrokeEllipse</a> : <tt> fill_rgb * stroke_attr * stroke_rgb *
--   rx * ry * center -&gt; Primtive </tt>
--   
--   Create a bordered (i.e. filled and stroked) primitive ellipse.
fillStrokeEllipse :: RGBi -> StrokeAttr -> RGBi -> Double -> Double -> DPoint2 -> Primitive

-- | <a>rfillStrokeEllipse</a> : <tt> fill_rgb * stroke_attr * stroke_rgb *
--   rx * ry * theta * center -&gt; Primtive </tt>
--   
--   Create a bordered (i.e. filled and stroked) ellipse rotated about the
--   center by <i>theta</i>.
rfillStrokeEllipse :: RGBi -> StrokeAttr -> RGBi -> Double -> Double -> Radian -> DPoint2 -> Primitive

-- | <a>extendBoundary</a> : <tt> x * y * picture -&gt; Picture </tt>
--   
--   Extend the bounding box of a picture.
--   
--   The bounding box is both horizontal directions by <tt>x</tt> and both
--   vertical directions by <tt>y</tt>. <tt>x</tt> and <tt>y</tt> must be
--   positive This function cannot be used to shrink a boundary.
extendBoundary :: Double -> Double -> Picture -> Picture

-- | <a>picOver</a> : <tt> picture * picture -&gt; Picture </tt>
--   
--   Draw the first picture on top of the second picture - neither picture
--   will be moved.
picOver :: Picture -> Picture -> Picture

-- | <a>picMoveBy</a> : <tt> picture * vector -&gt; Picture </tt>
--   
--   Move a picture by the supplied vector.
picMoveBy :: Picture -> DVec2 -> Picture

-- | <a>picBeside</a> : <tt> picture * picture -&gt; Picture </tt>
--   
--   Move the second picture to sit at the right side of the first picture
picBeside :: Picture -> Picture -> Picture

-- | Print the syntax tree of a Picture to the console.
printPicture :: Picture -> IO ()

-- | <a>illustrateBounds</a> : <tt> bbox_rgb * picture -&gt; Picture </tt>
--   
--   Draw the picture on top of an image of its bounding box. The bounding
--   box image will be drawn in the supplied colour.
illustrateBounds :: RGBi -> Picture -> Picture

-- | <a>illustrateBoundsPrim</a> : <tt> bbox_rgb * primitive -&gt; Picture
--   </tt>
--   
--   Draw the primitive on top of an image of its bounding box. The
--   bounding box image will be drawn in the supplied colour.
--   
--   The result will be lifted from Primitive to Picture.
illustrateBoundsPrim :: RGBi -> Primitive -> Picture

-- | <a>illustrateControlPoints</a> : <tt> control_point_rgb * primitive
--   -&gt; Picture </tt>
--   
--   Generate the control points illustrating the Bezier curves within a
--   picture.
--   
--   This has no effect on TextLabels. Nor does it draw Beziers of a
--   hyperlinked object.
illustrateControlPoints :: RGBi -> Primitive -> Picture


-- | This module re-exports types and functions from
--   <a>Wumpus.Core.PictureInternal</a> but makes them opaque. Contructors
--   are provided by <a>Wumpus.Core.Picture</a>.
--   
--   Note - whilst the Picture types support the Eq class the
--   implementations are not efficient, e.g. In the case of Primitive, one
--   of the constructors has to unwind a functional Hughes list. The Eq
--   instance is considered a legacy <i>feature</i> (or burden) as the
--   types have expanded.
module Wumpus.Core.WumpusTypes

-- | Picture is a rose tree. Leaves themselves are attributed with colour,
--   line-width etc. The <i>unit</i> of a Picture is fixed to Double
--   representing PostScript's <i>Point</i> unit. Output is always
--   gewnerated with PostScript points - other units are converted to
--   PostScript points before building the Picture.
--   
--   By attributing leaves with their drawing properties, Wumpus's picture
--   representaion is not directly matched to PostScript. PostScript has a
--   global graphics state (that allows local modifaction) from where
--   drawing properties are inherited. Wumpus has no attribute inheritance.
--   
--   Omitting some details of the list representation, Picture is a simple
--   non-empty rose tree via:
--   
--   <pre>
--   tree = Leaf [primitive] | Picture [tree]
--   </pre>
data Picture

-- | Set the font <i>delta</i> for SVG rendering.
--   
--   Note - this does not change the default colour or font style. It is
--   solely a backdoor into the SVG renderer to potential allow some code
--   size reductions.
data FontCtx

-- | Wumpus's drawings are built from two fundamental primitives: paths
--   (straight line segments and Bezier curves) and labels (single lines of
--   text).
--   
--   Ellipses are a included as a primitive only for optimization - drawing
--   a reasonable circle with Bezier curves needs at least eight curves.
--   This is inconvenient for drawing dots which can otherwise be drawn
--   with a single <tt>arc</tt> command.
--   
--   Wumpus does not follow PostScript employing arc as a general path
--   primitive - arcs are used only to draw ellipses. This is because arcs
--   do not enjoy the nice properties of Bezier curves, whereby the affine
--   transformation of a Bezier curve can simply be achieved by the affine
--   transformation of it's control points.
--   
--   Ellipses are represented by their center, half-width and half-height.
--   Half-width and half-height are used so the bounding box can be
--   calculated using only multiplication, and thus initially only obliging
--   a Num constraint on the unit. Though typically for affine
--   transformations a Fractional constraint is also obliged.
--   
--   Clipping is represented by a pair of the clipping path and the
--   primitive embedded within the path.
--   
--   To represent XLink hyperlinks, Primitives can be annotated with some a
--   hyperlink (likewise a <i>passive</i> font change for better SVG code
--   generation) and grouped - a hyperlinked arrow would want the tip and
--   the arrow body both to be incorporated in thelink even though they are
--   two drawing primitives.
--   
--   This means that Primitives aren't strictly <i>primitive</i> as the
--   actual implementation is a tree.
data Primitive

-- | Primitives can be grouped with hyperlinks in SVG output.
--   
--   Note - this is always printed as <tt>xlink:href=<a>...</a></tt>. Other
--   types of xlink can be modelled with the unrestrained SvgAnno type.
data XLink

-- | Primitives can be labelled with arbitrary SVG properties (e.g
--   <tt>onmouseover</tt>) within a group element.
--   
--   Note - annotations should be used only for non-graphical properties.
--   Graphical properties (fill_colour, font_size, etc.) should be set
--   through the appropriate Wumpus functions.
--   
--   Also note, this functionality is has not been widely used. It might be
--   something of a white elephant.
data SvgAttr

-- | PrimPath - a list of path segments and a CTM (translation matrix).
--   
--   The start point of the path forms the (dx,dy) of the CTM. The CTM is
--   otherwise hidden from the public constructors of this data type.
--   
--   Note - the PrimPath type does not support concatenation. It is
--   expected that all PrimPaths will be created <i>in one go</i>, and
--   client code defines a higher-level path type that supports
--   concatenation, splitting etc.
--   
--   Primitively paths can be built like this:
--   
--   <pre>
--   
--   path1 :: PrimPath
--   path1 = absPrimPath zeroPt [ absLineTo  (P2 0 60) 
--                              , absLineTo  (P2 40 100)
--                              , absLineTo  (P2 80 60)
--                              , absLineTo  (P2 80 0)
--                              , absLineTo  (P2 60 0)  
--                              , absLineTo  (P2 60 30)
--                              , absCurveTo (P2 60 50) (P2 50 60) (P2 40 60)
--                              , absCurveTo (P2 30 60) (P2 20 50) (P2 20 30)
--                              , absLineTo  (P2 20 0)
--                              ]
--   </pre>
--   
--   Although it's generally expected that PrimPaths will be constructed by
--   traversing a higher-level path object and collecting calls to the
--   <tt>absCurevTo</tt> and <tt>absLineTo</tt> functions in a list.
data PrimPath

-- | PrimPathSegment - either a relative cubic Bezier <i>curve-to</i> or a
--   relative <i>line-to</i>.
data PrimPathSegment

-- | AbsPathSegment - either a cubic Bezier curve or a line.
--   
--   Note this data type is transitory - it is only used as a convenience
--   to build relative paths. Hence the unit type is parametric.
data AbsPathSegment

-- | Label - represented by baseline-left point and text.
--   
--   Baseline-left is the dx * dy of the PrimCTM.
data PrimLabel

-- | A Char (possibly escaped) paired with its displacement from the
--   previous KerningChar.
type KerningChar = (Double, EscapedChar)
class Format a
format :: Format a => a -> Doc

-- | <a>stringformat</a> : String -&gt; Doc
--   
--   The format combinators are not exported by Wumpus-Core, however for
--   debugging unit types might need to be made instances of the
--   <a>Format</a> class.
--   
--   To define Format instances render the unit type to a String then use
--   <a>stringformat</a>, e.g:
--   
--   <pre>
--   instance Format Pica where
--     format a = stringformat (show a)
--   </pre>
stringformat :: String -> Doc


-- | Output PostScript - either PostScript (PS) files or EPS (Encapusulated
--   PostScript) files can be generated.
--   
--   The generated PostScript uses only features from Language Level 1.
module Wumpus.Core.OutputPostScript

-- | Output a series of pictures to a Postscript file. Each picture will be
--   printed on a separate page.
writePS :: FilePath -> [Picture] -> IO ()

-- | Output a picture to an EPS (Encapsulated PostScript) file. The .eps
--   file can then be imported or embedded in another document.
writeEPS :: FilePath -> Picture -> IO ()
instance Monad PsMonad
instance Applicative PsMonad
instance Functor PsMonad


-- | Output SVG.
--   
--   Note - the coordinate systems of Wumpus and SVG are different.
--   
--   <pre>
--   Wumpus - (0,0) is bottom-left.
--   </pre>
--   
--   <pre>
--   SVG - (0,0) is top-left.
--   </pre>
--   
--   To accommodate this, Wumpus adds rectifying matrix transformations to
--   the generated SVG code.
module Wumpus.Core.OutputSVG

-- | Output a picture to a SVG file.
writeSVG :: FilePath -> Picture -> IO ()

-- | <a>writeSVG_defs</a> : <tt> file_name -&gt; defs -&gt; picture -&gt;
--   IO () </tt>
--   
--   Output a picture to a SVG file the supplied <i>defs</i> are written
--   into the defs section of SVG file verbatim.
--   
--   This is considered an experimental feature, use <a>writeSVG</a>
--   instead.
writeSVG_defs :: FilePath -> String -> Picture -> IO ()
instance Eq FontMatch
instance Show FontMatch
instance Ord FontMatch
instance Monad SvgMonad
instance Applicative SvgMonad
instance Functor SvgMonad


-- | Common interface to Wumpus.Core.
--   
--   This is a <i>shim</i> module re-exporting types and functions from the
--   exposed Wumpus-Core modules. In most cases, importing just this module
--   should be sufficient to use Wumpus-Core.
--   
--   Named colours ( black, white etc.) are hidden from the module
--   <a>Wumpus.Core.Colour</a> to avoid collisions with modules that define
--   colour sets (e.g. all the SVG colours). If named colours are needed,
--   <a>Wumpus.Core.Colour</a> can be imported directly.
--   
--   Courier metrics (charWidth, textHeight, etc.) are hidden from the
--   module <a>Wumpus.Core.FontSize</a>. As these metrics are somewhat
--   approximate, it is expected that if higher-level software needs these
--   functionality it should define its own implementations. However the
--   functions may be convenient and if they are needed,
--   <a>Wumpus.Core.FontSize</a> can be imported directly.
module Wumpus.Core
