-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell functionality for quickly assembling simple compilers.
--   
--   Haskell monad and combinators for quickly assembling simple
--   compilation algorithms.
@package compilation
@version 0.0.0.3


-- | Compilation Monad and combinators for quickly assembling simple
--   compilers.
--   
--   <pre>
--   Control/Compilation.hs
--   </pre>
--   
--   A generic compilation monad for quickly assembling simple compilers.
module Control.Compilation

-- | Data types, class declarations, and class memberships.
class StateExtension a
initial :: StateExtension a => a

-- | State data structure wrapper.
data State a
State :: a -> State a
type Compile a b = Compilation a b
data Compilation a b
Compilation :: (State a -> (State a, b)) -> Compilation a b
Error :: String -> Compilation a b

-- | Generic combinators and functions.
extract :: StateExtension a => Compilation a b -> a
extractFromState :: StateExtension a => a -> Compilation a b -> a
nothing :: Compilation a ()
get :: StateExtension a => Compilation a a
set :: StateExtension a => a -> Compilation a ()
error :: String -> Compilation a ()
instance StateExtension ()
instance StateExtension a => Monad (Compilation a)


-- | Compilation Monad and combinators for quickly assembling simple
--   compilers.
--   
--   <pre>
--   Control/Compilation/Fresh.hs
--   </pre>
--   
--   State extension class and combinators for implementations of a state
--   that support generation of fresh (i.e., unique) values (integers and
--   strings).
module Control.Compilation.Fresh

-- | Type synonyms and class memberships.
type FreshIndex = Integer
type StateExtensionFresh = FreshIndex

-- | State extension class definition, including combinators and convenient
--   synonyms.
class StateExtension a => HasFresh a where freshInteger = do { s <- get; i <- return $ project s; set $ inject (i + 1) s; return $ i } freshString = do { i <- freshInteger; return $ show i } freshStringWithPrefix prefix = do { s <- freshString; return $ prefix ++ s } freshWithPrefix = freshStringWithPrefix fresh = freshString fresh_ = freshStringWithPrefix freshes i = do { ns <- mapM (\ _ -> fresh) [0 .. i - 1]; return $ [show n | n <- ns] } freshes_ prefix i = do { ns <- mapM (\ _ -> fresh) [0 .. i - 1]; return $ [prefix ++ show n | n <- ns] }
project :: HasFresh a => a -> StateExtensionFresh
inject :: HasFresh a => StateExtensionFresh -> a -> a
freshInteger :: HasFresh a => Compilation a Integer
freshString :: HasFresh a => Compilation a String
freshStringWithPrefix :: HasFresh a => String -> Compilation a String
freshWithPrefix :: HasFresh a => String -> Compilation a String
fresh :: HasFresh a => Compilation a String
fresh_ :: HasFresh a => String -> Compilation a String
freshes :: HasFresh a => Integer -> Compilation a [String]
freshes_ :: HasFresh a => String -> Integer -> Compilation a [String]
instance StateExtension StateExtensionFresh


-- | Compilation Monad and combinators for quickly assembling simple
--   compilers.
--   
--   <pre>
--   Control/Compilation/Module.hs
--   </pre>
--   
--   State extension class and combinators for implementations of a state
--   that support module name specification.
module Control.Compilation.Module

-- | Type synonyms and class memberships.
type ModuleName = String
type StateExtensionModule = ModuleName

-- | State extension class definition, including combinators.
class StateExtension a => HasModule a where setModule m = do { s <- get; set $ inject m s } getModule = do { s <- get; return $ project s }
project :: HasModule a => a -> StateExtensionModule
inject :: HasModule a => StateExtensionModule -> a -> a
setModule :: HasModule a => String -> Compilation a ()
getModule :: HasModule a => Compilation a String


-- | Compilation Monad and combinators for quickly assembling simple
--   compilers.
--   
--   <pre>
--   Control/Compilation/Environment.hs
--   </pre>
--   
--   State extension class and combinators for implementations of a state
--   that support an environment (i.e., lookup table or dictionary) data
--   structure or structures.
module Control.Compilation.Environment

-- | Type synonyms and class memberships.
type StateExtensionEnv a = [(String, a)]

-- | State extension class definition.
class StateExtension a => HasEnvironment a b where addEnv v x = do { s :: a <- get; env :: StateExtensionEnv b <- return $ project s; set $ inject ((v, x) : env) s } popEnv = do { s :: a <- get; env :: StateExtensionEnv b <- return $ project s; set $ inject (tail env) s } dropEnv n = do { s :: a <- get; env :: StateExtensionEnv b <- return $ project s; set $ inject (drop n env) s } lookupEnv v = do { s :: a <- get; env :: StateExtensionEnv b <- return $ project s; return $ lookup v env } setEnv env = do { s :: a <- get; set $ inject env s } getEnv = do { s :: a <- get; env :: StateExtensionEnv b <- return $ project s; return $ env }
project :: HasEnvironment a b => a -> StateExtensionEnv b
inject :: HasEnvironment a b => StateExtensionEnv b -> a -> a
addEnv :: HasEnvironment a b => String -> b -> Compilation a ()
popEnv :: HasEnvironment a b => Compilation a ()
dropEnv :: HasEnvironment a b => Int -> Compilation a ()
lookupEnv :: HasEnvironment a b => String -> Compilation a (Maybe b)
setEnv :: HasEnvironment a b => StateExtensionEnv b -> Compilation a ()
getEnv :: HasEnvironment a b => Compilation a (StateExtensionEnv b)
instance StateExtension (StateExtensionEnv a)


-- | Compilation Monad and combinators for quickly assembling simple
--   compilers.
--   
--   <pre>
--   Control/Compilation/String.hs
--   </pre>
--   
--   A generic compilation monad and combinators for quickly assembling
--   simple compilers that emit an ASCII string representation of the
--   target language (well-suited for direct syntax translators).
module Control.Compilation.String

-- | Type synonyms and class memberships.
type Indentation = Integer
type StateExtensionString = (Indentation, String)

-- | State extension class definition, including combinators and convenient
--   synonyms for compiling directly into a raw ASCII string.
class StateExtension a => HasString a where indent = do { state <- get; (i, s) <- return $ project state; set $ inject (i + 2, s) state } unindent = do { state <- get; (i, s) <- return $ project state; set $ inject (max 0 (i - 2), s) state } space = do { state <- get; (i, s) <- return $ project state; set $ inject (i, s ++ " ") state } spaces k = do { state <- get; (i, s) <- return $ project state; set $ inject (i, s ++ (take k $ repeat ' ')) state } newline = do { state <- get; (i, s) <- return $ project state; set $ inject (i, s ++ "" ++ (take (fromInteger i) $ repeat ' ')) state } newlines k = do { state <- get; (i, s) <- return $ project state; set $ inject (i,  s ++ (take k $ repeat '\n') ++ (take (fromInteger i) $ repeat ' ')) state } string s' = do { state <- get; (i, s) <- return $ project state; set $ inject (i, s ++ s') state } raw = string compiled c = let (_, s) :: StateExtensionString = project (extract c) in s
project :: HasString a => a -> StateExtensionString
inject :: HasString a => StateExtensionString -> a -> a
indent :: HasString a => Compilation a ()
unindent :: HasString a => Compilation a ()
space :: HasString a => Compilation a ()
spaces :: HasString a => Int -> Compilation a ()
newline :: HasString a => Compilation a ()
newlines :: HasString a => Int -> Compilation a ()
string :: HasString a => String -> Compilation a ()
raw :: HasString a => String -> Compilation a ()
compiled :: HasString a => Compilation a b -> String
instance StateExtension StateExtensionString


-- | Compilation Monad and combinators for quickly assembling simple
--   compilers.
--   
--   <pre>
--   Control/Compilation/Sequences.hs
--   </pre>
--   
--   A generic compilation monad for quickly assembling simple compilers
--   for target languages that are primarily sequences of instructions
--   (possibly with nesting, e.g., loop constructs or procedures).
module Control.Compilation.Sequences

-- | Type synonyms and class memberships.
type StateExtensionSequences a = [[a]]

-- | State extension class definition, and combinators for compiling into a
--   sequence (possibly with nested blocks) of instructions.
class StateExtension a => HasSequences a b where nest xs = do { s :: a <- get; xss :: StateExtensionSequences b <- return $ project s; set $ inject (xs : xss) s } unnest = do { s :: a <- get; xs :: StateExtensionSequences b <- return $ project s; set $ inject (tail $ xs) s; return $ head $ project s } depth = do { s <- get; xss :: StateExtensionSequences b <- return $ project s; return $ toInteger $ length xss }
project :: HasSequences a b => a -> StateExtensionSequences b
inject :: HasSequences a b => StateExtensionSequences b -> a -> a
nest :: HasSequences a b => [b] -> Compilation a ()
unnest :: HasSequences a b => Compilation a [b]
depth :: HasSequences a b => Compilation a Integer
instance StateExtension (StateExtensionSequences a)


-- | Compilation Monad and combinators for quickly assembling simple
--   compilers.
--   
--   <pre>
--   Control/Compilation/Trees.hs
--   </pre>
--   
--   A generic compilation monad for quickly assembling simple compilers
--   for target languages that are primarily expression trees.
module Control.Compilation.Trees
