-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Dynamic linking for embedded DSLs with staged compilation
--   
@package plugins-multistage
@version 0.6.1


-- | Generic components
module System.Plugins.MultiStage

-- | Generic function compiler and loader
loadFunWithConfig :: Config -> [Name] -> Q [Dec]

-- | Extract the type of the supplied function name
loadFunType :: Name -> Q Type

-- | Configuration parameters for the function loader
data Config
Config :: (Config -> Name -> Name -> [Name] -> Type -> [DecQ]) -> (Config -> Name -> Q Body) -> (Name -> [Name] -> Q Body) -> (Name -> Q Type) -> (Type -> Q Type) -> (Type -> Q Type) -> String -> String -> String -> [String] -> Safety -> Config
declWorker :: Config -> Config -> Name -> Name -> [Name] -> Type -> [DecQ]
builder :: Config -> Config -> Name -> Q Body
worker :: Config -> Name -> [Name] -> Q Body
typeFromName :: Config -> Name -> Q Type
mkHSig :: Config -> Type -> Q Type
mkCSig :: Config -> Type -> Q Type
prefix :: Config -> String
suffix :: Config -> String
wdir :: Config -> String
opts :: Config -> [String]
safety :: Config -> Safety
defaultConfig :: Config

-- | Build, load and link a C file
defaultBuilder :: Config -> Name -> Q Body

-- | The Calling Convention specifies how a type should be converted
data CallConv
CallConv :: (Type -> Q Type) -> (Type -> Q Type) -> CallConv

-- | Convert an argument
arg :: CallConv -> Type -> Q Type

-- | Convert the result
res :: CallConv -> Type -> Q Type

-- | Convert a type using the supplied calling convention
buildType :: CallConv -> Type -> Q Type

-- | Apply a type family
applyTF :: Name -> Type -> Q Type

-- | Expand type families
expandTF :: Type -> Q Type

-- | Pack a value into its runtime representation
--   
--   <pre>
--   pack a = to a &gt;&gt;= ref
--   </pre>
pack :: (Reference (Rep a), Marshal a) => a -> IO (Ref (Rep a))

-- | Unpack a value from its runtime representation
--   
--   <pre>
--   unpack a = deref a &gt;&gt;= from
--   </pre>
unpack :: (Reference (Rep a), Marshal a) => Ref (Rep a) -> IO a

-- | Optionally make a refrence of a value
class Reference a where type family Ref a :: * ref = return deref = return
ref :: Reference a => a -> IO (Ref a)
deref :: Reference a => Ref a -> IO a

-- | Convert between Haskell and representation types
class Marshal a where type family Rep a :: * to = return from = return
to :: Marshal a => a -> IO (Rep a)
from :: Marshal a => Rep a -> IO a
instance Marshal Double
instance Marshal Float
instance Marshal Word64
instance Marshal Word32
instance Marshal Word16
instance Marshal Word8
instance Marshal Int64
instance Marshal Int32
instance Marshal Int16
instance Marshal Int8
instance Marshal Bool
instance Reference Double
instance Reference Float
instance Reference Word64
instance Reference Word32
instance Reference Word16
instance Reference Word8
instance Reference Int64
instance Reference Int32
instance Reference Int16
instance Reference Int8
instance Reference Bool
