-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Heterogeneous lists
--   
@package HList
@version 0.4.0.0


-- | The HList library
--   
--   (C) 2004, Oleg Kiselyov, Ralf Laemmel, Keean Schupke
--   
--   Some very basic technology for faking dependent types in Haskell.
module Data.HList.FakePrelude

-- | simpler/weaker version where type information only propagates forward
--   with this one. <a>applyAB</a> defined below, is more complicated /
--   verbose to define, but it offers better type inference. Most uses have
--   been converted to <a>applyAB</a>, so there is not much that can be
--   done with <a>Apply</a>.
class Apply f a where type family ApplyR f a :: *
apply :: Apply f a => f -> a -> ApplyR f a

-- | No constraints on result and argument types
class ApplyAB f a b
applyAB :: ApplyAB f a b => f -> a -> b
data Fun (cxt :: k1) (getb :: k2)
Fun :: (forall a. FunCxt cxt a => a -> FunApp getb a) -> Fun

-- | see <a>Fun</a>. The only difference here is that the argument type is
--   calculated from the result type.
--   
--   <pre>
--   &gt;&gt;&gt; let rd = Fun' read :: Fun' Read String
--   
--   &gt;&gt;&gt; :t applyAB rd
--   applyAB rd :: Read b =&gt; [Char] -&gt; b
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let fromJust' = Fun' (\(Just a) -&gt; a) :: Fun' '[] Maybe
--   
--   &gt;&gt;&gt; :t applyAB fromJust'
--   applyAB fromJust' :: Maybe b -&gt; b
--   </pre>
--   
--   Note this use of Fun' means we don't have to get the b out of
--   <tt>Maybe b</tt>,
data Fun' (cxt :: k1) (geta :: k2)
Fun' :: (forall b. FunCxt cxt b => FunApp geta b -> b) -> Fun'

-- | note this function will only be available at a single type (that is,
--   <tt>hMap succ</tt> will only work on <tt>HList</tt> that contain only
--   one type)

-- | print. An alternative implementation could be:
--   
--   <pre>
--   &gt;&gt;&gt; let hPrint = Fun print :: Fun Show (IO ())
--   </pre>
--   
--   This produces:
--   
--   <pre>
--   &gt;&gt;&gt; :t applyAB hPrint
--   applyAB hPrint :: Show a =&gt; a -&gt; IO ()
--   </pre>
data HPrint
HPrint :: HPrint

-- | read
--   
--   <pre>
--   &gt;&gt;&gt; applyAB HRead "5.0" :: Double
--   5.0
--   </pre>
data HRead
HRead :: HRead

-- | show
data HShow
HShow :: HShow

-- | Compose two instances of <a>ApplyAB</a>
--   
--   <pre>
--   &gt;&gt;&gt; applyAB (HComp HRead HShow) (5::Double) :: Double
--   5.0
--   </pre>
data HComp g f

-- | <pre>
--   g . f
--   </pre>
HComp :: g -> f -> HComp g f

-- | <tt>app Comp (f,g) = g . f</tt>. Works like:
--   
--   <pre>
--   &gt;&gt;&gt; applyAB Comp (succ, pred) 'a'
--   'a'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; applyAB Comp (toEnum :: Int -&gt; Char, fromEnum) 10
--   10
--   </pre>
--   
--   Note that defaulting will sometimes give you the wrong thing
--   
--   <pre>
--   used to work (with associated types calculating result/argument types)
--   &gt;&gt;&gt; applyAB Comp (fromEnum, toEnum) 'a'
--   *** Exception: Prelude.Enum.().toEnum: bad argument
--   </pre>
data Comp
Comp :: Comp

-- | ((a,b) -&gt; f a &gt;&gt; b)
newtype HSeq x
HSeq :: x -> HSeq x

-- | <tt>HJust ()</tt> is a placeholder for a function that applies the
--   <a>HJust</a> constructor

-- | <a>flip</a>
data HFlip
HFlip :: HFlip

-- | <a>fmap</a>
newtype HFmap f
HFmap :: f -> HFmap f

-- | <a>liftA2</a>
newtype LiftA2 f
LiftA2 :: f -> LiftA2 f

-- | <a>untag</a>
data HUntag
HUntag :: HUntag

-- | A special <a>Proxy</a> for record labels, polykinded
data Label l
Label :: Label l
labelToProxy :: Label l -> Proxy l
class ShowLabel l
showLabel :: ShowLabel l => Label l -> String
hTrue :: Proxy True
hFalse :: Proxy False

-- | <tt>demote</tt> to values
hAnd :: Proxy t1 -> Proxy t2 -> Proxy (HAnd t1 t2)

-- | <tt>demote</tt> to values
hOr :: Proxy t1 -> Proxy t2 -> Proxy (HOr t1 t2)

-- | as compared with <a>HNot</a> this version is injective
class HNotFD (b :: Bool) (nb :: Bool) | b -> nb, nb -> b
hNot :: HNotFD a notA => Proxy a -> Proxy notA
class HCond (t :: Bool) x y z | t x y -> z
hCond :: HCond t x y z => Proxy t -> x -> y -> z

-- | The data type to be lifted to the type level
data HNat
HZero :: HNat
HSucc :: HNat -> HNat
hZero :: Proxy HZero
hSucc :: Proxy (n :: HNat) -> Proxy (HSucc n)
hPred :: Proxy (HSucc n) -> Proxy n
class HNat2Integral (n :: HNat)
hNat2Integral :: (HNat2Integral n, Integral i) => Proxy n -> i
class HNats2Integrals (ns :: [HNat])
hNats2Integrals :: (HNats2Integrals ns, Integral i) => Proxy ns -> [i]

-- | Equality on natural numbers (eventually to be subsumed by the
--   universal polykinded HEq)

-- | Less than
hLt :: Proxy x -> Proxy y -> Proxy (HLt x y)

-- | Less than or equal to
hLe :: Proxy x -> Proxy y -> Proxy (HLe x y)

-- | <tt>HDiv2 x</tt> behaves like <tt>x <a>div</a> 2</tt>
data HNothing
HNothing :: HNothing
newtype HJust x
HJust :: x -> HJust x

-- | We have to use Functional dependencies for now, for the sake of the
--   generic equality.
class HEq (x :: k) (y :: k) (b :: Bool) | x y -> b

-- | Equality for types that may have different kinds. This definition
--   allows operations on <tt>Record [Tagged "x" a, Tagged 2 b]</tt> to
--   work as expected.
type HEqK (x :: k1) (y :: k2) (b :: Bool) = HEq (Proxy x) (Proxy y) b
hEq :: HEq x y b => x -> y -> Proxy b

-- | this class generalizes HEq by allowing the choice of <tt>f</tt> to
--   allow equating only part of x and y
class HEqByFn f => HEqBy (f :: t) (x :: k) (y :: k) (b :: Bool) | f x y -> b

-- | Every instance of this class should have an instance of <a>HEqBy</a>
class HEqByFn f
type Arity f n = (ArityFwd f n, ArityRev f n)

-- | calculate the number of arguments a function can take
class ArityFwd (f :: *) (n :: HNat) | f -> n

-- | given the number of arguments a function can take, make sure the
--   function type actually matches
class ArityRev (f :: *) (n :: HNat)

-- | Named after <a>cast</a>, which behaves the same at runtime. One
--   difference is that there is a HCast instance for every type, while
--   <a>Typeable</a> instances can be missing sometimes.
class HCast x y
hCast :: HCast x y => x -> Maybe y

-- | helper for <a>HCast</a>
class HCast1 (b :: Bool) x y
hCast1 :: HCast1 b x y => Proxy b -> x -> Maybe y

-- | A class without instances for explicit failure
class Fail x
data ExtraField l
data FieldNotFound l
type TypeablePolyK (a :: k) = Typeable a

-- | Ensure two lists have the same length. We do case analysis on the
--   first one (hence the type must be known to the type checker). In
--   contrast, the second list may be a type variable.
class SameLength' (es1 :: [k]) (es2 :: [m])

-- | symmetrical version of <a>SameLength'</a>. Written as a class instead
--   of
--   
--   <pre>
--   type SameLength a b = (SameLength' a b, SameLength' b a)
--   </pre>
--   
--   since ghc expands type synonyms, but not classes (and it seems to have
--   the same result)
class (SameLength' x y, SameLength' y x) => SameLength (x :: [k]) (y :: [m]) where sameLength = id
sameLength :: SameLength x y => r x `p` f (q y) -> r x `p` f (q y)
asLengthOf :: SameLength x y => r x -> s y -> r x
class SameLabels (x :: k) (y :: m)

-- | <tt>sameLabels</tt> constrains the type of an optic, such that the
--   labels (<tt>t</tt> in <tt>Tagged t a</tt>) are the same. <tt>x</tt> or
--   <tt>y</tt> may have more elements than the other, in which case the
--   elements at the end of the longer list do not have their labels
--   constrained.
--   
--   see also <a>sameLength</a>
sameLabels :: SameLabels x y => p (r x) (f (q y)) -> p (r x) (f (q y))

-- | The <tt>Record</tt>, <tt>Variant</tt>, <tt>TIP</tt>, <tt>TIC</tt> type
--   constructors only make sense when they are applied to an instance of
--   this class
class HAllTaggedLV (ps :: [*])

-- | see Data.HList.Record.<tt>zipTagged</tt>

-- | The class of monoids (types with an associative binary operation that
--   has an identity). Instances should satisfy the following laws:
--   
--   <ul>
--   <li><pre>mappend mempty x = x</pre></li>
--   <li><pre>mappend x mempty = x</pre></li>
--   <li><pre>mappend x (mappend y z) = mappend (mappend x y) z</pre></li>
--   <li><pre>mconcat = <a>foldr</a> mappend mempty</pre></li>
--   </ul>
--   
--   The method names refer to the monoid of lists under concatenation, but
--   there are many other instances.
--   
--   Minimal complete definition: <a>mempty</a> and <a>mappend</a>.
--   
--   Some types can be viewed as a monoid in more than one way, e.g. both
--   addition and multiplication on numbers. In such cases we often define
--   <tt>newtype</tt>s and make those instances of <a>Monoid</a>, e.g.
--   <a>Sum</a> and <a>Product</a>.
class Monoid a
mempty :: Monoid a => a
mappend :: Monoid a => a -> a -> a
mconcat :: Monoid a => [a] -> a
instance Show HNothing
instance Show x => Show (HJust x)
instance (HAllTaggedLV xs, x ~ Tagged t v) => HAllTaggedLV (x : xs)
instance HAllTaggedLV '[]
instance SameLabels (Label t) s => SameLabels (Tagged t a) s
instance SameLabels (Label t) s => SameLabels t s
instance Label t ~ Label t' => SameLabels (Label t) t'
instance Label t ~ Label t' => SameLabels (Label t) (Label t')
instance Label t ~ Label t' => SameLabels (Label t) (Tagged t' a)
instance (SameLabels x y, SameLabels xs ys) => SameLabels (x : xs) (y : ys)
instance SameLabels (x : xs) '[]
instance SameLabels '[] (x : xs)
instance SameLabels '[] '[]
instance (SameLength' x y, SameLength' y x) => SameLength x y
instance (SameLength' xs ys, es2 ~ (y : ys)) => SameLength' (x : xs) es2
instance es2 ~ '[] => SameLength' '[] es2
instance HCast1 'False x y
instance x ~ y => HCast1 'True x y
instance (HEq x y b, HCast1 b x y) => HCast x y
instance (xf ~ (x -> f), ArityRev f n) => ArityRev xf ('HSucc n)
instance ArityRev f 'HZero
instance (HNats2Integrals ns, HNat2Integral n) => HNats2Integrals (n : ns)
instance HNats2Integrals '[]
instance HNat2Integral n => HNat2Integral ('HSucc n)
instance HNat2Integral 'HZero
instance HCond 'True x y x
instance HCond 'False x y y
instance HNotFD 'False 'True
instance HNotFD 'True 'False
instance Tagged t x ~ tx => ApplyAB HUntag tx x
instance (ApplyAB f (x, y) z, mz ~ m z, mxy ~ (m x, m y), Applicative m) => ApplyAB (LiftA2 f) mxy mz
instance (x ~ t a, y ~ t b, Functor t, ApplyAB f a b) => ApplyAB (HFmap f) x y
instance (f1 ~ (a -> b -> c), f2 ~ (b -> a -> c)) => ApplyAB HFlip f1 f2
instance hJustA ~ HJust a => ApplyAB (HJust t) a hJustA
instance (Monad m, ApplyAB f x fx, fx ~ m (), pair ~ (x, m ()), ApplyAB f x (m ())) => ApplyAB (HSeq f) pair fx
instance (y ~ y', fg ~ (x -> y, y' -> z), r ~ (x -> z)) => ApplyAB Comp fg r
instance (ApplyAB f a b, ApplyAB g b c) => ApplyAB (HComp g f) a c
instance (String ~ string, Show a) => ApplyAB HShow a string
instance (String ~ string, Read a) => ApplyAB HRead string a
instance (io ~ IO (), Show x) => ApplyAB HPrint x io
instance (x' ~ x, y' ~ y) => ApplyAB (x' -> y') x y
instance (FunCxt cxt b, FunApp geta b ~ a) => ApplyAB (Fun' cxt geta) a b
instance (FunCxt cxt a, FunApp getb a ~ b) => ApplyAB (Fun cxt getb) a b


-- | The HList library
--   
--   (C) 2004, Oleg Kiselyov, Ralf Laemmel, Keean Schupke
--   
--   Declarations for various classes and functions that apply for the
--   whole range of heterogeneous collections (HList, TIP, records, etc).
module Data.HList.HListPrelude
class HExtend e l where type family HExtendR e l
(.*.) :: HExtend e l => e -> l -> HExtendR e l

-- | to keep types shorter, <a>.*.</a> used with Proxy avoids producing a
--   <tt>Proxy :: Proxy '[Label x,Label y,Label z]</tt> if <tt>Proxy ::
--   Proxy '[x,y,z]</tt> is not a kind error (as it is when mixing Label6
--   and Label3 labels).
--   
--   ghc-7.6 does not accept <tt>Proxy ('[] :: [k])</tt> so for now require
--   <tt>k ~ *</tt>

-- | similar to <tt>emptyRecord</tt>, <tt>emptyTIP</tt>, emptyHList
--   (actually called <tt>HNil</tt>), except emptyProxy is the rightmost
--   argument to <a>.*.</a>
emptyProxy :: Proxy [*] ([] *)
class SubType l l'
class HAppend l1 l2
hAppend :: HAppend l1 l2 => l1 -> l2 -> HAppendR l1 l2

-- | poly-kinded, but <a>hAppend</a> only works in cases where the kind
--   variable <tt>k</tt> is <a>*</a>
class HOccurs e l
hOccurs :: HOccurs e l => l -> e
class HOccursNot (e :: k) (l :: [k])
class HProject l l'
hProject :: HProject l l' => l -> l'

-- | Map a type (key) to a natural (index) within the collection This is a
--   purely type-level computation
class HType2HNat (e :: k) (l :: [k]) (n :: HNat) | e l -> n
class HTypes2HNats es l (ns :: [HNat]) | es l -> ns

-- | Delete all elements with the type-level key e from the collection l.
--   Since the key is type-level, it is represented by a Proxy.
--   (polykinded)
class HDeleteMany e l l' | e l -> l'
hDeleteMany :: HDeleteMany e l l' => Proxy e -> l -> l'
class HDeleteAtLabel (r :: [*] -> *) (l :: k) v v' | l v -> v'
hDeleteAtLabel :: HDeleteAtLabel r l v v' => Label l -> r v -> r v'

-- | <a>unzip</a>
class SameLengths '[x, y, xy] => HUnzip (r :: [*] -> *) x y xy | x y -> xy, xy -> x y
hUnzip :: HUnzip r x y xy => r xy -> (r x, r y)

-- | <a>zip</a>. Variant supports hUnzip, but not hZip
--   (<tt>hZipVariant</tt> returns a Maybe)
class HUnzip r x y xy => HZip (r :: [*] -> *) x y xy
hZip :: HZip r x y xy => r x -> r y -> r xy
instance HExtend (Label x) (Proxy '[])


-- | The HList library
--   
--   (C) 2004, Oleg Kiselyov, Ralf Laemmel, Keean Schupke
--   
--   Basic declarations for typeful heterogeneous lists.
--   
--   Excuse the unstructured haddocks: while there are many declarations
--   here some are alternative implementations should be grouped, and the
--   definitions here are analgous to many list functions in the
--   <a>Prelude</a>.
module Data.HList.HList

-- | creates a HList of Proxies
class HProxiesFD (xs :: [*]) pxs | pxs -> xs, xs -> pxs
hProxies :: HProxiesFD xs pxs => HList pxs
type HProxies xs = HProxiesFD xs (AddProxy xs)

-- | Add <a>Proxy</a> to a type
--   
--   <pre>
--   &gt;&gt;&gt; let x = undefined :: HList (AddProxy [Char,Int])
--   
--   &gt;&gt;&gt; :t x
--   x :: HList '[Proxy Char, Proxy Int]
--   </pre>

-- | inverse of <a>AddProxy</a>
data ReadElement
ReadElement :: ReadElement

-- | <a>head</a>
hHead :: HList (e : l) -> e

-- | <a>tail</a>
hTail :: HList (e : l) -> HList l

-- | <a>last</a>
hLast :: HRevApp l1 ([] *) ((:) * e l) => HList l1 -> e
class HInit xs where type family HInitR xs :: [*]
hInit :: HInit xs => HList xs -> HList (HInitR xs)

-- | Length, but see <a>HLengthEq</a> instead
hLength :: HLengthEq l n => HList l -> Proxy n
class HAppendList l1 l2
hAppendList :: HAppendList l1 l2 => HList l1 -> HList l2 -> HList (HAppendListR l1 l2)

-- | <a>hAppend'</a> below is implemented using the same idea
append' :: [a] -> [a] -> [a]

-- | Alternative implementation of <a>hAppend</a>. Demonstrates
--   <a>HFoldr</a>
hAppend' :: HFoldr FHCons v l r => HList l -> v -> r
data FHCons
FHCons :: FHCons
class HRevApp l1 l2 l3 | l1 l2 -> l3
hRevApp :: HRevApp l1 l2 l3 => HList l1 -> HList l2 -> HList l3
class HReverse xs sx | xs -> sx, sx -> xs
hReverse :: HReverse xs sx => HList xs -> HList sx

-- | a version of <a>hReverse</a> that does not allow the type information
--   to flow backwards
hReverse_ :: HRevApp l1 ([] *) l3 => HList l1 -> HList l3

-- | Note:
--   
--   <ul>
--   <li><i><tt>x :: HList a</tt></i> means: <tt>forall a. x :: HList
--   a</tt><ul><li><i><tt>hEnd x</tt></i> means: <tt>exists a. x :: HList
--   a</tt></li></ul></li>
--   </ul>
--   
--   List termination
hEnd :: HList l -> HList l

-- | Building lists
hBuild :: HBuild' [] r => r
class HBuild' l r
hBuild' :: HBuild' l r => HList l -> r
class HFoldr f v (l :: [*]) r
hFoldr :: HFoldr f v l r => f -> v -> HList l -> r

-- | uses <a>ApplyAB</a> not <a>Apply</a>
class HScanr f z ls rs
hScanr :: HScanr f z ls rs => f -> z -> HList ls -> HList rs
class HFoldr1 f (l :: [*]) r
hFoldr1 :: HFoldr1 f l r => f -> HList l -> r

-- | uses <a>ApplyAB</a> not <a>Apply</a>

-- | like <a>foldl</a>
--   
--   <pre>
--   &gt;&gt;&gt; hFoldl (uncurry $ flip (:)) [] (1 `HCons` 2 `HCons` HNil)
--   [2,1]
--   </pre>
class HFoldl f (z :: *) xs (r :: *)
hFoldl :: HFoldl f z xs r => f -> z -> HList xs -> r
hUnfold :: (HUnfoldFD f (ApplyR f a) z, Apply f a) => f -> a -> HList z
type HUnfold p s = HUnfoldR p (ApplyR p s)
type HUnfold' p res = HUnfoldFD p (ApplyR p res) (HUnfold p res)
class HUnfoldFD p res z | p res -> z
hUnfold' :: HUnfoldFD p res z => p -> res -> HList z

-- | Sometimes the result type can fix the type of the first argument:
--   
--   <pre>
--   &gt;&gt;&gt; hReplicate Proxy () :: HList '[ (), (), () ]
--   H[(),(),()]
--   </pre>
--   
--   However, with HReplicate all elements must have the same type, so it
--   may be easier to use <a>HList2List</a>:
--   
--   <pre>
--   &gt;&gt;&gt; list2HList (repeat 3) :: Maybe (HList [Int, Int, Int])
--   Just H[3,3,3]
--   </pre>
class HLengthEq es n => HReplicateFD (n :: HNat) e es | n e -> es, es -> n
hReplicate :: HReplicateFD n e es => Proxy n -> e -> HList es
type HReplicate n e = HReplicateFD n e (HReplicateR n e)

-- | would be associated with <a>HReplicate</a> except we want it to work
--   with <tt>e</tt> of any kind, not just <a>*</a> that you can put into a
--   HList. An "inverse" of <a>HLength</a>

-- | HReplicate produces lists that can be converted to ordinary lists
--   
--   <pre>
--   &gt;&gt;&gt; let two = hSucc (hSucc hZero)
--   
--   &gt;&gt;&gt; let f = Fun' fromInteger :: Fun' Num Integer
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :t applyAB f
--   applyAB f :: Num b =&gt; Integer -&gt; b
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hReplicateF two f 3
--   H[3,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hReplicateF Proxy f 3 :: HList [Int, Double, Integer]
--   H[3,3.0,3]
--   </pre>
class HLengthEq r n => HReplicateF (n :: HNat) f z r | r -> n
hReplicateF :: (HReplicateF n f z r, HLengthEq r n) => Proxy n -> f -> z -> HList r

-- | This function behaves like <a>iterate</a>, with an extra argument to
--   help figure out the result length
--   
--   <pre>
--   &gt;&gt;&gt; let three = hSucc (hSucc (hSucc hZero))
--   
--   &gt;&gt;&gt; let f = Fun Just :: Fun '() Maybe
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :t applyAB f
--   applyAB f :: a -&gt; Maybe a
--   </pre>
--   
--   f is applied to different types: &gt;&gt;&gt; hIterate three f ()
--   H[(),Just (),Just (Just ())]
--   
--   It is also possible to specify the length later on, as done with
--   Prelude.<a>iterate</a>
--   
--   <pre>
--   &gt;&gt;&gt; let take3 x | _ &lt;- hLength x `asTypeOf` three = x
--   
--   &gt;&gt;&gt; take3 $ hIterate Proxy f ()
--   H[(),Just (),Just (Just ())]
--   </pre>
class HLengthEq r n => HIterate n f z r
hIterate :: (HIterate n f z r, HLengthEq r n) => Proxy n -> f -> z -> HList r

-- | Like <a>concat</a> but for HLists of HLists.
--   
--   Works in ghci... puzzling as what is different in doctest (it isn't
--   <tt>-XExtendedDefaultRules</tt>)
--   
--   <pre>
--   hConcat $ hBuild (hBuild 1 2 3) (hBuild 'a' "abc")
--   </pre>
--   
--   H[1, 2, 3, <tt>a</tt>, "abc"]
class HConcat (a :: [*]) where type family HConcatR a :: [*]
hConcat :: HConcat a => HList a -> HList (HConcatR a)

-- | hMap is written such that the length of the result list can be
--   determined from the length of the argument list (and the other way
--   around). Similarly, the type of the elements of the list is propagated
--   in both directions too.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XNoMonomorphismRestriction
--   
--   &gt;&gt;&gt; let xs = 1 .*. 'c' .*. HNil
--   
--   &gt;&gt;&gt; :t hMap (HJust ()) xs
--   hMap (HJust ()) xs :: Num y =&gt; HList '[HJust y, HJust Char]
--   </pre>
--   
--   These 4 examples show that the constraint on the length (2 in this
--   case) can be applied before or after the <a>hMap</a>. That inference
--   is independent of the direction that type information is propagated
--   for the individual elements.
--   
--   <pre>
--   &gt;&gt;&gt; let asLen2 xs = xs `asTypeOf` (undefined :: HList '[a,b])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let lr xs = asLen2 (applyAB (HMap HRead) xs)
--   
--   &gt;&gt;&gt; let ls xs = asLen2 (applyAB (HMap HShow) xs)
--   
--   &gt;&gt;&gt; let rl xs = applyAB (HMap HRead) (asLen2 xs)
--   
--   &gt;&gt;&gt; let sl xs = applyAB (HMap HShow) (asLen2 xs)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :t lr
--   lr
--     :: (Read ..., Read ...) =&gt; HList '[String, String] -&gt; HList '[..., ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :t rl
--   rl
--     :: (Read ..., Read ...) =&gt; HList '[String, String] -&gt; HList '[..., ...]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :t ls
--   ls
--     :: (Show ..., Show ...) =&gt; HList '[..., ...] -&gt; HList '[String, String]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :t sl
--   sl
--     :: (Show ..., Show ...) =&gt; HList '[..., ...] -&gt; HList '[String, String]
--   </pre>
newtype HMap f
HMap :: f -> HMap f
hMap :: (HMapAux r f a b, SameLength' * * b a, SameLength' * * a b) => f -> r a -> r b

-- | hMap constrained to HList
hMapL :: (HMapAux HList f a b, SameLength' * * b a, SameLength' * * a b) => f -> HList a -> HList b
newtype HMapL f
HMapL :: f -> HMapL f
class (SameLength a b, HMapAux r f a b) => HMapCxt r f a b
class HMapAux (r :: [*] -> *) f (x :: [*]) (y :: [*])
hMapAux :: (HMapAux r f x y, SameLength x y) => f -> r x -> r y
newtype MapCar f
MapCar :: f -> MapCar f

-- | Same as <a>hMap</a> only a different implementation.
hMapMapCar :: HFoldr (MapCar f) (HList []) l l' => f -> HList l -> l'

-- | <pre>
--   &gt;&gt;&gt; let xs = length .*. (+1) .*. (*2) .*. HNil
--   
--   &gt;&gt;&gt; hComposeList xs "abc"
--   8
--   </pre>
hComposeList :: HFoldr Comp (a -> a) l (t -> a) => HList l -> t -> a

-- | A heterogeneous version of
--   
--   <pre>
--   sequenceA :: (Applicative m) =&gt; [m a] -&gt; m [a]
--   </pre>
--   
--   Only now we operate on heterogeneous lists, where different elements
--   may have different types <tt>a</tt>. In the argument list of monadic
--   values (m a_i), although a_i may differ, the monad <tt>m</tt> must be
--   the same for all elements. That's why we needed
--   <a>Data.HList.TypeCastGeneric2</a> (currently (~)). The typechecker
--   will complain if we attempt to use hSequence on a HList of monadic
--   values with different monads.
--   
--   The <a>hSequence</a> problem was posed by Matthias Fischmann in his
--   message on the Haskell-Cafe list on Oct 8, 2006
--   
--   
--   <a>http://www.haskell.org/pipermail/haskell-cafe/2006-October/018708.html</a>
--   
--   
--   <a>http://www.haskell.org/pipermail/haskell-cafe/2006-October/018784.html</a>
--   
--   <ul>
--   <li><i><tt>Maybe</tt></i></li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; hSequence $ Just (1 :: Integer) `HCons` (Just 'c') `HCons` HNil
--   Just H[1,'c']
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hSequence $  return 1 `HCons` Just  'c' `HCons` HNil
--   Just H[1,'c']
--   </pre>
--   
--   <ul>
--   <li><i><tt>List</tt></i></li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; hSequence $ [1] `HCons` ['c'] `HCons` HNil
--   [H[1,'c']]
--   </pre>
class (Applicative m, SameLength a b) => HSequence m a b | a -> b, m b -> a
hSequence :: HSequence m a b => HList a -> m (HList b)

-- | <a>hSequence2</a> is not recommended over <a>hSequence</a> since it
--   possibly doesn't allow inferring argument types from the result types.
--   Otherwise this version should do exactly the same thing.
--   
--   The DataKinds version needs a little help to find the type of the
--   return HNil, unlike the original version, which worked just fine as
--   
--   <pre>
--   hSequence l = hFoldr ConsM (return HNil) l
--   </pre>
hSequence2 :: (HFoldr (LiftA2 FHCons) (f (HList ([] *))) l (f a), Applicative f) => HList l -> f a
newtype Mapcar f
Mapcar :: f -> Mapcar f
type HMapOut f l e = HFoldr (Mapcar f) [e] l [e]

-- | compare <tt>hMapOut f</tt> with <tt><a>hList2List</a> . <a>hMap</a>
--   f</tt>
hMapOut :: HMapOut f l e => f -> HList l -> [e]

-- | <pre>
--   mapM :: forall b m a. (Monad m) =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]
--   </pre>
--   
--   Likewise for mapM_.
--   
--   See <a>hSequence</a> if the result list should also be heterogenous.
hMapM :: (Monad m, HMapOut f l (m e)) => f -> HList l -> [m e]

-- | GHC doesn't like its own type. hMapM_ :: forall m a f e. (Monad m,
--   HMapOut f a (m e)) =&gt; f -&gt; a -&gt; m () Without explicit type
--   signature, it's Ok. Sigh. Anyway, Hugs does insist on a better type.
--   So we restrict as follows:
hMapM_ :: (Monad m, HMapOut f l (m ())) => f -> HList l -> m ()

-- | We do so constructively, converting the HList whose elements are Proxy
--   HNat to [HNat]. The latter kind is unpopulated and is present only at
--   the type level.
hNats :: HList l -> Proxy (HNats l)

-- | Check to see if an HList contains an element with a given type This is
--   a type-level only test
class HMember (e1 :: k) (l :: [k]) (b :: Bool) | e1 l -> b
class HMember' (b0 :: Bool) (e1 :: k) (l :: [k]) (b :: Bool) | b0 e1 l -> b

-- | The following is a similar type-only membership test It uses the
--   user-supplied curried type equality predicate pred
hMember :: HMember e l b => Proxy e -> Proxy l -> Proxy b

-- | Check to see if an element e occurs in a list l If not, return
--   'Nothing If the element does occur, return 'Just l1 where l1 is a
--   type-level list without e
class HMemberM (e1 :: k) (l :: [k]) (r :: Maybe [k]) | e1 l -> r
class HMemberM1 (b :: Bool) (e1 :: k) (l :: [k]) (r :: Maybe [k]) | b e1 l -> r
class HMemberM2 (b :: Maybe [k]) (e1 :: k) (l :: [k]) (r :: Maybe [k]) | b e1 l -> r

-- | It is a pure type-level operation
class HFind1 e l n => HFind (e :: k) (l :: [k]) (n :: HNat) | e l -> n
class HFind1 (e :: k) (l :: [k]) (n :: HNat) | e l -> n
class HFind2 (b :: Bool) (e :: k) (l :: [k]) (n :: HNat) | b e l -> n

-- | could be an associated type if HEq had one
class HTMember e (l :: [*]) (b :: Bool) | e l -> b
hTMember :: HTMember e l b => e -> HList l -> Proxy b
class HTIntersect l1 l2 l3 | l1 l2 -> l3
hTIntersect :: HTIntersect l1 l2 l3 => HList l1 -> HList l2 -> HList l3
class HTIntersectBool (b :: Bool) h t l1 l2 | b h t l1 -> l2
hTIntersectBool :: HTIntersectBool b h t l1 l2 => Proxy b -> h -> HList t -> HList l1 -> HList l2

-- | <tt>hMapOut id</tt> is similar, except this function is restricted to
--   HLists that actually contain a value (so the list produced will be
--   nonempty). This restriction allows adding a functional dependency,
--   which means that less type annotations can be necessary.
class HList2List l e | l -> e
hList2List :: HList2List l e => HList l -> [e]
list2HListSuffix :: HList2List l e => [e] -> Maybe (HList l, [e])
list2HList :: HList2List l e => [e] -> Maybe (HList l)

-- | <pre>
--   Prism [s] [t] (HList s) (HList t)
--   </pre>
listAsHList :: (HList2List l1 e1, HList2List l e, Choice p, Applicative f) => p (HList l1) (f (HList l)) -> p [e1] (f [e])

-- | <pre>
--   Prism' [a] (HList s)
--   </pre>
--   
--   where <tt>s ~ HReplicateR n a</tt>
listAsHList' :: (HList2List l e, Choice p, Applicative f) => p (HList l) (f (HList l)) -> p [e] (f [e])

-- | the same as <tt>map Just</tt>
--   
--   <pre>
--   &gt;&gt;&gt; toHJust (2 .*. 'a' .*. HNil)
--   H[HJust 2,HJust 'a']
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toHJust2 (2 .*. 'a' .*. HNil)
--   H[HJust 2,HJust 'a']
--   </pre>
class FromHJustR (ToHJustR l) ~ l => ToHJust l where type family ToHJustR l :: [*]
toHJust :: ToHJust l => HList l -> HList (ToHJustR l)

-- | alternative implementation. The Apply instance is in
--   <a>Data.HList.FakePrelude</a>. A longer type could be inferred.
toHJust2 :: (HMapCxt r (HJust ()) a b, ToHJust a, b ~ ToHJustR a) => r a -> r b
class FromHJustR (ToHJustR l) ~ l => FromHJust l where type family FromHJustR l :: [*]
fromHJust :: FromHJust l => HList l -> HList (FromHJustR l)

-- | This implementation is shorter.
fromHJust2 :: HMapCxt r HFromJust a b => r a -> r b
data HFromJust
HFromJust :: HFromJust
data HAddTag t
HAddTag :: t -> HAddTag t
data HRmTag
HRmTag :: HRmTag
hAddTag :: (HMapAux r (HAddTag t) a b, SameLength' * * b a, SameLength' * * a b) => t -> r a -> r b
hRmTag :: (HMapAux r HRmTag a b, SameLength' * * b a, SameLength' * * a b) => r a -> r b

-- | Annotate list with a type-level Boolean hFlag :: HMapCxt (HAddTag
--   (Proxy True)) l r =&gt; HList l -&gt; HList r
hFlag :: (HMapAux r (HAddTag (Proxy Bool True)) a b, SameLength' * * b a, SameLength' * * a b) => r a -> r b

-- | Analogus to Data.List.<a>partition</a> <a>snd</a>. See also
--   <tt>HPartition</tt>
--   
--   <pre>
--   &gt;&gt;&gt; let (.=.) :: p x -&gt; y -&gt; Tagged x y; _ .=. y = Tagged y
--   
--   &gt;&gt;&gt; hSplit $ hTrue .=. 2 .*. hTrue .=. 3 .*. hFalse .=. 1 .*. HNil
--   (H[2,3],H[1])
--   </pre>
--   
--   it might make more sense to instead have <tt>LVPair Bool e</tt>
--   instead of <tt>(e, Proxy Bool)</tt> since the former has the same
--   runtime representation as <tt>e</tt>
class HSplit l where type family HSplitT l :: [*] type family HSplitF l :: [*]
hSplit :: HSplit l => HList l -> (HList (HSplitT l), HList (HSplitF l))

-- | <a>splitAt</a>
--   
--   setup
--   
--   <pre>
--   &gt;&gt;&gt; let two = hSucc (hSucc hZero)
--   
--   &gt;&gt;&gt; let xsys = hEnd $ hBuild 1 2 3 4
--   </pre>
--   
--   If a length is explicitly provided, the resulting lists are inferred
--   
--   <pre>
--   &gt;&gt;&gt; hSplitAt two xsys
--   (H[1,2],H[3,4])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let sameLength_ :: SameLength a b =&gt; r a -&gt; r b -&gt; r a; sameLength_ = const
--   
--   &gt;&gt;&gt; let len2 x = x `sameLength_` HCons () (HCons () HNil)
--   </pre>
--   
--   If the first chunk of the list (a) has to be a certain length, the
--   type of the Proxy argument can be inferred.
--   
--   <pre>
--   &gt;&gt;&gt; case hSplitAt Proxy xsys of (a,b) -&gt; (len2 a, b)
--   (H[1,2],H[3,4])
--   </pre>
class (HLengthEq xs n, HAppendList1 xs ys xsys) => HSplitAt (n :: HNat) xsys xs ys | n xsys -> xs ys, xs ys -> xsys, xs -> n
hSplitAt :: HSplitAt n xsys xs ys => Proxy n -> HList xsys -> (HList xs, HList ys)

-- | helper for <a>HSplitAt</a>
class HSplitAt1 accum (n :: HNat) xsys xs ys | accum n xsys -> xs ys
hSplitAt1 :: HSplitAt1 accum n xsys xs ys => HList accum -> Proxy n -> HList xsys -> (HList xs, HList ys)

-- | a better way to write <tt>HLength xs ~ n</tt> because:
--   
--   <ol>
--   <li>it works properly with ghc-7.10 (probably another example of ghc
--   bug #10009)</li>
--   <li>it works backwards a bit in that if <tt>n</tt> is known, then
--   <tt>xs</tt> can be refined:</li>
--   </ol>
--   
--   <pre>
--   &gt;&gt;&gt; undefined :: HLengthEq xs HZero =&gt; HList xs
--   H[]
--   </pre>
class (SameLength' (HReplicateR n ()) xs, HLengthEq1 xs n, HLengthEq2 xs n) => HLengthEq (xs :: [*]) (n :: HNat) | xs -> n
class HLengthEq1 (xs :: [*]) n
class HLengthEq2 (xs :: [*]) n | xs -> n

-- | <tt>HAppendList1 xs ys xsys</tt> is the type-level way of saying
--   <tt>xs ++ ys == xsys</tt>
--   
--   used by <a>HSplitAt</a>
class HStripPrefix xs xsys ys => HAppendList1 (xs :: [k]) (ys :: [k]) (xsys :: [k]) | xs ys -> xsys, xs xsys -> ys

-- | analog of <a>stripPrefix</a>
class HStripPrefix xs xsys ys | xs xsys -> ys
class HTuple v t | v -> t, t -> v
hToTuple :: HTuple v t => HList v -> t
hFromTuple :: HTuple v t => t -> HList v

-- | <pre>
--   Iso (HList v) (HList v') a b
--   </pre>
hTuple :: (HTuple v1 b, HTuple v a, Profunctor p, Functor f) => p a (f b) -> p (HList v) (f (HList v1))

-- | <pre>
--   Iso' (HList v) a
--   </pre>
hTuple' :: (HTuple v b, Profunctor p, Functor f) => p b (f b) -> p (HList v) (f (HList v))

-- | <a>tails</a>
class HTails a b | a -> b, b -> a
hTails :: HTails a b => HList a -> HList b

-- | <a>inits</a>
class HInits a b | a -> b, b -> a
hInits :: HInits a b => HList a -> HList b

-- | behaves like <tt>tail . inits</tt>
class HInits1 a b | a -> b, b -> a
hInits1 :: HInits1 a b => HList a -> HList b

-- | similar to <a>FHCons</a>
data FHCons2 x
FHCons2 :: x -> FHCons2 x

-- | evidence to satisfy the fundeps in HInits

-- | evidence to satisfy the fundeps in HInits

-- | <tt>HPartitionEq f x1 xs xi xo</tt> is analogous to
--   
--   <pre>
--   (xi,xo) = partition (f x1) xs
--   </pre>
--   
--   where <tt>f</tt> is a "function" passed in using it's instance of
--   <a>HEqBy</a>
class HPartitionEq f x1 xs xi xo | f x1 xs -> xi xo
hPartitionEq :: HPartitionEq f x1 xs xi xo => Proxy f -> Proxy x1 -> HList xs -> (HList xi, HList xo)
class HPartitionEq1 (b :: Bool) f x1 x xs xi xo | b f x1 x xs -> xi xo
hPartitionEq1 :: HPartitionEq1 b f x1 x xs xi xo => Proxy b -> Proxy f -> Proxy x1 -> x -> HList xs -> (HList xi, HList xo)

-- | <tt>HGroupBy f x y</tt> is analogous to <tt>y = <a>groupBy</a> f
--   x</tt>
--   
--   given that <tt>f</tt> is used by <a>HEqBy</a>
class HGroupBy (f :: t) (as :: [*]) (gs :: [*]) | f as -> gs, gs -> as
hGroupBy :: HGroupBy f as gs => Proxy f -> HList as -> HList gs

-- | <tt>HSpanEq x y fst snd</tt> is analogous to <tt>(fst,snd) =
--   <a>span</a> (== x) y</tt>
class HSpanEqBy (f :: t) (x :: *) (y :: [*]) (fst :: [*]) (snd :: [*]) | f x y -> fst snd, fst snd -> y
hSpanEqBy :: HSpanEqBy f x y fst snd => Proxy f -> x -> HList y -> (HList fst, HList snd)
class HSpanEqBy1 (f :: t) (x :: *) (y :: [*]) (i :: [*]) (o :: [*]) | f x y -> i o
hSpanEqBy1 :: HSpanEqBy1 f x y i o => Proxy f -> x -> HList y -> (HList i, HList o)
class HSpanEqBy2 (b :: Bool) (f :: t) (x :: *) (y :: *) (ys :: [*]) (i :: [*]) (o :: [*]) | b f x y ys -> i o
hSpanEqBy2 :: HSpanEqBy2 b f x y ys i o => Proxy b -> Proxy f -> x -> y -> HList ys -> (HList i, HList o)
class HZipList x y l | x y -> l, l -> x y
hZipList :: HZipList x y l => HList x -> HList y -> HList l
hUnzipList :: HZipList x y l => HList l -> (HList x, HList y)

-- | Analogous to the Monoid instance for tuples
--   
--   <pre>
--   &gt;&gt;&gt; import Data.Monoid
--   
--   &gt;&gt;&gt; mempty :: HList '[(), All, [Int]]
--   H[(),All {getAll = True},[]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mappend (hBuild "a") (hBuild "b") :: HList '[String]
--   H["ab"]
--   </pre>
data ConstMempty
ConstMempty :: ConstMempty
data UncurryMappend
UncurryMappend :: UncurryMappend
instance (Bounded x, Bounded (HList xs)) => Bounded (HList (x : xs))
instance Bounded (HList '[])
instance (Ix x, Ix (HList xs)) => Ix (HList (x : xs))
instance Ix (HList '[])
instance (Ord x, Ord (HList xs)) => Ord (HList (x : xs))
instance Ord (HList '[])
instance (Eq x, Eq (HList xs)) => Eq (HList (x : xs))
instance Eq (HList '[])
instance (aa ~ (a, a), Monoid a) => ApplyAB UncurryMappend aa a
instance (x ~ Proxy y, Monoid y) => ApplyAB ConstMempty x y
instance (HProxies a, HMapCxt HList ConstMempty (AddProxy a) a, HZip HList a a aa, HMapCxt HList UncurryMappend aa a) => Monoid (HList a)
instance ((x, y) ~ z, HZipList xs ys zs) => HZipList (x : xs) (y : ys) (z : zs)
instance HZipList '[] '[] '[]
instance (SameLengths '[x, y, xy], HZipList x y xy) => HZip HList x y xy
instance (SameLengths '[x, y, xy], HZipList x y xy) => HUnzip HList x y xy
instance HSpanEqBy2 'False f x y ys '[] (y : ys)
instance HSpanEqBy1 f x zs i o => HSpanEqBy2 'True f x y zs (y : i) o
instance HSpanEqBy1 f x '[] '[] '[]
instance (HEqBy f x y b, HSpanEqBy2 b f x y ys i o) => HSpanEqBy1 f x (y : ys) i o
instance (HSpanEqBy1 f x y revFst snd, HReverse revFst fst, HRevApp revFst snd y) => HSpanEqBy f x y fst snd
instance HGroupBy f '[] '[]
instance (HSpanEqBy f a as fst snd, HGroupBy f snd gs) => HGroupBy f (a : as) (HList (a : fst) : gs)
instance HPartitionEq f x1 xs xi xo => HPartitionEq1 'False f x1 x xs xi (x : xo)
instance HPartitionEq f x1 xs xi xo => HPartitionEq1 'True f x1 x xs (x : xi) xo
instance (HEqBy f x1 x b, HPartitionEq1 b f x1 x xs xi xo) => HPartitionEq f x1 (x : xs) xi xo
instance HPartitionEq f x1 '[] '[] '[]
instance (hxs ~ HList xs, hxxs ~ HList (x : xs)) => ApplyAB (FHCons2 x) hxs hxxs
instance (HInits1 xs ys, HMapCxt HList (FHCons2 x) ys ys', HMapCons x ys ~ ys', HMapTail ys' ~ ys) => HInits1 (x : xs) (HList '[x] : ys')
instance HInits1 '[] '[HList '[]]
instance HInits1 a b => HInits a (HList '[] : b)
instance HTails xs ys => HTails (x : xs) (HList (x : xs) : ys)
instance HTails '[] '[HList '[]]
instance HTuple '[a, b, c, d, e, f] (a, b, c, d, e, f)
instance HTuple '[a, b, c, d, e] (a, b, c, d, e)
instance HTuple '[a, b, c, d] (a, b, c, d)
instance HTuple '[a, b, c] (a, b, c)
instance HTuple '[a, b] (a, b)
instance HTuple '[] ()
instance HStripPrefix '[] ys ys
instance (x' ~ x, HStripPrefix xs xsys ys) => HStripPrefix (x' : xs) (x : xsys) ys
instance HAppendList1 xs ys zs => HAppendList1 (x : xs) ys (x : zs)
instance HAppendList1 '[] ys ys
instance zero ~ 'HZero => HLengthEq2 '[] zero
instance (HLengthEq xs n, sn ~ 'HSucc n) => HLengthEq2 (x : xs) sn
instance xxs ~ '[] => HLengthEq1 xxs 'HZero
instance (HLengthEq xs n, xxs ~ (x : xs)) => HLengthEq1 xxs ('HSucc n)
instance (SameLength' (HReplicateR n ()) xs, HLengthEq1 xs n, HLengthEq2 xs n) => HLengthEq xs n
instance HSplitAt1 (b : accum) n bs xs ys => HSplitAt1 accum ('HSucc n) (b : bs) xs ys
instance HRevApp accum '[] xs => HSplitAt1 accum 'HZero ys xs ys
instance (HSplitAt1 '[] n xsys xs ys, HAppendList1 xs ys xsys, HLengthEq xs n) => HSplitAt n xsys xs ys
instance HSplit l => HSplit (Tagged 'False e : l)
instance HSplit l => HSplit (Tagged 'True e : l)
instance HSplit l => HSplit ((e, Proxy 'False) : l)
instance HSplit l => HSplit ((e, Proxy 'True) : l)
instance HSplit '[]
instance e' ~ e => ApplyAB HRmTag (e, t) e'
instance et ~ (e, t) => ApplyAB (HAddTag t) e et
instance hJustA ~ HJust a => ApplyAB HFromJust hJustA a
instance FromHJust l => FromHJust (HJust e : l)
instance FromHJust l => FromHJust (HNothing : l)
instance FromHJust '[]
instance ToHJust l => ToHJust (e : l)
instance ToHJust '[]
instance HList2List (e' : l) e => HList2List (e : e' : l) e
instance HList2List '[e] e
instance HTIntersect t l1 l2 => HTIntersectBool 'False h t l1 l2
instance HTIntersect t l1 l2 => HTIntersectBool 'True h t l1 (h : l2)
instance (HTMember h l1 b, HTIntersectBool b h t l1 l2) => HTIntersect (h : t) l1 l2
instance HTIntersect '[] l '[]
instance (HEq e e' b, HTMember e l b', HOr b b' ~ b'') => HTMember e (e' : l) b''
instance HTMember e '[] 'False
instance HFind1 e l n => HFind2 'False e l ('HSucc n)
instance HFind2 'True e l 'HZero
instance Fail (FieldNotFound e1) => HFind1 e1 '[] 'HZero
instance (HEq e1 e2 b, HFind2 b e1 l n) => HFind1 e1 (e2 : l) n
instance HFind1 e l n => HFind e l n
instance HMemberM2 ('Just l1) e1 (e : l) ('Just (e : l1))
instance HMemberM2 'Nothing e1 l 'Nothing
instance (HMemberM e1 l r, HMemberM2 r e1 (e : l) res) => HMemberM1 'False e1 (e : l) res
instance HMemberM1 'True e1 (e : l) ('Just l)
instance (HEq e1 e b, HMemberM1 b e1 (e : l) res) => HMemberM e1 (e : l) res
instance HMemberM e1 '[] 'Nothing
instance HMember e1 l br => HMember' 'False e1 l br
instance HMember' 'True e1 l 'True
instance (HEq e1 e b, HMember' b e1 l br) => HMember e1 (e : l) br
instance HMember e1 '[] 'False
instance (l ~ [e'], ApplyAB f e e', el ~ (e, l)) => ApplyAB (Mapcar f) el l
instance (m1 ~ m, Applicative m, HSequence m as bs) => HSequence m (m1 a : as) (a : bs)
instance Applicative m => HSequence m '[] '[]
instance ApplyAB f e e' => ApplyAB (MapCar f) (e, HList l) (HList (e' : l))
instance (ApplyAB f e e', HMapAux HList f l l', SameLength l l') => HMapAux HList f (e : l) (e' : l')
instance HMapAux HList f '[] '[]
instance (SameLength a b, HMapAux r f a b) => HMapCxt r f a b
instance (HMapCxt HList f a b, as ~ HList a, bs ~ HList b) => ApplyAB (HMapL f) as bs
instance (HMapCxt r f a b, as ~ r a, bs ~ r b) => ApplyAB (HMap f) as bs
instance (x ~ HList t, HConcat xs, HAppendList t (HConcatR xs)) => HConcat (x : xs)
instance HConcat '[]
instance (ApplyAB f z z', HIterate n f z' r', z ~ z_) => HIterate ('HSucc n) f z (z_ : r')
instance HIterate 'HZero f z '[]
instance (ApplyAB f z fz, HReplicateF n f z r') => HReplicateF ('HSucc n) f z (fz : r')
instance HReplicateF 'HZero f z '[]
instance (HReplicateFD n e es, e ~ e') => HReplicateFD ('HSucc n) e (e' : es)
instance HReplicateFD 'HZero e '[]
instance (Apply p s, HUnfoldFD p (ApplyR p s) z) => HUnfoldFD p (HJust (e, s)) (e : z)
instance HUnfoldFD p HNothing '[]
instance z ~ z' => HFoldl f z '[] z'
instance (zx ~ (z, x), ApplyAB f zx z', HFoldl f z' xs r) => HFoldl f z (x : xs) r
instance (ApplyAB f (e, r) r', HFoldr1 f (e' : l) r) => HFoldr1 f (e : e' : l) r'
instance v ~ v' => HFoldr1 f '[v] v'
instance (ApplyAB f (x, r) s, HScanr f z xs (r : rs), srrs ~ (s : r : rs)) => HScanr f z (x : xs) srrs
instance lz ~ '[z] => HScanr f z '[] lz
instance (ApplyAB f (e, r) r', HFoldr f v l r) => HFoldr f v (e : l) r'
instance v ~ v' => HFoldr f v '[] v'
instance HBuild' (a : l) r => HBuild' l (a -> r)
instance HReverse l l' => HBuild' l (HList l')
instance (HRevApp xs '[] sx, HRevApp sx '[] xs) => HReverse xs sx
instance HRevApp l (x : l') z => HRevApp (x : l) l' z
instance HRevApp '[] l2 l2
instance (x ~ (e, HList l), y ~ HList (e : l)) => ApplyAB FHCons x y
instance HAppendList l l' => HAppendList (x : l) l'
instance HAppendList '[] l2
instance HAppendList l1 l2 => HAppend (HList l1) (HList l2)
instance HExtend e (HList l)
instance HInit (b : c) => HInit (a : b : c)
instance HInit '[x]
instance (y ~ ReadP x, Read x) => ApplyAB ReadElement (Proxy x) y
instance (HProxies l, Read e, HSequence ReadP (ReadP e : readP_l) (e : l), HMapCxt HList ReadElement (AddProxy l) readP_l) => Read (HList (e : l))
instance Read (HList '[])
instance (Show e, Show (HList l)) => Show (HList (e : l))
instance Show (HList '[])
instance HProxiesFD xs pxs => HProxiesFD (x : xs) (Proxy x : pxs)
instance HProxiesFD '[] '[]


-- | The HList library
--   
--   (C) 2004, Oleg Kiselyov, Ralf Laemmel, Keean Schupke
--   
--   Array-like access to HLists.
module Data.HList.HArray
class HLookupByHNat (n :: HNat) (l :: [*]) where type family HLookupByHNatR (n :: HNat) (l :: [*]) :: *
hLookupByHNat :: HLookupByHNat n l => Proxy n -> HList l -> HLookupByHNatR n l
class HDeleteAtHNat (n :: HNat) (l :: [*]) where type family HDeleteAtHNatR (n :: HNat) (l :: [*]) :: [*]
hDeleteAtHNat :: HDeleteAtHNat n l => Proxy n -> HList l -> HList (HDeleteAtHNatR n l)
class HUpdateAtHNat (n :: HNat) e (l :: [*]) where type family HUpdateAtHNatR (n :: HNat) e (l :: [*]) :: [*]
hUpdateAtHNat :: HUpdateAtHNat n e l => Proxy n -> e -> HList l -> HList (HUpdateAtHNatR n e l)
hProjectByHNats' :: (HMapAux r (FHLookupByHNat l) a b, SameLength' * * b a, SameLength' * * a b) => r a -> HList l -> r b
newtype FHLookupByHNat (l :: [*])
FHLookupByHNat :: (HList l) -> FHLookupByHNat
hProjectByHNats :: (HUnfoldFD (FHUProj True ns) (ApplyR (FHUProj True ns) (t, Proxy HNat HZero)) z, Apply (FHUProj True ns) (t, Proxy HNat HZero)) => Proxy [HNat] ns -> t -> HList z
data FHUProj (sel :: Bool) (ns :: [HNat])
FHUProj :: FHUProj
type HProjectByHNatsR (ns :: [HNat]) (l :: [*]) = HUnfold (FHUProj True ns) (HList l, Proxy HZero)
type HProjectByHNatsCtx ns l = (Apply (FHUProj True ns) (HList l, Proxy HZero), HUnfold' (FHUProj True ns) (HList l, Proxy HZero))
hProjectAwayByHNats :: (HUnfoldFD (FHUProj False ns) (ApplyR (FHUProj False ns) (t, Proxy HNat HZero)) z, Apply (FHUProj False ns) (t, Proxy HNat HZero)) => Proxy [HNat] ns -> t -> HList z
type HProjectAwayByHNatsR (ns :: [HNat]) (l :: [*]) = HUnfold (FHUProj False ns) (HList l, Proxy HZero)
type HProjectAwayByHNatsCtx ns l = (Apply (FHUProj False ns) (HList l, Proxy HZero), HUnfold' (FHUProj False ns) (HList l, Proxy HZero))

-- | Splitting an array according to indices
hSplitByHNats :: (HUnfoldFD (FHUProj True ns) (ApplyR (FHUProj True ns) (t, Proxy HNat HZero)) z, HUnfoldFD (FHUProj False ns) (ApplyR (FHUProj False ns) (t, Proxy HNat HZero)) z1, Apply (FHUProj True ns) (t, Proxy HNat HZero), Apply (FHUProj False ns) (t, Proxy HNat HZero)) => Proxy [HNat] ns -> t -> (HList z, HList z1)
instance Apply (FHUProj sel ns) (HList l, Proxy ('HSucc n)) => Apply (Proxy 'False, FHUProj sel ns) (HList (e : l), Proxy n)
instance Apply (Proxy 'True, FHUProj sel ns) (HList (e : l), Proxy n)
instance (ch ~ Proxy (HBoolEQ sel (KMember n ns)), Apply (ch, FHUProj sel ns) (HList (e : l), Proxy n)) => Apply (FHUProj sel ns) (HList (e : l), Proxy n)
instance Apply (FHUProj sel ns) (HList '[], n)
instance HLookupByHNat n l => Apply (FHLookupByHNat l) (Proxy n)
instance Fail (FieldNotFound (Proxy n, e1)) => HUpdateAtHNat n e1 '[]
instance HUpdateAtHNat n e1 l => HUpdateAtHNat ('HSucc n) e1 (e : l)
instance HUpdateAtHNat 'HZero e1 (e : l)
instance HDeleteAtHNat n l => HDeleteAtHNat ('HSucc n) (e : l)
instance HDeleteAtHNat 'HZero (e : l)
instance HLookupByHNat n l => HLookupByHNat ('HSucc n) (e : l)
instance HLookupByHNat 'HZero (e : l)


-- | The HList library
--   
--   (C) 2004, Oleg Kiselyov, Ralf Laemmel, Keean Schupke
--   
--   Result-type-driven operations on typeful heterogeneous lists.
module Data.HList.HOccurs
class HOccurrence (e1 :: *) (l :: [*]) (l' :: [*]) | e1 l -> l'
hOccurrence :: HOccurrence e1 l l' => Proxy e1 -> HList l -> HList l'
class HOccurrence' (b :: Bool) (e1 :: *) (l :: [*]) (l' :: [*]) | b e1 l -> l'
hOccurrence' :: HOccurrence' b e1 l l' => Proxy b -> Proxy e1 -> HList l -> HList l'
class HOccursMany e (l :: [*])
hOccursMany :: HOccursMany e l => HList l -> [e]
class HOccursMany' e l
hOccursMany' :: HOccursMany' e l => HList l -> [e]
hOccursMany1 :: (HOccurrence e l (e : l'), HOccursMany e l') => HList l -> (e, [e])
hOccursFst :: HOccurrence e l (e : l') => HList l -> e
data TypeNotFound e
class HOccurs' e l
hOccurs' :: HOccurs' e l => HList l -> e

-- | lookup a value in the collection (TIP usually) and return the TIP with
--   that element deleted. Used to implement <tt>tipyTuple</tt>.
hOccursRest :: (HOccurs l (r v), HDeleteAtLabel * r l v v') => r v -> (l, r v')
hOccursOpt :: (HOccurrence e l l', HOccursOpt' e l') => HList l -> Maybe e
class HOccursOpt' e l
hOccursOpt' :: HOccursOpt' e l => HList l -> Maybe e
data TypeFound e
class HOccursNot' (b :: Bool) e (l :: [*])
instance (HOccurs e l, HProject l (HList l')) => HProject l (HList (e : l'))
instance HProject (HList l) (HList '[])
instance HOccursNot e l => HOccursNot' 'False e l
instance Fail (TypeFound e) => HOccursNot' 'True e l
instance (HEq e e1 b, HOccursNot' b e l) => HOccursNot e (e1 : l)
instance HOccursNot e '[]
instance e ~ e1 => HOccursOpt' e (e1 : l)
instance HOccursOpt' e '[]
instance (e ~ e1, HOccursNot e l) => HOccurs' e (e : l)
instance Fail (TypeNotFound e) => HOccurs' e '[]
instance (HOccurrence e (x : y) l', HOccurs' e l') => HOccurs e (HList (x : y))
instance (e ~ e1, HOccursMany e l) => HOccursMany' e (e1 : l)
instance HOccursMany' e '[]
instance (HOccurrence e l l', HOccursMany' e l') => HOccursMany e l
instance HOccurrence e1 l l' => HOccurrence' 'False e1 (e : l) l'
instance HOccurrence' 'True e1 (e : l) (e : l)
instance (HEq e1 e b, HOccurrence' b e1 (e : l) l') => HOccurrence e1 (e : l) l'
instance HOccurrence e1 '[] '[]


-- | While NoMonoLocalBinds could be enabled in TIP.hs, the ghc manual
--   warns "type inference becomes less predicatable if you do so. (Read
--   the papers!)". These definitions don't need type families, putting
--   these definitions in a separate module avoids that mess.
--   
--   XXX these should be implemented in terms of <tt>HTuple</tt> and
--   <tt>tipyProject</tt>, which means adding
module Data.HList.TIPtuple

-- | project a TIP (or HList) into a tuple
--   
--   <pre>
--   tipyTuple' x = (<tt>hOccurs</tt> x, hOccurs x)
--   </pre>
--   
--   behaves similarly, except <tt>tipyTuple</tt> excludes the possibility
--   of looking up the same element twice, which allows inferring a
--   concrete type in more situations. For example
--   
--   <pre>
--   (\x y z -&gt; tipyTuple (x .*. y .*. emptyTIP) `asTypeOf` (x, z)) () 'x'
--   </pre>
--   
--   has type <tt>Char -&gt; ((), Char)</tt>. tipyTuple' would need a type
--   annotation to decide whether the type should be <tt>Char -&gt; ((),
--   Char)</tt> or <tt>() -&gt; ((), ())</tt>
tipyTuple :: (HOccurs l1 (r v1), HOccurs l1 (r v), HOccurs l (r v2), HOccurs l (r v), HDeleteAtLabel * r l1 v1 v', HDeleteAtLabel * r l1 v v2, HDeleteAtLabel * r l v2 v'1, HDeleteAtLabel * r l v v1) => r v -> (l, l1)
tipyTuple3 :: (HOccurs l2 (r v5), HOccurs l2 (r v2), HOccurs l2 (r v), HOccurs l1 (r v4), HOccurs l1 (r v1), HOccurs l1 (r v), HOccurs l (r v6), HOccurs l (r v3), HOccurs l (r v), HDeleteAtLabel * r l2 v5 v6, HDeleteAtLabel * r l2 v2 v', HDeleteAtLabel * r l2 v v3, HDeleteAtLabel * r l1 v4 v'1, HDeleteAtLabel * r l1 v1 v2, HDeleteAtLabel * r l1 v v5, HDeleteAtLabel * r l v6 v'2, HDeleteAtLabel * r l v3 v4, HDeleteAtLabel * r l v v1) => r v -> (l, l1, l2)
tipyTuple4 :: (HOccurs l3 (r v11), HOccurs l3 (r v7), HOccurs l3 (r v3), HOccurs l3 (r v), HOccurs l2 (r v10), HOccurs l2 (r v6), HOccurs l2 (r v2), HOccurs l2 (r v), HOccurs l1 (r v9), HOccurs l1 (r v5), HOccurs l1 (r v1), HOccurs l1 (r v), HOccurs l (r v12), HOccurs l (r v8), HOccurs l (r v4), HOccurs l (r v), HDeleteAtLabel * r l3 v11 v12, HDeleteAtLabel * r l3 v7 v8, HDeleteAtLabel * r l3 v3 v', HDeleteAtLabel * r l3 v v4, HDeleteAtLabel * r l2 v10 v11, HDeleteAtLabel * r l2 v6 v'1, HDeleteAtLabel * r l2 v2 v3, HDeleteAtLabel * r l2 v v7, HDeleteAtLabel * r l1 v9 v'2, HDeleteAtLabel * r l1 v5 v6, HDeleteAtLabel * r l1 v1 v2, HDeleteAtLabel * r l1 v v10, HDeleteAtLabel * r l v12 v'3, HDeleteAtLabel * r l v8 v9, HDeleteAtLabel * r l v4 v5, HDeleteAtLabel * r l v v1) => r v -> (l, l1, l2, l3)
tipyTuple5 :: (HOccurs l4 (r v19), HOccurs l4 (r v14), HOccurs l4 (r v9), HOccurs l4 (r v4), HOccurs l4 (r v), HOccurs l3 (r v18), HOccurs l3 (r v13), HOccurs l3 (r v8), HOccurs l3 (r v3), HOccurs l3 (r v), HOccurs l2 (r v17), HOccurs l2 (r v12), HOccurs l2 (r v7), HOccurs l2 (r v2), HOccurs l2 (r v), HOccurs l1 (r v16), HOccurs l1 (r v11), HOccurs l1 (r v6), HOccurs l1 (r v1), HOccurs l1 (r v), HOccurs l (r v20), HOccurs l (r v15), HOccurs l (r v10), HOccurs l (r v5), HOccurs l (r v), HDeleteAtLabel * r l4 v19 v20, HDeleteAtLabel * r l4 v14 v15, HDeleteAtLabel * r l4 v9 v10, HDeleteAtLabel * r l4 v4 v', HDeleteAtLabel * r l4 v v5, HDeleteAtLabel * r l3 v18 v19, HDeleteAtLabel * r l3 v13 v14, HDeleteAtLabel * r l3 v8 v'1, HDeleteAtLabel * r l3 v3 v4, HDeleteAtLabel * r l3 v v9, HDeleteAtLabel * r l2 v17 v18, HDeleteAtLabel * r l2 v12 v'2, HDeleteAtLabel * r l2 v7 v8, HDeleteAtLabel * r l2 v2 v3, HDeleteAtLabel * r l2 v v13, HDeleteAtLabel * r l1 v16 v'3, HDeleteAtLabel * r l1 v11 v12, HDeleteAtLabel * r l1 v6 v7, HDeleteAtLabel * r l1 v1 v2, HDeleteAtLabel * r l1 v v17, HDeleteAtLabel * r l v20 v'4, HDeleteAtLabel * r l v15 v16, HDeleteAtLabel * r l v10 v11, HDeleteAtLabel * r l v5 v6, HDeleteAtLabel * r l v v1) => r v -> (l, l1, l2, l3, l4)


-- | The HList library
--   
--   (C) 2004, Oleg Kiselyov, Ralf Laemmel, Keean Schupke
--   
--   Type-indexed operations on typeful heterogeneous lists.
module Data.HList.HTypeIndexed

-- | Map a type to a natural (index within the collection) This is a purely
--   type-level computation

-- | Helper class
class HType2HNatCase (b :: Bool) (e :: *) (l :: [*]) (n :: HNat) | b e l -> n
hType2HNat :: HType2HNat e l n => proxy1 e -> proxy l -> Proxy n

-- | And lift to the list of types
hTypes2HNats :: HTypes2HNats es l ns => Proxy (es :: [*]) -> hlist l -> Proxy (ns :: [HNat])
class HDeleteManyCase (b :: Bool) e1 e l l1 | b e1 e l -> l1
hDeleteManyCase :: HDeleteManyCase b e1 e l l1 => Proxy b -> Proxy e1 -> e -> HList l -> HList l1
hDeleteAt :: (HDeleteAtHNat n l, HType2HNat * e l n) => proxy1 e -> HList l -> HList (HDeleteAtHNatR n l)
hUpdateAt :: (HUpdateAtHNat n e l, HType2HNat * e l n) => e -> HList l -> HList (HUpdateAtHNatR n e l)
hProjectBy :: (HUnfoldFD (FHUProj True ns) (ApplyR (FHUProj True ns) (hlist l, Proxy HNat HZero)) z, HTypes2HNats [*] k es l ns, Apply (FHUProj True ns) (hlist l, Proxy HNat HZero)) => Proxy [*] es -> hlist l -> HList z
hSplitBy :: (HUnfoldFD (FHUProj True ns) (ApplyR (FHUProj True ns) (hlist l, Proxy HNat HZero)) z, HUnfoldFD (FHUProj False ns) (ApplyR (FHUProj False ns) (hlist l, Proxy HNat HZero)) z1, HTypes2HNats [*] k es l ns, Apply (FHUProj True ns) (hlist l, Proxy HNat HZero), Apply (FHUProj False ns) (hlist l, Proxy HNat HZero)) => Proxy [*] es -> hlist l -> (HList z, HList z1)

-- | should this instead delete the first element of that type?
instance (HDeleteAtHNat n l, HType2HNat e l n, l' ~ HDeleteAtHNatR n l) => HDeleteAtLabel HList e l l'
instance HDeleteMany e1 (HList l) (HList l1) => HDeleteManyCase 'False e1 e l (e : l1)
instance HDeleteMany e (HList l) (HList l1) => HDeleteManyCase 'True e e l l1
instance (HEq e1 e b, HDeleteManyCase b e1 e l l1) => HDeleteMany e1 (HList (e : l)) (HList l1)
instance HDeleteMany e (HList '[]) (HList '[])
instance (HType2HNat e l n, HTypes2HNats es l ns) => HTypes2HNats (e : es) l (n : ns)
instance HTypes2HNats '[] l '[]
instance HType2HNat e l n => HType2HNatCase 'False e l ('HSucc n)
instance HOccursNot e l => HType2HNatCase 'True e l 'HZero
instance (HEq e1 e b, HType2HNatCase b e1 l n) => HType2HNat e1 (e : l) n


-- | The HList library
--   
--   (C) 2004, Oleg Kiselyov, Ralf Laemmel, Keean Schupke
--   
--   Zipping and unzipping for (conceptually) lists of pairs.
--   
--   Provides two alternative implementations
module Data.HList.HZip

-- | HZipR in the superclass constraint doesn't hurt, but it doesn't seem
--   to be necessary
class HZipR (MapFst z) (MapSnd z) ~ z => HUnZip z where type family MapFst z :: [*] type family MapSnd z :: [*]
hZip2 :: HUnZip z => HList (MapFst z) -> HList (MapSnd z) -> HList z
hUnzip2 :: HUnZip z => HList z -> (HList (MapFst z), HList (MapSnd z))

-- | calculates something like:
--   
--   <pre>
--   [a] -&gt; [b] -&gt; [(a,b)]
--   </pre>
--   
--   can be used to give another type for <a>hZip2</a>
--   
--   <pre>
--   hZip2 :: HList a -&gt; HList b -&gt; HList (HZipR a b)
--   </pre>

-- | this transpose requires equal-length HLists inside a HList:
--   
--   <pre>
--   &gt;&gt;&gt; import Data.HList.HListPrelude
--   
--   &gt;&gt;&gt; let ex = (1 .*. 2 .*. HNil) .*. ('a' .*. 'b' .*. HNil) .*. ( 3 .*. 5 .*. HNil) .*. HNil
--   </pre>
--   
--   The original list:
--   
--   <pre>
--   &gt;&gt;&gt; ex
--   H[H[1,2],H['a','b'],H[3,5]]
--   </pre>
--   
--   And transposed:
--   
--   <pre>
--   &gt;&gt;&gt; hTranspose ex
--   H[H[1,'a',3],H[2,'b',5]]
--   </pre>
hTranspose :: (HZip3 a b c, HFoldr HZipF (HList es) l (HList b), HReplicateFD n (HList ([] *)) es, HLengthEq1 HNat a n, HLengthEq2 HNat a n, SameLength' * * (HReplicateR * n ()) a) => HList ((:) * (HList a) l) -> HList c

-- | same as <tt>HZip</tt> but HCons the elements of x onto y. This might
--   be doable as a <tt>hMap f (hZip x y)</tt>, but that one doesn't
--   propagate types as easily it seems.
class HZip3 x y l | x y -> l, l -> x y
hZip3 :: HZip3 x y l => HList x -> HList y -> HList l
data HZipF
HZipF :: HZipF
instance (HZip3 a b c, x ~ (HList a, HList b), y ~ HList c) => ApplyAB HZipF x y
instance (HList (x : y) ~ z, HZip3 xs ys zs) => HZip3 (x : xs) (HList y : ys) (z : zs)
instance HZip3 '[] '[] '[]
instance (z ~ (x, y), HUnZip zs) => HUnZip (z : zs)
instance HUnZip '[]


-- | The HList library
--   
--   (C) 2004-2006, Oleg Kiselyov, Ralf Laemmel, Keean Schupke
--   
--   A model of labels as needed for extensible records. As before, all the
--   information about labels is recorded in their type, so the labels of
--   records may be purely phantom. In general, Labels are exclusively
--   type-level entities and have no run-time representation.
--   
--   Record labels are triplets of type-level naturals, namespace, and
--   description. The namespace part helps avoid confusions between labels
--   from different Haskell modules. The description is an arbitrary
--   nullary type constructor.
--   
--   For the sake of printing, the description is required to be the
--   instance of Show. One must make sure that the show functions does not
--   examine the value, as descr is purely phantom. Here's an example of
--   the good Label description:
--   
--   <pre>
--   data MyLabelDescr; instance Show MyLabelDescr where show _ = "descr"
--   </pre>
--   
--   which are automated by makeLabels3 from <a>Data.HList.MakeLabel</a>.
--   
--   This model even allows the labels in a record to belong to different
--   namespaces. To this end, the model employs the predicate for type
--   equality.
module Data.HList.Label3
data Lbl (x :: HNat) (ns :: *) (desc :: *)

-- | Construct the first label
firstLabel :: ns -> desc -> Label (Lbl HZero ns desc)

-- | Construct the next label
nextLabel :: Label (Lbl x ns desc) -> desc' -> Label (Lbl (HSucc x) ns desc')

-- | Equality on labels (descriptions are ignored) Use generic instance
--   
--   Show label

-- | If possible, Label is left off:
--   
--   <pre>
--   &gt;&gt;&gt; let q = label3 .*. label3 .*. emptyProxy
--   
--   &gt;&gt;&gt; :t q
--   q :: Proxy '[Lbl 'HZero () (), Lbl 'HZero () ()]
--   </pre>

-- | Mixing two label kinds means we have to include <a>Label</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let r = label3 .*. label6 .*. emptyProxy
--   
--   &gt;&gt;&gt; :t r
--   r :: Proxy '[Label (Lbl 'HZero () ()), Label "6"]
--   </pre>

-- | Mixing two label kinds means we have to include <a>Label</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s = label6 .*. label3 .*. emptyProxy
--   
--   &gt;&gt;&gt; :t s
--   s :: Proxy '[Label "6", Label (Lbl 'HZero () ())]
--   </pre>

-- | similar to Data.HList.Record.Labels1, but avoids producing Label
--   (Label x)
instance Typeable Lbl
instance HExtend (Label y) (Proxy (x : xs))
instance HExtend (Label y) (Proxy (x : xs))
instance HExtend (Label y) (Proxy (x : xs))
instance HExtend (Label y) (Proxy (x : xs))
instance HExtend (Label (Lbl n ns desc)) (Proxy (x : xs))
instance HExtend (Label (Lbl n ns desc)) (Proxy (Lbl n' ns' desc' : xs))
instance Show desc => Show (Label (Lbl x ns desc))
instance Show desc => ShowLabel (Lbl x ns desc)
instance Label t ~ Label (Lbl ix ns n) => SameLabels (Label t) (Lbl ix ns n)


-- | The HList library
--   
--   (C) 2004, Oleg Kiselyov, Ralf Laemmel, Keean Schupke
--   
--   Generic type equality predicate: The implementation based on
--   overlapping instances The only place where overlapping instances are
--   really used besides Label5
module Data.HList.TypeEqO
class TupleType (t :: *) (b :: Bool) | t -> b

-- | All our keywords must be registered
class IsKeyFN (t :: *) (flag :: Bool) | t -> flag

-- | overlapping/fallback case
instance [overlap ok] 'False ~ flag => IsKeyFN t flag
instance [overlap ok] (Arity f n) => ArityFwd (x -> f) ('HSucc n)
instance [overlap ok] hZero ~ 'HZero => ArityFwd f hZero
instance [overlap ok] HNat2Integral n => Show (Proxy n)
instance [overlap ok] Show (Proxy 'False)
instance [overlap ok] Show (Proxy 'True)
instance [overlap ok] 'False ~ b => TupleType x b
instance [overlap ok] TupleType (x, y, z) 'True
instance [overlap ok] TupleType (x, y) 'True
instance [overlap ok] TupleType () 'True
instance [overlap ok] 'False ~ b => HEq x y b
instance [overlap ok] HEq x x 'True


-- | Convert between functions taking HLists and functions taking many
--   arguments
module Data.HList.HCurry

-- | 'curry'/'uncurry' for many arguments and HLists instead of tuples
--   
--   XXX the last FD <tt>xs -&gt; n</tt> is needed to make hCompose infer
--   the right types: arguably it shouldn't be needed
class HLengthEq xs n => HCurry' (n :: HNat) f xs r | f xs -> r, r xs -> f, n f -> xs, xs -> n
hUncurry' :: HCurry' n f xs r => Proxy n -> f -> HList xs -> r
hCurry' :: HCurry' n f xs r => Proxy n -> (HList xs -> r) -> f
hUncurry :: (HCurry' n f xs r, ArityFwd f n, ArityRev f n) => f -> HList xs -> r

-- | Note: with ghc-7.10 the Arity constraint added here does not work
--   properly with hCompose, so it is possible that other uses of
--   <a>hCurry</a> are better served by <tt>hCurry' Proxy</tt>.
hCurry :: (HCurry' n f xs r, ArityFwd f n, ArityRev f n) => (HList xs -> r) -> f

-- | compose two functions that take multiple arguments. The result of the
--   second function is the first argument to the first function. An
--   example is probably clearer:
--   
--   <pre>
--   &gt;&gt;&gt; let f = hCompose (,,) (,)
--   
--   &gt;&gt;&gt; :t f
--   f :: ... -&gt; ... -&gt; ... -&gt; ... -&gt; ((..., ...), ..., ...)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; f 1 2 3 4
--   ((1,2),3,4)
--   </pre>
--   
--   Note: polymorphism can make it confusing as to how many parameters a
--   function actually takes. For example, the first two ids are <tt>id ::
--   (a -&gt; b) -&gt; (a -&gt; b)</tt> in
--   
--   <pre>
--   &gt;&gt;&gt; (.) id id id 'y'
--   'y'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hCompose id id id 'y'
--   'y'
--   </pre>
--   
--   still typechecks, but in that case <tt>hCompose i1 i2 i3 x == i1 ((i2
--   i3) x)</tt> has id with different types than @(.) i1 i2 i3 x == (i1
--   (i2 i3)) x
--   
--   Prompted by
--   <a>http://stackoverflow.com/questions/28932054/can-hlistelim-be-composed-with-another-function</a>
hCompose :: (HCurry' n2 f2 xs1 r, HCurry' n1 f1 xs x, HCurry' n f xsys r, HSplitAt1 ([] *) n1 xsys xs xs1, HAppendList1 * xs xs1 xsys, ArityFwd f2 n2, ArityFwd f1 n1, ArityRev f2 n2, ArityRev f1 n1) => (x -> f2) -> f1 -> f
arityOf :: Arity f n => f -> Proxy n
instance HCurry' n b xs r => HCurry' ('HSucc n) (x -> b) (x : xs) r
instance HCurry' 'HZero b '[] b


-- | Benchmarks for these functions can be found at
--   <a>http://code.haskell.org/~aavogt/HList-nodup/Run.html</a>.
--   
--   See <a>Data-HList-CommonMain.html#v:hSort</a> for the public
--   interface.
module Data.HList.HSort

-- | only in ghc &gt;= 7.7

-- | only in ghc &gt;= 7.7
--   
--   <pre>
--   &gt;&gt;&gt; let b1 = Proxy :: HEqBy HLeFn "x" "y" b =&gt; Proxy b
--   
--   &gt;&gt;&gt; :t b1
--   b1 :: Proxy 'True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let b2 = Proxy :: HEqBy HLeFn "x" "x" b =&gt; Proxy b
--   
--   &gt;&gt;&gt; :t b2
--   b2 :: Proxy 'True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let b3 = Proxy :: HEqBy HLeFn "y" "x" b =&gt; Proxy b
--   
--   &gt;&gt;&gt; :t b3
--   b3 :: Proxy 'False
--   </pre>

-- | the "standard" <a>&lt;=</a> for types. Reuses <a>HEqBy</a>
--   
--   Note that ghc-7.6 is missing instances for Symbol and Nat, so that
--   sorting only works <a>HNat</a> (as used by <a>Data.HList.Label3</a>).
data HLeFn

-- | Data.HList.Label3 labels can only be compared if they belong to the
--   same namespace.

-- | analogous to <a>Down</a>
data HDown a

-- | The HEqBy instances for <tt>HNeq HLeFn</tt> gives <a>&lt;</a>
data HNeq le

-- | <tt>HIsAscList le xs b</tt> is analogous to
--   
--   <pre>
--   b = all (\(x,y) -&gt; x `le` y) (xs `zip` tail xs)
--   </pre>
class HEqByFn le => HIsAscList le (xs :: [*]) (b :: Bool) | le xs -> b

-- | quick sort with a special case for sorted lists
class (SameLength a b, HEqByFn le) => HSortBy le (a :: [*]) (b :: [*]) | le a -> b
hSortBy :: HSortBy le a b => Proxy le -> HList a -> HList b
type HSort x y = HSortBy HLeFn x y
hSort :: HSort x y => HList x -> HList y
class HSortBy1 ok le (a :: [*]) (b :: [*]) | ok le a -> b
hSortBy1 :: HSortBy1 ok le a b => Proxy ok -> Proxy le -> HList a -> HList b

-- | HMSortBy is roughly a transcription of this merge sort
--   
--   <pre>
--   msort [] = []
--   msort [x] = [x]
--   msort [x,y] = hSort2 x y
--   msort xs = case splitAt (length xs `div` 2) xs of
--                (a,b) -&gt; msort a `merge` msort b
--   </pre>
--   
--   <pre>
--   hSort2 x y
--       | x &lt;= y    = [x,y]
--       | otherwise = [y,x]
--   </pre>
--   
--   <pre>
--   merge (x : xs) (y : ys)
--     | x &gt; y     = y : merge (x : xs) ys
--     | otherwise = x : merge xs (y : ys)
--   </pre>
class HEqByFn le => HMSortBy le (a :: [*]) (b :: [*]) | le a -> b
hMSortBy :: HMSortBy le a b => Proxy le -> HList a -> HList b
class HSort2 b x y ab | b x y -> ab
hSort2 :: HSort2 b x y ab => Proxy b -> x -> y -> HList ab
class HMerge le x y xy | le x y -> xy
hMerge :: HMerge le x y xy => Proxy le -> HList x -> HList y -> HList xy
type HMerge1 b x y min max = (HCond b (HList x) (HList y) (HList min), HCond b (HList y) (HList x) (HList max))
hMerge1 :: (HCond t2 y x t, HCond t2 x y t1) => Proxy Bool t2 -> y -> x -> (t, t1)

-- | HQSortBy is this algorithm
--   
--   <pre>
--   qsort (x : xs @ (_ : _)) = case partition (&lt;= x) xs of
--                    (le, gt) -&gt; qsort le ++ x : qsort gt
--   qsort xs = xs
--   </pre>
--   
--   on random inputs that are not pathological (ie. not already sorted or
--   reverse sorted) this turns out to be faster than HMSortBy, so it is
--   used by default.
class HQSortBy le (a :: [*]) (b :: [*]) | le a -> b
hQSortBy :: HQSortBy le a b => Proxy le -> HList a -> HList b

-- | Provided the labels involved have an appropriate instance of HEqByFn,
--   it would be possible to use the following definitions:
--   
--   <pre>
--   type HRLabelSet = HSet
--   type HLabelSet  = HSet
--   </pre>
class HEqByFn lt => HSetBy lt (ps :: [*])
class HSetBy (HNeq HLeFn) ps => HSet (ps :: [*])

-- | <pre>
--   &gt;&gt;&gt; let xx = Proxy :: HIsSet [Label "x", Label "x"] b =&gt; Proxy b
--   
--   &gt;&gt;&gt; :t xx
--   xx :: Proxy 'False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let xy = Proxy :: HIsSet [Label "x", Label "y"] b =&gt; Proxy b
--   
--   &gt;&gt;&gt; :t xy
--   xy :: Proxy 'True
--   </pre>
class HIsSet (ps :: [*]) (b :: Bool) | ps -> b
class HEqByFn lt => HIsSetBy lt (ps :: [*]) (b :: Bool) | lt ps -> b

-- | <tt>HAscList le xs</tt> confirms that xs is in ascending order, and
--   reports which element is duplicated otherwise.
class HEqByFn le => HAscList le (ps :: [*])
class HEqByFn le => HAscList0 le (ps :: [*]) (ps0 :: [*])
class HEqByFn le => HAscList1 le (b :: Bool) (ps :: [*]) (ps0 :: [*])
instance HAscList0 le ys ys0 => HAscList1 le 'True ys ys0
instance (Fail '("Duplicated element", y, "using le", le, "in", ys0), HEqByFn le) => HAscList1 le 'False (y : ys) ys0
instance HEqByFn le => HAscList0 le '[x] ps0
instance HEqByFn le => HAscList0 le '[] ps0
instance (HAscList1 le b (y : ys) ps0, HEqBy le x y b) => HAscList0 le (x : y : ys) ps0
instance HAscList0 le ps ps => HAscList le ps
instance (HSortBy lt ps ps', HIsAscList lt ps' b) => HIsSetBy lt ps b
instance HIsSetBy (HNeq HLeFn) ps b => HIsSet ps b
instance HSetBy (HNeq HLeFn) ps => HSet ps
instance (HSortBy lt ps ps', HAscList lt ps') => HSetBy lt ps
instance (HPartitionEq le a (b : bs) bGeq bLt, HQSortBy le bLt sortedLt, HQSortBy le bGeq sortedGeq, HAppendListR sortedLt (a : sortedGeq) ~ sorted, HAppendList sortedLt (a : sortedGeq)) => HQSortBy le (a : b : bs) sorted
instance HQSortBy le '[x] '[x]
instance HQSortBy le '[] '[]
instance (HEqBy le x y b, HMerge1 b (x : xs) (y : ys) (l : ls) hhs, HMerge le ls hhs srt) => HMerge le (x : xs) (y : ys) (l : srt)
instance HMerge le '[] (x : xs) (x : xs)
instance HMerge le (x : xs) '[] (x : xs)
instance HMerge le '[] '[] '[]
instance (HMerge le xs' ys' sorted, HMSortBy le ys ys', HMSortBy le xs xs', HLengthEq (a : b : c : cs) n2, HDiv2 n2 ~ n, HSplitAt n (a : b : c : cs) xs ys) => HMSortBy le (a : b : c : cs) sorted
instance HSort2 'False x y '[y, x]
instance HSort2 'True x y '[x, y]
instance (HSort2 b x y ab, HEqBy le x y b) => HMSortBy le '[x, y] ab
instance HEqByFn le => HMSortBy le '[x] '[x]
instance HEqByFn le => HMSortBy le '[] '[]
instance HQSortBy le a b => HSortBy1 'False le a b
instance HSortBy1 'True le a a
instance (SameLength a b, HIsAscList le a ok, HSortBy1 ok le a b) => HSortBy le a b
instance (HEqBy le x y b1, HIsAscList le (y : ys) b2, HAnd b1 b2 ~ b3) => HIsAscList le (x : y : ys) b3
instance HEqByFn le => HIsAscList le '[] 'True
instance HEqByFn le => HIsAscList le '[x] 'True
instance (HEqBy le y x b1, HNot b1 ~ b2) => HEqBy (HNeq le) x y b2
instance HEqByFn a => HEqByFn (HNeq a)
instance HEqBy f y x b => HEqBy (HDown f) x y b
instance HEqByFn a => HEqByFn (HDown a)
instance (HEqBy HLeFn n m b, ns ~ ns') => HEqBy HLeFn (Lbl n ns desc) (Lbl m ns' desc') b
instance HEqBy HLeFn x y b => HEqBy HLeFn (Proxy x) (Proxy y) b
instance HEqBy HLeFn x y b => HEqBy HLeFn (Label x) (Label y) b
instance HEqBy HLeFn x y b => HEqBy HLeFn (Tagged x v) (Tagged y w) b
instance HLe x y ~ b => HEqBy HLeFn x y b
instance HEqByFn HLeFn
instance (HEq (CmpSymbol x y) 'GT nb, HNot nb ~ b) => HEqBy HLeFn x y b
instance (x <=? y) ~ b => HEqBy HLeFn x y b


-- | The HList library
--   
--   (C) 2004, Oleg Kiselyov, Ralf Laemmel, Keean Schupke
--   
--   Yet another model of labels.
--   
--   This model allow us to use any type as label type. As a result, we
--   need some generic instances.
--   
--   Also, type errors may be more confusing now.
module Data.HList.Label5

-- | Equality on labels
--   
--   Show label
instance [overlap ok] Typeable x => ShowLabel x


-- | The HList library
--   
--   (C) 2004, Oleg Kiselyov, Ralf Laemmel, Keean Schupke
--   
--   Yet another model of labels.
--   
--   Labels are promoted Strings or Integers <a>GHC.TypeLits</a> inside the
--   <a>Label</a>. Needs ghc7.6 or higher.
--   
--   See <a>CommonMain#label6demo</a> for an example.
module Data.HList.Label6
instance HExtend (Label y) (Proxy (x : xs))
instance HExtend (Label y) (Proxy (x : xs))
instance KnownNat x => ShowLabel x
instance KnownSymbol x => ShowLabel x


-- | The HList library
--   
--   (C) 2004-2006, Oleg Kiselyov, Ralf Laemmel, Keean Schupke
--   
--   Extensible records
--   
--   The three-ish models of labels that go with this module;
--   
--   <ul>
--   <li><a>Data.HList.Label3</a></li>
--   <li><a>Data.HList.Label5</a></li>
--   <li><a>Data.HList.Label6</a></li>
--   <li><a>Data.HList.Labelable</a></li>
--   </ul>
--   
--   These used to work:
--   
--   <ul>
--   <li><a>Data.HList.Label1</a></li>
--   <li><a>Data.HList.Label2</a></li>
--   <li><a>Data.HList.Label4</a></li>
--   </ul>
module Data.HList.Record

-- | Create a value with the given label. Analagous to a data constructor
--   such as <a>Just</a>, <a>Left</a>, or <a>Right</a>. Higher fixity than
--   record-modification operations like (<a>.*.</a>), (<a>.-.</a>), etc.
--   to support expression like the below w/o parentheses:
--   
--   <pre>
--   &gt;&gt;&gt; x .=. "v1" .*. y .=. '2' .*. emptyRecord
--   Record{x="v1",y='2'}
--   </pre>
(.=.) :: Label l -> v -> Tagged l v
newtype Record (r :: [*])
Record :: (HList r) -> Record

-- | Build a record
mkRecord :: HRLabelSet r => HList r -> Record r

-- | Build an empty record
emptyRecord :: Record []

-- | serves the same purpose as <a>hEnd</a>
hEndR :: Record a -> Record a

-- | <pre>
--   <a>hEndP</a> $ <a>hBuild</a> label1 label2
--   </pre>
--   
--   is one way to make a Proxy of labels (for use with <a>asLabelsOf</a>
--   for example). Another way is
--   
--   <pre>
--   label1 .*. label2 .*. <a>emptyProxy</a>
--   </pre>
hEndP :: Proxy (xs :: [k]) -> Proxy xs

-- | <pre>
--   HRLabelSet t =&gt; Iso (HList s) (HList t) (Record s) (Record t)
--   </pre>
hListRecord :: (HLabelSet [*] (LabelsOf r), HAllTaggedLV r, Profunctor p, Functor f) => p (Record r) (f (Record t)) -> p (HList r) (f (HList t))

-- | <pre>
--   Iso' (HList s) (Record s)
--   </pre>
hListRecord' :: (Profunctor p, Functor f) => p (Record r) (f (Record r)) -> p (HList r) (f (HList r))

-- | Construct the (phantom) list of labels of a record, or list of Label.
labelsOf :: hlistOrRecord l -> Proxy (LabelsOf l)

-- | similar to <a>asTypeOf</a>:
--   
--   <pre>
--   &gt;&gt;&gt; let s0 = Proxy :: Proxy '["x", "y"]
--   
--   &gt;&gt;&gt; let s1 = Proxy :: Proxy '[Label "x", Label "y"]
--   
--   &gt;&gt;&gt; let s2 = Proxy :: Proxy '[Tagged "x" Int, Tagged "y" Char]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let f0 r = () where _ = r `asLabelsOf` s0
--   
--   &gt;&gt;&gt; let f1 r = () where _ = r `asLabelsOf` s1
--   
--   &gt;&gt;&gt; let f2 r = () where _ = r `asLabelsOf` s2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :t f0
--   f0 :: r '[Tagged "x" v, Tagged "y" v1] -&gt; ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :t f1
--   f1 :: r '[Tagged "x" v, Tagged "y" v1] -&gt; ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :t f2
--   f2 :: r '[Tagged "x" v, Tagged "y" v1] -&gt; ()
--   </pre>
asLabelsOf :: (HAllTaggedLV x, SameLabels x y, SameLength x y) => r x -> s y -> r x

-- | Construct the HList of values of the record.
class SameLength r (RecordValuesR r) => RecordValues (r :: [*]) where type family RecordValuesR r :: [*]
recordValues' :: RecordValues r => HList r -> HList (RecordValuesR r)
recordValues :: RecordValues r => Record r -> HList (RecordValuesR r)

-- | "inverse" to <a>recordValues</a>
hMapTaggedFn :: HMapTaggedFn a b => HList a -> Record b

-- | <pre>
--   Iso (Record s) (Record t) (HList a) (HList b)
--   </pre>
--   
--   <pre>
--   view unlabeled == <a>recordValues</a>
--   </pre>
unlabeled0 :: (RecordValues y, RecordValues x, HMapAux HList TaggedFn (RecordValuesR y) y, SameLabels [*] [*] x y, Profunctor p, Functor f) => p (HList (RecordValuesR x)) (f (HList (RecordValuesR y))) -> p (Record x) (f (Record y))
type Unlabeled x y = (HMapCxt HList TaggedFn (RecordValuesR y) y, RecordValues x, RecordValues y, SameLength (RecordValuesR x) (RecordValuesR y), SameLength x y, SameLabels x y, HAllTaggedLV x, HAllTaggedLV y)
unlabeled :: (Unlabeled x y, Profunctor p, Functor f) => (HList (RecordValuesR x) `p` f (HList (RecordValuesR y))) -> (Record x `p` f (Record y))
type Unlabeled' x = Unlabeled x x

-- | <pre>
--   Unlabeled' x =&gt; Iso' (Record x) (HList (RecordValuesR x))
--   </pre>
unlabeled' :: (Unlabeled' x, Profunctor p, Functor f) => (HList (RecordValuesR x) `p` f (HList (RecordValuesR x))) -> (Record x `p` f (Record x))
class ShowComponents l
showComponents :: ShowComponents l => String -> HList l -> String
class ShowLabel l
showLabel :: ShowLabel l => Label l -> String
(.*.) :: HExtend e l => e -> l -> HExtendR e l

-- | Remove a field from a record. At the same level as other record
--   modification options (<a>.*.</a>). Analagous to (<tt>\\</tt>) in
--   lists.
--   
--   <pre>
--   record1 .-. label1
--   </pre>
--   
--   <pre>
--   label1 .=. value1 .*.
--   label2 .=. value2 .-.
--   label2 .*.
--   emptyRecord
--   </pre>
--   
--   <pre>
--   label1 .=. value1 .-.
--   label1 .*.
--   label2 .=. value2 .*.
--   emptyRecord
--   </pre>
--   
--   <pre>
--   record1 .*. label1 .=. record2 .!. label1
--           .*. label2 .=. record2 .!. label2
--           .-. label1
--   </pre>
(.-.) :: HDeleteAtLabel r l xs xs' => r xs -> Label l -> r xs'
class HDeleteLabels ks r r' | ks r -> r'
hDeleteLabels :: HDeleteLabels ks r r' => proxy (ks :: [*]) -> Record r -> Record r'
class HLensCxt x r s t a b => HLens x r s t a b | x s b -> t, x t a -> s, x s -> a, x t -> b
hLens :: HLens x r s t a b => Label x -> (forall f. Functor f => (a -> f b) -> (r s -> f (r t)))

-- | This is a baseline implementation. We use a helper class, HasField, to
--   abstract from the implementation.
--   
--   Because <a>hLookupByLabel</a> is so frequent and important, we
--   implement it separately, more efficiently. The algorithm is familiar
--   assq, only the comparison operation is done at compile-time
class HasField (l :: k) r v | l r -> v
hLookupByLabel :: HasField l r v => Label l -> r -> v

-- | a version of <a>HasField</a> <i> <a>hLookupByLabel</a> </i> <a>.!.</a>
--   that returns a default value when the label is not in the record:
--   
--   <pre>
--   &gt;&gt;&gt; let r = x .=. "the x value" .*. emptyRecord
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hLookupByLabelM y r ()
--   ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hLookupByLabelM x r ()
--   "the x value"
--   </pre>
class HasFieldM (l :: k) r (v :: Maybe *) | l r -> v
hLookupByLabelM :: HasFieldM l r v => Label l -> r -> t -> DemoteMaybe t v

-- | Lookup a value in a record by its label. Analagous to (!!), the list
--   indexing operation. Highest fixity, like (<a>!!</a>).
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   let record1 = x .=. 3 .*.
--                 y .=. 'y' .*.
--                 emptyRecord
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; record1 .!. x
--   3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; record1 .!. y
--   'y'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   let r2 = y .=. record1 .!. x .*.
--            z .=. record1 .!. y .*.
--            emptyRecord
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; r2
--   Record{y=3,z='y'}
--   </pre>
--   
--   Note that labels made following <a>Data.HList.Labelable</a> allow
--   using "Control.Lens.^." instead.
(.!.) :: HasField l r v => r -> Label l -> v

-- | Update a field with a particular value. Same fixity as (.*.) so that
--   extensions and updates can be chained. There is no real list analogue,
--   since there is no Prelude defined update.
--   
--   <pre>
--   label1 .=. value1 .@. record1
--   </pre>
(.@.) :: (HUpdateAtLabel k record l v r r', SameLength' * * r' r, SameLength' * * r r') => Tagged k l v -> record r -> record r'

-- | <a>hUpdateAtLabel</a> <tt>label value record</tt>
class HUpdateAtLabel record (l :: k) (v :: *) (r :: [*]) (r' :: [*]) | l v r -> r', l r' -> v
hUpdateAtLabel :: (HUpdateAtLabel record l v r r', SameLength r r') => Label l -> v -> record r -> record r'

-- | The same as <a>.@.</a>, except type preserving. It has the same fixity
--   as (.@.).
(.<.) :: (HUpdateAtLabel k record l v r r, SameLength' * * r r) => Tagged k l v -> record r -> record r
type HTPupdateAtLabel record l v r = (HUpdateAtLabel record l v r r, SameLength' r r)

-- | We could also say:
--   
--   <pre>
--   hTPupdateAtLabel l v r = hUpdateAtLabel l v r `asTypeOf` r
--   </pre>
--   
--   Then we were taking a dependency on Haskell's type equivalence. This
--   would also constrain the actual implementation of hUpdateAtLabel.
--   
--   A variation on <a>hUpdateAtLabel</a>: type-preserving update.
hTPupdateAtLabel :: HTPupdateAtLabel record l v r => Label l -> v -> record r -> record r

-- | Rename the label of record
--   
--   <pre>
--   &gt;&gt;&gt; hRenameLabel x y (x .=. () .*. emptyRecord)
--   Record{y=()}
--   </pre>
hRenameLabel :: (HasField k l (r v) v1, HExtend (Tagged k1 l1 v1) (r v'), HDeleteAtLabel k r l v v') => Label k l -> Label k1 l1 -> r v -> HExtendR (Tagged k1 l1 v1) (r v')

-- | A helper to make the Proxy needed by hProjectByLabels, and similar
--   functions which accept a list of kind [*].
--   
--   For example:
--   
--   <pre>
--   (rin,rout) = <a>hProjectByLabels2</a> (Proxy :: Labels ["x","y"]) r
--   </pre>
--   
--   behaves like
--   
--   <pre>
--   rin = r .!. (Label :: Label "x") .*.
--         r .!. (Label :: Label "y") .*.
--         emptyRecord
--   
--   rout = r .-. (Label :: Label "x") .-. (Label :: Label "y")
--   </pre>

-- | <tt>hProjectByLabels ls r</tt> returns <tt>r</tt> with only the labels
--   in <tt>ls</tt> remaining
hProjectByLabels :: (HRLabelSet a, H2ProjectByLabels ls t a b) => proxy ls -> Record t -> Record a
hProjectByLabels' :: (HLabelSet [*] (LabelsOf l), HLabelSet [*] (LabelsOf r), H2ProjectByLabels (LabelsOf l) t r b, HRearrange3 (LabelsOf l) r l, SameLength' * * (LabelsOf l) r, SameLength' * * l r, SameLength' * * r (LabelsOf l), SameLength' * * r l, HAllTaggedLV r) => Record t -> Record l

-- | See <a>H2ProjectByLabels</a>
hProjectByLabels2 :: (H2ProjectByLabels ls t t1 t2, HRLabelSet t1, HRLabelSet t2) => Proxy ls -> Record t -> (Record t1, Record t2)
class HLeftUnion r r' r'' | r r' -> r''
hLeftUnion :: HLeftUnion r r' r'' => Record r -> Record r' -> Record r''

-- | Similar to list append, so give this slightly lower fixity than (.*.),
--   so we can write:
--   
--   <pre>
--   field1 .=. value .*. record1 .&lt;++. record2
--   </pre>
(.<++.) :: HLeftUnion r r' r'' => Record r -> Record r' -> Record r''
class UnionSymRec r1 r2 ru | r1 r2 -> ru
unionSR :: UnionSymRec r1 r2 ru => Record r1 -> Record r2 -> (Record ru, Record ru)

-- | Rearranges a record by labels. Returns the record r, rearranged such
--   that the labels are in the order given by ls. (LabelsOf r) must be a
--   permutation of ls.
hRearrange :: (HLabelSet ls, HRearrange ls r r') => Proxy ls -> Record r -> Record r'

-- | <a>hRearrange'</a> is <a>hRearrange</a> where ordering specified by
--   the Proxy argument is determined by the result type.
--   
--   With built-in haskell records, these <tt>e1</tt> and <tt>e2</tt> have
--   the same type:
--   
--   <pre>
--   data R = R { x, y :: Int }
--   e1 = R{ x = 1, y = 2}
--   e2 = R{ y = 2, x = 1}
--   </pre>
--   
--   <a>hRearrange'</a> can be used to allow either ordering to be
--   accepted:
--   
--   <pre>
--   h1, h2 :: Record [ Tagged "x" Int, Tagged "y" Int ]
--   h1 = hRearrange' $
--       x .=. 1 .*.
--       y .=. 2 .*.
--       emptyRecord
--   
--   h2 = hRearrange' $
--       y .=. 2 .*.
--       x .=. 1 .*.
--       emptyRecord
--   </pre>
hRearrange' :: (HLabelSet [*] (LabelsOf l), HRearrange3 (LabelsOf l) r l, SameLength' * * (LabelsOf l) r, SameLength' * * l r, SameLength' * * r (LabelsOf l), SameLength' * * r l) => Record r -> Record l
class Rearranged r s t a b
rearranged :: (Rearranged r s t a b, Profunctor p, Functor f) => r a `p` f (r b) -> r s `p` f (r t)

-- | <pre>
--   Iso' (r s) (r a)
--   </pre>
--   
--   where <tt>s</tt> is a permutation of <tt>a</tt>
rearranged' :: (Rearranged k r s s b b, Profunctor p, Functor f) => p (r b) (f (r b)) -> p (r s) (f (r s))

-- | map over the values of a record. This is a shortcut for
--   
--   <pre>
--   \ f (Record a) -&gt; Record (hMap (HFmap f) a)
--   </pre>
--   
--   <ul>
--   <li><i><tt>Example</tt></i></li>
--   </ul>
--   
--   suppose we have a function that should be applied to every element of
--   a record: &gt;&gt;&gt; let circSucc_ x | x == maxBound = minBound |
--   otherwise = succ x
--   
--   <pre>
--   :t circSucc_
--   </pre>
--   
--   circSucc_ :: (Eq a, Enum a, Bounded a) =&gt; a -&gt; a
--   
--   Use a shortcut (<a>Fun</a>) to create a value that has an appropriate
--   <a>ApplyAB</a> instance: &gt;&gt;&gt; let circSucc = Fun circSucc_ ::
--   Fun '[Eq,Enum,Bounded] '()
--   
--   Confirm that we got Fun right: &gt;&gt;&gt; :t applyAB circSucc
--   applyAB circSucc :: (Bounded b, Enum b, Eq b) =&gt; b -&gt; b
--   
--   <pre>
--   &gt;&gt;&gt; applyAB circSucc True
--   False
--   </pre>
--   
--   define the actual record: &gt;&gt;&gt; let r = x .=. <tt>a</tt> .*. y
--   .=. False .*. emptyRecord &gt;&gt;&gt; r Record{x=<tt>a</tt>,y=False}
--   
--   <pre>
--   &gt;&gt;&gt; hMapR circSucc r
--   Record{x='b',y=True}
--   </pre>
hMapR :: (HMapAux HList (HFmap f) x y, SameLength' * * y x, SameLength' * * x y) => f -> Record x -> Record y
newtype HMapR f
HMapR :: f -> HMapR f

-- | <tt>Iso (Record s) (Record t) (Record a) (Record b)</tt>, such that
--   <tt>relabeled = unlabeled . from unlabeled</tt>
--   
--   in other words, pretend a record has different labels, but the same
--   values.
class Relabeled r
relabeled :: (Relabeled r, HMapTaggedFn (RecordValuesR s) a, HMapTaggedFn (RecordValuesR b) t, SameLengths '[s, a, t, b], RecordValuesR t ~ RecordValuesR b, RecordValuesR s ~ RecordValuesR a, RecordValues b, RecordValues s, Profunctor p, Functor f) => r a `p` f (r b) -> r s `p` f (r t)

-- | <pre>
--   Iso' (Record s) (Record a)
--   </pre>
--   
--   such that <tt>RecordValuesR s ~ RecordValuesR a</tt>
relabeled' :: (Relabeled r, RecordValues b, RecordValues a, RecordValues s, HMapAux HList TaggedFn (RecordValuesR s) a, HMapAux HList TaggedFn (RecordValuesR s) s, SameLength' * * (RecordValuesR s) a, SameLength' * * b s, SameLength' * * a (RecordValuesR s), SameLength' * * a s, SameLength' * * s b, SameLength' * * s a, Profunctor p, Functor f, (~) [*] (RecordValuesR b) (RecordValuesR s), (~) [*] (RecordValuesR a) (RecordValuesR s)) => p (r a) (f (r b)) -> p (r s) (f (r s))

-- | Property of a proper label set for a record: no duplication of labels,
--   and every element of the list is <tt>Tagged label value</tt>
data DuplicatedLabel l
data ExtraField l
data FieldNotFound l

-- | a variation on <a>hZip</a> for <a>Proxy</a>, where the list of labels
--   does not have to include Label (as in <tt>ts'</tt>)
--   
--   <pre>
--   &gt;&gt;&gt; let ts = Proxy :: Proxy ["x","y"]
--   
--   &gt;&gt;&gt; let ts' = Proxy :: Proxy [Label "x",Label "y"]
--   
--   &gt;&gt;&gt; let vs = Proxy :: Proxy [Int,Char]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :t zipTagged ts Proxy
--   zipTagged ts Proxy :: Proxy '[Tagged "x" y, Tagged "y" y1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :t zipTagged ts vs
--   zipTagged ts vs :: Proxy '[Tagged "x" Int, Tagged "y" Char]
--   </pre>
--   
--   And and the case when hZip does the same thing:
--   
--   <pre>
--   &gt;&gt;&gt; :t zipTagged ts' vs
--   zipTagged ts' vs :: Proxy '[Tagged "x" Int, Tagged "y" Char]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :t hZip ts' vs
--   hZip ts' vs :: Proxy '[Tagged "x" Int, Tagged "y" Char]
--   </pre>
zipTagged :: (MapLabel ts ~ lts, HZip Proxy lts vs tvs) => Proxy ts -> proxy vs -> Proxy tvs
class HasField' (b :: Bool) (l :: k) (r :: [*]) v | b l r -> v
hLookupByLabel' :: HasField' b l r v => Proxy b -> Label l -> HList r -> v
class HasFieldM1 (b :: Maybe [*]) (l :: k) r v | b l r -> v
hLookupByLabelM1 :: HasFieldM1 b l r v => Proxy b -> Label l -> r -> t -> DemoteMaybe t v

-- | <i>Invariant</i>:
--   
--   <pre>
--   r === rin `disjoint-union` rout
--   labels rin === ls
--       where (rin,rout) = hProjectByLabels ls r
--   </pre>
class H2ProjectByLabels (ls :: [*]) r rin rout | ls r -> rin rout
h2projectByLabels :: H2ProjectByLabels ls r rin rout => proxy ls -> HList r -> (HList rin, HList rout)
class H2ProjectByLabels' (b :: Maybe [*]) (ls :: [*]) r rin rout | b ls r -> rin rout
h2projectByLabels' :: H2ProjectByLabels' b ls r rin rout => Proxy b -> proxy ls -> HList r -> (HList rin, HList rout)

-- | Relation between HLabelSet and HRLabelSet
--   
--   <pre>
--   instance HLabelSet (LabelsOf ps) =&gt; HRLabelSet ps
--   </pre>
--   
--   see also <tt>HSet</tt>
class HLabelSet ls
class HLabelSet' l1 l2 (leq :: Bool) r
class (HLabelSet (LabelsOf ps), HAllTaggedLV ps) => HRLabelSet (ps :: [*])

-- | The <tt>Record</tt>, <tt>Variant</tt>, <tt>TIP</tt>, <tt>TIC</tt> type
--   constructors only make sense when they are applied to an instance of
--   this class
class HAllTaggedLV (ps :: [*])

-- | Helper class for <a>hRearrange</a>
class (HRearrange3 ls r r', LabelsOf r' ~ ls, SameLength ls r, SameLength r r') => HRearrange (ls :: [*]) r r' | ls r -> r', r' -> ls
hRearrange2 :: HRearrange ls r r' => proxy ls -> HList r -> HList r'

-- | same as HRearrange, except no backwards FD
class HRearrange3 (ls :: [*]) r r' | ls r -> r'
hRearrange3 :: HRearrange3 ls r r' => proxy ls -> HList r -> HList r'

-- | Helper class 2 for <a>hRearrange</a>
class HRearrange4 (l :: *) (ls :: [*]) rin rout r' | l ls rin rout -> r'
hRearrange4 :: HRearrange4 l ls rin rout r' => proxy l -> Proxy ls -> HList rin -> HList rout -> HList r'
class UnionSymRec' (b :: Bool) r1 f2 r2' ru | b r1 f2 r2' -> ru
unionSR' :: UnionSymRec' b r1 f2 r2' ru => Proxy b -> Record r1 -> f2 -> Record r2' -> (Record ru, Record ru)

-- | A version of <a>HFind</a> where the <tt>ls</tt> type variable is a
--   list of <a>Tagged</a> or <a>Label</a>. This is a bit indirect, and
--   ideally LabelsOf could have kind [*] -&gt; [k].
type HFindLabel (l :: k) (ls :: [*]) (n :: HNat) = HFind l (UnLabel l (LabelsOf ls)) n

-- | Label accessor
labelLVPair :: Tagged l v -> Label l
newLVPair :: Label l -> v -> Tagged l v

-- | remove the Label type constructor. The <tt>proxy</tt> argument is
--   supplied to make it easier to fix the kind variable <tt>k</tt>.
type HMemberLabel l r b = HMember l (UnLabel l (LabelsOf r)) b
data TaggedFn
TaggedFn :: TaggedFn
data ReadComponent
type HMapTaggedFn l r = (HMapCxt HList TaggedFn l r, RecordValuesR r ~ l, RecordValues r)

-- | constraints needed to implement <a>HLens</a>
type HLensCxt x r s t a b = (HasField x (r s) a, HUpdateAtLabel r x b s t, HasField x (r t) b, HUpdateAtLabel r x a t s, SameLength s t, SameLabels s t)
class HZipRecord x y xy | x y -> xy, xy -> x y
hZipRecord :: HZipRecord x y xy => Record x -> Record y -> Record xy
hUnzipRecord :: HZipRecord x y xy => Record xy -> (Record x, Record y)

-- | instead of explicit recursion above, we could define HZipRecord in
--   terms of <a>HZipList</a>. While all types are inferred, this
--   implementation is probably slower, so explicit recursion is used in
--   the <a>HZip</a> <a>Record</a> instance.
hZipRecord2 :: (RecordValues y1, RecordValues y, RecordValues x, HMapAux HList TaggedFn (RecordValuesR x) x, HZipList (RecordValuesR y1) (RecordValuesR y) (RecordValuesR x), SameLength' * * y1 x, SameLength' * * y x, SameLength' * * x y1, SameLength' * * x y, SameLabels [*] [*] x y1, SameLabels [*] [*] x y, HAllTaggedLV x) => Record y1 -> Record y -> Record x
hUnzipRecord2 :: (RecordValues y, RecordValues x1, RecordValues x, HMapAux HList TaggedFn (RecordValuesR x) x, HMapAux HList TaggedFn (RecordValuesR x1) x1, HZipList (RecordValuesR x) (RecordValuesR x1) (RecordValuesR y), SameLength' * * y x1, SameLength' * * y x, SameLength' * * x1 y, SameLength' * * x y, SameLabels [*] [*] x1 y, SameLabels [*] [*] x y, HAllTaggedLV x1, HAllTaggedLV x) => Record y -> (Record x, Record x1)
instance Bounded (HList r) => Bounded (Record r)
instance Ix (HList r) => Ix (Record r)
instance Ord (HList r) => Ord (Record r)
instance Eq (HList r) => Eq (Record r)
instance Monoid (HList r) => Monoid (Record r)
instance HZipRecord as bs abss => HZipRecord (Tagged x a : as) (Tagged x b : bs) (Tagged x (a, b) : abss)
instance HZipRecord '[] '[] '[]
instance HUnzip Proxy ls vs lvs => HZip Proxy ls vs lvs
instance (RecordValuesR lvs ~ vs, SameLabels ls lvs, LabelsOf lvs ~ ls, SameLengths '[ls, vs, lvs], HAllTaggedLV lvs) => HUnzip Proxy ls vs lvs
instance (HZipRecord x y xy, SameLengths '[x, y, xy]) => HUnzip Record x y xy
instance (HZipRecord x y xy, SameLengths '[x, y, xy]) => HZip Record x y xy
instance (HRevAppR l '[] ~ lRev, HExtendRs lRev (Proxy '[]) ~ Proxy l1, l' ~ l1) => HBuild' l (Proxy l')
instance (HReverse l lRev, HMapTaggedFn lRev l') => HBuild' l (Record l')
instance HMapAux HList (HFmap f) x y => HMapAux Record f x y
instance (HMapCxt Record f x y, rx ~ Record x, ry ~ Record y) => ApplyAB (HMapR f) rx ry
instance (HLensCxt r x s t a b) => HLens r x s t a b
instance Fail (ExtraField l) => HRearrange3 '[] (Tagged l v : a) '[]
instance Fail (FieldNotFound l) => HRearrange4 l ls '[] rout '[]
instance (HRearrange3 ls rout r', r'' ~ (Tagged l v : r'), ll ~ Label l) => HRearrange4 ll ls '[Tagged l v] rout r''
instance (H2ProjectByLabels '[l] r rin rout, HRearrange4 l ls rin rout r', l ~ Label ll) => HRearrange3 (l : ls) r r'
instance HRearrange3 '[] '[] '[]
instance (HRearrange3 ls r r', LabelsOf r' ~ ls, SameLength ls r, SameLength r r') => HRearrange ls r r'
instance (la ~ LabelsOf a, lt ~ LabelsOf t, HRearrange la s a, HRearrange lt b t, HLabelSet la, HLabelSet lt) => Rearranged Record s t a b
instance (UnionSymRec r1 r2' ru, HExtend f2 (Record ru), Record f2ru ~ HExtendR f2 (Record ru)) => UnionSymRec' 'False r1 f2 r2' f2ru
instance (UnionSymRec r1 r2' ru, HTPupdateAtLabel Record l2 v2 ru, f2 ~ Tagged l2 v2) => UnionSymRec' 'True r1 f2 r2' ru
instance (HMemberLabel l r1 b, UnionSymRec' b r1 (Tagged l v) r2' ru) => UnionSymRec r1 (Tagged l v : r2') ru
instance r1 ~ r1' => UnionSymRec r1 '[] r1'
instance (HDeleteLabels (LabelsOf l) r r', HAppend (Record l) (Record r'), HAppendR (Record l) (Record r') ~ Record lr) => HLeftUnion l r lr
instance HDeleteLabels ks '[] '[]
instance (HMember (Label l) ks b, HCond b (Record r2) (Record (Tagged l v : r2)) (Record r3), HDeleteLabels ks r1 r2) => HDeleteLabels ks (Tagged l v : r1) r3
instance H2ProjectByLabels (LabelsOf r2) r1 r2 rout => SubType (Record r1) (Record r2)
instance H2ProjectByLabels ls r rin rout => H2ProjectByLabels' 'Nothing ls (f : r) rin (f : rout)
instance H2ProjectByLabels ls1 r rin rout => H2ProjectByLabels' ('Just ls1) ls (f : r) (f : rin) rout
instance (HMemberM (Label l1) (l : ls) b, H2ProjectByLabels' b (l : ls) (Tagged l1 v1 : r1) rin rout) => H2ProjectByLabels (l : ls) (Tagged l1 v1 : r1) rin rout
instance H2ProjectByLabels (l : ls) '[] '[] '[]
instance H2ProjectByLabels '[] r '[] r
instance Fail (FieldNotFound l) => HUpdateAtLabel2 l v '[] '[]
instance (HEqK l l' b, HUpdateAtLabel1 b l v (Tagged l' e : xs) xs') => HUpdateAtLabel2 l v (Tagged l' e : xs) xs'
instance HUpdateAtLabel2 l v xs xs' => HUpdateAtLabel1 'False l v (x : xs) (x : xs')
instance HUpdateAtLabel1 'True l v (Tagged l e : xs) (Tagged l v : xs)
instance (HUpdateAtLabel2 l v r r', HasField l (Record r') v) => HUpdateAtLabel Record l v r r'
instance H2ProjectByLabels '[Label l] v t1 v' => HDeleteAtLabel Record l v v'
instance HasField l (Record r) v => HasField' 'False l (fld : r) v
instance HasField' 'True l (Tagged l v : r) v
instance Fail (FieldNotFound l) => HasField l (Record '[]) (FieldNotFound l)
instance (HEqK l l1 b, HasField' b l (Tagged l1 v1 : r) v) => HasField l (Record (Tagged l1 v1 : r)) v
instance HasField l r v => HasFieldM1 ('Just b) l r ('Just v)
instance HasFieldM1 'Nothing l r 'Nothing
instance (HMemberM (Label l) (LabelsOf xs) b, HasFieldM1 b l (r xs) v) => HasFieldM l (r xs) v
instance (HRLabelSet (HAppendListR r1 r2), HAppend (HList r1) (HList r2)) => HAppend (Record r1) (Record r2)
instance HRLabelSet (t : r) => HExtend t (Record r)
instance (HMapCxt HList ReadComponent (AddProxy rs) bs, ApplyAB ReadComponent (Proxy r) readP_r, HProxies rs, HSequence ReadP (readP_r : bs) (r : rs)) => Read (Record (r : rs))
instance (Read v, ShowLabel l, x ~ Tagged l v, ReadP x ~ y) => ApplyAB ReadComponent (Proxy x) y
instance (ShowLabel l, Show v, ShowComponents r) => ShowComponents (Tagged l v : r)
instance ShowComponents '[]
instance ShowComponents r => Show (Record r)
instance RecordValues r => RecordValues (Tagged l v : r)
instance RecordValues '[]
instance Fail (DuplicatedLabel l1) => HLabelSet' l1 l2 'True r
instance (HLabelSet (l2 : r), HLabelSet (l1 : r)) => HLabelSet' l1 l2 'False r
instance (HEqK l1 l2 leq, HLabelSet' l1 l2 leq r) => HLabelSet (l1 : l2 : r)
instance HLabelSet '[x]
instance HLabelSet '[]
instance (HLabelSet (LabelsOf ps), HAllTaggedLV ps) => HRLabelSet ps
instance tx ~ Tagged t x => ApplyAB TaggedFn x tx
instance Relabeled Record


module Data.HList.RecordPuns

-- | requires labels to be promoted strings (kind Symbol), as provided by
--   <a>Data.HList.Label6</a> (ie. the label for foo is <tt>Label :: Label
--   "foo"</tt>), or <a>Data.HList.Labelable</a>
pun :: QuasiQuoter
instance Show Tree


-- | The HList library
--   
--   (C) 2004, Oleg Kiselyov, Ralf Laemmel, Keean Schupke
--   
--   Type-indexed products. The public interface is described in
--   <a>CommonMain#TIP</a>
module Data.HList.TIP

-- | TIPs are like <a>Record</a>, except element "i" of the list "l" has
--   type <tt>Tagged e_i e_i</tt>
newtype TIP (l :: [*])
TIP :: HList l -> TIP
unTIP :: TIP -> HList l
mkTIP :: HTypeIndexed l => HList l -> TIP l
emptyTIP :: TIP []

-- | this constraint ensures that a TIP created by <a>mkTIP</a> has no
--   duplicates
class (HAllTaggedEq l, HRLabelSet l) => HTypeIndexed (l :: [*])
class HAllTaggedEq (l :: [*])

-- | One occurrence and nothing is left
--   
--   This variation provides an extra feature for singleton lists. That is,
--   the result type is unified with the element in the list. Hence the
--   explicit provision of a result type can be omitted.
onRecord :: (HAllTaggedEq l, HLabelSet [*] (LabelsOf l), HAllTaggedLV l) => (Record r -> Record l) -> TIP r -> TIP l
tipyUpdate :: (HUpdateAtLabel * record v v r r, SameLength' * * r r) => v -> record r -> record r

-- | Use <a>Labels</a> to specify the first argument
tipyProject :: (HAllTaggedEq l, HLabelSet [*] (LabelsOf l), H2ProjectByLabels ls r l b, HAllTaggedLV l) => proxy ls -> TIP r -> TIP l

-- | provides a <tt>Lens' (TIP s) a</tt>. <tt>hLens'</tt> <tt>:: Label a
--   -&gt; Lens' (TIP s) a</tt> is another option.
tipyLens' :: (HAllTaggedEq t, HLabelSet [*] (LabelsOf t), HasField * b (Record t) b, HUpdateAtLabel2 * b b t t, SameLength' * * t t, SameLabels [*] [*] t t, HAllTaggedLV t, Functor f) => (b -> f b) -> TIP t -> f (TIP t)

-- | provides a <tt>Lens (TIP s) (TIP t) a b</tt>
--   
--   When using <tt>set</tt> (also known as <tt>.~</tt>), <a>tipyLens'</a>
--   can address the ambiguity as to which field "a" should actually be
--   updated.
tipyLens :: (HAllTaggedEq t, HAllTaggedEq s, HLabelSet [*] (LabelsOf t), HLabelSet [*] (LabelsOf s), HasField * b (Record t) b, HasField * b (Record s) b, HUpdateAtLabel2 * b b t s, HUpdateAtLabel2 * b b s t, SameLength' * * t s, SameLength' * * s t, SameLabels [*] [*] s t, HAllTaggedLV t, HAllTaggedLV s, Functor f) => (b -> f b) -> TIP s -> f (TIP t)

-- | The same as <a>tipyProject</a>, except also return the types not
--   requested in the <tt>proxy</tt> argument
tipyProject2 :: (HAllTaggedEq l1, HAllTaggedEq l, HLabelSet [*] (LabelsOf l), HLabelSet [*] (LabelsOf l1), H2ProjectByLabels ls r l l1, HAllTaggedLV l1, HAllTaggedLV l) => proxy ls -> TIP r -> (TIP l, TIP l1)

-- | Subtyping for TIPs

-- | <a>TagR</a> can also be used to avoid redundancy when defining types
--   for TIC and TIP.
--   
--   <pre>
--   type XShort = TagR [A,B,C,D]
--   </pre>
--   
--   <pre>
--   type XLong = [Tagged A A, Tagged B B, Tagged C C, Tagged D D]
--   </pre>
--   
--   an equivalent FD version, which is slightly better with respect to
--   simplifying types containing type variables (in ghc-7.8 and 7.6):
--   <a>http://stackoverflow.com/questions/24110410/</a>
--   
--   With ghc-7.10 (http:/<i>ghc.haskell.org</i>trac<i>ghc</i>ticket/10009)
--   the FD version is superior to the TF version:
--   
--   <pre>
--   class (UntagR (TagR a) ~ a) =&gt; TagUntag a where
--       type TagR a :: [*]
--       hTagSelf :: HList a -&gt; HList (TagR a)
--       hUntagSelf :: HList (TagR a) -&gt; HList a
--   
--   instance TagUntag '[] where
--       type TagR '[] = '[]
--       hTagSelf _ = HNil
--       hUntagSelf _ = HNil
--   
--   instance TagUntag xs =&gt; TagUntag (x ': xs) where
--       type TagR (x ': xs) = Tagged x x ': TagR xs
--       hTagSelf (HCons x xs) = Tagged x <a>HCons</a> hTagSelf xs
--       hUntagSelf (HCons (Tagged x) xs) = x <a>HCons</a> hUntagSelf xs
--   
--   type family UntagR (xs :: [*]) :: [*]
--   type instance UntagR '[] = '[]
--   type instance UntagR (x ': xs) = Untag1 x ': UntagR xs
--   </pre>
--   
--   Length information should flow backwards
--   
--   <pre>
--   &gt;&gt;&gt; let len2 x = x `asTypeOf` (undefined :: HList '[a,b])
--   
--   &gt;&gt;&gt; let f = len2 $ hTagSelf (hReplicate Proxy ())
--   
--   &gt;&gt;&gt; :t f
--   f :: HList '[Tagged () (), Tagged () ()]
--   </pre>
class SameLength a ta => TagUntagFD a ta | a -> ta, ta -> a
hTagSelf :: TagUntagFD a ta => HList a -> HList ta
hUntagSelf :: TagUntagFD a ta => HList ta -> HList a
type TagUntag xs = TagUntagFD xs (TagR xs)

-- | Sometimes the type variables available have <tt>TagR</tt> already
--   applied (ie the lists have elements like <tt>Tagged X X</tt>). Then
--   this abbreviation is useful:
type UntagTag xs = TagUntagFD (UntagR xs) xs

-- | <pre>
--   Iso (TIP (TagR a)) (TIP (TagR b)) (HList a) (HList b)
--   </pre>
tipHList :: (TagUntagFD a1 l, TagUntagFD a ta, Profunctor p, Functor f) => p (HList a) (f (HList a1)) -> p (TIP ta) (f (TIP l))

-- | <pre>
--   Iso' (TIP (TagR s)) (HList a)
--   </pre>
tipHList' :: (TagUntagFD a ta, Profunctor p, Functor f) => p (HList a) (f (HList a)) -> p (TIP ta) (f (TIP ta))

-- | <pre>
--   Iso (TIP s) (TIP t) (Record s) (Record t)
--   </pre>
--   
--   <tt>typeIndexed</tt> may be more appropriate
tipRecord :: (Profunctor p, Functor f) => p (Record r) (f (Record l)) -> p (TIP r) (f (TIP l))

-- | <pre>
--   Iso' (TIP (TagR s)) (Record a)
--   </pre>
tipRecord' :: (Profunctor p, Functor f) => p (Record r) (f (Record r)) -> p (TIP r) (f (TIP r))

-- | specialization of <a>hZip</a>
hZipTIP :: (TagUntagFD y ta1, TagUntagFD x ta, TagUntagFD a l, HZipList x y a) => TIP ta -> TIP ta1 -> TIP l

-- | specialization of <a>hUnzip</a>
hUnzipTIP :: (HAllTaggedEq l2, HAllTaggedEq l1, TagUntagFD a1 l2, TagUntagFD a l1, TagUntagFD l ta, HLabelSet [*] (LabelsOf l1), HLabelSet [*] (LabelsOf l2), HZipList a a1 l, HAllTaggedLV l2, HAllTaggedLV l1) => TIP ta -> (TIP l1, TIP l2)

-- | Transforming a TIP: applying to a TIP a (polyvariadic) function that
--   takes arguments from a TIP and updates the TIP with the result.
--   
--   In more detail: we have a typed-indexed collection TIP and we would
--   like to apply a transformation function to it, whose argument types
--   and the result type are all in the TIP. The function should locate its
--   arguments based on their types, and update the TIP with the result.
--   The function may have any number of arguments, including zero; the
--   order of arguments should not matter.
--   
--   The problem was posed by Andrew U. Frank on Haskell-Cafe, Sep 10,
--   2009.
--   <a>http://www.haskell.org/pipermail/haskell-cafe/2009-September/066217.html</a>
--   The problem is an interesting variation of the keyword argument
--   problem.
--   
--   Examples can be found in <tt>examples/TIPTransform.hs</tt> and
--   <tt>examples/TIPTransformM.hs</tt>
class TransTIP op db
ttip :: TransTIP op db => op -> TIP db -> TIP db
class TransTIP1 (b :: Bool) (n :: HNat) op db
ttip1 :: TransTIP1 b n op db => Proxy b -> Proxy n -> op -> TIP db -> TIP db
class TransTIP2 (b :: Bool) arg op db
ttip2 :: TransTIP2 b arg op db => Proxy b -> (arg -> op) -> TIP db -> TIP db

-- | In March 2010, Andrew Frank extended the problem for monadic
--   operations. This is the monadic version of <tt>TIPTransform.hs</tt> in
--   the present directory.
--   
--   This is the TF implementation. When specifying the operation to
--   perform over a TIP, we can leave it polymorphic over the monad. The
--   type checker will instantiate the monad based on the context.
class Monad m => TransTIPM m op db
ttipM :: TransTIPM m op db => op -> TIP db -> m (TIP db)
class Monad m => TransTIPM1 (b :: Bool) (n :: HNat) m op db
ttipM1 :: TransTIPM1 b n m op db => Proxy b -> Proxy n -> op -> TIP db -> m (TIP db)
class TransTIPM2 (b :: Bool) m arg op db
ttipM2 :: TransTIPM2 b m arg op db => Proxy b -> (arg -> op) -> TIP db -> m (TIP db)
instance Bounded (HList r) => Bounded (TIP r)
instance Ix (HList r) => Ix (TIP r)
instance Ord (HList r) => Ord (TIP r)
instance Eq (HList a) => Eq (TIP a)
instance Monoid (HList a) => Monoid (TIP a)
instance Fail '(TypeNotFound op, "in TIP", db) => TransTIPM2 'False m arg op db
instance (HOccurs arg (TIP db), TransTIPM m op db) => TransTIPM2 'True m arg op db
instance (Monad m, HMember (Tagged arg arg) db b, TransTIPM2 b m arg op db) => TransTIPM1 'False ('HSucc n) m (arg -> op) db
instance (Fail '(TypeNotFound op, "in TIP", db), Monad m) => TransTIPM1 'False 'HZero m op db
instance (Monad m, m ~ m', HTPupdateAtLabel TIP op op db) => TransTIPM1 'True n m (m' op) db
instance (Monad m, HMember (Tagged op op) db b, Arity (m' op) n, TransTIPM1 b n m (m' op) db) => TransTIPM m (m' op) db
instance Fail '(TypeNotFound arg, "in TIP", db) => TransTIP2 'False arg op db
instance (HOccurs arg (TIP db), TransTIP op db) => TransTIP2 'True arg op db
instance Fail '(TypeNotFound notfun, "in TIP", db) => TransTIP1 'False 'HZero notfun db
instance (HMember (Tagged arg arg) db b, TransTIP2 b arg op db) => TransTIP1 'False ('HSucc n) (arg -> op) db
instance (HTPupdateAtLabel TIP op op db) => TransTIP1 'True n op db
instance (HMember (Tagged op op) db b, Arity op n, TransTIP1 b n op db) => TransTIP op db
instance (HZipList (UntagR x) (UntagR y) (UntagR xy), UntagTag x, UntagTag y, UntagTag xy, HTypeIndexed x, HTypeIndexed y, SameLengths '[x, y, xy]) => HUnzip TIP x y xy
instance (HZipList (UntagR x) (UntagR y) (UntagR xy), UntagTag x, UntagTag y, UntagTag xy, SameLengths '[x, y, xy], HTypeIndexed x, HTypeIndexed y, HUnzip TIP x y xy) => HZip TIP x y xy
instance (TagUntagFD xs ys, txx ~ Tagged x x) => TagUntagFD (x : xs) (txx : ys)
instance TagUntagFD '[] '[]
instance (HOccurs e (TIP l1), SubType (TIP l1) (TIP l2)) => SubType (TIP l1) (TIP (e : l2))
instance SubType (TIP l) (TIP '[])
instance (HUpdateAtLabel Record e' e r r', HTypeIndexed r', e ~ e') => HUpdateAtLabel TIP e' e r r'
instance (HDeleteAtLabel Record e v v', HTypeIndexed v') => HDeleteAtLabel TIP e v v'
instance (HAppend (HList l) (HList l'), HTypeIndexed (HAppendListR l l')) => HAppend (TIP l) (TIP l')
instance HasField e (Record (x : y : l)) e => HOccurs e (TIP (x : y : l))
instance tee ~ Tagged e e => HOccurs e (TIP '[tee])
instance (e ~ e', HasField e (Record l) e') => HasField e (TIP l) e'
instance (HRLabelSet (Tagged e e : l), HTypeIndexed l) => HExtend e (TIP l)
instance (HAllTaggedEq l, tee ~ Tagged e e') => HAllTaggedEq (tee : l)
instance HAllTaggedEq '[]
instance (HAllTaggedEq l, HRLabelSet l) => HTypeIndexed l
instance HMapOut (HComp HShow HUntag) l String => Show (TIP l)


-- | The HList library
--   
--   See <a>CommonMain#Variant</a> for the public (safe) interface.
--   
--   The implementation here follows <a>Data.Dynamic</a>, though Typeable
--   is not needed.
--   
--   See <tt>broken/VariantP.hs</tt> and <tt>broken/VariantOld.hs</tt> for
--   different approaches to open sums.
module Data.HList.Variant

-- | <tt>Variant vs</tt> has an implementation similar to <tt>Dynamic</tt>,
--   except the contained value is one of the elements of the <tt>vs</tt>
--   list, rather than being one particular instance of <a>Typeable</a>.
--   
--   <pre>
--   &gt;&gt;&gt; v .!. _right
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; v .!. _left
--   Just 'x'
--   </pre>
--   
--   In some cases the <tt>pun</tt> quasiquote works with variants,
--   
--   <pre>
--   &gt;&gt;&gt; let f [pun| left right |] = (left,right)
--   
--   &gt;&gt;&gt; f v
--   (Just 'x',Nothing)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; f w
--   (Nothing,Just 5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let add1 v = hMapV (Fun succ :: Fun '[Enum] '()) v
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; f (add1 v)
--   (Just 'y',Nothing)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; f (add1 w)
--   (Nothing,Just 6)
--   </pre>
data Variant (vs :: [*])
Variant :: !Int -> Any -> Variant

-- | This is only safe if the n'th element of vs has type <tt>Tagged t
--   v</tt>
unsafeMkVariant :: Int -> v -> Variant vs

-- | Safe when (e ~ e') given that
--   
--   <pre>
--   Tagged t e ~ HLookupByHNatR n v
--   Tagged t' e' ~ HLookupByHNatR n v'
--   </pre>
--   
--   <a>hUpdateAtLabel</a> is the safe version
unsafeCastVariant :: Variant v -> Variant v'

-- | in ghc&gt;=7.8, <a>coerce</a> is probably a better choice
castVariant :: (RecordValuesR v ~ RecordValuesR v', SameLength v v') => Variant v -> Variant v'

-- | private destructor. This is safe only if the value contained actually
--   has type <tt>e</tt>
unsafeUnVariant :: Variant v -> e

-- | This function is unsafe because it can lead to a runtime error when
--   used together with the <a>HExtend</a> instance (.*.)
--   
--   <pre>
--   &gt;&gt;&gt; print $ (Label :: Label "x") .=. (Nothing :: Maybe ()) .*. unsafeEmptyVariant
--   V{*** Exception: invalid variant
--   </pre>
--   
--   use <a>mkVariant1</a> instead
unsafeEmptyVariant :: Variant []
class HasField x (Variant vs) (Maybe v) => MkVariant x v vs | x vs -> v
mkVariant :: MkVariant x v vs => Label x -> v -> proxy vs -> Variant vs
mkVariant1 :: Label k l -> e -> Variant ((:) * (Tagged k l e) ([] *))
splitVariant1 :: Variant (Tagged s x : xs) -> Either x (Variant xs)

-- | x ~ Tagged s t
splitVariant1' :: Variant (x : xs) -> Either x (Variant xs)
extendVariant :: Variant l -> Variant (e : l)

-- | Make a <tt>Prism (Variant s) (Variant t) a b</tt> out of a Label.
--   
--   See <a>Data.HList.Labelable</a>.<tt>hLens'</tt> is a more overloaded
--   version.
--   
--   Few type annotations are necessary because of the restriction that
--   <tt>s</tt> and <tt>t</tt> have the same labels in the same order, and
--   to get "t" the "a" in "s" is replaced with "b".
class (SameLength s t, SameLabels s t) => HPrism x s t a b | x s -> a, x t -> b, x s b -> t, x t a -> s
hPrism :: (HPrism x s t a b, Choice p, Applicative f) => Label x -> p a (f b) -> p (Variant s) (f (Variant t))

-- | Variants are not opaque

-- | helper class for defining the Show instance
class ShowVariant vs
showVariant :: ShowVariant vs => Variant vs -> ShowS

-- | A corresponding read instance
class ReadVariant vs
readVariant :: ReadVariant vs => ReadP (Variant vs)
class VariantConstrs (xs :: [*])
variantConstrs :: VariantConstrs xs => DataType -> proxy xs -> [Constr]

-- | <ul>
--   <li><i><tt>implementation of gunfold for Variant</tt></i></li>
--   </ul>
--   
--   In ghci
--   
--   <pre>
--   :set -ddump-deriv -XDeriveDataTypeable
--   data X a b c = A a | B b | C c deriving (Data,Typeable)
--   </pre>
--   
--   shows that gunfold is defined something like
--   
--   <pre>
--   gunfold k z c = case constrIndex c of
--         1 -&gt; k (z Ghci1.A)
--         2 -&gt; k (z Ghci1.B)
--         _ -&gt; k (z Ghci1.C)
--   </pre>
--   
--   If we instead had
--   
--   type X a b c = Variant [Tagged <a>A</a> a, Tagged <a>B</a> b, Tagged
--   <a>C</a> c]
--   
--   Then we could write:
--   
--   <pre>
--   gunfold1 :: (forall b r. Data b =&gt; (b -&gt; r) -&gt; c r)
--   </pre>
--   
--   <ul>
--   <li>&gt; Variant [Tagged <a>A</a> a, Tagged <a>B</a> b, Tagged
--   <a>C</a> c] &gt; gunfold1 f c = case constrIndex c of &gt; 1 -&gt; f
--   mkA &gt; 2 -&gt; f mkB &gt; _ -&gt; f mkC &gt; where mkA a = mkVariant
--   (Label :: Label <a>A</a>) (a :: a) v &gt; mkB b = mkVariant (Label ::
--   Label <a>B</a>) (b :: b) v &gt; mkC c = mkVariant (Label :: Label
--   <a>C</a>) (c :: c) v &gt; v = Proxy :: Proxy [Tagged <a>A</a> a,
--   Tagged <a>B</a> b, Tagged <a>C</a> c]</li>
--   </ul>
--   
--   where <tt>f = k.z</tt>
class GunfoldVariant (es :: [*]) v
gunfoldVariant :: GunfoldVariant es v => (forall b. Data b => (b -> Variant v) -> c (Variant v)) -> Proxy es -> Int -> c (Variant v)
class GfoldlVariant xs xs'
gfoldlVariant :: GfoldlVariant xs xs' => (forall d b. Data d => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> Variant xs -> c (Variant xs')

-- | Apply a function to all possible elements of the variant
newtype HMapV f
HMapV :: f -> HMapV f

-- | shortcut for <tt>applyAB . HMapV</tt>. <a>hMap</a> is more general
hMapV :: (HMapAux Variant (HFmap f) x y, SameLength' * * y x, SameLength' * * x y) => f -> Variant x -> Variant y

-- | <tt>hMapOutV f = unvariant . hMapV f</tt>, except an ambiguous type
--   variable is resolved by <a>HMapOutV_gety</a>
hMapOutV :: (SameLength x y, HMapAux Variant (HFmap f) x y, Unvariant y z, HMapOutV_gety x z ~ y) => f -> Variant x -> z

-- | resolves an ambiguous type in <a>hMapOutV</a>

-- | apply a function to all values that could be in the variant.

-- | <pre>
--   hUpdateAtLabel x e' (mkVariant x e proxy) == mkVariant x e' proxy
--   hUpdateAtLabel y e' (mkVariant x e proxy) == mkVariant x e  proxy
--   </pre>
type HUpdateVariantAtLabelCxt l e v v' n _e = (HFindLabel l v n, HFindLabel l v' n, HUpdateAtHNatR n (Tagged l e) v ~ v', HasField l (Variant v) (Maybe _e), HasField l (Record v') e, MkVariant l e v')

-- | Extension for Variants prefers the first value
--   
--   <pre>
--   (l .=. Nothing) .*. v = v
--   (l .=. Just e)  .*. _ = mkVariant l e Proxy
--   </pre>
class HAllEqVal (x :: [*]) (b :: Bool) | x -> b
class HAllEqVal' (x :: [*])

-- | Similar to <a>unvariant</a>, except type variables in <tt>v</tt> will
--   be made equal to <tt>e</tt> if possible. That allows the type of
--   <tt>Nothing</tt> to be inferred as <tt>Maybe Char</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; unvariant' $ x .=. Nothing .*. mkVariant1 y 'y'
--   'y'
--   </pre>
--   
--   However, this difference leads to more local error messages
--   (<tt>Couldn't match type () with Char</tt>), rather than the
--   following with <tt>unvariant</tt>:
--   
--   <pre>
--   Fail
--      '("Variant",
--        '[Tagged "left" Char, Tagged "right" ()],
--        "must have all values equal to ",
--        e))
--   </pre>
class Unvariant' v e | v -> e
unvariant' :: Unvariant' v e => Variant v -> e

-- | Convert a Variant which has all possibilities having the same type
--   into a value of that type. Analogous to <tt>either id id</tt>.
--   
--   See also <a>unvariant'</a>
class Unvariant v e | v -> e
unvariant :: Unvariant v e => Variant v -> e
class Unvariant1 b v e | b v -> e
unvariant1 :: Unvariant1 b v e => Proxy b -> Variant v -> e
data UnvariantTypeMismatch (vs :: [*])

-- | <pre>
--   Lens (Variant s) (Variant t) a b
--   </pre>
--   
--   Analogue of <tt>Control.Lens.chosen :: Lens (Either a a) (Either b b)
--   a b</tt>
unvarianted :: (Unvariant' s a, Unvariant' t b, SameLabels s t, SameLength s t, Functor f) => (a -> f b) -> Variant s -> f (Variant t)

-- | <pre>
--   Lens' (Variant s) a
--   </pre>
--   
--   where we might have <tt>s ~ '[Tagged t1 a, Tagged t2 a]</tt>
unvarianted' :: (HAllEqVal ((:) * (Tagged * () b) s) b1, HAllEqVal s b1, HAllEqVal' ((:) * (Tagged * () b) s), Unvariant1 Bool b1 s b, SameLength' * * s s, SameLabels [*] [*] s s, Functor f) => (b -> f b) -> Variant s -> f (Variant s)

-- | Applies to variants that have the same labels in the same order. A
--   generalization of
--   
--   <pre>
--   zipEither :: Either a b -&gt; Either a b -&gt; Maybe (Either (a,a) (b,b))
--   zipEither (Left a) (Left a') = Just (Left (a,a'))
--   zipEither (Right a) (Right a') = Just (Right (a,a'))
--   zipEither _ _ = Nothing
--   </pre>
--   
--   see <a>HZip</a> for zipping other collections
class ZipVariant x y xy | x y -> xy, xy -> x y
zipVariant :: ZipVariant x y xy => Variant x -> Variant y -> Maybe (Variant xy)

-- | Apply a record of functions to a variant of values. The functions are
--   selected based on those having the same label as the value.
class (SameLength v v', SameLabels v v') => ZipVR fs v v' | fs v -> v'
zipVR_ :: ZipVR fs v v' => Record fs -> Variant v -> Variant v'

-- | <pre>
--   &gt;&gt;&gt; let xy = x .*. y .*. emptyProxy
--   
--   &gt;&gt;&gt; let p = Proxy `asLabelsOf` xy
--   
--   &gt;&gt;&gt; let vs = [ mkVariant x 1.0 p, mkVariant y () p ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; zipVR (hBuild (+1) id) `map` vs
--   [V{x=2.0},V{y=()}]
--   </pre>
zipVR :: (SameLabels fs v, SameLength fs v, ZipVR fs v v', ZipVRCxt fs v v') => Record fs -> Variant v -> Variant v'

-- | Lets <a>zipVR</a> act as if <tt><a>ZipVR</a> fs v v'</tt> had an FD
--   <tt>v v' -&gt; fs</tt>
--   
--   <pre>
--   ZipVRCxt [Tagged s f,  Tagged t g]
--            [Tagged s fx, Tagged t gx]
--            [Tagged s fy, Tagged t gy]
--     = (f ~ (fx -&gt; fy), g ~ (gx -&gt; gy))
--   </pre>

-- | implemented like <tt>and (zipWith (==) xs ys)</tt>. Behaves the same
--   as the Eq instances for <a>Variant</a>
eqVariant :: (HAllEqVal ((:) * (Tagged * () Bool) (HMapOutV_gety x Bool)) b, HAllEqVal (HMapOutV_gety x Bool) b, Unvariant1 Bool b (HMapOutV_gety x Bool) Bool, ZipVariant x1 y x, HMapAux Variant (HFmap UncurryEq) x (HMapOutV_gety x Bool), SameLength' * * (HMapOutV_gety x Bool) x, SameLength' * * x (HMapOutV_gety x Bool)) => Variant x1 -> Variant y -> Bool
data UncurryEq
UncurryEq :: UncurryEq

-- | <pre>
--   &gt;&gt;&gt; let t = minBound :: Variant '[Tagged "x" Bool, Tagged "y" Bool]
--   
--   &gt;&gt;&gt; [t .. maxBound]
--   [V{x=False},V{x=True},V{y=False},V{y=True}]
--   </pre>
--   
--   <ul>
--   <li><i><tt>Odd behavior</tt></i> There are some arguments that this
--   instance should not exist.</li>
--   </ul>
--   
--   The last type in the Variant does not need to be Bounded. This means
--   that <a>enumFrom</a> behaves a bit unexpectedly:
--   
--   <pre>
--   &gt;&gt;&gt; [False .. ]
--   [False,True]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [t .. ]
--   [V{x=False},V{x=True},V{y=False},V{y=True},V{y=*** Exception: Prelude.Enum.Bool.toEnum: bad argument
--   </pre>
--   
--   This is a "feature" because it allows an <tt>Enum (Variant '[Tagged
--   "a" Bool, Tagged "n" <a>Integer</a>])</tt>
--   
--   Another difficult choice is that the lower bound is <tt>fromEnum
--   0</tt> rather than <tt>minBound</tt>:
--   
--   <pre>
--   &gt;&gt;&gt; take 5 [ minBound :: Variant '[Tagged "b" Bool, Tagged "i" Int] .. ]
--   [V{b=False},V{b=True},V{i=0},V{i=1},V{i=2}]
--   </pre>

-- | While the instances could be written Enum (Variant '[]) Eq/Ord which
--   cannot produce values, so they have instances for empty variants
--   (<a>unsafeEmptyVariant</a>). Enum can produce values, so it is better
--   that <tt>fromEnum 0 :: Variant '[]</tt> fails with No instance for
--   <tt>Enum (Variant '[])</tt> than producing an invalid variant.

-- | XXX check this mappend is legal

-- | convert a variant with more fields into one with fewer (or the same)
--   fields.
--   
--   <pre>
--   &gt;&gt;&gt; let ty = Proxy :: Proxy [Tagged "left" Int, Tagged "right" Int]
--   
--   &gt;&gt;&gt; let l = mkVariant _left 1 ty
--   
--   &gt;&gt;&gt; let r = mkVariant _right 2 ty
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map projectVariant [l, r] :: [Maybe (Variant '[Tagged "left" Int])]
--   [Just V{left=1},Nothing]
--   </pre>
--   
--   <tt><a>rearrangeVariant</a> = <tt>fromJust</tt> .
--   <a>projectVariant</a></tt> is one implementation of
--   <a>rearrangeVariant</a>, since the result can have the same fields
--   with a different order:
--   
--   <pre>
--   &gt;&gt;&gt; let yt = Proxy :: Proxy [Tagged "right" Int, Tagged "left" Int]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map projectVariant [l, r] `asTypeOf` [Just (mkVariant _left 0 yt)]
--   [Just V{left=1},Just V{right=2}]
--   </pre>
class ProjectVariant x y
projectVariant :: ProjectVariant x y => Variant x -> Maybe (Variant y)

-- | <pre>
--   projectExtendVariant = fmap <a>extendVariant</a> . <a>projectVariant</a>
--   </pre>
--   
--   where intermediate variant is as large as possible. Used to implement
--   <a>Data.HList.Labelable</a>.<tt>projected</tt>
--   
--   Note that:
--   
--   <pre>
--   &gt;&gt;&gt; let r = projectExtendVariant (mkVariant1 Label 1 :: Variant '[Tagged "x" Int])
--   
--   &gt;&gt;&gt; r :: Maybe (Variant '[Tagged "x" Integer])
--   Nothing
--   </pre>
class HAllTaggedLV y => ProjectExtendVariant x y
projectExtendVariant :: ProjectExtendVariant x y => Variant x -> Maybe (Variant y)
class ProjectExtendVariant' (inY :: Maybe [*]) lv (y :: [*])
projectExtendVariant' :: ProjectExtendVariant' inY lv y => Proxy inY -> lv -> Maybe (Variant y)
class (ProjectVariant x yin, ProjectVariant x yout) => SplitVariant x yin yout
splitVariant :: SplitVariant x yin yout => Variant x -> Either (Variant yin) (Variant yout)

-- | <tt>projectVariant . extendsVariant = Just</tt> (when the types match
--   up)
--   
--   <a>extendVariant</a> is a special case
class (HAllTaggedLV y, HAllTaggedLV x) => ExtendsVariant x y
extendsVariant :: ExtendsVariant x y => Variant x -> Variant y

-- | <tt>rearrangeVariant</tt> is a specialization of <a>extendsVariant</a>
--   whose result is always . see also <a>rearranged</a>
rearrangeVariant :: (SameLength v v', ExtendsVariant v v') => Variant v -> Variant v'

-- | <pre>
--   Prism (Record tma) (Record tmb) (Variant ta) (Variant tb)
--   </pre>
--   
--   see <a>hMaybied'</a>
hMaybied :: (VariantToHMaybied v1 x, VariantToHMaybied v r, HFoldr HMaybiedToVariantFs [Variant ([] *)] x [Variant v1], HMapAux HList (HFmap HCastF) x r, SameLength' * * x r, SameLength' * * r x, Choice p, Applicative f) => p (Variant v1) (f (Variant v)) -> p (Record x) (f (Record r))
data HCastF
HCastF :: HCastF

-- | <pre>
--   Prism' (Record tma) (Variant ta)
--   </pre>
--   
--   where <tt>tma</tt> and <tt>tmb</tt> are lists like
--   
--   <pre>
--   tma ~ '[Tagged x (Maybe a), Tagged y (Maybe b)]
--   ta  ~ '[Tagged x        a , Tagged y        b ]
--   </pre>
--   
--   If one element of the record is Just, the Variant will contain that
--   element. Otherwise, the prism fails.
--   
--   <ul>
--   <li><i><tt>Note</tt></i></li>
--   </ul>
--   
--   The types work out to define a prism:
--   
--   <pre>
--   l = <a>prism'</a> <a>variantToHMaybied</a> (<tt>listToMaybe</tt> . <a>hMaybiedToVariants</a>)
--   </pre>
--   
--   but the law: <tt>s^?l  Just a ==&gt; l # a  s</tt> is not followed,
--   because we could have:
--   
--   <pre>
--   s, s2 :: Record '[Tagged "x" (Maybe Int), Tagged "y" (Maybe Char)]
--   s = hBuild (Just 1) (Just '2')
--   s2 = hBuild (Just 1) Nothing
--   
--   v :: Variant '[Tagged "x" Int, Tagged "y" Char]
--   v = mkVariant (Label :: Label "x") 1 Proxy
--   </pre>
--   
--   So that <tt>s^?l == Just v</tt>. But <tt>l#v == s2 /= s</tt>, while
--   the law requires <tt>l#v == s</tt>. hMaybied avoids this problem by
--   only producing a value when there is only one present.
hMaybied' :: (VariantToHMaybied v x, HFoldr HMaybiedToVariantFs [Variant ([] *)] x [Variant v], HMapAux HList (HFmap HCastF) x x, SameLength' * * x x, Choice p, Applicative f) => p (Variant v) (f (Variant v)) -> p (Record x) (f (Record x))
class VariantToHMaybied v r | v -> r, r -> v
variantToHMaybied :: VariantToHMaybied v r => Variant v -> Record r
data ConstTaggedNothing
ConstTaggedNothing :: ConstTaggedNothing

-- | Every element of the record that is Just becomes one element in the
--   resulting list. See <a>hMaybied'</a> example types that <tt>r</tt> and
--   <tt>v</tt> can take.
hMaybiedToVariants :: (HFoldr HMaybiedToVariantFs [Variant []] r [Variant v], VariantToHMaybied v r) => Record r -> [Variant v]
data HMaybiedToVariantFs
HMaybiedToVariantFs :: HMaybiedToVariantFs
instance (x ~ (Tagged t (Maybe e), [Variant v]), y ~ [Variant (Tagged t e : v)], MkVariant t e (Tagged t e : v)) => ApplyAB HMaybiedToVariantFs x y
instance y ~ Tagged t (Maybe e) => ApplyAB ConstTaggedNothing x y
instance (VariantToHMaybied v r, HReplicateF nr ConstTaggedNothing () r, tx ~ Tagged t x, tmx ~ Tagged t (Maybe x)) => VariantToHMaybied (tx : v) (tmx : r)
instance VariantToHMaybied '[] '[]
instance (mx ~ Maybe x, my ~ Maybe y, HCast y x) => ApplyAB HCastF mx my
instance (SameLength s a, ExtendsVariant s a, SameLength b t, ExtendsVariant b t) => Rearranged Variant s t a b
instance (HAllTaggedLV x, Unvariant '[le] e, MkVariant l e x, le ~ Tagged l e) => ExtendsVariant '[le] x
instance (MkVariant l e y, le ~ Tagged l e, ExtendsVariant (b : bs) y) => ExtendsVariant (le : b : bs) y
instance (ProjectVariant x yin, ProjectVariant x yout, H2ProjectByLabels (LabelsOf yin) x xi xo, HRearrange (LabelsOf yin) xi yin, HRearrange (LabelsOf yout) xo yout, HLeftUnion xi xo xixo, HRearrange (LabelsOf x) xixo x, HAllTaggedLV x, HAllTaggedLV yin, HAllTaggedLV yout) => SplitVariant x yin yout
instance (MkVariant l v y, lv ~ Tagged l v) => ProjectExtendVariant' ('Just t) lv y
instance ProjectExtendVariant' 'Nothing lv y
instance (lv ~ Tagged l v, HMemberM lv y inY, ProjectExtendVariant' inY lv y, ProjectExtendVariant xs y) => ProjectExtendVariant (lv : xs) y
instance HAllTaggedLV y => ProjectExtendVariant '[] y
instance ProjectVariant x '[]
instance (ProjectVariant x ys, HasField t (Variant x) (Maybe y), HOccursNot (Label t) (LabelsOf ys), ty ~ Tagged t y) => ProjectVariant x (ty : ys)
instance (Monoid x, Monoid (Variant (a : b))) => Monoid (Variant (Tagged t x : a : b))
instance (Unvariant '[Tagged t x] x, Monoid x) => Monoid (Variant '[Tagged t x])
instance Enum x => Enum (Variant '[Tagged s x])
instance (Enum x, Bounded x, Enum (Variant (y : z))) => Enum (Variant (Tagged s x : y : z))
instance (Bounded x, Bounded z, HRevAppR (Tagged s x : xs) '[] ~ (Tagged t z : sx), MkVariant t z (Tagged s x : xs)) => Bounded (Variant (Tagged s x : xs))
instance (Ord x, Ord (Variant xs)) => Ord (Variant (x : xs))
instance Ord (Variant '[])
instance (ee ~ (e, e), Eq e, bool ~ Bool) => ApplyAB UncurryEq ee bool
instance (Eq (Variant xs), Eq x) => Eq (Variant (x : xs))
instance Eq (Variant '[])
instance ZipVR fs '[] '[]
instance (lv ~ Tagged l v, lv' ~ Tagged l v', HMemberM (Label l) (LabelsOf fs) b, HasFieldM l (Record fs) f, DemoteMaybe (v -> v) f ~ (v -> v'), MkVariant l v' (lv' : rs), ZipVR fs vs rs) => ZipVR fs (lv : vs) (lv' : rs)
instance (Unvariant '[txy] txy, tx ~ Tagged t x, ty ~ Tagged t y, txy ~ Tagged t (x, y)) => HUnzip Variant '[tx] '[ty] '[txy]
instance (HUnzip Variant (x2 : xs) (y2 : ys) (xy2 : xys), tx ~ Tagged t x, ty ~ Tagged t y, txy ~ Tagged t (x, y)) => HUnzip Variant (tx : x2 : xs) (ty : y2 : ys) (txy : xy2 : xys)
instance (tx ~ Tagged t x, ty ~ Tagged t y, txy ~ Tagged t (x, y), ZipVariant xs ys zs, MkVariant t (x, y) (txy : zs)) => ZipVariant (tx : xs) (ty : ys) (txy : zs)
instance ZipVariant '[] '[] '[]
instance Fail "Unvariant applied to empty variant" => Unvariant1 b '[] (Proxy "Unvariant applied to empty variant")
instance Fail (UnvariantTypeMismatch (v : vs)) => Unvariant1 'False (v : vs) (UnvariantTypeMismatch (v : vs))
instance v ~ Tagged t1 e => Unvariant1 'True (v : vs) e
instance (Unvariant1 b v e, HAllEqVal v b, HAllEqVal (Tagged () e : v) b) => Unvariant v e
instance (HAllEqVal' (Tagged () e : v), Unvariant v e) => Unvariant' v e
instance (HAllEqVal' (ta : xs), a' ~ a, ta ~ Tagged t a, ta' ~ Tagged t' a') => HAllEqVal' (ta' : ta : xs)
instance HAllEqVal' '[x]
instance HAllEqVal' '[]
instance (HEq a a' b, HAllEqVal (Tagged t a' : xs) b2, HAnd b b2 ~ b3) => HAllEqVal (Tagged s a : Tagged t a' : xs) b3
instance HAllEqVal '[x] 'True
instance HAllEqVal '[] 'True
instance (le ~ Tagged l (Maybe e), HOccursNot (Label l) (LabelsOf v)) => HExtend le (Variant v)
instance (HUpdateVariantAtLabelCxt l e v v' n _e) => HUpdateAtLabel Variant l e v v'
instance (ApplyAB f te te', HMapCxt Variant f (l : ls) (l' : ls')) => HMapAux Variant f (te : l : ls) (te' : l' : ls')
instance ApplyAB f te te' => HMapAux Variant f '[te] '[te']
instance (vx ~ Variant x, vy ~ Variant y, HMapAux Variant (HFmap f) x y, SameLength x y) => ApplyAB (HMapV f) vx vy
instance (Unvariant '[a] v, a ~ Tagged l v, Data v, MkVariant l v b) => GfoldlVariant '[a] b
instance (a ~ Tagged l v, MkVariant l v r, Data v, GfoldlVariant (b : c) r) => GfoldlVariant (a : b : c) r
instance (MkVariant l e v, Data e, GunfoldVariant (b : bs) v) => GunfoldVariant (Tagged l e : b : bs) v
instance (MkVariant l e v, Data e) => GunfoldVariant '[Tagged l e] v
instance (ShowLabel l, VariantConstrs xs) => VariantConstrs (Tagged l e : xs)
instance VariantConstrs '[]
instance (Typeable (Variant v), GfoldlVariant v v, GunfoldVariant v v, VariantConstrs v) => Data (Variant v)
instance (ShowLabel l, Read v, ReadVariant vs, HOccursNot (Label l) (LabelsOf vs)) => ReadVariant (Tagged l v : vs)
instance ReadVariant '[]
instance ReadVariant v => Read (Variant v)
instance (ShowLabel l, Show v, lv ~ Tagged l v) => ShowVariant '[lv]
instance (ShowLabel l, Show v, ShowVariant (w : ws)) => ShowVariant (Tagged l v : w : ws)
instance ShowVariant vs => Show (Variant vs)
instance (MkVariant x b t, HasField x (Variant s) (Maybe a), SameLength s t, SameLabels s t, H2ProjectByLabels '[Label x] s si so, H2ProjectByLabels '[Label x] t ti to, so ~ to, HUpdateAtLabel Variant x b s t, HUpdateAtLabel Variant x a t s) => HPrism x s t a b
instance (HasField x (Record vs) a, HFindLabel x vs n, HNat2Integral n) => HasField x (Variant vs) (Maybe a)
instance (HFindLabel x vs n, HNat2Integral n, HasField x (Variant vs) (Maybe v)) => MkVariant x v vs
instance Relabeled Variant


-- | The HList library
--   
--   (C) 2004, Oleg Kiselyov, Ralf Laemmel, Keean Schupke
--   
--   Type-indexed co-products. The public interface is exposed in
--   <a>CommonMain#TIC</a>
--   
--   (There are other ways: see ConsUnion.hs, for example)
module Data.HList.TIC

-- | A datatype for type-indexed co-products. A <a>TIC</a> is just a
--   <a>Variant</a>, where the elements of the type-level list <tt>"l"</tt>
--   are in the form <tt>Tagged x x</tt>.
newtype TIC (l :: [*])
TIC :: (Variant l) -> TIC

-- | <pre>
--   Iso (TIC s) (TIC t) (Variant s) (Variant t)
--   </pre>
--   
--   <a>typeIndexed</a> may be more appropriate
ticVariant :: (Profunctor p, Functor f) => p (Variant t) (f (Variant l)) -> p (TIC t) (f (TIC l))

-- | <pre>
--   Iso' (TIC s) (Variant s)
--   </pre>
ticVariant' :: (Profunctor p, Functor f) => p (Variant t) (f (Variant t)) -> p (TIC t) (f (TIC t))

-- | Conversion between type indexed collections (<a>TIC</a> and
--   <a>TIP</a>) and the corresponding collection that has other label
--   types (<a>Variant</a> and <a>Record</a> respectively)
--   
--   See <a>typeIndexed'</a>
class TypeIndexed r tr | r -> tr, tr -> r
typeIndexed :: (TypeIndexed r tr, TypeIndexedCxt s t a b, Profunctor p, Functor f) => p (tr (TagR a)) (f (tr (TagR b))) -> p (r s) (f (r t))
type TypeIndexedCxt s t a b = (HMapCxt HList TaggedFn b t, RecordValues s, RecordValues t, a ~ RecordValuesR s, b ~ RecordValuesR t, SameLabels s t, SameLength s t, SameLength b a, Coercible (TagR b) t, Coercible (TagR a) s, HAllTaggedLV s, HRLabelSet t, TagUntag a, TagUntag b)

-- | <pre>
--   <tt>Iso'</tt> (<a>Variant</a> s) (<a>TIC</a> a)
--   </pre>
--   
--   <pre>
--   <tt>Iso'</tt> (<a>Record</a> s) (<a>TIP</a> a)
--   </pre>
--   
--   where <tt>s</tt> has a type like <tt>'[Tagged "x" Int]</tt>, and
--   <tt>a</tt> has a type like <tt>'[Tagged Int Int]</tt>.
typeIndexed' :: (TypeIndexed r tr, TagUntagFD (RecordValuesR s) (TagR (RecordValuesR s)), HLabelSet [*] (LabelsOf s), RecordValues s, HMapAux HList TaggedFn (RecordValuesR s) s, SameLength' * * (RecordValuesR s) (RecordValuesR s), SameLength' * * s s, SameLabels [*] [*] s s, HAllTaggedLV s, Profunctor p, Coercible [*] (TagR (RecordValuesR s)) s, Functor f) => p (tr (TagR (RecordValuesR s))) (f (tr (TagR (RecordValuesR s)))) -> p (r s) (f (r s))

-- | Public constructor (or, open union's injection function)
mkTIC' :: (HTypeIndexed l, MkVariant i i l) => i -> proxy l -> TIC l

-- | make a TIC that contains one element
mkTIC1 :: MkVariant i i '[Tagged i i] => i -> TIC '[Tagged i i]

-- | make a TIC for use in contexts where the result type is fixed
mkTIC :: (HAllTaggedEq l, HLabelSet [*] (LabelsOf l), HasField * i (Record l) i, HFind1 * i (UnLabel * i (LabelsOf l)) n, HNat2Integral n, HAllTaggedLV l) => i -> TIC l

-- | Public destructor (or, open union's projection function)

-- | similar to <a>HPrism</a>
class TICPrism s t a b | s a b -> t, t a b -> s
ticPrism :: (TICPrism s t a b, SameLength s t, Choice p, Applicative f) => (a `p` f b) -> (TIC s `p` f (TIC t))

-- | <pre>
--   Prism' (TIC s) a
--   </pre>
ticPrism' :: (HPrism a s t a b, a ~ b, s ~ t) => (forall f p. (Applicative f, Choice p) => (a `p` f b) -> (TIC s `p` f (TIC t)))

-- | TICs are not opaque

-- | <pre>
--   Nothing .*. x = x
--   Just a .*. y = mkTIC a
--   </pre>
instance Monoid (Variant l) => Monoid (TIC l)
instance Enum (Variant l) => Enum (TIC l)
instance Bounded (Variant l) => Bounded (TIC l)
instance Ix (Variant l) => Ix (TIC l)
instance Ord (Variant l) => Ord (TIC l)
instance Eq (Variant l) => Eq (TIC l)
instance (me ~ Maybe e, HOccursNot (Tagged e e) l) => HExtend me (TIC l)
instance (ReadVariant l, HAllTaggedEq l, HRLabelSet l) => Read (TIC l)
instance ShowVariant l => Show (TIC l)
instance (MkVariant b b t, HasField a (Variant s) (Maybe a), SameLength s t, HFindLabel b t n, HFindLabel a s n, HUpdateAtHNatR n (Tagged b b) s ~ t, HUpdateAtHNatR n (Tagged a a) t ~ s) => TICPrism s t a b
instance (HasField o (TIC l) mo, mo ~ Maybe o) => HOccurs mo (TIC l)
instance HasField o (Variant l) (Maybe o) => HasField o (TIC l) (Maybe o)
instance TypeIndexed Variant TIC
instance TypeIndexed Record TIP
instance HMapAux Variant f xs ys => HMapAux TIC f xs ys


-- | A simple problem is being solved here, but unfortunately it is a bit
--   involved. The idea is to use the same haskell identifier for a lens
--   and for other purposes. In other words, get the same behavior as:
--   
--   <pre>
--   x = hLens (Label :: Label "x")
--   r ^. x
--   </pre>
--   
--   While still being able to extract the symbol "x" from x, so that
--   things like <tt>x .=. 123</tt> could be acceptable. In this case we
--   don't overload <a>.=.</a>, so instead you have to write <tt>x .==.
--   123</tt>.
--   
--   Elaboration of some ideas from edwardk.
module Data.HList.Labelable

-- | <ul>
--   <li><i><tt>r</tt></i> is <a>Record</a>, <a>Variant</a>. <a>TIP</a> and
--   <a>TIC</a> also have instances, but generally <a>tipyLens'</a> and
--   <a>ticPrism'</a> are more appropriate.</li>
--   <li><i><tt>x</tt></i> is the label for the field. It tends to have
--   kind <a>Symbol</a>, but others are supported in principle.</li>
--   </ul>
class SameLength s t => Labelable (x :: k) (r :: [*] -> *) s t a b | x s -> a, x t -> b, x s b -> t, x t a -> s where type family LabelableTy r :: LabeledOpticType
hLens' :: Labelable x r s t a b => Label x -> LabeledOptic x r s t a b

-- | This alias is the same as Control.Lens.Optic, except the (-&gt;) in
--   Optic is a type parameter <tt>to</tt> in LabeledOptic.
--   
--   Depending on the collection type (see instances of
--   <a>LabelableTy</a>), the type variables <tt>to, p, f</tt> are
--   constrained such that the resulting type is a <tt>Lens (r s) (r t) a
--   b</tt>, <tt>Prism (r s) (r t) a b</tt> or a <tt>LabeledTo x _ _</tt>.
--   The latter can be used to recover the label (<tt>x</tt>) when used as
--   an argument to <a>.==.</a> or equivalently <a>toLabel</a>.
type LabeledOptic (x :: k) (r :: [*] -> *) (s :: [*]) (t :: [*]) (a :: *) (b :: *) = forall ty to p f. (ty ~ LabelableTy r, LabeledOpticF ty f, LabeledOpticP ty p, LabeledOpticTo ty x to) => (a `p` f b) `to` (r s `p` f (r t))

-- | modification of <a>.=.</a> which works with the labels from this
--   module, and those from <a>Data.HList.Label6</a>. Note that this is not
--   strictly a generalization of <a>.=.</a>, since it does not work with
--   labels like <a>Data.HList.Label3</a> which have the wrong kind.
(.==.) :: ToSym label l => label -> v -> Tagged Symbol l v

-- | Sometimes it may be more convenient to operate on a record/variant
--   that only contains the fields of interest. <a>projected</a> can then
--   be used to apply that function to a record that contains additional
--   elements.
--   
--   <pre>
--   &gt;&gt;&gt; :set -XViewPatterns
--   
--   &gt;&gt;&gt; import Data.HList.RecordPuns
--   
--   &gt;&gt;&gt; let f [pun| (x y) |] = case x+y of z -&gt; [pun| z |]
--   
--   &gt;&gt;&gt; :t f
--   f :: Num v =&gt;
--        Record '[Tagged "x" v, Tagged "y" v] -&gt; Record '[Tagged "z" v]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let r = (let x = 1; y = 2; z = () in [pun| x y z |])
--   
--   &gt;&gt;&gt; r
--   Record{x=1,y=2,z=()}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; r &amp; sameLabels . projected %~ f
--   Record{x=1,y=2,z=3}
--   </pre>
class Projected r s t a b
projected :: (Projected r s t a b, ty ~ LabelableTy r, LabeledOpticP ty p, LabeledOpticF ty f) => r a `p` f (r b) -> r s `p` f (r t)

-- | <pre>
--   Lens' (Record s) (Record a)
--   </pre>
--   
--   <pre>
--   Prism' (Variant s) (Variant a)
--   </pre>
projected' :: (LabeledOpticP (LabelableTy r) p, LabeledOpticF (LabelableTy r) f, Projected r s s b b) => p (r b) (f (r b)) -> p (r s) (f (r s))

-- | sets all type variables to dummy values: only the <tt>Labeled x</tt>
--   part is actually needed
type LabeledCxt1 s t a b = (s ~ [], t ~ [], a ~ (), b ~ ())
data LabeledTo (x :: k) (a :: *) (b :: *)
LabeledTo :: LabeledTo
data LabeledR (x :: [*])
LabeledR :: LabeledR

-- | Create a <tt><a>Label</a> (x :: <a>Symbol</a>)</tt>:
--   
--   <pre>
--   toLabel :: LabeledTo x _ _ -&gt; Label x
--   toLabel :: Label x         -&gt; Label x
--   toLabel :: Proxy x         -&gt; Label x
--   </pre>
class ToSym label (s :: Symbol) | label -> s
toLabel :: ToSym label s => label -> Label s

-- | Identity functor and monad.
data Identity a :: * -> *
type LabelableTIPCxt x s t a b = (s ~ t, a ~ b, x ~ a, HLens x TIP s t a b)
data LabeledOpticType
LabelableLens :: LabeledOpticType
LabelablePrism :: LabeledOpticType
LabelableLabel :: LabeledOpticType
instance Show (LabeledTo x a b)
instance (to ~ LabeledTo x, ToSym (to p q) x) => HExtend (to p q) (Proxy (Lbl n ns desc : xs))
instance (to ~ LabeledTo x, ToSym (to p q) x) => HExtend (to p q) (Proxy (x : xs))
instance (to ~ LabeledTo x, ToSym (to p q) x) => HExtend (to p q) (Proxy '[])
instance (ExtendsVariant b t, ProjectVariant s a, ProjectExtendVariant s t, HLeftUnion b s bs, HRLabelSet bs, HRearrange (LabelsOf t) bs t) => Projected Variant s t a b
instance (H2ProjectByLabels (LabelsOf a) s a_ _s_minus_a, HRLabelSet a_, HRLabelSet a, HRearrange (LabelsOf a) a_ a, HLeftUnion b s bs, HRLabelSet bs, HRearrange (LabelsOf t) bs t, HRLabelSet t) => Projected Record s t a b
instance ToSym (label x) x
instance LabeledTo x (p a (f b)) (p (LabeledR s) (f (LabeledR t))) ~ v1 v2 v3 => ToSym (v1 v2 v3) x
instance (LabelableTIPCxt x s t a b) => Labelable x TIP s t a b
instance (TICPrism s t a b, x ~ a, a ~ b, s ~ t, SameLength s t) => Labelable x TIC s t a b
instance (HPrism x s t a b, to ~ (->)) => Labelable x Variant s t a b
instance (LabeledCxt1 s t a b) => Labelable x LabeledR s t a b
instance HLens x Record s t a b => Labelable x Record s t a b


module Data.HList.MakeLabels

-- | Labels like <a>Data.HList.Label5</a>.
--   
--   The following TH declaration splice should be placed at top-level,
--   before the created values are used. Enable <tt>-XTemplateHaskell</tt>
--   too.
--   
--   <pre>
--   makeLabels ["getX","getY","draw","X"]
--   </pre>
--   
--   should expand into the following declarations
--   
--   <pre>
--   data LabelGetX deriving Typeable
--   data LabelGetY deriving Typeable
--   data LabelDraw deriving Typeable
--   data LabelX deriving Typeable
--   </pre>
--   
--   <pre>
--   getX = Label :: Label LabelGetX
--   getY = Label :: Label LabelGetY
--   draw = Label :: Label LabelDraw
--   x    = Label :: Label LabelX
--   </pre>
makeLabels :: [String] -> Q [Dec]

-- | for <a>Data.HList.Label3</a>
makeLabels3 :: String -> [String] -> Q [Dec]

-- | for <a>Data.HList.Label6</a>
--   
--   <pre>
--   makeLabels6 ["x","y"]
--   </pre>
--   
--   is a shortcut for
--   
--   <pre>
--   x = Label :: Label "x"
--   y = Label :: Label "y"
--   </pre>
makeLabels6 :: [String] -> Q [Dec]

-- | <tt>makeLabelable "x y z"</tt> expands out to
--   
--   <pre>
--   x = hLens' (Label :: Label "x")
--   y = hLens' (Label :: Label "y")
--   z = hLens' (Label :: Label "z")
--   </pre>
--   
--   Refer to <a>Data.HList.Labelable</a> for usage.
makeLabelable :: String -> Q [Dec]


-- | <a>Data</a> instances for <a>HListFlat</a> and <a>Record</a> which
--   pretend to be flat data structures. The <tt>Data</tt> instance for
--   <a>HList</a> gives a nested structure.
--   
--   NOTE: these instances do not work with ghc-7.8 with promoted string
--   (Symbol) labels because of
--   <a>https://ghc.haskell.org/trac/ghc/ticket/9111</a>
--   
--   <ul>
--   <li><i><tt>HList</tt></i></li>
--   </ul>
--   
--   The data instance for
--   
--   <pre>
--   a :: HList '[Int, Double, b]
--   </pre>
--   
--   Looks like the same instance for
--   
--   <pre>
--   type T b = (Int, (Double, (b, ())))
--   </pre>
--   
--   <ul>
--   <li><i><tt>HListFlat</tt></i></li>
--   </ul>
--   
--   The Data instance for
--   
--   <pre>
--   a :: Data b =&gt; HListFlat '[Int,Double,b]
--   </pre>
--   
--   will look like the Data instance for:
--   
--   <pre>
--   data A b = A Int Double b
--   </pre>
--   
--   <ul>
--   <li><i><tt>Record</tt></i></li>
--   </ul>
--   
--   For <a>Record</a> similar ideas apply. An
--   
--   <pre>
--   a :: Record '[ LVPair "x" Int, LVPair "y" Double ]
--   </pre>
--   
--   should behave like a:
--   
--   <pre>
--   data A = A { x :: Int, y :: Double } deriving (Data)
--   </pre>
--   
--   Many unsafecoerces are necessary here because the Data class includes
--   type parameters <tt>c</tt> that cannot be used in the class context
--   for the instance. Perhaps there is another way.
module Data.HList.Data
type DataHListFlatCxt na g a = (HBuild' [] g, Typeable (HListFlat a), TypeablePolyK a, HFoldl (GfoldlK C) (C g) a (C (HList a)), HFoldr (GunfoldK C) (C g) (HReplicateR na ()) (C (HList a)), HLengthEq a na, HReplicate na ())
type DataRecordCxt a = (Data (HListFlat (RecordValuesR a)), TypeablePolyK a, TypeRepsList (Record a), RecordValues a, RecordLabelsStr a)
class TypeRepsList a
typeRepsList :: TypeRepsList a => a -> [TypeRep]
class RecordLabelsStr (xs :: [*])
recordLabelsStr :: RecordLabelsStr xs => Record xs -> [String]

-- | wraps up the first argument to <a>gfoldl</a>
data GfoldlK c
GfoldlK :: (forall d b. Data d => c (d -> b) -> d -> c b) -> GfoldlK c
data GunfoldK c
GunfoldK :: (forall b r. Data b => c (b -> r) -> c r) -> GunfoldK c

-- | this data type only exists to have Data instance
newtype HListFlat a
HListFlat :: (HList a) -> HListFlat a
type TypeablePolyK (a :: k) = Typeable a
instance Typeable (':)
instance Typeable '[]
instance Typeable 'HSucc
instance Typeable 'HZero
instance Typeable TIP
instance Typeable TIC
instance Typeable Variant
instance Typeable HListFlat
instance Typeable HList
instance Typeable Record
instance (TypeablePolyK xs, Typeable (Variant xs), Data (Variant xs)) => Data (TIC xs)
instance (TypeablePolyK xs, Typeable (HList xs), Data (HList xs)) => Data (TIP xs)
instance (Data x, Data (HList xs), TypeablePolyK (x : xs), Typeable (HList (x : xs))) => Data (HList (x : xs))
instance Typeable (HList '[]) => Data (HList '[])
instance (Data b, x ~ (t, c (b -> r)), y ~ c r) => ApplyAB (GunfoldK c) x y
instance (Data d, (c (d -> b), d) ~ x, c b ~ y) => ApplyAB (GfoldlK c) x y
instance TypeRepsList (HList '[])
instance (TypeRepsList (HList xs), Typeable x) => TypeRepsList (HList (x : xs))
instance TypeRepsList (HList xs) => TypeRepsList (Record xs)
instance (RecordLabelsStr2 xs, ShowLabel x) => RecordLabelsStr2 (x : xs)
instance RecordLabelsStr2 '[]
instance (RecordLabelsStr xs, ShowLabel x) => RecordLabelsStr (Tagged x t : xs)
instance RecordLabelsStr '[]
instance (DataRecordCxt a) => Data (Record a)
instance (DataHListFlatCxt na g a) => Data (HListFlat a)


-- | The public interface is exposed in <a>CommonMain#Kw</a>
module Data.HList.Keyword

-- | <tt>kw</tt> takes a <a>HList</a> whose first element is a function,
--   and the rest of the elements are default values. A useful trick is to
--   have a final argument <tt>()</tt> which is not eaten up by a label (A
--   only takes 1 argument). That way when you supply the () it knows there
--   are no more arguments (?).
--   
--   <pre>
--   &gt;&gt;&gt; data A = A
--   
--   &gt;&gt;&gt; instance IsKeyFN (A -&gt; a -&gt; b) True
--   
--   &gt;&gt;&gt; let f A a () = a + 1
--   
--   &gt;&gt;&gt; let f' = f .*. A .*. 1 .*. HNil
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; kw f' A 0 ()
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; kw f' ()
--   2
--   </pre>
class Kw (fn :: *) (arg_def :: [*]) r
kw :: Kw fn arg_def r => HList (fn : arg_def) -> r

-- | All our keywords must be registered
class IsKeyFN (t :: *) (flag :: Bool) | t -> flag

-- | convert a <a>Record</a> into a list that can supply default arguments
--   for <a>kw</a>
--   
--   A bit of setup:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XQuasiQuotes
--   
--   &gt;&gt;&gt; import Data.HList.RecordPuns
--   
--   &gt;&gt;&gt; let f (_ :: Label "a") a (_ :: Label "b") b () = a `div` b
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let a = 2; b = 1; f' = f .*. recToKW [pun| a b |]
--   
--   &gt;&gt;&gt; kw f' ()
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; kw f' (Label :: Label "a") 10 ()
--   10
--   </pre>
recToKW :: (HMapCxt HList TaggedToKW a b, HConcat b) => Record a -> HList (HConcatR b)
data K s (c :: *)
K :: K s
data ErrReqdArgNotFound x
data ErrUnexpectedKW x
class KWApply f arg_values r
kwapply :: KWApply f arg_values r => f -> HList arg_values -> r
class KWApply' flag f arg_values r
kwapply' :: KWApply' flag f arg_values r => Proxy flag -> f -> HList arg_values -> r

-- | The datatype Arg below is to maintain the state of keyword
--   accumulation: which keywords we need, and which keyword and values we
--   have already got. arg_types is the phantom HList of keywords that are
--   yet to be satisfied. arg_values is the <tt>HList (kw .*. kw_value .*.
--   etc)</tt> of already found keywords and their values.
newtype Arg arg_types arg_values
Arg :: (HList arg_values) -> Arg arg_types arg_values

-- | that reflects on a user-supplied function. It converts the *type* of a
--   user function to a collection of keywords required by that function.
--   This and the previous contraptions may be used to define an
--   <tt>extended</tt> version of some user function that takes more
--   arguments -- without the need to enumerate all arguments of the
--   original function. We thus infringe on the area of object and module
--   systems.
--   
--   The rest of the implementation is just to convert `kw fn defaults'
--   into the application of kwapply.
--   
--   Another key contraption is
reflect_fk :: ReflectFK fn kws => fn -> Arg kws []

-- | Reflection on a function: Given a function, return the type list of
--   its keywords
--   
--   <pre>
--   &gt;&gt;&gt; :t reflect_fk (undefined::Size-&gt;Int-&gt;Color-&gt;CommonColor-&gt;String)
--   reflect_fk (undefined::Size-&gt;Int-&gt;Color-&gt;CommonColor-&gt;String)
--     :: Arg '[Size, Color] '[]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; :t reflect_fk (undefined::Size-&gt;Int-&gt;()-&gt;Int)
--   reflect_fk (undefined::Size-&gt;Int-&gt;()-&gt;Int) :: Arg '[Size] '[]
--   </pre>
class ReflectFK f (kws :: [*])
class ReflectFK' (flag :: Bool) f kws

-- | The main class: collect and apply the keyword arguments
class KW f arg_desc arg_def r
kwdo :: KW f arg_desc arg_def r => f -> arg_desc -> HList arg_def -> r
class KW' rflag f arg_desc arg_def r
kw' :: KW' rflag f arg_desc arg_def r => Proxy rflag -> f -> arg_desc -> HList arg_def -> r

-- | Add the real argument to the Arg structure, and continue
class KWAcc arg_desc kw a f arg_def r
kwaccum :: KWAcc arg_desc kw a f arg_def r => arg_desc -> kw -> a -> f -> HList arg_def -> r

-- | Add the needed arguments from arg_def to arg_values and continue with
--   kwapply.
--   
--   That is, we try to satisfy the missing arguments from the defaults. It
--   will be a type error if some required arguments are missing
class KWMerge arg_needed arg_values arg_def f r
kwmerge :: KWMerge arg_needed arg_values arg_def f r => Arg arg_needed arg_values -> HList arg_def -> f -> r
class KWMerge' kw list atail arg_values arg_def f r
kwmerge' :: KWMerge' kw list atail arg_values arg_def f r => kw -> HList list -> (Arg atail arg_values) -> HList arg_def -> f -> r
class KWMerge'' (flag :: Bool) kw (list :: [*]) atail arg_values arg_def f r
kwmerge'' :: KWMerge'' flag kw list atail arg_values arg_def f r => Proxy flag -> kw -> HList list -> Arg atail arg_values -> HList arg_def -> f -> r

-- | Delete e from l to yield l' The element e must occur in l
class HDelete e (l :: [k]) (l' :: [k])
class HDelete' (flag :: Bool) e l l'
data TaggedToKW
instance Show (HList vals) => Show (Arg tys vals)
instance (x ~ Tagged l v, y ~ HList '[Label l, v]) => ApplyAB TaggedToKW x y
instance (KW' rflag fn akws arg_def r, akws ~ Arg kws '[], ReflectFK' flag fn kws, IsKeyFN r rflag, IsKeyFN fn flag) => Kw fn arg_def r
instance (HDelete e tail tail', e'tail ~ (e' : tail')) => HDelete' 'False e (e' : tail) e'tail
instance tail' ~ tail => HDelete' 'True e (e : tail) tail'
instance (HEq e e' flag, HDelete' flag e (e' : tail) l') => HDelete e (e' : tail) l'
instance (Fail (ErrUnexpectedKW e), r ~ '[]) => HDelete e '[] r
instance (HDelete kw arg_types arg_types', KW f (Arg arg_types' (kw : a : arg_values)) arg_def r) => KWAcc (Arg arg_types arg_values) kw a f arg_def r
instance KWMerge' kw tail atail arg_values arg_def f r => KWMerge'' 'False kw (kw' : v' : tail) atail arg_values arg_def f r
instance KWMerge atail (kw : v : arg_values) arg_def f r => KWMerge'' 'True kw (kw : v : tail) atail arg_values arg_def f r
instance (HEq kw kw' flag, KWMerge'' flag kw (kw' : etc) atail arg_values arg_def f r) => KWMerge' kw (kw' : etc) atail arg_values arg_def f r
instance (Fail (ErrReqdArgNotFound kw), nff ~ ErrReqdArgNotFound kw) => KWMerge' kw '[] atail arg_values arg_def f nff
instance KWMerge' kw arg_def atail arg_values arg_def f r => KWMerge (kw : atail) arg_values arg_def f r
instance KWApply f arg_values r => KWMerge '[] arg_values arg_def f r
instance (KWAcc arg_desc kw a f arg_def r, (kw -> a -> r) ~ kwar) => KW' 'True f arg_desc arg_def kwar
instance KWMerge arg_needed arg_values arg_def f r => KW' 'False f (Arg arg_needed arg_values) arg_def r
instance (IsKeyFN r rflag, KW' rflag f arg_desc arg_def r) => KW f arg_desc arg_def r
instance '[] ~ nil => ReflectFK' 'False f nil
instance (kkws ~ (kw : kws), ReflectFK rest kws) => ReflectFK' 'True (kw -> a -> rest) kkws
instance (IsKeyFN f flag, ReflectFK' flag f kws) => ReflectFK f kws
instance (HAppendListR tail '[kw, v] ~ l', HAppendList tail '[kw, v], KWApply f l' r) => KWApply' 'False f (kw : v : tail) r
instance (v' ~ v, KWApply f' tail r) => KWApply' 'True (kw -> v -> f') (kw : v' : tail) r
instance (HEq kw kw' flag, KWApply' flag (kw -> a -> f') (kw' : a' : tail) r) => KWApply (kw -> a -> f') (kw' : a' : tail) r
instance r ~ r' => KWApply r '[] r'
instance r ~ (c -> b) => IsKeyFN (K s c -> r) 'True
instance IsKeyFN (Label s -> a -> b) 'True


-- | The HList library
--   
--   This module re-exports everything needed to use HList.
module Data.HList.CommonMain
hSort :: HSort x y => HList x -> HList y
type HSort x y = HSortBy HLeFn x y

-- | quick sort with a special case for sorted lists
class (SameLength a b, HEqByFn le) => HSortBy le (a :: [*]) (b :: [*]) | le a -> b
hSortBy :: HSortBy le a b => Proxy le -> HList a -> HList b

-- | the "standard" <a>&lt;=</a> for types. Reuses <a>HEqBy</a>
--   
--   Note that ghc-7.6 is missing instances for Symbol and Nat, so that
--   sorting only works <a>HNat</a> (as used by <a>Data.HList.Label3</a>).
data HLeFn

-- | analogous to <a>Down</a>
data HDown a
class HSetBy (HNeq HLeFn) ps => HSet (ps :: [*])

-- | Provided the labels involved have an appropriate instance of HEqByFn,
--   it would be possible to use the following definitions:
--   
--   <pre>
--   type HRLabelSet = HSet
--   type HLabelSet  = HSet
--   </pre>
class HEqByFn lt => HSetBy lt (ps :: [*])

-- | <pre>
--   &gt;&gt;&gt; let xx = Proxy :: HIsSet [Label "x", Label "x"] b =&gt; Proxy b
--   
--   &gt;&gt;&gt; :t xx
--   xx :: Proxy 'False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let xy = Proxy :: HIsSet [Label "x", Label "y"] b =&gt; Proxy b
--   
--   &gt;&gt;&gt; :t xy
--   xy :: Proxy 'True
--   </pre>
class HIsSet (ps :: [*]) (b :: Bool) | ps -> b
class HEqByFn lt => HIsSetBy lt (ps :: [*]) (b :: Bool) | lt ps -> b

-- | <tt>HAscList le xs</tt> confirms that xs is in ascending order, and
--   reports which element is duplicated otherwise.
class HEqByFn le => HAscList le (ps :: [*])

-- | <tt>HIsAscList le xs b</tt> is analogous to
--   
--   <pre>
--   b = all (\(x,y) -&gt; x `le` y) (xs `zip` tail xs)
--   </pre>
class HEqByFn le => HIsAscList le (xs :: [*]) (b :: Bool) | le xs -> b

-- | 'curry'/'uncurry' for many arguments and HLists instead of tuples
--   
--   XXX the last FD <tt>xs -&gt; n</tt> is needed to make hCompose infer
--   the right types: arguably it shouldn't be needed
class HLengthEq xs n => HCurry' (n :: HNat) f xs r | f xs -> r, r xs -> f, n f -> xs, xs -> n
hUncurry' :: HCurry' n f xs r => Proxy n -> f -> HList xs -> r
hCurry' :: HCurry' n f xs r => Proxy n -> (HList xs -> r) -> f

-- | Note: with ghc-7.10 the Arity constraint added here does not work
--   properly with hCompose, so it is possible that other uses of
--   <a>hCurry</a> are better served by <tt>hCurry' Proxy</tt>.
hCurry :: (HCurry' n f xs r, ArityFwd f n, ArityRev f n) => (HList xs -> r) -> f
hUncurry :: (HCurry' n f xs r, ArityFwd f n, ArityRev f n) => f -> HList xs -> r

-- | compose two functions that take multiple arguments. The result of the
--   second function is the first argument to the first function. An
--   example is probably clearer:
--   
--   <pre>
--   &gt;&gt;&gt; let f = hCompose (,,) (,)
--   
--   &gt;&gt;&gt; :t f
--   f :: ... -&gt; ... -&gt; ... -&gt; ... -&gt; ((..., ...), ..., ...)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; f 1 2 3 4
--   ((1,2),3,4)
--   </pre>
--   
--   Note: polymorphism can make it confusing as to how many parameters a
--   function actually takes. For example, the first two ids are <tt>id ::
--   (a -&gt; b) -&gt; (a -&gt; b)</tt> in
--   
--   <pre>
--   &gt;&gt;&gt; (.) id id id 'y'
--   'y'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hCompose id id id 'y'
--   'y'
--   </pre>
--   
--   still typechecks, but in that case <tt>hCompose i1 i2 i3 x == i1 ((i2
--   i3) x)</tt> has id with different types than @(.) i1 i2 i3 x == (i1
--   (i2 i3)) x
--   
--   Prompted by
--   <a>http://stackoverflow.com/questions/28932054/can-hlistelim-be-composed-with-another-function</a>
hCompose :: (HCurry' n2 f2 xs1 r, HCurry' n1 f1 xs x, HCurry' n f xsys r, HSplitAt1 ([] *) n1 xsys xs xs1, HAppendList1 * xs xs1 xsys, ArityFwd f2 n2, ArityFwd f1 n1, ArityRev f2 n2, ArityRev f1 n1) => (x -> f2) -> f1 -> f

-- | TIPs are like <a>Record</a>, except element "i" of the list "l" has
--   type <tt>Tagged e_i e_i</tt>
data TIP (l :: [*])
emptyTIP :: TIP []
tipyUpdate :: (HUpdateAtLabel * record v v r r, SameLength' * * r r) => v -> record r -> record r

-- | provides a <tt>Lens (TIP s) (TIP t) a b</tt>
--   
--   When using <tt>set</tt> (also known as <tt>.~</tt>), <a>tipyLens'</a>
--   can address the ambiguity as to which field "a" should actually be
--   updated.
tipyLens :: (HAllTaggedEq t, HAllTaggedEq s, HLabelSet [*] (LabelsOf t), HLabelSet [*] (LabelsOf s), HasField * b (Record t) b, HasField * b (Record s) b, HUpdateAtLabel2 * b b t s, HUpdateAtLabel2 * b b s t, SameLength' * * t s, SameLength' * * s t, SameLabels [*] [*] s t, HAllTaggedLV t, HAllTaggedLV s, Functor f) => (b -> f b) -> TIP s -> f (TIP t)

-- | provides a <tt>Lens' (TIP s) a</tt>. <tt>hLens'</tt> <tt>:: Label a
--   -&gt; Lens' (TIP s) a</tt> is another option.
tipyLens' :: (HAllTaggedEq t, HLabelSet [*] (LabelsOf t), HasField * b (Record t) b, HUpdateAtLabel2 * b b t t, SameLength' * * t t, SameLabels [*] [*] t t, HAllTaggedLV t, Functor f) => (b -> f b) -> TIP t -> f (TIP t)

-- | Use <a>Labels</a> to specify the first argument
tipyProject :: (HAllTaggedEq l, HLabelSet [*] (LabelsOf l), H2ProjectByLabels ls r l b, HAllTaggedLV l) => proxy ls -> TIP r -> TIP l

-- | The same as <a>tipyProject</a>, except also return the types not
--   requested in the <tt>proxy</tt> argument
tipyProject2 :: (HAllTaggedEq l1, HAllTaggedEq l, HLabelSet [*] (LabelsOf l), HLabelSet [*] (LabelsOf l1), H2ProjectByLabels ls r l l1, HAllTaggedLV l1, HAllTaggedLV l) => proxy ls -> TIP r -> (TIP l, TIP l1)

-- | project a TIP (or HList) into a tuple
--   
--   <pre>
--   tipyTuple' x = (<tt>hOccurs</tt> x, hOccurs x)
--   </pre>
--   
--   behaves similarly, except <tt>tipyTuple</tt> excludes the possibility
--   of looking up the same element twice, which allows inferring a
--   concrete type in more situations. For example
--   
--   <pre>
--   (\x y z -&gt; tipyTuple (x .*. y .*. emptyTIP) `asTypeOf` (x, z)) () 'x'
--   </pre>
--   
--   has type <tt>Char -&gt; ((), Char)</tt>. tipyTuple' would need a type
--   annotation to decide whether the type should be <tt>Char -&gt; ((),
--   Char)</tt> or <tt>() -&gt; ((), ())</tt>
tipyTuple :: (HOccurs l1 (r v1), HOccurs l1 (r v), HOccurs l (r v2), HOccurs l (r v), HDeleteAtLabel * r l1 v1 v', HDeleteAtLabel * r l1 v v2, HDeleteAtLabel * r l v2 v'1, HDeleteAtLabel * r l v v1) => r v -> (l, l1)
tipyTuple3 :: (HOccurs l2 (r v5), HOccurs l2 (r v2), HOccurs l2 (r v), HOccurs l1 (r v4), HOccurs l1 (r v1), HOccurs l1 (r v), HOccurs l (r v6), HOccurs l (r v3), HOccurs l (r v), HDeleteAtLabel * r l2 v5 v6, HDeleteAtLabel * r l2 v2 v', HDeleteAtLabel * r l2 v v3, HDeleteAtLabel * r l1 v4 v'1, HDeleteAtLabel * r l1 v1 v2, HDeleteAtLabel * r l1 v v5, HDeleteAtLabel * r l v6 v'2, HDeleteAtLabel * r l v3 v4, HDeleteAtLabel * r l v v1) => r v -> (l, l1, l2)
tipyTuple4 :: (HOccurs l3 (r v11), HOccurs l3 (r v7), HOccurs l3 (r v3), HOccurs l3 (r v), HOccurs l2 (r v10), HOccurs l2 (r v6), HOccurs l2 (r v2), HOccurs l2 (r v), HOccurs l1 (r v9), HOccurs l1 (r v5), HOccurs l1 (r v1), HOccurs l1 (r v), HOccurs l (r v12), HOccurs l (r v8), HOccurs l (r v4), HOccurs l (r v), HDeleteAtLabel * r l3 v11 v12, HDeleteAtLabel * r l3 v7 v8, HDeleteAtLabel * r l3 v3 v', HDeleteAtLabel * r l3 v v4, HDeleteAtLabel * r l2 v10 v11, HDeleteAtLabel * r l2 v6 v'1, HDeleteAtLabel * r l2 v2 v3, HDeleteAtLabel * r l2 v v7, HDeleteAtLabel * r l1 v9 v'2, HDeleteAtLabel * r l1 v5 v6, HDeleteAtLabel * r l1 v1 v2, HDeleteAtLabel * r l1 v v10, HDeleteAtLabel * r l v12 v'3, HDeleteAtLabel * r l v8 v9, HDeleteAtLabel * r l v4 v5, HDeleteAtLabel * r l v v1) => r v -> (l, l1, l2, l3)
tipyTuple5 :: (HOccurs l4 (r v19), HOccurs l4 (r v14), HOccurs l4 (r v9), HOccurs l4 (r v4), HOccurs l4 (r v), HOccurs l3 (r v18), HOccurs l3 (r v13), HOccurs l3 (r v8), HOccurs l3 (r v3), HOccurs l3 (r v), HOccurs l2 (r v17), HOccurs l2 (r v12), HOccurs l2 (r v7), HOccurs l2 (r v2), HOccurs l2 (r v), HOccurs l1 (r v16), HOccurs l1 (r v11), HOccurs l1 (r v6), HOccurs l1 (r v1), HOccurs l1 (r v), HOccurs l (r v20), HOccurs l (r v15), HOccurs l (r v10), HOccurs l (r v5), HOccurs l (r v), HDeleteAtLabel * r l4 v19 v20, HDeleteAtLabel * r l4 v14 v15, HDeleteAtLabel * r l4 v9 v10, HDeleteAtLabel * r l4 v4 v', HDeleteAtLabel * r l4 v v5, HDeleteAtLabel * r l3 v18 v19, HDeleteAtLabel * r l3 v13 v14, HDeleteAtLabel * r l3 v8 v'1, HDeleteAtLabel * r l3 v3 v4, HDeleteAtLabel * r l3 v v9, HDeleteAtLabel * r l2 v17 v18, HDeleteAtLabel * r l2 v12 v'2, HDeleteAtLabel * r l2 v7 v8, HDeleteAtLabel * r l2 v2 v3, HDeleteAtLabel * r l2 v v13, HDeleteAtLabel * r l1 v16 v'3, HDeleteAtLabel * r l1 v11 v12, HDeleteAtLabel * r l1 v6 v7, HDeleteAtLabel * r l1 v1 v2, HDeleteAtLabel * r l1 v v17, HDeleteAtLabel * r l v20 v'4, HDeleteAtLabel * r l v15 v16, HDeleteAtLabel * r l v10 v11, HDeleteAtLabel * r l v5 v6, HDeleteAtLabel * r l v v1) => r v -> (l, l1, l2, l3, l4)
type TagUntag xs = TagUntagFD xs (TagR xs)

-- | <a>TagR</a> can also be used to avoid redundancy when defining types
--   for TIC and TIP.
--   
--   <pre>
--   type XShort = TagR [A,B,C,D]
--   </pre>
--   
--   <pre>
--   type XLong = [Tagged A A, Tagged B B, Tagged C C, Tagged D D]
--   </pre>
--   
--   an equivalent FD version, which is slightly better with respect to
--   simplifying types containing type variables (in ghc-7.8 and 7.6):
--   <a>http://stackoverflow.com/questions/24110410/</a>
--   
--   With ghc-7.10 (http:/<i>ghc.haskell.org</i>trac<i>ghc</i>ticket/10009)
--   the FD version is superior to the TF version:
--   
--   <pre>
--   class (UntagR (TagR a) ~ a) =&gt; TagUntag a where
--       type TagR a :: [*]
--       hTagSelf :: HList a -&gt; HList (TagR a)
--       hUntagSelf :: HList (TagR a) -&gt; HList a
--   
--   instance TagUntag '[] where
--       type TagR '[] = '[]
--       hTagSelf _ = HNil
--       hUntagSelf _ = HNil
--   
--   instance TagUntag xs =&gt; TagUntag (x ': xs) where
--       type TagR (x ': xs) = Tagged x x ': TagR xs
--       hTagSelf (HCons x xs) = Tagged x <a>HCons</a> hTagSelf xs
--       hUntagSelf (HCons (Tagged x) xs) = x <a>HCons</a> hUntagSelf xs
--   
--   type family UntagR (xs :: [*]) :: [*]
--   type instance UntagR '[] = '[]
--   type instance UntagR (x ': xs) = Untag1 x ': UntagR xs
--   </pre>
--   
--   Length information should flow backwards
--   
--   <pre>
--   &gt;&gt;&gt; let len2 x = x `asTypeOf` (undefined :: HList '[a,b])
--   
--   &gt;&gt;&gt; let f = len2 $ hTagSelf (hReplicate Proxy ())
--   
--   &gt;&gt;&gt; :t f
--   f :: HList '[Tagged () (), Tagged () ()]
--   </pre>
class SameLength a ta => TagUntagFD a ta | a -> ta, ta -> a
hTagSelf :: TagUntagFD a ta => HList a -> HList ta
hUntagSelf :: TagUntagFD a ta => HList ta -> HList a

-- | Transforming a TIP: applying to a TIP a (polyvariadic) function that
--   takes arguments from a TIP and updates the TIP with the result.
--   
--   In more detail: we have a typed-indexed collection TIP and we would
--   like to apply a transformation function to it, whose argument types
--   and the result type are all in the TIP. The function should locate its
--   arguments based on their types, and update the TIP with the result.
--   The function may have any number of arguments, including zero; the
--   order of arguments should not matter.
--   
--   The problem was posed by Andrew U. Frank on Haskell-Cafe, Sep 10,
--   2009.
--   <a>http://www.haskell.org/pipermail/haskell-cafe/2009-September/066217.html</a>
--   The problem is an interesting variation of the keyword argument
--   problem.
--   
--   Examples can be found in <tt>examples/TIPTransform.hs</tt> and
--   <tt>examples/TIPTransformM.hs</tt>
class TransTIP op db
ttip :: TransTIP op db => op -> TIP db -> TIP db

-- | In March 2010, Andrew Frank extended the problem for monadic
--   operations. This is the monadic version of <tt>TIPTransform.hs</tt> in
--   the present directory.
--   
--   This is the TF implementation. When specifying the operation to
--   perform over a TIP, we can leave it polymorphic over the monad. The
--   type checker will instantiate the monad based on the context.
class Monad m => TransTIPM m op db
ttipM :: TransTIPM m op db => op -> TIP db -> m (TIP db)

-- | A datatype for type-indexed co-products. A <a>TIC</a> is just a
--   <a>Variant</a>, where the elements of the type-level list <tt>"l"</tt>
--   are in the form <tt>Tagged x x</tt>.
data TIC (l :: [*])

-- | make a TIC for use in contexts where the result type is fixed
mkTIC :: (HAllTaggedEq l, HLabelSet [*] (LabelsOf l), HasField * i (Record l) i, HFind1 * i (UnLabel * i (LabelsOf l)) n, HNat2Integral n, HAllTaggedLV l) => i -> TIC l

-- | make a TIC that contains one element
mkTIC1 :: MkVariant i i '[Tagged i i] => i -> TIC '[Tagged i i]

-- | Public constructor (or, open union's injection function)
mkTIC' :: (HTypeIndexed l, MkVariant i i l) => i -> proxy l -> TIC l
ticPrism :: (TICPrism s t a b, SameLength s t, Choice p, Applicative f) => (a `p` f b) -> (TIC s `p` f (TIC t))

-- | <pre>
--   Prism' (TIC s) a
--   </pre>
ticPrism' :: (HPrism a s t a b, a ~ b, s ~ t) => (forall f p. (Applicative f, Choice p) => (a `p` f b) -> (TIC s `p` f (TIC t)))

-- | <tt>Variant vs</tt> has an implementation similar to <tt>Dynamic</tt>,
--   except the contained value is one of the elements of the <tt>vs</tt>
--   list, rather than being one particular instance of <a>Typeable</a>.
--   
--   <pre>
--   &gt;&gt;&gt; v .!. _right
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; v .!. _left
--   Just 'x'
--   </pre>
--   
--   In some cases the <tt>pun</tt> quasiquote works with variants,
--   
--   <pre>
--   &gt;&gt;&gt; let f [pun| left right |] = (left,right)
--   
--   &gt;&gt;&gt; f v
--   (Just 'x',Nothing)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; f w
--   (Nothing,Just 5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let add1 v = hMapV (Fun succ :: Fun '[Enum] '()) v
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; f (add1 v)
--   (Just 'y',Nothing)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; f (add1 w)
--   (Nothing,Just 6)
--   </pre>
data Variant (vs :: [*])
mkVariant :: MkVariant x v vs => Label x -> v -> proxy vs -> Variant vs
mkVariant1 :: Label k l -> e -> Variant ((:) * (Tagged k l e) ([] *))

-- | in ghc&gt;=7.8, <a>coerce</a> is probably a better choice
castVariant :: (RecordValuesR v ~ RecordValuesR v', SameLength v v') => Variant v -> Variant v'

-- | Apply a function to all possible elements of the variant
newtype HMapV f
HMapV :: f -> HMapV f

-- | shortcut for <tt>applyAB . HMapV</tt>. <a>hMap</a> is more general
hMapV :: (HMapAux Variant (HFmap f) x y, SameLength' * * y x, SameLength' * * x y) => f -> Variant x -> Variant y

-- | <tt>hMapOutV f = unvariant . hMapV f</tt>, except an ambiguous type
--   variable is resolved by <a>HMapOutV_gety</a>
hMapOutV :: (SameLength x y, HMapAux Variant (HFmap f) x y, Unvariant y z, HMapOutV_gety x z ~ y) => f -> Variant x -> z

-- | Applies to variants that have the same labels in the same order. A
--   generalization of
--   
--   <pre>
--   zipEither :: Either a b -&gt; Either a b -&gt; Maybe (Either (a,a) (b,b))
--   zipEither (Left a) (Left a') = Just (Left (a,a'))
--   zipEither (Right a) (Right a') = Just (Right (a,a'))
--   zipEither _ _ = Nothing
--   </pre>
--   
--   see <a>HZip</a> for zipping other collections
class ZipVariant x y xy | x y -> xy, xy -> x y
zipVariant :: ZipVariant x y xy => Variant x -> Variant y -> Maybe (Variant xy)

-- | Apply a record of functions to a variant of values. The functions are
--   selected based on those having the same label as the value.
class (SameLength v v', SameLabels v v') => ZipVR fs v v' | fs v -> v'
zipVR_ :: ZipVR fs v v' => Record fs -> Variant v -> Variant v'

-- | <pre>
--   &gt;&gt;&gt; let xy = x .*. y .*. emptyProxy
--   
--   &gt;&gt;&gt; let p = Proxy `asLabelsOf` xy
--   
--   &gt;&gt;&gt; let vs = [ mkVariant x 1.0 p, mkVariant y () p ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; zipVR (hBuild (+1) id) `map` vs
--   [V{x=2.0},V{y=()}]
--   </pre>
zipVR :: (SameLabels fs v, SameLength fs v, ZipVR fs v v', ZipVRCxt fs v v') => Record fs -> Variant v -> Variant v'
class (ProjectVariant x yin, ProjectVariant x yout) => SplitVariant x yin yout
splitVariant :: SplitVariant x yin yout => Variant x -> Either (Variant yin) (Variant yout)

-- | convert a variant with more fields into one with fewer (or the same)
--   fields.
--   
--   <pre>
--   &gt;&gt;&gt; let ty = Proxy :: Proxy [Tagged "left" Int, Tagged "right" Int]
--   
--   &gt;&gt;&gt; let l = mkVariant _left 1 ty
--   
--   &gt;&gt;&gt; let r = mkVariant _right 2 ty
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map projectVariant [l, r] :: [Maybe (Variant '[Tagged "left" Int])]
--   [Just V{left=1},Nothing]
--   </pre>
--   
--   <tt><a>rearrangeVariant</a> = <tt>fromJust</tt> .
--   <a>projectVariant</a></tt> is one implementation of
--   <a>rearrangeVariant</a>, since the result can have the same fields
--   with a different order:
--   
--   <pre>
--   &gt;&gt;&gt; let yt = Proxy :: Proxy [Tagged "right" Int, Tagged "left" Int]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; map projectVariant [l, r] `asTypeOf` [Just (mkVariant _left 0 yt)]
--   [Just V{left=1},Just V{right=2}]
--   </pre>
class ProjectVariant x y
projectVariant :: ProjectVariant x y => Variant x -> Maybe (Variant y)

-- | <tt>projectVariant . extendsVariant = Just</tt> (when the types match
--   up)
--   
--   <a>extendVariant</a> is a special case
class (HAllTaggedLV y, HAllTaggedLV x) => ExtendsVariant x y
extendsVariant :: ExtendsVariant x y => Variant x -> Variant y

-- | <pre>
--   projectExtendVariant = fmap <a>extendVariant</a> . <a>projectVariant</a>
--   </pre>
--   
--   where intermediate variant is as large as possible. Used to implement
--   <a>Data.HList.Labelable</a>.<tt>projected</tt>
--   
--   Note that:
--   
--   <pre>
--   &gt;&gt;&gt; let r = projectExtendVariant (mkVariant1 Label 1 :: Variant '[Tagged "x" Int])
--   
--   &gt;&gt;&gt; r :: Maybe (Variant '[Tagged "x" Integer])
--   Nothing
--   </pre>
class HAllTaggedLV y => ProjectExtendVariant x y
projectExtendVariant :: ProjectExtendVariant x y => Variant x -> Maybe (Variant y)

-- | Make a <tt>Prism (Variant s) (Variant t) a b</tt> out of a Label.
--   
--   See <a>Data.HList.Labelable</a>.<tt>hLens'</tt> is a more overloaded
--   version.
--   
--   Few type annotations are necessary because of the restriction that
--   <tt>s</tt> and <tt>t</tt> have the same labels in the same order, and
--   to get "t" the "a" in "s" is replaced with "b".
class (SameLength s t, SameLabels s t) => HPrism x s t a b | x s -> a, x t -> b, x s b -> t, x t a -> s
hPrism :: (HPrism x s t a b, Choice p, Applicative f) => Label x -> p a (f b) -> p (Variant s) (f (Variant t))

-- | <pre>
--   Lens (Variant s) (Variant t) a b
--   </pre>
--   
--   Analogue of <tt>Control.Lens.chosen :: Lens (Either a a) (Either b b)
--   a b</tt>
unvarianted :: (Unvariant' s a, Unvariant' t b, SameLabels s t, SameLength s t, Functor f) => (a -> f b) -> Variant s -> f (Variant t)

-- | <pre>
--   Lens' (Variant s) a
--   </pre>
--   
--   where we might have <tt>s ~ '[Tagged t1 a, Tagged t2 a]</tt>
unvarianted' :: (HAllEqVal ((:) * (Tagged * () b) s) b1, HAllEqVal s b1, HAllEqVal' ((:) * (Tagged * () b) s), Unvariant1 Bool b1 s b, SameLength' * * s s, SameLabels [*] [*] s s, Functor f) => (b -> f b) -> Variant s -> f (Variant s)
splitVariant1 :: Variant (Tagged s x : xs) -> Either x (Variant xs)

-- | x ~ Tagged s t
splitVariant1' :: Variant (x : xs) -> Either x (Variant xs)
extendVariant :: Variant l -> Variant (e : l)

-- | Convert a Variant which has all possibilities having the same type
--   into a value of that type. Analogous to <tt>either id id</tt>.
--   
--   See also <a>unvariant'</a>
class Unvariant v e | v -> e
unvariant :: Unvariant v e => Variant v -> e

-- | Similar to <a>unvariant</a>, except type variables in <tt>v</tt> will
--   be made equal to <tt>e</tt> if possible. That allows the type of
--   <tt>Nothing</tt> to be inferred as <tt>Maybe Char</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; unvariant' $ x .=. Nothing .*. mkVariant1 y 'y'
--   'y'
--   </pre>
--   
--   However, this difference leads to more local error messages
--   (<tt>Couldn't match type () with Char</tt>), rather than the
--   following with <tt>unvariant</tt>:
--   
--   <pre>
--   Fail
--      '("Variant",
--        '[Tagged "left" Char, Tagged "right" ()],
--        "must have all values equal to ",
--        e))
--   </pre>
class Unvariant' v e | v -> e
unvariant' :: Unvariant' v e => Variant v -> e

-- | Conversion between type indexed collections (<a>TIC</a> and
--   <a>TIP</a>) and the corresponding collection that has other label
--   types (<a>Variant</a> and <a>Record</a> respectively)
--   
--   See <a>typeIndexed'</a>
class TypeIndexed r tr | r -> tr, tr -> r
typeIndexed :: (TypeIndexed r tr, TypeIndexedCxt s t a b, Profunctor p, Functor f) => p (tr (TagR a)) (f (tr (TagR b))) -> p (r s) (f (r t))

-- | <pre>
--   <tt>Iso'</tt> (<a>Variant</a> s) (<a>TIC</a> a)
--   </pre>
--   
--   <pre>
--   <tt>Iso'</tt> (<a>Record</a> s) (<a>TIP</a> a)
--   </pre>
--   
--   where <tt>s</tt> has a type like <tt>'[Tagged "x" Int]</tt>, and
--   <tt>a</tt> has a type like <tt>'[Tagged Int Int]</tt>.
typeIndexed' :: (TypeIndexed r tr, TagUntagFD (RecordValuesR s) (TagR (RecordValuesR s)), HLabelSet [*] (LabelsOf s), RecordValues s, HMapAux HList TaggedFn (RecordValuesR s) s, SameLength' * * (RecordValuesR s) (RecordValuesR s), SameLength' * * s s, SameLabels [*] [*] s s, HAllTaggedLV s, Profunctor p, Coercible [*] (TagR (RecordValuesR s)) s, Functor f) => p (tr (TagR (RecordValuesR s))) (f (tr (TagR (RecordValuesR s)))) -> p (r s) (f (r s))

-- | <pre>
--   Iso (TIP (TagR a)) (TIP (TagR b)) (HList a) (HList b)
--   </pre>
tipHList :: (TagUntagFD a1 l, TagUntagFD a ta, Profunctor p, Functor f) => p (HList a) (f (HList a1)) -> p (TIP ta) (f (TIP l))

-- | <pre>
--   Iso' (TIP (TagR s)) (HList a)
--   </pre>
tipHList' :: (TagUntagFD a ta, Profunctor p, Functor f) => p (HList a) (f (HList a)) -> p (TIP ta) (f (TIP ta))

-- | <pre>
--   Iso (TIC s) (TIC t) (Variant s) (Variant t)
--   </pre>
--   
--   <a>typeIndexed</a> may be more appropriate
ticVariant :: (Profunctor p, Functor f) => p (Variant t) (f (Variant l)) -> p (TIC t) (f (TIC l))

-- | <pre>
--   Iso' (TIC s) (Variant s)
--   </pre>
ticVariant' :: (Profunctor p, Functor f) => p (Variant t) (f (Variant t)) -> p (TIC t) (f (TIC t))

-- | <pre>
--   Iso (TIP s) (TIP t) (Record s) (Record t)
--   </pre>
--   
--   <tt>typeIndexed</tt> may be more appropriate
tipRecord :: (Profunctor p, Functor f) => p (Record r) (f (Record l)) -> p (TIP r) (f (TIP l))

-- | <pre>
--   Iso' (TIP (TagR s)) (Record a)
--   </pre>
tipRecord' :: (Profunctor p, Functor f) => p (Record r) (f (Record r)) -> p (TIP r) (f (TIP r))

-- | <pre>
--   Prism (Record tma) (Record tmb) (Variant ta) (Variant tb)
--   </pre>
--   
--   see <a>hMaybied'</a>
hMaybied :: (VariantToHMaybied v1 x, VariantToHMaybied v r, HFoldr HMaybiedToVariantFs [Variant ([] *)] x [Variant v1], HMapAux HList (HFmap HCastF) x r, SameLength' * * x r, SameLength' * * r x, Choice p, Applicative f) => p (Variant v1) (f (Variant v)) -> p (Record x) (f (Record r))

-- | <pre>
--   Prism' (Record tma) (Variant ta)
--   </pre>
--   
--   where <tt>tma</tt> and <tt>tmb</tt> are lists like
--   
--   <pre>
--   tma ~ '[Tagged x (Maybe a), Tagged y (Maybe b)]
--   ta  ~ '[Tagged x        a , Tagged y        b ]
--   </pre>
--   
--   If one element of the record is Just, the Variant will contain that
--   element. Otherwise, the prism fails.
--   
--   <ul>
--   <li><i><tt>Note</tt></i></li>
--   </ul>
--   
--   The types work out to define a prism:
--   
--   <pre>
--   l = <a>prism'</a> <a>variantToHMaybied</a> (<tt>listToMaybe</tt> . <a>hMaybiedToVariants</a>)
--   </pre>
--   
--   but the law: <tt>s^?l  Just a ==&gt; l # a  s</tt> is not followed,
--   because we could have:
--   
--   <pre>
--   s, s2 :: Record '[Tagged "x" (Maybe Int), Tagged "y" (Maybe Char)]
--   s = hBuild (Just 1) (Just '2')
--   s2 = hBuild (Just 1) Nothing
--   
--   v :: Variant '[Tagged "x" Int, Tagged "y" Char]
--   v = mkVariant (Label :: Label "x") 1 Proxy
--   </pre>
--   
--   So that <tt>s^?l == Just v</tt>. But <tt>l#v == s2 /= s</tt>, while
--   the law requires <tt>l#v == s</tt>. hMaybied avoids this problem by
--   only producing a value when there is only one present.
hMaybied' :: (VariantToHMaybied v x, HFoldr HMaybiedToVariantFs [Variant ([] *)] x [Variant v], HMapAux HList (HFmap HCastF) x x, SameLength' * * x x, Choice p, Applicative f) => p (Variant v) (f (Variant v)) -> p (Record x) (f (Record x))
class VariantToHMaybied v r | v -> r, r -> v
variantToHMaybied :: VariantToHMaybied v r => Variant v -> Record r
data HMaybiedToVariantFs

-- | Every element of the record that is Just becomes one element in the
--   resulting list. See <a>hMaybied'</a> example types that <tt>r</tt> and
--   <tt>v</tt> can take.
hMaybiedToVariants :: (HFoldr HMaybiedToVariantFs [Variant []] r [Variant v], VariantToHMaybied v r) => Record r -> [Variant v]

-- | <tt>kw</tt> takes a <a>HList</a> whose first element is a function,
--   and the rest of the elements are default values. A useful trick is to
--   have a final argument <tt>()</tt> which is not eaten up by a label (A
--   only takes 1 argument). That way when you supply the () it knows there
--   are no more arguments (?).
--   
--   <pre>
--   &gt;&gt;&gt; data A = A
--   
--   &gt;&gt;&gt; instance IsKeyFN (A -&gt; a -&gt; b) True
--   
--   &gt;&gt;&gt; let f A a () = a + 1
--   
--   &gt;&gt;&gt; let f' = f .*. A .*. 1 .*. HNil
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; kw f' A 0 ()
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; kw f' ()
--   2
--   </pre>
class Kw (fn :: *) (arg_def :: [*]) r
kw :: Kw fn arg_def r => HList (fn : arg_def) -> r

-- | convert a <a>Record</a> into a list that can supply default arguments
--   for <a>kw</a>
--   
--   A bit of setup:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XQuasiQuotes
--   
--   &gt;&gt;&gt; import Data.HList.RecordPuns
--   
--   &gt;&gt;&gt; let f (_ :: Label "a") a (_ :: Label "b") b () = a `div` b
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let a = 2; b = 1; f' = f .*. recToKW [pun| a b |]
--   
--   &gt;&gt;&gt; kw f' ()
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; kw f' (Label :: Label "a") 10 ()
--   10
--   </pre>
recToKW :: (HMapCxt HList TaggedToKW a b, HConcat b) => Record a -> HList (HConcatR b)

-- | All our keywords must be registered
class IsKeyFN (t :: *) (flag :: Bool) | t -> flag
data K s (c :: *)
data ErrReqdArgNotFound x
data ErrUnexpectedKW x
class HAllTaggedEq (l :: [*])


-- | OOHaskell (C) 2004, Oleg Kiselyov, Ralf Laemmel, Keean Schupke
--   
--   This module gathers the API that we need for OOP in Haskell. We
--   basically select a certain configuration of the HList library, and we
--   also import modules that are needed for mutable data and monads. Note
--   on overlapping: Needed for the chosen model of labels. Other models
--   can be used instead, but the chosen look better in types.
module Data.HList
concrete :: MonadFix m => (a -> m a) -> a -> m a
(#) :: HasField l r v => r -> Label l -> v
