-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | data and parsers for Ethernet, TCP, UDP, IPv4, IPv6, ICMP, DHCP, TFTP
--   
--   The network stack extracted from the House
--   (<a>https://code.google.com/p/pdxhouse/</a>) project.
--   
--   Provides data structures and parsers for Ethernet, TCP, UDP, IPv4,
--   IPv6, ICMP, DHCP and TFTP packets as well as some server
--   implementations.
--   
--   This package was extracted from house due to the lack of existing
--   network package parsing libraries.
@package network-house
@version 0.1.0.1

module Net.Interface
data Interface m i o
Interface :: m i -> (o -> m ()) -> Interface m i o
rx :: Interface m i o -> m i
tx :: Interface m i o -> o -> m ()
data TimedInterface m i o
TimedInterface :: (Maybe Int -> m (Maybe i)) -> (o -> m ()) -> TimedInterface m i o
rxT :: TimedInterface m i o -> Maybe Int -> m (Maybe i)
txT :: TimedInterface m i o -> o -> m ()


-- | Concurrency primitives abstracted away from the IO monad
module Net.Concurrent
class (Functor io, Monad io) => ForkIO io
fork :: ForkIO io => io () -> io ThreadId
kill :: ForkIO io => ThreadId -> io ()
class (Functor io, Monad io) => DelayIO io
delay :: DelayIO io => Int -> io ()
class (Functor io, Monad io) => ChannelIO c io | io -> c
newChan :: ChannelIO c io => io (c a)
readChan :: ChannelIO c io => c a -> io a
writeChan :: ChannelIO c io => c a -> a -> io ()
class (Functor io, Monad io) => MVarIO v io | io -> v where newMVar a = do { v <- newEmptyMVar; putMVar v a; return v }
newEmptyMVar :: MVarIO v io => io (v a)
newMVar :: MVarIO v io => a -> io (v a)
putMVar :: MVarIO v io => v a -> a -> io ()
takeMVar, readMVar :: MVarIO v io => v a -> io a
class (Functor io, Monad io) => RefIO r io | io -> r
newRef :: RefIO r io => a -> io (r a)
readRef :: RefIO r io => r a -> io a
writeRef :: RefIO r io => r a -> a -> io ()
instance (MonadTrans t, Monad m, Functor (t m), Monad (t m), RefIO c m) => RefIO c (t m)
instance (MonadTrans t, Monad m, Functor (t m), Monad (t m), MVarIO v m) => MVarIO v (t m)
instance (MonadTrans t, Monad m, Functor (t m), Monad (t m), ChannelIO c m) => ChannelIO c (t m)
instance (MonadTrans t, Monad m, Functor (t m), Monad (t m), DelayIO m) => DelayIO (t m)

module Net.Wire
type Wire m a = Interface m a a

-- | An unbounded buffer unbounded :: ChannelIO c m =&gt; m (Wire m a)
unbounded :: (ChannelIO c m, ChannelIO c m1) => () -> m (Interface m1 o o)
newWire :: (MVarIO v m, MVarIO v m1, ChannelIO c m, ChannelIO c m1) => () -> m (Interface m1 o o)
newWire' :: (Enum a, Num a, Ord a, MVarIO v m, MVarIO v m1, ChannelIO c m, ChannelIO c m1) => a -> m (Interface m1 o o)
bounded :: (MVarIO v m, MVarIO v m1) => m (Interface m1 i o) -> m (Interface m1 i o)

-- | A bounded buffer that discards input when full
bounded' :: (Enum a, Num a, Ord a, MVarIO v m, MVarIO v m1) => a -> m (Interface m1 i o) -> m (Interface m1 i o)
timedWire :: (Eq (r ()), RefIO r m1, ChannelIO c m, ChannelIO c m1, DelayIO m1, ForkIO m1) => () -> m (TimedInterface m1 o o)

module Net.IO
instance RefIO IORef IO
instance MVarIO MVar IO
instance ChannelIO Chan IO
instance DelayIO IO
instance ForkIO IO

module Net.Bits
finiteBitSize :: Bits a => a -> Int
(.!.) :: (Integral a, Num a1, Bits a, Bits a1) => a -> Int -> a1
nextTo :: (Integral a1, Integral a2, Num a, Bits a, Bits a2) => a1 -> a2 -> a
catBits :: (Integral a1, Num a, Bits a1, Bits a) => [a1] -> a
showHex :: (Integral a, Show a) => a -> String
showBin :: Bits a => a -> [Char]
showHex' :: (Integral a, Show a) => Int -> a -> [Char]


-- | Various utilities used in the network protocol stack modules
module Net.Utils
class Functor f => Container f
contents :: Container f => f a -> a
replace :: Functor f => f a -> b -> f b
emap :: (Functor f, Container f1) => (a1 -> f a) -> f1 a1 -> f (f1 a)
emap2 :: (Functor f, Container f1, Container f2) => (a1 -> f a) -> f1 (f2 a1) -> f (f1 (f2 a))
lift :: (Functor f, Container f1) => f1 (f a) -> f (f1 a)
lift2 :: (Functor f, Container f1, Container f2) => f1 (f2 (f a)) -> f (f1 (f2 a))
doReq :: (MVarIO v m, MVarIO v io, ChannelIO c m) => c a -> ((b -> io ()) -> a) -> m b
foldlArray :: (IArray arr elem, Ix ix, Enum ix) => arr ix elem -> (elem -> a -> a) -> a -> a

-- | The number of elements in an array
arraySize :: (Num a1, Ix a1, IArray a e) => a a1 e -> a1

-- | TCP/IP 16-bit checksums
checksum :: [Word16] -> Word16

-- | Split a list into subcomponents of length 2. The first argument is
--   what to append in case the list is of odd length.
pairs :: a -> [a] -> [[a]]
bytes_to_words_big :: [Word8] -> [Word16]
bytes_to_words_lil :: [Word8] -> [Word16]
words_to_bytes_big :: [Word16] -> [Word8]
words_to_bytes_lil :: [Word16] -> [Word8]

module Net.Packet

-- | 8-bit unsigned integer type
data Word8 :: *

-- | The buffers used to represent packet, when they are received over the
--   network.
data InPacket
len :: InPacket -> Int
emptyInPack :: InPacket
toInPack :: Chunk -> InPacket
takeInPack :: Int -> InPacket -> InPacket
dropInPack :: Int -> InPacket -> InPacket

-- | Get a byte at a certain offset.
byteAt :: InPacket -> Int -> Word8

-- | Get a word from a certain offset (big endian).
wordAt :: InPacket -> Int -> Word16
toChunk :: InPacket -> Chunk

-- | The buffers for packets, that are to be sent over the network. Each
--   array contains a header of a layer in the network protocol stack.
data OutPacket
outLen :: OutPacket -> Int
chunks :: OutPacket -> [Chunk]
type Chunk = UArray Int Word8
emptyOutPack :: OutPacket
addChunk :: Chunk -> OutPacketS
appendOutPack :: OutPacket -> OutPacket -> OutPacket
splitOutPack :: Int -> OutPacket -> (OutPacket, OutPacket)
outBytes :: OutPacket -> [Word8]
loopback :: OutPacket -> InPacket
loopbackout :: InPacket -> OutPacket
instance Show OutPacket
instance Show InPacket

module Net.PacketParsing
data PacketParser a

-- | The buffers used to represent packet, when they are received over the
--   network.
data InPacket
doParse :: Parse a => InPacket -> Maybe a
parseInPacket :: PacketParser a -> InPacket -> Maybe a

-- | Perform two monadic computation and return the result from the second
--   one
(#!) :: (Monad m, Functor m) => m b -> m a -> m b

-- | Apply a pure function to the result of a monadic computation
(#) :: Functor f => (a -> b) -> f a -> f b

-- | Apply a function returned by a monadic computation to an argument
--   returned by a monadic computation
(<#) :: Monad m => m (a -> b) -> m a -> m b
class Parse a
parse :: Parse a => PacketParser a
bytes :: (Eq a, Num a) => a -> PacketParser [Word8]
bits :: (Integral a, Bits a) => Int -> PacketParser a
word8 :: PacketParser Word8
word16 :: PacketParser Word16
word32 :: PacketParser Word32
check8 :: Word8 -> PacketParser ()
check16 :: Word16 -> PacketParser ()
check :: Monad m => Bool -> m ()
lift :: Monad m => Maybe a -> m a
therest :: PacketParser InPacket
trunc :: Int -> PacketParser ()
class Unparse a
unparse :: Unparse a => a -> UnparseS

-- | The buffers for packets, that are to be sent over the network. Each
--   array contains a header of a layer in the network protocol stack.
data OutPacket
doUnparse :: Unparse a => a -> OutPacket
instance Unparse Char
instance Unparse a => Unparse [a]
instance (Unparse a, Unparse b, Unparse c, Unparse d, Unparse e) => Unparse (a, b, c, d, e)
instance (Unparse a, Unparse b, Unparse c, Unparse d) => Unparse (a, b, c, d)
instance (Unparse a, Unparse b, Unparse c) => Unparse (a, b, c)
instance (Unparse a, Unparse b) => Unparse (a, b)
instance Unparse ()
instance Unparse InPacket
instance Unparse Chunk
instance Unparse OutPacket
instance Unparse Word32
instance Unparse Word16
instance Unparse Word8
instance Parse Char
instance Parse Word32
instance Parse Word16
instance Parse Word8
instance Parse Bool
instance Parse a => Parse [a]
instance (Parse a, Parse b, Parse c, Parse d) => Parse (a, b, c, d)
instance (Parse a, Parse b, Parse c) => Parse (a, b, c)
instance (Parse a, Parse b) => Parse (a, b)
instance Parse (UArray Int Word8)
instance Parse InPacket
instance Alternative PacketParser
instance MonadPlus PacketParser
instance Monad PacketParser
instance Applicative PacketParser
instance Functor PacketParser

module Net.Ethernet
data Interface m i o
Interface :: Addr -> Interface m i o -> Interface m i o
myMAC :: Interface m i o -> Addr
io :: Interface m i o -> Interface m i o
rx :: Interface m i o -> m i
tx :: Interface m i o -> o -> m ()
data Addr
Addr :: !Word8 -> !Word8 -> !Word8 -> !Word8 -> !Word8 -> !Word8 -> Addr
broadcastAddr :: Addr
data Packet content
Packet :: Addr -> Addr -> PacketType -> content -> Packet content
dest :: Packet content -> Addr
source :: Packet content -> Addr
packType :: Packet content -> PacketType
content :: Packet content -> content
data PacketType
Ethernet :: !Int -> PacketType
IPv4 :: PacketType
IPv6 :: PacketType
ARP :: PacketType
Unknown :: !Word16 -> PacketType
unparse :: Packet OutPacket -> OutPacket
instance Eq Addr
instance Ord Addr
instance Bounded Addr
instance Eq PacketType
instance Show PacketType
instance Show content => Show (Packet content)
instance Parse content => Parse (Packet content)
instance Parse PacketType
instance Enum PacketType
instance Container Packet
instance Functor Packet
instance Show Addr
instance Unparse Addr
instance Parse Addr

module Net.IPv4OverEthernet
initialize :: Monad m => (t -> m (Maybe Addr)) -> Interface m i (Packet t1) -> Interface m i (t, t1)

module Net.IPv4
data Addr
Addr :: !Word8 -> !Word8 -> !Word8 -> !Word8 -> Addr
loopbackAddr :: Addr
broadcastAddr :: Addr -> Addr
type Netmask = Addr
netmaskA :: Addr
netmaskB :: Addr
netmaskC :: Addr
defaultNetmask :: Addr -> Addr
sameNet :: (Addr, Addr) -> Addr -> Bool
liftA1 :: (Word8 -> Word8) -> Addr -> Addr
liftA2 :: (Word8 -> Word8 -> Word8) -> Addr -> Addr -> Addr
andAddr :: Addr -> Addr -> Addr
orAddr :: Addr -> Addr -> Addr
complAddr :: Addr -> Addr
data Precedence
Routine :: Precedence
Priority :: Precedence
Immediate :: Precedence
Flash :: Precedence
Flash_Override :: Precedence
CRITIC_ECP :: Precedence
Internetwork_Control :: Precedence
Network_Control :: Precedence
data Packet content
Packet :: !Word8 -> !Int -> !TypeOfService -> !Word16 -> !Word16 -> !Flags -> !Word16 -> !Word8 -> !Protocol -> !Word16 -> !Addr -> !Addr -> ![Word8] -> !content -> Packet content
version :: Packet content -> !Word8
headerLen :: Packet content -> !Int
tos :: Packet content -> !TypeOfService
totalLen :: Packet content -> !Word16
identifier :: Packet content -> !Word16
flags :: Packet content -> !Flags
fragOff :: Packet content -> !Word16
timeToLive :: Packet content -> !Word8
protocol :: Packet content -> !Protocol
headerCheck :: Packet content -> !Word16
source :: Packet content -> !Addr
dest :: Packet content -> !Addr
options :: Packet content -> ![Word8]
content :: Packet content -> !content
data TypeOfService
TOS :: !Precedence -> !Bool -> !Bool -> !Bool -> TypeOfService
precedence :: TypeOfService -> !Precedence
lowDelay :: TypeOfService -> !Bool
highThrough :: TypeOfService -> !Bool
highReal :: TypeOfService -> !Bool
data Flags
Flags :: !Bool -> !Bool -> Flags
don'tFrag :: Flags -> !Bool
moreFrags :: Flags -> !Bool
skip :: Int -> PacketParser Word32
template :: Protocol -> Addr -> Addr -> content -> Packet content
data Protocol
ICMP :: Protocol
TCP :: Protocol
UDP :: Protocol
Unknown :: !Word8 -> Protocol
num_prot :: [(Int, Protocol)]
prot_num :: [(Protocol, Int)]
data Option
Short :: Word8 -> Option
Long :: OptType -> Word8 -> [Word8] -> Option
optType :: Option -> OptType
optLen :: Option -> Word8
optData :: Option -> [Word8]
data OptType
OptType :: Bool -> OptClass -> Word8 -> OptType
optCopied :: OptType -> Bool
optClass :: OptType -> OptClass
optNumber :: OptType -> Word8
data OptClass
Control :: OptClass
Reserved1 :: OptClass
DebugMeasure :: OptClass
Reserved4 :: OptClass
ipv4unparse :: Packet OutPacket -> OutPacket
instance Eq Addr
instance Ord Addr
instance Show Precedence
instance Enum Precedence
instance Show TypeOfService
instance Show Flags
instance Show Protocol
instance Eq Protocol
instance Show content => Show (Packet content)
instance Enum OptClass
instance Unparse a => Unparse (Packet a)
instance Parse contents => Parse (Packet contents)
instance Unparse Protocol
instance Parse Protocol
instance Enum Protocol
instance Container Packet
instance Functor Packet
instance Parse Flags
instance Parse TypeOfService
instance Parse Precedence
instance Read Addr
instance Show Addr
instance Unparse Addr
instance Parse Addr

module Net.IPv4Link
initialize :: Monad m => (Addr, Addr) -> Maybe Addr -> Interface m i (Addr, Packet content) -> Interface m i (Packet content)


-- | Port numbers (used by UDP and TCP) and some standard port numbers
module Net.PortNumber
newtype Port
Port :: Word16 -> Port
echo :: Port
telnet :: Port
bootps :: Port
bootpc :: Port
tftp :: Port
http :: Port
instance Eq Port
instance Ord Port
instance Bounded Port
instance Show Port
instance Unparse Port
instance Parse Port
instance Enum Port

module Net.DHCP
serverPort :: Port
clientPort :: Port
data Packet
Packet :: Operation -> Word32 -> Word16 -> Flags -> Addr -> Addr -> Addr -> Addr -> Addr -> String -> String -> Options -> Packet
opcode :: Packet -> Operation
xid :: Packet -> Word32
secs :: Packet -> Word16
flags :: Packet -> Flags
ciaddr :: Packet -> Addr
yiaddr :: Packet -> Addr
siaddr :: Packet -> Addr
giaddr :: Packet -> Addr
chaddr :: Packet -> Addr
sname :: Packet -> String
file :: Packet -> String
options :: Packet -> Options
data Operation
BootRequest :: Operation
BootReply :: Operation
data Flags
Flags :: Bool -> Flags
broadcast :: Flags -> Bool
newtype Options
Options :: [Option] -> Options
data Option
Pad :: Option
End :: Option
SubnetMask :: Addr -> Option
TimeOffset :: Option
Routers :: [Addr] -> Option
DNS_Servers :: [Addr] -> Option
HostName :: String -> Option
DomainName :: String -> Option
BroadcastAddress :: Addr -> Option
NTP_Servers :: [Addr] -> Option
RequestedIPAddress :: Addr -> Option
LeaseTime :: Word32 -> Option
OptionOverload :: Word8 -> Option
MessageType :: MessageType -> Option
ServerIdentifier :: Addr -> Option
Unknown :: Word8 -> [Word8] -> Option
data MessageType
Discover :: MessageType
Offer :: MessageType
Request :: MessageType
Decline :: MessageType
Ack :: MessageType
Nak :: MessageType
Release :: MessageType
Inform :: MessageType
template :: Addr -> Packet
magic :: [Word8]
parses :: Parse a => Int -> PacketParser [a]
zstring :: Int -> PacketParser String
bounded :: (Bounded a, Enum a, Integral a1) => Int -> a1 -> PacketParser a
unEnum :: (Enum a, Num b) => Int -> a -> b
instance Eq Operation
instance Bounded Operation
instance Enum Operation
instance Show Operation
instance Eq Flags
instance Show Flags
instance Eq MessageType
instance Bounded MessageType
instance Enum MessageType
instance Show MessageType
instance Eq Option
instance Show Option
instance Eq Options
instance Show Options
instance Show Packet
instance Unparse Packet
instance Parse Packet
instance Parse Option
instance Unparse Option
instance Unparse Options
instance Parse Options
instance Unparse Flags
instance Parse Flags
instance Unparse Operation
instance Unparse MessageType
instance Parse MessageType
instance Parse Operation

module Net.UDP
data Packet content
Packet :: !Port -> !Port -> !Word16 -> !Word16 -> !content -> Packet content
sourcePort :: Packet content -> !Port
destPort :: Packet content -> !Port
len :: Packet content -> !Word16
checksum :: Packet content -> !Word16
content :: Packet content -> !content
template :: Port -> Port -> content -> Packet content
newtype Port
Port :: Word16 -> Port
instance Show content => Show (Packet content)
instance Unparse a => Unparse (Packet a)
instance Parse a => Parse (Packet a)
instance Container Packet
instance Functor Packet

module Net.UDP_Client
initialize :: (Eq (r ()), RefIO r m, MVarIO v m, ChannelIO c m, DelayIO m, ForkIO m) => ([Char] -> m ()) -> Addr -> Interface m (Packet (Packet InPacket)) (Packet (Packet OutPacket)) -> m (Interface m)
type UDP_API m = TimedInterface m (Addr, Packet InPacket) (Addr, Packet OutPacket)
data Interface m
Interface :: (Port -> m (UDP_API m)) -> m (Port, UDP_API m) -> (Port -> m ()) -> Interface m
listen :: Interface m -> Port -> m (UDP_API m)
listenAny :: Interface m -> m (Port, UDP_API m)
unlisten :: Interface m -> Port -> m ()
data Packet content
Packet :: !Port -> !Port -> !Word16 -> !Word16 -> !content -> Packet content
sourcePort :: Packet content -> !Port
destPort :: Packet content -> !Port
len :: Packet content -> !Word16
checksum :: Packet content -> !Word16
content :: Packet content -> !content
template :: Port -> Port -> content -> Packet content
newtype Port
Port :: Word16 -> Port

module Net.DHCP_Client
init :: (RefIO r m, DelayIO m, ForkIO m) => ([Char] -> m ()) -> Interface m (Packet InPacket) (Packet OutPacket) -> m (Addr, Maybe Addr, Addr)
solicit :: (RefIO r m, DelayIO m, ForkIO m) => m a -> m b -> m b
solicit' :: (RefIO r m, DelayIO m, ForkIO m) => Int -> m a -> m b -> m b

module Net.ICMP
data Packet
EchoRequest :: EchoMsg -> Packet
EchoReply :: EchoMsg -> Packet
Other :: !MessageType -> !Word8 -> !Word16 -> UArray Int Word8 -> Packet
type_ :: Packet -> !MessageType
code :: Packet -> !Word8
chksum :: Packet -> !Word16
content :: Packet -> UArray Int Word8
data EchoMsg
Echo :: !Word16 -> !Word16 -> UArray Int Word8 -> EchoMsg
ident :: EchoMsg -> !Word16
seqNum :: EchoMsg -> !Word16
echoData :: EchoMsg -> UArray Int Word8
icmpUnparse :: Packet -> OutPacket
echoUnparse :: Bool -> EchoMsg -> OutPacket
data MessageType
Echo_Reply :: MessageType
Unknown1 :: MessageType
Unknown2 :: MessageType
Destination_Unreachable :: MessageType
Source_Quench :: MessageType
Redirect :: MessageType
Unknown6 :: MessageType
Unknown7 :: MessageType
Echo_Request :: MessageType
Unknown9 :: MessageType
Unknown10 :: MessageType
Time_Exceeded :: MessageType
Parameter_Problem :: MessageType
Timestamp :: MessageType
Timestamp_Reply :: MessageType
Information_Request :: MessageType
Information_Reply :: MessageType
UnknownOther :: MessageType
instance Show EchoMsg
instance Eq MessageType
instance Enum MessageType
instance Bounded MessageType
instance Show MessageType
instance Show Packet
instance Parse MessageType
instance Unparse Packet
instance Parse EchoMsg
instance Parse Packet

module Net.TCP
data Packet content
Packet :: !Port -> !Port -> !Word32 -> !Word32 -> !Word8 -> !ECN -> !ControlBits -> !Word16 -> !Word16 -> !Word16 -> ![Option] -> !content -> Packet content
sourcePort :: Packet content -> !Port
destPort :: Packet content -> !Port
seqNr :: Packet content -> !Word32
ackNr :: Packet content -> !Word32
dataOffset :: Packet content -> !Word8
ecn :: Packet content -> !ECN
controlBits :: Packet content -> !ControlBits
window :: Packet content -> !Word16
checksum :: Packet content -> !Word16
urgentPointer :: Packet content -> !Word16
options :: Packet content -> ![Option]
content :: Packet content -> !content
template :: Packet ()
data ECN
ECN :: !Bool -> !Bool -> !Bool -> ECN
n :: ECN -> !Bool
c :: ECN -> !Bool
e :: ECN -> !Bool
data ControlBits
CB :: !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> !Bool -> ControlBits
urg :: ControlBits -> !Bool
ack :: ControlBits -> !Bool
psh :: ControlBits -> !Bool
rst :: ControlBits -> !Bool
syn :: ControlBits -> !Bool
fin :: ControlBits -> !Bool
type Option = Word8
toBits :: Num b => [Bool] -> b
instance Show ECN
instance Bounded ECN
instance Eq ControlBits
instance Bounded ControlBits
instance Show ControlBits
instance Show content => Show (Packet content)
instance Unparse content => Unparse (Packet content)
instance Parse ECN
instance Parse ControlBits
instance Parse content => Parse (Packet content)
instance Container Packet
instance Functor Packet

module Net.TCP_Client
initialize :: (MVarIO v io, ChannelIO c io, DelayIO io, ForkIO io) => ([Char] -> io ()) -> Addr -> Interface io TCPPacketIn (Packet (Packet OutPacket)) -> io (Interface io)
data Active m
Active :: m () -> Interface m InPacket OutPacket -> Active m
close :: Active m -> m ()
io :: Active m -> Interface m InPacket OutPacket
tx :: Active m -> OutPacket -> m ()
rx :: Active m -> m InPacket
data Passive m
Passive :: m (Peer, Active m) -> m () -> Passive m
accept :: Passive m -> m (Peer, Active m)
unlisten :: Passive m -> m ()
data Interface m
Interface :: (Port -> m (Passive m)) -> (Peer -> m (Maybe (Active m))) -> Interface m
listen :: Interface m -> Port -> m (Passive m)
connect :: Interface m -> Peer -> m (Maybe (Active m))
type Peer = (Addr, Port)
newtype Port
Port :: Word16 -> Port
instance Eq Phase
instance Ord Phase
instance Show Phase

module Net.IPv4Client
type Client m p = Client' m (p InPacket) (p OutPacket)
type Client_ m p = Client' m p p
type Client' m i o = Interface m (Packet i) (Packet o)
data Clients m
Clients :: Client_ m Packet -> Client m Packet -> Client m Packet -> Clients m
icmp :: Clients m -> Client_ m Packet
udp :: Clients m -> Client m Packet
tcp :: Clients m -> Client m Packet
initialize :: (MVarIO v m, ChannelIO c m, ForkIO m) => ([Char] -> m ()) -> Interface m (Packet InPacket) (Packet OutPacket) -> m (Clients m)

module Net.IPv6
data Addr
Addr :: !Word16 -> !Word16 -> !Word16 -> !Word16 -> !Word16 -> !Word16 -> !Word16 -> !Word16 -> Addr
newtype Word4
Word4 :: Word8 -> Word4
newtype Word20
Word20 :: Word32 -> Word20
data Packet content
Packet :: !Word4 -> !Word8 -> !Word20 -> !Word16 -> !Protocol -> !Word8 -> !Addr -> !Addr -> !content -> Packet content
version :: Packet content -> !Word4
traffic_class :: Packet content -> !Word8
flow_label :: Packet content -> !Word20
payload_length :: Packet content -> !Word16
next_header :: Packet content -> !Protocol
hop_limit :: Packet content -> !Word8
source :: Packet content -> !Addr
dest :: Packet content -> !Addr
content :: Packet content -> !content
instance Eq Addr
instance Unparse content => Unparse (Packet content)
instance Parse content => Parse (Packet content)
instance Functor Packet
instance Parse Word20
instance Parse Word4
instance Unparse Addr
instance Parse Addr

module Net.TFTP
data Packet
RRQ :: Filename -> Mode -> Packet
WRQ :: Filename -> Mode -> Packet
Data :: BlockNr -> Data -> Packet
Ack :: BlockNr -> Packet
Error :: ErrorCode -> ErrMsg -> Packet
type Filename = String
type Mode = String
type BlockNr = Word16
type Data = UArray Int Word8
newtype ErrorCode
E :: Word16 -> ErrorCode
type ErrMsg = String
string :: PacketParser [Char]
unstring :: Unparse t => t -> UnparseS
instance Eq ErrorCode
instance Show ErrorCode
instance Show Packet
instance Unparse ErrorCode
instance Unparse Packet
instance Parse ErrorCode
instance Parse Packet

module Net.TFTP_Client
tftpGet :: MVarIO v m => t -> Interface m -> Addr -> [Char] -> [Char] -> m (Either [Char] [Data])
tftpPut :: MVarIO v m => t -> Interface m -> Addr -> Filename -> Mode -> String -> m (Either [Char] ())

module Net.ARP
data Packet
Packet :: Operation -> Addr -> Addr -> Addr -> Addr -> Packet
opcode :: Packet -> Operation
senderHA :: Packet -> Addr
senderIP :: Packet -> Addr
targetHA :: Packet -> Addr
targetIP :: Packet -> Addr
data Operation
Request :: Operation
Reply :: Operation
instance Eq Operation
instance Show Operation
instance Show Packet
instance Unparse Operation
instance Parse Operation
instance Unparse Packet
instance Parse Packet

module Net.ARP_Protocol
data Interface m
Interface :: (Addr -> m (Maybe Addr)) -> m CacheDump -> Interface m
lookup :: Interface m -> Addr -> m (Maybe Addr)
dump :: Interface m -> m CacheDump
type CacheDump = [(Addr, Maybe Addr)]
initialize :: (MVarIO v m1, MVarIO v m, ChannelIO c m, ChannelIO c m1, DelayIO m, ForkIO m) => ([Char] -> m a) -> Interface m Packet (Packet Packet) -> Addr -> m (Interface m1)
instance Show (Req m)

module Net.ClientInterface
data Config
DHCP :: Config
Fixed :: Addr -> Addr -> Addr -> Config
myIP :: Config -> Addr
routerIP :: Config -> Addr
netmask :: Config -> Addr
fixed :: Addr -> Addr -> Config
data Net m
Net :: (Addr -> Word16 -> Word16 -> m ()) -> m CacheDump -> Interface m -> Interface m -> Net m
ping :: Net m -> Addr -> Word16 -> Word16 -> m ()
dump :: Net m -> m CacheDump
udp :: Net m -> Interface m
tcp :: Net m -> Interface m
instance Show Config

module Net.Servers
tcpEchoServer :: ForkIO m => ([Char] -> m a) -> Net m -> m b
udpEchoServer :: Monad m => ([Char] -> m a) -> Net m -> m b
simpleTCPServer :: (ForkIO m, Unparse o, Parse a2) => ([Char] -> m a) -> Net m -> Port -> (Interface m (Maybe a2) o -> m a1) -> m b
lineBuffered :: (MVarIO v m, MVarIO v m1) => t -> Interface m1 (Maybe [Char]) o -> m (Interface m1 [Char] o)

-- | A simple telnet server for line-based services
telnetServer :: (MVarIO v m, ForkIO m, Unparse o) => ([Char] -> m a1) -> o -> (Interface m [Char] o -> [Char] -> m a) -> Net m -> m b

-- | A simple telnet client for line-based services
telnet :: (RefIO r m, ForkIO m) => Interface m [Char] [Char] -> Net m -> Peer -> m ()

module Net.EthernetClient
type Client_ m p = Interface m p (Packet p)
type Client m p = Interface m (p InPacket) (Packet (p OutPacket))
data Clients m
Clients :: Client m Packet -> Client_ m Packet -> Clients m
ipv4 :: Clients m -> Client m Packet
arp :: Clients m -> Client_ m Packet
initialize :: (MVarIO v m, ChannelIO c m, ForkIO m) => ([Char] -> m ()) -> Interface m (Packet InPacket) (Packet OutPacket) -> m (Clients m)

module Net.Test
initialize :: (Eq (r ()), RefIO r io, MVarIO v io, ChannelIO c io, DelayIO io, ForkIO io) => ([Char] -> io ()) -> Config -> Interface io (Packet InPacket) (Packet OutPacket) -> io ((Addr, Maybe Addr, Addr), Net io)
icmpHandler :: ForkIO io => ([Char] -> io ()) -> Addr -> Interface io (Packet Packet) (Packet Packet) -> io ThreadId
sendPing :: (Packet Packet -> t) -> Addr -> Addr -> Word16 -> Word16 -> t
