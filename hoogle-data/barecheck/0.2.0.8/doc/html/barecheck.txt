-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | QuickCheck implementations for common types
--   
@package barecheck
@version 0.2.0.8

module Data.Tree.Generators
tree :: (Int -> Int) -> Gen a -> Gen (Tree a)

module Prelude.Shrinkers
maybe :: (a -> [a]) -> Maybe a -> [Maybe a]
either :: (a -> [a]) -> (b -> [b]) -> Either a b -> [Either a b]
tuple2 :: (a -> [a]) -> (b -> [b]) -> (a, b) -> [(a, b)]
tuple3 :: (a -> [a]) -> (b -> [b]) -> (c -> [c]) -> (a, b, c) -> [(a, b, c)]
tuple4 :: (a -> [a]) -> (b -> [b]) -> (c -> [c]) -> (d -> [d]) -> (a, b, c, d) -> [(a, b, c, d)]
tuple5 :: (a -> [a]) -> (b -> [b]) -> (c -> [c]) -> (d -> [d]) -> (e -> [e]) -> (a, b, c, d, e) -> [(a, b, c, d, e)]

module Data.Tree.Shrinkers
tree :: (a -> [a]) -> Tree a -> [Tree a]

module Data.Time.Shrinkers
day :: Day -> [Day]
diffTime :: DiffTime -> [DiffTime]
uTCTime :: UTCTime -> [UTCTime]

module Data.Time.Generators
day :: Gen Day
diffTime :: Gen DiffTime
uTCTime :: Gen UTCTime

module Data.Time.Coarbitrary
day :: Day -> Gen b -> Gen b
diffTime :: DiffTime -> Gen b -> Gen b
uTCTime :: UTCTime -> Gen b -> Gen b

module Data.Text.Shrinkers
text :: (Char -> [Char]) -> Text -> [Text]

module Data.Text.Generators
text :: Gen Char -> Gen Text

module Data.Text.Coarbitrary
text :: Text -> Gen b -> Gen b

module Data.Sequence.Shrinkers
seq :: (a -> [a]) -> Seq a -> [Seq a]

module Data.Sequence.Generators
seq :: Gen a -> Gen (Seq a)

module Data.Sequence.Coarbitrary
seq :: (a -> Gen b -> Gen b) -> Seq a -> Gen b -> Gen b

module Data.Monoid.Shrinkers
last :: (a -> [a]) -> Last a -> [Last a]
first :: (a -> [a]) -> First a -> [First a]

module Data.Monoid.Generators
last :: Gen a -> Gen (Last a)
first :: Gen a -> Gen (First a)

module Data.Monoid.Coarbitrary
last :: (a -> Gen b -> Gen b) -> Last a -> Gen b -> Gen b
first :: (a -> Gen b -> Gen b) -> First a -> Gen b -> Gen b

module Data.Map.Shrinkers
map :: Ord k => ((k, a) -> [(k, a)]) -> Map k a -> [Map k a]

module Data.Map.Generators
map :: Ord k => Gen [(k, a)] -> Gen (Map k a)

module Data.Map.Coarbitrary
map :: Ord k => ((k, a) -> Gen r -> Gen r) -> Map k a -> Gen r -> Gen r

module Barecheck.Util

-- | <a>variant</a> monomorphised to <a>Int</a>; eliminates type defaulting
--   compiler warnings.
varInt :: Int -> Gen b -> Gen b

module Prelude.Coarbitrary
maybe :: (a -> Gen b -> Gen b) -> Maybe a -> Gen b -> Gen b
either :: (a -> Gen c -> Gen c) -> (b -> Gen c -> Gen c) -> Either a b -> Gen c -> Gen c
list :: (a -> Gen b -> Gen b) -> [a] -> Gen b -> Gen b
tuple2 :: (a -> Gen r -> Gen r) -> (b -> Gen r -> Gen r) -> (a, b) -> Gen r -> Gen r
tuple3 :: (a -> Gen r -> Gen r) -> (b -> Gen r -> Gen r) -> (c -> Gen r -> Gen r) -> (a, b, c) -> Gen r -> Gen r
tuple4 :: (a -> Gen r -> Gen r) -> (b -> Gen r -> Gen r) -> (c -> Gen r -> Gen r) -> (d -> Gen r -> Gen r) -> (a, b, c, d) -> Gen r -> Gen r
tuple5 :: (a -> Gen r -> Gen r) -> (b -> Gen r -> Gen r) -> (c -> Gen r -> Gen r) -> (d -> Gen r -> Gen r) -> (e -> Gen r -> Gen r) -> (a, b, c, d, e) -> Gen r -> Gen r

module Data.Tree.Coarbitrary
tree :: (a -> Gen b -> Gen b) -> Tree a -> Gen b -> Gen b


-- | This module allows for the <a>promote</a> function to be imported
--   correctly from different QuickCheck versions. QuickCheck 2.6 used
--   Test.QuickCheck.Gen.promote; QuickCheck 2.7 uses
--   Test.QuickCheck.Gen.Unsafe.promote. For use with old versions of
--   QuickCheck, Cabal will import a different version of this module from
--   the oldQuickCheck directory.
module Barecheck.Promote

-- | Promotes a monadic generator to a generator of monadic values.
promote :: Monad m => m (Gen a) -> Gen (m a)


-- | Generators for <a>Prelude</a> types.
--   
--   This module also contains function generators, like <a>function1</a>
--   and <a>function2</a>. These generate random functions. To use these,
--   get a coarbitrary function from one of the modules whose name ends in
--   <tt>Coarbitrary</tt> or by using the QuickCheck <tt>coarbitrary</tt>
--   function, along with using a generator for the function's result type.
--   For example:
--   
--   <pre>
--   module MyModule where
--   
--   import Test.QuickCheck
--   import qualified Prelude.Generators as G
--   import qualified Data.Text.Coarbitrary as C
--   import qualified Data.Text.Generators as G
--   
--   genTextToMaybeText :: Gen (Text -&gt; Maybe Text)
--   genTextToMaybeText = function1 C.text (G.maybe (G.text arbitrary))
--   </pre>
module Prelude.Generators
maybe :: Gen a -> Gen (Maybe a)
either :: Gen a -> Gen b -> Gen (Either a b)
function1 :: (a -> Gen b -> Gen b) -> Gen b -> Gen (a -> b)
function2 :: (a -> Gen r -> Gen r) -> (b -> Gen r -> Gen r) -> Gen r -> Gen (a -> b -> r)
function3 :: (a -> Gen r -> Gen r) -> (b -> Gen r -> Gen r) -> (c -> Gen r -> Gen r) -> Gen r -> Gen (a -> b -> c -> r)
function4 :: (a -> Gen r -> Gen r) -> (b -> Gen r -> Gen r) -> (c -> Gen r -> Gen r) -> (d -> Gen r -> Gen r) -> Gen r -> Gen (a -> b -> c -> d -> r)
function5 :: (a -> Gen r -> Gen r) -> (b -> Gen r -> Gen r) -> (c -> Gen r -> Gen r) -> (d -> Gen r -> Gen r) -> (e -> Gen r -> Gen r) -> Gen r -> Gen (a -> b -> c -> d -> e -> r)
tuple2 :: Gen a -> Gen b -> Gen (a, b)
tuple3 :: Gen a -> Gen b -> Gen c -> Gen (a, b, c)
tuple4 :: Gen a -> Gen b -> Gen c -> Gen d -> Gen (a, b, c, d)
tuple5 :: Gen a -> Gen b -> Gen c -> Gen d -> Gen e -> Gen (a, b, c, d, e)
