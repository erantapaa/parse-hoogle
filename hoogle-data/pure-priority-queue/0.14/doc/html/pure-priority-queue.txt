-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A pure priority queue.
--   
--   A pure priority queue.
@package pure-priority-queue
@version 0.14


-- | This module exposes the internals of a pure priority queue,
--   implemented on top of <a>Data.Map</a>.
--   
--   Estimates of worst-case time complexity are given. The value <i>n</i>
--   is the number of elements in the queue. The value <i>p</i> is the
--   cardinality of the set of priorities of the elements in the queue.
--   <i>p</i> is never greater than <i>n</i>.
module Data.PurePriorityQueue.Internal

-- | A queue of values of type <tt>a</tt> with priority of type <tt>p</tt>.
newtype MinMaxQueue p a
MinMaxQueue :: Map p [a] -> MinMaxQueue p a
unMinMaxQueue :: MinMaxQueue p a -> Map p [a]

-- | <i>O(1)</i> An empty priority queue.
empty :: MinMaxQueue p a

-- | <i>O(1)</i> Test whether a priority queue is empty.
null :: MinMaxQueue p a -> Bool

-- | <i>O(1)</i> A priority queue with a single entry.
singleton :: (Ord p) => a -> p -> MinMaxQueue p a

-- | <i>O(log p)</i> Insert a value with given priority into a priority
--   queue.
insert :: (Ord p) => a -> p -> MinMaxQueue p a -> MinMaxQueue p a

-- | <i>O(log p)</i> Remove the value with the minimum priority from the
--   queue.
--   
--   If the queue is empty, <a>deleteMin</a> returns <a>empty</a>. Ties are
--   broken arbitrarily.
deleteMin :: (Ord p) => MinMaxQueue p a -> MinMaxQueue p a

-- | <i>O(log p)</i> Remove the value with the maximum priority from the
--   queue.
--   
--   If the queue is empty, <a>deleteMax</a> returns <a>empty</a>. Ties are
--   broken arbitrarily.
deleteMax :: (Ord p) => MinMaxQueue p a -> MinMaxQueue p a

-- | Applies a <tt>Data.Map.Map</tt> view function to a given priority
--   queue.
viewWith :: (Ord p) => (Map p [a] -> Maybe ((p, [a]), Map p [a])) -> MinMaxQueue p a -> Maybe ((a, p), MinMaxQueue p a)

-- | <i>O(log p)</i> View a priority queue to get the (value, priority)
--   pair with the lowest priority and the remainder of the queue.
--   
--   Ties are broken arbitrarily.
minView :: (Ord p) => MinMaxQueue p a -> Maybe ((a, p), MinMaxQueue p a)

-- | <i>O(log p)</i> View a priority queue to get the (value, priority)
--   pair with the highest priority and the remainder of the queue.
--   
--   Ties are broken arbitrarily.
maxView :: (Ord p) => MinMaxQueue p a -> Maybe ((a, p), MinMaxQueue p a)

-- | <i>O(log p)</i> Get the minimum priority of the elements in the queue.
minPriority :: (Ord p) => MinMaxQueue p a -> Maybe p

-- | <i>O(log p)</i> Get the maximum priority of the elements in the queue.
maxPriority :: (Ord p) => MinMaxQueue p a -> Maybe p

-- | <i>O(n)</i> Fold the priorities and values of a priority queue.
foldWithPriority :: (Ord p) => (p -> a -> b -> b) -> b -> MinMaxQueue p a -> b

-- | <i>O(log p)</i> Split a priority queue <tt>q</tt> into two queues
--   <tt>(q1, q2)</tt> by the given priority <tt>p</tt>, such that
--   <tt>q1</tt> contains exactly the entries with priority less than
--   <tt>p</tt>, and <tt>q2</tt> containes exactly the entries with
--   priority greater than or equal to <tt>p</tt>.
splitByPriority :: (Ord p) => p -> MinMaxQueue p a -> (MinMaxQueue p a, MinMaxQueue p a)

-- | <i>O(n)</i> The number of entries in a priority queue.
size :: (Ord p) => MinMaxQueue p a -> Int

-- | <i>O(n log p)</i> Filter all values that satisfy the predicate.
filter :: (Ord p) => (a -> Bool) -> MinMaxQueue p a -> MinMaxQueue p a

-- | <i>O(n log p)</i> Filter all entries that satisfy the predicate.
filterWithPriority :: (Ord p) => (a -> p -> Bool) -> MinMaxQueue p a -> MinMaxQueue p a

-- | <i>O(n)</i> Convert the priority queue into a list of (value,
--   priority) pairs in ascending priority.
--   
--   Ties are broken in an arbitrary manner.
toAscList :: (Ord p) => MinMaxQueue p a -> [(a, p)]
instance (Eq p, Eq a) => Eq (MinMaxQueue p a)
instance (Ord p, Ord a) => Ord (MinMaxQueue p a)
instance (Ord p) => Monoid (MinMaxQueue p a)
instance Foldable (MinMaxQueue p)
instance Functor (MinMaxQueue p)


-- | A pure priority queue.
--   
--   Because many function names clash with <a>Prelude</a> names, this
--   module is usually imported <tt>qualified</tt>, e.g.,
--   
--   <pre>
--   import qualified Data.PurePriorityQueue as PQ
--   </pre>
--   
--   This implementation is built on top of <a>Data.Map</a>.
--   
--   Estimates of worst-case time complexity are given. The value <i>n</i>
--   is the number of elements in the queue. The value <i>p</i> is the
--   cardinality of the set of priorities of the elements in the queue.
--   <i>p</i> is never greater than <i>n</i>.
module Data.PurePriorityQueue

-- | A queue of values of type <tt>a</tt> with priority of type <tt>p</tt>.
data MinMaxQueue p a

-- | <i>O(1)</i> An empty priority queue.
empty :: MinMaxQueue p a

-- | <i>O(1)</i> Test whether a priority queue is empty.
null :: MinMaxQueue p a -> Bool

-- | <i>O(1)</i> A priority queue with a single entry.
singleton :: (Ord p) => a -> p -> MinMaxQueue p a

-- | <i>O(log p)</i> Insert a value with given priority into a priority
--   queue.
insert :: (Ord p) => a -> p -> MinMaxQueue p a -> MinMaxQueue p a

-- | <i>O(log p)</i> Remove the value with the minimum priority from the
--   queue.
--   
--   If the queue is empty, <a>deleteMin</a> returns <a>empty</a>. Ties are
--   broken arbitrarily.
deleteMin :: (Ord p) => MinMaxQueue p a -> MinMaxQueue p a

-- | <i>O(log p)</i> Remove the value with the maximum priority from the
--   queue.
--   
--   If the queue is empty, <a>deleteMax</a> returns <a>empty</a>. Ties are
--   broken arbitrarily.
deleteMax :: (Ord p) => MinMaxQueue p a -> MinMaxQueue p a

-- | <i>O(log p)</i> View a priority queue to get the (value, priority)
--   pair with the lowest priority and the remainder of the queue.
--   
--   Ties are broken arbitrarily.
minView :: (Ord p) => MinMaxQueue p a -> Maybe ((a, p), MinMaxQueue p a)

-- | <i>O(log p)</i> View a priority queue to get the (value, priority)
--   pair with the highest priority and the remainder of the queue.
--   
--   Ties are broken arbitrarily.
maxView :: (Ord p) => MinMaxQueue p a -> Maybe ((a, p), MinMaxQueue p a)

-- | <i>O(log p)</i> Get the minimum priority of the elements in the queue.
minPriority :: (Ord p) => MinMaxQueue p a -> Maybe p

-- | <i>O(log p)</i> Get the maximum priority of the elements in the queue.
maxPriority :: (Ord p) => MinMaxQueue p a -> Maybe p

-- | <i>O(n)</i> Fold the priorities and values of a priority queue.
foldWithPriority :: (Ord p) => (p -> a -> b -> b) -> b -> MinMaxQueue p a -> b

-- | <i>O(log p)</i> Split a priority queue <tt>q</tt> into two queues
--   <tt>(q1, q2)</tt> by the given priority <tt>p</tt>, such that
--   <tt>q1</tt> contains exactly the entries with priority less than
--   <tt>p</tt>, and <tt>q2</tt> containes exactly the entries with
--   priority greater than or equal to <tt>p</tt>.
splitByPriority :: (Ord p) => p -> MinMaxQueue p a -> (MinMaxQueue p a, MinMaxQueue p a)

-- | <i>O(n)</i> The number of entries in a priority queue.
size :: (Ord p) => MinMaxQueue p a -> Int

-- | <i>O(n log p)</i> Filter all values that satisfy the predicate.
filter :: (Ord p) => (a -> Bool) -> MinMaxQueue p a -> MinMaxQueue p a

-- | <i>O(n log p)</i> Filter all entries that satisfy the predicate.
filterWithPriority :: (Ord p) => (a -> p -> Bool) -> MinMaxQueue p a -> MinMaxQueue p a

-- | <i>O(n)</i> Convert the priority queue into a list of (value,
--   priority) pairs in ascending priority.
--   
--   Ties are broken in an arbitrary manner.
toAscList :: (Ord p) => MinMaxQueue p a -> [(a, p)]
