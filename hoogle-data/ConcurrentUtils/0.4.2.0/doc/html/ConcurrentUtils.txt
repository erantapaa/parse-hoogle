-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Concurrent utilities
--   
@package ConcurrentUtils
@version 0.4.2.0


-- | Lists suitable for parallel execution (taken from Hackage's monad-par
--   package). (For converting to regular lists, there is the toList
--   function in Data.Foldable.)
module Control.CUtils.AList
data AList t
Append :: (AList t) -> (AList t) -> AList t
List :: [t] -> AList t

-- | Filters the AList using a predicate.
filterAList :: (b -> Bool) -> AList b -> AList b

-- | Folds the AList with a function, that must be associative. This allows
--   parallelism to be introduced.
assocFold :: (c -> c -> c) -> AList c -> c

-- | Combine monoid elements to get a result.
monoid :: (Monoid a, Eq a) => AList a -> a

-- | Length of an AList.
lenAList :: (Num a, Eq a1) => AList a1 -> a

-- | Find the first element satisfying a predicate.
findAList :: Eq a => (a -> Bool) -> AList a -> Maybe a

-- | Concatenate an AList of ALists.
concatAList :: Monad m => m (m b) -> m b
instance Eq t => Eq (AList t)
instance Ord t => Ord (AList t)
instance Show t => Show (AList t)
instance Foldable AList
instance Traversable AList
instance Functor AList
instance MonadPlus AList
instance Monad AList


-- | A lock-free channel (queue) data structure.
module Control.CUtils.Channel
data Channel a t

-- | Create a channel with a buffer at least as big as <tt>buffer</tt>.
newChannel :: MArray a t IO => Word32 -> IO (Channel a t)

-- | Write into the channel, blocking when the buffer is full.
writeChannel :: MArray a e IO => Channel a e -> e -> IO ()

-- | Read from the channel, blocking when the buffer is empty.
readChannel :: MArray t b IO => Channel t b -> IO b


-- | A module of concurrent higher order functions.
module Control.CUtils.Conc

-- | For exceptions caused by caller code.
data ExceptionList
ExceptionList :: [SomeException] -> ExceptionList

-- | For internal errors. If a procedure throws this, some threads it
--   created may still be running. It is thrown separately from
--   ExceptionList.
data ConcException
ConcException :: ConcException

-- | Runs an associative folding function on the given array. Note: this
--   function only spawns enough threads to make effective use of the
--   <i>capabilities</i>. Any two list elements may be processed
--   sequentially or concurrently. To get parallelism, you have to set the
--   numCapabilities value, e.g. using GHC's +RTS -N flag.
assocFold :: (b -> b -> IO b) -> (a -> b) -> b -> Array Int a -> IO b
concF_ :: ?seq :: Bool => Int -> (Int -> IO ()) -> IO ()
conc_ :: (?seq :: Bool) -> Array Int (IO ()) -> IO ()

-- | The next two functions take an implicit parameter ?seq. Set it to True
--   if you want to only spawn threads for the capabilities (same as
--   <i>assocFold</i>, good for speed). If you need all the actions to be
--   executed concurrently, set it to False.
--   
--   n is the number of computations which are indexed from 0 to n - 1.
concF :: ?seq :: Bool => Int -> (Int -> IO e) -> IO (Array Int e)

-- | Runs several computations concurrently, and returns their results as
--   an array. Waits for all threads to end before returning.
conc :: ?seq :: Bool => Array Int (IO e) -> IO (Array Int e)

-- | Version of concF specialized for two computations.
concP :: IO t -> IO t1 -> IO (t, t1)
oneOfF :: Int -> (Int -> IO a) -> IO a

-- | Runs several computations in parallel, and returns one of their
--   results (terminating the other computations).
oneOf :: Array Int (IO a) -> IO a
instance Typeable ExceptionList
instance Typeable ConcException
instance Show ExceptionList
instance Show ConcException
instance Exception ConcException
instance Exception ExceptionList


-- | An implementation of nested data parallelism
module Control.CUtils.DataParallel

-- | The array interface
data ArrC t
ArrC :: !(Array Int t) -> !(Forest Int) -> ArrC t

-- | Inject a basic array into the ArrC type.
inject :: Array Int e -> ArrC e

-- | Get a basic array out.
project :: ArrC t -> Array Int t

-- | Convenience for making an array from a list.
newArray :: [e] -> Array Int e
mirror :: Either a a1 -> Either a1 a
pairUp :: [b] -> [(b, b)]

-- | Programs involving these array operations are optimized by a set of
--   rules when GHC's -O option is set. Use +RTS -N to get parallelism.
mp :: (t -> t1) -> ArrC t -> ArrC t1
count :: Int -> ArrC Int
index :: ArrC e -> Int -> e
zip :: ArrC t -> ArrC t1 -> ArrC (t, t1)
concat :: ArrC (ArrC t) -> ArrC t

-- | Associative fold
fold :: (a -> a -> a) -> (a1 -> a) -> a -> ArrC a1 -> a

-- | Control.Arrow substitutes
first :: (t -> t1) -> (t, t2) -> (t1, t2)
second :: (t -> t2) -> (t1, t) -> (t1, t2)
left :: (a -> b) -> Either a b1 -> Either b b1
right :: (b -> b1) -> Either a b -> Either a b1
and :: (t2 -> t) -> (t2 -> t1) -> t2 -> (t, t1)

-- | Internals
__pack :: ArrC (ArrC t) -> ArrC t
__unpack :: ArrC t -> ArrC (ArrC t)
__packProd :: (a, b) -> ArrC (Either a b)
__unpackProd :: ArrC (Either t t1) -> (t, t1)
__packSum1 :: Either a (ArrC b) -> ArrC (Either a b)
__unpackSum1 :: ArrC (Either a b) -> Either a (ArrC b)
__packSum2 :: Either (ArrC a1) a -> ArrC (Either a1 a)
__unpackSum2 :: ArrC (Either b a) -> Either (ArrC b) a


-- | Automatic deadlock prevention.
--   
--   Automatic deadlock detection is inefficient, and computations cannot
--   be rolled back or aborted in general.
--   
--   Instead, I prevent deadlocks before they happen.
module Control.CUtils.Deadlock

-- | The typical sequence that produces a deadlock is as follows:
--   
--   <ol>
--   <li>Thread 1 acquires lock A</li>
--   <li>Thread 2 acquires lock B</li>
--   <li>Thread 1 tries to acquire B</li>
--   <li>Thread 2 tries to acquire A</li>
--   </ol>
--   
--   Deadlock.
--   
--   Standard deadlock detection intervenes after (4) has occurred. I
--   intervene in a lock acquisition that is followed by an unsafe schedule
--   (here at (2)). I suspend thread 2 until a safe schedule is guaranteed
--   -- in this case until thread 1 relinquishes lock A.
--   
--   The Res arrow.
--   
--   Computations are built with these constructors (and the arrow
--   interface). Pieces of the arrow that hold locks have to be finitely
--   examinable, Locks have to be used with the Acq and Rel constructors.
data Res t u
Lift :: Kleisli IO t v -> Res v u -> Res t u
Acq :: MVar () -> Res t u -> Res t u
Rel :: MVar () -> Res t u -> Res t u
Fork :: Res t () -> Res t u -> Res t u
Plus :: Res t v -> Res u v -> Res (Either t u) v
Id :: Res t t

-- | Use this to run computations built in the Res arrow.
run :: Res t u -> t -> IO u
lft :: IO a -> Res v u -> Res v u
instance ArrowChoice Res
instance Arrow Res
instance Category Res


-- | A channel module with transparent network communication.
module Control.CUtils.NetChan
data NetSend t
data NetRecv t
localHost :: IO [Char]

-- | Creates a new channel, with receive and send ends.
newNetChan :: Binary t => IO (NetRecv t, NetSend t)

-- | Open a channel to another host
newNetSend :: HostName -> IO (NetSend t)

-- | Creates a receive end of this host's channel. Type unsafe!
newNetRecv :: Binary t => IO (NetRecv t)

-- | Sends something on a channel.
send :: Binary t => NetSend t -> t -> IO ()
receive :: NetRecv t -> IO ByteString

-- | Receives something from a channel.
recv :: Binary t => NetRecv t -> IO t

-- | Receives the send end of a channel, on a channel.
recvSend :: NetRecv (NetSend t) -> IO (NetSend t)

-- | Sends the receive end of a channel, on a channel.
sendRecv :: NetSend (NetRecv t) -> NetRecv t -> IO ()

-- | Receives the receive end of a channel, on a channel.
recvRecv :: Binary t => NetRecv (NetRecv t) -> IO (NetRecv t)
activateSend :: NetSend t -> IO (NetSend t)
activateRecv :: Binary t => NetRecv t -> IO (NetRecv t)
data Auth t

-- | Remote exercise of authority. Commands are transmitted in the clear,
--   but authenticated.
--   
--   auth - The authority to be served (runs on a separate thread).
--   
--   r - The receive end from the host.
--   
--   s - The send end to the host.
--   
--   publicKey - The public key of the intended recipient.
authServer :: Binary t => (t -> IO ()) -> NetRecv (Auth t) -> NetSend ByteString -> PublicKey -> IO ()

-- | privateKey - The private key for this host.
--   
--   Returns a function that can be used to send messages.
authClient :: Binary t => NetRecv ByteString -> NetSend (Auth t) -> PrivateKey -> IO (t -> IO ())
example :: IO ()
instance CryptoRandomGen EntropyPool
instance Binary (Auth t)
instance Binary (NetRecv t)
instance Binary (NetSend t)
instance Eq (NetRecv t)
instance Eq (NetSend t)
instance Eq ChannelFibre


-- | Functional channels | A channel data type which allows consumers to
--   hold references to different points in a stream at the same time.
--   Elements of a channel are kept alive only so long as there are
--   references pointing before those elements. And producers on a channel
--   are kept alive only so long as there are consumers.
module Control.CUtils.FChan
data Chan t

-- | Thrown by the writer function when the garbage collector detects that
--   no one will read it.
data DoneReadingException
DoneReadingException :: DoneReadingException

-- | Take the first element from a channel, and a channel representing the
--   remainder of the output.
takeChan :: Chan t -> IO (t, Chan t)

-- | Create a new channel. The first return value is a function that can be
--   used to add values to the channel. The second return value is the
--   channel itself.
newChan :: IO (t -> IO (), Chan t)

-- | The first return value is a thunk that returns values from the channel
--   successively, starting from the position of the parameter channel. The
--   second thunk can be used to retrieve the position of the channel after
--   all the reads made using the first thunk.
makeConsumer :: Chan b -> IO (IO b, IO (Chan b))
instance Typeable DoneReadingException
instance Show DoneReadingException
instance Exception DoneReadingException


-- | An implementation of communicating sequential processes.
module Control.CUtils.Processes

-- | The CSP data type:
--   
--   :|| - interleave
--   
--   :? - deterministic choice
--   
--   Join - interface parallel
--   
--   :-&gt; - prefix
--   
--   Stop - empty computation
--   
--   Do - execute IO, then behave as the returned process
data CSP
(:||) :: CSP -> CSP -> CSP
(:?) :: CSP -> CSP -> CSP
Join :: CSP -> [String] -> CSP -> CSP
(:->) :: String -> CSP -> CSP
Stop :: CSP
Do :: (IO CSP) -> CSP
runCSP0 :: (String -> IO (), Chan String) -> [(MVar Side, String, Side)] -> CSP -> IO ()

-- | Run a CSP computation.
runCSP :: CSP -> IO ()
instance Show CSP
instance Eq Side
instance Show (IO t)
