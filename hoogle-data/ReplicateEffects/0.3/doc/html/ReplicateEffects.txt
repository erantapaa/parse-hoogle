-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Composable replication schemes of applicative functors
--   
--   Composable replication schemes of applicative functors
@package ReplicateEffects
@version 0.3


-- | Composable replication schemes of applicative actions.
--   
--   This module separates common combinators such as <tt>some</tt> and
--   <tt>many</tt> (from <tt>Control.Applicative</tt>) from any actual
--   applicative actions. It offers composable building blocks for
--   expressing the number (or numbers) of times an action should be
--   executed. The building blocks themselves are composed using the
--   standard <a>Applicative</a>, <a>Alternative</a> and <a>Category</a>
--   combinators. Replication schemes can then be run with <a>*!</a> and
--   <a>*?</a> to produce actual actions.
--   
--   Some examples help see how this works. One of the simplest schemes is
--   <a>one</a>:
--   
--   <pre>
--   one :: Replicate a a
--   </pre>
--   
--   <tt>one *! p</tt> is equivalent to just <tt>p</tt>.
--   
--   Schemes can be summed by composing them in applicative fashion. In the
--   following example, the resulting tuple type makes it clear that the
--   action has been run twice and no information is lost:
--   
--   <pre>
--   two :: Replicate a (a, a)
--   two = (,) &lt;$&gt; one &lt;*&gt; one
--   </pre>
--   
--   <tt>two *! p</tt> is equivalent to <tt>(,) &lt;$&gt; p &lt;*&gt;
--   p</tt>.
--   
--   Things get more interesting if we use the choice combinator
--   <tt>&lt;|&gt;</tt> to form the union of two schemes.
--   
--   <pre>
--   oneOrTwo :: Replicate a (Either a (a, a))
--   oneOrTwo = Left &lt;$&gt; one &lt;|&gt; Right &lt;$&gt; two
--   </pre>
--   
--   Running schemes that allow multiple frequencies expand to actions that
--   always use <tt>&lt;|&gt;</tt> as late as possible. Since
--   <tt>oneOrTwo</tt> runs an action at least once, we can start by
--   running the action once immediately and only then choose whether we
--   want to stop there or run it a second time. Running it with <a>*!</a>
--   expands to:
--   
--   <pre>
--   \p -&gt; p &lt;**&gt;  (  -- Either run the action again and yield Right ... 
--                    (\y x -&gt; Right (x, y)) &lt;$&gt; p
--                &lt;|&gt; -- ... or stop here and yield Left.
--                    pure Left
--                 )
--   </pre>
--   
--   Replication schemes can be thought of as sets of Peano numerals. If
--   there is overlap between the two operands to <tt>&lt;|&gt;</tt>, the
--   overlap collapses and is lost in the result. For example,
--   <tt><a>between</a> 3 5 &lt;|&gt; between 4 6</tt> is equivalent to
--   <tt>between 3 6</tt>, a scheme that runs an action 3, 4, 5 or 6 times.
--   
--   The example above made the second <tt>p</tt> the first choice and the
--   <tt>pure</tt> option the second choice to <tt>&lt;|&gt;</tt>. In some
--   cases the other way around is preferred. This is what <a>*?</a> is
--   for; it prefers running an action fewer times over more times. Running
--   <tt>oneOrTwo</tt> with it is equivalent to:
--   
--   <pre>
--   \p -&gt; p &lt;**&gt;  (  -- Either stop here and yield Left ...
--                    pure Left
--                &lt;|&gt; -- ... or run the action again and yield Right.
--                    (\y x -&gt; Right (x, y)) &lt;$&gt; p
--                 )
--   </pre>
--   
--   Finally, schemes can be multiplied by composing them with the dot
--   operator <a>.</a> from <tt>Control.Category</tt>.
--   
--   <pre>
--   twiceThree :: Replicate a ((a, a, a), (a, a, a))
--   twiceThree = two . three
--   
--   thriceTwo :: Replicate a ((a, a), (a, a), (a, a))
--   thriceTwo = three . two
--   </pre>
--   
--   If <tt>.</tt>'s operands allow multiple frequencies, the result will
--   allow the products of all pairs of frequencies from the operands. We
--   can use this to e.g. produce all even numbers of occurrences:
--   
--   <pre>
--   even :: Replicate a [(a, a)]
--   even = many . two
--   </pre>
--   
--   In this example <tt>many</tt> behaves like the standard Applicative
--   <tt>many</tt>, allowing an action to be run any number of {0, 1, ..}
--   times.
module Control.Replicate

-- | A set of frequencies which with an applicative action is allowed to
--   occur. <tt>a</tt> is the result type of a single atomic action.
--   <tt>b</tt> is the composite result type after executing the action a
--   number of times allowed by this set.
data Replicate a b
Nil :: Replicate a b
Cons :: (c -> b) -> Maybe c -> Replicate a (a -> c) -> Replicate a b

-- | Run an action a certain number of times, using <a>&lt;|&gt;</a> to
--   branch (at the deepest point possible) if multiple frequencies are
--   allowed. Use greedy choices: always make the longer alternative the
--   left operand of <tt>&lt;|&gt;</tt>.
(*!) :: Alternative f => Replicate a b -> f a -> f b

-- | Run an action a certain number of times, using <a>&lt;|&gt;</a> to
--   branch (at the deepest point possible) if multiple frequencies are
--   allowed. Use lazy choices: always make the <a>pure</a> alternative the
--   left operand of <tt>&lt;|&gt;</tt>.
(*?) :: Alternative f => Replicate a b -> f a -> f b

-- | Enumerate all the numbers of allowed occurrences encoded by the
--   replication scheme.
sizes :: Replicate a b -> [Int]

-- | Perform an action exactly zero times.
zero :: b -> Replicate a b

-- | Perform an action exactly one time.
one :: Replicate a a

-- | Perform an action exactly two times.
two :: Replicate a (a, a)

-- | Perform an action exactly three times.
three :: Replicate a (a, a, a)

-- | Perform an action zero or one times.
opt :: Replicate a (Maybe a)

-- | Perform an action zero or more times.
many :: Replicate a [a]

-- | Perform an action one or more times.
some :: Replicate a [a]

-- | Perform an action exactly so many times.
exactly :: Int -> Replicate a [a]

-- | Perform an action at least so many times.
atLeast :: Int -> Replicate a [a]

-- | Perform an action at most so many times.
atMost :: Int -> Replicate a [a]

-- | Allow an action to be performed between so and so many times
--   (inclusive).
between :: Int -> Int -> Replicate a [a]

-- | Repeat an action forever.
forever :: Replicate a b
instance ArrowPlus Replicate
instance ArrowZero Replicate
instance Arrow Replicate
instance Category Replicate
instance Monoid (Replicate a b)
instance Alternative (Replicate a)
instance Applicative (Replicate a)
instance Functor (Replicate a)
