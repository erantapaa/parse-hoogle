-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Put-based lens library
--   
@package putlenses
@version 0.1.3


-- | Generic sums of products representation for algebraic data types
module GHC.InOut
class (Generic a, ToFromRep (Rep a)) => InOut a
inn :: InOut a => F a -> a
out :: InOut a => a -> F a
type F a = Flatten (Rep a)
class ToFromRep (f :: * -> *)
fromRep :: ToFromRep f => f x -> Flatten f
toRep :: ToFromRep f => Flatten f -> f x
instance (Generic a, ToFromRep (Rep a)) => InOut a
instance (ToFromRep f, ToFromRep g) => ToFromRep (f :*: g)
instance (ToFromRep f, ToFromRep g) => ToFromRep (f :+: g)
instance ToFromRep f => ToFromRep (M1 i c f)
instance ToFromRep (K1 i c)
instance ToFromRep U1


-- | General framework for put-based lenses.
module Generics.Putlenses.Putlens
newtype GetPut
GetPut :: Bool -> GetPut
newtype PutGet
PutGet :: Bool -> PutGet
testGetPut :: GetPut -> Bool
testPutGet :: PutGet -> Bool

-- | Interface for normal lenses
data LensM m s v
LensM :: (s -> v) -> (s -> v -> m s) -> (v -> m s) -> LensM m s v
get :: LensM m s v -> s -> v
put :: LensM m s v -> s -> v -> m s
create :: LensM m s v -> v -> m s

-- | Interface for lenses without monadic effects
type Lens s v = LensM Identity s v

-- | Non-monadic <tt>put</tt> function
simpleput :: Lens s v -> (s -> v -> s)

-- | Non-monadic <tt>create</tt> function
simplecreate :: Lens s v -> (v -> s)

-- | Monad for put-based lenses includes an environment, state, and boolean
--   tags that our system will use to ensure GetPut and PutGet
type PutM m a = ReaderT GetPut (WriterT PutGet m) a
type Get s v = s -> Maybe v
type Put m s v = Maybe s -> v -> PutM m s
type Create m s v = v -> PutM m s

-- | Framework for put-based lenses
data PutlensM m s v
PutlensM :: (s -> (Maybe v, Create m s v)) -> Create m s v -> PutlensM m s v
getputM :: PutlensM m s v -> s -> (Maybe v, Create m s v)
createM :: PutlensM m s v -> Create m s v
type PutlensMaybeM m s v = PutlensM (MaybeT m) s v
type PutlensReaderM m e s v = PutlensM (ReaderT e m) s v
type PutlensStateM m st s v = PutlensM (StateT st m) s v
type Putlens s v = PutlensM Identity s v

-- | Changes the resulting monad of a put computation
mapPutM' :: (Monad m, Monad n) => (m a -> n b) -> (forall c. m c -> n c) -> PutM m a -> PutM n b
mapPutM :: (forall a. m a -> n a) -> PutM m a -> PutM n a

-- | Changes the resulting monad of a putlens
mapPutlensM :: Monad m => (forall a. m a -> n a) -> PutlensM m s v -> PutlensM n s v

-- | Lifts a function on a given monad to a put computation
liftPutM :: Monad m => m s -> PutM m s

-- | Function <tt>lift</tt> applied to the monadic argument of a putlens
liftPutlensM :: (MonadTrans t, Monad m) => PutlensM m s v -> PutlensM (t m) s v

-- | Forward |get| function
getM :: PutlensM m s v -> Get s v

-- | Domain of a putlens (the domains of its get function)
dom :: PutlensM m s v -> (s -> Bool)

-- | Backward |put| function
putM :: PutlensM m s v -> Put m s v

-- | Runs a putlens for a particular environment
evalPutM :: Monad m => PutM m s -> GetPut -> m s
runPutM :: Monad m => PutM m s -> GetPut -> m (s, PutGet)

-- | Converts a normal lens to a putlens (without explicit failure)
lens2put :: Monad m => LensM m s v -> PutlensM m s v

-- | Converts a simple lens of the Haskell lens package into a putlens
simplelens2put :: Monad m => Lens' s v -> PutlensM m s v

-- | Converts a putlens to a normal lens, enforcing well-behavedness
put2lens :: Eq v => Putlens s v -> Lens s v

-- | Converts a putlens to a normal lens but without enforcing PutGet (for
--   unsafe casts)
put2quicklens :: Eq v => Putlens s v -> Lens s v

-- | Converts a putlens to a normal lens, without enforcing GetPut
put2quicklensNoGetPut :: Eq v => Putlens s v -> Lens s v

-- | Converts a putlens to a normal lens, without enforcing GetPut
put2lensNoGetPut :: Eq v => Putlens s v -> Lens s v

-- | Converts a monadic putlens to a monadic lens, enforcing
--   well-behavedness
put2lensM :: (Monad m, Eq v) => PutlensM m s v -> LensM m s v

-- | Converts a monadic putlens to a monadic lens but without enforcing
--   PutGet (for unsafe casts)
put2quicklensM :: (Monad m, Eq v) => PutlensM m s v -> LensM m s v

-- | Converts a monadic putlens to a monadic lens, without enforcing GetPut
put2lensNoGetPutM :: (Monad m, Eq v) => PutlensM m s v -> LensM m s v

-- | Converts a monadic putlens to a monadic lens, without enforcing GetPut
put2quicklensNoGetPutM :: (Monad m, Eq v) => PutlensM m s v -> LensM m s v

-- | Converts a putlens to a normal lens with a parameter telling to ensure
--   well-behavedness or not (for unsafe casts) Initializes the environment
--   as the original source, the state as empty, the GetPut tag as True and
--   the PutGet tag as False
put2lensM' :: (Monad m, Eq v) => Bool -> Bool -> PutlensM m s v -> LensM m s v

-- | The get function of a putlens
get' :: Eq v => PutlensM m s v -> (s -> v)
put' :: (Monad m, Eq v) => Bool -> Bool -> PutlensM m s v -> (s -> v -> m s)

-- | The tupled get/put function of a putlens (with PutGet and GetPut
--   flags)
getput' :: (Monad m, Eq v) => Bool -> Bool -> PutlensM m s v -> (s -> (v, v -> m s))

-- | The create function of a putlens (with PutGet flag)
create' :: (Monad m, Eq v) => Bool -> PutlensM m s v -> (v -> m s)

-- | Converts a putlens into another putlens that only uses the create
--   function
put2create :: (Monad m, Eq v) => PutlensM m s v -> PutlensM m s v
checkGetPut :: (Monad m, Eq v) => PutlensM m s v -> PutlensM m s v
checkPutGet :: Monad m => PutlensM m s v -> PutlensM m s v
offGetPut :: Monad m => PutM m s -> PutM m s
onPutGet :: Monad m => PutM m s -> PutM m s
instance Monoid PutGet


-- | Core language of put-based lenses.
module Generics.Putlenses.Language

-- | Runs an inner monad <tt>n</tt> inside a putlens with monad <tt>m</tt>
withMonadPut :: (Monad m, Monad n) => (forall a. Maybe s -> v -> n a -> m a) -> PutlensM n s v -> PutlensM m s v

-- | Runs an inner monad <tt>n</tt> inside a putlens with monad <tt>m</tt>
--   (using also the original view)
withMonadPut' :: (Monad m, Monad n) => (forall a. Maybe s -> Maybe v -> v -> n a -> m a) -> PutlensM n s v -> PutlensM m s v

-- | Applies some monadic modification (like changing a state) to a putlens
effectPut :: Monad m => (Maybe s -> v -> m ()) -> PutlensM m s v -> PutlensM m s v

-- | Converts a putlens with explicitly partial put functions into a normal
--   putlens
runMaybePut :: Monad m => PutlensMaybeM m s v -> PutlensM m s v

-- | Initializes the monad with a new state
runStatePut :: Monad m => (Maybe s -> v -> m st) -> PutlensStateM m st s v -> PutlensM m s v

-- | Ignores the current state and initializes a new state monad with a new
--   state
resetStatePut :: Monad m => (Maybe s -> v -> st -> m st') -> PutlensStateM m st' s v -> PutlensStateM m st s v

-- | Modifies the state before executing put
withStatePut :: MonadState st m => (Maybe s -> v -> st -> m st) -> PutlensM m s v -> PutlensM m s v
withStateTPut :: Monad m => (Maybe s -> v -> st -> m st) -> PutlensStateM m st s v -> PutlensStateM m st s v

-- | Modifies the state after executing put
updateStatePut :: MonadState st m => (Maybe s -> s -> st -> m st) -> PutlensM m s v -> PutlensM m s v
updateStateTPut :: Monad m => (Maybe s -> s -> st -> m st) -> PutlensStateM m st s v -> PutlensStateM m st s v
runReaderPut :: Monad m => (Maybe s -> v -> m e) -> PutlensReaderM m e s v -> PutlensM m s v
runReaderPutS :: Monad m => PutlensReaderM m s s v -> PutlensM m s v
runReaderPutMbS :: Monad m => PutlensReaderM m (Maybe s) s v -> PutlensM m s v
runReaderPutV :: Monad m => PutlensReaderM m v s v -> PutlensM m s v
runReaderPutMbV :: Monad m => PutlensReaderM m (Maybe v) s v -> PutlensM m s v
runReaderPutV' :: Monad m => PutlensReaderM m v s v -> PutlensM m s v
withReaderPut :: Monad m => (Maybe s -> v -> e -> m e') -> PutlensReaderM m e' s v -> PutlensReaderM m e s v
withReaderPut' :: Monad m => (Maybe s -> Maybe v -> v -> e -> m e') -> PutlensReaderM m e' s v -> PutlensReaderM m e s v
localPut :: MonadReader e m => (Maybe s -> v -> e -> e) -> PutlensM m s v -> PutlensM m s v
withS :: Monad m => PutlensReaderM m s s v -> PutlensReaderM m e s v
withMbS :: Monad m => PutlensReaderM m (Maybe s) s v -> PutlensReaderM m e s v
withV :: Monad m => PutlensReaderM m v s v -> PutlensReaderM m e s v
withMbV :: Monad m => PutlensReaderM m (Maybe v) s v -> PutlensReaderM m e s v
withV' :: Monad m => PutlensReaderM m v s v -> PutlensReaderM m e s v

-- | Modifies the original source before executing put (unsafe cast)
modifyS :: (Monad m, Eq v) => (Maybe s -> v -> m (Maybe s)) -> PutlensM m s v -> PutlensM m s v

-- | Modifies the updated view before executing put (unsafe cast)
modifyV' :: Monad m => (Maybe s -> v -> m v) -> PutlensM m s v -> PutlensM m s v

-- | Modifies the updated source after executing put (unsafe cast)
updateS' :: Monad m => (Maybe s -> s -> m s) -> PutlensM m s v -> PutlensM m s v

-- | Unfork putlens that applies two putlenses to distinct sides of a view
--   pair, producing the same source (unsafe) ^ Dualizes forward splitting
--   and induces a source-passing style
unforkPut :: (Monad m, Eq v1, Eq v2) => PutlensM m s v1 -> PutlensM m s v2 -> PutlensM m s (v1, v2)

-- | Identity putlens
idPut :: Monad m => PutlensM m v v

-- | Binary composition of putlenses
(.<) :: Monad m => PutlensM m s u -> PutlensM m u v -> PutlensM m s v

-- | View-based filtering putlens
phiPut :: Monad m => (v -> Bool) -> PutlensM m v v

-- | Like phiPut p .&lt; l, but with a less restricted put function that
--   uses the original source even when it does not satisfy <tt>p</tt>
phiSourcePut :: Monad m => (s -> Bool) -> PutlensM m s v -> PutlensM m s v

-- | Bottom putlens that is always undefined
botPut :: Monad m => PutlensM m a b

-- | Adds a value to the left of the view (according to a user-specified
--   function)
addfstPut :: (Monad m, Eq v) => (Maybe (s1, v) -> v -> m s1) -> PutlensM m (s1, v) v
addfstPutUnsafe :: Monad m => (Maybe (s1, v) -> v -> m s1) -> PutlensM m (s1, v) v

-- | Adds a value to the right of the view (according to a user-specified
--   function)
addsndPut :: (Monad m, Eq v) => (Maybe (v, s2) -> v -> m s2) -> PutlensM m (v, s2) v
addsndPutUnsafe :: Monad m => (Maybe (v, s2) -> v -> m s2) -> PutlensM m (v, s2) v

-- | Duplicates a view by enforcing the two sources to be the same
dupPut :: (Monad m, Eq v) => PutlensM m (v, v) v

-- | Duplicates a view but not enforcing the two sources to be the same
mergePut :: (Monad m, Eq v) => PutlensM m (v, v) v

-- | Adds a value to the left of the view (retrieving it from the original
--   source)
keepfstPut :: Monad m => PutlensM m (s1, v) v

-- | Adds a value to the right of the view (retrieving it from the original
--   source)
keepsndPut :: Monad m => PutlensM m (v, s2) v

-- | Adds a value to the left of the view (retrieving it from the original
--   source or otherwise using a user-specified function) GetPut is always
--   satisfied
keepfstOrPut :: Monad m => (v -> m s1) -> PutlensM m (s1, v) v

-- | Adds a value to the right of the view (retrieving it from the original
--   source or otherwise using a user-specified function) GetPut is always
--   satisfied
keepsndOrPut :: Monad m => (v -> m s2) -> PutlensM m (v, s2) v

-- | Deletes the left value of a view pair (taking a user-specified
--   function that instructs how it can be restored)
remfstPut :: (Monad m, Eq v1) => (v -> v1) -> PutlensM m v (v1, v)

-- | Deletes the right value of a view pair (taking a user-specified
--   function that instructs how it can be restored)
remsndPut :: (Monad m, Eq v2) => (v -> v2) -> PutlensM m v (v, v2)

-- | Product putlens that applies two putlenses to distinct sides of a view
--   pair, producing a source pair
(><<) :: Monad m => PutlensM m s1 v1 -> PutlensM m s2 v2 -> PutlensM m (s1, s2) (v1, v2)

-- | Product putlens that applies two putlenses to distinct sides of a view
--   pair, producing a source pair. | Turns off/on GetPut checking for
--   maximum expressivity.
(><<<) :: (Monad m, Eq v1, Eq v2) => PutlensM m s1 v1 -> PutlensM m s2 v2 -> PutlensM m (s1, s2) (v1, v2)

-- | Deletes a user-specified view
ignorePut :: (Monad m, Eq v) => v -> PutlensM m () v

-- | Creates a constant source from an empty view
newPut :: Monad m => s -> PutlensM m s ()

-- | Adds a new source (retrieving the original source)
keepPut :: Monad m => PutlensM m s ()
keepOrPut :: Monad m => m s -> PutlensM m s ()

-- | Creates a source from an empty view (according to a user-specified
--   function)
pntPut :: Monad m => (Maybe a -> m a) -> PutlensM m a ()

-- | Adds an empty view to the left of the view
addfstOnePut :: Monad m => PutlensM m ((), v) v

-- | Adds an empty view to the right of the view
addsndOnePut :: Monad m => PutlensM m (v, ()) v

-- | Deletes an empty view to the left of the view
remfstOnePut :: Monad m => PutlensM m a ((), a)

-- | Deletes an empty view to the left of the view
remsndOnePut :: Monad m => PutlensM m a (a, ())

-- | Injects a tag in the view (according to a user-specified predicate)
injPut :: (Monad m, Eq v) => (Maybe (Either v v) -> v -> m Bool) -> PutlensM m (Either v v) v
injPutUnsafe :: Monad m => (Maybe (Either v v) -> v -> m Bool) -> PutlensM m (Either v v) v

-- | Injects a tag in the view (according to the tags of the original
--   source)
injsOrPut :: Monad m => (v -> m Bool) -> PutlensM m (Either v v) v

-- | Injects a tag in the view (according to the tags of the original
--   source) with a left default for create
injlsPut :: Monad m => PutlensM m (Either v v) v

-- | Injects a tag in the view (according to the tags of the original
--   source) with a right default for create
injrsPut :: Monad m => PutlensM m (Either v v) v

-- | Injects a tag in the view according to the tags of the original source
--   or giving preference to the first lens when both are applicable.
--   Requires the monad to be an instance of <tt>MonadPlus</tt> to recover
--   from failure.
injunionPut :: (Eq v, MonadPlus m) => PutlensM m s1 v -> PutlensM m s2 v -> PutlensM m (Either s1 s2) v
injunionPutUnsafe :: MonadPlus m => PutlensM m s1 v -> PutlensM m s2 v -> PutlensM m (Either s1 s2) v

-- | Ignores the tags in the view ^ Fails whenever the domains of <tt>getM
--   f</tt> and <tt>getM g</tt> are not disjoint
(\/<) :: Monad m => PutlensM m s v1 -> PutlensM m s v2 -> PutlensM m s (Either v1 v2)
eitherPutUnsafe :: Monad m => PutlensM m s v1 -> PutlensM m s v2 -> PutlensM m s (Either v1 v2)

-- | Ignores the tags in the view (guaranteeing disjointness according to a
--   predicate on sources)
eitherSPut :: Monad m => (s -> Bool) -> PutlensM m s v1 -> PutlensM m s v2 -> PutlensM m s (Either v1 v2)

-- | Ignores the tags in the view (left-biased) ^ Guarantees disjointness
--   by favoring the left putlens
(.\/<) :: Monad m => PutlensM m s v1 -> PutlensM m s v2 -> PutlensM m s (Either v1 v2)

-- | Ignores the tags in the view (right-biased) ^ Guarantees disjointness
--   by favoring the right putlens
(\/.<) :: Monad m => PutlensM m s v1 -> PutlensM m s v2 -> PutlensM m s (Either v1 v2)

-- | Sum putlens that applies two putlenses to distinct sides of a view
--   sum, producing a view sum
(-|-<) :: Monad m => PutlensM m s1 v1 -> PutlensM m s2 v2 -> PutlensM m (Either s1 s2) (Either v1 v2)

-- | Injects a left tag in the view
injlPut :: Monad m => PutlensM m (Either v v2) v

-- | Injects a right tag in the view
injrPut :: Monad m => PutlensM m (Either v1 v) v

-- | Ignores left tags for left-tagged views
uninjlPut :: Monad m => PutlensM m v (Either v v2)

-- | Ignores left tags for left-tagged views
uninjrPut :: Monad m => PutlensM m v (Either v1 v)

-- | Conditional putlens combinator
ifthenelsePut :: (Monad m, Eq v) => (Maybe s -> v -> m Bool) -> PutlensM m s v -> PutlensM m s v -> PutlensM m s v

-- | Conditional putlens combinator (with a predicate on views)
ifVthenelsePut :: Monad m => (v -> Bool) -> PutlensM m s v -> PutlensM m s v -> PutlensM m s v

-- | Conditional putlens combinator (with a predicate on sources)
ifSthenelsePut :: (Monad m, Eq v) => (s -> Bool) -> PutlensM m s v -> PutlensM m s v -> PutlensM m s v

-- | Special if-then-else combinator for two putlenses with the same get
--   function ^ Given the invariant |getM f = getM g|, there are no
--   restrictions regarding branching behavior
ifKthenelsePut :: (Monad m, Eq v) => (Maybe s -> v -> m Bool) -> PutlensM m s v -> PutlensM m s v -> PutlensM m s v

-- | Union of two putlenses (requires the monad to be an instance of
--   <tt>MonadPlus</tt> to be able to recover from failure)
unionPut :: (Eq v, MonadPlus m) => PutlensM m s v -> PutlensM m s v -> PutlensM m s v

-- | Union of two putlenses (without well-behavedness checks)
unionPutUnsafe :: MonadPlus m => PutlensM m s v -> PutlensM m s v -> PutlensM m s v

-- | Embed user-specified lenses as putlenses
customPut :: (Monad m, Eq v) => (Maybe s -> v -> m s) -> (s -> v) -> PutlensM m s v

-- | Putlens from a sums-of-products view to an algebraic data type source
innPut :: (Monad m, InOut a) => PutlensM m a (F a)

-- | Putlens from an algebraic data type view to a sums-of-products source
outPut :: (Monad m, InOut a) => PutlensM m (F a) a

-- | Swaps the order of elements in a view pair
swapPut :: Monad m => PutlensM m (b, a) (a, b)

-- | Associates a right-nested view pair to the left
assoclPut :: Monad m => PutlensM m ((a, b), c) (a, (b, c))

-- | Associates a left-nested view pair to the right
assocrPut :: Monad m => PutlensM m (a, (b, c)) ((a, b), c)

-- | Swaps the order of elements in a view sum
coswapPut :: Monad m => PutlensM m (Either b a) (Either a b)

-- | Associates a right-nested view sum to the left
coassoclPut :: Monad m => PutlensM m (Either (Either a b) c) (Either a (Either b c))

-- | Associates a left-nested view sum to the left
coassocrPut :: Monad m => PutlensM m (Either a (Either b c)) (Either (Either a b) c)

-- | Distributes a sum to the left of a view pair into a sum of pairs
distlPut :: Monad m => PutlensM m (Either (a, c) (b, c)) (Either a b, c)

-- | Distributes a sum to the right of a view pair into a sum of pairs
distrPut :: Monad m => PutlensM m (Either (a, b) (a, c)) (a, Either b c)

-- | Undistributes a sum of pairs view into source pair with a sum to the
--   left
undistlPut :: Monad m => PutlensM m (Either a b, c) (Either (a, c) (b, c))

-- | Undistributes a sum of pairs view into source pair with a sum to the
--   right
undistrPut :: Monad m => PutlensM m (a, Either b c) (Either (a, b) (a, c))

-- | Swaps the first with the second element of a right-nested view pair
subrPut :: Monad m => PutlensM m (b, (a, c)) (a, (b, c))

-- | Swaps the second with the third element of a left-nested view pair
sublPut :: Monad m => PutlensM m ((a, c), b) ((a, b), c)

-- | Swaps the first with the second choice of a right-nested view sum
cosubrPut :: Monad m => PutlensM m (Either b (Either a c)) (Either a (Either b c))

-- | Swaps the second with the third choice of a left-nested view sum
cosublPut :: Monad m => PutlensM m (Either (Either a c) b) (Either (Either a b) c)

-- | Swaps the order of two nested view pairs
distpPut :: Monad m => PutlensM m ((a, c), (b, d)) ((a, b), (c, d))

-- | Distributes a pair of view sums into a sum of choices
distsPut :: Monad m => PutlensM m (Either (Either (a, c) (a, d)) (Either (b, c) (b, d))) (Either a b, Either c d)

-- | Joins a a sum of choices into a pair of view sums
undistsPut :: Monad m => PutlensM m (Either a b, Either c d) (Either (Either (a, c) (a, d)) (Either (b, c) (b, d)))

-- | Lifts a parameter outside of a lens (first element as external
--   parameter)
paramfstPut :: Monad m => (k -> PutlensM m s v) -> PutlensM m (k, s) (k, v)

-- | Lifts a left element of the source to an external parameter
paramfstGet :: (Monad m, Eq v) => (v -> m k) -> (k -> PutlensM m s v) -> PutlensM m (k, s) v

-- | Lifts a parameter outside of a lens (second element as external
--   parameter)
paramsndPut :: Monad m => (k -> PutlensM m s v) -> PutlensM m (s, k) (v, k)

-- | Lifts a right element of the source to an external parameter
paramsndGet :: (Monad m, Eq v) => (v -> m k) -> (k -> PutlensM m s v) -> PutlensM m (s, k) v
paramSrcPut :: Monad m => (Maybe s -> k) -> (k -> PutlensM m s v) -> PutlensM m s v

-- | Lifts a parameter used only by the backward function to an external
--   parameter
paramPut :: Monad m => (Maybe s -> v -> m k) -> (k -> PutlensM m s v) -> PutlensM m s v
isoPut :: Monad m => (a -> b) -> (b -> a) -> PutlensM m b a


-- | Template Haskell procedures to generate default putlenses for record
--   types and default putlens constructors and destructores for
--   <tt>Generic</tt> instances.
module Generics.Putlenses.TH

-- | Generates field putlenses for record types For a record <tt>data T a =
--   T { t1 :: String, t2 :: a } $( makePutlensFields ''T )</tt> it
--   generates two putlenses <tt>t1Put :: Monad m =&gt; PutlensM m e (T a)
--   String t2Put :: Monad m =&gt; PutlensM e (T a) a</tt>
makePutlensFields :: Name -> Q [Dec]

-- | Generates constructor and destructor putlenses for data types that are
--   <tt>Generic</tt> instances For an algebraic data type <tt>data List a
--   = Nil | Cons a [a] deriving Generic $( makePutlensConstructors ''List
--   )</tt> it generates two constructors <tt>nilPut :: MonadPlus m =&gt;
--   PutlensM m e (List a) () nilPut = innPut .&lt; injlPut consPut ::
--   Monad m =&gt; PutlensM m e (List a) (a,List a) consPut = innPut .&lt;
--   injrPut</tt> and two destructors <tt>unnilPut :: Monad m =&gt;
--   PutlensM m e () (List a) unnilPut = uninjlPut .&lt; outPut unconsPut
--   :: Monad m =&gt; PutlensM m e (a,List a) (List a) unconsPut =
--   uninjrPut .&lt; outPut</tt>
makePutlensConstructors :: Name -> Q [Dec]


-- | Collection of miscellaneous put-based programming examples.
module Generics.Putlenses.Examples.Examples

-- | Unzips a list into two lists (creating empty tail lists by default)
unzipPut :: (Monad m, Eq a, Eq b) => PutlensM m ([a], [b]) [(a, b)]

-- | Putlens version of <tt>map</tt>
mapPut :: Monad m => PutlensM m b a -> PutlensM m [b] [a]

-- | Putlens version of <tt>foldr</tt>
unfoldrPut :: (Monad m, Eq a, Eq b) => PutlensM m (b, a) a -> a -> PutlensM m [b] a

-- | Putlens version of <tt>unfoldr</tt>
foldrPut :: Monad m => PutlensM m b (Either () (a, b)) -> PutlensM m b [a]

-- | Putlens version of <tt>mfilter</tt>
mfilterPut :: MonadPlus m => (s -> Bool) -> PutlensM m s v -> PutlensM m s v

-- | Variant of <tt>unfoldrPut</tt> that tries to present the original
--   source branching even when the view value matches the stop condition
--   Useful for example for cases when we want to always preserve the
--   length of the original source list.
unfoldrsPut :: (Monad m, Eq a, Eq b) => PutlensM m (b, a) a -> a -> PutlensM m [b] a
nilPut :: Monad m => PutlensM m [a] ()
consPut :: Monad m => PutlensM m [a] (a, [a])
unnilPut :: Monad m => PutlensM m () [a]
unconsPut :: Monad m => PutlensM m (a, [a]) [a]
unheadPut :: (Monad m, Eq a) => PutlensM m [a] a
untailPut :: (Monad m, Eq a) => PutlensM m [a] [a]
wrapPut :: (Monad m, Eq a) => PutlensM m [a] a
unwrapPut :: (Monad m, Eq a) => PutlensM m a [a]
data Tree a
Empty :: Tree a
Node :: a -> (Tree a) -> (Tree a) -> Tree a
unnodePut :: Monad m => PutlensM m (a_alBc, (Tree a_alBc, Tree a_alBc)) (Tree a_alBc)
nodePut :: Monad m => PutlensM m (Tree a_alBc) (a_alBc, (Tree a_alBc, Tree a_alBc))
unemptyPut :: Monad m => PutlensM m () (Tree a_alBc)
emptyPut :: Monad m => PutlensM m (Tree a_alBc) ()

-- | List concatenation (positional)
catPut :: (Monad m, Eq a) => PutlensM m ([a], [a]) [a]
exCatPut1 :: [Integer]
exCatPut2 :: Identity ([Integer], [Integer])
exCatPut3 :: Identity ([Integer], [Integer])
exCatPut4 :: Identity ([Integer], [Integer])

-- | List concatenation (split the view list at position n-1)
catPutN :: (Monad m, Eq a) => (Maybe ([a], [a]) -> [a] -> Int) -> PutlensM m ([a], [a]) [a]
catPutN' :: (Monad m, Eq a) => PutlensStateM m Int ([a], [a]) [a]

-- | List concatenation (split the view list in half)
catPut2 :: Eq a => PutlensM Identity ([a], [a]) [a]
exCatPut21 :: [Integer]
exCatPut22 :: Identity ([Integer], [Integer])
exCatPut23 :: Identity ([Integer], [Integer])
exCatPut24 :: Identity ([Integer], [Integer])

-- | List concatenation (puts elements to the left while satisfying a
--   predicate)
catPutP :: (Monad m, Eq a) => (Maybe (Either [a] [a]) -> a -> m Bool) -> PutlensM m ([a], [a]) [a]

-- | List concatenation (puts elements to the left while being equal)
catPutSame :: (Monad m, Eq a) => PutlensM m ([a], [a]) [a]
catPutSameMb :: Eq a => PutlensM Identity ([a], [a]) [a]
exCatPutSame1 :: [Integer]
exCatPutSame2 :: Identity ([Integer], [Integer])
exCatPutSame3 :: Identity ([Integer], [Integer])

-- | List concatenation (puts elements to the left while smaller than a
--   particular value)
catPutPred :: (Monad m, Ord a) => a -> PutlensM m ([a], [a]) [a]
catPutPredMb :: Ord a => a -> PutlensM Identity ([a], [a]) [a]
exCatPutPred1 :: [Integer]
exCatPutPred2 :: Identity ([Integer], [Integer])
exCatPutPred3 :: Identity ([Integer], [Integer])
exCatPutPred4 :: Identity ([Integer], [Integer])

-- | Left list filtering lens (but will drop some right elements if the
--   view list is smaller). The argument passed to <tt>keepfstOrPut</tt>
--   can be undefined because it will never be used
filterlPut :: (Monad m, Eq a, Eq b) => PutlensM m [Either a b] [a]

-- | Right list filtering lens (but will drop some left elements if the
--   view list is smaller). The argument passed to <tt>keepsndOrPut</tt>
--   can be undefined because it will never be used
filterrPut :: (Monad m, Eq a, Eq b) => PutlensM m [Either a b] [b]

-- | List filtering lens that splits a list of eithers into a list two
--   lists. The boolean argument allows controlling the priority of
--   left/right values in the source list.
partitionPut :: (Monad m, Eq a, Eq b) => Bool -> PutlensM m [Either a b] ([a], [b])

-- | Left list filtering lens (that recovers all right elements).
filterleftPut :: (Monad m, Eq a, Eq b) => PutlensM m [Either a b] [a]
filterPut :: (Monad m, Eq a) => (a -> Bool) -> PutlensM m [a] [a]

-- | Right list filtering lens (that recovers all left elements).
filterrightPut :: (Monad m, Eq a, Eq b) => PutlensM m [Either a b] [b]
succPut :: Monad m => PutlensM m Int Int
predPut :: Monad m => PutlensM m Int Int
data Nat
ZeroN :: Nat
SuccN :: Nat -> Nat
unsuccNPut :: Monad m => PutlensM m Nat Nat
succNPut :: Monad m => PutlensM m Nat Nat
unzeroNPut :: Monad m => PutlensM m () Nat
zeroNPut :: Monad m => PutlensM m Nat ()
natPut :: Monad m => PutlensM m Nat Int
int :: Nat -> Int
nat :: Int -> Nat

-- | Length as a natural number
lengthNatPut :: (Monad m, Eq a) => (Int -> a) -> PutlensM m [a] Nat
exLengthNatPut1 :: Nat
exLengthNatPut2 :: Identity [Char]
exLengthNatPut3 :: Identity [Char]

-- | Embeds a value at a fixed position in a list
embedAtPut :: (Monad m, Eq a) => Int -> PutlensM m [a] a

-- | Embeds a value at a fixed position in a list (supports extending the
--   length original list)
embedAtPut1 :: (Monad m, Eq a) => Int -> PutlensM m [a] a

-- | Embeds a value at a fixed position in a list (source induction)
embedAtPut2 :: (Monad m, Eq a) => Int -> PutlensM m [a] a
embedAtPut2' :: (Monad m, Eq a) => PutlensM m (Int, [a]) a

-- | Embeds a value at a fixed position in a list (supports extending the
--   length original list) (source induction)
embedAtPut3 :: (Monad m, Eq a) => Int -> PutlensM m [a] a
embedAtPut3' :: (Monad m, Eq a) => PutlensStateM m a (Int, [a]) a
exEmbedAtPut1 :: Char
exEmbedAtPut2 :: Identity [Char]
exEmbedAtPut3 :: Identity [Char]
exEmbedAtPut4 :: Char
exEmbedAtPut5 :: Identity [Char]

-- | Embeds a value at a fixed position in a list (splitAt approach)
embedAtPut4 :: (Monad m, Eq a) => Int -> PutlensM m [a] a
splitAtPut :: (Monad m, Eq a) => PutlensM m (Int, [a]) ([a], [a])
exEmbedAtPut41 :: Char
exEmbedAtPut42 :: Identity [Char]
exEmbedAtPut43 :: Identity [Char]

-- | Splits a view number into two summands (by adding an offset to the
--   original first value)
splitPut :: (Monad m, Integral a) => ((a, a) -> a -> m a) -> PutlensM m (a, a) a

-- | Updates the sum of a list (preserves the original source and appends
--   the difference to the end)
summandsPut1 :: (Monad m, Integral a) => PutlensM m [a] a

-- | Updates the sum of a list (distributes the difference by dividing it
--   by two at each recursive step) half of the difference is added to the
--   first element of the source, a quarter to the second, and so on until
--   the remainder is 0
summandsPut2 :: (Monad m, Integral a) => PutlensM m [a] a

-- | Updates the sum of a list (distributes the difference by dividing it
--   by the length of the original list) distributes the difference evenly
--   among original list numbers
summandsPut3 :: (Monad m, Integral a) => PutlensM m [a] a
summandsPut3' :: (Monad m, Integral a) => PutlensStateM m a [a] a

-- | Updates the sum of a list (distributes the difference by dividing it
--   by the length of the original list, always preserving the size of the
--   original list even when the view is zero)
summandsPut4 :: (Monad m, Integral a) => PutlensM m [a] a
summandsPut4' :: (Monad m, Integral a) => PutlensStateM m a [a] a
exSummandsPut1 :: Integer
exSummandsPut2 :: [Integer]
exSummandsPut3 :: [Integer]
exSummandsPut4 :: [Integer]
exSummandsPut5 :: [Integer]
exSummandsPut6 :: [Integer]
exSummandsPut7 :: [Integer]

-- | Replicate
replicatePut :: (Monad m, Eq a) => PutlensM m (a, Int) [a]
exReplicatePut1 :: Identity (Char, Int)
exReplicatePut2 :: Identity (Char, Int)

-- | Replicates a list of elements into a sequence of replicated elements
replicateListPut :: (Monad m, Eq a) => PutlensM m [(a, Int)] [a]
recoverzerosPut :: (Monad m, Eq a) => PutlensM m [(a, Int)] [(a, Int)]
splitListPut :: (Monad m, Eq a) => PutlensM m [[a]] [a]
exReplicateListPut1 :: [Char]
exReplicateListPut2 :: Identity [(Char, Int)]

-- | Takes the first half of a list (with a default empty element)
halvePut :: (Monad m, Eq a) => a -> PutlensM m [a] [a]
halvePutMb :: Eq a => a -> PutlensM Identity [a] [a]
exHalvePut1 :: Identity [Char]
exHalvePut2 :: Identity [Char]

-- | Takes the first half of a list (using an increasing counter with each
--   consumed element in the forward direction)
halvePut2 :: (Monad m, Eq a) => a -> PutlensM m [a] [a]
halvePut2' :: (Monad m, Eq a) => a -> PutlensM m ([a], Int) ([a], Int)
exHalvePut21 :: Identity [Char]
exHalvePut22 :: Identity [Char]
exHalvePut23 :: Identity [Char]

-- | Takes the first half of a list (using a decreasing counter with the
--   size of the input list, decreased 2 by 2, in the forward direction)
halvePut3 :: (Monad m, Eq a) => a -> PutlensM m [a] [a]
halvePut3' :: (Monad m, Eq a) => a -> PutlensStateM m Int ([a], Int) [a]
exHalvePut31 :: Identity [Char]
exHalvePut32 :: Identity [Char]
exHalvePut33 :: Identity [Char]

-- | Incremental summation
isumPut :: Monad m => PutlensM m [Int] [Int]
subtractPut :: Monad m => Int -> PutlensM m Int Int
exIsumPut1 :: [Int]
exIsumPut2 :: Identity [Int]

-- | Insertion sort (put according to the original relative source order)
iunsortPut1 :: (Monad m, Ord a) => PutlensM m [a] [a]
delPut1 :: (Monad m, Ord a) => PutlensM m (a, [a]) [a]

-- | Insertion sort (identity backward transformation)
iunsortPut2 :: (Monad m, Ord a) => PutlensM m [a] [a]
delPut2 :: (Monad m, Ord a) => PutlensM m (a, [a]) [a]
exIunsortPut1 :: [Integer]
exIunsortPut2 :: [Integer]
exIunsortPut3 :: [Integer]

-- | Quicksort (put according to the original relative source order)
qsortPut :: (Monad m, Ord a) => PutlensM m [a] [a]

-- | Partition a list into smaller and bigger elements than a given element
qpartitionPut :: (Monad m, Ord a) => PutlensM m (a, [a]) (a, ([a], [a]))
catPutNonEmptyRight :: (Monad m, Eq a) => PutlensM m ([a], [a]) [a]
exQsortPut1 :: [Integer]
exQsortPut2 :: [Integer]
exQsortPut3 :: [Integer]

-- | Adds positions to a list (using an higher-order function)
positionsPut :: (Monad m, Eq a) => PutlensM m [a] [(Int, a)]
positionsPut' :: (Monad m, Eq a) => Int -> PutlensM m [a] [(Int, a)]

-- | Adds positions to a list (using environment)
positionsPut2 :: (Monad m, Eq a) => PutlensM m [a] [(Int, a)]
positionsPut2' :: (Monad m, Eq a) => PutlensReaderM m [(Int, a)] (Int, [a]) [(Int, a)]
exIntitions1 :: [(Int, Char)]
exIntitions2 :: [Char]
exIntitions3 :: [Char]

-- | Appends two strings with a separating space
appendWithSepPut :: Monad m => String -> PutlensM m (String, String) String

-- | Parsing<i>pretty-printing lens version using
--   <tt>read</tt></i><tt>show</tt>
readPut :: (MonadPlus m, Read a, Show a) => PutlensM m a String

-- | Parses a string into a sequence of <tt>Int</tt> or <tt>Bool</tt>
--   values separated by a single space
unwordsIntBool :: PutlensM Maybe [Either Int Bool] String

-- | Putlens inverse of <tt>unwords</tt>
unwordsPut :: PutlensM Maybe [String] String

-- | Putlens inverse of <tt>foldr1</tt>, a specialization of <tt>foldr</tt>
--   for non-empty lists
unfoldr1Put :: (MonadPlus m, Eq a) => PutlensM m (a, a) a -> PutlensM m [a] a
instance Eq Nat
instance Show Nat
instance Generic Nat
instance Datatype D1Nat
instance Constructor C1_0Nat
instance Constructor C1_1Nat
instance Generic (Tree a)
instance Datatype D1Tree
instance Constructor C1_0Tree
instance Constructor C1_1Tree


-- | Database examples for a source database with a list of people.
module Generics.Putlenses.Examples.People
type Name = String
type City = String
data Person
Person :: Name -> City -> Person
name :: Person -> Name
city :: Person -> City
nameLens :: Lens' Person Name
cityLens :: Lens' Person City
namePut :: PutlensM Identity Person Name
cityPut :: PutlensM Identity Person City
nameP :: Monad m => PutlensM m Person Name
peopleNamesPut0 :: Monad m => City -> PutlensM m [Person] [Name]
exPeopleNamesPut1 :: Identity [Person]
peopleNamesPut :: Monad m => City -> PutlensReaderM m [Person] [Person] [Name]
exPeopleNamesPut2 :: [Person]

-- | Generic database select putlens
selectPut :: (Monad m, Eq a, Ord k) => (a -> k) -> (Maybe [a] -> m [a]) -> (a -> Bool) -> PutlensM m [a] [a]
selectPut' :: (Monad m, Eq a, Ord k) => (a -> k) -> (a -> Bool) -> PutlensStateM m (Maybe a, [a]) [a] [a]
recoverEntry :: Ord k => (a -> k) -> [a] -> [a] -> (Maybe a, [a])
nameLns :: Lens Person Name
cityLns :: Lens Person City
isFrom :: City -> Person -> Bool

-- | Selects all people <tt>from</tt> a city
peopleFromPut :: Monad m => City -> PutlensM m [Person] [Person]

-- | Selects all people <tt>from</tt> a city (moves deleted people to a new
--   city <tt>to</tt>)
peopleFromToPut :: Monad m => City -> City -> PutlensM m [Person] [Person]
people :: [Person]
hugo :: Person
sebastian :: Person
zhenjiang :: Person
sebastianTokyo :: Person
exPeopleFromPut1 :: [Person]
exPeopleFromPut2 :: Identity [Person]
exPeopleFromPut3 :: Identity [Person]
exPeopleFromToPut1 :: Identity [Person]
exPeopleFromToPut2 :: Identity [Person]
type Book = (String, String)
type BookPerson = (String, Person)
booksOfPeoplePut :: Monad m => PutlensM m ([Book], [Person]) [BookPerson]
booksOfPeoplePut' :: Monad m => PutlensM m ([Book], [Person]) [BookPerson]
booksOfPersonPut :: Monad m => PutlensStateM m [Person] (Book, [Person]) BookPerson
joinBookPersonPut :: Monad m => PutlensM m (Book, Person) BookPerson
booksOfPeoplePut2 :: Monad m => PutlensM m ([Book], [Person]) [BookPerson]
booksOfPut :: Monad m => [Person] -> PutlensM m [Book] [Book]
selectPersonPut :: Monad m => Name -> PutlensStateM m [Person] [Person] Person
someBooks :: [([Char], [Char])]
somePeople :: [Person]
someJoin :: [([Char], Person)]
insMock :: [([Char], Person)]
exJoinPut1 :: ([Book], [Person])
exJoinPut2 :: ([Book], [Person])
delLOTR :: [([Char], Person)]
exJoinPut3 :: ([Book], [Person])
exJoinPut4 :: ([Book], [Person])
delLOTRMaias :: [([Char], Person)]
exJoinPut5 :: ([Book], [Person])
exJoinPut6 :: ([Book], [Person])
instance Eq Person
instance Show Person
instance Generic Person
instance Datatype D1Person
instance Constructor C1_0Person
instance Selector S1_0_0Person
instance Selector S1_0_1Person


-- | Graph coloring examples.
module Generics.Putlenses.Examples.Color
data Color
Red :: Color
Yellow :: Color
Green :: Color
Blue :: Color
type Vertex = Int
type ColoredGraph = [((Vertex, Color), Edges)]
type Edges = [Vertex]
type Graph = [(Vertex, Edges)]
lookupColor :: MonadPlus m => Vertex -> ColoredGraph -> m Color
colors :: [Color]
red :: MonadPlus m => m Color
blue :: MonadPlus m => m Color
green :: MonadPlus m => m Color
yellow :: MonadPlus m => m Color
genColors :: MonadPlus m => (Color -> Bool) -> [Color] -> m Color
allColors :: MonadPlus m => (Color -> Bool) -> m Color
uncolor :: ColoredGraph -> Graph
differentColor :: Color -> ColoredGraph -> Vertex -> Bool
isCorrect :: ColoredGraph -> Bool
isCorrectNode :: ((Vertex, Color), Edges) -> ColoredGraph -> Bool
mkColor :: MonadPlus m => (Color -> Bool) -> Vertex -> ColoredGraph -> m Color
mkColorNaive :: MonadPlus m => Vertex -> ColoredGraph -> m Color
genColorsNaive :: MonadPlus m => [Color] -> m Color
allColorsNaive :: MonadPlus m => m Color
genGraph :: Int -> Int -> Gen Graph
genGraph' :: [Int] -> [(Int, Int)] -> Graph
genEdges :: [Int] -> Int -> Gen [(Int, Int)]
genEdge :: [Int] -> Gen (Int, Int)

-- | Putlens that colors a graph in the backward direction
colorPut :: MonadPlus m => PutlensM m ColoredGraph Graph

-- | Putlens that colors a graph in the backward direction (slow version)
colorPutNaive :: MonadPlus m => PutlensM m ColoredGraph Graph
testColor :: IO ()
instance Eq Color
instance Ord Color
instance Show Color


-- | Random graph generation examples.
module Generics.Putlenses.Examples.Graph
type Vertex = Int
type Edges = [Vertex]
type Graph = [(Vertex, Edges)]
genGraph :: Int -> Int -> Gen Graph
genGraph' :: [Int] -> [(Int, Int)] -> Graph
genEdges :: [Int] -> Int -> Gen [(Int, Int)]
genEdge :: [Int] -> Gen (Int, Int)
deleteVertex :: Monad m => Vertex -> PutlensM m Graph Graph
testDelete :: Graph
genGraphPut :: PutlensM (MaybeT Gen) Graph (Int, Int)
edgesPut :: PutlensM (MaybeT Gen) Graph Int
lengthEdgesFromPut :: PutlensM (ReaderT [Vertex] (MaybeT Gen)) [Vertex] Int
verticesPut :: PutlensM (MaybeT Gen) Graph [Vertex]
lengthVerticesPut :: PutlensM (MaybeT Gen) [Vertex] Int

-- | Updates the sum of a list (distributes the difference by dividing it
--   by the length of the original list, always preserving the size of the
--   original list even when the view is zero) the source always contains
--   positive numbers
sumEdgesPut :: PutlensM (ReaderT [Vertex] (MaybeT Gen)) [Int] Int
exg :: [(Vertex, [Vertex])]
testGraph :: IO (Maybe Graph)
testSum :: IO (Maybe [Int])
anyint :: Gen Int
positiveint :: Gen Int


-- | Quickcheck procedures to test the well-behavedness of partial lenses
--   (and therefore putlenses)
module Generics.Putlenses.QuickCheck

-- | QuickCheck procedure to test if a lens is well-behaved (partial).
wb :: (Eq s, Eq v) => Lens s v -> s -> v -> Property

-- | QuickCheck procedure to test if a lens is well-behaved, taking as
--   arguments particular domains for get and for put (partial).
wbPartial :: (Eq s, Eq v) => (s -> Bool) -> (s -> v -> Bool) -> Lens s v -> s -> v -> Property

-- | QuickCheck procedure to test if a lens satisfies the PutGet law
--   (partial).
putgetPartial :: Eq v => (s -> v -> Bool) -> Lens s v -> s -> v -> Property

-- | QuickCheck procedure to test if a lens satisfies the PutGet law
--   (partial).
getputPartial :: Eq s => (s -> Bool) -> Lens s v -> s -> Property
