-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | List-like structures with static restrictions on the number of elements
--   
@package non-empty
@version 0.2.1

module Data.Append
data T f g a
Cons :: f a -> g a -> T f g a
fst :: T f g a -> f a
snd :: T f g a -> g a
instance (Traversable f, Traversable g) => Traversable (T f g)
instance (Foldable f, Foldable g) => Foldable (T f g)
instance (Functor f, Functor g) => Functor (T f g)

module Data.NonEmpty.Class
class Empty f
empty :: Empty f => f a
class Cons f
cons :: Cons f => a -> f a -> f a
class Snoc f
snoc :: Snoc f => f a -> a -> f a
snocDefault :: (Cons f, Traversable f) => f a -> a -> f a
class ViewL f
viewL :: ViewL f => f a -> Maybe (a, f a)
class ViewR f
viewR :: ViewR f => f a -> Maybe (f a, a)
class (ViewL f, ViewR f) => View f
viewRDefault :: (ViewL f, Traversable f) => f a -> Maybe (f a, a)
class Singleton f
singleton :: Singleton f => a -> f a
class Append f
append :: Append f => f a -> f a -> f a

-- | It must hold:
--   
--   <pre>
--   fmap f xs
--      = zipWith (\x _ -&gt; f x) xs xs
--      = zipWith (\_ x -&gt; f x) xs xs
--   </pre>
class Functor f => Zip f
zipWith :: Zip f => (a -> b -> c) -> f a -> f b -> f c
zipWith3 :: Zip f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
zipWith4 :: Zip f => (a -> b -> c -> d -> e) -> f a -> f b -> f c -> f d -> f e
zip :: Zip f => f a -> f b -> f (a, b)
zip3 :: Zip f => f a -> f b -> f c -> f (a, b, c)
zip4 :: Zip f => f a -> f b -> f c -> f d -> f (a, b, c, d)
class Repeat f
repeat :: Repeat f => a -> f a
class Repeat f => Iterate f
iterate :: Iterate f => (a -> a) -> a -> f a

-- | We need to distinguish between <a>Sort</a> and <a>SortBy</a>, since
--   there is an <tt>instance Sort Set</tt> but there cannot be an
--   <tt>instance SortBy Set</tt>.
class Sort f
sort :: (Sort f, Ord a) => f a -> f a

-- | Default implementation for <a>sort</a> based on <a>sortBy</a>.
sortDefault :: (Ord a, SortBy f) => f a -> f a
class Sort f => SortBy f
sortBy :: SortBy f => (a -> a -> Ordering) -> f a -> f a
class Reverse f
reverse :: Reverse f => f a -> f a
class Show f
showsPrec :: (Show f, Show a) => Int -> f a -> ShowS
class Arbitrary f
arbitrary :: (Arbitrary f, Arbitrary a) => Gen (f a)
shrink :: (Arbitrary f, Arbitrary a) => f a -> [f a]
instance Arbitrary []
instance Show Set
instance Show []
instance Reverse Seq
instance Reverse Maybe
instance Reverse []
instance SortBy Seq
instance SortBy Maybe
instance SortBy []
instance Sort Set
instance Sort Seq
instance Sort Maybe
instance Sort []
instance Iterate []
instance Repeat []
instance Zip Seq
instance Zip Maybe
instance Zip []
instance Append Seq
instance Append []
instance Singleton Seq
instance Singleton Set
instance Singleton Maybe
instance Singleton []
instance View Seq
instance View Set
instance View Maybe
instance View []
instance ViewR Seq
instance ViewR Set
instance ViewR Maybe
instance ViewR []
instance ViewL Seq
instance ViewL Set
instance ViewL Maybe
instance ViewL []
instance Snoc Seq
instance Snoc []
instance Cons Seq
instance Cons []
instance Empty Seq
instance Empty Set
instance Empty Maybe
instance Empty []

module Data.Empty
data T a
Cons :: T a
instance Eq (T a)
instance Ord (T a)
instance Iterate T
instance Repeat T
instance SortBy T
instance Sort T
instance Reverse T
instance Zip T
instance Empty T
instance Arbitrary (T a)
instance View T
instance ViewR T
instance ViewL T
instance Traversable T
instance Foldable T
instance Functor T
instance Show T
instance Show (T a)


-- | Generalized version of utility-ht:<a>Data.List.Match</a>.
module Data.NonEmpty.Match

-- | Make a list as long as another one
take :: Zip f => f b -> f a -> f a

-- | the same as <tt>($&gt;)</tt>
replicate :: Functor f => f a -> b -> f b

module Data.Zip

-- | Wrap a container such that its Applicative instance is based on zip.
newtype T f a
Cons :: f a -> T f a
decons :: T f a -> f a

-- | Always returns a rectangular list by clipping all dimensions to the
--   shortest slice. Be aware that <tt>transpose [] == repeat []</tt>.
transposeClip :: (Traversable f, Zip g, Repeat g) => f (g a) -> g (f a)
instance (Zip f, Repeat f) => Applicative (T f)
instance Functor f => Functor (T f)

module Data.NonEmpty

-- | The type <a>T</a> can be used for many kinds of list-like structures
--   with restrictions on the size.
--   
--   <ul>
--   <li><tt>T [] a</tt> is a lazy list containing at least one
--   element.</li>
--   <li><tt>T (T []) a</tt> is a lazy list containing at least two
--   elements.</li>
--   <li><tt>T Vector a</tt> is a vector with at least one element. You may
--   also use unboxed vectors but the first element will be stored in a box
--   and you will not be able to use many functions from this module.</li>
--   <li><tt>T Maybe a</tt> is a list that contains one or two
--   elements.</li>
--   <li><tt>Maybe</tt> is isomorphic to <tt>Optional Empty</tt>.</li>
--   <li><tt>T Empty a</tt> is a list that contains exactly one
--   element.</li>
--   <li><tt>T (T Empty) a</tt> is a list that contains exactly two
--   elements.</li>
--   <li><tt>Optional (T Empty) a</tt> is a list that contains zero or two
--   elements.</li>
--   <li>You can create a list type for every finite set of allowed list
--   length by nesting Optional and NonEmpty constructors. If list length
--   <tt>n</tt> is allowed, then place <tt>Optional</tt> at depth
--   <tt>n</tt>, if it is disallowed then place <tt>NonEmpty</tt>. The
--   maximum length is marked by <tt>Empty</tt>.</li>
--   </ul>
data T f a
Cons :: a -> f a -> T f a
head :: T f a -> a
tail :: T f a -> f a
(!:) :: a -> f a -> T f a

-- | Force immediate generation of Cons.
force :: T f a -> T f a

-- | Implementation of <a>&lt;*&gt;</a> without the <a>Empty</a> constraint
--   that is needed for <a>pure</a>.
apply :: (Applicative f, Cons f, Append f) => T f (a -> b) -> T f a -> T f b

-- | Implementation of <a>&gt;&gt;=</a> without the <a>Empty</a> constraint
--   that is needed for <a>return</a>.
bind :: (Monad f, Cons f, Append f) => T f a -> (a -> T f b) -> T f b
toList :: Foldable f => T f a -> [a]
flatten :: Cons f => T f a -> f a
fetch :: ViewL f => f a -> Maybe (T f a)

-- | Synonym for <a>Cons</a>. For symmetry to <a>snoc</a>.
cons :: a -> f a -> T f a
snoc :: Traversable f => f a -> a -> T f a
singleton :: Empty f => a -> T f a
reverse :: (Traversable f, Reverse f) => T f a -> T f a
mapHead :: (a -> a) -> T f a -> T f a
mapTail :: (f a -> g a) -> T f a -> T g a
viewL :: T f a -> (a, f a)
viewR :: Traversable f => T f a -> (f a, a)
init :: Traversable f => T f a -> f a
last :: Foldable f => T f a -> a
foldl1 :: Foldable f => (a -> a -> a) -> T f a -> a

-- | It holds:
--   
--   <pre>
--   foldl1Map f g = foldl1 f . fmap g
--   </pre>
--   
--   but <a>foldl1Map</a> does not need a <a>Functor</a> instance.
foldl1Map :: Foldable f => (b -> b -> b) -> (a -> b) -> T f a -> b

-- | Fold a non-empty list in a balanced way. <i>Balanced</i> means that
--   each element has approximately the same depth in the operator tree.
--   <i>Approximately the same depth</i> means that the difference between
--   maximum and minimum depth is at most 1. The accumulation operation
--   must be associative and commutative in order to get the same result as
--   <a>foldl1</a> or <tt>foldr1</tt>.
foldBalanced :: (a -> a -> a) -> T [] a -> a

-- | maximum is a total function
maximum :: (Ord a, Foldable f) => T f a -> a

-- | maximumBy is a total function
maximumBy :: Foldable f => (a -> a -> Ordering) -> T f a -> a

-- | maximumKey is a total function
maximumKey :: (Ord b, Foldable f) => (a -> b) -> T f a -> a

-- | minimum is a total function
minimum :: (Ord a, Foldable f) => T f a -> a

-- | minimumBy is a total function
minimumBy :: Foldable f => (a -> a -> Ordering) -> T f a -> a

-- | minimumKey is a total function
minimumKey :: (Ord b, Foldable f) => (a -> b) -> T f a -> a

-- | sum does not need a zero for initialization
sum :: (Num a, Foldable f) => T f a -> a

-- | product does not need a one for initialization
product :: (Num a, Foldable f) => T f a -> a
append :: (Append f, Traversable f) => T f a -> T f a -> T (T f) a
appendLeft :: (Append f, Traversable f) => f a -> T f a -> T f a
appendRight :: Append f => T f a -> f a -> T f a

-- | generic variants: <a>cycle</a> or better <tt>Semigroup.cycle</tt>
cycle :: (Cons f, Append f) => T f a -> T f a
zipWith :: Zip f => (a -> b -> c) -> T f a -> T f b -> T f c
mapAdjacent :: Traversable f => (a -> a -> b) -> T f a -> f b
class Insert f
insert :: (Insert f, Ord a) => a -> f a -> T f a

-- | Default implementation for <a>insert</a> based on <a>insertBy</a>.
insertDefault :: (Ord a, InsertBy f, SortBy f) => a -> f a -> T f a
class Insert f => InsertBy f
insertBy :: InsertBy f => (a -> a -> Ordering) -> a -> f a -> T f a
scanl :: Traversable f => (b -> a -> b) -> b -> f a -> T f b
scanr :: Traversable f => (a -> b -> b) -> b -> f a -> T f b
class Tails f
tails :: (Tails f, Cons g, Empty g) => f a -> T f (g a)

-- | Only advised for structures with efficient appending of single
--   elements like <tt>Sequence</tt>. Alternatively you may consider
--   <a>initsRev</a>.
inits :: (Traversable f, Snoc g, Empty g) => f a -> T f (g a)
initsRev :: (Traversable f, Cons g, Empty g, Reverse g) => f a -> T f (g a)
class Functor f => RemoveEach f
removeEach :: RemoveEach f => T f a -> T f (a, f a)


-- | Functions that cope both with plain and non-empty structures.
--   
--   If there are two versions of a function, where one works on
--   fixed-length lists, then place the fixed-length list variant in
--   NonEmpty and the other one here.
module Data.NonEmpty.Mixed
groupBy :: Foldable f => (a -> a -> Bool) -> f a -> [T [] a]
segmentAfter :: Foldable f => (a -> Bool) -> f a -> ([T [] a], [a])
segmentBefore :: Foldable f => (a -> Bool) -> f a -> ([a], [T [] a])
filterToInfixes :: Foldable f => (a -> Bool) -> f a -> [T [] a]
mapAdjacent :: (Cons f, Zip f) => (a -> a -> b) -> T f a -> f b
take :: (View g, Repeat f, Traversable f) => g a -> Maybe (f a)
splitAt :: (View g, Repeat f, Traversable f) => g a -> (Maybe (f a), g a)
sliceVertical :: (View g, Repeat f, Traversable f) => g a -> ([f a], g a)

-- | This implementation is more efficient for Sequence than <a>viewR</a>.
viewR :: (ViewR f, Empty f, Cons f) => T f a -> (f a, a)
init :: (ViewR f, Empty f, Cons f) => T f a -> f a
last :: ViewR f => T f a -> a
tails :: (ViewL f, Empty f) => f a -> T [] (f a)
inits :: (ViewL f, Cons f, Empty f) => f a -> T [] (f a)
appendLeft :: Cons f => [a] -> f a -> f a
iterate :: (Repeat f, Traversable f) => (a -> a) -> a -> f a
class Choose f
choose :: Choose f => [a] -> [f a]
instance Choose []
instance Choose f => Choose (T f)
instance Choose T

module Data.NonEmpty.Set
data T a

-- | We cannot have a reasonable <tt>instance Insert Set</tt>, since the
--   <tt>instance Insert (NonEmpty Set)</tt> would preserve duplicate
--   leading elements, whereas <a>Set</a> does not.
--   
--   However, the <tt>instance Insert NonEmpty</tt> is not the problem. A
--   general type like
--   
--   <pre>
--   insertSet :: (Insert f, Ord a) =&gt; a -&gt; f a -&gt; NonEmpty f a
--   </pre>
--   
--   cannot work, since it can be instantiated to
--   
--   <pre>
--   insertSet :: (Ord a) =&gt; a -&gt; NonEmpty Set a -&gt; NonEmpty (NonEmpty Set) a
--   </pre>
--   
--   and this is obviously wrong: <tt>insertSet x (singleton x)</tt> has
--   only one element, not two.
insert :: Ord a => a -> Set a -> T a
singleton :: a -> T a
member :: Ord a => a -> T a -> Bool
size :: T a -> Int
minView :: T a -> (a, Set a)
maxView :: Ord a => T a -> (a, Set a)
fromList :: Ord a => T [] a -> T a
toAscList :: T a -> T [] a
flatten :: Ord a => T a -> Set a
union :: Ord a => T a -> T a -> T a
unionLeft :: Ord a => Set a -> T a -> T a
unionRight :: Ord a => T a -> Set a -> T a
instance Eq a => Eq (T a)
instance Ord a => Ord (T a)
instance Show a => Show (T a)

module Data.NonEmpty.Map
data T k a
insert :: Ord k => k -> a -> Map k a -> T k a
singleton :: k -> a -> T k a
member :: Ord k => k -> T k a -> Bool
size :: T k a -> Int
elems :: T k a -> T [] a
keys :: T k a -> T [] k
keysSet :: Ord k => T k a -> T k
lookup :: Ord k => k -> T k a -> Maybe a
minViewWithKey :: T k a -> ((k, a), Map k a)
maxViewWithKey :: Ord k => T k a -> ((k, a), Map k a)
fromList :: Ord k => T [] (k, a) -> T k a
toAscList :: T k a -> T [] (k, a)
fetch :: Ord k => Map k a -> Maybe (T k a)
flatten :: Ord k => T k a -> Map k a
union :: Ord k => T k a -> T k a -> T k a
unionLeft :: Ord k => Map k a -> T k a -> T k a
unionRight :: Ord k => T k a -> Map k a -> T k a
instance (Eq k, Eq a) => Eq (T k a)
instance (Ord k, Ord a) => Ord (T k a)
instance Ord k => Traversable (T k)
instance Ord k => Foldable (T k)
instance Ord k => Functor (T k)
instance (Show k, Show a) => Show (T k a)

module Data.Optional
data T f a
Nil :: T f a
Cons :: a -> (f a) -> T f a
(?:) :: a -> f a -> T f a
fromEmpty :: T a -> T f a
fromNonEmpty :: T f a -> T f a
instance (Eq a, Eq (f a)) => Eq (T f a)
instance (Ord a, Ord (f a)) => Ord (T f a)
instance Tails f => Tails (T f)
instance RemoveEach f => RemoveEach (T f)
instance InsertBy f => InsertBy (T f)
instance Insert f => Insert (T f)
instance (InsertBy f, SortBy f) => SortBy (T f)
instance (Insert f, Sort f) => Sort (T f)
instance (Traversable f, Reverse f) => Reverse (T f)
instance Zip f => Zip (T f)
instance Repeat f => Repeat (T f)
instance (Cons f, Empty f) => Cons (T f)
instance Empty (T f)
instance (Arbitrary f, Arbitrary a) => Arbitrary (T f a)
instance Traversable f => Traversable (T f)
instance Foldable f => Foldable (T f)
instance Functor f => Functor (T f)
instance Show f => Show (T f)
instance (Show f, Show a) => Show (T f a)
