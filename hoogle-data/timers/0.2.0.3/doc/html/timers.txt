-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Simple package that implements timers.
--   
@package timers
@version 0.2.0.3

module Control.Concurrent.Timer.Lifted

-- | The data type representing the timer. For now, the action and delay
--   are fixed for the lifetime of the Timer.
data Timer m

-- | Utility
type TimerIO = Timer IO

-- | Executes the the given action once after the given delay elapsed, no
--   sooner, maybe later.
oneShotTimer :: MonadBaseControl IO m => m () -> Delay -> m (Timer m)

-- | Attempts to start a timer. The started timer will have the given delay
--   and action associated and will be one-shot timer.
--   
--   If the timer was initialized before it will be stopped (killed) and
--   started anew.
--   
--   Returns True if the start was successful, otherwise (e.g. other thread
--   is attempting to manipulate the timer) returns False.
oneShotStart :: MonadBaseControl IO m => Timer m -> m () -> Delay -> m Bool

-- | Attempts to restart already initialized timer. The restarted timer
--   will have the same delay and action associated and will be one-shot
--   timer.
--   
--   Returns True if the restart was successful, otherwise (e.g. other
--   thread is attempting to manipulate the timer or the timer was not
--   initialized) returns False.
oneShotRestart :: MonadBaseControl IO m => Timer m -> m Bool

-- | Executes the the given action repeatedly with at least the given delay
--   between executions.
repeatedTimer :: MonadBaseControl IO m => m () -> Delay -> m (Timer m)

-- | Attempts to start a timer. The started timer will have the given delay
--   and action associated and will be repeated timer.
--   
--   If the timer was initialized before it will be stopped (killed) and
--   started anew.
--   
--   Returns True if the start was successful, otherwise (e.g. other thread
--   is attempting to manipulate the timer) returns False.
repeatedStart :: MonadBaseControl IO m => Timer m -> m () -> Delay -> m Bool

-- | Attempts to restart already initialized timer. The restarted timer
--   will have the same delay and action associated and will be one-shot
--   timer.
--   
--   Returns True if the restart was successful, otherwise (e.g. other
--   thread is attempting to manipulate the timer or the timer was not
--   initialized) returns False.
repeatedRestart :: MonadBaseControl IO m => Timer m -> m Bool

-- | Creates a new timer. This does not start the timer.
newTimer :: MonadBase IO m => m (Timer m)

-- | This function is blocking. It waits until it can stop the timer (until
--   there is a value in the MVar), then it kills the timer's thread.
--   
--   After this action completes, the Timer is not innitialized anymore
--   (the MVar contains Nothing).
stopTimer :: MonadBaseControl IO m => Timer m -> m ()

module Control.Concurrent.Timer

-- | The data type representing the timer. For now, the action and delay
--   are fixed for the lifetime of the Timer.
data Timer m

-- | Utility
type TimerIO = Timer IO

-- | Executes the the given action once after the given delay elapsed, no
--   sooner, maybe later.
oneShotTimer :: IO () -> Delay -> IO TimerIO

-- | Attempts to start a timer. The started timer will have the given delay
--   and action associated with it and will be one-shot timer.
--   
--   If the timer was initialized before it will be stopped (killed) and
--   started anew.
--   
--   Returns True if the start was successful, otherwise (e.g. other thread
--   is attempting to manipulate the timer) returns False.
oneShotStart :: TimerIO -> IO () -> Delay -> IO Bool

-- | Attempts to restart already initialized timer. The restarted timer
--   will have the same delay and action associated with it and will be
--   one-shot timer.
--   
--   Returns True if the restart was successful, otherwise (e.g. other
--   thread is attempting to manipulate the timer or the timer was not
--   initialized) returns False.
oneShotRestart :: TimerIO -> IO Bool

-- | Executes the the given action repeatedly with at least the given delay
--   between executions.
repeatedTimer :: IO () -> Delay -> IO TimerIO

-- | Attempts to start a timer. The started timer will have the given delay
--   and action associated with it and will be repeated timer.
--   
--   If the timer was initialized before it will be stopped (killed) and
--   started anew.
--   
--   Returns True if the start was successful, otherwise (e.g. other thread
--   is attempting to manipulate the timer) returns False.
repeatedStart :: TimerIO -> IO () -> Delay -> IO Bool

-- | Attempts to restart already initialized timer. The restarted timer
--   will have the same delay and action associated with it and will be
--   one-shot timer.
--   
--   Returns True if the restart was successful, otherwise (e.g. other
--   thread is attempting to manipulate the timer or the timer was not
--   initialized) returns False.
repeatedRestart :: TimerIO -> IO Bool

-- | Creates a new timer. This does not start the timer.
newTimer :: IO TimerIO

-- | This function is blocking. It waits until it can stop the timer (until
--   there is a value in the MVar), then it kills the timer's thread.
--   
--   After this action completes, the Timer is not innitialized anymore
--   (the MVar contains Nothing).
stopTimer :: TimerIO -> IO ()
