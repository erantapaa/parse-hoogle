-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Three new monad transformers for multi-prompt delimited control
--   
--   Oleg Kiselyov's three new monad transformers for multi-prompt
--   delimited control (released with his permission)
--   
--   This library implements the superset of the interface described in *
--   <i>A Monadic Framework for Delimited Continuations</i>, R. Kent
--   Dybvig, Simon Peyton Jones, and Amr Sabry JFP, v17, N6, pp. 687--730,
--   2007.
--   <a>http://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR615</a>
--   
--   See the original article at
--   <a>http://okmij.org/ftp/continuations/implementations.html#CC-monads</a>
--   for more information.
--   
--   This package split multi-prompt delimited control from
--   <a>http://hackage.haskell.org/package/liboleg</a> for usability.
@package CC-delcont-alt
@version 0.0.0.0


-- | Monad transformer for multi-prompt delimited control
--   
--   This library implements the superset of the interface described in
--   
--   <ul>
--   <li>"<i>A Monadic Framework for Delimited Continuations</i>", R. Kent
--   Dybvig, Simon Peyton Jones, and Amr Sabry JFP, v17, N6, pp. 687--730,
--   2007.
--   <a>http://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR615</a></li>
--   </ul>
--   
--   This code is the straightforward implementation of the definitional
--   machine described in the above paper. To be precise, we implement an
--   equivalent machine, where captured continuations are always sandwiched
--   between two prompts. This equivalence as well as the trick to make it
--   all well-typed are described in the FLOPS 2010 paper. Therefore, to
--   the great extent this code is the straightforward translation of
--   delimcc from OCaml. The parallel stack of delimcc is the <tt>real</tt>
--   stack now (containing parts of the real continuation, that is).
--   
--   This code implements, in CPS, what amounts to a segmented stack (the
--   technique of implementing call/cc efficiently, first described in
--   Hieb, Dybvig and Bruggeman's PLDI 1990 paper).
module Control.Monad.CC.CCRef

-- | Delimited-continuation monad transformer The (CC m) monad is the Cont
--   monad with the answer-type (), combined with the persistent-state
--   monad. The state PTop is the `parallel stack' of delimcc, which is the
--   real stack now. The base monad m must support reference cells, that
--   is, be a member of the type class Mutation. Since we need reference
--   cells anyway, we represent the persistent state as a reference cell
--   PTop, which is passed as the environment.
data CC m a

-- | The context between two exception frames: The captured
--   sub-continuation It is a fragment of the parallel stack: a list of
--   PFrames in inverse order. Since we are in the Cont monad, there is no
--   <tt>real</tt> stack: the type Ekfragment is ()
data SubCont m a b

-- | The type of prompts is just like that in OCaml's delimcc
data Prompt m a
newPrompt :: (Monad m, Mutation m) => CC m (Prompt m a)
pushPrompt :: (Monad m, Mutation m) => Prompt m w -> CC m w -> CC m w
takeSubCont :: (Monad m, Mutation m) => Prompt m b -> (SubCont m a b -> CC m b) -> CC m a
pushSubCont :: (Monad m, Mutation m) => SubCont m a b -> CC m a -> CC m b
runCC :: (Monad m, Mutation m) => CC m a -> m a

-- | An efficient variation of take_subcont, which does not capture any
--   continuation. This code makes it clear that abort is essentially
--   raise.
abortP :: (Monad m, Mutation m) => Prompt m w -> CC m w -> CC m any

-- | An optimization: pushing the _delimited_ continuation. This is the
--   optimization of the pattern
--   
--   <pre>
--   pushPrompt (subcont_pb sk) (pushSubcont sk m)
--   </pre>
--   
--   corresponding to pushing the continuation captured by shift/shift0.
--   The latter continuation always has the delimiter at the end. Indeed
--   shift can be implemented more efficiently as a primitive rather than
--   via push_prompt/control combination...
pushDelimSubCont :: (Monad m, Mutation m) => SubCont m a b -> CC m a -> CC m b
shiftP :: (Monad m, Mutation m) => Prompt m w -> ((a -> CC m w) -> CC m w) -> CC m a
shift0P :: (Monad m, Mutation m) => Prompt m w -> ((a -> CC m w) -> CC m w) -> CC m a
controlP :: (Monad m, Mutation m) => Prompt m w -> ((a -> CC m w) -> CC m w) -> CC m a

-- | Check to see if a prompt is set
isPromptSet :: (Monad m, Mutation m) => Prompt m w -> CC m Bool
class Mutation m where { type family Ref m :: * -> *; }
newRef :: Mutation m => a -> m (Ref m a)
readRef :: Mutation m => Ref m a -> m a
writeRef :: Mutation m => Ref m a -> a -> m ()
instance MonadIO m => MonadIO (CC m)
instance MonadTrans CC
instance Monad m => Monad (CC m)


-- | Monad transformer for multi-prompt delimited control
--   
--   It implements the superset of the interface described in
--   
--   <ul>
--   <li>"<i>A Monadic Framework for Delimited Continuations</i>", R. Kent
--   Dybvig, Simon Peyton Jones, and Amr Sabry JFP, v17, N6, pp. 687--730,
--   2007.
--   <a>http://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR615</a></li>
--   </ul>
--   
--   The first main difference is the use of generalized prompts, which do
--   not have to be created with new_prompt and therefore can be defined at
--   top level. That removes one of the main practical drawbacks of Dybvig
--   et al implementations: the necessity to carry around the prompts
--   throughout all the code.
--   
--   The delimited continuation monad is parameterized by the flavor of
--   generalized prompts. The end of this code defines several flavors; the
--   library users may define their own. User-defined flavors are
--   especially useful when user's code uses a small closed set of
--   answer-types. Flavors PP and PD below are more general, assuming the
--   set of possible answer-types is open and Typeable. If the user wishes
--   to create several distinct prompts with the same answer-types, the
--   user should use the flavor of prompts accepting an integral prompt
--   identifier, such as PD. Prompts of the flavor PD correspond to the
--   prompts in Dybvig, Peyton Jones, Sabry framework. If the user wishes
--   to generate unique prompts, the user should arrange himself for the
--   generation of unique integers (using a state monad, for example). On
--   the other hand, the user can differentiate answer-types using
--   `newtype.' The latter can only produce the set of distinct prompts
--   that is fixed at run-time. Sometimes that is sufficient. There is not
--   need to create a gensym monad then.
--   
--   The second feature of our implementation is the use of the bubble-up
--   semantics: See page 57 of
--   <a>http://okmij.org/ftp/gengo/CAG-talk.pdf</a> This present code
--   implements, for the first time, the delimited continuation monad CC
--   *without* the use of the continuation monad. This code implements CC
--   in direct-style, so to speak. Instead of continuations, we rely on
--   exceptions. Our code has a lot in common with the Error monad. In
--   fact, our code implements an Error monad for resumable exceptions.
module Control.Monad.CC.CCExc

-- | Delimited-continuation monad transformer It is parameterized by the
--   prompt flavor p
data CC p m a

-- | The captured sub-continuation
type SubCont p m a b = CC p m a -> CC p m b

-- | The type of control operator's body
type CCT p m a w = SubCont p m a w -> CC p m w

-- | Generalized prompts for the answer-type w: an injection-projection
--   pair
type Prompt p m w = (forall x. CCT p m x w -> p m x, forall x. p m x -> Maybe (CCT p m x w))
pushPrompt :: Monad m => Prompt p m w -> CC p m w -> CC p m w

-- | Create the initial bubble
takeSubCont :: Monad m => Prompt p m w -> CCT p m x w -> CC p m x

-- | Apply the captured continuation
pushSubCont :: Monad m => SubCont p m a b -> CC p m a -> CC p m b
runCC :: Monad m => CC (p :: (* -> *) -> * -> *) m a -> m a
abortP :: Monad m => Prompt p m w -> CC p m w -> CC p m any
shiftP :: Monad m => Prompt p m w -> ((a -> CC p m w) -> CC p m w) -> CC p m a
shift0P :: Monad m => Prompt p m w -> ((a -> CC p m w) -> CC p m w) -> CC p m a
controlP :: Monad m => Prompt p m w -> ((a -> CC p m w) -> CC p m w) -> CC p m a

-- | The extreme case: prompts for the single answer-type w. The monad (CC
--   PS) then is the monad for regular (single-prompt) delimited
--   continuations
data PS w m x

-- | There is only one generalized prompt of the flavor PS for a given
--   answer-type w. It is defined below
ps :: Prompt (PS w) m w

-- | Prompts for the closed set of answer-types The following prompt flavor
--   P2, for two answer-types w1 and w2, is given as an example. Typically,
--   a programmer would define their own variant data type with variants
--   for the answer-types that occur in their program.
data P2 w1 w2 m x

-- | There are two generalized prompts of the flavor P2:
p2L :: Prompt (P2 w1 w2) m w1
p2R :: Prompt (P2 w1 w2) m w2

-- | Prompts for the open set of answer-types
data PP m x
pp :: Typeable w => Prompt PP m w

-- | The same as PP but with the phantom parameter c The parameter is
--   useful to statically enforce various constrains (statically pass some
--   information between shift and reset) The prompt PP is too
--   <tt>dynamic</tt>: all errors are detected dynamically See
--   Generator2.hs for an example
data PM c m x
pm :: Typeable w => Prompt (PM c) m w

-- | Open set of answer types, with an additional distinction (given by
--   integer identifiers) This prompt flavor corresponds to the prompts in
--   the Dybvig, Peyton-Jones, Sabry framework (modulo the Typeable
--   constraint).
data PD m x
newPrompt :: Typeable w => Int -> Prompt PD m w

-- | It is often helpful, for clarity of error messages, to specify the
--   answer-type associated with the prompt explicitly (rather than relying
--   on the type inference to figure that out). The following function is
--   useful for that purpose.
as_prompt_type :: Prompt p m w -> w -> Prompt p m w
instance MonadIO m => MonadIO (CC p m)
instance MonadTrans (CC p)
instance Monad m => Monad (CC p m)


-- | This file is the CPS version of <a>Control.Monad.CC.CCExc</a>,
--   implementing the identical interface
--   
--   Monad transformer for multi-prompt delimited control It implements the
--   superset of the interface described in
--   
--   <ul>
--   <li>"<i>A Monadic Framework for Delimited Continuations</i>", R. Kent
--   Dybvig, Simon Peyton Jones, and Amr Sabry JFP, v17, N6, pp. 687--730,
--   2007.
--   <a>http://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR615</a></li>
--   </ul>
--   
--   The first main difference is the use of generalized prompts, which do
--   not have to be created with new_prompt and therefore can be defined at
--   top level. That removes one of the main practical drawbacks of Dybvig
--   et al implementations: the necessity to carry around the prompts
--   throughout all the code.
--   
--   The delimited continuation monad is parameterized by the flavor of
--   generalized prompts. The end of this code defines several flavors; the
--   library users may define their own. User-defined flavors are
--   especially useful when user's code uses a small closed set of
--   answer-types. Flavors PP and PD below are more general, assuming the
--   set of possible answer-types is open and Typeable. If the user wishes
--   to create several distinct prompts with the same answer-types, the
--   user should use the flavor of prompts accepting an integral prompt
--   identifier, such as PD. Prompts of the flavor PD correspond to the
--   prompts in Dybvig, Peyton Jones, Sabry framework. If the user wishes
--   to generate unique prompts, the user should arrange himself for the
--   generation of unique integers (using a state monad, for example). On
--   the other hand, the user can differentiate answer-types using
--   `newtype.' The latter can only produce the set of distinct prompts
--   that is fixed at run-time. Sometimes that is sufficient. There is not
--   need to create a gensym monad then.
--   
--   See <a>Control.Monad.CC.CCExc</a> for further comments about the
--   implementation
module Control.Monad.CC.CCCxe

-- | Delimited-continuation monad transformer It is parameterized by the
--   prompt flavor p The first argument is the regular (success)
--   continuation, the second argument is the bubble, or a resumable
--   exception
data CC p m a

-- | The captured sub-continuation
type SubCont p m a b = CC p m a -> CC p m b

-- | The type of control operator's body
type CCT p m a w = SubCont p m a w -> CC p m w

-- | Generalized prompts for the answer-type w: an injection-projection
--   pair
type Prompt p m w = (forall x. CCT p m x w -> p m x, forall x. p m x -> Maybe (CCT p m x w))
pushPrompt :: Monad m => Prompt p m w -> CC p m w -> CC p m w

-- | Create the initial bubble
takeSubCont :: Monad m => Prompt p m w -> CCT p m x w -> CC p m x

-- | Apply the captured continuation
pushSubCont :: Monad m => SubCont p m a b -> CC p m a -> CC p m b
runCC :: Monad m => CC (p :: (* -> *) -> * -> *) m a -> m a
abortP :: Monad m => Prompt p m w -> CC p m w -> CC p m any
shiftP :: Monad m => Prompt p m w -> ((a -> CC p m w) -> CC p m w) -> CC p m a
shift0P :: Monad m => Prompt p m w -> ((a -> CC p m w) -> CC p m w) -> CC p m a
controlP :: Monad m => Prompt p m w -> ((a -> CC p m w) -> CC p m w) -> CC p m a

-- | The extreme case: prompts for the single answer-type w. The monad (CC
--   PS) then is the monad for regular (single-prompt) delimited
--   continuations
data PS w m x
ps :: Prompt (PS w) m w

-- | Prompts for the closed set of answer-types The following prompt flavor
--   P2, for two answer-types w1 and w2, is given as an example. Typically,
--   a programmer would define their own variant data type with variants
--   for the answer-types that occur in their program.
data P2 w1 w2 m x
p2L :: Prompt (P2 w1 w2) m w1
p2R :: Prompt (P2 w1 w2) m w2

-- | Prompts for the open set of answer-types
data PP m x
pp :: Typeable w => Prompt PP m w

-- | The same as PP but with the phantom parameter c The parameter is
--   useful to statically enforce various constrains (statically pass some
--   information between shift and reset) The prompt PP is too
--   <tt>dynamic</tt>: all errors are detected dynamically See
--   Generator2.hs for an example
data PM c m x
pm :: Typeable w => Prompt (PM c) m w

-- | Open set of answer types, with an additional distinction (given by
--   integer identifiers) This prompt flavor corresponds to the prompts in
--   the Dybvig, Peyton-Jones, Sabry framework (modulo the Typeable
--   constraint).
data PD m x
newPrompt :: Typeable w => Int -> Prompt PD m w

-- | It is often helpful, for clarity of error messages, to specify the
--   answer-type associated with the prompt explicitly (rather than relying
--   on the type inference to figure that out). The following function is
--   useful for that purpose.
as_prompt_type :: Prompt p m w -> w -> Prompt p m w
instance MonadIO m => MonadIO (CC p m)
instance MonadTrans (CC p)
instance Monad m => Monad (CC p m)
