-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Exhaustive pattern matching using lenses, traversals, and prisms
--   
@package total
@version 1.0.3


-- | This module lets you exhaustively pattern match on types using
--   <a>Lens</a>es, <a>Traversal</a>s, or <a>Prism</a>s.
--   
--   Here's an example use of this library:
--   
--   <pre>
--   import Lens.Family.Total
--   import Lens.Family.Stock
--   
--   total :: Either Char Int -&gt; String       -- Same as:
--   total = _case                            -- total = \case
--       &amp; on _Left  (\c -&gt; replicate 3  c )  --     Left  c -&gt; replicate 3 c
--       &amp; on _Right (\n -&gt; replicate n '!')  --     Right n -&gt; replicate n '!'
--   </pre>
--   
--   Our <tt>total</tt> function pattern matches exhaustively on the
--   <a>Either</a> type using the <a>_Left</a> and <a>_Right</a> prisms:
--   
--   <pre>
--   &gt;&gt;&gt; total (Left 'X')
--   "XXX"
--   
--   &gt;&gt;&gt; total (Right 2)
--   "!!"
--   </pre>
--   
--   The types ensure that the above function is total. For example, if you
--   omit the <a>_Right</a> branch:
--   
--   <pre>
--   partial :: Either Char Int -&gt; String
--   partial = _case
--       &amp; on _Left  (\c -&gt; replicate 3  c )
--   </pre>
--   
--   ... then you will get the following type error:
--   
--   <pre>
--   No instance for (Empty Int) arising from a use of ‘_case’
--   In the first argument of ‘(&amp;)’, namely ‘_case’
--   In the expression: _case &amp; on _Left (\ c -&gt; replicate 3 c)
--   In an equation for ‘partial’:
--       partial = _case &amp; on _Left (\ c -&gt; replicate 3 c)
--   </pre>
--   
--   That type error means that you didn't pattern match on the branch with
--   the <a>Int</a>.
--   
--   You can also implement exhaustive pattern matching for your own data
--   types with <a>Traversal</a>s or <a>Prism</a>s. However, this only
--   works if you have one type variable for each branch of your type:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric   #-}
--   {-# LANGUAGE TemplateHaskell #-}
--   
--   import Control.Lens.TH
--   import GHC.Generics (Generic)
--   import Lens.Family.Total
--   
--   data Example a b c = C1 a | C2 b | C3 c deriving (Generic)
--   
--   makePrisms ''Example
--   
--   instance (Empty a, Empty b, Empty c) =&gt; Empty (Example a b c)
--   
--   example :: Example String Char Int -&gt; String  -- Same as:
--   example = _case                               -- example = \case
--       &amp; on _C1 (\s -&gt; s              )          --     C1 s -&gt; s
--       &amp; on _C2 (\c -&gt; replicate 3  c )          --     C2 c -&gt; replicate 3  c
--       &amp; on _C3 (\n -&gt; replicate n '!')          --     C3 n -&gt; replicate n '!'
--   </pre>
--   
--   There is no way to prove that the pattern match is exhaustive unless
--   there is a type parameter for every branch. This is because each
--   successive pattern match <a>Void</a>s out that branch's type parameter
--   to prove that the branch no longer needs to be handled. <a>_case</a>
--   just verifies that all type parameters are <a>Void</a>.
--   
--   You can still write an inexhaustive pattern match so long as you
--   provide a default:
--   
--   <pre>
--   example :: Example Int String Float -&gt; String
--   example = _default "default"
--       &amp; on _C2 (\s -&gt; s)
--   </pre>
--   
--   You can even pattern match using <a>Lens</a>es, too:
--   
--   <pre>
--   example :: (Int, Char) -&gt; String     -- Same as:
--   example = _case                      -- example = \case
--       &amp; on _1 (\n -&gt; replicate n '1')  --     (n, _) -&gt; replicate n '1'
--   </pre>
--   
--   ... and of course the identity lens (<a>id</a>) works, too:
--   
--   <pre>
--   example :: (Int, Char) -&gt; String        -- Same as:
--   example = _case                         -- example = \case
--       &amp; on id (\(n, c) -&gt; replicate n c)  --     (n, c) -&gt; replicate n c
--   </pre>
module Lens.Family.Total

-- | A type class for uninhabited types
class Empty a where impossible = gimpossible . from
impossible :: Empty a => a -> x

-- | Synonym for <a>impossible</a>, used to check if a pattern match is
--   exhaustive
_case :: Empty a => a -> x

-- | Synonym for <a>const</a>, used to provide a default if a pattern match
--   is inexhaustive
_default :: x -> a -> x

-- | Pattern match on a <a>Traversal</a>
on :: ((a -> Either a Void) -> i -> Either l r) -> (l -> o) -> (r -> o) -> i -> o

-- | Operator for post-fix function application
(&) :: a -> (a -> b) -> b

-- | A logically uninhabited data type.
data Void :: *
instance GEmpty a => GEmpty (a :*: b)
instance GEmpty a => GEmpty (M1 i c a)
instance Empty a => GEmpty (K1 i a)
instance (GEmpty a, GEmpty b) => GEmpty (a :+: b)
instance GEmpty V1
instance Empty a => Empty (a, b)
instance (Empty a, Empty b) => Empty (Either a b)
instance Empty Void
