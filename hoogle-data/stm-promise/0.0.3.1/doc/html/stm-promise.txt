-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Simple STM Promises for IO computations and external processes
--   
@package stm-promise
@version 0.0.3.1


-- | TVars with a dirty bit that allows for one listener
module Control.Concurrent.STM.DTVar

-- | TVars with a dirty bit which allows for one listener.
data DTVar a

-- | New DTVar which starts dirty
newDTVar :: a -> STM (DTVar a)

-- | <a>newDTVar</a> in <a>IO</a>
newDTVarIO :: a -> IO (DTVar a)

-- | Write a value to a DTVar, making it dirty
writeDTVar :: DTVar a -> a -> STM ()

-- | <a>writeDTVar</a> in <a>IO</a>
writeDTVarIO :: DTVar a -> a -> IO ()

-- | Reads a DTVar <i>without</i> changing the dirty bit
readDTVar :: DTVar a -> STM a

-- | <a>readDTVar</a> in <a>IO</a>
readDTVarIO :: DTVar a -> IO a

-- | Listens until the dirty bit is true, then removes the dirty bit and
--   returns the read element
listenDTVar :: DTVar a -> STM a

-- | <a>listenDTVar</a> in <a>IO</a>
listenDTVarIO :: DTVar a -> IO a

-- | Listen until any of the dirty bits are true, then removes all dirty
--   bits and returns all <a>DTVar</a>'s values, in order.
listenDTVars :: [DTVar a] -> STM [a]

-- | <a>listenDTVars</a> in <a>IO</a>
listenDTVarsIO :: [DTVar a] -> IO [a]

-- | Modify a DTVar, making it dirty.
modifyDTVar :: DTVar a -> (a -> a) -> STM ()


-- | Promises that allow spawning and cancelling in <a>IO</a>, and an
--   <a>STM</a> result
module Control.Concurrent.STM.Promise

-- | A promise
data Promise a
Promise :: IO () -> IO () -> STM (PromiseResult a) -> Promise a

-- | Instruction for spawning
spawn :: Promise a -> IO ()

-- | Instruction for cancelling
cancel :: Promise a -> IO ()

-- | The result of a computation
result :: Promise a -> STM (PromiseResult a)

-- | Gets the result (partial function)
an :: PromiseResult a -> a

-- | The result of the promise
data PromiseResult a

-- | Not finished yet (or not even spawned yet))
Unfinished :: PromiseResult a

-- | Cancelled
Cancelled :: PromiseResult a

-- | A result
An :: a -> PromiseResult a

-- | Is this a result?
isAn :: PromiseResult a -> Bool

-- | Is this unfinished?
isUnfinished :: PromiseResult a -> Bool

-- | Is this cancelled?
isCancelled :: PromiseResult a -> Bool

-- | If either is finished (<a>An</a>), return one of them (favor the first
--   one)
--   
--   If either is <a>Unfinished</a>, this is also <a>Unfinished</a>.
--   
--   Otherwise, both are <a>Cancelled</a> and so is this.
eitherResult :: PromiseResult a -> PromiseResult a -> PromiseResult a

-- | If both are finished (<a>An</a>), return them in a tuple.
--   
--   If either is <a>Cancelled</a>, this is also <a>Cancelled</a>.
--   
--   Otherwise, both are <a>Unfinished</a> and so is this.
bothResults :: PromiseResult a -> PromiseResult b -> PromiseResult (a, b)
instance Functor PromiseResult
instance Eq a => Eq (PromiseResult a)
instance Ord a => Ord (PromiseResult a)
instance Show a => Show (PromiseResult a)
instance Functor Promise


-- | Promises for processes
module Control.Concurrent.STM.Promise.Process

-- | Make a <a>Promise</a>
processPromise :: FilePath -> [String] -> String -> IO (Promise ProcessResult)

-- | Make a <a>Promise</a>, but add a callback that will be run when the
--   process finishes nicely. This hook is mainly intended for logging.
processPromiseCallback :: (ProcessResult -> IO ()) -> FilePath -> [String] -> String -> IO (Promise ProcessResult)

-- | The result from a process
data ProcessResult
ProcessResult :: String -> String -> ExitCode -> ProcessResult
stderr :: ProcessResult -> String
stdout :: ProcessResult -> String
excode :: ProcessResult -> ExitCode

-- | Defines the exit codes that a program can return.
data ExitCode :: *

-- | indicates successful termination;
ExitSuccess :: ExitCode

-- | indicates program failure with an exit code. The exact interpretation
--   of the code is operating-system dependent. In particular, some values
--   may be prohibited (e.g. 0 on a POSIX-compliant system).
ExitFailure :: Int -> ExitCode
instance Eq ProcessResult
instance Ord ProcessResult
instance Show ProcessResult


-- | A tree of computation
module Control.Concurrent.STM.Promise.Tree

-- | Both/Either-trees
data Tree a

-- | Combine two trees with the semantics of <a>Label</a>
Node :: Label -> (Tree a) -> (Tree a) -> Tree a

-- | A computation
Leaf :: a -> Tree a

-- | There is a mean of recovering this computation, by returning mempty
Recoverable :: (Tree a) -> Tree a

-- | Both/Either labels
data Label

-- | Both of these must succeed with an An
Both :: Label

-- | Either of these must succeed with an An, and that one is returned
Either :: Label

-- | All of these must succeed
requireAll :: [Tree a] -> Tree a

-- | Any of these must succeed
requireAny :: [Tree a] -> Tree a

-- | As many as possible should succeed, try all.
tryAll :: [Tree a] -> Tree a

-- | Evaluates a tree of promises, cutting of unnecessary branches, given
--   that some other thread(s) evaluates the promises.
--   
--   The first result is the failures, then the actual result comes
evalTree :: Monoid a => (a -> Bool) -> Tree (Promise a) -> IO (a, a)

-- | Assuming some other thread(s) evaluate the promises in the tree, this
--   gives a live view of the progress, and cancels unnecessary subtrees
--   (due to <a>Either</a>).
--   
--   The first argument is a way to deem promises with results as failures.
--   `(== mempty)` or (const False) could be good alternatives. These
--   failures are sent to the TChan.
watchTree :: Monoid a => (a -> Bool) -> Tree (Promise a) -> IO (TChan a, DTVar (Tree (PromiseResult a)))

-- | A simple scheduling (see <a>workers</a>)
interleave :: Tree a -> [a]

-- | A somewhat smarter scheduling (see <a>workers</a>)
interleave' :: Tree a -> [a]

-- | Shows a tree
showTree :: Show a => Tree a -> String
instance Typeable Label
instance Typeable Tree
instance Eq Label
instance Ord Label
instance Show Label
instance Eq a => Eq (Tree a)
instance Ord a => Ord (Tree a)
instance Show a => Show (Tree a)
instance Traversable Tree
instance Foldable Tree
instance Functor Tree
instance Applicative Tree
instance Monad Tree


-- | Evaluating promises in parallel
module Control.Concurrent.STM.Promise.Workers

-- | Evaluate these promises on n processors, maybe using a timeout in
--   microseconds.
workers :: Maybe Int -> Int -> [Promise a] -> IO ()

-- | Evaluates a channel of promises, maybe using a timeout in
--   microseconds. Stops when the channel is empty.
worker :: Maybe Int -> TChan (Promise a) -> IO ()

-- | Evaluates a single promise (in the calling thread), maybe using a
--   timeout in microseconds.
evaluatePromise :: Maybe Int -> Promise a -> IO ()
