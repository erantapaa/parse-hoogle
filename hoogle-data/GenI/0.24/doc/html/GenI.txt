-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A natural language generator (specifically, an FB-LTAG surface realiser)
--   
--   A natural language generator (specifically, an FB-LTAG surface
--   realiser)
@package GenI
@version 0.24

module NLP.GenI.Statistics
data Statistics
type StatisticsState a = forall m. MonadState Statistics m => m a
emptyStats :: Statistics
showFinalStats :: Statistics -> String
initialStatisticsStateFor :: MonadState Statistics m => (m a -> Statistics -> b) -> m a -> b

-- | Adds a metric at the beginning of the list (note we reverse the order
--   whene we want to print the metrics)
addMetric :: Metric -> StatisticsState ()
data Metric
IntMetric :: String -> Int -> Metric
queryMetrics :: (Metric -> Maybe a) -> Statistics -> [a]
updateMetrics :: (Metric -> Metric) -> Statistics -> Statistics
incrIntMetric :: String -> Int -> Metric -> Metric
queryIntMetric :: String -> Metric -> Maybe Int
instance NFData Metric
instance NFData Statistics
instance JSON Statistics
instance Show Metric

module NLP.GenI.ErrorIO
type ErrorIO = ErrorT Text IO
liftEither :: (Error e, Monad m) => Either e a -> ErrorT e m a
instance Error Text


-- | This is not a proper pretty printer. I aim is to replace this with a
--   (de-facto) standard library if one should appear
module NLP.GenI.Pretty

-- | An alternative <a>Show</a> instance (the idea being that we should
--   reserve <a>Show</a> for outputting actual Haskell)
--   
--   Minimal implementation is <a>pretty</a> or <a>prettyStr</a>
class Pretty a where pretty = pack . prettyStr prettyStr = unpack . pretty
pretty :: Pretty a => a -> Text
prettyStr :: Pretty a => a -> String

-- | An infix synonym for <a>mappend</a>.
(<>) :: Monoid m => m -> m -> m

-- | Separated by space unless one of them is empty (in which case just the
--   non-empty one)
(<+>) :: Text -> Text -> Text

-- | I think I want ($+$) here but I'm not sure I understand the
--   documentation from the pretty package.
--   
--   <tt>t1 <a>above</a> t2</tt> separates the two by a newline, unless one
--   of them is empty. The vertical equivalent to '(<a>+</a>)'
above :: Text -> Text -> Text

-- | <pre>
--   between l r t == l <a></a> t <a></a> r
--   </pre>
between :: Text -> Text -> Text -> Text

-- | <tt>parens t</tt> puts <tt>t</tt> between parentheses (<tt>()</tt>)
parens :: Text -> Text

-- | <tt>squares t</tt> puts <tt>t</tt> between square brackets
--   (<tt>[]</tt>)
squares :: Text -> Text

-- | Puts list items on the same line if they are smaller than a certain
--   width otherwise, puts a newline in between them
squeezed :: Int -> [Text] -> Text

-- | <pre>
--   prettyCount toBlah ""     (x,1) == "blah"
--   prettyCount toBlah "foos" (x,1) == "blah"
--   prettyCount toBlah ""     (x,4) == "blah ×4"
--   prettyCount toBlah "foos" (x,4) == "blah ×4 foos"
--   </pre>
prettyCount :: (a -> Text) -> Text -> (a, Int) -> Text
instance Pretty Integer
instance Pretty Int
instance Pretty Text
instance Pretty String

module NLP.GenI.GeniShow

-- | GenI format; should round-trip with <a>Parser</a> by rights
--   
--   Minimal definition, either one of <a>geniShow</a> or
--   <a>geniShowText</a>
class GeniShow a where geniShow = unpack . geniShowText geniShowText = pack . geniShow
geniShow :: GeniShow a => a -> String
geniShowText :: GeniShow a => a -> Text
geniShowTree :: GeniShow a => Int -> Tree a -> Text
geniKeyword :: Text -> Text -> Text
instance GeniShow a => GeniShow (Tree a)

module NLP.GenI.Polarity.Types
data PolarityKey
PolarityKeyAv :: Text -> Text -> PolarityKey
PolarityKeyStr :: Text -> PolarityKey

-- | attribute
PolarityKeyVar :: Text -> PolarityKey
type SemPols = [Int]

-- | <a>PolarityAttr</a> is something you want to perform detect polarities
--   on.
data PolarityAttr
SimplePolarityAttr :: Text -> PolarityAttr
spkAtt :: PolarityAttr -> Text

-- | <tt>RestrictedPolarityKey</tt> <tt>c att</tt> is a polarity key in
--   which we only pay attention to nodes that have the category
--   <tt>c</tt>. This makes it possible to have polarities for a just a
--   small subset of nodes
RestrictedPolarityAttr :: Text -> Text -> PolarityAttr
_rpkCat :: PolarityAttr -> Text
rpkAtt :: PolarityAttr -> Text
readPolarityAttrs :: String -> Set PolarityAttr
showPolarityAttrs :: Set PolarityAttr -> String
instance Typeable PolarityKey
instance Typeable PolarityAttr
instance Eq PolarityKey
instance Ord PolarityKey
instance Data PolarityKey
instance Eq PolarityAttr
instance Ord PolarityAttr
instance NFData PolarityAttr
instance NFData PolarityKey
instance Show PolarityAttr
instance Pretty PolarityKey


-- | This module provides some very generic, non-GenI specific functions on
--   strings, trees and other miscellaneous odds and ends. Whenever
--   possible, one should try to replace these functions with versions that
--   are available in the standard libraries, or the Haskell platform ones,
--   or on hackage.
module NLP.GenI.General

-- | putStr on stderr
ePutStr :: String -> IO ()
ePutStrLn :: String -> IO ()
eFlush :: IO ()
isGeniIdentLetter :: Char -> Bool

-- | Drop all characters up to and including the one in question
dropTillIncluding :: Char -> String -> String
trim :: String -> String

-- | Make the first character of a string upper case
toUpperHead :: String -> String

-- | Make the first character of a string lower case
toLowerHead :: String -> String

-- | An alphanumeric sort is one where you treat the numbers in the string
--   as actual numbers. An alphanumeric sort would put x2 before x100,
--   because 2 &lt; 10, wheraeas a naive sort would put it the other way
--   around because the characters 1 &lt; 2. To sort alphanumerically, just
--   'sortBy (comparing toAlphaNum)'
toAlphaNum :: String -> [AlphaNum]
quoteString :: String -> String
quoteText :: Text -> Text

-- | <a>quoteText</a> but only if it contains characters that are not used
--   in GenI identifiers
maybeQuoteText :: Text -> Text

-- | break a list of items into sublists of length &lt; the clump size,
--   taking into consideration that each item in the clump will have a
--   single gap of padding interspersed
--   
--   any item whose length is greater than the clump size is put into a
--   clump by itself
--   
--   given a length function <tt>clumpBy (length.show) 8 [<a>hello</a>,
--   <a>this</a>, <a>is</a>, <a>a</a>, <a>list</a>]</tt>
clumpBy :: (a -> Int) -> Int -> [a] -> [[a]]
first3 :: (a -> a2) -> (a, b, c) -> (a2, b, c)
second3 :: (b -> b2) -> (a, b, c) -> (a, b2, c)
third3 :: (c -> c2) -> (a, b, c) -> (a, b, c2)
fst3 :: (a, b, c) -> a
snd3 :: (a, b, c) -> b
thd3 :: (a, b, c) -> c

-- | A strict version of <a>map</a>
map' :: (a -> b) -> [a] -> [b]
buckets :: Ord b => (a -> b) -> [a] -> [(b, [a])]

-- | True if the intersection of two lists is empty.
isEmptyIntersect :: Eq a => [a] -> [a] -> Bool

-- | Serves the same function as <a>groupBy</a>. It groups together items
--   by some property they have in common. The difference is that the
--   property is used as a key to a Map that you can lookup.
groupByFM :: Ord b => (a -> b) -> [a] -> (Map b [a])
insertToListMap :: Ord b => b -> a -> Map b [a] -> Map b [a]
histogram :: Ord a => [a] -> Map a Int
combinations :: [[a]] -> [[a]]
mapMaybeM :: Monad m => (a -> m (Maybe b)) -> [a] -> m [b]

-- | Return the list, modifying only the first matching item.
repList :: (a -> Bool) -> (a -> a) -> [a] -> [a]

-- | Strict version of <tt>mapTree</tt> (for non-strict, just use fmap)
mapTree' :: (a -> b) -> Tree a -> Tree b

-- | Like <a>filter</a>, except on Trees. Filter might not be a good name,
--   though, because we return a list of nodes, not a tree.
filterTree :: (a -> Bool) -> Tree a -> [a]

-- | The leaf nodes of a Tree
treeLeaves :: Tree a -> [a]

-- | Return pairs of (parent, terminal)
preTerminals :: Tree a -> [(a, a)]

-- | <a>repNode</a> <tt>fn filt t</tt> returns a version of <tt>t</tt> in
--   which the first node which <tt>filt</tt> matches is transformed using
--   <tt>fn</tt>.
repNode :: (Tree a -> Tree a) -> (Tree a -> Bool) -> Tree a -> Maybe (Tree a)

-- | Like <a>repNode</a> except that it performs the operations on all
--   nodes that match and doesn't care if any nodes match or not
repAllNode :: (Tree a -> Tree a) -> (Tree a -> Bool) -> Tree a -> Tree a

-- | Like <a>repNode</a> but on a list of tree nodes
listRepNode :: (Tree a -> Tree a) -> (Tree a -> Bool) -> [Tree a] -> ([Tree a], Bool)

-- | Replace a node in the tree in-place with another node; keep the
--   children the same. If the node is not found in the tree, or if there
--   are multiple instances of the node, this is treated as an error.
repNodeByNode :: (a -> Bool) -> a -> Tree a -> Tree a
type Interval = (Int, Int)

-- | Add two intervals
(!+!) :: Interval -> Interval -> Interval

-- | <a>ival</a> <tt>x</tt> builds a trivial interval from <tt>x</tt> to
--   <tt>x</tt>
ival :: Int -> Interval
showInterval :: Interval -> String
newtype BitVector
BitVector :: Integer -> BitVector

-- | displays a bit vector, using a minimum number of bits
showBitVector :: Int -> BitVector -> String

-- | errors specifically in GenI, which is very likely NOT the user's
--   fault.
geniBug :: String -> a
prettyException :: IOException -> String

-- | The module name for an arbitrary data type
mkLogname :: Typeable a => a -> String
instance Eq AlphaNum
instance Eq BitVector
instance Bits BitVector
instance Num BitVector
instance NFData BitVector
instance JSON Text
instance Ord AlphaNum
instance Binary Text


-- | This module provides a simple, naive implementation of
--   nondeterministic finite automata (NFA).
--   
--   The transition function consists of a <tt>Map</tt>, but there are also
--   accessor function which help you query the automaton without worrying
--   about how it's implemented.
--   
--   <ol>
--   <li>The states are a list of lists, not just a simple flat list as you
--   might expect. This allows you to optionally group your states into
--   "columns" which is something we use in the GenI polarity automaton
--   optimisation.</li>
--   <li>We model the empty an empty transition as the transition on
--   <tt>Nothing</tt>. All other transitions are <tt>Just</tt>
--   something.</li>
--   </ol>
module NLP.GenI.Automaton

-- | Note: you can define the final state either by setting
--   <a>isFinalSt</a> to <tt>Just f</tt> where <tt>f</tt> is some function
--   or by putting them in <a>finalStList</a>
data NFA st ab
NFA :: st -> Maybe (st -> Bool) -> [st] -> Map st (Map st [Maybe ab]) -> [[st]] -> NFA st ab
startSt :: NFA st ab -> st

-- | <a>finalSt</a> will use this if defined
isFinalSt :: NFA st ab -> Maybe (st -> Bool)

-- | can be ignored if <a>isFinalSt</a> is defined
finalStList :: NFA st ab -> [st]

-- | there can be more than one transition between any two states and a
--   transition could be the empty symbol
transitions :: NFA st ab -> Map st (Map st [Maybe ab])

-- | if you don't care about grouping states into columns you can just dump
--   everything in one big list
states :: NFA st ab -> [[st]]

-- | <a>finalSt</a> returns all the final states of an automaton
finalSt :: NFA st ab -> [st]
addTrans :: (Ord ab, Ord st) => NFA st ab -> st -> Maybe ab -> st -> NFA st ab

-- | <a>lookupTrans</a> <tt>aut st1 ab</tt> returns the states that
--   <tt>st1</tt> transitions to via <tt>a</tt>.
lookupTrans :: (Ord ab, Ord st) => NFA st ab -> st -> (Maybe ab) -> [st]

-- | Returns all possible paths through an automaton from the start state
--   to any dead-end.
--   
--   Each path is represented as a list of labels.
--   
--   We assume that the automaton does not have any loops in it.
automatonPaths :: (Ord st, Ord ab) => (NFA st ab) -> [[ab]]

-- | The set of all bundled paths. A bundled path is a sequence of states
--   through the automaton from the start state to any dead end. Any two
--   neighbouring states can have more than one possible transition between
--   them, so the bundles can multiply out to a lot of different possible
--   paths.
--   
--   The output is a list of lists of lists:
--   
--   <ul>
--   <li>Each item in the outer list is a bundled path through the
--   automaton, i.e. without distinguishing between the possible
--   transitions from any two neighbouring states</li>
--   <li>Each item in the middle list is represents the set of transitions
--   between two given neighbouring states</li>
--   <li>Each item in the inner list represents a transition between two
--   given states</li>
--   </ul>
automatonPathSets :: (Ord st, Ord ab) => (NFA st ab) -> [[[ab]]]
numStates :: NFA st ab -> Int
numTransitions :: NFA st ab -> Int

module Data.FullList.Internal
newtype FullList a
FullList :: [a] -> FullList a
fromFL :: FullList a -> [a]
indeedFL :: [a] -> w -> (FullList a -> w) -> w
head :: FullList a -> a
tail :: FullList a -> [a]
(++) :: FullList a -> FullList a -> FullList a
sortNub :: (Eq a, Ord a) => FullList a -> FullList a
class Listable l
(!:) :: Listable l => a -> l a -> FullList a
instance Typeable1 FullList
instance Eq a => Eq (FullList a)
instance Ord a => Ord (FullList a)
instance Show a => Show (FullList a)
instance Data a => Data (FullList a)
instance Binary a => Binary (FullList a)
instance NFData a => NFData (FullList a)
instance Listable FullList
instance Listable []
instance Functor FullList

module Data.FullList
data FullList a
fromFL :: FullList a -> [a]
indeedFL :: [a] -> w -> (FullList a -> w) -> w
head :: FullList a -> a
tail :: FullList a -> [a]
(++) :: FullList a -> FullList a -> FullList a
sortNub :: (Eq a, Ord a) => FullList a -> FullList a
class Listable l
(!:) :: Listable l => a -> l a -> FullList a


-- | Gory details for <a>GeniVal</a>
module NLP.GenI.GeniVal.Internal

-- | <ul>
--   <li>constant : no label, just constraints</li>
--   <li>variable : label, with or without constraints</li>
--   <li>anonymous : no label, no constraints</li>
--   </ul>
data GeniVal
GeniVal :: Maybe Text -> Maybe (FullList Text) -> GeniVal

-- | Optional label (<tt>?X</tt> would have <tt>Just <a>X</a></tt>)
gLabel :: GeniVal -> Maybe Text

-- | Optional values/constraints Must have at least one if at all
--   
--   Though it may seem a bit redudant, this is not quite the same as
--   having '[Text]' because <tt>Nothing</tt> means no constraints; whereas
--   <tt>Just []</tt> (impossible here) would mean bottom.
gConstraints :: GeniVal -> Maybe (FullList Text)

-- | <a>mkGConst</a> <tt>x :! []</tt> creates a single constant.
--   <a>mkGConst</a> <tt>x :! xs</tt> creates an atomic disjunction. It
--   makes no difference which of the values you supply for <tt>x</tt> and
--   <tt>xs</tt> as they will be sorted and nubed anyway.
mkGConst :: FullList Text -> GeniVal

-- | Create a singleton constant (no disjunction here)
mkGConstNone :: Text -> GeniVal

-- | Create a variable
mkGVar :: Text -> Maybe (FullList Text) -> GeniVal

-- | Create a variable with no constraints
mkGVarNone :: Text -> GeniVal

-- | Create an anonymous value
mkGAnon :: GeniVal

-- | If <tt>v</tt> has exactly one value/constraint, returns it
singletonVal :: GeniVal -> Maybe Text

-- | An anonymous <a>GeniVal</a> (<tt>_</tt> or <tt>?_</tt>) has no
--   labels/constraints
isAnon :: GeniVal -> Bool

-- | A variable substitution map. GenI unification works by rewriting
--   variables
type Subst = Map Text GeniVal

-- | For debugging
prettySubst :: Subst -> Text
class (MonadPlus m, MonadError Text m, Monad m, Functor m) => MonadUnify m

-- | <a>unify</a> performs unification on two lists of <a>GeniVal</a>. If
--   unification succeeds, it returns <tt>Just (r,s)</tt> where <tt>r</tt>
--   is the result of unification and verb!s! is a list of substitutions
--   that this unification results in.
unify :: MonadUnify m => [GeniVal] -> [GeniVal] -> m ([GeniVal], Subst)

-- | <tt>l1 <a>allSubsume</a> l2</tt> returns the result of <tt>l1
--   <a>unify</a> l2</tt> if doing a simultaneous traversal of both lists,
--   each item in <tt>l1</tt> subsumes the corresponding item in
--   <tt>l2</tt>
allSubsume :: MonadUnify m => [GeniVal] -> [GeniVal] -> m ([GeniVal], Subst)

-- | <tt>unifyHelper unf gs1 gs2</tt> zips two lists with some unification
--   function.
--   
--   It's meant to serve as a helper to <a>unify</a> and <a>allSubsume</a>
unifyHelper :: (MonadError Text m, Monad m) => (GeniVal -> GeniVal -> UnificationResult) -> [GeniVal] -> [GeniVal] -> m ([GeniVal], Subst)

-- | Note that the first Subst is assumed to come chronologically before
--   the second one; so merging <tt>{ X -&gt; Y }</tt> and <tt>{ Y -&gt; 3
--   }</tt> should give us <tt>{ X -&gt; 3; Y -&gt; 3 }</tt>;
--   
--   See <a>prependToSubst</a> for a warning!
appendSubst :: Subst -> Subst -> Subst

-- | Add to variable replacement to a <a>Subst</a> that logical comes
--   before the other stuff in it. So for example, if we have <tt>Y -&gt;
--   foo</tt> and we want to insert <tt>X -&gt; Y</tt>, we notice that, in
--   fact, <tt>Y</tt> has already been replaced by <tt>foo</tt>, so we add
--   <tt>X -&gt; foo</tt> instead
--   
--   Note that it is undefined if you try to append something like <tt>Y
--   -&gt; foo</tt> to <tt>Y -&gt; bar</tt>, because that would mean that
--   unification is broken
prependToSubst :: (Text, GeniVal) -> Subst -> Subst

-- | Unification can either…
data UnificationResult

-- | succeed for free (no substitutions),
SuccessSans :: GeniVal -> UnificationResult

-- | succeed with a one-way substitution,
SuccessRep :: Text -> GeniVal -> UnificationResult

-- | succeed w both vars needing substitution (constraint intersection),
SuccessRep2 :: Text -> Text -> GeniVal -> UnificationResult

-- | or fail
Failure :: UnificationResult

-- | See source code for details
--   
--   Note that we assume that it's acceptable to generate new variable
--   names by appending an <tt>x</tt> to them; this assumption is only safe
--   if the variables have gone through the function
--   <a>finaliseVarsById</a> or have been pre-processed and rewritten with
--   some kind of common suffix to avoid an accidental match
unifyOne :: GeniVal -> GeniVal -> UnificationResult

-- | <tt>intersectConstraints (Just cs1) (Just cs2)</tt> returns the
--   intersection of <tt>cs1</tt> and <tt>cs2</tt> if non-empty (or
--   <a>Nothing</a> if there's nothing in common)
--   
--   If any of the arguments is unconstrained (<tt>Nothing</tt>), we simply
--   return the other.
intersectConstraints :: Eq a => Maybe (FullList a) -> Maybe (FullList a) -> Maybe (Maybe (FullList a))

-- | <a>subsumeOne</a> <tt>x y</tt> returns the same result as <tt>unifyOne
--   x y</tt> if <tt>x</tt> subsumes <tt>y</tt> or <a>Failure</a> otherwise
subsumeOne :: GeniVal -> GeniVal -> UnificationResult

-- | Apply variable substitutions
replace :: DescendGeniVal a => Subst -> a -> a

-- | Apply a single variable substitution
replaceOne :: DescendGeniVal a => (Text, GeniVal) -> a -> a

-- | Here it is safe to say (X -&gt; Y; Y -&gt; Z) because this would be
--   crushed down into a final value of (X -&gt; Z; Y -&gt; Z)
replaceList :: DescendGeniVal a => [(Text, GeniVal)] -> a -> a

-- | Core implementation for <a>replace</a> For use by the Uniplate-esq
--   <a>descendGeniVal</a>
replaceMapG :: Subst -> GeniVal -> GeniVal

-- | Core implementation for <a>replaceOne</a> For use by the Uniplate-esq
--   <a>descendGeniVal</a>
replaceOneG :: (Text, GeniVal) -> GeniVal -> GeniVal

-- | A variable label and its constraints
type CollectedVar = (Text, Maybe (FullList Text))

-- | A <a>Collectable</a> is something which can return its variables as a
--   map from the variable to the number of times that variable occurs in
--   it.
--   
--   Important invariant: if the variable does not occur, then it does not
--   appear in the map (ie. all counts must be &gt;= 1 or the item does not
--   occur at all)
--   
--   By variables, what I most had in mind was the GVar values in a
--   GeniVal. This notion is probably not very useful outside the context
--   of alpha-conversion task, but it seems general enough that I'll keep
--   it around for a good bit, until either some use for it creeps up, or I
--   find a more general notion that I can transform this into.
class Collectable a
collect :: Collectable a => a -> Map CollectedVar Int -> Map CollectedVar Int

-- | An Idable is something that can be mapped to a unique id. You might
--   consider using this to implement Ord, but I won't. Note that the only
--   use I have for this so far (20 dec 2005) is in alpha-conversion.
class Idable a
idOf :: Idable a => a -> Integer

-- | Anonymise any variable that occurs only once in the object
anonymiseSingletons :: (Collectable a, DescendGeniVal a) => a -> a

-- | <a>finaliseVarsById</a> appends a unique suffix to all variables in an
--   object. This avoids us having to alpha convert all the time and relies
--   on the assumption finding that a unique suffix is possible.
finaliseVarsById :: (Collectable a, DescendGeniVal a, Idable a) => a -> a

-- | <a>finaliseVars</a> does the following:
--   
--   <ul>
--   <li>(if suffix is non-null) appends a suffix to all variable names to
--   ensure global uniqueness</li>
--   <li>intersects constraints for for all variables within the same
--   object</li>
--   </ul>
finaliseVars :: (Collectable a, DescendGeniVal a) => Text -> a -> a

-- | A schema value is a disjunction of GenI values. It allows us to
--   express “fancy” disjunctions in tree schemata, ie. disjunctions over
--   variables and not just atoms (<tt>?X;?Y</tt>).
--   
--   Our rule is that that when a tree schema is instantiated, any fancy
--   disjunctions must be “crushed” into a single <a>GeniVal</a> lest it be
--   rejected (see <a>crushOne</a>)
--   
--   Note that this is still not recursive; we don't have disjunction over
--   schema values, nor can schema values refer to schema values. It just
--   allows us to express the idea that in tree schemata, you can have
--   either variable <tt>?X</tt> or <tt>?Y</tt>.
newtype SchemaVal
SchemaVal :: [GeniVal] -> SchemaVal

-- | Convert a fancy disjunction (allowing disjunction over variables)
--   value into a plain old atomic disjunction. The idea is to support a
--   limited notion of fancy disjunction by requiring that there be a
--   single point where this disjunction can be converted into a plain old
--   variable. Note that we currently convert these to constants only.
crushOne :: SchemaVal -> Maybe GeniVal

-- | Convert a list of fancy disjunctions
crushList :: [SchemaVal] -> Maybe [GeniVal]

-- | A structure that can be traversed with a <a>GeniVal</a>-replacing
--   function (typical use case: substitution after unification)
--   
--   Approach suggested by Neil Mitchell after I found that Uniplate seemed
--   to hurt GenI performance a bit.
class DescendGeniVal a
descendGeniVal :: DescendGeniVal a => (GeniVal -> GeniVal) -> a -> a
instance [overlap ok] Typeable GeniVal
instance [overlap ok] Eq GeniVal
instance [overlap ok] Ord GeniVal
instance [overlap ok] Data GeniVal
instance [overlap ok] Eq SchemaVal
instance [overlap ok] Ord SchemaVal
instance [overlap ok] Binary SchemaVal
instance [overlap ok] Binary GeniVal
instance [overlap ok] NFData SchemaVal
instance [overlap ok] NFData GeniVal
instance [overlap ok] (Functor f, DescendGeniVal a) => DescendGeniVal (f a)
instance [overlap ok] DescendGeniVal GeniVal
instance [overlap ok] GeniShow SchemaVal
instance [overlap ok] DescendGeniVal SchemaVal
instance [overlap ok] Collectable SchemaVal
instance [overlap ok] Collectable GeniVal
instance [overlap ok] Collectable a => Collectable [a]
instance [overlap ok] Collectable a => Collectable (Maybe a)
instance [overlap ok] MonadUnify (Either Text)
instance [overlap ok] GeniShow GeniVal
instance [overlap ok] Pretty GeniVal


-- | GenI values (variables, constants)
module NLP.GenI.GeniVal

-- | <ul>
--   <li>constant : no label, just constraints</li>
--   <li>variable : label, with or without constraints</li>
--   <li>anonymous : no label, no constraints</li>
--   </ul>
data GeniVal

-- | Optional label (<tt>?X</tt> would have <tt>Just <a>X</a></tt>)
gLabel :: GeniVal -> Maybe Text

-- | Optional values/constraints Must have at least one if at all
--   
--   Though it may seem a bit redudant, this is not quite the same as
--   having '[Text]' because <tt>Nothing</tt> means no constraints; whereas
--   <tt>Just []</tt> (impossible here) would mean bottom.
gConstraints :: GeniVal -> Maybe (FullList Text)

-- | <a>mkGConst</a> <tt>x :! []</tt> creates a single constant.
--   <a>mkGConst</a> <tt>x :! xs</tt> creates an atomic disjunction. It
--   makes no difference which of the values you supply for <tt>x</tt> and
--   <tt>xs</tt> as they will be sorted and nubed anyway.
mkGConst :: FullList Text -> GeniVal

-- | Create a singleton constant (no disjunction here)
mkGConstNone :: Text -> GeniVal

-- | Create a variable
mkGVar :: Text -> Maybe (FullList Text) -> GeniVal

-- | Create a variable with no constraints
mkGVarNone :: Text -> GeniVal

-- | Create an anonymous value
mkGAnon :: GeniVal

-- | An anonymous <a>GeniVal</a> (<tt>_</tt> or <tt>?_</tt>) has no
--   labels/constraints
isAnon :: GeniVal -> Bool

-- | If <tt>v</tt> has exactly one value/constraint, returns it
singletonVal :: GeniVal -> Maybe Text

-- | A schema value is a disjunction of GenI values. It allows us to
--   express “fancy” disjunctions in tree schemata, ie. disjunctions over
--   variables and not just atoms (<tt>?X;?Y</tt>).
--   
--   Our rule is that that when a tree schema is instantiated, any fancy
--   disjunctions must be “crushed” into a single <a>GeniVal</a> lest it be
--   rejected (see <a>crushOne</a>)
--   
--   Note that this is still not recursive; we don't have disjunction over
--   schema values, nor can schema values refer to schema values. It just
--   allows us to express the idea that in tree schemata, you can have
--   either variable <tt>?X</tt> or <tt>?Y</tt>.
newtype SchemaVal
SchemaVal :: [GeniVal] -> SchemaVal

-- | Convert a fancy disjunction (allowing disjunction over variables)
--   value into a plain old atomic disjunction. The idea is to support a
--   limited notion of fancy disjunction by requiring that there be a
--   single point where this disjunction can be converted into a plain old
--   variable. Note that we currently convert these to constants only.
crushOne :: SchemaVal -> Maybe GeniVal

-- | <a>finaliseVars</a> does the following:
--   
--   <ul>
--   <li>(if suffix is non-null) appends a suffix to all variable names to
--   ensure global uniqueness</li>
--   <li>intersects constraints for for all variables within the same
--   object</li>
--   </ul>
finaliseVars :: (Collectable a, DescendGeniVal a) => Text -> a -> a

-- | <a>finaliseVarsById</a> appends a unique suffix to all variables in an
--   object. This avoids us having to alpha convert all the time and relies
--   on the assumption finding that a unique suffix is possible.
finaliseVarsById :: (Collectable a, DescendGeniVal a, Idable a) => a -> a

-- | Anonymise any variable that occurs only once in the object
anonymiseSingletons :: (Collectable a, DescendGeniVal a) => a -> a
class (MonadPlus m, MonadError Text m, Monad m, Functor m) => MonadUnify m

-- | <a>unify</a> performs unification on two lists of <a>GeniVal</a>. If
--   unification succeeds, it returns <tt>Just (r,s)</tt> where <tt>r</tt>
--   is the result of unification and verb!s! is a list of substitutions
--   that this unification results in.
unify :: MonadUnify m => [GeniVal] -> [GeniVal] -> m ([GeniVal], Subst)

-- | Unification can either…
data UnificationResult

-- | succeed for free (no substitutions),
SuccessSans :: GeniVal -> UnificationResult

-- | succeed with a one-way substitution,
SuccessRep :: Text -> GeniVal -> UnificationResult

-- | succeed w both vars needing substitution (constraint intersection),
SuccessRep2 :: Text -> Text -> GeniVal -> UnificationResult

-- | or fail
Failure :: UnificationResult

-- | A variable substitution map. GenI unification works by rewriting
--   variables
type Subst = Map Text GeniVal

-- | Note that the first Subst is assumed to come chronologically before
--   the second one; so merging <tt>{ X -&gt; Y }</tt> and <tt>{ Y -&gt; 3
--   }</tt> should give us <tt>{ X -&gt; 3; Y -&gt; 3 }</tt>;
--   
--   See <a>prependToSubst</a> for a warning!
appendSubst :: Subst -> Subst -> Subst

-- | <a>subsumeOne</a> <tt>x y</tt> returns the same result as <tt>unifyOne
--   x y</tt> if <tt>x</tt> subsumes <tt>y</tt> or <a>Failure</a> otherwise
subsumeOne :: GeniVal -> GeniVal -> UnificationResult

-- | <tt>l1 <a>allSubsume</a> l2</tt> returns the result of <tt>l1
--   <a>unify</a> l2</tt> if doing a simultaneous traversal of both lists,
--   each item in <tt>l1</tt> subsumes the corresponding item in
--   <tt>l2</tt>
allSubsume :: MonadUnify m => [GeniVal] -> [GeniVal] -> m ([GeniVal], Subst)

-- | A structure that can be traversed with a <a>GeniVal</a>-replacing
--   function (typical use case: substitution after unification)
--   
--   Approach suggested by Neil Mitchell after I found that Uniplate seemed
--   to hurt GenI performance a bit.
class DescendGeniVal a
descendGeniVal :: DescendGeniVal a => (GeniVal -> GeniVal) -> a -> a

-- | A <a>Collectable</a> is something which can return its variables as a
--   map from the variable to the number of times that variable occurs in
--   it.
--   
--   Important invariant: if the variable does not occur, then it does not
--   appear in the map (ie. all counts must be &gt;= 1 or the item does not
--   occur at all)
--   
--   By variables, what I most had in mind was the GVar values in a
--   GeniVal. This notion is probably not very useful outside the context
--   of alpha-conversion task, but it seems general enough that I'll keep
--   it around for a good bit, until either some use for it creeps up, or I
--   find a more general notion that I can transform this into.
class Collectable a
collect :: Collectable a => a -> Map CollectedVar Int -> Map CollectedVar Int

-- | An Idable is something that can be mapped to a unique id. You might
--   consider using this to implement Ord, but I won't. Note that the only
--   use I have for this so far (20 dec 2005) is in alpha-conversion.
class Idable a
idOf :: Idable a => a -> Integer

-- | Apply variable substitutions
replace :: DescendGeniVal a => Subst -> a -> a

-- | Here it is safe to say (X -&gt; Y; Y -&gt; Z) because this would be
--   crushed down into a final value of (X -&gt; Z; Y -&gt; Z)
replaceList :: DescendGeniVal a => [(Text, GeniVal)] -> a -> a


-- | Feature structures in GenI can be seen as a simple mapping from
--   attributes to values (no fancy recursion).
--   
--   From an implementation standpoint, we do truck around lists of
--   <a>AvPair</a> quite a bit which unfortunately means we don't guarantee
--   things like uniqueness of attributes. We may phase this out over time
--   in favour of <a>FeatStruct</a>
module NLP.GenI.FeatureStructure

-- | A list of attribute-value pairs. It's not a great idea to represent
--   feature structures with this because it allows for duplicates in the
--   attributes. But maybe sometimes you really do mean a list.
type Flist a = [AvPair a]

-- | An attribute-value pair, the typical use being <tt>AvPair GeniVal</tt>
--   or if you have something even simpler <tt>AvPair Text</tt>
data AvPair a
AvPair :: Text -> a -> AvPair a
avAtt :: AvPair a -> Text
avVal :: AvPair a -> a

-- | Experimental, alternative representation of Flist which guarantees
--   uniqueness of keys
type FeatStruct a = Map Text a

-- | A feature structure with no pairs
emptyFeatStruct :: FeatStruct a

-- | Convert an <a>Flist</a> to a proper <a>FeatStruct</a> Unsafely assumes
--   the keys are unique
mkFeatStruct :: Flist GeniVal -> FeatStruct GeniVal

-- | Convert an <a>FeatStruct</a> to a simpler to process <a>Flist</a>
fromFeatStruct :: FeatStruct a -> Flist a

-- | Sort an Flist according with its attributes
sortFlist :: Flist a -> Flist a

-- | <a>unifyFeat</a> performs feature structure unification, under the
--   these assumptions about the input:
--   
--   <ul>
--   <li>Features are ordered</li>
--   <li>The Flists do not share variables (renaming has already been
--   done.</li>
--   </ul>
--   
--   The features are allowed to have different sets of attributes, beacuse
--   we use <a>alignFeat</a> to realign them.
unifyFeat :: MonadUnify m => Flist GeniVal -> Flist GeniVal -> m (Flist GeniVal, Subst)

-- | <a>alignFeat</a> is a pre-procesing step used to ensure that feature
--   structures have the same set of keys. If a key is missing in one, we
--   copy it to the other with an anonymous value.
--   
--   The two feature structures must be sorted for this to work
alignFeat :: Flist GeniVal -> Flist GeniVal -> [(Text, GeniVal, GeniVal)]

-- | Helper for <a>alignFeat</a>; ignore
alignFeatH :: Flist GeniVal -> Flist GeniVal -> [(Text, GeniVal, GeniVal)] -> [(Text, GeniVal, GeniVal)]

-- | Flatten a fancy disjunction attribute-value pair
--   
--   See <a>crushOne</a> for details
crushAvPair :: AvPair SchemaVal -> Maybe (AvPair GeniVal)

-- | Flatten a fancy-disjunction feature structure
--   
--   See <a>crushOne</a> for details
crushFlist :: Flist SchemaVal -> Maybe (Flist GeniVal)
instance Typeable1 AvPair
instance Ord a => Ord (AvPair a)
instance Eq a => Eq (AvPair a)
instance Data a => Data (AvPair a)
instance NFData a => NFData (AvPair a)
instance Binary a => Binary (AvPair a)
instance GeniShow gv => GeniShow (AvPair gv)
instance GeniShow gv => GeniShow (Flist gv)
instance Pretty (AvPair GeniVal)
instance Pretty (Flist GeniVal)
instance Collectable a => Collectable (AvPair a)
instance DescendGeniVal v => DescendGeniVal ([String], Flist v)
instance DescendGeniVal a => DescendGeniVal (String, a)
instance DescendGeniVal v => DescendGeniVal (AvPair v)
instance GeniShow (FeatStruct GeniVal)
instance Pretty (FeatStruct GeniVal)


-- | Internal representation of GenI configuration options, typically
--   passed in through the command line or via the GUI.
--   
--   We don't yet use the record based approach, or something like cmdargs
--   because our use case involves
--   
--   <ul>
--   <li>sharing lots of options between different programs (batch
--   processing, gui, server)</li>
--   <li>supporting library users who want to build GenI-like applications
--   that share a good chunk of our flag set, and add configuration options
--   of their own.</li>
--   </ul>
--   
--   What we have is fairly clunky, but it seems to be quite flexible for
--   that need.
module NLP.GenI.Flag

-- | Requested optimisations
--   
--   At the time of this writing (2012-08-21), this is fairly sparse as a
--   lot of proposed optimisations have just been absorbed into GenI as
--   mandatory things.
data Optimisation

-- | all polarity-related optimisations
PolOpts :: Optimisation

-- | all adjunction-related optimisations
AdjOpts :: Optimisation

-- | polarity filtering
Polarised :: Optimisation

-- | ignore literal constraints (pessimisation?)
NoConstraints :: Optimisation

-- | guided realisation (needs polarity filtering)
Guided :: Optimisation

-- | A test suite and any test cases within that we want to pick out
type Instruction = (FilePath, Maybe [Text])

-- | The tree assembly algorithm we want to use
data BuilderType
SimpleBuilder :: BuilderType
SimpleOnePhaseBuilder :: BuilderType

-- | What kind of elementary trees we're getting. The typical use case is
--   to provide tree schemata with <a>GeniHand</a> (which then get anchored
--   into the lexicon to give us elmentary trees). You can also have
--   precompiled trees hardcoded into your GenI-like program, or read
--   preanchored elementary trees from somewhere else.
data GrammarType

-- | geni's text format
GeniHand :: GrammarType

-- | built into geni, no parsing needed
PreCompiled :: GrammarType

-- | lexical selection already done
PreAnchored :: GrammarType
defaultGrammarType :: GrammarType
getGrammarType :: [Flag] -> GrammarType
hasOpt :: Optimisation -> [Flag] -> Bool

-- | Flags are GenI's internal representation of command line arguments. We
--   use phantom existential types (?) for representing GenI flags. This
--   makes it simpler to do things such as ``get the value of the
--   MacrosFlg'' whilst preserving type safety (we always know that
--   MacrosFlg is associated with String). The alternative would be writing
--   getters and setters for each flag, and that gets really boring after a
--   while.
data Flag
Flag :: (x -> f) -> x -> Flag
class HasFlags x
flags :: HasFlags x => x -> [Flag]
onFlags :: HasFlags x => ([Flag] -> [Flag]) -> x -> x
isFlag :: (Typeable f, Typeable x) => (x -> f) -> Flag -> Bool
hasFlag :: (Typeable f, Typeable x, HasFlags flags) => (x -> f) -> flags -> Bool
deleteFlag :: (Typeable f, Typeable x, HasFlags flags) => (x -> f) -> flags -> flags

-- | This only has an effect if the flag is set
modifyFlag :: (Eq f, Typeable f, Typeable x, HasFlags flags) => (x -> f) -> (x -> x) -> flags -> flags
setFlag :: (Eq f, Typeable f, Typeable x, HasFlags flags) => (x -> f) -> x -> flags -> flags
getFlag :: (Typeable f, Typeable x, HasFlags flags) => (x -> f) -> flags -> Maybe x
getAllFlags :: (Typeable f, Typeable x, HasFlags flags) => (x -> f) -> flags -> [x]
getListFlag :: (Typeable f, Typeable x, HasFlags flags) => ([x] -> f) -> flags -> [x]

-- | <tt>updateFlags new old</tt> takes the flags from <tt>new</tt> plus
--   any from <tt>old</tt> that aren't mentioned in it
updateFlags :: HasFlags flags => flags -> flags -> flags
newtype BatchDirFlg
BatchDirFlg :: FilePath -> BatchDirFlg
newtype DisableGuiFlg
DisableGuiFlg :: () -> DisableGuiFlg
newtype DetectPolaritiesFlg
DetectPolaritiesFlg :: (Set PolarityAttr) -> DetectPolaritiesFlg
newtype DumpDerivationFlg
DumpDerivationFlg :: () -> DumpDerivationFlg
newtype EarlyDeathFlg
EarlyDeathFlg :: () -> EarlyDeathFlg
newtype FromStdinFlg
FromStdinFlg :: () -> FromStdinFlg
newtype HelpFlg
HelpFlg :: () -> HelpFlg
newtype InstructionsFileFlg
InstructionsFileFlg :: FilePath -> InstructionsFileFlg
newtype LexiconFlg
LexiconFlg :: FilePath -> LexiconFlg
newtype MacrosFlg
MacrosFlg :: FilePath -> MacrosFlg
newtype TracesFlg
TracesFlg :: FilePath -> TracesFlg
newtype MaxStepsFlg
MaxStepsFlg :: Integer -> MaxStepsFlg
newtype MaxResultsFlg
MaxResultsFlg :: Integer -> MaxResultsFlg
newtype MetricsFlg
MetricsFlg :: [String] -> MetricsFlg
newtype MorphCmdFlg
MorphCmdFlg :: String -> MorphCmdFlg
newtype MorphInfoFlg
MorphInfoFlg :: FilePath -> MorphInfoFlg
newtype OptimisationsFlg
OptimisationsFlg :: [Optimisation] -> OptimisationsFlg
newtype OutputFileFlg
OutputFileFlg :: String -> OutputFileFlg
newtype PartialFlg
PartialFlg :: () -> PartialFlg
newtype RankingConstraintsFlg
RankingConstraintsFlg :: FilePath -> RankingConstraintsFlg
newtype RootFeatureFlg
RootFeatureFlg :: (Flist GeniVal) -> RootFeatureFlg
newtype NoLoadTestSuiteFlg
NoLoadTestSuiteFlg :: () -> NoLoadTestSuiteFlg
newtype StatsFileFlg
StatsFileFlg :: FilePath -> StatsFileFlg
newtype TestCaseFlg
TestCaseFlg :: Text -> TestCaseFlg
newtype TestInstructionsFlg
TestInstructionsFlg :: [Instruction] -> TestInstructionsFlg
newtype TestSuiteFlg
TestSuiteFlg :: FilePath -> TestSuiteFlg
newtype TimeoutFlg
TimeoutFlg :: Int -> TimeoutFlg
newtype VerboseModeFlg
VerboseModeFlg :: () -> VerboseModeFlg
newtype VersionFlg
VersionFlg :: () -> VersionFlg
newtype ViewCmdFlg
ViewCmdFlg :: String -> ViewCmdFlg
newtype BuilderFlg
BuilderFlg :: BuilderType -> BuilderFlg
newtype GrammarTypeFlg
GrammarTypeFlg :: GrammarType -> GrammarTypeFlg
newtype WeirdFlg
WeirdFlg :: String -> WeirdFlg
instance Typeable Optimisation
instance Typeable BuilderType
instance Typeable GrammarType
instance Typeable Flag
instance Typeable BatchDirFlg
instance Typeable DisableGuiFlg
instance Typeable DetectPolaritiesFlg
instance Typeable DumpDerivationFlg
instance Typeable EarlyDeathFlg
instance Typeable FromStdinFlg
instance Typeable HelpFlg
instance Typeable InstructionsFileFlg
instance Typeable LexiconFlg
instance Typeable MacrosFlg
instance Typeable TracesFlg
instance Typeable MaxStepsFlg
instance Typeable MaxResultsFlg
instance Typeable MetricsFlg
instance Typeable MorphCmdFlg
instance Typeable MorphInfoFlg
instance Typeable OptimisationsFlg
instance Typeable OutputFileFlg
instance Typeable PartialFlg
instance Typeable RankingConstraintsFlg
instance Typeable RootFeatureFlg
instance Typeable NoLoadTestSuiteFlg
instance Typeable StatsFileFlg
instance Typeable TestCaseFlg
instance Typeable TestInstructionsFlg
instance Typeable TestSuiteFlg
instance Typeable TimeoutFlg
instance Typeable VerboseModeFlg
instance Typeable VersionFlg
instance Typeable ViewCmdFlg
instance Typeable BuilderFlg
instance Typeable GrammarTypeFlg
instance Typeable WeirdFlg
instance Show Optimisation
instance Eq Optimisation
instance Eq BuilderType
instance Show GrammarType
instance Eq GrammarType
instance Eq BatchDirFlg
instance Eq DisableGuiFlg
instance Eq DetectPolaritiesFlg
instance Eq DumpDerivationFlg
instance Eq EarlyDeathFlg
instance Eq FromStdinFlg
instance Eq HelpFlg
instance Eq InstructionsFileFlg
instance Eq LexiconFlg
instance Eq MacrosFlg
instance Eq TracesFlg
instance Eq MaxStepsFlg
instance Eq MaxResultsFlg
instance Eq MetricsFlg
instance Eq MorphCmdFlg
instance Eq MorphInfoFlg
instance Eq OptimisationsFlg
instance Eq OutputFileFlg
instance Eq PartialFlg
instance Eq RankingConstraintsFlg
instance Eq RootFeatureFlg
instance Eq NoLoadTestSuiteFlg
instance Eq StatsFileFlg
instance Eq TestCaseFlg
instance Eq TestInstructionsFlg
instance Eq TestSuiteFlg
instance Eq TimeoutFlg
instance Eq VerboseModeFlg
instance Eq VersionFlg
instance Eq ViewCmdFlg
instance Eq BuilderFlg
instance Eq GrammarTypeFlg
instance Eq WeirdFlg
instance Eq Flag
instance HasFlags [Flag]
instance Show BuilderType


-- | We use a flat semantics in GenI (bag of literals).
module NLP.GenI.Semantics

-- | A single semantic literal containing its handle, predicate, and
--   arguments
--   
--   This can be paramaterised on the kinds of variables it uses, for
--   example, <a>GeniVal</a> for a semantics that you might still want to
--   do unification on or <a>Text</a> if it's supposed to be ground.
data Literal gv
Literal :: gv -> gv -> [gv] -> Literal gv

-- | the handle can be seen as a special kind of argument; stored
--   separately
lHandle :: Literal gv -> gv
lPredicate :: Literal gv -> gv
lArgs :: Literal gv -> [gv]

-- | A semantics is just a set of literals.
type Sem = [Literal GeniVal]

-- | A literal and any constraints associated with it (semantic input)
type LitConstr = (Literal GeniVal, [Text])

-- | Semantics, index constraints, literal constraints
--   
--   The intention here is that for <tt>(sem, icons, lcons)</tt> <tt>all
--   (<a>elem</a> sem) lcons</tt>
type SemInput = (Sem, Flist GeniVal, [LitConstr])

-- | An empty literal, not sure you should really be using this
emptyLiteral :: Literal GeniVal

-- | Strip any index or literal constraints from an input. Use with care.
removeConstraints :: SemInput -> SemInput

-- | Default sorting for a semantics
sortSem :: Ord a => [Literal a] -> [Literal a]

-- | Default comparison for a literal
compareOnLiteral :: Ord a => Literal a -> Literal a -> Ordering

-- | Sort primarily putting the ones with the most constants first and
--   secondarily by the number of instances a predicate occurs (if plain
--   string; atomic disjunction/vars treated as infinite)
sortByAmbiguity :: Sem -> Sem

-- | Anything that we would want to count the number constants in (as
--   opposed to variables)
class HasConstants a
constants :: HasConstants a => a -> Int

-- | Helper for displaying or pretty printing a semantic input
--   
--   This gives you a bit of control over how each literal is displayed
displaySemInput :: ([LitConstr] -> Text) -> SemInput -> Text

-- | Is a handle generated by GenI. GenI lets you write literals without a
--   handle; in these cases a unique handle is generated and hidden from
--   the UI.
isInternalHandle :: Text -> Bool

-- | <tt>x <a>subsumeSem</a> y</tt> returns all the possible ways to unify
--   <tt>x</tt> with some SUBSET of <tt>y</tt> so that <tt>x</tt> subsumes
--   <tt>y</tt>. If <tt>x</tt> does NOT subsume <tt>y</tt>, we return the
--   empty list.
subsumeSem :: Sem -> Sem -> [(Sem, Subst)]

-- | Helper for <a>subsumeSem</a> traversal
subsumeSemH :: Sem -> Sem -> [(Sem, Subst)]

-- | <tt>p1 <a>subsumeLiteral</a> p2</tt> is the unification of <tt>p1</tt>
--   and <tt>p2</tt> if both literals have the same arity, and the handles,
--   predicates, and arguments in <tt>p1</tt> all subsume their
--   counterparts in <tt>p2</tt>
subsumeLiteral :: MonadUnify m => Literal GeniVal -> Literal GeniVal -> m (Literal GeniVal, Subst)

-- | Return the list of minimal ways to unify two semantics, ie. where any
--   literals that are not the product of a succesful unification really do
--   not unify with anything else.
unifySem :: Sem -> Sem -> [(Sem, Subst)]

-- | Helper traversal for <a>unifySem</a>
unifySemH :: Sem -> Sem -> [(Sem, Subst)]

-- | Two literals unify if they have the same arity, and their handles,
--   predicates, and arguments also unify
unifyLiteral :: MonadUnify m => Literal GeniVal -> Literal GeniVal -> m (Literal GeniVal, Subst)
instance Typeable1 Literal
instance Eq gv => Eq (Literal gv)
instance Data gv => Data (Literal gv)
instance Binary g => Binary (Literal g)
instance NFData g => NFData (Literal g)
instance GeniShow LitConstr
instance GeniShow SemInput
instance Pretty SemInput
instance GeniShow (Literal GeniVal)
instance Pretty (Literal GeniVal)
instance GeniShow Sem
instance Pretty Sem
instance DescendGeniVal a => DescendGeniVal (Literal a)
instance HasConstants (Literal GeniVal)
instance HasConstants a => HasConstants [a]
instance HasConstants GeniVal
instance Collectable a => Collectable (Literal a)
instance Ord gv => Ord (Literal gv)

module NLP.GenI.LexicalSelection.Types

-- | Left hand side of a path equation
data PathEqLhs
PeqInterface :: Text -> PathEqLhs
PeqJust :: NodePathEqLhs -> PathEqLhs
PeqUnknown :: Text -> PathEqLhs

-- | Path equations can either hit a feature or a node's lexeme attribute
data NodePathEqLhs
PeqFeat :: Text -> TopBottom -> Text -> NodePathEqLhs
PeqLex :: Text -> NodePathEqLhs
data TopBottom
Top :: TopBottom
Bottom :: TopBottom
type PathEqPair = (NodePathEqLhs, GeniVal)

-- | Parse a path equation using the GenI conventions This always succeeds,
--   but can return <tt>Just warning</tt> if anything anomalous comes up
--   FIXME : make more efficient
parsePathEq :: Text -> Writer [LexCombineError] PathEqLhs
showPathEqLhs :: PathEqLhs -> Text
data LexCombineError
BoringError :: Text -> LexCombineError
FamilyNotFoundError :: Text -> LexCombineError
SchemaError :: [Text] -> LexCombineError2 -> LexCombineError
data LexCombineError2
EnrichError :: PathEqLhs -> LexCombineError2
StringError :: Text -> LexCombineError2
showLexCombineError :: LexCombineError -> (Text, Text)
compressLexCombineErrors :: [LexCombineError] -> [LexCombineError]
instance Eq TopBottom
instance Ord TopBottom
instance Eq NodePathEqLhs
instance Ord NodePathEqLhs
instance Eq PathEqLhs
instance Ord PathEqLhs
instance Eq LexCombineError2
instance Ord LexCombineError2
instance Eq LexCombineError
instance Pretty LexCombineError2
instance Pretty LexCombineError
instance Poset Text
instance Poset PathEqLhs
instance Poset LexCombineError2
instance Poset LexCombineError

module NLP.GenI.Morphology.Types
type MorphInputFn = Literal GeniVal -> Maybe (Flist GeniVal)
type MorphRealiser = [Flag] -> [LemmaPlusSentence] -> [MorphOutput]
data MorphOutput
MorphOutput :: [Text] -> [Text] -> MorphOutput
moWarnings :: MorphOutput -> [Text]
moRealisations :: MorphOutput -> [Text]

-- | A lemma plus its morphological features
data LemmaPlus
LemmaPlus :: Text -> Flist GeniVal -> LemmaPlus
lpLemma :: LemmaPlus -> Text
lpFeats :: LemmaPlus -> Flist GeniVal

-- | A sentence composed of <a>LemmaPlus</a> instead of plain old words
type LemmaPlusSentence = [LemmaPlus]
instance Ord MorphOutput
instance Eq MorphOutput
instance Eq LemmaPlus
instance Ord LemmaPlus
instance NFData LemmaPlus
instance NFData MorphOutput


-- | Internals of lexical entry manipulation
module NLP.GenI.Lexicon.Internal

-- | Collection of lexical entries
type Lexicon = [LexEntry]

-- | Lexical entry
data LexEntry
LexEntry :: FullList Text -> Text -> [GeniVal] -> Flist GeniVal -> Flist GeniVal -> Flist GeniVal -> Sem -> [SemPols] -> LexEntry

-- | normally just a singleton, useful for merging synonyms
iword :: LexEntry -> FullList Text

-- | tree family to anchor to
ifamname :: LexEntry -> Text

-- | parameters (deprecrated; use the interface)
iparams :: LexEntry -> [GeniVal]

-- | features to unify with tree schema interface
iinterface :: LexEntry -> Flist GeniVal

-- | features to pick out family members we want
ifilters :: LexEntry -> Flist GeniVal

-- | path equations
iequations :: LexEntry -> Flist GeniVal

-- | lexical semantics
isemantics :: LexEntry -> Sem

-- | polarities (must be same length as <a>isemantics</a>)
isempols :: LexEntry -> [SemPols]

-- | See also <a>mkFullLexEntry</a> This version comes with some sensible
--   defaults.
mkLexEntry :: FullList Text -> Text -> [GeniVal] -> Flist GeniVal -> Flist GeniVal -> Flist GeniVal -> Sem -> LexEntry

-- | Variant of <a>mkLexEntry</a> but with more control
mkFullLexEntry :: FullList Text -> Text -> [GeniVal] -> Flist GeniVal -> Flist GeniVal -> Flist GeniVal -> Sem -> [SemPols] -> LexEntry

-- | An annotated GeniVal. This is for a rather old, obscure variant on the
--   polarity filtering optimisation. To account for zero literal
--   semantics, we annotate each value in the semantics with a
--   positive/negative marker. These markers are then counted up to
--   determine with we need to insert more literals into the semantics or
--   not. See the manual on polarity filtering for more details
type PolValue = (GeniVal, Int)

-- | Separate an input lexical semantics into the actual semantics and the
--   semantic polarity entries (which aren't used very much in practice,
--   being a sort of experimental feature to solve an obscure-ish technical
--   problem)
fromLexSem :: [Literal PolValue] -> (Sem, [SemPols])

-- | Note that by convention we ignore the polarity associated with the
--   predicate itself
fromLexLiteral :: Literal PolValue -> (Literal GeniVal, SemPols)
instance Typeable LexEntry
instance Eq LexEntry
instance Data LexEntry
instance NFData LexEntry
instance Binary LexEntry
instance Pretty LexEntry
instance GeniShow [LexEntry]
instance GeniShow LexEntry
instance Collectable LexEntry
instance DescendGeniVal LexEntry


-- | Lexical entries
--   
--   As a factorisation technique, LTAG grammars are commonly separated
--   into tree schemata (see <a>TreeSchema</a>) and lexical entries. The
--   grammar is what you get by “anchoring” each lexical entry to the
--   relevant tree schemata.
module NLP.GenI.Lexicon

-- | Collection of lexical entries
type Lexicon = [LexEntry]

-- | Lexical entry
data LexEntry

-- | See also <a>mkFullLexEntry</a> This version comes with some sensible
--   defaults.
mkLexEntry :: FullList Text -> Text -> [GeniVal] -> Flist GeniVal -> Flist GeniVal -> Flist GeniVal -> Sem -> LexEntry

-- | Variant of <a>mkLexEntry</a> but with more control
mkFullLexEntry :: FullList Text -> Text -> [GeniVal] -> Flist GeniVal -> Flist GeniVal -> Flist GeniVal -> Sem -> [SemPols] -> LexEntry

-- | normally just a singleton, useful for merging synonyms
iword :: LexEntry -> FullList Text

-- | tree family to anchor to
ifamname :: LexEntry -> Text

-- | parameters (deprecrated; use the interface)
iparams :: LexEntry -> [GeniVal]

-- | features to unify with tree schema interface
iinterface :: LexEntry -> Flist GeniVal

-- | features to pick out family members we want
ifilters :: LexEntry -> Flist GeniVal

-- | path equations
iequations :: LexEntry -> Flist GeniVal

-- | lexical semantics
isemantics :: LexEntry -> Sem

-- | polarities (must be same length as <a>isemantics</a>)
isempols :: LexEntry -> [SemPols]

-- | An annotated GeniVal. This is for a rather old, obscure variant on the
--   polarity filtering optimisation. To account for zero literal
--   semantics, we annotate each value in the semantics with a
--   positive/negative marker. These markers are then counted up to
--   determine with we need to insert more literals into the semantics or
--   not. See the manual on polarity filtering for more details
type PolValue = (GeniVal, Int)

-- | Separate an input lexical semantics into the actual semantics and the
--   semantic polarity entries (which aren't used very much in practice,
--   being a sort of experimental feature to solve an obscure-ish technical
--   problem)
fromLexSem :: [Literal PolValue] -> (Sem, [SemPols])

-- | Note that by convention we ignore the polarity associated with the
--   predicate itself
fromLexLiteral :: Literal PolValue -> (Literal GeniVal, SemPols)


-- | This module provides basic datatypes specific to Tree Adjoining
--   Grammar tree schemata.
module NLP.GenI.TreeSchema
type Macros = [SchemaTree]
type SchemaTree = Ttree (GNode SchemaVal)
data Ttree a
TT :: [GeniVal] -> Text -> Text -> Flist GeniVal -> Ptype -> Maybe Sem -> [Text] -> Tree a -> Ttree a
params :: Ttree a -> [GeniVal]
pfamily :: Ttree a -> Text
pidname :: Ttree a -> Text
pinterface :: Ttree a -> Flist GeniVal
ptype :: Ttree a -> Ptype
psemantics :: Ttree a -> Maybe Sem
ptrace :: Ttree a -> [Text]
tree :: Ttree a -> Tree a
data Ptype
Initial :: Ptype
Auxiliar :: Ptype
root :: Tree a -> a
rootUpd :: Tree a -> a -> Tree a
foot :: Tree (GNode a) -> GNode a

-- | Given a lexical item <tt>l</tt> and a tree node <tt>n</tt> (actually a
--   subtree with no children), return the same node with the lexical item
--   as its unique child. The idea is that it converts terminal lexeme
--   nodes into preterminal nodes where the actual terminal is the given
--   lexical item
setLexeme :: [Text] -> Tree (GNode a) -> Tree (GNode a)

-- | Given a lexical item <tt>s</tt> and a Tree GNode t, returns the tree
--   t' where l has been assigned to the anchor node in t'
setAnchor :: FullList Text -> Tree (GNode a) -> Tree (GNode a)

-- | Attributes recognised as lexemes, in order of preference
lexemeAttributes :: [Text]
crushTreeGNode :: Tree (GNode SchemaVal) -> Maybe (Tree (GNode GeniVal))

-- | Essentially boolean representation of adjunction constraint
data AdjunctionConstraint
MaybeAdj :: AdjunctionConstraint

-- | hard-coded null-adjunction constraint
ExplicitNoAdj :: AdjunctionConstraint

-- | inferred by GenI to be adjunction free (ie. during realisation)
InferredNoAdj :: AdjunctionConstraint
isAdjConstrained :: GNode gv -> Bool

-- | Add an inferred adjunction constraint marker unless we already see an
--   explicit one
addInferredAdjConstraint :: GNode gv -> GNode gv

-- | A single node of a TAG tree.
data GNode gv
GN :: NodeName -> Flist gv -> Flist gv -> Bool -> [Text] -> GType -> AdjunctionConstraint -> Text -> GNode gv
gnname :: GNode gv -> NodeName

-- | top feature structure
gup :: GNode gv -> Flist gv

-- | bottom feature structure
gdown :: GNode gv -> Flist gv

-- | <tt>False</tt> for na nodes
ganchor :: GNode gv -> Bool

-- | <tt>[]</tt> for na nodes
glexeme :: GNode gv -> [Text]
gtype :: GNode gv -> GType
gaconstr :: GNode gv -> AdjunctionConstraint

-- | for TAG, this would be the elementary tree that this node originally
--   came from
gorigin :: GNode gv -> Text
gnnameIs :: NodeName -> GNode gv -> Bool
type NodeName = Text
data GType
Subs :: GType
Foot :: GType
Lex :: GType
Other :: GType

-- | Return the value of the <a>cat</a> attribute, if available
gCategory :: Flist GeniVal -> Maybe GeniVal
showLexeme :: [Text] -> Text

-- | A schema value is a disjunction of GenI values. It allows us to
--   express “fancy” disjunctions in tree schemata, ie. disjunctions over
--   variables and not just atoms (<tt>?X;?Y</tt>).
--   
--   Our rule is that that when a tree schema is instantiated, any fancy
--   disjunctions must be “crushed” into a single <a>GeniVal</a> lest it be
--   rejected (see <a>crushOne</a>)
--   
--   Note that this is still not recursive; we don't have disjunction over
--   schema values, nor can schema values refer to schema values. It just
--   allows us to express the idea that in tree schemata, you can have
--   either variable <tt>?X</tt> or <tt>?Y</tt>.
data SchemaVal
crushGNode :: GNode SchemaVal -> Maybe (GNode GeniVal)
instance [overlap ok] Typeable Ptype
instance [overlap ok] Typeable1 Ttree
instance [overlap ok] Typeable AdjunctionConstraint
instance [overlap ok] Typeable GType
instance [overlap ok] Typeable1 GNode
instance [overlap ok] Show Ptype
instance [overlap ok] Eq Ptype
instance [overlap ok] Data Ptype
instance [overlap ok] Data a => Data (Ttree a)
instance [overlap ok] Eq a => Eq (Ttree a)
instance [overlap ok] Eq AdjunctionConstraint
instance [overlap ok] Data AdjunctionConstraint
instance [overlap ok] Show GType
instance [overlap ok] Eq GType
instance [overlap ok] Data GType
instance [overlap ok] Eq gv => Eq (GNode gv)
instance [overlap ok] Data gv => Data (GNode gv)
instance [overlap ok] NFData gv => NFData (GNode gv)
instance [overlap ok] NFData Ptype
instance [overlap ok] NFData GType
instance [overlap ok] Binary a => Binary (Ttree a)
instance [overlap ok] NFData AdjunctionConstraint
instance [overlap ok] Binary AdjunctionConstraint
instance [overlap ok] Binary GType
instance [overlap ok] Binary gv => Binary (GNode gv)
instance [overlap ok] Binary Ptype
instance [overlap ok] GeniShow gv => GeniShow (GNode gv)
instance [overlap ok] Pretty (GNode GeniVal)
instance [overlap ok] GeniShow a => GeniShow [Ttree a]
instance [overlap ok] GeniShow a => GeniShow (Ttree a)
instance [overlap ok] GeniShow Ptype
instance [overlap ok] DescendGeniVal v => DescendGeniVal (GNode v)
instance [overlap ok] Collectable gv => Collectable (GNode gv)
instance [overlap ok] Collectable a => Collectable (Tree a)
instance [overlap ok] DescendGeniVal a => DescendGeniVal (Map k a)
instance [overlap ok] Collectable a => Collectable (Ttree a)
instance [overlap ok] DescendGeniVal v => DescendGeniVal (Ttree v)


-- | This module provides basic datatypes specific to Tree Adjoining
--   Grammar (TAG) elementary trees and some low-level operations.
module NLP.GenI.Tag

-- | An anchored grammar. The grammar associates a set of semantic
--   predicates to a list of trees each.
type Tags = Map String [TagElem]
data TagElem
TE :: Text -> Text -> Integer -> Ptype -> Tree (GNode GeniVal) -> Sem -> Map PolarityKey (Int, Int) -> Flist GeniVal -> [Text] -> [SemPols] -> TagElem
idname :: TagElem -> Text
ttreename :: TagElem -> Text
tidnum :: TagElem -> Integer
ttype :: TagElem -> Ptype
ttree :: TagElem -> Tree (GNode GeniVal)
tsemantics :: TagElem -> Sem
tpolarities :: TagElem -> Map PolarityKey (Int, Int)
tinterface :: TagElem -> Flist GeniVal
ttrace :: TagElem -> [Text]

-- | can be empty
tsempols :: TagElem -> [SemPols]

-- | <a>TagItem</a> is a generalisation of <a>TagElem</a>.
class TagItem t
tgIdName :: TagItem t => t -> Text
tgIdNum :: TagItem t => t -> Integer
tgSemantics :: TagItem t => t -> Sem
tgTree :: TagItem t => t -> Tree (GNode GeniVal)
data TagSite
TagSite :: Text -> Flist GeniVal -> Flist GeniVal -> Text -> TagSite
tsName :: TagSite -> Text
tsUp :: TagSite -> Flist GeniVal
tsDown :: TagSite -> Flist GeniVal
tsOrigin :: TagSite -> Text
type TagDerivation = [DerivationStep]
data DerivationStep
SubstitutionStep :: Text -> Text -> Text -> DerivationStep
AdjunctionStep :: Text -> Text -> Text -> DerivationStep
InitStep :: Text -> DerivationStep
dsChild :: DerivationStep -> Text
dsParent :: DerivationStep -> Maybe Text
dsParentSite :: DerivationStep -> Maybe Text
ts_synIncomplete :: Text
ts_semIncomplete :: [Literal GeniVal] -> Text
ts_tbUnificationFailure :: Text -> Text
ts_rootFeatureMismatch :: Flist GeniVal -> Text

-- | <tt>addTags</tt> <tt>tags key elem</tt> adds <tt>elem</tt> to the the
--   list of elements associated to the key
addToTags :: Tags -> String -> TagElem -> Tags

-- | Normally, extracting the sentences from a TAG tree would just consist
--   of reading its leaves. But if you want the generator to return
--   inflected forms instead of just lemmas, you also need to return the
--   relevant features for each leaf. In TAG, or at least our use of it,
--   the features come from the *pre-terminal* nodes, that is, not the
--   leaves themselves but their parents. Another bit of trickiness:
--   because of atomic disjunction, leaves might have more than one value,
--   so we can't just return a String lemma but a list of String, one for
--   each possibility.
tagLeaves :: TagElem -> [(NodeName, UninflectedDisjunction)]

-- | Try in order: lexeme, lexeme attributes, node name
getLexeme :: GNode GeniVal -> [Text]
toTagSite :: GNode GeniVal -> TagSite

-- | Assigns a unique id to each element of this list, that is, an integer
--   between 1 and the size of the list.
setTidnums :: [TagElem] -> [TagElem]

-- | Plug the first tree into the second tree at the specified node.
--   Anything below the second node is silently discarded. We assume the
--   trees are pluggable; it is treated as a bug if they are not!
plugTree :: Tree NodeName -> NodeName -> Tree NodeName -> Tree NodeName

-- | Given two trees <tt>auxt</tt> and <tt>t</tt>, splice the tree
--   <tt>auxt</tt> into <tt>t</tt> via the TAG adjunction rule.
spliceTree :: NodeName -> Tree NodeName -> NodeName -> Tree NodeName -> Tree NodeName

-- | Sorts trees into a Map.Map organised by the first literal of their
--   semantics. This is useful in at least three places: the polarity
--   optimisation, the gui display code, and code for measuring the
--   efficiency of GenI. Note: trees with a null semantics are filed under
--   an empty predicate, if any.
mapBySem :: TagItem t => [t] -> Map (Literal GeniVal) [t]

-- | <tt>collect x m</tt> increments our count for any variables in
--   <tt>x</tt> (adds not-yet-seen variables as needed)
collect :: Collectable a => a -> Map CollectedVar Int -> Map CollectedVar Int

-- | Given a tree(GNode) returns a list of substitution or adjunction
--   nodes, as well as remaining nodes with a null adjunction constraint.
detectSites :: Tree (GNode GeniVal) -> ([NodeName], [NodeName], [NodeName])
instance Typeable TagSite
instance Typeable TagElem
instance Eq TagSite
instance Ord TagSite
instance Data TagSite
instance Eq TagElem
instance Data TagElem
instance Show DerivationStep
instance Ord DerivationStep
instance Eq DerivationStep
instance NFData DerivationStep
instance NFData TagElem
instance Pretty [TagSite]
instance GeniShow [TagElem]
instance GeniShow TagElem
instance TagItem TagElem
instance Idable TagElem
instance Collectable TagElem
instance DescendGeniVal TagSite
instance DescendGeniVal TagElem
instance Ord TagElem
instance JSON DerivationStep

module NLP.GenI.Warning.Internal

-- | This exists because we want the <a>Monoid</a> instance, providing a
--   GenI-specific notion of appending which merges instances of the same
--   error
newtype GeniWarnings
GeniWarnings :: [GeniWarning] -> GeniWarnings
fromGeniWarnings :: GeniWarnings -> [GeniWarning]
mkGeniWarnings :: [GeniWarning] -> GeniWarnings
data GeniWarning

-- | A warning that should be repeated for each lexical entry affected
LexWarning :: [LexEntry] -> LexWarning -> GeniWarning

-- | A single custom warning
CustomLexWarning :: Text -> GeniWarning

-- | Literals which did not receive any lexical selection
NoLexSelection :: [Literal GeniVal] -> GeniWarning

-- | Warnings from the morphological realiser
MorphWarning :: [Text] -> GeniWarning
data LexWarning
LexCombineAllSchemataFailed :: LexWarning
LexCombineOneSchemaFailed :: LexCombineError -> LexWarning
MissingCoanchors :: Text -> Int -> LexWarning

-- | Sort, treating non-comporable items as equal
posort :: Poset a => [a] -> [a]
sortWarnings :: GeniWarnings -> GeniWarnings
appendWarning :: GeniWarning -> [GeniWarning] -> [GeniWarning]
mergeWarning :: GeniWarning -> GeniWarning -> Maybe GeniWarning

-- | A warning may be displayed over several lines
showGeniWarning :: GeniWarning -> [Text]
type WordFamilyCount = Map (FullList Text, Text) Int
toWfCount :: [LexEntry] -> WordFamilyCount
instance Eq LexWarning
instance Eq GeniWarning
instance Poset LexWarning
instance Poset GeniWarning
instance Monoid GeniWarnings


-- | Typed warnings as an easier alternative to strings.
--   
--   This makes it easier to recognise repeated warnings and print them out
--   in a reasonable way
module NLP.GenI.Warning

-- | This exists because we want the <a>Monoid</a> instance, providing a
--   GenI-specific notion of appending which merges instances of the same
--   error
data GeniWarnings
fromGeniWarnings :: GeniWarnings -> [GeniWarning]
mkGeniWarnings :: [GeniWarning] -> GeniWarnings
sortWarnings :: GeniWarnings -> GeniWarnings
data GeniWarning

-- | A warning that should be repeated for each lexical entry affected
LexWarning :: [LexEntry] -> LexWarning -> GeniWarning

-- | A single custom warning
CustomLexWarning :: Text -> GeniWarning

-- | Literals which did not receive any lexical selection
NoLexSelection :: [Literal GeniVal] -> GeniWarning

-- | Warnings from the morphological realiser
MorphWarning :: [Text] -> GeniWarning
data LexWarning
LexCombineAllSchemataFailed :: LexWarning
LexCombineOneSchemaFailed :: LexCombineError -> LexWarning
MissingCoanchors :: Text -> Int -> LexWarning

-- | A warning may be displayed over several lines
showGeniWarning :: GeniWarning -> [Text]

module NLP.GenI.Polarity.Internal
data PolarityDetectionResult
PD_UserError :: String -> PolarityDetectionResult
PD_Nothing :: PolarityDetectionResult
PD_Just :: [(PolarityKey, Interval)] -> PolarityDetectionResult
PD_Unconstrained :: (Text, Interval) -> PolarityDetectionResult

-- | Given a description of what the root feature should unify with return
--   a -1 polarity for all relevant polarity keys. This allows us to
--   compensate for the root node of any derived tree.
detectRootCompensation :: Set PolarityAttr -> FeatStruct GeniVal -> PolMap
detectPolsH :: Set PolarityAttr -> TagElem -> [(PolarityKey, Interval)]
detectPolarity :: Int -> PolarityAttr -> FeatStruct GeniVal -> FeatStruct GeniVal -> PolarityDetectionResult
toZero :: Int -> Interval
substNodes :: TagElem -> [GNode GeniVal]
substTops :: TagElem -> [Flist GeniVal]
type SemMap = Map (Literal GeniVal) [TagElem]
type PolMap = Map PolarityKey Interval
polarityKeys :: [TagElem] -> PolMap -> [PolarityKey]

-- | Convert any unconstrained polarities in a <a>PolMap</a> to constrained
--   ones, assuming a global list of known constrained keys.
convertUnconstrainedPolarities :: [PolarityKey] -> PolMap -> PolMap
addPols :: [(PolarityKey, Interval)] -> PolMap -> PolMap

-- | Ensures that all states and transitions in the polarity automaton are
--   unique. This is a slight optimisation so that we don't have to
--   repeatedly check the automaton for state uniqueness during its
--   construction, but it is essential that this check be done after
--   construction
nubAut :: (Ord ab, Ord st) => NFA st ab -> NFA st ab
__cat__ :: Text
__idx__ :: Text

-- | Note that this will crash if any of the entries are errors
pdResults :: [PolarityDetectionResult] -> [(PolarityKey, Interval)]

-- | Note that this will crash if any of the entries are errors
pdToList :: (String -> String) -> PolarityDetectionResult -> [(PolarityKey, Interval)]

module NLP.GenI.Polarity
type PolAut = NFA PolState PolTrans
data PolState

-- | position in the input semantics, extra semantics, polarity interval
PolSt :: Int -> [Literal GeniVal] -> [(Int, Int)] -> PolState
type AutDebug = (PolarityKey, PolAut, PolAut)

-- | intermediate auts, seed aut, final aut, potentially modified sem
data PolResult
PolResult :: [AutDebug] -> PolAut -> PolAut -> Sem -> PolResult
prIntermediate :: PolResult -> [AutDebug]
prInitial :: PolResult -> PolAut
prFinal :: PolResult -> PolAut
prSem :: PolResult -> Sem

-- | Constructs a polarity automaton. For debugging purposes, it returns
--   all the intermediate automata produced by the construction algorithm.
buildAutomaton :: Set PolarityAttr -> FeatStruct GeniVal -> PolMap -> SemInput -> [TagElem] -> PolResult
type PolPathSet = IntSet

-- | Given a list of paths (i.e. a list of list of trees) return a list of
--   trees such that each tree is annotated with the paths it belongs to.
detectPolPaths :: [[TagElem]] -> [(TagElem, PolPathSet)]
hasSharedPolPaths :: PolPathSet -> PolPathSet -> Bool
polPathsToList :: PolPathSet -> [Int]

-- | A (trivially) packed representation of the singleton set containing a
--   single polarity path
singletonPolPath :: Int -> PolPathSet
emptyPolPaths :: PolPathSet
polPathsNull :: PolPathSet -> Bool
intersectPolPaths :: PolPathSet -> PolPathSet -> PolPathSet
unionPolPaths :: PolPathSet -> PolPathSet -> PolPathSet
makePolAut :: [TagElem] -> Sem -> PolMap -> [PolarityKey] -> PolResult

-- | Returns a modified input semantics and lexical selection in which
--   pronouns are properly accounted for.
fixPronouns :: (Sem, [TagElem]) -> (Sem, [TagElem])
detectSansIdx :: [TagElem] -> [TagElem]
suggestPolFeatures :: [TagElem] -> [Text]
detectPols :: Set PolarityAttr -> TagElem -> TagElem
declareIdxConstraints :: Flist GeniVal -> PolMap
detectIdxConstraints :: Flist GeniVal -> Flist GeniVal -> PolMap

-- | Render the list of polarity automaton paths as a string
prettyPolPaths :: PolPathSet -> Text

-- | Returns all possible paths through an automaton from the start state
--   to any dead-end.
--   
--   Each path is represented as a list of labels.
--   
--   We assume that the automaton does not have any loops in it.
automatonPaths :: (Ord st, Ord ab) => (NFA st ab) -> [[ab]]

-- | <a>finalSt</a> returns all the final states of an automaton
finalSt :: NFA st ab -> [st]

-- | Note: you can define the final state either by setting
--   <a>isFinalSt</a> to <tt>Just f</tt> where <tt>f</tt> is some function
--   or by putting them in <a>finalStList</a>
data NFA st ab
instance Eq PolState
instance Ord PolState
instance Show PolState


-- | The heavy lifting of GenI, the whole chart/agenda mechanism, can be
--   implemented in many ways. To make it easier to write different
--   algorithms for GenI and compare them, we provide a single interface
--   for what we call Builders.
--   
--   This interface is then used called by the Geni module and by the
--   graphical interface. Note that each builder has its own graphical
--   interface and that we do a similar thing in the graphical interface
--   code to make it possible to use these GUIs.
module NLP.GenI.Builder
type TagDerivation = [DerivationStep]
data Builder st it
Builder :: (Input -> [Flag] -> (st, Statistics)) -> BuilderState st () -> BuilderState st () -> (st -> GenStatus) -> (st -> [Output]) -> (st -> [Output]) -> Builder st it

-- | initialise the machine from the semantics and lexical selection
init :: Builder st it -> Input -> [Flag] -> (st, Statistics)

-- | run a realisation step
step :: Builder st it -> BuilderState st ()

-- | run all realisations steps until completion
stepAll :: Builder st it -> BuilderState st ()

-- | determine if realisation is finished
finished :: Builder st it -> st -> GenStatus

-- | unpack chart results into a list of sentences
unpack :: Builder st it -> st -> [Output]
partial :: Builder st it -> st -> [Output]
data GenStatus
Finished :: GenStatus
Active :: GenStatus
Error :: Text -> GenStatus

-- | The names of lexically selected chart items used in a derivation
lexicalSelection :: TagDerivation -> [Text]
data FilterStatus a
Filtered :: FilterStatus a
NotFiltered :: a -> FilterStatus a
incrCounter :: String -> Int -> BuilderState st ()
num_iterations :: String

-- | Sequence two dispatch filters.
(>-->) :: Monad s => DispatchFilter s a -> DispatchFilter s a -> DispatchFilter s a
num_comparisons :: String
chart_size :: String
type SemBitMap = Map (Literal GeniVal) BitVector

-- | assign a bit vector value to each literal in the semantics the
--   resulting map can then be used to construct a bit vector
--   representation of the semantics
defineSemanticBits :: Sem -> SemBitMap
semToBitVector :: SemBitMap -> Sem -> BitVector
bitVectorToSem :: SemBitMap -> BitVector -> Sem

-- | Dispatching consists of assigning a chart item to the right part of
--   the chart (agenda, trash, results list, etc). This is implemented as a
--   series of filters which can either fail or succeed. If a filter fails,
--   it may modify the item before passing it on to future filters.
type DispatchFilter s a = a -> s (FilterStatus a)

-- | If the item meets some condition, use the first filter, otherwise use
--   the second one.
condFilter :: Monad s => (a -> Bool) -> DispatchFilter s a -> DispatchFilter s a -> DispatchFilter s a

-- | Default implementation for the <a>stepAll</a> function in
--   <a>Builder</a>
defaultStepAll :: Builder st it -> BuilderState st ()
type BuilderState s a = StateT s (State Statistics) a
data UninflectedDisjunction
UninflectedDisjunction :: [Text] -> (Flist GeniVal) -> UninflectedDisjunction

-- | <a>Input</a> represents the set of inputs a backend could take
data Input
Input :: SemInput -> [LexEntry] -> [(TagElem, PolPathSet)] -> Input
inSemInput :: Input -> SemInput

-- | for the debugger
inLex :: Input -> [LexEntry]

-- | tag tree
inCands :: Input -> [(TagElem, PolPathSet)]

-- | Equivalent to <a>id</a> unless the input contains an empty or
--   uninstatiated semantics
unlessEmptySem :: Input -> [Flag] -> a -> a
initStats :: [Flag] -> Statistics
type Output = (Integer, LemmaPlusSentence, TagDerivation)

-- | A SentenceAut represents a set of sentences in the form of an
--   automaton. The labels of the automaton are the words of the sentence.
--   But note! “word“ in the sentence is in fact a tuple (lemma,
--   inflectional feature structures). Normally, the states are defined as
--   integers, with the only requirement being that each one, naturally
--   enough, is unique.
type SentenceAut = NFA Int LemmaPlus

-- | Performs surface realisation from an input semantics and a lexical
--   selection.
--   
--   Statistics tracked
--   
--   <ul>
--   <li>pol_used_bundles - number of bundled paths through the polarity
--   automaton. see <a>automatonPathSets</a></li>
--   <li>pol_used_paths - number of paths through the final automaton</li>
--   <li>pol_seed_paths - number of paths through the seed automaton (i.e.
--   with no polarities). This is normally just 1, unless you have
--   multi-literal semantics</li>
--   <li>pol_total_states - combined number of states in the all the
--   polarity automata</li>
--   <li>pol_total_tras - combined number of transitions in all polarity
--   automata</li>
--   <li>pol_max_states - number of states in the polarity automaton with
--   the most states</li>
--   <li>pol_total_tras - number of transitions in the polarity automata
--   with the most transitions</li>
--   <li>sem_literals - number of literals in the input semantics</li>
--   <li>lex_trees - total number of lexically selected trees</li>
--   </ul>
run :: Builder st it -> Input -> [Flag] -> (st, Statistics)
queryCounter :: String -> Statistics -> Maybe Int
defaultMetricNames :: [String]
preInit :: Input -> [Flag] -> (Input, PolResult)
instance Typeable UninflectedDisjunction
instance Data UninflectedDisjunction
instance NFData Input
instance Pretty GenStatus
instance Collectable UninflectedDisjunction
instance DescendGeniVal UninflectedDisjunction

module NLP.GenI.OptimalityTheory
data OtConstraint

-- | the trace must appear
PositiveC :: Text -> OtConstraint

-- | the trace must NOT appear
NegativeC :: Text -> OtConstraint

-- | these traces must not appear AT THE SAME TIME
NegativeConjC :: [Text] -> OtConstraint
type OtRanking = [[OtConstraint]]
type GetTraces = Text -> [Text]
type OtResult x = (Int, x, [OtViolation])
data OtViolation
data RankedOtConstraint
RankedOtConstraint :: Int -> OtConstraint -> RankedOtConstraint
rankResults :: GetTraces -> (a -> TagDerivation) -> OtRanking -> [a] -> [OtResult a]
otWarnings :: Macros -> OtRanking -> [OtViolation] -> [Text]
prettyViolations :: GetTraces -> Bool -> [OtViolation] -> Text
prettyRank :: Int -> Text
instance Show OtConstraint
instance Eq OtConstraint
instance Show RankedOtConstraint
instance Eq RankedOtConstraint
instance Eq RankedOtConstraint2
instance Show OtViolation
instance Eq OtViolation
instance Ord OtViolation
instance Ord LexItem
instance Eq LexItem
instance Show LexItem
instance NFData OtConstraint
instance NFData RankedOtConstraint
instance NFData OtViolation
instance Pretty OtConstraint
instance Pretty RankedOtConstraint
instance JSON OtViolation
instance JSON RankedOtConstraint
instance JSON OtConstraint
instance Ord RankedOtConstraint2
instance Ord RankedOtConstraint

module NLP.GenI.Control

-- | Inputs that go around a single testcase/input
data Params
Params :: Maybe BuilderType -> [Flag] -> [Flag] -> Maybe OtRanking -> Params
builderType :: Params -> Maybe BuilderType

-- | Custom morph realiser may define a custom set of flags that it accepts
morphFlags :: Params -> [Flag]
geniFlags :: Params -> [Flag]

-- | OT constraints (optional, uses global if unset)
ranking :: Params -> Maybe OtRanking
updateParams :: Params -> Params -> Params
instance HasFlags Params

module NLP.GenI.TestSuite
data TestCase sem
TestCase :: Text -> Text -> sem -> [Text] -> Maybe Params -> TestCase sem
tcName :: TestCase sem -> Text

-- | for gui
tcSemString :: TestCase sem -> Text
tcSem :: TestCase sem -> sem

-- | expected results (for testing)
tcExpected :: TestCase sem -> [Text]
tcParams :: TestCase sem -> Maybe Params
instance GeniShow sem => Pretty (TestCase sem)
instance GeniShow sem => GeniShow (TestCase sem)

module NLP.GenI.Parser
geniTestSuite :: Parser [TestCase SemInput]
geniSemanticInput :: Parser (Sem, Flist GeniVal, [LitConstr])

-- | Just the String representations of the semantics in the test suite
geniTestSuiteString :: Parser [Text]

-- | This is only used by the script genimakesuite
geniDerivations :: Parser [TestCaseOutput]
geniMacros :: Parser [SchemaTree]

-- | This makes it possible to read anchored trees, which may be useful for
--   debugging purposes.
--   
--   FIXME: note that this is very rudimentary; we do not set id numbers,
--   parse polarities. You'll have to call some of our helper functions if
--   you want that functionality.
geniTagElems :: Parser [TagElem]
geniLexicon :: Parser [LexEntry]
geniMorphInfo :: Parser [(Text, Flist GeniVal)]
geniFeats :: GeniValLike v => Parser (Flist v)
geniSemantics :: Parser Sem
geniValue :: Parser GeniVal
geniWords :: Parser Text
geniWord :: Parser Text
geniLanguageDef :: GenLanguageDef Text () Identity
tillEof :: Parser a -> Parser a
parseFromFile :: Parser a -> SourceName -> IO (Either ParseError a)
instance Eq Annotation
instance GeniValLike SchemaVal
instance GeniValLike GeniVal

module NLP.GenI.Configuration
getBuilderType :: Params -> BuilderType
getRanking :: Params -> OtRanking
mainBuilderTypes :: [BuilderType]

-- | The default parameters configuration
emptyParams :: Params
defineParams :: [Flag] -> Params -> Params
treatArgs :: [OptDescr Flag] -> [String] -> IO Params
treatArgsWithParams :: [OptDescr Flag] -> [String] -> Params -> IO Params

-- | Print out a GenI-style usage message with options divided into
--   sections
usage :: [OptSection] -> String -> String
basicSections :: [OptSection]
optionsSections :: [OptSection]

-- | Update the internal instructions list, test suite and case according
--   to the contents of an instructions file.
--   
--   Basic approach
--   
--   <ul>
--   <li>we always have instructions: if no instructions file, is specified
--   we infer virtual instructions from the test suite flag * the testsuite
--   and testcase flags are focusing tools, they pick out a subset from the
--   instructions</li>
--   </ul>
processInstructions :: Params -> IO Params

-- | Uses the GetOpt library to process the command line arguments. Note
--   that we divide them into basic and advanced usage.
optionsForStandardGenI :: [OptDescr Flag]
optionsForBasicStuff :: [OptDescr Flag]
optionsForOptimisation :: [OptDescr Flag]
optionsForMorphology :: [OptDescr Flag]
optionsForInputFiles :: [OptDescr Flag]
optionsForBuilder :: [OptDescr Flag]
optionsForTesting :: [OptDescr Flag]
helpOption :: OptDescr Flag
verboseOption :: OptDescr Flag
macrosOption :: OptDescr Flag
lexiconOption :: OptDescr Flag
nubBySwitches :: [OptDescr a] -> [OptDescr a]
noArg :: (Eq f, Typeable f) => (() -> f) -> ArgDescr Flag
reqArg :: (Eq f, Typeable f, Eq x, Typeable x) => (x -> f) -> (String -> x) -> String -> ArgDescr Flag
optArg :: (Eq f, Typeable f, Eq x, Typeable x) => (x -> f) -> x -> (String -> x) -> String -> ArgDescr Flag

-- | TODO: This is a horrible and abusive use of <a>error</a>
parseFlagWithParsec :: String -> Parser b -> Text -> b
readGlobalConfig :: IO (Maybe YamlLight)
setLoggers :: YamlLight -> IO ()

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class Typeable a
instance Show LogTo
instance Show LogFmt
instance Show LoggerConfig
instance IsString YamlLight
instance Read LogFmt
instance Read LogTo


-- | This module handles mostly everything to do with morphology in Geni.
--   There are two basic tasks: morphological input and output. GenI farms
--   out morphology to whatever third party program you specify on the
--   command line. Note that a simple and stupid `<tt>sillymorph'</tt>
--   realiser is provided either in the GenI repository or on hackage.
module NLP.GenI.Morphology

-- | Converts information from a morphological information file into GenI's
--   internal format.
readMorph :: [(Text, [AvPair GeniVal])] -> MorphInputFn

-- | Filters away from an input semantics any literals whose realisation is
--   strictly morphological. The first argument tells us helps identify the
--   morphological literals -- it associates literals with morphological
--   stuff; if it returns <a>Nothing</a>, then it is non-morphological
stripMorphSem :: MorphInputFn -> Sem -> Sem

-- | <a>attachMorph</a> <tt>morphfn sem cands</tt> does the bulk of the
--   morphological input processing. We use <tt>morphfn</tt> to determine
--   which literals in <tt>sem</tt> contain morphological information and
--   what information they contain. Then we attach this morphological
--   information to the relevant trees in <tt>cand</tt>. A tree is
--   considered relevant w.r.t to a morphological literal if its semantics
--   contains at least one literal whose first index is the same as the
--   first index of the morphological literal.
attachMorph :: MorphInputFn -> Sem -> [TagElem] -> [TagElem]

-- | <tt>setMorphAnchor n t</tt> replaces the anchor node of a tree with
--   <tt>n</tt>
--   
--   We assume the tree has exactly one anchor node. If it has none, this
--   explodes; if it has more than one, they all get replaced.
setMorphAnchor :: GNode GeniVal -> Tree (GNode GeniVal) -> Tree (GNode GeniVal)

-- | Converts a list of uninflected sentences into inflected ones by
--   calling
inflectSentencesUsingCmd :: String -> [LemmaPlusSentence] -> IO [(LemmaPlusSentence, MorphOutput)]

-- | Extracts the lemmas from a list of uninflected sentences. This is used
--   when the morphological generator is unavailable, doesn't work, etc.
sansMorph :: LemmaPlusSentence -> MorphOutput
instance Typeable MNAME
instance JSON LemmaPlus
instance JSON MorphOutput


-- | This module performs the core of lexical selection and anchoring.
module NLP.GenI.LexicalSelection

-- | This aims to support users who want to do lexical selection directly
--   from an input other than GenI style flat semantics.
--   
--   The requirement here is for you to provide some means of converting
--   the custom semantics to a GenI semantics
data CustomSem sem
CustomSem :: (sem -> Either Text SemInput) -> LexicalSelector sem -> (Text -> Either Text (TestCase sem)) -> (FilePath -> Text -> Either Text [TestCase sem]) -> (sem -> Text) -> CustomSem sem

-- | Conversion from custom semantics to GenI semantic input
fromCustomSemInput :: CustomSem sem -> sem -> Either Text SemInput

-- | Lexical selection function
customSelector :: CustomSem sem -> LexicalSelector sem
customSemParser :: CustomSem sem -> Text -> Either Text (TestCase sem)

-- | List of named inputs intended to act as a substitute for test suites
--   (<a>FilePath</a> argument is for reporting error messages only)
customSuiteParser :: CustomSem sem -> FilePath -> Text -> Either Text [TestCase sem]
customRenderSem :: CustomSem sem -> sem -> Text

-- | See <a>Configuration</a> if you want to use GenI with a custom lexical
--   selection function.
type LexicalSelector sem = Macros -> Lexicon -> sem -> IO LexicalSelection

-- | The result of the lexical selection process
data LexicalSelection
LexicalSelection :: [TagElem] -> [LexEntry] -> GeniWarnings -> LexicalSelection

-- | the main result: a set of elementary trees (ie. anchored trees)
lsAnchored :: LexicalSelection -> [TagElem]

-- | if available, lexical entries that were used to produce anchored trees
--   (useful for identifying anchoring failure)
lsLexEntries :: LexicalSelection -> [LexEntry]

-- | HINT: use <a>mempty</a> to initialise to empty
lsWarnings :: LexicalSelection -> GeniWarnings

-- | Performs standard GenI lexical selection as described in
--   <a>http://projects.haskell.org/GenI/manual/lexical-selection.html</a>
--   
--   This is just <a>defaultLexicalSelection</a> lifted into IO
defaultLexicalSelector :: Macros -> Lexicon -> SemInput -> IO LexicalSelection

-- | Helper for <a>defaultLexicalSelector</a> (Standard GenI lexical
--   selection is actually pure)
--   
--   This is just
--   
--   <ul>
--   <li><a>defaultLexicalChoice</a></li>
--   <li><a>defaultAnchoring</a></li>
--   <li><a>defaultPostProcessing</a></li>
--   </ul>
defaultLexicalSelection :: Macros -> Lexicon -> SemInput -> LexicalSelection

-- | <tt>missingLexEntries ts lexs</tt> returns any of the lexical
--   candidates <tt>lexs</tt> that were apparently not anchored
--   succesfully.
--   
--   TODO: it does this by (wrongly) checking for each lexical item to see
--   if any of the anchored trees in <tt>ts</tt> have identical semantics
--   to that lexical item. The better way to do this would be to throw a
--   subsumption check on top of items reported missing, because it's
--   possible for the trees to add semantics through unification.
missingLexEntries :: [TagElem] -> [LexEntry] -> [LexEntry]

-- | Select and returns the set of entries from the lexicon whose semantics
--   subsumes the input semantics.
defaultLexicalChoice :: Lexicon -> SemInput -> [LexEntry]

-- | <a>chooseCandI</a> <tt>sem l</tt> attempts to unify the semantics of
--   <tt>l</tt> with <tt>sem</tt> If this succeeds, we use return the
--   result(s); if it fails, we reject <tt>l</tt> as a lexical selection
--   candidate.
chooseCandI :: Sem -> [LexEntry] -> [LexEntry]

-- | <a>mergeSynonyms</a> is a factorisation technique that uses atomic
--   disjunction to merge all synonyms into a single lexical entry. Two
--   lexical entries are considered synonyms if their semantics match and
--   they point to the same tree families.
--   
--   FIXME: 2006-10-11 - note that this is no longer being used, because it
--   breaks the case where two lexical entries differ only by their use of
--   path equations. Perhaps it's worthwhile just to add a check that the
--   path equations match exactly.
mergeSynonyms :: [LexEntry] -> [LexEntry]

-- | The <a>LexCombine</a> monad supports warnings during lexical selection
--   and also failure via Maybe
type LexCombine a = MaybeT (Writer [LexCombineError]) a
runLexCombine :: LexCombine a -> (Maybe a, [LexCombineError])

-- | Note an anchoring error
lexTell :: LexCombineError -> LexCombine ()

-- | <tt>defaultAnchoring schemata lex sem</tt> implements the later half
--   of lexical selection (tree anchoring and enrichement). It assumes that
--   <tt>lex</tt> consists just of the lexical items that have been
--   selected, and tries to combine them with the tree schemata.
--   
--   This function may be useful if you are implementing your own lexical
--   selection functions, and you want GenI to take over after you've given
--   it a <tt>[LexEntry]</tt>
defaultAnchoring :: SemInput -> Macros -> [LexEntry] -> LexicalSelection

-- | Given a lexical item, looks up the tree families for that item, and
--   anchor the item to the trees.
combineList :: Sem -> Macros -> LexEntry -> ([LexCombineError], [TagElem])

-- | Combine a single tree with its lexical item to form a bonafide
--   TagElem. This process can fail, however, because of filtering or
--   enrichement
combineOne :: Sem -> LexEntry -> SchemaTree -> LexCombine [TagElem]

-- | See <a>http://projects.haskell.org/manual/lexical-selection</a> on
--   enrichement
enrich :: LexEntry -> SchemaTree -> LexCombine SchemaTree

-- | Helper for <a>enrich</a> (enrich by single path equation)
enrichBy :: SchemaTree -> PathEqPair -> LexCombine SchemaTree

-- | Helper for <a>enrichBy</a>
maybeEnrichBy :: SchemaTree -> PathEqPair -> Maybe (SchemaTree, Subst)

-- | <tt>enrichFeat av fs</tt> attempts to unify <tt>av</tt> with
--   <tt>fs</tt>
--   
--   Note here that <tt>fs</tt> is an <tt>Flist [GeniVal]</tt> rather than
--   the usual <tt>Flist GeniVal</tt> you may expect. This is because it
--   comes from <a>SchemaTree</a> which allows non-atomic disjunctions of
--   <tt>GeniVal</tt> which have to be flatten down to at most atomic
--   disjunctions once lexical selection is complete.
enrichFeat :: MonadUnify m => AvPair GeniVal -> Flist SchemaVal -> m (Flist SchemaVal, Subst)

-- | <tt>missingCoanchors l t</tt> returns the list of coanchor node names
--   from <tt>l</tt> that were not found in <tt>t</tt>
missingCoanchors :: LexEntry -> SchemaTree -> [Text]

-- | Split a lex entry's path equations into interface enrichement
--   equations or (co-)anchor modifiers
lexEquations :: LexEntry -> Writer [LexCombineError] ([AvPair GeniVal], [PathEqPair])

-- | <tt>seekCoanchor lhs t</tt> returns <tt>Just node</tt> if <tt>t</tt>
--   contains exactly one node that can be identified by <tt>lhs</tt>,
--   <tt>Nothing</tt> if it contains none.
--   
--   It crashes if there is more than one such node, because this should
--   have been caught earlier by GenI.
seekCoanchor :: NodePathEqLhs -> SchemaTree -> Maybe (GNode SchemaVal)

-- | <tt>matchNodeName lhs n</tt> is <tt>True</tt> if the <tt>lhs</tt>
--   refers to the node <tt>n</tt>
matchNodeName :: NodePathEqLhs -> GNode SchemaVal -> Bool

-- | <tt>matchNodeNameHelper</tt> recognises “anchor“ by convention;
--   otherwise, it does a name match
matchNodeNameHelper :: Text -> GNode SchemaVal -> Bool

-- | The lemanchor mechanism is described in
--   <a>http://projects.haskell.org/manual/lexical-selection</a>
setLemAnchors :: Tree (GNode GeniVal) -> Tree (GNode GeniVal)

-- | The name of the lemanchor attribute (by convention; see source)
_lemanchor :: Text

-- | <tt>setOrigin n t</tt> marks the nodes in <tt>t</tt> as having come
--   from a tree named <tt>n</tt>
setOrigin :: Text -> Tree (GNode v) -> Tree (GNode v)

-- | Standard post-processing/filtering steps that can take place after
--   lexical selection. Right now, this only consists of paraphrase
--   selection
defaultPostProcessing :: SemInput -> LexicalSelection -> LexicalSelection

-- | Rule out lexical selection results that violate trace constraints
preselectParaphrases :: [LitConstr] -> [TagElem] -> [TagElem]

-- | <a>True</a> if the tree fulfills the supplied trace constraints
respectsConstraints :: [LitConstr] -> TagElem -> Bool


-- | This is the interface between the front and backends of the generator.
--   The GUI and the console interface both talk to this module, and in
--   turn, this module talks to the input file parsers and the surface
--   realisation engine.
module NLP.GenI

-- | The program state consists of its configuration options and abstract,
--   cleaned up representations of all the data it's had to load into
--   memory (tree schemata files, lexicon files, etc). The intention is for
--   the state to stay static until the next time something triggers some
--   file loading.
data ProgState
ProgState :: Params -> Macros -> Lexicon -> MorphInputFn -> [Text] -> Maybe MorphRealiser -> ProgState

-- | the current configuration
pa :: ProgState -> Params

-- | tree schemata
gr :: ProgState -> Macros

-- | lexical entries
le :: ProgState -> Lexicon

-- | function to extract morphological information from the semantics (you
--   may instead be looking for <a>customMorph</a>)
morphinf :: ProgState -> MorphInputFn

-- | simplified traces (optional)
traces :: ProgState -> [Text]
customMorph :: ProgState -> Maybe MorphRealiser
type ProgStateRef = IORef ProgState

-- | The program state when you start GenI for the very first time
emptyProgState :: Params -> ProgState

-- | See <a>Configuration</a> if you want to use GenI with a custom lexical
--   selection function.
type LexicalSelector sem = Macros -> Lexicon -> sem -> IO LexicalSelection

-- | Entry point! (the most useful function to know here)
--   
--   <ul>
--   <li>Initialises the realiser (lexical selection, among other
--   things),</li>
--   <li>Runs the builder (the surface realisation engine proper)</li>
--   <li>Unpacks the builder results</li>
--   <li>Finalises the results (morphological generation)</li>
--   </ul>
--   
--   In addition to the results, this returns a generator state. The latter
--   is is mostly useful for debugging via the graphical interface. Note
--   that we assumes that you have already loaded in your grammar and
--   parsed your input semantics.
runGeni :: ProgState -> CustomSem sem -> Builder st it -> TestCase sem -> ErrorIO (GeniResults, st)

-- | <tt>simplifyResults <a>$</a> runGenI...'</tt> for an easier time if
--   you don't need the surface realiser state
simplifyResults :: Either Text (GeniResults, st) -> GeniResults

-- | Standard GenI semantics and lexical selection algorithm (with optional
--   <a>preanchored</a> mode)
defaultCustomSem :: ProgState -> IO (CustomSem SemInput)

-- | <a>GeniResults</a> is the outcome of running GenI on a single input
--   semantics. Each distinct result is returned as a single
--   <a>GeniResult</a> (NB: a single result may expand into multiple
--   strings through morphological post-processing),
data GeniResults
GeniResults :: [GeniResult] -> [Text] -> Statistics -> GeniResults

-- | one per chart item
grResults :: GeniResults -> [GeniResult]

-- | usually from lexical selection
grGlobalWarnings :: GeniResults -> [Text]

-- | things like number of chart items to help study efficiency
grStatistics :: GeniResults -> Statistics
data GeniResult
GError :: GeniError -> GeniResult
GSuccess :: GeniSuccess -> GeniResult
isSuccess :: GeniResult -> Bool
data GeniError
GeniError :: [Text] -> GeniError
data GeniSuccess
GeniSuccess :: LemmaPlusSentence -> [Text] -> ResultType -> [Text] -> TagDerivation -> Integer -> [GeniLexSel] -> Int -> [OtViolation] -> GeniSuccess

-- | “original” uninflected result
grLemmaSentence :: GeniSuccess -> LemmaPlusSentence

-- | results after morphology
grRealisations :: GeniSuccess -> [Text]
grResultType :: GeniSuccess -> ResultType

-- | warnings “local” to this particular item, cf. <a>grGlobalWarnings</a>
grWarnings :: GeniSuccess -> [Text]

-- | derivation tree behind the result
grDerivation :: GeniSuccess -> TagDerivation

-- | normally a chart item id
grOrigin :: GeniSuccess -> Integer

-- | the lexical selection behind this result (info only)
grLexSelection :: GeniSuccess -> [GeniLexSel]

-- | see <a>OptimalityTheory</a>
grRanking :: GeniSuccess -> Int

-- | which OT constraints were violated
grViolations :: GeniSuccess -> [OtViolation]
data GeniLexSel
GeniLexSel :: Text -> [Text] -> GeniLexSel
nlTree :: GeniLexSel -> Text
nlTrace :: GeniLexSel -> [Text]
data ResultType
CompleteResult :: ResultType
PartialResult :: ResultType

-- | <a>initGeni</a> performs lexical selection and strips the input
--   semantics of any morpohological literals
--   
--   See <a>defaultCustomSem</a>
initGeni :: ProgState -> CustomSem sem -> sem -> ErrorIO (Input, GeniWarnings)

-- | This is a helper to <tt>runGenI</tt>. It's mainly useful if you are
--   building interactive GenI debugging tools.
--   
--   Given a builder state,
--   
--   <ul>
--   <li>Unpacks the builder results</li>
--   <li>Finalises the results (morphological generation)</li>
--   </ul>
extractResults :: ProgState -> Maybe Params -> Builder st it -> st -> IO [GeniResult]

-- | No morphology! Pretend the lemma string is a sentence
lemmaSentenceString :: GeniSuccess -> Text
prettyResult :: ProgState -> GeniSuccess -> Text

-- | Show the sentences produced by the generator, in a relatively compact
--   form
showRealisations :: [String] -> String
histogram :: Ord a => [a] -> Map a Int

-- | <a>getTraces</a> is most likely useful for grammars produced by a
--   metagrammar system. Given a tree name, we retrieve the
--   `<tt>trace'</tt> information from the grammar for all trees that have
--   this name. We assume the tree name was constructed by GenI; see the
--   source code for details.
getTraces :: ProgState -> Text -> [Text]

-- | We have one master function that loads all the files GenI is expected
--   to use. This just calls the sub-loaders below, some of which are
--   exported for use by the graphical interface. The master function also
--   makes sure to complain intelligently if some of the required files are
--   missing.
loadEverything :: ProgStateRef -> CustomSem sem -> IO ()

-- | The file loading functions all work the same way: we load the file,
--   and try to parse it. If this doesn't work, we just fail in IO, and
--   GenI dies. If we succeed, we update the program state passed in as an
--   IORef.
class Loadable x
lParse :: Loadable x => FilePath -> Text -> Either Text x
lSet :: Loadable x => x -> ProgState -> ProgState
lSummarise :: Loadable x => x -> String
loadLexicon :: ProgStateRef -> IO Lexicon

-- | The macros are stored as a hashing function in the monad.
loadGeniMacros :: ProgStateRef -> IO Macros
loadTestSuite :: ProgState -> CustomSem sem -> IO [TestCase sem]
parseSemInput :: Text -> Either ParseError SemInput
loadRanking :: ProgStateRef -> IO ()
data BadInputException
BadInputException :: String -> Text -> BadInputException

-- | Load something from a string rather than a file
loadFromString :: Loadable a => ProgStateRef -> String -> Text -> IO a
instance Typeable BadInputException
instance Typeable MNAME
instance Show BadInputException
instance Ord GeniError
instance Eq GeniError
instance Ord GeniLexSel
instance Eq GeniLexSel
instance Ord ResultType
instance Eq ResultType
instance Ord GeniSuccess
instance Eq GeniSuccess
instance Ord GeniResult
instance Eq GeniResult
instance NFData GeniLexSel
instance NFData ResultType
instance NFData GeniError
instance NFData GeniSuccess
instance NFData GeniResult
instance JSON GeniLexSel
instance JSON ResultType
instance JSON GeniError
instance JSON GeniSuccess
instance JSON GeniResult
instance JSON GeniResults
instance Loadable PreAnchoredL
instance Pretty GeniError
instance Loadable TestSuiteL
instance Loadable OtRanking
instance Loadable TracesL
instance Loadable MorphFnL
instance Loadable Macros
instance Loadable Lexicon
instance Exception BadInputException
instance HasFlags ProgState

module NLP.GenI.Simple.SimpleBuilder
type Agenda = [SimpleItem]
type AuxAgenda = [SimpleItem]
type Chart = [SimpleItem]
data SimpleStatus
type SimpleState a = BuilderState SimpleStatus a
data SimpleItem
SimpleItem :: ChartId -> [NodeName] -> [NodeName] -> BitVector -> PolPathSet -> [GNode GeniVal] -> Tree Text -> NodeName -> Maybe NodeName -> [NodeName] -> TagDerivation -> SimpleGuiItem -> SimpleItem
siId :: SimpleItem -> ChartId
siSubstnodes :: SimpleItem -> [NodeName]
siAdjnodes :: SimpleItem -> [NodeName]
siSemantics :: SimpleItem -> BitVector
siPolpaths :: SimpleItem -> PolPathSet

-- | actually a set
siNodes :: SimpleItem -> [GNode GeniVal]
siDerived :: SimpleItem -> Tree Text
siRoot_ :: SimpleItem -> NodeName
siFoot_ :: SimpleItem -> Maybe NodeName
siPendingTb :: SimpleItem -> [NodeName]
siDerivation :: SimpleItem -> TagDerivation
siGuiStuff :: SimpleItem -> SimpleGuiItem
simpleBuilder_1p :: SimpleBuilder
simpleBuilder_2p :: SimpleBuilder
simpleBuilder :: Bool -> SimpleBuilder
theAgenda :: SimpleStatus -> Agenda
theHoldingPen :: SimpleStatus -> AuxAgenda
theChart :: SimpleStatus -> Chart
theResults :: SimpleStatus -> [SimpleItem]

-- | Creates an initial SimpleStatus.
initSimpleBuilder :: Bool -> Input -> [Flag] -> (SimpleStatus, Statistics)
addToAgenda :: SimpleItem -> SimpleState ()
addToChart :: SimpleItem -> SimpleState ()
genconfig :: SimpleStatus -> [Flag]

-- | Things whose only use is within the graphical debugger
data SimpleGuiItem
SimpleGuiItem :: [Text] -> [Text] -> Sem -> Text -> SimpleGuiItem

-- | nodes to highlight if there are things wrong with this item, what?
siHighlight :: SimpleGuiItem -> [Text]
siDiagnostic :: SimpleGuiItem -> [Text]
siFullSem :: SimpleGuiItem -> Sem
siIdname :: SimpleGuiItem -> Text
theTrash :: SimpleStatus -> Trash
step :: SimpleStatus -> GenerationPhase
unpackResult :: SimpleItem -> [Output]
testCanAdjoin :: SimpleItem -> TagSite -> Maybe (TagSite, TagSite, Subst)
testIapplyAdjNode :: Bool -> SimpleItem -> SimpleItem -> Maybe SimpleItem
testEmptySimpleGuiItem :: SimpleGuiItem
instance Typeable SimpleGuiItem
instance Show GenerationPhase
instance Data SimpleGuiItem
instance DescendGeniVal SimpleItem
instance DescendGeniVal (Text, UninflectedDisjunction)


-- | The console user interface including batch processing on entire test
--   suites.
module NLP.GenI.Console
consoleGeni :: ProgStateRef -> CustomSem sem -> IO ()

-- | Used in processing instructions files. Each instruction consists of a
--   suite file and a list of test case names from that file
--   
--   See <a>http://projects.haskell.org/GenI/manual/command-line.html</a>
--   for how testsuite, testcase, and instructions are expected to interact
--   
--   (Exported for use by regression testing code)
loadNextSuite :: ProgStateRef -> CustomSem sem -> (FilePath, Maybe [Text]) -> IO [TestCase sem]
instance Typeable MNAME

module NLP.GenI.Main
main :: IO ()
mainWithState :: ProgState -> CustomSem sem -> IO ()
forceGuiFlag :: Params -> Params

module BoolExp
data BoolExp a
Cond :: a -> BoolExp a
And :: (BoolExp a) -> (BoolExp a) -> BoolExp a
Or :: (BoolExp a) -> (BoolExp a) -> BoolExp a
Not :: (BoolExp a) -> BoolExp a
check :: (a -> Bool) -> BoolExp a -> Bool
