-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Library for incremental computing.
--   
--   This is a Haskell (plus some extensions) implementation of a library
--   for incremental computing. It closely follows the implementation in
--   the nice POPL 2002 paper <a>Adaptive Functional Programming</a>, by
--   Umut Acar, Guy Blelloch and Bob Harper.
@package Adaptive
@version 0.23

module Control.Monad.Adaptive.PriorityQueue
data PriorityQueue a
empty :: PriorityQueue a
insert :: Ord a => a -> PriorityQueue a -> PriorityQueue a
insertM :: Monad m => (a -> a -> m Ordering) -> a -> PriorityQueue a -> m (PriorityQueue a)
min :: PriorityQueue a -> Maybe (a, PriorityQueue a)

module Control.Monad.Adaptive.Ref
class EqRef r
eqRef :: EqRef r => r a -> r a -> Bool
class (EqRef r, Functor m, Monad m) => Ref m r | m -> r
newRef :: Ref m r => a -> m (r a)
readRef :: Ref m r => r a -> m a
writeRef :: Ref m r => r a -> a -> m ()
mapRef :: Ref m r => (a -> a) -> r a -> m ()
instance Ref IO IORef
instance EqRef IORef
instance Ref (ST s) (STRef s)
instance EqRef (STRef s)

module Control.Monad.Adaptive.CircularList
data CircularList m r a
circularList :: Ref m r => a -> m (CircularList m r a)
val :: Ref m r => CircularList m r a -> m a
update :: Ref m r => CircularList m r a -> a -> m ()
next :: Ref m r => CircularList m r a -> m (CircularList m r a)
previous :: Ref m r => CircularList m r a -> m (CircularList m r a)
insert :: Ref m r => CircularList m r a -> a -> m (CircularList m r a)
delete :: Ref m r => CircularList m r a -> m ()

module Control.Monad.Adaptive.MonadUtil
ifM :: Monad m => m Bool -> m a -> m a -> m a
whenM :: Monad m => m Bool -> m () -> m ()
unlessM :: Monad m => m Bool -> m () -> m ()

module Control.Monad.Adaptive.OrderedList
data Record m r a
data OrderedList m r a b
rval :: Ref m r => Record m r a -> OrderedList m r a a
next :: Ref m r => Record m r a -> OrderedList m r a (Record m r a)
order :: Ref m r => Record m r a -> Record m r a -> OrderedList m r a Ordering
delete :: Ref m r => Record m r a -> OrderedList m r a ()
spliceOut :: Ref m r => Record m r a -> Record m r a -> OrderedList m r a ()
deleted :: Ref m r => Record m r a -> OrderedList m r a Bool
insert :: Ref m r => Record m r a -> a -> OrderedList m r a (Record m r a)
base :: Ref m r => OrderedList m r a (Record m r a)
run :: Ref m r => OrderedList m r a b -> m b
inM :: Ref m r => m b -> OrderedList m r a b
record :: Ref m r => Record m r a -> OrderedList m r a (Bool, Integer, a)
instance (Ref m r, Integral b) => Integral (OrderedList m r a b)
instance Enum (OrderedList m r a b)
instance (Ref m r, Real b) => Real (OrderedList m r a b)
instance Ord (OrderedList m r a b)
instance (Ref m r, Num b) => Num (OrderedList m r a b)
instance Show (OrderedList m r a b)
instance Eq (OrderedList m r a b)
instance Ref m r => Ref (OrderedList m r a) r
instance Ref m r => Functor (OrderedList m r a)
instance Ref m r => Monad (OrderedList m r a)

module Control.Monad.Adaptive
data Adaptive m r a
data Changeable m r a
data Modifiable m r a
readMod :: Ref m r => Modifiable m r a -> Changeable m r a
class InM m'
inM :: (InM m', Ref m r) => m a -> m' m r a
change :: Ref m r => Modifiable m r a -> a -> Adaptive m r ()
propagate :: Ref m r => Adaptive m r ()
run :: Ref m r => Adaptive m r a -> m a
inCh :: Ref m r => Changeable m r a -> Adaptive m r a
class (Monad (n m r), Ref m r) => NewMod n m r
newModBy :: NewMod n m r => (a -> a -> Bool) -> Changeable m r a -> n m r (Modifiable m r a)
newMod :: (Eq a, NewMod n m r) => Changeable m r a -> n m r (Modifiable m r a)
instance Ref m r => NewMod Adaptive m r
instance Ref m r => NewMod Changeable m r
instance EqRef r => Eq (Modifiable m r a)
instance InM Adaptive
instance InM Changeable
instance Ref m r => Functor (Adaptive m r)
instance Ref m r => Monad (Adaptive m r)
instance Ref m r => Ref (Adaptive m r) r
instance Ref m r => Functor (Changeable m r)
instance Ref m r => Monad (Changeable m r)
instance Ref m r => Ref (Changeable m r) r
instance InOL Changeable
instance InOL Adaptive
