-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | native matrix based on vector
--   
@package matrices
@version 0.4.2

module Data.Matrix.Generic.Mutable
class MVector v a => MMatrix m v a
dim :: MMatrix m v a => m v s a -> (Int, Int)
unsafeRead :: (MMatrix m v a, PrimMonad s) => m v (PrimState s) a -> (Int, Int) -> s a
unsafeWrite :: (MMatrix m v a, PrimMonad s) => m v (PrimState s) a -> (Int, Int) -> a -> s ()
new :: (MMatrix m v a, PrimMonad s) => (Int, Int) -> s (m v (PrimState s) a)
replicate :: (MMatrix m v a, PrimMonad s) => (Int, Int) -> a -> s (m v (PrimState s) a)

-- | Derived methods
write :: (PrimMonad s, MMatrix m v a) => m v (PrimState s) a -> (Int, Int) -> a -> s ()
read :: (PrimMonad s, MMatrix m v a) => m v (PrimState s) a -> (Int, Int) -> s a

module Data.Matrix.Symmetric.Mutable

-- | mutable matrix
data SymMMatrix v s a
SymMMatrix :: !Int -> !(v s a) -> SymMMatrix v s a
dim :: MMatrix m v a => m v s a -> (Int, Int)

-- | Derived methods
write :: (PrimMonad s, MMatrix m v a) => m v (PrimState s) a -> (Int, Int) -> a -> s ()
unsafeWrite :: (MMatrix m v a, PrimMonad s) => m v (PrimState s) a -> (Int, Int) -> a -> s ()
read :: (PrimMonad s, MMatrix m v a) => m v (PrimState s) a -> (Int, Int) -> s a
unsafeRead :: (MMatrix m v a, PrimMonad s) => m v (PrimState s) a -> (Int, Int) -> s a

-- | Create a mutable matrix without initialization
new :: (MMatrix m v a, PrimMonad s) => (Int, Int) -> s (m v (PrimState s) a)
replicate :: (MMatrix m v a, PrimMonad s) => (Int, Int) -> a -> s (m v (PrimState s) a)
instance MVector v a => MMatrix SymMMatrix v a

module Data.Matrix.Generic
class (MMatrix (Mutable m) (Mutable v) a, Vector v a) => Matrix m v a where flatten mat = generate (r * c) $ \ i -> unsafeIndex mat (i `div` c, i `mod` c) where (r, c) = dim mat unsafeTakeRow mat i = generate c $ \ j -> unsafeIndex mat (i, j) where (_, c) = dim mat unsafeTakeColumn mat j = generate r $ \ i -> unsafeIndex mat (i, j) where (r, _) = dim mat takeDiag mat = generate n $ \ i -> unsafeIndex mat (i, i) where n = uncurry min . dim $ mat
dim :: Matrix m v a => m v a -> (Int, Int)
unsafeIndex :: Matrix m v a => m v a -> (Int, Int) -> a
unsafeFromVector :: Matrix m v a => (Int, Int) -> v a -> m v a
flatten :: Matrix m v a => m v a -> v a
unsafeTakeRow :: Matrix m v a => m v a -> Int -> v a
unsafeTakeColumn :: Matrix m v a => m v a -> Int -> v a
takeDiag :: Matrix m v a => m v a -> v a
thaw :: (Matrix m v a, PrimMonad s) => m v a -> s ((Mutable m) (Mutable v) (PrimState s) a)
unsafeThaw :: (Matrix m v a, PrimMonad s) => m v a -> s ((Mutable m) (Mutable v) (PrimState s) a)
freeze :: (Matrix m v a, PrimMonad s) => (Mutable m) (Mutable v) (PrimState s) a -> s (m v a)
unsafeFreeze :: (Matrix m v a, PrimMonad s) => (Mutable m) (Mutable v) (PrimState s) a -> s (m v a)

-- | Derived methods
--   
--   Return the number of rows
rows :: Matrix m v a => m v a -> Int

-- | Return the number of columns
cols :: Matrix m v a => m v a -> Int

-- | Indexing
(!) :: Matrix m v a => m v a -> (Int, Int) -> a
fromVector :: Matrix m v a => (Int, Int) -> v a -> m v a
fromList :: Matrix m v a => (Int, Int) -> [a] -> m v a
empty :: Matrix m v a => m v a

-- | O(m*n) Create a list by concatenating rows
toList :: Matrix m v a => m v a -> [a]

-- | O(m*n) Create matrix from list of lists, it doesn't check if the list
--   of list is a valid matrix
fromLists :: Matrix m v a => [[a]] -> m v a

-- | O(m*n) Matrix construction
matrix :: Matrix m v a => Int -> [a] -> m v a

-- | O(m*n) Create matrix from rows
fromRows :: Matrix m v a => [v a] -> m v a

-- | Extract a row.
takeRow :: Matrix m v a => m v a -> Int -> v a

-- | O(m) Return the rows
toRows :: Matrix m v a => m v a -> [v a]

-- | Extract a row.
takeColumn :: Matrix m v a => m v a -> Int -> v a

-- | O(m*n) Return the columns
toColumns :: Matrix m v a => m v a -> [v a]

-- | O(m*n) List of lists
toLists :: Matrix m v a => m v a -> [[a]]
create :: Matrix m v a => (forall s. ST s ((Mutable m) (Mutable v) s a)) -> m v a

module Data.Matrix.Symmetric

-- | Symmetric square matrix
data SymMatrix v a
SymMatrix :: !Int -> !(v a) -> SymMatrix v a
dim :: Matrix m v a => m v a -> (Int, Int)

-- | Derived methods
--   
--   Return the number of rows
rows :: Matrix m v a => m v a -> Int

-- | Return the number of columns
cols :: Matrix m v a => m v a -> Int
unsafeIndex :: Matrix m v a => m v a -> (Int, Int) -> a

-- | Indexing
(!) :: Matrix m v a => m v a -> (Int, Int) -> a

-- | Default algorithm is O((m*n) * O(unsafeIndex)).
flatten :: Matrix m v a => m v a -> v a
unsafeFromVector :: Matrix m v a => (Int, Int) -> v a -> m v a
fromVector :: Matrix m v a => (Int, Int) -> v a -> m v a

-- | Extract a row.
takeRow :: Matrix m v a => m v a -> Int -> v a
thaw :: (Matrix m v a, PrimMonad s) => m v a -> s ((Mutable m) (Mutable v) (PrimState s) a)
unsafeThaw :: (Matrix m v a, PrimMonad s) => m v a -> s ((Mutable m) (Mutable v) (PrimState s) a)
freeze :: (Matrix m v a, PrimMonad s) => (Mutable m) (Mutable v) (PrimState s) a -> s (m v a)
unsafeFreeze :: (Matrix m v a, PrimMonad s) => (Mutable m) (Mutable v) (PrimState s) a -> s (m v a)
create :: Matrix m v a => (forall s. ST s ((Mutable m) (Mutable v) s a)) -> m v a
map :: (Vector v a, Vector v b) => (a -> b) -> SymMatrix v a -> SymMatrix v b

-- | Upper triangular imap, i.e., i &lt;= j
imap :: (Vector v a, Vector v b) => ((Int, Int) -> a -> b) -> SymMatrix v a -> SymMatrix v b
zip :: (Vector v a, Vector v b, Vector v (a, b)) => SymMatrix v a -> SymMatrix v b -> SymMatrix v (a, b)
zipWith :: (Vector v a, Vector v b, Vector v c) => (a -> b -> c) -> SymMatrix v a -> SymMatrix v b -> SymMatrix v c
instance Show (v a) => Show (SymMatrix v a)
instance Vector v a => Matrix SymMatrix v a

module Data.Matrix.Dense.Generic.Mutable

-- | mutable matrix
data MMatrix v s a
MMatrix :: !Int -> !Int -> !Int -> !Int -> !(v s a) -> MMatrix v s a
dim :: MMatrix m v a => m v s a -> (Int, Int)
takeRow :: MVector v a => MMatrix v m a -> Int -> v m a

-- | Derived methods
write :: (PrimMonad s, MMatrix m v a) => m v (PrimState s) a -> (Int, Int) -> a -> s ()
unsafeWrite :: (MMatrix m v a, PrimMonad s) => m v (PrimState s) a -> (Int, Int) -> a -> s ()
read :: (PrimMonad s, MMatrix m v a) => m v (PrimState s) a -> (Int, Int) -> s a
unsafeRead :: (MMatrix m v a, PrimMonad s) => m v (PrimState s) a -> (Int, Int) -> s a

-- | Create a mutable matrix without initialization
new :: (MMatrix m v a, PrimMonad s) => (Int, Int) -> s (m v (PrimState s) a)
replicate :: (MMatrix m v a, PrimMonad s) => (Int, Int) -> a -> s (m v (PrimState s) a)
instance MVector v a => MMatrix MMatrix v a

module Data.Matrix.Storable.Mutable
type MMatrix a = MMatrix MVector a

module Data.Matrix.Unboxed.Mutable
type MMatrix a = MMatrix MVector a

module Data.Matrix.Sparse.Generic
class Eq a => Zero a
zero :: Zero a => a

-- | Compressed Sparse Row (CSR) matrix
data CSR v a
CSR :: !Int -> !Int -> !(v a) -> !(Vector Int) -> !(Vector Int) -> CSR v a
type AssocList a = [((Int, Int), a)]
dim :: Matrix m v a => m v a -> (Int, Int)

-- | Derived methods
--   
--   Return the number of rows
rows :: Matrix m v a => m v a -> Int

-- | Return the number of columns
cols :: Matrix m v a => m v a -> Int
unsafeIndex :: Matrix m v a => m v a -> (Int, Int) -> a

-- | Indexing
(!) :: Matrix m v a => m v a -> (Int, Int) -> a

-- | Extract a row.
takeRow :: Matrix m v a => m v a -> Int -> v a

-- | Extract a row.
takeColumn :: Matrix m v a => m v a -> Int -> v a

-- | Extract the diagonal. Default algorithm is O(min(m,n) *
--   O(unsafeIndex)).
takeDiag :: Matrix m v a => m v a -> v a

-- | Construct CSR from ascending association list. Items must be sorted
--   first by row index, and then by column index.
fromAscAL :: Vector v a => (Int, Int) -> Int -> AssocList a -> CSR v a
unsafeFromVector :: Matrix m v a => (Int, Int) -> v a -> m v a
fromVector :: Matrix m v a => (Int, Int) -> v a -> m v a

-- | O(m*n) Matrix construction
matrix :: Matrix m v a => Int -> [a] -> m v a

-- | O(m*n) Create matrix from list of lists, it doesn't check if the list
--   of list is a valid matrix
fromLists :: Matrix m v a => [[a]] -> m v a

-- | O(m*n) Create matrix from rows
fromRows :: Matrix m v a => [v a] -> m v a
empty :: Matrix m v a => m v a

-- | Default algorithm is O((m*n) * O(unsafeIndex)).
flatten :: Matrix m v a => m v a -> v a

-- | O(m) Return the rows
toRows :: Matrix m v a => m v a -> [v a]

-- | O(m*n) Return the columns
toColumns :: Matrix m v a => m v a -> [v a]

-- | O(m*n) Create a list by concatenating rows
toList :: Matrix m v a => m v a -> [a]

-- | O(m*n) List of lists
toLists :: Matrix m v a => m v a -> [[a]]
instance Show (v a) => Show (CSR v a)
instance (Zero a, Vector v a) => Matrix CSR v a
instance Eq a => Zero [a]
instance Zero Double
instance Zero Int

module Data.Matrix.Mutable
type MMatrix a = MMatrix MVector a

module Data.Matrix.Dense.Generic

-- | row-major matrix supporting efficient slice
data Matrix v a
Matrix :: !Int -> !Int -> !Int -> !Int -> !(v a) -> Matrix v a
dim :: Matrix m v a => m v a -> (Int, Int)

-- | Derived methods
--   
--   Return the number of rows
rows :: Matrix m v a => m v a -> Int

-- | Return the number of columns
cols :: Matrix m v a => m v a -> Int
unsafeIndex :: Matrix m v a => m v a -> (Int, Int) -> a

-- | Indexing
(!) :: Matrix m v a => m v a -> (Int, Int) -> a

-- | Extract a row.
takeRow :: Matrix m v a => m v a -> Int -> v a

-- | Extract a row.
takeColumn :: Matrix m v a => m v a -> Int -> v a

-- | Extract the diagonal. Default algorithm is O(min(m,n) *
--   O(unsafeIndex)).
takeDiag :: Matrix m v a => m v a -> v a
unsafeFromVector :: Matrix m v a => (Int, Int) -> v a -> m v a
fromVector :: Matrix m v a => (Int, Int) -> v a -> m v a

-- | O(m*n) Matrix construction
matrix :: Matrix m v a => Int -> [a] -> m v a

-- | O(m*n) Create matrix from list of lists, it doesn't check if the list
--   of list is a valid matrix
fromLists :: Matrix m v a => [[a]] -> m v a

-- | O(m*n) Create matrix from rows
fromRows :: Matrix m v a => [v a] -> m v a

-- | O(m*n) Create matrix from columns
fromColumns :: Vector v a => [v a] -> Matrix v a
empty :: Matrix m v a => m v a

-- | Default algorithm is O((m*n) * O(unsafeIndex)).
flatten :: Matrix m v a => m v a -> v a

-- | O(m) Return the rows
toRows :: Matrix m v a => m v a -> [v a]

-- | O(m*n) Return the columns
toColumns :: Matrix m v a => m v a -> [v a]

-- | O(m*n) Create a list by concatenating rows
toList :: Matrix m v a => m v a -> [a]

-- | O(m*n) List of lists
toLists :: Matrix m v a => m v a -> [[a]]

-- | O(m*n) Convert different matrix type
convert :: (Vector v a, Vector w a) => Matrix v a -> Matrix w a

-- | O(m*n) Matrix transpose
tr :: Vector v a => Matrix v a -> Matrix v a

-- | O(1) Extract sub matrix
subMatrix :: Vector v a => (Int, Int) -> (Int, Int) -> Matrix v a -> Matrix v a

-- | O(m*n) Create an identity matrix
ident :: (Num a, Vector v a) => Int -> Matrix v a

-- | O(m*n) Create a square matrix with given diagonal, other entries
--   default to 0
diag :: (Num a, Vector v a, Foldable t) => t a -> Matrix v a

-- | O(m*n) Create a rectangular matrix with default values and given
--   diagonal
diagRect :: (Vector v a, Foldable t) => a -> (Int, Int) -> t a -> Matrix v a
fromBlocks :: Vector v a => a -> [[Matrix v a]] -> Matrix v a
isSymmetric :: (Eq a, Vector v a) => Matrix v a -> Bool
force :: Vector v a => Matrix v a -> Matrix v a
foldl :: Vector v b => (a -> b -> a) -> a -> Matrix v b -> a
imap :: (Vector v a, Vector v b) => ((Int, Int) -> a -> b) -> Matrix v a -> Matrix v b
map :: (Vector v a, Vector v b) => (a -> b) -> Matrix v a -> Matrix v b
mapM :: (Vector v a, Vector v b, Monad m) => (a -> m b) -> Matrix v a -> m (Matrix v b)
mapM_ :: (Vector v a, Monad m) => (a -> m b) -> Matrix v a -> m ()
forM :: (Vector v a, Vector v b, Monad m) => Matrix v a -> (a -> m b) -> m (Matrix v b)
forM_ :: (Vector v a, Monad m) => Matrix v a -> (a -> m b) -> m ()
zipWith :: (Vector v a, Vector v b, Vector v c) => (a -> b -> c) -> Matrix v a -> Matrix v b -> Matrix v c
zipWith3 :: (Vector v a, Vector v b, Vector v c, Vector v d) => (a -> b -> c -> d) -> Matrix v a -> Matrix v b -> Matrix v c -> Matrix v d
zipWith4 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e) => (a -> b -> c -> d -> e) -> Matrix v a -> Matrix v b -> Matrix v c -> Matrix v d -> Matrix v e
zipWith5 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f) => (a -> b -> c -> d -> e -> f) -> Matrix v a -> Matrix v b -> Matrix v c -> Matrix v d -> Matrix v e -> Matrix v f
zipWith6 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f, Vector v g) => (a -> b -> c -> d -> e -> f -> g) -> Matrix v a -> Matrix v b -> Matrix v c -> Matrix v d -> Matrix v e -> Matrix v f -> Matrix v g
izipWith :: (Vector v a, Vector v b, Vector v c) => ((Int, Int) -> a -> b -> c) -> Matrix v a -> Matrix v b -> Matrix v c
izipWith3 :: (Vector v a, Vector v b, Vector v c, Vector v d) => ((Int, Int) -> a -> b -> c -> d) -> Matrix v a -> Matrix v b -> Matrix v c -> Matrix v d
izipWith4 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e) => ((Int, Int) -> a -> b -> c -> d -> e) -> Matrix v a -> Matrix v b -> Matrix v c -> Matrix v d -> Matrix v e
izipWith5 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f) => ((Int, Int) -> a -> b -> c -> d -> e -> f) -> Matrix v a -> Matrix v b -> Matrix v c -> Matrix v d -> Matrix v e -> Matrix v f
izipWith6 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f, Vector v g) => ((Int, Int) -> a -> b -> c -> d -> e -> f -> g) -> Matrix v a -> Matrix v b -> Matrix v c -> Matrix v d -> Matrix v e -> Matrix v f -> Matrix v g
zip :: (Vector v a, Vector v b, Vector v (a, b)) => Matrix v a -> Matrix v b -> Matrix v (a, b)
zip3 :: (Vector v a, Vector v b, Vector v c, Vector v (a, b, c)) => Matrix v a -> Matrix v b -> Matrix v c -> Matrix v (a, b, c)
zip4 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v (a, b, c, d)) => Matrix v a -> Matrix v b -> Matrix v c -> Matrix v d -> Matrix v (a, b, c, d)
zip5 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v (a, b, c, d, e)) => Matrix v a -> Matrix v b -> Matrix v c -> Matrix v d -> Matrix v e -> Matrix v (a, b, c, d, e)
zip6 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f, Vector v (a, b, c, d, e, f)) => Matrix v a -> Matrix v b -> Matrix v c -> Matrix v d -> Matrix v e -> Matrix v f -> Matrix v (a, b, c, d, e, f)
zipWithM :: (Monad m, Vector v a, Vector v b, Vector v c) => (a -> b -> m c) -> Matrix v a -> Matrix v b -> m (Matrix v c)
zipWithM_ :: (Monad m, Vector v a, Vector v b) => (a -> b -> m c) -> Matrix v a -> Matrix v b -> m ()
unzip :: (Vector v a, Vector v b, Vector v (a, b)) => Matrix v (a, b) -> (Matrix v a, Matrix v b)
unzip3 :: (Vector v a, Vector v b, Vector v c, Vector v (a, b, c)) => Matrix v (a, b, c) -> (Matrix v a, Matrix v b, Matrix v c)
unzip4 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v (a, b, c, d)) => Matrix v (a, b, c, d) -> (Matrix v a, Matrix v b, Matrix v c, Matrix v d)
unzip5 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v (a, b, c, d, e)) => Matrix v (a, b, c, d, e) -> (Matrix v a, Matrix v b, Matrix v c, Matrix v d, Matrix v e)
unzip6 :: (Vector v a, Vector v b, Vector v c, Vector v d, Vector v e, Vector v f, Vector v (a, b, c, d, e, f)) => Matrix v (a, b, c, d, e, f) -> (Matrix v a, Matrix v b, Matrix v c, Matrix v d, Matrix v e, Matrix v f)
sequence :: (Vector v a, Vector v (m a), Monad m) => Matrix v (m a) -> m (Matrix v a)
sequence_ :: (Vector v (m a), Monad m) => Matrix v (m a) -> m ()
generate :: Vector v a => (Int, Int) -> ((Int, Int) -> a) -> Matrix v a
thaw :: (Matrix m v a, PrimMonad s) => m v a -> s ((Mutable m) (Mutable v) (PrimState s) a)
unsafeThaw :: (Matrix m v a, PrimMonad s) => m v a -> s ((Mutable m) (Mutable v) (PrimState s) a)
freeze :: (Matrix m v a, PrimMonad s) => (Mutable m) (Mutable v) (PrimState s) a -> s (m v a)
unsafeFreeze :: (Matrix m v a, PrimMonad s) => (Mutable m) (Mutable v) (PrimState s) a -> s (m v a)
create :: Matrix m v a => (forall s. ST s ((Mutable m) (Mutable v) s a)) -> m v a
instance Show (v a) => Show (Matrix v a)
instance Vector v a => Matrix Matrix v a

module Data.Matrix.Storable
type Matrix a = Matrix Vector a

module Data.Matrix.Unboxed
type Matrix a = Matrix Vector a

module Data.Matrix
type Matrix = Matrix Vector
