-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Immutable disk-based B* trees
--   
--   Immutable disk-based B* trees
@package b-tree
@version 0.1.0.0

module BTree

-- | A tree leaf (e.g. key/value pair)
data BLeaf k e
BLeaf :: !k -> !e -> BLeaf k e

-- | The number of entries in a B-tree
type Size = Word64

-- | The maximum number of children of a B-tree inner node
type Order = Word64

-- | Build a B-tree into the given file.
--   
--   As the name suggests, this requires that the <tt>Producer</tt> emits
--   leaves in ascending key order.
fromOrderedToFile :: (MonadIO m, Binary e, Binary k) => Order -> Size -> FilePath -> Producer (BLeaf k e) m r -> m ()

-- | Build a B-tree into <tt>ByteString</tt>
--   
--   As the name suggests, this requires that the <tt>Producer</tt> emits
--   leaves in ascending key order.
--   
--   This is primarily used for testing. In particular, note that this is a
--   bad idea for large trees as the entire contents of the tree will need
--   to be kept in memory until all leaves have been added so that the
--   header can be prepended.
fromOrderedToByteString :: (Monad m, Binary e, Binary k) => Order -> Size -> Producer (BLeaf k e) m r -> m ByteString

-- | Build a B-tree into the given file.
--   
--   This does not assume that the leaves are produced in order. Instead,
--   the sorting is handled internally through a simple merge sort. Chunks
--   of leaves are collected, sorted in memory, and then written to
--   intermediate trees. At the end these trees are then merged.
fromUnorderedToFile :: (MonadIO m, Binary (BLeaf k e), Binary k, Binary e, Ord k) => FilePath -> Int -> Order -> FilePath -> Producer (BLeaf k e) m r -> EitherT String m ()

-- | A read-only B-tree for lookups
data LookupTree k e

-- | Open a B-tree file.
open :: FilePath -> IO (Either String (LookupTree k e))

-- | Read a B-tree from a <tt>ByteString</tt> produced by <a>Builder</a>
fromByteString :: ByteString -> Either String (LookupTree k e)

-- | Lookup a key in a B-tree.
lookup :: (Binary k, Binary e, Ord k) => LookupTree k e -> k -> Maybe e

-- | Merge several <tt>LookupTrees</tt>
--   
--   This is a convenience function for merging several trees already on
--   disk. For a more flexible interface, see <a>mergeLeaves</a>.
mergeTrees :: (MonadIO m, Functor m, Binary k, Binary e, Ord k) => (e -> e -> m e) -> Order -> FilePath -> [LookupTree k e] -> m ()

-- | Merge trees' leaves taking ordered leaves from a set of producers.
--   
--   Each producer must be annotated with the number of leaves it is
--   expected to produce. The size of the resulting tree will be at most
--   the sum of these sizes.
mergeLeaves :: (MonadIO m, Functor m, Binary k, Binary e, Ord k) => (e -> e -> m e) -> Order -> FilePath -> [(Size, Producer (BLeaf k e) m ())] -> m ()

-- | Get a sized <a>Producer</a> suitable for <a>mergeLeaves</a> from a
--   <a>LookupTree</a>
sizedProducerForTree :: (Monad m, Binary k, Binary e) => LookupTree k e -> (Size, Producer (BLeaf k e) m ())

-- | Iterate over the leaves of the given tree in ascending key order.
walkLeaves :: (Binary k, Binary v, Monad m) => LookupTree k v -> Producer (BLeaf k v) m (ByteString, Maybe String)
