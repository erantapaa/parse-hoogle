-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Support library for Template Haskell
--   
--   This package provides modules containing facilities for manipulating
--   Haskell source code using Template Haskell.
--   
--   See <a>http://www.haskell.org/haskellwiki/Template_Haskell</a> for
--   more information.
@package template-haskell
@version 2.10.0.0


-- | Abstract syntax definitions for Template Haskell.
module Language.Haskell.TH.Syntax
class Monad m => Quasi m
qNewName :: Quasi m => String -> m Name
qReport :: Quasi m => Bool -> String -> m ()
qRecover :: Quasi m => m a -> m a -> m a
qLookupName :: Quasi m => Bool -> String -> m (Maybe Name)
qReify :: Quasi m => Name -> m Info
qReifyInstances :: Quasi m => Name -> [Type] -> m [Dec]
qReifyRoles :: Quasi m => Name -> m [Role]
qReifyAnnotations :: (Quasi m, Data a) => AnnLookup -> m [a]
qReifyModule :: Quasi m => Module -> m ModuleInfo
qLocation :: Quasi m => m Loc
qRunIO :: Quasi m => IO a -> m a
qAddDependentFile :: Quasi m => FilePath -> m ()
qAddTopDecls :: Quasi m => [Dec] -> m ()
qAddModFinalizer :: Quasi m => Q () -> m ()
qGetQ :: (Quasi m, Typeable a) => m (Maybe a)
qPutQ :: (Quasi m, Typeable a) => a -> m ()
badIO :: String -> IO a
counter :: IORef Int
newtype Q a
[Q] :: (forall m. Quasi m => m a) -> Q a
[unQ] :: Q a -> forall m. Quasi m => m a
runQ :: Quasi m => Q a -> m a
newtype TExp a
[TExp] :: Exp -> TExp a
[unType] :: TExp a -> Exp
unTypeQ :: Q (TExp a) -> Q Exp
unsafeTExpCoerce :: Q Exp -> Q (TExp a)

-- | Generate a fresh name, which cannot be captured.
--   
--   For example, this:
--   
--   <pre>
--   f = $(do
--     nm1 &lt;- newName "x"
--     let nm2 = <a>mkName</a> "x"
--     return (<a>LamE</a> [<a>VarP</a> nm1] (LamE [VarP nm2] (<a>VarE</a> nm1)))
--    )
--   </pre>
--   
--   will produce the splice
--   
--   <pre>
--   f = \x0 -&gt; \x -&gt; x0
--   </pre>
--   
--   In particular, the occurrence <tt>VarE nm1</tt> refers to the binding
--   <tt>VarP nm1</tt>, and is not captured by the binding <tt>VarP
--   nm2</tt>.
--   
--   Although names generated by <tt>newName</tt> cannot <i>be
--   captured</i>, they can <i>capture</i> other names. For example, this:
--   
--   <pre>
--   g = $(do
--     nm1 &lt;- newName "x"
--     let nm2 = mkName "x"
--     return (LamE [VarP nm2] (LamE [VarP nm1] (VarE nm2)))
--    )
--   </pre>
--   
--   will produce the splice
--   
--   <pre>
--   g = \x -&gt; \x0 -&gt; x0
--   </pre>
--   
--   since the occurrence <tt>VarE nm2</tt> is captured by the innermost
--   binding of <tt>x</tt>, namely <tt>VarP nm1</tt>.
newName :: String -> Q Name

-- | Report an error (True) or warning (False), but carry on; use
--   <a>fail</a> to stop.

-- | <i>Deprecated: Use reportError or reportWarning instead</i>
report :: Bool -> String -> Q ()

-- | Report an error to the user, but allow the current splice's
--   computation to carry on. To abort the computation, use <a>fail</a>.
reportError :: String -> Q ()

-- | Report a warning to the user, and carry on.
reportWarning :: String -> Q ()

-- | Recover from errors raised by <a>reportError</a> or <a>fail</a>.
recover :: Q a -> Q a -> Q a
lookupName :: Bool -> String -> Q (Maybe Name)

-- | Look up the given name in the (type namespace of the) current splice's
--   scope. See <a>Language.Haskell.TH.Syntax#namelookup</a> for more
--   details.
lookupTypeName :: String -> Q (Maybe Name)

-- | Look up the given name in the (value namespace of the) current
--   splice's scope. See <a>Language.Haskell.TH.Syntax#namelookup</a> for
--   more details.
lookupValueName :: String -> Q (Maybe Name)

-- | <a>reify</a> looks up information about the <a>Name</a>.
--   
--   It is sometimes useful to construct the argument name using
--   <a>lookupTypeName</a> or <a>lookupValueName</a> to ensure that we are
--   reifying from the right namespace. For instance, in this context:
--   
--   <pre>
--   data D = D
--   </pre>
--   
--   which <tt>D</tt> does <tt>reify (mkName "D")</tt> return information
--   about? (Answer: <tt>D</tt>-the-type, but don't rely on it.) To ensure
--   we get information about <tt>D</tt>-the-value, use
--   <a>lookupValueName</a>:
--   
--   <pre>
--   do
--     Just nm &lt;- lookupValueName "D"
--     reify nm
--   </pre>
--   
--   and to get information about <tt>D</tt>-the-type, use
--   <a>lookupTypeName</a>.
reify :: Name -> Q Info

-- | <tt>reifyInstances nm tys</tt> returns a list of visible instances of
--   <tt>nm tys</tt>. That is, if <tt>nm</tt> is the name of a type class,
--   then all instances of this class at the types <tt>tys</tt> are
--   returned. Alternatively, if <tt>nm</tt> is the name of a data family
--   or type family, all instances of this family at the types <tt>tys</tt>
--   are returned.
reifyInstances :: Name -> [Type] -> Q [InstanceDec]

-- | <tt>reifyRoles nm</tt> returns the list of roles associated with the
--   parameters of the tycon <tt>nm</tt>. Fails if <tt>nm</tt> cannot be
--   found or is not a tycon. The returned list should never contain
--   <a>InferR</a>.
reifyRoles :: Name -> Q [Role]

-- | <tt>reifyAnnotations target</tt> returns the list of annotations
--   associated with <tt>target</tt>. Only the annotations that are
--   appropriately typed is returned. So if you have <tt>Int</tt> and
--   <tt>String</tt> annotations for the same target, you have to call this
--   function twice.
reifyAnnotations :: Data a => AnnLookup -> Q [a]

-- | <tt>reifyModule mod</tt> looks up information about module
--   <tt>mod</tt>. To look up the current module, call this function with
--   the return value of <tt>thisModule</tt>.
reifyModule :: Module -> Q ModuleInfo

-- | Is the list of instances returned by <a>reifyInstances</a> nonempty?
isInstance :: Name -> [Type] -> Q Bool

-- | The location at which this computation is spliced.
location :: Q Loc

-- | The <a>runIO</a> function lets you run an I/O computation in the
--   <a>Q</a> monad. Take care: you are guaranteed the ordering of calls to
--   <a>runIO</a> within a single <a>Q</a> computation, but not about the
--   order in which splices are run.
--   
--   Note: for various murky reasons, stdout and stderr handles are not
--   necessarily flushed when the compiler finishes running, so you should
--   flush them yourself.
runIO :: IO a -> Q a

-- | Record external files that runIO is using (dependent upon). The
--   compiler can then recognize that it should re-compile the Haskell file
--   when an external file changes.
--   
--   Expects an absolute file path.
--   
--   Notes:
--   
--   <ul>
--   <li>ghc -M does not know about these dependencies - it does not
--   execute TH.</li>
--   <li>The dependency is based on file content, not a modification
--   time</li>
--   </ul>
addDependentFile :: FilePath -> Q ()

-- | Add additional top-level declarations. The added declarations will be
--   type checked along with the current declaration group.
addTopDecls :: [Dec] -> Q ()

-- | Add a finalizer that will run in the Q monad after the current module
--   has been type checked. This only makes sense when run within a
--   top-level splice.
addModFinalizer :: Q () -> Q ()

-- | Get state from the Q monad.
getQ :: Typeable a => Q (Maybe a)

-- | Replace the state in the Q monad.
putQ :: Typeable a => a -> Q ()
returnQ :: a -> Q a
bindQ :: Q a -> (a -> Q b) -> Q b
sequenceQ :: [Q a] -> Q [a]
class Lift t
lift :: Lift t => t -> Q Exp
liftString :: String -> Q Exp
trueName :: Name
falseName :: Name
nothingName :: Name
justName :: Name
leftName :: Name
rightName :: Name
newtype ModName
[ModName] :: String -> ModName
newtype PkgName
[PkgName] :: String -> PkgName

-- | Obtained from <a>reifyModule</a> and <tt>thisModule</tt>.
data Module
[Module] :: PkgName -> ModName -> Module
newtype OccName
[OccName] :: String -> OccName
mkModName :: String -> ModName
modString :: ModName -> String
mkPkgName :: String -> PkgName
pkgString :: PkgName -> String
mkOccName :: String -> OccName
occString :: OccName -> String

-- | An abstract type representing names in the syntax tree.
--   
--   <a>Name</a>s can be constructed in several ways, which come with
--   different name-capture guarantees (see
--   <a>Language.Haskell.TH.Syntax#namecapture</a> for an explanation of
--   name capture):
--   
--   <ul>
--   <li>the built-in syntax <tt>'f</tt> and <tt>''T</tt> can be used to
--   construct names, The expression <tt>'f</tt> gives a <tt>Name</tt>
--   which refers to the value <tt>f</tt> currently in scope, and
--   <tt>''T</tt> gives a <tt>Name</tt> which refers to the type <tt>T</tt>
--   currently in scope. These names can never be captured.</li>
--   <li><a>lookupValueName</a> and <a>lookupTypeName</a> are similar to
--   <tt>'f</tt> and <tt>''T</tt> respectively, but the <tt>Name</tt>s are
--   looked up at the point where the current splice is being run. These
--   names can never be captured.</li>
--   <li><a>newName</a> monadically generates a new name, which can never
--   be captured.</li>
--   <li><a>mkName</a> generates a capturable name.</li>
--   </ul>
--   
--   Names constructed using <tt>newName</tt> and <tt>mkName</tt> may be
--   used in bindings (such as <tt>let x = ...</tt> or <tt>x -&gt;
--   ...</tt>), but names constructed using <tt>lookupValueName</tt>,
--   <tt>lookupTypeName</tt>, <tt>'f</tt>, <tt>''T</tt> may not.
data Name
[Name] :: OccName -> NameFlavour -> Name
data NameFlavour

-- | An unqualified name; dynamically bound
[NameS] :: NameFlavour

-- | A qualified name; dynamically bound
[NameQ] :: ModName -> NameFlavour

-- | A unique local name
[NameU] :: !Int -> NameFlavour

-- | Local name bound outside of the TH AST
[NameL] :: !Int -> NameFlavour

-- | Global name bound outside of the TH AST: An original name (occurrences
--   only, not binders) Need the namespace too to be sure which thing we
--   are naming
[NameG] :: NameSpace -> PkgName -> ModName -> NameFlavour
data NameSpace

-- | Variables
[VarName] :: NameSpace

-- | Data constructors
[DataName] :: NameSpace

-- | Type constructors and classes; Haskell has them in the same name space
--   for now.
[TcClsName] :: NameSpace
type Uniq = Int

-- | The name without its module prefix
nameBase :: Name -> String

-- | Module prefix of a name, if it exists
nameModule :: Name -> Maybe String

-- | Generate a capturable name. Occurrences of such names will be resolved
--   according to the Haskell scoping rules at the occurrence site.
--   
--   For example:
--   
--   <pre>
--   f = [| pi + $(varE (mkName "pi")) |]
--   ...
--   g = let pi = 3 in $f
--   </pre>
--   
--   In this case, <tt>g</tt> is desugared to
--   
--   <pre>
--   g = Prelude.pi + 3
--   </pre>
--   
--   Note that <tt>mkName</tt> may be used with qualified names:
--   
--   <pre>
--   mkName "Prelude.pi"
--   </pre>
--   
--   See also <a>dyn</a> for a useful combinator. The above example could
--   be rewritten using <tt>dyn</tt> as
--   
--   <pre>
--   f = [| pi + $(dyn "pi") |]
--   </pre>
mkName :: String -> Name

-- | Only used internally
mkNameU :: String -> Uniq -> Name

-- | Only used internally
mkNameL :: String -> Uniq -> Name

-- | Used for 'x etc, but not available to the programmer
mkNameG :: NameSpace -> String -> String -> String -> Name
mkNameG_v :: String -> String -> String -> Name
mkNameG_tc :: String -> String -> String -> Name
mkNameG_d :: String -> String -> String -> Name
data NameIs
[Alone] :: NameIs
[Applied] :: NameIs
[Infix] :: NameIs
showName :: Name -> String
showName' :: NameIs -> Name -> String

-- | Tuple data constructor
tupleDataName :: Int -> Name

-- | Tuple type constructor
tupleTypeName :: Int -> Name
mk_tup_name :: Int -> NameSpace -> Name

-- | Unboxed tuple data constructor
unboxedTupleDataName :: Int -> Name

-- | Unboxed tuple type constructor
unboxedTupleTypeName :: Int -> Name
mk_unboxed_tup_name :: Int -> NameSpace -> Name
data Loc
[Loc] :: String -> String -> String -> CharPos -> CharPos -> Loc
[loc_filename] :: Loc -> String
[loc_package] :: Loc -> String
[loc_module] :: Loc -> String
[loc_start] :: Loc -> CharPos
[loc_end] :: Loc -> CharPos
type CharPos = (Int, Int)  Line and character position

-- | Obtained from <a>reify</a> in the <a>Q</a> Monad.
data Info

-- | A class, with a list of its visible instances
[ClassI] :: Dec -> [InstanceDec] -> Info

-- | A class method
[ClassOpI] :: Name -> Type -> ParentName -> Fixity -> Info

-- | A "plain" type constructor. "Fancier" type constructors are returned
--   using <a>PrimTyConI</a> or <a>FamilyI</a> as appropriate
[TyConI] :: Dec -> Info

-- | A type or data family, with a list of its visible instances. A closed
--   type family is returned with 0 instances.
[FamilyI] :: Dec -> [InstanceDec] -> Info

-- | A "primitive" type constructor, which can't be expressed with a
--   <a>Dec</a>. Examples: <tt>(-&gt;)</tt>, <tt>Int#</tt>.
[PrimTyConI] :: Name -> Arity -> Unlifted -> Info

-- | A data constructor
[DataConI] :: Name -> Type -> ParentName -> Fixity -> Info

-- | A "value" variable (as opposed to a type variable, see <a>TyVarI</a>).
--   
--   The <tt>Maybe Dec</tt> field contains <tt>Just</tt> the declaration
--   which defined the variable -- including the RHS of the declaration --
--   or else <tt>Nothing</tt>, in the case where the RHS is unavailable to
--   the compiler. At present, this value is _always_ <tt>Nothing</tt>:
--   returning the RHS has not yet been implemented because of lack of
--   interest.
[VarI] :: Name -> Type -> (Maybe Dec) -> Fixity -> Info

-- | A type variable.
--   
--   The <tt>Type</tt> field contains the type which underlies the
--   variable. At present, this is always <tt><a>VarT</a> theName</tt>, but
--   future changes may permit refinement of this.
[TyVarI] :: Name -> Type -> Info

-- | Obtained from <a>reifyModule</a> in the <a>Q</a> Monad.
data ModuleInfo

-- | Contains the import list of the module.
[ModuleInfo] :: [Module] -> ModuleInfo

-- | In <a>ClassOpI</a> and <a>DataConI</a>, name of the parent class or
--   type
type ParentName = Name

-- | In <a>PrimTyConI</a>, arity of the type constructor
type Arity = Int

-- | In <a>PrimTyConI</a>, is the type constructor unlifted?
type Unlifted = Bool

-- | <a>InstanceDec</a> desribes a single instance of a class or type
--   function. It is just a <a>Dec</a>, but guaranteed to be one of the
--   following:
--   
--   <ul>
--   <li><a>InstanceD</a> (with empty <tt>[<a>Dec</a>]</tt>)</li>
--   <li><a>DataInstD</a> or <a>NewtypeInstD</a> (with empty derived
--   <tt>[<a>Name</a>]</tt>)</li>
--   <li><a>TySynInstD</a></li>
--   </ul>
type InstanceDec = Dec
data Fixity
[Fixity] :: Int -> FixityDirection -> Fixity
data FixityDirection
[InfixL] :: FixityDirection
[InfixR] :: FixityDirection
[InfixN] :: FixityDirection

-- | Highest allowed operator precedence for <a>Fixity</a> constructor
--   (answer: 9)
maxPrecedence :: Int

-- | Default fixity: <tt>infixl 9</tt>
defaultFixity :: Fixity
data Lit
[CharL] :: Char -> Lit
[StringL] :: String -> Lit

-- | Used for overloaded and non-overloaded literals. We don't have a good
--   way to represent non-overloaded literals at the moment. Maybe that
--   doesn't matter?
[IntegerL] :: Integer -> Lit
[RationalL] :: Rational -> Lit
[IntPrimL] :: Integer -> Lit
[WordPrimL] :: Integer -> Lit
[FloatPrimL] :: Rational -> Lit
[DoublePrimL] :: Rational -> Lit

-- | A primitive C-style string, type Addr#
[StringPrimL] :: [Word8] -> Lit

-- | Pattern in Haskell given in <tt>{}</tt>
data Pat

-- | <pre>
--   { 5 or <tt>c</tt> }
--   </pre>
[LitP] :: Lit -> Pat

-- | <pre>
--   { x }
--   </pre>
[VarP] :: Name -> Pat

-- | <pre>
--   { (p1,p2) }
--   </pre>
[TupP] :: [Pat] -> Pat

-- | <pre>
--   { () }
--   </pre>
[UnboxedTupP] :: [Pat] -> Pat

-- | <pre>
--   data T1 = C1 t1 t2; {C1 p1 p1} = e
--   </pre>
[ConP] :: Name -> [Pat] -> Pat

-- | <pre>
--   foo ({x :+ y}) = e
--   </pre>
[InfixP] :: Pat -> Name -> Pat -> Pat

-- | <pre>
--   foo ({x :+ y}) = e
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
[UInfixP] :: Pat -> Name -> Pat -> Pat

-- | <pre>
--   {(p)}
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
[ParensP] :: Pat -> Pat

-- | <pre>
--   { ~p }
--   </pre>
[TildeP] :: Pat -> Pat

-- | <pre>
--   { !p }
--   </pre>
[BangP] :: Pat -> Pat

-- | <pre>
--   { x @ p }
--   </pre>
[AsP] :: Name -> Pat -> Pat

-- | <pre>
--   { _ }
--   </pre>
[WildP] :: Pat

-- | <pre>
--   f (Pt { pointx = x }) = g x
--   </pre>
[RecP] :: Name -> [FieldPat] -> Pat

-- | <pre>
--   { [1,2,3] }
--   </pre>
[ListP] :: [Pat] -> Pat

-- | <pre>
--   { p :: t }
--   </pre>
[SigP] :: Pat -> Type -> Pat

-- | <pre>
--   { e -&gt; p }
--   </pre>
[ViewP] :: Exp -> Pat -> Pat
type FieldPat = (Name, Pat)
data Match

-- | <pre>
--   case e of { pat -&gt; body where decs }
--   </pre>
[Match] :: Pat -> Body -> [Dec] -> Match
data Clause

-- | <pre>
--   f { p1 p2 = body where decs }
--   </pre>
[Clause] :: [Pat] -> Body -> [Dec] -> Clause
data Exp

-- | <pre>
--   { x }
--   </pre>
[VarE] :: Name -> Exp

-- | <pre>
--   data T1 = C1 t1 t2; p = {C1} e1 e2
--   </pre>
[ConE] :: Name -> Exp

-- | <pre>
--   { 5 or <tt>c</tt>}
--   </pre>
[LitE] :: Lit -> Exp

-- | <pre>
--   { f x }
--   </pre>
[AppE] :: Exp -> Exp -> Exp

-- | <pre>
--   {x + y} or {(x+)} or {(+ x)} or {(+)}
--   </pre>
[InfixE] :: (Maybe Exp) -> Exp -> (Maybe Exp) -> Exp

-- | <pre>
--   {x + y}
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
[UInfixE] :: Exp -> Exp -> Exp -> Exp

-- | <pre>
--   { (e) }
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
[ParensE] :: Exp -> Exp

-- | <pre>
--   {  p1 p2 -&gt; e }
--   </pre>
[LamE] :: [Pat] -> Exp -> Exp

-- | <pre>
--   { case m1; m2 }
--   </pre>
[LamCaseE] :: [Match] -> Exp

-- | <pre>
--   { (e1,e2) }
--   </pre>
[TupE] :: [Exp] -> Exp

-- | <pre>
--   { () }
--   </pre>
[UnboxedTupE] :: [Exp] -> Exp

-- | <pre>
--   { if e1 then e2 else e3 }
--   </pre>
[CondE] :: Exp -> Exp -> Exp -> Exp

-- | <pre>
--   { if | g1 -&gt; e1 | g2 -&gt; e2 }
--   </pre>
[MultiIfE] :: [(Guard, Exp)] -> Exp

-- | <pre>
--   { let x=e1;   y=e2 in e3 }
--   </pre>
[LetE] :: [Dec] -> Exp -> Exp

-- | <pre>
--   { case e of m1; m2 }
--   </pre>
[CaseE] :: Exp -> [Match] -> Exp

-- | <pre>
--   { do { p &lt;- e1; e2 }  }
--   </pre>
[DoE] :: [Stmt] -> Exp

-- | <pre>
--   { [ (x,y) | x &lt;- xs, y &lt;- ys ] }
--   </pre>
--   
--   The result expression of the comprehension is the <i>last</i> of the
--   <tt><a>Stmt</a></tt>s, and should be a <a>NoBindS</a>.
--   
--   E.g. translation:
--   
--   <pre>
--   [ f x | x &lt;- xs ]
--   </pre>
--   
--   <pre>
--   CompE [BindS (VarP x) (VarE xs), NoBindS (AppE (VarE f) (VarE x))]
--   </pre>
[CompE] :: [Stmt] -> Exp

-- | <pre>
--   { [ 1 ,2 .. 10 ] }
--   </pre>
[ArithSeqE] :: Range -> Exp

-- | <pre>
--   { [1,2,3] }
--   </pre>
[ListE] :: [Exp] -> Exp

-- | <pre>
--   { e :: t }
--   </pre>
[SigE] :: Exp -> Type -> Exp

-- | <pre>
--   { T { x = y, z = w } }
--   </pre>
[RecConE] :: Name -> [FieldExp] -> Exp

-- | <pre>
--   { (f x) { z = w } }
--   </pre>
[RecUpdE] :: Exp -> [FieldExp] -> Exp

-- | <pre>
--   { static e }
--   </pre>
[StaticE] :: Exp -> Exp
type FieldExp = (Name, Exp)
data Body

-- | <pre>
--   f p { | e1 = e2
--         | e3 = e4 }
--    where ds
--   </pre>
[GuardedB] :: [(Guard, Exp)] -> Body

-- | <pre>
--   f p { = e } where ds
--   </pre>
[NormalB] :: Exp -> Body
data Guard

-- | <pre>
--   f x { | odd x } = x
--   </pre>
[NormalG] :: Exp -> Guard

-- | <pre>
--   f x { | Just y &lt;- x, Just z &lt;- y } = z
--   </pre>
[PatG] :: [Stmt] -> Guard
data Stmt
[BindS] :: Pat -> Exp -> Stmt
[LetS] :: [Dec] -> Stmt
[NoBindS] :: Exp -> Stmt
[ParS] :: [[Stmt]] -> Stmt
data Range
[FromR] :: Exp -> Range
[FromThenR] :: Exp -> Exp -> Range
[FromToR] :: Exp -> Exp -> Range
[FromThenToR] :: Exp -> Exp -> Exp -> Range
data Dec

-- | <pre>
--   { f p1 p2 = b where decs }
--   </pre>
[FunD] :: Name -> [Clause] -> Dec

-- | <pre>
--   { p = b where decs }
--   </pre>
[ValD] :: Pat -> Body -> [Dec] -> Dec

-- | <pre>
--   { data Cxt x =&gt; T x = A x | B (T x)
--          deriving (Z,W)}
--   </pre>
[DataD] :: Cxt -> Name -> [TyVarBndr] -> [Con] -> [Name] -> Dec

-- | <pre>
--   { newtype Cxt x =&gt; T x = A (B x)
--          deriving (Z,W)}
--   </pre>
[NewtypeD] :: Cxt -> Name -> [TyVarBndr] -> Con -> [Name] -> Dec

-- | <pre>
--   { type T x = (x,x) }
--   </pre>
[TySynD] :: Name -> [TyVarBndr] -> Type -> Dec

-- | <pre>
--   { class Eq a =&gt; Ord a where ds }
--   </pre>
[ClassD] :: Cxt -> Name -> [TyVarBndr] -> [FunDep] -> [Dec] -> Dec

-- | <pre>
--   { instance Show w =&gt; Show [w]
--          where ds }
--   </pre>
[InstanceD] :: Cxt -> Type -> [Dec] -> Dec

-- | <pre>
--   { length :: [a] -&gt; Int }
--   </pre>
[SigD] :: Name -> Type -> Dec

-- | <pre>
--   { foreign import ... }
--   { foreign export ... }
--   </pre>
[ForeignD] :: Foreign -> Dec

-- | <pre>
--   { infix 3 foo }
--   </pre>
[InfixD] :: Fixity -> Name -> Dec

-- | <pre>
--   { {--} }
--   </pre>
[PragmaD] :: Pragma -> Dec

-- | <pre>
--   { type family T a b c :: * }
--   </pre>
[FamilyD] :: FamFlavour -> Name -> [TyVarBndr] -> (Maybe Kind) -> Dec

-- | <pre>
--   { data instance Cxt x =&gt; T [x] = A x
--                                   | B (T x)
--          deriving (Z,W)}
--   </pre>
[DataInstD] :: Cxt -> Name -> [Type] -> [Con] -> [Name] -> Dec

-- | <pre>
--   { newtype instance Cxt x =&gt; T [x] = A (B x)
--          deriving (Z,W)}
--   </pre>
[NewtypeInstD] :: Cxt -> Name -> [Type] -> Con -> [Name] -> Dec

-- | <pre>
--   { type instance ... }
--   </pre>
[TySynInstD] :: Name -> TySynEqn -> Dec

-- | <pre>
--   { type family F a b :: * where ... }
--   </pre>
[ClosedTypeFamilyD] :: Name -> [TyVarBndr] -> (Maybe Kind) -> [TySynEqn] -> Dec

-- | <pre>
--   { type role T nominal representational }
--   </pre>
[RoleAnnotD] :: Name -> [Role] -> Dec

-- | <pre>
--   { deriving instance Ord a =&gt; Ord (Foo a) }
--   </pre>
[StandaloneDerivD] :: Cxt -> Type -> Dec

-- | <pre>
--   { default size :: Data a =&gt; a -&gt; Int }
--   </pre>
[DefaultSigD] :: Name -> Type -> Dec

-- | One equation of a type family instance or closed type family. The
--   arguments are the left-hand-side type patterns and the right-hand-side
--   result.
data TySynEqn
[TySynEqn] :: [Type] -> Type -> TySynEqn
data FunDep
[FunDep] :: [Name] -> [Name] -> FunDep
data FamFlavour
[TypeFam] :: FamFlavour
[DataFam] :: FamFlavour
data Foreign
[ImportF] :: Callconv -> Safety -> String -> Name -> Type -> Foreign
[ExportF] :: Callconv -> String -> Name -> Type -> Foreign
data Callconv
[CCall] :: Callconv
[StdCall] :: Callconv
[CApi] :: Callconv
[Prim] :: Callconv
[JavaScript] :: Callconv
data Safety
[Unsafe] :: Safety
[Safe] :: Safety
[Interruptible] :: Safety
data Pragma
[InlineP] :: Name -> Inline -> RuleMatch -> Phases -> Pragma
[SpecialiseP] :: Name -> Type -> (Maybe Inline) -> Phases -> Pragma
[SpecialiseInstP] :: Type -> Pragma
[RuleP] :: String -> [RuleBndr] -> Exp -> Exp -> Phases -> Pragma
[AnnP] :: AnnTarget -> Exp -> Pragma
[LineP] :: Int -> String -> Pragma
data Inline
[NoInline] :: Inline
[Inline] :: Inline
[Inlinable] :: Inline
data RuleMatch
[ConLike] :: RuleMatch
[FunLike] :: RuleMatch
data Phases
[AllPhases] :: Phases
[FromPhase] :: Int -> Phases
[BeforePhase] :: Int -> Phases
data RuleBndr
[RuleVar] :: Name -> RuleBndr
[TypedRuleVar] :: Name -> Type -> RuleBndr
data AnnTarget
[ModuleAnnotation] :: AnnTarget
[TypeAnnotation] :: Name -> AnnTarget
[ValueAnnotation] :: Name -> AnnTarget
type Cxt = [Pred]  @(Eq a, Ord b)@

-- | Since the advent of <tt>ConstraintKinds</tt>, constraints are really
--   just types. Equality constraints use the <a>EqualityT</a> constructor.
--   Constraints may also be tuples of other constraints.
type Pred = Type
data Strict
[IsStrict] :: Strict
[NotStrict] :: Strict
[Unpacked] :: Strict
data Con

-- | <pre>
--   C Int a
--   </pre>
[NormalC] :: Name -> [StrictType] -> Con

-- | <pre>
--   C { v :: Int, w :: a }
--   </pre>
[RecC] :: Name -> [VarStrictType] -> Con

-- | <pre>
--   Int :+ a
--   </pre>
[InfixC] :: StrictType -> Name -> StrictType -> Con

-- | <pre>
--   forall a. Eq a =&gt; C [a]
--   </pre>
[ForallC] :: [TyVarBndr] -> Cxt -> Con -> Con
type StrictType = (Strict, Type)
type VarStrictType = (Name, Strict, Type)
data Type

-- | <pre>
--   forall &lt;vars&gt;. &lt;ctxt&gt; -&gt; &lt;type&gt;
--   </pre>
[ForallT] :: [TyVarBndr] -> Cxt -> Type -> Type

-- | <pre>
--   T a b
--   </pre>
[AppT] :: Type -> Type -> Type

-- | <pre>
--   t :: k
--   </pre>
[SigT] :: Type -> Kind -> Type

-- | <pre>
--   a
--   </pre>
[VarT] :: Name -> Type

-- | <pre>
--   T
--   </pre>
[ConT] :: Name -> Type

-- | <pre>
--   'T
--   </pre>
[PromotedT] :: Name -> Type

-- | <pre>
--   (,), (,,), etc.
--   </pre>
[TupleT] :: Int -> Type

-- | <pre>
--   (), (), etc.
--   </pre>
[UnboxedTupleT] :: Int -> Type

-- | <pre>
--   -&gt;
--   </pre>
[ArrowT] :: Type

-- | <pre>
--   ~
--   </pre>
[EqualityT] :: Type

-- | <pre>
--   []
--   </pre>
[ListT] :: Type

-- | <pre>
--   '(), '(,), '(,,), etc.
--   </pre>
[PromotedTupleT] :: Int -> Type

-- | <pre>
--   '[]
--   </pre>
[PromotedNilT] :: Type

-- | <pre>
--   (':)
--   </pre>
[PromotedConsT] :: Type

-- | <pre>
--   *
--   </pre>
[StarT] :: Type

-- | <pre>
--   Constraint
--   </pre>
[ConstraintT] :: Type

-- | <pre>
--   0,1,2, etc.
--   </pre>
[LitT] :: TyLit -> Type
data TyVarBndr

-- | <pre>
--   a
--   </pre>
[PlainTV] :: Name -> TyVarBndr

-- | <pre>
--   (a :: k)
--   </pre>
[KindedTV] :: Name -> Kind -> TyVarBndr
data TyLit

-- | <pre>
--   2
--   </pre>
[NumTyLit] :: Integer -> TyLit

-- | <pre>
--   <a>Hello</a>
--   </pre>
[StrTyLit] :: String -> TyLit

-- | Role annotations
data Role

-- | <pre>
--   nominal
--   </pre>
[NominalR] :: Role

-- | <pre>
--   representational
--   </pre>
[RepresentationalR] :: Role

-- | <pre>
--   phantom
--   </pre>
[PhantomR] :: Role

-- | <pre>
--   _
--   </pre>
[InferR] :: Role

-- | Annotation target for reifyAnnotations
data AnnLookup
[AnnLookupModule] :: Module -> AnnLookup
[AnnLookupName] :: Name -> AnnLookup

-- | To avoid duplication between kinds and types, they are defined to be
--   the same. Naturally, you would never have a type be <a>StarT</a> and
--   you would never have a kind be <a>SigT</a>, but many of the other
--   constructors are shared. Note that the kind <tt>Bool</tt> is denoted
--   with <a>ConT</a>, not <a>PromotedT</a>. Similarly, tuple kinds are
--   made with <a>TupleT</a>, not <a>PromotedTupleT</a>.
type Kind = Type
cmpEq :: Ordering -> Bool
thenCmp :: Ordering -> Ordering -> Ordering
instance Constructor C1_7Info
instance Constructor C1_6Info
instance Constructor C1_5Info
instance Constructor C1_4Info
instance Constructor C1_3Info
instance Constructor C1_2Info
instance Constructor C1_1Info
instance Constructor C1_0Info
instance Datatype D1Info
instance Constructor C1_3Range
instance Constructor C1_2Range
instance Constructor C1_1Range
instance Constructor C1_0Range
instance Datatype D1Range
instance Constructor C1_5Pragma
instance Constructor C1_4Pragma
instance Constructor C1_3Pragma
instance Constructor C1_2Pragma
instance Constructor C1_1Pragma
instance Constructor C1_0Pragma
instance Datatype D1Pragma
instance Constructor C1_3Stmt
instance Constructor C1_2Stmt
instance Constructor C1_1Stmt
instance Constructor C1_0Stmt
instance Datatype D1Stmt
instance Constructor C1_1Guard
instance Constructor C1_0Guard
instance Datatype D1Guard
instance Constructor C1_1Body
instance Constructor C1_0Body
instance Datatype D1Body
instance Constructor C1_0Clause
instance Datatype D1Clause
instance Constructor C1_18Dec
instance Constructor C1_17Dec
instance Constructor C1_16Dec
instance Constructor C1_15Dec
instance Constructor C1_14Dec
instance Constructor C1_13Dec
instance Constructor C1_12Dec
instance Constructor C1_11Dec
instance Constructor C1_10Dec
instance Constructor C1_9Dec
instance Constructor C1_8Dec
instance Constructor C1_7Dec
instance Constructor C1_6Dec
instance Constructor C1_5Dec
instance Constructor C1_4Dec
instance Constructor C1_3Dec
instance Constructor C1_2Dec
instance Constructor C1_1Dec
instance Constructor C1_0Dec
instance Datatype D1Dec
instance Constructor C1_15Pat
instance Constructor C1_14Pat
instance Constructor C1_13Pat
instance Constructor C1_12Pat
instance Constructor C1_11Pat
instance Constructor C1_10Pat
instance Constructor C1_9Pat
instance Constructor C1_8Pat
instance Constructor C1_7Pat
instance Constructor C1_6Pat
instance Constructor C1_5Pat
instance Constructor C1_4Pat
instance Constructor C1_3Pat
instance Constructor C1_2Pat
instance Constructor C1_1Pat
instance Constructor C1_0Pat
instance Datatype D1Pat
instance Constructor C1_0Match
instance Datatype D1Match
instance Constructor C1_22Exp
instance Constructor C1_21Exp
instance Constructor C1_20Exp
instance Constructor C1_19Exp
instance Constructor C1_18Exp
instance Constructor C1_17Exp
instance Constructor C1_16Exp
instance Constructor C1_15Exp
instance Constructor C1_14Exp
instance Constructor C1_13Exp
instance Constructor C1_12Exp
instance Constructor C1_11Exp
instance Constructor C1_10Exp
instance Constructor C1_9Exp
instance Constructor C1_8Exp
instance Constructor C1_7Exp
instance Constructor C1_6Exp
instance Constructor C1_5Exp
instance Constructor C1_4Exp
instance Constructor C1_3Exp
instance Constructor C1_2Exp
instance Constructor C1_1Exp
instance Constructor C1_0Exp
instance Datatype D1Exp
instance Constructor C1_0TySynEqn
instance Datatype D1TySynEqn
instance Constructor C1_1Foreign
instance Constructor C1_0Foreign
instance Datatype D1Foreign
instance Constructor C1_1RuleBndr
instance Constructor C1_0RuleBndr
instance Datatype D1RuleBndr
instance Constructor C1_3Con
instance Constructor C1_2Con
instance Constructor C1_1Con
instance Constructor C1_0Con
instance Datatype D1Con
instance Constructor C1_1TyVarBndr
instance Constructor C1_0TyVarBndr
instance Datatype D1TyVarBndr
instance Constructor C1_16Type
instance Constructor C1_15Type
instance Constructor C1_14Type
instance Constructor C1_13Type
instance Constructor C1_12Type
instance Constructor C1_11Type
instance Constructor C1_10Type
instance Constructor C1_9Type
instance Constructor C1_8Type
instance Constructor C1_7Type
instance Constructor C1_6Type
instance Constructor C1_5Type
instance Constructor C1_4Type
instance Constructor C1_3Type
instance Constructor C1_2Type
instance Constructor C1_1Type
instance Constructor C1_0Type
instance Datatype D1Type
instance Constructor C1_2AnnTarget
instance Constructor C1_1AnnTarget
instance Constructor C1_0AnnTarget
instance Datatype D1AnnTarget
instance Constructor C1_1AnnLookup
instance Constructor C1_0AnnLookup
instance Datatype D1AnnLookup
instance Constructor C1_0FunDep
instance Datatype D1FunDep
instance Constructor C1_0Name
instance Datatype D1Name
instance Constructor C1_3Role
instance Constructor C1_2Role
instance Constructor C1_1Role
instance Constructor C1_0Role
instance Datatype D1Role
instance Constructor C1_1TyLit
instance Constructor C1_0TyLit
instance Datatype D1TyLit
instance Constructor C1_2Strict
instance Constructor C1_1Strict
instance Constructor C1_0Strict
instance Datatype D1Strict
instance Constructor C1_2Phases
instance Constructor C1_1Phases
instance Constructor C1_0Phases
instance Datatype D1Phases
instance Constructor C1_1RuleMatch
instance Constructor C1_0RuleMatch
instance Datatype D1RuleMatch
instance Constructor C1_2Inline
instance Constructor C1_1Inline
instance Constructor C1_0Inline
instance Datatype D1Inline
instance Constructor C1_2Safety
instance Constructor C1_1Safety
instance Constructor C1_0Safety
instance Datatype D1Safety
instance Constructor C1_4Callconv
instance Constructor C1_3Callconv
instance Constructor C1_2Callconv
instance Constructor C1_1Callconv
instance Constructor C1_0Callconv
instance Datatype D1Callconv
instance Constructor C1_1FamFlavour
instance Constructor C1_0FamFlavour
instance Datatype D1FamFlavour
instance Constructor C1_8Lit
instance Constructor C1_7Lit
instance Constructor C1_6Lit
instance Constructor C1_5Lit
instance Constructor C1_4Lit
instance Constructor C1_3Lit
instance Constructor C1_2Lit
instance Constructor C1_1Lit
instance Constructor C1_0Lit
instance Datatype D1Lit
instance Constructor C1_0Fixity
instance Datatype D1Fixity
instance Constructor C1_2FixityDirection
instance Constructor C1_1FixityDirection
instance Constructor C1_0FixityDirection
instance Datatype D1FixityDirection
instance Constructor C1_0ModuleInfo
instance Datatype D1ModuleInfo
instance Selector S1_0_4Loc
instance Selector S1_0_3Loc
instance Selector S1_0_2Loc
instance Selector S1_0_1Loc
instance Selector S1_0_0Loc
instance Constructor C1_0Loc
instance Datatype D1Loc
instance Constructor C1_4NameFlavour
instance Constructor C1_3NameFlavour
instance Constructor C1_2NameFlavour
instance Constructor C1_1NameFlavour
instance Constructor C1_0NameFlavour
instance Datatype D1NameFlavour
instance Constructor C1_2NameSpace
instance Constructor C1_1NameSpace
instance Constructor C1_0NameSpace
instance Datatype D1NameSpace
instance Constructor C1_0OccName
instance Datatype D1OccName
instance Constructor C1_0Module
instance Datatype D1Module
instance Constructor C1_0PkgName
instance Datatype D1PkgName
instance Constructor C1_0ModName
instance Datatype D1ModName
instance Generic Info
instance Data Info
instance Ord Info
instance Eq Info
instance Show Info
instance Generic Range
instance Data Range
instance Ord Range
instance Eq Range
instance Show Range
instance Generic Pragma
instance Data Pragma
instance Ord Pragma
instance Eq Pragma
instance Show Pragma
instance Generic Stmt
instance Data Stmt
instance Ord Stmt
instance Eq Stmt
instance Show Stmt
instance Generic Guard
instance Data Guard
instance Ord Guard
instance Eq Guard
instance Show Guard
instance Generic Body
instance Data Body
instance Ord Body
instance Eq Body
instance Show Body
instance Generic Clause
instance Data Clause
instance Ord Clause
instance Eq Clause
instance Show Clause
instance Generic Dec
instance Data Dec
instance Ord Dec
instance Eq Dec
instance Show Dec
instance Generic Pat
instance Data Pat
instance Ord Pat
instance Eq Pat
instance Show Pat
instance Generic Match
instance Data Match
instance Ord Match
instance Eq Match
instance Show Match
instance Generic Exp
instance Data Exp
instance Ord Exp
instance Eq Exp
instance Show Exp
instance Generic TySynEqn
instance Data TySynEqn
instance Ord TySynEqn
instance Eq TySynEqn
instance Show TySynEqn
instance Generic Foreign
instance Data Foreign
instance Ord Foreign
instance Eq Foreign
instance Show Foreign
instance Generic RuleBndr
instance Data RuleBndr
instance Ord RuleBndr
instance Eq RuleBndr
instance Show RuleBndr
instance Generic Con
instance Data Con
instance Ord Con
instance Eq Con
instance Show Con
instance Generic TyVarBndr
instance Data TyVarBndr
instance Ord TyVarBndr
instance Eq TyVarBndr
instance Show TyVarBndr
instance Generic Type
instance Data Type
instance Ord Type
instance Eq Type
instance Show Type
instance Generic AnnTarget
instance Data AnnTarget
instance Ord AnnTarget
instance Eq AnnTarget
instance Show AnnTarget
instance Generic AnnLookup
instance Data AnnLookup
instance Ord AnnLookup
instance Eq AnnLookup
instance Show AnnLookup
instance Generic FunDep
instance Data FunDep
instance Ord FunDep
instance Eq FunDep
instance Show FunDep
instance Generic Name
instance Eq Name
instance Data Name
instance Generic Role
instance Data Role
instance Ord Role
instance Eq Role
instance Show Role
instance Generic TyLit
instance Data TyLit
instance Ord TyLit
instance Eq TyLit
instance Show TyLit
instance Generic Strict
instance Data Strict
instance Ord Strict
instance Eq Strict
instance Show Strict
instance Generic Phases
instance Data Phases
instance Ord Phases
instance Eq Phases
instance Show Phases
instance Generic RuleMatch
instance Data RuleMatch
instance Ord RuleMatch
instance Eq RuleMatch
instance Show RuleMatch
instance Generic Inline
instance Data Inline
instance Ord Inline
instance Eq Inline
instance Show Inline
instance Generic Safety
instance Data Safety
instance Ord Safety
instance Eq Safety
instance Show Safety
instance Generic Callconv
instance Data Callconv
instance Ord Callconv
instance Eq Callconv
instance Show Callconv
instance Generic FamFlavour
instance Data FamFlavour
instance Ord FamFlavour
instance Eq FamFlavour
instance Show FamFlavour
instance Generic Lit
instance Data Lit
instance Ord Lit
instance Eq Lit
instance Show Lit
instance Generic Fixity
instance Data Fixity
instance Show Fixity
instance Ord Fixity
instance Eq Fixity
instance Generic FixityDirection
instance Data FixityDirection
instance Show FixityDirection
instance Ord FixityDirection
instance Eq FixityDirection
instance Generic ModuleInfo
instance Data ModuleInfo
instance Ord ModuleInfo
instance Eq ModuleInfo
instance Show ModuleInfo
instance Generic Loc
instance Data Loc
instance Ord Loc
instance Eq Loc
instance Show Loc
instance Generic NameFlavour
instance Ord NameFlavour
instance Eq NameFlavour
instance Data NameFlavour
instance Generic NameSpace
instance Data NameSpace
instance Ord NameSpace
instance Eq NameSpace
instance Generic OccName
instance Data OccName
instance Ord OccName
instance Eq OccName
instance Show OccName
instance Generic Module
instance Data Module
instance Ord Module
instance Eq Module
instance Show Module
instance Generic PkgName
instance Data PkgName
instance Ord PkgName
instance Eq PkgName
instance Show PkgName
instance Generic ModName
instance Data ModName
instance Ord ModName
instance Eq ModName
instance Show ModName
instance Quasi IO
instance Monad Q
instance Functor Q
instance Applicative Q
instance Quasi Q
instance Lift Integer
instance Lift Int
instance Lift Int8
instance Lift Int16
instance Lift Int32
instance Lift Int64
instance Lift Word
instance Lift Word8
instance Lift Word16
instance Lift Word32
instance Lift Word64
instance Lift Natural
instance Integral a => Lift (Ratio a)
instance Lift Float
instance Lift Double
instance Lift Char
instance Lift Bool
instance Lift a => Lift (Maybe a)
instance (Lift a, Lift b) => Lift (Either a b)
instance Lift a => Lift [a]
instance Lift ()
instance (Lift a, Lift b) => Lift (a, b)
instance (Lift a, Lift b, Lift c) => Lift (a, b, c)
instance (Lift a, Lift b, Lift c, Lift d) => Lift (a, b, c, d)
instance (Lift a, Lift b, Lift c, Lift d, Lift e) => Lift (a, b, c, d, e)
instance (Lift a, Lift b, Lift c, Lift d, Lift e, Lift f) => Lift (a, b, c, d, e, f)
instance (Lift a, Lift b, Lift c, Lift d, Lift e, Lift f, Lift g) => Lift (a, b, c, d, e, f, g)
instance Ord Name
instance Show Name


-- | TH.Lib contains lots of useful helper functions for generating and
--   manipulating Template Haskell terms
module Language.Haskell.TH.Lib
type InfoQ = Q Info
type PatQ = Q Pat
type FieldPatQ = Q FieldPat
type ExpQ = Q Exp
type TExpQ a = Q (TExp a)
type DecQ = Q Dec
type DecsQ = Q [Dec]
type ConQ = Q Con
type TypeQ = Q Type
type TyLitQ = Q TyLit
type CxtQ = Q Cxt
type PredQ = Q Pred
type MatchQ = Q Match
type ClauseQ = Q Clause
type BodyQ = Q Body
type GuardQ = Q Guard
type StmtQ = Q Stmt
type RangeQ = Q Range
type StrictTypeQ = Q StrictType
type VarStrictTypeQ = Q VarStrictType
type FieldExpQ = Q FieldExp
type RuleBndrQ = Q RuleBndr
type TySynEqnQ = Q TySynEqn
type Role = Role
intPrimL :: Integer -> Lit
wordPrimL :: Integer -> Lit
floatPrimL :: Rational -> Lit
doublePrimL :: Rational -> Lit
integerL :: Integer -> Lit
charL :: Char -> Lit
stringL :: String -> Lit
stringPrimL :: [Word8] -> Lit
rationalL :: Rational -> Lit
litP :: Lit -> PatQ
varP :: Name -> PatQ
tupP :: [PatQ] -> PatQ
unboxedTupP :: [PatQ] -> PatQ
conP :: Name -> [PatQ] -> PatQ
infixP :: PatQ -> Name -> PatQ -> PatQ
uInfixP :: PatQ -> Name -> PatQ -> PatQ
parensP :: PatQ -> PatQ
tildeP :: PatQ -> PatQ
bangP :: PatQ -> PatQ
asP :: Name -> PatQ -> PatQ
wildP :: PatQ
recP :: Name -> [FieldPatQ] -> PatQ
listP :: [PatQ] -> PatQ
sigP :: PatQ -> TypeQ -> PatQ
viewP :: ExpQ -> PatQ -> PatQ
fieldPat :: Name -> PatQ -> FieldPatQ
bindS :: PatQ -> ExpQ -> StmtQ
letS :: [DecQ] -> StmtQ
noBindS :: ExpQ -> StmtQ
parS :: [[StmtQ]] -> StmtQ
fromR :: ExpQ -> RangeQ
fromThenR :: ExpQ -> ExpQ -> RangeQ
fromToR :: ExpQ -> ExpQ -> RangeQ
fromThenToR :: ExpQ -> ExpQ -> ExpQ -> RangeQ
normalB :: ExpQ -> BodyQ
guardedB :: [Q (Guard, Exp)] -> BodyQ
normalG :: ExpQ -> GuardQ
normalGE :: ExpQ -> ExpQ -> Q (Guard, Exp)
patG :: [StmtQ] -> GuardQ
patGE :: [StmtQ] -> ExpQ -> Q (Guard, Exp)

-- | Use with <a>caseE</a>
match :: PatQ -> BodyQ -> [DecQ] -> MatchQ

-- | Use with <a>funD</a>
clause :: [PatQ] -> BodyQ -> [DecQ] -> ClauseQ

-- | Dynamically binding a variable (unhygenic)
dyn :: String -> ExpQ

-- | <i>Deprecated: Use varE instead</i>
global :: Name -> ExpQ
varE :: Name -> ExpQ
conE :: Name -> ExpQ
litE :: Lit -> ExpQ
appE :: ExpQ -> ExpQ -> ExpQ
parensE :: ExpQ -> ExpQ
uInfixE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
infixE :: Maybe ExpQ -> ExpQ -> Maybe ExpQ -> ExpQ
infixApp :: ExpQ -> ExpQ -> ExpQ -> ExpQ
sectionL :: ExpQ -> ExpQ -> ExpQ
sectionR :: ExpQ -> ExpQ -> ExpQ
lamE :: [PatQ] -> ExpQ -> ExpQ

-- | Single-arg lambda
lam1E :: PatQ -> ExpQ -> ExpQ
lamCaseE :: [MatchQ] -> ExpQ
tupE :: [ExpQ] -> ExpQ
unboxedTupE :: [ExpQ] -> ExpQ
condE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
multiIfE :: [Q (Guard, Exp)] -> ExpQ
letE :: [DecQ] -> ExpQ -> ExpQ
caseE :: ExpQ -> [MatchQ] -> ExpQ
doE :: [StmtQ] -> ExpQ
compE :: [StmtQ] -> ExpQ
arithSeqE :: RangeQ -> ExpQ
listE :: [ExpQ] -> ExpQ
sigE :: ExpQ -> TypeQ -> ExpQ
recConE :: Name -> [Q (Name, Exp)] -> ExpQ
recUpdE :: ExpQ -> [Q (Name, Exp)] -> ExpQ
stringE :: String -> ExpQ
fieldExp :: Name -> ExpQ -> Q (Name, Exp)

-- | <pre>
--   staticE x = [| static x |]
--   </pre>
staticE :: ExpQ -> ExpQ
fromE :: ExpQ -> ExpQ
fromThenE :: ExpQ -> ExpQ -> ExpQ
fromToE :: ExpQ -> ExpQ -> ExpQ
fromThenToE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
valD :: PatQ -> BodyQ -> [DecQ] -> DecQ
funD :: Name -> [ClauseQ] -> DecQ
tySynD :: Name -> [TyVarBndr] -> TypeQ -> DecQ
dataD :: CxtQ -> Name -> [TyVarBndr] -> [ConQ] -> [Name] -> DecQ
newtypeD :: CxtQ -> Name -> [TyVarBndr] -> ConQ -> [Name] -> DecQ
classD :: CxtQ -> Name -> [TyVarBndr] -> [FunDep] -> [DecQ] -> DecQ
instanceD :: CxtQ -> TypeQ -> [DecQ] -> DecQ
sigD :: Name -> TypeQ -> DecQ
forImpD :: Callconv -> Safety -> String -> Name -> TypeQ -> DecQ
infixLD :: Int -> Name -> DecQ
infixRD :: Int -> Name -> DecQ
infixND :: Int -> Name -> DecQ
pragInlD :: Name -> Inline -> RuleMatch -> Phases -> DecQ
pragSpecD :: Name -> TypeQ -> Phases -> DecQ
pragSpecInlD :: Name -> TypeQ -> Inline -> Phases -> DecQ
pragSpecInstD :: TypeQ -> DecQ
pragRuleD :: String -> [RuleBndrQ] -> ExpQ -> ExpQ -> Phases -> DecQ
pragAnnD :: AnnTarget -> ExpQ -> DecQ
pragLineD :: Int -> String -> DecQ
familyNoKindD :: FamFlavour -> Name -> [TyVarBndr] -> DecQ
familyKindD :: FamFlavour -> Name -> [TyVarBndr] -> Kind -> DecQ
dataInstD :: CxtQ -> Name -> [TypeQ] -> [ConQ] -> [Name] -> DecQ
newtypeInstD :: CxtQ -> Name -> [TypeQ] -> ConQ -> [Name] -> DecQ
tySynInstD :: Name -> TySynEqnQ -> DecQ
closedTypeFamilyNoKindD :: Name -> [TyVarBndr] -> [TySynEqnQ] -> DecQ
closedTypeFamilyKindD :: Name -> [TyVarBndr] -> Kind -> [TySynEqnQ] -> DecQ
roleAnnotD :: Name -> [Role] -> DecQ
standaloneDerivD :: CxtQ -> TypeQ -> DecQ
defaultSigD :: Name -> TypeQ -> DecQ
tySynEqn :: [TypeQ] -> TypeQ -> TySynEqnQ
cxt :: [PredQ] -> CxtQ
normalC :: Name -> [StrictTypeQ] -> ConQ
recC :: Name -> [VarStrictTypeQ] -> ConQ
infixC :: Q (Strict, Type) -> Name -> Q (Strict, Type) -> ConQ
forallC :: [TyVarBndr] -> CxtQ -> ConQ -> ConQ
forallT :: [TyVarBndr] -> CxtQ -> TypeQ -> TypeQ
varT :: Name -> TypeQ
conT :: Name -> TypeQ
appT :: TypeQ -> TypeQ -> TypeQ
arrowT :: TypeQ
listT :: TypeQ
litT :: TyLitQ -> TypeQ
tupleT :: Int -> TypeQ
unboxedTupleT :: Int -> TypeQ
sigT :: TypeQ -> Kind -> TypeQ
equalityT :: TypeQ

-- | <i>Deprecated: As of template-haskell-2.10, constraint predicates
--   (Pred) are just types (Type), in keeping with ConstraintKinds. Please
--   use <a>conT</a> and <a>appT</a>.</i>
classP :: Name -> [Q Type] -> Q Pred

-- | <i>Deprecated: As of template-haskell-2.10, constraint predicates
--   (Pred) are just types (Type), in keeping with ConstraintKinds. Please
--   see <a>equalityT</a>.</i>
equalP :: TypeQ -> TypeQ -> PredQ
promotedT :: Name -> TypeQ
promotedTupleT :: Int -> TypeQ
promotedNilT :: TypeQ
promotedConsT :: TypeQ
isStrict :: Q Strict
notStrict :: Q Strict
unpacked :: Q Strict
strictType :: Q Strict -> TypeQ -> StrictTypeQ
varStrictType :: Name -> StrictTypeQ -> VarStrictTypeQ
numTyLit :: Integer -> TyLitQ
strTyLit :: String -> TyLitQ
plainTV :: Name -> TyVarBndr
kindedTV :: Name -> Kind -> TyVarBndr
varK :: Name -> Kind
conK :: Name -> Kind
tupleK :: Int -> Kind
arrowK :: Kind
listK :: Kind
appK :: Kind -> Kind -> Kind
starK :: Kind
constraintK :: Kind
nominalR :: Role
representationalR :: Role
phantomR :: Role
inferR :: Role
cCall :: Callconv
stdCall :: Callconv
cApi :: Callconv
prim :: Callconv
javaScript :: Callconv
unsafe :: Safety
safe :: Safety
interruptible :: Safety
funDep :: [Name] -> [Name] -> FunDep
typeFam :: FamFlavour
dataFam :: FamFlavour
ruleVar :: Name -> RuleBndrQ
typedRuleVar :: Name -> TypeQ -> RuleBndrQ
valueAnnotation :: Name -> AnnTarget
typeAnnotation :: Name -> AnnTarget
moduleAnnotation :: AnnTarget
appsE :: [ExpQ] -> ExpQ

-- | Return the Module at the place of splicing. Can be used as an input
--   for <a>reifyModule</a>.
thisModule :: Q Module

module Language.Haskell.TH.Quote
data QuasiQuoter
[QuasiQuoter] :: (String -> Q Exp) -> (String -> Q Pat) -> (String -> Q Type) -> (String -> Q [Dec]) -> QuasiQuoter
[quoteExp] :: QuasiQuoter -> String -> Q Exp
[quotePat] :: QuasiQuoter -> String -> Q Pat
[quoteType] :: QuasiQuoter -> String -> Q Type
[quoteDec] :: QuasiQuoter -> String -> Q [Dec]
dataToQa :: Data a => (Name -> k) -> (Lit -> Q q) -> (k -> [Q q] -> Q q) -> (forall b. Data b => b -> Maybe (Q q)) -> a -> Q q

-- | <a>dataToExpQ</a> converts a value to a 'Q Exp' representation of the
--   same value. It takes a function to handle type-specific cases.
dataToExpQ :: Data a => (forall b. Data b => b -> Maybe (Q Exp)) -> a -> Q Exp

-- | <a>dataToPatQ</a> converts a value to a 'Q Pat' representation of the
--   same value. It takes a function to handle type-specific cases.
dataToPatQ :: Data a => (forall b. Data b => b -> Maybe (Q Pat)) -> a -> Q Pat

-- | <a>quoteFile</a> takes a <a>QuasiQuoter</a> and lifts it into one that
--   read the data out of a file. For example, suppose <tt>asmq</tt> is an
--   assembly-language quoter, so that you can write [asmq| ld r1, r2 |] as
--   an expression. Then if you define <tt>asmq_f = quoteFile asmq</tt>,
--   then the quote [asmq_f|foo.s|] will take input from file
--   <tt>"foo.s"</tt> instead of the inline text
quoteFile :: QuasiQuoter -> QuasiQuoter


-- | Monadic front-end to Text.PrettyPrint
module Language.Haskell.TH.PprLib
type Doc = PprM Doc
data PprM a

-- | An empty document
empty :: Doc

-- | A ';' character
semi :: Doc

-- | A ',' character
comma :: Doc

-- | A <tt>:</tt> character
colon :: Doc

-- | A space character
space :: Doc

-- | A '=' character
equals :: Doc

-- | A "-&gt;" string
arrow :: Doc

-- | A '(' character
lparen :: Doc

-- | A ')' character
rparen :: Doc

-- | A '[' character
lbrack :: Doc

-- | A ']' character
rbrack :: Doc

-- | A '{' character
lbrace :: Doc

-- | A '}' character
rbrace :: Doc
text :: String -> Doc
char :: Char -> Doc
ptext :: String -> Doc
int :: Int -> Doc
integer :: Integer -> Doc
float :: Float -> Doc
double :: Double -> Doc
rational :: Rational -> Doc

-- | Wrap document in <tt>(...)</tt>
parens :: Doc -> Doc

-- | Wrap document in <tt>[...]</tt>
brackets :: Doc -> Doc

-- | Wrap document in <tt>{...}</tt>
braces :: Doc -> Doc

-- | Wrap document in <tt>'...'</tt>
quotes :: Doc -> Doc

-- | Wrap document in <tt>"..."</tt>
doubleQuotes :: Doc -> Doc

-- | Beside
(<>) :: Doc -> Doc -> Doc

-- | Beside, separated by space
(<+>) :: Doc -> Doc -> Doc

-- | List version of <a>&lt;&gt;</a>
hcat :: [Doc] -> Doc

-- | List version of <a>&lt;+&gt;</a>
hsep :: [Doc] -> Doc

-- | Above; if there is no overlap it "dovetails" the two
($$) :: Doc -> Doc -> Doc

-- | Above, without dovetailing.
($+$) :: Doc -> Doc -> Doc

-- | List version of <a>$$</a>
vcat :: [Doc] -> Doc

-- | Either hsep or vcat
sep :: [Doc] -> Doc

-- | Either hcat or vcat
cat :: [Doc] -> Doc

-- | "Paragraph fill" version of sep
fsep :: [Doc] -> Doc

-- | "Paragraph fill" version of cat
fcat :: [Doc] -> Doc

-- | Nested
nest :: Int -> Doc -> Doc

-- | <pre>
--   hang d1 n d2 = sep [d1, nest n d2]
--   </pre>
hang :: Doc -> Int -> Doc -> Doc

-- | <pre>
--   punctuate p [d1, ... dn] = [d1 &lt;&gt; p, d2 &lt;&gt; p, ... dn-1 &lt;&gt; p, dn]
--   </pre>
punctuate :: Doc -> [Doc] -> [Doc]

-- | Returns <a>True</a> if the document is empty
isEmpty :: Doc -> PprM Bool
to_HPJ_Doc :: Doc -> Doc
pprName :: Name -> Doc
pprName' :: NameIs -> Name -> Doc
instance Show Doc
instance Functor PprM
instance Applicative PprM
instance Monad PprM


-- | contains a prettyprinter for the Template Haskell datatypes
module Language.Haskell.TH.Ppr
nestDepth :: Int
type Precedence = Int
appPrec :: Precedence
unopPrec :: Precedence
opPrec :: Precedence
noPrec :: Precedence
parensIf :: Bool -> Doc -> Doc
pprint :: Ppr a => a -> String
class Ppr a where ppr_list = vcat . map ppr
ppr :: Ppr a => a -> Doc
ppr_list :: Ppr a => [a] -> Doc
ppr_sig :: Name -> Type -> Doc
pprFixity :: Name -> Fixity -> Doc
pprPrefixOcc :: Name -> Doc
isSymOcc :: Name -> Bool
isSymbolASCII :: Char -> Bool
pprInfixExp :: Exp -> Doc
pprExp :: Precedence -> Exp -> Doc
pprFields :: [(Name, Exp)] -> Doc
pprMaybeExp :: Precedence -> Maybe Exp -> Doc
pprGuarded :: Doc -> (Guard, Exp) -> Doc
pprBody :: Bool -> Body -> Doc
pprLit :: Precedence -> Lit -> Doc
bytesToString :: [Word8] -> String
pprString :: String -> Doc
pprPat :: Precedence -> Pat -> Doc
ppr_dec :: Bool -> Dec -> Doc
ppr_data :: Doc -> Cxt -> Name -> Doc -> [Con] -> [Name] -> Doc
ppr_newtype :: Doc -> Cxt -> Name -> Doc -> Con -> [Name] -> Doc
ppr_tySyn :: Doc -> Name -> Doc -> Type -> Doc
pprVarStrictType :: (Name, Strict, Type) -> Doc
pprStrictType :: (Strict, Type) -> Doc
pprParendType :: Type -> Doc
pprTyApp :: (Type, [Type]) -> Doc
pprFunArgType :: Type -> Doc
split :: Type -> (Type, [Type])
pprTyLit :: TyLit -> Doc
pprCxt :: Cxt -> Doc
where_clause :: [Dec] -> Doc
showtextl :: Show a => a -> Doc
hashParens :: Doc -> Doc
quoteParens :: Doc -> Doc
instance Ppr a => Ppr [a]
instance Ppr Name
instance Ppr Info
instance Ppr Module
instance Ppr ModuleInfo
instance Ppr Exp
instance Ppr Stmt
instance Ppr Match
instance Ppr Lit
instance Ppr Pat
instance Ppr Dec
instance Ppr FunDep
instance Ppr FamFlavour
instance Ppr Foreign
instance Ppr Pragma
instance Ppr Inline
instance Ppr RuleMatch
instance Ppr Phases
instance Ppr RuleBndr
instance Ppr Clause
instance Ppr Con
instance Ppr Type
instance Ppr TyLit
instance Ppr TyVarBndr
instance Ppr Role
instance Ppr Range
instance Ppr Loc


-- | The public face of Template Haskell
--   
--   For other documentation, refer to:
--   <a>http://www.haskell.org/haskellwiki/Template_Haskell</a>
module Language.Haskell.TH
data Q a
runQ :: Quasi m => Q a -> m a

-- | Report an error to the user, but allow the current splice's
--   computation to carry on. To abort the computation, use <a>fail</a>.
reportError :: String -> Q ()

-- | Report a warning to the user, and carry on.
reportWarning :: String -> Q ()

-- | Report an error (True) or warning (False), but carry on; use
--   <a>fail</a> to stop.

-- | <i>Deprecated: Use reportError or reportWarning instead</i>
report :: Bool -> String -> Q ()

-- | Recover from errors raised by <a>reportError</a> or <a>fail</a>.
recover :: Q a -> Q a -> Q a

-- | The location at which this computation is spliced.
location :: Q Loc
data Loc
[Loc] :: String -> String -> String -> CharPos -> CharPos -> Loc
[loc_filename] :: Loc -> String
[loc_package] :: Loc -> String
[loc_module] :: Loc -> String
[loc_start] :: Loc -> CharPos
[loc_end] :: Loc -> CharPos

-- | The <a>runIO</a> function lets you run an I/O computation in the
--   <a>Q</a> monad. Take care: you are guaranteed the ordering of calls to
--   <a>runIO</a> within a single <a>Q</a> computation, but not about the
--   order in which splices are run.
--   
--   Note: for various murky reasons, stdout and stderr handles are not
--   necessarily flushed when the compiler finishes running, so you should
--   flush them yourself.
runIO :: IO a -> Q a

-- | <a>reify</a> looks up information about the <a>Name</a>.
--   
--   It is sometimes useful to construct the argument name using
--   <a>lookupTypeName</a> or <a>lookupValueName</a> to ensure that we are
--   reifying from the right namespace. For instance, in this context:
--   
--   <pre>
--   data D = D
--   </pre>
--   
--   which <tt>D</tt> does <tt>reify (mkName "D")</tt> return information
--   about? (Answer: <tt>D</tt>-the-type, but don't rely on it.) To ensure
--   we get information about <tt>D</tt>-the-value, use
--   <a>lookupValueName</a>:
--   
--   <pre>
--   do
--     Just nm &lt;- lookupValueName "D"
--     reify nm
--   </pre>
--   
--   and to get information about <tt>D</tt>-the-type, use
--   <a>lookupTypeName</a>.
reify :: Name -> Q Info

-- | <tt>reifyModule mod</tt> looks up information about module
--   <tt>mod</tt>. To look up the current module, call this function with
--   the return value of <tt>thisModule</tt>.
reifyModule :: Module -> Q ModuleInfo

-- | Return the Module at the place of splicing. Can be used as an input
--   for <a>reifyModule</a>.
thisModule :: Q Module

-- | Obtained from <a>reify</a> in the <a>Q</a> Monad.
data Info

-- | A class, with a list of its visible instances
[ClassI] :: Dec -> [InstanceDec] -> Info

-- | A class method
[ClassOpI] :: Name -> Type -> ParentName -> Fixity -> Info

-- | A "plain" type constructor. "Fancier" type constructors are returned
--   using <a>PrimTyConI</a> or <a>FamilyI</a> as appropriate
[TyConI] :: Dec -> Info

-- | A type or data family, with a list of its visible instances. A closed
--   type family is returned with 0 instances.
[FamilyI] :: Dec -> [InstanceDec] -> Info

-- | A "primitive" type constructor, which can't be expressed with a
--   <a>Dec</a>. Examples: <tt>(-&gt;)</tt>, <tt>Int#</tt>.
[PrimTyConI] :: Name -> Arity -> Unlifted -> Info

-- | A data constructor
[DataConI] :: Name -> Type -> ParentName -> Fixity -> Info

-- | A "value" variable (as opposed to a type variable, see <a>TyVarI</a>).
--   
--   The <tt>Maybe Dec</tt> field contains <tt>Just</tt> the declaration
--   which defined the variable -- including the RHS of the declaration --
--   or else <tt>Nothing</tt>, in the case where the RHS is unavailable to
--   the compiler. At present, this value is _always_ <tt>Nothing</tt>:
--   returning the RHS has not yet been implemented because of lack of
--   interest.
[VarI] :: Name -> Type -> (Maybe Dec) -> Fixity -> Info

-- | A type variable.
--   
--   The <tt>Type</tt> field contains the type which underlies the
--   variable. At present, this is always <tt><a>VarT</a> theName</tt>, but
--   future changes may permit refinement of this.
[TyVarI] :: Name -> Type -> Info

-- | Obtained from <a>reifyModule</a> in the <a>Q</a> Monad.
data ModuleInfo

-- | Contains the import list of the module.
[ModuleInfo] :: [Module] -> ModuleInfo

-- | <a>InstanceDec</a> desribes a single instance of a class or type
--   function. It is just a <a>Dec</a>, but guaranteed to be one of the
--   following:
--   
--   <ul>
--   <li><a>InstanceD</a> (with empty <tt>[<a>Dec</a>]</tt>)</li>
--   <li><a>DataInstD</a> or <a>NewtypeInstD</a> (with empty derived
--   <tt>[<a>Name</a>]</tt>)</li>
--   <li><a>TySynInstD</a></li>
--   </ul>
type InstanceDec = Dec

-- | In <a>ClassOpI</a> and <a>DataConI</a>, name of the parent class or
--   type
type ParentName = Name

-- | In <a>PrimTyConI</a>, arity of the type constructor
type Arity = Int

-- | In <a>PrimTyConI</a>, is the type constructor unlifted?
type Unlifted = Bool

-- | Look up the given name in the (type namespace of the) current splice's
--   scope. See <a>Language.Haskell.TH.Syntax#namelookup</a> for more
--   details.
lookupTypeName :: String -> Q (Maybe Name)

-- | Look up the given name in the (value namespace of the) current
--   splice's scope. See <a>Language.Haskell.TH.Syntax#namelookup</a> for
--   more details.
lookupValueName :: String -> Q (Maybe Name)

-- | <tt>reifyInstances nm tys</tt> returns a list of visible instances of
--   <tt>nm tys</tt>. That is, if <tt>nm</tt> is the name of a type class,
--   then all instances of this class at the types <tt>tys</tt> are
--   returned. Alternatively, if <tt>nm</tt> is the name of a data family
--   or type family, all instances of this family at the types <tt>tys</tt>
--   are returned.
reifyInstances :: Name -> [Type] -> Q [InstanceDec]

-- | Is the list of instances returned by <a>reifyInstances</a> nonempty?
isInstance :: Name -> [Type] -> Q Bool

-- | <tt>reifyRoles nm</tt> returns the list of roles associated with the
--   parameters of the tycon <tt>nm</tt>. Fails if <tt>nm</tt> cannot be
--   found or is not a tycon. The returned list should never contain
--   <a>InferR</a>.
reifyRoles :: Name -> Q [Role]

-- | <tt>reifyAnnotations target</tt> returns the list of annotations
--   associated with <tt>target</tt>. Only the annotations that are
--   appropriately typed is returned. So if you have <tt>Int</tt> and
--   <tt>String</tt> annotations for the same target, you have to call this
--   function twice.
reifyAnnotations :: Data a => AnnLookup -> Q [a]

-- | Annotation target for reifyAnnotations
data AnnLookup
[AnnLookupModule] :: Module -> AnnLookup
[AnnLookupName] :: Name -> AnnLookup
data TExp a
unType :: TExp a -> Exp

-- | An abstract type representing names in the syntax tree.
--   
--   <a>Name</a>s can be constructed in several ways, which come with
--   different name-capture guarantees (see
--   <a>Language.Haskell.TH.Syntax#namecapture</a> for an explanation of
--   name capture):
--   
--   <ul>
--   <li>the built-in syntax <tt>'f</tt> and <tt>''T</tt> can be used to
--   construct names, The expression <tt>'f</tt> gives a <tt>Name</tt>
--   which refers to the value <tt>f</tt> currently in scope, and
--   <tt>''T</tt> gives a <tt>Name</tt> which refers to the type <tt>T</tt>
--   currently in scope. These names can never be captured.</li>
--   <li><a>lookupValueName</a> and <a>lookupTypeName</a> are similar to
--   <tt>'f</tt> and <tt>''T</tt> respectively, but the <tt>Name</tt>s are
--   looked up at the point where the current splice is being run. These
--   names can never be captured.</li>
--   <li><a>newName</a> monadically generates a new name, which can never
--   be captured.</li>
--   <li><a>mkName</a> generates a capturable name.</li>
--   </ul>
--   
--   Names constructed using <tt>newName</tt> and <tt>mkName</tt> may be
--   used in bindings (such as <tt>let x = ...</tt> or <tt>x -&gt;
--   ...</tt>), but names constructed using <tt>lookupValueName</tt>,
--   <tt>lookupTypeName</tt>, <tt>'f</tt>, <tt>''T</tt> may not.
data Name
data NameSpace

-- | Generate a capturable name. Occurrences of such names will be resolved
--   according to the Haskell scoping rules at the occurrence site.
--   
--   For example:
--   
--   <pre>
--   f = [| pi + $(varE (mkName "pi")) |]
--   ...
--   g = let pi = 3 in $f
--   </pre>
--   
--   In this case, <tt>g</tt> is desugared to
--   
--   <pre>
--   g = Prelude.pi + 3
--   </pre>
--   
--   Note that <tt>mkName</tt> may be used with qualified names:
--   
--   <pre>
--   mkName "Prelude.pi"
--   </pre>
--   
--   See also <a>dyn</a> for a useful combinator. The above example could
--   be rewritten using <tt>dyn</tt> as
--   
--   <pre>
--   f = [| pi + $(dyn "pi") |]
--   </pre>
mkName :: String -> Name

-- | Generate a fresh name, which cannot be captured.
--   
--   For example, this:
--   
--   <pre>
--   f = $(do
--     nm1 &lt;- newName "x"
--     let nm2 = <a>mkName</a> "x"
--     return (<a>LamE</a> [<a>VarP</a> nm1] (LamE [VarP nm2] (<a>VarE</a> nm1)))
--    )
--   </pre>
--   
--   will produce the splice
--   
--   <pre>
--   f = \x0 -&gt; \x -&gt; x0
--   </pre>
--   
--   In particular, the occurrence <tt>VarE nm1</tt> refers to the binding
--   <tt>VarP nm1</tt>, and is not captured by the binding <tt>VarP
--   nm2</tt>.
--   
--   Although names generated by <tt>newName</tt> cannot <i>be
--   captured</i>, they can <i>capture</i> other names. For example, this:
--   
--   <pre>
--   g = $(do
--     nm1 &lt;- newName "x"
--     let nm2 = mkName "x"
--     return (LamE [VarP nm2] (LamE [VarP nm1] (VarE nm2)))
--    )
--   </pre>
--   
--   will produce the splice
--   
--   <pre>
--   g = \x -&gt; \x0 -&gt; x0
--   </pre>
--   
--   since the occurrence <tt>VarE nm2</tt> is captured by the innermost
--   binding of <tt>x</tt>, namely <tt>VarP nm1</tt>.
newName :: String -> Q Name

-- | The name without its module prefix
nameBase :: Name -> String

-- | Module prefix of a name, if it exists
nameModule :: Name -> Maybe String

-- | Tuple type constructor
tupleTypeName :: Int -> Name

-- | Tuple data constructor
tupleDataName :: Int -> Name

-- | Unboxed tuple type constructor
unboxedTupleTypeName :: Int -> Name

-- | Unboxed tuple data constructor
unboxedTupleDataName :: Int -> Name
data Dec

-- | <pre>
--   { f p1 p2 = b where decs }
--   </pre>
[FunD] :: Name -> [Clause] -> Dec

-- | <pre>
--   { p = b where decs }
--   </pre>
[ValD] :: Pat -> Body -> [Dec] -> Dec

-- | <pre>
--   { data Cxt x =&gt; T x = A x | B (T x)
--          deriving (Z,W)}
--   </pre>
[DataD] :: Cxt -> Name -> [TyVarBndr] -> [Con] -> [Name] -> Dec

-- | <pre>
--   { newtype Cxt x =&gt; T x = A (B x)
--          deriving (Z,W)}
--   </pre>
[NewtypeD] :: Cxt -> Name -> [TyVarBndr] -> Con -> [Name] -> Dec

-- | <pre>
--   { type T x = (x,x) }
--   </pre>
[TySynD] :: Name -> [TyVarBndr] -> Type -> Dec

-- | <pre>
--   { class Eq a =&gt; Ord a where ds }
--   </pre>
[ClassD] :: Cxt -> Name -> [TyVarBndr] -> [FunDep] -> [Dec] -> Dec

-- | <pre>
--   { instance Show w =&gt; Show [w]
--          where ds }
--   </pre>
[InstanceD] :: Cxt -> Type -> [Dec] -> Dec

-- | <pre>
--   { length :: [a] -&gt; Int }
--   </pre>
[SigD] :: Name -> Type -> Dec

-- | <pre>
--   { foreign import ... }
--   { foreign export ... }
--   </pre>
[ForeignD] :: Foreign -> Dec

-- | <pre>
--   { infix 3 foo }
--   </pre>
[InfixD] :: Fixity -> Name -> Dec

-- | <pre>
--   { {--} }
--   </pre>
[PragmaD] :: Pragma -> Dec

-- | <pre>
--   { type family T a b c :: * }
--   </pre>
[FamilyD] :: FamFlavour -> Name -> [TyVarBndr] -> (Maybe Kind) -> Dec

-- | <pre>
--   { data instance Cxt x =&gt; T [x] = A x
--                                   | B (T x)
--          deriving (Z,W)}
--   </pre>
[DataInstD] :: Cxt -> Name -> [Type] -> [Con] -> [Name] -> Dec

-- | <pre>
--   { newtype instance Cxt x =&gt; T [x] = A (B x)
--          deriving (Z,W)}
--   </pre>
[NewtypeInstD] :: Cxt -> Name -> [Type] -> Con -> [Name] -> Dec

-- | <pre>
--   { type instance ... }
--   </pre>
[TySynInstD] :: Name -> TySynEqn -> Dec

-- | <pre>
--   { type family F a b :: * where ... }
--   </pre>
[ClosedTypeFamilyD] :: Name -> [TyVarBndr] -> (Maybe Kind) -> [TySynEqn] -> Dec

-- | <pre>
--   { type role T nominal representational }
--   </pre>
[RoleAnnotD] :: Name -> [Role] -> Dec

-- | <pre>
--   { deriving instance Ord a =&gt; Ord (Foo a) }
--   </pre>
[StandaloneDerivD] :: Cxt -> Type -> Dec

-- | <pre>
--   { default size :: Data a =&gt; a -&gt; Int }
--   </pre>
[DefaultSigD] :: Name -> Type -> Dec
data Con

-- | <pre>
--   C Int a
--   </pre>
[NormalC] :: Name -> [StrictType] -> Con

-- | <pre>
--   C { v :: Int, w :: a }
--   </pre>
[RecC] :: Name -> [VarStrictType] -> Con

-- | <pre>
--   Int :+ a
--   </pre>
[InfixC] :: StrictType -> Name -> StrictType -> Con

-- | <pre>
--   forall a. Eq a =&gt; C [a]
--   </pre>
[ForallC] :: [TyVarBndr] -> Cxt -> Con -> Con
data Clause

-- | <pre>
--   f { p1 p2 = body where decs }
--   </pre>
[Clause] :: [Pat] -> Body -> [Dec] -> Clause
data Strict
[IsStrict] :: Strict
[NotStrict] :: Strict
[Unpacked] :: Strict
data Foreign
[ImportF] :: Callconv -> Safety -> String -> Name -> Type -> Foreign
[ExportF] :: Callconv -> String -> Name -> Type -> Foreign
data Callconv
[CCall] :: Callconv
[StdCall] :: Callconv
[CApi] :: Callconv
[Prim] :: Callconv
[JavaScript] :: Callconv
data Safety
[Unsafe] :: Safety
[Safe] :: Safety
[Interruptible] :: Safety
data Pragma
[InlineP] :: Name -> Inline -> RuleMatch -> Phases -> Pragma
[SpecialiseP] :: Name -> Type -> (Maybe Inline) -> Phases -> Pragma
[SpecialiseInstP] :: Type -> Pragma
[RuleP] :: String -> [RuleBndr] -> Exp -> Exp -> Phases -> Pragma
[AnnP] :: AnnTarget -> Exp -> Pragma
[LineP] :: Int -> String -> Pragma
data Inline
[NoInline] :: Inline
[Inline] :: Inline
[Inlinable] :: Inline
data RuleMatch
[ConLike] :: RuleMatch
[FunLike] :: RuleMatch
data Phases
[AllPhases] :: Phases
[FromPhase] :: Int -> Phases
[BeforePhase] :: Int -> Phases
data RuleBndr
[RuleVar] :: Name -> RuleBndr
[TypedRuleVar] :: Name -> Type -> RuleBndr
data AnnTarget
[ModuleAnnotation] :: AnnTarget
[TypeAnnotation] :: Name -> AnnTarget
[ValueAnnotation] :: Name -> AnnTarget
data FunDep
[FunDep] :: [Name] -> [Name] -> FunDep
data FamFlavour
[TypeFam] :: FamFlavour
[DataFam] :: FamFlavour

-- | One equation of a type family instance or closed type family. The
--   arguments are the left-hand-side type patterns and the right-hand-side
--   result.
data TySynEqn
[TySynEqn] :: [Type] -> Type -> TySynEqn
data Fixity
[Fixity] :: Int -> FixityDirection -> Fixity
data FixityDirection
[InfixL] :: FixityDirection
[InfixR] :: FixityDirection
[InfixN] :: FixityDirection

-- | Default fixity: <tt>infixl 9</tt>
defaultFixity :: Fixity

-- | Highest allowed operator precedence for <a>Fixity</a> constructor
--   (answer: 9)
maxPrecedence :: Int
data Exp

-- | <pre>
--   { x }
--   </pre>
[VarE] :: Name -> Exp

-- | <pre>
--   data T1 = C1 t1 t2; p = {C1} e1 e2
--   </pre>
[ConE] :: Name -> Exp

-- | <pre>
--   { 5 or <tt>c</tt>}
--   </pre>
[LitE] :: Lit -> Exp

-- | <pre>
--   { f x }
--   </pre>
[AppE] :: Exp -> Exp -> Exp

-- | <pre>
--   {x + y} or {(x+)} or {(+ x)} or {(+)}
--   </pre>
[InfixE] :: (Maybe Exp) -> Exp -> (Maybe Exp) -> Exp

-- | <pre>
--   {x + y}
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
[UInfixE] :: Exp -> Exp -> Exp -> Exp

-- | <pre>
--   { (e) }
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
[ParensE] :: Exp -> Exp

-- | <pre>
--   {  p1 p2 -&gt; e }
--   </pre>
[LamE] :: [Pat] -> Exp -> Exp

-- | <pre>
--   { case m1; m2 }
--   </pre>
[LamCaseE] :: [Match] -> Exp

-- | <pre>
--   { (e1,e2) }
--   </pre>
[TupE] :: [Exp] -> Exp

-- | <pre>
--   { () }
--   </pre>
[UnboxedTupE] :: [Exp] -> Exp

-- | <pre>
--   { if e1 then e2 else e3 }
--   </pre>
[CondE] :: Exp -> Exp -> Exp -> Exp

-- | <pre>
--   { if | g1 -&gt; e1 | g2 -&gt; e2 }
--   </pre>
[MultiIfE] :: [(Guard, Exp)] -> Exp

-- | <pre>
--   { let x=e1;   y=e2 in e3 }
--   </pre>
[LetE] :: [Dec] -> Exp -> Exp

-- | <pre>
--   { case e of m1; m2 }
--   </pre>
[CaseE] :: Exp -> [Match] -> Exp

-- | <pre>
--   { do { p &lt;- e1; e2 }  }
--   </pre>
[DoE] :: [Stmt] -> Exp

-- | <pre>
--   { [ (x,y) | x &lt;- xs, y &lt;- ys ] }
--   </pre>
--   
--   The result expression of the comprehension is the <i>last</i> of the
--   <tt><a>Stmt</a></tt>s, and should be a <a>NoBindS</a>.
--   
--   E.g. translation:
--   
--   <pre>
--   [ f x | x &lt;- xs ]
--   </pre>
--   
--   <pre>
--   CompE [BindS (VarP x) (VarE xs), NoBindS (AppE (VarE f) (VarE x))]
--   </pre>
[CompE] :: [Stmt] -> Exp

-- | <pre>
--   { [ 1 ,2 .. 10 ] }
--   </pre>
[ArithSeqE] :: Range -> Exp

-- | <pre>
--   { [1,2,3] }
--   </pre>
[ListE] :: [Exp] -> Exp

-- | <pre>
--   { e :: t }
--   </pre>
[SigE] :: Exp -> Type -> Exp

-- | <pre>
--   { T { x = y, z = w } }
--   </pre>
[RecConE] :: Name -> [FieldExp] -> Exp

-- | <pre>
--   { (f x) { z = w } }
--   </pre>
[RecUpdE] :: Exp -> [FieldExp] -> Exp

-- | <pre>
--   { static e }
--   </pre>
[StaticE] :: Exp -> Exp
data Match

-- | <pre>
--   case e of { pat -&gt; body where decs }
--   </pre>
[Match] :: Pat -> Body -> [Dec] -> Match
data Body

-- | <pre>
--   f p { | e1 = e2
--         | e3 = e4 }
--    where ds
--   </pre>
[GuardedB] :: [(Guard, Exp)] -> Body

-- | <pre>
--   f p { = e } where ds
--   </pre>
[NormalB] :: Exp -> Body
data Guard

-- | <pre>
--   f x { | odd x } = x
--   </pre>
[NormalG] :: Exp -> Guard

-- | <pre>
--   f x { | Just y &lt;- x, Just z &lt;- y } = z
--   </pre>
[PatG] :: [Stmt] -> Guard
data Stmt
[BindS] :: Pat -> Exp -> Stmt
[LetS] :: [Dec] -> Stmt
[NoBindS] :: Exp -> Stmt
[ParS] :: [[Stmt]] -> Stmt
data Range
[FromR] :: Exp -> Range
[FromThenR] :: Exp -> Exp -> Range
[FromToR] :: Exp -> Exp -> Range
[FromThenToR] :: Exp -> Exp -> Exp -> Range
data Lit
[CharL] :: Char -> Lit
[StringL] :: String -> Lit

-- | Used for overloaded and non-overloaded literals. We don't have a good
--   way to represent non-overloaded literals at the moment. Maybe that
--   doesn't matter?
[IntegerL] :: Integer -> Lit
[RationalL] :: Rational -> Lit
[IntPrimL] :: Integer -> Lit
[WordPrimL] :: Integer -> Lit
[FloatPrimL] :: Rational -> Lit
[DoublePrimL] :: Rational -> Lit

-- | A primitive C-style string, type Addr#
[StringPrimL] :: [Word8] -> Lit

-- | Pattern in Haskell given in <tt>{}</tt>
data Pat

-- | <pre>
--   { 5 or <tt>c</tt> }
--   </pre>
[LitP] :: Lit -> Pat

-- | <pre>
--   { x }
--   </pre>
[VarP] :: Name -> Pat

-- | <pre>
--   { (p1,p2) }
--   </pre>
[TupP] :: [Pat] -> Pat

-- | <pre>
--   { () }
--   </pre>
[UnboxedTupP] :: [Pat] -> Pat

-- | <pre>
--   data T1 = C1 t1 t2; {C1 p1 p1} = e
--   </pre>
[ConP] :: Name -> [Pat] -> Pat

-- | <pre>
--   foo ({x :+ y}) = e
--   </pre>
[InfixP] :: Pat -> Name -> Pat -> Pat

-- | <pre>
--   foo ({x :+ y}) = e
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
[UInfixP] :: Pat -> Name -> Pat -> Pat

-- | <pre>
--   {(p)}
--   </pre>
--   
--   See <a>Language.Haskell.TH.Syntax#infix</a>
[ParensP] :: Pat -> Pat

-- | <pre>
--   { ~p }
--   </pre>
[TildeP] :: Pat -> Pat

-- | <pre>
--   { !p }
--   </pre>
[BangP] :: Pat -> Pat

-- | <pre>
--   { x @ p }
--   </pre>
[AsP] :: Name -> Pat -> Pat

-- | <pre>
--   { _ }
--   </pre>
[WildP] :: Pat

-- | <pre>
--   f (Pt { pointx = x }) = g x
--   </pre>
[RecP] :: Name -> [FieldPat] -> Pat

-- | <pre>
--   { [1,2,3] }
--   </pre>
[ListP] :: [Pat] -> Pat

-- | <pre>
--   { p :: t }
--   </pre>
[SigP] :: Pat -> Type -> Pat

-- | <pre>
--   { e -&gt; p }
--   </pre>
[ViewP] :: Exp -> Pat -> Pat
type FieldExp = (Name, Exp)
type FieldPat = (Name, Pat)
data Type

-- | <pre>
--   forall &lt;vars&gt;. &lt;ctxt&gt; -&gt; &lt;type&gt;
--   </pre>
[ForallT] :: [TyVarBndr] -> Cxt -> Type -> Type

-- | <pre>
--   T a b
--   </pre>
[AppT] :: Type -> Type -> Type

-- | <pre>
--   t :: k
--   </pre>
[SigT] :: Type -> Kind -> Type

-- | <pre>
--   a
--   </pre>
[VarT] :: Name -> Type

-- | <pre>
--   T
--   </pre>
[ConT] :: Name -> Type

-- | <pre>
--   'T
--   </pre>
[PromotedT] :: Name -> Type

-- | <pre>
--   (,), (,,), etc.
--   </pre>
[TupleT] :: Int -> Type

-- | <pre>
--   (), (), etc.
--   </pre>
[UnboxedTupleT] :: Int -> Type

-- | <pre>
--   -&gt;
--   </pre>
[ArrowT] :: Type

-- | <pre>
--   ~
--   </pre>
[EqualityT] :: Type

-- | <pre>
--   []
--   </pre>
[ListT] :: Type

-- | <pre>
--   '(), '(,), '(,,), etc.
--   </pre>
[PromotedTupleT] :: Int -> Type

-- | <pre>
--   '[]
--   </pre>
[PromotedNilT] :: Type

-- | <pre>
--   (':)
--   </pre>
[PromotedConsT] :: Type

-- | <pre>
--   *
--   </pre>
[StarT] :: Type

-- | <pre>
--   Constraint
--   </pre>
[ConstraintT] :: Type

-- | <pre>
--   0,1,2, etc.
--   </pre>
[LitT] :: TyLit -> Type
data TyVarBndr

-- | <pre>
--   a
--   </pre>
[PlainTV] :: Name -> TyVarBndr

-- | <pre>
--   (a :: k)
--   </pre>
[KindedTV] :: Name -> Kind -> TyVarBndr
data TyLit

-- | <pre>
--   2
--   </pre>
[NumTyLit] :: Integer -> TyLit

-- | <pre>
--   <a>Hello</a>
--   </pre>
[StrTyLit] :: String -> TyLit

-- | To avoid duplication between kinds and types, they are defined to be
--   the same. Naturally, you would never have a type be <a>StarT</a> and
--   you would never have a kind be <a>SigT</a>, but many of the other
--   constructors are shared. Note that the kind <tt>Bool</tt> is denoted
--   with <a>ConT</a>, not <a>PromotedT</a>. Similarly, tuple kinds are
--   made with <a>TupleT</a>, not <a>PromotedTupleT</a>.
type Kind = Type
type Cxt = [Pred]  @(Eq a, Ord b)@

-- | Since the advent of <tt>ConstraintKinds</tt>, constraints are really
--   just types. Equality constraints use the <a>EqualityT</a> constructor.
--   Constraints may also be tuples of other constraints.
type Pred = Type

-- | Role annotations
data Role

-- | <pre>
--   nominal
--   </pre>
[NominalR] :: Role

-- | <pre>
--   representational
--   </pre>
[RepresentationalR] :: Role

-- | <pre>
--   phantom
--   </pre>
[PhantomR] :: Role

-- | <pre>
--   _
--   </pre>
[InferR] :: Role
type InfoQ = Q Info
type ExpQ = Q Exp
type DecQ = Q Dec
type DecsQ = Q [Dec]
type ConQ = Q Con
type TypeQ = Q Type
type TyLitQ = Q TyLit
type CxtQ = Q Cxt
type PredQ = Q Pred
type MatchQ = Q Match
type ClauseQ = Q Clause
type BodyQ = Q Body
type GuardQ = Q Guard
type StmtQ = Q Stmt
type RangeQ = Q Range
type StrictTypeQ = Q StrictType
type VarStrictTypeQ = Q VarStrictType
type PatQ = Q Pat
type FieldPatQ = Q FieldPat
type RuleBndrQ = Q RuleBndr
type TySynEqnQ = Q TySynEqn
intPrimL :: Integer -> Lit
wordPrimL :: Integer -> Lit
floatPrimL :: Rational -> Lit
doublePrimL :: Rational -> Lit
integerL :: Integer -> Lit
rationalL :: Rational -> Lit
charL :: Char -> Lit
stringL :: String -> Lit
stringPrimL :: [Word8] -> Lit
litP :: Lit -> PatQ
varP :: Name -> PatQ
tupP :: [PatQ] -> PatQ
conP :: Name -> [PatQ] -> PatQ
uInfixP :: PatQ -> Name -> PatQ -> PatQ
parensP :: PatQ -> PatQ
infixP :: PatQ -> Name -> PatQ -> PatQ
tildeP :: PatQ -> PatQ
bangP :: PatQ -> PatQ
asP :: Name -> PatQ -> PatQ
wildP :: PatQ
recP :: Name -> [FieldPatQ] -> PatQ
listP :: [PatQ] -> PatQ
sigP :: PatQ -> TypeQ -> PatQ
viewP :: ExpQ -> PatQ -> PatQ
fieldPat :: Name -> PatQ -> FieldPatQ
normalB :: ExpQ -> BodyQ
guardedB :: [Q (Guard, Exp)] -> BodyQ
normalG :: ExpQ -> GuardQ
normalGE :: ExpQ -> ExpQ -> Q (Guard, Exp)
patG :: [StmtQ] -> GuardQ
patGE :: [StmtQ] -> ExpQ -> Q (Guard, Exp)

-- | Use with <a>caseE</a>
match :: PatQ -> BodyQ -> [DecQ] -> MatchQ

-- | Use with <a>funD</a>
clause :: [PatQ] -> BodyQ -> [DecQ] -> ClauseQ

-- | Dynamically binding a variable (unhygenic)
dyn :: String -> ExpQ

-- | <i>Deprecated: Use varE instead</i>
global :: Name -> ExpQ
varE :: Name -> ExpQ
conE :: Name -> ExpQ
litE :: Lit -> ExpQ
appE :: ExpQ -> ExpQ -> ExpQ
uInfixE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
parensE :: ExpQ -> ExpQ

-- | <pre>
--   staticE x = [| static x |]
--   </pre>
staticE :: ExpQ -> ExpQ
infixE :: Maybe ExpQ -> ExpQ -> Maybe ExpQ -> ExpQ
infixApp :: ExpQ -> ExpQ -> ExpQ -> ExpQ
sectionL :: ExpQ -> ExpQ -> ExpQ
sectionR :: ExpQ -> ExpQ -> ExpQ
lamE :: [PatQ] -> ExpQ -> ExpQ

-- | Single-arg lambda
lam1E :: PatQ -> ExpQ -> ExpQ
lamCaseE :: [MatchQ] -> ExpQ
tupE :: [ExpQ] -> ExpQ
condE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
multiIfE :: [Q (Guard, Exp)] -> ExpQ
letE :: [DecQ] -> ExpQ -> ExpQ
caseE :: ExpQ -> [MatchQ] -> ExpQ
appsE :: [ExpQ] -> ExpQ
listE :: [ExpQ] -> ExpQ
sigE :: ExpQ -> TypeQ -> ExpQ
recConE :: Name -> [Q (Name, Exp)] -> ExpQ
recUpdE :: ExpQ -> [Q (Name, Exp)] -> ExpQ
stringE :: String -> ExpQ
fieldExp :: Name -> ExpQ -> Q (Name, Exp)
fromE :: ExpQ -> ExpQ
fromThenE :: ExpQ -> ExpQ -> ExpQ
fromToE :: ExpQ -> ExpQ -> ExpQ
fromThenToE :: ExpQ -> ExpQ -> ExpQ -> ExpQ
arithSeqE :: RangeQ -> ExpQ
fromR :: ExpQ -> RangeQ
fromThenR :: ExpQ -> ExpQ -> RangeQ
fromToR :: ExpQ -> ExpQ -> RangeQ
fromThenToR :: ExpQ -> ExpQ -> ExpQ -> RangeQ
doE :: [StmtQ] -> ExpQ
compE :: [StmtQ] -> ExpQ
bindS :: PatQ -> ExpQ -> StmtQ
letS :: [DecQ] -> StmtQ
noBindS :: ExpQ -> StmtQ
parS :: [[StmtQ]] -> StmtQ
forallT :: [TyVarBndr] -> CxtQ -> TypeQ -> TypeQ
varT :: Name -> TypeQ
conT :: Name -> TypeQ
appT :: TypeQ -> TypeQ -> TypeQ
arrowT :: TypeQ
equalityT :: TypeQ
listT :: TypeQ
tupleT :: Int -> TypeQ
sigT :: TypeQ -> Kind -> TypeQ
litT :: TyLitQ -> TypeQ
promotedT :: Name -> TypeQ
promotedTupleT :: Int -> TypeQ
promotedNilT :: TypeQ
promotedConsT :: TypeQ
numTyLit :: Integer -> TyLitQ
strTyLit :: String -> TyLitQ
isStrict :: Q Strict
notStrict :: Q Strict
strictType :: Q Strict -> TypeQ -> StrictTypeQ
varStrictType :: Name -> StrictTypeQ -> VarStrictTypeQ
cxt :: [PredQ] -> CxtQ

-- | <i>Deprecated: As of template-haskell-2.10, constraint predicates
--   (Pred) are just types (Type), in keeping with ConstraintKinds. Please
--   use <a>conT</a> and <a>appT</a>.</i>
classP :: Name -> [Q Type] -> Q Pred

-- | <i>Deprecated: As of template-haskell-2.10, constraint predicates
--   (Pred) are just types (Type), in keeping with ConstraintKinds. Please
--   see <a>equalityT</a>.</i>
equalP :: TypeQ -> TypeQ -> PredQ
normalC :: Name -> [StrictTypeQ] -> ConQ
recC :: Name -> [VarStrictTypeQ] -> ConQ
infixC :: Q (Strict, Type) -> Name -> Q (Strict, Type) -> ConQ
forallC :: [TyVarBndr] -> CxtQ -> ConQ -> ConQ
varK :: Name -> Kind
conK :: Name -> Kind
tupleK :: Int -> Kind
arrowK :: Kind
listK :: Kind
appK :: Kind -> Kind -> Kind
starK :: Kind
constraintK :: Kind
nominalR :: Role
representationalR :: Role
phantomR :: Role
inferR :: Role
valD :: PatQ -> BodyQ -> [DecQ] -> DecQ
funD :: Name -> [ClauseQ] -> DecQ
tySynD :: Name -> [TyVarBndr] -> TypeQ -> DecQ
dataD :: CxtQ -> Name -> [TyVarBndr] -> [ConQ] -> [Name] -> DecQ
newtypeD :: CxtQ -> Name -> [TyVarBndr] -> ConQ -> [Name] -> DecQ
classD :: CxtQ -> Name -> [TyVarBndr] -> [FunDep] -> [DecQ] -> DecQ
instanceD :: CxtQ -> TypeQ -> [DecQ] -> DecQ
sigD :: Name -> TypeQ -> DecQ
standaloneDerivD :: CxtQ -> TypeQ -> DecQ
defaultSigD :: Name -> TypeQ -> DecQ
roleAnnotD :: Name -> [Role] -> DecQ
familyNoKindD :: FamFlavour -> Name -> [TyVarBndr] -> DecQ
familyKindD :: FamFlavour -> Name -> [TyVarBndr] -> Kind -> DecQ
dataInstD :: CxtQ -> Name -> [TypeQ] -> [ConQ] -> [Name] -> DecQ
closedTypeFamilyNoKindD :: Name -> [TyVarBndr] -> [TySynEqnQ] -> DecQ
closedTypeFamilyKindD :: Name -> [TyVarBndr] -> Kind -> [TySynEqnQ] -> DecQ
newtypeInstD :: CxtQ -> Name -> [TypeQ] -> ConQ -> [Name] -> DecQ
tySynInstD :: Name -> TySynEqnQ -> DecQ
typeFam :: FamFlavour
dataFam :: FamFlavour
tySynEqn :: [TypeQ] -> TypeQ -> TySynEqnQ
cCall :: Callconv
stdCall :: Callconv
cApi :: Callconv
prim :: Callconv
javaScript :: Callconv
unsafe :: Safety
safe :: Safety
forImpD :: Callconv -> Safety -> String -> Name -> TypeQ -> DecQ
ruleVar :: Name -> RuleBndrQ
typedRuleVar :: Name -> TypeQ -> RuleBndrQ
pragInlD :: Name -> Inline -> RuleMatch -> Phases -> DecQ
pragSpecD :: Name -> TypeQ -> Phases -> DecQ
pragSpecInlD :: Name -> TypeQ -> Inline -> Phases -> DecQ
pragSpecInstD :: TypeQ -> DecQ
pragRuleD :: String -> [RuleBndrQ] -> ExpQ -> ExpQ -> Phases -> DecQ
pragAnnD :: AnnTarget -> ExpQ -> DecQ
pragLineD :: Int -> String -> DecQ
class Ppr a where ppr_list = vcat . map ppr
ppr :: Ppr a => a -> Doc
ppr_list :: Ppr a => [a] -> Doc
pprint :: Ppr a => a -> String
pprExp :: Precedence -> Exp -> Doc
pprLit :: Precedence -> Lit -> Doc
pprPat :: Precedence -> Pat -> Doc
pprParendType :: Type -> Doc
