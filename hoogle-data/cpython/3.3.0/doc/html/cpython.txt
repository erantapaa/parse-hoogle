-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Bindings for libpython
--   
--   These bindings allow Haskell code to call CPython code. It is not
--   currently possible to call Haskell code from CPython, but this feature
--   is planned.
@package cpython
@version 3.3.0

module CPython.Types.ByteArray
data ByteArray
byteArrayType :: Type
toByteArray :: ByteString -> IO ByteArray
fromByteArray :: ByteArray -> IO ByteString

-- | Create a new byte array from any object which implements the buffer
--   protocol.
fromObject :: Object self => self -> IO (ByteArray)
append :: ByteArray -> ByteArray -> IO (ByteArray)
length :: ByteArray -> IO (Integer)
resize :: ByteArray -> Integer -> IO (())
instance Concrete ByteArray
instance Object ByteArray

module CPython.Types.Bytes
data Bytes
bytesType :: Type
toBytes :: ByteString -> IO Bytes
fromBytes :: Bytes -> IO ByteString

-- | Create a new byte string from any object which implements the buffer
--   protocol.
fromObject :: Object self => self -> IO (Bytes)
length :: Bytes -> IO (Integer)
append :: Bytes -> Bytes -> IO Bytes
instance Concrete Bytes
instance Object Bytes

module CPython.Types.Capsule
data Capsule
capsuleType :: Type

-- | Retrieve the pointer stored in the capsule. On failure, throws an
--   exception.
--   
--   The name parameter must compare exactly to the name stored in the
--   capsule. If the name stored in the capsule is <a>Nothing</a>, the name
--   passed in must also be <a>Nothing</a>. Python uses the C function
--   strcmp() to compare capsule names.
getPointer :: Capsule -> Maybe Text -> IO (Ptr ())

-- | Return the current context stored in the capsule, which might be
--   <tt>NULL</tt>.
getContext :: Capsule -> IO (Ptr ())

-- | Return the current name stored in the capsule, which might be
--   <a>Nothing</a>.
getName :: Capsule -> IO (Maybe Text)

-- | Import a pointer to a C object from a capsule attribute in a module.
--   The name parameter should specify the full name to the attribute, as
--   in <tt>"module.attribute"</tt>. The name stored in the capsule must
--   match this string exactly. If the second parameter is <a>False</a>,
--   import the module without blocking (using
--   <tt>PyImport_ImportModuleNoBlock()</tt>). Otherwise, imports the
--   module conventionally (using <tt>PyImport_ImportModule()</tt>).
--   
--   Return the capsule’s internal pointer on success. On failure, throw an
--   exception. If the module could not be imported, and if importing in
--   non-blocking mode, returns <a>Nothing</a>.
importNamed :: Text -> Bool -> IO (Maybe (Ptr ()))

-- | Determines whether or not a capsule is valid. A valid capsule's type
--   is <a>capsuleType</a>, has a non-NULL pointer stored in it, and its
--   internal name matches the name parameter. (See <a>getPointer</a> for
--   information on how capsule names are compared.)
--   
--   In other words, if <a>isValid</a> returns <a>True</a>, calls to any of
--   the accessors (any function starting with <tt>get</tt>) are guaranteed
--   to succeed.
isValid :: Capsule -> Maybe Text -> IO Bool

-- | Set the void pointer inside the capsule. The pointer may not be
--   <tt>NULL</tt>.
setPointer :: Capsule -> Ptr () -> IO (())

-- | Set the context pointer inside the capsule.
setContext :: Capsule -> Ptr () -> IO (())
instance Concrete Capsule
instance Object Capsule

module CPython.Types.Cell
data Cell
cellType :: Type

-- | Create and return a new cell containing the value <i>obj</i>.
new :: Object obj => Maybe obj -> IO Cell

-- | Return the contents of a cell.
get :: Cell -> IO (Maybe SomeObject)

-- | Set the contents of a cell to <i>obj</i>. This releases the reference
--   to any current content of the cell.
set :: Object obj => Cell -> Maybe obj -> IO ()
instance Concrete Cell
instance Object Cell

module CPython.Types.Code
data Code
codeType :: Type
instance Concrete Code
instance Object Code

module CPython.Types.Complex
data Complex
complexType :: Type
toComplex :: Complex Double -> IO Complex
fromComplex :: Complex -> IO (Complex Double)
instance Concrete Complex
instance Object Complex

module CPython.Types.Dictionary
data Dictionary
dictionaryType :: Type
new :: IO (Dictionary)

-- | Empty an existing dictionary of all key-value pairs.
clear :: Dictionary -> IO (())

-- | Determine if a dictionary contains <i>key</i>. If an item in the
--   dictionary matches <i>key</i>, return <a>True</a>, otherwise return
--   <a>False</a>. On error, throws an exception. This is equivalent to the
--   Python expression <tt>key in d</tt>.
contains :: Object key => Dictionary -> key -> IO (Bool)

-- | Return a new dictionary that contains the same key-value pairs as the
--   old dictionary.
copy :: Dictionary -> IO (Dictionary)

-- | Return the object from a dictionary which has a key <i>key</i>. Return
--   <a>Nothing</a> if the key is not present.
getItem :: Object key => Dictionary -> key -> IO (Maybe SomeObject)

-- | Inserts <i>value</i> into a dictionary with a key of <i>key</i>.
--   <i>key</i> must be hashable; if it isn’t, throws <tt>TypeError</tt>.
setItem :: (Object key, Object value) => Dictionary -> key -> value -> IO (())

-- | Remove the entry in a dictionary with key <i>key</i>. <i>key</i> must
--   be hashable; if it isn’t, throws <tt>TypeError</tt>.
deleteItem :: Object key => Dictionary -> key -> IO (())

-- | Return a <a>List</a> containing all the items in the dictionary, as in
--   the Python method <tt>dict.items()</tt>.
items :: Dictionary -> IO (List)

-- | Return a <a>List</a> containing all the keys in the dictionary, as in
--   the Python method <tt>dict.keys()</tt>.
keys :: Dictionary -> IO (List)

-- | Return a <a>List</a> containing all the values in the dictionary, as
--   in the Python method <tt>dict.values()</tt>.
values :: Dictionary -> IO (List)

-- | Return the number of items in the dictionary. This is equivalent to
--   <tt>len(d)</tt>.
size :: Dictionary -> IO (Integer)

-- | Iterate over mapping object <i>b</i> adding key-value pairs to a
--   dictionary. <i>b</i> may be a dictionary, or any object supporting
--   <a>keys</a> and <a>getItem</a>. If the third parameter is <a>True</a>,
--   existing pairs in will be replaced if a matching key is found in
--   <i>b</i>, otherwise pairs will only be added if there is not already a
--   matching key.
merge :: Mapping b => Dictionary -> b -> Bool -> IO (())

-- | This is the same as <tt>(\a b -&gt; <a>merge</a> a b True)</tt> in
--   Haskell, or <tt>a.update(b)</tt> in Python.
update :: Mapping b => Dictionary -> b -> IO (())

-- | Update or merge into a dictionary, from the key-value pairs in
--   <i>seq2</i>. <i>seq2</i> must be an iterable object producing iterable
--   objects of length 2, viewed as key-value pairs. In case of duplicate
--   keys, the last wins if the third parameter is <a>True</a>, otherwise
--   the first wins. Equivalent Python:
--   
--   <pre>
--   def mergeFromSeq2(a, seq2, override):
--   	for key, value in seq2:
--   		if override or key not in a:
--   			a[key] = value
--   </pre>
mergeFromSeq2 :: Object seq2 => Dictionary -> seq2 -> Bool -> IO (())
instance Concrete Dictionary

module CPython.Types.Exception
data Exception
exceptionType :: Exception -> SomeObject
exceptionValue :: Exception -> SomeObject
exceptionTraceback :: Exception -> Maybe SomeObject

module CPython.Types.Float
data Float
floatType :: Type
toFloat :: Double -> IO (Float)
fromFloat :: Float -> IO (Double)
instance Concrete Float
instance Object Float

module CPython.Types.InstanceMethod
data InstanceMethod
instanceMethodType :: Type
new :: Object func => func -> IO (InstanceMethod)
function :: InstanceMethod -> IO (SomeObject)
instance Concrete InstanceMethod
instance Object InstanceMethod

module CPython.Types.Iterator
data SequenceIterator
sequenceIteratorType :: Type

-- | Return an <a>Iterator</a> that works with a general sequence object,
--   <i>seq</i>. The iteration ends when the sequence raises
--   <tt>IndexError</tt> for the subscripting operation.
sequenceIteratorNew :: Sequence seq => seq -> IO (SequenceIterator)
data CallableIterator
callableIteratorType :: Type

-- | Return a new <a>Iterator</a>. The first parameter, <i>callable</i>,
--   can be any Python callable object that can be called with no
--   parameters; each call to it should return the next item in the
--   iteration. When <i>callable</i> returns a value equal to
--   <i>sentinel</i>, the iteration will be terminated.
callableIteratorNew :: (Object callable, Object sentinel) => callable -> sentinel -> IO (CallableIterator)
instance Concrete CallableIterator
instance Object CallableIterator
instance Iterator CallableIterator
instance Concrete SequenceIterator
instance Object SequenceIterator
instance Iterator SequenceIterator

module CPython.Types.Method
data Method
methodType :: Type
new :: (Object func, Object self) => func -> self -> IO (Method)
function :: Method -> IO (SomeObject)
self :: Method -> IO (SomeObject)
instance Concrete Method
instance Object Method

module CPython.Types.Slice
data Slice
sliceType :: Type

-- | Return a new slice object with the given values. The <i>start</i>,
--   <i>stop</i>, and <i>step</i> parameters are used as the values of the
--   slice object attributes of the same names. Any of the values may be
--   <a>Nothing</a>, in which case <tt>None</tt> will be used for the
--   corresponding attribute.
new :: (Object start, Object stop, Object step) => Maybe start -> Maybe stop -> Maybe step -> IO Slice

-- | Retrieve the start, stop, step, and slice length from a <a>Slice</a>,
--   assuming a sequence of the given length.
getIndices :: Slice -> Integer -> IO (Integer, Integer, Integer, Integer)
instance Concrete Slice
instance Object Slice

module CPython.Types.Tuple
data Tuple
tupleType :: Type
toTuple :: [SomeObject] -> IO Tuple

-- | Convert any object implementing the iterator protocol to a
--   <a>Tuple</a>.
iterableToTuple :: Object iter => iter -> IO Tuple
fromTuple :: Tuple -> IO [SomeObject]
length :: Tuple -> IO (Integer)

-- | Return the object at a given index from a tuple, or throws
--   <tt>IndexError</tt> if the index is out of bounds.
getItem :: Tuple -> Integer -> IO (SomeObject)

-- | Take a slice of a tuple from <i>low</i> to <i>high</i>, and return it
--   as a new tuple.
getSlice :: Tuple -> Integer -> Integer -> IO (Tuple)
setItem :: Object o => Tuple -> Integer -> o -> IO ()
instance Concrete Tuple

module CPython.Types.List
data List
listType :: Type
toList :: [SomeObject] -> IO List

-- | Convert any object implementing the iterator protocol to a
--   <a>List</a>.
iterableToList :: Object iter => iter -> IO List
fromList :: List -> IO [SomeObject]
length :: List -> IO (Integer)

-- | Returns the object at a given position in the list. The position must
--   be positive; indexing from the end of the list is not supported. If
--   the position is out of bounds, throws an <tt>IndexError</tt>
--   exception.
getItem :: List -> Integer -> IO (SomeObject)

-- | Set the item at a given index.
setItem :: Object o => List -> Integer -> o -> IO ()

-- | Inserts <i>item</i> into the list in front of the given index. Throws
--   an exception if unsuccessful. Analogous to <tt>list.insert(index,
--   item)</tt>.
insert :: Object item => List -> Integer -> item -> IO (())

-- | Append <i>item</i> to the end of th list. Throws an exception if
--   unsuccessful. Analogous to <tt>list.append(item)</tt>.
append :: Object item => List -> item -> IO (())

-- | Return a list of the objects in list containing the objects between
--   the given indexes. Throws an exception if unsuccessful. Analogous to
--   <tt>list[low:high]</tt>. Negative indices, as when slicing from
--   Python, are not supported.
getSlice :: List -> Integer -> Integer -> IO (List)

-- | Sets the slice of a list between <i>low</i> and <i>high</i> to the
--   contents of a replacement list. Analogous to <tt>list[low:high] =
--   replacement</tt>. The replacement may be <a>Nothing</a>, indicating
--   the assignment of an empty list (slice deletion). Negative indices, as
--   when slicing from Python, are not supported.
setSlice :: List -> Integer -> Integer -> Maybe List -> IO ()

-- | Sort the items of a list in place. This is equivalent to
--   <tt>list.sort()</tt>.
sort :: List -> IO (())

-- | Reverses the items of a list in place. This is equivalent to
--   <tt>list.reverse()</tt>.
reverse :: List -> IO (())

-- | Return a new <a>Tuple</a> containing the contents of a list;
--   equivalent to <tt>tuple(list)</tt>.
toTuple :: List -> IO (Tuple)
instance Concrete List


-- | Any functionality not listed below is best accessed using the either
--   the <a>Object</a> protocol (including <tt>callMethod</tt>,
--   <tt>richCompare</tt>, <tt>hash</tt>, <tt>repr</tt>, <tt>isTrue</tt>,
--   and <tt>getIter</tt>) or the <tt>Number</tt> protocol (including
--   <a>and</a>, <a>subtract</a>, <a>or</a>, <a>xor</a>,
--   <tt>inPlaceAnd</tt>, <tt>inPlaceSubtract</tt>, <tt>inPlaceOr</tt>, and
--   <tt>inPlaceXor</tt>).
module CPython.Types.Set
class Object a => AnySet a
data Set
data FrozenSet
setType :: Type
frozenSetType :: Type
toSet :: [SomeObject] -> IO Set
toFrozenSet :: [SomeObject] -> IO FrozenSet

-- | Return a new <a>Set</a> from the contents of an iterable
--   <a>Object</a>. The object may be <a>Nothing</a> to create an empty
--   set. Throws a <tt>TypeError</tt> if the object is not iterable.
iterableToSet :: Object obj => obj -> IO (Set)

-- | Return a new <a>FrozenSet</a> from the contents of an iterable
--   <a>Object</a>. The object may be <a>Nothing</a> to create an empty
--   frozen set. Throws a <tt>TypeError</tt> if the object is not iterable.
iterableToFrozenSet :: Object obj => obj -> IO (FrozenSet)
fromSet :: AnySet set => set -> IO [SomeObject]

-- | Return the size of a <a>Set</a> or <a>FrozenSet</a>.
size :: AnySet set => set -> IO (Integer)

-- | Return <a>True</a> if found, <a>False</a> if not found. Unlike the
--   Python <tt>__contains__()</tt> method, this computation does not
--   automatically convert unhashable <a>Set</a>s into temporary
--   <a>FrozenSet</a>s. Throws a <tt>TypeError</tt> if the key is
--   unhashable.
contains :: (AnySet set, Object key) => set -> key -> IO (Bool)

-- | Add <i>key</i> to a <a>Set</a>. Also works with <a>FrozenSet</a> (like
--   <a>setItem</a> it can be used to fill-in the values of brand new
--   <a>FrozenSet</a>s before they are exposed to other code). Throws a
--   <tt>TypeError</tt> if the key is unhashable. Throws a
--   <tt>MemoryError</tt> if there is no room to grow.
add :: (AnySet set, Object key) => set -> key -> IO (())

-- | Return <a>True</a> if found and removed, <a>False</a> if not found (no
--   action taken). Does not throw <tt>KeyError</tt> for missing keys.
--   Throws a <tt>TypeError</tt> if <i>key</i> is unhashable. Unlike the
--   Python <tt>discard()</tt> method, this computation does not
--   automatically convert unhashable sets into temporary
--   <a>FrozenSet</a>s.
discard :: Object key => Set -> key -> IO (Bool)

-- | Return an arbitrary object in the set, and removes the object from the
--   set. Throws <tt>KeyError</tt> if the set is empty.
pop :: Set -> IO (SomeObject)

-- | Remove all elements from a set.
clear :: Set -> IO (())
instance AnySet FrozenSet
instance AnySet Set
instance Concrete FrozenSet
instance Object FrozenSet
instance Concrete Set
instance Object Set

module CPython.Types.Type
data Type
typeType :: Type

-- | Returns <a>True</a> if the first parameter is a subtype of the second
--   parameter.
isSubtype :: Type -> Type -> IO (Bool)
instance Concrete Type

module CPython.Types.Unicode
data Unicode
type Encoding = Text
data ErrorHandling
Strict :: ErrorHandling
Replace :: ErrorHandling
Ignore :: ErrorHandling
unicodeType :: Type
toUnicode :: Text -> IO Unicode
fromUnicode :: Unicode -> IO Text
length :: Unicode -> IO (Integer)

-- | Coerce an encoded object <i>obj</i> to an Unicode object.
--   
--   <a>Bytes</a> and other char buffer compatible objects are decoded
--   according to the given encoding and error handling mode.
--   
--   All other objects, including <a>Unicode</a> objects, cause a
--   <tt>TypeError</tt> to be thrown.
fromEncodedObject :: Object obj => obj -> Encoding -> ErrorHandling -> IO (Unicode)

-- | Shortcut for <tt><a>fromEncodedObject</a> "utf-8" <a>Strict</a></tt>
fromObject :: Object obj => obj -> IO Unicode

-- | Encode a <a>Unicode</a> object and return the result as <a>Bytes</a>
--   object. The encoding and error mode have the same meaning as the
--   parameters of the the <tt>str.encode()</tt> method. The codec to be
--   used is looked up using the Python codec registry.
encode :: Unicode -> Encoding -> ErrorHandling -> IO (Bytes)

-- | Create a <a>Unicode</a> object by decoding a <a>Bytes</a> object. The
--   encoding and error mode have the same meaning as the parameters of the
--   the <tt>str.encode()</tt> method. The codec to be used is looked up
--   using the Python codec registry.
decode :: Bytes -> Encoding -> ErrorHandling -> IO Unicode
append :: Unicode -> Unicode -> IO (Unicode)

-- | Split a string giving a <a>List</a> of <a>Unicode</a> objects. If the
--   separator is <a>Nothing</a>, splitting will be done at all whitespace
--   substrings. Otherwise, splits occur at the given separator. Separators
--   are not included in the resulting list.
split :: Unicode -> Maybe Unicode -> Maybe Integer -> IO List

-- | Split a <a>Unicode</a> string at line breaks, returning a list of
--   <a>Unicode</a> strings. CRLF is considered to be one line break. If
--   the second parameter is <a>False</a>, the line break characters are
--   not included in the resulting strings.
splitLines :: Unicode -> Bool -> IO (List)

-- | Translate a string by applying a character mapping table to it.
--   
--   The mapping table must map Unicode ordinal integers to Unicode ordinal
--   integers or <tt>None</tt> (causing deletion of the character).
--   
--   Mapping tables need only provide the <tt>__getitem__()</tt> interface;
--   dictionaries and sequences work well. Unmapped character ordinals
--   (ones which cause a <tt>LookupError</tt>) are left untouched and are
--   copied as-is.
--   
--   The error mode has the usual meaning for codecs.
translate :: Object table => Unicode -> table -> ErrorHandling -> IO (Unicode)

-- | Join a sequence of strings using the given separator.
join :: Sequence seq => Unicode -> seq -> IO (Unicode)
data MatchDirection
Prefix :: MatchDirection
Suffix :: MatchDirection

-- | Return <a>True</a> if the substring matches
--   <tt>string*[*start:end]</tt> at the given tail end (either a
--   <a>Prefix</a> or <a>Suffix</a> match), <a>False</a> otherwise.
tailMatch :: Unicode -> Unicode -> Integer -> Integer -> MatchDirection -> IO Bool
data FindDirection
Forwards :: FindDirection
Backwards :: FindDirection

-- | Return the first position of the substring in
--   <tt>string*[*start:end]</tt> using the given direction. The return
--   value is the index of the first match; a value of <a>Nothing</a>
--   indicates that no match was found.
find :: Unicode -> Unicode -> Integer -> Integer -> FindDirection -> IO (Maybe Integer)

-- | Return the number of non-overlapping occurrences of the substring in
--   <tt>string[start:end]</tt>.
count :: Unicode -> Unicode -> Integer -> Integer -> IO Integer

-- | Replace occurrences of the substring with a given replacement. If the
--   maximum count is <a>Nothing</a>, replace all occurences.
replace :: Unicode -> Unicode -> Unicode -> Maybe Integer -> IO Unicode

-- | Return a new <a>Unicode</a> object from the given format and args;
--   this is analogous to <tt>format % args</tt>.
format :: Unicode -> Tuple -> IO (Unicode)

-- | Check whether <i>element</i> is contained in a string.
--   
--   <i>element</i> has to coerce to a one element string.
contains :: Object element => Unicode -> element -> IO (Bool)
instance Show ErrorHandling
instance Eq ErrorHandling
instance Show MatchDirection
instance Eq MatchDirection
instance Show FindDirection
instance Eq FindDirection
instance Concrete Unicode
instance Object Unicode

module CPython.Types.WeakReference
data Reference
data Proxy

-- | Return a weak reference for the object. This will always return a new
--   reference, but is not guaranteed to create a new object; an existing
--   reference object may be returned. The second parameter,
--   <i>callback</i>, can be a callable object that receives notification
--   when <i>obj</i> is garbage collected; it should accept a single
--   parameter, which will be the weak reference object itself. If ob is
--   not a weakly-referencable object, or if <i>callback</i> is not
--   callable, this will throw a <tt>TypeError</tt>.
newReference :: (Object obj, Object callback) => obj -> Maybe callback -> IO Reference

-- | Return a weak reference proxy for the object. This will always return
--   a new reference, but is not guaranteed to create a new object; an
--   existing proxy may be returned. The second parameter, <i>callback</i>,
--   can be a callable object that receives notification when <i>obj</i> is
--   garbage collected; it should accept a single parameter, which will be
--   the weak reference object itself. If ob is not a weakly-referencable
--   object, or if <i>callback</i> is not callable, this will throw a
--   <tt>TypeError</tt>.
newProxy :: (Object obj, Object callback) => obj -> Maybe callback -> IO Proxy

-- | Return the referenced object from a weak reference. If the referent is
--   no longer live, returns <tt>None</tt>.
getObject :: Reference -> IO (SomeObject)
instance Object Proxy
instance Object Reference

module CPython.Constants

-- | The Python <tt>None</tt> object, denoting lack of value.
none :: IO (SomeObject)

-- | The Python <tt>True</tt> object.
true :: IO (SomeObject)

-- | The Python <tt>False</tt> object.
false :: IO (SomeObject)
isNone :: SomeObject -> IO Bool
isTrue :: SomeObject -> IO Bool
isFalse :: SomeObject -> IO Bool

module CPython.Types.Function
data Function
functionType :: Type

-- | Return a new function associated with the given code object. The
--   second parameter will be used as the globals accessible to the
--   function.
--   
--   The function's docstring, name, and <tt>__module__</tt> are retrieved
--   from the code object. The parameter defaults and closure are set to
--   <a>Nothing</a>.
new :: Code -> Dictionary -> IO (Function)

-- | Return the code object associated with a function.
getCode :: Function -> IO (Code)

-- | Return the globals dictionary associated with a function.
getGlobals :: Function -> IO (Dictionary)

-- | Return the <tt>__module__</tt> attribute of a function. This is
--   normally a <tt>Unicode</tt> containing the module name, but can be set
--   to any other object by Python code.
getModule :: Function -> IO (SomeObject)

-- | Return the default parameter values for a function. This can be a
--   tuple or <a>Nothing</a>.
getDefaults :: Function -> IO (Maybe Tuple)

-- | Set the default values for a function.
setDefaults :: Function -> Maybe Tuple -> IO (())

-- | Return the closure associated with a function. This can be
--   <a>Nothing</a>, or a tuple of <tt>Cell</tt>s.
getClosure :: Function -> IO (Maybe Tuple)

-- | Set the closure associated with a function. The tuple should contain
--   <tt>Cell</tt>s.
setClosure :: Function -> Maybe Tuple -> IO (())

-- | Return the annotations for a function. This can be a mutable
--   dictionary, or <a>Nothing</a>.
getAnnotations :: Function -> IO (Maybe Dictionary)

-- | Set the annotations for a function object.
setAnnotations :: Function -> Maybe Dictionary -> IO (())
instance Concrete Function
instance Object Function

module CPython.Protocols.Object
class Object a
toObject :: Object a => a -> SomeObject
class Object a => Concrete a
data SomeObject

-- | Returns a <a>Type</a> object corresponding to the object type of
--   <i>self</i>. On failure, throws <tt>SystemError</tt>. This is
--   equivalent to the Python expression <tt>type(o)</tt>.
getType :: Object self => self -> IO (Type)

-- | Returns <a>True</a> if <i>inst</i> is an instance of the class
--   <i>cls</i> or a subclass of <i>cls</i>, or <a>False</a> if not. On
--   error, throws an exception. If <i>cls</i> is a type object rather than
--   a class object, <a>isInstance</a> returns <a>True</a> if <i>inst</i>
--   is of type <i>cls</i>. If <i>cls</i> is a tuple, the check will be
--   done against every entry in <i>cls</i>. The result will be <a>True</a>
--   when at least one of the checks returns <a>True</a>, otherwise it will
--   be <a>False</a>. If <i>inst</i> is not a class instance and <i>cls</i>
--   is neither a type object, nor a class object, nor a tuple, <i>inst</i>
--   must have a <tt>__class__</tt> attribute ߞ the class relationship of
--   the value of that attribute with <i>cls</i> will be used to determine
--   the result of this function.
--   
--   Subclass determination is done in a fairly straightforward way, but
--   includes a wrinkle that implementors of extensions to the class system
--   may want to be aware of. If A and B are class objects, B is a subclass
--   of A if it inherits from A either directly or indirectly. If either is
--   not a class object, a more general mechanism is used to determine the
--   class relationship of the two objects. When testing if B is a subclass
--   of A, if A is B, <a>isSubclass</a> returns <a>True</a>. If A and B are
--   different objects, Bߢs <tt>__bases__</tt> attribute is searched in a
--   depth-first fashion for A ߞ the presence of the <tt>__bases__</tt>
--   attribute is considered sufficient for this determination.
isInstance :: (Object self, Object cls) => self -> cls -> IO (Bool)

-- | Returns <a>True</a> if the class <i>derived</i> is identical to or
--   derived from the class <i>cls</i>, otherwise returns <a>False</a>. In
--   case of an error, throws an exception. If <i>cls</i> is a tuple, the
--   check will be done against every entry in <i>cls</i>. The result will
--   be <a>True</a> when at least one of the checks returns <a>True</a>,
--   otherwise it will be <a>False</a>. If either <i>derived</i> or
--   <i>cls</i> is not an actual class object (or tuple), this function
--   uses the generic algorithm described above.
isSubclass :: (Object derived, Object cls) => derived -> cls -> IO (Bool)

-- | Attempt to cast an object to some concrete class. If the object isn't
--   an instance of the class or subclass, returns <a>Nothing</a>.
cast :: (Object a, Concrete b) => a -> IO (Maybe b)

-- | Returns <a>True</a> if <i>self</i> has an attribute with the given
--   name, and <a>False</a> otherwise. This is equivalent to the Python
--   expression <tt>hasattr(self, name)</tt>
hasAttribute :: Object self => self -> Unicode -> IO (Bool)

-- | Retrieve an attribute with the given name from object <i>self</i>.
--   Returns the attribute value on success, and throws an exception on
--   failure. This is the equivalent of the Python expression
--   <tt>self.name</tt>.
getAttribute :: Object self => self -> Unicode -> IO (SomeObject)

-- | Set the value of the attribute with the given name, for object
--   <i>self</i>, to the value <i>v</i>. THrows an exception on failure.
--   This is the equivalent of the Python statement <tt>self.name = v</tt>.
setAttribute :: (Object self, Object v) => self -> Unicode -> v -> IO (())

-- | Delete an attribute with the given name, for object <i>self</i>.
--   Throws an exception on failure. This is the equivalent of the Python
--   statement <tt>del self.name</tt>.
deleteAttribute :: Object self => self -> Unicode -> IO (())

-- | Print <tt>repr(self)</tt> to a handle.
print :: Object self => self -> Handle -> IO ()

-- | Compute a string representation of object <i>self</i>, or throw an
--   exception on failure. This is the equivalent of the Python expression
--   <tt>repr(self)</tt>.
repr :: Object self => self -> IO (Unicode)
ascii :: Object self => self -> IO (Unicode)

-- | Compute a string representation of object <i>self</i>, or throw an
--   exception on failure. This is the equivalent of the Python expression
--   <tt>str(self)</tt>.
string :: Object self => self -> IO (Unicode)

-- | Compute a bytes representation of object <i>self</i>, or throw an
--   exception on failure. This is equivalent to the Python expression
--   <tt>bytes(self)</tt>.
bytes :: Object self => self -> IO (Bytes)

-- | Determine if the object <i>self</i> is callable.
callable :: Object self => self -> IO (Bool)

-- | Call a callable Python object <i>self</i>, with arguments given by the
--   tuple and named arguments given by the dictionary. Returns the result
--   of the call on success, or throws an exception on failure. This is the
--   equivalent of the Python expression <tt>self(*args, **kw)</tt>.
call :: Object self => self -> Tuple -> Dictionary -> IO SomeObject

-- | Call a callable Python object <i>self</i>, with arguments given by the
--   list.
callArgs :: Object self => self -> [SomeObject] -> IO SomeObject

-- | Call the named method of object <i>self</i>, with arguments given by
--   the tuple and named arguments given by the dictionary. Returns the
--   result of the call on success, or throws an exception on failure. This
--   is the equivalent of the Python expression <tt>self.method(args)</tt>.
callMethod :: Object self => self -> Text -> Tuple -> Dictionary -> IO SomeObject

-- | Call the named method of object <i>self</i>, with arguments given by
--   the list. Returns the result of the call on success, or throws an
--   exception on failure. This is the equivalent of the Python expression
--   <tt>self.method(args)</tt>.
callMethodArgs :: Object self => self -> Text -> [SomeObject] -> IO SomeObject
data Comparison
LT :: Comparison
LE :: Comparison
EQ :: Comparison
NE :: Comparison
GT :: Comparison
GE :: Comparison

-- | Compare the values of <i>a</i> and <i>b</i> using the specified
--   comparison. If an exception is raised, throws an exception.
richCompare :: (Object a, Object b) => a -> b -> Comparison -> IO (Bool)

-- | Returns <a>True</a> if the object <i>self</i> is considered to be
--   true, and <a>False</a> otherwise. This is equivalent to the Python
--   expression <tt>not not self</tt>. On failure, throws an exception.
toBool :: Object self => self -> IO (Bool)

-- | Compute and return the hash value of an object <i>self</i>. On
--   failure, throws an exception. This is the equivalent of the Python
--   expression <tt>hash(self)</tt>.
hash :: Object self => self -> IO (Integer)

-- | This is equivalent to the Python expression <tt>dir(self)</tt>,
--   returning a (possibly empty) list of strings appropriate for the
--   object argument, or throws an exception if there was an error.
dir :: Object self => self -> IO (List)

-- | This is equivalent to the Python expression <tt>iter(self)</tt>. It
--   returns a new iterator for the object argument, or the object itself
--   if the object is already an iterator. Throws <tt>TypeError</tt> if the
--   object cannot be iterated.
getIterator :: Object self => self -> IO (SomeObject)
instance Show Comparison
instance Enum HSCPythonComparisonEnum

module CPython.Types.Integer
data Integer
integerType :: Type
toInteger :: Integer -> IO Integer
fromInteger :: Integer -> IO Integer
instance Concrete Integer
instance Object Integer

module CPython.Types.Module
data Module
moduleType :: Type

-- | Return a new module object with the <tt>__name__</tt> attribute set.
--   Only the module’s <tt>__doc__</tt> and <tt>__name__</tt> attributes
--   are filled in; the caller is responsible for providing a
--   <tt>__file__</tt> attribute.
new :: Text -> IO (Module)

-- | Return the dictionary object that implements a module’s namespace;
--   this object is the same as the <tt>__dict__</tt> attribute of the
--   module. This computation never fails. It is recommended extensions use
--   other computations rather than directly manipulate a module’s
--   <tt>__dict__</tt>.
getDictionary :: Module -> IO (Dictionary)

-- | Returns a module’s <tt>__name__</tt> value. If the module does not
--   provide one, or if it is not a string, throws <tt>SystemError</tt>.
getName :: Module -> IO Text

-- | Returns the name of the file from which a module was loaded using the
--   module’s <tt>__file__</tt> attribute. If this is not defined, or if it
--   is not a string, throws <tt>SystemError</tt>.
getFilename :: Module -> IO Text

-- | Add an object to a module with the given name. This is a convenience
--   computation which can be used from the module’s initialization
--   computation.
addObject :: Object value => Module -> Text -> value -> IO ()

-- | Add an integer constant to a module. This convenience computation can
--   be used from the module’s initialization computation.
addIntegerConstant :: Module -> Text -> Integer -> IO ()

-- | Add a string constant to a module. This convenience computation can be
--   used from the module’s initialization computation.
addTextConstant :: Module -> Text -> Text -> IO ()

-- | This is a higher-level interface that calls the current “import hook”
--   (with an explicit level of <tt>0</tt>, meaning absolute import). It
--   invokes the <tt>__import__()</tt> computation from the
--   <tt>__builtins__</tt> of the current globals. This means that the
--   import is done using whatever import hooks are installed in the
--   current environment.
--   
--   This computation always uses absolute imports.
importModule :: Text -> IO Module

-- | Reload a module. If an error occurs, an exception is thrown and the
--   old module still exists.
reload :: Module -> IO (Module)
instance Concrete Module
instance Object Module

module CPython.Types
data ByteArray
data Bytes
data Capsule
data Cell
data Code
data Complex
data Dictionary
data Exception
data Float
data Function
data InstanceMethod
data Integer
data SequenceIterator
data CallableIterator
data List
data Method
data Module
class Object a => AnySet a
data Set
data FrozenSet
data Slice
data Tuple
data Type
data Unicode
data Reference
data Proxy
byteArrayType :: Type
bytesType :: Type
capsuleType :: Type
cellType :: Type
codeType :: Type
complexType :: Type
dictionaryType :: Type
floatType :: Type
functionType :: Type
instanceMethodType :: Type
integerType :: Type
sequenceIteratorType :: Type
callableIteratorType :: Type
listType :: Type
methodType :: Type
moduleType :: Type
setType :: Type
frozenSetType :: Type
sliceType :: Type
tupleType :: Type
typeType :: Type
unicodeType :: Type
toByteArray :: ByteString -> IO ByteArray
fromByteArray :: ByteArray -> IO ByteString
toBytes :: ByteString -> IO Bytes
fromBytes :: Bytes -> IO ByteString
toComplex :: Complex Double -> IO Complex
fromComplex :: Complex -> IO (Complex Double)
toFloat :: Double -> IO (Float)
fromFloat :: Float -> IO (Double)
toInteger :: Integer -> IO Integer
fromInteger :: Integer -> IO Integer
toList :: [SomeObject] -> IO List

-- | Convert any object implementing the iterator protocol to a
--   <a>List</a>.
iterableToList :: Object iter => iter -> IO List
fromList :: List -> IO [SomeObject]
toSet :: [SomeObject] -> IO Set
toFrozenSet :: [SomeObject] -> IO FrozenSet

-- | Return a new <a>Set</a> from the contents of an iterable
--   <a>Object</a>. The object may be <a>Nothing</a> to create an empty
--   set. Throws a <tt>TypeError</tt> if the object is not iterable.
iterableToSet :: Object obj => obj -> IO (Set)

-- | Return a new <a>FrozenSet</a> from the contents of an iterable
--   <a>Object</a>. The object may be <a>Nothing</a> to create an empty
--   frozen set. Throws a <tt>TypeError</tt> if the object is not iterable.
iterableToFrozenSet :: Object obj => obj -> IO (FrozenSet)
fromSet :: AnySet set => set -> IO [SomeObject]
toTuple :: [SomeObject] -> IO Tuple

-- | Convert any object implementing the iterator protocol to a
--   <a>Tuple</a>.
iterableToTuple :: Object iter => iter -> IO Tuple
fromTuple :: Tuple -> IO [SomeObject]
toUnicode :: Text -> IO Unicode
fromUnicode :: Unicode -> IO Text

module CPython.Protocols.Iterator
class Object a => Iterator a
toIterator :: Iterator a => a -> SomeIterator
data SomeIterator

-- | Attempt to convert an object to a generic <a>Iterator</a>. If the
--   object does not implement the iterator protocol, returns
--   <a>Nothing</a>.
castToIterator :: Object a => a -> IO (Maybe SomeIterator)

-- | Return the next value from the iteration, or <a>Nothing</a> if there
--   are no remaining items.
next :: Iterator iter => iter -> IO (Maybe SomeObject)

module CPython.Protocols.Mapping
class Object a => Mapping a
toMapping :: Mapping a => a -> SomeMapping
data SomeMapping
castToMapping :: Object a => a -> IO (Maybe SomeMapping)
getItem :: (Mapping self, Object key) => self -> key -> IO (SomeObject)
setItem :: (Mapping self, Object key, Object value) => self -> key -> value -> IO (())
deleteItem :: (Mapping self, Object key) => self -> key -> IO (())
size :: Mapping self => self -> IO (Integer)
hasKey :: (Mapping self, Object key) => self -> key -> IO (Bool)
keys :: Mapping self => self -> IO (List)
values :: Mapping self => self -> IO (List)
items :: Mapping self => self -> IO (List)
instance Mapping Dictionary

module CPython.Protocols.Number
class Object a => Number a
toNumber :: Number a => a -> SomeNumber
data SomeNumber
castToNumber :: Object a => a -> IO (Maybe SomeNumber)
add :: (Number a, Number b) => a -> b -> IO (SomeNumber)
subtract :: (Number a, Number b) => a -> b -> IO (SomeNumber)
multiply :: (Number a, Number b) => a -> b -> IO (SomeNumber)
floorDivide :: (Number a, Number b) => a -> b -> IO (SomeNumber)
trueDivide :: (Number a, Number b) => a -> b -> IO (SomeNumber)
remainder :: (Number a, Number b) => a -> b -> IO (SomeNumber)
divmod :: (Number a, Number b) => a -> b -> IO (SomeNumber)
power :: (Number a, Number b, Number c) => a -> b -> Maybe c -> IO SomeNumber
negative :: Number a => a -> IO (SomeNumber)
positive :: Number a => a -> IO (SomeNumber)
absolute :: Number a => a -> IO (SomeNumber)
invert :: Number a => a -> IO (SomeNumber)
shiftL :: (Number a, Number b) => a -> b -> IO (SomeNumber)
shiftR :: (Number a, Number b) => a -> b -> IO (SomeNumber)
and :: (Number a, Number b) => a -> b -> IO (SomeNumber)
xor :: (Number a, Number b) => a -> b -> IO (SomeNumber)
or :: (Number a, Number b) => a -> b -> IO (SomeNumber)
inPlaceAdd :: (Number a, Number b) => a -> b -> IO (SomeNumber)
inPlaceSubtract :: (Number a, Number b) => a -> b -> IO (SomeNumber)
inPlaceMultiply :: (Number a, Number b) => a -> b -> IO (SomeNumber)
inPlaceFloorDivide :: (Number a, Number b) => a -> b -> IO (SomeNumber)
inPlaceTrueDivide :: (Number a, Number b) => a -> b -> IO (SomeNumber)
inPlaceRemainder :: (Number a, Number b) => a -> b -> IO (SomeNumber)
inPlacePower :: (Number a, Number b, Number c) => a -> b -> Maybe c -> IO SomeNumber
inPlaceShiftL :: (Number a, Number b) => a -> b -> IO (SomeNumber)
inPlaceShiftR :: (Number a, Number b) => a -> b -> IO (SomeNumber)
inPlaceAnd :: (Number a, Number b) => a -> b -> IO (SomeNumber)
inPlaceXor :: (Number a, Number b) => a -> b -> IO (SomeNumber)
inPlaceOr :: (Number a, Number b) => a -> b -> IO (SomeNumber)
toInteger :: Number a => a -> IO (Integer)
toFloat :: Number a => a -> IO (Float)
toBase :: Number a => a -> Integer -> IO (Unicode)
instance Number FrozenSet
instance Number Set
instance Number Complex
instance Number Float
instance Number Integer
instance Number SomeNumber
instance Object SomeNumber

module CPython.Protocols.Sequence
class Object a => Sequence a
toSequence :: Sequence a => a -> SomeSequence
data SomeSequence

-- | Attempt to convert an object to a generic <a>Sequence</a>. If the
--   object does not implement the sequence protocol, returns
--   <a>Nothing</a>.
castToSequence :: Object a => a -> IO (Maybe SomeSequence)
length :: Sequence self => self -> IO (Integer)
append :: (Sequence a, Sequence b) => a -> b -> IO (SomeSequence)
repeat :: Sequence a => a -> Integer -> IO (a)
inPlaceAppend :: (Sequence a, Sequence b) => a -> b -> IO (SomeSequence)
inPlaceRepeat :: Sequence a => a -> Integer -> IO (a)
getItem :: Sequence self => self -> Integer -> IO (SomeObject)
setItem :: (Sequence self, Object v) => self -> Integer -> v -> IO (())
deleteItem :: Sequence self => self -> Integer -> IO (())
getSlice :: Sequence self => self -> Integer -> Integer -> IO (SomeObject)
setSlice :: (Sequence self, Object v) => self -> Integer -> Integer -> v -> IO (())
deleteSlice :: Sequence self => self -> Integer -> Integer -> IO (())
count :: (Sequence self, Object v) => self -> v -> IO (Integer)
contains :: (Sequence self, Object v) => self -> v -> IO (Bool)

-- | Return the first index <i>i</i> for which <tt>self[i] == v</tt>. This
--   is equivalent to the Python expression <tt>self.index(v)</tt>.
index :: (Sequence self, Object v) => self -> v -> IO (Integer)

-- | Return a list object with the same contents as the arbitrary sequence
--   <i>seq</i>. The returned list is guaranteed to be new.
toList :: Sequence seq => seq -> IO (List)

-- | Return a tuple object with the same contents as the arbitrary sequence
--   <i>seq</i>. If <i>seq</i> is already a tuple, it is re-used rather
--   than copied.
toTuple :: Sequence seq => seq -> IO (Tuple)

-- | Returns the sequence <i>seq</i> as a tuple, unless it is already a
--   tuple or list, in which case <i>seq</i> is returned. If an error
--   occurs, throws <tt>TypeError</tt> with the given text as the exception
--   text.
fast :: Sequence seq => seq -> Text -> IO (SomeSequence)
instance Sequence Unicode
instance Sequence Tuple
instance Sequence List
instance Sequence Bytes
instance Sequence ByteArray

module CPython.Reflection

-- | Return a <a>Dictionary</a> of the builtins in the current execution
--   frame, or the interpreter of the thread state if no frame is currently
--   executing.
getBuiltins :: IO (Dictionary)

-- | Return a <a>Dictionary</a> of the local variables in the current
--   execution frame, or <a>Nothing</a> if no frame is currently executing.
getLocals :: IO (Maybe Dictionary)

-- | Return a <a>Dictionary</a> of the global variables in the current
--   execution frame, or <a>Nothing</a> if no frame is currently executing.
getGlobals :: IO (Maybe Dictionary)

-- | Return the current thread state's frame, which is <a>Nothing</a> if no
--   frame is currently executing.
getFrame :: IO (Maybe SomeObject)

-- | Return the name of <i>func</i> if it is a function, class or instance
--   object, else the name of <i>func</i>'s type.
getFunctionName :: Object func => func -> IO (Text)

-- | Return a description string, depending on the type of func. Return
--   values include <tt>"()"</tt> for functions and methods,
--   <tt>"constructor"</tt>, <tt>"instance"</tt>, and <tt>"object"</tt>.
--   Concatenated with the result of <a>getFunctionName</a>, the result
--   will be a description of <i>func</i>.
getFunctionDescription :: Object func => func -> IO (Text)

module CPython.System

-- | Return the object <i>name</i> from the <tt>sys</tt> module, or
--   <a>Nothing</a> if it does not exist.
getObject :: Text -> IO (Maybe SomeObject)

-- | Set <i>name</i> in the <tt>sys</tt> module to a value.
setObject :: Object a => Text -> a -> IO ()

-- | Delete <i>name</i> from the <tt>sys</tt> module.
deleteObject :: Text -> IO ()

-- | Reset <tt>sys.warnoptions</tt> to an empty list.
resetWarnOptions :: IO (())

-- | Add an entry to <tt>sys.warnoptions</tt>.
addWarnOption :: Text -> IO ()

-- | Set <tt>sys.path</tt> to a list object of paths found in the
--   parameter, which should be a list of paths separated with the
--   platform's search path delimiter (<tt>':'</tt> on Unix, <tt>';'</tt>
--   on Windows).
setPath :: Text -> IO ()

module CPython

-- | Initialize the Python interpreter. In an application embedding Python,
--   this should be called before using any other Python/C API
--   computations; with the exception of <a>setProgramName</a>,
--   <tt>initThreads</tt>, <tt>releaseLock</tt>, and <tt>acquireLock</tt>.
--   This initializes the table of loaded modules (<tt>sys.modules</tt>),
--   and creates the fundamental modules <tt>builtins</tt>,
--   <tt>__main__</tt> and <tt>sys</tt>. It also initializes the module
--   search path (<tt>sys.path</tt>). It does not set <tt>sys.argv</tt>;
--   use <a>setArgv</a> for that. This is a no-op when called for a second
--   time (without calling <a>finalize</a> first). There is no return
--   value; it is a fatal error if the initialization fails.
initialize :: IO (())

-- | Return <a>True</a> when the Python interpreter has been initialized,
--   <a>False</a> if not. After <a>finalize</a> is called, this returns
--   <a>False</a> until <a>initialize</a> is called again.
isInitialized :: IO (Bool)

-- | Undo all initializations made by <a>initialize</a> and subsequent use
--   of Python/C API computations, and destroy all sub-interpreters (see
--   <a>newInterpreter</a> below) that were created and not yet destroyed
--   since the last call to <a>initialize</a>. Ideally, this frees all
--   memory allocated by the Python interpreter. This is a no-op when
--   called for a second time (without calling <a>initialize</a> again
--   first). There is no return value; errors during finalization are
--   ignored.
--   
--   This computation is provided for a number of reasons. An embedding
--   application might want to restart Python without having to restart the
--   application itself. An application that has loaded the Python
--   interpreter from a dynamically loadable library (or DLL) might want to
--   free all memory allocated by Python before unloading the DLL. During a
--   hunt for memory leaks in an application a developer might want to free
--   all memory allocated by Python before exiting from the application.
--   
--   <i>Bugs and caveats</i>: The destruction of modules and objects in
--   modules is done in arbitrary order; this may cause destructors
--   (<tt>__del__()</tt> methods) to fail when they depend on other objects
--   (even functions) or modules. Dynamically loaded extension modules
--   loaded by Python are not unloaded. Small amounts of memory allocated
--   by the Python interpreter may not be freed (if you find a leak, please
--   report it). Memory tied up in circular references between objects is
--   not freed. Some memory allocated by extension modules may not be
--   freed. Some extensions may not work properly if their initialization
--   routine is called more than once; this can happen if an application
--   calls <a>initialize</a> and <a>finalize</a> more than once.
finalize :: IO (())

-- | Create a new sub-interpreter. This is an (almost) totally separate
--   environment for the execution of Python code. In particular, the new
--   interpreter has separate, independent versions of all imported
--   modules, including the fundamental modules <tt>builtins</tt>,
--   <tt>__main__</tt> and <tt>sys</tt>. The table of loaded modules
--   (<tt>sys.modules</tt>) and the module search path (<tt>sys.path</tt>)
--   are also separate. The new environment has no <tt>sys.argv</tt>
--   variable. It has new standard I/O stream file objects
--   <tt>sys.stdin</tt>, <tt>sys.stdout</tt> and <tt>sys.stderr</tt>
--   (however these refer to the same underlying <tt>FILE</tt> structures
--   in the C library).
--   
--   The return value points to the first thread state created in the new
--   sub-interpreter. This thread state is made in the current thread
--   state. Note that no actual thread is created; see the discussion of
--   thread states below. If creation of the new interpreter is
--   unsuccessful, <a>Nothing</a> is returned; no exception is set since
--   the exception state is stored in the current thread state and there
--   may not be a current thread state. (Like all other Python/C API
--   computations, the global interpreter lock must be held before calling
--   this computation and is still held when it returns; however, unlike
--   most other Python/C API computations, there needn’t be a current
--   thread state on entry.)
--   
--   Extension modules are shared between (sub-)interpreters as follows:
--   the first time a particular extension is imported, it is initialized
--   normally, and a (shallow) copy of its module’s dictionary is
--   squirreled away. When the same extension is imported by another
--   (sub-)interpreter, a new module is initialized and filled with the
--   contents of this copy; the extension’s <tt>init</tt> procedure is not
--   called. Note that this is different from what happens when an
--   extension is imported after the interpreter has been completely
--   re-initialized by calling <a>finalize</a> and <a>initialize</a>; in
--   that case, the extension’s <tt>init<i>module</i></tt> procedure is
--   called again.
--   
--   <i>Bugs and caveats</i>: Because sub-interpreters (and the main
--   interpreter) are part of the same process, the insulation between them
--   isn’t perfect — for example, using low-level file operations like
--   <tt>os.close()</tt> they can (accidentally or maliciously) affect each
--   other’s open files. Because of the way extensions are shared between
--   (sub-)interpreters, some extensions may not work properly; this is
--   especially likely when the extension makes use of (static) global
--   variables, or when the extension manipulates its module’s dictionary
--   after its initialization. It is possible to insert objects created in
--   one sub-interpreter into a namespace of another sub-interpreter; this
--   should be done with great care to avoid sharing user-defined
--   functions, methods, instances or classes between sub-interpreters,
--   since import operations executed by such objects may affect the wrong
--   (sub-)interpreter’s dictionary of loaded modules. (XXX This is a
--   hard-to-fix bug that will be addressed in a future release.)
--   
--   Also note that the use of this functionality is incompatible with
--   extension modules such as PyObjC and ctypes that use the
--   <tt>PyGILState_*()</tt> APIs (and this is inherent in the way the
--   <tt>PyGILState_*()</tt> procedures work). Simple things may work, but
--   confusing behavior will always be near.
newInterpreter :: IO (Maybe ThreadState)

-- | Destroy the (sub-)interpreter represented by the given thread state.
--   The given thread state must be the current thread state. See the
--   discussion of thread states below. When the call returns, the current
--   thread state is <tt>NULL</tt>. All thread states associated with this
--   interpreter are destroyed. (The global interpreter lock must be held
--   before calling this computation and is still held when it returns.)
--   <a>finalize</a> will destroy all sub-interpreters that haven’t been
--   explicitly destroyed at that point.
endInterpreter :: ThreadState -> IO ()

-- | Return the program name set with <a>setProgramName</a>, or the
--   default.
getProgramName :: IO Text

-- | This computation should be called before <a>initialize</a> is called
--   for the first time, if it is called at all. It tells the interpreter
--   the value of the <tt>argv[0]</tt> argument to the <tt>main</tt>
--   procedure of the program. This is used by <a>getPath</a> and some
--   other computations below to find the Python run-time libraries
--   relative to the interpreter executable. The default value is
--   <tt>"python"</tt>. No code in the Python interpreter will change the
--   program name.
setProgramName :: Text -> IO ()

-- | Return the prefix for installed platform-independent files. This is
--   derived through a number of complicated rules from the program name
--   set with <a>setProgramName</a> and some environment variables; for
--   example, if the program name is <tt>"/usr/local/bin/python"</tt>, the
--   prefix is <tt>"/usr/local"</tt>. This corresponds to the
--   <tt>prefix</tt> variable in the top-level Makefile and the
--   <i>--prefix</i> argument to the <tt>configure</tt> script at build
--   time. The value is available to Python code as <tt>sys.prefix</tt>. It
--   is only useful on UNIX. See also <a>getExecPrefix</a>.
getPrefix :: IO Text

-- | Return the <i>exec-prefix</i> for installed platform-<i>dependent</i>
--   files. This is derived through a number of complicated rules from the
--   program name set with setProgramName' and some environment variables;
--   for example, if the program name is <tt>"/usr/local/bin/python"</tt>,
--   the exec-prefix is <tt>"/usr/local"</tt>. This corresponds to the
--   <tt>exec_prefix</tt> variable in the top-level Makefile and the
--   <i>--exec-prefix</i> argument to the <tt>configure</tt> script at
--   build time. The value is available to Python code as
--   <tt>sys.exec_prefix</tt>. It is only useful on UNIX.
--   
--   Background: The exec-prefix differs from the prefix when platform
--   dependent files (such as executables and shared libraries) are
--   installed in a different directory tree. In a typical installation,
--   platform dependent files may be installed in the
--   <tt>/usr/local/plat</tt> subtree while platform independent may be
--   installed in <tt>/usr/local</tt>.
--   
--   Generally speaking, a platform is a combination of hardware and
--   software families, e.g. Sparc machines running the Solaris 2.x
--   operating system are considered the same platform, but Intel machines
--   running Solaris 2.x are another platform, and Intel machines running
--   Linux are yet another platform. Different major revisions of the same
--   operating system generally also form different platforms. Non-UNIX
--   operating systems are a different story; the installation strategies
--   on those systems are so different that the prefix and exec-prefix are
--   meaningless, and set to the empty string. Note that compiled Python
--   bytecode files are platform independent (but not independent from the
--   Python version by which they were compiled!).
--   
--   System administrators will know how to configure the <tt>mount</tt> or
--   <tt>automount</tt> programs to share <tt>/usr/local</tt> between
--   platforms while having <tt>/usr/local/plat</tt> be a different
--   filesystem for each platform.
getExecPrefix :: IO Text

-- | Return the full program name of the Python executable; this is
--   computed as a side-effect of deriving the default module search path
--   from the program name (set by <a>setProgramName</a> above). The value
--   is available to Python code as <tt>sys.executable</tt>.
getProgramFullPath :: IO Text

-- | Return the default module search path; this is computed from the
--   program name (set by <a>setProgramName</a> above) and some environment
--   variables. The returned string consists of a series of directory names
--   separated by a platform dependent delimiter character. The delimiter
--   character is <tt>':'</tt> on Unix and Mac OS X, <tt>';'</tt> on
--   Windows. The value is available to Python code as the list
--   <tt>sys.path</tt>, which may be modified to change the future search
--   path for loaded modules.
getPath :: IO Text

-- | Return the version of this Python interpreter. This is a string that
--   looks something like
--   
--   <pre>
--   "3.0a5+ (py3k:63103M, May 12 2008, 00:53:55) \n[GCC 4.2.3]"
--   </pre>
--   
--   The first word (up to the first space character) is the current Python
--   version; the first three characters are the major and minor version
--   separated by a period. The value is available to Python code as
--   <tt>sys.version</tt>.
getVersion :: IO (Text)

-- | Return the platform identifier for the current platform. On Unix, this
--   is formed from the “official” name of the operating system, converted
--   to lower case, followed by the major revision number; e.g., for
--   Solaris 2.x, which is also known as SunOS 5.x, the value is
--   <tt>"sunos5"</tt>. On Mac OS X, it is <tt>"darwin"</tt>. On Windows,
--   it is <tt>"win"</tt>. The value is available to Python code as
--   <tt>sys.platform</tt>.
getPlatform :: IO (Text)

-- | Return the official copyright string for the current Python version,
--   for example
--   
--   <pre>
--   "Copyright 1991-1995 Stichting Mathematisch Centrum, Amsterdam"
--   </pre>
--   
--   The value is available to Python code as <tt>sys.copyright</tt>.
getCopyright :: IO (Text)

-- | Return an indication of the compiler used to build the current Python
--   version, in square brackets, for example:
--   
--   <pre>
--   "[GCC 2.7.2.2]"
--   </pre>
--   
--   The value is available to Python code as part of the variable
--   <tt>sys.version</tt>.
getCompiler :: IO (Text)

-- | Return information about the sequence number and build date and time
--   of the current Python interpreter instance, for example
--   
--   <pre>
--   "#67, Aug  1 1997, 22:34:28"
--   </pre>
--   
--   The value is available to Python code as part of the variable
--   <tt>sys.version</tt>.
getBuildInfo :: IO (Text)

-- | Set <tt>sys.argv</tt>. The first parameter is similar to the result of
--   <tt>getProgName</tt>, with the difference that it should refer to the
--   script file to be executed rather than the executable hosting the
--   Python interpreter. If there isn’t a script that will be run, the
--   first parameter can be an empty string. If this function fails to
--   initialize <tt>sys.argv</tt>, a fatal condition is signalled using
--   <tt>Py_FatalError()</tt>.
--   
--   This function also prepends the executed script’s path to
--   <tt>sys.path</tt>. If no script is executed (in the case of calling
--   <tt>python -c</tt> or just the interactive interpreter), the empty
--   string is used instead.
setArgv :: Text -> [Text] -> IO ()

-- | Return the default “home”, that is, the value set by a previous call
--   to <a>setPythonHome</a>, or the value of the <tt>PYTHONHOME</tt>
--   environment variable if it is set.
getPythonHome :: IO (Maybe Text)

-- | Set the default “home” directory, that is, the location of the
--   standard Python libraries. The libraries are searched in
--   <tt><i>home</i>/lib/<i>python version</i></tt> and
--   <tt><i>home</i>/lib/<i>python version</i></tt>. No code in the Python
--   interpreter will change the Python home.
setPythonHome :: Maybe Text -> IO ()
