-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Categorical Monoids and Semirings
--   
--   This my attempt at synthesizing a few ideas about invertible
--   programming with Arrow like type classes. Here is a link to pdf
--   produced from the source
--   <a>https://takeittothelimit.files.wordpress.com/2012/03/semiring.pdf</a>
--   And here is a blog post that says basically the same thing.
--   <a>http://takeittothelimit.wordpress.com/2012/03/26/categorical-semirings-2/</a>
@package categorical-algebra
@version 0.0.0.1


-- | Categorical semirings (my term, but maybe the correct one) are an
--   alternative to Arrows, but play nicely with groupoids. | See the
--   source or the latex source for more background.
module Data.Semiring

-- | An endofunctor for combining two morphisms|
class Category k => Ctor k constr | constr -> k
selfmap :: Ctor k constr => k a b -> k c d -> k (constr a c) (constr b d)

-- | construct a new morphism with identity|
promote :: Ctor k op => k a b -> k (op a c) (op b c)

-- | construct a new morphism with identity with the arguments reversed|
swap_promote :: Ctor k op => k a b -> k (op c a) (op c b)

-- | The absorbtion law =&gt; x+0 &lt;-&gt; x |
class Ctor k op => Absorbs k op id | op -> k, op -> id
absorb :: Absorbs k op id => k (op id a) a
unabsorb :: Absorbs k op id => k a (op id a)

-- | The assocative law =&gt; (x + y) + z &lt;-&gt; x + (y + z)|
class Ctor k op => Assocative k op | op -> k
assoc :: Assocative k op => k (op (op a b) c) (op a (op b c))
unassoc :: Assocative k op => k (op a (op b c)) (op (op a b) c)

-- | The commutative law =&gt; x + y &lt;-&gt; y + x|
class Ctor k op => Commutative k op | op -> k
commute :: Commutative k op => k (op a b) (op b a)

-- | The annihilation law =&gt; 0 * x &lt;-&gt; 0|
class Ctor k op => Annihilates k op zero | op zero -> k
annihilates :: Annihilates k op zero => k (op zero a) zero

-- | The distribution law =&gt; (a + b) * c &lt;-&gt; (a * c) + (b * c)|
class (Ctor k add, Ctor k multi) => Distributes k add multi | add multi -> k
distribute :: Distributes k add multi => k (multi (add a b) c) (add (multi a c) (multi b c))
undistribute :: Distributes k add multi => k (add (multi a c) (multi b c)) (multi (add a b) c)

-- | Monoidial Category class|
class (Assocative k dot, Absorbs k dot id) => Monoidial k dot id | dot id -> k

-- | Commutative Monoidial Category class|
class (Monoidial k dot id, Commutative k dot) => CommutativeMonoidial k dot id | dot id -> k

-- | Semiring Category class|
class (CommutativeMonoidial k add zero, CommutativeMonoidial k multi one, Annihilates k multi zero, Distributes k add multi) => Semiring k add zero multi one | add zero multi one -> k

-- | Apply the multi monoid operator to the morphism and identity|
first :: Semiring a add zero multi one => a b c -> a (multi b d) (multi c d)

-- | Apply the multi monoid operator to identity and the morphism|
second :: Semiring a add zero multi one => a b c -> a (multi d b) (multi d c)

-- | Apply the add monoid operator to the morphism and identity|
left :: Semiring a add zero multi one => a b c -> a (add b d) (add c d)

-- | Apply the add monoid operator to identity and the morphism|
right :: Semiring a add zero multi one => a b c -> a (add d b) (add d c)
class Category g => Groupoid g
inv :: Groupoid g => g a b -> g b a
data Iso k a b
Iso :: k a b -> k b a -> Iso k a b
embed :: Iso k a b -> k a b
project :: Iso k a b -> k b a
biject_sum_absorb :: Biject (BSum BZero a) a
biject_sum_assoc :: Biject (BSum (BSum a b) c) (BSum a (BSum b c))
biject_product_absorb :: Biject (BProduct BOne a) a
biject_product_assoc :: Biject (BProduct (BProduct a b) c) (BProduct a (BProduct b c))
biject_distributes :: Biject (BProduct (BSum a b) c) (BSum (BProduct a c) (BProduct b c))
kbiject_sum_absorb :: Monad m => (KBiject m) (KBSum KBZero a) a
kbiject_sum_assoc :: Monad m => (KBiject m) (KBSum (KBSum a b) c) (KBSum a (KBSum b c))
kbiject_product_absorb :: Monad m => (KBiject m) (KBProduct KBOne a) a
kbiject_product_assoc :: Monad m => (KBiject m) (KBProduct (KBProduct a b) c) (KBProduct a (KBProduct b c))
kbiject_distributes :: Monad m => (KBiject m) (KBProduct (KBSum a b) c) (KBSum (KBProduct a c) (KBProduct b c))
instance Monad m => Semiring (KBiject m) KBSum KBZero KBProduct KBOne
instance Monad m => Distributes (KBiject m) KBSum KBProduct
instance Monad m => Annihilates (KBiject m) KBProduct KBZero
instance Monad m => CommutativeMonoidial (KBiject m) KBProduct KBOne
instance Monad m => Commutative (KBiject m) KBProduct
instance Monad m => Monoidial (KBiject m) KBProduct KBOne
instance Monad m => Assocative (KBiject m) KBProduct
instance Monad m => Absorbs (KBiject m) KBProduct KBOne
instance Monad m => Ctor (KBiject m) KBProduct
instance Monad m => CommutativeMonoidial (KBiject m) KBSum KBZero
instance Monad m => Commutative (KBiject m) KBSum
instance Monad m => Monoidial (KBiject m) KBSum KBZero
instance Monad m => Assocative (KBiject m) KBSum
instance Monad m => Absorbs (KBiject m) KBSum KBZero
instance Monad m => Ctor (KBiject m) KBSum
instance Semiring Biject BSum BZero BProduct BOne
instance Distributes Biject BSum BProduct
instance Annihilates Biject BProduct BZero
instance CommutativeMonoidial Biject BProduct BOne
instance Commutative Biject BProduct
instance Monoidial Biject BProduct BOne
instance Assocative Biject BProduct
instance Absorbs Biject BProduct BOne
instance Ctor Biject BProduct
instance CommutativeMonoidial Biject BSum BZero
instance Commutative Biject BSum
instance Monoidial Biject BSum BZero
instance Assocative Biject BSum
instance Absorbs Biject BSum BZero
instance Ctor Biject BSum
instance Category k => Groupoid (Iso k)
instance Newtype (Iso k a b) (k a b, k b a)
instance Category k => Category (Iso k)
instance Monad m => Semiring (Kleisli m) KSum KZero KProduct KOne
instance Monad m => Distributes (Kleisli m) KSum KProduct
instance Monad m => Annihilates (Kleisli m) KProduct KZero
instance Monad m => CommutativeMonoidial (Kleisli m) KProduct KOne
instance Monad m => Commutative (Kleisli m) KProduct
instance Monad m => Monoidial (Kleisli m) KProduct KOne
instance Monad m => Assocative (Kleisli m) KProduct
instance Monad m => Absorbs (Kleisli m) KProduct KOne
instance Monad m => Ctor (Kleisli m) KProduct
instance Monad m => CommutativeMonoidial (Kleisli m) KSum KZero
instance Monad m => Commutative (Kleisli m) KSum
instance Monad m => Monoidial (Kleisli m) KSum KZero
instance Monad m => Assocative (Kleisli m) KSum
instance Monad m => Absorbs (Kleisli m) KSum KZero
instance Monad m => Ctor (Kleisli m) KSum
instance Semiring (->) Sum Zero Product One
instance Distributes (->) Sum Product
instance Annihilates (->) Product Zero
instance CommutativeMonoidial (->) Product One
instance Commutative (->) Product
instance Monoidial (->) Product One
instance Assocative (->) Product
instance Absorbs (->) Product One
instance Ctor (->) Product
instance CommutativeMonoidial (->) Sum Zero
instance Commutative (->) Sum
instance Monoidial (->) Sum Zero
instance Assocative (->) Sum
instance Absorbs (->) Sum Zero
instance Ctor (->) Sum
