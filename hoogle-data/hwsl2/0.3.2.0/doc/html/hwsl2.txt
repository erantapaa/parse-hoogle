-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Hashing with SL2
--   
@package hwsl2
@version 0.3.2.0

module Data.Hash.SL2.Unsafe
unsafeUseAsPtr :: Hash -> (Ptr Hash -> IO a) -> IO a
unsafeUseAsPtr2 :: Hash -> Hash -> (Ptr Hash -> Ptr Hash -> IO a) -> IO a
unsafeWithNew :: (Ptr Hash -> IO a) -> IO (Hash, a)
unsafePack :: Storable a => [a] -> Hash
unsafeUnpack :: Storable a => Hash -> [a]
instance Storable Hash

module Data.Hash.SL2.Mutable

-- | <i>O(1)</i> Check a hash for bit-level validity.
valid :: Ptr Hash -> IO Bool

-- | <i>O(1)</i> Compare the two hashes for equality.
eq :: Ptr Hash -> Ptr Hash -> IO Bool

-- | <i>O(1)</i> Compare two hashes.
cmp :: Ptr Hash -> Ptr Hash -> IO Ordering

-- | <i>O(1)</i> Set the <a>Hash</a> to the empty value.
unit :: Ptr Hash -> IO ()

-- | <i>O(1)</i> Concatenate the second and third <a>Hash</a>, store the
--   result in the first.
concat :: Ptr Hash -> Ptr Hash -> Ptr Hash -> IO ()

-- | <i>O(n)</i> Append the hash of the <a>ByteString</a> to the existing
--   <a>Hash</a>.
append :: ByteString -> Ptr Hash -> IO ()

-- | <i>O(n)</i> Prepend the hash of the <a>ByteString</a> to the existing
--   <a>Hash</a>.
prepend :: ByteString -> Ptr Hash -> IO ()

-- | <i>O(n)</i> Append the hash of every <a>ByteString</a> to the existing
--   <a>Hash</a>, from left to right.
foldAppend :: Foldable t => t ByteString -> Ptr Hash -> IO ()

-- | <i>O(n)</i> Prepend the hash of every <a>ByteString</a> to the
--   existing <a>Hash</a>, from right to left.
foldPrepend :: Foldable t => t ByteString -> Ptr Hash -> IO ()

-- | <i>O(1)</i> Serialize the hash into a url-safe base64 representation.
serialize :: Ptr Hash -> IO String

-- | <i>O(1)</i> Unserialize the hash from the representation generated by
--   <a>serialize</a>.
unserialize :: String -> Ptr Hash -> IO (Maybe ())
withUnit :: (Ptr Hash -> IO a) -> IO (Hash, a)
withCopy :: Hash -> (Ptr Hash -> IO a) -> IO (Hash, a)


-- | An algebraic hash function, inspired by the paper <i>Hashing with
--   SL2</i> by Tillich and Zemor.
--   
--   The hash function is based on matrix multiplication in the special
--   linear group of degree 2, over a Galois field of order 2^127, with all
--   computations modulo the polynomial x^127 + x^63 + 1.
--   
--   This construction gives some nice properties, which traditional
--   bit-scambling hash functions don't possess, including it being
--   composable. It holds:
--   
--   <pre>
--   hash (m1 &lt;&gt; m2) == hash m1 &lt;&gt; hash m2
--   </pre>
--   
--   Following that, the hash function is also parallelisable. If a message
--   <tt>m</tt> can be divided into a list of chunks <tt>cs</tt>, the hash
--   of the message can be calculated in parallel:
--   
--   <pre>
--   mconcat (parMap rpar hash cs) == hash m
--   </pre>
--   
--   All operations in this package are implemented in a very efficient
--   manner using SSE instructions.
module Data.Hash.SL2
data Hash

-- | <i>O(n)</i> Calculate the hash of the <a>ByteString</a>. Alias for
--   <tt>(<a>append</a> <a>unit</a>)</tt>.
hash :: ByteString -> Hash

-- | <i>O(n)</i> Append the hash of the <a>ByteString</a> to the existing
--   <a>Hash</a>. A significantly faster equivalent of <tt>((. <a>hash</a>)
--   . <a>concat</a>)</tt>.
append :: Hash -> ByteString -> Hash

-- | <i>O(n)</i> Prepend the hash of the <a>ByteString</a> to the existing
--   <a>Hash</a>. A significantly faster equivalent of <tt>(<a>concat</a> .
--   <a>hash</a>)</tt>.
prepend :: ByteString -> Hash -> Hash

-- | <i>O(n)</i> Append the hash of every <a>ByteString</a> to the existing
--   <a>Hash</a>, from left to right. A significantly faster equivalent of
--   <tt>(<a>foldl</a> <a>append</a>)</tt>.
foldAppend :: Foldable t => Hash -> t ByteString -> Hash

-- | <i>O(n)</i> Prepend the hash of every <a>ByteString</a> to the
--   existing <a>Hash</a>, from right to left. A significantly faster
--   equivalent of <tt>(<a>flip</a> (<a>foldr</a> <a>prepend</a>))</tt>.
foldPrepend :: Foldable t => t ByteString -> Hash -> Hash

-- | <i>O(1)</i> The unit element for concatenation. Alias for
--   <a>mempty</a>.
unit :: Hash

-- | <i>O(1)</i> Concatenate two hashes. Alias for <a>mappend</a>.
concat :: Hash -> Hash -> Hash

-- | <i>O(n)</i> Concatenate a list of hashes. Alias for <a>mconcat</a>.
concatAll :: [Hash] -> Hash

-- | <i>O(1)</i> Parse the representation generated by <a>show</a>.
parse :: String -> Maybe Hash

-- | <i>O(1)</i> Check a hash for bit-level validity.
valid :: Hash -> Bool

-- | <i>O(1)</i> Validate a hash on the bit-level. From <tt><a>valid</a> h
--   == <a>True</a></tt> follows <tt><a>validate</a> h == <a>Just</a>
--   h</tt>.
validate :: Hash -> Maybe Hash

-- | <i>O(1)</i> Pack a list of 64 8-bit words.
pack8 :: [Word8] -> Maybe Hash

-- | <i>O(1)</i> Pack a list of 32 16-bit words.
pack16 :: [Word16] -> Maybe Hash

-- | <i>O(1)</i> Pack a list of 16 32-bit words.
pack32 :: [Word32] -> Maybe Hash

-- | <i>O(1)</i> Pack a list of 8 64-bit words.
pack64 :: [Word64] -> Maybe Hash

-- | <i>O(1)</i> Unpack into list of 64 8-bit words.
unpack8 :: Hash -> [Word8]

-- | <i>O(1)</i> Unpack into list of 32 16-bit words.
unpack16 :: Hash -> [Word16]

-- | <i>O(1)</i> Unpack into list of 16 32-bit words.
unpack32 :: Hash -> [Word32]

-- | <i>O(1)</i> Unpack into list of 8 64-bit words.
unpack64 :: Hash -> [Word64]
instance Monoid Hash
instance Ord Hash
instance Eq Hash
instance Show Hash

module Data.Hash.SL2.Chunk
data Chunk
Chunk :: Hash -> ByteString -> Chunk
getChunkHash :: Chunk -> Hash
getChunkBytes :: Chunk -> ByteString
fromByteString :: ByteString -> Chunk
instance Monoid Chunk
instance Ord Chunk
instance Eq Chunk
