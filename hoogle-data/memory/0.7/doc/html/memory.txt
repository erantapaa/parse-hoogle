-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | memory and related abtraction stuff
--   
@package memory
@version 0.7


-- | Extra Word size
module Data.Memory.ExtendedWords

-- | A simple Extended Word128 composed of 2 Word64
data Word128
Word128 :: !Word64 -> !Word64 -> Word128
instance Show Word128
instance Eq Word128


-- | methods to manipulate raw memory representation
module Data.Memory.PtrMethods

-- | Create a new temporary buffer
memCreateTemporary :: Int -> (Ptr Word8 -> IO a) -> IO a

-- | xor bytes from source1 and source2 to destination
--   
--   d = s1 xor s2
--   
--   s1, nor s2 are modified unless d point to s1 or s2
memXor :: Ptr Word8 -> Ptr Word8 -> Ptr Word8 -> Int -> IO ()

-- | xor bytes from source with a specific value to destination
--   
--   d = replicate (sizeof s) v <a>xor</a> s
memXorWith :: Ptr Word8 -> Word8 -> Ptr Word8 -> Int -> IO ()

-- | Copy a set number of bytes from <tt>src to </tt>dst
memCopy :: Ptr Word8 -> Ptr Word8 -> Int -> IO ()

-- | Set <tt>n number of bytes to the same value </tt>v
memSet :: Ptr Word8 -> Word8 -> Int -> IO ()

-- | Check if two piece of memory are equals
memEqual :: Ptr Word8 -> Ptr Word8 -> Int -> IO Bool

-- | A constant time equality test for 2 Memory buffers
--   
--   compared to normal equality function, this function will go over all
--   the bytes present before yielding a result even when knowing the
--   overall result early in the processing.
memConstEqual :: Ptr Word8 -> Ptr Word8 -> Int -> IO Bool

-- | Compare two piece of memory and returns how they compare
memCompare :: Ptr Word8 -> Ptr Word8 -> Int -> IO Ordering


-- | Hexadecimal escaper
module Data.Memory.Encoding.Base16

-- | Transform a raw memory to an hexadecimal <a>String</a>
--   
--   user beware, no checks are made
showHexadecimal :: (forall a. (Ptr Word8 -> IO a) -> IO a) -> Int -> String

-- | Transform a number of bytes pointed by.<tt>src in the hexadecimal
--   binary representation in </tt>dst
--   
--   destination memory need to be of correct size, otherwise it will lead
--   to really bad things.
toHexadecimal :: Ptr Word8 -> Ptr Word8 -> Int -> IO ()

-- | convert a base16 <tt>src in </tt>dst.
--   
--   n need to even
fromHexadecimal :: Ptr Word8 -> Ptr Word8 -> Int -> IO (Maybe Int)


-- | Base32
module Data.Memory.Encoding.Base32

-- | Transform a number of bytes pointed by.<tt>src in the base32 binary
--   representation in </tt>dst
--   
--   destination memory need to be of correct size, otherwise it will lead
--   to really bad things.
toBase32 :: Ptr Word8 -> Ptr Word8 -> Int -> IO ()

-- | Get the length needed for the destination buffer for a base32
--   decoding.
--   
--   if the length is not a multiple of 8, Nothing is returned
unBase32Length :: Ptr Word8 -> Int -> IO (Maybe Int)

-- | convert from base32 in <tt>src to binary in </tt>dst, using the number
--   of bytes specified
--   
--   the user should use unBase32Length to compute the correct length, or
--   check that the length specification is proper. no check is done here.
fromBase32 :: Ptr Word8 -> Ptr Word8 -> Int -> IO (Maybe Int)


-- | Base64
module Data.Memory.Encoding.Base64

-- | Transform a number of bytes pointed by.<tt>src in the base64 binary
--   representation in </tt>dst
--   
--   destination memory need to be of correct size, otherwise it will lead
--   to really bad things.
toBase64 :: Ptr Word8 -> Ptr Word8 -> Int -> IO ()

-- | Get the length needed for the destination buffer for a base64
--   decoding.
--   
--   if the length is not a multiple of 4, Nothing is returned
unBase64Length :: Ptr Word8 -> Int -> IO (Maybe Int)

-- | convert from base64 in <tt>src to binary in </tt>dst, using the number
--   of bytes specified
--   
--   the user should use unBase64Length to compute the correct length, or
--   check that the length specification is proper. no check is done here.
fromBase64 :: Ptr Word8 -> Ptr Word8 -> Int -> IO (Maybe Int)


module Data.Memory.Endian

-- | represent the CPU endianness
--   
--   Big endian system stores bytes with the MSB as the first byte. Little
--   endian system stores bytes with the LSB as the first byte.
--   
--   middle endian is purposely avoided.
data Endianness
LittleEndian :: Endianness
BigEndian :: Endianness

-- | Return the system endianness
getSystemEndianness :: Endianness

-- | Big Endian value
newtype BE a
BE :: a -> BE a
unBE :: BE a -> a

-- | Little Endian value
newtype LE a
LE :: a -> LE a
unLE :: LE a -> a

-- | Convert from a big endian value to the cpu endianness
fromBE :: ByteSwap a => BE a -> a

-- | Convert a value in cpu endianess to big endian
toBE :: ByteSwap a => a -> BE a

-- | Convert from a little endian value to the cpu endianness
fromLE :: ByteSwap a => LE a -> a

-- | Convert a value in cpu endianess to little endian
toLE :: ByteSwap a => a -> LE a

-- | Class of types that can be byte-swapped.
--   
--   e.g. Word16, Word32, Word64
class Storable a => ByteSwap a
instance Show Endianness
instance Eq Endianness
instance Show a => Show (LE a)
instance Eq a => Eq (LE a)
instance Storable a => Storable (LE a)
instance Show a => Show (BE a)
instance Eq a => Eq (BE a)
instance Storable a => Storable (BE a)
instance ByteSwap Word64
instance ByteSwap Word32
instance ByteSwap Word16


-- | ByteArray base converting
module Data.ByteArray.Encoding

-- | Convert a bytearray to the equivalent representation in a specific
--   Base
convertToBase :: (ByteArrayAccess bin, ByteArray bout) => Base -> bin -> bout

-- | Try to Convert a bytearray from the equivalent representation in a
--   specific Base
convertFromBase :: (ByteArrayAccess bin, ByteArray bout) => Base -> bin -> Either String bout

-- | Different bases that can be used
data Base

-- | similar to hexadecimal
Base16 :: Base
Base32 :: Base
Base64 :: Base
instance Show Base
instance Eq Base


module Data.ByteArray.Mapping

-- | Transform a bytearray at a specific offset into a Word64 tagged as BE
--   (Big Endian)
--   
--   no bounds checking. unsafe
toW64BE :: ByteArrayAccess bs => bs -> Int -> BE Word64

-- | Transform a bytearray at a specific offset into a Word64 tagged as LE
--   (Little Endian)
--   
--   no bounds checking. unsafe
toW64LE :: ByteArrayAccess bs => bs -> Int -> LE Word64

-- | map blocks of 64 bits of a bytearray, creating a new bytestring of
--   equivalent size where each blocks has been mapped through @f
--   
--   no length checking is done. unsafe
mapAsWord64 :: ByteArray bs => (Word64 -> Word64) -> bs -> bs

-- | map blocks of 128 bits of a bytearray, creating a new bytestring of
--   equivalent size where each blocks has been mapped through @f
--   
--   no length checking is done. unsafe
mapAsWord128 :: ByteArray bs => (Word128 -> Word128) -> bs -> bs


-- | A very simple bytearray parser related to Parsec and Attoparsec
--   
--   Simple example:
--   
--   <pre>
--   &gt; parse ((,,) &lt;$&gt; take 2 &lt;*&gt; byte 0x20 &lt;*&gt; (bytes "abc" *&gt; anyByte)) "xx abctest"
--   ParseOK "est" ("xx", 116)
--   </pre>
module Data.ByteArray.Parse

-- | Simple ByteString parser structure
data Parser byteArray a

-- | Simple parsing result, that represent respectively:
--   
--   <ul>
--   <li>failure: with the error message</li>
--   <li>continuation: that need for more input data</li>
--   <li>success: the remaining unparsed data and the parser value</li>
--   </ul>
data Result byteArray a
ParseFail :: String -> Result byteArray a
ParseMore :: (byteArray -> Result byteArray a) -> Result byteArray a
ParseOK :: byteArray -> a -> Result byteArray a

-- | Run a Parser on a ByteString and return a <a>Result</a>
parse :: ByteArrayAccess byteArray => Parser byteArray a -> byteArray -> Result byteArray a

-- | Run a parser on an @initial byteArray.
--   
--   If the Parser need more data than available, the @feeder function is
--   automatically called and fed to the More continuation.
parseFeed :: (ByteArrayAccess byteArray, Monad m) => m byteArray -> Parser byteArray a -> byteArray -> m (Result byteArray a)

-- | Parse a specific byte at current position
--   
--   if the byte is different than the expected on, this parser will raise
--   a failure.
byte :: ByteArray byteArray => Word8 -> Parser byteArray ()

-- | Get the next byte from the parser
anyByte :: ByteArray byteArray => Parser byteArray Word8

-- | Parse a sequence of bytes from current position
--   
--   if the following bytes don't match the expected bytestring completely,
--   the parser will raise a failure
bytes :: (Show ba, Eq ba, ByteArray ba) => ba -> Parser ba ()

-- | Take @n bytes from the current position in the stream
take :: ByteArray byteArray => Int -> Parser byteArray byteArray

-- | Take bytes while the @predicate hold from the current position in the
--   stream
takeWhile :: ByteArray byteArray => (Word8 -> Bool) -> Parser byteArray byteArray

-- | Take the remaining bytes from the current position in the stream
takeAll :: ByteArray byteArray => Parser byteArray byteArray

-- | Skip @n bytes from the current position in the stream
skip :: ByteArray byteArray => Int -> Parser byteArray ()

-- | Skip bytes while the @predicate hold from the current position in the
--   stream
skipWhile :: ByteArray byteArray => (Word8 -> Bool) -> Parser byteArray ()

-- | Skip all the remaining bytes from the current position in the stream
skipAll :: ByteArray byteArray => Parser byteArray ()

-- | Take a storable from the current position in the stream
takeStorable :: (ByteArray byteArray, Storable d) => Parser byteArray d
instance Alternative (Parser byteArray)
instance Applicative (Parser byteArray)
instance Functor (Parser byteArray)
instance MonadPlus (Parser byteArray)
instance Monad (Parser byteArray)
instance (Show ba, Show a) => Show (Result ba a)


-- | provide the SipHash algorithm. reference:
--   <a>http://131002.net/siphash/siphash.pdf</a>
module Data.ByteArray.Hash

-- | SigHash Key
data SipKey
SipKey :: {-# UNPACK #-} !Word64 -> {-# UNPACK #-} !Word64 -> SipKey

-- | Siphash tag value
newtype SipHash
SipHash :: Word64 -> SipHash

-- | Compute the SipHash tag of a byte array for a given key.
--   
--   <a>sipHash</a> is equivalent to 'sipHashWith 2 4'
sipHash :: ByteArrayAccess ba => SipKey -> ba -> SipHash

-- | Compute the SipHash tag of a byte array for a given key.
--   
--   The user can choose the C and D numbers of rounds.
--   
--   calling <a>sipHash</a> is equivalent to 'sipHashWith 2 4'
sipHashWith :: ByteArrayAccess ba => Int -> Int -> SipKey -> ba -> SipHash

-- | FNV1(a) hash (32 bit variants)
newtype FnvHash32
FnvHash32 :: Word32 -> FnvHash32

-- | FNV1(a) hash (64 bit variants)
newtype FnvHash64
FnvHash64 :: Word64 -> FnvHash64

-- | Compute the FNV1 32 bit hash value of a byte array
fnv1Hash :: ByteArrayAccess ba => ba -> FnvHash32

-- | Compute the FNV1a 32 bit hash value of a byte array
fnv1aHash :: ByteArrayAccess ba => ba -> FnvHash32

-- | Compute the FNV1 64 bit hash value of a byte array
fnv1_64Hash :: ByteArrayAccess ba => ba -> FnvHash64

-- | Compute the FNV1a 64 bit hash value of a byte array
fnv1a_64Hash :: ByteArrayAccess ba => ba -> FnvHash64


-- | Simple and efficient byte array types
--   
--   This module should be imported qualified.
module Data.ByteArray

-- | Class to Access size properties and data of a ByteArray
class ByteArrayAccess ba
length :: ByteArrayAccess ba => ba -> Int
withByteArray :: ByteArrayAccess ba => ba -> (Ptr p -> IO a) -> IO a

-- | Class to allocate new ByteArray of specific size
class (Eq ba, Ord ba, Monoid ba, ByteArrayAccess ba) => ByteArray ba
allocRet :: ByteArray ba => Int -> (Ptr p -> IO a) -> IO (a, ba)

-- | Simplest Byte Array
data Bytes

-- | ScrubbedBytes is a memory chunk which have the properties of:
--   
--   <ul>
--   <li>Being scrubbed after its goes out of scope.</li>
--   <li>A Show instance that doesn't actually show any content</li>
--   <li>A Eq instance that is constant time</li>
--   </ul>
data ScrubbedBytes

-- | A simple abstraction to a piece of memory.
--   
--   Do beware that garbage collection related to piece of memory could be
--   triggered before this is used.
--   
--   Only use with the appropriate handler has been used (e.g.
--   withForeignPtr on ForeignPtr)
data MemView
MemView :: {-# UNPACK #-} !(Ptr Word8) -> {-# UNPACK #-} !Int -> MemView

-- | Increase the memory view while reducing the size of the window
--   
--   this is useful as an abtraction to represent the current offset in a
--   buffer, and the remaining bytes left.
memViewPlus :: MemView -> Int -> MemView

-- | a view on a given bytes
--   
--   Equality test in constant time
data View bytes

-- | create a view on a given bytearray
--   
--   This function update the offset and the size in order to guarantee:
--   
--   <ul>
--   <li>offset &gt;= 0</li>
--   <li>size &gt;= 0</li>
--   <li>offset &lt; length</li>
--   <li>size =&lt; length - offset</li>
--   </ul>
view :: ByteArrayAccess bytes => bytes -> Int -> Int -> View bytes

-- | create a view from the given bytearray
takeView :: ByteArrayAccess bytes => bytes -> Int -> View bytes

-- | create a view from the given byte array starting after having dropped
--   the fist n bytes
dropView :: ByteArrayAccess bytes => bytes -> Int -> View bytes

-- | Allocate a new bytearray of specific size, and run the initializer on
--   this memory
alloc :: ByteArray ba => Int -> (Ptr p -> IO ()) -> IO ba

-- | similar to <a>alloc</a> but hide the allocation and initializer in a
--   pure context
allocAndFreeze :: ByteArray a => Int -> (Ptr p -> IO ()) -> a

-- | Allocate a new bytearray of specific size, and run the initializer on
--   this memory
create :: ByteArray ba => Int -> (Ptr p -> IO ()) -> IO ba

-- | similar to <a>create</a> but hide the allocation and initializer in a
--   pure context
unsafeCreate :: ByteArray a => Int -> (Ptr p -> IO ()) -> a

-- | Pack a list of bytes into a bytearray
pack :: ByteArray a => [Word8] -> a

-- | Un-pack a bytearray into a list of bytes
unpack :: ByteArrayAccess a => a -> [Word8]

-- | returns the first byte, and the remaining bytearray if the bytearray
--   is not null
uncons :: ByteArray a => a -> Maybe (Word8, a)

-- | Create an empty byte array
empty :: ByteArray a => a

-- | Check if a byte array is empty
null :: ByteArray a => a -> Bool

-- | Create a bytearray of a specific size containing a repeated byte value
replicate :: ByteArray ba => Int -> Word8 -> ba

-- | Create a bytearray of a specific size initialized to 0
zero :: ByteArray ba => Int -> ba

-- | Duplicate a bytearray into another bytearray, and run an initializer
--   on it
copy :: (ByteArrayAccess bs1, ByteArray bs2) => bs1 -> (Ptr p -> IO ()) -> IO bs2

-- | Take the first @n byte of a bytearray
take :: ByteArray bs => Int -> bs -> bs

-- | drop the first @n byte of a bytearray
drop :: ByteArray bs => Int -> bs -> bs

-- | Split a bytearray at the point where @pred becomes invalid
span :: ByteArray bs => (Word8 -> Bool) -> bs -> (bs, bs)

-- | Convert a bytearray to another type of bytearray
convert :: (ByteArrayAccess bin, ByteArray bout) => bin -> bout

-- | Similar to <a>copy</a> but also provide a way to return a value from
--   the initializer
copyRet :: (ByteArrayAccess bs1, ByteArray bs2) => bs1 -> (Ptr p -> IO a) -> IO (a, bs2)

-- | Similiar to <a>copy</a> but expect the resulting bytearray in a pure
--   context
copyAndFreeze :: (ByteArrayAccess bs1, ByteArray bs2) => bs1 -> (Ptr p -> IO ()) -> bs2

-- | Split a bytearray at a specific length in two bytearray
splitAt :: ByteArray bs => Int -> bs -> (bs, bs)

-- | Create a xor of bytes between a and b.
--   
--   the returns byte array is the size of the smallest input.
xor :: (ByteArrayAccess a, ByteArrayAccess b, ByteArray c) => a -> b -> c

-- | return a specific byte indexed by a number from 0 in a bytearray
--   
--   unsafe, no bound checking are done
index :: ByteArrayAccess a => a -> Int -> Word8

-- | Check if two bytearray are equals
--   
--   This is not constant time, as soon some byte differs the function will
--   returns. use <a>constEq</a> in sensitive context where timing matters.
eq :: (ByteArrayAccess bs1, ByteArrayAccess bs2) => bs1 -> bs2 -> Bool

-- | A constant time equality test for 2 ByteArrayAccess values.
--   
--   If values are of 2 different sizes, the function will abort early
--   without comparing any bytes.
--   
--   compared to == , this function will go over all the bytes present
--   before yielding a result even when knowing the overall result early in
--   the processing.
constEq :: (ByteArrayAccess bs1, ByteArrayAccess bs2) => bs1 -> bs2 -> Bool

-- | append one bytearray to the other
append :: ByteArray bs => bs -> bs -> bs

-- | Concatenate bytearray into a larger bytearray
concat :: (ByteArrayAccess bin, ByteArray bout) => [bin] -> bout


-- | Simple Byte Array packer
--   
--   Simple example:
--   
--   <pre>
--   &gt; flip pack 20 $ putWord8 0x41 &gt;&gt; putByteString "BCD" &gt;&gt; putWord8 0x20 &gt;&gt; putStorable (42 :: Word32)
--   Right (ABCD *\NUL\NUL\NUL")
--   </pre>
--   
--   Original code from <a>https://hackage.haskell.org/package/bspack</a>
--   generalized and adapted to run on <tt>memory</tt>, and spellchecked /
--   tweaked. (2015-05) Copyright (c) 2014 Nicolas DI PRIMA
module Data.ByteArray.Pack

-- | Simple ByteArray Packer
data Packer a

-- | Packing result:
--   
--   <ul>
--   <li>PackerMore: the next state of Packing with an arbitrary value</li>
--   <li>PackerFail: an error happened</li>
--   </ul>
data Result a
PackerMore :: a -> MemView -> Result a
PackerFail :: String -> Result a

-- | fill a given sized buffer with the result of the Packer action
fill :: ByteArray byteArray => Int -> Packer a -> Either String byteArray

-- | pack the given packer into the given bytestring

-- | <i>Deprecated: use fill instead</i>
pack :: ByteArray byteArray => Packer a -> Int -> Either String byteArray

-- | put Word8 in the current position in the stream
putWord8 :: Word8 -> Packer ()

-- | put Word16 in the current position in the stream /! use Host
--   Endianness
putWord16 :: Word16 -> Packer ()

-- | put Word32 in the current position in the stream /! use Host
--   Endianness
putWord32 :: Word32 -> Packer ()

-- | put a storable from the current position in the stream
putStorable :: Storable storable => storable -> Packer ()

-- | put a Byte Array from the current position in the stream
--   
--   If the ByteArray is null, then do nothing
putBytes :: ByteArrayAccess ba => ba -> Packer ()

-- | Will put the given storable list from the current position in the
--   stream to the end.
--   
--   This function will fail with not enough storage if the given storable
--   can't be written (not enough space)
--   
--   example: &gt; pack (fillList $ [1..] :: Word8) 9 ==&gt; "123456789"
--   &gt; pack (fillList $ [1..] :: Word32) 4 ==&gt; "1000" &gt; pack
--   (fillList $ [1..] :: Word32) 64 -- will work &gt; pack (fillList $
--   [1..] :: Word32) 1 -- will fail (not enough space) &gt; pack (fillList
--   $ [1..] :: Word32) 131 -- will fail (not enough space)
fillList :: Storable storable => [storable] -> Packer ()

-- | fill up from the current position in the stream to the end
--   
--   it is basically: &gt; fillUpWith s == fillList (repeat s)
fillUpWith :: Storable storable => storable -> Packer ()

-- | skip some bytes from the current position in the stream
skip :: Int -> Packer ()

-- | skip the size of a storable from the current position in the stream
skipStorable :: Storable storable => storable -> Packer ()
