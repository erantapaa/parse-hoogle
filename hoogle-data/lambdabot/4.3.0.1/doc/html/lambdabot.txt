-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lambdabot is a development tool and advanced IRC bot
--   
--   Lambdabot is an IRC bot written over several years by those on the
--   #haskell IRC channel.
--   
--   It operates as a command line tool, embedded in an editor, embedded in
--   GHCi, via internet relay chat and on the web.
@package lambdabot
@version 4.3.0.1

module Lambdabot.Util.Parser

-- | Parse a string as an <a>Exp</a> or a <a>Decl</a>, apply the given
--   generic transformation to it, and re-render it back to text.
withParsed :: (forall a. (Data a, Eq a) => a -> a) -> String -> String

-- | Render haskell code in a compact format
prettyPrintInLine :: Pretty a => a -> String

module Lambdabot.Plugin.Check.ShowQ
myquickcheck :: Testable prop => prop -> String

module Lambdabot.Plugin.Eval.Trusted
describeSequence :: SequenceData -> Maybe String
newtype Mu f
In :: f (Mu f) -> Mu f
out :: Mu f -> f (Mu f)
newtype Rec a
InR :: (Rec a -> a) -> Rec a
outR :: Rec a -> Rec a -> a

module Lambdabot.Util.Process
run :: FilePath -> String -> (String -> String) -> IO String


-- | The signal story. Posix signals are external events that invoke signal
--   handlers in Haskell. The signal handlers in turn throw dynamic
--   exceptions. Our instance of MonadError for LB maps the dynamic
--   exceptions to SignalCaughts, which can then be caught by a normal
--   catchError
module Lambdabot.Util.Signals
type Signal = CInt
newtype SignalException
SignalException :: Signal -> SignalException
ircSignalMessage :: Signal -> String

-- | Register signal handlers to catch external signals
withIrcSignalCatch :: MonadBaseControl IO m => m a -> m a
instance Typeable SignalException
instance Show SignalException
instance Exception SignalException


-- | Serialisation
module Lambdabot.Util.Serial
data Serial s
Serial :: (s -> Maybe ByteString) -> (ByteString -> Maybe s) -> Serial s
serialize :: Serial s -> s -> Maybe ByteString
deserialize :: Serial s -> ByteString -> Maybe s

-- | Default `instance' for a Serial
stdSerial :: (Show s, Read s) => Serial s

-- | Serializes a <a>Map</a> type if both the key and the value are
--   instances of Read and Show. The serialization is done by converting
--   the map to and from lists. Results are saved line-wise, for better
--   editing and revison control.
mapSerial :: (Ord k, Show k, Show v, Read k, Read v) => Serial (Map k v)
mapPackedSerial :: Serial (Map ByteString ByteString)
assocListPackedSerial :: Serial ([(ByteString, ByteString)])
mapListPackedSerial :: Serial (Map ByteString [ByteString])

-- | <a>readM</a> behaves like read, but catches failure in a monad. this
--   allocates a 20-30 M on startup...
readM :: (Monad m, Read a) => String -> m a
class Packable t
readPacked :: Packable t => ByteString -> t
showPacked :: Packable t => t -> ByteString
readOnly :: (ByteString -> b) -> Serial b
instance Packable (Map ByteString (Bool, [(String, Int)]))
instance Packable [(ByteString, ByteString)]
instance Packable (Map ByteString ByteString)
instance Packable (Map ByteString [ByteString])


-- | Time compatibility layer (stuff to support old lambdabot state
--   serialization formats)
--   
--   TODO: trim this down to just the explicitly serialization-related
--   stuff
module Lambdabot.Compat.AltTime

-- | Wrapping ClockTime (which doesn't provide a Read instance!) seems
--   easier than talking care of the serialization of UserStatus ourselves.
data ClockTime

-- | Retrieve the current clocktime
getClockTime :: IO ClockTime

-- | Difference of two clock times
diffClockTimes :: ClockTime -> ClockTime -> TimeDiff

-- | <tt><a>addToClockTime</a> d t</tt> adds a time difference <tt>d</tt>
--   and a -- clock time <tt>t</tt> to yield a new clock time.
addToClockTime :: TimeDiff -> ClockTime -> ClockTime

-- | Pretty-print a TimeDiff. Both positive and negative Timediffs produce
--   the same output.
--   
--   14d 17h 8m 53s
timeDiffPretty :: TimeDiff -> String
newtype TimeDiff
TimeDiff :: NominalDiffTime -> TimeDiff
noTimeDiff :: TimeDiff
instance Eq ClockTime
instance Eq TimeDiff
instance Ord TimeDiff
instance Binary TimeDiff
instance Binary ClockTime
instance Read TimeDiff
instance Show TimeDiff
instance Read ClockTime
instance Show ClockTime


-- | Extensible configuration system for lambdabot
--   
--   TODO: there's notthing lambdabot-specific about this, it could be a
--   useful standalone library.
module Lambdabot.Config
data Config t
getConfigDefault :: Config t -> t
mergeConfig :: Config t -> t -> t -> t
class Monad m => MonadConfig m
getConfig :: MonadConfig m => Config a -> m a

-- | Define a new configuration key with the specified name, type and
--   default value
--   
--   You should probably also provide an explicit export list for any
--   module that defines config keys, because the definition introduces a
--   few extra types that will clutter up the export list otherwise.
config :: String -> TypeQ -> ExpQ -> Q [Dec]

-- | Like <a>config</a>, but also allowing you to specify a "merge rule"
--   that will be used to combine multiple bindings of the same key.
--   
--   For example, in <a>Lambdabot.Config.Core</a>, <tt>onStartupCmds</tt>
--   is defined as a list of commands to execute on startup. Its default
--   value is [<a>offlinerc</a>], so if a user invokes the default
--   lambdabot executable without arguments, they will get a REPL. Each
--   instance of <a>-e</a> on the command-line adds a binding of the form:
--   
--   <pre>
--   onStartupCmds :=&gt; [command]
--   </pre>
--   
--   So if they give one <a>-e</a>, it replaces the default (note that it
--   is _not_ merged with the default - the default is discarded), and if
--   they give more than one they are merged using the specified operation
--   (in this case, `(++)`).
configWithMerge :: ExpQ -> String -> TypeQ -> ExpQ -> Q [Dec]
instance MonadConfig m => MonadConfig (StateT s m)
instance (MonadConfig m, Monoid w) => MonadConfig (WriterT w m)
instance MonadConfig m => MonadConfig (ReaderT r m)
instance GCompare Config
instance GEq Config


-- | String and other utilities
module Lambdabot.Util

-- | <a>dropSpace</a> takes as input a String and strips spaces from the
--   prefix as well as the suffix of the String. Example:
--   
--   <pre>
--   dropSpace "   abc  " ===&gt; "abc"
--   </pre>
dropSpace :: [Char] -> [Char]

-- | Drop space from the end of the string
dropSpaceEnd :: [Char] -> [Char]
dropNL :: [Char] -> [Char]

-- | Break a String into it's first word, and the rest of the string.
--   Example:
--   
--   <pre>
--   split_first_word "A fine day" ===&gt; ("A", "fine day)
--   </pre>
splitFirstWord :: String -> (String, String)

-- | Truncate a string to the specified length, putting ellipses at the end
--   if necessary.
limitStr :: Int -> String -> String

-- | Form a list of terms using a single conjunction. Example:
--   
--   <pre>
--   listToStr "and" ["a", "b", "c"] ===&gt; "a, b and c"
--   </pre>
listToStr :: String -> [String] -> String

-- | show a list without heavyweight formatting NB: assumes show instance
--   outputs a quoted <a>String</a>. under that assumption, strips the
--   outer quotes.
showClean :: Show a => [a] -> String

-- | untab an string
expandTab :: Int -> String -> String
arePrefixesWithSpaceOf :: [String] -> String -> Bool
arePrefixesOf :: [String] -> String -> Bool
io :: MonadIO m => IO a -> m a

-- | Pick a random element of the list.
random :: MonadIO m => [a] -> m a
insult :: [String]
confirmation :: [String]

module Lambdabot.Nick

-- | The type of nicknames isolated from a message.
data Nick
Nick :: !String -> !String -> Nick

-- | The tag of the server this nick is on
nTag :: Nick -> !String

-- | The server-specific nickname of this nick
nName :: Nick -> !String

-- | Format a nickname for display. This will automatically omit the server
--   field if it is the same as the server of the provided message.
fmtNick :: String -> Nick -> String

-- | Parse a nickname received in a message. If the server field is not
--   provided, it defaults to the same as that of the message.
parseNick :: String -> String -> Nick
instance Ord Nick
instance Eq Nick

module Lambdabot.OutputFilter
type OutputFilter m = Nick -> [String] -> m [String]
textwidth :: Int

-- | For now, this just checks for duplicate empty lines.
cleanOutput :: Monad m => OutputFilter m

-- | wrap long lines.
lineify :: Monad m => OutputFilter m

-- | Don't send any output to alleged bots.
checkRecip :: Monad m => OutputFilter m


-- | Backward-compatibility shim for (de-)serializing <a>Nick</a>s using
--   the old 'Read'/'Show' instances which gave freenode special treatment.
module Lambdabot.Compat.FreenodeNick
newtype FreenodeNick
FreenodeNick :: Nick -> FreenodeNick
getFreenodeNick :: FreenodeNick -> Nick
freenodeNickMapSerial :: (Show v, Read v) => Serial (Map Nick v)
instance Eq FreenodeNick
instance Ord FreenodeNick
instance Read FreenodeNick
instance Show FreenodeNick

module Lambdabot.Compat.PackedNick

-- | The type of nicknames
type PackedNick = ByteString

-- | Pack a nickname into a ByteString. Note that the resulting strings are
--   not optimally formatted for human consumtion.
packNick :: Nick -> ByteString

-- | Unpack a nickname packed by <a>packNick</a>.
unpackNick :: ByteString -> Nick

module Lambdabot.Message
class Show a => Message a
server :: Message a => a -> String
nick :: Message a => a -> Nick
fullName :: Message a => a -> String
channels :: Message a => a -> [Nick]
lambdabotName :: Message a => a -> Nick

module Lambdabot.Logging

-- | Priorities are used to define how important a log message is. Users
--   can filter log messages based on priorities.
--   
--   These have their roots on the traditional syslog system. The standard
--   definitions are given below, but you are free to interpret them
--   however you like. They are listed here in ascending importance order.
data Priority :: *

-- | Debug messages
DEBUG :: Priority

-- | Information
INFO :: Priority

-- | Normal runtime conditions
NOTICE :: Priority

-- | General Warnings
WARNING :: Priority

-- | General Errors
ERROR :: Priority

-- | Severe situations
CRITICAL :: Priority

-- | Take immediate action
ALERT :: Priority

-- | System is unusable
EMERGENCY :: Priority
class Monad m => MonadLogging m
getCurrentLogger :: MonadLogging m => m [String]
logM :: MonadLogging m => String -> Priority -> String -> m ()
debugM :: MonadLogging m => String -> m ()
infoM :: MonadLogging m => String -> m ()
noticeM :: MonadLogging m => String -> m ()
warningM :: MonadLogging m => String -> m ()
errorM :: MonadLogging m => String -> m ()
criticalM :: MonadLogging m => String -> m ()
alertM :: MonadLogging m => String -> m ()
emergencyM :: MonadLogging m => String -> m ()
instance MonadLogging IO

module Lambdabot.Config.Core
commandPrefixes :: Config [String]
disabledCommands :: Config [String]
evalPrefixes :: Config [String]
onStartupCmds :: Config [String]
outputDir :: Config FilePath
proxy :: Config Proxy
trustedPackages :: Config [String]
uncaughtExceptionHandler :: Config (SomeException -> IO ())
replaceRootLogger :: Config Bool
lbRootLoggerPath :: Config [String]
consoleLogHandle :: Config Handle
consoleLogLevel :: Config Priority
consoleLogFormat :: Config String
aspellBinary :: Config String
bfBinary :: Config String
djinnBinary :: Config String
ghcBinary :: Config String
ghciBinary :: Config String
hoogleBinary :: Config String
muevalBinary :: Config String
unlambdaBinary :: Config String
instance Typeable1 UNCAUGHTEXCEPTIONHANDLER
instance GCompare UNCAUGHTEXCEPTIONHANDLER
instance GEq UNCAUGHTEXCEPTIONHANDLER
instance Typeable1 TRUSTEDPACKAGES
instance GCompare TRUSTEDPACKAGES
instance GEq TRUSTEDPACKAGES
instance Typeable1 UNLAMBDABINARY
instance GCompare UNLAMBDABINARY
instance GEq UNLAMBDABINARY
instance Typeable1 MUEVALBINARY
instance GCompare MUEVALBINARY
instance GEq MUEVALBINARY
instance Typeable1 HOOGLEBINARY
instance GCompare HOOGLEBINARY
instance GEq HOOGLEBINARY
instance Typeable1 GHCIBINARY
instance GCompare GHCIBINARY
instance GEq GHCIBINARY
instance Typeable1 GHCBINARY
instance GCompare GHCBINARY
instance GEq GHCBINARY
instance Typeable1 DJINNBINARY
instance GCompare DJINNBINARY
instance GEq DJINNBINARY
instance Typeable1 BFBINARY
instance GCompare BFBINARY
instance GEq BFBINARY
instance Typeable1 ASPELLBINARY
instance GCompare ASPELLBINARY
instance GEq ASPELLBINARY
instance Typeable1 CONSOLELOGFORMAT
instance GCompare CONSOLELOGFORMAT
instance GEq CONSOLELOGFORMAT
instance Typeable1 CONSOLELOGLEVEL
instance GCompare CONSOLELOGLEVEL
instance GEq CONSOLELOGLEVEL
instance Typeable1 CONSOLELOGHANDLE
instance GCompare CONSOLELOGHANDLE
instance GEq CONSOLELOGHANDLE
instance Typeable1 LBROOTLOGGERPATH
instance GCompare LBROOTLOGGERPATH
instance GEq LBROOTLOGGERPATH
instance Typeable1 REPLACEROOTLOGGER
instance GCompare REPLACEROOTLOGGER
instance GEq REPLACEROOTLOGGER
instance Typeable1 PROXY
instance GCompare PROXY
instance GEq PROXY
instance Typeable1 OUTPUTDIR
instance GCompare OUTPUTDIR
instance GEq OUTPUTDIR
instance Typeable1 ONSTARTUPCMDS
instance GCompare ONSTARTUPCMDS
instance GEq ONSTARTUPCMDS
instance Typeable1 EVALPREFIXES
instance GCompare EVALPREFIXES
instance GEq EVALPREFIXES
instance Typeable1 DISABLEDCOMMANDS
instance GCompare DISABLEDCOMMANDS
instance GEq DISABLEDCOMMANDS
instance Typeable1 COMMANDPREFIXES
instance GCompare COMMANDPREFIXES
instance GEq COMMANDPREFIXES


-- | The IRC module processes the IRC protocol and provides a nice API for
--   sending and recieving IRC messages with an IRC server.
module Lambdabot.IRC

-- | An IRC message is a server, a prefix, a command and a list of
--   parameters.
data IrcMessage
IrcMessage :: !String -> !String -> !String -> !String -> ![String] -> IrcMessage
ircMsgServer :: IrcMessage -> !String
ircMsgLBName :: IrcMessage -> !String
ircMsgPrefix :: IrcMessage -> !String
ircMsgCommand :: IrcMessage -> !String
ircMsgParams :: IrcMessage -> ![String]
joinChannel :: Nick -> IrcMessage
partChannel :: Nick -> IrcMessage
getTopic :: Nick -> IrcMessage
setTopic :: Nick -> String -> IrcMessage

-- | <a>privmsg</a> creates a private message to the person designated.
privmsg :: Nick -> String -> IrcMessage

-- | <a>quit</a> creates a server QUIT message. The input string given is
--   the quit message, given to other parties when leaving the network.
quit :: String -> String -> IrcMessage
timeReply :: IrcMessage -> IrcMessage
errShowMsg :: IrcMessage -> String
user :: String -> String -> String -> String -> IrcMessage
setNick :: Nick -> IrcMessage
instance Show IrcMessage
instance Message IrcMessage

module Lambdabot.Command
data Command m
Command :: String -> [String] -> Bool -> Cmd m () -> (String -> Cmd m ()) -> Command m
cmdName :: Command m -> String
aliases :: Command m -> [String]
privileged :: Command m -> Bool
help :: Command m -> Cmd m ()
process :: Command m -> String -> Cmd m ()
cmdNames :: Command m -> [String]
command :: String -> Command Identity
runCommand :: (Monad m, Message a) => Command m -> a -> Nick -> String -> String -> m [String]
data Cmd m a
execCmd :: (Monad m, Message a) => Cmd m t -> a -> Nick -> String -> m [String]
getCmdName :: Monad m => Cmd m String
withMsg :: Monad m => (forall a. Message a => a -> Cmd m t) -> Cmd m t
readNick :: Monad m => String -> Cmd m Nick
showNick :: Monad m => Nick -> Cmd m String
getServer :: Monad m => Cmd m String
getSender :: Monad m => Cmd m Nick
getTarget :: Monad m => Cmd m Nick
getLambdabotName :: Monad m => Cmd m Nick
say :: Monad m => String -> Cmd m ()
instance MonadLogging m => MonadLogging (Cmd m)
instance MonadConfig m => MonadConfig (Cmd m)
instance MonadBaseControl b m => MonadBaseControl b (Cmd m)
instance MonadTransControl Cmd
instance MonadTrans Cmd
instance MonadBase b m => MonadBase b (Cmd m)
instance MonadIO m => MonadIO (Cmd m)
instance Monad m => Monad (Cmd m)
instance Applicative f => Applicative (Cmd f)
instance Functor f => Functor (Cmd f)

module Lambdabot.Module

-- | The Module type class.
data Module st
Module :: !(Maybe (Serial st)) -> !(LB st) -> !Bool -> !(ModuleT st LB [Command (ModuleT st LB)]) -> !(ModuleT st LB ()) -> !(ModuleT st LB ()) -> !(String -> Cmd (ModuleT st LB) ()) -> Module st

-- | If the module wants its state to be saved, this function should return
--   a Serial.
--   
--   The default implementation returns Nothing.
moduleSerialize :: Module st -> !(Maybe (Serial st))

-- | If the module maintains state, this method specifies the default state
--   (for example in case the state can't be read from a state).
--   
--   The default implementation returns an error and assumes the state is
--   never accessed.
moduleDefState :: Module st -> !(LB st)

-- | Is the module sticky? Sticky modules (as well as static ones) can't be
--   unloaded. By default, modules are not sticky.
moduleSticky :: Module st -> !Bool

-- | The commands the module listenes to.
moduleCmds :: Module st -> !(ModuleT st LB [Command (ModuleT st LB)])

-- | Initialize the module. The default implementation does nothing.
moduleInit :: Module st -> !(ModuleT st LB ())

-- | Finalize the module. The default implementation does nothing.
moduleExit :: Module st -> !(ModuleT st LB ())

-- | Process contextual input. A plugin that implements <a>contextual</a>
--   is able to respond to text not part of a normal command.
contextual :: Module st -> !(String -> Cmd (ModuleT st LB) ())
newModule :: Module st

-- | This transformer encodes the additional information a module might
--   need to access its name or its state.
newtype ModuleT st m a
ModuleT :: ReaderT (MVar st, String) m a -> ModuleT st m a
runModuleT :: ModuleT st m a -> ReaderT (MVar st, String) m a
getRef :: Monad m => ModuleT st m (MVar st)
getModuleName :: Monad m => ModuleT mod m String

-- | bind an action to the current module so it can be run from the plain
--   <a>LB</a> monad.
bindModule0 :: ModuleT mod LB a -> ModuleT mod LB (LB a)

-- | variant of <a>bindModule0</a> for monad actions with one argument
bindModule1 :: (a -> ModuleT mod LB b) -> ModuleT mod LB (a -> LB b)

-- | variant of <a>bindModule0</a> for monad actions with two arguments
bindModule2 :: (a -> b -> ModuleT mod LB c) -> ModuleT mod LB (a -> b -> LB c)
instance Applicative m => Applicative (ModuleT st m)
instance Functor m => Functor (ModuleT st m)
instance Monad m => Monad (ModuleT st m)
instance MonadTrans (ModuleT st)
instance MonadIO m => MonadIO (ModuleT st m)
instance MonadException m => MonadException (ModuleT st m)
instance MonadConfig m => MonadConfig (ModuleT st m)
instance MonadBaseControl b m => MonadBaseControl b (ModuleT st m)
instance MonadTransControl (ModuleT st)
instance MonadBase b m => MonadBase b (ModuleT st m)
instance MonadLogging m => MonadLogging (ModuleT st m)

module Lambdabot.ChanName
data ChanName
mkCN :: Nick -> ChanName
getCN :: ChanName -> Nick
instance Eq ChanName
instance Ord ChanName

module Lambdabot.Monad

-- | Global read-only state.
data IRCRState

-- | Default ro state
initRoState :: [DSum Config] -> IO IRCRState
reportInitDone :: MonadIO m => IRCRState -> m ()
waitForInit :: MonadLB m => m ()
waitForQuit :: MonadLB m => m ()
type Callback = IrcMessage -> LB ()
data ModuleRef
ModuleRef :: (Module st) -> (MVar st) -> String -> ModuleRef
data CommandRef
CommandRef :: (Module st) -> (MVar st) -> String -> (Command (ModuleT st LB)) -> CommandRef

-- | Global read/write state.
data IRCRWState
IRCRWState :: Map String (String, IrcMessage -> LB ()) -> Set Nick -> Set Nick -> Map ChanName String -> Map String ModuleRef -> Map String [(String, Callback)] -> [(String, OutputFilter LB)] -> Map String CommandRef -> !Bool -> IRCRWState
ircServerMap :: IRCRWState -> Map String (String, IrcMessage -> LB ())
ircPrivilegedUsers :: IRCRWState -> Set Nick
ircIgnoredUsers :: IRCRWState -> Set Nick

-- | maps channel names to topics
ircChannels :: IRCRWState -> Map ChanName String
ircModules :: IRCRWState -> Map String ModuleRef
ircCallbacks :: IRCRWState -> Map String [(String, Callback)]

-- | Output filters, invoked from right to left
ircOutputFilters :: IRCRWState -> [(String, OutputFilter LB)]
ircCommands :: IRCRWState -> Map String CommandRef
ircStayConnected :: IRCRWState -> !Bool

-- | Default rw state
initRwState :: IRCRWState

-- | The IRC Monad. The reader transformer holds information about the
--   connection to the IRC server.
--   
--   instances Monad, Functor, MonadIO, MonadState, MonadError
newtype LB a
LB :: ReaderT (IRCRState, IORef IRCRWState) IO a -> LB a
runLB :: LB a -> ReaderT (IRCRState, IORef IRCRWState) IO a
class (MonadIO m, MonadBaseControl IO m, MonadConfig m, MonadLogging m, Applicative m) => MonadLB m
lb :: MonadLB m => LB a -> m a

-- | run a computation in the LB monad
evalLB :: LB a -> IRCRState -> IRCRWState -> IO a
addServer :: String -> (IrcMessage -> LB ()) -> ModuleT mod LB ()
remServer :: String -> LB ()
send :: IrcMessage -> LB ()
received :: IrcMessage -> LB ()
getConfig :: MonadConfig m => Config a -> m a

-- | Interpret an expression in the context of a module. Arguments are
--   which map to use (<tt>ircModules</tt> and <tt>ircCommands</tt> are the
--   only sensible arguments here), the name of the module/command, action
--   for the case that the lookup fails, action if the lookup succeeds.
withModule :: String -> LB a -> (forall st. Module st -> ModuleT st LB a) -> LB a
withCommand :: String -> LB a -> (forall st. Module st -> Command (ModuleT st LB) -> ModuleT st LB a) -> LB a

-- | Interpret a function in the context of all modules
withAllModules :: (forall st. Module st -> ModuleT st LB a) -> LB ()
instance Functor LB
instance Applicative LB
instance Monad LB
instance MonadIO LB
instance MonadException LB
instance MonadLogging LB
instance MonadConfig LB
instance MonadState IRCRWState LB
instance MonadLB m => MonadLB (Cmd m)
instance MonadLB m => MonadLB (ModuleT st m)
instance MonadLB LB
instance MonadBaseControl IO LB
instance MonadBase IO LB

module Lambdabot.File

-- | Try to find a pre-existing file, searching first in ./State and then
--   in ~<i>.lambdabot</i>State
findLBFile :: FilePath -> LB (Maybe String)

-- | Complicated. If a file exists locally, we return that. If a file
--   exists in ~<i>lambdabot</i>State, we return that. If neither the file
--   nor ~<i>lambdabot</i>State exist, we create the directories and then
--   copy the file into it if a template exists, or create an empty file if
--   it does not. Note that the return type is simple so we can just do a
--   binding and stuff it into the conventional functions easily;
--   unfortunately, this removes error-checking, as an error is now just
--   "".
findOrCreateLBFile :: FilePath -> LB String
outputDir :: Config FilePath


-- | Support for the LB (LambdaBot) monad
module Lambdabot.State
class MonadLB m => MonadLBState m where type family LBState m
withMS :: MonadLBState m => (LBState m -> (LBState m -> m ()) -> m a) -> m a

-- | Read the module's private state.
readMS :: MonadLBState m => m (LBState m)

-- | Write the module's private state. Try to use withMS instead.
writeMS :: MonadLBState m => LBState m -> m ()

-- | Modify the module's private state.
modifyMS :: MonadLBState m => (LBState m -> LBState m) -> m ()

-- | This datatype allows modules to conviently maintain both global (i.e.
--   for all clients they're interacting with) and private state. It is
--   implemented on top of readMS/withMS.
--   
--   This simple implementation is linear in the number of private states
--   used.
data GlobalPrivate g p

-- | Creates a <tt>GlobalPrivate</tt> given the value of the global state.
--   No private state for clients will be created.
mkGlobalPrivate :: Int -> g -> GlobalPrivate g p

-- | Writes private state. For now, it locks everything.
withPS :: (MonadLBState m, LBState m ~ GlobalPrivate g p) => Nick -> (Maybe p -> (Maybe p -> LB ()) -> LB a) -> m a

-- | Reads private state.
readPS :: (MonadLBState m, LBState m ~ GlobalPrivate g p) => Nick -> m (Maybe p)
writePS :: (MonadLBState m, LBState m ~ GlobalPrivate g p) => Nick -> Maybe p -> m ()

-- | Writes global state. Locks everything
withGS :: (MonadLBState m, LBState m ~ GlobalPrivate g p) => (g -> (g -> m ()) -> m ()) -> m ()

-- | Reads global state.
readGS :: (MonadLBState m, LBState m ~ GlobalPrivate g p) => m g
writeGS :: (MonadLBState m, LBState m ~ GlobalPrivate g p) => g -> m ()

-- | flush state of modules
flushModuleState :: LB ()

-- | Read it in
readGlobalState :: Module st -> String -> LB (Maybe st)

-- | Peristence: write the global state out
writeGlobalState :: Module st -> String -> ModuleT st LB ()
instance MonadLBState m => MonadLBState (Cmd m)
instance MonadLB m => MonadLBState (ModuleT st m)


-- | Nickname equality subsystem.
--   
--   This component is responsible for deciding whether two nicknames refer
--   to the same person, for the purposes of <tt>tell et al. Nickname
--   equality must be monadic because it uses mutable state maintained by
--   the </tt>link and <tt>unlink commands. Also provided is a concept of
--   polynicks (by analogy to polytypes); polynicks can refer to an (open)
--   set of nicknames. For instance '</tt>tell *lambdabot Why does X do Y'
--   could tell a message to anyone who has identified as a lambdabot
--   maintainer. A polynick consists of a bar-separated list of (nicks or
--   open terms); an open term is like a nick but preceded with a star.
module Lambdabot.NickEq
data Polynick

-- | Determine if a nick matches a polynick. The state is read at the point
--   of binding.
nickMatches :: LB (Nick -> Polynick -> Bool)

-- | Parse a read polynick.
readPolynick :: Message a => a -> String -> Polynick

-- | Format a polynick.
showPolynick :: Message a => a -> Polynick -> String

-- | Lookup (using a polynick) in a map keyed on mononicks.
lookupMononickMap :: LB (Polynick -> Map Nick a -> [(Nick, a)])

-- | Convert a regular mononick into a polynick.
mononickToPolynick :: Nick -> Polynick
instance Eq Polynick


-- | URL Utility Functions
module Lambdabot.Util.Browser

-- | Fetches a page title suitable for display. Ideally, other plugins
--   should make use of this function if the result is to be displayed in
--   an IRC channel because it ensures that a consistent look is used (and
--   also lets the URL plugin effectively ignore contextual URLs that might
--   be generated by another instance of lambdabot; the URL plugin matches
--   on <tt>urlTitlePrompt</tt>).
urlPageTitle :: String -> BrowserAction (HandleStream String) (Maybe String)

-- | Run a browser action with some standardized settings
browseLB :: MonadLB m => BrowserAction conn a -> m a


-- | The guts of lambdabot.
--   
--   The LB/Lambdabot monad Generic server connection,disconnection The
--   module typeclass, type and operations on modules
module Lambdabot

-- | Register a module in the irc state
ircLoadModule :: Module st -> String -> LB ()

-- | Unregister a module's entry in the irc state
ircUnloadModule :: String -> LB ()
ircSignalConnect :: String -> Callback -> ModuleT mod LB ()
ircInstallOutputFilter :: OutputFilter LB -> ModuleT mod LB ()

-- | Checks if the given user has admin permissions and excecute the action
--   only in this case.
checkPrivs :: IrcMessage -> LB Bool

-- | Checks if the given user is being ignored. Privileged users can't be
--   ignored.
checkIgnore :: IrcMessage -> LB Bool
ircGetChannels :: LB [Nick]
ircQuit :: String -> String -> LB ()
ircReconnect :: String -> String -> LB ()

-- | Send a message to a channel/user. If the message is too long, the rest
--   of it is saved in the (global) more-state.
ircPrivmsg :: Nick -> String -> LB ()
ircPrivmsg' :: Nick -> String -> LB ()
instance MonadRandom LB

module Lambdabot.Main
lambdabotVersion :: Version
data Config t

-- | A basic dependent sum type; the first component is a tag that
--   specifies the type of the second; for example, think of a GADT such
--   as:
--   
--   <pre>
--   data Tag a where
--      AString :: Tag String
--      AnInt   :: Tag Int
--   </pre>
--   
--   Then, we have the following valid expressions of type <tt>DSum
--   Tag</tt>:
--   
--   <pre>
--   AString :=&gt; "hello!"
--   AnInt   :=&gt; 42
--   </pre>
--   
--   And we can write functions that consume <tt>DSum Tag</tt> values by
--   matching, such as:
--   
--   <pre>
--   toString :: DSum Tag -&gt; String
--   toString (AString :=&gt; str) = str
--   toString (AnInt   :=&gt; int) = show int
--   </pre>
--   
--   By analogy to the (key =&gt; value) construction for dictionary
--   entries in many dynamic languages, we use (key :=&gt; value) as the
--   constructor for dependent sums. The :=&gt; operator has very low
--   precedence and binds to the right, so if the <tt>Tag</tt> GADT is
--   extended with an additional constructor <tt>Rec :: Tag (DSum
--   Tag)</tt>, then <tt>Rec :=&gt; AnInt :=&gt; 3 + 4</tt> is parsed as
--   would be expected (<tt>Rec :=&gt; (AnInt :=&gt; (3 + 4))</tt>) and has
--   type <tt>DSum Tag</tt>. Its precedence is just above that of <a>$</a>,
--   so <tt>foo bar $ AString :=&gt; <a>eep</a></tt> is equivalent to
--   <tt>foo bar (AString :=&gt; <a>eep</a>)</tt>.
data DSum (tag :: * -> *) :: (* -> *) -> *
(:=>) :: !(tag a) -> a -> DSum tag

-- | The Lambdabot entry point. Initialise plugins, connect, and run the
--   bot in the LB monad
--   
--   Also, handle any fatal exceptions (such as non-recoverable signals),
--   (i.e. print a message and exit). Non-fatal exceptions should be dealt
--   with in the mainLoop or further down.
lambdabotMain :: LB () -> [DSum Config] -> IO ExitCode
type Modules = LB ()
modules :: [String] -> Q Exp

-- | Priorities are used to define how important a log message is. Users
--   can filter log messages based on priorities.
--   
--   These have their roots on the traditional syslog system. The standard
--   definitions are given below, but you are free to interpret them
--   however you like. They are listed here in ascending importance order.
data Priority :: *

-- | Debug messages
DEBUG :: Priority

-- | Information
INFO :: Priority

-- | Normal runtime conditions
NOTICE :: Priority

-- | General Warnings
WARNING :: Priority

-- | General Errors
ERROR :: Priority

-- | Severe situations
CRITICAL :: Priority

-- | Take immediate action
ALERT :: Priority

-- | System is unusable
EMERGENCY :: Priority

module Lambdabot.Plugin

-- | The Module type class.
data Module st
Module :: !(Maybe (Serial st)) -> !(LB st) -> !Bool -> !(ModuleT st LB [Command (ModuleT st LB)]) -> !(ModuleT st LB ()) -> !(ModuleT st LB ()) -> !(String -> Cmd (ModuleT st LB) ()) -> Module st

-- | If the module wants its state to be saved, this function should return
--   a Serial.
--   
--   The default implementation returns Nothing.
moduleSerialize :: Module st -> !(Maybe (Serial st))

-- | If the module maintains state, this method specifies the default state
--   (for example in case the state can't be read from a state).
--   
--   The default implementation returns an error and assumes the state is
--   never accessed.
moduleDefState :: Module st -> !(LB st)

-- | Is the module sticky? Sticky modules (as well as static ones) can't be
--   unloaded. By default, modules are not sticky.
moduleSticky :: Module st -> !Bool

-- | The commands the module listenes to.
moduleCmds :: Module st -> !(ModuleT st LB [Command (ModuleT st LB)])

-- | Initialize the module. The default implementation does nothing.
moduleInit :: Module st -> !(ModuleT st LB ())

-- | Finalize the module. The default implementation does nothing.
moduleExit :: Module st -> !(ModuleT st LB ())

-- | Process contextual input. A plugin that implements <a>contextual</a>
--   is able to respond to text not part of a normal command.
contextual :: Module st -> !(String -> Cmd (ModuleT st LB) ())

-- | This transformer encodes the additional information a module might
--   need to access its name or its state.
data ModuleT st m a
newModule :: Module st
getModuleName :: Monad m => ModuleT mod m String

-- | bind an action to the current module so it can be run from the plain
--   <a>LB</a> monad.
bindModule0 :: ModuleT mod LB a -> ModuleT mod LB (LB a)

-- | variant of <a>bindModule0</a> for monad actions with one argument
bindModule1 :: (a -> ModuleT mod LB b) -> ModuleT mod LB (a -> LB b)

-- | variant of <a>bindModule0</a> for monad actions with two arguments
bindModule2 :: (a -> b -> ModuleT mod LB c) -> ModuleT mod LB (a -> b -> LB c)

-- | The IRC Monad. The reader transformer holds information about the
--   connection to the IRC server.
--   
--   instances Monad, Functor, MonadIO, MonadState, MonadError
data LB a
class (MonadIO m, MonadBaseControl IO m, MonadConfig m, MonadLogging m, Applicative m) => MonadLB m
lb :: MonadLB m => LB a -> m a
lim80 :: Monad m => m String -> Cmd m ()

-- | convenience, similar to ios but also cut output to channel to 80
--   characters usage: <tt>process _ _ to _ s = ios80 to (plugs s)</tt>
ios80 :: MonadIO m => IO String -> Cmd m ()
data ChanName
mkCN :: Nick -> ChanName
getCN :: ChanName -> Nick

-- | The type of nicknames isolated from a message.
data Nick
Nick :: !String -> !String -> Nick

-- | The tag of the server this nick is on
nTag :: Nick -> !String

-- | The server-specific nickname of this nick
nName :: Nick -> !String

-- | Send a message to a channel/user. If the message is too long, the rest
--   of it is saved in the (global) more-state.
ircPrivmsg :: Nick -> String -> LB ()


-- | A plugin for the Haskell interpreter for the brainf*ck language
--   http:<i></i>www.muppetlabs.com<i>~breadbox</i>bf/
module Lambdabot.Plugin.BF
bfPlugin :: Module ()


-- | A Haskell evaluator for the pure part, using mueval
module Lambdabot.Plugin.Eval
evalPlugin :: Module ()
runGHC :: MonadLB m => String -> m String
exts :: [String]


-- | Test a property with QuickCheck
module Lambdabot.Plugin.Check
checkPlugin :: Module ()

module Lambdabot.Plugin.Compose
composePlugin :: Module ()
instance Show Expr


-- | This module is for throwing dice for e.g. RPGs. (@dice 3d6+2)
module Lambdabot.Plugin.Dice
dicePlugin :: Module ()


-- | DICT (RFC 2229) Lookup Module for lambdabot IRC robot. Tom Moertel
--   <a>tom@moertel.com</a>
module Lambdabot.Plugin.Dict
dictPlugin :: Module ()


-- | A binding to Djinn.
module Lambdabot.Plugin.Djinn
djinnPlugin :: Module (Maybe DjinnEnv)


-- | Simple template module Contains many constant bot commands.
module Lambdabot.Plugin.Dummy
dummyPlugin :: Module ()

module Lambdabot.Plugin.Elite
elitePlugin :: Module ()

module Lambdabot.Plugin.Error
errorPlugin :: Module ()
failOnLoad :: Config Bool
errorOnLoad :: Config Bool
instance Typeable1 ERRORONLOAD
instance GCompare ERRORONLOAD
instance GEq ERRORONLOAD
instance Typeable1 FAILONLOAD
instance GCompare FAILONLOAD
instance GEq FAILONLOAD


-- | GNU Talk Filters needs:
--   http:<i></i>www.hyperrealm.com/main.php?s=talkfilters Edward Kmett
--   2006
module Lambdabot.Plugin.Filter
filterPlugin :: Module [(String, FilePath, String)]


-- | The Type Module - another progressive plugin for lambdabot
--   
--   pesco hamburg 2003-04-05
--   
--   Greetings reader,
--   
--   whether you're a regular follower of the series or dropping in for the
--   first time, let me present for your pleasure the Type Module:
--   
--   One thing we enjoy on #haskell is throwing function types at each
--   other instead of spelling out tiresome monologue about arguments or
--   return values. Unfortunately such a toss often involves a local lookup
--   of the type signature in question because one is seldom sure about the
--   actual argument order.
--   
--   Well, what do you know, this plugin enables lambdabot to automate that
--   lookup for you and your fellow lambda hackers.
module Lambdabot.Plugin.Type
typePlugin :: Module ()
query_ghci :: MonadLB m => String -> String -> m String


-- | Free theorems plugin Andrew Bromage, 2006
module Lambdabot.Plugin.Free
freePlugin :: Module ()


-- | Haskell project name generation semi-joke
module Lambdabot.Plugin.Fresh
freshPlugin :: Module Integer


-- | Hackish Haddock module.
module Lambdabot.Plugin.Haddock
haddockPlugin :: Module HaddockState


-- | Hello world plugin
module Lambdabot.Plugin.Hello
helloPlugin :: Module ()


-- | Provide help for plugins
module Lambdabot.Plugin.Help
helpPlugin :: Module ()


-- | Talk to Neil Mitchell's <tt>Hoogle</tt> program
module Lambdabot.Plugin.Hoogle
hooglePlugin :: Module [String]


-- | A module to output the instances of a typeclass. Some sample
--   input/output:
--   
--   <pre>
--   lambdabot&gt; @instances Monad
--   [], ArrowMonad a, WriterT w m, Writer w, ReaderT r m, Reader r,
--   StateT s m, State s, RWST r w s m, RWS r w s, ErrorT e m, Either e,
--   ContT r m, Cont r, Maybe, ST s, IO
--   
--   lambdabot&gt; @instances Show
--   Float, Double, Integer, ST s a, [a], (a, b, c, d), (a, b, c), (a, b),
--   (), Ordering, Maybe a, Int, Either a b, Char, Bool
--   
--   lambdabot&gt; @instances-importing Text.Html Data.Tree Show
--   Float, Double, Tree a, HtmlTable, HtmlAttr, Html, HotLink, Integer,
--   ST s a, [a], (a, b, c, d), (a, b, c), (a, b), (), Ordering, Maybe a,
--   Int
--   </pre>
module Lambdabot.Plugin.Instances
instancesPlugin :: Module ()


-- | The plugin-level IRC interface.
module Lambdabot.Plugin.IRC
ircPlugin :: Module ()


-- | Karma
module Lambdabot.Plugin.Karma
karmaPlugin :: Module KarmaState

module Lambdabot.Plugin.Numberwang
numberwangPlugin :: Module NumberwangState


-- | Look up sequences in the Online Encyclopedia of Integer Sequences
--   Based on the Math.OEIS library
module Lambdabot.Plugin.OEIS
oeisPlugin :: Module ()


-- | Offline mode <i> RC file </i> -e support module. Handles spooling
--   lists of commands (from haskeline, files, or the command line) into
--   the vchat layer.
module Lambdabot.Plugin.OfflineRC
offlineRC :: Module OfflineRCState


-- | Pointfree programming fun
--   
--   A catalogue of refactorings is at:
--   http:<i></i>www.cs.kent.ac.uk<i>projects</i>refactor-fp<i>catalogue</i>
--   http:<i></i>www.cs.kent.ac.uk<i>projects</i>refactor-fp<i>catalogue</i>RefacIdeasAug03.html
--   
--   Use more Arrow stuff
--   
--   TODO would be to plug into HaRe and use some of their refactorings.
module Lambdabot.Plugin.Pl
plPlugin :: Module (GlobalPrivate () (Int, TopLevel))

module Lambdabot.Plugin.Pointful
pointfulPlugin :: Module ()


-- | | Support for voting | | License: lGPL | | added by Kenneth Hoste
--   (boegel), 22<i>11</i>2005 | inspiration: Where plugin (thanks
--   shapr,dons)
module Lambdabot.Plugin.Poll
pollPlugin :: Module (Map PollName Poll)


-- | Pretty-Printing echo
--   
--   example:
--   
--   <pre>
--   @pretty fun x = case x of {3 -&gt; "hello" ; 5 -&gt; "world" ; _ -&gt; "else"}
--   </pre>
--   
--   <pre>
--   fun x
--    = case x of
--     3 -&gt; "hello"
--     5 -&gt; "world"
--     _ -&gt; "else"
--   </pre>
--   
--   (c) Johannes Ahlmann, 2005-12-13, released under GPL 2
module Lambdabot.Plugin.Pretty
prettyPlugin :: Module ()


-- | Support for quotes
module Lambdabot.Plugin.Quote
quotePlugin :: Module (Map ByteString [ByteString])


-- | Search various things, Wikipedia and google for now.
--   
--   (c) 2005 Samuel Bronson (c) 2006 Don Stewart
module Lambdabot.Plugin.Search
searchPlugin :: Module ()


-- | Support for quotes
module Lambdabot.Plugin.Slap
slapPlugin :: Module ()

module Lambdabot.Plugin.Source
sourcePlugin :: Module (Map ByteString ByteString)


-- | Interface to <i>aspell</i>, an open source spelling checker, from a
--   suggestion by Kai Engelhardt. Requires you to install aspell.
module Lambdabot.Plugin.Spell
spellPlugin :: Module Bool

module Lambdabot.Plugin.Stats
statsPlugin :: Module StatsD

module Lambdabot.Plugin.Tell
tellPlugin :: Module NoticeBoard
instance Show NoteType
instance Eq NoteType
instance Read NoteType
instance Eq Note
instance Show Note
instance Read Note


-- | Pull quotes down from yahoo.
module Lambdabot.Plugin.Ticker
tickerPlugin :: Module ()


-- | A todo list
--   
--   (c) 2005 Samuel Bronson
module Lambdabot.Plugin.Todo
todoPlugin :: Module TodoState


-- | The Topic plugin is an interface for messing with the channel topic.
--   It can alter the topic in various ways and keep track of the changes.
--   The advantage of having the bot maintain the topic is that we get an
--   authoritative source for the current topic, when the IRC server
--   decides to delete it due to Network Splits.
module Lambdabot.Plugin.Topic
topicPlugin :: Module ()

module Lambdabot.Plugin.Undo
undoPlugin :: Module ()


-- | A plugin for the Haskell interpreter for the unlambda language
--   
--   http:<i></i>www.madore.org<i>~david</i>programs<i>unlambda</i>
module Lambdabot.Plugin.Unlambda
unlambdaPlugin :: Module ()


-- | Unroll the MTL monads with your favorite bot!
module Lambdabot.Plugin.UnMtl
unmtlPlugin :: Module ()
instance Monad PMonad


-- | Fetch URL page titles of HTML links.
module Lambdabot.Plugin.Url
urlPlugin :: Module Bool


-- | Lambdabot version information
module Lambdabot.Plugin.Version
versionPlugin :: Module ()


-- | Talk to hot chixxors.
module Lambdabot.Plugin.Vixen
vixenPlugin :: Module (Bool, String -> IO [Char])
instance Show WTree
instance Binary WTree


-- | Slightly specialised version of Where for associating projects with
--   their urls. Code almost all copied.
module Lambdabot.Plugin.Where
wherePlugin :: Module (Map ByteString ByteString)


-- | Logging an IRC channel..
module Lambdabot.Plugin.Activity
activityPlugin :: Module [(UTCTime, Nick)]


-- | Lambdabot base module. Controls message send and receive
module Lambdabot.Plugin.Base
base :: Module (GlobalPrivate () ())


-- | Simple wrapper over privmsg to get time information via the CTCP
module Lambdabot.Plugin.Localtime
localtimePlugin :: Module TimeMap


-- | Logging an IRC channel..
module Lambdabot.Plugin.Log
logPlugin :: Module (Map Channel ChanState)
instance Show ChanState
instance Eq ChanState
instance Eq Event
instance Show Event


-- | Support for more(1) buffering
module Lambdabot.Plugin.More
morePlugin :: Module (GlobalPrivate () [String])


-- | Keep track of IRC users.
module Lambdabot.Plugin.Seen
seenPlugin :: Module (Map Channel Int, Map PackedNick UserStatus)


-- | System module : IRC control functions
module Lambdabot.Plugin.System
system :: Module SystemState
