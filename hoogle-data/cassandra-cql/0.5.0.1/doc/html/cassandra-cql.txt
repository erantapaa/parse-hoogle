-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell client for Cassandra's CQL protocol
--   
@package cassandra-cql
@version 0.5.0.1


-- | Haskell client for Cassandra's CQL protocol
--   
--   For examples, take a look at the <i>tests</i> directory in the source
--   archive.
--   
--   Here's the correspondence between CQL and Haskell types:
--   
--   <ul>
--   <li>ascii - <a>ByteString</a></li>
--   <li>bigint - <a>Int64</a></li>
--   <li>blob - <a>Blob</a></li>
--   <li>boolean - <a>Bool</a></li>
--   <li>counter - <a>Counter</a></li>
--   <li>decimal - <a>Decimal</a></li>
--   <li>double - <a>Double</a></li>
--   <li>float - <a>Float</a></li>
--   <li>int - <a>Int</a></li>
--   <li>text / varchar - <a>Text</a></li>
--   <li>timestamp - <a>UTCTime</a></li>
--   <li>uuid - <a>UUID</a></li>
--   <li>varint - <a>Integer</a></li>
--   <li>timeuuid - <a>TimeUUID</a></li>
--   <li>inet - <a>SockAddr</a></li>
--   <li>list&lt;a&gt; - [a]</li>
--   <li>map&lt;a, b&gt; - <a>Map</a> a b</li>
--   <li>set&lt;a&gt; - <a>Set</a> b</li>
--   </ul>
--   
--   ...and you can define your own <a>CasType</a> instances to extend
--   these types, which is a very powerful way to write your code.
--   
--   One way to do things is to specify your queries with a type signature,
--   like this:
--   
--   <pre>
--   createSongs :: Query Schema () ()
--   createSongs = "create table songs (id uuid PRIMARY KEY, title text, artist text, comment text)"
--   
--   insertSong :: Query Write (UUID, Text, Text, Maybe Text) ()
--   insertSong = "insert into songs (id, title, artist, comment) values (?, ?, ?)"
--   
--   getOneSong :: Query Rows UUID (Text, Text, Maybe Text)
--   getOneSong = "select title, artist, comment from songs where id=?"
--   </pre>
--   
--   The three type parameters are the query type (<a>Schema</a>,
--   <a>Write</a> or <a>Rows</a>) followed by the input and output types,
--   which are given as tuples whose constituent types must match the ones
--   in the query CQL. If you do not match them correctly, you'll get a
--   runtime error when you execute the query. If you do, then the query
--   becomes completely type safe.
--   
--   Types can be <a>Maybe</a> types, in which case you can read and write
--   a Cassandra 'null' in the table. Cassandra allows any column to be
--   null, but you can lock this out by specifying non-Maybe types.
--   
--   The query types are:
--   
--   <ul>
--   <li><a>Schema</a> for modifications to the schema. The output tuple
--   type must be ().</li>
--   <li><a>Write</a> for row inserts and updates, and such. The output
--   tuple type must be ().</li>
--   <li><a>Rows</a> for selects that give a list of rows in response.</li>
--   </ul>
--   
--   The functions to use for these query types are <a>executeSchema</a>,
--   <a>executeWrite</a>, <a>executeTrans</a> and <a>executeRows</a> or
--   <a>executeRow</a> respectively.
--   
--   The following pattern seems to work very well, especially along with
--   your own <a>CasType</a> instances, because it gives you a place to
--   neatly add marshalling details that keeps away from the body of your
--   code.
--   
--   <pre>
--   insertSong :: UUID -&gt; Text -&gt; Text -&gt; Maybe Text -&gt; Cas ()
--   insertSong id title artist comment = executeWrite QUORUM q (id, title, artist, comment)
--        where q = "insert into songs (id, title, artist, comment) values (?, ?, ?, ?)"
--   </pre>
--   
--   Incidentally, here's Haskell's little-known multi-line string syntax.
--   You escape it using \ and then another \ where the string starts
--   again.
--   
--   <pre>
--   str = "multi\
--          \line"
--   </pre>
--   
--   (gives "multiline")
--   
--   <i>To do</i>
--   
--   <ul>
--   <li>Add the ability to easily run queries in parallel.</li>
--   <li>Add support for batch queries.</li>
--   <li>Add support for query paging.</li>
--   </ul>
module Database.Cassandra.CQL
type Server = (HostName, ServiceName)

-- | The name of a Cassandra keyspace. See the Cassandra documentation for
--   more information.
newtype Keyspace
Keyspace :: Text -> Keyspace
data Pool

-- | Construct a pool of Cassandra connections.
newPool :: [Server] -> Keyspace -> Maybe Authentication -> IO Pool
newPool' :: PoolConfig -> IO Pool
defaultConfig :: [Server] -> Keyspace -> Maybe Authentication -> PoolConfig
class MonadCatchIO m => MonadCassandra m
getCassandraPool :: MonadCassandra m => m Pool

-- | The monad used to run Cassandra queries in.
data Cas a

-- | Execute Cassandra queries.
runCas :: Pool -> Cas a -> IO a

-- | An exception that indicates an error originating in the Cassandra
--   server.
data CassandraException
ServerError :: Text -> Text -> CassandraException
ProtocolError :: Text -> Text -> CassandraException
BadCredentials :: Text -> Text -> CassandraException
UnavailableException :: Text -> Consistency -> Int -> Int -> Text -> CassandraException
Overloaded :: Text -> Text -> CassandraException
IsBootstrapping :: Text -> Text -> CassandraException
TruncateError :: Text -> Text -> CassandraException
WriteTimeout :: Text -> Consistency -> Int -> Int -> Text -> Text -> CassandraException
ReadTimeout :: Text -> Consistency -> Int -> Int -> Bool -> Text -> CassandraException
SyntaxError :: Text -> Text -> CassandraException
Unauthorized :: Text -> Text -> CassandraException
Invalid :: Text -> Text -> CassandraException
ConfigError :: Text -> Text -> CassandraException
AlreadyExists :: Text -> Keyspace -> Table -> Text -> CassandraException
Unprepared :: Text -> PreparedQueryID -> Text -> CassandraException

-- | All errors at the communications level are reported with this
--   exception (<a>IOException</a>s from socket I/O are always wrapped),
--   and this exception typically would mean that a retry is warranted.
--   
--   Note that this exception isn't guaranteed to be a transient one, so a
--   limit on the number of retries is likely to be a good idea.
--   <a>LocalProtocolError</a> probably indicates a corrupted database or
--   driver bug.
data CassandraCommsError
AuthenticationException :: Text -> CassandraCommsError
LocalProtocolError :: Text -> Text -> CassandraCommsError
MissingAuthenticationError :: Text -> Text -> CassandraCommsError
ValueMarshallingException :: TransportDirection -> Text -> Text -> CassandraCommsError
CassandraIOException :: IOException -> CassandraCommsError
ShortRead :: CassandraCommsError
NoAvailableServers :: CassandraCommsError
CoordinatorTimeout :: CassandraCommsError
data TransportDirection
TransportSending :: TransportDirection
TransportReceiving :: TransportDirection
data Authentication
PasswordAuthenticator :: UserId -> Password -> Authentication

-- | The text of a CQL query, along with type parameters to make the query
--   type safe. The type arguments are <a>Style</a>, followed by input and
--   output column types for the query each represented as a tuple.
--   
--   The <i>DataKinds</i> language extension is required for <a>Style</a>.
data Query :: Style -> * -> * -> *

-- | The first type argument for Query. Tells us what kind of query it is.
data Style

-- | A query that modifies the schema, such as DROP TABLE or CREATE TABLE
Schema :: Style

-- | A query that writes data, such as an INSERT or UPDATE
Write :: Style

-- | A query that returns a list of rows, such as SELECT
Rows :: Style

-- | Construct a query. Another way to construct one is as an overloaded
--   string through the <a>IsString</a> instance if you turn on the
--   <i>OverloadedStrings</i> language extension, e.g.
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   ...
--   
--   getOneSong :: Query Rows UUID (Text, Text, Maybe Text)
--   getOneSong = "select title, artist, comment from songs where id=?"
--   </pre>
query :: Text -> Query style i o

-- | Cassandra consistency level. See the Cassandra documentation for an
--   explanation.
data Consistency
ANY :: Consistency
ONE :: Consistency
TWO :: Consistency
THREE :: Consistency
QUORUM :: Consistency
ALL :: Consistency
LOCAL_QUORUM :: Consistency
EACH_QUORUM :: Consistency
SERIAL :: Consistency
LOCAL_SERIAL :: Consistency
LOCAL_ONE :: Consistency
data Change
CREATED :: Change
UPDATED :: Change
DROPPED :: Change

-- | Execute a schema change, such as creating or dropping a table.
executeSchema :: (MonadCassandra m, CasValues i) => Consistency -> Query Schema i () -> i -> m (Change, Keyspace, Table)

-- | Execute a write operation that returns void.
executeWrite :: (MonadCassandra m, CasValues i) => Consistency -> Query Write i () -> i -> m ()

-- | Execute a query that returns rows.
executeRows :: (MonadCassandra m, CasValues i, CasValues o) => Consistency -> Query Rows i o -> i -> m [o]

-- | Helper for <a>executeRows</a> useful in situations where you are only
--   expecting one row to be returned.
executeRow :: (MonadCassandra m, CasValues i, CasValues o) => Consistency -> Query Rows i o -> i -> m (Maybe o)

-- | Execute a lightweight transaction. The consistency level is implicit
--   and is SERIAL.
executeTrans :: (MonadCassandra m, CasValues i) => Query Write i () -> i -> m Bool

-- | If you wrap this round a <a>ByteString</a>, it will be treated as a
--   <i>blob</i> type instead of <i>ascii</i> (if it was a plain
--   <a>ByteString</a> type).
newtype Blob
Blob :: ByteString -> Blob
unBlob :: Blob -> ByteString

-- | A Cassandra distributed counter value.
newtype Counter
Counter :: Int64 -> Counter
unCounter :: Counter -> Int64

-- | If you wrap this round a <a>UUID</a> then it is treated as a
--   <i>timeuuid</i> type instead of <i>uuid</i> (if it was a plain
--   <a>UUID</a> type).
newtype TimeUUID
TimeUUID :: UUID -> TimeUUID
unTimeUUID :: TimeUUID -> UUID

-- | A helper for extracting the types from a metadata definition.
metadataTypes :: Metadata -> [CType]

-- | A type class for types that can be used in query arguments or column
--   values in returned results.
--   
--   To define your own newtypes for Cassandra data, you only need to
--   define <a>getCas</a>, <a>putCas</a> and <a>casType</a>, like this:
--   
--   <pre>
--   newtype UserId = UserId UUID deriving (Eq, Show)
--   
--   instance CasType UserId where
--       getCas = UserId &lt;$&gt; getCas
--       putCas (UserId i) = putCas i
--       casType (UserId i) = casType i
--   </pre>
--   
--   The same can be done more simply using the
--   <i>GeneralizedNewtypeDeriving</i> language extension, e.g.
--   
--   <pre>
--   {-# LANGUAGE GeneralizedNewtypeDeriving #-}
--   
--   ...
--   newtype UserId = UserId UUID deriving (Eq, Show, CasType)
--   </pre>
--   
--   If you have a more complex type you want to store as a Cassandra blob,
--   you could write an instance like this (assuming it's an instance of
--   the <i>cereal</i> package's <a>Serialize</a> class):
--   
--   <pre>
--   instance CasType User where
--       getCas = decode . unBlob &lt;$&gt; getCas
--       putCas = putCas . Blob . encode
--       casType _ = CBlob
--   </pre>
class CasType a where casNothing = error "casNothing impossible" casObliterate _ bs = Just bs
getCas :: CasType a => Get a
putCas :: CasType a => a -> Put
casType :: CasType a => a -> CType
casNothing :: CasType a => a
casObliterate :: CasType a => a -> ByteString -> Maybe ByteString

-- | A type class for a tuple of <a>CasType</a> instances, representing
--   either a list of arguments for a query, or the values in a row of
--   returned query results.
class CasValues v
encodeValues :: CasValues v => v -> [CType] -> Either CodingFailure [Maybe ByteString]
decodeValues :: CasValues v => [(CType, Maybe ByteString)] -> Either CodingFailure v

-- | A low-level function in case you need some rarely-used capabilities.
executeRaw :: (MonadCassandra m, CasValues i) => Query style any_i any_o -> i -> Consistency -> m (Result [Maybe ByteString])

-- | A low-level query result used with <a>executeRaw</a>.
data Result vs
Void :: Result vs
RowsResult :: Metadata -> [vs] -> Result vs
SetKeyspace :: Text -> Result vs
Prepared :: PreparedQueryID -> Metadata -> Result vs
SchemaChange :: Change -> Keyspace -> Table -> Result vs

-- | A fully qualified identification of a table that includes the
--   <a>Keyspace</a>.
data TableSpec
TableSpec :: Keyspace -> Table -> TableSpec

-- | Information about a table column.
data ColumnSpec
ColumnSpec :: TableSpec -> Text -> CType -> ColumnSpec

-- | The specification of a list of result set columns.
data Metadata
Metadata :: [ColumnSpec] -> Metadata

-- | Cassandra data types as used in metadata.
data CType
CCustom :: Text -> CType
CAscii :: CType
CBigint :: CType
CBlob :: CType
CBoolean :: CType
CCounter :: CType
CDecimal :: CType
CDouble :: CType
CFloat :: CType
CInt :: CType
CText :: CType
CTimestamp :: CType
CUuid :: CType
CVarint :: CType
CTimeuuid :: CType
CInet :: CType
CList :: CType -> CType
CMap :: CType -> CType -> CType
CSet :: CType -> CType
CMaybe :: CType -> CType

-- | The name of a Cassandra table (a.k.a. column family).
newtype Table
Table :: Text -> Table
newtype PreparedQueryID
PreparedQueryID :: ByteString -> PreparedQueryID
serverStats :: Pool -> IO [ServerStat]

-- | Exported stats for a server.
data ServerStat
ServerStat :: Server -> Int -> Bool -> ServerStat
statServer :: ServerStat -> Server
statSessionCount :: ServerStat -> Int
statAvailable :: ServerStat -> Bool
data PoolConfig
PoolConfig :: [Server] -> Keyspace -> Maybe Authentication -> NominalDiffTime -> NominalDiffTime -> NominalDiffTime -> NominalDiffTime -> NominalDiffTime -> Int -> PoolConfig
piServers :: PoolConfig -> [Server]
piKeyspace :: PoolConfig -> Keyspace
piAuth :: PoolConfig -> Maybe Authentication
piSessionCreateTimeout :: PoolConfig -> NominalDiffTime
piConnectionTimeout :: PoolConfig -> NominalDiffTime
piIoTimeout :: PoolConfig -> NominalDiffTime
piBackoffOnError :: PoolConfig -> NominalDiffTime
piMaxSessionIdleTime :: PoolConfig -> NominalDiffTime
piMaxSessions :: PoolConfig -> Int
instance [overlap ok] Typeable CassandraCommsError
instance [overlap ok] Typeable TimeUUID
instance [overlap ok] Typeable CassandraException
instance [overlap ok] Show ServerState
instance [overlap ok] Eq ServerState
instance [overlap ok] Show ServerStat
instance [overlap ok] Show Flag
instance [overlap ok] Eq Opcode
instance [overlap ok] Show Opcode
instance [overlap ok] Show a => Show (Frame a)
instance [overlap ok] Eq a => Eq (Long a)
instance [overlap ok] Ord a => Ord (Long a)
instance [overlap ok] Show a => Show (Long a)
instance [overlap ok] Read a => Read (Long a)
instance [overlap ok] Eq a => Eq (Short a)
instance [overlap ok] Ord a => Ord (Short a)
instance [overlap ok] Show a => Show (Short a)
instance [overlap ok] Read a => Read (Short a)
instance [overlap ok] Eq TransportDirection
instance [overlap ok] Show TransportDirection
instance [overlap ok] Show CassandraCommsError
instance [overlap ok] Eq Keyspace
instance [overlap ok] Ord Keyspace
instance [overlap ok] Show Keyspace
instance [overlap ok] IsString Keyspace
instance [overlap ok] ProtoElt Keyspace
instance [overlap ok] Eq Table
instance [overlap ok] Ord Table
instance [overlap ok] Show Table
instance [overlap ok] IsString Table
instance [overlap ok] ProtoElt Table
instance [overlap ok] Eq TableSpec
instance [overlap ok] Ord TableSpec
instance [overlap ok] Show TableSpec
instance [overlap ok] Eq CType
instance [overlap ok] Show ColumnSpec
instance [overlap ok] Show Metadata
instance [overlap ok] Eq Blob
instance [overlap ok] Ord Blob
instance [overlap ok] Show Blob
instance [overlap ok] Eq Counter
instance [overlap ok] Ord Counter
instance [overlap ok] Show Counter
instance [overlap ok] Read Counter
instance [overlap ok] Eq TimeUUID
instance [overlap ok] Data TimeUUID
instance [overlap ok] Ord TimeUUID
instance [overlap ok] Read TimeUUID
instance [overlap ok] Show TimeUUID
instance [overlap ok] Eq PreparedQueryID
instance [overlap ok] Ord PreparedQueryID
instance [overlap ok] Show PreparedQueryID
instance [overlap ok] ProtoElt PreparedQueryID
instance [overlap ok] Eq QueryID
instance [overlap ok] Ord QueryID
instance [overlap ok] Show QueryID
instance [overlap ok] Show (Query $a $b $c)
instance [overlap ok] Show PreparedQuery
instance [overlap ok] Eq Change
instance [overlap ok] Ord Change
instance [overlap ok] Show Change
instance [overlap ok] Show vs => Show (Result vs)
instance [overlap ok] Eq Consistency
instance [overlap ok] Ord Consistency
instance [overlap ok] Show Consistency
instance [overlap ok] Bounded Consistency
instance [overlap ok] Enum Consistency
instance [overlap ok] Show CassandraException
instance [overlap ok] Functor Cas
instance [overlap ok] Applicative Cas
instance [overlap ok] Monad Cas
instance [overlap ok] MonadIO Cas
instance [overlap ok] MonadCatchIO Cas
instance [overlap ok] MonadCassandra Cas
instance [overlap ok] ProtoElt Consistency
instance [overlap ok] (CasType a, CasType b, CasType c, CasType d, CasType e, CasType f, CasType g, CasType h, CasType i, CasType j, CasType k, CasType l, CasType m, CasType n, CasType o, CasType p, CasType q, CasType r, CasType s, CasType t) => CasValues (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t)
instance [overlap ok] (CasType a, CasType b, CasType c, CasType d, CasType e, CasType f, CasType g, CasType h, CasType i, CasType j, CasType k, CasType l, CasType m, CasType n, CasType o, CasType p, CasType q, CasType r, CasType s) => CasValues (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s)
instance [overlap ok] (CasType a, CasType b, CasType c, CasType d, CasType e, CasType f, CasType g, CasType h, CasType i, CasType j, CasType k, CasType l, CasType m, CasType n, CasType o, CasType p, CasType q, CasType r) => CasValues (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r)
instance [overlap ok] (CasType a, CasType b, CasType c, CasType d, CasType e, CasType f, CasType g, CasType h, CasType i, CasType j, CasType k, CasType l, CasType m, CasType n, CasType o, CasType p, CasType q) => CasValues (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q)
instance [overlap ok] (CasType a, CasType b, CasType c, CasType d, CasType e, CasType f, CasType g, CasType h, CasType i, CasType j, CasType k, CasType l, CasType m, CasType n, CasType o, CasType p) => CasValues (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)
instance [overlap ok] (CasType a, CasType b, CasType c, CasType d, CasType e, CasType f, CasType g, CasType h, CasType i, CasType j, CasType k, CasType l, CasType m, CasType n, CasType o) => CasValues (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)
instance [overlap ok] (CasType a, CasType b, CasType c, CasType d, CasType e, CasType f, CasType g, CasType h, CasType i, CasType j, CasType k, CasType l, CasType m, CasType n) => CasValues (a, b, c, d, e, f, g, h, i, j, k, l, m, n)
instance [overlap ok] (CasType a, CasType b, CasType c, CasType d, CasType e, CasType f, CasType g, CasType h, CasType i, CasType j, CasType k, CasType l, CasType m) => CasValues (a, b, c, d, e, f, g, h, i, j, k, l, m)
instance [overlap ok] (CasType a, CasType b, CasType c, CasType d, CasType e, CasType f, CasType g, CasType h, CasType i, CasType j, CasType k, CasType l) => CasValues (a, b, c, d, e, f, g, h, i, j, k, l)
instance [overlap ok] (CasType a, CasType b, CasType c, CasType d, CasType e, CasType f, CasType g, CasType h, CasType i, CasType j, CasType k) => CasValues (a, b, c, d, e, f, g, h, i, j, k)
instance [overlap ok] (CasType a, CasType b, CasType c, CasType d, CasType e, CasType f, CasType g, CasType h, CasType i, CasType j) => CasValues (a, b, c, d, e, f, g, h, i, j)
instance [overlap ok] (CasType a, CasType b, CasType c, CasType d, CasType e, CasType f, CasType g, CasType h, CasType i) => CasValues (a, b, c, d, e, f, g, h, i)
instance [overlap ok] (CasType a, CasType b, CasType c, CasType d, CasType e, CasType f, CasType g, CasType h) => CasValues (a, b, c, d, e, f, g, h)
instance [overlap ok] (CasType a, CasType b, CasType c, CasType d, CasType e, CasType f, CasType g) => CasValues (a, b, c, d, e, f, g)
instance [overlap ok] (CasType a, CasType b, CasType c, CasType d, CasType e, CasType f) => CasValues (a, b, c, d, e, f)
instance [overlap ok] (CasType a, CasType b, CasType c, CasType d, CasType e) => CasValues (a, b, c, d, e)
instance [overlap ok] (CasType a, CasType b, CasType c, CasType d) => CasValues (a, b, c, d)
instance [overlap ok] (CasType a, CasType b, CasType c) => CasValues (a, b, c)
instance [overlap ok] (CasType a, CasType b) => CasValues (a, b)
instance [overlap ok] CasType a => CasValues a
instance [overlap ok] CasValues ()
instance [overlap ok] (CasType a, CasNested rem) => CasNested (a, rem)
instance [overlap ok] CasNested ()
instance [overlap ok] Show CodingFailure
instance [overlap ok] ProtoElt (Result [Maybe ByteString])
instance [overlap ok] Functor Result
instance [overlap ok] ProtoElt Change
instance [overlap ok] IsString (Query style i o)
instance [overlap ok] ProtoElt Metadata
instance [overlap ok] ProtoElt CType
instance [overlap ok] (CasType a, Ord a, CasType b) => CasType (Map a b)
instance [overlap ok] (CasType a, Ord a) => CasType (Set a)
instance [overlap ok] CasType a => CasType [a]
instance [overlap ok] CasType SockAddr
instance [overlap ok] CasType TimeUUID
instance [overlap ok] CasType UUID
instance [overlap ok] CasType Text
instance [overlap ok] CasType Int
instance [overlap ok] CasType UTCTime
instance [overlap ok] CasType Float
instance [overlap ok] CasType Double
instance [overlap ok] CasType Decimal
instance [overlap ok] CasType Integer
instance [overlap ok] CasType Counter
instance [overlap ok] CasType Bool
instance [overlap ok] CasType Blob
instance [overlap ok] CasType Int64
instance [overlap ok] CasType ByteString
instance [overlap ok] CasType a => CasType (Maybe a)
instance [overlap ok] Show CType
instance [overlap ok] ProtoElt TableSpec
instance [overlap ok] Exception CassandraCommsError
instance [overlap ok] Exception CassandraException
instance [overlap ok] ProtoElt (Long ByteString)
instance [overlap ok] ProtoElt ByteString
instance [overlap ok] ProtoElt (Long Text)
instance [overlap ok] ProtoElt Text
instance [overlap ok] ProtoElt [(Text, Text)]
instance [overlap ok] ProtoElt (Map Text Text)
instance [overlap ok] Functor Short
instance [overlap ok] Functor Long
instance [overlap ok] Serialize Opcode
instance [overlap ok] (MonadCassandra m, Monoid w) => MonadCassandra (RWST r w s m)
instance [overlap ok] (MonadCassandra m, Monoid a) => MonadCassandra (WriterT a m)
instance [overlap ok] (MonadCassandra m, Error e) => MonadCassandra (ErrorT e m)
instance [overlap ok] MonadCassandra m => MonadCassandra (StateT a m)
instance [overlap ok] MonadCassandra m => MonadCassandra (ReaderT a m)
instance [overlap ok] Ord ServerState
