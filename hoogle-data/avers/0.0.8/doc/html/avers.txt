-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | empty
--   
@package avers
@version 0.0.8


-- | This module contains RethinkDB Expressions which are used to build
--   queries.
module Avers.Storage.Expressions

-- | The primary key in all our documents is the default "id".
primaryKeyField :: Text

-- | Expression which represents the primary key field.
primaryKeyFieldE :: Exp Text

-- | Expression which represents the value of a field inside of an Object.
objectFieldE :: IsDatum a => Text -> Exp Object -> Exp a

-- | True if the object field matches the given value.
objectFieldEqE :: ToDatum a => Text -> a -> Exp Object -> Exp Bool

-- | True if the object's primary key matches the given string.
primaryKeyEqE :: Text -> Exp Object -> Exp Bool

-- | Take the first item out of a sequence.
headE :: (IsSequence a, IsDatum r) => Exp a -> Exp r

module Avers.TH

-- | Generates both <a>ToJSON</a> and <a>FromJSON</a> instance declarations
--   for the given data type.
--   
--   This is a convienience function which is equivalent to calling both
--   <a>deriveToJSON</a> and <a>deriveFromJSON</a>.
deriveJSON :: Options -> Name -> Q [Dec]
deriveJSONOptions :: String -> Options
variantOptions :: String -> String -> String -> Options
defaultVariantOptions :: String -> Options
deriveEncoding :: Options -> Name -> Q [Dec]
deriveRecordEncoding :: Name -> String -> [(String, Q Exp)] -> Q [Dec]

-- | A type that can be converted from JSON, with the possibility of
--   failure.
--   
--   When writing an instance, use <tt>empty</tt>, <tt>mzero</tt>, or
--   <a>fail</a> to make a conversion fail, e.g. if an <a>Object</a> is
--   missing a required key, or the value is of the wrong type.
--   
--   An example type and instance:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance FromJSON Coord where
--     parseJSON (<a>Object</a> v) = Coord    <tt>&lt;$&gt;</tt>
--                            v <tt>.:</tt> "x" <tt>&lt;*&gt;</tt>
--                            v <tt>.:</tt> "y"
--   
--     -- A non-<a>Object</a> value is of the wrong type, so use <tt>mzero</tt> to fail.
--     parseJSON _          = <tt>mzero</tt>
--   </pre>
--   
--   Note the use of the <tt>OverloadedStrings</tt> language extension
--   which enables <tt>Text</tt> values to be written as string literals.
--   
--   Instead of manually writing your <a>FromJSON</a> instance, there are
--   three options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides template-haskell functions which
--   will derive an instance at compile-time. The generated instance is
--   optimized for your type so will probably be more efficient than the
--   following two options:</li>
--   <li><a>Data.Aeson.Generic</a> provides a generic <tt>fromJSON</tt>
--   function that parses to any type which is an instance of
--   <tt>Data</tt>.</li>
--   <li>If your compiler has support for the <tt>DeriveGeneric</tt> and
--   <tt>DefaultSignatures</tt> language extensions, <tt>parseJSON</tt>
--   will have a default generic implementation.</li>
--   </ul>
--   
--   To use this, simply add a <tt>deriving <a>Generic</a></tt> clause to
--   your datatype and declare a <tt>FromJSON</tt> instance for your
--   datatype without giving a definition for <tt>parseJSON</tt>.
--   
--   For example the previous example can be simplified to just:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving Generic
--   
--   instance FromJSON Coord
--   </pre>
--   
--   Note that, instead of using <tt>DefaultSignatures</tt>, it's also
--   possible to parameterize the generic decoding using
--   <a>genericParseJSON</a> applied to your encoding/decoding
--   <a>Options</a>:
--   
--   <pre>
--   instance FromJSON Coord where
--       parseJSON = <a>genericParseJSON</a> <a>defaultOptions</a>
--   </pre>
class FromJSON a
parseJSON :: FromJSON a => Value -> Parser a

-- | A type that can be converted to JSON.
--   
--   An example type and instance:
--   
--   @{-# LANGUAGE OverloadedStrings #-}
--   
--   data Coord = Coord { x :: Double, y :: Double }
--   
--   instance ToJSON Coord where toJSON (Coord x y) = <a>object</a> ["x"
--   <tt>.=</tt> x, "y" <tt>.=</tt> y] @
--   
--   Note the use of the <tt>OverloadedStrings</tt> language extension
--   which enables <tt>Text</tt> values to be written as string literals.
--   
--   Instead of manually writing your <a>ToJSON</a> instance, there are
--   three options to do it automatically:
--   
--   <ul>
--   <li><a>Data.Aeson.TH</a> provides template-haskell functions which
--   will derive an instance at compile-time. The generated instance is
--   optimized for your type so will probably be more efficient than the
--   following two options:</li>
--   <li><a>Data.Aeson.Generic</a> provides a generic <tt>toJSON</tt>
--   function that accepts any type which is an instance of
--   <tt>Data</tt>.</li>
--   <li>If your compiler has support for the <tt>DeriveGeneric</tt> and
--   <tt>DefaultSignatures</tt> language extensions (GHC 7.2 and newer),
--   <tt>toJSON</tt> will have a default generic implementation.</li>
--   </ul>
--   
--   To use the latter option, simply add a <tt>deriving
--   <a>Generic</a></tt> clause to your datatype and declare a
--   <tt>ToJSON</tt> instance for your datatype without giving a definition
--   for <tt>toJSON</tt>.
--   
--   For example the previous example can be simplified to just:
--   
--   @{-# LANGUAGE DeriveGeneric #-}
--   
--   import GHC.Generics
--   
--   data Coord = Coord { x :: Double, y :: Double } deriving Generic
--   
--   instance ToJSON Coord @
--   
--   Note that, instead of using <tt>DefaultSignatures</tt>, it's also
--   possible to parameterize the generic encoding using
--   <a>genericToJSON</a> applied to your encoding/decoding <a>Options</a>:
--   
--   <pre>
--   instance ToJSON Coord where
--       toJSON = <a>genericToJSON</a> <a>defaultOptions</a>
--   </pre>
class ToJSON a
toJSON :: ToJSON a => a -> Value

module Avers.Metrics.TH
toLabels :: [String] -> [[String]]
toMetrics :: [[String]] -> [[String]]
mkMeasurements :: Q [Dec]

module Avers.Metrics.Measurements
data Measurement
M_avers_storage_lookupObject_duration :: Measurement
M_avers_storage_lookupSnapshot_duration :: Measurement
M_avers_storage_lookupLatestSnapshot_duration :: Measurement
M_avers_storage_newestSnapshot_duration :: Measurement
M_avers_storage_patchesAfterRevision_duration :: Measurement
M_avers_storage_lookupPatch_duration :: Measurement
M_avers_storage_applyObjectUpdates_duration :: Measurement
M_avers_storage_applyObjectUpdates_numOperations :: Measurement
M_avers_storage_applyObjectUpdates_numPreviousPatches :: Measurement
M_avers_storage_exists_duration :: Measurement
measurementLabels :: Measurement -> [[Char]]

module Avers.Index
data Index a
Index :: Text -> (Exp Object -> Exp a) -> Index a
indexName :: Index a -> Text
indexExpression :: Index a -> Exp Object -> Exp a
data SomeIndex
SomeIndex :: Index a -> SomeIndex

module Avers.Types

-- | Pk - Types which can be converted to a database primary key.
class Pk a
toPk :: Pk a => a -> Text

-- | Path
newtype Path
Path :: Text -> Path
unPath :: Path -> Text

-- | ObjId
newtype ObjId
ObjId :: Text -> ObjId
unObjId :: ObjId -> Text

-- | The root object id is used for object created internally or when there
--   is no applicable creator.
rootObjId :: ObjId

-- | RevId
newtype RevId
RevId :: Int -> RevId
unRevId :: RevId -> Int

-- | The <a>RevId</a> which is used for the initial snapshot.
zeroRevId :: RevId

-- | ObjectId
data ObjectId

-- | The base object whose snapshots contain the actual content.
BaseObjectId :: !ObjId -> ObjectId

-- | An object describing a particualar release of the base object.
ReleaseObjectId :: !ObjId -> !RevId -> ObjectId

-- | Object which contains authorization rules.
AuthorizationObjectId :: !ObjId -> ObjectId
objectIdParser :: Parser ObjectId
parseObjectId :: Text -> Maybe ObjectId
objectIdBase :: ObjectId -> ObjId

-- | The operations that can be applied to JSON values.
data Operation

-- | Set is applied to <a>Object</a>s. It is used for adding, updating and
--   deleting properties from the object.
Set :: !Path -> !(Maybe Value) -> Operation
opPath :: Operation -> !Path
opValue :: Operation -> !(Maybe Value)

-- | Splice is used to manipulate <tt>Array</tt>s. It can remove and insert
--   multiple elements in a single operation.
Splice :: !Path -> !Int -> !Int -> ![Value] -> Operation
opPath :: Operation -> !Path
opIndex :: Operation -> !Int
opRemove :: Operation -> !Int
opInsert :: Operation -> ![Value]
data PatchError
UnknownPatchError :: !Text -> PatchError
type PatchM a = Either PatchError a
data Object
Object :: !ObjId -> !Text -> !UTCTime -> !ObjId -> !(Maybe Bool) -> Object
objectId :: Object -> !ObjId
objectType :: Object -> !Text
objectCreatedAt :: Object -> !UTCTime
objectCreatedBy :: Object -> !ObjId
objectDeleted :: Object -> !(Maybe Bool)

-- | Patch
data Patch
Patch :: !ObjectId -> !RevId -> !ObjId -> !UTCTime -> !Operation -> Patch
patchObjectId :: Patch -> !ObjectId
patchRevisionId :: Patch -> !RevId
patchAuthorId :: Patch -> !ObjId
patchCreatedAt :: Patch -> !UTCTime
patchOperation :: Patch -> !Operation

-- | Snapshot
data Snapshot
Snapshot :: !ObjectId -> !RevId -> !Value -> Snapshot
snapshotObjectId :: Snapshot -> !ObjectId
snapshotRevisionId :: Snapshot -> !RevId
snapshotContent :: Snapshot -> !Value

-- | Release
data Release
Release :: Release

-- | SecretId
newtype SecretId
SecretId :: Text -> SecretId
unSecretId :: SecretId -> Text

-- | Secret
--   
--   A <a>Secret</a> is a password (encrypted with scrypt) that is attached
--   to a <a>SecretId</a> (for example the <a>ObjId</a> of an account).
--   
--   It is up to you to ensure that <a>SecretId</a>s are unique. If you use
--   <a>ObjId</a>s then they by definition are.
data Secret
Secret :: !SecretId -> !Text -> Secret
secretId :: Secret -> !SecretId
secretValue :: Secret -> !Text

-- | BlobId
newtype BlobId
BlobId :: Text -> BlobId
unBlobId :: BlobId -> Text

-- | Blob
data Blob
Blob :: !BlobId -> !Int -> !Text -> Blob
blobId :: Blob -> !BlobId
blobSize :: Blob -> !Int
blobContentType :: Blob -> !Text

-- | SessionId
newtype SessionId
SessionId :: Text -> SessionId
unSessionId :: SessionId -> Text

-- | The session record that is stored in the database.
--   
--   A session is a unique identifier attached to a particular object. It
--   contains the creation date and when it was last accessed. If you need
--   to store additional data for a session, we recommend to use cookies.
data Session
Session :: !SessionId -> !ObjId -> !UTCTime -> !UTCTime -> Session
sessionId :: Session -> !SessionId
sessionObjId :: Session -> !ObjId
sessionCreatedAt :: Session -> !UTCTime
sessionLastAccessedAt :: Session -> !UTCTime
data AversError
InternalError :: !AversError -> AversError
DatabaseError :: !Text -> AversError
PatchError :: !PatchError -> AversError
ParseError :: !Value -> !Text -> AversError
UnknownObjectType :: !Text -> AversError
ObjectNotFound :: !ObjId -> AversError
DocumentNotFound :: !Text -> AversError
AversError :: !Text -> AversError
NotAuthorized :: AversError
internalError :: AversError -> Avers a
internal :: Avers a -> Avers a
databaseError :: Text -> Avers a
patchError :: PatchError -> Avers a
parseError :: MonadError AversError m => Value -> Text -> m a
documentNotFound :: Text -> Avers a
strErr :: String -> Avers a

-- | An <a>ObjectType</a> describes a particular type of object that is
--   managed by Avers.
data ObjectType a
ObjectType :: !Text -> Avers ObjId -> [SomeView a] -> ObjectType a

-- | The value of the <tt>type</tt> field of the <a>Object</a>.
otType :: ObjectType a -> !Text

-- | Action which generates a new id. This is so that object types can have
--   different strategies how to generate ids.
otId :: ObjectType a -> Avers ObjId
otViews :: ObjectType a -> [SomeView a]
data SomeObjectType
SomeObjectType :: ObjectType a -> SomeObjectType
parseValueAs :: FromJSON a => ObjectType a -> Value -> Either AversError a

-- | Configuration of the <a>Avers</a> monad.
data AversConfig
AversConfig :: !Text -> !Text -> (BlobId -> Text -> ByteString -> IO ()) -> ![SomeObjectType] -> (Measurement -> Double -> IO ()) -> AversConfig

-- | The hostname where RethinkDB is running. The port is currently not
--   configurable.
databaseHost :: AversConfig -> !Text

-- | RethinkDB supports multiple databases. This is the name of the one
--   which should be used.
databaseName :: AversConfig -> !Text

-- | Function which saves the given blob in the blob store. This can be the
--   local filesystem or an external services such as Amazon S3.
--   
--   TODO: Propagate errors back to the caller.
putBlob :: AversConfig -> BlobId -> Text -> ByteString -> IO ()

-- | All the object types which Avers knows about.
objectTypes :: AversConfig -> ![SomeObjectType]

-- | This is called when the internal instrumentation code creates a
--   measurement.
emitMeasurement :: AversConfig -> Measurement -> Double -> IO ()
data AversState
AversState :: !AversConfig -> !(Pool Handle) -> !(TVar (Map ObjectId RevId)) -> AversState

-- | A reference to the config, just in case we need it.
config :: AversState -> !AversConfig

-- | A pool of handles which are used to access the database.
databaseHandlePool :: AversState -> !(Pool Handle)

-- | Map from <a>ObjectId</a> to a recent <a>RevId</a>. It may be the
--   latest or a few revisions behind.
recentRevisionCache :: AversState -> !(TVar (Map ObjectId RevId))
newDatabaseHandlePool :: AversConfig -> IO (Pool Handle)
newState :: AversConfig -> IO AversState
newtype Avers a
Avers :: StateT AversState (ExceptT AversError IO) a -> Avers a
runAvers :: Avers a -> StateT AversState (ExceptT AversError IO) a
class Monad m => MonadAvers m
liftAvers :: MonadAvers m => Avers a -> m a
evalAvers :: AversState -> Avers a -> IO (Either AversError a)
data View obj a
View :: Text -> (Datum -> Either AversError a) -> (obj -> Avers (Maybe a)) -> [SomeIndex] -> View obj a

-- | The table name is derived from the view name. Therefore it should be
--   unique amongst all views.
viewName :: View obj a -> Text

-- | Function which parses objects stored in this view.
viewParser :: View obj a -> Datum -> Either AversError a

-- | Function which transforms an Avers Object into a type stored in the
--   view.
viewObjectTransformer :: View obj a -> obj -> Avers (Maybe a)

-- | Secondary indices defined on the view.
viewIndices :: View obj a -> [SomeIndex]
data SomeView obj
SomeView :: View obj a -> SomeView obj
instance Show AversError
instance Functor Avers
instance Applicative Avers
instance Monad Avers
instance MonadIO Avers
instance MonadError AversError Avers
instance MonadState AversState Avers
instance MonadAvers m => MonadAvers (StateT s m)
instance MonadAvers Avers
instance FromDatum Session
instance ToDatum Session
instance FromJSON Session
instance ToJSON Session
instance Pk Session
instance ToDatum SessionId
instance FromDatum SessionId
instance FromJSON SessionId
instance ToJSON SessionId
instance Pk SessionId
instance FromDatum Blob
instance ToDatum Blob
instance FromJSON Blob
instance ToJSON Blob
instance Show BlobId
instance Show Blob
instance Pk Blob
instance ToDatum BlobId
instance FromDatum BlobId
instance FromJSON BlobId
instance ToJSON BlobId
instance Pk BlobId
instance FromDatum Secret
instance ToDatum Secret
instance FromJSON Secret
instance ToJSON Secret
instance Show SecretId
instance Pk Secret
instance ToDatum SecretId
instance FromDatum SecretId
instance FromJSON SecretId
instance ToJSON SecretId
instance Pk SecretId
instance FromJSON Release
instance ToJSON Release
instance FromDatum Snapshot
instance ToDatum Snapshot
instance FromJSON Snapshot
instance ToJSON Snapshot
instance Show Snapshot
instance Pk Snapshot
instance FromDatum Patch
instance ToDatum Patch
instance FromJSON Patch
instance ToJSON Patch
instance Show Patch
instance Pk Patch
instance FromDatum Object
instance ToDatum Object
instance FromJSON Object
instance ToJSON Object
instance Show PatchError
instance Show Object
instance Pk Object
instance FromDatum Operation
instance ToDatum Operation
instance FromJSON Operation
instance ToJSON Operation
instance Eq Path
instance Ord Path
instance Show Path
instance Eq ObjId
instance Ord ObjId
instance Show ObjId
instance Eq RevId
instance Ord RevId
instance Show RevId
instance Eq ObjectId
instance Ord ObjectId
instance Show ObjectId
instance Eq Operation
instance Show Operation
instance ToDatum ObjectId
instance FromDatum ObjectId
instance FromJSON ObjectId
instance ToJSON ObjectId
instance Pk ObjectId
instance ToDatum RevId
instance FromDatum RevId
instance FromJSON RevId
instance ToJSON RevId
instance Pk RevId
instance Enum RevId
instance ToDatum ObjId
instance FromDatum ObjId
instance FromJSON ObjId
instance ToJSON ObjId
instance Pk ObjId
instance ToDatum Path
instance FromDatum Path
instance FromJSON Path
instance ToJSON Path
instance IsString Path
instance Pk Text

module Avers.Metrics
measureDuration :: Measurement -> Avers a -> Avers a
reportMeasurement :: Measurement -> Double -> Avers ()


-- | Low-level implementation of the storage backend.
module Avers.Storage.Backend
parseValue :: (FromJSON a, MonadError AversError m) => Value -> m a
parseDatum :: (FromDatum a, MonadError AversError m) => Datum -> m a
runQuery :: FromResponse (Result a) => Exp a -> Avers (Result a)
runQueryDatum :: FromDatum a => Exp Datum -> Avers a
runQuerySingleSelection :: FromDatum a => Exp SingleSelection -> Avers a
runQueryCollect :: (FromDatum a, IsSequence e, Result e ~ Sequence a) => Exp e -> Avers (Vector a)
existsDocument :: Pk k => Exp Table -> k -> Avers Bool
lookupDocument :: (Pk k, FromDatum a) => Exp Table -> k -> Avers (Maybe a)
insertDocument :: (ToDatum a, Pk a) => Exp Table -> a -> Avers ()
upsertDocument :: (ToDatum a, Pk a) => Exp Table -> a -> Avers ()
deleteDocument :: Pk k => Exp Table -> k -> Avers ()
instance FromDatum WriteResponse
instance ToDatum WriteResponse
instance Show WriteResponse

module Avers.Views
viewTableName :: View obj a -> Text

-- | Construct the table name for the given view. The table names look
--   something like this: "view_openGames"
viewTable :: View obj a -> Exp Table
data Record a
Record :: ObjId -> a -> Record a
recId :: Record a -> ObjId
recContent :: Record a -> a
updateObjectViews :: ObjectType a -> ObjId -> Maybe a -> Avers ()
updateView :: ToDatum a => View obj a -> ObjId -> Maybe obj -> Avers ()
instance ToDatum a => ToDatum (Record a)
instance ToJSON a => ToJSON (Record a)
instance Pk (Record a)

module Avers.Patching

-- | Apply the given op on the value. Can throw an exception if the
--   operation is invalid.
applyOperation :: Value -> Operation -> PatchM Value
opOT :: Value -> Operation -> Operation -> Maybe Operation

-- | Given an <a>Operation</a> which was created against a particular
--   <a>Value</a> (content), rebase it on top of patches which were created
--   against the very same content in parallel.
--   
--   This function assumes that the patches apply cleanly to the content.
--   Failure to do so results in a fatal error.
rebaseOperation :: Value -> Operation -> [Patch] -> Maybe Operation

-- | Resolve the path in the object.
resolvePathIn :: Path -> Value -> Maybe Value


-- | This module abstracts the storage engine and provides functions to
--   manipulate objects stored in it.
module Avers.Storage
requireResult :: AversError -> Maybe a -> Avers a
objectsTable :: Exp Table
blobsTable :: Exp Table
secretsTable :: Exp Table
patchesTable :: Exp Table
snapshotsTable :: Exp Table
sessionsTable :: Exp Table

-- | True if the object exists.
exists :: ObjId -> Avers Bool

-- | Lookup an <a>Object</a> by its <a>ObjId</a>. Throws
--   <a>ObjectNotFound</a> if the object doesn't exist.
lookupObject :: ObjId -> Avers Object

-- | Create a new object of the given type. An initial snapshot
--   (<a>RevId</a> 0) is created from the supplied content.
createObject :: ToJSON a => ObjectType a -> ObjId -> a -> Avers ObjId

-- | A more low-level version of <a>createObject</a>, for use when you want
--   to generate your own ObjId or create objects at a specific time.
createObject' :: ToJSON a => ObjId -> UTCTime -> ObjectType a -> ObjId -> a -> Avers ()

-- | Mark the object as deleted.
deleteObject :: ObjId -> Avers ()

-- | Prune the object from the database. This is only allowed if the object
--   is marked as deleted. Note that this is a very dangerous operation, it
--   can not be undone.
pruneObject :: ObjId -> Avers ()

-- | Fetch the content of the object and try to parse it.
--   
--   This function will fail with a <a>ParseError</a> if the content can
--   not be decoded into the desired type.
objectContent :: FromJSON a => ObjectId -> Avers a

-- | Get the snapshot of the newest revision of the given object.
lookupLatestSnapshot :: ObjectId -> Avers Snapshot
applyPatchToSnapshot :: Snapshot -> Patch -> Avers Snapshot
applyPatches :: Snapshot -> [Patch] -> Avers Snapshot
lookupRecentRevision :: ObjectId -> Avers (Maybe RevId)
updateRecentRevision :: ObjectId -> RevId -> Avers ()

-- | Get the newest snapshot which is stored in the database. The object
--   may be at a higher revision if the later snapshots are missing from
--   the database.
--   
--   This is an internal function. If you want the latest snapshot, you
--   should use <a>lookupLatestSnapshot</a>.
newestSnapshot :: ObjectId -> Avers Snapshot
lookupSnapshot :: ObjectId -> RevId -> Avers Snapshot
savePatch :: Patch -> Avers ()
saveSnapshot :: Snapshot -> Avers ()
updateSecret :: SecretId -> Text -> Avers ()

-- | Verify the value against the secret. If that fails, then this function
--   throws an error.
--   
--   This function automatically updates the secret in the database if the
--   scrypt params have changed.
verifySecret :: SecretId -> Text -> Avers ()

-- | Internal function which actually saves a secret in the database.
saveSecretValue :: SecretId -> EncryptedPass -> Avers ()
patchesAfterRevision :: ObjectId -> RevId -> Avers [Patch]
lookupPatch :: ObjectId -> RevId -> Avers Patch

-- | Lookup an object type which is registered in the Avers monad.
lookupObjectType :: Text -> Avers SomeObjectType
applyObjectUpdates :: ObjectId -> RevId -> ObjId -> [Operation] -> Bool -> Avers ([Patch], Int, [Patch])
data PatchState a
PatchState :: ObjectType a -> ObjectId -> RevId -> ObjId -> [Operation] -> Int -> Snapshot -> Snapshot -> [Patch] -> [Patch] -> PatchState a
psObjectType :: PatchState a -> ObjectType a
psObjectId :: PatchState a -> ObjectId
psRevisionId :: PatchState a -> RevId
psCommitterId :: PatchState a -> ObjId
psOperations :: PatchState a -> [Operation]
psNumConsumedOperations :: PatchState a -> Int
psBaseSnapshot :: PatchState a -> Snapshot
psLatestSnapshot :: PatchState a -> Snapshot
psPreviousPatches :: PatchState a -> [Patch]
psPatches :: PatchState a -> [Patch]
type AversPatch a b = StateT (PatchState a) Avers b
patchHandler :: FromJSON a => Bool -> AversPatch a Snapshot
existsBlob :: BlobId -> Avers Bool
lookupBlob :: BlobId -> Avers Blob
insertBlob :: Blob -> Avers ()
saveBlobContent :: Blob -> ByteString -> Avers ()
saveSession :: Session -> Avers ()
lookupSession :: SessionId -> Avers Session
dropSession :: SessionId -> Avers ()
newId :: Int -> IO Text
validateObject :: Text -> Value -> Avers ()
validateWithType :: FromJSON a => ObjectType a -> Value -> Avers ()
lookupRelease :: ObjId -> RevId -> Avers Release

-- | Create a new release of the given revision. If the object doesn't
--   exist, it will fail with <a>ObjectNotFound</a>.
createRelease :: ObjId -> RevId -> Avers ()
lookupLatestRelease :: ObjId -> Avers (Maybe RevId)
createBlob :: ByteString -> Text -> Avers Blob
objectsOfType :: ObjectType a -> Avers (Vector ObjId)
allObjectsOfType :: ObjectType a -> Avers (Vector ObjId)
isNotDeleted :: Exp Object -> Exp Bool
mapId :: Exp Object -> Exp Text

-- | Bootstrap the Avers handle: Create necessary tables, indexes, views
--   etc. This operation is idempotent.
indexF :: Exp Object -> Exp (Array Datum)
bootstrap :: Avers ()
createTable :: Text -> [SomeIndex] -> Avers ()

module Avers
data Avers a
evalAvers :: AversState -> Avers a -> IO (Either AversError a)

-- | Path
newtype Path
Path :: Text -> Path
unPath :: Path -> Text

-- | Pk - Types which can be converted to a database primary key.
class Pk a
toPk :: Pk a => a -> Text

-- | ObjId
newtype ObjId
ObjId :: Text -> ObjId
unObjId :: ObjId -> Text

-- | The root object id is used for object created internally or when there
--   is no applicable creator.
rootObjId :: ObjId

-- | RevId
newtype RevId
RevId :: Int -> RevId
unRevId :: RevId -> Int

-- | The <a>RevId</a> which is used for the initial snapshot.
zeroRevId :: RevId

-- | ObjectId
data ObjectId

-- | The base object whose snapshots contain the actual content.
BaseObjectId :: !ObjId -> ObjectId

-- | An object describing a particualar release of the base object.
ReleaseObjectId :: !ObjId -> !RevId -> ObjectId

-- | Object which contains authorization rules.
AuthorizationObjectId :: !ObjId -> ObjectId

-- | The operations that can be applied to JSON values.
data Operation

-- | Set is applied to <a>Object</a>s. It is used for adding, updating and
--   deleting properties from the object.
Set :: !Path -> !(Maybe Value) -> Operation
opPath :: Operation -> !Path
opValue :: Operation -> !(Maybe Value)

-- | Splice is used to manipulate <tt>Array</tt>s. It can remove and insert
--   multiple elements in a single operation.
Splice :: !Path -> !Int -> !Int -> ![Value] -> Operation
opPath :: Operation -> !Path
opIndex :: Operation -> !Int
opRemove :: Operation -> !Int
opInsert :: Operation -> ![Value]
data Object
Object :: !ObjId -> !Text -> !UTCTime -> !ObjId -> !(Maybe Bool) -> Object
objectId :: Object -> !ObjId
objectType :: Object -> !Text
objectCreatedAt :: Object -> !UTCTime
objectCreatedBy :: Object -> !ObjId
objectDeleted :: Object -> !(Maybe Bool)

-- | True if the object exists.
exists :: ObjId -> Avers Bool

-- | Create a new object of the given type. An initial snapshot
--   (<a>RevId</a> 0) is created from the supplied content.
createObject :: ToJSON a => ObjectType a -> ObjId -> a -> Avers ObjId

-- | A more low-level version of <a>createObject</a>, for use when you want
--   to generate your own ObjId or create objects at a specific time.
createObject' :: ToJSON a => ObjId -> UTCTime -> ObjectType a -> ObjId -> a -> Avers ()

-- | Lookup an <a>Object</a> by its <a>ObjId</a>. Throws
--   <a>ObjectNotFound</a> if the object doesn't exist.
lookupObject :: ObjId -> Avers Object

-- | Mark the object as deleted.
deleteObject :: ObjId -> Avers ()

-- | Prune the object from the database. This is only allowed if the object
--   is marked as deleted. Note that this is a very dangerous operation, it
--   can not be undone.
pruneObject :: ObjId -> Avers ()
objectsOfType :: ObjectType a -> Avers (Vector ObjId)
allObjectsOfType :: ObjectType a -> Avers (Vector ObjId)

-- | Patch
data Patch
Patch :: !ObjectId -> !RevId -> !ObjId -> !UTCTime -> !Operation -> Patch
patchObjectId :: Patch -> !ObjectId
patchRevisionId :: Patch -> !RevId
patchAuthorId :: Patch -> !ObjId
patchCreatedAt :: Patch -> !UTCTime
patchOperation :: Patch -> !Operation
data PatchError
UnknownPatchError :: !Text -> PatchError
lookupPatch :: ObjectId -> RevId -> Avers Patch

-- | Snapshot
data Snapshot
Snapshot :: !ObjectId -> !RevId -> !Value -> Snapshot
snapshotObjectId :: Snapshot -> !ObjectId
snapshotRevisionId :: Snapshot -> !RevId
snapshotContent :: Snapshot -> !Value

-- | Get the snapshot of the newest revision of the given object.
lookupLatestSnapshot :: ObjectId -> Avers Snapshot

-- | Fetch the content of the object and try to parse it.
--   
--   This function will fail with a <a>ParseError</a> if the content can
--   not be decoded into the desired type.
objectContent :: FromJSON a => ObjectId -> Avers a

-- | Release
data Release
Release :: Release
lookupRelease :: ObjId -> RevId -> Avers Release

-- | Create a new release of the given revision. If the object doesn't
--   exist, it will fail with <a>ObjectNotFound</a>.
createRelease :: ObjId -> RevId -> Avers ()
lookupLatestRelease :: ObjId -> Avers (Maybe RevId)

-- | Resolve the path in the object.
resolvePathIn :: Path -> Value -> Maybe Value

-- | SessionId
newtype SessionId
SessionId :: Text -> SessionId
unSessionId :: SessionId -> Text

-- | The session record that is stored in the database.
--   
--   A session is a unique identifier attached to a particular object. It
--   contains the creation date and when it was last accessed. If you need
--   to store additional data for a session, we recommend to use cookies.
data Session
Session :: !SessionId -> !ObjId -> !UTCTime -> !UTCTime -> Session
sessionId :: Session -> !SessionId
sessionObjId :: Session -> !ObjId
sessionCreatedAt :: Session -> !UTCTime
sessionLastAccessedAt :: Session -> !UTCTime
saveSession :: Session -> Avers ()
lookupSession :: SessionId -> Avers Session
dropSession :: SessionId -> Avers ()

-- | An <a>ObjectType</a> describes a particular type of object that is
--   managed by Avers.
data ObjectType a
ObjectType :: !Text -> Avers ObjId -> [SomeView a] -> ObjectType a

-- | The value of the <tt>type</tt> field of the <a>Object</a>.
otType :: ObjectType a -> !Text

-- | Action which generates a new id. This is so that object types can have
--   different strategies how to generate ids.
otId :: ObjectType a -> Avers ObjId
otViews :: ObjectType a -> [SomeView a]
data SomeObjectType
SomeObjectType :: ObjectType a -> SomeObjectType

-- | Lookup an object type which is registered in the Avers monad.
lookupObjectType :: Text -> Avers SomeObjectType
data AversError
InternalError :: !AversError -> AversError
DatabaseError :: !Text -> AversError
PatchError :: !PatchError -> AversError
ParseError :: !Value -> !Text -> AversError
UnknownObjectType :: !Text -> AversError
ObjectNotFound :: !ObjId -> AversError
DocumentNotFound :: !Text -> AversError
AversError :: !Text -> AversError
NotAuthorized :: AversError

-- | Configuration of the <a>Avers</a> monad.
data AversConfig
AversConfig :: !Text -> !Text -> (BlobId -> Text -> ByteString -> IO ()) -> ![SomeObjectType] -> (Measurement -> Double -> IO ()) -> AversConfig

-- | The hostname where RethinkDB is running. The port is currently not
--   configurable.
databaseHost :: AversConfig -> !Text

-- | RethinkDB supports multiple databases. This is the name of the one
--   which should be used.
databaseName :: AversConfig -> !Text

-- | Function which saves the given blob in the blob store. This can be the
--   local filesystem or an external services such as Amazon S3.
--   
--   TODO: Propagate errors back to the caller.
putBlob :: AversConfig -> BlobId -> Text -> ByteString -> IO ()

-- | All the object types which Avers knows about.
objectTypes :: AversConfig -> ![SomeObjectType]

-- | This is called when the internal instrumentation code creates a
--   measurement.
emitMeasurement :: AversConfig -> Measurement -> Double -> IO ()
data AversState
newState :: AversConfig -> IO AversState
strErr :: String -> Avers a
parseValueAs :: FromJSON a => ObjectType a -> Value -> Either AversError a
bootstrap :: Avers ()

-- | BlobId
newtype BlobId
BlobId :: Text -> BlobId
unBlobId :: BlobId -> Text

-- | Blob
data Blob
Blob :: !BlobId -> !Int -> !Text -> Blob
blobId :: Blob -> !BlobId
blobSize :: Blob -> !Int
blobContentType :: Blob -> !Text
createBlob :: ByteString -> Text -> Avers Blob
lookupBlob :: BlobId -> Avers Blob

-- | SecretId
newtype SecretId
SecretId :: Text -> SecretId
unSecretId :: SecretId -> Text

-- | Secret
--   
--   A <a>Secret</a> is a password (encrypted with scrypt) that is attached
--   to a <a>SecretId</a> (for example the <a>ObjId</a> of an account).
--   
--   It is up to you to ensure that <a>SecretId</a>s are unique. If you use
--   <a>ObjId</a>s then they by definition are.
data Secret
Secret :: !SecretId -> !Text -> Secret
secretId :: Secret -> !SecretId
secretValue :: Secret -> !Text
updateSecret :: SecretId -> Text -> Avers ()

-- | Verify the value against the secret. If that fails, then this function
--   throws an error.
--   
--   This function automatically updates the secret in the database if the
--   scrypt params have changed.
verifySecret :: SecretId -> Text -> Avers ()
applyObjectUpdates :: ObjectId -> RevId -> ObjId -> [Operation] -> Bool -> Avers ([Patch], Int, [Patch])
runQuery :: FromResponse (Result a) => Exp a -> Avers (Result a)
runQueryCollect :: (FromDatum a, IsSequence e, Result e ~ Sequence a) => Exp e -> Avers (Vector a)
parseValue :: (FromJSON a, MonadError AversError m) => Value -> m a
parseDatum :: (FromDatum a, MonadError AversError m) => Datum -> m a
newId :: Int -> IO Text
objectsTable :: Exp Table
blobsTable :: Exp Table
validateObject :: Text -> Value -> Avers ()
data View obj a
View :: Text -> (Datum -> Either AversError a) -> (obj -> Avers (Maybe a)) -> [SomeIndex] -> View obj a

-- | The table name is derived from the view name. Therefore it should be
--   unique amongst all views.
viewName :: View obj a -> Text

-- | Function which parses objects stored in this view.
viewParser :: View obj a -> Datum -> Either AversError a

-- | Function which transforms an Avers Object into a type stored in the
--   view.
viewObjectTransformer :: View obj a -> obj -> Avers (Maybe a)

-- | Secondary indices defined on the view.
viewIndices :: View obj a -> [SomeIndex]
data SomeView obj
SomeView :: View obj a -> SomeView obj

-- | Construct the table name for the given view. The table names look
--   something like this: "view_openGames"
viewTable :: View obj a -> Exp Table
updateView :: ToDatum a => View obj a -> ObjId -> Maybe obj -> Avers ()
data Index a
Index :: Text -> (Exp Object -> Exp a) -> Index a
indexName :: Index a -> Text
indexExpression :: Index a -> Exp Object -> Exp a
data SomeIndex
SomeIndex :: Index a -> SomeIndex
data Measurement
M_avers_storage_lookupObject_duration :: Measurement
M_avers_storage_lookupSnapshot_duration :: Measurement
M_avers_storage_lookupLatestSnapshot_duration :: Measurement
M_avers_storage_newestSnapshot_duration :: Measurement
M_avers_storage_patchesAfterRevision_duration :: Measurement
M_avers_storage_lookupPatch_duration :: Measurement
M_avers_storage_applyObjectUpdates_duration :: Measurement
M_avers_storage_applyObjectUpdates_numOperations :: Measurement
M_avers_storage_applyObjectUpdates_numPreviousPatches :: Measurement
M_avers_storage_exists_duration :: Measurement
measurementLabels :: Measurement -> [[Char]]
