-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Utility functions for the llvm interface
--   
--   The Low-Level Virtual-Machine is a compiler back-end with optimizer.
--   You may also call it a high-level portable assembler. This package
--   provides various utility functions for the Haskell interface to LLVM,
--   for example:
--   
--   <ul>
--   <li>arithmetic operations with better type inference than the
--   <tt>llvm</tt> interface in <a>LLVM.Extra.Arithmetic</a>,</li>
--   <li>a type class for loading and storing sets of values with one
--   command (macro) in <a>LLVM.Extra.Memory</a>,</li>
--   <li>support instance declarations of LLVM classes in
--   <a>LLVM.Extra.Class</a>,</li>
--   <li>handling of termination by a custom monad on top of
--   <tt>CodeGenFunction</tt> in <a>LLVM.Extra.MaybeContinuation</a></li>
--   <li>various kinds of loops (while) and condition structures
--   (if-then-else) in <a>LLVM.Extra.Control</a></li>
--   <li>automatic adaption to target specific extensions, currently used
--   for access of vector operations that are specific to an SSE level on
--   x86 processors in <a>LLVM.Extra.Extension</a> (On x86 architectures we
--   depend on the cpuid package that is needed for automatic detection of
--   available features.)</li>
--   <li>advanced vector operations such as sum of all vector elements,
--   cumulative sum, floor, non-negative fraction, absolute value in
--   <a>LLVM.Extra.Vector</a></li>
--   <li>type classes for handling scalar and vector operations in a
--   uniform way in <a>LLVM.Extra.ScalarOrVector</a></li>
--   <li>a Makefile and a description of how to run LLVM code from within
--   GHCi.</li>
--   </ul>
@package llvm-extra
@version 0.3

module LLVM.Extra.Extension

-- | This is an Applicative functor that registers, what extensions are
--   needed in order to run the contained instructions. You can escape from
--   the functor by calling <a>run</a> and providing a generic
--   implementation.
--   
--   We use an applicative functor since with a monadic interface we had to
--   create the specialised code in every case, in order to see which
--   extensions where used in the course of creating the instructions.
--   
--   We use only one (unparameterized) type for all extensions, since this
--   is the most simple solution. Alternatively we could use a type
--   parameter where class constraints show what extensions are needed.
--   This would be just like exceptions that are explicit in the type
--   signature as in the control-monad-exception package. However we would
--   still need to lift all basic LLVM instructions to the new monad.
data T a

-- | Analogous to <a>FunctionArgs</a>
--   
--   The type parameter <tt>r</tt> and its functional dependency are
--   necessary since <tt>g</tt> must be a function of the form <tt>a -&gt;
--   ... -&gt; c -&gt; CodeGenFunction r d</tt> and we must ensure that the
--   explicit <tt>r</tt> and the implicit <tt>r</tt> in the <tt>g</tt> do
--   match.
class CallArgs g r | g -> r
data Subtarget
Subtarget :: String -> String -> (forall r. CodeGenFunction r Bool) -> Subtarget

-- | Declare that a certain plain LLVM instruction depends on a particular
--   extension. This can be useful if you rely on the data layout of a
--   certain architecture when doing a bitcast, or if you know that LLVM
--   translates a certain generic operation to something especially optimal
--   for the declared extension.
wrap :: Subtarget -> a -> T a

-- | Create an intrinsic and register the needed extension. We cannot
--   immediately check whether the signature matches or whether the right
--   extension is given. However, when resolving intrinsics LLVM will not
--   find the intrinsic if the extension is wrong, and it also checks the
--   signature.
intrinsic :: (IsFunction f, CallArgs f g r, CallArgs g r) => Subtarget -> String -> T g
intrinsicAttr :: (IsFunction f, CallArgs f g r, CallArgs g r) => [Attribute] -> Subtarget -> String -> T g

-- | <tt>run generic specific</tt> generates the <tt>specific</tt> code if
--   the required extensions are available on the host processor and
--   <tt>generic</tt> otherwise.
run :: CodeGenFunction r a -> T (CodeGenFunction r a) -> CodeGenFunction r a

-- | Convenient variant of <a>run</a>: Only run the code with extended
--   instructions if an additional condition is given.
runWhen :: Bool -> CodeGenFunction r a -> T (CodeGenFunction r a) -> CodeGenFunction r a

-- | Only for debugging purposes.
runUnsafe :: T a -> a
with :: Functor f => f a -> (a -> b) -> f b
with2 :: Applicative f => f a -> f b -> (a -> b -> c) -> f c
with3 :: Applicative f => f a -> f b -> f c -> (a -> b -> c -> d) -> f d
instance Functor T
instance Applicative T
instance CallArgs (CodeGenFunction r (Value a)) r
instance CallArgs g r => CallArgs (Value a -> g) r

module LLVM.Extra.ExtensionCheck.X86
sse1 :: Subtarget
sse2 :: Subtarget
sse3 :: Subtarget
ssse3 :: Subtarget
sse41 :: Subtarget
sse42 :: Subtarget

module LLVM.Extra.Class
class Undefined a
undefTuple :: Undefined a => a
class Zero a
zeroTuple :: Zero a => a
zeroTuplePointed :: (Zero a, Applicative f) => f a
class Undefined llvmValue => MakeValueTuple haskellValue llvmValue | haskellValue -> llvmValue
valueTupleOf :: MakeValueTuple haskellValue llvmValue => haskellValue -> llvmValue
undefTuplePointed :: (Undefined a, Applicative f) => f a
valueTupleOfFunctor :: (MakeValueTuple h l, Functor f) => f h -> f l
phisTraversable :: (Phi a, Traversable f) => BasicBlock -> f a -> CodeGenFunction r (f a)
addPhisFoldable :: (Phi a, Foldable f, Applicative f) => BasicBlock -> f a -> f a -> CodeGenFunction r ()
instance (Pos n, IsPrimitive a, IsConst a) => MakeValueTuple (Vector n a) (Value (Vector n a))
instance MakeValueTuple (StablePtr a) (Value (StablePtr a))
instance IsType a => MakeValueTuple (Ptr a) (Value (Ptr a))
instance MakeValueTuple () ()
instance MakeValueTuple Word64 (Value Word64)
instance MakeValueTuple Word32 (Value Word32)
instance MakeValueTuple Word16 (Value Word16)
instance MakeValueTuple Word8 (Value Word8)
instance MakeValueTuple Int64 (Value Int64)
instance MakeValueTuple Int32 (Value Int32)
instance MakeValueTuple Int16 (Value Int16)
instance MakeValueTuple Int8 (Value Int8)
instance MakeValueTuple Bool (Value Bool)
instance MakeValueTuple Double (Value Double)
instance MakeValueTuple Float (Value Float)
instance (MakeValueTuple ah al, MakeValueTuple bh bl, MakeValueTuple ch cl) => MakeValueTuple (ah, bh, ch) (al, bl, cl)
instance (MakeValueTuple ah al, MakeValueTuple bh bl) => MakeValueTuple (ah, bh) (al, bl)
instance (Zero a, Zero b, Zero c) => Zero (a, b, c)
instance (Zero a, Zero b) => Zero (a, b)
instance IsFirstClass a => Zero (Value a)
instance Zero ()
instance (Undefined a, Undefined b, Undefined c) => Undefined (a, b, c)
instance (Undefined a, Undefined b) => Undefined (a, b)
instance IsFirstClass a => Undefined (Value a)
instance Undefined ()

module LLVM.Extra.Array
size :: Nat n => Value (Array n a) -> Int

-- | construct an array out of single elements
--   
--   You must assert that the length of the list matches the array size.
--   
--   This can be considered the inverse of <a>extractAll</a>.
assemble :: (Nat n, IsFirstClass a, IsSized a s) => [Value a] -> CodeGenFunction r (Value (Array n a))

-- | provide the elements of an array as a list of individual virtual
--   registers
--   
--   This can be considered the inverse of <a>assemble</a>.
extractAll :: (Nat n, IsFirstClass a, IsSized a s) => Value (Array n a) -> CodeGenFunction r [Value a]

-- | The loop is unrolled, since <a>insertvalue</a> and <a>extractvalue</a>
--   expect constant indices.
map :: (Nat n, IsFirstClass a, IsSized a asize, IsFirstClass b, IsSized b bsize) => (Value a -> CodeGenFunction r (Value b)) -> (Value (Array n a) -> CodeGenFunction r (Value (Array n b)))


-- | These functions work in arbitrary monads but are especially helpful
--   when working with the CodeGenFunction monad.
module LLVM.Extra.Monad
chain :: Monad m => [a -> m a] -> (a -> m a)
liftR2 :: Monad m => (a -> b -> m c) -> m a -> m b -> m c
liftR3 :: Monad m => (a -> b -> c -> m d) -> m a -> m b -> m c -> m d


-- | Useful control structures additionally to those in
--   <a>LLVM.Util.Loop</a>.
module LLVM.Extra.Control
arrayLoop :: (Phi a, IsType b, Num i, IsConst i, IsInteger i, IsFirstClass i, CmpRet i Bool) => Value i -> Value (Ptr b) -> a -> (Value (Ptr b) -> a -> CodeGenFunction r a) -> CodeGenFunction r a
arrayLoopWithExit :: (Phi s, IsType a, Num i, IsConst i, IsInteger i, IsFirstClass i, CmpRet i Bool) => Value i -> Value (Ptr a) -> s -> (Value (Ptr a) -> s -> CodeGenFunction r (Value Bool, s)) -> CodeGenFunction r (Value i, s)
arrayLoop2WithExit :: (Phi s, IsType a, IsType b, Num i, IsConst i, IsInteger i, IsFirstClass i, CmpRet i Bool) => Value i -> Value (Ptr a) -> Value (Ptr b) -> s -> (Value (Ptr a) -> Value (Ptr b) -> s -> CodeGenFunction r (Value Bool, s)) -> CodeGenFunction r (Value i, s)
fixedLengthLoop :: (Phi s, Num i, IsConst i, IsInteger i, IsFirstClass i, CmpRet i Bool) => Value i -> s -> (s -> CodeGenFunction r s) -> CodeGenFunction r s
whileLoop :: Phi a => a -> (a -> CodeGenFunction r (Value Bool)) -> (a -> CodeGenFunction r a) -> CodeGenFunction r a

-- | This is a variant of <a>whileLoop</a> that may be more convient,
--   because you only need one lambda expression for both loop condition
--   and loop body.
whileLoopShared :: Phi a => a -> (a -> (CodeGenFunction r (Value Bool), CodeGenFunction r a)) -> CodeGenFunction r a

-- | This construct starts new blocks, so be prepared when continueing
--   after an <a>ifThenElse</a>.
ifThenElse :: Phi a => Value Bool -> CodeGenFunction r a -> CodeGenFunction r a -> CodeGenFunction r a
ifThen :: Phi a => Value Bool -> a -> CodeGenFunction r a -> CodeGenFunction r a
class Phi a => Select a
select :: Select a => Value Bool -> a -> a -> CodeGenFunction r a
selectTraversable :: (Select a, Traversable f, Applicative f) => Value Bool -> f a -> f a -> CodeGenFunction r (f a)

-- | Branch-free variant of <a>ifThen</a> that is faster if the enclosed
--   block is very simply, say, if it contains at most two instructions. It
--   can only be used as alternative to <a>ifThen</a> if the enclosed block
--   is free of side effects.
ifThenSelect :: Select a => Value Bool -> a -> CodeGenFunction r a -> CodeGenFunction r a
instance (Select a, Select b, Select c) => Select (a, b, c)
instance (Select a, Select b) => Select (a, b)
instance Select ()
instance (IsFirstClass a, CmpRet a Bool) => Select (Value a)


-- | Some special operations on X86 processors. If you want to use them in
--   algorithm you will always have to prepare an alternative
--   implementation in terms of plain LLVM instructions. You will then run
--   them with <a>run</a> and this driver function then selects the most
--   advanced of both implementations. Functions that are written this way
--   can be found in <a>LLVM.Extra.Vector</a>. Availability of extensions
--   is checked with the <tt>CPUID</tt> instruction. However this does only
--   work if you compile code for the host machine, that is cross
--   compilation will fail! For cross compilation we would need access to
--   the SubTarget detection of LLVM that is only available in the C++
--   interface in version 2.6.
module LLVM.Extra.Extension.X86
maxss, minps, maxps, minss :: T (VFloat -> VFloat -> CodeGenFunction r VFloat)
maxsd, minpd, maxpd, minsd :: T (VDouble -> VDouble -> CodeGenFunction r VDouble)
cmpss :: T (FPPredicate -> VFloat -> VFloat -> CodeGenFunction r (Value (Vector D4 Int32)))
cmpps :: T (FPPredicate -> VFloat -> VFloat -> CodeGenFunction r (Value (Vector D4 Int32)))
cmpsd :: T (FPPredicate -> VDouble -> VDouble -> CodeGenFunction r (Value (Vector D2 Int64)))
cmppd :: T (FPPredicate -> VDouble -> VDouble -> CodeGenFunction r (Value (Vector D2 Int64)))
pcmpgtb :: T (Value (Vector D16 Int8) -> Value (Vector D16 Int8) -> CodeGenFunction r (Value (Vector D16 Int8)))
pcmpgtw :: T (Value (Vector D8 Int16) -> Value (Vector D8 Int16) -> CodeGenFunction r (Value (Vector D8 Int16)))
pcmpgtd :: T (Value (Vector D4 Int32) -> Value (Vector D4 Int32) -> CodeGenFunction r (Value (Vector D4 Int32)))
pcmpgtq :: T (Value (Vector D2 Int64) -> Value (Vector D2 Int64) -> CodeGenFunction r (Value (Vector D2 Int64)))
pcmpugtb :: T (Value (Vector D16 Word8) -> Value (Vector D16 Word8) -> CodeGenFunction r (Value (Vector D16 Word8)))
pcmpugtw :: T (Value (Vector D8 Word16) -> Value (Vector D8 Word16) -> CodeGenFunction r (Value (Vector D8 Word16)))
pcmpugtd :: T (Value (Vector D4 Word32) -> Value (Vector D4 Word32) -> CodeGenFunction r (Value (Vector D4 Word32)))
pcmpugtq :: T (Value (Vector D2 Word64) -> Value (Vector D2 Word64) -> CodeGenFunction r (Value (Vector D2 Word64)))
pminsb :: T (Value (Vector D16 Int8) -> Value (Vector D16 Int8) -> CodeGenFunction r (Value (Vector D16 Int8)))
pminsw :: T (Value (Vector D8 Int16) -> Value (Vector D8 Int16) -> CodeGenFunction r (Value (Vector D8 Int16)))
pminsd :: T (Value (Vector D4 Int32) -> Value (Vector D4 Int32) -> CodeGenFunction r (Value (Vector D4 Int32)))
pmaxsb :: T (Value (Vector D16 Int8) -> Value (Vector D16 Int8) -> CodeGenFunction r (Value (Vector D16 Int8)))
pmaxsw :: T (Value (Vector D8 Int16) -> Value (Vector D8 Int16) -> CodeGenFunction r (Value (Vector D8 Int16)))
pmaxsd :: T (Value (Vector D4 Int32) -> Value (Vector D4 Int32) -> CodeGenFunction r (Value (Vector D4 Int32)))
pminub :: T (Value (Vector D16 Word8) -> Value (Vector D16 Word8) -> CodeGenFunction r (Value (Vector D16 Word8)))
pminuw :: T (Value (Vector D8 Word16) -> Value (Vector D8 Word16) -> CodeGenFunction r (Value (Vector D8 Word16)))
pminud :: T (Value (Vector D4 Word32) -> Value (Vector D4 Word32) -> CodeGenFunction r (Value (Vector D4 Word32)))
pmaxub :: T (Value (Vector D16 Word8) -> Value (Vector D16 Word8) -> CodeGenFunction r (Value (Vector D16 Word8)))
pmaxuw :: T (Value (Vector D8 Word16) -> Value (Vector D8 Word16) -> CodeGenFunction r (Value (Vector D8 Word16)))
pmaxud :: T (Value (Vector D4 Word32) -> Value (Vector D4 Word32) -> CodeGenFunction r (Value (Vector D4 Word32)))
pabsb :: T (Value (Vector D16 Int8) -> CodeGenFunction r (Value (Vector D16 Int8)))
pabsw :: T (Value (Vector D8 Int16) -> CodeGenFunction r (Value (Vector D8 Int16)))
pabsd :: T (Value (Vector D4 Int32) -> CodeGenFunction r (Value (Vector D4 Int32)))
pmuludq :: T (Value (Vector D4 Word32) -> Value (Vector D4 Word32) -> CodeGenFunction r (Value (Vector D2 Word64)))
pmulld :: T (Value (Vector D4 Word32) -> Value (Vector D4 Word32) -> CodeGenFunction r (Value (Vector D4 Word32)))
cvtps2dq :: T (VFloat -> CodeGenFunction r (Value (Vector D4 Int32)))

-- | the upper two integers are set to zero, there is no instruction that
--   converts to Int64
cvtpd2dq :: T (VDouble -> CodeGenFunction r (Value (Vector D4 Int32)))

-- | MXCSR is not really supported by LLVM-2.6. LLVM does not know about
--   the dependency of all floating point operations on this status
--   register.
ldmxcsr :: T (Value (Ptr Word32) -> CodeGenFunction r ())
stmxcsr :: T (Value (Ptr Word32) -> CodeGenFunction r ())
withMXCSR :: Word32 -> T (CodeGenFunction r a -> CodeGenFunction r a)
haddps :: T (VFloat -> VFloat -> CodeGenFunction r VFloat)
haddpd :: T (VDouble -> VDouble -> CodeGenFunction r VDouble)
dpps :: T (VFloat -> VFloat -> Value Word32 -> CodeGenFunction r VFloat)
dppd :: T (VDouble -> VDouble -> Value Word32 -> CodeGenFunction r VDouble)
roundss, roundps :: T (VFloat -> Value Word32 -> CodeGenFunction r VFloat)
roundsd, roundpd :: T (VDouble -> Value Word32 -> CodeGenFunction r VDouble)
absss :: T (VFloat -> CodeGenFunction r VFloat)
abssd :: T (VDouble -> CodeGenFunction r VDouble)
absps :: T (VFloat -> CodeGenFunction r VFloat)
abspd :: T (VDouble -> CodeGenFunction r VDouble)

module LLVM.Extra.Vector
size :: Pos n => Value (Vector n a) -> Int
sizeInTuple :: ShuffleMatch n v => v -> Int

-- | Manually assemble a vector of equal values. Better use
--   ScalarOrVector.replicate.
replicate :: Access n a va => a -> CodeGenFunction r va
iterate :: Access n a va => (a -> CodeGenFunction r a) -> a -> CodeGenFunction r va

-- | construct a vector out of single elements
--   
--   You must assert that the length of the list matches the vector size.
--   
--   This can be considered the inverse of <a>extractAll</a>.
assemble :: Access n a va => [a] -> CodeGenFunction r va

-- | Manually implement vector shuffling using insertelement and
--   extractelement. In contrast to LLVM's built-in instruction it supports
--   distinct vector sizes, but it allows only one input vector (or a tuple
--   of vectors, but we cannot shuffle between them). For more complex
--   shuffling we recommend <a>extractAll</a> and <a>assemble</a>.
shuffle :: (Access m a ca, Access n a va) => va -> ConstValue (Vector m Word32) -> CodeGenFunction r ca

-- | Rotate one element towards the higher elements.
--   
--   I don't want to call it rotateLeft or rotateRight, because there is no
--   prefered layout for the vector elements. In Intel's instruction manual
--   vector elements are indexed like the bits, that is from right to left.
--   However, when working with Haskell list and enumeration syntax, the
--   start index is left.
rotateUp :: ShuffleMatch n v => v -> CodeGenFunction r v
rotateDown :: ShuffleMatch n v => v -> CodeGenFunction r v
reverse :: ShuffleMatch n v => v -> CodeGenFunction r v
shiftUp :: Access n a v => a -> v -> CodeGenFunction r (a, v)
shiftDown :: Access n a v => a -> v -> CodeGenFunction r (a, v)
shiftUpMultiZero :: (IsPrimitive a, Pos n) => Int -> Value (Vector n a) -> CodeGenFunction r (Value (Vector n a))
shiftDownMultiZero :: (IsPrimitive a, Pos n) => Int -> Value (Vector n a) -> CodeGenFunction r (Value (Vector n a))
class (Pos n, Phi v, Undefined v) => ShuffleMatch n v | v -> n
shuffleMatch :: ShuffleMatch n v => ConstValue (Vector n Word32) -> v -> CodeGenFunction r v
shuffleMatchTraversable :: (ShuffleMatch n v, Traversable f) => ConstValue (Vector n Word32) -> f v -> CodeGenFunction r (f v)

-- | Implement the <a>shuffleMatch</a> method using the methods of the
--   <a>Access</a> class.
shuffleMatchAccess :: Access n a v => ConstValue (Vector n Word32) -> v -> CodeGenFunction r v
shuffleMatchPlain1 :: (Pos n, IsPrimitive a) => Value (Vector n a) -> ConstValue (Vector n Word32) -> CodeGenFunction r (Value (Vector n a))
shuffleMatchPlain2 :: (Pos n, IsPrimitive a) => Value (Vector n a) -> Value (Vector n a) -> ConstValue (Vector n Word32) -> CodeGenFunction r (Value (Vector n a))

-- | Allow to work on records of vectors as if they are vectors of records.
--   This is a reasonable approach for records of different element types
--   since processor vectors can only be built from elements of the same
--   type. But also say for chunked stereo signal this makes sense. In this
--   case we would work on <tt>Stereo (Value a)</tt>.
class ShuffleMatch n v => Access n a v | v -> a n, a n -> v
insert :: Access n a v => Value Word32 -> a -> v -> CodeGenFunction r v
extract :: Access n a v => Value Word32 -> v -> CodeGenFunction r a
insertTraversable :: (Access n a v, Traversable f, Applicative f) => Value Word32 -> f a -> f v -> CodeGenFunction r (f v)
extractTraversable :: (Access n a v, Traversable f) => Value Word32 -> f v -> CodeGenFunction r (f a)

-- | provide the elements of a vector as a list of individual virtual
--   registers
--   
--   This can be considered the inverse of <a>assemble</a>.
extractAll :: Access n a v => v -> CodeGenFunction r [a]
insertChunk :: (Access m a ca, Access n a va) => Int -> ca -> va -> CodeGenFunction r va
modify :: Access n a va => Value Word32 -> (a -> CodeGenFunction r a) -> (va -> CodeGenFunction r va)

-- | Like LLVM.Util.Loop.mapVector but the loop is unrolled, which is
--   faster since it can be packed by the code generator.
map :: (Access n a va, Access n b vb) => (a -> CodeGenFunction r b) -> (va -> CodeGenFunction r vb)
mapChunks :: (Access m a ca, Access m b cb, Access n a va, Access n b vb) => (ca -> CodeGenFunction r cb) -> (va -> CodeGenFunction r vb)
zipChunksWith :: (Access m a ca, Access m b cb, Access m c cc, Access n a va, Access n b vb, Access n c vc) => (ca -> cb -> CodeGenFunction r cc) -> (va -> vb -> CodeGenFunction r vc)

-- | If the target vector type is a native type then the chop operation
--   produces no actual machine instruction. (nop) If the vector cannot be
--   evenly divided into chunks the last chunk will be padded with
--   undefined values.
chop :: (Access m a ca, Access n a va) => va -> [CodeGenFunction r ca]

-- | The target size is determined by the type. If the chunk list provides
--   more data, the exceeding data is dropped. If the chunk list provides
--   too few data, the target vector is filled with undefined elements.
concat :: (Access m a ca, Access n a va) => [ca] -> CodeGenFunction r va

-- | LLVM.select on boolean vectors cannot be translated to X86 code in
--   LLVM-2.6, thus I code my own version that calls select on all
--   elements. This is slow but works. When this issue is fixed, this
--   function will be replaced by LLVM.select.
select :: (IsFirstClass a, IsPrimitive a, Pos n, CmpRet a Bool) => Value (Vector n Bool) -> Value (Vector n a) -> Value (Vector n a) -> CodeGenFunction r (Value (Vector n a))
signedFraction :: (IsFloating a, IsConst a, Real a, Pos n) => Value (Vector n a) -> CodeGenFunction r (Value (Vector n a))

-- | Needs (log n) vector additions
cumulate1 :: (IsArithmetic a, IsPrimitive a, Pos n) => Value (Vector n a) -> CodeGenFunction r (Value (Vector n a))
umul32to64 :: Pos n => Value (Vector n Word32) -> Value (Vector n Word32) -> CodeGenFunction r (Value (Vector n Word64))

-- | The order of addition is chosen for maximum efficiency. We do not try
--   to prevent cancelations.
class (IsArithmetic a, IsPrimitive a) => Arithmetic a
sum :: (Arithmetic a, Pos n) => Value (Vector n a) -> CodeGenFunction r (Value a)
sumToPair :: (Arithmetic a, Pos n) => Value (Vector n a) -> CodeGenFunction r (Value a, Value a)
sumInterleavedToPair :: (Arithmetic a, Pos n) => Value (Vector n a) -> CodeGenFunction r (Value a, Value a)
cumulate :: (Arithmetic a, Pos n) => Value a -> Value (Vector n a) -> CodeGenFunction r (Value a, Value (Vector n a))
dotProduct :: (Arithmetic a, Pos n) => Value (Vector n a) -> Value (Vector n a) -> CodeGenFunction r (Value a)
mul :: (Arithmetic a, Pos n) => Value (Vector n a) -> Value (Vector n a) -> CodeGenFunction r (Value (Vector n a))

-- | Attention: The rounding and fraction functions only work for floating
--   point values with maximum magnitude of <tt>maxBound :: Int32</tt>.
--   This way we safe expensive handling of possibly seldom cases.
class (Arithmetic a, CmpRet a Bool, IsConst a) => Real a
min, max :: (Real a, Pos n) => Value (Vector n a) -> Value (Vector n a) -> CodeGenFunction r (Value (Vector n a))
abs :: (Real a, Pos n) => Value (Vector n a) -> CodeGenFunction r (Value (Vector n a))
truncate, fraction, floor :: (Real a, Pos n) => Value (Vector n a) -> CodeGenFunction r (Value (Vector n a))
instance Real Word64
instance Real Word32
instance Real Word16
instance Real Word8
instance Real Int64
instance Real Int32
instance Real Int16
instance Real Int8
instance Real Double
instance Real Float
instance Arithmetic Word32
instance Arithmetic Word64
instance Arithmetic Word16
instance Arithmetic Word8
instance Arithmetic Int64
instance Arithmetic Int32
instance Arithmetic Int16
instance Arithmetic Int8
instance Arithmetic Double
instance Arithmetic Float
instance (Access n a0 v0, Access n a1 v1, Access n a2 v2) => Access n (a0, a1, a2) (v0, v1, v2)
instance (ShuffleMatch n v0, ShuffleMatch n v1, ShuffleMatch n v2) => ShuffleMatch n (v0, v1, v2)
instance (Access n a0 v0, Access n a1 v1) => Access n (a0, a1) (v0, v1)
instance (ShuffleMatch n v0, ShuffleMatch n v1) => ShuffleMatch n (v0, v1)
instance (Pos n, IsPrimitive a) => Access n (Value a) (Value (Vector n a))
instance (Pos n, IsPrimitive a) => ShuffleMatch n (Value (Vector n a))


-- | Support for unified handling of scalars and vectors.
--   
--   Attention: The rounding and fraction functions only work for floating
--   point values with maximum magnitude of <tt>maxBound :: Int32</tt>.
--   This way we save expensive handling of possibly seldom cases.
module LLVM.Extra.ScalarOrVector
class (Real a, IsFloating a) => Fraction a
truncate :: Fraction a => Value a -> CodeGenFunction r (Value a)
fraction :: Fraction a => Value a -> CodeGenFunction r (Value a)

-- | The fraction has the same sign as the argument. This is not particular
--   useful but fast on IEEE implementations.
signedFraction :: Fraction a => Value a -> CodeGenFunction r (Value a)

-- | increment (first operand) may be negative, phase must always be
--   non-negative
addToPhase :: Fraction a => Value a -> Value a -> CodeGenFunction r (Value a)

-- | both increment and phase must be non-negative
incPhase :: Fraction a => Value a -> Value a -> CodeGenFunction r (Value a)
class Replicate scalar vector | vector -> scalar
replicate :: Replicate scalar vector => Value scalar -> CodeGenFunction r (Value vector)
replicateConst :: Replicate scalar vector => ConstValue scalar -> ConstValue vector
replicateOf :: (IsConst a, Replicate a v) => a -> Value v
class IsArithmetic a => Real a
min :: Real a => Value a -> Value a -> CodeGenFunction r (Value a)
max :: Real a => Value a -> Value a -> CodeGenFunction r (Value a)
abs :: Real a => Value a -> CodeGenFunction r (Value a)
class (Replicate a v, IsArithmetic a, IsArithmetic v) => PseudoModule a v
scale :: PseudoModule a v => Value a -> Value v -> CodeGenFunction r (Value v)
scaleConst :: PseudoModule a v => ConstValue a -> ConstValue v -> CodeGenFunction r (ConstValue v)
class IsConst a => IntegerConstant a
constFromInteger :: IntegerConstant a => Integer -> ConstValue a
class IntegerConstant a => RationalConstant a
constFromRational :: RationalConstant a => Rational -> ConstValue a
instance (RationalConstant a, IsPrimitive a, Pos n) => RationalConstant (Vector n a)
instance RationalConstant Double
instance RationalConstant Float
instance (IntegerConstant a, IsPrimitive a, Pos n) => IntegerConstant (Vector n a)
instance IntegerConstant Double
instance IntegerConstant Float
instance IntegerConstant Int64
instance IntegerConstant Int32
instance IntegerConstant Int16
instance IntegerConstant Int8
instance IntegerConstant Word64
instance IntegerConstant Word32
instance IntegerConstant Word16
instance IntegerConstant Word8
instance (IsArithmetic a, IsPrimitive a, Pos n) => PseudoModule a (Vector n a)
instance PseudoModule Double Double
instance PseudoModule Float Float
instance PseudoModule Int64 Int64
instance PseudoModule Int32 Int32
instance PseudoModule Int16 Int16
instance PseudoModule Int8 Int8
instance PseudoModule Word64 Word64
instance PseudoModule Word32 Word32
instance PseudoModule Word16 Word16
instance PseudoModule Word8 Word8
instance (Pos n, Real a) => Real (Vector n a)
instance Real Word64
instance Real Word32
instance Real Word16
instance Real Word8
instance Real Int64
instance Real Int32
instance Real Int16
instance Real Int8
instance Real FP128
instance Real Double
instance Real Float
instance (Pos n, IsPrimitive a) => Replicate a (Vector n a)
instance Replicate Word64 Word64
instance Replicate Word32 Word32
instance Replicate Word16 Word16
instance Replicate Word8 Word8
instance Replicate Int64 Int64
instance Replicate Int32 Int32
instance Replicate Int16 Int16
instance Replicate Int8 Int8
instance Replicate Bool Bool
instance Replicate FP128 FP128
instance Replicate Double Double
instance Replicate Float Float
instance (Pos n, Real a, IsFloating a, IsConst a) => Fraction (Vector n a)
instance Fraction Double
instance Fraction Float

module LLVM.Extra.Memory

-- | An implementation of both <a>MakeValueTuple</a> and <tt>Memory.C</tt>
--   must ensure that <tt>haskellValue</tt> is compatible with
--   <tt>llvmStruct</tt>. That is, writing and reading <tt>llvmStruct</tt>
--   by LLVM must be the same as accessing <tt>haskellValue</tt> by
--   <tt>Storable</tt> methods. ToDo: In future we may also require
--   Storable constraint for llvmStruct.
--   
--   We use a functional dependency in order to let type inference work
--   nicely.
class (Phi llvmValue, Undefined llvmValue, IsType llvmStruct) => C llvmValue llvmStruct | llvmValue -> llvmStruct
load :: C llvmValue llvmStruct => Value (Ptr llvmStruct) -> CodeGenFunction r llvmValue
store :: C llvmValue llvmStruct => llvmValue -> Value (Ptr llvmStruct) -> CodeGenFunction r ()
decompose :: C llvmValue llvmStruct => Value llvmStruct -> CodeGenFunction r llvmValue
compose :: C llvmValue llvmStruct => llvmValue -> CodeGenFunction r (Value llvmStruct)
modify :: C llvmValue llvmStruct => (llvmValue -> CodeGenFunction r llvmValue) -> Value (Ptr llvmStruct) -> CodeGenFunction r ()
castStorablePtr :: (MakeValueTuple haskellValue llvmValue, C llvmValue llvmStruct) => Ptr haskellValue -> Ptr llvmStruct
type Record r o v = Element r o v v
data Element r o v x
element :: (C x llvmStruct, GetValue o n llvmStruct, GetElementPtr o (n, ()) llvmStruct) => (v -> x) -> n -> Element r o v x
loadRecord :: Record r o llvmValue -> Value (Ptr o) -> CodeGenFunction r llvmValue
storeRecord :: Record r o llvmValue -> llvmValue -> Value (Ptr o) -> CodeGenFunction r ()
decomposeRecord :: Record r o llvmValue -> Value o -> CodeGenFunction r llvmValue
composeRecord :: IsType o => Record r o llvmValue -> llvmValue -> CodeGenFunction r (Value o)
loadNewtype :: C a o => (a -> llvmValue) -> Value (Ptr o) -> CodeGenFunction r llvmValue
storeNewtype :: C a o => (llvmValue -> a) -> llvmValue -> Value (Ptr o) -> CodeGenFunction r ()
decomposeNewtype :: C a o => (a -> llvmValue) -> Value o -> CodeGenFunction r llvmValue
composeNewtype :: C a o => (llvmValue -> a) -> llvmValue -> CodeGenFunction r (Value o)
class (IsFirstClass llvmType, IsType llvmStruct) => FirstClass llvmType llvmStruct | llvmType -> llvmStruct
instance C () (Struct ())
instance FirstClass a am => C (Value a) am
instance (IsType (Struct s), IsType (Struct sm)) => ConvertStruct s sm i () ()
instance (GetValue (Struct s) i a, GetValue (Struct sm) i am, FirstClass a am, ConvertStruct s sm i' rem remm, Succ i i') => ConvertStruct s sm i (a, rem) (am, remm)
instance (IsFirstClass (Struct s), IsType (Struct sm), ConvertStruct s sm D0 s sm) => FirstClass (Struct s) (Struct sm)
instance FirstClass (StablePtr a) (StablePtr a)
instance IsType a => FirstClass (Ptr a) (Ptr a)
instance (Nat n, IsFirstClass am, FirstClass a am, IsSized a asize, IsSized am amsize) => FirstClass (Array n a) (Array n am)
instance (Pos n, IsPrimitive a, IsPrimitive am, FirstClass a am) => FirstClass (Vector n a) (Vector n am)
instance FirstClass Bool Word32
instance FirstClass Word64 Word64
instance FirstClass Word32 Word32
instance FirstClass Word16 Word16
instance FirstClass Word8 Word8
instance FirstClass Int64 Int64
instance FirstClass Int32 Int32
instance FirstClass Int16 Int16
instance FirstClass Int8 Int8
instance FirstClass Double Double
instance FirstClass Float Float
instance (C al as, C bl bs, C cl cs, IsSized as sas, IsSized bs sbs, IsSized cs scs) => C (al, bl, cl) (Struct (as, (bs, (cs, ()))))
instance (C al as, C bl bs, IsSized as sas, IsSized bs sbs) => C (al, bl) (Struct (as, (bs, ())))
instance Applicative (Element r o v)
instance Functor (Element r o v)

module LLVM.Extra.ForeignPtr
newInit :: FunPtr (Ptr a -> IO ()) -> FunPtr (IO (Ptr a)) -> IO (ForeignPtr a)
newParam :: (Storable b, MakeValueTuple b bl, C bl bp) => FunPtr (Ptr a -> IO ()) -> FunPtr (Ptr bp -> IO (Ptr a)) -> b -> IO (ForeignPtr a)

-- | Adding the finalizer to a ForeignPtr seems to be the only way that
--   warrants execution of the finalizer (not too early and not never).
--   However, the normal ForeignPtr finalizers must be independent from
--   Haskell runtime. In contrast to ForeignPtr finalizers, addFinalizer
--   adds finalizers to boxes, that are optimized away. Thus finalizers are
--   run too early or not at all. Concurrent.ForeignPtr and using threaded
--   execution is the only way to get finalizers in Haskell IO.
new :: Storable a => IO () -> a -> IO (ForeignPtr a)
with :: (Storable a, MakeValueTuple a al, C al ap) => ForeignPtr a -> (Ptr ap -> IO b) -> IO b

module LLVM.Extra.Arithmetic

-- | This and the following type classes are intended for arithmetic
--   operations on wrappers around LLVM types. E.g. you might define a
--   fixed point fraction type by
--   
--   <pre>
--   newtype Fixed = Fixed Int32
--   </pre>
--   
--   and then use the same methods for floating point and fixed point
--   arithmetic.
--   
--   In contrast to the arithmetic methods in the <tt>llvm</tt> wrapper, in
--   our methods the types of operands and result match. Advantage: Type
--   inference determines most of the types automatically. Disadvantage:
--   You cannot use constant values directly, but you have to convert them
--   all to <a>Value</a>.
class Additive a
zero :: Additive a => a
add :: Additive a => a -> a -> CodeGenFunction r a
sub :: Additive a => a -> a -> CodeGenFunction r a
neg :: Additive a => a -> CodeGenFunction r a
one :: IntegerConstant a => a
inc :: (IsArithmetic a, IsConst a, Num a) => Value a -> CodeGenFunction r (Value a)
dec :: (IsArithmetic a, IsConst a, Num a) => Value a -> CodeGenFunction r (Value a)
class Additive a => PseudoRing a
mul :: PseudoRing a => a -> a -> CodeGenFunction r a
square :: PseudoRing a => a -> CodeGenFunction r a
class (PseudoRing a, Additive v) => PseudoModule a v
scale :: PseudoModule a v => a -> v -> CodeGenFunction r v
class PseudoRing a => Field a
fdiv :: Field a => a -> a -> CodeGenFunction r a
class IntegerConstant a
fromInteger' :: IntegerConstant a => Integer -> a
class IntegerConstant a => RationalConstant a
fromRational' :: RationalConstant a => Rational -> a
idiv :: IsInteger a => Value a -> Value a -> CodeGenFunction r (Value a)
irem :: IsInteger a => Value a -> Value a -> CodeGenFunction r (Value a)
fcmp :: (IsFloating a, CmpRet a b) => FPPredicate -> Value a -> Value a -> CodeGenFunction r (Value b)
cmp :: CmpRet a b => CmpPredicate -> Value a -> Value a -> CodeGenFunction r (Value b)
and :: IsInteger a => Value a -> Value a -> CodeGenFunction r (Value a)
or :: IsInteger a => Value a -> Value a -> CodeGenFunction r (Value a)
class Additive a => Real a
min :: Real a => a -> a -> CodeGenFunction r a
max :: Real a => a -> a -> CodeGenFunction r a
abs :: Real a => a -> CodeGenFunction r a
class Real a => Fraction a
truncate :: Fraction a => a -> CodeGenFunction r a
fraction :: Fraction a => a -> CodeGenFunction r a
signedFraction :: Fraction a => a -> CodeGenFunction r a
addToPhase :: Fraction a => a -> a -> CodeGenFunction r a

-- | both increment and phase must be non-negative
incPhase :: Fraction a => a -> a -> CodeGenFunction r a
advanceArrayElementPtr :: Value (Ptr a) -> CodeGenFunction r (Value (Ptr a))
class Field a => Algebraic a
sqrt :: Algebraic a => a -> CodeGenFunction r a
class Algebraic a => Transcendental a
sin, log, exp, cos :: Transcendental a => a -> CodeGenFunction r a
pow :: Transcendental a => a -> a -> CodeGenFunction r a
instance IsFloating a => Transcendental (Value a)
instance IsFloating a => Algebraic (Value a)
instance Fraction a => Fraction (Value a)
instance Real a => Real (Value a)
instance RationalConstant a => RationalConstant (Value a)
instance RationalConstant a => RationalConstant (ConstValue a)
instance IsFloating v => Field (ConstValue v)
instance IsFloating v => Field (Value v)
instance IntegerConstant a => IntegerConstant (Value a)
instance IntegerConstant a => IntegerConstant (ConstValue a)
instance PseudoModule a v => PseudoModule (ConstValue a) (ConstValue v)
instance PseudoModule a v => PseudoModule (Value a) (Value v)
instance IsArithmetic v => PseudoRing (ConstValue v)
instance IsArithmetic v => PseudoRing (Value v)
instance (Additive a, Additive b, Additive c) => Additive (a, b, c)
instance (Additive a, Additive b) => Additive (a, b)
instance IsArithmetic a => Additive (ConstValue a)
instance IsArithmetic a => Additive (Value a)


-- | Maybe datatype implemented in continuation passing style.
module LLVM.Extra.MaybeContinuation

-- | Isomorphic to <tt>ReaderT (CodeGenFunction r z) (ContT z
--   (CodeGenFunction r)) a</tt>, where the reader provides the block for
--   <a>Nothing</a> and the continuation part manages the <a>Just</a>.
newtype T r z a
Cons :: (CodeGenFunction r z -> (a -> CodeGenFunction r z) -> CodeGenFunction r z) -> T r z a
resolve :: T r z a -> CodeGenFunction r z -> (a -> CodeGenFunction r z) -> CodeGenFunction r z
map :: (a -> CodeGenFunction r b) -> T r z a -> T r z b

-- | counterpart to Data.Maybe.HT.toMaybe
withBool :: Phi z => Value Bool -> CodeGenFunction r a -> T r z a
fromBool :: Phi z => CodeGenFunction r (Value Bool, a) -> T r z a
toBool :: Undefined a => T r (Value Bool, a) a -> CodeGenFunction r (Value Bool, a)
isJust :: T r (Value Bool) a -> CodeGenFunction r (Value Bool)
lift :: CodeGenFunction r a -> T r z a
guard :: Phi z => Value Bool -> T r z ()
bind :: T r z a -> (a -> T r z b) -> T r z b

-- | If the returned position is smaller than the array size, then returned
--   final state is undefined.
arrayLoop :: (Phi s, Undefined s, IsType a, Num i, IsConst i, IsInteger i, IsFirstClass i, CmpRet i Bool) => Value i -> Value (Ptr a) -> s -> (Value (Ptr a) -> s -> T r (Value Bool, s) s) -> CodeGenFunction r (Value i, s)
arrayLoop2 :: (Phi s, Undefined s, IsType a, IsType b, Num i, IsConst i, IsInteger i, IsFirstClass i, CmpRet i Bool) => Value i -> Value (Ptr a) -> Value (Ptr b) -> s -> (Value (Ptr a) -> Value (Ptr b) -> s -> T r (Value Bool, (Value (Ptr b), s)) s) -> CodeGenFunction r (Value i, s)
fixedLengthLoop :: (Phi s, Undefined s, Num i, IsConst i, IsInteger i, IsFirstClass i, CmpRet i Bool) => Value i -> s -> (s -> T r (Value Bool, (Value i, s)) s) -> CodeGenFunction r (Value i, s)
instance MonadIO (T r z)
instance Monad (T r z)
instance Applicative (T r z)
instance Functor (T r z)
