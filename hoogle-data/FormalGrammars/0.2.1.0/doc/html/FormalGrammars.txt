-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | (Context-free) grammars in formal language theory
--   
@package FormalGrammars
@version 0.2.1.0


-- | The data types that define a CFG.
module FormalLanguage.CFG.Grammar.Types
newtype IndexName
IndexName :: String -> IndexName
_getIndexName :: IndexName -> String
getIndexName :: Iso' IndexName String
data IOP
IPlus :: IOP
IMinus :: IOP
IEq :: IOP
INone :: IOP
ISymbol :: IOP

-- | Encode the index of the syntactic or terminal variable.
--   
--   In case of grammar-based indexing, keep <tt>indexRange</tt> empty. The
--   <tt>indexStep</tt> keeps track of any <tt>+k</tt> / <tt>-k</tt> given
--   in the production rules.
--   
--   We allow indexing terminals now, too. When glueing together terminals,
--   one might want to be able to differentiate between terminals.
data Index
Index :: IndexName -> Integer -> IOP -> [Integer] -> Integer -> Index
_indexName :: Index -> IndexName
_indexHere :: Index -> Integer
_indexOp :: Index -> IOP
_indexRange :: Index -> [Integer]
_indexStep :: Index -> Integer
indexStep :: Lens' Index Integer
indexRange :: Lens' Index [Integer]
indexOp :: Lens' Index IOP
indexName :: Lens' Index IndexName
indexHere :: Lens' Index Integer

-- | Newtype wrapper for symbol names.
newtype SymbolName
SymbolName :: String -> SymbolName
_getSteName :: SymbolName -> String
getSteName :: Iso' SymbolName String

-- | The tape, a terminal operates on. Terminals on different tapes could
--   still have the same <tt>SymbolName</tt> but different type and input!
newtype Tape
Tape :: Int -> Tape
_getTape :: Tape -> Int
getTape :: Iso' Tape Int

-- | Symbols, potentially with an index or more than one.
data SynTermEps

-- | Syntactic variables.
SynVar :: SymbolName -> [Index] -> Integer -> Integer -> SynTermEps
_name :: SynTermEps -> SymbolName
_index :: SynTermEps -> [Index]
_splitN :: SynTermEps -> Integer
_splitK :: SynTermEps -> Integer
SynTerm :: SymbolName -> [Index] -> SynTermEps
_name :: SynTermEps -> SymbolName
_index :: SynTermEps -> [Index]

-- | Regular old terminal symbol -- reads stuff from the input.
Term :: SymbolName -> [Index] -> SynTermEps
_name :: SynTermEps -> SymbolName
_index :: SynTermEps -> [Index]

-- | This sym denotes the case, where we have an <tt>Deletion</tt>
--   terminal, i.e. something is matched to nothing. This is actually just
--   a regular terminal symbol, we just treat it differently.
Deletion :: SynTermEps

-- | Finally, a real epsilon. Again, these are somewhat regular terminal
--   symbols, but it is important to be able to recognize these, when
--   trying to create outside variants of our algorithms.
Epsilon :: SynTermEps
splitN :: Traversal' SynTermEps Integer
splitK :: Traversal' SynTermEps Integer
name :: Traversal' SynTermEps SymbolName
index :: Traversal' SynTermEps [Index]
_Epsilon :: Prism' SynTermEps ()
_Deletion :: Prism' SynTermEps ()
_Term :: Prism' SynTermEps (SymbolName, [Index])
_SynTerm :: Prism' SynTermEps (SymbolName, [Index])
_SynVar :: Prism' SynTermEps (SymbolName, [Index], Integer, Integer)

-- | The length of the list encodes the dimension of the symbol. Forms a
--   monoid over dimensional concatenation.
newtype Symbol
Symbol :: [SynTermEps] -> Symbol
_getSymbolList :: Symbol -> [SynTermEps]
getSymbolList :: Iso' Symbol [SynTermEps]

-- | The name of an attribute function
newtype AttributeFunction
Attr :: String -> AttributeFunction
_getAttr :: AttributeFunction -> String
getAttr :: Iso' AttributeFunction String

-- | Production rules for at-most CFGs.
data Rule
Rule :: Symbol -> [AttributeFunction] -> [Symbol] -> Rule

-- | the left-hand side of the rule
_lhs :: Rule -> Symbol

-- | the attribute for this rule
_attr :: Rule -> [AttributeFunction]

-- | the right-hand side with a collection of terminals and syntactic
--   variables
_rhs :: Rule -> [Symbol]
rhs :: Lens' Rule [Symbol]
lhs :: Lens' Rule Symbol
attr :: Lens' Rule [AttributeFunction]
data DerivedGrammar
Inside :: DerivedGrammar
Outside :: String -> DerivedGrammar
isOutside :: DerivedGrammar -> Bool

-- | Complete descrition of a grammar. In principle it would be enough to
--   hold <tt>_rules</tt> and the <tt>_start</tt> symbol name. We also
--   store dimensionless names for syntactiv variables, and terminals. This
--   makes certain checks easier or possible.
--   
--   We store all single-tape symbol names dimensionless. This means that,
--   for terminals, symbols with the same name have the same tape. This is
--   slightly inconvenient for special applications (say Protein-DNA
--   alignment) but one can easily rename terminals.
--   
--   TODO better way to handle indexed symbols?
data Grammar
Grammar :: Map SymbolName SynTermEps -> Map SymbolName SynTermEps -> Map SymbolName SynTermEps -> DerivedGrammar -> Set Rule -> Symbol -> Map IndexName Index -> Map IndexName Index -> String -> Bool -> Grammar

-- | regular syntactic variables, without dimension
_synvars :: Grammar -> Map SymbolName SynTermEps

-- | Terminal synvars are somewhat weird. They are used in Outside
--   grammars, and hold previously calculated inside values.
_synterms :: Grammar -> Map SymbolName SynTermEps

-- | regular terminal symbols
_termvars :: Grammar -> Map SymbolName SynTermEps

-- | Is this an automatically derived outside grammar
_outside :: Grammar -> DerivedGrammar

-- | set of production rules
_rules :: Grammar -> Set Rule

-- | start symbol
_start :: Grammar -> Symbol

-- | any global variables
_params :: Grammar -> Map IndexName Index

-- | active indices
_indices :: Grammar -> Map IndexName Index

-- | grammar name
_grammarName :: Grammar -> String

-- | some grammar file requested this grammar to be expanded into code --
--   TODO remove, we have an emission queue
_write :: Grammar -> Bool
write :: Lens' Grammar Bool
termvars :: Lens' Grammar (Map SymbolName SynTermEps)
synvars :: Lens' Grammar (Map SymbolName SynTermEps)
synterms :: Lens' Grammar (Map SymbolName SynTermEps)
start :: Lens' Grammar Symbol
rules :: Lens' Grammar (Set Rule)
params :: Lens' Grammar (Map IndexName Index)
outside :: Lens' Grammar DerivedGrammar
indices :: Lens' Grammar (Map IndexName Index)
grammarName :: Lens' Grammar String
instance Typeable Grammar
instance Show Grammar
instance Data Grammar
instance Default Grammar
instance Typeable DerivedGrammar
instance Show DerivedGrammar
instance Eq DerivedGrammar
instance Data DerivedGrammar
instance Default DerivedGrammar
instance Typeable Rule
instance Show Rule
instance Eq Rule
instance Ord Rule
instance Data Rule
instance Typeable AttributeFunction
instance Show AttributeFunction
instance Eq AttributeFunction
instance Ord AttributeFunction
instance IsString AttributeFunction
instance Data AttributeFunction
instance Typeable Symbol
instance Show Symbol
instance Eq Symbol
instance Ord Symbol
instance Monoid Symbol
instance Semigroup Symbol
instance Data Symbol
instance Typeable SynTermEps
instance Show SynTermEps
instance Eq SynTermEps
instance Ord SynTermEps
instance Data SynTermEps
instance Typeable Tape
instance Show Tape
instance Eq Tape
instance Ord Tape
instance Enum Tape
instance Num Tape
instance Data Tape
instance Typeable SymbolName
instance Show SymbolName
instance Eq SymbolName
instance Ord SymbolName
instance IsString SymbolName
instance Data SymbolName
instance Typeable IOP
instance Typeable Index
instance Show IOP
instance Eq IOP
instance Ord IOP
instance Data IOP
instance Show Index
instance Eq Index
instance Ord Index
instance Data Index
instance Typeable IndexName
instance Show IndexName
instance Eq IndexName
instance Ord IndexName
instance IsString IndexName
instance Data IndexName


-- | Collection of small helper functions for grammars.
module FormalLanguage.CFG.Grammar.Util

-- | <tt>Term</tt>, <tt>Deletion</tt>, and <tt>Epsilon</tt> all count as
--   terminal symbols.
isTerminal :: Symbol -> Bool

-- | <tt>Term</tt>, and <tt>Epsilon</tt> are terminal symbols that can be
--   bound.
isBindableTerminal :: Symbol -> Bool

-- | Only <tt>SynVar</tt>s are non-terminal.
isSyntactic :: Symbol -> Bool

-- | special case of single-tape synvar in multi-tape setting
isSynStacked :: Symbol -> Bool

-- | true if we have a split synvar
isAllSplit :: Symbol -> Bool

-- | Set all <tt>splitK</tt> values to <tt>0</tt> for lookups.
splitK0 :: Symbol -> Symbol

-- | Take a split symbol and rewrite as full.
splitToFull :: Symbol -> Symbol

-- | Is this a syntactic terminal symbol?
isSynTerm :: Symbol -> Bool

-- | Epsilon-only symbols.
isEpsilon :: Symbol -> Bool

-- | Dimension of the grammar. Rather costly, because we check for
--   dimensional consistency.
dim :: Grammar -> Int

-- | Extract single-tape terminals together with their tape dimension.
uniqueTermsWithTape :: Grammar -> [(SynTermEps, Tape)]

-- | Extract single-tape bindable terminals together with their tape
--   dimension.
uniqueBindableTermsWithTape :: Grammar -> [(SynTermEps, Tape)]
uniqueSynVarsWithTape :: Grammar -> [(SynTermEps, Tape)]
uniqueSynTermsWithTape :: Grammar -> [(SynTermEps, Tape)]
uniqueSynTermEpsWithTape :: [Symbol] -> [(SynTermEps, Tape)]

-- | Return the nub list of terminal symbols. This includes
--   <tt>Deletion</tt> symbols, and might not be what you want. Check
--   <a>uniqueBindableTerminalSymbols</a> too!
uniqueTerminalSymbols :: Grammar -> [Symbol]
uniqueBindableTerminalSymbols :: Grammar -> [Symbol]

-- | Return the nub list of syntactic symbols.
uniqueSyntacticSymbols :: Grammar -> [Symbol]

-- | Return the nub list of syntactic terminals.
uniqueSynTermSymbols :: Grammar -> [Symbol]

-- | TODO Currently a stub (original is in <tt>.Grammar</tt> still. Want to
--   have it monadically, as the code is a mess.
normalizeStartEpsilon :: Grammar -> Grammar

-- | Left-linear grammars have at most one non-terminal on the RHS. It is
--   the first symbol.
isLeftLinear :: Grammar -> Bool


-- | The basic data types for formal languages up to and including
--   context-free grammars.
--   
--   TODO we shall have to extend the system for multi-tape grammars to
--   allow combined terminal/non-terminal systems. This will basically mean
--   dealing with context-sensitive grammars, at which we can just fully
--   generalize everything.
--   
--   TODO we need a general system to generate fresh variable names of
--   varying dimension. This is very much desired for certain operations
--   (especially on products).
--   
--   BIGTODO <tt>E _</tt> are actually the <a>None</a> thing in ADPfusion;
--   while normal epsilons are just terminals.
module FormalLanguage.CFG.Grammar


-- | This module provides the functionality for automatic calculation of
--   outside grammars from their inside progenitors.
--   
--   TODO If we already have an inside rule: <tt>S -&gt; A | B | C</tt>
--   with inside syntactic variable <tt>S</tt> whose sole purpose is to
--   collect results, than we don't need an extra symbol for Outside. What
--   happens if this is not the case?
module FormalLanguage.CFG.Outside

-- | Given an inside grammar, return <tt>Just</tt> an outside grammar,
--   otherwise return <tt>Nothing</tt>.
outsideFromInside :: Grammar -> Maybe Grammar

-- | Given a single inside rule, create the outside rules.
--   
--   TODO rules with only terminals on the RHS may need some consideration
--   (this INCLUDES epsilon rules!)
--   
--   TODO How do I know what an epsilon rule is? I might actually have to
--   say in the formal language... actually this might work. say <tt>e</tt>
--   is a free variable, but terminal: <tt>X -&gt; e</tt> has the epsilon
--   form <tt>X -&gt; e eps</tt> because there are only "non-epsilon" rhs
--   terminals -- we don't know yet that <tt>e</tt> is epsilon. This
--   generates the outside rule <tt>S -&gt; e X*</tt> which is what we
--   want, except for the superfluous <tt>e</tt> on the rhs. Because this
--   generates an algebra type that is incompatible with the inside
--   version, users should not do this. We are probably save, if all rules
--   FROM the start symbol are of the form <tt>S -&gt; A | B | C</tt> and
--   all terminal ending rules are of the form <tt>A -&gt; eps</tt> (i.e.
--   rewrite <tt>A -&gt; c</tt> to <tt>A -&gt; c E</tt> and have <tt>E
--   -&gt; eps</tt>.
genOutsideRules :: Rule -> [Rule]

-- | Helper function that turns an inside symbol into an outside symbol.
--   Simply by attaching a <tt>'</tt> (prime) symbol.
outsideSymb :: Symbol -> Symbol
genEpsilonRule :: [AttributeFunction] -> Symbol -> Rule
findStartSymbols :: Set Rule -> [Symbol]

-- | If necessary add a special "start" rule to the set of rules.
--   
--   Take a grammar and transform it into an outside grammar. If the given
--   grammar is already in outside form, the grammar is returned as is.
toOutside :: Grammar -> Grammar


-- | TODO grammar-level indices should be colored red! also, make grammar
--   globally available (reader monad)
module FormalLanguage.CFG.PrettyPrint.ANSI
genGrammarDoc :: Grammar -> Doc
grammarDoc :: Grammar -> Reader Grammar Doc
rulesDoc :: [Rule] -> Reader Grammar [Doc]
ruleDoc :: Rule -> Reader Grammar Doc
steDoc :: SynTermEps -> Reader Grammar Doc
indexDoc :: [Index] -> Reader Grammar Doc
symbolDoc :: Symbol -> Reader Grammar Doc
printDoc :: Doc -> IO ()


-- | We define a simple domain-specific language for context-free
--   languages.
--   
--   TODO we still need to make sure to handle NTs correctly. It should be
--   that we write <tt>[X,Y]</tt> in multidim cases and then we check in
--   rules if <tt>[X,Y]</tt> is available ... of course for
--   <tt>[X,eps]</tt> we then need to check if <tt>eps</tt> is an epsilon
--   symbol.
module FormalLanguage.CFG.Parser

-- | The environment captures both the current grammar we work with
--   (<tt>current</tt>) as well as everything we have parsed until now
--   (<tt>env</tt>).
data GrammarEnv
GrammarEnv :: Grammar -> Map String Grammar -> Seq Grammar -> Bool -> GrammarEnv

-- | The grammar declaration we currently evaluate
_current :: GrammarEnv -> Grammar

-- | grammars within the environment
_env :: GrammarEnv -> Map String Grammar

-- | sequence of grammars to emit (in order)
_emit :: GrammarEnv -> Seq Grammar

-- | emit lots of informative messages
_verbose :: GrammarEnv -> Bool
verbose :: Lens' GrammarEnv Bool
env :: Lens' GrammarEnv (Map String Grammar)
emit :: Lens' GrammarEnv (Seq Grammar)
current :: Lens' GrammarEnv Grammar
test :: MonadIO m => m (Maybe (Seq Grammar))
parse :: String -> Result (Seq Grammar)

-- | Parse everything in the grammar source. The additional argument,
--   normally <tt>empty :: Alternative f a</tt>, allows for providing
--   additional parsing capabilities -- e.g. for grammar products..
parseEverything :: Parse m () -> Parse m (Seq Grammar)

-- | The basic parser, which generates a grammar from a description.
parseGrammar :: Parse m ()

-- | Collect all indices and set them as active
setIndices :: Parse m [Index]

-- | Which of the intermediate grammar to actually emit as code or text in
--   TeX. Single line: <tt>Emit: KnownGrammarName</tt>
parseEmitGrammar :: Parse m ()

-- | Normalize start and epsilon rules in a known <tt>Source:</tt>, thereby
--   generating a new grammar.
parseNormStartEps :: Parse m ()

-- | Try to generate an outside grammar from an inside grammar. The
--   <tt>From:</tt> name is looked up in the environment.
--   
--   <pre>
--   Outside: NAME
--   From: (inside)NAME
--   //
--   </pre>
parseOutside :: Parse m ()

-- | Some additional commands that change the parsing state.
--   
--   TODO <tt>MonoidOfPairs</tt> should generate an adapter function that
--   turns any 2-tape eval function into its k-tape version. This means
--   collecting all name pairs, then emitting the corresponding adapter.
--   We'll also need a monoidal function for combining pairs. (this is
--   along the lines of sum-of-pairs).
parseCommands :: Parse m ()
fgIdents :: TokenParsing m => IdentifierStyle m
newGrammarName :: Parse m String
knownGrammarName :: Parse m Grammar

-- | Parses a syntactic (or non-terminal) symbol (for the corresponding
--   index type). Cf. <a>parseSynTermDecl</a>.
parseSyntacticDecl :: EvalReq -> Parse m SynTermEps

-- | Parses a syntactic terminal declaration; an inside syntactic variable
--   in an outside context.
parseSynTermDecl :: EvalReq -> Parse m SynTermEps
parseTermDecl :: Parse m SynTermEps

-- | The syntactic variable here needs to either have no index at all, have
--   a grammar-based index, or have a fully calculated index.
parseStartSym :: Parse m Symbol
data EvalReq

-- | Happens when we actually emit a grammar product (in development)
EvalFull :: EvalReq

-- | Happens when we work through the rules
EvalRule :: EvalReq

-- | Happens when we encounter <tt>N: </tt> and define a symbol
EvalSymb :: EvalReq

-- | Happens when we define grammar-global parameters
EvalGrammar :: EvalReq
knownSynVar :: EvalReq -> Stately m Symbol
knownSynTerm :: EvalReq -> Stately m Symbol

-- | Parses indices <tt>{ ... }</tt> within curly brackets
--   (<tt>braces</tt>).
--   
--   When parsing the <tt>EvalSymb</tt> case, indexed symbols are being
--   created.
--   
--   Parsing in rules is handled via <tt>EvalRule</tt> and actually
--   requires us saying which explicit index we use.
parseIndex :: EvalReq -> Stately m [Index]
knownTermVar :: EvalReq -> Stately m Symbol

-- | Parses an already known symbol, either syntactic or terminal.
--   
--   TODO Correctly parse inside-syntactics in outside grammars? Do we want
--   this explicitly?
knownSymbol :: EvalReq -> Stately m Symbol
parseRule :: Parse m [Rule]

-- | For split syntactic variables used in split manner (i.e. @S -&gt; X Y
--   X Y)
--   
--   TODO error control!
updateSplitCounts :: [Symbol] -> [Symbol]

-- | Once we have parsed a rule, we still need to extract all active
--   indices in the rule, and enumerate over them. This will finally
--   generate the set of rules we are interested in.
expandIndexed :: Rule -> Parse m [Rule]
type Parse m a = (TokenParsing m, MonadState GrammarEnv (Unlined m), MonadState GrammarEnv m, MonadPlus m) => m a
type Stately m a = (TokenParsing m, MonadState GrammarEnv m, MonadPlus m) => m a
newtype GrammarParser m a
GrammarParser :: StateT GrammarEnv m a -> GrammarParser m a
runGrammarParser :: GrammarParser m a -> StateT GrammarEnv m a

-- | The result of parsing. Either we succeeded or something went wrong.
data Result a :: * -> *
Success :: a -> Result a
Failure :: Doc -> Result a
instance MonadState GrammarEnv (Unlined (GrammarParser Parser))
instance (Functor m, MonadPlus m) => Alternative (GrammarParser m)
instance (Monad m, Functor m) => Applicative (GrammarParser m)
instance Functor m => Functor (GrammarParser m)
instance MonadPlus m => MonadPlus (GrammarParser m)
instance Monad m => Monad (GrammarParser m)
instance (MonadPlus m, CharParsing m) => CharParsing (GrammarParser m)
instance (MonadPlus m, Parsing m) => Parsing (GrammarParser m)
instance Monad m => MonadState GrammarEnv (GrammarParser m)
instance (MonadPlus m, CharParsing m) => TokenParsing (GrammarParser m)
instance Default GrammarEnv
instance Show GrammarEnv


-- | A PrettyPrinter that generates "almost useable" Haskell modules. The
--   signature and grammar are created but the algebras are (obviously)
--   missing.
module FormalLanguage.CFG.PrettyPrint.Haskell

-- | Render grammar
grammarHaskell :: Grammar -> Doc

module FormalLanguage.CFG.PrettyPrint.LaTeX

-- | Use this function to render a <a>LaTeX</a> (or another one in the
--   <a>Render</a> class) value directly in a file.
renderFile :: Render a => FilePath -> a -> IO ()
renderLaTeX :: Int -> Grammar -> LaTeX

module FormalLanguage.CFG.PrettyPrint


-- | Template Haskell system for translating formal grammars into real
--   Haskell code based on ADPfusion.
--   
--   If you want automatic algebra products, ADPfusion provides these.
--   <tt>makeAlgebraProductH ['h] ''SigName</tt> where <tt>SigName</tt> is
--   the auto-generted signature name, will generate the algebra product.
--   
--   When will build the grammar, the types and variables are
--   <tt>newName</tt>s while attribute functions names are deterministic
--   and potentially non-unique.
module FormalLanguage.CFG.TH

-- | Entry point for generation of <tt>Grammar</tt> and <tt>Signature</tt>
--   code. Will also stuff the <a>Grammar</a> into the state data. A bunch
--   of TH names are generated here and become part of the state, as they
--   are used in multiple places.
thCodeGen :: Int -> Grammar -> Q [Dec]
instance Default CfgState


-- | This QuasiQuoter turns the description of formal grammars into
--   ADPfusion-based code.
--   
--   TODO use Quote.quoteFile to be able to read files as well
module FormalLanguage.CFG.QQ
formalLangFile :: QuasiQuoter
formalLanguage :: QuasiQuoter
parseFormalLanguage :: GrammarParser Parser () -> String -> Q [Dec]
trim :: [Char] -> [Char]

-- | Determine the length of the unique prefix we need for algebra
--   functions.
uniquePrefixLength :: Seq Grammar -> Int

module FormalLanguage.CFG

module FormalLanguage
