-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Typesafe generation of haskell source code
--   
--   This library provides an interface to generate haskell source code,
--   verifying at compile time that the resulting code typechecks. See
--   https:/<i>github.com</i>bennofs/haskell-generate for an introduction
--   explaining how to use the library.
@package haskell-generate
@version 0.2.3

module Language.Haskell.Generate.Expression
newtype Expression t
Expression :: Exp -> Expression t
runExpression :: Expression t -> Exp
app :: Expression (a -> b) -> Expression a -> Expression b

module Language.Haskell.Generate.Monad

-- | This monad keeps track of a counter for generating unique names and
--   the set of modules that are needed for the expression.
newtype Generate a
Generate :: StateT Integer (Writer (Set ModuleName)) a -> Generate a
unGenerate :: Generate a -> StateT Integer (Writer (Set ModuleName)) a

-- | This is a type alias for a Generate action that returns an expression
--   of type <tt>t</tt>.
type ExpG t = Generate (Expression t)

-- | Extract the set of modules and the value from a Generate action.
runGenerate :: Generate a -> (a, Set ModuleName)

-- | Generate a new unique variable name with the given prefix. Note that
--   this new variable name is only unique relative to other variable names
--   generated by this function.
newName :: String -> Generate Name

-- | Use a haskell-src-exts Exp as the result of a Generate action.
returnE :: Exp -> ExpG t

-- | Import a function from a module. This function is polymorphic in the
--   type of the resulting expression, you should probably only use this
--   function to define type-restricted specializations.
--   
--   Example:
--   
--   <pre>
--   addInt :: ExpG (Int -&gt; Int -&gt; Int) -- Here we restricted the type to something sensible
--   addInt = useValue "Prelude" $ Symbol "+"
--   </pre>
useValue :: String -> Name -> ExpG a

-- | Import a value constructor from a module. Returns the qualified name
--   of the constructor.
useCon :: String -> Name -> Generate QName

-- | Use the value of a variable with the given name.
useVar :: Name -> ExpG t

-- | Generate a case expression.
caseE :: ExpG x -> [(Pat, ExpG t)] -> ExpG t

-- | Apply a function in a haskell expression to a value.
applyE :: ExpG (a -> b) -> ExpG a -> ExpG b

-- | ApplyE for 2 arguments
applyE2 :: ExpG (a -> b -> c) -> ExpG a -> ExpG b -> ExpG c

-- | Apply a function to 3 arguments
applyE3 :: ExpG (a -> b -> c -> d) -> ExpG a -> ExpG b -> ExpG c -> ExpG d

-- | Apply a function to 4 arguments
applyE4 :: ExpG (a -> b -> c -> d -> e) -> ExpG a -> ExpG b -> ExpG c -> ExpG d -> ExpG e

-- | Apply a function to 5 arguments
applyE5 :: ExpG (a -> b -> c -> d -> e -> f) -> ExpG a -> ExpG b -> ExpG c -> ExpG d -> ExpG e -> ExpG f

-- | Apply a function to 6 arguments
applyE6 :: ExpG (a -> b -> c -> d -> e -> f -> g) -> ExpG a -> ExpG b -> ExpG c -> ExpG d -> ExpG e -> ExpG f -> ExpG g

-- | Operator for <a>applyE</a>.
(<>$) :: ExpG (a -> b) -> ExpG a -> ExpG b

-- | Generate a expression from a haskell value. This can for example be
--   used to create lambdas:
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ generateExp $ expr (\x f -&gt; f &lt;&gt;$ x)
--   \ pvar_0 -&gt; \ pvar_1 -&gt; pvar_1 pvar_0
--   </pre>
--   
--   Or string literals:
--   
--   <pre>
--   &gt;&gt;&gt; putStrLn $ generateExp $ expr "I'm a string!"
--   ['I', '\'', 'm', ' ', 'a', ' ', 's', 't', 'r', 'i', 'n', 'g', '!']
--   </pre>
class GenExp t where type family GenExpType t :: *
expr :: GenExp t => t -> ExpG (GenExpType t)

-- | A module keeps track of the needed imports, but also has a list of
--   declarations in it.
newtype ModuleM a
ModuleM :: (Writer (Set ModuleName, [Decl]) a) -> ModuleM a

-- | This is the resulting type of a function generating a module. It is a
--   ModuleM action returning the export list.
type ModuleG = ModuleM (Maybe [ExportSpec])

-- | A reference to a function. With a reference to a function, you can
--   apply it (by lifting it into ExprT using <a>expr</a>) to some value or
--   export it using <a>exportFun</a>.
data FunRef t
FunRef :: Name -> FunRef t

-- | This type is used to represent variables, and also constructors.
data Name :: *

-- | <i>varid</i> or <i>conid</i>.
Ident :: String -> Name

-- | <i>varsym</i> or <i>consym</i>
Symbol :: String -> Name

-- | Generate a ExportSpec for a given function item.
exportFun :: FunRef t -> ExportSpec

-- | Add a declaration to the module. Return a reference to it that can be
--   used to either apply the function to some values or export it.
addDecl :: Name -> ExpG t -> ModuleM (FunRef t)

-- | Extract the Module from a module generator.
runModuleM :: ModuleG -> String -> Module

-- | Generate the source code for a module.
generateModule :: ModuleG -> String -> String

-- | Pretty print the expression generated by a given action.
generateExp :: ExpG t -> String
instance Functor Generate
instance Applicative Generate
instance Monad Generate
instance Functor ModuleM
instance Applicative ModuleM
instance Monad ModuleM
instance GenExp (FunRef t)
instance GenExp x => GenExp (ExpG a -> x)
instance GenExp a => GenExp [a]
instance GenExp Rational
instance GenExp Integer
instance GenExp Char
instance GenExp (Expression t)
instance GenExp (ExpG a)

module Language.Haskell.Generate.TH

-- | Declare a function. The name of the definition will be the name of the
--   function with an added apostrophe. (Example: declareFunction 'add
--   generates a definition with the name add').
declareFunction :: Name -> DecsQ

-- | Declare a symbol, using the given name for the definition.
declareNamedSymbol :: (Name, String) -> DecsQ

-- | Make a ExpG for the given function, using the given name for the
--   definition.
declareNamedFunction :: (Name, String) -> DecsQ

-- | Make a ExpG for some thing, using the given name for the definition.
--   The third tuple element specifies the constructor to use for
--   constructing the Name. This can either be <tt>'Symbol</tt> (for
--   symbols) or <tt>'Ident</tt> (for functions).
declareNamedThing :: (Name, String, Name) -> DecsQ

module Language.Haskell.Generate.PreludeDef
nothing' :: ExpG (Maybe a_a7tk)
true' :: ExpG Bool
false' :: ExpG Bool
right' :: ExpG (b_a9Cv -> Either a_a9Cu b_a9Cv)
left' :: ExpG (a_a9Cn -> Either a_a9Cn b_a9Co)
just' :: ExpG (a_a7tq -> Maybe a_a7tq)
readLn' :: Read a_afud => ExpG (IO a_afud)
readIO' :: Read a_afuc => ExpG (String -> IO a_afuc)
appendFile' :: ExpG (FilePath -> String -> IO ())
writeFile' :: ExpG (FilePath -> String -> IO ())
readFile' :: ExpG (FilePath -> IO String)
interact' :: ExpG ((String -> String) -> IO ())
getContents' :: ExpG (IO String)
getLine' :: ExpG (IO String)
getChar' :: ExpG (IO Char)
print' :: Show a_afsC => ExpG (a_afsC -> IO ())
putStrLn' :: ExpG (String -> IO ())
putStr' :: ExpG (String -> IO ())
putChar' :: ExpG (Char -> IO ())
show' :: Show a_aahm => ExpG (a_aahm -> String)
read' :: Read a_afh0 => ExpG (String -> a_afh0)
unwords' :: ExpG ([String] -> String)
unlines' :: ExpG ([String] -> String)
words' :: ExpG (String -> [String])
lines' :: ExpG (String -> [String])
unzip3' :: ExpG ([(a_afgX, b_afgY, c_afgZ)] -> ([a_afgX], [b_afgY], [c_afgZ]))
unzip' :: ExpG ([(a_afgV, b_afgW)] -> ([a_afgV], [b_afgW]))
zipWith3' :: ExpG ((a_afgR -> b_afgS -> c_afgT -> d_afgU) -> [a_afgR] -> [b_afgS] -> [c_afgT] -> [d_afgU])
zipWith' :: ExpG ((a_afgO -> b_afgP -> c_afgQ) -> [a_afgO] -> [b_afgP] -> [c_afgQ])
zip3' :: ExpG ([a_afgL] -> [b_afgM] -> [c_afgN] -> [(a_afgL, b_afgM, c_afgN)])
zip' :: ExpG ([a_afgJ] -> [b_afgK] -> [(a_afgJ, b_afgK)])
lookup' :: Eq a_afgH => ExpG (a_afgH -> [(a_afgH, b_afgI)] -> Maybe b_afgI)
notElem' :: Eq a_afgG => ExpG (a_afgG -> [a_afgG] -> Bool)
elem' :: Eq a_afgz => ExpG (a_afgz -> [a_afgz] -> Bool)
break' :: ExpG ((a_afgy -> Bool) -> [a_afgy] -> ([a_afgy], [a_afgy]))
span' :: ExpG ((a_afgx -> Bool) -> [a_afgx] -> ([a_afgx], [a_afgx]))
dropWhile' :: ExpG ((a_afgw -> Bool) -> [a_afgw] -> [a_afgw])
takeWhile' :: ExpG ((a_afgv -> Bool) -> [a_afgv] -> [a_afgv])
splitAt' :: ExpG (Int -> [a_afgu] -> ([a_afgu], [a_afgu]))
drop' :: ExpG (Int -> [a_afgt] -> [a_afgt])
take' :: ExpG (Int -> [a_afgs] -> [a_afgs])
cycle' :: ExpG ([a_afgr] -> [a_afgr])
replicate' :: ExpG (Int -> a_afgq -> [a_afgq])
repeat' :: ExpG (a_afgp -> [a_afgp])
iterate' :: ExpG ((a_afgo -> a_afgo) -> a_afgo -> [a_afgo])
scanr1' :: ExpG ((a_afgn -> a_afgn -> a_afgn) -> [a_afgn] -> [a_afgn])
scanl1' :: ExpG ((a_afgm -> a_afgm -> a_afgm) -> [a_afgm] -> [a_afgm])
scanr' :: ExpG ((a_afgk -> b_afgl -> b_afgl) -> b_afgl -> [a_afgk] -> [b_afgl])
scanl' :: ExpG ((b_afgi -> a_afgj -> b_afgi) -> b_afgi -> [a_afgj] -> [b_afgi])
minimum' :: Ord a_afgh => ExpG ([a_afgh] -> a_afgh)
maximum' :: Ord a_afgg => ExpG ([a_afgg] -> a_afgg)
concatMap' :: ExpG ((a_afge -> [b_afgf]) -> [a_afge] -> [b_afgf])
concat' :: ExpG ([[a_af2e]] -> [a_af2e])
product' :: Num a_afgd => ExpG ([a_afgd] -> a_afgd)
sum' :: Num a_afgc => ExpG ([a_afgc] -> a_afgc)
all' :: ExpG ((a_afgb -> Bool) -> [a_afgb] -> Bool)
any' :: ExpG ((a_afga -> Bool) -> [a_afga] -> Bool)
or' :: ExpG ([Bool] -> Bool)
and' :: ExpG ([Bool] -> Bool)
foldr1' :: ExpG ((a_afg9 -> a_afg9 -> a_afg9) -> [a_afg9] -> a_afg9)
foldl1' :: ExpG ((a_aac9 -> a_aac9 -> a_aac9) -> [a_aac9] -> a_aac9)
foldr' :: ExpG ((a_afg7 -> b_afg8 -> b_afg8) -> b_afg8 -> [a_afg7] -> b_afg8)
foldl' :: ExpG ((b_afg5 -> a_afg6 -> b_afg5) -> b_afg5 -> [a_afg6] -> b_afg5)
reverse' :: ExpG ([a_afg4] -> [a_afg4])
length' :: ExpG ([a_afg3] -> Int)
null' :: ExpG ([a_afg2] -> Bool)
init' :: ExpG ([a_afg1] -> [a_afg1])
tail' :: ExpG ([a_afg0] -> [a_afg0])
last' :: ExpG ([a_affZ] -> a_affZ)
head' :: ExpG ([a_affY] -> a_affY)
filter' :: ExpG ((a_affX -> Bool) -> [a_affX] -> [a_affX])
map' :: ExpG ((a_a9Br -> b_a9Bs) -> [a_a9Br] -> [b_a9Bs])
undefined' :: ExpG a_12
asTypeOf' :: ExpG (a_affW -> a_affW -> a_affW)
until' :: ExpG ((a_affV -> Bool) -> (a_affV -> a_affV) -> a_affV -> a_affV)
flip' :: ExpG ((a_aelq -> b_aelr -> c_aels) -> b_aelr -> a_aelq -> c_aels)
const' :: ExpG (a_affT -> b_affU -> a_affT)
id' :: ExpG (a_aaAM -> a_aaAM)
mapM_' :: Monad m_affR => ExpG ((a_affQ -> m_affR b_affS) -> [a_affQ] -> m_affR ())
mapM' :: Monad m_aaj6 => ExpG ((a_aaj5 -> m_aaj6 b_aaj7) -> [a_aaj5] -> m_aaj6 [b_aaj7])
return' :: Monad m_a8vs => forall a_a9rF. ExpG (a_a9rF -> m_a8vs a_a9rF)
fmap' :: Functor f_a9bS => forall a_a9ci b_a9cj. ExpG ((a_a9ci -> b_a9cj) -> f_a9bS a_a9ci -> f_a9bS b_a9cj)
realToFrac' :: (Real a_affH, Fractional b_affI) => ExpG (a_affH -> b_affI)
fromIntegral' :: (Integral a_affF, Num b_affG) => ExpG (a_affF -> b_affG)
lcm' :: Integral a_affE => ExpG (a_affE -> a_affE -> a_affE)
gcd' :: Integral a_affD => ExpG (a_affD -> a_affD -> a_affD)
odd' :: Integral a_affC => ExpG (a_affC -> Bool)
even' :: Integral a_affB => ExpG (a_affB -> Bool)
subtract' :: Num a_affA => ExpG (a_affA -> a_affA -> a_affA)
atan2' :: RealFloat a_affh => ExpG (a_affh -> a_affh -> a_affh)
isNegativeZero' :: RealFloat a_affh => ExpG (a_affh -> Bool)
isIEEE' :: RealFloat a_affh => ExpG (a_affh -> Bool)
isDenormalized' :: RealFloat a_affh => ExpG (a_affh -> Bool)
isInfinite' :: RealFloat a_affh => ExpG (a_affh -> Bool)
isNaN' :: RealFloat a_affh => ExpG (a_affh -> Bool)
scaleFloat' :: RealFloat a_affh => ExpG (Int -> a_affh -> a_affh)
significand' :: RealFloat a_affh => ExpG (a_affh -> a_affh)
exponent' :: RealFloat a_affh => ExpG (a_affh -> Int)
encodeFloat' :: RealFloat a_affh => ExpG (Integer -> Int -> a_affh)
decodeFloat' :: RealFloat a_affh => ExpG (a_affh -> (Integer, Int))
floatRange' :: RealFloat a_affh => ExpG (a_affh -> (Int, Int))
floatDigits' :: RealFloat a_affh => ExpG (a_affh -> Int)
floatRadix' :: RealFloat a_affh => ExpG (a_affh -> Integer)
floor' :: RealFrac a_aff1 => forall b_afff. Integral b_afff => ExpG (a_aff1 -> b_afff)
ceiling' :: RealFrac a_aff1 => forall b_affe. Integral b_affe => ExpG (a_aff1 -> b_affe)
round' :: RealFrac a_aff1 => forall b_affd. Integral b_affd => ExpG (a_aff1 -> b_affd)
truncate' :: RealFrac a_aff1 => forall b_affc. Integral b_affc => ExpG (a_aff1 -> b_affc)
properFraction' :: RealFrac a_aff1 => forall b_affb. Integral b_affb => ExpG (a_aff1 -> (b_affb, a_aff1))
atanh' :: Floating a_afeE => ExpG (a_afeE -> a_afeE)
acosh' :: Floating a_afeE => ExpG (a_afeE -> a_afeE)
asinh' :: Floating a_afeE => ExpG (a_afeE -> a_afeE)
tanh' :: Floating a_afeE => ExpG (a_afeE -> a_afeE)
cosh' :: Floating a_afeE => ExpG (a_afeE -> a_afeE)
sinh' :: Floating a_afeE => ExpG (a_afeE -> a_afeE)
atan' :: Floating a_afeE => ExpG (a_afeE -> a_afeE)
acos' :: Floating a_afeE => ExpG (a_afeE -> a_afeE)
asin' :: Floating a_afeE => ExpG (a_afeE -> a_afeE)
tan' :: Floating a_afeE => ExpG (a_afeE -> a_afeE)
cos' :: Floating a_afeE => ExpG (a_afeE -> a_afeE)
sin' :: Floating a_afeE => ExpG (a_afeE -> a_afeE)
logBase' :: Floating a_afeE => ExpG (a_afeE -> a_afeE -> a_afeE)
sqrt' :: Floating a_afeE => ExpG (a_afeE -> a_afeE)
log' :: Floating a_afeE => ExpG (a_afeE -> a_afeE)
exp' :: Floating a_afeE => ExpG (a_afeE -> a_afeE)
pi' :: Floating a_afeE => ExpG a_afeE
fromRational' :: Fractional a_afew => ExpG (Rational -> a_afew)
recip' :: Fractional a_afew => ExpG (a_afew -> a_afew)
toInteger' :: Integral a_afej => ExpG (a_afej -> Integer)
divMod' :: Integral a_afej => ExpG (a_afej -> a_afej -> (a_afej, a_afej))
quotRem' :: Integral a_afej => ExpG (a_afej -> a_afej -> (a_afej, a_afej))
mod' :: Integral a_afej => ExpG (a_afej -> a_afej -> a_afej)
div' :: Integral a_afej => ExpG (a_afej -> a_afej -> a_afej)
rem' :: Integral a_afej => ExpG (a_afej -> a_afej -> a_afej)
quot' :: Integral a_afej => ExpG (a_afej -> a_afej -> a_afej)
fromInteger' :: Num a_aakB => ExpG (Integer -> a_aakB)
signum' :: Num a_aakB => ExpG (a_aakB -> a_aakB)
abs' :: Num a_aakB => ExpG (a_aakB -> a_aakB)
negate' :: Num a_aakB => ExpG (a_aakB -> a_aakB)
not' :: ExpG (Bool -> Bool)
uncurry' :: ExpG ((a_afef -> b_afeg -> c_afeh) -> (a_afef, b_afeg) -> c_afeh)
curry' :: ExpG (((a_afec, b_afed) -> c_afee) -> a_afec -> b_afed -> c_afee)
snd' :: ExpG ((a_afea, b_afeb) -> b_afeb)
fst' :: ExpG ((a_aal1, b_aal2) -> a_aal1)
either' :: ExpG ((a_afe7 -> c_afe8) -> (b_afe9 -> c_afe8) -> Either a_afe7 b_afe9 -> c_afe8)
maybe' :: ExpG (b_aekV -> (a_aekW -> b_aekV) -> Maybe a_aekW -> b_aekV)
notequal' :: Eq a_afgB => ExpG (a_afgB -> a_afgB -> Bool)
equal' :: Eq a_afgB => ExpG (a_afgB -> a_afgB -> Bool)
index' :: ExpG ([a_agfI] -> Int -> a_agfI)
append' :: ExpG ([a_aahj] -> [a_aahj] -> [a_aahj])
then' :: Monad m_a8vs => forall a_a9rz b_a9rA. ExpG (m_a8vs a_a9rz -> m_a8vs b_a9rA -> m_a8vs b_a9rA)
bind' :: Monad m_a8vs => forall a_a9rt b_a9ru. ExpG (m_a8vs a_a9rt -> (a_a9rt -> m_a8vs b_a9ru) -> m_a8vs b_a9ru)
floatPow' :: Floating a_afeE => ExpG (a_afeE -> a_afeE -> a_afeE)
divide' :: Fractional a_afew => ExpG (a_afew -> a_afew -> a_afew)
mult' :: Num a_aakB => ExpG (a_aakB -> a_aakB -> a_aakB)
add' :: Num a_aakB => ExpG (a_aakB -> a_aakB -> a_aakB)
dot' :: ExpG ((b_a9BC -> c_a9BD) -> (a_a9BE -> b_a9BC) -> a_a9BE -> c_a9BD)
(<>.) :: ExpG (b -> c) -> ExpG (a -> b) -> ExpG (a -> c)
tuple0 :: ExpG ()
tuple2 :: ExpG (a -> b -> (a, b))
tuple3 :: ExpG (a -> b -> c -> (a, b, c))
tuple4 :: ExpG (a -> b -> c -> d -> (a, b, c, d))
tuple5 :: ExpG (a -> b -> c -> d -> (a, b, c, d, e))
cons :: ExpG (a -> [a] -> [a])
instance Num t => Num (ExpG t)

module Language.Haskell.Generate
