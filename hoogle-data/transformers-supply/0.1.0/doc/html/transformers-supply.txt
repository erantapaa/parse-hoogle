-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Supply applicative, monad, applicative transformer and
monad transformer.
--   
--   The <tt>Supply</tt> monad represents a computation that consumes
--   values from a provided supply.
--   
--   This package comes with two separate implementations,
--   <tt>Control.Applicative.Supply</tt> and
--   <tt>Control.Monad.Trans.Supply</tt>. The former provides an
--   applicative and applicative transformer, the latter a monad and monad
--   transformer.
--   
--   The reason for providing two separate implementations is that the
--   <tt>Applicative</tt> instance of
--   <tt>Control.Monad.Trans.Supply.SupplyT</tt> incurs a <tt>Monad</tt>
--   constraint on the wrapped type, meaning it's not possible to
--   (usefully) wrap a type that only has an <tt>Applicative</tt> instance.
--   
--   The implementation of <tt>Control.Applicative.Supply.SupplyT</tt> has
--   an <tt>Applicative</tt> instance for wrapped types that are only
--   <tt>Applicative</tt>, but this implementation cannot be made an
--   instance of <tt>Monad</tt>, meaning it is less powerful than the
--   version from <tt>Control.Monad.Trans.Supply</tt>.
--   
--   In general, use <tt>Control.Monad.Trans.Supply</tt> unless you're
--   wrapping a type that has no <tt>Monad</tt> instance, in which case you
--   can fall back to <tt>Control.Applicative.Supply</tt>.
@package transformers-supply
@version 0.1.0


-- | <ul>
--   <li><i>Computation type:</i> Computations that require a supply of
--   values.</li>
--   <li><i>Binding strategy:</i> Applicative values are functions that
--   consume an input from a supply to produce a value.</li>
--   <li><i>Useful for:</i> Providing a supply of unique names or other
--   values to computations needing them.</li>
--   <li><i>Zero and plus:</i> Identical to the underlying implementation
--   (if any) of <a>empty</a> and <a>&lt;|&gt;</a>.</li>
--   <li><i>Example type:</i> <tt><a>Supply</a> s a</tt> or
--   <tt><a>SupplyT</a> s f a</tt></li>
--   <li><i>Difference from <a>Control.Monad.Trans.Supply</a>:</i>
--   <a>SupplyT</a> defined in this module is not, and cannot be an
--   instance of <a>Monad</a>. See the <a>Applicative vs Monad</a> section
--   below for an in-depth explanation.</li>
--   </ul>
--   
--   The <tt><a>Supply</a> s a</tt> applicative represents a computation
--   that consumes a supply of <tt>s</tt>'s to produce a value of type
--   <tt>a</tt>. One example use is to simplify computations that require
--   the generation of unique names. The <a>Supply</a> applicative can be
--   used to provide a stream of unique names to such a computation.
module Control.Applicative.Supply

-- | The Supply applicative.
--   
--   Computations consume values of type <tt>s</tt> from a supply of
--   values.
--   
--   <a>pure</a> ignores the supply of values, while <a>&lt;*&gt;</a>
--   passes the supply to the second argument after the first argument is
--   done consuming values.
type Supply s a = SupplyT s Identity a

-- | The Supply transformer.
--   
--   Composes Supply with an underlying applicative, identical to using
--   <tt><a>Compose</a> <a>Supply</a> f a</tt>, but this implementation
--   avoids the need to explicitly wrap <a>demand</a> in <a>pure</a>
--   everywhere.
--   
--   The resulting SupplyT value has an <a>Alternative</a> instance if the
--   underlying applicative has an <a>Alternative</a> instance.
data SupplyT s f a

-- | Supply a construction function with an <tt>s</tt> value from the
--   supply.
supply :: (s -> f a) -> SupplyT s f a

-- | Supply a non-applicative construction function with an <tt>s</tt>
--   value from the supply and automatically lift its result into the
--   <tt>f</tt> applicative that <a>SupplyT</a> wraps.
provide :: Applicative f => (s -> a) -> SupplyT s f a

-- | Demand an <tt>s</tt> value from the supply.
demand :: Applicative f => SupplyT s f s

-- | Change the type of values consumed by a <a>Supply</a> computation.
withSupply :: (s' -> s) -> Supply s a -> Supply s' a

-- | Change the type of values consumed by a <a>SupplyT</a> computation.
withSupplyT :: (s' -> s) -> SupplyT s f a -> SupplyT s' f a

-- | Run a supply consuming computation, using a generation function and
--   initial value to compute the values consumed by the <a>Supply</a>
--   computation.
runSupply :: Supply s a -> (s -> s) -> s -> a

-- | Run a supply consuming computation, using a generation function and
--   initial value to compute the values consumed by the <a>SupplyT</a>
--   computation.
runSupplyT :: SupplyT s f a -> (s -> s) -> s -> f a

-- | Feed a supply consuming computation from a list until the computation
--   finishes or the list runs out. If the list does not contain sufficient
--   elements, <tt>runListSupply</tt> returns uncompleted computation.
runListSupply :: Supply s a -> [s] -> Either (Supply s a) a

-- | Feed a supply consuming computation from a list until the computation
--   finishes or the list runs out. If the list does not contain sufficient
--   elements, <tt>runListSupplyT</tt> returns uncompleted computation.
runListSupplyT :: SupplyT s f a -> [s] -> Either (SupplyT s f a) (f a)

-- | Feed a supply consuming computation from a monadic action until the
--   computation finishes.
runMonadSupply :: Monad m => Supply s a -> m s -> m a

-- | Feed a supply consuming computation from a monadic action until the
--   computation finishes.
runMonadSupplyT :: Monad m => SupplyT s f a -> m s -> m (f a)
instance Alternative f => Alternative (SupplyT s f)
instance Applicative f => Applicative (SupplyT s f)
instance Functor f => Functor (SupplyT s f)


-- | <ul>
--   <li><i>Computation type:</i> Computations that require a supply of
--   values.</li>
--   <li><i>Binding strategy:</i> Applicative values are functions that
--   consume an input from a supply to produce a value.</li>
--   <li><i>Useful for:</i> Providing a supply of unique names or other
--   values to computations needing them.</li>
--   <li><i>Zero and plus:</i> Identical to the underlying implementations
--   (if any) of <a>empty</a>, <a>&lt;|&gt;</a>, <a>mzero</a> and
--   <a>mplus</a>.</li>
--   <li><i>Example type:</i> <tt><a>Supply</a> s a</tt> or
--   <tt><a>SupplyT</a> s f a</tt></li>
--   <li><i>Difference from <a>Control.Applicative.Supply</a>:</i> The
--   <a>Applicative</a> instance of <a>SupplyT</a> defined in this module
--   requires that the wrapped type is an instance of <a>Monad</a>. See the
--   <a>Applicative vs Monad</a> section below for an in-depth
--   explanation.</li>
--   </ul>
--   
--   The <tt><a>Supply</a> s a</tt> monad represents a computation that
--   consumes a supply of <tt>s</tt>'s to produce a value of type
--   <tt>a</tt>. One example use is to simplify computations that require
--   the generation of unique names. The <a>Supply</a> monad can be used to
--   provide a stream of unique names to such a computation.
module Control.Monad.Trans.Supply

-- | The Supply monad.
--   
--   Computations consume values of type <tt>s</tt> from a supply of
--   values.
--   
--   <a>return</a> ignores the supply of values, while <a>&gt;&gt;=</a>
--   passes the supply to the second argument after the first argument is
--   done consuming values.
type Supply s a = SupplyT s Identity a

-- | The Supply transformer.
--   
--   Composes Supply with an underlying monad, allowing it to be used monad
--   in transformer stacks.
--   
--   The resulting SupplyT value has <a>Alternative</a> and
--   <a>MonadPlus</a> instances if the underlying monad has such these
--   instances.
data SupplyT s m a

-- | Supply a construction function with an <tt>s</tt> value from the
--   supply.
supply :: Monad m => (s -> m a) -> SupplyT s m a

-- | Supply a non-monadic construction function with an <tt>s</tt> value
--   from the supply and automatically lift its result into the <tt>m</tt>
--   monad that <a>SupplyT</a> wraps.
provide :: Monad m => (s -> a) -> SupplyT s m a

-- | Demand an <tt>s</tt> value from the supply.
demand :: Monad m => SupplyT s m s

-- | Change the type of values consumed by a <a>Supply</a> computation.
withSupply :: (s' -> s) -> Supply s a -> Supply s' a

-- | Change the type of values consumed by a <a>SupplyT</a> computation.
withSupplyT :: Functor f => (s' -> s) -> SupplyT s f a -> SupplyT s' f a

-- | Run a supply consuming computation, using a generation function and
--   initial value to compute the values consumed by the <a>Supply</a>
--   computation.
runSupply :: Supply s a -> (s -> s) -> s -> a

-- | Run a supply consuming computation, using a generation function and
--   initial value to compute the values consumed by the <a>SupplyT</a>
--   computation.
runSupplyT :: Monad m => SupplyT s m a -> (s -> s) -> s -> m a

-- | Feed a supply consuming computation from a list until the computation
--   finishes or the list runs out. If the list does not contain sufficient
--   elements, <tt>runListSupply</tt> returns uncompleted computation.
runListSupply :: Supply s a -> [s] -> Either (Supply s a) a

-- | Feed a supply consuming computation from a list until the computation
--   finishes or the list runs out. If the list does not contain sufficient
--   elements, <tt>runListSupplyT</tt> returns uncompleted computation.
runListSupplyT :: Monad m => SupplyT s m a -> [s] -> m (Either (SupplyT s m a) a)

-- | Feed a supply consuming computation from a monadic action until the
--   computation finishes.
runMonadSupply :: Monad m => Supply s a -> m s -> m a

-- | Feed a supply consuming computation from a monadic action until the
--   computation finishes.
runMonadSupplyT :: Monad m => SupplyT s m a -> m s -> m a
instance (Functor m, MonadIO m) => MonadIO (SupplyT s m)
instance (Functor m, MonadPlus m) => MonadPlus (SupplyT s m)
instance (Alternative m, Monad m) => Alternative (SupplyT s m)
instance MonadTrans (SupplyT s)
instance (Functor m, Monad m) => Monad (SupplyT s m)
instance (Functor m, Monad m) => Applicative (SupplyT s m)
instance Functor f => Functor (SupplyT s f)
instance Functor f => Functor (Consumer s f)


-- | See <a>Control.Monad.Supply</a> for documentation.
module Control.Monad.Supply.Class

-- | The <a>MonadSupply</a> class provides access to the functions needed
--   to construct supply-consuming computations in a monad transformer
--   stack.
class Monad m => MonadSupply s f m | m -> s, m -> f
supply :: MonadSupply s f m => (s -> f a) -> m a
provide :: MonadSupply s f m => (s -> a) -> m a

-- | Demand an <tt>s</tt> value from the supply.
demand :: MonadSupply s f m => m s
instance (Monoid w, MonadSupply s f m) => MonadSupply s f (WriterT w m)
instance (Monoid w, MonadSupply s f m) => MonadSupply s f (WriterT w m)
instance MonadSupply s f m => MonadSupply s f (StateT s m)
instance MonadSupply s f m => MonadSupply s f (StateT s m)
instance (Monoid w, MonadSupply s f m) => MonadSupply s f (RWST r w s m)
instance (Monoid w, MonadSupply s f m) => MonadSupply s f (RWST r w s m)
instance MonadSupply s f m => MonadSupply s f (ReaderT r m)
instance MonadSupply s f m => MonadSupply s f (MaybeT m)
instance MonadSupply s f m => MonadSupply s f (ListT m)
instance MonadSupply s f m => MonadSupply s f (IdentityT m)
instance (Error e, MonadSupply s f m) => MonadSupply s f (ErrorT e m)
instance MonadSupply s f m => MonadSupply s f (ContT r m)
instance (Functor m, Monad m) => MonadSupply s m (SupplyT s m)


-- | <ul>
--   <li><i>Computation type:</i> Computations that require a supply of
--   values.</li>
--   <li><i>Binding strategy:</i> Applicative values are functions that
--   consume an input from a supply to produce a value.</li>
--   <li><i>Useful for:</i> Providing a supply of unique names or other
--   values to computations needing them.</li>
--   <li><i>Zero and plus:</i> Identical to the underlying implementations
--   (if any) of <tt>empty</tt>, <tt>&lt;|&gt;</tt>, <a>mzero</a> and
--   <a>mplus</a>.</li>
--   </ul>
--   
--   The <tt><a>Supply</a> s a</tt> monad represents a computation that
--   consumes a supply of <tt>s</tt>'s to produce a value of type
--   <tt>a</tt>. One example use is to simplify computations that require
--   the generation of unique names. The <a>Supply</a> monad can be used to
--   provide a stream of unique names to such a computation.
module Control.Monad.Supply

-- | The <a>MonadSupply</a> class provides access to the functions needed
--   to construct supply-consuming computations in a monad transformer
--   stack.
class Monad m => MonadSupply s f m | m -> s, m -> f
supply :: MonadSupply s f m => (s -> f a) -> m a
provide :: MonadSupply s f m => (s -> a) -> m a

-- | Demand an <tt>s</tt> value from the supply.
demand :: MonadSupply s f m => m s

-- | The Supply monad.
--   
--   Computations consume values of type <tt>s</tt> from a supply of
--   values.
--   
--   <a>return</a> ignores the supply of values, while <a>&gt;&gt;=</a>
--   passes the supply to the second argument after the first argument is
--   done consuming values.
type Supply s a = SupplyT s Identity a

-- | Change the type of values consumed by a <a>Supply</a> computation.
withSupply :: (s' -> s) -> Supply s a -> Supply s' a

-- | Run a supply consuming computation, using a generation function and
--   initial value to compute the values consumed by the <a>Supply</a>
--   computation.
runSupply :: Supply s a -> (s -> s) -> s -> a

-- | Feed a supply consuming computation from a list until the computation
--   finishes or the list runs out. If the list does not contain sufficient
--   elements, <tt>runListSupply</tt> returns uncompleted computation.
runListSupply :: Supply s a -> [s] -> Either (Supply s a) a

-- | Feed a supply consuming computation from a monadic action until the
--   computation finishes.
runMonadSupply :: Monad m => Supply s a -> m s -> m a

-- | The Supply transformer.
--   
--   Composes Supply with an underlying monad, allowing it to be used monad
--   in transformer stacks.
--   
--   The resulting SupplyT value has <a>Alternative</a> and
--   <a>MonadPlus</a> instances if the underlying monad has such these
--   instances.
data SupplyT s m a

-- | Change the type of values consumed by a <a>SupplyT</a> computation.
withSupplyT :: Functor f => (s' -> s) -> SupplyT s f a -> SupplyT s' f a

-- | Run a supply consuming computation, using a generation function and
--   initial value to compute the values consumed by the <a>SupplyT</a>
--   computation.
runSupplyT :: Monad m => SupplyT s m a -> (s -> s) -> s -> m a

-- | Feed a supply consuming computation from a list until the computation
--   finishes or the list runs out. If the list does not contain sufficient
--   elements, <tt>runListSupplyT</tt> returns uncompleted computation.
runListSupplyT :: Monad m => SupplyT s m a -> [s] -> m (Either (SupplyT s m a) a)

-- | Feed a supply consuming computation from a monadic action until the
--   computation finishes.
runMonadSupplyT :: Monad m => SupplyT s m a -> m s -> m a
