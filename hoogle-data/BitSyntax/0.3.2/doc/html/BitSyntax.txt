-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A module to aid in the (de)serialisation of binary data
--   
--   A module to aid in the (de)serialisation of binary data
@package BitSyntax
@version 0.3.2


-- | This module contains fuctions and templates for building up and
--   breaking down packed bit structures. It's something like Erlang's
--   bit-syntax (or, actually, more like Python's struct module).
--   
--   This code uses Data.ByteString which is included in GHC 6.5 and you
--   can get it for 6.4 at <a>http://www.cse.unsw.edu.au/~dons/fps.html</a>
module Data.BitSyntax
data BitBlock

-- | Unsigned 8-bit int
U8 :: Int -> BitBlock

-- | Unsigned 16-bit int
U16 :: Int -> BitBlock

-- | Unsigned 32-bit int
U32 :: Int -> BitBlock

-- | Little-endian, unsigned 16-bit int
U16LE :: Int -> BitBlock

-- | Little-endian, unsigned 32-bit int
U32LE :: Int -> BitBlock

-- | Appends the string with a trailing NUL byte
NullTerminated :: String -> BitBlock

-- | Appends the string without any terminator
RawString :: String -> BitBlock

-- | Appends a ByteString
RawByteString :: ByteString -> BitBlock

-- | Packs a series of bit fields together. The argument is a list of pairs
--   where the first element is the size (in bits) and the second is the
--   value. The sum of the sizes for a given PackBits must be a multiple of
--   8
PackBits :: [(Int, Int)] -> BitBlock

-- | Make a binary string from the list of elements given
makeBits :: [BitBlock] -> ByteString
data ReadType

-- | An unsigned number of some number of bytes. Valid arguments are 1, 2
--   and 4
Unsigned :: Integer -> ReadType

-- | An unsigned, little-endian integer of some number of bytes. Valid
--   arguments are 2 and 4
UnsignedLE :: Integer -> ReadType

-- | A variable length element to be decoded by a custom function. The
--   function's name is given as the single argument and should have type
--   <tt>Monad m =&gt; ByteString -&gt; m (v, ByteString)</tt>
Variable :: Name -> ReadType

-- | Skip some number of bytes
Skip :: Integer -> ReadType

-- | A fixed size field, the result of which is a ByteString of that
--   length.
Fixed :: Integer -> ReadType

-- | Decode a value and ignore it (the result will not be part of the
--   returned tuple)
Ignore :: ReadType -> ReadType

-- | Like variable, but the decoding function is passed the entire result
--   tuple so far. Thus the function whose name passed has type <tt>Monad m
--   =&gt; ByteString -&gt; (...) -&gt; m (v, ByteString)</tt>
Context :: Name -> ReadType

-- | Takes the most recent element of the result tuple and interprets it as
--   the length of this field. Results in a ByteString
LengthPrefixed :: ReadType

-- | Decode a series of bit fields, results in a list of Integers. Each
--   element of the argument is the length of the bit field. The sums of
--   the lengths must be a multiple of 8
PackedBits :: [Integer] -> ReadType

-- | Results in a ByteString containing the undecoded bytes so far.
--   Generally used at the end to return the trailing body of a structure,
--   it can actually be used at any point in the decoding to return the
--   trailing part at that point.
Rest :: ReadType
bitSyn :: [ReadType] -> Q Exp
decodeU8 :: ByteString -> Word8
decodeU16 :: ByteString -> Word16
decodeU32 :: ByteString -> Word32
decodeU16LE :: ByteString -> Word16
decodeU32LE :: ByteString -> Word32
instance Show BitBlock
instance Arbitrary Word32
instance Arbitrary Word16
