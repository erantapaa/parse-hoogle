-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Typeclasses for injective relations and isomorphisms between types.
--   
--   This package defines "can be cast to" relations between types: two
--   types a and b are an instance of Injective if there's an injective
--   function from a to b. If there is also an injective function from b to
--   a, a and b are instances of Iso, meaning that one can convert back and
--   forth losslessly (up to some appropriate notion of equality). The main
--   purpose of this little package is to provide easy casting between the
--   common string types (String, strict/lazy Text) and numeric types
--   (Integers, Peano numbers), without having to look up the names of the
--   various conversion functions all the time.
@package type-iso
@version 0.1.0.0


-- | Injective types. This module contains the <a>Injective</a> typeclass
--   and instances for the following equivalence classes:
--   
--   <ul>
--   <li><tt>{Strict Text, Lazy Text, String}</tt>. <tt>ByteString</tt>s
--   are not part of this, since there exists more than one way to turn
--   unicode text into a ByteString (see <a>Data.Text.Encoding</a> and
--   <a>Data.Text.Lazy.Encoding</a>).</li>
--   <li><tt>{Whole, Integer}</tt>. Be advices, though, that Peano numbers
--   may contain unobservable infinities (i.e. <tt>infinity = S
--   infinity</tt>) and thus, the conversion to Integer may not
--   terminate.</li>
--   <li><tt>{Nat, Natural}</tt>. For finite values, they're extensionally
--   equivalent, but <tt>Nat</tt> has lazy infinity.</li>
--   </ul>
--   
--   Additional injections:
--   
--   <ul>
--   <li>Maybe to Either (the reverse is not true, since different
--   <a>Left</a> values would all be converted to <a>Nothing</a>).</li>
--   <li>Integers to Rational.</li>
--   <li>Natural numbers to Integer and Rational.</li>
--   </ul>
module Data.Types.Injective

-- | The class relation between types <tt>a</tt> and <tt>b</tt> s.t.
--   <tt>a</tt> can be injected into <tt>b</tt>.
--   
--   The following laws must be fulfilled:
--   
--   <ul>
--   <li><i><tt>Injectivity</tt></i></li>
--   </ul>
--   
--   <pre>
--   x /= y  ==&gt;  (to x) /= (to y)
--   </pre>
--   
--   <ul>
--   <li><i><tt>Totality</tt></i> <tt>to</tt> should be a total function.
--   No cheating by it undefined for parts of the set!</li>
--   </ul>
class Injective a b
to :: Injective a b => a -> b
instance Injective Whole Rational
instance Injective Integer Rational
instance Injective Nat Rational
instance Injective Nat Whole
instance Injective Nat Integer
instance Injective Natural Rational
instance Injective Natural Whole
instance Injective Natural Integer
instance Default a => Injective (Maybe b) (Either a b)
instance Injective Nat Natural
instance Injective Natural Nat
instance Injective Integer Whole
instance Injective Whole Integer
instance Injective String Text
instance Injective Text String
instance Injective Text Text
instance Injective Text Text
instance Injective String Text
instance Injective Text String
instance Injective a a


-- | Contains the class definition of <a>Iso</a>, indicating isomorphism
--   between two types.
module Data.Types.Isomorphic

-- | The class of isomorphic types, i.e. those which can be cast to each
--   other withouth loss of information. Type isomorphism is an equivalence
--   relation (reflexive, symmetric, transitive), but due to the
--   limitations of the type system, only reflexivity is implemented for
--   all types. Since there are no type inequality constraints, writing
--   symmetry and transitivity instances over all types would result in
--   overlapping instances with due to reflexivity.
--   
--   The following must be ensured:
--   
--   <ul>
--   <li><i><tt>Isomorphism</tt></i> <tt> isoFrom . isoTo = id </tt></li>
--   </ul>
--   
--   Reflexivity, symmetry and transitivity are then "free":
--   
--   <pre>
--   instance Iso a a where
--      isoTo = id
--      isoFrom = id
--   </pre>
--   
--   <pre>
--   instance Iso a b =&gt; Iso b a where
--      isoTo = isoFrom
--      isoFrom = isoTo
--   </pre>
--   
--   <pre>
--   instance (Iso a b, Iso b c) =&gt; Iso a c where
--     isoTo = isoTo . isoTo
--     isFrom = isoFrom . isoFrom
--   </pre>
--   
--   Out of these, only the first one (reflexivity) is actually
--   implemented, since the other two would result in overlapping
--   instances. We would be able to avoid this with type inequality
--   constrains (e.g. <tt>a /~ b</tt>, <tt>a /~ c</tt>, <tt>b /~ c)</tt>.
class (Injective a b, Injective b a) => Iso a b

-- | Synonym for <a>to</a>.
from :: Iso a b => b -> a
instance Iso Integer Whole
instance Iso Whole Integer
instance Iso Text Text
instance Iso Text Text
instance Iso String Text
instance Iso Text String
instance Iso String Text
instance Iso Text String
instance Iso a a
