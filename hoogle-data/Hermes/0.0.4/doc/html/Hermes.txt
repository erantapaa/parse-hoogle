-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Message-based middleware layer
--   
--   A middleware providing best-effort unicast, remote procedure calls,
--   probabilistic (and slow!) broadcast and automatic membership
--   management, meant for small to medium networks
@package Hermes
@version 0.0.4


-- | Miscellaneous functions. Not really for public consumption.
module Network.Hermes.Misc
ghead :: (Data x, Typeable y) => x -> y
byteStringToInteger :: ByteString -> Integer
runTMVar :: TMVar s -> StateT s IO a -> IO a
throwM :: (MonadIO m, Exception e) => e -> m a
modifyTVar :: TVar a -> (a -> a) -> STM ()

-- | Our notion of types: A shown Typeable.
type Type = String
showType :: (Typeable a) => a -> Type

-- | Logs any unhandled exceptions
trapForkIO :: String -> IO () -> IO ThreadId

-- | Encryption stuff
rsaEncrypt :: (RandomGen g) => g -> PublicKey -> ByteString -> (ByteString, g)
rsaDecrypt :: PrivateKey -> ByteString -> ByteString
rsaVerify :: PublicKey -> ByteString -> ByteString -> Bool
rsaSign :: PrivateKey -> ByteString -> ByteString

-- | Swap values in a Map. Returns the old value, if any.
swap :: (Ord k) => k -> v -> Map k v -> (Maybe v, Map k v)

-- | Executes an action once for each value of the TVar. May skip values if
--   it changes quickly.
listenTVar :: (Eq a) => TVar a -> (a -> IO ()) -> IO ThreadId
adjustWithDefault :: (Ord k) => a -> (a -> a) -> k -> Map k a -> Map k a


-- | An MChan is a combination of a Map and a TChan.
module Network.Hermes.MChan

-- | MChan is an abstract type representing a keyed, unbounded FIFO channel
data MChan k v

-- | Builds and returns a new instance of MChan
newMChan :: (Ord k) => STM (MChan k v)

-- | IO version of <a>newMChan</a>. This is useful for creating top-level
--   <a>MChan</a>s using <tt>System.IO.Unsafe.unsafePerformIO</tt>, because
--   using <a>atomically</a> inside
--   <tt>System.IO.Unsafe.unsafePerformIO</tt> isn't safe.
newMChanIO :: (Ord k) => IO (MChan k v)

-- | Read the next value from an MChan. If the specified key doesn't exist
--   (or is removed while waiting), it returns Nothing.
readMChan :: (Ord k) => MChan k v -> k -> STM (Maybe v)

-- | Write a value to an MChan. Returns false and discards the value if the
--   specified key doesn't exist.
writeMChan :: (Ord k) => MChan k v -> k -> v -> STM Bool

-- | Write a value to an MChan, creating the key if it doesn't exist.
writeMChan' :: (Ord k) => MChan k v -> k -> v -> STM ()

-- | Checks whether the key exists
existsMChan :: (Ord k) => MChan k v -> k -> STM Bool

-- | Creates the key if it doesn't already exist
ensureMChan :: (Ord k) => MChan k v -> k -> STM ()

-- | Delete a key from an MChan
deleteMChan :: (Ord k) => MChan k v -> k -> STM ()
instance Typeable2 MChan

module Network.Hermes.Net
connectStream :: Address -> IO Handle

-- | Creates a TCP server that will hand off incoming connections to new
--   threads.
--   
--   Killing the server does not kill these forked threads.
--   
--   The handle passed to your action will be automatically closed when
--   that action returns.
streamServer :: Address -> (Handle -> Address -> IO ()) -> IO (IO ())
data Address

-- | Host name and port, IPv4, IPv6, or both
IP :: HostName -> Int -> Address

-- | IPv4 only
IPv4 :: HostName -> Int -> Address

-- | IPv6 only
IPv6 :: HostName -> Int -> Address

-- | Unix domain socket, not available on Windows
Unix :: FilePath -> Address

-- | Returns the <i>best</i> fit only, or a DNSFailure exception
resolve :: Address -> IO SockAddr
reverseLookup :: SockAddr -> IO Address


-- | Hermes is a middleware layer providing best-effort unicast, remote
--   procedure calls, probabilistic (and slow!) broadcast and automatic
--   membership management. It is meant for small-to-medium networks; its
--   broadcast gossip protocol, which is used for membership management,
--   will scale poorly to very large ones.
--   
--   Hermes uses HsLogger for event logging, using the "hermes" namespace.
module Network.Hermes

-- | Most Hermes functions can throw one of these exceptions, which | are
--   mainly triggered when (re)negotiating connections.
data HermesException

-- | Hermes has no idea who you're talking about. How did you even get the
--   HermesID? HermesID information is never discarded, so this exception
--   should be rather uncommon.
HermesIDUnknown :: HermesID -> HermesException

-- | We don't know where this HermesID is; we never did, or old information
--   proved to be false.
AddressUnknown :: HermesID -> HermesException

-- | Failed to resolve the address
DNSFailure :: Address -> HermesException

-- | The remote server is not speaking Hermes-speak.
WrongProtocol :: HermesException

-- | A different protocol version is in use at the remote host. Check
--   library version.
ProtocolVersionMismatch :: Word32 -> Word32 -> HermesException

-- | Something went wrong while authenticating. Have a reason.
AuthError :: String -> HermesException

-- | Something went wrong while deserializing your data.
DeserializationError :: String -> HermesException

-- | Attempted to create a listener on a port we're already listening to
ListenerAlreadyExists :: HermesException

-- | Message corrupted (connection broken)
MessageError :: HermesException

-- | Some operation took longer than the user-configured timeout
Timeout :: HermesException

-- | Receive was explicitly cancelled by the user
RecvCancelled :: HermesException

-- | All use of hermes must be wrapped with this (on windows)
withHermes :: IO a -> IO a
data SignatureRequest
type Signature = ByteString
data Authority
newAuthority :: IO Authority

-- | Creates a signature request for serialization
newSignatureRequest :: Context -> SignatureRequest

-- | Sign a request. Use setKeySignature to install it.
signRequest :: Authority -> SignatureRequest -> Signature
installSignature :: Context -> Signature -> IO ()

-- | Adds an authority to the list of trusted authorities
addAuthority :: Context -> Authority -> IO ()
data Context

-- | If Indirect, require a signature from an authority.
--   
--   If Direct, require an OK from the library client.
--   
--   If None, no trust is required.
data TrustLevel
None :: TrustLevel
Indirect :: TrustLevel
Direct :: TrustLevel

-- | A hash computed from a public key
type HermesID = Integer

-- | Creates a new Hermes context allowing messaging, RPC and gossip, and
--   using automatic address dissemination via the gossip protocol.
--   
--   The trust level defaults to Indirect.
--   
--   The gossip interval defaults to 300 seconds, call setPeriod to change
--   it.
newContext :: IO Context

-- | Creates a pre-signed context. You may snapshot this to restore on
--   another computer, or use on this one.
newSignedContext :: Authority -> IO Context
snapshotContext :: Context -> IO ByteString

-- | Snapshots a context for storage
--   
--   Transient state (RPC calls, messages) are discarded, as are
--   connection, listener information and RPC bindings.
snapshotContext' :: Context -> STM ByteString

-- | Restores a context from storage
--   
--   You will have to reset RPC bindings and listeners.
restoreContext :: ByteString -> IO Context
uuid :: Context -> HermesID

-- | For operations that may block, other than recv, this sets a maximum
--   wait time. Hermes will never block longer than this.
setTimeout :: Context -> Double -> IO ()

-- | Set the desired trust limit, which will take effect on next connection
--   
--   When connecting peers (either way), a degree of trust is required, or
--   the connection will be rejected.
setTrustLimit :: Context -> TrustLevel -> IO ()

-- | Set up a listener for incoming connections. These are not stored when
--   snapshotting contexts. This function will return once the port has
--   been bound.
startListener :: Context -> Address -> Maybe Address -> IO ()
data Address

-- | Host name and port, IPv4, IPv6, or both
IP :: HostName -> Int -> Address

-- | IPv4 only
IPv4 :: HostName -> Int -> Address

-- | IPv6 only
IPv6 :: HostName -> Int -> Address

-- | Unix domain socket, not available on Windows
Unix :: FilePath -> Address

-- | Connects to a given address without knowing in advance who will be
--   answering. The answerer's HermesID is returned, assuming the
--   connection is properly established.
--   
--   Typically used for bootstrapping.
connect :: Context -> Address -> IO HermesID

-- | Sends a message. The type representation is included, so a modicum of
--   type safety is provided, and recv will only attempt to decode and
--   return a message of the matching (not necessarily correct! Make sure
--   your de/serializers match!) type. There is, of course, a possibility
--   of exceptions if application versions differ.
--   
--   You may use send' to provide an arbitrary tag to match on, in which
--   case recv' will only return a message with an equal tag; if you don't,
--   recv will only return messages without tags.
--   
--   This function normally blocks until the entire message has been sent,
--   an exception occurs or a timeout is reached. It will retry once if the
--   connection fails within the timeout.
--   
--   Unless acceptType or recv has been called in advance, sent messages
--   are thrown away instead of queued. Once either has been, they are
--   indefinitely queued until refuseType is called.
send :: (Serialize msg, Typeable msg) => Context -> HermesID -> msg -> IO ()
send' :: (Serialize msg, Typeable msg, Serialize tag, Typeable tag) => Context -> HermesID -> msg -> tag -> IO ()

-- | Receives a message. This function blocks until a message of the
--   appropriate type has been received, possibly forever. You may use
--   multiple simultaneous recv calls; each message will only be delivered
--   once.
recv :: (Serialize msg, Typeable msg) => Context -> IO (HermesID, msg)
recv' :: (Serialize msg, Typeable msg, Serialize tag, Typeable tag) => Context -> tag -> IO (HermesID, msg)

-- | If you wish to queue messages without immediately calling recv, use
--   this.
--   
--   acceptType is idempotent.
acceptType :: (Typeable msg, Serialize tag, Typeable tag) => Context -> msg -> tag -> IO ()

-- | If you wish to *stop* queueing messages of a given type, use this.
--   
--   Calling refuseType will cause all recv calls to this type/tag
--   combination to throw RecvCancelled.
--   
--   refuseType is idempotent.
refuseType :: (Typeable msg, Serialize tag, Typeable tag) => Context -> msg -> tag -> IO ()

-- | Remote procedure call
--   
--   In addition to the usual core exceptions, this function may fail in
--   the specific case the the named procedure doesn't exist or has the
--   wrong type, in which case it returns Nothing.
call :: (Serialize a, Typeable a, Serialize b, Typeable b) => Context -> HermesID -> ProcName -> a -> IO (Maybe b)

-- | Registers (or replaces) a callback that is to be executed whenever we
--   receive a properly typed call to this name.
--   
--   You may register calls with the same name, so long as they have
--   different types.
--   
--   If the callback already exists, it is overwritten.
registerCallback :: (Serialize a, Serialize b, Typeable a, Typeable b) => Context -> ProcName -> (a -> IO b) -> IO ()
type ProcName = String

-- | Insert a factoid in the gossip network. This will immediately trigger
--   a limited gossip exchange, hopefully spreading it to a large fraction
--   of the network.
--   
--   Factoids are keyed by their type, source, and the type and serialized
--   value of an arbitrary tag. They can be replaced by re-inserting later,
--   and optionally expire after a timeout.
--   
--   Don't rely on the timeout, though. It's for garbage collection, and is
--   not required to be exact.
writeFactoid :: (Typeable factoid, Serialize factoid, Typeable tag, Serialize tag) => Context -> factoid -> tag -> Maybe TTL -> IO ()

-- | Read a factoid, assuming it exists.
readFactoid :: (Typeable factoid, Serialize factoid, Typeable tag, Serialize tag) => Context -> tag -> HermesID -> IO (Maybe factoid)

-- | Read all factoids with an appropriate type and tag. Useful if you
--   don't know what source to expect.
readFactoids :: (Typeable factoid, Serialize factoid, Typeable tag, Serialize tag) => Context -> tag -> IO [(HermesID, factoid)]

-- | Add a callback to be called every time a type-matching factoid is
--   inserted or updated. It will not be called for writeFactoid calls.
addCallback :: (Serialize tag, Typeable tag, Serialize msg, Typeable msg) => Context -> (HermesID -> tag -> msg -> IO ()) -> IO ()

-- | Set the period for the periodic gossiper. It will take effect after
--   the next periodic gossip.
setPeriod :: Context -> Double -> IO ()

-- | Seconds
type TTL = Double

-- | The address snapshot contains address information for every node we
--   know of, which can be restored into another node to bootstrap it.
snapshotAddresses :: Context -> STM ByteString

-- | Restore an address snapshot to bootstrap your node.
--   
--   Returns Nothing on success, otherwise a parse error.
restoreAddresses :: Context -> ByteString -> STM (Maybe String)

-- | This utility function decides the lowest priority that will be shown.
--   The default is WARNING.
setDebug :: Priority -> IO ()

-- | Priorities are used to define how important a log messgae is. Users
--   can filter log messages based on priorities.
--   
--   These have their roots on the traditional syslog system. The standard
--   definitions are given below, but you are free to interpret them
--   however you like. They are listed here in ascending importance order.
data Priority :: *

-- | Debug messages
DEBUG :: Priority

-- | Information
INFO :: Priority

-- | Normal runtime conditions
NOTICE :: Priority

-- | General Warnings
WARNING :: Priority

-- | General Errors
ERROR :: Priority

-- | Severe situations
CRITICAL :: Priority

-- | Take immediate action
ALERT :: Priority

-- | System is unusable
EMERGENCY :: Priority
