-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An evolving collection of Oleg Kiselyov's Haskell modules
--   
--   An evolving collection of Oleg Kiselyov's Haskell modules (released
--   with his permission)
--   
--   See the original articles at <a>http://okmij.org/ftp/</a>
@package liboleg
@version 2010.1.10.0


-- | <a>http://okmij.org/ftp/Haskell/regions.html#light-weight</a>
--   
--   Lightweight monadic regions
--   
--   <ul>
--   <li><i>The Abstract of the paper</i> We present Haskell libraries that
--   statically ensure the safe use of resources such as file handles. We
--   statically prevent accessing an already closed handle or forgetting to
--   close it. The libraries can be trivially extended to other resources
--   such as database connections and graphic contexts.</li>
--   </ul>
--   
--   Because file handles and similar resources are scarce, we want to not
--   just assure their safe use but further deallocate them soon after they
--   are no longer needed. Relying on Fluet and Morrisett's calculus of
--   nested regions, we contribute a novel, improved, and extended
--   implementation of the calculus in Haskell, with file handles as
--   resources.
--   
--   Our library supports region polymorphism and implicit region
--   subtyping, along with higher-order functions, mutable state,
--   recursion, and run-time exceptions. A program may allocate arbitrarily
--   many resources and dispose of them in any order, not necessarily LIFO.
--   Region annotations are part of an expression's inferred type. Our new
--   Haskell encoding of monadic regions as monad transformers needs no
--   witness terms. It assures timely deallocation even when resources have
--   markedly different lifetimes and the identity of the longest-living
--   resource is determined only dynamically.
--   
--   For contrast, we also implement a Haskell library for manual resource
--   management, where deallocation is explicit and safety is assured by a
--   form of linear types. We implement the linear typing in Haskell with
--   the help of phantom types and a parameterized monad to statically
--   track the type-state of resources.
--   
--   Joint work with Chung-chieh Shan.
--   
--   Handle-based IO with the assured open/close protocol, see README This
--   file contains the Security kernel. See SafeHandlesTest.hs for tests.
--   This is the final solution: lightweight monadic regions with only
--   type-level enforcement of region discipline
module System.SafeHandles

-- | The IO monad with safe handles and regions (SIO) is implemented as the
--   monad transformer IORT (recursively) applied to IO.
--   
--   Each region maintains the state listing all open handles assigned to
--   the region. Since we already have IO, it is easy to implement the
--   state as a mutable list (IORef of the list) and make this reference a
--   pervasive environment. We could have used implicit parameters or
--   implicit configurations to pass that IORef around. Here, we use
--   ReaderT.
data IORT s m v
type SIO s = IORT s IO

-- | Our (safe) handle is labeled with the monad where it was created
data SHandle m :: (* -> *)
runSIO :: (forall s. SIO s v) -> IO v

-- | There is no explicit close operation. A handle is automatically closed
--   when its region is finished (normally or abnormally).
newRgn :: (RMonadIO m) => (forall s. IORT s m v) -> m v

-- | Lift from one IORT to an IORT in a children region... IORT should be
--   opaque to the user: hence this is not the instance of MonadTrans
liftSIO :: (Monad m) => IORT s m a -> IORT s1 (IORT s m) a

-- | Create a new handle and assign it to the current region One can use
--   liftIORT (newSHandle ...) to assign the handle to any parent region.
newSHandle :: (RMonadIO m) => FilePath -> IOMode -> IORT s m (SHandle (IORT s m))

-- | Duplicate a handle, returning a handle that can be used in the parent
--   region (and can be returned from the current region as the result).
--   This operation prolongs the life of a handle based on a _dynamic_
--   condition. If we know the lifetime of a handle statically, we can
--   execute liftSIO (newSHandle ...) to place the handle in the
--   corresponding region. If we don't know the lifetime of a handle
--   statically, we place it in the inner region, and then extend its
--   lifetime by reassigning to the parent region based on the dynamic
--   conditions.
shDup :: (RMonadIO m) => SHandle (IORT s1 (IORT s m)) -> IORT s1 (IORT s m) (SHandle (IORT s m))
data IOMode :: *
ReadMode :: IOMode
WriteMode :: IOMode
AppendMode :: IOMode
ReadWriteMode :: IOMode

-- | Safe-handle-based IO... The handle is assigned to the current region
--   or its ancestor. So, we have to verify that the label of the handle is
--   the prefix (perhaps improper) of the label of the monad (label of the
--   region).
shGetLine :: (MonadRaise m1 m2, RMonadIO m2) => SHandle m1 -> m2 String
shPutStrLn :: (MonadRaise m1 m2, RMonadIO m2) => SHandle m1 -> String -> m2 ()
shIsEOF :: (MonadRaise m1 m2, RMonadIO m2) => SHandle m1 -> m2 Bool

-- | It seems however that IOErrors don't invalidate the Handles. For
--   example, if EOF is reported, we may try to reposition the
--   <tt>file</tt> and read again. That's why in Posix, EOF and file errors
--   can be cleared.
shThrow :: (RMonadIO m) => Exception -> m a
shCatch :: (RMonadIO m) => m a -> (Exception -> m a) -> m a

-- | Useful for debugging
shReport :: (RMonadIO m) => String -> m ()

-- | make IORef available with SIO, so we may write tests that attempt to
--   leak handles and computations with handles via assignment
sNewIORef :: (RMonadIO m) => a -> m (IORef a)
sReadIORef :: (RMonadIO m) => IORef a -> m a
sWriteIORef :: (RMonadIO m) => IORef a -> a -> m ()
instance [overlap ok] (Monad m) => Monad (IORT s m)
instance [overlap ok] TypeCast2'' () a a
instance [overlap ok] (TypeCast2'' t a b) => TypeCast2' t a b
instance [overlap ok] (TypeCast2' () a b) => TypeCast2 a b
instance [overlap ok] TypeCast'' () a a
instance [overlap ok] (TypeCast'' t a b) => TypeCast' t a b
instance [overlap ok] (TypeCast' () a b) => TypeCast a b
instance [overlap ok] (RMonadIO m) => RMonadIO (IORT s m)
instance [overlap ok] (RMonadIO m) => RMonadIO (ReaderT r m)
instance [overlap ok] RMonadIO IO
instance [overlap ok] (Monad m2, TypeCast2 m2 (IORT s m2'), MonadRaise m1 m2') => MonadRaise m1 m2
instance [overlap ok] (Monad m) => MonadRaise m m


-- | Low-level IO operations These operations are either missing from the
--   GHC run-time library, or implemented suboptimally or heavy-handedly
module System.LowLevelIO

-- | Alas, GHC provides no function to read from Fd to an allocated buffer.
--   The library function fdRead is not appropriate as it returns a string
--   already. I'd rather get data from a buffer. Furthermore, fdRead (at
--   least in GHC) allocates a new buffer each time it is called. This is a
--   waste. Yet another problem with fdRead is in raising an exception on
--   any IOError or even EOF. I'd rather avoid exceptions altogether.
myfdRead :: Fd -> Ptr CChar -> ByteCount -> IO (Either Errno ByteCount)

-- | The following fseek procedure throws no exceptions.
myfdSeek :: Fd -> SeekMode -> FileOffset -> IO (Either Errno FileOffset)

-- | Haskell representation for <tt>errno</tt> values. The implementation
--   is deliberately exposed, to allow users to add their own definitions
--   of <a>Errno</a> values.
newtype Errno :: *
Errno :: CInt -> Errno

-- | poll if file descriptors have something to read Return the list of
--   read-pending descriptors
select'read'pending :: [Fd] -> IO (Either Errno [Fd])


-- | <a>http://okmij.org/ftp/Haskell/misc.html#sys_open</a>
--   
--   Haskell interface to sys_open.c: providing openFd and closeFd that can
--   deal with <tt>extended</tt> file names (which can name TCP and
--   bi-directional pipes in addition to the regular disk files)
--   <a>http://okmij.org/ftp/syscall-interpose.html#Application</a>
--   
--   Also included a useful utility read_line to read a NL-terminated line
--   from an Fd. It deliberately uses no handles and so never messes with
--   Fd (in particular, it doesn't put the file descriptor in the
--   non-blocking mode)
--   
--   Simple and reliable uni- and bi-directional pipes
--   
--   MySysOpen module offers a reliable, proven way of interacting with
--   another local or remote process via a unidirectional or bidirectional
--   channel. It supports pipes and Unix and TCP sockets. MySysOpen is a
--   simple and explicit alternative to the multi-threaded IO processing of
--   the GHC run-time system. The module is the Haskell binding to sys_open
--   -- the extended, user-level file opening interface.
--   
--   The second half of MySysOpen.hs contains several bi-directional
--   channel interaction tests. One checks repeated sending and receiving
--   of data; the amount of received data is intentionally large, about
--   510K. Two other tests interact with programs that are not specifically
--   written for interactive use, such as sort. The latter cannot produce
--   any output before it has read all of the input, accepting no input
--   terminator other than the EOF condition. One test uses shutdown to set
--   the EOF condition. The other test programs the handler for a custom
--   EOF indicator, literally in the file name of the communication pipe.
module System.SysOpen
mysysOpenFd :: FilePath -> OpenMode -> Maybe FileMode -> IO Fd
mysysCloseFd :: Fd -> IO ()

-- | Close the output direction of the bi-directional pipe
mysysCloseOut :: Fd -> IO ()
read_line :: [Char] -> Fd -> IO ([Char], [Char])


-- | 
--   <a>http://okmij.org/ftp/typed-formatting/FPrintScan.html#print-show</a>
--   
--   Generic polyvariadic printf in Haskell98
--   
--   This generalization of Text.Printf.printf is inspired by the message
--   of Evan Klitzke, who wrote on Haskell-Cafe about frequent occurrences
--   in his code of the lines like
--   
--   <pre>
--   infoM $ printf "%s saw %s with %s" (show x) (show y) (show z)
--   </pre>
--   
--   Writing show on and on quickly becomes tiresome. It turns out, we can
--   avoid these repeating show, still conforming to Haskell98.
--   
--   Our polyvariadic generic printf is like polyvariadic show with the
--   printf-like format string. Our printf handles values of any present
--   and future type for which there is a Show instance. For example:
--   
--   <pre>
--   t1 = unR $ printf "Hi there"
--   -- "Hi there"
--   </pre>
--   
--   <pre>
--   t2 = unR $ printf "Hi %s!" "there"
--   -- "Hi there!"
--   </pre>
--   
--   <pre>
--   t3 = unR $ printf "The value of %s is %s" "x" 3
--   -- "The value of x is 3"
--   </pre>
--   
--   <pre>
--   t4 = unR $ printf "The value of %s is %s" "x" [5]
--   -- "The value of x is [5]"
--   </pre>
--   
--   The unsightly unR appears solely for Haskell98 compatibility: flexible
--   instances remove the need for it. On the other hand, Evan Klitzke's
--   code post-processes the result of formatting with infoM, which can
--   subsume unR.
--   
--   A bigger problem with our generic printf, shared with the original
--   Text.Printf.printf, is partiality: The errors like passing too many or
--   too few arguments to printf are caught only at run-time. We can
--   certainly do better.
--   
--   Version: The current version is 1.1, June 5, 2009.
--   
--   References
--   
--   <ul>
--   <li>The complete source code with the tests. It was published in the
--   message posted on the Haskell-Cafe mailing list on Fri, 5 Jun 2009
--   00:57:00 -0700 (PDT)
--   <a>http://okmij.org/ftp/typed-formatting/GenPrintF.hs</a></li>
--   </ul>
module Text.GenPrintF

-- | Needed only for the sake of Haskell98 If we are OK with flexible
--   instances, this newtype can be disposed of
newtype RString
RString :: String -> RString
unR :: RString -> String
class SPrintF r
pr_aux :: (SPrintF r) => [FDesc] -> [String] -> r

-- | A very simple language of format descriptors
data FDesc
FD_lit :: String -> FDesc
FD_str :: FDesc
convert_to_fdesc :: String -> [FDesc]
instance Eq FDesc
instance Show FDesc
instance (Show a, SPrintF r) => SPrintF (a -> r)
instance SPrintF RString


-- | The final view to the typed sprintf and sscanf
--   
--   <a>http://okmij.org/ftp/typed-formatting/FPrintScan.html</a>
--   
--   This code defines a simple domain-specific language of string patterns
--   and demonstrates two interpreters of the language: for building
--   strings (sprintf) and parsing strings (sscanf). This code thus solves
--   the problem of typed printf/scanf sharing the same format string posed
--   by Chung-chieh Shan. This code presents scanf/printf interpreters in
--   the final style; it is thus the dual of the code in PrintScan.hs
--   
--   Version: The current version is 1.1, Sep 2, 2008.
--   
--   References
--   
--   <ul>
--   <li>The complete Haskell98 code with many examples.
--   <a>http://okmij.org/ftp/typed-formatting/PrintScanF.hs</a></li>
--   <li>The final view on typed sprintf and sscanf
--   <a>http://okmij.org/ftp/typed-formatting/PrintScanF.txt</a></li>
--   <li>The message posted on the Haskell mailing list on Tue, 2 Sep 2008
--   00:57:18 -0700 (PDT)</li>
--   </ul>
module Text.PrintScanF
class FormattingSpec repr
lit :: (FormattingSpec repr) => String -> repr a a
int :: (FormattingSpec repr) => repr a (Int -> a)
char :: (FormattingSpec repr) => repr a (Char -> a)
fpp :: (FormattingSpec repr) => PrinterParser b -> repr a (b -> a)
(^) :: (FormattingSpec repr) => repr b c -> repr a b -> repr a c
data PrinterParser a
PrinterParser :: (a -> String) -> (String -> Maybe (a, String)) -> PrinterParser a
fmt :: (FormattingSpec repr, Show b, Read b) => b -> repr a (b -> a)
newtype FPr a b
FPr :: ((String -> a) -> b) -> FPr a b
newtype FSc a b
FSc :: (String -> b -> Maybe (a, String)) -> FSc a b
sprintf :: FPr String b -> b
sscanf :: String -> FSc a b -> b -> Maybe a
showread :: (Show a, Read a) => PrinterParser a
prefix :: String -> String -> Maybe String
instance FormattingSpec FSc
instance FormattingSpec FPr


-- | <a>http://okmij.org/ftp/typed-formatting/FPrintScan.html#C-like</a>
--   
--   Safe and generic printf/scanf with C-like format string
--   
--   We implement printf that takes a C-like format string and the variable
--   number of other arguments. Unlike C of Haskell's printf, ours is
--   total: if the types or the number of the other arguments, the values
--   to format, does not match the format string, a type error is reported
--   at compile time. To the familiar format descriptors %s and %d we add
--   %a to format any showable value. The latter is like the format
--   descriptor ~a of Common Lisp. Likewise, we build scanf that takes a
--   C-like format string and the consumer function with the variable
--   number of arguments. The types and the number of the arguments must
--   match the format string; a type error is reported otherwise.
--   
--   Our approach is a variation of the safe printf and scanf described
--   elsewhere on this page. We use Template Haskell to translate the
--   format string to a phrase in the DSL of format descriptors. We use the
--   final approach to embed that DSL into Haskell.
--   
--   Unlike the safe printf explained in the Template Haskell
--   documentation, in our implementation, format descriptors are first
--   class. They can be built incrementally. The same descriptor can be
--   used both for printing and for parsing. Our printf and scanf are
--   user-extensible: library users can write functions to direct format
--   output to any suitable data sink, or to read parsed data from any
--   suitable data source such as string or a file. Finally, what is
--   formatted can be parsed back using the same format descriptor.
--   
--   Here are some of the tests from the test collection referenced below.
--   The evaluation result is given in the comments below each binding.
--   Example t31 shows that format descriptors are indeed first-class. The
--   definition t32, when uncommented, raises the shown type error because
--   the format descriptor does not match the type of the corresponding
--   argument.
module Text.TotalPrintF
spec :: String -> ExpQ
sprintf :: FPr String b -> b
sscanf :: String -> FSc a b -> b -> Maybe a
(^) :: (FormattingSpec repr) => repr b c -> repr a b -> repr a c
instance Eq FDesc
instance Show FDesc


-- | Type-safe printf and scanf with C-like formatting string We also
--   permit a generic format specifier %a to format or parse any showable
--   and readable value. Our format descriptors are first-class and can be
--   built incrementally. We can use the same format descriptor to format
--   to a string, to the standard output or any other data sink.
--   Furthermore, we can use the same format descriptor to parse from a
--   string or any data source. What we print we can parse, using the same
--   descriptor.
module Text.TFTest
newtype FPrIO a b
FPrIO :: ((IO () -> a) -> b) -> FPrIO a b
instance FormattingSpec FPrIO


-- | <a>http://okmij.org/ftp/typed-formatting/FPrintScan.html</a>
--   
--   The initial view to the typed sprintf and sscanf This code defines a
--   simple domain-specific language of string patterns and demonstrates
--   two interpreters of the language: for building strings (sprintf) and
--   parsing strings (sscanf). This code thus solves the problem of typed
--   printf/scanf sharing the same format string posed by Chung-chieh Shan.
--   
--   Version: The current version is 1.1, Aug 31, 2008.
--   
--   References
--   
--   <ul>
--   <li>The complete code with many examples.
--   <a>http://okmij.org/ftp/typed-formatting/PrintScan.hs</a></li>
--   <li>The initial view on typed sprintf and sscanf
--   <a>http://okmij.org/ftp/typed-formatting/PrintScanI.txt</a></li>
--   <li>The message with more explanations, posted on the Haskell mailing
--   list on Sun, 31 Aug 2008 19:40:41 -0700 (PDT)</li>
--   </ul>
module Text.PrintScan
data F a b
FLit :: String -> F a a
FInt :: F a (Int -> a)
FChr :: F a (Char -> a)
FPP :: PrinterParser b -> F a (b -> a)
(:^) :: F b c -> F a b -> F a c

-- | Printer<i>parsers (injection</i>projection pairs)
data PrinterParser a
PrinterParser :: (a -> String) -> (String -> Maybe (a, String)) -> PrinterParser a

-- | a bit of syntactic sugar to avoid hitting the Shift key too many a
--   time
fmt :: (Show b, Read b) => b -> F a (b -> a)

-- | The interpreter for printf It implements Asai's accumulator-less
--   alternative to Danvy's functional unparsing
intp :: F a b -> (String -> a) -> b

-- | The interpreter for scanf
ints :: F a b -> String -> b -> Maybe (a, String)
sprintf :: F String b -> b
sscanf :: String -> F a b -> b -> Maybe a

-- | The format specification is first-class. One can build format
--   specification incrementally This is not the case with OCaml's
--   printf/scanf (where the format specification has a weird typing and is
--   not first class).
--   
--   Primitive Printer/parsers
showread :: (Show a, Read a) => PrinterParser a

-- | A better prefixOf function prefix patt str --&gt; Just str' if the
--   String patt is the prefix of String str. The result str' is str with
--   patt removed Otherwise, the result is Nothing
prefix :: String -> String -> Maybe String


-- | Dynamic Epistemic Logic: solving the puzzles from Hans van Ditmarsch's
--   tutorial course on Dynamic Epistemic Logic, NASSLLI 2010, June 20,
--   2010. See also
--   
--   Dynamic Epistemic Logic and Knowledge Puzzles H.P. van Ditmarsch, W.
--   van der Hoek, and B.P. Kooi
--   <a>http://www.csc.liv.ac.uk/~wiebe/pubs/Documents/iccs.pdf</a>
--   
--   Epistemic Puzzles Hans van Ditmarsch
--   <a>http://www.cs.otago.ac.nz/staffpriv/hans/cosc462/logicpuzzlesB.pdf</a>
--   
--   We encode the statement of the problem as a filter on possible worlds.
--   The possible worlds consistent with the statement of the problem are
--   the solutions.
--   
--   <pre>
--   "Agent A does not know proposition phi" is interpreted
--   </pre>
--   
--   as the statement that for all worlds consistent with the propositions
--   A currently knows, phi is true in some but false in the others.
--   
--   <a>http://okmij.org/ftp/Algorithms.html#dyn-epistemology</a>
module Logic.DynEpistemology

-- | Problem 1 Anne and Bill each privately receive a natural number. Their
--   numbers are consecutive. The following truthful conversation takes
--   place:
--   
--   <pre>
--   Anne: I don't know your number
--   Bill: I don't know your number either
--   Anne: I know your number.
--   Bill: I know your number too.
--   </pre>
--   
--   If Anne has received the number 2, what was the number received by
--   Bill? This puzzle is also known as `Conway paradox': it appears that
--   Anne and Bill have truthfully made contradictory statements.
--   
--   A possible world for a problem 1: numbers received by Anne and Bill
type P1World = (Int, Int)

-- | The number Anne received in the world w
p1_anne :: P1World -> Int

-- | The number Bill received in the world w
p1_bill :: P1World -> Int

-- | An initial stream of possible worlds for problem 1
p1worlds :: (MonadPlus m) => m P1World

-- | Encoding the statement of the problem: the conversation steps. The
--   remaining possible world gives us the solution.
prob1 :: [P1World]

-- | A variation of the problem: Assuming the numbers don't exceed 100,
--   what are the numbers received by Anne and Bill? Again, the possible
--   worlds consistent with the statement of the problem are the solutions.
prob1a :: [P1World]

-- | Spelling out the <a>unique</a> condition, to demonstrate what it means
prob1a' :: [[P1World]]

-- | Problem 2
--   
--   Anne, Bill and Cath each have a positive natural number written on
--   their foreheads. They can only see the foreheads of others. One of the
--   numbers is the sum of the other two. All the previous is common
--   knowledge. The following truthful conversation takes place:
--   
--   <pre>
--   Anne: I don't know my number.
--   Bill: I don't know my number.
--   Cath: I don't know my number.
--   Anne: I now know my number, and it is 50.
--   </pre>
--   
--   What are the numbers of Bill and Cath? Math Horizons, November 2004.
--   Problem 182.
--   
--   A possible world for a problem 1: numbers received by Anne, Bill, and
--   Cath
type P2World = (Int, Int, Int)

-- | The number on Anne's forehead in the world w
p2_anne :: P2World -> Int

-- | If Anne sees the number x on Bill's forehead and the number y on
--   Cath's forehead, what numbers could be on Anne's forehead? In other
--   words, compute the set of possible worlds that are indistinguishable
--   from the world w as far as Anne is concerned.
p2_anne_keys :: P2World -> [P2World]

-- | The number on Bill's forehead in the world w
p2_bill :: P2World -> Int

-- | Which worlds Bill can't distinguish
p2_bill_keys :: P2World -> [P2World]

-- | The number on Cath's forehead in the world w
p2_cath :: P2World -> Int

-- | Ditto for Cath
p2_cath_keys :: P2World -> [P2World]

-- | An initial stream of possible worlds for problem 2. The code is naive
--   but hopefully obviously correct as it clearly corresponds to the
--   statement of the problem.
p2worlds :: (MonadPlus m) => m P2World

-- | Encoding the statement of the problem: the conversation steps. The
--   remaining possible world gives us the solution.
prob2 :: [P2World]

-- | Reverse application
choose :: (MonadPlus m) => [a] -> m a

-- | A stream of naturals
nat :: (MonadPlus m) => m Int

-- | A stream of integers starting with n
iota :: (MonadPlus m) => Int -> m Int

-- | Filter a set of possible worlds Given a proj function (yielding a set
--   of keys for a world w), return a stream of worlds that are not unique
--   with respect to their keys. That is, there are several worlds with the
--   same key. Our state is a set of quarantined worlds. When we receive a
--   world whose key we have not seen, we quarantine it. We release from
--   the quarantine when we encounter the same key again. Our function is
--   specialized to the List monad. In general, we need MonadMinus (see the
--   LogicT paper), of which List is an instance.
nonunique :: (Ord key) => (w -> [key]) -> [w] -> [w]

-- | Given a proj function (yielding a set of keys for a world w), return a
--   stream of worlds that are unique with respect to their keys. That is,
--   there is only one world for the key. We accept a termination
--   criterion. We terminate the stream once we have received the key for
--   which the criterion returns true. When we receive a world whose key we
--   have not seen, we quarantine it. We release from the quarantine when
--   the stream is terminated.
unique :: (Ord key) => (w -> [key]) -> (key -> Bool) -> [w] -> [w]

module Language.Fibration
class NFN a b
napp :: (NFN a b) => a -> b
class NFN1 a t b
napp1 :: (NFN1 a t b) => t -> a -> b
test_nfn1 :: Integer
class NFN2 a tl t tr b
napp2 :: (NFN2 a tl t tr b) => (tl, t, tr) -> a -> b
class NFN3 a tll tl tlr t trl tr trr b
napp3 :: (NFN3 a tll tl tlr t trl tr trr b) => ((tll, tl, tlr), t, (trl, tr, trr)) -> a -> b
test_nfn3 :: Integer
class FN s a b | s -> a, s -> b
app :: (FN s a b) => s -> a -> b
data L
L :: L
instance (FN u a t, FN v t b) => FN (u, v) a b
instance FN L Integer Integer
instance FN (Integer -> Integer) Integer Integer
instance FN (Float -> Integer) Float Integer
instance FN (Integer -> Float) Integer Float
instance NFN Integer Integer
instance (NFN2 a tll tl tlr t, NFN2 t trl tr trr b) => NFN3 a tll tl tlr t trl tr trr b
instance (NFN1 a tl t, NFN1 t tr b) => NFN2 a tl t tr b
instance (NFN a t, NFN t b) => NFN1 a t b
instance NFN Float Integer
instance NFN Integer Float


-- | <ul>
--   <li>Type representation, equality and the safe typecast: * the
--   above-the-board version of Data.Typeable</li>
--   </ul>
module Language.Typ

-- | <ul>
--   <li>The language of type representations: first-order and typed It is
--   quite like the language of int<i>neg</i>add we have seen before, but
--   it is now typed. It is first order: the language of simple types is
--   first order</li>
--   </ul>
class TSYM trepr
tint :: (TSYM trepr) => trepr Int
tarr :: (TSYM trepr) => trepr a -> trepr b -> trepr (a -> b)

-- | <ul>
--   <li>The view interpreter The first interpreter is to view the
--   types</li>
--   </ul>
newtype ShowT a
ShowT :: String -> ShowT a
view_t :: ShowT a -> String
newtype TQ t
TQ :: (forall trepr. (TSYM trepr) => trepr t) -> TQ t
unTQ :: TQ t -> forall trepr. (TSYM trepr) => trepr t
show_as :: TQ a -> a -> String

-- | The implementation of the interpreter ShowAs shows off the technique
--   of accumulating new TQ as we traverse the old one. We shall see more
--   examples later. One is again reminded of attribute grammars.
data ShowAs a
ShowAs :: (TQ a) -> (a -> String) -> ShowAs a
data Typ
Typ :: (TQ t) -> Typ
data TCOPY trep1 trep2 a
TCOPY :: (trep1 a) -> (trep2 a) -> TCOPY trep1 trep2 a
newtype EQU a b
EQU :: (forall c. c a -> c b) -> EQU a b
equ_cast :: EQU a b -> forall c. c a -> c b
refl :: EQU a a
tran :: EQU a u -> EQU u b -> EQU a b
newtype FS b a
FS :: EQU a b -> FS b a
unFS :: FS b a -> EQU a b
symm :: EQU a b -> EQU b a
newtype F1 t b a
F1 :: EQU t (a -> b) -> F1 t b a
unF1 :: F1 t b a -> EQU t (a -> b)
newtype F2 t a b
F2 :: EQU t (a -> b) -> F2 t a b
unF2 :: F2 t a b -> EQU t (a -> b)
eq_arr :: EQU a1 a2 -> EQU b1 b2 -> EQU (a1 -> b1) (a2 -> b2)
data AsInt a
AsInt :: (Maybe (EQU a Int)) -> AsInt a
as_int :: AsInt a -> c a -> Maybe (c Int)
data AsArrow a
AsArrow :: (TQ a) -> (Maybe (TQ b1, TQ b2, EQU a (b1 -> b2))) -> AsArrow a
as_arrow :: AsArrow a -> AsArrow a
newtype SafeCast a
SafeCast :: (forall b. TQ b -> Maybe (EQU a b)) -> SafeCast a
safe_gcast :: TQ a -> c a -> TQ b -> Maybe (c b)
data Dynamic
Dynamic :: (TQ t) -> t -> Dynamic
newtype Id a
Id :: a -> Id a
instance TSYM SafeCast
instance TSYM AsArrow
instance TSYM AsInt
instance (TSYM trep1, TSYM trep2) => TSYM (TCOPY trep1 trep2)
instance TSYM ShowAs
instance TSYM TQ
instance TSYM ShowT

module Language.ToTDPE


-- | <ul>
--   <li>Essentially, Haskell98! * Typed tagless-final interpreters for
--   simply-typed lambda-calculus * de Bruijn indices based on the code
--   accompanying the paper by Jacques Carette, Oleg Kiselyov, and
--   Chung-chieh Shan</li>
--   </ul>
module Language.TTFdB
class Symantics repr
int :: (Symantics repr) => Int -> repr h Int
add :: (Symantics repr) => repr h Int -> repr h Int -> repr h Int
z :: (Symantics repr) => repr (a, h) a
s :: (Symantics repr) => repr h a -> repr (any, h) a
lam :: (Symantics repr) => repr (a, h) b -> repr h (a -> b)
app :: (Symantics repr) => repr h (a -> b) -> repr h a -> repr h b
newtype R h a
R :: (h -> a) -> R h a
unR :: R h a -> h -> a
newtype S h a
S :: ([String] -> String) -> S h a
unS :: S h a -> [String] -> String
view :: S () a -> String
instance Symantics S
instance Symantics R


-- | Why all these extensions? I could've cheated a bit and gotten by
--   without the last four: the function typecheck below is partial anyway.
--   If we permit one sort of errors (when the deserialized term is
--   ill-typed), we may as well permit another sort of errors (a
--   closed-looking term turns out open), even if the latter sort of error
--   can't arise if our typecheck function is correct. due to the desire to
--   let GHC check some correctness properties I wanted to avoid
--   unnecessary errors and let GHC see the correctness of my code to a
--   larger extent
module Language.TypeCheck
data Tree
Leaf :: String -> Tree
Node :: String -> [Tree] -> Tree
data DynTerm repr h
DynTerm :: (TQ a) -> (repr h a) -> DynTerm repr h
read_t :: Tree -> Either String Typ
type VarName = String
data VarDesc t
VarDesc :: (TQ t) -> VarName -> VarDesc t
class Var gamma h | gamma -> h
findvar :: (Var gamma h, Symantics repr) => VarName -> gamma -> Either String (DynTerm repr h)
asTypeRepr :: t -> repr h t -> repr h t
typecheck :: (Symantics repr, Var gamma h) => Tree -> gamma -> Either String (DynTerm repr h)
newtype CL h a
CL :: (forall repr. (Symantics repr) => repr h a) -> CL h a
unCL :: CL h a -> forall repr. (Symantics repr) => repr h a
instance Eq Tree
instance Read Tree
instance Show Tree
instance Symantics CL
instance (Var gamma h) => Var (VarDesc t, gamma) (t, h)
instance Var () ()


-- | This is the Haskell version of symantics1.ml, for comparison ACG with
--   a more expressive semantic lexicon that includes multi-prompt
--   delimited continuations and the notion of evaluation. Types are
--   considered as a mere approximation rather than the complete
--   specification of grammatical composition.
--   
--   <ul>
--   <li><a>http://okmij.org/ftp/gengo/index.html#CAG</a></li>
--   </ul>
module Language.Symantics1

-- | Abstract signature, which defines base types, constants and their
--   types
data N
data NP
data S
data SM

-- | An interpretation of the base type btyp in the signature labeled by
--   lab
class Abstract c
john :: (Abstract c) => c (I c NP)
bill :: (Abstract c) => c (I c NP)
man :: (Abstract c) => c (I c N)
woman :: (Abstract c) => c (I c N)
see :: (Abstract c) => c (I c NP) -> c (I c NP) -> c (I c S)
love :: (Abstract c) => c (I c NP) -> c (I c NP) -> c (I c S)
every :: (Abstract c) => c (I c N) -> c (I c NP)
some :: (Abstract c) => c (I c N) -> c (I c NP)
dot :: (Abstract c) => c (I c S) -> c (I c SM)

-- | Example from Sec 4.3 of the ESSLLI Advanced ACG course.
--   
--   An interpretation of the abstract signature as the surface form:
--   strings
newtype LString a
LString :: a -> LString a
ccat :: LString String -> LString String -> LString String

-- | Semantic forms
data E
Ind :: String -> E
data T
Man :: E -> T
Woman :: E -> T
See :: E -> E -> T
Love :: E -> E -> T
And :: T -> T -> T
Imply :: T -> T -> T
Exists :: Varname -> T -> T
Forall :: Varname -> T -> T
type Varname = String

-- | The order of quantification
data QuantOrder
Uni_over_Exi :: QuantOrder
Exi_over_Uni :: QuantOrder
data SemEnv r
SemEnv :: Prompt r T -> Prompt r T -> QuantOrder -> Prompt r (Int -> CC r T) -> SemEnv r
puni :: SemEnv r -> Prompt r T
pexi :: SemEnv r -> Prompt r T
quant_order :: SemEnv r -> QuantOrder
pcnt :: SemEnv r -> Prompt r (Int -> CC r T)

-- | The Semantic monad
newtype SemM r a
SemM :: (ReaderT (SemEnv r) (CC r) a) -> SemM r a
unSem :: SemM r a -> SemEnv r -> CC r a
runSem :: QuantOrder -> (forall r. SemM r T) -> T

-- | <i>Movement</i> into the position of the prompt selected by psel
--   
--   Logical forms of sample terms in different semantic environment
--   
--   Auxiliary functions
app :: (Monad m) => m (a -> m b) -> m a -> m b

-- | Generate a new variable name
genvar :: SemM r Varname
shiftP :: Prompt r b -> ((a -> CC r b) -> CC r b) -> CC r a
instance Monad (SemM r)
instance Show T
instance Show E
instance (Show a) => Show (LString a)
instance Abstract (SemM r)
instance Abstract LString


-- | Typed tagless-final interpreters for Linear Lambda Calculus de Bruijn
--   indices
--   
--   Linear lambda-calculus: each bound variable is referenced exactly
--   once.
--   
--   Application: natural language semantics: (see for example, works by
--   Michael Moortgat) In particular, linear lambda calculi are extensively
--   used in Abstract Categorial Grammars.
--   
--   The following code would look better in ML: we can declare types F and
--   U in a signature. They will be assumed distinct. Yet an implementation
--   of the signature may conflate the F and U types; therefore, we can use
--   the interpreter for the ordinary lambda calculus. Alas, this approach
--   doesn't work for Haskell: If we use associated types to model
--   type-class local types F and U, the type checker does not consider
--   them necessarily distinct and generates equality constraint. That
--   breaks the abstraction! Terms like tl2 below would not be rejected.
--   
--   <a>http://okmij.org/ftp/tagless-final/course/course.html#linear</a>
module Language.LinearLC
newtype F a
F :: a -> F a
data U
Used :: U

-- | This semantics assumes that all values (that is, substitutable things)
--   are closed terms. This is the case in CBV or CBN calculi, which never
--   evaluate under lambda. Therefore, we do not qualify the types of
--   values by the env Otherwise, we have to qualify each type such as Int
--   or a with its env. For the unextended linear lambda calculus below, we
--   don't need to make this restriction as substitution of linear terms
--   into linear terms doesn't violate the linearity. But that property is
--   not stated syntactically below. Stating it syntactically does seem
--   possible, but the code becomes quite more complex.
class LSymantics repr
int :: (LSymantics repr) => Int -> repr hi hi Int
add :: (LSymantics repr) => repr hi h Int -> repr h ho Int -> repr hi ho Int
z :: (LSymantics repr) => repr (F a, h) (U, h) a
s :: (LSymantics repr) => repr hi ho a -> repr (any, hi) (any, ho) a
app :: (LSymantics repr) => repr hi h (a -> b) -> repr h ho a -> repr hi ho b

-- | The reason we separate out <a>lam</a> is to expose the type variables
--   hi and ho in the class head. A particular instance might be able to
--   attach constraints to hi and ho. The instance for the R interpreter
--   indeed attaches the HiHo constraint.
class LinearL repr hi ho
lam :: (LinearL repr hi ho) => repr (F a, hi) (U, ho) b -> repr hi ho (a -> b)

-- | Typed and tagless evaluator object term ==&gt; metalanguage value
newtype R hi ho a
R :: (hi -> (a, ho)) -> R hi ho a
unR :: R hi ho a -> hi -> (a, ho)

-- | Interpreting lam is quite more different Why? Why the simple approach
--   does not work? We need to produce ho when the lambda-form is produced,
--   not when it is applied. But ho of the lambda-form includes the ho for
--   the body of lambda. The latter is the result of evaluating the body;
--   but we get to evaluate the body of the lambda only when the
--   lambda-form is applied. But we need that ho now. Fortunately, types
--   are enough to produce ho. That's the purpose for the type class HiHo.
class HiHo hi ho
hiho :: (HiHo hi ho) => hi -> ho

-- | Another interpreter Literally the same as Symantics.S Although I later
--   decided to print linear lambdas as !x -&gt; ...
newtype S hi ho a
S :: ([String] -> String) -> S hi ho a
unS :: S hi ho a -> [String] -> String
view :: S () () a -> String

-- | Extension: the ordinary lam
newtype G a
G :: a -> G a
class GenL repr hi ho
glam :: (GenL repr hi ho) => repr (G a, hi) (G a, ho) b -> repr hi ho (a -> b)
class GZ repr
gz :: (GZ repr) => repr (G a, hi) (G a, hi) a
instance GenL S hi ho
instance GZ S
instance (HiHo hi ho) => HiHo (G a, hi) (G a, ho)
instance GZ R
instance (HiHo hi ho) => GenL R hi ho
instance LinearL S hi ho
instance LSymantics S
instance (HiHo hi ho) => LinearL R hi ho
instance (HiHo hi ho) => HiHo (F a, hi) (U, ho)
instance (HiHo hi ho) => HiHo (F a, hi) (F a, ho)
instance HiHo () ()
instance LSymantics R


-- | Embedding a higher-order domain-specific language (simply-typed
--   lambda-calculus with constants) with a selectable evaluation order:
--   Call-by-value, call-by-name, call-by-need in the same Final Tagless
--   framework This is the Haskell98 version of the code CB.hs located in
--   the same directory as this file
--   
--   
--   <a>http://okmij.org/ftp/tagless-final/tagless-typed.html#call-by-any</a>
module Language.CB98

-- | The (higher-order abstract) syntax of our DSL
type Arr exp a b = exp a -> exp b
class EDSL exp
lam :: (EDSL exp) => (exp a -> exp b) -> exp (Arr exp a b)
app :: (EDSL exp) => exp (Arr exp a b) -> exp a -> exp b
int :: (EDSL exp) => Int -> exp Int
add :: (EDSL exp) => exp Int -> exp Int -> exp Int
sub :: (EDSL exp) => exp Int -> exp Int -> exp Int

-- | A convenient abbreviation
let_ :: (EDSL exp) => exp a -> (exp a -> exp b) -> exp b

-- | A sample EDSL term
t :: (EDSL exp) => exp Int

-- | Interpretation of EDSL expressions as values of the host language
--   (Haskell) An EDSL expression of type a is interpreted as a Haskell
--   value of the type SName m a, SValue m a or SLazy m a, where m is a
--   Monad (the parameter of the interpretation).
newtype SName m a
SN :: m a -> SName m a
unSN :: SName m a -> m a
runName :: SName m a -> m a

-- | The addition (x <a>add</a> x) is performed twice because y is bound to
--   a computation, and y is evaluated twice
--   
--   A more elaborate example
t1 :: (EDSL exp) => exp Int

-- | A better example
t2 :: (EDSL exp) => exp Int

-- | The result of subtraction was not needed, and so it was not performed
--   OTH, (int 5 <a>add</a> int 5) was computed four times
--   
--   Call-by-value
newtype SValue m a
SV :: m a -> SValue m a
unSV :: SValue m a -> m a

-- | We reuse most of EDSL (SName) except for lam
vn :: SValue m x -> SName m x
nv :: SName m x -> SValue m x
runValue :: SValue m a -> m a

-- | We now evaluate the previously written tests t, t1, t2 under the new
--   interpretation
--   
--   Call-by-need
share :: (MonadIO m) => m a -> m (m a)
newtype SLazy m a
SL :: m a -> SLazy m a
unSL :: SLazy m a -> m a
ln :: SLazy m x -> SName m x
nl :: SName m x -> SLazy m x
runLazy :: SLazy m a -> m a
instance (MonadIO m) => EDSL (SLazy m)
instance (MonadIO m) => MonadIO (SLazy m)
instance (Monad m) => Monad (SLazy m)
instance (MonadIO m) => EDSL (SValue m)
instance (MonadIO m) => MonadIO (SValue m)
instance (Monad m) => Monad (SValue m)
instance (MonadIO m) => EDSL (SName m)
instance (MonadIO m) => MonadIO (SName m)
instance (Monad m) => Monad (SName m)


-- | Typed tagless-final interpreters for PCF Higher-order abstract syntax
--   based on the code accompanying the paper by Jacques Carette, Oleg
--   Kiselyov, and Chung-chieh Shan
--   
--   <a>http://okmij.org/ftp/tagless-final/course/course.html#TDPE</a>
module Language.TTF

-- | The language is simply-typed lambda-calculus with fixpoint and
--   constants. It is essentially PCF. The language is just expressive
--   enough for the power function. We define the language by parts, to
--   emphasize modularity. The core plus the fixpoint is the language
--   described in the paper
--   
--   <i>Hongwei Xi, Chiyan Chen, Gang Chen Guarded Recursive Datatype
--   Constructors, POPL2003</i>
--   
--   which is used to justify GADTs.
--   
--   <ul>
--   <li>Core language</li>
--   </ul>
class Symantics repr
int :: (Symantics repr) => Int -> repr Int
add :: (Symantics repr) => repr Int -> repr Int -> repr Int
lam :: (Symantics repr) => (repr a -> repr b) -> repr (a -> b)
app :: (Symantics repr) => repr (a -> b) -> repr a -> repr b
newtype R a
R :: a -> R a
unR :: R a -> a

-- | <ul>
--   <li>R is not a tag! It is a newtype The expression with unR _looks_
--   like tag introduction and elimination. But the function unR is
--   *total*. There is no run-time error is possible at all -- and this
--   fact is fully apparent to the compiler. Furthermore, at run-time, (R
--   x) is indistinguishable from x * R is a meta-circular interpreter This
--   is easier to see now. So, object-level addition is _truly_ the
--   metalanguage addition. Needless to say, that is efficient. * R never
--   gets stuck: no pattern-matching of any kind * R is total</li>
--   <li><i></i> Another interpreter</li>
--   </ul>
type VarCounter = Int
newtype S a
S :: (VarCounter -> String) -> S a
unS :: S a -> VarCounter -> String

-- | <ul>
--   <li>The crucial role of repr being a type constructor rather than just
--   a type. It lets some information about object-term representation
--   through (the type) while keeping the representation itself
--   hidden.</li>
--   <li><i></i> * Extensions of the language</li>
--   <li>Multiplication</li>
--   </ul>
class MulSYM repr
mul :: (MulSYM repr) => repr Int -> repr Int -> repr Int
class BoolSYM repr
bool :: (BoolSYM repr) => Bool -> repr Bool
leq :: (BoolSYM repr) => repr Int -> repr Int -> repr Bool
if_ :: (BoolSYM repr) => repr Bool -> repr a -> repr a -> repr a
class FixSYM repr
fix :: (FixSYM repr) => (repr a -> repr a) -> repr a
instance FixSYM S
instance BoolSYM S
instance MulSYM S
instance FixSYM R
instance BoolSYM R
instance MulSYM R
instance Symantics S
instance Symantics R


-- | Type-directed partial evaluation, Olivier Danvy, POPL96 *
--   <a>http://www.brics.dk/~danvy/tdpe-ln.pdf</a>
module Language.TDPE
data RR repr meta obj
RR :: (meta -> repr obj) -> (repr obj -> meta) -> RR repr meta obj
reify :: RR repr meta obj -> meta -> repr obj
reflect :: RR repr meta obj -> repr obj -> meta
base :: RR repr (repr a) a
(-->) :: (Symantics repr) => RR repr m1 o1 -> RR repr m2 o2 -> RR repr (m1 -> m2) (o1 -> o2)


-- | <ul>
--   
--   <li><a>http://okmij.org/ftp/tagless-final/course/course.html#CPS</a></li>
--   </ul>
--   
--   We demonstrate ordinary and administrative-redex--less call-by-value
--   Continuation Passing Style (CPS) transformation that assuredly
--   produces well-typed terms and is patently total.
--   
--   Our goal here is not to evaluate, view or serialize a tagless-final
--   term, but to transform it to another one. The result is a
--   tagless-final term, which we can interpret in multiple ways: evaluate,
--   view, or transform again. We first came across transformations of
--   tagless-final terms when we discussed pushing the negation down in the
--   simple, unityped language of addition and negation. The general case
--   is more complex. It is natural to require the result of transforming a
--   well-typed term be well-typed. In the tagless-final approach that
--   requirement is satisfied automatically: after all, only well-typed
--   terms are expressible. We require instead that a tagless-final
--   transformation be total. In particular, the fact that the
--   transformation handles all possible cases of the source terms must be
--   patently, syntactically clear. The complete coverage must be so clear
--   that the metalanguage compiler should be able to see that, without the
--   aid of extra tools.
--   
--   Since the only thing we can do with tagless-final terms is to
--   interpret them, the CPS transformer is written in the form of an
--   interpreter. It interprets source terms yielding transformed terms,
--   which can be interpreted in many ways. In particular, the terms can be
--   interpreted by the CPS transformer again, yielding 2-CPS terms. CPS
--   transformers are composable, as expected.
--   
--   A particular complication of the CPS transform is that the type of the
--   result is different from the type of the source term: the CPS
--   transform translates not only terms but also types. Moreover, the CPS
--   type transform and the arrow type constructor do not commute. For that
--   reason, we have to introduce an extended Symantics class, ESymantics,
--   which makes the meaning of function types dependent on a particular
--   interpreter. As it turns out, we do not have to re-write the existing
--   Symantics terms: we can re-interpret any old terms in the extended
--   Symantics. Conversely, any extended Symantics term can be interpreted
--   using any old, legacy, Symantics interpreter. The CPS transform is an
--   extended Symantics interpreter proper.
--   
--   The ordinary (Fischer or Plotkin) CPS transform introduces many
--   administrative redices, which make the result too hard to read. Danvy
--   and Filinski proposed a one-pass CPS transform, which relies on the
--   metalanguage to get rid of the administrative redices. The one-pass
--   CPS transform can be regarded as an example of the
--   normalization-by-evaluation.
module Language.CPS
class ESymantics repr
int :: (ESymantics repr) => Int -> repr Int
add :: (ESymantics repr) => repr Int -> repr Int -> repr Int
lam :: (ESymantics repr) => (repr a -> repr b) -> repr (Arr repr a b)
app :: (ESymantics repr) => repr (Arr repr a b) -> repr a -> repr b
newtype ExtSym repr a
ExtSym :: repr (GenArr repr a) -> ExtSym repr a
unExtSym :: ExtSym repr a -> repr (GenArr repr a)
newtype Lg repr a
Lg :: repr a -> Lg repr a
unLg :: Lg repr a -> repr a
legacy :: (Symantics repr) => (repr a -> b) -> Lg repr a -> b
newtype CPS repr w a
CPS :: repr (Arr repr (Arr repr a w) w) -> CPS repr w a
cpsr :: CPS repr w a -> repr (Arr repr (Arr repr a w) w)
cpsk :: (ESymantics repr) => (repr (Arr repr a w) -> repr w) -> CPS repr w a
appk :: (ESymantics repr) => CPS repr w a -> (repr a -> repr w) -> repr w
cpsv :: (ESymantics repr) => repr a -> CPS repr w a
newtype CPS1 repr w a
CPS1 :: ((repr a -> repr w) -> repr w) -> CPS1 repr w a
cps1r :: CPS1 repr w a -> (repr a -> repr w) -> repr w
reflect :: (ESymantics repr) => ((repr a -> repr w) -> repr w) -> repr (Arr repr (Arr repr a w) w)
cps1v :: (ESymantics repr) => repr a -> CPS1 repr w a
instance (ESymantics repr) => ESymantics (CPS1 repr w)
instance (ESymantics repr) => ESymantics (CPS repr w)
instance (Symantics repr) => ESymantics (Lg repr)
instance (ESymantics repr) => Symantics (ExtSym repr)


-- | <ul>
--   <li>Almost Haskell98. See CB98,hs for the genuine Haskell98 version
--   Here we use a few extensions to make the code prettier</li>
--   <li>Embedding a higher-order domain-specific language (simply-typed *
--   lambda-calculus with constants) with a selectable evaluation order: *
--   Call-by-value, call-by-name, call-by-need</li>
--   </ul>
module Language.CBAny

-- | The (higher-order abstract) syntax of our DSL
type Arr exp a b = exp a -> exp b
class EDSL exp
int :: (EDSL exp) => Int -> exp Int
add :: (EDSL exp) => exp Int -> exp Int -> exp Int
sub :: (EDSL exp) => exp Int -> exp Int -> exp Int
lam :: (EDSL exp) => (exp a -> exp b) -> exp (Arr exp a b)
app :: (EDSL exp) => exp (Arr exp a b) -> exp a -> exp b

-- | A convenient abbreviation (could've been called <tt>bind</tt>)
let_ :: (EDSL exp) => exp a -> (exp a -> exp b) -> exp b

-- | A sample EDSL term
t :: (EDSL exp) => exp Int
newtype S l m a
S :: m a -> S l m a
unS :: S l m a -> m a
data Name
runName :: S Name m a -> m a

-- | A more elaborate example
t1 :: (EDSL exp) => exp Int
t2 :: (EDSL exp) => exp Int
data Value
vn :: S Value m x -> S Name m x
nv :: S Name m x -> S Value m x
runValue :: S Value m a -> m a
share :: (MonadIO m) => m a -> m (m a)
data Lazy
ln :: S Lazy m x -> S Name m x
nl :: S Name m x -> S Lazy m x
runLazy :: S Lazy m a -> m a
instance (Monad m) => Monad (S l m)
instance (MonadIO m) => MonadIO (S l m)
instance (MonadIO m) => EDSL (S Lazy m)
instance (MonadIO m) => EDSL (S Value m)
instance (MonadIO m) => EDSL (S Name m)


-- | Embedding a higher-order domain-specific language (simply-typed
--   lambda-calculus with constants) with a selectable evaluation order:
--   Call-by-value, call-by-name, call-by-need in the same Final Tagless
--   framework
--   
--   
--   <a>http://okmij.org/ftp/tagless-final/tagless-typed.html#call-by-any</a>
module Language.CB

-- | Our EDSL is typed. EDSL types are built from the following two type
--   constructors:
data IntT
data (:->) a b

-- | We could have used Haskell's type Int and the arrow -&gt; constructor.
--   We would like to emphasize however that EDSL types need not be
--   identical to the host language types. To give the type system to EDSL,
--   we merely need <tt>labels</tt> -- which is what IntT and :-&gt; are
--   
--   The (higher-order abstract) syntax of our DSL
class EDSL exp
lam :: (EDSL exp) => (exp a -> exp b) -> exp (a :-> b)
app :: (EDSL exp) => exp (a :-> b) -> exp a -> exp b
int :: (EDSL exp) => Int -> exp IntT
add :: (EDSL exp) => exp IntT -> exp IntT -> exp IntT
sub :: (EDSL exp) => exp IntT -> exp IntT -> exp IntT

-- | A convenient abbreviation
let_ :: (EDSL exp) => exp a -> (exp a -> exp b) -> exp b

-- | A sample EDSL term
t :: (EDSL exp) => exp IntT

-- | Interpretation of EDSL types as host language types The type
--   interpretation function Sem is parameterized by <tt>m</tt>, which is
--   assumed to be a Monad.

-- | Interpretation of EDSL expressions as values of the host language
--   (Haskell) An EDSL expression of the type a is interpreted as a Haskell
--   value of the type S l m a, where m is a Monad (the parameter of the
--   interpretation) and l is the label for the evaluation order (one of
--   Name, Value, or Lazy). (S l m) is not quite a monad -- only up to the
--   Sem interpretation
newtype S l m a
S :: m (Sem m a) -> S l m a
unS :: S l m a -> m (Sem m a)

-- | Call-by-name
data Name
runName :: S Name m a -> m (Sem m a)

-- | Evaluating:
--   
--   <pre>
--   t = (lam $ \x -&gt; let_ (x `add` x)
--                        $ \y -&gt; y `add` y) `app` int 10
--   </pre>
--   
--   The addition (x <a>add</a> x) is performed twice because y is bound to
--   a computation, and y is evaluated twice
t1 :: (EDSL exp) => exp IntT

-- | A better example
t2 :: (EDSL exp) => exp IntT

-- | The result of subtraction was not needed, and so it was not performed
--   | OTH, (int 5 <a>add</a> int 5) was computed four times
data Value

-- | We reuse most of EDSL (S Name) except for lam
vn :: S Value m x -> S Name m x
nv :: S Name m x -> S Value m x
runValue :: S Value m a -> m (Sem m a)
share :: (MonadIO m) => m a -> m (m a)
data Lazy

-- | We reuse most of EDSL (S Name) except for lam
ln :: S Lazy m x -> S Name m x
nl :: S Name m x -> S Lazy m x
runLazy :: S Lazy m a -> m (Sem m a)
instance (MonadIO m) => EDSL (S Lazy m)
instance (MonadIO m) => EDSL (S Value m)
instance (MonadIO m) => EDSL (S Name m)


-- | Simply-typed Curry-style (nominal) lambda-calculus with integers and
--   zero-comparison Type inference. Hiding the single-threaded state via
--   simple algebraic transformations (beta-expansions).
--   
--   <a>http://okmij.org/ftp/Computation/Computation.html#teval</a>
module Language.TEval.TInfTM
data Typ
TInt :: Typ
(:>) :: !Typ -> !Typ -> Typ
TV :: TVarName -> Typ
type TVarName = Int
data Term
V :: VarName -> Term
L :: VarName -> Term -> Term
A :: Term -> Term -> Term
I :: Int -> Term
(:+) :: Term -> Term -> Term
IFZ :: Term -> Term -> Term -> Term
Fix :: Term -> Term
type VarName = String

-- | Type Environment: associating types with <tt>free</tt> term variables
type TEnv = [(VarName, Typ)]
env0 :: TEnv
lkup :: TEnv -> VarName -> Typ
ext :: TEnv -> (VarName, Typ) -> TEnv

-- | Type Variable Environment: associating types with <tt>free</tt> type
--   variables
data TVE
TVE :: Int -> (IntMap Typ) -> TVE

-- | Allocate a fresh type variable (see the first component of TVE)
newtv :: TVE -> (Typ, TVE)
tve0 :: TVE
tvlkup :: TVE -> TVarName -> Maybe Typ
tvext :: TVE -> (TVarName, Typ) -> TVE

-- | Type variables are logic variables: hypothetical reasoning
tvsub :: TVE -> Typ -> Typ

-- | <tt>shallow</tt> substitution; check if tv is bound to anything
--   <tt>substantial</tt>
tvchase :: TVE -> Typ -> Typ

-- | The unification. If unification failed, return the reason
unify :: Typ -> Typ -> TVE -> Either String TVE

-- | If either t1 or t2 are type variables, they are definitely unbound
unify' :: Typ -> Typ -> TVE -> Either String TVE

-- | Unify a free variable v1 with t2
unifyv :: TVarName -> Typ -> TVE -> Either String TVE

-- | The occurs check: if v appears free in t
occurs :: TVarName -> Typ -> TVE -> Bool

-- | Introducing the combinators to hide single-threaded state tve in one
--   case of teval' (the A case). The other cases stay as they are, to
--   illustrate that our transformation is fully compatible with the
--   earlier code.
type TVEM a = TVE -> (a, TVE)
(>>=) :: TVEM a -> (a -> TVEM b) -> TVEM b
return :: a -> TVEM a

-- | The expression abstracted from the last-but-one re-writing of the
--   A-clause below
--   
--   Type reconstruction: abstract evaluation
teval' :: TEnv -> Term -> (TVE -> (Typ, TVE))
teval :: TEnv -> Term -> Typ
instance Show TVE
instance Show Term
instance Eq Term
instance Show Typ
instance Eq Typ


-- | Simply-typed Curry-style (nominal) lambda-calculus with integers and
--   zero-comparison Type inference, of the type and of the environment,
--   aka conditional typechecking This code does not in general infer
--   polymorphic bindings as this is akin to higher-order unification.
--   
--   The benefit of the approach: we can handle _open_ terms. Some of them
--   we type check, and some of them we reject. The rejection means the
--   term cannot be typed in _any_ type environment.
--   
--   One often hears a complaint against typing: one can evaluate terms we
--   can't even type check. This code shows that we can type check terms we
--   can't even evaluate.
--   
--   We cannot evaluate open terms at all, but we can type check them,
--   inferring both the type as well as the _requirement_ on the
--   environments in which the term must be used.
--   
--   <a>http://okmij.org/ftp/Computation/Computation.html#teval</a>
module Language.TEval.TInfTEnv
data Typ
TInt :: Typ
(:>) :: !Typ -> !Typ -> Typ
TV :: TVarName -> Typ
type TVarName = Int
data Term
V :: VarName -> Term
L :: VarName -> Term -> Term
A :: Term -> Term -> Term
I :: Int -> Term
(:+) :: Term -> Term -> Term
IFZ :: Term -> Term -> Term -> Term
Fix :: Term -> Term
type VarName = String

-- | Type Environment: associating types with <tt>free</tt> term variables
type TEnv = [(VarName, Typ)]
env0 :: TEnv
lkup :: TEnv -> VarName -> Typ
ext :: TEnv -> (VarName, Typ) -> TEnv
unext :: TEnv -> VarName -> TEnv
env_map :: (Typ -> Typ) -> TEnv -> TEnv

-- | Merge two environment, using the given function to resolve the
--   conflicts, if any
env_fold_merge :: TEnv -> TEnv -> (Typ -> Typ -> seed -> Either err seed) -> seed -> Either err (TEnv, seed)

-- | Type Variable Environment: associating types with <tt>free</tt> type
--   variables
data TVE
TVE :: Int -> (IntMap Typ) -> TVE

-- | Allocate a fresh type variable (see the first component of TVE)
newtv :: TVE -> (Typ, TVE)
tve0 :: TVE
tvlkup :: TVE -> TVarName -> Maybe Typ
tvext :: TVE -> (TVarName, Typ) -> TVE

-- | Type variables are logic variables: hypothetical reasoning
tvsub :: TVE -> Typ -> Typ

-- | <tt>shallow</tt> substitution; check if tv is bound to anything
--   <tt>substantial</tt>
tvchase :: TVE -> Typ -> Typ

-- | The unification. If unification failed, return the reason
unify :: Typ -> Typ -> TVE -> Either String TVE

-- | If either t1 or t2 are type variables, they are definitely unbound
unify' :: Typ -> Typ -> TVE -> Either String TVE

-- | Unify a free variable v1 with t2
unifyv :: TVarName -> Typ -> TVE -> Either String TVE

-- | The occurs check: if v appears free in t
occurs :: TVarName -> Typ -> TVE -> Bool
merge_env :: TEnv -> TEnv -> (TVE -> (TEnv, TVE))

-- | Type reconstruction: abstract evaluation
teval' :: Term -> (TVE -> (Typ, TEnv, TVE))

-- | Resolve all type variables, as far as possible
teval :: Term -> (Typ, TEnv)
instance Show TVE
instance Show Term
instance Eq Term
instance Show Typ
instance Eq Typ


-- | Simply-typed Curry-style (nominal) lambda-calculus with integers and
--   zero-comparison Type inference
--   
--   <a>http://okmij.org/ftp/Computation/Computation.html#teval</a>
module Language.TEval.TInfT
data Typ
TInt :: Typ
(:>) :: !Typ -> !Typ -> Typ
TV :: TVarName -> Typ
type TVarName = Int
data Term
V :: VarName -> Term
L :: VarName -> Term -> Term
A :: Term -> Term -> Term
I :: Int -> Term
(:+) :: Term -> Term -> Term
IFZ :: Term -> Term -> Term -> Term
Fix :: Term -> Term
type VarName = String

-- | Type Environment: associating types with <tt>free</tt> term variables
type TEnv = [(VarName, Typ)]
env0 :: TEnv
lkup :: TEnv -> VarName -> Typ
ext :: TEnv -> (VarName, Typ) -> TEnv
data TVE
TVE :: Int -> (IntMap Typ) -> TVE
newtv :: TVE -> (Typ, TVE)
tve0 :: TVE
tvlkup :: TVE -> TVarName -> Maybe Typ
tvext :: TVE -> (TVarName, Typ) -> TVE

-- | Type variables are logic variables: hypothetical reasoning
tvsub :: TVE -> Typ -> Typ

-- | <tt>shallow</tt> substitution; check if tv is bound to anything
--   <tt>substantial</tt>
tvchase :: TVE -> Typ -> Typ

-- | The unification. If unification failed, return the reason
unify :: Typ -> Typ -> TVE -> Either String TVE

-- | If either t1 or t2 are type variables, they are definitely unbound
unify' :: Typ -> Typ -> TVE -> Either String TVE

-- | Unify a free variable v1 with t2
unifyv :: TVarName -> Typ -> TVE -> Either String TVE

-- | The occurs check: if v appears free in t
occurs :: TVarName -> Typ -> TVE -> Bool

-- | Type reconstruction: abstract evaluation
teval' :: TEnv -> Term -> (TVE -> (Typ, TVE))

-- | Resolve all type variables, as far as possible
teval :: TEnv -> Term -> Typ
instance Show TVE
instance Show Term
instance Eq Term
instance Show Typ
instance Eq Typ


-- | Simply-typed Curry-style (nominal) lambda-calculus with integers and
--   zero-comparison Let-polymorphism via type schemes Type inference
--   
--   <a>http://okmij.org/ftp/Computation/Computation.html#teval</a>
module Language.TEval.TInfLetP
data Typ
TInt :: Typ
(:>) :: !Typ -> !Typ -> Typ
TV :: TVarName -> Typ
type TVarName = Int
data TypS
TypS :: [TVarName] -> Typ -> TypS
data Term
V :: VarName -> Term
L :: VarName -> Term -> Term
A :: Term -> Term -> Term
I :: Int -> Term
(:+) :: Term -> Term -> Term
IFZ :: Term -> Term -> Term -> Term
Fix :: Term -> Term
Let :: (VarName, Term) -> Term -> Term
type VarName = String

-- | Type Environment: associating *would-be* types with <tt>free</tt> term
--   variables
type TEnv = [(VarName, TypS)]
env0 :: TEnv
lkup :: TEnv -> VarName -> TypS
ext :: TEnv -> (VarName, TypS) -> TEnv

-- | Type Variable Environment: associating types with <tt>free</tt> type
--   variables
data TVE
TVE :: Int -> (IntMap Typ) -> TVE

-- | TVE is the state of a monadic computation
type TVEM = State TVE

-- | Allocate a fresh type variable (see the first component of TVE)
newtv :: TVEM Typ
tve0 :: TVE
tvlkup :: TVE -> TVarName -> Maybe Typ
tvext :: TVE -> (TVarName, Typ) -> TVE

-- | TVE domain predicate: check to see if a TVarName is in the domain of
--   TVE
tvdomainp :: TVE -> TVarName -> Bool

-- | Give the list of all type variables that are allocated in TVE but not
--   bound there
tvfree :: TVE -> [TVarName]

-- | Type variables are logic variables: hypothetical reasoning
tvsub :: TVE -> Typ -> Typ

-- | <tt>shallow</tt> substitution; check if tv is bound to anything
--   <tt>substantial</tt>
tvchase :: TVE -> Typ -> Typ

-- | The unification. If unification failed, return the reason
unify :: Typ -> Typ -> TVE -> Either String TVE

-- | If either t1 or t2 are type variables, they are definitely unbound
unify' :: Typ -> Typ -> TVE -> Either String TVE

-- | Unify a free variable v1 with t2
unifyv :: TVarName -> Typ -> TVE -> Either String TVE

-- | The occurs check: if v appears free in t
occurs :: TVarName -> Typ -> TVE -> Bool

-- | Compute (quite unoptimally) the characteristic function of the set
--   forall tvb in fv(tve_before). Union fv(tvsub(tve_after,tvb))
tvdependentset :: TVE -> TVE -> (TVarName -> Bool)

-- | Monadic version of unify
unifyM :: Typ -> Typ -> (String -> String) -> TVEM ()

-- | Given a type scheme, that is, the type t and the list of type
--   variables tvs, for every tvs, replace all of its occurrences in t with
--   a fresh type variable. We do that by creating a substitution tve and
--   applying it to t.
instantiate :: TypS -> TVEM Typ

-- | Given a typechecking action ta yielding the type t, return the type
--   scheme quantifying over _truly free_ type variables in t with respect
--   to TVE that existed before the typechecking action began. Let
--   tve_before is TVE before the type checking action is executed, and
--   tve_after is TVE after the action. A type variable tv is truly free if
--   it is free in tve_after and remains free if the typechecking action
--   were executed in any tve extending tve_before with arbitrary binding
--   to type variables free in tve_before. To be more precise, a type
--   variable tv is truly free with respect to tve_before if: tv notin
--   domain(tve_after) forall tvb in fv(tve_before). tv notin
--   fv(tvsub(tve_after,tvb)) In other words, tv is truly free if it is
--   free and <tt>independent</tt> of tve_before.
--   
--   Our goal is to reproduce the behavior in TInfLetI.hs:
--   generalize/instantiate should mimic multiple executions of the
--   typechecking action. That means we should quantify over all type
--   variables created by ta that are independent of the type environment
--   in which the action may be executed.
generalize :: TVEM Typ -> TVEM TypS

-- | Return the list of type variables in t (possibly with duplicates)
freevars :: Typ -> [TVarName]

-- | Type reconstruction: abstract evaluation
teval' :: TEnv -> Term -> TVEM Typ

-- | Resolve all type variables, as far as possible, and generalize We
--   assume teval will be used for top-level expressions where
--   generalization is appropriate.
teval :: TEnv -> Term -> TypS

-- | non-generalizing teval (as before)
tevalng :: TEnv -> Term -> Typ
instance Show TVE
instance Show Term
instance Eq Term
instance Show TypS
instance Show Typ
instance Eq Typ


-- | Simply-typed Curry-style (nominal) lambda-calculus with integers and
--   zero-comparison Let-polymorphism via inlining Type inference
--   
--   <a>http://okmij.org/ftp/Computation/Computation.html#teval</a>
module Language.TEval.TInfLetI
data Typ
TInt :: Typ
(:>) :: !Typ -> !Typ -> Typ
TV :: TVarName -> Typ
type TVarName = Int
data Term
V :: VarName -> Term
L :: VarName -> Term -> Term
A :: Term -> Term -> Term
I :: Int -> Term
(:+) :: Term -> Term -> Term
IFZ :: Term -> Term -> Term -> Term
Fix :: Term -> Term
Let :: (VarName, Term) -> Term -> Term
type VarName = String

-- | Type Environment: associating *would-be* types with <tt>free</tt> term
--   variables
type TEnv = [(VarName, TVEM Typ)]
env0 :: TEnv
lkup :: TEnv -> VarName -> TVEM Typ
ext :: TEnv -> (VarName, TVEM Typ) -> TEnv

-- | Type Variable Environment: associating types with <tt>free</tt> type
--   variables
data TVE
TVE :: Int -> (IntMap Typ) -> TVE

-- | TVE is the state of a monadic computation
type TVEM = State TVE

-- | Allocate a fresh type variable (see the first component of TVE)
newtv :: TVEM Typ
tve0 :: TVE
tvlkup :: TVE -> TVarName -> Maybe Typ
tvext :: TVE -> (TVarName, Typ) -> TVE

-- | Type variables are logic variables: hypothetical reasoning
tvsub :: TVE -> Typ -> Typ

-- | <tt>shallow</tt> substitution; check if tv is bound to anything
--   <tt>substantial</tt>
tvchase :: TVE -> Typ -> Typ

-- | The unification. If unification failed, return the reason
unify :: Typ -> Typ -> TVE -> Either String TVE

-- | If either t1 or t2 are type variables, they are definitely unbound
unify' :: Typ -> Typ -> TVE -> Either String TVE

-- | Unify a free variable v1 with t2
unifyv :: TVarName -> Typ -> TVE -> Either String TVE

-- | The occurs check: if v appears free in t
occurs :: TVarName -> Typ -> TVE -> Bool

-- | Monadic version of unify
unifyM :: Typ -> Typ -> (String -> String) -> TVEM ()

-- | Type reconstruction: abstract evaluation
teval' :: TEnv -> Term -> TVEM Typ

-- | Resolve all type variables, as far as possible
teval :: TEnv -> Term -> Typ
instance Show TVE
instance Show Term
instance Eq Term
instance Show Typ
instance Eq Typ


-- | Simply-typed Church-style (nominal) lambda-calculus with integers and
--   zero-comparison Type reconstruction, for all subterms
--   
--   <a>http://okmij.org/ftp/Computation/Computation.html#teval</a>
module Language.TEval.TEvalNR
data Typ
TInt :: Typ
(:>) :: !Typ -> !Typ -> Typ
data Term
V :: VarName -> Term
L :: VarName -> Typ -> Term -> Term
A :: Term -> Term -> Term
I :: Int -> Term
(:+) :: Term -> Term -> Term
IFZ :: Term -> Term -> Term -> Term
Fix :: Term -> Term
type VarName = String

-- | Type Environment: associating types with <tt>free</tt> variables
type TEnv = [(VarName, Typ)]
env0 :: TEnv
lkup :: TEnv -> VarName -> Typ
ext :: TEnv -> (VarName, Typ) -> TEnv

-- | A virtual typed AST: associating a type to each subterm
type TermIndex = [Int]
type Typs = Map TermIndex Typ
topterm :: Typ -> Typs
toptyp :: Typs -> Typ
shift :: Int -> Typs -> Typs

-- | Type reconstruction: abstract evaluation
teval :: TEnv -> Term -> Typs
instance Show Term
instance Eq Term
instance Show Typ
instance Eq Typ


-- | Simply-typed Church-style (nominal) lambda-calculus with integers and
--   zero-comparison Type checking
--   
--   <a>http://okmij.org/ftp/Computation/Computation.html#teval</a>
module Language.TEval.TEvalNC
data Typ
TInt :: Typ
(:>) :: !Typ -> !Typ -> Typ
data Term
V :: VarName -> Term
L :: VarName -> Typ -> Term -> Term
A :: Term -> Term -> Term
I :: Int -> Term
(:+) :: Term -> Term -> Term
IFZ :: Term -> Term -> Term -> Term
Fix :: Term -> Term
type VarName = String

-- | Type Environment: associating types with <tt>free</tt> variables
type TEnv = [(VarName, Typ)]
env0 :: TEnv
lkup :: TEnv -> VarName -> Typ
ext :: TEnv -> (VarName, Typ) -> TEnv

-- | Type reconstruction: abstract evaluation
teval :: TEnv -> Term -> Typ
instance Show Term
instance Eq Term
instance Show Typ
instance Eq Typ


-- | Tagless Typed lambda-calculus with integers and the conditional in the
--   higher-order abstract syntax. Haskell itself ensures the object terms
--   are well-typed. Here we use GADT: This file is not in Haskell98
--   
--   <a>http://okmij.org/ftp/Computation/Computation.html#teval</a>
module Language.TEval.EvalTaglessI
data Term t
V :: t -> Term t
L :: (Term t1 -> Term t2) -> Term (t1 -> t2)
A :: Term (t1 -> t2) -> Term t1 -> Term t2
I :: Int -> Term Int
(:+) :: Term Int -> Term Int -> Term Int
IFZ :: Term Int -> Term t -> Term t -> Term t
Fix :: Term ((a -> b) -> (a -> b)) -> Term (a -> b)

-- | We no longer need variables or the environment and we do normalization
--   by evaluation.
--   
--   Denotational semantics. Why?
evald :: Term t -> t

-- | Operational semantics. Why? GADT are still implemented imperfectly: we
--   the default case in case statements (with cannot happen error), to
--   avoid the warning about inexhaustive pattern match -- although these
--   case-brances can never be executed. Why?
evalo :: Term t -> Term t
instance Show (Term t)


-- | Tagless Typed lambda-calculus with integers and the conditional in the
--   higher-order abstract syntax. Haskell itself ensures the object terms
--   are well-typed. Here we use the tagless final approach.
--   
--   <a>http://okmij.org/ftp/Computation/Computation.html#teval</a>
module Language.TEval.EvalTaglessF
class Symantics repr
l :: (Symantics repr) => (repr t1 -> repr t2) -> repr (t1 -> t2)
a :: (Symantics repr) => repr (t1 -> t2) -> repr t1 -> repr t2
i :: (Symantics repr) => Int -> repr Int
(+:) :: (Symantics repr) => repr Int -> repr Int -> repr Int
ifz :: (Symantics repr) => repr Int -> repr t -> repr t -> repr t
fix :: (Symantics repr) => repr ((a -> b) -> (a -> b)) -> repr (a -> b)

-- | Since we rely on the metalanguage for typechecking and hence type
--   generalization, we have to use `let' of the metalanguage.
--   
--   It is quite challenging to show terms. Yet, in contrast to the
--   GADT-based approach (EvalTaglessI.hs), we are able to do that, without
--   extending our language with auxiliary syntactic forms. Incidentally,
--   showing of terms is just another way of _evaluating_ them, to strings.
type VarCount = Int
newtype S t
S :: (VarCount -> (String, VarCount)) -> S t

-- | We no longer need variables or the environment and we do normalization
--   by evaluation.
--   
--   Denotational semantics. Why?
newtype D t
D :: t -> D t
evald :: D t -> t
instance Symantics D
instance Symantics S


-- | Untyped (nominal) lambda-calculus with integers and the conditional
--   
--   <a>http://okmij.org/ftp/Computation/Computation.html#teval</a>
--   
--   <ul>
--   <li><i>The Abstract of the lecture notes</i> We expound a view of type
--   checking as evaluation with `abstract values'. Whereas dynamic
--   semantics, evaluation, deals with (dynamic) values like 0, 1, etc.,
--   static semantics, type checking, deals with approximations like int. A
--   type system is sound if it correctly approximates the dynamic behavior
--   and predicts its outcome: if the static semantics predicts that a term
--   has the type int, the dynamic evaluation of the term, if it
--   terminates, will yield an integer.</li>
--   </ul>
--   
--   As object language, we use simply-typed and let-polymorphic lambda
--   calculi with integers and integer operations as constants. We use
--   Haskell as a metalanguage in which to write evaluators, type checkers,
--   type reconstructors and inferencers for the object language.
--   
--   We explore the deep relation between parametric polymorphism and
--   <tt>inlining</tt>. Polymorphic type checking then is an optimization
--   allowing us to type check a polymorphic term at the place of its
--   definition rather than at the places of its use.
--   
--   Joint work with Chung-chieh Shan.
--   
--   Version The current version is 1.1, July 2008. References lecture.pdf
--   [199K]
module Language.TEval.EvalN
data Term
V :: VarName -> Term
L :: VarName -> Term -> Term
A :: Term -> Term -> Term
I :: Int -> Term
(:+) :: Term -> Term -> Term
IFZ :: Term -> Term -> Term -> Term
type VarName = String

-- | Environment: associating values with <tt>free</tt> variables
type Env = [(VarName, Value)]
env0 :: Env
lkup :: Env -> VarName -> Value
ext :: Env -> (VarName, Value) -> Env
data Value
VI :: Int -> Value
VC :: (Value -> Value) -> Value

-- | Denotational semantics. Why? How to make it operational?
eval :: Env -> Term -> Value
instance Show Term
instance Eq Term
instance Show Value


-- | A model of the evaluation of logic programs (i.e., resolving Horn
--   clauses)
--   
--   The point is not to re-implement Prolog with all the conveniences but
--   to formalize evaluation strategies such as SLD, SLD-interleaving, and
--   others. The formalization is aimed at reasoning about termination and
--   solution sequences. See App A and B of the full FLOPS 2008 paper (the
--   file arithm.pdf in this directory).
module Language.DefinitionTree

-- | A logic var is represented by a pair of an integer and a list of
--   `predicate marks' (which are themselves integers). Such an odd
--   representation is needed to ensure the standardization apart:
--   different instances of a clause must have distinctly renamed
--   variables. Unlike Claessen, we get by without the state monad to
--   generate unique variable names (labels). See the discussion and
--   examples in the <tt>tests</tt> section below. Our main advantage is
--   that we separate the naming of variables from the evaluation strategy.
--   Evaluation no longer cares about generating fresh names, which notably
--   simplifies the analysis of the strategies. Logic vars are typed,
--   albeit phantomly.
type VStack = [Int]
type LogicVar term = (Int, VStack)

-- | A finite map from vars to terms (parameterized over the domain of
--   terms)
type Subst term = Map (LogicVar term) term

-- | Formulas
--   
--   A formula describes a finite or _infinite_ AND-OR tree that encodes
--   the logic-program clauses that may be needed to evaluate a particular
--   goal. We represent a goal g(t1,...,tn) by a combination of the goal
--   g(X1,...,Xn), whose arguments are distinct fresh logic variables, and
--   a substitution {Xi=ti}. For a goal g(X1,...,Xn), a |Formula| encodes
--   all the clauses of the logic program that could possibly prove g, in
--   their order. Each clause
--   
--   <pre>
--   g(t1,...,tn) :- b1(t11,...,t1m), ...
--   </pre>
--   
--   is represented by the (guarding) substitution {Xi=ti, Ykj=tkj} and the
--   sequence of the goals bk(Yk1,...,Ykm) in the body. Each of these goals
--   is again encoded as a |Formula|. All variables in the clauses are
--   renamed to ensure the standardization apart.
--   
--   Our trees are similar to Antoy's definitional trees, used to encode
--   rewriting rules and represent control strategies in term-rewriting
--   systems and _functional logic_ programming. However, in definitional
--   trees, function calls can be nested, and patterns are linear.
--   
--   The translation from Prolog is straightforward; the first step is to
--   re-write clauses so that the arguments of each goal are logic
--   variables: A fact
--   
--   <pre>
--   g(term).
--   </pre>
--   
--   is converted to
--   
--   <pre>
--   g(X) :- X = term.
--   </pre>
--   
--   A clause
--   
--   <pre>
--   g(term) :- g1(term1), g2(term2).
--   </pre>
--   
--   is converted to
--   
--   <pre>
--   g(X) :- X = term, _V1 = term1, g1(_V1), _V2=term2, g2(_V2).
--   </pre>
--   
--   See the real examples at the end
--   
--   A formula (parameterized by the domain of terms) is an OR-sequence of
--   clauses
data Formula term
Fail :: Formula term
(:+:) :: (Clause term) -> (Formula term) -> Formula term

-- | A clause is a guarded body; the latter is an AND-sequence of formulas
data Clause term
G :: (Subst term) -> (Body term) -> Clause term
data Body term
Fact :: Body term
(:*:) :: (Formula term) -> (Body term) -> Body term

-- | The evaluation process starts with a formula and the initial
--   substitution, which together represent a goal. The guarding
--   substitution of the clause conjoins with the current substitution to
--   yield the substitution for the evaluation of the body. The conjunction
--   of substitutions may lead to a contradiction, in which case the clause
--   is skipped (<tt>pruned</tt>).
--   
--   Evaluation as pruning: we traverse a tree and prune away failed
--   branches
prune :: (Unifiable term) => Formula term -> Subst term -> Formula term
prunec :: (Unifiable term) => Clause term -> Subst term -> Maybe (Clause term)

-- | A different evaluator: Evaluate a tree to a stream (lazy list) given
--   the initial substitution s. Here we use the SLD strategy.
eval :: (Unifiable term) => Formula term -> Subst term -> [Subst term]

-- | Same as above, using the SLD-interleaving strategy. See Definition 3.1
--   of the LogicT paper (ICFP05)
evali :: (Unifiable term) => Formula term -> Subst term -> [Subst term]

-- | Evaluation, substitutions and unification are parametric over terms
--   (term algebra), provided the following two operations are defined. We
--   should be able to examine a term and determine if it is a variable or
--   a constructor (represented by an integer) applied to a sequence of
--   zero or more terms. Conversely, given a constructor (represented by an
--   integer) and a list of terms-children we should be able to build a
--   term. The two operations must satisfy the laws:
--   
--   <pre>
--   either id build . classify === id
--   classify . build === Right
--   </pre>
class Unifiable term
classify :: (Unifiable term) => term -> Either (LogicVar term) (Int, [term])
build :: (Unifiable term) => (Int, [term]) -> term

-- | building substitutions
bv :: LogicVar term -> term -> Subst term
ins :: Subst term -> (LogicVar term, term) -> Subst term

-- | Apply a substitution to a term
sapp :: (Unifiable term) => Subst term -> term -> term

-- | Conjoin two substitutions (see Defn 1 of the FLOPS 2008 paper). We
--   merge two substitutions and solve the resulting set of equations,
--   returning Nothing if the two original substitutions are contradictory.
unify :: (Unifiable term) => Subst term -> Subst term -> Maybe (Subst term)

-- | Solve the equations using the naive realization of the Martelli and
--   Montanari process
solve :: (Unifiable term) => Subst term -> [(Either (LogicVar term) term, term)] -> Maybe (Subst term)

-- | Unary numerals
data UN
UNv :: (LogicVar UN) -> UN
UZ :: UN
US :: UN -> UN

-- | Encoding of variable names to ensure standardization apart. A clause
--   such as genu(X) or add(X,Y,Z) may appear in the tree (infinitely) many
--   times. We must ensure that each instance uses distinct logic
--   variables. To this end, we name variables by a pair (Int, VStack)
--   whose first component is the local label of a variable within a
--   clause. VStack is a path from the root of the tree to the current
--   occurrence of the clause in the tree. Each predicate along the path is
--   represented by an integer label (0 for genu, 1 for add, 2 for mul,
--   etc). To <tt>pass</tt> arguments to a clause, we add to the current
--   substitution the bindings for the variables of that clause. See the
--   genu' example below: whereas (0,h) is the label of the variable X in
--   the current instance of genu, (0,genu_mark:h) is X in the callee.
--   
--   A logic program
--   
--   <pre>
--   genu([]).
--   genu([u|X]) :- genu(X).
--   </pre>
--   
--   and the goal genu(X) are encoded as follows. The argument of genu' is
--   the path of the current instance of genu' from the top of the AND-OR
--   tree.
genu :: Formula UN
add :: VStack -> Formula UN
mul :: VStack -> Formula UN
instance Eq UN
instance Show UN
instance Unifiable UN


-- | 
--   <a>http://okmij.org/ftp/Computation/lambda-calc.html#haskell-type-level</a>
--   
--   This is the first message in a series on arbitrary type/kind-level
--   computations in the present-day Haskell, and on using of so computed
--   types to give signatures to terms and to drive the selection of
--   overloaded functions. We can define the type TD N to be the type of a
--   tree fib(N)-level deep, and instantiate the read function for the tree
--   of that type. The type computations are largely expressed in a
--   functional language not too unlike Haskell itself.
--   
--   In this message we implement call-by-value lambda-calculus with
--   booleans, naturals and case-discrimination. The distinct feature of
--   our implementation, besides its simplicity, is the primary role of
--   type application rather than that of abstraction. Yet we trivially
--   represent closures and higher-order functions. We use proper names for
--   function arguments (rather than deBruijn indices), and yet we avoid
--   the need for fresh name generation, name comparison, and
--   alpha-conversion. We have no explicit environment and no need to
--   propagate and search it, and yet we can partially apply functions.
--   
--   Our implementation fundamentally relies on the connection between
--   polymorphism and abstraction, and takes the full advantage of the
--   type-lambda implicitly present in Haskell. The reason for the
--   triviality of our code is the typechecker's already doing most of the
--   work need for an implementation of lambda-calculus.
--   
--   Our code is indeed quite simple: its general part has only three
--   lines:
--   
--   <pre>
--   instance E (F x) (F x)
--   instance (E y y', A (F x) y' r) =&gt; E ((F x) :&lt; y) r
--   instance (E (x :&lt; y) r', E (r' :&lt; z) r) =&gt; E ((x :&lt; y) :&lt; z) r
--   </pre>
--   
--   The first line says that abstractions evaluate to themselves, the
--   second line executes the redex, and the third recurses to find it.
--   Still, we may (and did) write partial applications, the fixpoint
--   combinator, Fibonacci function, and S and K combinators. Incidentally,
--   the realization of the S combinator again takes three lines, two of
--   which build the closures (partial applications) and the third line
--   executes the familiar S-rule.
--   
--   <pre>
--   instance A (F CombS) f (F (CombS,f))
--   instance A (F (CombS,f)) g (F (CombS,f,g))
--   instance E (f :&lt; x :&lt; (g :&lt; x)) r =&gt; A (F (CombS,f,g)) x r
--   </pre>
--   
--   Incidentally, the present code constitutes what seems to be the
--   shortest proof that the type system of Haskell with the undecidable
--   instances extension is indeed Turing-complete. That extension is
--   needed for the fixpoint combinator -- which is present in the system
--   described in Luca Cardelli's 1988 manuscript:
--   
--   <a>http://lucacardelli.name/Papers/PhaseDistinctions.pdf</a>
--   
--   As he wrote, ``Here we have generalized the language of constant
--   expressions to include typed lambda abstraction, application and
--   recursion (because of the latter we do not require compile-time
--   computations to terminate).'' [p9]
--   
--   This message is all the code, which runs in GHC 6.4.1 - 6.8.2 (it
--   could well run in Hugs; alas, Hugs did not like infix type
--   constructors like :&lt;).
module Language.TypeLC

-- | First we define some constants
data HTrue
HTrue :: HTrue
data HFalse
HFalse :: HFalse
data Zero
Zero :: Zero
data Su a
Su :: a -> Su a

-- | Indicator for functions, or applicable things:
data F x
class A l a b | l a -> b

-- | The meaning of |A l a b| is that the application to |a| of an
--   applicable thing denoted by |l| yields |b|.
--   
--   Surprisingly, this already works. Let us define the boolean Not
--   function
data FNot

-- | The next function is the boolean And. It takes two arguments, so we
--   have to handle currying now.
data FAnd

-- | Commonly, abstraction is held to be `more fundamental', which is
--   reflected in the popular phrase `Lambda-the-Ultimate'. In our system,
--   application is fundamental. An abstraction is a not-yet-applied
--   application -- which is in itself a first-class value. The class A
--   defines the meaning of a function, and an instance of A becomes the
--   definition of a function (clause).
--   
--   We have dealt with simple expressions and applicative things. We now
--   build sequences of applications, and define the corresponding big step
--   semantics. We introduce the syntax for applications:
data (:<) f x

-- | and the big-step evaluation function:
class E a b | a -> b

-- | That is all. The rest of the message are the tests. The first one is
--   the type-level equivalent of the following function:
--   
--   <pre>
--   testb x = and (not x) (not (not x))
--   </pre>
--   
--   At the type level, it looks not much differently:
type Testb x = (E ((F FAnd :< (F FNot :< x)) :< (F FNot :< (F FNot :< x))) r) => r

-- | We introduce the applicative fixpoint combinator
data Rec l

-- | and define the sum of two numerals
--   
--   At the type level, this looks as follows
data FSum'

-- | now we tie up the knot
type FSum = Rec (F FSum')
type N0 = Zero
type N1 = Su N0
type N2 = Su N1
type N3 = Su N2
test_sum :: (E ((F FSum :< x) :< y) r) => x -> y -> r

-- | Finally, the standard test -- Fibonacci
data Fib'
type Fib = Rec (F Fib')
test_fib :: (E (F Fib :< n) r) => n -> r

-- | Finally, we demonstrate that our calculus is combinatorially complete,
--   by writing the S and K combinators
data CombK
data CombS

-- | A few examples: SKK as the identity
type Test_skk x = (E (((F CombS :< F CombK) :< F CombK) :< x) r) => r

-- | and the representation of numerals in the SK calculus. The expression
--   (F FSum :&lt; Su Zero) is a partial application of the function sum to
--   1.
type CombZ = F CombS :< F CombK
type CombSu = F CombS :< ((F CombS :< (F CombK :< F CombS)) :< F CombK)
type CombTwo = CombSu :< (CombSu :< CombZ)
test_ctwo :: (E ((CombTwo :< (F FSum :< Su Zero)) :< Zero) r) => r
class Nat a
fromNat :: (Nat a) => a -> Integer
instance (Nat x) => Show (Su x)
instance Show Zero
instance (Nat x) => Nat (Su x)
instance Nat Zero
instance Show HFalse
instance Show HTrue
instance (E ((f :< x) :< (g :< x)) r) => A (F (CombS, f, g)) x r
instance A (F (CombS, f)) g (F (CombS, f, g))
instance A (F CombS) f (F (CombS, f))
instance A (F (CombK, a)) b a
instance A (F CombK) a (F (CombK, a))
instance (E ((F FSum :< (self :< n)) :< (self :< Su n)) r) => A (F (Fib', self)) (Su (Su n)) r
instance A (F (Fib', self)) (Su Zero) (Su Zero)
instance A (F (Fib', self)) Zero (Su Zero)
instance A (F Fib') self (F (Fib', self))
instance (E ((self :< n) :< m) r) => A (F (FSum', self, Su n)) m (Su r)
instance A (F (FSum', self, Zero)) m m
instance A (F (FSum', self)) n (F (FSum', self, n))
instance A (F FSum') self (F (FSum', self))
instance (E ((l :< F (Rec l)) :< x) r) => A (F (Rec l)) x r
instance (E x x') => E (Su x) (Su x')
instance (E (x :< y) r', E (r' :< z) r) => E ((x :< y) :< z) r
instance (E y y', A (F x) y' r) => E (F x :< y) r
instance E (F x) (F x)
instance E Zero Zero
instance E HFalse HFalse
instance E HTrue HTrue
instance A (F (FAnd, HFalse)) a HFalse
instance A (F (FAnd, HTrue)) a a
instance A (F FAnd) x (F (FAnd, x))
instance A (F FNot) HFalse HTrue
instance A (F FNot) HTrue HFalse


-- | <a>http://okmij.org/ftp/Haskell/types.html#computable-types</a>
--   
--   Part I of the series introduced the type-level functional language
--   with the notation that resembles lambda-calculus with case
--   distinction, fixpoint recursion, etc. Modulo a bit of syntactic tart,
--   the language of the type functions even looks almost like the pure
--   Haskell. In this message, we show the applications of computable
--   types, to ascribe signatures to terms and to drive the selection of
--   overloaded functions. We can compute the type of a tree of the depth
--   fib(N) or a complex XML type, and instantiate the read function to
--   read the trees of only that shape.
--   
--   A telling example of the power of the approach is the ability to use
--   not only (a-&gt;) but also (-&gt;a) as an unary type function. The
--   former is just (-&gt;) a. The latter is considered impossible. In our
--   approach, (-&gt;a) is written almost literally as (flip (-&gt;) a)
--   
--   This series of messages has been inspired by Luca Cardelli's 1988
--   manuscript ``Phase Distinctions in Type Theory''
--   <a>http://lucacardelli.name/Papers/PhaseDistinctions.pdf</a> and by
--   Simon Peyton Jones and Erik Meijer's ``Henk: A Typed Intermediate
--   Language''
--   <a>http://www.research.microsoft.com/~simonpj/Papers/henk.ps.gz</a>
--   which expounds many of the same notions in an excellent tutorial style
--   and in modern terminology.
--   
--   I'm very grateful to Chung-chieh Shan for pointing out these papers to
--   me and for thought-provoking discussions.
module Language.TypeFN

-- | Our first example comes from Cardelli's paper: defining the type
--   Prop(n), of n-ary propositions. That is,
--   
--   <pre>
--   Prop(2) should be the type       Bool -&gt; Bool -&gt; Bool
--   Prop(3) is the type of functions Bool -&gt; Bool -&gt; Bool -&gt; Bool
--   </pre>
--   
--   etc.
--   
--   Cardelli's paper (p. 10) writes this type as
--   
--   <pre>
--   let Prop:: AllKK(N:: NatK) Type =
--        recK(F:: AllKK(N:: NatK) Type)
--            funKK(N:: NatK) caseK N of 0K =&gt; Bool; succK(M) =&gt; Bool -&gt; F(M);
--   </pre>
--   
--   <pre>
--   let and2: Prop(2K) =
--        fun(a: Bool) fun(b: Bool) a &amp; b;
--   </pre>
--   
--   Here 0K and 2K are type-level numerals of the kind NatK; recK is the
--   type-level fix-point combinator. The computed type Prop(2) then gives
--   the type to the term and2.
--   
--   In our system, this example looks as follows:
data Prop'
type Prop = Rec (F Prop')
type Prop2 = (E (F Prop :< N2) r) => r

-- | We can compute types by applying type functions, just as we can
--   compute values by applying regular functions. Indeed, let us define a
--   StrangeProp of the kind NAT -&gt; Type. StrangeProp(n) is the type of
--   propositions of arity m, where m is fib(n). We compose together the
--   already defined type function Prop2 and the type function Fib in the
--   previous message.
data StrangeProp
oddand4t :: (E (F StrangeProp :< ((F FSum :< N2) :< N2)) r) => r

-- | We introduce the combinator Ntimes: |NTimes f x n| applies f to x n
--   times. This is a sort of fold over numerals.
data Ntimes
data ATC1 c

-- | We can then write the type of n-ary propositions Prop(N) in a
--   different way, as an N-times application of the type constructor
--   (Bool-&gt;) to Bool.
type PropN' n = (E (((F Ntimes :< (F (ATC1 ((->) Bool)))) :< Bool) :< n) r) => r

-- | To generalize,
data ATC2 c :: (* -> * -> *)
type SPropN' n = (E (((F Ntimes :< (F (ATC2 (->)) :< Bool)) :< Bool) :< (F Fib :< n)) r) => r

-- | The comparison of ATC1 with ATC2 shows two different ways of defining
--   abstractions: as (F x) terms (`lambda-terms' in our calculus) and as
--   polymorphic types (Haskell type abstractions). The two ways are
--   profoundly related. The more verbose type application notation, via
--   (:&lt;), has its benefits. After we introduce another higher-order
--   function
data Flip

-- | we make a very little change
type SSPropN' n = (E (((F Ntimes :< ((F Flip :< (F (ATC2 (->)))) :< Bool)) :< Bool) :< (F Fib :< n)) r) => r

-- | and obtain quite a different result:
--   
--   <pre>
--   *TypeFN&gt; :t test_sspn4
--   test_sspn4 :: ((((Bool -&gt; Bool) -&gt; Bool) -&gt; Bool) -&gt; Bool) -&gt; Bool
--   </pre>
--   
--   In effect, we were able to use not only (a-&gt;) but also (-&gt;a) as
--   an unary type function. Moreover, we achieved the latter by almost
--   literally applying the flip function to the arrow type constructor
--   (-&gt;).
--   
--   Using the type inspection tools (typecast), we can replace the family
--   of functions ATC1, ATC2 with one, kind-polymorphic, polyvariadic
--   function ATC. This approach will be explained in further messages.
--   
--   We can use the computed types to drive overloaded functions such as
--   read and show. The specifically instantiated read functions, in
--   particular, will check that a (remotely) received serialized value
--   matches our expectation. Let's consider the type of trees of the depth
--   of at most N.
data Node v els
Node :: v -> [els] -> Node v els
type TreeDN v l n = (E (((F Ntimes :< (F (ATC1 (Node v)))) :< l) :< n) r) => r
instance (Read v, Read els) => Read (Node v els)
instance (Show v, Show els) => Show (Node v els)
instance E (Node v els) (Node v els)
instance (E ((f :< y) :< x) r) => A (F (Flip, f, x)) y r
instance A (F (Flip, f)) x (F (Flip, f, x))
instance A (F Flip) f (F (Flip, f))
instance A (F (ATC2 c)) x (F (ATC1 (c x)))
instance A (F (ATC1 c)) x (c x)
instance (E (((F Ntimes :< f) :< (f :< x)) :< n) r) => A (F (Ntimes, f, x)) (Su n) r
instance A (F (Ntimes, f, x)) Zero x
instance A (F (Ntimes, f)) x (F (Ntimes, f, x))
instance A (F Ntimes) f (F (Ntimes, f))
instance E (a, b) (a, b)
instance E (a -> b) (a -> b)
instance E String String
instance E Int Int
instance E Bool Bool
instance (E (F Prop :< (F Fib :< n)) r) => A (F StrangeProp) n r
instance (E (f :< m) r) => A (F (Prop', f)) (Su m) (Bool -> r)
instance A (F (Prop', f)) Zero Bool
instance A (F Prop') f (F (Prop', f))


-- | Unifying syntax with semantics
module Lambda.CFG4
data S
data NP
data VP
data TV
class Symantics repr
john :: (Symantics repr) => repr NP
mary :: (Symantics repr) => repr NP
like :: (Symantics repr) => repr TV
r2 :: (Symantics repr) => repr TV -> repr NP -> repr VP
r1 :: (Symantics repr) => repr NP -> repr VP -> repr S
data EN a
EN :: String -> EN a
unEN :: EN a -> String
data Sem a
Sem :: Tr a -> Sem a
unSem :: Sem a -> Tr a
data Entity
John :: Entity
Mary :: Entity
instance Eq Entity
instance Show Entity
instance Show (Sem S)
instance Symantics Sem
instance Show (EN a)
instance Symantics EN


-- | Type functions: interpretations of the type constants
--   
--   <a>http://okmij.org/ftp/gengo/NASSLLI10/</a>
module Lambda.CFG3Sem
data S
data NP
data VP
data TV
data Sem a
Sem :: Tr a -> Sem a
unSem :: Sem a -> Tr a
data Entity
John :: Entity
Mary :: Entity
mary :: Sem NP
john :: Sem NP
like :: Sem TV
r2 :: Sem TV -> Sem NP -> Sem VP
r1 :: Sem NP -> Sem VP -> Sem S
sentence :: Sem S
instance Eq Entity
instance Show Entity
instance Show (Sem S)


-- | Introducing type constants
--   
--   We wish to outlaw terms such as bad_sentence in CFG2EN.hs, even though
--   there may be an interpretation that accepts these bad terms. We really
--   wish our terms represent all and only valid CFG derivations. We
--   accomplish this goal here. Our approach is reminiscent of LCF.
module Lambda.CFG3EN
data S
data NP
data VP
data TV

-- | Parameterized types: cf notation:
--   
--   <pre>
--   &lt;string,features&gt; in
--   </pre>
--   
--   the Minimalist Grammar
data EN a
EN :: String -> EN a
unEN :: EN a -> String

-- | One may think of the above data declaration as defining an isomorphism
--   between EN values and Strings. The functions EN and unEN (what is
--   their type?) witness the isomorphism. It helps to look at their
--   composition.
mary :: EN NP
john :: EN NP
like :: EN TV
r2 :: EN TV -> EN NP -> EN VP
r1 :: EN NP -> EN VP -> EN S
sentence :: EN S
instance Show (EN a)


-- | <a>http://okmij.org/ftp/gengo/NASSLLI10/</a>
module Lambda.CFG2Sem

-- | CFG1Sem with type annotations
data Entity
John :: Entity
Mary :: Entity
mary :: Entity
john :: Entity
like :: Entity -> Entity -> Bool
r2 :: (Entity -> Entity -> Bool) -> Entity -> (Entity -> Bool)
r1 :: Entity -> (Entity -> Bool) -> Bool

-- | A new notation for <a>like</a> (which will be convenient later)
sentence :: Bool
instance Eq Entity
instance Show Entity


-- | <a>http://okmij.org/ftp/gengo/NASSLLI10</a>
module Lambda.CFG2EN

-- | Type annotations
mary :: String
john :: String
like :: String
r2 :: String -> String -> String
r1 :: String -> String -> String
sentence :: String

-- | Unfortunately, the following sentence is, too, accepted by the type
--   checker.
--   
--   We shall later see how to build terms that correspond to all and only
--   valid derivations. Invalid derivations will become ill-typed.
bad_sentence :: String


-- | <a>http://okmij.org/ftp/gengo/NASSLLI10/</a>
module Lambda.CFG1Sem

-- | Semantic interpretation of a CFG derivation
--   
--   In conventional notation:
--   
--   <pre>
--   D_e = {John, Mary}
--   </pre>
data Entity
John :: Entity
Mary :: Entity
instance Eq Entity
instance Show Entity


-- | <a>http://okmij.org/ftp/gengo/NASSLLI10/</a>
module Lambda.CFG1EN

module Lambda.Semantics

-- | Here we encode the <a>target language</a>, the language to express
--   denotations (or, meanings) Following Montague, our language for
--   denotations is essentially Church's <a>Simple Theory of Types</a> also
--   known as simply-typed lambda-calculus It is a form of a higher-order
--   predicate logic.
data Entity
John :: Entity
Mary :: Entity

-- | We define the grammar of the target language the same way we have
--   defined the grammar for (source) fragment
class Lambda lrepr
john' :: (Lambda lrepr) => lrepr Entity
mary' :: (Lambda lrepr) => lrepr Entity
like' :: (Lambda lrepr) => lrepr (Entity -> Entity -> Bool)
own' :: (Lambda lrepr) => lrepr (Entity -> Entity -> Bool)
farmer' :: (Lambda lrepr) => lrepr (Entity -> Bool)
donkey' :: (Lambda lrepr) => lrepr (Entity -> Bool)
true :: (Lambda lrepr) => lrepr Bool
neg :: (Lambda lrepr) => lrepr Bool -> lrepr Bool
conj :: (Lambda lrepr) => lrepr Bool -> lrepr Bool -> lrepr Bool
exists :: (Lambda lrepr) => lrepr ((Entity -> Bool) -> Bool)
app :: (Lambda lrepr) => lrepr (a -> b) -> lrepr a -> lrepr b
lam :: (Lambda lrepr) => (lrepr a -> lrepr b) -> lrepr (a -> b)

-- | Syntactic sugar
--   
--   The first interpretation: evaluating in the world with John, Mary, and
--   Bool as truth values. Lambda functions are interpreted as Haskell
--   functions and Lambda applications are interpreted as Haskell
--   applications. The interpreter R is metacircular (and so, efficient).
data R a
R :: a -> R a
unR :: R a -> a

-- | <a>Running</a> the examples
--   
--   We now interpret Lambda terms as Strings, so we can show our formulas.
--   Actually, not quite strings: we need a bit of _context_: the
--   precedence and the number of variables already bound in the context.
--   The latter number lets us generate unique variable names.
data C a
C :: (Int -> Int -> String) -> C a
unC :: C a -> Int -> Int -> String

-- | We can now see the examples
--   
--   The displayed difference between lsen4 and lsen4' shows that
--   beta-redices have been reduced. NBE.
--   
--   Normalizing the terms: performing the apparent redices
data P lrepr a
P :: lrepr a -> Maybe (Known lrepr a) -> P lrepr a
unP :: P lrepr a -> lrepr a
known :: P lrepr a -> Maybe (Known lrepr a)
instance Eq Entity
instance Show Entity
instance (Show (lrepr a)) => Show (P lrepr a)
instance (Lambda lrepr) => Lambda (P lrepr)
instance Show (C a)
instance Lambda C
instance (Show a) => Show (R a)
instance Lambda R


-- | Context-free grammars, in the tagless-final style
--   
--   <a>http://okmij.org/ftp/gengo/NASSLLI10/</a>
module Lambda.CFG

-- | Syntactic categories: non-terminals of CFG
data S
data NP
data VP
data TV

-- | This class defines the syntax of our fragment (the grammar,
--   essentially). Its instances will show interpretations of the grammar,
--   or <tt>semantics</tt>
--   
--   The names r1, r2, etc. are the labels of CFG rules. These names are
--   evocative of Montague
class Symantics repr
john :: (Symantics repr) => repr NP
mary :: (Symantics repr) => repr NP
like :: (Symantics repr) => repr TV
own :: (Symantics repr) => repr TV
r2 :: (Symantics repr) => repr TV -> repr NP -> repr VP
r1 :: (Symantics repr) => repr NP -> repr VP -> repr S

-- | show the inferred types, as well as the inferred types for the phrases
--   like
--   
--   The first sample sentence, or CFG derivation The inferred type is S.
--   So, sen1 is a derivations of a complete sentence.
--   
--   We now define the first interpretation of a CFG derivations: We
--   interpret the derivation to give the parsed string. That is, we
--   generate a yield of a CFG derivation, in English.
--   
--   We represent each node in the derivation tree by an English phrase
data EN a
EN :: String -> EN a
unEN :: EN a -> String

-- | Show the English form of sen1
--   
--   We now define semantics of a phrase represented by a derivation. It is
--   a different interpretation of the phrase and its types.
--   
--   We first interpret syntactic types (NP, VP, etc) in terms of the types
--   of the language of logic formulas. The type class Lambda defines the
--   language of logic formulas (STT, or higher-order logic) with types
--   Entity, Bool, and the arrows.
data Sem lrepr a
Sem :: lrepr (Tr a) -> Sem lrepr a
unSem :: Sem lrepr a -> lrepr (Tr a)
instance Show (Sem (P C) a)
instance Show (Sem C a)
instance (Lambda lrepr) => Symantics (Sem lrepr)
instance Show (EN a)
instance Symantics EN


-- | Interpreting a CFG derivation as a string in Japanese. That is, we
--   generate a yield of a CFG derivation, this time in Japanese.
--   
--   <a>http://okmij.org/ftp/gengo/NASSLLI10/</a>
module Lambda.CFGJ

-- | We represent each node in the derivation tree by a Japanese phrase or
--   a Japanese <a>sentential form</a> (that is, a phrase with holes).
--   Contrast with the EN interpreter in CFG.hs
data JA a
JA :: TJ a -> JA a
unJA :: JA a -> TJ a

-- | A verb or a verb-like word (e.g., an i-adjective) require arguments of
--   particular cases. We need a way for a verb to specify the desired case
--   of its arguments.
data Case
Nom :: Case
NomStrong :: Case
Acc :: Case
case_particle :: Case -> String

-- | The type family TJ defines the types of sentential forms corresponding
--   to syntactic categories.
--   
--   As we shall see in QCFGJ.hs, we are going to need high (raised) types
--   of our NP. A verb will ask its argument to turn itself to the desired
--   case.
type SK = (String -> String) -> String

-- | Auxiliary functions for the code below
make_np :: String -> (Case -> SK)
make_tv :: String -> Case -> Case -> (Case -> SK) -> (Case -> SK) -> String
instance Show (JA S)
instance Symantics JA


-- | Context-free grammar with quantifiers
--   
--   We extend CFG.hs to add quantified noun phrases in the tradition of
--   Montague
module Lambda.QCFG

-- | Additional syntactic categories
data CN
data QNP

-- | We extend our earlier fragment with common nouns farmer and donkey,
--   and quantifiers everyone, someone, every farmer, a donkey, etc. Since
--   we added two new categories (CN and QNP), we need to add rules to our
--   CFG to be able to use the categories in derivations.
--   
--   The numbers 4 and 5 are due to Montague
class (Symantics repr) => Quantifier repr
farmer :: (Quantifier repr) => repr CN
donkey :: (Quantifier repr) => repr CN
everyone :: (Quantifier repr) => repr QNP
someone :: (Quantifier repr) => repr QNP
every :: (Quantifier repr) => repr CN -> repr QNP
a :: (Quantifier repr) => repr CN -> repr QNP
who :: (Quantifier repr) => repr VP -> repr CN -> repr CN
r5 :: (Quantifier repr) => repr TV -> repr QNP -> repr VP
r4 :: (Quantifier repr) => repr QNP -> repr VP -> repr S
instance (Lambda lrepr) => Quantifier (Sem lrepr)
instance Quantifier EN


-- | Philippe de Groote. 2010. Dynamic logic: a type-theoretic view. Talk
--   slides at `Le modle et l<tt>algorithme</tt>, Rocquencourt.
--   <a>http://www.inria.fr/rocquencourt/rendez-vous/modele-et-algo/dynamic-logic-a-type-theoretic-view</a>
module Lambda.Dynamics

-- | We extend the Lambda language with state (of the type State)
type State = [Entity]
class (Lambda lrepr) => States lrepr
update :: (States lrepr) => lrepr Entity -> lrepr State -> lrepr State
select :: (States lrepr) => lrepr State -> lrepr Entity
data D c a
D :: c (Dynamic a) -> D c a
unD :: D c a -> c (Dynamic a)
class Predicate a
dynamic :: (Predicate a, Lambda lrepr) => (lrepr State -> lrepr a) -> lrepr (Dynamic a)
static :: (Predicate a, Lambda lrepr) => lrepr (Dynamic a) -> lrepr State -> lrepr a
class (Lambda lrepr) => Dynamics lrepr
it' :: (Dynamics lrepr) => lrepr ((Entity -> Bool) -> Bool)
class (Quantifier repr) => Pronoun repr
it_ :: (Pronoun repr) => repr QNP
instance (Dynamics lrepr) => Pronoun (Sem lrepr)
instance Pronoun EN
instance (Dynamics lrepr) => Dynamics (P lrepr)
instance Dynamics C
instance (States lrepr) => Dynamics (D lrepr)
instance (Predicate a) => Predicate (Entity -> a)
instance Predicate Bool
instance Show (D (P C) Bool)
instance Show (D C Bool)
instance Show (Sem (D (P C)) S)
instance Show (Sem (D C) S)
instance (States c) => Lambda (D c)
instance (States lrepr) => States (P lrepr)
instance States C
instance States R


-- | Interpreting a CFG derivation with quantifiers as a string in
--   Japanese. That is, we generate a yield of a CFG derivation, this time
--   in Japanese.
module Lambda.QCFGJ
instance Quantifier JA


-- | Context-free grammar with quantifiers A different ways to add
--   quantification, via Higher-Order abstract syntax (HOAS). This is a
--   <a>rational reconstruction</a> of Montague's general approach of
--   `administrative pronouns', which later gave rise to the Quantifier
--   Raising (QR)
module Lambda.QHCFG

-- | No longer any need in a new syntactic category QNP We leave out CN as
--   an exercise
--   
--   <pre>
--   data CN                                      -- Common noun
--   </pre>
--   
--   We extend our earlier fragment with quantifiers everyone, someone. In
--   contrast to QCFG.hs, we do not add any new syntactic category, so we
--   don't need to add any rules to our CFG.
class (Symantics repr) => Quantifier repr
everyone :: (Quantifier repr) => (repr NP -> repr S) -> repr S
someone :: (Quantifier repr) => (repr NP -> repr S) -> repr S
instance (Lambda lrepr) => Quantifier (Sem lrepr)
instance Quantifier EN


-- | Combinatorial Categorical Grammar (CCG)
--   
--   <a>http://okmij.org/ftp/gengo/NASSLLI10</a>
module Lambda.CCG

-- | Syntactic categories: non-terminals of CCG
data S
data NP
data (:/) b a
data (:\\) b a

-- | This class defines the syntax of our fragment (the grammar,
--   essentially). Its instances will show interpretations of the grammar,
--   or <tt>semantics</tt>
class Symantics repr
john :: (Symantics repr) => repr NP
mary :: (Symantics repr) => repr NP
like :: (Symantics repr) => repr ((NP :\\ S) :/ NP)
(/) :: (Symantics repr) => repr (b :/ a) -> repr a -> repr b
(\\) :: (Symantics repr) => repr a -> repr (a :\\ b) -> repr b

-- | show the inferred types, as well as the inferred types for phrases
--   like
--   
--   The first sample sentence, or CCG derivation The inferred type is S.
--   So, sen1 is a derivations of a complete sentence.
--   
--   We now define the first interpretation of a CCG derivations: We
--   interpret the derivation to give the parsed string. That is, we
--   generate a yield of a CCG derivation, in English.
--   
--   We represent each node in the derivation tree by an English phrase
data EN a
EN :: String -> EN a
unEN :: EN a -> String

-- | Show the English form of sen1
--   
--   We now define semantics of a phrase represented by a derivation. It is
--   a different interpretation of the phrase and its types.
--   
--   We first interpret syntactic types (NP, slashes, etc) in terms of the
--   types of the language of logic formulas. The type class Lambda defines
--   the language of logic formulas (STT, or higher-order logic) with types
--   Entity, Bool, and the arrows.
data Sem lrepr a
Sem :: lrepr (Tr a) -> Sem lrepr a
unSem :: Sem lrepr a -> lrepr (Tr a)

-- | We can now see the semantics of sen1
--   
--   Computing the yield in Japanese
--   
--   The type family TJ defines the types of sentential forms corresponding
--   to syntactic categories.
--   
--   We represent each node in the derivation tree by a Japanese phrase or
--   a Japanese <a>sentential form</a> (that is, a phrase with holes).
--   Contrast with the EN interpreter above.
data JA a
JA :: TJ a -> JA a
unJA :: JA a -> TJ a

-- | The translation is certainly different: <a>like</a> corresponds to an
--   adjective in Japanese.
--   
--   Adding quantification; one way
type QNP = S :/ (NP :\\ S)

-- | We extend our earlier fragment with quantifiers everyone, someone We
--   also add a combinator for raising the first argument of a TV
class (Symantics repr) => Quantifier repr
everyone :: (Quantifier repr) => repr QNP
someone :: (Quantifier repr) => repr QNP
lift_vt :: (Quantifier repr) => repr ((NP :\\ S) :/ NP) -> repr ((NP :\\ S) :/ QNP)
instance Quantifier JA
instance (Lambda lrepr) => Quantifier (Sem lrepr)
instance Quantifier EN
instance Show (JA S)
instance Symantics JA
instance Show (Sem (P C) a)
instance Show (Sem C a)
instance (Lambda lrepr) => Symantics (Sem lrepr)
instance Show (EN a)
instance Symantics EN


-- | Monadic and General Iteratees: incremental input parsers, processors
--   and transformers
--   
--   The running example, parts 1 and 2 Part 1 is reading the headers, the
--   sequence of lines terminated by an empty line. Each line is terminated
--   by CR, LF, or CRLF. We should return the headers in order. In the case
--   of error, we should return the headers read so far and the description
--   of the error. Part 2 is reading the headers and reading all the lines
--   from the HTTP-chunk-encoded content that follows the headers. Part 2
--   thus verifies layering of streams, and processing of one stream
--   embedded (chunk encoded) into another stream.
module System.IterateeM

-- | A stream is a (continuing) sequence of elements bundled in Chunks. The
--   first two variants indicate termination of the stream. Chunk [a] gives
--   the currently available part of the stream. The stream is not
--   terminated yet. The case (Chunk []) signifies a stream with no
--   currently available data but which is still continuing. A stream
--   processor should, informally speaking, ``suspend itself'' and wait for
--   more data to arrive. Later on, we can add another variant: IE_block
--   (Ptr CChar) CSize so we could parse right from the buffer.
data StreamG a
EOF :: StreamG a
Err :: String -> StreamG a
Chunk :: [a] -> StreamG a

-- | A particular instance of StreamG: the stream of characters. This
--   stream is used by many input parsers.
type Stream = StreamG Char

-- | Iteratee -- a generic stream processor, what is being folded over a
--   stream When Iteratee is in the <tt>done</tt> state, it contains the
--   computed result and the remaining part of the stream. In the
--   <tt>cont</tt> state, the iteratee has not finished the computation and
--   needs more input. We assume that all iteratees are <tt>good</tt> --
--   given bounded input, they do the bounded amount of computation and
--   take the bounded amount of resources. The monad m describes the sort
--   of computations done by the iteratee as it processes the stream. The
--   monad m could be the identity monad (for pure computations) or the IO
--   monad (to let the iteratee store the stream processing results as they
--   are computed). We also assume that given a terminated stream, an
--   iteratee moves to the done state, so the results computed so far could
--   be returned.
--   
--   We could have used existentials instead, by doing the closure
--   conversion
data IterateeG el m a
IE_done :: a -> (StreamG el) -> IterateeG el m a
IE_cont :: (StreamG el -> IterateeGM el m a) -> IterateeG el m a
newtype IterateeGM el m a
IM :: m (IterateeG el m a) -> IterateeGM el m a
unIM :: IterateeGM el m a -> m (IterateeG el m a)
type Iteratee m a = IterateeG Char m a
type IterateeM m a = IterateeGM Char m a

-- | Useful combinators for implementing iteratees and enumerators
liftI :: (Monad m) => IterateeG el m a -> IterateeGM el m a

-- | Just like bind (at run-time, this is indeed exactly bind)
(>>==) :: (Monad m) => IterateeGM el m a -> (IterateeG el m a -> IterateeGM el' m b) -> IterateeGM el' m b

-- | Just like an application -- a call-by-value-like application
(==<<) :: (Monad m) => (IterateeG el m a -> IterateeGM el' m b) -> IterateeGM el m a -> IterateeGM el' m b

-- | The following is a <tt>variant</tt> of join in the IterateeGM el m
--   monad. When el' is the same as el, the type of joinI is indeed that of
--   true monadic join. However, joinI is subtly different: since generally
--   el' is different from el, it makes no sense to continue using the
--   internal, IterateeG el' m a: we no longer have elements of the type
--   el' to feed to that iteratee. We thus send EOF to the internal
--   Iteratee and propagate its result. This join function is useful when
--   dealing with `derived iteratees' for embedded/nested streams. In
--   particular, joinI is useful to process the result of stake,
--   map_stream, or conv_stream below.
joinI :: (Monad m) => IterateeGM el m (IterateeG el' m a) -> IterateeGM el m a

-- | Read a stream to the end and return all of its elements as a list
stream2list :: (Monad m) => IterateeGM el m [el]

-- | Check to see if the stream is in error
iter_report_err :: (Monad m) => IterateeGM el m (Maybe String)

-- | The analogue of List.break It takes an element predicate and returns a
--   pair: (str, Just c) -- the element <tt>c</tt> is the first element of
--   the stream satisfying the break predicate; The list str is the prefix
--   of the stream up to but including <tt>c</tt> (str,Nothing) -- The
--   stream is terminated with EOF or error before any element satisfying
--   the break predicate was found. str is the scanned part of the stream.
--   None of the element in str satisfy the break predicate.
sbreak :: (Monad m) => (el -> Bool) -> IterateeGM el m ([el], Maybe el)

-- | A particular optimized case of the above: skip all elements of the
--   stream satisfying the given predicate -- until the first element that
--   does not satisfy the predicate, or the end of the stream. This is the
--   analogue of List.dropWhile
sdropWhile :: (Monad m) => (el -> Bool) -> IterateeGM el m ()

-- | Attempt to read the next element of the stream Return (Just c) if
--   successful, return Nothing if the stream is terminated (by EOF or an
--   error)
snext :: (Monad m) => IterateeGM el m (Maybe el)

-- | Look ahead at the next element of the stream, without removing it from
--   the stream. Return (Just c) if successful, return Nothing if the
--   stream is terminated (by EOF or an error)
speek :: (Monad m) => IterateeGM el m (Maybe el)

-- | Skip the rest of the stream
skip_till_eof :: (Monad m) => IterateeGM el m ()

-- | Skip n elements of the stream, if there are that many This is the
--   analogue of List.drop
sdrop :: (Monad m) => Int -> IterateeGM el m ()

-- | Iteratee converters for stream embedding The converters show a
--   different way of composing two iteratees: <tt>vertical</tt> rather
--   than <tt>horizontal</tt>
--   
--   The type of the converter from the stream with elements el_outer to
--   the stream with element el_inner. The result is the iteratee for the
--   outer stream that uses an `IterateeG el_inner m a' to process the
--   embedded, inner stream as it reads the outer stream.
type EnumeratorN el_outer el_inner m a = IterateeG el_inner m a -> IterateeGM el_outer m (IterateeG el_inner m a)

-- | Read n elements from a stream and apply the given iteratee to the
--   stream of the read elements. Unless the stream is terminated early, we
--   read exactly n elements (even if the iteratee has accepted fewer).
stake :: (Monad m) => Int -> EnumeratorN el el m a

-- | Map the stream: yet another iteratee transformer Given the stream of
--   elements of the type el and the function el-&gt;el', build a nested
--   stream of elements of the type el' and apply the given iteratee to it.
--   Note the contravariance
map_stream :: (Monad m) => (el -> el') -> EnumeratorN el el' m a

-- | Convert one stream into another, not necessarily in <tt>lockstep</tt>
--   The transformer map_stream maps one element of the outer stream to one
--   element of the nested stream. The transformer below is more general:
--   it may take several elements of the outer stream to produce one
--   element of the inner stream, or the other way around. The
--   transformation from one stream to the other is specified as IterateeGM
--   el m (Maybe [el']). The <a>Maybe</a> type reflects the possibility of
--   the conversion error.
conv_stream :: (Monad m) => IterateeGM el m (Maybe [el']) -> EnumeratorN el el' m a

-- | Combining the primitive iteratees to solve the running problem:
--   Reading headers and the content from an HTTP-like stream
type Line = String

-- | Read the line of text from the stream The line can be terminated by
--   CR, LF or CRLF. Return (Right Line) if successful. Return (Left Line)
--   if EOF or a stream error were encountered before the terminator is
--   seen. The returned line is the string read so far.
--   
--   The code is the same as that of pure Iteratee, only the signature has
--   changed. Compare the code below with GHCBufferIO.line_lazy
line :: (Monad m) => IterateeM m (Either Line Line)

-- | Line iteratees: processors of a stream whose elements are made of
--   Lines
--   
--   Collect all read lines and return them as a list see stream2list
--   
--   Print lines as they are received. This is the first <tt>impure</tt>
--   iteratee with non-trivial actions during chunk processing
print_lines :: IterateeGM Line IO ()

-- | Convert the stream of characters to the stream of lines, and apply the
--   given iteratee to enumerate the latter. The stream of lines is
--   normally terminated by the empty line. When the stream of characters
--   is terminated, the stream of lines is also terminated, abnormally.
--   This is the first proper iteratee-enumerator: it is the iteratee of
--   the character stream and the enumerator of the line stream. More
--   generally, we could have used conv_stream to implement enum_lines.
enum_lines :: (Monad m) => EnumeratorN Char Line m a

-- | Convert the stream of characters to the stream of words, and apply the
--   given iteratee to enumerate the latter. Words are delimited by white
--   space. This is the analogue of List.words It is instructive to compare
--   the code below with the code of List.words, which is:
--   
--   <pre>
--   words                   :: String -&gt; [String]
--   words s                 =  case dropWhile isSpace s of
--                                   "" -&gt; []
--                                   s' -&gt; w : words s''
--                                         where (w, s'') =
--                                               break isSpace s'
--   </pre>
--   
--   One should keep in mind that enum_words is a more general, monadic
--   function. More generally, we could have used conv_stream to implement
--   enum_words.
enum_words :: (Monad m) => EnumeratorN Char String m a

-- | Enumerators Each enumerator takes an iteratee and returns an iteratee
--   an Enumerator is an iteratee transformer. The enumerator normally
--   stops when the stream is terminated or when the iteratee moves to the
--   done state, whichever comes first. When to stop is of course up to the
--   enumerator...
--   
--   We have two choices of composition: compose iteratees or compose
--   enumerators. The latter is useful when one iteratee reads from the
--   concatenation of two data sources.
type EnumeratorGM el m a = IterateeG el m a -> IterateeGM el m a
type EnumeratorM m a = EnumeratorGM Char m a

-- | The most primitive enumerator: applies the iteratee to the terminated
--   stream. The result is the iteratee usually in the done state.
enum_eof :: (Monad m) => EnumeratorGM el m a

-- | Another primitive enumerator: report an error
enum_err :: (Monad m) => String -> EnumeratorGM el m a

-- | The composition of two enumerators: essentially the functional
--   composition It is convenient to flip the order of the arguments of the
--   composition though: in e1 &gt;. e2, e1 is executed first
(>.) :: (Monad m) => EnumeratorGM el m a -> EnumeratorGM el m a -> EnumeratorGM el m a

-- | The pure 1-chunk enumerator It passes a given list of elements to the
--   iteratee in one chunk This enumerator does no IO and is useful for
--   testing of base parsing
enum_pure_1chunk :: (Monad m) => [el] -> EnumeratorGM el m a

-- | The pure n-chunk enumerator It passes a given lift of elements to the
--   iteratee in n chunks This enumerator does no IO and is useful for
--   testing of base parsing and handling of chunk boundaries
enum_pure_nchunk :: (Monad m) => [el] -> Int -> EnumeratorGM el m a

-- | The enumerator of a POSIX Fd Unlike fdRead (which allocates a new
--   buffer on each invocation), we use the same buffer all throughout
enum_fd :: Fd -> EnumeratorM IO a
enum_file :: FilePath -> EnumeratorM IO a

-- | HTTP chunk decoding Each chunk has the following format:
--   
--   <pre>
--   &lt;chunk-size&gt; CRLF &lt;chunk-data&gt; CRLF
--   </pre>
--   
--   where <a>chunk-size</a> is the hexadecimal number; <a>chunk-data</a>
--   is a sequence of <a>chunk-size</a> bytes. The last chunk (so-called
--   EOF chunk) has the format 0 CRLF CRLF (where 0 is an ASCII zero, a
--   character with the decimal code 48). For more detail, see <a>Chunked
--   Transfer Coding</a>, Sec 3.6.1 of the HTTP/1.1 standard:
--   <a>http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.6.1</a>
--   
--   The following enum_chunk_decoded has the signature of the enumerator
--   of the nested (encapsulated and chunk-encoded) stream. It receives an
--   iteratee for the embedded stream and returns the iteratee for the
--   base, embedding stream. Thus what is an enumerator and what is an
--   iteratee may be a matter of perspective.
--   
--   We have a decision to make: Suppose an iteratee has finished (either
--   because it obtained all needed data or encountered an error that makes
--   further processing meaningless). While skipping the rest of the
--   stream/the trailer, we encountered a framing error (e.g., missing CRLF
--   after chunk data). What do we do? We chose to disregard the latter
--   problem. Rationale: when the iteratee has finished, we are in the
--   process of skipping up to the EOF (draining the source). Disregarding
--   the errors seems OK then. Also, the iteratee may have found an error
--   and decided to abort further processing. Flushing the remainder of the
--   input is reasonable then. One can make a different choice...
enum_chunk_decoded :: (Monad m) => Iteratee m a -> IterateeM m a
instance (Show a) => Show (StreamG a)
instance MonadTrans (IterateeGM el)
instance (Monad m) => Monad (IterateeGM el m)


-- | Random and Binary IO with IterateeM
--   
--   <a>http://okmij.org/ftp/Streams.html#random-bin-IO</a>
--   
--   Random and binary IO: Reading TIFF
--   
--   Iteratees presuppose sequential processing. A general-purpose input
--   method must also support random IO: processing a seek-able input
--   stream from an arbitrary position, jumping back and forth through the
--   stream. We demonstrate random IO with iteratees, as well as reading
--   non-textual files and converting raw bytes into multi-byte quantities
--   such as integers, rationals, and TIFF dictionaries. Positioning of the
--   input stream is evocative of delimited continuations.
--   
--   We use random and binary IO to write a general-purpose TIFF library.
--   The library emphasizes incremental processing, relying on iteratees
--   and enumerators for on-demand reading of tag values. The library
--   extensively uses nested streams, tacitly converting the stream of raw
--   bytes from the file into streams of integers, rationals and other
--   user-friendly items. The pixel matrix is presented as a contiguous
--   stream, regardless of its segmentation into strips and physical
--   arrangement.
--   
--   We show a representative application of the library: reading a sample
--   TIFF file, printing selected values from the TIFF dictionary,
--   verifying the values of selected pixels and computing the histogram of
--   pixel values. The pixel verification procedure stops reading the pixel
--   matrix as soon as all specified pixel values are verified. The
--   histogram accumulation does read the entire matrix, but incrementally.
--   Neither pixel matrix processing procedure loads the whole matrix in
--   memory. In fact, we never read and retain more than the IO-buffer-full
--   of raw data.
--   
--   Version: The current version is 1.1, December 2008.
module System.RandomIO

-- | The type of the IO monad supporting seek requests and endianness The
--   seek_request is not-quite a state, more like a `communication channel'
--   set by the iteratee and answered by the enumerator. Since the base
--   monad is IO, it seems simpler to implement both endianness and seek
--   requests as IORef cells. Their names are grouped in a structure
--   RBState, which is propagated as the `environment.'
newtype RBIO a
RBIO :: (RBState -> IO a) -> RBIO a
unRBIO :: RBIO a -> RBState -> IO a

-- | Generally, RBState is opaque and should not be exported.
data RBState
RBState :: IORef Bool -> IORef (Maybe FileOffset) -> RBState
msb_first :: RBState -> IORef Bool
seek_req :: RBState -> IORef (Maybe FileOffset)

-- | The programmer should use the following functions instead
--   
--   To request seeking, the iteratee sets seek_req to (Just
--   desired_offset) When the enumerator answers the request, it sets
--   seek_req back to Nothing
rb_seek_set :: FileOffset -> RBIO ()
rb_seek_answered :: RBIO Bool
rb_msb_first :: RBIO Bool
rb_msb_first_set :: Bool -> RBIO ()
runRB :: RBState -> IterateeGM el RBIO a -> IO (IterateeG el RBIO a)

-- | A useful combinator. Perhaps a better idea would have been to define
--   Iteratee to have (Maybe a) in IE_done? In that case, we could make
--   IterateeGM to be the instance of MonadPlus
bindm :: (Monad m) => m (Maybe a) -> (a -> m (Maybe b)) -> m (Maybe b)

-- | We discard all available input first. We keep discarding the stream s
--   until we determine that our request has been answered: rb_seek_set
--   sets the state seek_req to (Just off). When the request is answered,
--   the state goes back to Nothing. The above features remind one of
--   delimited continuations.
sseek :: FileOffset -> IterateeGM el RBIO ()

-- | An iteratee that reports and propagates an error We disregard the
--   input first and then propagate error. It is reminiscent of
--   <tt>abort</tt>
iter_err :: (Monad m) => String -> IterateeGM el m ()

-- | Read n elements from a stream and apply the given iteratee to the
--   stream of the read elements. If the given iteratee accepted fewer
--   elements, we stop. This is the variation of <a>stake</a> with the
--   early termination of processing of the outer stream once the
--   processing of the inner stream finished early. This variation is
--   particularly useful for randomIO, where we do not have to care to
--   `drain the input stream'.
stakeR :: (Monad m) => Int -> EnumeratorN el el m a

-- | Iteratees to read unsigned integers written in Big- or Little-endian
--   ways
endian_read2 :: IterateeGM Word8 RBIO (Maybe Word16)
endian_read4 :: IterateeGM Word8 RBIO (Maybe Word32)

-- | The enumerator of a POSIX Fd: a variation of enum_fd that supports
--   RandomIO (seek requests)
enum_fd_random :: Fd -> EnumeratorGM Word8 RBIO a
instance MonadIO RBIO
instance Monad RBIO


-- | A general-purpose TIFF library
--   
--   <a>http://okmij.org/ftp/Streams.html#random-bin-IO</a>
--   
--   The library gives the user the TIFF dictionary, which the user can
--   search for specific tags and obtain the values associated with the
--   tags, including the pixel matrix.
--   
--   The overarching theme is incremental processing: initially, only the
--   TIFF dictionary is read. The value associated with a tag is read only
--   when that tag is looked up (unless the value was short and was packed
--   in the TIFF dictionary entry). The pixel matrix (let alone the whole
--   TIFF file) is not loaded in memory -- the pixel matrix is not even
--   located before it is needed. The matrix is processed incrementally, by
--   a user-supplied iteratee.
--   
--   The incremental processing is accomplished by iteratees and
--   enumerators. The enumerators are indeed first-class, they are stored
--   in the interned TIFF dictionary data structure. These enumerators
--   represent the values associated with tags; the values will be read on
--   demand, when the enumerator is applied to a user-given iteratee.
--   
--   The library extensively uses nested streams, tacitly converting the
--   stream of raw bytes from the file into streams of integers, rationals
--   and other user-friendly items. The pixel matrix is presented as a
--   contiguous stream, regardless of its segmentation into strips and
--   physical arrangement. The library exhibits random IO and binary
--   parsing, reading of multi-byte numeric data in big- or little-endian
--   formats. The library can be easily adopted for AIFF, RIFF and other
--   IFF formats.
--   
--   We show a representative application of the library: reading a sample
--   TIFF file, printing selected values from the TIFF dictionary,
--   verifying the values of selected pixels and computing the histogram of
--   pixel values. The pixel verification procedure stops reading the pixel
--   matrix as soon as all specified pixel values are verified. The
--   histogram accumulation does read the entire matrix, but incrementally.
--   Neither pixel matrix processing procedure loads the whole matrix in
--   memory. In fact, we never read and retain more than the IO-buffer-full
--   of raw data.
module Codec.Image.Tiff

-- | Sample TIFF user code The following is sample code using the TIFF
--   library (whose implementation is in the second part of this file). Our
--   sample code prints interesting information from the TIFF dictionary
--   (such as the dimensions, the resolution and the name of the image)
--   
--   The sample file is a GNU logo (from http:<i></i>www.gnu.org) converted
--   from JPG to TIFF. Copyleft by GNU.
--   
--   The main user function. tiff_reader is the library function, which
--   builds the TIFF dictionary. process_tiff is the user function, to
--   extract useful data from the dictionary
--   
--   Sample TIFF processing function
--   
--   sample processing of the pixel matrix: computing the histogram
compute_hist :: TIFFDict -> IterateeGM Word8 RBIO (Int, IntMap Int)

-- | Another sample processor of the pixel matrix: verifying values of some
--   pixels This processor does not read the whole matrix; it stops as soon
--   as everything is verified or the error is detected
--   
--   TIFF library code
--   
--   We need a more general enumerator type: enumerator that maps streams
--   (not necessarily in lock-step). This is a flattened (`joinI-ed')
--   EnumeratorN elfrom elto m a
type EnumeratorGMM elfrom elto m a = IterateeG elto m a -> IterateeGM elfrom m a

-- | A TIFF directory is a finite map associating a TIFF tag with a record
--   TIFFDE
type TIFFDict = IntMap TIFFDE
data TIFFDE
TIFFDE :: Int -> TIFFDE_ENUM -> TIFFDE
tiffde_count :: TIFFDE -> Int
tiffde_enum :: TIFFDE -> TIFFDE_ENUM
data TIFFDE_ENUM
TEN_CHAR :: (forall a. EnumeratorGMM Word8 Char RBIO a) -> TIFFDE_ENUM
TEN_BYTE :: (forall a. EnumeratorGMM Word8 Word8 RBIO a) -> TIFFDE_ENUM
TEN_INT :: (forall a. EnumeratorGMM Word8 Integer RBIO a) -> TIFFDE_ENUM
TEN_RAT :: (forall a. EnumeratorGMM Word8 Rational RBIO a) -> TIFFDE_ENUM

-- | Standard TIFF data types
data TIFF_TYPE
TT_NONE :: TIFF_TYPE
TT_byte :: TIFF_TYPE
TT_ascii :: TIFF_TYPE
TT_short :: TIFF_TYPE
TT_long :: TIFF_TYPE
TT_rational :: TIFF_TYPE
TT_sbyte :: TIFF_TYPE
TT_undefined :: TIFF_TYPE
TT_sshort :: TIFF_TYPE
TT_slong :: TIFF_TYPE
TT_srational :: TIFF_TYPE
TT_float :: TIFF_TYPE
TT_double :: TIFF_TYPE

-- | Standard TIFF tags
data TIFF_TAG
TG_other :: Int -> TIFF_TAG
TG_SUBFILETYPE :: TIFF_TAG
TG_OSUBFILETYPE :: TIFF_TAG
TG_IMAGEWIDTH :: TIFF_TAG
TG_IMAGELENGTH :: TIFF_TAG
TG_BITSPERSAMPLE :: TIFF_TAG
TG_COMPRESSION :: TIFF_TAG
TG_PHOTOMETRIC :: TIFF_TAG
TG_THRESHOLDING :: TIFF_TAG
TG_CELLWIDTH :: TIFF_TAG
TG_CELLLENGTH :: TIFF_TAG
TG_FILLORDER :: TIFF_TAG
TG_DOCUMENTNAME :: TIFF_TAG
TG_IMAGEDESCRIPTION :: TIFF_TAG
TG_MAKE :: TIFF_TAG
TG_MODEL :: TIFF_TAG
TG_STRIPOFFSETS :: TIFF_TAG
TG_ORIENTATION :: TIFF_TAG
TG_SAMPLESPERPIXEL :: TIFF_TAG
TG_ROWSPERSTRIP :: TIFF_TAG
TG_STRIPBYTECOUNTS :: TIFF_TAG
TG_MINSAMPLEVALUE :: TIFF_TAG
TG_MAXSAMPLEVALUE :: TIFF_TAG
TG_XRESOLUTION :: TIFF_TAG
TG_YRESOLUTION :: TIFF_TAG
TG_PLANARCONFIG :: TIFF_TAG
TG_PAGENAME :: TIFF_TAG
TG_XPOSITION :: TIFF_TAG
TG_YPOSITION :: TIFF_TAG
TG_FREEOFFSETS :: TIFF_TAG
TG_FREEBYTECOUNTS :: TIFF_TAG
TG_GRAYRESPONSEUNIT :: TIFF_TAG
TG_GRAYRESPONSECURVE :: TIFF_TAG
TG_GROUP3OPTIONS :: TIFF_TAG
TG_GROUP4OPTIONS :: TIFF_TAG
TG_RESOLUTIONUNIT :: TIFF_TAG
TG_PAGENUMBER :: TIFF_TAG
TG_COLORRESPONSEUNIT :: TIFF_TAG
TG_COLORRESPONSECURVE :: TIFF_TAG
TG_SOFTWARE :: TIFF_TAG
TG_DATETIME :: TIFF_TAG
TG_ARTIST :: TIFF_TAG
TG_HOSTCOMPUTER :: TIFF_TAG
TG_PREDICTOR :: TIFF_TAG
TG_WHITEPOINT :: TIFF_TAG
TG_PRIMARYCHROMATICITIES :: TIFF_TAG
TG_COLORMAP :: TIFF_TAG
TG_BADFAXLINES :: TIFF_TAG
TG_CLEANFAXDATA :: TIFF_TAG
TG_CONSECUTIVEBADFAXLINES :: TIFF_TAG
TG_MATTEING :: TIFF_TAG
tag_to_int :: TIFF_TAG -> Int
int_to_tag :: Int -> TIFF_TAG

-- | The library function to read the TIFF dictionary
tiff_reader :: IterateeGM Word8 RBIO (Maybe TIFFDict)

-- | A few conversion procedures
u32_to_float :: Word32 -> Double
u32_to_s32 :: Word32 -> Int32
u16_to_s16 :: Word16 -> Int16
u8_to_s8 :: Word8 -> Int8
note :: [String] -> IterateeGM el RBIO ()

-- | An internal function to load the dictionary. It assumes that the
--   stream is positioned to read the dictionary
load_dict :: IterateeGM Word8 RBIO (Maybe TIFFDict)

-- | Reading the pixel matrix For simplicity, we assume no compression and
--   8-bit pixels
pixel_matrix_enum :: TIFFDict -> EnumeratorN Word8 Word8 RBIO a

-- | A few helpers for getting data from TIFF dictionary
dict_read_int :: TIFF_TAG -> TIFFDict -> IterateeGM Word8 RBIO (Maybe Integer)
dict_read_ints :: TIFF_TAG -> TIFFDict -> IterateeGM Word8 RBIO (Maybe [Integer])
dict_read_rat :: TIFF_TAG -> TIFFDict -> IterateeGM Word8 RBIO (Maybe Rational)
dict_read_string :: TIFF_TAG -> TIFFDict -> IterateeGM Word8 RBIO (Maybe String)
instance Eq TIFF_TAG
instance Show TIFF_TAG
instance Eq TIFF_TYPE
instance Enum TIFF_TYPE
instance Ord TIFF_TYPE
instance Bounded TIFF_TYPE
instance Show TIFF_TYPE


-- | This file is part of the code accompanying the paper `Fun with type
--   functions' Joint work with Simon Peyton Jones and Chung-chieh Shan See
--   the paper for explanations.
module Control.Mutation

-- | Start basic
class Mutation m where { type family Ref m :: * -> *; }
newRef :: (Mutation m) => a -> m (Ref m a)
readRef :: (Mutation m) => Ref m a -> m a
writeRef :: (Mutation m) => Ref m a -> a -> m ()
instance (Monad m, Mutation m, MonadTrans t) => Mutation (t m)
instance Mutation (ST s)
instance Mutation IO


-- | Monad transformer for multi-prompt delimited control
--   
--   This library implements the superset of the interface described in
--   
--   <pre>
--   A Monadic Framework for Delimited Continuations
--   R. Kent Dybvig, Simon Peyton Jones, and Amr Sabry
--   JFP, v17, N6, pp. 687--730, 2007.
--   http://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR615
--   </pre>
--   
--   This code is the straightforward implementation of the definitional
--   machine described in the above paper. To be precise, we implement an
--   equivalent machine, where captured continuations are always sandwiched
--   between two prompts. This equivalence as well as the trick to make it
--   all well-typed are described in the FLOPS 2010 paper. Therefore, to
--   the great extent this code is the straightforward translation of
--   delimcc from OCaml. The parallel stack of delimcc is the <tt>real</tt>
--   stack now (containing parts of the real continuation, that is).
--   
--   This code implements, in CPS, what amounts to a segmented stack (the
--   technique of implementing call/cc efficiently, first described in
--   Hieb, Dybvig and Bruggeman's PLDI 1990 paper).
module Control.CCRef

-- | Delimited-continuation monad transformer The (CC m) monad is the Cont
--   monad with the answer-type (), combined with the persistent-state
--   monad. The state PTop is the `parallel stack' of delimcc, which is the
--   real stack now. The base monad m must support reference cells, that
--   is, be a member of the type class Mutation. Since we need reference
--   cells anyway, we represent the persistent state as a reference cell
--   PTop, which is passed as the environment.
data CC m a

-- | The context between two exception frames: The captured
--   sub-continuation It is a fragment of the parallel stack: a list of
--   PFrames in inverse order. Since we are in the Cont monad, there is no
--   <tt>real</tt> stack: the type Ekfragment is ()
data SubCont m a b

-- | We manipulate portions of the stack between two exception frames. The
--   type of the exception DelimCCE is ()
--   
--   The type of prompts is just like that in OCaml's delimcc
data Prompt m a

-- | Basic Operations of the delimited control interface All control
--   operators in the end jump to the exception frame
--   
--   <pre>
--   (in delimcc, that was `raise DelimCCE'; here it is `pfr_ek h')
--   </pre>
newPrompt :: (Monad m, Mutation m) => CC m (Prompt m a)
pushPrompt :: (Monad m, Mutation m) => Prompt m w -> CC m w -> CC m w
takeSubCont :: (Monad m, Mutation m) => Prompt m b -> (SubCont m a b -> CC m b) -> CC m a
pushSubCont :: (Monad m, Mutation m) => SubCont m a b -> CC m a -> CC m b
runCC :: (Monad m, Mutation m) => CC m a -> m a

-- | An efficient variation of take_subcont, which does not capture any
--   continuation. This code makes it clear that abort is essentially
--   raise.
abortP :: (Monad m, Mutation m) => Prompt m w -> CC m w -> CC m any

-- | An optimization: pushing the _delimited_ continuation. This is the
--   optimization of the pattern
--   
--   <pre>
--   pushPrompt (subcont_pb sk) (pushSubcont sk m)
--   </pre>
--   
--   corresponding to pushing the continuation captured by shift/shift0.
--   The latter continuation always has the delimiter at the end. Indeed
--   shift can be implemented more efficiently as a primitive rather than
--   via push_prompt/control combination...
pushDelimSubCont :: (Monad m, Mutation m) => SubCont m a b -> CC m a -> CC m b

-- | Useful derived operations
shiftP :: (Monad m, Mutation m) => Prompt m w -> ((a -> CC m w) -> CC m w) -> CC m a
shift0P :: (Monad m, Mutation m) => Prompt m w -> ((a -> CC m w) -> CC m w) -> CC m a
controlP :: (Monad m, Mutation m) => Prompt m w -> ((a -> CC m w) -> CC m w) -> CC m a

-- | Check to see if a prompt is set
isPromptSet :: (Monad m, Mutation m) => Prompt m w -> CC m Bool
instance (MonadIO m) => MonadIO (CC m)
instance MonadTrans CC
instance (Monad m) => Monad (CC m)

module Control.CCCxe

-- | Delimited-continuation monad transformer It is parameterized by the
--   prompt flavor p The first argument is the regular (success)
--   continuation, the second argument is the bubble, or a resumable
--   exception
data CC p m a

-- | The captured sub-continuation
type SubCont p m a b = CC p m a -> CC p m b

-- | The type of control operator's body
type CCT p m a w = SubCont p m a w -> CC p m w

-- | Generalized prompts for the answer-type w: an injection-projection
--   pair
type Prompt p m w = (forall x. CCT p m x w -> p m x, forall x. p m x -> Maybe (CCT p m x w))

-- | Basic Operations of the delimited control interface
pushPrompt :: (Monad m) => Prompt p m w -> CC p m w -> CC p m w

-- | Create the initial bubble
takeSubCont :: (Monad m) => Prompt p m w -> CCT p m x w -> CC p m x

-- | Apply the captured continuation
pushSubCont :: (Monad m) => SubCont p m a b -> CC p m a -> CC p m b
runCC :: (Monad m) => CC (p :: (* -> *) -> * -> *) m a -> m a

-- | Useful derived operations
abortP :: (Monad m) => Prompt p m w -> CC p m w -> CC p m any
shiftP :: (Monad m) => Prompt p m w -> ((a -> CC p m w) -> CC p m w) -> CC p m a
shift0P :: (Monad m) => Prompt p m w -> ((a -> CC p m w) -> CC p m w) -> CC p m a
controlP :: (Monad m) => Prompt p m w -> ((a -> CC p m w) -> CC p m w) -> CC p m a

-- | The extreme case: prompts for the single answer-type w. The monad (CC
--   PS) then is the monad for regular (single-prompt) delimited
--   continuations
data PS w m x

-- | There is only one generalized prompt of the flavor PS for a given
--   answer-type w. It is defined below
ps :: Prompt (PS w) m w

-- | Prompts for the closed set of answer-types The following prompt flavor
--   P2, for two answer-types w1 and w2, is given as an example. Typically,
--   a programmer would define their own variant data type with variants
--   for the answer-types that occur in their program.
data P2 w1 w2 m x

-- | There are two generalized prompts of the flavor P2
p2L :: Prompt (P2 w1 w2) m w1
p2R :: Prompt (P2 w1 w2) m w2

-- | Prompts for the open set of answer-types
data PP m x
pp :: (Typeable w) => Prompt PP m w

-- | The same as PP but with the phantom parameter c The parameter is
--   useful to statically enforce various constrains (statically pass some
--   information between shift and reset) The prompt PP is too
--   <tt>dynamic</tt>: all errors are detected dynamically See
--   Generator2.hs for an example
data PM c m x
pm :: (Typeable w) => Prompt (PM c) m w

-- | Open set of answer types, with an additional distinction (given by
--   integer identifiers) This prompt flavor corresponds to the prompts in
--   the Dybvig, Peyton-Jones, Sabry framework (modulo the Typeable
--   constraint).
data PD m x
newPrompt :: (Typeable w) => Int -> Prompt PD m w

-- | It is often helpful, for clarity of error messages, to specify the
--   answer-type associated with the prompt explicitly (rather than relying
--   on the type inference to figure that out). The following function is
--   useful for that purpose.
as_prompt_type :: Prompt p m w -> w -> Prompt p m w
instance (MonadIO m) => MonadIO (CC p m)
instance MonadTrans (CC p)
instance (Monad m) => Monad (CC p m)


-- | Monad transformer for multi-prompt delimited control It implements the
--   superset of the interface described in
--   
--   
--   <a>http://okmij.org/ftp/continuations/implementations.html#CC-monads</a>
--   
--   <pre>
--   A Monadic Framework for Delimited Continuations
--   R. Kent Dybvig, Simon Peyton Jones, and Amr Sabry
--   JFP, v17, N6, pp. 687--730, 2007.
--   http://www.cs.indiana.edu/cgi-bin/techreports/TRNNN.cgi?trnum=TR615
--   </pre>
--   
--   The first main difference is the use of generalized prompts, which do
--   not have to be created with new_prompt and therefore can be defined at
--   top level. That removes one of the main practical drawbacks of Dybvig
--   et al implementations: the necessity to carry around the prompts
--   throughout all the code.
--   
--   The delimited continuation monad is parameterized by the flavor of
--   generalized prompts. The end of this code defines several flavors; the
--   library users may define their own. User-defined flavors are
--   especially useful when user's code uses a small closed set of
--   answer-types. Flavors PP and PD below are more general, assuming the
--   set of possible answer-types is open and Typeable. If the user wishes
--   to create several distinct prompts with the same answer-types, the
--   user should use the flavor of prompts accepting an integral prompt
--   identifier, such as PD. Prompts of the flavor PD correspond to the
--   prompts in Dybvig, Peyton Jones, Sabry framework. If the user wishes
--   to generate unique prompts, the user should arrange himself for the
--   generation of unique integers (using a state monad, for example). On
--   the other hand, the user can differentiate answer-types using
--   `newtype.' The latter can only produce the set of distinct prompts
--   that is fixed at run-time. Sometimes that is sufficient. There is not
--   need to create a gensym monad then.
--   
--   The second feature of our implementation is the use of the bubble-up
--   semantics: See page 57 of
--   <a>http://okmij.org/ftp/gengo/CAG-talk.pdf</a> This present code
--   implements, for the first time, the delimited continuation monad CC
--   *without* the use of the continuation monad. This code implements CC
--   in direct-style, so to speak. Instead of continuations, we rely on
--   exceptions. Our code has a lot in common with the Error monad. In
--   fact, our code implements an Error monad for resumable exceptions.
module Control.CCExc

-- | Delimited-continuation monad transformer It is parameterized by the
--   prompt flavor p
data CC p m a

-- | The captured sub-continuation
type SubCont p m a b = CC p m a -> CC p m b

-- | The type of control operator's body
type CCT p m a w = SubCont p m a w -> CC p m w

-- | Generalized prompts for the answer-type w: an injection-projection
--   pair
type Prompt p m w = (forall x. CCT p m x w -> p m x, forall x. p m x -> Maybe (CCT p m x w))

-- | Basic Operations of the delimited control interface
pushPrompt :: (Monad m) => Prompt p m w -> CC p m w -> CC p m w

-- | Create the initial bubble
takeSubCont :: (Monad m) => Prompt p m w -> CCT p m x w -> CC p m x
pushSubCont :: (Monad m) => SubCont p m a b -> CC p m a -> CC p m b
runCC :: (Monad m) => CC (p :: (* -> *) -> * -> *) m a -> m a

-- | Useful derived operations
abortP :: (Monad m) => Prompt p m w -> CC p m w -> CC p m any
shiftP :: (Monad m) => Prompt p m w -> ((a -> CC p m w) -> CC p m w) -> CC p m a
shift0P :: (Monad m) => Prompt p m w -> ((a -> CC p m w) -> CC p m w) -> CC p m a
controlP :: (Monad m) => Prompt p m w -> ((a -> CC p m w) -> CC p m w) -> CC p m a

-- | The extreme case: prompts for the single answer-type w. The monad (CC
--   PS) then is the monad for regular (single-prompt) delimited
--   continuations
data PS w m x

-- | There is only one generalized prompt of the flavor PS for a given
--   answer-type w. It is defined below
ps :: Prompt (PS w) m w

-- | Prompts for the closed set of answer-types The following prompt flavor
--   P2, for two answer-types w1 and w2, is given as an example. Typically,
--   a programmer would define their own variant data type with variants
--   for the answer-types that occur in their program.
data P2 w1 w2 m x

-- | There are two generalized prompts of the flavor P2
p2L :: Prompt (P2 w1 w2) m w1
p2R :: Prompt (P2 w1 w2) m w2

-- | Prompts for the open set of answer-types
data PP m x
pp :: (Typeable w) => Prompt PP m w

-- | The same as PP but with the phantom parameter c The parameter is
--   useful to statically enforce various constrains (statically pass some
--   information between shift and reset) The prompt PP is too
--   <tt>dynamic</tt>: all errors are detected dynamically See
--   Generator2.hs for an example
data PM c m x
pm :: (Typeable w) => Prompt (PM c) m w

-- | Open set of answer types, with an additional distinction (given by
--   integer identifiers) This prompt flavor corresponds to the prompts in
--   the Dybvig, Peyton-Jones, Sabry framework (modulo the Typeable
--   constraint).
data PD m x
newPrompt :: (Typeable w) => Int -> Prompt PD m w

-- | It is often helpful, for clarity of error messages, to specify the
--   answer-type associated with the prompt explicitly (rather than relying
--   on the type inference to figure that out). The following function is
--   useful for that purpose.
as_prompt_type :: Prompt p m w -> w -> Prompt p m w
instance (MonadIO m) => MonadIO (CC p m)
instance MonadTrans (CC p)
instance (Monad m) => Monad (CC p m)


-- | Generators in Haskell
--   
--   We translate the in-order tree traversal example from an old article
--   Generators in Icon, Python, and Scheme, 2004.
--   
--   <a>http://okmij.org/ftp/Scheme/enumerators-callcc.html#Generators</a>
--   
--   using Haskell and delimited continuations rather than call/cc +
--   mutation. The code is shorter, and it even types. To be honest, we
--   actually translate the OCaml code generator.ml
--   
--   In this code, we use a single global prompt (that is, ordinary shift0)
--   Generator2.hs shows the need for several prompts.
module Control.Generator1

-- | A few preliminaries: define the tree and build a sample tree
type Label = Int
data Tree
Leaf :: Tree
Node :: Label -> Tree -> Tree -> Tree
make_full_tree :: Int -> Tree

-- | In Python, <a>yield</a> is a keyword. In Haskell, it is a regular
--   function. Furthermore, it is a user-defined function, in one line of
--   code. To get generators there is no need to extend a language.
type P m a = PS (Res m a)
newtype Res m a
Res :: ((a -> CC (P m a) m ()) -> CC (P m a) m ()) -> Res m a
yield :: (Monad m) => a -> CC (P m a) m ()

-- | The enumerator: the for-loop essentially
--   
--   The in_order function itself: compare with the Python version
in_order :: (Monad m) => Tree -> CC (P m Label) m ()

-- | Print out the result of the in-order traversal
test_io :: IO ()

-- | Or return it as a pure list; the effects are encapsulated
test_st :: [Label]
instance Show Tree


-- | Generators in Haskell
--   
--   We translate the in-order tree traversal example from an old article
--   Generators in Icon, Python, and Scheme, 2004.
--   
--   <pre>
--   http://okmij.org/ftp/Scheme/enumerators-callcc.html#Generators
--   </pre>
--   
--   using Haskell and delimited continuations rather than call/cc +
--   mutation. The code is shorter, and it even types. To be honest, we
--   actually translate the OCaml code generator.ml
--   
--   This code is the extension of Generator1.hs; we use delimited control
--   not only to implement the generator. We also use delimited control to
--   accumulate the results in a list. We need two different prompts then
--   (with two different answer-types, as it happens). This file
--   illustrates the prompt flavors PP and PM, using newtypes to define
--   private global prompts (global prompts that are private to the current
--   module).
module Control.Generator2

-- | A few preliminaries: define the tree and build a sample tree
type Label = Int
data Tree
Leaf :: Tree
Node :: Label -> Tree -> Tree -> Tree
make_full_tree :: Int -> Tree

-- | In Python, <a>yield</a> is a keyword. In Haskell, it is a regular
--   function. Furthermore, it is a user-defined function, in one line of
--   code. To get generators there is no need to extend a language.
--   
--   First, we try the prompt flavor PP
--   
--   The answer-type for one of the prompts
newtype ResP m a
ResP :: ((a -> CC PP m ()) -> CC PP m ()) -> ResP m a

-- | One prompt, used by the generator (the yield/enumerate pair) We
--   instantiate the global pp to the desired answer-type.
ppy :: (Typeable1 m, Typeable a) => Prompt PP m (ResP m a)

-- | The rest of the code, up to test_io, is the same as that in
--   Generator1.hs
yieldP :: (Typeable1 m, Typeable a) => (Monad m) => a -> CC PP m ()

-- | The enumerator: the for-loop essentially
enumerateP :: (Typeable1 m, Typeable a, Monad m) => CC PP m () -> (a -> CC PP m ()) -> CC PP m ()

-- | The in_order function itself: compare with the Python version
in_orderP :: (Typeable1 m, Monad m) => Tree -> CC PP m ()

-- | Print out the result of the in-order traversal
test_ioP :: IO ()

-- | Using the prompt flavor PM
--   
--   The above code works. We can define the second pair of operators to
--   accummulate the result into a list. Yet, the solution is not very
--   satisfactory. We notice that the prompt type ppy is polymorphic over
--   a, the elements we yield. What ensures that <a>yieldP</a> yields
--   elements of the same type that enumerateP can pass to the body of the
--   loop? Nothing, actually, at compile time. If yieldP and enumerateP do
--   not agree on the type of the elements, a run-time error will occur.
--   This is where the PM prompt type comes in handy. It has a phantom type
--   parameter c, which can be used to communicate between producers and
--   consumers of the effect. We use the type parameter c to communicate
--   the type of elements, between yield and enumerate. Since the parameter
--   is phantom, it costs us nothing at run-time.
--   
--   The answer-type for one of the prompts
newtype Res m a
Res :: ((a -> CC (PM a) m ()) -> CC (PM a) m ()) -> Res m a

-- | One prompt, used by the generator (the yield/enumerate pair)
py :: (Typeable1 m, Typeable a) => Prompt (PM a) m (Res m a)

-- | The rest of the code, up to test_io, is the same as that in
--   Generator1.hs
yield :: (Typeable1 m, Typeable a) => (Monad m) => a -> CC (PM a) m ()

-- | The enumerator: the for-loop essentially
enumerate :: (Typeable1 m, Typeable a, Monad m) => CC (PM a) m () -> (a -> CC (PM a) m ()) -> CC (PM a) m ()

-- | The in_order function itself: compare with the Python version
in_order :: (Typeable1 m, Monad m) => Tree -> CC (PM Label) m ()

-- | Print out the result of the in-order traversal
test_io :: IO ()

-- | The second application of control: accumulating the results in a list
--   
--   The answer-type for the second prompt. We use newtype for
--   identification
newtype Acc a
Acc :: [a] -> Acc a

-- | The second prompt, used by the acc/accumulated pair Again we use the
--   mark of PM to communicate the type of the elements between <a>acc</a>
--   and <a>accumulated</a>. It happens to be the same type used by
--   yield/enumetrate. If that was not the case, we could have easily
--   arranged for a type-level record (see HList or the TFP paper).
pa :: (Typeable a) => Prompt (PM a) m (Acc a)
acc :: (Typeable a, Monad m) => a -> CC (PM a) m ()
accumulated :: (Typeable a, Monad m) => CC (PM a) m () -> CC (PM a) m [a]
test_acc :: [Label]

-- | To avoid importing mtl, we define Identity on our own
newtype Identity a
Identity :: a -> Identity a
runIdentity :: Identity a -> a
instance Typeable1 Identity
instance Typeable1 Acc
instance Show Tree
instance Monad Identity
instance (Typeable1 m) => Typeable1 (Res m)
instance (Typeable1 m) => Typeable1 (ResP m)


-- | Implementing the State Monad as a term algebra
--   
--   <a>http://okmij.org/ftp/Haskell/types.html#state-algebra</a>
module Control.StateAlgebra

-- | Monadic actions are terms composed from the following constructors
data Bind t f
Bind :: t -> f -> Bind t f
data Return v
Return :: v -> Return v
data Get
Get :: Get
data Put v
Put :: v -> Put v

-- | examples of terms
--   
--   An example of an ill-formed term
--   
--   An example of an ill-typed term The following term is ill-typed
--   because it attempts to store both a boolean and a character in the
--   state. Our state can have only one type.
--   
--   The interpreter of monadic actions It takes the term <tt>t</tt> and
--   the initial state of the type <tt>s</tt> and returns the final state
--   and the resulting value. The type of the result, <tt>a</tt>, is
--   uniquely determined by the term and the state
class (RunBind t s a) => RunState t s a | t s -> a
runst :: (RunState t s a) => t -> s -> (s, a)

-- | Interpretation of the Bind action requires an auxiliary class This is
--   due to the polymorphism of the monadic bind, which has the type
--   
--   <pre>
--   m a -&gt; (a -&gt; m b) -&gt; m b
--   </pre>
--   
--   Note the polymorphism both in <tt>a</tt> (value type of the input
--   monadic action) and <tt>b</tt> (value type of the resulting action)
class RunBind m s a
runbind :: (RunBind m s a, RunState t s b) => m -> (a -> t) -> s -> (s, b)

-- | We can now run (interpret) our sample terms
--   
--   term2 denoted the action of negating the current state and returning
--   the original state
--   
--   Now, we show that our term representation of the state monad is an
--   instance of MonadState
data Statte s a
Statte :: t -> Statte s a

-- | We can write computations expressed by term1 and term2 using the
--   normal monadic syntax
--   
--   The following identity function is to resolve polymorphism, to tell
--   that monadic terms below should use our representation of MonadState
as_statte :: Statte s a -> Statte s a
instance MonadState s (Statte s)
instance Monad (Statte s)
instance RunBind (Statte s a) s a
instance RunState (Statte s a) s a
instance (RunBind m s x, RunState y s w) => RunBind (Bind m (x -> y)) s w
instance RunBind (Put s) s ()
instance RunBind Get s s
instance RunBind (Return a) s a
instance (RunState m s a, RunState t s b) => RunState (Bind m (a -> t)) s b
instance RunState (Put s) s ()
instance RunState Get s s
instance RunState (Return a) s a


-- | Type-class overloaded functions: second-order typeclass programming
--   with backtracking
--   
--   <a>http://okmij.org/ftp/Haskell/types.html#poly2</a>
module Control.Poly2

-- | The classes of types used in the examples below
type Fractionals = Float :*: (Double :*: HNil)
type Nums = Int :*: (Integer :*: (AllOf Fractionals :*: HNil))
type Ords = Bool :*: (Char :*: (AllOf Nums :*: HNil))
type Eqs = AllOf (TypeCl OpenEqs) :*: (AllOfBut Ords Fractionals :*: HNil)

-- | The Fractionals, Nums and Ords above are closed. But Eqs is open
--   (i.e., extensible), due to the following:
data OpenEqs

-- | Why we call Nums etc. a type class rather than a type set? The
--   following does not work: type synonyms can't be recursive.
--   
--   <pre>
--   type Russel = AllOfBut () Russel :*: HNil
--   </pre>
--   
--   But the more elaborate version does, with the expected result:
data RusselC
type Russel = AllOfBut () (TypeCl RusselC) :*: HNil
data AllOf x
data AllOfBut x y
data TypeCl x

-- | Classifies if the type x belongs to the open class labeled l The
--   result r is either HTrue or HFalse
class TypeCls l x r | l x -> r

-- | Deciding the membership in a closed class, specified by enumeration,
--   union and difference
data Member tl
class MemApp bf t x r | bf t x -> r

-- | we avoid defining a new class like MemApp above. I guess, after Apply,
--   we don't need a single class ever?
data MemCase2 h t x

-- | A type class for instance guards and back-tracking Here, pred and f
--   are labels and n is of a kind numeral.
class GFN n f a pred | n f a -> pred

-- | The guard that always succeeds (cf. <a>otherwise</a> in Haskell)
data Otherwise
newtype GFn f
GFn :: f -> GFn f
newtype GFnA n f
GFnA :: f -> GFnA n f
newtype GFnTest n f flag
GFnTest :: f -> GFnTest n f flag

-- | A generic function that tests if its argument is a member of Eqs
data IsAnEq
IsAnEq :: IsAnEq

-- | The main test: approximate equality. See the article for the
--   description.
data PairOf t
data ApproxEq
ApproxEq :: ApproxEq
data ApproxEq'
ApproxEq' :: ApproxEq'
data HNil
HNil :: HNil
data (:*:) a b
(:*:) :: a -> b -> :*: a b
data HTrue
data HFalse
data Z
Z :: Z
newtype S n
S :: n -> S n
class TypeCast a b | a -> b, b -> a
typeCast :: (TypeCast a b) => a -> b
class TypeCast' t a b | t a -> b, t b -> a
typeCast' :: (TypeCast' t a b) => t -> a -> b
class TypeCast'' t a b | t a -> b, t b -> a
typeCast'' :: (TypeCast'' t a b) => t -> a -> b
class TypeEq x y b | x y -> b
class Apply f a r | f a -> r
apply :: (Apply f a r) => f -> a -> r
instance [overlap ok] Apply (x -> y) x y
instance [overlap ok] (TypeCast HFalse b) => TypeEq x y b
instance [overlap ok] TypeEq x x HTrue
instance [overlap ok] TypeCast'' () a a
instance [overlap ok] (TypeCast'' t a b) => TypeCast' t a b
instance [overlap ok] (TypeCast' () a b) => TypeCast a b
instance [overlap ok] Apply (GFnA n ApproxEq') a Bool
instance [overlap ok] (TypeCast pred Otherwise) => GFN n ApproxEq' a pred
instance [overlap ok] (Num x, Ord x) => Apply (GFnA Z ApproxEq') (x, x) Bool
instance [overlap ok] GFN Z ApproxEq' (x, x) (PairOf (Member Nums))
instance [overlap ok] (Fractional x, Ord x) => Apply (GFnA (S Z) ApproxEq') (x, x) Bool
instance [overlap ok] GFN (S Z) ApproxEq' (x, x) (PairOf (Member Fractionals))
instance [overlap ok] Apply (GFnA n ApproxEq) a Bool
instance [overlap ok] (TypeCast pred Otherwise) => GFN n ApproxEq a pred
instance [overlap ok] (Apply (GFn ApproxEq) (x, x) Bool, Eq x) => Apply (GFnA (S (S (S Z))) ApproxEq) ((x, x), (x, x)) Bool
instance [overlap ok] GFN (S (S (S Z))) ApproxEq ((x, x), (x, x)) (PairOf (PairOf (Member Nums)))
instance [overlap ok] (Eq x) => Apply (GFnA (S (S Z)) ApproxEq) (x, x) Bool
instance [overlap ok] GFN (S (S Z)) ApproxEq (x, x) (PairOf (Member Eqs))
instance [overlap ok] (Num x, Ord x) => Apply (GFnA (S Z) ApproxEq) (x, x) Bool
instance [overlap ok] GFN (S Z) ApproxEq (x, x) (PairOf (Member Nums))
instance [overlap ok] (Fractional x, Ord x) => Apply (GFnA Z ApproxEq) (x, x) Bool
instance [overlap ok] GFN Z ApproxEq (x, x) (PairOf (Member Fractionals))
instance [overlap ok] (TypeCast r HFalse) => Apply (PairOf t) x r
instance [overlap ok] (Apply t x r) => Apply (PairOf t) (x, x) r
instance [overlap ok] (Apply (GFn IsAnEq) x Bool, Apply (GFn IsAnEq) y Bool) => Apply (GFnA (S Z) IsAnEq) (x, y) Bool
instance [overlap ok] GFN (S Z) IsAnEq (x, y) Otherwise
instance [overlap ok] Apply (GFnA n IsAnEq) a Bool
instance [overlap ok] (TypeCast pred Otherwise) => GFN n IsAnEq a pred
instance [overlap ok] Apply (GFnA Z IsAnEq) a Bool
instance [overlap ok] GFN Z IsAnEq a (Member Eqs)
instance [overlap ok] (GFN (S n) f a pred, Apply pred a flag, Apply (GFnTest (S n) f flag) a b) => Apply (GFnTest n f HFalse) a b
instance [overlap ok] (Apply (GFnA n f) a b) => Apply (GFnTest n f HTrue) a b
instance [overlap ok] (GFN Z f a pred, Apply pred a flag, Apply (GFnTest Z f flag) a b) => Apply (GFn f) a b
instance [overlap ok] Apply Otherwise a HTrue
instance [overlap ok] (Apply (Member (AllOf h :*: t)) x r) => Apply (MemCase2 h t x) HFalse r
instance [overlap ok] (Apply (Member t) x r) => Apply (MemCase2 h t x) HTrue r
instance [overlap ok] (Apply (Member t) x r) => MemApp HFalse t x r
instance [overlap ok] MemApp HTrue t x HTrue
instance [overlap ok] (Apply (Member exc) x bf, Apply (MemCase2 h t x) bf r) => Apply (Member (AllOfBut h exc :*: t)) x r
instance [overlap ok] (Apply (Member h) x bf, MemApp bf t x r) => Apply (Member (AllOf h :*: t)) x r
instance [overlap ok] (TypeEq h x bf, MemApp bf t x r) => Apply (Member (h :*: t)) x r
instance [overlap ok] (TypeCls l x r) => Apply (Member (TypeCl l)) x r
instance [overlap ok] Apply (Member HNil) x HFalse
instance [overlap ok] (TypeCast r HFalse) => TypeCls l x r
instance [overlap ok] (Apply (Member Russel) x r) => TypeCls RusselC x r
instance [overlap ok] TypeCls OpenEqs () HTrue


-- | Extensible Denotational Semantics
--   
--   This work is a generalization of /Extensible Denotational Language
--   Specifications Robert Cartwright, Matthias Felleisen Theor. Aspects of
--   Computer Software, 1994/ <a>http://citeseer.ist.psu.edu/69837.html</a>
--   
--   to be referred to as EDLS.
--   
--   We implement the enhanced EDLS in Haskell and add delimited control.
--   To be precise, we implement the Base interpreter (whose sole
--   operations are Loop and Error) and the following extensions: CBV
--   lambda-calculus, Arithmetic, Storage, Control. The extensions can be
--   added to the Base interpreter in any order and in any combination.
--   
--   Our implementation has the following advantages over EDLS:
--   
--   <ul>
--   <li>support for delimited control * support for a local storage
--   (including `thread-local' storage and general delimited dynamic
--   binding) * extensions do not have to be composed explicitly, and so
--   the composition order truly does not matter. In the original EDLS, one
--   had to write interpreter composition explicitly. In our approach, an
--   extension is pulled in automatically if the program includes the
--   corresponding syntactic forms. For example, if a program contains
--   storage cell creation and dereference operations, the Storage
--   extension will automatically be used to interpret the program.</li>
--   </ul>
--   
--   Our main departure from EDLS is is the removal of the `central
--   authority'. There is no semantic <tt>admin</tt> function. Rather,
--   admin is part of the source language and can be used at any place in
--   the code. The `central authority' of EDLS must be an extensible
--   function, requiring meta-language facilities to implement (such as
--   quite non-standard Scheme modules). We do not have central authority.
--   Rather, we have bureaucracy: each specific effect handler interprets
--   its own effects as it can, throwing the rest <tt>upstairs</tt> for
--   higher-level bureaucrats to deal with. Extensibility arises
--   automatically.
--   
--   We take the meaning of a program to be the union of Values and
--   (unfulfilled) Actions. If the meaning of the program is a (non-bottom)
--   value, the program is terminating. If the meaning of the program is an
--   Action -- the program finished with an error, such as an action to
--   access a non-existing storage cell, or shift without reset, or a
--   user-raised error.
--   
--   Incidentally, EDLS stresses on p. 2 (the last full paragraph) that
--   their schema critically relies on the distinction between a complete
--   program and a nested program phrase. Our contribution (which is the
--   consequence of removing the central admin, making it first-class) is
--   eliminating such a distinction! EDLS says, at the very top of p. 3,
--   that the handle in the effect message ``is roughly a conventional
--   continuation.'' Because the admin of EDLS is <tt>outside</tt> of the
--   program (at the point of infinity, so to speak), its continuation
--   indeed appears undelimited. By making our <tt>admin</tt> a part of the
--   source language, we recognize the handle in the effect message for
--   what it is: a _delimited_ continuation.
--   
--   As we see below, the Control aspect is orthogonal to the CBV aspect.
--   So, we can just as easily replace the CBV extension with the CBN
--   extension, which will give us the denotation of delimited control in
--   CBN.
--   
--   We shall be using Haskell to express denotations, taking advantage of
--   the fact that Haskell values are <tt>lifted</tt>. See also the remark
--   on p21 of EDLS: someone (ref. [4]) showed that sets and partial
--   functions can suffice...
--   
--   Our program denotations are stable: they have the same form regardless
--   of a particular composition of modular interpreters. See Section 3.5
--   of EDLS for precise formulation (and the last paragraph of Section 3.4
--   for concise informal statement of stability). Also see the comparison
--   with the monads on p. 20: different monads assign numeral radically
--   different meanings, depending on the monad. But in EDLS, a numeral has
--   exactly the same denotation.
--   
--   The meaning of an expression is also the same and stable, no matter
--   what the interpreter is: it is a function from Env to Computations
--   (the latter being the union of values and unfulfilled effects -- the
--   same union mentioned above).
--   
--   However, by using handlers, some effect messages can be subtracted:
--   so, strictly speaking, the denotation of a fragment is V +
--   effect-message-issued - effect-messages handled. There seem to be a
--   connection with effect systems.
--   
--   Additional notes on EDLS:
--   
--   The abstract and p. 2 (especially the last full paragraph) are so
--   well-written!
--   
--   p. 5, bottom: ``It [ref x.x, where ref means what it does in ML] is a
--   closed expression that does not diverge, is not a value, and cannot be
--   reduced to a value without affecting the context. We refer to such
--   results as _effects_.''
--   
--   Beginning of Section 3 and App A give a very good introduction to the
--   denotational semantics.
--   
--   p. 6: ``Algebraically speaking, the interpreter is (roughly) a
--   homomorphism from syntax to semantics''
--   
--   ``A straightforward representation of an evaluation context is a
--   function from values to computations, which directly corresponds to
--   its operational usage as a function from syntactic values to
--   expressions.'' (p. 8). EDLS then notices that the <tt>handle</tt> has
--   the same type as the denotation of a context. Footnote 6 notes that
--   handler is roughly the composition combinator for functions from
--   values to computations [contexts!] and it superficially relates to
--   [bind] but does not satisfy all monad laws.
--   
--   The last of EDLS Sec 3.5, p. 15: ``Informally speaking, this property
--   [stable denotations] asserts that in the framework of extensible
--   semantics, the addition of a programming construct corresponds to the
--   addition of a new `<tt>dimension'</tt> to the space of meaning. [The
--   equations, featuring injection and projection functions, make that
--   precise and clear.] The reader may want to contrast this general
--   statement with the numerous papers on the relationship between direct
--   and continuation semantics.''
--   
--   The practical consequence of the lack of stability of denotations for
--   monads is that monadic transformers put layers upon layers of thunks,
--   which have to be carried over _in full_ from one sub-expression into
--   the other, even if no single subexpression uses all of the features.
--   
--   The present code is not written in idiomatic Haskell and does not take
--   advantage of types at all. The ubiquitous projections from the
--   universal domain tantamount to ``dynamic typing.'' The code is
--   intentionally written to be close to the EDLS paper, emphasizing
--   denotational semantics (whose domains are untyped). One can certainly
--   do better, for example, employ user-defined datatypes for tagged
--   values, avoiding the ugly string-tagged VT.
module Control.ExtensibleDS

-- | The universal domain Yes, it is untyped... But Denot semantics is like
--   this anyway... Bottom is the implicit member of this domain.
data Value
VI :: Int -> Value
VS :: String -> Value
VP :: Value -> Value -> Value
VF :: (Value -> Value) -> Value
VT :: Tag -> Value -> Value
type Tag = String
type Action = Value

-- | Computations: just like in EDLS The strictness of inV guarantees that
--   inV bottom = bottom, as on Fig. 3 of EDLS Error is always a part of
--   the computation
data Comp
InV :: !Value -> Comp
InFX :: (Value -> Comp) -> Action -> Comp

-- | Auxiliary functions
newtype V
V :: String -> V
type Env v = V -> v

-- | Note that inV is essentially the identity <tt>partial</tt>
--   continuation
--   
--   The error <a>raise</a> action and its tag
--   
--   The universal handler of actions It propagates the action request InFX
--   up. Since we do case-analysis on the first argument, v, the handler is
--   strict in that argument. That is, handler bottom ==&gt; bottom, as
--   required by Fig. 3 of EDLS. The last clause is essentially the
--   denotation of a `control channel'
--   
--   Expressions and their interpretations This is an open data type and an
--   open function. Haskell typeclasses are ideal for that.
--   
--   This is the function curlyM of EDLS
class Interpretor exp
interpret :: (Interpretor exp) => exp -> Env Value -> Comp

-- | The base language has only two expressions: omega and error See Fig. 3
--   (p. 7) of EDLS
data BE_err
BE_err :: BE_err
data BE_omega
BE_omega :: BE_omega

-- | The meaning of a program
--   
--   Extension: Call-by-Value: see a part Fig. 4 of EDLS (or, Fig. 8)
--   
--   We add closures (procedures) to the Base
type Proc = Value -> Comp
class PV u
inP :: (PV u) => Proc -> u
prP :: (PV u) => u -> Maybe (Proc)
type Var = V
data Lam e
Lam :: V -> e -> Lam e
data App e1 e2
(:@) :: e1 -> e2 -> App e1 e2

-- | Create a few variables for use in examples
vy :: Var
vr :: Var
vf :: Var
vx :: Var

-- | Denotations of the new actions (inj<i>proj to</i>from the Universal
--   Domain)
--   
--   inject and project computations
inComp :: Comp -> Value
prComp :: Value -> Maybe Comp

-- | Extension: Arithmetic: see a part Fig. 4 of EDLS
class PN u
inN :: (PN u) => Int -> u
prN :: (PN u) => u -> Maybe Int
data IntC
IntC :: Int -> IntC
data Add1
Add1 :: Add1

-- | Extension: State: see Fig. 5 of EDLS
newtype Loc
Loc :: Int -> Loc
class PL u
inL :: (PL u) => Loc -> u
prL :: (PL u) => u -> Maybe Loc

-- | a better idea is Loc -&gt; Maybe Value, so that when lookup fails, we
--   can re-throw that Deref or Set message. That would make the storage
--   extensible... The first component of the pair is the allocation
--   counter
type Sto = (Int, Loc -> Value)
inSto :: Sto -> Value
prSto :: Value -> Maybe Sto
init_sto :: Sto

-- | new expressions
data Ref e
Ref :: e -> Ref e
data Deref e
Deref :: e -> Deref e
data Set e1 e2
Set :: e1 -> e2 -> Set e1 e2

-- | Now we need a storage admin It is treated as an expression in the
--   source language!
data StoAdmin e
StoAdmin :: Sto -> e -> StoAdmin e
inControl :: (Value -> Comp) -> Value
prControl :: Value -> Maybe (Value -> Comp)
data Control e
Control :: e -> Control e
data ControlAdmin e
ControlAdmin :: e -> ControlAdmin e
instance Eq Loc
instance Show Loc
instance Eq V
instance Show V
instance (Interpretor e) => Interpretor (ControlAdmin e)
instance (Interpretor e) => Interpretor (Control e)
instance PL Value
instance (Interpretor e) => Interpretor (StoAdmin e)
instance (Interpretor e1, Interpretor e2) => Interpretor (Set e1 e2)
instance (Interpretor e) => Interpretor (Deref e)
instance (Interpretor e) => Interpretor (Ref e)
instance PN Value
instance Interpretor Add1
instance Interpretor IntC
instance PV Value
instance (Interpretor e1, Interpretor e2) => Interpretor (App e1 e2)
instance (Interpretor e) => Interpretor (Lam e)
instance Interpretor V
instance Interpretor BE_err
instance Interpretor BE_omega
instance Show Comp
instance Show Value


-- | Variable state monad
--   
--   <a>http://okmij.org/ftp/Computation/monads.html#param-monad</a>
--   
--   The familiar State monad lets us represent computations with a state
--   that can be queried and updated. The state must have the same type
--   during the entire computation however. One sometimes wants to express
--   a computation where not only the value but also the type of the state
--   can be updated -- while maintaining static typing. We wish for a
--   parameterized <tt>monad</tt> that indexes each monadic type by an
--   initial (type)state and a final (type)state. The effect of an
--   effectful computation thus becomes apparent in the type of the
--   computation, and so can be statically reasoned about.
module Control.VarStateM

-- | A parameterized <tt>monad</tt>
class Monadish m
gret :: (Monadish m) => a -> m p p a
gbind :: (Monadish m) => m p q a -> (a -> m q r b) -> m p r b

-- | Inject regular monads to be monadish things too
newtype MW m p q a
MW :: m a -> MW m p q a
unMW :: MW m p q a -> m a

-- | First, use the regular Monad.State
--   
--   Now, wrap in MW
--   
--   Introduce the variable-type state
newtype VST m si so v
VST :: (si -> m (so, v)) -> VST m si so v
runVST :: VST m si so v -> si -> m (so, v)
vsget :: (Monad m) => VST m si si si
vsput :: (Monad m) => so -> VST m si so ()

-- | Try polymorphic recursion, over the state. crec1 invokes itself, and
--   changes the type of the state from some si to Bool.
crec1 :: (Enum si, Monad m) => VST m si si Int

-- | Another example, to illustrate locking and static reasoning about the
--   locking state
data Locked
Locked :: Locked
data Unlocked
Unlocked :: Unlocked
data LIO p q a
LIO :: IO a -> LIO p q a
unLIO :: LIO p q a -> IO a
lput :: String -> LIO p p ()
lget :: LIO p p String
lock :: LIO Unlocked Locked ()
unlock :: LIO Locked Unlocked ()
instance Monadish LIO
instance (Monad m) => Monadish (VST m)
instance (Monad m) => Monadish (MW m)


-- | Implementation of the calculus lambda-sr-let
--   
--   <pre>
--   Polymorphic delimited continuations
--   Asai and Kameyama, APLAS 2007
--   http://logic.cs.tsukuba.ac.jp/~kam/paper/aplas07.pdf
--   hereafter, AK07
--   </pre>
--   
--   This embedding of the AK07 calculus into Haskell is another proof that
--   AK07 admit type inference algorithm. In all the tests below, all the
--   types are inferred.
module Control.ShiftResetGenuine

-- | Parameterized monad. This is almost the same monad used in the
--   Region-IO and TFP07 paper See also
--   
--   <pre>
--   Robert Atkey, Parameterised Notions of Computation, Msfp2006
--   http://homepages.inf.ed.ac.uk/ratkey/param-notions.pdf
--   </pre>
--   
--   and
--   
--   <pre>
--   http://www.haskell.org/pipermail/haskell/2006-December/018917.html
--   </pre>
class Monadish m
ret :: (Monadish m) => tau -> m a a tau
bind :: (Monadish m) => m b g sigma -> (sigma -> m a b tau) -> m a g tau

-- | Inject regular monads to be monadish things too
newtype MW m p q a
MW :: m a -> MW m p q a
unMW :: MW m p q a -> m a

-- | some syntactic sugar
--   
--   The continuation monad parameterized by two answer types We represent
--   the the effectful expression e, whose type is characterized by the
--   judgement
--   
--   <pre>
--   Gamma; a |- e:tau; b
--   </pre>
--   
--   as a parameterized monad C a b tau. We represent an effectful function
--   type sigma<i>a -&gt; tau</i>b of the calculus as an arrow type sigma
--   -&gt; C a b tau. Incidentally, this notational <tt>convention</tt>
--   expresses the rule <tt>fun</tt> in AK07
newtype C a b tau
C :: ((tau -> a) -> b) -> C a b tau
unC :: C a b tau -> (tau -> a) -> b

-- | The rules from AK07 as they are (see Fig 3)
reset :: C sigma tau sigma -> C a a tau

-- | shift.
shift :: ((tau -> C t t a) -> C s b s) -> C a b tau
run :: C tau tau tau -> tau

-- | The append example from AK07, section 2.1
--   
--   The sprintf test: Sec 2.3 of AK07 The paper argues this test requires
--   both the changing of the answer type and polymorphism (fmt is used
--   polymorphically in stest3)
int :: Int -> String
str :: String -> String
instance Monadish C
instance (Monad m) => Monadish (MW m)


-- | <a>http://okmij.org/ftp/Haskell/misc.html#catch-MonadIO</a>
--   
--   The ability to use functions <a>catch</a>, <a>bracket</a>,
--   <a>catchDyn</a>, etc. in MonadIO other than IO itself has been a
--   fairly frequently requested feature:
--   
--   
--   <a>http://www.haskell.org/pipermail/glasgow-haskell-users/2003-September/005660.html</a>
--   
--   <a>
--   http://haskell.org/pipermail/libraries/2003-February/000774.html</a>
--   
--   The reason it is not implemented is because these functions cannot be
--   defined for a general MonadIO. However, these functions can be easily
--   defined for a large and interesting subset of MonadIO. The following
--   code demonstrates that. It uses no extensions (other than those needed
--   for the Monad Transformer Library itself), patches no compilers, and
--   proposes no extensions. The generic catch has been useful in a
--   database library (Takusen), where many operations work in a monad
--   (ReaderT Session IO): IO with the environment containing the database
--   session data. Many other foreign libraries have a pattern of passing
--   around various handles, which are better hidden in a monad. Still, we
--   should be able to handle IO errors and user exceptions that arise in
--   these computations.
module Control.CaughtMonadIO
data MyException
MyException :: String -> MyException

-- | The implementation is quite trivial.
class (MonadIO m) => CaughtMonadIO m
gcatch :: (CaughtMonadIO m) => m a -> (Exception -> m a) -> m a
catchDyn :: (Typeable e, CaughtMonadIO m) => m a -> (e -> m a) -> m a
instance Typeable MyException
instance Show MyException
instance (Monoid w, CaughtMonadIO m) => CaughtMonadIO (RWST r w s m)
instance (CaughtMonadIO m) => CaughtMonadIO (StateT s m)
instance (Monoid w, CaughtMonadIO m) => CaughtMonadIO (WriterT w m)
instance (CaughtMonadIO m) => CaughtMonadIO (ReaderT r m)
instance (CaughtMonadIO m, Error e) => CaughtMonadIO (ErrorT e m)
instance CaughtMonadIO IO


-- | Obtain the Name that corresponds to a top-level (Prelude-level)
--   Haskell identifier. Given an expression such as [e| (+) |] we return
--   the expression that is the application of mkNameG_v to the correct
--   strings. That expression, when spliced in, will compute exactly the
--   same name that corresponds to the one we started with, that is, (+).
--   Note that (+) was the identifier, not the name. The result of splicing
--   reifyName can be used in splices (see the Diff.hs for examples). We
--   essentially apply the TH to itself and emulate more than one stage of
--   computation.
module Data.Symbolic.TypedCodeAux
reifyName :: Q Exp -> Q Exp


-- | Template Haskell code is untyped, which is a bummer and leads to late
--   error reporting. We make code expressions typed, at least for our
--   particular domain.
module Data.Symbolic.TypedCode

-- | The data type of a typed TH code experssion. The phantom parameter
--   <tt>a</tt> is the type.
data Code a
data Var a
type QCode a = Q (Code a)

-- | This function is useful when splicing code expressions See DiffTest.hs
--   for the examples of its use.
reflectQC :: Q (Code a) -> Q Exp
showQC :: Q (Code a) -> IO ()

-- | Typed primitive operations
op'add :: (Num a) => Code (a -> a -> a)
op'sub :: (Num a) => Code (a -> a -> a)
op'mul :: (Num a) => Code (a -> a -> a)
op'div :: (Fractional a) => Code (a -> a -> a)
op'negate :: (Num a) => Code (a -> a)
op'recip :: (Fractional a) => Code (a -> a)
op'sin :: (Floating a) => Code (a -> a)
op'cos :: (Floating a) => Code (a -> a)
op'pi :: (Floating a) => Code a

-- | Code expression combinators
appC :: Code (a -> b) -> Code a -> Code b

-- | Lifting from primitive datatypes to Code
integerC :: (Num a) => Integer -> Code a
rationalC :: (Fractional a) => Rational -> Code a

-- | A distinguished variable (over which we differentiate)
new'diffVar :: Q (Var a)

-- | Lift this variable to Code
var'exp :: Var a -> Code a
reflectDF :: Var a -> Code a -> QCode (a -> a)
on'varC :: Var a -> Code b -> Maybe (Either (Var a) (Var b))

-- | Intensional code analysis Alas, TH.Exp is not a GADT. So, we have to
--   do their emulation...
on'litC :: Code a -> Maybe (Code a)
on'litRationalC :: Code a -> Maybe Rational
on'1opC :: Code (a -> b) -> Code d -> Maybe (Code a)
on'2opC :: Code (a -> b -> c) -> Code d -> Maybe (Code a, Code b)
instance Eq (Code a)
instance Show (Code a)


-- | Reify the (compiled) code to its typed TH representation (or, the
--   dictionary *view*, to be precise) and reflect/compile that code. We
--   must spread the code through several modules, due to the particular
--   requirement of the Template Haskell. See DiffTest.hs for reflection of
--   the differentiated TH code back into (machine) code.
module Data.Symbolic.Diff
testf1 :: (Num a) => a

-- | We can define a function
--   
--   we can even compile it. At any point, we can reify it, into a
--   `dictionary view' The result is the TH code, which we can print, and
--   compile back to the code. We can also differentiate the TH code,
--   simplify it, partially evaluate it, etc.
--   
--   Symbolic Differentiation of the reified, typed TH code expressions The
--   derivative over the code is a type preserving operation
diffC :: (Floating a, Floating b) => Var b -> Code a -> Code a

-- | Simplification rules simplification is type-preserving obviously,
--   simplification is an `open-ended' problem: we could even recognize
--   common sub-expressions and simplify them by introducing let binding.
--   In the following however, we do trivial simplification only. One can
--   always add more simplification rules later.
simpleC :: (Floating a) => Var b -> Code a -> Code a

-- | repeat until no simplifications are made
simpleCL :: (Floating a) => Var b -> Code a -> Maybe (Code a)

-- | And that's about it. Putting it all together gives us:
diff_fn :: (Floating b) => (forall a. (Floating a) => a -> a) -> QCode (b -> b)

-- | This is a useful helper to show us the code of the function in
--   question
show_fn :: (forall a. (Floating a) => a -> a) -> IO ()
instance (Floating a) => Floating (Code a)
instance (Fractional a) => Fractional (Code a)
instance (Num a) => Num (Code a)


-- | Running the splicing tests from Diff.hs. Due to the TH requirement,
--   this code must be in a separate module.
module Data.Symbolic.DiffTest


-- | Illustration of the 2-order lambda-calculus, using Church numerals as
--   an example. The example shows limited impredicativity
--   
--   <a>http://okmij.org/ftp/Haskell/types.html#some-impredicativity</a>
module Data.Numerals
newtype N
N :: (forall a. (a -> a) -> a -> a) -> N
zero :: N
succ :: N -> N
one :: N
mul :: N -> N -> N
add :: N -> N -> N
exp :: N -> N -> N
exp2 :: N -> N -> N

-- | Simpler illustrations of impredicativity
f1 :: (forall a. a -> a) -> b -> b
foo :: (c -> c) -> notimportant
newtype W
W :: (forall a. a -> a) -> W
unW :: W -> forall a. a -> a
f2 :: W -> b -> b


-- | Haskell with only one typeclass
--   
--   <a>http://okmij.org/ftp/Haskell/Haskell1/Class1.hs</a>
--   
--   <a>http://okmij.org/ftp/Haskell/types.html#Haskell1</a>
--   
--   How to make ad hoc overloading less ad hoc while defining no type
--   classes. For clarity, we call as Haskell1 the language Haskell98 with
--   no typeclass declarations but with a single, pre-defined typeclass C
--   (which has two parameters related by a functional dependency). The
--   programmers may not declare any typeclasses; but they may add
--   instances to C and use them. We show on a series of examples that
--   despite the lack of typeclass declarations, Haskell1 can express all
--   the typeclass code of Haskell98 plus multi-parameter type classes and
--   even some (most useful?) functional dependencies.
--   
--   Haskell1 is not a new language and requires no new compilers; rather,
--   it is a subset of the current Haskell. The <tt>removal</tt> of
--   typeclass declarations is merely the matter of discipline.
module Data.Class1

-- | The one and only type class present in Haskell1
class C l t | l -> t
ac :: (C l t) => l -> t

-- | Example 1: Building overloaded numeric functions, the analogue of Num.
--   The following defines overloaded numeric functions `a la carte'. We
--   shall see how to bundle such methods into what Haskell98 calls
--   <tt>classes</tt>
data Add a
data Mul a
data FromInteger a

-- | We can now define the generic addition. We use the operation +$ to
--   avoid the confusion with Prelude.(+)
--   
--   In H98, the overloaded addition was a method. In Haskell1, it is an
--   ordinary (bounded polymorphic) function The signature looks a bit
--   ugly; we'll see how to simplify it a bit
(+$) :: (C (Add a) (a -> a -> a)) => a -> a -> a

-- | We now illustrate overloading over datatypes other than basic ones. We
--   define dual numbers (see Wikipedia)
data Dual a
Dual :: a -> a -> Dual a

-- | Here is a different, perhaps simpler, way of defining signatures of
--   overloaded functions. The constraint C is inferred and no longer has
--   to be mentioned explicitly
mul_sig :: a -> a -> a
mul_as :: a -> Mul a

-- | and the corresponding overloaded function (which in Haskell98 was a
--   method) Again, we chose a slightly different name to avoid the
--   confusion with the Prelude
frmInteger :: (C (FromInteger a) (Integer -> a)) => Integer -> a

-- | We can define generic function at will, using already defined
--   overloaded functions. For example,
data SHOW a
shw :: (C (SHOW a) (a -> String)) => a -> String

-- | Finally, we demonstrate overloading of non-functional values, such as
--   minBound and maxBound. These are not <tt>methods</tt> in the classical
--   sense.
data MinBound a
mnBound :: (C (MinBound a) a) => a

-- | We are defining a super-set of monads, so called `restricted monads'.
--   Restricted monads include all ordinary monads; in addition, we can
--   define a SET monad. See
--   <a>http://okmij.org/ftp/Haskell/types.html#restricted-datatypes</a>
data RET m :: (* -> *) a
data BIND m :: (* -> *) a b
ret :: (C (RET m a) (a -> m a)) => a -> m a
bind :: (C (BIND m a b) (m a -> (a -> m b) -> m b)) => (m a -> (a -> m b) -> m b)
instance (Show a) => Show (Dual a)
instance (C (SHOW a) (a -> String)) => C (SHOW (Maybe a)) (Maybe a -> String)
instance C (BIND (Either e) a b) (Either e a -> (a -> Either e b) -> Either e b)
instance C (RET (Either e) a) (a -> Either e a)
instance C (BIND Maybe a b) (Maybe a -> (a -> Maybe b) -> Maybe b)
instance C (RET Maybe a) (a -> Maybe a)
instance C (MinBound Bool) Bool
instance C (MinBound Int) Int
instance (C (SHOW a) (a -> String)) => C (SHOW (Dual a)) (Dual a -> String)
instance C (SHOW Float) (Float -> String)
instance C (SHOW Int) (Int -> String)
instance (C (FromInteger a) (Integer -> a)) => C (FromInteger (Dual a)) (Integer -> Dual a)
instance C (FromInteger Float) (Integer -> Float)
instance C (FromInteger Int) (Integer -> Int)
instance (C (Add a) (a -> a -> a), C (Mul a) (a -> a -> a)) => C (Mul (Dual a)) (Dual a -> Dual a -> Dual a)
instance C (Mul Float) (Float -> Float -> Float)
instance C (Mul Int) (Int -> Int -> Int)
instance (C (Add a) (a -> a -> a)) => C (Add (Dual a)) (Dual a -> Dual a -> Dual a)
instance C (Add Float) (Float -> Float -> Float)
instance C (Add Int) (Int -> Int -> Int)


-- | Haskell with only one typeclass
--   
--   <a>http://okmij.org/ftp/Haskell/Haskell1/Class2.hs</a>
--   
--   <a>http://okmij.org/ftp/Haskell/types.html#Haskell1</a>
--   
--   How to make ad hoc overloading less ad hoc while defining no type
--   classes. Haskell1' -- the extension of Haskell1 with functional
--   dependencies, and bounded-polymorphic higher-rank types
module Data.Class2

-- | Some functional dependencies: implementing Monad Error As it turns
--   out, some functional dependencies are expressible already in Haskell1.
--   The example is MonadError, which in Haskell' has the form
data ERROR a
strMsg :: (C (ERROR a) (String -> a)) => String -> a
data ThrowError m :: (* -> *) a
throwError :: (C (ThrowError m a) (e -> m a), C (RET m a) t1, C (BIND m a b) t2) => e -> m a
data CatchError m :: (* -> *) a
catchError :: (C (CatchError m a) (m a -> (e -> m a) -> m a)) => m a -> (e -> m a) -> m a
data FC1 a b c
fc1 :: (C (FC1 a b c) (a -> b -> c)) => a -> b -> c
data FC2 a b c
fc2 :: (C (FC2 a b c) (a -> b -> c)) => a -> b -> c
data FC3 a b c
fc3 :: (C (FC3 a b c) (a -> b -> c)) => a -> b -> c
data FromList e
fromList :: (C (FromList e) (Int -> [e] -> array)) => Int -> [e] -> array
data Index e
indexA :: (C (Index e) (array -> Int -> e)) => (array -> Int -> e)
data NUM a
NUM :: (a -> a -> a) -> (a -> a -> a) -> (Integer -> a) -> (a -> String) -> NUM a
nm_add :: NUM a -> a -> a -> a
nm_mul :: NUM a -> a -> a -> a
nm_fromInteger :: NUM a -> Integer -> a
nm_show :: NUM a -> a -> String
data CLS a
(+$$) :: (C (CLS (NUM a)) (NUM a)) => a -> a -> a
(*$$) :: (C (CLS (NUM a)) (NUM a)) => a -> a -> a
nshw :: (C (CLS (NUM a)) (NUM a)) => a -> String
nfromI :: (C (CLS (NUM a)) (NUM a)) => Integer -> a
data PACK
PACK :: a -> PACK
class TypeCast a b | a -> b, b -> a
typeCast :: (TypeCast a b) => a -> b
class TypeCast' t a b | t a -> b, t b -> a
typeCast' :: (TypeCast' t a b) => t -> a -> b
class TypeCast'' t a b | t a -> b, t b -> a
typeCast'' :: (TypeCast'' t a b) => t -> a -> b
instance TypeCast'' () a a
instance (TypeCast'' t a b) => TypeCast' t a b
instance (TypeCast' () a b) => TypeCast a b
instance (C (Add a) (a -> a -> a), C (Mul a) (a -> a -> a), C (FromInteger a) (Integer -> a), C (SHOW a) (a -> String)) => C (CLS (NUM a)) (NUM a)
instance (C (Index a) (ara -> Int -> a), C (Index b) (arb -> Int -> b)) => C (Index (a, b)) ((ara, arb) -> Int -> (a, b))
instance C (Index Char) (String -> Int -> Char)
instance C (Index Bool) ((Int, Integer) -> Int -> Bool)
instance (C (FromList a) (Int -> [a] -> ara), C (FromList b) (Int -> [b] -> arb)) => C (FromList (a, b)) (Int -> [(a, b)] -> (ara, arb))
instance C (FromList Char) (Int -> [Char] -> String)
instance C (FromList Bool) (Int -> [Bool] -> (Int, Integer))
instance (TypeCast (FC3 Bool b c) (FC3 Bool Char Int)) => C (FC3 Bool b c) (Bool -> Char -> Int)
instance (TypeCast c Int) => C (FC2 Bool Char c) (Bool -> Char -> Int)
instance C (FC1 Bool Char Int) (Bool -> Char -> Int)
instance C (CatchError (Either e) a) (Either e a -> (e -> Either e a) -> Either e a)
instance C (ThrowError (Either e) a) (e -> Either e a)
instance C (ERROR String) (String -> String)


-- | Haskell98
--   
--   <a>http://okmij.org/ftp/Algorithms.html#pure-cyclic-list</a>
--   
--   Pure functional, mutation-free, constant-time-access double-linked
--   lists
--   
--   Note that insertions, deletions, lookups have a worst-case complexity
--   of O(min(n,W)), where W is either 32 or 64 (depending on the
--   paltform). That means the access time is bounded by a small constant
--   (32 or 64).
--   
--   <i>Pure functional, mutation-free, efficient double-linked lists</i>
--   
--   It is always an interesting challenge to write a pure functional and
--   efficient implementation of an imperative algorithm destructively
--   operating a data structure. The functional implementation has a
--   significant benefit of equational reasoning and modularity. We can
--   comprehend the algorithm without keeping the implicit global state in
--   mind. The mutation-free, functional realization has practical
--   benefits: the ease of adding checkpointing, undo and redo. The absence
--   of mutations makes the code multi-threading-safe and helps in porting
--   to distributed or non-shared-memory parallel architectures. On the
--   other hand, an imperative implementation has the advantage of
--   optimality: mutating a component in a complex data structure is a
--   constant-time operation, at least on conventional architectures.
--   Imperative code makes sharing explicit, and so permits efficient
--   implementation of cyclic data structures.
--   
--   We show a simple example of achieving all the benefits of an
--   imperative data structure -- including sharing and the efficiency of
--   updates -- in a pure functional program. Our data structure is a
--   doubly-linked, possibly cyclic list, with the standard operations of
--   adding, deleting and updating elements; traversing the list in both
--   directions; iterating over the list, with cycle detection. The code:
--   
--    uniformly handles both cyclic and terminated lists;  does not
--   rebuild the whole list on updates;  updates the value in the current
--   node in time bound by a small constant;  does not use or mention any
--   monads;  does not use any IORef, STRef, TVars, or any other
--   destructive updates;  permits the logging, undoing and redoing of
--   updates, checkpointing;  easily generalizes to two-dimensional
--   meshes.
--   
--   The algorithm is essentially imperative, thus permitting identity
--   checking and in-place <tt>updates</tt>, but implemented purely
--   functionally. Although the code uses many local, type safe
--   <tt>heaps</tt>, there is emphatically no global heap and no global
--   state.
--   
--   Version: The current version is 1.2, Jan 7, 2009.
--   
--   References
--   
--   Haskell-Cafe discussion ``Updating doubly linked lists''. January 2009
module Data.FDList

-- | Representation of the double-linked list
type Ref = Int
data Node a
Node :: a -> Ref -> Ref -> Node a
node_val :: Node a -> a
node_left :: Node a -> Ref
node_right :: Node a -> Ref

-- | Because DList contains the <tt>pointer</tt> to the current element,
--   DList is also a Zipper
data DList a
DList :: Ref -> Ref -> IntMap (Node a) -> DList a
dl_counter :: DList a -> Ref
dl_current :: DList a -> Ref
dl_mem :: DList a -> IntMap (Node a)

-- | Operations on the DList a
empty :: DList a

-- | In a well-formed list, dl_current must point to a valid node All
--   operations below preserve well-formedness
well_formed :: DList a -> Bool
is_empty :: DList a -> Bool

-- | auxiliary function
get_curr_node :: DList a -> Node a

-- | The insert operation below makes a cyclic list The other operations
--   don't care Insert to the right of the current element, if any Return
--   the DL where the inserted node is the current one
insert_right :: a -> DList a -> DList a

-- | Delete the current element from a non-empty list We can handle both
--   cyclic and terminated lists The right node becomes the current node.
--   If the right node does not exists, the left node becomes current
delete :: DList a -> DList a
get_curr :: DList a -> a
move_right :: DList a -> Maybe (DList a)

-- | If no right, just stay inplace
move_right' :: DList a -> DList a
move_left :: DList a -> Maybe (DList a)

-- | If no left, just stay inplace
move_left' :: DList a -> DList a
fromList :: [a] -> DList a

-- | The following does not anticipate cycles (deliberately)
takeDL :: Int -> DList a -> [a]

-- | Reverse taking: we move left
takeDLrev :: Int -> DList a -> [a]

-- | Update the current node <tt>inplace</tt>
update :: a -> DList a -> DList a

-- | This one watches for a cycle and terminates when it detects one
toList :: DList a -> [a]
