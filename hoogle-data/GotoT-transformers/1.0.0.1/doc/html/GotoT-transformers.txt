-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A monad and monadic transformer providing "goto" functionality
--   
--   This module provides a monad and a monad transformer that allow the
--   user to transfer the flow of execution from an arbitrary point of a
--   monadic computation to another monadic computation.
@package GotoT-transformers
@version 1.0.0.1


-- | This module provides a monad and a monad transformer that allow the
--   user to transfer the flow of execution from an arbitrary point of a
--   monadic computation to another monadic computation.
module Control.Monad.Trans.Goto

-- | A goto monad, parameterized by the type <tt>r</tt> of the value to
--   return.
type Goto r = GotoT r Identity

-- | Execute the goto monad computation and return the resulting value.
runGoto :: Goto r r -> r

-- | A goto monad transformer parameterized by
--   
--   <ul>
--   <li><tt>r</tt> - the value that will ultimately be returned; and</li>
--   <li><tt>m</tt> - the inner monad.</li>
--   </ul>
--   
--   The <a>GotoT</a> type wraps a monadic value that contains either a
--   pure value or the next place at which the flow of execution should be
--   continued.
newtype GotoT r m a
GotoT :: m (Either (GotoT r m r) a) -> GotoT r m a
unwrapGotoT :: GotoT r m a -> m (Either (GotoT r m r) a)

-- | Execute the goto monad computation and return the resulting value.
--   
--   <a>runGotoT</a> is implemented by using a ''trampoline'' approach. It
--   looks at the monadic value and checks whether it is either a
--   <a>Left</a> containing a continuation or a <a>Right</a> containing the
--   result. As long as it sees a <a>Left</a> it executes the continuation
--   and then feeds the result back into itself. Thus the computation
--   bounces back to this function (hence the ''trampoline'') as long as
--   the user keeps calling <a>goto</a> until the final result has been
--   obtained.
runGotoT :: Monad m => GotoT r m r -> m r

-- | Transfer the flow of executation from an arbitrary point in the
--   current monadic computation to another monadic computation.
--   
--   Note that the destination computation must promise to produce the same
--   value that was promised to be returned by the origin computation.
--   Also, since control is being transferred away from the origin
--   computation, the goto function returns a monadic value that can have
--   an arbitrary type, since the monadic value will never be used by the
--   originating computation.
goto :: Monad m => GotoT r m r -> GotoT r m a
instance MonadTrans (GotoT r)
instance MonadIO m => MonadIO (GotoT r m)
instance Monad m => Monad (GotoT r m)
instance Functor m => Functor (GotoT r m)
instance Applicative m => Applicative (GotoT r m)
