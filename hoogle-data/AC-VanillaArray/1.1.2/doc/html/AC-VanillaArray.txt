-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Immutable arrays with plain integer indicies.
--   
--   This package is a thin layer over GHC's low-level array primitives. It
--   provides arrays with zero-origin integers for indicies. (These arrays
--   also lack bounds checks.) They come in two flavours: mutable or
--   immutable. (Both are boxed and lazy, however. There are no unboxed
--   arrays here.) The idea is that you can use this package as a starting
--   point for building a more useful array package, without having to
--   learn all GHC's low-level internals for yourself. Changes: * Now
--   builds with GHC 6.12.1
@package AC-VanillaArray
@version 1.1.2


-- | Two flavours of array: mutable and immutable. All are boxed, lazy, and
--   use zero-origin integers as indicies.
module Data.Array.Vanilla.Unsafe

-- | The type of immutable arrays, with elements of type <tt>x</tt>.
data IArray x

-- | The type of mutable arrays, with elements of type <tt>x</tt>. These
--   arrays live in the <tt>ST</tt> monad, but you can use <tt>stToIO</tt>
--   to convert this to <tt>IO</tt> if required.
--   
--   Two <tt>MArray</tt>s are equal as per <tt>(==)</tt> if they are both
--   the exact same array (i.e., the same block of RAM). Two seperate
--   arrays which merely hold the same data are <i>not</i> considered
--   equal. (This fact could change at any second, after all.)
data MArray s x

-- | Create a brand new <tt>MArray</tt>, of the specified size, with all
--   elements set to the value provided. If the array size is <tt>n</tt>,
--   valid indicies are from <tt>0</tt> to <tt>n-1</tt>.
marray_new :: Int -> x -> ST s (MArray s x)

-- | Read from an <tt>MArray</tt>.
--   
--   <i>Unsafe</i>: No bounds checks. Indicies below <tt>0</tt> or above
--   <tt>n-1</tt> will likely result in a program crash.
marray_read :: MArray s x -> Int -> ST s x

-- | Write to an <tt>MArray</tt>, replacing the element at the specified
--   index.
--   
--   <i>Unsafe</i>: No bounds checks. Indicies below <tt>0</tt> or above
--   <tt>n-1</tt> will likely result in a program crash (if you're lucky),
--   or weird data corruption (if you're unlucky).
marray_write :: MArray s x -> Int -> x -> ST s ()

-- | Create a new <tt>IArray</tt> which refers to the same memory block as
--   an existing <tt>MArray</tt>.
--   
--   <i>Unsafe</i>: Mutating the <tt>MArray</tt> will cause the contents of
--   the <tt>IArray</tt> to mutate also, violating referential
--   transparency. (Avoid this by explicitly copying the data before
--   freezing.)
marray_freeze :: MArray s x -> ST s (IArray x)

-- | Create a new <tt>MArray</tt> which refers to the same memory block as
--   an existing <tt>IArray</tt>.
--   
--   <i>Unsafe</i>: Mutating the <tt>MArray</tt> will cause the contents of
--   the <tt>IArray</tt> to mutate also, violating referential
--   transparency. (Avoid this by explicitly copying the data after thawing
--   and before mutating it.)
iarray_thaw :: IArray x -> ST s (MArray s x)

-- | Read from an <tt>IArray</tt>. (Since <tt>IArrays</tt> are immutable,
--   this is a pure operation.)
--   
--   <i>Unsafe</i>: No bounds checks. Indicies below <tt>0</tt> or above
--   <tt>n-1</tt> will likely result in a program crash.
iarray_read :: IArray x -> Int -> x
instance Eq (MArray s x)
