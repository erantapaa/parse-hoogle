-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Simplified Pascal language to SSVM compiler
--   
--   This package provides a compiler for simplified variant of Pascal
--   language. That language includes conditional statements, for loops,
--   procedures and functions. But it does not support complex data types
--   (only integer, string and boolean are supported currently). This
--   compiler outputs bytecode which may be run by SSVM (see
--   simple-stacked-vm package).
@package simple-pascal
@version 0.1

module Language.Pascal.Types

-- | Type for symbol identifiers
type Id = String

-- | Attach annotation to node
data Annotate node ann
Annotate :: node -> ann -> Annotate node ann
content :: Annotate node ann -> node
annotation :: Annotate node ann -> ann

-- | Position of node in the source code
data SrcPos
SrcPos :: Int -> Int -> SrcPos
srcLine :: SrcPos -> Int
srcColumn :: SrcPos -> Int

-- | Node type info
data TypeAnn
TypeAnn :: SrcPos -> Type -> Map Id Symbol -> TypeAnn
srcPos :: TypeAnn -> SrcPos
typeOf :: TypeAnn -> Type
localSymbols :: TypeAnn -> Map Id Symbol

-- | Recursive annotated type
type :~ node ann = Annotate (node ann) ann

-- | Attach type info to node
withType :: Annotate a SrcPos -> Type -> Annotate a TypeAnn
setType :: Annotate Symbol a -> Type -> Annotate Symbol a

-- | Change annotation of annotated node
annotate :: ann -> Annotate node old -> Annotate node ann

-- | Program
data Program a
Program :: [(Id, Expression :~ a)] -> Map Id Type -> [Annotate Symbol a] -> [Function :~ a] -> [Statement :~ a] -> Program a

-- | constants
progConsts :: Program a -> [(Id, Expression :~ a)]

-- | user defined types
progTypes :: Program a -> Map Id Type

-- | global variables
progVariables :: Program a -> [Annotate Symbol a]

-- | functions
progFunctions :: Program a -> [Function :~ a]

-- | program body statements
progBody :: Program a -> [Statement :~ a]

-- | Function (or procedure)
data Function a
Function :: String -> [Annotate Symbol a] -> Type -> [Annotate Symbol a] -> [Statement :~ a] -> Function a

-- | function name
fnName :: Function a -> String

-- | formal arguments
fnFormalArgs :: Function a -> [Annotate Symbol a]

-- | return type (if TVoid then this is procedure)
fnResultType :: Function a -> Type

-- | local variables
fnVars :: Function a -> [Annotate Symbol a]

-- | function body statements
fnBody :: Function a -> [Statement :~ a]

-- | Symbol table
type SymbolTable = [Map Id Symbol]

-- | A symbol
data Symbol
Symbol :: Id -> Type -> Int -> Int -> Symbol
symbolName :: Symbol -> Id
symbolType :: Symbol -> Type

-- | Source line where symbol was defined
symbolDefLine :: Symbol -> Int

-- | Source column
symbolDefCol :: Symbol -> Int
showSymbol :: Symbol -> String
symbolNameC :: Annotate Symbol ann -> Id
symbolTypeC :: Annotate Symbol ann -> Type
typeOfA :: Annotate node TypeAnn -> Type

-- | Make symbol from it's name and type
(#) :: Id -> Type -> Symbol

-- | Supported data types
data Type
TInteger :: Type
TString :: Type
TBool :: Type
TVoid :: Type

-- | user defined type
TUser :: Id -> Type

-- | any value (dynamic typing)
TAny :: Type

-- | array of some type
TArray :: Integer -> Type -> Type

-- | record
TRecord :: [(Id, Type)] -> Type

-- | record field: field index and type
TField :: Int -> Type -> Type

-- | formal arguments types and return type
TFunction :: [Type] -> Type -> Type

-- | Assignment LHS value: variable or array item
data LValue a
LVariable :: Id -> LValue a
LArray :: Id -> (Expression :~ a) -> LValue a
LField :: Id -> Id -> LValue a

-- | Program statements
data Statement a

-- | lvalue := expression;
Assign :: (LValue :~ a) -> (Expression :~ a) -> Statement a

-- | procedureName(arguments);
Procedure :: Id -> [Expression :~ a] -> Statement a

-- | return expression;
Return :: (Expression :~ a) -> Statement a

-- | break (for loop)
Break :: Statement a

-- | contnune (for loop)
Continue :: Statement a

-- | exit (procedure or program)
Exit :: Statement a

-- | if expression then ... else ...
IfThenElse :: (Expression :~ a) -> [Statement :~ a] -> [Statement :~ a] -> Statement a

-- | for i := start to end do ...
For :: Id -> (Expression :~ a) -> (Expression :~ a) -> [Statement :~ a] -> Statement a

-- | Literal values
data Lit
LInteger :: Integer -> Lit
LString :: String -> Lit
LBool :: Bool -> Lit

-- | Expressions
data Expression a

-- | named variable value
Variable :: Id -> Expression a

-- | array item
ArrayItem :: Id -> (Expression :~ a) -> Expression a

-- | record field
RecordField :: Id -> Id -> Expression a

-- | literal value
Literal :: Lit -> Expression a

-- | functionName(arguments)
Call :: Id -> [Expression :~ a] -> Expression a

-- | binary operation (x+y etc)
Op :: BinOp -> (Expression :~ a) -> (Expression :~ a) -> Expression a

-- | Supported binary operations
data BinOp
Add :: BinOp
Sub :: BinOp
Mul :: BinOp
Div :: BinOp
Mod :: BinOp
Pow :: BinOp
IsGT :: BinOp
IsLT :: BinOp
IsEQ :: BinOp
IsNE :: BinOp

-- | Compiler error
data TError
TError :: Int -> Int -> Context -> String -> TError
errLine :: TError -> Int
errColumn :: TError -> Int
errContext :: TError -> Context
errMessage :: TError -> String

-- | Compiler context (where we are?)
data Context

-- | unknown context (== internal error)
Unknown :: Context

-- | Outside program body or functions
Outside :: Context

-- | In the program body
ProgramBody :: Context

-- | In the for loop (started on nth instruction, with named counter)
ForLoop :: Id -> Int -> Context

-- | In the named function (returning named type)
InFunction :: Id -> Type -> Context

-- | Context ID, for labels and variable names generation
contextId :: Context -> String

-- | Type checker state
data CheckState
CheckState :: Map Id Type -> [(Id, Expression :~ TypeAnn)] -> SymbolTable -> [Context] -> Int -> Int -> CheckState
userTypes :: CheckState -> Map Id Type
userConsts :: CheckState -> [(Id, Expression :~ TypeAnn)]
symbolTable :: CheckState -> SymbolTable
contexts :: CheckState -> [Context]
ckLine :: CheckState -> Int
ckColumn :: CheckState -> Int

-- | Code generator state
data CodeGenState

-- | already generated code
CGState :: [(Id, Lit)] -> [Id] -> [Context] -> Bool -> Code -> CodeGenState
constants :: CodeGenState -> [(Id, Lit)]

-- | declared variables (not used currently)
variables :: CodeGenState -> [Id]

-- | current contexts stack
currentContext :: CodeGenState -> [Context]

-- | quote (word declaration) mode
quoteMode :: CodeGenState -> Bool
generated :: CodeGenState -> Code

-- | Starting code generator state
emptyGState :: CodeGenState
newtype Generate a
Generate :: ErrorT TError (State CodeGenState) a -> Generate a
runGenerate :: Generate a -> ErrorT TError (State CodeGenState) a
newtype Check a
Check :: ErrorT TError (State CheckState) a -> Check a
runCheck :: Check a -> ErrorT TError (State CheckState) a
class Monad m => Checker m
enterContext :: Checker m => Context -> m ()
dropContext :: Checker m => m ()
failCheck :: Checker m => String -> m a
inContext :: Checker m => Context -> m a -> m a
instance (Eq node, Eq ann) => Eq (Annotate node ann)
instance Eq SrcPos
instance Eq Type
instance Eq Symbol
instance Eq TypeAnn
instance Show TypeAnn
instance Eq Lit
instance Eq BinOp
instance Eq a => Eq (Expression a)
instance Eq a => Eq (LValue a)
instance Eq a => Eq (Statement a)
instance Eq a => Eq (Function a)
instance Show (Function a)
instance Eq a => Eq (Program a)
instance Show (Program a)
instance Eq Context
instance Eq TError
instance Eq CheckState
instance Show CheckState
instance Eq CodeGenState
instance Show CodeGenState
instance Monad Generate
instance MonadState CodeGenState Generate
instance MonadError TError Generate
instance Monad Check
instance MonadError TError Check
instance MonadState CheckState Check
instance Show Context
instance Error TError
instance Show TError
instance Show BinOp
instance Show (Expression a)
instance Show Lit
instance Show (Statement a)
instance Show (LValue a)
instance Show Type
instance Show Symbol
instance Show SrcPos
instance Show node => Show (Annotate node ann)

module Language.Pascal.Parser
parseSource :: FilePath -> IO (Program :~ SrcPos)
pProgram :: Parser (Program :~ SrcPos)

module Language.Pascal.Builtin

-- | Generate instruction
i :: Instruction -> Generate ()

-- | Generate PUSH instruction
push :: StackType a => a -> Generate ()

-- | List of builtin functions
builtinFunctions :: [(Id, Type, Generate ())]

-- | If named symbol is builtin, return it's definition
lookupBuiltin :: Id -> Maybe (Generate ())

module Language.Pascal.TypeCheck
checkTypes :: Program :~ SrcPos -> Program :~ TypeAnn
checkSource :: FilePath -> IO (Program :~ TypeAnn)

-- | Symbol table of builtin symbols
builtinSymbols :: Map Id Symbol
instance Typed Expression
instance Typed Function
instance Typed Statement
instance Typed LValue
instance Typed Program
instance Checker Check

module Language.Pascal.CodeGen

-- | Run code generator
runCodeGen :: Generate () -> Code
class CodeGen a
generate :: CodeGen a => a -> Generate ()
instance [overlap ok] CodeGen (Function TypeAnn)
instance [overlap ok] CodeGen (Program TypeAnn)
instance [overlap ok] CodeGen (Statement TypeAnn)
instance [overlap ok] CodeGen (LValue :~ TypeAnn)
instance [overlap ok] CodeGen (Expression TypeAnn)
instance [overlap ok] CodeGen (Expression :~ TypeAnn)
instance [overlap ok] CodeGen a => CodeGen [a]
instance [overlap ok] CodeGen (a TypeAnn) => CodeGen (a :~ TypeAnn)
instance [overlap ok] Checker Generate
