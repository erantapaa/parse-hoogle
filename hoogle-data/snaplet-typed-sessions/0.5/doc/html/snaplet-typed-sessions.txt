-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Typed session snaplets and continuation-based
programming for the Snap web framework
--   
--   This package provides two Snaplets implementing typed sessions in the
--   Snap web framework, as either memory-backed arbitrary types, or as
--   client-side cookie-backed serializable types. Unlike the standard
--   session snaplet, sessions can be of an arbitrary type appropriate to
--   the application. Client-side session data is encrypted for security,
--   and sessions have a configurable timeout (optional for the client-side
--   back end).
--   
--   In addition, a library is provided for a continuation-based
--   programming model called Snap Dialogues. Dialogues allow natural
--   specification of stateful interactions with the client that span
--   multiple requests. Because the session type is not serializable, this
--   requires the memory-backed session implementation.
@package snaplet-typed-sessions
@version 0.5


-- | This module provides the generic interface to the various typed
--   session implementations, including both server-side and client-side
--   typed sessions.
module Snap.Snaplet.TypedSession

-- | The generic interface to typed session implementations. Both the
--   client-side and server-side implementations of sessions implement the
--   common interface specified here.
class HasTypedSession v t | v -> t
getSession :: HasTypedSession v t => Handler b v t
setSession :: HasTypedSession v t => t -> Handler b v ()
clearSession :: HasTypedSession v t => Handler b v ()
touchSession :: HasTypedSession v t => Handler b v ()

-- | A convenience function for gaining access to the session. The session
--   is touched and then passed to the nested <a>Handler</a>.
withSession :: HasTypedSession v t => (t -> Handler b v a) -> Handler b v a

-- | Gets a named value from a session that happens to be a <a>Map</a>.
getFromSession :: (Ord k, HasTypedSession v (Map k a)) => k -> Handler b v (Maybe a)

-- | Sets a named value in a session that happens to be a <a>Map</a>.
setInSession :: (Ord k, HasTypedSession v (Map k a)) => k -> a -> Handler b v ()

-- | Deletes a named value from a session that happens to be a <a>Map</a>.
deleteFromSession :: (Ord k, HasTypedSession v (Map k a)) => k -> Handler b v ()


-- | This is the server-side memory-backed implementation of typed
--   sessions. It has the advantage of being able to store arbitrary data
--   structures including functions and other non-serializable data. As a
--   result, though, it is limited to a single server-side process since
--   it's not possible to migrate arbitrary data between nodes. Load
--   balancing with this snaplet requires <a>sticky sessions</a> or a
--   similar technique to ensure that a given client always reaches the
--   same server-side node.
module Snap.Snaplet.TypedSession.Memory

-- | A typed session manager that stores session data by session key in a
--   server-side map.
data MemorySessionManager t

-- | Initializer for the memory-backed typed session snaplet.
initMemorySessions :: FilePath -> ByteString -> Int -> IO t -> SnapletInit b (MemorySessionManager t)
instance HasTypedSession (MemorySessionManager t) t


-- | This is the client-side cookie-backed implementation of typed
--   sessions. Because all data is stored on the client, this session
--   back-end is easier to use in load balanced settings, and session
--   timeouts are optional. All session data is encrypted so that it cannot
--   be read by the client itself. However, it has the disadvantage of only
--   being able to store serializable data types.
module Snap.Snaplet.TypedSession.Client

-- | The typed session manager that stores session data directly in
--   encrypted client-side cookies.
data ClientSessionManager t

-- | Initializer for the cookie-backed typed session snaplet.
initClientSessions :: Serialize t => FilePath -> ByteString -> Maybe Int -> IO t -> SnapletInit b (ClientSessionManager t)
instance Serialize t => HasTypedSession (ClientSessionManager t) t


-- | This module provides an easy to use continuation-backed programming
--   model for interactive web applications, called Snap Dialogues. A
--   dialogue is a procedural description of an interaction with the user,
--   which generally spans across many requests. Dialogues are specified in
--   a monadic embedded domain-specific language.
module Snap.Dialogues

-- | A <a>DlgManager</a> is user to keep track of ongoing dialogues with a
--   given user. One of them should be stored in the user's session. The
--   manager is parameterized on the base and value types for the
--   underlying request handling monad.
data DlgManager b v

-- | Creates a new <a>DlgManager</a> with the given timeout in seconds for
--   abandoned dialogues.
makeDlgManager :: Int -> IO (DlgManager b v)

-- | This type class identifies the location of the <a>DlgManager</a> in
--   the session object. In order to use dialogues, your session type must
--   be an instance of <a>HasDlgManager</a>.
class HasDlgManager b v a | a -> b v
getDlgManager :: HasDlgManager b v a => a -> DlgManager b v

-- | A value of a <a>Dlg</a> type represents a (possibly partial) dialogue
--   between the user and the application, producing a result of type
--   <tt>a</tt>. Dialogues can be composed using the monadic interface to
--   describe complex interactions.
data Dlg m a

-- | A value of <a>Page</a> type represents a way of rendering a page,
--   given the request URI for continuing the dialogue in the future.
--   Typically you will build pages using some kind of templating system
--   such as Heist.
type Page m = ByteString -> m ()

-- | Converts the combination of rendering and parsing a page into a step
--   of a <a>Dlg</a>.
showPage :: Monad m => Page m -> m a -> Dlg m a

-- | The <a>dialogue</a> function builds a <a>Handler</a> that handles a
--   given dialogue. The URLs of the dialog are of the form
--   <a>.../dlg-55555</a>, where <a>dlg</a> is the prefix (passed as a
--   parameter) and 55555 is the (numeric) dialogue ID. Requests to
--   <a>.../dlg</a> create a new dialogue.
--   
--   In general, this can be combined in normal ways with other routing
--   constructs, so long as request URIs of the above forms reach this
--   handler. When pages are served as part of a dialog, their relative
--   paths are passed on to later handlers, so images, stylesheets, etc.
--   can be served using <tt>serveDirectory</tt> just as you normally
--   would.
dialogue :: (HasTypedSession v t, HasDlgManager b v t) => ByteString -> Dlg (Handler b v) () -> Handler b v ()
instance MonadIO m => MonadIO (Dlg m)
instance MonadTrans Dlg
instance Monad m => Monad (Dlg m)
