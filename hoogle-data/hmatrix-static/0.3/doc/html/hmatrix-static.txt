-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | hmatrix with vector and matrix sizes encoded in types
--   
--   A thin, lightweight wrapper over hmatrix to support static checking of
--   matrix and vector sizes (for instance, addition of different-sized
--   vectors will be disallowed at compile-time).
--   
--   Objects whose sizes are not statically known are given the special
--   size <a>Unknown</a>, which allows a syntactically cheap way to step
--   down to the statically unchecked system of hmatrix. This is cheap in
--   comparison to representing unknown sizes with exisential types, which
--   forces pervasive continuation passing style.
--   
--   WARNING: when using the QuasiQuoting in this package, be aware of
--   infix expressions. See the note in <a>Data.Packed.Static.Syntax</a>
--   for details.
@package hmatrix-static
@version 0.3


-- | Shape-based functionality, common for matrices and vectors
module Data.Packed.Static.Shapes

-- | Uninhabited type. Represents unknown lengths. Instances of
--   <a>ShapedContainer</a> use <a>Unknown</a> for the <a>UnknownShape</a>
--   type.
data Unknown
class ShapedContainer a where { type family Unwrapped a :: * -> *; type family UnknownShape a; }
unWrap :: (ShapedContainer a) => a s t -> Unwrapped a t
wrapU :: (ShapedContainer a) => Unwrapped a t -> a (UnknownShape a) t
unsafeReshape :: (ShapedContainer a) => a s t -> a s' t

-- | For type hints.
--   
--   <pre>
--   &gt; constant (5::Double) <a>atShape</a> d4
--    [$vec| 5.0, 5.0, 5.0, 5.0 |] :: Vector D4 Double
--   </pre>
--   
--   Implementation:
--   
--   <tt>atShape = const</tt>.
atShape :: a s t -> s -> a s t

-- | For type hints.
--   
--   <pre>
--   &gt; constant (5::Double) <a>atShape</a> shapeOf [$vec|1|]
--    [$vec| 5.0 |]
--   </pre>
--   
--   Implementation:
--   
--   <pre>
--   shapeOf _ = undefined
--   </pre>
shapeOf :: a s t -> s

-- | Changes the static shape to the UnknownShape. Dynamic representation
--   is unchanged.
forgetShapeU :: (ShapedContainer a) => a s t -> a (UnknownShape a) t

-- | <tt>unsafeWrap = unsafeReshape . wrapU</tt>.
unsafeWrap :: (ShapedContainer a) => Unwrapped a t -> a s t
instance (ShapedContainer a, Normed (Unwrapped a e)) => Normed (a n e)
instance (ShapedContainer a, Show (a n e), Floating (Unwrapped a e)) => Floating (a n e)
instance (ShapedContainer a, Show (a n e), Fractional (Unwrapped a e)) => Fractional (a n e)
instance (ShapedContainer a, Show (a n e), Num (Unwrapped a e)) => Num (a n e)
instance (ShapedContainer a, Eq (Unwrapped a t)) => Eq (a s t)
instance (ShapedContainer a, Linear (Unwrapped a) e) => Linear (a n) e
instance (ShapedContainer a, Container (Unwrapped a) e) => Container (a n) e


-- | Useful imports from other packages. In particular: imports from TFP,
--   Foreign.Storable, and HMatrix.
module Data.Packed.Static.Imports


-- | Manipulation of Matrix and Vector in the ST monad.
module Data.Packed.Static.ST
newtype STVector n s t
STVector :: STVector s t -> STVector n s t
unSTVector :: STVector n s t -> STVector s t
newVector :: (Element t, PositiveT n) => t -> ST s (STVector n s t)
thawVector :: (Storable t) => Vector n t -> ST s (STVector n s t)
freezeVector :: (Storable t) => STVector n s1 t -> ST s2 (Vector n t)
runSTVector :: (Storable t) => (forall s. ST s (STVector n s t)) -> Vector n t
readVector :: (Storable t) => STVector n s t -> Int -> ST s t
writeVector :: (Storable t) => STVector n s t -> Int -> t -> ST s ()
modifyVector :: (Storable t) => STVector n s t -> Int -> (t -> t) -> ST s ()
liftSTVector :: (Storable t) => (Vector n t -> c) -> STVector n s1 t -> ST s2 c

-- | A matrix with <tt>m</tt> rows, <tt>n</tt> columns.
newtype STMatrix mn s t
STMatrix :: STMatrix s t -> STMatrix mn s t
unSTMatrix :: STMatrix mn s t -> STMatrix s t
newMatrix :: (Element t, PositiveT m, PositiveT n) => t -> ST s (STMatrix (m, n) s t)
thawMatrix :: (Storable t) => Matrix (m, n) t -> ST s (STMatrix (m, n) s t)
freezeMatrix :: (Storable t) => STMatrix (m, n) s1 t -> ST s2 (Matrix (m, n) t)
runSTMatrix :: (Storable t) => (forall s. ST s (STMatrix (m, n) s t)) -> Matrix (m, n) t
readMatrix :: (Storable t) => STMatrix (m, n) s t -> Int -> Int -> ST s t
writeMatrix :: (Storable t) => STMatrix (m, n) s t -> Int -> Int -> t -> ST s ()
modifyMatrix :: (Storable t) => STMatrix (m, n) s t -> Int -> Int -> (t -> t) -> ST s ()
liftSTMatrix :: (Storable t) => (Matrix (m, n) t -> a) -> STMatrix (m, n) s1 t -> ST s2 a
unsafeReadVector :: (Storable t) => STVector n s t -> Int -> ST s t
unsafeWriteVector :: (Storable t) => STVector n s t -> Int -> t -> ST s ()
unsafeThawVector :: (Storable t) => Vector n t -> ST s (STVector n s t)
unsafeFreezeVector :: (Storable t) => STVector n s1 t -> ST s2 (Vector n t)
unsafeReadMatrix :: (Storable t) => STMatrix (m, n) s t -> Int -> Int -> ST s t
unsafeWriteMatrix :: (Storable t) => STMatrix (m, n) s t -> Int -> Int -> t -> ST s ()
unsafeThawMatrix :: (Storable t) => Matrix (m, n) t -> ST s (STMatrix (m, n) s t)
unsafeFreeMatrix :: (Storable t) => STMatrix (m, n) s1 t -> ST s2 (Matrix (m, n) t)


-- | Statically-dimensioned 2D matrices.
module Data.Packed.Static.Matrix

-- | A matrix with <tt>m</tt> rows, <tt>n</tt> columns.
data Matrix mn t
refineMat :: Matrix (m, n) t -> (forall m' n'. (PositiveT m', PositiveT n') => Matrix (m', n') t -> a) -> a
forgetRowsU :: Matrix (m, n) t -> Matrix (Unknown, n) t
forgetColsU :: Matrix (m, n) t -> Matrix (m, Unknown) t

-- | Fixes a matrix's static row length. Essentially a mechanism for
--   partial type signatures: you can specify the row length without
--   specifying the rest of matrix's type.
--   
--   <pre>
--   &gt;ident `atRows` d5
--   [$mat| 1.0, 0.0, 0.0, 0.0, 0.0;
--          0.0, 1.0, 0.0, 0.0, 0.0;
--          0.0, 0.0, 1.0, 0.0, 0.0;
--          0.0, 0.0, 0.0, 1.0, 0.0;
--          0.0, 0.0, 0.0, 0.0, 1.0 |]
--   </pre>
atRows :: Matrix (m, n) t -> m -> Matrix (m, n) t

-- | Fixes a matrix's static column length.
--   
--   <pre>
--   &gt; ident `atCols` d4
--   [$mat| 1.0, 0.0, 0.0, 0.0;
--          0.0, 1.0, 0.0, 0.0;
--          0.0, 0.0, 1.0, 0.0;
--          0.0, 0.0, 0.0, 1.0 |]
--   </pre>
atCols :: Matrix (m, n) t -> n -> Matrix (m, n) t
withShape :: (PositiveT m, PositiveT n) => (Int -> Int -> Matrix (m, n) t) -> Matrix (m, n) t
withRows :: (PositiveT m) => (Int -> Matrix (m, n) t) -> Matrix (m, n) t
withCols :: (PositiveT n) => (Int -> Matrix (m, n) t) -> Matrix (m, n) t
withSquare :: (PositiveT n) => (Int -> Matrix (n, n) t) -> Matrix (n, n) t

-- | Constructs a matrix using the function from row/column index. The
--   first of the pair is the row; the second is the column. Indexing is
--   0-based.
--   
--   <pre>
--   &gt; buildMatrix (fromIntegral . uncurry (^)) `atShape` (d3,d4)
--   [$mat| 1.0, 0.0, 0.0, 0.0;
--          1.0, 1.0, 1.0, 1.0;
--          1.0, 2.0, 4.0, 8.0 |]
--   </pre>
buildMatrix :: (PositiveT m, PositiveT n, Element a) => ((Int, Int) -> a) -> Matrix (m, n) a

-- | Constructs a matrix from a list. The size in the matrix's type and the
--   list's length must agree or else a runtime error will be raised.
--   
--   <pre>
--   &gt; (d2 &gt;&lt; d3)[1,2,3,4,5,6]
--   [$mat| 1.0, 2.0, 3.0;
--          4.0, 5.0, 6.0 |]
--   </pre>
(><) :: (PositiveT m, PositiveT n, Element t) => m -> n -> [t] -> Matrix (m, n) t

-- | Constructs a matrix from a list. The size in the matrix's type and the
--   list's length must agree or else a runtime error will be raised.
--   
--   <pre>
--   &gt; matFromList [1,2,3,4,5,6] `atShape` (d2,d3)
--   [$mat| 1.0, 2.0, 3.0;
--          4.0, 5.0, 6.0 |]
--   </pre>
matFromList :: (Element t, PositiveT m, PositiveT n) => [t] -> Matrix (m, n) t

-- | Constructs a matrix from a list of lists of elements. Each sublist
--   must be of equal size or a runtime error will be raised.
--   
--   <pre>
--   &gt; fromListsU [[1,2,3],[4,5,6]]
--   [$mat| 1.0, 2.0, 3.0;
--          4.0, 5.0, 6.0 |]
--   </pre>
fromListsU :: (Element t) => [[t]] -> Matrix (Unknown, Unknown) t

-- | Converts a matrix to a list of its rows, each as a list.
--   
--   <pre>
--   &gt; toLists [$mat|1,2,3;4,5,6|]
--   [[1.0,2.0,3.0],[4.0,5.0,6.0]]
--   </pre>
toLists :: (Element t) => Matrix (m, n) t -> [[t]]

-- | Constructs a matrix from a list of rows.
--   
--   <pre>
--   &gt; fromRowsU [[$vec|1,2,3|],[$vec|4,5,6|]]
--   [$mat| 1.0, 2.0, 3.0;
--          4.0, 5.0, 6.0 |]
--   </pre>
fromRowsU :: (Element t) => [Vector n t] -> Matrix (Unknown, n) t

-- | Converts a matrix to a list of its rows.
--   
--   <pre>
--   &gt; toRows [$mat|1,2,3;4,5,6|]
--   [[$vec| 1.0, 2.0, 3.0 |],[$vec| 4.0, 5.0, 6.0 |]]
--   </pre>
toRows :: (Element t) => Matrix (m, n) t -> [Vector n t]

-- | Constructs a matrix from a list of columns.
--   
--   <pre>
--   &gt; fromColumnsU [[$vec|1,2,3|],[$vec|4,5,6|]]
--   [$mat| 1.0, 4.0;
--          2.0, 5.0;
--          3.0, 6.0 |]
--   </pre>
fromColumnsU :: (Element t) => [Vector n t] -> Matrix (n, Unknown) t

-- | Converts a matrix to a list of its columns.
--   
--   <pre>
--   &gt; toColumns [$mat|1,2,3;4,5,6|]
--   [[$vec| 1.0, 4.0 |],[$vec| 2.0, 5.0 |],[$vec| 3.0, 6.0 |]]
--   </pre>
toColumns :: (Element t) => Matrix (m, n) t -> [Vector m t]

-- | Constructs a matrix from blocks.
--   
--   <pre>
--   &gt; fromBlocksU [[[$matU|1,2,3;4,5,6|],  [$matU|7,8,9;10,11,12|]],
--                  [[$matU|11,12,13;14,15,16|],[$matU|21,22,23;24,25,26|]]]
--   [$mat|  1.0,  2.0,  3.0,  7.0,  8.0,  9.0;
--           4.0,  5.0,  6.0, 10.0, 11.0, 12.0;
--          11.0, 12.0, 13.0, 21.0, 22.0, 23.0;
--          14.0, 15.0, 16.0, 24.0, 25.0, 26.0 |]
--   </pre>
fromBlocksU :: (Element t) => [[Matrix (Unknown, Unknown) t]] -> Matrix (Unknown, Unknown) t

-- | Interprets a vector as a 1-row matrix.
--   
--   <pre>
--   &gt; asRow [$vec|1,2,3|]
--   [$mat| 1.0, 2.0, 3.0 |]
--   </pre>
asRow :: (Element a) => Vector n a -> Matrix (D1, n) a

-- | Interprets a vector as a 1-column matrix.
--   
--   <pre>
--   &gt; asColumn [$vec|1,2,3|]
--   [$mat| 1.0;
--          2.0;
--          3.0 |]
--   </pre>
asColumn :: (Element a) => Vector n a -> Matrix (n, D1) a

-- | Returns the number of rows of the matrix.
--   
--   <pre>
--   &gt; rows [$mat|1::Double,2,3;4,5,6|]
--   2
--   </pre>
rows :: Matrix (m, n) t -> Int

-- | Returns the number of columns of the matrix.
--   
--   <pre>
--   &gt; cols [$mat|1::Double,2,3;4,5,6|]
--   3
--   </pre>
cols :: Matrix (m, n) t -> Int

-- | Matrix transpose.
--   
--   <pre>
--   &gt; trans [$mat|1,2,3;4,5,6|]
--   [$mat| 1.0, 4.0;
--          2.0, 5.0;
--          3.0, 6.0 |]
--   </pre>
trans :: Matrix (m, n) t -> Matrix (n, m) t

-- | Reshapes a vector into a matrix, with the specified number of columns.
--   If the vector's length is not a multiple of the required columns, a
--   runtime error is raised.
--   
--   <pre>
--   &gt; reshapeU 3 [$vecU|1,2,3,4,5,6|]
--   [$mat| 1.0, 2.0, 3.0;
--          4.0, 5.0, 6.0 |]
--   </pre>
reshapeU :: (Element t) => Int -> Vector n t -> Matrix (Unknown, Unknown) t

-- | Flattens a matrix into a vector.
--   
--   <pre>
--   &gt; flatten [$mat|1,2,3;4,5,6|]
--   [$vec| 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 |]
--   </pre>
flatten :: (Element t) => Matrix (m, n) t -> Vector (m :*: n) t

-- | Indexes a matrix.
--   
--   <pre>
--   &gt; [$mat|1,2,3;4,5,6|] @@&gt; (1,2)
--   6.0
--   </pre>
(@@>) :: (Storable t) => Matrix (m, n) t -> (Int, Int) -> t

-- | <a>replicate</a> for matrices.
--   
--   <pre>
--   &gt; repmatU [$mat|1;2|] 2 3
--   [$mat| 1.0, 1.0, 1.0;
--          2.0, 2.0, 2.0;
--          1.0, 1.0, 1.0;
--          2.0, 2.0, 2.0 |]
--   </pre>
repmatU :: (Element t) => Matrix (m, n) t -> Int -> Int -> Matrix (Unknown, Unknown) t

-- | Vertically flips a matrix.
--   
--   <pre>
--   &gt; flipud [$mat|1,2,3;4,5,6|]
--   [$mat| 4.0, 5.0, 6.0;
--          1.0, 2.0, 3.0 |]
--   </pre>
flipud :: (Element t) => Matrix (m, n) t -> Matrix (m, n) t

-- | Horizonatlly flips a matrix.
--   
--   <pre>
--   &gt; fliprl [$mat|1,2,3;4,5,6|]
--   [$mat| 3.0, 2.0, 1.0;
--          6.0, 5.0, 4.0 |]
--   </pre>
fliprl :: (Element t) => Matrix (m, n) t -> Matrix (m, n) t

-- | Extracts a submatrix.
--   
--   <pre>
--   &gt; subMatrixU (0,1) (2,2) [$mat|1,2,3,4;5,6,7,8;9,10,11,12|]
--   [$mat| 2.0, 3.0;
--          6.0, 7.0 |]
--   </pre>
subMatrixU :: (Element a) => (Int, Int) -> (Int, Int) -> Matrix (m, n) a -> Matrix (Unknown, Unknown) a

-- | Takes rows from the top of the matrix until the required size is
--   reached.
--   
--   <pre>
--   &gt; takeRows [$mat|1,2;3,4;5,6|] `atRows` d2
--   [$mat| 1.0, 2.0;
--          3.0, 4.0 |]
--   </pre>
takeRows :: (PositiveT m', Element t, (m' :<=: m) ~ True) => Matrix (m, n) t -> Matrix (m', n) t

-- | Takes rows from the bottom of the matrix until the required size is
--   reached.
--   
--   <pre>
--   &gt; dropRows [$mat|1,2;3,4;5,6|] `atRows` d2
--   [$mat| 3.0, 4.0;
--          5.0, 6.0 |]
--   </pre>
dropRows :: (PositiveT m', Element t, (m' :<=: m) ~ True) => Matrix (m, n) t -> Matrix (m', n) t

-- | Takes columns from the left of the matrix until the required size is
--   reached.
--   
--   <pre>
--   &gt; takeColumns [$mat|1,2,3;4,5,6|] `atCols` d2
--   [$mat| 1.0, 2.0;
--          4.0, 5.0 |]
--   </pre>
takeColumns :: (PositiveT n', Element t, (n' :<=: n) ~ True) => Matrix (m, n) t -> Matrix (m, n') t

-- | Takes columns from the right of the matrix until the required size is
--   reached.
--   
--   <pre>
--   &gt; dropColumns [$mat|1,2,3;4,5,6|] `atCols` d2
--   [$mat| 2.0, 3.0;
--          5.0, 6.0 |]
--   </pre>
dropColumns :: (PositiveT n', Element t, (n' :<=: n) ~ True) => Matrix (m, n) t -> Matrix (m, n') t

-- | Extracts the given rows from a matrix.
--   
--   <pre>
--   &gt; extractRowsU [1,0] [$mat|1,2;3,4;5,6|]
--   [$mat| 3.0, 4.0;
--          1.0, 2.0 |]
--   </pre>
extractRowsU :: (Element t) => [Int] -> Matrix (m, n) t -> Matrix (Unknown, n) t

-- | Constructs the identity matrix of any given size.
--   
--   <pre>
--   &gt; ident `atRows` d3
--   [$mat| 1.0, 0.0, 0.0;
--          0.0, 1.0, 0.0;
--          0.0, 0.0, 1.0 |]
--   </pre>
ident :: (Element t, PositiveT n) => Matrix (n, n) t

-- | Constructs a square matrix with the given vector as its diagonal.
--   
--   <pre>
--   &gt; diag (linspace (1,3)) `atRows` d3
--   [$mat| 1.0, 0.0, 0.0;
--          0.0, 2.0, 0.0;
--          0.0, 0.0, 3.0 |]
--   </pre>
diag :: (Element a) => Vector n a -> Matrix (n, n) a

-- | Constructs a rectangular matrix with the given vector as its diagonal.
--   
--   <pre>
--   &gt; diagRect (linspace (1,3)) `atShape` (d3,d4)
--   [$mat| 1.0, 0.0, 0.0, 0.0;
--          0.0, 2.0, 0.0, 0.0;
--          0.0, 0.0, 3.0, 0.0 |]
--   
--   &gt; diagRect (linspace (1,3)) `atShape` (d4,d3)
--   [$mat| 1.0, 0.0, 0.0;
--          0.0, 2.0, 0.0;
--          0.0, 0.0, 3.0;
--          0.0, 0.0, 0.0 |]
--   </pre>
diagRect :: (Element a, PositiveT m, PositiveT n) => Vector (Min m n) a -> Matrix (m, n) a

-- | Takes the diagonal from a matrix.
--   
--   <pre>
--   &gt; takeDiag [$mat|1,2,3;4,5,6|]
--   [$vec| 1.0, 5.0 |]
--   </pre>
takeDiag :: (Element t) => Matrix (m, n) t -> Vector (Min m n) t

-- | Operations on matrices viewed as operations on the vector of their
--   elements
--   
--   <pre>
--   &gt; liftMatrix (+constant 2) [$mat|1,2,3;4,5,6|]
--   [$mat| 3.0, 4.0, 5.0;
--          6.0, 7.0, 8.0 |]
--   </pre>
liftMatrix :: (Element a, Element b) => (Vector (m :*: n) a -> Vector (m :*: n) b) -> Matrix (m, n) a -> Matrix (m, n) b

-- | See hmatrix's <a>format</a>.
format :: (Element t) => String -> (t -> String) -> Matrix (m, n) t -> String

-- | See hmatrix's <a>readMatrix</a>.
readMatrix :: String -> Matrix (Unknown, Unknown) Double

-- | See hmatrix's <a>fromFile</a>.
fromFile :: FilePath -> (Int, Int) -> IO (Matrix (Unknown, Unknown) Double)

-- | See hmatrix's <a>fromArray2D</a>.
fromArray2D :: (Element t) => Array (Int, Int) t -> Matrix (Unknown, Unknown) t
instance (Element e, Show e) => Show (Matrix (m, n) e)
instance ShapedContainer Matrix


-- | Statically-dimensioned 1D vectors.
module Data.Packed.Static.Vector

-- | A vector with elements of type <tt>t</tt> and length <tt>n</tt>. The
--   type <tt>n</tt> encodes the vector's length, and will usually either
--   be Unknown or will satisfy PositiveT.
--   
--   Operations which return vectors of length Unknown will return vectors
--   whose lengths are determined at runtime. All operations which mention
--   Unknown lengths will have names ending in an uppercase U, for example
--   fromListU, subVectorU.
--   
--   The use of Unknown facilitates manipulation of dynamically-lengthed
--   vectors without using continuations for each operation, since most
--   operations work equally well for lengthed as well as unlengthed
--   vectors. When vectors of Unknown length are used, runtime length
--   mismatches may arise, and the system is as safe as hmatrix.
--   
--   When the length of every vector is known, if the code typechecks, then
--   there will be no runtime vector length mismatches. Equivalently, there
--   will be no runtime vector length mismatches if:
--   
--   <ul>
--   <li>no unsafe functions are used; and</li>
--   <li>no functions mentioning Unknown are used, i.e. no functions with
--   suffix U are used.</li>
--   </ul>
data Vector n t

-- | "Reifies" a Vector's length in types. Useful when vectors of length
--   <a>Unknown</a> need to be used for a statically-sized operations. For
--   instance, if <tt>v :: Vector Unknown Double</tt>, then we can write
--   
--   <pre>
--   refineVec v (v -&gt; forgetSize $ v + constant 5)
--   </pre>
--   
--   to add a constant vector of 5s with the appropriate size.
refineVec :: Vector m t -> (forall n. (PositiveT n) => Vector n t -> a) -> a

-- | Sets an arbitrary-length vector to a specific value.
--   
--   <pre>
--   &gt; constant 1 <a>atDim</a> 5
--   [$vec| 1.0, 1.0, 1.0, 1.0, 1.0 |]
--   </pre>
atDim :: (forall n. (PositiveT n) => Vector n t) -> Int -> Vector Unknown t

-- | For type hints.
--   
--   <pre>
--   &gt; constant (5::Double) <a>atShape</a> d4
--    [$vec| 5.0, 5.0, 5.0, 5.0 |] :: Vector D4 Double
--   </pre>
--   
--   Implementation:
--   
--   <tt>atShape = const</tt>.
atShape :: a s t -> s -> a s t

-- | Builds a vector given a function from indices. Indexing is 0-based.
--   
--   <pre>
--   &gt; buildVector fromIntegral `atShape` d5
--   [$vec| 0.0, 1.0, 2.0, 3.0, 4.0 |]
--   </pre>
buildVector :: (PositiveT n, Element a) => (Int -> a) -> Vector n a

-- | Constructs a vector from all the elements of a list.
--   
--   <pre>
--   &gt; fromListU [1,2,3,4,5]
--   [$vec| 1.0, 2.0, 3.0, 4.0, 5.0 |]
--   </pre>
fromListU :: (Storable a) => [a] -> Vector Unknown a

-- | Converts to a list of elements.
--   
--   <pre>
--   &gt; toList [$vec|1,2,3|]
--   [1.0,2.0,3.0]
--   </pre>
toList :: (Storable a) => Vector n a -> [a]

-- | Vector's length.
--   
--   <pre>
--   &gt; dim [$vec|1::Double,2,3|]
--   3
--   </pre>
dim :: Vector n t -> Int

-- | Indexes a vector.
--   
--   <pre>
--   &gt; [$vec|1,2,3|] @&gt; 1
--   2.0
--   </pre>
(@>) :: (Storable t) => Vector n t -> Int -> t

-- | Extracts a subvector.
--   
--   <pre>
--   &gt; subVectorU 2 3 [$vec|1,2,3,4,5|]
--   [$vec| 3.0, 4.0, 5.0 |]
--   </pre>
subVectorU :: (Storable t) => Int -> Int -> Vector n t -> Vector Unknown t

-- | Joins each vector in the list.
--   
--   <pre>
--   &gt; joinU [[$vecU|1,2,3|], [$vecU|4,5|]]
--   [$vec| 1.0, 2.0, 3.0, 4.0, 5.0 |]
--   </pre>
joinU :: (Storable t) => [Vector Unknown t] -> Vector Unknown t

-- | Creates a constant vector of any length. The length is determined by
--   the type.
--   
--   <pre>
--   &gt; [$vec|1,2,3|] + constant 2
--   [$vec| 3.0, 4.0, 5.0 |]
--   </pre>
constant :: (Element t, PositiveT n) => t -> Vector n t

-- | Creates a vector of arbitrary length whose components range linearly
--   from a to b. The vector's length is determined by its type.
--   
--   <pre>
--   &gt; linspace (1,5) <a>atShape</a> d4
--   [$vec| 1.0, 2.333333333333333, 3.6666666666666665, 5.0 |]
--   </pre>
linspace :: (PositiveT n) => (Double, Double) -> Vector n Double

-- | Gives the vector's minimum entry.
--   
--   <pre>
--   &gt; vectorMin [$vec|1,2,3|]
--   1.0
--   </pre>
vectorMin :: Vector n Double -> Double

-- | Gives the vector's maximum entry.
--   
--   <pre>
--   &gt; vectorMax [$vec|1,2,3|]
--   3.0
--   </pre>
vectorMax :: Vector n Double -> Double

-- | Gives the index of a vector's minimum entry. <tt>&gt; vectorMinIndex
--   [$vec|1,2,3|] 0</tt>
vectorMinIndex :: Vector n Double -> Int

-- | Gives the index of a vector's maximum entry.
--   
--   <pre>
--   &gt; vectorMaxIndex [$vec|1,2,3|]
--   2
--   </pre>
vectorMaxIndex :: Vector n Double -> Int

-- | <a>map</a> for vectors.
--   
--   <pre>
--   &gt; (*2) <a>liftVector</a> [$vec|1,2,3|]
--   [$vec| 2.0, 4.0, 6.0 |]
--   </pre>
liftVector :: (Storable a, Storable b) => (a -> b) -> Vector n a -> Vector n b

-- | <a>zipWith</a> for vectors.
--   
--   <pre>
--   &gt; liftVector2 (+) [$vec|1,2,3|] (constant 3)
--   [$vec| 4.0, 5.0, 6.0 |]
--   </pre>
liftVector2 :: (Storable a, Storable b, Storable c) => (a -> b -> c) -> Vector n a -> Vector n b -> Vector n c
instance (Storable e, Show e) => Show (Vector n e)
instance ShapedContainer Vector


-- | QuasiQuoting for matrices and vectors.
--   
--   BIG WARNING: the expression quasiquoters for matrices and vectors are
--   broken for infix expressions. All operators will be assumed to be left
--   infix with infix level 9. To avoid unexpected parses, fully
--   parenthesise all infix expressions.
module Data.Packed.Static.Syntax

-- | The matrix quasiquoter for expressions and patterns.
--   
--   <ul>
--   <li>Elements on the same row are separated by commas; rows themselves
--   are separated by semicolons. All whitespace is optional</li>
--   <li>The expression quasiquoter allows arbitrary Haskell expressions as
--   its elements; the pattern quasiquoter requires that each element is a
--   variable.</li>
--   <li>Using the quasiquoter for patterns requires that you use the
--   <a>viewMat</a> view pattern first (this is a workaround since Template
--   Haskell doesn't yet support view patterns).</li>
--   </ul>
--   
--   For example,
--   
--   <pre>
--   example1 :: (Element t) =&gt; Matrix (D2,D3) t -&gt; Matrix (D2,D2) t
--   example1 (viewMat -&gt; [$mat|a, b, c;
--                              d, e, f|]) = [$mat|a+b,   b+c;
--                                                 sin c, f  |]
--   </pre>
mat :: QuasiQuoter

-- | Quasiquoter for matrices of Unknown size. We should just use
--   <tt>[$matU|&lt;text&gt;|]</tt> as shorthand for
--   <tt><a>forgetShapeU</a> [$mat|&lt;text&gt;|]</tt>.
--   
--   No pattern quasiquoter exists, and I currently have no plans to
--   introduce one.
matU :: QuasiQuoter

-- | The vector quasiquoter for expressions and patterns. This is very
--   similar to the <a>mat</a> quasiquoter.
--   
--   <ul>
--   <li>Elements are separated by commas; whitespace is ignored.</li>
--   <li>The expression quasiquoter allows arbitrary Haskell expressions
--   for each element; the pattern quasiquoter requires that each element
--   is a variable pattern.</li>
--   <li>The pattern quasiquoter must be preceeded by a the <a>viewVec</a>
--   view pattern.</li>
--   </ul>
--   
--   For example,
--   
--   <pre>
--   example2 :: (Storable t, Num t) =&gt; Vector D2 t -&gt; Vector D3 t
--   example2 (viewVec -&gt; [$vec|a, b|]) = [$vec|a*b, 5, 7|]
--   </pre>
vec :: QuasiQuoter

-- | Quasiquoter for vectors of unknown lengths. Like <a>matU</a>,
--   <tt>[$vecU|&lt;text&gt;|]</tt> is just shorthand for
--   <tt><a>forgetShapeU</a> [$vec|&lt;text&gt;|]</tt>.
vecU :: QuasiQuoter

-- | Required for the <a>mat</a> pattern quasiquoter. See <a>mat</a>.
data MatView n t

-- | Required for the <a>mat</a> pattern quasiquoter. See <a>mat</a>.
viewMat :: (Element t) => Matrix (m, n) t -> MatView (m, n) t

-- | Required for the <a>vec</a> quasiquoter. See <a>vec</a>.
data VecView n t

-- | Required for the <a>vec</a> quasiquoter. See <a>vec</a>.
viewVec :: (Storable t) => Vector n t -> VecView n t


-- | Conversions to other forms.
module Data.Packed.Static.Convert

-- | Constructs a vector from an hmatrix (dynamically-lengthed) vector.
fromHVectorU :: Vector t -> Vector Unknown t

-- | Gives the underlying hmatrix representation.
toHVector :: Vector n t -> Vector t
arrayFromVector :: (Storable t) => Vector n t -> Array Int t
vectorFromArray :: (Storable t) => Array Int t -> Vector Unknown t
mArrayFromVector :: (MArray b t (ST s), Storable t) => Vector n t -> ST s (b Int t)
vectorFromMArray :: (Storable t) => Array Int t -> Vector n t
vectorToStorableArray :: (Storable t) => Vector n t -> IO (StorableArray Int t)
storableArrayToVector :: (Storable t) => StorableArray Int t -> IO (Vector Unknown t)

-- | Constructs a vector from an hmatrix (dynamically-lengthed) vector.
fromHMatrixU :: Matrix t -> Matrix (Unknown, Unknown) t

-- | Gives the underlying hmatrix representation.
toHMatrix :: Matrix (m, n) t -> Matrix t
arrayFromMatrix :: Matrix mn Double -> UArray (Int, Int) Double
matrixFromArray :: UArray (Int, Int) Double -> Matrix mn Double
mArrayFromMatrix :: (MArray b Double m) => Matrix mn Double -> m (b (Int, Int) Double)
matrixFromMArray :: (MArray a Double (ST s)) => a (Int, Int) Double -> ST s (Matrix mn Double)


-- | Statically-dimensioned vectors and matrices.
module Data.Packed.Static


-- | Common operations.
module Numeric.LinearAlgebra.Static.Algorithms
matT :: Matrix s t -> a
vecT :: Vector s t -> a
doubleT :: a s Double -> x
complexT :: a s (Complex Double) -> x
class Mul a b where { type family MulResult a b :: * -> *; }
(<>) :: (Mul a b, Field t) => a t -> b t -> MulResult a b t

-- | Dot product
(<.>) :: (Field t) => Vector n t -> Vector n t -> t

-- | Overloaded matrix-matrix, matrix-vector, vector-matrix, or
--   vector-vector vertical concatenation. The instances have type
--   equalities to improve the quality of type inference.
(<->) :: (JoinableV a b, Element t) => a t -> b t -> Matrix (JoinShapeV a b) t

-- | Overloaded matrix-matrix, matrix-vector, vector-matrix, or
--   vector-vector horizontal concatenation. The instances have type
--   equalities to improve the quality of type inference.
(<|>) :: (JoinableH a b, Element t) => a t -> b t -> Matrix (JoinShapeH a b) t

-- | Least squares solution of a linear equation.
(<\>) :: (Field t) => Matrix (m, n) t -> Vector m t -> Vector n t
linearSolve :: (Field t) => Matrix (m, m) t -> Matrix (m, n) t -> Matrix (m, n) t
inv :: (Field t) => Matrix (m, m) t -> Matrix (m, m) t
pinv :: (Field t) => Matrix (m, n) t -> Matrix (n, m) t
det :: (Field t) => Matrix (m, m) t -> t
rank :: (Field t) => Matrix (m, n) t -> Int
rcond :: (Field t) => Matrix (m, n) t -> Double
eig :: (Field t) => Matrix (m, m) t -> (Vector m (Complex Double), Matrix (m, m) (Complex Double))
eigSH :: (Field t) => Matrix (m, m) t -> (Vector m Double, Matrix (m, m) t)
svd :: (Field t) => Matrix (m, n) t -> (Matrix (m, m) t, Vector (Min m n) Double, Matrix (n, n) t)
fullSVD :: (Field t) => Matrix mn t -> (Matrix (m, m) t, Matrix (m, n) Double, Matrix (n, n) t)
economySVDU :: (Field t) => Matrix (m, n) t -> (Matrix (m, Unknown) t, Vector Unknown Double, Matrix (n, Unknown) t)
qr :: (Field t) => Matrix (m, n) t -> (Matrix (m, m) t, Matrix (m, n) t)
chol :: (Field t) => Matrix (m, m) t -> Matrix (m, m) t
hess :: (Field t) => Matrix (m, m) t -> (Matrix (m, m) t, Matrix (m, m) t)
schur :: (Field t) => Matrix (m, m) t -> (Matrix (m, m) t, Matrix (m, m) t)
lu :: (Field t) => Matrix (m, n) t -> (Matrix (m, Min m n) t, Matrix (Min m n, n) t, Matrix (m, m) t, t)
luPacked :: (Field t) => Matrix (m, n) t -> (Matrix (m, n) t, [Int])
luSolve :: (Field t) => (Matrix (m, n) t, [Int]) -> Matrix (m, p) t -> Matrix (n, p) t
expm :: (Field t) => Matrix (m, m) t -> Matrix (m, m) t
sqrtm :: (Field t) => Matrix (m, m) t -> Matrix (m, m) t
matFunc :: (Field t) => (Complex Double -> Complex Double) -> Matrix (m, m) t -> Matrix (m, m) (Complex Double)
nullspacePrec :: (Field t) => Double -> Matrix (m, n) t -> [Vector n t]
nullVector :: (Field t) => Matrix (m, n) t -> Vector n t
ctrans :: (Field t) => Matrix (m, n) t -> Matrix (n, m) t
eps :: Double
i :: Complex Double
outer :: (Field t) => Vector m t -> Vector n t -> Matrix (m, n) t
kronecker :: (Field t) => Matrix (m, n) t -> Matrix (p, q) t -> Matrix (m :*: p, n :*: q) t
instance JoinableH (Vector m) (Vector m)
instance JoinableH (Vector m) (Matrix (m, n))
instance JoinableH (Matrix (m, n)) (Vector m)
instance JoinableH (Matrix (m, n)) (Matrix (m, p))
instance JoinableV (Vector n) (Vector n)
instance JoinableV (Vector n) (Matrix (m, n))
instance JoinableV (Matrix (m, n)) (Vector n)
instance JoinableV (Matrix (m, n)) (Matrix (p, n))
instance (m ~ m') => Mul (Vector m) (Matrix (m', n))
instance (n ~ n') => Mul (Matrix (m, n)) (Vector n')
instance (n ~ n') => Mul (Matrix (m, n)) (Matrix (n', p))


-- | Main imported interface for this package.
module Numeric.LinearAlgebra.Static
