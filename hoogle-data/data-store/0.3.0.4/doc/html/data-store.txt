-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Type safe, in-memory dictionary with multidimensional keys.
--   
--   Type safe, in-memory dictionary with multidimensional keys. Similar to
--   ixset, higgsset, tables. But offers: type safe interface,
--   auto-increment dimensions, specifying the relationships between the
--   key dimension and the elements (one-one, one-many, many-one,
--   many-many), performance.
@package data-store
@version 0.3.0.4

module Data.Store.Internal.Type
moduleName :: String

-- | This is type-level tag for tagging dimensions of key and the index of
--   a store. You can think of <tt><a>M</a></tt> as an abbreviation for
--   <a>many</a>.
--   
--   <ul>
--   <li>When <tt><a>Key</a></tt> dimension is tagged with
--   <tt><a>M</a></tt>, it means that a single element can be indexed under
--   multiple key dimension values. Example: <tt>Content</tt> (element) has
--   many tags.</li>
--   <li>When <tt><a>Index</a></tt> dimension is tagged with
--   <tt><a>M</a></tt>, it means that a multiple elements can be indexed
--   under a single key dimension values. Example: One rating can be shared
--   by many <tt>Content</tt>s (elements).</li>
--   </ul>
--   
--   See also:
--   
--   <ul>
--   <li><a>O</a></li>
--   <li><a>Key</a></li>
--   <li><a>Store</a></li>
--   </ul>
data M

-- | This is type-level tag for tagging dimensions of key and the index of
--   a store. You can think of <tt><a>O</a></tt> as an abbreviation for
--   <a>one</a>.
--   
--   <ul>
--   <li>When <tt><a>Key</a></tt> dimension is tagged with
--   <tt><a>O</a></tt>, it means that a single element is indexed under
--   exactly one key dimension value. Example: <tt>Content</tt> (element)
--   has exactly one title.</li>
--   <li>When <tt><a>Index</a></tt> dimension is tagged with
--   <tt><a>O</a></tt>, it means that at most one element can be indexed
--   under one key dimension value. Example: One <tt>ContentID</tt>
--   corresponds to at most one <tt>Content</tt> (element).</li>
--   </ul>
--   
--   See also:
--   
--   <ul>
--   <li><a>M</a></li>
--   <li><a>Key</a></li>
--   <li><a>Store</a></li>
--   </ul>
data O

-- | Type-level zero.
data Z
Z :: Z

-- | Type-level successor of a number.
data S n
S :: n -> S n
type N0 = Z
type N1 = S N0
type N2 = S N1
type N3 = S N2
type N4 = S N3
type N5 = S N4
type N6 = S N5
type N7 = S N6
type N8 = S N7
type N9 = S N8
type N10 = S N9
n0 :: N0
n1 :: N1
n2 :: N2
n3 :: N3
n4 :: N4
n5 :: N5
n6 :: N6
n7 :: N7
n8 :: N8
n9 :: N9
n10 :: N10

-- | The pupose of the <tt><a>RawKey</a></tt> type family is to derive a
--   type of a "raw key" that is easier to pattern match against than
--   <tt><a>Key</a></tt>.
--   
--   Example:
--   
--   <pre>
--   RawKey (O :. O :. O :. M :. O) (ContentID :. String :. String :. String :. Double) ~ (ContentID :. String :. String :. [String] :. Double)
--   </pre>
class (Ord k, Enum k, Bounded k) => Auto k

-- | The store data type has four type arguments that define what and how
--   things are stored.
--   
--   The <tt>krs</tt> (key relation specification) and <tt>irs</tt> (index
--   relation specification) define the relations between the dimensions of
--   the key and the elements. To that end, we use <tt><a>O</a></tt> and
--   <tt><a>M</a></tt> type-level tags and
--   <tt>'Data.Store.Type.Internal.(:.)'</tt> data type to create tuple of
--   these tags (to describe all the dimensions).
--   
--   The possible relations are as follows:
--   
--   <ul>
--   <li>One-one: Every intem is indexed under exactly one key dimension
--   value. One key dimension value corresponds to at most one
--   elements.</li>
--   <li>One-many: Every element is indexed under exactly one key dimension
--   value. One key dimension value can correspond to many elements.</li>
--   <li>Many-one: Every element can be indexed under multiple (zero or
--   more) key dimension values. One key dimension value corresponds to at
--   most one elements.</li>
--   <li>Many-many: Every element cab be indexed under multiple (zero or
--   more) key dimension value. One key dimension value can correspond to
--   many elements.</li>
--   </ul>
--   
--   The <tt>ts</tt> (type specification) defines the type of the key's
--   dimensions and finally <tt>v</tt> is the type of the elements stored.
--   
--   In our example with <tt>Content</tt>, we have five dimensions: ID,
--   name, body, tags and rating. We would like our store to have these
--   properties:
--   
--   <ul>
--   <li><tt>Content</tt> has one ID, only one content can have a given
--   ID.</li>
--   <li><tt>Content</tt> has one name, only one content can have a given
--   name.</li>
--   <li><tt>Content</tt> has one body, many contents can have the same
--   content.</li>
--   <li><tt>Content</tt> has many tags, many contents can have tte same
--   tag.</li>
--   <li><tt>Content</tt> has one rating, many contents can have the same
--   rating.</li>
--   </ul>
--   
--   So in our case, we define:
--   
--   <pre>
--   type ContentStoreKRS = O         :. O      :. O      :. M      :. O
--   type ContentStoreIRS = O         :. O      :. M      :. M      :. M
--   type ContentStoreTS  = ContentID :. String :. String :. String :. Double
--   type ContentStore = Store ContentStoreKRS ContentStoreIRS ContentStoreTS Content
--   </pre>
--   
--   See also:
--   
--   <ul>
--   <li><a>O</a></li>
--   <li><a>M</a></li>
--   <li>'Data.Store.Internal.Type.(:.)'</li>
--   <li><a>Key</a></li>
--   </ul>
data Store tag krs irs ts v
Store :: !(IntMap (IKey krs ts, v)) -> !(Index irs ts) -> {-# UNPACK #-} !Int -> Store tag krs irs ts v
storeV :: Store tag krs irs ts v -> !(IntMap (IKey krs ts, v))
storeI :: Store tag krs irs ts v -> !(Index irs ts)
storeNID :: Store tag krs irs ts v -> {-# UNPACK #-} !Int
data GenericKey dim rs ts
KN :: !(dim r t) -> !(GenericKey dim rt tt) -> GenericKey dim (r :. rt) (t :. tt)
K1 :: !(dim r t) -> GenericKey dim r t
type Key = GenericKey KeyDimension
type IKey = GenericKey IKeyDimension
data Index rs ts
IN :: !(IndexDimension r t) -> !(Index rt tt) -> Index (r :. rt) (t :. tt)
I1 :: !(IndexDimension r t) -> Index r t
data KeyDimension r t
KeyDimensionO :: t -> KeyDimension O t
KeyDimensionM :: [t] -> KeyDimension M t
KeyDimensionA :: KeyDimension O t
data IKeyDimension r t
IKeyDimensionO :: t -> IKeyDimension O t
IKeyDimensionM :: [t] -> IKeyDimension M t
data IndexDimension r t
IndexDimensionO :: !(Map t Int) -> IndexDimension O t
IndexDimensionM :: !(Map t IntSet) -> IndexDimension M t
class GetDimension n a
getDimension :: GetDimension n a => n -> a -> RawDimensionType n a
data TT
data FF
class Empty a
empty :: Empty a => a
class EmptyProxy flag a
emptyProxy :: EmptyProxy flag a => flag -> a

-- | Data type for creating tuples, it is used to:
--   
--   <ul>
--   <li>Create type-level tuples of relation tags for relation
--   specification of the key and the index of the store.</li>
--   </ul>
--   
--   <pre>
--   M :. O :. O :. M
--   </pre>
--   
--   <ul>
--   <li>Create type-level tuples of types for type specification of the
--   key and index of the store.</li>
--   </ul>
--   
--   <pre>
--   Int :. Double :. String :. String
--   </pre>
--   
--   <ul>
--   <li>Create value-level tuples to return raw key (with resolved
--   auto-increment dimensions).</li>
--   </ul>
--   
--   <pre>
--   [1, 2, 3] :. 3.5 :. "Foo" :. ["Bar1", "Bar2"]
--   </pre>
data (:.) h t
(:.) :: h -> t -> :. h t
instance Typeable5 Store
instance Typeable2 IKeyDimension
instance Typeable2 KeyDimension
instance (NFData a, NFData b) => NFData (a :. b)
instance (NFData t, NFData (IKey rt tt)) => NFData (IKey (r :. rt) (t :. tt))
instance NFData t => NFData (IKey M t)
instance NFData t => NFData (IKey O t)
instance NFData t => NFData (IKeyDimension r t)
instance (NFData t, NFData (Index rt tt)) => NFData (Index (r :. rt) (t :. tt))
instance NFData t => NFData (Index M t)
instance NFData t => NFData (Index O t)
instance NFData t => NFData (IndexDimension r t)
instance (NFData e, NFData (IKey krs ts), NFData (Index irs ts)) => NFData (Store tag krs irs ts e)
instance Empty (Index irs ts) => Empty (Store tag krs irs ts e)
instance (Ord t, Empty (Index rt tt)) => Empty (Index (M :. rt) (t :. tt))
instance (Ord t, Empty (Index rt tt)) => Empty (Index (O :. rt) (t :. tt))
instance Ord t => Empty (Index M t)
instance Ord t => Empty (Index O t)
instance GetDimension n (Index rt tt) => GetDimension (S n) (Index (r :. rt) (t :. tt))
instance GetDimension Z (Index (r :. rt) (t :. tt))
instance GetDimension Z (Index M t)
instance GetDimension Z (Index O t)
instance Show t => Show (IndexDimension r t)
instance (Ord t, SafeCopy t) => SafeCopy (IndexDimension M t)
instance (Ord t, SafeCopy t) => SafeCopy (IndexDimension O t)
instance (Ord t, Serialize t) => Serialize (IndexDimension M t)
instance (Ord t, Serialize t) => Serialize (IndexDimension O t)
instance Show t => Show (IKeyDimension r t)
instance (Ord t, SafeCopy t) => SafeCopy (IKeyDimension M t)
instance (Ord t, SafeCopy t) => SafeCopy (IKeyDimension O t)
instance (Ord t, Serialize t) => Serialize (IKeyDimension M t)
instance (Ord t, Serialize t) => Serialize (IKeyDimension O t)
instance Eq (IKeyDimension r t)
instance Show t => Show (KeyDimension r t)
instance (Show t, Show (Index rt tt)) => Show (Index (r :. rt) (t :. tt))
instance Show t => Show (Index M t)
instance Show t => Show (Index O t)
instance Typeable2 Index
instance (Ord t, SafeCopy t, SafeCopy (Index rt tt)) => SafeCopy (Index (M :. rt) (t :. tt))
instance (Ord t, SafeCopy t, SafeCopy (Index rt tt)) => SafeCopy (Index (O :. rt) (t :. tt))
instance (Ord t, SafeCopy t) => SafeCopy (Index M t)
instance (Ord t, SafeCopy t) => SafeCopy (Index O t)
instance (Ord t, Serialize t, Serialize (Index rt tt)) => Serialize (Index (M :. rt) (t :. tt))
instance (Ord t, Serialize t, Serialize (Index rt tt)) => Serialize (Index (O :. rt) (t :. tt))
instance (Ord t, Serialize t) => Serialize (Index M t)
instance (Ord t, Serialize t) => Serialize (Index O t)
instance (Show t, Show (IKey rt tt)) => Show (IKey (r :. rt) (t :. tt))
instance Show t => Show (IKey M t)
instance Show t => Show (IKey O t)
instance (Show t, Show (Key rt tt)) => Show (Key (r :. rt) (t :. tt))
instance Show t => Show (Key M t)
instance Show t => Show (Key O t)
instance Typeable2 (GenericKey dim)
instance (SafeCopy (GenericKey dim rt tt), SafeCopy (dim r t)) => SafeCopy (GenericKey dim (r :. rt) (t :. tt))
instance SafeCopy (dim M t) => SafeCopy (GenericKey dim M t)
instance SafeCopy (dim O t) => SafeCopy (GenericKey dim O t)
instance (Serialize (GenericKey dim rt tt), Serialize (dim r t)) => Serialize (GenericKey dim (r :. rt) (t :. tt))
instance Serialize (dim M t) => Serialize (GenericKey dim M t)
instance Serialize (dim O t) => Serialize (GenericKey dim O t)
instance Eq (GenericKey IKeyDimension rs ts)
instance (Show (IKey krs ts), Show v) => Show (Store tag krs irs ts v)
instance (SafeCopy (IKey krs ts), SafeCopy (Index irs ts), SafeCopy v) => SafeCopy (Store tag krs irs ts v)
instance (Serialize (IKey krs ts), Serialize (Index irs ts), Serialize v) => Serialize (Store tag krs irs ts v)
instance (Show h, Show t) => Show (h :. t)
instance (Ord k, Enum k, Bounded k) => Auto k

module Data.Store.Internal.Function
moduleName :: String
genericSubset :: Empty (Index irs ts) => IntSet -> Store tag krs irs ts v -> Store tag krs irs ts v
genericLookup :: IntSet -> Store tag krs irs ts v -> [(RawKey krs ts, v)]
genericUpdateWithKey :: (Applicative f, Monad f) => (IKey krs ts -> Int -> Store tag krs irs ts e -> f (Store tag krs irs ts e)) -> (RawKey krs ts -> e -> Maybe (e, Maybe (Key krs ts))) -> IntSet -> Store tag krs irs ts e -> f (Store tag krs irs ts e)
mergeKeys :: Key krs ts -> IKey krs ts -> IKey krs ts
keyInternalToRaw :: IKey krs ts -> RawKey krs ts
keyFromInternal :: IKey krs ts -> Key krs ts
keyToInternal :: Index irs ts -> Key krs ts -> IKey krs ts
nextKey :: Auto t => IndexDimension r t -> t
genericInsert :: Applicative f => (IKey krs ts -> Int -> Store tag krs irs ts e -> f (Store tag krs irs ts e)) -> IKey krs ts -> e -> Store tag krs irs ts e -> f (Store tag krs irs ts e)

-- | Inserts the given element identifier into the store's index under the
--   given internal key.
--   
--   In case of collisions: returns <a>Nothing</a>.
indexInsertID :: IKey krs ts -> Int -> Store tag krs irs ts e -> Maybe (Store tag krs irs ts e)

-- | Inserts the given element identifier into the store's index under the
--   given internal key.
--   
--   In case of collisions: deletes them.
indexInsertID' :: IKey krs ts -> Int -> Store tag krs irs ts e -> Identity (Store tag krs irs ts e)

-- | UNSAFE. Inserts the given element identifier into the store's index
--   under the given internal key.
--   
--   In case of collisions: ignores them.
indexInsertID'' :: IKey krs ts -> Int -> Store tag krs irs ts e -> Identity (Store tag krs irs ts e)
findCollisions :: IKey krs ts -> Index irs ts -> [Int]

-- | Deletes EID fron an index.
indexDeleteID :: IKey krs ts -> Int -> Index irs ts -> Index irs ts

module Data.Store.Selection

-- | The expression (<tt>sDim .&lt; c</tt>) is a selection that includes
--   value <tt>x</tt> if and only if it is indexed in the <tt>sDim</tt>
--   dimension with a key <tt>k</tt> such that <tt>k &lt; c</tt>.
--   
--   Complexity of <tt><a>resolve</a></tt>: <i>O(log n + k)</i>
(.<) :: GetDimension n (Index irs ts) => (tag, n) -> DimensionType n irs ts -> Selection tag krs irs ts

-- | The expression (<tt>sDim .&lt;= c</tt>) is a selection that includes
--   value <tt>x</tt> if and only if it is indexed in the <tt>sDim</tt>
--   dimension with a key <tt>k</tt> such that <tt>k &lt;= c</tt>.
--   
--   Complexity of <tt><a>resolve</a></tt>: <i>O(log n + k)</i>
(.<=) :: GetDimension n (Index irs ts) => (tag, n) -> DimensionType n irs ts -> Selection tag krs irs ts

-- | The expression (<tt>sDim .&gt; c</tt>) is a selection that includes
--   value <tt>x</tt> if and only if it is indexed in the <tt>sDim</tt>
--   dimension with a key <tt>k</tt> such that <tt>k &gt; c</tt>.
--   
--   Complexity of <tt><a>resolve</a></tt>: <i>O(log n + k)</i>
(.>) :: GetDimension n (Index irs ts) => (tag, n) -> DimensionType n irs ts -> Selection tag krs irs ts

-- | The expression (<tt>sDim .&gt;= c</tt>) is a selection that includes
--   value <tt>x</tt> if and only if it is indexed in the <tt>sDim</tt>
--   dimension with a key <tt>k</tt> such that <tt>k &gt;= c</tt>.
--   
--   Complexity of <tt><a>resolve</a></tt>: <i>O(log n + k)</i>
(.>=) :: GetDimension n (Index irs ts) => (tag, n) -> DimensionType n irs ts -> Selection tag krs irs ts

-- | The expression (<tt>sDim ./= c</tt>) is a selection that includes
--   value <tt>x</tt> if and only if it is indexed in the <tt>sDim</tt>
--   dimension with a key <tt>k</tt> such that <tt>k /= c</tt>.
--   
--   Complexity of <tt><a>resolve</a></tt>: <i>O(n)</i>
(./=) :: GetDimension n (Index irs ts) => (tag, n) -> DimensionType n irs ts -> Selection tag krs irs ts

-- | The expression (<tt>sDim .== c</tt>) is a selection that includes
--   value <tt>x</tt> if and only if it is indexed in the <tt>sDim</tt>
--   dimension with a key <tt>k</tt> such that <tt>k == c</tt>.
--   
--   Complexity of <tt><a>resolve</a></tt>: <i>O(log n)</i>
(.==) :: GetDimension n (Index irs ts) => (tag, n) -> DimensionType n irs ts -> Selection tag krs irs ts

-- | The expression (<tt>s1 .&amp;&amp; s2</tt>) is a selection that
--   includes the intersection of the selections <tt>s1</tt> and
--   <tt>s2</tt>.
--   
--   Complexity of <tt><a>resolve</a></tt>: <i>O(c(s1) + c(s2) + s(s1) +
--   s(s2)</i>
(.&&) :: (IsSelection s1, IsSelection s2) => s1 tag krs irs ts -> s2 tag krs irs ts -> Selection tag krs irs ts

-- | The expression (<tt>s1 .|| s2</tt>) is a selection that includes the
--   union of the selections <tt>s1</tt> and <tt>s2</tt>.
--   
--   Complexity of <tt><a>resolve</a></tt>: <i>O(c(s1) + c(s2) + s(s1) +
--   s(s2)</i>
(.||) :: (IsSelection s1, IsSelection s2) => s1 tag krs irs ts -> s2 tag krs irs ts -> Selection tag krs irs ts

-- | The expression (<tt>not' sel</tt>) is a selection that includes all
--   values except those that match the selection <tt>sel</tt>.
not :: IsSelection sel => sel tag krs irs ts -> Selection tag krs irs ts

-- | Selection that matches the intersection of all the selections in the
--   list or everything if the list is empty.
all :: [Selection tag krs irs ts] -> Selection tag krs irs ts

-- | The expression (<tt><a>all1D</a> d ss</tt>) is equivalent to
--   (<tt><a>all'</a> $ map ($ d) ss</tt>).
all1D :: (tag, n) -> [(tag, n) -> Selection tag krs irs ts] -> Selection tag krs irs ts

-- | Selection that matches the union of all the selections in the list or
--   nothing if the list is empty.
any :: [Selection tag krs irs ts] -> Selection tag krs irs ts

-- | The expression (<tt><a>any1D</a> d ss</tt>) is equivalent to
--   (<tt><a>any'</a> $ map ($ d) ss</tt>).
any1D :: (tag, n) -> [(tag, n) -> Selection tag krs irs ts] -> Selection tag krs irs ts
class IsSelection sel
resolve :: IsSelection sel => sel tag krs irs ts -> Store tag krs irs ts v -> IntSet
data Selection tag krs irs ts
instance IsSelection (SelectionDimension n)
instance IsSelection Selection


-- | Dictionary with multidimensional keys and type-safe interface.
--   
--   These modules are intended to be imported qualified to avoid name
--   clashes with prelude, e.g.:
--   
--   <pre>
--   import qualified Data.Store as S
--   import           Data.Store (M, O, (.:), (.:.), (:.), (.&lt;), (.&lt;=), (.&gt;), (.&gt;=), (./=), (.==), (.&amp;&amp;), (.||))
--   </pre>
--   
--   Throughout out the documentation, the examples will be based on this
--   code:
--   
--   <pre>
--   {-# LANGUAGE TypeOperators #-}
--   
--   module Example01
--   where
--   
--   --------------------------------------------------------------------------------
--   import           Control.Applicative
--   import qualified Control.Monad.State as State
--   --------------------------------------------------------------------------------
--   import qualified Data.Store as S
--   import           Data.Store (M, O, (.:), (.:.), (:.)(..), (.&lt;), (.&lt;=), (.&gt;), (.&gt;=), (./=), (.==), (.&amp;&amp;), (.||))
--   --------------------------------------------------------------------------------
--   
--   data Content = Content
--       { contentName :: String  
--       , contentBody :: String  
--       , contentTags :: [String]
--       , contentRating :: Double
--       }
--   
--   type ContentID = Int
--   
--   -- Content has one ID, only one content can have a given ID.
--   -- Content has one name, only one content can have a given name.
--   -- Content has one body, many contents can have the same content.
--   -- Content has many tags, many contents can have the same tag.
--   -- Content has one rating, many contents can have the same rating.
--   
--   data ContentStoreTag = ContentStoreTag
--   
--   type ContentStoreTS  = ContentID :. String :. String :. String :. Double
--   type ContentStoreKRS = O         :. O      :. O      :. M      :. O
--   type ContentStoreIRS = O         :. O      :. M      :. M      :. M
--   type ContentStore = S.Store ContentStoreTag ContentStoreKRS ContentStoreIRS ContentStoreTS Content
--   type ContentStoreKey = S.Key ContentStoreKRS ContentStoreTS
--   type ContentStoreSelection = S.Selection ContentStoreTag ContentStoreKRS ContentStoreIRS ContentStoreTS
--   
--   sContentID :: (ContentStoreTag, S.N0)
--   sContentID = (ContentStoreTag, S.n0)
--   
--   sContentName :: (ContentStoreTag, S.N1)
--   sContentName = (ContentStoreTag, S.n1)
--   
--   sContentBody :: (ContentStoreTag, S.N2)
--   sContentBody = (ContentStoreTag, S.n2)
--   
--   sContentTag :: (ContentStoreTag, S.N3)
--   sContentTag = (ContentStoreTag, S.n3)
--   
--   sContentRating :: (ContentStoreTag, S.N4)
--   sContentRating = (ContentStoreTag, S.n4)
--   </pre>
--   
--   Glossary
--   
--   <ul>
--   <li>Key (type/value) -- refers either to the type or value of a key of
--   the store.</li>
--   <li>Key dimension -- refers to one dimension of a key (e.g.: article's
--   author, article's tag). Refers to the dimension as a whole, together
--   with its properties, etc.</li>
--   <li>Key dimension value -- refers to some concrete value from the
--   domain of the dimension.</li>
--   <li>Element (type/value) -- refers either to the type or value of the
--   elements (in literature, the term "value" is usually used, be here it
--   would clash far too often) of the store.</li>
--   </ul>
--   
--   The implementation is based on <a>Data.Map</a>, <a>Data.Set</a>,
--   <a>Data.IntMap</a> and <a>Data.IntSet</a>.
--   
--   The following variables and constants are used in Big-O notation:
--   
--   <ul>
--   <li><i>W</i> -- the (constant) number of bits of <a>Int</a> (32 or
--   64).</li>
--   <li><i>d</i> -- the (constant) number of dimensions of the store.</li>
--   <li><i>k</i> -- the (variable) number of key dimensions values of a
--   key (or maximum of the number of key dimension values over all keys in
--   case of for example <tt><a>updateWithKey</a></tt>).</li>
--   <li><i>s</i> -- the (variable) size of the output of the operation or
--   the (variable) number of elements affected by the operation. This is
--   often the number of key-element pairs that correspond to some
--   selection.</li>
--   <li><i>s(sel)</i> -- the (variable) number of key-element pairs that
--   correspond to a selection <i>sel</i> if <i>s</i> would otherwise be
--   ambigious.</li>
--   <li><i>c</i> -- the (variable) complexity of selection.</li>
--   <li><i>c(sel)</i> -- the (variable) complexity of resolving the
--   selection <i>sel</i> if <i>c</i> would otherwise be ambiguous.</li>
--   </ul>
module Data.Store

-- | The store data type has four type arguments that define what and how
--   things are stored.
--   
--   The <tt>krs</tt> (key relation specification) and <tt>irs</tt> (index
--   relation specification) define the relations between the dimensions of
--   the key and the elements. To that end, we use <tt><a>O</a></tt> and
--   <tt><a>M</a></tt> type-level tags and
--   <tt>'Data.Store.Type.Internal.(:.)'</tt> data type to create tuple of
--   these tags (to describe all the dimensions).
--   
--   The possible relations are as follows:
--   
--   <ul>
--   <li>One-one: Every intem is indexed under exactly one key dimension
--   value. One key dimension value corresponds to at most one
--   elements.</li>
--   <li>One-many: Every element is indexed under exactly one key dimension
--   value. One key dimension value can correspond to many elements.</li>
--   <li>Many-one: Every element can be indexed under multiple (zero or
--   more) key dimension values. One key dimension value corresponds to at
--   most one elements.</li>
--   <li>Many-many: Every element cab be indexed under multiple (zero or
--   more) key dimension value. One key dimension value can correspond to
--   many elements.</li>
--   </ul>
--   
--   The <tt>ts</tt> (type specification) defines the type of the key's
--   dimensions and finally <tt>v</tt> is the type of the elements stored.
--   
--   In our example with <tt>Content</tt>, we have five dimensions: ID,
--   name, body, tags and rating. We would like our store to have these
--   properties:
--   
--   <ul>
--   <li><tt>Content</tt> has one ID, only one content can have a given
--   ID.</li>
--   <li><tt>Content</tt> has one name, only one content can have a given
--   name.</li>
--   <li><tt>Content</tt> has one body, many contents can have the same
--   content.</li>
--   <li><tt>Content</tt> has many tags, many contents can have tte same
--   tag.</li>
--   <li><tt>Content</tt> has one rating, many contents can have the same
--   rating.</li>
--   </ul>
--   
--   So in our case, we define:
--   
--   <pre>
--   type ContentStoreKRS = O         :. O      :. O      :. M      :. O
--   type ContentStoreIRS = O         :. O      :. M      :. M      :. M
--   type ContentStoreTS  = ContentID :. String :. String :. String :. Double
--   type ContentStore = Store ContentStoreKRS ContentStoreIRS ContentStoreTS Content
--   </pre>
--   
--   See also:
--   
--   <ul>
--   <li><a>O</a></li>
--   <li><a>M</a></li>
--   <li>'Data.Store.Internal.Type.(:.)'</li>
--   <li><a>Key</a></li>
--   </ul>
data Store tag krs irs ts v
type Key = GenericKey KeyDimension
data KeyDimension r t

-- | The pupose of the <tt><a>RawKey</a></tt> type family is to derive a
--   type of a "raw key" that is easier to pattern match against than
--   <tt><a>Key</a></tt>.
--   
--   Example:
--   
--   <pre>
--   RawKey (O :. O :. O :. M :. O) (ContentID :. String :. String :. String :. Double) ~ (ContentID :. String :. String :. [String] :. Double)
--   </pre>

-- | This is type-level tag for tagging dimensions of key and the index of
--   a store. You can think of <tt><a>M</a></tt> as an abbreviation for
--   <a>many</a>.
--   
--   <ul>
--   <li>When <tt><a>Key</a></tt> dimension is tagged with
--   <tt><a>M</a></tt>, it means that a single element can be indexed under
--   multiple key dimension values. Example: <tt>Content</tt> (element) has
--   many tags.</li>
--   <li>When <tt><a>Index</a></tt> dimension is tagged with
--   <tt><a>M</a></tt>, it means that a multiple elements can be indexed
--   under a single key dimension values. Example: One rating can be shared
--   by many <tt>Content</tt>s (elements).</li>
--   </ul>
--   
--   See also:
--   
--   <ul>
--   <li><a>O</a></li>
--   <li><a>Key</a></li>
--   <li><a>Store</a></li>
--   </ul>
data M

-- | This is type-level tag for tagging dimensions of key and the index of
--   a store. You can think of <tt><a>O</a></tt> as an abbreviation for
--   <a>one</a>.
--   
--   <ul>
--   <li>When <tt><a>Key</a></tt> dimension is tagged with
--   <tt><a>O</a></tt>, it means that a single element is indexed under
--   exactly one key dimension value. Example: <tt>Content</tt> (element)
--   has exactly one title.</li>
--   <li>When <tt><a>Index</a></tt> dimension is tagged with
--   <tt><a>O</a></tt>, it means that at most one element can be indexed
--   under one key dimension value. Example: One <tt>ContentID</tt>
--   corresponds to at most one <tt>Content</tt> (element).</li>
--   </ul>
--   
--   See also:
--   
--   <ul>
--   <li><a>M</a></li>
--   <li><a>Key</a></li>
--   <li><a>Store</a></li>
--   </ul>
data O

-- | Data type for creating tuples, it is used to:
--   
--   <ul>
--   <li>Create type-level tuples of relation tags for relation
--   specification of the key and the index of the store.</li>
--   </ul>
--   
--   <pre>
--   M :. O :. O :. M
--   </pre>
--   
--   <ul>
--   <li>Create type-level tuples of types for type specification of the
--   key and index of the store.</li>
--   </ul>
--   
--   <pre>
--   Int :. Double :. String :. String
--   </pre>
--   
--   <ul>
--   <li>Create value-level tuples to return raw key (with resolved
--   auto-increment dimensions).</li>
--   </ul>
--   
--   <pre>
--   [1, 2, 3] :. 3.5 :. "Foo" :. ["Bar1", "Bar2"]
--   </pre>
data (:.) h t
(:.) :: h -> t -> :. h t
class (Ord k, Enum k, Bounded k) => Auto k
empty :: Empty a => a

-- | The expression (<tt><a>singleton</a> k v</tt>) is store that contains
--   only the <tt>(k, v)</tt> as a key-element pair.
singleton :: Empty (Index irs ts) => Key krs ts -> v -> Store tag krs irs ts v

-- | The expression (<tt><a>insert</a> k e old</tt>) is either
--   <tt>Nothing</tt> if inserting the <tt>(k, e)</tt> key-element pair
--   would cause a collision or (<tt>Just (rk, new)</tt>), where
--   <tt>rk</tt> is the raw key of <tt>k</tt> and <tt>new</tt> is store
--   containing the same key-element pairs as <tt>old</tt> plus <tt>(k,
--   e)</tt>.
--   
--   Examples:
--   
--   <pre>
--   &gt;&gt;&gt; let content = Content "name" "body" ["t1", "t2"] 0.5
--   
--   &gt;&gt;&gt; insert (contentKey content) content store
--   &gt; Just (1 :. "name" :. "body" :. ["t1", "t2"] :. 0.5, &lt;updated_store&gt;)
--   </pre>
--   
--   Complexity: <i>O(min(n, W) + k * (log n + min(n, W)))</i>
--   
--   See also:
--   
--   <ul>
--   <li><a>insert'</a></li>
--   <li><a>Key</a></li>
--   <li><a>RawKey</a></li>
--   </ul>
insert :: Key krs ts -> v -> Store tag krs irs ts v -> Maybe (RawKey krs ts, Store tag krs irs ts v)

-- | The expression (<tt><a>insert'</a> k v old</tt>) is <tt>(rk,
--   new)</tt>, where <tt>rk</tt> is the raw key of <tt>k</tt> and
--   <tt>new</tt> is a store that contains the same key-element pairs as
--   <tt>old</tt> plus <tt>(k, e)</tt>. Any key-value pairs from
--   <tt>old</tt> colliding with <tt>(k, e)</tt> are not included in
--   <tt>new</tt>.
--   
--   Complexity: <i>O(min(n, W) + k * (log n + min(n, W)))</i>
--   
--   See also:
--   
--   <ul>
--   <li><a>insert</a></li>
--   <li><a>Key</a></li>
--   <li><a>RawKey</a></li>
--   </ul>
insert' :: Key krs ts -> e -> Store tag krs irs ts e -> (RawKey krs ts, Store tag krs irs ts e)

-- | UNSAFE! This function can corrupt the store.
--   
--   The expression (<tt><a>unsafeInsert</a> k v old</tt>) is <tt>(rk,
--   new)</tt>, where <tt>rk</tt> is the raw key of <tt>k</tt> and
--   <tt>new</tt> is a store that contains the same key-element pairs as
--   <tt>old</tt> plus <tt>(k, e)</tt>. Any key-value pairs from
--   <tt>old</tt> colliding with <tt>(k, e)</tt> will cause UNDEFINED
--   BEHAVIOUR.
--   
--   See also:
--   
--   <ul>
--   <li><a>insert</a></li>
--   <li><a>insert'</a></li>
--   <li><a>Key</a></li>
--   <li><a>RawKey</a></li>
--   </ul>
unsafeInsert :: Key krs ts -> e -> Store tag krs irs ts e -> (RawKey krs ts, Store tag krs irs ts e)

-- | The expression (<tt><a>updateWithKey</a> tr sel old</tt>) is (<tt>Just
--   new</tt>) where <tt>new</tt> is a store containing the same
--   key-element pairs as <tt>old</tt> except for any key-element pairs
--   <tt>(k, e)</tt> that match the selection <tt>sel</tt>, those are
--   updated as follows:
--   
--   <ul>
--   <li>If <tt>(tr k e)</tt> is <tt>Nothing</tt> the pair is not included
--   in <tt>new</tt>.</li>
--   <li>If <tt>(tr k e)</tt> is (<tt>Just (e', Nothing)</tt>) the pair is
--   replaced by pair <tt>(k, e')</tt>.</li>
--   <li>If <tt>(tr k e)</tt> is (<tt>Just (e', Just k')</tt>) the pair is
--   replaced by pair <tt>(k', e')</tt>.</li>
--   </ul>
--   
--   If any of the updated key-element pairs would cause a collision, the
--   result is <tt>Nothing</tt>.
--   
--   Complexity: <i>O(c + s * (min(n, W) + k * (log n + min(n, W))))</i>
--   
--   See also:
--   
--   <ul>
--   <li><a>updateWithKey'</a></li>
--   </ul>
updateWithKey :: IsSelection sel => (RawKey krs ts -> v -> Maybe (v, Maybe (Key krs ts))) -> sel tag krs irs ts -> Store tag krs irs ts v -> Maybe (Store tag krs irs ts v)

-- | The expression (<tt><a>updateWithKey'</a> tr sel old</tt>) is
--   <tt>new</tt> where <tt>new</tt> is a store containing the same
--   key-element pairs as <tt>old</tt> except for any key-element pairs
--   <tt>(k, e)</tt> that match the selection <tt>sel</tt>, those are
--   updated as follows:
--   
--   <ul>
--   <li>If <tt>(tr k e)</tt> is <tt>Nothing</tt> the pair is not included
--   in <tt>new</tt>.</li>
--   <li>If <tt>(tr k e)</tt> is (<tt>Just (e', Nothing)</tt>) the pair is
--   replaced by pair <tt>(k, e')</tt>.</li>
--   <li>If <tt>(tr k e)</tt> is (<tt>Just (e', Just k')</tt>) the pair is
--   replaced by pair <tt>(k', e')</tt>.</li>
--   </ul>
--   
--   Any pairs of the original store <tt>old</tt> that would, after the
--   update, cause collisons are not included in <tt>new</tt>.
--   
--   Complexity: <i>O(c + s * d * (min(n, W) + k * (log n + min(n,
--   W))))</i>
--   
--   See also:
--   
--   <ul>
--   <li><a>updateWithKey</a></li>
--   </ul>
updateWithKey' :: IsSelection sel => (RawKey krs ts -> v -> Maybe (v, Maybe (Key krs ts))) -> sel tag krs irs ts -> Store tag krs irs ts v -> Store tag krs irs ts v

-- | The expression (<tt><a>update</a> tr sel s</tt>) is equivalent to
--   (<tt><a>updateWithKey</a> tr' sel s</tt>) where (<tt>tr' = (_ v -&gt;
--   tr v) = const tr</tt>).
--   
--   Complexity: <i>O(c + s * (min(n, W) + q * log n))</i>
update :: IsSelection sel => (v -> Maybe (v, Maybe (Key krs ts))) -> sel tag krs irs ts -> Store tag krs irs ts v -> Maybe (Store tag krs irs ts v)

-- | The expression (<tt><a>update'</a> tr sel s</tt>) is equivalent to
--   (<tt><a>updateWithKey'</a> tr' sel s</tt>) where (<tt>tr' = (_ v -&gt;
--   tr v) = const tr</tt>).
--   
--   Complexity: <i>O(c + d * s * (min(n, W) + q * log n))</i>
update' :: IsSelection sel => (v -> Maybe (v, Maybe (Key krs ts))) -> sel tag krs irs ts -> Store tag krs irs ts v -> Store tag krs irs ts v

-- | The expression (<tt><a>updateElements</a> tr sel s</tt>) is equivalent
--   to (<tt><a>update</a> tr' sel s</tt>) where (<tt>tr' = (maybe Nothing
--   (v -&gt; Just (v, Nothing)) . tr)</tt>).
--   
--   Complexity: <i>O(c + s * min(n, W))</i>
updateElements :: IsSelection sel => (v -> Maybe v) -> sel tag krs irs ts -> Store tag krs irs ts v -> Store tag krs irs ts v

-- | The expression (<tt><a>delete</a> sel old</tt>) is equivalent to
--   (<tt><a>fromJust</a> $ <a>update</a> (const Nothing) sel old</tt>).
--   
--   Complexity: <i>O(c + s * (min(n, W) + q * log n)</i>
delete :: IsSelection sel => sel tag krs irs ts -> Store tag krs irs ts v -> Store tag krs irs ts v

-- | The expression <tt>(<a>map</a> tr old</tt>) is store where every
--   element of <tt>old</tt> was transformed using the function
--   <tt>tr</tt>.
map :: (v1 -> v2) -> Store tag krs irs ts v1 -> Store tag krs irs ts v2

-- | The expression (<tt><a>foldr</a> f z s</tt>) folds the store using the
--   given right-associative binary operator.
foldr :: (v -> b -> b) -> b -> Store tag krs irs ts v -> b

-- | The expression (<tt><a>foldrWithKey</a> f z s</tt>) folds the store
--   using the given right-associative operator.
foldrWithKey :: (RawKey krs ts -> v -> b -> b) -> b -> Store tag krs irs ts v -> b

-- | The expression (<tt><a>foldl</a> f z s</tt>) folds the store using the
--   given left-associative binary operator.
foldl :: (b -> v -> b) -> b -> Store tag krs irs ts v -> b

-- | The expression (<tt><a>foldlWithKey</a> f z s</tt>) folds the store
--   using the given left-associative operator.
foldlWithKey :: (b -> RawKey krs ts -> v -> b) -> b -> Store tag krs irs ts v -> b

-- | The expression (<tt><a>toList</a> store</tt>) is a list of key-element
--   pairs that are stored in <tt>store</tt>.
toList :: Store tag krs irs ts v -> [(RawKey krs ts, v)]

-- | The expression (<tt><a>elements</a> store</tt>) is a list of elements
--   that are stored in <tt>store</tt>.
elements :: Store tag krs irs ts v -> [v]

-- | The expression (<tt><a>keys</a> store</tt>) is a list of pairs raw
--   keys that are stored in <tt>store</tt>.
keys :: Store tag krs irs ts v -> [RawKey krs ts]

-- | The expression (<tt><a>fromList</a> kvs</tt>) is either a) (<tt>Just
--   store</tt>) where <tt>store</tt> is a store containing exactly the
--   given key-element pairs or; b) <tt>Nothing</tt> if inserting any of
--   the key-element pairs would cause a collision.
--   
--   See also:
--   
--   <ul>
--   <li><a>fromList'</a></li>
--   </ul>
fromList :: Empty (Index irs ts) => [(Key krs ts, v)] -> Maybe (Store tag krs irs ts v)

-- | The expression (<tt><a>fromList'</a> kvs</tt>) is <tt>store</tt>
--   containing the given key-element pairs (colliding pairs are not
--   included).
--   
--   See also:
--   
--   <ul>
--   <li><a>fromList</a></li>
--   </ul>
fromList' :: Empty (Index irs ts) => [(Key krs ts, v)] -> Store tag krs irs ts v

-- | UNSAFE! This function can corrupt the store.
--   
--   The expression (<tt><a>fromList'</a> kvs</tt>) is <tt>store</tt>
--   containing the given key-element pairs (colliding pairs cause
--   UNDEFINED BEHAVIOUR).
--   
--   See also:
--   
--   <ul>
--   <li><a>fromList</a></li>
--   <li><a>fromList</a></li>
--   </ul>
unsafeFromList :: Empty (Index irs ts) => [(Key krs ts, v)] -> Store tag krs irs ts v

-- | The expression (<tt><a>size</a> store</tt>) is the number of elements
--   in <tt>store</tt>.
size :: Store tag krs irs ts v -> Int

-- | The expression (<tt><a>lookup</a> sel store</tt>) is list of (raw
--   key)-element pairs that match the selection.
--   
--   Complexity: <i>O(c + s * min(n, W))</i>
lookup :: IsSelection sel => sel tag krs irs ts -> Store tag krs irs ts v -> [(RawKey krs ts, v)]
data Selection tag krs irs ts

-- | The expression (<tt>not' sel</tt>) is a selection that includes all
--   values except those that match the selection <tt>sel</tt>.
not :: IsSelection sel => sel tag krs irs ts -> Selection tag krs irs ts

-- | The expression (<tt>sDim .&lt; c</tt>) is a selection that includes
--   value <tt>x</tt> if and only if it is indexed in the <tt>sDim</tt>
--   dimension with a key <tt>k</tt> such that <tt>k &lt; c</tt>.
--   
--   Complexity of <tt><a>resolve</a></tt>: <i>O(log n + k)</i>
(.<) :: GetDimension n (Index irs ts) => (tag, n) -> DimensionType n irs ts -> Selection tag krs irs ts

-- | The expression (<tt>sDim .&lt;= c</tt>) is a selection that includes
--   value <tt>x</tt> if and only if it is indexed in the <tt>sDim</tt>
--   dimension with a key <tt>k</tt> such that <tt>k &lt;= c</tt>.
--   
--   Complexity of <tt><a>resolve</a></tt>: <i>O(log n + k)</i>
(.<=) :: GetDimension n (Index irs ts) => (tag, n) -> DimensionType n irs ts -> Selection tag krs irs ts

-- | The expression (<tt>sDim .&gt; c</tt>) is a selection that includes
--   value <tt>x</tt> if and only if it is indexed in the <tt>sDim</tt>
--   dimension with a key <tt>k</tt> such that <tt>k &gt; c</tt>.
--   
--   Complexity of <tt><a>resolve</a></tt>: <i>O(log n + k)</i>
(.>) :: GetDimension n (Index irs ts) => (tag, n) -> DimensionType n irs ts -> Selection tag krs irs ts

-- | The expression (<tt>sDim .&gt;= c</tt>) is a selection that includes
--   value <tt>x</tt> if and only if it is indexed in the <tt>sDim</tt>
--   dimension with a key <tt>k</tt> such that <tt>k &gt;= c</tt>.
--   
--   Complexity of <tt><a>resolve</a></tt>: <i>O(log n + k)</i>
(.>=) :: GetDimension n (Index irs ts) => (tag, n) -> DimensionType n irs ts -> Selection tag krs irs ts

-- | The expression (<tt>sDim ./= c</tt>) is a selection that includes
--   value <tt>x</tt> if and only if it is indexed in the <tt>sDim</tt>
--   dimension with a key <tt>k</tt> such that <tt>k /= c</tt>.
--   
--   Complexity of <tt><a>resolve</a></tt>: <i>O(n)</i>
(./=) :: GetDimension n (Index irs ts) => (tag, n) -> DimensionType n irs ts -> Selection tag krs irs ts

-- | The expression (<tt>sDim .== c</tt>) is a selection that includes
--   value <tt>x</tt> if and only if it is indexed in the <tt>sDim</tt>
--   dimension with a key <tt>k</tt> such that <tt>k == c</tt>.
--   
--   Complexity of <tt><a>resolve</a></tt>: <i>O(log n)</i>
(.==) :: GetDimension n (Index irs ts) => (tag, n) -> DimensionType n irs ts -> Selection tag krs irs ts

-- | The expression (<tt>s1 .&amp;&amp; s2</tt>) is a selection that
--   includes the intersection of the selections <tt>s1</tt> and
--   <tt>s2</tt>.
--   
--   Complexity of <tt><a>resolve</a></tt>: <i>O(c(s1) + c(s2) + s(s1) +
--   s(s2)</i>
(.&&) :: (IsSelection s1, IsSelection s2) => s1 tag krs irs ts -> s2 tag krs irs ts -> Selection tag krs irs ts

-- | The expression (<tt>s1 .|| s2</tt>) is a selection that includes the
--   union of the selections <tt>s1</tt> and <tt>s2</tt>.
--   
--   Complexity of <tt><a>resolve</a></tt>: <i>O(c(s1) + c(s2) + s(s1) +
--   s(s2)</i>
(.||) :: (IsSelection s1, IsSelection s2) => s1 tag krs irs ts -> s2 tag krs irs ts -> Selection tag krs irs ts

-- | Function for creating an auto-increment dimension. Can be used instead
--   of (<tt>dimO x</tt>) if the type is an instance of the
--   <tt><a>Auto</a></tt> type-class.
dimA :: Auto t => KeyDimension O t

-- | Function for creating dimensions with the relation
--   "one-<a>anything</a>".
dimO :: Ord t => t -> KeyDimension O t

-- | Function for creating dimensions with the relation
--   "many-<a>anything</a>".
dimM :: Ord t => [t] -> KeyDimension M t

-- | Function for connecting one dimension and rest of the key.
(.:) :: dim r t -> GenericKey dim rs1 ts1 -> GenericKey dim (r :. rs1) (t :. ts1)

-- | Function for connecting one dimensions with another (most often the
--   last dimension of the key).
(.:.) :: dim r1 t1 -> dim r2 t2 -> GenericKey dim (r1 :. r2) (t1 :. t2)

-- | Type-level successor of a number.
data S n
S :: n -> S n

-- | Type-level zero.
data Z
type N0 = Z
type N1 = S N0
type N2 = S N1
type N3 = S N2
type N4 = S N3
type N5 = S N4
type N6 = S N5
type N7 = S N6
type N8 = S N7
type N9 = S N8
type N10 = S N9
n0 :: N0
n1 :: N1
n2 :: N2
n3 :: N3
n4 :: N4
n5 :: N5
n6 :: N6
n7 :: N7
n8 :: N8
n9 :: N9
n10 :: N10
showIndex :: Show (Index irs ts) => Store tag krs irs ts v -> String
printIndex :: Show (Index irs ts) => Store tag krs irs ts v -> IO ()

-- | The name of this module.
moduleName :: String
instance Empty (Index irs ts) => Monoid (Store tag krs irs ts v)
instance Functor (Store tag krs irs ts)

module Data.Store.Storable

-- | This type-class facilitates the common use case where the key under
--   which given values is to be indexed can be derived from the value.
--   
--   Example:
--   
--   The <tt>Storable</tt> type-class instance for our <tt>Content</tt>
--   data type would look like this:
--   
--   <pre>
--   instance Storable Content where
--       type StoreKRS Content = O         :. O      :. O      :. M      :. O 
--       type StoreIRS Content = O         :. O      :. M      :. M      :. M
--       type StoreTS  Content = ContentID :. String :. String :. String :. Double
--   
--       key (Content cn cb cts cr) = 
--           S.dimA .: S.dimO cn .: S.dimO cb .: S.dimM cts .:. S.dimO cr
--   </pre>
class Storable v where type family StoreKRS t :: * type family StoreIRS t :: * type family StoreTS t :: *
key :: Storable v => v -> Key (StoreKRS v) (StoreTS v)

-- | See <tt><a>insert</a></tt>.
insert :: Storable v => v -> Store tag (StoreKRS v) (StoreIRS v) (StoreTS v) v -> Maybe (RawKey (StoreKRS v) (StoreTS v), Store tag (StoreKRS v) (StoreIRS v) (StoreTS v) v)

-- | See <tt><a>insert'</a></tt>.
insert' :: Storable v => v -> Store tag (StoreKRS v) (StoreIRS v) (StoreTS v) v -> (RawKey (StoreKRS v) (StoreTS v), Store tag (StoreKRS v) (StoreIRS v) (StoreTS v) v)

-- | See <tt><a>updateWithKey</a></tt>.
updateWithKey :: (Storable v, IsSelection sel) => (RawKey (StoreKRS v) (StoreTS v) -> v -> Maybe v) -> sel tag (StoreKRS v) (StoreIRS v) (StoreTS v) -> Store tag (StoreKRS v) (StoreIRS v) (StoreTS v) v -> Maybe (Store tag (StoreKRS v) (StoreIRS v) (StoreTS v) v)

-- | See <tt><a>updateWithKey'</a></tt>.
updateWithKey' :: (Storable v, IsSelection sel) => (RawKey (StoreKRS v) (StoreTS v) -> v -> Maybe v) -> sel tag (StoreKRS v) (StoreIRS v) (StoreTS v) -> Store tag (StoreKRS v) (StoreIRS v) (StoreTS v) v -> Store tag (StoreKRS v) (StoreIRS v) (StoreTS v) v

-- | See <tt><a>update</a></tt>.
update :: (Storable v, IsSelection sel) => (v -> Maybe v) -> sel tag (StoreKRS v) (StoreIRS v) (StoreTS v) -> Store tag (StoreKRS v) (StoreIRS v) (StoreTS v) v -> Maybe (Store tag (StoreKRS v) (StoreIRS v) (StoreTS v) v)

-- | See <tt><a>update'</a></tt>.
update' :: (Storable v, IsSelection sel) => (v -> Maybe v) -> sel tag (StoreKRS v) (StoreIRS v) (StoreTS v) -> Store tag (StoreKRS v) (StoreIRS v) (StoreTS v) v -> Store tag (StoreKRS v) (StoreIRS v) (StoreTS v) v

-- | See <tt><a>fromList</a></tt>.
fromList :: (Empty (Index (StoreIRS v) (StoreTS v)), Storable v) => [v] -> Maybe (Store tag (StoreKRS v) (StoreIRS v) (StoreTS v) v)

-- | See <tt><a>fromList'</a></tt>.
fromList' :: (Empty (Index (StoreIRS v) (StoreTS v)), Storable v) => [v] -> Store tag (StoreKRS v) (StoreIRS v) (StoreTS v) v

module Data.Store.Lens
class With sel
with :: (With sel, Empty (Index irs ts)) => sel tag krs irs ts -> Lens' (Store tag krs irs ts v) (Store tag krs irs ts v)
instance IsSelection sel => With sel
