-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Countable, Searchable, Finite, Empty classes
--   
--   <ul>
--   <li><tt>class Countable</tt>, for countable types</li>
--   <li><tt>class AtLeastOneCountable</tt>, for countable types that have
--   at least one value</li>
--   <li><tt>class InfiniteCountable</tt>, for infinite countable
--   types</li>
--   <li><tt>class Searchable</tt>, for types that can be searched over.
--   This turns out to include some infinite types, see
--   <a>http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/</a>.</li>
--   <li><tt>class Finite</tt>, for finite types</li>
--   <li><tt>class Empty</tt>, for empty types</li>
--   <li><tt>data Nothing</tt>, an empty type</li>
--   </ul>
--   
--   Some orphan instances:
--   
--   <ul>
--   <li><tt>(Searchable a,Eq b) =&gt; Eq (a -&gt; b)</tt> <i> </i></li>
--   <li><tt>(Finite t) =&gt; Foldable ((-&gt;) t)</tt> <i> </i></li>
--   <li><tt>(Finite a) =&gt; Traversable ((-&gt;) a)</tt> <i> </i></li>
--   <li><tt>(Show a,Finite a,Show b) =&gt; Show (a -&gt; b)</tt> <i>
--   </i></li>
--   </ul>
@package countable
@version 0.2

module Data.Countable
class Eq a => Countable a
countPrevious :: Countable a => a -> Maybe a
countMaybeNext :: Countable a => Maybe a -> Maybe a
countDown :: Countable a => a -> [a]
boundedCountPrevious :: (Eq a, Bounded a, Enum a) => a -> Maybe a
boundedCountMaybeNext :: (Eq a, Bounded a, Enum a) => Maybe a -> Maybe a
maybeRecount :: (Countable a, Countable b) => a -> Maybe b
countDownUp :: (Countable down, Countable up) => (down, up) -> Maybe (down, up)
countUpDown :: (Countable up, Countable down) => (up, down) -> Maybe (up, down)
finalIteration :: (a -> Maybe a) -> a -> a
class Countable a => AtLeastOneCountable a
countFirst :: AtLeastOneCountable a => a
class AtLeastOneCountable a => InfiniteCountable a
countNext :: InfiniteCountable a => Maybe a -> a
recount :: (Countable a, InfiniteCountable b) => a -> b
instance AtLeastOneCountable a => InfiniteCountable [a]
instance Countable a => AtLeastOneCountable [a]
instance Countable a => Countable [a]
instance (Countable a, InfiniteCountable b) => InfiniteCountable (Either a b)
instance (AtLeastOneCountable a, InfiniteCountable b) => InfiniteCountable (a, b)
instance InfiniteCountable a => InfiniteCountable (Maybe a)
instance InfiniteCountable Integer
instance (AtLeastOneCountable a, AtLeastOneCountable b) => AtLeastOneCountable (a, b)
instance (Countable a, AtLeastOneCountable b) => AtLeastOneCountable (Either a b)
instance Countable a => AtLeastOneCountable (Maybe a)
instance AtLeastOneCountable Integer
instance AtLeastOneCountable Int64
instance AtLeastOneCountable Int32
instance AtLeastOneCountable Int16
instance AtLeastOneCountable Int8
instance AtLeastOneCountable Word64
instance AtLeastOneCountable Word32
instance AtLeastOneCountable Word16
instance AtLeastOneCountable Word8
instance AtLeastOneCountable Bool
instance AtLeastOneCountable ()
instance (Countable a, Countable b) => Countable (a, b)
instance (Countable a, Countable b) => Countable (Either a b)
instance Countable a => Countable (Maybe a)
instance Countable Integer
instance Countable Int64
instance Countable Int32
instance Countable Int16
instance Countable Int8
instance Countable Word64
instance Countable Word32
instance Countable Word16
instance Countable Word8
instance Countable Bool
instance Countable ()

module Data.Expression
data Expression a b f r
ClosedExpression :: (f r) -> Expression a b f r
OpenExpression :: a -> (Expression a b f (b -> r)) -> Expression a b f r
expressionSym :: a -> f (b -> r) -> Expression a b f r
runExpression :: Functor f => Expression a b f r -> f ((a -> b) -> r)
instance Applicative f => Applicative (Expression a b f)
instance Functor f => Functor (Expression a b f)


-- | This module also includes these orphan instances:
--   
--   <ul>
--   <li><tt>(<a>Searchable</a> a,<a>Eq</a> b) =&gt; <a>Eq</a> (a -&gt;
--   b)</tt> <i> </i></li>
--   <li><tt>(<a>Finite</a> t) =&gt; <a>Foldable</a> ((-&gt;) t)</tt> <i>
--   </i></li>
--   <li><tt>(<a>Finite</a> a) =&gt; <a>Traversable</a> ((-&gt;) a)</tt>
--   <i> </i></li>
--   <li><tt>(<a>Show</a> a,<a>Finite</a> a,<a>Show</a> b) =&gt;
--   <a>Show</a> (a -&gt; b)</tt> <i> </i></li>
--   </ul>
module Data.Searchable

-- | It turns out there are <a>Searchable</a> instances that are not
--   <a>Finite</a>. The <tt>(c -&gt; s)</tt> instance is based on the
--   algorithm at
--   <a>http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/</a>.
class Searchable a
search :: Searchable a => (a -> Maybe b) -> Maybe b
forsome :: Searchable a => (a -> Bool) -> Bool
forevery :: Searchable a => (a -> Bool) -> Bool
class (Searchable a, Countable a) => Finite a where assemble afb = fmap listLookup (traverse (\ a -> fmap (\ b -> (a, b)) (afb a)) allValues) where listLookup [] _ = error "missing value" listLookup ((a, b) : _) a' | a == a' = b listLookup (_ : l) a' = listLookup l a'
allValues :: Finite a => [a]
assemble :: (Finite a, Applicative f) => (a -> f b) -> f (a -> b)
finiteSearch :: Finite a => (a -> Maybe b) -> Maybe b
finiteCountPrevious :: Finite a => a -> Maybe a
finiteCountMaybeNext :: Finite a => Maybe a -> Maybe a
instance (Show a, Finite a, Show b) => Show (a -> b)
instance (Finite a, Finite b) => Finite (a -> b)
instance (Finite a, AtLeastOneCountable a, InfiniteCountable b) => InfiniteCountable (a -> b)
instance (Finite a, AtLeastOneCountable b) => AtLeastOneCountable (a -> b)
instance (Finite a, Countable b) => Countable (a -> b)
instance (Finite a, Finite b) => Finite (a, b)
instance (Finite a, Finite b) => Finite (Either a b)
instance Finite a => Finite (Maybe a)
instance Finite Int64
instance Searchable Int64
instance Finite Int32
instance Searchable Int32
instance Finite Int16
instance Searchable Int16
instance Finite Int8
instance Searchable Int8
instance Finite Word64
instance Searchable Word64
instance Finite Word32
instance Searchable Word32
instance Finite Word16
instance Searchable Word16
instance Finite Word8
instance Searchable Word8
instance Finite Bool
instance Searchable Bool
instance Finite ()
instance Searchable ()
instance Finite a => Traversable ((->) a)
instance Finite t => Foldable ((->) t)
instance (Searchable a, Eq b) => Eq (a -> b)
instance (Countable c, Searchable s) => Searchable (c -> s)
instance (Searchable a, Searchable b) => Searchable (a, b)
instance (Searchable a, Searchable b) => Searchable (Either a b)
instance Searchable a => Searchable (Maybe a)

module Data.Empty
class Finite n => Empty n where never n = seq n undefined
never :: Empty n => n -> a
data Nothing
instance Show Nothing
instance Ord Nothing
instance Eq Nothing
instance Empty Nothing
instance Finite Nothing
instance Searchable Nothing
instance Countable Nothing
instance (AtLeastOneCountable a, Finite a, Empty b) => Empty (a -> b)
instance (Empty a, Finite b) => Empty (a, b)
instance (Empty a, Empty b) => Empty (Either a b)
