-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Efficient, high-level dynamic programming.
--   
@package ADPfusion
@version 0.4.1.1

module ADP.Fusion.TH.Common

-- | The last <tt>Name</tt> of a rule is the name of the syntactic type of
--   the result.
getRuleResultType :: VarStrictType -> Name


-- | Backtracking which uses lists internally. The basic idea is to convert
--   each <tt>Stream</tt> into a list. The consumer consumes the stream
--   lazily, but allows for fusion to happen. The hope is that this
--   improves total performance in those cases, where backtracking has
--   significant costs.
module ADP.Fusion.TH.Backtrack

-- | <tt>Backtracking</tt> products of <tt>f</tt> and <tt>b</tt>. Choice in
--   <tt>f</tt> needs to be reduced to a scalar value. It is then compared
--   to the <tt>fst</tt> values in <tt>b</tt>. From those, <tt>choice
--   b</tt> selects.
class ProductBacktracking sigF sigB where type family SigBacktracking sigF sigB :: *
(<||) :: ProductBacktracking sigF sigB => sigF -> sigB -> SigBacktracking sigF sigB

-- | The ADP-established product operation. Returns a vector of results,
--   along the lines of what the ADP <tt>f *** b</tt> provides.
class ProductCombining sigF sigB where type family SigCombining sigF sigB :: *
(***) :: ProductCombining sigF sigB => sigF -> sigB -> SigCombining sigF sigB

-- | Creates instances for all products given a signature data type.
makeProductInstances :: Name -> Q [Dec]

-- | Returns the <a>Name</a> of the monad variable.
getMonadName :: [TyVarBndr] -> Maybe Name

-- | Returns the <a>Name</a>s of the objective function variables, as well
--   as the name of the objective function itself.
getObjectiveNames :: [VarStrictType] -> Maybe (Name, Name, Name, Name)

-- | The left algebra type. Assumes that in <tt>choice :: Stream m x -&gt;
--   m r</tt> we have that <tt>x ~ r</tt>.
buildLeftType :: Name -> (Name, Name, Name) -> (Name, Name) -> [TyVarBndr] -> Type

-- | Here, we do not set any restrictions on the types <tt>m</tt> and
--   <tt>r</tt>.
buildRightType :: Name -> (Name, Name, Name) -> (Name, Name, Name) -> [TyVarBndr] -> Type

-- | Build up the type for backtracking. We want laziness in the right
--   return type. Hence, we have <tt>AppT ListT (VarT xR)</tt> ; i.e. we
--   want to return results in a list.
buildSigBacktrackingType :: Name -> (Name, Name, Name) -> (Name) -> (Name, Name, Name) -> [TyVarBndr] -> Type

-- | Build up the type for backtracking. We want laziness in the right
--   return type. Hence, we have <tt>AppT ListT (VarT xR)</tt>.
buildSigCombiningType :: Name -> Name -> (Name, Name, Name) -> (Name, Name, Name) -> (Name, Name, Name) -> [TyVarBndr] -> TypeQ

-- | Build up attribute and choice function. Here, we actually bind the
--   left and right algebra to <tt>l</tt> and <tt>r</tt>.
genAlgProdFunctions :: Choice -> Name -> [VarStrictType] -> [VarStrictType] -> [VarStrictType] -> Q Clause

-- | Simple wrapper for creating the choice fun expression.
genChoiceFunction :: Choice -> Name -> Name -> VarStrictType -> Q (Name, Exp)

-- | We take the left and right function name for one attribute and build
--   up the combined attribute function. Mostly a wrapper around
--   <tt>recBuildLampat</tt> which does the main work.
--   
--   TODO need fun names from <tt>l</tt> and <tt>r</tt>
genAttributeFunction :: [Name] -> Name -> Name -> VarStrictType -> Q (Name, Exp)

-- | Now things become trickly. We are given all non-terminal names (to
--   differentiate between a terminal (stack) and a syntactic variable; the
--   left and right function; and the arguments to this attribute function
--   (except the result parameter). We are given the latter as a result to
--   an earlier call to <a>getRuleSynVarNames</a>.
--   
--   We now look at each argument and determine wether it is a syntactic
--   variable. If so, then we actually have a tuple arguments
--   <tt>(x,ys)</tt> where <tt>x</tt> has to optimized value and
--   <tt>ys</tt> the backtracking list. The left function receives just
--   <tt>x</tt> in this case. For the right function, things are more
--   complicated, since we have to flatten lists. See <a>buildRns</a>.
--   
--   Terminals are always given "as is" since we do not have a need for
--   tupled-up information as we have for syntactic variables.
recBuildLamPat :: [Name] -> Name -> Name -> [ArgTy Name] -> Q ([Pat], Exp, Exp)
buildLamPat :: [ArgTy Pat] -> Q [Pat]

-- | Look at the argument type and build the capturing variables. In
--   particular captures synvar arguments with a 2-tuple <tt>(x,ys)</tt>.
argTyArgs :: ArgTy Name -> Q (ArgTy Pat)
buildLns :: Exp -> [ArgTy Pat] -> ExpQ

-- | NOTE
--   
--   <pre>
--   [ f x | x &lt;- xs ]
--   CompE [BindS (VarP x) (VarE xs), NoBindS (AppE (VarE f) (VarE x))]
--   </pre>
buildRns :: Exp -> [ArgTy Pat] -> ExpQ

-- | Type for backtracking functions.
--   
--   Not too interesting, mostly to keep track of <tt>choice</tt>.
type Choice = Name -> Name -> Q Exp

-- | Build up the backtracking choice function. This choice function will
--   backtrack based on the first result, then return only the second.
--   
--   TODO it should be (only?) this function we will need to modify to
--   build all algebra products.
--   
--   <tt>ysM</tt> can't be unboxed, as <tt>snd</tt> of each element is a
--   list, lazily consumed. We build up <tt>ysM</tt> as this makes fusion
--   happen. Of course, this is a boxed vector and not as efficient, but we
--   gain the ability to have lazily created backtracking from this!
--   
--   This means strict optimization AND lazy backtracking
buildBacktrackingChoice :: Choice
buildCombiningChoice :: Choice

-- | Transform a monadic stream monadically into a vector.
--   
--   TODO Improve code!
streamToVector :: Monad m => Stream m x -> m (Vector x)

-- | Transform a vector into a monadic stream.
--   
--   TODO improve code!
vectorToStream :: Monad m => Vector x -> Stream m x

-- | Gets the names used in the evaluation function. This returns one
--   <a>Name</a> for each variable.
--   
--   In case of <tt>TupleT 0</tt> the type is <tt>()</tt> and there isn't a
--   name to go with it. We just <tt>mkName "()"</tt> a name, but this
--   might be slightly dangerous? (Not really sure if it indeed is)
--   
--   With <tt>AppT _ _</tt> we have a multidim terminal and produce another
--   hackish name to be consumed above.
--   
--   <pre>
--   AppT (AppT ArrowT (AppT (AppT (ConT Data.Array.Repa.Index.:.) (AppT (AppT (ConT Data.Array.Repa.Index.:.) (ConT Data.Array.Repa.Index.Z)) (VarT c_1627675270))) (VarT c_1627675270))) (VarT x_1627675265)
--   </pre>
getRuleSynVarNames :: [Name] -> Type -> [ArgTy Name]
data ArgTy x

-- | This <tt>SynVar</tt> spans the full column of tapes; i.e. it is a
--   normal syntactic variable.
SynVar :: x -> ArgTy x
synVarName :: ArgTy x -> x

-- | We have just a single-tape grammar and as such just a
--   single-dimensional terminal. We call this term, because
--   <tt>StackedTerms</tt> will be rewritten to just <tt>Term</tt>!
Term :: x -> ArgTy x
termName :: ArgTy x -> x

-- | We have a multi-tape grammar with a stack of just terminals. We
--   normally can ignore the contents in the functions above, but keep them
--   anyway.
StackedTerms :: [ArgTy x] -> ArgTy x
stackedTerms :: ArgTy x -> [ArgTy x]

-- | We have a multi-tape grammar, but the stack contains a mixture of
--   <tt>ArgTy</tt>s.
StackedVars :: [ArgTy x] -> ArgTy x
stackedVars :: ArgTy x -> [ArgTy x]

-- | A single-dim <tt>()</tt> case
NilVar :: ArgTy x

-- | The result type name
Result :: x -> ArgTy x
result :: ArgTy x -> x
unpackArgTy :: Show x => ArgTy x -> x

-- | Get all synvars, even if deep in a stack
flattenSynVars :: ArgTy x -> [x]
instance Show x => Show (ArgTy x)
instance Eq x => Eq (ArgTy x)

module ADP.Fusion.SynVar.Recursive.Point


-- | The <a>axiom</a> runs a backtracking algebra. The name comes from
--   Robert Giegerichs <tt>ADP</tt> where <tt>axiom</tt> runs the fully
--   formed algorithm.
module ADP.Fusion.SynVar.Axiom

-- | The Axiom type class
class Axiom t where type family AxiomStream t :: *
axiom :: Axiom t => t -> AxiomStream t

module ADP.Fusion.QuickCheck.Common
tr :: (Show a1, Show a) => [a] -> [a1] -> b -> b

module ADP.Fusion.Base.Classes
data OutsideContext s
OStatic :: s -> OutsideContext s
ORightOf :: s -> OutsideContext s
OFirstLeft :: s -> OutsideContext s
OLeftOf :: s -> OutsideContext s
data InsideContext s
IStatic :: s -> InsideContext s
IVariable :: s -> InsideContext s
data ComplementContext
Complemented :: ComplementContext
class RuleContext i where type family Context i :: *
initialContext :: RuleContext i => i -> Context i

-- | During construction of the stream, we need to extract individual
--   elements from symbols in production rules. An element in a stream is
--   fixed by both, the type <tt>x</tt> of the actual argument we want to
--   grab (say individual characters we parse from an input) and the type
--   of indices <tt>i</tt> we use.
--   
--   <tt>Elm</tt> data constructors are all eradicated during fusion and
--   should never show up in CORE.
class Element x i where data family Elm x i :: * type family RecElm x i :: * type family Arg x :: *
getArg :: Element x i => Elm x i -> Arg x
getIdx :: Element x i => Elm x i -> i
getOmx :: Element x i => Elm x i -> i
getElm :: Element x i => Elm x i -> RecElm x i

-- | <tt>mkStream</tt> creates the actual stream of elements (<tt>Elm</tt>)
--   that will be fed to functions on the left of the
--   <tt>(&lt;&lt;&lt;)</tt> operator. Streams work over all monads and are
--   specialized for each combination of arguments <tt>x</tt> and indices
--   <tt>i</tt>.
class Monad m => MkStream m x i
mkStream :: MkStream m x i => x -> Context i -> i -> i -> Stream m (Elm x i)

-- | Finally, we need to be able to correctly build together symbols on the
--   right-hand side of the <tt>(&lt;&lt;&lt;)</tt> operator.
--   
--   The default makes sure that the last (or only) argument left over is
--   correctly assigned a <tt>Z</tt> to terminate the symbol stack.
class Build x where type family Stack x :: * type instance Stack x = S :!: x build x = S :!: x
build :: Build x => x -> Stack x

-- | Similar to <a>Z</a>, but terminates an argument stack.
data S
S :: S

-- | <a>staticCheck</a> acts as a static filter. If <tt>b</tt> is true, we
--   keep all stream elements. If <tt>b</tt> is false, we discard all
--   stream elements.
staticCheck :: Monad m => Bool -> Stream m a -> Stream m a
data StaticCheck a b
CheckLeft :: a -> StaticCheck a b
CheckRight :: b -> StaticCheck a b

-- | Constrains the behaviour of the memoizing tables. They may be
--   <a>EmptyOk</a> if <tt>i==j</tt> is allowed (empty subwords or
--   similar); or they may need <a>NonEmpty</a> indices, or finally they
--   can be <a>OnlyZero</a> (only <tt>i==j</tt> allowed) which is useful in
--   multi-dimensional casese.
data TableConstraint
EmptyOk :: TableConstraint
NonEmpty :: TableConstraint
OnlyZero :: TableConstraint
minSize :: TableConstraint -> Int
class ModifyConstraint t
toNonEmpty :: ModifyConstraint t => t -> t
toEmpty :: ModifyConstraint t => t -> t
instance Show ix => Show (Elm S ix)
instance Eq S
instance Show S
instance Eq TableConstraint
instance Show TableConstraint
instance Element S i
instance Build x => Build (x :!: y)

module ADP.Fusion.Base.Multi

-- | Terminates a multi-dimensional terminal symbol stack.
data M
M :: M

-- | Terminal symbols are stacked together with <tt>a</tt> tails and
--   <tt>b</tt> head.
data TermSymbol a b
(:|) :: a -> b -> TermSymbol a b

-- | Extracts the type of a multi-dimensional terminal argument.

-- | Handles each individual argument within a stack of terminal symbols.
class TerminalStream m t i
terminalStream :: TerminalStream m t i => t -> Context i -> i -> Stream m (S5 s j j i i) -> Stream m (S6 s j j i i (TermArg t))
iPackTerminalStream :: (TerminalStream m t1 i, Monad m) => t1 -> Context i -> (:.) i t -> Stream m (S5 s a a ((:.) i b) ((:.) i b)) -> Stream m (S6 s ((:.) a b) ((:.) a b) i i (TermArg t1))
oPackTerminalStream :: (TerminalStream m t1 (Outside z), Monad m) => t1 -> Context (Outside z) -> Outside ((:.) z t) -> Stream m (S5 s a a (Outside ((:.) z b)) (Outside ((:.) z b))) -> Stream m (S6 s ((:.) a b) ((:.) a b) (Outside z) (Outside z) (TermArg t1))

-- | For multi-dimensional terminals we need to be able to calculate how
--   the static/variable signal changes and if the index for the inner part
--   needs to be modified.
class TermStaticVar t i
termStaticVar :: TermStaticVar t i => t -> Context i -> i -> Context i
termStreamIndex :: TermStaticVar t i => t -> Context i -> i -> i
data S4 a b c d
S4 :: !a -> !b -> !c -> !d -> S4 a b c d
data S5 a b c d e
S5 :: !a -> !b -> !c -> !d -> !e -> S5 a b c d e
data S6 a b c d e f
S6 :: !a -> !b -> !c -> !d -> !e -> !f -> S6 a b c d e f
fromTerminalStream :: S6 (Elm ls i) Z Z i i (TermArg (TermSymbol a b)) -> Elm ((:!:) ls (TermSymbol a b)) i
toTerminalStream :: Element x e => Elm x e -> S5 (Elm x e) Z Z e e
class TableStaticVar i
tableStaticVar :: TableStaticVar i => Context i -> i -> Context i
tableStreamIndex :: TableStaticVar i => TblConstraint i -> Context i -> i -> i
instance (Show i, Show (TermArg (TermSymbol a b)), Show (Elm ls i)) => Show (Elm (ls :!: TermSymbol a b) i)
instance Eq M
instance Show M
instance (Eq a, Eq b) => Eq (TermSymbol a b)
instance (Show a, Show b) => Show (TermSymbol a b)
instance (TableStaticVar (Outside is), TableStaticVar (Outside i)) => TableStaticVar (Outside (is :. i))
instance (TableStaticVar is, TableStaticVar i) => TableStaticVar (is :. i)
instance TableStaticVar (Outside Z)
instance TableStaticVar Z
instance (RuleContext (Outside is), RuleContext (Outside i)) => RuleContext (Outside (is :. i))
instance (RuleContext is, RuleContext i) => RuleContext (is :. i)
instance RuleContext (Outside Z)
instance RuleContext Z
instance (TermStaticVar a (Outside is), TermStaticVar b (Outside i)) => TermStaticVar (TermSymbol a b) (Outside (is :. i))
instance (TermStaticVar a is, TermStaticVar b i) => TermStaticVar (TermSymbol a b) (is :. i)
instance TermStaticVar M (Outside Z)
instance TermStaticVar M Z
instance Monad m => MkStream m S (Outside Z)
instance Monad m => MkStream m S Z
instance Monad m => TerminalStream m M (Outside Z)
instance Monad m => TerminalStream m M Z
instance (Monad m, MkStream m ls i, Element ls i, TerminalStream m (TermSymbol a b) i, TermStaticVar (TermSymbol a b) i) => MkStream m (ls :!: TermSymbol a b) i
instance Element ls i => Element (ls :!: TermSymbol a b) i
instance Build (TermSymbol a b)

module ADP.Fusion.Base.Point
instance TableStaticVar (Outside PointL)
instance TableStaticVar PointL
instance (Monad m, MkStream m S (Outside is), Context (Outside (is :. PointL)) ~ (Context (Outside is) :. OutsideContext Int)) => MkStream m S (Outside (is :. PointL))
instance (Monad m, MkStream m S is, Context (is :. PointL) ~ (Context is :. InsideContext Int)) => MkStream m S (is :. PointL)
instance Monad m => MkStream m S (Outside PointL)
instance Monad m => MkStream m S PointL
instance RuleContext (Complement PointL)
instance RuleContext (Outside PointL)
instance RuleContext PointL


-- | The <tt>Context</tt> for a <tt>BitSet</tt> is the number of bits we
--   should reserve for the more right-most symbols, which request a number
--   of reserved bits.
module ADP.Fusion.Base.Set

-- | An undefined bitset with 2 interfaces.
undefbs2i :: BS2I f l
undefi :: Interface i

-- | We sometimes need
data ThisThatNaught a b
This :: a -> ThisThatNaught a b
That :: b -> ThisThatNaught a b
Naught :: ThisThatNaught a b
instance Monad m => MkStream m S (Complement (BS2I First Last))
instance Monad m => MkStream m S (Outside (BS2I First Last))
instance Monad m => MkStream m S (BS2I First Last)
instance Monad m => MkStream m S BitSet
instance RuleContext (Complement (BS2I First Last))
instance RuleContext (Outside (BS2I First Last))
instance RuleContext (BS2I First Last)
instance RuleContext (Complement BitSet)
instance RuleContext (Outside BitSet)
instance RuleContext BitSet


-- | Instances to allow <a>Subword</a>s to be used as index structures in
--   <tt>ADPfusion</tt>.
module ADP.Fusion.Base.Subword
instance TableStaticVar Subword
instance (Monad m, MkStream m S is, Context (is :. Subword) ~ (Context is :. InsideContext ())) => MkStream m S (is :. Subword)
instance Monad m => MkStream m S (Complement Subword)
instance Monad m => MkStream m S (Outside Subword)
instance Monad m => MkStream m S Subword
instance RuleContext (Complement Subword)
instance RuleContext (Outside Subword)
instance RuleContext Subword


-- | The functions in here auto-create suitable algebra product functions
--   from a signature. Currently, functions <tt>&lt;**</tt> are supported
--   which have scalar results in the first variable.
--   
--   TODO If we want to support classified DP, we shall also need
--   <tt>**&lt;</tt> generating vector-results given a vector result,
--   followed by a scalar result.
--   
--   TODO Then we also need <tt>***</tt> handling the case of
--   vector-to-vector results.
--   
--   TODO note the comments in <tt>buildBacktrackingChoice</tt>
module ADP.Fusion.TH
makeAlgebraProduct :: Name -> Q [Dec]
(<||) :: ProductBacktracking sigF sigB => sigF -> sigB -> SigBacktracking sigF sigB
(***) :: ProductCombining sigF sigB => sigF -> sigB -> SigCombining sigF sigB

module ADP.Fusion.Base


-- | Wrap forward tables in such a way as to allow backtracking via
--   algebras.
module ADP.Fusion.SynVar.Backtrack

-- | TODO this should go into <tt>ADP.Fusion.Table.Backtrack</tt>, more
--   than just tabulated syntactic vars are going to use it.
--   
--   NOTE You probably need to give the <tt>monad morphism</tt> between
--   <tt>mF</tt> and <tt>mB</tt> so as to be able to extract forward
--   results in the backtracking phase.
class GenBacktrackTable t (mF :: * -> *) (mB :: * -> *) r where data family Backtrack t (mF :: * -> *) (mB :: * -> *) r :: * type family BacktrackIndex t :: *
toBacktrack :: GenBacktrackTable t mF mB r => t -> (forall a. mF a -> mB a) -> (BacktrackIndex t -> BacktrackIndex t -> mB [r]) -> Backtrack t mF mB r
instance Build (Backtrack t mF mB r)


-- | With <a>tableIndices</a> we create a stream of legal indices for this
--   table. We need <a>tableIndices</a> in multi-dimensional tables as the
--   type of the multi-dimensional indices is generic.
module ADP.Fusion.SynVar.Indices
class TableIndices i
tableIndices :: (TableIndices i, Monad m) => TblConstraint i -> Context i -> i -> Stream m (S5 z j j i i) -> Stream m (S5 z j j i i)

-- | TODO I think we need to check <tt>cs:.c</tt> here
--   
--   TODO yes, handle <tt>Empty</tt> / <tt>NonEmpty</tt> !!!
instance TableIndices (Outside is) => TableIndices (Outside (is :. PointL))
instance TableIndices is => TableIndices (is :. PointL)
instance TableIndices is => TableIndices (is :. Subword)
instance TableIndices (Outside Z)
instance TableIndices Z

module ADP.Fusion.SynVar.Array.Type

-- | Immutable table.
data ITbl m arr i x
ITbl :: !Int -> !Int -> !(TblConstraint i) -> !(arr i x) -> !(i -> i -> m x) -> ITbl m arr i x
iTblBigOrder :: ITbl m arr i x -> !Int
iTblLittleOrder :: ITbl m arr i x -> !Int
iTblConstraint :: ITbl m arr i x -> !(TblConstraint i)
iTblArray :: ITbl m arr i x -> !(arr i x)
iTblFun :: ITbl m arr i x -> !(i -> i -> m x)
instance (Show i, Show (Elm ls i), Show x) => Show (Elm (ls :!: ITbl m arr j x) i)
instance (Monad mB, Element ls (Outside (is :. i)), TableStaticVar (Outside (is :. i)), TableIndices (Outside (is :. i)), MkStream mB ls (Outside (is :. i)), PrimArrayOps arr (Outside (is :. i)) x, Show (is :. i)) => MkStream mB (ls :!: Backtrack (ITbl mF arr (Outside (is :. i)) x) mF mB r) (Outside (is :. i))
instance (Monad m, Element ls (Outside (is :. i)), TableStaticVar (Outside (is :. i)), TableIndices (Outside (is :. i)), MkStream m ls (Outside (is :. i)), PrimArrayOps arr (Outside (is :. i)) x, Show (is :. i)) => MkStream m (ls :!: ITbl m arr (Outside (is :. i)) x) (Outside (is :. i))
instance (Monad mB, Element ls (is :. i), TableStaticVar (is :. i), TableIndices (is :. i), MkStream mB ls (is :. i), PrimArrayOps arr (is :. i) x) => MkStream mB (ls :!: Backtrack (ITbl mF arr (is :. i) x) mF mB r) (is :. i)
instance (Monad m, Element ls (is :. i), TableStaticVar (is :. i), TableIndices (is :. i), MkStream m ls (is :. i), PrimArrayOps arr (is :. i) x) => MkStream m (ls :!: ITbl m arr (is :. i) x) (is :. i)
instance (Show x, Show i, Show (Elm ls i)) => Show (Elm (ls :!: Backtrack (ITbl mF arr i x) mF mB r) i)
instance Element ls i => Element (ls :!: Backtrack (ITbl mF arr j x) mF mB r) i
instance Element ls i => Element (ls :!: ITbl m arr j x) i
instance (Monad mB, PrimArrayOps arr i x, IndexStream i) => Axiom (Backtrack (ITbl mF arr i x) mF mB r)
instance (Monad m, PrimArrayOps arr i x, IndexStream i) => Axiom (ITbl m arr i x)
instance GenBacktrackTable (ITbl mF arr i x) mF mB r
instance Build (ITbl m arr i x)

module ADP.Fusion.SynVar.Array.Point
instance (Monad mB, Element ls (Outside PointL), PrimArrayOps arr (Outside PointL) x, MkStream mB ls (Outside PointL)) => MkStream mB (ls :!: Backtrack (ITbl mF arr (Outside PointL) x) mF mB r) (Outside PointL)
instance (Monad m, Element ls (Outside PointL), PrimArrayOps arr (Outside PointL) x, MkStream m ls (Outside PointL)) => MkStream m (ls :!: ITbl m arr (Outside PointL) x) (Outside PointL)
instance (Monad mB, Element ls PointL, PrimArrayOps arr PointL x, MkStream mB ls PointL) => MkStream mB (ls :!: Backtrack (ITbl mF arr PointL x) mF mB r) PointL
instance (Monad m, Element ls PointL, PrimArrayOps arr PointL x, MkStream m ls PointL) => MkStream m (ls :!: ITbl m arr PointL x) PointL

module ADP.Fusion.SynVar.Array.Set
instance (Monad m, Element ls (BS2I First Last), PrimArrayOps arr (BS2I First Last) x, MkStream m ls (BS2I First Last), Show x) => MkStream m (ls :!: ITbl m arr (BS2I First Last) x) (BS2I First Last)
instance (Monad m, Element ls BitSet, PrimArrayOps arr BitSet x, MkStream m ls BitSet) => MkStream m (ls :!: ITbl m arr BitSet x) BitSet

module ADP.Fusion.SynVar.Array.Subword

-- | Get the previous index; this should really be made generic!
--   
--   TODO This is probably a REALLY STUPID IDEA ;-)
class FirstSecond x k
greenLight :: FirstSecond x k => x -> k -> Bool
class FirstSecondIdx x k i
greenIdx :: FirstSecondIdx x k i => x -> i -> k -> Elm x i -> Subword
instance (FirstSecondIdx ls (arr ((Z :. Subword) :. Subword) x) Subword, Elm ls Subword ~ RecElm (ls :!: Backtrack (ITbl mF arr ((Z :. Subword) :. Subword) x) mF mB r) Subword, Element ls Subword) => FirstSecondIdx (ls :!: Backtrack (ITbl mF arr ((Z :. Subword) :. Subword) x) mF mB r) (arr ((Z :. Subword) :. Subword) x) Subword
instance (FirstSecondIdx ls (arr ((Z :. Subword) :. Subword) x) Subword, Elm ls Subword ~ RecElm (ls :!: ITbl m arr ((Z :. Subword) :. Subword) x) Subword, Element ls Subword) => FirstSecondIdx (ls :!: ITbl m arr ((Z :. Subword) :. Subword) x) (arr ((Z :. Subword) :. Subword) x) Subword
instance FirstSecondIdx S k i
instance FirstSecond ls (arr ((Z :. Subword) :. Subword) x) => FirstSecond (ls :!: Backtrack (ITbl mF arr ((Z :. Subword) :. Subword) x) mF mB r) (arr ((Z :. Subword) :. Subword) x)
instance FirstSecond ls (arr ((Z :. Subword) :. Subword) x) => FirstSecond (ls :!: ITbl m arr ((Z :. Subword) :. Subword) x) (arr ((Z :. Subword) :. Subword) x)
instance FirstSecond S k
instance (Monad mB, FirstSecond ls (arr ((Z :. Subword) :. Subword) x), FirstSecondIdx ls (arr ((Z :. Subword) :. Subword) x) Subword, PrimArrayOps arr ((Z :. Subword) :. Subword) x, Element ls Subword, MkStream mB ls Subword, Show r) => MkStream mB (ls :!: Backtrack (ITbl mF arr ((Z :. Subword) :. Subword) x) mF mB r) Subword
instance (Monad m, Element ls Subword, FirstSecond ls (arr ((Z :. Subword) :. Subword) x), FirstSecondIdx ls (arr ((Z :. Subword) :. Subword) x) Subword, PrimArrayOps arr ((Z :. Subword) :. Subword) x, MkStream m ls Subword, Show x) => MkStream m (ls :!: ITbl m arr ((Z :. Subword) :. Subword) x) Subword
instance ModifyConstraint (Backtrack (ITbl mF arr Subword x) mF mB r)
instance ModifyConstraint (ITbl m arr Subword x)
instance (Monad m, Element ls (Complement Subword), PrimArrayOps arr (Outside Subword) x, MkStream m ls (Complement Subword)) => MkStream m (ls :!: ITbl m arr (Outside Subword) x) (Complement Subword)
instance (Monad m, Element ls (Complement Subword), PrimArrayOps arr Subword x, MkStream m ls (Complement Subword)) => MkStream m (ls :!: ITbl m arr Subword x) (Complement Subword)
instance (Monad m, Element ls (Outside Subword), PrimArrayOps arr Subword x, MkStream m ls (Outside Subword)) => MkStream m (ls :!: ITbl m arr Subword x) (Outside Subword)
instance (Monad m, Element ls (Outside Subword), PrimArrayOps arr (Outside Subword) x, MkStream m ls (Outside Subword)) => MkStream m (ls :!: ITbl m arr (Outside Subword) x) (Outside Subword)
instance (Monad mB, Element ls Subword, MkStream mB ls Subword, PrimArrayOps arr Subword x) => MkStream mB (ls :!: Backtrack (ITbl mF arr Subword x) mF mB r) Subword
instance (Monad m, Element ls Subword, PrimArrayOps arr Subword x, MkStream m ls Subword) => MkStream m (ls :!: ITbl m arr Subword x) Subword


-- | TODO migrate instances to correct modules
module ADP.Fusion.SynVar.Array.TermSymbol

-- | TODO need to deal with <tt>minSize</tt>
instance TermStaticVar (Backtrack (ITbl mF arr Subword x) mF mB r) Subword
instance TermStaticVar (ITbl m arr Subword x) Subword
instance (Monad mB, TerminalStream mB a is, PrimArrayOps arr Subword x) => TerminalStream mB (TermSymbol a (Backtrack (ITbl mF arr Subword x) mF mB r)) (is :. Subword)
instance (Monad m, TerminalStream m a is, PrimArrayOps arr Subword x, Show x) => TerminalStream m (TermSymbol a (ITbl m arr Subword x)) (is :. Subword)

module ADP.Fusion.SynVar.Array

module ADP.Fusion.SynVar.Fill

-- | Run and freeze <tt>MTbl</tt>s. Since actually running the
--   table-filling part is usually the last thing to do, we can freeze as
--   well.
runFreezeMTbls :: (ExposeTables t1, PrimMonad m, IndexStream sh, FreezeTables m (OnlyTables t1), MPrimArrayOps arr sh elm, WriteCell m ((:.) tail (MutArr m (arr sh elm), t)) sh, (~) * (TableFun t1) ((:.) tail (MutArr m (arr sh elm), t))) => t1 -> m (Frozen (OnlyTables t1))

-- | Expose the actual mutable table with an <tt>MTbl</tt>. (Should be
--   temporary until <tt>MTbl</tt>s get a more thorough treatment for
--   auto-filling.
class ExposeTables t where type family TableFun t :: * type family OnlyTables t :: *
expose :: ExposeTables t => t -> TableFun t
onlyTables :: ExposeTables t => t -> OnlyTables t

-- | A vanilla context-free grammar
data CFG

-- | This grammar is a multi-cfg in a monotone setting
data MonotoneMCFG

-- | Mutate a cell in a stack of syntactic variables.
--   
--   TODO generalize to monad morphism via <tt>mmorph</tt> package. This
--   will allow more interesting <tt>mrph</tt> functions that can, for
--   example, track some state in the forward phase. (Note that this can be
--   dangerous, we do <i>not</i> want to have this state influence forward
--   results, unless that can be made deterministic, or we'll break
--   Bellman)
class MutateCell (h :: *) (s :: *) (im :: * -> *) (om :: * -> *) i
mutateCell :: MutateCell h s im om i => Proxy h -> Int -> Int -> (forall a. im a -> om a) -> s -> i -> i -> om ()
class MutateTables (h :: *) (s :: *) (im :: * -> *) (om :: * -> *)
mutateTables :: MutateTables h s im om => Proxy h -> (forall a. im a -> om a) -> s -> om s
class TableOrder (s :: *)
tableLittleOrder :: TableOrder s => s -> [Int]
tableBigOrder :: TableOrder s => s -> [Int]
type ZS2 = (Z :. Subword) :. Subword

-- | Default table filling, assuming that the forward monad is just
--   <tt>IO</tt>.
--   
--   TODO generalize to <tt>MonadIO</tt> or <tt>MonadPrim</tt>.
mutateTablesDefault :: MutateTables CFG t Id IO => t -> t

-- | Mutate tables, but observe certain hints. We use this for monotone
--   mcfgs for now.
mutateTablesWithHints :: MutateTables h t Id IO => Proxy h -> t -> t
instance Monad om => MutateCell p Z im om i
instance (Monad om, MutateCell h (ts :. ITbl im arr i x) im om i, PrimArrayOps arr i x, Show i, IndexStream i, TableOrder (ts :. ITbl im arr i x)) => MutateTables h (ts :. ITbl im arr i x) im om
instance (PrimArrayOps arr Subword x, MPrimArrayOps arr Subword x, MutateCell h ts im om ((Z :. Subword) :. Subword), PrimMonad om) => MutateCell h (ts :. ITbl im arr Subword x) im om ((Z :. Subword) :. Subword)
instance (PrimArrayOps arr ZS2 x, MPrimArrayOps arr ZS2 x, MutateCell MonotoneMCFG ts im om ZS2, PrimMonad om) => MutateCell MonotoneMCFG (ts :. ITbl im arr ZS2 x) im om ZS2
instance (PrimArrayOps arr i x, MPrimArrayOps arr i x, MutateCell CFG ts im om i, PrimMonad om, Show x, Show i) => MutateCell CFG (ts :. ITbl im arr i x) im om i
instance TableOrder ts => TableOrder (ts :. ITbl im arr i x)
instance TableOrder Z
instance ExposeTables Z

module ADP.Fusion.SynVar.Recursive.Type
data IRec m i x
IRec :: !(TblConstraint i) -> !i -> !i -> !(i -> i -> m x) -> IRec m i x
iRecConstraint :: IRec m i x -> !(TblConstraint i)
iRecFrom :: IRec m i x -> !i
iRecTo :: IRec m i x -> !i
iRecFun :: IRec m i x -> !(i -> i -> m x)
instance Element ls i => Element (ls :!: Backtrack (IRec mF i x) mF mB r) i
instance Element ls i => Element (ls :!: IRec m i x) i
instance (Monad mB, IndexStream i) => Axiom (Backtrack (IRec mF i x) mF mB r)
instance (Monad m, IndexStream i) => Axiom (IRec m i x)
instance GenBacktrackTable (IRec mF i x) mF mB r
instance Build (IRec m i x)

module ADP.Fusion.SynVar.Recursive.Subword

module ADP.Fusion.SynVar.Recursive


-- | NOTE <i>highly experimental</i>
module ADP.Fusion.SynVar.Split.Type
data SplitType
Fragment :: SplitType
Final :: SplitType

-- | The <tt>Arg synVar</tt> means that we probably need to rewrite the
--   internal type resolution now!

-- | Should never fail?

-- | Wraps a normal non-terminal and attaches a type-level unique identier
--   and z-ordering (with the unused <tt>Z</tt> at <tt>0</tt>).
--   
--   TODO attach empty/non-empty stuff (or get from non-splitted synvar?)
--   
--   TODO re-introduce z-ordering later (once we have a sort fun)
newtype Split (uId :: Symbol) (splitType :: SplitType) synVar
Split :: synVar -> Split synVar
getSplit :: Split synVar -> synVar
split :: Proxy (uId :: Symbol) -> Proxy (splitType :: SplitType) -> synVar -> Split uId splitType synVar

-- | <a>collectIx</a> gobbles up indices that are tagged with the same
--   symbolic identifier.
collectIx :: SplitIxCol uId (SameSid uId (Elm ls i)) (Elm ls i) => Proxy uId -> Elm ls i -> SplitIxTy uId (SameSid uId (Elm ls i)) (Elm ls i)

-- | Closed type family that gives us a (type) function for type symbol
--   equality.

-- | Type-level <tt>(||)</tt>

-- | <tt>x ++ y</tt> but for inductive tuples.
--   
--   TODO move to PrimitiveArray
class Zconcat x y where type family Zpp x y :: *
zconcat :: Zconcat x y => x -> y -> Zpp x y

-- | Actually collect split indices based on if we managed to find the
--   right <tt>Split</tt> synvar (based on the right symbol).
class SplitIxCol (uId :: Symbol) (b :: Bool) e where type family SplitIxTy uId b e :: *
splitIxCol :: SplitIxCol uId b e => Proxy uId -> Proxy b -> e -> SplitIxTy uId b e

-- | A concrete, poly-kinded proxy type
data Proxy (t :: k) :: k -> *
Proxy :: Proxy
instance (SplitIxCol uId (SameSid uId (Elm ls i)) (Elm ls i), Zconcat (SplitIxTy uId (SameSid uId (Elm ls i)) (Elm ls i)) (SplitIxTy uId (SameSid uId (TermSymbol a b)) (TermSymbol a b))) => SplitIxCol uId 'True (Elm (ls :!: TermSymbol a b) i)
instance SplitIxCol uId (SameSid uId (Elm ls i)) (Elm ls i) => SplitIxCol uId 'True (Elm (ls :!: Split sId splitType (Backtrack (ITbl mF arr j x) mF mB r)) i)
instance SplitIxCol uId (SameSid uId (Elm ls i)) (Elm ls i) => SplitIxCol uId 'True (Elm (ls :!: Split sId splitType (ITbl m arr j x)) i)
instance (SplitIxCol uId (SameSid uId (Elm ls i)) (Elm ls i), Element (ls :!: l) i, RecElm (ls :!: l) i ~ Elm ls i) => SplitIxCol uId 'False (Elm (ls :!: l) i)
instance SplitIxCol uId b (Elm S i)
instance Zconcat x z => Zconcat x (z :. y)
instance Zconcat x Z
instance Element ls i => Element (ls :!: Split uId splitType (Backtrack (ITbl mF arr j x) mF mB r)) i
instance Element ls i => Element (ls :!: Split uId splitType (ITbl m arr j x)) i
instance Build (Split uId splitType synVar)

module ADP.Fusion.SynVar.Split.Subword
instance (Monad mB, Element ls Subword, MkStream mB ls Subword, SplitIxCol uId (SameSid uId (Elm ls Subword)) (Elm ls Subword), (SplitIxTy uId (SameSid uId (Elm ls Subword)) (Elm ls Subword) :. Subword) ~ mix, PrimArrayOps arr (SplitIxTy uId (SameSid uId (Elm ls Subword)) (Elm ls Subword) :. Subword) x) => MkStream mB (ls :!: Split uId 'Final (Backtrack (ITbl mF arr mix x) mF mB r)) Subword
instance (Monad mB, Element ls Subword, MkStream mB ls Subword) => MkStream mB (ls :!: Split uId 'Fragment (Backtrack (ITbl mF arr j x) mF mB r)) Subword
instance (Monad m, Element ls Subword, MkStream m ls Subword, SplitIxCol uId (SameSid uId (Elm ls Subword)) (Elm ls Subword), (SplitIxTy uId (SameSid uId (Elm ls Subword)) (Elm ls Subword) :. Subword) ~ mix, PrimArrayOps arr (SplitIxTy uId (SameSid uId (Elm ls Subword)) (Elm ls Subword) :. Subword) x) => MkStream m (ls :!: Split uId 'Final (ITbl m arr mix x)) Subword
instance (Monad m, Element ls Subword, MkStream m ls Subword) => MkStream m (ls :!: Split uId 'Fragment (ITbl m arr j x)) Subword


-- | Split syntactic variables for multi-cfg dynamic programs.
module ADP.Fusion.SynVar.Split


-- | This module re-exports all table types.
module ADP.Fusion.SynVar

module ADP.Fusion.Term.Chr.Type

-- | A generic Character parser that reads a single character but allows
--   passing additional information.
--   
--   <a>Chr</a> expects a function to retrieve <tt>r</tt> at index
--   position, followed by the actual generic vector with data.
data Chr r x
Chr :: (v x -> Int -> r) -> (v x) -> Chr r x

-- | smart constructor for regular 1-character parsers
chr :: Vector v x => v x -> Chr x x

-- | Smart constructor for Maybe Peeking, followed by a character.
chrLeft :: Vector v x => v x -> Chr (Maybe x, x) x
instance (Show i, Show r, Show (Elm ls i)) => Show (Elm (ls :!: Chr r x) i)
instance Element ls i => Element (ls :!: Chr r x) i
instance Build (Chr r x)

module ADP.Fusion.Term.Chr.Point
instance (Monad m, TerminalStream m a (Outside is), Context (Outside (is :. PointL)) ~ (Context (Outside is) :. OutsideContext Int)) => TerminalStream m (TermSymbol a (Chr r x)) (Outside (is :. PointL))
instance (Monad m, TerminalStream m a is) => TerminalStream m (TermSymbol a (Chr r x)) (is :. PointL)
instance TermStaticVar (Chr r x) (Outside PointL)
instance TermStaticVar (Chr r x) PointL
instance (Monad m, Element ls (Outside PointL), MkStream m ls (Outside PointL)) => MkStream m (ls :!: Chr r x) (Outside PointL)
instance (Monad m, Element ls PointL, MkStream m ls PointL) => MkStream m (ls :!: Chr r x) PointL

module ADP.Fusion.Term.Chr.Subword
instance TermStaticVar (Chr r x) Subword
instance (Monad m, TerminalStream m a is) => TerminalStream m (TermSymbol a (Chr r x)) (is :. Subword)
instance (Monad m, Element ls (Outside Subword), MkStream m ls (Outside Subword)) => MkStream m (ls :!: Chr r x) (Outside Subword)
instance (Monad m, Element ls Subword, MkStream m ls Subword) => MkStream m (ls :!: Chr r x) Subword

module ADP.Fusion.Term.Chr

module ADP.Fusion.Term.Deletion.Type
data Deletion
Deletion :: Deletion
instance Element ls i => Element (ls :!: Deletion) i
instance Build Deletion

module ADP.Fusion.Term.Deletion.Point
instance (Monad m, TerminalStream m a (Outside is)) => TerminalStream m (TermSymbol a Deletion) (Outside (is :. PointL))
instance (Monad m, TerminalStream m a is) => TerminalStream m (TermSymbol a Deletion) (is :. PointL)
instance TermStaticVar Deletion (Outside PointL)
instance TermStaticVar Deletion PointL
instance (Monad m, Element ls (Outside PointL), MkStream m ls (Outside PointL)) => MkStream m (ls :!: Deletion) (Outside PointL)
instance (Monad m, MkStream m ls PointL) => MkStream m (ls :!: Deletion) PointL

module ADP.Fusion.Term.Deletion.Subword
instance TermStaticVar Deletion Subword
instance (Monad m, TerminalStream m a is) => TerminalStream m (TermSymbol a Deletion) (is :. Subword)

module ADP.Fusion.Term.Deletion

module ADP.Fusion.Term.Edge.Type
data Edge e
Edge :: (Int -> Int -> e) -> Edge e
instance (Show i, Show e, Show (Elm ls i)) => Show (Elm (ls :!: Edge e) i)
instance Element ls i => Element (ls :!: Edge e) i
instance Build (Edge e)

module ADP.Fusion.Term.Edge.Set
instance (Monad m, Element ls (Complement (BS2I First Last)), MkStream m ls (Complement (BS2I First Last))) => MkStream m (ls :!: Edge f) (Complement (BS2I First Last))
instance (Monad m, Element ls (Outside (BS2I First Last)), MkStream m ls (Outside (BS2I First Last))) => MkStream m (ls :!: Edge f) (Outside (BS2I First Last))
instance (Monad m, Element ls (BS2I First Last), MkStream m ls (BS2I First Last)) => MkStream m (ls :!: Edge e) (BS2I First Last)

module ADP.Fusion.Term.Edge

module ADP.Fusion.Term.Epsilon.Type
data Epsilon
Epsilon :: Epsilon
instance Element ls i => Element (ls :!: Epsilon) i
instance Build Epsilon

module ADP.Fusion.Term.Epsilon.Point
instance (Monad m, TerminalStream m a (Outside is)) => TerminalStream m (TermSymbol a Epsilon) (Outside (is :. PointL))
instance (Monad m, TerminalStream m a is) => TerminalStream m (TermSymbol a Epsilon) (is :. PointL)
instance TermStaticVar Epsilon (Outside PointL)
instance TermStaticVar Epsilon PointL
instance (Monad m, Element ls (Outside PointL), MkStream m ls (Outside PointL)) => MkStream m (ls :!: Epsilon) (Outside PointL)
instance (Monad m, MkStream m ls PointL) => MkStream m (ls :!: Epsilon) PointL

module ADP.Fusion.Term.Epsilon.Subword
instance TermStaticVar Epsilon Subword
instance (Monad m, TerminalStream m a is) => TerminalStream m (TermSymbol a Epsilon) (is :. Subword)
instance (Monad m, MkStream m ls (Outside Subword)) => MkStream m (ls :!: Epsilon) (Outside Subword)
instance (Monad m, MkStream m ls Subword) => MkStream m (ls :!: Epsilon) Subword

module ADP.Fusion.Term.Epsilon

module ADP.Fusion.Term.PeekIndex.Type
data PeekIndex i
PeekIndex :: PeekIndex i
instance (Show i, Show (Elm ls i)) => Show (Elm (ls :!: PeekIndex i) i)
instance Element ls i => Element (ls :!: PeekIndex i) i
instance Build (PeekIndex i)

module ADP.Fusion.Term.PeekIndex.Subword
instance (Monad m, Element ls (Complement Subword), MkStream m ls (Complement Subword)) => MkStream m (ls :!: PeekIndex (Complement Subword)) (Complement Subword)

module ADP.Fusion.Term.PeekIndex

module ADP.Fusion.Term.Strng.Type

-- | <a>Strng</a> terminals return "strings", i.e. vectors of
--   <tt>Chr</tt>s. They allow the user to specify <tt>[ 0 .. ]</tt> atoms
--   to be parsed at once. It is possible to both, limit the minimal and
--   maximal number.
--   
--   NOTE gadt comments are not parsed by haddock?
data Strng v x
Strng :: (Int -> Int -> v x -> v x) -> Int -> Int -> (v x) -> Strng v x
manyS :: Vector v x => v x -> Strng v x
someS :: Vector v x => v x -> Strng v x
strng :: Vector v x => Int -> Int -> v x -> Strng v x
instance (Show i, Show (v x), Show (Elm ls i)) => Show (Elm (ls :!: Strng v x) i)
instance Element ls i => Element (ls :!: Strng v x) i
instance Build (Strng v x)

module ADP.Fusion.Term.Strng.Point
instance (Monad m, TerminalStream m a is) => TerminalStream m (TermSymbol a (Strng v x)) (is :. PointL)
instance TermStaticVar (Strng v x) PointL
instance (Monad m, Element ls PointL, MkStream m ls PointL) => MkStream m (ls :!: Strng v x) PointL

module ADP.Fusion.Term.Strng.Subword

-- | TODO If we use (IVariable mx) we might be able to request
--   <tt>exactly</tt> the range we need!
instance (Monad m, Element ls Subword, MkStream m ls Subword) => MkStream m (ls :!: Strng v x) Subword


-- | A <a>Strng</a> matches [0..] <tt>Chr</tt>s.
module ADP.Fusion.Term.Strng

module ADP.Fusion.Term

module ADP.Fusion.Apply
class Apply x where type family Fun x :: *
apply :: Apply x => Fun x -> x
instance Apply ((((((((((((((((Z :. a) :. b) :. c) :. d) :. e) :. f) :. g) :. h) :. i) :. j) :. k) :. l) :. m) :. n) :. o) -> res)
instance Apply (((((((((((((((Z :. a) :. b) :. c) :. d) :. e) :. f) :. g) :. h) :. i) :. j) :. k) :. l) :. m) :. n) -> res)
instance Apply ((((((((((((((Z :. a) :. b) :. c) :. d) :. e) :. f) :. g) :. h) :. i) :. j) :. k) :. l) :. m) -> res)
instance Apply (((((((((((((Z :. a) :. b) :. c) :. d) :. e) :. f) :. g) :. h) :. i) :. j) :. k) :. l) -> res)
instance Apply ((((((((((((Z :. a) :. b) :. c) :. d) :. e) :. f) :. g) :. h) :. i) :. j) :. k) -> res)
instance Apply (((((((((((Z :. a) :. b) :. c) :. d) :. e) :. f) :. g) :. h) :. i) :. j) -> res)
instance Apply ((((((((((Z :. a) :. b) :. c) :. d) :. e) :. f) :. g) :. h) :. i) -> res)
instance Apply (((((((((Z :. a) :. b) :. c) :. d) :. e) :. f) :. g) :. h) -> res)
instance Apply ((((((((Z :. a) :. b) :. c) :. d) :. e) :. f) :. g) -> res)
instance Apply (((((((Z :. a) :. b) :. c) :. d) :. e) :. f) -> res)
instance Apply ((((((Z :. a) :. b) :. c) :. d) :. e) -> res)
instance Apply (((((Z :. a) :. b) :. c) :. d) -> res)
instance Apply ((((Z :. a) :. b) :. c) -> res)
instance Apply (((Z :. a) :. b) -> res)
instance Apply ((Z :. a) -> res)


-- | Generalized fusion system for grammars.
--   
--   NOTE Symbols typically do not check bound data for consistency. If
--   you, say, bind a terminal symbol to an input of length 0 and then run
--   your grammar, you probably get errors, garbled data or random crashes.
--   Such checks are done via asserts in non-production code.
module ADP.Fusion

-- | Apply a function to symbols on the RHS of a production rule. Builds
--   the stack of symbols from <tt>xs</tt> using <a>build</a>, then hands
--   this stack to <a>mkStream</a> together with the initial <tt>iniT</tt>
--   telling <a>mkStream</a> that we are in the "outer" position. Once the
--   stream has been created, we <a>map</a> <a>getArg</a> to get just the
--   arguments in the stack, and finally <a>apply</a> the function
--   <tt>f</tt>.
(<<<) :: (Apply (Arg (Stack x) -> b), RuleContext s, Element (Stack x) s, MkStream m (Stack x) s, Build x) => Fun (Arg (Stack x) -> b) -> x -> s -> s -> Stream m b
(<<#) :: (Apply (Arg (Stack x) -> m b), RuleContext s, Element (Stack x) s, MkStream m (Stack x) s, Build x) => Fun (Arg (Stack x) -> m b) -> x -> s -> s -> Stream m b

-- | Combine two RHSs to give a choice between parses.
(|||) :: Monad m => (t -> t1 -> Stream m a) -> (t -> t1 -> Stream m a) -> t -> t1 -> Stream m a

-- | Applies the objective function <tt>h</tt> to a stream <tt>s</tt>. The
--   objective function reduces the stream to a single optimal value (or
--   some vector of co-optimal things).
(...) :: (t1 -> t2 -> s) -> (s -> t) -> t1 -> t2 -> t

-- | Separator between RHS symbols.
(~~) :: a -> b -> Pair a b

-- | This separator looks much paper "on paper" and is not widely used
--   otherwise.
(%) :: a -> b -> Pair a b

module ADP.Fusion.QuickCheck.Point
prop_Epsilon :: PointL -> Bool
prop_O_Epsilon :: Outside PointL -> Bool
prop_ZEpsilon :: (:.) Z PointL -> Bool
prop_O_ZEpsilon :: Outside ((:.) Z PointL) -> Bool
prop_O_ZEpsilonEpsilon :: Outside ((:.) ((:.) Z PointL) PointL) -> Bool
prop_O_ItNC :: Outside PointL -> Bool
prop_O_ZItNC :: Outside ((:.) Z PointL) -> Bool
prop_O_2dimIt_NC_CN :: Outside ((:.) ((:.) Z PointL) PointL) -> Bool
prop_2dimIt_NC_CN :: (:.) ((:.) Z PointL) PointL -> Bool

-- | A single character terminal
prop_Tt :: (:.) Z PointL -> Bool

-- | Two single-character terminals
prop_CC :: (:.) Z PointL -> Bool

-- | Just a table
prop_It :: PointL -> Bool
prop_O_It :: Outside PointL -> Bool
prop_ZIt :: (:.) Z PointL -> Bool
prop_O_ZIt :: Outside ((:.) Z PointL) -> Bool

-- | Table, then single terminal
prop_ItC :: PointL -> Bool

-- | <tt>A^*_j -&gt; A^*_{j+1} c_{j+1)</tt> !
prop_O_ItC :: Outside PointL -> Bool
prop_O_ItCC :: Outside PointL -> Bool
prop_O_ZItCC :: Outside ((:.) Z PointL) -> Bool

-- | synvar followed by a 2-tape character terminal
prop_2dimItCC :: (:.) ((:.) Z PointL) PointL -> Bool
prop_O_2dimItCC :: Outside ((:.) ((:.) Z PointL) PointL) -> Bool
xprop_O_ixZItCC :: Outside ((:.) Z PointL) -> [Elm ((:!:) ((:!:) ((:!:) S (ITbl Id Unboxed (Outside ((:.) Z PointL)) Int)) (TermSymbol M (Chr Int Int))) (TermSymbol M (Chr Int Int))) (Outside ((:.) Z PointL))]
prop_ManyS :: PointL -> Bool
prop_SomeS :: PointL -> Bool
prop_2dim_ManyS_ManyS :: (:.) ((:.) Z PointL) PointL -> Bool
prop_2dim_SomeS_SomeS :: (:.) ((:.) Z PointL) PointL -> Bool
prop_Itbl_ManyS :: PointL -> Bool
prop_Itbl_SomeS :: PointL -> Bool
prop_1dim_Itbl_ManyS :: (:.) Z PointL -> Bool
prop_1dim_Itbl_SomeS :: (:.) Z PointL -> Bool
prop_2dim_Itbl_ManyS_ManyS :: (:.) ((:.) Z PointL) PointL -> Bool
prop_2dim_Itbl_SomeS_SomeS :: (:.) ((:.) Z PointL) PointL -> Bool
(>>>) :: (RuleContext s, MkStream Id (Stack x) s, Build x) => (Elm (Stack x) s -> b) -> x -> s -> s -> Stream b
class GetIxs x i where type family R x i :: *
getIxs :: GetIxs x i => Elm x i -> R x i
xsP :: Unboxed (PointL) Int
xsZP :: Unboxed (Z :. PointL) Int
xsPo :: Unboxed (Outside (PointL)) Int
xsZPo :: Unboxed (Outside (Z :. PointL)) Int
xsPP :: Unboxed ((Z :. PointL) :. PointL) Int
xsPPo :: Unboxed (Outside ((Z :. PointL) :. PointL)) Int
mxsPP :: MutArr IO (Unboxed ((:.) ((:.) Z PointL) PointL) Int)
maxI :: Int
maxPL :: PointL
xs :: Vector Int
options :: Args
customCheck :: Property -> IO Result
allProps :: IO Bool
instance GetIxs ls i => GetIxs (ls :!: ITbl m a i x) i
instance GetIxs ls i => GetIxs (ls :!: Chr a b) i
instance GetIxs S i

module ADP.Fusion.QuickCheck.Set
prop_b_ii :: BitSet -> Bool
prop_b_ii_nn :: BitSet -> Bool
prop_b_iii :: BitSet -> Bool
prop_b_iii_nnn :: BitSet -> Bool
prop_bii_i :: BS2I First Last -> Bool
prop_bii_i_n :: BS2I First Last -> Bool

-- | Edges should never work as a single terminal element.
prop_bii_e :: BS2I First Last -> Bool

-- | Edges extend only in cases where in <tt>i -&gt; j</tt>, <tt>i</tt>
--   actually happens to be a true interface.
prop_bii_ie :: BS2I First Last -> Bool
prop_bii_ie_n :: BS2I First Last -> Bool
prop_bii_iee :: BS2I First Last -> Bool
prop_bii_ieee :: BS2I First Last -> Bool
prop_bii_iee_n :: BS2I First Last -> Bool
prop_bii_ieee_n :: BS2I First Last -> Bool
highBit :: Int
highestB :: BitSet
highestBII :: (:>) ((:>) BitSet (Interface First)) (Interface Last)
xsB :: Unboxed BitSet Int
xoB :: Unboxed (Outside BitSet) Int
xsBII :: Unboxed ((BitSet :> Interface First) :> Interface Last) Int
options :: Args
customCheck :: Property -> IO Result
allProps :: IO Bool


-- | TODO need to carefully check all props against boundary errors!
--   Especially the 2-dim cases!
module ADP.Fusion.QuickCheck.Subword
prop_sv_OI :: Outside Subword -> Bool
prop_sv_IO :: Outside Subword -> Bool
prop_sv_OII :: Outside Subword -> Bool
prop_sv_IOI :: Outside Subword -> Bool
prop_sv_IIO :: Outside Subword -> Bool
prop_cOc :: Outside Subword -> Bool
prop_ccOcc :: Outside Subword -> Bool
prop_cOccc :: Outside Subword -> Bool
prop_cOcIc :: Outside Subword -> Bool
prop_cIcOc :: Outside Subword -> Bool
prop_Epsilon :: Outside Subword -> Bool
prop_2dimIt :: (:.) ((:.) Z Subword) Subword -> Bool
prop_2dimcIt :: (:.) ((:.) Z Subword) Subword -> Bool
prop_2dimItc :: (:.) ((:.) Z Subword) Subword -> Bool
prop_2dimcItc :: (:.) ((:.) Z Subword) Subword -> Bool
highest :: Int
csS :: Vector (Int, Int)
xsS :: Unboxed Subword (Int, Int)
xoS :: Unboxed (Outside Subword) (Int, Int)
xsSS :: Unboxed ((Z :. Subword) :. Subword) ((Int, Int), (Int, Int))
options :: Args
customCheck :: Property -> IO Result
allProps :: IO Bool
