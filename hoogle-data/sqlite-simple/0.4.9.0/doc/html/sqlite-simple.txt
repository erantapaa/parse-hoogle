-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Mid-Level SQLite client library
--   
@package sqlite-simple
@version 0.4.9.0


-- | Adapted from Leon P Smith's code for SQLite.
--   
--   See <a>http://sqlite.org/lang_datefunc.html</a> for date formats used
--   in SQLite.
module Database.SQLite.Simple.Time.Implementation
parseUTCTime :: Text -> Either String UTCTime
parseDay :: Text -> Either String Day

-- | Output YYYY-MM-DD HH:MM:SS with an optional .SSS fraction part.
--   Explicit timezone attribute is not appended as per SQLite3's datetime
--   conventions.
utcTimeToBuilder :: UTCTime -> Builder
dayToBuilder :: Day -> Builder
timeOfDayToBuilder :: TimeOfDay -> Builder
timeZoneToBuilder :: TimeZone -> Builder


-- | Conversions to/from Haskell <tt>UTCTime</tt> and <tt>Day</tt> types
--   for SQLite3. Offers better performance than direct use of time
--   package's 'read'/'show' functionality.
--   
--   The parsers are heavily adapted for the specific variant of ISO 8601
--   that SQLite uses, and the printers attempt to duplicate this syntax.
module Database.SQLite.Simple.Time


-- | The <a>Ok</a> type is a simple error handler, basically equivalent to
--   <tt>Either [SomeException]</tt>.
--   
--   One of the primary reasons why this type was introduced is that
--   <tt>Either SomeException</tt> had not been provided an instance for
--   <a>Alternative</a>, and it would have been a bad idea to provide an
--   orphaned instance for a commonly-used type and typeclass included in
--   <tt>base</tt>.
--   
--   Extending the failure case to a list of <a>SomeException</a>s enables
--   a more sensible <a>Alternative</a> instance definitions:
--   <a>&lt;|&gt;</a> concatinates the list of exceptions when both cases
--   fail, and <a>empty</a> is defined as 'Errors []'. Though
--   <a>&lt;|&gt;</a> one could pick one of two exceptions, and throw away
--   the other, and have <a>empty</a> provide a generic exception, this
--   avoids cases where <a>empty</a> overrides a more informative exception
--   and allows you to see all the different ways your computation has
--   failed.
module Database.SQLite.Simple.Ok
data Ok a
Errors :: [SomeException] -> Ok a
Ok :: !a -> Ok a

-- | Two <a>Errors</a> cases are considered equal, regardless of what the
--   list of exceptions looks like.

-- | a way to reify a list of exceptions into a single exception
newtype ManyErrors
ManyErrors :: [SomeException] -> ManyErrors
instance Typeable Ok
instance Typeable ManyErrors
instance Show a => Show (Ok a)
instance Functor Ok
instance Show ManyErrors
instance Exception ManyErrors
instance Monad Ok
instance MonadPlus Ok
instance Alternative Ok
instance Applicative Ok
instance Eq a => Eq (Ok a)


-- | Internal bits. This interface is less stable and can change at any
--   time. In particular this means that while the rest of the
--   sqlite-simple package endeavors to follow the package versioning
--   policy, this module does not. Also, at the moment there are things in
--   here that aren't particularly internal and are exported elsewhere;
--   these will eventually disappear from this module.
module Database.SQLite.Simple.Internal

-- | Connection to an open database.
--   
--   You can use <a>connectionHandle</a> to gain access to the underlying
--   <a>http://hackage.haskell.org/package/direct-sqlite</a> connection.
--   This may be useful if you need to access some direct-sqlite
--   functionality that's not exposed in the sqlite-simple API. This should
--   be a safe thing to do although mixing both APIs is discouraged.
newtype Connection
Connection :: Database -> Connection
connectionHandle :: Connection -> Database
data ColumnOutOfBounds
ColumnOutOfBounds :: !Int -> ColumnOutOfBounds
errorColumnIndex :: ColumnOutOfBounds -> !Int

-- | A Field represents metadata about a particular field
data Field
Field :: SQLData -> {-# UNPACK #-} !Int -> Field
result :: Field -> SQLData
column :: Field -> {-# UNPACK #-} !Int
newtype RowParseRO
RowParseRO :: Int -> RowParseRO
nColumns :: RowParseRO -> Int
newtype RowParser a
RP :: ReaderT RowParseRO (StateT (Int, [SQLData]) Ok) a -> RowParser a
unRP :: RowParser a -> ReaderT RowParseRO (StateT (Int, [SQLData]) Ok) a
gettypename :: SQLData -> ByteString
instance Typeable ColumnOutOfBounds
instance Eq ColumnOutOfBounds
instance Show ColumnOutOfBounds
instance Functor RowParser
instance Applicative RowParser
instance Alternative RowParser
instance Monad RowParser
instance MonadPlus RowParser
instance Exception ColumnOutOfBounds


-- | Top-level module for sqlite-simple.
module Database.SQLite.Simple.Types

-- | A placeholder for the SQL <tt>NULL</tt> value.
data Null
Null :: Null

-- | A single-value "collection".
--   
--   This is useful if you need to supply a single parameter to a SQL
--   query, or extract a single column from a SQL result.
--   
--   Parameter example:
--   
--   <pre>
--   query c "select x from scores where x &gt; ?" (<a>Only</a> (42::Int))
--   </pre>
--   
--   Result example:
--   
--   <pre>
--   xs &lt;- query_ c "select id from users"
--   forM_ xs $ \(<a>Only</a> id) -&gt; {- ... -}
--   </pre>
newtype Only a
Only :: a -> Only a
fromOnly :: Only a -> a

-- | A query string. This type is intended to make it difficult to
--   construct a SQL query by concatenating string fragments, as that is an
--   extremely common way to accidentally introduce SQL injection
--   vulnerabilities into an application.
--   
--   This type is an instance of <a>IsString</a>, so the easiest way to
--   construct a query is to enable the <tt>OverloadedStrings</tt> language
--   extension and then simply write the query in double quotes.
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   import Database.SQLite.Simple
--   
--   q :: Query
--   q = "select ?"
--   </pre>
--   
--   The underlying type is a <tt>Text</tt>, and literal Haskell strings
--   that contain Unicode characters will be correctly transformed to
--   UTF-8.
newtype Query
Query :: Text -> Query
fromQuery :: Query -> Text

-- | A composite type to parse your custom data structures without having
--   to define dummy newtype wrappers every time.
--   
--   <pre>
--   instance FromRow MyData where ...
--   </pre>
--   
--   <pre>
--   instance FromRow MyData2 where ...
--   </pre>
--   
--   then I can do the following for free:
--   
--   <pre>
--   res &lt;- query' c "..."
--   forM res $ \(MyData{..} :. MyData2{..}) -&gt; do
--     ....
--   </pre>
data (:.) h t
(:.) :: h -> t -> (:.) h t
instance Typeable Null
instance Typeable Query
instance Typeable Only
instance Typeable (:.)
instance Read Null
instance Show Null
instance Eq Query
instance Ord Query
instance Eq a => Eq (Only a)
instance Ord a => Ord (Only a)
instance Read a => Read (Only a)
instance Show a => Show (Only a)
instance Functor Only
instance (Eq h, Eq t) => Eq (h :. t)
instance (Ord h, Ord t) => Ord (h :. t)
instance (Show h, Show t) => Show (h :. t)
instance (Read h, Read t) => Read (h :. t)
instance Monoid Query
instance IsString Query
instance Read Query
instance Show Query
instance Eq Null


-- | The <a>FromField</a> typeclass, for converting a single value in a row
--   returned by a SQL query into a more useful Haskell representation.
--   
--   A Haskell numeric type is considered to be compatible with all SQLite
--   numeric types that are less accurate than it. For instance, the
--   Haskell <a>Double</a> type is compatible with the SQLite's 32-bit
--   <tt>Int</tt> type because it can represent a <tt>Int</tt> exactly. On
--   the other hand, since a <a>Double</a> might lose precision if
--   representing a 64-bit <tt>BigInt</tt>, the two are <i>not</i>
--   considered compatible.
module Database.SQLite.Simple.FromField

-- | A type that may be converted from a SQL type.
class FromField a
fromField :: FromField a => FieldParser a
type FieldParser a = Field -> Ok a

-- | Exception thrown if conversion from a SQL value to a Haskell value
--   fails.
data ResultError

-- | The SQL and Haskell types are not compatible.
Incompatible :: String -> String -> String -> ResultError
errSQLType :: ResultError -> String
errHaskellType :: ResultError -> String
errMessage :: ResultError -> String

-- | A SQL <tt>NULL</tt> was encountered when the Haskell type did not
--   permit it.
UnexpectedNull :: String -> String -> String -> ResultError
errSQLType :: ResultError -> String
errHaskellType :: ResultError -> String
errMessage :: ResultError -> String

-- | The SQL value could not be parsed, or could not be represented as a
--   valid Haskell value, or an unexpected low-level error occurred (e.g.
--   mismatch between metadata and actual data in a row).
ConversionFailed :: String -> String -> String -> ResultError
errSQLType :: ResultError -> String
errHaskellType :: ResultError -> String
errMessage :: ResultError -> String

-- | A Field represents metadata about a particular field
data Field

-- | Return the actual SQL data for a database field. This allows
--   user-defined <a>FromField</a> instances to access the SQL data
--   associated with a field being parsed.
fieldData :: Field -> SQLData

-- | Given one of the constructors from <a>ResultError</a>, the field, and
--   an <a>errMessage</a>, this fills in the other fields in the exception
--   value and returns it in a 'Left . SomeException' constructor.
returnError :: (Typeable a, Exception err) => (String -> String -> String -> err) -> Field -> String -> Ok a
instance Typeable ResultError
instance Eq ResultError
instance Show ResultError
instance FromField Day
instance FromField UTCTime
instance FromField ByteString
instance FromField ByteString
instance FromField [Char]
instance FromField Text
instance FromField Text
instance FromField Bool
instance FromField Float
instance FromField Double
instance FromField Word
instance FromField Word64
instance FromField Word32
instance FromField Word16
instance FromField Word8
instance FromField Integer
instance FromField Int64
instance FromField Int
instance FromField Int32
instance FromField Int16
instance FromField Int8
instance FromField Null
instance FromField a => FromField (Maybe a)
instance Exception ResultError


-- | The <a>ToField</a> typeclass, for rendering a parameter to an SQLite
--   value to be bound as a SQL query parameter.
module Database.SQLite.Simple.ToField

-- | A type that may be used as a single parameter to a SQL query.
class ToField a
toField :: ToField a => a -> SQLData
instance ToField Day
instance ToField UTCTime
instance ToField Text
instance ToField [Char]
instance ToField Text
instance ToField ByteString
instance ToField ByteString
instance ToField Double
instance ToField Float
instance ToField Word64
instance ToField Word
instance ToField Word32
instance ToField Word16
instance ToField Word8
instance ToField Integer
instance ToField Int64
instance ToField Int
instance ToField Int32
instance ToField Int16
instance ToField Int8
instance ToField Bool
instance ToField Null
instance ToField a => ToField (Maybe a)
instance ToField SQLData


-- | The <a>ToRow</a> typeclass, for rendering a collection of parameters
--   to a SQL query.
--   
--   Predefined instances are provided for tuples containing up to ten
--   elements.
module Database.SQLite.Simple.ToRow

-- | A collection type that can be turned into a list of <a>SQLData</a>
--   elements.
class ToRow a
toRow :: ToRow a => a -> [SQLData]
instance (ToRow a, ToRow b) => ToRow (a :. b)
instance ToField a => ToRow [a]
instance (ToField a, ToField b, ToField c, ToField d, ToField e, ToField f, ToField g, ToField h, ToField i, ToField j) => ToRow (a, b, c, d, e, f, g, h, i, j)
instance (ToField a, ToField b, ToField c, ToField d, ToField e, ToField f, ToField g, ToField h, ToField i) => ToRow (a, b, c, d, e, f, g, h, i)
instance (ToField a, ToField b, ToField c, ToField d, ToField e, ToField f, ToField g, ToField h) => ToRow (a, b, c, d, e, f, g, h)
instance (ToField a, ToField b, ToField c, ToField d, ToField e, ToField f, ToField g) => ToRow (a, b, c, d, e, f, g)
instance (ToField a, ToField b, ToField c, ToField d, ToField e, ToField f) => ToRow (a, b, c, d, e, f)
instance (ToField a, ToField b, ToField c, ToField d, ToField e) => ToRow (a, b, c, d, e)
instance (ToField a, ToField b, ToField c, ToField d) => ToRow (a, b, c, d)
instance (ToField a, ToField b, ToField c) => ToRow (a, b, c)
instance (ToField a, ToField b) => ToRow (a, b)
instance ToField a => ToRow (Only a)
instance ToRow ()


-- | The <a>FromRow</a> typeclass, for converting a row of results returned
--   by a SQL query into a more useful Haskell representation.
--   
--   Predefined instances are provided for tuples containing up to ten
--   elements.
module Database.SQLite.Simple.FromRow

-- | A collection type that can be converted from a sequence of fields.
--   Instances are provided for tuples up to 10 elements and lists of any
--   length.
--   
--   Note that instances can defined outside of sqlite-simple, which is
--   often useful. For example, here's an instance for a user-defined pair:
--   
--   @data User = User { name :: String, fileQuota :: Int }
--   
--   instance <a>FromRow</a> User where fromRow = User &lt;$&gt;
--   <a>field</a> &lt;*&gt; <a>field</a> @
--   
--   The number of calls to <a>field</a> must match the number of fields
--   returned in a single row of the query result. Otherwise, a
--   <a>ConversionFailed</a> exception will be thrown.
--   
--   Note the caveats associated with user-defined implementations of
--   <a>fromRow</a>.
class FromRow a
fromRow :: FromRow a => RowParser a
data RowParser a
field :: FromField a => RowParser a
fieldWith :: FieldParser a -> RowParser a
numFieldsRemaining :: RowParser Int
instance (FromRow a, FromRow b) => FromRow (a :. b)
instance FromField a => FromRow [a]
instance (FromField a, FromField b, FromField c, FromField d, FromField e, FromField f, FromField g, FromField h, FromField i, FromField j) => FromRow (a, b, c, d, e, f, g, h, i, j)
instance (FromField a, FromField b, FromField c, FromField d, FromField e, FromField f, FromField g, FromField h, FromField i) => FromRow (a, b, c, d, e, f, g, h, i)
instance (FromField a, FromField b, FromField c, FromField d, FromField e, FromField f, FromField g, FromField h) => FromRow (a, b, c, d, e, f, g, h)
instance (FromField a, FromField b, FromField c, FromField d, FromField e, FromField f, FromField g) => FromRow (a, b, c, d, e, f, g)
instance (FromField a, FromField b, FromField c, FromField d, FromField e, FromField f) => FromRow (a, b, c, d, e, f)
instance (FromField a, FromField b, FromField c, FromField d, FromField e) => FromRow (a, b, c, d, e)
instance (FromField a, FromField b, FromField c, FromField d) => FromRow (a, b, c, d)
instance (FromField a, FromField b, FromField c) => FromRow (a, b, c)
instance (FromField a, FromField b) => FromRow (a, b)
instance FromField a => FromRow (Only a)


module Database.SQLite.Simple

-- | A query string. This type is intended to make it difficult to
--   construct a SQL query by concatenating string fragments, as that is an
--   extremely common way to accidentally introduce SQL injection
--   vulnerabilities into an application.
--   
--   This type is an instance of <a>IsString</a>, so the easiest way to
--   construct a query is to enable the <tt>OverloadedStrings</tt> language
--   extension and then simply write the query in double quotes.
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   import Database.SQLite.Simple
--   
--   q :: Query
--   q = "select ?"
--   </pre>
--   
--   The underlying type is a <tt>Text</tt>, and literal Haskell strings
--   that contain Unicode characters will be correctly transformed to
--   UTF-8.
newtype Query
Query :: Text -> Query
fromQuery :: Query -> Text

-- | Connection to an open database.
--   
--   You can use <a>connectionHandle</a> to gain access to the underlying
--   <a>http://hackage.haskell.org/package/direct-sqlite</a> connection.
--   This may be useful if you need to access some direct-sqlite
--   functionality that's not exposed in the sqlite-simple API. This should
--   be a safe thing to do although mixing both APIs is discouraged.
newtype Connection
Connection :: Database -> Connection
connectionHandle :: Connection -> Database

-- | A collection type that can be turned into a list of <a>SQLData</a>
--   elements.
class ToRow a
toRow :: ToRow a => a -> [SQLData]

-- | A collection type that can be converted from a sequence of fields.
--   Instances are provided for tuples up to 10 elements and lists of any
--   length.
--   
--   Note that instances can defined outside of sqlite-simple, which is
--   often useful. For example, here's an instance for a user-defined pair:
--   
--   @data User = User { name :: String, fileQuota :: Int }
--   
--   instance <a>FromRow</a> User where fromRow = User &lt;$&gt;
--   <a>field</a> &lt;*&gt; <a>field</a> @
--   
--   The number of calls to <a>field</a> must match the number of fields
--   returned in a single row of the query result. Otherwise, a
--   <a>ConversionFailed</a> exception will be thrown.
--   
--   Note the caveats associated with user-defined implementations of
--   <a>fromRow</a>.
class FromRow a
fromRow :: FromRow a => RowParser a

-- | A single-value "collection".
--   
--   This is useful if you need to supply a single parameter to a SQL
--   query, or extract a single column from a SQL result.
--   
--   Parameter example:
--   
--   <pre>
--   query c "select x from scores where x &gt; ?" (<a>Only</a> (42::Int))
--   </pre>
--   
--   Result example:
--   
--   <pre>
--   xs &lt;- query_ c "select id from users"
--   forM_ xs $ \(<a>Only</a> id) -&gt; {- ... -}
--   </pre>
newtype Only a
Only :: a -> Only a
fromOnly :: Only a -> a

-- | A composite type to parse your custom data structures without having
--   to define dummy newtype wrappers every time.
--   
--   <pre>
--   instance FromRow MyData where ...
--   </pre>
--   
--   <pre>
--   instance FromRow MyData2 where ...
--   </pre>
--   
--   then I can do the following for free:
--   
--   <pre>
--   res &lt;- query' c "..."
--   forM res $ \(MyData{..} :. MyData2{..}) -&gt; do
--     ....
--   </pre>
data (:.) h t
(:.) :: h -> t -> (:.) h t
data SQLData :: *
SQLInteger :: SrictNotUnpackedInt64 -> SQLData
SQLFloat :: SrictNotUnpackedDouble -> SQLData
SQLText :: SrictNotUnpackedText -> SQLData
SQLBlob :: SrictNotUnpackedByteString -> SQLData
SQLNull :: SQLData

-- | An SQLite prepared statement.
data Statement

-- | Index of a column in a result set. Column indices start from 0.
newtype ColumnIndex
ColumnIndex :: ColumnIndex -> ColumnIndex
data NamedParam
(:=) :: Text -> v -> NamedParam

-- | Open a database connection to a given file. Will throw an exception if
--   it cannot connect.
--   
--   Every <a>open</a> must be closed with a call to <a>close</a>.
--   
--   If you specify ":memory:" or an empty string as the input filename,
--   then a private, temporary in-memory database is created for the
--   connection. This database will vanish when you close the connection.
open :: String -> IO Connection

-- | Close a database connection.
close :: Connection -> IO ()

-- | Opens a database connection, executes an action using this connection,
--   and closes the connection, even in the presence of exceptions.
withConnection :: String -> (Connection -> IO a) -> IO a

-- | <a>http://www.sqlite.org/c3ref/profile.html</a>
--   
--   Enable/disable tracing of SQL execution. Tracing can be disabled by
--   setting <a>Nothing</a> as the logger callback.
--   
--   Warning: If the logger callback throws an exception, your whole
--   program may crash. Enable only for debugging!
setTrace :: Connection -> Maybe (Text -> IO ()) -> IO ()

-- | Perform a <tt>SELECT</tt> or other SQL query that is expected to
--   return results. All results are retrieved and converted before this
--   function returns.
--   
--   When processing large results, this function will consume a lot of
--   client-side memory. Consider using <a>fold</a> instead.
--   
--   Exceptions that may be thrown:
--   
--   <ul>
--   <li><a>FormatError</a>: the query string mismatched with given
--   arguments.</li>
--   <li><a>ResultError</a>: result conversion failed.</li>
--   </ul>
query :: (ToRow q, FromRow r) => Connection -> Query -> q -> IO [r]

-- | A version of <a>query</a> that does not perform query substitution.
query_ :: FromRow r => Connection -> Query -> IO [r]

-- | A version of <a>query</a> that does not perform query substitution and
--   takes an explicit <a>RowParser</a>.
queryWith_ :: RowParser r -> Connection -> Query -> IO [r]

-- | A version of <a>query</a> where the query parameters (placeholders)
--   are named.
--   
--   Example:
--   
--   <pre>
--   r &lt;- <a>queryNamed</a> c "SELECT * FROM posts WHERE id=:id AND date&gt;=:date" [":id" <a>:=</a> postId, ":date" <a>:=</a> afterDate]
--   </pre>
queryNamed :: FromRow r => Connection -> Query -> [NamedParam] -> IO [r]

-- | Returns the rowid of the most recent successful INSERT on the given
--   database connection.
--   
--   See also <a>http://www.sqlite.org/c3ref/last_insert_rowid.html</a>.
lastInsertRowId :: Connection -> IO Int64

-- | Perform a <tt>SELECT</tt> or other SQL query that is expected to
--   return results. Results are converted and fed into the <tt>action</tt>
--   callback as they are being retrieved from the database.
--   
--   This allows gives the possibility of processing results in constant
--   space (for instance writing them to disk).
--   
--   Exceptions that may be thrown:
--   
--   <ul>
--   <li><a>FormatError</a>: the query string mismatched with given
--   arguments.</li>
--   <li><a>ResultError</a>: result conversion failed.</li>
--   </ul>
fold :: (FromRow row, ToRow params) => Connection -> Query -> params -> a -> (a -> row -> IO a) -> IO a

-- | A version of <a>fold</a> which does not perform parameter
--   substitution.
fold_ :: FromRow row => Connection -> Query -> a -> (a -> row -> IO a) -> IO a

-- | A version of <a>fold</a> where the query parameters (placeholders) are
--   named.
foldNamed :: FromRow row => Connection -> Query -> [NamedParam] -> a -> (a -> row -> IO a) -> IO a

-- | Execute an <tt>INSERT</tt>, <tt>UPDATE</tt>, or other SQL query that
--   is not expected to return results.
--   
--   Throws <a>FormatError</a> if the query could not be formatted
--   correctly.
execute :: ToRow q => Connection -> Query -> q -> IO ()

-- | A version of <a>execute</a> that does not perform query substitution.
execute_ :: Connection -> Query -> IO ()

-- | A version of <a>execute</a> where the query parameters (placeholders)
--   are named.
executeNamed :: Connection -> Query -> [NamedParam] -> IO ()
field :: FromField a => RowParser a

-- | Run an IO action inside a SQL transaction started with <tt>BEGIN
--   TRANSACTION</tt>. If the action throws any kind of an exception, the
--   transaction will be rolled back with <tt>ROLLBACK TRANSACTION</tt>.
--   Otherwise the results are committed with <tt>COMMIT TRANSACTION</tt>.
withTransaction :: Connection -> IO a -> IO a

-- | Opens a prepared statement. A prepared statement must always be closed
--   with a corresponding call to <a>closeStatement</a> before closing the
--   connection. Use <a>nextRow</a> to iterate on the values returned. Once
--   <a>nextRow</a> returns <a>Nothing</a>, you need to invoke <a>reset</a>
--   before reexecuting the statement again with <a>nextRow</a>.
openStatement :: Connection -> Query -> IO Statement

-- | Closes a prepared statement.
closeStatement :: Statement -> IO ()

-- | Opens a prepared statement, executes an action using this statement,
--   and closes the statement, even in the presence of exceptions.
withStatement :: Connection -> Query -> (Statement -> IO a) -> IO a

-- | Binds parameters to a prepared statement. Once <a>nextRow</a> returns
--   <a>Nothing</a>, the statement must be reset with the <a>reset</a>
--   function before it can be executed again by calling <a>nextRow</a>.
bind :: ToRow params => Statement -> params -> IO ()

-- | Binds named parameters to a prepared statement.
bindNamed :: Statement -> [NamedParam] -> IO ()

-- | Resets a statement. This does not reset bound parameters, if any, but
--   allows the statement to be reexecuted again by invoking
--   <a>nextRow</a>.
reset :: Statement -> IO ()

-- | Return the name of a a particular column in the result set of a
--   <a>Statement</a>. Throws an <a>ArrayException</a> if the colum index
--   is out of bounds.
--   
--   <a>http://www.sqlite.org/c3ref/column_name.html</a>
columnName :: Statement -> ColumnIndex -> IO Text

-- | Binds parameters to a prepared statement, and <a>reset</a>s the
--   statement when the callback completes, even in the presence of
--   exceptions.
--   
--   Use <a>withBind</a> to reuse prepared statements. Because it
--   <a>reset</a>s the statement <i>after</i> each usage, it avoids a
--   pitfall involving implicit transactions. SQLite creates an implicit
--   transaction if you don't say <tt>BEGIN</tt> explicitly, and does not
--   commit it until all active statements are finished with either
--   <a>reset</a> or <a>closeStatement</a>.
withBind :: ToRow params => Statement -> params -> IO a -> IO a

-- | Extracts the next row from the prepared statement.
nextRow :: FromRow r => Statement -> IO (Maybe r)

-- | Exception thrown if a <a>Query</a> was malformed. This may occur if
--   the number of '<tt>?</tt>' characters in the query string does not
--   match the number of parameters provided.
data FormatError
FormatError :: String -> Query -> [String] -> FormatError
fmtMessage :: FormatError -> String
fmtQuery :: FormatError -> Query
fmtParams :: FormatError -> [String]

-- | Exception thrown if conversion from a SQL value to a Haskell value
--   fails.
data ResultError

-- | The SQL and Haskell types are not compatible.
Incompatible :: String -> String -> String -> ResultError
errSQLType :: ResultError -> String
errHaskellType :: ResultError -> String
errMessage :: ResultError -> String

-- | A SQL <tt>NULL</tt> was encountered when the Haskell type did not
--   permit it.
UnexpectedNull :: String -> String -> String -> ResultError
errSQLType :: ResultError -> String
errHaskellType :: ResultError -> String
errMessage :: ResultError -> String

-- | The SQL value could not be parsed, or could not be represented as a
--   valid Haskell value, or an unexpected low-level error occurred (e.g.
--   mismatch between metadata and actual data in a row).
ConversionFailed :: String -> String -> String -> ResultError
errSQLType :: ResultError -> String
errHaskellType :: ResultError -> String
errMessage :: ResultError -> String

-- | Exception thrown when SQLite3 reports an error.
--   
--   direct-sqlite may throw other types of exceptions if you misuse the
--   API.
data SQLError :: *
SQLError :: SrictNotUnpackedError -> Text -> Text -> SQLError

-- | Error code returned by API call
sqlError :: SQLError -> SrictNotUnpackedError

-- | Text describing the error
sqlErrorDetails :: SQLError -> Text

-- | Indicates what action produced this error, e.g. <tt>exec "SELECT *
--   FROM foo"</tt>
sqlErrorContext :: SQLError -> Text
data Error :: *

-- | Successful result
ErrorOK :: Error

-- | SQL error or missing database
ErrorError :: Error

-- | Internal logic error in SQLite
ErrorInternal :: Error

-- | Access permission denied
ErrorPermission :: Error

-- | Callback routine requested an abort
ErrorAbort :: Error

-- | The database file is locked
ErrorBusy :: Error

-- | A table in the database is locked
ErrorLocked :: Error

-- | A <tt>malloc()</tt> failed
ErrorNoMemory :: Error

-- | Attempt to write a readonly database
ErrorReadOnly :: Error

-- | Operation terminated by <tt>sqlite3_interrupt()</tt>
ErrorInterrupt :: Error

-- | Some kind of disk I/O error occurred
ErrorIO :: Error

-- | The database disk image is malformed
ErrorCorrupt :: Error

-- | Unknown opcode in <tt>sqlite3_file_control()</tt>
ErrorNotFound :: Error

-- | Insertion failed because database is full
ErrorFull :: Error

-- | Unable to open the database file
ErrorCan'tOpen :: Error

-- | Database lock protocol error
ErrorProtocol :: Error

-- | Database is empty
ErrorEmpty :: Error

-- | The database schema changed
ErrorSchema :: Error

-- | String or BLOB exceeds size limit
ErrorTooBig :: Error

-- | Abort due to constraint violation
ErrorConstraint :: Error

-- | Data type mismatch
ErrorMismatch :: Error

-- | Library used incorrectly
ErrorMisuse :: Error

-- | Uses OS features not supported on host
ErrorNoLargeFileSupport :: Error

-- | Authorization denied
ErrorAuthorization :: Error

-- | Auxiliary database format error
ErrorFormat :: Error

-- | 2nd parameter to sqlite3_bind out of range
ErrorRange :: Error

-- | File opened that is not a database file
ErrorNotADatabase :: Error

-- | <tt>sqlite3_step()</tt> has another row ready
ErrorRow :: Error

-- | <tt>sqlite3_step()</tt> has finished executing
ErrorDone :: Error
instance Typeable FormatError
instance Eq ColumnIndex
instance Ord ColumnIndex
instance Enum ColumnIndex
instance Num ColumnIndex
instance Real ColumnIndex
instance Integral ColumnIndex
instance Eq FormatError
instance Show FormatError
instance Exception FormatError
instance Show NamedParam
