-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Hashing tools
--   
--   Hashing tools
@package hash
@version 0.2.0.1


module Data.Hash.Rolling

-- | Take a <a>ByteString</a> and generate a new <a>ByteString</a> with
--   chunks based on a rolling hash. This generates chunks with an expected
--   size of 8k, where the sizes vary between 128 bytes and 64k each. and
--   the breakpoints are based on moments where a rolling hash function
--   applied to the last 128 bytes of the input matches a mask.
--   
--   This can be used with various chunk hashing schemes to allow hashing
--   that is fairly robust in the presence of inline insertions and
--   deletions.
--   
--   This scheme is based on the standard Rabin-Karp rolling checksum. It
--   is much slower than <tt>rolling</tt>, but is provided here for
--   comparison purposes.
roll' :: ByteString -> ByteString

-- | Take a strict <a>ByteString</a> and generate a new lazy
--   <a>ByteString</a> with chunks based on a rolling hash. This generates
--   chunks with an expected size of 8k, where the sizes vary between 128
--   bytes and 64k each. and the breakpoints are based on moments where a
--   rolling hash function applied to the last 128 bytes of the input
--   matches a mask.
--   
--   This can be used with various chunk hashing schemes to allow hashing
--   that is fairly robust in the presence of inline insertions and
--   deletions.
--   
--   The rolling hash is based on the ideas from <tt>buzhash</tt>, but
--   since we have a known window size that is an integral multiple of the
--   word size we save work.
roll :: ByteString -> ByteString


module Data.Hash.Double

-- | "Less Hashing, Same Performance: Building a Better Bloom Filter" by
--   Kirsch and Mitzenmacher demonstrated that for many use-cases,
--   especially involving Bloom filters, we can use pairwise independent
--   hashes to generate a family of related hash functions with good
--   characteristics.
--   
--   <a>http://www.eecs.harvard.edu/~kirsch/pubs/bbbf/rsa.pdf</a>
--   
--   This stores a pair of hashes.
--   
--   <pre>
--   &gt;&gt;&gt; sip (42 :: Int)^..taking 4 each
--   [-2574874314062730062,-9186383815474761572,2648850756822758536,-3962658744589272970]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sip (42 :: Int)^.ix 3
--   -3962658744589272970
--   </pre>
data Hash
Hash :: {-# UNPACK #-} !Int -> {-# UNPACK #-} !Int -> Hash
sip :: Hashable a => a -> Hash
pepper :: Int
instance Typeable Hash
instance Eq Hash
instance Ord Hash
instance Show Hash
instance Read Hash
instance Data Hash
instance Generic Hash
instance Datatype D1Hash
instance Constructor C1_0Hash
instance (Gettable f, Applicative f) => Each f Hash Hash Int Int
instance Gettable f => Ixed f Hash
instance Gettable f => Contains f Hash


module Data.Hash.CRC32
data CRC32
updated :: Getting (Endo (Endo CRC32)) t Word8 -> t -> CRC32 -> CRC32
final :: CRC32 -> Word32
instance (Reviewable p, Functor f) => Snoc p f CRC32 CRC32 Word8 Word8
instance Default CRC32
