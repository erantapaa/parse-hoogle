-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A tiling window manager
--   
--   This is a modified version of xmonad used by Bluetile.
@package xmonad-bluetilebranch
@version 0.9.1.4


module XMonad.StackSet

-- | A cursor into a non-empty list of workspaces.
--   
--   We puncture the workspace list, producing a hole in the structure used
--   to track the currently focused workspace. The two other lists that are
--   produced are used to track those workspaces visible as Xinerama
--   screens, and those workspaces not visible anywhere.
data StackSet i l a sid sd
StackSet :: !Screen i l a sid sd -> [Screen i l a sid sd] -> [Workspace i l a] -> Map a RationalRect -> StackSet i l a sid sd

-- | currently focused workspace
current :: StackSet i l a sid sd -> !Screen i l a sid sd

-- | non-focused workspaces, visible in xinerama
visible :: StackSet i l a sid sd -> [Screen i l a sid sd]

-- | workspaces not visible anywhere
hidden :: StackSet i l a sid sd -> [Workspace i l a]

-- | floating windows
floating :: StackSet i l a sid sd -> Map a RationalRect

-- | A workspace is just a tag, a layout, and a stack.
data Workspace i l a
Workspace :: !i -> l -> Maybe (Stack a) -> Workspace i l a
tag :: Workspace i l a -> !i
layout :: Workspace i l a -> l
stack :: Workspace i l a -> Maybe (Stack a)

-- | Visible workspaces, and their Xinerama screens.
data Screen i l a sid sd
Screen :: !Workspace i l a -> !sid -> !sd -> Screen i l a sid sd
workspace :: Screen i l a sid sd -> !Workspace i l a
screen :: Screen i l a sid sd -> !sid
screenDetail :: Screen i l a sid sd -> !sd

-- | A stack is a cursor onto a (possibly empty) window list. The data
--   structure tracks focus by construction, and the master window is by
--   convention the top-most item. Focus operations will not reorder the
--   list that results from flattening the cursor. The structure can be
--   envisaged as:
--   
--   <pre>
--      +-- master:  &lt; '7' &gt;
--   up |            [ '2' ]
--      +---------   [ '3' ]
--   focus:          &lt; '4' &gt;
--   dn +----------- [ '8' ]
--   </pre>
--   
--   A <a>Stack</a> can be viewed as a list with a hole punched in it to
--   make the focused position. Under the zipper/calculus view of such
--   structures, it is the differentiation of a [a], and integrating it
--   back has a natural implementation used in <a>index</a>.
data Stack a
Stack :: !a -> [a] -> [a] -> Stack a
focus :: Stack a -> !a
up :: Stack a -> [a]
down :: Stack a -> [a]

-- | A structure for window geometries
data RationalRect
RationalRect :: Rational -> Rational -> Rational -> Rational -> RationalRect

-- | <i>O(n)</i>. Create a new stackset, of empty stacks, with given tags,
--   with physical screens whose descriptions are given by <tt>m</tt>. The
--   number of physical screens (<tt>length <tt>m</tt></tt>) should be less
--   than or equal to the number of workspace tags. The first workspace in
--   the list will be current.
--   
--   Xinerama: Virtual workspaces are assigned to physical screens,
--   starting at 0.
new :: Integral s => l -> [i] -> [sd] -> StackSet i l a s sd

-- | <i>O(w)</i>. Set focus to the workspace with index 'i'. If the index
--   is out of range, return the original <a>StackSet</a>.
--   
--   Xinerama: If the workspace is not visible on any Xinerama screen, it
--   becomes the current screen. If it is in the visible list, it becomes
--   current.
view :: (Eq s, Eq i) => i -> StackSet i l a s sd -> StackSet i l a s sd

-- | Set focus to the given workspace. If that workspace does not exist in
--   the stackset, the original workspace is returned. If that workspace is
--   <a>hidden</a>, then display that workspace on the current screen, and
--   move the current workspace to <a>hidden</a>. If that workspace is
--   <a>visible</a> on another screen, the workspaces of the current screen
--   and the other screen are swapped.
greedyView :: (Eq s, Eq i) => i -> StackSet i l a s sd -> StackSet i l a s sd

-- | Find the tag of the workspace visible on Xinerama screen <tt>sc</tt>.
--   <a>Nothing</a> if screen is out of bounds.
lookupWorkspace :: Eq s => s -> StackSet i l a s sd -> Maybe i

-- | Get a list of all screens in the <a>StackSet</a>.
screens :: StackSet i l a s sd -> [Screen i l a s sd]

-- | Get a list of all workspaces in the <a>StackSet</a>.
workspaces :: StackSet i l a s sd -> [Workspace i l a]

-- | Get a list of all windows in the <a>StackSet</a> in no particular
--   order
allWindows :: Eq a => StackSet i l a s sd -> [a]

-- | Get the tag of the currently focused workspace.
currentTag :: StackSet i l a s sd -> i

-- | <i>O(1)</i>. Extract the focused element of the current stack. Return
--   <a>Just</a> that element, or <a>Nothing</a> for an empty stack.
peek :: StackSet i l a s sd -> Maybe a

-- | <i>O(s)</i>. Extract the stack on the current workspace, as a list.
--   The order of the stack is determined by the master window -- it will
--   be the head of the list. The implementation is given by the natural
--   integration of a one-hole list cursor, back to a list.
index :: StackSet i l a s sd -> [a]

-- | <i>O(n)</i>. Flatten a <a>Stack</a> into a list.
integrate :: Stack a -> [a]

-- | <i>O(n)</i> Flatten a possibly empty stack into a list.
integrate' :: Maybe (Stack a) -> [a]

-- | <i>O(n)</i>. Turn a list into a possibly empty stack (i.e., a zipper):
--   the first element of the list is current, and the rest of the list is
--   down.
differentiate :: [a] -> Maybe (Stack a)
focusUp :: StackSet i l a s sd -> StackSet i l a s sd

-- | <i>O(1), O(w) on the wrapping case</i>.
--   
--   focusUp, focusDown. Move the window focus up or down the stack,
--   wrapping if we reach the end. The wrapping should model a <a>cycle</a>
--   on the current stack. The <tt>master</tt> window, and window order,
--   are unaffected by movement of focus.
--   
--   swapUp, swapDown, swap the neighbour in the stack ordering, wrapping
--   if we reach the end. Again the wrapping model should <a>cycle</a> on
--   the current stack.
focusDown :: StackSet i l a s sd -> StackSet i l a s sd
focusUp' :: Stack a -> Stack a

-- | Variants of <a>focusUp</a> and <a>focusDown</a> that work on a
--   <a>Stack</a> rather than an entire <a>StackSet</a>.
focusDown' :: Stack a -> Stack a

-- | <i>O(s)</i>. Set focus to the master window.
focusMaster :: StackSet i l a s sd -> StackSet i l a s sd

-- | <i>O(1) on current window, O(n) in general</i>. Focus the window
--   <tt>w</tt>, and set its workspace as current.
focusWindow :: (Eq s, Eq a, Eq i) => a -> StackSet i l a s sd -> StackSet i l a s sd

-- | Is the given tag present in the <a>StackSet</a>?
tagMember :: Eq i => i -> StackSet i l a s sd -> Bool

-- | Rename a given tag if present in the <a>StackSet</a>.
renameTag :: Eq i => i -> i -> StackSet i l a s sd -> StackSet i l a s sd

-- | Ensure that a given set of workspace tags is present by renaming
--   existing workspaces and/or creating new hidden workspaces as
--   necessary.
ensureTags :: Eq i => l -> [i] -> StackSet i l a s sd -> StackSet i l a s sd

-- | <i>O(n)</i>. Is a window in the <a>StackSet</a>?
member :: Eq a => a -> StackSet i l a s sd -> Bool

-- | <i>O(1) on current window, O(n) in general</i>. Return <a>Just</a> the
--   workspace tag of the given window, or <a>Nothing</a> if the window is
--   not in the <a>StackSet</a>.
findTag :: Eq a => a -> StackSet i l a s sd -> Maybe i

-- | Map a function on all the workspaces in the <a>StackSet</a>.
mapWorkspace :: (Workspace i l a -> Workspace i l a) -> StackSet i l a s sd -> StackSet i l a s sd

-- | Map a function on all the layouts in the <a>StackSet</a>.
mapLayout :: (l -> l') -> StackSet i l a s sd -> StackSet i l' a s sd

-- | <i>O(n)</i>. (Complexity due to duplicate check). Insert a new element
--   into the stack, above the currently focused element. The new element
--   is given focus; the previously focused element is moved down.
--   
--   If the element is already in the stackset, the original stackset is
--   returned unmodified.
--   
--   Semantics in Huet's paper is that insert doesn't move the cursor.
--   However, we choose to insert above, and move the focus.
insertUp :: Eq a => a -> StackSet i l a s sd -> StackSet i l a s sd

-- | <i>O(1) on current window, O(n) in general</i>. Delete window
--   <tt>w</tt> if it exists. There are 4 cases to consider:
--   
--   <ul>
--   <li>delete on an <a>Nothing</a> workspace leaves it Nothing</li>
--   <li>otherwise, try to move focus to the down</li>
--   <li>otherwise, try to move focus to the up</li>
--   <li>otherwise, you've got an empty workspace, becomes
--   <a>Nothing</a></li>
--   </ul>
--   
--   Behaviour with respect to the master:
--   
--   <ul>
--   <li>deleting the master window resets it to the newly focused
--   window</li>
--   <li>otherwise, delete doesn't affect the master.</li>
--   </ul>
delete :: (Ord a, Eq s) => a -> StackSet i l a s sd -> StackSet i l a s sd

-- | Only temporarily remove the window from the stack, thereby not
--   destroying special information saved in the <tt>Stackset</tt>
delete' :: (Eq a, Eq s) => a -> StackSet i l a s sd -> StackSet i l a s sd

-- | <i>O(n)</i>. 'filter p s' returns the elements of <tt>s</tt> such that
--   <tt>p</tt> evaluates to <a>True</a>. Order is preserved, and focus
--   moves as described for <a>delete</a>.
filter :: (a -> Bool) -> Stack a -> Maybe (Stack a)
swapUp :: StackSet i l a s sd -> StackSet i l a s sd
swapDown :: StackSet i l a s sd -> StackSet i l a s sd

-- | <i>O(s)</i>. Set the master window to the focused window. The old
--   master window is swapped in the tiling order with the focused window.
--   Focus stays with the item moved.
swapMaster :: StackSet i l a s sd -> StackSet i l a s sd

-- | <i>O(s)</i>. Set the master window to the focused window. The other
--   windows are kept in order and shifted down on the stack, as if you
--   just hit mod-shift-k a bunch of times. Focus stays with the item
--   moved.
shiftMaster :: StackSet i l a s sd -> StackSet i l a s sd

-- | Apply a function, and a default value for <a>Nothing</a>, to modify
--   the current stack.
modify :: Maybe (Stack a) -> (Stack a -> Maybe (Stack a)) -> StackSet i l a s sd -> StackSet i l a s sd

-- | Apply a function to modify the current stack if it isn't empty, and we
--   don't want to empty it.
modify' :: (Stack a -> Stack a) -> StackSet i l a s sd -> StackSet i l a s sd

-- | Given a window, and its preferred rectangle, set it as floating A
--   floating window should already be managed by the <a>StackSet</a>.
float :: Ord a => a -> RationalRect -> StackSet i l a s sd -> StackSet i l a s sd

-- | Clear the floating status of a window
sink :: Ord a => a -> StackSet i l a s sd -> StackSet i l a s sd

-- | <i>O(w)</i>. shift. Move the focused element of the current stack to
--   stack <tt>n</tt>, leaving it as the focused element on that stack. The
--   item is inserted above the currently focused element on that
--   workspace. The actual focused workspace doesn't change. If there is no
--   element on the current stack, the original stackSet is returned.
shift :: (Ord a, Eq s, Eq i) => i -> StackSet i l a s sd -> StackSet i l a s sd

-- | <i>O(n)</i>. shiftWin. Searches for the specified window <tt>w</tt> on
--   all workspaces of the stackSet and moves it to stack <tt>n</tt>,
--   leaving it as the focused element on that stack. The item is inserted
--   above the currently focused element on that workspace. The actual
--   focused workspace doesn't change. If the window is not found in the
--   stackSet, the original stackSet is returned.
shiftWin :: (Ord a, Eq a, Eq s, Eq i) => i -> a -> StackSet i l a s sd -> StackSet i l a s sd

-- | this function indicates to catch that an error is expected
abort :: String -> a
instance Show a => Show (Stack a)
instance Read a => Read (Stack a)
instance Eq a => Eq (Stack a)
instance Show RationalRect
instance Read RationalRect
instance Eq RationalRect
instance (Show i, Show l, Show a) => Show (Workspace i l a)
instance (Read i, Read l, Read a) => Read (Workspace i l a)
instance (Eq i, Eq l, Eq a) => Eq (Workspace i l a)
instance (Show i, Show l, Show a, Show sid, Show sd) => Show (Screen i l a sid sd)
instance (Read i, Read l, Read a, Read sid, Read sd) => Read (Screen i l a sid sd)
instance (Eq i, Eq l, Eq a, Eq sid, Eq sd) => Eq (Screen i l a sid sd)
instance (Show i, Show l, Show a, Show sid, Show sd) => Show (StackSet i l a sid sd)
instance (Ord a, Read i, Read l, Read a, Read sid, Read sd) => Read (StackSet i l a sid sd)
instance (Eq i, Eq l, Eq a, Eq sid, Eq sd) => Eq (StackSet i l a sid sd)


-- | The <a>X</a> monad, a state monad transformer over <a>IO</a>, for the
--   window manager state, and support routines.
module XMonad.Core

-- | The X monad, <a>ReaderT</a> and <a>StateT</a> transformers over
--   <a>IO</a> encapsulating the window manager configuration and state,
--   respectively.
--   
--   Dynamic components may be retrieved with <a>get</a>, static components
--   with <a>ask</a>. With newtype deriving we get readers and state monads
--   instantiated on <a>XConf</a> and <a>XState</a> automatically.
data X a
type WindowSet = StackSet WorkspaceId (Layout Window) Window ScreenId ScreenDetail
type WindowSpace = Workspace WorkspaceId (Layout Window) Window

-- | Virtual workspace indices
type WorkspaceId = String

-- | Physical screen indices
newtype ScreenId
S :: Int -> ScreenId

-- | The <a>Rectangle</a> with screen dimensions
data ScreenDetail
SD :: !Rectangle -> ScreenDetail
screenRect :: ScreenDetail -> !Rectangle

-- | XState, the (mutable) window manager state.
data XState
XState :: !WindowSet -> !Set Window -> !Map Window Int -> !Maybe (Position -> Position -> X (), X ()) -> !KeyMask -> !Map String (Either String StateExtension) -> XState

-- | workspace list
windowset :: XState -> !WindowSet

-- | the Set of mapped windows
mapped :: XState -> !Set Window

-- | the number of expected UnmapEvents
waitingUnmap :: XState -> !Map Window Int
dragging :: XState -> !Maybe (Position -> Position -> X (), X ())

-- | The numlock modifier
numberlockMask :: XState -> !KeyMask

-- | stores custom state information.
--   
--   The module XMonad.Utils.ExtensibleState in xmonad-contrib provides
--   additional information and a simple interface for using this.
extensibleState :: XState -> !Map String (Either String StateExtension)

-- | XConf, the (read-only) window manager configuration.
data XConf
XConf :: Display -> !XConfig Layout -> !Window -> !Pixel -> !Pixel -> !Map (KeyMask, KeySym) (X ()) -> !Map (KeyMask, Button) (Window -> X ()) -> !Bool -> !Maybe (Position, Position) -> XConf

-- | the X11 display
display :: XConf -> Display

-- | initial user configuration
config :: XConf -> !XConfig Layout

-- | the root window
theRoot :: XConf -> !Window

-- | border color of unfocused windows
normalBorder :: XConf -> !Pixel

-- | border color of the focused window
focusedBorder :: XConf -> !Pixel

-- | a mapping of key presses to actions
keyActions :: XConf -> !Map (KeyMask, KeySym) (X ())

-- | a mapping of button presses to actions
buttonActions :: XConf -> !Map (KeyMask, Button) (Window -> X ())

-- | was refocus caused by mouse action?
mouseFocused :: XConf -> !Bool

-- | position of the mouse according to the event currently being processed
mousePosition :: XConf -> !Maybe (Position, Position)
data XConfig l
XConfig :: !String -> !String -> !String -> !l Window -> !ManageHook -> !Event -> X All -> ![String] -> !KeyMask -> !XConfig Layout -> Map (ButtonMask, KeySym) (X ()) -> !XConfig Layout -> Map (ButtonMask, Button) (Window -> X ()) -> !Dimension -> !X () -> !X () -> !Bool -> XConfig l

-- | Non focused windows border color. Default: "#dddddd"
normalBorderColor :: XConfig l -> !String

-- | Focused windows border color. Default: "#ff0000"
focusedBorderColor :: XConfig l -> !String

-- | The preferred terminal application. Default: "xterm"
terminal :: XConfig l -> !String

-- | The available layouts
layoutHook :: XConfig l -> !l Window

-- | The action to run when a new window is opened
manageHook :: XConfig l -> !ManageHook

-- | Handle an X event, returns (All True) if the default handler should
--   also be run afterwards. mappend should be used for combining event
--   hooks in most cases.
handleEventHook :: XConfig l -> !Event -> X All

-- | The list of workspaces' names
workspaces :: XConfig l -> ![String]

-- | the mod modifier
modMask :: XConfig l -> !KeyMask

-- | The key binding: a map from key presses and actions
keys :: XConfig l -> !XConfig Layout -> Map (ButtonMask, KeySym) (X ())

-- | The mouse bindings
mouseBindings :: XConfig l -> !XConfig Layout -> Map (ButtonMask, Button) (Window -> X ())

-- | The border width
borderWidth :: XConfig l -> !Dimension

-- | The action to perform when the windows set is changed
logHook :: XConfig l -> !X ()

-- | The action to perform on startup
startupHook :: XConfig l -> !X ()

-- | Whether window entry events can change focus
focusFollowsMouse :: XConfig l -> !Bool

-- | Every layout must be an instance of <a>LayoutClass</a>, which defines
--   the basic layout operations along with a sensible default for each.
--   
--   Minimal complete definition:
--   
--   <ul>
--   <li><a>runLayout</a> || ((<a>doLayout</a> || <a>pureLayout</a>)
--   &amp;&amp; <a>emptyLayout</a>), and</li>
--   <li><a>handleMessage</a> || <a>pureMessage</a></li>
--   </ul>
--   
--   You should also strongly consider implementing <a>description</a>,
--   although it is not required.
--   
--   Note that any code which <i>uses</i> <a>LayoutClass</a> methods should
--   only ever call <a>runLayout</a>, <a>handleMessage</a>, and
--   <a>description</a>! In other words, the only calls to <a>doLayout</a>,
--   <a>pureMessage</a>, and other such methods should be from the default
--   implementations of <a>runLayout</a>, <a>handleMessage</a>, and so on.
--   This ensures that the proper methods will be used, regardless of the
--   particular methods that any <a>LayoutClass</a> instance chooses to
--   define.
class Show (layout a) => LayoutClass layout a
runLayout :: LayoutClass layout a => Workspace WorkspaceId (layout a) a -> Rectangle -> X ([(a, Rectangle)], Maybe (layout a))
doLayout :: LayoutClass layout a => layout a -> Rectangle -> Stack a -> X ([(a, Rectangle)], Maybe (layout a))
pureLayout :: LayoutClass layout a => layout a -> Rectangle -> Stack a -> [(a, Rectangle)]
emptyLayout :: LayoutClass layout a => layout a -> Rectangle -> X ([(a, Rectangle)], Maybe (layout a))
handleMessage :: LayoutClass layout a => layout a -> SomeMessage -> X (Maybe (layout a))
pureMessage :: LayoutClass layout a => layout a -> SomeMessage -> Maybe (layout a)
description :: LayoutClass layout a => layout a -> String

-- | An existential type that can hold any object that is in <a>Read</a>
--   and <a>LayoutClass</a>.
data Layout a
Layout :: (l a) -> Layout a

-- | Using the <a>Layout</a> as a witness, parse existentially wrapped
--   windows from a <a>String</a>.
readsLayout :: Layout a -> String -> [(Layout a, String)]

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class Typeable a

-- | Based on ideas in /An Extensible Dynamically-Typed Hierarchy of
--   Exceptions/, Simon Marlow, 2006. Use extensible messages to the
--   <a>handleMessage</a> handler.
--   
--   User-extensible messages must be a member of this class.
class Typeable a => Message a

-- | A wrapped value of some type in the <a>Message</a> class.
data SomeMessage
SomeMessage :: a -> SomeMessage

-- | And now, unwrap a given, unknown <a>Message</a> type, performing a
--   (dynamic) type check on the result.
fromMessage :: Message m => SomeMessage -> Maybe m

-- | <a>LayoutMessages</a> are core messages that all layouts (especially
--   stateful layouts) should consider handling.
data LayoutMessages

-- | sent when a layout becomes non-visible
Hide :: LayoutMessages

-- | sent when xmonad is exiting or restarting
ReleaseResources :: LayoutMessages

-- | Existential type to store a state extension.
data StateExtension

-- | Non-persistent state extension
StateExtension :: a -> StateExtension

-- | Persistent extension
PersistentExtension :: a -> StateExtension

-- | Every module must make the data it wants to store an instance of this
--   class.
--   
--   Minimal complete definition: initialValue
class Typeable a => ExtensionClass a
initialValue :: ExtensionClass a => a
extensionType :: ExtensionClass a => a -> StateExtension

-- | Run the <a>X</a> monad, given a chunk of <a>X</a> monad code, and an
--   initial state Return the result, and final state
runX :: XConf -> XState -> X a -> IO (a, XState)

-- | Run in the <a>X</a> monad, and in case of exception, and catch it and
--   log it to stderr, and run the error case.
catchX :: X a -> X a -> X a

-- | Execute the argument, catching all exceptions. Either this function or
--   <a>catchX</a> should be used at all callsites of user customized code.
userCode :: X a -> X (Maybe a)

-- | Same as userCode but with a default argument to return instead of
--   using Maybe, provided for convenience.
userCodeDef :: a -> X a -> X a

-- | General utilities
--   
--   Lift an <a>IO</a> action into the <a>X</a> monad
io :: MonadIO m => IO a -> m a

-- | Lift an <a>IO</a> action into the <a>X</a> monad. If the action
--   results in an <a>IO</a> exception, log the exception to stderr and
--   continue normal execution.
catchIO :: MonadIO m => IO () -> m ()

-- | Ignore SIGPIPE to avoid termination when a pipe is full, and SIGCHLD
--   to avoid zombie processes, and clean up any extant zombie processes.
installSignalHandlers :: MonadIO m => m ()
uninstallSignalHandlers :: MonadIO m => m ()

-- | Run a monad action with the current display settings
withDisplay :: (Display -> X a) -> X a

-- | Run a monadic action with the current stack set
withWindowSet :: (WindowSet -> X a) -> X a

-- | True if the given window is the root window
isRoot :: Window -> X Bool

-- | This is basically a map function, running a function in the <a>X</a>
--   monad on each workspace with the output of that function being the
--   modified workspace.
runOnWorkspaces :: (WindowSpace -> X WindowSpace) -> X ()

-- | Wrapper for the common case of atom internment
getAtom :: String -> X Atom

-- | spawn. Launch an external application. Specifically, it double-forks
--   and runs the <a>String</a> you pass as a command to <i>bin</i>sh.
spawn :: MonadIO m => String -> m ()

-- | Like <a>spawn</a>, but returns the <a>ProcessID</a> of the launched
--   application
spawnPID :: MonadIO m => String -> m ProcessID

-- | A replacement for <a>forkProcess</a> which resets default signal
--   handlers.
xfork :: MonadIO m => IO () -> m ProcessID

-- | Return the path to <tt>~/.xmonad</tt>.
getXMonadDir :: MonadIO m => m String

-- | 'recompile force', recompile <tt>~/.xmonad/xmonad.hs</tt> when any of
--   the following apply:
--   
--   <ul>
--   <li>force is <a>True</a></li>
--   <li>the xmonad executable does not exist</li>
--   <li>the xmonad executable is older than xmonad.hs</li>
--   </ul>
--   
--   The -i flag is used to restrict recompilation to the xmonad.hs file
--   only.
--   
--   Compilation errors (if any) are logged to ~/.xmonad/xmonad.errors. If
--   GHC indicates failure with a non-zero exit code, an xmessage
--   displaying that file is spawned.
--   
--   <a>False</a> is returned if there are compilation errors.
recompile :: MonadIO m => Bool -> m Bool

-- | A <a>trace</a> for the <a>X</a> monad. Logs a string to stderr. The
--   result may be found in your .xsession-errors file
trace :: MonadIO m => String -> m ()

-- | Conditionally run an action, using a <tt>Maybe a</tt> to decide.
whenJust :: Monad m => Maybe a -> (a -> m ()) -> m ()

-- | Conditionally run an action, using a <a>X</a> event to decide
whenX :: X Bool -> X () -> X ()
atom_WM_STATE :: X Atom
atom_WM_PROTOCOLS :: X Atom

-- | Common non-predefined atoms
atom_WM_DELETE_WINDOW :: X Atom
type ManageHook = Query (Endo WindowSet)
newtype Query a
Query :: (ReaderT Window X a) -> Query a
runQuery :: Query a -> Window -> X a
instance Typeable LayoutMessages
instance Typeable1 X
instance Eq LayoutMessages
instance Functor Query
instance Monad Query
instance MonadReader Window Query
instance MonadIO Query
instance Functor X
instance Monad X
instance MonadIO X
instance MonadState XState X
instance MonadReader XConf X
instance Eq ScreenDetail
instance Show ScreenDetail
instance Read ScreenDetail
instance Eq ScreenId
instance Ord ScreenId
instance Show ScreenId
instance Read ScreenId
instance Enum ScreenId
instance Num ScreenId
instance Integral ScreenId
instance Real ScreenId
instance Message LayoutMessages
instance Message Event
instance Show (Layout a)
instance LayoutClass Layout Window
instance Monoid a => Monoid (Query a)
instance Monoid a => Monoid (X a)
instance Applicative X


-- | The collection of core layouts.
module XMonad.Layout

-- | Simple fullscreen mode. Renders the focused window fullscreen.
data Full a
Full :: Full a

-- | The builtin tiling mode of xmonad. Supports <a>Shrink</a>,
--   <a>Expand</a> and <a>IncMasterN</a>.
data Tall a

-- | Default proportion of screen occupied by master pane (default: 1/2)
Tall :: !Int -> !Rational -> !Rational -> Tall a

-- | The default number of windows in the master pane (default: 1)
tallNMaster :: Tall a -> !Int

-- | Percent of screen to increment by when resizing panes (default: 3/100)
tallRatioIncrement :: Tall a -> !Rational
tallRatio :: Tall a -> !Rational

-- | Mirror a layout, compute its 90 degree rotated form.
newtype Mirror l a
Mirror :: (l a) -> Mirror l a

-- | Change the size of the master pane.
data Resize
Shrink :: Resize
Expand :: Resize

-- | Increase the number of clients in the master pane.
data IncMasterN
IncMasterN :: !Int -> IncMasterN

-- | A layout that allows users to switch between various layout options.
data Choose l r a

-- | The layout choice combinator
(|||) :: (LayoutClass l a, LayoutClass r a) => l a -> r a -> Choose l r a

-- | Messages to change the current layout.
data ChangeLayout
FirstLayout :: ChangeLayout
NextLayout :: ChangeLayout

-- | Mirror a rectangle.
mirrorRect :: Rectangle -> Rectangle
splitVertically :: Int -> Rectangle -> [Rectangle]
splitHorizontally :: Int -> Rectangle -> [Rectangle]
splitHorizontallyBy :: RealFrac r => r -> Rectangle -> (Rectangle, Rectangle)
splitVerticallyBy :: RealFrac r => r -> Rectangle -> (Rectangle, Rectangle)

-- | Compute the positions for windows using the default two-pane tiling
--   algorithm.
--   
--   The screen is divided into two panes. All clients are then partioned
--   between these two panes. One pane, the master, by convention has the
--   least number of windows in it.
tile :: Rational -> Rectangle -> Int -> Int -> [Rectangle]
instance Typeable NextNoWrap
instance Typeable ChangeLayout
instance Typeable IncMasterN
instance Typeable Resize
instance Eq NextNoWrap
instance Show NextNoWrap
instance Read LR
instance Show LR
instance Eq LR
instance (Read (l a), Read (r a)) => Read (Choose l r a)
instance (Show (l a), Show (r a)) => Show (Choose l r a)
instance Eq ChangeLayout
instance Show ChangeLayout
instance Show (l a) => Show (Mirror l a)
instance Read (l a) => Read (Mirror l a)
instance Show (Tall a)
instance Read (Tall a)
instance Show (Full a)
instance Read (Full a)
instance (LayoutClass l a, LayoutClass r a) => LayoutClass (Choose l r) a
instance Message NextNoWrap
instance Message ChangeLayout
instance LayoutClass l a => LayoutClass (Mirror l) a
instance LayoutClass Tall a
instance LayoutClass Full a
instance Message IncMasterN
instance Message Resize


-- | Operations.
module XMonad.Operations

-- | Window manager operations manage. Add a new window to be managed in
--   the current workspace. Bring it into focus.
--   
--   Whether the window is already managed, or not, it is mapped, has its
--   border set, and its event mask set.
manage :: Window -> X ()

-- | unmanage. A window no longer exists, remove it from the window list,
--   on whatever workspace it is.
unmanage :: Window -> X ()

-- | Kill the specified window. If we do kill it, we'll get a delete notify
--   back from X.
--   
--   There are two ways to delete a window. Either just kill it, or if it
--   supports the delete protocol, send a delete event (e.g. firefox)
killWindow :: Window -> X ()

-- | Kill the currently focused client.
kill :: X ()

-- | windows. Modify the current window list with a pure function, and
--   refresh
windows :: (WindowSet -> WindowSet) -> X ()

-- | Produce the actual rectangle from a screen and a ratio on that screen.
scaleRationalRect :: Rectangle -> RationalRect -> Rectangle

-- | setWMState. set the WM_STATE property
setWMState :: Window -> Int -> X ()

-- | hide. Hide a window by unmapping it, and setting Iconified.
hide :: Window -> X ()

-- | reveal. Show a window by mapping it and setting Normal this is
--   harmless if the window was already visible
reveal :: Window -> X ()

-- | The client events that xmonad is interested in
clientMask :: EventMask

-- | Set some properties when we initially gain control of a window
setInitialProperties :: Window -> X ()

-- | refresh. Render the currently visible workspaces, as determined by the
--   <tt>StackSet</tt>. Also, set focus to the focused window.
--   
--   This is our <tt>view</tt> operation (MVC), in that it pretty prints
--   our model with X calls.
refresh :: X ()

-- | clearEvents. Remove all events of a given type from the event queue.
clearEvents :: EventMask -> X ()

-- | tileWindow. Moves and resizes w such that it fits inside the given
--   rectangle, including its border.
tileWindow :: Window -> Rectangle -> X ()

-- | Returns <a>True</a> if the first rectangle is contained within, but
--   not equal to the second.
containedIn :: Rectangle -> Rectangle -> Bool

-- | Given a list of screens, remove all duplicated screens and screens
--   that are entirely contained within another.
nubScreens :: [Rectangle] -> [Rectangle]

-- | Cleans the list of screens according to the rules documented for
--   nubScreens.
getCleanedScreenInfo :: MonadIO m => Display -> m [Rectangle]

-- | rescreen. The screen configuration may have changed (due to xrandr),
--   update the state and refresh the screen, and reset the gap.
rescreen :: X ()

-- | setButtonGrab. Tell whether or not to intercept clicks on a given
--   window
setButtonGrab :: Bool -> Window -> X ()

-- | Set the focus to the window on top of the stack, or root
setTopFocus :: X ()

-- | Set focus explicitly to window <tt>w</tt> if it is managed by us, or
--   root. This happens if X notices we've moved the mouse (and perhaps
--   moved the mouse to a new screen).
focus :: Window -> X ()

-- | Call X to set the keyboard focus details.
setFocusX :: Window -> X ()

-- | Throw a message to the current <a>LayoutClass</a> possibly modifying
--   how we layout the windows, then refresh.
sendMessage :: Message a => a -> X ()

-- | Send a message to all layouts, without refreshing.
broadcastMessage :: Message a => a -> X ()

-- | Send a message to a layout, without refreshing.
sendMessageWithNoRefresh :: Message a => a -> Workspace WorkspaceId (Layout Window) Window -> X ()

-- | Update the layout field of a workspace
updateLayout :: WorkspaceId -> Maybe (Layout Window) -> X ()

-- | Set the layout of the currently viewed workspace
setLayout :: Layout Window -> X ()

-- | Return workspace visible on screen <tt>sc</tt>, or <a>Nothing</a>.
screenWorkspace :: ScreenId -> X (Maybe WorkspaceId)

-- | Apply an <a>X</a> operation to the currently focused window, if there
--   is one.
withFocused :: (Window -> X ()) -> X ()

-- | <a>True</a> if window is under management by us
isClient :: Window -> X Bool

-- | Combinations of extra modifier masks we need to grab keys/buttons for.
--   (numlock and capslock)
extraModifiers :: X [KeyMask]

-- | Strip numlock/capslock from a mask
cleanMask :: KeyMask -> X KeyMask

-- | Get the <a>Pixel</a> value for a named color
initColor :: Display -> String -> IO (Maybe Pixel)

-- | <tt>restart name resume</tt>. Attempt to restart xmonad by executing
--   the program <tt>name</tt>. If <tt>resume</tt> is <a>True</a>, restart
--   with the current window state. When executing another window manager,
--   <tt>resume</tt> should be <a>False</a>.
restart :: String -> Bool -> X ()

-- | Floating layer support
--   
--   Given a window, find the screen it is located on, and compute the
--   geometry of that window wrt. that screen.
floatLocation :: Window -> X (ScreenId, RationalRect)

-- | Given a point, determine the screen (if any) that contains it.
pointScreen :: Position -> Position -> X (Maybe (Screen WorkspaceId (Layout Window) Window ScreenId ScreenDetail))

-- | <tt>pointWithin x y r</tt> returns <a>True</a> if the <tt>(x, y)</tt>
--   co-ordinate is within <tt>r</tt>.
pointWithin :: Position -> Position -> Rectangle -> Bool

-- | Make a tiled window floating, using its suggested rectangle
float :: Window -> X ()

-- | Accumulate mouse motion events
mouseDrag :: (Position -> Position -> X ()) -> X () -> X ()

-- | XXX comment me
mouseMoveWindow :: Window -> X ()

-- | XXX comment me
mouseResizeWindow :: Window -> X ()

-- | Support for window size hints
type D = (Dimension, Dimension)

-- | Given a window, build an adjuster function that will reduce the given
--   dimensions according to the window's border width and size hints.
mkAdjust :: Window -> X (D -> D)

-- | Reduce the dimensions if needed to comply to the given SizeHints,
--   taking window borders into account.
applySizeHints :: Integral a => Dimension -> SizeHints -> (a, a) -> D

-- | Reduce the dimensions if needed to comply to the given SizeHints.
applySizeHintsContents :: Integral a => SizeHints -> (a, a) -> D

-- | XXX comment me
applySizeHints' :: SizeHints -> D -> D

-- | Reduce the dimensions so their aspect ratio falls between the two
--   given aspect ratios.
applyAspectHint :: (D, D) -> D -> D

-- | Reduce the dimensions so they are a multiple of the size increments.
applyResizeIncHint :: D -> D -> D

-- | Reduce the dimensions if they exceed the given maximum dimensions.
applyMaxSizeHint :: D -> D -> D


-- | An EDSL for ManageHooks
module XMonad.ManageHook

-- | Lift an <a>X</a> action to a <a>Query</a>.
liftX :: X a -> Query a

-- | The identity hook that returns the WindowSet unchanged.
idHook :: ManageHook

-- | Infix <a>mappend</a>. Compose two <a>ManageHook</a> from right to
--   left.
(<+>) :: Monoid m => m -> m -> m

-- | Compose the list of <a>ManageHook</a>s.
composeAll :: [ManageHook] -> ManageHook

-- | <tt>p --&gt; x</tt>. If <tt>p</tt> returns <a>True</a>, execute the
--   <a>ManageHook</a>.
(-->) :: Query Bool -> ManageHook -> ManageHook

-- | <tt>q =? x</tt>. if the result of <tt>q</tt> equals <tt>x</tt>, return
--   <a>True</a>.
(=?) :: Eq a => Query a -> a -> Query Bool

-- | <a>&amp;&amp;</a> lifted to a <a>Monad</a>.
(<&&>) :: Monad m => m Bool -> m Bool -> m Bool

-- | <a>||</a> lifted to a <a>Monad</a>.
(<||>) :: Monad m => m Bool -> m Bool -> m Bool

-- | Return the window title.
title :: Query String

-- | Return the application name.
appName :: Query String

-- | Backwards compatible alias for <a>appName</a>.
resource :: Query String

-- | Return the resource class.
className :: Query String

-- | A query that can return an arbitrary X property of type <a>String</a>,
--   identified by name.
stringProperty :: String -> Query String
getStringProperty :: Display -> Window -> String -> X (Maybe String)

-- | Modify the <a>WindowSet</a> with a pure function.
doF :: (WindowSet -> WindowSet) -> ManageHook

-- | Move the window to the floating layer.
doFloat :: ManageHook

-- | Map the window and remove it from the <a>WindowSet</a>.
doIgnore :: ManageHook

-- | Move the window to a given workspace
doShift :: WorkspaceId -> ManageHook


-- | This module specifies the default configuration values for xmonad.
--   
--   DO NOT MODIFY THIS FILE! It won't work. You may configure xmonad by
--   providing your own <tt>~/.xmonad/xmonad.hs</tt> that overrides
--   specific fields in <a>defaultConfig</a>. For a starting point, you can
--   copy the <tt>xmonad.hs</tt> found in the <tt>man</tt> directory, or
--   look at examples on the xmonad wiki.
module XMonad.Config
defaultConfig :: XConfig (Choose Tall (Choose (Mirror Tall) Full))


-- | xmonad, a minimalist, tiling window manager for X11
module XMonad.Main

-- | The main entry point
xmonad :: (LayoutClass l Window, Read (l Window)) => XConfig l -> IO ()


module XMonad

-- | Bitwise "or"
(.|.) :: Bits a => a -> a -> a
class Monad m => MonadState s m :: (* -> *) | m -> s
get :: MonadState s m => m s
put :: MonadState s m => s -> m ()

-- | Gets specific component of the state, using a projection function
--   supplied.
gets :: MonadState s m => (s -> a) -> m a

-- | Monadic state transformer.
--   
--   Maps an old state to a new state inside a state monad. The old state
--   is thrown away.
--   
--   <pre>
--   Main&gt; :t modify ((+1) :: Int -&gt; Int)
--   modify (...) :: (MonadState Int a) =&gt; a ()
--   </pre>
--   
--   This says that <tt>modify (+1)</tt> acts over any Monad that is a
--   member of the <tt>MonadState</tt> class, with an <tt>Int</tt> state.
modify :: MonadState s m => (s -> s) -> m ()

-- | See examples in <a>Control.Monad.Reader</a>. Note, the partially
--   applied function type <tt>(-&gt;) r</tt> is a simple reader monad. See
--   the <tt>instance</tt> declaration below.
class Monad m => MonadReader r m :: (* -> *) | m -> r
ask :: MonadReader r m => m r
local :: MonadReader r m => (r -> r) -> m a -> m a

-- | Retrieves a function of the current environment.
asks :: MonadReader r m => (r -> a) -> m a

-- | Monads in which <a>IO</a> computations may be embedded. Any monad
--   built by applying a sequence of monad transformers to the <a>IO</a>
--   monad will be an instance of this class.
--   
--   Instances should satisfy the following laws, which state that
--   <a>liftIO</a> is a transformer of monads:
--   
--   <ul>
--   <li><pre><a>liftIO</a> . <a>return</a> = <a>return</a></pre></li>
--   <li><pre><a>liftIO</a> (m &gt;&gt;= f) = <a>liftIO</a> m &gt;&gt;=
--   (<a>liftIO</a> . f)</pre></li>
--   </ul>
class Monad m => MonadIO m :: (* -> *)
liftIO :: MonadIO m => IO a -> m a
