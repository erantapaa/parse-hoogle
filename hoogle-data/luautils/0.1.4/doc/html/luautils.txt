-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Helpers for Haskell integration with Lua
--   
@package luautils
@version 0.1.4

module Scripting.LuaUtils.Internal.Util

-- | "whileIterateM b f a" will execute action (f a) while (b a) is true
--   and also feed the results back to the next iteration.
whileIterateM :: Monad m => (a -> m Bool) -> (a -> m a) -> a -> m a

-- | Monadic version of the if condition
ifM :: Monad m => m Bool -> m a -> m a -> m a

-- | Bool deconstructor in the spirit of <a>either</a> and <a>maybe</a>
--   Similar to the lambda-if proposal
bool :: a -> a -> Bool -> a
forM_ :: Monad m => [a] -> (a -> m b) -> m ()


-- | This package is an add-on to the <tt>HsLua</tt> package by Gracjan
--   Polak (http:/<i>hackage.haskell.org</i>package/hslua).
--   
--   HsLua only provides a very bare-bones wrapper over the Lua API, and
--   this package is meant to fill in the gap by providing some commonly
--   used features.
--   
--   Currently the following features are provided -
--   
--   <ol>
--   <li><tt>Lua.StackValue</tt> instances for a variety of commonly used
--   datatypes, such as Lists, Tuples, Either, Maybe etc.</li>
--   <li><tt>luaDoString</tt> and <tt>luaDoFile</tt> utility
--   functions.</li>
--   <li>A function to dump the contents of the stack for debugging
--   purposes (<tt>dumpStack</tt>).</li>
--   </ol>
module Scripting.LuaUtils
data BinStackValue t
toBinStackValue :: Binary t => t -> BinStackValue t
fromBinStackValue :: BinStackValue t -> t

-- | Binary push
pushbinary :: Binary a => LuaState -> a -> IO ()

-- | Binary peek
peekbinary :: Binary a => LuaState -> Int -> IO (Maybe a)

-- | Execute a String containing Lua Code
luaDoString :: LuaState -> String -> IO ()

-- | Execute a Lua script file
luaDoFile :: LuaState -> String -> IO ()

-- | Pretty print the contents of the entire Lua stack in a human readable
--   form
dumpStack :: LuaState -> IO ()
instance [overlap ok] Eq t => Eq (BinStackValue t)
instance [overlap ok] (StackValue k, StackValue v, Ord k) => StackValue (Map k v)
instance [overlap ok] (StackValue a, StackValue b, StackValue c, StackValue d, StackValue e, StackValue f, StackValue g, StackValue h) => StackValue (a, b, c, d, e, f, g, h)
instance [overlap ok] (StackValue a, StackValue b, StackValue c, StackValue d, StackValue e, StackValue f, StackValue g) => StackValue (a, b, c, d, e, f, g)
instance [overlap ok] (StackValue a, StackValue b, StackValue c, StackValue d, StackValue e, StackValue f) => StackValue (a, b, c, d, e, f)
instance [overlap ok] (StackValue a, StackValue b, StackValue c, StackValue d, StackValue e) => StackValue (a, b, c, d, e)
instance [overlap ok] (StackValue a, StackValue b, StackValue c, StackValue d) => StackValue (a, b, c, d)
instance [overlap ok] (StackValue a, StackValue b, StackValue c) => StackValue (a, b, c)
instance [overlap ok] (StackValue a, StackValue b) => StackValue (a, b)
instance [overlap ok] (StackValue o1, StackValue o2) => StackValue (Either o1 o2)
instance [overlap ok] StackValue o => StackValue (Maybe o)
instance [overlap ok] StackValue Text
instance [overlap ok] Binary t => StackValue (BinStackValue t)
