-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An extended serialization library on top of "cereal"
--   
--   Provides non-orphan instances for an extended range of types,
--   transformer types and support for mutable data, while reapproaching
--   the naming conventions of "cereal" library. For a streaming frontend
--   over this library see <a>"pipes-cereal-plus"</a>
@package cereal-plus
@version 0.4.0


-- | A monad-transformer over <a>Data.Serialize.Put</a>.
module CerealPlus.Serialize

-- | A serialization monad transformer.
data Serialize m a

-- | Run and get the monad result paired with a bytestring of serialized
--   data.
run :: Monad m => Serialize m a -> m (a, ByteString)

-- | Run and get the monad result paired with a lazy bytestring of
--   serialized data.
runLazy :: Monad m => Serialize m a -> m (a, LazyByteString)

-- | Run and get a bytestring of serialized data.
exec :: Monad m => Serialize m a -> m ByteString

-- | Run and get a lazy bytestring of serialized data.
execLazy :: Monad m => Serialize m a -> m LazyByteString

-- | Run a <a>Put</a> action of the "cereal" library.
liftPut :: Monad m => Put -> Serialize m ()
instance Functor PutM'
instance Applicative PutM'
instance Monad PutM'
instance Functor m => Functor (Serialize m)
instance Applicative m => Applicative (Serialize m)
instance Monad m => Monad (Serialize m)
instance MonadIO m => MonadIO (Serialize m)
instance MonadTrans Serialize
instance MonadPlus m => MonadPlus (Serialize m)
instance Alternative m => Alternative (Serialize m)
instance Monoid (PutM' ())
instance MFunctor Serialize


-- | A monad-transformer over <a>Data.Serialize.Get</a>.
module CerealPlus.Deserialize

-- | A deserialization monad transformer.
data Deserialize m a

-- | Run on a chunk of data and get a partial result.
runPartial :: Deserialize m a -> ByteString -> m (Result m a)

-- | A partial result of deserialization.
data Result m a

-- | A message describing the deserialization failure and a remaining
--   chunk.
Fail :: Text -> ByteString -> Result m a

-- | A continuation function, which should be supplied with the next chunk.
Partial :: (ByteString -> m (Result m a)) -> Result m a

-- | A deserialized data structure and a remaining chunk.
Done :: a -> ByteString -> Result m a

-- | Run a <a>Get</a> action of the "cereal" library.
liftGet :: Monad m => Get a -> Deserialize m a

-- | Fail with a message.
--   
--   Since there's no consensus on how to implement <tt>catchError</tt> of
--   <tt>MonadError</tt>, we'll go with just this function.
--   
--   It is not implemented as <a>fail</a> because <a>fail</a> is pure evil.
throwError :: Monad m => Text -> Deserialize m a
instance MFunctor Result
instance MFunctor Deserialize
instance Monad m => Functor (Deserialize m)
instance Monad m => Applicative (Deserialize m)
instance MonadIO m => MonadIO (Deserialize m)
instance MonadTrans Deserialize
instance Monad m => Monad (Deserialize m)

module CerealPlus.Serializable

-- | Support for serialization of a data type in a monadic context (e.g.,
--   <a>IO</a>, <a>ST</a>, <a>STM</a>, <a>Identity</a>), meaning that this
--   can be used to provide serialization support for mutable data.
--   
--   To use it in a pure context, refer to <a>Identity</a> monad.
class Serializable m a where serialize = serializeRep . from deserialize = to <$> deserializeRep
serialize :: (Serializable m a, Monad m, Applicative m) => a -> Serialize m ()
deserialize :: (Serializable m a, Monad m, Applicative m) => Deserialize m a
instance Serializable IO a => Serializable IO (TVar a)
instance Serializable STM a => Serializable STM (TVar a)
instance Serializable IO a => Serializable IO (MVar a)
instance Serializable IO a => Serializable IO (IORef a)
instance (Serializable (ST RealWorld) a, Serializable (ST RealWorld) b, Hashable a, Eq a) => Serializable IO (HashTable RealWorld a b)
instance (Serializable (ST RealWorld) a, Serializable (ST RealWorld) b, Hashable a, Eq a) => Serializable IO (HashTable RealWorld a b)
instance (Serializable (ST RealWorld) a, Serializable (ST RealWorld) b, Hashable a, Eq a) => Serializable IO (HashTable RealWorld a b)
instance (Serializable (ST s) a, Serializable (ST s) b, Hashable a, Eq a) => Serializable (ST s) (HashTable s a b)
instance (Serializable (ST s) a, Serializable (ST s) b, Hashable a, Eq a) => Serializable (ST s) (HashTable s a b)
instance (Serializable (ST s) a, Serializable (ST s) b, Hashable a, Eq a) => Serializable (ST s) (HashTable s a b)
instance (Serializable m a, Unbox a) => Serializable m (UVector a)
instance (Serializable m a, Storable a) => Serializable m (SVector a)
instance (Serializable m a, Prim a) => Serializable m (PVector a)
instance Serializable m a => Serializable m (Vector a)
instance (Serializable m e, Serializable m i, IArray UArray e, Ix i) => Serializable m (UArray i e)
instance (Serializable m e, Serializable m i, Ix i) => Serializable m (Array i e)
instance (Serializable m a, Hashable a, Eq a) => Serializable m (HashSet a)
instance (Serializable m a, Serializable m b, Hashable a, Eq a) => Serializable m (HashMap a b)
instance (Serializable m a, Serializable m b, Ord a) => Serializable m (Map a b)
instance Serializable m a => Serializable m (IntMap a)
instance (Serializable m a, Ord a) => Serializable m (Set a)
instance (Serializable m a, Serializable m b, Serializable m c, Serializable m d, Serializable m e) => Serializable m (a, b, c, d, e)
instance (Serializable m a, Serializable m b, Serializable m c, Serializable m d) => Serializable m (a, b, c, d)
instance (Serializable m a, Serializable m b, Serializable m c) => Serializable m (a, b, c)
instance (Serializable m a, Serializable m b) => Serializable m (a, b)
instance Serializable m a => Serializable m (Identity a)
instance Serializable m a => Serializable m (Seq a)
instance Serializable m a => Serializable m [a]
instance Serializable m a => Serializable m (Maybe a)
instance (Serializable m a, Serializable m b) => Serializable m (Either a b)
instance Serializable m a => Serializable m (Tree a)
instance (Serializable m a, Integral a) => Serializable m (Ratio a)
instance Serializable m a => Serializable m (Last a)
instance Serializable m a => Serializable m (First a)
instance Serializable m a => Serializable m (Product a)
instance Serializable m a => Serializable m (Sum a)
instance Serializable m Any
instance Serializable m All
instance Serializable m a => Serializable m (Dual a)
instance Serializable m Ordering
instance Serializable m Bool
instance Serializable m IntSet
instance Serializable m LazyByteString
instance Serializable m ByteString
instance Serializable m ()
instance Serializable m Word64
instance Serializable m Word32
instance Serializable m Word16
instance Serializable m Word8
instance Serializable m Word
instance Serializable m Integer
instance Serializable m Int64
instance Serializable m Int32
instance Serializable m Int16
instance Serializable m Int8
instance Serializable m Int
instance Serializable m Float
instance Serializable m Double
instance Serializable m Char
instance Serializable m AbsoluteTime
instance Serializable m ZonedTime
instance Serializable m LocalTime
instance Serializable m TimeZone
instance Serializable m TimeOfDay
instance Serializable m NominalDiffTime
instance Serializable m UTCTime
instance Serializable m UniversalTime
instance Serializable m DiffTime
instance Serializable m Day
instance Serializable m LazyText
instance Serializable m Text
instance (HasResolution a, Fractional (Fixed a)) => Serializable m (Fixed a)
instance (SerializableRep a m, SerializableRep b m) => SerializableRep (a :+: b) m
instance (SerializableRep a m, SerializableRep b m) => SerializableRep (a :*: b) m
instance Serializable m a => SerializableRep (K1 i a) m
instance SerializableRep a m => SerializableRep (M1 i c a) m
instance SerializableRep U1 m
