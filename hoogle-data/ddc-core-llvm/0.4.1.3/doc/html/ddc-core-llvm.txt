-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Disciplined Disciple Compiler LLVM code generator.
--   
--   Disciplined Disciple Compiler LLVM code generator.
@package ddc-core-llvm
@version 0.4.1.3


-- | Pretty printer instances for the Llvm syntax.
module DDC.Llvm.Pretty

module DDC.Llvm.Syntax

-- | This is a top level container in LLVM.
data Module
Module :: [String] -> [TypeAlias] -> [Global] -> [FunctionDecl] -> [Function] -> [MDecl] -> Module

-- | Comments to include at the start of the module.
modComments :: Module -> [String]

-- | Alias type definitions.
modAliases :: Module -> [TypeAlias]

-- | Global variables to include in the module.
modGlobals :: Module -> [Global]

-- | Functions used in this module but defined in other modules.
modFwdDecls :: Module -> [FunctionDecl]

-- | Functions defined in this module.
modFuncs :: Module -> [Function]

-- | Metdata for alias analysis
modMDecls :: Module -> [MDecl]

-- | Lookup the calling convention for this function, using the forward
--   declarations as well as the function definitions.
lookupCallConv :: String -> Module -> Maybe CallConv

-- | A global mutable variable. Maybe defined or external
data Global
GlobalStatic :: Var -> Static -> Global
GlobalExternal :: Var -> Global

-- | Return the <tt>LlvmType</tt> of the <tt>LMGlobal</tt>
typeOfGlobal :: Global -> Type

-- | Return the <tt>LlvmVar</tt> part of a <tt>LMGlobal</tt>
varOfGlobal :: Global -> Var

-- | Llvm Static Data. These represent the possible global level variables
--   and constants.
data Static

-- | A comment in a static section.
StaticComment :: String -> Static

-- | A static variant of a literal value.
StaticLit :: Lit -> Static

-- | For uninitialised data.
StaticUninitType :: Type -> Static

-- | Defines a static <tt>LMString</tt>.
StaticStr :: String -> Type -> Static

-- | A static array.
StaticArray :: [Static] -> Type -> Static

-- | A static structure type.
StaticStruct :: [Static] -> Type -> Static

-- | A pointer to other data.
StaticPointer :: Var -> Static

-- | Pointer to Pointer conversion.
StaticBitc :: Static -> Type -> Static

-- | Pointer to Integer conversion.
StaticPtoI :: Static -> Type -> Static

-- | Constant addition operation.
StaticAdd :: Static -> Static -> Static

-- | Constant subtraction operation.
StaticSub :: Static -> Static -> Static

-- | Return the <tt>LlvmType</tt> of the <tt>LlvmStatic</tt>.
typeOfStatic :: Static -> Type

-- | An LLVM Function
data FunctionDecl
FunctionDecl :: String -> Linkage -> CallConv -> Type -> ParamListType -> [Param] -> Align -> FunctionDecl

-- | Unique identifier of the function
declName :: FunctionDecl -> String

-- | LinkageType of the function
declLinkage :: FunctionDecl -> Linkage

-- | The calling convention of the function
declCallConv :: FunctionDecl -> CallConv

-- | Type of the returned value
declReturnType :: FunctionDecl -> Type

-- | Indicates if this function uses varargs
declParamListType :: FunctionDecl -> ParamListType

-- | Parameter types and attributes
declParams :: FunctionDecl -> [Param]

-- | Function align value, must be power of 2
declAlign :: FunctionDecl -> Align

-- | Functions can have a fixed amount of parameters, or a variable amount.
data ParamListType

-- | Fixed amount of arguments.
FixedArgs :: ParamListType

-- | Variable amount of arguments.
VarArgs :: ParamListType

-- | Describes a function parameter.
data Param
Param :: Type -> [ParamAttr] -> Param
paramType :: Param -> Type
paramAttrs :: Param -> [ParamAttr]

-- | Alignment.
data Align
AlignNone :: Align
AlignBytes :: Integer -> Align

-- | A LLVM Function
data Function
Function :: FunctionDecl -> [String] -> [FuncAttr] -> Section -> [Block] -> Function

-- | The signature of this declared function.
funDecl :: Function -> FunctionDecl

-- | The function parameter names.
funParams :: Function -> [String]

-- | The function attributes.
funAttrs :: Function -> [FuncAttr]

-- | The section to put the function into,
funSection :: Function -> Section

-- | The body of the functions.
funBlocks :: Function -> [Block]

-- | The section name to put the function in.
data Section

-- | Let the LLVM decide what section to put this in.
SectionAuto :: Section

-- | Put it in this specific section.
SectionSpecific :: String -> Section

-- | A block of LLVM code with an optional annotation.
data Block
Block :: Label -> Seq AnnotInstr -> Block

-- | The code label for this block
blockLabel :: Block -> Label

-- | A list of LlvmStatement's representing the code for this block. This
--   list must end with a control flow statement.
blockInstrs :: Block -> Seq AnnotInstr

-- | Get the set of LLVM variables that this block defines.
defVarsOfBlock :: Block -> Set Var

-- | Block labels.
data Label
Label :: String -> Label

-- | Instructions annotated with metadata.
data AnnotInstr
AnnotInstr :: Instr -> [MDecl] -> AnnotInstr
annotInstr :: AnnotInstr -> Instr
annotMDecl :: AnnotInstr -> [MDecl]

-- | Construct an annotated instruction with no annotations.
annotNil :: Instr -> AnnotInstr

-- | Annotate an instruction with some metadata.
annotWith :: Instr -> [MDecl] -> AnnotInstr

-- | Instructions
data Instr

-- | Comment meta-instruction.
IComment :: [String] -> Instr

-- | Set meta instruction v1 = value. This isn't accepted by the real LLVM
--   compiler. ISet instructions are erased by the <tt>Clean</tt>
--   transform.
ISet :: Var -> Exp -> Instr

-- | No operation. This isn't accepted by the real LLVM compiler. INop
--   instructions are erased by the <tt>Clean</tt> transform.
INop :: Instr
IPhi :: Var -> [(Exp, Label)] -> Instr

-- | Return a result.
IReturn :: (Maybe Exp) -> Instr

-- | Unconditional branch to the target label.
IBranch :: Label -> Instr

-- | Conditional branch.
IBranchIf :: Exp -> Label -> Label -> Instr

-- | Mutliway branch. If scruitniee matches one of the literals in the list
--   then jump to the corresponding label, otherwise jump to the default.
ISwitch :: Exp -> Label -> [(Lit, Label)] -> Instr

-- | Informs the optimizer that instructions after this point are
--   unreachable.
IUnreachable :: Instr
IOp :: Var -> Op -> Exp -> Exp -> Instr

-- | Cast the variable from to the to type. This is an abstraction of three
--   cast operators in Llvm, inttoptr, prttoint and bitcast.
IConv :: Var -> Conv -> Exp -> Instr

-- | Load a value from memory.
ILoad :: Var -> Exp -> Instr

-- | Store a value to memory. First expression gives the destination
--   pointer.
IStore :: Exp -> Exp -> Instr

-- | Integer comparison.
IICmp :: Var -> ICond -> Exp -> Exp -> Instr

-- | Floating-point comparison.
IFCmp :: Var -> FCond -> Exp -> Exp -> Instr

-- | Call a function. Only NoReturn, NoUnwind and ReadNone attributes are
--   valid.
ICall :: (Maybe Var) -> CallType -> (Maybe CallConv) -> Type -> Name -> [Exp] -> [FuncAttr] -> Instr

-- | If this instruction can branch to a label then return the possible
--   targets.
branchTargetsOfInstr :: Instr -> Maybe (Set Label)

-- | Get the LLVM variable that this instruction assigns to, or
--   <a>Nothing</a> if there isn't one.
defVarOfInstr :: Instr -> Maybe Var

-- | Different types of metadata used in LLVM IR e.g. <tt>debug</tt>,
--   <tt>tbaa</tt>, <tt>range</tt>, etc.
data Metadata
Tbaa :: MDNode -> Metadata
Debug :: Metadata

-- | Maps matadata references to metadata nodes e.g. !2 = !{ metadata
--   <a>id</a>, !0, !i11}
data MDecl
MDecl :: MRef -> Metadata -> MDecl
data MRef
MRef :: Int -> MRef
rval :: MDecl -> Metadata

-- | Construct a single tbaa node
tbaaNode :: String -> MRef -> Bool -> Metadata

-- | Llvm Types.
data Type

-- | Void type
TVoid :: Type

-- | An integer with a given width in bits.
TInt :: Integer -> Type

-- | 32-bit floating point
TFloat :: Type

-- | 64-bit floating point
TDouble :: Type

-- | 80 bit (x86 only) floating point
TFloat80 :: Type

-- | 128 bit floating point
TFloat128 :: Type

-- | A block label.
TLabel :: Type

-- | A pointer to another type of thing.
TPointer :: Type -> Type

-- | An array of things.
TArray :: Integer -> Type -> Type

-- | A structure type.
TStruct :: [Type] -> Type

-- | A type alias.
TAlias :: TypeAlias -> Type

-- | Function type, used to create pointers to functions.
TFunction :: FunctionDecl -> Type

-- | A type alias.
data TypeAlias
TypeAlias :: String -> Type -> TypeAlias

-- | Test if the given <tt>LlvmType</tt> is an integer
isInt :: Type -> Bool

-- | Test if the given <tt>LlvmType</tt> is a floating point type
isFloat :: Type -> Bool

-- | Test if the given <tt>LlvmType</tt> is an <tt>LMPointer</tt> construct
isPointer :: Type -> Bool

-- | Calculate the size in bytes of a Type, given the size of pointers.
takeBytesOfType :: Integer -> Type -> Maybe Integer
data Exp

-- | Use of a variable.
XVar :: Var -> Exp

-- | A literal.
XLit :: Lit -> Exp

-- | An undefined value.
XUndef :: Type -> Exp

-- | Take the type of an expression.
typeOfExp :: Exp -> Type

-- | A variable that can be assigned to.
data Var
Var :: Name -> Type -> Var

-- | Yield the name of a var.
nameOfVar :: Var -> Name

-- | Yield the type of a var.
typeOfVar :: Var -> Type

-- | Names of variables.
data Name
NameGlobal :: String -> Name
NameLocal :: String -> Name

-- | Literal data.
data Lit

-- | An integer literal
LitInt :: Type -> Integer -> Lit

-- | A floating-point literal.
LitFloat :: Type -> Double -> Lit

-- | A null pointer literal. Only applicable to pointer types
LitNull :: Type -> Lit

-- | A completely undefined value.
LitUndef :: Type -> Lit

-- | Yield the <a>Type</a> of a <a>Lit</a>.
typeOfLit :: Lit -> Type

-- | Binary arithmetic operators.
data Op

-- | add two integers, floating point or vector values.
OpAdd :: Op

-- | subtract two ...
OpSub :: Op

-- | multiply ..
OpMul :: Op

-- | unsigned integer or vector division.
OpUDiv :: Op

-- | signed integer ..
OpSDiv :: Op

-- | unsigned integer or vector remainder
OpURem :: Op

-- | signed ...
OpSRem :: Op

-- | add two floating point or vector values.
OpFAdd :: Op

-- | subtract two ...
OpFSub :: Op

-- | multiply ...
OpFMul :: Op

-- | divide ...
OpFDiv :: Op

-- | remainder ...
OpFRem :: Op

-- | Left shift.
OpShl :: Op

-- | Logical shift right
OpLShr :: Op

-- | Arithmetic shift right. The most significant bits of the result will
--   be equal to the sign bit of the left operand.
OpAShr :: Op

-- | AND bitwise logical operation.
OpAnd :: Op

-- | OR bitwise logical operation.
OpOr :: Op

-- | XOR bitwise logical operation.
OpXor :: Op

-- | Integer comparison.
data ICond

-- | Equal (Signed and Unsigned)
ICondEq :: ICond

-- | Not equal (Signed and Unsigned)
ICondNe :: ICond

-- | Unsigned greater than
ICondUgt :: ICond

-- | Unsigned greater than or equal
ICondUge :: ICond

-- | Unsigned less than
ICondUlt :: ICond

-- | Unsigned less than or equal
ICondUle :: ICond

-- | Signed greater than
ICondSgt :: ICond

-- | Signed greater than or equal
ICondSge :: ICond

-- | Signed less than
ICondSlt :: ICond

-- | Signed less than or equal
ICondSle :: ICond

-- | Floating point comparison.
data FCond

-- | Always yields false, regardless of operands.
FCondFalse :: FCond

-- | Both operands are not a QNAN and op1 is equal to op2.
FCondOeq :: FCond

-- | Both operands are not a QNAN and op1 is greater than op2.
FCondOgt :: FCond

-- | Both operands are not a QNAN and op1 is greater than or equal to op2.
FCondOge :: FCond

-- | Both operands are not a QNAN and op1 is less than op2.
FCondOlt :: FCond

-- | Both operands are not a QNAN and op1 is less than or equal to op2.
FCondOle :: FCond

-- | Both operands are not a QNAN and op1 is not equal to op2.
FCondOne :: FCond

-- | Both operands are not a QNAN.
FCondOrd :: FCond

-- | Either operand is a QNAN or op1 is equal to op2.
FCondUeq :: FCond

-- | Either operand is a QNAN or op1 is greater than op2.
FCondUgt :: FCond

-- | Either operand is a QNAN or op1 is greater than or equal to op2.
FCondUge :: FCond

-- | Either operand is a QNAN or op1 is less than op2.
FCondUlt :: FCond

-- | Either operand is a QNAN or op1 is less than or equal to op2.
FCondUle :: FCond

-- | Either operand is a QNAN or op1 is not equal to op2.
FCondUne :: FCond

-- | Either operand is a QNAN.
FCondUno :: FCond

-- | Always yields true, regardless of operands.
FCondTrue :: FCond

-- | Conversion Operations
data Conv

-- | Integer truncate
ConvTrunc :: Conv

-- | Integer extend (zero fill)
ConvZext :: Conv

-- | Integer extend (sign fill)
ConvSext :: Conv

-- | Float truncate
ConvFptrunc :: Conv

-- | Float extend
ConvFpext :: Conv

-- | Float to unsigned Integer
ConvFptoui :: Conv

-- | Float to signed Integer
ConvFptosi :: Conv

-- | Unsigned Integer to Float
ConvUintofp :: Conv

-- | Signed Int to Float
ConvSintofp :: Conv

-- | Pointer to Integer
ConvPtrtoint :: Conv

-- | Integer to Pointer
ConvInttoptr :: Conv

-- | Cast between types where no bit manipulation is needed
ConvBitcast :: Conv

-- | Function attributes are set to communicate additional information
--   about a function. Function attributes are considered to be part of the
--   function, not of the function type, so functions with different
--   parameter attributes can have the same function type. Functions can
--   have multiple attributes.
--   
--   Descriptions taken from
--   <a>http://llvm.org/docs/LangRef.html#fnattrs</a>
data FuncAttr

-- | The inliner should attempt to inline this function into callers
--   whenever possible, ignoring any active inlining size threshold for
--   this caller.
AlwaysInline :: FuncAttr

-- | The source code contained a hint that inlining this function is
--   desirable (such as the "inline" keyword in C/C++). It is just a hint;
--   it imposes no requirements on the inliner.
InlineHint :: FuncAttr

-- | The inliner should never inline this function in any situation. This
--   attribute may not be used together with the alwaysinline attribute.
NoInline :: FuncAttr

-- | Suggests that optimization passes and code generator passes make
--   choices that keep the code size of this function low, and otherwise do
--   optimizations specifically to reduce code size.
OptSize :: FuncAttr

-- | The function never returns normally. This produces undefined behavior
--   at runtime if the function ever does dynamically return.
NoReturn :: FuncAttr

-- | The function never returns with an unwind or exceptional control flow.
--   If the function does unwind, its runtime behavior is undefined.
NoUnwind :: FuncAttr

-- | The function computes its result (or decides to unwind an exception)
--   based strictly on its arguments, without dereferencing any pointer
--   arguments or otherwise accessing any mutable state (e.g. memory,
--   control registers, etc) visible to caller functions. It does not write
--   through any pointer arguments (including byval arguments) and never
--   changes any state visible to callers. This means that it cannot unwind
--   exceptions by calling the C++ exception throwing methods, but could
--   use the unwind instruction.
ReadNone :: FuncAttr

-- | The function does not write through any pointer arguments (including
--   byval arguments) or otherwise modify any state (e.g. memory, control
--   registers, etc) visible to caller functions. It may dereference
--   pointer arguments and read state that may be set in the caller. A
--   readonly function always returns the same value (or unwinds an
--   exception identically) when called with the same set of arguments and
--   global state. It cannot unwind an exception by calling the C++
--   exception throwing methods, but may use the unwind instruction.
ReadOnly :: FuncAttr

-- | The function should emit a stack smashing protector. It is in the form
--   of a "canary"—a random value placed on the stack before the local
--   variables that's checked upon return from the function to see if it
--   has been overwritten. A heuristic is used to determine if a function
--   needs stack protectors or not. If a function that has an ssp attribute
--   is inlined into a function that doesn't have an ssp attribute, then
--   the resulting function will have an ssp attribute.
Ssp :: FuncAttr

-- | The function should always emit a stack smashing protector. This
--   overrides the ssp function attribute. If a function that has an sspreq
--   attribute is inlined into a function that doesn't have an sspreq
--   attribute or which has an ssp attribute, then the resulting function
--   will have an sspreq attribute.
SspReq :: FuncAttr

-- | The code generator should not use a red zone, even if the
--   target-specific ABI normally permits it.
NoRedZone :: FuncAttr

-- | Disables implicit floating point instructions.
NoImplicitFloat :: FuncAttr

-- | Disables prologue / epilogue emission for the function. This can have
--   very system-specific consequences.
Naked :: FuncAttr

-- | Parameter attributes are used to communicate additional information
--   about the result or parameters of a function
data ParamAttr

-- | That the parameter or return value should be zero-extended to a 32-bit
--   value by the caller (for a parameter) or the callee (for a return
--   value).
ZeroExt :: ParamAttr

-- | The parameter or return value should be sign-extended to a 32-bit
--   value by the caller (for a parameter) or the callee (for a return
--   value).
SignExt :: ParamAttr

-- | The parameter or return value should be treated in a special
--   target-dependent fashion during while emitting code for a function
--   call or return (usually, by putting it in a register as opposed to
--   memory).
InReg :: ParamAttr

-- | The pointer parameter should really be passed by value to the
--   function.
ByVal :: ParamAttr

-- | The pointer parameter specifies the address of a structure that is the
--   return value of the function in the source program.
SRet :: ParamAttr

-- | The pointer does not alias any global or any other parameter.
NoAlias :: ParamAttr

-- | The callee does not make any copies of the pointer that outlive the
--   callee itself.
NoCapture :: ParamAttr

-- | The pointer parameter can be excised using the trampoline intrinsics.
Nest :: ParamAttr

-- | Different calling conventions a function can use.
data CallConv

-- | The C calling convention. This calling convention (the default if no
--   other calling convention is specified) matches the target C calling
--   conventions. This calling convention supports varargs function calls
--   and tolerates some mismatch in the declared prototype and implemented
--   declaration of the function (as does normal C).
CC_Ccc :: CallConv

-- | This calling convention attempts to make calls as fast as possible
--   (e.g. by passing things in registers). This calling convention allows
--   the target to use whatever tricks it wants to produce fast code for
--   the target, without having to conform to an externally specified ABI
--   (Application Binary Interface). Implementations of this convention
--   should allow arbitrary tail call optimization to be supported. This
--   calling convention does not support varargs and requires the prototype
--   of al callees to exactly match the prototype of the function
--   definition.
CC_Fastcc :: CallConv

-- | This calling convention attempts to make code in the caller as
--   efficient as possible under the assumption that the call is not
--   commonly executed. As such, these calls often preserve all registers
--   so that the call does not break any live ranges in the caller side.
--   This calling convention does not support varargs and requires the
--   prototype of all callees to exactly match the prototype of the
--   function definition.
CC_Coldcc :: CallConv

-- | Any calling convention may be specified by number, allowing
--   target-specific calling conventions to be used. Target specific
--   calling conventions start at 64.
CC_Ncc :: Int -> CallConv

-- | X86 Specific <tt>StdCall</tt> convention. LLVM includes a specific
--   alias for it rather than just using CC_Ncc.
CC_X86_Stdcc :: CallConv

-- | Different ways to call a function.
data CallType

-- | Normal call, allocate a new stack frame.
CallTypeStd :: CallType

-- | Tail call, perform the call in the current stack frame.
CallTypeTail :: CallType

-- | Linkage type of a symbol.
--   
--   The description of the constructors is copied from the Llvm Assembly
--   Language Reference Manual
--   <a>http://www.llvm.org/docs/LangRef.html#linkage</a>, because they
--   correspond to the Llvm linkage types.
data Linkage

-- | Global values with internal linkage are only directly accessible by
--   objects in the current module. In particular, linking code into a
--   module with an internal global value may cause the internal to be
--   renamed as necessary to avoid collisions. Because the symbol is
--   internal to the module, all references can be updated. This
--   corresponds to the notion of the <tt>static</tt> keyword in C.
Internal :: Linkage

-- | Globals with <tt>linkonce</tt> linkage are merged with other globals
--   of the same name when linkage occurs. This is typically used to
--   implement inline functions, templates, or other code which must be
--   generated in each translation unit that uses it. Unreferenced linkonce
--   globals are allowed to be discarded.
LinkOnce :: Linkage

-- | <tt>weak</tt> linkage is exactly the same as linkonce linkage, except
--   that unreferenced weak globals may not be discarded. This is used for
--   globals that may be emitted in multiple translation units, but that
--   are not guaranteed to be emitted into every translation unit that uses
--   them. One example of this are common globals in C, such as <tt>int
--   X;</tt> at global scope.
Weak :: Linkage

-- | <tt>appending</tt> linkage may only be applied to global variables of
--   pointer to array type. When two global variables with appending
--   linkage are linked together, the two global arrays are appended
--   together. This is the Llvm, typesafe, equivalent of having the system
--   linker append together <tt>sections</tt> with identical names when .o
--   files are linked.
Appending :: Linkage

-- | The semantics of this linkage follow the ELF model: the symbol is weak
--   until linked, if not linked, the symbol becomes null instead of being
--   an undefined reference.
ExternWeak :: Linkage

-- | The symbol participates in linkage and can be used to resolve external
--   symbol references.
ExternallyVisible :: Linkage

-- | Alias for <a>ExternallyVisible</a> but with explicit textual form in
--   LLVM assembly.
External :: Linkage


-- | Inline <a>ISet</a> meta-instructions, drop <a>INop</a>
--   meta-instructions, and propagate calling conventions from declarations
--   to call sites. This should all be part of the LLVM language itself,
--   but it isn't.
module DDC.Llvm.Transform.Clean

-- | Clean a module.
clean :: Module -> Module

module DDC.Llvm.Graph

-- | Llvm block graph. We use this form for transformations, as it makes it
--   easy to find blocks and attach annotations to them.
data Graph a
Graph :: Label -> Map Label (Node a) -> Graph a

-- | The entry node for the block graph.
graphEntry :: Graph a -> Label

-- | Internal nodes.
graphNodes :: Graph a -> Map Label (Node a)

-- | A block of instructions, and an optional annotation.
data Node a
Node :: Label -> Seq AnnotInstr -> a -> Node a

-- | Block label for the node.
nodeLabel :: Node a -> Label

-- | Statements in this node, with meta-data annotations.
nodeInstrs :: Node a -> Seq AnnotInstr

-- | Optional annotation on the node.
nodeAnnot :: Node a -> a

-- | Convert a list of blocks to a block graph.
graphOfBlocks :: a -> [Block] -> Maybe (Graph a)

-- | Flatten a graph back into a list of blocks.
blocksOfGraph :: Graph a -> [Block]

-- | Get the set of all block labels in a graph.
labelsOfGraph :: Graph a -> [Label]

-- | Lookup a node from the graph, or <a>Nothing</a> if it can't be found.
lookupNodeOfGraph :: Graph a -> Label -> Maybe (Node a)

-- | Apply a function to a single node in the graoh.
modifyNodeOfGraph :: Label -> (Node a -> Node a) -> Graph a -> Graph a

-- | Apply a function to every node in the graph.
mapNodesOfGraph :: (Node a -> Node b) -> Graph a -> Graph b

-- | Apply a function to every node annotation in the graph.
mapAnnotsOfGraph :: (a -> b) -> Graph a -> Graph b

-- | Convert a <a>Node</a> to <a>Block</a> form, dropping any annotation.
blockOfNode :: Node a -> Block

-- | Get the children of a node.
childrenOfNode :: Node a -> Set Label
instance Show a => Show (Node a)
instance Show a => Show (Graph a)

module DDC.Llvm.Analysis.Children

-- | The children of a node are the other nodes this one might branch to.
data Children
Children :: (Set Label) -> Children

-- | Annotate a graph with the children of each node.
annotChildrenOfGraph :: Graph a -> Graph (a, Children)

-- | Annotate a node with its children.
annotChildrenOfNode :: Node a -> Node (a, Children)

-- | Get the children of a node.
childrenOfNode :: Node a -> Set Label

module DDC.Llvm.Analysis.Parents

-- | The parents of a node are the other nodes that might branch to this
--   one.
data Parents
Parents :: (Set Label) -> Parents

-- | Annotate a graph with the parents of each node.
annotParentsOfGraph :: Graph a -> Graph (a, Parents)

-- | Get a list of parents tracing back to the node that defines the given
--   variable, or <a>Nothing</a> if the definition site can not be found.
lineageOfVar :: Graph Parents -> Var -> Label -> Maybe [Label]

module DDC.Llvm.Transform.LinkPhi

-- | Link Phi instructions in a module.
--   
--   For Phi instructions, the Salt-&gt;Llvm converter just fills in the
--   source block label of each variable to be merged with <tt>undef</tt>.
--   We need to add the real block label of the in-edge that defines each
--   variable.
--   
--   We build a graph of each block, work out the in-edges due to branches,
--   and fill in the real block labels by back tracing the in-edges until
--   we find the node that defines each variable.
linkPhi :: Module -> Module

module DDC.Core.Llvm.Metadata.Graph

-- | An undirected graph.
newtype UG a
UG :: (Dom a, Rel a) -> UG a

-- | A directed graph.
newtype DG a
DG :: (Dom a, Rel a) -> DG a
orientUG :: (Show a, Ord a) => UG a -> DG a

-- | Partition a DG into the minimum set of (directed) trees
partitionDG :: Eq a => DG a -> [Tree a]

-- | An inverted tree (with edges going from child to parent)
newtype Tree a
Tree :: (Dom a, Rel a) -> Tree a

-- | Get the sources of a tree.
sources :: Eq a => a -> Tree a -> [a]

-- | Enroot a tree with the given root.
anchor :: Eq a => a -> Tree a -> Tree a
type Dom a = [a]

-- | A binary relation.
type Rel a = a -> a -> Bool

-- | Convert a list to a relation.
fromList :: Eq a => [(a, a)] -> Rel a

-- | Convert a relation.
toList :: Dom a -> Rel a -> [(a, a)]

-- | Find the transitive closure of a binary relation using Floyd-Warshall
--   algorithm
transClosure :: Eq a => Dom a -> Rel a -> Rel a

-- | Transitively orient an undireted graph
--   
--   Using the algorithm from <a>Lex-BFS and partition refinement, with
--   applications to transitive orientation, interval graph recognition and
--   consecutive ones testing</a>, R. McConnell et al 2000
--   
--   In the case where the transitive orientation does not exist, it simply
--   gives some orientation
--   
--   note: gave up on modular decomposition, this approach has very
--   slightly worse time complexity but much simpler
transOrient :: (Show a, Ord a) => UG a -> DG a

-- | Calculate the aliasing induced by a set of trees this includes
--   aliasing within each of the trees and aliasing among trees.
aliasMeasure :: Eq a => Rel a -> Partitioning a -> Int

-- | A relation is an (inverted) tree if each node has at most one outgoing
--   arc
isTree :: Dom a -> Rel a -> Bool
instance Show a => Show (Tree a)
instance Show a => Eq (DG a)
instance Show a => Show (DG a)
instance Show a => Show (UG a)

module DDC.Core.Llvm.Metadata.Tbaa

-- | Metadata for a supercombinator.
data MDSuper
MDSuper :: MDEnv -> [MDecl] -> MDSuper
nameMap :: MDSuper -> MDEnv
decls :: MDSuper -> [MDecl]

-- | Generate tbaa metadata for a top-level Salt supercombinator.
deriveMD :: BindStruct (Exp ()) => String -> Exp () Name -> LlvmM (MDSuper)

-- | Attach relevant metadata to instructions
annot :: (BindStruct c, Show (c Name)) => KindEnv Name -> MDSuper -> [c Name] -> Instr -> AnnotInstr

-- | Lookup the metadata for a name, from the metadata tree attached to a
--   supecombinator.
lookup :: Bound Name -> MDSuper -> Maybe [MDecl]

-- | Like <a>lookup</a> but lookup metadata for several names at once.
lookups :: [Bound Name] -> MDSuper -> [Maybe [MDecl]]
instance Show MDSuper
instance Show ANode
instance Eq ANode
instance Ord ANode
instance Pretty MDSuper

module DDC.Core.Llvm.Convert

-- | Convert a Salt module to LLVM.
--   
--   If anything goes wrong in the convertion then this function will just
--   call <a>error</a>.
convertModule :: Platform -> Module () Name -> Module

-- | Convert a Salt type to an LlvmType.
convertType :: Platform -> KindEnv Name -> Type Name -> Type

-- | Split the parameter and result types from a supercombinator type and
--   and convert them to LLVM form.
--   
--   We can't split the type first and just call <a>convertType</a> above
--   as we need to decend into any quantifiers that wrap the body type.
convertSuperType :: Platform -> KindEnv Name -> Type Name -> ([Type], Type)
