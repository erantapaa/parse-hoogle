-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A reimplementation of the Reactive library.
--   
--   Reenact is a reimplementation of the <i>Reactive</i> library by Conal
--   Elliott. It preserves semantics and most operators of the original
--   library. In particular the <a>Monoid</a>, <a>Applicative</a> and
--   <a>Monad</a> instances for <a>Events</a>, <a>Reactives</a> and
--   <a>Behaviours</a> are available and have the original semantics. The
--   implementation however is completely different, based on asynchronous
--   channels instead of the <a>unamb</a> operator.
@package reenact
@version 0.9

module Control.Reactive.Var
newtype Var a
Var :: TVar a -> Var a
getVar :: Var a -> TVar a
dupVar :: Var a -> IO (Var a)
newVar :: a -> Var a
readVar :: Var a -> IO a
writeVar :: Var a -> a -> IO ()

module Control.Reactive.Chan
newtype Chan a
Chan :: TChan a -> Chan a
getChan :: Chan a -> TChan a
newChan :: IO (Chan a)
dupChan :: Chan a -> IO (Chan a)
readChan :: Chan a -> IO a
tryReadChan :: Chan a -> IO (Maybe a)
writeChan :: Chan a -> a -> IO ()


-- | Primitives:
--   
--   <ul>
--   <li><a>Event</a>: <a>mempty</a>, <a>mappend</a>, <a>fmap</a></li>
--   <li><a>Reactive</a>: <a>fmap</a>, <a>return</a>, <a>join</a>,
--   <a>&lt;</a></li>
--   <li><a>scatterE</a></li>
--   <li><a>accumE</a> or <a>accumR</a></li>
--   <li><a>stepper</a>, <a>apply</a> (or <a>sample</a>, or
--   <a>snapshotWith</a>)</li>
--   <li><a>readChanE</a>, <a>writeChanE</a>, <a>getE</a>, <a>pollE</a>,
--   <a>putE</a>, <a>runLoopUntil</a></li>
--   </ul>
module Control.Reactive

-- | A stream of values.
--   
--   <pre>
--   type Event a = [(Time, a)]
--   </pre>
data Event a

-- | A time-varying value.
--   
--   <pre>
--   type Reactive a = Time -&gt; a
--   </pre>
data Reactive a

-- | Step between values.
stepper :: a -> Event a -> Reactive a

-- | Switch between time-varying values.
--   
--   switcher :: Reactive a -&gt; Event (Reactive a) -&gt; Reactive a r
--   <tt>switcher</tt> e = RJoin (r <a>stepper</a> e) r <tt>switcher</tt> e
--   = join (r <a>stepper</a> e)
--   
--   Step between values without initial.
maybeStepper :: Event a -> Reactive (Maybe a)

-- | Switch between the values of a time-varying value when an event
--   occurs.
--   
--   sampleAndHold :: Reactive b -&gt; Event a -&gt; Reactive b
--   sampleAndHold r e = r <tt>switcher</tt> (pure <a>$</a> r <a>sample</a>
--   e) sampleAndHold r e = (liftA2 change) r (maybeStepper $ sample r e)
--   where change a Nothing = a change a (Just b) = b
sampleAndHold2 :: b -> Reactive b -> Event a -> Reactive b

-- | Apply the values of an event to a time-varying function.
--   
--   <pre>
--   r `apply` e = r `snapshotWith ($)` e
--   </pre>
apply :: Reactive (a -> b) -> Event a -> Event b

-- | Filter an event based on a time-varying predicate.
--   
--   <pre>
--   r `filter'` e = justE $ (partial &lt;$&gt; r) `apply` e
--   </pre>
filter' :: Reactive (a -> Bool) -> Event a -> Event a

-- | Filter an event based on a time-varying toggle.
--   
--   <pre>
--   r `gate` e = (const &lt;$&gt; r) `filter'` e
--   </pre>
gate :: Reactive Bool -> Event a -> Event a

-- | Sample a time-varying value.
--   
--   <pre>
--   r `snapshot` e = snapshotWith const
--   </pre>
sample :: Reactive b -> Event a -> Event b

-- | Sample a time-varying value with the value of the trigger.
--   
--   <pre>
--   r `snapshot` e = snapshotWith (,)
--   </pre>
snapshot :: Reactive a -> Event b -> Event (a, b)

-- | Sample a time-varying value with the value of the trigger, using the
--   given function to combine.
--   
--   <pre>
--   r `snapshotWith f` e = (f &lt;$&gt; r) `apply` e
--   </pre>
snapshotWith :: (a -> b -> c) -> Reactive a -> Event b -> Event c

-- | Discard empty values.
justE :: Event (Maybe a) -> Event a

-- | Partition values of different types. See also <a>partitionE</a>.
--   
--   <pre>
--   let (x, y) in eitherE x y = splitE e  â‰¡  e
--   </pre>
splitE :: Event (Either a b) -> (Event a, Event b)

-- | Interleave values of different types.
eitherE :: Event a -> Event b -> Event (Either a b)

-- | Delay by one value.
lastE :: Event a -> Event a

-- | Delay by <tt>n</tt> values.
delayE :: Int -> Event a -> Event a

-- | Pack with last value. Similar to <tt>withPrevEWith</tt> in reactive
--   but flipped.
recallEWith :: (b -> b -> a) -> Event b -> Event a

-- | Difference of successive values.
diffE :: Num a => Event a -> Event a

-- | Buffer up to <i>n</i> values. When the buffer is full, old elements
--   will be rotated out.
--   
--   <pre>
--   bufferE n e = [[e1],[e1,e2]..[e1..en],[e2..en+1]..]
--   </pre>
bufferE :: Int -> Event a -> Event [a]

-- | Gather event values into chunks of regular size.
--   
--   <pre>
--   gatherE n e = [[e1..en],[en+1..e2n]..]
--   </pre>
gatherE :: Int -> Event a -> Event [a]

-- | Separate chunks of values.
--   
--   <pre>
--   scatterE [e1,e2..] = [e1] &lt;&gt; [e2] ..
--   </pre>
scatterE :: Event [a] -> Event a

-- | Event accumulator.
--   
--   <pre>
--   a `accumE` e = (a `accumR` e) `sample` e
--   a `accumR` e = a `stepper` (a `accumE` e)
--   </pre>
accumE :: a -> Event (a -> a) -> Event a

-- | Reactive accumulator.
--   
--   <pre>
--   a `accumE` e = (a `accumR` e) `sample` e
--   a `accumR` e = a `stepper` (a `accumE` e)
--   </pre>
accumR :: a -> Event (a -> a) -> Reactive a

-- | Create a past-dependent event.
--   
--   <pre>
--   scanlE f z x = foldpE (flip f) f z x
--   </pre>
foldpE :: (a -> b -> b) -> b -> Event a -> Event b

-- | Create a past-dependent reactive. This combinator corresponds to
--   <a>scanl</a> on streams.
--   
--   <pre>
--   scanlR f z x = foldpR (flip f) f z x
--   </pre>
foldpR :: (a -> b -> b) -> b -> Event a -> Reactive b

-- | Create a past-dependent event. This combinator corresponds to
--   <a>scanl</a> on streams.
--   
--   <pre>
--   scanlE f z x = foldpE (flip f) f z x
--   </pre>
scanlE :: (a -> b -> a) -> a -> Event b -> Event a

-- | Create a past-dependent reactive. This combinator corresponds to
--   <a>scanl</a> on streams.
--   
--   <pre>
--   scanlR f z x = foldpR (flip f) f z x
--   </pre>
scanlR :: (a -> b -> a) -> a -> Event b -> Reactive a

-- | Efficient combination of <a>accumE</a> and <a>accumR</a>.
mapAccum :: a -> Event (a -> (b, a)) -> (Event b, Reactive a)

-- | Get just the first value.
firstE :: Event a -> Event a

-- | Get all but the first value.
restE :: Event a -> Event a

-- | Count values.
countE :: Enum b => Event a -> Event b

-- | Count values.
countR :: Enum b => Event a -> Reactive b

-- | Create a past-dependent event using a <a>Monoid</a> instance.
monoidE :: Monoid a => Event a -> Event a

-- | Create a past-dependent event using a <a>Monoid</a> instance.
monoidR :: Monoid a => Event a -> Reactive a
sumE :: Num a => Event a -> Event a
productE :: Num a => Event a -> Event a
allE :: Event Bool -> Event Bool
anyE :: Event Bool -> Event Bool
sumR :: Num a => Event a -> Reactive a
productR :: Num a => Event a -> Reactive a
allR :: Event Bool -> Reactive Bool
anyR :: Event Bool -> Reactive Bool

-- | Throw away values of the event.
--   
--   This is of course just <tt>() &lt;$ x</tt> but it is useful to fix the
--   type in some cases.
tickE :: Event a -> Event ()
onR :: Event a -> Reactive Bool
offR :: Event a -> Reactive Bool
toggleR :: Event a -> Reactive Bool

-- | An event occuring at the specified interval.
pulse :: DiffTime -> Event ()

-- | A generalized time behaviour.
time :: Fractional a => Reactive a

-- | Integrates a behaviour.
--   
--   <pre>
--   integral pulse behavior
--   </pre>
integral :: Fractional b => Event a -> Reactive b -> Reactive b
data TransportControl t

-- | Play from the current position.
Play :: TransportControl t

-- | Play in reverse from the current position.
Reverse :: TransportControl t

-- | Stop playing, and retain current position.
Pause :: TransportControl t

-- | Stop and reset position.
Stop :: TransportControl t

-- | Generates a cursor that moves forward or backward continuously.
--   
--   The cursor may be started, stopped, moved by sending a
--   <a>TransportControl</a> event.
--   
--   <pre>
--   transport control pulse speed
--   </pre>
transport :: (Ord t, Fractional t) => Event (TransportControl t) -> Event a -> Reactive t -> Reactive t

-- | Record a list of values.
record :: Ord t => Reactive t -> Event a -> Reactive [(t, a)]

-- | Play back a list of values.
--   
--   This function will sample the time behaviour at an arbitrary small
--   interval. To get precise control of how time is sampled, use
--   <a>playback'</a> instead.
playback :: Ord t => Reactive t -> Reactive [(t, a)] -> Event a

-- | Play back a list of values.
playback' :: Ord t => Event b -> Reactive t -> Reactive [(t, a)] -> Event [(t, a)]

-- | Run both and behave as the second event.
seqE :: Event a -> Event b -> Event b
oftenE :: Event ()

-- | Event version of <a>getChar</a>.
getCharE :: Event Char

-- | Event version of <a>putChar</a>.
putCharE :: Event Char -> Event Char

-- | Event version of <a>getLine</a>.
getLineE :: Event String

-- | Event version of <a>putStrLn</a>.
putLineE :: Event String -> Event String
systemTimeR :: Reactive UTCTime
systemTimeSecondsR :: Reactive DiffTime
systemTimeDayR :: Reactive Day

-- | Event reading from a channel.
readChanE :: Chan a -> Event a

-- | Event writing to a channel.
writeChanE :: Chan a -> Event a -> Event a

-- | Event reading from external world. The computation should be blocking
--   and is polled exactly once per value.
--   
--   This function can be used with standard I/O functions.
getE :: IO a -> Event a

-- | Event reading from external world. The computation should be
--   non-blocking and may be polled repeatedly for each value.
--   
--   This function should be used with <i>non-effectful</i> functions,
--   typically functions that observe the current value of some external
--   property. You should <i>not</i> use this function with standard I/O
--   functions as this may lead to non-deterministic reads (i.e. loss of
--   data).
pollE :: IO (Maybe a) -> Event a

-- | Event writing to the external world.
--   
--   This function can be used with standard I/O functions.
putE :: (a -> IO ()) -> Event a -> Event a

-- | Run the given event once.
run :: Event a -> IO ()

-- | Run the given event for ever.
runLoop :: Event a -> IO ()

-- | Run the given event until the first <tt>Just x</tt> value, then return
--   <tt>x</tt>.
runLoopUntil :: Event (Maybe a) -> IO a
type Source a = Event a
type Sink a = Event a -> Event ()

-- | Creates a new source and a computation that writes it.
newSource :: IO (a -> IO (), Source a)

-- | Creates a new sink and a computation that reads from it.
newSink :: IO (IO (Maybe a), Sink a)

-- | Behaves like the original event but writes a given message to the
--   standard output for each value.
notify :: String -> Event a -> Event a

-- | Behaves like the original event but writes its value, prepended by the
--   given message, for each value.
showing :: Show a => String -> Event a -> Event a
runEvent :: Show a => Event a -> IO ()
runReactive :: Show a => Reactive a -> IO ()
unsafeGetReactive :: Reactive a -> a
instance Eq (TransportControl t)
instance Ord (TransportControl t)
instance Show (TransportControl t)
instance VectorSpace v => VectorSpace (Reactive v)
instance AdditiveGroup v => AdditiveGroup (Reactive v)
instance Floating b => Floating (Reactive b)
instance Fractional b => Fractional (Reactive b)
instance Integral a => Integral (Reactive a)
instance (Num a, Ord a) => Real (Reactive a)
instance Num a => Num (Reactive a)
instance Enum a => Enum (Reactive a)
instance Ord b => Ord (Reactive b)
instance Eq (Reactive b)
instance IsString a => IsString (Reactive a)
instance Applicative Reactive
instance Functor Reactive
instance Monoid a => Monoid (Reactive a)
instance Monoid (Event a)
instance Functor Event

module Control.Reactive.Midi
type MidiTime = Word32
type MidiMessage = Message
type MidiSource = Source
type MidiDestination = Destination
midiSources :: Reactive [MidiSource]
midiDestinations :: Reactive [MidiDestination]
findSource :: Reactive String -> Reactive (Maybe MidiSource)
findDestination :: Reactive String -> Reactive (Maybe MidiDestination)
midiIn :: MidiSource -> Event MidiMessage
midiIn' :: MidiSource -> Event (MidiTime, MidiMessage)
midiOut :: MidiDestination -> Event MidiMessage -> Event MidiMessage
