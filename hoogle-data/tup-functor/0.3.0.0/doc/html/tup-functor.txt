-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Homogeneous tuples
--   
@package tup-functor
@version 0.3.0.0

module Data.Tup.Class
class (Functor f, Applicative f, Foldable f, Traversable f) => Tup f where tupSize = foldl (\ c _ -> c + 1) 0 tupToList = toList tupFromList = \ ys -> snd $ mapAccumL (\ (x : xs) _ -> (xs, x)) ys (pure undefined) tupUndef _ = undefined tupProxy _ = Proxy constantTup = pure undefinedTup = pure undefined
tupSize :: Tup f => f a -> Int
tupToList :: Tup f => f a -> [a]
tupFromList :: Tup f => [a] -> f a
tupProxy :: Tup f => f a -> Proxy a
tupUndef :: Tup f => f a -> a
constantTup :: Tup f => a -> f a
undefinedTup :: Tup f => f a

-- | Safe version of <a>tupFromList</a>.
maybeTupFromList :: Tup f => [a] -> Maybe (f a)

-- | Transpose a Tup of Tups.
transposeTup :: (Tup f, Tup g) => f (g a) -> g (f a)

-- | Safe concatenation (going through lists)
maybeTupConcat :: (Tup f, Tup g, Tup h) => f a -> g a -> Maybe (h a)

-- | Unsafe concatenation
unsafeTupConcat :: (Tup f, Tup g, Tup h) => f a -> g a -> h a

-- | Safe conversion between different Tup implementations
maybeConvertTup :: (Tup f, Tup g) => f a -> Maybe (g a)

-- | Unsafe conversion
unsafeConvertTup :: (Tup f, Tup g) => f a -> g a
zipTupWith :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
zipTupWith3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
zipTupWith4 :: Applicative f => (a -> b -> c -> d -> e) -> f a -> f b -> f c -> f d -> f e
zipTup :: Applicative f => f a -> f b -> f (a, b)
zipTup3 :: Applicative f => f a -> f b -> f c -> f (a, b, c)
zipTup4 :: Applicative f => f a -> f b -> f c -> f d -> f (a, b, c, d)


-- | Lazy homogeneous tuples
module Data.Tup.Tup.Lazy
data Tup0 a
Tup0 :: Tup0 a
data Tup1 a
Tup1 :: a -> Tup1 a
data Tup2 a
Tup2 :: a -> a -> Tup2 a
data Tup3 a
Tup3 :: a -> a -> a -> Tup3 a
data Tup4 a
Tup4 :: a -> a -> a -> a -> Tup4 a
data Tup5 a
Tup5 :: a -> a -> a -> a -> a -> Tup5 a
data Tup6 a
Tup6 :: a -> a -> a -> a -> a -> a -> Tup6 a
data Tup7 a
Tup7 :: a -> a -> a -> a -> a -> a -> a -> Tup7 a
data Tup8 a
Tup8 :: a -> a -> a -> a -> a -> a -> a -> a -> Tup8 a
data Tup9 a
Tup9 :: a -> a -> a -> a -> a -> a -> a -> a -> a -> Tup9 a
tupTup :: Applicative f => f a -> f a -> f (Tup2 a)
tupTup3 :: Applicative f => f a -> f a -> f a -> f (Tup3 a)
tupTup4 :: Applicative f => f a -> f a -> f a -> f a -> f (Tup4 a)
tupTup5 :: Applicative f => f a -> f a -> f a -> f a -> f a -> f (Tup5 a)
instance Eq (Tup0 a)
instance Ord (Tup0 a)
instance Show (Tup0 a)
instance Read (Tup0 a)
instance Bounded (Tup0 a)
instance Functor Tup0
instance Foldable Tup0
instance Traversable Tup0
instance Eq a => Eq (Tup1 a)
instance Ord a => Ord (Tup1 a)
instance Show a => Show (Tup1 a)
instance Read a => Read (Tup1 a)
instance Bounded a => Bounded (Tup1 a)
instance Functor Tup1
instance Foldable Tup1
instance Traversable Tup1
instance Eq a => Eq (Tup2 a)
instance Ord a => Ord (Tup2 a)
instance Show a => Show (Tup2 a)
instance Read a => Read (Tup2 a)
instance Bounded a => Bounded (Tup2 a)
instance Functor Tup2
instance Foldable Tup2
instance Traversable Tup2
instance Eq a => Eq (Tup3 a)
instance Ord a => Ord (Tup3 a)
instance Show a => Show (Tup3 a)
instance Read a => Read (Tup3 a)
instance Bounded a => Bounded (Tup3 a)
instance Functor Tup3
instance Foldable Tup3
instance Traversable Tup3
instance Eq a => Eq (Tup4 a)
instance Ord a => Ord (Tup4 a)
instance Show a => Show (Tup4 a)
instance Read a => Read (Tup4 a)
instance Bounded a => Bounded (Tup4 a)
instance Functor Tup4
instance Foldable Tup4
instance Traversable Tup4
instance Eq a => Eq (Tup5 a)
instance Ord a => Ord (Tup5 a)
instance Show a => Show (Tup5 a)
instance Read a => Read (Tup5 a)
instance Bounded a => Bounded (Tup5 a)
instance Functor Tup5
instance Foldable Tup5
instance Traversable Tup5
instance Eq a => Eq (Tup6 a)
instance Ord a => Ord (Tup6 a)
instance Show a => Show (Tup6 a)
instance Read a => Read (Tup6 a)
instance Bounded a => Bounded (Tup6 a)
instance Functor Tup6
instance Foldable Tup6
instance Traversable Tup6
instance Eq a => Eq (Tup7 a)
instance Ord a => Ord (Tup7 a)
instance Show a => Show (Tup7 a)
instance Read a => Read (Tup7 a)
instance Bounded a => Bounded (Tup7 a)
instance Functor Tup7
instance Foldable Tup7
instance Traversable Tup7
instance Eq a => Eq (Tup8 a)
instance Ord a => Ord (Tup8 a)
instance Show a => Show (Tup8 a)
instance Read a => Read (Tup8 a)
instance Bounded a => Bounded (Tup8 a)
instance Functor Tup8
instance Foldable Tup8
instance Traversable Tup8
instance Eq a => Eq (Tup9 a)
instance Ord a => Ord (Tup9 a)
instance Show a => Show (Tup9 a)
instance Read a => Read (Tup9 a)
instance Bounded a => Bounded (Tup9 a)
instance Functor Tup9
instance Foldable Tup9
instance Traversable Tup9
instance Storable a => Storable (Tup9 a)
instance Storable a => Storable (Tup8 a)
instance Storable a => Storable (Tup7 a)
instance Storable a => Storable (Tup6 a)
instance Storable a => Storable (Tup5 a)
instance Storable a => Storable (Tup4 a)
instance Storable a => Storable (Tup3 a)
instance Storable a => Storable (Tup2 a)
instance Storable a => Storable (Tup1 a)
instance Storable a => Storable (Tup0 a)
instance Monoid a => Monoid (Tup9 a)
instance Monoid a => Monoid (Tup8 a)
instance Monoid a => Monoid (Tup7 a)
instance Monoid a => Monoid (Tup6 a)
instance Monoid a => Monoid (Tup5 a)
instance Monoid a => Monoid (Tup4 a)
instance Monoid a => Monoid (Tup3 a)
instance Monoid a => Monoid (Tup2 a)
instance Monoid a => Monoid (Tup1 a)
instance Monoid a => Monoid (Tup0 a)
instance Fractional a => Fractional (Tup9 a)
instance Fractional a => Fractional (Tup8 a)
instance Fractional a => Fractional (Tup7 a)
instance Fractional a => Fractional (Tup6 a)
instance Fractional a => Fractional (Tup5 a)
instance Fractional a => Fractional (Tup4 a)
instance Fractional a => Fractional (Tup3 a)
instance Fractional a => Fractional (Tup2 a)
instance Fractional a => Fractional (Tup1 a)
instance Fractional a => Fractional (Tup0 a)
instance Num a => Num (Tup9 a)
instance Num a => Num (Tup8 a)
instance Num a => Num (Tup7 a)
instance Num a => Num (Tup6 a)
instance Num a => Num (Tup5 a)
instance Num a => Num (Tup4 a)
instance Num a => Num (Tup3 a)
instance Num a => Num (Tup2 a)
instance Num a => Num (Tup1 a)
instance Num a => Num (Tup0 a)
instance Applicative Tup9
instance Applicative Tup8
instance Applicative Tup7
instance Applicative Tup6
instance Applicative Tup5
instance Applicative Tup4
instance Applicative Tup3
instance Applicative Tup2
instance Applicative Tup1
instance Applicative Tup0
instance Tup Tup9
instance Tup Tup8
instance Tup Tup7
instance Tup Tup6
instance Tup Tup5
instance Tup Tup4
instance Tup Tup3
instance Tup Tup2
instance Tup Tup1
instance Tup Tup0


-- | Strict homogeneous tuples
module Data.Tup.Tup.Strict
data Tup0 a
Tup0 :: Tup0 a
data Tup1 a
Tup1 :: !a -> Tup1 a
data Tup2 a
Tup2 :: !a -> !a -> Tup2 a
data Tup3 a
Tup3 :: !a -> !a -> !a -> Tup3 a
data Tup4 a
Tup4 :: !a -> !a -> !a -> !a -> Tup4 a
data Tup5 a
Tup5 :: !a -> !a -> !a -> !a -> !a -> Tup5 a
data Tup6 a
Tup6 :: !a -> !a -> !a -> !a -> !a -> !a -> Tup6 a
data Tup7 a
Tup7 :: !a -> !a -> !a -> !a -> !a -> !a -> !a -> Tup7 a
data Tup8 a
Tup8 :: !a -> !a -> !a -> !a -> !a -> !a -> !a -> !a -> Tup8 a
data Tup9 a
Tup9 :: !a -> !a -> !a -> !a -> !a -> !a -> !a -> !a -> !a -> Tup9 a
tupTup :: Applicative f => f a -> f a -> f (Tup2 a)
tupTup3 :: Applicative f => f a -> f a -> f a -> f (Tup3 a)
tupTup4 :: Applicative f => f a -> f a -> f a -> f a -> f (Tup4 a)
tupTup5 :: Applicative f => f a -> f a -> f a -> f a -> f a -> f (Tup5 a)
instance Eq (Tup0 a)
instance Ord (Tup0 a)
instance Show (Tup0 a)
instance Read (Tup0 a)
instance Bounded (Tup0 a)
instance Functor Tup0
instance Foldable Tup0
instance Traversable Tup0
instance Eq a => Eq (Tup1 a)
instance Ord a => Ord (Tup1 a)
instance Show a => Show (Tup1 a)
instance Read a => Read (Tup1 a)
instance Bounded a => Bounded (Tup1 a)
instance Functor Tup1
instance Foldable Tup1
instance Traversable Tup1
instance Eq a => Eq (Tup2 a)
instance Ord a => Ord (Tup2 a)
instance Show a => Show (Tup2 a)
instance Read a => Read (Tup2 a)
instance Bounded a => Bounded (Tup2 a)
instance Functor Tup2
instance Foldable Tup2
instance Traversable Tup2
instance Eq a => Eq (Tup3 a)
instance Ord a => Ord (Tup3 a)
instance Show a => Show (Tup3 a)
instance Read a => Read (Tup3 a)
instance Bounded a => Bounded (Tup3 a)
instance Functor Tup3
instance Foldable Tup3
instance Traversable Tup3
instance Eq a => Eq (Tup4 a)
instance Ord a => Ord (Tup4 a)
instance Show a => Show (Tup4 a)
instance Read a => Read (Tup4 a)
instance Bounded a => Bounded (Tup4 a)
instance Functor Tup4
instance Foldable Tup4
instance Traversable Tup4
instance Eq a => Eq (Tup5 a)
instance Ord a => Ord (Tup5 a)
instance Show a => Show (Tup5 a)
instance Read a => Read (Tup5 a)
instance Bounded a => Bounded (Tup5 a)
instance Functor Tup5
instance Foldable Tup5
instance Traversable Tup5
instance Eq a => Eq (Tup6 a)
instance Ord a => Ord (Tup6 a)
instance Show a => Show (Tup6 a)
instance Read a => Read (Tup6 a)
instance Bounded a => Bounded (Tup6 a)
instance Functor Tup6
instance Foldable Tup6
instance Traversable Tup6
instance Eq a => Eq (Tup7 a)
instance Ord a => Ord (Tup7 a)
instance Show a => Show (Tup7 a)
instance Read a => Read (Tup7 a)
instance Bounded a => Bounded (Tup7 a)
instance Functor Tup7
instance Foldable Tup7
instance Traversable Tup7
instance Eq a => Eq (Tup8 a)
instance Ord a => Ord (Tup8 a)
instance Show a => Show (Tup8 a)
instance Read a => Read (Tup8 a)
instance Bounded a => Bounded (Tup8 a)
instance Functor Tup8
instance Foldable Tup8
instance Traversable Tup8
instance Eq a => Eq (Tup9 a)
instance Ord a => Ord (Tup9 a)
instance Show a => Show (Tup9 a)
instance Read a => Read (Tup9 a)
instance Bounded a => Bounded (Tup9 a)
instance Functor Tup9
instance Foldable Tup9
instance Traversable Tup9
instance Storable a => Storable (Tup9 a)
instance Storable a => Storable (Tup8 a)
instance Storable a => Storable (Tup7 a)
instance Storable a => Storable (Tup6 a)
instance Storable a => Storable (Tup5 a)
instance Storable a => Storable (Tup4 a)
instance Storable a => Storable (Tup3 a)
instance Storable a => Storable (Tup2 a)
instance Storable a => Storable (Tup1 a)
instance Storable a => Storable (Tup0 a)
instance Monoid a => Monoid (Tup9 a)
instance Monoid a => Monoid (Tup8 a)
instance Monoid a => Monoid (Tup7 a)
instance Monoid a => Monoid (Tup6 a)
instance Monoid a => Monoid (Tup5 a)
instance Monoid a => Monoid (Tup4 a)
instance Monoid a => Monoid (Tup3 a)
instance Monoid a => Monoid (Tup2 a)
instance Monoid a => Monoid (Tup1 a)
instance Monoid a => Monoid (Tup0 a)
instance Fractional a => Fractional (Tup9 a)
instance Fractional a => Fractional (Tup8 a)
instance Fractional a => Fractional (Tup7 a)
instance Fractional a => Fractional (Tup6 a)
instance Fractional a => Fractional (Tup5 a)
instance Fractional a => Fractional (Tup4 a)
instance Fractional a => Fractional (Tup3 a)
instance Fractional a => Fractional (Tup2 a)
instance Fractional a => Fractional (Tup1 a)
instance Fractional a => Fractional (Tup0 a)
instance Num a => Num (Tup9 a)
instance Num a => Num (Tup8 a)
instance Num a => Num (Tup7 a)
instance Num a => Num (Tup6 a)
instance Num a => Num (Tup5 a)
instance Num a => Num (Tup4 a)
instance Num a => Num (Tup3 a)
instance Num a => Num (Tup2 a)
instance Num a => Num (Tup1 a)
instance Num a => Num (Tup0 a)
instance Applicative Tup9
instance Applicative Tup8
instance Applicative Tup7
instance Applicative Tup6
instance Applicative Tup5
instance Applicative Tup4
instance Applicative Tup3
instance Applicative Tup2
instance Applicative Tup1
instance Applicative Tup0
instance Tup Tup9
instance Tup Tup8
instance Tup Tup7
instance Tup Tup6
instance Tup Tup5
instance Tup Tup4
instance Tup Tup3
instance Tup Tup2
instance Tup Tup1
instance Tup Tup0


-- | Homogeneous lists with the length encoded in the type.
--   
--   This can be considered as a different implementation of
--   <a>Data.Tup.Tup</a> (one which also scales for vectors/tuples longer
--   than 9 elements)
--   
--   Example:
--   
--   <pre>
--   vec3 1 2 3  :: Vec3 Int
--   {{ 1,2,3 }} :: Vec3 Int
--   Cons 1 (Cons 2 (Cons 3 Empty)) :: Cons (Cons (Cons Empty)) Int
--   </pre>
module Data.Tup.Vec
type Vec0 = Empty
type Vec1 = Cons Vec0
type Vec2 = Cons Vec1
type Vec3 = Cons Vec2
type Vec4 = Cons Vec3
type Vec5 = Cons Vec4
type Vec6 = Cons Vec5
type Vec7 = Cons Vec6
type Vec8 = Cons Vec7
type Vec9 = Cons Vec8
data Empty a
Empty :: Empty a
data Cons v a
Cons :: a -> (v a) -> Cons v a
consUndefTail :: Tup v => Cons v a -> v a
vec0 :: Vec0 a
vec1 :: a -> Vec1 a
vec2 :: a -> a -> Vec2 a
vec3 :: a -> a -> a -> Vec3 a
vec4 :: a -> a -> a -> a -> Vec4 a
vec5 :: a -> a -> a -> a -> a -> Vec5 a
vec6 :: a -> a -> a -> a -> a -> a -> Vec6 a
vec7 :: a -> a -> a -> a -> a -> a -> a -> Vec7 a
vec8 :: a -> a -> a -> a -> a -> a -> a -> a -> Vec8 a
vec9 :: a -> a -> a -> a -> a -> a -> a -> a -> a -> Vec9 a
vecVec :: Applicative f => f a -> f a -> f (Vec2 a)
vecVec3 :: Applicative f => f a -> f a -> f a -> f (Vec3 a)
vecVec4 :: Applicative f => f a -> f a -> f a -> f a -> f (Vec4 a)
vecVec5 :: Applicative f => f a -> f a -> f a -> f a -> f a -> f (Vec5 a)
instance Eq (Empty a)
instance Ord (Empty a)
instance Bounded (Empty a)
instance Functor Empty
instance Foldable Empty
instance Traversable Empty
instance (Eq a, Eq (v a)) => Eq (Cons v a)
instance (Ord a, Ord (v a)) => Ord (Cons v a)
instance (Bounded a, Bounded (v a)) => Bounded (Cons v a)
instance Functor v => Functor (Cons v)
instance Foldable v => Foldable (Cons v)
instance Traversable v => Traversable (Cons v)
instance (Storable a, Storable (v a), Tup v) => Storable (Cons v a)
instance Storable a => Storable (Empty a)
instance (Monoid a, Monoid (v a), Tup v) => Monoid (Cons v a)
instance Monoid a => Monoid (Empty a)
instance (Fractional a, Fractional (v a), Tup v) => Fractional (Cons v a)
instance Fractional a => Fractional (Empty a)
instance (Num a, Num (v a), Tup v) => Num (Cons v a)
instance Num a => Num (Empty a)
instance Applicative v => Applicative (Cons v)
instance Applicative Empty
instance (Show a, Tup v) => Show (Cons v a)
instance Show a => Show (Empty a)
instance Tup v => Tup (Cons v)
instance Tup Empty


-- | Homogeneous tuples as newtypes of standard Haskell tuples. This is a
--   third alternative implementation.
--   
--   <pre>
--   ntup3 1 2 3 == NTup3 (1,2,3)
--   </pre>
module Data.Tup.Newtype
data NTup0 a
NTup0 :: NTup0 a
newtype NTup1 a
NTup1 :: a -> NTup1 a
newtype NTup2 a
NTup2 :: (a, a) -> NTup2 a
newtype NTup3 a
NTup3 :: (a, a, a) -> NTup3 a
newtype NTup4 a
NTup4 :: (a, a, a, a) -> NTup4 a
newtype NTup5 a
NTup5 :: (a, a, a, a, a) -> NTup5 a
newtype NTup6 a
NTup6 :: (a, a, a, a, a, a) -> NTup6 a
newtype NTup7 a
NTup7 :: (a, a, a, a, a, a, a) -> NTup7 a
newtype NTup8 a
NTup8 :: (a, a, a, a, a, a, a, a) -> NTup8 a
newtype NTup9 a
NTup9 :: (a, a, a, a, a, a, a, a, a) -> NTup9 a
ntup0 :: NTup0 a
ntup1 :: a -> NTup1 a
ntup2 :: a -> a -> NTup2 a
ntup3 :: a -> a -> a -> NTup3 a
ntup4 :: a -> a -> a -> a -> NTup4 a
ntup5 :: a -> a -> a -> a -> a -> NTup5 a
ntup6 :: a -> a -> a -> a -> a -> a -> NTup6 a
ntup7 :: a -> a -> a -> a -> a -> a -> a -> NTup7 a
ntup8 :: a -> a -> a -> a -> a -> a -> a -> a -> NTup8 a
ntup9 :: a -> a -> a -> a -> a -> a -> a -> a -> a -> NTup9 a
untup1 :: NTup1 a -> a
untup2 :: NTup2 a -> (a, a)
untup3 :: NTup3 a -> (a, a, a)
untup4 :: NTup4 a -> (a, a, a, a)
untup5 :: NTup5 a -> (a, a, a, a, a)
untup6 :: NTup6 a -> (a, a, a, a, a, a)
untup7 :: NTup7 a -> (a, a, a, a, a, a, a)
untup8 :: NTup8 a -> (a, a, a, a, a, a, a, a)
untup9 :: NTup9 a -> (a, a, a, a, a, a, a, a, a)
instance Eq (NTup0 a)
instance Ord (NTup0 a)
instance Read (NTup0 a)
instance Show (NTup0 a)
instance Bounded (NTup0 a)
instance Functor NTup0
instance Foldable NTup0
instance Traversable NTup0
instance Eq a => Eq (NTup1 a)
instance Ord a => Ord (NTup1 a)
instance Read a => Read (NTup1 a)
instance Show a => Show (NTup1 a)
instance Bounded a => Bounded (NTup1 a)
instance Functor NTup1
instance Foldable NTup1
instance Traversable NTup1
instance Eq a => Eq (NTup2 a)
instance Ord a => Ord (NTup2 a)
instance Read a => Read (NTup2 a)
instance Show a => Show (NTup2 a)
instance Bounded a => Bounded (NTup2 a)
instance Functor NTup2
instance Foldable NTup2
instance Traversable NTup2
instance Eq a => Eq (NTup3 a)
instance Ord a => Ord (NTup3 a)
instance Read a => Read (NTup3 a)
instance Show a => Show (NTup3 a)
instance Bounded a => Bounded (NTup3 a)
instance Functor NTup3
instance Foldable NTup3
instance Traversable NTup3
instance Eq a => Eq (NTup4 a)
instance Ord a => Ord (NTup4 a)
instance Read a => Read (NTup4 a)
instance Show a => Show (NTup4 a)
instance Bounded a => Bounded (NTup4 a)
instance Functor NTup4
instance Foldable NTup4
instance Traversable NTup4
instance Eq a => Eq (NTup5 a)
instance Ord a => Ord (NTup5 a)
instance Read a => Read (NTup5 a)
instance Show a => Show (NTup5 a)
instance Bounded a => Bounded (NTup5 a)
instance Functor NTup5
instance Foldable NTup5
instance Traversable NTup5
instance Eq a => Eq (NTup6 a)
instance Ord a => Ord (NTup6 a)
instance Read a => Read (NTup6 a)
instance Show a => Show (NTup6 a)
instance Bounded a => Bounded (NTup6 a)
instance Functor NTup6
instance Foldable NTup6
instance Traversable NTup6
instance Eq a => Eq (NTup7 a)
instance Ord a => Ord (NTup7 a)
instance Read a => Read (NTup7 a)
instance Show a => Show (NTup7 a)
instance Bounded a => Bounded (NTup7 a)
instance Functor NTup7
instance Foldable NTup7
instance Traversable NTup7
instance Eq a => Eq (NTup8 a)
instance Ord a => Ord (NTup8 a)
instance Read a => Read (NTup8 a)
instance Show a => Show (NTup8 a)
instance Bounded a => Bounded (NTup8 a)
instance Functor NTup8
instance Foldable NTup8
instance Traversable NTup8
instance Eq a => Eq (NTup9 a)
instance Ord a => Ord (NTup9 a)
instance Read a => Read (NTup9 a)
instance Show a => Show (NTup9 a)
instance Bounded a => Bounded (NTup9 a)
instance Functor NTup9
instance Foldable NTup9
instance Traversable NTup9
instance Storable a => Storable (NTup9 a)
instance Storable a => Storable (NTup8 a)
instance Storable a => Storable (NTup7 a)
instance Storable a => Storable (NTup6 a)
instance Storable a => Storable (NTup5 a)
instance Storable a => Storable (NTup4 a)
instance Storable a => Storable (NTup3 a)
instance Storable a => Storable (NTup2 a)
instance Storable a => Storable (NTup1 a)
instance Storable a => Storable (NTup0 a)
instance Monoid a => Monoid (NTup9 a)
instance Monoid a => Monoid (NTup8 a)
instance Monoid a => Monoid (NTup7 a)
instance Monoid a => Monoid (NTup6 a)
instance Monoid a => Monoid (NTup5 a)
instance Monoid a => Monoid (NTup4 a)
instance Monoid a => Monoid (NTup3 a)
instance Monoid a => Monoid (NTup2 a)
instance Monoid a => Monoid (NTup1 a)
instance Monoid a => Monoid (NTup0 a)
instance Fractional a => Fractional (NTup9 a)
instance Fractional a => Fractional (NTup8 a)
instance Fractional a => Fractional (NTup7 a)
instance Fractional a => Fractional (NTup6 a)
instance Fractional a => Fractional (NTup5 a)
instance Fractional a => Fractional (NTup4 a)
instance Fractional a => Fractional (NTup3 a)
instance Fractional a => Fractional (NTup2 a)
instance Fractional a => Fractional (NTup1 a)
instance Fractional a => Fractional (NTup0 a)
instance Num a => Num (NTup9 a)
instance Num a => Num (NTup8 a)
instance Num a => Num (NTup7 a)
instance Num a => Num (NTup6 a)
instance Num a => Num (NTup5 a)
instance Num a => Num (NTup4 a)
instance Num a => Num (NTup3 a)
instance Num a => Num (NTup2 a)
instance Num a => Num (NTup1 a)
instance Num a => Num (NTup0 a)
instance Applicative NTup9
instance Applicative NTup8
instance Applicative NTup7
instance Applicative NTup6
instance Applicative NTup5
instance Applicative NTup4
instance Applicative NTup3
instance Applicative NTup2
instance Applicative NTup1
instance Applicative NTup0
instance Tup NTup9
instance Tup NTup8
instance Tup NTup7
instance Tup NTup6
instance Tup NTup5
instance Tup NTup4
instance Tup NTup3
instance Tup NTup2
instance Tup NTup1
instance Tup NTup0


-- | Concatenation of tuples. Requires MPTCs and FunDeps.
module Data.Tup.Concat
class (Tup f, Tup g, Tup h) => TupConcat f g h | f g -> h where tupConcat x y = tupFromList (tupToList x ++ tupToList y)
tupConcat :: TupConcat f g h => f a -> g a -> h a
instance TupConcat NTup9 NTup0 NTup9
instance TupConcat NTup8 NTup1 NTup9
instance TupConcat NTup8 NTup0 NTup8
instance TupConcat NTup7 NTup2 NTup9
instance TupConcat NTup7 NTup1 NTup8
instance TupConcat NTup7 NTup0 NTup7
instance TupConcat NTup6 NTup3 NTup9
instance TupConcat NTup6 NTup2 NTup8
instance TupConcat NTup6 NTup1 NTup7
instance TupConcat NTup6 NTup0 NTup6
instance TupConcat NTup5 NTup4 NTup9
instance TupConcat NTup5 NTup3 NTup8
instance TupConcat NTup5 NTup2 NTup7
instance TupConcat NTup5 NTup1 NTup6
instance TupConcat NTup5 NTup0 NTup5
instance TupConcat NTup4 NTup5 NTup9
instance TupConcat NTup4 NTup4 NTup8
instance TupConcat NTup4 NTup3 NTup7
instance TupConcat NTup4 NTup2 NTup6
instance TupConcat NTup4 NTup1 NTup5
instance TupConcat NTup4 NTup0 NTup4
instance TupConcat NTup3 NTup6 NTup9
instance TupConcat NTup3 NTup5 NTup8
instance TupConcat NTup3 NTup4 NTup7
instance TupConcat NTup3 NTup3 NTup6
instance TupConcat NTup3 NTup2 NTup5
instance TupConcat NTup3 NTup1 NTup4
instance TupConcat NTup3 NTup0 NTup3
instance TupConcat NTup2 NTup7 NTup9
instance TupConcat NTup2 NTup6 NTup8
instance TupConcat NTup2 NTup5 NTup7
instance TupConcat NTup2 NTup4 NTup6
instance TupConcat NTup2 NTup3 NTup5
instance TupConcat NTup2 NTup2 NTup4
instance TupConcat NTup2 NTup1 NTup3
instance TupConcat NTup2 NTup0 NTup2
instance TupConcat NTup1 NTup8 NTup9
instance TupConcat NTup1 NTup7 NTup8
instance TupConcat NTup1 NTup6 NTup7
instance TupConcat NTup1 NTup5 NTup6
instance TupConcat NTup1 NTup4 NTup5
instance TupConcat NTup1 NTup3 NTup4
instance TupConcat NTup1 NTup2 NTup3
instance TupConcat NTup1 NTup1 NTup2
instance TupConcat NTup1 NTup0 NTup1
instance TupConcat NTup0 NTup9 NTup9
instance TupConcat NTup0 NTup8 NTup8
instance TupConcat NTup0 NTup7 NTup7
instance TupConcat NTup0 NTup6 NTup6
instance TupConcat NTup0 NTup5 NTup5
instance TupConcat NTup0 NTup4 NTup4
instance TupConcat NTup0 NTup3 NTup3
instance TupConcat NTup0 NTup2 NTup2
instance TupConcat NTup0 NTup1 NTup1
instance TupConcat NTup0 NTup0 NTup0
instance TupConcat Tup9 Tup0 Tup9
instance TupConcat Tup8 Tup1 Tup9
instance TupConcat Tup8 Tup0 Tup8
instance TupConcat Tup7 Tup2 Tup9
instance TupConcat Tup7 Tup1 Tup8
instance TupConcat Tup7 Tup0 Tup7
instance TupConcat Tup6 Tup3 Tup9
instance TupConcat Tup6 Tup2 Tup8
instance TupConcat Tup6 Tup1 Tup7
instance TupConcat Tup6 Tup0 Tup6
instance TupConcat Tup5 Tup4 Tup9
instance TupConcat Tup5 Tup3 Tup8
instance TupConcat Tup5 Tup2 Tup7
instance TupConcat Tup5 Tup1 Tup6
instance TupConcat Tup5 Tup0 Tup5
instance TupConcat Tup4 Tup5 Tup9
instance TupConcat Tup4 Tup4 Tup8
instance TupConcat Tup4 Tup3 Tup7
instance TupConcat Tup4 Tup2 Tup6
instance TupConcat Tup4 Tup1 Tup5
instance TupConcat Tup4 Tup0 Tup4
instance TupConcat Tup3 Tup6 Tup9
instance TupConcat Tup3 Tup5 Tup8
instance TupConcat Tup3 Tup4 Tup7
instance TupConcat Tup3 Tup3 Tup6
instance TupConcat Tup3 Tup2 Tup5
instance TupConcat Tup3 Tup1 Tup4
instance TupConcat Tup3 Tup0 Tup3
instance TupConcat Tup2 Tup7 Tup9
instance TupConcat Tup2 Tup6 Tup8
instance TupConcat Tup2 Tup5 Tup7
instance TupConcat Tup2 Tup4 Tup6
instance TupConcat Tup2 Tup3 Tup5
instance TupConcat Tup2 Tup2 Tup4
instance TupConcat Tup2 Tup1 Tup3
instance TupConcat Tup2 Tup0 Tup2
instance TupConcat Tup1 Tup8 Tup9
instance TupConcat Tup1 Tup7 Tup8
instance TupConcat Tup1 Tup6 Tup7
instance TupConcat Tup1 Tup5 Tup6
instance TupConcat Tup1 Tup4 Tup5
instance TupConcat Tup1 Tup3 Tup4
instance TupConcat Tup1 Tup2 Tup3
instance TupConcat Tup1 Tup1 Tup2
instance TupConcat Tup1 Tup0 Tup1
instance TupConcat Tup0 Tup9 Tup9
instance TupConcat Tup0 Tup8 Tup8
instance TupConcat Tup0 Tup7 Tup7
instance TupConcat Tup0 Tup6 Tup6
instance TupConcat Tup0 Tup5 Tup5
instance TupConcat Tup0 Tup4 Tup4
instance TupConcat Tup0 Tup3 Tup3
instance TupConcat Tup0 Tup2 Tup2
instance TupConcat Tup0 Tup1 Tup1
instance TupConcat Tup0 Tup0 Tup0
instance TupConcat Tup9 Tup0 Tup9
instance TupConcat Tup8 Tup1 Tup9
instance TupConcat Tup8 Tup0 Tup8
instance TupConcat Tup7 Tup2 Tup9
instance TupConcat Tup7 Tup1 Tup8
instance TupConcat Tup7 Tup0 Tup7
instance TupConcat Tup6 Tup3 Tup9
instance TupConcat Tup6 Tup2 Tup8
instance TupConcat Tup6 Tup1 Tup7
instance TupConcat Tup6 Tup0 Tup6
instance TupConcat Tup5 Tup4 Tup9
instance TupConcat Tup5 Tup3 Tup8
instance TupConcat Tup5 Tup2 Tup7
instance TupConcat Tup5 Tup1 Tup6
instance TupConcat Tup5 Tup0 Tup5
instance TupConcat Tup4 Tup5 Tup9
instance TupConcat Tup4 Tup4 Tup8
instance TupConcat Tup4 Tup3 Tup7
instance TupConcat Tup4 Tup2 Tup6
instance TupConcat Tup4 Tup1 Tup5
instance TupConcat Tup4 Tup0 Tup4
instance TupConcat Tup3 Tup6 Tup9
instance TupConcat Tup3 Tup5 Tup8
instance TupConcat Tup3 Tup4 Tup7
instance TupConcat Tup3 Tup3 Tup6
instance TupConcat Tup3 Tup2 Tup5
instance TupConcat Tup3 Tup1 Tup4
instance TupConcat Tup3 Tup0 Tup3
instance TupConcat Tup2 Tup7 Tup9
instance TupConcat Tup2 Tup6 Tup8
instance TupConcat Tup2 Tup5 Tup7
instance TupConcat Tup2 Tup4 Tup6
instance TupConcat Tup2 Tup3 Tup5
instance TupConcat Tup2 Tup2 Tup4
instance TupConcat Tup2 Tup1 Tup3
instance TupConcat Tup2 Tup0 Tup2
instance TupConcat Tup1 Tup8 Tup9
instance TupConcat Tup1 Tup7 Tup8
instance TupConcat Tup1 Tup6 Tup7
instance TupConcat Tup1 Tup5 Tup6
instance TupConcat Tup1 Tup4 Tup5
instance TupConcat Tup1 Tup3 Tup4
instance TupConcat Tup1 Tup2 Tup3
instance TupConcat Tup1 Tup1 Tup2
instance TupConcat Tup1 Tup0 Tup1
instance TupConcat Tup0 Tup9 Tup9
instance TupConcat Tup0 Tup8 Tup8
instance TupConcat Tup0 Tup7 Tup7
instance TupConcat Tup0 Tup6 Tup6
instance TupConcat Tup0 Tup5 Tup5
instance TupConcat Tup0 Tup4 Tup4
instance TupConcat Tup0 Tup3 Tup3
instance TupConcat Tup0 Tup2 Tup2
instance TupConcat Tup0 Tup1 Tup1
instance TupConcat Tup0 Tup0 Tup0
instance (Tup u, Tup v, TupConcat u v w) => TupConcat (Cons u) v (Cons w)
instance Tup v => TupConcat Empty v v


-- | This small library defines data types <a>Tup1</a>, <a>Tup2</a> ...
--   <a>Tup9</a> for homogeneous tuples of small size (both strict and
--   lazy), and various instances for them, most notably <a>Functor</a> and
--   <a>Applicative</a>. We also have a <a>Tup</a> type class:
--   
--   <pre>
--   class Tup f where
--     tupSize     :: f a -&gt; Int
--     tupToList   :: f a -&gt; [a]
--     tupFromList :: [a] -&gt; f a 
--     tupProxy    :: f a -&gt; Proxy a
--     ...
--   </pre>
--   
--   Also included is a very simple preprocesszor <tt>tuplepp</tt> which
--   translates the syntax <tt>{{a,b,c}}</tt> into <tt>(Tup3 a b c)</tt>.
module Data.Tup.Tup


-- | This small library defines data types <a>Tup1</a>, <a>Tup2</a> ...
--   <a>Tup9</a> for homogeneous tuples of small size (both strict and
--   lazy), and various instances for them, most notably <a>Functor</a> and
--   <a>Applicative</a>. We also have a <a>Tup</a> type class:
--   
--   <pre>
--   class Tup f where
--     tupSize     :: f a -&gt; Int
--     tupToList   :: f a -&gt; [a]
--     tupFromList :: [a] -&gt; f a 
--     tupProxy    :: f a -&gt; Proxy a
--     ...
--   </pre>
--   
--   Also included is a very simple preprocesszor <tt>tuplepp</tt> which
--   translates the syntax <tt>{{a,b,c}}</tt> into <tt>(Tup3 a b c)</tt>.
--   
--   A different implementation is also given in the module
--   <a>Data.Tup.Vec</a>; this basically implements lists which encode
--   their length in their types. For this, just replace <a>Tup</a> by
--   <tt>Vec</tt> everywhere. The same instances and functions are
--   provided.
--   
--   A third implementation is in <a>Data.Tup.Newtype</a>; here the tuples
--   are newtypes of Haskell tuples. Just replace <a>Tup</a> by
--   <tt>NTup</tt>.
module Data.Tup
