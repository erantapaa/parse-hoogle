-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The Haskell tracer, generating and viewing Haskell execution traces
--   
@package hat
@version 2.9.0.0

module Hat.Hack

module Hat.Hat
data RefModule
data RefSrcPos
data RefExp
data RefAtom
type Loc = Int
type Fixity = Int
type Arity = Int
data R a
R :: a -> RefExp -> R a
tPrelude :: RefModule
toId :: RefExp -> R a -> R a
fromId :: RefExp -> R a -> R a

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) characters (see
--   <a>http://www.unicode.org/</a> for details). This set extends the ISO
--   8859-1 (Latin-1) character set (the first 256 characters), which is
--   itself an extension of the ASCII character set (the first 128
--   characters). A character literal in Haskell has type <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <tt>ord</tt> and
--   <tt>chr</tt>).
data Char :: *

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int :: *

-- | Arbitrary-precision integers.
data Integer :: *

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float :: *

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double :: *
toChar :: RefExp -> R Char -> Char
fromChar :: RefExp -> Char -> R Char
toInt :: RefExp -> R Int -> Int
fromInt :: RefExp -> Int -> R Int
toInteger :: RefExp -> R Integer -> Integer
fromInteger :: RefExp -> Integer -> R Integer
toFloat :: RefExp -> R Float -> Float
fromFloat :: RefExp -> Float -> R Float
toDouble :: RefExp -> R Double -> Double
fromDouble :: RefExp -> Double -> R Double
newtype Fun a b
Fun :: (RefExp -> R a -> R b) -> Fun a b
data IO a
toIO :: (RefExp -> R a -> b) -> RefExp -> R (IO a) -> IO b
fromIO :: (RefExp -> a -> R b) -> RefExp -> IO a -> R (IO b)
data Tuple0
Tuple0 :: Tuple0
aTuple0 :: RefAtom
data Tuple2 a b
Tuple2 :: (R a) -> (R b) -> Tuple2 a b
aTuple2 :: RefAtom
data Tuple3 a b c
Tuple3 :: (R a) -> (R b) -> (R c) -> Tuple3 a b c
aTuple3 :: RefAtom
data Tuple4 a b c d
Tuple4 :: (R a) -> (R b) -> (R c) -> (R d) -> Tuple4 a b c d
aTuple4 :: RefAtom
data Tuple5 a b c d e
Tuple5 :: (R a) -> (R b) -> (R c) -> (R d) -> (R e) -> Tuple5 a b c d e
aTuple5 :: RefAtom
data Tuple6 a b c d e f
Tuple6 :: (R a) -> (R b) -> (R c) -> (R d) -> (R e) -> (R f) -> Tuple6 a b c d e f
aTuple6 :: RefAtom
data Tuple7 a b c d e f g
Tuple7 :: (R a) -> (R b) -> (R c) -> (R d) -> (R e) -> (R f) -> (R g) -> Tuple7 a b c d e f g
aTuple7 :: RefAtom
data Tuple8 a b c d e f g h
Tuple8 :: (R a) -> (R b) -> (R c) -> (R d) -> (R e) -> (R f) -> (R g) -> (R h) -> Tuple8 a b c d e f g h
aTuple8 :: RefAtom
data Tuple9 a b c d e f g h i
Tuple9 :: (R a) -> (R b) -> (R c) -> (R d) -> (R e) -> (R f) -> (R g) -> (R h) -> (R i) -> Tuple9 a b c d e f g h i
aTuple9 :: RefAtom
data Tuple10 a b c d e f g h i j
Tuple10 :: (R a) -> (R b) -> (R c) -> (R d) -> (R e) -> (R f) -> (R g) -> (R h) -> (R i) -> (R j) -> Tuple10 a b c d e f g h i j
aTuple10 :: RefAtom
data Tuple11 a b c d e f g h i j k
Tuple11 :: (R a) -> (R b) -> (R c) -> (R d) -> (R e) -> (R f) -> (R g) -> (R h) -> (R i) -> (R j) -> (R k) -> Tuple11 a b c d e f g h i j k
aTuple11 :: RefAtom
data Tuple12 a b c d e f g h i j k l
Tuple12 :: (R a) -> (R b) -> (R c) -> (R d) -> (R e) -> (R f) -> (R g) -> (R h) -> (R i) -> (R j) -> (R k) -> (R l) -> Tuple12 a b c d e f g h i j k l
aTuple12 :: RefAtom
data Tuple13 a b c d e f g h i j k l m
Tuple13 :: (R a) -> (R b) -> (R c) -> (R d) -> (R e) -> (R f) -> (R g) -> (R h) -> (R i) -> (R j) -> (R k) -> (R l) -> (R m) -> Tuple13 a b c d e f g h i j k l m
aTuple13 :: RefAtom
data Tuple14 a b c d e f g h i j k l m n
Tuple14 :: (R a) -> (R b) -> (R c) -> (R d) -> (R e) -> (R f) -> (R g) -> (R h) -> (R i) -> (R j) -> (R k) -> (R l) -> (R m) -> (R n) -> Tuple14 a b c d e f g h i j k l m n
aTuple14 :: RefAtom
data Tuple15 a b c d e f g h i j k l m n o
Tuple15 :: (R a) -> (R b) -> (R c) -> (R d) -> (R e) -> (R f) -> (R g) -> (R h) -> (R i) -> (R j) -> (R k) -> (R l) -> (R m) -> (R n) -> (R o) -> Tuple15 a b c d e f g h i j k l m n o
aTuple15 :: RefAtom
toTuple0 :: RefExp -> R Tuple0 -> ()
fromTuple0 :: RefExp -> () -> R Tuple0
toTuple2 :: (RefExp -> R a -> c) -> (RefExp -> R b -> d) -> RefExp -> R (Tuple2 a b) -> (c, d)
fromTuple2 :: (RefExp -> a -> R c) -> (RefExp -> b -> R d) -> RefExp -> (a, b) -> R (Tuple2 c d)
data List a
Cons :: (R a) -> (R (List a)) -> List a
Nil :: List a
aCons :: RefAtom
aNil :: RefAtom
ap1 :: RefSrcPos -> RefExp -> R (Fun a z) -> R a -> R z
ap2 :: RefSrcPos -> RefExp -> R (Fun a (Fun b z)) -> R a -> R b -> R z
ap3 :: RefSrcPos -> RefExp -> R (Fun a (Fun b (Fun c z))) -> R a -> R b -> R c -> R z
ap4 :: RefSrcPos -> RefExp -> R (Fun a (Fun b (Fun c (Fun d z)))) -> R a -> R b -> R c -> R d -> R z
ap5 :: RefSrcPos -> RefExp -> R (Fun a (Fun b (Fun c (Fun d (Fun e z))))) -> R a -> R b -> R c -> R d -> R e -> R z
ap6 :: RefSrcPos -> RefExp -> R (Fun a (Fun b (Fun c (Fun d (Fun e (Fun g z)))))) -> R a -> R b -> R c -> R d -> R e -> R g -> R z
ap7 :: RefSrcPos -> RefExp -> R (Fun a (Fun b (Fun c (Fun d (Fun e (Fun g (Fun h z))))))) -> R a -> R b -> R c -> R d -> R e -> R g -> R h -> R z
ap8 :: RefSrcPos -> RefExp -> R (Fun a (Fun b (Fun c (Fun d (Fun e (Fun g (Fun h (Fun i z)))))))) -> R a -> R b -> R c -> R d -> R e -> R g -> R h -> R i -> R z
ap9 :: RefSrcPos -> RefExp -> R (Fun a (Fun b (Fun c (Fun d (Fun e (Fun g (Fun h (Fun i (Fun j z))))))))) -> R a -> R b -> R c -> R d -> R e -> R g -> R h -> R i -> R j -> R z
ap10 :: RefSrcPos -> RefExp -> R (Fun a (Fun b (Fun c (Fun d (Fun e (Fun g (Fun h (Fun i (Fun j (Fun k z)))))))))) -> R a -> R b -> R c -> R d -> R e -> R g -> R h -> R i -> R j -> R k -> R z
ap11 :: RefSrcPos -> RefExp -> R (Fun a (Fun b (Fun c (Fun d (Fun e (Fun g (Fun h (Fun i (Fun j (Fun k (Fun l z))))))))))) -> R a -> R b -> R c -> R d -> R e -> R g -> R h -> R i -> R j -> R k -> R l -> R z
ap12 :: RefSrcPos -> RefExp -> R (Fun a (Fun b (Fun c (Fun d (Fun e (Fun g (Fun h (Fun i (Fun j (Fun k (Fun l (Fun m z)))))))))))) -> R a -> R b -> R c -> R d -> R e -> R g -> R h -> R i -> R j -> R k -> R l -> R m -> R z
ap13 :: RefSrcPos -> RefExp -> R (Fun a (Fun b (Fun c (Fun d (Fun e (Fun g (Fun h (Fun i (Fun j (Fun k (Fun l (Fun m (Fun n z))))))))))))) -> R a -> R b -> R c -> R d -> R e -> R g -> R h -> R i -> R j -> R k -> R l -> R m -> R n -> R z
ap14 :: RefSrcPos -> RefExp -> R (Fun a (Fun b (Fun c (Fun d (Fun e (Fun g (Fun h (Fun i (Fun j (Fun k (Fun l (Fun m (Fun n (Fun o z)))))))))))))) -> R a -> R b -> R c -> R d -> R e -> R g -> R h -> R i -> R j -> R k -> R l -> R m -> R n -> R o -> R z
ap15 :: RefSrcPos -> RefExp -> R (Fun a (Fun b (Fun c (Fun d (Fun e (Fun g (Fun h (Fun i (Fun j (Fun k (Fun l (Fun m (Fun n (Fun o (Fun q z))))))))))))))) -> R a -> R b -> R c -> R d -> R e -> R g -> R h -> R i -> R j -> R k -> R l -> R m -> R n -> R o -> R q -> R z
fun1 :: RefAtom -> RefSrcPos -> RefExp -> (R a -> RefExp -> R z) -> R (Fun a z)
fun2 :: RefAtom -> RefSrcPos -> RefExp -> (R a -> R b -> RefExp -> R z) -> R (Fun a (Fun b z))
fun3 :: RefAtom -> RefSrcPos -> RefExp -> (R a -> R b -> R c -> RefExp -> R z) -> R (Fun a (Fun b (Fun c z)))
fun4 :: RefAtom -> RefSrcPos -> RefExp -> (R a -> R b -> R c -> R d -> RefExp -> R z) -> R (Fun a (Fun b (Fun c (Fun d z))))
fun5 :: RefAtom -> RefSrcPos -> RefExp -> (R a -> R b -> R c -> R d -> R e -> RefExp -> R z) -> R (Fun a (Fun b (Fun c (Fun d (Fun e z)))))
fun6 :: RefAtom -> RefSrcPos -> RefExp -> (R a -> R b -> R c -> R d -> R e -> R g -> RefExp -> R z) -> R (Fun a (Fun b (Fun c (Fun d (Fun e (Fun g z))))))
fun7 :: RefAtom -> RefSrcPos -> RefExp -> (R a -> R b -> R c -> R d -> R e -> R g -> R h -> RefExp -> R z) -> R (Fun a (Fun b (Fun c (Fun d (Fun e (Fun g (Fun h z)))))))
fun8 :: RefAtom -> RefSrcPos -> RefExp -> (R a -> R b -> R c -> R d -> R e -> R g -> R h -> R i -> RefExp -> R z) -> R (Fun a (Fun b (Fun c (Fun d (Fun e (Fun g (Fun h (Fun i z))))))))
fun9 :: RefAtom -> RefSrcPos -> RefExp -> (R a -> R b -> R c -> R d -> R e -> R g -> R h -> R i -> R j -> RefExp -> R z) -> R (Fun a (Fun b (Fun c (Fun d (Fun e (Fun g (Fun h (Fun i (Fun j z)))))))))
fun10 :: RefAtom -> RefSrcPos -> RefExp -> (R a -> R b -> R c -> R d -> R e -> R g -> R h -> R i -> R j -> R k -> RefExp -> R z) -> R (Fun a (Fun b (Fun c (Fun d (Fun e (Fun g (Fun h (Fun i (Fun j (Fun k z))))))))))
fun11 :: RefAtom -> RefSrcPos -> RefExp -> (R a -> R b -> R c -> R d -> R e -> R g -> R h -> R i -> R j -> R k -> R l -> RefExp -> R z) -> R (Fun a (Fun b (Fun c (Fun d (Fun e (Fun g (Fun h (Fun i (Fun j (Fun k (Fun l z)))))))))))
fun12 :: RefAtom -> RefSrcPos -> RefExp -> (R a -> R b -> R c -> R d -> R e -> R g -> R h -> R i -> R j -> R k -> R l -> R m -> RefExp -> R z) -> R (Fun a (Fun b (Fun c (Fun d (Fun e (Fun g (Fun h (Fun i (Fun j (Fun k (Fun l (Fun m z))))))))))))
fun13 :: RefAtom -> RefSrcPos -> RefExp -> (R a -> R b -> R c -> R d -> R e -> R g -> R h -> R i -> R j -> R k -> R l -> R m -> R n -> RefExp -> R z) -> R (Fun a (Fun b (Fun c (Fun d (Fun e (Fun g (Fun h (Fun i (Fun j (Fun k (Fun l (Fun m (Fun n z)))))))))))))
fun14 :: RefAtom -> RefSrcPos -> RefExp -> (R a -> R b -> R c -> R d -> R e -> R g -> R h -> R i -> R j -> R k -> R l -> R m -> R n -> R o -> RefExp -> R z) -> R (Fun a (Fun b (Fun c (Fun d (Fun e (Fun g (Fun h (Fun i (Fun j (Fun k (Fun l (Fun m (Fun n (Fun o z))))))))))))))
fun15 :: RefAtom -> RefSrcPos -> RefExp -> (R a -> R b -> R c -> R d -> R e -> R g -> R h -> R i -> R j -> R k -> R l -> R m -> R n -> R o -> R q -> RefExp -> R z) -> R (Fun a (Fun b (Fun c (Fun d (Fun e (Fun g (Fun h (Fun i (Fun j (Fun k (Fun l (Fun m (Fun n (Fun o (Fun q z)))))))))))))))
uap1 :: RefSrcPos -> RefExp -> R (Fun a z) -> R a -> R z
uap2 :: RefSrcPos -> RefExp -> R (Fun a (Fun b z)) -> R a -> R b -> R z
uap3 :: RefSrcPos -> RefExp -> R (Fun a (Fun b (Fun c z))) -> R a -> R b -> R c -> R z
uap4 :: RefSrcPos -> RefExp -> R (Fun a (Fun b (Fun c (Fun d z)))) -> R a -> R b -> R c -> R d -> R z
uap5 :: RefSrcPos -> RefExp -> R (Fun a (Fun b (Fun c (Fun d (Fun e z))))) -> R a -> R b -> R c -> R d -> R e -> R z
uap6 :: RefSrcPos -> RefExp -> R (Fun a (Fun b (Fun c (Fun d (Fun e (Fun g z)))))) -> R a -> R b -> R c -> R d -> R e -> R g -> R z
uap7 :: RefSrcPos -> RefExp -> R (Fun a (Fun b (Fun c (Fun d (Fun e (Fun g (Fun h z))))))) -> R a -> R b -> R c -> R d -> R e -> R g -> R h -> R z
uap8 :: RefSrcPos -> RefExp -> R (Fun a (Fun b (Fun c (Fun d (Fun e (Fun g (Fun h (Fun i z)))))))) -> R a -> R b -> R c -> R d -> R e -> R g -> R h -> R i -> R z
ufun1 :: RefAtom -> RefSrcPos -> RefExp -> (R a -> RefExp -> R r) -> R (Fun a r)
ufun2 :: RefAtom -> RefSrcPos -> RefExp -> (R a -> R b -> RefExp -> R r) -> R (Fun a (Fun b r))
ufun3 :: RefAtom -> RefSrcPos -> RefExp -> (R a -> R b -> R c -> RefExp -> R r) -> R (Fun a (Fun b (Fun c r)))
ufun4 :: RefAtom -> RefSrcPos -> RefExp -> (R a -> R b -> R c -> R d -> RefExp -> R r) -> R (Fun a (Fun b (Fun c (Fun d r))))
ufun5 :: RefAtom -> RefSrcPos -> RefExp -> (R a -> R b -> R c -> R d -> R e -> RefExp -> R r) -> R (Fun a (Fun b (Fun c (Fun d (Fun e r)))))
ufun6 :: RefAtom -> RefSrcPos -> RefExp -> (R a -> R b -> R c -> R d -> R e -> R g -> RefExp -> R r) -> R (Fun a (Fun b (Fun c (Fun d (Fun e (Fun g r))))))
ufun7 :: RefAtom -> RefSrcPos -> RefExp -> (R a -> R b -> R c -> R d -> R e -> R g -> R h -> RefExp -> R r) -> R (Fun a (Fun b (Fun c (Fun d (Fun e (Fun g (Fun h r)))))))
ufun8 :: RefAtom -> RefSrcPos -> RefExp -> (R a -> R b -> R c -> R d -> R e -> R g -> R h -> R i -> RefExp -> R r) -> R (Fun a (Fun b (Fun c (Fun d (Fun e (Fun g (Fun h (Fun i r))))))))
app1 :: RefSrcPos -> RefSrcPos -> RefExp -> RefAtom -> (R a -> RefExp -> R z) -> R a -> R z
app2 :: RefSrcPos -> RefSrcPos -> RefExp -> RefAtom -> (R a -> R b -> RefExp -> R z) -> R a -> R b -> R z
app3 :: RefSrcPos -> RefSrcPos -> RefExp -> RefAtom -> (R a -> R b -> R c -> RefExp -> R z) -> R a -> R b -> R c -> R z
app4 :: RefSrcPos -> RefSrcPos -> RefExp -> RefAtom -> (R a -> R b -> R c -> R d -> RefExp -> R z) -> R a -> R b -> R c -> R d -> R z
app5 :: RefSrcPos -> RefSrcPos -> RefExp -> RefAtom -> (R a -> R b -> R c -> R d -> R e -> RefExp -> R z) -> R a -> R b -> R c -> R d -> R e -> R z
uapp1 :: RefSrcPos -> RefSrcPos -> RefExp -> RefAtom -> (R a -> RefExp -> R z) -> R a -> R z
uapp2 :: RefSrcPos -> RefSrcPos -> RefExp -> RefAtom -> (R a -> R b -> RefExp -> R z) -> R a -> R b -> R z
uapp3 :: RefSrcPos -> RefSrcPos -> RefExp -> RefAtom -> (R a -> R b -> R c -> RefExp -> R z) -> R a -> R b -> R c -> R z
uapp4 :: RefSrcPos -> RefSrcPos -> RefExp -> RefAtom -> (R a -> R b -> R c -> R d -> RefExp -> R z) -> R a -> R b -> R c -> R d -> R z
uapp5 :: RefSrcPos -> RefSrcPos -> RefExp -> RefAtom -> (R a -> R b -> R c -> R d -> R e -> RefExp -> R z) -> R a -> R b -> R c -> R d -> R e -> R z
uwrapForward :: RefExp -> R a -> R a
con0 :: RefSrcPos -> RefExp -> z -> RefAtom -> R z
con1 :: RefSrcPos -> RefExp -> (R a -> z) -> RefAtom -> R a -> R z
con2 :: RefSrcPos -> RefExp -> (R a -> R b -> z) -> RefAtom -> R a -> R b -> R z
con3 :: RefSrcPos -> RefExp -> (R a -> R b -> R c -> z) -> RefAtom -> R a -> R b -> R c -> R z
con4 :: RefSrcPos -> RefExp -> (R a -> R b -> R c -> R d -> z) -> RefAtom -> R a -> R b -> R c -> R d -> R z
con5 :: RefSrcPos -> RefExp -> (R a -> R b -> R c -> R d -> R e -> z) -> RefAtom -> R a -> R b -> R c -> R d -> R e -> R z
con6 :: RefSrcPos -> RefExp -> (R a -> R b -> R c -> R d -> R e -> R f -> z) -> RefAtom -> R a -> R b -> R c -> R d -> R e -> R f -> R z
con7 :: RefSrcPos -> RefExp -> (R a -> R b -> R c -> R d -> R e -> R f -> R g -> z) -> RefAtom -> R a -> R b -> R c -> R d -> R e -> R f -> R g -> R z
con8 :: RefSrcPos -> RefExp -> (R a -> R b -> R c -> R d -> R e -> R f -> R g -> R h -> z) -> RefAtom -> R a -> R b -> R c -> R d -> R e -> R f -> R g -> R h -> R z
con9 :: RefSrcPos -> RefExp -> (R a -> R b -> R c -> R d -> R e -> R f -> R g -> R h -> R i -> z) -> RefAtom -> R a -> R b -> R c -> R d -> R e -> R f -> R g -> R h -> R i -> R z
con10 :: RefSrcPos -> RefExp -> (R a -> R b -> R c -> R d -> R e -> R f -> R g -> R h -> R i -> R j -> z) -> RefAtom -> R a -> R b -> R c -> R d -> R e -> R f -> R g -> R h -> R i -> R j -> R z
con11 :: RefSrcPos -> RefExp -> (R a -> R b -> R c -> R d -> R e -> R f -> R g -> R h -> R i -> R j -> R k -> z) -> RefAtom -> R a -> R b -> R c -> R d -> R e -> R f -> R g -> R h -> R i -> R j -> R k -> R z
con12 :: RefSrcPos -> RefExp -> (R a -> R b -> R c -> R d -> R e -> R f -> R g -> R h -> R i -> R j -> R k -> R l -> z) -> RefAtom -> R a -> R b -> R c -> R d -> R e -> R f -> R g -> R h -> R i -> R j -> R k -> R l -> R z
con13 :: RefSrcPos -> RefExp -> (R a -> R b -> R c -> R d -> R e -> R f -> R g -> R h -> R i -> R j -> R k -> R l -> R m -> z) -> RefAtom -> R a -> R b -> R c -> R d -> R e -> R f -> R g -> R h -> R i -> R j -> R k -> R l -> R m -> R z
con14 :: RefSrcPos -> RefExp -> (R a -> R b -> R c -> R d -> R e -> R f -> R g -> R h -> R i -> R j -> R k -> R l -> R m -> R n -> z) -> RefAtom -> R a -> R b -> R c -> R d -> R e -> R f -> R g -> R h -> R i -> R j -> R k -> R l -> R m -> R n -> R z
con15 :: RefSrcPos -> RefExp -> (R a -> R b -> R c -> R d -> R e -> R f -> R g -> R h -> R i -> R j -> R k -> R l -> R m -> R n -> R o -> z) -> RefAtom -> R a -> R b -> R c -> R d -> R e -> R f -> R g -> R h -> R i -> R j -> R k -> R l -> R m -> R n -> R o -> R z
pa0 :: b -> (b -> RefExp -> c) -> RefSrcPos -> RefExp -> RefAtom -> c
pa1 :: (R a1 -> b) -> (b -> RefExp -> c) -> RefSrcPos -> RefExp -> RefAtom -> R a1 -> c
pa2 :: (R a1 -> R a2 -> b) -> (b -> RefExp -> c) -> RefSrcPos -> RefExp -> RefAtom -> R a1 -> R a2 -> c
pa3 :: (R a1 -> R a2 -> R a3 -> b) -> (b -> RefExp -> c) -> RefSrcPos -> RefExp -> RefAtom -> R a1 -> R a2 -> R a3 -> c
pa4 :: (R a1 -> R a2 -> R a3 -> R a4 -> b) -> (b -> RefExp -> c) -> RefSrcPos -> RefExp -> RefAtom -> R a1 -> R a2 -> R a3 -> R a4 -> c
pa5 :: (R a1 -> R a2 -> R a3 -> R a4 -> R a5 -> b) -> (b -> RefExp -> c) -> RefSrcPos -> RefExp -> RefAtom -> R a1 -> R a2 -> R a3 -> R a4 -> R a5 -> c
pa6 :: (R a1 -> R a2 -> R a3 -> R a4 -> R a5 -> R a6 -> b) -> (b -> RefExp -> c) -> RefSrcPos -> RefExp -> RefAtom -> R a1 -> R a2 -> R a3 -> R a4 -> R a5 -> R a6 -> c
pa7 :: (R a1 -> R a2 -> R a3 -> R a4 -> R a5 -> R a6 -> R a7 -> b) -> (b -> RefExp -> c) -> RefSrcPos -> RefExp -> RefAtom -> R a1 -> R a2 -> R a3 -> R a4 -> R a5 -> R a6 -> R a7 -> c
pa8 :: (R a1 -> R a2 -> R a3 -> R a4 -> R a5 -> R a6 -> R a7 -> R a8 -> b) -> (b -> RefExp -> c) -> RefSrcPos -> RefExp -> RefAtom -> R a1 -> R a2 -> R a3 -> R a4 -> R a5 -> R a6 -> R a7 -> R a8 -> c
cn1 :: (R a1 -> b) -> RefExp -> R (Fun a1 b)
cn2 :: (R a1 -> R a2 -> b) -> RefExp -> R (Fun a1 (Fun a2 b))
cn3 :: (R a1 -> R a2 -> R a3 -> b) -> RefExp -> R (Fun a1 (Fun a2 (Fun a3 b)))
cn4 :: (R a1 -> R a2 -> R a3 -> R a4 -> b) -> RefExp -> R (Fun a1 (Fun a2 (Fun a3 (Fun a4 b))))
cn5 :: (R a1 -> R a2 -> R a3 -> R a4 -> R a5 -> b) -> RefExp -> R (Fun a1 (Fun a2 (Fun a3 (Fun a4 (Fun a5 b)))))
cn6 :: (R a1 -> R a2 -> R a3 -> R a4 -> R a5 -> R a6 -> b) -> RefExp -> R (Fun a1 (Fun a2 (Fun a3 (Fun a4 (Fun a5 (Fun a6 b))))))
cn7 :: (R a1 -> R a2 -> R a3 -> R a4 -> R a5 -> R a6 -> R a7 -> b) -> RefExp -> R (Fun a1 (Fun a2 (Fun a3 (Fun a4 (Fun a5 (Fun a6 (Fun a7 b)))))))
cn8 :: (R a1 -> R a2 -> R a3 -> R a4 -> R a5 -> R a6 -> R a7 -> R a8 -> b) -> RefExp -> R (Fun a1 (Fun a2 (Fun a3 (Fun a4 (Fun a5 (Fun a6 (Fun a7 (Fun a8 b))))))))
cn9 :: (R a1 -> R a2 -> R a3 -> R a4 -> R a5 -> R a6 -> R a7 -> R a8 -> R a9 -> b) -> RefExp -> R (Fun a1 (Fun a2 (Fun a3 (Fun a4 (Fun a5 (Fun a6 (Fun a7 (Fun a8 (Fun a9 b)))))))))
cn10 :: (R a1 -> R a2 -> R a3 -> R a4 -> R a5 -> R a6 -> R a7 -> R a8 -> R a9 -> R a10 -> b) -> RefExp -> R (Fun a1 (Fun a2 (Fun a3 (Fun a4 (Fun a5 (Fun a6 (Fun a7 (Fun a8 (Fun a9 (Fun a10 b))))))))))
cn11 :: (R a1 -> R a2 -> R a3 -> R a4 -> R a5 -> R a6 -> R a7 -> R a8 -> R a9 -> R a10 -> R a11 -> b) -> RefExp -> R (Fun a1 (Fun a2 (Fun a3 (Fun a4 (Fun a5 (Fun a6 (Fun a7 (Fun a8 (Fun a9 (Fun a10 (Fun a11 b)))))))))))
cn12 :: (R a1 -> R a2 -> R a3 -> R a4 -> R a5 -> R a6 -> R a7 -> R a8 -> R a9 -> R a10 -> R a11 -> R a12 -> b) -> RefExp -> R (Fun a1 (Fun a2 (Fun a3 (Fun a4 (Fun a5 (Fun a6 (Fun a7 (Fun a8 (Fun a9 (Fun a10 (Fun a11 (Fun a12 b))))))))))))
cguard :: RefSrcPos -> RefExp -> R Bool -> (RefExp -> R a) -> (RefExp -> R a) -> R a
ucguard :: R Bool -> R a -> R a -> R a
cif :: RefSrcPos -> RefExp -> R Bool -> (RefExp -> R a) -> (RefExp -> R a) -> R a
ucif :: RefExp -> R Bool -> R a -> R a -> R a
ccase :: RefSrcPos -> RefExp -> (R a -> RefExp -> R b) -> R a -> R b
uccase :: RefSrcPos -> RefExp -> (R a -> RefExp -> R b) -> R a -> R b
constUse :: RefSrcPos -> RefExp -> R a -> R a
uconstUse :: RefSrcPos -> RefExp -> R a -> R a
constDef :: RefExp -> RefAtom -> (RefExp -> R a) -> R a
uconstDef :: RefExp -> RefAtom -> (RefExp -> R a) -> R a
projection :: RefSrcPos -> RefExp -> R a -> R a
class WrapVal a
wrapVal :: WrapVal a => RefSrcPos -> a -> RefExp -> R a
update1 :: WrapVal a => RefSrcPos -> RefExp -> R a -> (a -> a) -> RefAtom -> R b -> R a
update2 :: WrapVal a => RefSrcPos -> RefExp -> R a -> (a -> a) -> RefAtom -> RefAtom -> R b -> R c -> R a
uupdate :: WrapVal a => RefExp -> R a -> (a -> a) -> R a
conChar :: RefSrcPos -> RefExp -> Char -> R Char
conInteger :: RefSrcPos -> RefExp -> Integer -> R Integer
mkAtomRational :: RefSrcPos -> RefExp -> Rational -> RefExp
fromExpList :: RefSrcPos -> RefExp -> [R a] -> R (List a)
fromLitString :: RefSrcPos -> RefExp -> String -> R (List Char)
traceIO :: String -> R (IO a) -> IO ()
hatError :: RefExp -> String -> a
fatal :: RefExp -> a
outputTrace :: RefExp -> String -> IO ()
wrapForward :: RefExp -> R a -> R a
mkModule :: String -> String -> Bool -> RefModule
mkSrcPos :: RefModule -> Loc -> Loc -> RefSrcPos
mkNoSrcPos :: RefSrcPos
mkRoot :: RefExp
mkValueUse :: RefExp -> RefSrcPos -> RefAtom -> RefExp
mkValueApp1 :: RefExp -> RefSrcPos -> RefAtom -> RefExp -> RefExp
mkValueApp2 :: RefExp -> RefSrcPos -> RefAtom -> RefExp -> RefExp -> RefExp
mkValueApp3 :: RefExp -> RefSrcPos -> RefAtom -> RefExp -> RefExp -> RefExp -> RefExp
mkValueApp4 :: RefExp -> RefSrcPos -> RefAtom -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp
mkValueApp5 :: RefExp -> RefSrcPos -> RefAtom -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp
mkValueApp6 :: RefExp -> RefSrcPos -> RefAtom -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp
mkValueApp7 :: RefExp -> RefSrcPos -> RefAtom -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp
mkValueApp8 :: RefExp -> RefSrcPos -> RefAtom -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp
mkValueApp9 :: RefExp -> RefSrcPos -> RefAtom -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp
mkValueApp10 :: RefExp -> RefSrcPos -> RefAtom -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp
mkValueApp11 :: RefExp -> RefSrcPos -> RefAtom -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp
mkValueApp12 :: RefExp -> RefSrcPos -> RefAtom -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp
mkValueApp13 :: RefExp -> RefSrcPos -> RefAtom -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp
mkValueApp14 :: RefExp -> RefSrcPos -> RefAtom -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp
mkValueApp15 :: RefExp -> RefSrcPos -> RefAtom -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp
mkApp1 :: RefExp -> RefSrcPos -> RefExp -> RefExp -> RefExp
mkApp2 :: RefExp -> RefSrcPos -> RefExp -> RefExp -> RefExp -> RefExp
mkApp3 :: RefExp -> RefSrcPos -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp
mkApp4 :: RefExp -> RefSrcPos -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp
mkApp5 :: RefExp -> RefSrcPos -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp
mkApp6 :: RefExp -> RefSrcPos -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp
mkApp7 :: RefExp -> RefSrcPos -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp
mkApp8 :: RefExp -> RefSrcPos -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp
mkApp9 :: RefExp -> RefSrcPos -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp
mkApp10 :: RefExp -> RefSrcPos -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp
mkApp11 :: RefExp -> RefSrcPos -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp
mkApp12 :: RefExp -> RefSrcPos -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp
mkApp13 :: RefExp -> RefSrcPos -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp
mkApp14 :: RefExp -> RefSrcPos -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp
mkApp15 :: RefExp -> RefSrcPos -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp -> RefExp
mkLambda :: RefAtom
mkVariable :: RefModule -> Loc -> Loc -> Fixity -> Arity -> String -> Bool -> RefAtom
mkConstructor :: RefModule -> Loc -> Loc -> Fixity -> Arity -> String -> RefAtom
mkConstructorWFields :: RefModule -> Loc -> Loc -> Fixity -> Arity -> String -> [RefAtom] -> RefAtom
mkAbstract :: String -> RefAtom
mkDoLambda :: RefAtom
instance Eq RefExp

module Hat.PreludeBuiltinTypes
newtype Fun a b
Fun :: (RefExp -> R a -> R b) -> Fun a b

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int :: *

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) characters (see
--   <a>http://www.unicode.org/</a> for details). This set extends the ISO
--   8859-1 (Latin-1) character set (the first 256 characters), which is
--   itself an extension of the ASCII character set (the first 128
--   characters). A character literal in Haskell has type <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <tt>ord</tt> and
--   <tt>chr</tt>).
data Char :: *

-- | Arbitrary-precision integers.
data Integer :: *

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float :: *

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double :: *
data Bool :: *
False :: Bool
True :: Bool

-- | The Haskell 2010 type for exceptions in the <a>IO</a> monad. Any I/O
--   operation may raise an <a>IOError</a> instead of returning a result.
--   For a more general type of exception, including also those that arise
--   in pure code, see <a>Control.Exception.Exception</a>.
--   
--   In Haskell 2010, this is an opaque type.
type IOError = IOException
aTrue :: RefAtom
aFalse :: RefAtom
type String = List Char
toFun :: (RefExp -> c -> R a) -> (RefExp -> R b -> d) -> RefExp -> R (Fun a b) -> (c -> d)
fromFun :: (RefExp -> R a -> b) -> (RefExp -> c -> R d) -> RefExp -> (b -> c) -> R (Fun a d)
toBool :: RefExp -> R Bool -> Bool
fromBool :: RefExp -> Bool -> R Bool
toList :: (RefExp -> R a -> b) -> RefExp -> R (List a) -> [b]
fromList :: (RefExp -> a -> R b) -> RefExp -> [a] -> R (List b)
toString :: RefExp -> R String -> String
fromString :: RefExp -> String -> R String
toIOError :: RefExp -> R IOError -> IOError
fromIOError :: RefExp -> IOError -> R IOError
aIOError :: RefAtom
gerror :: RefSrcPos -> RefExp -> R (Fun String z)
herror :: R String -> RefExp -> a
aerror :: RefAtom
gundefined :: RefSrcPos -> RefExp -> R a
hundefined :: RefExp -> a
aundefined :: RefAtom

module Hat.PreludeBasic
gyield :: RefSrcPos -> RefExp -> R (Fun a (ReadS a))
hyield :: R a -> R (ReadS___1 a) -> RefExp -> R (ReadS___2 a)
glift :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b (ReadS c))) (Fun (ReadS a) (Fun (ReadS b) (ReadS c))))
hlift :: R (Fun a (Fun b (ReadS c))) -> R (ReadS a) -> R (ReadS b) -> R (ReadS___1 c) -> RefExp -> R (ReadS___2 c)
gthenAp :: RefSrcPos -> RefExp -> R (Fun (ReadS (Fun a b)) (Fun (ReadS a) (ReadS b)))
gthenLex :: RefSrcPos -> RefExp -> R (Fun (ReadS a) (Fun String (ReadS a)))
hthenLex :: R (ReadS a) -> R String -> RefExp -> R (ReadS a)
galt :: RefSrcPos -> RefExp -> R (Fun (ReadS a) (Fun (ReadS a) (ReadS a)))
halt :: R (ReadS a) -> R (ReadS a) -> R (ReadS___1 a) -> RefExp -> R (ReadS___2 a)
gguard :: RefSrcPos -> RefExp -> R (Fun Bool (List Tuple0))
hguard :: R Bool -> RefExp -> R (List Tuple0)
class Eq a where (%/=) !/= p = ufun2 (++>=*=+>=%+/=) (%/=) p (*/=) where (fx */= fy) p = uwrapForward p (hnot (uap2 mkNoSrcPos p ((!==) mkNoSrcPos p) fx fy) p) (%==) !== p = ufun2 (+^!=*=^!=%+==) (%==) p (*==) where (fx *== fy) p = uwrapForward p (hnot (uap2 mkNoSrcPos p ((!/=) mkNoSrcPos p) fx fy) p)
(!==, !/=) :: Eq a => RefSrcPos -> RefExp -> R (Fun a (Fun a Bool))
(|==, |/=) :: Eq a => R (Fun a (Fun a Bool))
class Eq a => Ord a where gcompare pcompare p = ufun2 c81v5v84v26compare pcompare p hcompare where hcompare fx fy p = ucguard (uap2 mkNoSrcPos p ((!==) mkNoSrcPos p) fx fy) (con0 mkNoSrcPos p EQ aEQ) (ucguard (uap2 mkNoSrcPos p ((!<=) mkNoSrcPos p) fx fy) (con0 mkNoSrcPos p LT aLT) (ucguard (gotherwise mkNoSrcPos p) (con0 mkNoSrcPos p GT aGT) (fatal p))) (%<=) !<= p = ufun2 (+@+=*=@+=&#<=) (%<=) p (*<=) where (fx *<= fy) p = uap2 mkNoSrcPos p ((!/=) mkNoSrcPos p) (uap2 mkNoSrcPos p (gcompare mkNoSrcPos p) fx fy) (con0 mkNoSrcPos p GT aGT) (%<) !< p = ufun2 (+@^=*=@^=&#<) (%<) p (*<) where (fx *< fy) p = uap2 mkNoSrcPos p ((!==) mkNoSrcPos p) (uap2 mkNoSrcPos p (gcompare mkNoSrcPos p) fx fy) (con0 mkNoSrcPos p LT aLT) (%>=) !>= p = ufun2 (+@@=*=@@=&#>=) (%>=) p (*>=) where (fx *>= fy) p = uap2 mkNoSrcPos p ((!/=) mkNoSrcPos p) (uap2 mkNoSrcPos p (gcompare mkNoSrcPos p) fx fy) (con0 mkNoSrcPos p LT aLT) (%>) !> p = ufun2 (+@>=*=@>=&#>) (%>) p (*>) where (fx *> fy) p = uap2 mkNoSrcPos p ((!==) mkNoSrcPos p) (uap2 mkNoSrcPos p (gcompare mkNoSrcPos p) fx fy) (con0 mkNoSrcPos p GT aGT) gmax pmax p = ufun2 c92v5v94v25max pmax p hmax where hmax fx fy p = ucguard (uap2 mkNoSrcPos p ((!<=) mkNoSrcPos p) fx fy) (projection mkNoSrcPos p fy) (ucguard (gotherwise mkNoSrcPos p) (projection mkNoSrcPos p fx) (fatal p)) gmin pmin p = ufun2 c95v5v97v25min pmin p hmin where hmin fx fy p = ucguard (uap2 mkNoSrcPos p ((!<=) mkNoSrcPos p) fx fy) (projection mkNoSrcPos p fx) (ucguard (gotherwise mkNoSrcPos p) (projection mkNoSrcPos p fy) (fatal p))
gcompare :: Ord a => RefSrcPos -> RefExp -> R (Fun a (Fun a Ordering))
scompare :: Ord a => R (Fun a (Fun a Ordering))
(!<, !>, !>=, !<=) :: Ord a => RefSrcPos -> RefExp -> R (Fun a (Fun a Bool))
(|<, |>, |>=, |<=) :: Ord a => R (Fun a (Fun a Bool))
gmax, gmin :: Ord a => RefSrcPos -> RefExp -> R (Fun a (Fun a a))
smax, smin :: Ord a => R (Fun a (Fun a a))
class Enum a where stoEnum = gundefined mkNoSrcPos p sfromEnum = gundefined mkNoSrcPos p gsucc psucc p = uconstUse psucc p ssucc ssucc = uconstDef p c117v5v117v48succ (\ p -> uap2 mkNoSrcPos p ((!.) mkNoSrcPos p) (gtoEnum mkNoSrcPos p) (uap2 mkNoSrcPos p ((!.) mkNoSrcPos p) (uap2 mkNoSrcPos p (gflip mkNoSrcPos p) ((!+) mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (1)))) (gfromEnum mkNoSrcPos p))) gpred ppred p = uconstUse ppred p spred spred = uconstDef p c118v5v118v56pred (\ p -> uap2 mkNoSrcPos p ((!.) mkNoSrcPos p) (gtoEnum mkNoSrcPos p) (uap2 mkNoSrcPos p ((!.) mkNoSrcPos p) (uap1 mkNoSrcPos p (gsubtract mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (1)))) (gfromEnum mkNoSrcPos p))) genumFrom penumFrom p = ufun1 c119v5v119v50enumFrom penumFrom p henumFrom where henumFrom fx p = uwrapForward p (hmap (gtoEnum mkNoSrcPos p) (uap1 mkNoSrcPos p (genumFrom mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromEnum mkNoSrcPos p) fx)) p) genumFromTo penumFromTo p = ufun2 c120v5v120v61enumFromTo penumFromTo p henumFromTo where henumFromTo fx fy p = uwrapForward p (hmap (gtoEnum mkNoSrcPos p) (uap2 mkNoSrcPos p (genumFromTo mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromEnum mkNoSrcPos p) fx) (uap1 mkNoSrcPos p (gfromEnum mkNoSrcPos p) fy)) p) genumFromThen penumFromThen p = ufun2 c121v5v121v62enumFromThen penumFromThen p henumFromThen where henumFromThen fx fy p = uwrapForward p (hmap (gtoEnum mkNoSrcPos p) (uap2 mkNoSrcPos p (genumFromThen mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromEnum mkNoSrcPos p) fx) (uap1 mkNoSrcPos p (gfromEnum mkNoSrcPos p) fy)) p) genumFromThenTo penumFromThenTo p = ufun3 c122v5v123v73enumFromThenTo penumFromThenTo p henumFromThenTo where henumFromThenTo fx fy fz p = uwrapForward p (hmap (gtoEnum mkNoSrcPos p) (uap3 mkNoSrcPos p (genumFromThenTo mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromEnum mkNoSrcPos p) fx) (uap1 mkNoSrcPos p (gfromEnum mkNoSrcPos p) fy) (uap1 mkNoSrcPos p (gfromEnum mkNoSrcPos p) fz)) p)
gsucc, gpred :: Enum a => RefSrcPos -> RefExp -> R (Fun a a)
ssucc, spred :: Enum a => R (Fun a a)
gtoEnum :: Enum a => RefSrcPos -> RefExp -> R (Fun Int a)
stoEnum :: Enum a => R (Fun Int a)
gfromEnum :: Enum a => RefSrcPos -> RefExp -> R (Fun a Int)
sfromEnum :: Enum a => R (Fun a Int)
genumFrom :: Enum a => RefSrcPos -> RefExp -> R (Fun a (List a))
senumFrom :: Enum a => R (Fun a (List a))
genumFromThen :: Enum a => RefSrcPos -> RefExp -> R (Fun a (Fun a (List a)))
senumFromThen :: Enum a => R (Fun a (Fun a (List a)))
genumFromTo :: Enum a => RefSrcPos -> RefExp -> R (Fun a (Fun a (List a)))
senumFromTo :: Enum a => R (Fun a (Fun a (List a)))
genumFromThenTo :: Enum a => RefSrcPos -> RefExp -> R (Fun a (Fun a (Fun a (List a))))
senumFromThenTo :: Enum a => R (Fun a (Fun a (Fun a (List a))))
class Bounded a where sminBound = gundefined mkNoSrcPos p smaxBound = gundefined mkNoSrcPos p
gminBound :: Bounded a => RefSrcPos -> RefExp -> R a
sminBound :: Bounded a => R a
gmaxBound :: Bounded a => RefSrcPos -> RefExp -> R a
smaxBound :: Bounded a => R a
class (Eq a, Show a) => Num a where (|+) = gundefined mkNoSrcPos p (|*) = gundefined mkNoSrcPos p sabs = gundefined mkNoSrcPos p ssignum = gundefined mkNoSrcPos p sfromInteger = gundefined mkNoSrcPos p (%-) !- p = ufun2 (+#&#=*=#&#=%+-) (%-) p (*-) where (fx *- fy) p = uap2 mkNoSrcPos p ((!+) mkNoSrcPos p) fx (uap1 mkNoSrcPos p (gnegate mkNoSrcPos p) fy) gnegate pnegate p = ufun1 c142v5v142v29negate pnegate p hnegate where hnegate fx p = uap2 mkNoSrcPos p ((!-) mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0))) fx
(!+, !*, !-) :: Num a => RefSrcPos -> RefExp -> R (Fun a (Fun a a))
(|+, |*, |-) :: Num a => R (Fun a (Fun a a))
gnegate :: Num a => RefSrcPos -> RefExp -> R (Fun a a)
snegate :: Num a => R (Fun a a)
gabs, gsignum :: Num a => RefSrcPos -> RefExp -> R (Fun a a)
sabs, ssignum :: Num a => R (Fun a a)
gfromInteger :: Num a => RefSrcPos -> RefExp -> R (Fun Integer a)
sfromInteger :: Num a => R (Fun Integer a)
class (Num a, Ord a) => Real a where stoRational = gundefined mkNoSrcPos p
gtoRational :: Real a => RefSrcPos -> RefExp -> R (Fun a Rational)
stoRational :: Real a => R (Fun a Rational)
class (Real a, Enum a) => Integral a where squotRem = gundefined mkNoSrcPos p stoInteger = gundefined mkNoSrcPos p gquot pquot p = ufun2 c157v5v157v32quot pquot p hquot where hquot fn fd p = gq mkNoSrcPos p where gq pq p = uconstUse pq p sq gr pr p = uconstUse pr p sr sq = uconstDef p c157v34v157v52q (\ _ -> case j157v34v157v52q of { (kq, fq, fr) -> fq }) sr = uconstDef p c157v34v157v52r (\ _ -> case j157v34v157v52q of { (kq, fq, fr) -> fr }) j157v34v157v52q = case uap2 mkNoSrcPos p (gquotRem mkNoSrcPos p) fn fd of { R (Tuple2 fq fr) kq -> (kq, fq, fr) _ -> fatal p } grem prem p = ufun2 c158v5v158v32rem prem p hrem where hrem fn fd p = gr mkNoSrcPos p where gq pq p = uconstUse pq p sq gr pr p = uconstUse pr p sr sq = uconstDef p c158v34v158v52q (\ _ -> case j158v34v158v52q of { (kq, fq, fr) -> fq }) sr = uconstDef p c158v34v158v52r (\ _ -> case j158v34v158v52q of { (kq, fq, fr) -> fr }) j158v34v158v52q = case uap2 mkNoSrcPos p (gquotRem mkNoSrcPos p) fn fd of { R (Tuple2 fq fr) kq -> (kq, fq, fr) _ -> fatal p } gdiv pdiv p = ufun2 c159v5v159v32div pdiv p hdiv where hdiv fn fd p = gq mkNoSrcPos p where gq pq p = uconstUse pq p sq gr pr p = uconstUse pr p sr sq = uconstDef p c159v34v159v51q (\ _ -> case j159v34v159v51q of { (kq, fq, fr) -> fq }) sr = uconstDef p c159v34v159v51r (\ _ -> case j159v34v159v51q of { (kq, fq, fr) -> fr }) j159v34v159v51q = case uap2 mkNoSrcPos p (gdivMod mkNoSrcPos p) fn fd of { R (Tuple2 fq fr) kq -> (kq, fq, fr) _ -> fatal p } gmod pmod p = ufun2 c160v5v160v32mod pmod p hmod where hmod fn fd p = gr mkNoSrcPos p where gq pq p = uconstUse pq p sq gr pr p = uconstUse pr p sr sq = uconstDef p c160v34v160v51q (\ _ -> case j160v34v160v51q of { (kq, fq, fr) -> fq }) sr = uconstDef p c160v34v160v51r (\ _ -> case j160v34v160v51q of { (kq, fq, fr) -> fr }) j160v34v160v51q = case uap2 mkNoSrcPos p (gdivMod mkNoSrcPos p) fn fd of { R (Tuple2 fq fr) kq -> (kq, fq, fr) _ -> fatal p } gdivMod pdivMod p = ufun2 c161v5v164v29divMod pdivMod p hdivMod where hdivMod fn fd p = ucif p (uap2 mkNoSrcPos p ((!==) mkNoSrcPos p) (uap1 mkNoSrcPos p (gsignum mkNoSrcPos p) (gr mkNoSrcPos p)) (uap1 mkNoSrcPos p (gnegate mkNoSrcPos p) (uap1 mkNoSrcPos p (gsignum mkNoSrcPos p) fd))) (con2 mkNoSrcPos p Tuple2 aTuple2 (uap2 mkNoSrcPos p ((!-) mkNoSrcPos p) (gq mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (1)))) (uap2 mkNoSrcPos p ((!+) mkNoSrcPos p) (gr mkNoSrcPos p) fd)) (gqr mkNoSrcPos p) where gqr pqr p = uconstUse pqr p sqr sqr = uconstDef p c164v31v164v52qr (\ p -> uap2 mkNoSrcPos p (gquotRem mkNoSrcPos p) fn fd) gq pq p = uconstUse pq p sq gr pr p = uconstUse pr p sr sq = uconstDef p c164v31v164v52q (\ _ -> case j164v31v164v52q of { (kq, fq, fr) -> fq }) sr = uconstDef p c164v31v164v52r (\ _ -> case j164v31v164v52q of { (kq, fq, fr) -> fr }) j164v31v164v52q = case gqr mkNoSrcPos p of { R (Tuple2 fq fr) kq -> (kq, fq, fr) _ -> fatal p }
gquot, grem :: Integral a => RefSrcPos -> RefExp -> R (Fun a (Fun a a))
squot, srem :: Integral a => R (Fun a (Fun a a))
gdiv, gmod :: Integral a => RefSrcPos -> RefExp -> R (Fun a (Fun a a))
sdiv, smod :: Integral a => R (Fun a (Fun a a))
gquotRem, gdivMod :: Integral a => RefSrcPos -> RefExp -> R (Fun a (Fun a (Tuple2 a a)))
squotRem, sdivMod :: Integral a => R (Fun a (Fun a (Tuple2 a a)))
gtoInteger :: Integral a => RefSrcPos -> RefExp -> R (Fun a Integer)
stoInteger :: Integral a => R (Fun a Integer)
class Num a => Fractional a where sfromRational = gundefined mkNoSrcPos p grecip precip p = ufun1 c174v5v174v29recip precip p hrecip where hrecip fx p = uap2 mkNoSrcPos p ((!/) mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (1))) fx (%/) !/ p = ufun2 (+#^*=*=#^*=%*/) (%/) p (*/) where (fx */ fy) p = uap2 mkNoSrcPos p ((!*) mkNoSrcPos p) fx (uap1 mkNoSrcPos p (grecip mkNoSrcPos p) fy)
(!/) :: Fractional a => RefSrcPos -> RefExp -> R (Fun a (Fun a a))
(|/) :: Fractional a => R (Fun a (Fun a a))
grecip :: Fractional a => RefSrcPos -> RefExp -> R (Fun a a)
srecip :: Fractional a => R (Fun a a)
gfromRational :: Fractional a => RefSrcPos -> RefExp -> R (Fun Rational a)
sfromRational :: Fractional a => R (Fun Rational a)
class Fractional a => Floating a where spi = gundefined mkNoSrcPos p sexp = gundefined mkNoSrcPos p slog = gundefined mkNoSrcPos p ssin = gundefined mkNoSrcPos p scos = gundefined mkNoSrcPos p sasin = gundefined mkNoSrcPos p sacos = gundefined mkNoSrcPos p satan = gundefined mkNoSrcPos p ssinh = gundefined mkNoSrcPos p scosh = gundefined mkNoSrcPos p sasinh = gundefined mkNoSrcPos p sacosh = gundefined mkNoSrcPos p satanh = gundefined mkNoSrcPos p (%**) !** p = ufun2 (+#>#=*=#>#=%>**) (%**) p (***) where (fx *** fy) p = uap1 mkNoSrcPos p (gexp mkNoSrcPos p) (uap2 mkNoSrcPos p ((!*) mkNoSrcPos p) (uap1 mkNoSrcPos p (glog mkNoSrcPos p) fx) fy) glogBase plogBase p = ufun2 c192v5v192v37logBase plogBase p hlogBase where hlogBase fx fy p = uap2 mkNoSrcPos p ((!/) mkNoSrcPos p) (uap1 mkNoSrcPos p (glog mkNoSrcPos p) fy) (uap1 mkNoSrcPos p (glog mkNoSrcPos p) fx) gsqrt psqrt p = ufun1 c193v5v193v32sqrt psqrt p hsqrt where hsqrt fx p = uap2 mkNoSrcPos p ((!**) mkNoSrcPos p) fx (uap1 mkNoSrcPos p (gfromRational mkNoSrcPos p) (R ((:%) (conInteger mkNoSrcPos p (1)) (conInteger mkNoSrcPos p (2))) (mkAtomRational mkNoSrcPos p 0.5))) gtan ptan p = ufun1 c194v5v194v39tan ptan p htan where htan fx p = uap2 mkNoSrcPos p ((!/) mkNoSrcPos p) (uap1 mkNoSrcPos p (gsin mkNoSrcPos p) fx) (uap1 mkNoSrcPos p (gcos mkNoSrcPos p) fx) gtanh ptanh p = ufun1 c195v5v195v39tanh ptanh p htanh where htanh fx p = uap2 mkNoSrcPos p ((!/) mkNoSrcPos p) (uap1 mkNoSrcPos p (gsinh mkNoSrcPos p) fx) (uap1 mkNoSrcPos p (gcosh mkNoSrcPos p) fx)
gpi :: Floating a => RefSrcPos -> RefExp -> R a
spi :: Floating a => R a
gexp, gsqrt, glog :: Floating a => RefSrcPos -> RefExp -> R (Fun a a)
sexp, ssqrt, slog :: Floating a => R (Fun a a)
(!**, glogBase) :: Floating a => RefSrcPos -> RefExp -> R (Fun a (Fun a a))
(|**, slogBase) :: Floating a => R (Fun a (Fun a a))
gsin, gtan, gcos :: Floating a => RefSrcPos -> RefExp -> R (Fun a a)
ssin, stan, scos :: Floating a => R (Fun a a)
gasin, gatan, gacos :: Floating a => RefSrcPos -> RefExp -> R (Fun a a)
sasin, satan, sacos :: Floating a => R (Fun a a)
gsinh, gtanh, gcosh :: Floating a => RefSrcPos -> RefExp -> R (Fun a a)
ssinh, stanh, scosh :: Floating a => R (Fun a a)
gasinh, gatanh, gacosh :: Floating a => RefSrcPos -> RefExp -> R (Fun a a)
sasinh, satanh, sacosh :: Floating a => R (Fun a a)
class (Real a, Fractional a) => RealFrac a where sproperFraction = gundefined mkNoSrcPos p gtruncate ptruncate p = ufun1 c206v5v206v32truncate ptruncate p htruncate where htruncate fx p = gm mkNoSrcPos p where gm pm p = uconstUse pm p sm sm = uconstDef p c206v34v206v57m (\ _ -> case j206v34v206v57m of { (km, fm) -> fm }) j206v34v206v57m = case uap1 mkNoSrcPos p (gproperFraction mkNoSrcPos p) fx of { R (Tuple2 fm _) km -> (km, fm) _ -> fatal p } ground pround p = ufun1 c208v5v221v0round pround p hround where hround fx p = let gn pn p = uconstUse pn p sn gr pr p = uconstUse pr p sr sn = uconstDef p c208v29v208v52n (\ _ -> case j208v29v208v52n of { (kn, fn, fr) -> fn }) sr = uconstDef p c208v29v208v52r (\ _ -> case j208v29v208v52n of { (kn, fn, fr) -> fr }) j208v29v208v52n = case uap1 mkNoSrcPos p (gproperFraction mkNoSrcPos p) fx of { R (Tuple2 fn fr) kn -> (kn, fn, fr) _ -> fatal p } gm pm p = uconstUse pm p sm sm = uconstDef p c209v29v209v66m (\ p -> ucif p (uap2 mkNoSrcPos p ((!<) mkNoSrcPos p) (gr mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) (uap2 mkNoSrcPos p ((!-) mkNoSrcPos p) (gn mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (1)))) (uap2 mkNoSrcPos p ((!+) mkNoSrcPos p) (gn mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (1))))) in uccase mkNoSrcPos p (let v210v30v221v0v1 (R LT _) p = gn mkNoSrcPos p v210v30v221v0v1 (R EQ _) p = ucif p (uwrapForward p (heven (gn mkNoSrcPos p) p)) (gn mkNoSrcPos p) (gm mkNoSrcPos p) v210v30v221v0v1 (R GT _) p = gm mkNoSrcPos p v210v30v221v0v1 _ p = fatal p in v210v30v221v0v1) (uap2 mkNoSrcPos p (gcompare mkNoSrcPos p) (uap1 mkNoSrcPos p (gsignum mkNoSrcPos p) (uap2 mkNoSrcPos p ((!-) mkNoSrcPos p) (uap1 mkNoSrcPos p (gabs mkNoSrcPos p) (gr mkNoSrcPos p)) (uap1 mkNoSrcPos p (gfromRational mkNoSrcPos p) (R ((:%) (conInteger mkNoSrcPos p (1)) (conInteger mkNoSrcPos p (2))) (mkAtomRational mkNoSrcPos p 0.5))))) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) gceiling pceiling p = ufun1 c221v5v222v29ceiling pceiling p hceiling where hceiling fx p = ucif p (uap2 mkNoSrcPos p ((!>) mkNoSrcPos p) (gr mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) (uap2 mkNoSrcPos p ((!+) mkNoSrcPos p) (gn mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (1)))) (gn mkNoSrcPos p) where gn pn p = uconstUse pn p sn gr pr p = uconstUse pr p sr sn = uconstDef p c222v31v222v54n (\ _ -> case j222v31v222v54n of { (kn, fn, fr) -> fn }) sr = uconstDef p c222v31v222v54r (\ _ -> case j222v31v222v54n of { (kn, fn, fr) -> fr }) j222v31v222v54n = case uap1 mkNoSrcPos p (gproperFraction mkNoSrcPos p) fx of { R (Tuple2 fn fr) kn -> (kn, fn, fr) _ -> fatal p } gfloor pfloor p = ufun1 c224v5v225v29floor pfloor p hfloor where hfloor fx p = ucif p (uap2 mkNoSrcPos p ((!<) mkNoSrcPos p) (gr mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) (uap2 mkNoSrcPos p ((!-) mkNoSrcPos p) (gn mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (1)))) (gn mkNoSrcPos p) where gn pn p = uconstUse pn p sn gr pr p = uconstUse pr p sr sn = uconstDef p c225v31v225v54n (\ _ -> case j225v31v225v54n of { (kn, fn, fr) -> fn }) sr = uconstDef p c225v31v225v54r (\ _ -> case j225v31v225v54n of { (kn, fn, fr) -> fr }) j225v31v225v54n = case uap1 mkNoSrcPos p (gproperFraction mkNoSrcPos p) fx of { R (Tuple2 fn fr) kn -> (kn, fn, fr) _ -> fatal p }
gproperFraction :: (RealFrac a, Integral b) => RefSrcPos -> RefExp -> R (Fun a (Tuple2 b a))
sproperFraction :: (RealFrac a, Integral b) => R (Fun a (Tuple2 b a))
gtruncate, ground :: (RealFrac a, Integral b) => RefSrcPos -> RefExp -> R (Fun a b)
struncate, sround :: (RealFrac a, Integral b) => R (Fun a b)
gceiling, gfloor :: (RealFrac a, Integral b) => RefSrcPos -> RefExp -> R (Fun a b)
sceiling, sfloor :: (RealFrac a, Integral b) => R (Fun a b)
class (RealFrac a, Floating a) => RealFloat a where sfloatRadix = gundefined mkNoSrcPos p sfloatDigits = gundefined mkNoSrcPos p sfloatRange = gundefined mkNoSrcPos p sdecodeFloat = gundefined mkNoSrcPos p sencodeFloat = gundefined mkNoSrcPos p sisNaN = gundefined mkNoSrcPos p sisInfinite = gundefined mkNoSrcPos p sisDenormalized = gundefined mkNoSrcPos p sisNegativeZero = gundefined mkNoSrcPos p sisIEEE = gundefined mkNoSrcPos p gexponent pexponent p = ufun1 c244v5v245v29exponent pexponent p hexponent where hexponent fx p = ucif p (uap2 mkNoSrcPos p ((!==) mkNoSrcPos p) (gm mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0))) (uap2 mkNoSrcPos p ((!+) mkNoSrcPos p) (gn mkNoSrcPos p) (uap1 mkNoSrcPos p (gfloatDigits mkNoSrcPos p) fx)) where gm pm p = uconstUse pm p sm gn pn p = uconstUse pn p sn sm = uconstDef p c245v31v245v51m (\ _ -> case j245v31v245v51m of { (km, fm, fn) -> fm }) sn = uconstDef p c245v31v245v51n (\ _ -> case j245v31v245v51m of { (km, fm, fn) -> fn }) j245v31v245v51m = case uap1 mkNoSrcPos p (gdecodeFloat mkNoSrcPos p) fx of { R (Tuple2 fm fn) km -> (km, fm, fn) _ -> fatal p } gsignificand psignificand p = ufun1 c247v5v248v29significand psignificand p hsignificand where hsignificand fx p = uap2 mkNoSrcPos p (gencodeFloat mkNoSrcPos p) (gm mkNoSrcPos p) (uap1 mkNoSrcPos p (gnegate mkNoSrcPos p) (uap1 mkNoSrcPos p (gfloatDigits mkNoSrcPos p) fx)) where gm pm p = uconstUse pm p sm sm = uconstDef p c248v31v248v51m (\ _ -> case j248v31v248v51m of { (km, fm) -> fm }) j248v31v248v51m = case uap1 mkNoSrcPos p (gdecodeFloat mkNoSrcPos p) fx of { R (Tuple2 fm _) km -> (km, fm) _ -> fatal p } gscaleFloat pscaleFloat p = ufun2 c250v5v251v29scaleFloat pscaleFloat p hscaleFloat where hscaleFloat fk fx p = uap2 mkNoSrcPos p (gencodeFloat mkNoSrcPos p) (gm mkNoSrcPos p) (uap2 mkNoSrcPos p ((!+) mkNoSrcPos p) (gn mkNoSrcPos p) fk) where gm pm p = uconstUse pm p sm gn pn p = uconstUse pn p sn sm = uconstDef p c251v31v251v51m (\ _ -> case j251v31v251v51m of { (km, fm, fn) -> fm }) sn = uconstDef p c251v31v251v51n (\ _ -> case j251v31v251v51m of { (km, fm, fn) -> fn }) j251v31v251v51m = case uap1 mkNoSrcPos p (gdecodeFloat mkNoSrcPos p) fx of { R (Tuple2 fm fn) km -> (km, fm, fn) _ -> fatal p } gatan2 patan2 p = ufun2 c253v5v264v30atan2 patan2 p hatan2 where hatan2 fy fx p = ucguard (uap2 mkNoSrcPos p ((!>) mkNoSrcPos p) fx (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) (uap1 mkNoSrcPos p (gatan mkNoSrcPos p) (uap2 mkNoSrcPos p ((!/) mkNoSrcPos p) fy fx)) (ucguard (uwrapForward p ((*&&) (uap2 mkNoSrcPos p ((!==) mkNoSrcPos p) fx (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) (uap2 mkNoSrcPos p ((!>) mkNoSrcPos p) fy (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) p)) (uap2 mkNoSrcPos p ((!/) mkNoSrcPos p) (gpi mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (2)))) (ucguard (uwrapForward p ((*&&) (uap2 mkNoSrcPos p ((!<) mkNoSrcPos p) fx (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) (uap2 mkNoSrcPos p ((!>) mkNoSrcPos p) fy (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) p)) (uap2 mkNoSrcPos p ((!+) mkNoSrcPos p) (gpi mkNoSrcPos p) (uap1 mkNoSrcPos p (gatan mkNoSrcPos p) (uap2 mkNoSrcPos p ((!/) mkNoSrcPos p) fy fx))) (ucguard (uwrapForward p ((*||) (uwrapForward p ((*&&) (uap2 mkNoSrcPos p ((!<=) mkNoSrcPos p) fx (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) (uap2 mkNoSrcPos p ((!<) mkNoSrcPos p) fy (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) p)) (uwrapForward p ((*||) (uwrapForward p ((*&&) (uap2 mkNoSrcPos p ((!<) mkNoSrcPos p) fx (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) (uap1 mkNoSrcPos p (gisNegativeZero mkNoSrcPos p) fy) p)) (uwrapForward p ((*&&) (uap1 mkNoSrcPos p (gisNegativeZero mkNoSrcPos p) fx) (uap1 mkNoSrcPos p (gisNegativeZero mkNoSrcPos p) fy) p)) p)) p)) (uap1 mkNoSrcPos p (gnegate mkNoSrcPos p) (uap2 mkNoSrcPos p (gatan2 mkNoSrcPos p) (uap1 mkNoSrcPos p (gnegate mkNoSrcPos p) fy) fx)) (ucguard (uwrapForward p ((*&&) (uap2 mkNoSrcPos p ((!==) mkNoSrcPos p) fy (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) (uwrapForward p ((*||) (uap2 mkNoSrcPos p ((!<) mkNoSrcPos p) fx (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) (uap1 mkNoSrcPos p (gisNegativeZero mkNoSrcPos p) fx) p)) p)) (gpi mkNoSrcPos p) (ucguard (uwrapForward p ((*&&) (uap2 mkNoSrcPos p ((!==) mkNoSrcPos p) fx (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) (uap2 mkNoSrcPos p ((!==) mkNoSrcPos p) fy (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) p)) (projection mkNoSrcPos p fy) (ucguard (gotherwise mkNoSrcPos p) (uap2 mkNoSrcPos p ((!+) mkNoSrcPos p) fx fy) (fatal p)))))))
gfloatRadix :: RealFloat a => RefSrcPos -> RefExp -> R (Fun a Integer)
sfloatRadix :: RealFloat a => R (Fun a Integer)
gfloatDigits :: RealFloat a => RefSrcPos -> RefExp -> R (Fun a Int)
sfloatDigits :: RealFloat a => R (Fun a Int)
gfloatRange :: RealFloat a => RefSrcPos -> RefExp -> R (Fun a (Tuple2 Int Int))
sfloatRange :: RealFloat a => R (Fun a (Tuple2 Int Int))
gdecodeFloat :: RealFloat a => RefSrcPos -> RefExp -> R (Fun a (Tuple2 Integer Int))
sdecodeFloat :: RealFloat a => R (Fun a (Tuple2 Integer Int))
gencodeFloat :: RealFloat a => RefSrcPos -> RefExp -> R (Fun Integer (Fun Int a))
sencodeFloat :: RealFloat a => R (Fun Integer (Fun Int a))
gexponent :: RealFloat a => RefSrcPos -> RefExp -> R (Fun a Int)
sexponent :: RealFloat a => R (Fun a Int)
gsignificand :: RealFloat a => RefSrcPos -> RefExp -> R (Fun a a)
ssignificand :: RealFloat a => R (Fun a a)
gscaleFloat :: RealFloat a => RefSrcPos -> RefExp -> R (Fun Int (Fun a a))
sscaleFloat :: RealFloat a => R (Fun Int (Fun a a))
gisNaN, gisIEEE, gisNegativeZero, gisDenormalized, gisInfinite :: RealFloat a => RefSrcPos -> RefExp -> R (Fun a Bool)
sisNaN, sisIEEE, sisNegativeZero, sisDenormalized, sisInfinite :: RealFloat a => R (Fun a Bool)
gatan2 :: RealFloat a => RefSrcPos -> RefExp -> R (Fun a (Fun a a))
satan2 :: RealFloat a => R (Fun a (Fun a a))
gsubtract :: Num a => RefSrcPos -> RefExp -> R (Fun a (Fun a a))
geven :: Integral a => RefSrcPos -> RefExp -> R (Fun a Bool)
heven :: Integral a => R a -> RefExp -> R Bool
godd :: Integral a => RefSrcPos -> RefExp -> R (Fun a Bool)
ggcd :: Integral a => RefSrcPos -> RefExp -> R (Fun a (Fun a a))
hgcd :: Integral a => R a -> R a -> RefExp -> R a
glcm :: Integral a => RefSrcPos -> RefExp -> R (Fun a (Fun a a))
hlcm :: Integral a => R a -> R a -> RefExp -> R a
(!^) :: (Num a, Integral b) => RefSrcPos -> RefExp -> R (Fun a (Fun b a))
(*^) :: (Num a, Integral b) => R a -> R b -> RefExp -> R a
(!^^) :: (Fractional a, Integral b) => RefSrcPos -> RefExp -> R (Fun a (Fun b a))
(*^^) :: (Fractional a, Integral b) => R a -> R b -> RefExp -> R a
gfromIntegral :: (Integral a, Num b) => RefSrcPos -> RefExp -> R (Fun a b)
grealToFrac :: (Real a, Fractional b) => RefSrcPos -> RefExp -> R (Fun a b)
class Functor f where sfmap = gundefined mkNoSrcPos p
gfmap :: Functor f => RefSrcPos -> RefExp -> R (Fun (Fun a b) (Fun (f a) (f b)))
sfmap :: Functor f => R (Fun (Fun a b) (Fun (f a) (f b)))
class Monad m where (|>>=) = gundefined mkNoSrcPos p sreturn = gundefined mkNoSrcPos p (%>>) !>> p = ufun2 (+%$^=*=%$^=$@>>) (%>>) p (*>>) where (fm *>> fk) p = uap2 mkNoSrcPos p ((!>>=) mkNoSrcPos p) fm (ufun1 mkLambda mkNoSrcPos p (\ _ p -> projection mkNoSrcPos p fk)) gfail pfail p = ufun1 c328v5v328v21fail pfail p hfail where hfail fs p = uwrapForward p (herror fs p)
(!>>=) :: Monad m => RefSrcPos -> RefExp -> R (Fun (m a) (Fun (Fun a (m b)) (m b)))
(|>>=) :: Monad m => R (Fun (m a) (Fun (Fun a (m b)) (m b)))
(!>>) :: Monad m => RefSrcPos -> RefExp -> R (Fun (m a) (Fun (m b) (m b)))
(|>>) :: Monad m => R (Fun (m a) (Fun (m b) (m b)))
greturn :: Monad m => RefSrcPos -> RefExp -> R (Fun a (m a))
sreturn :: Monad m => R (Fun a (m a))
gfail :: Monad m => RefSrcPos -> RefExp -> R (Fun String (m a))
sfail :: Monad m => R (Fun String (m a))
gsequence :: Monad m => RefSrcPos -> RefExp -> R (Fun (List (m a)) (m (List a)))
gsequence_ :: Monad m => RefSrcPos -> RefExp -> R (Fun (List (m a)) (m Tuple0))
gmapM :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a (m b)) (Fun (List a) (m (List b))))
hmapM :: Monad m => R (Fun a (m b)) -> R (List a) -> RefExp -> R (m (List b))
gmapM_ :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a (m b)) (Fun (List a) (m Tuple0)))
hmapM_ :: Monad m => R (Fun a (m b)) -> R (List a) -> RefExp -> R (m Tuple0)
(!=<<) :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a (m b)) (Fun (m a) (m b)))
(*=<<) :: Monad m => R (Fun a (m b)) -> R (m a) -> RefExp -> R (m b)
gid :: RefSrcPos -> RefExp -> R (Fun a a)
hid :: R a -> RefExp -> R a
gconst :: RefSrcPos -> RefExp -> R (Fun a (Fun b a))
hconst :: R a -> R b -> RefExp -> R a
(!.) :: RefSrcPos -> RefExp -> R (Fun (Fun b c) (Fun (Fun a b) (Fun a c)))
(*.) :: R (Fun b c) -> R (Fun a b) -> R a -> RefExp -> R c
gflip :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b c)) (Fun b (Fun a c)))
hflip :: R (Fun a (Fun b c)) -> R b -> R a -> RefExp -> R c
(!$) :: RefSrcPos -> RefExp -> R (Fun (Fun a b) (Fun a b))
(*$) :: R (Fun a b) -> R a -> RefExp -> R b
(!$!) :: RefSrcPos -> RefExp -> R (Fun (Fun a b) (Fun a b))
(*$!) :: R (Fun a b) -> R a -> RefExp -> R b
(!&&) :: RefSrcPos -> RefExp -> R (Fun Bool (Fun Bool Bool))
(*&&) :: R Bool -> R Bool -> RefExp -> R Bool
(!||) :: RefSrcPos -> RefExp -> R (Fun Bool (Fun Bool Bool))
(*||) :: R Bool -> R Bool -> RefExp -> R Bool
gnot :: RefSrcPos -> RefExp -> R (Fun Bool Bool)
hnot :: R Bool -> RefExp -> R Bool
gotherwise :: RefSrcPos -> RefExp -> R Bool
data Maybe a
Nothing :: Maybe a
Just :: (R a) -> Maybe a
gmaybe :: RefSrcPos -> RefExp -> R (Fun b (Fun (Fun a b) (Fun (Maybe a) b)))
hmaybe :: R b -> R (Fun a b) -> R (Maybe a) -> RefExp -> R b
data Either a b
Left :: (R a) -> Either a b
Right :: (R b) -> Either a b
geither :: RefSrcPos -> RefExp -> R (Fun (Fun a c) (Fun (Fun b c) (Fun (Either a b) c)))
heither :: R (Fun a c) -> R (Fun b c) -> R (Either a b) -> RefExp -> R c
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering
gintEnumFromByTo :: RefSrcPos -> RefExp -> R (Fun Int (Fun Int (Fun Int (List Int))))
hintEnumFromByTo :: R Int -> R Int -> R Int -> RefExp -> R (List Int)
gnumericEnumFrom :: Fractional a => RefSrcPos -> RefExp -> R (Fun a (List a))
gnumericEnumFromThen :: Fractional a => RefSrcPos -> RefExp -> R (Fun a (Fun a (List a)))
hnumericEnumFromThen :: Fractional a => R a -> R a -> RefExp -> R (List a)
gnumericEnumFromTo :: (Fractional a, Ord a) => RefSrcPos -> RefExp -> R (Fun a (Fun a (List a)))
hnumericEnumFromTo :: (Fractional a, Ord a) => R a -> R a -> RefExp -> R (List a)
gnumericEnumFromThenTo :: (Fractional a, Ord a) => RefSrcPos -> RefExp -> R (Fun a (Fun a (Fun a (List a))))
hnumericEnumFromThenTo :: (Fractional a, Ord a) => R a -> R a -> R a -> RefExp -> R (List a)
gfst :: RefSrcPos -> RefExp -> R (Fun (Tuple2 a b) a)
hfst :: R (Tuple2 a b) -> RefExp -> R a
gsnd :: RefSrcPos -> RefExp -> R (Fun (Tuple2 a b) b)
hsnd :: R (Tuple2 a b) -> RefExp -> R b
gcurry :: RefSrcPos -> RefExp -> R (Fun (Fun (Tuple2 a b) c) (Fun a (Fun b c)))
hcurry :: R (Fun (Tuple2 a b) c) -> R a -> R b -> RefExp -> R c
guncurry :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b c)) (Fun (Tuple2 a b) c))
huncurry :: R (Fun a (Fun b c)) -> (R (Tuple2 a b) -> RefExp -> R c)
guntil :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (Fun a a) (Fun a a)))
huntil :: R (Fun a Bool) -> R (Fun a a) -> R a -> RefExp -> R a
gasTypeOf :: RefSrcPos -> RefExp -> R (Fun a (Fun a a))
g_foldr :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b b)) (Fun (List a) (Fun b b)))
h_foldr :: R (Fun a (Fun b b)) -> R (List a) -> R b -> RefExp -> R b
g_filter :: RefSrcPos -> RefExp -> R (Fun Bool (Fun (Fun (List a) (List a)) (Fun (List a) (List a))))
h_filter :: R Bool -> R (Fun (List a) (List a)) -> R (List a) -> RefExp -> R (List a)
gmap :: RefSrcPos -> RefExp -> R (Fun (Fun a b) (Fun (List a) (List b)))
hmap :: R (Fun a b) -> R (List a) -> RefExp -> R (List b)
(!++) :: RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List a) (List a)))
(*++) :: R (List a) -> R (List a) -> RefExp -> R (List a)
gfilter :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) (List a)))
hfilter :: R (Fun a Bool) -> R (List a) -> RefExp -> R (List a)
gconcat :: RefSrcPos -> RefExp -> R (Fun (List (List a)) (List a))
hconcat :: R (List (List a)) -> RefExp -> R (List a)
ghead :: RefSrcPos -> RefExp -> R (Fun (List a) a)
hhead :: R (List a) -> RefExp -> R a
glast :: RefSrcPos -> RefExp -> R (Fun (List a) a)
hlast :: R (List a) -> RefExp -> R a
gtail :: RefSrcPos -> RefExp -> R (Fun (List a) (List a))
htail :: R (List a) -> RefExp -> R (List a)
ginit :: RefSrcPos -> RefExp -> R (Fun (List a) (List a))
hinit :: R (List a) -> RefExp -> R (List a)
gnull :: RefSrcPos -> RefExp -> R (Fun (List a) Bool)
hnull :: R (List a) -> RefExp -> R Bool
glength :: RefSrcPos -> RefExp -> R (Fun (List a) Int)
hlength :: R (List a) -> RefExp -> R Int
(!!!) :: RefSrcPos -> RefExp -> R (Fun (List a) (Fun Int a))
(*!!) :: R (List a) -> R Int -> RefExp -> R a
gfoldl :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b a)) (Fun a (Fun (List b) a)))
hfoldl :: R (Fun a (Fun b a)) -> R a -> R (List b) -> RefExp -> R a
gfoldl1 :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a a)) (Fun (List a) a))
hfoldl1 :: R (Fun a (Fun a a)) -> R (List a) -> RefExp -> R a
gscanl :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b a)) (Fun a (Fun (List b) (List a))))
hscanl :: R (Fun a (Fun b a)) -> R a -> R (List b) -> RefExp -> R (List a)
gscanl1 :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a a)) (Fun (List a) (List a)))
hscanl1 :: R (Fun a (Fun a a)) -> R (List a) -> RefExp -> R (List a)
gfoldr :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b b)) (Fun b (Fun (List a) b)))
hfoldr :: R (Fun a (Fun b b)) -> R b -> R (List a) -> RefExp -> R b
gfoldr1 :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a a)) (Fun (List a) a))
hfoldr1 :: R (Fun a (Fun a a)) -> R (List a) -> RefExp -> R a
gscanr :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b b)) (Fun b (Fun (List a) (List b))))
hscanr :: R (Fun a (Fun b b)) -> R b -> R (List a) -> RefExp -> R (List b)
gscanr1 :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a a)) (Fun (List a) (List a)))
hscanr1 :: R (Fun a (Fun a a)) -> R (List a) -> RefExp -> R (List a)
giterate :: RefSrcPos -> RefExp -> R (Fun (Fun a a) (Fun a (List a)))
hiterate :: R (Fun a a) -> R a -> RefExp -> R (List a)
grepeat :: RefSrcPos -> RefExp -> R (Fun a (List a))
hrepeat :: R a -> RefExp -> R (List a)
greplicate :: RefSrcPos -> RefExp -> R (Fun Int (Fun a (List a)))
hreplicate :: R Int -> R a -> RefExp -> R (List a)
gcycle :: RefSrcPos -> RefExp -> R (Fun (List a) (List a))
hcycle :: R (List a) -> RefExp -> R (List a)
gtake :: RefSrcPos -> RefExp -> R (Fun Int (Fun (List a) (List a)))
htake :: R Int -> R (List a) -> RefExp -> R (List a)
gdrop :: RefSrcPos -> RefExp -> R (Fun Int (Fun (List a) (List a)))
hdrop :: R Int -> R (List a) -> RefExp -> R (List a)
gsplitAt :: RefSrcPos -> RefExp -> R (Fun Int (Fun (List a) (Tuple2 (List a) (List a))))
hsplitAt :: R Int -> R (List a) -> RefExp -> R (Tuple2 (List a) (List a))
gtakeWhile :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) (List a)))
htakeWhile :: R (Fun a Bool) -> R (List a) -> RefExp -> R (List a)
gdropWhile :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) (List a)))
hdropWhile :: R (Fun a Bool) -> R (List a) -> RefExp -> R (List a)
gspan :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) (Tuple2 (List a) (List a))))
hspan :: R (Fun a Bool) -> R (List a) -> RefExp -> R (Tuple2 (List a) (List a))
gbreak :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) (Tuple2 (List a) (List a))))
hbreak :: R (Fun a Bool) -> RefExp -> R (Fun (List a) (Tuple2 (List a) (List a)))
glines :: RefSrcPos -> RefExp -> R (Fun String (List String))
hlines :: R String -> RefExp -> R (List String)
gwords :: RefSrcPos -> RefExp -> R (Fun String (List String))
hwords :: R String -> RefExp -> R (List String)
gunlines :: RefSrcPos -> RefExp -> R (Fun (List String) String)
gunwords :: RefSrcPos -> RefExp -> R (Fun (List String) String)
hunwords :: R (List String) -> RefExp -> R String
greverse :: RefSrcPos -> RefExp -> R (Fun (List a) (List a))
gand :: RefSrcPos -> RefExp -> R (Fun (List Bool) Bool)
gor :: RefSrcPos -> RefExp -> R (Fun (List Bool) Bool)
gany :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) Bool))
hany :: R (Fun a Bool) -> RefExp -> R (Fun (List a) Bool)
gall :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) Bool))
hall :: R (Fun a Bool) -> RefExp -> R (Fun (List a) Bool)
gelem :: Eq a => RefSrcPos -> RefExp -> R (Fun a (Fun (List a) Bool))
helem :: Eq a => R a -> RefExp -> R (Fun (List a) Bool)
gnotElem :: Eq a => RefSrcPos -> RefExp -> R (Fun a (Fun (List a) Bool))
hnotElem :: Eq a => R a -> RefExp -> R (Fun (List a) Bool)
glookup :: Eq a => RefSrcPos -> RefExp -> R (Fun a (Fun (List (Tuple2 a b)) (Maybe b)))
hlookup :: Eq a => R a -> R (List (Tuple2 a b)) -> RefExp -> R (Maybe b)
gsum :: Num a => RefSrcPos -> RefExp -> R (Fun (List a) a)
gproduct :: Num a => RefSrcPos -> RefExp -> R (Fun (List a) a)
gmaximum :: Ord a => RefSrcPos -> RefExp -> R (Fun (List a) a)
hmaximum :: Ord a => R (List a) -> RefExp -> R a
gminimum :: Ord a => RefSrcPos -> RefExp -> R (Fun (List a) a)
hminimum :: Ord a => R (List a) -> RefExp -> R a
gconcatMap :: RefSrcPos -> RefExp -> R (Fun (Fun a (List b)) (Fun (List a) (List b)))
hconcatMap :: R (Fun a (List b)) -> RefExp -> R (Fun (List a) (List b))
gzip :: RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List b) (List (Tuple2 a b))))
gzip3 :: RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List b) (Fun (List c) (List (Tuple3 a b c)))))
gzipWith :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b c)) (Fun (List a) (Fun (List b) (List c))))
hzipWith :: R (Fun a (Fun b c)) -> R (List a) -> R (List b) -> RefExp -> R (List c)
gzipWith3 :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b (Fun c d))) (Fun (List a) (Fun (List b) (Fun (List c) (List d)))))
hzipWith3 :: R (Fun a (Fun b (Fun c d))) -> R (List a) -> R (List b) -> R (List c) -> RefExp -> R (List d)
gunzip :: RefSrcPos -> RefExp -> R (Fun (List (Tuple2 a b)) (Tuple2 (List a) (List b)))
gunzip3 :: RefSrcPos -> RefExp -> R (Fun (List (Tuple3 a b c)) (Tuple3 (List a) (List b) (List c)))
type ReadS a = Fun String (List (Tuple2 a String))
type ReadS___1 a = String
type ReadS___2 a = List (Tuple2 a String)
type ShowS = Fun String String
type ShowS___1 = String
type ShowS___2 = String
class Read a where sreadsPrec = gundefined mkNoSrcPos p greadList preadList p = uconstUse preadList p sreadList sreadList = uconstDef p c1810v5v1812v28readList (\ p -> let greadl preadl p = ufun1 c1812v30v1814v73readl preadl p hreadl areadl = c1812v30v1814v73readl hreadl fs p = uwrapForward p ((*++) (uap2 mkNoSrcPos p ((!>>=) mkNoSrcPos p) (uwrapForward p (hlex fs p)) (ufun1 mkDoLambda mkNoSrcPos p (\ fv1812v53v1812v63v1 p -> uccase mkNoSrcPos p (let v1812v53v1812v63v1 (R (Tuple2 (R (Cons (R ']' _) (R Nil _)) _) ft) _) p = uap1 mkNoSrcPos p (greturn mkNoSrcPos p) (con2 mkNoSrcPos p Tuple2 aTuple2 (con0 mkNoSrcPos p Nil aNil) ft) v1812v53v1812v63v1 _ p = uap1 mkNoSrcPos p (gfail mkNoSrcPos p) (fromLitString mkNoSrcPos p "pattern-match failure in do-expression") in v1812v53v1812v63v1) fv1812v53v1812v63v1))) (uap2 mkNoSrcPos p ((!>>=) mkNoSrcPos p) (uap1 mkNoSrcPos p (greads mkNoSrcPos p) fs) (ufun1 mkDoLambda mkNoSrcPos p (\ (R (Tuple2 fx ft) _) p -> uap2 mkNoSrcPos p ((!>>=) mkNoSrcPos p) (uwrapForward p (hreadl' ft p)) (ufun1 mkDoLambda mkNoSrcPos p (\ (R (Tuple2 fxs fu) _) p -> uap1 mkNoSrcPos p (greturn mkNoSrcPos p) (con2 mkNoSrcPos p Tuple2 aTuple2 (con2 mkNoSrcPos p Cons aCons fx fxs) fu)))))) p) greadl' preadl' p = ufun1 c1815v30v1818v73readl' preadl' p hreadl' areadl' = c1815v30v1818v73readl' hreadl' fs p = uwrapForward p ((*++) (uap2 mkNoSrcPos p ((!>>=) mkNoSrcPos p) (uwrapForward p (hlex fs p)) (ufun1 mkDoLambda mkNoSrcPos p (\ fv1815v53v1815v63v1 p -> uccase mkNoSrcPos p (let v1815v53v1815v63v1 (R (Tuple2 (R (Cons (R ']' _) (R Nil _)) _) ft) _) p = uap1 mkNoSrcPos p (greturn mkNoSrcPos p) (con2 mkNoSrcPos p Tuple2 aTuple2 (con0 mkNoSrcPos p Nil aNil) ft) v1815v53v1815v63v1 _ p = uap1 mkNoSrcPos p (gfail mkNoSrcPos p) (fromLitString mkNoSrcPos p "pattern-match failure in do-expression") in v1815v53v1815v63v1) fv1815v53v1815v63v1))) (uap2 mkNoSrcPos p ((!>>=) mkNoSrcPos p) (uwrapForward p (hlex fs p)) (ufun1 mkDoLambda mkNoSrcPos p (\ fv1816v53v1816v63v1 p -> uccase mkNoSrcPos p (let v1816v53v1816v63v1 (R (Tuple2 (R (Cons (R ',' _) (R Nil _)) _) ft) _) p = uap2 mkNoSrcPos p ((!>>=) mkNoSrcPos p) (uap1 mkNoSrcPos p (greads mkNoSrcPos p) ft) (ufun1 mkDoLambda mkNoSrcPos p (\ (R (Tuple2 fx fu) _) p -> uap2 mkNoSrcPos p ((!>>=) mkNoSrcPos p) (uwrapForward p (hreadl' fu p)) (ufun1 mkDoLambda mkNoSrcPos p (\ (R (Tuple2 fxs fv) _) p -> uap1 mkNoSrcPos p (greturn mkNoSrcPos p) (con2 mkNoSrcPos p Tuple2 aTuple2 (con2 mkNoSrcPos p Cons aCons fx fxs) fv))))) v1816v53v1816v63v1 _ p = uap1 mkNoSrcPos p (gfail mkNoSrcPos p) (fromLitString mkNoSrcPos p "pattern-match failure in do-expression") in v1816v53v1816v63v1) fv1816v53v1816v63v1))) p) in uwrapForward p (hreadParen (con0 mkNoSrcPos p False aFalse) (ufun1 mkLambda mkNoSrcPos p (\ fr p -> uap2 mkNoSrcPos p ((!>>=) mkNoSrcPos p) (uwrapForward p (hlex fr p)) (ufun1 mkDoLambda mkNoSrcPos p (\ fv1810v53v1810v63v1 p -> uccase mkNoSrcPos p (let v1810v53v1810v63v1 (R (Tuple2 (R (Cons (R '[' _) (R Nil _)) _) fs) _) p = uap2 mkNoSrcPos p ((!>>=) mkNoSrcPos p) (uwrapForward p (hreadl fs p)) (ufun1 mkDoLambda mkNoSrcPos p (\ fpr p -> uap1 mkNoSrcPos p (greturn mkNoSrcPos p) fpr)) v1810v53v1810v63v1 _ p = uap1 mkNoSrcPos p (gfail mkNoSrcPos p) (fromLitString mkNoSrcPos p "pattern-match failure in do-expression") in v1810v53v1810v63v1) fv1810v53v1810v63v1)))) p))
greadsPrec :: Read a => RefSrcPos -> RefExp -> R (Fun Int (ReadS a))
sreadsPrec :: Read a => R (Fun Int (ReadS a))
greadList :: Read a => RefSrcPos -> RefExp -> R (ReadS (List a))
sreadList :: Read a => R (ReadS (List a))
class Show a where gshowsPrec pshowsPrec p = ufun3 c1828v5v1828v35showsPrec pshowsPrec p hshowsPrec where hshowsPrec _ fx fs p = uwrapForward p ((*++) (uap1 mkNoSrcPos p (gshow mkNoSrcPos p) fx) fs p) gshow pshow p = ufun1 c1830v5v1830v36show pshow p hshow where hshow fx p = uap3 mkNoSrcPos p (gshowsPrec mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0))) fx (fromLitString mkNoSrcPos p "") gshowList pshowList p = ufun1 c1832v5v1838v0showList pshowList p hshowList where hshowList (R Nil _) p = uap1 mkNoSrcPos p (gshowString mkNoSrcPos p) (fromLitString mkNoSrcPos p "[]") hshowList (R (Cons fx fxs) _) p = uap2 mkNoSrcPos p ((!.) mkNoSrcPos p) (uap1 mkNoSrcPos p (gshowChar mkNoSrcPos p) (conChar mkNoSrcPos p '[')) (uap2 mkNoSrcPos p ((!.) mkNoSrcPos p) (uap1 mkNoSrcPos p (gshows mkNoSrcPos p) fx) (uwrapForward p (hshowl fxs p))) where gshowl pshowl p = ufun1 c1834v31v1836v53showl pshowl p hshowl ashowl = c1834v31v1836v53showl hshowl (R Nil _) p = uap1 mkNoSrcPos p (gshowChar mkNoSrcPos p) (conChar mkNoSrcPos p ']') hshowl (R (Cons fx fxs) _) p = uap2 mkNoSrcPos p ((!.) mkNoSrcPos p) (uap1 mkNoSrcPos p (gshowChar mkNoSrcPos p) (conChar mkNoSrcPos p ',')) (uap2 mkNoSrcPos p ((!.) mkNoSrcPos p) (uap1 mkNoSrcPos p (gshows mkNoSrcPos p) fx) (uwrapForward p (hshowl fxs p))) hshowl _ p = fatal p hshowList _ p = fatal p
gshowsPrec :: Show a => RefSrcPos -> RefExp -> R (Fun Int (Fun a ShowS))
sshowsPrec :: Show a => R (Fun Int (Fun a ShowS))
gshow :: Show a => RefSrcPos -> RefExp -> R (Fun a String)
sshow :: Show a => R (Fun a String)
gshowList :: Show a => RefSrcPos -> RefExp -> R (Fun (List a) ShowS)
sshowList :: Show a => R (Fun (List a) ShowS)
greads :: Read a => RefSrcPos -> RefExp -> R (ReadS a)
gshows :: Show a => RefSrcPos -> RefExp -> R (Fun a ShowS)
gread :: Read a => RefSrcPos -> RefExp -> R (Fun String a)
hread :: Read a => R String -> RefExp -> R a
gshowChar :: RefSrcPos -> RefExp -> R (Fun Char ShowS)
gshowString :: RefSrcPos -> RefExp -> R (Fun String ShowS)
gshowParen :: RefSrcPos -> RefExp -> R (Fun Bool (Fun ShowS ShowS))
hshowParen :: R Bool -> R ShowS -> RefExp -> R ShowS
greadParen :: RefSrcPos -> RefExp -> R (Fun Bool (Fun (ReadS a) (ReadS a)))
hreadParen :: R Bool -> R (ReadS a) -> RefExp -> R (ReadS a)
glex :: RefSrcPos -> RefExp -> R (ReadS String)
hlex :: R (ReadS___1 String) -> RefExp -> R (ReadS___2 String)
type FilePath = String
gputStr :: RefSrcPos -> RefExp -> R (Fun String (IO Tuple0))
hputStr :: R String -> RefExp -> R (IO Tuple0)
gputStrLn :: RefSrcPos -> RefExp -> R (Fun String (IO Tuple0))
hputStrLn :: R String -> RefExp -> R (IO Tuple0)
gprint :: Show a => RefSrcPos -> RefExp -> R (Fun a (IO Tuple0))
hprint :: Show a => R a -> RefExp -> R (IO Tuple0)
ggetLine :: RefSrcPos -> RefExp -> R (IO String)
ginteract :: RefSrcPos -> RefExp -> R (Fun (Fun String String) (IO Tuple0))
hinteract :: R (Fun String String) -> RefExp -> R (IO Tuple0)
greadIO :: Read a => RefSrcPos -> RefExp -> R (Fun String (IO a))
hreadIO :: Read a => R String -> RefExp -> R (IO a)
greadLn :: Read a => RefSrcPos -> RefExp -> R (IO a)
gdigitToInt :: RefSrcPos -> RefExp -> R (Fun Char Int)
hdigitToInt :: R Char -> RefExp -> R Int
gintToDigit :: RefSrcPos -> RefExp -> R (Fun Int Char)
hintToDigit :: R Int -> RefExp -> R Char
gord :: RefSrcPos -> RefExp -> R (Fun Char Int)
gchr :: RefSrcPos -> RefExp -> R (Fun Int Char)
greadLitChar :: RefSrcPos -> RefExp -> R (ReadS Char)
hreadLitChar :: R (ReadS___1 Char) -> RefExp -> R (ReadS___2 Char)
gshowLitChar :: RefSrcPos -> RefExp -> R (Fun Char ShowS)
hshowLitChar :: R Char -> RefExp -> R ShowS
gprotectEsc :: RefSrcPos -> RefExp -> R (Fun (Fun Char Bool) (Fun (Fun (List Char) c) (Fun (List Char) c)))
hprotectEsc :: R (Fun Char Bool) -> R (Fun (List Char) c) -> RefExp -> R (Fun (List Char) c)
gasciiTab :: RefSrcPos -> RefExp -> R (List (Tuple2 Char (List Char)))
glexLitChar :: RefSrcPos -> RefExp -> R (ReadS String)
hlexLitChar :: R (ReadS___1 String) -> RefExp -> R (ReadS___2 String)
gfromRat :: RealFloat a => RefSrcPos -> RefExp -> R (Fun Rational a)
hfromRat :: RealFloat a => R Rational -> RefExp -> R a
gfromRat' :: RealFloat a => RefSrcPos -> RefExp -> R (Fun Rational a)
hfromRat' :: RealFloat a => R Rational -> RefExp -> R a
gscaleRat :: RefSrcPos -> RefExp -> R (Fun Rational (Fun Int (Fun Rational (Fun Rational (Fun Int (Fun Rational (Tuple2 Rational Int)))))))
hscaleRat :: R Rational -> R Int -> R Rational -> R Rational -> R Int -> R Rational -> RefExp -> R (Tuple2 Rational Int)
gminExpt :: RefSrcPos -> RefExp -> R Int
gmaxExpt :: RefSrcPos -> RefExp -> R Int
gexpt :: RefSrcPos -> RefExp -> R (Fun Integer (Fun Int Integer))
hexpt :: R Integer -> R Int -> RefExp -> R Integer
gexpts :: RefSrcPos -> RefExp -> R (List Integer)
gintegerLogBase :: RefSrcPos -> RefExp -> R (Fun Integer (Fun Integer Int))
hintegerLogBase :: R Integer -> R Integer -> RefExp -> R Int
gshowSigned :: Real a => RefSrcPos -> RefExp -> R (Fun (Fun a ShowS) (Fun Int (Fun a ShowS)))
hshowSigned :: Real a => R (Fun a ShowS) -> R Int -> R a -> RefExp -> R ShowS
gshowOct :: Integral a => RefSrcPos -> RefExp -> R (Fun a ShowS)
gshowInt :: Integral a => RefSrcPos -> RefExp -> R (Fun a ShowS)
gshowHex :: Integral a => RefSrcPos -> RefExp -> R (Fun a ShowS)
gshowIntAtBase :: Integral a => RefSrcPos -> RefExp -> R (Fun a (Fun (Fun Int Char) (Fun a ShowS)))
hshowIntAtBase :: Integral a => R a -> R (Fun Int Char) -> R a -> R ShowS___1 -> RefExp -> R ShowS___2
greadSigned :: Real a => RefSrcPos -> RefExp -> R (Fun (ReadS a) (ReadS a))
hreadSigned :: Real a => R (ReadS a) -> RefExp -> R (ReadS a)
greadInt :: Integral a => RefSrcPos -> RefExp -> R (Fun a (Fun (Fun Char Bool) (Fun (Fun Char Int) (ReadS a))))
hreadInt :: Integral a => R a -> R (Fun Char Bool) -> R (Fun Char Int) -> R (ReadS___1 a) -> RefExp -> R (ReadS___2 a)
greadDec :: Integral a => RefSrcPos -> RefExp -> R (ReadS a)
greadOct :: Integral a => RefSrcPos -> RefExp -> R (ReadS a)
greadHex :: Integral a => RefSrcPos -> RefExp -> R (ReadS a)
gshowEFloat :: RealFloat a => RefSrcPos -> RefExp -> R (Fun (Maybe Int) (Fun a ShowS))
hshowEFloat :: RealFloat a => R (Maybe Int) -> R a -> RefExp -> R ShowS
gshowFFloat :: RealFloat a => RefSrcPos -> RefExp -> R (Fun (Maybe Int) (Fun a ShowS))
hshowFFloat :: RealFloat a => R (Maybe Int) -> R a -> RefExp -> R ShowS
gshowGFloat :: RealFloat a => RefSrcPos -> RefExp -> R (Fun (Maybe Int) (Fun a ShowS))
hshowGFloat :: RealFloat a => R (Maybe Int) -> R a -> RefExp -> R ShowS
gshowFloat :: RealFloat a => RefSrcPos -> RefExp -> R (Fun a ShowS)
data FFFormat
FFExponent :: FFFormat
FFFixed :: FFFormat
FFGeneric :: FFFormat
gformatRealFloat :: RealFloat a => RefSrcPos -> RefExp -> R (Fun FFFormat (Fun (Maybe Int) (Fun a String)))
hformatRealFloat :: RealFloat a => R FFFormat -> R (Maybe Int) -> R a -> RefExp -> R String
groundTo :: RefSrcPos -> RefExp -> R (Fun Int (Fun Int (Fun (List Int) (Tuple2 Int (List Int)))))
hroundTo :: R Int -> R Int -> R (List Int) -> RefExp -> R (Tuple2 Int (List Int))
gfloatToDigits :: RealFloat a => RefSrcPos -> RefExp -> R (Fun Integer (Fun a (Tuple2 (List Int) Int)))
hfloatToDigits :: RealFloat a => R Integer -> R a -> RefExp -> R (Tuple2 (List Int) Int)
greadFloat :: RealFloat a => RefSrcPos -> RefExp -> R (ReadS a)
hreadFloat :: RealFloat a => R (ReadS___1 a) -> RefExp -> R (ReadS___2 a)
glexDigits :: RefSrcPos -> RefExp -> R (ReadS String)
gnonnull :: RefSrcPos -> RefExp -> R (Fun (Fun Char Bool) (ReadS String))
hnonnull :: R (Fun Char Bool) -> R (ReadS___1 String) -> RefExp -> R (ReadS___2 String)
gprec :: RefSrcPos -> RefExp -> R Int
data Ratio a
(:%) :: !(R a) -> !(R a) -> Ratio a
type Rational = Ratio Integer
type Rational___1 = Ratio Integer
greduce :: Integral b => RefSrcPos -> RefExp -> R (Fun b (Fun b (Ratio b)))
hreduce :: Integral b => R b -> R b -> RefExp -> R (Ratio b)
(!%) :: Integral a => RefSrcPos -> RefExp -> R (Fun a (Fun a (Ratio a)))
(*%) :: Integral a => R a -> R a -> RefExp -> R (Ratio a)
gnumerator :: Integral a => RefSrcPos -> RefExp -> R (Fun (Ratio a) a)
hnumerator :: Integral a => R (Ratio a) -> RefExp -> R a
gdenominator :: Integral a => RefSrcPos -> RefExp -> R (Fun (Ratio a) a)
hdenominator :: Integral a => R (Ratio a) -> RefExp -> R a
gapproxRational :: RealFrac a => RefSrcPos -> RefExp -> R (Fun a (Fun a Rational))
happroxRational :: RealFrac a => R a -> R a -> RefExp -> R Rational
aEQ :: RefAtom
aFFExponent :: RefAtom
aFFFixed :: RefAtom
aFFGeneric :: RefAtom
aGT :: RefAtom
aJust :: RefAtom
aLT :: RefAtom
aLeft :: RefAtom
aNothing :: RefAtom
aRight :: RefAtom
a_filter :: RefAtom
a_foldr :: RefAtom
aall :: RefAtom
aalt :: RefAtom
aand :: RefAtom
aany :: RefAtom
aapproxRational :: RefAtom
aasTypeOf :: RefAtom
aasciiTab :: RefAtom
abreak :: RefAtom
achr :: RefAtom
aconcat :: RefAtom
aconcatMap :: RefAtom
aconst :: RefAtom
acurry :: RefAtom
acycle :: RefAtom
adenominator :: RefAtom
adigitToInt :: RefAtom
adrop :: RefAtom
adropWhile :: RefAtom
aeither :: RefAtom
aelem :: RefAtom
aeven :: RefAtom
aexpt :: RefAtom
aexpts :: RefAtom
afilter :: RefAtom
aflip :: RefAtom
afloatToDigits :: RefAtom
afoldl :: RefAtom
afoldl1 :: RefAtom
afoldr :: RefAtom
afoldr1 :: RefAtom
aformatRealFloat :: RefAtom
afromIntegral :: RefAtom
afromRat :: RefAtom
afromRat' :: RefAtom
afst :: RefAtom
agcd :: RefAtom
agetLine :: RefAtom
aguard :: RefAtom
ahead :: RefAtom
aid :: RefAtom
ainit :: RefAtom
aintEnumFromByTo :: RefAtom
aintToDigit :: RefAtom
aintegerLogBase :: RefAtom
ainteract :: RefAtom
aiterate :: RefAtom
alast :: RefAtom
alcm :: RefAtom
alength :: RefAtom
alex :: RefAtom
alexDigits :: RefAtom
alexLitChar :: RefAtom
alift :: RefAtom
alines :: RefAtom
alookup :: RefAtom
amap :: RefAtom
amapM :: RefAtom
amapM_ :: RefAtom
amaxExpt :: RefAtom
amaximum :: RefAtom
amaybe :: RefAtom
aminExpt :: RefAtom
aminimum :: RefAtom
anonnull :: RefAtom
anot :: RefAtom
anotElem :: RefAtom
anull :: RefAtom
anumerator :: RefAtom
anumericEnumFrom :: RefAtom
anumericEnumFromThen :: RefAtom
anumericEnumFromThenTo :: RefAtom
anumericEnumFromTo :: RefAtom
aodd :: RefAtom
aor :: RefAtom
aord :: RefAtom
aotherwise :: RefAtom
aprec :: RefAtom
aprint :: RefAtom
aproduct :: RefAtom
aprotectEsc :: RefAtom
aputStr :: RefAtom
aputStrLn :: RefAtom
aread :: RefAtom
areadDec :: RefAtom
areadFloat :: RefAtom
areadHex :: RefAtom
areadIO :: RefAtom
areadInt :: RefAtom
areadLitChar :: RefAtom
areadLn :: RefAtom
areadOct :: RefAtom
areadParen :: RefAtom
areadSigned :: RefAtom
areads :: RefAtom
arealToFrac :: RefAtom
areduce :: RefAtom
arepeat :: RefAtom
areplicate :: RefAtom
areverse :: RefAtom
aroundTo :: RefAtom
ascaleRat :: RefAtom
ascanl :: RefAtom
ascanl1 :: RefAtom
ascanr :: RefAtom
ascanr1 :: RefAtom
asequence :: RefAtom
asequence_ :: RefAtom
ashowChar :: RefAtom
ashowEFloat :: RefAtom
ashowFFloat :: RefAtom
ashowFloat :: RefAtom
ashowGFloat :: RefAtom
ashowHex :: RefAtom
ashowInt :: RefAtom
ashowIntAtBase :: RefAtom
ashowLitChar :: RefAtom
ashowOct :: RefAtom
ashowParen :: RefAtom
ashowSigned :: RefAtom
ashowString :: RefAtom
ashows :: RefAtom
asnd :: RefAtom
aspan :: RefAtom
asplitAt :: RefAtom
asubtract :: RefAtom
asum :: RefAtom
atail :: RefAtom
atake :: RefAtom
atakeWhile :: RefAtom
athenAp :: RefAtom
athenLex :: RefAtom
auncurry :: RefAtom
aunlines :: RefAtom
auntil :: RefAtom
aunwords :: RefAtom
aunzip :: RefAtom
aunzip3 :: RefAtom
awords :: RefAtom
ayield :: RefAtom
azip :: RefAtom
azip3 :: RefAtom
azipWith :: RefAtom
azipWith3 :: RefAtom
(+!!) :: RefAtom
(+$) :: RefAtom
(+$!) :: RefAtom
(+%) :: RefAtom
(+&&) :: RefAtom
(+#>#=*=#>#=%>**) :: RefAtom
(+++) :: RefAtom
(+#&#=*=#&#=%+-) :: RefAtom
(+.) :: RefAtom
(+#^*=*=#^*=%*/) :: RefAtom
(++>=*=+>=%+/=) :: RefAtom
(+:%) :: RefAtom
(+@^=*=@^=&#<) :: RefAtom
(+@+=*=@+=&#<=) :: RefAtom
(+=<<) :: RefAtom
(+^!=*=^!=%+==) :: RefAtom
(+@>=*=@>=&#>) :: RefAtom
(+@@=*=@@=&#>=) :: RefAtom
(+%$^=*=%$^=$@>>) :: RefAtom
(+^) :: RefAtom
(+^^) :: RefAtom
(+||) :: RefAtom
(+%+!=%=%+!=#^==) :: RefAtom
(+&#^=%=&#>=$&==) :: RefAtom
(+&^@=*=&^@=&>==) :: RefAtom
(+&@$=*=&@$=&><=) :: RefAtom
(+*!+=*#=*!+=*$==) :: RefAtom
(+*$!=*=*$#=%#>>=) :: RefAtom
(+*$@=*#=*$@=*$==) :: RefAtom
(+*&+=&=*&+=$$>>=) :: RefAtom
(+**&=$#=**&=$$==) :: RefAtom
(+*++=%=*++=$&/=) :: RefAtom
(+*+*=%=*+*=$&==) :: RefAtom
(+*+>=%=*+>=$&<) :: RefAtom
(+*^!=%=*^!=$&<=) :: RefAtom
(+*^$=%=*^$=$&>) :: RefAtom
(+*^#=%=*^#=$&>=) :: RefAtom
(+*^^=$=*^^=$@*) :: RefAtom
(+*^*=$=*^*=$^+) :: RefAtom
(+*^+=$=*^+=$@-) :: RefAtom
(++$&=%=+$&=$@/=) :: RefAtom
(++$%=%=+$%=$@==) :: RefAtom
(++$^=%=+$^=$@<) :: RefAtom
(++$@=%=+$@=$@<=) :: RefAtom
(++%!=%=+%!=$@>) :: RefAtom
(++$>=%=+$>=$@>=) :: RefAtom
(++%*=$=+%*=%!*) :: RefAtom
(++%%=$=+%%=%!+) :: RefAtom
(++%&=$=+%&=%!-) :: RefAtom
(++^+=%=+^+=$+/=) :: RefAtom
(++^*=%=+^*=$+==) :: RefAtom
(++^>=%=+^>=$+<) :: RefAtom
(++@!=%=+@!=$+<=) :: RefAtom
(++@$=%=+@$=$+>) :: RefAtom
(++@#=%=+@#=$+>=) :: RefAtom
(++@^=$=+@^=$@*) :: RefAtom
(++@*=$=+@*=$@+) :: RefAtom
(++@+=$=+@+=$@-) :: RefAtom
(++>@=%=+>@=$+/) :: RefAtom
(+^*&=%=^*&=$^/=) :: RefAtom
(+^*%=%=^*%=$^==) :: RefAtom
(+^*^=%=^*^=$^<) :: RefAtom
(+^*@=%=^*@=$^<=) :: RefAtom
(+^+!=%=^+!=$^>) :: RefAtom
(+^*>=%=^*>=$^>=) :: RefAtom
(+^+*=$=^+*=$>*) :: RefAtom
(+^+%=$=^+%=$>+) :: RefAtom
(+^+&=$=^+&=$>-) :: RefAtom
(+^^+=%=^^+=$^/) :: RefAtom
(+@@%=%=@@*=$+==) :: RefAtom
(+>!%=*=>!%=%>>>=) :: RefAtom
(+>#+=%=>#+=%>==) :: RefAtom
(+>%#=%=>%#=**==) :: RefAtom
(+>&^=%=>&^=^#==) :: RefAtom
(+>+*=%=>++=**==) :: RefAtom
(+>@^=%=>@@=++==) :: RefAtom
(+#!##=%=#!#$=^^==) :: RefAtom
(+#!&!=%=#!&$=#&==) :: RefAtom
(+#!^$=%=#!^&=$*==) :: RefAtom
(+##!^=%=##!>=%+==) :: RefAtom
(+##&&=%=##&+=&^==) :: RefAtom
(+##@%=%=##@*=*@==) :: RefAtom
(+#$$*=%=#$$^=+>==) :: RefAtom
(+#$^#=%=#$^*=#&==) :: RefAtom
(+#%$$=%=#%$+=$*==) :: RefAtom
(+%#>*=%^=%#>*=%@==) :: RefAtom
(+%$$&=*=%$$&=&%<) :: RefAtom
(+%$$%=*=%$$%=&%<=) :: RefAtom
(+%$$@=*=%$$@=*#*) :: RefAtom
(+%$$^=*=%$$^=*&+) :: RefAtom
(+%$%@=*=%$%@=&$/) :: RefAtom
data Bool :: *
False :: Bool
True :: Bool
aTrue :: RefAtom
aFalse :: RefAtom

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) characters (see
--   <a>http://www.unicode.org/</a> for details). This set extends the ISO
--   8859-1 (Latin-1) character set (the first 256 characters), which is
--   itself an extension of the ASCII character set (the first 128
--   characters). A character literal in Haskell has type <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <tt>ord</tt> and
--   <tt>chr</tt>).
data Char :: *

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int :: *

-- | Arbitrary-precision integers.
data Integer :: *

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float :: *

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double :: *

-- | The Haskell 2010 type for exceptions in the <a>IO</a> monad. Any I/O
--   operation may raise an <a>IOError</a> instead of returning a result.
--   For a more general type of exception, including also those that arise
--   in pure code, see <a>Control.Exception.Exception</a>.
--   
--   In Haskell 2010, this is an opaque type.
type IOError = IOException
data IO a
type String = List Char
gerror :: RefSrcPos -> RefExp -> R (Fun String z)
aerror :: RefAtom
herror :: R String -> RefExp -> a
gundefined :: RefSrcPos -> RefExp -> R a
gseq :: RefSrcPos -> RefExp -> R (Fun a (Fun b b))
aseq :: RefAtom
hseq :: R a1 -> R a -> RefExp -> R a
gisAscii :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisAscii :: RefAtom
hisAscii :: R Char -> RefExp -> R Bool
gisLatin1 :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisLatin1 :: RefAtom
hisLatin1 :: R Char -> RefExp -> R Bool
gisControl :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisControl :: RefAtom
hisControl :: R Char -> RefExp -> R Bool
gisPrint :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisPrint :: RefAtom
hisPrint :: R Char -> RefExp -> R Bool
gisSpace :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisSpace :: RefAtom
hisSpace :: R Char -> RefExp -> R Bool
gisUpper :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisUpper :: RefAtom
hisUpper :: R Char -> RefExp -> R Bool
gisLower :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisLower :: RefAtom
hisLower :: R Char -> RefExp -> R Bool
gisAlpha :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisAlpha :: RefAtom
hisAlpha :: R Char -> RefExp -> R Bool
gisDigit :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisDigit :: RefAtom
hisDigit :: R Char -> RefExp -> R Bool
gisOctDigit :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisOctDigit :: RefAtom
hisOctDigit :: R Char -> RefExp -> R Bool
gisHexDigit :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisHexDigit :: RefAtom
hisHexDigit :: R Char -> RefExp -> R Bool
gisAlphaNum :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisAlphaNum :: RefAtom
hisAlphaNum :: R Char -> RefExp -> R Bool
gtoUpper :: RefSrcPos -> RefExp -> R (Fun Char Char)
atoUpper :: RefAtom
htoUpper :: R Char -> RefExp -> R Char
gtoLower :: RefSrcPos -> RefExp -> R (Fun Char Char)
atoLower :: RefAtom
htoLower :: R Char -> RefExp -> R Char
gprimIntToChar :: RefSrcPos -> RefExp -> R (Fun Int Char)
aprimIntToChar :: RefAtom
hprimIntToChar :: R Int -> RefExp -> R Char
gprimCharToInt :: RefSrcPos -> RefExp -> R (Fun Char Int)
aprimCharToInt :: RefAtom
hprimCharToInt :: R Char -> RefExp -> R Int
gprimUnicodeMaxBound :: RefSrcPos -> RefExp -> R Char
gprimIntMinBound :: RefSrcPos -> RefExp -> R Int
gprimIntMaxBound :: RefSrcPos -> RefExp -> R Int
gprimIntEq :: RefSrcPos -> RefExp -> R (Fun Int (Fun Int Bool))
aprimIntEq :: RefAtom
hprimIntEq :: R Int -> R Int -> RefExp -> R Bool
gprimIntNe :: RefSrcPos -> RefExp -> R (Fun Int (Fun Int Bool))
aprimIntNe :: RefAtom
hprimIntNe :: R Int -> R Int -> RefExp -> R Bool
gprimIntLt :: RefSrcPos -> RefExp -> R (Fun Int (Fun Int Bool))
aprimIntLt :: RefAtom
hprimIntLt :: R Int -> R Int -> RefExp -> R Bool
gprimIntLe :: RefSrcPos -> RefExp -> R (Fun Int (Fun Int Bool))
aprimIntLe :: RefAtom
hprimIntLe :: R Int -> R Int -> RefExp -> R Bool
gprimIntGt :: RefSrcPos -> RefExp -> R (Fun Int (Fun Int Bool))
aprimIntGt :: RefAtom
hprimIntGt :: R Int -> R Int -> RefExp -> R Bool
gprimIntGe :: RefSrcPos -> RefExp -> R (Fun Int (Fun Int Bool))
aprimIntGe :: RefAtom
hprimIntGe :: R Int -> R Int -> RefExp -> R Bool
gprimIntQuot :: RefSrcPos -> RefExp -> R (Fun Int (Fun Int Int))
aprimIntQuot :: RefAtom
hprimIntQuot :: R Int -> R Int -> RefExp -> R Int
gprimIntRem :: RefSrcPos -> RefExp -> R (Fun Int (Fun Int Int))
aprimIntRem :: RefAtom
hprimIntRem :: R Int -> R Int -> RefExp -> R Int
gprimIntPlus :: RefSrcPos -> RefExp -> R (Fun Int (Fun Int Int))
aprimIntPlus :: RefAtom
hprimIntPlus :: R Int -> R Int -> RefExp -> R Int
gprimIntMinus :: RefSrcPos -> RefExp -> R (Fun Int (Fun Int Int))
aprimIntMinus :: RefAtom
hprimIntMinus :: R Int -> R Int -> RefExp -> R Int
gprimIntTimes :: RefSrcPos -> RefExp -> R (Fun Int (Fun Int Int))
aprimIntTimes :: RefAtom
hprimIntTimes :: R Int -> R Int -> RefExp -> R Int
gprimIntNegate :: RefSrcPos -> RefExp -> R (Fun Int Int)
aprimIntNegate :: RefAtom
hprimIntNegate :: R Int -> RefExp -> R Int
gprimIntAbs :: RefSrcPos -> RefExp -> R (Fun Int Int)
aprimIntAbs :: RefAtom
hprimIntAbs :: R Int -> RefExp -> R Int
gprimIntSignum :: RefSrcPos -> RefExp -> R (Fun Int Int)
aprimIntSignum :: RefAtom
hprimIntSignum :: R Int -> RefExp -> R Int
gprimIntegerFromInt :: RefSrcPos -> RefExp -> R (Fun Int Integer)
aprimIntegerFromInt :: RefAtom
hprimIntegerFromInt :: R Int -> RefExp -> R Integer
gprimIntFromInteger :: RefSrcPos -> RefExp -> R (Fun Integer Int)
aprimIntFromInteger :: RefAtom
hprimIntFromInteger :: R Integer -> RefExp -> R Int
gprimIntegerEq :: RefSrcPos -> RefExp -> R (Fun Integer (Fun Integer Bool))
aprimIntegerEq :: RefAtom
hprimIntegerEq :: R Integer -> R Integer -> RefExp -> R Bool
gprimIntegerNe :: RefSrcPos -> RefExp -> R (Fun Integer (Fun Integer Bool))
aprimIntegerNe :: RefAtom
hprimIntegerNe :: R Integer -> R Integer -> RefExp -> R Bool
gprimIntegerLt :: RefSrcPos -> RefExp -> R (Fun Integer (Fun Integer Bool))
aprimIntegerLt :: RefAtom
hprimIntegerLt :: R Integer -> R Integer -> RefExp -> R Bool
gprimIntegerLe :: RefSrcPos -> RefExp -> R (Fun Integer (Fun Integer Bool))
aprimIntegerLe :: RefAtom
hprimIntegerLe :: R Integer -> R Integer -> RefExp -> R Bool
gprimIntegerGt :: RefSrcPos -> RefExp -> R (Fun Integer (Fun Integer Bool))
aprimIntegerGt :: RefAtom
hprimIntegerGt :: R Integer -> R Integer -> RefExp -> R Bool
gprimIntegerGe :: RefSrcPos -> RefExp -> R (Fun Integer (Fun Integer Bool))
aprimIntegerGe :: RefAtom
hprimIntegerGe :: R Integer -> R Integer -> RefExp -> R Bool
gprimIntegerQuot :: RefSrcPos -> RefExp -> R (Fun Integer (Fun Integer Integer))
aprimIntegerQuot :: RefAtom
hprimIntegerQuot :: R Integer -> R Integer -> RefExp -> R Integer
gprimIntegerRem :: RefSrcPos -> RefExp -> R (Fun Integer (Fun Integer Integer))
aprimIntegerRem :: RefAtom
hprimIntegerRem :: R Integer -> R Integer -> RefExp -> R Integer
gprimIntegerQuotRem :: RefSrcPos -> RefExp -> R (Fun Integer (Fun Integer (Tuple2 Integer Integer)))
aprimIntegerQuotRem :: RefAtom
hprimIntegerQuotRem :: R Integer -> R Integer -> RefExp -> R (Tuple2 Integer Integer)
gprimIntegerAdd :: RefSrcPos -> RefExp -> R (Fun Integer (Fun Integer Integer))
aprimIntegerAdd :: RefAtom
hprimIntegerAdd :: R Integer -> R Integer -> RefExp -> R Integer
gprimIntegerSub :: RefSrcPos -> RefExp -> R (Fun Integer (Fun Integer Integer))
aprimIntegerSub :: RefAtom
hprimIntegerSub :: R Integer -> R Integer -> RefExp -> R Integer
gprimIntegerMul :: RefSrcPos -> RefExp -> R (Fun Integer (Fun Integer Integer))
aprimIntegerMul :: RefAtom
hprimIntegerMul :: R Integer -> R Integer -> RefExp -> R Integer
gprimIntegerNeg :: RefSrcPos -> RefExp -> R (Fun Integer Integer)
aprimIntegerNeg :: RefAtom
hprimIntegerNeg :: R Integer -> RefExp -> R Integer
gprimFloatFromInteger :: RefSrcPos -> RefExp -> R (Fun Integer Float)
aprimFloatFromInteger :: RefAtom
hprimFloatFromInteger :: R Integer -> RefExp -> R Float
gprimFloatRadix :: RefSrcPos -> RefExp -> R (Fun Float Integer)
aprimFloatRadix :: RefAtom
hprimFloatRadix :: R Float -> RefExp -> R Integer
gprimFloatDigits :: RefSrcPos -> RefExp -> R (Fun Float Int)
aprimFloatDigits :: RefAtom
hprimFloatDigits :: R Float -> RefExp -> R Int
gprimFloatRange :: RefSrcPos -> RefExp -> R (Fun Float (Tuple2 Int Int))
aprimFloatRange :: RefAtom
hprimFloatRange :: R Float -> RefExp -> R (Tuple2 Int Int)
gprimDecodeFloat :: RefSrcPos -> RefExp -> R (Fun Float (Tuple2 Integer Int))
aprimDecodeFloat :: RefAtom
hprimDecodeFloat :: R Float -> RefExp -> R (Tuple2 Integer Int)
gprimEncodeFloat :: RefSrcPos -> RefExp -> R (Fun Integer (Fun Int Float))
aprimEncodeFloat :: RefAtom
hprimEncodeFloat :: R Integer -> R Int -> RefExp -> R Float
gprimFloatIsNaN :: RefSrcPos -> RefExp -> R (Fun Float Bool)
aprimFloatIsNaN :: RefAtom
hprimFloatIsNaN :: R Float -> RefExp -> R Bool
gprimFloatIsInfinite :: RefSrcPos -> RefExp -> R (Fun Float Bool)
aprimFloatIsInfinite :: RefAtom
hprimFloatIsInfinite :: R Float -> RefExp -> R Bool
gprimFloatIsDenormalized :: RefSrcPos -> RefExp -> R (Fun Float Bool)
aprimFloatIsDenormalized :: RefAtom
hprimFloatIsDenormalized :: R Float -> RefExp -> R Bool
gprimFloatIsNegativeZero :: RefSrcPos -> RefExp -> R (Fun Float Bool)
aprimFloatIsNegativeZero :: RefAtom
hprimFloatIsNegativeZero :: R Float -> RefExp -> R Bool
gprimFloatIsIEEE :: RefSrcPos -> RefExp -> R (Fun Float Bool)
aprimFloatIsIEEE :: RefAtom
hprimFloatIsIEEE :: R Float -> RefExp -> R Bool
gprimFloatEq :: RefSrcPos -> RefExp -> R (Fun Float (Fun Float Bool))
aprimFloatEq :: RefAtom
hprimFloatEq :: R Float -> R Float -> RefExp -> R Bool
gprimFloatNe :: RefSrcPos -> RefExp -> R (Fun Float (Fun Float Bool))
aprimFloatNe :: RefAtom
hprimFloatNe :: R Float -> R Float -> RefExp -> R Bool
gprimFloatLt :: RefSrcPos -> RefExp -> R (Fun Float (Fun Float Bool))
aprimFloatLt :: RefAtom
hprimFloatLt :: R Float -> R Float -> RefExp -> R Bool
gprimFloatLe :: RefSrcPos -> RefExp -> R (Fun Float (Fun Float Bool))
aprimFloatLe :: RefAtom
hprimFloatLe :: R Float -> R Float -> RefExp -> R Bool
gprimFloatGt :: RefSrcPos -> RefExp -> R (Fun Float (Fun Float Bool))
aprimFloatGt :: RefAtom
hprimFloatGt :: R Float -> R Float -> RefExp -> R Bool
gprimFloatGe :: RefSrcPos -> RefExp -> R (Fun Float (Fun Float Bool))
aprimFloatGe :: RefAtom
hprimFloatGe :: R Float -> R Float -> RefExp -> R Bool
gprimFloatPi :: RefSrcPos -> RefExp -> R Float
gprimFloatExp :: RefSrcPos -> RefExp -> R (Fun Float Float)
aprimFloatExp :: RefAtom
hprimFloatExp :: R Float -> RefExp -> R Float
gprimFloatLog :: RefSrcPos -> RefExp -> R (Fun Float Float)
aprimFloatLog :: RefAtom
hprimFloatLog :: R Float -> RefExp -> R Float
gprimFloatSqrt :: RefSrcPos -> RefExp -> R (Fun Float Float)
aprimFloatSqrt :: RefAtom
hprimFloatSqrt :: R Float -> RefExp -> R Float
gprimFloatSin :: RefSrcPos -> RefExp -> R (Fun Float Float)
aprimFloatSin :: RefAtom
hprimFloatSin :: R Float -> RefExp -> R Float
gprimFloatCos :: RefSrcPos -> RefExp -> R (Fun Float Float)
aprimFloatCos :: RefAtom
hprimFloatCos :: R Float -> RefExp -> R Float
gprimFloatTan :: RefSrcPos -> RefExp -> R (Fun Float Float)
aprimFloatTan :: RefAtom
hprimFloatTan :: R Float -> RefExp -> R Float
gprimFloatAsin :: RefSrcPos -> RefExp -> R (Fun Float Float)
aprimFloatAsin :: RefAtom
hprimFloatAsin :: R Float -> RefExp -> R Float
gprimFloatAcos :: RefSrcPos -> RefExp -> R (Fun Float Float)
aprimFloatAcos :: RefAtom
hprimFloatAcos :: R Float -> RefExp -> R Float
gprimFloatAtan :: RefSrcPos -> RefExp -> R (Fun Float Float)
aprimFloatAtan :: RefAtom
hprimFloatAtan :: R Float -> RefExp -> R Float
gprimFloatDiv :: RefSrcPos -> RefExp -> R (Fun Float (Fun Float Float))
aprimFloatDiv :: RefAtom
hprimFloatDiv :: R Float -> R Float -> RefExp -> R Float
gprimFloatAdd :: RefSrcPos -> RefExp -> R (Fun Float (Fun Float Float))
aprimFloatAdd :: RefAtom
hprimFloatAdd :: R Float -> R Float -> RefExp -> R Float
gprimFloatSub :: RefSrcPos -> RefExp -> R (Fun Float (Fun Float Float))
aprimFloatSub :: RefAtom
hprimFloatSub :: R Float -> R Float -> RefExp -> R Float
gprimFloatMul :: RefSrcPos -> RefExp -> R (Fun Float (Fun Float Float))
aprimFloatMul :: RefAtom
hprimFloatMul :: R Float -> R Float -> RefExp -> R Float
gprimFloatAbs :: RefSrcPos -> RefExp -> R (Fun Float Float)
aprimFloatAbs :: RefAtom
hprimFloatAbs :: R Float -> RefExp -> R Float
gprimFloatSignum :: RefSrcPos -> RefExp -> R (Fun Float Float)
aprimFloatSignum :: RefAtom
hprimFloatSignum :: R Float -> RefExp -> R Float
gprimDoubleFromInteger :: RefSrcPos -> RefExp -> R (Fun Integer Double)
aprimDoubleFromInteger :: RefAtom
hprimDoubleFromInteger :: R Integer -> RefExp -> R Double
gprimDoubleRadix :: RefSrcPos -> RefExp -> R (Fun Double Integer)
aprimDoubleRadix :: RefAtom
hprimDoubleRadix :: R Double -> RefExp -> R Integer
gprimDoubleDigits :: RefSrcPos -> RefExp -> R (Fun Double Int)
aprimDoubleDigits :: RefAtom
hprimDoubleDigits :: R Double -> RefExp -> R Int
gprimDoubleRange :: RefSrcPos -> RefExp -> R (Fun Double (Tuple2 Int Int))
aprimDoubleRange :: RefAtom
hprimDoubleRange :: R Double -> RefExp -> R (Tuple2 Int Int)
gprimDecodeDouble :: RefSrcPos -> RefExp -> R (Fun Double (Tuple2 Integer Int))
aprimDecodeDouble :: RefAtom
hprimDecodeDouble :: R Double -> RefExp -> R (Tuple2 Integer Int)
gprimEncodeDouble :: RefSrcPos -> RefExp -> R (Fun Integer (Fun Int Double))
aprimEncodeDouble :: RefAtom
hprimEncodeDouble :: R Integer -> R Int -> RefExp -> R Double
gprimDoubleIsNaN :: RefSrcPos -> RefExp -> R (Fun Double Bool)
aprimDoubleIsNaN :: RefAtom
hprimDoubleIsNaN :: R Double -> RefExp -> R Bool
gprimDoubleIsInfinite :: RefSrcPos -> RefExp -> R (Fun Double Bool)
aprimDoubleIsInfinite :: RefAtom
hprimDoubleIsInfinite :: R Double -> RefExp -> R Bool
gprimDoubleIsDenormalized :: RefSrcPos -> RefExp -> R (Fun Double Bool)
aprimDoubleIsDenormalized :: RefAtom
hprimDoubleIsDenormalized :: R Double -> RefExp -> R Bool
gprimDoubleIsNegativeZero :: RefSrcPos -> RefExp -> R (Fun Double Bool)
aprimDoubleIsNegativeZero :: RefAtom
hprimDoubleIsNegativeZero :: R Double -> RefExp -> R Bool
gprimDoubleIsIEEE :: RefSrcPos -> RefExp -> R (Fun Double Bool)
aprimDoubleIsIEEE :: RefAtom
hprimDoubleIsIEEE :: R Double -> RefExp -> R Bool
gprimDoubleEq :: RefSrcPos -> RefExp -> R (Fun Double (Fun Double Bool))
aprimDoubleEq :: RefAtom
hprimDoubleEq :: R Double -> R Double -> RefExp -> R Bool
gprimDoubleNe :: RefSrcPos -> RefExp -> R (Fun Double (Fun Double Bool))
aprimDoubleNe :: RefAtom
hprimDoubleNe :: R Double -> R Double -> RefExp -> R Bool
gprimDoubleLt :: RefSrcPos -> RefExp -> R (Fun Double (Fun Double Bool))
aprimDoubleLt :: RefAtom
hprimDoubleLt :: R Double -> R Double -> RefExp -> R Bool
gprimDoubleLe :: RefSrcPos -> RefExp -> R (Fun Double (Fun Double Bool))
aprimDoubleLe :: RefAtom
hprimDoubleLe :: R Double -> R Double -> RefExp -> R Bool
gprimDoubleGt :: RefSrcPos -> RefExp -> R (Fun Double (Fun Double Bool))
aprimDoubleGt :: RefAtom
hprimDoubleGt :: R Double -> R Double -> RefExp -> R Bool
gprimDoubleGe :: RefSrcPos -> RefExp -> R (Fun Double (Fun Double Bool))
aprimDoubleGe :: RefAtom
hprimDoubleGe :: R Double -> R Double -> RefExp -> R Bool
gprimDoublePi :: RefSrcPos -> RefExp -> R Double
gprimDoubleExp :: RefSrcPos -> RefExp -> R (Fun Double Double)
aprimDoubleExp :: RefAtom
hprimDoubleExp :: R Double -> RefExp -> R Double
gprimDoubleLog :: RefSrcPos -> RefExp -> R (Fun Double Double)
aprimDoubleLog :: RefAtom
hprimDoubleLog :: R Double -> RefExp -> R Double
gprimDoubleSqrt :: RefSrcPos -> RefExp -> R (Fun Double Double)
aprimDoubleSqrt :: RefAtom
hprimDoubleSqrt :: R Double -> RefExp -> R Double
gprimDoubleSin :: RefSrcPos -> RefExp -> R (Fun Double Double)
aprimDoubleSin :: RefAtom
hprimDoubleSin :: R Double -> RefExp -> R Double
gprimDoubleCos :: RefSrcPos -> RefExp -> R (Fun Double Double)
aprimDoubleCos :: RefAtom
hprimDoubleCos :: R Double -> RefExp -> R Double
gprimDoubleTan :: RefSrcPos -> RefExp -> R (Fun Double Double)
aprimDoubleTan :: RefAtom
hprimDoubleTan :: R Double -> RefExp -> R Double
gprimDoubleAsin :: RefSrcPos -> RefExp -> R (Fun Double Double)
aprimDoubleAsin :: RefAtom
hprimDoubleAsin :: R Double -> RefExp -> R Double
gprimDoubleAcos :: RefSrcPos -> RefExp -> R (Fun Double Double)
aprimDoubleAcos :: RefAtom
hprimDoubleAcos :: R Double -> RefExp -> R Double
gprimDoubleAtan :: RefSrcPos -> RefExp -> R (Fun Double Double)
aprimDoubleAtan :: RefAtom
hprimDoubleAtan :: R Double -> RefExp -> R Double
gprimDoubleDiv :: RefSrcPos -> RefExp -> R (Fun Double (Fun Double Double))
aprimDoubleDiv :: RefAtom
hprimDoubleDiv :: R Double -> R Double -> RefExp -> R Double
gprimDoubleAdd :: RefSrcPos -> RefExp -> R (Fun Double (Fun Double Double))
aprimDoubleAdd :: RefAtom
hprimDoubleAdd :: R Double -> R Double -> RefExp -> R Double
gprimDoubleSub :: RefSrcPos -> RefExp -> R (Fun Double (Fun Double Double))
aprimDoubleSub :: RefAtom
hprimDoubleSub :: R Double -> R Double -> RefExp -> R Double
gprimDoubleMul :: RefSrcPos -> RefExp -> R (Fun Double (Fun Double Double))
aprimDoubleMul :: RefAtom
hprimDoubleMul :: R Double -> R Double -> RefExp -> R Double
gprimDoubleAbs :: RefSrcPos -> RefExp -> R (Fun Double Double)
aprimDoubleAbs :: RefAtom
hprimDoubleAbs :: R Double -> RefExp -> R Double
gprimDoubleSignum :: RefSrcPos -> RefExp -> R (Fun Double Double)
aprimDoubleSignum :: RefAtom
hprimDoubleSignum :: R Double -> RefExp -> R Double
gprimIOBind :: RefSrcPos -> RefExp -> R (Fun (IO a) (Fun (Fun a (IO b)) (IO b)))
aprimIOBind :: RefAtom
hprimIOBind :: R (IO a) -> R (Fun a (IO b)) -> RefExp -> R (IO b)
gprimIOReturn :: RefSrcPos -> RefExp -> R (Fun a (IO a))
aprimIOReturn :: RefAtom
hprimIOReturn :: R b -> RefExp -> R (IO b)
gioError :: RefSrcPos -> RefExp -> R (Fun IOError (IO a))
aioError :: RefAtom
hioError :: R IOError -> RefExp -> R (IO b)
guserError :: RefSrcPos -> RefExp -> R (Fun String IOError)
auserError :: RefAtom
huserError :: R String -> RefExp -> R IOError
gcatch :: RefSrcPos -> RefExp -> R (Fun (IO a) (Fun (Fun IOError (IO a)) (IO a)))
acatch :: RefAtom
hcatch :: R (IO b) -> R (Fun IOError (IO b)) -> RefExp -> R (IO b)
gputChar :: RefSrcPos -> RefExp -> R (Fun Char (IO Tuple0))
aputChar :: RefAtom
hputChar :: R Char -> RefExp -> R (IO Tuple0)
ggetChar :: RefSrcPos -> RefExp -> R (IO Char)
ggetContents :: RefSrcPos -> RefExp -> R (IO String)
greadFile :: RefSrcPos -> RefExp -> R (Fun String (IO String))
areadFile :: RefAtom
hreadFile :: R String -> RefExp -> R (IO String)
gwriteFile :: RefSrcPos -> RefExp -> R (Fun String (Fun String (IO Tuple0)))
awriteFile :: RefAtom
hwriteFile :: R String -> R String -> RefExp -> R (IO Tuple0)
gappendFile :: RefSrcPos -> RefExp -> R (Fun String (Fun String (IO Tuple0)))
aappendFile :: RefAtom
happendFile :: R String -> R String -> RefExp -> R (IO Tuple0)
gprimIOErrorShow :: RefSrcPos -> RefExp -> R (Fun IOError String)
aprimIOErrorShow :: RefAtom
hprimIOErrorShow :: R IOError -> RefExp -> R String
instance Integral a => Show (Ratio a)
instance (Read a, Integral a) => Read (Ratio a)
instance Integral a => Enum (Ratio a)
instance Integral a => RealFrac (Ratio a)
instance Integral a => Fractional (Ratio a)
instance Integral a => Real (Ratio a)
instance Integral a => Num (Ratio a)
instance Integral a => Ord (Ratio a)
instance Eq a => Eq (Ratio a)
instance WrapVal (Ratio a)
instance WrapVal FFFormat
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i, Show j, Show k, Show l, Show m, Show n, Show o) => Show (Tuple15 a b c d e f g h i j k l m n o)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i, Show j, Show k, Show l, Show m, Show n) => Show (Tuple14 a b c d e f g h i j k l m n)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i, Show j, Show k, Show l, Show m) => Show (Tuple13 a b c d e f g h i j k l m)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i, Show j, Show k, Show l) => Show (Tuple12 a b c d e f g h i j k l)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i, Show j, Show k) => Show (Tuple11 a b c d e f g h i j k)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i, Show j) => Show (Tuple10 a b c d e f g h i j)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h, Show i) => Show (Tuple9 a b c d e f g h i)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g, Show h) => Show (Tuple8 a b c d e f g h)
instance (Show a, Show b, Show c, Show d, Show e, Show f, Show g) => Show (Tuple7 a b c d e f g)
instance (Show a, Show b, Show c, Show d, Show e, Show f) => Show (Tuple6 a b c d e f)
instance (Show a, Show b, Show c, Show d, Show e) => Show (Tuple5 a b c d e)
instance (Show a, Show b, Show c, Show d) => Show (Tuple4 a b c d)
instance (Show a, Show b, Show c) => Show (Tuple3 a b c)
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g, Read h, Read i, Read j, Read k, Read l, Read m, Read n, Read o) => Read (Tuple15 a b c d e f g h i j k l m n o)
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g, Read h, Read i, Read j, Read k, Read l, Read m, Read n) => Read (Tuple14 a b c d e f g h i j k l m n)
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g, Read h, Read i, Read j, Read k, Read l, Read m) => Read (Tuple13 a b c d e f g h i j k l m)
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g, Read h, Read i, Read j, Read k, Read l) => Read (Tuple12 a b c d e f g h i j k l)
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g, Read h, Read i, Read j, Read k) => Read (Tuple11 a b c d e f g h i j k)
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g, Read h, Read i, Read j) => Read (Tuple10 a b c d e f g h i j)
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g, Read h, Read i) => Read (Tuple9 a b c d e f g h i)
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g, Read h) => Read (Tuple8 a b c d e f g h)
instance (Read a, Read b, Read c, Read d, Read e, Read f, Read g) => Read (Tuple7 a b c d e f g)
instance (Read a, Read b, Read c, Read d, Read e, Read f) => Read (Tuple6 a b c d e f)
instance (Read a, Read b, Read c, Read d, Read e) => Read (Tuple5 a b c d e)
instance (Read a, Read b, Read c, Read d) => Read (Tuple4 a b c d)
instance (Read a, Read b, Read c) => Read (Tuple3 a b c)
instance (Read a, Read b) => Read (Tuple2 a b)
instance (Show a, Show b) => Show (Tuple2 a b)
instance Read a => Read (List a)
instance Show a => Show (List a)
instance Read Char
instance Show Char
instance Read Tuple0
instance Show Tuple0
instance Read Double
instance Show Double
instance Read Float
instance Show Float
instance Read Integer
instance Show Integer
instance Read Int
instance Show Int
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g, Bounded h, Bounded i, Bounded j, Bounded k, Bounded l, Bounded m, Bounded n, Bounded o) => Bounded (Tuple15 a b c d e f g h i j k l m n o)
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h, Ord i, Ord j, Ord k, Ord l, Ord m, Ord n, Ord o) => Ord (Tuple15 a b c d e f g h i j k l m n o)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k, Eq l, Eq m, Eq n, Eq o) => Eq (Tuple15 a b c d e f g h i j k l m n o)
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g, Bounded h, Bounded i, Bounded j, Bounded k, Bounded l, Bounded m, Bounded n) => Bounded (Tuple14 a b c d e f g h i j k l m n)
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h, Ord i, Ord j, Ord k, Ord l, Ord m, Ord n) => Ord (Tuple14 a b c d e f g h i j k l m n)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k, Eq l, Eq m, Eq n) => Eq (Tuple14 a b c d e f g h i j k l m n)
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g, Bounded h, Bounded i, Bounded j, Bounded k, Bounded l, Bounded m) => Bounded (Tuple13 a b c d e f g h i j k l m)
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h, Ord i, Ord j, Ord k, Ord l, Ord m) => Ord (Tuple13 a b c d e f g h i j k l m)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k, Eq l, Eq m) => Eq (Tuple13 a b c d e f g h i j k l m)
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g, Bounded h, Bounded i, Bounded j, Bounded k, Bounded l) => Bounded (Tuple12 a b c d e f g h i j k l)
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h, Ord i, Ord j, Ord k, Ord l) => Ord (Tuple12 a b c d e f g h i j k l)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k, Eq l) => Eq (Tuple12 a b c d e f g h i j k l)
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g, Bounded h, Bounded i, Bounded j, Bounded k) => Bounded (Tuple11 a b c d e f g h i j k)
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h, Ord i, Ord j, Ord k) => Ord (Tuple11 a b c d e f g h i j k)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j, Eq k) => Eq (Tuple11 a b c d e f g h i j k)
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g, Bounded h, Bounded i, Bounded j) => Bounded (Tuple10 a b c d e f g h i j)
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h, Ord i, Ord j) => Ord (Tuple10 a b c d e f g h i j)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i, Eq j) => Eq (Tuple10 a b c d e f g h i j)
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g, Bounded h, Bounded i) => Bounded (Tuple9 a b c d e f g h i)
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h, Ord i) => Ord (Tuple9 a b c d e f g h i)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h, Eq i) => Eq (Tuple9 a b c d e f g h i)
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g, Bounded h) => Bounded (Tuple8 a b c d e f g h)
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g, Ord h) => Ord (Tuple8 a b c d e f g h)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g, Eq h) => Eq (Tuple8 a b c d e f g h)
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f, Bounded g) => Bounded (Tuple7 a b c d e f g)
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f, Ord g) => Ord (Tuple7 a b c d e f g)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f, Eq g) => Eq (Tuple7 a b c d e f g)
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e, Bounded f) => Bounded (Tuple6 a b c d e f)
instance (Ord a, Ord b, Ord c, Ord d, Ord e, Ord f) => Ord (Tuple6 a b c d e f)
instance (Eq a, Eq b, Eq c, Eq d, Eq e, Eq f) => Eq (Tuple6 a b c d e f)
instance (Bounded a, Bounded b, Bounded c, Bounded d, Bounded e) => Bounded (Tuple5 a b c d e)
instance (Ord a, Ord b, Ord c, Ord d, Ord e) => Ord (Tuple5 a b c d e)
instance (Eq a, Eq b, Eq c, Eq d, Eq e) => Eq (Tuple5 a b c d e)
instance (Bounded a, Bounded b, Bounded c, Bounded d) => Bounded (Tuple4 a b c d)
instance (Ord a, Ord b, Ord c, Ord d) => Ord (Tuple4 a b c d)
instance (Eq a, Eq b, Eq c, Eq d) => Eq (Tuple4 a b c d)
instance (Bounded a, Bounded b, Bounded c) => Bounded (Tuple3 a b c)
instance (Ord a, Ord b, Ord c) => Ord (Tuple3 a b c)
instance (Eq a, Eq b, Eq c) => Eq (Tuple3 a b c)
instance (Bounded a, Bounded b) => Bounded (Tuple2 a b)
instance (Ord a, Ord b) => Ord (Tuple2 a b)
instance (Eq a, Eq b) => Eq (Tuple2 a b)
instance Monad List
instance Functor List
instance Ord a => Ord (List a)
instance Eq a => Eq (List a)
instance Enum Double
instance Enum Float
instance RealFloat Double
instance RealFrac Double
instance Floating Double
instance Fractional Double
instance Real Double
instance Num Double
instance Ord Double
instance Eq Double
instance RealFloat Float
instance RealFrac Float
instance Floating Float
instance Fractional Float
instance Real Float
instance Num Float
instance Ord Float
instance Eq Float
instance Enum Integer
instance Integral Integer
instance Real Integer
instance Num Integer
instance Ord Integer
instance Eq Integer
instance Bounded Int
instance Enum Int
instance Integral Int
instance Real Int
instance Num Int
instance Ord Int
instance Eq Int
instance Bounded Ordering
instance Show Ordering
instance Read Ordering
instance Enum Ordering
instance Ord Ordering
instance Eq Ordering
instance WrapVal Ordering
instance Monad IO
instance Functor IO
instance (Show a, Show b) => Show (Either a b)
instance (Read a, Read b) => Read (Either a b)
instance (Ord a, Ord b) => Ord (Either a b)
instance (Eq a, Eq b) => Eq (Either a b)
instance WrapVal (Either a b)
instance Monad Maybe
instance Functor Maybe
instance Show a => Show (Maybe a)
instance Read a => Read (Maybe a)
instance Ord a => Ord (Maybe a)
instance Eq a => Eq (Maybe a)
instance WrapVal (Maybe a)
instance Bounded Char
instance Enum Char
instance Ord Char
instance Eq Char
instance Bounded Bool
instance Show Bool
instance Read Bool
instance Enum Bool
instance Ord Bool
instance Eq Bool
instance Bounded Tuple0
instance Enum Tuple0
instance Ord Tuple0
instance Eq Tuple0

module Hat.Prelude
g_filter :: RefSrcPos -> RefExp -> R (Fun Bool (Fun (Fun (List a) (List a)) (Fun (List a) (List a))))
a_filter :: RefAtom
h_filter :: R Bool -> R (Fun (List a) (List a)) -> R (List a) -> RefExp -> R (List a)
g_foldr :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b b)) (Fun (List a) (Fun b b)))
a_foldr :: RefAtom
h_foldr :: R (Fun a (Fun b b)) -> R (List a) -> R b -> RefExp -> R b
gmap :: RefSrcPos -> RefExp -> R (Fun (Fun a b) (Fun (List a) (List b)))
amap :: RefAtom
hmap :: R (Fun a b) -> R (List a) -> RefExp -> R (List b)
(!++) :: RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List a) (List a)))
(+++) :: RefAtom
(*++) :: R (List a) -> R (List a) -> RefExp -> R (List a)
gfilter :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) (List a)))
afilter :: RefAtom
hfilter :: R (Fun a Bool) -> R (List a) -> RefExp -> R (List a)
gconcat :: RefSrcPos -> RefExp -> R (Fun (List (List a)) (List a))
aconcat :: RefAtom
hconcat :: R (List (List a)) -> RefExp -> R (List a)
ghead :: RefSrcPos -> RefExp -> R (Fun (List a) a)
ahead :: RefAtom
hhead :: R (List a) -> RefExp -> R a
glast :: RefSrcPos -> RefExp -> R (Fun (List a) a)
alast :: RefAtom
hlast :: R (List a) -> RefExp -> R a
gtail :: RefSrcPos -> RefExp -> R (Fun (List a) (List a))
atail :: RefAtom
htail :: R (List a) -> RefExp -> R (List a)
ginit :: RefSrcPos -> RefExp -> R (Fun (List a) (List a))
ainit :: RefAtom
hinit :: R (List a) -> RefExp -> R (List a)
gnull :: RefSrcPos -> RefExp -> R (Fun (List a) Bool)
anull :: RefAtom
hnull :: R (List a) -> RefExp -> R Bool
glength :: RefSrcPos -> RefExp -> R (Fun (List a) Int)
alength :: RefAtom
hlength :: R (List a) -> RefExp -> R Int
(!!!) :: RefSrcPos -> RefExp -> R (Fun (List a) (Fun Int a))
(+!!) :: RefAtom
(*!!) :: R (List a) -> R Int -> RefExp -> R a
gfoldl :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b a)) (Fun a (Fun (List b) a)))
afoldl :: RefAtom
hfoldl :: R (Fun a (Fun b a)) -> R a -> R (List b) -> RefExp -> R a
gfoldl1 :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a a)) (Fun (List a) a))
afoldl1 :: RefAtom
hfoldl1 :: R (Fun a (Fun a a)) -> R (List a) -> RefExp -> R a
gscanl :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b a)) (Fun a (Fun (List b) (List a))))
ascanl :: RefAtom
hscanl :: R (Fun a (Fun b a)) -> R a -> R (List b) -> RefExp -> R (List a)
gscanl1 :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a a)) (Fun (List a) (List a)))
ascanl1 :: RefAtom
hscanl1 :: R (Fun a (Fun a a)) -> R (List a) -> RefExp -> R (List a)
gfoldr :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b b)) (Fun b (Fun (List a) b)))
afoldr :: RefAtom
hfoldr :: R (Fun a (Fun b b)) -> R b -> R (List a) -> RefExp -> R b
gfoldr1 :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a a)) (Fun (List a) a))
afoldr1 :: RefAtom
hfoldr1 :: R (Fun a (Fun a a)) -> R (List a) -> RefExp -> R a
gscanr :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b b)) (Fun b (Fun (List a) (List b))))
ascanr :: RefAtom
hscanr :: R (Fun a (Fun b b)) -> R b -> R (List a) -> RefExp -> R (List b)
gscanr1 :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a a)) (Fun (List a) (List a)))
ascanr1 :: RefAtom
hscanr1 :: R (Fun a (Fun a a)) -> R (List a) -> RefExp -> R (List a)
giterate :: RefSrcPos -> RefExp -> R (Fun (Fun a a) (Fun a (List a)))
aiterate :: RefAtom
hiterate :: R (Fun a a) -> R a -> RefExp -> R (List a)
grepeat :: RefSrcPos -> RefExp -> R (Fun a (List a))
arepeat :: RefAtom
hrepeat :: R a -> RefExp -> R (List a)
greplicate :: RefSrcPos -> RefExp -> R (Fun Int (Fun a (List a)))
areplicate :: RefAtom
hreplicate :: R Int -> R a -> RefExp -> R (List a)
gcycle :: RefSrcPos -> RefExp -> R (Fun (List a) (List a))
acycle :: RefAtom
hcycle :: R (List a) -> RefExp -> R (List a)
gtake :: RefSrcPos -> RefExp -> R (Fun Int (Fun (List a) (List a)))
atake :: RefAtom
htake :: R Int -> R (List a) -> RefExp -> R (List a)
gdrop :: RefSrcPos -> RefExp -> R (Fun Int (Fun (List a) (List a)))
adrop :: RefAtom
hdrop :: R Int -> R (List a) -> RefExp -> R (List a)
gsplitAt :: RefSrcPos -> RefExp -> R (Fun Int (Fun (List a) (Tuple2 (List a) (List a))))
asplitAt :: RefAtom
hsplitAt :: R Int -> R (List a) -> RefExp -> R (Tuple2 (List a) (List a))
gtakeWhile :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) (List a)))
atakeWhile :: RefAtom
htakeWhile :: R (Fun a Bool) -> R (List a) -> RefExp -> R (List a)
gdropWhile :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) (List a)))
adropWhile :: RefAtom
hdropWhile :: R (Fun a Bool) -> R (List a) -> RefExp -> R (List a)
gspan :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) (Tuple2 (List a) (List a))))
aspan :: RefAtom
hspan :: R (Fun a Bool) -> R (List a) -> RefExp -> R (Tuple2 (List a) (List a))
gbreak :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) (Tuple2 (List a) (List a))))
abreak :: RefAtom
hbreak :: R (Fun a Bool) -> RefExp -> R (Fun (List a) (Tuple2 (List a) (List a)))
glines :: RefSrcPos -> RefExp -> R (Fun String (List String))
alines :: RefAtom
hlines :: R String -> RefExp -> R (List String)
gwords :: RefSrcPos -> RefExp -> R (Fun String (List String))
awords :: RefAtom
hwords :: R String -> RefExp -> R (List String)
gunlines :: RefSrcPos -> RefExp -> R (Fun (List String) String)
gunwords :: RefSrcPos -> RefExp -> R (Fun (List String) String)
aunwords :: RefAtom
hunwords :: R (List String) -> RefExp -> R String
greverse :: RefSrcPos -> RefExp -> R (Fun (List a) (List a))
gand :: RefSrcPos -> RefExp -> R (Fun (List Bool) Bool)
gor :: RefSrcPos -> RefExp -> R (Fun (List Bool) Bool)
gany :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) Bool))
aany :: RefAtom
hany :: R (Fun a Bool) -> RefExp -> R (Fun (List a) Bool)
gall :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) Bool))
aall :: RefAtom
hall :: R (Fun a Bool) -> RefExp -> R (Fun (List a) Bool)
gelem :: Eq a => RefSrcPos -> RefExp -> R (Fun a (Fun (List a) Bool))
aelem :: RefAtom
helem :: Eq a => R a -> RefExp -> R (Fun (List a) Bool)
gnotElem :: Eq a => RefSrcPos -> RefExp -> R (Fun a (Fun (List a) Bool))
anotElem :: RefAtom
hnotElem :: Eq a => R a -> RefExp -> R (Fun (List a) Bool)
glookup :: Eq a => RefSrcPos -> RefExp -> R (Fun a (Fun (List (Tuple2 a b)) (Maybe b)))
alookup :: RefAtom
hlookup :: Eq a => R a -> R (List (Tuple2 a b)) -> RefExp -> R (Maybe b)
gsum :: Num a => RefSrcPos -> RefExp -> R (Fun (List a) a)
gproduct :: Num a => RefSrcPos -> RefExp -> R (Fun (List a) a)
gmaximum :: Ord a => RefSrcPos -> RefExp -> R (Fun (List a) a)
amaximum :: RefAtom
hmaximum :: Ord a => R (List a) -> RefExp -> R a
gminimum :: Ord a => RefSrcPos -> RefExp -> R (Fun (List a) a)
aminimum :: RefAtom
hminimum :: Ord a => R (List a) -> RefExp -> R a
gconcatMap :: RefSrcPos -> RefExp -> R (Fun (Fun a (List b)) (Fun (List a) (List b)))
aconcatMap :: RefAtom
hconcatMap :: R (Fun a (List b)) -> RefExp -> R (Fun (List a) (List b))
gzip :: RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List b) (List (Tuple2 a b))))
gzip3 :: RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List b) (Fun (List c) (List (Tuple3 a b c)))))
gzipWith :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b c)) (Fun (List a) (Fun (List b) (List c))))
azipWith :: RefAtom
hzipWith :: R (Fun a (Fun b c)) -> R (List a) -> R (List b) -> RefExp -> R (List c)
gzipWith3 :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b (Fun c d))) (Fun (List a) (Fun (List b) (Fun (List c) (List d)))))
azipWith3 :: RefAtom
hzipWith3 :: R (Fun a (Fun b (Fun c d))) -> R (List a) -> R (List b) -> R (List c) -> RefExp -> R (List d)
gunzip :: RefSrcPos -> RefExp -> R (Fun (List (Tuple2 a b)) (Tuple2 (List a) (List b)))
gunzip3 :: RefSrcPos -> RefExp -> R (Fun (List (Tuple3 a b c)) (Tuple3 (List a) (List b) (List c)))
type ReadS a = Fun String (List (Tuple2 a String))
type ReadS___1 a = String
type ReadS___2 a = List (Tuple2 a String)
type ShowS = Fun String String
type ShowS___1 = String
type ShowS___2 = String
class Read a where sreadsPrec = gundefined mkNoSrcPos p greadList preadList p = uconstUse preadList p sreadList sreadList = uconstDef p c1810v5v1812v28readList (\ p -> let greadl preadl p = ufun1 c1812v30v1814v73readl preadl p hreadl areadl = c1812v30v1814v73readl hreadl fs p = uwrapForward p ((*++) (uap2 mkNoSrcPos p ((!>>=) mkNoSrcPos p) (uwrapForward p (hlex fs p)) (ufun1 mkDoLambda mkNoSrcPos p (\ fv1812v53v1812v63v1 p -> uccase mkNoSrcPos p (let v1812v53v1812v63v1 (R (Tuple2 (R (Cons (R ']' _) (R Nil _)) _) ft) _) p = uap1 mkNoSrcPos p (greturn mkNoSrcPos p) (con2 mkNoSrcPos p Tuple2 aTuple2 (con0 mkNoSrcPos p Nil aNil) ft) v1812v53v1812v63v1 _ p = uap1 mkNoSrcPos p (gfail mkNoSrcPos p) (fromLitString mkNoSrcPos p "pattern-match failure in do-expression") in v1812v53v1812v63v1) fv1812v53v1812v63v1))) (uap2 mkNoSrcPos p ((!>>=) mkNoSrcPos p) (uap1 mkNoSrcPos p (greads mkNoSrcPos p) fs) (ufun1 mkDoLambda mkNoSrcPos p (\ (R (Tuple2 fx ft) _) p -> uap2 mkNoSrcPos p ((!>>=) mkNoSrcPos p) (uwrapForward p (hreadl' ft p)) (ufun1 mkDoLambda mkNoSrcPos p (\ (R (Tuple2 fxs fu) _) p -> uap1 mkNoSrcPos p (greturn mkNoSrcPos p) (con2 mkNoSrcPos p Tuple2 aTuple2 (con2 mkNoSrcPos p Cons aCons fx fxs) fu)))))) p) greadl' preadl' p = ufun1 c1815v30v1818v73readl' preadl' p hreadl' areadl' = c1815v30v1818v73readl' hreadl' fs p = uwrapForward p ((*++) (uap2 mkNoSrcPos p ((!>>=) mkNoSrcPos p) (uwrapForward p (hlex fs p)) (ufun1 mkDoLambda mkNoSrcPos p (\ fv1815v53v1815v63v1 p -> uccase mkNoSrcPos p (let v1815v53v1815v63v1 (R (Tuple2 (R (Cons (R ']' _) (R Nil _)) _) ft) _) p = uap1 mkNoSrcPos p (greturn mkNoSrcPos p) (con2 mkNoSrcPos p Tuple2 aTuple2 (con0 mkNoSrcPos p Nil aNil) ft) v1815v53v1815v63v1 _ p = uap1 mkNoSrcPos p (gfail mkNoSrcPos p) (fromLitString mkNoSrcPos p "pattern-match failure in do-expression") in v1815v53v1815v63v1) fv1815v53v1815v63v1))) (uap2 mkNoSrcPos p ((!>>=) mkNoSrcPos p) (uwrapForward p (hlex fs p)) (ufun1 mkDoLambda mkNoSrcPos p (\ fv1816v53v1816v63v1 p -> uccase mkNoSrcPos p (let v1816v53v1816v63v1 (R (Tuple2 (R (Cons (R ',' _) (R Nil _)) _) ft) _) p = uap2 mkNoSrcPos p ((!>>=) mkNoSrcPos p) (uap1 mkNoSrcPos p (greads mkNoSrcPos p) ft) (ufun1 mkDoLambda mkNoSrcPos p (\ (R (Tuple2 fx fu) _) p -> uap2 mkNoSrcPos p ((!>>=) mkNoSrcPos p) (uwrapForward p (hreadl' fu p)) (ufun1 mkDoLambda mkNoSrcPos p (\ (R (Tuple2 fxs fv) _) p -> uap1 mkNoSrcPos p (greturn mkNoSrcPos p) (con2 mkNoSrcPos p Tuple2 aTuple2 (con2 mkNoSrcPos p Cons aCons fx fxs) fv))))) v1816v53v1816v63v1 _ p = uap1 mkNoSrcPos p (gfail mkNoSrcPos p) (fromLitString mkNoSrcPos p "pattern-match failure in do-expression") in v1816v53v1816v63v1) fv1816v53v1816v63v1))) p) in uwrapForward p (hreadParen (con0 mkNoSrcPos p False aFalse) (ufun1 mkLambda mkNoSrcPos p (\ fr p -> uap2 mkNoSrcPos p ((!>>=) mkNoSrcPos p) (uwrapForward p (hlex fr p)) (ufun1 mkDoLambda mkNoSrcPos p (\ fv1810v53v1810v63v1 p -> uccase mkNoSrcPos p (let v1810v53v1810v63v1 (R (Tuple2 (R (Cons (R '[' _) (R Nil _)) _) fs) _) p = uap2 mkNoSrcPos p ((!>>=) mkNoSrcPos p) (uwrapForward p (hreadl fs p)) (ufun1 mkDoLambda mkNoSrcPos p (\ fpr p -> uap1 mkNoSrcPos p (greturn mkNoSrcPos p) fpr)) v1810v53v1810v63v1 _ p = uap1 mkNoSrcPos p (gfail mkNoSrcPos p) (fromLitString mkNoSrcPos p "pattern-match failure in do-expression") in v1810v53v1810v63v1) fv1810v53v1810v63v1)))) p))
greadsPrec :: Read a => RefSrcPos -> RefExp -> R (Fun Int (ReadS a))
sreadsPrec :: Read a => R (Fun Int (ReadS a))
greadList :: Read a => RefSrcPos -> RefExp -> R (ReadS (List a))
sreadList :: Read a => R (ReadS (List a))
class Show a where gshowsPrec pshowsPrec p = ufun3 c1828v5v1828v35showsPrec pshowsPrec p hshowsPrec where hshowsPrec _ fx fs p = uwrapForward p ((*++) (uap1 mkNoSrcPos p (gshow mkNoSrcPos p) fx) fs p) gshow pshow p = ufun1 c1830v5v1830v36show pshow p hshow where hshow fx p = uap3 mkNoSrcPos p (gshowsPrec mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0))) fx (fromLitString mkNoSrcPos p "") gshowList pshowList p = ufun1 c1832v5v1838v0showList pshowList p hshowList where hshowList (R Nil _) p = uap1 mkNoSrcPos p (gshowString mkNoSrcPos p) (fromLitString mkNoSrcPos p "[]") hshowList (R (Cons fx fxs) _) p = uap2 mkNoSrcPos p ((!.) mkNoSrcPos p) (uap1 mkNoSrcPos p (gshowChar mkNoSrcPos p) (conChar mkNoSrcPos p '[')) (uap2 mkNoSrcPos p ((!.) mkNoSrcPos p) (uap1 mkNoSrcPos p (gshows mkNoSrcPos p) fx) (uwrapForward p (hshowl fxs p))) where gshowl pshowl p = ufun1 c1834v31v1836v53showl pshowl p hshowl ashowl = c1834v31v1836v53showl hshowl (R Nil _) p = uap1 mkNoSrcPos p (gshowChar mkNoSrcPos p) (conChar mkNoSrcPos p ']') hshowl (R (Cons fx fxs) _) p = uap2 mkNoSrcPos p ((!.) mkNoSrcPos p) (uap1 mkNoSrcPos p (gshowChar mkNoSrcPos p) (conChar mkNoSrcPos p ',')) (uap2 mkNoSrcPos p ((!.) mkNoSrcPos p) (uap1 mkNoSrcPos p (gshows mkNoSrcPos p) fx) (uwrapForward p (hshowl fxs p))) hshowl _ p = fatal p hshowList _ p = fatal p
gshowsPrec :: Show a => RefSrcPos -> RefExp -> R (Fun Int (Fun a ShowS))
sshowsPrec :: Show a => R (Fun Int (Fun a ShowS))
gshow :: Show a => RefSrcPos -> RefExp -> R (Fun a String)
sshow :: Show a => R (Fun a String)
gshowList :: Show a => RefSrcPos -> RefExp -> R (Fun (List a) ShowS)
sshowList :: Show a => R (Fun (List a) ShowS)
greads :: Read a => RefSrcPos -> RefExp -> R (ReadS a)
gshows :: Show a => RefSrcPos -> RefExp -> R (Fun a ShowS)
gread :: Read a => RefSrcPos -> RefExp -> R (Fun String a)
aread :: RefAtom
hread :: Read a => R String -> RefExp -> R a
glex :: RefSrcPos -> RefExp -> R (ReadS String)
alex :: RefAtom
hlex :: R (ReadS___1 String) -> RefExp -> R (ReadS___2 String)
gshowChar :: RefSrcPos -> RefExp -> R (Fun Char ShowS)
gshowString :: RefSrcPos -> RefExp -> R (Fun String ShowS)
greadParen :: RefSrcPos -> RefExp -> R (Fun Bool (Fun (ReadS a) (ReadS a)))
areadParen :: RefAtom
hreadParen :: R Bool -> R (ReadS a) -> RefExp -> R (ReadS a)
gshowParen :: RefSrcPos -> RefExp -> R (Fun Bool (Fun ShowS ShowS))
ashowParen :: RefAtom
hshowParen :: R Bool -> R ShowS -> RefExp -> R ShowS
type FilePath = String

-- | The Haskell 2010 type for exceptions in the <a>IO</a> monad. Any I/O
--   operation may raise an <a>IOError</a> instead of returning a result.
--   For a more general type of exception, including also those that arise
--   in pure code, see <a>Control.Exception.Exception</a>.
--   
--   In Haskell 2010, this is an opaque type.
type IOError = IOException
gioError :: RefSrcPos -> RefExp -> R (Fun IOError (IO a))
aioError :: RefAtom
hioError :: R IOError -> RefExp -> R (IO b)
guserError :: RefSrcPos -> RefExp -> R (Fun String IOError)
auserError :: RefAtom
huserError :: R String -> RefExp -> R IOError
gcatch :: RefSrcPos -> RefExp -> R (Fun (IO a) (Fun (Fun IOError (IO a)) (IO a)))
acatch :: RefAtom
hcatch :: R (IO b) -> R (Fun IOError (IO b)) -> RefExp -> R (IO b)
gputChar :: RefSrcPos -> RefExp -> R (Fun Char (IO Tuple0))
aputChar :: RefAtom
hputChar :: R Char -> RefExp -> R (IO Tuple0)
gputStr :: RefSrcPos -> RefExp -> R (Fun String (IO Tuple0))
aputStr :: RefAtom
hputStr :: R String -> RefExp -> R (IO Tuple0)
gputStrLn :: RefSrcPos -> RefExp -> R (Fun String (IO Tuple0))
aputStrLn :: RefAtom
hputStrLn :: R String -> RefExp -> R (IO Tuple0)
gprint :: Show a => RefSrcPos -> RefExp -> R (Fun a (IO Tuple0))
aprint :: RefAtom
hprint :: Show a => R a -> RefExp -> R (IO Tuple0)
ggetChar :: RefSrcPos -> RefExp -> R (IO Char)
ggetLine :: RefSrcPos -> RefExp -> R (IO String)
ggetContents :: RefSrcPos -> RefExp -> R (IO String)
ginteract :: RefSrcPos -> RefExp -> R (Fun (Fun String String) (IO Tuple0))
ainteract :: RefAtom
hinteract :: R (Fun String String) -> RefExp -> R (IO Tuple0)
greadFile :: RefSrcPos -> RefExp -> R (Fun String (IO String))
areadFile :: RefAtom
hreadFile :: R String -> RefExp -> R (IO String)
gwriteFile :: RefSrcPos -> RefExp -> R (Fun String (Fun String (IO Tuple0)))
awriteFile :: RefAtom
hwriteFile :: R String -> R String -> RefExp -> R (IO Tuple0)
gappendFile :: RefSrcPos -> RefExp -> R (Fun String (Fun String (IO Tuple0)))
aappendFile :: RefAtom
happendFile :: R String -> R String -> RefExp -> R (IO Tuple0)
greadIO :: Read a => RefSrcPos -> RefExp -> R (Fun String (IO a))
areadIO :: RefAtom
hreadIO :: Read a => R String -> RefExp -> R (IO a)
greadLn :: Read a => RefSrcPos -> RefExp -> R (IO a)
data Bool :: *
False :: Bool
True :: Bool
aFalse :: RefAtom
aTrue :: RefAtom
data Maybe a
Nothing :: Maybe a
Just :: (R a) -> Maybe a
aNothing :: RefAtom
aJust :: RefAtom
data Either a b
Left :: (R a) -> Either a b
Right :: (R b) -> Either a b
aLeft :: RefAtom
aRight :: RefAtom
data Ordering
LT :: Ordering
EQ :: Ordering
GT :: Ordering
aLT :: RefAtom
aEQ :: RefAtom
aGT :: RefAtom

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) characters (see
--   <a>http://www.unicode.org/</a> for details). This set extends the ISO
--   8859-1 (Latin-1) character set (the first 256 characters), which is
--   itself an extension of the ASCII character set (the first 128
--   characters). A character literal in Haskell has type <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <tt>ord</tt> and
--   <tt>chr</tt>).
data Char :: *
type String = List Char

-- | A fixed-precision integer type with at least the range <tt>[-2^29 ..
--   2^29-1]</tt>. The exact range for a given implementation can be
--   determined by using <a>minBound</a> and <a>maxBound</a> from the
--   <a>Bounded</a> class.
data Int :: *

-- | Arbitrary-precision integers.
data Integer :: *

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float :: *

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double :: *
type Rational = Ratio Integer
data IO a
class Eq a where (%/=) !/= p = ufun2 (++>=*=+>=%+/=) (%/=) p (*/=) where (fx */= fy) p = uwrapForward p (hnot (uap2 mkNoSrcPos p ((!==) mkNoSrcPos p) fx fy) p) (%==) !== p = ufun2 (+^!=*=^!=%+==) (%==) p (*==) where (fx *== fy) p = uwrapForward p (hnot (uap2 mkNoSrcPos p ((!/=) mkNoSrcPos p) fx fy) p)
(!==, !/=) :: Eq a => RefSrcPos -> RefExp -> R (Fun a (Fun a Bool))
(|==, |/=) :: Eq a => R (Fun a (Fun a Bool))
class Eq a => Ord a where gcompare pcompare p = ufun2 c81v5v84v26compare pcompare p hcompare where hcompare fx fy p = ucguard (uap2 mkNoSrcPos p ((!==) mkNoSrcPos p) fx fy) (con0 mkNoSrcPos p EQ aEQ) (ucguard (uap2 mkNoSrcPos p ((!<=) mkNoSrcPos p) fx fy) (con0 mkNoSrcPos p LT aLT) (ucguard (gotherwise mkNoSrcPos p) (con0 mkNoSrcPos p GT aGT) (fatal p))) (%<=) !<= p = ufun2 (+@+=*=@+=&#<=) (%<=) p (*<=) where (fx *<= fy) p = uap2 mkNoSrcPos p ((!/=) mkNoSrcPos p) (uap2 mkNoSrcPos p (gcompare mkNoSrcPos p) fx fy) (con0 mkNoSrcPos p GT aGT) (%<) !< p = ufun2 (+@^=*=@^=&#<) (%<) p (*<) where (fx *< fy) p = uap2 mkNoSrcPos p ((!==) mkNoSrcPos p) (uap2 mkNoSrcPos p (gcompare mkNoSrcPos p) fx fy) (con0 mkNoSrcPos p LT aLT) (%>=) !>= p = ufun2 (+@@=*=@@=&#>=) (%>=) p (*>=) where (fx *>= fy) p = uap2 mkNoSrcPos p ((!/=) mkNoSrcPos p) (uap2 mkNoSrcPos p (gcompare mkNoSrcPos p) fx fy) (con0 mkNoSrcPos p LT aLT) (%>) !> p = ufun2 (+@>=*=@>=&#>) (%>) p (*>) where (fx *> fy) p = uap2 mkNoSrcPos p ((!==) mkNoSrcPos p) (uap2 mkNoSrcPos p (gcompare mkNoSrcPos p) fx fy) (con0 mkNoSrcPos p GT aGT) gmax pmax p = ufun2 c92v5v94v25max pmax p hmax where hmax fx fy p = ucguard (uap2 mkNoSrcPos p ((!<=) mkNoSrcPos p) fx fy) (projection mkNoSrcPos p fy) (ucguard (gotherwise mkNoSrcPos p) (projection mkNoSrcPos p fx) (fatal p)) gmin pmin p = ufun2 c95v5v97v25min pmin p hmin where hmin fx fy p = ucguard (uap2 mkNoSrcPos p ((!<=) mkNoSrcPos p) fx fy) (projection mkNoSrcPos p fx) (ucguard (gotherwise mkNoSrcPos p) (projection mkNoSrcPos p fy) (fatal p))
gcompare :: Ord a => RefSrcPos -> RefExp -> R (Fun a (Fun a Ordering))
scompare :: Ord a => R (Fun a (Fun a Ordering))
(!<, !>, !>=, !<=) :: Ord a => RefSrcPos -> RefExp -> R (Fun a (Fun a Bool))
(|<, |>, |>=, |<=) :: Ord a => R (Fun a (Fun a Bool))
gmax, gmin :: Ord a => RefSrcPos -> RefExp -> R (Fun a (Fun a a))
smax, smin :: Ord a => R (Fun a (Fun a a))
class Enum a where stoEnum = gundefined mkNoSrcPos p sfromEnum = gundefined mkNoSrcPos p gsucc psucc p = uconstUse psucc p ssucc ssucc = uconstDef p c117v5v117v48succ (\ p -> uap2 mkNoSrcPos p ((!.) mkNoSrcPos p) (gtoEnum mkNoSrcPos p) (uap2 mkNoSrcPos p ((!.) mkNoSrcPos p) (uap2 mkNoSrcPos p (gflip mkNoSrcPos p) ((!+) mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (1)))) (gfromEnum mkNoSrcPos p))) gpred ppred p = uconstUse ppred p spred spred = uconstDef p c118v5v118v56pred (\ p -> uap2 mkNoSrcPos p ((!.) mkNoSrcPos p) (gtoEnum mkNoSrcPos p) (uap2 mkNoSrcPos p ((!.) mkNoSrcPos p) (uap1 mkNoSrcPos p (gsubtract mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (1)))) (gfromEnum mkNoSrcPos p))) genumFrom penumFrom p = ufun1 c119v5v119v50enumFrom penumFrom p henumFrom where henumFrom fx p = uwrapForward p (hmap (gtoEnum mkNoSrcPos p) (uap1 mkNoSrcPos p (genumFrom mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromEnum mkNoSrcPos p) fx)) p) genumFromTo penumFromTo p = ufun2 c120v5v120v61enumFromTo penumFromTo p henumFromTo where henumFromTo fx fy p = uwrapForward p (hmap (gtoEnum mkNoSrcPos p) (uap2 mkNoSrcPos p (genumFromTo mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromEnum mkNoSrcPos p) fx) (uap1 mkNoSrcPos p (gfromEnum mkNoSrcPos p) fy)) p) genumFromThen penumFromThen p = ufun2 c121v5v121v62enumFromThen penumFromThen p henumFromThen where henumFromThen fx fy p = uwrapForward p (hmap (gtoEnum mkNoSrcPos p) (uap2 mkNoSrcPos p (genumFromThen mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromEnum mkNoSrcPos p) fx) (uap1 mkNoSrcPos p (gfromEnum mkNoSrcPos p) fy)) p) genumFromThenTo penumFromThenTo p = ufun3 c122v5v123v73enumFromThenTo penumFromThenTo p henumFromThenTo where henumFromThenTo fx fy fz p = uwrapForward p (hmap (gtoEnum mkNoSrcPos p) (uap3 mkNoSrcPos p (genumFromThenTo mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromEnum mkNoSrcPos p) fx) (uap1 mkNoSrcPos p (gfromEnum mkNoSrcPos p) fy) (uap1 mkNoSrcPos p (gfromEnum mkNoSrcPos p) fz)) p)
gsucc, gpred :: Enum a => RefSrcPos -> RefExp -> R (Fun a a)
ssucc, spred :: Enum a => R (Fun a a)
gtoEnum :: Enum a => RefSrcPos -> RefExp -> R (Fun Int a)
stoEnum :: Enum a => R (Fun Int a)
gfromEnum :: Enum a => RefSrcPos -> RefExp -> R (Fun a Int)
sfromEnum :: Enum a => R (Fun a Int)
genumFrom :: Enum a => RefSrcPos -> RefExp -> R (Fun a (List a))
senumFrom :: Enum a => R (Fun a (List a))
genumFromThen :: Enum a => RefSrcPos -> RefExp -> R (Fun a (Fun a (List a)))
senumFromThen :: Enum a => R (Fun a (Fun a (List a)))
genumFromTo :: Enum a => RefSrcPos -> RefExp -> R (Fun a (Fun a (List a)))
senumFromTo :: Enum a => R (Fun a (Fun a (List a)))
genumFromThenTo :: Enum a => RefSrcPos -> RefExp -> R (Fun a (Fun a (Fun a (List a))))
senumFromThenTo :: Enum a => R (Fun a (Fun a (Fun a (List a))))
class Bounded a where sminBound = gundefined mkNoSrcPos p smaxBound = gundefined mkNoSrcPos p
gminBound :: Bounded a => RefSrcPos -> RefExp -> R a
sminBound :: Bounded a => R a
gmaxBound :: Bounded a => RefSrcPos -> RefExp -> R a
smaxBound :: Bounded a => R a
class (Eq a, Show a) => Num a where (|+) = gundefined mkNoSrcPos p (|*) = gundefined mkNoSrcPos p sabs = gundefined mkNoSrcPos p ssignum = gundefined mkNoSrcPos p sfromInteger = gundefined mkNoSrcPos p (%-) !- p = ufun2 (+#&#=*=#&#=%+-) (%-) p (*-) where (fx *- fy) p = uap2 mkNoSrcPos p ((!+) mkNoSrcPos p) fx (uap1 mkNoSrcPos p (gnegate mkNoSrcPos p) fy) gnegate pnegate p = ufun1 c142v5v142v29negate pnegate p hnegate where hnegate fx p = uap2 mkNoSrcPos p ((!-) mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0))) fx
(!+, !*, !-) :: Num a => RefSrcPos -> RefExp -> R (Fun a (Fun a a))
(|+, |*, |-) :: Num a => R (Fun a (Fun a a))
gnegate :: Num a => RefSrcPos -> RefExp -> R (Fun a a)
snegate :: Num a => R (Fun a a)
gabs, gsignum :: Num a => RefSrcPos -> RefExp -> R (Fun a a)
sabs, ssignum :: Num a => R (Fun a a)
gfromInteger :: Num a => RefSrcPos -> RefExp -> R (Fun Integer a)
sfromInteger :: Num a => R (Fun Integer a)
class (Num a, Ord a) => Real a where stoRational = gundefined mkNoSrcPos p
gtoRational :: Real a => RefSrcPos -> RefExp -> R (Fun a Rational)
stoRational :: Real a => R (Fun a Rational)
class (Real a, Enum a) => Integral a where squotRem = gundefined mkNoSrcPos p stoInteger = gundefined mkNoSrcPos p gquot pquot p = ufun2 c157v5v157v32quot pquot p hquot where hquot fn fd p = gq mkNoSrcPos p where gq pq p = uconstUse pq p sq gr pr p = uconstUse pr p sr sq = uconstDef p c157v34v157v52q (\ _ -> case j157v34v157v52q of { (kq, fq, fr) -> fq }) sr = uconstDef p c157v34v157v52r (\ _ -> case j157v34v157v52q of { (kq, fq, fr) -> fr }) j157v34v157v52q = case uap2 mkNoSrcPos p (gquotRem mkNoSrcPos p) fn fd of { R (Tuple2 fq fr) kq -> (kq, fq, fr) _ -> fatal p } grem prem p = ufun2 c158v5v158v32rem prem p hrem where hrem fn fd p = gr mkNoSrcPos p where gq pq p = uconstUse pq p sq gr pr p = uconstUse pr p sr sq = uconstDef p c158v34v158v52q (\ _ -> case j158v34v158v52q of { (kq, fq, fr) -> fq }) sr = uconstDef p c158v34v158v52r (\ _ -> case j158v34v158v52q of { (kq, fq, fr) -> fr }) j158v34v158v52q = case uap2 mkNoSrcPos p (gquotRem mkNoSrcPos p) fn fd of { R (Tuple2 fq fr) kq -> (kq, fq, fr) _ -> fatal p } gdiv pdiv p = ufun2 c159v5v159v32div pdiv p hdiv where hdiv fn fd p = gq mkNoSrcPos p where gq pq p = uconstUse pq p sq gr pr p = uconstUse pr p sr sq = uconstDef p c159v34v159v51q (\ _ -> case j159v34v159v51q of { (kq, fq, fr) -> fq }) sr = uconstDef p c159v34v159v51r (\ _ -> case j159v34v159v51q of { (kq, fq, fr) -> fr }) j159v34v159v51q = case uap2 mkNoSrcPos p (gdivMod mkNoSrcPos p) fn fd of { R (Tuple2 fq fr) kq -> (kq, fq, fr) _ -> fatal p } gmod pmod p = ufun2 c160v5v160v32mod pmod p hmod where hmod fn fd p = gr mkNoSrcPos p where gq pq p = uconstUse pq p sq gr pr p = uconstUse pr p sr sq = uconstDef p c160v34v160v51q (\ _ -> case j160v34v160v51q of { (kq, fq, fr) -> fq }) sr = uconstDef p c160v34v160v51r (\ _ -> case j160v34v160v51q of { (kq, fq, fr) -> fr }) j160v34v160v51q = case uap2 mkNoSrcPos p (gdivMod mkNoSrcPos p) fn fd of { R (Tuple2 fq fr) kq -> (kq, fq, fr) _ -> fatal p } gdivMod pdivMod p = ufun2 c161v5v164v29divMod pdivMod p hdivMod where hdivMod fn fd p = ucif p (uap2 mkNoSrcPos p ((!==) mkNoSrcPos p) (uap1 mkNoSrcPos p (gsignum mkNoSrcPos p) (gr mkNoSrcPos p)) (uap1 mkNoSrcPos p (gnegate mkNoSrcPos p) (uap1 mkNoSrcPos p (gsignum mkNoSrcPos p) fd))) (con2 mkNoSrcPos p Tuple2 aTuple2 (uap2 mkNoSrcPos p ((!-) mkNoSrcPos p) (gq mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (1)))) (uap2 mkNoSrcPos p ((!+) mkNoSrcPos p) (gr mkNoSrcPos p) fd)) (gqr mkNoSrcPos p) where gqr pqr p = uconstUse pqr p sqr sqr = uconstDef p c164v31v164v52qr (\ p -> uap2 mkNoSrcPos p (gquotRem mkNoSrcPos p) fn fd) gq pq p = uconstUse pq p sq gr pr p = uconstUse pr p sr sq = uconstDef p c164v31v164v52q (\ _ -> case j164v31v164v52q of { (kq, fq, fr) -> fq }) sr = uconstDef p c164v31v164v52r (\ _ -> case j164v31v164v52q of { (kq, fq, fr) -> fr }) j164v31v164v52q = case gqr mkNoSrcPos p of { R (Tuple2 fq fr) kq -> (kq, fq, fr) _ -> fatal p }
gquot, grem :: Integral a => RefSrcPos -> RefExp -> R (Fun a (Fun a a))
squot, srem :: Integral a => R (Fun a (Fun a a))
gdiv, gmod :: Integral a => RefSrcPos -> RefExp -> R (Fun a (Fun a a))
sdiv, smod :: Integral a => R (Fun a (Fun a a))
gquotRem, gdivMod :: Integral a => RefSrcPos -> RefExp -> R (Fun a (Fun a (Tuple2 a a)))
squotRem, sdivMod :: Integral a => R (Fun a (Fun a (Tuple2 a a)))
gtoInteger :: Integral a => RefSrcPos -> RefExp -> R (Fun a Integer)
stoInteger :: Integral a => R (Fun a Integer)
class Num a => Fractional a where sfromRational = gundefined mkNoSrcPos p grecip precip p = ufun1 c174v5v174v29recip precip p hrecip where hrecip fx p = uap2 mkNoSrcPos p ((!/) mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (1))) fx (%/) !/ p = ufun2 (+#^*=*=#^*=%*/) (%/) p (*/) where (fx */ fy) p = uap2 mkNoSrcPos p ((!*) mkNoSrcPos p) fx (uap1 mkNoSrcPos p (grecip mkNoSrcPos p) fy)
(!/) :: Fractional a => RefSrcPos -> RefExp -> R (Fun a (Fun a a))
(|/) :: Fractional a => R (Fun a (Fun a a))
grecip :: Fractional a => RefSrcPos -> RefExp -> R (Fun a a)
srecip :: Fractional a => R (Fun a a)
gfromRational :: Fractional a => RefSrcPos -> RefExp -> R (Fun Rational a)
sfromRational :: Fractional a => R (Fun Rational a)
class Fractional a => Floating a where spi = gundefined mkNoSrcPos p sexp = gundefined mkNoSrcPos p slog = gundefined mkNoSrcPos p ssin = gundefined mkNoSrcPos p scos = gundefined mkNoSrcPos p sasin = gundefined mkNoSrcPos p sacos = gundefined mkNoSrcPos p satan = gundefined mkNoSrcPos p ssinh = gundefined mkNoSrcPos p scosh = gundefined mkNoSrcPos p sasinh = gundefined mkNoSrcPos p sacosh = gundefined mkNoSrcPos p satanh = gundefined mkNoSrcPos p (%**) !** p = ufun2 (+#>#=*=#>#=%>**) (%**) p (***) where (fx *** fy) p = uap1 mkNoSrcPos p (gexp mkNoSrcPos p) (uap2 mkNoSrcPos p ((!*) mkNoSrcPos p) (uap1 mkNoSrcPos p (glog mkNoSrcPos p) fx) fy) glogBase plogBase p = ufun2 c192v5v192v37logBase plogBase p hlogBase where hlogBase fx fy p = uap2 mkNoSrcPos p ((!/) mkNoSrcPos p) (uap1 mkNoSrcPos p (glog mkNoSrcPos p) fy) (uap1 mkNoSrcPos p (glog mkNoSrcPos p) fx) gsqrt psqrt p = ufun1 c193v5v193v32sqrt psqrt p hsqrt where hsqrt fx p = uap2 mkNoSrcPos p ((!**) mkNoSrcPos p) fx (uap1 mkNoSrcPos p (gfromRational mkNoSrcPos p) (R ((:%) (conInteger mkNoSrcPos p (1)) (conInteger mkNoSrcPos p (2))) (mkAtomRational mkNoSrcPos p 0.5))) gtan ptan p = ufun1 c194v5v194v39tan ptan p htan where htan fx p = uap2 mkNoSrcPos p ((!/) mkNoSrcPos p) (uap1 mkNoSrcPos p (gsin mkNoSrcPos p) fx) (uap1 mkNoSrcPos p (gcos mkNoSrcPos p) fx) gtanh ptanh p = ufun1 c195v5v195v39tanh ptanh p htanh where htanh fx p = uap2 mkNoSrcPos p ((!/) mkNoSrcPos p) (uap1 mkNoSrcPos p (gsinh mkNoSrcPos p) fx) (uap1 mkNoSrcPos p (gcosh mkNoSrcPos p) fx)
gpi :: Floating a => RefSrcPos -> RefExp -> R a
spi :: Floating a => R a
gexp, gsqrt, glog :: Floating a => RefSrcPos -> RefExp -> R (Fun a a)
sexp, ssqrt, slog :: Floating a => R (Fun a a)
(!**, glogBase) :: Floating a => RefSrcPos -> RefExp -> R (Fun a (Fun a a))
(|**, slogBase) :: Floating a => R (Fun a (Fun a a))
gsin, gtan, gcos :: Floating a => RefSrcPos -> RefExp -> R (Fun a a)
ssin, stan, scos :: Floating a => R (Fun a a)
gasin, gatan, gacos :: Floating a => RefSrcPos -> RefExp -> R (Fun a a)
sasin, satan, sacos :: Floating a => R (Fun a a)
gsinh, gtanh, gcosh :: Floating a => RefSrcPos -> RefExp -> R (Fun a a)
ssinh, stanh, scosh :: Floating a => R (Fun a a)
gasinh, gatanh, gacosh :: Floating a => RefSrcPos -> RefExp -> R (Fun a a)
sasinh, satanh, sacosh :: Floating a => R (Fun a a)
class (Real a, Fractional a) => RealFrac a where sproperFraction = gundefined mkNoSrcPos p gtruncate ptruncate p = ufun1 c206v5v206v32truncate ptruncate p htruncate where htruncate fx p = gm mkNoSrcPos p where gm pm p = uconstUse pm p sm sm = uconstDef p c206v34v206v57m (\ _ -> case j206v34v206v57m of { (km, fm) -> fm }) j206v34v206v57m = case uap1 mkNoSrcPos p (gproperFraction mkNoSrcPos p) fx of { R (Tuple2 fm _) km -> (km, fm) _ -> fatal p } ground pround p = ufun1 c208v5v221v0round pround p hround where hround fx p = let gn pn p = uconstUse pn p sn gr pr p = uconstUse pr p sr sn = uconstDef p c208v29v208v52n (\ _ -> case j208v29v208v52n of { (kn, fn, fr) -> fn }) sr = uconstDef p c208v29v208v52r (\ _ -> case j208v29v208v52n of { (kn, fn, fr) -> fr }) j208v29v208v52n = case uap1 mkNoSrcPos p (gproperFraction mkNoSrcPos p) fx of { R (Tuple2 fn fr) kn -> (kn, fn, fr) _ -> fatal p } gm pm p = uconstUse pm p sm sm = uconstDef p c209v29v209v66m (\ p -> ucif p (uap2 mkNoSrcPos p ((!<) mkNoSrcPos p) (gr mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) (uap2 mkNoSrcPos p ((!-) mkNoSrcPos p) (gn mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (1)))) (uap2 mkNoSrcPos p ((!+) mkNoSrcPos p) (gn mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (1))))) in uccase mkNoSrcPos p (let v210v30v221v0v1 (R LT _) p = gn mkNoSrcPos p v210v30v221v0v1 (R EQ _) p = ucif p (uwrapForward p (heven (gn mkNoSrcPos p) p)) (gn mkNoSrcPos p) (gm mkNoSrcPos p) v210v30v221v0v1 (R GT _) p = gm mkNoSrcPos p v210v30v221v0v1 _ p = fatal p in v210v30v221v0v1) (uap2 mkNoSrcPos p (gcompare mkNoSrcPos p) (uap1 mkNoSrcPos p (gsignum mkNoSrcPos p) (uap2 mkNoSrcPos p ((!-) mkNoSrcPos p) (uap1 mkNoSrcPos p (gabs mkNoSrcPos p) (gr mkNoSrcPos p)) (uap1 mkNoSrcPos p (gfromRational mkNoSrcPos p) (R ((:%) (conInteger mkNoSrcPos p (1)) (conInteger mkNoSrcPos p (2))) (mkAtomRational mkNoSrcPos p 0.5))))) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) gceiling pceiling p = ufun1 c221v5v222v29ceiling pceiling p hceiling where hceiling fx p = ucif p (uap2 mkNoSrcPos p ((!>) mkNoSrcPos p) (gr mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) (uap2 mkNoSrcPos p ((!+) mkNoSrcPos p) (gn mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (1)))) (gn mkNoSrcPos p) where gn pn p = uconstUse pn p sn gr pr p = uconstUse pr p sr sn = uconstDef p c222v31v222v54n (\ _ -> case j222v31v222v54n of { (kn, fn, fr) -> fn }) sr = uconstDef p c222v31v222v54r (\ _ -> case j222v31v222v54n of { (kn, fn, fr) -> fr }) j222v31v222v54n = case uap1 mkNoSrcPos p (gproperFraction mkNoSrcPos p) fx of { R (Tuple2 fn fr) kn -> (kn, fn, fr) _ -> fatal p } gfloor pfloor p = ufun1 c224v5v225v29floor pfloor p hfloor where hfloor fx p = ucif p (uap2 mkNoSrcPos p ((!<) mkNoSrcPos p) (gr mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) (uap2 mkNoSrcPos p ((!-) mkNoSrcPos p) (gn mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (1)))) (gn mkNoSrcPos p) where gn pn p = uconstUse pn p sn gr pr p = uconstUse pr p sr sn = uconstDef p c225v31v225v54n (\ _ -> case j225v31v225v54n of { (kn, fn, fr) -> fn }) sr = uconstDef p c225v31v225v54r (\ _ -> case j225v31v225v54n of { (kn, fn, fr) -> fr }) j225v31v225v54n = case uap1 mkNoSrcPos p (gproperFraction mkNoSrcPos p) fx of { R (Tuple2 fn fr) kn -> (kn, fn, fr) _ -> fatal p }
gproperFraction :: (RealFrac a, Integral b) => RefSrcPos -> RefExp -> R (Fun a (Tuple2 b a))
sproperFraction :: (RealFrac a, Integral b) => R (Fun a (Tuple2 b a))
gtruncate, ground :: (RealFrac a, Integral b) => RefSrcPos -> RefExp -> R (Fun a b)
struncate, sround :: (RealFrac a, Integral b) => R (Fun a b)
gceiling, gfloor :: (RealFrac a, Integral b) => RefSrcPos -> RefExp -> R (Fun a b)
sceiling, sfloor :: (RealFrac a, Integral b) => R (Fun a b)
class (RealFrac a, Floating a) => RealFloat a where sfloatRadix = gundefined mkNoSrcPos p sfloatDigits = gundefined mkNoSrcPos p sfloatRange = gundefined mkNoSrcPos p sdecodeFloat = gundefined mkNoSrcPos p sencodeFloat = gundefined mkNoSrcPos p sisNaN = gundefined mkNoSrcPos p sisInfinite = gundefined mkNoSrcPos p sisDenormalized = gundefined mkNoSrcPos p sisNegativeZero = gundefined mkNoSrcPos p sisIEEE = gundefined mkNoSrcPos p gexponent pexponent p = ufun1 c244v5v245v29exponent pexponent p hexponent where hexponent fx p = ucif p (uap2 mkNoSrcPos p ((!==) mkNoSrcPos p) (gm mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0))) (uap2 mkNoSrcPos p ((!+) mkNoSrcPos p) (gn mkNoSrcPos p) (uap1 mkNoSrcPos p (gfloatDigits mkNoSrcPos p) fx)) where gm pm p = uconstUse pm p sm gn pn p = uconstUse pn p sn sm = uconstDef p c245v31v245v51m (\ _ -> case j245v31v245v51m of { (km, fm, fn) -> fm }) sn = uconstDef p c245v31v245v51n (\ _ -> case j245v31v245v51m of { (km, fm, fn) -> fn }) j245v31v245v51m = case uap1 mkNoSrcPos p (gdecodeFloat mkNoSrcPos p) fx of { R (Tuple2 fm fn) km -> (km, fm, fn) _ -> fatal p } gsignificand psignificand p = ufun1 c247v5v248v29significand psignificand p hsignificand where hsignificand fx p = uap2 mkNoSrcPos p (gencodeFloat mkNoSrcPos p) (gm mkNoSrcPos p) (uap1 mkNoSrcPos p (gnegate mkNoSrcPos p) (uap1 mkNoSrcPos p (gfloatDigits mkNoSrcPos p) fx)) where gm pm p = uconstUse pm p sm sm = uconstDef p c248v31v248v51m (\ _ -> case j248v31v248v51m of { (km, fm) -> fm }) j248v31v248v51m = case uap1 mkNoSrcPos p (gdecodeFloat mkNoSrcPos p) fx of { R (Tuple2 fm _) km -> (km, fm) _ -> fatal p } gscaleFloat pscaleFloat p = ufun2 c250v5v251v29scaleFloat pscaleFloat p hscaleFloat where hscaleFloat fk fx p = uap2 mkNoSrcPos p (gencodeFloat mkNoSrcPos p) (gm mkNoSrcPos p) (uap2 mkNoSrcPos p ((!+) mkNoSrcPos p) (gn mkNoSrcPos p) fk) where gm pm p = uconstUse pm p sm gn pn p = uconstUse pn p sn sm = uconstDef p c251v31v251v51m (\ _ -> case j251v31v251v51m of { (km, fm, fn) -> fm }) sn = uconstDef p c251v31v251v51n (\ _ -> case j251v31v251v51m of { (km, fm, fn) -> fn }) j251v31v251v51m = case uap1 mkNoSrcPos p (gdecodeFloat mkNoSrcPos p) fx of { R (Tuple2 fm fn) km -> (km, fm, fn) _ -> fatal p } gatan2 patan2 p = ufun2 c253v5v264v30atan2 patan2 p hatan2 where hatan2 fy fx p = ucguard (uap2 mkNoSrcPos p ((!>) mkNoSrcPos p) fx (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) (uap1 mkNoSrcPos p (gatan mkNoSrcPos p) (uap2 mkNoSrcPos p ((!/) mkNoSrcPos p) fy fx)) (ucguard (uwrapForward p ((*&&) (uap2 mkNoSrcPos p ((!==) mkNoSrcPos p) fx (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) (uap2 mkNoSrcPos p ((!>) mkNoSrcPos p) fy (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) p)) (uap2 mkNoSrcPos p ((!/) mkNoSrcPos p) (gpi mkNoSrcPos p) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (2)))) (ucguard (uwrapForward p ((*&&) (uap2 mkNoSrcPos p ((!<) mkNoSrcPos p) fx (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) (uap2 mkNoSrcPos p ((!>) mkNoSrcPos p) fy (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) p)) (uap2 mkNoSrcPos p ((!+) mkNoSrcPos p) (gpi mkNoSrcPos p) (uap1 mkNoSrcPos p (gatan mkNoSrcPos p) (uap2 mkNoSrcPos p ((!/) mkNoSrcPos p) fy fx))) (ucguard (uwrapForward p ((*||) (uwrapForward p ((*&&) (uap2 mkNoSrcPos p ((!<=) mkNoSrcPos p) fx (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) (uap2 mkNoSrcPos p ((!<) mkNoSrcPos p) fy (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) p)) (uwrapForward p ((*||) (uwrapForward p ((*&&) (uap2 mkNoSrcPos p ((!<) mkNoSrcPos p) fx (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) (uap1 mkNoSrcPos p (gisNegativeZero mkNoSrcPos p) fy) p)) (uwrapForward p ((*&&) (uap1 mkNoSrcPos p (gisNegativeZero mkNoSrcPos p) fx) (uap1 mkNoSrcPos p (gisNegativeZero mkNoSrcPos p) fy) p)) p)) p)) (uap1 mkNoSrcPos p (gnegate mkNoSrcPos p) (uap2 mkNoSrcPos p (gatan2 mkNoSrcPos p) (uap1 mkNoSrcPos p (gnegate mkNoSrcPos p) fy) fx)) (ucguard (uwrapForward p ((*&&) (uap2 mkNoSrcPos p ((!==) mkNoSrcPos p) fy (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) (uwrapForward p ((*||) (uap2 mkNoSrcPos p ((!<) mkNoSrcPos p) fx (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) (uap1 mkNoSrcPos p (gisNegativeZero mkNoSrcPos p) fx) p)) p)) (gpi mkNoSrcPos p) (ucguard (uwrapForward p ((*&&) (uap2 mkNoSrcPos p ((!==) mkNoSrcPos p) fx (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) (uap2 mkNoSrcPos p ((!==) mkNoSrcPos p) fy (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0)))) p)) (projection mkNoSrcPos p fy) (ucguard (gotherwise mkNoSrcPos p) (uap2 mkNoSrcPos p ((!+) mkNoSrcPos p) fx fy) (fatal p)))))))
gfloatRadix :: RealFloat a => RefSrcPos -> RefExp -> R (Fun a Integer)
sfloatRadix :: RealFloat a => R (Fun a Integer)
gfloatDigits :: RealFloat a => RefSrcPos -> RefExp -> R (Fun a Int)
sfloatDigits :: RealFloat a => R (Fun a Int)
gfloatRange :: RealFloat a => RefSrcPos -> RefExp -> R (Fun a (Tuple2 Int Int))
sfloatRange :: RealFloat a => R (Fun a (Tuple2 Int Int))
gdecodeFloat :: RealFloat a => RefSrcPos -> RefExp -> R (Fun a (Tuple2 Integer Int))
sdecodeFloat :: RealFloat a => R (Fun a (Tuple2 Integer Int))
gencodeFloat :: RealFloat a => RefSrcPos -> RefExp -> R (Fun Integer (Fun Int a))
sencodeFloat :: RealFloat a => R (Fun Integer (Fun Int a))
gexponent :: RealFloat a => RefSrcPos -> RefExp -> R (Fun a Int)
sexponent :: RealFloat a => R (Fun a Int)
gsignificand :: RealFloat a => RefSrcPos -> RefExp -> R (Fun a a)
ssignificand :: RealFloat a => R (Fun a a)
gscaleFloat :: RealFloat a => RefSrcPos -> RefExp -> R (Fun Int (Fun a a))
sscaleFloat :: RealFloat a => R (Fun Int (Fun a a))
gisNaN, gisIEEE, gisNegativeZero, gisDenormalized, gisInfinite :: RealFloat a => RefSrcPos -> RefExp -> R (Fun a Bool)
sisNaN, sisIEEE, sisNegativeZero, sisDenormalized, sisInfinite :: RealFloat a => R (Fun a Bool)
gatan2 :: RealFloat a => RefSrcPos -> RefExp -> R (Fun a (Fun a a))
satan2 :: RealFloat a => R (Fun a (Fun a a))
class Monad m where (|>>=) = gundefined mkNoSrcPos p sreturn = gundefined mkNoSrcPos p (%>>) !>> p = ufun2 (+%$^=*=%$^=$@>>) (%>>) p (*>>) where (fm *>> fk) p = uap2 mkNoSrcPos p ((!>>=) mkNoSrcPos p) fm (ufun1 mkLambda mkNoSrcPos p (\ _ p -> projection mkNoSrcPos p fk)) gfail pfail p = ufun1 c328v5v328v21fail pfail p hfail where hfail fs p = uwrapForward p (herror fs p)
(!>>=) :: Monad m => RefSrcPos -> RefExp -> R (Fun (m a) (Fun (Fun a (m b)) (m b)))
(|>>=) :: Monad m => R (Fun (m a) (Fun (Fun a (m b)) (m b)))
(!>>) :: Monad m => RefSrcPos -> RefExp -> R (Fun (m a) (Fun (m b) (m b)))
(|>>) :: Monad m => R (Fun (m a) (Fun (m b) (m b)))
greturn :: Monad m => RefSrcPos -> RefExp -> R (Fun a (m a))
sreturn :: Monad m => R (Fun a (m a))
gfail :: Monad m => RefSrcPos -> RefExp -> R (Fun String (m a))
sfail :: Monad m => R (Fun String (m a))
class Functor f where sfmap = gundefined mkNoSrcPos p
gfmap :: Functor f => RefSrcPos -> RefExp -> R (Fun (Fun a b) (Fun (f a) (f b)))
sfmap :: Functor f => R (Fun (Fun a b) (Fun (f a) (f b)))
gmapM :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a (m b)) (Fun (List a) (m (List b))))
amapM :: RefAtom
hmapM :: Monad m => R (Fun a (m b)) -> R (List a) -> RefExp -> R (m (List b))
gmapM_ :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a (m b)) (Fun (List a) (m Tuple0)))
amapM_ :: RefAtom
hmapM_ :: Monad m => R (Fun a (m b)) -> R (List a) -> RefExp -> R (m Tuple0)
gsequence :: Monad m => RefSrcPos -> RefExp -> R (Fun (List (m a)) (m (List a)))
gsequence_ :: Monad m => RefSrcPos -> RefExp -> R (Fun (List (m a)) (m Tuple0))
(!=<<) :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a (m b)) (Fun (m a) (m b)))
(+=<<) :: RefAtom
(*=<<) :: Monad m => R (Fun a (m b)) -> R (m a) -> RefExp -> R (m b)
gmaybe :: RefSrcPos -> RefExp -> R (Fun b (Fun (Fun a b) (Fun (Maybe a) b)))
amaybe :: RefAtom
hmaybe :: R b -> R (Fun a b) -> R (Maybe a) -> RefExp -> R b
geither :: RefSrcPos -> RefExp -> R (Fun (Fun a c) (Fun (Fun b c) (Fun (Either a b) c)))
aeither :: RefAtom
heither :: R (Fun a c) -> R (Fun b c) -> R (Either a b) -> RefExp -> R c
(!&&) :: RefSrcPos -> RefExp -> R (Fun Bool (Fun Bool Bool))
(+&&) :: RefAtom
(*&&) :: R Bool -> R Bool -> RefExp -> R Bool
(!||) :: RefSrcPos -> RefExp -> R (Fun Bool (Fun Bool Bool))
(+||) :: RefAtom
(*||) :: R Bool -> R Bool -> RefExp -> R Bool
gnot :: RefSrcPos -> RefExp -> R (Fun Bool Bool)
anot :: RefAtom
hnot :: R Bool -> RefExp -> R Bool
gotherwise :: RefSrcPos -> RefExp -> R Bool
gsubtract :: Num a => RefSrcPos -> RefExp -> R (Fun a (Fun a a))
geven :: Integral a => RefSrcPos -> RefExp -> R (Fun a Bool)
aeven :: RefAtom
heven :: Integral a => R a -> RefExp -> R Bool
godd :: Integral a => RefSrcPos -> RefExp -> R (Fun a Bool)
ggcd :: Integral a => RefSrcPos -> RefExp -> R (Fun a (Fun a a))
agcd :: RefAtom
hgcd :: Integral a => R a -> R a -> RefExp -> R a
glcm :: Integral a => RefSrcPos -> RefExp -> R (Fun a (Fun a a))
alcm :: RefAtom
hlcm :: Integral a => R a -> R a -> RefExp -> R a
(!^) :: (Num a, Integral b) => RefSrcPos -> RefExp -> R (Fun a (Fun b a))
(+^) :: RefAtom
(*^) :: (Num a, Integral b) => R a -> R b -> RefExp -> R a
(!^^) :: (Fractional a, Integral b) => RefSrcPos -> RefExp -> R (Fun a (Fun b a))
(+^^) :: RefAtom
(*^^) :: (Fractional a, Integral b) => R a -> R b -> RefExp -> R a
gfromIntegral :: (Integral a, Num b) => RefSrcPos -> RefExp -> R (Fun a b)
grealToFrac :: (Real a, Fractional b) => RefSrcPos -> RefExp -> R (Fun a b)
gfst :: RefSrcPos -> RefExp -> R (Fun (Tuple2 a b) a)
afst :: RefAtom
hfst :: R (Tuple2 a b) -> RefExp -> R a
gsnd :: RefSrcPos -> RefExp -> R (Fun (Tuple2 a b) b)
asnd :: RefAtom
hsnd :: R (Tuple2 a b) -> RefExp -> R b
gcurry :: RefSrcPos -> RefExp -> R (Fun (Fun (Tuple2 a b) c) (Fun a (Fun b c)))
acurry :: RefAtom
hcurry :: R (Fun (Tuple2 a b) c) -> R a -> R b -> RefExp -> R c
guncurry :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b c)) (Fun (Tuple2 a b) c))
auncurry :: RefAtom
huncurry :: R (Fun a (Fun b c)) -> (R (Tuple2 a b) -> RefExp -> R c)
gid :: RefSrcPos -> RefExp -> R (Fun a a)
aid :: RefAtom
hid :: R a -> RefExp -> R a
gconst :: RefSrcPos -> RefExp -> R (Fun a (Fun b a))
aconst :: RefAtom
hconst :: R a -> R b -> RefExp -> R a
(!.) :: RefSrcPos -> RefExp -> R (Fun (Fun b c) (Fun (Fun a b) (Fun a c)))
(+.) :: RefAtom
(*.) :: R (Fun b c) -> R (Fun a b) -> R a -> RefExp -> R c
gflip :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b c)) (Fun b (Fun a c)))
aflip :: RefAtom
hflip :: R (Fun a (Fun b c)) -> R b -> R a -> RefExp -> R c
(!$) :: RefSrcPos -> RefExp -> R (Fun (Fun a b) (Fun a b))
(+$) :: RefAtom
(*$) :: R (Fun a b) -> R a -> RefExp -> R b
guntil :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (Fun a a) (Fun a a)))
auntil :: RefAtom
huntil :: R (Fun a Bool) -> R (Fun a a) -> R a -> RefExp -> R a
gasTypeOf :: RefSrcPos -> RefExp -> R (Fun a (Fun a a))
gerror :: RefSrcPos -> RefExp -> R (Fun String z)
aerror :: RefAtom
herror :: R String -> RefExp -> a
gundefined :: RefSrcPos -> RefExp -> R a
gseq :: RefSrcPos -> RefExp -> R (Fun a (Fun b b))
aseq :: RefAtom
hseq :: R a1 -> R a -> RefExp -> R a
(!$!) :: RefSrcPos -> RefExp -> R (Fun (Fun a b) (Fun a b))
(+$!) :: RefAtom
(*$!) :: R (Fun a b) -> R a -> RefExp -> R b

module Hat.Char
gisAscii :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisAscii :: RefAtom
hisAscii :: R Char -> RefExp -> R Bool
gisLatin1 :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisLatin1 :: RefAtom
hisLatin1 :: R Char -> RefExp -> R Bool
gisControl :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisControl :: RefAtom
hisControl :: R Char -> RefExp -> R Bool
gisPrint :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisPrint :: RefAtom
hisPrint :: R Char -> RefExp -> R Bool
gisSpace :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisSpace :: RefAtom
hisSpace :: R Char -> RefExp -> R Bool
gisUpper :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisUpper :: RefAtom
hisUpper :: R Char -> RefExp -> R Bool
gisLower :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisLower :: RefAtom
hisLower :: R Char -> RefExp -> R Bool
gisAlpha :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisAlpha :: RefAtom
hisAlpha :: R Char -> RefExp -> R Bool
gisDigit :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisDigit :: RefAtom
hisDigit :: R Char -> RefExp -> R Bool
gisOctDigit :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisOctDigit :: RefAtom
hisOctDigit :: R Char -> RefExp -> R Bool
gisHexDigit :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisHexDigit :: RefAtom
hisHexDigit :: R Char -> RefExp -> R Bool
gisAlphaNum :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisAlphaNum :: RefAtom
hisAlphaNum :: R Char -> RefExp -> R Bool
gdigitToInt :: RefSrcPos -> RefExp -> R (Fun Char Int)
adigitToInt :: RefAtom
hdigitToInt :: R Char -> RefExp -> R Int
gintToDigit :: RefSrcPos -> RefExp -> R (Fun Int Char)
aintToDigit :: RefAtom
hintToDigit :: R Int -> RefExp -> R Char
gtoUpper :: RefSrcPos -> RefExp -> R (Fun Char Char)
atoUpper :: RefAtom
htoUpper :: R Char -> RefExp -> R Char
gtoLower :: RefSrcPos -> RefExp -> R (Fun Char Char)
atoLower :: RefAtom
htoLower :: R Char -> RefExp -> R Char
gord :: RefSrcPos -> RefExp -> R (Fun Char Int)
gchr :: RefSrcPos -> RefExp -> R (Fun Int Char)
greadLitChar :: RefSrcPos -> RefExp -> R (ReadS Char)
areadLitChar :: RefAtom
hreadLitChar :: R (ReadS___1 Char) -> RefExp -> R (ReadS___2 Char)
gshowLitChar :: RefSrcPos -> RefExp -> R (Fun Char ShowS)
ashowLitChar :: RefAtom
hshowLitChar :: R Char -> RefExp -> R ShowS
glexLitChar :: RefSrcPos -> RefExp -> R (ReadS String)
alexLitChar :: RefAtom
hlexLitChar :: R (ReadS___1 String) -> RefExp -> R (ReadS___2 String)

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) characters (see
--   <a>http://www.unicode.org/</a> for details). This set extends the ISO
--   8859-1 (Latin-1) character set (the first 256 characters), which is
--   itself an extension of the ASCII character set (the first 128
--   characters). A character literal in Haskell has type <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <tt>ord</tt> and
--   <tt>chr</tt>).
data Char :: *
type String = List Char

module Hat.Complex
data Complex a
(:+) :: !(R a) -> !(R a) -> Complex a
(+:+) :: RefAtom
grealPart :: RealFloat a => RefSrcPos -> RefExp -> R (Fun (Complex a) a)
arealPart :: RefAtom
hrealPart :: RealFloat a => R (Complex a) -> RefExp -> R a
gimagPart :: RealFloat a => RefSrcPos -> RefExp -> R (Fun (Complex a) a)
aimagPart :: RefAtom
himagPart :: RealFloat a => R (Complex a) -> RefExp -> R a
gconjugate :: RealFloat a => RefSrcPos -> RefExp -> R (Fun (Complex a) (Complex a))
aconjugate :: RefAtom
hconjugate :: RealFloat a => R (Complex a) -> RefExp -> R (Complex a)
gmkPolar :: RealFloat a => RefSrcPos -> RefExp -> R (Fun a (Fun a (Complex a)))
amkPolar :: RefAtom
hmkPolar :: RealFloat a => R a -> R a -> RefExp -> R (Complex a)
gcis :: RealFloat a => RefSrcPos -> RefExp -> R (Fun a (Complex a))
acis :: RefAtom
hcis :: RealFloat a => R a -> RefExp -> R (Complex a)
gpolar :: RealFloat a => RefSrcPos -> RefExp -> R (Fun (Complex a) (Tuple2 a a))
apolar :: RefAtom
hpolar :: RealFloat a => R (Complex a) -> RefExp -> R (Tuple2 a a)
gmagnitude :: RealFloat a => RefSrcPos -> RefExp -> R (Fun (Complex a) a)
amagnitude :: RefAtom
hmagnitude :: RealFloat a => R (Complex a) -> RefExp -> R a
gphase :: RealFloat a => RefSrcPos -> RefExp -> R (Fun (Complex a) a)
aphase :: RefAtom
hphase :: RealFloat a => R (Complex a) -> RefExp -> R a
instance RealFloat a => Floating (Complex a)
instance RealFloat a => Fractional (Complex a)
instance RealFloat a => Num (Complex a)
instance Show a => Show (Complex a)
instance Read a => Read (Complex a)
instance Eq a => Eq (Complex a)
instance WrapVal (Complex a)

module Hat.CPUTime
ggetCPUTime :: RefSrcPos -> RefExp -> R (IO Integer)
gcpuTimePrecision :: RefSrcPos -> RefExp -> R Integer

module Hat.Maybe
gisJust :: RefSrcPos -> RefExp -> R (Fun (Maybe a) Bool)
aisJust :: RefAtom
hisJust :: R (Maybe a) -> RefExp -> R Bool
gisNothing :: RefSrcPos -> RefExp -> R (Fun (Maybe a) Bool)
gfromJust :: RefSrcPos -> RefExp -> R (Fun (Maybe a) a)
afromJust :: RefAtom
hfromJust :: R (Maybe a) -> RefExp -> R a
gfromMaybe :: RefSrcPos -> RefExp -> R (Fun a (Fun (Maybe a) a))
afromMaybe :: RefAtom
hfromMaybe :: R a -> R (Maybe a) -> RefExp -> R a
glistToMaybe :: RefSrcPos -> RefExp -> R (Fun (List a) (Maybe a))
alistToMaybe :: RefAtom
hlistToMaybe :: R (List a) -> RefExp -> R (Maybe a)
gmaybeToList :: RefSrcPos -> RefExp -> R (Fun (Maybe a) (List a))
amaybeToList :: RefAtom
hmaybeToList :: R (Maybe a) -> RefExp -> R (List a)
gcatMaybes :: RefSrcPos -> RefExp -> R (Fun (List (Maybe a)) (List a))
acatMaybes :: RefAtom
hcatMaybes :: R (List (Maybe a)) -> RefExp -> R (List a)
gmapMaybe :: RefSrcPos -> RefExp -> R (Fun (Fun a (Maybe b)) (Fun (List a) (List b)))
amapMaybe :: RefAtom
hmapMaybe :: R (Fun a (Maybe b)) -> RefExp -> R (Fun (List a) (List b))
data Maybe a
Nothing :: Maybe a
Just :: (R a) -> Maybe a
aNothing :: RefAtom
aJust :: RefAtom
gmaybe :: RefSrcPos -> RefExp -> R (Fun b (Fun (Fun a b) (Fun (Maybe a) b)))
amaybe :: RefAtom
hmaybe :: R b -> R (Fun a b) -> R (Maybe a) -> RefExp -> R b

module Hat.List
gelemIndex :: Eq a => RefSrcPos -> RefExp -> R (Fun a (Fun (List a) (Maybe Int)))
aelemIndex :: RefAtom
helemIndex :: Eq a => R a -> RefExp -> R (Fun (List a) (Maybe Int))
gelemIndices :: Eq a => RefSrcPos -> RefExp -> R (Fun a (Fun (List a) (List Int)))
aelemIndices :: RefAtom
helemIndices :: Eq a => R a -> RefExp -> R (Fun (List a) (List Int))
gfind :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) (Maybe a)))
afind :: RefAtom
hfind :: R (Fun a Bool) -> RefExp -> R (Fun (List a) (Maybe a))
gfindIndex :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) (Maybe Int)))
afindIndex :: RefAtom
hfindIndex :: R (Fun a Bool) -> RefExp -> R (Fun (List a) (Maybe Int))
gfindIndices :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) (List Int)))
afindIndices :: RefAtom
hfindIndices :: R (Fun a Bool) -> R (List a) -> RefExp -> R (List Int)
gnub :: Eq a => RefSrcPos -> RefExp -> R (Fun (List a) (List a))
gnubBy :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a Bool)) (Fun (List a) (List a)))
anubBy :: RefAtom
hnubBy :: R (Fun a (Fun a Bool)) -> R (List a) -> RefExp -> R (List a)
gdelete :: Eq a => RefSrcPos -> RefExp -> R (Fun a (Fun (List a) (List a)))
gdeleteBy :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a Bool)) (Fun a (Fun (List a) (List a))))
adeleteBy :: RefAtom
hdeleteBy :: R (Fun a (Fun a Bool)) -> R a -> R (List a) -> RefExp -> R (List a)
(!\\) :: Eq a => RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List a) (List a)))
gdeleteFirstsBy :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a Bool)) (Fun (List a) (Fun (List a) (List a))))
adeleteFirstsBy :: RefAtom
hdeleteFirstsBy :: R (Fun a (Fun a Bool)) -> RefExp -> R (Fun (List a) (Fun (List a) (List a)))
gunion :: Eq a => RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List a) (List a)))
gunionBy :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a Bool)) (Fun (List a) (Fun (List a) (List a))))
aunionBy :: RefAtom
hunionBy :: R (Fun a (Fun a Bool)) -> R (List a) -> R (List a) -> RefExp -> R (List a)
gintersect :: Eq a => RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List a) (List a)))
gintersectBy :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a Bool)) (Fun (List a) (Fun (List a) (List a))))
aintersectBy :: RefAtom
hintersectBy :: R (Fun a (Fun a Bool)) -> R (List a) -> R (List a) -> RefExp -> R (List a)
gintersperse :: RefSrcPos -> RefExp -> R (Fun a (Fun (List a) (List a)))
aintersperse :: RefAtom
hintersperse :: R a -> R (List a) -> RefExp -> R (List a)
gtranspose :: RefSrcPos -> RefExp -> R (Fun (List (List a)) (List (List a)))
atranspose :: RefAtom
htranspose :: R (List (List a)) -> RefExp -> R (List (List a))
gpartition :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) (Tuple2 (List a) (List a))))
apartition :: RefAtom
hpartition :: R (Fun a Bool) -> R (List a) -> RefExp -> R (Tuple2 (List a) (List a))
ggroup :: Eq a => RefSrcPos -> RefExp -> R (Fun (List a) (List (List a)))
ggroupBy :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a Bool)) (Fun (List a) (List (List a))))
agroupBy :: RefAtom
hgroupBy :: R (Fun a (Fun a Bool)) -> R (List a) -> RefExp -> R (List (List a))
ginits :: RefSrcPos -> RefExp -> R (Fun (List a) (List (List a)))
ainits :: RefAtom
hinits :: R (List a) -> RefExp -> R (List (List a))
gtails :: RefSrcPos -> RefExp -> R (Fun (List a) (List (List a)))
atails :: RefAtom
htails :: R (List a) -> RefExp -> R (List (List a))
gisPrefixOf :: Eq a => RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List a) Bool))
aisPrefixOf :: RefAtom
hisPrefixOf :: Eq a => R (List a) -> R (List a) -> RefExp -> R Bool
gisSuffixOf :: Eq a => RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List a) Bool))
aisSuffixOf :: RefAtom
hisSuffixOf :: Eq a => R (List a) -> R (List a) -> RefExp -> R Bool
gmapAccumL :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b (Tuple2 a c))) (Fun a (Fun (List b) (Tuple2 a (List c)))))
amapAccumL :: RefAtom
hmapAccumL :: R (Fun a (Fun b (Tuple2 a c))) -> R a -> R (List b) -> RefExp -> R (Tuple2 a (List c))
gmapAccumR :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b (Tuple2 a c))) (Fun a (Fun (List b) (Tuple2 a (List c)))))
amapAccumR :: RefAtom
hmapAccumR :: R (Fun a (Fun b (Tuple2 a c))) -> R a -> R (List b) -> RefExp -> R (Tuple2 a (List c))
gsort :: Ord a => RefSrcPos -> RefExp -> R (Fun (List a) (List a))
gsortBy :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a Ordering)) (Fun (List a) (List a)))
asortBy :: RefAtom
hsortBy :: R (Fun a (Fun a Ordering)) -> RefExp -> R (Fun (List a) (List a))
ginsert :: Ord a => RefSrcPos -> RefExp -> R (Fun a (Fun (List a) (List a)))
ginsertBy :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a Ordering)) (Fun a (Fun (List a) (List a))))
ainsertBy :: RefAtom
hinsertBy :: R (Fun a (Fun a Ordering)) -> R a -> R (List a) -> RefExp -> R (List a)
gmaximumBy :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a Ordering)) (Fun (List a) a))
amaximumBy :: RefAtom
hmaximumBy :: R (Fun a (Fun a Ordering)) -> R (List a) -> RefExp -> R a
gminimumBy :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a Ordering)) (Fun (List a) a))
aminimumBy :: RefAtom
hminimumBy :: R (Fun a (Fun a Ordering)) -> R (List a) -> RefExp -> R a
ggenericLength :: Integral a => RefSrcPos -> RefExp -> R (Fun (List b) a)
agenericLength :: RefAtom
hgenericLength :: Integral a => R (List b) -> RefExp -> R a
ggenericTake :: Integral a => RefSrcPos -> RefExp -> R (Fun a (Fun (List b) (List b)))
agenericTake :: RefAtom
hgenericTake :: Integral a => R a -> R (List b) -> RefExp -> R (List b)
ggenericDrop :: Integral a => RefSrcPos -> RefExp -> R (Fun a (Fun (List b) (List b)))
agenericDrop :: RefAtom
hgenericDrop :: Integral a => R a -> R (List b) -> RefExp -> R (List b)
ggenericSplitAt :: Integral a => RefSrcPos -> RefExp -> R (Fun a (Fun (List b) (Tuple2 (List b) (List b))))
agenericSplitAt :: RefAtom
hgenericSplitAt :: Integral a => R a -> R (List b) -> RefExp -> R (Tuple2 (List b) (List b))
ggenericIndex :: Integral a => RefSrcPos -> RefExp -> R (Fun (List b) (Fun a b))
agenericIndex :: RefAtom
hgenericIndex :: Integral a => R (List b) -> R a -> RefExp -> R b
ggenericReplicate :: Integral a => RefSrcPos -> RefExp -> R (Fun a (Fun b (List b)))
agenericReplicate :: RefAtom
hgenericReplicate :: Integral a => R a -> R b -> RefExp -> R (List b)
gzip4 :: RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List b) (Fun (List c) (Fun (List d) (List (Tuple4 a b c d))))))
gzip5 :: RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List b) (Fun (List c) (Fun (List d) (Fun (List e) (List (Tuple5 a b c d e)))))))
gzip6 :: RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List b) (Fun (List c) (Fun (List d) (Fun (List e) (Fun (List f) (List (Tuple6 a b c d e f))))))))
gzip7 :: RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List b) (Fun (List c) (Fun (List d) (Fun (List e) (Fun (List f) (Fun (List g) (List (Tuple7 a b c d e f g)))))))))
gzipWith4 :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b (Fun c (Fun d e)))) (Fun (List a) (Fun (List b) (Fun (List c) (Fun (List d) (List e))))))
azipWith4 :: RefAtom
hzipWith4 :: R (Fun a (Fun b (Fun c (Fun d e)))) -> R (List a) -> R (List b) -> R (List c) -> R (List d) -> RefExp -> R (List e)
gzipWith5 :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b (Fun c (Fun d (Fun e f))))) (Fun (List a) (Fun (List b) (Fun (List c) (Fun (List d) (Fun (List e) (List f)))))))
azipWith5 :: RefAtom
hzipWith5 :: R (Fun a (Fun b (Fun c (Fun d (Fun e f))))) -> R (List a) -> R (List b) -> R (List c) -> R (List d) -> R (List e) -> RefExp -> R (List f)
gzipWith6 :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b (Fun c (Fun d (Fun e (Fun f g)))))) (Fun (List a) (Fun (List b) (Fun (List c) (Fun (List d) (Fun (List e) (Fun (List f) (List g))))))))
azipWith6 :: RefAtom
hzipWith6 :: R (Fun a (Fun b (Fun c (Fun d (Fun e (Fun f g)))))) -> R (List a) -> R (List b) -> R (List c) -> R (List d) -> R (List e) -> R (List f) -> RefExp -> R (List g)
gzipWith7 :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b (Fun c (Fun d (Fun e (Fun f (Fun g h))))))) (Fun (List a) (Fun (List b) (Fun (List c) (Fun (List d) (Fun (List e) (Fun (List f) (Fun (List g) (List h)))))))))
azipWith7 :: RefAtom
hzipWith7 :: R (Fun a (Fun b (Fun c (Fun d (Fun e (Fun f (Fun g h))))))) -> R (List a) -> R (List b) -> R (List c) -> R (List d) -> R (List e) -> R (List f) -> R (List g) -> RefExp -> R (List h)
gunzip4 :: RefSrcPos -> RefExp -> R (Fun (List (Tuple4 a b c d)) (Tuple4 (List a) (List b) (List c) (List d)))
gunzip5 :: RefSrcPos -> RefExp -> R (Fun (List (Tuple5 a b c d e)) (Tuple5 (List a) (List b) (List c) (List d) (List e)))
gunzip6 :: RefSrcPos -> RefExp -> R (Fun (List (Tuple6 a b c d e f)) (Tuple6 (List a) (List b) (List c) (List d) (List e) (List f)))
gunzip7 :: RefSrcPos -> RefExp -> R (Fun (List (Tuple7 a b c d e f g)) (Tuple7 (List a) (List b) (List c) (List d) (List e) (List f) (List g)))
gunfoldr :: RefSrcPos -> RefExp -> R (Fun (Fun b (Maybe (Tuple2 a b))) (Fun b (List a)))
aunfoldr :: RefAtom
hunfoldr :: R (Fun b (Maybe (Tuple2 a b))) -> R b -> RefExp -> R (List a)
gmap :: RefSrcPos -> RefExp -> R (Fun (Fun a b) (Fun (List a) (List b)))
amap :: RefAtom
hmap :: R (Fun a b) -> R (List a) -> RefExp -> R (List b)
(!++) :: RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List a) (List a)))
(+++) :: RefAtom
(*++) :: R (List a) -> R (List a) -> RefExp -> R (List a)
gconcat :: RefSrcPos -> RefExp -> R (Fun (List (List a)) (List a))
aconcat :: RefAtom
hconcat :: R (List (List a)) -> RefExp -> R (List a)
gfilter :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) (List a)))
afilter :: RefAtom
hfilter :: R (Fun a Bool) -> R (List a) -> RefExp -> R (List a)
ghead :: RefSrcPos -> RefExp -> R (Fun (List a) a)
ahead :: RefAtom
hhead :: R (List a) -> RefExp -> R a
glast :: RefSrcPos -> RefExp -> R (Fun (List a) a)
alast :: RefAtom
hlast :: R (List a) -> RefExp -> R a
gtail :: RefSrcPos -> RefExp -> R (Fun (List a) (List a))
atail :: RefAtom
htail :: R (List a) -> RefExp -> R (List a)
ginit :: RefSrcPos -> RefExp -> R (Fun (List a) (List a))
ainit :: RefAtom
hinit :: R (List a) -> RefExp -> R (List a)
gnull :: RefSrcPos -> RefExp -> R (Fun (List a) Bool)
anull :: RefAtom
hnull :: R (List a) -> RefExp -> R Bool
glength :: RefSrcPos -> RefExp -> R (Fun (List a) Int)
alength :: RefAtom
hlength :: R (List a) -> RefExp -> R Int
(!!!) :: RefSrcPos -> RefExp -> R (Fun (List a) (Fun Int a))
(+!!) :: RefAtom
(*!!) :: R (List a) -> R Int -> RefExp -> R a
gfoldl :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b a)) (Fun a (Fun (List b) a)))
afoldl :: RefAtom
hfoldl :: R (Fun a (Fun b a)) -> R a -> R (List b) -> RefExp -> R a
gfoldl1 :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a a)) (Fun (List a) a))
afoldl1 :: RefAtom
hfoldl1 :: R (Fun a (Fun a a)) -> R (List a) -> RefExp -> R a
gscanl :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b a)) (Fun a (Fun (List b) (List a))))
ascanl :: RefAtom
hscanl :: R (Fun a (Fun b a)) -> R a -> R (List b) -> RefExp -> R (List a)
gscanl1 :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a a)) (Fun (List a) (List a)))
ascanl1 :: RefAtom
hscanl1 :: R (Fun a (Fun a a)) -> R (List a) -> RefExp -> R (List a)
gfoldr :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b b)) (Fun b (Fun (List a) b)))
afoldr :: RefAtom
hfoldr :: R (Fun a (Fun b b)) -> R b -> R (List a) -> RefExp -> R b
gfoldr1 :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a a)) (Fun (List a) a))
afoldr1 :: RefAtom
hfoldr1 :: R (Fun a (Fun a a)) -> R (List a) -> RefExp -> R a
gscanr :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b b)) (Fun b (Fun (List a) (List b))))
ascanr :: RefAtom
hscanr :: R (Fun a (Fun b b)) -> R b -> R (List a) -> RefExp -> R (List b)
gscanr1 :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a a)) (Fun (List a) (List a)))
ascanr1 :: RefAtom
hscanr1 :: R (Fun a (Fun a a)) -> R (List a) -> RefExp -> R (List a)
giterate :: RefSrcPos -> RefExp -> R (Fun (Fun a a) (Fun a (List a)))
aiterate :: RefAtom
hiterate :: R (Fun a a) -> R a -> RefExp -> R (List a)
grepeat :: RefSrcPos -> RefExp -> R (Fun a (List a))
arepeat :: RefAtom
hrepeat :: R a -> RefExp -> R (List a)
greplicate :: RefSrcPos -> RefExp -> R (Fun Int (Fun a (List a)))
areplicate :: RefAtom
hreplicate :: R Int -> R a -> RefExp -> R (List a)
gcycle :: RefSrcPos -> RefExp -> R (Fun (List a) (List a))
acycle :: RefAtom
hcycle :: R (List a) -> RefExp -> R (List a)
gtake :: RefSrcPos -> RefExp -> R (Fun Int (Fun (List a) (List a)))
atake :: RefAtom
htake :: R Int -> R (List a) -> RefExp -> R (List a)
gdrop :: RefSrcPos -> RefExp -> R (Fun Int (Fun (List a) (List a)))
adrop :: RefAtom
hdrop :: R Int -> R (List a) -> RefExp -> R (List a)
gsplitAt :: RefSrcPos -> RefExp -> R (Fun Int (Fun (List a) (Tuple2 (List a) (List a))))
asplitAt :: RefAtom
hsplitAt :: R Int -> R (List a) -> RefExp -> R (Tuple2 (List a) (List a))
gtakeWhile :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) (List a)))
atakeWhile :: RefAtom
htakeWhile :: R (Fun a Bool) -> R (List a) -> RefExp -> R (List a)
gdropWhile :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) (List a)))
adropWhile :: RefAtom
hdropWhile :: R (Fun a Bool) -> R (List a) -> RefExp -> R (List a)
gspan :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) (Tuple2 (List a) (List a))))
aspan :: RefAtom
hspan :: R (Fun a Bool) -> R (List a) -> RefExp -> R (Tuple2 (List a) (List a))
gbreak :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) (Tuple2 (List a) (List a))))
abreak :: RefAtom
hbreak :: R (Fun a Bool) -> RefExp -> R (Fun (List a) (Tuple2 (List a) (List a)))
glines :: RefSrcPos -> RefExp -> R (Fun String (List String))
alines :: RefAtom
hlines :: R String -> RefExp -> R (List String)
gwords :: RefSrcPos -> RefExp -> R (Fun String (List String))
awords :: RefAtom
hwords :: R String -> RefExp -> R (List String)
gunlines :: RefSrcPos -> RefExp -> R (Fun (List String) String)
gunwords :: RefSrcPos -> RefExp -> R (Fun (List String) String)
aunwords :: RefAtom
hunwords :: R (List String) -> RefExp -> R String
greverse :: RefSrcPos -> RefExp -> R (Fun (List a) (List a))
gand :: RefSrcPos -> RefExp -> R (Fun (List Bool) Bool)
gor :: RefSrcPos -> RefExp -> R (Fun (List Bool) Bool)
gany :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) Bool))
aany :: RefAtom
hany :: R (Fun a Bool) -> RefExp -> R (Fun (List a) Bool)
gall :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) Bool))
aall :: RefAtom
hall :: R (Fun a Bool) -> RefExp -> R (Fun (List a) Bool)
gelem :: Eq a => RefSrcPos -> RefExp -> R (Fun a (Fun (List a) Bool))
aelem :: RefAtom
helem :: Eq a => R a -> RefExp -> R (Fun (List a) Bool)
gnotElem :: Eq a => RefSrcPos -> RefExp -> R (Fun a (Fun (List a) Bool))
anotElem :: RefAtom
hnotElem :: Eq a => R a -> RefExp -> R (Fun (List a) Bool)
glookup :: Eq a => RefSrcPos -> RefExp -> R (Fun a (Fun (List (Tuple2 a b)) (Maybe b)))
alookup :: RefAtom
hlookup :: Eq a => R a -> R (List (Tuple2 a b)) -> RefExp -> R (Maybe b)
gsum :: Num a => RefSrcPos -> RefExp -> R (Fun (List a) a)
gproduct :: Num a => RefSrcPos -> RefExp -> R (Fun (List a) a)
gmaximum :: Ord a => RefSrcPos -> RefExp -> R (Fun (List a) a)
amaximum :: RefAtom
hmaximum :: Ord a => R (List a) -> RefExp -> R a
gminimum :: Ord a => RefSrcPos -> RefExp -> R (Fun (List a) a)
aminimum :: RefAtom
hminimum :: Ord a => R (List a) -> RefExp -> R a
gconcatMap :: RefSrcPos -> RefExp -> R (Fun (Fun a (List b)) (Fun (List a) (List b)))
aconcatMap :: RefAtom
hconcatMap :: R (Fun a (List b)) -> RefExp -> R (Fun (List a) (List b))
gzip :: RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List b) (List (Tuple2 a b))))
gzip3 :: RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List b) (Fun (List c) (List (Tuple3 a b c)))))
gzipWith :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b c)) (Fun (List a) (Fun (List b) (List c))))
azipWith :: RefAtom
hzipWith :: R (Fun a (Fun b c)) -> R (List a) -> R (List b) -> RefExp -> R (List c)
gzipWith3 :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b (Fun c d))) (Fun (List a) (Fun (List b) (Fun (List c) (List d)))))
azipWith3 :: RefAtom
hzipWith3 :: R (Fun a (Fun b (Fun c d))) -> R (List a) -> R (List b) -> R (List c) -> RefExp -> R (List d)
gunzip :: RefSrcPos -> RefExp -> R (Fun (List (Tuple2 a b)) (Tuple2 (List a) (List b)))
gunzip3 :: RefSrcPos -> RefExp -> R (Fun (List (Tuple3 a b c)) (Tuple3 (List a) (List b) (List c)))

module Hat.Locale
data TimeLocale
TimeLocale :: R (List (Tuple2 String String)) -> R (List (Tuple2 String String)) -> R (Tuple2 String String) -> R String -> R String -> R String -> R String -> TimeLocale
bwDays :: TimeLocale -> R (List (Tuple2 String String))
bmonths :: TimeLocale -> R (List (Tuple2 String String))
bamPm :: TimeLocale -> R (Tuple2 String String)
bdateTimeFmt :: TimeLocale -> R String
bdateFmt :: TimeLocale -> R String
btimeFmt :: TimeLocale -> R String
btime12Fmt :: TimeLocale -> R String
gwDays :: RefSrcPos -> RefExp -> R (Fun TimeLocale (List (Tuple2 String String)))
gmonths :: RefSrcPos -> RefExp -> R (Fun TimeLocale (List (Tuple2 String String)))
gamPm :: RefSrcPos -> RefExp -> R (Fun TimeLocale (Tuple2 String String))
gdateTimeFmt :: RefSrcPos -> RefExp -> R (Fun TimeLocale String)
gdateFmt :: RefSrcPos -> RefExp -> R (Fun TimeLocale String)
gtimeFmt :: RefSrcPos -> RefExp -> R (Fun TimeLocale String)
gtime12Fmt :: RefSrcPos -> RefExp -> R (Fun TimeLocale String)
hwDays :: R TimeLocale -> RefExp -> R (List (Tuple2 String String))
hmonths :: R TimeLocale -> RefExp -> R (List (Tuple2 String String))
hamPm :: R TimeLocale -> RefExp -> R (Tuple2 String String)
hdateTimeFmt :: R TimeLocale -> RefExp -> R String
hdateFmt :: R TimeLocale -> RefExp -> R String
htimeFmt :: R TimeLocale -> RefExp -> R String
htime12Fmt :: R TimeLocale -> RefExp -> R String
awDays :: RefAtom
amonths :: RefAtom
aamPm :: RefAtom
adateTimeFmt :: RefAtom
adateFmt :: RefAtom
atimeFmt :: RefAtom
atime12Fmt :: RefAtom
aTimeLocale :: RefAtom
gdefaultTimeLocale :: RefSrcPos -> RefExp -> R TimeLocale
instance Show TimeLocale
instance Ord TimeLocale
instance Eq TimeLocale
instance WrapVal TimeLocale

module Hat.Monad
class Monad m => MonadPlus m where smzero = gundefined mkNoSrcPos p smplus = gundefined mkNoSrcPos p
gmzero :: MonadPlus m => RefSrcPos -> RefExp -> R (m a)
smzero :: MonadPlus m => R (m a)
gmplus :: MonadPlus m => RefSrcPos -> RefExp -> R (Fun (m a) (Fun (m a) (m a)))
smplus :: MonadPlus m => R (Fun (m a) (Fun (m a) (m a)))
gjoin :: Monad m => RefSrcPos -> RefExp -> R (Fun (m (m a)) (m a))
ajoin :: RefAtom
hjoin :: Monad m => R (m (m a)) -> RefExp -> R (m a)
gguard :: MonadPlus m => RefSrcPos -> RefExp -> R (Fun Bool (m Tuple0))
aguard :: RefAtom
hguard :: MonadPlus m => R Bool -> RefExp -> R (m Tuple0)
gwhen :: Monad m => RefSrcPos -> RefExp -> R (Fun Bool (Fun (m Tuple0) (m Tuple0)))
awhen :: RefAtom
hwhen :: Monad m => R Bool -> R (m Tuple0) -> RefExp -> R (m Tuple0)
gunless :: Monad m => RefSrcPos -> RefExp -> R (Fun Bool (Fun (m Tuple0) (m Tuple0)))
aunless :: RefAtom
hunless :: Monad m => R Bool -> R (m Tuple0) -> RefExp -> R (m Tuple0)
gap :: Monad m => RefSrcPos -> RefExp -> R (Fun (m (Fun a b)) (Fun (m a) (m b)))
gmsum :: MonadPlus m => RefSrcPos -> RefExp -> R (Fun (List (m a)) (m a))
amsum :: RefAtom
hmsum :: MonadPlus m => R (List (m a)) -> RefExp -> R (m a)
gfilterM :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a (m Bool)) (Fun (List a) (m (List a))))
afilterM :: RefAtom
hfilterM :: Monad m => R (Fun a (m Bool)) -> R (List a) -> RefExp -> R (m (List a))
gmapAndUnzipM :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a (m (Tuple2 b c))) (Fun (List a) (m (Tuple2 (List b) (List c)))))
amapAndUnzipM :: RefAtom
hmapAndUnzipM :: Monad m => R (Fun a (m (Tuple2 b c))) -> R (List a) -> RefExp -> R (m (Tuple2 (List b) (List c)))
gzipWithM :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b (m c))) (Fun (List a) (Fun (List b) (m (List c)))))
azipWithM :: RefAtom
hzipWithM :: Monad m => R (Fun a (Fun b (m c))) -> R (List a) -> R (List b) -> RefExp -> R (m (List c))
gzipWithM_ :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b (m c))) (Fun (List a) (Fun (List b) (m Tuple0))))
azipWithM_ :: RefAtom
hzipWithM_ :: Monad m => R (Fun a (Fun b (m c))) -> R (List a) -> R (List b) -> RefExp -> R (m Tuple0)
gfoldM :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b (m a))) (Fun a (Fun (List b) (m a))))
afoldM :: RefAtom
hfoldM :: Monad m => R (Fun a (Fun b (m a))) -> R a -> R (List b) -> RefExp -> R (m a)
gliftM :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a b) (Fun (m a) (m b)))
aliftM :: RefAtom
hliftM :: Monad m => R (Fun a b) -> RefExp -> R (Fun (m a) (m b))
gliftM2 :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b c)) (Fun (m a) (Fun (m b) (m c))))
aliftM2 :: RefAtom
hliftM2 :: Monad m => R (Fun a (Fun b c)) -> RefExp -> R (Fun (m a) (Fun (m b) (m c)))
gliftM3 :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b (Fun c d))) (Fun (m a) (Fun (m b) (Fun (m c) (m d)))))
aliftM3 :: RefAtom
hliftM3 :: Monad m => R (Fun a (Fun b (Fun c d))) -> RefExp -> R (Fun (m a) (Fun (m b) (Fun (m c) (m d))))
gliftM4 :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b (Fun c (Fun d e)))) (Fun (m a) (Fun (m b) (Fun (m c) (Fun (m d) (m e))))))
aliftM4 :: RefAtom
hliftM4 :: Monad m => R (Fun a (Fun b (Fun c (Fun d e)))) -> RefExp -> R (Fun (m a) (Fun (m b) (Fun (m c) (Fun (m d) (m e)))))
gliftM5 :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b (Fun c (Fun d (Fun e f))))) (Fun (m a) (Fun (m b) (Fun (m c) (Fun (m d) (Fun (m e) (m f)))))))
aliftM5 :: RefAtom
hliftM5 :: Monad m => R (Fun a (Fun b (Fun c (Fun d (Fun e f))))) -> RefExp -> R (Fun (m a) (Fun (m b) (Fun (m c) (Fun (m d) (Fun (m e) (m f))))))
class Monad m where (|>>=) = gundefined mkNoSrcPos p sreturn = gundefined mkNoSrcPos p (%>>) !>> p = ufun2 (+%$^=*=%$^=$@>>) (%>>) p (*>>) where (fm *>> fk) p = uap2 mkNoSrcPos p ((!>>=) mkNoSrcPos p) fm (ufun1 mkLambda mkNoSrcPos p (\ _ p -> projection mkNoSrcPos p fk)) gfail pfail p = ufun1 c328v5v328v21fail pfail p hfail where hfail fs p = uwrapForward p (herror fs p)
(!>>=) :: Monad m => RefSrcPos -> RefExp -> R (Fun (m a) (Fun (Fun a (m b)) (m b)))
(|>>=) :: Monad m => R (Fun (m a) (Fun (Fun a (m b)) (m b)))
(!>>) :: Monad m => RefSrcPos -> RefExp -> R (Fun (m a) (Fun (m b) (m b)))
(|>>) :: Monad m => R (Fun (m a) (Fun (m b) (m b)))
greturn :: Monad m => RefSrcPos -> RefExp -> R (Fun a (m a))
sreturn :: Monad m => R (Fun a (m a))
gfail :: Monad m => RefSrcPos -> RefExp -> R (Fun String (m a))
sfail :: Monad m => R (Fun String (m a))
class Functor f where sfmap = gundefined mkNoSrcPos p
gfmap :: Functor f => RefSrcPos -> RefExp -> R (Fun (Fun a b) (Fun (f a) (f b)))
sfmap :: Functor f => R (Fun (Fun a b) (Fun (f a) (f b)))
gmapM :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a (m b)) (Fun (List a) (m (List b))))
amapM :: RefAtom
hmapM :: Monad m => R (Fun a (m b)) -> R (List a) -> RefExp -> R (m (List b))
gmapM_ :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a (m b)) (Fun (List a) (m Tuple0)))
amapM_ :: RefAtom
hmapM_ :: Monad m => R (Fun a (m b)) -> R (List a) -> RefExp -> R (m Tuple0)
gsequence :: Monad m => RefSrcPos -> RefExp -> R (Fun (List (m a)) (m (List a)))
gsequence_ :: Monad m => RefSrcPos -> RefExp -> R (Fun (List (m a)) (m Tuple0))
(!=<<) :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a (m b)) (Fun (m a) (m b)))
(+=<<) :: RefAtom
(*=<<) :: Monad m => R (Fun a (m b)) -> R (m a) -> RefExp -> R (m b)
instance MonadPlus List
instance MonadPlus Maybe

module Hat.Numeric
gfromRat :: RealFloat a => RefSrcPos -> RefExp -> R (Fun Rational a)
afromRat :: RefAtom
hfromRat :: RealFloat a => R Rational -> RefExp -> R a
gshowSigned :: Real a => RefSrcPos -> RefExp -> R (Fun (Fun a ShowS) (Fun Int (Fun a ShowS)))
ashowSigned :: RefAtom
hshowSigned :: Real a => R (Fun a ShowS) -> R Int -> R a -> RefExp -> R ShowS
gshowIntAtBase :: Integral a => RefSrcPos -> RefExp -> R (Fun a (Fun (Fun Int Char) (Fun a ShowS)))
ashowIntAtBase :: RefAtom
hshowIntAtBase :: Integral a => R a -> R (Fun Int Char) -> R a -> R ShowS___1 -> RefExp -> R ShowS___2
gshowInt :: Integral a => RefSrcPos -> RefExp -> R (Fun a ShowS)
gshowOct :: Integral a => RefSrcPos -> RefExp -> R (Fun a ShowS)
gshowHex :: Integral a => RefSrcPos -> RefExp -> R (Fun a ShowS)
greadSigned :: Real a => RefSrcPos -> RefExp -> R (Fun (ReadS a) (ReadS a))
areadSigned :: RefAtom
hreadSigned :: Real a => R (ReadS a) -> RefExp -> R (ReadS a)
greadInt :: Integral a => RefSrcPos -> RefExp -> R (Fun a (Fun (Fun Char Bool) (Fun (Fun Char Int) (ReadS a))))
areadInt :: RefAtom
hreadInt :: Integral a => R a -> R (Fun Char Bool) -> R (Fun Char Int) -> R (ReadS___1 a) -> RefExp -> R (ReadS___2 a)
greadDec :: Integral a => RefSrcPos -> RefExp -> R (ReadS a)
greadOct :: Integral a => RefSrcPos -> RefExp -> R (ReadS a)
greadHex :: Integral a => RefSrcPos -> RefExp -> R (ReadS a)
gfloatToDigits :: RealFloat a => RefSrcPos -> RefExp -> R (Fun Integer (Fun a (Tuple2 (List Int) Int)))
afloatToDigits :: RefAtom
hfloatToDigits :: RealFloat a => R Integer -> R a -> RefExp -> R (Tuple2 (List Int) Int)
gshowEFloat :: RealFloat a => RefSrcPos -> RefExp -> R (Fun (Maybe Int) (Fun a ShowS))
ashowEFloat :: RefAtom
hshowEFloat :: RealFloat a => R (Maybe Int) -> R a -> RefExp -> R ShowS
gshowFFloat :: RealFloat a => RefSrcPos -> RefExp -> R (Fun (Maybe Int) (Fun a ShowS))
ashowFFloat :: RefAtom
hshowFFloat :: RealFloat a => R (Maybe Int) -> R a -> RefExp -> R ShowS
gshowGFloat :: RealFloat a => RefSrcPos -> RefExp -> R (Fun (Maybe Int) (Fun a ShowS))
ashowGFloat :: RefAtom
hshowGFloat :: RealFloat a => R (Maybe Int) -> R a -> RefExp -> R ShowS
gshowFloat :: RealFloat a => RefSrcPos -> RefExp -> R (Fun a ShowS)
greadFloat :: RealFloat a => RefSrcPos -> RefExp -> R (ReadS a)
areadFloat :: RefAtom
hreadFloat :: RealFloat a => R (ReadS___1 a) -> RefExp -> R (ReadS___2 a)
glexDigits :: RefSrcPos -> RefExp -> R (ReadS String)

module Hat.Random
class RandomGen g where snext = gundefined mkNoSrcPos p ssplit = gundefined mkNoSrcPos p ggenRange pgenRange p = ufun1 c24v3v24v34genRange pgenRange p hgenRange where hgenRange fg p = con2 mkNoSrcPos p Tuple2 aTuple2 (gminBound mkNoSrcPos p) (gmaxBound mkNoSrcPos p)
ggenRange :: RandomGen g => RefSrcPos -> RefExp -> R (Fun g (Tuple2 Int Int))
sgenRange :: RandomGen g => R (Fun g (Tuple2 Int Int))
gnext :: RandomGen g => RefSrcPos -> RefExp -> R (Fun g (Tuple2 Int g))
snext :: RandomGen g => R (Fun g (Tuple2 Int g))
gsplit :: RandomGen g => RefSrcPos -> RefExp -> R (Fun g (Tuple2 g g))
ssplit :: RandomGen g => R (Fun g (Tuple2 g g))

-- | The <a>StdGen</a> instance of <a>RandomGen</a> has a <a>genRange</a>
--   of at least 30 bits.
--   
--   The result of repeatedly using <a>next</a> should be at least as
--   statistically robust as the <i>Minimal Standard Random Number
--   Generator</i> described by [<a>System.Random\#Park</a>,
--   <a>System.Random\#Carta</a>]. Until more is known about
--   implementations of <a>split</a>, all we require is that <a>split</a>
--   deliver generators that are (a) not identical and (b) independently
--   robust in the sense just given.
--   
--   The <a>Show</a> and <a>Read</a> instances of <a>StdGen</a> provide a
--   primitive way to save the state of a random number generator. It is
--   required that <tt><a>read</a> (<a>show</a> g) == g</tt>.
--   
--   In addition, <a>reads</a> may be used to map an arbitrary string (not
--   necessarily one produced by <a>show</a>) onto a value of type
--   <a>StdGen</a>. In general, the <a>Read</a> instance of <a>StdGen</a>
--   has the following properties:
--   
--   <ul>
--   <li>It guarantees to succeed on any string.</li>
--   <li>It guarantees to consume only a finite portion of the string.</li>
--   <li>Different argument strings are likely to result in different
--   results.</li>
--   </ul>
data StdGen :: *
gmkStdGen :: RefSrcPos -> RefExp -> R (Fun Int StdGen)
amkStdGen :: RefAtom
hmkStdGen :: R Int -> RefExp -> R StdGen
class Random a where srandomR = gundefined mkNoSrcPos p srandom = gundefined mkNoSrcPos p grandoms prandoms p = ufun1 c68v3v69v9randoms prandoms p hrandoms where hrandoms fg p = con2 mkNoSrcPos p Cons aCons (gx mkNoSrcPos p) (uap1 mkNoSrcPos p (grandoms mkNoSrcPos p) (gg' mkNoSrcPos p)) where gx px p = uconstUse px p sx gg' pg' p = uconstUse pg' p sg' sx = uconstDef p c70v5v70v21x (\ _ -> case j70v5v70v21x of { (kx, fx, fg') -> fx }) sg' = uconstDef p c70v5v70v21g' (\ _ -> case j70v5v70v21x of { (kx, fx, fg') -> fg' }) j70v5v70v21x = case uap1 mkNoSrcPos p (grandom mkNoSrcPos p) fg of { R (Tuple2 fx fg') kx -> (kx, fx, fg') _ -> fatal p } grandomRs prandomRs p = ufun2 c71v3v72v9randomRs prandomRs p hrandomRs where hrandomRs frange fg p = con2 mkNoSrcPos p Cons aCons (gx mkNoSrcPos p) (uap2 mkNoSrcPos p (grandomRs mkNoSrcPos p) frange (gg' mkNoSrcPos p)) where gx px p = uconstUse px p sx gg' pg' p = uconstUse pg' p sg' sx = uconstDef p c73v5v73v28x (\ _ -> case j73v5v73v28x of { (kx, fx, fg') -> fx }) sg' = uconstDef p c73v5v73v28g' (\ _ -> case j73v5v73v28x of { (kx, fx, fg') -> fg' }) j73v5v73v28x = case uap2 mkNoSrcPos p (grandomR mkNoSrcPos p) frange fg of { R (Tuple2 fx fg') kx -> (kx, fx, fg') _ -> fatal p } grandomIO prandomIO p = uconstUse prandomIO p srandomIO srandomIO = uconstDef p c74v3v74v39randomIO (\ p -> uwrapForward p (hgetStdRandom (grandom mkNoSrcPos p) p)) grandomRIO prandomRIO p = ufun1 c75v3v75v48randomRIO prandomRIO p hrandomRIO where hrandomRIO frange p = uwrapForward p (hgetStdRandom (uap1 mkNoSrcPos p (grandomR mkNoSrcPos p) frange) p)
grandomR :: (Random a, RandomGen g) => RefSrcPos -> RefExp -> R (Fun (Tuple2 a a) (Fun g (Tuple2 a g)))
srandomR :: (Random a, RandomGen g) => R (Fun (Tuple2 a a) (Fun g (Tuple2 a g)))
grandom :: (Random a, RandomGen g) => RefSrcPos -> RefExp -> R (Fun g (Tuple2 a g))
srandom :: (Random a, RandomGen g) => R (Fun g (Tuple2 a g))
grandomRs :: (Random a, RandomGen g) => RefSrcPos -> RefExp -> R (Fun (Tuple2 a a) (Fun g (List a)))
srandomRs :: (Random a, RandomGen g) => R (Fun (Tuple2 a a) (Fun g (List a)))
grandoms :: (Random a, RandomGen g) => RefSrcPos -> RefExp -> R (Fun g (List a))
srandoms :: (Random a, RandomGen g) => R (Fun g (List a))
grandomRIO :: Random a => RefSrcPos -> RefExp -> R (Fun (Tuple2 a a) (IO a))
srandomRIO :: Random a => R (Fun (Tuple2 a a) (IO a))
grandomIO :: Random a => RefSrcPos -> RefExp -> R (IO a)
srandomIO :: Random a => R (IO a)
ggetStdRandom :: RefSrcPos -> RefExp -> R (Fun (Fun StdGen (Tuple2 a StdGen)) (IO a))
agetStdRandom :: RefAtom
hgetStdRandom :: R (Fun StdGen (Tuple2 b StdGen)) -> RefExp -> R (IO b)
ggetStdGen :: RefSrcPos -> RefExp -> R (IO StdGen)
gsetStdGen :: RefSrcPos -> RefExp -> R (Fun StdGen (IO Tuple0))
asetStdGen :: RefAtom
hsetStdGen :: R StdGen -> RefExp -> R (IO Tuple0)
gnewStdGen :: RefSrcPos -> RefExp -> R (IO StdGen)
instance Random Char
instance Random Bool
instance Random Double
instance Random Float
instance Random Integer
instance Random Int
instance Show StdGen
instance Read StdGen
instance RandomGen StdGen

module Hat.Ratio
data Ratio a
type Rational = Ratio Integer
(!%) :: Integral a => RefSrcPos -> RefExp -> R (Fun a (Fun a (Ratio a)))
(+%) :: RefAtom
(*%) :: Integral a => R a -> R a -> RefExp -> R (Ratio a)
gnumerator :: Integral a => RefSrcPos -> RefExp -> R (Fun (Ratio a) a)
anumerator :: RefAtom
hnumerator :: Integral a => R (Ratio a) -> RefExp -> R a
gdenominator :: Integral a => RefSrcPos -> RefExp -> R (Fun (Ratio a) a)
adenominator :: RefAtom
hdenominator :: Integral a => R (Ratio a) -> RefExp -> R a
gapproxRational :: RealFrac a => RefSrcPos -> RefExp -> R (Fun a (Fun a Rational))
aapproxRational :: RefAtom
happroxRational :: RealFrac a => R a -> R a -> RefExp -> R Rational

module Hat.System
data ExitCode
ExitSuccess :: ExitCode
ExitFailure :: (R Int) -> ExitCode
aExitSuccess :: RefAtom
aExitFailure :: RefAtom
ggetArgs :: RefSrcPos -> RefExp -> R (IO (List String))
ggetProgName :: RefSrcPos -> RefExp -> R (IO String)
ggetEnv :: RefSrcPos -> RefExp -> R (Fun String (IO String))
agetEnv :: RefAtom
hgetEnv :: R String -> RefExp -> R (IO String)
gsystem :: RefSrcPos -> RefExp -> R (Fun String (IO ExitCode))
asystem :: RefAtom
hsystem :: R String -> RefExp -> R (IO ExitCode)
gexitWith :: RefSrcPos -> RefExp -> R (Fun ExitCode (IO a))
aexitWith :: RefAtom
hexitWith :: R ExitCode -> RefExp -> R (IO b)
gexitFailure :: RefSrcPos -> RefExp -> R (IO a)

module Hat.Control.Monad
class Functor f where sfmap = gundefined mkNoSrcPos p
gfmap :: Functor f => RefSrcPos -> RefExp -> R (Fun (Fun a b) (Fun (f a) (f b)))
sfmap :: Functor f => R (Fun (Fun a b) (Fun (f a) (f b)))
class Monad m where (|>>=) = gundefined mkNoSrcPos p sreturn = gundefined mkNoSrcPos p (%>>) !>> p = ufun2 (+%$^=*=%$^=$@>>) (%>>) p (*>>) where (fm *>> fk) p = uap2 mkNoSrcPos p ((!>>=) mkNoSrcPos p) fm (ufun1 mkLambda mkNoSrcPos p (\ _ p -> projection mkNoSrcPos p fk)) gfail pfail p = ufun1 c328v5v328v21fail pfail p hfail where hfail fs p = uwrapForward p (herror fs p)
(!>>=) :: Monad m => RefSrcPos -> RefExp -> R (Fun (m a) (Fun (Fun a (m b)) (m b)))
(|>>=) :: Monad m => R (Fun (m a) (Fun (Fun a (m b)) (m b)))
(!>>) :: Monad m => RefSrcPos -> RefExp -> R (Fun (m a) (Fun (m b) (m b)))
(|>>) :: Monad m => R (Fun (m a) (Fun (m b) (m b)))
greturn :: Monad m => RefSrcPos -> RefExp -> R (Fun a (m a))
sreturn :: Monad m => R (Fun a (m a))
gfail :: Monad m => RefSrcPos -> RefExp -> R (Fun String (m a))
sfail :: Monad m => R (Fun String (m a))
class Monad m => MonadPlus m where smzero = gundefined mkNoSrcPos p smplus = gundefined mkNoSrcPos p
gmzero :: MonadPlus m => RefSrcPos -> RefExp -> R (m a)
smzero :: MonadPlus m => R (m a)
gmplus :: MonadPlus m => RefSrcPos -> RefExp -> R (Fun (m a) (Fun (m a) (m a)))
smplus :: MonadPlus m => R (Fun (m a) (Fun (m a) (m a)))
gmapM :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a (m b)) (Fun (List a) (m (List b))))
amapM :: RefAtom
hmapM :: Monad m => R (Fun a (m b)) -> R (List a) -> RefExp -> R (m (List b))
gmapM_ :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a (m b)) (Fun (List a) (m Tuple0)))
amapM_ :: RefAtom
hmapM_ :: Monad m => R (Fun a (m b)) -> R (List a) -> RefExp -> R (m Tuple0)
gforM :: Monad m => RefSrcPos -> RefExp -> R (Fun (List a) (Fun (Fun a (m b)) (m (List b))))
gforM_ :: Monad m => RefSrcPos -> RefExp -> R (Fun (List a) (Fun (Fun a (m b)) (m Tuple0)))
gsequence :: Monad m => RefSrcPos -> RefExp -> R (Fun (List (m a)) (m (List a)))
gsequence_ :: Monad m => RefSrcPos -> RefExp -> R (Fun (List (m a)) (m Tuple0))
(!=<<) :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a (m b)) (Fun (m a) (m b)))
(+=<<) :: RefAtom
(*=<<) :: Monad m => R (Fun a (m b)) -> R (m a) -> RefExp -> R (m b)
(!>=>) :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a (m b)) (Fun (Fun b (m c)) (Fun a (m c))))
(+>=>) :: RefAtom
(*>=>) :: Monad m => R (Fun a (m b)) -> R (Fun b (m c)) -> RefExp -> R (Fun a (m c))
(!<=<) :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun b (m c)) (Fun (Fun a (m b)) (Fun a (m c))))
gforever :: Monad m => RefSrcPos -> RefExp -> R (Fun (m a) (m b))
aforever :: RefAtom
hforever :: Monad m => R (m a) -> RefExp -> R (m b)
gvoid :: Functor f => RefSrcPos -> RefExp -> R (Fun (f a) (f Tuple0))
gjoin :: Monad m => RefSrcPos -> RefExp -> R (Fun (m (m a)) (m a))
ajoin :: RefAtom
hjoin :: Monad m => R (m (m a)) -> RefExp -> R (m a)
gmsum :: MonadPlus m => RefSrcPos -> RefExp -> R (Fun (List (m a)) (m a))
amsum :: RefAtom
hmsum :: MonadPlus m => R (List (m a)) -> RefExp -> R (m a)
gfilterM :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a (m Bool)) (Fun (List a) (m (List a))))
afilterM :: RefAtom
hfilterM :: Monad m => R (Fun a (m Bool)) -> R (List a) -> RefExp -> R (m (List a))
gmapAndUnzipM :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a (m (Tuple2 b c))) (Fun (List a) (m (Tuple2 (List b) (List c)))))
amapAndUnzipM :: RefAtom
hmapAndUnzipM :: Monad m => R (Fun a (m (Tuple2 b c))) -> R (List a) -> RefExp -> R (m (Tuple2 (List b) (List c)))
gzipWithM :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b (m c))) (Fun (List a) (Fun (List b) (m (List c)))))
azipWithM :: RefAtom
hzipWithM :: Monad m => R (Fun a (Fun b (m c))) -> R (List a) -> R (List b) -> RefExp -> R (m (List c))
gzipWithM_ :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b (m c))) (Fun (List a) (Fun (List b) (m Tuple0))))
azipWithM_ :: RefAtom
hzipWithM_ :: Monad m => R (Fun a (Fun b (m c))) -> R (List a) -> R (List b) -> RefExp -> R (m Tuple0)
gfoldM :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b (m a))) (Fun a (Fun (List b) (m a))))
afoldM :: RefAtom
hfoldM :: Monad m => R (Fun a (Fun b (m a))) -> R a -> R (List b) -> RefExp -> R (m a)
gfoldM_ :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b (m a))) (Fun a (Fun (List b) (m Tuple0))))
afoldM_ :: RefAtom
hfoldM_ :: Monad m => R (Fun a (Fun b (m a))) -> R a -> R (List b) -> RefExp -> R (m Tuple0)
greplicateM :: Monad m => RefSrcPos -> RefExp -> R (Fun Int (Fun (m a) (m (List a))))
areplicateM :: RefAtom
hreplicateM :: Monad m => R Int -> R (m a) -> RefExp -> R (m (List a))
greplicateM_ :: Monad m => RefSrcPos -> RefExp -> R (Fun Int (Fun (m a) (m Tuple0)))
areplicateM_ :: RefAtom
hreplicateM_ :: Monad m => R Int -> R (m a) -> RefExp -> R (m Tuple0)
gguard :: MonadPlus m => RefSrcPos -> RefExp -> R (Fun Bool (m Tuple0))
aguard :: RefAtom
hguard :: MonadPlus m => R Bool -> RefExp -> R (m Tuple0)
gwhen :: Monad m => RefSrcPos -> RefExp -> R (Fun Bool (Fun (m Tuple0) (m Tuple0)))
awhen :: RefAtom
hwhen :: Monad m => R Bool -> R (m Tuple0) -> RefExp -> R (m Tuple0)
gunless :: Monad m => RefSrcPos -> RefExp -> R (Fun Bool (Fun (m Tuple0) (m Tuple0)))
aunless :: RefAtom
hunless :: Monad m => R Bool -> R (m Tuple0) -> RefExp -> R (m Tuple0)
gliftM :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a b) (Fun (m a) (m b)))
aliftM :: RefAtom
hliftM :: Monad m => R (Fun a b) -> RefExp -> R (Fun (m a) (m b))
gliftM2 :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b c)) (Fun (m a) (Fun (m b) (m c))))
aliftM2 :: RefAtom
hliftM2 :: Monad m => R (Fun a (Fun b c)) -> RefExp -> R (Fun (m a) (Fun (m b) (m c)))
gliftM3 :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b (Fun c d))) (Fun (m a) (Fun (m b) (Fun (m c) (m d)))))
aliftM3 :: RefAtom
hliftM3 :: Monad m => R (Fun a (Fun b (Fun c d))) -> RefExp -> R (Fun (m a) (Fun (m b) (Fun (m c) (m d))))
gliftM4 :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b (Fun c (Fun d e)))) (Fun (m a) (Fun (m b) (Fun (m c) (Fun (m d) (m e))))))
aliftM4 :: RefAtom
hliftM4 :: Monad m => R (Fun a (Fun b (Fun c (Fun d e)))) -> RefExp -> R (Fun (m a) (Fun (m b) (Fun (m c) (Fun (m d) (m e)))))
gliftM5 :: Monad m => RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b (Fun c (Fun d (Fun e f))))) (Fun (m a) (Fun (m b) (Fun (m c) (Fun (m d) (Fun (m e) (m f)))))))
aliftM5 :: RefAtom
hliftM5 :: Monad m => R (Fun a (Fun b (Fun c (Fun d (Fun e f))))) -> RefExp -> R (Fun (m a) (Fun (m b) (Fun (m c) (Fun (m d) (Fun (m e) (m f))))))
gap :: Monad m => RefSrcPos -> RefExp -> R (Fun (m (Fun a b)) (Fun (m a) (m b)))

module Hat.Data.Maybe
data Maybe a
Nothing :: Maybe a
Just :: (R a) -> Maybe a
aNothing :: RefAtom
aJust :: RefAtom
gmaybe :: RefSrcPos -> RefExp -> R (Fun b (Fun (Fun a b) (Fun (Maybe a) b)))
amaybe :: RefAtom
hmaybe :: R b -> R (Fun a b) -> R (Maybe a) -> RefExp -> R b
gisJust :: RefSrcPos -> RefExp -> R (Fun (Maybe a) Bool)
aisJust :: RefAtom
hisJust :: R (Maybe a) -> RefExp -> R Bool
gisNothing :: RefSrcPos -> RefExp -> R (Fun (Maybe a) Bool)
gfromJust :: RefSrcPos -> RefExp -> R (Fun (Maybe a) a)
afromJust :: RefAtom
hfromJust :: R (Maybe a) -> RefExp -> R a
gfromMaybe :: RefSrcPos -> RefExp -> R (Fun a (Fun (Maybe a) a))
afromMaybe :: RefAtom
hfromMaybe :: R a -> R (Maybe a) -> RefExp -> R a
glistToMaybe :: RefSrcPos -> RefExp -> R (Fun (List a) (Maybe a))
alistToMaybe :: RefAtom
hlistToMaybe :: R (List a) -> RefExp -> R (Maybe a)
gmaybeToList :: RefSrcPos -> RefExp -> R (Fun (Maybe a) (List a))
amaybeToList :: RefAtom
hmaybeToList :: R (Maybe a) -> RefExp -> R (List a)
gcatMaybes :: RefSrcPos -> RefExp -> R (Fun (List (Maybe a)) (List a))
acatMaybes :: RefAtom
hcatMaybes :: R (List (Maybe a)) -> RefExp -> R (List a)
gmapMaybe :: RefSrcPos -> RefExp -> R (Fun (Fun a (Maybe b)) (Fun (List a) (List b)))
amapMaybe :: RefAtom
hmapMaybe :: R (Fun a (Maybe b)) -> RefExp -> R (Fun (List a) (List b))

module Hat.Data.List
(!++) :: RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List a) (List a)))
(+++) :: RefAtom
(*++) :: R (List a) -> R (List a) -> RefExp -> R (List a)
ghead :: RefSrcPos -> RefExp -> R (Fun (List a) a)
ahead :: RefAtom
hhead :: R (List a) -> RefExp -> R a
glast :: RefSrcPos -> RefExp -> R (Fun (List a) a)
alast :: RefAtom
hlast :: R (List a) -> RefExp -> R a
gtail :: RefSrcPos -> RefExp -> R (Fun (List a) (List a))
atail :: RefAtom
htail :: R (List a) -> RefExp -> R (List a)
ginit :: RefSrcPos -> RefExp -> R (Fun (List a) (List a))
ainit :: RefAtom
hinit :: R (List a) -> RefExp -> R (List a)
gnull :: RefSrcPos -> RefExp -> R (Fun (List a) Bool)
anull :: RefAtom
hnull :: R (List a) -> RefExp -> R Bool
glength :: RefSrcPos -> RefExp -> R (Fun (List a) Int)
alength :: RefAtom
hlength :: R (List a) -> RefExp -> R Int
gmap :: RefSrcPos -> RefExp -> R (Fun (Fun a b) (Fun (List a) (List b)))
amap :: RefAtom
hmap :: R (Fun a b) -> R (List a) -> RefExp -> R (List b)
greverse :: RefSrcPos -> RefExp -> R (Fun (List a) (List a))
gintersperse :: RefSrcPos -> RefExp -> R (Fun a (Fun (List a) (List a)))
aintersperse :: RefAtom
hintersperse :: R a -> R (List a) -> RefExp -> R (List a)
gintercalate :: RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List (List a)) (List a)))
aintercalate :: RefAtom
hintercalate :: R (List a) -> R (List (List a)) -> RefExp -> R (List a)
gtranspose :: RefSrcPos -> RefExp -> R (Fun (List (List a)) (List (List a)))
atranspose :: RefAtom
htranspose :: R (List (List a)) -> RefExp -> R (List (List a))
gsubsequences :: RefSrcPos -> RefExp -> R (Fun (List a) (List (List a)))
asubsequences :: RefAtom
hsubsequences :: R (List a) -> RefExp -> R (List (List a))
gpermutations :: RefSrcPos -> RefExp -> R (Fun (List a) (List (List a)))
apermutations :: RefAtom
hpermutations :: R (List a) -> RefExp -> R (List (List a))
gfoldl :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b a)) (Fun a (Fun (List b) a)))
afoldl :: RefAtom
hfoldl :: R (Fun a (Fun b a)) -> R a -> R (List b) -> RefExp -> R a
gfoldl' :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b a)) (Fun a (Fun (List b) a)))
afoldl' :: RefAtom
hfoldl' :: R (Fun a (Fun b a)) -> R a -> R (List b) -> RefExp -> R a
gfoldl1 :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a a)) (Fun (List a) a))
afoldl1 :: RefAtom
hfoldl1 :: R (Fun a (Fun a a)) -> R (List a) -> RefExp -> R a
gfoldl1' :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a a)) (Fun (List a) a))
afoldl1' :: RefAtom
hfoldl1' :: R (Fun a (Fun a a)) -> R (List a) -> RefExp -> R a
gfoldr :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b b)) (Fun b (Fun (List a) b)))
afoldr :: RefAtom
hfoldr :: R (Fun a (Fun b b)) -> R b -> R (List a) -> RefExp -> R b
gfoldr1 :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a a)) (Fun (List a) a))
afoldr1 :: RefAtom
hfoldr1 :: R (Fun a (Fun a a)) -> R (List a) -> RefExp -> R a
gconcat :: RefSrcPos -> RefExp -> R (Fun (List (List a)) (List a))
aconcat :: RefAtom
hconcat :: R (List (List a)) -> RefExp -> R (List a)
gconcatMap :: RefSrcPos -> RefExp -> R (Fun (Fun a (List b)) (Fun (List a) (List b)))
aconcatMap :: RefAtom
hconcatMap :: R (Fun a (List b)) -> RefExp -> R (Fun (List a) (List b))
gand :: RefSrcPos -> RefExp -> R (Fun (List Bool) Bool)
gor :: RefSrcPos -> RefExp -> R (Fun (List Bool) Bool)
gany :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) Bool))
aany :: RefAtom
hany :: R (Fun a Bool) -> RefExp -> R (Fun (List a) Bool)
gall :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) Bool))
aall :: RefAtom
hall :: R (Fun a Bool) -> RefExp -> R (Fun (List a) Bool)
gsum :: Num a => RefSrcPos -> RefExp -> R (Fun (List a) a)
gproduct :: Num a => RefSrcPos -> RefExp -> R (Fun (List a) a)
gmaximum :: Ord a => RefSrcPos -> RefExp -> R (Fun (List a) a)
amaximum :: RefAtom
hmaximum :: Ord a => R (List a) -> RefExp -> R a
gminimum :: Ord a => RefSrcPos -> RefExp -> R (Fun (List a) a)
aminimum :: RefAtom
hminimum :: Ord a => R (List a) -> RefExp -> R a
gscanl :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b a)) (Fun a (Fun (List b) (List a))))
ascanl :: RefAtom
hscanl :: R (Fun a (Fun b a)) -> R a -> R (List b) -> RefExp -> R (List a)
gscanl1 :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a a)) (Fun (List a) (List a)))
ascanl1 :: RefAtom
hscanl1 :: R (Fun a (Fun a a)) -> R (List a) -> RefExp -> R (List a)
gscanr :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b b)) (Fun b (Fun (List a) (List b))))
ascanr :: RefAtom
hscanr :: R (Fun a (Fun b b)) -> R b -> R (List a) -> RefExp -> R (List b)
gscanr1 :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a a)) (Fun (List a) (List a)))
ascanr1 :: RefAtom
hscanr1 :: R (Fun a (Fun a a)) -> R (List a) -> RefExp -> R (List a)
gmapAccumL :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b (Tuple2 a c))) (Fun a (Fun (List b) (Tuple2 a (List c)))))
amapAccumL :: RefAtom
hmapAccumL :: R (Fun a (Fun b (Tuple2 a c))) -> R a -> R (List b) -> RefExp -> R (Tuple2 a (List c))
gmapAccumR :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b (Tuple2 a c))) (Fun a (Fun (List b) (Tuple2 a (List c)))))
amapAccumR :: RefAtom
hmapAccumR :: R (Fun a (Fun b (Tuple2 a c))) -> R a -> R (List b) -> RefExp -> R (Tuple2 a (List c))
giterate :: RefSrcPos -> RefExp -> R (Fun (Fun a a) (Fun a (List a)))
aiterate :: RefAtom
hiterate :: R (Fun a a) -> R a -> RefExp -> R (List a)
grepeat :: RefSrcPos -> RefExp -> R (Fun a (List a))
arepeat :: RefAtom
hrepeat :: R a -> RefExp -> R (List a)
greplicate :: RefSrcPos -> RefExp -> R (Fun Int (Fun a (List a)))
areplicate :: RefAtom
hreplicate :: R Int -> R a -> RefExp -> R (List a)
gcycle :: RefSrcPos -> RefExp -> R (Fun (List a) (List a))
acycle :: RefAtom
hcycle :: R (List a) -> RefExp -> R (List a)
gunfoldr :: RefSrcPos -> RefExp -> R (Fun (Fun b (Maybe (Tuple2 a b))) (Fun b (List a)))
aunfoldr :: RefAtom
hunfoldr :: R (Fun b (Maybe (Tuple2 a b))) -> R b -> RefExp -> R (List a)
gtake :: RefSrcPos -> RefExp -> R (Fun Int (Fun (List a) (List a)))
atake :: RefAtom
htake :: R Int -> R (List a) -> RefExp -> R (List a)
gdrop :: RefSrcPos -> RefExp -> R (Fun Int (Fun (List a) (List a)))
adrop :: RefAtom
hdrop :: R Int -> R (List a) -> RefExp -> R (List a)
gsplitAt :: RefSrcPos -> RefExp -> R (Fun Int (Fun (List a) (Tuple2 (List a) (List a))))
asplitAt :: RefAtom
hsplitAt :: R Int -> R (List a) -> RefExp -> R (Tuple2 (List a) (List a))
gtakeWhile :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) (List a)))
atakeWhile :: RefAtom
htakeWhile :: R (Fun a Bool) -> R (List a) -> RefExp -> R (List a)
gdropWhile :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) (List a)))
adropWhile :: RefAtom
hdropWhile :: R (Fun a Bool) -> R (List a) -> RefExp -> R (List a)
gspan :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) (Tuple2 (List a) (List a))))
aspan :: RefAtom
hspan :: R (Fun a Bool) -> R (List a) -> RefExp -> R (Tuple2 (List a) (List a))
gbreak :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) (Tuple2 (List a) (List a))))
abreak :: RefAtom
hbreak :: R (Fun a Bool) -> RefExp -> R (Fun (List a) (Tuple2 (List a) (List a)))
gstripPrefix :: Eq a => RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List a) (Maybe (List a))))
astripPrefix :: RefAtom
hstripPrefix :: Eq a => R (List a) -> R (List a) -> RefExp -> R (Maybe (List a))
ggroup :: Eq a => RefSrcPos -> RefExp -> R (Fun (List a) (List (List a)))
ginits :: RefSrcPos -> RefExp -> R (Fun (List a) (List (List a)))
ainits :: RefAtom
hinits :: R (List a) -> RefExp -> R (List (List a))
gtails :: RefSrcPos -> RefExp -> R (Fun (List a) (List (List a)))
atails :: RefAtom
htails :: R (List a) -> RefExp -> R (List (List a))
gisPrefixOf :: Eq a => RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List a) Bool))
aisPrefixOf :: RefAtom
hisPrefixOf :: Eq a => R (List a) -> R (List a) -> RefExp -> R Bool
gisSuffixOf :: Eq a => RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List a) Bool))
aisSuffixOf :: RefAtom
hisSuffixOf :: Eq a => R (List a) -> R (List a) -> RefExp -> R Bool
gisInfixOf :: Eq a => RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List a) Bool))
aisInfixOf :: RefAtom
hisInfixOf :: Eq a => R (List a) -> R (List a) -> RefExp -> R Bool
gelem :: Eq a => RefSrcPos -> RefExp -> R (Fun a (Fun (List a) Bool))
aelem :: RefAtom
helem :: Eq a => R a -> RefExp -> R (Fun (List a) Bool)
gnotElem :: Eq a => RefSrcPos -> RefExp -> R (Fun a (Fun (List a) Bool))
anotElem :: RefAtom
hnotElem :: Eq a => R a -> RefExp -> R (Fun (List a) Bool)
glookup :: Eq a => RefSrcPos -> RefExp -> R (Fun a (Fun (List (Tuple2 a b)) (Maybe b)))
alookup :: RefAtom
hlookup :: Eq a => R a -> R (List (Tuple2 a b)) -> RefExp -> R (Maybe b)
gfind :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) (Maybe a)))
afind :: RefAtom
hfind :: R (Fun a Bool) -> RefExp -> R (Fun (List a) (Maybe a))
gfilter :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) (List a)))
afilter :: RefAtom
hfilter :: R (Fun a Bool) -> R (List a) -> RefExp -> R (List a)
gpartition :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) (Tuple2 (List a) (List a))))
apartition :: RefAtom
hpartition :: R (Fun a Bool) -> R (List a) -> RefExp -> R (Tuple2 (List a) (List a))
(!!!) :: RefSrcPos -> RefExp -> R (Fun (List a) (Fun Int a))
(+!!) :: RefAtom
(*!!) :: R (List a) -> R Int -> RefExp -> R a
gelemIndex :: Eq a => RefSrcPos -> RefExp -> R (Fun a (Fun (List a) (Maybe Int)))
aelemIndex :: RefAtom
helemIndex :: Eq a => R a -> RefExp -> R (Fun (List a) (Maybe Int))
gelemIndices :: Eq a => RefSrcPos -> RefExp -> R (Fun a (Fun (List a) (List Int)))
aelemIndices :: RefAtom
helemIndices :: Eq a => R a -> RefExp -> R (Fun (List a) (List Int))
gfindIndex :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) (Maybe Int)))
afindIndex :: RefAtom
hfindIndex :: R (Fun a Bool) -> RefExp -> R (Fun (List a) (Maybe Int))
gfindIndices :: RefSrcPos -> RefExp -> R (Fun (Fun a Bool) (Fun (List a) (List Int)))
afindIndices :: RefAtom
hfindIndices :: R (Fun a Bool) -> R (List a) -> RefExp -> R (List Int)
gzip :: RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List b) (List (Tuple2 a b))))
gzip3 :: RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List b) (Fun (List c) (List (Tuple3 a b c)))))
gzip4 :: RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List b) (Fun (List c) (Fun (List d) (List (Tuple4 a b c d))))))
gzip5 :: RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List b) (Fun (List c) (Fun (List d) (Fun (List e) (List (Tuple5 a b c d e)))))))
gzip6 :: RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List b) (Fun (List c) (Fun (List d) (Fun (List e) (Fun (List f) (List (Tuple6 a b c d e f))))))))
gzip7 :: RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List b) (Fun (List c) (Fun (List d) (Fun (List e) (Fun (List f) (Fun (List g) (List (Tuple7 a b c d e f g)))))))))
gzipWith :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b c)) (Fun (List a) (Fun (List b) (List c))))
azipWith :: RefAtom
hzipWith :: R (Fun a (Fun b c)) -> R (List a) -> R (List b) -> RefExp -> R (List c)
gzipWith3 :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b (Fun c d))) (Fun (List a) (Fun (List b) (Fun (List c) (List d)))))
azipWith3 :: RefAtom
hzipWith3 :: R (Fun a (Fun b (Fun c d))) -> R (List a) -> R (List b) -> R (List c) -> RefExp -> R (List d)
gzipWith4 :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b (Fun c (Fun d e)))) (Fun (List a) (Fun (List b) (Fun (List c) (Fun (List d) (List e))))))
azipWith4 :: RefAtom
hzipWith4 :: R (Fun a (Fun b (Fun c (Fun d e)))) -> R (List a) -> R (List b) -> R (List c) -> R (List d) -> RefExp -> R (List e)
gzipWith5 :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b (Fun c (Fun d (Fun e f))))) (Fun (List a) (Fun (List b) (Fun (List c) (Fun (List d) (Fun (List e) (List f)))))))
azipWith5 :: RefAtom
hzipWith5 :: R (Fun a (Fun b (Fun c (Fun d (Fun e f))))) -> R (List a) -> R (List b) -> R (List c) -> R (List d) -> R (List e) -> RefExp -> R (List f)
gzipWith6 :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b (Fun c (Fun d (Fun e (Fun f g)))))) (Fun (List a) (Fun (List b) (Fun (List c) (Fun (List d) (Fun (List e) (Fun (List f) (List g))))))))
azipWith6 :: RefAtom
hzipWith6 :: R (Fun a (Fun b (Fun c (Fun d (Fun e (Fun f g)))))) -> R (List a) -> R (List b) -> R (List c) -> R (List d) -> R (List e) -> R (List f) -> RefExp -> R (List g)
gzipWith7 :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun b (Fun c (Fun d (Fun e (Fun f (Fun g h))))))) (Fun (List a) (Fun (List b) (Fun (List c) (Fun (List d) (Fun (List e) (Fun (List f) (Fun (List g) (List h)))))))))
azipWith7 :: RefAtom
hzipWith7 :: R (Fun a (Fun b (Fun c (Fun d (Fun e (Fun f (Fun g h))))))) -> R (List a) -> R (List b) -> R (List c) -> R (List d) -> R (List e) -> R (List f) -> R (List g) -> RefExp -> R (List h)
gunzip :: RefSrcPos -> RefExp -> R (Fun (List (Tuple2 a b)) (Tuple2 (List a) (List b)))
gunzip3 :: RefSrcPos -> RefExp -> R (Fun (List (Tuple3 a b c)) (Tuple3 (List a) (List b) (List c)))
gunzip4 :: RefSrcPos -> RefExp -> R (Fun (List (Tuple4 a b c d)) (Tuple4 (List a) (List b) (List c) (List d)))
gunzip5 :: RefSrcPos -> RefExp -> R (Fun (List (Tuple5 a b c d e)) (Tuple5 (List a) (List b) (List c) (List d) (List e)))
gunzip6 :: RefSrcPos -> RefExp -> R (Fun (List (Tuple6 a b c d e f)) (Tuple6 (List a) (List b) (List c) (List d) (List e) (List f)))
gunzip7 :: RefSrcPos -> RefExp -> R (Fun (List (Tuple7 a b c d e f g)) (Tuple7 (List a) (List b) (List c) (List d) (List e) (List f) (List g)))
glines :: RefSrcPos -> RefExp -> R (Fun String (List String))
alines :: RefAtom
hlines :: R String -> RefExp -> R (List String)
gwords :: RefSrcPos -> RefExp -> R (Fun String (List String))
awords :: RefAtom
hwords :: R String -> RefExp -> R (List String)
gunlines :: RefSrcPos -> RefExp -> R (Fun (List String) String)
gunwords :: RefSrcPos -> RefExp -> R (Fun (List String) String)
aunwords :: RefAtom
hunwords :: R (List String) -> RefExp -> R String
gnub :: Eq a => RefSrcPos -> RefExp -> R (Fun (List a) (List a))
gdelete :: Eq a => RefSrcPos -> RefExp -> R (Fun a (Fun (List a) (List a)))
(!\\) :: Eq a => RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List a) (List a)))
gunion :: Eq a => RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List a) (List a)))
gintersect :: Eq a => RefSrcPos -> RefExp -> R (Fun (List a) (Fun (List a) (List a)))
gsort :: Ord a => RefSrcPos -> RefExp -> R (Fun (List a) (List a))
ginsert :: Ord a => RefSrcPos -> RefExp -> R (Fun a (Fun (List a) (List a)))
gnubBy :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a Bool)) (Fun (List a) (List a)))
anubBy :: RefAtom
hnubBy :: R (Fun a (Fun a Bool)) -> R (List a) -> RefExp -> R (List a)
gdeleteBy :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a Bool)) (Fun a (Fun (List a) (List a))))
adeleteBy :: RefAtom
hdeleteBy :: R (Fun a (Fun a Bool)) -> R a -> R (List a) -> RefExp -> R (List a)
gdeleteFirstsBy :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a Bool)) (Fun (List a) (Fun (List a) (List a))))
adeleteFirstsBy :: RefAtom
hdeleteFirstsBy :: R (Fun a (Fun a Bool)) -> RefExp -> R (Fun (List a) (Fun (List a) (List a)))
gunionBy :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a Bool)) (Fun (List a) (Fun (List a) (List a))))
aunionBy :: RefAtom
hunionBy :: R (Fun a (Fun a Bool)) -> R (List a) -> R (List a) -> RefExp -> R (List a)
gintersectBy :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a Bool)) (Fun (List a) (Fun (List a) (List a))))
aintersectBy :: RefAtom
hintersectBy :: R (Fun a (Fun a Bool)) -> R (List a) -> R (List a) -> RefExp -> R (List a)
ggroupBy :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a Bool)) (Fun (List a) (List (List a))))
agroupBy :: RefAtom
hgroupBy :: R (Fun a (Fun a Bool)) -> R (List a) -> RefExp -> R (List (List a))
gsortBy :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a Ordering)) (Fun (List a) (List a)))
asortBy :: RefAtom
hsortBy :: R (Fun a (Fun a Ordering)) -> RefExp -> R (Fun (List a) (List a))
ginsertBy :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a Ordering)) (Fun a (Fun (List a) (List a))))
ainsertBy :: RefAtom
hinsertBy :: R (Fun a (Fun a Ordering)) -> R a -> R (List a) -> RefExp -> R (List a)
gmaximumBy :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a Ordering)) (Fun (List a) a))
amaximumBy :: RefAtom
hmaximumBy :: R (Fun a (Fun a Ordering)) -> R (List a) -> RefExp -> R a
gminimumBy :: RefSrcPos -> RefExp -> R (Fun (Fun a (Fun a Ordering)) (Fun (List a) a))
aminimumBy :: RefAtom
hminimumBy :: R (Fun a (Fun a Ordering)) -> R (List a) -> RefExp -> R a
ggenericLength :: Integral a => RefSrcPos -> RefExp -> R (Fun (List b) a)
agenericLength :: RefAtom
hgenericLength :: Integral a => R (List b) -> RefExp -> R a
ggenericTake :: Integral a => RefSrcPos -> RefExp -> R (Fun a (Fun (List b) (List b)))
agenericTake :: RefAtom
hgenericTake :: Integral a => R a -> R (List b) -> RefExp -> R (List b)
ggenericDrop :: Integral a => RefSrcPos -> RefExp -> R (Fun a (Fun (List b) (List b)))
agenericDrop :: RefAtom
hgenericDrop :: Integral a => R a -> R (List b) -> RefExp -> R (List b)
ggenericSplitAt :: Integral a => RefSrcPos -> RefExp -> R (Fun a (Fun (List b) (Tuple2 (List b) (List b))))
agenericSplitAt :: RefAtom
hgenericSplitAt :: Integral a => R a -> R (List b) -> RefExp -> R (Tuple2 (List b) (List b))
ggenericIndex :: Integral a => RefSrcPos -> RefExp -> R (Fun (List b) (Fun a b))
agenericIndex :: RefAtom
hgenericIndex :: Integral a => R (List b) -> R a -> RefExp -> R b
ggenericReplicate :: Integral a => RefSrcPos -> RefExp -> R (Fun a (Fun b (List b)))
agenericReplicate :: RefAtom
hgenericReplicate :: Integral a => R a -> R b -> RefExp -> R (List b)

module Hat.System.Exit
data ExitCode
ExitSuccess :: ExitCode
ExitFailure :: (R Int) -> ExitCode
aExitSuccess :: RefAtom
aExitFailure :: RefAtom
gexitWith :: RefSrcPos -> RefExp -> R (Fun ExitCode (IO a))
aexitWith :: RefAtom
hexitWith :: R ExitCode -> RefExp -> R (IO b)
gexitFailure :: RefSrcPos -> RefExp -> R (IO a)
gexitSuccess :: RefSrcPos -> RefExp -> R (IO a)

module Hat.Ix
class Ord a => Ix a where srange = gundefined mkNoSrcPos p sindex = gundefined mkNoSrcPos p sinRange = gundefined mkNoSrcPos p srangeSize = gundefined mkNoSrcPos p grangeSize prangeSize p = ufun1 c9v5v10v54rangeSize prangeSize p hrangeSize where hrangeSize fb@(R (Tuple2 fl fh) _) p = ucguard (uwrapForward p (hnull (uap1 mkNoSrcPos p (grange mkNoSrcPos p) fb) p)) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (0))) (ucguard (gotherwise mkNoSrcPos p) (uap2 mkNoSrcPos p ((!+) mkNoSrcPos p) (uap2 mkNoSrcPos p (gindex mkNoSrcPos p) fb fh) (uap1 mkNoSrcPos p (gfromInteger mkNoSrcPos p) (conInteger mkNoSrcPos p (1)))) (fatal p))
grange :: Ix a => RefSrcPos -> RefExp -> R (Fun (Tuple2 a a) (List a))
srange :: Ix a => R (Fun (Tuple2 a a) (List a))
gindex :: Ix a => RefSrcPos -> RefExp -> R (Fun (Tuple2 a a) (Fun a Int))
sindex :: Ix a => R (Fun (Tuple2 a a) (Fun a Int))
ginRange :: Ix a => RefSrcPos -> RefExp -> R (Fun (Tuple2 a a) (Fun a Bool))
sinRange :: Ix a => R (Fun (Tuple2 a a) (Fun a Bool))
grangeSize :: Ix a => RefSrcPos -> RefExp -> R (Fun (Tuple2 a a) Int)
srangeSize :: Ix a => R (Fun (Tuple2 a a) Int)
instance (Ix a1, Ix a2, Ix a3, Ix a4, Ix a5, Ix a6, Ix a7, Ix a8, Ix a9, Ix a10, Ix a11, Ix a12, Ix a13, Ix a14, Ix a15) => Ix (Tuple15 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15)
instance (Ix a1, Ix a2, Ix a3, Ix a4, Ix a5, Ix a6, Ix a7, Ix a8, Ix a9, Ix a10, Ix a11, Ix a12, Ix a13, Ix a14) => Ix (Tuple14 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14)
instance (Ix a1, Ix a2, Ix a3, Ix a4, Ix a5, Ix a6, Ix a7, Ix a8, Ix a9, Ix a10, Ix a11, Ix a12, Ix a13) => Ix (Tuple13 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13)
instance (Ix a1, Ix a2, Ix a3, Ix a4, Ix a5, Ix a6, Ix a7, Ix a8, Ix a9, Ix a10, Ix a11, Ix a12) => Ix (Tuple12 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12)
instance (Ix a1, Ix a2, Ix a3, Ix a4, Ix a5, Ix a6, Ix a7, Ix a8, Ix a9, Ix a10, Ix a11) => Ix (Tuple11 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11)
instance (Ix a1, Ix a2, Ix a3, Ix a4, Ix a5, Ix a6, Ix a7, Ix a8, Ix a9, Ix a10) => Ix (Tuple10 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10)
instance (Ix a1, Ix a2, Ix a3, Ix a4, Ix a5, Ix a6, Ix a7, Ix a8, Ix a9) => Ix (Tuple9 a1 a2 a3 a4 a5 a6 a7 a8 a9)
instance (Ix a1, Ix a2, Ix a3, Ix a4, Ix a5, Ix a6, Ix a7, Ix a8) => Ix (Tuple8 a1 a2 a3 a4 a5 a6 a7 a8)
instance (Ix a1, Ix a2, Ix a3, Ix a4, Ix a5, Ix a6, Ix a7) => Ix (Tuple7 a1 a2 a3 a4 a5 a6 a7)
instance (Ix a1, Ix a2, Ix a3, Ix a4, Ix a5, Ix a6) => Ix (Tuple6 a1 a2 a3 a4 a5 a6)
instance (Ix a1, Ix a2, Ix a3, Ix a4, Ix a5) => Ix (Tuple5 a1 a2 a3 a4 a5)
instance (Ix a1, Ix a2, Ix a3, Ix a4) => Ix (Tuple4 a1 a2 a3 a4)
instance (Ix a1, Ix a2, Ix a3) => Ix (Tuple3 a1 a2 a3)
instance (Ix a, Ix b) => Ix (Tuple2 a b)
instance Ix Tuple0
instance Ix Ordering
instance Ix Bool
instance Ix Integer
instance Ix Int
instance Ix Char

module Hat.IO

-- | Haskell defines operations to read and write characters from and to
--   files, represented by values of type <tt>Handle</tt>. Each value of
--   this type is a <i>handle</i>: a record used by the Haskell run-time
--   system to <i>manage</i> I/O with file system objects. A handle has at
--   least the following properties:
--   
--   <ul>
--   <li>whether it manages input or output or both;</li>
--   <li>whether it is <i>open</i>, <i>closed</i> or
--   <i>semi-closed</i>;</li>
--   <li>whether the object is seekable;</li>
--   <li>whether buffering is disabled, or enabled on a line or block
--   basis;</li>
--   <li>a buffer (whose length may be zero).</li>
--   </ul>
--   
--   Most handles will also have a current I/O position indicating where
--   the next input or output operation will occur. A handle is
--   <i>readable</i> if it manages only input or both input and output;
--   likewise, it is <i>writable</i> if it manages only output or both
--   input and output. A handle is <i>open</i> when first allocated. Once
--   it is closed it can no longer be used for either input or output,
--   though an implementation cannot re-use its storage while references
--   remain to it. Handles are in the <a>Show</a> and <a>Eq</a> classes.
--   The string produced by showing a handle is system dependent; it should
--   include enough information to identify the handle for debugging. A
--   handle is equal according to <a>==</a> only to itself; no attempt is
--   made to compare the internal state of different handles for equality.
data Handle :: *
data HandlePosn :: *
data IOMode
ReadMode :: IOMode
WriteMode :: IOMode
AppendMode :: IOMode
ReadWriteMode :: IOMode
aReadMode :: RefAtom
aWriteMode :: RefAtom
aAppendMode :: RefAtom
aReadWriteMode :: RefAtom
data BufferMode
NoBuffering :: BufferMode
LineBuffering :: BufferMode
BlockBuffering :: (R (Maybe Int)) -> BufferMode
aNoBuffering :: RefAtom
aLineBuffering :: RefAtom
aBlockBuffering :: RefAtom
data SeekMode
AbsoluteSeek :: SeekMode
RelativeSeek :: SeekMode
SeekFromEnd :: SeekMode
aAbsoluteSeek :: RefAtom
aRelativeSeek :: RefAtom
aSeekFromEnd :: RefAtom
gstdin :: RefSrcPos -> RefExp -> R Handle
gstdout :: RefSrcPos -> RefExp -> R Handle
gstderr :: RefSrcPos -> RefExp -> R Handle
gopenFile :: RefSrcPos -> RefExp -> R (Fun String (Fun IOMode (IO Handle)))
aopenFile :: RefAtom
hopenFile :: R String -> R IOMode -> RefExp -> R (IO Handle)
ghClose :: RefSrcPos -> RefExp -> R (Fun Handle (IO Tuple0))
ahClose :: RefAtom
hhClose :: R Handle -> RefExp -> R (IO Tuple0)
ghFileSize :: RefSrcPos -> RefExp -> R (Fun Handle (IO Integer))
ahFileSize :: RefAtom
hhFileSize :: R Handle -> RefExp -> R (IO Integer)
ghIsEOF :: RefSrcPos -> RefExp -> R (Fun Handle (IO Bool))
ahIsEOF :: RefAtom
hhIsEOF :: R Handle -> RefExp -> R (IO Bool)
gisEOF :: RefSrcPos -> RefExp -> R (IO Bool)
ghSetBuffering :: RefSrcPos -> RefExp -> R (Fun Handle (Fun BufferMode (IO Tuple0)))
ahSetBuffering :: RefAtom
hhSetBuffering :: R Handle -> R BufferMode -> RefExp -> R (IO Tuple0)
ghGetBuffering :: RefSrcPos -> RefExp -> R (Fun Handle (IO BufferMode))
ahGetBuffering :: RefAtom
hhGetBuffering :: R Handle -> RefExp -> R (IO BufferMode)
ghFlush :: RefSrcPos -> RefExp -> R (Fun Handle (IO Tuple0))
ahFlush :: RefAtom
hhFlush :: R Handle -> RefExp -> R (IO Tuple0)
ghGetPosn :: RefSrcPos -> RefExp -> R (Fun Handle (IO HandlePosn))
ahGetPosn :: RefAtom
hhGetPosn :: R Handle -> RefExp -> R (IO HandlePosn)
ghSetPosn :: RefSrcPos -> RefExp -> R (Fun HandlePosn (IO Tuple0))
ahSetPosn :: RefAtom
hhSetPosn :: R HandlePosn -> RefExp -> R (IO Tuple0)
ghSeek :: RefSrcPos -> RefExp -> R (Fun Handle (Fun SeekMode (Fun Integer (IO Tuple0))))
ahSeek :: RefAtom
hhSeek :: R Handle -> R SeekMode -> R Integer -> RefExp -> R (IO Tuple0)
ghWaitForInput :: RefSrcPos -> RefExp -> R (Fun Handle (Fun Int (IO Bool)))
ahWaitForInput :: RefAtom
hhWaitForInput :: R Handle -> R Int -> RefExp -> R (IO Bool)
ghReady :: RefSrcPos -> RefExp -> R (Fun Handle (IO Bool))
ahReady :: RefAtom
hhReady :: R Handle -> RefExp -> R (IO Bool)
ghGetChar :: RefSrcPos -> RefExp -> R (Fun Handle (IO Char))
ahGetChar :: RefAtom
hhGetChar :: R Handle -> RefExp -> R (IO Char)
ghGetLine :: RefSrcPos -> RefExp -> R (Fun Handle (IO String))
ahGetLine :: RefAtom
hhGetLine :: R Handle -> RefExp -> R (IO String)
ghLookAhead :: RefSrcPos -> RefExp -> R (Fun Handle (IO Char))
ahLookAhead :: RefAtom
hhLookAhead :: R Handle -> RefExp -> R (IO Char)
ghGetContents :: RefSrcPos -> RefExp -> R (Fun Handle (IO String))
ahGetContents :: RefAtom
hhGetContents :: R Handle -> RefExp -> R (IO String)
ghPutChar :: RefSrcPos -> RefExp -> R (Fun Handle (Fun Char (IO Tuple0)))
ahPutChar :: RefAtom
hhPutChar :: R Handle -> R Char -> RefExp -> R (IO Tuple0)
ghPutStr :: RefSrcPos -> RefExp -> R (Fun Handle (Fun String (IO Tuple0)))
ahPutStr :: RefAtom
hhPutStr :: R Handle -> R String -> RefExp -> R (IO Tuple0)
ghPutStrLn :: RefSrcPos -> RefExp -> R (Fun Handle (Fun String (IO Tuple0)))
ahPutStrLn :: RefAtom
hhPutStrLn :: R Handle -> R String -> RefExp -> R (IO Tuple0)
ghPrint :: Show a => RefSrcPos -> RefExp -> R (Fun Handle (Fun a (IO Tuple0)))
ahPrint :: RefAtom
hhPrint :: Show a => R Handle -> R a -> RefExp -> R (IO Tuple0)
ghIsOpen :: RefSrcPos -> RefExp -> R (Fun Handle (IO Bool))
ahIsOpen :: RefAtom
hhIsOpen :: R Handle -> RefExp -> R (IO Bool)
ghIsClosed :: RefSrcPos -> RefExp -> R (Fun Handle (IO Bool))
ahIsClosed :: RefAtom
hhIsClosed :: R Handle -> RefExp -> R (IO Bool)
ghIsReadable :: RefSrcPos -> RefExp -> R (Fun Handle (IO Bool))
ahIsReadable :: RefAtom
hhIsReadable :: R Handle -> RefExp -> R (IO Bool)
ghIsWritable :: RefSrcPos -> RefExp -> R (Fun Handle (IO Bool))
ahIsWritable :: RefAtom
hhIsWritable :: R Handle -> RefExp -> R (IO Bool)
ghIsSeekable :: RefSrcPos -> RefExp -> R (Fun Handle (IO Bool))
ahIsSeekable :: RefAtom
hhIsSeekable :: R Handle -> RefExp -> R (IO Bool)
gisAlreadyExistsError :: RefSrcPos -> RefExp -> R (Fun IOError Bool)
aisAlreadyExistsError :: RefAtom
hisAlreadyExistsError :: R IOError -> RefExp -> R Bool
gisDoesNotExistError :: RefSrcPos -> RefExp -> R (Fun IOError Bool)
aisDoesNotExistError :: RefAtom
hisDoesNotExistError :: R IOError -> RefExp -> R Bool
gisAlreadyInUseError :: RefSrcPos -> RefExp -> R (Fun IOError Bool)
aisAlreadyInUseError :: RefAtom
hisAlreadyInUseError :: R IOError -> RefExp -> R Bool
gisFullError :: RefSrcPos -> RefExp -> R (Fun IOError Bool)
aisFullError :: RefAtom
hisFullError :: R IOError -> RefExp -> R Bool
gisEOFError :: RefSrcPos -> RefExp -> R (Fun IOError Bool)
aisEOFError :: RefAtom
hisEOFError :: R IOError -> RefExp -> R Bool
gisIllegalOperation :: RefSrcPos -> RefExp -> R (Fun IOError Bool)
aisIllegalOperation :: RefAtom
hisIllegalOperation :: R IOError -> RefExp -> R Bool
gisPermissionError :: RefSrcPos -> RefExp -> R (Fun IOError Bool)
aisPermissionError :: RefAtom
hisPermissionError :: R IOError -> RefExp -> R Bool
gisUserError :: RefSrcPos -> RefExp -> R (Fun IOError Bool)
aisUserError :: RefAtom
hisUserError :: R IOError -> RefExp -> R Bool
gioeGetErrorString :: RefSrcPos -> RefExp -> R (Fun IOError String)
aioeGetErrorString :: RefAtom
hioeGetErrorString :: R IOError -> RefExp -> R String
gioeGetHandle :: RefSrcPos -> RefExp -> R (Fun IOError (Maybe Handle))
aioeGetHandle :: RefAtom
hioeGetHandle :: R IOError -> RefExp -> R (Maybe Handle)
gioeGetFileName :: RefSrcPos -> RefExp -> R (Fun IOError (Maybe String))
aioeGetFileName :: RefAtom
hioeGetFileName :: R IOError -> RefExp -> R (Maybe String)
gtry :: RefSrcPos -> RefExp -> R (Fun (IO a) (IO (Either IOError a)))
atry :: RefAtom
htry :: R (IO a) -> RefExp -> R (IO (Either IOError a))
gbracket :: RefSrcPos -> RefExp -> R (Fun (IO a) (Fun (Fun a (IO b)) (Fun (Fun a (IO c)) (IO c))))
abracket :: RefAtom
hbracket :: R (IO a) -> R (Fun a (IO b)) -> R (Fun a (IO c)) -> RefExp -> R (IO c)
gbracket_ :: RefSrcPos -> RefExp -> R (Fun (IO a) (Fun (Fun a (IO b)) (Fun (IO c) (IO c))))
abracket_ :: RefAtom
hbracket_ :: R (IO a) -> R (Fun a (IO b)) -> R (IO c) -> RefExp -> R (IO c)
data IO a
type FilePath = String

-- | The Haskell 2010 type for exceptions in the <a>IO</a> monad. Any I/O
--   operation may raise an <a>IOError</a> instead of returning a result.
--   For a more general type of exception, including also those that arise
--   in pure code, see <a>Control.Exception.Exception</a>.
--   
--   In Haskell 2010, this is an opaque type.
type IOError = IOException
gioError :: RefSrcPos -> RefExp -> R (Fun IOError (IO a))
aioError :: RefAtom
hioError :: R IOError -> RefExp -> R (IO b)
guserError :: RefSrcPos -> RefExp -> R (Fun String IOError)
auserError :: RefAtom
huserError :: R String -> RefExp -> R IOError
gcatch :: RefSrcPos -> RefExp -> R (Fun (IO a) (Fun (Fun IOError (IO a)) (IO a)))
acatch :: RefAtom
hcatch :: R (IO b) -> R (Fun IOError (IO b)) -> RefExp -> R (IO b)
ginteract :: RefSrcPos -> RefExp -> R (Fun (Fun String String) (IO Tuple0))
ainteract :: RefAtom
hinteract :: R (Fun String String) -> RefExp -> R (IO Tuple0)
gputChar :: RefSrcPos -> RefExp -> R (Fun Char (IO Tuple0))
aputChar :: RefAtom
hputChar :: R Char -> RefExp -> R (IO Tuple0)
gputStr :: RefSrcPos -> RefExp -> R (Fun String (IO Tuple0))
aputStr :: RefAtom
hputStr :: R String -> RefExp -> R (IO Tuple0)
gputStrLn :: RefSrcPos -> RefExp -> R (Fun String (IO Tuple0))
aputStrLn :: RefAtom
hputStrLn :: R String -> RefExp -> R (IO Tuple0)
gprint :: Show a => RefSrcPos -> RefExp -> R (Fun a (IO Tuple0))
aprint :: RefAtom
hprint :: Show a => R a -> RefExp -> R (IO Tuple0)
ggetChar :: RefSrcPos -> RefExp -> R (IO Char)
ggetLine :: RefSrcPos -> RefExp -> R (IO String)
ggetContents :: RefSrcPos -> RefExp -> R (IO String)
greadFile :: RefSrcPos -> RefExp -> R (Fun String (IO String))
areadFile :: RefAtom
hreadFile :: R String -> RefExp -> R (IO String)
gwriteFile :: RefSrcPos -> RefExp -> R (Fun String (Fun String (IO Tuple0)))
awriteFile :: RefAtom
hwriteFile :: R String -> R String -> RefExp -> R (IO Tuple0)
gappendFile :: RefSrcPos -> RefExp -> R (Fun String (Fun String (IO Tuple0)))
aappendFile :: RefAtom
happendFile :: R String -> R String -> RefExp -> R (IO Tuple0)
greadIO :: Read a => RefSrcPos -> RefExp -> R (Fun String (IO a))
areadIO :: RefAtom
hreadIO :: Read a => R String -> RefExp -> R (IO a)
greadLn :: Read a => RefSrcPos -> RefExp -> R (IO a)
instance Eq HandlePosn
instance Show Handle
instance Eq Handle

module Hat.System.Environment
ggetArgs :: RefSrcPos -> RefExp -> R (IO (List String))
ggetProgName :: RefSrcPos -> RefExp -> R (IO String)
ggetEnv :: RefSrcPos -> RefExp -> R (Fun String (IO String))
agetEnv :: RefAtom
hgetEnv :: R String -> RefExp -> R (IO String)

module Hat.System.IO
data IO a
gfixIO :: RefSrcPos -> RefExp -> R (Fun (Fun a (IO a)) (IO a))
afixIO :: RefAtom
hfixIO :: R (Fun a (IO a)) -> RefExp -> R (IO a)
type FilePath = String

-- | Haskell defines operations to read and write characters from and to
--   files, represented by values of type <tt>Handle</tt>. Each value of
--   this type is a <i>handle</i>: a record used by the Haskell run-time
--   system to <i>manage</i> I/O with file system objects. A handle has at
--   least the following properties:
--   
--   <ul>
--   <li>whether it manages input or output or both;</li>
--   <li>whether it is <i>open</i>, <i>closed</i> or
--   <i>semi-closed</i>;</li>
--   <li>whether the object is seekable;</li>
--   <li>whether buffering is disabled, or enabled on a line or block
--   basis;</li>
--   <li>a buffer (whose length may be zero).</li>
--   </ul>
--   
--   Most handles will also have a current I/O position indicating where
--   the next input or output operation will occur. A handle is
--   <i>readable</i> if it manages only input or both input and output;
--   likewise, it is <i>writable</i> if it manages only output or both
--   input and output. A handle is <i>open</i> when first allocated. Once
--   it is closed it can no longer be used for either input or output,
--   though an implementation cannot re-use its storage while references
--   remain to it. Handles are in the <a>Show</a> and <a>Eq</a> classes.
--   The string produced by showing a handle is system dependent; it should
--   include enough information to identify the handle for debugging. A
--   handle is equal according to <a>==</a> only to itself; no attempt is
--   made to compare the internal state of different handles for equality.
data Handle :: *
gstdin :: RefSrcPos -> RefExp -> R Handle
gstdout :: RefSrcPos -> RefExp -> R Handle
gstderr :: RefSrcPos -> RefExp -> R Handle
gwithFile :: RefSrcPos -> RefExp -> R (Fun String (Fun IOMode (Fun (Fun Handle (IO r)) (IO r))))
awithFile :: RefAtom
hwithFile :: R String -> R IOMode -> R (Fun Handle (IO b)) -> RefExp -> R (IO b)
gopenFile :: RefSrcPos -> RefExp -> R (Fun String (Fun IOMode (IO Handle)))
aopenFile :: RefAtom
hopenFile :: R String -> R IOMode -> RefExp -> R (IO Handle)
data IOMode
ReadMode :: IOMode
WriteMode :: IOMode
AppendMode :: IOMode
ReadWriteMode :: IOMode
aReadMode :: RefAtom
aWriteMode :: RefAtom
aAppendMode :: RefAtom
aReadWriteMode :: RefAtom
ghClose :: RefSrcPos -> RefExp -> R (Fun Handle (IO Tuple0))
ahClose :: RefAtom
hhClose :: R Handle -> RefExp -> R (IO Tuple0)
greadFile :: RefSrcPos -> RefExp -> R (Fun String (IO String))
areadFile :: RefAtom
hreadFile :: R String -> RefExp -> R (IO String)
gwriteFile :: RefSrcPos -> RefExp -> R (Fun String (Fun String (IO Tuple0)))
awriteFile :: RefAtom
hwriteFile :: R String -> R String -> RefExp -> R (IO Tuple0)
gappendFile :: RefSrcPos -> RefExp -> R (Fun String (Fun String (IO Tuple0)))
aappendFile :: RefAtom
happendFile :: R String -> R String -> RefExp -> R (IO Tuple0)
ghFileSize :: RefSrcPos -> RefExp -> R (Fun Handle (IO Integer))
ahFileSize :: RefAtom
hhFileSize :: R Handle -> RefExp -> R (IO Integer)
ghSetFileSize :: RefSrcPos -> RefExp -> R (Fun Handle (Fun Integer (IO Tuple0)))
ahSetFileSize :: RefAtom
hhSetFileSize :: R Handle -> R Integer -> RefExp -> R (IO Tuple0)
ghIsEOF :: RefSrcPos -> RefExp -> R (Fun Handle (IO Bool))
ahIsEOF :: RefAtom
hhIsEOF :: R Handle -> RefExp -> R (IO Bool)
gisEOF :: RefSrcPos -> RefExp -> R (IO Bool)
data BufferMode
NoBuffering :: BufferMode
LineBuffering :: BufferMode
BlockBuffering :: (R (Maybe Int)) -> BufferMode
aNoBuffering :: RefAtom
aLineBuffering :: RefAtom
aBlockBuffering :: RefAtom
ghSetBuffering :: RefSrcPos -> RefExp -> R (Fun Handle (Fun BufferMode (IO Tuple0)))
ahSetBuffering :: RefAtom
hhSetBuffering :: R Handle -> R BufferMode -> RefExp -> R (IO Tuple0)
ghGetBuffering :: RefSrcPos -> RefExp -> R (Fun Handle (IO BufferMode))
ahGetBuffering :: RefAtom
hhGetBuffering :: R Handle -> RefExp -> R (IO BufferMode)
ghFlush :: RefSrcPos -> RefExp -> R (Fun Handle (IO Tuple0))
ahFlush :: RefAtom
hhFlush :: R Handle -> RefExp -> R (IO Tuple0)
ghGetPosn :: RefSrcPos -> RefExp -> R (Fun Handle (IO HandlePosn))
ahGetPosn :: RefAtom
hhGetPosn :: R Handle -> RefExp -> R (IO HandlePosn)
ghSetPosn :: RefSrcPos -> RefExp -> R (Fun HandlePosn (IO Tuple0))
ahSetPosn :: RefAtom
hhSetPosn :: R HandlePosn -> RefExp -> R (IO Tuple0)
data HandlePosn :: *
ghSeek :: RefSrcPos -> RefExp -> R (Fun Handle (Fun SeekMode (Fun Integer (IO Tuple0))))
ahSeek :: RefAtom
hhSeek :: R Handle -> R SeekMode -> R Integer -> RefExp -> R (IO Tuple0)
data SeekMode
AbsoluteSeek :: SeekMode
RelativeSeek :: SeekMode
SeekFromEnd :: SeekMode
aAbsoluteSeek :: RefAtom
aRelativeSeek :: RefAtom
aSeekFromEnd :: RefAtom
ghTell :: RefSrcPos -> RefExp -> R (Fun Handle (IO Integer))
ahTell :: RefAtom
hhTell :: R Handle -> RefExp -> R (IO Integer)
ghIsOpen :: RefSrcPos -> RefExp -> R (Fun Handle (IO Bool))
ahIsOpen :: RefAtom
hhIsOpen :: R Handle -> RefExp -> R (IO Bool)
ghIsClosed :: RefSrcPos -> RefExp -> R (Fun Handle (IO Bool))
ahIsClosed :: RefAtom
hhIsClosed :: R Handle -> RefExp -> R (IO Bool)
ghIsReadable :: RefSrcPos -> RefExp -> R (Fun Handle (IO Bool))
ahIsReadable :: RefAtom
hhIsReadable :: R Handle -> RefExp -> R (IO Bool)
ghIsWritable :: RefSrcPos -> RefExp -> R (Fun Handle (IO Bool))
ahIsWritable :: RefAtom
hhIsWritable :: R Handle -> RefExp -> R (IO Bool)
ghIsSeekable :: RefSrcPos -> RefExp -> R (Fun Handle (IO Bool))
ahIsSeekable :: RefAtom
hhIsSeekable :: R Handle -> RefExp -> R (IO Bool)
ghIsTerminalDevice :: RefSrcPos -> RefExp -> R (Fun Handle (IO Bool))
ahIsTerminalDevice :: RefAtom
hhIsTerminalDevice :: R Handle -> RefExp -> R (IO Bool)
ghSetEcho :: RefSrcPos -> RefExp -> R (Fun Handle (Fun Bool (IO Tuple0)))
ahSetEcho :: RefAtom
hhSetEcho :: R Handle -> R Bool -> RefExp -> R (IO Tuple0)
ghGetEcho :: RefSrcPos -> RefExp -> R (Fun Handle (IO Bool))
ahGetEcho :: RefAtom
hhGetEcho :: R Handle -> RefExp -> R (IO Bool)
ghShow :: RefSrcPos -> RefExp -> R (Fun Handle (IO String))
ahShow :: RefAtom
hhShow :: R Handle -> RefExp -> R (IO String)
ghWaitForInput :: RefSrcPos -> RefExp -> R (Fun Handle (Fun Int (IO Bool)))
ahWaitForInput :: RefAtom
hhWaitForInput :: R Handle -> R Int -> RefExp -> R (IO Bool)
ghReady :: RefSrcPos -> RefExp -> R (Fun Handle (IO Bool))
ahReady :: RefAtom
hhReady :: R Handle -> RefExp -> R (IO Bool)
ghGetChar :: RefSrcPos -> RefExp -> R (Fun Handle (IO Char))
ahGetChar :: RefAtom
hhGetChar :: R Handle -> RefExp -> R (IO Char)
ghGetLine :: RefSrcPos -> RefExp -> R (Fun Handle (IO String))
ahGetLine :: RefAtom
hhGetLine :: R Handle -> RefExp -> R (IO String)
ghLookAhead :: RefSrcPos -> RefExp -> R (Fun Handle (IO Char))
ahLookAhead :: RefAtom
hhLookAhead :: R Handle -> RefExp -> R (IO Char)
ghGetContents :: RefSrcPos -> RefExp -> R (Fun Handle (IO String))
ahGetContents :: RefAtom
hhGetContents :: R Handle -> RefExp -> R (IO String)
ghPutChar :: RefSrcPos -> RefExp -> R (Fun Handle (Fun Char (IO Tuple0)))
ahPutChar :: RefAtom
hhPutChar :: R Handle -> R Char -> RefExp -> R (IO Tuple0)
ghPutStr :: RefSrcPos -> RefExp -> R (Fun Handle (Fun String (IO Tuple0)))
ahPutStr :: RefAtom
hhPutStr :: R Handle -> R String -> RefExp -> R (IO Tuple0)
ghPutStrLn :: RefSrcPos -> RefExp -> R (Fun Handle (Fun String (IO Tuple0)))
ahPutStrLn :: RefAtom
hhPutStrLn :: R Handle -> R String -> RefExp -> R (IO Tuple0)
ghPrint :: Show a => RefSrcPos -> RefExp -> R (Fun Handle (Fun a (IO Tuple0)))
ahPrint :: RefAtom
hhPrint :: Show a => R Handle -> R a -> RefExp -> R (IO Tuple0)
ginteract :: RefSrcPos -> RefExp -> R (Fun (Fun String String) (IO Tuple0))
ainteract :: RefAtom
hinteract :: R (Fun String String) -> RefExp -> R (IO Tuple0)
gputChar :: RefSrcPos -> RefExp -> R (Fun Char (IO Tuple0))
aputChar :: RefAtom
hputChar :: R Char -> RefExp -> R (IO Tuple0)
gputStr :: RefSrcPos -> RefExp -> R (Fun String (IO Tuple0))
aputStr :: RefAtom
hputStr :: R String -> RefExp -> R (IO Tuple0)
gputStrLn :: RefSrcPos -> RefExp -> R (Fun String (IO Tuple0))
aputStrLn :: RefAtom
hputStrLn :: R String -> RefExp -> R (IO Tuple0)
gprint :: Show a => RefSrcPos -> RefExp -> R (Fun a (IO Tuple0))
aprint :: RefAtom
hprint :: Show a => R a -> RefExp -> R (IO Tuple0)
ggetChar :: RefSrcPos -> RefExp -> R (IO Char)
ggetLine :: RefSrcPos -> RefExp -> R (IO String)
ggetContents :: RefSrcPos -> RefExp -> R (IO String)
greadIO :: Read a => RefSrcPos -> RefExp -> R (Fun String (IO a))
areadIO :: RefAtom
hreadIO :: Read a => R String -> RefExp -> R (IO a)
greadLn :: Read a => RefSrcPos -> RefExp -> R (IO a)

module Hat.Directory
data Permissions
Permissions :: R Bool -> R Bool -> R Bool -> R Bool -> Permissions
breadable :: Permissions -> R Bool
bwritable :: Permissions -> R Bool
bexecutable :: Permissions -> R Bool
bsearchable :: Permissions -> R Bool
greadable :: RefSrcPos -> RefExp -> R (Fun Permissions Bool)
gwritable :: RefSrcPos -> RefExp -> R (Fun Permissions Bool)
gexecutable :: RefSrcPos -> RefExp -> R (Fun Permissions Bool)
gsearchable :: RefSrcPos -> RefExp -> R (Fun Permissions Bool)
hreadable :: R Permissions -> RefExp -> R Bool
hwritable :: R Permissions -> RefExp -> R Bool
hexecutable :: R Permissions -> RefExp -> R Bool
hsearchable :: R Permissions -> RefExp -> R Bool
areadable :: RefAtom
awritable :: RefAtom
aexecutable :: RefAtom
asearchable :: RefAtom
aPermissions :: RefAtom
gcreateDirectory :: RefSrcPos -> RefExp -> R (Fun String (IO Tuple0))
acreateDirectory :: RefAtom
hcreateDirectory :: R String -> RefExp -> R (IO Tuple0)
gremoveDirectory :: RefSrcPos -> RefExp -> R (Fun String (IO Tuple0))
aremoveDirectory :: RefAtom
hremoveDirectory :: R String -> RefExp -> R (IO Tuple0)
gremoveFile :: RefSrcPos -> RefExp -> R (Fun String (IO Tuple0))
aremoveFile :: RefAtom
hremoveFile :: R String -> RefExp -> R (IO Tuple0)
grenameDirectory :: RefSrcPos -> RefExp -> R (Fun String (Fun String (IO Tuple0)))
arenameDirectory :: RefAtom
hrenameDirectory :: R String -> R String -> RefExp -> R (IO Tuple0)
grenameFile :: RefSrcPos -> RefExp -> R (Fun String (Fun String (IO Tuple0)))
arenameFile :: RefAtom
hrenameFile :: R String -> R String -> RefExp -> R (IO Tuple0)
ggetDirectoryContents :: RefSrcPos -> RefExp -> R (Fun String (IO (List String)))
agetDirectoryContents :: RefAtom
hgetDirectoryContents :: R String -> RefExp -> R (IO (List String))
ggetCurrentDirectory :: RefSrcPos -> RefExp -> R (IO String)
gsetCurrentDirectory :: RefSrcPos -> RefExp -> R (Fun String (IO Tuple0))
asetCurrentDirectory :: RefAtom
hsetCurrentDirectory :: R String -> RefExp -> R (IO Tuple0)
gdoesFileExist :: RefSrcPos -> RefExp -> R (Fun String (IO Bool))
adoesFileExist :: RefAtom
hdoesFileExist :: R String -> RefExp -> R (IO Bool)
gdoesDirectoryExist :: RefSrcPos -> RefExp -> R (Fun String (IO Bool))
adoesDirectoryExist :: RefAtom
hdoesDirectoryExist :: R String -> RefExp -> R (IO Bool)
ggetPermissions :: RefSrcPos -> RefExp -> R (Fun String (IO Permissions))
agetPermissions :: RefAtom
hgetPermissions :: R String -> RefExp -> R (IO Permissions)
gsetPermissions :: RefSrcPos -> RefExp -> R (Fun String (Fun Permissions (IO Tuple0)))
asetPermissions :: RefAtom
hsetPermissions :: R String -> R Permissions -> RefExp -> R (IO Tuple0)
instance Show Permissions
instance Read Permissions
instance Ord Permissions
instance Eq Permissions

module Hat.Time

-- | A representation of the internal clock time. Clock times may be
--   compared, converted to strings, or converted to an external calendar
--   time <a>CalendarTime</a> for I/O or other manipulations.
data ClockTime :: *
data Month
January :: Month
February :: Month
March :: Month
April :: Month
May :: Month
June :: Month
July :: Month
August :: Month
September :: Month
October :: Month
November :: Month
December :: Month
aJanuary :: RefAtom
aFebruary :: RefAtom
aMarch :: RefAtom
aApril :: RefAtom
aMay :: RefAtom
aJune :: RefAtom
aJuly :: RefAtom
aAugust :: RefAtom
aSeptember :: RefAtom
aOctober :: RefAtom
aNovember :: RefAtom
aDecember :: RefAtom
data Day
Sunday :: Day
Monday :: Day
Tuesday :: Day
Wednesday :: Day
Thursday :: Day
Friday :: Day
Saturday :: Day
aSunday :: RefAtom
aMonday :: RefAtom
aTuesday :: RefAtom
aWednesday :: RefAtom
aThursday :: RefAtom
aFriday :: RefAtom
aSaturday :: RefAtom
data CalendarTime
CalendarTime :: R Int -> R Month -> R Int -> R Int -> R Int -> R Int -> R Integer -> R Day -> R Int -> R String -> R Int -> R Bool -> CalendarTime
bctYear :: CalendarTime -> R Int
bctMonth :: CalendarTime -> R Month
bctDay :: CalendarTime -> R Int
bctHour :: CalendarTime -> R Int
bctMin :: CalendarTime -> R Int
bctSec :: CalendarTime -> R Int
bctPicosec :: CalendarTime -> R Integer
bctWDay :: CalendarTime -> R Day
bctYDay :: CalendarTime -> R Int
bctTZName :: CalendarTime -> R String
bctTZ :: CalendarTime -> R Int
bctIsDST :: CalendarTime -> R Bool
gctYear :: RefSrcPos -> RefExp -> R (Fun CalendarTime Int)
gctMonth :: RefSrcPos -> RefExp -> R (Fun CalendarTime Month)
gctDay :: RefSrcPos -> RefExp -> R (Fun CalendarTime Int)
gctHour :: RefSrcPos -> RefExp -> R (Fun CalendarTime Int)
gctMin :: RefSrcPos -> RefExp -> R (Fun CalendarTime Int)
gctSec :: RefSrcPos -> RefExp -> R (Fun CalendarTime Int)
gctPicosec :: RefSrcPos -> RefExp -> R (Fun CalendarTime Integer)
gctWDay :: RefSrcPos -> RefExp -> R (Fun CalendarTime Day)
gctYDay :: RefSrcPos -> RefExp -> R (Fun CalendarTime Int)
gctTZName :: RefSrcPos -> RefExp -> R (Fun CalendarTime String)
gctTZ :: RefSrcPos -> RefExp -> R (Fun CalendarTime Int)
gctIsDST :: RefSrcPos -> RefExp -> R (Fun CalendarTime Bool)
hctYear :: R CalendarTime -> RefExp -> R Int
hctMonth :: R CalendarTime -> RefExp -> R Month
hctDay :: R CalendarTime -> RefExp -> R Int
hctHour :: R CalendarTime -> RefExp -> R Int
hctMin :: R CalendarTime -> RefExp -> R Int
hctSec :: R CalendarTime -> RefExp -> R Int
hctPicosec :: R CalendarTime -> RefExp -> R Integer
hctWDay :: R CalendarTime -> RefExp -> R Day
hctYDay :: R CalendarTime -> RefExp -> R Int
hctTZName :: R CalendarTime -> RefExp -> R String
hctTZ :: R CalendarTime -> RefExp -> R Int
hctIsDST :: R CalendarTime -> RefExp -> R Bool
actYear :: RefAtom
actMonth :: RefAtom
actDay :: RefAtom
actHour :: RefAtom
actMin :: RefAtom
actSec :: RefAtom
actPicosec :: RefAtom
actWDay :: RefAtom
actYDay :: RefAtom
actTZName :: RefAtom
actTZ :: RefAtom
actIsDST :: RefAtom
aCalendarTime :: RefAtom
data TimeDiff
TimeDiff :: R Int -> R Int -> R Int -> R Int -> R Int -> R Int -> R Integer -> TimeDiff
btdYear :: TimeDiff -> R Int
btdMonth :: TimeDiff -> R Int
btdDay :: TimeDiff -> R Int
btdHour :: TimeDiff -> R Int
btdMin :: TimeDiff -> R Int
btdSec :: TimeDiff -> R Int
btdPicosec :: TimeDiff -> R Integer
gtdYear :: RefSrcPos -> RefExp -> R (Fun TimeDiff Int)
gtdMonth :: RefSrcPos -> RefExp -> R (Fun TimeDiff Int)
gtdDay :: RefSrcPos -> RefExp -> R (Fun TimeDiff Int)
gtdHour :: RefSrcPos -> RefExp -> R (Fun TimeDiff Int)
gtdMin :: RefSrcPos -> RefExp -> R (Fun TimeDiff Int)
gtdSec :: RefSrcPos -> RefExp -> R (Fun TimeDiff Int)
gtdPicosec :: RefSrcPos -> RefExp -> R (Fun TimeDiff Integer)
htdYear :: R TimeDiff -> RefExp -> R Int
htdMonth :: R TimeDiff -> RefExp -> R Int
htdDay :: R TimeDiff -> RefExp -> R Int
htdHour :: R TimeDiff -> RefExp -> R Int
htdMin :: R TimeDiff -> RefExp -> R Int
htdSec :: R TimeDiff -> RefExp -> R Int
htdPicosec :: R TimeDiff -> RefExp -> R Integer
atdYear :: RefAtom
atdMonth :: RefAtom
atdDay :: RefAtom
atdHour :: RefAtom
atdMin :: RefAtom
atdSec :: RefAtom
atdPicosec :: RefAtom
aTimeDiff :: RefAtom
ggetClockTime :: RefSrcPos -> RefExp -> R (IO ClockTime)
gaddToClockTime :: RefSrcPos -> RefExp -> R (Fun TimeDiff (Fun ClockTime ClockTime))
aaddToClockTime :: RefAtom
haddToClockTime :: R TimeDiff -> R ClockTime -> RefExp -> R ClockTime
gdiffClockTimes :: RefSrcPos -> RefExp -> R (Fun ClockTime (Fun ClockTime TimeDiff))
adiffClockTimes :: RefAtom
hdiffClockTimes :: R ClockTime -> R ClockTime -> RefExp -> R TimeDiff
gtoCalendarTime :: RefSrcPos -> RefExp -> R (Fun ClockTime (IO CalendarTime))
atoCalendarTime :: RefAtom
htoCalendarTime :: R ClockTime -> RefExp -> R (IO CalendarTime)
gtoUTCTime :: RefSrcPos -> RefExp -> R (Fun ClockTime CalendarTime)
atoUTCTime :: RefAtom
htoUTCTime :: R ClockTime -> RefExp -> R CalendarTime
gtoClockTime :: RefSrcPos -> RefExp -> R (Fun CalendarTime ClockTime)
atoClockTime :: RefAtom
htoClockTime :: R CalendarTime -> RefExp -> R ClockTime
gcalendarTimeToString :: RefSrcPos -> RefExp -> R (Fun CalendarTime String)
acalendarTimeToString :: RefAtom
hcalendarTimeToString :: R CalendarTime -> RefExp -> R String
gformatCalendarTime :: RefSrcPos -> RefExp -> R (Fun TimeLocale (Fun String (Fun CalendarTime String)))
aformatCalendarTime :: RefAtom
hformatCalendarTime :: R TimeLocale -> R String -> R CalendarTime -> RefExp -> R String
instance Eq ClockTime
instance Ord ClockTime

module Hat.Data.Char

-- | The character type <a>Char</a> is an enumeration whose values
--   represent Unicode (or equivalently ISO/IEC 10646) characters (see
--   <a>http://www.unicode.org/</a> for details). This set extends the ISO
--   8859-1 (Latin-1) character set (the first 256 characters), which is
--   itself an extension of the ASCII character set (the first 128
--   characters). A character literal in Haskell has type <a>Char</a>.
--   
--   To convert a <a>Char</a> to or from the corresponding <a>Int</a> value
--   defined by Unicode, use <a>toEnum</a> and <a>fromEnum</a> from the
--   <a>Enum</a> class respectively (or equivalently <tt>ord</tt> and
--   <tt>chr</tt>).
data Char :: *
type String = List Char
gisControl :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisControl :: RefAtom
hisControl :: R Char -> RefExp -> R Bool
gisSpace :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisSpace :: RefAtom
hisSpace :: R Char -> RefExp -> R Bool
gisLower :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisLower :: RefAtom
hisLower :: R Char -> RefExp -> R Bool
gisUpper :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisUpper :: RefAtom
hisUpper :: R Char -> RefExp -> R Bool
gisAlpha :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisAlpha :: RefAtom
hisAlpha :: R Char -> RefExp -> R Bool
gisAlphaNum :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisAlphaNum :: RefAtom
hisAlphaNum :: R Char -> RefExp -> R Bool
gisPrint :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisPrint :: RefAtom
hisPrint :: R Char -> RefExp -> R Bool
gisDigit :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisDigit :: RefAtom
hisDigit :: R Char -> RefExp -> R Bool
gisOctDigit :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisOctDigit :: RefAtom
hisOctDigit :: R Char -> RefExp -> R Bool
gisHexDigit :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisHexDigit :: RefAtom
hisHexDigit :: R Char -> RefExp -> R Bool
gisLetter :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisLetter :: RefAtom
hisLetter :: R Char -> RefExp -> R Bool
gisMark :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisMark :: RefAtom
hisMark :: R Char -> RefExp -> R Bool
gisNumber :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisNumber :: RefAtom
hisNumber :: R Char -> RefExp -> R Bool
gisPunctuation :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisPunctuation :: RefAtom
hisPunctuation :: R Char -> RefExp -> R Bool
gisSymbol :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisSymbol :: RefAtom
hisSymbol :: R Char -> RefExp -> R Bool
gisSeparator :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisSeparator :: RefAtom
hisSeparator :: R Char -> RefExp -> R Bool
gisAscii :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisAscii :: RefAtom
hisAscii :: R Char -> RefExp -> R Bool
gisLatin1 :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisLatin1 :: RefAtom
hisLatin1 :: R Char -> RefExp -> R Bool
gisAsciiUpper :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisAsciiUpper :: RefAtom
hisAsciiUpper :: R Char -> RefExp -> R Bool
gisAsciiLower :: RefSrcPos -> RefExp -> R (Fun Char Bool)
aisAsciiLower :: RefAtom
hisAsciiLower :: R Char -> RefExp -> R Bool
data GeneralCategory
UppercaseLetter :: GeneralCategory
LowercaseLetter :: GeneralCategory
TitlecaseLetter :: GeneralCategory
ModifierLetter :: GeneralCategory
OtherLetter :: GeneralCategory
NonSpacingMark :: GeneralCategory
SpacingCombiningMark :: GeneralCategory
EnclosingMark :: GeneralCategory
DecimalNumber :: GeneralCategory
LetterNumber :: GeneralCategory
OtherNumber :: GeneralCategory
ConnectorPunctuation :: GeneralCategory
DashPunctuation :: GeneralCategory
OpenPunctuation :: GeneralCategory
ClosePunctuation :: GeneralCategory
InitialQuote :: GeneralCategory
FinalQuote :: GeneralCategory
OtherPunctuation :: GeneralCategory
MathSymbol :: GeneralCategory
CurrencySymbol :: GeneralCategory
ModifierSymbol :: GeneralCategory
OtherSymbol :: GeneralCategory
Space :: GeneralCategory
LineSeparator :: GeneralCategory
ParagraphSeparator :: GeneralCategory
Control :: GeneralCategory
Format :: GeneralCategory
Surrogate :: GeneralCategory
PrivateUse :: GeneralCategory
NotAssigned :: GeneralCategory
aUppercaseLetter :: RefAtom
aLowercaseLetter :: RefAtom
aTitlecaseLetter :: RefAtom
aModifierLetter :: RefAtom
aOtherLetter :: RefAtom
aNonSpacingMark :: RefAtom
aSpacingCombiningMark :: RefAtom
aEnclosingMark :: RefAtom
aDecimalNumber :: RefAtom
aLetterNumber :: RefAtom
aOtherNumber :: RefAtom
aConnectorPunctuation :: RefAtom
aDashPunctuation :: RefAtom
aOpenPunctuation :: RefAtom
aClosePunctuation :: RefAtom
aInitialQuote :: RefAtom
aFinalQuote :: RefAtom
aOtherPunctuation :: RefAtom
aMathSymbol :: RefAtom
aCurrencySymbol :: RefAtom
aModifierSymbol :: RefAtom
aOtherSymbol :: RefAtom
aSpace :: RefAtom
aLineSeparator :: RefAtom
aParagraphSeparator :: RefAtom
aControl :: RefAtom
aFormat :: RefAtom
aSurrogate :: RefAtom
aPrivateUse :: RefAtom
aNotAssigned :: RefAtom
ggeneralCategory :: RefSrcPos -> RefExp -> R (Fun Char GeneralCategory)
ageneralCategory :: RefAtom
hgeneralCategory :: R Char -> RefExp -> R GeneralCategory
gtoUpper :: RefSrcPos -> RefExp -> R (Fun Char Char)
atoUpper :: RefAtom
htoUpper :: R Char -> RefExp -> R Char
gtoLower :: RefSrcPos -> RefExp -> R (Fun Char Char)
atoLower :: RefAtom
htoLower :: R Char -> RefExp -> R Char
gtoTitle :: RefSrcPos -> RefExp -> R (Fun Char Char)
atoTitle :: RefAtom
htoTitle :: R Char -> RefExp -> R Char
gdigitToInt :: RefSrcPos -> RefExp -> R (Fun Char Int)
adigitToInt :: RefAtom
hdigitToInt :: R Char -> RefExp -> R Int
gintToDigit :: RefSrcPos -> RefExp -> R (Fun Int Char)
aintToDigit :: RefAtom
hintToDigit :: R Int -> RefExp -> R Char
gord :: RefSrcPos -> RefExp -> R (Fun Char Int)
gchr :: RefSrcPos -> RefExp -> R (Fun Int Char)
gshowLitChar :: RefSrcPos -> RefExp -> R (Fun Char ShowS)
ashowLitChar :: RefAtom
hshowLitChar :: R Char -> RefExp -> R ShowS
glexLitChar :: RefSrcPos -> RefExp -> R (ReadS String)
alexLitChar :: RefAtom
hlexLitChar :: R (ReadS___1 String) -> RefExp -> R (ReadS___2 String)
greadLitChar :: RefSrcPos -> RefExp -> R (ReadS Char)
areadLitChar :: RefAtom
hreadLitChar :: R (ReadS___1 Char) -> RefExp -> R (ReadS___2 Char)
instance Ix GeneralCategory
instance Bounded GeneralCategory
instance Show GeneralCategory
instance Read GeneralCategory
instance Enum GeneralCategory
instance Ord GeneralCategory
instance Eq GeneralCategory
instance WrapVal GeneralCategory

module Hat.Array
data Array a b
garray :: Ix a => RefSrcPos -> RefExp -> R (Fun (Tuple2 a a) (Fun (List (Tuple2 a b)) (Array a b)))
aarray :: RefAtom
harray :: Ix a => R (Tuple2 a a) -> R (List (Tuple2 a b)) -> RefExp -> R (Array a b)
glistArray :: Ix a => RefSrcPos -> RefExp -> R (Fun (Tuple2 a a) (Fun (List b) (Array a b)))
alistArray :: RefAtom
hlistArray :: Ix a => R (Tuple2 a a) -> R (List b) -> RefExp -> R (Array a b)
(!!) :: Ix a => RefSrcPos -> RefExp -> R (Fun (Array a b) (Fun a b))
(+!) :: RefAtom
(*!) :: Ix a => R (Array a b) -> RefExp -> R (Fun a b)
gbounds :: Ix a => RefSrcPos -> RefExp -> R (Fun (Array a b) (Tuple2 a a))
abounds :: RefAtom
hbounds :: Ix a => R (Array a b) -> RefExp -> R (Tuple2 a a)
gindices :: Ix a => RefSrcPos -> RefExp -> R (Fun (Array a b) (List a))
gelems :: Ix a => RefSrcPos -> RefExp -> R (Fun (Array a b) (List b))
aelems :: RefAtom
helems :: Ix a => R (Array a b) -> RefExp -> R (List b)
gassocs :: Ix a => RefSrcPos -> RefExp -> R (Fun (Array a b) (List (Tuple2 a b)))
aassocs :: RefAtom
hassocs :: Ix a => R (Array a b) -> RefExp -> R (List (Tuple2 a b))
gaccumArray :: Ix a => RefSrcPos -> RefExp -> R (Fun (Fun b (Fun c b)) (Fun b (Fun (Tuple2 a a) (Fun (List (Tuple2 a c)) (Array a b)))))
aaccumArray :: RefAtom
haccumArray :: Ix a => R (Fun b (Fun c b)) -> R b -> R (Tuple2 a a) -> RefExp -> R (Fun (List (Tuple2 a c)) (Array a b))
(!//) :: Ix a => RefSrcPos -> RefExp -> R (Fun (Array a b) (Fun (List (Tuple2 a b)) (Array a b)))
(+//) :: RefAtom
(*//) :: Ix a => R (Array a b) -> R (List (Tuple2 a b)) -> RefExp -> R (Array a b)
gaccum :: Ix a => RefSrcPos -> RefExp -> R (Fun (Fun b (Fun c b)) (Fun (Array a b) (Fun (List (Tuple2 a c)) (Array a b))))
aaccum :: RefAtom
haccum :: Ix a => R (Fun b (Fun c b)) -> RefExp -> R (Fun (Array a b) (Fun (List (Tuple2 a c)) (Array a b)))
gixmap :: (Ix a, Ix b) => RefSrcPos -> RefExp -> R (Fun (Tuple2 a a) (Fun (Fun a b) (Fun (Array b c) (Array a c))))
aixmap :: RefAtom
hixmap :: (Ix a, Ix b) => R (Tuple2 a a) -> R (Fun a b) -> R (Array b c) -> RefExp -> R (Array a c)
instance (Ix a, Read a, Read b) => Read (Array a b)
instance (Ix a, Show a, Show b) => Show (Array a b)
instance (Ix a, Ord b) => Ord (Array a b)
instance (Ix a, Eq b) => Eq (Array a b)
instance Ix a => Functor (Array a)
instance WrapVal (Array a b)
