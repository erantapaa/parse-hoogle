-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A family of combinators for defining webservices APIs and serving them
--   
@package servant-server
@version 0.4.3.1

module Servant.Server.Internal.ServantErr
data ServantErr
ServantErr :: Int -> String -> ByteString -> [Header] -> ServantErr
errHTTPCode :: ServantErr -> Int
errReasonPhrase :: ServantErr -> String
errBody :: ServantErr -> ByteString
errHeaders :: ServantErr -> [Header]
responseServantErr :: ServantErr -> Response
err300 :: ServantErr
err301 :: ServantErr
err302 :: ServantErr
err303 :: ServantErr
err304 :: ServantErr
err305 :: ServantErr
err307 :: ServantErr
err400 :: ServantErr
err401 :: ServantErr
err402 :: ServantErr
err403 :: ServantErr
err404 :: ServantErr
err405 :: ServantErr
err406 :: ServantErr
err407 :: ServantErr
err409 :: ServantErr
err410 :: ServantErr
err411 :: ServantErr
err412 :: ServantErr
err413 :: ServantErr
err414 :: ServantErr
err415 :: ServantErr
err416 :: ServantErr
err417 :: ServantErr
err500 :: ServantErr
err501 :: ServantErr
err502 :: ServantErr
err503 :: ServantErr
err504 :: ServantErr
err505 :: ServantErr
instance Show ServantErr
instance Eq ServantErr

module Servant.Server.Internal.Enter
class Enter typ arg ret | typ arg -> ret, typ ret -> arg
enter :: Enter typ arg ret => arg -> typ -> ret

-- | A natural transformation from <tt>m</tt> to <tt>n</tt>. Used to
--   <a>enter</a> particular datatypes.
newtype (:~>) m n
Nat :: (forall a. m a -> n a) -> (:~>) m n
unNat :: (:~>) m n -> forall a. m a -> n a

-- | Like <a>lift</a>.
liftNat :: (MonadTrans t, Monad m) => m :~> t m
runReaderTNat :: r -> (ReaderT r m :~> m)
evalStateTLNat :: Monad m => s -> (StateT s m :~> m)
evalStateTSNat :: Monad m => s -> (StateT s m :~> m)

-- | Log the contents of <a>WriterT</a> with the function provided as the
--   first argument, and return the value of the <tt>WriterT</tt>
--   computation
logWriterTSNat :: MonadIO m => (w -> IO ()) -> (WriterT w m :~> m)

-- | Like <a>logWriterTSNat</a>, but for strict <tt>WriterT</tt>.
logWriterTLNat :: MonadIO m => (w -> IO ()) -> (WriterT w m :~> m)
fromExceptT :: ExceptT e m :~> EitherT e m

-- | Like <tt>mmorph</tt>'s <a>hoist</a>.
hoistNat :: (MFunctor t, Monad m) => (m :~> n) -> (t m :~> t n)

-- | Like <tt>mmorph</tt>'s <a>embed</a>.
embedNat :: (MMonad t, Monad n) => (m :~> t n) -> (t m :~> t n)

-- | Like <tt>mmorph</tt>'s <a>squash</a>.
squashNat :: (Monad m, MMonad t) => t (t m) :~> t m

-- | Like <tt>mmorph</tt>'s <a>generalize</a>.
generalizeNat :: Applicative m => Identity :~> m
instance Typeable (:~>)
instance Enter (m a) (m :~> n) (n a)
instance Category (:~>)
instance Enter b arg ret => Enter (a -> b) arg (a -> ret)
instance (Enter typ1 arg1 ret1, Enter typ2 arg2 ret2, arg1 ~ arg2) => Enter (typ1 :<|> typ2) arg1 (ret1 :<|> ret2)

module Servant.Server.Internal
data ReqBodyState
Uncalled :: ReqBodyState
Called :: !ByteString -> ReqBodyState
Done :: !ByteString -> ReqBodyState
toApplication :: RoutingApplication -> Application
data RouteMismatch

-- | the usual "not found" error
NotFound :: RouteMismatch

-- | a more informative "you just got the HTTP method wrong" error
WrongMethod :: RouteMismatch

-- | request body has unsupported media type
UnsupportedMediaType :: RouteMismatch

-- | an even more informative "your json request body wasn't valid" error
InvalidBody :: String -> RouteMismatch

-- | an even even more informative arbitrary HTTP response code error.
HttpError :: Status -> (Maybe ByteString) -> RouteMismatch

-- | A wrapper around <tt><a>Either</a> <a>RouteMismatch</a> a</tt>.
newtype RouteResult a
RR :: Either RouteMismatch a -> RouteResult a
routeResult :: RouteResult a -> Either RouteMismatch a
failWith :: RouteMismatch -> RouteResult a
succeedWith :: a -> RouteResult a
isMismatch :: RouteResult a -> Bool

-- | Like `null . pathInfo`, but works with redundant trailing slashes.
pathIsEmpty :: Request -> Bool

-- | If we get a <a>Right</a>, it has precedence over everything else.
--   
--   This in particular means that if we could get several <a>Right</a>s,
--   only the first we encounter would be taken into account.
type RoutingApplication = Request -> (RouteResult Response -> IO ResponseReceived) -> IO ResponseReceived
splitMatrixParameters :: Text -> (Text, Text)
parsePathInfo :: Request -> [Text]

-- | Returns a processed pathInfo from the request.
--   
--   In order to handle matrix parameters in the request correctly, the raw
--   pathInfo needs to be processed, so routing works as intended. Therefor
--   this function should be used to access the pathInfo for routing
--   purposes.
processedPathInfo :: Request -> [Text]
class HasServer layout where type family ServerT layout (m :: * -> *) :: *
route :: HasServer layout => Proxy layout -> Server layout -> RoutingApplication
type Server layout = ServerT layout (EitherT ServantErr IO)

-- | A server for <tt>a <a>:&lt;|&gt;</a> b</tt> first tries to match the
--   request against the route represented by <tt>a</tt> and if it fails
--   tries <tt>b</tt>. You must provide a request handler for each route.
--   
--   <pre>
--   type MyApi = "books" :&gt; Get '[JSON] [Book] -- GET /books
--           :&lt;|&gt; "books" :&gt; ReqBody Book :&gt; Post '[JSON] Book -- POST /books
--   
--   server :: Server MyApi
--   server = listAllBooks :&lt;|&gt; postBook
--     where listAllBooks = ...
--           postBook book = ...
--   </pre>
captured :: FromText a => proxy (Capture sym a) -> Text -> Maybe a

-- | If you use <a>Capture</a> in one of the endpoints for your API, this
--   automatically requires your server-side handler to be a function that
--   takes an argument of the type specified by the <a>Capture</a>. This
--   lets servant worry about getting it from the URL and turning it into a
--   value of the type you specify.
--   
--   You can control how it'll be converted from <a>Text</a> to your type
--   by simply providing an instance of <a>FromText</a> for your type.
--   
--   Example:
--   
--   <pre>
--   type MyApi = "books" :&gt; Capture "isbn" Text :&gt; Get '[JSON] Book
--   
--   server :: Server MyApi
--   server = getBook
--     where getBook :: Text -&gt; EitherT ServantErr IO Book
--           getBook isbn = ...
--   </pre>

-- | If you have a <a>Delete</a> endpoint in your API, the handler for this
--   endpoint is meant to delete a resource.
--   
--   The code of the handler will, just like for <a>Get</a>, <a>Post</a>
--   and <a>Put</a>, run in <tt>EitherT ServantErr IO ()</tt>. The
--   <a>Int</a> represents the status code and the <a>String</a> a message
--   to be returned. You can use <a>left</a> to painlessly error out if the
--   conditions for a successful deletion are not met.

-- | When implementing the handler for a <a>Get</a> endpoint, just like for
--   <a>Delete</a>, <a>Post</a> and <a>Put</a>, the handler code runs in
--   the <tt>EitherT ServantErr IO</tt> monad, where the <a>Int</a>
--   represents the status code and the <a>String</a> a message, returned
--   in case of failure. You can quite handily use <a>left</a> to quickly
--   fail if some conditions are not met.
--   
--   If successfully returning a value, we use the type-level list,
--   combined with the request's <tt>Accept</tt> header, to encode the
--   value for you (returning a status code of 200). If there was no
--   <tt>Accept</tt> header or it was <tt>*/*</tt>, we return encode using
--   the first <tt>Content-Type</tt> type on the list.

-- | If you use <a>Header</a> in one of the endpoints for your API, this
--   automatically requires your server-side handler to be a function that
--   takes an argument of the type specified by <a>Header</a>. This lets
--   servant worry about extracting it from the request and turning it into
--   a value of the type you specify.
--   
--   All it asks is for a <a>FromText</a> instance.
--   
--   Example:
--   
--   <pre>
--   newtype Referer = Referer Text
--     deriving (Eq, Show, FromText, ToText)
--   
--              -- GET /view-my-referer
--   type MyApi = "view-my-referer" :&gt; Header "Referer" Referer :&gt; Get '[JSON] Referer
--   
--   server :: Server MyApi
--   server = viewReferer
--     where viewReferer :: Referer -&gt; EitherT ServantErr IO referer
--           viewReferer referer = return referer
--   </pre>

-- | When implementing the handler for a <a>Post</a> endpoint, just like
--   for <a>Delete</a>, <a>Get</a> and <a>Put</a>, the handler code runs in
--   the <tt>EitherT ServantErr IO</tt> monad, where the <a>Int</a>
--   represents the status code and the <a>String</a> a message, returned
--   in case of failure. You can quite handily use <a>left</a> to quickly
--   fail if some conditions are not met.
--   
--   If successfully returning a value, we use the type-level list,
--   combined with the request's <tt>Accept</tt> header, to encode the
--   value for you (returning a status code of 201). If there was no
--   <tt>Accept</tt> header or it was <tt>*/*</tt>, we return encode using
--   the first <tt>Content-Type</tt> type on the list.

-- | When implementing the handler for a <a>Put</a> endpoint, just like for
--   <a>Delete</a>, <a>Get</a> and <a>Post</a>, the handler code runs in
--   the <tt>EitherT ServantErr IO</tt> monad, where the <a>Int</a>
--   represents the status code and the <a>String</a> a message, returned
--   in case of failure. You can quite handily use <a>left</a> to quickly
--   fail if some conditions are not met.
--   
--   If successfully returning a value, we use the type-level list,
--   combined with the request's <tt>Accept</tt> header, to encode the
--   value for you (returning a status code of 200). If there was no
--   <tt>Accept</tt> header or it was <tt>*/*</tt>, we return encode using
--   the first <tt>Content-Type</tt> type on the list.

-- | When implementing the handler for a <a>Patch</a> endpoint, just like
--   for <a>Delete</a>, <a>Get</a> and <a>Put</a>, the handler code runs in
--   the <tt>EitherT ServantErr IO</tt> monad, where the <a>Int</a>
--   represents the status code and the <a>String</a> a message, returned
--   in case of failure. You can quite handily use <a>left</a> to quickly
--   fail if some conditions are not met.
--   
--   If successfully returning a value, we just require that its type has a
--   <tt>ToJSON</tt> instance and servant takes care of encoding it for
--   you, yielding status code 200 along the way.

-- | If you use <tt><a>QueryParam</a> "author" Text</tt> in one of the
--   endpoints for your API, this automatically requires your server-side
--   handler to be a function that takes an argument of type
--   <tt><a>Maybe</a> <a>Text</a></tt>.
--   
--   This lets servant worry about looking it up in the query string and
--   turning it into a value of the type you specify, enclosed in
--   <a>Maybe</a>, because it may not be there and servant would then hand
--   you <a>Nothing</a>.
--   
--   You can control how it'll be converted from <a>Text</a> to your type
--   by simply providing an instance of <a>FromText</a> for your type.
--   
--   Example:
--   
--   <pre>
--   type MyApi = "books" :&gt; QueryParam "author" Text :&gt; Get '[JSON] [Book]
--   
--   server :: Server MyApi
--   server = getBooksBy
--     where getBooksBy :: Maybe Text -&gt; EitherT ServantErr IO [Book]
--           getBooksBy Nothing       = ...return all books...
--           getBooksBy (Just author) = ...return books by the given author...
--   </pre>

-- | If you use <tt><a>QueryParams</a> "authors" Text</tt> in one of the
--   endpoints for your API, this automatically requires your server-side
--   handler to be a function that takes an argument of type
--   <tt>[<a>Text</a>]</tt>.
--   
--   This lets servant worry about looking up 0 or more values in the query
--   string associated to <tt>authors</tt> and turning each of them into a
--   value of the type you specify.
--   
--   You can control how the individual values are converted from
--   <a>Text</a> to your type by simply providing an instance of
--   <a>FromText</a> for your type.
--   
--   Example:
--   
--   <pre>
--   type MyApi = "books" :&gt; QueryParams "authors" Text :&gt; Get '[JSON] [Book]
--   
--   server :: Server MyApi
--   server = getBooksBy
--     where getBooksBy :: [Text] -&gt; EitherT ServantErr IO [Book]
--           getBooksBy authors = ...return all books by these authors...
--   </pre>

-- | If you use <tt><a>QueryFlag</a> "published"</tt> in one of the
--   endpoints for your API, this automatically requires your server-side
--   handler to be a function that takes an argument of type <a>Bool</a>.
--   
--   Example:
--   
--   <pre>
--   type MyApi = "books" :&gt; QueryFlag "published" :&gt; Get '[JSON] [Book]
--   
--   server :: Server MyApi
--   server = getBooks
--     where getBooks :: Bool -&gt; EitherT ServantErr IO [Book]
--           getBooks onlyPublished = ...return all books, or only the ones that are already published, depending on the argument...
--   </pre>
parseMatrixText :: ByteString -> QueryText

-- | If you use <tt><a>MatrixParam</a> "author" Text</tt> in one of the
--   endpoints for your API, this automatically requires your server-side
--   handler to be a function that takes an argument of type
--   <tt><a>Maybe</a> <a>Text</a></tt>.
--   
--   This lets servant worry about looking it up in the query string and
--   turning it into a value of the type you specify, enclosed in
--   <a>Maybe</a>, because it may not be there and servant would then hand
--   you <a>Nothing</a>.
--   
--   You can control how it'll be converted from <a>Text</a> to your type
--   by simply providing an instance of <a>FromText</a> for your type.
--   
--   Example:
--   
--   <pre>
--   type MyApi = "books" :&gt; MatrixParam "author" Text :&gt; Get [Book]
--   
--   server :: Server MyApi
--   server = getBooksBy
--     where getBooksBy :: Maybe Text -&gt; EitherT ServantErr IO [Book]
--           getBooksBy Nothing       = ...return all books...
--           getBooksBy (Just author) = ...return books by the given author...
--   </pre>

-- | If you use <tt><a>MatrixParams</a> "authors" Text</tt> in one of the
--   endpoints for your API, this automatically requires your server-side
--   handler to be a function that takes an argument of type
--   <tt>[<a>Text</a>]</tt>.
--   
--   This lets servant worry about looking up 0 or more values in the query
--   string associated to <tt>authors</tt> and turning each of them into a
--   value of the type you specify.
--   
--   You can control how the individual values are converted from
--   <a>Text</a> to your type by simply providing an instance of
--   <a>FromText</a> for your type.
--   
--   Example:
--   
--   <pre>
--   type MyApi = "books" :&gt; MatrixParams "authors" Text :&gt; Get [Book]
--   
--   server :: Server MyApi
--   server = getBooksBy
--     where getBooksBy :: [Text] -&gt; EitherT ServantErr IO [Book]
--           getBooksBy authors = ...return all books by these authors...
--   </pre>

-- | If you use <tt><a>MatrixFlag</a> "published"</tt> in one of the
--   endpoints for your API, this automatically requires your server-side
--   handler to be a function that takes an argument of type <a>Bool</a>.
--   
--   Example:
--   
--   <pre>
--   type MyApi = "books" :&gt; MatrixFlag "published" :&gt; Get [Book]
--   
--   server :: Server MyApi
--   server = getBooks
--     where getBooks :: Bool -&gt; EitherT ServantErr IO [Book]
--           getBooks onlyPublished = ...return all books, or only the ones that are already published, depending on the argument...
--   </pre>

-- | Just pass the request to the underlying application and serve its
--   response.
--   
--   Example:
--   
--   <pre>
--   type MyApi = "images" :&gt; Raw
--   
--   server :: Server MyApi
--   server = serveDirectory "/var/www/images"
--   </pre>

-- | If you use <a>ReqBody</a> in one of the endpoints for your API, this
--   automatically requires your server-side handler to be a function that
--   takes an argument of the type specified by <a>ReqBody</a>. The
--   <tt>Content-Type</tt> header is inspected, and the list provided is
--   used to attempt deserialization. If the request does not have a
--   <tt>Content-Type</tt> header, it is treated as
--   <tt>application/octet-stream</tt>. This lets servant worry about
--   extracting it from the request and turning it into a value of the type
--   you specify.
--   
--   All it asks is for a <tt>FromJSON</tt> instance.
--   
--   Example:
--   
--   <pre>
--   type MyApi = "books" :&gt; ReqBody '[JSON] Book :&gt; Post '[JSON] Book
--   
--   server :: Server MyApi
--   server = postBook
--     where postBook :: Book -&gt; EitherT ServantErr IO Book
--           postBook book = ...insert into your db...
--   </pre>

-- | Make sure the incoming request starts with <tt>"/path"</tt>, strip it
--   and pass the rest of the request path to <tt>sublayout</tt>.
ct_wildcard :: ByteString
instance [overlap ok] Eq RouteMismatch
instance [overlap ok] Ord RouteMismatch
instance [overlap ok] Show RouteMismatch
instance [overlap ok] Eq a => Eq (RouteResult a)
instance [overlap ok] Show a => Show (RouteResult a)
instance [overlap ok] (KnownSymbol path, HasServer sublayout) => HasServer (path :> sublayout)
instance [overlap ok] (AllCTUnrender list a, HasServer sublayout) => HasServer (ReqBody list a :> sublayout)
instance [overlap ok] HasServer Raw
instance [overlap ok] (KnownSymbol sym, HasServer sublayout) => HasServer (MatrixFlag sym :> sublayout)
instance [overlap ok] (KnownSymbol sym, FromText a, HasServer sublayout) => HasServer (MatrixParams sym a :> sublayout)
instance [overlap ok] (KnownSymbol sym, FromText a, HasServer sublayout) => HasServer (MatrixParam sym a :> sublayout)
instance [overlap ok] (KnownSymbol sym, HasServer sublayout) => HasServer (QueryFlag sym :> sublayout)
instance [overlap ok] (KnownSymbol sym, FromText a, HasServer sublayout) => HasServer (QueryParams sym a :> sublayout)
instance [overlap ok] (KnownSymbol sym, FromText a, HasServer sublayout) => HasServer (QueryParam sym a :> sublayout)
instance [overlap ok] (GetHeaders (Headers h v), AllCTRender ctypes v) => HasServer (Patch ctypes (Headers h v))
instance [overlap ok] HasServer (Patch ctypes ())
instance [overlap ok] AllCTRender ctypes a => HasServer (Patch ctypes a)
instance [overlap ok] (GetHeaders (Headers h v), AllCTRender ctypes v) => HasServer (Put ctypes (Headers h v))
instance [overlap ok] HasServer (Put ctypes ())
instance [overlap ok] AllCTRender ctypes a => HasServer (Put ctypes a)
instance [overlap ok] (GetHeaders (Headers h v), AllCTRender ctypes v) => HasServer (Post ctypes (Headers h v))
instance [overlap ok] HasServer (Post ctypes ())
instance [overlap ok] AllCTRender ctypes a => HasServer (Post ctypes a)
instance [overlap ok] (KnownSymbol sym, FromText a, HasServer sublayout) => HasServer (Header sym a :> sublayout)
instance [overlap ok] (GetHeaders (Headers h v), AllCTRender ctypes v) => HasServer (Get ctypes (Headers h v))
instance [overlap ok] HasServer (Get ctypes ())
instance [overlap ok] AllCTRender ctypes a => HasServer (Get ctypes a)
instance [overlap ok] (GetHeaders (Headers h v), AllCTRender ctypes v) => HasServer (Delete ctypes (Headers h v))
instance [overlap ok] HasServer (Delete ctypes ())
instance [overlap ok] AllCTRender ctypes a => HasServer (Delete ctypes a)
instance [overlap ok] (KnownSymbol capture, FromText a, HasServer sublayout) => HasServer (Capture capture a :> sublayout)
instance [overlap ok] (HasServer a, HasServer b) => HasServer (a :<|> b)
instance [overlap ok] Monoid (RouteResult a)
instance [overlap ok] Monoid RouteMismatch


-- | This module lets you implement <a>Server</a>s for defined APIs. You'll
--   most likely just need <a>serve</a>.
module Servant.Server

-- | <a>serve</a> allows you to implement an API and produce a wai
--   <a>Application</a>.
--   
--   Example:
--   
--   <pre>
--   type MyApi = "books" :&gt; Get '[JSON] [Book] -- GET /books
--           :&lt;|&gt; "books" :&gt; ReqBody Book :&gt; Post '[JSON] Book -- POST /books
--   
--   server :: Server MyApi
--   server = listAllBooks :&lt;|&gt; postBook
--     where listAllBooks = ...
--           postBook book = ...
--   
--   myApi :: Proxy MyApi
--   myApi = Proxy
--   
--   app :: Application
--   app = serve myApi server
--   
--   main :: IO ()
--   main = Network.Wai.Handler.Warp.run 8080 app
--   </pre>
serve :: HasServer layout => Proxy layout -> Server layout -> Application
toApplication :: RoutingApplication -> Application
class HasServer layout where type family ServerT layout (m :: * -> *) :: *
route :: HasServer layout => Proxy layout -> Server layout -> RoutingApplication
type Server layout = ServerT layout (EitherT ServantErr IO)
enter :: Enter typ arg ret => arg -> typ -> ret

-- | A natural transformation from <tt>m</tt> to <tt>n</tt>. Used to
--   <a>enter</a> particular datatypes.
newtype (:~>) m n
Nat :: (forall a. m a -> n a) -> (:~>) m n
unNat :: (:~>) m n -> forall a. m a -> n a

-- | Like <a>lift</a>.
liftNat :: (MonadTrans t, Monad m) => m :~> t m
runReaderTNat :: r -> (ReaderT r m :~> m)
evalStateTLNat :: Monad m => s -> (StateT s m :~> m)
evalStateTSNat :: Monad m => s -> (StateT s m :~> m)

-- | Like <a>logWriterTSNat</a>, but for strict <tt>WriterT</tt>.
logWriterTLNat :: MonadIO m => (w -> IO ()) -> (WriterT w m :~> m)

-- | Log the contents of <a>WriterT</a> with the function provided as the
--   first argument, and return the value of the <tt>WriterT</tt>
--   computation
logWriterTSNat :: MonadIO m => (w -> IO ()) -> (WriterT w m :~> m)
fromExceptT :: ExceptT e m :~> EitherT e m

-- | Like <tt>mmorph</tt>'s <a>hoist</a>.
hoistNat :: (MFunctor t, Monad m) => (m :~> n) -> (t m :~> t n)

-- | Like <tt>mmorph</tt>'s <a>embed</a>.
embedNat :: (MMonad t, Monad n) => (m :~> t n) -> (t m :~> t n)

-- | Like <tt>mmorph</tt>'s <a>squash</a>.
squashNat :: (Monad m, MMonad t) => t (t m) :~> t m

-- | Like <tt>mmorph</tt>'s <a>generalize</a>.
generalizeNat :: Applicative m => Identity :~> m
data ServantErr
ServantErr :: Int -> String -> ByteString -> [Header] -> ServantErr
errHTTPCode :: ServantErr -> Int
errReasonPhrase :: ServantErr -> String
errBody :: ServantErr -> ByteString
errHeaders :: ServantErr -> [Header]
err300 :: ServantErr
err301 :: ServantErr
err302 :: ServantErr
err303 :: ServantErr
err304 :: ServantErr
err305 :: ServantErr
err307 :: ServantErr
err400 :: ServantErr
err401 :: ServantErr
err402 :: ServantErr
err403 :: ServantErr
err404 :: ServantErr
err405 :: ServantErr
err406 :: ServantErr
err407 :: ServantErr
err409 :: ServantErr
err410 :: ServantErr
err411 :: ServantErr
err412 :: ServantErr
err413 :: ServantErr
err414 :: ServantErr
err415 :: ServantErr
err416 :: ServantErr
err417 :: ServantErr
err500 :: ServantErr
err501 :: ServantErr
err502 :: ServantErr
err503 :: ServantErr
err504 :: ServantErr
err505 :: ServantErr


-- | This module defines a sever-side handler that lets you serve static
--   files.
--   
--   <ul>
--   <li><a>serveDirectory</a> lets you serve anything that lives under a
--   particular directory on your filesystem.</li>
--   </ul>
module Servant.Utils.StaticFiles

-- | Serve anything under the specified directory as a <a>Raw</a> endpoint.
--   
--   <pre>
--   type MyApi = "static" :&gt; Raw
--   
--   server :: Server MyApi
--   server = serveDirectory "/var/www"
--   </pre>
--   
--   would capture any request to <tt>/static/&lt;something&gt;</tt> and
--   look for <tt>&lt;something&gt;</tt> under <tt>/var/www</tt>.
--   
--   It will do its best to guess the MIME type for that file, based on the
--   extension, and send an appropriate <i>Content-Type</i> header if
--   possible.
--   
--   If your goal is to serve HTML, CSS and Javascript files that use the
--   rest of the API as a webapp backend, you will most likely not want the
--   static files to be hidden behind a <i>/static/</i> prefix. In that
--   case, remember to put the <a>serveDirectory</a> handler in the last
--   position, because <i>servant</i> will try to match the handlers in
--   order.
serveDirectory :: FilePath -> Server Raw

module Servant

-- | A concrete, poly-kinded proxy type
data Proxy (t :: k) :: k -> *
Proxy :: Proxy
