-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | NationStates API client
--   
@package nationstates
@version 0.1.0.2


-- | Simple rate limiting combinator.
module NationStates.RateLimit
data RateLimit

-- | Create a new rate limiter with the specified delay.
--   
--   The rate limiter is thread-safe, and can be shared between threads.
newRateLimit :: TimeSpec -> IO RateLimit

-- | Run the given action, pausing as necessary to keep under the rate
--   limit.
rateLimit :: RateLimit -> IO a -> IO a


-- | Data structures used by NationStates.
module NationStates.Types

-- | Nation category.
--   
--   This datum summarizes a nation's personal, economic, and political
--   freedoms.
data WACategory
Anarchy :: WACategory
AuthoritarianDemocracy :: WACategory
BenevolentDictatorship :: WACategory
CapitalistParadise :: WACategory
Capitalizt :: WACategory
CivilRightsLovefest :: WACategory
CompulsoryConsumeristState :: WACategory
ConservativeDemocracy :: WACategory
CorporateBordello :: WACategory
CorporatePoliceState :: WACategory
CorruptDictatorship :: WACategory
DemocraticSocialists :: WACategory

-- | This category has two variations: "<i>Father</i> Knows Best State" and
--   "<i>Mother</i> Knows Best State".
FatherKnowsBestState :: FatherOrMother -> WACategory
FreeMarketParadise :: WACategory
InoffensiveCentristDemocracy :: WACategory
IronFistConsumerists :: WACategory
IronFistSocialists :: WACategory
LeftLeaningCollegeState :: WACategory
LeftWingUtopia :: WACategory
LiberalDemocraticSocialists :: WACategory
LibertarianPoliceState :: WACategory
MoralisticDemocracy :: WACategory
NewYorkTimesDemocracy :: WACategory
PsychoticDictatorship :: WACategory
RightWingUtopia :: WACategory
ScandinavianLiberalParadise :: WACategory
TyrannyByMajority :: WACategory

-- | Differentiates between a <i>Father</i> or <i>Mother</i> Knows Best
--   State.
data FatherOrMother
Father :: FatherOrMother
Mother :: FatherOrMother
readWACategory :: String -> Maybe WACategory
showWACategory :: WACategory -> String
readWAVote :: String -> Maybe (Maybe Bool)
showWAVote :: Maybe Bool -> String
instance Eq FatherOrMother
instance Ord FatherOrMother
instance Read FatherOrMother
instance Show FatherOrMother
instance Eq WACategory
instance Ord WACategory
instance Read WACategory
instance Show WACategory


-- | Low-level tools for querying the NationStates API.
--   
--   Most of the time, you should use the high-level wrappers in e.g.
--   <a>NationStates.Nation</a> instead. But if you need something not
--   provided by these wrappers, then feel free to use this module
--   directly.
module NationStates.Core

-- | A request to the NationStates API.
--   
--   <ul>
--   <li>Construct an <tt>NS</tt> using <a>makeNS</a> or
--   <a>makeNS'</a>.</li>
--   <li>Compose <tt>NS</tt> values using the <a>Applicative</a>
--   interface.</li>
--   <li>Execute an <tt>NS</tt> using <a>requestNS</a>.</li>
--   </ul>
--   
--   This type wraps a query string, along with a function that parses the
--   response. The funky type machinery keeps these two parts in sync, as
--   long as you stick to the <a>Applicative</a> interface.
--   
--   <pre>
--   type NS a = (<a>Query</a>, Query -&gt; <a>Element</a> -&gt; a)
--   </pre>
type NS = Compose ((,) Query) (Compose ((->) Query) ((->) Element))

-- | Construct a request for a single shard.
--   
--   For example, this code requests the <a>"motto"</a> shard:
--   
--   <pre>
--   motto :: NS String
--   motto = makeNS "motto" Nothing "MOTTO"
--   </pre>
--   
--   For more complex requests (e.g. nested elements), try <a>makeNS'</a>
--   instead.
makeNS :: String -> String -> NS String

-- | Construct a request for a single shard.
makeNS' :: String -> Maybe Integer -> [(String, String)] -> (Query -> Element -> a) -> NS a

-- | Perform a request on the NationStates API.
requestNS :: Maybe (String, String) -> NS a -> Context -> IO a

-- | The version of the NationStates API used by this package.
--   
--   Every request to NationStates includes this number. This means that if
--   the response format changes, existing code will continue to work under
--   the old API.
--   
--   This number should match the current API version, as given by
--   <a>https://www.nationstates.net/cgi-bin/api.cgi?a=version</a>. If not,
--   please file an issue.
apiVersion :: Integer

-- | Keeps track of the set of shards to request.
data Query
Query :: Map String (Set (Maybe Integer)) -> Map String String -> Query
queryShards :: Query -> Map String (Set (Maybe Integer))
queryOptions :: Query -> Map String String

-- | Keeps track of rate limits and TLS connections.
--   
--   You should create a single <a>Context</a> at the start of your
--   program, then share it between multiple threads and requests.
data Context
Context :: Manager -> (forall a. IO a -> IO a) -> String -> Context
contextManager :: Context -> Manager
contextRateLimit :: Context -> forall a. IO a -> IO a
contextUserAgent :: Context -> String

-- | Split a list by the given predicate, dropping empty sublists.
--   
--   <pre>
--   &gt;&gt;&gt; wordsBy (== ',') "the_vines,motesardo-east_adanzi,yellowapple"
--   ["the_vines", "montesardo-east_adanzi", "yellowapple"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; wordsBy (== ',') ""
--   []
--   </pre>
wordsBy :: (a -> Bool) -> [a] -> [[a]]

-- | Parse a string using the <a>Read</a> instance. Succeeds if there is
--   exactly one valid result.
--   
--   <i>Since: 4.6.0.0</i>
readMaybe :: Read a => String -> Maybe a

-- | Parse an input string using the given parser function.
--   
--   If parsing fails, raise an <a>error</a>.
--   
--   <pre>
--   &gt;&gt;&gt; expect "integer" readMaybe "42" :: Integer
--   42
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; expect "integer" readMaybe "butts" :: Integer
--   *** Exception: invalid integer: "butts"
--   </pre>
expect :: String -> (String -> Maybe a) -> String -> a

-- | Raise an <a>error</a>.
--   
--   <pre>
--   &gt;&gt;&gt; expected "integer" "butts"
--   *** Exception: invalid integer: "butts"
--   </pre>
expected :: String -> String -> a
instance Show Query
instance Monoid Query


-- | The Nation API.
--   
--   This module should be imported qualified, to prevent name clashes:
--   
--   <pre>
--   import NationStates
--   import qualified NationStates.Nation as Nation
--   </pre>
--   
--   In general, this module follows the terminology used in the
--   <a>official documentation</a>, except when it clashes with Haskell
--   keywords. For instance, the <tt>type</tt> shard has been renamed to
--   <a>type_</a>.
--   
--   Here's a short example:
--   
--   <pre>
--   import NationStates
--   import qualified NationStates.Nation as Nation
--   import Text.Printf
--   
--   main = <a>withContext</a> "ExampleBot/2000" $ \c -&gt; do
--       (name, motto) &lt;- Nation.<a>run</a> "Montesardo-East Adanzi"
--           ((,) &lt;$&gt; Nation.<a>name</a> &lt;*&gt; Nation.<a>motto</a>) c
--       printf "%s has the motto: %s\n" name motto
--   </pre>
module NationStates.Nation

-- | A request to the Nation API.
newtype Nation a
Nation :: NS a -> Nation a
unNation :: Nation a -> NS a

-- | Perform a request to the Nation API.
run :: String -> Nation a -> Context -> IO a

-- | Short name.
--   
--   <pre>
--   "Testlandia"
--   </pre>
name :: Nation String

-- | Full name, including pre-title.
--   
--   <pre>
--   "The Republic of Testlandia"
--   </pre>
fullname :: Nation String

-- | Nation type.
--   
--   <pre>
--   "Republic"
--   </pre>
type_ :: Nation String

-- | Motto.
--   
--   <pre>
--   "It's a feature!"
--   </pre>
motto :: Nation String

-- | Nation category.
--   
--   <pre>
--   InoffensiveCentristDemocracy
--   </pre>
category :: Nation WACategory

-- | Whether the nation is in the World Assembly.
--   
--   <pre>
--   True
--   </pre>
wa :: Nation Bool

-- | List of endorsements received.
--   
--   <pre>
--   ["jlink","translenia","the_vines"]
--   </pre>
endorsements :: Nation [String]

-- | General assembly vote.
--   
--   <pre>
--   Just True
--   </pre>
gavote :: Nation (Maybe Bool)

-- | Security council vote.
--   
--   <pre>
--   Nothing
--   </pre>
scvote :: Nation (Maybe Bool)

-- | Description of civil rights, economy, and political freedoms.
--   
--   <pre>
--   ("Excellent","Strong","Very Good")
--   </pre>
freedom :: Nation (String, String, String)

-- | Resident region.
--   
--   <pre>
--   "Testregionia"
--   </pre>
region :: Nation String

-- | Population, in millions.
--   
--   <pre>
--   25764
--   </pre>
population :: Nation Integer

-- | Income tax, percent.
--   
--   <pre>
--   83.6
--   </pre>
tax :: Nation Double

-- | National animal.
--   
--   <pre>
--   "sea-snake"
--   </pre>
animal :: Nation String

-- | A short phrase describing the animal.
--   
--   <pre>
--   "is also the nation's favorite main course"
--   </pre>
animaltrait :: Nation String

-- | Currency.
--   
--   <pre>
--   "☆star☆"
--   </pre>
currency :: Nation String

-- | Flag URL.
--   
--   <pre>
--   "http://www.nationstates.net/images/flags/Switzerland.png"
--   </pre>
flag :: Nation String

-- | A suitable banner for this nation.
--   
--   <pre>
--   "v1"
--   </pre>
banner :: Nation String

-- | A list of suitable banners for this nation.
--   
--   <pre>
--   ["v1","o4","b14","t23","m3"]
--   </pre>
banners :: Nation [String]

-- | Query today's census.
--   
--   Returns the current census ID, along with its value.
--   
--   <pre>
--   (24,6.0)
--   </pre>
censusscore :: Nation (Integer, Double)

-- | Query a census by its census ID.
--   
--   <pre>
--   94.0
--   </pre>
censusscore' :: Integer -> Nation Double
instance Functor Nation
instance Applicative Nation


-- | The Region API.
--   
--   This module should be imported qualified, to prevent name clashes:
--   
--   <pre>
--   import NationStates
--   import qualified NationStates.Region as Region
--   </pre>
--   
--   In general, this module follows the terminology used in the
--   <a>official documentation</a>.
--   
--   Here's a short example:
--   
--   <pre>
--   import NationStates
--   import qualified NationStates.Region as Region
--   import Text.Printf
--   
--   main = <a>withContext</a> "ExampleBot/2000" $ \c -&gt; do
--       (name, numnations, delegate) &lt;- Region.<a>run</a> "Pony Lands"
--           ((,,) &lt;$&gt; Region.<a>name</a> &lt;*&gt; Region.<a>numnations</a> &lt;*&gt; Region.<a>delegate</a>) c
--       printf "%s has %d nations. Its delegate is %s\n" name numnations delegate
--   </pre>
module NationStates.Region

-- | A request to the Region API.
newtype Region a
Region :: NS a -> Region a
unRegion :: Region a -> NS a

-- | Perform a request to the Region API.
run :: String -> Region a -> Context -> IO a

-- | Region name.
--   
--   <pre>
--   "Pony Lands"
--   </pre>
name :: Region String

-- | Factbook, in BBCode format.
--   
--   <pre>
--   "[b]We&amp;#39;ve got ponies, therefore your argument is invalid..."
--   </pre>
factbook :: Region String

-- | Number of nations in the region.
--   
--   <pre>
--   112
--   </pre>
numnations :: Region Integer

-- | List of nations in the region.
--   
--   <pre>
--   ["urmanian","enatai","unfitting_doors","lykosia","trotterdam"]
--   </pre>
nations :: Region [String]

-- | Region delegate.
--   
--   <pre>
--   "princess_luna"
--   </pre>
delegate :: Region String
instance Functor Region
instance Applicative Region

module NationStates

-- | Keeps track of rate limits and TLS connections.
--   
--   You should create a single <a>Context</a> at the start of your
--   program, then share it between multiple threads and requests.
data Context

-- | Create a <a>Context</a>, and pass it to the provided function.
--   
--   The <a>Context</a> will be closed automatically when the function
--   returns.
withContext :: String -> (Context -> IO a) -> IO a
