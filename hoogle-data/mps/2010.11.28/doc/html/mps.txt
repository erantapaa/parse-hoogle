-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | simply oo
--   
--   DSL that allows one to write Haskell from left to right
@package mps
@version 2010.11.28

module MPS.TH
here :: QuasiQuoter

module MPS.Light
(.) :: a -> (a -> b) -> b
(>) :: Category cat => cat a b -> cat b c -> cat a c
(<) :: Category cat => cat b c -> cat a b -> cat a c
(^) :: Functor f => f a -> (a -> b) -> f b
(/) :: FilePath -> FilePath -> FilePath
(-) :: (a -> b) -> a -> b
(<->) :: Num a => a -> a -> a
join :: [a] -> [[a]] -> [a]
join' :: [[a]] -> [a]
first, fifth, forth, third, second :: [a] -> a
sixth, tenth, ninth, eighth, seventh :: [a] -> a
unique :: Ord a => [a] -> [a]
is_unique :: Ord a => [a] -> Bool
same :: Ord a => [a] -> Bool
times :: b -> Int -> [b]
upto :: Enum a => a -> a -> [a]
downto :: (Num t, Enum t) => t -> t -> [t]
remove_at :: Int -> [a] -> [a]
insert_at, replace_at :: Int -> a -> [a] -> [a]
at :: Int -> [a] -> a
slice :: Int -> Int -> [a] -> [a]
cherry_pick :: [Int] -> [a] -> [a]
reduce, reduce' :: (a -> a -> a) -> [a] -> a
inject, inject' :: Foldable t => a -> (a -> b -> a) -> t b -> a
none_of :: (a -> Bool) -> [a] -> Bool
select, reject :: (a -> Bool) -> [a] -> [a]
inner_map :: (a -> b) -> [[a]] -> [[b]]
inner_reduce :: (a -> a -> a) -> [[a]] -> [a]
inner_inject :: Foldable t => a -> (a -> b -> a) -> [t b] -> [a]
label_by :: (a -> c) -> [a] -> [(c, a)]
labeling :: (a -> c') -> [a] -> [(a, c')]
in_group_of :: Int -> [t] -> [[t]]
split_to :: Int -> [a] -> [[a]]
apply, send_to :: a -> (a -> b) -> b
let_receive :: (a -> b -> c) -> b -> a -> c
map_send_to :: a -> [a -> b] -> [b]
belongs_to :: (Foldable t, Eq a) => t a -> a -> Bool
has :: (Foldable t, Eq b) => b -> t b -> Bool
indexed :: (Num t, Enum t) => [b] -> [(t, b)]
map_with_index :: (Num t, Enum t) => ((t, b) -> b1) -> [b] -> [b1]
ljust, rjust :: Int -> a -> [a] -> [a]
ub, lb :: (a -> Bool) -> [a] -> [a]
between :: (a -> Bool) -> (a -> Bool) -> [a] -> [a]
not_null :: [a] -> Bool
powerslice :: [a] -> [[a]]
common :: Ord a => [a] -> [a] -> [a]
rsort :: Ord a => [a] -> [a]
encode :: Eq a => [a] -> [(Int, a)]
decode :: [(Int, a)] -> [a]
only_one :: [a] -> Bool
concat_map :: (a -> [b]) -> [a] -> [b]
to_list :: Foldable t => t a -> [a]
to_set :: Ord a => [a] -> Set a
to_h :: Ord k => [(k, a)] -> Map k a
to_a :: [a] -> Array Int a
to_a' :: Ix i => (i, i) -> [e] -> Array i e
hist :: (Num e, Ix i) => (i, i) -> [i] -> Array i e
compare_by :: Ord b => (a -> b) -> a -> a -> Ordering
eq, aren't, isn't, is_not, is :: Eq a => a -> a -> Bool
swap :: (a, b) -> (b, a)
tuple2 :: [a] -> (a, a)
tuple3 :: [a] -> (a, a, a)
list2 :: (a, a) -> [a]
list3 :: (a, a, a) -> [a]
filter_fst :: (a -> Bool) -> [(a, b)] -> [(a, b)]
filter_snd :: (b -> Bool) -> [(a, b)] -> [(a, b)]
only_fst :: [(a, b)] -> [a]
only_snd :: [(a, b)] -> [b]
map_fst :: (a -> b) -> [(a, c)] -> [(b, c)]
map_snd :: (a -> b) -> [(c, a)] -> [(c, b)]
pair :: ((a, b) -> c) -> a -> b -> c
triple :: ((a, b, c) -> d) -> a -> b -> c -> d
splash :: (a -> b -> c) -> (a, b) -> c
splash3 :: (a -> b -> c -> d) -> (a, b, c) -> d
twin :: a -> (a, a)
from_i :: (Integral a, Num b) => a -> b
explode :: Show a => a -> [Int]
lower, upper :: String -> String
starts_with, ends_with :: String -> String -> Bool
capitalize :: String -> String
to_s :: Show a => a -> String
is_palindrom :: Eq a => [a] -> Bool
trace' :: Show a => a -> a

module MPS.Extra
p_eval, p_eval' :: [a] -> [a]
p_reduce, p_reduce' :: (a -> a -> a) -> [a] -> a
p_map, p_map' :: (a -> b) -> [a] -> [b]
p_split_to :: Int -> [t] -> [[t]]
p_map_reduce_to :: Int -> ([a] -> b) -> (b -> b -> b) -> [a] -> b
p_map_reduce :: ([a] -> b) -> (b -> b -> b) -> [a] -> b
date :: Integer -> Int -> Int -> Day
splash_date :: Day -> (Integer, Int, Int)
split_raw :: String -> String -> [String]
split :: String -> String -> [String]
split' :: String -> [String]
sub :: String -> String -> String -> String
gsub :: String -> String -> String -> String
type RegexResult = (String, (String, String))
type MatchList = [(Int, String)]
match :: String -> String -> Maybe (RegexResult, MatchList)
strip :: String -> String
empty :: String -> Bool
collapse :: (Integral a, Num b) => [a] -> b
base :: Integral a => a -> a -> String
camel_case, snake_case :: String -> String
purify :: IO a -> a
ls :: String -> IO [String]
file_size :: String -> IO Integer
file_mtime :: String -> IO UTCTime
read_binary_file :: String -> IO String
get_permissions :: String -> IO Permissions
get_current_directory :: IO String
now :: IO UTCTime
format_time :: String -> UTCTime -> String
simple_time_format :: String
parse_time :: String -> String -> UTCTime
t2i :: UTCTime -> Integer
t2f :: Fractional a => UTCTime -> a
i2t :: Integer -> UTCTime
f2t :: Real a => a -> UTCTime
filter_comment :: String -> String
b2u, u2b :: String -> String

module MPS.Env

module MPS.Heavy
parse :: GenParser tok () a -> [tok] -> a
unescape_xml, escape_xml :: String -> String
unescape_unicode_xml, escape_unicode_xml :: String -> String

module MPS

module MPSUTF8
read_file :: String -> IO String
write_file :: String -> String -> IO ()
ls :: String -> IO [String]
mkdir_p :: String -> IO ()
file_exist :: String -> IO Bool
dir_exist :: String -> IO Bool
split :: String -> String -> [String]
gsub :: String -> String -> String -> String
sub :: String -> String -> String -> String
match :: String -> String -> Maybe (RegexResult, MatchList)
strip :: String -> String
rm :: String -> IO ()
rm_rf :: String -> IO ()
