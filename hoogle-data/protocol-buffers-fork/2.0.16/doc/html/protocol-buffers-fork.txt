-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Parse Google Protocol Buffer specifications
--   
--   Parse proto files and generate Haskell code. This is a fork of the
--   protocol-buffers library at
--   http:<i></i>hackage.haskell.org<i>package</i>protocol-buffers
@package protocol-buffers-fork
@version 2.0.16


-- | By Chris Kuklewicz, drawing heavily from binary and binary-strict, but
--   all the bugs are my own.
--   
--   This file is under the usual BSD3 licence, copyright 2008.
--   
--   Modified the monad to be strict for version 2.0.0
--   
--   This started out as an improvement to
--   <a>Data.Binary.Strict.IncrementalGet</a> with slightly better
--   internals. The simplified <a>Get</a>, <a>runGet</a>, <a>Result</a>
--   trio with the <a>Data.Binary.Strict.Class.BinaryParser</a> instance
--   are an _untested_ upgrade from IncrementalGet. Especially untested are
--   the strictness properties.
--   
--   <a>Get</a> usefully implements Applicative and Monad, MonadError,
--   Alternative and MonadPlus. Unhandled errors are reported along with
--   the number of bytes successfully consumed. Effects of <a>suspend</a>
--   and <a>putAvailable</a> are visible after fail<i>throwError</i>mzero.
--   
--   Each time the parser reaches the end of the input it will return a
--   Partial wrapped continuation which requests a (Maybe Lazy.ByteString).
--   Passing (Just bs) will append bs to the input so far and continue
--   processing. If you pass Nothing to the continuation then you are
--   declaring that there will never be more input and that the parser
--   should never again return a partial contination; it should return
--   failure or finished.
--   
--   <a>suspendUntilComplete</a> repeatedly uses a partial continuation to
--   ask for more input until <a>Nothing</a> is passed and then it proceeds
--   with parsing.
--   
--   The <a>getAvailable</a> command returns the lazy byte string the
--   parser has remaining before calling <a>suspend</a>. The
--   <a>putAvailable</a> replaces this input and is a bit fancy: it also
--   replaces the input at the current offset for all the potential
--   catchError/mplus handlers. This change is _not_ reverted by
--   fail<i>throwError</i>mzero.
--   
--   The three <a>lookAhead</a> and <a>lookAheadM</a> and <a>lookAheadE</a>
--   functions are very similar to the ones in binary's Data.Binary.Get.
--   
--   Add specialized high-bit-run
module Text.ProtocolBuffers.Get
data Get a

-- | <a>runGet</a> is the simple executor
runGet :: Get a -> ByteString -> Result a

-- | <a>runGetAll</a> is the simple executor, and will not ask for any
--   continuation because this lazy bytestring is all the input
runGetAll :: Get a -> ByteString -> Result a
data Result a
Failed :: {-# UNPACK #-} !Int64 -> String -> Result a
Finished :: !ByteString -> {-# UNPACK #-} !Int64 -> a -> Result a
Partial :: (Maybe ByteString -> Result a) -> Result a

-- | check that there are at least <tt>n</tt> bytes available in the input.
--   This will suspend if there is to little data.
ensureBytes :: Int64 -> Get ()
getStorable :: Storable a => Get a

-- | Pull <tt>n</tt> bytes from the input, as a lazy ByteString. This will
--   suspend if there is too little data.
getLazyByteString :: Int64 -> Get ByteString

-- | Keep calling <a>suspend</a> until Nothing is passed to the
--   <a>Partial</a> continuation. This ensures all the data has been loaded
--   into the state of the parser.
suspendUntilComplete :: Get ()

-- | Get the input currently available to the parser.
getAvailable :: Get ByteString

-- | <a>putAvailable</a> replaces the bytestream past the current # of read
--   bytes. This will also affect pending MonadError handler and MonadPlus
--   branches. I think all pending branches have to have fewer bytesRead
--   than the current one. If this is wrong then an error will be thrown.
--   
--   WARNING : <a>putAvailable</a> is still untested.
putAvailable :: ByteString -> Get ()

-- | <a>lookAhead</a> runs the <tt>todo</tt> action and then rewinds only
--   the BinaryParser state. Any new input from <a>suspend</a> or changes
--   from <a>putAvailable</a> are kept. Changes to the user state
--   (MonadState) are kept. The MonadWriter output is retained.
--   
--   If an error is thrown then the entire monad state is reset to last
--   catchError as usual.
lookAhead :: Get a -> Get a

-- | <a>lookAheadM</a> runs the <tt>todo</tt> action. If the action returns
--   <a>Nothing</a> then the BinaryParser state is rewound (as in
--   <a>lookAhead</a>). If the action return <a>Just</a> then the
--   BinaryParser is not rewound, and lookAheadM acts as an identity.
--   
--   If an error is thrown then the entire monad state is reset to last
--   catchError as usual.
lookAheadM :: Get (Maybe a) -> Get (Maybe a)

-- | <a>lookAheadE</a> runs the <tt>todo</tt> action. If the action returns
--   <a>Left</a> then the BinaryParser state is rewound (as in
--   <a>lookAhead</a>). If the action return <a>Right</a> then the
--   BinaryParser is not rewound, and lookAheadE acts as an identity.
--   
--   If an error is thrown then the entire monad state is reset to last
--   catchError as usual.
lookAheadE :: Get (Either a b) -> Get (Either a b)

-- | Discard the next <tt>m</tt> bytes
skip :: Int64 -> Get ()

-- | Return the number of <a>bytesRead</a> so far. Initially 0, never
--   negative.
bytesRead :: Get Int64

-- | Return True if the number of bytes <a>remaining</a> is 0. Any futher
--   attempts to read an empty parser will call <a>suspend</a> which might
--   result in more input to consume.
--   
--   Compare with <a>isReallyEmpty</a>
isEmpty :: Get Bool

-- | Return True if the input is exhausted and will never be added to.
--   Returns False if there is input left to consume.
--   
--   Compare with <a>isEmpty</a>
isReallyEmpty :: Get Bool

-- | Return the number of bytes <a>remaining</a> before the current input
--   runs out and <a>suspend</a> might be called.
remaining :: Get Int64

-- | get the longest prefix of the input where all the bytes satisfy the
--   predicate.
spanOf :: (Word8 -> Bool) -> Get (ByteString)

-- | get the longest prefix of the input where the high bit is set as well
--   as following byte. This made getVarInt slower.
highBitRun :: Get Int64
getWord8 :: Get Word8

-- | Pull <tt>n</tt> bytes from the input, as a strict ByteString. This
--   will suspend if there is too little data. If the result spans multiple
--   lazy chunks then the result occupies a freshly allocated strict
--   bytestring, otherwise it fits in a single chunk and refers to the same
--   immutable memory block as the whole chunk.
getByteString :: Int -> Get ByteString
getWord16be :: Get Word16
getWord32be :: Get Word32
getWord64be :: Get Word64
getWord16le :: Get Word16
getWord32le :: Get Word32
getWord64le :: Get Word64
getWordhost :: Get Word
getWord16host :: Get Word16
getWord32host :: Get Word32
getWord64host :: Get Word64
decode7 :: (Integral s, Bits s) => Get s
decode7size :: Get Int64
decode7unrolled :: (Num s, Integral s, Bits s) => Get s
instance Show S
instance Alternative Get
instance Applicative Get
instance MonadPlus Get
instance MonadError String Get
instance Monad Get
instance Functor Get
instance MonadSuspend Get
instance Show (FrameStack b)
instance Show a => Show (Result a)


-- | <a>Text.ProtocolBuffers.Basic</a> defines or re-exports most of the
--   basic field types; <a>Maybe</a>,<a>Bool</a>, <a>Double</a>, and
--   <a>Float</a> come from the Prelude instead. This module also defined
--   the <a>Mergeable</a> and <a>Default</a> classes. The <tt>Wire</tt>
--   class is not defined here to avoid orphans.
module Text.ProtocolBuffers.Basic

-- | Double-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   double-precision type.
data Double :: *

-- | Single-precision floating point numbers. It is desirable that this
--   type be at least equal in range and precision to the IEEE
--   single-precision type.
data Float :: *
data Bool :: *

-- | The <a>Maybe</a> type encapsulates an optional value. A value of type
--   <tt><a>Maybe</a> a</tt> either contains a value of type <tt>a</tt>
--   (represented as <tt><a>Just</a> a</tt>), or it is empty (represented
--   as <a>Nothing</a>). Using <a>Maybe</a> is a good way to deal with
--   errors or exceptional cases without resorting to drastic measures such
--   as <a>error</a>.
--   
--   The <a>Maybe</a> type is also a monad. It is a simple kind of error
--   monad, where all errors are represented by <a>Nothing</a>. A richer
--   error monad can be built using the <a>Either</a> type.
data Maybe a :: * -> *

-- | General-purpose finite sequences.
data Seq a :: * -> *

-- | <a>Utf8</a> is used to mark <a>ByteString</a> values that (should)
--   contain valud utf8 encoded strings. This type is used to represent
--   <tt>TYPE_STRING</tt> values.
newtype Utf8
Utf8 :: ByteString -> Utf8

-- | A space-efficient representation of a Word8 vector, supporting many
--   efficient operations. A <a>ByteString</a> contains 8-bit characters
--   only.
--   
--   Instances of Eq, Ord, Read, Show, Data, Typeable
data ByteString :: *

-- | 32-bit signed integer type
data Int32 :: *

-- | 64-bit signed integer type
data Int64 :: *

-- | 32-bit unsigned integer type
data Word32 :: *

-- | 64-bit unsigned integer type
data Word64 :: *

-- | <a>WireTag</a> is the 32 bit value with the upper 29 bits being the
--   <a>FieldId</a> and the lower 3 bits being the <a>WireType</a>
newtype WireTag
WireTag :: Word32 -> WireTag
getWireTag :: WireTag -> Word32

-- | <a>FieldId</a> is the field number which can be in the range 1 to
--   2^29-1 but the value from 19000 to 19999 are forbidden (so sayeth
--   Google).
newtype FieldId
FieldId :: Int32 -> FieldId
getFieldId :: FieldId -> Int32

-- | <a>WireType</a> is the 3 bit wire encoding value, and is currently in
--   the range 0 to 5, leaving 6 and 7 currently invalid.
--   
--   <ul>
--   <li>0 <i>Varint</i> : int32, int64, uint32, uint64, sint32, sint64,
--   bool, enum</li>
--   <li>1 <i>64-bit</i> : fixed64, sfixed64, double</li>
--   <li>2 <i>Length-delimited</i> : string, bytes, embedded messages</li>
--   <li>3 <i>Start group</i> : groups (deprecated)</li>
--   <li>4 <i>End group</i> : groups (deprecated)</li>
--   <li>5 <i>32-bit</i> : fixed32, sfixed32, float</li>
--   </ul>
newtype WireType
WireType :: Word32 -> WireType
getWireType :: WireType -> Word32

-- | <a>FieldType</a> is the integer associated with the
--   FieldDescriptorProto's Type. The allowed range is currently 1 to 18,
--   as shown below (excerpt from descritor.proto)
--   
--   <pre>
--   // 0 is reserved for errors.
--   // Order is weird for historical reasons.
--   TYPE_DOUBLE         = 1;
--   TYPE_FLOAT          = 2;
--   TYPE_INT64          = 3;   // Not ZigZag encoded.  Negative numbers
--                              // take 10 bytes.  Use TYPE_SINT64 if negative
--                              // values are likely.
--   TYPE_UINT64         = 4;
--   TYPE_INT32          = 5;   // Not ZigZag encoded.  Negative numbers
--                              // take 10 bytes.  Use TYPE_SINT32 if negative
--                              // values are likely.
--   TYPE_FIXED64        = 6;
--   TYPE_FIXED32        = 7;
--   TYPE_BOOL           = 8;
--   TYPE_STRING         = 9;
--   TYPE_GROUP          = 10;  // Tag-delimited aggregate.
--   TYPE_MESSAGE        = 11;  // Length-delimited aggregate.
--   
--   // New in version 2.
--   TYPE_BYTES          = 12;
--   TYPE_UINT32         = 13;
--   TYPE_ENUM           = 14;
--   TYPE_SFIXED32       = 15;
--   TYPE_SFIXED64       = 16;
--   TYPE_SINT32         = 17;  // Uses ZigZag encoding.
--   TYPE_SINT64         = 18;  // Uses ZigZag encoding.
--   </pre>
newtype FieldType
FieldType :: Int -> FieldType
getFieldType :: FieldType -> Int

-- | <a>EnumCode</a> is the Int32 assoicated with a
--   EnumValueDescriptorProto and is in the range 0 to 2^31-1.
newtype EnumCode
EnumCode :: Int32 -> EnumCode
getEnumCode :: EnumCode -> Int32

-- | <a>WireSize</a> is the Int64 size type associate with the lazy
--   bytestrings used in the <tt>Put</tt> and <tt>Get</tt> monads.
type WireSize = Int64

-- | The <a>Mergeable</a> class is not a <a>Monoid</a>, <tt>mergeEmpty</tt>
--   is not a left or right unit like <a>mempty</a>. The default
--   <a>mergeAppend</a> is to take the second parameter and discard the
--   first one. The <a>mergeConcat</a> defaults to <tt>foldl</tt>
--   associativity.
--   
--   NOTE: <tt>mergeEmpty</tt> has been removed in protocol buffers version
--   2. Use defaultValue instead. New strict fields would mean that
--   required fields in messages will be automatic errors with
--   <tt>mergeEmpty</tt>.
class Default a => Mergeable a where mergeAppend _a b = b mergeConcat = foldl mergeAppend defaultValue
mergeAppend :: Mergeable a => a -> a -> a
mergeConcat :: (Mergeable a, Foldable t) => t a -> a

-- | The Default class has the default-default values of types. See
--   <a>http://code.google.com/apis/protocolbuffers/docs/proto.html#optional</a>
--   and also note that <a>Enum</a> types have a <a>defaultValue</a> that
--   is the first one in the <tt>.proto</tt> file (there is always at least
--   one value). Instances of this for messages hold any default value
--   defined in the <tt>.proto</tt> file. <a>defaultValue</a> is where the
--   <tt>MessageAPI</tt> function <tt>getVal</tt> looks when an optional
--   field is not set.
class Default a
defaultValue :: Default a => a
isValidUTF8 :: ByteString -> Maybe Int
toUtf8 :: ByteString -> Either Int Utf8
utf8 :: Utf8 -> ByteString
uToString :: Utf8 -> String
uFromString :: String -> Utf8
instance Typeable Utf8
instance Typeable WireTag
instance Typeable FieldId
instance Typeable WireType
instance Typeable FieldType
instance Typeable EnumCode
instance Data Utf8
instance Eq Utf8
instance Ord Utf8
instance Eq WireTag
instance Ord WireTag
instance Enum WireTag
instance Read WireTag
instance Show WireTag
instance Num WireTag
instance Bits WireTag
instance Bounded WireTag
instance Data WireTag
instance Eq FieldId
instance Ord FieldId
instance Enum FieldId
instance Read FieldId
instance Show FieldId
instance Num FieldId
instance Data FieldId
instance Ix FieldId
instance Eq WireType
instance Ord WireType
instance Enum WireType
instance Read WireType
instance Show WireType
instance Num WireType
instance Data WireType
instance Eq FieldType
instance Ord FieldType
instance Enum FieldType
instance Read FieldType
instance Show FieldType
instance Num FieldType
instance Data FieldType
instance Eq EnumCode
instance Ord EnumCode
instance Read EnumCode
instance Show EnumCode
instance Num EnumCode
instance Data EnumCode
instance Default Utf8
instance Default ByteString
instance Default (Seq a)
instance Default (Maybe a)
instance Default Bool
instance Default Double
instance Default Float
instance Default Int32
instance Default Int64
instance Default Word32
instance Default Word64
instance Mergeable Word64
instance Mergeable Word32
instance Mergeable Int64
instance Mergeable Int32
instance Mergeable Float
instance Mergeable Double
instance Mergeable ByteString
instance Mergeable Utf8
instance Mergeable Bool
instance Mergeable (Seq a)
instance Mergeable a => Mergeable (Maybe a)
instance Bounded EnumCode
instance Bounded FieldType
instance Bounded WireType
instance Bounded FieldId
instance Monoid Utf8
instance Show Utf8
instance Read Utf8


-- | This modules colelct utility routines related to the different
--   incarnations of identifiers in the code. The basic identifier is
--   always ASCII, but because of the self generated DescriptorProto data
--   structures it is stored in <a>Utf8</a> tagged lazy bytestrings.
--   
--   An <tt>identifier</tt> is a non-empty ASCII string made of
--   [a-zA-Z0-9_] where the first character is never in [0-9].
--   
--   A <tt>field</tt> is a mangled identifer that is a valid Haskell name
--   that begins with lower case, and which may have a single quote at the
--   end if needed to avoid a reserved word. These may also start with '_',
--   though just a <a>_</a> is mangled to <a>_'</a>.
--   
--   A 'module' is a mangled identifier that is a valid Haskell name that
--   begins with upper case. These never have a single quote. A leading '_'
--   is replaced with a leading <a>U'_</a> to make a valid identifier.
module Text.ProtocolBuffers.Identifiers
unull :: Utf8 -> Bool
toString :: Utf8 -> String
fromString :: String -> Utf8

-- | Contains one identifier name
newtype IName a
IName :: a -> IName a
iName :: IName a -> a

-- | <a>.</a> separated identifier which may or may start with a dot. There
--   are never two or more <a>.</a>s in a row. There is always at least one
--   identifier.
newtype DIName a
DIName :: a -> DIName a
diName :: DIName a -> a

-- | Fully qualified identifier: repeated (<a>.</a> then identifier)
newtype FIName a
FIName :: a -> FIName a
fiName :: FIName a -> a

-- | Contains one module name, non-empty
newtype MName a
MName :: a -> MName a
mName :: MName a -> a

-- | Full Haskell module name: MNames separated by <a>.</a>, ending with a
--   module
newtype FMName a
FMName :: a -> FMName a
fmName :: FMName a -> a

-- | Parsed Haskell name ending with MName. Good contructor to use.
data PMName a
PMName :: [MName a] -> (MName a) -> PMName a

-- | Contains one field name, non-empty
newtype FName a
FName :: a -> FName a
fName :: FName a -> a

-- | Full Haskell field name: MNames separated by <a>.</a>, ending with a
--   field
newtype FFName a
FFName :: a -> FFName a
ffName :: FFName a -> a

-- | Parsed Haskell name ending with FName. Good constructor to use.
data PFName a
PFName :: [MName a] -> (FName a) -> PFName a

-- | This is used to abstract over Utf8 and String. The important entry
--   point is <a>validDI</a>.
class Monoid a => Dotted a
uncons :: Dotted a => a -> Maybe (Char, a)
cons :: Dotted a => Char -> a -> a
dot :: Dotted a => a -> a -> a
validI :: Dotted a => a -> Maybe (IName a)
validDI :: Dotted a => a -> Maybe (DIName a)
split :: Dotted a => a -> [a]

-- | The <a>mangle</a> transformation has instances for several
--   combiantions of input and output. These allow one to construct the
--   Haskell types of MName<i>FMName</i>PMName and FName<i>FFName</i>PFName
--   out of the protobuf types IName<i>DIName</i>FIName. Currently, all the
--   Haskell instances are for the String base type.
class Mangle a b
mangle :: Mangle a b => a -> b
joinPM :: Dotted a => PMName a -> FMName a
joinPF :: Dotted a => PFName a -> FFName a

-- | <a>difi</a> examines the <a>DIName</a> and prepend a <a>.</a> if
--   absent, promoting it to a <a>FIName</a>.
difi :: Dotted a => DIName a -> FIName a

-- | Typed <a>split</a>
splitDI :: Dotted a => DIName a -> [IName a]

-- | Typed <a>split</a>
splitFI :: Dotted a => FIName a -> [IName a]

-- | Typed <a>split</a>
splitFM :: Dotted a => FMName a -> [MName a]

-- | Right (True,_) means the input is a FIName. Right (False,_) means the
--   input is a DIName (without leading <a>.</a>)
--   
--   This creates useful error messages for the user.
checkDIString :: String -> Either String (Bool, [IName String])

-- | Right (True,_) means the input is a FIName. Right (False,_) means the
--   input is a DIName (without leading <a>.</a>)
--   
--   This creates useful error messages for the user.
checkDIUtf8 :: Utf8 -> Either String (Bool, [IName Utf8])
promoteDI :: Dotted a => IName a -> DIName a
promoteFI :: Dotted a => IName a -> FIName a
promoteFM :: Dotted a => MName a -> FMName a
promoteFF :: Dotted a => FName a -> FFName a
dotFM :: Dotted a => FMName a -> FMName a -> FMName a
dotFF :: Dotted a => FMName a -> FFName a -> FFName a
fqAppend :: Dotted a => FIName a -> [IName a] -> FIName a
instance Typeable1 IName
instance Typeable1 MName
instance Typeable1 FName
instance Typeable1 DIName
instance Typeable1 FIName
instance Typeable1 FMName
instance Typeable1 FFName
instance Typeable1 PMName
instance Typeable1 PFName
instance Data a => Data (IName a)
instance Eq a => Eq (IName a)
instance Ord a => Ord (IName a)
instance Data a => Data (MName a)
instance Eq a => Eq (MName a)
instance Ord a => Ord (MName a)
instance Data a => Data (FName a)
instance Eq a => Eq (FName a)
instance Ord a => Ord (FName a)
instance Data a => Data (DIName a)
instance Eq a => Eq (DIName a)
instance Ord a => Ord (DIName a)
instance Data a => Data (FIName a)
instance Eq a => Eq (FIName a)
instance Ord a => Ord (FIName a)
instance Data a => Data (FMName a)
instance Eq a => Eq (FMName a)
instance Ord a => Ord (FMName a)
instance Data a => Data (FFName a)
instance Eq a => Eq (FFName a)
instance Ord a => Ord (FFName a)
instance Show a => Show (PMName a)
instance Data a => Data (PMName a)
instance Read a => Read (PMName a)
instance Eq a => Eq (PMName a)
instance Ord a => Ord (PMName a)
instance Show a => Show (PFName a)
instance Data a => Data (PFName a)
instance Read a => Read (PFName a)
instance Eq a => Eq (PFName a)
instance Ord a => Ord (PFName a)
instance Dotted String
instance Dotted Utf8
instance Mangle (FIName Utf8) (PFName String)
instance Mangle (DIName Utf8) (PFName String)
instance Mangle (FIName Utf8) (PMName String)
instance Mangle (DIName Utf8) (PMName String)
instance Mangle (MName String) (FName String)
instance Mangle (IName Utf8) (FName String)
instance Mangle (IName String) (FName String)
instance Mangle (FName String) (MName String)
instance Mangle (IName Utf8) (MName String)
instance Mangle (IName String) (MName String)
instance Show a => Show (FFName a)
instance Show a => Show (FMName a)
instance Show a => Show (FIName a)
instance Show a => Show (DIName a)
instance Show a => Show (FName a)
instance Show a => Show (MName a)
instance Show a => Show (IName a)
instance Read a => Read (FMName a)
instance Read a => Read (FFName a)
instance Read a => Read (FIName a)
instance Read a => Read (DIName a)
instance Read a => Read (FName a)
instance Read a => Read (MName a)
instance Read a => Read (IName a)


-- | A strong feature of the protocol-buffers package is that it does not
--   contain any structures defined by descriptor.proto! This prevents me
--   hitting any annoying circular dependencies. The structures defined
--   here are included in each module created by <tt>hprotoc</tt>. They are
--   optimized for use in code generation.
--   
--   These values can be inspected at runtime by the user's code, but I
--   have yet to write much documentation. Luckily the record field names
--   are somewhat descriptive.
--   
--   The other reflection is using the <tt>fileDescriptorProto</tt> which
--   is put into the top level module created by hprotoc.
module Text.ProtocolBuffers.Reflections

-- | This is fully qualified name data type for code generation. The
--   <a>haskellPrefix</a> was possibly specified on the <tt>hprotoc</tt>
--   command line. The <a>parentModule</a> is a combination of the module
--   prefix from the '.proto' file and any nested levels of definition.
--   
--   The name components are likely to have been mangled to ensure the
--   <a>baseName</a> started with an uppercase letter, in <tt> ['A'..'Z']
--   </tt>.
data ProtoName
ProtoName :: FIName Utf8 -> [MName String] -> [MName String] -> MName String -> ProtoName

-- | fully qualified name using <a>package</a> prefix (no mangling)
protobufName :: ProtoName -> FIName Utf8

-- | Haskell specific prefix to module hierarchy (e.g. Text.Foo)
haskellPrefix :: ProtoName -> [MName String]

-- | .proto specified namespace (like Com.Google.Bar)
parentModule :: ProtoName -> [MName String]
baseName :: ProtoName -> MName String
data ProtoFName
ProtoFName :: FIName Utf8 -> [MName String] -> [MName String] -> FName String -> ProtoFName

-- | fully qualified name using <a>package</a> prefix (no mangling)
protobufName' :: ProtoFName -> FIName Utf8

-- | Haskell specific prefix to module hierarchy (e.g. Text.Foo)
haskellPrefix' :: ProtoFName -> [MName String]

-- | .proto specified namespace (like Com.Google.Bar)
parentModule' :: ProtoFName -> [MName String]
baseName' :: ProtoFName -> FName String
data ProtoInfo
ProtoInfo :: ProtoName -> [FilePath] -> FilePath -> Seq KeyInfo -> [DescriptorInfo] -> [EnumInfo] -> Map ProtoName (Seq FieldInfo) -> ProtoInfo

-- | blank protobufName, maybe blank haskellPrefix and/or parentModule
protoMod :: ProtoInfo -> ProtoName

-- | path to haskell module
protoFilePath :: ProtoInfo -> [FilePath]

-- | filename without path of .proto file
protoSource :: ProtoInfo -> FilePath

-- | top level keys
extensionKeys :: ProtoInfo -> Seq KeyInfo

-- | all messages and groups
messages :: ProtoInfo -> [DescriptorInfo]

-- | all enums
enums :: ProtoInfo -> [EnumInfo]
knownKeyMap :: ProtoInfo -> Map ProtoName (Seq FieldInfo)
data DescriptorInfo
DescriptorInfo :: ProtoName -> [FilePath] -> Bool -> Seq FieldInfo -> Seq KeyInfo -> [(FieldId, FieldId)] -> Seq FieldInfo -> Bool -> Bool -> DescriptorInfo
descName :: DescriptorInfo -> ProtoName
descFilePath :: DescriptorInfo -> [FilePath]
isGroup :: DescriptorInfo -> Bool
fields :: DescriptorInfo -> Seq FieldInfo
keys :: DescriptorInfo -> Seq KeyInfo
extRanges :: DescriptorInfo -> [(FieldId, FieldId)]
knownKeys :: DescriptorInfo -> Seq FieldInfo
storeUnknown :: DescriptorInfo -> Bool
lazyFields :: DescriptorInfo -> Bool
data FieldInfo
FieldInfo :: ProtoFName -> FieldId -> WireTag -> Maybe (WireTag, WireTag) -> WireSize -> Bool -> Bool -> Bool -> Bool -> FieldType -> Maybe ProtoName -> Maybe ByteString -> Maybe HsDefault -> FieldInfo
fieldName :: FieldInfo -> ProtoFName
fieldNumber :: FieldInfo -> FieldId

-- | Used for writing and reading if packedTag is Nothing
wireTag :: FieldInfo -> WireTag

-- | used for reading when Just {} instead of wireTag
packedTag :: FieldInfo -> Maybe (WireTag, WireTag)

-- | Bytes required in the Varint formatted wireTag
wireTagLength :: FieldInfo -> WireSize
isPacked :: FieldInfo -> Bool
isRequired :: FieldInfo -> Bool

-- | True if repeated is the field type
canRepeat :: FieldInfo -> Bool

-- | True if packed would be valid for this field type
mightPack :: FieldInfo -> Bool

-- | fromEnum of Text.DescriptorProtos.FieldDescriptorProto.Type
typeCode :: FieldInfo -> FieldType

-- | Set for Messages,Groups,and Enums
typeName :: FieldInfo -> Maybe ProtoName

-- | crappy, but not escaped, thing
hsRawDefault :: FieldInfo -> Maybe ByteString

-- | nice parsed thing
hsDefault :: FieldInfo -> Maybe HsDefault
type KeyInfo = (ProtoName, FieldInfo)

-- | <a>HsDefault</a> stores the parsed default from the proto file in a
--   form that will make a nice literal in the
--   <a>Language.Haskell.Exts.Syntax</a> code generation by
--   <tt>hprotoc</tt>.
--   
--   Note that Utf8 labeled byte sequences have been stripped to just
--   <a>ByteString</a> here as this is sufficient for code generation.
--   
--   On 25 August 2010 20:12, George van den Driessche
--   <a>georgevdd@google.com</a> sent Chris Kuklewicz a patch to
--   MakeReflections.parseDefEnum to ensure that HsDef'Enum holds the
--   mangled form of the name.
data HsDefault
HsDef'Bool :: Bool -> HsDefault
HsDef'ByteString :: ByteString -> HsDefault
HsDef'RealFloat :: SomeRealFloat -> HsDefault
HsDef'Integer :: Integer -> HsDefault
HsDef'Enum :: String -> HsDefault

-- | <a>SomeRealFloat</a> projects Double/Float to Rational or a special
--   IEEE type. This is needed to track protobuf-2.3.0 which allows nan and
--   inf and -inf default values.
data SomeRealFloat
SRF'Rational :: Rational -> SomeRealFloat
SRF'nan :: SomeRealFloat
SRF'ninf :: SomeRealFloat
SRF'inf :: SomeRealFloat
data EnumInfo
EnumInfo :: ProtoName -> [FilePath] -> [(EnumCode, String)] -> EnumInfo
enumName :: EnumInfo -> ProtoName
enumFilePath :: EnumInfo -> [FilePath]

-- | The String is the Haskell name to write into the generated source
--   files
enumValues :: EnumInfo -> [(EnumCode, String)]
type EnumInfoApp e = [(EnumCode, String, e)]
class ReflectDescriptor m where getMessageInfo x = cached where cached = makeMessageInfo (reflectDescriptorInfo (undefined `asTypeOf` x)) makeMessageInfo :: DescriptorInfo -> GetMessageInfo makeMessageInfo di = GetMessageInfo {requiredTags = fromDistinctAscList . sort $ [wireTag f | f <- toList (fields di), isRequired f], allowedTags = fromDistinctAscList . sort $ [wireTag f | f <- toList (fields di)] ++ [wireTag f | f <- toList (knownKeys di)]}
getMessageInfo :: ReflectDescriptor m => m -> GetMessageInfo
reflectDescriptorInfo :: ReflectDescriptor m => m -> DescriptorInfo
class ReflectEnum e where parentOfEnum _ = Nothing
reflectEnum :: ReflectEnum e => EnumInfoApp e
reflectEnumInfo :: ReflectEnum e => e -> EnumInfo
parentOfEnum :: ReflectEnum e => e -> Maybe DescriptorInfo

-- | <a>GetMessageInfo</a> is used in getting messages from the wire. It
--   supplies the <a>Set</a> of precomposed wire tags that must be found in
--   the message as well as a <a>Set</a> of all allowed tags (including
--   known extension fields and all required wire tags).
--   
--   Extension fields not in the allowedTags set are still loaded, but only
--   as <a>ByteString</a> blobs that will have to interpreted later.
data GetMessageInfo
GetMessageInfo :: Set WireTag -> Set WireTag -> GetMessageInfo
requiredTags :: GetMessageInfo -> Set WireTag
allowedTags :: GetMessageInfo -> Set WireTag

-- | <a>makePNF</a> is used by the generated code to create a ProtoName
--   with less newtype noise.
makePNF :: ByteString -> [String] -> [String] -> String -> ProtoName
toRF :: (RealFloat a, Fractional a) => SomeRealFloat -> a
fromRF :: (RealFloat a, Fractional a) => a -> SomeRealFloat
instance Typeable ProtoName
instance Typeable ProtoFName
instance Typeable GetMessageInfo
instance Typeable SomeRealFloat
instance Typeable HsDefault
instance Typeable FieldInfo
instance Typeable DescriptorInfo
instance Typeable EnumInfo
instance Typeable ProtoInfo
instance Show ProtoName
instance Read ProtoName
instance Eq ProtoName
instance Ord ProtoName
instance Data ProtoName
instance Show ProtoFName
instance Read ProtoFName
instance Eq ProtoFName
instance Ord ProtoFName
instance Data ProtoFName
instance Show GetMessageInfo
instance Read GetMessageInfo
instance Eq GetMessageInfo
instance Ord GetMessageInfo
instance Data GetMessageInfo
instance Show SomeRealFloat
instance Read SomeRealFloat
instance Eq SomeRealFloat
instance Ord SomeRealFloat
instance Data SomeRealFloat
instance Show HsDefault
instance Read HsDefault
instance Eq HsDefault
instance Ord HsDefault
instance Data HsDefault
instance Show FieldInfo
instance Read FieldInfo
instance Eq FieldInfo
instance Ord FieldInfo
instance Data FieldInfo
instance Show DescriptorInfo
instance Read DescriptorInfo
instance Eq DescriptorInfo
instance Ord DescriptorInfo
instance Data DescriptorInfo
instance Show EnumInfo
instance Read EnumInfo
instance Eq EnumInfo
instance Ord EnumInfo
instance Data EnumInfo
instance Show ProtoInfo
instance Read ProtoInfo
instance Eq ProtoInfo
instance Ord ProtoInfo
instance Data ProtoInfo


-- | Here are the serialization and deserialization functions.
--   
--   This module cooperates with the generated code to implement the Wire
--   instances. The encoding is mostly documented at
--   <a>http://code.google.com/apis/protocolbuffers/docs/encoding.html</a>.
--   
--   The user API functions are grouped into sections and documented. The
--   rest are for internal use. The main functions are <a>messageGet</a>
--   and <a>messagePut</a> (and <a>messageSize</a>). There are then several
--   'message*' variants which allow for finer control and for making
--   delimited messages.
module Text.ProtocolBuffers.WireMessage

-- | This computes the size of the message's fields with tags on the wire
--   with no initial tag or length (in bytes). This is also the length of
--   the message as placed between group start and stop tags.
messageSize :: (ReflectDescriptor msg, Wire msg) => msg -> WireSize

-- | This is <a>runPut</a> applied to <a>messagePutM</a>. It result in a
--   <a>ByteString</a> with a length of <a>messageSize</a> bytes.
messagePut :: (ReflectDescriptor msg, Wire msg) => msg -> ByteString

-- | This consumes the <a>ByteString</a> to decode a message. It assumes
--   the <a>ByteString</a> is merely a sequence of the tagged fields of the
--   message, and consumes until a group stop tag is detected or the entire
--   input is consumed. Any <a>ByteString</a> past the end of the stop tag
--   is returned as well.
--   
--   This is <a>runGetOnLazy</a> applied to <a>messageGetM</a>.
messageGet :: (ReflectDescriptor msg, Wire msg) => ByteString -> Either String (msg, ByteString)

-- | This writes just the message's fields with tags to the wire. This
--   <a>Put</a> monad can be composed and eventually executed with
--   <a>runPut</a>.
--   
--   This is actually <tt> wirePut 10 msg </tt>
messagePutM :: (ReflectDescriptor msg, Wire msg) => msg -> Put

-- | This reads the tagged message fields until the stop tag or the end of
--   input is reached.
--   
--   This is actually <tt> wireGet 10 msg </tt>
messageGetM :: (ReflectDescriptor msg, Wire msg) => Get msg

-- | This computes the size of the message fields as in <a>messageSize</a>
--   and add the length of the encoded size to the total. Thus this is the
--   the length of the message including the encoded length header, but
--   without any leading tag.
messageWithLengthSize :: (ReflectDescriptor msg, Wire msg) => msg -> WireSize

-- | This is <a>runPut</a> applied to <a>messageWithLengthPutM</a>. It
--   results in a <a>ByteString</a> with a length of
--   <a>messageWithLengthSize</a> bytes.
messageWithLengthPut :: (ReflectDescriptor msg, Wire msg) => msg -> ByteString

-- | This <a>runGetOnLazy</a> applied to <a>messageWithLengthGetM</a>.
--   
--   This first reads the encoded length of the message and will then
--   succeed when it has consumed precisely this many additional bytes. The
--   <a>ByteString</a> after this point will be returned.
messageWithLengthGet :: (ReflectDescriptor msg, Wire msg) => ByteString -> Either String (msg, ByteString)

-- | This writes the encoded length of the message's fields and then the
--   message's fields with tags to the wire. This <a>Put</a> monad can be
--   composed and eventually executed with <a>runPut</a>.
--   
--   This is actually <tt> wirePut 11 msg </tt>
messageWithLengthPutM :: (ReflectDescriptor msg, Wire msg) => msg -> Put

-- | This reads the encoded message length and then the message.
--   
--   This is actually <tt> wireGet 11 msg </tt>
messageWithLengthGetM :: (ReflectDescriptor msg, Wire msg) => Get msg

-- | This computes the size of the <a>messageWithLengthSize</a> and then
--   adds the length an initial tag with the given <a>FieldId</a>.
messageAsFieldSize :: (ReflectDescriptor msg, Wire msg) => FieldId -> msg -> WireSize

-- | This writes an encoded wire tag with the given <a>FieldId</a> and then
--   the encoded length of the message's fields and then the message's
--   fields with tags to the wire. This <a>Put</a> monad can be composed
--   and eventually executed with <a>runPut</a>.
messageAsFieldPutM :: (ReflectDescriptor msg, Wire msg) => FieldId -> msg -> Put

-- | This reads a wire tag (must be of type '2') to get the <a>FieldId</a>.
--   Then the encoded message length is read, followed by the message
--   itself. Both the <a>FieldId</a> and the message are returned.
--   
--   This allows for incremental reading and processing.
messageAsFieldGetM :: (ReflectDescriptor msg, Wire msg) => Get (FieldId, msg)

-- | Put merely lifts Builder into a Writer monad, applied to ().
type Put = PutM ()
data Get a

-- | Run the <a>Put</a> monad with a serialiser
runPut :: Put -> ByteString

-- | <a>runGet</a> is the simple executor
runGet :: Get a -> ByteString -> Result a
runGetOnLazy :: Get r -> ByteString -> Either String (r, ByteString)

-- | This is <a>runGetOnLazy</a> with the <a>Left</a> results converted to
--   <a>error</a> calls and the trailing <a>ByteString</a> discarded. This
--   use of runtime errors is discouraged, but may be convenient.
getFromBS :: Get r -> ByteString -> r

-- | The <a>Wire</a> class is for internal use, and may change. If there is
--   a mis-match between the <a>FieldType</a> and the type of <tt>b</tt>
--   then you will get a failure at runtime.
--   
--   Users should stick to the message functions defined in
--   <a>Text.ProtocolBuffers.WireMessage</a> and exported to use user by
--   <a>Text.ProtocolBuffers</a>. These are less likely to change.
class Wire b where wireGetPacked ft = throwError ("Text.ProtocolBuffers.ProtoCompile.Basic: wireGetPacked default:" ++ "\ \  There is no way to get a packed FieldType of " ++ show ft ++ ".\ \  Either there is a bug in this library or the wire format is has been updated.")
wireSize :: Wire b => FieldType -> b -> WireSize
wirePut :: Wire b => FieldType -> b -> Put
wireGet :: Wire b => FieldType -> Get b
wireGetPacked :: Wire b => FieldType -> Get (Seq b)
size'WireTag :: WireTag -> Int64
toWireType :: FieldType -> WireType
toWireTag :: FieldId -> FieldType -> WireTag
toPackedWireTag :: FieldId -> WireTag
mkWireTag :: FieldId -> WireType -> WireTag

-- | Used in generated code.
prependMessageSize :: WireSize -> WireSize

-- | Used in generated code.
putSize :: WireSize -> Put
putVarUInt :: (Integral a, Bits a) => a -> Put
getVarInt :: (Show a, Integral a, Bits a) => Get a

-- | Write a lazy ByteString efficiently, simply appending the lazy
--   ByteString chunks to the output buffer
putLazyByteString :: ByteString -> Put
splitWireTag :: WireTag -> (FieldId, WireType)
fieldIdOf :: WireTag -> FieldId

-- | Used in generated code.
wireSizeReq :: Wire v => Int64 -> FieldType -> v -> Int64

-- | Used in generated code.
wireSizeOpt :: Wire v => Int64 -> FieldType -> Maybe v -> Int64

-- | Used in generated code.
wireSizeRep :: Wire v => Int64 -> FieldType -> Seq v -> Int64

-- | Used in generated code.
wireSizePacked :: Wire v => Int64 -> FieldType -> Seq v -> Int64

-- | Used in generated code.
wirePutReq :: Wire v => WireTag -> FieldType -> v -> Put

-- | Used in generated code.
wirePutOpt :: Wire v => WireTag -> FieldType -> Maybe v -> Put

-- | Used in generated code.
wirePutRep :: Wire v => WireTag -> FieldType -> Seq v -> Put

-- | Used in generated code.
wirePutPacked :: Wire v => WireTag -> FieldType -> Seq v -> Put
wireSizeErr :: Typeable a => FieldType -> a -> WireSize
wirePutErr :: Typeable a => FieldType -> a -> Put
wireGetErr :: Typeable a => FieldType -> Get a
getMessageWith :: (Default message, ReflectDescriptor message) => (WireTag -> message -> Get message) -> Get message

-- | Used by generated code getBareMessageWith assumes the wireTag for the
--   message, if it existed, has already been read. getBareMessageWith
--   assumes that it does needs to read the Varint encoded length of the
--   message. getBareMessageWith will consume the entire ByteString it is
--   operating on, or until it finds any STOP_GROUP tag (wireType == 4)
getBareMessageWith :: (Default message, ReflectDescriptor message) => (WireTag -> message -> Get message) -> Get message
wireGetEnum :: (Typeable e, Enum e) => (Int -> Maybe e) -> Get e
wireGetPackedEnum :: (Typeable e, Enum e) => (Int -> Maybe e) -> Get (Seq e)
unknownField :: Typeable a => a -> FieldId -> Get a
unknown :: (Typeable a, ReflectDescriptor a) => FieldId -> WireType -> a -> Get a

-- | This reads in the raw bytestring corresponding to an field known only
--   through the wiretag's <a>FieldId</a> and <a>WireType</a>.
wireGetFromWire :: FieldId -> WireType -> Get ByteString
castWord64ToDouble :: Word64 -> Double
castWord32ToFloat :: Word32 -> Float
castDoubleToWord64 :: Double -> Word64
castFloatToWord32 :: Float -> Word32
zzEncode64 :: Int64 -> Word64
zzEncode32 :: Int32 -> Word32
zzDecode64 :: Word64 -> Int64
zzDecode32 :: Word32 -> Int32
instance Wire Int
instance Wire ByteString
instance Wire Utf8
instance Wire Bool
instance Wire Word32
instance Wire Word64
instance Wire Int32
instance Wire Int64
instance Wire Float
instance Wire Double


-- | The <a>Extensions</a> module contributes two main things. The first is
--   the definition and implementation of extensible message features. This
--   means that the <a>ExtField</a> data type is exported but its
--   constructor is (in an ideal world) hidden.
--   
--   This first part also includes the keys for the extension fields: the
--   <a>Key</a> data type. These are typically defined in code generated by
--   <tt>hprotoc</tt> from '.proto' file definitions.
--   
--   The second main part is the <a>MessageAPI</a> class which defines
--   <a>getVal</a> and <a>isSet</a>. These allow uniform access to normal
--   and extension fields for users.
--   
--   Access to extension fields is strictly though keys. There is not
--   currently any way to query or change or clear any other extension
--   field data.
--   
--   This module is likely to get broken up into pieces.
module Text.ProtocolBuffers.Extensions

-- | This allows reflection, in this case it gives the numerical
--   <a>FieldId</a> of the key, from 1 to 2^29-1 (excluding 19,000 through
--   19,999).
getKeyFieldId :: Key c msg v -> FieldId

-- | This allows reflection, in this case it gives the <a>FieldType</a>
--   enumeration value (1 to 18) of the
--   <a>Text.DescriptorProtos.FieldDescriptorProto.Type</a> of the field.
getKeyFieldType :: Key c msg v -> FieldType

-- | This will return the default value for a given <a>Key</a>, which is
--   set in the '.proto' file, or if unset it is the <a>defaultValue</a> of
--   that type.
getKeyDefaultValue :: Key c msg v -> v

-- | The <a>Key</a> data type is used with the <a>ExtKey</a> class to put,
--   get, and clear external fields of messages. The <a>Key</a> can also be
--   used with the <tt>MessagesAPI</tt> to get a possibly default value and
--   to check whether a key has been set in a message.
--   
--   The <a>Key</a> type (opaque to the user) has a phantom type of Maybe
--   or Seq that corresponds to Optional or Repeated fields. And a second
--   phantom type that matches the message type it must be used with. The
--   third type parameter corresonds to the Haskell value type.
--   
--   The <a>Key</a> is a GADT that puts all the needed class instances into
--   scope. The actual content is the <a>FieldId</a> ( numeric key), the
--   <a>FieldType</a> (for sanity checks), and <tt>Maybe v</tt> (a
--   non-standard default value).
--   
--   When code is generated all of the known keys are taken into account in
--   the deserialization from the wire. Unknown extension fields are read
--   as a collection of raw byte sequences. If a key is then presented it
--   will be used to parse the bytes.
--   
--   There is no guarantee for what happens if two Keys disagree about the
--   type of a field; in particular there may be undefined values and
--   runtime errors. The data constructor for <a>Key</a> has to be exported
--   to the generated code, but is not exposed to the user by
--   <a>Text.ProtocolBuffers</a>.
data Key c msg v
Key :: FieldId -> FieldType -> (Maybe v) -> Key c msg v

-- | The <a>ExtKey</a> class has three functions for user of the API:
--   <a>putExt</a>, <a>getExt</a>, and <a>clearExt</a>. The
--   <a>wireGetKey</a> is used in generated code.
--   
--   There are two instances of this class, <a>Maybe</a> for optional
--   message fields and <a>Seq</a> for repeated message fields. This class
--   allows for uniform treatment of these two kinds of extension fields.
class ExtKey c
putExt :: ExtKey c => Key c msg v -> c v -> msg -> msg
getExt :: ExtKey c => Key c msg v -> msg -> Either String (c v)
clearExt :: ExtKey c => Key c msg v -> msg -> msg
wireGetKey :: ExtKey c => Key c msg v -> msg -> Get msg
class MessageAPI msg a b | msg a -> b where isSet _ _ = True
getVal :: MessageAPI msg a b => msg -> a -> b
isSet :: MessageAPI msg a b => msg -> a -> Bool

-- | The <a>PackedSeq</a> is needed to distinguish the packed repeated
--   format from the repeated format. This is only used in the phantom type
--   of Key.
newtype PackedSeq a
PackedSeq :: (Seq a) -> PackedSeq a
unPackedSeq :: PackedSeq a -> (Seq a)
data EP
EP :: {-# UNPACK #-} !WireType -> !ByteString -> EP

-- | This is used by the generated code
wireSizeExtField :: ExtField -> WireSize

-- | This is used by the generated code. The data is serialized in order of
--   increasing field number.
wirePutExtField :: ExtField -> Put

-- | get a value from the wire into the message's ExtField. This is used by
--   generated code for extensions that were not known at compile time.
loadExtension :: (ReflectDescriptor a, ExtendMessage a) => FieldId -> WireType -> a -> Get a
notExtension :: (ReflectDescriptor a, ExtendMessage a, Typeable a) => FieldId -> WireType -> a -> Get a
wireGetKeyToUnPacked :: (ExtendMessage msg, GPB v) => Key Seq msg v -> msg -> Get msg
wireGetKeyToPacked :: (ExtendMessage msg, GPB v) => Key PackedSeq msg v -> msg -> Get msg

-- | The <a>Key</a> and <a>GPWitness</a> GADTs use <a>GPB</a> as a
--   shorthand for many classes.
class (Mergeable a, Default a, Wire a, Show a, Typeable a, Eq a, Ord a) => GPB a

-- | ExtField is a newtype'd map from the numeric FieldId key to the
--   ExtFieldValue. This allows for the needed class instances.
newtype ExtField
ExtField :: (Map FieldId ExtFieldValue) -> ExtField

-- | <a>ExtendMessage</a> abstracts the operations of storing and
--   retrieving the <a>ExtField</a> from the message, and provides the
--   reflection needed to know the valid field numbers.
--   
--   This only used internally.
class Typeable msg => ExtendMessage msg
getExtField :: ExtendMessage msg => msg -> ExtField
putExtField :: ExtendMessage msg => ExtField -> msg -> msg
validExtRanges :: ExtendMessage msg => msg -> [(FieldId, FieldId)]

-- | The WireType is used to ensure the Seq is homogenous. The ByteString
--   is the unparsed input after the tag.
data ExtFieldValue
ExtFromWire :: !(Seq EP) -> ExtFieldValue
ExtOptional :: !FieldType -> !GPDyn -> ExtFieldValue
ExtRepeated :: !FieldType -> !GPDynSeq -> ExtFieldValue
ExtPacked :: !FieldType -> !GPDynSeq -> ExtFieldValue
instance Typeable1 PackedSeq
instance Typeable EP
instance Typeable ExtDataPair
instance Typeable DummyMessageType
instance Typeable1 GPWitness
instance Typeable GPDynSeq
instance Typeable GPDyn
instance Typeable ExtFieldValue
instance Data EP
instance Eq EP
instance Ord EP
instance Show EP
instance Data ExtDataPair
instance Show ExtDataPair
instance Ord ExtFieldValue
instance Show ExtFieldValue
instance Eq ExtField
instance Ord ExtField
instance Show ExtField
instance MessageAPI msg (msg -> Word64) Word64
instance MessageAPI msg (msg -> Word32) Word32
instance MessageAPI msg (msg -> Int64) Int64
instance MessageAPI msg (msg -> Int32) Int32
instance MessageAPI msg (msg -> Float) Float
instance MessageAPI msg (msg -> Double) Double
instance MessageAPI msg (msg -> Utf8) Utf8
instance MessageAPI msg (msg -> ByteString) ByteString
instance Default v => MessageAPI msg (Key Seq msg v) (Seq v)
instance Default v => MessageAPI msg (Key Maybe msg v) v
instance MessageAPI msg (msg -> Seq a) (Seq a)
instance (Default msg, Default a) => MessageAPI msg (msg -> Maybe a) a
instance ExtKey PackedSeq
instance ExtKey Seq
instance ExtKey Maybe
instance Show GPDynSeq
instance Ord GPDynSeq
instance Eq GPDynSeq
instance Show GPDyn
instance Ord GPDyn
instance Eq GPDyn
instance GPB a => Data (GPWitness a)
instance Ord (GPWitness a)
instance Eq (GPWitness a)
instance Show (GPWitness a)
instance Default ExtField
instance Mergeable ExtField
instance GPB Word64
instance GPB Word32
instance GPB Int64
instance GPB Int32
instance GPB Float
instance GPB Double
instance GPB Utf8
instance GPB ByteString
instance GPB Bool
instance Eq ExtFieldValue
instance ExtendMessage DummyMessageType
instance Data ExtField
instance Typeable ExtField
instance (Typeable1 c, Typeable msg, Typeable v) => Show (Key c msg v)
instance Typeable1 c => Typeable2 (Key c)


-- | This module add unknown field support to the library. There are no
--   user API things here, except for advanced spelunking into the data
--   structures which can and have changed with no notice. Importer beware.
module Text.ProtocolBuffers.Unknown

-- | This is a suposedly opaque type
newtype UnknownField
UnknownField :: (Seq UnknownFieldValue) -> UnknownField

-- | Messages that can store unknown fields implement this interface.
--   UnknownField is a supposedly opaque type.
class UnknownMessage msg
getUnknownField :: UnknownMessage msg => msg -> UnknownField
putUnknownField :: UnknownMessage msg => UnknownField -> msg -> msg
data UnknownFieldValue
UFV :: {-# UNPACK #-} !WireTag -> !ByteString -> UnknownFieldValue

-- | This is used by the generated code
wireSizeUnknownField :: UnknownField -> WireSize

-- | This is used by the generated code
wirePutUnknownField :: UnknownField -> Put

-- | This is used by the generated code
catch'Unknown :: (Typeable a, UnknownMessage a) => (WireTag -> a -> Get a) -> (WireTag -> a -> Get a)
instance Typeable UnknownFieldValue
instance Typeable UnknownField
instance Eq UnknownFieldValue
instance Ord UnknownFieldValue
instance Show UnknownFieldValue
instance Read UnknownFieldValue
instance Data UnknownFieldValue
instance Eq UnknownField
instance Ord UnknownField
instance Show UnknownField
instance Read UnknownField
instance Data UnknownField
instance Default UnknownField
instance Mergeable UnknownField


-- | This provides what is needed for the output of <tt>hprotoc</tt> to
--   compile. This and the Prelude will both be imported qualified as P',
--   the prime ensuring no name conflicts are possible.
module Text.ProtocolBuffers.Header
append :: Seq a -> a -> Seq a
emptyBS :: ByteString

-- | <i>O(n)</i> Convert a <a>String</a> into a <a>ByteString</a>.
pack :: [Char] -> ByteString

-- | The <a>fromMaybe</a> function takes a default value and and
--   <a>Maybe</a> value. If the <a>Maybe</a> is <a>Nothing</a>, it returns
--   the default values; otherwise, it returns the value contained in the
--   <a>Maybe</a>.
fromMaybe :: a -> Maybe a -> a

-- | In many situations, the <a>liftM</a> operations can be replaced by
--   uses of <a>ap</a>, which promotes function application.
--   
--   <pre>
--   return f `ap` x1 `ap` ... `ap` xn
--   </pre>
--   
--   is equivalent to
--   
--   <pre>
--   liftMn f x1 x2 ... xn
--   </pre>
ap :: Monad m => m (a -> b) -> m a -> m b

-- | <i>O(n)</i>. Build a set from an ascending list of distinct elements
--   in linear time. <i>The precondition (input list is strictly ascending)
--   is not checked.</i>
fromDistinctAscList :: [a] -> Set a

-- | <i>O(log n)</i>. Is the element in the set?
member :: Ord a => a -> Set a -> Bool

-- | Is used within a monadic computation to begin exception processing.
throwError :: MonadError e m => forall a. e -> m a

-- | A handler function to handle previous errors and return to normal
--   execution. A common idiom is:
--   
--   <pre>
--   do { action1; action2; action3 } `catchError` handler
--   </pre>
--   
--   where the <tt>action</tt> functions can call <a>throwError</a>. Note
--   that <tt>handler</tt> and the do-block must have the same return type.
catchError :: MonadError e m => forall a. m a -> (e -> m a) -> m a


-- | <a>Text.ProtocolBuffers</a> exposes the client API. This merely
--   re-exports parts of the other modules in protocol-buffers. The exposed
--   parts are:
--   
--   <pre>
--   import Text.ProtocolBuffers.Basic
--     ( Seq,isValidUTF8,toUtf8,utf8,Utf8(Utf8),Int32,Int64,Word32,Word64
--     , WireTag,FieldId,WireType,FieldType,EnumCode,WireSize
--     , Mergeable(mergeAppend,mergeConcat),Default(defaultValue))
--   import Text.ProtocolBuffers.Extensions
--     ( Key,ExtKey(getExt,putExt,clearExt),MessageAPI(getVal,isSet)
--     , getKeyFieldId,getKeyFieldType,getKeyDefaultValue)
--   import Text.ProtocolBuffers.Identifiers
--   import Text.ProtocolBuffers.Reflections
--     ( ReflectDescriptor(..),ReflectEnum(..),ProtoName(..),HsDefault(..),EnumInfoApp
--     , KeyInfo,FieldInfo(..),DescriptorInfo(..),EnumInfo(..),ProtoInfo(..),makePNF )
--   import Text.ProtocolBuffers.WireMessage
--     ( Wire,Put,Get,runPut,runGet,runGetOnLazy
--     , messageSize,messagePut,messageGet,messagePutM,messageGetM
--     , messageWithLengthSize,messageWithLengthPut,messageWithLengthGet,messageWithLengthPutM,messageWithLengthGetM
--     , messageAsFieldSize,messageAsFieldPutM,messageAsFieldGetM)
--   </pre>
--   
--   The message serialization is taken care of by <a>WireMessage</a>
--   operations, especially <a>messagePut</a> and <a>messageGet</a>. The
--   <a>MessageAPI</a> provides the useful polymorphic <a>getVal</a> and
--   <a>isSet</a> where <a>getVal</a> looks up default values and also
--   works with extension keys. The <a>Utf8</a> newtype is used to indicate
--   the format in the underlying lazy <tt>ByteString</tt>. Messages and
--   values can be combined with the right-biased <a>Mergeable</a>
--   operations. The <tt>mergeEmpty</tt> should not be used as required
--   values are filled in with undefined errors, please use
--   <a>defaultValue</a> instead.
--   
--   The Utf8 type is a newtype of the Lazy ByteString. It can be safely
--   constructed by checking for errors with <a>toUtf8</a>, which returns
--   'Left Int' indicating the index where an error is detected. It can be
--   deconstructed with <a>utf8</a>.
module Text.ProtocolBuffers
