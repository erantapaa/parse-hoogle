-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | References which can be joined and on which lenses can be applied
--   
@package lensref
@version 0.2

module Data.LensRef

-- | Type class for references which can be joined and on which lenses can
--   be applied.
--   
--   The join operation is <a>join</a> from <a>Control.Monad</a>: If <tt>(r
--   :: RefReaderSimple r (RefSimple r a))</tt> then <tt>(join r ::
--   RefSimple r a)</tt>. This is possible because reference operations
--   work with <tt>(RefReaderSimple r (r a))</tt> instead of just <tt>(r
--   a)</tt>. For more compact type signatures, <tt>(RefReaderSimple r (r
--   a))</tt> is called <tt>(RefSimple r a)</tt>.
class (MonadRefWriter (RefWriterSimple r), MonadRefReader (RefReaderSimple r), RefReader (RefReaderSimple r) ~ RefReaderSimple r) => RefClass r where type family RefReaderSimple r :: * -> *
unitRef :: RefClass r => RefSimple r ()
lensMap :: RefClass r => Lens' a b -> RefSimple r a -> RefSimple r b
readRefSimple :: RefClass r => RefSimple r a -> RefReaderSimple r a
writeRefSimple :: RefClass r => RefSimple r a -> a -> RefWriterSimple r ()

-- | Reference wrapped into a RefReaderSimple monad. See the documentation
--   of <a>RefClass</a>.
type RefSimple r a = RefReaderSimple r (r a)

-- | There are two associated types of a reference, <a>RefReaderSimple</a>
--   and <a>RefWriterSimple</a> which determines each-other. This is
--   implemented by putting only <a>RefReaderSimple</a> into the
--   <a>RefClass</a> class and adding a <tt>RefWriterOf</tt> data family
--   outside of <a>RefClass</a>.
--   
--   <tt>RefWriterOf</tt> is hidden from the documentation because you
--   never need it explicitly.
type RefWriterSimple m = RefWriterOf (RefReaderSimple m)

-- | TODO
class Monad m => MonadRefReader m where type family BaseRef m :: * -> * readRef = liftRefReader . readRefSimple
liftRefReader :: MonadRefReader m => RefReader m a -> m a
readRef :: (MonadRefReader m, RefClass r, RefReader m ~ RefReaderSimple r) => RefSimple r a -> m a

-- | TODO
class MonadRefReader m => MonadRefWriter m where writeRef r = liftRefWriter . writeRefSimple r
liftRefWriter :: MonadRefWriter m => RefWriter m a -> m a
writeRef :: (MonadRefWriter m, RefClass r, RefReaderSimple r ~ RefReader m) => RefSimple r a -> a -> m ()

-- | Monad for reference creation. Reference creation is not a method of
--   the <a>RefClass</a> type class to make possible to create the same
--   type of references in multiple monads.
--   
--   For basic usage examples, look into the source of
--   <tt>Data.LensRef.Test</tt>.
class (Monad m, RefClass (BaseRef m), MonadRefReader m, MonadMemo m) => MonadRefCreator m where newRef = extRef unitRef united
extRef :: MonadRefCreator m => Ref m b -> Lens' a b -> a -> m (Ref m a)
newRef :: MonadRefCreator m => a -> m (Ref m a)

-- | TODO
type Ref m a = RefSimple (BaseRef m) a

-- | TODO
type RefReader m = RefReaderSimple (BaseRef m)

-- | TODO
type RefWriter m = RefWriterSimple (BaseRef m)

-- | Monad for dynamic actions
class (MonadRefCreator m, MonadRefWriter (Modifier m), MonadRefCreator (Modifier m), BaseRef (Modifier m) ~ BaseRef m, Monad (EffectM m), EffectM (Modifier m) ~ EffectM m, Modifier (Modifier m) ~ Modifier m) => MonadRegister m where type family EffectM m :: * -> * type family Modifier m :: * -> * onChangeSimple r f = onChange r $ return . f
onChange :: (MonadRegister m, Eq a) => RefReader m a -> (a -> m (m b)) -> m (RefReader m b)
onChangeSimple :: (MonadRegister m, Eq a) => RefReader m a -> (a -> m b) -> m (RefReader m b)
onRegionStatusChange :: MonadRegister m => (RegionStatusChange -> m ()) -> m ()
liftEffectM :: MonadRegister m => EffectM m a -> m a
liftToModifier :: MonadRegister m => m a -> Modifier m a
registerCallback :: (MonadRegister m, Functor f) => f (Modifier m ()) -> m (f (EffectM m ()))

-- | TODO
data RegionStatusChange
Kill :: RegionStatusChange
Block :: RegionStatusChange
Unblock :: RegionStatusChange

-- | TODO
class Monad m => MonadMemo m
memoRead :: MonadMemo m => m a -> m (m a)

-- | <tt>modRef r f</tt> === <tt>readRef r &gt;&gt;= writeRef r . f</tt>
modRef :: (MonadRefWriter m, RefClass r, RefReaderSimple r ~ RefReader m) => RefSimple r a -> (a -> a) -> m ()

-- | TODO
postponeModification :: MonadRegister m => Modifier m () -> m ()

-- | Reference with inherent equivalence.
class RefClass r => EqRefClass r
valueIsChanging :: EqRefClass r => RefSimple r a -> RefReaderSimple r (a -> Bool)

-- | RefClasss with inherent equivalence.
--   
--   <tt>EqRefSimple r a</tt> === <tt>RefReaderSimple r (exist b . Eq b
--   =&gt; (Lens' b a, r b))</tt>
--   
--   As a reference, <tt>(m :: EqRefSimple r a)</tt> behaves as
--   
--   <pre>
--   join $ liftM (uncurry lensMap) m
--   </pre>
type EqRefSimple r a = RefReaderSimple r (EqRefCore r a)

-- | TODO
type EqRef m a = EqRefSimple (BaseRef m) a

-- | <tt>hasEffect r f</tt> returns <tt>False</tt> iff <tt>(modRef m
--   f)</tt> === <tt>(return ())</tt>.
--   
--   <tt>hasEffect</tt> is correct only if <tt>toEqRef</tt> is applied on a
--   pure reference (a reference which is a pure lens on the hidden state).
--   
--   <tt>hasEffect</tt> makes defining auto-sensitive buttons easier, for
--   example.
hasEffect :: EqRefClass r => RefSimple r a -> (a -> a) -> RefReaderSimple r Bool

-- | <tt>EqRefSimple</tt> construction.
toEqRef :: (RefClass r, Eq a) => RefSimple r a -> EqRefSimple r a

-- | An <tt>EqRefSimple</tt> is a normal reference if we forget about the
--   equality.
--   
--   <tt>fromEqRef m</tt> === <tt>join $ liftM (uncurry lensMap) m</tt>
fromEqRef :: RefClass r => EqRefSimple r a -> RefSimple r a

-- | TODO
newEqRef :: (MonadRefCreator m, Eq a) => a -> m (EqRef m a)
instance Eq RegionStatusChange
instance Ord RegionStatusChange
instance Show RegionStatusChange
instance RefClass r => RefClass (EqRefCore r)
instance RefClass r => EqRefClass (EqRefCore r)

module Data.LensRef.Common
type RefWriterT w m = ReaderT (Ref m w) m
runRefWriterT :: (MonadRefCreator m, Monoid w) => RefWriterT w m a -> m (a, Ref m w)
tell' :: (Monoid w, MonadRefCreator m, MonadRefWriter m) => w -> RefWriterT w m ()
newtype MonadMonoid a
MonadMonoid :: a () -> MonadMonoid a
runMonadMonoid :: MonadMonoid a -> a ()
newtype Morph m n
Morph :: (forall a. m a -> n a) -> Morph m n
runMorph :: Morph m n -> forall a. m a -> n a
type SRef m a = Morph (StateT a m) m
class Monad m => NewRef m
newRef' :: NewRef m => a -> m (SRef m a)
memoRead_ :: (MonadRefWriter m, MonadRefCreator m) => m a -> m (m a)
instance NewRef m => NewRef (ReaderT r m)
instance (Monoid w, NewRef m) => NewRef (WriterT w m)
instance NewRef m => NewRef (StateT s m)
instance NewRef IO
instance Monad m => Monoid (MonadMonoid m)


-- | Register reference implementation for the <tt>MonadRefCreator</tt>
--   interface.
--   
--   The implementation uses <tt>unsafeCoerce</tt> internally, but its
--   effect cannot escape.
module Data.LensRef.Pure
data Register n a
runRegister :: Monad m => (forall a. m (m a, a -> m ())) -> Register m a -> m (a, m ())
runTests :: IO ()
instance Monad n => Monad (Register n)
instance (Monad n, Functor n) => Applicative (Register n)
instance Functor n => Functor (Register n)
instance Monad m => Monad (RefWriterOf (ReaderT s m))
instance (Monad m, Functor m) => Applicative (RefWriterOf (ReaderT s m))
instance Functor m => Functor (RefWriterOf (ReaderT s m))
instance MonadReader s m => MonadReader s (RefWriterOf (ReaderT s m))
instance Monad m => MonadState s (RefWriterOf (ReaderT s m))
instance Monad n => MonadRegister (Register n)
instance Monad n => MonadRefWriter (Register n)
instance Monad m => MonadMemo (Register m)
instance Monad n => MonadRefCreator (Register n)
instance Monad m => MonadRefReader (Register m)
instance MonadFix m => MonadFix (Register m)
instance MonadTrans Register
instance Monad m => MonadRefWriter (StateT LSt m)
instance Monad m => MonadMemo (StateT LSt m)
instance Monad m => MonadRefCreator (StateT LSt m)
instance Monad m => MonadRefReader (StateT LSt m)
instance RefClass (Lens_ LSt)
instance MonadRefWriter (RefWriterOf (Reader LSt))
instance Monad m => MonadRefReader (RefWriterOf (ReaderT LSt m))
instance MonadRefReader (Reader LSt)


-- | Fast implementation for the <tt>MonadRefCreator</tt> interface.
--   
--   TODO - elim mem leak: registered events don't allow to release unused
--   refs - optimiziation: do not remember values - optimiziation: equality
--   check
module Data.LensRef.Fast
type Register m = Reg (Wrap m)
runRegister :: NewRef m => (forall a. m (m a, a -> m ())) -> Register m a -> m (a, m ())
runTests :: IO ()
instance Monad m => Monad (Wrap m)
instance Functor m => Functor (Wrap m)
instance Applicative m => Applicative (Wrap m)
instance MonadFix m => MonadFix (Wrap m)
instance Monad n => Monad (Reg n)
instance Applicative n => Applicative (Reg n)
instance Functor n => Functor (Reg n)
instance Monad m => Monad (RefWriterOf (Wrap m))
instance Applicative m => Applicative (RefWriterOf (Wrap m))
instance Functor m => Functor (RefWriterOf (Wrap m))
instance NewRef m => MonadRegister (Register m)
instance NewRef m => MonadRefWriter (Register m)
instance NewRef m => MonadMemo (Register m)
instance NewRef m => MonadRefCreator (Register m)
instance NewRef m => MonadRefReader (Register m)
instance MonadFix m => MonadFix (Register m)
instance NewRef m => MonadRefWriter (Wrap m)
instance NewRef m => MonadMemo (Wrap m)
instance NewRef m => MonadRefCreator (Wrap m)
instance NewRef m => MonadRefWriter (RefWriterOf (Wrap m))
instance NewRef m => MonadRefReader (RefWriterOf (Wrap m))
instance NewRef m => MonadRefReader (Wrap m)
instance NewRef m => RefClass (Lens_ m)
instance MonadTrans Wrap
instance NewRef m => NewRef (Wrap m)
