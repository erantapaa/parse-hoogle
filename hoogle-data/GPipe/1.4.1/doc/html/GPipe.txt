-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A functional graphics API for programmable GPUs
--   
--   GPipe models the entire graphics pipeline in a purely functional,
--   immutable and typesafe way. It is built on top of the programmable
--   pipeline (i.e. non-fixed function) of OpenGL 2.1 and uses features
--   such as vertex buffer objects (VBO's), texture objects and GLSL shader
--   code synthetisation to create fast graphics programs. Buffers,
--   textures and shaders are cached internally to ensure fast framerate,
--   and GPipe is also capable of managing multiple windows and contexts.
--   By creating your own instances of GPipes classes, it's possible to use
--   additional datatypes on the GPU.
--   
--   You'll need full OpenGL 2.1 support, including GLSL 1.20 to use GPipe.
--   Thanks to OpenGLRaw, you may still build GPipe programs on machines
--   lacking this support.
@package GPipe
@version 1.4.1


-- | This module defines the various formats that are used by
--   <tt>FrameBuffer</tt>s and textures, both on the GPU and the CPU.
module Graphics.GPipe.Format

-- | A GPU format with only an alpha value. These are the associated types
--   in <a>GPUFormat</a> and <a>ColorFormat</a>:
--   
--   <ul>
--   <li><i><tt>CPUFormat AlphaFormat</tt></i> <a>CPUFormat1Comp</a></li>
--   <li><i><tt>Color AlphaFormat a</tt></i> <tt>Alpha a</tt></li>
--   </ul>
data AlphaFormat
Alpha4 :: AlphaFormat
Alpha8 :: AlphaFormat
Alpha12 :: AlphaFormat
Alpha16 :: AlphaFormat

-- | A GPU format with a single color component. These are the associated
--   types in <a>GPUFormat</a> and <a>ColorFormat</a>:
--   
--   <ul>
--   <li><i><tt>CPUFormat LuminanceFormat</tt></i>
--   <a>CPUFormat1Comp</a></li>
--   <li><i><tt>Color LuminanceFormat a</tt></i> <tt>Luminance a</tt></li>
--   </ul>
data LuminanceFormat
Luminance4 :: LuminanceFormat
Luminance8 :: LuminanceFormat
Luminance12 :: LuminanceFormat
Luminance16 :: LuminanceFormat
SLuminance8 :: LuminanceFormat

-- | A GPU format with a single color component and an alpha value. These
--   are the associated types in <a>GPUFormat</a> and <a>ColorFormat</a>:
--   
--   <ul>
--   <li><i><tt>CPUFormat LuminanceAlphaFormat</tt></i>
--   <a>CPUFormat2Comp</a></li>
--   <li><i><tt>Color LuminanceAlphaFormat a</tt></i> <tt>LuminanceAlpha a
--   a</tt></li>
--   </ul>
data LuminanceAlphaFormat
Luminance4Alpha4 :: LuminanceAlphaFormat
Luminance6Alpha2 :: LuminanceAlphaFormat
Luminance8Alpha8 :: LuminanceAlphaFormat
Luminance12Alpha4 :: LuminanceAlphaFormat
Luminance12Alpha12 :: LuminanceAlphaFormat
Luminance16Alpha16 :: LuminanceAlphaFormat
SLuminance8Alpha8 :: LuminanceAlphaFormat

-- | A GPU format with color components for red, green and blue. These are
--   the associated types in <a>GPUFormat</a> and <a>ColorFormat</a>:
--   
--   <ul>
--   <li><i><tt>CPUFormat RGBFormat</tt></i> <a>CPUFormat3Comp</a></li>
--   <li><i><tt>Color RGBFormat a</tt></i> <tt>RGB (</tt><a>Vec3</a><tt>
--   a)</tt></li>
--   </ul>
data RGBFormat
R3G3B2 :: RGBFormat
RGB4 :: RGBFormat
RGB5 :: RGBFormat
RGB8 :: RGBFormat
RGB10 :: RGBFormat
RGB12 :: RGBFormat
RGB16 :: RGBFormat
SRGB8 :: RGBFormat

-- | A GPU format with color components for red, green and blue, and an
--   alpha value. These are the associated types in <a>GPUFormat</a> and
--   <a>ColorFormat</a>:
--   
--   <ul>
--   <li><i><tt>CPUFormat RGBAFormat</tt></i> <a>CPUFormat4Comp</a></li>
--   <li><i><tt>Color RGBAFormat a</tt></i> <tt>RGBA (</tt><a>Vec3</a><tt>
--   a) a</tt></li>
--   </ul>
data RGBAFormat
RGBA2 :: RGBAFormat
RGBA4 :: RGBAFormat
RGB5A1 :: RGBAFormat
RGBA8 :: RGBAFormat
RGB10A2 :: RGBAFormat
RGBA12 :: RGBAFormat
RGBA16 :: RGBAFormat
SRGBA8 :: RGBAFormat

-- | A GPU format for a depth buffer value. This is the associated type in
--   <a>GPUFormat</a>:
--   
--   <ul>
--   <li><i><tt>CPUFormat DepthFormat</tt></i> <a>CPUFormat1Comp</a></li>
--   </ul>
data DepthFormat
Depth16 :: DepthFormat
Depth24 :: DepthFormat
Depth32 :: DepthFormat

-- | A GPU format for a stencil buffer value. This is the associated type
--   in <a>GPUFormat</a>:
--   
--   <ul>
--   <li><i><tt>CPUFormat StencilFormat</tt></i> <a>CPUFormat1Comp</a></li>
--   </ul>
data StencilFormat
StencilFormat :: StencilFormat
class (StorableCPUFormat (CPUFormat f), Eq (CPUFormat f)) => GPUFormat f where type family CPUFormat f

-- | This context is used to select which types can be used in a frame
--   buffers color buffer, and also to restrict the type of a texture.
class GPUFormat f => ColorFormat f where data family Color f :: * -> *
type Depth = Float
type Stencil = Int

-- | A CPU format for 4 components (i.e. a RGBA color).
data CPUFormat4Comp
PerComp4 :: CPUFormat1Comp -> CPUFormat4Comp
UnsignedShort4_4_4_4 :: CPUFormat4Comp
UnsignedShort4_4_4_4_Rev :: CPUFormat4Comp
UnsignedShort5_5_5_1 :: CPUFormat4Comp
UnsignedShort1_5_5_5_Rev :: CPUFormat4Comp
UnsignedInt8_8_8_8 :: CPUFormat4Comp
UnsignedInt8_8_8_8_Rev :: CPUFormat4Comp
UnsignedInt10_10_10_2 :: CPUFormat4Comp
UnsignedInt2_10_10_10_Rev :: CPUFormat4Comp

-- | A CPU format for 3 components (i.e. a RGB color).
data CPUFormat3Comp
PerComp3 :: CPUFormat1Comp -> CPUFormat3Comp
UnsignedByte3_3_2 :: CPUFormat3Comp
UnsignedByte2_3_3_Rev :: CPUFormat3Comp
UnsignedShort5_6_5 :: CPUFormat3Comp
UnsignedShort5_6_5_Rev :: CPUFormat3Comp

-- | A CPU format for 2 components (i.e. a LuminanceAlpha color).
data CPUFormat2Comp
PerComp2 :: CPUFormat1Comp -> CPUFormat2Comp

-- | A CPU format for 1 component
data CPUFormat1Comp
UnsignedByteFormat :: CPUFormat1Comp
BitmapFormat :: CPUFormat1Comp
ByteFormat :: CPUFormat1Comp
UnsignedShortFormat :: CPUFormat1Comp
ShortFormat :: CPUFormat1Comp
UnsignedIntFormat :: CPUFormat1Comp
IntFormat :: CPUFormat1Comp
FloatFormat :: CPUFormat1Comp
class StorableCPUFormat a


-- | A GPipe program mainly consits of creating and manipulating streams of
--   primitives and fragments. The modules
--   <a>Graphics.GPipe.Stream.Primitive</a> and
--   <a>Graphics.GPipe.Stream.Fragment</a> defines those streams.
--   
--   All atomic values except textures in streams uses the <a>Vertex</a> or
--   <a>Fragment</a> type constructors. Composite types are created by
--   composing the atomic <a>Vertex</a> or <a>Fragment</a> types, rather
--   than wrapping the composite type in any of those type constructors.
--   This module provides the common classes for those atomic types, as
--   well as reexports of imported common types and modules.
module Graphics.GPipe.Stream

-- | An opaque type constructor for atomic values in a specific GPU context
--   (i.e. <a>V</a> or <a>F</a>), e.g. <a>Shader</a> <a>V</a> <a>Float</a>.
data Shader c t

-- | Denotes a type on the GPU, that can be moved there from the CPU
--   (through the internal use of uniforms). Use the existing instances of
--   this class to create new ones.
class GPU a where type family CPU a
toGPU :: GPU a => CPU a -> a

-- | This class provides the GPU functions either not found in Prelude's
--   numerical classes, or that has wrong types. Instances are also
--   provided for normal <a>Float</a>s and <a>Double</a>s. Minimal complete
--   definition: <a>floor'</a> and <a>ceiling'</a>.
class Floating a => Real' a where rsqrt = (1 /) . sqrt exp2 = (2 **) log2 = logBase 2 saturate x = clamp x 0 1 mix x y a = x * (1 - a) + y * a smoothstep a b x = let t = saturate ((x - a) / (b - a)) in t * t * (3 - 2 * t) fract' x = x - floor' x mod' x y = x - y * floor' (x / y)
rsqrt :: Real' a => a -> a
exp2 :: Real' a => a -> a
log2 :: Real' a => a -> a
floor' :: Real' a => a -> a
ceiling' :: Real' a => a -> a
fract' :: Real' a => a -> a
mod' :: Real' a => a -> a -> a
clamp :: Real' a => a -> a -> a -> a
saturate :: Real' a => a -> a
mix :: Real' a => a -> a -> a -> a
step :: Real' a => a -> a -> a
smoothstep :: Real' a => a -> a -> a -> a

-- | Provides a common way to convert numeric types to integer and floating
--   point representations.
class Convert a where type family ConvertFloat a type family ConvertInt a
toFloat :: Convert a => a -> ConvertFloat a
toInt :: Convert a => a -> ConvertInt a

-- | The vector constructor. <tt>(:.)</tt> for vectors is like <tt>(:)</tt>
--   for lists, and <tt>()</tt> takes the place of <tt>[]</tt>. (The list
--   of instances here is not meant to be readable.)
data (:.) a b :: * -> * -> *
(:.) :: !a -> !b -> :. a b
type Vec2 a = :. a (:. a ())
type Vec3 a = :. a (Vec2 a)
type Vec4 a = :. a (Vec3 a)


-- | <a>FrameBuffer</a>s are 2D images in which fragments from
--   <tt>FragmentStream</tt>s are painted. A <a>FrameBuffer</a> may contain
--   any combination of a color buffer, a depth buffer and a stencil
--   buffer. <a>FrameBuffer</a>s may be shown in windows, saved to memory
--   or converted to textures. <a>FrameBuffer</a>s have no size, but takes
--   the size of the window when shown, or are given a size when saved to
--   memory or converted to a texture.
module Graphics.GPipe.FrameBuffer

-- | A polymorphic frame buffer. It is parameterized on the type of color
--   buffer, depth buffer and stencil buffer. Any instances of
--   <a>ColorFormat</a> can be used for color buffer, or '()' to denote
--   <a>no color buffer</a>. For depth and stencil buffers,
--   <a>DepthFormat</a> and <a>StencilFormat</a> marks the existance of
--   buffer, while '()' marks the inexistance.
data FrameBuffer c d s

-- | Cretes and shows a new GPipe window. Use the last parameter to add
--   extra GLUT callbacks to the window. Note that you can't register your
--   own <a>displayCallback</a> and <a>reshapeCallback</a>.
newWindow :: String -> Vec2 Int -> Vec2 Int -> (Vec2 Int -> IO (FrameBuffer c d s)) -> (Window -> IO ()) -> IO ()
newFrameBufferColor :: ColorFormat f => Color f Float -> FrameBuffer f () ()
newFrameBufferColorDepth :: ColorFormat f => Color f Float -> Depth -> FrameBuffer f DepthFormat ()
newFrameBufferColorStencil :: ColorFormat f => Color f Float -> Stencil -> FrameBuffer f () StencilFormat
newFrameBufferColorDepthStencil :: ColorFormat f => Color f Float -> Depth -> Stencil -> FrameBuffer f DepthFormat StencilFormat
newFrameBufferDepth :: Depth -> FrameBuffer () DepthFormat ()
newFrameBufferStencil :: Stencil -> FrameBuffer () () StencilFormat
newFrameBufferDepthStencil :: Depth -> Stencil -> FrameBuffer () DepthFormat StencilFormat

-- | Saves a <a>FrameBuffer</a>s color buffer to main memory.
getFrameBufferColor :: GPUFormat c => CPUFormat c -> Vec2 Int -> FrameBuffer c d s -> Ptr a -> IO ()

-- | Saves a <a>FrameBuffer</a>s depth buffer to main memory.
getFrameBufferDepth :: CPUFormat DepthFormat -> Vec2 Int -> FrameBuffer c DepthFormat s -> Ptr a -> IO ()

-- | Saves a <a>FrameBuffer</a>s stencil buffer to main memory.
getFrameBufferStencil :: CPUFormat StencilFormat -> Vec2 Int -> FrameBuffer c d StencilFormat -> Ptr a -> IO ()

-- | Returns the byte size needed to store a certain format and size of a
--   framebuffer. Use this to allocate memory before using
--   <a>getFrameBufferColor</a>, <a>getFrameBufferDepth</a> or
--   <a>getFrameBufferStencil</a>.
getFrameBufferCPUFormatByteSize :: StorableCPUFormat f => f -> Vec2 Int -> Int
paintColor :: ColorFormat c => Blending -> ColorMask c -> FragmentStream (Color c (Fragment Float)) -> FrameBuffer c d s -> FrameBuffer c d s
paintDepth :: DepthFunction -> DepthMask -> FragmentStream FragmentDepth -> FrameBuffer c DepthFormat s -> FrameBuffer c DepthFormat s
paintColorDepth :: ColorFormat c => DepthFunction -> DepthMask -> Blending -> ColorMask c -> FragmentStream (Color c (Fragment Float), FragmentDepth) -> FrameBuffer c DepthFormat s -> FrameBuffer c DepthFormat s
paintStencil :: StencilTests -> StencilOps -> StencilOps -> FragmentStream (Fragment a) -> FrameBuffer c d StencilFormat -> FrameBuffer c d StencilFormat
paintDepthStencil :: StencilTests -> StencilOps -> DepthFunction -> DepthMask -> StencilOps -> StencilOps -> FragmentStream FragmentDepth -> FrameBuffer c DepthFormat StencilFormat -> FrameBuffer c DepthFormat StencilFormat
paintColorStencil :: ColorFormat c => StencilTests -> StencilOps -> StencilOps -> Blending -> ColorMask c -> FragmentStream (Color c (Fragment Float)) -> FrameBuffer c d StencilFormat -> FrameBuffer c d StencilFormat
paintColorDepthStencil :: ColorFormat c => StencilTests -> StencilOps -> DepthFunction -> DepthMask -> StencilOps -> StencilOps -> Blending -> ColorMask c -> FragmentStream (Color c (Fragment Float), FragmentDepth) -> FrameBuffer c DepthFormat StencilFormat -> FrameBuffer c DepthFormat StencilFormat
paintRastDepth :: DepthFunction -> DepthMask -> FragmentStream (Fragment a) -> FrameBuffer c DepthFormat s -> FrameBuffer c DepthFormat s
paintColorRastDepth :: ColorFormat c => DepthFunction -> DepthMask -> Blending -> ColorMask c -> FragmentStream (Color c (Fragment Float)) -> FrameBuffer c DepthFormat s -> FrameBuffer c DepthFormat s
paintRastDepthStencil :: StencilTests -> StencilOps -> DepthFunction -> DepthMask -> StencilOps -> StencilOps -> FragmentStream (Fragment a) -> FrameBuffer c DepthFormat StencilFormat -> FrameBuffer c DepthFormat StencilFormat
paintColorRastDepthStencil :: ColorFormat c => StencilTests -> StencilOps -> DepthFunction -> DepthMask -> StencilOps -> StencilOps -> Blending -> ColorMask c -> FragmentStream (Color c (Fragment Float)) -> FrameBuffer c DepthFormat StencilFormat -> FrameBuffer c DepthFormat StencilFormat

-- | <a>True</a> for each color component that should be written to the
--   <a>FrameBuffer</a>.
type ColorMask f = Color f Bool

-- | Sets how the painted colors are blended with the <a>FrameBuffer</a>s
--   previous value.
data Blending

-- | The painted fragment completely overwrites the previous value.
NoBlending :: Blending

-- | Use blending equations to combine the fragment with the previous
--   value. The first <a>BlendEquation</a> and <a>BlendingFactor</a>s is
--   used for front faced triangles and other primitives, and the second
--   for back faced triangles.
Blend :: (BlendEquation, BlendEquation) -> ((BlendingFactor, BlendingFactor), (BlendingFactor, BlendingFactor)) -> (Color RGBAFormat Float) -> Blending

-- | Use a <a>LogicOp</a> to combine the fragment with the previous value.
BlendLogicOp :: LogicOp -> Blending
data BlendEquation :: *
FuncAdd :: BlendEquation
FuncSubtract :: BlendEquation
FuncReverseSubtract :: BlendEquation
Min :: BlendEquation
Max :: BlendEquation
LogicOp :: BlendEquation
data BlendingFactor :: *
Zero :: BlendingFactor
One :: BlendingFactor
SrcColor :: BlendingFactor
OneMinusSrcColor :: BlendingFactor
DstColor :: BlendingFactor
OneMinusDstColor :: BlendingFactor
SrcAlpha :: BlendingFactor
OneMinusSrcAlpha :: BlendingFactor
DstAlpha :: BlendingFactor
OneMinusDstAlpha :: BlendingFactor
ConstantColor :: BlendingFactor
OneMinusConstantColor :: BlendingFactor
ConstantAlpha :: BlendingFactor
OneMinusConstantAlpha :: BlendingFactor
SrcAlphaSaturate :: BlendingFactor
data LogicOp :: *
Clear :: LogicOp
And :: LogicOp
AndReverse :: LogicOp
Copy :: LogicOp
AndInverted :: LogicOp
Noop :: LogicOp
Xor :: LogicOp
Or :: LogicOp
Nor :: LogicOp
Equiv :: LogicOp
Invert :: LogicOp
OrReverse :: LogicOp
CopyInverted :: LogicOp
OrInverted :: LogicOp
Nand :: LogicOp
Set :: LogicOp
data ComparisonFunction :: *
Never :: ComparisonFunction
Less :: ComparisonFunction
Equal :: ComparisonFunction
Lequal :: ComparisonFunction
Greater :: ComparisonFunction
Notequal :: ComparisonFunction
Gequal :: ComparisonFunction
Always :: ComparisonFunction

-- | The function used to compare the fragment's depth and the depth
--   buffers depth with.
type DepthFunction = ComparisonFunction

-- | <a>True</a> if the depth component should be written to the
--   <a>FrameBuffer</a>.
type DepthMask = Bool

-- | Sets the operations that should be performed on the
--   <a>FrameBuffer</a>s stencil value
data StencilOps
StencilOps :: StencilOp -> StencilOp -> StencilOps

-- | Used for front faced triangles and other primitives.
frontStencilOp :: StencilOps -> StencilOp

-- | Used for back faced triangles.
backStencilOp :: StencilOps -> StencilOp
data StencilOp :: *
OpZero :: StencilOp
OpKeep :: StencilOp
OpReplace :: StencilOp
OpIncr :: StencilOp
OpIncrWrap :: StencilOp
OpDecr :: StencilOp
OpDecrWrap :: StencilOp
OpInvert :: StencilOp

-- | Sets a test that should be performed on the stencil value.
data StencilTest
StencilTest :: ComparisonFunction -> Int32 -> Word32 -> StencilTest

-- | The function used to compare the <tt>stencilReference</tt> and the
--   stencil buffers value with.
stencilComparision :: StencilTest -> ComparisonFunction

-- | The value to compare with the stencil buffer's value.
stencilReference :: StencilTest -> Int32

-- | A bit mask with ones in each position that should be compared and
--   written to the stencil buffer.
stencilMask :: StencilTest -> Word32

-- | Sets the tests that should be performed on the stencil value, first
--   for front facing triangles and other primitives, then for back facing
--   triangles.
data StencilTests
StencilTests :: StencilTest -> StencilTest -> StencilTests
type FragmentDepth = Fragment Float


-- | <a>FragmentStream</a>s implement the <a>Functor</a> class, which
--   provides the <a>fmap</a> method that you can use to manipulate those
--   streams. This corresponds to writing and using fragment shaders, but
--   in a much more modular way. You may for instance apply <a>fmap</a>
--   several times in a sequence, effectively creating complex shaders.
--   
--   Instances are also provided for the <tt>Monoid</tt> class, so several
--   streams (of the same type) can be concatenated. The order is
--   preserved, meaning that the fragments in stream <tt>a</tt> in <tt>a
--   <tt>mappend</tt> b</tt> will be drawn before the fragments in
--   <tt>b</tt>.
--   
--   All atomic values except textures in fragment streams uses the
--   <a>Fragment</a> type constructor. Composite types are created by
--   composing the atomic <a>Fragment</a> types, rather than wrapping the
--   composite type in the <a>Fragment</a> type constructors.
--   
--   <a>Fragment</a> instances for are provided for most of Prelude's
--   numerical classes. Since <a>Eq</a>, <a>Ord</a> and <a>Show</a> are
--   prerequisites for these classes, instances are provided for them too,
--   even though their methods all will generate errors if used (except
--   <a>min</a> and <a>max</a>). Use the instances of <a>EqB</a>,
--   <a>OrdB</a> and <a>IfB</a> from the Boolean package if you want to
--   compare <a>Fragment</a> values. Hyperbolic trigonometrical functions
--   aren't provided either.
--   
--   Rewrite rule specializations are provided for the Vec package
--   functions <tt>norm</tt>, <tt>normalize</tt>, <tt>dot</tt> and
--   <tt>cross</tt> on vectors of <a>Fragment</a> <a>Float</a>, so the use
--   of these functions (and others from that package that is defined in
--   terms of them) are highly encouraged.
module Graphics.GPipe.Stream.Fragment

-- | A stream of fragments on the GPU, parameterized on the fragments type
--   (built up of atoms of type <a>Fragment</a>).
data FragmentStream a

-- | Used to denote a fragment context in the first parameter to
--   <a>Shader</a>
data F

-- | A type synonyme for atomic values in a fragment on the GPU, e.g.
--   <a>Fragment</a> <a>Float</a>.
type Fragment = Shader F

-- | The derivative in x using local differencing of the rasterized value.
dFdx :: Fragment Float -> Fragment Float

-- | The derivative in y using local differencing of the rasterized value.
dFdy :: Fragment Float -> Fragment Float

-- | The sum of the absolute derivative in x and y using local differencing
--   of the rasterized value.
fwidth :: Fragment Float -> Fragment Float

-- | Filters out fragments in a stream where the provided function returns
--   <a>true</a>.
filterFragments :: (a -> Fragment Bool) -> FragmentStream a -> FragmentStream a

-- | The context of types that can be rasterized from vertices in
--   <a>PrimitiveStream</a>s to fragments in <a>FragmentStream</a>s. Create
--   your own instances in terms of the existing ones, e.g. convert your
--   vertex data to <a>Vertex</a> <a>Float</a>s, turn them into
--   <a>Fragment</a> <a>Float</a>s with <a>toFragment</a> and then convert
--   them to your fragment data representation.
class GPU a => VertexOutput a where type family FragmentInput a
toFragment :: VertexOutput a => Rasterizer a (FragmentInput a)

-- | An arrow by which vertex data gets converted to fragment data. Use
--   <a>toFragment</a> in the existing instances of <a>VertexOutput</a> to
--   operate in this arrow.
data Rasterizer a b
type VertexPosition = Vec4 (Vertex Float)

-- | Rasterize front side of all types of primitives with vertices
--   containing canonical view coordinates into fragments.
rasterizeFront :: VertexOutput a => PrimitiveStream p (VertexPosition, a) -> FragmentStream (FragmentInput a)

-- | Rasterize back side of triangles with vertices containing canonical
--   view coordinates into fragments.
rasterizeBack :: VertexOutput a => PrimitiveStream Triangle (VertexPosition, a) -> FragmentStream (FragmentInput a)

-- | Rasterize both sides of triangles with vertices containing canonical
--   view coordinates into fragments, also returning the primitives side in
--   the fragments.
rasterizeFrontAndBack :: VertexOutput a => PrimitiveStream Triangle (VertexPosition, a) -> FragmentStream (Fragment Bool, FragmentInput a)


-- | <a>PrimitiveStream</a>s implement the <a>Functor</a> class, which
--   provides the <a>fmap</a> method that you can use to manipulate those
--   streams. This corresponds to writing and using vertex shaders, but in
--   a much more modular way. You may for instance apply <a>fmap</a>
--   several times in a sequence, effectively creating complex shaders.
--   
--   Instances are also provided for the <tt>Monoid</tt> class, so several
--   streams (of the same type) can be concatenated. The order is
--   preserved, meaning that the primitives in stream <tt>a</tt> in <tt>a
--   <tt>mappend</tt> b</tt> will be drawn before the primitives in
--   <tt>b</tt>.
--   
--   All atomic values except textures in vertex streams uses the
--   <a>Vertex</a> type constructor. Composite types are created by
--   composing the atomic <a>Vertex</a> types, rather than wrapping the
--   composite type in the <a>Vertex</a> type constructors.
--   
--   <a>Vertex</a> instances for are provided for most of Prelude's
--   numerical classes. Since <a>Eq</a>, <a>Ord</a> and <a>Show</a> are
--   prerequisites for these classes, instances are provided for them too,
--   even though their methods all will generate errors if used (except
--   <a>min</a> and <a>max</a>). Use the instances of <a>EqB</a>,
--   <a>OrdB</a> and <a>IfB</a> from the Boolean package if you want to
--   compare <a>Vertex</a> values. Hyperbolic trigonometrical functions
--   aren't provided either.
--   
--   Rewrite rule specializations are provided for the Vec package
--   functions <tt>norm</tt>, <tt>normalize</tt>, <tt>dot</tt> and
--   <tt>cross</tt> on vectors of <a>Vertex</a> <a>Float</a>, so the use of
--   these functions (and others from that package that is defined in terms
--   of them) are highly encouraged.
module Graphics.GPipe.Stream.Primitive

-- | A stream of primitives built by vertices on the GPU. The first
--   parameter is the primitive type (currently <a>Triangle</a>,
--   <a>Line</a> or <a>Point</a>) and the second the the type of each
--   primitives' vertices' type (built up of atoms of type <a>Vertex</a>).
data PrimitiveStream p a

-- | Used to denote a vertex context in the first parameter to
--   <a>Shader</a>
data V

-- | A type synonyme for atomic values in a vertex on the GPU, e.g.
--   <a>Vertex</a> <a>Float</a>.
type Vertex = Shader V

-- | The context of types that can be converted into vertices in
--   <a>PrimitiveStream</a>s. Create your own instances in terms of the
--   existing ones, e.g. convert your vertex data to <a>Float</a>s, turn
--   them into <a>Vertex</a> <a>Float</a>s with <a>toVertex</a> and then
--   convert them to your vertex data representation.
class GPU a => VertexInput a
toVertex :: VertexInput a => InputAssembler (CPU a) a

-- | An arrow by which CPU data gets converted to vertex data. Use
--   <a>toVertex</a> in the existing instances of <a>VertexInput</a> to
--   operate in this arrow.
data InputAssembler a b
data Triangle
TriangleStrip :: Triangle
TriangleList :: Triangle
TriangleFan :: Triangle
data Line
LineStrip :: Line
LineList :: Line
data Point
PointList :: Point
class Primitive p

-- | Converts a list of values to a <a>PrimitiveStream</a>, using a
--   specified <a>Primitive</a> type. This function is lazy in the aspect
--   that if parts of the values aren't used on the GPU, they won't get
--   evaluated and transferred there either.
toGPUStream :: (VertexInput a, Primitive p) => p -> [CPU a] -> PrimitiveStream p a

-- | Converts a list of values to a <a>PrimitiveStream</a>, using a
--   specified <a>Primitive</a> type and an index list. This will use index
--   buffer objects on the GPU, and is recommended if several primitives
--   share vertices. This function is lazy in the aspect that if parts of
--   the values aren't used on the GPU, they won't get evaluated and
--   transferred there either.
toIndexedGPUStream :: (VertexInput a, Primitive p) => p -> [CPU a] -> [Int] -> PrimitiveStream p a


-- | Textures are type safe in GPipe, e.g. when you sample a
--   <tt>RGBFormat</tt> texture, you get an <tt>RGB</tt> value.
--   
--   Textures are either created directly from memory, or by giving a
--   framebuffer a concrete size (which it otherwise don't have). The
--   latter is however not possible for 3D textures.
--   
--   Depth textures are textures that contains depth component data (of
--   type <tt>DepthFormat</tt>) but takes the type of
--   <tt>LuminanceFormat</tt> or <tt>AlphaFormat</tt> textures, and are
--   sampled as such.
module Graphics.GPipe.Texture

-- | A 3D texture. May only be created from main memory in GPipe.
--   <a>Texture3D</a> <tt>f</tt> has the following associated types in its
--   <a>Texture</a> instance:
--   
--   <ul>
--   <li><i><tt>TextureFormat (Texture3D f)</tt></i> <tt>f</tt></li>
--   <li><i><tt>TextureSize (Texture3D f)</tt></i> <a>Vec3</a>
--   <a>Int</a></li>
--   <li><i><tt>TextureVertexCoord (Texture3D f)</tt></i> <a>Vec3</a>
--   <tt>(</tt><a>Vertex</a> <a>Float</a><tt>)</tt></li>
--   <li><i><tt>TextureFragmentCoord (Texture3D f)</tt></i> <a>Vec3</a>
--   <tt>(</tt><a>Fragment</a> <a>Float</a><tt>)</tt></li>
--   </ul>
data Texture3D f

-- | A 2D texture. <a>Texture2D</a> <tt>f</tt> has the following associated
--   types in its <a>Texture</a> instance:
--   
--   <ul>
--   <li><i><tt>TextureFormat (Texture2D f)</tt></i> <tt>f</tt></li>
--   <li><i><tt>TextureSize (Texture2D f)</tt></i> <a>Vec2</a>
--   <a>Int</a></li>
--   <li><i><tt>TextureVertexCoord (Texture2D f)</tt></i> <a>Vec2</a>
--   <tt>(</tt><a>Vertex</a> <a>Float</a><tt>)</tt></li>
--   <li><i><tt>TextureFragmentCoord (Texture2D f)</tt></i> <a>Vec2</a>
--   <tt>(</tt><a>Fragment</a> <a>Float</a><tt>)</tt></li>
--   </ul>
data Texture2D f

-- | A 1D texture. Assumes a frame buffer of height 1 when created from
--   such. <a>Texture1D</a> <tt>f</tt> has the following associated types
--   in its <a>Texture</a> instance:
--   
--   <ul>
--   <li><i><tt>TextureFormat (Texture1D f)</tt></i> <tt>f</tt></li>
--   <li><i><tt>TextureSize (Texture1D f)</tt></i> <a>Int</a></li>
--   <li><i><tt>TextureVertexCoord (Texture1D f)</tt></i> <a>Vertex</a>
--   <a>Float</a></li>
--   <li><i><tt>TextureFragmentCoord (Texture1D f)</tt></i> <a>Fragment</a>
--   <a>Float</a></li>
--   </ul>
data Texture1D f

-- | A cube texture. The sides of the cube are always specified in this
--   order: Positive X, negative X, positive Y, negative Y, positive Z,
--   negative Z. <a>TextureCube</a> <tt>f</tt> has the following associated
--   types in its <a>Texture</a> instance:
--   
--   <ul>
--   <li><i><tt>TextureFormat (TextureCube f)</tt></i> <tt>f</tt></li>
--   <li><i><tt>TextureSize (TextureCube f)</tt></i> <a>Vec2</a> <a>Int</a>
--   (The size of each side)</li>
--   <li><i><tt>TextureVertexCoord (TextureCube f)</tt></i> <a>Vec3</a>
--   <tt>(</tt><a>Vertex</a> <a>Float</a><tt>)</tt></li>
--   <li><i><tt>TextureFragmentCoord (TextureCube f)</tt></i> <a>Vec3</a>
--   <tt>(</tt><a>Fragment</a> <a>Float</a><tt>)</tt></li>
--   </ul>
data TextureCube f
class Texture t where type family TextureFormat t type family TextureSize t type family TextureVertexCoord t type family TextureFragmentCoord t
textureCPUFormatByteSize :: Texture t => CPUFormat (TextureFormat t) -> TextureSize t -> [Int]
sample :: Texture t => Sampler -> t -> TextureFragmentCoord t -> Color (TextureFormat t) (Fragment Float)
sampleBias :: Texture t => Sampler -> t -> TextureFragmentCoord t -> Fragment Float -> Color (TextureFormat t) (Fragment Float)
sampleLod :: Texture t => Sampler -> t -> TextureVertexCoord t -> Vertex Float -> Color (TextureFormat t) (Vertex Float)

-- | Creates a texture from color data in main memory. It lives in the IO
--   monad for the sake of the Ptr's, and could otherwise safely be wrapped
--   in <tt>unsafePerformIO</tt> calls.
newTexture :: (Texture t, GPUFormat (TextureFormat t)) => CPUFormat (TextureFormat t) -> TextureFormat t -> TextureSize t -> [Ptr a] -> IO t

-- | Creates a depth texture from data in main memory. The texture will
--   have the type of a color format and is sampled as such, but contains
--   depth component information internally. It lives in the IO monad for
--   the sake of the Ptr's, and could otherwise safely be wrapped in
--   <tt>unsafePerformIO</tt> calls.
newDepthTexture :: (Texture t, DepthColorFormat (TextureFormat t)) => CPUFormat (TextureFormat t) -> DepthFormat -> TextureSize t -> [Ptr a] -> IO t

-- | The textures that is instances of this class may be created from a
--   <a>FrameBuffer</a>s color buffer.
class Texture t => FromFrameBufferColor t c
fromFrameBufferColor :: FromFrameBufferColor t c => TextureFormat t -> TextureSize t -> FrameBuffer c d s -> t

-- | The textures that is instances of this class may be created from a
--   <a>FrameBuffer</a>s depth buffer. The texture will have the type of a
--   color format and is sampled as such, but contains depth component
--   information internally.
class Texture t => FromFrameBufferDepth t
fromFrameBufferDepth :: FromFrameBufferDepth t => DepthFormat -> TextureSize t -> FrameBuffer c DepthFormat s -> t

-- | The formats that is instances of this class may be used as depth
--   textures, i.e. created with <a>newDepthTexture</a>,
--   <a>fromFrameBufferDepth</a> and <a>fromFrameBufferCubeDepth</a>.
class ColorFormat a => DepthColorFormat a

-- | Create a <a>TextureCube</a> of a specific format and size from the the
--   color buffers of six framebuffers.
fromFrameBufferCubeColor :: ColorFormat c => c -> Vec2 Int -> FrameBuffer c d1 s1 -> FrameBuffer c d2 s2 -> FrameBuffer c d3 s3 -> FrameBuffer c d4 s4 -> FrameBuffer c d5 s5 -> FrameBuffer c d6 s6 -> TextureCube c

-- | Create a <a>TextureCube</a> of a specific depth format and size from
--   the the depth buffers of six framebuffers. The texture will have the
--   type of a color format and is sampled as such, but contains depth
--   component information internally.
fromFrameBufferCubeDepth :: DepthColorFormat d => DepthFormat -> Vec2 Int -> FrameBuffer c1 DepthFormat s1 -> FrameBuffer c2 DepthFormat s2 -> FrameBuffer c3 DepthFormat s3 -> FrameBuffer c4 DepthFormat s4 -> FrameBuffer c5 DepthFormat s5 -> FrameBuffer c6 DepthFormat s6 -> TextureCube d

-- | A structure describing how a texture is sampled
data Sampler
Sampler :: Filter -> EdgeMode -> Sampler

-- | Filter mode used in sampler state
data Filter
Point :: Filter
Linear :: Filter

-- | Edge mode used in sampler state
data EdgeMode
Wrap :: EdgeMode
Mirror :: EdgeMode
Clamp :: EdgeMode


-- | GPipe models the entire graphics pipeline in a purely functional,
--   immutable and typesafe way. It is built on top of the programmable
--   pipeline (i.e. non-fixed function) of OpenGL 2.1 and uses features
--   such as vertex buffer objects (VBO's), texture objects and GLSL shader
--   code synthetisation to create fast graphics programs. Buffers,
--   textures and shaders are cached internally to ensure fast framerate,
--   and GPipe is also capable of managing multiple windows and contexts.
--   By creating your own instances of GPipes classes, it's possible to use
--   additional datatypes on the GPU.
--   
--   You'll need full OpenGL 2.1 support, including GLSL 1.20 to use GPipe.
--   Thanks to OpenGLRaw, you may still build GPipe programs on machines
--   lacking this support.
--   
--   This is a conveniance module, combining GPipes all other modules.
module Graphics.GPipe
