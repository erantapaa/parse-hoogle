-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lax arrows
--   
--   Lax arrows are variants of other arrows which are “less strict” than
--   the original arrows. They can be used, for example, to produce I/O
--   fixpoints in situations where <tt>fixIO</tt> would fail.
@package lax
@version 0.1.0.3


-- | Lax arrows.
--   
--   In order to get an understanding of what a lax arrow is, consider the
--   following code example:
--   
--   <pre>
--   looping :: IO ()
--   looping = fixIO (\char -&gt; putChar char &gt;&gt; return 'A')
--   </pre>
--   
--   One might expect that executing <tt>looping</tt> will result in a
--   capital A being printed but this is not the case. The resulting
--   <tt>'A'</tt> will become “available” not until the action <tt>putChar
--   char</tt> has been executed.
--   
--   In order to explain this, let’s think of <tt>IO o</tt> as being
--   equivalent to <tt>World -&gt; Either Exception (o,World)</tt>. The
--   <tt>&gt;&gt;=</tt> operator could now be defined as follows:
--   
--   <pre>
--   io1 &gt;&gt;= io2Gen = \world -&gt; case io1 world of
--                                  Left  exc         -&gt; Left exc
--                                  Right (o1,world') -&gt; io2Gen o1 world'
--   </pre>
--   
--   This results in the following situation:
--   
--   <ul>
--   <li>In order to decide whether <tt>looping</tt> outputs a value or
--   throws an exception, the system has to decide whether <tt>putChar char
--   &gt;&gt; return 'A'</tt> outputs a value or throws an exception.</li>
--   <li>In order to decide whether <tt>putChar char &gt;&gt; return
--   'A'</tt> outputs a value or throws an exception, the system has to
--   decide whether <tt>putChar char</tt> outputs a value or throws an
--   exception (because of the way, <tt>&gt;&gt;=</tt> is
--   implemented).</li>
--   <li>In order to decide whether <tt>putChar char</tt> outputs a value
--   or throws an exception, the system has to know if there is really a
--   <tt>char</tt> to output or whether there is none because of an
--   exception. So it has to decide whether <tt>putChar char &gt;&gt;
--   return 'A'</tt> outputs a value or throws an exception.</li>
--   </ul>
--   
--   So we have a circular dependency resulting in an output value of
--   <tt>_|_</tt> for <tt>looping</tt>.
--   
--   The <a>LaxArrow</a> type constructor transforms a given arrow into a
--   new arrow which works mostly like the base arrow but is “a bit less
--   strict”. To be more precise, all parts of a lax arrow value which are
--   constructed with <a>arr</a> are internally moved to the beginning.
--   This way, data produced by such parts is available at each point in
--   the arrow when <a>loop</a> is used. For the above example, this would
--   mean that the result <tt>'A'</tt> is already known before the
--   <tt>putChar</tt> action is executed and can therefore be used by this
--   action.
--   
--   Note that relaxation only works for arrows, not directly for monads.
--   It is unknown whether a relaxation mechanism for monads exists but it
--   is considered unlikely. Of course, you can transform any monad into an
--   arrow by using <a>Kleisli</a>. However, the lax arrow type is not an
--   instance of <a>ArrowChoice</a> nor is it one of <a>ArrowApply</a>, and
--   at least the current implementation does not allow it to be an
--   instance of either class.
--   
--   Further note that the implementation of lax arrows does not use
--   <tt>unsafePerformIO</tt> nor <tt>unsafeInterleaveIO</tt> and is not
--   tied to <tt>IO</tt> at all.
--   
--   The lax arrow version of the <tt>looping</tt> example would be as
--   follows:
--   
--   <pre>
--   looping :: IO ()
--   looping = runKleisli (runLax (loop $ second $ impure (Kleisli putChar) &gt;&gt;&gt; arr (const 'A')))
--                        ()
--   </pre>
module Control.Arrow.Lax

-- | A lax arrow.
data LaxArrow base i o

-- | Transforms a value of the base arrow type into a lax arrow value. Pure
--   parts of the argument are not affected by relaxation, only parts of
--   the lax arrow value which are constructed with <a>arr</a> from the
--   <a>LaxArrow</a> instance of <a>Arrow</a>.
--   
--   <tt>lift</tt> from the <tt>ArrowTransformer</tt> class is not used
--   since it is probably supposed to be a homomorphism but <a>impure</a>
--   is not a homomorphism. While <a>impure</a> preserves
--   <a>&gt;&gt;&gt;</a>, it does not preserve <a>arr</a>, <a>first</a> and
--   <a>loop</a>. If it would then we would have no relaxation effect at
--   all.
impure :: ArrowLoop base => base i o -> LaxArrow base i o

-- | Converts a lax arrow value into a value of the base arrow type.
runLax :: Arrow base => LaxArrow base i o -> base i o
instance Arrow base => ArrowLoop (LaxArrow base)
instance Arrow base => Arrow (LaxArrow base)
instance Arrow base => Category (LaxArrow base)
