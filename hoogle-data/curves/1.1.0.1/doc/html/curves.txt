-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Library for drawing curve based images.
--   
--   Curves is an easy to use library for creating images. The basic
--   primitive is a curve, which, in the simplest case, is a continuous
--   function from a scalar parameter to a 2-dimensional point on the
--   curve. Images are rendered as PNG images.
@package curves
@version 1.1.0.1


-- | Write-only attributes.
module Graphics.Curves.Attribute

-- | Representation of an attribute update for an element of type
--   <tt>a</tt>.
data Assignment a

-- | Set an attribute
(:=) :: f b -> b -> Assignment a

-- | Modify an attribute
(:~) :: f b -> (b -> b) -> Assignment a

-- | The type constructor <tt>f</tt> is such that <tt>f b</tt> is the type
--   of names of attributes of <tt>a</tt> of type <tt>b</tt>.
class HasAttribute f a where setAttribute t x = modifyAttribute t (const x)
modifyAttribute :: HasAttribute f a => f b -> (b -> b) -> a -> a
setAttribute :: HasAttribute f a => f b -> b -> a -> a

-- | Apply a sequence of attribute assignments to an object (applied
--   left-to-right).
with :: a -> [Assignment a] -> a


-- | Simple two-dimensional linear algebra.
module Graphics.Curves.Math
type Scalar = Double

-- | Two-dimensional vectors.
data Vec
Vec :: !Scalar -> !Scalar -> Vec
getX :: Vec -> !Scalar
getY :: Vec -> !Scalar
type Point = Vec

-- | <pre>
--   unitX = Vec 1 0
--   </pre>
unitX :: Vec

-- | <pre>
--   unitY = Vec 0 1
--   </pre>
unitY :: Vec

-- | <pre>
--   diag x = Vec x x
--   </pre>
diag :: Scalar -> Vec

-- | Apply a function to the coordinates of a vector.
vmap :: (Scalar -> Scalar) -> Vec -> Vec

-- | Point-wise lifting of an operator on coordinates.
vzip :: (Scalar -> Scalar -> Scalar) -> Vec -> Vec -> Vec

-- | <pre>
--   vuncurry f (Vec x y) = f x y
--   </pre>
vuncurry :: (Scalar -> Scalar -> a) -> Vec -> a

-- | <pre>
--   vcurry f x y = f (Vec x y)
--   </pre>
vcurry :: (Vec -> a) -> Scalar -> Scalar -> a

-- | The dot product of two vectors.
dot :: Vec -> Vec -> Scalar

-- | Rotate a vector 90 degrees counterclockwise.
rot90 :: Vec -> Vec

-- | Normalize a vector.
--   
--   <pre>
--   norm v = v / abs v
--   </pre>
norm :: Vec -> Vec

-- | The counterclockwise angle between two vectors.
angle :: Vec -> Vec -> Scalar

-- | The weighted average of two points.
--   
--   <pre>
--   interpolate p q t == (1 - t) * p + t * q
--   </pre>
interpolate :: Point -> Point -> Scalar -> Point
data Segment
Seg :: !Point -> !Point -> Segment
getStart :: Segment -> !Point
getEnd :: Segment -> !Point

-- | The length of a segment.
--   
--   <pre>
--   segmentLength (Seg p q) = distance p q
--   </pre>
segmentLength :: Segment -> Scalar

-- | The square length of a segment. Avoids computing a square root.
squareSegmentLength :: Segment -> Scalar

-- | Is a point to the left of a line segment, as seen from the start of
--   the segment looking a the end?
leftOf :: Point -> Segment -> Bool

-- | Compute the intersection point of two segments, if any.
intersectSegment :: Segment -> Segment -> Maybe Point

-- | Compute the intersection point of two lines, if any.
intersectLine :: Segment -> Segment -> Maybe Point

-- | Compute the intersection point of a line and a segment, if any.
intersectLineSegment :: Segment -> Segment -> Maybe Point

-- | A basis for a coordinate system.
data Basis
Basis :: Point -> Point -> Point -> Basis
origin :: Basis -> Point
xUnit :: Basis -> Point
yUnit :: Basis -> Point

-- | <pre>
--   defaultBasis = Basis 0 unitX unitY
--   </pre>
defaultBasis :: Basis

-- | Translate a point from the <a>defaultBasis</a> to the given basis.
toBasis :: Basis -> Point -> Point

-- | Translate a point in the given basis to the <a>defaultBasis</a>.
fromBasis :: Basis -> Point -> Point
class DistanceToPoint a where distance x p = sqrt (squareDistance x p) squareDistance x p = distance x p ^ 2 distanceAtMost d x p = case distance x p of { d' | d' <= d -> Just d' | otherwise -> Nothing }
distance :: DistanceToPoint a => a -> Point -> Scalar
squareDistance :: DistanceToPoint a => a -> Point -> Scalar
distanceAtMost :: DistanceToPoint a => Scalar -> a -> Point -> Maybe Scalar
class Transformable a
transform :: Transformable a => (Point -> Point) -> a -> a

-- | <pre>
--   translate v = transform (+ v)
--   </pre>
translate :: Transformable a => Vec -> a -> a

-- | <pre>
--   scale v = transform (* v)
--   </pre>
scale :: Transformable a => Vec -> a -> a

-- | Scale using a given point as the center.
scaleFrom :: Transformable a => Point -> Vec -> a -> a

-- | Rotate an object counterclockwise around the origin.
rotate :: Transformable a => Scalar -> a -> a

-- | Rotate an object counterclockwise around a given point.
rotateAround :: Transformable a => Point -> Scalar -> a -> a

-- | Find the smallest value making a function satisfy a given predicate.
--   Needs the function to be monotone in the predicate to work properly.
findThreshold :: (Scalar -> a) -> (a -> Bool) -> Scalar -> Scalar -> Scalar -> Maybe (Scalar, a)
instance Eq Vec
instance Ord Vec
instance Eq Segment
instance Ord Segment
instance Show Basis
instance Eq Basis
instance Ord Basis
instance Transformable Basis
instance Transformable (Rigid a)
instance (Transformable a, Transformable b, Transformable c) => Transformable (a, b, c)
instance (Transformable a, Transformable b) => Transformable (a, b)
instance Transformable b => Transformable (a -> b)
instance Transformable ()
instance Transformable a => Transformable [a]
instance (Transformable a, Transformable b) => Transformable (Either a b)
instance Transformable a => Transformable (Maybe a)
instance Transformable Segment
instance Transformable Vec
instance DistanceToPoint Segment
instance DistanceToPoint Vec
instance Show Segment
instance Fractional Vec
instance Num Vec
instance Show Vec


-- | RGBA colour values.
module Graphics.Curves.Colour

-- | RGBA values in the range 0.0 to 1.0.
type Colour = Colour' Scalar

-- | RGBA values parameterised on the colour value type.
data Colour' a
Colour :: !a -> !a -> !a -> !a -> Colour' a
getRed :: Colour' a -> !a
getGreen :: Colour' a -> !a
getBlue :: Colour' a -> !a
getAlpha :: Colour' a -> !a
truncColour :: (Ord a, Num a) => Colour' a -> Colour' a

-- | <pre>
--   opacity a c = setAlpha (a * getAlpha c) c
--   </pre>
opacity :: Scalar -> Colour -> Colour

-- | <pre>
--   opaque = setAlpha 1
--   </pre>
opaque :: Colour -> Colour

-- | Set the alpha value of a colour.
setAlpha :: Scalar -> Colour -> Colour

-- | Check if a colour is completely transparent.
isTransparent :: Colour -> Bool

-- | <tt>visible c == Nothing</tt> iff <tt>isTransparent c</tt>
visible :: Colour -> Maybe Colour

-- | Completely transparent (and black) colour.
transparent :: Colour
white :: Colour
blue :: Colour
green :: Colour
red :: Colour
black :: Colour

-- | Alpha blending two colours.
blend :: Colour -> Colour -> Colour
instance Eq a => Eq (Colour' a)
instance Ord a => Ord (Colour' a)
instance Functor Colour'
instance Foldable Colour'
instance Traversable Colour'
instance (Ord a, Num a) => Num (Colour' a)
instance Show a => Show (Colour' a)
instance Applicative Colour'

module Graphics.Curves.Style

-- | Style attributes of a curve. The line width is with width in pixels of
--   the solid part of the curve. Outside the line width the curve fades to
--   full transparency in a band whose width is determined by the line blur
--   attribute. All line attributes can be parameterized by the absolute
--   (in pixels) and relative distance from the start of the curve.
--   
--   A set of closed curves combined with <a>+++</a> can be filled using a
--   fill colour (<a>transparent</a> for no fill) or a texture. A texture
--   is a function that computes a colour value given the position of the
--   point being filled, both in absolute pixels and relative to the
--   texture basis. The texture basis is <a>defaultBasis</a> by default and
--   is transformed with the image. Typically you would use the absolute
--   position for rasterisation and the relative position for textures.
--   
--   A point is deemed inside the curves if a ray starting at the point
--   intersects with the curves an odd number of times. The fill blur is
--   the width of the band around the curve edge in which the fill colour
--   fades to full transparency. Setting the fill colour of a non-closed
--   curve results in unspecified behaviour.
data CurveAttribute :: * -> *
LineWidth :: CurveAttribute Scalar
LineBlur :: CurveAttribute Scalar
LineColour :: CurveAttribute Colour
VarLineWidth :: CurveAttribute (Scalar -> Scalar -> Point -> Scalar)
VarLineBlur :: CurveAttribute (Scalar -> Scalar -> Point -> Scalar)
VarLineColour :: CurveAttribute (Scalar -> Scalar -> Point -> Colour)
FillBlur :: CurveAttribute Scalar
FillColour :: CurveAttribute Colour
Texture :: CurveAttribute (Point -> Point -> Colour)
TextureBasis :: CurveAttribute Basis

-- | A style is a list of attribute assignments.
type Style = [Assignment Image]

-- | Setting the line width, blur and colour.
lineStyle :: Scalar -> Scalar -> Colour -> Style

-- | Setting the fill blur and colour.
fillStyle :: Scalar -> Colour -> Style

-- | Dynamic line width style that tapers off at the end points. First
--   argument is maximum width and the second the length of the tapering
--   off part.
brushStyle :: Scalar -> Scalar -> Style

-- | Fade from the first to the second colour and then back. The third
--   argument in the distance in pixels it takes to reach the second
--   colour.
gradient :: Colour -> Colour -> Scalar -> Style

-- | A dashed line style. The first argument is the approximate length (in
--   pixels) of the dashes and the second argument of the gaps. The lengths
--   are adjusted to make the curve always end in a dash.
dashedOpen :: Scalar -> Scalar -> Style

-- | A dashed line style. The first argument is the approximate length (in
--   pixels) of the dashes and the second argument of the gaps. The lengths
--   are adjusted to make the curve always end in a gap so closed curves
--   have a smooth transition where the end of the curve meets the start.
dashedClosed :: Scalar -> Scalar -> Style

-- | A dashed line style. The first argument is the lengths (in pixels) of
--   the dashes and the second argument of the gaps.
dashed :: Scalar -> Scalar -> Style


-- | Curves is an easy to use library for creating images. The basic
--   primitive is a curve, which, in the simplest case, is a continuous
--   function from a <a>Scalar</a> parameter to a 2-dimensional
--   <a>Point</a> on the <a>curve</a>. Images are rendered
--   (<a>renderImage</a>) as PNG images.
module Graphics.Curves

-- | The image type.
data Image

-- | A single point.
point :: Point -> Image

-- | A straight line between two points.
line :: Point -> Point -> Image

-- | A connected sequence of straight lines. The list must have at least
--   two elements.
lineStrip :: [Point] -> Image

-- | A polygon.
--   
--   <pre>
--   poly ps = lineStrip (ps ++ [head ps])
--   </pre>
poly :: [Point] -> Image

-- | A circle given by its center and radius.
circle :: Point -> Scalar -> Image

-- | A circle segment. The third and fourth arguments are the start and end
--   angle of the segment. If the start angle is bigger than the end angle
--   it's the clockwise segment, otherwise the counterclockwise segment.
--   For instance, <tt>circleSegment 0 1 0 pi</tt> is the top half circle
--   starting in <a>unitX</a> and ending in <tt>-<a>unitX</a></tt>, whereas
--   <tt>circleSegment 0 1 0 (-pi)</tt> is the bottow half circle with the
--   same start and end points.
circleSegment :: Point -> Scalar -> Scalar -> Scalar -> Image

-- | A simple curve whose points are given by the function argument. The
--   first two arguments specify the range of the function. The function
--   must be continuous on this interval.
--   
--   For example, a straight line between points <tt>p</tt> and <tt>q</tt>
--   can be implemented as
--   
--   <pre>
--   curve 0 1 (<a>interpolate</a> p q)
--   </pre>
curve :: Scalar -> Scalar -> (Scalar -> Point) -> Image

-- | <pre>
--   curve_ = <a>curve</a> 0 1
--   </pre>
curve_ :: (Scalar -> Point) -> Image

-- | The most general form of curve. The curve function is split in two,
--   one function from the parameter to an arbitrary <a>Transformable</a>
--   object, and a second function from this object (and the parameter
--   value) to a point on the curve. The power of this combinator comes
--   from the fact that transformations (e.g. <a>translate</a>,
--   <a>scale</a>, <a>rotate</a>) of the curve apply only to the (result of
--   the) first function. This means that the points computed by the second
--   function are measured in pixels of the final image.
--   
--   For an example, see the <a>arrow</a> combinator, which uses a line
--   <a>Segment</a> as the intermediate type and computes the arrow head in
--   the second function, to ensure that the arrow head has the same
--   dimensions regardless of how the arrow is scaled.
curve' :: Transformable a => Scalar -> Scalar -> (Scalar -> a) -> (Scalar -> a -> Point) -> Image

-- | A <a>uniform cubic B-spline</a> with the given control points.
bSpline :: [Point] -> Image

-- | A B-spline which starts in the first control point and ends in the
--   last control point. This is achieved by adding two extra copies of the
--   first and last points.
bSpline' :: [Point] -> Image

-- | A closed B-spline.
--   
--   <pre>
--   closedBSpline ps = bSpline (ps ++ take 3 ps)
--   </pre>
closedBSpline :: [Point] -> Image

-- | A strip of cubic Bézier curves.
bezier :: [Point] -> Image

-- | A Bézier curve of degree n with the given control points <tt>[p0 ..
--   pn]</tt>.
bezierSegment :: [Point] -> Image

-- | Reverse the direction of all curves in an image. Useful in conjunction
--   with <a>+++</a>.
reverseImage :: Image -> Image

-- | Join the right-most curve of the first image to the left-most curve of
--   the second image. The <a>Style</a> is inherited from the curve of the
--   first image. If the end point of the first curve does not coincide
--   with the starting point of the second curve a straight line is added
--   to connect the two. This combinator is useful when using parameterized
--   line styles (such as <a>dashed</a>).
(+++) :: Image -> Image -> Image

-- | Like <a>+++</a> but doesn't join the end points of the curves.
(+.+) :: Image -> Image -> Image

-- | Prepend a point to the left-most curve of an image. <tt>p &lt;++
--   i</tt> is equivalent to <tt><a>line</a> p q <a>+++</a> i</tt> if
--   <tt>q</tt> is the starting point of the left-most curve of <tt>i</tt>.
(<++) :: Point -> Image -> Image

-- | Append a point to the right-most curve of an image. <tt>i ++&gt;
--   p</tt> is equivalent to <tt>i <a>+++</a> <a>line</a> q p</tt> if
--   <tt>q</tt> is the end point of the right-most curve of <tt>i</tt>.
(++>) :: Image -> Point -> Image

-- | Differentiating the curves of an image
differentiate :: Image -> Image

-- | Apply a function to all points of an image. The function also gets the
--   curve parameter (between 0 and 1) of the given point. This applies
--   after all transformations so the points are measured in pixels, unless
--   the image is later unfrozen with <a>unfreezeImage</a>.
mapImage :: (Scalar -> Point -> Point) -> Image -> Image

-- | Zipping two images. Both images must have the same number of curves
--   <a>combine</a>d in the same order. As with <a>mapImage</a> the zipping
--   takes place after all transformations.
zipImage :: (Scalar -> Point -> Point -> Point) -> Image -> Image -> Image

-- | Apply a transformation to an image. Unlike <a>mapImage</a> the
--   transformation is applied immediately.
transformImage :: (forall a. Transformable a => Scalar -> a -> a) -> Image -> Image

-- | Compute the length of the curves of an image by approximating it by a
--   series of straight-line segments, each no longer than specified by the
--   first argument.
curveLength :: Scalar -> Image -> Scalar

-- | Freeze the size of an image around the given point. Scaling the image
--   will only affect the position of the image, not the size. Translation
--   and rotation affect the image normally.
--   
--   <pre>
--   <a>scaleFrom</a> p (<a>diag</a> k) (freezeImageSize p i) == freezeImageSize p i
--   </pre>
--   
--   Scaling with non-uniform scale factors will still distort the image,
--   however.
freezeImageSize :: Point -> Image -> Image

-- | Freeze image orientation. Rotations of the image will only affect the
--   position of the image, not its orientation. Translation and scaling
--   affect the image normally.
--   
--   <pre>
--   <a>rotateAround</a> p a (freezeImageOrientation p i) == freezeImageOrientation p i
--   </pre>
freezeImageOrientation :: Point -> Image -> Image

-- | Freeze both the size and the orientation of an image.
--   
--   <pre>
--   freezeImage p i == <a>freezeImageSize</a> p i (<a>freezeImageOrientation</a> p i)
--   </pre>
freezeImage :: Point -> Image -> Image

-- | Freeze the line style of an image. This means that the pixel
--   parameters (distance along the curve and pixel position) are given as
--   they are at this moment, and won't be affected by later
--   transformations.
freezeImageStyle :: Image -> Image

-- | Unfreeze an image. After unfreezing any frozen features will be
--   affected by transformations again.
unfreezeImage :: Image -> Image

-- | A blend function is used to compute the resulting colour when
--   <a>combine</a>ing two images.
type BlendFunc = Maybe Colour -> Maybe Colour -> Maybe Colour

-- | Combine two images using the specified blend function.
combine :: BlendFunc -> Image -> Image -> Image

-- | Map a function over the colours of an image.
mapColour :: (Colour -> Colour) -> Image -> Image

-- | Alpha <a>blend</a> the first colour on top of the second colour.
unionBlend :: BlendFunc

-- | The alpha value of the result is the product of the alpha values of
--   the two inputs.
intersectBlend :: BlendFunc

-- | Multiplies the alpha value of the first colour by 1 - the alpha value
--   of the second colour.
diffBlend :: BlendFunc

-- | An infix synonym for <a>mappend</a>.
(<>) :: Monoid m => m -> m -> m

-- | The intersection of two images.
--   
--   <pre>
--   (&gt;&lt;) = combine intersectBlend
--   </pre>
(><) :: Image -> Image -> Image

-- | Subtract the second image from the first.
--   
--   <pre>
--   (&lt;-&gt;) = combine diffBlend
--   </pre>
(<->) :: Image -> Image -> Image

-- | Compute the bounds of an image, returning a line segment from the
--   bottom left corner to the top right corner of the bounding box. This
--   function ignores line widths. Note that using pixel based features
--   (for instance, produced by <a>freezeImageSize</a>) means that the
--   bounds may become invalid if the image is scaled.
imageBounds :: Image -> Segment
sampleImage :: Image -> Scalar -> [[Point]]

-- | Scale the an image to fit inside the the box given by the two points
--   (bottom-left and top-right corners).
autoFit :: Point -> Point -> Image -> Image

-- | Scale the an image to fit inside the the box given by the two points
--   (bottom-left and top-right corners). Does not preserve aspect ratio.
autoStretch :: Point -> Point -> Image -> Image

-- | Render an image as a PNG file with a 1-bit alpha channel.
--   Semi-transparent pixels in the image are blended with the given
--   background colour to produce opaque pixels.
renderImage :: FilePath -> Int -> Int -> Colour -> Image -> IO ()
version :: String
instance ImageElement Vec
instance ImageElement Segment
instance ImageElement Image


-- | Simple (ugly) hand-crafted text. See <a>Graphics.Curves.SVG.Font</a>
--   for prettier text.
module Graphics.Curves.Text
data Alignment
LeftAlign :: Alignment
RightAlign :: Alignment
CenterAlign :: Alignment

-- | Equivalent to <tt><a>stringImage'</a> LeftAlign 0.2</tt>.
stringImage :: String -> Image

-- | Draw a string at the origin with the given text alignment. The second
--   argument specifies the spacing between characters. Upper-case letters
--   are 2 units high.
stringImage' :: Alignment -> Scalar -> String -> Image

-- | Draw a string centered at a given point. The second argument specifies
--   the font height in pixels, invariant under scaling.
label :: Point -> Scalar -> String -> Image


-- | Combinators for drawing various geometric figures.
module Graphics.Curves.Geometry

-- | Draw an axis-aligned rectangle with the given opposite corners.
rectangle :: Point -> Point -> Image
type Length = Scalar
type Angle = Scalar

-- | Draw a triangle with the given side lengths. The corner opposite the
--   third side is located at the origin and the first side is drawn along
--   the x-axis.
triangle :: Length -> Length -> Length -> Image

-- | Draw a triangle given by two side lengths and an angle. The corner of
--   the angle is drawn at the origin and the first side along the x-axis.
triangleA :: Length -> Length -> Angle -> Image

-- | Draw a triangle given by two angles and the length of the side shared
--   by the angles. The first angle is drawn at the origin and the side
--   along the x-axis.
triangleAA :: Length -> Angle -> Angle -> Image

-- | Draw an n-sided regular polygon centered at the origin and one corner
--   at <a>unitY</a>.
regularPoly :: Int -> Image

-- | Draw an angle arc for the counter clockwise angle BAC.
angleArc :: Scalar -> Point -> Point -> Point -> Image

-- | Draw an angle arc labelled by the given string.
labelledAngle :: String -> Vec -> Point -> Point -> Point -> Image

-- | Draw a line segment with an arrow head.
arrow :: Point -> Point -> Image

module Graphics.Curves.Graph

-- | Draw the graph of a function together with axis and some guides.
graph :: Scalar -> Scalar -> (Scalar -> Scalar) -> Image

module Graphics.Curves.SVG.Path

-- | A path is a sequence of path commands.
type Path = [PathCmd]

-- | Path commands can use absolute or relative coordinates.
data CoordType
Absolute :: CoordType
Relative :: CoordType

-- | The path commands specified by
--   <a>http://www.w3.org/TR/SVG/paths.html#PathData</a>.
data PathCmd
MoveTo :: CoordType -> Point -> PathCmd
LineTo :: CoordType -> Point -> PathCmd
HorLineTo :: CoordType -> Scalar -> PathCmd
VerLineTo :: CoordType -> Scalar -> PathCmd

-- | number of points = degree of the Bézier curve
BezierTo :: CoordType -> [Point] -> PathCmd

-- | first control point is the mirror of the previous control point
SmoothBezierTo :: CoordType -> [Point] -> PathCmd
ArcTo :: CoordType -> Vec -> Scalar -> Bool -> Bool -> Point -> PathCmd
ClosePath :: PathCmd

-- | Read a path string.
parsePath :: String -> Path

-- | Render a path.
drawPath :: Path -> Image
instance Show CoordType
instance Show PathCmd
instance Show PathToken


-- | This module contains functions to render text using fonts specified in
--   the <a>SVG format</a>.
module Graphics.Curves.SVG.Font

-- | Contains all the data necessary to render text.
data SVGFont

-- | Read a font from an SVG file.
loadFont :: FilePath -> IO SVGFont

-- | Render a string in the given font. The text starts at the origin and
--   is scaled to make upper case letters 1 unit high.
drawString :: SVGFont -> String -> Image


-- | The Liberation font from
--   <a>https://fedorahosted.org/liberation-fonts</a>.
module Graphics.Curves.Text.Fonts.Liberation
data Modifier
Bold :: Modifier
Italic :: Modifier
data FontStyle
Mono :: FontStyle
Sans :: FontStyle
Serif :: FontStyle
liberation :: FontStyle -> [Modifier] -> SVGFont
instance Show Modifier
instance Eq Modifier
instance Ord Modifier
instance Show FontStyle
instance Eq FontStyle
instance Ord FontStyle
