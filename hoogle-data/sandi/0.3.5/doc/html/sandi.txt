-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Data encoding library
--   
@package sandi
@version 0.3.5


-- | Implementation based on the specification found at
--   <a>http://yence.sourceforge.net/docs/protocol/version1_3_draft.html</a>.
module Codec.Binary.Yenc

-- | Encoding function.
--   
--   This function allocates enough space to hold 20% more than the size of
--   the indata (or at least 512 bytes) and then encodes as much as
--   possible of the indata. That means there is a risk that the encoded
--   data won't fit and in that case the second part of the pair contains
--   the remainder of the indata.
--   
--   <pre>
--   &gt;&gt;&gt; y_enc $ Data.ByteString.Char8.pack "foobar"
--   ("\144\153\153\140\139\156","")
--   
--   &gt;&gt;&gt; snd $ y_enc $ Data.ByteString.Char8.pack $ Data.List.take 257 $ repeat '\x13'
--   "\DC3"
--   </pre>
y_enc :: ByteString -> (ByteString, ByteString)

-- | Decoding function.
--   
--   <pre>
--   &gt;&gt;&gt; y_dec $ Data.ByteString.pack [144,153,153,140,139,156]
--   Right ("foobar","")
--   
--   &gt;&gt;&gt; y_dec $ Data.ByteString.Char8.pack "=}"
--   Right ("\DC3","")
--   </pre>
--   
--   A <tt>Left</tt> value is only ever returned on decoding errors which,
--   due to characteristics of the encoding, can never happen.
--   
--   <pre>
--   &gt;&gt;&gt; y_dec $ Data.ByteString.Char8.pack "="
--   Right ("","=")
--   </pre>
y_dec :: ByteString -> Either (ByteString, ByteString) (ByteString, ByteString)

-- | Convenient function that calls <a>y_enc</a> repeatedly until the whole
--   input data is encoded.
encode :: ByteString -> ByteString

-- | A synonym for <a>y_dec</a>.
decode :: ByteString -> Either (ByteString, ByteString) ByteString


module Data.Conduit.Codec.Yenc
encode :: Monad m => Conduit ByteString m ByteString
decode :: (Monad m, MonadThrow m) => Conduit ByteString m ByteString


-- | Xxencoding is obsolete but still included for completeness. Further
--   information on the encoding can be found at
--   <a>http://en.wikipedia.org/wiki/Xxencode</a>. It should be noted that
--   this implementation performs no padding.
--   
--   This encoding is very similar to uuencoding, therefore further
--   information regarding the functions can be found in the documentation
--   of <a>Codec.Binary.Uu</a>.
module Codec.Binary.Xx

-- | Encoding function.
--   
--   <pre>
--   &gt;&gt;&gt; xx_encode_part $ Data.ByteString.Char8.pack "foo"
--   ("Naxj","")
--   
--   &gt;&gt;&gt; xx_encode_part $ Data.ByteString.Char8.pack "foob"
--   ("Naxj","b")
--   </pre>
xx_encode_part :: ByteString -> (ByteString, ByteString)

-- | Encoding function for the final block.
--   
--   <pre>
--   &gt;&gt;&gt; xx_encode_final $ Data.ByteString.Char8.pack "r"
--   Just "QU"
--   
--   &gt;&gt;&gt; xx_encode_final $ Data.ByteString.Char8.pack "foo"
--   Nothing
--   </pre>
xx_encode_final :: ByteString -> Maybe ByteString

-- | Decoding function.
--   
--   <pre>
--   &gt;&gt;&gt; xx_decode_part $ Data.ByteString.Char8.pack "Naxj"
--   Right ("foo","")
--   
--   &gt;&gt;&gt; xx_decode_part $ Data.ByteString.Char8.pack "NaxjMa3"
--   Right ("foo","Ma3")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; xx_decode_part $ Data.ByteString.Char8.pack "Na j"
--   Left ("","Na J")
--   </pre>
xx_decode_part :: ByteString -> Either (ByteString, ByteString) (ByteString, ByteString)

-- | Decoding function for the final block.
--   
--   <pre>
--   &gt;&gt;&gt; xx_decode_final $ Data.ByteString.Char8.pack "Naw"
--   Just "fo"
--   
--   &gt;&gt;&gt; xx_decode_final $ Data.ByteString.Char8.pack ""
--   Just ""
--   
--   &gt;&gt;&gt; xx_decode_final $ Data.ByteString.Char8.pack "Na "
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; xx_decode_final $ encode $ Data.ByteString.Char8.pack "foo"
--   Nothing
--   </pre>
xx_decode_final :: ByteString -> Maybe ByteString
encode :: ByteString -> ByteString
decode :: ByteString -> Either (ByteString, ByteString) ByteString


module Data.Conduit.Codec.Xx
encode :: Monad m => Conduit ByteString m ByteString
decode :: (Monad m, MonadThrow m) => Conduit ByteString m ByteString


-- | Uuencoding is notoriously badly specified. This implementation aims at
--   being compatible with the GNU Sharutils
--   (<a>http://www.gnu.org/software/sharutils/</a>).
--   
--   Just like Base64 encoding uuencoding expands blocks of 3 bytes into
--   blocks of 4 bytes. There is however no well defined ending to a piece
--   of encoded data, instead uuencoded data is commonly transferred
--   linewise where each line is prepended with the length of the data in
--   the line.
--   
--   This module currently only deals with the encoding. Chopping the
--   encoded data into lines, and unchopping lines into encoded data is
--   left as an exercise to the reader. (Patches are welcome.)
module Codec.Binary.Uu

-- | Encoding function.
--   
--   This function encodes as large a portion of the input as possible and
--   returns the encoded part together with the remaining part. Enough
--   space is allocated for the encoding to make sure that the remaining
--   part is less than 3 bytes long, which means it can be passed to
--   <a>uu_encode_final</a> as is.
--   
--   <pre>
--   &gt;&gt;&gt; uu_encode_part $ Data.ByteString.Char8.pack "foo"
--   ("9F]O","")
--   
--   &gt;&gt;&gt; uu_encode_part $ Data.ByteString.Char8.pack "foob"
--   ("9F]O","b")
--   </pre>
uu_encode_part :: ByteString -> (ByteString, ByteString)

-- | Encoding function for the final block.
--   
--   The final block has to have a size less than 3.
--   
--   <pre>
--   &gt;&gt;&gt; uu_encode_final $ Data.ByteString.Char8.pack "r"
--   Just "&lt;@"
--   </pre>
--   
--   Trying to pass in too large a block result in failure:
--   
--   <pre>
--   &gt;&gt;&gt; uu_encode_final $ Data.ByteString.Char8.pack "foo"
--   Nothing
--   </pre>
uu_encode_final :: ByteString -> Maybe ByteString

-- | Decoding function.
--   
--   Decode as large a portion of the input as possible. Enough data is
--   allocated for the output to ensure that the remainder is less than 4
--   bytes in size. Success result in a <tt>Right</tt> value:
--   
--   <pre>
--   &gt;&gt;&gt; uu_decode_part $ Data.ByteString.Char8.pack "9F]O"
--   Right ("foo","")
--   
--   &gt;&gt;&gt; uu_decode_part $ Data.ByteString.Char8.pack "9F]O8F$"
--   Right ("foo","8F$")
--   </pre>
--   
--   Failures occur on bad input and result in a <tt>Left</tt> value:
--   
--   <pre>
--   &gt;&gt;&gt; uu_decode_part $ Data.ByteString.Char8.pack "9F 0"
--   Left ("","9F 0")
--   </pre>
uu_decode_part :: ByteString -> Either (ByteString, ByteString) (ByteString, ByteString)

-- | Decoding function for the final block.
--   
--   The final block has to have a size of 0 or 4:
--   
--   <pre>
--   &gt;&gt;&gt; uu_decode_final $ Data.ByteString.Char8.pack "9F\\"
--   Just "fo"
--   
--   &gt;&gt;&gt; uu_decode_final $ Data.ByteString.Char8.pack ""
--   Just ""
--   
--   &gt;&gt;&gt; uu_decode_final $ Data.ByteString.Char8.pack "9F¬"
--   Nothing
--   </pre>
--   
--   But it must be the encoding of a block that is less than 3 bytes:
--   
--   <pre>
--   &gt;&gt;&gt; uu_decode_final $ encode $ Data.ByteString.Char8.pack "foo"
--   Nothing
--   </pre>
uu_decode_final :: ByteString -> Maybe ByteString

-- | Convenience function that combines <a>uu_encode_part</a> and
--   <a>uu_encode_final</a> to encode a complete string.
--   
--   <pre>
--   &gt;&gt;&gt; encode $ Data.ByteString.Char8.pack "foo"
--   "9F]O"
--   
--   &gt;&gt;&gt; encode $ Data.ByteString.Char8.pack "foobar"
--   "9F]O8F%R"
--   </pre>
encode :: ByteString -> ByteString

-- | Convenience function that combines <a>uu_decode_part</a> and
--   <a>uu_decode_final</a> to decode a complete string.
--   
--   <pre>
--   &gt;&gt;&gt; decode $ Data.ByteString.Char8.pack "9F]O"
--   Right "foo"
--   
--   &gt;&gt;&gt; decode $ Data.ByteString.Char8.pack "9F]O8F%R"
--   Right "foobar"
--   </pre>
--   
--   Failures when decoding returns the decoded part and the remainder:
--   
--   <pre>
--   &gt;&gt;&gt; decode $ Data.ByteString.Char8.pack "9F]O8F¬R"
--   Left ("foo","8F\172R")
--   </pre>
decode :: ByteString -> Either (ByteString, ByteString) ByteString


module Data.Conduit.Codec.Uu
encode :: Monad m => Conduit ByteString m ByteString
decode :: (Monad m, MonadThrow m) => Conduit ByteString m ByteString


-- | Implementation of Quoted-Printable based on RFC 2045
--   (<a>http://tools.ietf.org/html/rfc2045</a>).
--   
--   This encoding encodes <i>everything</i> that is passed in, it will not
--   try to guess the native line ending for your architecture. In other
--   words, if you are using this to encode text you need to split it into
--   separate lines before encoding.
module Codec.Binary.QuotedPrintable

-- | Encoding function.
--   
--   This function allocates enough space to hold twice the size of the
--   indata (or at least 512 bytes) and then encodes as much as possible of
--   the indata. That means there is a risk that the encoded data won't fit
--   and in that case the second part of the pair contains the remainder of
--   the indata.
--   
--   <pre>
--   &gt;&gt;&gt; qp_enc $ Data.ByteString.Char8.pack "="
--   ("=3D","")
--   
--   &gt;&gt;&gt; snd $ qp_enc $ Data.ByteString.Char8.pack $ Data.List.take 171 $ repeat '='
--   "="
--   </pre>
qp_enc :: ByteString -> (ByteString, ByteString)

-- | Decoding function.
--   
--   <pre>
--   &gt;&gt;&gt; qp_dec $ Data.ByteString.Char8.pack "foobar"
--   Right "foobar"
--   
--   &gt;&gt;&gt; qp_dec $ Data.ByteString.Char8.pack "1=20+=201=20=3D=202"
--   Right "1 + 1 = 2"
--   </pre>
--   
--   The input data is allowed to use lowercase letters in the hexadecimal
--   representation of an octets value, even though the standard says that
--   only uppercase letters may be used:
--   
--   <pre>
--   &gt;&gt;&gt; qp_dec $ Data.ByteString.Char8.pack "=3D"
--   Right "="
--   
--   &gt;&gt;&gt; qp_dec $ Data.ByteString.Char8.pack "=3d"
--   Right "="
--   </pre>
--   
--   It also allows the input to encode _all_ octets in the hexadecimal
--   representation:
--   
--   <pre>
--   &gt;&gt;&gt; qp_dec $ Data.ByteString.Char8.pack "=20!"
--   Right (" !","")
--   
--   &gt;&gt;&gt; qp_dec $ Data.ByteString.Char8.pack "=20=21"
--   Right (" !","")
--   </pre>
--   
--   A <tt>Left</tt> value is only ever returned on decoding errors.
--   
--   <pre>
--   &gt;&gt;&gt; qp_dec $ Data.ByteString.Char8.pack "=2"
--   Right ("","=2")
--   
--   &gt;&gt;&gt; qp_dec $ Data.ByteString.Char8.pack "=2g"
--   Left ("","=2g")
--   </pre>
qp_dec :: ByteString -> Either (ByteString, ByteString) (ByteString, ByteString)

-- | Convenient function that calls <a>qp_enc</a> repeatedly until the
--   whole input data is encoded.
encode :: ByteString -> ByteString

-- | A synonym for <a>qp_dec</a>.
decode :: ByteString -> Either (ByteString, ByteString) ByteString


module Data.Conduit.Codec.QuotedPrintable
encode :: Monad m => Conduit ByteString m ByteString
decode :: (Monad m, MonadThrow m) => Conduit ByteString m ByteString


-- | Implemented as described at
--   <a>http://en.wikipedia.org/wiki/Ascii85</a>.
module Codec.Binary.Base85

-- | Encoding function.
--   
--   Encodes as large a part as possible of the indata.
--   
--   <pre>
--   &gt;&gt;&gt; b85_encode_part $ Data.ByteString.Char8.pack "foobar"
--   ("AoDTs","ar")
--   </pre>
--   
--   It supports special handling of both all-zero groups and all-space
--   groups.
--   
--   <pre>
--   &gt;&gt;&gt; b85_encode_part $ Data.ByteString.Char8.pack "    "
--   ("y", "")
--   
--   &gt;&gt;&gt; b85_encode_part $ Data.ByteString.Char8.pack "\0\0\0\0"
--   ("z", "")
--   </pre>
b85_encode_part :: ByteString -> (ByteString, ByteString)

-- | Encoding function for the final block.
--   
--   <pre>
--   &gt;&gt;&gt; b85_encode_final $ Data.ByteString.Char8.pack "ar"
--   Just "@&lt;)"
--   </pre>
b85_encode_final :: ByteString -> Maybe ByteString

-- | Decoding function.
--   
--   Decode as large a portion of the input as possible.
--   
--   <pre>
--   &gt;&gt;&gt; b85_decode_part $ Data.ByteString.Char8.pack "AoDTs"
--   Right ("foob","")
--   
--   &gt;&gt;&gt; b85_decode_part $ Data.ByteString.Char8.pack "AoDTs@&lt;)"
--   Right ("foob","@&lt;)")
--   
--   &gt;&gt;&gt; b85_decode_part $ Data.ByteString.Char8.pack "@&lt;)"
--   Right ("","@&lt;)")
--   </pre>
--   
--   At least 512 bytes of data is allocated for the output, but because of
--   the special handling of all-zero and all-space groups it is possible
--   that the space won't be enough. (To be sure to always fit the output
--   one would have to allocate 5 times the length of the input. It seemed
--   a good trade-off to sometimes have to call the function more than once
--   instead.)
--   
--   <pre>
--   &gt;&gt;&gt; either snd snd $ b85_decode_part $ Data.ByteString.Char8.pack $ Prelude.take 129 $ repeat 'y'
--   "y"
--   </pre>
b85_decode_part :: ByteString -> Either (ByteString, ByteString) (ByteString, ByteString)

-- | Decoding function for the final block.
--   
--   <pre>
--   &gt;&gt;&gt; b85_decode_final $ Data.ByteString.Char8.pack "@&lt;)"
--   Just "ar"
--   
--   &gt;&gt;&gt; b85_decode_final $ Data.ByteString.Char8.pack ""
--   Just ""
--   
--   &gt;&gt;&gt; b85_decode_final $ Data.ByteString.Char8.pack "AoDTs"
--   Nothing
--   </pre>
b85_decode_final :: ByteString -> Maybe ByteString

-- | Convenience function that combines <a>b85_encode_part</a> and
--   <a>b85_encode_final</a> to encode a complete string.
--   
--   <pre>
--   &gt;&gt;&gt; encode  $ Data.ByteString.Char8.pack "foob"
--   "AoDTs"
--   
--   &gt;&gt;&gt; encode  $ Data.ByteString.Char8.pack "foobar"
--   "AoDTs@&lt;)"
--   </pre>
encode :: ByteString -> ByteString

-- | Convenience function that combines <a>b85_decode_part</a> and
--   <a>b85_decode_final</a> to decode a complete string.
--   
--   <pre>
--   &gt;&gt;&gt; decode  $ Data.ByteString.Char8.pack "AoDTs"
--   "foob"
--   
--   &gt;&gt;&gt; encode  $ Data.ByteString.Char8.pack "AoDTs@&lt;)"
--   "foobar"
--   </pre>
decode :: ByteString -> Either (ByteString, ByteString) ByteString


module Data.Conduit.Codec.Base85
encode :: Monad m => Conduit ByteString m ByteString
decode :: (Monad m, MonadThrow m) => Conduit ByteString m ByteString


-- | Implemented as specified in RFC 4648
--   (<a>http://tools.ietf.org/html/rfc4648</a>).
--   
--   The difference compared to vanilla Base64 encoding is just in two
--   characters. In Base64 the characters <tt>/+</tt> are used, and in
--   Base64Url they are replaced by <tt>_-</tt> respectively.
--   
--   Please refer to <a>Codec.Binary.Base64</a> for the details of all
--   functions in this module.
module Codec.Binary.Base64Url
b64u_encode_part :: ByteString -> (ByteString, ByteString)
b64u_encode_final :: ByteString -> Maybe ByteString
b64u_decode_part :: ByteString -> Either (ByteString, ByteString) (ByteString, ByteString)
b64u_decode_final :: ByteString -> Maybe ByteString
encode :: ByteString -> ByteString
decode :: ByteString -> Either (ByteString, ByteString) ByteString


module Data.Conduit.Codec.Base64Url
encode :: Monad m => Conduit ByteString m ByteString
decode :: (Monad m, MonadThrow m) => Conduit ByteString m ByteString


-- | Implemented as specified in RFC 4648
--   (<a>http://tools.ietf.org/html/rfc4648</a>).
--   
--   Base64 encoding works by expanding blocks of 3 bytes of data into
--   blocks of 4 bytes of data. Finally it also includes a well defined
--   ending of the encoded data to make sure the size of the final block of
--   encoded data is 4 bytes too.
module Codec.Binary.Base64

-- | Encoding function.
--   
--   This function encodes as large a portion of the input as possible and
--   returns the encoded part together with the remaining part. Enough
--   space is allocated for the encoding to make sure that the remaining
--   part is less than 3 bytes long, which means it can be passed to
--   <a>b64_encode_final</a> as is.
--   
--   <pre>
--   &gt;&gt;&gt; b64_encode_part $ Data.ByteString.Char8.pack "foo"
--   ("Zm9v","")
--   
--   &gt;&gt;&gt; b64_encode_part $ Data.ByteString.Char8.pack "foob"
--   ("Zm9v","b")
--   </pre>
b64_encode_part :: ByteString -> (ByteString, ByteString)

-- | Encoding function for the final block.
--   
--   The final block has to have a size less than 3.
--   
--   <pre>
--   &gt;&gt;&gt; b64_encode_final $ Data.ByteString.Char8.pack "r"
--   Just "cg=="
--   </pre>
--   
--   Trying to pass in too large a block result in failure:
--   
--   <pre>
--   &gt;&gt;&gt; b64_encode_final $ Data.ByteString.Char8.pack "foo"
--   Nothing
--   </pre>
b64_encode_final :: ByteString -> Maybe ByteString

-- | Decoding function.
--   
--   Decode as large a portion of the input as possible. Enough data is
--   allocated for the output to ensure that the remainder is less than 4
--   bytes in size. Success result in a <tt>Right</tt> value:
--   
--   <pre>
--   &gt;&gt;&gt; b64_decode_part $ Data.ByteString.Char8.pack "Zm9v"
--   Right ("foo","")
--   
--   &gt;&gt;&gt; b64_decode_part $ Data.ByteString.Char8.pack "Zm9vYmE="
--   Right ("foo","YmE=")
--   </pre>
--   
--   Failures occur on bad input and result in a <tt>Left</tt> value:
--   
--   <pre>
--   &gt;&gt;&gt; b64_decode_part $ Data.ByteString.Char8.pack "Z=9v"
--   Left ("","Z=9v")
--   </pre>
b64_decode_part :: ByteString -> Either (ByteString, ByteString) (ByteString, ByteString)

-- | Decoding function for the final block.
--   
--   The final block has to have a size of 0 or 4:
--   
--   <pre>
--   &gt;&gt;&gt; b64_decode_final $ Data.ByteString.Char8.pack "Zm8="
--   Just "fo"
--   
--   &gt;&gt;&gt; b64_decode_final $ Data.ByteString.Char8.pack ""
--   Just ""
--   
--   &gt;&gt;&gt; b64_decode_final $ Data.ByteString.Char8.pack "Zm="
--   Nothing
--   </pre>
--   
--   But it must be the encoding of a block that is less than 3 bytes:
--   
--   <pre>
--   &gt;&gt;&gt; b64_decode_final $ encode $ Data.ByteString.Char8.pack "foo"
--   Nothing
--   </pre>
b64_decode_final :: ByteString -> Maybe ByteString

-- | Convenience function that combines <a>b64_encode_part</a> and
--   <a>b64_encode_final</a> to encode a complete string.
--   
--   <pre>
--   &gt;&gt;&gt; encode $ Data.ByteString.Char8.pack "foo"
--   "Zm9v"
--   
--   &gt;&gt;&gt; encode $ Data.ByteString.Char8.pack "foobar"
--   "Zm9vYmFy"
--   </pre>
encode :: ByteString -> ByteString

-- | Convenience function that combines <a>b64_decode_part</a> and
--   <a>b64_decode_final</a> to decode a complete string.
--   
--   <pre>
--   &gt;&gt;&gt; decode $ Data.ByteString.Char8.pack "Zm9v"
--   Right "foo"
--   
--   &gt;&gt;&gt; decode $ Data.ByteString.Char8.pack "Zm9vYmFy"
--   Right "foobar"
--   </pre>
--   
--   Failures when decoding returns the decoded part and the remainder:
--   
--   <pre>
--   &gt;&gt;&gt; decode $ Data.ByteString.Char8.pack "Zm9vYm=y"
--   Left ("foo","Ym=y")
--   </pre>
decode :: ByteString -> Either (ByteString, ByteString) ByteString


module Data.Conduit.Codec.Base64
encode :: Monad m => Conduit ByteString m ByteString
decode :: (Monad m, MonadThrow m) => Conduit ByteString m ByteString


-- | Implemented as specified in RFC 4648
--   (<a>http://tools.ietf.org/html/rfc4648</a>).
--   
--   This encoding is closely related to base 32 and so is its
--   implementation, so please refer to <a>Codec.Binary.Base32</a> for
--   further details.
module Codec.Binary.Base32Hex

-- | Encoding function.
--   
--   See <a>b32_encode_part</a>.
--   
--   <pre>
--   &gt;&gt;&gt; b32h_encode_part $ Data.ByteString.Char8.pack "fooba"
--   ("CPNMUOJ1","")
--   
--   &gt;&gt;&gt; b32h_encode_part $ Data.ByteString.Char8.pack "foobar"
--   ("CPNMUOJ1","r")
--   </pre>
b32h_encode_part :: ByteString -> (ByteString, ByteString)

-- | Encoding function for the final block.
--   
--   See <a>b32_encode_final</a>.
--   
--   <pre>
--   &gt;&gt;&gt; b32h_encode_final $ Data.ByteString.Char8.pack "r"
--   Just "E8======"
--   
--   &gt;&gt;&gt; b32h_encode_final $ Data.ByteString.Char8.pack "fooba"
--   Nothing
--   </pre>
b32h_encode_final :: ByteString -> Maybe ByteString

-- | Decoding function.
--   
--   See <a>b32_decode_part</a>.
--   
--   <pre>
--   &gt;&gt;&gt; b32h_decode_part $ Data.ByteString.Char8.pack "CPNMUOJ1"
--   Right ("fooba","")
--   
--   &gt;&gt;&gt; b32h_decode_part $ Data.ByteString.Char8.pack "CPNMUOJ1E8======"
--   Right ("fooba","E8======")
--   
--   &gt;&gt;&gt; b32h_decode_part $ Data.ByteString.Char8.pack "C=NMUOJ1"
--   Left ("","C=NMUOJ1")
--   </pre>
b32h_decode_part :: ByteString -> Either (ByteString, ByteString) (ByteString, ByteString)

-- | Decoding function for the final block.
--   
--   See <a>b32_decode_final</a>.
--   
--   <pre>
--   &gt;&gt;&gt; b32h_decode_final $ Data.ByteString.Char8.pack "CPNMUOG="
--   Just "foob"
--   
--   &gt;&gt;&gt; b32h_decode_final $ Data.ByteString.Char8.pack ""
--   Just ""
--   
--   &gt;&gt;&gt; b32h_decode_final $ Data.ByteString.Char8.pack "CPNMUO="
--   Nothing
--   
--   &gt;&gt;&gt; b32h_decode_final $ encode $ Data.ByteString.Char8.pack "fooba"
--   Nothing
--   </pre>
b32h_decode_final :: ByteString -> Maybe ByteString

-- | Convenience function that combines <a>b32h_encode_part</a> and
--   <a>b32h_encode_final</a> to encode a complete string.
--   
--   <pre>
--   &gt;&gt;&gt; encode $ Data.ByteString.Char8.pack "fooba"
--   "CPNMUOJ1"
--   
--   &gt;&gt;&gt; encode $ Data.ByteString.Char8.pack "foobar"
--   "CPNMUOJ1E8======"
--   </pre>
encode :: ByteString -> ByteString

-- | Convenience function that combines <a>b32h_decode_part</a> and
--   <a>b32h_decode_final</a> to decode a complete string.
--   
--   <pre>
--   &gt;&gt;&gt; decode $ Data.ByteString.Char8.pack "CPNMUOJ1"
--   Right "fooba"
--   
--   &gt;&gt;&gt; decode $ Data.ByteString.Char8.pack "CPNMUOJ1E8======"
--   Right "foobar"
--   </pre>
--   
--   Failures when decoding returns the decoded part and the remainder:
--   
--   <pre>
--   &gt;&gt;&gt; decode $ Data.ByteString.Char8.pack "CPNMUOJ1=8======"
--   Left ("fooba","=8======")
--   </pre>
decode :: ByteString -> Either (ByteString, ByteString) ByteString


module Data.Conduit.Codec.Base32Hex
encode :: Monad m => Conduit ByteString m ByteString
decode :: (Monad m, MonadThrow m) => Conduit ByteString m ByteString


-- | Implemented as specified in RFC 4648
--   (<a>http://tools.ietf.org/html/rfc4648</a>).
--   
--   Base32 encoding works by expanding blocks of 5 bytes of data into
--   blocks of 8 bytes of data. Finally it also includes a well defined
--   ending of the encoded data to make sure the size of the final block of
--   encoded data is 8 bytes too.
module Codec.Binary.Base32

-- | Encoding function.
--   
--   This function encodes as large a portion of the input as possible and
--   returns the encoded part together with the remaining part. Enough
--   space is allocated for the encoding to make sure that the remaining
--   part is less than 5 bytes long, which means it can be passed to
--   <a>b32_encode_final</a> as is.
--   
--   <pre>
--   &gt;&gt;&gt; b32_encode_part $ Data.ByteString.Char8.pack "fooba"
--   ("MZXW6YTB","")
--   
--   &gt;&gt;&gt; b32_encode_part $ Data.ByteString.Char8.pack "foobar"
--   ("MZXW6YTB","r")
--   </pre>
b32_encode_part :: ByteString -> (ByteString, ByteString)

-- | Encoding function for the final block.
--   
--   The final block has to have a size less than 5.
--   
--   <pre>
--   &gt;&gt;&gt; b32_encode_final $ Data.ByteString.Char8.pack "r"
--   Just "OI======"
--   </pre>
--   
--   Trying to pass in too large a block result in failure:
--   
--   <pre>
--   &gt;&gt;&gt; b32_encode_final $ Data.ByteString.Char8.pack "fooba"
--   Nothing
--   </pre>
b32_encode_final :: ByteString -> Maybe ByteString

-- | Decoding function.
--   
--   Decode as large a portion of the input as possible. Enough data is
--   allocated for the output to ensure that the remainder is less than 8
--   bytes in size. Success result in a <tt>Right</tt> value:
--   
--   <pre>
--   &gt;&gt;&gt; b32_decode_part $ Data.ByteString.Char8.pack "MZXW6YTB"
--   Right ("fooba","")
--   
--   &gt;&gt;&gt; b32_decode_part $ Data.ByteString.Char8.pack "MZXW6YTBOI======"
--   Right ("fooba","OI======")
--   </pre>
--   
--   Failures occur on bad input and result in a <tt>Left</tt> value:
--   
--   <pre>
--   &gt;&gt;&gt; b32_decode_part $ Data.ByteString.Char8.pack "M=XW6YTB"
--   Left ("","M=XW6YTB")
--   </pre>
b32_decode_part :: ByteString -> Either (ByteString, ByteString) (ByteString, ByteString)

-- | Decoding function for the final block.
--   
--   The final block has to have a size of 0 or 8:
--   
--   <pre>
--   &gt;&gt;&gt; b32_decode_final $ Data.ByteString.Char8.pack "MZXW6YQ="
--   Just "foob"
--   
--   &gt;&gt;&gt; b32_decode_final $ Data.ByteString.Char8.pack ""
--   Just ""
--   
--   &gt;&gt;&gt; b32_decode_final $ Data.ByteString.Char8.pack "MZXW6Y="
--   Nothing
--   </pre>
--   
--   But it must be the encoding of a block that is less than 5 bytes:
--   
--   <pre>
--   &gt;&gt;&gt; b32_decode_final $ encode $ Data.ByteString.Char8.pack "fooba"
--   Nothing
--   </pre>
b32_decode_final :: ByteString -> Maybe ByteString

-- | Convenience function that combines <a>b32_encode_part</a> and
--   <a>b32_encode_final</a> to encode a complete string.
--   
--   <pre>
--   &gt;&gt;&gt; encode $ Data.ByteString.Char8.pack "fooba"
--   "MZXW6YTB"
--   
--   &gt;&gt;&gt; encode $ Data.ByteString.Char8.pack "foobar"
--   "MZXW6YTBOI======"
--   </pre>
encode :: ByteString -> ByteString

-- | Convenience function that combines <a>b32_decode_part</a> and
--   <a>b32_decode_final</a> to decode a complete string.
--   
--   <pre>
--   &gt;&gt;&gt; decode $ Data.ByteString.Char8.pack "MZXW6YTB"
--   Right "fooba"
--   
--   &gt;&gt;&gt; decode $ Data.ByteString.Char8.pack "MZXW6YTBOI======"
--   Right "foobar"
--   </pre>
--   
--   Failures when decoding returns the decoded part and the remainder:
--   
--   <pre>
--   &gt;&gt;&gt; decode $ Data.ByteString.Char8.pack "MZXW6YTBOI=0===="
--   Left ("fooba","OI=0====")
--   </pre>
decode :: ByteString -> Either (ByteString, ByteString) ByteString


module Data.Conduit.Codec.Base32
encode :: Monad m => Conduit ByteString m ByteString
decode :: (Monad m, MonadThrow m) => Conduit ByteString m ByteString


-- | Implemention of base 16 encoding (hex encoding) as specified in RFC
--   4648 (<a>http://tools.ietf.org/html/rfc4648</a>).
module Codec.Binary.Base16

-- | Encoding function.
--   
--   This function, unlike some other encoding functions in the library,
--   simply cannot fail. Double the length of the input string is allocated
--   for the encoded data, which is guaranteed to hold the result.
--   
--   <pre>
--   &gt;&gt;&gt; b16_enc $ Data.ByteString.pack [0x00]
--   "00"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; b16_enc $ Data.ByteString.Char8.pack "foobar"
--   "666F6F626172"
--   </pre>
b16_enc :: ByteString -> ByteString

-- | Decoding function.
--   
--   The returned value on success is <tt>Right (&lt;decoded part&gt;,
--   &lt;undecoded part&gt;)</tt> (the undecoded part is either a empty or
--   a single byte), and on failure it's <tt>Left (&lt;decoded part&gt;,
--   &lt;undecodable part&gt;)</tt>. Space equal to the length of the input
--   string is allocated, which is more than enough to hold the decoded
--   data.
--   
--   <pre>
--   &gt;&gt;&gt; b16_dec $ Data.ByteString.Char8.pack "00"
--   Right ("\NUL","")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; b16_dec $ Data.ByteString.Char8.pack "666F6F626172"
--   Right ("foobar","")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; b16_dec $ Data.ByteString.Char8.pack "666F6F62617"
--   Right ("fooba","7")
--   
--   &gt;&gt;&gt; b16_dec $ Data.ByteString.Char8.pack "666F6F62617g"
--   Left ("fooba","g")
--   </pre>
b16_dec :: ByteString -> Either (ByteString, ByteString) (ByteString, ByteString)

-- | A synonym for <a>b16_enc</a>.
encode :: ByteString -> ByteString

-- | A synonum for <a>b16_dec</a>.
decode :: ByteString -> Either (ByteString, ByteString) ByteString


module Data.Conduit.Codec.Base16
encode :: Monad m => Conduit ByteString m ByteString
decode :: (Monad m, MonadThrow m) => Conduit ByteString m ByteString
