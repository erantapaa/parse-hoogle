-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | simple alternative to type classes
--   
@package cluss
@version 0.3


-- | Basic tools for clusses. <a>Examples</a> show how to use them.
--   
--   Template haskell tools are in the module <a>Type.Cluss.TH</a>.
module Type.Cluss

-- | <tt><a>In</a> as</tt> is a <i>cluss</i>, where <tt>as</tt> is a list
--   of type patterns. Normally, <tt>as</tt> is concrete and does not
--   contain any type variables, like <tt><a>In</a> [<a>Binary</a> (-&gt;)
--   (<a>Show</a> &gt;|&lt; <a>This</a>), <a>Type</a> <a>String</a>]
--   a</tt>.
--   
--   When <tt>a</tt> satisfies <tt>In as a</tt>, you can use the method
--   <tt><a>proj</a> :: <a>AllOf</a> as f -&gt; f a</tt>.
--   
--   Internally, "type pattern matching" is executed by Where, a closed
--   type family, which cannot check if a type satisfies a constraint. If
--   <tt>as</tt> has many type patterns that can match <tt>a</tt>, only the
--   first one matches <tt>a</tt>.
--   
--   Clusses call for some language extensions. Basically, this language
--   pragma will do.
--   
--   <pre>
--   {-# LANGUAGE DataKinds, FlexibleContexts, TypeOperators #-}
--   </pre>
class In (as :: [*]) (a :: k)
proj :: In as a => AllOf as t -> t a

-- | <tt><a>Has</a> as a</tt> judges whether a type <tt>a</tt> belongs to a
--   cluss <tt><a>In</a> as</tt>, on some level. When not sure, <a>Has</a>
--   always returns <a>True</a>. For example, when <tt>as</tt> has
--   <tt><a>Unary</a> [] <a>Show</a></tt> and <tt>a</tt> is <tt>[b]</tt>,
--   <a>Has</a> can't judge if <tt>b</tt> belongs to <a>Show</a> since the
--   instances of <a>Show</a> is <i>open</i>, but it assumes that
--   <tt>b</tt> belongs to <a>Show</a> and returns <a>True</a>.

-- | The empty type <tt><a>Type</a> a</tt> is a type pattern, where
--   <tt>a</tt> is a type. The type pattern <tt><a>Type</a> <a>Int</a></tt>
--   corresponds to <tt>instance C <a>Int</a> where ...</tt> (where
--   <tt>C</tt> is a corresponding type class), for example. Note that the
--   type variable <tt>a</tt> can be of any kind: <tt>a</tt> could be of
--   the kind <tt>* -&gt; *</tt>, for example.
data Type (a :: k)

-- | The empty type <tt><a>AnyType</a> p</tt> is a type pattern, where
--   <tt>p</tt> is a type function from a type to a constraint. The type
--   pattern <tt><a>AnyType</a> <a>Show</a></tt> basically corresponds to
--   <tt>instance <a>Show</a> a =&gt; C a where ...</tt> (where <tt>C</tt>
--   is a corresponding type class), for example, but <a>AnyType</a> is
--   much more useful in that it does not cause <i>overlapping
--   instances</i> whereas <tt>C</tt> is likely to, because cluss instances
--   are prioritized.
data AnyType (p :: k -> Constraint)

-- | The empty type <tt>a <tt>&lt;|</tt> p</tt> is a type pattern, where
--   <tt>a</tt> is a type constructor, and <tt>p</tt> is a type function to
--   a constraint from the type variables for the constructor <tt>a</tt>.
--   The type pattern <tt>[] &lt;| <a>Show</a></tt> corresponds to
--   <tt>instance <a>Show</a> a =&gt; C [a] where ...</tt> (where
--   <tt>C</tt> is a corresponding type class), for example.
--   
--   You can replace <a>Unary</a>, <a>Binary</a>, ..., and <a>Denary</a>
--   with <tt>&lt;|</tt>, but you can sometimes save the effort of
--   annotating kinds using <a>Unary</a>, <a>Binary</a>, ..., or
--   <a>Denary</a> instead of <tt>&lt;|</tt>, especially when using the
--   <tt>PolyKinds</tt> extension, because the kinds of the parameters in
--   <a>Unary</a>, <a>Binary</a>, ..., and <a>Denary</a> are restricted as
--   described below.
data (<|) (a :: k) (p :: l)

-- | <tt>a &lt;| p</tt>, with <tt>a</tt> being of the kind <tt>i -&gt;
--   k</tt>, and <tt>p</tt> of the kind <tt>i -&gt; <a>Constraint</a></tt>.
type Unary (a :: i -> k) (p :: i -> Constraint) = a <| p

-- | <tt>a &lt;| p</tt>, with <tt>a</tt> being of the kind <tt>i -&gt; i2
--   -&gt; k</tt>, and <tt>p</tt> of the kind <tt>i -&gt; i2 -&gt;
--   <a>Constraint</a></tt>.
type Binary (a :: i -> i2 -> k) (p :: i -> i2 -> Constraint) = a <| p

-- | <tt>a &lt;| p</tt>, with <tt>a</tt> being of the kind <tt>i -&gt; i2
--   -&gt; i3 -&gt; k</tt>, and <tt>p</tt> of the kind <tt>i -&gt; i2 -&gt;
--   i3 -&gt; <a>Constraint</a></tt>.
type Ternary (a :: i -> i2 -> i3 -> k) (p :: i -> i2 -> i3 -> Constraint) = a <| p

-- | <tt>a &lt;| p</tt>, with <tt>a</tt> being of the kind <tt>i -&gt; i2
--   -&gt; i3 -&gt; i4 -&gt; k</tt>, and <tt>p</tt> of the kind <tt>i -&gt;
--   i2 -&gt; i3 -&gt; i4 -&gt; <a>Constraint</a></tt>.
type Quaternary (a :: i -> i2 -> i3 -> i4 -> k) (p :: i -> i2 -> i3 -> i4 -> Constraint) = a <| p

-- | <tt>a &lt;| p</tt>, with <tt>a</tt> being of the kind <tt>i -&gt; i2
--   -&gt; i3 -&gt; i4 -&gt; i5 -&gt; k</tt>, and <tt>p</tt> of the kind
--   <tt>i -&gt; i2 -&gt; i3 -&gt; i4 -&gt; i5 -&gt;
--   <a>Constraint</a></tt>.
type Quinary (a :: i -> i2 -> i3 -> i4 -> i5 -> k) (p :: i -> i2 -> i3 -> i4 -> i5 -> Constraint) = a <| p

-- | <tt>a &lt;| p</tt>, with <tt>a</tt> being of the kind <tt>i -&gt; i2
--   -&gt; i3 -&gt; i4 -&gt; i5 -&gt; i6 -&gt; k</tt>, and <tt>p</tt> of
--   the kind <tt>i -&gt; i2 -&gt; i3 -&gt; i4 -&gt; i5 -&gt; i6 -&gt;
--   <a>Constraint</a></tt>.
type Senary (a :: i -> i2 -> i3 -> i4 -> i5 -> i6 -> k) (p :: i -> i2 -> i3 -> i4 -> i5 -> i6 -> Constraint) = a <| p

-- | <tt>a &lt;| p</tt>, with <tt>a</tt> being of the kind <tt>i -&gt; i2
--   -&gt; i3 -&gt; i4 -&gt; i5 -&gt; i6 -&gt; i7 -&gt; k</tt>, and
--   <tt>p</tt> of the kind <tt>i -&gt; i2 -&gt; i3 -&gt; i4 -&gt; i5 -&gt;
--   i6 -&gt; i7 -&gt; <a>Constraint</a></tt>.
type Septenary (a :: i -> i2 -> i3 -> i4 -> i5 -> i6 -> i7 -> k) (p :: i -> i2 -> i3 -> i4 -> i5 -> i6 -> i7 -> Constraint) = a <| p

-- | <tt>a &lt;| p</tt>, with <tt>a</tt> being of the kind <tt>i -&gt; i2
--   -&gt; i3 -&gt; i4 -&gt; i5 -&gt; i6 -&gt; i7 -&gt; i8 -&gt; k</tt>,
--   and <tt>p</tt> of the kind <tt>i -&gt; i2 -&gt; i3 -&gt; i4 -&gt; i5
--   -&gt; i6 -&gt; i7 -&gt; i8 -&gt; <a>Constraint</a></tt>.
type Octary (a :: i -> i2 -> i3 -> i4 -> i5 -> i6 -> i7 -> i8 -> k) (p :: i -> i2 -> i3 -> i4 -> i5 -> i6 -> i7 -> i8 -> Constraint) = a <| p

-- | <tt>a &lt;| p</tt>, with <tt>a</tt> being of the kind <tt>i -&gt; i2
--   -&gt; i3 -&gt; i4 -&gt; i5 -&gt; i6 -&gt; i7 -&gt; i8 -&gt; i9 -&gt;
--   k</tt>, and <tt>p</tt> of the kind <tt>i -&gt; i2 -&gt; i3 -&gt; i4
--   -&gt; i5 -&gt; i6 -&gt; i7 -&gt; i8 -&gt; i9 -&gt;
--   <a>Constraint</a></tt>.
type Nonary (a :: i -> i2 -> i3 -> i4 -> i5 -> i6 -> i7 -> i8 -> i9 -> k) (p :: i -> i2 -> i3 -> i4 -> i5 -> i6 -> i7 -> i8 -> i9 -> Constraint) = a <| p

-- | <tt>a &lt;| p</tt>, with <tt>a</tt> being of the kind <tt>i -&gt; i2
--   -&gt; i3 -&gt; i4 -&gt; i5 -&gt; i6 -&gt; i7 -&gt; i8 -&gt; i9 -&gt;
--   i10 -&gt; k</tt>, and <tt>p</tt> of the kind <tt>i -&gt; i2 -&gt; i3
--   -&gt; i4 -&gt; i5 -&gt; i6 -&gt; i7 -&gt; i8 -&gt; i9 -&gt; i10 -&gt;
--   <a>Constraint</a></tt>.
type Denary (a :: i -> i2 -> i3 -> i4 -> i5 -> i6 -> i7 -> i8 -> i9 -> i10 -> k) (p :: i -> i2 -> i3 -> i4 -> i5 -> i6 -> i7 -> i8 -> i9 -> i10 -> Constraint) = a <| p

-- | <tt><a>AllOf</a> as f</tt> is a tuple that contains values of the type
--   <tt>f a</tt>, where <tt>a</tt> can be any type that satisfies <tt>In
--   as a</tt>. Each value corresponds to each type pattern, and the values
--   in <tt><a>AllOf</a> as f</tt> must be in the same order as the type
--   patterns in <tt>as</tt>. And, And1, And2, ..., and And10 are used to
--   combine the values, where None must be added at the end. You have to
--   use And for <tt><a>Type</a> a</tt>, And1 for <tt><a>Unary</a> a
--   p</tt>, And2 for <tt><a>Binary</a> a p</tt>, ..., and And10 for
--   <tt><a>Denary</a> a p</tt>.
type AllOf as = AllOf' as as

-- | <a>This</a> creates a recursion. In other words, <a>This</a> will work
--   as <tt><a>In</a> as</tt> itself when used in the type list (first
--   parameter) <tt>as</tt> of <a>In</a>, combined with <a>Type</a>,
--   <tt>&lt;|</tt>, <a>Unary</a>, <a>Binary</a>, ..., <a>Denary</a>,
--   &gt;+&lt;, &gt;++&lt;, ..., &gt;++++++++++&lt;, &gt;|&lt;, &gt;||&lt;,
--   ..., and &gt;|||||||||&lt;.
--   
--   Note that <a>This</a> will not be expanded into <tt><a>In</a> as</tt>
--   if the condition described above is not satisfied. For example,
--   <a>This</a> in the parameter of <a>AnyType</a> will not be expanded
--   because it causes infinite recursion. Internally, the expansion is
--   executed by Modify, Modify2, ..., and Modify10.
--   
--   The instance of <a>This</a> itself cannot be created since the context
--   <tt><a>True</a> ~ <a>False</a></tt> will never be satisfied.
--   
--   There is no predetermined limit of recursion depth, but GHC has a
--   fixed-depth recursion stack for safety, so you may need to increase
--   the stack depth with <tt>-fcontext-stack=N</tt>.
class True ~ False => This a

-- | <tt><a>Pure</a> a</tt> is equivalent to the empty constraint
--   <tt>()</tt>.
--   
--   <pre>
--   Pure a == ()
--   </pre>
class Pure a

-- | <pre>
--   (Is a) b == (a ~ b)
--   </pre>
type Is = (~)

-- | <pre>
--   (p &gt;+&lt; q) a == (p a, q a)
--   </pre>
class (p a, q a) => (>+<) p q a

-- | <pre>
--   (p &gt;++&lt; q) a b == (p a b, q a b)
--   </pre>
class (p a b, q a b) => (>++<) p q a b

-- | <pre>
--   (p &gt;+++&lt; q) a b c == (p a b c, q a b c)
--   </pre>
class (p a b c, q a b c) => (>+++<) p q a b c

-- | <pre>
--   (p &gt;++++&lt; q) a b c d == (p a b c d, q a b c d)
--   </pre>
class (p a b c d, q a b c d) => (>++++<) p q a b c d

-- | <pre>
--   (p &gt;+++++&lt; q) a b c d e == (p a b c d e, q a b c d e)
--   </pre>
class (p a b c d e, q a b c d e) => (>+++++<) p q a b c d e

-- | <pre>
--   (p &gt;++++++&lt; q) a b c d e f == (p a b c d e f, q a b c d e f)
--   </pre>
class (p a b c d e f, q a b c d e f) => (>++++++<) p q a b c d e f

-- | <pre>
--   (p &gt;+++++++&lt; q) a b c d e f g == (p a b c d e f g, q a b c d e f g)
--   </pre>
class (p a b c d e f g, q a b c d e f g) => (>+++++++<) p q a b c d e f g

-- | <pre>
--   (p &gt;++++++++&lt; q) a b c d e f g h == (p a b c d e f g h, q a b c d e f g h)
--   </pre>
class (p a b c d e f g h, q a b c d e f g h) => (>++++++++<) p q a b c d e f g h

-- | <pre>
--   (p &gt;+++++++++&lt; q) a b c d e f g h i == (p a b c d e f g h, q a b c d e f g h i)
--   </pre>
class (p a b c d e f g h i, q a b c d e f g h i) => (>+++++++++<) p q a b c d e f g h i

-- | <pre>
--   (p &gt;++++++++++&lt; q) a b c d e f g h i j == (p a b c d e f g h, q a b c d e f g h i j)
--   </pre>
class (p a b c d e f g h i j, q a b c d e f g h i j) => (>++++++++++<) p q a b c d e f g h i j

-- | <pre>
--   (p &gt;|&lt; q) a b == (p a, q b)
--   </pre>
class (p a, q b) => (>|<) p q a b

-- | <pre>
--   (p &gt;||&lt; q) a b c == (p a b, q c)
--   </pre>
class (p a b, q c) => (>||<) p q a b c

-- | <pre>
--   (p &gt;|||&lt; q) a b c d == (p a b c, q d)
--   </pre>
class (p a b c, q d) => (>|||<) p q a b c d

-- | <pre>
--   (p &gt;||||&lt; q) a b c d e == (p a b c d, q e)
--   </pre>
class (p a b c d, q e) => (>||||<) p q a b c d e

-- | <pre>
--   (p &gt;|||||&lt; q) a b c d e f == (p a b c d e, q f)
--   </pre>
class (p a b c d e, q f) => (>|||||<) p q a b c d e f

-- | <pre>
--   (p &gt;||||||&lt; q) a b c d e f g == (p a b c d e f, q g)
--   </pre>
class (p a b c d e f, q g) => (>||||||<) p q a b c d e f g

-- | <pre>
--   (p &gt;|||||||&lt; q) a b c d e f g h == (p a b c d e f g, q h)
--   </pre>
class (p a b c d e f g, q h) => (>|||||||<) p q a b c d e f g h

-- | <pre>
--   (p &gt;||||||||&lt; q) a b c d e f g h i == (p a b c d e f g h, q i)
--   </pre>
class (p a b c d e f g h, q i) => (>||||||||<) p q a b c d e f g h i

-- | <pre>
--   (p &gt;||||||||&lt; q) a b c d e f g h i j == (p a b c d e f g h i, q j)
--   </pre>
class (p a b c d e f g h i, q j) => (>|||||||||<) p q a b c d e f g h i j
class p a => IR1 p a
class p a b => IR2 p a b
class p a b c => IR3 p a b c
class p a b c d => IR4 p a b c d
class p a b c d e => IR5 p a b c d e
class p a b c d e f => IR6 p a b c d e f
class p a b c d e f g => IR7 p a b c d e f g
class p a b c d e f g h => IR8 p a b c d e f g h
class p a b c d e f g h i => IR9 p a b c d e f g h i
class p a b c d e f g h i j => IR10 p a b c d e f g h i j
type AllOfI as = AllOfI' as as
andI :: a -> AllOfI' ts as -> AllOfI' ts (Type a : as)
andI1 :: (forall b. Modify (a b) (In ts) p b => a b) -> AllOfI' ts as -> AllOfI' ts (Unary a p : as)
andI2 :: (forall b c. Modify2 (a b c) (In ts) p b c => a b c) -> AllOfI' ts as -> AllOfI' ts (Binary a p : as)
andI3 :: (forall b c d. Modify3 (a b c d) (In ts) p b c d => a b c d) -> AllOfI' ts as -> AllOfI' ts (Ternary a p : as)
andI4 :: (forall b c d e. Modify4 (a b c d e) (In ts) p b c d e => a b c d e) -> AllOfI' ts as -> AllOfI' ts (Quaternary a p : as)
andI5 :: (forall b c d e f. Modify5 (a b c d e f) (In ts) p b c d e f => a b c d e f) -> AllOfI' ts as -> AllOfI' ts (Quinary a p : as)
andI6 :: (forall b c d e f g. Modify6 (a b c d e f g) (In ts) p b c d e f g => a b c d e f g) -> AllOfI' ts as -> AllOfI' ts (Senary a p : as)
andI7 :: (forall b c d e f g h. Modify7 (a b c d e f g h) (In ts) p b c d e f g h => a b c d e f g h) -> AllOfI' ts as -> AllOfI' ts (Septenary a p : as)
andI8 :: (forall b c d e f g h i. Modify8 (a b c d e f g h i) (In ts) p b c d e f g h i => a b c d e f g h i) -> AllOfI' ts as -> AllOfI' ts (Octary a p : as)
andI9 :: (forall b c d e f g h i j. Modify9 (a b c d e f g h i j) (In ts) p b c d e f g h i j => a b c d e f g h i j) -> AllOfI' ts as -> AllOfI' ts (Nonary a p : as)
andI10 :: (forall b c d e f g h i j k. Modify10 (a b c d e f g h i j k) (In ts) p b c d e f g h i j k => a b c d e f g h i j k) -> AllOfI' ts as -> AllOfI' ts (Denary a p : as)
noneI :: AllOfI' ts []
projI :: In as a => AllOfI as -> a
type AllOfF as t = AllOfF' as as t
andF :: (a -> t) -> AllOfF' ts as t -> AllOfF' ts (Type a : as) t
andF1 :: (forall b. Modify (a b) (In ts) p b => a b -> t) -> AllOfF' ts as t -> AllOfF' ts (Unary a p : as) t
andF2 :: (forall b c. Modify2 (a b c) (In ts) p b c => a b c -> t) -> AllOfF' ts as t -> AllOfF' ts (Binary a p : as) t
andF3 :: (forall b c d. Modify3 (a b c d) (In ts) p b c d => a b c d -> t) -> AllOfF' ts as t -> AllOfF' ts (Ternary a p : as) t
andF4 :: (forall b c d e. Modify4 (a b c d e) (In ts) p b c d e => a b c d e -> t) -> AllOfF' ts as t -> AllOfF' ts (Quaternary a p : as) t
andF5 :: (forall b c d e f. Modify5 (a b c d e f) (In ts) p b c d e f => a b c d e f -> t) -> AllOfF' ts as t -> AllOfF' ts (Quinary a p : as) t
andF6 :: (forall b c d e f g. Modify6 (a b c d e f g) (In ts) p b c d e f g => a b c d e f g -> t) -> AllOfF' ts as t -> AllOfF' ts (Senary a p : as) t
andF7 :: (forall b c d e f g h. Modify7 (a b c d e f g h) (In ts) p b c d e f g h => a b c d e f g h -> t) -> AllOfF' ts as t -> AllOfF' ts (Septenary a p : as) t
andF8 :: (forall b c d e f g h i. Modify8 (a b c d e f g h i) (In ts) p b c d e f g h i => a b c d e f g h i -> t) -> AllOfF' ts as t -> AllOfF' ts (Octary a p : as) t
andF9 :: (forall b c d e f g h i j. Modify9 (a b c d e f g h i j) (In ts) p b c d e f g h i j => a b c d e f g h i j -> t) -> AllOfF' ts as t -> AllOfF' ts (Nonary a p : as) t
andF10 :: (forall b c d e f g h i j k. Modify10 (a b c d e f g h i j k) (In ts) p b c d e f g h i j k => a b c d e f g h i j k -> t) -> AllOfF' ts as t -> AllOfF' ts (Denary a p : as) t
noneF :: AllOfF' ts [] t
projF :: In as a => AllOfF as t -> (a -> t)
instance In' n ts as a => In' (Look_At_Tail n) ts (Denary b p : as) a
instance In' n ts as a => In' (Look_At_Tail n) ts (Nonary b p : as) a
instance In' n ts as a => In' (Look_At_Tail n) ts (Octary b p : as) a
instance In' n ts as a => In' (Look_At_Tail n) ts (Septenary b p : as) a
instance In' n ts as a => In' (Look_At_Tail n) ts (Senary b p : as) a
instance In' n ts as a => In' (Look_At_Tail n) ts (Quinary b p : as) a
instance In' n ts as a => In' (Look_At_Tail n) ts (Quaternary b p : as) a
instance In' n ts as a => In' (Look_At_Tail n) ts (Ternary b p : as) a
instance In' n ts as a => In' (Look_At_Tail n) ts (Binary b p : as) a
instance In' n ts as a => In' (Look_At_Tail n) ts (Unary b p : as) a
instance In' n ts as a => In' (Look_At_Tail n) ts (AnyType p : as) a
instance In' n ts as a => In' (Look_At_Tail n) ts (Type b : as) a
instance (Modify10 (a b c d e f g h i j k11) (In ts) p b c d e f g h i j k11) => In' Look_At_Head ts (Denary a p : as) (a b c d e f g h i j k11)
instance (Modify9 (a b c d e f g h i j) (In ts) p b c d e f g h i j) => In' Look_At_Head ts (Nonary a p : as) (a b c d e f g h i j)
instance (Modify8 (a b c d e f g h i) (In ts) p b c d e f g h i) => In' Look_At_Head ts (Octary a p : as) (a b c d e f g h i)
instance (Modify7 (a b c d e f g h) (In ts) p b c d e f g h) => In' Look_At_Head ts (Septenary a p : as) (a b c d e f g h)
instance (Modify6 (a b c d e f g) (In ts) p b c d e f g) => In' Look_At_Head ts (Senary a p : as) (a b c d e f g)
instance (Modify5 (a b c d e f) (In ts) p b c d e f) => In' Look_At_Head ts (Quinary a p : as) (a b c d e f)
instance (Modify4 (a b c d e) (In ts) p b c d e) => In' Look_At_Head ts (Quaternary a p : as) (a b c d e)
instance (Modify3 (a b c d) (In ts) p b c d) => In' Look_At_Head ts (Ternary a p : as) (a b c d)
instance (Modify2 (a b c) (In ts) p b c) => In' Look_At_Head ts (Binary a p : as) (a b c)
instance (Modify (a b) (In ts) p b) => In' Look_At_Head ts (Unary a p : as) (a b)
instance (p a) => In' Look_At_Head ts (AnyType p : as) a
instance In' Look_At_Head ts (Type a : as) a
instance In' (Where as as a) as as a => In as a
instance (p a b c d e f g h i j) => IR10 p a b c d e f g h i j
instance (p a b c d e f g h i) => IR9 p a b c d e f g h i
instance (p a b c d e f g h) => IR8 p a b c d e f g h
instance (p a b c d e f g) => IR7 p a b c d e f g
instance (p a b c d e f) => IR6 p a b c d e f
instance (p a b c d e) => IR5 p a b c d e
instance (p a b c d) => IR4 p a b c d
instance (p a b c) => IR3 p a b c
instance (p a b) => IR2 p a b
instance (p a) => IR1 p a
instance (p a b c d e f g h i, q j) => (>|||||||||<) p q a b c d e f g h i j
instance (p a b c d e f g h, q i) => (>||||||||<) p q a b c d e f g h i
instance (p a b c d e f g, q h) => (>|||||||<) p q a b c d e f g h
instance (p a b c d e f, q g) => (>||||||<) p q a b c d e f g
instance (p a b c d e, q f) => (>|||||<) p q a b c d e f
instance (p a b c d, q e) => (>||||<) p q a b c d e
instance (p a b c, q d) => (>|||<) p q a b c d
instance (p a b, q c) => (>||<) p q a b c
instance (p a, q b) => (>|<) p q a b
instance (p a b c d e f g h i j, q a b c d e f g h i j) => (>++++++++++<) p q a b c d e f g h i j
instance (p a b c d e f g h i, q a b c d e f g h i) => (>+++++++++<) p q a b c d e f g h i
instance (p a b c d e f g h, q a b c d e f g h) => (>++++++++<) p q a b c d e f g h
instance (p a b c d e f g, q a b c d e f g) => (>+++++++<) p q a b c d e f g
instance (p a b c d e f, q a b c d e f) => (>++++++<) p q a b c d e f
instance (p a b c d e, q a b c d e) => (>+++++<) p q a b c d e
instance (p a b c d, q a b c d) => (>++++<) p q a b c d
instance (p a b c, q a b c) => (>+++<) p q a b c
instance (p a b, q a b) => (>++<) p q a b
instance (p a, q a) => (>+<) p q a
instance Pure a


-- | Template haskell tools for clusses.
--   
--   Basic tools are in the module <a>Type.Cluss</a>.
module Type.Cluss.TH

-- | <a>clussify</a> converts a type class into a cluss, roughly speaking.
--   For example, if the visible instances of <a>Show</a> were to be only
--   <tt><a>Show</a> <a>Int</a></tt>, <tt><a>Show</a> a =&gt; <a>Show</a>
--   [a]</tt>, and <tt>(<a>Show</a> a, <a>Show</a> b) =&gt; <a>Show</a> (a,
--   b)</tt>, the result of <tt>$(<a>clussify</a> ''<a>Show</a>)</tt> will
--   be
--   
--   <pre>
--   Show &gt;|&lt; In [Type Int, Unary [] Show, Binary (,) (Show &gt;|&lt; Show)]
--   </pre>
--   
--   (in fact, the result will be more verbose, using <tt><a>Show</a>
--   &gt;|&lt; <tt>Pure</tt> &gt;++&lt; <tt>Pure</tt> &gt;|&lt;
--   <a>Show</a></tt> instead of <tt><a>Show</a> &gt;|&lt;
--   <a>Show</a></tt>).
--   
--   Due to the stage restriction of template haskell, <a>clussify</a>
--   can't catch the instances defined in the module where the
--   <tt>classify</tt> is written.
--   
--   Note that <a>clussify</a> neglects complicated instances that cannot
--   be simply expressed with the combinators in the module
--   <a>Type.Cluss</a>.
--   
--   You need some language extensions to use <a>clussify</a>. Basically,
--   this language pragma will do.
--   
--   <pre>
--   {-# LANGUAGE TemplateHaskell, ConstraintKinds #-}
--   </pre>
clussify :: Name -> Q Type
