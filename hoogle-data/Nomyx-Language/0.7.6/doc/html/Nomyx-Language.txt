-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Language to express rules for Nomic
--   
@package Nomyx-Language
@version 0.7.6

module Paths_Nomyx_Language
version :: Version
getBinDir :: IO FilePath
getLibDir :: IO FilePath
getDataDir :: IO FilePath
getLibexecDir :: IO FilePath
getDataFileName :: FilePath -> IO FilePath
getSysconfDir :: IO FilePath

module Control.Shortcut

-- | class of things that can be run in parallel and can be shortcuted. The
--   funtion in parameter is called everytime an intermediate result is
--   known, as soon as it returns True the intermediate results are
--   returned (discarding those not yet available). the order of the lists
--   must be preserved
class Shortcutable s
shortcut :: Shortcutable s => [s a] -> ([Maybe a] -> Bool) -> s [Maybe a]

-- | version without the maybes
shortcut_ :: (Functor s, Shortcutable s) => [s a] -> ([a] -> Bool) -> s [a]

-- | version with two different types of result
shortcut2 :: (Functor s, Monad s, Shortcutable s) => [s a] -> [s b] -> ([Maybe a] -> [Maybe b] -> Bool) -> s ([Maybe a], [Maybe b])

-- | version with a supplementary event which result is discarded
shortcut2b :: (Functor s, Monad s, Shortcutable s) => [s a] -> s b -> ([Maybe a] -> Bool -> Bool) -> s ([Maybe a], Bool)
fromLeft :: Either a b -> a
fromRight :: Either a b -> b


-- | This module contains the type definitions necessary to build a Nomic
--   rule.
module Language.Nomyx.Expression
type PlayerNumber = Int
type PlayerName = String
type RuleNumber = Int
type RuleName = String
type RuleDesc = String
type RuleText = String
type RuleCode = String
type EventNumber = Int
type EventName = String
type VarName = String
type Code = String
type OutputNumber = Int
type InputNumber = Int
data Eff
Effect :: Eff
NoEffect :: Eff
type Effect = Effect
type NoEffect = NoEffect

-- | A Nomex (Nomyx Expression) allows the players to write rules. Within
--   the rules, you can access and modify the state of the game.
type Nomex = Exp Effect

-- | A NomexNE (Nomyx Expression No Effect) is a specialisation of the type
--   that guarantees that the instructions will have no effects.
type NomexNE = Exp NoEffect
data Exp :: Eff -> * -> *
NewVar :: VarName -> a -> Nomex (Maybe (V a))
ReadVar :: V a -> NomexNE (Maybe a)
WriteVar :: V a -> a -> Nomex Bool
DelVar :: (V a) -> Nomex Bool
OnEvent :: Event e -> ((EventNumber, e) -> Nomex ()) -> Nomex EventNumber
DelEvent :: EventNumber -> Nomex Bool
GetEvents :: NomexNE [EventInfo]
SendMessage :: Msg a -> a -> Nomex ()
ProposeRule :: RuleInfo -> Nomex Bool
ActivateRule :: RuleNumber -> Nomex Bool
RejectRule :: RuleNumber -> Nomex Bool
AddRule :: RuleInfo -> Nomex Bool
ModifyRule :: RuleNumber -> RuleInfo -> Nomex Bool
GetRules :: NomexNE [RuleInfo]
GetPlayers :: NomexNE [PlayerInfo]
SetPlayerName :: PlayerNumber -> PlayerName -> Nomex Bool
DelPlayer :: PlayerNumber -> Nomex Bool
NewOutput :: Maybe PlayerNumber -> NomexNE String -> Nomex OutputNumber
GetOutput :: OutputNumber -> NomexNE (Maybe String)
UpdateOutput :: OutputNumber -> NomexNE String -> Nomex Bool
DelOutput :: OutputNumber -> Nomex Bool
SetVictory :: NomexNE [PlayerNumber] -> Nomex ()
CurrentTime :: NomexNE UTCTime
SelfRuleNumber :: NomexNE RuleNumber
GetRandomNumber :: (a, a) -> Nomex a
Return :: a -> Exp e a
Bind :: Exp e a -> (a -> Exp e b) -> Exp e b
ThrowError :: String -> Exp Effect a
CatchError :: Nomex a -> (String -> Nomex a) -> Nomex a
LiftEffect :: NomexNE a -> Nomex a
Simu :: Nomex a -> NomexNE Bool -> NomexNE Bool
liftEffect :: NomexNE a -> Nomex a

-- | a container for a variable name and type
data V a
V :: String -> V a
varName :: V a -> String

-- | Composable events
data Event a
SumEvent :: Event a -> Event a -> Event a
AppEvent :: Event (a -> b) -> Event a -> Event b
PureEvent :: a -> Event a
EmptyEvent :: Event a
BindEvent :: Event a -> (a -> Event b) -> Event b
ShortcutEvents :: [Event a] -> ([Maybe a] -> Bool) -> Event [Maybe a]
SignalEvent :: Signal a -> Event a
LiftEvent :: NomexNE a -> Event a

-- | Signals
data Signal a
Input :: PlayerNumber -> String -> (InputForm a) -> Signal a
Player :: Player -> Signal PlayerInfo
RuleEv :: RuleEvent -> Signal RuleInfo
Time :: UTCTime -> Signal UTCTime
Message :: Msg a -> Signal a
Victory :: Signal VictoryInfo

-- | Type agnostic base event
data SomeSignal
SomeSignal :: (Signal a) -> SomeSignal

-- | Type agnostic result data
data SomeData
SomeData :: e -> SomeData

-- | Events parameters
data Player
Arrive :: Player
Leave :: Player
data RuleEvent
Proposed :: RuleEvent
Activated :: RuleEvent
Rejected :: RuleEvent
Added :: RuleEvent
Modified :: RuleEvent
Deleted :: RuleEvent
data Msg m
Msg :: String -> Msg m

-- | Input forms
data InputForm a
Text :: InputForm String
TextArea :: InputForm String
Button :: InputForm ()
Radio :: [(a, String)] -> InputForm a
Checkbox :: [(a, String)] -> InputForm [a]
data EventInfo
EventInfo :: EventNumber -> RuleNumber -> Event e -> EventHandler e -> Status -> [SignalOccurence] -> EventInfo
_eventNumber :: EventInfo -> EventNumber
_ruleNumber :: EventInfo -> RuleNumber
event :: EventInfo -> Event e
handler :: EventInfo -> EventHandler e
_evStatus :: EventInfo -> Status
_env :: EventInfo -> [SignalOccurence]
data SignalAddressElem
SumR :: SignalAddressElem
SumL :: SignalAddressElem
AppR :: SignalAddressElem
AppL :: SignalAddressElem
BindR :: SignalAddressElem
BindL :: SignalAddressElem
Shortcut :: SignalAddressElem
type SignalAddress = [SignalAddressElem]
data SignalData
SignalData :: Signal e -> e -> SignalData
signal :: SignalData -> Signal e
signalData :: SignalData -> e
data SignalOccurence
SignalOccurence :: SignalData -> SignalAddress -> SignalOccurence
_signalOccData :: SignalOccurence -> SignalData
_signalOccAddress :: SignalOccurence -> SignalAddress
type EventHandler e = (EventNumber, e) -> Nomex ()
data Status
SActive :: Status
SDeleted :: Status

-- | Type of a rule function.
type Rule = Nomex ()

-- | An informationnal structure about a rule
data RuleInfo
RuleInfo :: RuleNumber -> RuleName -> String -> PlayerNumber -> Code -> Rule -> RuleStatus -> Maybe RuleNumber -> RuleInfo
_rNumber :: RuleInfo -> RuleNumber
_rName :: RuleInfo -> RuleName
_rDescription :: RuleInfo -> String
_rProposedBy :: RuleInfo -> PlayerNumber
_rRuleCode :: RuleInfo -> Code
_rRule :: RuleInfo -> Rule
_rStatus :: RuleInfo -> RuleStatus
_rAssessedBy :: RuleInfo -> Maybe RuleNumber

-- | the status of a rule.
data RuleStatus
Active :: RuleStatus
Pending :: RuleStatus
Reject :: RuleStatus

-- | informations on players
data PlayerInfo
PlayerInfo :: PlayerNumber -> String -> Maybe PlayerNumber -> PlayerInfo
_playerNumber :: PlayerInfo -> PlayerNumber
_playerName :: PlayerInfo -> String
_playAs :: PlayerInfo -> Maybe PlayerNumber
data VictoryInfo
VictoryInfo :: RuleNumber -> NomexNE [PlayerNumber] -> VictoryInfo
_vRuleNumber :: VictoryInfo -> RuleNumber
_vCond :: VictoryInfo -> NomexNE [PlayerNumber]
partial :: String -> Nomex (Maybe a) -> Nomex a
concatMapM :: Monad m => (a -> m [b]) -> [a] -> m [b]
signalOccAddress :: Lens SignalOccurence SignalAddress
signalOccData :: Lens SignalOccurence SignalData
env :: Lens EventInfo [SignalOccurence]
evStatus :: Lens EventInfo Status
ruleNumber :: Lens EventInfo RuleNumber
eventNumber :: Lens EventInfo EventNumber
playAs :: Lens PlayerInfo (Maybe PlayerNumber)
playerName :: Lens PlayerInfo String
playerNumber :: Lens PlayerInfo PlayerNumber
rAssessedBy :: Lens RuleInfo (Maybe RuleNumber)
rStatus :: Lens RuleInfo RuleStatus
rRule :: Lens RuleInfo Rule
rRuleCode :: Lens RuleInfo Code
rProposedBy :: Lens RuleInfo PlayerNumber
rDescription :: Lens RuleInfo String
rName :: Lens RuleInfo RuleName
rNumber :: Lens RuleInfo RuleNumber
instance Typeable Eff
instance Typeable V
instance Typeable Player
instance Typeable RuleEvent
instance Typeable Msg
instance Typeable InputForm
instance Typeable RuleStatus
instance Typeable PlayerInfo
instance Typeable VictoryInfo
instance Typeable RuleInfo
instance Typeable Signal
instance Typeable Event
instance Show SignalOccurence
instance Show SignalData
instance Eq (Msg e)
instance Eq (InputForm e)
instance Eq (Signal e)
instance Show SomeSignal
instance Show (Signal a)
instance Show (InputForm a)
instance Show SomeData
instance Typeable 'NoEffect
instance Typeable 'Effect
instance Typeable Exp
instance Show Player
instance Eq Player
instance Show RuleEvent
instance Eq RuleEvent
instance Show (Msg m)
instance Show SignalAddressElem
instance Read SignalAddressElem
instance Ord SignalAddressElem
instance Eq SignalAddressElem
instance Generic SignalAddressElem
instance Eq Status
instance Show Status
instance Eq RuleStatus
instance Show RuleStatus
instance Eq PlayerInfo
instance Show PlayerInfo
instance Show VictoryInfo
instance Show RuleInfo
instance Datatype D1SignalAddressElem
instance Constructor C1_0SignalAddressElem
instance Constructor C1_1SignalAddressElem
instance Constructor C1_2SignalAddressElem
instance Constructor C1_3SignalAddressElem
instance Constructor C1_4SignalAddressElem
instance Constructor C1_5SignalAddressElem
instance Constructor C1_6SignalAddressElem
instance (Typeable a, Typeable b) => Show (a -> b)
instance Ord PlayerInfo
instance Ord RuleInfo
instance Eq RuleInfo
instance Ord EventInfo
instance Eq EventInfo
instance Shortcutable Event
instance MonadPlus Event
instance Monad Event
instance Alternative Event
instance Applicative Event
instance Functor Event
instance MonadError String Nomex
instance Applicative (Exp a)
instance Functor (Exp a)
instance Monad (Exp a)
instance Typeable a => Show (Exp Effect a)
instance Typeable a => Show (Exp NoEffect a)


-- | All the building blocks to allow rules to build events.
module Language.Nomyx.Events

-- | register a callback on an event
onEvent :: (Typeable e, Show e) => Event e -> ((EventNumber, e) -> Nomex ()) -> Nomex EventNumber

-- | register a callback on an event, disregard the event number
onEvent_ :: (Typeable e, Show e) => Event e -> (e -> Nomex ()) -> Nomex EventNumber

-- | set an handler for an event that will be triggered only once
onEventOnce :: (Typeable e, Show e) => Event e -> (e -> Nomex ()) -> Nomex EventNumber
delEvent :: EventNumber -> Nomex Bool
getEvents :: NomexNE [EventInfo]
getEvent :: EventNumber -> NomexNE (Maybe EventInfo)
getIntermediateResults :: EventNumber -> NomexNE (Maybe [(PlayerNumber, SomeData)])

-- | broadcast a message that can be catched by another rule
sendMessage :: (Typeable a, Show a) => Msg a -> a -> Nomex ()
sendMessage_ :: String -> Nomex ()

-- | subscribe on a message
onMessage :: (Typeable m, Show m) => Msg m -> (m -> Nomex ()) -> Nomex EventNumber
onMessageOnce :: (Typeable m, Show m) => Msg m -> (m -> Nomex ()) -> Nomex EventNumber

-- | on the provided schedule, the supplied function will be called
schedule :: Schedule Freq -> (UTCTime -> Nomex ()) -> Nomex ()
schedule_ :: Schedule Freq -> Nomex () -> Nomex ()
schedule' :: [UTCTime] -> (UTCTime -> Nomex ()) -> Nomex ()
schedule'_ :: [UTCTime] -> Nomex () -> Nomex ()

-- | get the current time as UTCTime
getCurrentTime :: NomexNE UTCTime

-- | duration
oneWeek :: NominalDiffTime

-- | duration
oneDay :: NominalDiffTime

-- | duration
oneHour :: NominalDiffTime

-- | duration
oneMinute :: NominalDiffTime

-- | Build an event firing at a specific time
timeEvent :: UTCTime -> Event UTCTime

-- | Build a message event, that can be intercepted by another rule this is
--   useful for message-passing style of communication
messageEvent :: Typeable a => Msg a -> Event a

-- | Build a event firing when the victory condition is changed
victoryEvent :: Event VictoryInfo

-- | Build a event firing when a player arrives or leaves
playerEvent :: Player -> Event PlayerInfo

-- | Build a event firing when an action is made on a rule
ruleEvent :: RuleEvent -> Event RuleInfo
signalEvent :: Typeable a => Signal a -> Event a
inputFormSignal :: Typeable a => PlayerNumber -> String -> (InputForm a) -> Signal a

-- | Build a event firing immediatly, yelding the value of the NomexNE
liftEvent :: NomexNE a -> Event a


-- | All the building blocks to allow rules to build variables. for
--   example, you can create a variable with: do newMsgVar_ <a>MyMoney</a>
--   (0::Int)
module Language.Nomyx.Variables

-- | a container for a variable name and type
data V a
V :: String -> V a
varName :: V a -> String

-- | a MsgVar is a variable with a message attached, allowing to trigger
--   registered functions anytime the var if modified
data VEvent a
VUpdated :: a -> VEvent a
VDeleted :: VEvent a
data MsgVar a
MsgVar :: Msg (VEvent a) -> V a -> MsgVar a
message :: MsgVar a -> Msg (VEvent a)
variable :: MsgVar a -> V a

-- | variable creation
newVar :: (Typeable a, Show a) => VarName -> a -> Nomex (Maybe (V a))
newVar_ :: (Typeable a, Show a) => VarName -> a -> Nomex (V a)
newVar' :: (Typeable a, Show a) => V a -> a -> Nomex Bool

-- | variable reading
readVar :: (Typeable a, Show a) => V a -> NomexNE (Maybe a)
readVar_ :: (Typeable a, Show a) => V a -> Nomex a

-- | variable writing
writeVar :: (Typeable a, Show a) => V a -> a -> Nomex Bool

-- | modify a variable using the provided function
modifyVar :: (Typeable a, Show a) => V a -> (a -> a) -> Nomex Bool

-- | delete variable
delVar :: V a -> Nomex Bool
newMsgVar :: (Typeable a, Show a) => VarName -> a -> Nomex (Maybe (MsgVar a))
newMsgVar_ :: (Typeable a, Show a) => VarName -> a -> Nomex (MsgVar a)
newMsgVar' :: (Typeable a, Show a) => MsgVar a -> a -> Nomex Bool
readMsgVar :: (Typeable a, Show a) => MsgVar a -> NomexNE (Maybe a)
readMsgVar_ :: (Typeable a, Show a) => MsgVar a -> Nomex a
writeMsgVar :: (Typeable a, Show a) => MsgVar a -> a -> Nomex Bool
modifyMsgVar :: (Typeable a, Show a) => MsgVar a -> (a -> a) -> Nomex Bool
delMsgVar :: (Typeable a, Show a) => MsgVar a -> Nomex Bool
msgVar :: String -> MsgVar a

-- | create a new MsgVar and register callback in case of change (update,
--   delete)
newMsgVarOnEvent :: (Typeable a, Show a, Eq a) => VarName -> a -> (VEvent a -> Nomex ()) -> Nomex (Maybe (MsgVar a))
onMsgVarEvent :: (Typeable a, Show a) => MsgVar a -> (VEvent a -> Nomex ()) -> Nomex EventNumber

-- | adds a callback for each of the MsgVar events: Create, Update, Delete
onMsgVarChange :: (Typeable a, Show a, Eq a) => MsgVar a -> (a -> Nomex b) -> (a -> b -> Nomex ()) -> (b -> Nomex ()) -> Nomex EventNumber
onMsgVarDelete :: (Typeable a, Show a) => MsgVar a -> Nomex () -> Nomex EventNumber

-- | get the messsage triggered when the array is filled
getMsgVarMessage :: (Typeable a, Show a) => MsgVar a -> NomexNE (Msg (VEvent a))

-- | get the association array
getMsgVarData :: (Typeable a, Show a) => MsgVar a -> NomexNE (Maybe a)
getMsgVarData_ :: (Typeable a, Show a) => MsgVar a -> Nomex a
getMsgVarName :: (Typeable a, Show a) => MsgVar a -> String

-- | ArrayVar is an indexed array with a signal attached triggered at every
--   change. | each indexed elements starts empty (value=Nothing).
type ArrayVar i a = MsgVar [(i, Maybe a)]

-- | initialize an empty ArrayVar
newArrayVar :: (Typeable a, Show a, Typeable i, Show i) => VarName -> [i] -> Nomex (Maybe (ArrayVar i a))
newArrayVar_ :: (Typeable a, Show a, Typeable i, Show i) => VarName -> [i] -> Nomex (ArrayVar i a)

-- | initialize an empty ArrayVar, registering a callback that will be
--   triggered at every change
newArrayVar' :: (Typeable a, Show a, Eq a, Typeable i, Show i, Eq i) => VarName -> [i] -> (VEvent [(i, Maybe a)] -> Nomex ()) -> Nomex (Maybe (ArrayVar i a))

-- | initialize an empty ArrayVar, registering a callback. the ArrayVar
--   will be deleted when full
newArrayVarOnce :: (Typeable a, Show a, Eq a, Typeable i, Show i, Ord i) => VarName -> [i] -> (VEvent [(i, Maybe a)] -> Nomex ()) -> Nomex (Maybe (ArrayVar i a))
cleanOnFull :: (Typeable a, Show a, Eq a, Typeable i, Show i, Ord i) => ArrayVar i a -> Nomex ()
isFullArrayVar_ :: (Typeable a, Show a, Typeable i, Show i, Ord i) => ArrayVar i a -> NomexNE Bool

-- | store one value and the given index. If this is the last filled
--   element, the registered callbacks are triggered.
putArrayVar :: (Typeable a, Show a, Eq a, Typeable i, Show i, Eq i, Ord i) => ArrayVar i a -> i -> a -> Nomex Bool
putArrayVar_ :: (Typeable a, Show a, Eq a, Typeable i, Show i, Ord i) => ArrayVar i a -> i -> a -> Nomex ()
instance Typeable VEvent
instance Show a => Show (VEvent a)
instance Eq a => Eq (VEvent a)


-- | All the building blocks to allow rules to get inputs. for example, you
--   can create a button that will display a message like this: do void $
--   onInputButton_ "Click here:" (const $ outputAll_ "Bravo!") 1
module Language.Nomyx.Inputs

-- | Input forms
data InputForm a
Text :: InputForm String
TextArea :: InputForm String
Button :: InputForm ()
Radio :: [(a, String)] -> InputForm a
Checkbox :: [(a, String)] -> InputForm [a]

-- | event based on a radio input choice
inputRadio :: (Eq c, Show c, Typeable c) => PlayerNumber -> String -> [(c, String)] -> Event c

-- | event based on a text input
inputText :: PlayerNumber -> String -> Event String

-- | event based on a checkbox input
inputCheckbox :: (Eq c, Show c, Typeable c) => PlayerNumber -> String -> [(c, String)] -> Event [c]

-- | event based on a button
inputButton :: PlayerNumber -> String -> Event ()

-- | event based on a text area
inputTextarea :: PlayerNumber -> String -> Event String

-- | triggers a choice input to the user. The result will be sent to the
--   callback
onInputRadio :: (Typeable a, Eq a, Show a) => String -> [a] -> (EventNumber -> a -> Nomex ()) -> PlayerNumber -> Nomex EventNumber

-- | the same, disregard the event number
onInputRadio_ :: (Typeable a, Eq a, Show a) => String -> [a] -> (a -> Nomex ()) -> PlayerNumber -> Nomex EventNumber

-- | the same, suppress the event after first trigger
onInputRadioOnce :: (Typeable a, Eq a, Show a) => String -> [a] -> (a -> Nomex ()) -> PlayerNumber -> Nomex EventNumber
inputRadio' :: (Eq c, Show c, Typeable c) => PlayerNumber -> String -> [c] -> Event c

-- | triggers a string input to the user. The result will be sent to the
--   callback
onInputText :: String -> (EventNumber -> String -> Nomex ()) -> PlayerNumber -> Nomex EventNumber

-- | asks the player pn to answer a question, and feed the callback with
--   this data.
onInputText_ :: String -> (String -> Nomex ()) -> PlayerNumber -> Nomex EventNumber

-- | asks the player pn to answer a question, and feed the callback with
--   this data.
onInputTextOnce :: String -> (String -> Nomex ()) -> PlayerNumber -> Nomex EventNumber
onInputCheckbox :: (Typeable a, Eq a, Show a) => String -> [(a, String)] -> (EventNumber -> [a] -> Nomex ()) -> PlayerNumber -> Nomex EventNumber
onInputCheckbox_ :: (Typeable a, Eq a, Show a) => String -> [(a, String)] -> ([a] -> Nomex ()) -> PlayerNumber -> Nomex EventNumber
onInputCheckboxOnce :: (Typeable a, Eq a, Show a) => String -> [(a, String)] -> ([a] -> Nomex ()) -> PlayerNumber -> Nomex EventNumber
onInputButton :: String -> (EventNumber -> () -> Nomex ()) -> PlayerNumber -> Nomex EventNumber
onInputButton_ :: String -> (() -> Nomex ()) -> PlayerNumber -> Nomex EventNumber
onInputButtonOnce :: String -> (() -> Nomex ()) -> PlayerNumber -> Nomex EventNumber
onInputTextarea :: String -> (EventNumber -> String -> Nomex ()) -> PlayerNumber -> Nomex EventNumber
onInputTextarea_ :: String -> (String -> Nomex ()) -> PlayerNumber -> Nomex EventNumber
onInputTextareaOnce :: String -> (String -> Nomex ()) -> PlayerNumber -> Nomex EventNumber


-- | All the building blocks to allow rules to produce outputs. for
--   example, you can display a message like this: do outputAll_ "hello,
--   world!"
module Language.Nomyx.Outputs
type OutputNumber = Int

-- | outputs a message to one player, dynamic version
newOutput :: Maybe PlayerNumber -> NomexNE String -> Nomex OutputNumber

-- | outputs a message to one player, static version
newOutput_ :: Maybe PlayerNumber -> String -> Nomex OutputNumber

-- | output a message to all players
outputAll :: NomexNE String -> Nomex OutputNumber

-- | output a constant message to all players
outputAll_ :: String -> Nomex ()

-- | get an output by number
getOutput :: OutputNumber -> NomexNE (Maybe String)

-- | get an output by number, partial version
getOutput_ :: OutputNumber -> Nomex String

-- | update an output
updateOutput :: OutputNumber -> NomexNE String -> Nomex Bool

-- | delete an output
delOutput :: OutputNumber -> Nomex Bool
displayVar :: (Typeable a, Show a) => Maybe PlayerNumber -> MsgVar a -> (Maybe a -> NomexNE String) -> Nomex OutputNumber
displayVar' :: (Typeable a, Show a) => Maybe PlayerNumber -> MsgVar a -> (a -> NomexNE String) -> Nomex OutputNumber
displaySimpleVar :: (Typeable a, Show a) => Maybe PlayerNumber -> MsgVar a -> String -> Nomex OutputNumber
displayArrayVar :: (Typeable a, Show a, Typeable i, Show i) => Maybe PlayerNumber -> ArrayVar i a -> String -> Nomex OutputNumber


-- | Basic rules building blocks. for example, you can suppress rule 1
--   with: do suppressRule 1
module Language.Nomyx.Rules
type RuleNumber = Int
type RuleCode = String
data RuleEvent
Proposed :: RuleEvent
Activated :: RuleEvent
Rejected :: RuleEvent
Added :: RuleEvent
Modified :: RuleEvent
Deleted :: RuleEvent

-- | the status of a rule.
data RuleStatus
Active :: RuleStatus
Pending :: RuleStatus
Reject :: RuleStatus

-- | A meta rule is a rule that can juge the legality of another rule.
type MetaRule = RuleInfo -> NomexNE Bool

-- | activate a rule: change its state to Active and execute it
activateRule :: RuleNumber -> Nomex Bool
activateRule_ :: RuleNumber -> Nomex ()

-- | reject a rule: change its state to Suppressed and suppresses all its
--   environment (events, variables, inputs, victory) the rule can be
--   activated again later
rejectRule :: RuleNumber -> Nomex Bool
rejectRule_ :: RuleNumber -> Nomex ()
getRules :: NomexNE [RuleInfo]
getActiveRules :: NomexNE [RuleInfo]
getRule :: RuleNumber -> NomexNE (Maybe RuleInfo)
getRulesByNumbers :: [RuleNumber] -> NomexNE [RuleInfo]
getRuleFuncs :: NomexNE [Nomex ()]

-- | add a rule to the game, it will have to be activated
addRule :: RuleInfo -> Nomex Bool
addRule_ :: RuleInfo -> Nomex ()

-- | add a rule to the game as described by the parameters
addRule' :: RuleName -> Rule -> RuleCode -> String -> Nomex RuleNumber
getFreeRuleNumber :: NomexNE RuleNumber
suppressRule :: RuleNumber -> Nomex Bool
suppressRule_ :: RuleNumber -> Nomex ()
suppressAllRules :: Nomex Bool

-- | propose a rule that will need to be voted on.
proposeRule :: RuleInfo -> Nomex Bool
modifyRule :: RuleNumber -> RuleInfo -> Nomex Bool

-- | This rule will activate automatically any new rule.
autoActivate :: Nomex ()

-- | activate or reject a rule
activateOrRejectRule :: RuleInfo -> Bool -> Nomex ()

-- | simulate the execution of rule "sim" and then run rule "test" over the
--   result
simulate :: Nomex a -> NomexNE Bool -> NomexNE Bool

-- | The meta rules are stored in a list variable
metaruleVar :: MsgVar [(String, MetaRule)]

-- | create the meta rule variable
createMetaruleVar :: Nomex ()

-- | add a new metarule to the list
addMetarule :: MetaRule -> String -> Nomex ()

-- | use the list of meta rules to juge a new rule
testWithMetaRules :: RuleInfo -> NomexNE Bool
displayMetarules :: Nomex ()

-- | A rule will be always legal
legal :: MetaRule

-- | A rule will be always illegal
illegal :: MetaRule

-- | Player p cannot propose any more rules
noPlayPlayer :: PlayerNumber -> MetaRule

-- | rule number rn cannot be deleted by any incoming rule we simulate the
--   execution of an incoming rule to make sure it doesn't delete the
--   immutable rule
immutableRule :: RuleNumber -> MetaRule

-- | a rule can autodelete itself (generaly after having performed some
--   actions)
autoDelete :: Nomex ()

-- | All rules from player p are erased:
eraseAllRules :: PlayerNumber -> Nomex Bool

-- | allows a rule to retrieve its own number (for auto-deleting for
--   example)
getSelfRuleNumber :: NomexNE RuleNumber
getSelfRule :: NomexNE RuleInfo

-- | sets a callback called for each rule proposed
onRuleProposed :: (RuleInfo -> Nomex ()) -> Nomex ()
showRule :: Show a => a -> Exp Effect ()


-- | All the building blocks to allow rules to manage players. for example,
--   you can change the name of player 1 with: do void $ modifyPlayerName 1
--   ("King " ++)
module Language.Nomyx.Players
type PlayerNumber = Int
type PlayerName = String

-- | informations on players
data PlayerInfo
PlayerInfo :: PlayerNumber -> String -> Maybe PlayerNumber -> PlayerInfo
_playerNumber :: PlayerInfo -> PlayerNumber
_playerName :: PlayerInfo -> String
_playAs :: PlayerInfo -> Maybe PlayerNumber

-- | Events parameters
data Player
Arrive :: Player
Leave :: Player

-- | Build a event firing when a player arrives or leaves
playerEvent :: Player -> Event PlayerInfo
playerNumber :: Lens PlayerInfo PlayerNumber
playerName :: Lens PlayerInfo String

-- | get all the players
getPlayers :: NomexNE [PlayerInfo]

-- | Get a specific player
getPlayer :: PlayerNumber -> NomexNE (Maybe PlayerInfo)

-- | Get the name of a player
getPlayerName :: PlayerNumber -> NomexNE (Maybe PlayerName)

-- | Get the name of a player, his number if not found
getPlayerName' :: PlayerNumber -> NomexNE PlayerName

-- | Set the name of a player
setPlayerName :: PlayerNumber -> PlayerName -> Nomex Bool
modifyPlayerName :: PlayerNumber -> (PlayerName -> PlayerName) -> Nomex Bool

-- | Get the total number of players
getPlayersNumber :: NomexNE Int

-- | Get all the players number
getAllPlayerNumbers :: NomexNE [PlayerNumber]

-- | Remove the player from the game (kick)
delPlayer :: PlayerNumber -> Nomex Bool

-- | perform an action for each current players, new players and leaving
--   players returns the event numbers for arriving players and leaving
--   players
forEachPlayer :: (PlayerNumber -> Nomex ()) -> (PlayerNumber -> Nomex ()) -> (PlayerNumber -> Nomex ()) -> Nomex (EventNumber, EventNumber)

-- | perform the same action for each players, including new players
--   returns the event numbers for arriving players and leaving players
forEachPlayer_ :: (PlayerNumber -> Nomex ()) -> Nomex (EventNumber, EventNumber)

-- | create a value initialized for each players manages players joining
--   and leaving
createValueForEachPlayer :: (Typeable a, Show a, Eq a) => a -> MsgVar [(PlayerNumber, a)] -> Nomex (EventNumber, EventNumber)

-- | create a value initialized for each players initialized to zero
--   manages players joining and leaving
createValueForEachPlayer_ :: MsgVar [(PlayerNumber, Int)] -> Nomex (EventNumber, EventNumber)
getValueOfPlayer :: (Typeable a, Show a, Eq a) => PlayerNumber -> MsgVar [(PlayerNumber, a)] -> NomexNE (Maybe a)
modifyValueOfPlayer :: (Eq a, Show a, Typeable a) => PlayerNumber -> MsgVar [(PlayerNumber, a)] -> (a -> a) -> Nomex Bool
modifyAllValues :: (Eq a, Show a, Typeable a) => MsgVar [(PlayerNumber, a)] -> (a -> a) -> Nomex ()

-- | show a player name based on his number
showPlayer :: PlayerNumber -> NomexNE String

-- | get the player number of the proposer of the rule
getProposerNumber :: NomexNE PlayerNumber
getProposerNumber_ :: Nomex PlayerNumber

-- | set victory to a list of players
setVictory :: NomexNE [PlayerNumber] -> Nomex ()

-- | give victory to one player
giveVictory :: PlayerNumber -> Nomex ()

-- | get a random number uniformly distributed in the closed interval
--   [lo,hi] resets the number generator
getRandomNumber :: Random a => (a, a) -> Nomex a


-- | Voting system
module Language.Nomyx.Vote

-- | a vote assessing function (such as unanimity, majority...)
type AssessFunction = VoteStats -> Maybe Bool

-- | the vote statistics, including the number of votes per choice, the
--   number of persons called to vote, and if the vote is finished (timeout
--   or everybody voted)
data VoteStats
VoteStats :: Map Bool Int -> Int -> Bool -> VoteStats
voteCounts :: VoteStats -> Map Bool Int
nbParticipants :: VoteStats -> Int
voteFinished :: VoteStats -> Bool

-- | information broadcasted when a vote begins
data VoteBegin
VoteBegin :: RuleInfo -> UTCTime -> EventNumber -> VoteBegin
vbRule :: VoteBegin -> RuleInfo
vbEndAt :: VoteBegin -> UTCTime
vbEventNumber :: VoteBegin -> EventNumber

-- | information broadcasted when a vote ends
data VoteEnd
VoteEnd :: RuleInfo -> [(PlayerNumber, Maybe Bool)] -> Bool -> UTCTime -> VoteEnd
veRule :: VoteEnd -> RuleInfo
veVotes :: VoteEnd -> [(PlayerNumber, Maybe Bool)]
vePassed :: VoteEnd -> Bool
veFinishedAt :: VoteEnd -> UTCTime
voteBegin :: Msg VoteBegin
voteEnd :: Msg VoteEnd

-- | vote at unanimity every incoming rule
unanimityVote :: Nomex ()

-- | call a vote on a rule for every players, with an assessing function
--   and a delay
callVoteRule :: AssessFunction -> NominalDiffTime -> RuleInfo -> Nomex ()
callVoteRule' :: AssessFunction -> UTCTime -> RuleInfo -> Nomex ()

-- | actions to do when the vote is finished
finishVote :: AssessFunction -> RuleInfo -> [(PlayerNumber, Maybe Bool)] -> Nomex ()

-- | call a vote for every players, with an assessing function, a delay and
--   a function to run on the result
callVote :: AssessFunction -> UTCTime -> String -> RuleNumber -> ([(PlayerNumber, Maybe Bool)] -> Nomex ()) -> Nomex EventNumber

-- | vote with a function able to assess the ongoing votes. | the vote can
--   be concluded as soon as the result is known.
voteWith :: UTCTime -> AssessFunction -> String -> Event [(PlayerNumber, Maybe Bool)]

-- | display the votes (ongoing and finished)
displayVotes :: Nomex ()
singleVote :: String -> PlayerNumber -> Event Bool

-- | assess the vote results according to a unanimity
unanimity :: AssessFunction

-- | assess the vote results according to an absolute majority (half voters
--   plus one)
majority :: AssessFunction

-- | assess the vote results according to a majority of x (in %)
majorityWith :: Int -> AssessFunction

-- | assess the vote results according to a fixed number of positive votes
numberVotes :: Int -> AssessFunction

-- | adds a quorum to an assessing function
withQuorum :: AssessFunction -> Int -> AssessFunction
getVoteStats :: [Maybe Bool] -> Bool -> VoteStats
counts :: (Eq a, Ord a) => [a] -> [(a, Int)]

-- | Compute a result based on a quota of positive votes. the result can be
--   positive if the quota if reached, negative if the quota cannot be
--   reached anymore at that point, or still pending.
voteQuota :: Int -> VoteStats -> Maybe Bool

-- | number of people that voted if the voting is finished, total number of
--   people that should vote otherwise
nbVoters :: VoteStats -> Int
voted :: VoteStats -> Int
notVoted :: VoteStats -> Int

-- | display an on going vote
displayOnGoingVote :: VoteBegin -> Nomex ()
getVotes :: [PlayerNumber] -> [(PlayerNumber, Bool)] -> [(PlayerNumber, Maybe Bool)]
getBooleanResult :: (PlayerNumber, SomeData) -> (PlayerNumber, Bool)
showOnGoingVote :: [(PlayerNumber, Maybe Bool)] -> RuleNumber -> UTCTime -> NomexNE String

-- | display a finished vote
displayFinishedVote :: VoteEnd -> Nomex ()
showFinishedVote :: RuleNumber -> Bool -> [(PlayerNumber, Maybe Bool)] -> UTCTime -> NomexNE String
showVote :: (PlayerNumber, Maybe Bool) -> NomexNE (String, String)
showChoice :: Maybe Bool -> String
instance Typeable VoteStats
instance Typeable VoteBegin
instance Typeable VoteEnd
instance Show VoteStats
instance Show VoteBegin
instance Eq VoteBegin
instance Ord VoteBegin
instance Show VoteEnd
instance Eq VoteEnd
instance Ord VoteEnd


-- | This module re-exports the elements necessary to compose a Nomyx rule.
module Language.Nomyx


-- | This file gives a list of example rules that the players can submit.
--   You can copy-paste them in the field <a>Code</a> of the web GUI. You
--   can copy either the name of the function (i.e. "helloWorld") or its
--   body (i.e. "outputAll_ "hello, world!""), but NOT both. Don't hesitate
--   to get inspiration from there and create your own rules!
module Language.Nomyx.Examples

-- | A rule that does nothing
nothing :: Rule

-- | A rule that says hello to all players
helloWorld :: Rule

-- | account variable name and type
accounts :: MsgVar [(PlayerNumber, Int)]

-- | Create a bank account for each players
createBankAccounts :: Rule

-- | Permanently display the bank accounts
displayBankAccounts :: Rule

-- | each player wins X Ecu each day you can also try with "minutly" or
--   "monthly" instead of "daily" and everything in the "time-recurrence"
--   package
winXEcuPerDay :: Int -> Rule

-- | a player wins X Ecu if a rule proposed is accepted
winXEcuOnRuleAccepted :: Int -> Rule

-- | a player can transfer money to another player
moneyTransfer :: Rule

-- | delete a rule
delRule :: RuleNumber -> Rule

-- | a majority vote, with the folowing parameters: a quorum of 2 voters is
--   necessary for the validity of the vote the vote is assessed after
--   every vote in case the winner is already known the vote will finish
--   anyway after one day
voteWithMajority :: Rule
king :: MsgVar PlayerNumber

-- | player pn is the king: we create a variable King to identify him, and
--   we prefix his name with <a>King</a>
makeKing :: PlayerNumber -> Rule

-- | Monarchy: only the king decides which rules to accept or reject
monarchy :: PlayerNumber -> Rule

-- | Revolution! Hail to the king! This rule suppresses the democracy
--   (usually rules 1 and 2), installs the king and activates monarchy.
revolution :: PlayerNumber -> Rule

-- | will display the current time (when refreshing the screen)
displayCurrentTime :: Rule

-- | will display the time at which the rule as been activated
displayActivateTime :: Nomex ()

-- | Rule that state that you win. Good luck on having this accepted by
--   other players ;)
iWin :: Rule

-- | Change current system (the rules passed in parameter) to absolute
--   majority (half participants plus one)
returnToDemocracy :: [RuleNumber] -> Rule

-- | set the victory for players having more than X accepted rules
victoryXRules :: Int -> Rule
victoryXEcu :: Int -> Rule

-- | Only one player can achieve victory: No group victory. Forbidding
--   group victory usually becomes necessary when lowering the voting
--   quorum: a coalition of players could simply force a "victory" rule and
--   win the game.
noGroupVictory :: Rule

-- | kick a player and prevent him from returning
banPlayer :: PlayerNumber -> Rule
gameMaster :: MsgVar PlayerNumber

-- | display a button and greets you when pressed (for player 1)
bravoButton :: Rule
enterHaiku :: Rule

-- | display a button to greet other players
helloButton :: Rule
instance Typeable Castle
instance Show Castle
instance Eq Castle
