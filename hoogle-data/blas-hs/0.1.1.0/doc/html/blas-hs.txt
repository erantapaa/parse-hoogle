-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Low-level Haskell bindings to Blas.
--   
--   This package provides a complete low-level binding to Blas via the
--   foreign function interface, allowing Haskell programs to take
--   advantage of optimized routines for vector and matrix operations in
--   Haskell.
--   
--   More information can be found at the <a>repository</a>.
@package blas-hs
@version 0.1.1.0


-- | Enumerations used by the Blas interface.
module Blas.Primitive.Types

-- | Memory layout of a matrix.
data Order

-- | Row-major order.
RowMajor :: Order

-- | Column-major order.
ColMajor :: Order

-- | Operation applied to a matrix.
data Transpose

-- | No operation.
NoTrans :: Transpose

-- | Transposition.
Trans :: Transpose

-- | Conjugation and transposition.
ConjTrans :: Transpose

-- | Specifies which triangular part of a matrix is used.
data Uplo

-- | Upper triangular part.
Upper :: Uplo

-- | Lower triangular part.
Lower :: Uplo

-- | Whether a matrix is unit triangular.
data Diag

-- | Not unit triangular.
NonUnit :: Diag

-- | Unit triangular.
Unit :: Diag

-- | The side that a matrix appears in the product.
data Side

-- | On the left side.
Left :: Side

-- | On the right side.
Right :: Side
instance Bounded Order
instance Eq Order
instance Ix Order
instance Ord Order
instance Read Order
instance Show Order
instance Bounded Transpose
instance Eq Transpose
instance Ix Transpose
instance Ord Transpose
instance Read Transpose
instance Show Transpose
instance Bounded Uplo
instance Eq Uplo
instance Ix Uplo
instance Ord Uplo
instance Read Uplo
instance Show Uplo
instance Bounded Diag
instance Eq Diag
instance Ix Diag
instance Ord Diag
instance Read Diag
instance Show Diag
instance Bounded Side
instance Eq Side
instance Ix Side
instance Ord Side
instance Read Side
instance Show Side
instance Enum Side
instance Enum Diag
instance Enum Uplo
instance Enum Transpose
instance Enum Order


-- | Foreign function interface to Blas. These functions use safe foreign
--   calls. Refer to the GHC documentation for more information regarding
--   appropriate use of safe and unsafe foreign calls.
module Blas.Primitive.Safe
sdsdot :: (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> IO ((Float))
dsdot :: (Int) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> IO ((Double))
sdot :: (Int) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> IO ((Float))
ddot :: (Int) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> IO ((Double))
cdotu_sub :: (Int) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> IO ()
zdotu_sub :: (Int) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> IO ()
cdotc_sub :: (Int) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> IO ()
zdotc_sub :: (Int) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> IO ()
snrm2 :: (Int) -> (Ptr Float) -> (Int) -> IO ((Float))
dnrm2 :: (Int) -> (Ptr Double) -> (Int) -> IO ((Double))
scnrm2 :: (Int) -> (Ptr (Complex Float)) -> (Int) -> IO ((Float))
dznrm2 :: (Int) -> (Ptr (Complex Double)) -> (Int) -> IO ((Double))
sasum :: (Int) -> (Ptr Float) -> (Int) -> IO ((Float))
dasum :: (Int) -> (Ptr Double) -> (Int) -> IO ((Double))
scasum :: (Int) -> (Ptr (Complex Float)) -> (Int) -> IO ((Float))
dzasum :: (Int) -> (Ptr (Complex Double)) -> (Int) -> IO ((Double))
isamax :: (Int) -> (Ptr Float) -> (Int) -> IO ((Int))
idamax :: (Int) -> (Ptr Double) -> (Int) -> IO ((Int))
icamax :: (Int) -> (Ptr (Complex Float)) -> (Int) -> IO ((Int))
izamax :: (Int) -> (Ptr (Complex Double)) -> (Int) -> IO ((Int))
sswap :: (Int) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> IO ()
dswap :: (Int) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> IO ()
cswap :: (Int) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zswap :: (Int) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> IO ()
scopy :: (Int) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> IO ()
dcopy :: (Int) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> IO ()
ccopy :: (Int) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zcopy :: (Int) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> IO ()
saxpy :: (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> IO ()
daxpy :: (Int) -> (Double) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> IO ()
caxpy :: (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zaxpy :: (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> IO ()
srotg :: (Ptr Float) -> (Ptr Float) -> (Ptr Float) -> (Ptr Float) -> IO ()
drotg :: (Ptr Double) -> (Ptr Double) -> (Ptr Double) -> (Ptr Double) -> IO ()
srotmg :: (Ptr Float) -> (Ptr Float) -> (Ptr Float) -> (Float) -> (Ptr Float) -> IO ()
drotmg :: (Ptr Double) -> (Ptr Double) -> (Ptr Double) -> (Double) -> (Ptr Double) -> IO ()
srot :: (Int) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> (Float) -> (Float) -> IO ()
drot :: (Int) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> (Double) -> (Double) -> IO ()
srotm :: (Int) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> (Ptr Float) -> IO ()
drotm :: (Int) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> (Ptr Double) -> IO ()
sscal :: (Int) -> (Float) -> (Ptr Float) -> (Int) -> IO ()
dscal :: (Int) -> (Double) -> (Ptr Double) -> (Int) -> IO ()
cscal :: (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> IO ()
csscal :: (Int) -> (Float) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zscal :: (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> IO ()
zdscal :: (Int) -> (Double) -> (Ptr (Complex Double)) -> (Int) -> IO ()
sgemv :: (Order) -> (Transpose) -> (Int) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> IO ()
dgemv :: (Order) -> (Transpose) -> (Int) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> IO ()
cgemv :: (Order) -> (Transpose) -> (Int) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zgemv :: (Order) -> (Transpose) -> (Int) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> IO ()
sgbmv :: (Order) -> (Transpose) -> (Int) -> (Int) -> (Int) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> IO ()
dgbmv :: (Order) -> (Transpose) -> (Int) -> (Int) -> (Int) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> IO ()
cgbmv :: (Order) -> (Transpose) -> (Int) -> (Int) -> (Int) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zgbmv :: (Order) -> (Transpose) -> (Int) -> (Int) -> (Int) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> IO ()
strmv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> IO ()
dtrmv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> IO ()
ctrmv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> IO ()
ztrmv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> IO ()
stbmv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Int) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> IO ()
dtbmv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Int) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> IO ()
ctbmv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> IO ()
ztbmv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> IO ()
stpmv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Ptr Float) -> (Ptr Float) -> (Int) -> IO ()
dtpmv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Ptr Double) -> (Ptr Double) -> (Int) -> IO ()
ctpmv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Ptr (Complex Float)) -> (Ptr (Complex Float)) -> (Int) -> IO ()
ztpmv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Ptr (Complex Double)) -> (Ptr (Complex Double)) -> (Int) -> IO ()
strsv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> IO ()
dtrsv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> IO ()
ctrsv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> IO ()
ztrsv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> IO ()
stbsv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Int) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> IO ()
dtbsv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Int) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> IO ()
ctbsv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> IO ()
ztbsv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> IO ()
stpsv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Ptr Float) -> (Ptr Float) -> (Int) -> IO ()
dtpsv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Ptr Double) -> (Ptr Double) -> (Int) -> IO ()
ctpsv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Ptr (Complex Float)) -> (Ptr (Complex Float)) -> (Int) -> IO ()
ztpsv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Ptr (Complex Double)) -> (Ptr (Complex Double)) -> (Int) -> IO ()
ssymv :: (Order) -> (Uplo) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> IO ()
dsymv :: (Order) -> (Uplo) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> IO ()
ssbmv :: (Order) -> (Uplo) -> (Int) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> IO ()
dsbmv :: (Order) -> (Uplo) -> (Int) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> IO ()
sspmv :: (Order) -> (Uplo) -> (Int) -> (Float) -> (Ptr Float) -> (Ptr Float) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> IO ()
dspmv :: (Order) -> (Uplo) -> (Int) -> (Double) -> (Ptr Double) -> (Ptr Double) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> IO ()
sger :: (Order) -> (Int) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> IO ()
dger :: (Order) -> (Int) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> IO ()
ssyr :: (Order) -> (Uplo) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> IO ()
dsyr :: (Order) -> (Uplo) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> IO ()
ssyr2 :: (Order) -> (Uplo) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> IO ()
dsyr2 :: (Order) -> (Uplo) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> IO ()
sspr :: (Order) -> (Uplo) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Ptr Float) -> IO ()
dspr :: (Order) -> (Uplo) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> (Ptr Double) -> IO ()
sspr2 :: (Order) -> (Uplo) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> (Ptr Float) -> IO ()
dspr2 :: (Order) -> (Uplo) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> (Ptr Double) -> IO ()
chemv :: (Order) -> (Uplo) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zhemv :: (Order) -> (Uplo) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> IO ()
chbmv :: (Order) -> (Uplo) -> (Int) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zhbmv :: (Order) -> (Uplo) -> (Int) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> IO ()
chpmv :: (Order) -> (Uplo) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Ptr (Complex Float)) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zhpmv :: (Order) -> (Uplo) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Ptr (Complex Double)) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> IO ()
cgeru :: (Order) -> (Int) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zgeru :: (Order) -> (Int) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> IO ()
cgerc :: (Order) -> (Int) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zgerc :: (Order) -> (Int) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> IO ()
cher :: (Order) -> (Uplo) -> (Int) -> (Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zher :: (Order) -> (Uplo) -> (Int) -> (Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> IO ()
chpr :: (Order) -> (Uplo) -> (Int) -> (Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> IO ()
zhpr :: (Order) -> (Uplo) -> (Int) -> (Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> IO ()
cher2 :: (Order) -> (Uplo) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zher2 :: (Order) -> (Uplo) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> IO ()
chpr2 :: (Order) -> (Uplo) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> IO ()
zhpr2 :: (Order) -> (Uplo) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> IO ()
sgemm :: (Order) -> (Transpose) -> (Transpose) -> (Int) -> (Int) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> IO ()
dgemm :: (Order) -> (Transpose) -> (Transpose) -> (Int) -> (Int) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> IO ()
cgemm :: (Order) -> (Transpose) -> (Transpose) -> (Int) -> (Int) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zgemm :: (Order) -> (Transpose) -> (Transpose) -> (Int) -> (Int) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> IO ()
ssymm :: (Order) -> (Side) -> (Uplo) -> (Int) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> IO ()
dsymm :: (Order) -> (Side) -> (Uplo) -> (Int) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> IO ()
csymm :: (Order) -> (Side) -> (Uplo) -> (Int) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zsymm :: (Order) -> (Side) -> (Uplo) -> (Int) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> IO ()
ssyrk :: (Order) -> (Uplo) -> (Transpose) -> (Int) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> IO ()
dsyrk :: (Order) -> (Uplo) -> (Transpose) -> (Int) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> IO ()
csyrk :: (Order) -> (Uplo) -> (Transpose) -> (Int) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zsyrk :: (Order) -> (Uplo) -> (Transpose) -> (Int) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> IO ()
ssyr2k :: (Order) -> (Uplo) -> (Transpose) -> (Int) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> IO ()
dsyr2k :: (Order) -> (Uplo) -> (Transpose) -> (Int) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> IO ()
csyr2k :: (Order) -> (Uplo) -> (Transpose) -> (Int) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zsyr2k :: (Order) -> (Uplo) -> (Transpose) -> (Int) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> IO ()
chemm :: (Order) -> (Side) -> (Uplo) -> (Int) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zhemm :: (Order) -> (Side) -> (Uplo) -> (Int) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> IO ()
cherk :: (Order) -> (Uplo) -> (Transpose) -> (Int) -> (Int) -> (Float) -> (Ptr (Complex Float)) -> (Int) -> (Float) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zherk :: (Order) -> (Uplo) -> (Transpose) -> (Int) -> (Int) -> (Double) -> (Ptr (Complex Double)) -> (Int) -> (Double) -> (Ptr (Complex Double)) -> (Int) -> IO ()
cher2k :: (Order) -> (Uplo) -> (Transpose) -> (Int) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Float) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zher2k :: (Order) -> (Uplo) -> (Transpose) -> (Int) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Double) -> (Ptr (Complex Double)) -> (Int) -> IO ()
strmm :: (Order) -> (Side) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> IO ()
dtrmm :: (Order) -> (Side) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> IO ()
ctrmm :: (Order) -> (Side) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> IO ()
ztrmm :: (Order) -> (Side) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> IO ()
strsm :: (Order) -> (Side) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> IO ()
dtrsm :: (Order) -> (Side) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> IO ()
ctrsm :: (Order) -> (Side) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> IO ()
ztrsm :: (Order) -> (Side) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> IO ()


-- | Foreign function interface to Blas. These functions use unsafe foreign
--   calls. Refer to the GHC documentation for more information regarding
--   appropriate use of safe and unsafe foreign calls.
module Blas.Primitive.Unsafe
sdsdot :: (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> IO ((Float))
dsdot :: (Int) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> IO ((Double))
sdot :: (Int) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> IO ((Float))
ddot :: (Int) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> IO ((Double))
cdotu_sub :: (Int) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> IO ()
zdotu_sub :: (Int) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> IO ()
cdotc_sub :: (Int) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> IO ()
zdotc_sub :: (Int) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> IO ()
snrm2 :: (Int) -> (Ptr Float) -> (Int) -> IO ((Float))
dnrm2 :: (Int) -> (Ptr Double) -> (Int) -> IO ((Double))
scnrm2 :: (Int) -> (Ptr (Complex Float)) -> (Int) -> IO ((Float))
dznrm2 :: (Int) -> (Ptr (Complex Double)) -> (Int) -> IO ((Double))
sasum :: (Int) -> (Ptr Float) -> (Int) -> IO ((Float))
dasum :: (Int) -> (Ptr Double) -> (Int) -> IO ((Double))
scasum :: (Int) -> (Ptr (Complex Float)) -> (Int) -> IO ((Float))
dzasum :: (Int) -> (Ptr (Complex Double)) -> (Int) -> IO ((Double))
isamax :: (Int) -> (Ptr Float) -> (Int) -> IO ((Int))
idamax :: (Int) -> (Ptr Double) -> (Int) -> IO ((Int))
icamax :: (Int) -> (Ptr (Complex Float)) -> (Int) -> IO ((Int))
izamax :: (Int) -> (Ptr (Complex Double)) -> (Int) -> IO ((Int))
sswap :: (Int) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> IO ()
dswap :: (Int) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> IO ()
cswap :: (Int) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zswap :: (Int) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> IO ()
scopy :: (Int) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> IO ()
dcopy :: (Int) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> IO ()
ccopy :: (Int) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zcopy :: (Int) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> IO ()
saxpy :: (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> IO ()
daxpy :: (Int) -> (Double) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> IO ()
caxpy :: (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zaxpy :: (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> IO ()
srotg :: (Ptr Float) -> (Ptr Float) -> (Ptr Float) -> (Ptr Float) -> IO ()
drotg :: (Ptr Double) -> (Ptr Double) -> (Ptr Double) -> (Ptr Double) -> IO ()
srotmg :: (Ptr Float) -> (Ptr Float) -> (Ptr Float) -> (Float) -> (Ptr Float) -> IO ()
drotmg :: (Ptr Double) -> (Ptr Double) -> (Ptr Double) -> (Double) -> (Ptr Double) -> IO ()
srot :: (Int) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> (Float) -> (Float) -> IO ()
drot :: (Int) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> (Double) -> (Double) -> IO ()
srotm :: (Int) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> (Ptr Float) -> IO ()
drotm :: (Int) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> (Ptr Double) -> IO ()
sscal :: (Int) -> (Float) -> (Ptr Float) -> (Int) -> IO ()
dscal :: (Int) -> (Double) -> (Ptr Double) -> (Int) -> IO ()
cscal :: (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> IO ()
csscal :: (Int) -> (Float) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zscal :: (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> IO ()
zdscal :: (Int) -> (Double) -> (Ptr (Complex Double)) -> (Int) -> IO ()
sgemv :: (Order) -> (Transpose) -> (Int) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> IO ()
dgemv :: (Order) -> (Transpose) -> (Int) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> IO ()
cgemv :: (Order) -> (Transpose) -> (Int) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zgemv :: (Order) -> (Transpose) -> (Int) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> IO ()
sgbmv :: (Order) -> (Transpose) -> (Int) -> (Int) -> (Int) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> IO ()
dgbmv :: (Order) -> (Transpose) -> (Int) -> (Int) -> (Int) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> IO ()
cgbmv :: (Order) -> (Transpose) -> (Int) -> (Int) -> (Int) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zgbmv :: (Order) -> (Transpose) -> (Int) -> (Int) -> (Int) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> IO ()
strmv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> IO ()
dtrmv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> IO ()
ctrmv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> IO ()
ztrmv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> IO ()
stbmv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Int) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> IO ()
dtbmv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Int) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> IO ()
ctbmv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> IO ()
ztbmv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> IO ()
stpmv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Ptr Float) -> (Ptr Float) -> (Int) -> IO ()
dtpmv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Ptr Double) -> (Ptr Double) -> (Int) -> IO ()
ctpmv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Ptr (Complex Float)) -> (Ptr (Complex Float)) -> (Int) -> IO ()
ztpmv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Ptr (Complex Double)) -> (Ptr (Complex Double)) -> (Int) -> IO ()
strsv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> IO ()
dtrsv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> IO ()
ctrsv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> IO ()
ztrsv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> IO ()
stbsv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Int) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> IO ()
dtbsv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Int) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> IO ()
ctbsv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> IO ()
ztbsv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> IO ()
stpsv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Ptr Float) -> (Ptr Float) -> (Int) -> IO ()
dtpsv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Ptr Double) -> (Ptr Double) -> (Int) -> IO ()
ctpsv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Ptr (Complex Float)) -> (Ptr (Complex Float)) -> (Int) -> IO ()
ztpsv :: (Order) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Ptr (Complex Double)) -> (Ptr (Complex Double)) -> (Int) -> IO ()
ssymv :: (Order) -> (Uplo) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> IO ()
dsymv :: (Order) -> (Uplo) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> IO ()
ssbmv :: (Order) -> (Uplo) -> (Int) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> IO ()
dsbmv :: (Order) -> (Uplo) -> (Int) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> IO ()
sspmv :: (Order) -> (Uplo) -> (Int) -> (Float) -> (Ptr Float) -> (Ptr Float) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> IO ()
dspmv :: (Order) -> (Uplo) -> (Int) -> (Double) -> (Ptr Double) -> (Ptr Double) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> IO ()
sger :: (Order) -> (Int) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> IO ()
dger :: (Order) -> (Int) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> IO ()
ssyr :: (Order) -> (Uplo) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> IO ()
dsyr :: (Order) -> (Uplo) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> IO ()
ssyr2 :: (Order) -> (Uplo) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> IO ()
dsyr2 :: (Order) -> (Uplo) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> IO ()
sspr :: (Order) -> (Uplo) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Ptr Float) -> IO ()
dspr :: (Order) -> (Uplo) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> (Ptr Double) -> IO ()
sspr2 :: (Order) -> (Uplo) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> (Ptr Float) -> IO ()
dspr2 :: (Order) -> (Uplo) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> (Ptr Double) -> IO ()
chemv :: (Order) -> (Uplo) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zhemv :: (Order) -> (Uplo) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> IO ()
chbmv :: (Order) -> (Uplo) -> (Int) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zhbmv :: (Order) -> (Uplo) -> (Int) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> IO ()
chpmv :: (Order) -> (Uplo) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Ptr (Complex Float)) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zhpmv :: (Order) -> (Uplo) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Ptr (Complex Double)) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> IO ()
cgeru :: (Order) -> (Int) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zgeru :: (Order) -> (Int) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> IO ()
cgerc :: (Order) -> (Int) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zgerc :: (Order) -> (Int) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> IO ()
cher :: (Order) -> (Uplo) -> (Int) -> (Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zher :: (Order) -> (Uplo) -> (Int) -> (Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> IO ()
chpr :: (Order) -> (Uplo) -> (Int) -> (Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> IO ()
zhpr :: (Order) -> (Uplo) -> (Int) -> (Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> IO ()
cher2 :: (Order) -> (Uplo) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zher2 :: (Order) -> (Uplo) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> IO ()
chpr2 :: (Order) -> (Uplo) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> IO ()
zhpr2 :: (Order) -> (Uplo) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> IO ()
sgemm :: (Order) -> (Transpose) -> (Transpose) -> (Int) -> (Int) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> IO ()
dgemm :: (Order) -> (Transpose) -> (Transpose) -> (Int) -> (Int) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> IO ()
cgemm :: (Order) -> (Transpose) -> (Transpose) -> (Int) -> (Int) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zgemm :: (Order) -> (Transpose) -> (Transpose) -> (Int) -> (Int) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> IO ()
ssymm :: (Order) -> (Side) -> (Uplo) -> (Int) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> IO ()
dsymm :: (Order) -> (Side) -> (Uplo) -> (Int) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> IO ()
csymm :: (Order) -> (Side) -> (Uplo) -> (Int) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zsymm :: (Order) -> (Side) -> (Uplo) -> (Int) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> IO ()
ssyrk :: (Order) -> (Uplo) -> (Transpose) -> (Int) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> IO ()
dsyrk :: (Order) -> (Uplo) -> (Transpose) -> (Int) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> IO ()
csyrk :: (Order) -> (Uplo) -> (Transpose) -> (Int) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zsyrk :: (Order) -> (Uplo) -> (Transpose) -> (Int) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> IO ()
ssyr2k :: (Order) -> (Uplo) -> (Transpose) -> (Int) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> IO ()
dsyr2k :: (Order) -> (Uplo) -> (Transpose) -> (Int) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> IO ()
csyr2k :: (Order) -> (Uplo) -> (Transpose) -> (Int) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zsyr2k :: (Order) -> (Uplo) -> (Transpose) -> (Int) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> IO ()
chemm :: (Order) -> (Side) -> (Uplo) -> (Int) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zhemm :: (Order) -> (Side) -> (Uplo) -> (Int) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> IO ()
cherk :: (Order) -> (Uplo) -> (Transpose) -> (Int) -> (Int) -> (Float) -> (Ptr (Complex Float)) -> (Int) -> (Float) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zherk :: (Order) -> (Uplo) -> (Transpose) -> (Int) -> (Int) -> (Double) -> (Ptr (Complex Double)) -> (Int) -> (Double) -> (Ptr (Complex Double)) -> (Int) -> IO ()
cher2k :: (Order) -> (Uplo) -> (Transpose) -> (Int) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> (Float) -> (Ptr (Complex Float)) -> (Int) -> IO ()
zher2k :: (Order) -> (Uplo) -> (Transpose) -> (Int) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> (Double) -> (Ptr (Complex Double)) -> (Int) -> IO ()
strmm :: (Order) -> (Side) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> IO ()
dtrmm :: (Order) -> (Side) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> IO ()
ctrmm :: (Order) -> (Side) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> IO ()
ztrmm :: (Order) -> (Side) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> IO ()
strsm :: (Order) -> (Side) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Int) -> (Float) -> (Ptr Float) -> (Int) -> (Ptr Float) -> (Int) -> IO ()
dtrsm :: (Order) -> (Side) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Int) -> (Double) -> (Ptr Double) -> (Int) -> (Ptr Double) -> (Int) -> IO ()
ctrsm :: (Order) -> (Side) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Int) -> (Complex Float) -> (Ptr (Complex Float)) -> (Int) -> (Ptr (Complex Float)) -> (Int) -> IO ()
ztrsm :: (Order) -> (Side) -> (Uplo) -> (Transpose) -> (Diag) -> (Int) -> (Int) -> (Complex Double) -> (Ptr (Complex Double)) -> (Int) -> (Ptr (Complex Double)) -> (Int) -> IO ()


-- | Generic interface to Blas using safe foreign calls. Refer to the GHC
--   documentation for more information regarding appropriate use of safe
--   and unsafe foreign calls.
--   
--   The functions here are named in a similar fashion to the original Blas
--   interface, with the type-dependent letter(s) removed. Some functions
--   have been merged with others to allow the interface to work on both
--   real and complex numbers. If you can't a particular function, try
--   looking for its corresponding complex equivalent (e.g. <tt>symv</tt>
--   is a special case of <a>hemv</a> applied to real numbers).
--   
--   Note: although complex versions of <a>rot</a> and <a>rotg</a> exist in
--   many implementations, they are not part of the official Blas standard
--   and therefore not included here. If you <i>really</i> need them,
--   submit a ticket so we can try to come up with a solution.
--   
--   The documentation here is still incomplete. Consult the <a>official
--   documentation</a> for more information.
--   
--   Notation:
--   
--   <ul>
--   <li><tt>⋅</tt> denotes dot product (without any conjugation).</li>
--   <li><tt>*</tt> denotes complex conjugation.</li>
--   <li><tt>⊤</tt> denotes transpose.</li>
--   <li><tt>†</tt> denotes conjugate transpose (Hermitian conjugate).</li>
--   </ul>
--   
--   Conventions:
--   
--   <ul>
--   <li>All scalars are denoted with lowercase Greek letters</li>
--   <li>All vectors are denoted with lowercase Latin letters and are
--   assumed to be column vectors (unless transposed).</li>
--   <li>All matrices are denoted with uppercase Latin letters.</li>
--   </ul>
--   
--   <i>Since: 0.1.1</i>
module Blas.Specialized.Float.Safe

-- | Generate a Givens rotation. (Only available for real floating-point
--   types.)
rotg :: Ptr Float -> Ptr Float -> Ptr Float -> Ptr Float -> IO ()

-- | Generate a modified Givens rotation. (Only available for real
--   floating-point types.)
rotmg :: Ptr Float -> Ptr Float -> Ptr Float -> Float -> Ptr Float -> IO ()

-- | Apply a Givens rotation. (Only available for real floating-point
--   types.)
rot :: Int -> Ptr Float -> Int -> Ptr Float -> Int -> Float -> Float -> IO ()

-- | Apply a modified Givens rotation. (Only available for real
--   floating-point types.)
rotm :: Int -> Ptr Float -> Int -> Ptr Float -> Int -> Ptr Float -> IO ()

-- | Swap two vectors:
--   
--   <pre>
--   (x, y) ← (y, x)
--   </pre>
swap :: Int -> Ptr Float -> Int -> Ptr Float -> Int -> IO ()

-- | Multiply a vector by a scalar.
--   
--   <pre>
--   x ← α x
--   </pre>
scal :: Int -> Float -> Ptr Float -> Int -> IO ()

-- | Copy a vector into another vector:
--   
--   <pre>
--   y ← x
--   </pre>
copy :: Int -> Ptr Float -> Int -> Ptr Float -> Int -> IO ()

-- | Add a scalar-vector product to a vector.
--   
--   <pre>
--   y ← α x + y
--   </pre>
axpy :: Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> IO ()

-- | Calculate the bilinear dot product of two vectors:
--   
--   <pre>
--   x ⋅ y ≡ ∑[i] x[i] y[i]
--   </pre>
dotu :: Int -> Ptr Float -> Int -> Ptr Float -> Int -> IO Float

-- | Calculate the sesquilinear dot product of two vectors.
--   
--   <pre>
--   x* ⋅ y ≡ ∑[i] x[i]* y[i]
--   </pre>
dotc :: Int -> Ptr Float -> Int -> Ptr Float -> Int -> IO Float

-- | Calculate the dot product of two vectors with extended precision
--   accumulation of the intermediate results and add a scalar value to the
--   result. (Only available for the <tt><a>Float</a></tt> type.)
sdsdot :: Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> IO Float

-- | Calculate the Euclidean (L²) norm of a vector:
--   
--   <pre>
--   ‖x‖₂ ≡ √(∑[i] x[i]²)
--   </pre>
nrm2 :: Int -> Ptr Float -> Int -> IO Float

-- | Calculate the Manhattan (L¹) norm, equal to the sum of the magnitudes
--   of the elements:
--   
--   <pre>
--   ‖x‖₁ = ∑[i] |x[i]|
--   </pre>
asum :: Int -> Ptr Float -> Int -> IO Float

-- | Calculate the index of the element with the maximum magnitude
--   (absolute value).
iamax :: Int -> Ptr Float -> Int -> IO Int

-- | Perform a general matrix-vector update.
--   
--   <pre>
--   y ← α T(A) x + β y
--   </pre>
gemv :: Order -> Transpose -> Int -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> Float -> Ptr Float -> Int -> IO ()

-- | Perform a general banded matrix-vector update.
--   
--   <pre>
--   y ← α T(A) x + β y
--   </pre>
gbmv :: Order -> Transpose -> Int -> Int -> Int -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> Float -> Ptr Float -> Int -> IO ()

-- | Perform a hermitian matrix-vector update.
--   
--   <pre>
--   y ← α A x + β y
--   </pre>
hemv :: Order -> Uplo -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> Float -> Ptr Float -> Int -> IO ()

-- | Perform a hermitian banded matrix-vector update.
--   
--   <pre>
--   y ← α A x + β y
--   </pre>
hbmv :: Order -> Uplo -> Int -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> Float -> Ptr Float -> Int -> IO ()

-- | Perform a hermitian packed matrix-vector update.
--   
--   <pre>
--   y ← α A x + β y
--   </pre>
hpmv :: Order -> Uplo -> Int -> Float -> Ptr Float -> Ptr Float -> Int -> Float -> Ptr Float -> Int -> IO ()

-- | Multiply a triangular matrix by a vector.
--   
--   <pre>
--   x ← T(A) x
--   </pre>
trmv :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr Float -> Int -> Ptr Float -> Int -> IO ()

-- | Multiply a triangular banded matrix by a vector.
--   
--   <pre>
--   x ← T(A) x
--   </pre>
tbmv :: Order -> Uplo -> Transpose -> Diag -> Int -> Int -> Ptr Float -> Int -> Ptr Float -> Int -> IO ()

-- | Multiply a triangular packed matrix by a vector.
--   
--   <pre>
--   x ← T(A) x
--   </pre>
tpmv :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr Float -> Ptr Float -> Int -> IO ()

-- | Multiply an inverse triangular matrix by a vector.
--   
--   <pre>
--   x ← T(A⁻¹) x
--   </pre>
trsv :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr Float -> Int -> Ptr Float -> Int -> IO ()

-- | Multiply an inverse triangular banded matrix by a vector.
--   
--   <pre>
--   x ← T(A⁻¹) x
--   </pre>
tbsv :: Order -> Uplo -> Transpose -> Diag -> Int -> Int -> Ptr Float -> Int -> Ptr Float -> Int -> IO ()

-- | Multiply an inverse triangular packed matrix by a vector.
--   
--   <pre>
--   x ← T(A⁻¹) x
--   </pre>
tpsv :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr Float -> Ptr Float -> Int -> IO ()

-- | Perform an unconjugated rank-1 update of a general matrix.
--   
--   <pre>
--   A ← α x y⊤ + A
--   </pre>
geru :: Order -> Int -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> Ptr Float -> Int -> IO ()

-- | Perform a conjugated rank-1 update of a general matrix.
--   
--   <pre>
--   A ← α x y† + A
--   </pre>
gerc :: Order -> Int -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> Ptr Float -> Int -> IO ()

-- | Perform a rank-1 update of a Hermitian matrix.
--   
--   <pre>
--   A ← α x y† + A
--   </pre>
her :: Order -> Uplo -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> IO ()

-- | Perform a rank-1 update of a Hermitian packed matrix.
--   
--   <pre>
--   A ← α x y† + A
--   </pre>
hpr :: Order -> Uplo -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> IO ()

-- | Perform a rank-2 update of a Hermitian matrix.
--   
--   <pre>
--   A ← α x y† + y (α x)† + A
--   </pre>
her2 :: Order -> Uplo -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> Ptr Float -> Int -> IO ()

-- | Perform a rank-2 update of a Hermitian packed matrix.
--   
--   <pre>
--   A ← α x y† + y (α x)† + A
--   </pre>
hpr2 :: Order -> Uplo -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> Ptr Float -> IO ()

-- | Perform a general matrix-matrix update.
--   
--   <pre>
--   C ← α T(A) U(B) + β C
--   </pre>
gemm :: Order -> Transpose -> Transpose -> Int -> Int -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> Float -> Ptr Float -> Int -> IO ()

-- | Perform a symmetric matrix-matrix update.
--   
--   <pre>
--   C ← α A B + β C    or    C ← α B A + β C
--   </pre>
--   
--   where <tt>A</tt> is symmetric. The matrix <tt>A</tt> must be in an
--   unpacked format, although the routine will only access half of it as
--   specified by the <tt><a>Uplo</a></tt> argument.
symm :: Order -> Side -> Uplo -> Int -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> Float -> Ptr Float -> Int -> IO ()

-- | Perform a Hermitian matrix-matrix update.
--   
--   <pre>
--   C ← α A B + β C    or    C ← α B A + β C
--   </pre>
--   
--   where <tt>A</tt> is Hermitian. The matrix <tt>A</tt> must be in an
--   unpacked format, although the routine will only access half of it as
--   specified by the <tt><a>Uplo</a></tt> argument.
hemm :: Order -> Side -> Uplo -> Int -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> Float -> Ptr Float -> Int -> IO ()

-- | Perform a symmetric rank-k update.
--   
--   <pre>
--   C ← α A A⊤ + β C    or    C ← α A⊤ A + β C
--   </pre>
syrk :: Order -> Uplo -> Transpose -> Int -> Int -> Float -> Ptr Float -> Int -> Float -> Ptr Float -> Int -> IO ()

-- | Perform a Hermitian rank-k update.
--   
--   <pre>
--   C ← α A A† + β C    or    C ← α A† A + β C
--   </pre>
herk :: Order -> Uplo -> Transpose -> Int -> Int -> Float -> Ptr Float -> Int -> Float -> Ptr Float -> Int -> IO ()

-- | Perform a symmetric rank-2k update.
--   
--   <pre>
--   C ← α A B⊤ + α* B A⊤ + β C    or    C ← α A⊤ B + α* B⊤ A + β C
--   </pre>
syr2k :: Order -> Uplo -> Transpose -> Int -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> Float -> Ptr Float -> Int -> IO ()

-- | Perform a Hermitian rank-2k update.
--   
--   <pre>
--   C ← α A B† + α* B A† + β C    or    C ← α A† B + α* B† A + β C
--   </pre>
her2k :: Order -> Uplo -> Transpose -> Int -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> Float -> Ptr Float -> Int -> IO ()

-- | Perform a triangular matrix-matrix multiplication.
--   
--   <pre>
--   B ← α T(A) B    or    B ← α B T(A)
--   </pre>
--   
--   where <tt>A</tt> is triangular.
trmm :: Order -> Side -> Uplo -> Transpose -> Diag -> Int -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> IO ()

-- | Perform an inverse triangular matrix-matrix multiplication.
--   
--   <pre>
--   B ← α T(A⁻¹) B    or    B ← α B T(A⁻¹)
--   </pre>
--   
--   where <tt>A</tt> is triangular.
trsm :: Order -> Side -> Uplo -> Transpose -> Diag -> Int -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> IO ()


-- | Generic interface to Blas using safe foreign calls. Refer to the GHC
--   documentation for more information regarding appropriate use of safe
--   and unsafe foreign calls.
--   
--   The functions here are named in a similar fashion to the original Blas
--   interface, with the type-dependent letter(s) removed. Some functions
--   have been merged with others to allow the interface to work on both
--   real and complex numbers. If you can't a particular function, try
--   looking for its corresponding complex equivalent (e.g. <tt>symv</tt>
--   is a special case of <a>hemv</a> applied to real numbers).
--   
--   Note: although complex versions of <a>rot</a> and <a>rotg</a> exist in
--   many implementations, they are not part of the official Blas standard
--   and therefore not included here. If you <i>really</i> need them,
--   submit a ticket so we can try to come up with a solution.
--   
--   The documentation here is still incomplete. Consult the <a>official
--   documentation</a> for more information.
--   
--   Notation:
--   
--   <ul>
--   <li><tt>⋅</tt> denotes dot product (without any conjugation).</li>
--   <li><tt>*</tt> denotes complex conjugation.</li>
--   <li><tt>⊤</tt> denotes transpose.</li>
--   <li><tt>†</tt> denotes conjugate transpose (Hermitian conjugate).</li>
--   </ul>
--   
--   Conventions:
--   
--   <ul>
--   <li>All scalars are denoted with lowercase Greek letters</li>
--   <li>All vectors are denoted with lowercase Latin letters and are
--   assumed to be column vectors (unless transposed).</li>
--   <li>All matrices are denoted with uppercase Latin letters.</li>
--   </ul>
--   
--   <i>Since: 0.1.1</i>
module Blas.Specialized.Double.Safe

-- | Generate a Givens rotation. (Only available for real floating-point
--   types.)
rotg :: Ptr Double -> Ptr Double -> Ptr Double -> Ptr Double -> IO ()

-- | Generate a modified Givens rotation. (Only available for real
--   floating-point types.)
rotmg :: Ptr Double -> Ptr Double -> Ptr Double -> Double -> Ptr Double -> IO ()

-- | Apply a Givens rotation. (Only available for real floating-point
--   types.)
rot :: Int -> Ptr Double -> Int -> Ptr Double -> Int -> Double -> Double -> IO ()

-- | Apply a modified Givens rotation. (Only available for real
--   floating-point types.)
rotm :: Int -> Ptr Double -> Int -> Ptr Double -> Int -> Ptr Double -> IO ()

-- | Swap two vectors:
--   
--   <pre>
--   (x, y) ← (y, x)
--   </pre>
swap :: Int -> Ptr Double -> Int -> Ptr Double -> Int -> IO ()

-- | Multiply a vector by a scalar.
--   
--   <pre>
--   x ← α x
--   </pre>
scal :: Int -> Double -> Ptr Double -> Int -> IO ()

-- | Copy a vector into another vector:
--   
--   <pre>
--   y ← x
--   </pre>
copy :: Int -> Ptr Double -> Int -> Ptr Double -> Int -> IO ()

-- | Add a scalar-vector product to a vector.
--   
--   <pre>
--   y ← α x + y
--   </pre>
axpy :: Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> IO ()

-- | Calculate the bilinear dot product of two vectors:
--   
--   <pre>
--   x ⋅ y ≡ ∑[i] x[i] y[i]
--   </pre>
dotu :: Int -> Ptr Double -> Int -> Ptr Double -> Int -> IO Double

-- | Calculate the sesquilinear dot product of two vectors.
--   
--   <pre>
--   x* ⋅ y ≡ ∑[i] x[i]* y[i]
--   </pre>
dotc :: Int -> Ptr Double -> Int -> Ptr Double -> Int -> IO Double

-- | Calculate the dot product of two vectors with extended precision
--   accumulation of the intermediate results and return a double-precision
--   result. (Only available in the <tt>Double</tt> module.)
dsdot :: Int -> Ptr Float -> Int -> Ptr Float -> Int -> IO Double

-- | Calculate the Euclidean (L²) norm of a vector:
--   
--   <pre>
--   ‖x‖₂ ≡ √(∑[i] x[i]²)
--   </pre>
nrm2 :: Int -> Ptr Double -> Int -> IO Double

-- | Calculate the Manhattan (L¹) norm, equal to the sum of the magnitudes
--   of the elements:
--   
--   <pre>
--   ‖x‖₁ = ∑[i] |x[i]|
--   </pre>
asum :: Int -> Ptr Double -> Int -> IO Double

-- | Calculate the index of the element with the maximum magnitude
--   (absolute value).
iamax :: Int -> Ptr Double -> Int -> IO Int

-- | Perform a general matrix-vector update.
--   
--   <pre>
--   y ← α T(A) x + β y
--   </pre>
gemv :: Order -> Transpose -> Int -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> Double -> Ptr Double -> Int -> IO ()

-- | Perform a general banded matrix-vector update.
--   
--   <pre>
--   y ← α T(A) x + β y
--   </pre>
gbmv :: Order -> Transpose -> Int -> Int -> Int -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> Double -> Ptr Double -> Int -> IO ()

-- | Perform a hermitian matrix-vector update.
--   
--   <pre>
--   y ← α A x + β y
--   </pre>
hemv :: Order -> Uplo -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> Double -> Ptr Double -> Int -> IO ()

-- | Perform a hermitian banded matrix-vector update.
--   
--   <pre>
--   y ← α A x + β y
--   </pre>
hbmv :: Order -> Uplo -> Int -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> Double -> Ptr Double -> Int -> IO ()

-- | Perform a hermitian packed matrix-vector update.
--   
--   <pre>
--   y ← α A x + β y
--   </pre>
hpmv :: Order -> Uplo -> Int -> Double -> Ptr Double -> Ptr Double -> Int -> Double -> Ptr Double -> Int -> IO ()

-- | Multiply a triangular matrix by a vector.
--   
--   <pre>
--   x ← T(A) x
--   </pre>
trmv :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr Double -> Int -> Ptr Double -> Int -> IO ()

-- | Multiply a triangular banded matrix by a vector.
--   
--   <pre>
--   x ← T(A) x
--   </pre>
tbmv :: Order -> Uplo -> Transpose -> Diag -> Int -> Int -> Ptr Double -> Int -> Ptr Double -> Int -> IO ()

-- | Multiply a triangular packed matrix by a vector.
--   
--   <pre>
--   x ← T(A) x
--   </pre>
tpmv :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr Double -> Ptr Double -> Int -> IO ()

-- | Multiply an inverse triangular matrix by a vector.
--   
--   <pre>
--   x ← T(A⁻¹) x
--   </pre>
trsv :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr Double -> Int -> Ptr Double -> Int -> IO ()

-- | Multiply an inverse triangular banded matrix by a vector.
--   
--   <pre>
--   x ← T(A⁻¹) x
--   </pre>
tbsv :: Order -> Uplo -> Transpose -> Diag -> Int -> Int -> Ptr Double -> Int -> Ptr Double -> Int -> IO ()

-- | Multiply an inverse triangular packed matrix by a vector.
--   
--   <pre>
--   x ← T(A⁻¹) x
--   </pre>
tpsv :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr Double -> Ptr Double -> Int -> IO ()

-- | Perform an unconjugated rank-1 update of a general matrix.
--   
--   <pre>
--   A ← α x y⊤ + A
--   </pre>
geru :: Order -> Int -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> Ptr Double -> Int -> IO ()

-- | Perform a conjugated rank-1 update of a general matrix.
--   
--   <pre>
--   A ← α x y† + A
--   </pre>
gerc :: Order -> Int -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> Ptr Double -> Int -> IO ()

-- | Perform a rank-1 update of a Hermitian matrix.
--   
--   <pre>
--   A ← α x y† + A
--   </pre>
her :: Order -> Uplo -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> IO ()

-- | Perform a rank-1 update of a Hermitian packed matrix.
--   
--   <pre>
--   A ← α x y† + A
--   </pre>
hpr :: Order -> Uplo -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> IO ()

-- | Perform a rank-2 update of a Hermitian matrix.
--   
--   <pre>
--   A ← α x y† + y (α x)† + A
--   </pre>
her2 :: Order -> Uplo -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> Ptr Double -> Int -> IO ()

-- | Perform a rank-2 update of a Hermitian packed matrix.
--   
--   <pre>
--   A ← α x y† + y (α x)† + A
--   </pre>
hpr2 :: Order -> Uplo -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> Ptr Double -> IO ()

-- | Perform a general matrix-matrix update.
--   
--   <pre>
--   C ← α T(A) U(B) + β C
--   </pre>
gemm :: Order -> Transpose -> Transpose -> Int -> Int -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> Double -> Ptr Double -> Int -> IO ()

-- | Perform a symmetric matrix-matrix update.
--   
--   <pre>
--   C ← α A B + β C    or    C ← α B A + β C
--   </pre>
--   
--   where <tt>A</tt> is symmetric. The matrix <tt>A</tt> must be in an
--   unpacked format, although the routine will only access half of it as
--   specified by the <tt><a>Uplo</a></tt> argument.
symm :: Order -> Side -> Uplo -> Int -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> Double -> Ptr Double -> Int -> IO ()

-- | Perform a Hermitian matrix-matrix update.
--   
--   <pre>
--   C ← α A B + β C    or    C ← α B A + β C
--   </pre>
--   
--   where <tt>A</tt> is Hermitian. The matrix <tt>A</tt> must be in an
--   unpacked format, although the routine will only access half of it as
--   specified by the <tt><a>Uplo</a></tt> argument.
hemm :: Order -> Side -> Uplo -> Int -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> Double -> Ptr Double -> Int -> IO ()

-- | Perform a symmetric rank-k update.
--   
--   <pre>
--   C ← α A A⊤ + β C    or    C ← α A⊤ A + β C
--   </pre>
syrk :: Order -> Uplo -> Transpose -> Int -> Int -> Double -> Ptr Double -> Int -> Double -> Ptr Double -> Int -> IO ()

-- | Perform a Hermitian rank-k update.
--   
--   <pre>
--   C ← α A A† + β C    or    C ← α A† A + β C
--   </pre>
herk :: Order -> Uplo -> Transpose -> Int -> Int -> Double -> Ptr Double -> Int -> Double -> Ptr Double -> Int -> IO ()

-- | Perform a symmetric rank-2k update.
--   
--   <pre>
--   C ← α A B⊤ + α* B A⊤ + β C    or    C ← α A⊤ B + α* B⊤ A + β C
--   </pre>
syr2k :: Order -> Uplo -> Transpose -> Int -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> Double -> Ptr Double -> Int -> IO ()

-- | Perform a Hermitian rank-2k update.
--   
--   <pre>
--   C ← α A B† + α* B A† + β C    or    C ← α A† B + α* B† A + β C
--   </pre>
her2k :: Order -> Uplo -> Transpose -> Int -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> Double -> Ptr Double -> Int -> IO ()

-- | Perform a triangular matrix-matrix multiplication.
--   
--   <pre>
--   B ← α T(A) B    or    B ← α B T(A)
--   </pre>
--   
--   where <tt>A</tt> is triangular.
trmm :: Order -> Side -> Uplo -> Transpose -> Diag -> Int -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> IO ()

-- | Perform an inverse triangular matrix-matrix multiplication.
--   
--   <pre>
--   B ← α T(A⁻¹) B    or    B ← α B T(A⁻¹)
--   </pre>
--   
--   where <tt>A</tt> is triangular.
trsm :: Order -> Side -> Uplo -> Transpose -> Diag -> Int -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> IO ()


-- | Generic interface to Blas using safe foreign calls. Refer to the GHC
--   documentation for more information regarding appropriate use of safe
--   and unsafe foreign calls.
--   
--   The functions here are named in a similar fashion to the original Blas
--   interface, with the type-dependent letter(s) removed. Some functions
--   have been merged with others to allow the interface to work on both
--   real and complex numbers. If you can't a particular function, try
--   looking for its corresponding complex equivalent (e.g. <tt>symv</tt>
--   is a special case of <a>hemv</a> applied to real numbers).
--   
--   Note: although complex versions of <tt>rot</tt> and <tt>rotg</tt>
--   exist in many implementations, they are not part of the official Blas
--   standard and therefore not included here. If you <i>really</i> need
--   them, submit a ticket so we can try to come up with a solution.
--   
--   The documentation here is still incomplete. Consult the <a>official
--   documentation</a> for more information.
--   
--   Notation:
--   
--   <ul>
--   <li><tt>⋅</tt> denotes dot product (without any conjugation).</li>
--   <li><tt>*</tt> denotes complex conjugation.</li>
--   <li><tt>⊤</tt> denotes transpose.</li>
--   <li><tt>†</tt> denotes conjugate transpose (Hermitian conjugate).</li>
--   </ul>
--   
--   Conventions:
--   
--   <ul>
--   <li>All scalars are denoted with lowercase Greek letters</li>
--   <li>All vectors are denoted with lowercase Latin letters and are
--   assumed to be column vectors (unless transposed).</li>
--   <li>All matrices are denoted with uppercase Latin letters.</li>
--   </ul>
--   
--   <i>Since: 0.1.1</i>
module Blas.Specialized.ComplexFloat.Safe

-- | Swap two vectors:
--   
--   <pre>
--   (x, y) ← (y, x)
--   </pre>
swap :: Int -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> IO ()

-- | Multiply a vector by a scalar.
--   
--   <pre>
--   x ← α x
--   </pre>
scal :: Int -> Complex Float -> Ptr (Complex Float) -> Int -> IO ()

-- | Copy a vector into another vector:
--   
--   <pre>
--   y ← x
--   </pre>
copy :: Int -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> IO ()

-- | Add a scalar-vector product to a vector.
--   
--   <pre>
--   y ← α x + y
--   </pre>
axpy :: Int -> Complex Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> IO ()

-- | Calculate the bilinear dot product of two vectors:
--   
--   <pre>
--   x ⋅ y ≡ ∑[i] x[i] y[i]
--   </pre>
dotu :: Int -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> IO (Complex Float)

-- | Calculate the sesquilinear dot product of two vectors.
--   
--   <pre>
--   x* ⋅ y ≡ ∑[i] x[i]* y[i]
--   </pre>
dotc :: Int -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> IO (Complex Float)

-- | Calculate the Euclidean (L²) norm of a vector:
--   
--   <pre>
--   ‖x‖₂ ≡ √(∑[i] x[i]²)
--   </pre>
nrm2 :: Int -> Ptr (Complex Float) -> Int -> IO Float

-- | Calculate the Manhattan (L¹) norm, equal to the sum of the magnitudes
--   of the elements:
--   
--   <pre>
--   ‖x‖₁ = ∑[i] |x[i]|
--   </pre>
asum :: Int -> Ptr (Complex Float) -> Int -> IO Float

-- | Calculate the index of the element with the maximum magnitude
--   (absolute value).
iamax :: Int -> Ptr (Complex Float) -> Int -> IO Int

-- | Perform a general matrix-vector update.
--   
--   <pre>
--   y ← α T(A) x + β y
--   </pre>
gemv :: Order -> Transpose -> Int -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform a general banded matrix-vector update.
--   
--   <pre>
--   y ← α T(A) x + β y
--   </pre>
gbmv :: Order -> Transpose -> Int -> Int -> Int -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform a hermitian matrix-vector update.
--   
--   <pre>
--   y ← α A x + β y
--   </pre>
hemv :: Order -> Uplo -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform a hermitian banded matrix-vector update.
--   
--   <pre>
--   y ← α A x + β y
--   </pre>
hbmv :: Order -> Uplo -> Int -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform a hermitian packed matrix-vector update.
--   
--   <pre>
--   y ← α A x + β y
--   </pre>
hpmv :: Order -> Uplo -> Int -> Complex Float -> Ptr (Complex Float) -> Ptr (Complex Float) -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> IO ()

-- | Multiply a triangular matrix by a vector.
--   
--   <pre>
--   x ← T(A) x
--   </pre>
trmv :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> IO ()

-- | Multiply a triangular banded matrix by a vector.
--   
--   <pre>
--   x ← T(A) x
--   </pre>
tbmv :: Order -> Uplo -> Transpose -> Diag -> Int -> Int -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> IO ()

-- | Multiply a triangular packed matrix by a vector.
--   
--   <pre>
--   x ← T(A) x
--   </pre>
tpmv :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr (Complex Float) -> Ptr (Complex Float) -> Int -> IO ()

-- | Multiply an inverse triangular matrix by a vector.
--   
--   <pre>
--   x ← T(A⁻¹) x
--   </pre>
trsv :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> IO ()

-- | Multiply an inverse triangular banded matrix by a vector.
--   
--   <pre>
--   x ← T(A⁻¹) x
--   </pre>
tbsv :: Order -> Uplo -> Transpose -> Diag -> Int -> Int -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> IO ()

-- | Multiply an inverse triangular packed matrix by a vector.
--   
--   <pre>
--   x ← T(A⁻¹) x
--   </pre>
tpsv :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr (Complex Float) -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform an unconjugated rank-1 update of a general matrix.
--   
--   <pre>
--   A ← α x y⊤ + A
--   </pre>
geru :: Order -> Int -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform a conjugated rank-1 update of a general matrix.
--   
--   <pre>
--   A ← α x y† + A
--   </pre>
gerc :: Order -> Int -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform a rank-1 update of a Hermitian matrix.
--   
--   <pre>
--   A ← α x y† + A
--   </pre>
her :: Order -> Uplo -> Int -> Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform a rank-1 update of a Hermitian packed matrix.
--   
--   <pre>
--   A ← α x y† + A
--   </pre>
hpr :: Order -> Uplo -> Int -> Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> IO ()

-- | Perform a rank-2 update of a Hermitian matrix.
--   
--   <pre>
--   A ← α x y† + y (α x)† + A
--   </pre>
her2 :: Order -> Uplo -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform a rank-2 update of a Hermitian packed matrix.
--   
--   <pre>
--   A ← α x y† + y (α x)† + A
--   </pre>
hpr2 :: Order -> Uplo -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> IO ()

-- | Perform a general matrix-matrix update.
--   
--   <pre>
--   C ← α T(A) U(B) + β C
--   </pre>
gemm :: Order -> Transpose -> Transpose -> Int -> Int -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform a symmetric matrix-matrix update.
--   
--   <pre>
--   C ← α A B + β C    or    C ← α B A + β C
--   </pre>
--   
--   where <tt>A</tt> is symmetric. The matrix <tt>A</tt> must be in an
--   unpacked format, although the routine will only access half of it as
--   specified by the <tt><a>Uplo</a></tt> argument.
symm :: Order -> Side -> Uplo -> Int -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform a Hermitian matrix-matrix update.
--   
--   <pre>
--   C ← α A B + β C    or    C ← α B A + β C
--   </pre>
--   
--   where <tt>A</tt> is Hermitian. The matrix <tt>A</tt> must be in an
--   unpacked format, although the routine will only access half of it as
--   specified by the <tt><a>Uplo</a></tt> argument.
hemm :: Order -> Side -> Uplo -> Int -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform a symmetric rank-k update.
--   
--   <pre>
--   C ← α A A⊤ + β C    or    C ← α A⊤ A + β C
--   </pre>
syrk :: Order -> Uplo -> Transpose -> Int -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform a Hermitian rank-k update.
--   
--   <pre>
--   C ← α A A† + β C    or    C ← α A† A + β C
--   </pre>
herk :: Order -> Uplo -> Transpose -> Int -> Int -> Float -> Ptr (Complex Float) -> Int -> Float -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform a symmetric rank-2k update.
--   
--   <pre>
--   C ← α A B⊤ + α* B A⊤ + β C    or    C ← α A⊤ B + α* B⊤ A + β C
--   </pre>
syr2k :: Order -> Uplo -> Transpose -> Int -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform a Hermitian rank-2k update.
--   
--   <pre>
--   C ← α A B† + α* B A† + β C    or    C ← α A† B + α* B† A + β C
--   </pre>
her2k :: Order -> Uplo -> Transpose -> Int -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> Float -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform a triangular matrix-matrix multiplication.
--   
--   <pre>
--   B ← α T(A) B    or    B ← α B T(A)
--   </pre>
--   
--   where <tt>A</tt> is triangular.
trmm :: Order -> Side -> Uplo -> Transpose -> Diag -> Int -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform an inverse triangular matrix-matrix multiplication.
--   
--   <pre>
--   B ← α T(A⁻¹) B    or    B ← α B T(A⁻¹)
--   </pre>
--   
--   where <tt>A</tt> is triangular.
trsm :: Order -> Side -> Uplo -> Transpose -> Diag -> Int -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> IO ()


-- | Generic interface to Blas using safe foreign calls. Refer to the GHC
--   documentation for more information regarding appropriate use of safe
--   and unsafe foreign calls.
--   
--   The functions here are named in a similar fashion to the original Blas
--   interface, with the type-dependent letter(s) removed. Some functions
--   have been merged with others to allow the interface to work on both
--   real and complex numbers. If you can't a particular function, try
--   looking for its corresponding complex equivalent (e.g. <tt>symv</tt>
--   is a special case of <a>hemv</a> applied to real numbers).
--   
--   Note: although complex versions of <tt>rot</tt> and <tt>rotg</tt>
--   exist in many implementations, they are not part of the official Blas
--   standard and therefore not included here. If you <i>really</i> need
--   them, submit a ticket so we can try to come up with a solution.
--   
--   The documentation here is still incomplete. Consult the <a>official
--   documentation</a> for more information.
--   
--   Notation:
--   
--   <ul>
--   <li><tt>⋅</tt> denotes dot product (without any conjugation).</li>
--   <li><tt>*</tt> denotes complex conjugation.</li>
--   <li><tt>⊤</tt> denotes transpose.</li>
--   <li><tt>†</tt> denotes conjugate transpose (Hermitian conjugate).</li>
--   </ul>
--   
--   Conventions:
--   
--   <ul>
--   <li>All scalars are denoted with lowercase Greek letters</li>
--   <li>All vectors are denoted with lowercase Latin letters and are
--   assumed to be column vectors (unless transposed).</li>
--   <li>All matrices are denoted with uppercase Latin letters.</li>
--   </ul>
--   
--   <i>Since: 0.1.1</i>
module Blas.Specialized.ComplexDouble.Safe

-- | Swap two vectors:
--   
--   <pre>
--   (x, y) ← (y, x)
--   </pre>
swap :: Int -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> IO ()

-- | Multiply a vector by a scalar.
--   
--   <pre>
--   x ← α x
--   </pre>
scal :: Int -> Complex Double -> Ptr (Complex Double) -> Int -> IO ()

-- | Copy a vector into another vector:
--   
--   <pre>
--   y ← x
--   </pre>
copy :: Int -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> IO ()

-- | Add a scalar-vector product to a vector.
--   
--   <pre>
--   y ← α x + y
--   </pre>
axpy :: Int -> Complex Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> IO ()

-- | Calculate the bilinear dot product of two vectors:
--   
--   <pre>
--   x ⋅ y ≡ ∑[i] x[i] y[i]
--   </pre>
dotu :: Int -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> IO (Complex Double)

-- | Calculate the sesquilinear dot product of two vectors.
--   
--   <pre>
--   x* ⋅ y ≡ ∑[i] x[i]* y[i]
--   </pre>
dotc :: Int -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> IO (Complex Double)

-- | Calculate the Euclidean (L²) norm of a vector:
--   
--   <pre>
--   ‖x‖₂ ≡ √(∑[i] x[i]²)
--   </pre>
nrm2 :: Int -> Ptr (Complex Double) -> Int -> IO Double

-- | Calculate the Manhattan (L¹) norm, equal to the sum of the magnitudes
--   of the elements:
--   
--   <pre>
--   ‖x‖₁ = ∑[i] |x[i]|
--   </pre>
asum :: Int -> Ptr (Complex Double) -> Int -> IO Double

-- | Calculate the index of the element with the maximum magnitude
--   (absolute value).
iamax :: Int -> Ptr (Complex Double) -> Int -> IO Int

-- | Perform a general matrix-vector update.
--   
--   <pre>
--   y ← α T(A) x + β y
--   </pre>
gemv :: Order -> Transpose -> Int -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform a general banded matrix-vector update.
--   
--   <pre>
--   y ← α T(A) x + β y
--   </pre>
gbmv :: Order -> Transpose -> Int -> Int -> Int -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform a hermitian matrix-vector update.
--   
--   <pre>
--   y ← α A x + β y
--   </pre>
hemv :: Order -> Uplo -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform a hermitian banded matrix-vector update.
--   
--   <pre>
--   y ← α A x + β y
--   </pre>
hbmv :: Order -> Uplo -> Int -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform a hermitian packed matrix-vector update.
--   
--   <pre>
--   y ← α A x + β y
--   </pre>
hpmv :: Order -> Uplo -> Int -> Complex Double -> Ptr (Complex Double) -> Ptr (Complex Double) -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> IO ()

-- | Multiply a triangular matrix by a vector.
--   
--   <pre>
--   x ← T(A) x
--   </pre>
trmv :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> IO ()

-- | Multiply a triangular banded matrix by a vector.
--   
--   <pre>
--   x ← T(A) x
--   </pre>
tbmv :: Order -> Uplo -> Transpose -> Diag -> Int -> Int -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> IO ()

-- | Multiply a triangular packed matrix by a vector.
--   
--   <pre>
--   x ← T(A) x
--   </pre>
tpmv :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr (Complex Double) -> Ptr (Complex Double) -> Int -> IO ()

-- | Multiply an inverse triangular matrix by a vector.
--   
--   <pre>
--   x ← T(A⁻¹) x
--   </pre>
trsv :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> IO ()

-- | Multiply an inverse triangular banded matrix by a vector.
--   
--   <pre>
--   x ← T(A⁻¹) x
--   </pre>
tbsv :: Order -> Uplo -> Transpose -> Diag -> Int -> Int -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> IO ()

-- | Multiply an inverse triangular packed matrix by a vector.
--   
--   <pre>
--   x ← T(A⁻¹) x
--   </pre>
tpsv :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr (Complex Double) -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform an unconjugated rank-1 update of a general matrix.
--   
--   <pre>
--   A ← α x y⊤ + A
--   </pre>
geru :: Order -> Int -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform a conjugated rank-1 update of a general matrix.
--   
--   <pre>
--   A ← α x y† + A
--   </pre>
gerc :: Order -> Int -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform a rank-1 update of a Hermitian matrix.
--   
--   <pre>
--   A ← α x y† + A
--   </pre>
her :: Order -> Uplo -> Int -> Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform a rank-1 update of a Hermitian packed matrix.
--   
--   <pre>
--   A ← α x y† + A
--   </pre>
hpr :: Order -> Uplo -> Int -> Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> IO ()

-- | Perform a rank-2 update of a Hermitian matrix.
--   
--   <pre>
--   A ← α x y† + y (α x)† + A
--   </pre>
her2 :: Order -> Uplo -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform a rank-2 update of a Hermitian packed matrix.
--   
--   <pre>
--   A ← α x y† + y (α x)† + A
--   </pre>
hpr2 :: Order -> Uplo -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> IO ()

-- | Perform a general matrix-matrix update.
--   
--   <pre>
--   C ← α T(A) U(B) + β C
--   </pre>
gemm :: Order -> Transpose -> Transpose -> Int -> Int -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform a symmetric matrix-matrix update.
--   
--   <pre>
--   C ← α A B + β C    or    C ← α B A + β C
--   </pre>
--   
--   where <tt>A</tt> is symmetric. The matrix <tt>A</tt> must be in an
--   unpacked format, although the routine will only access half of it as
--   specified by the <tt><a>Uplo</a></tt> argument.
symm :: Order -> Side -> Uplo -> Int -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform a Hermitian matrix-matrix update.
--   
--   <pre>
--   C ← α A B + β C    or    C ← α B A + β C
--   </pre>
--   
--   where <tt>A</tt> is Hermitian. The matrix <tt>A</tt> must be in an
--   unpacked format, although the routine will only access half of it as
--   specified by the <tt><a>Uplo</a></tt> argument.
hemm :: Order -> Side -> Uplo -> Int -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform a symmetric rank-k update.
--   
--   <pre>
--   C ← α A A⊤ + β C    or    C ← α A⊤ A + β C
--   </pre>
syrk :: Order -> Uplo -> Transpose -> Int -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform a Hermitian rank-k update.
--   
--   <pre>
--   C ← α A A† + β C    or    C ← α A† A + β C
--   </pre>
herk :: Order -> Uplo -> Transpose -> Int -> Int -> Double -> Ptr (Complex Double) -> Int -> Double -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform a symmetric rank-2k update.
--   
--   <pre>
--   C ← α A B⊤ + α* B A⊤ + β C    or    C ← α A⊤ B + α* B⊤ A + β C
--   </pre>
syr2k :: Order -> Uplo -> Transpose -> Int -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform a Hermitian rank-2k update.
--   
--   <pre>
--   C ← α A B† + α* B A† + β C    or    C ← α A† B + α* B† A + β C
--   </pre>
her2k :: Order -> Uplo -> Transpose -> Int -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> Double -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform a triangular matrix-matrix multiplication.
--   
--   <pre>
--   B ← α T(A) B    or    B ← α B T(A)
--   </pre>
--   
--   where <tt>A</tt> is triangular.
trmm :: Order -> Side -> Uplo -> Transpose -> Diag -> Int -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform an inverse triangular matrix-matrix multiplication.
--   
--   <pre>
--   B ← α T(A⁻¹) B    or    B ← α B T(A⁻¹)
--   </pre>
--   
--   where <tt>A</tt> is triangular.
trsm :: Order -> Side -> Uplo -> Transpose -> Diag -> Int -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> IO ()


-- | Generic interface to Blas using safe foreign calls. Refer to the GHC
--   documentation for more information regarding appropriate use of safe
--   and unsafe foreign calls.
--   
--   The functions here are named in a similar fashion to the original Blas
--   interface, with the type-dependent letter(s) removed. Some functions
--   have been merged with others to allow the interface to work on both
--   real and complex numbers. If you can't a particular function, try
--   looking for its corresponding complex equivalent (e.g. <tt>symv</tt>
--   is a special case of <a>hemv</a> applied to real numbers).
--   
--   Note: although complex versions of <a>rot</a> and <a>rotg</a> exist in
--   many implementations, they are not part of the official Blas standard
--   and therefore not included here. If you <i>really</i> need them,
--   submit a ticket so we can try to come up with a solution.
--   
--   The documentation here is still incomplete. Consult the <a>official
--   documentation</a> for more information.
--   
--   Notation:
--   
--   <ul>
--   <li><tt>⋅</tt> denotes dot product (without any conjugation).</li>
--   <li><tt>*</tt> denotes complex conjugation.</li>
--   <li><tt>⊤</tt> denotes transpose.</li>
--   <li><tt>†</tt> denotes conjugate transpose (Hermitian conjugate).</li>
--   </ul>
--   
--   Conventions:
--   
--   <ul>
--   <li>All scalars are denoted with lowercase Greek letters</li>
--   <li>All vectors are denoted with lowercase Latin letters and are
--   assumed to be column vectors (unless transposed).</li>
--   <li>All matrices are denoted with uppercase Latin letters.</li>
--   </ul>
module Blas.Generic.Safe

-- | Blas operations that are applicable to real and complex numbers.
--   
--   Instances are defined for the 4 types supported by Blas: the single-
--   and double-precision floating point types and their complex versions.
class (Floating a, Storable a) => Numeric a where type family RealType a :: *
swap :: Numeric a => Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
scal :: Numeric a => Int -> a -> Ptr a -> Int -> IO ()
copy :: Numeric a => Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
axpy :: Numeric a => Int -> a -> Ptr a -> Int -> Ptr a -> Int -> IO ()
dotu :: Numeric a => Int -> Ptr a -> Int -> Ptr a -> Int -> IO a
dotc :: Numeric a => Int -> Ptr a -> Int -> Ptr a -> Int -> IO a
nrm2 :: Numeric a => Int -> Ptr a -> Int -> IO (RealType a)
asum :: Numeric a => Int -> Ptr a -> Int -> IO (RealType a)
iamax :: Numeric a => Int -> Ptr a -> Int -> IO Int
gemv :: Numeric a => Order -> Transpose -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
gbmv :: Numeric a => Order -> Transpose -> Int -> Int -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
hemv :: Numeric a => Order -> Uplo -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
hbmv :: Numeric a => Order -> Uplo -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
hpmv :: Numeric a => Order -> Uplo -> Int -> a -> Ptr a -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
trmv :: Numeric a => Order -> Uplo -> Transpose -> Diag -> Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
tbmv :: Numeric a => Order -> Uplo -> Transpose -> Diag -> Int -> Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
tpmv :: Numeric a => Order -> Uplo -> Transpose -> Diag -> Int -> Ptr a -> Ptr a -> Int -> IO ()
trsv :: Numeric a => Order -> Uplo -> Transpose -> Diag -> Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
tbsv :: Numeric a => Order -> Uplo -> Transpose -> Diag -> Int -> Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
tpsv :: Numeric a => Order -> Uplo -> Transpose -> Diag -> Int -> Ptr a -> Ptr a -> Int -> IO ()
geru :: Numeric a => Order -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
gerc :: Numeric a => Order -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
her :: Numeric a => Order -> Uplo -> Int -> RealType a -> Ptr a -> Int -> Ptr a -> Int -> IO ()
hpr :: Numeric a => Order -> Uplo -> Int -> RealType a -> Ptr a -> Int -> Ptr a -> IO ()
her2 :: Numeric a => Order -> Uplo -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
hpr2 :: Numeric a => Order -> Uplo -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> Ptr a -> IO ()
gemm :: Numeric a => Order -> Transpose -> Transpose -> Int -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
symm :: Numeric a => Order -> Side -> Uplo -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
hemm :: Numeric a => Order -> Side -> Uplo -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
syrk :: Numeric a => Order -> Uplo -> Transpose -> Int -> Int -> a -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
herk :: Numeric a => Order -> Uplo -> Transpose -> Int -> Int -> RealType a -> Ptr a -> Int -> RealType a -> Ptr a -> Int -> IO ()
syr2k :: Numeric a => Order -> Uplo -> Transpose -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
her2k :: Numeric a => Order -> Uplo -> Transpose -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> RealType a -> Ptr a -> Int -> IO ()
trmm :: Numeric a => Order -> Side -> Uplo -> Transpose -> Diag -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> IO ()
trsm :: Numeric a => Order -> Side -> Uplo -> Transpose -> Diag -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> IO ()

-- | Blas operations that are only applicable to real numbers.
class Numeric a => RealNumeric a
rotg :: RealNumeric a => Ptr a -> Ptr a -> Ptr a -> Ptr a -> IO ()
rotmg :: RealNumeric a => Ptr a -> Ptr a -> Ptr a -> a -> Ptr a -> IO ()
rot :: RealNumeric a => Int -> Ptr a -> Int -> Ptr a -> Int -> a -> a -> IO ()
rotm :: RealNumeric a => Int -> Ptr a -> Int -> Ptr a -> Int -> Ptr a -> IO ()

-- | Calculate the dot product of two vectors with extended precision
--   accumulation of the intermediate results and return a double-precision
--   result. (Only available in the <tt>Double</tt> module.)
dsdot :: Int -> Ptr Float -> Int -> Ptr Float -> Int -> IO Double

-- | Calculate the dot product of two vectors with extended precision
--   accumulation of the intermediate results and add a scalar value to the
--   result. (Only available for the <tt><a>Float</a></tt> type.)
sdsdot :: Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> IO Float
instance RealNumeric Double
instance RealNumeric Float
instance Numeric (Complex Double)
instance Numeric (Complex Float)
instance Numeric Double
instance Numeric Float


-- | Generic interface to Blas using unsafe foreign calls. Refer to the GHC
--   documentation for more information regarding appropriate use of safe
--   and unsafe foreign calls.
--   
--   The functions here are named in a similar fashion to the original Blas
--   interface, with the type-dependent letter(s) removed. Some functions
--   have been merged with others to allow the interface to work on both
--   real and complex numbers. If you can't a particular function, try
--   looking for its corresponding complex equivalent (e.g. <tt>symv</tt>
--   is a special case of <a>hemv</a> applied to real numbers).
--   
--   Note: although complex versions of <a>rot</a> and <a>rotg</a> exist in
--   many implementations, they are not part of the official Blas standard
--   and therefore not included here. If you <i>really</i> need them,
--   submit a ticket so we can try to come up with a solution.
--   
--   The documentation here is still incomplete. Consult the <a>official
--   documentation</a> for more information.
--   
--   Notation:
--   
--   <ul>
--   <li><tt>⋅</tt> denotes dot product (without any conjugation).</li>
--   <li><tt>*</tt> denotes complex conjugation.</li>
--   <li><tt>⊤</tt> denotes transpose.</li>
--   <li><tt>†</tt> denotes conjugate transpose (Hermitian conjugate).</li>
--   </ul>
--   
--   Conventions:
--   
--   <ul>
--   <li>All scalars are denoted with lowercase Greek letters</li>
--   <li>All vectors are denoted with lowercase Latin letters and are
--   assumed to be column vectors (unless transposed).</li>
--   <li>All matrices are denoted with uppercase Latin letters.</li>
--   </ul>
--   
--   <i>Since: 0.1.1</i>
module Blas.Specialized.Float.Unsafe

-- | Generate a Givens rotation. (Only available for real floating-point
--   types.)
rotg :: Ptr Float -> Ptr Float -> Ptr Float -> Ptr Float -> IO ()

-- | Generate a modified Givens rotation. (Only available for real
--   floating-point types.)
rotmg :: Ptr Float -> Ptr Float -> Ptr Float -> Float -> Ptr Float -> IO ()

-- | Apply a Givens rotation. (Only available for real floating-point
--   types.)
rot :: Int -> Ptr Float -> Int -> Ptr Float -> Int -> Float -> Float -> IO ()

-- | Apply a modified Givens rotation. (Only available for real
--   floating-point types.)
rotm :: Int -> Ptr Float -> Int -> Ptr Float -> Int -> Ptr Float -> IO ()

-- | Swap two vectors:
--   
--   <pre>
--   (x, y) ← (y, x)
--   </pre>
swap :: Int -> Ptr Float -> Int -> Ptr Float -> Int -> IO ()

-- | Multiply a vector by a scalar.
--   
--   <pre>
--   x ← α x
--   </pre>
scal :: Int -> Float -> Ptr Float -> Int -> IO ()

-- | Copy a vector into another vector:
--   
--   <pre>
--   y ← x
--   </pre>
copy :: Int -> Ptr Float -> Int -> Ptr Float -> Int -> IO ()

-- | Add a scalar-vector product to a vector.
--   
--   <pre>
--   y ← α x + y
--   </pre>
axpy :: Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> IO ()

-- | Calculate the bilinear dot product of two vectors:
--   
--   <pre>
--   x ⋅ y ≡ ∑[i] x[i] y[i]
--   </pre>
dotu :: Int -> Ptr Float -> Int -> Ptr Float -> Int -> IO Float

-- | Calculate the sesquilinear dot product of two vectors.
--   
--   <pre>
--   x* ⋅ y ≡ ∑[i] x[i]* y[i]
--   </pre>
dotc :: Int -> Ptr Float -> Int -> Ptr Float -> Int -> IO Float

-- | Calculate the dot product of two vectors with extended precision
--   accumulation of the intermediate results and add a scalar value to the
--   result. (Only available for the <tt><a>Float</a></tt> type.)
sdsdot :: Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> IO Float

-- | Calculate the Euclidean (L²) norm of a vector:
--   
--   <pre>
--   ‖x‖₂ ≡ √(∑[i] x[i]²)
--   </pre>
nrm2 :: Int -> Ptr Float -> Int -> IO Float

-- | Calculate the Manhattan (L¹) norm, equal to the sum of the magnitudes
--   of the elements:
--   
--   <pre>
--   ‖x‖₁ = ∑[i] |x[i]|
--   </pre>
asum :: Int -> Ptr Float -> Int -> IO Float

-- | Calculate the index of the element with the maximum magnitude
--   (absolute value).
iamax :: Int -> Ptr Float -> Int -> IO Int

-- | Perform a general matrix-vector update.
--   
--   <pre>
--   y ← α T(A) x + β y
--   </pre>
gemv :: Order -> Transpose -> Int -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> Float -> Ptr Float -> Int -> IO ()

-- | Perform a general banded matrix-vector update.
--   
--   <pre>
--   y ← α T(A) x + β y
--   </pre>
gbmv :: Order -> Transpose -> Int -> Int -> Int -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> Float -> Ptr Float -> Int -> IO ()

-- | Perform a hermitian matrix-vector update.
--   
--   <pre>
--   y ← α A x + β y
--   </pre>
hemv :: Order -> Uplo -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> Float -> Ptr Float -> Int -> IO ()

-- | Perform a hermitian banded matrix-vector update.
--   
--   <pre>
--   y ← α A x + β y
--   </pre>
hbmv :: Order -> Uplo -> Int -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> Float -> Ptr Float -> Int -> IO ()

-- | Perform a hermitian packed matrix-vector update.
--   
--   <pre>
--   y ← α A x + β y
--   </pre>
hpmv :: Order -> Uplo -> Int -> Float -> Ptr Float -> Ptr Float -> Int -> Float -> Ptr Float -> Int -> IO ()

-- | Multiply a triangular matrix by a vector.
--   
--   <pre>
--   x ← T(A) x
--   </pre>
trmv :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr Float -> Int -> Ptr Float -> Int -> IO ()

-- | Multiply a triangular banded matrix by a vector.
--   
--   <pre>
--   x ← T(A) x
--   </pre>
tbmv :: Order -> Uplo -> Transpose -> Diag -> Int -> Int -> Ptr Float -> Int -> Ptr Float -> Int -> IO ()

-- | Multiply a triangular packed matrix by a vector.
--   
--   <pre>
--   x ← T(A) x
--   </pre>
tpmv :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr Float -> Ptr Float -> Int -> IO ()

-- | Multiply an inverse triangular matrix by a vector.
--   
--   <pre>
--   x ← T(A⁻¹) x
--   </pre>
trsv :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr Float -> Int -> Ptr Float -> Int -> IO ()

-- | Multiply an inverse triangular banded matrix by a vector.
--   
--   <pre>
--   x ← T(A⁻¹) x
--   </pre>
tbsv :: Order -> Uplo -> Transpose -> Diag -> Int -> Int -> Ptr Float -> Int -> Ptr Float -> Int -> IO ()

-- | Multiply an inverse triangular packed matrix by a vector.
--   
--   <pre>
--   x ← T(A⁻¹) x
--   </pre>
tpsv :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr Float -> Ptr Float -> Int -> IO ()

-- | Perform an unconjugated rank-1 update of a general matrix.
--   
--   <pre>
--   A ← α x y⊤ + A
--   </pre>
geru :: Order -> Int -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> Ptr Float -> Int -> IO ()

-- | Perform a conjugated rank-1 update of a general matrix.
--   
--   <pre>
--   A ← α x y† + A
--   </pre>
gerc :: Order -> Int -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> Ptr Float -> Int -> IO ()

-- | Perform a rank-1 update of a Hermitian matrix.
--   
--   <pre>
--   A ← α x y† + A
--   </pre>
her :: Order -> Uplo -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> IO ()

-- | Perform a rank-1 update of a Hermitian packed matrix.
--   
--   <pre>
--   A ← α x y† + A
--   </pre>
hpr :: Order -> Uplo -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> IO ()

-- | Perform a rank-2 update of a Hermitian matrix.
--   
--   <pre>
--   A ← α x y† + y (α x)† + A
--   </pre>
her2 :: Order -> Uplo -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> Ptr Float -> Int -> IO ()

-- | Perform a rank-2 update of a Hermitian packed matrix.
--   
--   <pre>
--   A ← α x y† + y (α x)† + A
--   </pre>
hpr2 :: Order -> Uplo -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> Ptr Float -> IO ()

-- | Perform a general matrix-matrix update.
--   
--   <pre>
--   C ← α T(A) U(B) + β C
--   </pre>
gemm :: Order -> Transpose -> Transpose -> Int -> Int -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> Float -> Ptr Float -> Int -> IO ()

-- | Perform a symmetric matrix-matrix update.
--   
--   <pre>
--   C ← α A B + β C    or    C ← α B A + β C
--   </pre>
--   
--   where <tt>A</tt> is symmetric. The matrix <tt>A</tt> must be in an
--   unpacked format, although the routine will only access half of it as
--   specified by the <tt><a>Uplo</a></tt> argument.
symm :: Order -> Side -> Uplo -> Int -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> Float -> Ptr Float -> Int -> IO ()

-- | Perform a Hermitian matrix-matrix update.
--   
--   <pre>
--   C ← α A B + β C    or    C ← α B A + β C
--   </pre>
--   
--   where <tt>A</tt> is Hermitian. The matrix <tt>A</tt> must be in an
--   unpacked format, although the routine will only access half of it as
--   specified by the <tt><a>Uplo</a></tt> argument.
hemm :: Order -> Side -> Uplo -> Int -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> Float -> Ptr Float -> Int -> IO ()

-- | Perform a symmetric rank-k update.
--   
--   <pre>
--   C ← α A A⊤ + β C    or    C ← α A⊤ A + β C
--   </pre>
syrk :: Order -> Uplo -> Transpose -> Int -> Int -> Float -> Ptr Float -> Int -> Float -> Ptr Float -> Int -> IO ()

-- | Perform a Hermitian rank-k update.
--   
--   <pre>
--   C ← α A A† + β C    or    C ← α A† A + β C
--   </pre>
herk :: Order -> Uplo -> Transpose -> Int -> Int -> Float -> Ptr Float -> Int -> Float -> Ptr Float -> Int -> IO ()

-- | Perform a symmetric rank-2k update.
--   
--   <pre>
--   C ← α A B⊤ + α* B A⊤ + β C    or    C ← α A⊤ B + α* B⊤ A + β C
--   </pre>
syr2k :: Order -> Uplo -> Transpose -> Int -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> Float -> Ptr Float -> Int -> IO ()

-- | Perform a Hermitian rank-2k update.
--   
--   <pre>
--   C ← α A B† + α* B A† + β C    or    C ← α A† B + α* B† A + β C
--   </pre>
her2k :: Order -> Uplo -> Transpose -> Int -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> Float -> Ptr Float -> Int -> IO ()

-- | Perform a triangular matrix-matrix multiplication.
--   
--   <pre>
--   B ← α T(A) B    or    B ← α B T(A)
--   </pre>
--   
--   where <tt>A</tt> is triangular.
trmm :: Order -> Side -> Uplo -> Transpose -> Diag -> Int -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> IO ()

-- | Perform an inverse triangular matrix-matrix multiplication.
--   
--   <pre>
--   B ← α T(A⁻¹) B    or    B ← α B T(A⁻¹)
--   </pre>
--   
--   where <tt>A</tt> is triangular.
trsm :: Order -> Side -> Uplo -> Transpose -> Diag -> Int -> Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> IO ()


-- | Generic interface to Blas using unsafe foreign calls. Refer to the GHC
--   documentation for more information regarding appropriate use of safe
--   and unsafe foreign calls.
--   
--   The functions here are named in a similar fashion to the original Blas
--   interface, with the type-dependent letter(s) removed. Some functions
--   have been merged with others to allow the interface to work on both
--   real and complex numbers. If you can't a particular function, try
--   looking for its corresponding complex equivalent (e.g. <tt>symv</tt>
--   is a special case of <a>hemv</a> applied to real numbers).
--   
--   Note: although complex versions of <a>rot</a> and <a>rotg</a> exist in
--   many implementations, they are not part of the official Blas standard
--   and therefore not included here. If you <i>really</i> need them,
--   submit a ticket so we can try to come up with a solution.
--   
--   The documentation here is still incomplete. Consult the <a>official
--   documentation</a> for more information.
--   
--   Notation:
--   
--   <ul>
--   <li><tt>⋅</tt> denotes dot product (without any conjugation).</li>
--   <li><tt>*</tt> denotes complex conjugation.</li>
--   <li><tt>⊤</tt> denotes transpose.</li>
--   <li><tt>†</tt> denotes conjugate transpose (Hermitian conjugate).</li>
--   </ul>
--   
--   Conventions:
--   
--   <ul>
--   <li>All scalars are denoted with lowercase Greek letters</li>
--   <li>All vectors are denoted with lowercase Latin letters and are
--   assumed to be column vectors (unless transposed).</li>
--   <li>All matrices are denoted with uppercase Latin letters.</li>
--   </ul>
--   
--   <i>Since: 0.1.1</i>
module Blas.Specialized.Double.Unsafe

-- | Generate a Givens rotation. (Only available for real floating-point
--   types.)
rotg :: Ptr Double -> Ptr Double -> Ptr Double -> Ptr Double -> IO ()

-- | Generate a modified Givens rotation. (Only available for real
--   floating-point types.)
rotmg :: Ptr Double -> Ptr Double -> Ptr Double -> Double -> Ptr Double -> IO ()

-- | Apply a Givens rotation. (Only available for real floating-point
--   types.)
rot :: Int -> Ptr Double -> Int -> Ptr Double -> Int -> Double -> Double -> IO ()

-- | Apply a modified Givens rotation. (Only available for real
--   floating-point types.)
rotm :: Int -> Ptr Double -> Int -> Ptr Double -> Int -> Ptr Double -> IO ()

-- | Swap two vectors:
--   
--   <pre>
--   (x, y) ← (y, x)
--   </pre>
swap :: Int -> Ptr Double -> Int -> Ptr Double -> Int -> IO ()

-- | Multiply a vector by a scalar.
--   
--   <pre>
--   x ← α x
--   </pre>
scal :: Int -> Double -> Ptr Double -> Int -> IO ()

-- | Copy a vector into another vector:
--   
--   <pre>
--   y ← x
--   </pre>
copy :: Int -> Ptr Double -> Int -> Ptr Double -> Int -> IO ()

-- | Add a scalar-vector product to a vector.
--   
--   <pre>
--   y ← α x + y
--   </pre>
axpy :: Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> IO ()

-- | Calculate the bilinear dot product of two vectors:
--   
--   <pre>
--   x ⋅ y ≡ ∑[i] x[i] y[i]
--   </pre>
dotu :: Int -> Ptr Double -> Int -> Ptr Double -> Int -> IO Double

-- | Calculate the sesquilinear dot product of two vectors.
--   
--   <pre>
--   x* ⋅ y ≡ ∑[i] x[i]* y[i]
--   </pre>
dotc :: Int -> Ptr Double -> Int -> Ptr Double -> Int -> IO Double

-- | Calculate the dot product of two vectors with extended precision
--   accumulation of the intermediate results and return a double-precision
--   result. (Only available in the <tt>Double</tt> module.)
dsdot :: Int -> Ptr Float -> Int -> Ptr Float -> Int -> IO Double

-- | Calculate the Euclidean (L²) norm of a vector:
--   
--   <pre>
--   ‖x‖₂ ≡ √(∑[i] x[i]²)
--   </pre>
nrm2 :: Int -> Ptr Double -> Int -> IO Double

-- | Calculate the Manhattan (L¹) norm, equal to the sum of the magnitudes
--   of the elements:
--   
--   <pre>
--   ‖x‖₁ = ∑[i] |x[i]|
--   </pre>
asum :: Int -> Ptr Double -> Int -> IO Double

-- | Calculate the index of the element with the maximum magnitude
--   (absolute value).
iamax :: Int -> Ptr Double -> Int -> IO Int

-- | Perform a general matrix-vector update.
--   
--   <pre>
--   y ← α T(A) x + β y
--   </pre>
gemv :: Order -> Transpose -> Int -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> Double -> Ptr Double -> Int -> IO ()

-- | Perform a general banded matrix-vector update.
--   
--   <pre>
--   y ← α T(A) x + β y
--   </pre>
gbmv :: Order -> Transpose -> Int -> Int -> Int -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> Double -> Ptr Double -> Int -> IO ()

-- | Perform a hermitian matrix-vector update.
--   
--   <pre>
--   y ← α A x + β y
--   </pre>
hemv :: Order -> Uplo -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> Double -> Ptr Double -> Int -> IO ()

-- | Perform a hermitian banded matrix-vector update.
--   
--   <pre>
--   y ← α A x + β y
--   </pre>
hbmv :: Order -> Uplo -> Int -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> Double -> Ptr Double -> Int -> IO ()

-- | Perform a hermitian packed matrix-vector update.
--   
--   <pre>
--   y ← α A x + β y
--   </pre>
hpmv :: Order -> Uplo -> Int -> Double -> Ptr Double -> Ptr Double -> Int -> Double -> Ptr Double -> Int -> IO ()

-- | Multiply a triangular matrix by a vector.
--   
--   <pre>
--   x ← T(A) x
--   </pre>
trmv :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr Double -> Int -> Ptr Double -> Int -> IO ()

-- | Multiply a triangular banded matrix by a vector.
--   
--   <pre>
--   x ← T(A) x
--   </pre>
tbmv :: Order -> Uplo -> Transpose -> Diag -> Int -> Int -> Ptr Double -> Int -> Ptr Double -> Int -> IO ()

-- | Multiply a triangular packed matrix by a vector.
--   
--   <pre>
--   x ← T(A) x
--   </pre>
tpmv :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr Double -> Ptr Double -> Int -> IO ()

-- | Multiply an inverse triangular matrix by a vector.
--   
--   <pre>
--   x ← T(A⁻¹) x
--   </pre>
trsv :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr Double -> Int -> Ptr Double -> Int -> IO ()

-- | Multiply an inverse triangular banded matrix by a vector.
--   
--   <pre>
--   x ← T(A⁻¹) x
--   </pre>
tbsv :: Order -> Uplo -> Transpose -> Diag -> Int -> Int -> Ptr Double -> Int -> Ptr Double -> Int -> IO ()

-- | Multiply an inverse triangular packed matrix by a vector.
--   
--   <pre>
--   x ← T(A⁻¹) x
--   </pre>
tpsv :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr Double -> Ptr Double -> Int -> IO ()

-- | Perform an unconjugated rank-1 update of a general matrix.
--   
--   <pre>
--   A ← α x y⊤ + A
--   </pre>
geru :: Order -> Int -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> Ptr Double -> Int -> IO ()

-- | Perform a conjugated rank-1 update of a general matrix.
--   
--   <pre>
--   A ← α x y† + A
--   </pre>
gerc :: Order -> Int -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> Ptr Double -> Int -> IO ()

-- | Perform a rank-1 update of a Hermitian matrix.
--   
--   <pre>
--   A ← α x y† + A
--   </pre>
her :: Order -> Uplo -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> IO ()

-- | Perform a rank-1 update of a Hermitian packed matrix.
--   
--   <pre>
--   A ← α x y† + A
--   </pre>
hpr :: Order -> Uplo -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> IO ()

-- | Perform a rank-2 update of a Hermitian matrix.
--   
--   <pre>
--   A ← α x y† + y (α x)† + A
--   </pre>
her2 :: Order -> Uplo -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> Ptr Double -> Int -> IO ()

-- | Perform a rank-2 update of a Hermitian packed matrix.
--   
--   <pre>
--   A ← α x y† + y (α x)† + A
--   </pre>
hpr2 :: Order -> Uplo -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> Ptr Double -> IO ()

-- | Perform a general matrix-matrix update.
--   
--   <pre>
--   C ← α T(A) U(B) + β C
--   </pre>
gemm :: Order -> Transpose -> Transpose -> Int -> Int -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> Double -> Ptr Double -> Int -> IO ()

-- | Perform a symmetric matrix-matrix update.
--   
--   <pre>
--   C ← α A B + β C    or    C ← α B A + β C
--   </pre>
--   
--   where <tt>A</tt> is symmetric. The matrix <tt>A</tt> must be in an
--   unpacked format, although the routine will only access half of it as
--   specified by the <tt><a>Uplo</a></tt> argument.
symm :: Order -> Side -> Uplo -> Int -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> Double -> Ptr Double -> Int -> IO ()

-- | Perform a Hermitian matrix-matrix update.
--   
--   <pre>
--   C ← α A B + β C    or    C ← α B A + β C
--   </pre>
--   
--   where <tt>A</tt> is Hermitian. The matrix <tt>A</tt> must be in an
--   unpacked format, although the routine will only access half of it as
--   specified by the <tt><a>Uplo</a></tt> argument.
hemm :: Order -> Side -> Uplo -> Int -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> Double -> Ptr Double -> Int -> IO ()

-- | Perform a symmetric rank-k update.
--   
--   <pre>
--   C ← α A A⊤ + β C    or    C ← α A⊤ A + β C
--   </pre>
syrk :: Order -> Uplo -> Transpose -> Int -> Int -> Double -> Ptr Double -> Int -> Double -> Ptr Double -> Int -> IO ()

-- | Perform a Hermitian rank-k update.
--   
--   <pre>
--   C ← α A A† + β C    or    C ← α A† A + β C
--   </pre>
herk :: Order -> Uplo -> Transpose -> Int -> Int -> Double -> Ptr Double -> Int -> Double -> Ptr Double -> Int -> IO ()

-- | Perform a symmetric rank-2k update.
--   
--   <pre>
--   C ← α A B⊤ + α* B A⊤ + β C    or    C ← α A⊤ B + α* B⊤ A + β C
--   </pre>
syr2k :: Order -> Uplo -> Transpose -> Int -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> Double -> Ptr Double -> Int -> IO ()

-- | Perform a Hermitian rank-2k update.
--   
--   <pre>
--   C ← α A B† + α* B A† + β C    or    C ← α A† B + α* B† A + β C
--   </pre>
her2k :: Order -> Uplo -> Transpose -> Int -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> Double -> Ptr Double -> Int -> IO ()

-- | Perform a triangular matrix-matrix multiplication.
--   
--   <pre>
--   B ← α T(A) B    or    B ← α B T(A)
--   </pre>
--   
--   where <tt>A</tt> is triangular.
trmm :: Order -> Side -> Uplo -> Transpose -> Diag -> Int -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> IO ()

-- | Perform an inverse triangular matrix-matrix multiplication.
--   
--   <pre>
--   B ← α T(A⁻¹) B    or    B ← α B T(A⁻¹)
--   </pre>
--   
--   where <tt>A</tt> is triangular.
trsm :: Order -> Side -> Uplo -> Transpose -> Diag -> Int -> Int -> Double -> Ptr Double -> Int -> Ptr Double -> Int -> IO ()


-- | Generic interface to Blas using unsafe foreign calls. Refer to the GHC
--   documentation for more information regarding appropriate use of safe
--   and unsafe foreign calls.
--   
--   The functions here are named in a similar fashion to the original Blas
--   interface, with the type-dependent letter(s) removed. Some functions
--   have been merged with others to allow the interface to work on both
--   real and complex numbers. If you can't a particular function, try
--   looking for its corresponding complex equivalent (e.g. <tt>symv</tt>
--   is a special case of <a>hemv</a> applied to real numbers).
--   
--   Note: although complex versions of <tt>rot</tt> and <tt>rotg</tt>
--   exist in many implementations, they are not part of the official Blas
--   standard and therefore not included here. If you <i>really</i> need
--   them, submit a ticket so we can try to come up with a solution.
--   
--   The documentation here is still incomplete. Consult the <a>official
--   documentation</a> for more information.
--   
--   Notation:
--   
--   <ul>
--   <li><tt>⋅</tt> denotes dot product (without any conjugation).</li>
--   <li><tt>*</tt> denotes complex conjugation.</li>
--   <li><tt>⊤</tt> denotes transpose.</li>
--   <li><tt>†</tt> denotes conjugate transpose (Hermitian conjugate).</li>
--   </ul>
--   
--   Conventions:
--   
--   <ul>
--   <li>All scalars are denoted with lowercase Greek letters</li>
--   <li>All vectors are denoted with lowercase Latin letters and are
--   assumed to be column vectors (unless transposed).</li>
--   <li>All matrices are denoted with uppercase Latin letters.</li>
--   </ul>
--   
--   <i>Since: 0.1.1</i>
module Blas.Specialized.ComplexFloat.Unsafe

-- | Swap two vectors:
--   
--   <pre>
--   (x, y) ← (y, x)
--   </pre>
swap :: Int -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> IO ()

-- | Multiply a vector by a scalar.
--   
--   <pre>
--   x ← α x
--   </pre>
scal :: Int -> Complex Float -> Ptr (Complex Float) -> Int -> IO ()

-- | Copy a vector into another vector:
--   
--   <pre>
--   y ← x
--   </pre>
copy :: Int -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> IO ()

-- | Add a scalar-vector product to a vector.
--   
--   <pre>
--   y ← α x + y
--   </pre>
axpy :: Int -> Complex Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> IO ()

-- | Calculate the bilinear dot product of two vectors:
--   
--   <pre>
--   x ⋅ y ≡ ∑[i] x[i] y[i]
--   </pre>
dotu :: Int -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> IO (Complex Float)

-- | Calculate the sesquilinear dot product of two vectors.
--   
--   <pre>
--   x* ⋅ y ≡ ∑[i] x[i]* y[i]
--   </pre>
dotc :: Int -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> IO (Complex Float)

-- | Calculate the Euclidean (L²) norm of a vector:
--   
--   <pre>
--   ‖x‖₂ ≡ √(∑[i] x[i]²)
--   </pre>
nrm2 :: Int -> Ptr (Complex Float) -> Int -> IO Float

-- | Calculate the Manhattan (L¹) norm, equal to the sum of the magnitudes
--   of the elements:
--   
--   <pre>
--   ‖x‖₁ = ∑[i] |x[i]|
--   </pre>
asum :: Int -> Ptr (Complex Float) -> Int -> IO Float

-- | Calculate the index of the element with the maximum magnitude
--   (absolute value).
iamax :: Int -> Ptr (Complex Float) -> Int -> IO Int

-- | Perform a general matrix-vector update.
--   
--   <pre>
--   y ← α T(A) x + β y
--   </pre>
gemv :: Order -> Transpose -> Int -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform a general banded matrix-vector update.
--   
--   <pre>
--   y ← α T(A) x + β y
--   </pre>
gbmv :: Order -> Transpose -> Int -> Int -> Int -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform a hermitian matrix-vector update.
--   
--   <pre>
--   y ← α A x + β y
--   </pre>
hemv :: Order -> Uplo -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform a hermitian banded matrix-vector update.
--   
--   <pre>
--   y ← α A x + β y
--   </pre>
hbmv :: Order -> Uplo -> Int -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform a hermitian packed matrix-vector update.
--   
--   <pre>
--   y ← α A x + β y
--   </pre>
hpmv :: Order -> Uplo -> Int -> Complex Float -> Ptr (Complex Float) -> Ptr (Complex Float) -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> IO ()

-- | Multiply a triangular matrix by a vector.
--   
--   <pre>
--   x ← T(A) x
--   </pre>
trmv :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> IO ()

-- | Multiply a triangular banded matrix by a vector.
--   
--   <pre>
--   x ← T(A) x
--   </pre>
tbmv :: Order -> Uplo -> Transpose -> Diag -> Int -> Int -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> IO ()

-- | Multiply a triangular packed matrix by a vector.
--   
--   <pre>
--   x ← T(A) x
--   </pre>
tpmv :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr (Complex Float) -> Ptr (Complex Float) -> Int -> IO ()

-- | Multiply an inverse triangular matrix by a vector.
--   
--   <pre>
--   x ← T(A⁻¹) x
--   </pre>
trsv :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> IO ()

-- | Multiply an inverse triangular banded matrix by a vector.
--   
--   <pre>
--   x ← T(A⁻¹) x
--   </pre>
tbsv :: Order -> Uplo -> Transpose -> Diag -> Int -> Int -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> IO ()

-- | Multiply an inverse triangular packed matrix by a vector.
--   
--   <pre>
--   x ← T(A⁻¹) x
--   </pre>
tpsv :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr (Complex Float) -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform an unconjugated rank-1 update of a general matrix.
--   
--   <pre>
--   A ← α x y⊤ + A
--   </pre>
geru :: Order -> Int -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform a conjugated rank-1 update of a general matrix.
--   
--   <pre>
--   A ← α x y† + A
--   </pre>
gerc :: Order -> Int -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform a rank-1 update of a Hermitian matrix.
--   
--   <pre>
--   A ← α x y† + A
--   </pre>
her :: Order -> Uplo -> Int -> Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform a rank-1 update of a Hermitian packed matrix.
--   
--   <pre>
--   A ← α x y† + A
--   </pre>
hpr :: Order -> Uplo -> Int -> Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> IO ()

-- | Perform a rank-2 update of a Hermitian matrix.
--   
--   <pre>
--   A ← α x y† + y (α x)† + A
--   </pre>
her2 :: Order -> Uplo -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform a rank-2 update of a Hermitian packed matrix.
--   
--   <pre>
--   A ← α x y† + y (α x)† + A
--   </pre>
hpr2 :: Order -> Uplo -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> IO ()

-- | Perform a general matrix-matrix update.
--   
--   <pre>
--   C ← α T(A) U(B) + β C
--   </pre>
gemm :: Order -> Transpose -> Transpose -> Int -> Int -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform a symmetric matrix-matrix update.
--   
--   <pre>
--   C ← α A B + β C    or    C ← α B A + β C
--   </pre>
--   
--   where <tt>A</tt> is symmetric. The matrix <tt>A</tt> must be in an
--   unpacked format, although the routine will only access half of it as
--   specified by the <tt><a>Uplo</a></tt> argument.
symm :: Order -> Side -> Uplo -> Int -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform a Hermitian matrix-matrix update.
--   
--   <pre>
--   C ← α A B + β C    or    C ← α B A + β C
--   </pre>
--   
--   where <tt>A</tt> is Hermitian. The matrix <tt>A</tt> must be in an
--   unpacked format, although the routine will only access half of it as
--   specified by the <tt><a>Uplo</a></tt> argument.
hemm :: Order -> Side -> Uplo -> Int -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform a symmetric rank-k update.
--   
--   <pre>
--   C ← α A A⊤ + β C    or    C ← α A⊤ A + β C
--   </pre>
syrk :: Order -> Uplo -> Transpose -> Int -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform a Hermitian rank-k update.
--   
--   <pre>
--   C ← α A A† + β C    or    C ← α A† A + β C
--   </pre>
herk :: Order -> Uplo -> Transpose -> Int -> Int -> Float -> Ptr (Complex Float) -> Int -> Float -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform a symmetric rank-2k update.
--   
--   <pre>
--   C ← α A B⊤ + α* B A⊤ + β C    or    C ← α A⊤ B + α* B⊤ A + β C
--   </pre>
syr2k :: Order -> Uplo -> Transpose -> Int -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform a Hermitian rank-2k update.
--   
--   <pre>
--   C ← α A B† + α* B A† + β C    or    C ← α A† B + α* B† A + β C
--   </pre>
her2k :: Order -> Uplo -> Transpose -> Int -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> Float -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform a triangular matrix-matrix multiplication.
--   
--   <pre>
--   B ← α T(A) B    or    B ← α B T(A)
--   </pre>
--   
--   where <tt>A</tt> is triangular.
trmm :: Order -> Side -> Uplo -> Transpose -> Diag -> Int -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> IO ()

-- | Perform an inverse triangular matrix-matrix multiplication.
--   
--   <pre>
--   B ← α T(A⁻¹) B    or    B ← α B T(A⁻¹)
--   </pre>
--   
--   where <tt>A</tt> is triangular.
trsm :: Order -> Side -> Uplo -> Transpose -> Diag -> Int -> Int -> Complex Float -> Ptr (Complex Float) -> Int -> Ptr (Complex Float) -> Int -> IO ()


-- | Generic interface to Blas using unsafe foreign calls. Refer to the GHC
--   documentation for more information regarding appropriate use of safe
--   and unsafe foreign calls.
--   
--   The functions here are named in a similar fashion to the original Blas
--   interface, with the type-dependent letter(s) removed. Some functions
--   have been merged with others to allow the interface to work on both
--   real and complex numbers. If you can't a particular function, try
--   looking for its corresponding complex equivalent (e.g. <tt>symv</tt>
--   is a special case of <a>hemv</a> applied to real numbers).
--   
--   Note: although complex versions of <tt>rot</tt> and <tt>rotg</tt>
--   exist in many implementations, they are not part of the official Blas
--   standard and therefore not included here. If you <i>really</i> need
--   them, submit a ticket so we can try to come up with a solution.
--   
--   The documentation here is still incomplete. Consult the <a>official
--   documentation</a> for more information.
--   
--   Notation:
--   
--   <ul>
--   <li><tt>⋅</tt> denotes dot product (without any conjugation).</li>
--   <li><tt>*</tt> denotes complex conjugation.</li>
--   <li><tt>⊤</tt> denotes transpose.</li>
--   <li><tt>†</tt> denotes conjugate transpose (Hermitian conjugate).</li>
--   </ul>
--   
--   Conventions:
--   
--   <ul>
--   <li>All scalars are denoted with lowercase Greek letters</li>
--   <li>All vectors are denoted with lowercase Latin letters and are
--   assumed to be column vectors (unless transposed).</li>
--   <li>All matrices are denoted with uppercase Latin letters.</li>
--   </ul>
--   
--   <i>Since: 0.1.1</i>
module Blas.Specialized.ComplexDouble.Unsafe

-- | Swap two vectors:
--   
--   <pre>
--   (x, y) ← (y, x)
--   </pre>
swap :: Int -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> IO ()

-- | Multiply a vector by a scalar.
--   
--   <pre>
--   x ← α x
--   </pre>
scal :: Int -> Complex Double -> Ptr (Complex Double) -> Int -> IO ()

-- | Copy a vector into another vector:
--   
--   <pre>
--   y ← x
--   </pre>
copy :: Int -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> IO ()

-- | Add a scalar-vector product to a vector.
--   
--   <pre>
--   y ← α x + y
--   </pre>
axpy :: Int -> Complex Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> IO ()

-- | Calculate the bilinear dot product of two vectors:
--   
--   <pre>
--   x ⋅ y ≡ ∑[i] x[i] y[i]
--   </pre>
dotu :: Int -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> IO (Complex Double)

-- | Calculate the sesquilinear dot product of two vectors.
--   
--   <pre>
--   x* ⋅ y ≡ ∑[i] x[i]* y[i]
--   </pre>
dotc :: Int -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> IO (Complex Double)

-- | Calculate the Euclidean (L²) norm of a vector:
--   
--   <pre>
--   ‖x‖₂ ≡ √(∑[i] x[i]²)
--   </pre>
nrm2 :: Int -> Ptr (Complex Double) -> Int -> IO Double

-- | Calculate the Manhattan (L¹) norm, equal to the sum of the magnitudes
--   of the elements:
--   
--   <pre>
--   ‖x‖₁ = ∑[i] |x[i]|
--   </pre>
asum :: Int -> Ptr (Complex Double) -> Int -> IO Double

-- | Calculate the index of the element with the maximum magnitude
--   (absolute value).
iamax :: Int -> Ptr (Complex Double) -> Int -> IO Int

-- | Perform a general matrix-vector update.
--   
--   <pre>
--   y ← α T(A) x + β y
--   </pre>
gemv :: Order -> Transpose -> Int -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform a general banded matrix-vector update.
--   
--   <pre>
--   y ← α T(A) x + β y
--   </pre>
gbmv :: Order -> Transpose -> Int -> Int -> Int -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform a hermitian matrix-vector update.
--   
--   <pre>
--   y ← α A x + β y
--   </pre>
hemv :: Order -> Uplo -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform a hermitian banded matrix-vector update.
--   
--   <pre>
--   y ← α A x + β y
--   </pre>
hbmv :: Order -> Uplo -> Int -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform a hermitian packed matrix-vector update.
--   
--   <pre>
--   y ← α A x + β y
--   </pre>
hpmv :: Order -> Uplo -> Int -> Complex Double -> Ptr (Complex Double) -> Ptr (Complex Double) -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> IO ()

-- | Multiply a triangular matrix by a vector.
--   
--   <pre>
--   x ← T(A) x
--   </pre>
trmv :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> IO ()

-- | Multiply a triangular banded matrix by a vector.
--   
--   <pre>
--   x ← T(A) x
--   </pre>
tbmv :: Order -> Uplo -> Transpose -> Diag -> Int -> Int -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> IO ()

-- | Multiply a triangular packed matrix by a vector.
--   
--   <pre>
--   x ← T(A) x
--   </pre>
tpmv :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr (Complex Double) -> Ptr (Complex Double) -> Int -> IO ()

-- | Multiply an inverse triangular matrix by a vector.
--   
--   <pre>
--   x ← T(A⁻¹) x
--   </pre>
trsv :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> IO ()

-- | Multiply an inverse triangular banded matrix by a vector.
--   
--   <pre>
--   x ← T(A⁻¹) x
--   </pre>
tbsv :: Order -> Uplo -> Transpose -> Diag -> Int -> Int -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> IO ()

-- | Multiply an inverse triangular packed matrix by a vector.
--   
--   <pre>
--   x ← T(A⁻¹) x
--   </pre>
tpsv :: Order -> Uplo -> Transpose -> Diag -> Int -> Ptr (Complex Double) -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform an unconjugated rank-1 update of a general matrix.
--   
--   <pre>
--   A ← α x y⊤ + A
--   </pre>
geru :: Order -> Int -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform a conjugated rank-1 update of a general matrix.
--   
--   <pre>
--   A ← α x y† + A
--   </pre>
gerc :: Order -> Int -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform a rank-1 update of a Hermitian matrix.
--   
--   <pre>
--   A ← α x y† + A
--   </pre>
her :: Order -> Uplo -> Int -> Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform a rank-1 update of a Hermitian packed matrix.
--   
--   <pre>
--   A ← α x y† + A
--   </pre>
hpr :: Order -> Uplo -> Int -> Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> IO ()

-- | Perform a rank-2 update of a Hermitian matrix.
--   
--   <pre>
--   A ← α x y† + y (α x)† + A
--   </pre>
her2 :: Order -> Uplo -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform a rank-2 update of a Hermitian packed matrix.
--   
--   <pre>
--   A ← α x y† + y (α x)† + A
--   </pre>
hpr2 :: Order -> Uplo -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> IO ()

-- | Perform a general matrix-matrix update.
--   
--   <pre>
--   C ← α T(A) U(B) + β C
--   </pre>
gemm :: Order -> Transpose -> Transpose -> Int -> Int -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform a symmetric matrix-matrix update.
--   
--   <pre>
--   C ← α A B + β C    or    C ← α B A + β C
--   </pre>
--   
--   where <tt>A</tt> is symmetric. The matrix <tt>A</tt> must be in an
--   unpacked format, although the routine will only access half of it as
--   specified by the <tt><a>Uplo</a></tt> argument.
symm :: Order -> Side -> Uplo -> Int -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform a Hermitian matrix-matrix update.
--   
--   <pre>
--   C ← α A B + β C    or    C ← α B A + β C
--   </pre>
--   
--   where <tt>A</tt> is Hermitian. The matrix <tt>A</tt> must be in an
--   unpacked format, although the routine will only access half of it as
--   specified by the <tt><a>Uplo</a></tt> argument.
hemm :: Order -> Side -> Uplo -> Int -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform a symmetric rank-k update.
--   
--   <pre>
--   C ← α A A⊤ + β C    or    C ← α A⊤ A + β C
--   </pre>
syrk :: Order -> Uplo -> Transpose -> Int -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform a Hermitian rank-k update.
--   
--   <pre>
--   C ← α A A† + β C    or    C ← α A† A + β C
--   </pre>
herk :: Order -> Uplo -> Transpose -> Int -> Int -> Double -> Ptr (Complex Double) -> Int -> Double -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform a symmetric rank-2k update.
--   
--   <pre>
--   C ← α A B⊤ + α* B A⊤ + β C    or    C ← α A⊤ B + α* B⊤ A + β C
--   </pre>
syr2k :: Order -> Uplo -> Transpose -> Int -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform a Hermitian rank-2k update.
--   
--   <pre>
--   C ← α A B† + α* B A† + β C    or    C ← α A† B + α* B† A + β C
--   </pre>
her2k :: Order -> Uplo -> Transpose -> Int -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> Double -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform a triangular matrix-matrix multiplication.
--   
--   <pre>
--   B ← α T(A) B    or    B ← α B T(A)
--   </pre>
--   
--   where <tt>A</tt> is triangular.
trmm :: Order -> Side -> Uplo -> Transpose -> Diag -> Int -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> IO ()

-- | Perform an inverse triangular matrix-matrix multiplication.
--   
--   <pre>
--   B ← α T(A⁻¹) B    or    B ← α B T(A⁻¹)
--   </pre>
--   
--   where <tt>A</tt> is triangular.
trsm :: Order -> Side -> Uplo -> Transpose -> Diag -> Int -> Int -> Complex Double -> Ptr (Complex Double) -> Int -> Ptr (Complex Double) -> Int -> IO ()


-- | Generic interface to Blas using unsafe foreign calls. Refer to the GHC
--   documentation for more information regarding appropriate use of safe
--   and unsafe foreign calls.
--   
--   The functions here are named in a similar fashion to the original Blas
--   interface, with the type-dependent letter(s) removed. Some functions
--   have been merged with others to allow the interface to work on both
--   real and complex numbers. If you can't a particular function, try
--   looking for its corresponding complex equivalent (e.g. <tt>symv</tt>
--   is a special case of <a>hemv</a> applied to real numbers).
--   
--   Note: although complex versions of <a>rot</a> and <a>rotg</a> exist in
--   many implementations, they are not part of the official Blas standard
--   and therefore not included here. If you <i>really</i> need them,
--   submit a ticket so we can try to come up with a solution.
--   
--   The documentation here is still incomplete. Consult the <a>official
--   documentation</a> for more information.
--   
--   Notation:
--   
--   <ul>
--   <li><tt>⋅</tt> denotes dot product (without any conjugation).</li>
--   <li><tt>*</tt> denotes complex conjugation.</li>
--   <li><tt>⊤</tt> denotes transpose.</li>
--   <li><tt>†</tt> denotes conjugate transpose (Hermitian conjugate).</li>
--   </ul>
--   
--   Conventions:
--   
--   <ul>
--   <li>All scalars are denoted with lowercase Greek letters</li>
--   <li>All vectors are denoted with lowercase Latin letters and are
--   assumed to be column vectors (unless transposed).</li>
--   <li>All matrices are denoted with uppercase Latin letters.</li>
--   </ul>
module Blas.Generic.Unsafe

-- | Blas operations that are applicable to real and complex numbers.
--   
--   Instances are defined for the 4 types supported by Blas: the single-
--   and double-precision floating point types and their complex versions.
class (Floating a, Storable a) => Numeric a where type family RealType a :: *
swap :: Numeric a => Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
scal :: Numeric a => Int -> a -> Ptr a -> Int -> IO ()
copy :: Numeric a => Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
axpy :: Numeric a => Int -> a -> Ptr a -> Int -> Ptr a -> Int -> IO ()
dotu :: Numeric a => Int -> Ptr a -> Int -> Ptr a -> Int -> IO a
dotc :: Numeric a => Int -> Ptr a -> Int -> Ptr a -> Int -> IO a
nrm2 :: Numeric a => Int -> Ptr a -> Int -> IO (RealType a)
asum :: Numeric a => Int -> Ptr a -> Int -> IO (RealType a)
iamax :: Numeric a => Int -> Ptr a -> Int -> IO Int
gemv :: Numeric a => Order -> Transpose -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
gbmv :: Numeric a => Order -> Transpose -> Int -> Int -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
hemv :: Numeric a => Order -> Uplo -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
hbmv :: Numeric a => Order -> Uplo -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
hpmv :: Numeric a => Order -> Uplo -> Int -> a -> Ptr a -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
trmv :: Numeric a => Order -> Uplo -> Transpose -> Diag -> Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
tbmv :: Numeric a => Order -> Uplo -> Transpose -> Diag -> Int -> Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
tpmv :: Numeric a => Order -> Uplo -> Transpose -> Diag -> Int -> Ptr a -> Ptr a -> Int -> IO ()
trsv :: Numeric a => Order -> Uplo -> Transpose -> Diag -> Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
tbsv :: Numeric a => Order -> Uplo -> Transpose -> Diag -> Int -> Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
tpsv :: Numeric a => Order -> Uplo -> Transpose -> Diag -> Int -> Ptr a -> Ptr a -> Int -> IO ()
geru :: Numeric a => Order -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
gerc :: Numeric a => Order -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
her :: Numeric a => Order -> Uplo -> Int -> RealType a -> Ptr a -> Int -> Ptr a -> Int -> IO ()
hpr :: Numeric a => Order -> Uplo -> Int -> RealType a -> Ptr a -> Int -> Ptr a -> IO ()
her2 :: Numeric a => Order -> Uplo -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> Ptr a -> Int -> IO ()
hpr2 :: Numeric a => Order -> Uplo -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> Ptr a -> IO ()
gemm :: Numeric a => Order -> Transpose -> Transpose -> Int -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
symm :: Numeric a => Order -> Side -> Uplo -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
hemm :: Numeric a => Order -> Side -> Uplo -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
syrk :: Numeric a => Order -> Uplo -> Transpose -> Int -> Int -> a -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
herk :: Numeric a => Order -> Uplo -> Transpose -> Int -> Int -> RealType a -> Ptr a -> Int -> RealType a -> Ptr a -> Int -> IO ()
syr2k :: Numeric a => Order -> Uplo -> Transpose -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> a -> Ptr a -> Int -> IO ()
her2k :: Numeric a => Order -> Uplo -> Transpose -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> RealType a -> Ptr a -> Int -> IO ()
trmm :: Numeric a => Order -> Side -> Uplo -> Transpose -> Diag -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> IO ()
trsm :: Numeric a => Order -> Side -> Uplo -> Transpose -> Diag -> Int -> Int -> a -> Ptr a -> Int -> Ptr a -> Int -> IO ()

-- | Blas operations that are only applicable to real numbers.
class Numeric a => RealNumeric a
rotg :: RealNumeric a => Ptr a -> Ptr a -> Ptr a -> Ptr a -> IO ()
rotmg :: RealNumeric a => Ptr a -> Ptr a -> Ptr a -> a -> Ptr a -> IO ()
rot :: RealNumeric a => Int -> Ptr a -> Int -> Ptr a -> Int -> a -> a -> IO ()
rotm :: RealNumeric a => Int -> Ptr a -> Int -> Ptr a -> Int -> Ptr a -> IO ()

-- | Calculate the dot product of two vectors with extended precision
--   accumulation of the intermediate results and return a double-precision
--   result. (Only available in the <tt>Double</tt> module.)
dsdot :: Int -> Ptr Float -> Int -> Ptr Float -> Int -> IO Double

-- | Calculate the dot product of two vectors with extended precision
--   accumulation of the intermediate results and add a scalar value to the
--   result. (Only available for the <tt><a>Float</a></tt> type.)
sdsdot :: Int -> Float -> Ptr Float -> Int -> Ptr Float -> Int -> IO Float
instance RealNumeric Double
instance RealNumeric Float
instance Numeric (Complex Double)
instance Numeric (Complex Float)
instance Numeric Double
instance Numeric Float
