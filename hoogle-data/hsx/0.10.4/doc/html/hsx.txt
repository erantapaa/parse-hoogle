-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | HSX (Haskell Source with XML) allows literal XML syntax in Haskell source code.
--   
--   HSX (Haskell Source with XML) allows literal XML syntax in Haskell
--   source code. The trhsx preprocessor translates .hsx source files into
--   ordinary .hs files. Literal XML syntax is translated into function
--   calls for creating XML values of the appropriate forms. trhsx
--   transforms literal XML syntax into a series of function calls. Any
--   project can make use of the syntax by providing definitions for those
--   functions, and the XML values produced will be of the types specified.
--   This works for any types, since trhsx doesn't make any assumptions, or
--   inserts any information depending on types. XMLGenerator defines a few
--   typeclasses that together cover the functions injected by the
--   preprocessor. A project that uses these classes to provide the
--   semantics for the injected syntax will be able to use any functions
--   written in terms of these, allowing better code reusability than if
--   each project defines its own semantics for the XML syntax. Also, the
--   classes makes it possible to use the literal syntax at different types
--   within the same module. Achieving that is not as simple as it may
--   seem, but the XMLGenerator module provides all the necessary
--   machinery.
@package hsx
@version 0.10.4


-- | Functions for transforming abstract Haskell code extended with regular
--   patterns into semantically equivalent normal abstract Haskell code. In
--   other words, we transform away regular patterns.
module HSX.Transform

-- | Transform away occurences of regular patterns from an abstract Haskell
--   module, preserving semantics.
transform :: Module -> Module

-- | Transform expressions by traversing subterms. Of special interest are
--   expressions that contain patterns as subterms, i.e. <tt>let</tt>,
--   <tt>case</tt> and lambda expressions, and also list comprehensions and
--   <tt>do</tt>-expressions. All other expressions simply transform their
--   sub-expressions, if any. Of special interest are of course also any
--   xml expressions.
transformExp :: Exp -> Exp
instance [overlap ok] Functor Tr
instance [overlap ok] Monad Tr
instance [overlap ok] Functor RN
instance [overlap ok] Monad RN
instance [overlap ok] Functor HsxM
instance [overlap ok] Monad HsxM


-- | The class and monad transformer that forms the basis of the literal
--   XML syntax translation. Literal tags will be translated into functions
--   of the GenerateXML class, and any instantiating monads with associated
--   XML types can benefit from that syntax.
module HSX.XMLGenerator

-- | The monad transformer that allows a monad to generate XML values.
newtype XMLGenT m a
XMLGenT :: (m a) -> XMLGenT m a

-- | un-lift.
unXMLGenT :: XMLGenT m a -> m a

-- | map the inner monad
mapXMLGenT :: (m a -> n b) -> XMLGenT m a -> XMLGenT n b
type Name = (Maybe String, String)

-- | Generate XML values in some XMLGenerator monad.
class Monad m => XMLGen m where type family XMLType m data family ChildType m data family AttributeType m genEElement n ats = genElement n ats []
genElement :: XMLGen m => Name -> [XMLGenT m [AttributeType m]] -> [XMLGenT m [ChildType m]] -> XMLGenT m (XMLType m)
genEElement :: XMLGen m => Name -> [XMLGenT m [AttributeType m]] -> XMLGenT m (XMLType m)
xmlToChild :: XMLGen m => XMLType m -> ChildType m
pcdataToChild :: XMLGen m => String -> ChildType m

-- | Type synonyms to avoid writing out the XMLnGenT all the time
type GenXML m = XMLGenT m (XMLType m)
type GenXMLList m = XMLGenT m [XMLType m]
type GenChild m = XMLGenT m (ChildType m)
type GenChildList m = XMLGenT m [ChildType m]
type GenAttribute m = XMLGenT m (AttributeType m)
type GenAttributeList m = XMLGenT m [AttributeType m]

-- | Embed values as child nodes of an XML element. The parent type will be
--   clear from the context so it is not mentioned.
class XMLGen m => EmbedAsChild m c
asChild :: EmbedAsChild m c => c -> GenChildList m

-- | Similarly embed values as attributes of an XML element.
class XMLGen m => EmbedAsAttr m a
asAttr :: EmbedAsAttr m a => a -> GenAttributeList m
class (XMLGen m, SetAttr m (XMLType m), AppendChild m (XMLType m), EmbedAsChild m (XMLType m), EmbedAsChild m [XMLType m], EmbedAsChild m String, EmbedAsChild m Char, EmbedAsChild m (), EmbedAsAttr m (Attr String String), EmbedAsAttr m (Attr String Int), EmbedAsAttr m (Attr String Bool)) => XMLGenerator m
data Attr n a
(:=) :: n -> a -> Attr n a

-- | Set attributes on XML elements
class XMLGen m => SetAttr m elem where setAttr e a = setAll e $ liftM return a
setAttr :: SetAttr m elem => elem -> GenAttribute m -> GenXML m
setAll :: SetAttr m elem => elem -> GenAttributeList m -> GenXML m
(<@, set) :: (SetAttr m elem, EmbedAsAttr m attr) => elem -> attr -> GenXML m
(<<@) :: (SetAttr m elem, EmbedAsAttr m a) => elem -> [a] -> GenXML m
class XMLGen m => AppendChild m elem where appChild e c = appAll e $ liftM return c
appChild :: AppendChild m elem => elem -> GenChild m -> GenXML m
appAll :: AppendChild m elem => elem -> GenChildList m -> GenXML m
(<:, app) :: (AppendChild m elem, EmbedAsChild m c) => elem -> c -> GenXML m
(<<:) :: (AppendChild m elem, EmbedAsChild m c) => elem -> [c] -> GenXML m

-- | Names can be simple or qualified with a domain. We want to
--   conveniently use both simple strings or pairs wherever a Name is
--   expected.
class Show n => IsName n
toName :: IsName n => n -> Name
class TypeCast a b | a -> b, b -> a
typeCast :: TypeCast a b => a -> b
class TypeCast' t a b | t a -> b, t b -> a
typeCast' :: TypeCast' t a b => t -> a -> b
class TypeCast'' t a b | t a -> b, t b -> a
typeCast'' :: TypeCast'' t a b => t -> a -> b
class TypeCastM ma mb | ma -> mb, mb -> ma
typeCastM :: TypeCastM ma mb => ma x -> mb x
class TypeCastM' t ma mb | t ma -> mb, t mb -> ma
typeCastM' :: TypeCastM' t ma mb => t -> ma x -> mb x
class TypeCastM'' t ma mb | t ma -> mb, t mb -> ma
typeCastM'' :: TypeCastM'' t ma mb => t -> ma x -> mb x
instance [overlap ok] Applicative m => Applicative (XMLGenT m)
instance [overlap ok] Alternative m => Alternative (XMLGenT m)
instance [overlap ok] Monad m => Monad (XMLGenT m)
instance [overlap ok] Functor m => Functor (XMLGenT m)
instance [overlap ok] MonadIO m => MonadIO (XMLGenT m)
instance [overlap ok] MonadPlus m => MonadPlus (XMLGenT m)
instance [overlap ok] MonadWriter w m => MonadWriter w (XMLGenT m)
instance [overlap ok] MonadReader r m => MonadReader r (XMLGenT m)
instance [overlap ok] MonadState s m => MonadState s (XMLGenT m)
instance [overlap ok] MonadRWS r w s m => MonadRWS r w s (XMLGenT m)
instance [overlap ok] MonadCont m => MonadCont (XMLGenT m)
instance [overlap ok] MonadError e m => MonadError e (XMLGenT m)
instance [overlap ok] (Show n, Show a) => Show (Attr n a)
instance [overlap ok] TypeCastM'' () ma ma
instance [overlap ok] TypeCastM'' t ma mb => TypeCastM' t ma mb
instance [overlap ok] TypeCastM' () ma mb => TypeCastM ma mb
instance [overlap ok] TypeCast'' () a a
instance [overlap ok] TypeCast'' t a b => TypeCast' t a b
instance [overlap ok] TypeCast' () a b => TypeCast a b
instance [overlap ok] IsName (String, String)
instance [overlap ok] IsName String
instance [overlap ok] IsName Name
instance [overlap ok] (AppendChild m x, TypeCastM m1 m) => AppendChild m (XMLGenT m1 x)
instance [overlap ok] (TypeCastM m1 m, SetAttr m x) => SetAttr m (XMLGenT m1 x)
instance [overlap ok] EmbedAsAttr m a => EmbedAsAttr m [a]
instance [overlap ok] XMLGen m => EmbedAsAttr m (AttributeType m)
instance [overlap ok] (EmbedAsAttr m (Attr a v), TypeCastM m1 m) => EmbedAsAttr m (Attr a (XMLGenT m1 v))
instance [overlap ok] (XMLGen m, EmbedAsAttr m a) => EmbedAsAttr m (XMLGenT m a)
instance [overlap ok] XMLGen m => EmbedAsChild m ()
instance [overlap ok] XMLGen m => EmbedAsChild m String
instance [overlap ok] (XMLGen m, XMLType m ~ x) => EmbedAsChild m x
instance [overlap ok] XMLGen m => EmbedAsChild m (ChildType m)
instance [overlap ok] EmbedAsChild m c => EmbedAsChild m [c]
instance [overlap ok] (EmbedAsChild m c, m ~ n) => EmbedAsChild m (XMLGenT n c)
instance [overlap ok] MonadTrans XMLGenT
