-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A package for parsing shell scripts
--   
--   Language.Sh is a collection of modules for parsing and manipulating
--   expressions in shell grammar. This is part of a larger project, shsh.
--   Please note that the API is somewhat unstable until we reach version
--   1.0.
@package language-sh
@version 0.0.3.1


-- | Here we define the <i>complete</i> abstract syntax tree for simple and
--   compound statements.
module Language.Sh.Syntax
data Command
Synchronous :: AndOrList -> Command
Asynchronous :: AndOrList -> Command
data AndOrList
Singleton :: Pipeline -> AndOrList
(:&&:) :: AndOrList -> Pipeline -> AndOrList
(:||:) :: AndOrList -> Pipeline -> AndOrList
data Pipeline
Pipeline :: [Statement] -> Pipeline
BangPipeline :: [Statement] -> Pipeline
data Term
TWord :: Word -> Term
TRedir :: Redir -> Term
TAssignment :: Assignment -> Term
data Statement
Statement :: [Word] -> [Redir] -> [Assignment] -> Statement
Compound :: CompoundStatement -> [Redir] -> Statement
FunctionDefinition :: String -> CompoundStatement -> [Redir] -> Statement
OrderedStatement :: [Term] -> Statement
data CompoundStatement
For :: String -> [Word] -> [Command] -> CompoundStatement
While :: [Command] -> [Command] -> CompoundStatement
Until :: [Command] -> [Command] -> CompoundStatement
If :: [Command] -> [Command] -> [Command] -> CompoundStatement
Case :: Word -> [([Word], [Command])] -> CompoundStatement
Subshell :: [Command] -> CompoundStatement
BraceGroup :: [Command] -> CompoundStatement
type Word = [Lexeme]
data Lexeme
Literal :: Char -> Lexeme
Quote :: Char -> Lexeme
Expand :: Expansion -> Lexeme
Quoted :: Lexeme -> Lexeme
SplitField :: Lexeme

-- | An expansion. The first three are all variable expansions. The
--   <a>ModifiedExpansion</a> in particular also keeps track of which
--   operation it is to perform. The <a>Char</a> can be any of
--   <tt><a>-+=?#%</a></tt> and the <a>Bool</a> says whether it was paired
--   with a <tt><tt>:</tt></tt> in the case of the first four or doubled in
--   the case of the latter two. This isn't a very good data structure, but
--   I hesitate to add 12 more algebraic types, one for each type of
--   expansion. It would be elegant to use a function parameter here, but
--   then we lose our data-ness and it makes it difficult to be
--   <tt>Show</tt>. We could use a data class that has functions and is
--   also <tt>Show</tt> and can be pretty-printed, and this would allow
--   arbitrary generalizability, but do we really want this? It needs to be
--   parsed anyway. The other question is the <tt>bash</tt> extensions: do
--   we parse for <tt>/</tt> or should it be an error? Is there a way to
--   prevent it optionally?
data Expansion
SimpleExpansion :: String -> Expansion
ModifiedExpansion :: String -> Char -> Bool -> Word -> Expansion
LengthExpansion :: String -> Expansion
CommandSub :: [Command] -> Expansion
Arithmetic :: Word -> Expansion
data Redir
(:>) :: Int -> Word -> Redir
(:>|) :: Int -> Word -> Redir
(:>&) :: Int -> Int -> Redir
(:>>) :: Int -> Word -> Redir
(:<>) :: Int -> Word -> Redir
(:<) :: Int -> Word -> Redir
(:<&) :: Int -> Int -> Redir
(:<<) :: Int -> String -> Redir
(:<<-) :: Int -> String -> Redir

-- | filled in version...?
Heredoc :: Int -> Bool -> Word -> Redir
data Assignment
(:=) :: String -> Word -> Assignment
instance Show Assignment
instance Show Redir
instance Show Expansion
instance Show Lexeme
instance Show CompoundStatement
instance Show Statement
instance Show Term
instance Show Pipeline
instance Show AndOrList
instance Show Command

module Language.Sh.Map

-- | The idea here is to prevent duplicating code needlessly. We could go
--   even more extreme and make a third parameter, but then we have WAY too
--   many instances, and they all depend on every other one anyway... class
--   Applicative a =&gt; ExpressionMapper a f t where mapSh :: f -&gt; t
--   -&gt; a t
class (Monad m, Functor m) => ExpressionMapperM m f | f -> m
mapCommandsM :: (ExpressionMapperM m f) => f -> [Command] -> m [Command]
defaultMapCommandsM :: (ExpressionMapperM m f) => f -> [Command] -> m [Command]
mapCommandM :: (ExpressionMapperM m f) => f -> Command -> m Command
defaultMapCommandM :: (ExpressionMapperM m f) => f -> Command -> m Command
mapListM :: (ExpressionMapperM m f) => f -> AndOrList -> m AndOrList
defaultMapListM :: (ExpressionMapperM m f) => f -> AndOrList -> m AndOrList
mapPipelineM :: (ExpressionMapperM m f) => f -> Pipeline -> m Pipeline
defaultMapPipelineM :: (ExpressionMapperM m f) => f -> Pipeline -> m Pipeline
mapStatementM :: (ExpressionMapperM m f) => f -> Statement -> m Statement
defaultMapStatementM :: (ExpressionMapperM m f) => f -> Statement -> m Statement
mapCompoundM :: (ExpressionMapperM m f) => f -> CompoundStatement -> m CompoundStatement
defaultMapCompoundM :: (ExpressionMapperM m f) => f -> CompoundStatement -> m CompoundStatement
mapTermsM :: (ExpressionMapperM m f) => f -> Term -> m [Term]
defaultMapTermsM :: (ExpressionMapperM m f) => f -> Term -> m [Term]
mapTermM :: (ExpressionMapperM m f) => f -> Term -> m Term
defaultMapTermM :: (ExpressionMapperM m f) => f -> Term -> m Term
mapWordM :: (ExpressionMapperM m f) => f -> Word -> m Word
defaultMapWordM :: (ExpressionMapperM m f) => f -> Word -> m Word
mapLexemesM :: (ExpressionMapperM m f) => f -> Lexeme -> m [Lexeme]
defaultMapLexemesM :: (ExpressionMapperM m f) => f -> Lexeme -> m [Lexeme]
mapLexemeM :: (ExpressionMapperM m f) => f -> Lexeme -> m Lexeme
defaultMapLexemeM :: (ExpressionMapperM m f) => f -> Lexeme -> m Lexeme
mapExpansionM :: (ExpressionMapperM m f) => f -> Expansion -> m Expansion
defaultMapExpansionM :: (ExpressionMapperM m f) => f -> Expansion -> m Expansion
mapAssignmentM :: (ExpressionMapperM m f) => f -> Assignment -> m Assignment
defaultMapAssignmentM :: (ExpressionMapperM m f) => f -> Assignment -> m Assignment
mapRedirM :: (ExpressionMapperM m f) => f -> Redir -> m Redir
defaultMapRedirM :: (ExpressionMapperM m f) => f -> Redir -> m Redir
class ExpressionMapper f
mapCommands :: (ExpressionMapper f) => f -> [Command] -> [Command]
defaultMapCommands :: (ExpressionMapper f) => f -> [Command] -> [Command]
mapCommand :: (ExpressionMapper f) => f -> Command -> Command
defaultMapCommand :: (ExpressionMapper f) => f -> Command -> Command
mapList :: (ExpressionMapper f) => f -> AndOrList -> AndOrList
defaultMapList :: (ExpressionMapper f) => f -> AndOrList -> AndOrList
mapPipeline :: (ExpressionMapper f) => f -> Pipeline -> Pipeline
defaultMapPipeline :: (ExpressionMapper f) => f -> Pipeline -> Pipeline
mapStatement :: (ExpressionMapper f) => f -> Statement -> Statement
defaultMapStatement :: (ExpressionMapper f) => f -> Statement -> Statement
mapCompound :: (ExpressionMapper f) => f -> CompoundStatement -> CompoundStatement
defaultMapCompound :: (ExpressionMapper f) => f -> CompoundStatement -> CompoundStatement
mapTerms :: (ExpressionMapper f) => f -> Term -> [Term]
defaultMapTerms :: (ExpressionMapper f) => f -> Term -> [Term]
mapTerm :: (ExpressionMapper f) => f -> Term -> Term
defaultMapTerm :: (ExpressionMapper f) => f -> Term -> Term
mapWord :: (ExpressionMapper f) => f -> Word -> Word
defaultMapWord :: (ExpressionMapper f) => f -> Word -> Word
mapLexemes :: (ExpressionMapper f) => f -> Lexeme -> [Lexeme]
defaultMapLexemes :: (ExpressionMapper f) => f -> Lexeme -> [Lexeme]
mapLexeme :: (ExpressionMapper f) => f -> Lexeme -> Lexeme
defaultMapLexeme :: (ExpressionMapper f) => f -> Lexeme -> Lexeme
mapExpansion :: (ExpressionMapper f) => f -> Expansion -> Expansion
defaultMapExpansion :: (ExpressionMapper f) => f -> Expansion -> Expansion
mapAssignment :: (ExpressionMapper f) => f -> Assignment -> Assignment
defaultMapAssignment :: (ExpressionMapper f) => f -> Assignment -> Assignment
mapRedir :: (ExpressionMapper f) => f -> Redir -> Redir
defaultMapRedir :: (ExpressionMapper f) => f -> Redir -> Redir
instance ExpressionMapper (Redir -> Redir)
instance ExpressionMapper (Assignment -> Assignment)
instance ExpressionMapper (Expansion -> Expansion)
instance ExpressionMapper (Lexeme -> [Lexeme])
instance ExpressionMapper (Lexeme -> Lexeme)
instance ExpressionMapper (Word -> Word)
instance ExpressionMapper (CompoundStatement -> CompoundStatement)
instance ExpressionMapper (Statement -> Statement)
instance ExpressionMapper (Pipeline -> Pipeline)
instance ExpressionMapper (AndOrList -> AndOrList)
instance ExpressionMapper (Command -> Command)
instance (Monad m, Functor m) => ExpressionMapperM m (Redir -> m Redir)
instance (Monad m, Functor m) => ExpressionMapperM m (Assignment -> m Assignment)
instance (Monad m, Functor m) => ExpressionMapperM m (Expansion -> m Expansion)
instance (Monad m, Functor m) => ExpressionMapperM m (Lexeme -> m [Lexeme])
instance (Monad m, Functor m) => ExpressionMapperM m (Lexeme -> m Lexeme)
instance (Monad m, Functor m) => ExpressionMapperM m (Word -> m Word)
instance (Monad m, Functor m) => ExpressionMapperM m (CompoundStatement -> m CompoundStatement)
instance (Monad m, Functor m) => ExpressionMapperM m (Statement -> m Statement)
instance (Monad m, Functor m) => ExpressionMapperM m (Pipeline -> m Pipeline)
instance (Monad m, Functor m) => ExpressionMapperM m (AndOrList -> m AndOrList)
instance (Monad m, Functor m) => ExpressionMapperM m (Command -> m Command)

module Language.Sh.Pretty

-- | This is the pretty-printing class
class Pretty p
pretty :: (Pretty p) => p -> String
compacted :: (Pretty p) => p -> PrettyP String
indented :: (Pretty p) => Int -> p -> PrettyP String
instance Show PState
instance Show QuoteType
instance Eq QuoteType
instance Pretty [Command]
instance Pretty Command
instance Pretty AndOrList
instance Pretty Pipeline
instance Pretty Statement
instance Pretty Term
instance Pretty CompoundStatement
instance Pretty Assignment
instance Pretty Redir
instance Pretty Expansion
instance Pretty [Lexeme]
instance Pretty Lexeme
instance Pretty (PrettyP String)
instance Pretty String

module Language.Sh.Glob
expandGlob :: (MonadIO m) => Word -> m [FilePath]
matchPattern :: Word -> String -> Bool
removePrefix :: Bool -> Word -> String -> String
removeSuffix :: Bool -> Word -> String -> String


-- | Here we use the stuff defined in the AST and Parsec modules to parse
--   things.
module Language.Sh.Parser

-- | This is the main export here. We take a list of aliases for the
--   environment and a <tt>String</tt> to parse. The return type is
--   <tt>Right [Command]</tt> if parsing succeeded and <tt>Left
--   (String,Bool)</tt> upon failure. The <tt>Bool</tt> is <tt>True</tt>
--   when the error was fatal/unrecoverable.
parse :: [(String, String)] -> String -> Either (String, Bool) [Command]
hereDocsComplete :: [Command] -> Bool
instance Enum WordContext
instance Ord WordContext
instance Eq WordContext

module Language.Sh.Arithmetic
runMathParser :: SS -> String -> Either String (Int, SI)
instance Show Term


-- | This is the expansion module. It provides an interface for a monad in
--   which expansions can happen, and then defines the expansions.
module Language.Sh.Expansion
data ExpansionFunctions m
ExpansionFunctions :: m [(String, String)] -> (String -> String -> m ()) -> (String -> m (Maybe String)) -> (Word -> m [FilePath]) -> ([Command] -> m String) -> m [String] -> ExpansionFunctions m
getAllEnv :: ExpansionFunctions m -> m [(String, String)]
setEnv :: ExpansionFunctions m -> String -> String -> m ()
homeDir :: ExpansionFunctions m -> String -> m (Maybe String)
expandGlob :: ExpansionFunctions m -> Word -> m [FilePath]
commandSub :: ExpansionFunctions m -> [Command] -> m String
positionals :: ExpansionFunctions m -> m [String]

-- | This is a default function that basically treats globs as literals.
noGlobExpansion :: (Monad m) => Word -> m [String]

-- | We have one main sticking point here... in the case of <tt>A=*</tt>,
--   we want to use expandWord, and do the glob expansion. In the case of
--   <tt>&gt;*</tt>, we want to <i>try</i> the glob expansion and then
--   given an error in the case that we get multiple hits. We could make
--   one more expansion function? (expandNoAmbiguousGlob?)
expand :: (Monad m, Functor m) => ExpansionFunctions m -> [Word] -> m [String]

-- | Test: A=1 * --&gt; A=1 ... -&gt; so it's getting expand'ed/joined, and
--   not expandWord'ed. For now, we'll leave globs out of this function,
--   but it seems like maybe the only use is in redirects, so then we can
--   make this the one that doesn't allow ambiguity. Also, we know that
--   glob expansion comes after field splitting... (B= ; A=2$B*) Tricky:
--   A=<a>3$B*</a>; echo $A --&gt; looks silly, but echo <a>$A</a>...
expandWord :: (Monad m, Functor m) => ExpansionFunctions m -> Word -> m String

-- | This is a version of expandWord that doesn't deal with globs or remove
--   quotes! It's currently only used in case statements.
expandPattern :: (Monad m, Functor m) => ExpansionFunctions m -> Word -> m Word
