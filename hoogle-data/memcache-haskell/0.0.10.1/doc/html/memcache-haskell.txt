-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Memcache procotol library
--   
@package memcache-haskell
@version 0.0.10.1


-- | Types
module Network.Memcache.Types

-- | statistic property list
type StatsList = [(String, String)]

-- | hostname and port (ex. "localhost:11211")
type Nodekey = String


-- | Class definitions
--   
--   This module is mainly for internal use.
module Network.Memcache.Class
class Message a where recvContent _h msg = return $ Just msg
parseHeader :: Message a => ByteString -> Maybe a
toChunks :: Message a => a -> [ByteString]
recvContent :: (Message a, MonadIO m) => Handle -> a -> m (Maybe a)


-- | This module represents memcached response messages.
module Network.Memcache.Response

-- | response messages from memcached server
data Response
Ok :: Response
Value :: !ByteString -> !Word32 -> !Word64 -> ByteString -> !(Maybe Word64) -> Response
End :: Response
Stored :: Response
NotStored :: Response
Exists :: Response
NotFound :: Response
Deleted :: Response
Found :: Response
Touched :: Response
Error :: Response
ServerError :: String -> Response
ClientError :: String -> Response
Version :: ByteString -> Response
Stat :: ByteString -> ByteString -> Response
Code :: Word64 -> Response

-- | Parse a response.
parseResponse :: ByteString -> Maybe Response

-- | Parse a response but only its header.
parseResponseHeader :: ByteString -> Maybe Response

-- | Response parser by attoparsec.
responseParser :: Parser Response

-- | Response header parser by attoparsec.
responseHeaderParser :: Parser Response
instance Show Response
instance Eq Response
instance Message Response


-- | This is a utility module for handle-based IO opearations
module Network.Memcache.IO

-- | Send a message
--   
--   <pre>
--   send socket FlushAllOp
--   </pre>
send :: (MonadIO m, Message a) => Handle -> a -> m ()

-- | Receive a message
--   
--   You may need to specify the return type when you call this function
--   like the code shown below.
--   
--   <pre>
--   mresp &lt;- recv socket :: IO (Maybe Response)
--   </pre>
recv :: (MonadIO m, Message a) => Handle -> m (Maybe a)


-- | For farther information, please see
--   <a>https://github.com/memcached/memcached/blob/master/doc/protocol.txt</a>
--   
--   <ul>
--   <li>storage - <tt>set</tt>, <tt>add</tt>, <tt>replace</tt>,
--   <tt>append</tt> or <tt>prepend</tt></li>
--   <li>retrieval - <tt>get</tt> and <tt>gets</tt></li>
--   <li>deletion - <tt>delete</tt></li>
--   <li>increment decrement - <tt>incr</tt> and <tt>decr</tt></li>
--   <li>touch - <tt>touch</tt></li>
--   <li>stats</li>
--   <li>other commands - <tt>flush_all</tt>, <a>version</a>,
--   <tt>quit</tt></li>
--   </ul>
module Network.Memcache.Op
data Option
Noreply :: Option
data Op
SetOp :: !ByteString -> !Word32 -> !Word64 -> !BytesT -> ValueT -> ![Option] -> Op
CasOp :: !ByteString -> !Word32 -> !Word64 -> !BytesT -> !Word64 -> ValueT -> ![Option] -> Op
AddOp :: !ByteString -> !Word32 -> !Word64 -> !BytesT -> ValueT -> ![Option] -> Op
ReplaceOp :: !ByteString -> !Word32 -> !Word64 -> !BytesT -> ValueT -> ![Option] -> Op
AppendOp :: !ByteString -> !Word32 -> !Word64 -> !BytesT -> ValueT -> ![Option] -> Op
PrependOp :: !ByteString -> !Word32 -> !Word64 -> !BytesT -> ValueT -> ![Option] -> Op
GetOp :: ![ByteString] -> Op
GetsOp :: ![ByteString] -> Op
DeleteOp :: !ByteString -> ![Option] -> Op
IncrOp :: !ByteString -> !Word64 -> ![Option] -> Op
DecrOp :: !ByteString -> !Word64 -> ![Option] -> Op
TouchOp :: !ByteString -> !Word64 -> ![Option] -> Op
PingOp :: Op
FlushAllOp :: Op
VersionOp :: Op
QuitOp :: Op
StatsOp :: ![ByteString] -> Op

-- | true if an operation is an update command
isWriteOp :: Op -> Bool

-- | true if an operation is a retrieval command
isReadOp :: Op -> Bool

-- | true if an operation has noreply option
isNoreplyOp :: Op -> Bool

-- | true if an operation is a storage command
isStorageOp :: Op -> Bool

-- | parse a option string
toOption :: ByteString -> Maybe Option

-- | parse option strings
toOptions :: [ByteString] -> Maybe [Option]

-- | get the key of an operation
keyOf :: Op -> Maybe ByteString

-- | get the value size of an operation
bytesOf :: Op -> Maybe BytesT

-- | Parse an operation.
parseOp :: ByteString -> Maybe Op

-- | Parse an operation but only its header.
parseOpHeader :: ByteString -> Maybe Op

-- | command parser by attoparsec
opParser :: Parser Op

-- | command header parser by attoparsec
opHeaderParser :: Parser Op

-- | update the value of an operation
updateOpValue :: Op -> ValueT -> Op
instance Eq Option
instance Show Op
instance Read Op
instance Eq Op
instance Message Op
instance Read Option
instance Show Option


-- | This is a utility module for client application.
module Network.Memcache.Client

-- | Client is a handler corresponding to a memcached session.
data Client

-- | statistic property list
type StatsList = [(String, String)]

-- | hostname and port (ex. "localhost:11211")
type Nodekey = String

-- | Key class
class Hashable a => Key a
toBS :: Key a => a -> ByteString

-- | Value class
class Value a
serializeValue :: Value a => a -> ByteString
deserializeValue :: Value a => ByteString -> Either String a

-- | Open a client session and return a client handler.
openClient :: MonadIO m => Nodekey -> m (Maybe Client)

-- | Close a client session.
closeClient :: MonadIO m => Client -> m ()

-- | Get the hostname and port pair from a handler
clientNodekey :: Client -> String

-- | Get the socket from a handler
clientSocket :: Client -> Handle

-- | Connect and execute an action.
withClient :: Nodekey -> (Client -> IO (Maybe a)) -> IO (Maybe a)

-- | Connect to one of given hosts and execute an action.
--   
--   <pre>
--   import Network.Memcache
--     
--   main = do
--     mValue &lt;- withClient "127.0.0.1:11211" $ \client -&gt; get client "key"
--     case mValue of
--       Nothing -&gt; putStrLn "(no value)"
--       Just value -&gt; putStrLn value
--   </pre>
--   
--   Note that this function doesn't retry the action when it fails.
withClients :: [Nodekey] -> (Client -> IO (Maybe a)) -> IO (Maybe a)

-- | Connect to the given hosts one by one and execute the action for each
--   client.
--   
--   If you'd like to clear all the data in your cluster, you can use this
--   function to issue "flush_all" command to each memcache node.
--   
--   <pre>
--   main = do
--     ret &lt;- forEachClient ["192.168.0.1:11211", "192.168.0.2:11211"] $ flushAll
--     print ret
--   </pre>
forEachClient :: [Nodekey] -> (Client -> IO (Maybe a)) -> IO ([Maybe a])

-- | Set an item
set :: (MonadIO m, Key k, Value v) => Client -> k -> v -> m Bool

-- | Set an item with exptime
setEx :: (MonadIO m, Key k, Value v) => Client -> k -> v -> Word64 -> m Bool

-- | Cas an item
cas :: (MonadIO m, Key k, Value v) => Client -> k -> v -> Word64 -> m Bool

-- | Cas an item with exptime
casEx :: (MonadIO m, Key k, Value v) => Client -> k -> v -> Word64 -> Word64 -> m Bool

-- | Add an item
add :: (MonadIO m, Key k, Value v) => Client -> k -> v -> m Bool

-- | Add an item with exptime
addEx :: (MonadIO m, Key k, Value v) => Client -> k -> v -> Word64 -> m Bool

-- | Replace an item
replace :: (MonadIO m, Key k, Value v) => Client -> k -> v -> m Bool

-- | Replace an item with exptime
replaceEx :: (MonadIO m, Key k, Value v) => Client -> k -> v -> Word64 -> m Bool

-- | Get an item
get :: (MonadIO m, Key k, Value v) => Client -> k -> m (Maybe v)

-- | Get an item and its version
gets :: (MonadIO m, Key k, Value v) => Client -> k -> m (Maybe (v, Word64))

-- | Delete an item
delete :: (MonadIO m, Key k) => Client -> k -> m Bool

-- | Increment an item
incr :: (MonadIO m, Key k) => Client -> k -> Int -> m (Maybe Int)

-- | Decrement an item
decr :: (MonadIO m, Key k) => Client -> k -> Int -> m (Maybe Int)

-- | Flush all items
flushAll :: MonadIO m => Client -> m (Maybe Response)

-- | Acquire statistic information
--   
--   To get each statistic value from the resulted list, use
--   <a>Network.Memcache.Stats</a> module.
stats :: MonadIO m => Client -> m (StatsList)

-- | Acquire statistic information with arguments
--   
--   To get each statistic value from the resulted list, use
--   <a>Network.Memcache.Stats</a> module.
statsWithArgs :: MonadIO m => Client -> [String] -> m (StatsList)
instance Value ByteString
instance Value String
instance Key ByteString
instance Key String


-- | Statistic information
--   
--   Please refer to
--   <a>https://github.com/memcached/memcached/blob/master/doc/protocol.txt</a>
--   for detail.
module Network.Memcache.Stats

-- | get any stats value as a string
getValue :: String -> StatsList -> Maybe String

-- | pid (32u)
getPid :: StatsList -> Maybe Word32

-- | uptime (32u)
getUptime :: StatsList -> Maybe Word32

-- | time (32u) unix time
getTime :: StatsList -> Maybe Word32

-- | version (string)
getVersion :: StatsList -> Maybe String

-- | pointer_size (32)
getPointerSize :: StatsList -> Maybe Int32

-- | rusage_user (32u.32u)
getRusageUser :: StatsList -> Maybe (Word32, Word32)

-- | rusage_system (32u.32u)
getRusageSystem :: StatsList -> Maybe (Word32, Word32)

-- | curr_items (32u)
getCurrItems :: StatsList -> Maybe Word64

-- | total_items (32u)
getTotalItems :: StatsList -> Maybe Word64

-- | bytes (64u)
getBytes :: StatsList -> Maybe Word64

-- | curr_connections (32u)
getCurrConnections :: StatsList -> Maybe Word32

-- | total_connections (32u)
getTotalConnections :: StatsList -> Maybe Word32

-- | connection_structures (32u)
getConnectionStructures :: StatsList -> Maybe Word32

-- | cmd_get (64u)
getCmdGet :: StatsList -> Maybe Word64

-- | cmd_set (64u)
getCmdSet :: StatsList -> Maybe Word64

-- | get_hits (64u)
getGetHits :: StatsList -> Maybe Word64

-- | get_misses (64u)
getGetMisses :: StatsList -> Maybe Word64

-- | evictions (64u)
getEvictions :: StatsList -> Maybe Word64

-- | bytes_read (64u)
getBytesRead :: StatsList -> Maybe Word64

-- | bytes_written (64u)
getBytesWritten :: StatsList -> Maybe Word64

-- | limit_maxbytes (32u)
getLimitMaxbytes :: StatsList -> Maybe Word64

-- | threads (32u)
getThreads :: StatsList -> Maybe Word32


-- | memcache-haskell is a memcache protocol library for server and client
--   application.
--   
--   If you want to implement a simple memcache client, just import
--   <a>Network.Memcache</a> module and use withClient function.
--   
--   <pre>
--   import Network.Memcache
--     
--   main = do
--     mValue &lt;- withClient "127.0.0.1:11211" $ \client -&gt; get client "key"
--     case mValue of
--       Nothing -&gt; putStrLn "(no value)"
--       Just value -&gt; putStrLn value
--   </pre>
--   
--   Or, use openClient and closeClient pair for more complex cases.
--   
--   <pre>
--   import Control.Exception
--   import Control.Monad.Trans.Resource (allocate, release, runResourceT)
--   import Control.Monad.IO.Class
--   import Network.Memcache
--   import System.Environment
--   
--   main :: IO ()
--   main = do
--     args &lt;- getArgs
--     case args of
--       [] -&gt; main' "127.0.0.1:11211"
--       (nk:_) -&gt; main' nk
--   
--   main' :: Nodekey -&gt; IO ()
--   main' nodekey = runResourceT $ do
--     (rkeyClient , client) &lt;- flip allocate closeClient $ do
--       c &lt;- openClient nodekey
--       case c of
--         Just client -&gt; return (client)
--         Nothing -&gt; liftIO $ do
--           throwIO (userError "could not open.")
--     liftIO $ do
--       ret &lt;- set client "key" "foo"
--       print ret
--       ret' &lt;- get client "key" :: IO (Maybe String)
--       print ret'
--     release rkeyClient
--   </pre>
--   
--   If your application is more complex and should recognize memcache
--   command and response directly, you have to import more and use
--   low-level functions.
--   
--   For server application, please use <a>Network.Memcache.Op</a> and
--   <a>Network.Memcache.Response</a> directly to parse and process each
--   command.
--   
--   If you are familiar with conduit library, please take a look at
--   memcache-conduit library and you will find that you can write a
--   memcache protocol server very quickly.
--   
--   <pre>
--   main :: IO ()
--   main = do
--     runResourceT $ do
--       runTCPServer (serverSettings 13301 HostAny) $ \appData -&gt; do
--         (appSource appData)
--           $$ getOpText
--           =$ process htVar
--           =$ putResponseText
--           =$ (appSink appData)
--   
--   process = ...
--   </pre>
module Network.Memcache
