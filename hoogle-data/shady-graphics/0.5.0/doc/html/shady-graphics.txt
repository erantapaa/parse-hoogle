-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Functional GPU programming - DSEL & compiler
--   
--   Compile functional specifications for GPU execution. See also
--   shady-render, shady-tv, and shady-examples
--   
--   Copyright 2009-2011 by Conal Elliott; GNU AGPLv3 license (see
--   COPYING). This license is a place-holder. Let me know if you'd like
--   other terms.
@package shady-graphics
@version 0.5.0


-- | Simple colors
module Shady.Color

-- | Color, as RGBA
data Color

-- | Representation conversion
colorToR4 :: Color -> R4E

-- | Representation conversion
r4ToColor :: R4E -> Color

-- | Color from red, green, blue, alpha components
rgba :: R1 :=> (R1 :=> (R1 :=> (R1 :=> Color)))

-- | Color from red, green, blue components
rgb :: R1 :=> (R1 :=> (R1 :=> Color))

-- | Extract the red component
colorR :: Color -> FloatE

-- | Extract the green component
colorG :: Color -> FloatE

-- | Extract the blue component
colorB :: Color -> FloatE

-- | Extract the alpha component
colorA :: Color -> FloatE

-- | Overlay on two colors
overC :: Binop Color

-- | Pointwise <a>overC</a>, e.g., for images.
over :: Binop (p -> Color)
black :: Color

-- | Some colors
white :: Color
red :: Color
green :: Color
blue :: Color
clear :: Color
grey :: R1 :=> Color

-- | Shade of grey
gray :: R1 :=> Color
class HasColor a
toColor :: HasColor a => a -> Color
instance Eq Color
instance Ord Color
instance Show Color
instance Num Color
instance Fractional Color
instance Floating Color
instance AdditiveGroup Color
instance InnerSpace Color
instance HasColor BoolE
instance HasColor Color
instance IfB BoolE Color
instance Monoid Color
instance VectorSpace Color


-- | Lighting/shading. Adapted from Vertigo.
module Shady.Lighting

-- | Info about how one light affects a given point. The surface lighter
--   decides what to do with the light info. Attenuation and relation of
--   light position (if finitely distant) to surface position are already
--   accounted for. <a>liDir</a> is the direction <i>to</i> the light
--   (normalized).
data LightInfo
LI :: Color -> Dir3E -> LightInfo
liColor :: LightInfo -> Color
liDir :: LightInfo -> Dir3E

-- | A light is something that provides light info to every point in space
--   (though to some points it provides blackness), independent of
--   obstructions. Should probably also take an atmosphere argument.
type Light = R3E -> LightInfo

-- | Viewing environment: ambient, eye, lights
data View
View :: Color -> R3E -> [Light] -> View
viewAmbient :: View -> Color
viewEye :: View -> R3E
viewLights :: View -> [Light]

-- | Info about a surface at a point: position, normal, color
data SurfInfo
SurfInfo :: R3E -> Dir3E -> Color -> SurfInfo
surfPos :: SurfInfo -> R3E
surfNormal :: SurfInfo -> Dir3E
surfColor :: SurfInfo -> Color

-- | View-dependent lighter
type Lighter a = View -> SurfInfo -> a

-- | Light- and view-dependent lighter
type LLighter a = LightInfo -> Lighter a

-- | Ambient color
ambient :: Lighter Color

-- | Eye point
eye :: Lighter R3E

-- | Lights
lights :: Lighter [Light]

-- | Surface point
surfP :: Lighter R3E

-- | Surface normal
surfN :: Lighter Dir3E

-- | Surface Color
intrinsic :: Lighter Color

-- | Light color
colorL :: LLighter Color

-- | Direction <i>to</i> light
dirL :: LLighter R3E

-- | Combine contributions from multiple lights. Patterned after
--   Renderman's <tt>illuminance</tt> construct.
illuminance :: (AdditiveGroup a, IfB BoolE a) => LLighter a -> Lighter a

-- | Pure diffuse
diffuse :: Lighter Color

-- | Weighted combination of ambient and diffuse
ambDiff :: (Color, Color) -> Lighter Color

-- | The Stanford rtsl version, with ambient and weights:
--   
--   surface float4 lightmodel_diffuse (float4 ka, float4 kd) { perlight
--   float diffuse = dot(N,L); perlight float4 fr = kd * select(diffuse
--   &gt; 0, diffuse, 0); return ka * Ca + integrate(fr * Cl); }
--   
--   Direction from surface point to eye
eyeDir :: Lighter Dir3E

-- | Eye/light vector average (CGPP p 731)
eyeLight :: LLighter Dir3E

-- | Reflection vector (CGPP p 730)
reflection :: LLighter Dir3E

-- | Pure specular. Ignores intrinsic surface color. There are different
--   ways to compute the power base.
specularG :: LLighter FloatE -> FloatE -> Lighter Color
specularRV :: FloatE -> Lighter Color

-- | Or the N.H model:
specularNH :: FloatE -> Lighter Color

-- | surface floatv lightmodel_specular (floatv s, floatv e, float sh) {
--   perlight float diffuse = dot(N,DIRL); perlight float specular =
--   pow(max(dot(N,H),0),sh); perlight floatv fr = select(diffuse &gt; 0, s
--   * specular, Zero); return integrate(fr * Cl) + e; }
type BasicSh = (Color, Color, Color, FloatE) -> Lighter Color

-- | Combine intrinsic, ambient, diffuse and specular, with weightings
basic :: LLighter FloatE -> BasicSh
basicRV :: BasicSh
basicNH :: BasicSh

-- | surface float4 lightmodel (float4 a, float4 d, float4 s, float4 e,
--   float sh) { perlight float diffuse = dot(N,DIRL); perlight float
--   specular = pow(max(dot(N,H),0),sh); perlight float4 fr = d *
--   max(diffuse, 0) + s * select(diffuse &gt; 0, specular, 0); return a *
--   Ca + integrate(fr * Cl) + e; }
class Liftable k f
lift :: Liftable k f => k -> f

-- | Direction. Assumed normalized.
type Dir3E = R3E

-- | Directional light, given the direction <i>from</i> the light (opposite
--   <a>dirL</a>)
dirLight :: Color -> Dir3E -> Light

-- | Point light
pointLight :: Color -> R3E -> Light
stdViewPos :: R3E

-- | View with white ambient light and given eye position and lights
stdView :: R3E -> [Light] -> View

-- | View with white ambient light, one directional light, and given eye
--   position. For now, light position is like eye position but more so.
view1 :: R3E -> View
ma :: Color
md :: Color
ms :: Color
msh :: FloatE
basicStd :: Lighter Color
instance Liftable d (a -> b -> c -> d)
instance Liftable c (a -> b -> c)
instance Liftable b (a -> b)
instance Liftable a a


-- | Invertible transformations
module Shady.ITransform

-- | Transform with inverse. The <a>Monoid</a> instances is identity and
--   composition (in the usual order for composition of the forward
--   transformations).
data ITransform a
ITransform :: Unop a -> Unop a -> ITransform a
itForward :: ITransform a -> Unop a
itBackward :: ITransform a -> Unop a

-- | Inverse an <a>ITransform</a>
inverse :: Unop (ITransform a)

-- | Handy when we invert a transform by modifying the argument to the
--   transform's maker.
andInverse :: (c -> Unop a) -> (c -> c) -> c -> ITransform a

-- | Transformable values
class ITrans w a | a -> w
(*:) :: ITrans w a => ITransform w -> Unop a
instance (ITrans w a, ITrans w b) => ITrans w (a -> b)
instance (ITrans w a, ITrans w b, ITrans w c, ITrans w d) => ITrans w (a, b, c, d)
instance (ITrans w a, ITrans w b, ITrans w c) => ITrans w (a, b, c)
instance (ITrans w a, ITrans w b) => ITrans w (a, b)
instance ITrans (Complex s) (Complex s)
instance ITrans w (E a)
instance Monoid (ITransform a)


-- | Images (infinite &amp; continuous)
module Shady.Image
type Point = ComplexE R
pointToR2 :: Point -> R2E
r2ToPoint :: R2E -> Point

-- | Generalized filter, polymorphic over domain
type FilterG p a = Unop (p -> a)

-- | Image filter
type Filter a = FilterG Point a

-- | Wrap up a sampler as an image
samplerIm :: Sampler2 :=> Image Color
scale2 :: (Floating s, ITrans (Complex s) a) => Complex s -> Unop a
uscale2 :: (Floating s, ITrans (Complex s) a) => s -> Unop a
translate2 :: (Floating s, ITrans (Complex s) a) => Complex s -> Unop a
rotate2 :: (Floating s, ITrans (Complex s) a) => s -> Unop a

-- | Bilinear interpolation
bilerp :: VectorSpace w => w -> w -> w -> w -> (Scalar w, Scalar w) -> w

-- | Bilinear interpolation image
bilerpC :: (VectorSpace w, (Scalar w) ~ s) => w -> w -> w -> w -> ImageG s w

-- | Generalized image -- continuous &amp; infinite
type ImageG s a = Complex s -> a

-- | Continuous, infinite image
type Image a = ImageG FloatE a

-- | Region over general space
type PRegion p = p -> BoolE

-- | 2D spatial region
type Region = Image BoolE
universeR :: Applicative f => f BoolE
emptyR :: Applicative f => f BoolE
eqF :: (IsNat n, IsScalar a, Eq a, Applicative f) => f (VecE n a) -> f (VecE n a) -> f BoolE
neqF :: (IsNat n, IsScalar a, Eq a, Applicative f) => f (VecE n a) -> f (VecE n a) -> f BoolE
intersectR :: Applicative f => Binop (f BoolE)
unionR :: Applicative f => Binop (f BoolE)
xorR :: Applicative f => Binop (f BoolE)
diffR :: Applicative f => Binop (f BoolE)
complementR :: Applicative f => Unop (f BoolE)

-- | Generalized unit disk/ball
udisk :: (InnerSpace p, (Scalar p) ~ FloatE) => PRegion p

-- | Generalized disk/ball, given radius
disk :: (InnerSpace p, (Scalar p) ~ FloatE) => FloatE -> PRegion p

-- | Generalized annulus, given outer &amp; inner radii
annulus :: (InnerSpace p, (Scalar p) ~ FloatE) => FloatE -> FloatE -> PRegion p

-- | Checker-board
checker :: Region

-- | Crop a function, filling in <a>mempty</a> where the test yeis false.
crop :: (Applicative f, Monoid (f a), IfB bool a) => f bool -> f a -> f a

-- | General domain-varying transformation.
transformG :: (c -> ITransform p) -> (p -> c) -> Unop (p -> a)

-- | Space-varying <a>translate2</a>
translate2Im :: AdditiveGroup p => Unop p -> Unop (p -> a)

-- | Space-varying <a>scale2</a>
scale2Im :: Fractional s => Unop (Complex s) -> Unop (ImageG s a)

-- | Space-varying <a>uscale2</a>
uscale2Im :: Fractional s => ImageG s s -> Unop (ImageG s a)

-- | Space-varying <a>rotate2</a>
rotate2Im :: Floating s => ImageG s s -> Unop (ImageG s a)

-- | Swirl transformation
swirl :: Floating s => s -> Unop (ImageG s a)

-- | Unit, rectangular tiling.
utile :: (Frac p, ITrans (Complex s) p, ITrans (Complex s) a, Floating s) => Unop (p -> a)
tile :: (Floating s, Frac s, ITrans (Complex s) a) => Complex s -> Unop (ImageG s a)
instance ITrans Point Color


-- | Parametric surfaces with automatic normals
module Shady.ParamSurf
type HeightField s = Complex s -> s
type Surf s = Complex s -> (s, s, s)
type USurf = forall s. Floating s => Surf s
type Curve2 s = s -> Complex s
type Curve3 s = s -> (s, s, s)
type Warp1 s = s -> s
type Warp2 s = Complex s -> Complex s
type Warp3 s = (s, s, s) -> (s, s, s)

-- | Trig functions with unit period ([-1,1])
sinU :: Floating s => s -> s
cosU :: Floating s => s -> s

-- | Turn a height field into a surface
hfSurf :: HeightField s -> Surf s

-- | Like <a>hfSurf</a> but for curve construction
fcurve :: Warp1 s -> Curve2 s

-- | Unit circle.
circle :: Floating s => Curve2 s

-- | Half semi circle, with theta in [-pi<i>2,pi</i>2]
semiCircle :: Floating s => Curve2 s

-- | Torus, given radius of sweep circle and cross section
torus :: (Floating s, VectorSpace s, (Scalar s) ~ s) => s -> s -> Surf s
revolveG :: Floating s => (s -> Curve2 s) -> Surf s
revolve :: Floating s => Curve2 s -> Surf s
sphere1 :: Floating s => Surf s

-- | Profile product.
profile :: Num s => Curve2 s -> Curve2 s -> Surf s
sphere3 :: Floating s => Surf s
sphere2 :: Floating s => Surf s

-- | Frustum, given base &amp; cap radii and height.
frustum :: (Floating s, VectorSpace s, (Scalar s) ~ s) => s -> s -> s -> Surf s

-- | Unit cylinder. Unit height and radii
ucylinder :: (Floating s, VectorSpace s) => Surf s

-- | XY plane as a surface
xyPlane :: Num s => Surf s

-- | Given a combining op and two curves, make a surface. A sort of
--   Cartesian product with combination.
cartF :: (a -> b -> c) -> (s -> a) -> (s -> b) -> (Complex s -> c)
sweep :: VectorSpace s => Curve3 s -> Curve3 s -> Surf s

-- | One period, unit height eggcrate
eggcrateH :: Floating s => HeightField s
revolveH :: (Floating s, InnerSpace s, (Scalar s) ~ s) => Warp1 s -> HeightField s
rippleH :: (Floating s, InnerSpace s, (Scalar s) ~ s) => HeightField s

-- | Simple ripply pond shape
ripple :: Floating s => Surf s

-- | Apply a displacement map at a value
displaceV :: (InnerSpace v, s ~ (Scalar v), Floating s, HasNormal v) => v -> Scalar v -> v

-- | Apply a displacement map to a function (e.g., <a>Curve2</a> or
--   <a>Surf</a>) or other container.
displace :: (InnerSpace v, (Scalar v) ~ s, Floating s, HasNormal v, Applicative f) => f v -> f (Scalar v) -> f v
rotate :: Floating s => s -> Warp2 s
addY :: Num s => (a -> Complex s) -> (a -> (s, s, s))
addZ :: Num s => (a -> Complex s) -> (a -> (s, s, s))
addX :: Num s => (a -> Complex s) -> (a -> (s, s, s))
addXZ :: Num s => (a -> s) -> (a -> (s, s, s))
addXY :: Num s => (a -> s) -> (a -> (s, s, s))
addYZ :: Num s => (a -> s) -> (a -> (s, s, s))
onY :: Warp1 s -> Warp3 s
onZ :: Warp1 s -> Warp3 s
onX :: Warp1 s -> Warp3 s
onYZ :: Warp2 s -> Warp3 s
onXZ :: Warp2 s -> Warp3 s
onXY :: Warp2 s -> Warp3 s
onY' :: Warp1 s -> (a -> (s, s, s)) -> (a -> (s, s, s))
onZ' :: Warp1 s -> (a -> (s, s, s)) -> (a -> (s, s, s))
onX' :: Warp1 s -> (a -> (s, s, s)) -> (a -> (s, s, s))
onXZ' :: Warp2 s -> (a -> (s, s, s)) -> (a -> (s, s, s))
onYZ' :: Warp2 s -> (a -> (s, s, s)) -> (a -> (s, s, s))
onXY' :: Warp2 s -> (a -> (s, s, s)) -> (a -> (s, s, s))
type V2 a = (a, a)
type V3 a = (a, a, a)
type ER = FloatE
type ER2 = V2 ER
type ER3 = V3 ER
type TR = ER :> ER
type T = ER2 :> ER

-- | Derivative towers of point on a surface
type SurfPt = V3 T

-- | Differentiable surface
type SurfD = Surf T

-- | Vertex and normal
type VN = (R3E, R3E)
toVN :: SurfPt -> VN
type SurfVN = R2E -> VN
surfVN :: SurfD -> SurfVN
instance ITrans (Complex T) T
instance HasBasis R2E
instance HasBasis FloatE


-- | Assemble shaders and display an image
module Shady.CompileSurface

-- | Eye position as a single expression. See also <tt>EyePos</tt>.
type EyePosE = R3E

-- | Renderable surface
type FullSurf = (Lighter Color, EyePosE -> View, SurfD, Image Color)

-- | 3D animation
type SurfB = T -> FullSurf

-- | Surface shader program
surfBProg :: EyePosE -> SurfB -> GLSL R1 R2
wrapSurf :: EyePosE -> SurfWrapper u'

-- | Wrap up a parameterized surface for compiling. Computes normals and
--   lighting per pixel -- sometimes called <a>exact shading</a>.
wrapSurfExact :: EyePosE -> SurfWrapper u'

-- | Wrap up a parameterized surface for compiling. This variant
--   interpolates normals, as in Phong shading.
wrapSurfIN :: EyePosE -> SurfWrapper u'

-- | Wrap up a parameterized surface for compiling. This variant
--   interpolates normals, as in Phong shading.
wrapSurfIC :: EyePosE -> SurfWrapper u'


-- | Compile a parameterized image
module Shady.CompileImage

-- | 2D animation
type ImageB c = R1 :=> Image c

-- | GLSL program for an <a>ImageB</a>.
imageBProg :: HasColor c => ImageB c -> GLSL R1 R2
imSurfB :: HasColor c => ImageB c -> SurfB
eyePos :: EyePos
