-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lenses for the taggy html/xml parser
--   
--   Lenses, folds, traversals and prisms for <a>taggy</a>.
--   
--   This greatly simplifies your life when dealing with the ugly world of
--   Real Life HTML. Here's an <a>example</a>. It lists the date, author
--   and package name of all the <i>recent package uploads</i> entries from
--   the hackage page of the same name. Note that it uses <a>wreq</a> to
--   <i>fetch</i> the Hackage page.
--   
--   <pre>
--   module Main (main) where
--   
--   import Control.Lens (to, only,(^?),ix, toListOf)
--   import Data.ByteString.Lazy (ByteString)
--   import Data.Text (Text)
--   import Data.Text.Encoding.Error (lenientDecode)
--   import Data.Text.Lazy.Encoding (decodeUtf8With)
--   import Network.HTTP.Client (Response)
--   import Network.Wreq (responseBody, get)
--   import Text.Taggy (Node)
--   import Text.Taggy.Lens (html, elements, children, contents,allNamed)
--   
--   data Upload =
--     Upload Text -- ^ date
--            Text -- ^ author
--            Text -- ^ package name
--     deriving (Show)
--   
--   table :: [Node] -&gt; Maybe Upload
--   table row = do
--     date    &lt;- row ^? ix 0 . contents
--     author  &lt;- row ^? ix 1 . contents
--     package &lt;- row ^? ix 2 . elements . contents
--     return $ Upload date author package
--   
--   recentPackages :: Response ByteString -&gt; [Maybe Upload]
--   recentPackages = toListOf
--                  $ responseBody . to (decodeUtf8With lenientDecode)
--                  . html . allNamed (only "tr") . children . to table
--   
--   main :: IO ()
--   main = get "https://hackage.haskell.org/packages/recent" &gt;&gt;= print `fmap` recentPackages
--   </pre>
--   
--   Report any problem on our <a>issues</a> page on github.
@package taggy-lens
@version 0.1.2

module Text.Taggy.Lens

-- | A <a>Node</a> is either an <a>Element</a> or some raw text.
data Node :: *
NodeElement :: Element -> Node
NodeContent :: Text -> Node

-- | An <a>Element</a> here refers to a tag name, the attributes specified
--   withing that tag, and all the children nodes of that element. An
--   <a>Element</a> is basically anything but "raw" content.
data Element :: *
Element :: !Text -> !(HashMap AttrName AttrValue) -> [Node] -> Element

-- | name of the element. e.g <a>a</a> for <a>a</a>
eltName :: Element -> !Text

-- | a (hash)map from attribute names to attribute values
eltAttrs :: Element -> !(HashMap AttrName AttrValue)

-- | children <a>Node</a>s
eltChildren :: Element -> [Node]

-- | A lens into the name of a given DOM element.
name :: Lens' Element Text

-- | A lens into the attributes of a given DOM element.
--   
--   <pre>
--   &gt;&gt;&gt; let markup = "&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;" :: Lazy.Text
--   
--   &gt;&gt;&gt; markup ^? html . element . attrs
--   Just (fromList [("xmlns","http://www.w3.org/1999/xhtml")])
--   
--   &gt;&gt;&gt; markup ^? html . element . attrs . at "xmlns" &amp; join
--   Just "http://www.w3.org/1999/xhtml"
--   
--   &gt;&gt;&gt; markup ^? html . element . attrs . at "style" &amp; join
--   Nothing
--   
--   &gt;&gt;&gt; markup &amp; html . element . attrs . at "xmlns" ?~ "http://www.w3.org/TR/html4/"
--   "&lt;html xmlns=\"http://www.w3.org/TR/html4/\"&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;"
--   </pre>
attrs :: Lens' Element (HashMap Text Text)

-- | A lens into the child nodes, elements, or contents of a given DOM
--   element.
--   
--   <pre>
--   &gt;&gt;&gt; let markup = "&lt;html&gt;&lt;title&gt;Your title goes here.&lt;/title&gt;&lt;body&gt;Your content goes here.&lt;/body&gt;&lt;/html&gt;" :: Lazy.Text
--   
--   &gt;&gt;&gt; markup ^? html . element . children . ix 0
--   Just (NodeElement (Element {eltName = "title", eltAttrs = fromList [], eltChildren = [NodeContent "Your title goes here."]}))
--   
--   &gt;&gt;&gt; markup &amp; html . element . children . ix 0 . element . children .~ [NodeContent "Lenses!"]
--   "&lt;html&gt;&lt;title&gt;Lenses!&lt;/title&gt;&lt;body&gt;Your content goes here.&lt;/body&gt;&lt;/html&gt;"
--   </pre>
children :: Lens' Element [Node]

-- | HTML document parsing and rendering.
--   
--   <pre>
--   &gt;&gt;&gt; let markup = "&lt;html&gt;&lt;head&gt;&lt;title&gt;My Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;blink&gt;Hello, world!&lt;/blink&gt;&lt;/body&gt;&lt;/html&gt;" :: Lazy.Text
--   
--   &gt;&gt;&gt; markup ^? htmlWith False
--   Just (NodeElement (Element {eltName = "html", eltAttrs = fromList [], eltChildren = [NodeElement (Element {eltName = "head", eltAttrs = fromList [], eltChildren = [NodeElement (Element {eltName = "title", eltAttrs = fromList [], eltChildren = [NodeContent "My Page"]})]}),NodeElement (Element {eltName = "body", eltAttrs = fromList [], eltChildren = [NodeElement (Element {eltName = "blink", eltAttrs = fromList [], eltChildren = [NodeContent "Hello, world!"]})]})]}))
--   
--   &gt;&gt;&gt; (markup ^? htmlWith False) ^. _Just . re (htmlWith False) == markup
--   True
--   </pre>
--   
--   The provided boolean specifies whether named entities should be
--   translated to unicode. For a less general version of this prism, with
--   translation by default, see 'html.'
--   
--   <pre>
--   &gt;&gt;&gt; (True, False) &amp; both %~ \convert -&gt; "&lt;span&gt;&amp;hearts;&lt;/span&gt;" ^? htmlWith convert . element . contents
--   (Just "\9829",Just "&amp;hearts;")
--   </pre>
--   
--   The parser produces a single node; if markup describes more than one
--   element at the top-level, all but the first are discarded.
--   
--   <pre>
--   &gt;&gt;&gt; (markup &lt;&gt; markup) ^? htmlWith False == markup ^? htmlWith False
--   True
--   </pre>
htmlWith :: Bool -> Prism' Text Node

-- | Like <a>htmlWith</a>, but converts named entities by default.
--   
--   <pre>
--   &gt;&gt;&gt; let markup = "&lt;html&gt;&lt;head&gt;&lt;title&gt;My Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;blink&gt;Hello, world!&lt;/blink&gt;&lt;/body&gt;&lt;/html&gt;" :: Lazy.Text
--   
--   &gt;&gt;&gt; markup ^? htmlWith True == markup ^? html
--   True
--   </pre>
html :: Prism' Text Node

-- | Construct a node from an element, or attempt to extract an element
--   from a node.
--   
--   <pre>
--   &gt;&gt;&gt; let markup = "&lt;html&gt;&lt;head&gt;&lt;title&gt;My Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;blink&gt;Hello, world!&lt;/blink&gt;&lt;/body&gt;&lt;/html&gt;" :: Lazy.Text
--   
--   &gt;&gt;&gt; markup ^? html . element
--   Just (Element {eltName = "html", eltAttrs = fromList [], eltChildren = [NodeElement (Element {eltName = "head", eltAttrs = fromList [], eltChildren = [NodeElement (Element {eltName = "title", eltAttrs = fromList [], eltChildren = [NodeContent "My Page"]})]}),NodeElement (Element {eltName = "body", eltAttrs = fromList [], eltChildren = [NodeElement (Element {eltName = "blink", eltAttrs = fromList [], eltChildren = [NodeContent "Hello, world!"]})]})]})
--   
--   &gt;&gt;&gt; markup ^? html . element. re element == markup ^? html
--   True
--   </pre>
class HasElement a
element :: HasElement a => Prism' a Element

-- | Construct a node from text, or attempt to extract text from a node.
--   
--   <pre>
--   &gt;&gt;&gt; let markup = "&lt;foo&gt;bar&lt;/foo&gt;" :: Lazy.Text
--   
--   &gt;&gt;&gt; markup ^? html . element . children . traverse . content
--   Just "bar"
--   
--   &gt;&gt;&gt; markup &amp; html . element . children . traverse . content .~ "baz"
--   "&lt;foo&gt;baz&lt;/foo&gt;"
--   </pre>
content :: Prism' Node Text

-- | Given an attribute name, a lens into its value for a given element.
--   
--   <pre>
--   &gt;&gt;&gt; let markup = "&lt;html&gt;&lt;foo class=\"a\"&gt;&lt;/foo&gt;&lt;bar class=\"b\"&gt;&lt;/bar&gt;&lt;/html&gt;" :: Lazy.Text
--   
--   &gt;&gt;&gt; markup ^.. htmlWith False . elements . attr "class" . _Just
--   ["a","b"]
--   </pre>
attr :: Text -> Lens' Element (Maybe Text)

-- | A traversal into attributes matching a provided property.
--   
--   <pre>
--   &gt;&gt;&gt; let markup = "&lt;html&gt;&lt;foo class=\"a\"&gt;&lt;/foo&gt;&lt;bar class=\"a\"&gt;&lt;/bar&gt;&lt;/html&gt;" :: Lazy.Text
--   
--   &gt;&gt;&gt; markup ^.. htmlWith False . elements . attributed (ix "class" . only "a") . name
--   ["foo","bar"]
--   </pre>
attributed :: Fold (HashMap Text Text) a -> Traversal' Element Element

-- | A traversal into elements with a name matching a provided property.
--   
--   <pre>
--   &gt;&gt;&gt; let markup = "&lt;html&gt;&lt;foo&gt;bar&lt;/foo&gt;&lt;baz&gt;qux&lt;/baz&gt;&lt;quux&gt;corge&lt;/quux&gt;&lt;/html&gt;" :: Lazy.Text
--   
--   &gt;&gt;&gt; markup ^.. htmlWith False . elements . named (to T.length . only 3) . name
--   ["foo","baz"]
--   </pre>
named :: Fold Text a -> Traversal' Element Element

-- | A traversal into the immediate children of an element that are also
--   elements, directly or via a Node.
--   
--   <pre>
--   &gt;&gt;&gt; let markup = "&lt;html&gt;&lt;foo&gt;&lt;/foo&gt;&lt;bar&gt;&lt;/bar&gt;&lt;baz&gt;&lt;/baz&gt;&lt;/html&gt;" :: Lazy.Text
--   
--   &gt;&gt;&gt; markup ^.. html . element . elements . name
--   ["foo","bar","baz"]
--   
--   &gt;&gt;&gt; markup ^.. html . elements . element . name
--   ["foo","bar","baz"]
--   </pre>
class HasElements a
elements :: HasElements a => Traversal' a Element

-- | A traversal into the immediate children of an element that are text
--   content, directly or via a Node.
--   
--   <pre>
--   &gt;&gt;&gt; let markup = "&lt;html&gt;&lt;foo&gt;&lt;/foo&gt;bar&lt;baz&gt;&lt;/baz&gt;qux&lt;/html&gt;" :: Lazy.Text
--   
--   &gt;&gt;&gt; markup ^.. html . element . contents
--   ["bar","qux"]
--   
--   &gt;&gt;&gt; markup ^.. html . contents
--   ["bar","qux"]
--   </pre>
class HasContent a
contents :: HasContent a => Traversal' a Text

-- | A fold into all elements (current and descendants) who's name satisfy
--   a provided property.
--   
--   <pre>
--   &gt;&gt;&gt; let markup' = "&lt;html&gt;&lt;foo class=\"woah\"&gt;bar&lt;qux&gt;&lt;foo&gt;baz&lt;/foo&gt;&lt;/qux&gt;&lt;/foo&gt;&lt;/html&gt;" :: Lazy.Text
--   
--   &gt;&gt;&gt; markup' ^.. html . allNamed (only "foo") . contents
--   ["bar","baz"]
--   
--   &gt;&gt;&gt; markup' ^.. html . allNamed (only "foo") . attributed (ix "class" . only "woah") . contents
--   ["bar"]
--   </pre>
allNamed :: HasElement a => Fold Text b -> Fold a Element

-- | A fold into all elements (current and descendants) who's attributes
--   satisfy a provided property.
--   
--   <pre>
--   &gt;&gt;&gt; let markup' = "&lt;html&gt;&lt;foo class=\"woah\"&gt;bar&lt;qux class=\"woah\"&gt;&lt;/qux&gt;&lt;/foo&gt;&lt;quux class=\"woah\"&gt;&lt;/quux&gt;&lt;/html&gt;" :: Lazy.Text
--   
--   &gt;&gt;&gt; markup' ^.. html . allAttributed (folded . only "woah") . name
--   ["foo","qux","quux"]
--   
--   &gt;&gt;&gt; markup' ^.. html . allAttributed (folded . only "woah") . named (only "foo") . name
--   ["foo"]
--   </pre>
allAttributed :: HasElement a => Fold (HashMap Text Text) b -> Fold a Element
instance Plated Element
instance Plated Node
instance HasContent Node
instance HasContent Element
instance HasElements Node
instance HasElements Element
instance HasElement Element
instance HasElement Node
