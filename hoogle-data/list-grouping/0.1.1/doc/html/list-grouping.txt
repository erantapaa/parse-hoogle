-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Functions for grouping a list into sublists
--   
--   Functions for grouping a list into sublists based on predicate or
--   integer offsets.
--   
--   NOTE: THIS MODULE IS DEPRECATED. PLEASE TRY THE <a>split</a> PACKAGE
--   INSTEAD http:<i></i>hackage.haskell.org<i>package</i>split-0.1.3
--   
--   Grouping a list based on integer offsets:
--   
--   <pre>
--   splitEvery 3 [1..10]  ==  [[1,2,3],[4,5,6],[7,8,9],[10]]
--   splitWith [1,3,1,3] [1..10]  ==  [[1],[2,3,4],[5],[6,7,8],[9,10]]
--   splitWithDrop [1,3,1,3] [1..10]  ==  [[1],[2,3,4],[5],[6,7,8]]
--   </pre>
--   
--   Grouping based on a predicate:
--   
--   <pre>
--   breakBefore odd [2..9]  ==  [[2],[3,4],[5,6],[7,8],[9]]
--   breakAfter odd [2..9]  ==  [[2,3],[4,5],[6,7],[8,9]]
--   breakDrop odd [0,0,0,1,0,1,1,0,0]  ==  [[0,0,0],[0],[0,0]]
--   </pre>
--   
--   Please send me any comments, requests or bug reports
@package list-grouping
@version 0.1.1


-- | Provides functions for the awkward task of dividing a list into
--   sub-lists, based on some predicate function, or based on some integer
--   offset (e.g. dividing a list into lists of three elements each.
--   
--   We could abstract out some common patterns, but I want the code to be
--   copy-and-pasteable. I'm hoping that this module can eventually contain
--   the most efficient implementation possible of these functions, and
--   would appreciate any suggestions or patches. Please also send any
--   suggestions for other useful list-grouping functions.
--   
--   Please send me any requests, bugs, or improvements to this module!
module Data.List.Grouping

-- | partitions list into sub-lists of length given by the Int:
splitEvery :: Int -> [a] -> [[a]]

-- | partitions list into lengths corresponding the list of Ints supplied.
--   if we run out of lengths, the remaining tail is returned as last
--   element.
splitWith :: [Int] -> [a] -> [[a]]

-- | same as <a>splitWith</a> but we drop the end of our list should we run
--   out of integer lengths.
splitWithDrop :: [Int] -> [a] -> [[a]]

-- | partitions list before every element matching predicate:
breakBefore :: (a -> Bool) -> [a] -> [[a]]

-- | partitions list after every element matching predicate:
breakAfter :: (a -> Bool) -> [a] -> [[a]]

-- | partitions the list at the points matching predicate, dropping those
--   elements that match.
breakDrop :: (a -> Bool) -> [a] -> [[a]]
