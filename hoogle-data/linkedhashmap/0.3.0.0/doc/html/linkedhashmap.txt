-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Persistent LinkedHashMap data structure
--   
@package linkedhashmap
@version 0.3.0.0

module Data.LinkedHashMap.IntMap
data LinkedHashMap k v
LinkedHashMap :: (HashMap k (Entry v)) -> (IntMap (k, v)) -> {-# UNPACK #-} !Int -> LinkedHashMap k v

-- | <i>O(1)</i> Construct an empty map.
empty :: LinkedHashMap k v

-- | <i>O(1)</i> Construct a map with a single element.
singleton :: (Eq k, Hashable k) => k -> v -> LinkedHashMap k v

-- | <i>O(1)</i> Return <a>True</a> if this map is empty, <a>False</a>
--   otherwise.
null :: LinkedHashMap k v -> Bool

-- | <i>O(1)</i> Return the number of key-value mappings in this map.
size :: LinkedHashMap k v -> Int

-- | <i>O(log n)</i> Return <a>True</a> if the specified key is present in
--   the map, <a>False</a> otherwise.
member :: (Eq k, Hashable k) => k -> LinkedHashMap k a -> Bool

-- | <i>O(log n)</i> Return the value to which the specified key is mapped,
--   or <a>Nothing</a> if this map contains no mapping for the key.
lookup :: (Eq k, Hashable k) => k -> LinkedHashMap k v -> Maybe v

-- | <i>O(log n)</i> Return the value to which the specified key is mapped,
--   or the default value if this map contains no mapping for the key.
lookupDefault :: (Eq k, Hashable k) => v -> k -> LinkedHashMap k v -> v

-- | <i>O(log n)</i> Return the value to which the specified key is mapped.
--   Calls <a>error</a> if this map contains no mapping for the key.
(!) :: (Eq k, Hashable k) => LinkedHashMap k v -> k -> v

-- | <i>O(log n)</i> Associate the specified value with the specified key
--   in this map. If this map previously contained a mapping for the key,
--   the old value is replaced.
insert :: (Eq k, Hashable k) => k -> v -> LinkedHashMap k v -> LinkedHashMap k v

-- | <i>O(log n)</i> Associate the value with the key in this map. If this
--   map previously contained a mapping for the key, the old value is
--   replaced by the result of applying the given function to the new and
--   old value. Example:
--   
--   <pre>
--   insertWith f k v map
--     where f new old = new + old
--   </pre>
insertWith :: (Eq k, Hashable k) => (v -> v -> v) -> k -> v -> LinkedHashMap k v -> LinkedHashMap k v

-- | <i>O(log n)</i> Remove the mapping for the specified key from this map
--   if present.
delete :: (Eq k, Hashable k) => k -> LinkedHashMap k v -> LinkedHashMap k v

-- | <i>O(log n)</i> Adjust the value tied to a given key in this map only
--   if it is present. Otherwise, leave the map alone.
adjust :: (Eq k, Hashable k) => (v -> v) -> k -> LinkedHashMap k v -> LinkedHashMap k v

-- | <i>O(m*log n)</i> The union of two maps, n - size of the first map. If
--   a key occurs in both maps, the mapping from the first will be the
--   mapping in the result.
union :: (Eq k, Hashable k) => LinkedHashMap k v -> LinkedHashMap k v -> LinkedHashMap k v

-- | <i>O(m*log n)</i> The union of two maps, n - size of the first map. If
--   a key occurs in both maps, the provided function (first argument) will
--   be used to compute the result.
unionWith :: (Eq k, Hashable k) => (v -> v -> v) -> LinkedHashMap k v -> LinkedHashMap k v -> LinkedHashMap k v

-- | Construct a set containing all elements from a list of sets.
unions :: (Eq k, Hashable k) => [LinkedHashMap k v] -> LinkedHashMap k v

-- | <i>O(n)</i> Transform this map by applying a function to every value.
map :: (v1 -> v2) -> LinkedHashMap k v1 -> LinkedHashMap k v2

-- | <i>O(n)</i> Transform this map by applying a function to every value.
mapWithKey :: (k -> v1 -> v2) -> LinkedHashMap k v1 -> LinkedHashMap k v2

-- | <i>O(n*log(n))</i> Transform this map by accumulating an Applicative
--   result from every value.
traverseWithKey :: Applicative f => (k -> v1 -> f v2) -> LinkedHashMap k v1 -> f (LinkedHashMap k v2)

-- | <i>O(n*log m)</i> Difference of two maps. Return elements of the first
--   map not existing in the second.
difference :: (Eq k, Hashable k) => LinkedHashMap k v -> LinkedHashMap k w -> LinkedHashMap k v

-- | <i>O(n*log m)</i> Intersection of two maps. Return elements of the
--   first map for keys existing in the second.
intersection :: (Eq k, Hashable k) => LinkedHashMap k v -> LinkedHashMap k w -> LinkedHashMap k v

-- | <i>O(n+m)</i> Intersection of two maps. If a key occurs in both maps
--   the provided function is used to combine the values from the two maps.
intersectionWith :: (Eq k, Hashable k) => (v1 -> v2 -> v3) -> LinkedHashMap k v1 -> LinkedHashMap k v2 -> LinkedHashMap k v3

-- | <i>O(n)</i> Reduce this map by applying a binary operator to all
--   elements, using the given starting value (typically the left-identity
--   of the operator). Each application of the operator is evaluated before
--   before using the result in the next application. This function is
--   strict in the starting value.
foldl' :: (a -> v -> a) -> a -> LinkedHashMap k v -> a

-- | <i>O(n)</i> Reduce this map by applying a binary operator to all
--   elements, using the given starting value (typically the left-identity
--   of the operator). Each application of the operator is evaluated before
--   before using the result in the next application. This function is
--   strict in the starting value.
foldlWithKey' :: (a -> k -> v -> a) -> a -> LinkedHashMap k v -> a

-- | <i>O(n)</i> Reduce this map by applying a binary operator to all
--   elements, using the given starting value (typically the right-identity
--   of the operator).
foldr :: (v -> a -> a) -> a -> LinkedHashMap k v -> a

-- | <i>O(n)</i> Reduce this map by applying a binary operator to all
--   elements, using the given starting value (typically the right-identity
--   of the operator).
foldrWithKey :: (k -> v -> a -> a) -> a -> LinkedHashMap k v -> a

-- | <i>O(n*log(n))</i> Filter this map by retaining only elements which
--   values satisfy a predicate.
filter :: (Eq k, Hashable k) => (v -> Bool) -> LinkedHashMap k v -> LinkedHashMap k v

-- | <i>O(n*log(n))</i> Filter this map by retaining only elements
--   satisfying a predicate.
filterWithKey :: (Eq k, Hashable k) => (k -> v -> Bool) -> LinkedHashMap k v -> LinkedHashMap k v

-- | <i>O(n)</i> Return a list of this map's keys. The list is produced
--   lazily.
keys :: (Eq k, Hashable k) => LinkedHashMap k v -> [k]

-- | <i>O(n)</i> Return a list of this map's values. The list is produced
--   lazily.
elems :: (Eq k, Hashable k) => LinkedHashMap k v -> [v]

-- | <i>O(n)</i> Return a list of this map's elements.
toList :: LinkedHashMap k v -> [(k, v)]

-- | <i>O(n*log n)</i> Construct a map with the supplied mappings. If the
--   list contains duplicate mappings, the later mappings take precedence.
fromList :: (Eq k, Hashable k) => [(k, v)] -> LinkedHashMap k v

-- | <i>O(n*log n)</i> Construct a map from a list of elements. Uses the
--   provided function to merge duplicate entries.
fromListWith :: (Eq k, Hashable k) => (v -> v -> v) -> [(k, v)] -> LinkedHashMap k v
instance Show a => Show (Entry a)
instance Traversable (LinkedHashMap k)
instance Foldable (LinkedHashMap k)
instance Functor (LinkedHashMap k)
instance (NFData k, NFData v) => NFData (LinkedHashMap k v)
instance NFData a => NFData (Entry a)
instance (Show k, Show v) => Show (LinkedHashMap k v)

module Data.LinkedHashMap.Seq
data LinkedHashMap k v
LinkedHashMap :: (HashMap k (Entry v)) -> (Seq (MaybePair k v)) -> {-# UNPACK #-} !Int -> LinkedHashMap k v

-- | <i>O(1)</i> Construct an empty map.
empty :: LinkedHashMap k v

-- | <i>O(1)</i> Construct a map with a single element.
singleton :: (Eq k, Hashable k) => k -> v -> LinkedHashMap k v

-- | <i>O(1)</i> Return <a>True</a> if this map is empty, <a>False</a>
--   otherwise.
null :: LinkedHashMap k v -> Bool

-- | <i>O(1)</i> Return the number of key-value mappings in this map.
size :: LinkedHashMap k v -> Int

-- | <i>O(log n)</i> Return <a>True</a> if the specified key is present in
--   the map, <a>False</a> otherwise.
member :: (Eq k, Hashable k) => k -> LinkedHashMap k a -> Bool

-- | <i>O(log n)</i> Return the value to which the specified key is mapped,
--   or <a>Nothing</a> if this map contains no mapping for the key.
lookup :: (Eq k, Hashable k) => k -> LinkedHashMap k v -> Maybe v

-- | <i>O(log n)</i> Return the value to which the specified key is mapped,
--   or the default value if this map contains no mapping for the key.
lookupDefault :: (Eq k, Hashable k) => v -> k -> LinkedHashMap k v -> v

-- | <i>O(log n)</i> Return the value to which the specified key is mapped.
--   Calls <a>error</a> if this map contains no mapping for the key.
(!) :: (Eq k, Hashable k) => LinkedHashMap k v -> k -> v

-- | <i>O(log n)</i> Associate the specified value with the specified key
--   in this map. If this map previously contained a mapping for the key,
--   the old value is replaced.
insert :: (Eq k, Hashable k) => k -> v -> LinkedHashMap k v -> LinkedHashMap k v

-- | <i>O(log n)</i> Associate the value with the key in this map. If this
--   map previously contained a mapping for the key, the old value is
--   replaced by the result of applying the given function to the new and
--   old value. Example:
--   
--   <pre>
--   insertWith f k v map
--     where f new old = new + old
--   </pre>
insertWith :: (Eq k, Hashable k) => (v -> v -> v) -> k -> v -> LinkedHashMap k v -> LinkedHashMap k v

-- | <i>O(log n)</i> Remove the mapping for the specified key from this map
--   if present.
delete :: (Eq k, Hashable k) => k -> LinkedHashMap k v -> LinkedHashMap k v

-- | <i>O(log n)</i> Adjust the value tied to a given key in this map only
--   if it is present. Otherwise, leave the map alone.
adjust :: (Eq k, Hashable k) => (v -> v) -> k -> LinkedHashMap k v -> LinkedHashMap k v

-- | <i>O(m*log n)</i> The union of two maps, n - size of the first map. If
--   a key occurs in both maps, the mapping from the first will be the
--   mapping in the result.
union :: (Eq k, Hashable k) => LinkedHashMap k v -> LinkedHashMap k v -> LinkedHashMap k v

-- | <i>O(m*log n)</i> The union of two maps, n - size of the first map. If
--   a key occurs in both maps, the provided function (first argument) will
--   be used to compute the result.
unionWith :: (Eq k, Hashable k) => (v -> v -> v) -> LinkedHashMap k v -> LinkedHashMap k v -> LinkedHashMap k v

-- | Construct a set containing all elements from a list of sets.
unions :: (Eq k, Hashable k) => [LinkedHashMap k v] -> LinkedHashMap k v

-- | <i>O(n)</i> Transform this map by applying a function to every value.
map :: (v1 -> v2) -> LinkedHashMap k v1 -> LinkedHashMap k v2

-- | <i>O(n)</i> Transform this map by applying a function to every value.
mapWithKey :: (k -> v1 -> v2) -> LinkedHashMap k v1 -> LinkedHashMap k v2

-- | <i>O(n*log(n))</i> Transform this map by accumulating an Applicative
--   result from every value.
traverseWithKey :: Applicative f => (k -> v1 -> f v2) -> LinkedHashMap k v1 -> f (LinkedHashMap k v2)

-- | <i>O(n*log m)</i> Difference of two maps. Return elements of the first
--   map not existing in the second.
difference :: (Eq k, Hashable k) => LinkedHashMap k v -> LinkedHashMap k w -> LinkedHashMap k v

-- | <i>O(n*log m)</i> Intersection of two maps. Return elements of the
--   first map for keys existing in the second.
intersection :: (Eq k, Hashable k) => LinkedHashMap k v -> LinkedHashMap k w -> LinkedHashMap k v

-- | <i>O(n+m)</i> Intersection of two maps. If a key occurs in both maps
--   the provided function is used to combine the values from the two maps.
intersectionWith :: (Eq k, Hashable k) => (v1 -> v2 -> v3) -> LinkedHashMap k v1 -> LinkedHashMap k v2 -> LinkedHashMap k v3

-- | <i>O(n)</i> Reduce this map by applying a binary operator to all
--   elements, using the given starting value (typically the left-identity
--   of the operator). Each application of the operator is evaluated before
--   before using the result in the next application. This function is
--   strict in the starting value.
foldl' :: (a -> v -> a) -> a -> LinkedHashMap k v -> a

-- | <i>O(n)</i> Reduce this map by applying a binary operator to all
--   elements, using the given starting value (typically the left-identity
--   of the operator). Each application of the operator is evaluated before
--   before using the result in the next application. This function is
--   strict in the starting value.
foldlWithKey' :: (a -> k -> v -> a) -> a -> LinkedHashMap k v -> a

-- | <i>O(n)</i> Reduce this map by applying a binary operator to all
--   elements, using the given starting value (typically the right-identity
--   of the operator).
foldr :: (v -> a -> a) -> a -> LinkedHashMap k v -> a

-- | <i>O(n)</i> Reduce this map by applying a binary operator to all
--   elements, using the given starting value (typically the right-identity
--   of the operator).
foldrWithKey :: (k -> v -> a -> a) -> a -> LinkedHashMap k v -> a

-- | <i>O(n*log(n))</i> Filter this map by retaining only elements which
--   values satisfy a predicate.
filter :: (Eq k, Hashable k) => (v -> Bool) -> LinkedHashMap k v -> LinkedHashMap k v

-- | <i>O(n*log(n))</i> Filter this map by retaining only elements
--   satisfying a predicate.
filterWithKey :: (Eq k, Hashable k) => (k -> v -> Bool) -> LinkedHashMap k v -> LinkedHashMap k v

-- | <i>O(n)</i> Return a list of this map's keys. The list is produced
--   lazily.
keys :: (Eq k, Hashable k) => LinkedHashMap k v -> [k]

-- | <i>O(n)</i> Return a list of this map's values. The list is produced
--   lazily.
elems :: (Eq k, Hashable k) => LinkedHashMap k v -> [v]

-- | <i>O(n)</i> Return a list of this map's elements. The list is produced
--   lazily.
toList :: LinkedHashMap k v -> [(k, v)]

-- | <i>O(n*log n)</i> Construct a map with the supplied mappings. If the
--   list contains duplicate mappings, the later mappings take precedence.
fromList :: (Eq k, Hashable k) => [(k, v)] -> LinkedHashMap k v

-- | <i>O(n*log n)</i> Construct a map from a list of elements. Uses the
--   provided function to merge duplicate entries.
fromListWith :: (Eq k, Hashable k) => (v -> v -> v) -> [(k, v)] -> LinkedHashMap k v
pack :: (Eq k, Hashable k) => LinkedHashMap k v -> LinkedHashMap k v
instance Show a => Show (Entry a)
instance (Show k, Show v) => Show (MaybePair k v)
instance Traversable (LinkedHashMap k)
instance Foldable (LinkedHashMap k)
instance Functor (LinkedHashMap k)
instance (NFData k, NFData v) => NFData (LinkedHashMap k v)
instance (NFData a, NFData b) => NFData (MaybePair a b)
instance NFData a => NFData (Entry a)
instance (Show k, Show v) => Show (LinkedHashMap k v)

module Data.LinkedHashSet

-- | A set of values. A set cannot contain duplicate values.
data LinkedHashSet a

-- | <i>O(1)</i> Construct an empty set.
empty :: LinkedHashSet a

-- | <i>O(1)</i> Construct a set with a single element.
singleton :: (Eq a, Hashable a) => a -> LinkedHashSet a

-- | <i>O(m*log n)</i> Construct a set containing all elements from both
--   sets, n - size of first map.
union :: (Eq a, Hashable a) => LinkedHashSet a -> LinkedHashSet a -> LinkedHashSet a

-- | Construct a set containing all elements from a list of sets.
unions :: (Eq a, Hashable a) => [LinkedHashSet a] -> LinkedHashSet a

-- | <i>O(1)</i> Return <a>True</a> if this set is empty, <a>False</a>
--   otherwise.
null :: LinkedHashSet a -> Bool

-- | <i>O(1)</i> Return the number of elements in this set.
size :: LinkedHashSet a -> Int

-- | <i>O(min(n,W))</i> Return <a>True</a> if the given value is present in
--   this set, <a>False</a> otherwise.
member :: (Eq a, Hashable a) => a -> LinkedHashSet a -> Bool

-- | <i>O(min(n,W))</i> Add the specified value to this set.
insert :: (Eq a, Hashable a) => a -> LinkedHashSet a -> LinkedHashSet a

-- | <i>O(min(n,W))</i> Remove the specified value from this set if
--   present.
delete :: (Eq a, Hashable a) => a -> LinkedHashSet a -> LinkedHashSet a

-- | <i>O(n)</i> Transform this set by applying a function to every value.
--   The resulting set may be smaller than the source.
map :: (Hashable b, Eq b) => (a -> b) -> LinkedHashSet a -> LinkedHashSet b

-- | <i>O(n)</i> Difference of two sets. Return elements of the first set
--   not existing in the second.
difference :: (Eq a, Hashable a) => LinkedHashSet a -> LinkedHashSet a -> LinkedHashSet a

-- | <i>O(n)</i> Intersection of two sets. Return elements present in both
--   the first set and the second.
intersection :: (Eq a, Hashable a) => LinkedHashSet a -> LinkedHashSet a -> LinkedHashSet a

-- | <i>O(n)</i> Reduce this set by applying a binary operator to all
--   elements, using the given starting value (typically the left-identity
--   of the operator). Each application of the operator is evaluated before
--   before using the result in the next application. This function is
--   strict in the starting value.
foldl' :: (a -> b -> a) -> a -> LinkedHashSet b -> a

-- | <i>O(n)</i> Reduce this set by applying a binary operator to all
--   elements, using the given starting value (typically the right-identity
--   of the operator).
foldr :: (b -> a -> a) -> a -> LinkedHashSet b -> a

-- | <i>O(n)</i> Filter this set by retaining only elements satisfying a
--   predicate.
filter :: (Eq a, Hashable a) => (a -> Bool) -> LinkedHashSet a -> LinkedHashSet a

-- | <i>O(n)</i> Return a list of this set's elements. The list is produced
--   lazily.
toList :: LinkedHashSet a -> [a]

-- | <i>O(n*min(W, n))</i> Construct a set from a list of elements.
fromList :: (Eq a, Hashable a) => [a] -> LinkedHashSet a
instance NFData a => NFData (LinkedHashSet a)
instance Show a => Show (LinkedHashSet a)

module Data.LinkedHashMap
