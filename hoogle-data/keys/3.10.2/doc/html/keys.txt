-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Keyed functors and containers
--   
@package keys
@version 3.10.2

module Data.Key
class Functor f => Keyed f
mapWithKey :: Keyed f => (Key f -> a -> b) -> f a -> f b
(<#$>) :: Keyed f => (Key f -> a -> b) -> f a -> f b
keyed :: Keyed f => f a -> f (Key f, a)
class Functor f => Zip f where zipWith f a b = uncurry f <$> zip a b zip = zipWith (,) zap = zipWith id
zipWith :: Zip f => (a -> b -> c) -> f a -> f b -> f c
zip :: Zip f => f a -> f b -> f (a, b)
zap :: Zip f => f (a -> b) -> f a -> f b
class (Keyed f, Zip f) => ZipWithKey f where zipWithKey f = zap . mapWithKey f zapWithKey = zipWithKey (\ k f -> f k)
zipWithKey :: ZipWithKey f => (Key f -> a -> b -> c) -> f a -> f b -> f c
zapWithKey :: ZipWithKey f => f (Key f -> a -> b) -> f a -> f b
class Lookup f => Indexable f
index :: Indexable f => f a -> Key f -> a
(!) :: Indexable f => f a -> Key f -> a
class Lookup f
lookup :: Lookup f => Key f -> f a -> Maybe a
lookupDefault :: Indexable f => Key f -> f a -> Maybe a
class Functor f => Adjustable f where replace k v = adjust (const v) k
adjust :: Adjustable f => (a -> a) -> Key f -> f a -> f a
replace :: Adjustable f => Key f -> a -> f a -> f a
class Foldable t => FoldableWithKey t where toKeyedList = foldrWithKey (\ k v t -> (k, v) : t) [] foldMapWithKey f = foldrWithKey (\ k v -> mappend (f k v)) mempty foldrWithKey f z t = appEndo (foldMapWithKey (\ k v -> Endo (f k v)) t) z foldlWithKey f z t = appEndo (getDual (foldMapWithKey (\ k a -> Dual (Endo (\ b -> f b k a))) t)) z
toKeyedList :: FoldableWithKey t => t a -> [(Key t, a)]
foldMapWithKey :: (FoldableWithKey t, Monoid m) => (Key t -> a -> m) -> t a -> m
foldrWithKey :: FoldableWithKey t => (Key t -> a -> b -> b) -> b -> t a -> b
foldlWithKey :: FoldableWithKey t => (b -> Key t -> a -> b) -> b -> t a -> b
foldrWithKey' :: FoldableWithKey t => (Key t -> a -> b -> b) -> b -> t a -> b
foldlWithKey' :: FoldableWithKey t => (b -> Key t -> a -> b) -> b -> t a -> b
foldrWithKeyM :: (FoldableWithKey t, Monad m) => (Key t -> a -> b -> m b) -> b -> t a -> m b
foldlWithKeyM :: (FoldableWithKey t, Monad m) => (b -> Key t -> a -> m b) -> b -> t a -> m b
traverseWithKey_ :: (FoldableWithKey t, Applicative f) => (Key t -> a -> f b) -> t a -> f ()
forWithKey_ :: (FoldableWithKey t, Applicative f) => t a -> (Key t -> a -> f b) -> f ()
mapWithKeyM_ :: (FoldableWithKey t, Monad m) => (Key t -> a -> m b) -> t a -> m ()
forWithKeyM_ :: (FoldableWithKey t, Monad m) => t a -> (Key t -> a -> m b) -> m ()
concatMapWithKey :: FoldableWithKey t => (Key t -> a -> [b]) -> t a -> [b]
anyWithKey :: FoldableWithKey t => (Key t -> a -> Bool) -> t a -> Bool
allWithKey :: FoldableWithKey t => (Key t -> a -> Bool) -> t a -> Bool
findWithKey :: FoldableWithKey t => (Key t -> a -> Bool) -> t a -> Maybe a
class (Foldable1 t, FoldableWithKey t) => FoldableWithKey1 t
foldMapWithKey1 :: (FoldableWithKey1 t, Semigroup m) => (Key t -> a -> m) -> t a -> m
traverseWithKey1_ :: (FoldableWithKey1 t, Apply f) => (Key t -> a -> f b) -> t a -> f ()
forWithKey1_ :: (FoldableWithKey1 t, Apply f) => t a -> (Key t -> a -> f b) -> f ()
foldMapWithKeyDefault1 :: (FoldableWithKey1 t, Monoid m) => (Key t -> a -> m) -> t a -> m
class (Keyed t, FoldableWithKey t, Traversable t) => TraversableWithKey t where mapWithKeyM f = unwrapMonad . traverseWithKey (fmap WrapMonad . f)
traverseWithKey :: (TraversableWithKey t, Applicative f) => (Key t -> a -> f b) -> t a -> f (t b)
mapWithKeyM :: (TraversableWithKey t, Monad m) => (Key t -> a -> m b) -> t a -> m (t b)
forWithKey :: (TraversableWithKey t, Applicative f) => t a -> (Key t -> a -> f b) -> f (t b)
forWithKeyM :: (TraversableWithKey t, Monad m) => t a -> (Key t -> a -> m b) -> m (t b)

-- | The <a>mapAccumWithKeyL</a> function behaves like a combination of
--   <a>mapWithKey</a> and <a>foldlWithKey</a>; it applies a function to
--   each element of a structure, passing an accumulating parameter from
--   left to right, and returning a final value of this accumulator
--   together with the new structure.
mapAccumWithKeyL :: TraversableWithKey t => (Key t -> a -> b -> (a, c)) -> a -> t b -> (a, t c)

-- | The <a>mapAccumWithKeyR</a> function behaves like a combination of
--   <a>mapWithKey</a> and <a>foldrWithKey</a>; it applies a function to
--   each element of a structure, passing an accumulating parameter from
--   right to left, and returning a final value of this accumulator
--   together with the new structure.
mapAccumWithKeyR :: TraversableWithKey t => (Key t -> a -> b -> (a, c)) -> a -> t b -> (a, t c)
mapWithKeyDefault :: TraversableWithKey t => (Key t -> a -> b) -> t a -> t b

-- | This function may be used as a value for <a>foldMapWithKey</a> in a
--   <a>FoldableWithKey</a> instance.
foldMapWithKeyDefault :: (TraversableWithKey t, Monoid m) => (Key t -> a -> m) -> t a -> m
class (Traversable1 t, FoldableWithKey1 t, TraversableWithKey t) => TraversableWithKey1 t
traverseWithKey1 :: (TraversableWithKey1 t, Apply f) => (Key t -> a -> f b) -> t a -> f (t b)
foldMapWithKey1Default :: (TraversableWithKey1 t, Semigroup m) => (Key t -> a -> m) -> t a -> m
instance TraversableWithKey Maybe
instance FoldableWithKey Maybe
instance ZipWithKey Maybe
instance Zip Maybe
instance Lookup Maybe
instance Indexable Maybe
instance Keyed Maybe
instance TraversableWithKey (HashMap k)
instance FoldableWithKey (HashMap k)
instance (Eq k, Hashable k) => ZipWithKey (HashMap k)
instance (Eq k, Hashable k) => Zip (HashMap k)
instance (Eq k, Hashable k) => Lookup (HashMap k)
instance (Eq k, Hashable k) => Indexable (HashMap k)
instance Keyed (HashMap k)
instance TraversableWithKey1 ((,) k)
instance TraversableWithKey ((,) k)
instance FoldableWithKey1 ((,) k)
instance FoldableWithKey ((,) k)
instance Keyed ((,) k)
instance (Adjustable f, Adjustable g) => Adjustable (Product f g)
instance (TraversableWithKey1 f, TraversableWithKey1 g) => TraversableWithKey1 (Product f g)
instance (TraversableWithKey f, TraversableWithKey g) => TraversableWithKey (Product f g)
instance (FoldableWithKey1 f, FoldableWithKey1 g) => FoldableWithKey1 (Product f g)
instance (FoldableWithKey f, FoldableWithKey g) => FoldableWithKey (Product f g)
instance (ZipWithKey f, ZipWithKey g) => ZipWithKey (Product f g)
instance (Zip f, Zip g) => Zip (Product f g)
instance (Lookup f, Lookup g) => Lookup (Product f g)
instance (Indexable f, Indexable g) => Indexable (Product f g)
instance (Keyed f, Keyed g) => Keyed (Product f g)
instance (Adjustable f, Adjustable g) => Adjustable (Coproduct f g)
instance (Lookup f, Lookup g) => Lookup (Coproduct f g)
instance (Indexable f, Indexable g) => Indexable (Coproduct f g)
instance Ix i => Adjustable (Array i)
instance Ix i => TraversableWithKey (Array i)
instance Ix i => FoldableWithKey (Array i)
instance Ix i => Lookup (Array i)
instance Ix i => Indexable (Array i)
instance Ix i => Keyed (Array i)
instance Ord k => Adjustable (Map k)
instance TraversableWithKey (Map k)
instance FoldableWithKey (Map k)
instance Ord k => Lookup (Map k)
instance Ord k => Indexable (Map k)
instance Keyed (Map k)
instance Ord k => ZipWithKey (Map k)
instance Ord k => Zip (Map k)
instance TraversableWithKey Seq
instance FoldableWithKey Seq
instance Keyed Seq
instance Adjustable Seq
instance ZipWithKey Seq
instance Zip Seq
instance Lookup Seq
instance Indexable Seq
instance TraversableWithKey1 NonEmpty
instance FoldableWithKey1 NonEmpty
instance Adjustable NonEmpty
instance Lookup NonEmpty
instance Indexable NonEmpty
instance TraversableWithKey NonEmpty
instance FoldableWithKey NonEmpty
instance Keyed NonEmpty
instance ZipWithKey NonEmpty
instance Zip NonEmpty
instance Adjustable []
instance Lookup []
instance Indexable []
instance TraversableWithKey []
instance FoldableWithKey []
instance Keyed []
instance ZipWithKey []
instance Zip []
instance (TraversableWithKey1 f, TraversableWithKey1 m) => TraversableWithKey1 (Compose f m)
instance (TraversableWithKey f, TraversableWithKey m) => TraversableWithKey (Compose f m)
instance (FoldableWithKey1 f, FoldableWithKey1 m) => FoldableWithKey1 (Compose f m)
instance (FoldableWithKey f, FoldableWithKey m) => FoldableWithKey (Compose f m)
instance (Lookup f, Lookup g) => Lookup (Compose f g)
instance (Indexable f, Indexable g) => Indexable (Compose f g)
instance (Keyed f, Keyed g) => Keyed (Compose f g)
instance (ZipWithKey f, ZipWithKey g) => ZipWithKey (Compose f g)
instance (Zip f, Zip g) => Zip (Compose f g)
instance Adjustable IntMap
instance Lookup IntMap
instance Indexable IntMap
instance TraversableWithKey IntMap
instance FoldableWithKey IntMap
instance Keyed IntMap
instance ZipWithKey IntMap
instance Zip IntMap
instance Lookup w => Lookup (TracedT s w)
instance Indexable w => Indexable (TracedT s w)
instance Keyed w => Keyed (TracedT s w)
instance ZipWithKey w => ZipWithKey (TracedT s w)
instance Zip w => Zip (TracedT s w)
instance Lookup m => Lookup (ReaderT e m)
instance Indexable m => Indexable (ReaderT e m)
instance Keyed m => Keyed (ReaderT e m)
instance ZipWithKey m => ZipWithKey (ReaderT e m)
instance Zip m => Zip (ReaderT e m)
instance Lookup ((->) a)
instance Indexable ((->) a)
instance ZipWithKey ((->) a)
instance Zip ((->) a)
instance Keyed ((->) a)
instance TraversableWithKey1 m => TraversableWithKey1 (IdentityT m)
instance TraversableWithKey m => TraversableWithKey (IdentityT m)
instance FoldableWithKey1 m => FoldableWithKey1 (IdentityT m)
instance FoldableWithKey m => FoldableWithKey (IdentityT m)
instance Keyed m => Keyed (IdentityT m)
instance ZipWithKey m => ZipWithKey (IdentityT m)
instance Zip m => Zip (IdentityT m)
instance Lookup m => Lookup (IdentityT m)
instance Indexable m => Indexable (IdentityT m)
instance TraversableWithKey1 Identity
instance TraversableWithKey Identity
instance FoldableWithKey1 Identity
instance FoldableWithKey Identity
instance Keyed Identity
instance ZipWithKey Identity
instance Zip Identity
instance Adjustable Identity
instance Lookup Identity
instance Indexable Identity
instance TraversableWithKey1 f => TraversableWithKey1 (Free f)
instance TraversableWithKey1 Tree
instance TraversableWithKey1 f => TraversableWithKey1 (Cofree f)
instance Applicative (StateR s)
instance Functor (StateR s)
instance Applicative (StateL s)
instance Functor (StateL s)
instance TraversableWithKey f => TraversableWithKey (Free f)
instance TraversableWithKey Tree
instance TraversableWithKey f => TraversableWithKey (Cofree f)
instance Functor f => Functor (Act f)
instance Apply f => Semigroup (Act f a)
instance FoldableWithKey1 f => FoldableWithKey1 (Free f)
instance FoldableWithKey1 Tree
instance FoldableWithKey1 f => FoldableWithKey1 (Cofree f)
instance FoldableWithKey Tree
instance FoldableWithKey f => FoldableWithKey (Cofree f)
instance FoldableWithKey f => FoldableWithKey (Free f)
instance Adjustable Tree
instance Adjustable f => Adjustable (Cofree f)
instance Adjustable f => Adjustable (Free f)
instance Lookup f => Lookup (Free f)
instance Lookup Tree
instance Lookup f => Lookup (Cofree f)
instance Indexable Tree
instance Indexable f => Indexable (Cofree f)
instance ZipWithKey Tree
instance ZipWithKey f => ZipWithKey (Cofree f)
instance Zip Tree
instance Zip f => Zip (Cofree f)
instance Keyed Tree
instance Keyed f => Keyed (Cofree f)
instance Keyed f => Keyed (Free f)
