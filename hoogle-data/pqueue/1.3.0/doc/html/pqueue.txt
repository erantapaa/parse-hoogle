-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Reliable, persistent, fast priority queues.
--   
@package pqueue
@version 1.3.0


-- | General purpose priority queue, supporting extract-minimum operations.
--   
--   An amortized running time is given for each operation, with <i>n</i>
--   referring to the length of the sequence and <i>k</i> being the
--   integral index used by some operations. These bounds hold even in a
--   persistent (shared) setting.
--   
--   This implementation is based on a binomial heap augmented with a
--   global root. The spine of the heap is maintained lazily. To force the
--   spine of the heap, use <a>seqSpine</a>.
--   
--   This implementation does not guarantee stable behavior.
--   
--   This implementation offers a number of methods of the form
--   <tt>xxxU</tt>, where <tt>U</tt> stands for unordered. No guarantees
--   whatsoever are made on the execution or traversal order of these
--   functions.
module Data.PQueue.Min

-- | A priority queue with elements of type <tt>a</tt>. Supports extracting
--   the minimum element.
data MinQueue a

-- | <i>O(1)</i>. The empty priority queue.
empty :: MinQueue a

-- | <i>O(1)</i>. Is this the empty priority queue?
null :: MinQueue a -> Bool

-- | <i>O(1)</i>. The number of elements in the queue.
size :: MinQueue a -> Int

-- | <i>O(1)</i>. Returns the minimum element. Throws an error on an empty
--   queue.
findMin :: MinQueue a -> a

-- | Returns the minimum element of the queue, if the queue is nonempty.
getMin :: MinQueue a -> Maybe a

-- | <i>O(log n)</i>. Deletes the minimum element. If the queue is empty,
--   does nothing.
deleteMin :: Ord a => MinQueue a -> MinQueue a

-- | <i>O(log n)</i>. Extracts the minimum element. Throws an error on an
--   empty queue.
deleteFindMin :: Ord a => MinQueue a -> (a, MinQueue a)

-- | Retrieves the minimum element of the queue, and the queue stripped of
--   that element, or <a>Nothing</a> if passed an empty queue.
minView :: Ord a => MinQueue a -> Maybe (a, MinQueue a)

-- | <i>O(1)</i>. Construct a priority queue with a single element.
singleton :: a -> MinQueue a

-- | Amortized <i>O(1)</i>, worst-case <i>O(log n)</i>. Insert an element
--   into the priority queue.
insert :: Ord a => a -> MinQueue a -> MinQueue a

-- | Amortized <i>O(log (min(n,m)))</i>, worst-case <i>O(log (max
--   (n,m)))</i>. Take the union of two priority queues.
union :: Ord a => MinQueue a -> MinQueue a -> MinQueue a

-- | Takes the union of a list of priority queues. Equivalent to
--   <tt><a>foldl</a> <a>union</a> <a>empty</a></tt>.
unions :: Ord a => [MinQueue a] -> MinQueue a

-- | <i>O(k log n)</i>. Index (subscript) operator, starting from 0.
--   <tt>queue !! k</tt> returns the <tt>(k+1)</tt>th smallest element in
--   the queue. Equivalent to <tt>toAscList queue !! k</tt>.
(!!) :: Ord a => MinQueue a -> Int -> a

-- | <i>O(k log n)</i>. <a>take</a> <tt>k</tt>, applied to a queue
--   <tt>queue</tt>, returns a list of the smallest <tt>k</tt> elements of
--   <tt>queue</tt>, or all elements of <tt>queue</tt> itself if <tt>k
--   &gt;= <a>size</a> queue</tt>.
take :: Ord a => Int -> MinQueue a -> [a]

-- | <i>O(k log n)</i>. <a>drop</a> <tt>k</tt>, applied to a queue
--   <tt>queue</tt>, returns <tt>queue</tt> with the smallest <tt>k</tt>
--   elements deleted, or an empty queue if <tt>k &gt;= size
--   <tt>queue</tt></tt>.
drop :: Ord a => Int -> MinQueue a -> MinQueue a

-- | <i>O(k log n)</i>. Equivalent to <tt>(<a>take</a> k queue, <a>drop</a>
--   k queue)</tt>.
splitAt :: Ord a => Int -> MinQueue a -> ([a], MinQueue a)

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a queue
--   <tt>queue</tt>, returns the longest prefix (possibly empty) of
--   <tt>queue</tt> of elements that satisfy <tt>p</tt>.
takeWhile :: Ord a => (a -> Bool) -> MinQueue a -> [a]

-- | <a>dropWhile</a> <tt>p queue</tt> returns the queue remaining after
--   <a>takeWhile</a> <tt>p queue</tt>.
dropWhile :: Ord a => (a -> Bool) -> MinQueue a -> MinQueue a

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a queue
--   <tt>queue</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>queue</tt> of elements that satisfy <tt>p</tt>
--   and second element is the remainder of the queue.
span :: Ord a => (a -> Bool) -> MinQueue a -> ([a], MinQueue a)

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a queue
--   <tt>queue</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>queue</tt> of elements that <i>do not
--   satisfy</i> <tt>p</tt> and second element is the remainder of the
--   queue.
break :: Ord a => (a -> Bool) -> MinQueue a -> ([a], MinQueue a)

-- | <i>O(n)</i>. Returns the queue with all elements not satisfying
--   <tt>p</tt> removed.
filter :: Ord a => (a -> Bool) -> MinQueue a -> MinQueue a

-- | <i>O(n)</i>. Returns a pair where the first queue contains all
--   elements satisfying <tt>p</tt>, and the second queue contains all
--   elements not satisfying <tt>p</tt>.
partition :: Ord a => (a -> Bool) -> MinQueue a -> (MinQueue a, MinQueue a)

-- | <i>O(n)</i>. Map elements and collect the <a>Just</a> results.
mapMaybe :: Ord b => (a -> Maybe b) -> MinQueue a -> MinQueue b

-- | <i>O(n)</i>. Map elements and separate the <a>Left</a> and
--   <a>Right</a> results.
mapEither :: (Ord b, Ord c) => (a -> Either b c) -> MinQueue a -> (MinQueue b, MinQueue c)

-- | <i>O(n)</i>. Creates a new priority queue containing the images of the
--   elements of this queue. Equivalent to <tt><a>fromList</a> . <a>map</a>
--   f . toList</tt>.
map :: Ord b => (a -> b) -> MinQueue a -> MinQueue b

-- | <i>O(n log n)</i>. Performs a right-fold on the elements of a priority
--   queue in ascending order.
foldrAsc :: Ord a => (a -> b -> b) -> b -> MinQueue a -> b

-- | <i>O(n log n)</i>. Performs a left-fold on the elements of a priority
--   queue in ascending order.
foldlAsc :: Ord a => (b -> a -> b) -> b -> MinQueue a -> b

-- | <i>O(n log n)</i>. Performs a right-fold on the elements of a priority
--   queue in descending order. <tt>foldrDesc f z q == foldlAsc (flip f) z
--   q</tt>.
foldrDesc :: Ord a => (a -> b -> b) -> b -> MinQueue a -> b

-- | <i>O(n log n)</i>. Performs a left-fold on the elements of a priority
--   queue in descending order. <tt>foldlDesc f z q == foldrAsc (flip f) z
--   q</tt>.
foldlDesc :: Ord a => (b -> a -> b) -> b -> MinQueue a -> b

-- | <i>O(n)</i>. Returns the elements of the priority queue in ascending
--   order. Equivalent to <a>toAscList</a>.
--   
--   If the order of the elements is irrelevant, consider using
--   <a>toListU</a>.
toList :: Ord a => MinQueue a -> [a]

-- | <i>O(n log n)</i>. Extracts the elements of the priority queue in
--   ascending order.
toAscList :: Ord a => MinQueue a -> [a]

-- | <i>O(n log n)</i>. Extracts the elements of the priority queue in
--   descending order.
toDescList :: Ord a => MinQueue a -> [a]

-- | <i>O(n)</i>. Constructs a priority queue from an unordered list.
fromList :: Ord a => [a] -> MinQueue a

-- | <i>O(n)</i>. Constructs a priority queue from an ascending list.
--   <i>Warning</i>: Does not check the precondition.
fromAscList :: [a] -> MinQueue a

-- | <i>O(n)</i>. Constructs a priority queue from an descending list.
--   <i>Warning</i>: Does not check the precondition.
fromDescList :: [a] -> MinQueue a

-- | Maps a function over the elements of the queue, ignoring order. This
--   function is only safe if the function is monotonic. This function
--   <i>does not</i> check the precondition.
mapU :: (a -> b) -> MinQueue a -> MinQueue b

-- | <i>O(n)</i>. Unordered right fold on a priority queue.
foldrU :: (a -> b -> b) -> b -> MinQueue a -> b

-- | <i>O(n)</i>. Unordered left fold on a priority queue.
foldlU :: (b -> a -> b) -> b -> MinQueue a -> b

-- | Equivalent to <a>toListU</a>.
elemsU :: MinQueue a -> [a]

-- | Returns the elements of the queue, in no particular order.
toListU :: MinQueue a -> [a]

-- | Constructs a priority queue out of the keys of the specified
--   <a>MinPQueue</a>.
keysQueue :: MinPQueue k a -> MinQueue k

-- | Forces the spine of the priority queue.
seqSpine :: MinQueue a -> b -> b
instance Ord a => Monoid (MinQueue a)
instance Read a => Read (MinQueue a)
instance (Ord a, Show a) => Show (MinQueue a)


-- | General purpose priority queue, supporting view-maximum operations.
--   
--   An amortized running time is given for each operation, with <i>n</i>
--   referring to the length of the sequence and <i>k</i> being the
--   integral index used by some operations. These bounds hold even in a
--   persistent (shared) setting.
--   
--   This implementation is based on a binomial heap augmented with a
--   global root. The spine of the heap is maintained lazily. To force the
--   spine of the heap, use <a>seqSpine</a>.
--   
--   This implementation does not guarantee stable behavior.
--   
--   This implementation offers a number of methods of the form
--   <tt>xxxU</tt>, where <tt>U</tt> stands for unordered. No guarantees
--   whatsoever are made on the execution or traversal order of these
--   functions.
module Data.PQueue.Max

-- | A priority queue with elements of type <tt>a</tt>. Supports extracting
--   the maximum element. Implemented as a wrapper around <a>MinQueue</a>.
data MaxQueue a

-- | <i>O(1)</i>. The empty priority queue.
empty :: MaxQueue a

-- | <i>O(1)</i>. Is this the empty priority queue?
null :: MaxQueue a -> Bool

-- | <i>O(1)</i>. The number of elements in the queue.
size :: MaxQueue a -> Int

-- | <i>O(1)</i>. Returns the maximum element of the queue. Throws an error
--   on an empty queue.
findMax :: MaxQueue a -> a

-- | <i>O(1)</i>. The top (maximum) element of the queue, if there is one.
getMax :: MaxQueue a -> Maybe a

-- | <i>O(log n)</i>. Deletes the maximum element of the queue. Does
--   nothing on an empty queue.
deleteMax :: Ord a => MaxQueue a -> MaxQueue a

-- | <i>O(log n)</i>. Extracts the maximum element of the queue. Throws an
--   error on an empty queue.
deleteFindMax :: Ord a => MaxQueue a -> (a, MaxQueue a)

-- | <i>O(log n)</i>. Extract the top (maximum) element of the sequence, if
--   there is one.
maxView :: Ord a => MaxQueue a -> Maybe (a, MaxQueue a)

-- | <i>O(1)</i>. Construct a priority queue with a single element.
singleton :: a -> MaxQueue a

-- | <i>O(1)</i>. Insert an element into the priority queue.
insert :: Ord a => a -> MaxQueue a -> MaxQueue a

-- | <i>O(log (min(n1,n2)))</i>. Take the union of two priority queues.
union :: Ord a => MaxQueue a -> MaxQueue a -> MaxQueue a

-- | Takes the union of a list of priority queues. Equivalent to
--   <tt><a>foldl</a> <a>union</a> <a>empty</a></tt>.
unions :: Ord a => [MaxQueue a] -> MaxQueue a

-- | <i>O(k log n)</i>. Returns the <tt>(k+1)</tt>th largest element of the
--   queue.
(!!) :: Ord a => MaxQueue a -> Int -> a

-- | <i>O(k log n)</i>. Returns the list of the <tt>k</tt> largest elements
--   of the queue, in descending order, or all elements of the queue, if
--   <tt>k &gt;= n</tt>.
take :: Ord a => Int -> MaxQueue a -> [a]

-- | <i>O(k log n)</i>. Returns the queue with the <tt>k</tt> largest
--   elements deleted, or the empty queue if <tt>k &gt;= n</tt>.
drop :: Ord a => Int -> MaxQueue a -> MaxQueue a

-- | <i>O(k log n)</i>. Equivalent to <tt>(take k queue, drop k
--   queue)</tt>.
splitAt :: Ord a => Int -> MaxQueue a -> ([a], MaxQueue a)

-- | <a>takeWhile</a>, applied to a predicate <tt>p</tt> and a queue
--   <tt>queue</tt>, returns the longest prefix (possibly empty) of
--   <tt>queue</tt> of elements that satisfy <tt>p</tt>.
takeWhile :: Ord a => (a -> Bool) -> MaxQueue a -> [a]

-- | <a>dropWhile</a> <tt>p queue</tt> returns the queue remaining after
--   <a>takeWhile</a> <tt>p queue</tt>.
dropWhile :: Ord a => (a -> Bool) -> MaxQueue a -> MaxQueue a

-- | <a>span</a>, applied to a predicate <tt>p</tt> and a queue
--   <tt>queue</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>queue</tt> of elements that satisfy <tt>p</tt>
--   and second element is the remainder of the queue.
span :: Ord a => (a -> Bool) -> MaxQueue a -> ([a], MaxQueue a)

-- | <a>break</a>, applied to a predicate <tt>p</tt> and a queue
--   <tt>queue</tt>, returns a tuple where first element is longest prefix
--   (possibly empty) of <tt>queue</tt> of elements that <i>do not
--   satisfy</i> <tt>p</tt> and second element is the remainder of the
--   queue.
break :: Ord a => (a -> Bool) -> MaxQueue a -> ([a], MaxQueue a)

-- | <i>O(n)</i>. Returns a queue of those elements which satisfy the
--   predicate.
filter :: Ord a => (a -> Bool) -> MaxQueue a -> MaxQueue a

-- | <i>O(n)</i>. Returns a pair of queues, where the left queue contains
--   those elements that satisfy the predicate, and the right queue
--   contains those that do not.
partition :: Ord a => (a -> Bool) -> MaxQueue a -> (MaxQueue a, MaxQueue a)

-- | <i>O(n)</i>. Maps a function over the elements of the queue, and
--   collects the <a>Just</a> values.
mapMaybe :: Ord b => (a -> Maybe b) -> MaxQueue a -> MaxQueue b

-- | <i>O(n)</i>. Maps a function over the elements of the queue, and
--   separates the <a>Left</a> and <a>Right</a> values.
mapEither :: (Ord b, Ord c) => (a -> Either b c) -> MaxQueue a -> (MaxQueue b, MaxQueue c)

-- | <a>map</a> <tt>f xs</tt> is the list obtained by applying <tt>f</tt>
--   to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
map :: (a -> b) -> [a] -> [b]

-- | <i>O(n log n)</i>. Performs a right-fold on the elements of a priority
--   queue in ascending order. <tt><a>foldrAsc</a> f z q ==
--   <a>foldlDesc</a> (flip f) z q</tt>.
foldrAsc :: Ord a => (a -> b -> b) -> b -> MaxQueue a -> b

-- | <i>O(n log n)</i>. Performs a left-fold on the elements of a priority
--   queue in descending order. <tt><a>foldlAsc</a> f z q ==
--   <a>foldrDesc</a> (flip f) z q</tt>.
foldlAsc :: Ord a => (b -> a -> b) -> b -> MaxQueue a -> b

-- | <i>O(n log n)</i>. Performs a right-fold on the elements of a priority
--   queue in descending order.
foldrDesc :: Ord a => (a -> b -> b) -> b -> MaxQueue a -> b

-- | <i>O(n log n)</i>. Performs a left-fold on the elements of a priority
--   queue in descending order.
foldlDesc :: Ord a => (b -> a -> b) -> b -> MaxQueue a -> b

-- | <i>O(n)</i>. Returns the elements of the priority queue in no
--   particular order.
toList :: Ord a => MaxQueue a -> [a]

-- | <i>O(n log n)</i>. Extracts the elements of the priority queue in
--   ascending order.
toAscList :: Ord a => MaxQueue a -> [a]

-- | <i>O(n log n)</i>. Extracts the elements of the priority queue in
--   descending order.
toDescList :: Ord a => MaxQueue a -> [a]

-- | <i>O(n log n)</i>. Constructs a priority queue from an unordered list.
fromList :: Ord a => [a] -> MaxQueue a

-- | <i>O(n)</i>. Constructs a priority queue from an ascending list.
--   <i>Warning</i>: Does not check the precondition.
fromAscList :: [a] -> MaxQueue a

-- | <i>O(n)</i>. Constructs a priority queue from a descending list.
--   <i>Warning</i>: Does not check the precondition.
fromDescList :: [a] -> MaxQueue a

-- | <i>O(n)</i>. Assumes that the function it is given is monotonic, and
--   applies this function to every element of the priority queue. <i>Does
--   not check the precondition</i>.
mapU :: (a -> b) -> MaxQueue a -> MaxQueue b

-- | <i>O(n)</i>. Unordered right fold on a priority queue.
foldrU :: (a -> b -> b) -> b -> MaxQueue a -> b

-- | <i>O(n)</i>. Unordered left fold on a priority queue.
foldlU :: (b -> a -> b) -> b -> MaxQueue a -> b

-- | Equivalent to <a>toListU</a>.
elemsU :: MaxQueue a -> [a]

-- | <i>O(n)</i>. Returns a list of the elements of the priority queue, in
--   no particular order.
toListU :: MaxQueue a -> [a]

-- | <i>O(n)</i>. Constructs a priority queue from the keys of a
--   <a>MaxPQueue</a>.
keysQueue :: MaxPQueue k a -> MaxQueue k

-- | <i>O(log n)</i>. Forces the spine of the heap.
seqSpine :: MaxQueue a -> b -> b
instance Typeable MaxQueue
instance Ord a => Eq (MaxQueue a)
instance Ord a => Ord (MaxQueue a)
instance (Data a, Ord a) => Data (MaxQueue a)
instance Ord a => Monoid (MaxQueue a)
instance Read a => Read (MaxQueue a)
instance (Ord a, Show a) => Show (MaxQueue a)
instance NFData a => NFData (MaxQueue a)


-- | General purpose priority queue. Each element is associated with a
--   <i>key</i>, and the priority queue supports viewing and extracting the
--   element with the minimum key.
--   
--   A worst-case bound is given for each operation. In some cases, an
--   amortized bound is also specified; these bounds do not hold in a
--   persistent context.
--   
--   This implementation is based on a binomial heap augmented with a
--   global root. The spine of the heap is maintained lazily. To force the
--   spine of the heap, use <a>seqSpine</a>.
--   
--   We do not guarantee stable behavior. Ties are broken arbitrarily --
--   that is, if <tt>k1 &lt;= k2</tt> and <tt>k2 &lt;= k1</tt>, then there
--   are no guarantees about the relative order in which <tt>k1</tt>,
--   <tt>k2</tt>, and their associated elements are returned. (Unlike
--   Data.Map, we allow multiple elements with the same key.)
--   
--   This implementation offers a number of methods of the form
--   <tt>xxxU</tt>, where <tt>U</tt> stands for unordered. No guarantees
--   whatsoever are made on the execution or traversal order of these
--   functions.
module Data.PQueue.Prio.Min

-- | A priority queue where values of type <tt>a</tt> are annotated with
--   keys of type <tt>k</tt>. The queue supports extracting the element
--   with minimum key.
data MinPQueue k a

-- | <i>O(1)</i>. Returns the empty priority queue.
empty :: MinPQueue k a

-- | <i>O(1)</i>. Constructs a singleton priority queue.
singleton :: k -> a -> MinPQueue k a

-- | Amortized <i>O(1)</i>, worst-case <i>O(log n)</i>. Inserts an element
--   with the specified key into the queue.
insert :: Ord k => k -> a -> MinPQueue k a -> MinPQueue k a

-- | Amortized <i>O(log(min(n1, n2)))</i>, worst-case <i>O(log(max(n1,
--   n2)))</i>. Returns the union of the two specified queues.
union :: Ord k => MinPQueue k a -> MinPQueue k a -> MinPQueue k a

-- | The union of a list of queues: (<tt><a>unions</a> == <a>foldl</a>
--   <a>union</a> <a>empty</a></tt>).
unions :: Ord k => [MinPQueue k a] -> MinPQueue k a

-- | <i>O(1)</i>. Checks if this priority queue is empty.
null :: MinPQueue k a -> Bool

-- | <i>O(1)</i>. Returns the size of this priority queue.
size :: MinPQueue k a -> Int

-- | <i>O(1)</i>. The minimal (key, element) in the queue. Calls
--   <a>error</a> if empty.
findMin :: MinPQueue k a -> (k, a)

-- | <i>O(1)</i>. The minimal (key, element) in the queue, if the queue is
--   nonempty.
getMin :: MinPQueue k a -> Maybe (k, a)

-- | <i>O(log n)</i>. Deletes the minimal (key, element) in the queue.
--   Returns an empty queue if the queue is empty.
deleteMin :: Ord k => MinPQueue k a -> MinPQueue k a

-- | <i>O(log n)</i>. Delete and find the element with the minimum key.
--   Calls <a>error</a> if empty.
deleteFindMin :: Ord k => MinPQueue k a -> ((k, a), MinPQueue k a)

-- | <i>O(1)</i>. Alter the value at the minimum key. If the queue is
--   empty, does nothing.
adjustMin :: (a -> a) -> MinPQueue k a -> MinPQueue k a

-- | <i>O(1)</i>. Alter the value at the minimum key. If the queue is
--   empty, does nothing.
adjustMinWithKey :: (k -> a -> a) -> MinPQueue k a -> MinPQueue k a

-- | <i>O(log n)</i>. (Actually <i>O(1)</i> if there's no deletion.) Update
--   the value at the minimum key. If the queue is empty, does nothing.
updateMin :: Ord k => (a -> Maybe a) -> MinPQueue k a -> MinPQueue k a

-- | <i>O(log n)</i>. (Actually <i>O(1)</i> if there's no deletion.) Update
--   the value at the minimum key. If the queue is empty, does nothing.
updateMinWithKey :: Ord k => (k -> a -> Maybe a) -> MinPQueue k a -> MinPQueue k a

-- | <i>O(log n)</i>. Retrieves the value associated with the minimal key
--   of the queue, and the queue stripped of that element, or
--   <a>Nothing</a> if passed an empty queue.
minView :: Ord k => MinPQueue k a -> Maybe (a, MinPQueue k a)

-- | <i>O(log n)</i>. Retrieves the minimal (key, value) pair of the map,
--   and the map stripped of that element, or <a>Nothing</a> if passed an
--   empty map.
minViewWithKey :: Ord k => MinPQueue k a -> Maybe ((k, a), MinPQueue k a)

-- | <i>O(n)</i>. Map a function over all values in the queue.
map :: (a -> b) -> MinPQueue k a -> MinPQueue k b

-- | <i>O(n)</i>. Map a function over all values in the queue.
mapWithKey :: (k -> a -> b) -> MinPQueue k a -> MinPQueue k b

-- | <i>O(n)</i>. <tt><a>mapKeys</a> f q</tt> is the queue obtained by
--   applying <tt>f</tt> to each key of <tt>q</tt>.
mapKeys :: Ord k' => (k -> k') -> MinPQueue k a -> MinPQueue k' a

-- | <i>O(n)</i>. <tt><a>mapKeysMonotonic</a> f q == <tt>mapKeys</tt> f
--   q</tt>, but only works when <tt>f</tt> is strictly monotonic. <i>The
--   precondition is not checked.</i> This function has better performance
--   than <tt>mapKeys</tt>.
mapKeysMonotonic :: (k -> k') -> MinPQueue k a -> MinPQueue k' a

-- | <i>O(n log n)</i>. Fold the keys and values in the map, such that
--   <tt><a>foldrWithKey</a> f z q == <a>foldr</a> (<a>uncurry</a> f) z
--   (<tt>toAscList</tt> q)</tt>.
--   
--   If you do not care about the traversal order, consider using
--   <a>foldrWithKeyU</a>.
foldrWithKey :: Ord k => (k -> a -> b -> b) -> b -> MinPQueue k a -> b

-- | <i>O(n log n)</i>. Fold the keys and values in the map, such that
--   <tt><a>foldlWithKey</a> f z q == <a>foldl</a> (<a>uncurry</a> . f) z
--   (<tt>toAscList</tt> q)</tt>.
--   
--   If you do not care about the traversal order, consider using
--   <a>foldlWithKeyU</a>.
foldlWithKey :: Ord k => (b -> k -> a -> b) -> b -> MinPQueue k a -> b

-- | <i>O(n log n)</i>. Traverses the elements of the queue in ascending
--   order by key. (<tt><a>traverseWithKey</a> f q == <a>fromAscList</a>
--   <a>$</a> <a>traverse</a> (<a>uncurry</a> f) (<a>toAscList</a> q)</tt>)
--   
--   If you do not care about the <i>order</i> of the traversal, consider
--   using <a>traverseWithKeyU</a>.
traverseWithKey :: (Ord k, Applicative f) => (k -> a -> f b) -> MinPQueue k a -> f (MinPQueue k b)

-- | <i>O(k log n)</i>. Takes the first <tt>k</tt> (key, value) pairs in
--   the queue, or the first <tt>n</tt> if <tt>k &gt;= n</tt>.
--   (<tt><a>take</a> k q == <a>take</a> k (<a>toAscList</a> q)</tt>)
take :: Ord k => Int -> MinPQueue k a -> [(k, a)]

-- | <i>O(k log n)</i>. Deletes the first <tt>k</tt> (key, value) pairs in
--   the queue, or returns an empty queue if <tt>k &gt;= n</tt>.
drop :: Ord k => Int -> MinPQueue k a -> MinPQueue k a

-- | <i>O(k log n)</i>. Equivalent to <tt>(<a>take</a> k q, <a>drop</a> k
--   q)</tt>.
splitAt :: Ord k => Int -> MinPQueue k a -> ([(k, a)], MinPQueue k a)

-- | Takes the longest possible prefix of elements satisfying the
--   predicate. (<tt><a>takeWhile</a> p q == <a>takeWhile</a> (p .
--   <a>snd</a>) (<a>toAscList</a> q)</tt>)
takeWhile :: Ord k => (a -> Bool) -> MinPQueue k a -> [(k, a)]

-- | Takes the longest possible prefix of elements satisfying the
--   predicate. (<tt><a>takeWhile</a> p q == <a>takeWhile</a> (uncurry p)
--   (<a>toAscList</a> q)</tt>)
takeWhileWithKey :: Ord k => (k -> a -> Bool) -> MinPQueue k a -> [(k, a)]

-- | Removes the longest possible prefix of elements satisfying the
--   predicate.
dropWhile :: Ord k => (a -> Bool) -> MinPQueue k a -> MinPQueue k a

-- | Removes the longest possible prefix of elements satisfying the
--   predicate.
dropWhileWithKey :: Ord k => (k -> a -> Bool) -> MinPQueue k a -> MinPQueue k a

-- | Equivalent to <tt>(<a>takeWhile</a> p q, <a>dropWhile</a> p q)</tt>.
span :: Ord k => (a -> Bool) -> MinPQueue k a -> ([(k, a)], MinPQueue k a)

-- | Equivalent to <tt>(<a>takeWhileWithKey</a> p q,
--   <a>dropWhileWithKey</a> p q)</tt>.
spanWithKey :: Ord k => (k -> a -> Bool) -> MinPQueue k a -> ([(k, a)], MinPQueue k a)

-- | Equivalent to <tt><a>span</a> (<a>not</a> . p)</tt>.
break :: Ord k => (a -> Bool) -> MinPQueue k a -> ([(k, a)], MinPQueue k a)

-- | Equivalent to <tt><a>spanWithKey</a> ( k a -&gt; <a>not</a> (p k a))
--   q</tt>.
breakWithKey :: Ord k => (k -> a -> Bool) -> MinPQueue k a -> ([(k, a)], MinPQueue k a)

-- | <i>O(n)</i>. Filter all values that satisfy the predicate.
filter :: Ord k => (a -> Bool) -> MinPQueue k a -> MinPQueue k a

-- | <i>O(n)</i>. Filter all values that satisfy the predicate.
filterWithKey :: Ord k => (k -> a -> Bool) -> MinPQueue k a -> MinPQueue k a

-- | <i>O(n)</i>. Partition the queue according to a predicate. The first
--   queue contains all elements which satisfy the predicate, the second
--   all elements that fail the predicate.
partition :: Ord k => (a -> Bool) -> MinPQueue k a -> (MinPQueue k a, MinPQueue k a)

-- | <i>O(n)</i>. Partition the queue according to a predicate. The first
--   queue contains all elements which satisfy the predicate, the second
--   all elements that fail the predicate.
partitionWithKey :: Ord k => (k -> a -> Bool) -> MinPQueue k a -> (MinPQueue k a, MinPQueue k a)

-- | <i>O(n)</i>. Map values and collect the <a>Just</a> results.
mapMaybe :: Ord k => (a -> Maybe b) -> MinPQueue k a -> MinPQueue k b

-- | <i>O(n)</i>. Map values and collect the <a>Just</a> results.
mapMaybeWithKey :: Ord k => (k -> a -> Maybe b) -> MinPQueue k a -> MinPQueue k b

-- | <i>O(n)</i>. Map values and separate the <a>Left</a> and <a>Right</a>
--   results.
mapEither :: Ord k => (a -> Either b c) -> MinPQueue k a -> (MinPQueue k b, MinPQueue k c)

-- | <i>O(n)</i>. Map values and separate the <a>Left</a> and <a>Right</a>
--   results.
mapEitherWithKey :: Ord k => (k -> a -> Either b c) -> MinPQueue k a -> (MinPQueue k b, MinPQueue k c)

-- | <i>O(n)</i>. Build a priority queue from the list of (key, value)
--   pairs.
fromList :: Ord k => [(k, a)] -> MinPQueue k a

-- | <i>O(n)</i>. Build a priority queue from an ascending list of (key,
--   value) pairs. <i>The precondition is not checked.</i>
fromAscList :: [(k, a)] -> MinPQueue k a

-- | <i>O(n)</i>. Build a priority queue from a descending list of (key,
--   value) pairs. <i>The precondition is not checked.</i>
fromDescList :: [(k, a)] -> MinPQueue k a

-- | <i>O(n log n)</i>. Return all keys of the queue in ascending order.
keys :: Ord k => MinPQueue k a -> [k]

-- | <i>O(n log n)</i>. Return all elements of the queue in ascending order
--   by key.
elems :: Ord k => MinPQueue k a -> [a]

-- | <i>O(n log n)</i>. Equivalent to <a>toAscList</a>.
assocs :: Ord k => MinPQueue k a -> [(k, a)]

-- | <i>O(n log n)</i>. Return all (key, value) pairs in ascending order by
--   key.
toAscList :: Ord k => MinPQueue k a -> [(k, a)]

-- | <i>O(n log n)</i>. Return all (key, value) pairs in descending order
--   by key.
toDescList :: Ord k => MinPQueue k a -> [(k, a)]

-- | <i>O(n log n)</i>. Equivalent to <a>toAscList</a>.
--   
--   If the traversal order is irrelevant, consider using <a>toListU</a>.
toList :: Ord k => MinPQueue k a -> [(k, a)]

-- | <i>O(n)</i>. An unordered right fold over the elements of the queue,
--   in no particular order.
foldrU :: (a -> b -> b) -> b -> MinPQueue k a -> b

-- | <i>O(n)</i>. An unordered right fold over the elements of the queue,
--   in no particular order.
foldrWithKeyU :: (k -> a -> b -> b) -> b -> MinPQueue k a -> b

-- | <i>O(n)</i>. An unordered left fold over the elements of the queue, in
--   no particular order.
foldlU :: (b -> a -> b) -> b -> MinPQueue k a -> b

-- | <i>O(n)</i>. An unordered left fold over the elements of the queue, in
--   no particular order.
foldlWithKeyU :: (b -> k -> a -> b) -> b -> MinPQueue k a -> b

-- | <i>O(n)</i>. An unordered traversal over a priority queue, in no
--   particular order. While there is no guarantee in which order the
--   elements are traversed, the resulting priority queue will be perfectly
--   valid.
traverseU :: Applicative f => (a -> f b) -> MinPQueue k a -> f (MinPQueue k b)
traverseWithKeyU :: Applicative f => (k -> a -> f b) -> MinPQueue k a -> f (MinPQueue k b)

-- | <i>O(n)</i>. Return all keys of the queue in no particular order.
keysU :: MinPQueue k a -> [k]

-- | <i>O(n)</i>. Return all elements of the queue in no particular order.
elemsU :: MinPQueue k a -> [a]

-- | <i>O(n)</i>. Equivalent to <a>toListU</a>.
assocsU :: MinPQueue k a -> [(k, a)]

-- | <i>O(n)</i>. Returns all (key, value) pairs in the queue in no
--   particular order.
toListU :: MinPQueue k a -> [(k, a)]

-- | <i>O(log n)</i>. Analogous to <tt>deepseq</tt> in the <tt>deepseq</tt>
--   package, but only forces the spine of the binomial heap.
seqSpine :: MinPQueue k a -> b -> b
instance Ord k => Traversable (MinPQueue k)
instance Ord k => Foldable (MinPQueue k)
instance Functor (MinPQueue k)
instance (Read k, Read a) => Read (MinPQueue k a)
instance (Ord k, Show k, Show a) => Show (MinPQueue k a)
instance Ord k => Monoid (MinPQueue k a)


-- | General purpose priority queue. Each element is associated with a
--   <i>key</i>, and the priority queue supports viewing and extracting the
--   element with the maximum key.
--   
--   A worst-case bound is given for each operation. In some cases, an
--   amortized bound is also specified; these bounds do not hold in a
--   persistent context.
--   
--   This implementation is based on a binomial heap augmented with a
--   global root. The spine of the heap is maintained lazily. To force the
--   spine of the heap, use <a>seqSpine</a>.
--   
--   We do not guarantee stable behavior. Ties are broken arbitrarily --
--   that is, if <tt>k1 &lt;= k2</tt> and <tt>k2 &lt;= k1</tt>, then there
--   are no guarantees about the relative order in which <tt>k1</tt>,
--   <tt>k2</tt>, and their associated elements are returned. (Unlike
--   Data.Map, we allow multiple elements with the same key.)
--   
--   This implementation offers a number of methods of the form
--   <tt>xxxU</tt>, where <tt>U</tt> stands for unordered. No guarantees
--   whatsoever are made on the execution or traversal order of these
--   functions.
module Data.PQueue.Prio.Max

-- | A priority queue where values of type <tt>a</tt> are annotated with
--   keys of type <tt>k</tt>. The queue supports extracting the element
--   with maximum key.
data MaxPQueue k a

-- | <i>O(1)</i>. Returns the empty priority queue.
empty :: MaxPQueue k a

-- | <i>O(1)</i>. Constructs a singleton priority queue.
singleton :: k -> a -> MaxPQueue k a

-- | Amortized <i>O(1)</i>, worst-case <i>O(log n)</i>. Inserts an element
--   with the specified key into the queue.
insert :: Ord k => k -> a -> MaxPQueue k a -> MaxPQueue k a

-- | Amortized <i>O(log(min(n1, n2)))</i>, worst-case <i>O(log(max(n1,
--   n2)))</i>. Returns the union of the two specified queues.
union :: Ord k => MaxPQueue k a -> MaxPQueue k a -> MaxPQueue k a

-- | The union of a list of queues: (<tt><a>unions</a> == <a>foldl</a>
--   <a>union</a> <a>empty</a></tt>).
unions :: Ord k => [MaxPQueue k a] -> MaxPQueue k a

-- | <i>O(1)</i>. Checks if this priority queue is empty.
null :: MaxPQueue k a -> Bool

-- | <i>O(1)</i>. Returns the size of this priority queue.
size :: MaxPQueue k a -> Int

-- | <i>O(1)</i>. The maximal (key, element) in the queue. Calls
--   <a>error</a> if empty.
findMax :: MaxPQueue k a -> (k, a)

-- | <i>O(1)</i>. The maximal (key, element) in the queue, if the queue is
--   nonempty.
getMax :: MaxPQueue k a -> Maybe (k, a)

-- | <i>O(log n)</i>. Delete and find the element with the maximum key.
--   Calls <a>error</a> if empty.
deleteMax :: Ord k => MaxPQueue k a -> MaxPQueue k a

-- | <i>O(log n)</i>. Delete and find the element with the maximum key.
--   Calls <a>error</a> if empty.
deleteFindMax :: Ord k => MaxPQueue k a -> ((k, a), MaxPQueue k a)

-- | <i>O(1)</i>. Alter the value at the maximum key. If the queue is
--   empty, does nothing.
adjustMax :: (a -> a) -> MaxPQueue k a -> MaxPQueue k a

-- | <i>O(1)</i>. Alter the value at the maximum key. If the queue is
--   empty, does nothing.
adjustMaxWithKey :: (k -> a -> a) -> MaxPQueue k a -> MaxPQueue k a

-- | <i>O(log n)</i>. (Actually <i>O(1)</i> if there's no deletion.) Update
--   the value at the maximum key. If the queue is empty, does nothing.
updateMax :: Ord k => (a -> Maybe a) -> MaxPQueue k a -> MaxPQueue k a

-- | <i>O(log n)</i>. (Actually <i>O(1)</i> if there's no deletion.) Update
--   the value at the maximum key. If the queue is empty, does nothing.
updateMaxWithKey :: Ord k => (k -> a -> Maybe a) -> MaxPQueue k a -> MaxPQueue k a

-- | <i>O(log n)</i>. Retrieves the value associated with the maximum key
--   of the queue, and the queue stripped of that element, or
--   <a>Nothing</a> if passed an empty queue.
maxView :: Ord k => MaxPQueue k a -> Maybe (a, MaxPQueue k a)

-- | <i>O(log n)</i>. Retrieves the maximal (key, value) pair of the map,
--   and the map stripped of that element, or <a>Nothing</a> if passed an
--   empty map.
maxViewWithKey :: Ord k => MaxPQueue k a -> Maybe ((k, a), MaxPQueue k a)

-- | <i>O(n)</i>. Map a function over all values in the queue.
map :: (a -> b) -> MaxPQueue k a -> MaxPQueue k b

-- | <i>O(n)</i>. Map a function over all values in the queue.
mapWithKey :: (k -> a -> b) -> MaxPQueue k a -> MaxPQueue k b

-- | <i>O(n)</i>. Map a function over all values in the queue.
mapKeys :: Ord k' => (k -> k') -> MaxPQueue k a -> MaxPQueue k' a

-- | <i>O(n)</i>. <tt><a>mapKeysMonotonic</a> f q == <a>mapKeys</a> f
--   q</tt>, but only works when <tt>f</tt> is strictly monotonic. <i>The
--   precondition is not checked.</i> This function has better performance
--   than <a>mapKeys</a>.
mapKeysMonotonic :: (k -> k') -> MaxPQueue k a -> MaxPQueue k' a

-- | <i>O(n log n)</i>. Fold the keys and values in the map, such that
--   <tt><a>foldrWithKey</a> f z q == <a>foldr</a> (<a>uncurry</a> f) z
--   (<a>toAscList</a> q)</tt>.
--   
--   If you do not care about the traversal order, consider using
--   <a>foldrWithKeyU</a>.
foldrWithKey :: Ord k => (k -> a -> b -> b) -> b -> MaxPQueue k a -> b

-- | <i>O(n log n)</i>. Fold the keys and values in the map, such that
--   <tt><a>foldlWithKey</a> f z q == <a>foldl</a> (<a>uncurry</a> . f) z
--   (<a>toAscList</a> q)</tt>.
--   
--   If you do not care about the traversal order, consider using
--   <a>foldlWithKeyU</a>.
foldlWithKey :: Ord k => (b -> k -> a -> b) -> b -> MaxPQueue k a -> b

-- | <i>O(n log n)</i>. Traverses the elements of the queue in descending
--   order by key. (<tt><a>traverseWithKey</a> f q == <a>fromDescList</a>
--   <a>$</a> <a>traverse</a> (<a>uncurry</a> f) (<a>toDescList</a>
--   q)</tt>)
--   
--   If you do not care about the <i>order</i> of the traversal, consider
--   using <a>traverseWithKeyU</a>.
traverseWithKey :: (Ord k, Applicative f) => (k -> a -> f b) -> MaxPQueue k a -> f (MaxPQueue k b)

-- | <i>O(k log n)</i>. Takes the first <tt>k</tt> (key, value) pairs in
--   the queue, or the first <tt>n</tt> if <tt>k &gt;= n</tt>.
--   (<tt><a>take</a> k q == <a>take</a> k (<a>toDescList</a> q)</tt>)
take :: Ord k => Int -> MaxPQueue k a -> [(k, a)]

-- | <i>O(k log n)</i>. Deletes the first <tt>k</tt> (key, value) pairs in
--   the queue, or returns an empty queue if <tt>k &gt;= n</tt>.
drop :: Ord k => Int -> MaxPQueue k a -> MaxPQueue k a

-- | <i>O(k log n)</i>. Equivalent to <tt>(<a>take</a> k q, <a>drop</a> k
--   q)</tt>.
splitAt :: Ord k => Int -> MaxPQueue k a -> ([(k, a)], MaxPQueue k a)

-- | Takes the longest possible prefix of elements satisfying the
--   predicate. (<tt><a>takeWhile</a> p q == <a>takeWhile</a> (p .
--   <a>snd</a>) (<a>toAscList</a> q)</tt>)
takeWhile :: Ord k => (a -> Bool) -> MaxPQueue k a -> [(k, a)]

-- | Takes the longest possible prefix of elements satisfying the
--   predicate. (<tt><a>takeWhile</a> p q == <a>takeWhile</a> (uncurry p)
--   (<a>toAscList</a> q)</tt>)
takeWhileWithKey :: Ord k => (k -> a -> Bool) -> MaxPQueue k a -> [(k, a)]

-- | Removes the longest possible prefix of elements satisfying the
--   predicate.
dropWhile :: Ord k => (a -> Bool) -> MaxPQueue k a -> MaxPQueue k a

-- | Removes the longest possible prefix of elements satisfying the
--   predicate.
dropWhileWithKey :: Ord k => (k -> a -> Bool) -> MaxPQueue k a -> MaxPQueue k a

-- | Equivalent to <tt>(<a>takeWhile</a> p q, <a>dropWhile</a> p q)</tt>.
span :: Ord k => (a -> Bool) -> MaxPQueue k a -> ([(k, a)], MaxPQueue k a)

-- | Equivalent to <tt><a>spanWithKey</a> ( k a -&gt; <a>not</a> (p k a))
--   q</tt>.
spanWithKey :: Ord k => (k -> a -> Bool) -> MaxPQueue k a -> ([(k, a)], MaxPQueue k a)

-- | Equivalent to <tt><a>span</a> (<a>not</a> . p)</tt>.
break :: Ord k => (a -> Bool) -> MaxPQueue k a -> ([(k, a)], MaxPQueue k a)

-- | Equivalent to <tt><a>spanWithKey</a> ( k a -&gt; <a>not</a> (p k a))
--   q</tt>.
breakWithKey :: Ord k => (k -> a -> Bool) -> MaxPQueue k a -> ([(k, a)], MaxPQueue k a)

-- | <i>O(n)</i>. Filter all values that satisfy the predicate.
filter :: Ord k => (a -> Bool) -> MaxPQueue k a -> MaxPQueue k a

-- | <i>O(n)</i>. Filter all values that satisfy the predicate.
filterWithKey :: Ord k => (k -> a -> Bool) -> MaxPQueue k a -> MaxPQueue k a

-- | <i>O(n)</i>. Partition the queue according to a predicate. The first
--   queue contains all elements which satisfy the predicate, the second
--   all elements that fail the predicate.
partition :: Ord k => (a -> Bool) -> MaxPQueue k a -> (MaxPQueue k a, MaxPQueue k a)

-- | <i>O(n)</i>. Partition the queue according to a predicate. The first
--   queue contains all elements which satisfy the predicate, the second
--   all elements that fail the predicate.
partitionWithKey :: Ord k => (k -> a -> Bool) -> MaxPQueue k a -> (MaxPQueue k a, MaxPQueue k a)

-- | <i>O(n)</i>. Map values and collect the <a>Just</a> results.
mapMaybe :: Ord k => (a -> Maybe b) -> MaxPQueue k a -> MaxPQueue k b

-- | <i>O(n)</i>. Map values and collect the <a>Just</a> results.
mapMaybeWithKey :: Ord k => (k -> a -> Maybe b) -> MaxPQueue k a -> MaxPQueue k b

-- | <i>O(n)</i>. Map values and separate the <a>Left</a> and <a>Right</a>
--   results.
mapEither :: Ord k => (a -> Either b c) -> MaxPQueue k a -> (MaxPQueue k b, MaxPQueue k c)

-- | <i>O(n)</i>. Map values and separate the <a>Left</a> and <a>Right</a>
--   results.
mapEitherWithKey :: Ord k => (k -> a -> Either b c) -> MaxPQueue k a -> (MaxPQueue k b, MaxPQueue k c)

-- | <i>O(n)</i>. Build a priority queue from the list of (key, value)
--   pairs.
fromList :: Ord k => [(k, a)] -> MaxPQueue k a

-- | <i>O(n)</i>. Build a priority queue from an ascending list of (key,
--   value) pairs. <i>The precondition is not checked.</i>
fromAscList :: [(k, a)] -> MaxPQueue k a

-- | <i>O(n)</i>. Build a priority queue from a descending list of (key,
--   value) pairs. <i>The precondition is not checked.</i>
fromDescList :: [(k, a)] -> MaxPQueue k a

-- | <i>O(n log n)</i>. Return all keys of the queue in ascending order.
keys :: Ord k => MaxPQueue k a -> [k]

-- | <i>O(n log n)</i>. Return all elements of the queue in ascending order
--   by key.
elems :: Ord k => MaxPQueue k a -> [a]

-- | <i>O(n log n)</i>. Equivalent to <a>toDescList</a>.
assocs :: Ord k => MaxPQueue k a -> [(k, a)]

-- | <i>O(n log n)</i>. Return all (key, value) pairs in ascending order by
--   key.
toAscList :: Ord k => MaxPQueue k a -> [(k, a)]

-- | <i>O(n log n)</i>. Return all (key, value) pairs in descending order
--   by key.
toDescList :: Ord k => MaxPQueue k a -> [(k, a)]

-- | <i>O(n log n)</i>. Equivalent to <a>toAscList</a>.
--   
--   If the traversal order is irrelevant, consider using <a>toListU</a>.
toList :: Ord k => MaxPQueue k a -> [(k, a)]

-- | <i>O(n)</i>. An unordered right fold over the elements of the queue,
--   in no particular order.
foldrU :: (a -> b -> b) -> b -> MaxPQueue k a -> b

-- | <i>O(n)</i>. An unordered right fold over the elements of the queue,
--   in no particular order.
foldrWithKeyU :: (k -> a -> b -> b) -> b -> MaxPQueue k a -> b

-- | <i>O(n)</i>. An unordered left fold over the elements of the queue, in
--   no particular order.
foldlU :: (b -> a -> b) -> b -> MaxPQueue k a -> b

-- | <i>O(n)</i>. An unordered left fold over the elements of the queue, in
--   no particular order.
foldlWithKeyU :: (b -> k -> a -> b) -> b -> MaxPQueue k a -> b

-- | <i>O(n)</i>. An unordered traversal over a priority queue, in no
--   particular order. While there is no guarantee in which order the
--   elements are traversed, the resulting priority queue will be perfectly
--   valid.
traverseU :: (Applicative f, Ord b) => (a -> f b) -> MaxPQueue k a -> f (MaxPQueue k b)

-- | <i>O(n)</i>. An unordered traversal over a priority queue, in no
--   particular order. While there is no guarantee in which order the
--   elements are traversed, the resulting priority queue will be perfectly
--   valid.
traverseWithKeyU :: (Applicative f, Ord b) => (k -> a -> f b) -> MaxPQueue k a -> f (MaxPQueue k b)

-- | <i>O(n)</i>. Return all keys of the queue in no particular order.
keysU :: MaxPQueue k a -> [k]

-- | <i>O(n)</i>. Return all elements of the queue in no particular order.
elemsU :: MaxPQueue k a -> [a]

-- | <i>O(n)</i>. Equivalent to <a>toListU</a>.
assocsU :: MaxPQueue k a -> [(k, a)]

-- | <i>O(n)</i>. Returns all (key, value) pairs in the queue in no
--   particular order.
toListU :: MaxPQueue k a -> [(k, a)]

-- | <i>O(log n)</i>. Analogous to <tt>deepseq</tt> in the <tt>deepseq</tt>
--   package, but only forces the spine of the binomial heap.
seqSpine :: MaxPQueue k a -> b -> b
instance Ord k => Traversable (MaxPQueue k)
instance Ord k => Foldable (MaxPQueue k)
instance Functor (MaxPQueue k)
instance (Read k, Read a) => Read (MaxPQueue k a)
instance (Ord k, Show k, Show a) => Show (MaxPQueue k a)
