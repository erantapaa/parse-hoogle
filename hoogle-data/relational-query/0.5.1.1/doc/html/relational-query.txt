-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Typeful, Modular, Relational, algebraic query engine
--   
@package relational-query
@version 0.5.1.1


-- | This module defines phantom typed SQL expression object. Contains
--   internal structure and unsafe interfaces.
module Database.Relational.Query.Expr.Unsafe

-- | Phantom typed SQL expression object. Project from projection type
--   <tt>p</tt>.
newtype Expr p a
Expr :: StringSQL -> Expr p a

-- | Get SQL expression from typed object.
unsafeStringSql :: Expr p t -> StringSQL

-- | Get SQL string from typed object.
showExpr :: Expr p t -> String
instance Show (Expr p a)


-- | This module defines type classes and templates for scalar queries.
module Database.Relational.Query.Scalar

-- | Constraint which represents scalar degree.
class PersistableWidth ct => ScalarDegree ct

-- | <a>ScalarDegree</a> instance templates.
defineScalarDegree :: TypeQ -> Q [Dec]
instance ScalarDegree ct => ScalarDegree (Maybe ct)


-- | This module defines query context tag types.
module Database.Relational.Query.Context

-- | Type tag for flat (not-aggregated) query
data Flat

-- | Type tag for aggregated query
data Aggregated

-- | Type tag for exists predicate
data Exists

-- | Type tag for window function building
data OverWindow

-- | Type tag for normal aggregatings set
data Set

-- | Type tag for aggregatings GROUPING SETS
data SetList

-- | Type tag for aggregatings power set
data Power


-- | This module defines interfaces between haskell pure values and query
--   internal projection values.
module Database.Relational.Query.Pure

-- | Specify tuple like record constructors which are allowed to define
--   <tt>ProjectableFunctor</tt>.
class ProductConstructor r
productConstructor :: ProductConstructor r => r

-- | Interface for constant SQL term list.
class ShowConstantTermsSQL a
showConstantTermsSQL' :: ShowConstantTermsSQL a => a -> [StringSQL]

-- | String interface of <a>showConstantTermsSQL'</a>.
showConstantTermsSQL :: ShowConstantTermsSQL a => a -> [String]
instance (ShowConstantTermsSQL a, ShowConstantTermsSQL b) => ShowConstantTermsSQL (a, b)
instance (PersistableWidth a, ShowConstantTermsSQL a) => ShowConstantTermsSQL (Maybe a)
instance ShowConstantTermsSQL LocalTime
instance ShowConstantTermsSQL TimeOfDay
instance ShowConstantTermsSQL Day
instance ShowConstantTermsSQL Double
instance ShowConstantTermsSQL Float
instance ShowConstantTermsSQL Bool
instance ShowConstantTermsSQL Char
instance ShowConstantTermsSQL Text
instance ShowConstantTermsSQL Text
instance ShowConstantTermsSQL ByteString
instance ShowConstantTermsSQL ByteString
instance ShowConstantTermsSQL String
instance ShowConstantTermsSQL Int
instance ShowConstantTermsSQL Int64
instance ShowConstantTermsSQL Int32
instance ShowConstantTermsSQL Int16
instance ProductConstructor (a -> b -> (a, b))


-- | This module defines phantom typed SQL expression object. Contains
--   normal interfaces.
module Database.Relational.Query.Expr

-- | Phantom typed SQL expression object. Project from projection type
--   <tt>p</tt>.
data Expr p a

-- | Typed constant SQL expression from Haskell value.
valueExpr :: ShowConstantTermsSQL ft => ft -> Expr p ft

-- | Convert phantom type into <a>Maybe</a>.
just :: Expr p ft -> Expr p (Maybe ft)

-- | Allowed only for having or where <a>Expr</a>. So NULL expression
--   result will be possible. Behavior around boolean is strongly dependent
--   on RDBMS impelemetations.
fromJust :: Expr p (Maybe ft) -> Expr p ft

-- | AND operator for <a>Expr</a>.
exprAnd :: Expr p Bool -> Expr p Bool -> Expr p Bool


-- | This module provides untyped components for query.
module Database.Relational.Query.Component

-- | Column SQL string type
type ColumnSQL = ColumnSQL' StringSQL

-- | <a>ColumnSQL</a> from string
columnSQL :: String -> ColumnSQL

-- | <a>ColumnSQL</a> from <a>StringSQL</a>
columnSQL' :: StringSQL -> ColumnSQL

-- | StringSQL from ColumnSQL
showsColumnSQL :: ColumnSQL -> StringSQL

-- | Configuration type.
data Config

-- | Default configuration.
defaultConfig :: Config

-- | Unit of product is supported or not.
data ProductUnitSupport
PUSupported :: ProductUnitSupport
PUNotSupported :: ProductUnitSupport

-- | Result record duplication attribute
data Duplication
All :: Duplication
Distinct :: Duplication

-- | Compose duplication attribute string.
showsDuplication :: Duplication -> StringSQL

-- | Type for restriction of query.
type QueryRestriction c = [Expr c Bool]

-- | Compose WHERE clause from <a>QueryRestriction</a>.
composeWhere :: QueryRestriction Flat -> StringSQL

-- | Compose HAVING clause from <a>QueryRestriction</a>.
composeHaving :: QueryRestriction Aggregated -> StringSQL

-- | Type for group-by term
type AggregateColumnRef = ColumnSQL

-- | Type for group key.
data AggregateBitKey

-- | Type for grouping set
data AggregateSet

-- | Type for group-by tree
data AggregateElem

-- | Single term aggregation element.
aggregateColumnRef :: AggregateColumnRef -> AggregateElem

-- | Empty aggregation.
aggregateEmpty :: [AggregateElem]

-- | Key of aggregation power set.
aggregatePowerKey :: [AggregateColumnRef] -> AggregateBitKey

-- | Single grouping set.
aggregateGroupingSet :: [AggregateElem] -> AggregateSet

-- | Rollup aggregation element.
aggregateRollup :: [AggregateBitKey] -> AggregateElem

-- | Cube aggregation element.
aggregateCube :: [AggregateBitKey] -> AggregateElem

-- | Grouping sets aggregation.
aggregateSets :: [AggregateSet] -> AggregateElem

-- | Compose GROUP BY clause from AggregateElem list.
composeGroupBy :: [AggregateElem] -> StringSQL

-- | Compose PARTITION BY clause from AggregateColumnRef list.
composePartitionBy :: [AggregateColumnRef] -> StringSQL

-- | Order direction. Ascendant or Descendant.
data Order
Asc :: Order
Desc :: Order

-- | Type for order-by column
type OrderColumn = ColumnSQL

-- | Type for order-by term
type OrderingTerm = (Order, OrderColumn)

-- | Type for order-by terms
type OrderingTerms = [OrderingTerm]

-- | Compose ORDER BY clause from OrderingTerms
composeOrderBy :: OrderingTerms -> StringSQL

-- | Column SQL String
type AssignColumn = ColumnSQL

-- | Value SQL String
type AssignTerm = ColumnSQL

-- | Assignment pair
type Assignment = (AssignColumn, AssignTerm)

-- | Assignment pair list.
type Assignments = [Assignment]

-- | Compose SET clause from <a>Assignments</a>.
composeSets :: Assignments -> StringSQL

-- | Compose <i>OVER (PARTITION BY ... )</i> clause.
composeOver :: [AggregateColumnRef] -> OrderingTerms -> StringSQL
instance Show ProductUnitSupport
instance Show Config
instance Show Duplication
instance Show AggregateBitKey
instance Show AggregateElem
instance Show AggregateSet
instance Show Order
instance Show ColumnSQL
instance Functor ColumnSQL'


-- | This module defines monad transformer which requires query generate
--   configuration.
module Database.Relational.Query.Monad.Trans.Config

-- | <a>ReaderT</a> type to require query generate configuration.
data QueryConfig m a

-- | Lift to <a>QueryConfig</a>.
queryConfig :: Monad m => m a -> QueryConfig m a

-- | Run <a>QueryConfig</a> to expand with configuration
runQueryConfig :: QueryConfig m a -> Config -> m a

-- | Read configuration.
askQueryConfig :: Monad m => QueryConfig m Config
instance Monad m => Monad (QueryConfig m)
instance Functor m => Functor (QueryConfig m)
instance Applicative m => Applicative (QueryConfig m)


-- | This module defines typed projection path objects. Contains internal
--   structure and unsafe interfaces.
module Database.Relational.Query.Pi.Unsafe

-- | Projection path from type <tt>r0</tt> into type <tt>r1</tt>. This type
--   also indicate key object which type is <tt>r1</tt> for record type
--   <tt>r0</tt>.
data Pi r0 r1

-- | Projectable fmap of <a>Pi</a> type.
pfmap :: ProductConstructor (a -> b) => (a -> b) -> Pi r a -> Pi r b

-- | Projectable ap of <a>Pi</a> type.
pap :: Pi r (a -> b) -> Pi r a -> Pi r b

-- | Get record width.
width :: Pi r a -> Int

-- | Compose projection path.
(<.>) :: Pi a b -> Pi b c -> Pi a c

-- | Compose projection path. <a>Maybe</a> phantom functor is
--   <a>map</a>-ed.
(<?.>) :: Pi a (Maybe b) -> Pi b c -> Pi a (Maybe c)

-- | Compose projection path. <a>Maybe</a> phantom functors are
--   <tt>join</tt>-ed like <tt>&gt;=&gt;</tt>.
(<?.?>) :: Pi a (Maybe b) -> Pi b (Maybe c) -> Pi a (Maybe c)

-- | Unsafely project untyped value list.
pi :: [a] -> Pi r0 r1 -> [a]

-- | Unsafely define projection path from type <tt>r0</tt> into type
--   <tt>r1</tt>. Use inferred <a>PersistableRecordWidth</a>.
definePi :: PersistableWidth r1 => Int -> Pi r0 r1

-- | Unsafely define projection path from type <tt>r0</tt> into type
--   <tt>r1</tt>.
defineDirectPi' :: PersistableRecordWidth r1 -> [Int] -> Pi r0 r1

-- | Unsafely define projection path from type <tt>r0</tt> into type
--   <tt>r1</tt>. Use inferred <a>PersistableRecordWidth</a>.
defineDirectPi :: PersistableWidth r1 => [Int] -> Pi r0 r1

-- | Unsafely untype key to expand indexes.
unsafeExpandIndexes :: Pi a b -> [Int]


-- | This module defines typed projection path objects. Contains normal
--   interfaces.
module Database.Relational.Query.Pi

-- | Projection path from type <tt>r0</tt> into type <tt>r1</tt>. This type
--   also indicate key object which type is <tt>r1</tt> for record type
--   <tt>r0</tt>.
data Pi r0 r1

-- | Projectable fmap of <a>Pi</a> type.
pfmap :: ProductConstructor (a -> b) => (a -> b) -> Pi r a -> Pi r b

-- | Projectable ap of <a>Pi</a> type.
pap :: Pi r (a -> b) -> Pi r a -> Pi r b

-- | Compose projection path.
(<.>) :: Pi a b -> Pi b c -> Pi a c

-- | Compose projection path. <a>Maybe</a> phantom functor is
--   <a>map</a>-ed.
(<?.>) :: Pi a (Maybe b) -> Pi b c -> Pi a (Maybe c)

-- | Compose projection path. <a>Maybe</a> phantom functors are
--   <tt>join</tt>-ed like <tt>&gt;=&gt;</tt>.
(<?.?>) :: Pi a (Maybe b) -> Pi b (Maybe c) -> Pi a (Maybe c)

-- | Identity projection path.
id' :: PersistableWidth a => Pi a a

-- | Projection path for fst of tuple.
fst' :: PersistableWidth a => Pi (a, b) a

-- | Projection path for snd of tuple.
snd' :: (PersistableWidth a, PersistableWidth b) => Pi (a, b) b


-- | This module provides proof object definitions of constraint key.
--   Difference between this module and
--   <a>Database.Record.KeyConstraint</a> is typed constraint key column
--   definition is included in this module.
module Database.Relational.Query.Constraint

-- | Constraint Key proof object. Constraint type <tt>c</tt>, record type
--   <tt>r</tt> and columns type <tt>ct</tt>.
data Key c r ct

-- | Index of key which specifies constraint key.
indexes :: Key c r ct -> [Int]

-- | Unsafely generate constraint <a>Key</a> proof object using specified
--   key index.
unsafeDefineConstraintKey :: PersistableWidth ct => [Int] -> Key c r ct

-- | Get table constraint <a>KeyConstraint</a> proof object from constraint
--   <a>Key</a>.
tableConstraint :: Key c r ct -> KeyConstraint c r

-- | Get projection path proof object from constraint <a>Key</a>.
projectionKey :: Key c r ct -> Pi r ct

-- | Derive <a>Unique</a> constraint <a>Key</a> from <a>Primary</a>
--   constraint <a>Key</a>
uniqueKey :: PersistableWidth ct => Key Primary r ct -> Key Unique r ct

-- | Constraint <a>Key</a> inference interface.
class PersistableWidth ct => HasConstraintKey c r ct
constraintKey :: HasConstraintKey c r ct => Key c r ct

-- | Infered <a>Unique</a> constraint <a>Key</a>. Record type <tt>r</tt>
--   has unique key which type is <tt>ct</tt> derived from primay key.
derivedUniqueKey :: HasConstraintKey Primary r ct => Key Unique r ct

-- | Constraint type. Primary key.
data Primary :: *

-- | Constraint type. Unique key.
data Unique :: *

-- | Constraint type. Not-null key.
data NotNull :: *


-- | This module defines table type which has table metadatas.
module Database.Relational.Query.Table

-- | Untyped typed table type
data Untyped

-- | Name string of table in SQL
name' :: Untyped -> String

-- | Width of table
width' :: Untyped -> Int

-- | Column name strings in SQL
columns' :: Untyped -> [ColumnSQL]

-- | Column name string in SQL specified by index
(!) :: Untyped -> Int -> ColumnSQL

-- | Phantom typed table type
data Table r

-- | Untype table.
unType :: Table t -> Untyped

-- | Name string of table in SQL
name :: Table r -> String

-- | Not qualified name string of table in SQL
shortName :: Table r -> String

-- | Width of table
width :: Table r -> Int

-- | Column name strings in SQL
columns :: Table r -> [ColumnSQL]

-- | Column name string in SQL specified by index
index :: Table r -> Int -> ColumnSQL

-- | Unsafely generate phantom typed table type.
table :: String -> [String] -> Table r

-- | Cast phantom type into <a>Maybe</a> type.
toMaybe :: Table r -> Table (Maybe r)

-- | Inference rule of <a>Table</a> existence.
class PersistableWidth r => TableDerivable r
derivedTable :: TableDerivable r => Table r
instance Show Untyped


-- | This module defines sub-query structure used in query products.
module Database.Relational.Query.Sub

-- | Sub-query type
data SubQuery

-- | <a>SubQuery</a> from <a>Table</a>.
fromTable :: Table r -> SubQuery

-- | Unsafely generate flat <a>SubQuery</a> from untyped components.
flatSubQuery :: Config -> UntypedProjection -> Duplication -> JoinProduct -> QueryRestriction Flat -> OrderingTerms -> SubQuery

-- | Unsafely generate aggregated <a>SubQuery</a> from untyped components.
aggregatedSubQuery :: Config -> UntypedProjection -> Duplication -> JoinProduct -> QueryRestriction Flat -> [AggregateElem] -> QueryRestriction Aggregated -> OrderingTerms -> SubQuery

-- | Union binary operator on <a>SubQuery</a>
union :: Duplication -> SubQuery -> SubQuery -> SubQuery

-- | Except binary operator on <a>SubQuery</a>
except :: Duplication -> SubQuery -> SubQuery -> SubQuery

-- | Intersect binary operator on <a>SubQuery</a>
intersect :: Duplication -> SubQuery -> SubQuery -> SubQuery

-- | SQL StringSQL for toplevel-SQL.
showSQL :: SubQuery -> StringSQL

-- | SQL string for toplevel-SQL.
toSQL :: SubQuery -> String

-- | SQL string for nested-qeury.
unitSQL :: SubQuery -> String

-- | Width of <a>SubQuery</a>.
width :: SubQuery -> Int

-- | Qualifier type.
newtype Qualifier
Qualifier :: Int -> Qualifier

-- | Qualified query.
data Qualified a

-- | Get qualifier
qualifier :: Qualified a -> Qualifier

-- | Unqualify.
unQualify :: Qualified a -> a

-- | Add qualifier
qualify :: a -> Qualifier -> Qualified a

-- | Width of <a>Qualified</a> <tt>SubQUery</tt>.
queryWidth :: Qualified SubQuery -> Int

-- | Get column SQL string of <a>SubQuery</a>.
column :: Qualified SubQuery -> Int -> ColumnSQL

-- | Projection structure unit
data ProjectionUnit

-- | Untyped projection. Forgot record type.
type UntypedProjection = [ProjectionUnit]

-- | Make untyped projection from columns.
untypedProjectionFromColumns :: [ColumnSQL] -> UntypedProjection

-- | Make untyped projection from joined sub-query.
untypedProjectionFromJoinedSubQuery :: Qualified SubQuery -> UntypedProjection

-- | Make untyped projection from scalar sub-query.
untypedProjectionFromScalarSubQuery :: SubQuery -> UntypedProjection

-- | Width of <a>UntypedProjection</a>.
widthOfUntypedProjection :: UntypedProjection -> Int

-- | Get column SQL string list of projection.
columnsOfUntypedProjection :: UntypedProjection -> [ColumnSQL]

-- | Product tree specialized by <a>SubQuery</a>.
type QueryProduct = ProductTree (Qualified SubQuery)

-- | Product node specialized by <a>SubQuery</a>.
type QueryProductNode = Node (Qualified SubQuery)

-- | Type for join product of query.
type JoinProduct = Maybe QueryProduct
instance Show SetOp
instance Show BinOp
instance Show Qualifier
instance Show a => Show (Qualified a)
instance Show SubQuery
instance Show ProjectionUnit
instance Functor Qualified


-- | This module defines query projection type structure and interfaces.
module Database.Relational.Query.Projection

-- | Phantom typed projection. Projected into Haskell record type
--   <tt>t</tt>.
data Projection c t

-- | Width of <a>Projection</a>.
width :: Projection c r -> Int

-- | Get column SQL string list of projection.
columns :: Projection c r -> [ColumnSQL]

-- | Unsafely get untyped projection.
untype :: Projection c r -> UntypedProjection

-- | Unsafely generate <a>Projection</a> from SQL expression strings.
unsafeFromSqlTerms :: [StringSQL] -> Projection c t

-- | Unsafely generate <a>Projection</a> from qualified (joined) sub-query.
unsafeFromQualifiedSubQuery :: Qualified SubQuery -> Projection c t

-- | Unsafely generate <a>Projection</a> from scalar sub-query.
unsafeFromScalarSubQuery :: SubQuery -> Projection c t

-- | Unsafely generate unqualified <a>Projection</a> from <a>Table</a>.
unsafeFromTable :: Table r -> Projection c r

-- | Lift <a>Expr</a> to <a>Projection</a> to use as restrict predicate.
predicateProjectionFromExpr :: Expr c (Maybe Bool) -> Projection c (Maybe Bool)

-- | Unsafely get SQL term from <tt>Proejction</tt>.
unsafeStringSql :: Projection c r -> StringSQL

-- | Trace projection path to get narrower <a>Projection</a>.
pi :: Projection c a -> Pi a b -> Projection c b

-- | Trace projection path to get narrower <a>Projection</a>. From
--   <a>Maybe</a> type to <a>Maybe</a> type.
piMaybe :: Projection c (Maybe a) -> Pi a b -> Projection c (Maybe b)

-- | Trace projection path to get narrower <a>Projection</a>. From
--   <a>Maybe</a> type to <a>Maybe</a> type. Leaf type of projection path
--   is <a>Maybe</a>.
piMaybe' :: Projection c (Maybe a) -> Pi a (Maybe b) -> Projection c (Maybe b)

-- | Composite nested <a>Maybe</a> on projection phantom type.
flattenMaybe :: Projection c (Maybe (Maybe a)) -> Projection c (Maybe a)

-- | Cast into <a>Maybe</a> on projection phantom type.
just :: Projection c r -> Projection c (Maybe r)

-- | Unsafely lift to aggregated context.
unsafeToAggregated :: Projection Flat r -> Projection Aggregated r

-- | Unsafely down to flat context.
unsafeToFlat :: Projection Aggregated r -> Projection Flat r

-- | Unsafely cast context type tag.
unsafeChangeContext :: Projection c r -> Projection c' r

-- | Unsafely get SQL string expression of not null key projection.
unsafeStringSqlNotNullMaybe :: HasColumnConstraint NotNull r => Projection c (Maybe r) -> StringSQL

-- | Projectable fmap of <a>Projection</a> type.
pfmap :: ProductConstructor (a -> b) => (a -> b) -> Projection c a -> Projection c b

-- | Projectable ap of <a>Projection</a> type.
pap :: Projection c (a -> b) -> Projection c a -> Projection c b

-- | Projection type for row list.
data ListProjection p t

-- | Make row list projection from <a>Projection</a> list.
list :: [p t] -> ListProjection p t

-- | Make row list projection from <a>SubQuery</a>.
unsafeListFromSubQuery :: SubQuery -> ListProjection p t

-- | Map projection show operatoions and concatinate to single SQL
--   expression.
unsafeStringSqlList :: (p t -> StringSQL) -> ListProjection p t -> StringSQL


-- | This module defines functions to generate simple SQL strings.
module Database.Relational.Query.SQL

-- | Type for query suffix words
type QuerySuffix = [Keyword]

-- | Expand query suffix words
showsQuerySuffix :: QuerySuffix -> StringSQL

-- | Generate prefix string of update SQL.
updatePrefixSQL :: Table r -> StringSQL

-- | Generate update SQL by specified key and table. Columns name list of
--   table are also required.
updateSQL' :: String -> [ColumnSQL] -> [ColumnSQL] -> String

-- | Generate update SQL by specified key and table. Columns name list of
--   table are also required.
updateOtherThanKeySQL' :: String -> [ColumnSQL] -> [Int] -> String

-- | Generate update SQL specified by single key.
updateOtherThanKeySQL :: Table r -> Pi r p -> String

-- | Generate prefix string of insert SQL.
insertPrefixSQL :: Pi r r' -> Table r -> StringSQL

-- | Generate insert SQL.
insertSQL :: Pi r r' -> Table r -> String

-- | Generate size measured records chunk insert SQL.
insertSizedChunkSQL :: Pi r r' -> Table r -> Int -> (String, Int)

-- | Generate all column delete SQL by specified table. Untyped table
--   version.
deletePrefixSQL' :: String -> StringSQL

-- | Generate all column delete SQL by specified table.
deletePrefixSQL :: Table r -> StringSQL


-- | This module defines operators on various polymorphic projections.
module Database.Relational.Query.Projectable

-- | Project from Projection type into expression type.
expr :: Projection p a -> Expr p a

-- | Interface to project SQL terms unsafely.
class SqlProjectable p
unsafeProjectSqlTerms' :: SqlProjectable p => [StringSQL] -> p t

-- | Unsafely Project single SQL term.
unsafeProjectSql' :: SqlProjectable p => StringSQL -> p t

-- | Unsafely project from SQL strings. String interface of
--   <a>unsafeProjectSqlTerms'</a>.
unsafeProjectSqlTerms :: SqlProjectable p => [String] -> p t

-- | Unsafely Project single SQL string. String interface of
--   <a>unsafeProjectSql'</a>.
unsafeProjectSql :: SqlProjectable p => String -> p t

-- | Generate polymorphic projection of SQL constant values from Haskell
--   value.
value :: (ShowConstantTermsSQL t, OperatorProjectable p) => t -> p t

-- | Polymorphic proejction of SQL true value.
valueTrue :: (OperatorProjectable p, ProjectableMaybe p) => p (Maybe Bool)

-- | Polymorphic proejction of SQL false value.
valueFalse :: (OperatorProjectable p, ProjectableMaybe p) => p (Maybe Bool)

-- | Polymorphic proejction of SQL set value from Haskell list.
values :: (ShowConstantTermsSQL t, OperatorProjectable p) => [t] -> ListProjection p t

-- | Polymorphic projection of SQL null value.
unsafeValueNull :: OperatorProjectable p => p (Maybe a)

-- | Placeholder parameter type which has real parameter type arguemnt
--   <tt>p</tt>.
data PlaceHolders p

-- | Unsafely add placeholder parameter to queries.
unsafeAddPlaceHolders :: Functor f => f a -> f (PlaceHolders p, a)

-- | Unsafely get placeholder parameter
unsafePlaceHolders :: PlaceHolders p

-- | Provide scoped placeholder and return its parameter object.
placeholder' :: (PersistableWidth t, SqlProjectable p) => (p t -> a) -> (PlaceHolders t, a)

-- | Provide scoped placeholder and return its parameter object. Monadic
--   version.
placeholder :: (PersistableWidth t, SqlProjectable p, Monad m) => (p t -> m a) -> m (PlaceHolders t, a)

-- | No placeholder semantics
unitPlaceHolder :: PlaceHolders ()

-- | Interface to get SQL term from projections.
class ProjectableShowSql p
unsafeShowSql' :: ProjectableShowSql p => p a -> StringSQL

-- | Unsafely generate SQL expression string from projection object. String
--   interface of <a>unsafeShowSql'</a>.
unsafeShowSql :: ProjectableShowSql p => p a -> String

-- | Binary operator type for SQL String.
type SqlBinOp = Keyword -> Keyword -> Keyword

-- | Unsafely make projection binary operator from string binary operator.
unsafeBinOp :: (SqlProjectable p, ProjectableShowSql p) => SqlBinOp -> p a -> p b -> p c

-- | Unsafely make projection unary operator from SQL keyword.
unsafeUniOp :: (ProjectableShowSql p0, SqlProjectable p1) => (Keyword -> Keyword) -> p0 a -> p1 b

-- | Compare operator corresponding SQL <i>=</i> .
(.=.) :: (OperatorProjectable p, ProjectableShowSql p) => p ft -> p ft -> p (Maybe Bool)

-- | Compare operator corresponding SQL <i>&lt;</i> .
(.<.) :: (OperatorProjectable p, ProjectableShowSql p) => p ft -> p ft -> p (Maybe Bool)

-- | Compare operator corresponding SQL <i>&lt;=</i> .
(.<=.) :: (OperatorProjectable p, ProjectableShowSql p) => p ft -> p ft -> p (Maybe Bool)

-- | Compare operator corresponding SQL <i>&gt;</i> .
(.>.) :: (OperatorProjectable p, ProjectableShowSql p) => p ft -> p ft -> p (Maybe Bool)

-- | Compare operator corresponding SQL <i>&gt;=</i> .
(.>=.) :: (OperatorProjectable p, ProjectableShowSql p) => p ft -> p ft -> p (Maybe Bool)

-- | Compare operator corresponding SQL <i>&lt;&gt;</i> .
(.<>.) :: (OperatorProjectable p, ProjectableShowSql p) => p ft -> p ft -> p (Maybe Bool)

-- | Same as <a>caseSearch</a>, but you can write like <a>list</a>
--   <a>casesOrElse</a> <a>clause</a>.
casesOrElse :: (OperatorProjectable p, ProjectableShowSql p) => [(p (Maybe Bool), p a)] -> p a -> p a

-- | Uncurry version of <a>case'</a>, and you can write like ...
--   <a>casesOrElse'</a> <a>clause</a>.
casesOrElse' :: (OperatorProjectable p, ProjectableShowSql p) => (p a, [(p a, p b)]) -> p b -> p b

-- | Search case operator correnponding SQL search <i>CASE</i>. Like,
--   <i>CASE WHEN p0 THEN a WHEN p1 THEN b ... ELSE c END</i>
caseSearch :: (OperatorProjectable p, ProjectableShowSql p) => [(p (Maybe Bool), p a)] -> p a -> p a

-- | Null default version of <a>caseSearch</a>.
caseSearchMaybe :: (OperatorProjectable p, ProjectableShowSql p) => [(p (Maybe Bool), p (Maybe a))] -> p (Maybe a)

-- | Simple case operator correnponding SQL simple <i>CASE</i>. Like,
--   <i>CASE x WHEN v THEN a WHEN w THEN b ... ELSE c END</i>
case' :: (OperatorProjectable p, ProjectableShowSql p) => p a -> [(p a, p b)] -> p b -> p b

-- | Null default version of <a>case'</a>.
caseMaybe :: (OperatorProjectable p, ProjectableShowSql p, ProjectableMaybe p) => p a -> [(p a, p (Maybe b))] -> p (Maybe b)

-- | Binary operator corresponding SQL <i>IN</i> .
in' :: (OperatorProjectable p, ProjectableShowSql p) => p t -> ListProjection p t -> p (Maybe Bool)

-- | Logical operator corresponding SQL <i>AND</i> .
and' :: (OperatorProjectable p, ProjectableShowSql p) => p ft -> p ft -> p (Maybe Bool)

-- | Logical operator corresponding SQL <i>OR</i> .
or' :: (OperatorProjectable p, ProjectableShowSql p) => p ft -> p ft -> p (Maybe Bool)

-- | Operator corresponding SQL <i>IS NULL</i> , and extended against
--   record types.
isNothing :: (OperatorProjectable (Projection c), ProjectableShowSql (Projection c), HasColumnConstraint NotNull r) => Projection c (Maybe r) -> Projection c (Maybe Bool)

-- | Operator corresponding SQL <i>NOT (... IS NULL)</i> , and extended
--   against record type.
isJust :: (OperatorProjectable (Projection c), ProjectableShowSql (Projection c), HasColumnConstraint NotNull r) => Projection c (Maybe r) -> Projection c (Maybe Bool)

-- | Operator from maybe type using record extended <tt>isNull</tt>.
fromMaybe :: (OperatorProjectable (Projection c), ProjectableShowSql (Projection c), HasColumnConstraint NotNull r) => Projection c r -> Projection c (Maybe r) -> Projection c r

-- | Logical operator corresponding SQL <i>NOT</i> .
not' :: (OperatorProjectable p, ProjectableShowSql p) => p (Maybe Bool) -> p (Maybe Bool)

-- | Logical operator corresponding SQL <i>EXISTS</i> .
exists :: (OperatorProjectable p, ProjectableShowSql p) => ListProjection (Projection Exists) r -> p (Maybe Bool)

-- | Concatinate operator corresponding SQL <i>||</i> .
(.||.) :: (OperatorProjectable p, ProjectableShowSql p, IsString a) => p a -> p a -> p a

-- | Concatinate operator corresponding SQL <i>||</i> . Maybe type version.
(?||?) :: (OperatorProjectable p, ProjectableShowSql p, IsString a) => p (Maybe a) -> p (Maybe a) -> p (Maybe a)

-- | String-compare operator corresponding SQL <i>LIKE</i> .
like :: (OperatorProjectable p, ProjectableShowSql p, IsString a, ShowConstantTermsSQL a) => p a -> a -> p (Maybe Bool)

-- | String-compare operator corresponding SQL <i>LIKE</i> . Maybe type
--   version.
likeMaybe :: (OperatorProjectable p, ProjectableShowSql p, IsString a, ShowConstantTermsSQL a) => p (Maybe a) -> a -> p (Maybe Bool)

-- | String-compare operator corresponding SQL <i>LIKE</i> .
like' :: (OperatorProjectable p, ProjectableShowSql p, IsString a) => p a -> p a -> p (Maybe Bool)

-- | String-compare operator corresponding SQL <i>LIKE</i> .
likeMaybe' :: (OperatorProjectable p, ProjectableShowSql p, IsString a) => p (Maybe a) -> p (Maybe a) -> p (Maybe Bool)

-- | Number operator corresponding SQL <i>+</i> .
(.+.) :: (OperatorProjectable p, ProjectableShowSql p, Num a) => p a -> p a -> p a

-- | Number operator corresponding SQL <i>-</i> .
(.-.) :: (OperatorProjectable p, ProjectableShowSql p, Num a) => p a -> p a -> p a

-- | Number operator corresponding SQL /// .
(./.) :: (OperatorProjectable p, ProjectableShowSql p, Num a) => p a -> p a -> p a

-- | Number operator corresponding SQL <i>*</i> .
(.*.) :: (OperatorProjectable p, ProjectableShowSql p, Num a) => p a -> p a -> p a

-- | Number negate uni-operator corresponding SQL <i>-</i>.
negate' :: (OperatorProjectable p, ProjectableShowSql p, Num a) => p a -> p a

-- | Number fromIntegral uni-operator.
fromIntegral' :: (SqlProjectable p, ProjectableShowSql p, Integral a, Num b) => p a -> p b

-- | Unsafely show number into string-like type in projections.
showNum :: (SqlProjectable p, ProjectableShowSql p, Num a, IsString b) => p a -> p b

-- | Number operator corresponding SQL <i>+</i> .
(?+?) :: (OperatorProjectable p, ProjectableShowSql p, Num a) => p (Maybe a) -> p (Maybe a) -> p (Maybe a)

-- | Number operator corresponding SQL <i>-</i> .
(?-?) :: (OperatorProjectable p, ProjectableShowSql p, Num a) => p (Maybe a) -> p (Maybe a) -> p (Maybe a)

-- | Number operator corresponding SQL /// .
(?/?) :: (OperatorProjectable p, ProjectableShowSql p, Num a) => p (Maybe a) -> p (Maybe a) -> p (Maybe a)

-- | Number operator corresponding SQL <i>*</i> .
(?*?) :: (OperatorProjectable p, ProjectableShowSql p, Num a) => p (Maybe a) -> p (Maybe a) -> p (Maybe a)

-- | Number negate uni-operator corresponding SQL <i>-</i>.
negateMaybe :: (OperatorProjectable p, ProjectableShowSql p, Num a) => p (Maybe a) -> p (Maybe a)

-- | Number fromIntegral uni-operator.
fromIntegralMaybe :: (SqlProjectable p, ProjectableShowSql p, Integral a, Num b) => p (Maybe a) -> p (Maybe b)

-- | Unsafely show number into string-like type in projections.
showNumMaybe :: (SqlProjectable p, ProjectableShowSql p, Num a, IsString b) => p (Maybe a) -> p (Maybe b)

-- | <i>RANK()</i> term.
rank :: Integral a => Projection OverWindow a

-- | <i>DENSE_RANK()</i> term.
denseRank :: Integral a => Projection OverWindow a

-- | <i>ROW_NUMBER()</i> term.
rowNumber :: Integral a => Projection OverWindow a

-- | <i>PERCENT_RANK()</i> term.
percentRank :: Projection OverWindow Double

-- | <i>CUME_DIST()</i> term.
cumeDist :: Projection OverWindow Double

-- | Zipping projections.
projectZip :: ProjectableApplicative p => p a -> p b -> p (a, b)

-- | Binary operator the same as <a>projectZip</a>.
(><) :: ProjectableApplicative p => p a -> p b -> p (a, b)

-- | Zipping except for identity element laws.
class ProjectableApplicative p => ProjectableIdZip p
leftId :: ProjectableIdZip p => p ((), a) -> p a
rightId :: ProjectableIdZip p => p (a, ()) -> p a

-- | Interface to control <a>Maybe</a> of phantom type in projections.
class ProjectableMaybe p
just :: ProjectableMaybe p => p a -> p (Maybe a)
flattenMaybe :: ProjectableMaybe p => p (Maybe (Maybe a)) -> p (Maybe a)

-- | Weaken functor on projections.
class ProjectableFunctor p
(|$|) :: (ProjectableFunctor p, ProductConstructor (a -> b)) => (a -> b) -> p a -> p b

-- | Weaken applicative functor on projections.
class ProjectableFunctor p => ProjectableApplicative p
(|*|) :: ProjectableApplicative p => p (a -> b) -> p a -> p b

-- | Same as <a>|$|</a> other than using inferred record constructor.
ipfmap :: (ProjectableFunctor p, ProductConstructor (a -> b)) => p a -> p b
instance ProjectableApplicative (Pi a)
instance ProjectableFunctor (Pi a)
instance ProjectableApplicative (Projection c)
instance ProjectableFunctor (Projection c)
instance ProjectableApplicative PlaceHolders
instance ProjectableFunctor PlaceHolders
instance ProjectableIdZip PlaceHolders
instance ProjectableMaybe (Expr p)
instance ProjectableMaybe (Projection c)
instance ProjectableMaybe PlaceHolders
instance ProjectableShowSql (Projection c)
instance ProjectableShowSql (Expr p)
instance OperatorProjectable (Expr Aggregated)
instance OperatorProjectable (Expr Flat)
instance OperatorProjectable (Projection Aggregated)
instance OperatorProjectable (Projection Flat)
instance SqlProjectable (Expr p)
instance SqlProjectable (Projection OverWindow)
instance SqlProjectable (Projection Aggregated)
instance SqlProjectable (Projection Flat)


-- | This module defines operators on various polymorphic projections which
--   needs extended GHC features.
module Database.Relational.Query.ProjectableExtended

-- | Interface to compose phantom <a>Maybe</a> nested type.
class ProjectableFlattenMaybe a b
flatten :: (ProjectableFlattenMaybe a b, ProjectableMaybe p) => p a -> p b

-- | Get narrower projection with flatten leaf phantom Maybe types along
--   with projection path.
flattenPiMaybe :: (ProjectableMaybe (Projection cont), ProjectableFlattenMaybe (Maybe b) c) => Projection cont (Maybe a) -> Pi a b -> Projection cont c

-- | Get narrower projection along with projection path and project into
--   result projection type.
(!) :: Projectable Projection p => Projection c a -> Pi a b -> p c b

-- | Get narrower projection along with projection path and project into
--   result projection type. <a>Maybe</a> phantom functor is <a>map</a>-ed.
(?!) :: Projectable Projection p => Projection c (Maybe a) -> Pi a b -> p c (Maybe b)

-- | Get narrower projection along with projection path and project into
--   result projection type. Source record <a>Maybe</a> phantom functor and
--   projection path leaf <a>Maybe</a> functor are <tt>join</tt>-ed.
(?!?) :: Projectable Projection p => Projection c (Maybe a) -> Pi a (Maybe b) -> p c (Maybe b)

-- | Get narrower projection with flatten leaf phantom Maybe types along
--   with projection path and project into result projection type.
(!??) :: (ProjectableFlattenMaybe (Maybe b) c, Projectable Projection p, ProjectableMaybe (p cont)) => Projection cont (Maybe a) -> Pi a b -> p cont c

-- | Get narrower projected expression along with projectino path and strip
--   <a>Maybe</a> phantom type off.
(.!) :: Projection c (Maybe a) -> Pi a b -> Expr c b

-- | Get narrower projected expression along with projectino path and strip
--   <a>Maybe</a> phantom type off. Projection path leaf is <a>Maybe</a>
--   case.
(.?) :: Projection c (Maybe a) -> Pi a (Maybe b) -> Expr c b

-- | Unsafely make aggregation uni-operator from SQL keyword.
unsafeAggregateOp :: (AggregatedContext ac, SqlProjectable (p ac)) => Keyword -> Projection Flat a -> p ac b

-- | Aggregation function COUNT.
count :: (Integral b, AggregatedContext ac, SqlProjectable (p ac)) => Projection Flat a -> p ac b

-- | Aggregation function SUM.
sum' :: (Num a, AggregatedContext ac, SqlProjectable (p ac)) => Projection Flat a -> p ac (Maybe a)

-- | Aggregation function SUM.
sumMaybe :: (Num a, AggregatedContext ac, SqlProjectable (p ac)) => Projection Flat (Maybe a) -> p ac (Maybe a)

-- | Aggregation function AVG.
avg :: (Num a, Fractional b, AggregatedContext ac, SqlProjectable (p ac)) => Projection Flat a -> p ac (Maybe b)

-- | Aggregation function AVG.
avgMaybe :: (Num a, Fractional b, AggregatedContext ac, SqlProjectable (p ac)) => Projection Flat (Maybe a) -> p ac (Maybe b)

-- | Aggregation function MAX.
max' :: (Ord a, AggregatedContext ac, SqlProjectable (p ac)) => Projection Flat a -> p ac (Maybe a)

-- | Aggregation function MAX.
maxMaybe :: (Ord a, AggregatedContext ac, SqlProjectable (p ac)) => Projection Flat (Maybe a) -> p ac (Maybe a)

-- | Aggregation function MIN.
min' :: (Ord a, AggregatedContext ac, SqlProjectable (p ac)) => Projection Flat a -> p ac (Maybe a)

-- | Aggregation function MIN.
minMaybe :: (Ord a, AggregatedContext ac, SqlProjectable (p ac)) => Projection Flat (Maybe a) -> p ac (Maybe a)

-- | Aggregation function EVERY.
every :: (AggregatedContext ac, SqlProjectable (p ac)) => Projection Flat (Maybe Bool) -> p ac (Maybe Bool)

-- | Aggregation function ANY.
any' :: (AggregatedContext ac, SqlProjectable (p ac)) => Projection Flat (Maybe Bool) -> p ac (Maybe Bool)

-- | Aggregation function SOME.
some' :: (AggregatedContext ac, SqlProjectable (p ac)) => Projection Flat (Maybe Bool) -> p ac (Maybe Bool)

-- | Zipping except for identity element laws.
class ProjectableApplicative p => ProjectableIdZip p
leftId :: ProjectableIdZip p => p ((), a) -> p a
rightId :: ProjectableIdZip p => p (a, ()) -> p a

-- | Interface to run recursively identity element laws.
class ProjectableRunIdsZip a b
runIds :: (ProjectableRunIdsZip a b, ProjectableIdZip p) => p a -> p b

-- | Specialize <a>runIds</a> for <a>PlaceHolders</a> type.
flattenPh :: ProjectableRunIdsZip a b => PlaceHolders a -> PlaceHolders b
instance ProjectableRunIdsZip a a
instance ProjectableRunIdsZip a b => ProjectableRunIdsZip (a, ()) b
instance ProjectableRunIdsZip a b => ProjectableRunIdsZip ((), a) b
instance ProjectableFlattenMaybe (Maybe a) (Maybe a)
instance ProjectableFlattenMaybe (Maybe a) b => ProjectableFlattenMaybe (Maybe (Maybe a)) b
instance Projectable Projection Expr
instance Projectable Projection Projection
instance AggregatedContext OverWindow
instance AggregatedContext Aggregated


-- | This module defines query building interface classes.
module Database.Relational.Query.Monad.Class

-- | Lift interface from base qualify monad.
class (Functor q, Monad q, Functor m, Monad m) => MonadQualify q m
liftQualify :: MonadQualify q m => q a -> m a

-- | Lift interface from base qualify monad. Another constraint to support
--   unique query.
class (Functor q, Monad q, MonadQuery m) => MonadQualifyUnique q m
liftQualifyUnique :: MonadQualifyUnique q m => q a -> m a

-- | Restrict context interface
class (Functor m, Monad m) => MonadRestrict c m
restrict :: MonadRestrict c m => Projection c (Maybe Bool) -> m ()

-- | Query building interface.
class (Functor m, Monad m) => MonadQuery m
setDuplication :: MonadQuery m => Duplication -> m ()
restrictJoin :: MonadQuery m => Projection Flat (Maybe Bool) -> m ()
unsafeSubQuery :: MonadQuery m => NodeAttr -> Qualified SubQuery -> m (Projection Flat r)

-- | Aggregated query building interface extends <a>MonadQuery</a>.
class MonadQuery m => MonadAggregate m
unsafeAddAggregateElement :: MonadAggregate m => AggregateElem -> m ()

-- | Window specification building interface.
class Monad m => MonadPartition m
unsafeAddPartitionKey :: MonadPartition m => AggregateColumnRef -> m ()

-- | Specify ALL attribute to query context.
all' :: MonadQuery m => m ()

-- | Specify DISTINCT attribute to query context.
distinct :: MonadQuery m => m ()

-- | Add restriction to last join.
onE :: MonadQuery m => Expr Flat (Maybe Bool) -> m ()

-- | Add restriction to last join. Projection type version.
on :: MonadQuery m => Projection Flat (Maybe Bool) -> m ()

-- | Add restriction to this query. Expr type version.
wheresE :: MonadRestrict Flat m => Expr Flat (Maybe Bool) -> m ()

-- | Add restriction to this not aggregated query.
wheres :: MonadRestrict Flat m => Projection Flat (Maybe Bool) -> m ()

-- | Add <i>GROUP BY</i> term into context and get aggregated projection.
groupBy :: MonadAggregate m => Projection Flat r -> m (Projection Aggregated r)

-- | Add restriction to this aggregated query. Expr type version.
havingE :: MonadRestrict Aggregated m => Expr Aggregated (Maybe Bool) -> m ()

-- | Add restriction to this aggregated query. Aggregated Projection type
--   version.
having :: MonadRestrict Aggregated m => Projection Aggregated (Maybe Bool) -> m ()


-- | This module defines monad transformer which lift from
--   <a>MonadQuery</a> into Aggregated query.
module Database.Relational.Query.Monad.Trans.Aggregating

-- | Type to accumulate aggregating context. Type <tt>ac</tt> is
--   aggregating-context type like aggregating key set building,
--   aggregating key sets set building and partition key set building. Type
--   <tt>at</tt> is aggregating term type.
data Aggregatings ac at m a

-- | Lift to <a>Aggregatings</a>.
aggregatings :: Monad m => m a -> Aggregatings ac at m a

-- | Context type building one grouping set.
type AggregatingSetT = Aggregatings Set AggregateElem

-- | Context type building grouping sets list.
type AggregatingSetListT = Aggregatings SetList AggregateSet

-- | Context type building power group set.
type AggregatingPowerSetT = Aggregatings Power AggregateBitKey

-- | Context type building partition keys set.
type PartitioningSetT c = Aggregatings c AggregateColumnRef

-- | Run <a>Aggregatings</a> to get terms list.
extractAggregateTerms :: (Monad m, Functor m) => Aggregatings ac at m a -> m (a, [at])

-- | Typeful aggregate element.
data AggregateKey a

-- | Add <i>GROUP BY</i> element into context and get aggregated
--   projection.
groupBy' :: MonadAggregate m => AggregateKey a -> m a

-- | Context monad type to build single grouping set.
type AggregatingSet = AggregatingSetT Identity

-- | Context monad type to build grouping power set.
type AggregatingPowerSet = AggregatingPowerSetT Identity

-- | Context monad type to build grouping set list.
type AggregatingSetList = AggregatingSetListT Identity

-- | Context monad type to build partition keys set.
type PartitioningSet c = PartitioningSetT c Identity

-- | Specify key of single grouping set from Projection.
key :: Projection Flat r -> AggregatingSet (Projection Aggregated (Maybe r))

-- | Specify key of single grouping set.
key' :: AggregateKey a -> AggregatingSet a

-- | Finalize and specify single grouping set.
set :: AggregatingSet a -> AggregatingSetList a

-- | Specify key of rollup and cube power set.
bkey :: Projection Flat r -> AggregatingPowerSet (Projection Aggregated (Maybe r))

-- | Finalize grouping power set as rollup power set.
rollup :: AggregatingPowerSet a -> AggregateKey a

-- | Finalize grouping power set as cube power set.
cube :: AggregatingPowerSet a -> AggregateKey a

-- | Finalize grouping set list.
groupingSets :: AggregatingSetList a -> AggregateKey a
instance MonadTrans (Aggregatings ac at)
instance Monad m => Monad (Aggregatings ac at m)
instance Functor m => Functor (Aggregatings ac at m)
instance Applicative m => Applicative (Aggregatings ac at m)
instance Monad m => MonadPartition (PartitioningSetT c m)
instance MonadQuery m => MonadAggregate (AggregatingSetT m)
instance MonadQuery m => MonadQuery (AggregatingSetT m)
instance MonadRestrict c m => MonadRestrict c (AggregatingSetT m)


-- | This module defines monad transformer which lift from query into query
--   with ordering.
module Database.Relational.Query.Monad.Trans.Ordering

-- | Type to accumulate ordering context. Type <tt>c</tt> is ordering term
--   projection context type.
data Orderings c m a

-- | Lift to <a>Orderings</a>.
orderings :: Monad m => m a -> Orderings c m a

-- | Type for order-by terms
type OrderingTerms = [OrderingTerm]

-- | Add ordering terms.
orderBy :: (Monad m, ProjectableOrdering (Projection c)) => Projection c t -> Order -> Orderings c m ()

-- | Add ascendant ordering term.
asc :: (Monad m, ProjectableOrdering (Projection c)) => Projection c t -> Orderings c m ()

-- | Add descendant ordering term.
desc :: (Monad m, ProjectableOrdering (Projection c)) => Projection c t -> Orderings c m ()

-- | Run <a>Orderings</a> to get <a>OrderingTerms</a>
extractOrderingTerms :: (Monad m, Functor m) => Orderings c m a -> m (a, OrderingTerms)
instance MonadTrans (Orderings c)
instance Monad m => Monad (Orderings c m)
instance Functor m => Functor (Orderings c m)
instance Applicative m => Applicative (Orderings c m)
instance ProjectableOrdering (Projection c)
instance MonadPartition m => MonadPartition (Orderings c m)
instance MonadAggregate m => MonadAggregate (Orderings c m)
instance MonadQuery m => MonadQuery (Orderings c m)
instance MonadRestrict rc m => MonadRestrict rc (Orderings c m)


-- | This module defines monad transformer which lift from context into
--   context with assigning.
module Database.Relational.Query.Monad.Trans.Assigning

-- | Type to accumulate assigning context. Type <tt>r</tt> is table record
--   type.
data Assignings r m a

-- | Lift to <a>Assignings</a>
assignings :: Monad m => m a -> Assignings r m a

-- | Add an assignment.
assignTo :: Monad m => Projection Flat v -> AssignTarget r v -> Assignings r m ()

-- | Add and assginment.
(<-#) :: Monad m => AssignTarget r v -> Projection Flat v -> Assignings r m ()

-- | Target of assignment.
type AssignTarget r v = Pi r v

-- | Run <a>Assignings</a> to get <a>Assignments</a>
extractAssignments :: (Monad m, Functor m) => Assignings r m a -> m (a, Table r -> Assignments)
instance MonadTrans (Assignings r)
instance Monad m => Monad (Assignings r m)
instance Functor m => Functor (Assignings r m)
instance Applicative m => Applicative (Assignings r m)
instance MonadRestrict c m => MonadRestrict c (Assignings r m)


-- | This module defines monad transformer which lift to basic
--   <a>MonadQuery</a>.
module Database.Relational.Query.Monad.Trans.Restricting

-- | Type to accumulate query restrictions. Type <tt>c</tt> is context tag
--   of restriction building like Flat (where) or Aggregated (having).
data Restrictings c m a

-- | Lift to <a>Restrictings</a>
restrictings :: Monad m => m a -> Restrictings c m a

-- | Run <a>Restrictings</a> to get <a>QueryRestriction</a>
extractRestrict :: (Monad m, Functor m) => Restrictings c m a -> m (a, QueryRestriction c)
instance MonadTrans (Restrictings c)
instance Monad m => Monad (Restrictings c m)
instance Functor m => Functor (Restrictings c m)
instance Applicative m => Applicative (Restrictings c m)
instance MonadAggregate m => MonadAggregate (Restrictings c m)
instance MonadQuery q => MonadQuery (Restrictings c q)
instance (Monad q, Functor q) => MonadRestrict c (Restrictings c q)


-- | This module defines monad transformer which lift to basic
--   <a>MonadQuery</a>.
module Database.Relational.Query.Monad.Trans.Join

-- | <a>StateT</a> type to accumulate join product context.
data QueryJoin m a

-- | Lift to <a>QueryJoin</a>
join' :: Monad m => m a -> QueryJoin m a

-- | Run <a>QueryJoin</a> to get <a>JoinProduct</a>
extractProduct :: Functor m => QueryJoin m a -> m ((a, JoinProduct), Duplication)
instance Monad m => Monad (QueryJoin m)
instance Functor m => Functor (QueryJoin m)
instance (Monad m, Functor m) => Applicative (QueryJoin m)
instance (Monad q, Functor q) => MonadQuery (QueryJoin q)


-- | This module defines core query type.
module Database.Relational.Query.Monad.Type

-- | Thin monad type for untyped structure.
type ConfigureQuery = Qualify (QueryConfig Identity)

-- | Run <a>ConfigureQuery</a> monad with initial state to get only result.
configureQuery :: ConfigureQuery q -> Config -> q

-- | Get qualifyed table form query.
qualifyQuery :: a -> ConfigureQuery (Qualified a)

-- | Read configuration.
askConfig :: ConfigureQuery Config

-- | Core query monad type used from flat(not-aggregated) query and
--   aggregated query.
type QueryCore = Restrictings Flat (QueryJoin ConfigureQuery)

-- | Extract <a>QueryCore</a> computation.
extractCore :: QueryCore a -> ConfigureQuery (((a, QueryRestriction Flat), JoinProduct), Duplication)

-- | OrderedQuery monad type with placeholder type <tt>p</tt>. Projection
--   must be the same as <a>Orderings</a> context type parameter
--   <tt>c</tt>.
type OrderedQuery c m p r = Orderings c m (PlaceHolders p, Projection c r)


-- | This module contains definitions about simple restrict context monad
--   type.
module Database.Relational.Query.Monad.Restrict

-- | Restrict only monad type used from update statement and delete
--   statement.
type Restrict = Restrictings Flat ConfigureQuery

-- | RestrictedStatement type synonym. Projection record type <tt>r</tt>
--   must be the same as <a>Restrictings</a> type parameter <tt>r</tt>.
type RestrictedStatement r a = Projection Flat r -> Restrict a

-- | Run <a>Restrict</a> to get <a>QueryRestriction</a>.
extract :: Restrict a -> Config -> (a, QueryRestriction Flat)
instance MonadQualify ConfigureQuery Restrict


-- | This module contains definitions about restrict context with
--   assignment monad type.
module Database.Relational.Query.Monad.Assign

-- | Target update monad type used from update statement and merge
--   statement.
type Assign r = Assignings r Restrict

-- | AssignStatement type synonym. Specifying assignments and restrictions
--   like update statement. Projection record type must be the same as
--   <tt>Target</tt> type parameter <tt>r</tt>.
type AssignStatement r a = Projection Flat r -> Assign r a

-- | Run <a>Assign</a>.
extract :: Assign r a -> Config -> ((a, Table r -> Assignments), QueryRestriction Flat)
instance MonadQualify ConfigureQuery (Assign r)


-- | This module defines effect statements like update and delete.
module Database.Relational.Query.Effect

-- | Restriction type with place-holder parameter <tt>p</tt> and projection
--   record type <tt>r</tt>.
data Restriction p r

-- | Not finalized <a>Restrict</a> monad type.
type RestrictionContext p r = RestrictedStatement r (PlaceHolders p)

-- | Finalize <a>Restrict</a> monad and generate <a>Restriction</a>.
restriction :: RestrictedStatement r () -> Restriction () r

-- | Finalize <a>Restrict</a> monad and generate <a>Restriction</a> with
--   place-holder parameter <tt>p</tt>
restriction' :: RestrictedStatement r (PlaceHolders p) -> Restriction p r

-- | UpdateTarget type with place-holder parameter <tt>p</tt> and
--   projection record type <tt>r</tt>.
data UpdateTarget p r

-- | Not finalized <tt>Target</tt> monad type.
type UpdateTargetContext p r = AssignStatement r (PlaceHolders p)

-- | Finalize <tt>Target</tt> monad and generate <a>UpdateTarget</a>.
updateTarget :: AssignStatement r () -> UpdateTarget () r

-- | Finalize <tt>Target</tt> monad and generate <a>UpdateTarget</a> with
--   place-holder parameter <tt>p</tt>.
updateTarget' :: AssignStatement r (PlaceHolders p) -> UpdateTarget p r

-- | Lift <a>Restriction</a> to <a>UpdateTarget</a>. Update target columns
--   are all.
liftTargetAllColumn :: PersistableWidth r => Restriction () r -> UpdateTarget r r

-- | Lift <a>Restriction</a> to <a>UpdateTarget</a>. Update target columns
--   are all. With placefolder type <tt>p</tt>.
liftTargetAllColumn' :: PersistableWidth r => Restriction p r -> UpdateTarget (r, p) r

-- | Finalize <a>Restrict</a> monad and generate <a>UpdateTarget</a>.
--   Update target columns are all.
updateTargetAllColumn :: PersistableWidth r => RestrictedStatement r () -> UpdateTarget r r

-- | Finalize <a>Restrict</a> monad and generate <a>UpdateTarget</a>.
--   Update target columns are all. With placefolder type <tt>p</tt>.
updateTargetAllColumn' :: PersistableWidth r => RestrictedStatement r (PlaceHolders p) -> UpdateTarget (r, p) r

-- | SQL WHERE clause <a>StringSQL</a> string from <a>Restriction</a>.
sqlWhereFromRestriction :: Config -> Table r -> Restriction p r -> StringSQL

-- | SQL SET clause and WHERE clause <a>StringSQL</a> string from
--   <a>UpdateTarget</a>
sqlFromUpdateTarget :: Config -> Table r -> UpdateTarget p r -> StringSQL
instance TableDerivable r => Show (UpdateTarget p r)
instance TableDerivable r => Show (Restriction p r)


-- | This module contains definitions about simple (not-aggregated) query
--   type.
module Database.Relational.Query.Monad.Simple

-- | Simple (not-aggregated) query monad type.
type QuerySimple = Orderings Flat QueryCore

-- | Simple (not-aggregated) query type. <tt>SimpleQuery'</tt> p r ==
--   <a>QuerySimple</a> (<a>PlaceHolders</a> p, <a>Projection</a> r).
type SimpleQuery p r = OrderedQuery Flat QueryCore p r

-- | Lift from qualified table forms into <a>QuerySimple</a>.
simple :: ConfigureQuery a -> QuerySimple a

-- | Run <a>SimpleQuery</a> to get SQL string with <tt>Qualify</tt>
--   computation.
toSQL :: SimpleQuery p r -> ConfigureQuery String

-- | Run <a>SimpleQuery</a> to get <a>SubQuery</a> with <tt>Qualify</tt>
--   computation.
toSubQuery :: SimpleQuery p r -> ConfigureQuery SubQuery
instance MonadQualify ConfigureQuery (Orderings Flat QueryCore)


-- | This module contains definitions about aggregated query type.
module Database.Relational.Query.Monad.Aggregate

-- | Aggregated query monad type.
type QueryAggregate = Orderings Aggregated (Restrictings Aggregated (AggregatingSetT QueryCore))

-- | Aggregated query type. <a>AggregatedQuery</a> p r ==
--   <a>QueryAggregate</a> (<a>PlaceHolders</a> p, <a>Projection</a>
--   <a>Aggregated</a> r).
type AggregatedQuery p r = OrderedQuery Aggregated (Restrictings Aggregated (AggregatingSetT QueryCore)) p r

-- | Run <a>AggregatedQuery</a> to get SQL with <a>ConfigureQuery</a>
--   computation.
toSQL :: AggregatedQuery p r -> ConfigureQuery String

-- | Run <a>AggregatedQuery</a> to get <a>SubQuery</a> with
--   <a>ConfigureQuery</a> computation.
toSubQuery :: AggregatedQuery p r -> ConfigureQuery SubQuery

-- | Partition monad type for partition-by clause.
type Window c = Orderings c (PartitioningSet c)

-- | Add <i>PARTITION BY</i> term into context.
partitionBy :: Projection c r -> Window c ()

-- | Operator to make window function result projection using built
--   <a>Window</a> monad.
over :: SqlProjectable (Projection c) => Projection OverWindow a -> Window c () -> Projection c a
instance MonadQualify ConfigureQuery QueryAggregate
instance MonadRestrict Flat q => MonadRestrict Flat (Restrictings Aggregated q)


-- | This module contains definitions about unique query type to support
--   scalar queries.
module Database.Relational.Query.Monad.Unique

-- | Unique query monad type.
data QueryUnique a

-- | Run <tt>SimpleQuery</tt> to get <a>SubQuery</a> with <tt>Qualify</tt>
--   computation.
toSubQuery :: QueryUnique (PlaceHolders p, Projection c r) -> ConfigureQuery SubQuery
instance MonadQuery QueryUnique
instance Monad QueryUnique
instance Applicative QueryUnique
instance Functor QueryUnique
instance MonadQualifyUnique ConfigureQuery QueryUnique


-- | This module defines re-usable Relation type to compose complex query.
module Database.Relational.Query.Relation

-- | Relation type with place-holder parameter <tt>p</tt> and query result
--   type <tt>r</tt>.
data Relation p r

-- | Simple <a>Relation</a> from <a>Table</a>.
table :: Table r -> Relation () r

-- | Infered <a>Relation</a>.
derivedRelation :: TableDerivable r => Relation () r

-- | Interface to derive <a>Table</a> type object.
tableOf :: TableDerivable r => Relation () r -> Table r

-- | Finalize <a>QuerySimple</a> monad and generate <a>Relation</a>.
relation :: QuerySimple (Projection Flat r) -> Relation () r

-- | Finalize <a>QuerySimple</a> monad and generate <a>Relation</a> with
--   place-holder parameter <tt>p</tt>.
relation' :: SimpleQuery p r -> Relation p r

-- | Finalize <a>QueryAggregate</a> monad and geneate <a>Relation</a>.
aggregateRelation :: QueryAggregate (Projection Aggregated r) -> Relation () r

-- | Finalize <a>QueryAggregate</a> monad and geneate <a>Relation</a> with
--   place-holder parameter <tt>p</tt>.
aggregateRelation' :: AggregatedQuery p r -> Relation p r

-- | Unique relation type to compose scalar queries.
data UniqueRelation p c r

-- | Unsafely specify unique relation.
unsafeUnique :: Relation p r -> UniqueRelation p c r

-- | Discard unique attribute.
unUnique :: UniqueRelation p c r -> Relation p r

-- | Finalize <a>QueryUnique</a> monad and generate <a>UniqueRelation</a>.
uniqueRelation' :: QueryUnique (PlaceHolders p, Projection c r) -> UniqueRelation p c r

-- | Aggregated <a>UniqueRelation</a>.
aggregatedUnique :: Relation ph r -> Pi r a -> (Projection Flat a -> Projection Aggregated b) -> UniqueRelation ph Flat b

-- | Dump internal structure tree.
dump :: Relation p r -> String

-- | Generate SQL string from <a>Relation</a> with configuration.
sqlFromRelationWith :: Relation p r -> Config -> StringSQL

-- | SQL string from <a>Relation</a>.
sqlFromRelation :: Relation p r -> StringSQL

-- | Join sub-query. Query result is not <a>Maybe</a>.
query :: (MonadQualify ConfigureQuery m, MonadQuery m) => Relation () r -> m (Projection Flat r)

-- | Join sub-query with place-holder parameter <tt>p</tt>. query result is
--   not <a>Maybe</a>.
query' :: (MonadQualify ConfigureQuery m, MonadQuery m) => Relation p r -> m (PlaceHolders p, Projection Flat r)

-- | Join sub-query. Query result is <a>Maybe</a>. The combinations of
--   <a>query</a> and <a>queryMaybe</a> express inner joins, left outer
--   joins, right outer joins, and full outer joins. Here is an example of
--   a right outer join:
--   
--   <pre>
--   outerJoin = relation $ do
--     e &lt;- queryMaybe employee
--     d &lt;- query department
--     on $ e ?! E.deptId' .=. just (d ! D.deptId')
--     return $ (,) |$| e |*| d
--   </pre>
queryMaybe :: (MonadQualify ConfigureQuery m, MonadQuery m) => Relation () r -> m (Projection Flat (Maybe r))

-- | Join sub-query with place-holder parameter <tt>p</tt>. Query result is
--   <a>Maybe</a>.
queryMaybe' :: (MonadQualify ConfigureQuery m, MonadQuery m) => Relation p r -> m (PlaceHolders p, Projection Flat (Maybe r))

-- | List sub-query, for <i>IN</i> and <i>EXIST</i>.
queryList :: MonadQualify ConfigureQuery m => Relation () r -> m (ListProjection (Projection c) r)

-- | List sub-query, for <i>IN</i> and <i>EXIST</i> with place-holder
--   parameter <tt>p</tt>.
queryList' :: MonadQualify ConfigureQuery m => Relation p r -> m (PlaceHolders p, ListProjection (Projection c) r)

-- | Scalar sub-query.
queryScalar :: (MonadQualify ConfigureQuery m, ScalarDegree r) => UniqueRelation () c r -> m (Projection c (Maybe r))

-- | Scalar sub-query with place-holder parameter <tt>p</tt>.
queryScalar' :: (MonadQualify ConfigureQuery m, ScalarDegree r) => UniqueRelation p c r -> m (PlaceHolders p, Projection c (Maybe r))

-- | Join unique sub-query with place-holder parameter <tt>p</tt>.
uniqueQuery' :: MonadQualifyUnique ConfigureQuery m => UniqueRelation p c r -> m (PlaceHolders p, Projection c r)

-- | Join unique sub-query with place-holder parameter <tt>p</tt>. Query
--   result is <a>Maybe</a>.
uniqueQueryMaybe' :: MonadQualifyUnique ConfigureQuery m => UniqueRelation p c r -> m (PlaceHolders p, Projection c (Maybe r))

-- | Restriction function type for direct style join operator.
type JoinRestriction a b = Projection Flat a -> Projection Flat b -> Projection Flat (Maybe Bool)

-- | Simplify placeholder type applying left identity element.
rightPh :: Relation ((), p) r -> Relation p r

-- | Simplify placeholder type applying right identity element.
leftPh :: Relation (p, ()) r -> Relation p r

-- | Direct inner join with place-holder parameters.
inner' :: Relation pa a -> Relation pb b -> [JoinRestriction a b] -> Relation (pa, pb) (a, b)

-- | Direct left outer join with place-holder parameters.
left' :: Relation pa a -> Relation pb b -> [JoinRestriction a (Maybe b)] -> Relation (pa, pb) (a, Maybe b)

-- | Direct right outer join with place-holder parameters.
right' :: Relation pa a -> Relation pb b -> [JoinRestriction (Maybe a) b] -> Relation (pa, pb) (Maybe a, b)

-- | Direct full outer join with place-holder parameters.
full' :: Relation pa a -> Relation pb b -> [JoinRestriction (Maybe a) (Maybe b)] -> Relation (pa, pb) (Maybe a, Maybe b)

-- | Direct inner join.
inner :: Relation () a -> Relation () b -> [JoinRestriction a b] -> Relation () (a, b)

-- | Direct left outer join.
left :: Relation () a -> Relation () b -> [JoinRestriction a (Maybe b)] -> Relation () (a, Maybe b)

-- | Direct right outer join.
right :: Relation () a -> Relation () b -> [JoinRestriction (Maybe a) b] -> Relation () (Maybe a, b)

-- | Direct full outer join.
full :: Relation () a -> Relation () b -> [JoinRestriction (Maybe a) (Maybe b)] -> Relation () (Maybe a, Maybe b)

-- | Apply restriction for direct join style.
on' :: ([JoinRestriction a b] -> Relation pc (a, b)) -> [JoinRestriction a b] -> Relation pc (a, b)

-- | Union of two relations.
union :: Relation () a -> Relation () a -> Relation () a

-- | Subtraction of two relations.
except :: Relation () a -> Relation () a -> Relation () a

-- | Intersection of two relations.
intersect :: Relation () a -> Relation () a -> Relation () a

-- | Union of two relations. Not distinct.
unionAll :: Relation () a -> Relation () a -> Relation () a

-- | Subtraction of two relations. Not distinct.
exceptAll :: Relation () a -> Relation () a -> Relation () a

-- | Intersection of two relations. Not distinct.
intersectAll :: Relation () a -> Relation () a -> Relation () a

-- | Union of two relations with place-holder parameters.
union' :: Relation p a -> Relation q a -> Relation (p, q) a

-- | Subtraction of two relations with place-holder parameters.
except' :: Relation p a -> Relation q a -> Relation (p, q) a

-- | Intersection of two relations with place-holder parameters.
intersect' :: Relation p a -> Relation q a -> Relation (p, q) a

-- | Union of two relations with place-holder parameters. Not distinct.
unionAll' :: Relation p a -> Relation q a -> Relation (p, q) a

-- | Subtraction of two relations with place-holder parameters. Not
--   distinct.
exceptAll' :: Relation p a -> Relation q a -> Relation (p, q) a

-- | Intersection of two relations with place-holder parameters. Not
--   distinct.
intersectAll' :: Relation p a -> Relation q a -> Relation (p, q) a
instance Show (Relation p r)


-- | This module defines typed SQL.
module Database.Relational.Query.Type

-- | Query type with place-holder parameter <tt>p</tt> and query result
--   type <tt>a</tt>.
newtype Query p a
Query :: String -> Query p a
untypeQuery :: Query p a -> String

-- | Unsafely make typed <a>Query</a> from SQL string.
unsafeTypedQuery :: String -> Query p a

-- | From <a>Relation</a> into typed <a>Query</a> with suffix SQL words.
relationalQuery' :: Relation p r -> QuerySuffix -> Query p r

-- | From <a>Relation</a> into typed <a>Query</a>.
relationalQuery :: Relation p r -> Query p r

-- | From <a>Relation</a> into untyped SQL query string.
relationalQuerySQL :: Config -> Relation p r -> QuerySuffix -> String

-- | Update type with key type <tt>p</tt> and update record type
--   <tt>a</tt>. Columns to update are record columns other than key
--   columns, So place-holder parameter type is the same as record type
--   <tt>a</tt>.
data KeyUpdate p a
KeyUpdate :: Pi a p -> String -> KeyUpdate p a
updateKey :: KeyUpdate p a -> Pi a p
untypeKeyUpdate :: KeyUpdate p a -> String

-- | Unsafely make typed <a>KeyUpdate</a> from SQL string.
unsafeTypedKeyUpdate :: Pi a p -> String -> KeyUpdate p a

-- | Make typed <a>KeyUpdate</a> from <a>Table</a> and key columns selector
--   <a>Pi</a>.
typedKeyUpdate :: Table a -> Pi a p -> KeyUpdate p a

-- | Make typed <a>KeyUpdate</a> object using derived info specified by
--   <a>Relation</a> type.
typedKeyUpdateTable :: TableDerivable r => Relation () r -> Pi r p -> KeyUpdate p r

-- | Update type with place-holder parameter <tt>p</tt>.
newtype Update p
Update :: String -> Update p
untypeUpdate :: Update p -> String

-- | Unsafely make typed <a>Update</a> from SQL string.
unsafeTypedUpdate :: String -> Update p

-- | Make typed <a>Update</a> from <a>Config</a>, <a>Table</a> and
--   <a>UpdateTarget</a>.
typedUpdate' :: Config -> Table r -> UpdateTarget p r -> Update p

-- | Make typed <a>Update</a> using <a>defaultConfig</a>, <a>Table</a> and
--   <a>UpdateTarget</a>.
typedUpdate :: Table r -> UpdateTarget p r -> Update p

-- | Make typed <a>Update</a> from <a>Config</a>, derived table and
--   <a>UpdateTargetContext</a>
derivedUpdate' :: TableDerivable r => Config -> UpdateTargetContext p r -> Update p

-- | Make typed <a>Update</a> from <a>defaultConfig</a>, derived table and
--   <a>UpdateTargetContext</a>
derivedUpdate :: TableDerivable r => UpdateTargetContext p r -> Update p

-- | Make typed <a>Update</a> from <a>Table</a> and <a>Restriction</a>.
--   Update target is all column.
typedUpdateAllColumn :: PersistableWidth r => Table r -> Restriction p r -> Update (r, p)

-- | Directly make typed <a>Update</a> from <a>Table</a> and
--   <tt>Restrict</tt> monad context. Update target is all column.
restrictedUpdateAllColumn :: PersistableWidth r => Table r -> RestrictionContext p r -> Update (r, p)

-- | Directly make typed <a>Update</a> from <a>Table</a> and
--   <tt>Restrict</tt> monad context. Update target is all column.
restrictedUpdateTableAllColumn :: (PersistableWidth r, TableDerivable r) => Relation () r -> RestrictionContext p r -> Update (r, p)

-- | Make untyped update SQL string from <a>Table</a> and
--   <a>UpdateTarget</a>.
updateSQL :: Config -> Table r -> UpdateTarget p r -> String

-- | Insert type to insert record type <tt>a</tt>.
data Insert a
Insert :: String -> String -> Int -> Insert a
untypeInsert :: Insert a -> String
untypeChunkInsert :: Insert a -> String
chunkSizeOfInsert :: Insert a -> Int

-- | Unsafely make typed <a>Insert</a> from single insert and chunked
--   insert SQL.
unsafeTypedInsert' :: String -> String -> Int -> Insert a

-- | Unsafely make typed <a>Insert</a> from single insert SQL.
unsafeTypedInsert :: String -> Insert a

-- | Make typed <a>Insert</a> from <a>Table</a> and columns selector
--   <a>Pi</a> with configuration parameter.
typedInsert' :: Config -> Table r -> Pi r r' -> Insert r'

-- | Make typed <a>Insert</a> from <a>Table</a> and columns selector
--   <a>Pi</a>.
typedInsert :: Table r -> Pi r r' -> Insert r'

-- | Table type inferred <a>Insert</a>.
derivedInsert :: TableDerivable r => Pi r r' -> Insert r'

-- | InsertQuery type.
newtype InsertQuery p
InsertQuery :: String -> InsertQuery p
untypeInsertQuery :: InsertQuery p -> String

-- | Unsafely make typed <a>InsertQuery</a> from SQL string.
unsafeTypedInsertQuery :: String -> InsertQuery p

-- | Make typed <a>InsertQuery</a> from columns selector <a>Table</a>,
--   <a>Pi</a> and <a>Relation</a> with configuration parameter.
typedInsertQuery' :: Config -> Table r -> Pi r r' -> Relation p r' -> InsertQuery p

-- | Make typed <a>InsertQuery</a> from columns selector <a>Table</a>,
--   <a>Pi</a> and <a>Relation</a>.
typedInsertQuery :: Table r -> Pi r r' -> Relation p r' -> InsertQuery p

-- | Table type inferred <a>InsertQuery</a>.
derivedInsertQuery :: TableDerivable r => Pi r r' -> Relation p r' -> InsertQuery p

-- | Make untyped insert select SQL string from <a>Table</a>, <a>Pi</a> and
--   <a>Relation</a>.
insertQuerySQL :: Config -> Table r -> Pi r r' -> Relation p r' -> String

-- | Delete type with place-holder parameter <tt>p</tt>.
newtype Delete p
Delete :: String -> Delete p
untypeDelete :: Delete p -> String

-- | Unsafely make typed <a>Delete</a> from SQL string.
unsafeTypedDelete :: String -> Delete p

-- | Make typed <a>Delete</a> from <a>Config</a>, <a>Table</a> and
--   <a>Restriction</a>.
typedDelete' :: Config -> Table r -> Restriction p r -> Delete p

-- | Make typed <a>Delete</a> from <a>Table</a> and <a>Restriction</a>.
typedDelete :: Table r -> Restriction p r -> Delete p

-- | Make typed <a>Delete</a> from <a>Config</a>, derived table and
--   <tt>RestrictContext</tt>
derivedDelete' :: TableDerivable r => Config -> RestrictionContext p r -> Delete p

-- | Make typed <a>Delete</a> from <a>defaultConfig</a>, derived table and
--   <tt>RestrictContext</tt>
derivedDelete :: TableDerivable r => RestrictionContext p r -> Delete p

-- | Make untyped delete SQL string from <a>Table</a> and
--   <a>Restriction</a>.
deleteSQL :: Config -> Table r -> Restriction p r -> String

-- | Untype interface for typed no-result type statments with single type
--   parameter which represents place-holder parameter <tt>p</tt>.
class UntypeableNoFetch s
untypeNoFetch :: UntypeableNoFetch s => s p -> String
instance UntypeableNoFetch Delete
instance UntypeableNoFetch Update
instance UntypeableNoFetch Insert
instance Show (Delete p)
instance Show (InsertQuery p)
instance Show (Insert a)
instance Show (Update p)
instance Show (KeyUpdate p a)
instance Show (Query p a)


-- | This module defines typed SQLs derived from type informations.
module Database.Relational.Query.Derives

-- | Query restricted with specified key.
specifiedKey :: PersistableWidth p => Pi a p -> Relation () a -> Relation p a

-- | Query restricted with specified unique key.
unique :: PersistableWidth p => Key Unique a p -> Relation () a -> Relation p a

-- | Query restricted with specified primary key.
primary' :: PersistableWidth p => Key Primary a p -> Relation () a -> Relation p a

-- | Query restricted with inferred primary key.
primary :: HasConstraintKey Primary a p => Relation () a -> Relation p a

-- | Typed <a>KeyUpdate</a> using specified constraint key.
updateByConstraintKey :: Table r -> Key c r p -> KeyUpdate p r

-- | Typed <a>KeyUpdate</a> using inferred primary key.
primaryUpdate :: HasConstraintKey Primary r p => Table r -> KeyUpdate p r

-- | Convert from Haskell type <tt>r</tt> into SQL value <tt>q</tt> list
--   expected by update form like
--   
--   <i>UPDATE <a>table</a> SET c0 = ?, c1 = ?, ..., cn = ? WHERE key0 = ?
--   AND key1 = ? AND key2 = ? ... </i>
--   
--   using derived <tt>RecordToSql</tt> proof object.
updateValuesWithKey :: ToSql q r => Pi r p -> r -> [q]

-- | <a>UniqueRelation</a> inferred from table.
derivedUniqueRelation :: TableDerivable r => Key Unique r k -> Projection c k -> UniqueRelation () c r


-- | This module is integrated module of Query.
module Database.Relational.Query


-- | This module defines arrow version combinators which improves
--   type-safty on building queries. Referencing the local projections may
--   cause to break the result query. It is possible to controls injection
--   of previous local projections by restricting domain type of arrow.
--   This idea is imported from Opaleye.
--   (https:/<i>github.com</i>tomjaguarpaw/haskell-opaleye,
--   <a>https://github.com/khibino/haskell-relational-record/issues/19)</a>.
--   
--   Importing this module instead of <a>Database.Relational.Query</a>
--   enables to build query using arrow combinators.
module Database.Relational.Query.Arrow

-- | Same as <a>all'</a>. Arrow version.
all' :: MonadQuery m => QueryA m () ()

-- | Same as <a>distinct</a>. Arrow version.
distinct :: MonadQuery m => QueryA m () ()

-- | Same as <a>query</a>. Arrow version. The result arrow is not injected
--   by local projections.
query :: (MonadQualify ConfigureQuery m, MonadQuery m) => Relation () r -> QueryA m () (Projection Flat r)

-- | Same as <a>queryMaybe</a>. Arrow version. The result arrow is not
--   injected by any local projections.
queryMaybe :: (MonadQualify ConfigureQuery m, MonadQuery m) => Relation () r -> QueryA m () (Projection Flat (Maybe r))

-- | Same as <a>query'</a>. Arrow version. The result arrow is not injected
--   by any local projections.
query' :: (MonadQualify ConfigureQuery m, MonadQuery m) => Relation p r -> QueryA m () (PlaceHolders p, Projection Flat r)

-- | Same as <a>queryMaybe'</a>. Arrow version. The result arrow is not
--   injected by any local projections.
queryMaybe' :: (MonadQualify ConfigureQuery m, MonadQuery m) => Relation p r -> QueryA m () (PlaceHolders p, Projection Flat (Maybe r))

-- | Same as <a>queryList</a>. Arrow version. The result arrow is designed
--   to be injected by local projections.
queryList :: MonadQualify ConfigureQuery m => (Projection c a -> Relation () r) -> QueryA m (Projection c a) (ListProjection (Projection c) r)

-- | Same as <a>queryList'</a>. Arrow version. The result arrow is designed
--   to be injected by local projections.
queryList' :: MonadQualify ConfigureQuery m => (Projection c a -> Relation p r) -> QueryA m (Projection c a) (PlaceHolders p, ListProjection (Projection c) r)

-- | Same as <a>queryList</a> to pass this result to <a>exists</a>
--   operator. Arrow version. The result arrow is designed to be injected
--   by local projections.
queryExists :: MonadQualify ConfigureQuery m => (Projection c a -> Relation () r) -> QueryA m (Projection c a) (ListProjection (Projection Exists) r)

-- | Same as <a>queryList'</a> to pass this result to <a>exists</a>
--   operator. Arrow version. The result arrow is designed to be injected
--   by local projections.
queryExists' :: MonadQualify ConfigureQuery m => (Projection c a -> Relation p r) -> QueryA m (Projection c a) (PlaceHolders p, ListProjection (Projection Exists) r)

-- | Same as <a>queryList</a>. Arrow version. Useful for no reference cases
--   to local projections.
queryListU :: MonadQualify ConfigureQuery m => Relation () r -> QueryA m () (ListProjection (Projection c) r)

-- | Same as <a>queryList'</a>. Arrow version. Useful for no reference
--   cases to local projections.
queryListU' :: MonadQualify ConfigureQuery m => Relation p r -> QueryA m () (PlaceHolders p, ListProjection (Projection c) r)

-- | Same as <a>queryScalar</a>. Arrow version. The result arrow is
--   designed to be injected by any local projection.
queryScalar :: (MonadQualify ConfigureQuery m, ScalarDegree r) => (Projection c a -> UniqueRelation () c r) -> QueryA m (Projection c a) (Projection c (Maybe r))

-- | Same as <a>queryScalar'</a>. Arrow version. The result arrow is
--   designed to be injected by any local projection.
queryScalar' :: (MonadQualify ConfigureQuery m, ScalarDegree r) => (Projection c a -> UniqueRelation p c r) -> QueryA m (Projection c a) (PlaceHolders p, Projection c (Maybe r))

-- | Same as <a>queryScalar</a>. Arrow version. Useful for no reference
--   cases to local projections.
queryScalarU :: (MonadQualify ConfigureQuery m, ScalarDegree r) => UniqueRelation () c r -> QueryA m () (Projection c (Maybe r))

-- | Same as <a>queryScalar'</a>. Arrow version. Useful for no reference
--   cases to local projections.
queryScalarU' :: (MonadQualify ConfigureQuery m, ScalarDegree r) => UniqueRelation p c r -> QueryA m () (PlaceHolders p, Projection c (Maybe r))

-- | Same as <a>uniqueQuery'</a>. Arrow version. The result arrow is not
--   injected by local projections.
uniqueQuery' :: MonadQualifyUnique ConfigureQuery m => UniqueRelation p c r -> QueryA m () (PlaceHolders p, Projection c r)

-- | Same as <a>uniqueQueryMaybe'</a>. Arrow version. The result arrow is
--   not injected by local projections.
uniqueQueryMaybe' :: MonadQualifyUnique ConfigureQuery m => UniqueRelation p c r -> QueryA m () (PlaceHolders p, Projection c (Maybe r))

-- | Same as <a>on</a>. Arrow version. The result arrow is designed to be
--   injected by local conditional flat-projections.
on :: MonadQuery m => QueryA m (Projection Flat (Maybe Bool)) ()

-- | Same as <a>wheres</a>. Arrow version. The result arrow is designed to
--   be injected by local conditional flat-projections.
wheres :: MonadRestrict Flat m => QueryA m (Projection Flat (Maybe Bool)) ()

-- | Same as <a>having</a>. Arrow version. The result arrow is designed to
--   be injected by local conditional aggregated-projections.
having :: MonadRestrict Aggregated m => QueryA m (Projection Aggregated (Maybe Bool)) ()

-- | Same as <a>groupBy</a>. Arrow version. The result arrow is designed to
--   be injected by local flat-projections.
groupBy :: MonadAggregate m => QueryA m (Projection Flat r) (Projection Aggregated r)

-- | Same as <a>placeholder</a>. Arrow version. The result arrow is
--   designed to be injected by locally built arrow using placeholders.
placeholder :: (PersistableWidth t, SqlProjectable p, Monad m) => QueryA m (QueryA m (p t) a) (PlaceHolders t, a)

-- | Same as <a>relation</a>. Finalize query-building arrow instead of
--   query-building monad.
relation :: QuerySimple () (Projection Flat r) -> Relation () r

-- | Same as <a>relation'</a>. Finalize query-building arrow instead of
--   query-building monad.
relation' :: QuerySimple () (PlaceHolders p, Projection Flat r) -> Relation p r

-- | Same as <a>aggregateRelation</a>. Finalize query-building arrow
--   instead of query-building monad.
aggregateRelation :: QueryAggregate () (Projection Aggregated r) -> Relation () r

-- | Same as <a>aggregateRelation'</a>. Finalize query-building arrow
--   instead of query-building monad.
aggregateRelation' :: QueryAggregate () (PlaceHolders p, Projection Aggregated r) -> Relation p r

-- | Same as <a>uniqueRelation'</a>. Finalize query-building arrow instead
--   of query-building monad.
uniqueRelation' :: QueryUnique () (PlaceHolders p, Projection c r) -> UniqueRelation p c r

-- | Same as <a>groupBy'</a>. This arrow is designed to be injected by
--   local <a>AggregateKey</a>.
groupBy' :: MonadAggregate m => QueryA m (AggregateKey a) a

-- | Same as <a>key</a>. This arrow is designed to be injected by local
--   flat-projections.
key :: AggregatingSet (Projection Flat r) (Projection Aggregated (Maybe r))

-- | Same as <a>key'</a>. This arrow is designed to be injected by local
--   <tt>AggregteKey</tt>.
key' :: AggregatingSet (AggregateKey a) a

-- | Same as <a>set</a>. This arrow is designed to be injected by locally
--   built <tt>AggregtingSet</tt> arrow.
set :: AggregatingSetList (AggregatingSet () a) a

-- | Same as <a>bkey</a>. This arrow is designed to be injected by local
--   flat-projections.
bkey :: AggregatingPowerSet (Projection Flat r) (Projection Aggregated (Maybe r))

-- | Same as <a>rollup</a>. Finalize locally built
--   <a>AggregatingPowerSet</a>.
rollup :: AggregatingPowerSet () a -> AggregateKey a

-- | Same as <a>cube</a>. Finalize locally built
--   <a>AggregatingPowerSet</a>.
cube :: AggregatingPowerSet () a -> AggregateKey a

-- | Same as <a>groupingSets</a>. Finalize locally built
--   <a>AggregatingSetList</a>.
groupingSets :: AggregatingSetList () a -> AggregateKey a

-- | Same as <a>orderBy</a>. The result arrow is designed to be injected by
--   local projections.
orderBy :: Monad m => Order -> Orderings c m (Projection c t) ()

-- | Same as <a>asc</a>. The result arrow is designed to be injected by
--   local projections.
asc :: Monad m => Orderings c m (Projection c t) ()

-- | Same as <a>desc</a>. The result arrow is designed to be injected by
--   local projections.
desc :: Monad m => Orderings c m (Projection c t) ()

-- | Same as <a>partitionBy</a>. The result arrow is designed to be
--   injected by local projections.
partitionBy :: Window c (Projection c r) ()

-- | Same as <a>over</a>. Make window function result projection using
--   built <a>Window</a> arrow.
over :: SqlProjectable (Projection c) => Projection OverWindow a -> Window c () () -> Projection c a

-- | Make <a>AssignTarget</a> into arrow which is designed to be injected
--   by local projection assignees.
assign :: Monad m => AssignTarget r v -> Assignings r m (Projection Flat v) ()

-- | Same as <a>derivedUpdate'</a>. Make <a>Update</a> from assigning
--   statement arrow using configuration.
derivedUpdate' :: TableDerivable r => Config -> UpdateTargetContext p r -> Update p

-- | Same as <a>derivedUpdate</a>. Make <a>Update</a> from assigning
--   statement arrow.
derivedUpdate :: TableDerivable r => UpdateTargetContext p r -> Update p

-- | Same as <a>derivedDelete'</a>. Make <a>Update</a> from restrict
--   statement arrow using configuration.
derivedDelete' :: TableDerivable r => Config -> RestrictionContext p r -> Delete p

-- | Same as <a>derivedDelete</a>. Make <a>Update</a> from restrict
--   statement arrow.
derivedDelete :: TableDerivable r => RestrictionContext p r -> Delete p

-- | Arrow to build queries.
data QueryA m a b

-- | Arrow type corresponding to <a>QuerySimple</a>
type QuerySimple = QueryA QuerySimple

-- | Arrow type corresponding to <a>QueryAggregate</a>
type QueryAggregate = QueryA QueryAggregate

-- | Arrow type corresponding to <a>QueryUnique</a>
type QueryUnique = QueryA QueryUnique

-- | Arrow type corresponding to <a>AggregatingSet</a>
type AggregatingSet = QueryA AggregatingSet

-- | Arrow type corresponding to <a>AggregatingSetList</a>
type AggregatingSetList = QueryA AggregatingSetList

-- | Arrow type corresponding to <a>AggregatingPowerSet</a>
type AggregatingPowerSet = QueryA AggregatingPowerSet

-- | Arrow type corresponding to <a>Orderings</a>
type Orderings c m = QueryA (Orderings c m)

-- | Arrow type corresponding to <a>Window</a>
type Window c = QueryA (Window c)

-- | Arrow type corresponding to <a>Assignings</a>
type Assignings r m = QueryA (Assignings r m)

-- | Arrow type corresponding to <a>UpdateTargetContext</a>
type UpdateTargetContext p r = Assignings r Restrict (Projection Flat r) (PlaceHolders p)

-- | Arrow type corresponding to <a>RestrictionContext</a>
type RestrictionContext p r = QueryA Restrict (Projection Flat r) (PlaceHolders p)
instance Monad m => Category (QueryA m)
instance Monad m => Arrow (QueryA m)


-- | This module defines templates for Haskell record type and type class
--   instances to define column projection on SQL query like Haskell
--   records. Templates are generated by also using functions of
--   <a>Database.Record.TH</a> module, so mapping between list of untyped
--   SQL type and Haskell record type will be done too.
module Database.Relational.Query.TH

-- | Generate all templtes about table using default naming rule.
defineTableDefault :: Config -> String -> String -> [(String, TypeQ)] -> [ConName] -> [Int] -> Maybe Int -> Q [Dec]

-- | Unsafely inlining SQL string <a>Query</a> in compile type.
unsafeInlineQuery :: TypeQ -> TypeQ -> String -> VarName -> Q [Dec]

-- | Inlining composed <a>Query</a> in compile type.
inlineQuery :: Name -> Relation p r -> Config -> QuerySuffix -> String -> Q [Dec]

-- | Make templates about table, column and haskell record using default
--   naming rule.
defineTableTypesAndRecordDefault :: Config -> String -> String -> [(String, TypeQ)] -> [ConName] -> Q [Dec]

-- | Rule template to infer primary key.
defineHasPrimaryKeyInstance :: TypeQ -> TypeQ -> [Int] -> Q [Dec]

-- | Rule template to infer primary key.
defineHasPrimaryKeyInstanceDefault :: String -> TypeQ -> [Int] -> Q [Dec]

-- | Rule template to infer not-null key.
defineHasNotNullKeyInstance :: TypeQ -> Int -> Q [Dec]

-- | Rule template to infer not-null key.
defineHasNotNullKeyInstanceDefault :: String -> Int -> Q [Dec]

-- | <a>ScalarDegree</a> instance templates.
defineScalarDegree :: TypeQ -> Q [Dec]

-- | Column projection path <a>Pi</a> templates.
defineColumns :: ConName -> [((VarName, TypeQ), Maybe (TypeQ, VarName))] -> Q [Dec]

-- | Make column projection path and constraint key templates using default
--   naming rule.
defineColumnsDefault :: ConName -> [((String, TypeQ), Maybe TypeQ)] -> Q [Dec]

-- | <a>Table</a> and <a>Relation</a> templates.
defineTableTypes :: VarName -> VarName -> VarName -> VarName -> TypeQ -> String -> [String] -> Q [Dec]

-- | Make templates about table and column metadatas using default naming
--   rule.
defineTableTypesDefault :: Config -> String -> String -> [((String, TypeQ), Maybe TypeQ)] -> Q [Dec]

-- | Template of derived primary <a>Query</a>.
definePrimaryQuery :: VarName -> TypeQ -> TypeQ -> ExpQ -> Q [Dec]

-- | Template of derived primary <tt>Update</tt>.
definePrimaryUpdate :: VarName -> TypeQ -> TypeQ -> ExpQ -> Q [Dec]

-- | Make <tt>TableDerivation</tt> variable expression template from table
--   name using default naming rule.
derivationExpDefault :: String -> ExpQ

-- | Make <a>Table</a> variable expression template from table name using
--   default naming rule.
tableVarExpDefault :: String -> ExpQ

-- | Make <a>Relation</a> variable expression template from table name
--   using default naming rule.
relationVarExpDefault :: String -> ExpQ

-- | SQL templates derived from primary key.
defineSqlsWithPrimaryKey :: VarName -> VarName -> TypeQ -> TypeQ -> ExpQ -> ExpQ -> Q [Dec]

-- | SQL templates derived from primary key using default naming rule.
defineSqlsWithPrimaryKeyDefault :: String -> TypeQ -> TypeQ -> ExpQ -> ExpQ -> Q [Dec]

-- | Make template for <a>ProductConstructor</a> instance.
defineProductConstructorInstance :: TypeQ -> ExpQ -> [TypeQ] -> Q [Dec]

-- | Generate all templates against defined record like type constructor
--   other than depending on sql-value type.
makeRelationalRecordDefault :: Name -> Q [Dec]

-- | Extract param type and result type from defined Relation
reifyRelation :: Name -> Q (Type, Type)
