-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | PostgreSQL backend for the groundhog library.
--   
@package groundhog-postgresql
@version 0.7.0.2

module Database.Groundhog.Postgresql.Geometry
data Point
Point :: Double -> Double -> Point

-- | It is not fully implemented in PostgreSQL yet. It is kept just to
--   match all geometric types.
data Line
Line :: Point -> Point -> Line
data Lseg
Lseg :: Point -> Point -> Lseg
data Box
Box :: Point -> Point -> Box
data Path
ClosedPath :: [Point] -> Path
OpenPath :: [Point] -> Path
data Polygon
Polygon :: [Point] -> Polygon
data Circle
Circle :: Point -> Double -> Circle

-- | Translation
--   
--   <pre>
--   box '((0,0),(1,1))' + point '(2.0,0)' = box '(3,1),(2,0)'
--   </pre>
(+.) :: (SqlDb db, Plus a b, ExpressionOf db r x a, ExpressionOf db r y b) => x -> y -> Expr db r a

-- | Translation
--   
--   <pre>
--   box '((0,0),(1,1))' - point '(2.0,0)' = box '(-1,1),(-2,0)'
--   </pre>
(-.) :: (SqlDb db, BoxCirclePathPoint a, ExpressionOf db r x a, ExpressionOf db r y Point) => x -> y -> Expr db r a

-- | Scaling/rotation
--   
--   <pre>
--   box '((0,0),(1,1))' * point '(2.0,0)' = box '(2,2),(0,0)'
--   </pre>
(*.) :: (SqlDb db, BoxCirclePathPoint a, ExpressionOf db r x a, ExpressionOf db r y Point) => x -> y -> Expr db r a

-- | Scaling/rotation
--   
--   <pre>
--   box '((0,0),(2,2))' / point '(2.0,0)' = box '(1,1),(0,0)'
--   </pre>
(/.) :: (SqlDb db, BoxCirclePathPoint a, ExpressionOf db r x a, ExpressionOf db r y Point) => x -> y -> Expr db r a

-- | Point or box of intersection
--   
--   <pre>
--   lseg '((1,-1),(-1,1))' # '((1,1),(-1,-1))' = point '(0,0)'
--   </pre>
--   
--   <pre>
--   box '((1,-1),(-1,1))' # '((1,1),(-1,-1))' = box '(1,1),(-1,-1)'
--   </pre>
(#) :: (SqlDb db, BoxLineLseg a, ExpressionOf db r x a, ExpressionOf db r y a) => x -> y -> Expr db r a

-- | Closest point to first operand on second operand
--   
--   <pre>
--   point '(0,0)' ## lseg '((2,0),(0,2))' = point '(1,1)'
--   </pre>
(##) :: (SqlDb db, Closest a b, ExpressionOf db r x a, ExpressionOf db r y b) => x -> y -> Expr db r Point

-- | Distance between
--   
--   <pre>
--   circle '((0,0),1)' <a>-</a> circle '((5,0),1)' = 3
--   </pre>
(<->) :: (SqlDb db, Distance a b, ExpressionOf db r x a, ExpressionOf db r y b) => x -> y -> Expr db r Double

-- | Overlaps?
--   
--   <pre>
--   box '((0,0),(1,1))' &amp;&amp; box '((0,0),(2,2))' = true
--   </pre>
(&&) :: (SqlDb db, BoxCirclePolygon a, ExpressionOf db r x a, ExpressionOf db r y a) => x -> y -> Cond db r

-- | Is strictly left of?
--   
--   <pre>
--   circle '((0,0),1)' &lt;&lt; circle '((5,0),1)' = true
--   </pre>
(<<) :: (SqlDb db, BoxCirclePointPolygon a, ExpressionOf db r x a, ExpressionOf db r y a) => x -> y -> Cond db r

-- | Is strictly right of?
--   
--   <pre>
--   circle '((5,0),1)' &gt;&gt; circle '((0,0),1)' = true
--   </pre>
(>>) :: (SqlDb db, BoxCirclePointPolygon a, ExpressionOf db r x a, ExpressionOf db r y a) => x -> y -> Cond db r

-- | Does not extend to the right of? box '((0,0),(1,1))' &amp;&lt; box
--   '((0,0),(2,2))' = t
(&<) :: (SqlDb db, BoxCirclePolygon a, ExpressionOf db r x a, ExpressionOf db r y a) => x -> y -> Cond db r

-- | Does not extend to the left of?
--   
--   <pre>
--   box '((0,0),(3,3))' &amp;&gt; box '((0,0),(2,2))' = true
--   </pre>
(&>) :: (SqlDb db, BoxCirclePolygon a, ExpressionOf db r x a, ExpressionOf db r y a) => x -> y -> Cond db r

-- | Is strictly below?
--   
--   <pre>
--   box '((0,0),(3,3))' &lt;&lt;| box '((3,4),(5,5))' = true
--   </pre>
(<<|) :: (SqlDb db, BoxCirclePolygon a, ExpressionOf db r x a, ExpressionOf db r y a) => x -> y -> Cond db r

-- | Is strictly above?
--   
--   <pre>
--   box '((3,4),(5,5))' |&gt;&gt; box '((0,0),(3,3))'
--   </pre>
(|>>) :: (SqlDb db, BoxCirclePolygon a, ExpressionOf db r x a, ExpressionOf db r y a) => x -> y -> Cond db r

-- | Does not extend above?
--   
--   <pre>
--   box '((0,0),(1,1))' &amp;&lt;| box '((0,0),(2,2))' = true
--   </pre>
(&<|) :: (SqlDb db, BoxCirclePolygon a, ExpressionOf db r x a, ExpressionOf db r y a) => x -> y -> Cond db r

-- | Does not extend below?
--   
--   <pre>
--   box '((0,0),(3,3))' |&amp;&gt; box '((0,0),(2,2))' = true
--   </pre>
(|&>) :: (SqlDb db, BoxCirclePolygon a, ExpressionOf db r x a, ExpressionOf db r y a) => x -> y -> Cond db r

-- | Is below (allows touching)?
--   
--   <pre>
--   circle '((0,0),1)' &lt;^ circle '((0,5),1)' = true
--   </pre>
(<^) :: (SqlDb db, BoxPoint a, ExpressionOf db r x a, ExpressionOf db r y a) => x -> y -> Cond db r

-- | Is above (allows touching)?
--   
--   <pre>
--   circle '((0,5),1)' &gt;^ circle '((0,0),1)' = true
--   </pre>
(>^) :: (SqlDb db, BoxPoint a, ExpressionOf db r x a, ExpressionOf db r y a) => x -> y -> Cond db r

-- | Intersects?
--   
--   <pre>
--   lseg '((-1,0),(1,0))' ?# box '((-2,-2),(2,2))' = true
--   </pre>
(?#) :: (SqlDb db, Intersects a b, ExpressionOf db r x a, ExpressionOf db r y b) => x -> y -> Cond db r

-- | Are horizontally aligned?
--   
--   <pre>
--   point '(1,0)' ?- point '(0,0)' = true
--   </pre>
(?-) :: (SqlDb db, ExpressionOf db r x Point, ExpressionOf db r y Point) => x -> y -> Cond db r

-- | Are vertically aligned?
--   
--   <pre>
--   point '(0,1)' ?| point '(0,0)' = true
--   </pre>
(?|) :: (SqlDb db, ExpressionOf db r x Point, ExpressionOf db r y Point) => x -> y -> Cond db r

-- | Is perpendicular?
--   
--   <pre>
--   lseg '((0,0),(0,1))' ?-| lseg '((0,0),(1,0))' = true
--   </pre>
(?-|) :: (SqlDb db, LineLseg a, ExpressionOf db r x a, ExpressionOf db r y a) => x -> y -> Cond db r

-- | Are parallel?
--   
--   <pre>
--   lseg '((-1,0),(1,0))' ?|| lseg '((-1,2),(1,2))' = true
--   </pre>
(?||) :: (SqlDb db, LineLseg a, ExpressionOf db r x a, ExpressionOf db r y a) => x -> y -> Cond db r

-- | Contains?
--   
--   <pre>
--   circle '((0,0),2)' @&gt; point '(1,1)' = true
--   </pre>
(@>) :: (SqlDb db, Contains a b, ExpressionOf db r x a, ExpressionOf db r y b) => x -> y -> Cond db r

-- | Contained in or on?
--   
--   <pre>
--   point '(1,1)' &lt;@ circle '((0,0),2)' = true
--   </pre>
(<@) :: (SqlDb db, Contained a b, ExpressionOf db r x a, ExpressionOf db r y b) => x -> y -> Cond db r

-- | Same as?
--   
--   <pre>
--   polygon '((0,0),(1,1))' ~= polygon '((1,1),(0,0))' = true
--   </pre>
(~=) :: (SqlDb db, BoxCirclePointPolygon a, ExpressionOf db r x a, ExpressionOf db r y a) => x -> y -> Cond db r
instance Eq Point
instance Show Point
instance Eq Line
instance Show Line
instance Eq Lseg
instance Show Lseg
instance Eq Box
instance Show Box
instance Eq Path
instance Show Path
instance Eq Polygon
instance Show Polygon
instance Eq Circle
instance Show Circle
instance Intersects Path Path
instance Intersects Lseg Lseg
instance Intersects Lseg Line
instance Intersects Lseg Box
instance Intersects Line Box
instance Intersects Line Line
instance Intersects Box Box
instance Closest Point Lseg
instance Closest Point Box
instance Closest Point Line
instance Closest Lseg Lseg
instance Closest Lseg Line
instance Closest Lseg Box
instance Closest Line Lseg
instance Closest Line Box
instance Contained Polygon Polygon
instance Contained Point Circle
instance Contained Point Polygon
instance Contained Point Path
instance Contained Point Line
instance Contained Point Box
instance Contained Point Lseg
instance Contained Lseg Line
instance Contained Lseg Box
instance Contained Circle Circle
instance Contained Box Box
instance Contains Polygon Point
instance Contains Polygon Polygon
instance Contains Path Point
instance Contains Circle Point
instance Contains Circle Circle
instance Contains Box Point
instance Contains Box Box
instance Distance Polygon Polygon
instance Distance Point Lseg
instance Distance Point Box
instance Distance Point Line
instance Distance Point Circle
instance Distance Point Point
instance Distance Point Path
instance Distance Path Path
instance Distance Lseg Box
instance Distance Lseg Lseg
instance Distance Lseg Line
instance Distance Line Box
instance Distance Line Line
instance Distance Circle Polygon
instance Distance Circle Circle
instance Distance Box Box
instance Plus Point Point
instance Plus Path Path
instance Plus Path Point
instance Plus Circle Point
instance Plus Box Point
instance LineLseg Lseg
instance LineLseg Line
instance BoxPoint Point
instance BoxPoint Box
instance BoxCirclePointPolygon Polygon
instance BoxCirclePointPolygon Point
instance BoxCirclePointPolygon Circle
instance BoxCirclePointPolygon Box
instance BoxCirclePathPoint Point
instance BoxCirclePathPoint Path
instance BoxCirclePathPoint Circle
instance BoxCirclePathPoint Box
instance BoxCirclePolygon Polygon
instance BoxCirclePolygon Circle
instance BoxCirclePolygon Box
instance BoxLineLseg Lseg
instance BoxLineLseg Line
instance BoxLineLseg Box
instance PersistField Circle
instance PrimitivePersistField Circle
instance PersistField Polygon
instance PrimitivePersistField Polygon
instance PersistField Path
instance PrimitivePersistField Path
instance PersistField Box
instance PrimitivePersistField Box
instance PersistField Lseg
instance PrimitivePersistField Lseg
instance PersistField Line
instance PrimitivePersistField Line
instance PersistField Point
instance PrimitivePersistField Point

module Database.Groundhog.Postgresql
withPostgresqlPool :: (MonadBaseControl IO m, MonadIO m) => String -> Int -> (Pool Postgresql -> m a) -> m a
withPostgresqlConn :: (MonadBaseControl IO m, MonadIO m) => String -> (Postgresql -> m a) -> m a
createPostgresqlPool :: MonadIO m => String -> Int -> m (Pool Postgresql)

-- | Runs action within connection. It can handle a simple connection, a
--   pool of them, etc.
runDbConn :: (MonadBaseControl IO m, MonadIO m, ConnectionManager cm conn) => DbPersist conn (NoLoggingT m) a -> cm -> m a
newtype Postgresql
Postgresql :: Connection -> Postgresql

-- | Put explicit type for expression. It is useful for values which are
--   defaulted to a wrong type. For example, a literal Int from a 64bit
--   machine can be defaulted to a 32bit int by Postgresql. Also a value
--   entered as an external string (geometry, arrays and other complex
--   types have this representation) may need an explicit type.
explicitType :: (Expression Postgresql r a, PersistField a) => a -> Expr Postgresql r a

-- | Casts expression to a type. <tt>castType value "INT"</tt> results in
--   <tt>value::INT</tt>.
castType :: Expression Postgresql r a => a -> String -> Expr Postgresql r a

-- | Distinct only on certain fields or expressions. For example,
--   <tt>select $ CondEmpty <a>distinctOn</a> (lower EmailField,
--   IpField)</tt>.
distinctOn :: (db ~ Postgresql, HasSelectOptions a db r, HasDistinct a ~ HFalse, Projection' p db r p') => a -> p -> SelectOptions db r (HasLimit a) (HasOffset a) (HasOrder a) HTrue
showSqlType :: DbTypePrimitive -> String
instance ToField P
instance SingleConnectionManager Postgresql Postgresql
instance ConnectionManager (Pool Postgresql) Postgresql
instance ConnectionManager Postgresql Postgresql
instance Savepoint Postgresql
instance (MonadBaseControl IO m, MonadIO m, MonadLogger m) => SchemaAnalyzer (DbPersist Postgresql m)
instance (MonadBaseControl IO m, MonadIO m, MonadLogger m) => PersistBackend (DbPersist Postgresql m)
instance FloatingSqlDb Postgresql
instance SqlDb Postgresql
instance DbDescriptor Postgresql


-- | See detailed documentation for PostgreSQL arrays at
--   <a>http://www.postgresql.org/docs/9.2/static/arrays.html</a> and
--   <a>http://www.postgresql.org/docs/9.2/static/functions-array.html</a>
module Database.Groundhog.Postgresql.Array

-- | Represents PostgreSQL arrays
newtype Array a
Array :: [a] -> Array a
(!) :: (ExpressionOf Postgresql r a (Array elem), ExpressionOf Postgresql r b Int) => a -> b -> Expr Postgresql r elem
(!:) :: (ExpressionOf Postgresql r a (Array elem), ExpressionOf Postgresql r i1 Int, ExpressionOf Postgresql r i2 Int) => a -> (i1, i2) -> Expr Postgresql r (Array elem)
append :: (ExpressionOf Postgresql r a (Array elem), ExpressionOf Postgresql r b elem) => a -> b -> Expr Postgresql r (Array elem)
prepend :: (ExpressionOf Postgresql r a elem, ExpressionOf Postgresql r b (Array elem)) => a -> b -> Expr Postgresql r (Array elem)
arrayCat :: (ExpressionOf Postgresql r a (Array elem), ExpressionOf Postgresql r b (Array elem)) => a -> b -> Expr Postgresql r (Array elem)
arrayDims :: ExpressionOf Postgresql r a (Array elem) => a -> Expr Postgresql r String
arrayNDims :: ExpressionOf Postgresql r a (Array elem) => a -> Expr Postgresql r Int
arrayLower :: ExpressionOf Postgresql r a (Array elem) => a -> Int -> Expr Postgresql r Int
arrayUpper :: ExpressionOf Postgresql r a (Array elem) => a -> Int -> Expr Postgresql r Int
arrayLength :: ExpressionOf Postgresql r a (Array elem) => a -> Int -> Expr Postgresql r Int

-- | Concatenates array elements using supplied delimiter.
--   array_to_string(ARRAY[1, 2, 3], <tt>~^~</tt>) = 1~^~2~^~3
arrayToString :: ExpressionOf Postgresql r a (Array elem) => a -> String -> Expr Postgresql r String

-- | Splits string into array elements using supplied delimiter.
--   string_to_array('xx~^~yy~^~zz', <tt>~^~</tt>) = {xx,yy,zz}
stringToArray :: ExpressionOf Postgresql r a String => a -> String -> Expr Postgresql r (Array String)
any :: (ExpressionOf Postgresql r a elem, ExpressionOf Postgresql r b (Array elem)) => a -> b -> Cond Postgresql r
all :: (ExpressionOf Postgresql r a elem, ExpressionOf Postgresql r b (Array elem)) => a -> b -> Cond Postgresql r

-- | Contains. ARRAY[1,4,3] @&gt; ARRAY[3,1] = t
(@>) :: (ExpressionOf Postgresql r a (Array elem), ExpressionOf Postgresql r b (Array elem)) => a -> b -> Cond Postgresql r

-- | Is contained by. ARRAY[2,7] &lt;@ ARRAY[1,7,4,2,6] = t
(<@) :: (ExpressionOf Postgresql r a (Array elem), ExpressionOf Postgresql r b (Array elem)) => a -> b -> Cond Postgresql r

-- | Overlap (have elements in common). ARRAY[1,4,3] &amp;&amp; ARRAY[2,1]
--   = t
overlaps :: (ExpressionOf Postgresql r a (Array elem), ExpressionOf Postgresql r b (Array elem)) => a -> b -> Cond Postgresql r
instance [overlap ok] Eq a => Eq (Array a)
instance [overlap ok] Show a => Show (Array a)
instance [overlap ok] (ArrayElem a, PrimitivePersistField a) => PrimitivePersistField (Array a)
instance [overlap ok] PrimitivePersistField a => ArrayElem a
instance [overlap ok] ArrayElem a => ArrayElem (Array a)
instance [overlap ok] (ArrayElem a, PrimitivePersistField a) => PersistField (Array a)
