-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Provides the region monad for safely opening and working with
scarce resources.
--   
--   This package provides the region monad transformer. Scarce resources
--   like files, memory pointers or USB devices for example can be opened
--   in a region. When the region terminates, all opened resources will be
--   automatically closed. The main advantage of regions is that the opened
--   resources can not be returned from the region which ensures no I/O
--   with closed resources is possible.
--   
--   The primary technique used in this package is called "Lightweight
--   monadic regions" which was invented by Oleg Kiselyov and Chung-chieh
--   Shan. See:
--   
--   <a>http://okmij.org/ftp/Haskell/regions.html#light-weight</a>
--   
--   Also see the <tt>regions-mtl</tt> and <tt>regions-monadstf</tt>
--   packages which provide instances for the classes in the respected
--   monad transformers packages.
--   
--   For an example on how to use this library see the
--   <tt>safer-file-handles</tt>, <tt>usb-safe</tt> or
--   <tt>regional-pointers</tt> packages.
@package regions
@version 0.11


-- | This module is not intended for end-users. It should only be used by
--   library authors wishing to extend this <tt>regions</tt> library.
module Control.Monad.Trans.Region.OnExit

-- | An <a>IO</a> computation that closes or finalizes a resource. For
--   example "<tt>hClose someHandle</tt>" or "<tt>free somePtr</tt>".
type Finalizer = IO ()

-- | A handle to a <a>Finalizer</a> that allows you to duplicate it to a
--   parent region using <a>dup</a>.
--   
--   Duplicating a finalizer means that instead of it being performed when
--   the current region terminates it is performed when the parent region
--   terminates.
data FinalizerHandle r :: (* -> *)

-- | Register the <a>Finalizer</a> in the region. When the region
--   terminates all registered finalizers will be perfomed if they're not
--   duplicated to a parent region.
--   
--   Note that finalizers are run in LIFO order (Last In First Out). So
--   executing the following:
--   
--   <pre>
--   runRegionT $ do
--     _ &lt;- onExit $ putStrLn "finalizer 1"
--     _ &lt;- onExit $ putStrLn "finalizer 2"
--     return ()
--   </pre>
--   
--   yields:
--   
--   <pre>
--   finalizer 2
--   finalizer 1
--   </pre>
onExit :: MonadIO pr => Finalizer -> RegionT s pr (FinalizerHandle (RegionT s pr))


module Control.Monad.Trans.Region.Unsafe

-- | Convert a <a>Local</a> region to a regular region.
--   
--   This function is unsafe because it allows you to use a
--   <a>LocalRegion</a>-tagged handle outside its <a>Local</a> region.
unsafeStripLocal :: RegionT (Local s) pr α -> RegionT s pr α
unsafeLiftControlIO :: RegionControlIO m => (RunInBase m IO -> IO α) -> m α
unsafeLiftControl :: Monad pr => (Run (RegionT s) -> pr α) -> RegionT s pr α
unsafeControlIO :: RegionControlIO m => (RunInBase m IO -> IO (m α)) -> m α
unsafeLiftIOOp :: RegionControlIO m => ((α -> IO (m β)) -> IO (m γ)) -> ((α -> m β) -> m γ)
unsafeLiftIOOp_ :: RegionControlIO m => (IO (m α) -> IO (m β)) -> (m α -> m β)


-- | This modules implements a technique called <i>"Lightweight monadic
--   regions"</i> invented by Oleg Kiselyov and Chung-chieh Shan
--   
--   See: <a>http://okmij.org/ftp/Haskell/regions.html#light-weight</a>
module Control.Monad.Trans.Region

-- | A monad transformer in which scarce resources can be opened. When the
--   region terminates, all opened resources will be closed automatically.
--   It's a type error to return an opened resource from the region. The
--   latter ensures no I/O with closed resources is possible.
data RegionT s pr α

-- | Execute a region inside its parent region <tt>pr</tt>.
--   
--   All resources which have been opened in the given region and which
--   haven't been duplicated using <a>dup</a>, will be closed on exit from
--   this function wether by normal termination or by raising an exception.
--   
--   Also all resources which have been duplicated to this region from a
--   child region are closed on exit if they haven't been duplicated
--   themselves.
--   
--   Note the type variable <tt>s</tt> of the region wich is only
--   quantified over the region itself. This ensures that <i>all</i>
--   values, having a type containing <tt>s</tt>, can <i>not</i> be
--   returned from this function. (Note the similarity with the <tt>ST</tt>
--   monad.)
--   
--   Note that it is possible to run a region inside another region.
runRegionT :: RegionControlIO pr => (forall s. RegionT s pr α) -> pr α

-- | Regions do not have an instance for <a>MonadControlIO</a> since that
--   would break the safety guarantees. (Think about lifting
--   <tt>forkIO</tt> into a region!)
--   
--   However <a>runRegionT</a> and other operations on regions do need the
--   ability to lift control operations. This is where the
--   <a>RegionControlIO</a> class comes in. This class is identical to
--   <a>MonadControlIO</a> but its <a>unsafeLiftControlIO</a> method is not
--   exported by this module. So user can't accidentally break the safety.
--   
--   Note that a <a>RegionT</a> is an instance of this class. For the rest
--   there is a catch-all <tt>instance <a>MonadControlIO</a> m =&gt;
--   <a>RegionControlIO</a> m</tt>.
class MonadIO m => RegionControlIO m

-- | Duplicate an <tt>h</tt> in the parent region. This <tt>h</tt> will
--   usually be some type of regional handle.
--   
--   For example, suppose you run the following region:
--   
--   <pre>
--   runRegionT $ do
--   </pre>
--   
--   Inside this region you run a nested <i>child</i> region like:
--   
--   <pre>
--   r1hDup &lt;- runRegionT $ do
--   </pre>
--   
--   Now in this child region you open the resource <tt>r1</tt>:
--   
--   <pre>
--   r1h &lt;- open r1
--   </pre>
--   
--   ...yielding the regional handle <tt>r1h</tt>. Note that:
--   
--   <pre>
--   r1h :: RegionalHandle (RegionT cs (RegionT ps ppr))
--   </pre>
--   
--   where <tt>cs</tt> is bound by the inner (child) <tt>runRegionT</tt>
--   and <tt>ps</tt> is bound by the outer (parent) <tt>runRegionT</tt>.
--   
--   Suppose you want to use the resulting regional handle <tt>r1h</tt> in
--   the <i>parent</i> region. You can't simply <tt>return r1h</tt> because
--   then the type variable <tt>cs</tt>, escapes the inner region.
--   
--   However, if you duplicate the regional handle you can safely return
--   it.
--   
--   <pre>
--   r1hDup &lt;- dup r1h
--   return r1hDup
--   </pre>
--   
--   Note that <tt>r1hDup :: RegionalHandle (RegionT ps ppr)</tt>
--   
--   Back in the parent region you can safely operate on <tt>r1hDup</tt>.
class Dup h
dup :: (Dup h, MonadIO ppr) => h (RegionT cs (RegionT ps ppr)) -> RegionT cs (RegionT ps ppr) (h (RegionT ps ppr))

-- | The <tt>AncestorRegion</tt> class is used to relate the region in
--   which a resource was opened to the region in which it is used. Take
--   the following operation from the <tt>safer-file-handles</tt> package
--   as an example:
--   
--   <pre>
--   hFileSize :: (pr `AncestorRegion` cr, MonadIO cr) =&gt; RegionalFileHandle ioMode pr -&gt; cr Integer
--   </pre>
--   
--   The <tt>AncestorRegion</tt> class defines the parent / child
--   relationship between regions. The constraint
--   
--   <pre>
--   pr `AncestorRegion` cr
--   </pre>
--   
--   is satisfied if and only if <tt>cr</tt> is a sequence of zero or more
--   "<tt><a>RegionT</a> s</tt>" (with varying <tt>s</tt>) applied to
--   <tt>pr</tt>, in other words, if <tt>cr</tt> is an (improper) nested
--   subregion of <tt>pr</tt>.
--   
--   The class constraint <tt>InternalAncestorRegion pr cr</tt> serves two
--   purposes. First, the instances of <tt>InternalAncestorRegion</tt> do
--   the type-level recursion that implements the relation specified above.
--   Second, since it is not exported, user code cannot add new instances
--   of <a>AncestorRegion</a> (as these would have to be made instances of
--   <tt>InternalAncestorRegion</tt>, too), effectively turning it into a
--   <i>closed class</i>.
class InternalAncestorRegion pr cr => AncestorRegion pr cr

-- | The <tt>RootRegion</tt> is the ancestor of any region.
--   
--   It's primary purpose is to tag regional handles which don't have an
--   associated finalizer. For example the standard file handles
--   <tt>stdin</tt>, <tt>stdout</tt> and <tt>stderr</tt> which are opened
--   on program startup and which shouldn't be closed when a region
--   terminates. Another example is the <tt>nullPtr</tt> which is a memory
--   pointer which doesn't point to any allocated memory so doesn't need to
--   be freed.
data RootRegion α

-- | A <tt>LocalRegion</tt> is used to tag regional handles which are
--   created locally.
--   
--   An example is the <tt>LocalPtr</tt> in the <tt>alloca</tt> function
--   from the <tt>regional-pointers</tt> package:
--   
--   <pre>
--   alloca :: (Storable a, MonadControlIO pr)
--          =&gt; (forall sl. LocalPtr a (<a>LocalRegion</a> sl s) -&gt; RegionT (<a>Local</a> s) pr b)
--          -&gt; RegionT s pr b
--   </pre>
--   
--   The finalisation of the <tt>LocalPtr</tt> is not performed by the
--   <tt>regions</tt> library but is handled locally by <tt>alloca</tt>
--   instead.
--   
--   The type variable <tt>sl</tt>, which is only quantified over the
--   continuation, ensures that locally opened resources don't escape.
data LocalRegion sl s α

-- | A type used to tag regions in which locally created handles (handles
--   tagged with <a>LocalRegion</a>) can be used.
--   
--   Note than any handle which is created in a <tt>RegionT (Local s)</tt>
--   can be used outside that region (<tt>RegionT s</tt>) and visa versa
--   (except for <a>LocalRegion</a>-tagged handles).
data Local s

-- | Lift a <tt>callCC</tt> operation to the new monad.
liftCallCC :: (((α -> pr β) -> pr α) -> pr α) -> (((α -> RegionT s pr β) -> RegionT s pr α) -> RegionT s pr α)

-- | Transform the computation inside a region.
mapRegionT :: (m α -> n β) -> (RegionT s m α -> RegionT s n β)

-- | Lift a <tt>catchError</tt> operation to the new monad.
liftCatch :: (pr α -> (e -> pr α) -> pr α) -> (RegionT s pr α -> (e -> RegionT s pr α) -> RegionT s pr α)
