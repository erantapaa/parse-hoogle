-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Predicative tries
--   
--   Predicative tries
@package pred-trie
@version 0.2.0

module Data.Trie.Pred.Disjoint.Tail
data DPTrie p t x
[DMore] :: t -> Maybe x -> [DPTrie p t x] -> DPTrie p t x
[DPred] :: p -> (t -> Maybe r) -> Maybe (r -> x) -> [DPTrie p t (r -> x)] -> DPTrie p t x
lookup :: Eq t => NonEmpty t -> DPTrie p t x -> Maybe x
lookupWithL :: Eq t => (t -> t) -> NonEmpty t -> DPTrie p t x -> Maybe x
lookupNearestParent :: Eq t => NonEmpty t -> DPTrie p t x -> Maybe x

-- | Overwrites when similar, leaves untouched when not
merge :: (Eq p, Eq t) => DPTrie p t x -> DPTrie p t x -> DPTrie p t x
areDisjoint :: (Eq p, Eq t) => DPTrie p t x -> DPTrie p t x -> Bool
litSingletonTail :: NonEmpty t -> x -> DPTrie p t x
litExtrudeTail :: [t] -> DPTrie p t x -> DPTrie p t x
sort :: (Eq p, Eq t) => [DPTrie p t x] -> [DPTrie p t x]

module Data.Trie.Pred.Disjoint

-- | A Rooted, predicate, disjointly indexed trie
data RDPTrie p t x
[Rooted] :: (Maybe x) -> [DPTrie p t x] -> RDPTrie p t x
merge :: (Eq p, Eq t) => RDPTrie p t x -> RDPTrie p t x -> RDPTrie p t x
lookup :: (Eq t) => [t] -> RDPTrie p t x -> Maybe x
lookupWithL :: (Eq t) => (t -> t) -> [t] -> RDPTrie p t x -> Maybe x
lookupNearestParent :: (Eq t) => [t] -> RDPTrie p t x -> Maybe x
litSingleton :: [t] -> x -> RDPTrie p t x
litExtrude :: [t] -> RDPTrie p t x -> RDPTrie p t x
instance (Eq p, Eq t) => Monoid (RDPTrie p t x)

module Data.Trie.Pred.Unified.Tail
data UPTrie t x
[UMore] :: t -> Maybe x -> [UPTrie t x] -> UPTrie t x
[UPred] :: t -> (t -> Maybe r) -> Maybe (r -> x) -> [UPTrie t (r -> x)] -> UPTrie t x
showTail :: (Show t) => UPTrie t x -> String

-- | Assigns a value to literal constructors
assignLit :: (Eq t) => NonEmpty t -> Maybe x -> UPTrie t x -> UPTrie t x
lookup :: Eq t => NonEmpty t -> UPTrie t x -> Maybe x
lookupWithL :: Eq t => (t -> t) -> NonEmpty t -> UPTrie t x -> Maybe x
lookupNearestParent :: Eq t => NonEmpty t -> UPTrie t x -> Maybe x

-- | Overwrites when similar, leaves untouched when not
merge :: (Eq t) => UPTrie t x -> UPTrie t x -> UPTrie t x
areDisjoint :: (Eq t) => UPTrie t x -> UPTrie t x -> Bool

-- | Create a singleton trie out of literal constructors
litSingletonTail :: NonEmpty t -> x -> UPTrie t x

-- | Push a trie down with literal constructors
litExtrudeTail :: [t] -> UPTrie t x -> UPTrie t x
sort :: (Eq t) => [UPTrie t x] -> [UPTrie t x]
instance Show t => Show (UPTrie t x)

module Data.Trie.Pred.Unified
data RUPTrie t x
[Rooted] :: Maybe x -> [UPTrie t x] -> RUPTrie t x
[root] :: RUPTrie t x -> Maybe x
[children] :: RUPTrie t x -> [UPTrie t x]
assignLit :: Eq t => [t] -> Maybe x -> RUPTrie t x -> RUPTrie t x
showTrie :: Show t => RUPTrie t x -> String
merge :: (Eq t) => RUPTrie t x -> RUPTrie t x -> RUPTrie t x
lookup :: (Eq t) => [t] -> RUPTrie t x -> Maybe x
lookupWithL :: (Eq t) => (t -> t) -> [t] -> RUPTrie t x -> Maybe x
lookupNearestParent :: (Eq t) => [t] -> RUPTrie t x -> Maybe x
litSingleton :: [t] -> x -> RUPTrie t x
litExtrude :: [t] -> RUPTrie t x -> RUPTrie t x
instance Eq t => Monoid (RUPTrie t x)
instance Show t => Show (RUPTrie t x)
