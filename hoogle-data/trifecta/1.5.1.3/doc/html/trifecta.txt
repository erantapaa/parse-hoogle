-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A modern parser combinator library with convenient diagnostics
--   
@package trifecta
@version 1.5.1.3


-- | Fast zero based arrays, based on the implementation in the HAMT-branch
--   of unordered-containers
module Text.Trifecta.Util.Array
data Array a
data MArray s a

-- | Create a new mutable array of specified size, in the specified state
--   thread, with each element containing the specified initial value.
new :: Int -> a -> ST s (MArray s a)
new_ :: Int -> ST s (MArray s a)
empty :: Array a
singleton :: a -> Array a
length :: Array a -> Int
lengthM :: MArray s a -> Int
read :: MArray s a -> Int -> ST s a
write :: MArray s a -> Int -> a -> ST s ()
index :: Array a -> Int -> a
index_ :: Array a -> Int -> ST s a
indexM_ :: MArray s a -> Int -> ST s a

-- | <i>O(n)</i> Update the element at the given position in this array.
update :: Array e -> Int -> e -> Array e

-- | <i>O(n)</i> Insert an element at the given position in this array,
--   increasing its size by one.
insert :: Array e -> Int -> e -> Array e

-- | <i>O(n)</i> Delete an element at the given position in this array,
--   decreasing its size by one.
delete :: Array e -> Int -> Array e
unsafeFreeze :: MArray s a -> ST s (Array a)
run :: (forall s. ST s (MArray s e)) -> Array e
run2 :: (forall s. ST s (MArray s e, a)) -> (Array e, a)

-- | Unsafely copy the elements of an array. Array bounds are not checked.
copy :: Array e -> Int -> MArray s e -> Int -> Int -> ST s ()

-- | Unsafely copy the elements of an array. Array bounds are not checked.
copyM :: MArray s e -> Int -> MArray s e -> Int -> Int -> ST s ()
foldl' :: (b -> a -> b) -> b -> Array a -> b
foldr :: (a -> b -> b) -> b -> Array a -> b
thaw :: Array e -> Int -> Int -> ST s (MArray s e)
map :: (a -> b) -> Array a -> Array b

-- | Strict version of <a>map</a>.
map' :: (a -> b) -> Array a -> Array b
traverse :: Applicative f => (a -> f b) -> Array a -> f (Array b)
filter :: (a -> Bool) -> Array a -> Array a
instance NFData a => NFData (Array a)


-- | Interval maps implemented using the <a>FingerTree</a> type, following
--   section 4.8 of
--   
--   <ul>
--   <li>Ralf Hinze and Ross Paterson, "Finger trees: a simple
--   general-purpose data structure", <i>Journal of Functional
--   Programming</i> 16:2 (2006) pp 197-217.
--   <a>http://www.soi.city.ac.uk/~ross/papers/FingerTree.html</a></li>
--   </ul>
--   
--   An amortized running time is given for each operation, with <i>n</i>
--   referring to the size of the priority queue. These bounds hold even in
--   a persistent (shared) setting.
--   
--   <i>Note</i>: Many of these operations have the same names as similar
--   operations on lists in the <a>Prelude</a>. The ambiguity may be
--   resolved using either qualification or the <tt>hiding</tt> clause.
--   
--   Unlike <a>Data.IntervalMap.FingerTree</a>, this version sorts things
--   so that the largest interval from a given point comes first. This way
--   if you have nested intervals, you get the outermost interval before
--   the contained intervals.
module Text.Trifecta.Util.IntervalMap

-- | A closed interval. The lower bound should be less than or equal to the
--   higher bound.
data Interval v
Interval :: v -> v -> Interval v
low :: Interval v -> v
high :: Interval v -> v

-- | Map of closed intervals, possibly with duplicates. The <a>Foldable</a>
--   and <a>Traversable</a> instances process the intervals in
--   lexicographical order.
newtype IntervalMap v a
IntervalMap :: FingerTree (IntInterval v) (Node v a) -> IntervalMap v a
runIntervalMap :: IntervalMap v a -> FingerTree (IntInterval v) (Node v a)

-- | <i>O(1)</i>. Interval map with a single entry.
singleton :: Ord v => Interval v -> a -> IntervalMap v a

-- | <i>O(log n)</i>. Insert an interval into a map. The map may contain
--   duplicate intervals; the new entry will be inserted before any
--   existing entries for the same interval.
insert :: Ord v => v -> v -> a -> IntervalMap v a -> IntervalMap v a

-- | <i>O(k log (n</i>/<i>k))</i>. All intervals that contain the given
--   point, in lexicographical order.
search :: Ord v => v -> IntervalMap v a -> [(Interval v, a)]

-- | <i>O(k log (n</i>/<i>k))</i>. All intervals that intersect with the
--   given interval, in lexicographical order.
intersections :: Ord v => v -> v -> IntervalMap v a -> [(Interval v, a)]

-- | <i>O(k log (n</i>/<i>k))</i>. All intervals that contain the given
--   interval, in lexicographical order.
dominators :: Ord v => v -> v -> IntervalMap v a -> [(Interval v, a)]

-- | <i>O(n)</i>. Add a delta to each interval in the map
offset :: (Ord v, Monoid v) => v -> IntervalMap v a -> IntervalMap v a
data IntInterval v
NoInterval :: IntInterval v
IntInterval :: (Interval v) -> v -> IntInterval v
fromList :: Ord v => [(v, v, a)] -> IntervalMap v a
instance Show v => Show (Interval v)
instance Ord v => Monoid (IntervalMap v a)
instance Ord v => HasUnion0 (IntervalMap v a)
instance Ord v => HasUnion (IntervalMap v a)
instance Ord v => Measured (IntInterval v) (IntervalMap v a)
instance TraversableWithIndex (Interval v) (IntervalMap v)
instance Traversable (IntervalMap v)
instance FoldableWithIndex (Interval v) (IntervalMap v)
instance Foldable (IntervalMap v)
instance FunctorWithIndex (Interval v) (IntervalMap v)
instance Functor (IntervalMap v)
instance Ord v => Measured (IntInterval v) (Node v a)
instance Ord v => Monoid (IntInterval v)
instance TraversableWithIndex (Interval v) (Node v)
instance Traversable (Node v)
instance FoldableWithIndex (Interval v) (Node v)
instance Foldable (Node v)
instance FunctorWithIndex (Interval v) (Node v)
instance Functor (Node v)
instance Traversable Interval
instance Foldable Interval
instance Functor Interval
instance Ord v => Ord (Interval v)
instance Eq v => Eq (Interval v)
instance (Ord v, Monoid v) => Reducer v (Interval v)
instance Ord v => Semigroup (Interval v)


module Text.Trifecta.Delta
data Delta
Columns :: {-# UNPACK #-} !Int64 -> {-# UNPACK #-} !Int64 -> Delta
Tab :: {-# UNPACK #-} !Int64 -> {-# UNPACK #-} !Int64 -> {-# UNPACK #-} !Int64 -> Delta
Lines :: {-# UNPACK #-} !Int64 -> {-# UNPACK #-} !Int64 -> {-# UNPACK #-} !Int64 -> {-# UNPACK #-} !Int64 -> Delta
Directed :: !ByteString -> {-# UNPACK #-} !Int64 -> {-# UNPACK #-} !Int64 -> {-# UNPACK #-} !Int64 -> {-# UNPACK #-} !Int64 -> Delta
class HasDelta t
delta :: HasDelta t => t -> Delta
class HasBytes t
bytes :: HasBytes t => t -> Int64

-- | Increment a column number to the next tabstop.
nextTab :: Int64 -> Int64

-- | Rewind a <a>Delta</a> to the beginning of the line.
rewind :: Delta -> Delta

-- | Should we show two things with a <a>Delta</a> on the same line?
near :: (HasDelta s, HasDelta t) => s -> t -> Bool

-- | Retrieve the character offset within the current line from this
--   <a>Delta</a>.
column :: HasDelta t => t -> Int64

-- | Retrieve the byte offset within the current line from this
--   <a>Delta</a>.
columnByte :: Delta -> Int64
instance Typeable Delta
instance Show Delta
instance Data Delta
instance Generic Delta
instance Datatype D1Delta
instance Constructor C1_0Delta
instance Constructor C1_1Delta
instance Constructor C1_2Delta
instance Constructor C1_3Delta
instance (Measured v a, HasDelta v) => HasDelta (FingerTree v a)
instance HasDelta ByteString
instance HasDelta Word8
instance HasDelta Char
instance HasDelta Delta
instance Semigroup Delta
instance Monoid Delta
instance Hashable Delta
instance HasBytes Delta
instance Pretty Delta
instance (HasDelta l, HasDelta r) => HasDelta (Either l r)
instance Ord Delta
instance Eq Delta
instance (Measured v a, HasBytes v) => HasBytes (FingerTree v a)
instance HasBytes ByteString


module Text.Trifecta.Rope
data Rope
Rope :: !Delta -> !(FingerTree Delta Strand) -> Rope
rope :: FingerTree Delta Strand -> Rope
data Strand
Strand :: {-# UNPACK #-} !ByteString -> !Delta -> Strand
Skipping :: !Delta -> Strand
strand :: ByteString -> Strand
strands :: Rope -> FingerTree Delta Strand

-- | grab a the contents of a rope from a given location up to a newline
grabRest :: Delta -> Rope -> r -> (Delta -> ByteString -> r) -> r

-- | grab a the contents of a rope from a given location up to a newline
grabLine :: Delta -> Rope -> r -> (Delta -> ByteString -> r) -> r
instance Typeable Strand
instance Show Strand
instance Data Strand
instance Generic Strand
instance Show Rope
instance Datatype D1Strand
instance Constructor C1_0Strand
instance Constructor C1_1Strand
instance Reducer [Char] Rope
instance Reducer ByteString Rope
instance Reducer Strand Rope
instance Reducer Rope Rope
instance Semigroup Rope
instance Monoid Rope
instance Measured Delta Rope
instance HasDelta Rope
instance HasBytes Rope
instance HasBytes Strand
instance HasDelta Strand
instance Hashable Strand
instance Measured Delta Strand


-- | harder, better, faster, stronger...
module Text.Trifecta.Util.It
data It r a
Pure :: a -> It r a
It :: a -> (r -> It r a) -> It r a
needIt :: a -> (r -> Maybe a) -> It r a
wantIt :: a -> (r -> (# Bool, a #)) -> It r a
simplifyIt :: It r a -> r -> It r a
runIt :: (a -> o) -> (a -> (r -> It r a) -> o) -> It r a -> o

-- | Given a position, go there, and grab the text forward from that point
fillIt :: r -> (Delta -> ByteString -> r) -> Delta -> It Rope r

-- | Return the text of the line that contains a given position
rewindIt :: Delta -> It Rope (Maybe ByteString)
sliceIt :: Delta -> Delta -> It Rope ByteString
instance Comonad (It r)
instance ComonadApply (It r)
instance Monad (It r)
instance Applicative (It r)
instance Functor (It r)
instance Show a => Show (It r a)


module Text.Trifecta.Highlight

-- | Tags used by the <a>TokenParsing</a> <a>highlight</a> combinator.
data Highlight :: *

-- | A <a>HighlightedRope</a> is a <a>Rope</a> with an associated
--   <a>IntervalMap</a> full of highlighted regions.
data HighlightedRope
HighlightedRope :: !(IntervalMap Delta Highlight) -> {-# UNPACK #-} !Rope -> HighlightedRope
class HasHighlightedRope c_ax2x where ropeContent = (.) highlightedRope ropeContent ropeHighlights = (.) highlightedRope ropeHighlights
highlightedRope :: HasHighlightedRope c_ax2x => Lens' c_ax2x HighlightedRope
ropeContent :: HasHighlightedRope c_ax2x => Lens' c_ax2x Rope
ropeHighlights :: HasHighlightedRope c_ax2x => Lens' c_ax2x (IntervalMap Delta Highlight)

-- | Convert a <a>Highlight</a> into a coloration on a <a>Doc</a>.
withHighlight :: Highlight -> Doc -> Doc

-- | Represents a source file like an HsColour rendered document
data HighlightDoc
HighlightDoc :: String -> String -> HighlightedRope -> HighlightDoc
class HasHighlightDoc c_axym where docContent = (.) highlightDoc docContent docCss = (.) highlightDoc docCss docTitle = (.) highlightDoc docTitle
highlightDoc :: HasHighlightDoc c_axym => Lens' c_axym HighlightDoc
docContent :: HasHighlightDoc c_axym => Lens' c_axym HighlightedRope
docCss :: HasHighlightDoc c_axym => Lens' c_axym String
docTitle :: HasHighlightDoc c_axym => Lens' c_axym String

-- | Generate an HTML document from a title and a <a>HighlightedRope</a>.
doc :: String -> HighlightedRope -> HighlightDoc
instance ToMarkup HighlightDoc
instance HasHighlightDoc HighlightDoc
instance Pretty HighlightedRope
instance ToMarkup HighlightedRope
instance Ord (Located a)
instance Eq (Located a)
instance Monoid HighlightedRope
instance Semigroup HighlightedRope
instance HasBytes HighlightedRope
instance HasDelta HighlightedRope
instance HasHighlightedRope HighlightedRope


-- | The type for Lines will very likely change over time, to enable
--   drawing lit up multi-character versions of control characters for
--   <tt>^Z</tt>, <tt>^[</tt>, <tt><a>0xff</a></tt>, etc. This will make
--   for much nicer diagnostics when working with protocols.
module Text.Trifecta.Rendering
data Rendering
Rendering :: !Delta -> {-# UNPACK #-} !Int64 -> {-# UNPACK #-} !Int64 -> (Lines -> Lines) -> (Delta -> Lines -> Lines) -> Rendering
class HasRendering c_aBhe where renderingDelta = (.) rendering renderingDelta renderingLine = (.) rendering renderingLine renderingLineBytes = (.) rendering renderingLineBytes renderingLineLen = (.) rendering renderingLineLen renderingOverlays = (.) rendering renderingOverlays
rendering :: HasRendering c_aBhe => Lens' c_aBhe Rendering
renderingDelta :: HasRendering c_aBhe => Lens' c_aBhe Delta
renderingLine :: HasRendering c_aBhe => Lens' c_aBhe (Lines -> Lines)
renderingLineBytes :: HasRendering c_aBhe => Lens' c_aBhe Int64
renderingLineLen :: HasRendering c_aBhe => Lens' c_aBhe Int64
renderingOverlays :: HasRendering c_aBhe => Lens' c_aBhe (Delta -> Lines -> Lines)
nullRendering :: Rendering -> Bool
emptyRendering :: Rendering
class Source t
source :: Source t => t -> (Int64, Int64, Lines -> Lines)

-- | create a drawing surface
rendered :: Source s => Delta -> s -> Rendering
class Renderable t
render :: Renderable t => t -> Rendering
data Rendered a
(:@) :: a -> Rendering -> Rendered a

-- | <pre>
--   In file included from baz.c:9
--   In file included from bar.c:4
--   foo.c:8:36: note
--   int main(int argc, char ** argv) { int; }
--                                      ^
--   </pre>
data Caret
Caret :: !Delta -> {-# UNPACK #-} !ByteString -> Caret
class HasCaret t
caret :: HasCaret t => Lens' t Caret
data Careted a
(:^) :: a -> Caret -> Careted a
drawCaret :: Delta -> Delta -> Lines -> Lines
addCaret :: Delta -> Rendering -> Rendering
caretEffects :: [SGR]
renderingCaret :: Delta -> ByteString -> Rendering
data Span
Span :: !Delta -> !Delta -> {-# UNPACK #-} !ByteString -> Span
class HasSpan t
span :: HasSpan t => Lens' t Span
data Spanned a
(:~) :: a -> Span -> Spanned a
spanEffects :: [SGR]
drawSpan :: Delta -> Delta -> Delta -> Lines -> Lines

-- | <pre>
--   int main(int argc, char ** argv) { int; }
--                                      ^~~
--   </pre>
addSpan :: Delta -> Delta -> Rendering -> Rendering
data Fixit
Fixit :: {-# UNPACK #-} !Span -> !ByteString -> Fixit
_fixitSpan :: Fixit -> {-# UNPACK #-} !Span
_fixitReplacement :: Fixit -> !ByteString
class HasFixit c_aCAE where fixitReplacement = (.) fixit fixitReplacement fixitSpan = (.) fixit fixitSpan
fixit :: HasFixit c_aCAE => Lens' c_aCAE Fixit
fixitReplacement :: HasFixit c_aCAE => Lens' c_aCAE ByteString
fixitSpan :: HasFixit c_aCAE => Lens' c_aCAE Span
drawFixit :: Delta -> Delta -> String -> Delta -> Lines -> Lines
addFixit :: Delta -> Delta -> String -> Rendering -> Rendering
type Lines = Array (Int, Int64) ([SGR], Char)
draw :: [SGR] -> Int -> Int64 -> String -> Lines -> Lines
ifNear :: Delta -> (Lines -> Lines) -> Delta -> Lines -> Lines
(.#) :: (Delta -> Lines -> Lines) -> Rendering -> Rendering
instance Renderable Fixit
instance Reducer Fixit Rendering
instance Hashable Fixit
instance HasSpan Fixit
instance HasFixit Fixit
instance Typeable Caret
instance Typeable Careted
instance Typeable Span
instance Typeable Spanned
instance Typeable Fixit
instance Show a => Show (Rendered a)
instance Eq Caret
instance Ord Caret
instance Show Caret
instance Data Caret
instance Generic Caret
instance Eq a => Eq (Careted a)
instance Ord a => Ord (Careted a)
instance Show a => Show (Careted a)
instance Data a => Data (Careted a)
instance Generic (Careted a)
instance Eq Span
instance Ord Span
instance Show Span
instance Data Span
instance Generic Span
instance Eq a => Eq (Spanned a)
instance Ord a => Ord (Spanned a)
instance Show a => Show (Spanned a)
instance Data a => Data (Spanned a)
instance Generic (Spanned a)
instance Eq Fixit
instance Ord Fixit
instance Show Fixit
instance Data Fixit
instance Generic Fixit
instance Datatype D1Caret
instance Constructor C1_0Caret
instance Datatype D1Careted
instance Constructor C1_0Careted
instance Datatype D1Span
instance Constructor C1_0Span
instance Datatype D1Spanned
instance Constructor C1_0Spanned
instance Datatype D1Fixit
instance Constructor C1_0Fixit
instance Selector S1_0_0Fixit
instance Selector S1_0_1Fixit
instance Hashable a => Hashable (Spanned a)
instance Renderable (Spanned a)
instance Reducer (Spanned a) Rendering
instance Traversable Spanned
instance Foldable Spanned
instance ComonadApply Spanned
instance Comonad Spanned
instance Functor Spanned
instance HasSpan (Spanned a)
instance Hashable Span
instance Reducer Span Rendering
instance Semigroup Span
instance Renderable Span
instance HasSpan Span
instance Hashable a => Hashable (Careted a)
instance Reducer (Careted a) Rendering
instance Renderable (Careted a)
instance Traversable Careted
instance Foldable Careted
instance ComonadApply Careted
instance Comonad Careted
instance HasBytes (Careted a)
instance HasDelta (Careted a)
instance Functor Careted
instance HasCaret (Careted a)
instance Semigroup Caret
instance Reducer Caret Rendering
instance Renderable Caret
instance HasDelta Caret
instance HasBytes Caret
instance Hashable Caret
instance HasCaret Caret
instance Renderable (Rendered a)
instance Traversable Rendered
instance Foldable Rendered
instance ComonadApply Rendered
instance Comonad Rendered
instance HasBytes (Rendered a)
instance HasDelta (Rendered a)
instance Functor Rendered
instance Pretty Rendering
instance Source ByteString
instance Source String
instance Renderable Rendering
instance HasDelta Rendering
instance Monoid Rendering
instance Semigroup Rendering
instance Show Rendering
instance HasRendering Rendering


module Text.Trifecta.Combinators

-- | This class provides parsers with easy access to:
--   
--   1) the current line contents. 2) the current position as a
--   <a>Delta</a>. 3) the ability to use <a>sliced</a> on any parser.
class (MonadPlus m, TokenParsing m) => DeltaParsing m where rend = rendered <$> position <*> line restOfLine = drop . fromIntegral . columnByte <$> position <*> line
line :: DeltaParsing m => m ByteString
position :: DeltaParsing m => m Delta
slicedWith :: DeltaParsing m => (a -> ByteString -> r) -> m a -> m r
rend :: (DeltaParsing m, DeltaParsing m) => m Rendering
restOfLine :: (DeltaParsing m, DeltaParsing m) => m ByteString

-- | Run a parser, grabbing all of the text between its start and end
--   points and discarding the original result
sliced :: DeltaParsing m => m a -> m ByteString

-- | Grab a <a>Caret</a> pointing to the current location.
careting :: DeltaParsing m => m Caret

-- | Parse a <a>Careted</a> result. Pointing the <a>Caret</a> to where you
--   start.
careted :: DeltaParsing m => m a -> m (Careted a)

-- | Discard the result of a parse, returning a <a>Span</a> from where we
--   start to where it ended parsing.
spanning :: DeltaParsing m => m a -> m Span

-- | Parse a <a>Spanned</a> result. The <a>Span</a> starts here and runs to
--   the last position parsed.
spanned :: DeltaParsing m => m a -> m (Spanned a)

-- | Grab a fixit.
fixiting :: DeltaParsing m => m ByteString -> m Fixit

-- | This class is a refinement of <a>DeltaParsing</a> that adds the
--   ability to mark your position in the input and return there for
--   further parsing later.
class (DeltaParsing m, HasDelta d) => MarkParsing d m | m -> d
mark :: MarkParsing d m => m d
release :: MarkParsing d m => d -> m ()
instance (MonadPlus m, MarkParsing d m) => MarkParsing d (IdentityT m)
instance (MonadPlus m, MarkParsing d m, Monoid w) => MarkParsing d (RWST r w s m)
instance (MonadPlus m, MarkParsing d m, Monoid w) => MarkParsing d (RWST r w s m)
instance (MonadPlus m, MarkParsing d m, Monoid w) => MarkParsing d (WriterT w m)
instance (MonadPlus m, MarkParsing d m, Monoid w) => MarkParsing d (WriterT w m)
instance (MonadPlus m, MarkParsing d m) => MarkParsing d (ReaderT e m)
instance (MonadPlus m, MarkParsing d m) => MarkParsing d (StateT s m)
instance (MonadPlus m, MarkParsing d m) => MarkParsing d (StateT s m)
instance (MonadPlus m, DeltaParsing m) => DeltaParsing (IdentityT m)
instance (MonadPlus m, DeltaParsing m, Monoid w) => DeltaParsing (RWST r w s m)
instance (MonadPlus m, DeltaParsing m, Monoid w) => DeltaParsing (RWST r w s m)
instance (MonadPlus m, DeltaParsing m, Monoid w) => DeltaParsing (WriterT w m)
instance (MonadPlus m, DeltaParsing m, Monoid w) => DeltaParsing (WriterT w m)
instance (MonadPlus m, DeltaParsing m) => DeltaParsing (ReaderT e m)
instance (MonadPlus m, DeltaParsing m) => DeltaParsing (StateT s m)
instance (MonadPlus m, DeltaParsing m) => DeltaParsing (StateT s m)


-- | Results and Parse Errors
module Text.Trifecta.Result

-- | The result of parsing. Either we succeeded or something went wrong.
data Result a
Success :: a -> Result a
Failure :: Doc -> Result a

-- | A <a>Prism</a> that lets you embed or retrieve a <a>Result</a> in a
--   potentially larger type.
class AsResult s t a b | s -> a, t -> b, s b -> t, t a -> s
_Result :: AsResult s t a b => Prism s t (Result a) (Result b)

-- | The <a>Prism</a> for the <a>Success</a> constructor of <a>Result</a>
_Success :: AsResult s t a b => Prism s t a b

-- | The <a>Prism</a> for the <a>Failure</a> constructor of <a>Result</a>
_Failure :: AsResult s s a a => Prism' s Doc

-- | This is used to report an error. What went wrong, some supplemental
--   docs and a set of things expected at the current location. This does
--   not, however, include the actual location.
data Err
Err :: Maybe Doc -> [Doc] -> Set String -> Err
_reason :: Err -> Maybe Doc
_footnotes :: Err -> [Doc]
_expected :: Err -> Set String
class HasErr c_a19Cx where expected = (.) err expected footnotes = (.) err footnotes reason = (.) err reason
err :: HasErr c_a19Cx => Lens' c_a19Cx Err
expected :: HasErr c_a19Cx => Lens' c_a19Cx (Set String)
footnotes :: HasErr c_a19Cx => Lens' c_a19Cx [Doc]
reason :: HasErr c_a19Cx => Lens' c_a19Cx (Maybe Doc)
class Errable m
raiseErr :: Errable m => Err -> m a

-- | Convert a location and an <a>Err</a> into a <a>Doc</a>
explain :: Rendering -> Err -> Doc

-- | Generate a simple <a>Err</a> word-wrapping the supplied message.
failed :: String -> Err
instance Show a => Show (Result a)
instance Functor Result
instance Foldable Result
instance Traversable Result
instance Alternative Result
instance Applicative Result
instance Show a => Pretty (Result a)
instance AsResult (Result a) (Result b) a b
instance Monoid Err
instance Semigroup Err
instance HasErr Err


module Text.Trifecta.Parser
newtype Parser a
Parser :: (forall r. (a -> Err -> It Rope r) -> (Err -> It Rope r) -> (a -> Set String -> Delta -> ByteString -> It Rope r) -> (Doc -> It Rope r) -> Delta -> ByteString -> It Rope r) -> Parser a
unparser :: Parser a -> forall r. (a -> Err -> It Rope r) -> (Err -> It Rope r) -> (a -> Set String -> Delta -> ByteString -> It Rope r) -> (Doc -> It Rope r) -> Delta -> ByteString -> It Rope r
manyAccum :: (a -> [a] -> [a]) -> Parser a -> Parser [a]
data Step a
StepDone :: !Rope -> a -> Step a
StepFail :: !Rope -> Doc -> Step a
StepCont :: !Rope -> (Result a) -> (Rope -> Step a) -> Step a
feed :: Reducer t Rope => t -> Step r -> Step r
starve :: Step a -> Result a
stepParser :: Parser a -> Delta -> ByteString -> Step a
stepResult :: Rope -> Result a -> Step a
stepIt :: It Rope a -> Step a

-- | <tt>parseFromFile p filePath</tt> runs a parser <tt>p</tt> on the
--   input read from <tt>filePath</tt> using <a>readFile</a>. All
--   diagnostic messages emitted over the course of the parse attempt are
--   shown to the user on the console.
--   
--   <pre>
--   main = do
--     result &lt;- parseFromFile numbers "digits.txt"
--     case result of
--       Nothing -&gt; return ()
--       Just a  -&gt; print $ sum a
--   </pre>
parseFromFile :: MonadIO m => Parser a -> String -> m (Maybe a)

-- | <tt>parseFromFileEx p filePath</tt> runs a parser <tt>p</tt> on the
--   input read from <tt>filePath</tt> using <a>readFile</a>. Returns all
--   diagnostic messages emitted over the course of the parse and the
--   answer if the parse was successful.
--   
--   <pre>
--   main = do
--     result &lt;- parseFromFileEx (many number) "digits.txt"
--     case result of
--       Failure xs -&gt; displayLn xs
--       Success a  -&gt; print (sum a)
--   </pre>
parseFromFileEx :: MonadIO m => Parser a -> String -> m (Result a)
parseString :: Parser a -> Delta -> String -> Result a

-- | <tt>parseByteString p delta i</tt> runs a parser <tt>p</tt> on
--   <tt>i</tt>.
parseByteString :: Parser a -> Delta -> ByteString -> Result a
parseTest :: (MonadIO m, Show a) => Parser a -> String -> m ()
instance Functor Step
instance Show a => Show (Step a)
instance MarkParsing Delta Parser
instance DeltaParsing Parser
instance TokenParsing Parser
instance CharParsing Parser
instance LookAheadParsing Parser
instance Errable Parser
instance Parsing Parser
instance MonadPlus Parser
instance Monad Parser
instance Monoid a => Monoid (Parser a)
instance Semigroup a => Semigroup (Parser a)
instance Alternative Parser
instance Applicative Parser
instance Functor Parser


module Text.Trifecta
