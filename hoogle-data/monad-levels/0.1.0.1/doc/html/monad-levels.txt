-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Specific levels of monad transformers
--   
@package monad-levels
@version 0.1.0.1


module Control.Monad.Levels.Constraints

-- | Lift a value of the satisfying monad to the top of the tower.
liftSat :: SatisfyConstraint c m => Proxy c -> SatMonad c m a -> m a

-- | Lower a function from the top of the monad tower down to the
--   satisfying monad in which it can be applied.
lowerSat :: SatisfyConstraintF c m a f => Proxy c -> Proxy f -> Proxy m -> Proxy a -> SatFunction c f m a -> VarFunction f m a

-- | A variant of <a>lowerSat</a> for when <tt>CanLower f m a ~ ()</tt>.
lowerSat' :: (SatisfyConstraint c m, VariadicFunction f) => Proxy c -> Proxy f -> Proxy m -> Proxy a -> (() :- CanLower f m a) -> SatFunction c f m a -> VarFunction f m a

-- | A specialised instance of <a>lowerSat</a> where a simple function of
--   type <tt>m a -&gt; m a</tt> is lowered to the satisfying monad.
lowerFunction :: SatisfyConstraint c m => Proxy c -> (SatMonadValue c m a -> SatMonadValue c m a) -> m a -> m a

-- | For a specified constraint <tt>c</tt> and <a>MonadTower</a>
--   <tt>m</tt>, <tt>SatisfyConstraint c m</tt> specifies that it is
--   possible to reach a monad in the tower that specifies the constraint.
type SatisfyConstraint c m = (SatisfyConstraint_ (SatDepth c m) c m, c (SatMonad c m), BaseMonad (SatMonad c m) ~ BaseMonad m)

-- | An extension of <a>SatisfyConstraint</a> that also ensures that any
--   additional constraints needed to satisfy a <a>VariadicFunction</a>
--   <tt>f</tt> to achieve an end result based upon the type <tt>m a</tt>
--   are met.
type SatisfyConstraintF c m a f = (SatisfyConstraint c m, VariadicFunction f, CanLowerFunc f c m a)

-- | The Monad in the tower that satisfies the provided constraint.
type SatMonad (c :: (* -> *) -> Constraint) (m :: * -> *) = SatMonad_ (SatDepth c m) c m

-- | Converts <tt>m a</tt> into what the value in the monadic stack is
--   where the monad satisfies the provided constraint.
type SatMonadValue c m a = SatMonad_ (SatDepth c m) c m (SatValue_ (SatDepth c m) c m a)

-- | Any additional constraints that may be needed for a specified
--   <a>VariadicFunction</a> to be valid as it is lowered to the satisfying
--   monad.
--   
--   This typically matters only if <a>ValueOnly</a> or <a>MonadicOther</a>
--   are used.
type CanLowerFunc f c m a = CanLowerFunc_ f (SatDepth c m) c m a

-- | The type of the <a>VariadicFunction</a> <tt>f</tt> when the provided
--   constraint is satisfied.
type SatFunction c f m a = VarFunctionSat f (SatDepth c m) c m a

-- | When considering whether a particular monad within a <a>MonadTower</a>
--   stack satisfies a constraint, we need to be able to determine this at
--   the type level.
--   
--   This is achieved with the <a>ConstraintSatisfied</a> associated type:
--   it should be equated to a closed type family with the result being
--   <a>True</a> for all monads for which the constraint is satisfied and
--   <a>False</a> for all others.
--   
--   (This is defined as a type class rather than just a type family so
--   that we can explicitly state that this needs to be defined.)
class ValidConstraint (c :: (* -> *) -> Constraint) where type family ConstraintSatisfied c (m :: * -> *) :: Bool

-- | Indicates whether a specified constraint is allowed to pass through a
--   particular level.
--   
--   (It may not be recognisable in Haddock documentation, but the
--   <tt>b</tt> parameter is of kind <tt><a>Bool</a></tt> using the
--   <tt>DataKinds</tt> extension).
--   
--   By default, for all monad levels this is set to the value of
--   <a>DefaultAllowConstraints</a> for all constraints, with the exception
--   of <a>IsBaseMonad</a> for which it is set to <a>True</a>.
--   
--   Instances of this class can - and should when appropriate - be
--   overlapped/overriden.
class (ValidConstraint c, MonadLevel m) => ConstraintPassThrough c m (b :: Bool)

-- | Inductively find the "floor" in the <a>MonadTower</a> where the
--   specified constraint is satisfied.
--   
--   This class is only exported for documentation purposes: no other
--   instances are possible, and most of the internals are not safe to use
--   outside of this module.
--   
--   You should use <a>SatisfyConstraint</a> instead of this in your
--   constraints.
class (ValidConstraint c, MonadTower m) => SatisfyConstraint_ (n :: Nat) c m where type family SatMonad_ n c m :: * -> * type family SatValue_ n c m a type family CanLowerFunc_ f n c m a :: Constraint

-- | Calculate how many levels down is the satisfying monad.
type SatDepth (c :: (* -> *) -> Constraint) (m :: * -> *) = FindTrue (TrySatisfy c m)

-- | Whilst <a>MonadLevel</a> requires <tt>CanUnwrap m a a</tt> for all
--   <tt>a</tt>, the type system can't always determine this. This is a
--   helper function to do so.
proofInst :: MonadLevel m => Proxy m -> Proxy a -> (MonadLevel m :- CanUnwrap m a a)

-- | A function composed of variadic arguments that produces a value based
--   upon the type <tt>m a</tt>.
class VariadicLower f => VariadicFunction f where type family VarFunction f (m :: * -> *) a

-- | Base class for dealing with variadic functions/arguments.
class VariadicLower v where type family LowerV v (m :: * -> *) :: * type family SatV v (n :: Nat) (c :: (* -> *) -> Constraint) (m :: * -> *) :: * type family CanLower v (m :: * -> *) a :: Constraint type instance LowerV v m = v type instance SatV v n c m = v type instance CanLower v m a = ()

-- | The function represented by the <a>VariadicFunction</a> when lowered
--   to the satisfying monad.
type VarFunctionSat f n c m a = VarFunction (SatV f n c m) (SatMonad_ n c m) (SatValue_ n c m a)

-- | The fundamental way of creating a <a>VariadicFunction</a>. <tt>MkVarFn
--   v</tt> corresponds to a function of type <tt><a>VariadicType</a> v m a
--   -&gt; m a</tt> for some specified <tt>m a</tt>.
--   
--   If more than one argument is needed for a function, they can be
--   prepended on using <a>Func</a>.
type MkVarFn v = Func v (MkVarFnFrom MonadicValue)

-- | The result of a <a>VariadicFunction</a>. This can't be used on its
--   own, and needs to have at least one <a>Func</a> attached to it.
data MkVarFnFrom va

-- | Represents the function <tt>v1 -&gt; v2</tt>.
data Func (v1 :: *) (v2 :: *)

-- | Class representing arguments/parameters for lower-able variadic
--   functions.
--   
--   When considering a function with an end result based upon <tt>m
--   a</tt>, the following argument types are available:
--   
--   <ul>
--   <li><i><tt><a>ValueOnly</a></tt></i> corresponds to <tt>a</tt>.</li>
--   <li><i><tt><a>Const</a> b</tt></i> corresponds to some other type
--   <tt>b</tt>.</li>
--   <li><i><tt><a>MonadicValue</a></tt></i> corresponds to <tt>m
--   a</tt>.</li>
--   <li><i><tt><a>MonadicOther</a> b</tt></i> corresponds to <tt>m
--   b</tt>.</li>
--   <li><i><tt><a>MonadicTuple</a> b</tt></i> corresponds to <tt>m
--   (a,b)</tt>.</li>
--   <li><i><tt><a>Func</a> v1 v2</tt></i> corresponds to <tt>v1 -&gt;
--   v2</tt>.</li>
--   </ul>
class VariadicLower v => VariadicArg v where type family VariadicType v (m :: * -> *) a validSatArg0 _ _ _ = Sub Dict validSatArg _ _ _ _ = Sub Dict

-- | Variadic arguments that can be lowered. All <a>VariadicArg</a> values
--   are instances of this class.
--   
--   This actually defines how a variadic argument is lowered down to the
--   <a>LowerMonad</a>.
class VariadicArg v => LowerableVArg v where validLowerArg _ _ = Sub Dict

-- | In contrast to <a>LowerableVArg</a>, this class is for
--   <a>VariadicArg</a> values that can be <i>lifted</i> from the
--   <a>LowerMonad</a>.
--   
--   This is important for <tt><a>Func</a> v1 v2</tt> arguments, as to
--   lower a function we need to <i>lift</i> <tt>v1</tt> before applying
--   the function, and then subsequently lower the result.
--   
--   All instances of <a>VariadicArg</a> are instances of this with the
--   exception of <a>ValueOnly</a> (as it's not always possible to convert
--   an arbitrary <tt><a>InnerValue</a> m a</tt> back into an <tt>a</tt>).
class VariadicArg v => LiftableVArg v where validLiftArg _ _ = Sub Dict

-- | Variadic arguments that can be lifted via a call to <a>wrap</a>. Only
--   those that have a <a>VariadicType</a> that is a monadic value can thus
--   be instances of this class.
class LiftableVArg v => WrappableVArg v where validWrapArg _ _ = Sub Dict

-- | This corresponds to <tt>a</tt> when the final result is based upon
--   <tt>m a</tt>. This requires the extra constraint of
--   <tt><a>CanAddInternal</a> m</tt>.
data ValueOnly

-- | A constant type that does not depend upon the current monadic context.
--   That is, <tt>Const b</tt> corresponds to just <tt>b</tt>. It is kept
--   as-is when lowering through the different levels.
data Const (b :: *)

-- | Corresponds to <tt>m a</tt>.
data MonadicValue

-- | Corresponds to <tt>m b</tt>, where the final result is based upon
--   <tt>m a</tt>. This requires the extra constraint of
--   <tt><a>CanUnwrap</a> m a b</tt>.
data MonadicOther b

-- | Corresponds to <tt>m (a,b)</tt>. This requires the extra constraints
--   of <tt><a>CanAddInternal</a> m</tt> and <tt><a>AllowOtherValues</a> m
--   ~ True</tt> (This is used instead of <a>CanUnwrap</a> as a
--   simplification).
data MonadicTuple b

-- | A concrete, poly-kinded proxy type
data Proxy (t :: k) :: k -> *
Proxy :: Proxy
instance (LowerableVArg va, VariadicFunction vf) => VariadicFunction (Func va vf)
instance WrappableVArg va => VariadicFunction (MkVarFnFrom va)
instance VariadicLower va => VariadicLower (MkVarFnFrom va)
instance (LowerableVArg va, LiftableVArg vb) => LiftableVArg (Func va vb)
instance (LiftableVArg va, LowerableVArg vb) => LowerableVArg (Func va vb)
instance (VariadicArg va, VariadicArg vb) => VariadicArg (Func va vb)
instance (VariadicLower a, VariadicLower b) => VariadicLower (Func a b)
instance LowerableVArg ValueOnly
instance VariadicArg ValueOnly
instance VariadicLower ValueOnly
instance WrappableVArg (MonadicTuple b)
instance LiftableVArg (MonadicTuple b)
instance Monoid b => LowerableVArg (MonadicTuple b)
instance VariadicArg (MonadicTuple b)
instance VariadicLower (MonadicTuple b)
instance WrappableVArg (MonadicOther b)
instance LiftableVArg (MonadicOther b)
instance LowerableVArg (MonadicOther b)
instance VariadicArg (MonadicOther b)
instance VariadicLower (MonadicOther b)
instance WrappableVArg MonadicValue
instance LiftableVArg MonadicValue
instance LowerableVArg MonadicValue
instance VariadicArg MonadicValue
instance VariadicLower MonadicValue
instance LiftableVArg (Const b)
instance LowerableVArg (Const b)
instance VariadicArg (Const b)
instance VariadicLower (Const b)
instance (ConstraintPassThrough c m 'True, SatisfyConstraint_ n c (LowerMonad m)) => SatisfyConstraint_ ('Suc n) c m
instance (ValidConstraint c, MonadTower m, c m) => SatisfyConstraint_ 'Zero c m


module Control.Monad.Levels.Transformers

-- | Unlike <tt>HasBaseMonad</tt>, this is not a universal constraint
--   applicable to all <a>MonadLevel</a> instances, as otherwise it can be
--   used to bypass the lack of an allowed constraint.
type HasTransformer t m = (SatisfyConstraint (IsTransformer t) m, MonadLevel (TransformedMonad t m), TransformedMonad t m ~ t (LowerMonad (TransformedMonad t m)))

-- | The sub-part of the monadic stack where the requested transformer is
--   on top.
type TransformedMonad t m = SatMonad (IsTransformer t) m
liftT :: HasTransformer t m => TransformedMonad t m a -> m a
class (MonadLevel m, m ~ t (LowerMonad m), t (LowerMonad m) ~ m) => IsTransformer t m
instance (MonadLevel m) => ConstraintPassThrough (IsTransformer (StateT s)) (ListT m) 'True
instance (MonadLevel m) => ConstraintPassThrough (IsTransformer (StateT s)) (ContT r m) 'True
instance (MonadLevel m) => ConstraintPassThrough (IsTransformer (StateT s)) (ListT m) 'True
instance (MonadLevel m) => ConstraintPassThrough (IsTransformer (StateT s)) (ContT r m) 'True
instance (MonadLevel m) => ConstraintPassThrough (IsTransformer (ReaderT r)) (ListT m) 'True
instance (MonadLevel m) => ConstraintPassThrough (IsTransformer (ReaderT r)) (ContT c m) 'True
instance (MonadLevel m) => ConstraintPassThrough (IsTransformer (ExceptT e)) (ListT m) 'True
instance (MonadLevel m) => ConstraintPassThrough (IsTransformer (ContT r)) (ListT m) 'True
instance ValidConstraint (IsTransformer t)
instance (MonadLevel m, m ~ t (LowerMonad m), t (LowerMonad m) ~ m) => IsTransformer t m


module Control.Monad.Levels

-- | Monads in a monadic stack.
--   
--   For monads that are <i>not</i> instances of <tt>MonadicLevel_</tt>
--   then it suffices to say <tt>instance MonadTower_ MyMonad</tt>; for
--   levels it is required to define <a>BaseMonad</a> (typically
--   recursively).
--   
--   You should use <a>MonadTower</a> in any constraints rather than this
--   class. This includes when writing instances of <a>MonadTower_</a> for
--   monadic transformers.
class (Applicative m, Monad m) => MonadTower_ m where type family BaseMonad m :: * -> * type instance BaseMonad m = m

-- | This is <a>MonadTower_</a> with additional sanity constraints to
--   ensure that applying <a>BaseMonad</a> is idempotent.
type MonadTower m = (MonadTower_ m, MonadTower_ (BaseMonad m), BaseMonad (BaseMonad m) ~ BaseMonad m, BaseMonad m ~ BaseMonad (BaseMonad m))

-- | How to handle wrappers around existing <a>MonadTower</a> instances.
--   
--   For newtype wrappers (e.g. <a>IdentityT</a>), it is sufficient to only
--   define <a>LowerMonad</a>.
--   
--   You should use <a>MonadLevel</a> rather than this class in
--   constraints.
class (MonadTower m, MonadTower (LowerMonad m), BaseMonad m ~ BaseMonad (LowerMonad m), BaseMonad (LowerMonad m) ~ BaseMonad m, CanAddInternalM m) => MonadLevel_ m where type family LowerMonad m :: * -> * type family InnerValue m a :: * type family WithLower_ m :: (* -> *) -> * -> * type family AllowOtherValues m :: Bool type family DefaultAllowConstraints m :: Bool type instance InnerValue m a = a type instance WithLower_ m = AddIdent type instance AllowOtherValues m = True type instance DefaultAllowConstraints m = True wrap = coerceWrap
wrap :: (MonadLevel_ m, CanUnwrap m a b) => Proxy a -> (Unwrapper m a (LowerMonadValue m b)) -> m b

-- | This is <a>MonadLevel_</a> with some additional sanity constraints.
type MonadLevel m = (MonadLevel_ m, (Forall (CanUnwrapSelf m), WithLowerC m))

-- | A continuation function to produce a value of type <tt>t</tt>.
type Unwrapper m a t = (forall b. CanUnwrap m a b => m b -> LowerMonadValue m b) -> (WithLower m a) -> t

-- | The value contained within the actual level (e.g. for
--   <tt><a>StateT</a> s m a</tt>, this is equivalent to <tt>m (a,s)</tt>).
type LowerMonadValue m a = LowerMonad m (InnerValue m a)
type WithLower m = WithLower_ m m

-- | If we're dealing overall with <tt>m a</tt>, then this allows us to
--   specify those <tt>b</tt> values for which we can also manipulate <tt>m
--   b</tt>.
--   
--   If <tt><a>AllowOtherValues</a> m ~ False</tt> then we require that
--   <tt>a ~ b</tt>; otherwise, any <tt>b</tt> is accepted.
class (MonadLevel_ m, CanUnwrap_ m a b) => CanUnwrap m a b

-- | Used to ensure that for all monad levels, <tt>CanUnwrap m a a</tt> is
--   satisfied.
class (MonadLevel_ m, CanUnwrap m a a) => CanUnwrapSelf m a
type WithLowerC m = AddConstraint (WithLower_ m) m
class AddInternalM (ai :: (* -> *) -> * -> *) where type family AddConstraint ai (m :: * -> *) :: Constraint type instance AddConstraint ai m = ()
addInternalM :: (AddInternalM ai, MonadLevel m, WithLower_ m ~ ai, CanUnwrap m a b) => ai m a -> LowerMonad m b -> LowerMonadValue m b
type CanAddInternalM m = AddInternalM (WithLower_ m)

-- | Used for monad transformers like <a>ContT</a> where it is not possible
--   to manipulate the internal value without considering the monad that it
--   is within.
newtype AddIM m a
AddIM :: (forall b. CanUnwrap m a b => LowerMonad m b -> LowerMonadValue m b) -> AddIM m a
addIMFunc :: AddIM m a -> forall b. CanUnwrap m a b => LowerMonad m b -> LowerMonadValue m b
class AddInternalM ai => AddInternal ai
addInternal :: (AddInternal ai, MonadLevel m, WithLower_ m ~ ai, CanUnwrap m a b) => ai m a -> b -> InnerValue m b
mapInternal :: (AddInternal ai, MonadLevel m, WithLower_ m ~ ai, CanUnwrap m a b, CanUnwrap m a c) => ai m a -> (b -> c) -> InnerValue m b -> InnerValue m c
type CanAddInternal m = AddInternal (WithLower_ m)

-- | In most cases you will want to use <a>AddIG</a> instead of this; this
--   is defined for cases like <a>ListT</a> where it may not be possible to
--   obtain either zero or one value for use with <a>getInternal</a>.
data AddI m a
AddI :: (forall b. CanUnwrap m a b => b -> InnerValue m b) -> (forall b c. (CanUnwrap m a b, CanUnwrap m a c) => (b -> c) -> InnerValue m b -> InnerValue m c) -> AddI m a
setIFunc :: AddI m a -> forall b. CanUnwrap m a b => b -> InnerValue m b
mapIFunc :: AddI m a -> forall b c. (CanUnwrap m a b, CanUnwrap m a c) => (b -> c) -> InnerValue m b -> InnerValue m c

-- | Used for monad transformers where <tt><a>InnerValue</a> m a ~ a</tt>.
data AddIdent (m :: * -> *) a
AddIdent :: AddIdent a
class AddInternal ai => GetInternal ai
getInternal :: (GetInternal ai, MonadLevel m, WithLower_ m ~ ai, CanUnwrap m a b) => ai m a -> c -> (b -> c) -> InnerValue m b -> c
type CanGetInternal m = GetInternal (WithLower_ m)

-- | Used for monad transformers where it is possible to consider the
--   <a>InnerValue</a> in isolation. If <tt>InnerValue m a ~ a</tt> then
--   use <a>AddIdent</a> instead.
data AddIG m a
AddIG :: (forall b. CanUnwrap m a b => b -> InnerValue m b) -> (forall b c. (CanUnwrap m a b, CanUnwrap m a c) => (b -> c) -> InnerValue m b -> InnerValue m c) -> (forall b c. CanUnwrap m a b => c -> (b -> c) -> InnerValue m b -> c) -> AddIG m a
setIUFunc :: AddIG m a -> forall b. CanUnwrap m a b => b -> InnerValue m b
mapIUFunc :: AddIG m a -> forall b c. (CanUnwrap m a b, CanUnwrap m a c) => (b -> c) -> InnerValue m b -> InnerValue m c
getIUFunc :: AddIG m a -> forall b c. CanUnwrap m a b => c -> (b -> c) -> InnerValue m b -> c
lift :: MonadLevel m => LowerMonad m a -> m a
class (MonadTower m, m ~ BaseMonad m, BaseMonad m ~ m) => IsBaseMonad m

-- | Ideally, this alias would not be needed as every instance of
--   <a>MonadTower</a> should satisfy the required constraint. However,
--   this is needed for technical reasons.
type HasBaseMonad m = SatisfyConstraint IsBaseMonad m
liftBase :: HasBaseMonad m => BaseMonad m a -> m a
type BaseMonadOf b m = (HasBaseMonad m, BaseMonad m ~ b, b ~ BaseMonad m)

-- | An alias defined for convenience with existing code.
liftIO :: BaseMonadOf IO m => IO a -> m a

-- | Unlike <tt>HasBaseMonad</tt>, this is not a universal constraint
--   applicable to all <a>MonadLevel</a> instances, as otherwise it can be
--   used to bypass the lack of an allowed constraint.
type HasTransformer t m = (SatisfyConstraint (IsTransformer t) m, MonadLevel (TransformedMonad t m), TransformedMonad t m ~ t (LowerMonad (TransformedMonad t m)))

-- | The sub-part of the monadic stack where the requested transformer is
--   on top.
type TransformedMonad t m = SatMonad (IsTransformer t) m
liftT :: HasTransformer t m => TransformedMonad t m a -> m a


-- | This module allows inclusion of <a>ContT</a> into your monad stack so
--   as to represent continuation-passing style (CPS) computations.
--   
--   Note that the behaviour of some monad transformers and how they deal
--   with continuations differs from how <a>mtl</a> handles them. For
--   example, with a lazy state transformer, using this module results in
--   <a>liftCallCC</a>, whereas <tt>mtl</tt> uses <a>liftCallCC'</a>.
module Control.Monad.Levels.Cont

-- | <tt>callCC</tt> (call-with-current-continuation) calls a function with
--   the current continuation as its argument.
callCC :: HasCont m a b => ((a -> m b) -> m a) -> m a

-- | The continuation monad transformer. Can be used to add continuation
--   handling to other monads.
newtype ContT r (m :: * -> *) a :: * -> (* -> *) -> * -> *
ContT :: ((a -> m r) -> m r) -> ContT r a
runContT :: ContT r a -> (a -> m r) -> m r

-- | Represents monad stacks that can successfully pass <a>callCC</a> down
--   to a <a>ContT</a> transformer.
type HasCont m a b = SatisfyConstraintF IsCont m a (ContFn b)

-- | A simple class just to match up with the <a>ContT</a> monad
--   transformer.
class MonadLevel m => IsCont m

-- | This corresponds to <a>CallCC</a> in <tt>transformers</tt>.
type ContFn b = MkVarFn (Func (Func ValueOnly (MonadicOther b)) MonadicValue)
instance (MonadTower m) => ConstraintPassThrough IsCont (ListT m) 'True
instance ValidConstraint IsCont
instance (MonadTower m) => IsCont (ContT r m)


-- | Computations which may fail or throw exceptions.
module Control.Monad.Levels.Except

-- | Begin exception processing.
throwError :: HasError e m => e -> m a

-- | Handle exception processing.
catchError :: HasError e m => m a -> (e -> m a) -> m a

-- | A monad transformer that adds exceptions to other monads.
--   
--   <tt>ExceptT</tt> constructs a monad parameterized over two things:
--   
--   <ul>
--   <li>e - The exception type.</li>
--   <li>m - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function yields a computation that produces the
--   given value, while <tt>&gt;&gt;=</tt> sequences two subcomputations,
--   exiting on the first exception.
newtype ExceptT e (m :: * -> *) a :: * -> (* -> *) -> * -> *
ExceptT :: m (Either e a) -> ExceptT e a

-- | A monad stack that can throw and handle exceptions of type <tt>e</tt>.
type HasError e m = SatisfyConstraint (IsError e) m

-- | Constraint for monads that can throw and handle exceptions.
class MonadTower m => IsError e m
instance (MonadTower m) => ConstraintPassThrough (IsError e) (ListT m) 'True
instance ValidConstraint (IsError e)
instance (MonadTower m) => IsError e (ExceptT e m)
instance IsError e (Either e)
instance IsError IOException IO


-- | Provides a shared environment for reading values and executing
--   sub-computations in a modified environment.
module Control.Monad.Levels.Reader

-- | Obtain the reader environment.
ask :: HasReader r m => m r

-- | Retrieve a function of the current environment. An alias of
--   <a>reader</a>.
asks :: HasReader r m => (r -> a) -> m a

-- | Retrieve a function of the current environment.
reader :: HasReader r m => (r -> a) -> m a

-- | Execute a computation in a modified environment.
local :: HasReader r m => (r -> r) -> m a -> m a

-- | The reader monad transformer, which adds a read-only environment to
--   the given monad.
--   
--   The <a>return</a> function ignores the environment, while
--   <tt>&gt;&gt;=</tt> passes the inherited environment to both
--   subcomputations.
newtype ReaderT r (m :: * -> *) a :: * -> (* -> *) -> * -> *
ReaderT :: (r -> m a) -> ReaderT r a
runReaderT :: ReaderT r a -> r -> m a

-- | A monad stack containing a Reader environment of type <tt>r</tt>.
type HasReader r m = SatisfyConstraint (IsReader r) m

-- | The minimal definitions needed by a monad providing a Reader
--   environment.
class MonadTower m => IsReader r m
instance (MonadTower m) => ConstraintPassThrough (IsReader r) (ListT m) 'True
instance (MonadTower m) => ConstraintPassThrough (IsReader r) (ContT c m) 'True
instance (MonadTower m, Monoid w) => IsReader r (RWST r w s m)
instance (MonadTower m, Monoid w) => IsReader r (RWST r w s m)
instance IsReader r ((->) r)
instance (MonadTower m) => IsReader r (ReaderT r m)
instance ValidConstraint (IsReader r)


-- | Monad environments for stateful computations.
module Control.Monad.Levels.State

-- | Embed a simple state action into the monad stack.
state :: HasState s m => (s -> (a, s)) -> m a

-- | Obtain the state environment.
get :: HasState s m => m s

-- | Apply a function to the stateful environment. Equivalent to <tt>fmap f
--   <a>get</a></tt>.
gets :: HasState s m => (s -> a) -> m a

-- | Replace the stateful environment.
put :: HasState s m => s -> m ()

-- | Map the old state to a new state, and discard the old one. Equivalent
--   to <tt><a>gets</a> f &gt;&gt;= <a>put</a></tt>.
modify :: HasState s m => (s -> s) -> m ()

-- | A variant of <a>modify</a> in which the computation is strict in the
--   new state.
modify' :: HasState s m => (s -> s) -> m ()

-- | A monad stack containing a stateful environment of type <tt>s</tt>.
type HasState s m = SatisfyConstraint (IsState s) m

-- | The minimal definition needed for a monad providing a stateful
--   environment.
class MonadTower m => IsState s m
instance (MonadTower m) => ConstraintPassThrough (IsState s) (ListT m) 'True
instance (MonadTower m) => ConstraintPassThrough (IsState s) (ContT r m) 'True
instance (MonadTower m, Monoid w) => IsState s (RWST r w s m)
instance (MonadTower m, Monoid w) => IsState s (RWST r w s m)
instance (MonadTower m) => IsState s (StateT s m)
instance (MonadTower m) => IsState s (StateT s m)
instance ValidConstraint (IsState s)


-- | Lazy stateful computations.
module Control.Monad.Levels.State.Lazy

-- | Embed a simple state action into the monad stack.
state :: HasState s m => (s -> (a, s)) -> m a

-- | Obtain the state environment.
get :: HasState s m => m s

-- | Apply a function to the stateful environment. Equivalent to <tt>fmap f
--   <a>get</a></tt>.
gets :: HasState s m => (s -> a) -> m a

-- | Replace the stateful environment.
put :: HasState s m => s -> m ()

-- | Map the old state to a new state, and discard the old one. Equivalent
--   to <tt><a>gets</a> f &gt;&gt;= <a>put</a></tt>.
modify :: HasState s m => (s -> s) -> m ()

-- | A variant of <a>modify</a> in which the computation is strict in the
--   new state.
modify' :: HasState s m => (s -> s) -> m ()

-- | A state transformer monad parameterized by:
--   
--   <ul>
--   <li><tt>s</tt> - The state.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
newtype StateT s (m :: * -> *) a :: * -> (* -> *) -> * -> *
StateT :: (s -> m (a, s)) -> StateT s a
runStateT :: StateT s a -> s -> m (a, s)

-- | A monad stack containing a stateful environment of type <tt>s</tt>.
type HasState s m = SatisfyConstraint (IsState s) m

-- | The minimal definition needed for a monad providing a stateful
--   environment.
class MonadTower m => IsState s m


-- | Strict stateful computations.
module Control.Monad.Levels.State.Strict

-- | Embed a simple state action into the monad stack.
state :: HasState s m => (s -> (a, s)) -> m a

-- | Obtain the state environment.
get :: HasState s m => m s

-- | Apply a function to the stateful environment. Equivalent to <tt>fmap f
--   <a>get</a></tt>.
gets :: HasState s m => (s -> a) -> m a

-- | Replace the stateful environment.
put :: HasState s m => s -> m ()

-- | Map the old state to a new state, and discard the old one. Equivalent
--   to <tt><a>gets</a> f &gt;&gt;= <a>put</a></tt>.
modify :: HasState s m => (s -> s) -> m ()

-- | A variant of <a>modify</a> in which the computation is strict in the
--   new state.
modify' :: HasState s m => (s -> s) -> m ()

-- | A state transformer monad parameterized by:
--   
--   <ul>
--   <li><tt>s</tt> - The state.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function leaves the state unchanged, while
--   <tt>&gt;&gt;=</tt> uses the final state of the first computation as
--   the initial state of the second.
newtype StateT s (m :: * -> *) a :: * -> (* -> *) -> * -> *
StateT :: (s -> m (a, s)) -> StateT s a
runStateT :: StateT s a -> s -> m (a, s)

-- | A monad stack containing a stateful environment of type <tt>s</tt>.
type HasState s m = SatisfyConstraint (IsState s) m

-- | The minimal definition needed for a monad providing a stateful
--   environment.
class MonadTower m => IsState s m


module Control.Monad.Levels.Writer

-- | Embed a simple writer action.
writer :: HasWriter w m => (a, w) -> m a

-- | An action that produces the output <tt>w</tt>.
tell :: HasWriter w m => w -> m ()
type HasWriter w m = (Monoid w, SatisfyConstraint (IsWriter w) m)

-- | Execute the action <tt>m</tt> and add its output to the value of the
--   computation.
listen :: CanListen w m a => m a -> m (a, w)
type CanListen w m a = SatisfyConstraintF (IsWriter w) m a (ListenFn w)
type ListenFn w = Func MonadicValue (MkVarFnFrom (MonadicTuple w))

-- | Execute the action <tt>m</tt> (which returns a value and a function)
--   and returns the value, applying the function to the output.
pass :: CanPass w m a => m (a, w -> w) -> m a
type CanPass w m a = SatisfyConstraintF (IsWriter w) m a (PassFn w)
type PassFn w = MkVarFn (MonadicTuple (Endo w))

-- | The minimal definition needed for a monad providing a writer
--   environment.
class (Monoid w, MonadTower m) => IsWriter w m
instance Monoid w => ValidConstraint (IsWriter w)
instance (Monoid w, MonadTower m) => IsWriter w (RWST r w s m)
instance (Monoid w, MonadTower m) => IsWriter w (RWST r w s m)
instance (Monoid w, MonadTower m) => IsWriter w (WriterT w m)
instance (Monoid w, MonadTower m) => IsWriter w (WriterT w m)


module Control.Monad.Levels.Writer.Lazy

-- | Embed a simple writer action.
writer :: HasWriter w m => (a, w) -> m a

-- | An action that produces the output <tt>w</tt>.
tell :: HasWriter w m => w -> m ()
type HasWriter w m = (Monoid w, SatisfyConstraint (IsWriter w) m)

-- | Execute the action <tt>m</tt> and add its output to the value of the
--   computation.
listen :: CanListen w m a => m a -> m (a, w)
type CanListen w m a = SatisfyConstraintF (IsWriter w) m a (ListenFn w)
type ListenFn w = Func MonadicValue (MkVarFnFrom (MonadicTuple w))

-- | Execute the action <tt>m</tt> (which returns a value and a function)
--   and returns the value, applying the function to the output.
pass :: CanPass w m a => m (a, w -> w) -> m a
type CanPass w m a = SatisfyConstraintF (IsWriter w) m a (PassFn w)
type PassFn w = MkVarFn (MonadicTuple (Endo w))

-- | A writer monad parameterized by:
--   
--   <ul>
--   <li><tt>w</tt> - the output to accumulate.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <tt>&gt;&gt;=</tt> combines the outputs of the subcomputations using
--   <a>mappend</a>.
newtype WriterT w (m :: * -> *) a :: * -> (* -> *) -> * -> *
WriterT :: m (a, w) -> WriterT w a
runWriterT :: WriterT w a -> m (a, w)

-- | The minimal definition needed for a monad providing a writer
--   environment.
class (Monoid w, MonadTower m) => IsWriter w m


module Control.Monad.Levels.Writer.Strict

-- | Embed a simple writer action.
writer :: HasWriter w m => (a, w) -> m a

-- | An action that produces the output <tt>w</tt>.
tell :: HasWriter w m => w -> m ()
type HasWriter w m = (Monoid w, SatisfyConstraint (IsWriter w) m)

-- | Execute the action <tt>m</tt> and add its output to the value of the
--   computation.
listen :: CanListen w m a => m a -> m (a, w)
type CanListen w m a = SatisfyConstraintF (IsWriter w) m a (ListenFn w)
type ListenFn w = Func MonadicValue (MkVarFnFrom (MonadicTuple w))

-- | Execute the action <tt>m</tt> (which returns a value and a function)
--   and returns the value, applying the function to the output.
pass :: CanPass w m a => m (a, w -> w) -> m a
type CanPass w m a = SatisfyConstraintF (IsWriter w) m a (PassFn w)
type PassFn w = MkVarFn (MonadicTuple (Endo w))

-- | A writer monad parameterized by:
--   
--   <ul>
--   <li><tt>w</tt> - the output to accumulate.</li>
--   <li><tt>m</tt> - The inner monad.</li>
--   </ul>
--   
--   The <a>return</a> function produces the output <a>mempty</a>, while
--   <tt>&gt;&gt;=</tt> combines the outputs of the subcomputations using
--   <a>mappend</a>.
newtype WriterT w (m :: * -> *) a :: * -> (* -> *) -> * -> *
WriterT :: m (a, w) -> WriterT w a
runWriterT :: WriterT w a -> m (a, w)

-- | The minimal definition needed for a monad providing a writer
--   environment.
class (Monoid w, MonadTower m) => IsWriter w m


-- | Note that the original definitions are used for the various reader,
--   writer and state computations: as such, if there is (for example)
--   another level that satisfies 'IsReader r' above the one that satisfies
--   'IsRWS r w s' in the stack, then calling <a>ask</a> will use the
--   higher level.
module Control.Monad.Levels.RWS
type HasRWS r w s m = SatisfyConstraint (IsRWS r w s) m

-- | Defined as another class rather than an alias in case you need to
--   ensure the same level satisfies all three constraints (and to have a
--   specific <a>ValidConstraint</a> instance).
class (IsReader r m, IsWriter w m, IsState s m) => IsRWS r w s m
instance Monoid w => ValidConstraint (IsRWS r w s)
instance (MonadTower m, Monoid w) => IsRWS r w s (RWST r w s m)
instance (MonadTower m, Monoid w) => IsRWS r w s (RWST r w s m)


-- | Note that the original definitions are used for the various reader,
--   writer and state computations: as such, if there is (for example)
--   another level that satisfies 'IsReader r' above the one that satisfies
--   'IsRWS r w s' in the stack, then calling <a>ask</a> will use the
--   higher level.
module Control.Monad.Levels.RWS.Lazy

-- | A monad transformer adding reading an environment of type <tt>r</tt>,
--   collecting an output of type <tt>w</tt> and updating a state of type
--   <tt>s</tt> to an inner monad <tt>m</tt>.
newtype RWST r w s (m :: * -> *) a :: * -> * -> * -> (* -> *) -> * -> *
RWST :: (r -> s -> m (a, s, w)) -> RWST r w s a
runRWST :: RWST r w s a -> r -> s -> m (a, s, w)


-- | Note that the original definitions are used for the various reader,
--   writer and state computations: as such, if there is (for example)
--   another level that satisfies 'IsReader r' above the one that satisfies
--   'IsRWS r w s' in the stack, then calling <a>ask</a> will use the
--   higher level.
module Control.Monad.Levels.RWS.Strict

-- | A monad transformer adding reading an environment of type <tt>r</tt>,
--   collecting an output of type <tt>w</tt> and updating a state of type
--   <tt>s</tt> to an inner monad <tt>m</tt>.
newtype RWST r w s (m :: * -> *) a :: * -> * -> * -> (* -> *) -> * -> *
RWST :: (r -> s -> m (a, s, w)) -> RWST r w s a
runRWST :: RWST r w s a -> r -> s -> m (a, s, w)
