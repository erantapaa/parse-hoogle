-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A test framework building on HUnit.
--   
@package HUnit-Plus
@version 1.0.1


-- | This module handles the complexities of writing information to the
--   terminal, including modifying text in place. This code is imported
--   from the original HUnit library.
module Test.HUnitPlus.Terminal

-- | Simplifies the input string by interpreting <tt>\r</tt> and
--   <tt>\b</tt> characters specially so that the result string has the
--   same final (or <i>terminal</i>, pun intended) appearance as would the
--   input string when written to a terminal that overwrites character
--   positions following carriage returns and backspaces.
terminalAppearance :: String -> String


-- | Sets HUnit-Plus tests can be specified using <a>Filter</a>s. These are
--   used by <a>Test.HUnitPlus.Execution</a> and <a>Test.HUnitPlus.Main</a>
--   to select which tests are run. Filters can specify tests belonging to
--   a certain suite, starting with a certain path, having a certain tag,
--   or combinations thereof.
--   
--   Filters are optimized for the behavior of programs created by the
--   <tt>createMain</tt> function, which runs a test if it matches
--   <i>any</i> of the filters specified. There is also a string format for
--   filters, which is how filters are specified in testlist files and
--   command-line arguments. The format is optimized for simplicity, and as
--   such, it is not necessarily possible to describe a given <a>Filter</a>
--   with a single textual representation of a filter.
--   
--   The format for filters is as follows:
--   
--   [<i>suite</i>][<i>path</i>][<i>tags</i>]
--   
--   Where at least one of the <i>suite</i>, <i>path</i>, or <i>tags</i>
--   elements are present
--   
--   The <i>suite</i> element is a comma-separated list of suite names
--   (alphanumeric, no spaces), enclosed in brackets ('[' ']').
--   
--   The <i>path</i> element is a series of path elements (alphanumeric, no
--   spaces), separated by dots (<a>.</a>).
--   
--   The <i>tags</i> element consists of a <tt>\@</tt> character, followed
--   by a comma-separated list of tag names (alphanumeric, no spaces).
--   
--   The following are examples of textual filters, and their meanings:
--   
--   <ul>
--   <li><tt>first.second.third</tt>: Run all tests starting with the path
--   <tt>first.second.third</tt>. If there is a test named
--   <tt>first.second.third</tt>, it will be run.</li>
--   <li><tt>[unit]</tt>: Run all tests in the suite <tt>unit</tt>.</li>
--   <li><tt>[unit,stress]</tt>: Run all tests in the suites <tt>unit</tt>
--   and <tt>stress</tt></li>
--   <li><tt>@parser</tt>: Run all tests with the <tt>parser</tt> tag</li>
--   <li><tt>@parser,lexer</tt>: Run all tests with the <tt>parser</tt>
--   <i>or</i> the <tt>lexer</tt> tags.</li>
--   <li><tt>backend.codegen@asm</tt>: Run all tests starting with the path
--   <tt>backend.codegen</tt> with the <tt>asm</tt> tag.</li>
--   <li><tt>[stress]@net</tt>: Run all tests in the <tt>stress</tt> suite
--   with the tag <tt>net</tt>.</li>
--   <li><tt>[perf,profile]inner.outer</tt>: Run all tests in the
--   <tt>perf</tt> and <tt>profile</tt> suites that start with the path
--   <tt>inner.outer</tt>.</li>
--   <li><tt>[whitebox]network.protocol@security</tt>: Run all tests in the
--   <tt>whitebox</tt> suite beginning with the path
--   <tt>network.protocol</tt> that have the <tt>security</tt> tag.</li>
--   </ul>
--   
--   The most common use case of filters is to select a single failing test
--   to run, as part of fixing it. In this case, a single filter consisting
--   of the path to the test will have this effect.
module Test.HUnitPlus.Filter

-- | A tree-like structure that represents a set of tests within a given
--   suite.
data Selector
Selector :: Map String Selector -> !(Maybe (Set String)) -> Selector

-- | <tt>Selector</tt>s for subgroups of this one. The entry for each path
--   element contains the <tt>Selector</tt> to be used for that group (or
--   test). An empty map actually means 'select all tests'.
selectorInners :: Selector -> Map String Selector

-- | Tags by which to filter all tests. The empty set actually means 'run
--   all tests regardless of tags'. <a>Nothing</a> means that all tests
--   will be skipped (though this will be overridden by any
--   <tt>Selector</tt>s in <tt>selectorInners</tt>.
selectorTags :: Selector -> !(Maybe (Set String))

-- | Specifies zero or more test suites, to which the given <a>Selector</a>
--   is then applied. If no test suites are specified, then the
--   <a>Selector</a> applies to all test suites.
data Filter
Filter :: !(Set String) -> !Selector -> Filter

-- | The test suites to which the <a>Selector</a> applies. The empty set
--   actually means 'all suites'.
filterSuites :: Filter -> !(Set String)

-- | The <a>Selector</a> to apply.
filterSelector :: Filter -> !Selector

-- | Combine two <a>selectorTags</a> fields into one. This operation
--   represents the union of the tests that are selected by the two fields.
combineTags :: Maybe (Set String) -> Maybe (Set String) -> Maybe (Set String)

-- | A <a>Filter</a> that selects all tests in all suites.
passFilter :: Filter

-- | A <a>Selector</a> that selects all tests.
allSelector :: Selector

-- | Combine two <a>Selector</a>s into a single <a>Selector</a>.
combineSelectors :: Selector -> Selector -> Selector

-- | Take a list of test suite names and a list of <a>Filter</a>s, and
--   build a <a>Map</a> that says for each test suite, what (combined)
--   <a>Selector</a> should be used to select tests.
suiteSelectors :: [String] -> [Filter] -> Map String Selector

-- | Parse a <a>Filter</a> expression. The format for filter expressions is
--   described in the module documentation.
parseFilter :: String -> String -> Either String Filter

-- | Given a <a>FilePath</a>, get the contents of the file and parse it as
--   a testlist file.
parseFilterFile :: FilePath -> IO (Either [String] [Filter])

-- | Parse content from a testlist file. The file must contain one filter
--   per line. Leading and trailing spaces are ignored, as are lines that
--   contain no filter. A <tt>#</tt> will cause the parser to skip the rest
--   of the line.
parseFilterFileContent :: String -> String -> Either [String] [Filter]
instance Eq Selector
instance Ord Selector
instance Show Selector
instance Ord Filter
instance Eq Filter
instance Show Filter


-- | Reporting functionality for HUnit-Plus. Test reporting is now defined
--   using a set of events. A <a>Reporter</a> contains handlers for these
--   events, which have access to and update a <a>Reporter</a>-defined
--   state value. The handlers in a <a>Reporter</a> are called at
--   appropriate points during text execution.
--   
--   This module also contains a basic <a>defaultReporter</a> that simply
--   passes the state value through unchanged. It also defines
--   <a>combinedReporter</a>, which facilitates "gluing" two
--   <a>Reporter</a>s together.
module Test.HUnitPlus.Reporting

-- | Composed into <a>Path</a>s.
data Node
Label :: String -> Node

-- | Keeps track of the remaining tests and the results of the performed
--   tests. As each test is performed, the path is removed and the counts
--   are updated as appropriate.
data State
State :: !String -> !Path -> !Counts -> !(Map String String) -> ![OptionDescr] -> State

-- | The name of the case or suite currently being run.
stName :: State -> !String

-- | The path to the test case currently being run.
stPath :: State -> !Path

-- | The current test statistics.
stCounts :: State -> !Counts

-- | The current option values.
stOptions :: State -> !(Map String String)

-- | The current option descriptions we know about.
stOptionDescs :: State -> ![OptionDescr]

-- | A record that holds the results of tests that have been performed up
--   until this point.
data Counts
Counts :: !Word -> !Word -> !Word -> !Word -> !Word -> !Word -> !Word -> Counts

-- | Number of total cases.
cCases :: Counts -> !Word

-- | Number of cases tried.
cTried :: Counts -> !Word

-- | Number of cases that failed with an error.
cErrors :: Counts -> !Word

-- | Number of cases that failed.
cFailures :: Counts -> !Word

-- | Number of cases that were skipped.
cSkipped :: Counts -> !Word

-- | Total number of assertions checked.
cAsserts :: Counts -> !Word

-- | Number of assertions checked by the last test case.
cCaseAsserts :: Counts -> !Word

-- | Report generator. This record type contains a number of functions that
--   are called at various points throughout a test run.
data Reporter us
Reporter :: IO us -> (Double -> Counts -> us -> IO us) -> (State -> us -> IO us) -> (Double -> State -> us -> IO us) -> (State -> us -> IO us) -> (String -> State -> us -> IO us) -> (Double -> State -> us -> IO us) -> (State -> us -> IO us) -> (String -> State -> us -> IO us) -> (String -> State -> us -> IO us) -> (String -> State -> us -> IO us) -> (String -> State -> us -> IO us) -> Reporter us

-- | Called at the beginning of a test run.
reporterStart :: Reporter us -> IO us

-- | Called at the end of a test run.
reporterEnd :: Reporter us -> Double -> Counts -> us -> IO us

-- | Called at the start of a test suite run.
reporterStartSuite :: Reporter us -> State -> us -> IO us

-- | Called at the end of a test suite run.
reporterEndSuite :: Reporter us -> Double -> State -> us -> IO us

-- | Called at the start of a test case run.
reporterStartCase :: Reporter us -> State -> us -> IO us

-- | Called to report progress of a test case run.
reporterCaseProgress :: Reporter us -> String -> State -> us -> IO us

-- | Called at the end of a test case run.
reporterEndCase :: Reporter us -> Double -> State -> us -> IO us

-- | Called when skipping a test case.
reporterSkipCase :: Reporter us -> State -> us -> IO us

-- | Called to report output printed to the system output stream.
reporterSystemOut :: Reporter us -> String -> State -> us -> IO us

-- | Called to report output printed to the system error stream.
reporterSystemErr :: Reporter us -> String -> State -> us -> IO us

-- | Called when a test fails.
reporterFailure :: Reporter us -> String -> State -> us -> IO us

-- | Called when a test reports an error.
reporterError :: Reporter us -> String -> State -> us -> IO us

-- | Uniquely describes the location of a test within a test hierarchy.
--   Node order is from test case to root.
type Path = [Node]

-- | A <a>Counts</a> with all zero counts.
zeroCounts :: Counts

-- | Converts a test case path to a string, separating adjacent elements by
--   a dot ('.'). An element of the path is quoted (as with <a>show</a>)
--   when there is potential ambiguity.
showPath :: Path -> String

-- | Gewerate a string showing the entire qualified name from the reporting
--   state.
showQualName :: State -> String

-- | A reporter containing default actions, which are to do nothing and
--   return the user state unmodified.
defaultReporter :: Reporter a

-- | Combines two <a>Reporter</a>s into a single reporter that calls both.
combinedReporter :: Reporter us1 -> Reporter us2 -> Reporter (us1, us2)
instance Eq Counts
instance Show Counts
instance Read Counts
instance Eq Node
instance Show Node
instance Read Node
instance Eq State
instance Show State
instance Read State


-- | <a>Reporter</a> for running HUnit tests and reporting results as
--   JUnit-style XML reports. This uses the hexpat library for XML
--   generation. This module also contains functions for creating the
--   various nodes in a JUnit XML report.
module Test.HUnitPlus.XML

-- | Generate an element for a property definition
propertyElem :: (String, String) -> Node String String

-- | Generate an element for a set of property definitions
propertiesElem :: [(String, String)] -> Node String String

-- | Generate an element representing output to stdout
systemOutElem :: String -> Node String String

-- | Generate an element representing output to stderr
systemErrElem :: String -> Node String String

-- | Generate an element representing a test failure.
failureElem :: String -> Node String String

-- | Generate an element representing an error in a test.
errorElem :: String -> Node String String

-- | Generate an element for a single test case.
testcaseElem :: String -> String -> Word -> Double -> [Node String String] -> Node String String

-- | Generate an element for a skipped test case
skippedTestElem :: String -> String -> Node String String

-- | Generate an element for a test suite run
testSuiteElem :: String -> Map String String -> Word -> Word -> Word -> Word -> String -> UTCTime -> Double -> [Node String String] -> Node String String

-- | Generate the top-level element containing all test suites
testSuitesElem :: Double -> [Node String String] -> Node String String

-- | A reporter that generates JUnit XML reports
xmlReporter :: Reporter [[Node String String]]


-- | Basic definitions for the HUnitPlus library.
--   
--   This module contains what you need to create assertions and test cases
--   and combine them into test suites.
--   
--   The assertion and test definition operators are the same as those
--   found in the HUnit library. However, an important note is that the
--   behavior of assertions in HUnit-Plus differs from those in HUnit.
--   HUnit-Plus assertions do <i>not</i> stop executing a test if they
--   fail, and are designed so that multiple assertions can be made by a
--   single test. HUnit-Plus contains several "abort" functions, which can
--   be used to terminate a test immediately.
--   
--   HUnit-Plus test execution handles exceptions. An uncaught exception
--   will cause the test to report an error (along with any failures and/or
--   errors that have occurred so far), and test execution and reporting
--   will continue.
--   
--   The data structures for describing tests are the same as those in the
--   <a>Distribution.TestSuite</a> module used by cabal's testing
--   facilities. This allows for easy interfacing with cabal's
--   <tt>detailed</tt> testing scheme.
--   
--   This gives rise to a grid possible use cases: creating a test using
--   the HUnit-Plus facilities vs. executing an existing
--   <a>Distribution.TestSuite</a> test which was not created by the
--   facilities in this module, and executing a test with HUnit-Plus vs
--   executing it with another test framework. The <a>executeTest</a>
--   function is designed to cope with either possible origin of a test,
--   and the <a>Testable</a> instances are designed to produce tests which
--   work as expected in either possible execution environment.
module Test.HUnitPlus.Base
data Test :: *
Test :: TestInstance -> Test
Group :: String -> Bool -> [Test] -> Test
groupName :: Test -> String

-- | If true, then children of this group may be run in parallel. Note that
--   this setting is not inherited by children. In particular, consider a
--   group F with "concurrently = False" that has some children, including
--   a group T with "concurrently = True". The children of group T may be
--   run concurrently with each other, as long as none are run at the same
--   time as any of the direct children of group F.
concurrently :: Test -> Bool
groupTests :: Test -> [Test]
ExtraOptions :: [OptionDescr] -> Test -> Test
data TestInstance :: *
TestInstance :: IO Progress -> String -> [String] -> [OptionDescr] -> (String -> String -> Either String TestInstance) -> TestInstance

-- | Perform the test.
run :: TestInstance -> IO Progress

-- | A name for the test, unique within a test suite.
name :: TestInstance -> String

-- | Users can select groups of tests by their tags.
tags :: TestInstance -> [String]

-- | Descriptions of the options recognized by this test.
options :: TestInstance -> [OptionDescr]

-- | Try to set the named option to the given value. Returns an error
--   message if the option is not supported or the value could not be
--   correctly parsed; otherwise, a <a>TestInstance</a> with the option set
--   to the given value is returned.
setOption :: TestInstance -> String -> String -> Either String TestInstance

-- | Definition for a test suite. This is intended to be a top-level (ie.
--   non-nestable) container for tests. Test suites have a name, a list of
--   options with default values (which can be overridden either at runtime
--   or statically using <a>ExtraOptions</a>), and a set of <a>Test</a>s to
--   be run.
--   
--   Individual tests are described using definitions found in cabal's
--   <a>Distribution.TestSuite</a> module, to allow for straightforward
--   integration with cabal testing facilities.
data TestSuite
TestSuite :: !String -> !Bool -> ![(String, String)] -> ![Test] -> TestSuite

-- | The name of the test suite.
suiteName :: TestSuite -> !String

-- | Whether or not to run the tests concurrently.
suiteConcurrently :: TestSuite -> !Bool

-- | A list of all options used by this suite, and the default values for
--   those options.
suiteOptions :: TestSuite -> ![(String, String)]

-- | The tests in the suite.
suiteTests :: TestSuite -> ![Test]

-- | Create a test suite from a name and a list of tests.
testSuite :: String -> [Test] -> TestSuite

-- | Provides a way to convert data into a <tt>Test</tt> or set of
--   <tt>Test</tt>.
class Testable t where testName testname t = testNameTags testname [] t testTags tagset t = testNameTags syntheticName tagset t test t = testNameTags syntheticName [] t
testNameTags :: Testable t => String -> [String] -> t -> Test
testName :: Testable t => String -> t -> Test
testTags :: Testable t => [String] -> t -> Test
test :: (Testable t, Testable t) => t -> Test

-- | Shorthand for a test case that asserts equality (with the expected
--   value on the left-hand side, and the actual value on the right-hand
--   side).
(~=?) :: (Eq a, Show a) => a -> a -> Test

-- | Shorthand for a test case that asserts equality (with the actual value
--   on the left-hand side, and the expected value on the right-hand side).
(~?=) :: (Eq a, Show a) => a -> a -> Test

-- | Creates a test from the specified <a>Testable</a>, with the specified
--   label attached to it.
--   
--   Since <a>Test</a> is <tt>Testable</tt>, this can be used as a
--   shorthand way of attaching a <tt>TestLabel</tt> to one or more tests.
(~:) :: Testable t => String -> t -> Test

-- | Creates a test case resulting from asserting the condition obtained
--   from the specified <tt>AssertionPredicable</tt>.
(~?) :: Assertable t => t -> String -> Test
type Assertion = IO ()

-- | Signal that an assertion succeeded. This will log that an assertion
--   has been made.
assertSuccess :: Assertion

-- | Unconditionally signal that a failure has occurred. This will not stop
--   execution, but will record the failure, resulting in a failed test.
assertFailure :: String -> Assertion

-- | Signal that a failure has occurred and stop the test immediately. Note
--   that if an error has been logged already, the test will be reported as
--   an error.
abortFailure :: String -> Assertion

-- | Signal than an error has occurred and stop the test immediately.
abortError :: String -> Assertion

-- | Asserts that the specified condition holds.
assertBool :: String -> Bool -> Assertion

-- | Signals an assertion failure if a non-empty message (i.e., a message
--   other than <tt>""</tt>) is passed.
assertString :: String -> Assertion

-- | Signals an assertion failure if a non-empty message (i.e., a message
--   other than <tt>""</tt>) is passed. Allows a prefix to be supplied for
--   the assertion failure message.
assertStringWithPrefix :: String -> String -> Assertion

-- | Asserts that the specified actual value is equal to the expected
--   value. The output message will contain the prefix, the expected value,
--   and the actual value.
--   
--   If the prefix is the empty string (i.e., <tt>""</tt>), then the prefix
--   is omitted and only the expected and actual values are output.
assertEqual :: (Eq a, Show a) => String -> a -> a -> Assertion

-- | Assert that the given computation throws an exception that matches a
--   predicate.
assertThrows :: (Exception e, Show e) => (e -> Assertion) -> IO a -> Assertion

-- | Assert that the given computation throws a specific exception.
assertThrowsExact :: (Exception e, Show e, Eq e) => e -> IO a -> Assertion

-- | Allows the extension of the assertion mechanism.
--   
--   Since an <a>Assertion</a> can be a sequence of <tt>Assertion</tt>s and
--   <tt>IO</tt> actions, there is a fair amount of flexibility of what can
--   be achieved. As a rule, the resulting <a>Assertion</a> should not
--   assert multiple, independent conditions.
--   
--   If more complex arrangements of assertions are needed, <a>Test</a>s
--   and <a>Testable</a> should be used.
class Assertable t where assert = assertWithMsg ""
assertWithMsg :: Assertable t => String -> t -> Assertion
assert :: Assertable t => t -> Assertion

-- | Asserts that the specified actual value is equal to the expected value
--   (with the expected value on the left-hand side).
(@=?) :: (Eq a, Show a) => a -> a -> Assertion

-- | Asserts that the specified actual value is equal to the expected value
--   (with the actual value on the left-hand side).
(@?=) :: (Eq a, Show a) => a -> a -> Assertion

-- | Shorthand for <a>assertBool</a>.
(@?) :: Assertable t => t -> String -> Assertion

-- | Does the actual work of executing a test. This maintains the necessary
--   bookkeeping recording assertions and failures, It also sets up
--   exception handlers and times the test.
executeTest :: Reporter us -> State -> us -> IO Progress -> IO (Double, State, us)

-- | Record sysout output.
logSyserr :: String -> IO ()

-- | Record sysout output.
logSysout :: String -> IO ()

-- | Record that one assertion has been checked.
logAssert :: IO ()

-- | Record a failure, along with a message.
logFailure :: String -> IO ()

-- | Record an error, along with a message.
logError :: String -> IO ()

-- | Execute the given computation with a message prefix.
withPrefix :: String -> IO () -> IO ()

-- | Get a combined failure message, if there is one.
getErrors :: IO (Maybe String)

-- | Get a combined failure message, if there is one.
getFailures :: IO (Maybe String)
instance Typeable TestException
instance Show TestException
instance Testable t => Testable [t]
instance Assertable t => Testable (IO t)
instance Testable Test
instance ListAssertable Assertion
instance ListAssertable Char
instance Assertable t => Assertable (IO t)
instance ListAssertable t => Assertable [t]
instance Assertable Progress
instance Assertable Result
instance Assertable Bool
instance Assertable ()
instance Exception TestException


-- | Functions for executing test cases, test paths, and test suites. These
--   functions are provided for the sake of convenience and testing;
--   however, the preferred way of using HUnit-Plus is to use the
--   <a>Test.HUnitPlus.Main#createMain</a> to create a test program
--   directly from a list of test suites.
module Test.HUnitPlus.Execution

-- | Execute an individual test case.
performTestCase :: Reporter us -> State -> us -> TestInstance -> IO (State, us)

-- | Execute a given test (which may be a group), with the specified
--   selector and report generators. Only tests which match the selector
--   will be executed. The rest will be logged as skipped.
performTest :: Reporter us -> Selector -> State -> us -> Test -> IO (State, us)

-- | Decide whether to execute a test suite based on a map from suite names
--   to selectors. If the map contains a selector for the test suite,
--   execute all tests matching the selector, and log the rest as skipped.
--   If the map does not contain a selector, do not execute the suite, and
--   do <i>not</i> log its tests as skipped.
performTestSuite :: Reporter us -> Map String Selector -> us -> TestSuite -> IO (Counts, us)

-- | Top-level function for a test run. Given a set of suites and a map
--   from suite names to selectors, execute all suites that have selectors.
--   For any test suite, only the tests specified by its selector will be
--   executed; the rest will be logged as skipped. Suites that do not have
--   a selector will be omitted entirely, and their tests will <i>not</i>
--   be logged as skipped.
performTestSuites :: Reporter us -> Map String Selector -> [TestSuite] -> IO (Counts, us)


-- | Text-based reporting functionality for reporting either as text, or to
--   the terminal. This module is an adaptation of code from the original
--   HUnit library.
--   
--   Note that the test execution function in this module are included for
--   (a measure of) compatibility with HUnit, but are deprecated in favor
--   of the function in the <a>Test.HUnitPlus.Main</a> module.
module Test.HUnitPlus.Text

-- | The text-based reporters (<a>textReporter</a> and
--   <a>terminalReporter</a>) construct strings and pass them to the
--   function embodied in a <a>PutText</a>. This function handles the
--   string in one of several ways. Two schemes are defined here.
--   <a>putTextToHandle</a> writes report lines to a given handle.
--   <a>putTextToShowS</a> accumulates lines for return as a whole.
--   
--   The <a>PutText</a> function is also passed, and returns, an arbitrary
--   state value (called <tt>st</tt> here). The initial state value is
--   given in the <a>PutText</a>; the final value is returned by
--   <a>runTestText</a>.
data PutText st
PutText :: (String -> st -> IO st) -> st -> PutText st

-- | Writes persistent lines to the given handle.
putTextToHandle :: Handle -> PutText ()

-- | Accumulates lines for return by <a>runTestText</a>. The accumulated
--   lines are represented by a <tt><a>ShowS</a> (<a>String</a> -&gt;
--   <a>String</a>)</tt> function whose first argument is the string to be
--   appended to the accumulated report lines.
putTextToShowS :: PutText ShowS

-- | Converts test execution counts to a string.
showCounts :: Counts -> String

-- | Create a <a>Reporter</a> that outputs a textual report for
--   non-terminal output.
textReporter :: PutText us -> Bool -> Reporter us

-- | Execute a test, processing text output according to the given
--   reporting scheme. The reporting scheme's state is threaded through
--   calls to the reporting scheme's function and finally returned, along
--   with final count values. The text is output in non-terminal mode.
--   
--   This function is deprecated. The preferred way to run tests is to use
--   the functions in <a>Test.HUnitPlus.Main</a>.
runTestText :: PutText us -> Bool -> Test -> IO (Counts, us)

-- | Execute a test suite, processing text output according to the given
--   reporting scheme. The reporting scheme's state is threaded through
--   calls to the reporting scheme's function and finally returned, along
--   with final count values. The text is output in non-terminal mode.
--   
--   This function is deprecated. The preferred way to run tests is to use
--   the functions in <a>Test.HUnitPlus.Main</a>.
runSuiteText :: PutText us -> Bool -> TestSuite -> IO (Counts, us)

-- | Execute the given test suites, processing text output according to the
--   given reporting scheme. The reporting scheme's state is threaded
--   through calls to the reporting scheme's function and finally returned,
--   along with final count values. The text is output in non-terminal
--   mode.
--   
--   This function is deprecated. The preferred way to run tests is to use
--   the functions in <a>Test.HUnitPlus.Main</a>.
runSuitesText :: PutText us -> Bool -> [TestSuite] -> IO (Counts, us)

-- | A reporter that outputs lines indicating progress to the terminal.
--   Reporting is made to standard error, and progress reports are
--   included.
terminalReporter :: Reporter Int

-- | Execute a test, processing text output according to the given
--   reporting scheme. The reporting scheme's state is threaded through
--   calls to the reporting scheme's function and finally returned, along
--   with final count values. The text is output in terminal mode.
--   
--   This function is deprecated. The preferred way to run tests is to use
--   the functions in <a>Test.HUnitPlus.Main</a>.
runTestTT :: Test -> IO Counts

-- | Execute a test suite, processing text output according to the given
--   reporting scheme. The reporting scheme's state is threaded through
--   calls to the reporting scheme's function and finally returned, along
--   with final count values. The text is output in terminal mode.
--   
--   This function is deprecated. The preferred way to run tests is to use
--   the functions in <a>Test.HUnitPlus.Main</a>.
runSuiteTT :: TestSuite -> IO Counts

-- | Execute the given test suites, processing text output according to the
--   given reporting scheme. The reporting scheme's state is threaded
--   through calls to the reporting scheme's function and finally returned,
--   along with final count values. The text is output in terminal mode.
--   
--   This function is deprecated. The preferred way to run tests is to use
--   the functions in <a>Test.HUnitPlus.Main</a>.
runSuitesTT :: [TestSuite] -> IO Counts


-- | A mostly-complete test selection and execution program for running
--   HUnit-Plus tests. The only thing missing are the actual test suites,
--   which are provided as parameters to <a>createMain</a>.
--   
--   Given a set of test suites, module can be used to create a test
--   execution program as follows:
--   
--   <pre>
--   module Main(main) where
--   
--   import Test.HUnitPlus.Main
--   import MyProgram.Tests(testsuites)
--   
--   main :: IO ()
--   main = createMain testsuites
--   </pre>
--   
--   Where <tt>testsuites</tt> is a list of <a>TestSuite</a>s.
--   
--   The resulting program, when executed with no arguments will execute
--   all test suites and write a summary to <tt>stdout</tt>. Additionally,
--   the test program has a number of options that control reporting and
--   test execution.
--   
--   A summary of the options follows:
--   
--   <ul>
--   <li><tt>-c <i>mode</i>, --consolemode=<i>mode</i></tt>: Set the
--   behavior of console reporting to <i>mode</i>. Can be <tt>quiet</tt>,
--   <tt>terminal</tt>, <tt>text</tt>, and <tt>verbose</tt>. Default is
--   <tt>terminal</tt>.</li>
--   <li><tt>-t [<i>file</i>], --txtreport[=<i>file</i>]</tt>: Write a text
--   report to <i>file</i> (if specified; if not, the default is
--   'report.txt'). Formatting of the report is the same as the
--   <tt>verbose</tt> terminal mode.</li>
--   <li><tt>-x [<i>file</i>], --xmlreport[=<i>file</i>]</tt>: Write a
--   JUnit-style XML report to <i>file</i> (if specified; if not, the
--   default is 'report.xml').</li>
--   <li><tt>-l <i>file</i>, --testlist=<i>file</i></tt>: Read a testlist
--   from <i>file</i>. The file must contain a number of filters, one per
--   line. Empty lines or lines beginning with '#' are ignored. Multiple
--   files may be specified. The filters from all files are combined, and
--   added to any filters specified on the command line.</li>
--   </ul>
--   
--   Any additional arguments are assumed to be filters, which specify a
--   set of tests to be run. For more information on the format of filters,
--   see the <a>Filter</a> module. If no filters are given either on the
--   command line or in testlist files, then all tests will be run.
module Test.HUnitPlus.Main

-- | Command-line options for generated programs.
data Opts
Opts :: [String] -> [String] -> [String] -> [ConsoleMode] -> [String] -> Opts

-- | A file to which to write a JUnit-style XML report. The list must
--   contain a single value, or be empty, or else the test program will
--   report bad options. If the list is empty, no XML report will be
--   generated.
xmlreport :: Opts -> [String]

-- | Filters in string format, specifying which tests should be run. If no
--   filters are given, then all tests will be run. For information on the
--   string format, see <a>Test.HUnitPlus.Filter</a>.
filters :: Opts -> [String]

-- | A file to which to write a plain-text report. The list must contain a
--   single value, or be empty, or else the test program will report bad
--   options. If the list is empty, no report will be generated.
txtreport :: Opts -> [String]

-- | The behavior of the console output.
consmode :: Opts -> [ConsoleMode]

-- | Files from which to read testlists. Multiple files may be specified.
--   The contents will be parsed and added to the list of filters specified
--   on the command line.
testlist :: Opts -> [String]

-- | Console mode options.
data ConsoleMode

-- | Do not generate any console output.
Quiet :: ConsoleMode

-- | Report test counts interactively during execution, updating the number
--   of tests run, skipped, failed, and errored as they execute.
Terminal :: ConsoleMode

-- | Report a summary of tests run, skipped, failed, and errored after
--   execution.
Text :: ConsoleMode

-- | Report extra information as tests execute.
Verbose :: ConsoleMode

-- | Command-line options for the <a>System.Console.CmdArgs</a> module.
opts :: Opts

-- | Create a standard test execution program from a set of test suites.
--   The resulting <tt>main</tt> will process command line options as
--   described, execute the appropirate tests, and exit with success if all
--   tests passed, and fail otherwise.
createMain :: [TestSuite] -> IO ()

-- | Top-level function for executing test suites. <a>createMain</a> is
--   simply a wrapper around this function. This function allows users to
--   supply their own options, and to decide what to do with the result of
--   test execution.
topLevel :: [TestSuite] -> Opts -> IO (Either [String] Bool)
instance Typeable ConsoleMode
instance Typeable Opts
instance Data ConsoleMode
instance Show ConsoleMode
instance Show Opts
instance Data Opts


-- | The legacy test definitions for compatibility with the original HUnit
--   library. These are not guaranteed to be compatible for all cases, but
--   they should work for most. The <a>Testable</a> instance converts them
--   into <a>Distribution.TestSuite</a> tests, with no tags.
--   
--   These are deprecated in favor of the test definitions from the Cabal
--   <a>Distribution.TestSuite</a> module, plus the <a>TestSuite</a>
--   definition in <a>Test.HUnitPlus.Base</a>.
module Test.HUnitPlus.Legacy

-- | The basic structure used to create an annotated tree of test cases.
data Test

-- | A single, independent test case composed.
TestCase :: Assertion -> Test

-- | A set of <tt>Test</tt>s sharing the same level in the hierarchy.
TestList :: [Test] -> Test

-- | A name or description for a subtree of the <tt>Test</tt>s.
TestLabel :: String -> Test -> Test
instance Testable Test
instance Show Test


-- | HUnit-Plus is a unit testing framework for Haskell, based on the older
--   HUnit framework.
--   
--   To use HUnit-Plus, first import the module <a>Test.HUnitPlus</a>:
--   
--   <pre>
--   import Test.HUnitPlus
--   </pre>
--   
--   HUnit-Plus provides the same succinct syntax for defining test as
--   HUnit. However, HUnit-Plus tests use the data structures from
--   <a>Distribution.TestSuite</a> to describe tests, as opposed to the
--   data structures used by HUnit.
--   
--   <pre>
--   test1 = "test1" ~: (assertEqual "for (foo 3)," (1,2) (foo 3))
--   test2 = "test2" ~: (do (x,y) &lt;- partA 3
--                         assertEqual "for the first result of partA," 5 x
--                         b &lt;- partB y
--                         assertBool ("(partB " ++ show y ++ ") failed") b)
--   </pre>
--   
--   You can also use the datatypes in <a>Distribution.TestSuite</a> to
--   define your tests, or import tests that were defined that way.
--   
--   <pre>
--   test3 = Test (TestInstance { ... })
--   
--   testgroup1 = Group { ... }
--   </pre>
--   
--   Additionally, you can use the <a>Test.HUnitPlus.Legacy</a> module to
--   define tests in the old HUnit fashion. The test-creation operators
--   will convert them into HUnit-Plus tests.
--   
--   <pre>
--   import qualified Test.HUnitPlus.Legacy as Legacy
--   test4 = "test4" ~: Test (assertEqual "a == b" a b)
--   testgroup2 = TestList [TestLabel "testFoo" testBar,
--                          TestLabel "testBar" testBar]
--   </pre>
--   
--   You can add tags to tests as well:
--   
--   <pre>
--   test1Tags = testTags ["demo"] test1
--   test5 = testNameTags "test5" ["demo"] (a @?= b)
--   </pre>
--   
--   You can also create groups of tests:
--   
--   <pre>
--   testgroup3 = "group3" ~: [ test1, test2, testgroup1, test3 ]
--   </pre>
--   
--   At the top level, group tests into suites.
--   
--   <pre>
--   suite = TestSuite { suiteName = "suite",
--                       suiteTests = [ testgroup3, test4 ],
--                       ... }
--   </pre>
--   
--   The <a>createMain</a> function in <a>Test.HUnitPlus.Main</a> can be
--   used to easily define a <tt>main</tt> for a test execution program.
--   
--   <pre>
--   main = createMain suite
--   </pre>
--   
--   The resulting program has a number of options for executing tests and
--   reporting the results, which are documented in
--   <a>Test.HUnitPlus.Main</a>, as well as in the program's "usage"
--   output. Briefly, you can execute all tests by running the program
--   without arguments.
--   
--   <pre>
--   $&gt; ./testprog
--   </pre>
--   
--   You can select tests to be run by supplying a filter:
--   
--   <pre>
--   $&gt; ./testprog group3.test1
--   $&gt; ./testprog @demo
--   </pre>
--   
--   You can also generate various kinds of reports, and control console
--   output:
--   
--   <pre>
--   $&gt; ./testprog --xmlreport --txtreport --consolemode=quiet --testlist=tests
--   </pre>
--   
--   You can also use the <a>topLevel</a> function to supply options to
--   test execution and get the result, allowing limited integration with a
--   larger test execution framework. (<a>Test.HUnitPlus.Execution</a> has
--   even more options).
module Test.HUnitPlus
