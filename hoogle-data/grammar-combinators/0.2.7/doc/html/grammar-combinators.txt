-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A parsing library of context-free grammar combinators.
--   
--   The grammar-combinators library is a novel parsing library using an
--   explicit representation of recursion to provide various novel
--   features, for grammar analysis, transformation and parsing
--   functionality.
@package grammar-combinators
@version 0.2.7

module Text.GrammarCombinators.Base.Token

-- | The <a>Token</a> class identifies a type that can be used as terminal
--   identifier in a grammar definition. The type <tt>t</tt> itself is an
--   abstract identifier, identifying a certain type of terminals, but any
--   value of type <tt>t</tt> can correspond to a possibly infinite numer
--   of values of type 'ConcreteToken t'. For example, if you use a lexer
--   in a simple arithmetic expressions grammar, your lexer would typically
--   return values like <tt>PLUS</tt>, <tt>MINUS</tt>, but also 'INTEGER
--   42' when a number is lexed. In this case, a separate Token type t
--   would be defined, such that a value <tt>INTEGER_T</tt> of the
--   <a>Token</a> type t could correspond to all values of the form
--   'INTEGER n' (for n an Integer) of type 'ConcreteToken t'. A production
--   rule defined as <tt>token</tt> INTEGER_T would then produce result
--   values of type <a>ConcreteToken</a> t (e.g. INTEGER 42).
--   
--   The requirements on <a>Token</a> types are relatively strict, but this
--   is necessary to make it usable in table-based parser algorithms. We
--   reference the <a>Lift</a> class to allow for compile-time
--   precalculation of tables using Template Haskell (See the LL1 and
--   RealLL1 parsers).
--   
--   Note that in some cases it is inefficient to use Char directly as
--   token type, because of the big amount of tokens. For example when
--   using <tt>transformLeftCorner</tt>, the new domain will contain O(n*t
--   + n^2) non-terminals where n is the amount of non-terminals and t is
--   th number of tokens, so when using this transformation, it is
--   beneficial to use a token type with less token values than
--   <a>Char</a>, at least if you will use algorithms that fold over the
--   full new grammar's domain (e.g. <tt>printGrammar</tt> does,
--   <tt>printReachableGrammar</tt> doesn't).
class (Show (ConcreteToken t), Eq (ConcreteToken t), Lift (ConcreteToken t), Eq t, Show t, Ord t, Lift t, Enumerable t) => Token t where type family ConcreteToken t
classify :: Token t => ConcreteToken t -> t
enumConcreteTokens :: Token t => t -> [ConcreteToken t]
instance Token Char

module Text.GrammarCombinators.Base.Domain
class DomainMap phi phi' supIxT
supIx :: DomainMap phi phi' supIxT => phi' ix -> phi (supIxT ix)
subIx :: DomainMap phi phi' supIxT => phi (supIxT ix) -> phi' ix
class DomainMap phi phi' supIxT => DomainEmbedding phi phi' supIxT
supPF :: (DomainEmbedding phi phi' supIxT, HFunctor phi (PF phi)) => phi' ix -> phi (supIxT ix) -> PF phi' (SubVal supIxT r) ix -> PF phi r (supIxT ix)

-- | A generic wrapper type that restricts a semantic value family over a
--   bigger domain to a smaller domain.
data SubVal (supIxT :: * -> *) v ix
MkSubVal :: v (supIxT ix) -> SubVal v ix
unSubVal :: SubVal v ix -> v (supIxT ix)
data IxMapId
data IxMapBase (m :: * -> *)
data IxMapSeq (l1 :: *) (l2 :: * -> *)
class MemoFam (phi :: * -> *) where data family Memo phi :: (* -> *) -> *
fromMemo :: MemoFam phi => Memo phi v -> (forall ix. phi ix -> v ix)
toMemo :: MemoFam phi => (forall ix. phi ix -> v ix) -> Memo phi v
memoFamily :: MemoFam phi => (forall ix. phi ix -> v ix) -> (forall ix. phi ix -> v ix)

-- | A domain <tt>phi</tt> that is an instance of the <a>FoldFam</a> type
--   class supports folding over all non-terminals in the domain using the
--   <a>foldFam</a> function.
class FoldFam phi
foldFam :: FoldFam phi => (forall ix. phi ix -> b -> b) -> b -> b

-- | A domain <tt>phi</tt> that is an instance of the <a>EqFam</a> type
--   class supports overriding a function over the full domain at a single
--   non-terminal using the |overrideIdx| function.
class EqFam phi where eqIdx idx1 = overrideIdxK (const False) idx1 True
eqIdx :: EqFam phi => phi ix1 -> phi ix2 -> Bool
overrideIdx :: EqFam phi => (forall ix'. phi ix' -> r ix') -> phi oix -> r oix -> phi ix -> r ix

-- | Similar to the <a>overrideIdx</a> function, but limited to functions
--   whose result type is the same for all non-terminals.
overrideIdxK :: EqFam phi => (forall ix'. phi ix' -> v) -> phi oix -> v -> phi ix -> v

-- | A domain <tt>phi</tt> that is an instance of the <a>ShowFam</a> type
--   class supports conversion of non-terminal proof terms to Strings using
--   the <a>showIdx</a> function.
class ShowFam phi
showIdx :: ShowFam phi => phi ix -> String

-- | A decent Domain <tt>phi</tt> should instantiate the <a>FoldFam</a>,
--   <a>ShowFam</a>, <a>EqFam</a> and <a>MemoFam</a>. Avoid using this type
--   class in constraints, use more specific type classes whenever
--   possible.
--   
--   Note: instances for this type class are not automatically derived, and
--   you have to manually instantiate it with an empty implementation
--   block.
class (FoldFam phi, ShowFam phi, EqFam phi, MemoFam phi) => Domain phi
memoFamilyK :: MemoFam phi => (forall ix. phi ix -> v) -> (forall ix. phi ix -> v)
toMemoK :: MemoFam phi => (forall ix. phi ix -> v) -> Memo phi (K0 v)
fromMemoK :: MemoFam phi => Memo phi (K0 v) -> phi ix -> v
class LiftFam phi
liftIdxE :: LiftFam phi => phi ix -> Exp
liftIdxP :: LiftFam phi => phi ix -> Pat
data LeftIx ix
data RightIx ix
data MergeDomain phiL phiR ix
LeftIdx :: phiL ix -> MergeDomain phiL phiR (LeftIx ix)
RightIdx :: phiR ix -> MergeDomain phiL phiR (RightIx ix)
data EitherFunctor rL rR ix
LeftR :: rL ix -> EitherFunctor rL rR (LeftIx ix)
RightR :: rR ix -> EitherFunctor rL rR (RightIx ix)
unLeftR :: EitherFunctor rL rR (LeftIx ix) -> rL ix
unRightR :: EitherFunctor rL rR (RightIx ix) -> rR ix
instance Show (v (supIxT ix)) => Show (SubVal supIxT v ix)
instance Show (rR ix) => Show (EitherFunctor rL rR (RightIx ix))
instance Show (rL ix) => Show (EitherFunctor rL rR (LeftIx ix))
instance (Domain phiL, Domain phiR) => Domain (MergeDomain phiL phiR)
instance (EqFam phiL, EqFam phiR) => EqFam (MergeDomain phiL phiR)
instance (FoldFam phiL, FoldFam phiR) => FoldFam (MergeDomain phiL phiR)
instance (ShowFam phiL, ShowFam phiR) => ShowFam (MergeDomain phiL phiR)
instance (MemoFam phiL, MemoFam phiR) => MemoFam (MergeDomain phiL phiR)

module Text.GrammarCombinators.Base.MultiRec
data IL xi r ix
IL :: [r xi] -> IL xi r ix
unIL :: IL xi r ix -> [r xi]
data SubPF (phi :: * -> *) (phi' :: * -> *) unusedPhi' supIxT r ix
SubPF :: phi' ix -> PF phi' (SubVal supIxT r) ix -> SubPF phi phi' phi' supIxT r (supIxT ix)
instance (HFunctor phi' (PF phi'), DomainEmbedding phi phi' supIxT) => HFunctor phi (SubPF phi phi' phi' supIxT)
instance El phi xi => HFunctor phi (IL xi)

module Text.GrammarCombinators.Base.ProductionRule

-- | Base type class for production rule interpretations. A production rule
--   interpretation that is an instance of the <a>ProductionRule</a> type
--   class supports sequencing and disjunction of rules, empty rules, dead
--   rules and end-of-input rules.
class ProductionRule p
(>>>) :: ProductionRule p => p (a -> b) -> p a -> p b
(|||) :: ProductionRule p => p va -> p va -> p va
endOfInput :: ProductionRule p => p ()
die :: ProductionRule p => p a
class ProductionRule p => LiftableProductionRule p where optionally r = epsilonL Just [| Just |] >>> r ||| epsilonL Nothing [| Nothing |]
epsilonL :: LiftableProductionRule p => a -> Q Exp -> p a
optionally :: LiftableProductionRule p => p v -> p (Maybe v)
epsilonLS :: (Lift v, LiftableProductionRule p) => v -> p v
class LiftableProductionRule p => EpsProductionRule p
epsilon :: EpsProductionRule p => a -> p a

-- | Type class for production rules matching tokens of a certain token
--   type <tt>t</tt>. <tt>t</tt> should be an instance of the <a>Token</a>
--   type class.
class TokenProductionRule p t | p -> t
token :: TokenProductionRule p t => t -> p (ConcreteToken t)
anyToken :: TokenProductionRule p t => p (ConcreteToken t)
class PenaltyProductionRule p
penalty :: PenaltyProductionRule p => Int -> p a -> p a

-- | Sequence two rules, but drop the result of the first.
(*>>>) :: (ProductionRule p, LiftableProductionRule p) => p a -> p b -> p b

-- | Sequence two rules, but drop the result of the second.
(>>>*) :: (ProductionRule p, LiftableProductionRule p) => p a -> p b -> p a

-- | Apply a given function to the result of a given rule.
($>>) :: EpsProductionRule p => (a -> b) -> p a -> p b

-- | Replace a rule's result value with a given value.
($>>*) :: EpsProductionRule p => a -> p b -> p a

-- | Apply a given function to the result of a given rule.
($|>>) :: LiftableProductionRule p => (a -> b, Q Exp) -> p a -> p b

-- | Replace a rule's result value with a given value.
($|>>*) :: LiftableProductionRule p => (a, Q Exp) -> p b -> p a

-- | Production rule interpretations supporting the
--   <a>RecProductionRule</a> type class support references to
--   non-terminals in a given domain <tt>phi</tt>. The type of the result
--   values of the rules is determined by semantic value family <tt>r</tt>.
class RecProductionRule p phi r | p -> phi, p -> r
ref :: RecProductionRule p phi r => phi ix -> p (r ix)

-- | Production rule interpretations supporting the
--   <a>LoopProductionRule</a> type class allow for Kleene-star quantified
--   references to non-terminals (zero or more, see the <a>manyRef</a>
--   function) as well as <a>+</a>-quantified references to non-terminals
--   (one or more, see the <a>many1Ref</a> function).
--   
--   An instance can implement either manyRef or many1Ref, both or neither.
--   Not implementing either produces old-style many and many1 combinator
--   behaviour (discouraged for most situations)
class (ProductionRule p, LiftableProductionRule p, RecProductionRule p phi r) => LoopProductionRule p phi r | p -> phi, p -> r where manyRef idx = epsilonL [] [| [] |] ||| many1Ref idx many1Ref idx = ((:), [| (:) |]) $|>> ref idx >>> manyRef idx
manyRef :: LoopProductionRule p phi r => phi ix -> p [r ix]
many1Ref :: LoopProductionRule p phi r => phi ix -> p [r ix]

-- | The 'SuperProductionRule| type class is in an experimental state, and
--   currently not intended for general use.
class SuperProductionRule p
subref :: (SuperProductionRule p, DomainEmbedding phi phi' supIxT, HFunctor phi (PF phi), ProductionRule (p phi ixT r t), ProductionRule (p phi' (IxMapSeq ixT supIxT) (SubVal supIxT r) t)) => (forall ix'. phi' ix' -> p phi' (IxMapSeq ixT supIxT) (SubVal supIxT r) t (PF phi' (SubVal supIxT r) ix')) -> phi' ix -> phi (supIxT ix) -> p phi ixT r t (PF phi r (supIxT ix))

-- | Match any token in a given range of tokens.
tokenRange :: (ProductionRule p, TokenProductionRule p t) => [t] -> p (ConcreteToken t)

-- | Consecutively match a given list of tokens and return their concrete
--   token values as a list.
string :: (ProductionRule p, LiftableProductionRule p, TokenProductionRule p t) => [t] -> p [ConcreteToken t]

-- | An old style <tt>many</tt> combinator. Produces an infinite rule
--   similar to Parsec's many rule. Prefer to use the <a>manyRef</a>
--   function whenever possible.
manyInf :: (ProductionRule p, LiftableProductionRule p) => p a -> p [a]

-- | An old style <tt>many</tt> combinator. Produces an infinite rule
--   similar to Parsec's many rule. Prefer to use the <a>manyRef</a>
--   function whenever possible.
many1Inf :: (ProductionRule p, LiftableProductionRule p) => p a -> p [a]
class ProductionRuleWithLibrary p phi r | p -> phi, p -> r
lib :: ProductionRuleWithLibrary p phi r => phi ix -> p (r ix)
class BiasedProductionRule p where >||| = flip (<|||) <||| = flip (>|||)
(>|||) :: BiasedProductionRule p => p a -> p a -> p a
(<|||) :: BiasedProductionRule p => p a -> p a -> p a

module Text.GrammarCombinators.Base.Grammar
type RegularRule (phi :: * -> *) (r :: * -> *) t v = forall p. (ProductionRule p, EpsProductionRule p, TokenProductionRule p t) => p v
type PenaltyRegularRule (phi :: * -> *) (r :: * -> *) t v = forall p. (ProductionRule p, EpsProductionRule p, TokenProductionRule p t, PenaltyProductionRule p) => p v
type BiasedRegularRule (phi :: * -> *) (r :: * -> *) t v = forall p. (ProductionRule p, EpsProductionRule p, TokenProductionRule p t, BiasedProductionRule p) => p v
type ContextFreeRule phi r t v = forall p. (ProductionRule p, EpsProductionRule p, RecProductionRule p phi r, TokenProductionRule p t) => p v
type PenaltyContextFreeRule phi r t v = forall p. (ProductionRule p, EpsProductionRule p, RecProductionRule p phi r, TokenProductionRule p t, PenaltyProductionRule p) => p v
type BiasedContextFreeRule phi r t v = forall p. (ProductionRule p, EpsProductionRule p, RecProductionRule p phi r, TokenProductionRule p t, BiasedProductionRule p) => p v
type ExtendedContextFreeRule phi r t v = forall p. (ProductionRule p, EpsProductionRule p, RecProductionRule p phi r, TokenProductionRule p t, LoopProductionRule p phi r) => p v
type PenaltyExtendedContextFreeRule phi r t v = forall p. (ProductionRule p, EpsProductionRule p, RecProductionRule p phi r, TokenProductionRule p t, LoopProductionRule p phi r, PenaltyProductionRule p) => p v
type BiasedExtendedContextFreeRule phi r t v = forall p. (ProductionRule p, EpsProductionRule p, RecProductionRule p phi r, TokenProductionRule p t, LoopProductionRule p phi r, BiasedProductionRule p) => p v
type BiasedExtendedLiftableContextFreeRule phi r t v = forall p. (ProductionRule p, LiftableProductionRule p, RecProductionRule p phi r, TokenProductionRule p t, LoopProductionRule p phi r, BiasedProductionRule p) => p v
type AnyExtendedContextFreeRule phi r t v = forall p. (ProductionRule p, EpsProductionRule p, RecProductionRule p phi r, TokenProductionRule p t, LoopProductionRule p phi r, PenaltyProductionRule p, BiasedProductionRule p) => p v
type LAnyExtendedContextFreeRule phi r t v = forall p. (ProductionRule p, LiftableProductionRule p, RecProductionRule p phi r, TokenProductionRule p t, LoopProductionRule p phi r, PenaltyProductionRule p, BiasedProductionRule p) => p v
type LiftableContextFreeRule phi r t v = forall p. (ProductionRule p, LiftableProductionRule p, RecProductionRule p phi r, TokenProductionRule p t) => p v
type ExtendedLiftableContextFreeRule phi r t v = forall p. (ProductionRule p, LiftableProductionRule p, RecProductionRule p phi r, TokenProductionRule p t, LoopProductionRule p phi r) => p v
type GGrammar rt phi t (r :: * -> *) (rr :: * -> *) = forall ix. phi ix -> rt phi r t (rr ix)
type AGrammar rt phi t = forall r. GGrammar rt phi t r (PF phi r)
type PGrammar rt phi t r = GGrammar rt phi t r r
type GRegularGrammar phi t r rr = GGrammar RegularRule phi t r rr
type GContextFreeGrammar phi t r rr = GGrammar ContextFreeRule phi t r rr
type GLContextFreeGrammar phi t r rr = GGrammar LiftableContextFreeRule phi t r rr
type GPenaltyContextFreeGrammar phi t r rr = GGrammar PenaltyContextFreeRule phi t r rr
type GBiasedContextFreeGrammar phi t r rr = GGrammar BiasedContextFreeRule phi t r rr
type GExtendedContextFreeGrammar phi t r rr = GGrammar ExtendedContextFreeRule phi t r rr
type GPenaltyExtendedContextFreeGrammar phi t r rr = GGrammar PenaltyExtendedContextFreeRule phi t r rr
type GBiasedExtendedContextFreeGrammar phi t r rr = GGrammar BiasedExtendedContextFreeRule phi t r rr
type GAnyExtendedContextFreeGrammar phi t r rr = GGrammar AnyExtendedContextFreeRule phi t r rr
type GLAnyExtendedContextFreeGrammar phi t r rr = GGrammar LAnyExtendedContextFreeRule phi t r rr
type GLExtendedContextFreeGrammar phi t r rr = GGrammar ExtendedLiftableContextFreeRule phi t r rr
type ContextFreeGrammar phi t = AGrammar ContextFreeRule phi t
type LContextFreeGrammar phi t = AGrammar LiftableContextFreeRule phi t
type ExtendedContextFreeGrammar phi t = AGrammar ExtendedContextFreeRule phi t
type PenaltyExtendedContextFreeGrammar phi t r rr = AGrammar PenaltyExtendedContextFreeRule phi t
type BiasedExtendedContextFreeGrammar phi t r rr = AGrammar BiasedExtendedContextFreeRule phi t
type LExtendedContextFreeGrammar phi t = AGrammar ExtendedLiftableContextFreeRule phi t
type ProcessingRegularGrammar phi t r = PGrammar RegularRule phi t r
type ProcessingPenaltyRegularGrammar phi t r = PGrammar PenaltyRegularRule phi t r
type ProcessingBiasedRegularGrammar phi t r = PGrammar BiasedRegularRule phi t r
type ProcessingContextFreeGrammar phi t r = PGrammar ContextFreeRule phi t r
type ProcessingLContextFreeGrammar phi t r = PGrammar LiftableContextFreeRule phi t r
type ProcessingPenaltyContextFreeGrammar phi t r = PGrammar PenaltyContextFreeRule phi t r
type ProcessingBiasedContextFreeGrammar phi t r = PGrammar BiasedContextFreeRule phi t r
type ProcessingExtendedContextFreeGrammar phi t r = PGrammar ExtendedContextFreeRule phi t r
type ProcessingPenaltyExtendedContextFreeGrammar phi t r = PGrammar PenaltyExtendedContextFreeRule phi t r
type ProcessingBiasedExtendedContextFreeGrammar phi t r = PGrammar BiasedExtendedContextFreeRule phi t r
type ProcessingLExtendedContextFreeGrammar phi t r = PGrammar ExtendedLiftableContextFreeRule phi t r
type ProcessingLBiasedExtendedContextFreeGrammar phi t r = PGrammar BiasedExtendedLiftableContextFreeRule phi t r

module Text.GrammarCombinators.Base.Processor
type GProcessor phi r rr = forall ix. phi ix -> rr ix -> r ix
type Processor phi r = GProcessor phi r (PF phi r)

-- | A trivial identity processor that keeps current production rule
--   results unmodified.
identityProcessor :: GProcessor phi r r

-- | A trivial processor that throws everything away and returns a value of
--   the type K0 ().
trivialProcessor :: Processor phi (K0 ())
applyProcessor' :: (ProductionRule p, EpsProductionRule p) => (forall ix. phi ix -> p (r ix)) -> GProcessor phi r' r -> (forall ix. phi ix -> p (r' ix))

-- | Apply a given processor to a given context-free grammar.
applyProcessor :: GContextFreeGrammar phi t r rr -> GProcessor phi rr' rr -> GContextFreeGrammar phi t r rr'
applyProcessorL :: LiftFam phi => GLContextFreeGrammar phi t r rr -> GProcessor phi rr' rr -> Q Exp -> GLContextFreeGrammar phi t r rr'

-- | Apply a given processor to a given extended liftable context-free
--   grammar.
applyProcessorLE :: LiftFam phi => GLExtendedContextFreeGrammar phi t r rr -> GProcessor phi rr' rr -> Q Exp -> GLExtendedContextFreeGrammar phi t r rr'

-- | Apply a given processor to a given extended context-free grammar.
applyProcessorE :: GExtendedContextFreeGrammar phi t r rr -> GProcessor phi rr' rr -> GExtendedContextFreeGrammar phi t r rr'

module Text.GrammarCombinators.Base

module Text.GrammarCombinators.Library.Numeric
data DecimalInteger

-- | This domain is intended to be reused in grammars where decimal
--   integers are used. You can refer to the DecimalInteger non-terminal
--   using the <a>lib</a> primitive from the
--   <a>ProductionRuleWithLibrary</a> type class and then obtain the
--   combined grammar by combining your grammar with
--   <a>procNumericGrammar</a> using the <a>combineGrammars</a> function
data NumericDomain ix
DecimalInteger :: NumericDomain DecimalInteger
numericGrammar :: ExtendedContextFreeGrammar NumericDomain Char

-- | The standard processing grammar for domain <a>NumericDomain</a>,
--   intended to be combined with other grammars using the
--   <a>combineGrammars</a> function.
procNumericGrammar :: Read n => ProcessingExtendedContextFreeGrammar NumericDomain Char (NumericValue n)
instance Domain NumericDomain
instance EqFam NumericDomain
instance MemoFam NumericDomain
instance FoldFam NumericDomain
instance ShowFam NumericDomain


-- | This was intended as a common library for top-down parser algorithms,
--   but it is a bit outdated and currently only used by the LL1 parser.
module Text.GrammarCombinators.Parser.TopDown
newtype NonBranchingRule phi r t v
MkNBR :: ((forall ix. phi ix -> [ConcreteToken t] -> NonBranchingRule phi r t (r ix)) -> MaybeT (State [ConcreteToken t]) v) -> NonBranchingRule phi r t v
unNBR :: NonBranchingRule phi r t v -> (forall ix. phi ix -> [ConcreteToken t] -> NonBranchingRule phi r t (r ix)) -> MaybeT (State [ConcreteToken t]) v
nbrEndOfInput :: NonBranchingRule phi r t ()
type UnambiguousTopDownGrammar phi r t = (Domain phi, Token t) => phi ix -> [ConcreteToken t] -> NonBranchingRule phi r t (r ix)
newtype WrapLookaheadNBR phi r t ix
WrapLNBR :: ([ConcreteToken t] -> NonBranchingRule phi r t (r ix)) -> WrapLookaheadNBR phi r t ix
unWrapLNBR :: WrapLookaheadNBR phi r t ix -> [ConcreteToken t] -> NonBranchingRule phi r t (r ix)
parseTopDown :: (Domain phi, Token t) => UnambiguousTopDownGrammar phi r t -> phi ix -> [ConcreteToken t] -> Maybe (r ix)
instance Monad (NonBranchingRule phi r t)
instance Functor (NonBranchingRule phi r t)

module Text.GrammarCombinators.Parser.LL1
data Token t => LL1Table phi t
LL1Table :: Memo phi (K0 (Map t Int)) -> Memo phi (K0 (Maybe Int)) -> Memo phi (K0 (Maybe Int)) -> LL1Table phi t
calcLL1Table :: (Token t, Domain phi) => GContextFreeGrammar phi t r rr -> LL1Table phi t
parseLL1 :: (Domain phi, Token t, ProductionRule (LLRule phi ixT r t)) => ProcessingContextFreeGrammar phi t r -> LL1Table phi t -> phi ix -> [ConcreteToken t] -> Maybe (r ix)
instance RecProductionRule (LLRule phi ixT r t) phi r
instance Token t => TokenProductionRule (LLRule phi ixT r t) t
instance LiftableProductionRule (LLRule phi ixT r t)
instance EpsProductionRule (LLRule phi ixT r t)
instance ProductionRule (LLRule phi ixT r t)
instance Functor (LLRule phi ixT r t)
instance (Domain phi, Token t) => RecProductionRule (FSCalculator phi ixT r t) phi r
instance (Token t, Domain phi) => TokenProductionRule (FSCalculator phi ixT r t) t
instance (Domain phi, Token t) => LiftableProductionRule (FSCalculator phi ixT r t)
instance (Domain phi, Token t) => EpsProductionRule (FSCalculator phi ixT r t)
instance (Domain phi, Token t) => ProductionRule (FSCalculator phi ixT r t)

module Text.GrammarCombinators.Parser.LL1TH
prepareLL1TableTH :: (Domain phi, Token t, Lift (Memo phi (K0 (Map t Int))), Lift (Memo phi (K0 (Maybe Int)))) => GContextFreeGrammar phi t r rr -> Q Exp
instance (Lift k, Lift a) => Lift (Map k a)

module Text.GrammarCombinators.Parser.Packrat
data Result phi r t v
Parsed :: v -> (Derivs phi r t) -> Result phi r t v
NoParse :: Result phi r t v
data Derivs phi r t

-- | Parse a given string according to a given grammar, starting from a
--   given start non-terminal, with a backtracking Packrat parser algorithm
--   (like backtracking recursive descent, but with linear performance in
--   the length of the input).
parsePackrat :: (Token t, MemoFam phi) => ProcessingContextFreeGrammar phi t r -> phi ix -> [ConcreteToken t] -> Result phi r t (r ix)
instance LoopProductionRule (PackratRule phi r t) phi r
instance RecProductionRule (PackratRule phi r t) phi r
instance Token t => TokenProductionRule (PackratRule phi r t) t
instance LiftableProductionRule (PackratRule phi r t)
instance EpsProductionRule (PackratRule phi r t)
instance ProductionRule (PackratRule phi r t)
instance MemoFam phi => MemoFam (PackratDomain phi)
instance DomainMap (PackratDomain phi) phi PRBaseIx
instance Functor (Result phi r t)
instance Show v => Show (Result phi r t v)


-- | This is an experiment, do not use.
module Text.GrammarCombinators.Parser.RealLL1
data Token t => FirstSet t
FS :: Set t -> Bool -> Bool -> FirstSet t
firstTokens :: FirstSet t -> Set t
canBeEmpty :: FirstSet t -> Bool
canBeEOI :: FirstSet t -> Bool
data BranchSelectorMemo t
DefaultBranchSelectorMemo :: BranchSelectorMemo t
SplitBranchSelectorMemoL :: (FirstSet t) -> (BranchSelectorMemo t) -> (BranchSelectorMemo t) -> BranchSelectorMemo t
FlipBS :: (BranchSelectorMemo t) -> BranchSelectorMemo t
newtype RealLL1Table phi t
MkRealLL1Table :: Memo phi (K0 (BranchSelectorMemo t)) -> RealLL1Table phi t
parseRealLL1 :: (Domain phi, Token t) => RealLL1Grammar phi ixT r r t -> RealLL1Table phi t -> phi ix -> [ConcreteToken t] -> Maybe (r ix)
prepareLL1Parser :: (Domain phi, Token t) => BSCGrammar phi r t rr -> RealLL1Table phi t
instance Token t => Show (FirstSet t)
instance RecProductionRule (RealLL1Rule phi ixT r t) phi r
instance Token t => TokenProductionRule (RealLL1Rule phi ixT r t) t
instance EpsProductionRule (RealLL1Rule phi ixT r t)
instance LiftableProductionRule (RealLL1Rule phi ixT r t)
instance ProductionRule (RealLL1Rule phi ixT r t)
instance (Token t, Domain phi) => LoopProductionRule (BranchSelectorComputer phi r t) phi r
instance (Token t, Domain phi) => RecProductionRule (BranchSelectorComputer phi r t) phi r
instance (Token t, Domain phi) => TokenProductionRule (BranchSelectorComputer phi r t) t
instance (Domain phi, Token t) => EpsProductionRule (BranchSelectorComputer phi r t)
instance (Domain phi, Token t) => LiftableProductionRule (BranchSelectorComputer phi r t)
instance (Domain phi, Token t) => ProductionRule (BranchSelectorComputer phi r t)

module Text.GrammarCombinators.Transform.UnfoldLoops

-- | Unfold loops in a given grammar, replacing calls to <a>manyRef</a> idx
--   by <a>manyInf</a> (<a>ref</a> idx) and likewise for <a>many1Ref</a>
unfoldLoops :: GExtendedContextFreeGrammar phi t r rr -> GContextFreeGrammar phi t r rr

-- | Unfold loops in a given grammar, replacing calls to <a>manyRef</a> idx
--   by <a>manyInf</a> (<a>ref</a> idx) and likewise for <a>many1Ref</a>
unfoldLoopsP :: GPenaltyExtendedContextFreeGrammar phi t r rr -> GPenaltyContextFreeGrammar phi t r rr

-- | Unfold loops in a given rule, replacing calls to <a>manyRef</a> idx by
--   <a>manyInf</a> (<a>ref</a> idx) and likewise for <a>many1Ref</a>
unfoldLoopsRule :: ExtendedContextFreeRule phi r t v -> ContextFreeRule phi r t v

-- | Replace loops in a given rule by rules provided in two provided sets
--   of rules, replacing calls to <a>manyRef</a> by the corresponding rule
--   from the first set, and calls to <a>manyRef</a> by the corresponding
--   rule from the second set. You likely don't need this and should be
--   looking at <a>unfoldLoops</a> or <a>unfoldLoopsRule</a> instead.
replaceLoopsRule :: (ProductionRule p, EpsProductionRule p, RecProductionRule p phi r, TokenProductionRule p t) => ExtendedContextFreeRule phi r t v -> (forall ix. phi ix -> p [r ix]) -> (forall ix. phi ix -> p [r ix]) -> p v
instance (ProductionRule p, LiftableProductionRule p, RecProductionRule p phi r) => LoopProductionRule (UnfoldLoopsWrapper p phi ixT r t) phi r
instance RecProductionRule p phi r => RecProductionRule (UnfoldLoopsWrapper p phi ixT r t) phi r
instance PenaltyProductionRule p => PenaltyProductionRule (UnfoldLoopsWrapper p phi ixT r t)
instance TokenProductionRule p t => TokenProductionRule (UnfoldLoopsWrapper p phi ixT r t) t
instance EpsProductionRule p => EpsProductionRule (UnfoldLoopsWrapper p phi ixT r t)
instance LiftableProductionRule p => LiftableProductionRule (UnfoldLoopsWrapper p phi ixT r t)
instance ProductionRule p => ProductionRule (UnfoldLoopsWrapper p phi ixT r t)

module Text.GrammarCombinators.Transform.UnfoldRecursion

-- | A value of type UnfoldDepth defines for each non-terminal in a grammar
--   how many times it should be unfolded by the <a>unfoldSelective</a> or
--   <a>unfoldSelectiveE</a> algorithms.
type UnfoldDepth phi = forall ix. phi ix -> Integer

-- | Unfold recursion in a given contextx-free grammar, replacing calls to
--   <a>ref</a> idx with the non-terminal's production rule. This produces
--   production rules similar to those in traditional parser combinator
--   libraries.
unfoldRecursion :: ProcessingContextFreeGrammar phi t r -> ProcessingRegularGrammar phi t r
unfoldRecursionP :: ProcessingPenaltyContextFreeGrammar phi t r -> ProcessingPenaltyRegularGrammar phi t r
unfoldRecursionB :: ProcessingBiasedContextFreeGrammar phi t r -> ProcessingBiasedRegularGrammar phi t r

-- | Unfold recursion in a given extended context-free grammar, replacing
--   calls to <a>ref</a> idx with the non-terminal's production rule. This
--   produces production rules similar to those in traditional parser
--   combinator libraries.
unfoldRecursionE :: ProcessingExtendedContextFreeGrammar phi t r -> ProcessingRegularGrammar phi t r

-- | A value of type <a>UnfoldDepth</a> phi indicating nothing should be
--   unfolded at all. This can be used as a start value and then further
--   modified with the <a>selectNT</a> function.
selectNothing :: UnfoldDepth phi

-- | A value of type <a>UnfoldDepth</a> phi indicating every non-terminal
--   should be unfolded once.
selectAllOnce :: UnfoldDepth phi

-- | A function modifying a given <a>UnfoldDepth</a> phi by increasing the
--   depth for a given non-terminal by 1.
selectNT :: EqFam phi => UnfoldDepth phi -> phi ix -> UnfoldDepth phi

-- | A function modifying a given <a>UnfoldDepth</a> phi by decreasing the
--   depth for a given non-terminal by 1.
unselectNT :: EqFam phi => UnfoldDepth phi -> phi ix -> UnfoldDepth phi
sumUD :: UnfoldDepth phi -> UnfoldDepth phi -> UnfoldDepth phi
scaleUD :: Integer -> UnfoldDepth phi -> UnfoldDepth phi

-- | A function modifying a given <a>UnfoldDepth</a> phi by applying a
--   given function to the depth for a given non-terminal.
modifyUnfoldDepth :: EqFam phi => UnfoldDepth phi -> (Integer -> Integer) -> phi ix -> UnfoldDepth phi

-- | Selectively unfold a given context-free grammar according to a given
--   <a>UnfoldDepth</a>.
unfoldSelective :: EqFam phi => UnfoldDepth phi -> ProcessingContextFreeGrammar phi t r -> ProcessingContextFreeGrammar phi t r

-- | Selectively unfold a given extended context-free grammar according to
--   a given <a>UnfoldDepth</a>.
unfoldSelectiveE :: EqFam phi => UnfoldDepth phi -> ProcessingExtendedContextFreeGrammar phi t r -> ProcessingExtendedContextFreeGrammar phi t r

-- | Unfold a given context-free rule by replacing all references to
--   non-terminals with the production rule for that non-terminal in a
--   given processing context-free grammar.
unfoldRule :: ContextFreeRule phi r t v -> ProcessingContextFreeGrammar phi t r -> ContextFreeRule phi r t v

-- | Unfold a given extended context-free rule by replacing all references
--   to non-terminals with the production rule for that non-terminal in a
--   given processing extended context-free grammar.
unfoldRuleE :: ExtendedContextFreeRule phi r t v -> ProcessingExtendedContextFreeGrammar phi t r -> ExtendedContextFreeRule phi r t v
instance LoopProductionRule p phi r => LoopProductionRule (RPWRule p phi ixT r t) phi r
instance ProductionRule p => RecProductionRule (RPWRule p phi ixT r t) phi r
instance TokenProductionRule p t => TokenProductionRule (RPWRule p phi ixT r t) t
instance EpsProductionRule p => EpsProductionRule (RPWRule p phi ixT r t)
instance BiasedProductionRule p => BiasedProductionRule (RPWRule p phi ixT r t)
instance PenaltyProductionRule p => PenaltyProductionRule (RPWRule p phi ixT r t)
instance LiftableProductionRule p => LiftableProductionRule (RPWRule p phi ixT r t)
instance ProductionRule p => ProductionRule (RPWRule p phi ixT r t)

module Text.GrammarCombinators.Parser.RecursiveDescent

-- | Parse a given string according to a given grammar, starting from a
--   given start non-terminal, with a simple backtracking recursive descent
--   parser algorithm.
parseRecDec :: Token t => ProcessingContextFreeGrammar phi t r -> phi ix -> [ConcreteToken t] -> Maybe (r ix)
instance Monad (RecDecRule t)
instance Token t => TokenProductionRule (RecDecRule t) t
instance LiftableProductionRule (RecDecRule t)
instance EpsProductionRule (RecDecRule t)
instance ProductionRule (RecDecRule t)
instance MonadPlus (RecDecRule t)


-- | UUParse compatibility module.
module Text.GrammarCombinators.Parser.UUParse

-- | Parse a given string according to a given grammar, starting from a
--   given start symbol using the UUParse error-correcting parsing library
--   (always produces a result)
parseUU :: (Token t, IsLocationUpdatedBy loc (ConcreteToken t)) => ProcessingContextFreeGrammar phi t r -> phi ix -> loc -> [ConcreteToken t] -> r ix

-- | Parse a given string according to a given regular grammar, starting
--   from a given start symbol using the UUParse error-correcting parsing
--   library (always produces a result)
parseUUR :: (Token t, IsLocationUpdatedBy loc (ConcreteToken t)) => ProcessingRegularGrammar phi t r -> phi ix -> loc -> [ConcreteToken t] -> r ix

-- | Parse a given string according to a given regular production rule
--   using the UUParse error-correcting parsing library (always produces a
--   result).
parseUURule :: (Token t, IsLocationUpdatedBy loc (ConcreteToken t)) => RegularRule phi r t v -> loc -> [ConcreteToken t] -> v

-- | Parse a given string according to a given extended grammar, starting
--   from a given start symbol using the UUParse error-correcting parsing
--   library (always produces a result)
parseUUE :: (Token t, IsLocationUpdatedBy loc (ConcreteToken t)) => ProcessingExtendedContextFreeGrammar phi t r -> phi ix -> loc -> [ConcreteToken t] -> r ix
instance (Token t, Show ct, ConcreteToken t ~ ct, IsLocationUpdatedBy loc ct) => TokenProductionRule (WrapP t loc ct) t
instance Token t => LiftableProductionRule (WrapP t loc ct)
instance Token t => EpsProductionRule (WrapP t loc ct)
instance Token t => ProductionRule (WrapP t loc ct)

module Text.GrammarCombinators.TH.Base
instance Lift (v (supIxT ix)) => Lift (SubVal supIxT v ix)
instance Lift v => Lift (K0 v ix)
instance Lift v => Lift (Set v)

module Text.GrammarCombinators.Transform.FoldLoops

-- | A parametrised type such that <a>FLBaseIx</a> ix represents base
--   non-terminal ix.
data FLBaseIx ix

-- | A parametrised type such that <a>FLBaseIx</a> ix represents the
--   Kleene-<a>*</a> version of base non-terminal ix.
data FLManyIx ix

-- | FoldLoopsDomain phi defines, for base domain phi, an extended domain
--   containing non-terminal types <a>FLBaseIx</a> ix representing base
--   non-terminal ix, and <a>FLManyIx</a> ix representing a Kleene-*
--   version of base non-terminal ix.
data FoldLoopsDomain phi ix
FLBase :: phi ix -> FoldLoopsDomain phi (FLBaseIx ix)
FLMany :: phi ix -> FoldLoopsDomain phi (FLManyIx ix)

-- | FoldLoopsValue defines, for a semantic value family r over base domain
--   phi, a semantic value family <a>FoldLoopsValue</a> r over domain
--   <a>FoldLoopsDomain</a> r, such that the semantic value for base
--   non-terminal <a>FLBaseIx</a> is a wrapped version of type r ix, and
--   for Kleene-* non-terminal <a>FLManyIx</a> a wrapped version of type [r
--   ix].

-- | FoldLoopsResultValue defines, for semantic value families r and rr
--   over base domain phi, a semantic value family
--   <a>FoldLoopsResultValue</a> r rr over domain <a>FoldLoopsDomain</a> r.
--   such that the semantic value for base non-terminal <a>FLBaseIx</a> is
--   a wrapped version of type rr ix, and for Kleene-* non-terminal
--   <a>FLManyIx</a> a wrapped version of type [r ix].

-- | Construct a processor for a grammar transformed using the
--   <a>foldLoops</a> algorithm, given a processor for the original
--   grammar.
processFoldLoops :: GProcessor phi r rr -> GProcessor (FoldLoopsDomain phi) (FoldLoopsValue r) (FoldLoopsResultValue r rr)

-- | Transform a given extended context-free grammar over a domain
--   <tt>phi</tt> into a standard context-free grammar over the extended
--   domain <a>FoldLoopsDomain</a> <tt>phi</tt>. Calls to <a>manyRef</a>
--   idx are transformed into calls to <a>ref</a> (<a>FLMany</a> idx),
--   where <a>FLMany</a> idx is a new non-terminal representing the
--   Kleene-* version of underlying non-terminal <tt>idx</tt>. Normal calls
--   to <a>ref</a> idx are transformed into calls to <a>ref</a>
--   (<a>FLBase</a> idx) where <a>FLBase</a> idx represents the unmodified
--   underlying non-terminal <tt>idx</tt>. The <a>foldLoops</a> algorithm
--   constructs appropriate production rules for both types of new
--   non-terminals. Values are wrapped in the <a>FoldLoopsResultValue</a>
--   <tt>r</tt> <tt>rr</tt> semantic value family.
foldLoops :: GExtendedContextFreeGrammar phi t r rr -> GContextFreeGrammar (FoldLoopsDomain phi) t (FoldLoopsValue r) (FoldLoopsResultValue r rr)

-- | Transform a given processing extended context-free grammar over a
--   domain <tt>phi</tt> into a standard context-free grammar over the
--   extended domain 'FoldLoopsDomain phi'. Completely similar to
--   <a>foldLoops</a>, but wraps values in the <a>FoldLoopsValue</a>
--   <tt>r</tt> semantic value family.
foldAndProcessLoops :: Token t => ProcessingExtendedContextFreeGrammar phi t r -> ProcessingContextFreeGrammar (FoldLoopsDomain phi) t (FoldLoopsValue r)
instance Show (r ix) => Show (FoldLoopsValue r (FLManyIx ix))
instance Show (r ix) => Show (FoldLoopsValue r (FLBaseIx ix))
instance (ProductionRule p, EpsProductionRule p, LiftableProductionRule p, TokenProductionRule p t, RecProductionRule p (FoldLoopsDomain phi) (FoldLoopsValue r)) => LoopProductionRule (FLWrap p (FoldLoopsDomain phi) (FoldLoopsValue r) phi r t) phi r
instance (RecProductionRule p (FoldLoopsDomain phi) (FoldLoopsValue r), ProductionRule p, EpsProductionRule p) => RecProductionRule (FLWrap p (FoldLoopsDomain phi) (FoldLoopsValue r) phi r t) phi r
instance TokenProductionRule p t => TokenProductionRule (FLWrap p (FoldLoopsDomain phi) (FoldLoopsValue r) phi r t) t
instance LiftableProductionRule p => LiftableProductionRule (FLWrap p (FoldLoopsDomain phi) (FoldLoopsValue r) phi r t)
instance EpsProductionRule p => EpsProductionRule (FLWrap p (FoldLoopsDomain phi) (FoldLoopsValue r) phi r t)
instance ProductionRule p => ProductionRule (FLWrap p (FoldLoopsDomain phi) (FoldLoopsValue r) phi r t)
instance Domain phi => Domain (FoldLoopsDomain phi)
instance MemoFam phi => MemoFam (FoldLoopsDomain phi)
instance DomainMap (FoldLoopsDomain phi) phi FLManyIx
instance DomainMap (FoldLoopsDomain phi) phi FLBaseIx
instance EqFam phi => EqFam (FoldLoopsDomain phi)
instance ShowFam phi => ShowFam (FoldLoopsDomain phi)
instance FoldFam phi => FoldFam (FoldLoopsDomain phi)

module Text.GrammarCombinators.TH.FoldLoops
instance (Lift (Memo phi (SubVal FLBaseIx v)), Lift (Memo phi (SubVal FLManyIx v))) => Lift (Memo (FoldLoopsDomain phi) v)

module Text.GrammarCombinators.TH.RealLL1
liftRealLL1Table :: Lift (Memo phi (K0 (BranchSelectorMemo t))) => RealLL1Table phi t -> Q Exp
instance Token t => Lift (BranchSelectorMemo t)
instance Token t => Lift (FirstSet t)

module Text.GrammarCombinators.Transform.CombineEpsilons

-- | Combine consecutive epsilon rules in a given grammar into a single
--   epsilon rule.
combineEpsilons :: GContextFreeGrammar phi t r rr -> GContextFreeGrammar phi t r rr

-- | Combine consecutive epsilon rules in a given extended grammar into a
--   single epsilon rule.
combineEpsilonsE :: GExtendedContextFreeGrammar phi t r rr -> GExtendedContextFreeGrammar phi t r rr
instance (EpsProductionRule p, LoopProductionRule p phi r) => LoopProductionRule (CombineEpsilonsRule p phi r t) phi r
instance RecProductionRule p phi r => RecProductionRule (CombineEpsilonsRule p phi r t) phi r
instance TokenProductionRule p t => TokenProductionRule (CombineEpsilonsRule p phi r t) t
instance EpsProductionRule p => LiftableProductionRule (CombineEpsilonsRule p phi r t)
instance EpsProductionRule p => EpsProductionRule (CombineEpsilonsRule p phi r t)
instance (ProductionRule p, EpsProductionRule p) => ProductionRule (CombineEpsilonsRule p phi r t)

module Text.GrammarCombinators.Transform.CombineGrammars

-- | Combine two grammars into a single one. The argument grammars are over
--   different domains <tt>phiL</tt> and <tt>phiR</tt>, but they are
--   allowed to refer to each other's non-terminals using the <a>lib</a>
--   primitive from the <a>ProductionRuleWithLibrary</a> type class. The
--   resulting grammar is over the combined domain 'MergeDomain phiL phiR'.
combineGrammars :: (EpsProductionRule p, ProductionRule p, TokenProductionRule p t, RecProductionRule p (MergeDomain phiL phiR) (EitherFunctor rL rR), LoopProductionRule p (MergeDomain phiL phiR) (EitherFunctor rL rR)) => (forall p' ix'. (ProductionRule p', EpsProductionRule p', TokenProductionRule p' t, RecProductionRule p' phiL rL, LoopProductionRule p' phiL rL, ProductionRuleWithLibrary p' phiR rR) => phiL ix' -> p' (rrL ix')) -> (forall p' ix'. (ProductionRule p', EpsProductionRule p', TokenProductionRule p' t, RecProductionRule p' phiR rR, LoopProductionRule p' phiR rR, ProductionRuleWithLibrary p' phiL rL) => phiR ix' -> p' (rrR ix')) -> MergeDomain phiL phiR ix -> p (EitherFunctor rrL rrR ix)
instance (EpsProductionRule p, ProductionRule p, LoopProductionRule p (MergeDomain phiL phiR) (EitherFunctor rL rR)) => LoopProductionRule (IGW p phiL phiR rL rR t) (MergeDomain phiR phiL) (EitherFunctor rR rL)
instance (EpsProductionRule p, ProductionRule p, RecProductionRule p (MergeDomain phiL phiR) (EitherFunctor rL rR)) => RecProductionRule (IGW p phiL phiR rL rR t) (MergeDomain phiR phiL) (EitherFunctor rR rL)
instance ProductionRule p => ProductionRule (IGW p phiL phiR rL rR t)
instance TokenProductionRule p t => TokenProductionRule (IGW p phiL phiR rL rR t) t
instance LiftableProductionRule p => LiftableProductionRule (IGW p phiL phiR rL rR t)
instance EpsProductionRule p => EpsProductionRule (IGW p phiL phiR rL rR t)
instance TokenProductionRule p t => TokenProductionRule (CGW p phiL phiR rL rR t) t
instance EpsProductionRule p => EpsProductionRule (CGW p phiL phiR rL rR t)
instance LiftableProductionRule p => LiftableProductionRule (CGW p phiL phiR rL rR t)
instance ProductionRule p => ProductionRule (CGW p phiL phiR rL rR t)
instance (EpsProductionRule p, ProductionRule p, RecProductionRule p (MergeDomain phiL phiR) (EitherFunctor rL rR)) => ProductionRuleWithLibrary (CGW p phiL phiR rL rR t) phiR rR
instance (EpsProductionRule p, ProductionRule p, LoopProductionRule p (MergeDomain phiL phiR) (EitherFunctor rL rR)) => LoopProductionRule (CGW p phiL phiR rL rR t) phiL rL
instance (EpsProductionRule p, ProductionRule p, RecProductionRule p (MergeDomain phiL phiR) (EitherFunctor rL rR)) => RecProductionRule (CGW p phiL phiR rL rR t) phiL rL

module Text.GrammarCombinators.Transform.FilterDies

-- | Filter dead branches from a given context-free grammar.
filterDies :: GContextFreeGrammar phi t r rr -> GContextFreeGrammar phi t r rr

-- | Filter dead branches from a given context-free grammar.
filterDiesP :: GPenaltyContextFreeGrammar phi t r rr -> GPenaltyContextFreeGrammar phi t r rr

-- | Filter dead branches from a given extended context-free grammar.
filterDiesE :: GExtendedContextFreeGrammar phi t r rr -> GExtendedContextFreeGrammar phi t r rr

-- | Filter dead branches from a given context-free grammar.
filterDiesPE :: GPenaltyExtendedContextFreeGrammar phi t r rr -> GPenaltyExtendedContextFreeGrammar phi t r rr

-- | Filter dead branches from a given extended context-free grammar.
filterDiesLE :: GLExtendedContextFreeGrammar phi t r rr -> GLExtendedContextFreeGrammar phi t r rr
instance LoopProductionRule p phi r => LoopProductionRule (FilterDiesRule p phi r t) phi r
instance PenaltyProductionRule p => PenaltyProductionRule (FilterDiesRule p phi r t)
instance RecProductionRule p phi r => RecProductionRule (FilterDiesRule p phi r t) phi r
instance TokenProductionRule p t => TokenProductionRule (FilterDiesRule p phi r t) t
instance LiftableProductionRule p => LiftableProductionRule (FilterDiesRule p phi r t)
instance EpsProductionRule p => EpsProductionRule (FilterDiesRule p phi r t)
instance ProductionRule p => ProductionRule (FilterDiesRule p phi r t)

module Text.GrammarCombinators.Utils.CalcFirst
data FirstSet t
FS :: Set t -> Bool -> Bool -> FirstSet t
firstSet :: FirstSet t -> Set t
canBeEmpty :: FirstSet t -> Bool
canBeEOI :: FirstSet t -> Bool
data FSCalculator phi (r :: * -> *) t rr v
type FirstSetGrammar phi r t rr = forall ix. phi ix -> FSCalculator phi r t rr (rr ix)
calcFS :: FSCalculator phi r t rr v -> FirstSetGrammar phi r t rr -> FirstSet t
calcFirst :: (Domain phi, Token t) => GExtendedContextFreeGrammar phi t r rr -> phi ix -> FirstSet t
instance Show t => Show (FirstSet t)
instance (Token t, EqFam phi) => LoopProductionRule (FSCalculator phi r t rr) phi r
instance (Token t, EqFam phi) => RecProductionRule (FSCalculator phi r t rr) phi r
instance Token t => TokenProductionRule (FSCalculator phi r t rr) t
instance Token t => LiftableProductionRule (FSCalculator phi r t rr)
instance Token t => EpsProductionRule (FSCalculator phi r t rr)
instance Token t => ProductionRule (FSCalculator phi r t rr)


-- | Compatibility component for the Parsec library.
module Text.GrammarCombinators.Transform.IntroduceBias
introduceBias :: (Token t, EqFam phi) => ProcessingContextFreeGrammar phi t r -> ProcessingBiasedContextFreeGrammar phi t r
introduceBiasE :: (Token t, EqFam phi) => ProcessingExtendedContextFreeGrammar phi t r -> ProcessingBiasedExtendedContextFreeGrammar phi t r
introduceBiasLE :: (Token t, EqFam phi) => ProcessingLExtendedContextFreeGrammar phi t r -> ProcessingLBiasedExtendedContextFreeGrammar phi t r
instance (Token t, EqFam phi, BiasedProductionRule p, LiftableProductionRule p, LoopProductionRule p phi r) => LoopProductionRule (IBW p phi r t rr) phi r
instance (Token t, EqFam phi, RecProductionRule p phi r) => RecProductionRule (IBW p phi r t rr) phi r
instance (Token t, TokenProductionRule p t) => TokenProductionRule (IBW p phi r t rr) t
instance (Token t, EpsProductionRule p, BiasedProductionRule p) => EpsProductionRule (IBW p phi r t rr)
instance (Token t, LiftableProductionRule p, BiasedProductionRule p) => LiftableProductionRule (IBW p phi r t rr)
instance (Token t, ProductionRule p, BiasedProductionRule p) => ProductionRule (IBW p phi r t rr)


-- | Compatibility component for the Parsec library.
module Text.GrammarCombinators.Parser.Parsec

-- | Parse a given string according to a given grammar, starting from a
--   given start non-terminal, using the Parsec parser library. Currently
--   uses backtracking for every branch.
parseParsec :: Token t => ProcessingBiasedContextFreeGrammar phi t r -> phi ix -> SourceName -> [ConcreteToken t] -> Either ParseError (r ix)
parseParsecR :: Token t => ProcessingBiasedRegularGrammar phi t r -> phi ix -> SourceName -> [ConcreteToken t] -> Either ParseError (r ix)
parseParsecBiased :: (Token t, EqFam phi) => ProcessingContextFreeGrammar phi t r -> phi ix -> SourceName -> [ConcreteToken t] -> Either ParseError (r ix)
data WrapGenParser t v
unWGP :: WrapGenParser t v -> Parsec [ConcreteToken t] () v
instance Token t => TokenProductionRule (WrapGenParser t) t
instance Token t => LiftableProductionRule (WrapGenParser t)
instance Token t => EpsProductionRule (WrapGenParser t)
instance BiasedProductionRule (WrapGenParser t)
instance Token t => ProductionRule (WrapGenParser t)

module Text.GrammarCombinators.Transform.LeftCorner
data LCBaseIx ix
data LCNTMinNTIx ix' ix
data LCNTMinTIx t ix

-- | <a>LCDomain</a> defines, for a base domain phi an extended domain
--   containing the non-terminals used by the left- corner transform.
data LCDomain phi t ix
LCBase :: phi ix -> LCDomain phi t (LCBaseIx ix)
LCNTMinNT :: phi ix' -> phi ix -> LCDomain phi t (LCNTMinNTIx ix' ix)
LCNTMinT :: t -> phi ix -> LCDomain phi t (LCNTMinTIx t ix)

-- | Apply the left-corner transform to a given grammar, removing direct
--   and indirect left recursion.
--   
--   Note that the new domain will contain O(n*t + n^2) non-terminals where
--   n is the amount of non-terminals and t is the number of tokens, so
--   when using this transformation, it can be beneficial to use a token
--   type with a more limited amount of token values than <a>Char</a>, at
--   least if you will use algorithms that fold over the full new grammar's
--   domain (e.g. <tt>printGrammar</tt> does,
--   <tt>printReachableGrammar</tt> doesn't).
transformLeftCorner :: (Domain phi, Token t) => ProcessingContextFreeGrammar phi t r -> ProcessingContextFreeGrammar (LCDomain phi t) t (LCValue r t)

-- | Apply the left-corner transform to a given extended grammar, removing
--   direct and indirect left recursion.
transformLeftCornerE :: (Domain phi, Token t) => ProcessingExtendedContextFreeGrammar phi t r -> ProcessingExtendedContextFreeGrammar (LCDomain phi t) t (LCValue r t)
instance Show (r ix) => Show (LCValue r t (LCBaseIx ix))
instance (EqFam phi, EpsProductionRule p, LoopProductionRule p (LCDomain phi t) (LCValue r t)) => LoopProductionRule (TransformLCRule p (LCDomain phi t) (LCValue r t) phi r t) phi r
instance (ProductionRule p, EqFam phi, EpsProductionRule p, RecProductionRule p (LCDomain phi t) (LCValue r t)) => RecProductionRule (TransformLCRule p (LCDomain phi t) (LCValue r t) phi r t) phi r
instance (Token t, TokenProductionRule p t, ProductionRule p, LiftableProductionRule p, RecProductionRule p (LCDomain phi t) (LCValue r t)) => TokenProductionRule (TransformLCRule p unused1 unused2 phi r t) t
instance (ProductionRule p, EpsProductionRule p, RecProductionRule p (LCDomain phi t) (LCValue r t)) => LiftableProductionRule (TransformLCRule p (LCDomain phi t) (LCValue r t) phi r t)
instance (ProductionRule p, EpsProductionRule p, RecProductionRule p (LCDomain phi t) (LCValue r t)) => EpsProductionRule (TransformLCRule p (LCDomain phi t) (LCValue r t) phi r t)
instance (ProductionRule p, EpsProductionRule p, RecProductionRule p (LCDomain phi t) (LCValue r t)) => ProductionRule (TransformLCRule p (LCDomain phi t) (LCValue r t) phi r t)
instance DomainMap (LCDomain phi t) phi LCBaseIx
instance (EqFam phi, Token t) => EqFam (LCDomain phi t)
instance (Domain phi, Token t) => Domain (LCDomain phi t)
instance (MemoFam phi, Token t) => MemoFam (LCDomain phi t)
instance (Token t, FoldFam phi) => FoldFam (LCDomain phi t)
instance (ShowFam phi, Show t) => ShowFam (LCDomain phi t)

module Text.GrammarCombinators.Transform.UniformPaull
data UPDomain phi ix
UPBase :: phi ix -> UPDomain phi (UPBaseIx ix)
UPHead :: phi ix -> UPDomain phi (UPHeadIx ix)
UPTail :: phi ix -> UPDomain phi (UPTailIx ix)
data UPBaseIx ix
data UPHeadIx ix
data UPTailIx ix
unUPBV :: UPValue r (UPBaseIx ix) -> r ix
unUPHV :: UPValue r (UPHeadIx ix) -> r ix
unUPTV :: UPValue r (UPTailIx ix) -> r ix -> r ix

-- | Apply a uniform variant of the classic Paull transformation to a given
--   grammar, removing direct and indirect left recursion.
transformUniformPaull :: Domain phi => ProcessingContextFreeGrammar phi t r -> ProcessingExtendedContextFreeGrammar (UPDomain phi) t (UPValue r)
transformUniformPaullP :: Domain phi => ProcessingPenaltyContextFreeGrammar phi t r -> ProcessingPenaltyExtendedContextFreeGrammar (UPDomain phi) t (UPValue r)

-- | Apply a uniform variant of the classic Paull transformation to a given
--   extended grammar, removing direct and indirect left recursion.
transformUniformPaullE :: Domain phi => ProcessingExtendedContextFreeGrammar phi t r -> ProcessingExtendedContextFreeGrammar (UPDomain phi) t (UPValue r)

-- | Apply a uniform variant of the classic Paull transformation to a given
--   extended liftable grammar, removing direct and indirect left
--   recursion.
transformUniformPaullLE :: Domain phi => ProcessingLExtendedContextFreeGrammar phi t r -> ProcessingLExtendedContextFreeGrammar (UPDomain phi) t (UPValue r)
instance Show (r ix) => Show (UPValue r (UPHeadIx ix))
instance Show (r ix) => Show (UPValue r (UPBaseIx ix))
instance (EqFam phi, LiftableProductionRule p, LoopProductionRule p (UPDomain phi) (UPValue r)) => LoopProductionRule (TransformUPWrapper p surrIx (UPDomain phi) (UPValue r) phi ixT r t) phi r
instance (RecProductionRule p (UPDomain phi) (UPValue r), LiftableProductionRule p, EqFam phi, LoopProductionRule p (UPDomain phi) (UPValue r)) => RecProductionRule (TransformUPWrapper p surrIx (UPDomain phi) (UPValue r) phi ixT r t) phi r
instance (TokenProductionRule p t, ProductionRule p) => TokenProductionRule (TransformUPWrapper p surrIx (UPDomain phi) (UPValue r) phi ixT r t) t
instance PenaltyProductionRule p => PenaltyProductionRule (TransformUPWrapper p surrIx (UPDomain phi) (UPValue r) phi ixT r t)
instance LiftableProductionRule p => LiftableProductionRule (TransformUPWrapper p surrIx (UPDomain phi) (UPValue r) phi ixT r t)
instance EpsProductionRule p => EpsProductionRule (TransformUPWrapper p surrIx (UPDomain phi) (UPValue r) phi ixT r t)
instance (ProductionRule p, LiftableProductionRule p) => ProductionRule (TransformUPWrapper p surrIx (UPDomain phi) (UPValue r) phi ixT r t)
instance Domain phi => Domain (UPDomain phi)
instance MemoFam phi => MemoFam (UPDomain phi)
instance DomainMap (UPDomain phi) phi UPTailIx
instance DomainMap (UPDomain phi) phi UPHeadIx
instance DomainMap (UPDomain phi) phi UPBaseIx
instance EqFam phi => EqFam (UPDomain phi)
instance LiftFam phi => LiftFam (UPDomain phi)
instance ShowFam phi => ShowFam (UPDomain phi)
instance FoldFam phi => FoldFam (UPDomain phi)

module Text.GrammarCombinators.Transform.PenalizeErrors
data MaybeSemanticT r ix
JustV :: r ix -> MaybeSemanticT r ix
fromJustV :: MaybeSemanticT r ix -> r ix
NothingV :: MaybeSemanticT r ix
isJustV :: MaybeSemanticT r ix -> Bool
newtype PBEHProductionRule p (phi :: * -> *) (unusedR :: * -> *) (r :: * -> *) t v
MkPBEH :: p v -> PBEHProductionRule p t v
unPBEH :: PBEHProductionRule p t v -> p v
newtype IsJustApp v
IJA :: Bool -> IsJustApp v
unIJA :: IsJustApp v -> Bool
processPenalizedSimple :: HFunctor phi (PF phi) => Processor phi r -> Processor phi (MaybeSemanticT r)
penalizeErrors' :: (forall ix'. phi ix' -> PBEHProductionRule p phi (MaybeSemanticT r) r t (rr ix')) -> phi ix -> p (rr ix)
penalizeErrorsE :: Token t => GExtendedContextFreeGrammar phi t (MaybeSemanticT r) rr -> GPenaltyExtendedContextFreeGrammar phi t (MaybeSemanticT r) rr
penalizeErrors :: Token t => GContextFreeGrammar phi t (MaybeSemanticT r) rr -> GPenaltyContextFreeGrammar phi t (MaybeSemanticT r) rr
instance Show (r ix) => Show (MaybeSemanticT r ix)
instance Applicative IsJustApp
instance Functor IsJustApp
instance (PenaltyProductionRule p, LiftableProductionRule p, TokenProductionRule p t, Token t) => TokenProductionRule (PBEHProductionRule p phi (MaybeSemanticT r) r t) t
instance (LoopProductionRule p phi (MaybeSemanticT r), LiftableProductionRule p, PenaltyProductionRule p) => LoopProductionRule (PBEHProductionRule p phi (MaybeSemanticT r) r t) phi (MaybeSemanticT r)
instance (RecProductionRule p phi (MaybeSemanticT r), LiftableProductionRule p, PenaltyProductionRule p) => RecProductionRule (PBEHProductionRule p phi (MaybeSemanticT r) r t) phi (MaybeSemanticT r)
instance EpsProductionRule p => EpsProductionRule (PBEHProductionRule p phi (MaybeSemanticT r) r t)
instance LiftableProductionRule p => LiftableProductionRule (PBEHProductionRule p phi (MaybeSemanticT r) r t)
instance ProductionRule p => ProductionRule (PBEHProductionRule p phi (MaybeSemanticT r) r t)

module Text.GrammarCombinators.Utils.IsChainNT

-- | Detect if a given non-terminal in a given extended context free
--   grammar is a chain non-terminal. An NT is a chain NT if all of its
--   productions are chain rules.
isChainNT :: EqFam phi => GExtendedContextFreeGrammar phi t r rr -> phi idx -> Bool
instance EqFam phi => LoopProductionRule (IsChainNT phi r t rr) phi r
instance EqFam phi => RecProductionRule (IsChainNT phi r t rr) phi r
instance TokenProductionRule (IsChainNT phi r t rr) t
instance LiftableProductionRule (IsChainNT phi r t rr)
instance EpsProductionRule (IsChainNT phi r t rr)
instance ProductionRule (IsChainNT phi r t rr)

module Text.GrammarCombinators.Transform.UnfoldChainNTs

-- | Unfold chain non-terminals in a given context- free grammar. A chain
--   non-terminal is a terminal such that its production rule is a numer of
--   epsilons followed by a single normal reference to another
--   non-terminal.
unfoldChainNTs :: EqFam phi => ProcessingContextFreeGrammar phi r t -> ProcessingContextFreeGrammar phi r t

-- | Unfold chain non-terminals in a given extended context-free grammar. A
--   chain non-terminal is a terminal such that its production rule is a
--   numer of epsilons followed by a single normal reference to another
--   non-terminal.
unfoldChainNTsE :: EqFam phi => ProcessingExtendedContextFreeGrammar phi r t -> ProcessingExtendedContextFreeGrammar phi r t
instance (ProductionRule p, EpsProductionRule p, LoopProductionRule p phi r) => LoopProductionRule (RuleToManyWrapper p phi r t) phi r
instance LoopProductionRule p phi r => RecProductionRule (RuleToManyWrapper p phi r t) phi r
instance ProductionRule p => TokenProductionRule (RuleToManyWrapper p phi r t) t
instance (ProductionRule p, EpsProductionRule p) => LiftableProductionRule (RuleToManyWrapper p phi r t)
instance (ProductionRule p, EpsProductionRule p) => EpsProductionRule (RuleToManyWrapper p phi r t)
instance (ProductionRule p, EpsProductionRule p) => ProductionRule (RuleToManyWrapper p phi r t)

module Text.GrammarCombinators.Utils.AssessSize

-- | Assess the size of a given grammar. Primitive rules (<a>token</a>,
--   <a>ref</a>, <a>manyRef</a>, <a>many1Ref</a>, <a>epsilon</a>) are
--   counted as 1 point, combinators like <a>|||</a> or <a>&gt;&gt;&gt;</a>
--   just add the points of their left and right hand sides. Proposals for
--   better metrics are welcome.
assessSize :: (Token t, FoldFam phi) => GExtendedContextFreeGrammar phi t r rr -> Int
instance LoopProductionRule (AssessSizeProductionRule phi r t) phi r
instance RecProductionRule (AssessSizeProductionRule phi r t) phi r
instance Token t => TokenProductionRule (AssessSizeProductionRule phi r t) t
instance LiftableProductionRule (AssessSizeProductionRule phi r t)
instance EpsProductionRule (AssessSizeProductionRule phi r t)
instance ProductionRule (AssessSizeProductionRule phi r t)

module Text.GrammarCombinators.Utils.CombineProcessors
data CombineFam r1 r2 ix
Combine :: (r1 ix) -> (r2 ix) -> CombineFam r1 r2 ix

-- | Combine two semantic processors into a single one that tuples their
--   respective values.
combineProcessors :: GProcessor phi rr1 r1 -> GProcessor phi rr2 r2 -> GProcessor phi (CombineFam rr1 rr2) (CombineFam r1 r2)

module Text.GrammarCombinators.Utils.EnumerateGrammar
type EnumerateParserInternalGrammar phi t = forall ix. phi ix -> Int -> [[ConcreteToken t]]
newtype EnumerateProductionRule phi ixT (r :: * -> *) t v
IPP :: (EnumerateParserInternalGrammar phi t -> Int -> [[ConcreteToken t]]) -> EnumerateProductionRule phi ixT t v
printIPP :: EnumerateProductionRule phi ixT t v -> EnumerateParserInternalGrammar phi t -> Int -> [[ConcreteToken t]]
type EnumerateGrammar phi ixT (r :: * -> *) t rr = forall ix. phi ix -> EnumerateProductionRule phi ixT r t (rr ix)
enumerateGrammar :: (Token t, FoldFam phi, ShowFam phi) => GContextFreeGrammar phi t r rr -> Int -> phi ix -> [[ConcreteToken t]]
enumerateGrammarE :: (Token t, FoldFam phi, ShowFam phi) => GExtendedContextFreeGrammar phi t r rr -> Int -> phi ix -> [[ConcreteToken t]]
instance RecProductionRule (EnumerateProductionRule phi ixT r t) phi r
instance Token t => TokenProductionRule (EnumerateProductionRule phi ixT r t) t
instance EpsProductionRule (EnumerateProductionRule phi ixT r t)
instance LiftableProductionRule (EnumerateProductionRule phi ixT r t)
instance ProductionRule (EnumerateProductionRule phi ixT r t)

module Text.GrammarCombinators.Utils.UnfoldDepthFirst
class ProductionRule p => SimpleRecProductionRule p phi r rr | p -> phi, p -> r, p -> rr where cutRecursion _ = die
ref' :: SimpleRecProductionRule p phi r rr => phi ix -> p (rr ix) -> p (r ix)
cutRecursion :: SimpleRecProductionRule p phi r rr => phi ix -> p (rr ix)
class SimpleLoopProductionRule p phi r rr | p -> phi, p -> r, p -> rr
manyRef' :: SimpleLoopProductionRule p phi r rr => phi ix -> p (rr ix) -> p [r ix]
many1Ref' :: SimpleLoopProductionRule p phi r rr => phi ix -> p (rr ix) -> p [r ix]
newtype UnfoldDepthFirstRule p (phi :: * -> *) (r :: * -> *) t (rr :: * -> *) v
MkFRR :: (UDFGrammar p phi r t rr -> p v) -> UnfoldDepthFirstRule p t v
foldReachableFromRule :: UnfoldDepthFirstRule p t v -> UDFGrammar p phi r t rr -> p v
type UDFGrammar p phi (r :: * -> *) t rr = forall ix. phi ix -> p (rr ix)
newtype WrapUR p r ix
WUR :: p (r ix) -> WrapUR p r ix
unWUR :: WrapUR p r ix -> p (r ix)
declareDead :: (EqFam phi, ProductionRule p, SimpleRecProductionRule p phi r rr) => phi ix -> UDFGrammar p phi r t rr -> UDFGrammar p phi r t rr
unfoldDepthFirst'' :: (ProductionRule p, EqFam phi, TokenProductionRule p t, EpsProductionRule p, BiasedProductionRule p, PenaltyProductionRule p, SimpleRecProductionRule p phi r rr, SimpleLoopProductionRule p phi r rr) => UnfoldDepthFirstRule p phi r t rr v -> GAnyExtendedContextFreeGrammar phi t r rr -> (UDFGrammar p phi r t rr -> UDFGrammar p phi r t rr) -> p v
unfoldDepthFirst' :: (ProductionRule p, EqFam phi, EpsProductionRule p, PenaltyProductionRule p, BiasedProductionRule p, TokenProductionRule p t, SimpleRecProductionRule p phi r rr, SimpleLoopProductionRule p phi r rr) => GAnyExtendedContextFreeGrammar phi t r rr -> (UDFGrammar p phi r t rr -> UDFGrammar p phi r t rr) -> phi ix -> p (rr ix)
unfoldDepthFirstProper :: (ProductionRule p, EqFam phi, EpsProductionRule p, PenaltyProductionRule p, BiasedProductionRule p, TokenProductionRule p t, SimpleRecProductionRule p phi r rr, SimpleLoopProductionRule p phi r rr) => GAnyExtendedContextFreeGrammar phi t r rr -> phi ix -> p (rr ix)
unfoldDepthFirst :: (ProductionRule p, EqFam phi, EpsProductionRule p, PenaltyProductionRule p, BiasedProductionRule p, TokenProductionRule p t, SimpleRecProductionRule p phi r rr, SimpleLoopProductionRule p phi r rr) => GAnyExtendedContextFreeGrammar phi t r rr -> phi ix -> p (r ix)
instance (ProductionRule p, LiftableProductionRule p, SimpleRecProductionRule p phi r rr, SimpleLoopProductionRule p phi r rr) => LoopProductionRule (UnfoldDepthFirstRule p phi r t rr) phi r
instance PenaltyProductionRule p => PenaltyProductionRule (UnfoldDepthFirstRule p phi r t rr)
instance SimpleRecProductionRule p phi r rr => RecProductionRule (UnfoldDepthFirstRule p phi r t rr) phi r
instance TokenProductionRule p t => TokenProductionRule (UnfoldDepthFirstRule p phi r t rr) t
instance LiftableProductionRule p => LiftableProductionRule (UnfoldDepthFirstRule p phi r t rr)
instance EpsProductionRule p => EpsProductionRule (UnfoldDepthFirstRule p phi r t rr)
instance BiasedProductionRule p => BiasedProductionRule (UnfoldDepthFirstRule p phi r t rr)
instance ProductionRule p => ProductionRule (UnfoldDepthFirstRule p phi r t rr)

module Text.GrammarCombinators.Utils.IsDead

-- | Detect if a given non-terminal in a given grammar is dead. A
--   non-terminal is dead if its production rule can never match anything.
isDead :: (EqFam phi, FoldFam phi, MemoFam phi) => GExtendedContextFreeGrammar phi t r rr -> phi ix -> Bool
instance (EqFam phi, MemoFam phi) => SimpleLoopProductionRule (IsDeadRule phi r t rr) phi r rr
instance (EqFam phi, MemoFam phi) => SimpleRecProductionRule (IsDeadRule phi r t rr) phi r rr
instance BiasedProductionRule (IsDeadRule phi r t rr)
instance PenaltyProductionRule (IsDeadRule phi r t rr)
instance TokenProductionRule (IsDeadRule phi r t rr) t
instance LiftableProductionRule (IsDeadRule phi r t rr)
instance EpsProductionRule (IsDeadRule phi r t rr)
instance ProductionRule (IsDeadRule phi r t rr)

module Text.GrammarCombinators.Transform.UnfoldDead

-- | Unfold dead non-terminals in a given context- free grammar, such that
--   the unfolded references can be filtered with the <tt>filterDies</tt>
--   algorithm. This uses the <a>isDead</a> algorithm to detect dead
--   non-terminals.
unfoldDead :: (EqFam phi, FoldFam phi, MemoFam phi) => GContextFreeGrammar phi r t rr -> GContextFreeGrammar phi r t rr

-- | Unfold dead non-terminals in a given extended context- free grammar,
--   such that the unfolded references can be filtered with the
--   <tt>filterDies</tt> algorithm. This uses the <a>isDead</a> algorithm
--   to detect dead non-terminals.
unfoldDeadE :: (EqFam phi, FoldFam phi, MemoFam phi) => GExtendedContextFreeGrammar phi r t rr -> GExtendedContextFreeGrammar phi r t rr

-- | Unfold dead non-terminals in a given extended liftable context- free
--   grammar, such that the unfolded references can be filtered with the
--   <tt>filterDies</tt> algorithm. This uses the <a>isDead</a> algorithm
--   to detect dead non-terminals.
unfoldDeadLE :: (EqFam phi, FoldFam phi, MemoFam phi) => GLExtendedContextFreeGrammar phi r t rr -> GLExtendedContextFreeGrammar phi r t rr
instance (ProductionRule p, LiftableProductionRule p, LoopProductionRule p phi r) => LoopProductionRule (UnfoldDeadRule p phi r t) phi r
instance (ProductionRule p, RecProductionRule p phi r) => RecProductionRule (UnfoldDeadRule p phi r t) phi r
instance TokenProductionRule p t => TokenProductionRule (UnfoldDeadRule p phi r t) t
instance LiftableProductionRule p => LiftableProductionRule (UnfoldDeadRule p phi r t)
instance EpsProductionRule p => EpsProductionRule (UnfoldDeadRule p phi r t)
instance ProductionRule p => ProductionRule (UnfoldDeadRule p phi r t)

module Text.GrammarCombinators.Transform.OptimizeGrammar
optimizeGrammarE :: (Token t, Domain phi) => ProcessingExtendedContextFreeGrammar phi t r -> ProcessingExtendedContextFreeGrammar (UPDomain phi) t (UPValue r)

module Text.GrammarCombinators.Utils.IsReachable

-- | Fold a given function over all non-terminals that are reachable from a
--   given non-terminal. This function will at least fold over the given
--   non-terminal itself.
foldReachable :: Domain phi => GAnyExtendedContextFreeGrammar phi t r rr -> phi ix -> (forall ix'. phi ix' -> n -> n) -> n -> n

-- | Fold a given function over all non-terminals that are reachable from a
--   given non-terminal. This function is limited to proper reachable rules
--   (see <a>isReachableProper</a> for what that means).
foldReachableProper :: Domain phi => GAnyExtendedContextFreeGrammar phi t r rr -> phi ix -> (forall ix'. phi ix' -> n -> n) -> n -> n

-- | Check if a given non-terminal is reachable from a given other
--   non-terminal in a given extended context-free grammar. This function
--   assumes that all grammars are reachable from themselves.
isReachable :: Domain phi => GAnyExtendedContextFreeGrammar phi t r rr -> phi ix -> phi ix' -> Bool

-- | Check if a given non-terminal is reachable from a given other
--   non-terminal in a given extended context-free grammar. For this
--   function, a non- terminal is not automatically considered reachable
--   from itself, but only if it has some production in which a submatch of
--   itself is present.
isReachableProper :: Domain phi => GAnyExtendedContextFreeGrammar phi t r rr -> phi ix -> phi ix' -> Bool
instance EqFam phi => SimpleLoopProductionRule (FoldReachableIntRule phi r t rr n) phi r rr
instance EqFam phi => SimpleRecProductionRule (FoldReachableIntRule phi r t rr n) phi r rr
instance TokenProductionRule (FoldReachableIntRule phi r t rr n) t
instance LiftableProductionRule (FoldReachableIntRule phi r t rr n)
instance EpsProductionRule (FoldReachableIntRule phi r t rr n)
instance BiasedProductionRule (FoldReachableIntRule phi r t rr n)
instance PenaltyProductionRule (FoldReachableIntRule phi r t rr n)
instance ProductionRule (FoldReachableIntRule phi r t rr n)

module Text.GrammarCombinators.Utils.EnumTokens

-- | Enumerate all tokens that can be present in any match of a given
--   production rule.
enumRuleTokens :: (Domain phi, Token t) => ExtendedContextFreeRule phi r t v -> [t]

-- | Enumerate all tokens that can be present in any match of any string
--   that can be matched by a given non-terminal in a given grammar.
enumTokens :: (Token t, Domain phi) => GExtendedContextFreeGrammar phi t r rr -> phi ix -> [t]

-- | Enumerate all tokens that can be present in any match of any string
--   that can be matched by any non-terminal in a given grammar.
enumAllTokens :: (Token t, Domain phi) => GExtendedContextFreeGrammar phi t r rr -> [t]
instance ShowFam phi => LoopProductionRule (EnumTokensRule phi r t) phi r
instance ShowFam phi => RecProductionRule (EnumTokensRule phi r t) phi r
instance Token t => TokenProductionRule (EnumTokensRule phi r t) t
instance EpsProductionRule (EnumTokensRule phi r t)
instance LiftableProductionRule (EnumTokensRule phi r t)
instance ProductionRule (EnumTokensRule phi r t)

module Text.GrammarCombinators.Utils.IsEpsilon

-- | Detect if a given context-free rule is an epsilon rule.
isEpsilon :: ContextFreeRule phi r t v -> Bool
instance LoopProductionRule (IsEpsilonRule phi r t) phi r
instance RecProductionRule (IsEpsilonRule phi r t) phi r
instance TokenProductionRule (IsEpsilonRule phi r t) t
instance EpsProductionRule (IsEpsilonRule phi r t)
instance LiftableProductionRule (IsEpsilonRule phi r t)
instance ProductionRule (IsEpsilonRule phi r t)

module Text.GrammarCombinators.Utils.LiftGrammar

-- | Lift a given grammar to Template Haskell
liftGrammar :: (FoldFam phi, LiftFam phi, Token t) => GLAnyExtendedContextFreeGrammar phi t r rr -> Name -> Q Type -> Q [Dec]

-- | Lift a given grammar to Template Haskell and replace recursion and
--   loops with infinite-tree style recursive calls to the grammar itself.
--   This allows GHC to do a much better optimization (x20 speed-ups in one
--   realistic test, compared with result of <a>liftGrammar</a>).
unfoldAndLiftGrammar :: (FoldFam phi, LiftFam phi, Token t) => GLAnyExtendedContextFreeGrammar phi t r rr -> Name -> Q Type -> Q [Dec]
instance LiftFam phi => LoopProductionRule (LiftedRule phi r t) phi r
instance LiftFam phi => RecProductionRule (LiftedRule phi r t) phi r
instance Token t => TokenProductionRule (LiftedRule phi r t) t
instance LiftableProductionRule (LiftedRule phi r t)
instance PenaltyProductionRule (LiftedRule phi r t)
instance BiasedProductionRule (LiftedRule phi r t)
instance ProductionRule (LiftedRule phi r t)

module Text.GrammarCombinators.Utils.MemoizeGrammar

-- | Memoize the production rules of a regular grammar. Currently not sure
--   if this is ever useful.
memoizeGrammarR :: MemoFam phi => GRegularGrammar phi t r rr -> GRegularGrammar phi t r rr

-- | Memoize the production rules of a grammar. Currently not sure if this
--   is ever useful.
memoizeGrammar :: MemoFam phi => GContextFreeGrammar phi t r rr -> GContextFreeGrammar phi t r rr

-- | Memoize the production rules of an extended grammar. Currently not
--   sure if this is ever useful.
memoizeGrammarE :: MemoFam phi => GExtendedContextFreeGrammar phi t r rr -> GExtendedContextFreeGrammar phi t r rr

module Text.GrammarCombinators.Utils.PrintGrammar

-- | Print out a single production rule
printRule :: (Domain phi, Token t) => GAnyExtendedContextFreeGrammar phi t r rr -> Integer -> phi ix -> String

-- | Print out a full grammar.
printGrammar :: (Domain phi, Token t) => GAnyExtendedContextFreeGrammar phi t r rr -> String

-- | Print out a grammar with a depth limit. Intended for infinite
--   grammars.
printGrammarInf :: (Domain phi, Token t) => GAnyExtendedContextFreeGrammar phi t r rr -> Integer -> String

-- | Print out the part of a grammar that is reachable from a given
--   non-terminal.
printReachableGrammar :: (Domain phi, Token t) => GAnyExtendedContextFreeGrammar phi t r rr -> phi ix -> String
instance ShowFam phi => LoopProductionRule (PrintProductionRule phi r t) phi r
instance ShowFam phi => RecProductionRule (PrintProductionRule phi r t) phi r
instance Token t => TokenProductionRule (PrintProductionRule phi r t) t
instance LiftableProductionRule (PrintProductionRule phi r t)
instance PenaltyProductionRule (PrintProductionRule phi r t)
instance EpsProductionRule (PrintProductionRule phi r t)
instance BiasedProductionRule (PrintProductionRule phi r t)
instance ProductionRule (PrintProductionRule phi r t)

module Text.GrammarCombinators.Utils.ToGraph
ruleToGraph :: (Token t, Domain phi, DynGraph gr) => Int -> GExtendedContextFreeGrammar phi t r rr -> phi ix -> gr String String
graphToGraphviz :: Gr String String -> DotGraph Node
fullGrammarToGraph :: (Token t, Domain phi, DynGraph gr) => Int -> GExtendedContextFreeGrammar phi t r rr -> gr String String
reachableGrammarToGraph :: (Token t, Domain phi, DynGraph gr) => Int -> GExtendedContextFreeGrammar phi t r rr -> phi ix -> gr String String
showGraph :: PrintDotRepr dg n => dg n -> IO ()
instance Domain phi => LoopProductionRule (GraphConstructor phi r t) phi r
instance Domain phi => RecProductionRule (GraphConstructor phi r t) phi r
instance Token t => TokenProductionRule (GraphConstructor phi r t) t
instance LiftableProductionRule (GraphConstructor phi r t)
instance EpsProductionRule (GraphConstructor phi r t)
instance ProductionRule (GraphConstructor phi r t)
