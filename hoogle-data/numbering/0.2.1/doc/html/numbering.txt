-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Combinators for creating bijections from some type to the natural numbers.
--   
--   Combinators for creating bijections from a subset of an arbitrary type
--   to a range of <a>Int</a>s, , e.g. for using libraries that require
--   <a>Int</a> IDs.
@package numbering
@version 0.2.1

module Data.Numbering

-- | Invariant:
--   
--   <pre>
--   For all i in 0 .. <a>nuLength</a> - 1, 
--       <a>toInt</a> (<a>fromInt</a> i) == i 
--   </pre>
--   
--   This implies that
--   
--   <pre>
--   For all a of the form <a>fromInt</a> i (with i in 0 .. <a>nuLength</a> - 1), 
--       <a>fromInt</a> (<a>toInt</a> a) = a
--   </pre>
--   
--   The behaviour of <tt>fromInt</tt> for out-of-bounds indices and that
--   of <tt>toInt</tt> for elements not occuring in the numbering is
--   undefined.
--   
--   Thus, assuming the invariant holds, <tt>toInt</tt> is uniquely
--   determined by <tt>fromInt</tt> (on valid inputs).
data Numbering a

-- | "Unsafe" because the invariant isn't checked.
UnsafeMkNumbering :: (a -> Int) -> (Int -> a) -> Int -> Numbering a
toInt :: Numbering a -> a -> Int
fromInt :: Numbering a -> Int -> a
nuLength :: Numbering a -> Int

-- | <tt>enumNu a b</tt> creates a numbering of the elements <tt>[a ..
--   b]</tt> (inclusively).
enumNu :: Enum a => a -> a -> Numbering a

-- | <tt>enumNu' i j</tt> creates a numbering of the elements <tt>[toEnum i
--   .. toEnum j]</tt> (inclusively).
enumNu' :: Enum a => Int -> Int -> Numbering a

-- | (Uses a <a>Map</a> because <a>Data.Set</a> doesn't expose the
--   necessary index-based API)
nuFromSet :: Map Int ignored -> Numbering Int

-- | The distinctness precondition is checked (we have to create a map
--   anyway).
nuFromDistinctVector :: (Ord a, Show a, Vector v a) => v a -> Numbering a

-- | Allows customization of the map type used.
nuFromDistinctVectorG :: (Show a, Vector v a) => map -> ((a -> Int -> Int -> t) -> a -> Int -> map -> map) -> (a -> map -> Maybe Int) -> v a -> Numbering a

-- | Numbering of all elements of a finite type.
finiteTypeNu :: (Enum a, Bounded a) => Numbering a

-- | Identity numbering
idNu :: Int -> Numbering Int
emptyNu :: Numbering a

-- | See <a>nuFromDistinctVector</a>.
nuFromDistinctList :: (Ord a, Show a) => [a] -> Numbering a

-- | See <a>nuFromDistinctVector</a>.
nuFromDistinctUnboxList :: (Ord a, Show a, Unbox a) => [a] -> Numbering a
nuFromDistinctIntList :: [Int] -> Numbering Int

-- | Uniquifies the input first (resulting in an unspecified order).
nuFromList :: (Ord a, Show a) => [a] -> Numbering a

-- | Uniquifies the input first (resulting in an unspecified order).
nuFromUnboxList :: (Ord a, Show a, Unbox a) => [a] -> Numbering a

-- | Uniquifies the input first (resulting in an unspecified order).
nuFromIntList :: [Int] -> Numbering Int

-- | In <tt>mapNu f g nu</tt>, the arguments must satisfy
--   
--   <pre>
--   For all i in 0 .. <a>nuLength</a> nu - 1, 
--       (g . f) a == a
--            where
--                a = <a>fromInt</a> nu i
--   </pre>
mapNu :: (a -> b) -> (b -> a) -> Numbering a -> Numbering b

-- | In <tt>reindexNu k f g nu</tt>, the arguments must satisfy
--   
--   <pre>
--   For all i in 0 .. k,
--       (g . f) i == i
--   </pre>
--   
--   Note: Decreasing the length with this function will <i>not</i> release
--   any memory retained by the closures in the input numbering (e.g. the
--   vector, for numberings created by <a>nuFromDistinctVector</a>). Use
--   <a>consolidateNu</a> afterwards for that.
reindexNu :: Int -> (Int -> Int) -> (Int -> Int) -> Numbering a -> Numbering a

-- | Semantic <a>id</a> (for in-bounds inputs), but backs the numbering
--   with a new vector and map having just the required length (example:
--   <tt>consolidateNu (<a>nuTake</a> 1 (<a>nuFromDistinctVector</a>
--   largeVector))</tt>).
consolidateNu :: (Ord a, Show a) => Numbering a -> Numbering a

-- | Like <a>consolidateNu</a>, but uses unboxed vectors.
consolidateUnboxNu :: (Ord a, Show a, Unbox a) => Numbering a -> Numbering a
nuTake :: Int -> Numbering a -> Numbering a
reverseNu :: Numbering a -> Numbering a

-- | Identity for nonpositive arg.
nuDrop :: Int -> Numbering a -> Numbering a

-- | Creates a numbering for an <a>Either</a>-like type, given numberings
--   for the summand types.
sumNu :: (a1 -> a) -> (a2 -> a) -> ((a1 -> Int) -> (a2 -> Int) -> a -> Int) -> Numbering a1 -> Numbering a2 -> Numbering a
eitherNu :: Numbering a -> Numbering b -> Numbering (Either a b)

-- | Creates a numbering for an pair-like type, given numberings for the
--   component types.
prodNu :: (a -> a2) -> (a -> a1) -> (a2 -> a1 -> a) -> Numbering a2 -> Numbering a1 -> Numbering a
pairNu :: Numbering a -> Numbering b -> Numbering (a, b)
nuIndices :: Numbering a -> [Int]
nuElements :: Numbering a -> [a]

-- | = <a>nuElements</a>.
nuToList :: Numbering a -> [a]

-- | = <a>nuElements</a>. Won't actually be distinct if the invariant is
--   broken.
nuToDistinctList :: Numbering a -> [a]
nuToVector :: Vector v a => Numbering a -> v a

-- | = <a>nuToVector</a>. Won't actually be distinct if the invariant is
--   broken.
nuToDistinctVector :: Vector v a => Numbering a -> v a
data NumberingBrokenInvariantException a
NumberingBrokenInvariantException :: Int -> a -> Int -> NumberingBrokenInvariantException a
nbie_index :: NumberingBrokenInvariantException a -> Int
nbie_fromIntOfIndex :: NumberingBrokenInvariantException a -> a
nbie_toIntOfFromIntOfIndex :: NumberingBrokenInvariantException a -> Int
checkNu :: Numbering a -> Either (NumberingBrokenInvariantException a) ()
instance Typeable1 NumberingBrokenInvariantException
instance Show a => Show (NumberingBrokenInvariantException a)
instance (Show a, Typeable a) => Exception (NumberingBrokenInvariantException a)
instance Eq a => Eq (Numbering a)
instance Show a => Show (Numbering a)
