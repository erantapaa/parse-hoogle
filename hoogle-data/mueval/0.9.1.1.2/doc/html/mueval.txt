-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Safely evaluate pure Haskell expressions
--   
@package mueval
@version 0.9.1.1.2

module Mueval.Resources

-- | Pull together several methods of reducing priority and easy access to
--   resources: <a>nice</a>, and the rlimit bindings, If called with False,
--   <a>limitResources</a> will not use POSIX rlimits.
limitResources :: Bool -> IO ()

module Mueval.Context

-- | Return false if any of the listed modules cannot be found in the
--   whitelist.
cleanModules :: [String] -> Bool

-- | Modules which we should load by default. These are of course
--   whitelisted. Specifically, we want the Prelude because otherwise
--   things are horribly crippled; we want SimpleReflect so we can do neat
--   things (for said neat things, see
--   <a>http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details</a>);
--   and we want ShowFun to neuter IO stuff even more. The rest should be
--   safe to import without clashes, according to the Lambdabot sources.
defaultModules :: [String]
defaultPackages :: [String]

-- | Borrowed from Lambdabot, this is the whitelist of modules which should
--   be safe to import functions from, but which we don't want to import by
--   default. FIXME: make these qualified imports. The GHC API &amp; Hint
--   currently do not support qualified imports. WARNING: You can import
--   these with --module, certainly, but the onus is on the user to make
--   sure they fully disambiguate function names; ie:
--   
--   <pre>
--   mueval  --module Data.Map -e "Prelude.map (+1) [1..100]"
--   </pre>
qualifiedModules :: [(String, Maybe String)]

module Mueval.ArgsParse

-- | See the results of --help for information on what each option means.
data Options
Options :: Int -> Maybe [String] -> String -> String -> String -> Bool -> Bool -> Bool -> [String] -> Bool -> Bool -> Bool -> [String] -> Bool -> Options
timeLimit :: Options -> Int
modules :: Options -> Maybe [String]
expression :: Options -> String
loadFile :: Options -> String
user :: Options -> String
printType :: Options -> Bool
typeOnly :: Options -> Bool
extensions :: Options -> Bool
namedExtensions :: Options -> [String]
noImports :: Options -> Bool
rLimits :: Options -> Bool
packageTrust :: Options -> Bool
trustedPackages :: Options -> [String]
help :: Options -> Bool
interpreterOpts :: [String] -> Either (Bool, String) Options

-- | Just give us the end result options; this parsing for us. Bonus points
--   for handling UTF.
getOptions :: [String] -> Either (Bool, String) Options
instance Show Options

module Mueval.Interpreter
readExt :: String -> Extension

-- | The actual calling of Hint functionality. The heart of this just calls
--   <a>eval</a>, but we do so much more - we disable Haskell extensions,
--   hide all packages, make sure one cannot call unimported functions,
--   typecheck, set resource limits for this thread, and do some error
--   handling.
interpreter :: Options -> Interpreter (String, String, String)

-- | Wrapper around <a>interpreter</a>; supplies a fresh GHC API session
--   and error-handling. The arguments are largely passed on, and the
--   results lightly parsed.
interpreterSession :: Options -> IO ()

-- | Given a filepath (containing function definitions), copy it to a
--   temporary file and change directory to it, returning the new filepath.
cpload :: FilePath -> IO FilePath

-- | Print the String (presumably the result of interpreting something),
--   but only print the first 1024 characters to avoid flooding. Lambdabot
--   has a similar limit.
sayIO :: String -> IO ()

-- | Oh no, something has gone wrong. If it's a compilation error pretty
--   print the first 1024 chars of it and throw an <a>ExitException</a>
--   otherwise rethrow the exception in String form.
printInterpreterError :: InterpreterError -> IO ()
exceptionMsg :: String

-- | Renders the input String including its exceptions using
--   <tt>exceptionMsg</tt>
render :: (MonadIO m, Functor m) => Int -> String -> m (String, Bool)
data Stream
Cons :: Char -> (IO Stream) -> Stream
Exception :: (IO Stream) -> Stream
End :: Stream
toStream :: String -> IO Stream

module Mueval.Parallel

-- | Fork off a thread which will sleep and then kill off the specified
--   thread.
watchDog :: Int -> ThreadId -> IO ()

-- | A basic blocking operation.
block :: (t -> MVar a -> IO t1) -> t -> IO a

-- | Using MVars, block on <a>forkedMain</a> until it finishes.
forkedMain :: Options -> IO ()

-- | Set a <a>watchDog</a> on this thread, and then continue on with
--   whatever.
forkedMain' :: Options -> MVar String -> IO ThreadId
