-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | OpenCV based machine vision library
--   
--   This is a machine vision package that wraps some functionality of
--   OpenCV library. This package has been developed for personal use and
--   is not meant to be a complete wrapper. It also includes some things
--   not in OpenCV.
--   
--   Currently this package is quite dirty and requires much work on
--   documentation and code clean-up, but is somewhat tested.
--   
--   (The scarce) Documentation is available at
--   <a>http://aleator.github.com/CV/</a>
--   
--   Changelog. 0.3.6.0 - Critical referential transparency bug fix.
--   
--   <ol>
--   <li>3.5.4 - Bug fixes and preliminary compatability with opencv
--   2.4</li>
--   <li>3.5 - Many new wrappers, clean ups and other fixes.</li>
--   <li>3.4 - Pixelwise operations, bug fixes and additional
--   documentation</li>
--   <li>3.3.0 - Improvements, including compatablity with opencv 2.3.1 and
--   removal of dependency with deprecated JYU.Utils</li>
--   </ol>
--   
--   Changelog. 0.3.2.0 - Improvements, including fancier pixel-wise
--   manipulations
--   
--   Changelog. 0.3.0.2 - Workaround for compiling with OS X 10.6 &amp;
--   fixed errors about M_PI
@package CV
@version 0.3.7

module Utils.Stream

-- | Stream of monadic values
data Stream m a
Terminated :: Stream m a
Value :: (m (a, Stream m a)) -> Stream m a

-- | Attaching side effects
sideEffect :: Monad m => (a -> m ()) -> Stream m a -> Stream m a

-- | Repeating stream
listToStream :: Monad m => [a] -> Stream m a
repeatS :: Monad m => a -> Stream m a
repeatSM :: Monad m => m a -> Stream m a

-- | Create a stream by iterating a monadic action
iterateS :: Monad m => (a -> m a) -> a -> Stream m a

-- | Pure and monadic left fold over a stream
foldS :: Monad m => (a -> t -> a) -> a -> Stream m t -> m a
foldSM :: Monad m => (a -> t -> m a) -> a -> Stream m t -> m a

-- | Merge two (time)streams
time :: (t, t1) -> t
value :: (t, t1) -> t1
mergeTimeStreams :: (Monad m, Ord t2) => t -> t1 -> Stream m (t2, t) -> Stream m (t2, t1) -> Stream m (t2, (t, t1))
mergeTimeStreamsWith :: (Monad m, Ord t2) => t -> t1 -> (t -> t1 -> t3) -> Stream m (t2, t) -> Stream m (t2, t1) -> Stream m (t2, t3)
mergeManyW :: (Monad m, Ord t) => [t1] -> (t1 -> t1 -> t1) -> [Stream m (t, t1)] -> Stream m (t, t1)
mergeS :: (Monad m, Ord a) => Stream m (a, t) -> Stream m (a, t1) -> Stream m (LRB (a, t) (a, (t, t1)) (a, t1))
data LRB a b c
L :: a -> LRB a b c
B :: b -> LRB a b c
R :: c -> LRB a b c
mergeE :: Monad m => (t, t1) -> Stream m (LRB (t2, t) (t2, (t, t1)) (t2, t1)) -> Stream m (t2, (t, t1))
push :: Monad m => a -> Stream m a -> Stream m a
zipS :: Applicative f => f a1 -> f a -> f (a1, a)
sequenceS :: Monad m => Stream m (m a) -> (Stream m a)
mapMS :: Monad m => (a -> m b) -> Stream m a -> Stream m b

-- | Drop elements from the stream. Due to stream structure, this operation
--   cannot fail gracefully when dropping more elements than what is found
--   in the stream
dropS :: Monad m => Int -> Stream m a -> Stream m a
takeS :: Monad m => Int -> Stream m a -> Stream m a
takeWhileS :: Monad m => (a -> Bool) -> Stream m a -> Stream m a
consS :: Monad m => a -> Stream m a -> Stream m a
pairS :: Monad m => Stream m a -> Stream m (a, a)
terminateOn :: Monad m => (a -> Bool) -> Stream m a -> Stream m a
runStream :: Monad m => Stream m a -> m [a]
runStream_ :: Monad m => Stream m t -> m ()
runLast :: Monad m => a -> Stream m a -> m a
runLast1 :: Monad m => Stream m a -> m a
instance (Show a, Show b, Show c) => Show (LRB a b c)
instance Monad m => Applicative (Stream m)
instance Monad m => Functor (Stream m)

module Utils.List

-- | Group list into indevidual pairs: [1,2,3,4] =&gt; [(1,2),(3,4)]. Works
--   only with even number of elements
pairs :: [t] -> [(t, t)]

-- | Undo pairs function
fromPairs :: [(a, a)] -> [a]
prop_pairsFromTo :: Eq a => [a] -> Property

-- | Group list into pairs: [1,2,3] =&gt; [(1,2),(2,3)]. Works with non
--   null lists
pairs1 :: [b] -> [(b, b)]

-- | Undo pairs1 function
fromPairs1 :: [(a, a)] -> [a]
prop_pairsFromTo1 :: Eq a => [a] -> Property
crease :: (b1 -> b1 -> b) -> [b1] -> [b]
creaseM :: Monad m => (b -> b -> m a) -> [b] -> m [a]
ranks :: (Enum b, Num b) => (b1 -> b1 -> Ordering) -> [b1] -> [b]
rankBy :: (Enum t, Num t) => (b -> b -> Ordering) -> [b] -> [(t, b)]
clusterBy :: Ord b => (a -> b) -> [a] -> [[a]]
groupItems :: Ord a1 => (a -> a1) -> (a -> b) -> [a] -> [(a1, [b])]
lookupDef :: Eq a1 => a -> a1 -> [(a1, a)] -> a
pairings :: [t] -> [(t, t)]
forEach :: (a -> a) -> [a] -> [[a]]
forPairs :: (b -> b1 -> b) -> [b] -> [b1] -> [[b]]
replicateList :: Int -> [a] -> [a]
concatZipNub :: Eq a => [a] -> [a] -> [a]
histogram :: (Num t, RealFrac a) => a -> [a] -> [(a, t)]
binList :: Integral a => a -> ([b] -> b1) -> [(a, b)] -> [(a, b1)]
zeroMean :: Fractional b => [b] -> [b]
takeNAccordingTo :: Ord a => Int -> ([a], [b]) -> [(a, b)]
select :: (c -> c -> Bool) -> [c] -> [c] -> [c]
takeHalf :: [a] -> [a]
splitToNParts :: Int -> [a] -> [[a]]
prop_splitEq :: Eq a => Int -> [a] -> Property
prop_splitLen :: Int -> [a] -> Property
count :: Num a => (b -> Bool) -> [b] -> a
frequencies :: (Num t, Ord b) => [b] -> [(b, t)]
normalizeFrequencies :: Fractional t1 => [(t, t1)] -> [(t, t1)]
average :: Fractional b => [b] -> b
smallestBy :: (a -> a -> Ordering) -> Int -> [a] -> [a]
smallestBy' :: (a -> a -> Ordering) -> Int -> [a] -> [a] -> [a]
median :: (Fractional a, Ord a) => [a] -> a
takeTail :: Int -> [a] -> [a]
stdDev :: Floating b => [b] -> b
cumulate :: Num a => [a] -> [a]
schwartzianTransform :: (Ord a, Ord b) => (a -> b) -> [a] -> [a]
sortVia :: Ord a => (b -> a) -> [b] -> [b]
comparing :: Ord a => (t -> a) -> t -> t -> Ordering
majority :: Ord a => [a] -> a
getKNeighbourhoods :: Int -> [a] -> [[a]]
prop_headIdentical_KN :: Eq b => Int -> [b] -> Property
splitToLength :: Int -> [a] -> [[a]]
takeLengths :: [Int] -> [a] -> [[a]]
prop_takeLen :: [Int] -> [a] -> Property
prop_takeLens :: [Int] -> [a] -> Property
splitBy :: (a -> Bool) -> [a] -> [[a]]
splitBetween :: (a -> a -> Bool) -> [a] -> [a] -> [[a]]
tear :: (a -> Bool) -> [a] -> ([a], [a])
swapEverywhere :: [a] -> [a] -> [[a]]
takeWhile2 :: (a -> a -> Bool) -> [a] -> [a]
applyMap :: t -> [t -> b] -> [b]
applyMapM :: Monad m => a -> [a -> m b] -> m [b]
changesM :: Monad m => [a -> m b] -> a -> m [b]
rollList :: [a] -> [a]
roll :: [a] -> [a]
mergeList :: [a] -> [a] -> [a]
takeWhile1 :: (a -> Bool) -> [a] -> [a]
editingMap :: ([t] -> t -> t) -> [t] -> [t]
editingTrav :: ([t] -> t -> t) -> [t] -> [t] -> [t]
rotate :: [a] -> [a]
cycles :: [a] -> [[a]]

module Utils.Function
both :: (t -> t1) -> (t, t) -> (t1, t1)
with :: (t -> t1) -> t -> (t, t1)
under :: (t1 -> t) -> (t2 -> t3 -> t1) -> t2 -> t3 -> t
affine1d :: Fractional t => (t, t) -> (t, t) -> t -> t
mkFst :: (t1 -> t) -> t1 -> (t, t1)
mkSnd :: (t -> t1) -> t -> (t, t1)
minBy :: (a -> a -> Ordering) -> a -> a -> a
maxBy :: (a -> a -> Ordering) -> a -> a -> a

module Utils.Pointer
withPtrList :: [ForeignPtr a] -> (Ptr (Ptr a) -> IO b) -> IO b

module Utils.DrawingClass
class Draws a b
draw :: Draws a b => a -> b

module Utils.Point
type Pt a = (a, a)
norm2 :: Num a => Pt a -> a
norm :: Pt Double -> Double
(>/) :: (Integral t, Integral t1) => (t, t1) -> (t, t1) -> (t, t1)
instance Num a => Num (Pt a)

module Utils.Rectangle
data Rectangle a
Rectangle :: !a -> !a -> !a -> !a -> Rectangle a
s :: NFData a => a -> t -> t
left :: Rectangle t -> t
right :: Num a => Rectangle a -> a
top :: Rectangle t -> t
bottom :: Num a => Rectangle a -> a
topLeft :: Rectangle t -> (t, t)
topRight :: Num t => Rectangle t -> (t, t)
bottomLeft :: Num t => Rectangle t -> (t, t)
bottomRight :: Num t => Rectangle t -> (t, t)
vertices :: Num t => Rectangle t -> [(t, t)]
rSize :: Rectangle t -> (t, t)
rArea :: Num a => Rectangle a -> a
center :: Fractional t => Rectangle t -> (t, t)
centerI :: Integral t => Rectangle t -> (t, t)

-- | Create rectangle around point (x,y)
around :: (Fractional a, Ord a) => (a, a) -> (a, a) -> Rectangle a
mkRectangle :: (Num a, Ord a) => (a, a) -> (a, a) -> Rectangle a
mkRectCorners :: (Num a, Ord a) => (a, a) -> (a, a) -> Rectangle a
prop_Corners :: (Int, Int) -> (Int, Int) -> Bool
mkRec :: ((Integer, Integer), (Integer, Integer)) -> Rectangle Integer
fromPtSize :: (a, a) -> (a, a) -> Rectangle a

-- | Return rectangle r2 in coordinate system defined by r1
inCoords :: Num t => Rectangle t -> Rectangle t -> ((t, t), (t, t)) -> Rectangle (t, t)

-- | Return a point in coordinates of given rectangle
inCoords' :: Num t => Rectangle t -> (t, t) -> (t, t)

-- | Adjust the size of the rectangle to be divisible by 2^n.
enlargeToNthPower :: (Integral b, Integral a) => b -> Rectangle a -> Rectangle a
intersection :: (Num a, Ord a) => Rectangle a -> Rectangle a -> Rectangle a
propIntersectionArea :: (Num a, Ord a) => Rectangle a -> Rectangle a -> Bool
propIntersectionCommutes :: (Num a, Ord a) => Rectangle a -> Rectangle a -> Bool
intersects :: (Num a, Ord a) => Rectangle a -> Rectangle a -> Bool
contains :: (Num a, Ord a) => Rectangle a -> Rectangle a -> Bool
intersect1D :: Ord a => (a, a) -> (a, a) -> Bool
prop_intersect1DCommutes :: Ord a => (a, a) -> (a, a) -> Bool
prop_intersectsCommutes :: ((Integer, Integer), (Integer, Integer)) -> ((Integer, Integer), (Integer, Integer)) -> Bool

-- | Create a tiling of a rectangles.
tile :: (Enum a, Num a, Ord a) => (a, a) -> (a, a) -> Rectangle a -> [Rectangle a]

-- | Scale a rectangle
scale :: (Integral a, Integral a3, RealFrac a1, RealFrac a2) => (a1, a2) -> Rectangle a3 -> Rectangle a
fromInt :: (Integral a, Num a1) => Rectangle a -> Rectangle a1
roundR :: (Integral a1, RealFrac a) => Rectangle a -> Rectangle a1
instance Eq a => Eq (Rectangle a)
instance Show a => Show (Rectangle a)
instance (Num a, Ord a, Serial a) => Serial (Rectangle a)
instance NFData a => NFData (Rectangle a)

module Utils.GeometryClass
class Point2D a where type family ELP a :: *
pt :: Point2D a => a -> (ELP a, ELP a)
toPt :: Point2D a => (ELP a, ELP a) -> a

-- | Extract integer coordinates of a point
ipt :: (Point2D a, RealFrac (ELP a)) => a -> (Int, Int)
convertPt :: (Point2D a, Point2D b, ELP a ~ ELP b) => a -> b
class BoundingBox a where type family ELBB a :: *
bounds :: BoundingBox a => a -> Rectangle (ELBB a)
class FromBounds a where type family ELFB a :: *
fromBounds :: FromBounds a => Rectangle (ELFB a) -> a
convertBounds :: (BoundingBox a, FromBounds b, ELBB a ~ ELFB b) => a -> b
class Line2D a where type family ELL a :: *
offsetAngle :: Line2D a => a -> (ELL a, Double)
class LineSegment a where type family ELS a :: *
startEnd :: LineSegment a => a -> ((ELS a, ELS a), (ELS a, ELS a))

-- | Typeclass for elements with a size, such as images and matrices.
class Sized a where type family Size a :: *
getSize :: Sized a => a -> Size a
biggerThan :: (Sized a, Sized b, Size a ~ (Int, Int), Size b ~ Size a) => a -> b -> Bool
instance FromBounds (Rectangle a)
instance BoundingBox (Rectangle a)
instance Point2D (Double, Double)
instance Point2D (Float, Float)
instance Point2D (Int, Int)

module CV.Bindings.Types
c'IPL_DEPTH_1U :: Num a => a
c'IPL_DEPTH_8U :: Num a => a
c'IPL_DEPTH_16U :: Num a => a
c'IPL_DEPTH_32F :: Num a => a
c'IPL_DEPTH_8S :: Num a => a
c'IPL_DEPTH_16S :: Num a => a
c'IPL_DEPTH_32S :: Num a => a
c'IPL_BORDER_CONSTANT :: Num a => a
c'IPL_BORDER_REPLICATE :: Num a => a
c'IPL_BORDER_REFLECT :: Num a => a
c'IPL_BORDER_WRAP :: Num a => a
data C'IplImage
C'IplImage :: C'IplImage
data C'CvMemStorage
C'CvMemStorage :: C'CvMemStorage
data C'CvSeqBlock
C'CvSeqBlock :: C'CvSeqBlock
data C'CvArr
C'CvArr :: C'CvArr
data C'CvHistogram
C'CvHistogram :: C'CvHistogram
data C'CvContour
C'CvContour :: CInt -> CInt -> Ptr C'CvSeq -> Ptr C'CvSeq -> Ptr C'CvSeq -> Ptr C'CvSeq -> CInt -> CInt -> Ptr Char -> Ptr Char -> CInt -> Ptr C'CvSeqBlock -> Ptr C'CvSeqBlock -> C'CvRect -> CInt -> CInt -> CInt -> CInt -> C'CvContour
c'CvContour'flags :: C'CvContour -> CInt
c'CvContour'header_size :: C'CvContour -> CInt
c'CvContour'h_prev :: C'CvContour -> Ptr C'CvSeq
c'CvContour'h_next :: C'CvContour -> Ptr C'CvSeq
c'CvContour'v_prev :: C'CvContour -> Ptr C'CvSeq
c'CvContour'v_next :: C'CvContour -> Ptr C'CvSeq
c'CvContour'total :: C'CvContour -> CInt
c'CvContour'elem_size :: C'CvContour -> CInt
c'CvContour'block_max :: C'CvContour -> Ptr Char
c'CvContour'ptr :: C'CvContour -> Ptr Char
c'CvContour'delta_elems :: C'CvContour -> CInt
c'CvContour'free_blocks :: C'CvContour -> Ptr C'CvSeqBlock
c'CvContour'first :: C'CvContour -> Ptr C'CvSeqBlock
c'CvContour'rect :: C'CvContour -> C'CvRect
c'CvContour'color :: C'CvContour -> CInt
c'CvContour'reserved_0_ :: C'CvContour -> CInt
c'CvContour'reserved_1_ :: C'CvContour -> CInt
c'CvContour'reserved_2_ :: C'CvContour -> CInt
data C'CvSeq
C'CvSeq :: CInt -> CInt -> Ptr C'CvSeq -> Ptr C'CvSeq -> Ptr C'CvSeq -> Ptr C'CvSeq -> CInt -> CInt -> Ptr Char -> Ptr Char -> CInt -> Ptr C'CvSeqBlock -> Ptr C'CvSeqBlock -> C'CvSeq
c'CvSeq'flags :: C'CvSeq -> CInt
c'CvSeq'header_size :: C'CvSeq -> CInt
c'CvSeq'h_prev :: C'CvSeq -> Ptr C'CvSeq
c'CvSeq'h_next :: C'CvSeq -> Ptr C'CvSeq
c'CvSeq'v_prev :: C'CvSeq -> Ptr C'CvSeq
c'CvSeq'v_next :: C'CvSeq -> Ptr C'CvSeq
c'CvSeq'total :: C'CvSeq -> CInt
c'CvSeq'elem_size :: C'CvSeq -> CInt
c'CvSeq'block_max :: C'CvSeq -> Ptr Char
c'CvSeq'ptr :: C'CvSeq -> Ptr Char
c'CvSeq'delta_elems :: C'CvSeq -> CInt
c'CvSeq'free_blocks :: C'CvSeq -> Ptr C'CvSeqBlock
c'CvSeq'first :: C'CvSeq -> Ptr C'CvSeqBlock
c'extractCVSeq :: Ptr C'CvSeq -> Ptr () -> IO ()
c'cvGetSeqElem :: Ptr C'CvSeq -> CInt -> IO (Ptr CChar)
c'printSeq :: Ptr C'CvSeq -> IO ()
p'extractCVSeq :: FunPtr (Ptr C'CvSeq -> Ptr () -> IO ())
p'CvContour'flags :: Ptr (C'CvContour) -> Ptr (CInt)
p'cvGetSeqElem :: FunPtr (Ptr C'CvSeq -> CInt -> IO (Ptr CChar))
p'printSeq :: FunPtr (Ptr C'CvSeq -> IO ())

-- | Convert a CvSeq object into list of its contents. Note that since
--   CvSeq can be approximately anything, including a crazy man from the
--   moon, this is pretty unsafe and you must make sure that <tt>a</tt> is
--   actually the element in the seq, and the seq is something that
--   remotely represents a sequence of elements.
p'CvContour'header_size :: Ptr (C'CvContour) -> Ptr (CInt)
p'CvContour'h_prev :: Ptr (C'CvContour) -> Ptr (Ptr C'CvSeq)
cvSeqToList :: Storable a => Ptr C'CvSeq -> IO [a]
p'CvContour'h_next :: Ptr (C'CvContour) -> Ptr (Ptr C'CvSeq)
p'CvContour'v_prev :: Ptr (C'CvContour) -> Ptr (Ptr C'CvSeq)
p'CvContour'v_next :: Ptr (C'CvContour) -> Ptr (Ptr C'CvSeq)
p'CvSeq'flags :: Ptr (C'CvSeq) -> Ptr (CInt)
p'CvContour'total :: Ptr (C'CvContour) -> Ptr (CInt)
p'CvSeq'header_size :: Ptr (C'CvSeq) -> Ptr (CInt)
cvSeqToVector :: (Unbox a, Storable a) => Ptr C'CvSeq -> IO (Vector a)

-- | A version of <a>cvSeqToList</a> that returns a vector instead. All the
--   warnings of <tt>CvSeqToList</tt> apply.
p'CvContour'elem_size :: Ptr (C'CvContour) -> Ptr (CInt)
p'CvSeq'h_prev :: Ptr (C'CvSeq) -> Ptr (Ptr C'CvSeq)
p'CvContour'block_max :: Ptr (C'CvContour) -> Ptr (Ptr Char)
p'CvSeq'h_next :: Ptr (C'CvSeq) -> Ptr (Ptr C'CvSeq)
p'CvContour'ptr :: Ptr (C'CvContour) -> Ptr (Ptr Char)
p'CvSeq'v_prev :: Ptr (C'CvSeq) -> Ptr (Ptr C'CvSeq)
p'CvContour'delta_elems :: Ptr (C'CvContour) -> Ptr (CInt)
p'CvSeq'v_next :: Ptr (C'CvSeq) -> Ptr (Ptr C'CvSeq)
p'CvContour'free_blocks :: Ptr (C'CvContour) -> Ptr (Ptr C'CvSeqBlock)
p'CvSeq'total :: Ptr (C'CvSeq) -> Ptr (CInt)
p'CvContour'first :: Ptr (C'CvContour) -> Ptr (Ptr C'CvSeqBlock)
p'CvSeq'elem_size :: Ptr (C'CvSeq) -> Ptr (CInt)
p'CvContour'rect :: Ptr (C'CvContour) -> Ptr (C'CvRect)
p'CvSeq'block_max :: Ptr (C'CvSeq) -> Ptr (Ptr Char)
data C'CvRect
C'CvRect :: CInt -> CInt -> CInt -> CInt -> C'CvRect
c'CvRect'x :: C'CvRect -> CInt
c'CvRect'y :: C'CvRect -> CInt
c'CvRect'width :: C'CvRect -> CInt
c'CvRect'height :: C'CvRect -> CInt
p'CvContour'color :: Ptr (C'CvContour) -> Ptr (CInt)
p'CvSeq'ptr :: Ptr (C'CvSeq) -> Ptr (Ptr Char)
p'CvContour'reserved_0_ :: Ptr (C'CvContour) -> Ptr (CInt)
p'CvSeq'delta_elems :: Ptr (C'CvSeq) -> Ptr (CInt)
p'CvContour'reserved_1_ :: Ptr (C'CvContour) -> Ptr (CInt)
p'CvSeq'free_blocks :: Ptr (C'CvSeq) -> Ptr (Ptr C'CvSeqBlock)
p'CvRect'x :: Ptr (C'CvRect) -> Ptr (CInt)
p'CvContour'reserved_2_ :: Ptr (C'CvContour) -> Ptr (CInt)
p'CvSeq'first :: Ptr (C'CvSeq) -> Ptr (Ptr C'CvSeqBlock)
p'CvRect'y :: Ptr (C'CvRect) -> Ptr (CInt)
p'CvRect'width :: Ptr (C'CvRect) -> Ptr (CInt)
p'CvRect'height :: Ptr (C'CvRect) -> Ptr (CInt)
data C'CvScalar
C'CvScalar :: CDouble -> CDouble -> CDouble -> CDouble -> C'CvScalar
c'CvScalar'val_0_ :: C'CvScalar -> CDouble
c'CvScalar'val_1_ :: C'CvScalar -> CDouble
c'CvScalar'val_2_ :: C'CvScalar -> CDouble
c'CvScalar'val_3_ :: C'CvScalar -> CDouble
p'CvScalar'val_0_ :: Ptr (C'CvScalar) -> Ptr (CDouble)
p'CvScalar'val_1_ :: Ptr (C'CvScalar) -> Ptr (CDouble)
p'CvScalar'val_2_ :: Ptr (C'CvScalar) -> Ptr (CDouble)
p'CvScalar'val_3_ :: Ptr (C'CvScalar) -> Ptr (CDouble)
data C'CvSize
C'CvSize :: CInt -> CInt -> C'CvSize
c'CvSize'width :: C'CvSize -> CInt
c'CvSize'height :: C'CvSize -> CInt
p'CvSize'width :: Ptr (C'CvSize) -> Ptr (CInt)
p'CvSize'height :: Ptr (C'CvSize) -> Ptr (CInt)
data C'CvSize2D32f
C'CvSize2D32f :: CFloat -> CFloat -> C'CvSize2D32f
c'CvSize2D32f'width :: C'CvSize2D32f -> CFloat
c'CvSize2D32f'height :: C'CvSize2D32f -> CFloat
p'CvSize2D32f'width :: Ptr (C'CvSize2D32f) -> Ptr (CFloat)
p'CvSize2D32f'height :: Ptr (C'CvSize2D32f) -> Ptr (CFloat)
data C'CvConnectedComp
C'CvConnectedComp :: CDouble -> C'CvScalar -> C'CvRect -> Ptr C'CvSeq -> C'CvConnectedComp
c'CvConnectedComp'area :: C'CvConnectedComp -> CDouble
c'CvConnectedComp'value :: C'CvConnectedComp -> C'CvScalar
c'CvConnectedComp'rect :: C'CvConnectedComp -> C'CvRect
c'CvConnectedComp'contour :: C'CvConnectedComp -> Ptr C'CvSeq
data C'CvPoint
C'CvPoint :: CInt -> CInt -> C'CvPoint
c'CvPoint'x :: C'CvPoint -> CInt
c'CvPoint'y :: C'CvPoint -> CInt
p'CvConnectedComp'area :: Ptr (C'CvConnectedComp) -> Ptr (CDouble)
p'CvConnectedComp'value :: Ptr (C'CvConnectedComp) -> Ptr (C'CvScalar)
p'CvPoint'x :: Ptr (C'CvPoint) -> Ptr (CInt)
p'CvConnectedComp'rect :: Ptr (C'CvConnectedComp) -> Ptr (C'CvRect)
p'CvPoint'y :: Ptr (C'CvPoint) -> Ptr (CInt)
p'CvConnectedComp'contour :: Ptr (C'CvConnectedComp) -> Ptr (Ptr C'CvSeq)
data C'CvPoint2D32f
C'CvPoint2D32f :: CFloat -> CFloat -> C'CvPoint2D32f
c'CvPoint2D32f'x :: C'CvPoint2D32f -> CFloat
c'CvPoint2D32f'y :: C'CvPoint2D32f -> CFloat
p'CvPoint2D32f'x :: Ptr (C'CvPoint2D32f) -> Ptr (CFloat)
p'CvPoint2D32f'y :: Ptr (C'CvPoint2D32f) -> Ptr (CFloat)
mkCvPoint2D32F :: (CFloat, CFloat) -> C'CvPoint2D32f
data C'CvBox2D
C'CvBox2D :: C'CvPoint2D32f -> C'CvSize2D32f -> CFloat -> C'CvBox2D
c'CvBox2D'center :: C'CvBox2D -> C'CvPoint2D32f
c'CvBox2D'size :: C'CvBox2D -> C'CvSize2D32f
c'CvBox2D'angle :: C'CvBox2D -> CFloat
p'CvBox2D'center :: Ptr (C'CvBox2D) -> Ptr (C'CvPoint2D32f)
p'CvBox2D'size :: Ptr (C'CvBox2D) -> Ptr (C'CvSize2D32f)
p'CvBox2D'angle :: Ptr (C'CvBox2D) -> Ptr (CFloat)

-- | spatial moments
--   
--   central moments
--   
--   <pre>
--   m00 != 0 ? 1/sqrt(m00) : 0
--   </pre>
data C'CvMoments
C'CvMoments :: CDouble -> CDouble -> CDouble -> CDouble -> CDouble -> CDouble -> CDouble -> CDouble -> CDouble -> CDouble -> CDouble -> CDouble -> CDouble -> CDouble -> CDouble -> CDouble -> CDouble -> CDouble -> C'CvMoments
c'CvMoments'm00 :: C'CvMoments -> CDouble
c'CvMoments'm10 :: C'CvMoments -> CDouble
c'CvMoments'm01 :: C'CvMoments -> CDouble
c'CvMoments'm20 :: C'CvMoments -> CDouble
c'CvMoments'm11 :: C'CvMoments -> CDouble
c'CvMoments'm02 :: C'CvMoments -> CDouble
c'CvMoments'm30 :: C'CvMoments -> CDouble
c'CvMoments'm21 :: C'CvMoments -> CDouble
c'CvMoments'm12 :: C'CvMoments -> CDouble
c'CvMoments'm03 :: C'CvMoments -> CDouble
c'CvMoments'mu20 :: C'CvMoments -> CDouble
c'CvMoments'mu11 :: C'CvMoments -> CDouble
c'CvMoments'mu02 :: C'CvMoments -> CDouble
c'CvMoments'mu30 :: C'CvMoments -> CDouble
c'CvMoments'mu21 :: C'CvMoments -> CDouble
c'CvMoments'mu12 :: C'CvMoments -> CDouble
c'CvMoments'mu03 :: C'CvMoments -> CDouble
c'CvMoments'inv_sqrt_m00 :: C'CvMoments -> CDouble

-- | Hu invariants
data C'CvHuMoments
C'CvHuMoments :: CDouble -> CDouble -> CDouble -> CDouble -> CDouble -> CDouble -> CDouble -> C'CvHuMoments
c'CvHuMoments'hu1 :: C'CvHuMoments -> CDouble
c'CvHuMoments'hu2 :: C'CvHuMoments -> CDouble
c'CvHuMoments'hu3 :: C'CvHuMoments -> CDouble
c'CvHuMoments'hu4 :: C'CvHuMoments -> CDouble
c'CvHuMoments'hu5 :: C'CvHuMoments -> CDouble
c'CvHuMoments'hu6 :: C'CvHuMoments -> CDouble
c'CvHuMoments'hu7 :: C'CvHuMoments -> CDouble
data C'CvTermCriteria
C'CvTermCriteria :: CInt -> CInt -> Double -> C'CvTermCriteria
c'CvTermCriteria'type :: C'CvTermCriteria -> CInt
c'CvTermCriteria'max_iter :: C'CvTermCriteria -> CInt
c'CvTermCriteria'epsilon :: C'CvTermCriteria -> Double
data TermCriteria
EPS :: Double -> TermCriteria
ITER :: Int -> TermCriteria
p'CvMoments'm00 :: Ptr (C'CvMoments) -> Ptr (CDouble)
p'CvHuMoments'hu1 :: Ptr (C'CvHuMoments) -> Ptr (CDouble)
toCvTCrit :: TermCriteria -> C'CvTermCriteria
p'CvMoments'm10 :: Ptr (C'CvMoments) -> Ptr (CDouble)
p'CvHuMoments'hu2 :: Ptr (C'CvHuMoments) -> Ptr (CDouble)
p'CvTermCriteria'type :: Ptr (C'CvTermCriteria) -> Ptr (CInt)
c'CV_TERMCRIT_ITER :: Num a => a
p'CvMoments'm01 :: Ptr (C'CvMoments) -> Ptr (CDouble)
p'CvHuMoments'hu3 :: Ptr (C'CvHuMoments) -> Ptr (CDouble)
p'CvTermCriteria'max_iter :: Ptr (C'CvTermCriteria) -> Ptr (CInt)
c'CV_TERMCRIT_NUMBER :: Num a => a
c'CV_TERMCRIT_EPS :: Num a => a
p'CvMoments'm20 :: Ptr (C'CvMoments) -> Ptr (CDouble)
p'CvHuMoments'hu4 :: Ptr (C'CvHuMoments) -> Ptr (CDouble)
p'CvTermCriteria'epsilon :: Ptr (C'CvTermCriteria) -> Ptr (Double)
p'CvMoments'm11 :: Ptr (C'CvMoments) -> Ptr (CDouble)
p'CvHuMoments'hu5 :: Ptr (C'CvHuMoments) -> Ptr (CDouble)
p'CvMoments'm02 :: Ptr (C'CvMoments) -> Ptr (CDouble)
p'CvHuMoments'hu6 :: Ptr (C'CvHuMoments) -> Ptr (CDouble)
c'cvCreateMemStorage :: Int -> IO (Ptr C'CvMemStorage)
c'cvReleaseMemStorage :: Ptr (Ptr C'CvMemStorage) -> IO ()
p'CvMoments'm30 :: Ptr (C'CvMoments) -> Ptr (CDouble)
p'CvHuMoments'hu7 :: Ptr (C'CvHuMoments) -> Ptr (CDouble)
p'cvCreateMemStorage :: FunPtr (Int -> IO (Ptr C'CvMemStorage))
p'cvReleaseMemStorage :: FunPtr (Ptr (Ptr C'CvMemStorage) -> IO ())
withNewMemory :: (Ptr C'CvMemStorage -> IO b) -> IO b
p'CvMoments'm21 :: Ptr (C'CvMoments) -> Ptr (CDouble)
p'CvMoments'm12 :: Ptr (C'CvMoments) -> Ptr (CDouble)
p'CvMoments'm03 :: Ptr (C'CvMoments) -> Ptr (CDouble)
p'CvMoments'mu20 :: Ptr (C'CvMoments) -> Ptr (CDouble)
c'CV_8UC1 :: Num a => a
c'CV_8UC2 :: Num a => a
p'CvMoments'mu11 :: Ptr (C'CvMoments) -> Ptr (CDouble)
c'CV_8UC3 :: Num a => a
c'CV_8UC4 :: Num a => a
p'CvMoments'mu02 :: Ptr (C'CvMoments) -> Ptr (CDouble)
c'CV_8SC1 :: Num a => a
p'CvMoments'mu30 :: Ptr (C'CvMoments) -> Ptr (CDouble)
c'CV_8SC2 :: Num a => a
c'CV_8SC3 :: Num a => a
p'CvMoments'mu21 :: Ptr (C'CvMoments) -> Ptr (CDouble)
c'CV_8SC4 :: Num a => a
p'CvMoments'mu12 :: Ptr (C'CvMoments) -> Ptr (CDouble)
c'CV_16UC1 :: Num a => a
c'CV_16UC2 :: Num a => a
p'CvMoments'mu03 :: Ptr (C'CvMoments) -> Ptr (CDouble)
c'CV_16UC3 :: Num a => a
c'CV_16UC4 :: Num a => a
p'CvMoments'inv_sqrt_m00 :: Ptr (C'CvMoments) -> Ptr (CDouble)
c'CV_16SC1 :: Num a => a
c'CV_16SC2 :: Num a => a
c'CV_16SC3 :: Num a => a
c'CV_16SC4 :: Num a => a
c'CV_32SC1 :: Num a => a
c'CV_32SC2 :: Num a => a
c'CV_32SC3 :: Num a => a
c'CV_32SC4 :: Num a => a
c'CV_32FC1 :: Num a => a
c'CV_32FC2 :: Num a => a
c'CV_32FC3 :: Num a => a
c'CV_32FC4 :: Num a => a
c'CV_64FC1 :: Num a => a
c'CV_64FC2 :: Num a => a
c'CV_64FC3 :: Num a => a
c'CV_64FC4 :: Num a => a
c'CV_CLOCKWISE :: Num a => a
c'CV_COUNTER_CLOCKWISE :: Num a => a
data C'CvConvexityDefect
C'CvConvexityDefect :: Ptr C'CvPoint -> Ptr C'CvPoint -> Ptr C'CvPoint -> CFloat -> C'CvConvexityDefect
c'CvConvexityDefect'start :: C'CvConvexityDefect -> Ptr C'CvPoint
c'CvConvexityDefect'end :: C'CvConvexityDefect -> Ptr C'CvPoint
c'CvConvexityDefect'depth_point :: C'CvConvexityDefect -> Ptr C'CvPoint
c'CvConvexityDefect'depth :: C'CvConvexityDefect -> CFloat
p'CvConvexityDefect'start :: Ptr (C'CvConvexityDefect) -> Ptr (Ptr C'CvPoint)
data C'CvSURFPoint
C'CvSURFPoint :: C'CvPoint2D32f -> CInt -> CInt -> CFloat -> CFloat -> C'CvSURFPoint
c'CvSURFPoint'pt :: C'CvSURFPoint -> C'CvPoint2D32f
c'CvSURFPoint'laplacian :: C'CvSURFPoint -> CInt
c'CvSURFPoint'size :: C'CvSURFPoint -> CInt
c'CvSURFPoint'dir :: C'CvSURFPoint -> CFloat
c'CvSURFPoint'hessian :: C'CvSURFPoint -> CFloat
p'CvConvexityDefect'end :: Ptr (C'CvConvexityDefect) -> Ptr (Ptr C'CvPoint)
p'CvConvexityDefect'depth_point :: Ptr (C'CvConvexityDefect) -> Ptr (Ptr C'CvPoint)
p'CvConvexityDefect'depth :: Ptr (C'CvConvexityDefect) -> Ptr (CFloat)
p'CvSURFPoint'pt :: Ptr (C'CvSURFPoint) -> Ptr (C'CvPoint2D32f)
p'CvSURFPoint'laplacian :: Ptr (C'CvSURFPoint) -> Ptr (CInt)
p'CvSURFPoint'size :: Ptr (C'CvSURFPoint) -> Ptr (CInt)
p'CvSURFPoint'dir :: Ptr (C'CvSURFPoint) -> Ptr (CFloat)
p'CvSURFPoint'hessian :: Ptr (C'CvSURFPoint) -> Ptr (CFloat)
instance Eq C'CvSeq
instance Show C'CvSeq
instance Eq C'CvRect
instance Show C'CvRect
instance Eq C'CvContour
instance Show C'CvContour
instance Eq C'CvScalar
instance Show C'CvScalar
instance Eq C'CvSize
instance Show C'CvSize
instance Eq C'CvSize2D32f
instance Show C'CvSize2D32f
instance Eq C'CvConnectedComp
instance Show C'CvConnectedComp
instance Eq C'CvPoint
instance Show C'CvPoint
instance Eq C'CvPoint2D32f
instance Show C'CvPoint2D32f
instance Eq C'CvBox2D
instance Show C'CvBox2D
instance Eq C'CvMoments
instance Show C'CvMoments
instance Eq C'CvHuMoments
instance Show C'CvHuMoments
instance Eq C'CvTermCriteria
instance Show C'CvTermCriteria
instance Show TermCriteria
instance Eq TermCriteria
instance Eq C'CvConvexityDefect
instance Show C'CvConvexityDefect
instance Eq C'CvSURFPoint
instance Show C'CvSURFPoint
instance Point2D C'CvSURFPoint
instance Storable C'CvSURFPoint
instance Storable C'CvConvexityDefect
instance Storable C'CvTermCriteria
instance Storable C'CvHuMoments
instance Storable C'CvMoments
instance Storable C'CvBox2D
instance Sized C'CvBox2D
instance Point2D C'CvPoint2D32f
instance Storable C'CvPoint2D32f
instance Point2D C'CvPoint
instance Storable C'CvPoint
instance Storable C'CvConnectedComp
instance Sized C'CvSize2D32f
instance Storable C'CvSize2D32f
instance Sized C'CvSize
instance Storable C'CvSize
instance Storable C'CvScalar
instance FromBounds C'CvRect
instance BoundingBox C'CvRect
instance Storable C'CvRect
instance Storable C'CvSeq
instance Storable C'CvContour

module CV.Image

-- | The type for Images
newtype Image channels depth
S :: BareImage -> Image channels depth

-- | Allocate a new empty image
empty :: CreateImage (Image a b) => (Int, Int) -> (Image a b)

-- | Allocate a new image that of the same size and type as the exemplar
--   image given.
emptyCopy :: CreateImage (Image a b) => Image a b -> (Image a b)
emptyCopy' :: CreateImage (Image a b) => Image a b -> IO (Image a b)

-- | Create a copy of an image
cloneImage :: Image a b -> IO (Image a b)
withClone :: Image channels depth -> (Image channels depth -> IO ()) -> IO (Image channels depth)
withCloneValue :: Image channels depth -> (Image channels depth -> IO a) -> IO a

-- | Class for images that exist.
class CreateImage a
create :: CreateImage a => (Int, Int) -> IO a

-- | Type family for expressing which channels a colorspace contains. This
--   needs to be fixed wrt. the BGR color space.

-- | Single channel grayscale image
data GrayScale
data Complex
data RGB
data RGBA
data RGB_Channel
Red :: RGB_Channel
Green :: RGB_Channel
Blue :: RGB_Channel
data LAB
data LAB_Channel
LAB_L :: LAB_Channel
LAB_A :: LAB_Channel
LAB_B :: LAB_Channel
type D32 = Float
type D64 = Double
type D8 = Word8
data Tag tp
lab :: Tag LAB
rgba :: Tag RGBA
rgb :: Tag RGB
compose :: Composes a => Source a -> a

-- | <i>Deprecated: This is unsafe. Use compose instead</i>
composeMultichannelImage :: CreateImage (Image tp a) => Maybe (Image GrayScale a) -> Maybe (Image GrayScale a) -> Maybe (Image GrayScale a) -> Maybe (Image GrayScale a) -> Tag tp -> Image tp a

-- | Typeclass for CV items that can be read from file. Mainly images at
--   this point.
class Loadable a
readFromFile :: Loadable a => FilePath -> IO a
saveImage :: Save (Image c d) => FilePath -> Image c d -> IO ()
loadColorImage :: FilePath -> IO (Maybe (Image BGR D32))
loadImage :: FilePath -> IO (Maybe (Image GrayScale D32))
class GetPixel a where type family P a :: *
getPixel :: GetPixel a => (Int, Int) -> a -> P a
class SetPixel a where type family SP a :: *
setPixel :: SetPixel a => (Int, Int) -> SP a -> a -> IO ()
getAllPixels :: (Sized a, GetPixel a, ~ * (Size a) (Int, Int)) => a -> [P a]
getAllPixelsRowMajor :: (Sized a, GetPixel a, ~ * (Size a) (Int, Int)) => a -> [P a]

-- | Perform (a destructive) inplace map of the image. This should be
--   wrapped inside withClone or an image operation
mapImageInplace :: (P (Image GrayScale D32) -> P (Image GrayScale D32)) -> Image GrayScale D32 -> IO ()
data ImageDepth

-- | Typeclass for elements with a size, such as images and matrices.
class Sized a where type family Size a :: *
getSize :: Sized a => a -> Size a
biggerThan :: (Sized a, Sized b, Size a ~ (Int, Int), Size b ~ Size a) => a -> b -> Bool
getArea :: (Sized a, Num b, Size a ~ (b, b)) => a -> b
getChannel :: Enum a => a -> Image (ChannelOf a) d -> Image GrayScale d
getImageChannels :: Image c d -> IO CInt
getImageDepth :: Image c d -> IO ImageDepth
getImageInfo :: Image c d -> IO ((Int, Int), ImageDepth, CInt)
setCOI :: Integral a => a -> Image c d -> IO ()
setROI :: (Integral t, Integral t1, Integral t2, Integral t3) => (t, t1) -> (t2, t3) -> Image c d -> IO ()
resetROI :: Image c d -> IO ()
getRegion :: (Int, Int) -> (Int, Int) -> Image c d -> Image c d
withIOROI :: (Integral t, Integral t1, Integral t2, Integral t3) => (t, t1) -> (t2, t3) -> Image c d -> IO b -> IO b
withROI :: (Int, Int) -> (Int, Int) -> Image c d -> (Image c d -> a) -> a

-- | Blit image2 onto image1. This uses an alpha channel bitmap for
--   determining the regions where the image should be <a>blended</a> with
--   the base image.
blendBlit :: Image c d -> Image c1 d1 -> Image c3 d3 -> Image c2 d2 -> (CInt, CInt) -> IO ()
blit :: Image GrayScale D32 -> Image GrayScale D32 -> (Int, Int) -> IO ()
blitM :: (Integral a, Integral a1, Integral a2, Integral a3) => (a, a1) -> [((a2, a3), Image GrayScale D32)] -> Image GrayScale D32
subPixelBlit :: Image c d -> Image c d -> (CDouble, CDouble) -> IO ()
safeBlit :: Image GrayScale D32 -> Image GrayScale D32 -> (Int, Int) -> Image GrayScale D32

-- | Create a montage form given images (u,v) determines the layout and
--   space the spacing between images. Images are assumed to be the same
--   size (determined by the first image)
montage :: CreateImage (Image GrayScale D32) => (Int, Int) -> Int -> [Image GrayScale D32] -> Image GrayScale D32

-- | Tile images by overlapping them on a black canvas.
tileImages :: Image c d -> Image c1 d1 -> (CInt, CInt) -> Image channels depth
rgbToGray :: Image RGB D32 -> Image GrayScale D32
grayToRGB :: Image GrayScale D32 -> Image RGB D32
rgbToLab :: Image RGB D32 -> Image LAB D32
bgrToRgb :: Image BGR D8 -> Image RGB D8
rgbToBgr :: Image RGB D8 -> Image BGR D8
cloneTo64F :: Image c d -> IO (Image c D64)
unsafeImageTo32F :: Image c d -> Image c D32
unsafeImageTo64F :: Image c d -> Image c D64
unsafeImageTo8Bit :: Image cspace a -> Image cspace D8
newtype BareImage
BareImage :: (ForeignPtr (BareImage)) -> BareImage
creatingImage :: IO (Ptr BareImage) -> IO (Image channels depth)
unImage :: Image t t1 -> ForeignPtr BareImage

-- | Remove typing info from an image
unS :: Image t t1 -> BareImage
withGenBareImage :: BareImage -> (Ptr b -> IO b1) -> IO b1
withBareImage :: BareImage -> (Ptr BareImage -> IO b) -> IO b
creatingBareImage :: IO (Ptr BareImage) -> IO BareImage
withGenImage :: Image c d -> (Ptr b -> IO a) -> IO a
withImage :: Image c d -> (Ptr BareImage -> IO a) -> IO a
imageFPTR :: Image c d -> ForeignPtr BareImage
ensure32F :: (Ptr (BareImage)) -> (IO (Ptr (BareImage)))
setCatch :: IO CInt
data CvException
data CvSizeError
CvSizeError :: String -> CvSizeError
data CvIOError
CvIOError :: String -> CvIOError
instance Typeable CvException
instance Typeable CvIOError
instance Typeable CvSizeError
instance Show ImageDepth
instance Eq RGB_Channel
instance Ord RGB_Channel
instance Enum RGB_Channel
instance Eq LAB_Channel
instance Ord LAB_Channel
instance Enum LAB_Channel
instance Show CvException
instance Show CvIOError
instance Show CvSizeError
instance Exception CvSizeError
instance Exception CvIOError
instance Exception CvException
instance SetPixel (Image Complex D32)
instance SetPixel (Image RGB D32)
instance SetPixel (Image GrayScale D8)
instance SetPixel (Image GrayScale D32)
instance Enum ImageDepth
instance Save (Image GrayScale D32)
instance Save (Image GrayScale D8)
instance Save (Image RGB D8)
instance Save (Image RGB D32)
instance Save (Image BGR D32)
instance CreateImage (Image RGBA D8)
instance CreateImage (Image RGB D8)
instance CreateImage (Image LAB D8)
instance CreateImage (Image GrayScale D8)
instance CreateImage (Image RGBA D64)
instance CreateImage (Image RGB D64)
instance CreateImage (Image LAB D64)
instance CreateImage (Image GrayScale D64)
instance CreateImage (Image RGBA D32)
instance CreateImage (Image RGB D32)
instance CreateImage (Image LAB D32)
instance CreateImage (Image Complex D32)
instance CreateImage (Image GrayScale D32)
instance GetPixel (Image LAB D32)
instance GetPixel (Image RGB D8)
instance GetPixel (Image BGR D8)
instance GetPixel (Image BGR D32)
instance GetPixel (Image RGB D32)
instance GetPixel (Image Complex D32)
instance GetPixel (Image GrayScale D8)
instance GetPixel (Image GrayScale D32)
instance Enum CvtFlags
instance Enum CvtCodes
instance Sized (Image c d)
instance Sized BareImage
instance Loadable (Image GrayScale D8)
instance Loadable (Image RGB D8)
instance Loadable (Image RGB D32)
instance Loadable (Image GrayScale D32)
instance CreateImage (Image LAB a) => Composes (Image LAB a)
instance CreateImage (Image RGB a) => Composes (Image RGB a)
instance CreateImage (Image RGBA a) => Composes (Image RGBA a)
instance NFData (Image a b)


-- | This module is an applicative wrapper for images. It introduces
--   Pixelwise type that can be converted from and to grayscale images and
--   which has an applicative and functor instances.
module CV.Pixelwise

-- | A wrapper for allowing functor and applicative instances for
--   non-polymorphic image types.
data Pixelwise x
MkP :: (Int, Int) -> ((Int, Int) -> x) -> Pixelwise x
sizeOf :: Pixelwise x -> (Int, Int)
eltOf :: Pixelwise x -> (Int, Int) -> x
fromImage :: (Num (P b), GetPixel b, Sized b, Size b ~ Size (Pixelwise (P b))) => b -> Pixelwise (P b)

-- | Convert a function into construct into a Pixelwise construct
fromFunction :: (Int, Int) -> ((Int, Int) -> x) -> Pixelwise x

-- | Convert a pixelwise construct to image.
toImage :: (SetPixel (Image a b), CreateImage (Image a b)) => Pixelwise (SP (Image a b)) -> Image a b

-- | Convert a pixelwise construct to image.
toImagePar :: (SetPixel (Image a b), CreateImage (Image a b)) => Int -> Pixelwise (SP (Image a b)) -> Image a b

-- | Re-arrange pixel positions and values
remap :: (((Int, Int) -> b) -> ((Int, Int) -> x)) -> Pixelwise b -> Pixelwise x
remapImage :: (CreateImage (Image a b), SetPixel (Image a b), Num (P (Image a b)), GetPixel (Image a b)) => (((Int, Int) -> P (Image a b)) -> (Int, Int) -> SP (Image a b)) -> Image a b -> Image a b
mapImage :: (CreateImage (Image c d), SetPixel (Image c d), Num (P (Image a b)), GetPixel (Image a b)) => (P (Image a b) -> SP (Image c d)) -> Image a b -> Image c d
mapPixels :: (t -> x) -> Pixelwise t -> Pixelwise x
imageFromFunction :: (SetPixel (Image a b), CreateImage (Image a b)) => (Int, Int) -> ((Int, Int) -> (SP (Image a b))) -> Image a b

-- | Convert image to a function, which returns pixel values in the domain
--   of the image and zero elsewhere
imageToFunction :: (GetPixel (Image a b), Num (P (Image a b))) => Image a b -> ((Int, Int) -> P (Image a b))

-- | Shorthand for `a <a>$</a> fromImage b`
(<$$>) :: (Num (P b1), Size b1 ~ (Int, Int), Sized b1, GetPixel b1) => (P b1 -> b) -> b1 -> Pixelwise b

-- | Shorthand for `a <a>*</a> fromImage b`
(<+>) :: (Num (P b1), Size b1 ~ (Int, Int), Sized b1, GetPixel b1) => Pixelwise (P b1 -> b) -> b1 -> Pixelwise b
instance Num a => Num (Pixelwise a)
instance Show (Pixelwise a)
instance Eq a => Eq (Pixelwise a)
instance Applicative Pixelwise
instance Functor Pixelwise
instance Sized (Pixelwise a)
instance GetPixel (Pixelwise x)


-- | This module provides slow but functional means for exporting images
--   from and to CArrays, which can easily be passed into foreign
--   functions.
module CV.Conversions

-- | Copy the contents of a CArray into CV.Image type.
copyCArrayToImage :: CArray (Int, Int) Double -> Image GrayScale D32

-- | Copy the contents of a CArray into CV.Image type.
copy8UCArrayToImage :: CArray (Int, Int) Word8 -> Image GrayScale D8

-- | Copy the contents of a CV.Image into a CArray.
copyImageToCArray :: Image GrayScale D32 -> CArray (Int, Int) Double

-- | Copy CArray of floats to image
copyFCArrayToImage :: CArray (Int, Int) Float -> Image GrayScale D32

-- | Copy D32 grayscale image to CArray
copyImageToFCArray :: Image GrayScale D32 -> CArray (Int, Int) Float

-- | Copy the real part of an array to image
copyComplexCArrayToImage :: CArray (Int, Int) (Complex Double) -> Image GrayScale D32

-- | Copy image as a real part of a complex CArray
copyImageToComplexCArray :: Image GrayScale D32 -> CArray (Int, Int) (Complex Double)

-- | Copy the contents of CV.Image into a pre-existing CArray.
copyImageToExistingCArray :: Image t t1 -> CArray i Double -> IO ()
unsafe8UC_RGBFromPtr :: (Int, Int) -> Ptr Word8 -> IO (Image RGB D8)
unsafe8UC_BGRFromPtr :: (Int, Int) -> Ptr Word8 -> IO (Image RGB D8)
acquireImageSlowF' :: Int -> (Int -> ((Ptr Float) -> (IO (Ptr (BareImage)))))
acquireImageSlow' :: Int -> (Int -> ((Ptr Double) -> (IO (Ptr (BareImage)))))
acquireImageSlow8URGB' :: Int -> (Int -> ((Ptr Word8) -> (IO (Ptr (BareImage)))))


-- | Binary instances for images. Currently it only supports the type
--   `Image Grayscale D32`.
module CV.Binary
instance Binary (Image GrayScale D32)


-- | This module provides wrappers for CvMat type. This is still
--   preliminary as the type of the matrix isn't coded in the haskell type.
module CV.Matrix
class Exists a where type family Args a :: *
create :: Exists a => Args a -> IO a
data Matrix a

-- | Create an empty matrix of given dimensions
emptyMatrix :: Exists (Matrix a) => Args (Matrix a) -> Matrix a

-- | Generate a matrix from a index function
fromFunction :: (Storable t, Exists (Matrix t), Args (Matrix t) ~ (Int, Int)) => (Int, Int) -> ((Int, Int) -> t) -> Matrix t
fromList :: (Storable t, Exists (Matrix t), Args (Matrix t) ~ (Int, Int)) => (Int, Int) -> [t] -> Matrix t

-- | Convert a matrix to flat list (row major order)
toList :: Storable a => Matrix a -> [a]

-- | Convert matrix to rows represented as nested lists
toRows :: Storable t => Matrix t -> [[t]]

-- | Convert matrix to cols represented as nested lists
toCols :: Storable t => Matrix t -> [[t]]

-- | Get an element of the matrix
get :: Storable t => (Matrix t) -> Int -> Int -> IO t

-- | Write an element to a matrix
put :: Storable t => (Matrix t) -> Int -> Int -> t -> IO ()
withMatPtr :: Matrix x -> (Ptr C'CvMat -> IO a) -> IO a

-- | Transpose a matrix. Does not do complex conjugation for complex
--   matrices
transpose :: (Exists (Matrix a), Args (Matrix a) ~ Size (Matrix a)) => Matrix a -> Matrix a

-- | Ordinary matrix multiplication
mxm :: (Exists (Matrix a), Args (Matrix a) ~ Size (Matrix a)) => Matrix a -> Matrix a -> Matrix a

-- | Matrix inversion
invert :: (Exists (Matrix a), Args (Matrix a) ~ Size (Matrix a)) => Matrix a -> Matrix a

-- | Convert a rotation vector to a rotation matrix (1x3 -&gt; 3x3)
rodrigues2 :: (Exists (Matrix a), Args (Matrix a) ~ Size (Matrix a)) => Matrix a -> Matrix a

-- | Create an identity matrix
identity :: (Num a, Sized (Matrix a), Args (Matrix a) ~ (Int, Int), Size (Matrix a) ~ (Int, Int), Storable a, Exists (Matrix a)) => (Matrix a) -> Matrix a
instance Sized (Matrix a)
instance Exists (Matrix (Double, Double))
instance Exists (Matrix Double)
instance Exists (Matrix (CInt, CInt, CInt, CInt))
instance Exists (Matrix (Int, Int, Int, Int))
instance Exists (Matrix (CFloat, CFloat, CFloat))
instance Exists (Matrix (Float, Float, Float))
instance Exists (Matrix (CFloat, CFloat))
instance Exists (Matrix (Float, Float))
instance Exists (Matrix (Int, Int))
instance Exists (Matrix Int)
instance Exists (Matrix Float)
instance (Show t, Storable t, Size (Matrix t) ~ (Int, Int)) => Show (Matrix t)


-- | This module exposes opencv functions for camera calibration using a
--   chessboard rig. This module follows opencv quite closely and the best
--   documentation is probably found there. As quick example however, the
--   following program detects and draws chessboard corners from an image.
--   
--   <pre>
--    module Main where
--    import CV.Image
--    import CV.Calibration
--   
--   main = do
--        Just i &lt;- loadColorImage "chess.png"
--        let corners = findChessboardCorners (unsafeImageTo8Bit i) (4,5) (FastCheck:defaultFlags)
--        let y = drawChessboardCorners (unsafeImageTo8Bit i) (4,5) corners
--        mapM_ print (corners)
--        saveImage "found_chessboard.png" y
--   </pre>
module CV.Calibration

-- | Flags for the chessboard corner detector. See opencv documentation for
--   cvFindChessboardCorners.
data FindFlags
AdaptiveThresh :: FindFlags
NormalizeImage :: FindFlags
FilterQuads :: FindFlags
FastCheck :: FindFlags

-- | Default flags for finding corners
defaultFlags :: [FindFlags]

-- | Find the inner corners of a chessboard in a given image.
findChessboardCorners :: Image RGB D8 -> (Int, Int) -> [FindFlags] -> [(Float, Float)]

-- | Given an estimate of chessboard corners, provide a subpixel estimation
--   of actual corners.
refineChessboardCorners :: Image GrayScale D8 -> [(Float, Float)] -> (Int, Int) -> (Int, Int) -> [(Float, Float)]

-- | Draw the found chessboard corners to an image
drawChessboardCorners :: Image RGB D8 -> (Int, Int) -> [(Float, Float)] -> Image RGB D8

-- | See opencv function cvCalibrateCamera2. This function takes a list of
--   world-screen coordinate pairs acquired with find-chessboard corners
--   and attempts to find the camera parameters for the system. It returns
--   the fitting error, the camera matrix, list of distortion co-efficients
--   and rotation and translation vectors for each coordinate pair.
calibrateCamera2 :: [[((Float, Float, Float), (Float, Float))]] -> (Int, Int) -> IO (Double, Matrix Float, [[Float]], [[Float]], [[Float]])
instance Show CvPoint
instance Storable CvPoint
instance Enum FindFlags

module CV.ImageOp

-- | ImageOperation is a name for unary operators that mutate images
--   inplace.
newtype ImageOperation c d
ImgOp :: (Image c d -> IO ()) -> ImageOperation c d

-- | Compose two image operations
(#>) :: ImageOperation c d -> ImageOperation c d -> ImageOperation c d

-- | An unit operation for compose
nonOp :: ImageOperation c d

-- | Apply image operation to a Copy of an image
(<#) :: Image c d -> ImageOperation c d -> Image c d
blitOp :: Image GrayScale D32 -> (Int, Int) -> ImageOperation GrayScale D32
setPixelOp :: SetPixel (Image c d) => (Int, Int) -> SP (Image c d) -> ImageOperation c d
fromImageOp :: ImageOperation t t1 -> IOP (Image t t1) (Image t t1)
newtype IOP a b
IOP :: (a -> IO b) -> IOP a b
(&#&) :: IOP (Image c d) e -> IOP (Image c d) f -> IOP (Image c d) (Image c d, Image c d)
unsafeOperate :: ImageOperation c d -> Image c d -> Image c d
runIOP :: IOP (Image channels depth) a -> Image channels depth -> IO a

-- | Apply list of image operations to a Copy of an image. (Makes a single
--   copy and is faster than folding over (&lt;#)
(<##) :: Image c d -> [ImageOperation c d] -> Image c d
operate :: ImageOperation c d -> Image c d -> IO (Image c d)
operateOn :: Image c d -> ImageOperation c d -> IO (Image c d)

-- | Iterate an operation N times
times :: Int -> ImageOperation c d -> ImageOperation c d
directOp :: Image t t1 -> ImageOperation t t1 -> IO ()
operateInPlace :: ImageOperation t t1 -> Image t t1 -> IO ()
unsafeOperateOn :: Image c d -> ImageOperation c d -> Image c d
operateWithROI :: (Integral t2, Integral t3, Integral t4, Integral t5) => (t2, t3) -> (t4, t5) -> ImageOperation t t1 -> Image t t1 -> IO (Image t t1)
instance Category IOP


-- | Mathematical and statistical operations for images. See also module
--   <a>CV.ImageMathOp</a> which contains handy operators for some of
--   these.
module CV.ImageMath

-- | Calculates the per-pixel sum of two images.
add :: Image c1 d1 -> Image c1 d1 -> Image c1 d1

-- | Calculates the per-pixel difference of two images.
sub :: Image c1 d1 -> Image c1 d1 -> Image c1 d1

-- | Calculates the per-pixel absolute difference of two images.
absDiff :: Image c1 d1 -> Image c1 d1 -> Image c1 d1

-- | Calculates the per-pixel product of two images.
mul :: Image c1 d1 -> Image c1 d1 -> Image c1 d1

-- | Calculates the per-pixel division of two images.
div :: Image c1 d1 -> Image c1 d1 -> Image c1 d1

-- | Calculates the per-pixel minimum of two images.
min :: Image c1 d1 -> Image c1 d1 -> Image c1 d1

-- | Calculates the per-pixel maximum of two images.
max :: Image c1 d1 -> Image c1 d1 -> Image c1 d1

-- | Merge two images according to a mask. Result is <tt>R = A*m +
--   B*(m-1)</tt>.
maskedMerge :: Image GrayScale D8 -> Image GrayScale D32 -> Image GrayScale D32 -> Image GrayScale D32

-- | Calculates the average of multiple images by adding the pixel values
--   and dividing the resulting values by number of images.
averageImages :: [Image GrayScale D32] -> Image GrayScale D32

-- | Calculates the atan2 of pixel values in two images.
atan2 :: Image GrayScale D32 -> Image GrayScale D32 -> Image GrayScale D32

-- | Calculates the (non-absolute) difference of every pixel to image mean.
--   See also <a>subMeanAbs</a>.
subMean :: Image GrayScale D32 -> Image GrayScale D32

-- | Calculates the absolute difference of every pixel to image mean. See
--   also <a>subMean</a>.
subMeanAbs :: Image GrayScale D32 -> Image GrayScale D32

-- | Calculates the square root of every pixel.
sqrt :: Image GrayScale D32 -> Image GrayScale D32

-- | Calculates the natural logarithm of every pixel.
log :: Image GrayScale D32 -> Image GrayScale D32

-- | Calculates the absolute value of every pixel.
abs :: Image c d -> Image c d

-- | Calculates the atan of every pixel.
atan :: Image GrayScale D32 -> Image GrayScale D32

-- | Logical inversion of image (ie. invert, but stay on [0..1] range;
--   multiply by <tt>-1</tt> and add <tt>1</tt>).
invert :: Image GrayScale D32 -> Image GrayScale D32

-- | Adds a scalar to every pixel.
addS :: D32 -> Image GrayScale D32 -> Image GrayScale D32

-- | Subtracts a scalar from every pixel, scalar on left.
subS :: Real a => Image c d -> a -> Image c d

-- | Subtracts a scalar from every pixel, scalar on right.
subRS :: D32 -> Image GrayScale D32 -> Image GrayScale D32

-- | Multiplies every pixel by a scalar.
mulS :: D32 -> Image GrayScale D32 -> Image GrayScale D32

-- | Calculates the per-pixel minimum between an image and a scalar.
minS :: Float -> Image c d -> Image c d

-- | Calculates the per-pixel maximum between an image and a scalar.
maxS :: Float -> Image c d -> Image c d

-- | Compares each pixel to a scalar, and produces a binary image where the
--   pixel value is less than the scalar. For example, <tt>(lessThan s
--   I)</tt> has white pixels where value of I is less than s. Notice that
--   the order of operands is opposite to the intuitive interpretation of
--   <tt>s `<a>lessThan</a>` I</tt>.
lessThan :: D32 -> Image GrayScale D32 -> Image GrayScale D8

-- | Compares each pixel to a scalar, and produces a binary image where the
--   pixel value is greater than the scalar. For example, <tt>(moreThan s
--   I)</tt> has white pixels where value of I is greater than s. Notice
--   that the order of operands is opposite to the intuitive interpretation
--   of <tt>s `<a>moreThan</a>` I</tt>.
moreThan :: D32 -> Image GrayScale D32 -> Image GrayScale D8

-- | Compares two images and produces a binary image that has white pixels
--   in those positions where the comparison is true. For example,
--   <tt>(less2Than A B)</tt> has white pixels where value of A is less
--   than value of B. Notice that these functions follow the intuitive
--   order of operands, unlike <a>lessThan</a> and <a>moreThan</a>.
less2Than :: CreateImage (Image GrayScale d) => Image GrayScale d -> Image GrayScale d -> Image GrayScale D8

-- | Compares two images and produces a binary image that has white pixels
--   in those positions where the comparison is true. For example,
--   <tt>(less2Than A B)</tt> has white pixels where value of A is less
--   than value of B. Notice that these functions follow the intuitive
--   order of operands, unlike <a>lessThan</a> and <a>moreThan</a>.
more2Than :: CreateImage (Image GrayScale d) => Image GrayScale d -> Image GrayScale d -> Image GrayScale D8

-- | Calculates the sum of pixel values in whole image (notice that OpenCV
--   automatically casts the result to double).
sum :: Image GrayScale D32 -> D32

-- | Calculates the average pixel value in whole image.
average :: Image GrayScale D32 -> D32

-- | Calculates the average value for pixels that have non-zero mask value.
averageMask :: Image GrayScale D32 -> Image GrayScale D8 -> D32

-- | Calculates the standard deviation of pixel values in whole image.
stdDeviation :: Image GrayScale D32 -> D32

-- | Calculates the standard deviation of values for pixels that have
--   non-zero mask value.
stdDeviationMask :: Image c d -> Image c1 d1 -> CDouble

-- | Finds the minimum and maximum pixel value in the image.
findMinMax :: Image t t1 -> (D32, D32)

-- | Finds the minimum and maximum pixel value in the image and the
--   locations where these values were found.
findMinMaxLoc :: (Fractional t3, Fractional t, Num t1, Num t2, Num t4, Num t5) => Image c d -> (((t1, t2), t), ((t4, t5), t3))

-- | Finds the minimum and maximum value for pixels with non-zero mask
--   value.
findMinMaxMask :: BareImage -> BareImage -> (D32, D32)

-- | Finds the minimum and maximum pixel value in the image.
imageMinMax :: Fractional d => Image GrayScale d -> (d, d)

-- | Utility functions for getting the maximum or minimum pixel value of
--   the image; equal to <tt>snd . findMinMax</tt> and <tt>fst .
--   findMinMax</tt>.
minValue :: Image GrayScale D32 -> D32

-- | Utility functions for getting the maximum or minimum pixel value of
--   the image; equal to <tt>snd . findMinMax</tt> and <tt>fst .
--   findMinMax</tt>.
maxValue :: Image GrayScale D32 -> D32

-- | Calculates the average and standard deviation of pixel values in the
--   image in one operation.
imageAvgSdv :: Fractional d => Image GrayScale d -> (d, d)

-- | Render image of 2D gaussian curve with standard deviation of
--   (stdX,stdY) to image size (w,h) The origin/center of curve is in
--   center of the image.
gaussianImage :: (Int, Int) -> (Double, Double) -> Image GrayScale D32

-- | Produce white image with <tt>edgeW</tt> amount of edges fading to
--   black.
fadedEdgeImage :: (CInt, CInt) -> CInt -> Image channels depth

-- | Produce image where pixel is coloured according to distance from the
--   edge.
fadeToCenter :: (CInt, CInt) -> Image channels depth

-- | Given a distance map and a circle, return the biggest circle with
--   radius less than given in the distance map that fully covers the
--   previous one.
maximalCoveringCircle :: (Fractional t2, Num t, Num t1) => Image c d -> (CInt, CInt, CDouble) -> (t, t1, t2)

-- | Operation to limit image with another image; same as <a>min</a>.
limitToOp :: Image c1 d1 -> ImageOperation c d


-- | Mathematical operators for images; see also module <a>ImageMath</a>
--   for the functions these operators are based on.
module CV.ImageMathOp

-- | Image addition, subtraction, and multiplication operator; same as
--   <a>add</a>, <a>sub</a>, and <a>mul</a>.
(#+) :: CreateImage (Image c d) => Image c d -> Image c d -> Image c d

-- | Image addition, subtraction, and multiplication operator; same as
--   <a>add</a>, <a>sub</a>, and <a>mul</a>.
(#-) :: CreateImage (Image c d) => Image c d -> Image c d -> Image c d

-- | Image addition, subtraction, and multiplication operator; same as
--   <a>add</a>, <a>sub</a>, and <a>mul</a>.
(#*) :: CreateImage (Image c d) => Image c d -> Image c d -> Image c d

-- | Image comparison operators; same as <a>less2Than</a> and
--   <a>more2Than</a>. Example: <tt>A #&lt; B</tt> produces a binary image
--   that has white pixels in those positions where value of A is less than
--   value of B.
(#<) :: CreateImage (Image GrayScale d) => Image GrayScale d -> Image GrayScale d -> Image GrayScale D8

-- | Image comparison operators; same as <a>less2Than</a> and
--   <a>more2Than</a>. Example: <tt>A #&lt; B</tt> produces a binary image
--   that has white pixels in those positions where value of A is less than
--   value of B.
(#>) :: CreateImage (Image GrayScale d) => Image GrayScale d -> Image GrayScale d -> Image GrayScale D8

-- | Scalar multiplication, addition, and subtraction (scalar on left)
--   operators; same as <a>mulS</a>, <a>addS</a>, and <a>subRS</a>.
(|*) :: D32 -> Image GrayScale D32 -> Image GrayScale D32

-- | Scalar multiplication, addition, and subtraction (scalar on left)
--   operators; same as <a>mulS</a>, <a>addS</a>, and <a>subRS</a>.
(|+) :: D32 -> Image GrayScale D32 -> Image GrayScale D32

-- | Scalar multiplication, addition, and subtraction (scalar on left)
--   operators; same as <a>mulS</a>, <a>addS</a>, and <a>subRS</a>.
(-|) :: D32 -> Image GrayScale D32 -> Image GrayScale D32

-- | Scalar subtraction operator (scalar on right); same as <a>subS</a>.
(|-) :: Image GrayScale D32 -> D32 -> Image GrayScale D32

-- | Scalar comparison operators; same as <a>moreThan</a> and
--   <a>lessThan</a>. Example: <tt>s |&gt; I</tt> produces a binary image
--   that has white pixels in those positions where the value of I is
--   larger than s. Notice that this is opposite to the intuitive
--   interpretation.
(|>) :: D32 -> Image GrayScale D32 -> Image GrayScale D8

-- | Scalar comparison operators; same as <a>moreThan</a> and
--   <a>lessThan</a>. Example: <tt>s |&gt; I</tt> produces a binary image
--   that has white pixels in those positions where the value of I is
--   larger than s. Notice that this is opposite to the intuitive
--   interpretation.
(|<) :: D32 -> Image GrayScale D32 -> Image GrayScale D8


-- | This module contains functions for simple histogram manipulation. Use
--   this to scale the image for viewing or to perform simple light-level
--   normalization accross multiple images.
module CV.ColourUtils

-- | Adjust the image histogram to have fixed mean and standard deviation.
--   This can be used for simple light level normalization.
balance :: (D32, D32) -> Image GrayScale D32 -> Image GrayScale D32

-- | Perform logarithmic compression on the image. This will enhance dark
--   features and suppress bright features. Use this to visualize images
--   with high dynamic range. (FFT results, for example)
logarithmicCompression :: Image GrayScale D32 -> Image GrayScale D32

-- | Histogram stretch scales the image to fit the range [0,1]
stretchHistogram :: Image GrayScale D32 -> Image GrayScale D32

-- | Equalize contrast of the image. This is good for visualizing images
--   with backgrounds and foregrounds that are both bright or both dark.
equalizeHistogram :: Image GrayScale D8 -> Image GrayScale D8


-- | This module is a collection of various image filters
module CV.Filters

-- | Create a new image by applying gaussian, or uniform smoothing.
gaussian :: (Int, Int) -> Image GrayScale D32 -> Image GrayScale D32

-- | Image operation which applies gaussian or unifarm smoothing with a
--   given window size to the image.
gaussianOp :: (Int, Int) -> ImageOperation GrayScale D32

-- | Image operation which applies gaussian or unifarm smoothing with a
--   given window size to the image.
blurOp :: (Int, Int) -> ImageOperation GrayScale D32

-- | Create a new image by applying gaussian, or uniform smoothing.
blur :: (Int, Int) -> Image GrayScale D32 -> Image GrayScale D32

-- | Create a new image by applying gaussian, or uniform smoothing.
blurNS :: (Int, Int) -> Image GrayScale D32 -> Image GrayScale D32

-- | Apply bilateral filtering
bilateral :: (Int, Int) -> (Int, Int) -> Image a D8 -> Image a D8
class HasMedianFiltering a
median :: HasMedianFiltering a => (Int, Int) -> a -> a

-- | SUSAN adaptive smoothing filter, see
--   <a>http://users.fmrib.ox.ac.uk/~steve/susan/susan/susan.html</a>
susan :: (Int, Int) -> Double -> Double -> Image GrayScale D32 -> Image GrayScale D32
getCentralMoment :: CInt -> (CInt, CInt) -> Image c d -> Image channels depth
getAbsCentralMoment :: CInt -> (CInt, CInt) -> Image c d -> Image channels depth
getMoment :: CInt -> (CInt, CInt) -> Image c d -> Image channels depth
secondMomentBinarize :: CDouble -> Image c d -> Image c d
secondMomentBinarizeOp :: CDouble -> ImageOperation c d
secondMomentAdaptiveBinarize :: CInt -> CInt -> CDouble -> Image c d -> Image c d
secondMomentAdaptiveBinarizeOp :: CInt -> CInt -> CDouble -> ImageOperation c d

-- | A selective average filter is an edge preserving noise reduction
--   filter. It is a standard gaussian filter which ignores pixel values
--   that are more than a given threshold away from the filtered pixel
--   value.
selectiveAvg :: (Int, Int) -> Double -> Image GrayScale D32 -> Image GrayScale D32
convolve2D :: (Point2D anchor, ELP anchor ~ Int) => Matrix D32 -> anchor -> Image GrayScale D32 -> Image GrayScale D32
convolve2DI :: (CInt, CInt) -> Image c1 d1 -> Image c d -> Image channels depth

-- | Filter the image with box shaped averaging mask.
haar :: IntegralImage -> (Int, Int, Int, Int) -> Image GrayScale D32

-- | Get an average of a given region.
haarAt :: IntegralImage -> (Int, Int, Int, Int) -> Double

-- | A type for storing integral images. Integral image stores for every
--   pixel the sum of pixels above and left of it. Such images are used for
--   significantly accelerating the calculation of area averages.
data IntegralImage

-- | Calculate the integral image from the given image.
integralImage :: Image GrayScale D32 -> IntegralImage

-- | Replace pixel values by the average of the row.
verticalAverage :: Image GrayScale D32 -> Image GrayScale D32
instance GetPixel IntegralImage
instance Sized IntegralImage
instance HasMedianFiltering (Image RGB D8)
instance HasMedianFiltering (Image GrayScale D32)
instance HasMedianFiltering (Image GrayScale D8)
instance Enum SmoothType


-- | This module provides QuickCheck generators for images.
module CV.Arbitrary

-- | Generate a random small image, that might be constant, noisy or
--   smoothly varying Range of values is [0,1]
smallImage :: Gen (Image GrayScale D32)

-- | Generate 10x10 constant image
constImage :: Gen (Image GrayScale D32)

-- | Generate 10x10 noisy image
noisyImage :: Gen (Image GrayScale D32)

-- | Generate 10x10 smoothly varying image
smoothImage :: Gen (Image GrayScale D32)

-- | Generate a (10m x 10m) sized noisy image.
blockNoise :: Int -> Gen (Image GrayScale D32)
instance Arbitrary ZeroOne


-- | This module contains functions for extracting features from connected
--   components of black and white images as well as extracting other shape
--   related features.
module CV.ConnectedComponents
fillConnectedComponents :: Image GrayScale D8 -> (Image GrayScale D8, Int)
maskConnectedComponent :: Image GrayScale D8 -> Int -> Image GrayScale D8

-- | Remove all connected components that fall outside of given size range
--   from the image.
selectSizedComponents :: Double -> Double -> Image GrayScale D8 -> Image GrayScale D8

-- | Count the number of connected components in the image
countBlobs :: Image GrayScale D8 -> Int

-- | Extract raw spatial moments of the image.
spatialMoments :: Image GrayScale D32 -> Bool -> [Double]

-- | Extract central moments of the image. These are useful for describing
--   the object shape for a classifier system.
centralMoments :: Image GrayScale D32 -> Bool -> [Double]

-- | Extract normalized central moments of the image.
normalizedCentralMoments :: Image GrayScale D32 -> Bool -> [Double]

-- | Extract Hu-moments of the image. These features are rotation
--   invariant.
huMoments :: Image GrayScale D32 -> Bool -> [Double]

-- | Structure that contains the opencv sequence holding the contour data.
data Contours

-- | Extract contours of connected components of the image.
getContours :: Image GrayScale D8 -> Contours

-- | The area of a contour.
contourArea :: ContourFunctionUS Double

-- | Get the perimeter of a contour.
contourPerimeter :: ContourFunctionUS Double

-- | Get a list of the points in the contour.
contourPoints :: ContourFunctionUS [(Double, Double)]

-- | This function maps an opencv contour calculation over all contours of
--   the image.
mapContours :: ContourFunctionUS a -> Contours -> [a]

-- | Operation for extracting Hu-moments from a contour
contourHuMoments :: ContourFunctionUS [Double]

module CV.DFT
dft :: Image GrayScale d -> Image Complex D32
idft :: Image Complex D32 -> Image GrayScale D32
complexSplit :: Image Complex D32 -> (Image GrayScale D32, Image GrayScale D32)
complexToMagnitude :: Image Complex D32 -> Image GrayScale D32

module CV.Operations
clear :: Image c d -> Image c d
set :: Double -> Image c d -> Image c d
expand :: (Int, Int, Int, Int) -> Image d c -> Image d c
data NormType
NormC :: NormType
NormL1 :: NormType
NormL2 :: NormType
NormMask :: NormType
NormRelative :: NormType
NormDiff :: NormType
NormMinMax :: NormType
NormDiffC :: NormType
NormDiffL1 :: NormType
NormDiffL2 :: NormType
NormDiffRelativeC :: NormType
NormDiffRelativeL1 :: NormType
NormDiffRelativeL2 :: NormType
normalize :: Double -> Double -> NormType -> Image c d -> Image c d
unitNormalize :: (Fractional a, Ord a) => Image GrayScale a -> Image GrayScale a
unitStretch :: Image c d -> Image c d
logNormalize :: Image GrayScale D32 -> Image GrayScale D32
cartToPolar :: (Image GrayScale D32, Image GrayScale D32) -> (Image GrayScale D32, Image GrayScale D32)


-- | Module for exposing opencv drawing functions. These are meant for
--   quick and dirty marking and not for anything presentable. For any real
--   drawing you should figure out how to use cairo or related package,
--   such as diagrams. They are way better.
--   
--   Consult the <a>CV.ImageOp</a> module for functions to apply the
--   operations in this module to images.
module CV.Drawing

-- | Is the shape filled or just a boundary?
data ShapeStyle
Filled :: ShapeStyle
Stroked :: Int -> ShapeStyle

-- | Typeclass for images that support elementary drawing operations.
class Drawable a b where type family Color a b :: *
putTextOp :: Drawable a b => (Color a b) -> Float -> String -> (Int, Int) -> ImageOperation a b
lineOp :: Drawable a b => (Color a b) -> Int -> (Int, Int) -> (Int, Int) -> ImageOperation a b
circleOp :: Drawable a b => (Color a b) -> (Int, Int) -> Int -> ShapeStyle -> ImageOperation a b
rectOp :: (Drawable a b, BoundingBox bb, Integral (ELBB bb)) => (Color a b) -> Int -> bb -> ImageOperation a b
fillPolyOp :: Drawable a b => (Color a b) -> [(Int, Int)] -> ImageOperation a b
ellipseOp :: Drawable a b => (Color a b) -> Int -> (Int, Int) -> (Int, Int) -> Float -> (Float, Float) -> ImageOperation a b
ellipseBoxOp :: Drawable a b => (Color a b) -> C'CvBox2D -> Int -> Int -> ImageOperation a b

-- | Draw a line segments
drawLinesOp :: Drawable c d => Color c d -> Int -> [((Int, Int), (Int, Int))] -> ImageOperation c d

-- | Draw a polyline
drawPolyLineOp :: Drawable c d => Color c d -> Int -> [((Int, Int))] -> ImageOperation c d

-- | Draw C'CvBox2D
drawBox2Dop :: Drawable c d => Color c d -> C'CvBox2D -> ImageOperation c d

-- | Flood fill a region of the image
fillOp :: (Int, Int) -> D32 -> D32 -> D32 -> Bool -> ImageOperation GrayScale D32

-- | Apply fillOp to an image
floodfill :: (Int, Int) -> D32 -> D32 -> D32 -> Bool -> Image GrayScale D32 -> Image GrayScale D32

-- | Apply circleOp to an image
circle :: Drawable c d => (Int, Int) -> Int -> Color c d -> ShapeStyle -> Image c d -> Image c d

-- | Apply drawLinesOp to an image
drawLines :: Drawable c d => Image c d -> Color c d -> Int -> [((Int, Int), (Int, Int))] -> IO (Image c d)

-- | Apply rectOp to an image
rectangle :: (BoundingBox bb, Integral (ELBB bb), Drawable c d) => Color c d -> Int -> bb -> Image c d -> IO (Image c d)

-- | Apply fillPolyOp to an image
fillPoly :: Drawable c d => Color c d -> [(Int, Int)] -> Image c d -> IO (Image c d)
instance Eq ShapeStyle
instance Show ShapeStyle
instance Drawable GrayScale D32
instance Drawable GrayScale D8
instance Drawable Complex D32
instance Drawable RGB D32

module CV.DrawableInstances
instance Draws C'CvPoint2D32f (ImageOperation GrayScale D32)
instance Draws C'CvSURFPoint (ImageOperation GrayScale D32)


-- | This module is a collection of simple edge detectors.
module CV.Edges

-- | Perform Sobel filtering on image. First argument gives order of
--   horizontal and vertical derivative estimates and second one is the
--   aperture. This function can also calculate Scharr filter with aperture
--   specification of sScharr
sobelOp :: (Int, Int) -> SobelAperture -> ImageOperation GrayScale D32
sobel :: (Int, Int) -> SobelAperture -> Image GrayScale D32 -> Image GrayScale D32

-- | Perform laplacian filtering of given aperture to image
laplaceOp :: LaplacianAperture -> ImageOperation GrayScale D32
laplace :: LaplacianAperture -> Image GrayScale D32 -> Image GrayScale D32

-- | Perform canny thresholding using two threshold values and given
--   aperture Works only on 8-bit images
canny :: Int -> Int -> Int -> Image GrayScale D8 -> Image GrayScale D8

-- | SUSAN edge detection filter, see
--   <a>http://users.fmrib.ox.ac.uk/~steve/susan/susan/susan.html</a>
susan :: (Int, Int) -> D32 -> Image GrayScale D32 -> Image GrayScale D8

-- | Aperture sizes for sobel operator
data SobelAperture

-- | Use Scharr mask instead
sScharr :: SobelAperture
s1 :: SobelAperture
s3 :: SobelAperture
s5 :: SobelAperture
s7 :: SobelAperture

-- | Aperture sizes for laplacian operator
data LaplacianAperture
l1 :: LaplacianAperture
l3 :: LaplacianAperture
l5 :: LaplacianAperture
l7 :: LaplacianAperture
instance Eq SobelAperture
instance Ord SobelAperture
instance Show SobelAperture
instance Read SobelAperture
instance Eq LaplacianAperture
instance Ord LaplacianAperture
instance Show LaplacianAperture
instance Read LaplacianAperture

module CV.Features

-- | Parameters for SURF feature extraction
data SURFParams

-- | Default parameters for getSURF
defaultSURFParams :: SURFParams
mkSURFParams :: Double -> Int -> Int -> Bool -> SURFParams

-- | Extract Speeded Up Robust Features from an image.
getSURF :: SURFParams -> Image GrayScale D8 -> Maybe (Image GrayScale D8) -> [(C'CvSURFPoint, [Float])]

-- | The function encapsulates all the parameters of the MSER extraction
--   algorithm (see
--   <a>http://en.wikipedia.org/wiki/Maximally_stable_extremal_regions</a>
getMSER :: (Point2D a, ELP a ~ Int) => Image GrayScale D8 -> Maybe (Image GrayScale D8) -> MSERParams -> [[a]]
data MSERParams

-- | Create parameters for getMSER.
mkMSERParams :: Int -> Int -> Int -> Float -> Float -> Int -> Double -> Double -> Int -> MSERParams
defaultMSERParams :: MSERParams
moments :: Image GrayScale D32 -> Moments
type Moments = C'CvMoments
getSpatialMoment :: (Int, Int) -> Moments -> Double
getCentralMoment :: (Int, Int) -> Moments -> Double
getNormalizedCentralMoment :: (Int, Int) -> Moments -> Double
instance Show MSERParams
instance Show SURFParams
instance Show FloatBlock64
instance Show FloatBlock128
instance Storable FloatBlock128
instance Storable FloatBlock64

module CV.Fitting
data Ellipse
Ellipse :: (Float, Float) -> Float -> Float -> Float -> Ellipse
center :: Ellipse -> (Float, Float)
width :: Ellipse -> Float
height :: Ellipse -> Float
angle :: Ellipse -> Float

-- | Given a (1,n) or (n,1) matrix of points, calculate (in the least
--   squares sense) the best ellipse around the points
fitEllipse :: Matrix (Float, Float) -> Ellipse

-- | Fit a line to set of points.
fitLine2D :: Dist -> Double -> Double -> Double -> Matrix (Float, Float) -> ((Float, Float), (Float, Float))

-- | Fit a minimum area rectangle over a set of points
minAreaRect :: Matrix (Float, Float) -> C'CvBox2D

-- | Calculate the minimum axis-aligned bounding rectangle of given points.
boundingRect :: Matrix (Float, Float) -> C'CvRect

-- | Calculate the minimum enclosing circle of a point set.
boundingCircle :: (ELP a ~ Double, Point2D a) => Matrix (Float, Float) -> (a, Double)

-- | Calculcate the clockwise convex hull of a point set
convexHull :: Matrix (Float, Float) -> Matrix (Float, Float)

-- | Calculate convexity defects of a contour.
convexityDefects :: Matrix (Int, Int) -> [(C'CvPoint, C'CvPoint, C'CvPoint, CFloat)]
instance Eq Ellipse
instance Show Ellipse

module CV.FunnyStatistics
r_variance :: (Int, Int) -> Image GrayScale D32 -> Image GrayScale D32
variance :: (Int, Int) -> Image GrayScale D32 -> Image GrayScale D32
stdDev :: (Int, Int) -> Image GrayScale D32 -> Image GrayScale D32
r_stdDev :: (Int, Int) -> Image GrayScale D32 -> Image GrayScale D32
pearsonSkewness1 :: (Int, Int) -> Image GrayScale D32 -> Image GrayScale D32


-- | Various image transformations from opencv and other sources.
module CV.Transforms

-- | Since DCT is valid only for even sized images, we provide a function
--   to crop images to even sizes.
takeEvenSized :: Image c d -> Image c d

-- | Perform Discrete Cosine Transform
dct :: Image GrayScale d -> Image GrayScale d

-- | Perform Inverse Discrete Cosine Transform
idct :: Image GrayScale d -> Image GrayScale d
data MirrorAxis
Vertical :: MirrorAxis
Horizontal :: MirrorAxis

-- | Mirror an image over a cardinal axis
flip :: CreateImage (Image c d) => MirrorAxis -> Image c d -> Image c d

-- | Rotate <tt>img</tt> <tt>angle</tt> radians.
rotate :: Double -> Image c d -> Image c d
data Interpolation
NearestNeighbour :: Interpolation
Linear :: Interpolation
Area :: Interpolation
Cubic :: Interpolation

-- | Simulate a radial distortion over an image
radialDistort :: Image GrayScale D32 -> Double -> Image GrayScale D32

-- | Scale image by one ratio on both of the axes
scaleSingleRatio :: (RealFloat a, CreateImage (Image c D32)) => Interpolation -> a -> Image c D32 -> Image c D32

-- | Scale an image with different ratios for axes
scale :: (CreateImage (Image c D32), RealFloat a) => Interpolation -> (a, a) -> Image c D32 -> Image c D32

-- | Scale an image to a given size
scaleToSize :: CreateImage (Image c D32) => Interpolation -> Bool -> (Int, Int) -> Image c D32 -> Image c D32

-- | Apply a perspective transform to the image. The transformation 3x3
--   matrix is supplied as a row ordered, flat, list.
perspectiveTransform :: Real a => Image c d -> [a] -> Image c d
perspectiveTransform' :: CreateImage (Image c d) => Matrix Float -> Image c d -> (Int, Int) -> Image c d

-- | Find a homography between two sets of points in. The resulting 3x3
--   matrix is returned as a list.
getHomography :: Real a => [(a, a)] -> [(a, a)] -> [CDouble]
data HomographyMethod
Default :: HomographyMethod
Ransac :: HomographyMethod
LMeds :: HomographyMethod
getHomography' :: Matrix Float -> Matrix Float -> HomographyMethod -> Float -> Matrix Float

-- | Return a copy of an image with an even size
evenize :: Image channels depth -> Image channels depth

-- | Return a copy of an image with an odd size
oddize :: Image channels depth -> Image channels depth

-- | Pad images to same size
sameSizePad :: Image channels depth -> Image c d -> Image channels depth
cv_Gaussian :: CInt

-- | Downsize image by 50% efficiently. Image dimensions must be even.
pyrDown :: CreateImage (Image GrayScale a) => Image GrayScale a -> Image GrayScale a
pyrUp :: CreateImage (Image GrayScale a) => Image GrayScale a -> Image GrayScale a
safePyrDown :: CreateImage (Image GrayScale depth) => Image GrayScale depth -> Image GrayScale depth

-- | Enlargen the image so that its size is a power of two.
minEnlarge :: Image GrayScale D32 -> Image GrayScale D32

-- | Calculate an infinite gaussian pyramid of an image while keeping track
--   of various corner cases and gotchas.
gaussianPyramid :: Image GrayScale D32 -> [Image GrayScale D32]

-- | Calculate the laplacian pyramid of an image up to the nth level.
--   Notice that the image size must be divisible by 2^n or opencv will
--   abort (TODO!)
laplacianPyramid :: Int -> Image GrayScale D32 -> [Image GrayScale D32]

-- | Reconstruct an image from a laplacian pyramid
reconstructFromLaplacian :: [Image GrayScale D32] -> Image GrayScale D32

-- | Enlargen the image so that its size is divisible by 2^n. Fill the area
--   outside the image with black.
enlarge :: Int -> Image GrayScale D32 -> Image GrayScale D32

-- | Enlargen the image so that its size is is divisible by 2^n. Replicate
--   the border of the image.
enlargeShadow :: Int -> Image GrayScale D32 -> Image GrayScale D32
data DistanceType
C :: DistanceType
L1 :: DistanceType
L2 :: DistanceType

-- | Mask sizes accepted by distanceTransform
data MaskSize
M3 :: MaskSize
M5 :: MaskSize
distanceTransform :: DistanceType -> MaskSize -> Image GrayScale D8 -> Image GrayScale D32
cvDCT :: (Ptr ()) -> ((Ptr ()) -> (CInt -> (IO ())))
cvFlip :: (Ptr ()) -> ((Ptr ()) -> (CInt -> (IO ())))
rotateImage :: (Ptr (BareImage)) -> (CDouble -> (CDouble -> (IO (Ptr (BareImage)))))
radialRemap :: (Ptr (BareImage)) -> ((Ptr (BareImage)) -> (CDouble -> (IO ())))
cvResize :: (Ptr ()) -> ((Ptr ()) -> (CInt -> (IO ())))
wrapPerspective :: (Ptr (BareImage)) -> (CDouble -> (CDouble -> (CDouble -> (CDouble -> (CDouble -> (CDouble -> (CDouble -> (CDouble -> (CDouble -> (IO (Ptr (BareImage))))))))))))
wrapWarpPerspective :: (Ptr ()) -> ((Ptr ()) -> ((Ptr ()) -> (IO ())))
findHomography :: (Ptr CDouble) -> ((Ptr CDouble) -> (CInt -> ((Ptr CDouble) -> (IO ()))))
cvFindHomography :: (Ptr ()) -> ((Ptr ()) -> ((Ptr ()) -> (CInt -> (CDouble -> ((Ptr ()) -> (IO CInt))))))
makeEvenUp :: (Ptr (BareImage)) -> (IO (Ptr (BareImage)))
padUp :: (Ptr (BareImage)) -> (CInt -> (CInt -> (IO (Ptr (BareImage)))))
cvPyrDown :: (Ptr ()) -> ((Ptr ()) -> (CInt -> (IO ())))
cvPyrUp :: (Ptr ()) -> ((Ptr ()) -> (CInt -> (IO ())))
blitShadow :: (Ptr (BareImage)) -> ((Ptr (BareImage)) -> (IO ()))
cvDistTransform :: (Ptr ()) -> ((Ptr ()) -> (CInt -> (CInt -> ((Ptr CFloat) -> ((Ptr ()) -> (IO ()))))))
instance Show MirrorAxis
instance Eq MirrorAxis
instance Eq Interpolation
instance Ord Interpolation
instance Enum Interpolation
instance Show Interpolation
instance Eq MaskSize
instance Ord MaskSize
instance Enum MaskSize
instance Show MaskSize
instance Enum DistanceType
instance Enum HomographyMethod

module CV.Gabor
newtype GaborMask
GaborMask :: (CInt, CInt, CDouble, CDouble, CDouble, CDouble, CDouble) -> GaborMask
gaborImage :: (Int, Int, CDouble, CDouble, CDouble, CDouble, CDouble, CDouble, CDouble) -> Image GrayScale D32
gaborFiltering :: GaborMask -> Image c d -> Image c d
radialGaborFiltering :: (CInt, CInt, CDouble, CDouble, CDouble, CDouble) -> Image c d -> Image c d
radialGaborImage :: (Int, Int, CDouble, CDouble, CDouble, CDouble) -> Image GrayScale D32
renderGabor :: (Ptr ()) -> (CInt -> (CInt -> (CDouble -> (CDouble -> (CDouble -> (CDouble -> (CDouble -> (CDouble -> (CDouble -> (IO ()))))))))))
gaborFilter :: (Ptr ()) -> ((Ptr ()) -> (CInt -> (CInt -> (CDouble -> (CDouble -> (CDouble -> (CDouble -> (CDouble -> (IO ())))))))))
radialGaborFilter :: (Ptr ()) -> ((Ptr ()) -> (CInt -> (CInt -> (CDouble -> (CDouble -> (CDouble -> (CDouble -> (IO ()))))))))
renderRadialGabor :: (Ptr ()) -> (CInt -> (CInt -> (CDouble -> (CDouble -> (CDouble -> (CDouble -> (IO ())))))))

module CV.HighGUI
display :: Image c d -> IO ()
mkWin :: String -> Int -> IO ()
makeWindow :: String -> IO ()
destroyWindow :: String -> IO ()
trackbarCallback :: (CInt -> IO ()) -> IO (FunPtr (CInt -> IO ()))
mkTrackbar :: Integral a => a -> t -> String -> String -> (CInt -> IO ()) -> IO CInt
waitKey :: CInt -> IO CInt
showImage :: String -> Image c d -> IO ()
mkWin'_ :: (Ptr CChar) -> (CInt -> (IO CInt))
cvDestroyWindow :: (Ptr CChar) -> (IO ())
cvCreateTrackbar :: (Ptr CChar) -> ((Ptr CChar) -> ((Ptr CInt) -> (CInt -> ((FunPtr (CInt -> (IO ()))) -> (IO CInt)))))
cvWaitKey :: CInt -> (IO CInt)
showImage'_ :: (Ptr CChar) -> ((Ptr ()) -> (IO ()))

module CV.Histogram
newtype HistogramData a
HGD :: [(a, a)] -> HistogramData a

-- | Given a set of images, such as the color channels of color image, and
--   a histogram with corresponding number of channels, replace the pixels
--   of the image with the likelihoods from the histogram
backProjectHistogram :: [Image GrayScale D8] -> Histogram -> Image GrayScale D8

-- | Calculate an opencv histogram object from set of images, each with
--   it's own number of bins.
histogram :: [(Image GrayScale D8, Int)] -> Bool -> Maybe (Image GrayScale D8) -> Histogram
values :: HistogramData b -> [b]
cmpUnion :: (Num a, Ord a) => [a] -> [a] -> a
cmpIntersect :: (Num a, Ord a) => [a] -> [a] -> a
cmpEuclidian :: Num a => [a] -> [a] -> a
cmpAbs :: Num a => [a] -> [a] -> a
chiSqrHG :: (Fractional a, Ord a) => HistogramData a -> HistogramData a -> a
chiSqr :: (Fractional a, Ord a) => [a] -> [a] -> a
liftBins :: ([b] -> [a]) -> HistogramData b -> [(a, b)]
liftValues :: ([a] -> [b]) -> HistogramData a -> [(a, b)]
sub :: (Eq b, Num b) => HistogramData b -> HistogramData b -> HistogramData b
noBins :: HistogramData t -> Int
getPositivePart :: (Num b, Ord b) => HistogramData b -> HistogramData b
tcumulate :: Num a => [a] -> [a]
weightedHistogram :: (Fractional b, Real a, Real a1) => Image c d -> Image c1 d1 -> a -> a1 -> Int -> [b]
simpleGetHistogram :: Image GrayScale D32 -> Maybe (Image GrayScale D8) -> D32 -> D32 -> Int -> Bool -> [D32]
get_weighted_histogram :: (Ptr (BareImage)) -> ((Ptr (BareImage)) -> (CDouble -> (CDouble -> (CInt -> ((Ptr CDouble) -> (IO ()))))))
get_histogram :: (Ptr (BareImage)) -> ((Ptr (BareImage)) -> (CFloat -> (CFloat -> (CInt -> (CInt -> ((Ptr CDouble) -> (IO ())))))))

module CV.HoughTransform
type HoughDesc = Int
data Segment
Segment :: (Int, Int) -> (Int, Int) -> Segment
start :: Segment -> (Int, Int)
end :: Segment -> (Int, Int)
data Line
Line :: Double -> Double -> Line
bias :: Line -> Double
θ :: Line -> Double
data With a b
With :: a -> b -> With a b
type ImageWithLines = Image GrayScale D8 With [Line]
type ImageWithSegments = Image GrayScale D8 With [Segment]
image :: Image c d With e -> Image c d
lines :: a With [Line] -> [Line]
segments :: a With [Segment] -> [Segment]
lineToSegment :: (Int, t) -> Line -> Segment
houghProbabilisticToLine :: t -> (Int, Int) -> (Int, Int) -> Segment
rho1pix :: Double
rho5pix :: Double
theta1deg :: Double
theta2deg :: Double
imageHoughLinesStandard :: Int -> Double -> Double -> Int -> Image GrayScale D8 -> ImageWithLines
imageHoughLinesProbabilistic :: Int -> Double -> Double -> Int -> Double -> Double -> Image GrayScale D8 -> ImageWithSegments
imageHoughLinesMultiScale :: Int -> Double -> Double -> Int -> Double -> Double -> Image GrayScale D8 -> ImageWithLines
houghLinesStandard :: Image GrayScale D8 -> Int -> Double -> Double -> Int -> [(CFloat, CFloat)]
houghLinesProbabilistic :: Image GrayScale D8 -> Int -> Double -> Double -> Int -> Double -> Double -> [(CInt, CInt, CInt, CInt)]
houghLinesMultiscale :: Image GrayScale D8 -> Int -> Double -> Double -> Int -> Double -> Double -> [(CFloat, CFloat)]
houghCirclesGradient :: Image GrayScale D8 -> Int -> Double -> Double -> Double -> Double -> Int -> Int -> [(CFloat, CFloat, CFloat)]
instance Eq Segment
instance Show Segment
instance Eq Line
instance Show Line

module CV.Sampling
allPatches :: (Int, Int) -> Image c d -> [Image c d]
allButLast :: [a] -> [a]
getTiles :: (Int, Int) -> Image c d -> [Image c d]
getTilesC :: (Int, Int) -> Image c d -> [((Int, Int), Image c d)]
getOverlappedTileCoords :: (Integral t2, Integral t3, RealFrac t, RealFrac t1, Sized a, ~ * (Size a) (t2, t3)) => (t2, t3) -> (t, t1) -> a -> [(t2, t3)]
getOverlappedTiles :: (Int, Int) -> (CDouble, CDouble) -> Image c d -> [Image c d]
getOverlappedTilesC :: (Int, Int) -> (CDouble, CDouble) -> Image c d -> [((Int, Int), Image c d)]
both :: (t -> t1) -> (t, t) -> (t1, t1)
getMarkedAndUnmarkedTiles :: (Int, Int) -> (CDouble, CDouble) -> Image c d -> Image GrayScale Float -> ([Image c d], [Image c d])
getPatches :: (Int, Int) -> [(Int, Int)] -> Image c d -> [Image c d]
getCenteredPatches :: (Int, Int) -> [(Int, Int)] -> Image c d -> [Image c d]
discardAroundEdges :: (Num t, Num t1, Ord t, Ord t1) => (t, t1) -> (t, t1) -> [(t, t1)] -> [(t, t1)]
getCoordsFromMarks :: (Fractional (P a), Ord (P a), Sized a, GetPixel a, ~ * (Size a) (Int, Int)) => a -> [(Int, Int)]
getMarkedPatches :: (Fractional (P a), Ord (P a), Sized a, GetPixel a, ~ * (Size a) (Int, Int)) => (Int, Int) -> Image c d -> a -> [Image c d]
randomPatches :: PrimMonad m => (Int, Int) -> Int -> Image c d -> Gen (PrimState m) -> m [Image c d]
randomCoord :: PrimMonad m => (Int, Int) -> Gen (PrimState m) -> m (Int, Int)

module CV.Iterators
class ImageContext c where type family V c :: *
getPos :: ImageContext c => c -> (Int, Int)
getVal :: ImageContext c => c -> Maybe (V c)
evolve :: ImageContext c => c -> c
type F32I = Ptr C'F32_image_iterator
filterPixels :: (Float -> Bool) -> Image GrayScale D32 -> [((Int, Int), Float)]
filterPixelsSlow :: (Float -> Bool) -> Image GrayScale D32 -> [((Int, Int), Float)]
instance ImageContext F32I

module CV.Corners
type HarrisDesc = Float
data Corner d
Corner :: (Int, Int) -> d -> Corner d
pos :: Corner d -> (Int, Int)
desc :: Corner d -> d
data ImageWithCorners d
ImageWithCorners :: Image GrayScale D32 -> [Corner d] -> ImageWithCorners d
image :: ImageWithCorners d -> Image GrayScale D32
corners :: ImageWithCorners d -> [Corner d]
harris :: Int -> Int -> Double -> Image GrayScale D32 -> Image GrayScale D32
harrisCorners :: Float -> Image GrayScale D32 -> ImageWithCorners HarrisDesc

module CV.LightBalance
f :: Int -> CInt
x2cylinder :: (Real a, Real a1, Real a2) => (Int, Int) -> a -> a1 -> a2 -> Image channels depth
cos4cylinder :: (Int, Int) -> Image channels depth
cos4vignetting :: (Int, Int) -> Image channels depth
threeB :: (Int, Int) -> CDouble -> CDouble -> CDouble -> Image channels depth
twoPar :: (Int, Int) -> CDouble -> CDouble -> CDouble -> Image channels depth
vignettingModelX2Cyl :: CInt -> (CInt -> (CDouble -> (CDouble -> (CDouble -> (IO (Ptr (BareImage)))))))
vignettingModelCos4XCyl :: CInt -> (CInt -> (IO (Ptr (BareImage))))
vignettingModelCos4 :: CInt -> (CInt -> (IO (Ptr (BareImage))))
vignettingModelB3 :: CInt -> (CInt -> (CDouble -> (CDouble -> (CDouble -> (IO (Ptr (BareImage)))))))
vignettingModelP :: CInt -> (CInt -> (CDouble -> (CDouble -> (CDouble -> (IO (Ptr (BareImage)))))))

module CV.Morphology
type StructuringElement = ConvKernel
structuringElement :: Enum a => (CInt, CInt) -> (CInt, CInt) -> a -> ConvKernel
customSE :: (CInt, CInt) -> (CInt, CInt) -> [CInt] -> ConvKernel
basicSE :: ConvKernel
bigSE :: ConvKernel
geodesic :: Image GrayScale D32 -> ImageOperation GrayScale D32 -> ImageOperation GrayScale D32
openOp :: StructuringElement -> ImageOperation GrayScale D32
closeOp :: StructuringElement -> ImageOperation GrayScale D32
open :: StructuringElement -> Image GrayScale D32 -> Image GrayScale D32
close :: StructuringElement -> Image GrayScale D32 -> Image GrayScale D32
erode :: ConvKernel -> Int -> Image c d -> Image c d
dilate :: ConvKernel -> Int -> Image c d -> Image c d

-- | Perform a black tophat filtering of size
blackTopHat :: CInt -> Image GrayScale D32 -> Image GrayScale D32

-- | Perform a white tophat filtering of size
whiteTopHat :: CInt -> Image GrayScale D32 -> Image GrayScale D32
dilateOp :: ConvKernel -> Int -> ImageOperation c d
erodeOp :: ConvKernel -> Int -> ImageOperation c d
data KernelShape
RectShape :: KernelShape
CrossShape :: KernelShape
EllipseShape :: KernelShape
instance Enum KernelShape

module CV.Marking
boxFlaws :: Image GrayScale D32 -> Image GrayScale D32
highLightFlaws :: Image GrayScale D32 -> Image GrayScale D32 -> Image GrayScale D32
displayFlaws :: Image GrayScale D32 -> Image GrayScale D32 -> Image GrayScale D32
displayLargeFlaws :: Image GrayScale D32 -> Image GrayScale D32 -> Image GrayScale D32
type Marker c d = (Int, Int) -> (Int, Int) -> ImageOperation c d
condMarker :: (t1 -> Bool) -> (t -> t1 -> t2 -> ImageOperation c d) -> t -> t1 -> t2 -> ImageOperation c d
getCoordsForMarkedTiles :: (Integral t2, Integral t3, RealFrac t, RealFrac t1, Sized a, ~ * (Size a) (t2, t3)) => (t2, t3) -> (t, t1) -> [Bool] -> a -> [(t2, t3)]
cuteDot :: (Num (Color c d), Drawable c d) => (Int, Int) -> ImageOperation c d
cuteCircle1 :: (Num (Color c d), Drawable c d) => (Int, Int) -> ImageOperation c d
cuteRect :: (Fractional (Color c d), Integral a, Drawable c d) => (a, a) -> (a, a) -> ImageOperation c d
cuteCircle :: Marker GrayScale D32
markTiles :: (RealFrac t, RealFrac t1) => Image c d -> (Int, Int) -> (t, t1) -> ((Int, Int) -> t2 -> (Int, Int) -> ImageOperation c d) -> [t2] -> Image c d


-- | This module provides the elementary image splining (seamless merging)
--   using the burt-adelson multiresolution splines introduced in <a>A
--   multiresolution spline with application to image mosaics</a>, Burt,
--   P.J. and Adelson, E.H., ACM Transactions on Graphics,1983.
module CV.MultiresolutionSpline

-- | This function merges two images based on given mask, the first image
--   dominates on areas where the mask is 1 and the second where the mask
--   is 0. The merging should be relatively seamless and is controlled by
--   the <tt>levels</tt> parameter, which adjusts the accuracy. Usually,
--   decent results can be obtained with 4 pyramid levels.
--   
--   Note that the mask should contain a tiny blurred region between images
--   for optimal result.
burtAdelsonMerge :: Int -> Image GrayScale D8 -> Image GrayScale D32 -> Image GrayScale D32 -> Image GrayScale D32

module CV.TemplateMatching
getTemplateMap :: Image c d -> Image c1 d1 -> Image channels depth
data MatchType
SQDIFF :: MatchType
SQDIFF_NORMED :: MatchType
CCORR :: MatchType
CCORR_NORMED :: MatchType
CCOEFF :: MatchType
CCOEFF_NORMED :: MatchType
simpleTemplateMatch :: MatchType -> Image GrayScale D32 -> Image GrayScale D32 -> ((Int, Int), Double)
matchTemplate :: MatchType -> Image GrayScale D32 -> Image GrayScale D32 -> Image GrayScale D32

-- | Perform subpixel template matching using intensity interpolation
subPixelTemplateMatch :: MatchType -> Image GrayScale D32 -> Image GrayScale D32 -> Double -> (Double, Double)
regionToInt :: (Integral a, RealFrac a1) => Rectangle a1 -> Rectangle a
data ShapeMatchMethod
Method1 :: ShapeMatchMethod
Method2 :: ShapeMatchMethod
Method3 :: ShapeMatchMethod
matchShapes :: ShapeMatchMethod -> Image GrayScale D8 -> Image GrayScale D8 -> Double
templateImage :: (Ptr (BareImage)) -> ((Ptr (BareImage)) -> (IO (Ptr (BareImage))))
simpleMatchTemplate :: (Ptr (BareImage)) -> ((Ptr (BareImage)) -> ((Ptr CInt) -> ((Ptr CInt) -> ((Ptr CDouble) -> (CInt -> (IO ()))))))
cvMatchTemplate :: (Ptr ()) -> ((Ptr ()) -> ((Ptr ()) -> (CInt -> (IO ()))))
cvMatchShapes :: (Ptr ()) -> ((Ptr ()) -> (CInt -> (CDouble -> (IO CDouble))))
instance Enum ShapeMatchMethod
instance Enum MatchType


-- | This module provides implementations for basic versions of Local
--   Binary Pattern texture features introduced in T. Ojala, M.
--   Pietikäinen, and D. Harwood (1994), <a>Performance evaluation of
--   texture measures with classification based on Kullback discrimination
--   of distributions</a>, Proceedings of the 12th IAPR International
--   Conference on Pattern Recognition (ICPR 1994).
module CV.Textures

-- | Convert an LBP histogram into rotation invariant form
rotationInvariant :: [Double] -> Vector Double

-- | The most basic 3x3 lbp operator
lbp :: Image GrayScale D32 -> [Double]

-- | The larger radius basic 5x5 lbp operator
lbp5 :: Image GrayScale D32 -> [Double]

-- | A variant of LBP which is weighted. This can be used to select only
--   parts of the image by using binary masks, or to give higher weight for
--   some areas of the image.
weightedLBP :: (Integral a, Integral a1) => a -> a1 -> Image GrayScale D32 -> Image GrayScale D32 -> [Double]


-- | Image thresholding operations
module CV.Thresholding

-- | Thresholding behavior for values larger and smaller than threshold
data ThresholdType

-- | Values larger than threshold are set to max, smaller to zero
MaxAndZero :: ThresholdType

-- | Values larger than threshold are set to zero, smaller to max
ZeroAndMax :: ThresholdType

-- | Values larger than threshold are truncated to threshold, smaller are
--   not touched
ThreshAndValue :: ThresholdType

-- | Values larger than threshold are not touched, smaller are set to zero
ValueAndZero :: ThresholdType

-- | Values larger than threshold are set to zero, smaller are not touched
ZeroAndValue :: ThresholdType

-- | Thresholds a grayscale image according to the selected type, using the
--   given threshold value.
threshold :: MaxVal d => ThresholdType -> Double -> Image GrayScale d -> Image GrayScale d
thresholdInPlace :: MaxVal d => ThresholdType -> Double -> Image GrayScale d -> IO (Image GrayScale D8)

-- | Thresholds a grayscale image using the otsu method according to the
--   selected type. Threshold value is selected automatically, and only
--   8-bit images are supported.
thresholdOtsu :: ThresholdType -> Image GrayScale D8 -> Image GrayScale D8

-- | Method used for selecting the adaptive threshold value
data AdaptiveType

-- | Threshold using the arithmetic mean of pixel neighborhood
ByMean :: AdaptiveType

-- | Threshold using the gaussian weighted mean of pixel neighborhood
ByGaussian :: AdaptiveType

-- | Applies adaptive thresholding by selecting the optimal threshold value
--   for each pixel. The threshold is selected by calculating the
--   arithmetic or gaussian-weighted mean of a pixel neighborhood, and
--   applying a bias term to the obtained value.
adaptiveThreshold :: MaxVal d => AdaptiveType -> ThresholdType -> Int -> Double -> Image GrayScale d -> Image GrayScale d
bernsen :: (CInt, CInt) -> Float -> Image GrayScale Float -> Image GrayScale D8
nibbly :: D32 -> D32 -> Image GrayScale D32 -> Image GrayScale D8
nibblyr :: (Int, Int) -> Float -> Image GrayScale D32 -> Image GrayScale D8
kittler :: Float -> Image GrayScale D32 -> Image GrayScale D8
kittlerMeasure :: Image GrayScale D32 -> Float -> D32
betweenClassVariance :: Fractional a => [a] -> [a] -> a
instance MaxVal D8
instance MaxVal D32

module CV.Tracking
meanShift :: (BoundingBox a, Integral (ELBB a), ELBB a ~ Int) => Image GrayScale D32 -> a -> TermCriteria -> (Double, Rectangle Int)
snake :: Image c d -> [(Int, Int)] -> Float -> Float -> Float -> (CInt, CInt) -> C'CvTermCriteria -> Bool -> IO [C'CvPoint]

module CV.Video
newtype Capture
Capture :: (ForeignPtr (Capture)) -> Capture
withCapture :: Capture -> (Ptr Capture -> IO b) -> IO b
releaseCapture :: FinalizerPtr Capture
newtype VideoWriter
VideoWriter :: (ForeignPtr (VideoWriter)) -> VideoWriter
withVideoWriter :: VideoWriter -> (Ptr VideoWriter -> IO b) -> IO b
releaseVideoWriter :: FinalizerPtr VideoWriter
type VideoStream c d = Stream IO (Image c d)
streamFromVideo :: Capture -> Stream IO (Image RGB D32)
streamFromVideo' :: Image RGB D32 -> Capture -> Stream IO (Image RGB D32)
captureFromFile :: String -> IO Capture
captureFromCam :: Integral a => a -> IO (Maybe Capture)
dropFrame :: Capture -> IO ()
getFrame :: Capture -> IO (Maybe (Image RGB D32))
data CapProp
CAP_PROP_POS_MSEC :: CapProp
CAP_PROP_POS_FRAMES :: CapProp
CAP_PROP_POS_AVI_RATIO :: CapProp
CAP_PROP_FRAME_WIDTH :: CapProp
CAP_PROP_FRAME_HEIGHT :: CapProp
CAP_PROP_FPS :: CapProp
CAP_PROP_FOURCC :: CapProp
CAP_PROP_FRAME_COUNT :: CapProp
CAP_PROP_FORMAT :: CapProp
CAP_PROP_MODE :: CapProp
CAP_PROP_BRIGHTNESS :: CapProp
CAP_PROP_CONTRAST :: CapProp
CAP_PROP_SATURATION :: CapProp
CAP_PROP_HUE :: CapProp
CAP_PROP_GAIN :: CapProp
CAP_PROP_EXPOSURE :: CapProp
CAP_PROP_CONVERT_RGB :: CapProp
CAP_PROP_WHITE_BALANCE_BLUE_U :: CapProp
CAP_PROP_WHITE_BALANCE_RED_V :: CapProp
CAP_PROP_RECTIFICATION :: CapProp
CAP_PROP_MONOCROME :: CapProp
fromProp :: CapProp -> CInt
getCapProp :: Fractional b => Capture -> CapProp -> IO b
getFrameRate :: Fractional a => Capture -> a
getFrameSize :: (Integral t, Integral t1) => Capture -> (t, t1)
setCapProp :: Real a => Capture -> CapProp -> a -> IO CInt
numberOfFrames :: Integral a => Capture -> a
frameNumber :: Integral a => Capture -> a
data Codec
MPG4 :: Codec
createVideoWriter :: (Integral t, Integral t1) => String -> Codec -> CDouble -> (t, t1) -> IO VideoWriter
writeFrame :: VideoWriter -> Image RGB D32 -> IO ()
cvCreateFileCapture :: (Ptr CChar) -> (IO (Ptr (Capture)))
cvCreateCameraCapture :: CInt -> (IO (Ptr (Capture)))
cvGrabFrame :: (Ptr (Capture)) -> (IO CInt)
cvQueryFrame :: (Ptr (Capture)) -> (IO (Ptr (BareImage)))
cvGetCaptureProperty :: (Ptr (Capture)) -> (CInt -> (IO CDouble))
cvSetCaptureProperty :: (Ptr (Capture)) -> (CInt -> (CDouble -> (IO CInt)))
wrapCreateVideoWriter :: (Ptr CChar) -> (CInt -> (CDouble -> (CInt -> (CInt -> (CInt -> (IO (Ptr (VideoWriter))))))))
cvWriteFrame :: (Ptr (VideoWriter)) -> ((Ptr (BareImage)) -> (IO CInt))
instance Eq Codec
instance Show Codec
instance Enum CapProp

module CV.Projection
projectPolar :: Image c d -> Image GrayScale D32

module CV.Files
readFromTcr :: String -> Image GrayScale D32
readFromTcrRectified :: String -> Image GrayScale D32
readFromTcrMag :: String -> Image GrayScale D32
calcDerivativeDirection :: Image GrayScale D32 -> Image GrayScale D32
