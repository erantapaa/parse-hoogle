-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Hoodle file renderer
--   
--   Rendering library using cairo for hoodle file format
@package hoodle-render
@version 0.4


module Graphics.Hoodle.Render.Type.RenderCache

-- | hashmap: key = UUID, value = (original size, view size, surface)
type RenderCache = HashMap UUID (Double, Surface)


module Hoodle.Util.Process
checkPipe :: FilePath -> IO ()
mkTmpFileName :: IO FilePath
existThenRemove :: FilePath -> IO ()
pipeAction :: IO () -> (ByteString -> IO a) -> IO a
pipeActionWith :: IO () -> (FilePath -> IO a) -> IO a


-- | Renderable Item Type
module Graphics.Hoodle.Render.Type.Item
data RItem
RItemStroke :: (BBoxed Stroke) -> RItem
RItemImage :: (BBoxed Image) -> (Maybe Surface) -> RItem
RItemSVG :: (BBoxed SVG) -> (Maybe SVG) -> RItem
RItemLink :: (BBoxed Link) -> (Maybe SVG) -> RItem
RItemAnchor :: (BBoxed Anchor) -> (Maybe SVG) -> RItem
isStrkInRItem :: RItem -> Bool
isImgInRItem :: RItem -> Bool
isSVGInRItem :: RItem -> Bool
isLinkInRItem :: RItem -> Bool
isAnchorInRItem :: RItem -> Bool
findStrkInRItem :: RItem -> Maybe (BBoxed Stroke)
findImgInRItem :: RItem -> Maybe (BBoxed Image)
findSVGInRItem :: RItem -> Maybe (BBoxed SVG)
rItem2Item :: RItem -> Item
instance Show RItem
instance GetBBoxable RItem


module Graphics.Hoodle.Render.Type.Renderer
data PDFCommand
GetDocFromFile :: !ByteString -> TMVar (Maybe Document) -> PDFCommand
GetDocFromDataURI :: !ByteString -> TMVar (Maybe Document) -> PDFCommand
GetPageFromDoc :: !Document -> !Int -> TMVar (Maybe Page) -> PDFCommand
RenderPageScaled :: !Page -> !Dimension -> !Dimension -> PDFCommand
type Renderer = ReaderT ((UUID, (Double, Surface)) -> IO (), TVar (Seq (UUID, PDFCommand))) IO
sendPDFCommand :: UUID -> TVar (Seq (UUID, PDFCommand)) -> PDFCommand -> STM ()
instance Show PDFCommand


module Graphics.Hoodle.Render.Type.Background
data Context
Context :: ByteString -> ByteString -> Maybe Document -> Maybe Document -> Context
ctxt_domain :: Context -> ByteString
ctxt_filename :: Context -> ByteString
ctxt_doc :: Context -> Maybe Document
ctxt_embeddeddoc :: Context -> Maybe Document
data RBackground
RBkgSmpl :: ByteString -> ByteString -> UUID -> RBackground
rbkg_color :: RBackground -> ByteString
rbkg_style :: RBackground -> ByteString
rbkg_uuid :: RBackground -> UUID
RBkgPDF :: Maybe ByteString -> ByteString -> Int -> Maybe Page -> UUID -> RBackground
rbkg_domain :: RBackground -> Maybe ByteString
rbkg_filename :: RBackground -> ByteString
rbkg_pageno :: RBackground -> Int
rbkg_popplerpage :: RBackground -> Maybe Page
rbkg_uuid :: RBackground -> UUID
RBkgEmbedPDF :: Int -> Maybe Page -> UUID -> RBackground
rbkg_pageno :: RBackground -> Int
rbkg_popplerpage :: RBackground -> Maybe Page
rbkg_uuid :: RBackground -> UUID
isRBkgSmpl :: RBackground -> Bool
data RBkgOpt
RBkgDrawPDF :: RBkgOpt
RBkgDrawWhite :: RBkgOpt
RBkgDrawBuffer :: RBkgOpt
RBkgDrawPDFInBBox :: (Maybe BBox) -> RBkgOpt
rbkg2Bkg :: RBackground -> Background
instance Show RBackground


-- | Renderable Hoodle Type
module Graphics.Hoodle.Render.Type.Hoodle
newtype LyBuf
LyBuf :: (Maybe Surface) -> LyBuf

-- | normal rendering data structure for layer, R for rendering buffer is
--   Surface, container for item = list and StrokeBBox as contained items
type RLayer = GLayer LyBuf [] RItem

-- | normal rendering data structure for page background is RBackground and
--   container for layer is IntMap and layer is RLayer
type RPage = GPage RBackground ZipperSelect RLayer

-- | normal rendering data struture for hoodle container for page is IntMap
--   page is RPage
type RHoodle = GHoodle IntMap RPage
emptyRLayer :: RLayer

-- | project to simple Layer out of RLayer
rLayer2Layer :: RLayer -> Layer

-- | project to simple Page out of RPage
rPage2Page :: RPage -> Page

-- | project to simple Hoodle out of RHoodle
rHoodle2Hoodle :: RHoodle -> Hoodle
newtype InBBox a
InBBox :: a -> InBBox a
unInBBox :: InBBox a -> a
data InBBoxOption
InBBoxOption :: (Maybe BBox) -> InBBoxOption
newtype InBBoxBkgBuf a
InBBoxBkgBuf :: a -> InBBoxBkgBuf a
unInBBoxBkgBuf :: InBBoxBkgBuf a -> a
instance Show RHoodle


-- | utility
module Graphics.Hoodle.Render.Util
clipBBox :: Maybe BBox -> Render ()
clearBBox :: Maybe BBox -> Render ()


-- | Selection type
module Graphics.Hoodle.Render.Type.HitTest
data AlterList a b
Empty :: AlterList a b
(:-) :: a -> AlterList b a -> AlterList a b
newtype NotHitted a
NotHitted :: [a] -> NotHitted a
unNotHitted :: NotHitted a -> [a]
newtype Hitted a
Hitted :: [a] -> Hitted a
unHitted :: Hitted a -> [a]
type StrokeHitted = AlterList (NotHitted (BBoxed Stroke)) (Hitted (BBoxed Stroke))
type RItemHitted = AlterList (NotHitted RItem) (Hitted RItem)
fmapAL :: (a -> c) -> (b -> d) -> AlterList a b -> AlterList c d
getA :: AlterList a b -> [a]
getB :: AlterList a b -> [b]
interleave :: (a -> c) -> (b -> c) -> AlterList a b -> [c]
type TAlterHitted a = AlterList [a] (Hitted a)
newtype TEitherAlterHitted a
TEitherAlterHitted :: Either [a] (TAlterHitted a) -> TEitherAlterHitted a
unTEitherAlterHitted :: TEitherAlterHitted a -> Either [a] (TAlterHitted a)
takeHitted :: AlterList x (Hitted a) -> [a]
isAnyHitted :: AlterList x (Hitted a) -> Bool
takeFirstFromHitted :: RItemHitted -> RItemHitted
takeLastFromHitted :: RItemHitted -> RItemHitted
instance (Show a, Show b) => Show (AlterList a b)
instance Show a => Show (NotHitted a)
instance Functor NotHitted
instance Show a => Show (Hitted a)
instance Functor Hitted


-- | Hit-testing routines
module Graphics.Hoodle.Render.Util.HitTest

-- | hit test of whether a point in a bbox previously, hitTestBBoxPoint
isPointInBBox :: BBox -> (Double, Double) -> Bool

-- | hit test of whether two lines intersect
do2LinesIntersect :: ((Double, Double), (Double, Double)) -> ((Double, Double), (Double, Double)) -> Bool

-- | previously, hitTestLineStroke
doesLineHitStrk :: ((Double, Double), (Double, Double)) -> Stroke -> Bool

-- | Do two bounding boxes intersect with each other? previously,
--   hitTestBBoxBBox
do2BBoxIntersect :: BBox -> BBox -> Bool

-- | is the second bbox inside the first bbox? previously,
--   hitTestInsideBBox
isBBox2InBBox1 :: BBox -> BBox -> Bool
hltFilteredBy_StateT :: (a -> Bool) -> [a] -> State Bool (AlterList (NotHitted a) (Hitted a))

-- | highlight strokes filtered by a condition. previously mkHitTestAL
hltFilteredBy :: (a -> Bool) -> [a] -> AlterList (NotHitted a) (Hitted a)
hltHittedByBBox :: GetBBoxable a => BBox -> [a] -> AlterList (NotHitted a) (Hitted a)
hltEmbeddedByBBox :: GetBBoxable a => BBox -> [a] -> AlterList (NotHitted a) (Hitted a)

-- | only check if a line and bbox of item overlapped
hltHittedByLineRough :: GetBBoxable a => ((Double, Double), (Double, Double)) -> [a] -> AlterList (NotHitted a) (Hitted a)
hltItmsHittedByLine_StateT :: ((Double, Double), (Double, Double)) -> [RItem] -> State Bool RItemHitted
hltItmsHittedByLineFrmSelected_StateT :: ((Double, Double), (Double, Double)) -> RItemHitted -> State Bool (AlterList (NotHitted RItem) RItemHitted)
elimHitted :: GetBBoxable a => AlterList (NotHitted a) (Hitted a) -> State (Maybe BBox) [a]
merge :: Maybe BBox -> Maybe BBox -> Maybe BBox
getTotalBBox :: GetBBoxable a => [a] -> Maybe BBox


module Graphics.Hoodle.Render.Type.Select
type SLayerF a = GLayer (BufOf a) TEitherAlterHitted (ItmOf a)
data HLayersF s a
HLayersF :: SLayerF a -> s a -> HLayersF s a
hlyrt_selectedLayer :: HLayersF s a -> SLayerF a
hlyrt_otherLayers :: HLayersF s a -> s a
type HLayers = HLayersF ZipperSelect RLayer
type HLayer = SLayerF RLayer
selectedLayer :: Simple Lens HLayers HLayer
otherLayers :: Simple Lens HLayers (ZipperSelect RLayer)
type HPage = GPage RBackground (HLayersF ZipperSelect) RLayer
type HHoodle = GSelect (IntMap RPage) (Maybe (Int, HPage))
hLayer2RLayer :: HLayer -> RLayer
hPage2RPage :: HPage -> RPage
mkHPage :: RPage -> HPage


-- | Renderable Hoodle Type
module Graphics.Hoodle.Render.Type


-- | draw utility
module Graphics.Hoodle.Render.Primitive
drawStrokeCurve :: [Pair Double Double] -> Render ()
drawVWStrokeCurve :: [(Double, Double, Double)] -> Render ()


-- | collection of rendering routine that draws bounding box only
module Graphics.Hoodle.Render.Highlight
renderStrkHltd :: BBoxed Stroke -> Render ()

-- | render items highlighted
renderRItemHltd :: RItem -> Render ()
renderHltBBox :: BBox -> Render ()


-- | Rendering RItem
module Graphics.Hoodle.Render.Item

-- | construct renderable item
cnstrctRItem :: Item -> Renderer RItem

-- | get embedded png image. If not, just give me nothing.
getByteStringIfEmbeddedPNG :: ByteString -> Maybe ByteString

-- | read JPG file using GD library and create cairo image surface
--   currently, this uses temporary png file (which is potentially
--   dangerous)
getJPGandCreateSurface :: FilePath -> IO Surface
saveTempPNGToCreateSurface :: ByteString -> IO Surface


module Graphics.Hoodle.Render.Background
popplerGetDocFromFile :: ByteString -> IO (Maybe Document)
getByteStringIfEmbeddedPDF :: ByteString -> Maybe ByteString
popplerGetDocFromDataURI :: ByteString -> IO (Maybe Document)
popplerGetPageFromDoc :: Document -> Int -> IO (Maybe Page)

-- | draw ruling all
drawRuling :: Double -> Double -> ByteString -> Render ()

-- | draw ruling in bbox
drawRuling_InBBox :: BBox -> Double -> Double -> ByteString -> Render ()

-- | render background without any constraint
renderBkg :: (Background, Dimension) -> Render ()

-- | this has some bugs. need to fix
cnstrctRBkg_StateT :: Dimension -> Background -> StateT (Maybe Context) Renderer RBackground


-- | collection of rendering routine
module Graphics.Hoodle.Render
data Xform4Page
Xform4Page :: Double -> Double -> Double -> Double -> Xform4Page
transx :: Xform4Page -> Double
transy :: Xform4Page -> Double
scalex :: Xform4Page -> Double
scaley :: Xform4Page -> Double

-- | render stroke
renderStrk :: Stroke -> Render ()

-- | render image : not fully implemented
renderImg :: Image -> Render ()

-- | render background without any constraint
renderBkg :: (Background, Dimension) -> Render ()

-- | render item
renderItem :: Item -> Render ()
renderPage :: Page -> Render ()
renderRBkg :: RenderCache -> (RBackground, Dimension, Maybe Xform4Page) -> Render (RBackground, Dimension, Maybe Xform4Page)
renderRItem :: RenderCache -> RItem -> Render RItem

-- | render RLayer within BBox after hittest items
renderRLayer_InBBox :: RenderCache -> Maybe BBox -> RLayer -> Render RLayer

-- | background drawing in bbox
renderRBkg_InBBox :: RenderCache -> Maybe BBox -> (RBackground, Dimension, Maybe Xform4Page) -> Render (RBackground, Dimension, Maybe Xform4Page)

-- | Background rendering using buffer
renderRBkg_Buf :: RenderCache -> (RBackground, Dimension, Maybe Xform4Page) -> Render (RBackground, Dimension, Maybe Xform4Page)
renderRLayer_InBBoxBuf :: RenderCache -> Maybe BBox -> RLayer -> Render RLayer
updateLayerBuf :: RenderCache -> Dimension -> Maybe BBox -> RLayer -> IO RLayer
updatePageBuf :: RenderCache -> RPage -> IO RPage
updateHoodleBuf :: RenderCache -> RHoodle -> IO RHoodle
cnstrctRLayer :: Layer -> Renderer RLayer

-- | this has some bugs. need to fix
cnstrctRBkg_StateT :: Dimension -> Background -> StateT (Maybe Context) Renderer RBackground
cnstrctRPage_StateT :: Page -> StateT (Maybe Context) Renderer RPage
cnstrctRHoodle :: Hoodle -> Renderer RHoodle
instance Show Xform4Page


-- | collection of rendering routine
module Graphics.Hoodle.Render.Debug
renderRBkg_Dummy :: RenderCache -> (RBackground, Dimension, Maybe Xform4Page) -> Render ()

-- | render background without pdf
renderRBkg_NoPDF :: RenderCache -> (RBackground, Dimension, Maybe Xform4Page) -> Render ()

-- | render only bounding box of a StrokeBBox
renderStrkBBx_BBoxOnly :: BBoxed Stroke -> Render ()
renderImgBBx_BBoxOnly :: BBoxed Image -> Render ()
renderRItem_BBoxOnly :: RenderCache -> RItem -> Render ()
renderRLayer_BBoxOnly :: RenderCache -> RLayer -> Render ()

-- | render only bounding box of a StrokeBBox
renderRPage_BBoxOnly :: RenderCache -> RPage -> Render ()

-- | Background rendering using buffer
renderRBkg_Buf :: RenderCache -> (RBackground, Dimension, Maybe Xform4Page) -> Render (RBackground, Dimension, Maybe Xform4Page)
renderRLayer_InBBoxBuf :: RenderCache -> Maybe BBox -> RLayer -> Render RLayer


module Graphics.Hoodle.Render.Generic

-- | temporary util
passarg :: Monad m => (a -> m ()) -> a -> m a
class Renderable a
cairoRender :: Renderable a => RenderCache -> a -> Render a
class RenderOptionable a where type family RenderOption a :: *
cairoRenderOption :: RenderOptionable a => RenderOption a -> RenderCache -> a -> Render a
data StrokeBBoxOption
DrawFull :: StrokeBBoxOption
DrawBoxOnly :: StrokeBBoxOption
cairoOptionPage :: (RenderOptionable (b, Dimension, Maybe Xform4Page), RenderOptionable a, Foldable s) => (RenderOption (b, Dimension, Maybe Xform4Page), RenderOption a) -> RenderCache -> (GPage b s a, Maybe Xform4Page) -> Render (GPage b s a, Maybe Xform4Page)
instance RenderOptionable (InBBoxBkgBuf RPage, Maybe Xform4Page)
instance RenderOptionable (InBBox RPage, Maybe Xform4Page)
instance (RenderOptionable (b, Dimension, Maybe Xform4Page), RenderOptionable a, Foldable s) => RenderOptionable (GPage b s a, Maybe Xform4Page)
instance RenderOptionable (InBBox RLayer)
instance RenderOptionable RLayer
instance RenderOptionable (RBackground, Dimension, Maybe Xform4Page)
instance RenderOptionable (BBoxed Stroke)
instance RenderOptionable Stroke
instance RenderOptionable (Background, Dimension)
instance Renderable RLayer
instance Renderable (BBoxed Stroke)
instance Renderable Stroke
instance Renderable (Background, Dimension)
