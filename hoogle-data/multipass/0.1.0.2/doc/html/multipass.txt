-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Folding data with multiple named passes
--   
--   Folding data with multiple named passes
@package multipass
@version 0.1.0.2

module Data.Pass.Monoid.Ord
data Min a
Min :: a -> Min a
NoMin :: Min a
getMin :: Num a => Min a -> a
data Max a
Max :: a -> Max a
NoMax :: Max a
getMax :: Num a => Max a -> a
instance Typeable1 Min
instance Typeable1 Max
instance Ord a => Monoid (Max a)
instance Binary a => Binary (Max a)
instance Binary a => Binary (Min a)
instance Ord a => Monoid (Min a)

module Data.Pass.L.Estimator

-- | Techniques used to smooth the nearest values when calculating quantile
--   functions. R2 is used by default, and the numbering convention follows
--   the use in the R programming language, as far as it goes.
data Estimator

-- | Inverse of the empirical distribution function
R1 :: Estimator

-- | .. with averaging at discontinuities (default)
R2 :: Estimator

-- | The observation numbered closest to Np. NB: does not yield a proper
--   median
R3 :: Estimator

-- | Linear interpolation of the empirical distribution function. NB: does
--   not yield a proper median.
R4 :: Estimator

-- | .. with knots midway through the steps as used in hydrology. This is
--   the simplest continuous estimator that yields a correct median
R5 :: Estimator

-- | Linear interpolation of the expectations of the order statistics for
--   the uniform distribution on [0,1]
R6 :: Estimator

-- | Linear interpolation of the modes for the order statistics for the
--   uniform distribution on [0,1]
R7 :: Estimator

-- | Linear interpolation of the approximate medans for order statistics.
R8 :: Estimator

-- | The resulting quantile estimates are approximately unbiased for the
--   expected order statistics if x is normally distributed.
R9 :: Estimator

-- | When rounding h, this yields the order statistic with the least
--   expected square deviation relative to p.
R10 :: Estimator

-- | The Harrell-Davis quantile estimator based on bootstrapped order
--   statistics
HD :: Estimator
data Estimate r
Estimate :: {-# UNPACK #-} !Rational -> (IntMap r) -> Estimate r
estimateBy :: Fractional r => Estimator -> Rational -> Int -> Estimate r
instance Typeable Estimator
instance Eq Estimator
instance Ord Estimator
instance Enum Estimator
instance Bounded Estimator
instance Data Estimator
instance Show Estimator
instance Read Estimator
instance Show r => Show (Estimate r)
instance Hashable Estimator
instance Binary Estimator

module Data.Pass.L.By
class By k
by :: By k => k a b -> Estimator -> k a b

module Data.Pass.Trans
class Trans t
trans :: (Trans t, Binary b, Monoid b, Typeable b) => k a b -> t k a b

module Data.Pass.Named
class Typeable2 k => Named k where putFun xs = put $ showsFun 0 xs "" hashFunWithSalt n xs = n `hashWithSalt` runPut (putFun xs) equalFun xs ys = runPut (putFun xs) == runPut (putFun ys)
showsFun :: Named k => Int -> k a b -> String -> String
putFun :: Named k => k a b -> Put
hashFunWithSalt :: Named k => Int -> k a b -> Int
equalFun :: Named k => k a b -> k c d -> Bool

module Data.Pass.Eval.Naive
class Naive k
naive :: Naive k => k a b -> Int -> [a] -> b
(@@@) :: (Naive k, Foldable f) => k a b -> f a -> b

module Data.Pass.Eval
class Eval k
eval :: Eval k => k a b -> Int -> [a] -> b
(@@) :: (Eval k, Foldable f) => k a b -> f a -> b

module Data.Pass.L

-- | An L-Estimator represents a linear combination of order statistics
data L a b
LTotal :: L a a
LMean :: L a a
LScale :: L a a
NthLargest :: Int -> L a a
NthSmallest :: Int -> L a a
QuantileBy :: Estimator -> Rational -> L a a
Winsorized :: Rational -> L a b -> L a b
Trimmed :: Rational -> L a b -> L a b
Jackknifed :: L a b -> L a b
(:*) :: Rational -> L a b -> L a b
(:+) :: L a b -> L a b -> L a b
getL :: (Fractional a, Ord a) => Get (L a a)
callL :: L a b -> Int -> IntMap b
ordL :: L a b -> ((Ord b, Num b) => r) -> r
eqL :: L a b -> p a -> p b
selectM :: (Num a, Ord a) => IntMap a -> [a] -> a

-- | A common measure of how robust an L estimator is in the presence of
--   outliers.
breakdown :: (Num b, Eq b) => L a b -> Int

-- | <tt>f @# n</tt> Return a list of the coefficients that would be used
--   by an L-Estimator for an input of length <tt>n</tt>
(@#) :: Num a => L a a -> Int -> [a]
instance Typeable2 L
instance Eval L
instance Naive L
instance Eq (L a b)
instance Hashable (L a b)
instance Show (L a b)
instance Named L
instance By L

module Data.Pass.Call
class Named k => Call k
call :: Call k => k a b -> a -> b

module Data.Pass.Thrist
data Thrist k a b
Nil :: Thrist k a a
(:-) :: k b c -> Thrist k a b -> Thrist k a c
thrist :: k a b -> Thrist k a b
fromThrist :: Call k => (forall d e. k d e -> c) -> Thrist k a b -> [c]
instance Typeable2 k => Typeable2 (Thrist k)
instance Named k => Hashable (Thrist k a b)
instance Named k => Eq (Thrist k a b)
instance By k => By (Thrist k)
instance Call k => Call (Thrist k)
instance Named k => Named (Thrist k)
instance Category (Thrist k)
instance Trans Thrist
instance Named k => Show (Thrist k a b)

module Data.Pass.Prep
class Prep t
prep :: Prep t => k a b -> t k b c -> t k a c
instance Prep Thrist

module Data.Pass.Key
data Key k a
Key :: Thrist k a b -> Key k a
instance Named k => Show (Key k a)
instance Named k => Hashable (Key k a)
instance Named k => Eq (Key k a)

module Data.Pass.Fun
newtype Fun k a b
Fun :: k a b -> Fun k a b
unFun :: Fun k a b -> k a b
instance By k => By (Fun k)
instance Eval k => Eval (Fun k)
instance Naive k => Naive (Fun k)
instance Named k => Hashable (Fun k a b)
instance Named k => Eq (Fun k a b)
instance Call k => Call (Fun k)
instance Named k => Named (Fun k)
instance Typeable2 k => Typeable2 (Fun k)
instance Named k => Show (Fun k a b)
instance Trans Fun

module Data.Pass.Env
data Env k a
empty :: Env k a
lookup :: (Call k, Typeable b, Binary b, Monoid b) => Thrist k a b -> Env k a -> Maybe b
insert :: (Call k, Typeable b, Binary b, Monoid b) => Thrist k a b -> b -> Env k a -> Env k a
cons :: Call k => a -> Env k a -> Env k a
instance Show Fake
instance Named k => Show (Env k a)
instance Applicative Id
instance Functor Id

module Data.Pass.Type
data Pass k a b
Pass :: (m -> o) -> Thrist k i m -> Pass k i o
L :: (n -> o) -> L n n -> Thrist k i n -> Pass k i o
Ap :: (b -> c) -> Pass k i (a -> b) -> Pass k i a -> Pass k i c
Pure :: a -> Pass k i a
env :: Call k => Pass k a b -> Env k a
instance Call k => Eval (Pass k)
instance Call k => Naive (Pass k)
instance Floating b => Floating (Pass k a b)
instance Fractional b => Fractional (Pass k a b)
instance Num b => Num (Pass k a b)
instance Prep Pass
instance Typeable2 k => Typeable2 (Pass k)
instance Applicative (Pass k a)
instance Functor (Pass k a)
instance Trans Pass
instance By (Pass k)

module Data.Pass.Class
class Passable t
pass :: (Passable t, Eval k, Typeable b, Binary b, Monoid b) => t k a b -> Pass k a b
instance Passable Pass
instance Passable Thrist
instance Passable Fun

module Data.Pass.Calc
data Calc k a b
Stop :: b -> Calc k a b
(:&) :: Pass k a b -> (b -> Calc k a c) -> Calc k a c
Rank :: Thrist k a b -> ([Int] -> Calc k a c) -> Calc k a c
instance Call k => Eval (Calc k)
instance Call k => Naive (Calc k)
instance Trans Calc
instance Floating b => Floating (Calc k a b)
instance Fractional b => Fractional (Calc k a b)
instance Num b => Num (Calc k a b)
instance Prep Calc
instance Monad (Calc k a)
instance Applicative (Calc k a)
instance Functor (Calc k a)
instance By (Calc k)

module Data.Pass.Calculation
class Calculation t
calc :: (Calculation t, Eval k, Typeable b, Binary b, Monoid b) => t k a b -> Calc k a b
instance Calculation Calc
instance Calculation Pass
instance Calculation Thrist
instance Calculation Fun

module Data.Pass.Step
class Prep t => Step t
step :: Step t => Pass k a b -> t k a b
instance Step Calc
instance Step Pass

module Data.Pass.Robust

-- | embedding for L-estimators
class Robust l where winsorized p f = robust $ Winsorized p f trimmed p f = robust $ Trimmed p f jackknifed f = robust $ Jackknifed f lscale = robust LScale quantile p = robust $ QuantileBy R2 p midhinge = robust $ 0.5 :* (q1 :+ q3) trimean = robust $ 0.25 :* (q1 :+ 2 :* q2 :+ q3) iqr = robust $ ((- 1) :* q1) :+ q3 idr = robust $ ((- 1) :* quantile 0.1) :+ quantile 0.9
robust :: Robust l => L a b -> l a b
winsorized :: (Robust l, Fractional b, Ord b) => Rational -> L a b -> l a b
trimmed :: (Robust l, Fractional b, Ord b) => Rational -> L a b -> l a b
jackknifed :: (Robust l, Fractional b, Ord b) => L a b -> l a b
lscale :: (Robust l, Fractional a, Ord a) => l a a
quantile :: (Robust l, Fractional a, Ord a) => Rational -> l a a
midhinge :: (Robust l, Fractional a, Ord a) => l a a
trimean :: (Robust l, Fractional a, Ord a) => l a a
iqr :: (Robust l, Fractional a, Ord a) => l a a
idr :: (Robust l, Fractional a, Ord a) => l a a
median :: (Robust l, Fractional a, Ord a) => l a a

-- | interquartile mean
iqm :: (Robust l, Fractional a, Ord a) => l a a
idm :: (Robust l, Fractional a, Ord a) => l a a
tercile :: (Robust l, Fractional a, Ord a) => Rational -> l a a

-- | terciles 1 and 2
t1 :: (Robust l, Fractional a, Ord a) => l a a

-- | terciles 1 and 2
t2 :: (Robust l, Fractional a, Ord a) => l a a
quartile :: (Robust l, Fractional a, Ord a) => Rational -> l a a

-- | quantiles, with breakdown points 25%, 50%, and 25% respectively
q1 :: (Robust l, Fractional a, Ord a) => l a a

-- | quantiles, with breakdown points 25%, 50%, and 25% respectively
q2 :: (Robust l, Fractional a, Ord a) => l a a

-- | quantiles, with breakdown points 25%, 50%, and 25% respectively
q3 :: (Robust l, Fractional a, Ord a) => l a a
quintile :: (Robust l, Fractional a, Ord a) => Rational -> l a a

-- | quintiles 1 through 4
qu1 :: (Robust l, Fractional a, Ord a) => l a a

-- | quintiles 1 through 4
qu2 :: (Robust l, Fractional a, Ord a) => l a a

-- | quintiles 1 through 4
qu3 :: (Robust l, Fractional a, Ord a) => l a a

-- | quintiles 1 through 4
qu4 :: (Robust l, Fractional a, Ord a) => l a a
percentile :: (Robust l, Fractional a, Ord a) => Rational -> l a a
permille :: (Robust l, Fractional a, Ord a) => Rational -> l a a
instance Robust (Calc k)
instance Robust (Pass k)
instance Robust l => Robust (Fun l)
instance Robust L

module Data.Pass.Accelerant
class Accelerant k where meanPass = robust LMean totalPass = robust LTotal largestPass = robust $ NthLargest 0 smallestPass = robust $ NthSmallest 0 midrangePass = largestPass - smallestPass
meanPass :: Accelerant k => Pass k Double Double
totalPass :: Accelerant k => Pass k Double Double
largestPass :: Accelerant k => Pass k Double Double
smallestPass :: Accelerant k => Pass k Double Double
midrangePass :: Accelerant k => Pass k Double Double

module Data.Pass.Accelerated
class Accelerated k
mean :: Accelerated k => k Double Double
total :: Accelerated k => k Double Double
largest :: Accelerated k => k Double Double
smallest :: Accelerated k => k Double Double
midrange :: Accelerated k => k Double Double
instance Accelerant k => Accelerated (Pass k)
instance Accelerant k => Accelerated (Calc k)
instance Accelerated k => Accelerated (Thrist k)
instance Accelerated k => Accelerated (Fun k)
instance Accelerated L


module Data.Pass
class Eval k
eval :: Eval k => k a b -> Int -> [a] -> b
(@@) :: (Eval k, Foldable f) => k a b -> f a -> b
class Naive k
naive :: Naive k => k a b -> Int -> [a] -> b
(@@@) :: (Naive k, Foldable f) => k a b -> f a -> b
data Pass k a b
Pass :: (m -> o) -> Thrist k i m -> Pass k i o
L :: (n -> o) -> L n n -> Thrist k i n -> Pass k i o
Ap :: (b -> c) -> Pass k i (a -> b) -> Pass k i a -> Pass k i c
Pure :: a -> Pass k i a
class Passable t
pass :: (Passable t, Eval k, Typeable b, Binary b, Monoid b) => t k a b -> Pass k a b
class Prep t => Step t
step :: Step t => Pass k a b -> t k a b
data Calc k a b
Stop :: b -> Calc k a b
(:&) :: Pass k a b -> (b -> Calc k a c) -> Calc k a c
Rank :: Thrist k a b -> ([Int] -> Calc k a c) -> Calc k a c
class Calculation t
calc :: (Calculation t, Eval k, Typeable b, Binary b, Monoid b) => t k a b -> Calc k a b
class Prep t
prep :: Prep t => k a b -> t k b c -> t k a c

-- | An L-Estimator represents a linear combination of order statistics
data L a b
LTotal :: L a a
LMean :: L a a
LScale :: L a a
NthLargest :: Int -> L a a
NthSmallest :: Int -> L a a
QuantileBy :: Estimator -> Rational -> L a a
Winsorized :: Rational -> L a b -> L a b
Trimmed :: Rational -> L a b -> L a b
Jackknifed :: L a b -> L a b
(:*) :: Rational -> L a b -> L a b
(:+) :: L a b -> L a b -> L a b

-- | <tt>f @# n</tt> Return a list of the coefficients that would be used
--   by an L-Estimator for an input of length <tt>n</tt>
(@#) :: Num a => L a a -> Int -> [a]

-- | A common measure of how robust an L estimator is in the presence of
--   outliers.
breakdown :: (Num b, Eq b) => L a b -> Int

-- | interquartile mean
iqm :: (Robust l, Fractional a, Ord a) => l a a
idm :: (Robust l, Fractional a, Ord a) => l a a

-- | Techniques used to smooth the nearest values when calculating quantile
--   functions. R2 is used by default, and the numbering convention follows
--   the use in the R programming language, as far as it goes.
data Estimator

-- | Inverse of the empirical distribution function
R1 :: Estimator

-- | .. with averaging at discontinuities (default)
R2 :: Estimator

-- | The observation numbered closest to Np. NB: does not yield a proper
--   median
R3 :: Estimator

-- | Linear interpolation of the empirical distribution function. NB: does
--   not yield a proper median.
R4 :: Estimator

-- | .. with knots midway through the steps as used in hydrology. This is
--   the simplest continuous estimator that yields a correct median
R5 :: Estimator

-- | Linear interpolation of the expectations of the order statistics for
--   the uniform distribution on [0,1]
R6 :: Estimator

-- | Linear interpolation of the modes for the order statistics for the
--   uniform distribution on [0,1]
R7 :: Estimator

-- | Linear interpolation of the approximate medans for order statistics.
R8 :: Estimator

-- | The resulting quantile estimates are approximately unbiased for the
--   expected order statistics if x is normally distributed.
R9 :: Estimator

-- | When rounding h, this yields the order statistic with the least
--   expected square deviation relative to p.
R10 :: Estimator

-- | The Harrell-Davis quantile estimator based on bootstrapped order
--   statistics
HD :: Estimator
class By k
by :: By k => k a b -> Estimator -> k a b

-- | embedding for L-estimators
class Robust l where winsorized p f = robust $ Winsorized p f trimmed p f = robust $ Trimmed p f jackknifed f = robust $ Jackknifed f lscale = robust LScale quantile p = robust $ QuantileBy R2 p midhinge = robust $ 0.5 :* (q1 :+ q3) trimean = robust $ 0.25 :* (q1 :+ 2 :* q2 :+ q3) iqr = robust $ ((- 1) :* q1) :+ q3 idr = robust $ ((- 1) :* quantile 0.1) :+ quantile 0.9
robust :: Robust l => L a b -> l a b
winsorized :: (Robust l, Fractional b, Ord b) => Rational -> L a b -> l a b
trimmed :: (Robust l, Fractional b, Ord b) => Rational -> L a b -> l a b
jackknifed :: (Robust l, Fractional b, Ord b) => L a b -> l a b
lscale :: (Robust l, Fractional a, Ord a) => l a a
quantile :: (Robust l, Fractional a, Ord a) => Rational -> l a a
midhinge :: (Robust l, Fractional a, Ord a) => l a a
trimean :: (Robust l, Fractional a, Ord a) => l a a
iqr :: (Robust l, Fractional a, Ord a) => l a a
idr :: (Robust l, Fractional a, Ord a) => l a a
median :: (Robust l, Fractional a, Ord a) => l a a
tercile :: (Robust l, Fractional a, Ord a) => Rational -> l a a

-- | terciles 1 and 2
t1 :: (Robust l, Fractional a, Ord a) => l a a

-- | terciles 1 and 2
t2 :: (Robust l, Fractional a, Ord a) => l a a
quartile :: (Robust l, Fractional a, Ord a) => Rational -> l a a

-- | quantiles, with breakdown points 25%, 50%, and 25% respectively
q1 :: (Robust l, Fractional a, Ord a) => l a a

-- | quantiles, with breakdown points 25%, 50%, and 25% respectively
q2 :: (Robust l, Fractional a, Ord a) => l a a

-- | quantiles, with breakdown points 25%, 50%, and 25% respectively
q3 :: (Robust l, Fractional a, Ord a) => l a a
quintile :: (Robust l, Fractional a, Ord a) => Rational -> l a a

-- | quintiles 1 through 4
qu1 :: (Robust l, Fractional a, Ord a) => l a a

-- | quintiles 1 through 4
qu2 :: (Robust l, Fractional a, Ord a) => l a a

-- | quintiles 1 through 4
qu3 :: (Robust l, Fractional a, Ord a) => l a a

-- | quintiles 1 through 4
qu4 :: (Robust l, Fractional a, Ord a) => l a a
percentile :: (Robust l, Fractional a, Ord a) => Rational -> l a a
permille :: (Robust l, Fractional a, Ord a) => Rational -> l a a
class Accelerated k
mean :: Accelerated k => k Double Double
total :: Accelerated k => k Double Double
largest :: Accelerated k => k Double Double
smallest :: Accelerated k => k Double Double
midrange :: Accelerated k => k Double Double
data Thrist k a b
Nil :: Thrist k a a
(:-) :: k b c -> Thrist k a b -> Thrist k a c
thrist :: k a b -> Thrist k a b
class Trans t
trans :: (Trans t, Binary b, Monoid b, Typeable b) => k a b -> t k a b
class Named k => Call k
call :: Call k => k a b -> a -> b
class Typeable2 k => Named k where putFun xs = put $ showsFun 0 xs "" hashFunWithSalt n xs = n `hashWithSalt` runPut (putFun xs) equalFun xs ys = runPut (putFun xs) == runPut (putFun ys)
showsFun :: Named k => Int -> k a b -> String -> String
putFun :: Named k => k a b -> Put
hashFunWithSalt :: Named k => Int -> k a b -> Int
equalFun :: Named k => k a b -> k c d -> Bool
class Accelerant k where meanPass = robust LMean totalPass = robust LTotal largestPass = robust $ NthLargest 0 smallestPass = robust $ NthSmallest 0 midrangePass = largestPass - smallestPass
meanPass :: Accelerant k => Pass k Double Double
totalPass :: Accelerant k => Pass k Double Double
largestPass :: Accelerant k => Pass k Double Double
smallestPass :: Accelerant k => Pass k Double Double
midrangePass :: Accelerant k => Pass k Double Double
