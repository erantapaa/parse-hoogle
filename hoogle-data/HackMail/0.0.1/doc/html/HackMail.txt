-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A Procmail Replacement as Haskell EDSL
--   
--   A program for filtering/sorting email. Monadic EDSL for sorting,
--   supports multiple mail storage formats.
@package HackMail
@version 0.0.1


-- | Author : Joe Fredette License : BSD3 Copyright : Joe Fredette
--   
--   Maintainer : Joe Fredette <a>jfredett.at.gmail.dot.com</a> Stability :
--   Unstable Portability : Portable
module HackMail.Control.Checksum
checksum :: String -> String


-- | Author : Joe Fredette License : BSD3 Copyright : Joe Fredette
--   
--   Maintainer : Joe Fredette <a>jfredett.at.gmail.dot.com</a> Stability :
--   Unstable Portability : Portable
module HackMail.Data.ParseEmail
data Email
Email :: Header -> Body -> Email
data Header
HDR :: HeaderTok -> String -> Header -> Header
STOP :: Header
newtype Body
Body :: [String] -> Body
data HeaderTok
TO :: HeaderTok
DATE :: HeaderTok
FROM :: HeaderTok
SENDER :: HeaderTok
REPLYTO :: HeaderTok
CC :: HeaderTok
BCC :: HeaderTok
MESSAGEID :: HeaderTok
INREPLYTO :: HeaderTok
REFERENCES :: HeaderTok
SUBJECT :: HeaderTok
KEYWORDS :: HeaderTok
XFIELD :: String -> HeaderTok
parseEmail :: [Char] -> Either ParseError Email
parseEmailFromFile :: SourceName -> IO (Either ParseError Email)
matchHdr :: String -> HeaderTok
instance Typeable HeaderTok
instance Typeable Header
instance Typeable Body
instance Typeable Email
instance Eq HeaderTok
instance Read HeaderTok
instance Eq Header
instance Eq Body
instance Eq Email
instance Show HeaderTok
instance Show Header
instance Show Body
instance Show Email

module HackMail.Control.Misc
pairToList :: ([a], [a]) -> [a]
both :: (Arrow a) => a b c -> a (b, b) (c, c)
double :: (Arrow a) => a b c -> a b (c, c)
appBoth :: (a -> b, c -> d) -> a -> c -> (b, d)
appDouble :: (a -> b, a -> b) -> a -> (b, b)
maybeToBool :: Maybe a -> Bool
maybeOr :: Maybe a -> Maybe a -> Maybe (a, a)
maybeAnd :: Maybe a -> Maybe a -> Maybe (a, a)
maybeIf :: Maybe a -> Maybe a -> Maybe a -> Maybe a
instance Show (a -> b)


-- | Author : Joe Fredette License : BSD3 Copyright : Joe Fredette
--   
--   Maintainer : Joe Fredette <a>jfredett.at.gmail.dot.com</a> Stability :
--   Unstable Portability : Portable
module HackMail.Data.Email
writeEmail :: Email -> FilePath -> FilePath -> IO ()
emailChecksum :: Email -> String
grabTokValUnsafe :: Email -> HeaderTok -> String
grabTokVal :: Email -> HeaderTok -> Maybe String


-- | Author : Joe Fredette License : BSD3 Copyright : Joe Fredette
--   
--   Maintainer : Joe Fredette <a>jfredett.at.gmail.dot.com</a> Stability :
--   Unstable Portability : Not portable (*nix style only)
module HackMail.Data.Path
data Path
P :: VPath -> Bool -> Path
virtualPath :: Path -> VPath
relative :: Path -> Bool
data VPath
(:/:) :: VPath -> String -> VPath
Root :: VPath
parse :: FilePath -> Path
parseV :: FilePath -> VPath
splitOn :: (Eq a) => a -> [a] -> [[a]]
(+/+) :: Path -> Path -> Path
liftToPath1 :: (VPath -> VPath) -> Path -> Path
liftToPath2 :: (VPath -> VPath -> VPath) -> Path -> Path -> Path
pathExists :: Path -> IO Bool
mkDeliverablePath :: Path -> FileName -> FilePath
toFilePath :: Path -> FilePath
instance Eq VPath
instance Eq Path
instance Show Path
instance Show VPath


-- | Author : Joe Fredette License : BSD3 Copyright : Joe Fredette
--   
--   Maintainer : Joe Fredette <a>jfredett.at.gmail.dot.com</a> Stability :
--   Unstable Portability : Portable
module HackMail.Data.Deliverable

-- | The main class which abstracts over delivery of datatype to somewhere
--   in the file system. It also abstracts over construction. Due to some
--   weirdity w.r.t. Hint, this, and all instancing datatypes, must derive
--   Typeable. A bit of boilerplate, but deriving generally handles it
--   easily.
class (Typeable a) => Deliverable a
deliverIO :: (Deliverable a) => a -> IO ()
construct :: (Deliverable a) => Email -> Path -> a
data DEMail
DE :: Email -> Path -> DEMail
email :: DEMail -> Email
path :: DEMail -> Path
newtype FlatEmail
Flat :: DEMail -> FlatEmail
newtype MaildirEmail
MD :: DEMail -> MaildirEmail
getDeliveryPath :: DEMail -> FilePath
data ToDelivery
Wrap :: a -> ToDelivery
delivery :: ToDelivery -> IO ()
instance Typeable ToDelivery
instance Typeable MaildirEmail
instance Typeable FlatEmail
instance Typeable DEMail
instance Show MaildirEmail
instance Eq MaildirEmail
instance Show FlatEmail
instance Eq FlatEmail
instance Eq DEMail
instance Show DEMail
instance Deliverable MaildirEmail
instance Deliverable FlatEmail

module HackMail.Data.MainTypes
data Options
Opt :: Bool -> Maybe FilePath -> Maybe FilePath -> Options
daemonMode :: Options -> Bool
incomingMailLoc :: Options -> Maybe FilePath
altFMainLoc :: Options -> Maybe FilePath
getOpts :: [String] -> Options

-- | A type mostly used in Hackmain.hs, stores some information about
--   paths. Only here to avoid nasty mutually recursive modules. (TODO:
--   Move this and associated functions another module?)
data Config
Conf :: Path -> FilePath -> Filter () -> Config
inboxLoc :: Config -> Path
filterMainLoc :: Config -> FilePath
filterMain :: Config -> Filter ()

-- | A simple type to contain the email context. May become bigger, to
--   store configuration details, etc.
newtype Filter a
Filter :: (ReaderT (Config, Email) IO a) -> Filter a
runFilter :: Filter a -> (Config, Email) -> IO a
instance Typeable1 Filter
instance Typeable Config
instance Monad Filter
instance Functor Filter
instance MonadReader (Config, Email) Filter
instance MonadIO Filter
instance Eq Options
instance Show Options
instance (Show a) => Show (SortOpt a)
instance Show Config

module HackMail.Data.FilterConf

module HackMail.Control.DaemonMode


-- | Author : Joe Fredette License : BSD3 Copyright : Joe Fredette
--   
--   Maintainer : Joe Fredette <a>jfredett.at.gmail.dot.com</a> Stability :
--   Unstable Portability : not portable
module HackMail.Hackmain
configFolderPathIO :: IO FilePath
pipe_mode :: Options -> Config -> IO ()
daemon_mode :: Options -> Config -> IO ()
buildConf :: IO Config
getFilterMainStuff :: FilePath -> Interpreter (Path, Filter ())
getExt :: Bool -> Bool -> ((a, a) -> a)
runUnsafeInterpreter :: Interpreter a -> IO a
