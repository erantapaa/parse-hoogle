-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | fast ByteString to number converting library
--   
@package bytestring-read
@version 0.3.1

module Data.ByteString.Read.Class
class (Fractional a, Num (Fraction a), Ord (Fraction a)) => ReadFractional a where data family Fraction a
maxValue :: ReadFractional a => proxy a -> Maybe (Fraction a)
fromFraction :: (ReadFractional a, Num b) => Fraction a -> b
class KnownNat n => Radix n
isDigit :: Radix n => proxy n -> Word8 -> Bool
unsafeToDigit :: Radix n => proxy n -> Word8 -> Word8
class Source a
null :: Source a => a -> Bool
empty :: Source a => a
head :: Source a => a -> Word8
tail :: Source a => a -> a
instance Eq (Fraction Rational)
instance Ord (Fraction Rational)
instance Num (Fraction Rational)
instance Eq (Fraction Double)
instance Ord (Fraction Double)
instance Num (Fraction Double)
instance Eq (Fraction Float)
instance Ord (Fraction Float)
instance Num (Fraction Float)
instance Source ByteString
instance Source ByteString
instance Radix 36
instance Radix 35
instance Radix 34
instance Radix 33
instance Radix 32
instance Radix 31
instance Radix 30
instance Radix 29
instance Radix 28
instance Radix 27
instance Radix 26
instance Radix 25
instance Radix 24
instance Radix 23
instance Radix 22
instance Radix 21
instance Radix 20
instance Radix 19
instance Radix 18
instance Radix 17
instance Radix 16
instance Radix 15
instance Radix 14
instance Radix 13
instance Radix 12
instance Radix 11
instance Radix 10
instance Radix 9
instance Radix 8
instance Radix 7
instance Radix 6
instance Radix 5
instance Radix 4
instance Radix 3
instance Radix 2
instance ReadFractional Rational
instance ReadFractional Double
instance ReadFractional Float

module Data.ByteString.Read.Integral

-- | convert bytestring into unsigned integral using radix
--   
--   <pre>
--   &gt;&gt;&gt; integral' (Proxy :: Proxy 10) "12345" :: Maybe (Int, S.ByteString)
--   Just (12345,"")
--   
--   &gt;&gt;&gt; integral' (Proxy :: Proxy 2) "10112" :: Maybe (Int, L.ByteString)
--   Just (11,"2")
--   
--   &gt;&gt;&gt; integral' (Proxy :: Proxy 36) "Z" :: Maybe (Double, S.ByteString)
--   Just (35.0,"")
--   </pre>
integral' :: (Radix b, Num n, Source s) => proxy b -> s -> Maybe (n, s)

-- | <pre>
--   integral = <a>integral'</a> (Proxy :: Proxy 10)
--   </pre>
integral :: (Num n, Source s) => s -> Maybe (n, s)

-- | <pre>
--   int = integral
--   </pre>
int :: Source s => s -> Maybe (Int, s)

module Data.ByteString.Read.Fractional

-- | convert bytestring into unsigned fractional using radix.
--   
--   this function can parse
--   
--   <ul>
--   <li>oct/hexa-decimal (0o,0O,0x,0X) (optional)</li>
--   <li>fractional(0.1, 12224.3543)</li>
--   <li>exponential (e1, E+2, e-123) (10-radixed only, optional)</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; fractional "12.4" :: Maybe (Double, S.ByteString)
--   Just (12.4,"")
--   
--   &gt;&gt;&gt; fractional "1.23e12" :: Maybe (Double, L.ByteString)
--   Just (1.23e12,"")
--   
--   &gt;&gt;&gt; fractional "0o0.4" :: Maybe (Double, S.ByteString)
--   Just (0.5,"")
--   
--   &gt;&gt;&gt; fractional "0x3f.12" :: Maybe (Double, L.ByteString)
--   Just (63.0703125,"")
--   </pre>
fractional :: (ReadFractional r, Source s) => s -> Maybe (r, s)

-- | <pre>
--   double = fractional
--   </pre>
double :: Source s => s -> Maybe (Double, s)

-- | convert bytestring into unsigned fractional using radix.
--   
--   this function can parse
--   
--   <ul>
--   <li>fractional(0.1, 12224.3543)</li>
--   <li>exponential (e1, E+2, e-123) (optional)</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; fractional10 "12.5" :: Maybe (Double, S.ByteString)
--   Just (12.5,"")
--   
--   &gt;&gt;&gt; fractional10 "124.1e12" :: Maybe (Double, L.ByteString)
--   Just (1.241e14,"")
--   
--   &gt;&gt;&gt; fractional10 "12.5e-3" :: Maybe (Double, S.ByteString)
--   Just (1.25e-2,"")
--   
--   &gt;&gt;&gt; fractional10 "3.11e+3" :: Maybe (Double, L.ByteString)
--   Just (3110.0,"")
--   </pre>
fractional10 :: (ReadFractional r, Source s) => s -> Maybe (r, s)

-- | convert bytestring into unsigned fractional using radix.
--   
--   this function can parse
--   
--   <ul>
--   <li>fractional(0.1, 12224.3543)</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; fractional' (Proxy :: Proxy 36) "12z" :: Maybe (Double, S.ByteString)
--   Just (1403.0,"")
--   
--   &gt;&gt;&gt; fractional' (Proxy :: Proxy 2) "1012" :: Maybe (Double, L.ByteString)
--   Just (5.0,"2")
--   
--   &gt;&gt;&gt; fractional' (Proxy :: Proxy 10) "a12" :: Maybe (Double, S.ByteString)
--   Nothing
--   </pre>
fractional' :: (Radix b, ReadFractional r, Source s) => proxy b -> s -> Maybe (r, s)

module Data.ByteString.Read.DEPRECATED

-- | <i>Deprecated: use ReadFractional</i>
type EffectiveDigit = ReadFractional

-- | <i>Deprecated: use fractional</i>
floating :: EffectiveDigit r => ByteString -> Maybe (r, ByteString)

-- | <i>Deprecated: use Radix</i>
type Base = Radix

-- | <i>Deprecated: use fractional10</i>
floating10 :: EffectiveDigit r => ByteString -> Maybe (r, ByteString)

-- | <i>Deprecated: use floating'</i>
floating' :: (Base b, EffectiveDigit r) => proxy b -> ByteString -> Maybe (r, ByteString)

module Data.ByteString.Read
class Source a
class (Fractional a, Num (Fraction a), Ord (Fraction a)) => ReadFractional a

-- | convert bytestring into unsigned fractional using radix.
--   
--   this function can parse
--   
--   <ul>
--   <li>oct/hexa-decimal (0o,0O,0x,0X) (optional)</li>
--   <li>fractional(0.1, 12224.3543)</li>
--   <li>exponential (e1, E+2, e-123) (10-radixed only, optional)</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; fractional "12.4" :: Maybe (Double, S.ByteString)
--   Just (12.4,"")
--   
--   &gt;&gt;&gt; fractional "1.23e12" :: Maybe (Double, L.ByteString)
--   Just (1.23e12,"")
--   
--   &gt;&gt;&gt; fractional "0o0.4" :: Maybe (Double, S.ByteString)
--   Just (0.5,"")
--   
--   &gt;&gt;&gt; fractional "0x3f.12" :: Maybe (Double, L.ByteString)
--   Just (63.0703125,"")
--   </pre>
fractional :: (ReadFractional r, Source s) => s -> Maybe (r, s)

-- | <pre>
--   double = fractional
--   </pre>
double :: Source s => s -> Maybe (Double, s)

-- | <pre>
--   integral = <a>integral'</a> (Proxy :: Proxy 10)
--   </pre>
integral :: (Num n, Source s) => s -> Maybe (n, s)

-- | <pre>
--   int = integral
--   </pre>
int :: Source s => s -> Maybe (Int, s)

-- | convert unsigned parser to signed parser.
--   
--   this function can parse
--   
--   <ul>
--   <li>sign (+, -) (optional)</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; signed double ("12.4" :: S.ByteString)
--   Just (12.4,"")
--   
--   &gt;&gt;&gt; signed double ("-3.21e3" :: L.ByteString)
--   Just (-3210.0,"")
--   
--   &gt;&gt;&gt; signed double ("+0x1f.4" :: S.ByteString)
--   Just (31.25,"")
--   </pre>
signed :: (Source s, Num r) => (s -> Maybe (r, s)) -> s -> Maybe (r, s)
