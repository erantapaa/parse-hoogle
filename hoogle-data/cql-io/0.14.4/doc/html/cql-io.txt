-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Cassandra CQL client.
--   
@package cql-io
@version 0.14.4


-- | This driver operates on some state which must be initialised prior to
--   executing client operations and terminated eventually. The library
--   uses <a>tinylog</a> for its logging output and expects a
--   <tt>Logger</tt>.
--   
--   For example:
--   
--   <pre>
--   &gt; import Data.Text (Text)
--   &gt; import Data.Functor.Identity
--   &gt; import Database.CQL.IO as Client
--   &gt; import Database.CQL.Protocol
--   &gt; import qualified System.Logger as Logger
--   &gt;
--   &gt; g &lt;- Logger.new Logger.defSettings
--   &gt; c &lt;- Client.init g defSettings
--   &gt; let p = QueryParams One False () Nothing Nothing Nothing
--   &gt; runClient c $ query ("SELECT cql_version from system.local" :: QueryString R () (Identity Text)) p
--   [Identity "3.2.0"]
--   &gt; shutdown c
--   </pre>
--   
--   <b>Note on prepared statements</b>
--   
--   Prepared statements are fully supported but imply certain complexities
--   which lead to some assumptions beyond the scope of the CQL binary
--   protocol specification (spec):
--   
--   <ol>
--   <li>The spec scopes the <a>QueryId</a> to the node the query has been
--   prepared with. The spec does not state anything about the format of
--   the <a>QueryId</a>, however it seems that at least the official Java
--   driver assumes that any given <a>QueryString</a> yields the same
--   <a>QueryId</a> on every node. We make the same assumption.</li>
--   <li>In case a node does not know a given <a>QueryId</a> an
--   <a>Unprepared</a> error is returned. We assume that it is always safe
--   to then transparently re-prepare the corresponding <a>QueryString</a>
--   and to re-execute the original request against the same node.</li>
--   </ol>
--   
--   Besides these assumptions there is also a potential tradeoff in
--   regards to <i>eager</i> vs. <i>lazy</i> query preparation. We
--   understand <i>eager</i> to mean preparation against all current nodes
--   of a cluster and <i>lazy</i> to mean preparation against a single node
--   if required, i.e. after an <a>Unprepared</a> error response. Which
--   strategy to choose depends on the scope of query reuse and the size of
--   the cluster. The global default can be changed through the
--   <a>Settings</a> module and per action using
--   <a>withPrepareStrategy</a>.
module Database.CQL.IO
data Settings
data PrepareStrategy

-- | cluster-wide preparation
EagerPrepare :: PrepareStrategy

-- | on-demand per node preparation
LazyPrepare :: PrepareStrategy

-- | Default settings:
--   
--   <ul>
--   <li>contact point is "localhost" port 9042</li>
--   <li>load-balancing policy is <a>random</a></li>
--   <li>binary protocol version is 3 (supported by Cassandra &gt;=
--   2.1.0)</li>
--   <li>connection idle timeout is 60s</li>
--   <li>the connection pool uses 4 stripes to mitigate thread
--   contention</li>
--   <li>connections use a connect timeout of 5s, a send timeout of 3s and
--   a receive timeout of 10s</li>
--   <li>128 streams per connection are used</li>
--   <li>16k receive buffer size</li>
--   <li>no compression is applied to frame bodies</li>
--   <li>no default keyspace is used.</li>
--   <li>no retries are done</li>
--   <li>lazy prepare strategy</li>
--   </ul>
defSettings :: Settings

-- | Add an additional host to the contact list.
addContact :: String -> Settings -> Settings

-- | Set the compression to use for frame body compression.
setCompression :: Compression -> Settings -> Settings

-- | Set the connect timeout of a connection.
setConnectTimeout :: NominalDiffTime -> Settings -> Settings

-- | Set the initial contact points (hosts) from which node discovery will
--   start.
setContacts :: String -> [String] -> Settings -> Settings

-- | Set the connection idle timeout. Connections in a pool will be closed
--   if not in use for longer than this timeout.
setIdleTimeout :: NominalDiffTime -> Settings -> Settings

-- | Set the default keyspace to use. Every new connection will be
--   initialised to use this keyspace.
setKeyspace :: Keyspace -> Settings -> Settings

-- | Maximum connections per pool <i>stripe</i>.
setMaxConnections :: Int -> Settings -> Settings

-- | Set the maximum number of streams per connection. In version 2 of the
--   binary protocol at most 128 streams can be used. Version 3 supports up
--   to 32768 streams.
setMaxStreams :: Int -> Settings -> Settings

-- | When receiving a response times out, we can no longer use the stream
--   of the connection that was used to make the request as it is uncertain
--   if a response will arrive later. Thus the bandwith of a connection
--   will be decreased. This settings defines a threshold after which we
--   close the connection to get a new one with all streams available.
setMaxTimeouts :: Int -> Settings -> Settings

-- | Set the load-balancing policy.
setPolicy :: IO Policy -> Settings -> Settings

-- | Set the number of pool stripes to use. A good setting is equal to the
--   number of CPU cores this codes is running on.
setPoolStripes :: Int -> Settings -> Settings

-- | Set the portnumber to use to connect on <i>every</i> node of the
--   cluster.
setPortNumber :: PortNumber -> Settings -> Settings

-- | Set strategy to use for preparing statements.
setPrepareStrategy :: PrepareStrategy -> Settings -> Settings

-- | Set the binary protocol version to use.
setProtocolVersion :: Version -> Settings -> Settings

-- | Set the receive timeout of a connection. Requests exceeding the
--   receive timeout will fail with a <tt>Timeout</tt> exception.
setResponseTimeout :: NominalDiffTime -> Settings -> Settings

-- | Set the send timeout of a connection. Request exceeding the send will
--   cause the connection to be closed and fail with
--   <tt>ConnectionClosed</tt> exception.
setSendTimeout :: NominalDiffTime -> Settings -> Settings

-- | Set default retry settings to use.
setRetrySettings :: RetrySettings -> Settings -> Settings

-- | Set maximum receive buffer size.
--   
--   The actual buffer size used will be the minimum of the CQL response
--   size and the value set here.
setMaxRecvBuffer :: Int -> Settings -> Settings
data RetrySettings

-- | Never retry.
noRetry :: RetrySettings

-- | Forever retry immediately.
retryForever :: RetrySettings

-- | Limit number of retries.
maxRetries :: Word -> RetrySettings -> RetrySettings

-- | When retrying a (batch-) query, change consistency to the given value.
adjustConsistency :: Consistency -> RetrySettings -> RetrySettings

-- | Wait a constant time between retries.
constDelay :: NominalDiffTime -> RetrySettings -> RetrySettings

-- | Delay retries with exponential backoff.
expBackoff :: NominalDiffTime -> NominalDiffTime -> RetrySettings -> RetrySettings

-- | Delay retries using Fibonacci sequence as backoff.
fibBackoff :: NominalDiffTime -> NominalDiffTime -> RetrySettings -> RetrySettings

-- | On retry adjust the send timeout.
adjustSendTimeout :: NominalDiffTime -> RetrySettings -> RetrySettings

-- | On retry adjust the response timeout.
adjustResponseTimeout :: NominalDiffTime -> RetrySettings -> RetrySettings

-- | A type which can run a query against Cassandra.
class RunQ q
runQ :: (RunQ q, MonadClient m, Tuple a, Tuple b) => q k a b -> QueryParams a -> m (Response k a b)

-- | The Client monad.
--   
--   A simple reader monad around some internal state. Prior to executing
--   this monad via <a>runClient</a>, its state must be initialised through
--   <a>init</a> and after finishing operation it should be terminated with
--   <a>shutdown</a>.
--   
--   Actual CQL queries are handled by invoking <a>request</a>.
--   Additionally <a>debugInfo</a> returns an internal cluster view.
data Client a

-- | Monads in which <a>Client</a> actions may be embedded.
class (Functor m, Applicative m, Monad m, MonadIO m, MonadCatch m) => MonadClient m
liftClient :: MonadClient m => Client a -> m a
localState :: MonadClient m => (ClientState -> ClientState) -> m a -> m a

-- | Opaque client state/environment.
data ClientState
data DebugInfo
DebugInfo :: String -> [InetAddr] -> [Host] -> DebugInfo

-- | <a>Policy</a> string representation
policyInfo :: DebugInfo -> String

-- | hosts currently checked for reachability
jobInfo :: DebugInfo -> [InetAddr]

-- | all known hosts
hostInfo :: DebugInfo -> [Host]

-- | Initialise client state with the given <a>Settings</a> using the
--   provided <a>Logger</a> for all it's logging output.
init :: MonadIO m => Logger -> Settings -> m ClientState

-- | Execute the client monad.
runClient :: MonadIO m => ClientState -> Client a -> m a

-- | Use given <a>RetrySettings</a> during execution of some client action.
retry :: MonadClient m => RetrySettings -> m a -> m a

-- | Terminate client state, i.e. end all running background checks and
--   shutdown all connection pools. Once this is entered, the client will
--   eventually be shut down, though an asynchronous exception can
--   interrupt the wait for that to occur.
shutdown :: MonadIO m => ClientState -> m ()
debugInfo :: MonadClient m => m DebugInfo

-- | Run a CQL read-only query against a Cassandra node.
query :: (MonadClient m, Tuple a, Tuple b, RunQ q) => q R a b -> QueryParams a -> m [b]

-- | Run a CQL read-only query against a Cassandra node.
query1 :: (MonadClient m, Tuple a, Tuple b, RunQ q) => q R a b -> QueryParams a -> m (Maybe b)

-- | Run a CQL insert/update query against a Cassandra node.
write :: (MonadClient m, Tuple a, RunQ q) => q W a () -> QueryParams a -> m ()

-- | Run a CQL schema query against a Cassandra node.
schema :: (MonadClient m, Tuple a, RunQ q) => q S a () -> QueryParams a -> m (Maybe SchemaChange)

-- | Return value of <a>paginate</a>. Contains the actual result values as
--   well as an indication of whether there is more data available and the
--   actual action to fetch the next page.
data Page a
Page :: !Bool -> [a] -> Client (Page a) -> Page a
hasMore :: Page a -> !Bool
result :: Page a -> [a]
nextPage :: Page a -> Client (Page a)

-- | A page with an empty result list.
emptyPage :: Page a

-- | Run a CQL read-only query against a Cassandra node.
--   
--   This function is like <a>query</a>, but limits the result size to
--   10000 (default) unless there is an explicit size restriction given in
--   <a>QueryParams</a>. The returned <a>Page</a> can be used to continue
--   the query.
--   
--   Please note that -- as of Cassandra 2.1.0 -- if your requested page
--   size is equal to the result size, <a>hasMore</a> might be true and a
--   subsequent <a>nextPage</a> will return an empty list in <a>result</a>.
paginate :: (MonadClient m, Tuple a, Tuple b, RunQ q) => q R a b -> QueryParams a -> m (Page b)

-- | Representation of a prepared query. Actual preparation is handled
--   transparently by the driver.
data PrepQuery k a b
prepared :: QueryString k a b -> PrepQuery k a b
queryString :: PrepQuery k a b -> QueryString k a b

-- | <a>Batch</a> construction monad.
data BatchM a

-- | Add a query to this batch.
addQuery :: (Show a, Tuple a, Tuple b) => QueryString W a b -> a -> BatchM ()

-- | Add a prepared query to this batch.
addPrepQuery :: (Show a, Tuple a, Tuple b) => PrepQuery W a b -> a -> BatchM ()

-- | Set the type of this batch.
setType :: BatchType -> BatchM ()

-- | Set <a>Batch</a> consistency level.
setConsistency :: Consistency -> BatchM ()

-- | Set <a>Batch</a> serial consistency.
setSerialConsistency :: SerialConsistency -> BatchM ()

-- | Run a batch query against a Cassandra node.
batch :: MonadClient m => BatchM () -> m ()

-- | Send a CQL <a>Request</a> to the server and return a <a>Response</a>.
--   
--   This function will first ask the clients load-balancing <a>Policy</a>
--   for some host and use its connection pool to acquire a connection for
--   request transmission.
--   
--   If all available hosts are busy (i.e. their connection pools are fully
--   utilised), the function will block until a connection becomes
--   available or the maximum wait-queue length has been reached.
request :: (MonadClient m, Tuple a, Tuple b) => Request k a b -> m (Response k a b)

-- | A policy defines a load-balancing strategy and generally handles host
--   visibility.
data Policy
Policy :: ([Host] -> [Host] -> IO ()) -> (HostEvent -> IO ()) -> IO (Maybe Host) -> IO [Host] -> (Host -> IO Bool) -> IO Word -> IO String -> Policy

-- | Initialise the policy with two sets of hosts. The first parameter are
--   hosts known to be available, the second are other nodes. Please note
--   that a policy may be re-initialised at any point through this method.
setup :: Policy -> [Host] -> [Host] -> IO ()

-- | Event handler. Policies will be informed about cluster changes through
--   this function.
onEvent :: Policy -> HostEvent -> IO ()

-- | Host selection. The driver will ask for a host to use in a query
--   through this function. A policy which has no available nodes my return
--   Nothing.
select :: Policy -> IO (Maybe Host)

-- | Return all currently alive hosts.
current :: Policy -> IO [Host]

-- | During startup and node discovery, the driver will ask the policy if a
--   dicovered host should be ignored.
acceptable :: Policy -> Host -> IO Bool

-- | During query processing, the driver will ask the policy for a rough
--   esitimate of alive hosts. The number is used to repeatedly invoke
--   <a>select</a> (with the underlying assumption that the policy returns
--   mostly different hosts).
hostCount :: Policy -> IO Word

-- | Like having an effectful <a>Show</a> instance for this policy.
display :: Policy -> IO String

-- | Return hosts in random order.
random :: IO Policy

-- | Iterate over hosts one by one.
roundRobin :: IO Policy

-- | Host representation.
data Host

-- | This event will be passed to a <tt>Policy</tt> to inform it about
--   cluster changes.
data HostEvent

-- | a new host has been added to the cluster
HostNew :: !Host -> HostEvent

-- | a host has been removed from the cluster
HostGone :: !InetAddr -> HostEvent

-- | a host has been started
HostUp :: !InetAddr -> HostEvent

-- | a host has been stopped
HostDown :: !InetAddr -> HostEvent
newtype InetAddr
InetAddr :: SockAddr -> InetAddr
sockAddr :: InetAddr -> SockAddr

-- | The IP address and port number of this host.
hostAddr :: Lens' Host InetAddr

-- | The data centre name (may be an empty string).
dataCentre :: Lens' Host Text

-- | The rack name (may be an empty string).
rack :: Lens' Host Text
data InvalidSettings
UnsupportedCompression :: [CompressionAlgorithm] -> InvalidSettings
InvalidCacheSize :: InvalidSettings
newtype InternalError
InternalError :: String -> InternalError
data HostError
NoHostAvailable :: HostError
HostsBusy :: HostError
data ConnectionError
ConnectionClosed :: !InetAddr -> ConnectionError
ConnectTimeout :: !InetAddr -> ConnectionError
data UnexpectedResponse
UnexpectedResponse :: UnexpectedResponse
UnexpectedResponse' :: !(Response k a b) -> UnexpectedResponse
newtype Timeout
TimeoutRead :: String -> Timeout
data HashCollision
HashCollision :: !Text -> !Text -> HashCollision
instance Functor Page
instance RunQ PrepQuery
instance RunQ QueryString
