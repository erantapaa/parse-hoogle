-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Utilities for Data.Lens
--   
@package data-lens-template
@version 2.1.9


-- | This module provides an automatic Template Haskell routine to scour
--   data type definitions and generate accessor objects for them
--   automatically.
module Data.Lens.Template

-- | <tt>nameMakeLens n f</tt> where <tt>n</tt> is the name of a data type
--   declared with <tt>data</tt> and <tt>f</tt> is a function from names of
--   fields in that data type to the name of the corresponding accessor. If
--   <tt>f</tt> returns <tt>Nothing</tt>, then no accessor is generated for
--   that field.
nameMakeLens :: Name -> (String -> Maybe String) -> Q [Dec]

-- | <tt>makeLenses n</tt> where <tt>n</tt> is the name of a data type
--   declared with <tt>data</tt> looks through all the declared fields of
--   the data type, and for each field beginning with an underscore
--   generates an accessor of the same name without the underscore.
--   
--   It is "nameMakeLens" n f where <tt>f</tt> satisfies
--   
--   <pre>
--   f ('_' : s) = Just s
--   f x = Nothing -- otherwise
--   </pre>
--   
--   For example, given the data type:
--   
--   <pre>
--   data Score = Score { 
--     _p1Score :: Int
--   , _p2Score :: Int
--   , rounds :: Int
--   }
--   </pre>
--   
--   <tt>makeLenses</tt> will generate the following objects:
--   
--   <pre>
--   p1Score :: Lens Score Int
--   p1Score = lens _p1Score (\x s -&gt; s { _p1Score = x })
--   p2Score :: Lens Score Int
--   p2Score = lens _p2Score (\x s -&gt; s { _p2Score = x })
--   </pre>
--   
--   It is used with Template Haskell syntax like:
--   
--   <pre>
--   $( makeLenses [''TypeName] )
--   </pre>
--   
--   And will generate accessors when TypeName was declared using
--   <tt>data</tt> or <tt>newtype</tt>.
makeLenses :: [Name] -> Q [Dec]

-- | <pre>
--   makeLens a = makeLenses [a]
--   </pre>
--   
--   <pre>
--   $( makeLens ''TypeName )
--   </pre>
makeLens :: Name -> Q [Dec]
decMakeLens :: Name -> Dec -> (String -> Maybe String) -> Q [Dec]
