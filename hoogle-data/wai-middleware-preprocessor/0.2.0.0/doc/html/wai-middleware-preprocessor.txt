-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | WAI middleware for preprocessing static files
--   
@package wai-middleware-preprocessor
@version 0.2.0.0


-- | Serve files subject to a preprocessing function. This library makes it
--   easy to integrate Javascript or CSS preprocessors into a WAI
--   application that will compile the relevant files at runtime
module Network.Wai.Middleware.Preprocessor

-- | Run a preprocessor on incoming requests
--   
--   For example, if your preprocessor has input extension ".fay" and
--   output extension ".js" (and just does the identity function)
--   
--   <pre>
--   ppMiddleware (preprocessor ".fay" ".js" (Just))
--   </pre>
--   
--   and a request to "index.js" goes through the generated middleware
--   
--   <pre>
--   GET "/index.js"
--   </pre>
--   
--   If "index.js" exists, it does nothing
--   
--   If "index.js" does not exist, it does the following:
--   
--   If "index.fay" exists, it will read it in, run the function on its
--   content, and it will write the output to "index.js"
--   
--   Otherwise, it will do nothing
--   
--   Finally, in all cases, it will pass the request along
ppMiddleware :: Preprocessor -> Middleware

-- | Preprocessor composed with static file server
--   
--   This function is just the composition of staticPolicy from
--   wai-middleware-static and ppMiddleware. The policy creation functions
--   from that library are also exported from this library for ease of use.
ppFileMiddleware :: Policy -> Preprocessor -> Middleware

-- | Preprocessors are comprised of an input file extension
--   (<a>String</a>), an output file extension (<a>String</a>), and a
--   transforming function (<a>Text</a> -&gt; <a>Maybe</a> <a>Text</a>)
data Preprocessor

-- | Constructor for a preprocessor.
preprocessor :: String -> String -> (Text -> Maybe Text) -> Preprocessor

-- | Run the preprocessor on a given file
runPreprocessor :: Preprocessor -> FilePath -> IO ()

-- | Read in the input file, run through the preprocessor, and write it out
preprocess :: FilePath -> FilePath -> (Text -> Maybe Text) -> IO ()

-- | Take an incoming URI and optionally modify or filter it. The result
--   will be treated as a filepath.
data Policy :: *

-- | Choose between two policies. If the first fails, run the second.
(<|>) :: Policy -> Policy -> Policy

-- | Sequence two policies. They are run from left to right. (Note: this is
--   <a>mappend</a>)
(>->) :: Policy -> Policy -> Policy

-- | Lift a function into a <a>Policy</a>
policy :: (String -> Maybe String) -> Policy

-- | Lift a predicate into a <a>Policy</a>
predicate :: (String -> Bool) -> Policy

-- | Add a base path to the URI
--   
--   <pre>
--   staticPolicy (addBase "/home/user/files")
--   </pre>
--   
--   GET "foo/bar" looks for "/home/user/files/foo/bar"
addBase :: String -> Policy

-- | Add an initial slash to to the URI, if not already present.
--   
--   <pre>
--   staticPolicy addSlash
--   </pre>
--   
--   GET "foo/bar" looks for "/foo/bar"
addSlash :: Policy

-- | Accept only URIs containing given string
contains :: String -> Policy

-- | Accept only URIs with given prefix
hasPrefix :: String -> Policy

-- | Accept only URIs with given suffix
hasSuffix :: String -> Policy

-- | Reject URIs containing ".."
noDots :: Policy

-- | Reject URIs that are absolute paths
isNotAbsolute :: Policy

-- | Use URI as the key to an association list, rejecting those not found.
--   The policy result is the matching value.
--   
--   <pre>
--   staticPolicy (only [("foo/bar", "/home/user/files/bar")])
--   </pre>
--   
--   GET "foo/bar" looks for "/home/user/files/bar" GET "baz/bar" doesn't
--   match anything
only :: [(String, String)] -> Policy

-- | Run a policy
tryPolicy :: Policy -> String -> Maybe String
