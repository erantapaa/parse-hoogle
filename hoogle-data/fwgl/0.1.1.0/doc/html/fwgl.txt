-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | FRP 2D/3D game engine
--   
@package fwgl
@version 0.1.1.0

module FWGL.Internal.TList
type Equal xs ys = And (IsSubset xs ys) (IsSubset ys xs) ~ True
type Member x xs = IsMember x xs ~ True
class Subset (xs :: [*]) (ys :: [*])
type Reverse xs = Reverse' xs []
instance IsSubset xs ys ~ 'True => Subset xs ys

module FWGL.Graphics.Color

-- | An RGBA 32-bit color.
data Color
Color :: !Word8 -> !Word8 -> !Word8 -> !Word8 -> Color

-- | Create a <a>Color</a> with alpha set to 255.
visible :: Word8 -> Word8 -> Word8 -> Color
white :: Color
black :: Color
transparent :: Color
red :: Color
green :: Color
blue :: Color
yellow :: Color
instance Eq Color
instance Show Color
instance Storable Color
instance Hashable Color

module FWGL.Key

-- | A mouse button.
data MouseButton
MouseLeft :: MouseButton
MouseMiddle :: MouseButton
MouseRight :: MouseButton

-- | A keyboard key.
data Key
KeyA :: Key
KeyB :: Key
KeyC :: Key
KeyD :: Key
KeyE :: Key
KeyF :: Key
KeyG :: Key
KeyH :: Key
KeyI :: Key
KeyJ :: Key
KeyK :: Key
KeyL :: Key
KeyM :: Key
KeyN :: Key
KeyO :: Key
KeyP :: Key
KeyQ :: Key
KeyR :: Key
KeyS :: Key
KeyT :: Key
KeyU :: Key
KeyV :: Key
KeyW :: Key
KeyX :: Key
KeyY :: Key
KeyZ :: Key
Key0 :: Key
Key1 :: Key
Key2 :: Key
Key3 :: Key
Key4 :: Key
Key5 :: Key
Key6 :: Key
Key7 :: Key
Key8 :: Key
Key9 :: Key
KeySpace :: Key
KeyEnter :: Key
KeyTab :: Key
KeyEsc :: Key
KeyBackspace :: Key
KeyShift :: Key
KeyControl :: Key
KeyAlt :: Key
KeyCapsLock :: Key
KeyNumLock :: Key
KeyArrowLeft :: Key
KeyArrowUp :: Key
KeyArrowRight :: Key
KeyArrowDown :: Key
KeyIns :: Key
KeyDel :: Key
KeyHome :: Key
KeyEnd :: Key
KeyPgUp :: Key
KeyPgDown :: Key
KeyF1 :: Key
KeyF2 :: Key
KeyF3 :: Key
KeyF4 :: Key
KeyF5 :: Key
KeyF6 :: Key
KeyF7 :: Key
KeyF8 :: Key
KeyF9 :: Key
KeyF10 :: Key
KeyF11 :: Key
KeyF12 :: Key
KeyPadDel :: Key
KeyPadIns :: Key
KeyPadEnd :: Key
KeyPadDown :: Key
KeyPadPgDown :: Key
KeyPadLeft :: Key
KeyPadRight :: Key
KeyPadHome :: Key
KeyPadUp :: Key
KeyPadPgUp :: Key
KeyPadAdd :: Key
KeyPadSub :: Key
KeyPadMul :: Key
KeyPadDiv :: Key
KeyPadEnter :: Key
KeyPadDot :: Key
KeyPad0 :: Key
KeyPad1 :: Key
KeyPad2 :: Key
KeyPad3 :: Key
KeyPad4 :: Key
KeyPad5 :: Key
KeyPad6 :: Key
KeyPad7 :: Key
KeyPad8 :: Key
KeyPad9 :: Key
KeyUnknown :: Key
instance Eq MouseButton
instance Show MouseButton
instance Eq Key
instance Show Key

module FWGL.Vector

-- | Two-dimensional vector.
data V2
V2 :: !Float -> !Float -> V2

-- | Three-dimensional vector.
data V3
V3 :: !Float -> !Float -> !Float -> V3

-- | Four-dimensional vector.
data V4
V4 :: !Float -> !Float -> !Float -> !Float -> V4

-- | 2x2 matrix.
data M2
M2 :: !V2 -> !V2 -> M2

-- | 3x3 matrix.
data M3
M3 :: !V3 -> !V3 -> !V3 -> M3

-- | 4x4 matrix.
data M4
M4 :: !V4 -> !V4 -> !V4 -> !V4 -> M4

-- | Create a two-dimensional vector.
vec2 :: (Float, Float) -> V2

-- | Create a three-dimensional vector.
vec3 :: (Float, Float, Float) -> V3

-- | Create a four-dimensional vector.
vec4 :: (Float, Float, Float, Float) -> V4

-- | 4D vector dot product.
dot4 :: V4 -> V4 -> Float

-- | Create a 2x2 matrix.
mat2 :: (Float, Float, Float, Float) -> M2

-- | Create a 3x3 matrix.
mat3 :: (Float, Float, Float, Float, Float, Float, Float, Float, Float) -> M3

-- | 3x3 matrix multiplication.
mul3 :: M3 -> M3 -> M3

-- | Create a 4x4 matrix.
mat4 :: (Float, Float, Float, Float, Float, Float, Float, Float, Float, Float, Float, Float, Float, Float, Float, Float) -> M4

-- | 4x4 matrix multiplication.
mul4 :: M4 -> M4 -> M4

-- | Transpose a 4x4 matrix.
transpose4 :: M4 -> M4

-- | 4x4 identity matrix.
idMat4 :: M4

-- | 4x4 translation matrix.
transMat4 :: V3 -> M4

-- | 4x4 rotation matrix (X axis).
rotXMat4 :: Float -> M4

-- | 4x4 rotation matrix (Y axis).
rotYMat4 :: Float -> M4

-- | 4x4 rotation matrix (Z axis).
rotZMat4 :: Float -> M4

-- | 4x4 rotation matrix.
rotAAMat4 :: V3 -> Float -> M4

-- | 4x4 scale matrix.
scaleMat4 :: V3 -> M4

-- | 4x4 perspective matrix.
perspectiveMat4 :: Float -> Float -> Float -> Float -> M4

-- | 4x4 FPS camera matrix.
cameraMat4 :: V3 -> Float -> Float -> M4

-- | The identity 3x3 matrix.
idMat3 :: M3

-- | 3x3 translation matrix.
transMat3 :: V2 -> M3

-- | 3x3 rotation matrix.
rotMat3 :: Float -> M3

-- | 3x3 scale matrix.
scaleMat3 :: V2 -> M3
instance Show V2
instance Eq V2
instance Show V3
instance Eq V3
instance Show V4
instance Eq V4
instance Show M2
instance Eq M2
instance Show M3
instance Eq M3
instance Show M4
instance Eq M4
instance Storable V4
instance Storable V3
instance Storable V2
instance Hashable V4
instance Hashable V3
instance Hashable V2

module FWGL.Backend.GLES
class (Integral GLEnum, Integral GLUInt, Integral GLInt, Integral GLSize, Bits GLEnum, Num GLEnum, Num GLUInt, Num GLInt, Num GLPtrDiff, Num GLSize) => GLES where type family Ctx type family GLEnum type family GLUInt type family GLInt type family GLPtr type family GLPtrDiff type family GLSize type family GLString type family GLBool type family Buffer type family UniformLocation type family Texture type family Shader type family Program type family FrameBuffer type family RenderBuffer type family Array type family Float32Array type family Int32Array type family Image
true :: GLES => GLBool
false :: GLES => GLBool
nullGLPtr :: GLES => GLPtr
toGLString :: GLES => String -> GLString
noBuffer :: GLES => Buffer
noTexture :: GLES => Texture
noArray :: GLES => IO Array
encodeM2 :: GLES => M2 -> IO Float32Array
encodeM3 :: GLES => M3 -> IO Float32Array
encodeM4 :: GLES => M4 -> IO Float32Array
encodeFloats :: GLES => [Float] -> IO Array
encodeV2s :: GLES => [V2] -> IO Array
encodeV3s :: GLES => [V3] -> IO Array
encodeV4s :: GLES => [V4] -> IO Array
encodeUShorts :: GLES => [Word16] -> IO Array
encodeColors :: GLES => [Color] -> IO Array
glActiveTexture :: GLES => Ctx -> GLEnum -> IO ()
glAttachShader :: GLES => Ctx -> Program -> Shader -> IO ()
glBindAttribLocation :: GLES => Ctx -> Program -> GLUInt -> GLString -> IO ()
glBindBuffer :: GLES => Ctx -> GLEnum -> Buffer -> IO ()
glBindFramebuffer :: GLES => Ctx -> GLEnum -> FrameBuffer -> IO ()
glBindRenderbuffer :: GLES => Ctx -> GLEnum -> RenderBuffer -> IO ()
glBindTexture :: GLES => Ctx -> GLEnum -> Texture -> IO ()
glBlendColor :: GLES => Ctx -> Float -> Float -> Float -> Float -> IO ()
glBlendEquation :: GLES => Ctx -> GLEnum -> IO ()
glBlendEquationSeparate :: GLES => Ctx -> GLEnum -> GLEnum -> IO ()
glBlendFunc :: GLES => Ctx -> GLEnum -> GLEnum -> IO ()
glBlendFuncSeparate :: GLES => Ctx -> GLEnum -> GLEnum -> GLEnum -> GLEnum -> IO ()
glBufferData :: GLES => Ctx -> GLEnum -> Array -> GLEnum -> IO ()
glBufferSubData :: GLES => Ctx -> GLEnum -> GLPtrDiff -> Array -> IO ()
glCheckFramebufferStatus :: GLES => Ctx -> GLEnum -> IO GLEnum
glClear :: GLES => Ctx -> GLEnum -> IO ()
glClearColor :: GLES => Ctx -> Float -> Float -> Float -> Float -> IO ()
glClearDepth :: GLES => Ctx -> Float -> IO ()
glClearStencil :: GLES => Ctx -> GLInt -> IO ()
glColorMask :: GLES => Ctx -> GLBool -> GLBool -> GLBool -> GLBool -> IO ()
glCompileShader :: GLES => Ctx -> Shader -> IO ()
glCompressedTexImage2D :: GLES => Ctx -> GLEnum -> GLInt -> GLEnum -> GLSize -> GLSize -> GLInt -> Array -> IO ()
glCompressedTexSubImage2D :: GLES => Ctx -> GLEnum -> GLInt -> GLInt -> GLInt -> GLSize -> GLSize -> GLEnum -> Array -> IO ()
glCopyTexImage2D :: GLES => Ctx -> GLEnum -> GLInt -> GLEnum -> GLInt -> GLInt -> GLSize -> GLSize -> GLInt -> IO ()
glCopyTexSubImage2D :: GLES => Ctx -> GLEnum -> GLInt -> GLInt -> GLInt -> GLInt -> GLInt -> GLSize -> GLSize -> IO ()
glCreateBuffer :: GLES => Ctx -> IO Buffer
glCreateFramebuffer :: GLES => Ctx -> IO FrameBuffer
glCreateProgram :: GLES => Ctx -> IO Program
glCreateRenderbuffer :: GLES => Ctx -> IO RenderBuffer
glCreateShader :: GLES => Ctx -> GLEnum -> IO Shader
glCreateTexture :: GLES => Ctx -> IO Texture
glCullFace :: GLES => Ctx -> GLEnum -> IO ()
glDeleteBuffer :: GLES => Ctx -> Buffer -> IO ()
glDeleteFramebuffer :: GLES => Ctx -> FrameBuffer -> IO ()
glDeleteProgram :: GLES => Ctx -> Program -> IO ()
glDeleteRenderbuffer :: GLES => Ctx -> RenderBuffer -> IO ()
glDeleteShader :: GLES => Ctx -> Shader -> IO ()
glDeleteTexture :: GLES => Ctx -> Texture -> IO ()
glDepthFunc :: GLES => Ctx -> GLEnum -> IO ()
glDepthMask :: GLES => Ctx -> GLBool -> IO ()
glDepthRange :: GLES => Ctx -> Float -> Float -> IO ()
glDetachShader :: GLES => Ctx -> Program -> Shader -> IO ()
glDisable :: GLES => Ctx -> GLEnum -> IO ()
glDisableVertexAttribArray :: GLES => Ctx -> GLUInt -> IO ()
glDrawArrays :: GLES => Ctx -> GLEnum -> GLInt -> GLSize -> IO ()
glDrawElements :: GLES => Ctx -> GLEnum -> GLSize -> GLEnum -> GLPtr -> IO ()
glEnable :: GLES => Ctx -> GLEnum -> IO ()
glEnableVertexAttribArray :: GLES => Ctx -> GLUInt -> IO ()
glFinish :: GLES => Ctx -> IO ()
glFlush :: GLES => Ctx -> IO ()
glFramebufferRenderbuffer :: GLES => Ctx -> GLEnum -> GLEnum -> GLEnum -> RenderBuffer -> IO ()
glFramebufferTexture2D :: GLES => Ctx -> GLEnum -> GLEnum -> GLEnum -> Texture -> GLInt -> IO ()
glFrontFace :: GLES => Ctx -> GLEnum -> IO ()
glGenerateMipmap :: GLES => Ctx -> GLEnum -> IO ()
glGetAttribLocation :: GLES => Ctx -> Program -> GLString -> IO GLInt
glGetError :: GLES => Ctx -> IO GLEnum
glGetProgramInfoLog :: GLES => Ctx -> Program -> IO GLString
glGetShaderInfoLog :: GLES => Ctx -> Shader -> IO GLString
glGetShaderSource :: GLES => Ctx -> Shader -> IO GLString
glGetUniformLocation :: GLES => Ctx -> Program -> GLString -> IO UniformLocation
glHint :: GLES => Ctx -> GLEnum -> GLEnum -> IO ()
glIsBuffer :: GLES => Ctx -> Buffer -> IO GLBool
glIsEnabled :: GLES => Ctx -> GLEnum -> IO GLBool
glIsFramebuffer :: GLES => Ctx -> FrameBuffer -> IO GLBool
glIsProgram :: GLES => Ctx -> Program -> IO GLBool
glIsRenderbuffer :: GLES => Ctx -> RenderBuffer -> IO GLBool
glIsShader :: GLES => Ctx -> Shader -> IO GLBool
glIsTexture :: GLES => Ctx -> Texture -> IO GLBool
glLineWidth :: GLES => Ctx -> Float -> IO ()
glLinkProgram :: GLES => Ctx -> Program -> IO ()
glPixelStorei :: GLES => Ctx -> GLEnum -> GLInt -> IO ()
glPolygonOffset :: GLES => Ctx -> Float -> Float -> IO ()
glReadPixels :: GLES => Ctx -> GLInt -> GLInt -> GLSize -> GLSize -> GLEnum -> GLEnum -> Array -> IO ()
glRenderbufferStorage :: GLES => Ctx -> GLEnum -> GLEnum -> GLSize -> GLSize -> IO ()
glSampleCoverage :: GLES => Ctx -> Float -> GLBool -> IO ()
glScissor :: GLES => Ctx -> GLInt -> GLInt -> GLSize -> GLSize -> IO ()
glShaderSource :: GLES => Ctx -> Shader -> GLString -> IO ()
glStencilFunc :: GLES => Ctx -> GLEnum -> GLInt -> GLUInt -> IO ()
glStencilFuncSeparate :: GLES => Ctx -> GLEnum -> GLEnum -> GLInt -> GLUInt -> IO ()
glStencilMask :: GLES => Ctx -> GLUInt -> IO ()
glStencilMaskSeparate :: GLES => Ctx -> GLEnum -> GLUInt -> IO ()
glStencilOp :: GLES => Ctx -> GLEnum -> GLEnum -> GLEnum -> IO ()
glStencilOpSeparate :: GLES => Ctx -> GLEnum -> GLEnum -> GLEnum -> GLEnum -> IO ()
glTexImage2DBuffer :: GLES => Ctx -> GLEnum -> GLInt -> GLInt -> GLSize -> GLSize -> GLInt -> GLEnum -> GLEnum -> Array -> IO ()
glTexImage2DImage :: GLES => Ctx -> GLEnum -> GLInt -> GLInt -> GLEnum -> GLEnum -> Image -> IO ()
glTexParameterf :: GLES => Ctx -> GLEnum -> GLEnum -> Float -> IO ()
glTexParameteri :: GLES => Ctx -> GLEnum -> GLEnum -> GLInt -> IO ()
glTexSubImage2D :: GLES => Ctx -> GLEnum -> GLInt -> GLInt -> GLInt -> GLSize -> GLSize -> GLEnum -> GLEnum -> Array -> IO ()
glUniform1f :: GLES => Ctx -> UniformLocation -> Float -> IO ()
glUniform1fv :: GLES => Ctx -> UniformLocation -> Float32Array -> IO ()
glUniform1i :: GLES => Ctx -> UniformLocation -> GLInt -> IO ()
glUniform1iv :: GLES => Ctx -> UniformLocation -> Int32Array -> IO ()
glUniform2f :: GLES => Ctx -> UniformLocation -> Float -> Float -> IO ()
glUniform2fv :: GLES => Ctx -> UniformLocation -> Float32Array -> IO ()
glUniform2i :: GLES => Ctx -> UniformLocation -> GLInt -> GLInt -> IO ()
glUniform2iv :: GLES => Ctx -> UniformLocation -> Int32Array -> IO ()
glUniform3f :: GLES => Ctx -> UniformLocation -> Float -> Float -> Float -> IO ()
glUniform3fv :: GLES => Ctx -> UniformLocation -> Float32Array -> IO ()
glUniform3i :: GLES => Ctx -> UniformLocation -> GLInt -> GLInt -> GLInt -> IO ()
glUniform3iv :: GLES => Ctx -> UniformLocation -> Int32Array -> IO ()
glUniform4f :: GLES => Ctx -> UniformLocation -> Float -> Float -> Float -> Float -> IO ()
glUniform4fv :: GLES => Ctx -> UniformLocation -> Float32Array -> IO ()
glUniform4i :: GLES => Ctx -> UniformLocation -> GLInt -> GLInt -> GLInt -> GLInt -> IO ()
glUniform4iv :: GLES => Ctx -> UniformLocation -> Int32Array -> IO ()
glUniformMatrix2fv :: GLES => Ctx -> UniformLocation -> GLBool -> Float32Array -> IO ()
glUniformMatrix3fv :: GLES => Ctx -> UniformLocation -> GLBool -> Float32Array -> IO ()
glUniformMatrix4fv :: GLES => Ctx -> UniformLocation -> GLBool -> Float32Array -> IO ()
glUseProgram :: GLES => Ctx -> Program -> IO ()
glValidateProgram :: GLES => Ctx -> Program -> IO ()
glVertexAttrib1f :: GLES => Ctx -> GLUInt -> Float -> IO ()
glVertexAttrib1fv :: GLES => Ctx -> GLUInt -> Float32Array -> IO ()
glVertexAttrib2f :: GLES => Ctx -> GLUInt -> Float -> Float -> IO ()
glVertexAttrib2fv :: GLES => Ctx -> GLUInt -> Float32Array -> IO ()
glVertexAttrib3f :: GLES => Ctx -> GLUInt -> Float -> Float -> Float -> IO ()
glVertexAttrib3fv :: GLES => Ctx -> GLUInt -> Float32Array -> IO ()
glVertexAttrib4f :: GLES => Ctx -> GLUInt -> Float -> Float -> Float -> Float -> IO ()
glVertexAttrib4fv :: GLES => Ctx -> GLUInt -> Float32Array -> IO ()
glVertexAttribPointer :: GLES => Ctx -> GLUInt -> GLInt -> GLEnum -> GLBool -> GLSize -> GLPtr -> IO ()
glViewport :: GLES => Ctx -> GLInt -> GLInt -> GLSize -> GLSize -> IO ()
gl_DEPTH_BUFFER_BIT :: GLES => GLEnum
gl_STENCIL_BUFFER_BIT :: GLES => GLEnum
gl_COLOR_BUFFER_BIT :: GLES => GLEnum
gl_POINTS :: GLES => GLEnum
gl_LINES :: GLES => GLEnum
gl_LINE_LOOP :: GLES => GLEnum
gl_LINE_STRIP :: GLES => GLEnum
gl_TRIANGLES :: GLES => GLEnum
gl_TRIANGLE_STRIP :: GLES => GLEnum
gl_TRIANGLE_FAN :: GLES => GLEnum
gl_ZERO :: GLES => GLEnum
gl_ONE :: GLES => GLEnum
gl_SRC_COLOR :: GLES => GLEnum
gl_ONE_MINUS_SRC_COLOR :: GLES => GLEnum
gl_SRC_ALPHA :: GLES => GLEnum
gl_ONE_MINUS_SRC_ALPHA :: GLES => GLEnum
gl_DST_ALPHA :: GLES => GLEnum
gl_ONE_MINUS_DST_ALPHA :: GLES => GLEnum
gl_DST_COLOR :: GLES => GLEnum
gl_ONE_MINUS_DST_COLOR :: GLES => GLEnum
gl_SRC_ALPHA_SATURATE :: GLES => GLEnum
gl_FUNC_ADD :: GLES => GLEnum
gl_BLEND_EQUATION :: GLES => GLEnum
gl_BLEND_EQUATION_RGB :: GLES => GLEnum
gl_BLEND_EQUATION_ALPHA :: GLES => GLEnum
gl_FUNC_SUBTRACT :: GLES => GLEnum
gl_FUNC_REVERSE_SUBTRACT :: GLES => GLEnum
gl_BLEND_DST_RGB :: GLES => GLEnum
gl_BLEND_SRC_RGB :: GLES => GLEnum
gl_BLEND_DST_ALPHA :: GLES => GLEnum
gl_BLEND_SRC_ALPHA :: GLES => GLEnum
gl_CONSTANT_COLOR :: GLES => GLEnum
gl_ONE_MINUS_CONSTANT_COLOR :: GLES => GLEnum
gl_CONSTANT_ALPHA :: GLES => GLEnum
gl_ONE_MINUS_CONSTANT_ALPHA :: GLES => GLEnum
gl_BLEND_COLOR :: GLES => GLEnum
gl_ARRAY_BUFFER :: GLES => GLEnum
gl_ELEMENT_ARRAY_BUFFER :: GLES => GLEnum
gl_ARRAY_BUFFER_BINDING :: GLES => GLEnum
gl_ELEMENT_ARRAY_BUFFER_BINDING :: GLES => GLEnum
gl_STREAM_DRAW :: GLES => GLEnum
gl_STATIC_DRAW :: GLES => GLEnum
gl_DYNAMIC_DRAW :: GLES => GLEnum
gl_BUFFER_SIZE :: GLES => GLEnum
gl_BUFFER_USAGE :: GLES => GLEnum
gl_CURRENT_VERTEX_ATTRIB :: GLES => GLEnum
gl_FRONT :: GLES => GLEnum
gl_BACK :: GLES => GLEnum
gl_FRONT_AND_BACK :: GLES => GLEnum
gl_CULL_FACE :: GLES => GLEnum
gl_BLEND :: GLES => GLEnum
gl_DITHER :: GLES => GLEnum
gl_STENCIL_TEST :: GLES => GLEnum
gl_DEPTH_TEST :: GLES => GLEnum
gl_SCISSOR_TEST :: GLES => GLEnum
gl_POLYGON_OFFSET_FILL :: GLES => GLEnum
gl_SAMPLE_ALPHA_TO_COVERAGE :: GLES => GLEnum
gl_SAMPLE_COVERAGE :: GLES => GLEnum
gl_NO_ERROR :: GLES => GLEnum
gl_INVALID_ENUM :: GLES => GLEnum
gl_INVALID_VALUE :: GLES => GLEnum
gl_INVALID_OPERATION :: GLES => GLEnum
gl_OUT_OF_MEMORY :: GLES => GLEnum
gl_CW :: GLES => GLEnum
gl_CCW :: GLES => GLEnum
gl_LINE_WIDTH :: GLES => GLEnum
gl_ALIASED_POINT_SIZE_RANGE :: GLES => GLEnum
gl_ALIASED_LINE_WIDTH_RANGE :: GLES => GLEnum
gl_CULL_FACE_MODE :: GLES => GLEnum
gl_FRONT_FACE :: GLES => GLEnum
gl_DEPTH_RANGE :: GLES => GLEnum
gl_DEPTH_WRITEMASK :: GLES => GLEnum
gl_DEPTH_CLEAR_VALUE :: GLES => GLEnum
gl_DEPTH_FUNC :: GLES => GLEnum
gl_STENCIL_CLEAR_VALUE :: GLES => GLEnum
gl_STENCIL_FUNC :: GLES => GLEnum
gl_STENCIL_FAIL :: GLES => GLEnum
gl_STENCIL_PASS_DEPTH_FAIL :: GLES => GLEnum
gl_STENCIL_PASS_DEPTH_PASS :: GLES => GLEnum
gl_STENCIL_REF :: GLES => GLEnum
gl_STENCIL_VALUE_MASK :: GLES => GLEnum
gl_STENCIL_WRITEMASK :: GLES => GLEnum
gl_STENCIL_BACK_FUNC :: GLES => GLEnum
gl_STENCIL_BACK_FAIL :: GLES => GLEnum
gl_STENCIL_BACK_PASS_DEPTH_FAIL :: GLES => GLEnum
gl_STENCIL_BACK_PASS_DEPTH_PASS :: GLES => GLEnum
gl_STENCIL_BACK_REF :: GLES => GLEnum
gl_STENCIL_BACK_VALUE_MASK :: GLES => GLEnum
gl_STENCIL_BACK_WRITEMASK :: GLES => GLEnum
gl_VIEWPORT :: GLES => GLEnum
gl_SCISSOR_BOX :: GLES => GLEnum
gl_COLOR_CLEAR_VALUE :: GLES => GLEnum
gl_COLOR_WRITEMASK :: GLES => GLEnum
gl_UNPACK_ALIGNMENT :: GLES => GLEnum
gl_PACK_ALIGNMENT :: GLES => GLEnum
gl_MAX_TEXTURE_SIZE :: GLES => GLEnum
gl_MAX_VIEWPORT_DIMS :: GLES => GLEnum
gl_SUBPIXEL_BITS :: GLES => GLEnum
gl_RED_BITS :: GLES => GLEnum
gl_GREEN_BITS :: GLES => GLEnum
gl_BLUE_BITS :: GLES => GLEnum
gl_ALPHA_BITS :: GLES => GLEnum
gl_DEPTH_BITS :: GLES => GLEnum
gl_STENCIL_BITS :: GLES => GLEnum
gl_POLYGON_OFFSET_UNITS :: GLES => GLEnum
gl_POLYGON_OFFSET_FACTOR :: GLES => GLEnum
gl_TEXTURE_BINDING_2D :: GLES => GLEnum
gl_SAMPLE_BUFFERS :: GLES => GLEnum
gl_SAMPLES :: GLES => GLEnum
gl_SAMPLE_COVERAGE_VALUE :: GLES => GLEnum
gl_SAMPLE_COVERAGE_INVERT :: GLES => GLEnum
gl_COMPRESSED_TEXTURE_FORMATS :: GLES => GLEnum
gl_DONT_CARE :: GLES => GLEnum
gl_FASTEST :: GLES => GLEnum
gl_NICEST :: GLES => GLEnum
gl_GENERATE_MIPMAP_HINT :: GLES => GLEnum
gl_BYTE :: GLES => GLEnum
gl_UNSIGNED_BYTE :: GLES => GLEnum
gl_SHORT :: GLES => GLEnum
gl_UNSIGNED_SHORT :: GLES => GLEnum
gl_INT :: GLES => GLEnum
gl_UNSIGNED_INT :: GLES => GLEnum
gl_FLOAT :: GLES => GLEnum
gl_DEPTH_COMPONENT :: GLES => GLEnum
gl_ALPHA :: GLES => GLEnum
gl_RGB :: GLES => GLEnum
gl_RGBA :: GLES => GLEnum
gl_LUMINANCE :: GLES => GLEnum
gl_LUMINANCE_ALPHA :: GLES => GLEnum
gl_UNSIGNED_SHORT_4_4_4_4 :: GLES => GLEnum
gl_UNSIGNED_SHORT_5_5_5_1 :: GLES => GLEnum
gl_UNSIGNED_SHORT_5_6_5 :: GLES => GLEnum
gl_FRAGMENT_SHADER :: GLES => GLEnum
gl_VERTEX_SHADER :: GLES => GLEnum
gl_MAX_VERTEX_ATTRIBS :: GLES => GLEnum
gl_MAX_VERTEX_UNIFORM_VECTORS :: GLES => GLEnum
gl_MAX_VARYING_VECTORS :: GLES => GLEnum
gl_MAX_COMBINED_TEXTURE_IMAGE_UNITS :: GLES => GLEnum
gl_MAX_VERTEX_TEXTURE_IMAGE_UNITS :: GLES => GLEnum
gl_MAX_TEXTURE_IMAGE_UNITS :: GLES => GLEnum
gl_MAX_FRAGMENT_UNIFORM_VECTORS :: GLES => GLEnum
gl_SHADER_TYPE :: GLES => GLEnum
gl_DELETE_STATUS :: GLES => GLEnum
gl_LINK_STATUS :: GLES => GLEnum
gl_VALIDATE_STATUS :: GLES => GLEnum
gl_ATTACHED_SHADERS :: GLES => GLEnum
gl_ACTIVE_UNIFORMS :: GLES => GLEnum
gl_ACTIVE_ATTRIBUTES :: GLES => GLEnum
gl_SHADING_LANGUAGE_VERSION :: GLES => GLEnum
gl_CURRENT_PROGRAM :: GLES => GLEnum
gl_NEVER :: GLES => GLEnum
gl_LESS :: GLES => GLEnum
gl_EQUAL :: GLES => GLEnum
gl_LEQUAL :: GLES => GLEnum
gl_GREATER :: GLES => GLEnum
gl_NOTEQUAL :: GLES => GLEnum
gl_GEQUAL :: GLES => GLEnum
gl_ALWAYS :: GLES => GLEnum
gl_KEEP :: GLES => GLEnum
gl_REPLACE :: GLES => GLEnum
gl_INCR :: GLES => GLEnum
gl_DECR :: GLES => GLEnum
gl_INVERT :: GLES => GLEnum
gl_INCR_WRAP :: GLES => GLEnum
gl_DECR_WRAP :: GLES => GLEnum
gl_VENDOR :: GLES => GLEnum
gl_RENDERER :: GLES => GLEnum
gl_VERSION :: GLES => GLEnum
gl_NEAREST :: GLES => GLEnum
gl_LINEAR :: GLES => GLEnum
gl_NEAREST_MIPMAP_NEAREST :: GLES => GLEnum
gl_LINEAR_MIPMAP_NEAREST :: GLES => GLEnum
gl_NEAREST_MIPMAP_LINEAR :: GLES => GLEnum
gl_LINEAR_MIPMAP_LINEAR :: GLES => GLEnum
gl_TEXTURE_MAG_FILTER :: GLES => GLEnum
gl_TEXTURE_MIN_FILTER :: GLES => GLEnum
gl_TEXTURE_WRAP_S :: GLES => GLEnum
gl_TEXTURE_WRAP_T :: GLES => GLEnum
gl_TEXTURE_2D :: GLES => GLEnum
gl_TEXTURE :: GLES => GLEnum
gl_TEXTURE_CUBE_MAP :: GLES => GLEnum
gl_TEXTURE_BINDING_CUBE_MAP :: GLES => GLEnum
gl_TEXTURE_CUBE_MAP_POSITIVE_X :: GLES => GLEnum
gl_TEXTURE_CUBE_MAP_NEGATIVE_X :: GLES => GLEnum
gl_TEXTURE_CUBE_MAP_POSITIVE_Y :: GLES => GLEnum
gl_TEXTURE_CUBE_MAP_NEGATIVE_Y :: GLES => GLEnum
gl_TEXTURE_CUBE_MAP_POSITIVE_Z :: GLES => GLEnum
gl_TEXTURE_CUBE_MAP_NEGATIVE_Z :: GLES => GLEnum
gl_MAX_CUBE_MAP_TEXTURE_SIZE :: GLES => GLEnum
gl_TEXTURE0 :: GLES => GLEnum
gl_TEXTURE1 :: GLES => GLEnum
gl_TEXTURE2 :: GLES => GLEnum
gl_TEXTURE3 :: GLES => GLEnum
gl_TEXTURE4 :: GLES => GLEnum
gl_TEXTURE5 :: GLES => GLEnum
gl_TEXTURE6 :: GLES => GLEnum
gl_TEXTURE7 :: GLES => GLEnum
gl_TEXTURE8 :: GLES => GLEnum
gl_TEXTURE9 :: GLES => GLEnum
gl_TEXTURE10 :: GLES => GLEnum
gl_TEXTURE11 :: GLES => GLEnum
gl_TEXTURE12 :: GLES => GLEnum
gl_TEXTURE13 :: GLES => GLEnum
gl_TEXTURE14 :: GLES => GLEnum
gl_TEXTURE15 :: GLES => GLEnum
gl_TEXTURE16 :: GLES => GLEnum
gl_TEXTURE17 :: GLES => GLEnum
gl_TEXTURE18 :: GLES => GLEnum
gl_TEXTURE19 :: GLES => GLEnum
gl_TEXTURE20 :: GLES => GLEnum
gl_TEXTURE21 :: GLES => GLEnum
gl_TEXTURE22 :: GLES => GLEnum
gl_TEXTURE23 :: GLES => GLEnum
gl_TEXTURE24 :: GLES => GLEnum
gl_TEXTURE25 :: GLES => GLEnum
gl_TEXTURE26 :: GLES => GLEnum
gl_TEXTURE27 :: GLES => GLEnum
gl_TEXTURE28 :: GLES => GLEnum
gl_TEXTURE29 :: GLES => GLEnum
gl_TEXTURE30 :: GLES => GLEnum
gl_TEXTURE31 :: GLES => GLEnum
gl_ACTIVE_TEXTURE :: GLES => GLEnum
gl_REPEAT :: GLES => GLEnum
gl_CLAMP_TO_EDGE :: GLES => GLEnum
gl_MIRRORED_REPEAT :: GLES => GLEnum
gl_FLOAT_VEC2 :: GLES => GLEnum
gl_FLOAT_VEC3 :: GLES => GLEnum
gl_FLOAT_VEC4 :: GLES => GLEnum
gl_INT_VEC2 :: GLES => GLEnum
gl_INT_VEC3 :: GLES => GLEnum
gl_INT_VEC4 :: GLES => GLEnum
gl_BOOL :: GLES => GLEnum
gl_BOOL_VEC2 :: GLES => GLEnum
gl_BOOL_VEC3 :: GLES => GLEnum
gl_BOOL_VEC4 :: GLES => GLEnum
gl_FLOAT_MAT2 :: GLES => GLEnum
gl_FLOAT_MAT3 :: GLES => GLEnum
gl_FLOAT_MAT4 :: GLES => GLEnum
gl_SAMPLER_2D :: GLES => GLEnum
gl_SAMPLER_CUBE :: GLES => GLEnum
gl_VERTEX_ATTRIB_ARRAY_ENABLED :: GLES => GLEnum
gl_VERTEX_ATTRIB_ARRAY_SIZE :: GLES => GLEnum
gl_VERTEX_ATTRIB_ARRAY_STRIDE :: GLES => GLEnum
gl_VERTEX_ATTRIB_ARRAY_TYPE :: GLES => GLEnum
gl_VERTEX_ATTRIB_ARRAY_NORMALIZED :: GLES => GLEnum
gl_VERTEX_ATTRIB_ARRAY_POINTER :: GLES => GLEnum
gl_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING :: GLES => GLEnum
gl_COMPILE_STATUS :: GLES => GLEnum
gl_LOW_FLOAT :: GLES => GLEnum
gl_MEDIUM_FLOAT :: GLES => GLEnum
gl_HIGH_FLOAT :: GLES => GLEnum
gl_LOW_INT :: GLES => GLEnum
gl_MEDIUM_INT :: GLES => GLEnum
gl_HIGH_INT :: GLES => GLEnum
gl_FRAMEBUFFER :: GLES => GLEnum
gl_RENDERBUFFER :: GLES => GLEnum
gl_RGBA4 :: GLES => GLEnum
gl_RGB5_A1 :: GLES => GLEnum
gl_RGB565 :: GLES => GLEnum
gl_DEPTH_COMPONENT16 :: GLES => GLEnum
gl_STENCIL_INDEX8 :: GLES => GLEnum
gl_RENDERBUFFER_WIDTH :: GLES => GLEnum
gl_RENDERBUFFER_HEIGHT :: GLES => GLEnum
gl_RENDERBUFFER_INTERNAL_FORMAT :: GLES => GLEnum
gl_RENDERBUFFER_RED_SIZE :: GLES => GLEnum
gl_RENDERBUFFER_GREEN_SIZE :: GLES => GLEnum
gl_RENDERBUFFER_BLUE_SIZE :: GLES => GLEnum
gl_RENDERBUFFER_ALPHA_SIZE :: GLES => GLEnum
gl_RENDERBUFFER_DEPTH_SIZE :: GLES => GLEnum
gl_RENDERBUFFER_STENCIL_SIZE :: GLES => GLEnum
gl_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE :: GLES => GLEnum
gl_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME :: GLES => GLEnum
gl_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL :: GLES => GLEnum
gl_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE :: GLES => GLEnum
gl_COLOR_ATTACHMENT0 :: GLES => GLEnum
gl_DEPTH_ATTACHMENT :: GLES => GLEnum
gl_STENCIL_ATTACHMENT :: GLES => GLEnum
gl_NONE :: GLES => GLEnum
gl_FRAMEBUFFER_COMPLETE :: GLES => GLEnum
gl_FRAMEBUFFER_INCOMPLETE_ATTACHMENT :: GLES => GLEnum
gl_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT :: GLES => GLEnum
gl_FRAMEBUFFER_INCOMPLETE_DIMENSIONS :: GLES => GLEnum
gl_FRAMEBUFFER_UNSUPPORTED :: GLES => GLEnum
gl_FRAMEBUFFER_BINDING :: GLES => GLEnum
gl_RENDERBUFFER_BINDING :: GLES => GLEnum
gl_MAX_RENDERBUFFER_SIZE :: GLES => GLEnum
gl_INVALID_FRAMEBUFFER_OPERATION :: GLES => GLEnum

module FWGL.Shader.Language

-- | A type in the GPU.
class ShaderType t
toExpr :: ShaderType t => t -> Expr
fromExpr :: ShaderType t => Expr -> t
typeName :: ShaderType t => t -> String
size :: ShaderType t => t -> Int
data Expr
Empty :: Expr
Read :: String -> Expr
Op1 :: String -> Expr -> Expr
Op2 :: String -> Expr -> Expr -> Expr
Apply :: String -> [Expr] -> Expr
X :: Expr -> Expr
Y :: Expr -> Expr
Z :: Expr -> Expr
W :: Expr -> Expr
Literal :: String -> Expr

-- | A GPU float.
newtype Float
Float :: Expr -> Float

-- | A GPU sampler (sampler2D in GLSL).
newtype Sampler2D
Sampler2D :: Expr -> Sampler2D

-- | A GPU 2D vector. NB: This is a different type from
--   FWGL.Vector.<a>V2</a>.
data V2
V2 :: Float -> Float -> V2

-- | A GPU 3D vector.
data V3
V3 :: Float -> Float -> Float -> V3

-- | A GPU 4D vector.
data V4
V4 :: Float -> Float -> Float -> Float -> V4

-- | A GPU 2x2 matrix.
data M2
M2 :: V2 -> V2 -> M2

-- | A GPU 3x3 matrix.
data M3
M3 :: V3 -> V3 -> V3 -> M3

-- | A GPU 4x4 matrix.
data M4
M4 :: V4 -> V4 -> V4 -> V4 -> M4
fromRational :: Rational -> Float
fromInteger :: Integer -> Float
negate :: Float -> Float

-- | Types that can be multiplied.
class Mul a b c | a b -> c
(*) :: (Mul a b c, ShaderType a, ShaderType b, ShaderType c) => a -> b -> c
(/) :: (Mul a b c, ShaderType a, ShaderType b, ShaderType c) => a -> b -> c

-- | Types that can be added.
class Sum a
(+) :: (Sum a, ShaderType a) => a -> a -> a
(-) :: (Sum a, ShaderType a) => a -> a -> a
(^) :: (ShaderType a, ShaderType b) => a -> b -> a
(&&) :: Bool -> Bool -> Bool
(||) :: Bool -> Bool -> Bool
(==) :: ShaderType a => a -> a -> Bool
(>=) :: ShaderType a => a -> a -> Bool
(<=) :: ShaderType a => a -> a -> Bool
(<) :: ShaderType a => a -> a -> Bool
(>) :: ShaderType a => a -> a -> Bool
abs :: Float -> Float
sign :: Float -> Float
texture2D :: Sampler2D -> V2 -> V4
sqrt :: Float -> Float
instance Typeable Bool
instance Typeable Float
instance Typeable Sampler2D
instance Typeable V2
instance Typeable V3
instance Typeable V4
instance Typeable M2
instance Typeable M3
instance Typeable M4
instance Eq Expr
instance Sum M4
instance Sum M3
instance Sum M2
instance Sum V4
instance Sum V3
instance Sum V2
instance Sum Float
instance Mul V4 M4 V4
instance Mul V3 M3 V3
instance Mul V2 M2 V2
instance Mul M4 V4 V4
instance Mul M3 V3 V3
instance Mul M2 V2 V2
instance Mul Float M4 M4
instance Mul Float M3 M3
instance Mul Float M2 M2
instance Mul M4 Float M4
instance Mul M3 Float M3
instance Mul M2 Float M2
instance Mul M4 M4 M4
instance Mul M3 M3 M3
instance Mul M2 M2 M2
instance Mul Float V4 V4
instance Mul Float V3 V3
instance Mul Float V2 V2
instance Mul V4 Float V4
instance Mul V3 Float V3
instance Mul V2 Float V2
instance Mul V4 V4 V4
instance Mul V3 V3 V3
instance Mul V2 V2 V2
instance Mul Float Float Float
instance Matrix M4
instance Matrix M3
instance Matrix M2
instance Vector V4
instance Vector V3
instance Vector V2
instance ShaderType M4
instance ShaderType M3
instance ShaderType M2
instance ShaderType V4
instance ShaderType V3
instance ShaderType V2
instance ShaderType Sampler2D
instance ShaderType Float
instance ShaderType Bool

module FWGL.Shader.Shader

-- | A function from a (heterogeneous) set of uniforms and a set of inputs
--   (attributes or varyings) to a set of outputs (varyings).
type Shader gs is os = STList gs -> STList is -> STList os

-- | The condition for a valid <a>Shader</a>.
type Valid gs is os = (StaticList gs, StaticList is, StaticList os, StaticSTList gs, StaticSTList is, StaticSTList os)
type Member x xs = IsMember x xs ~ True
class AllTypeable (xs :: [*])
class Subset (xs :: [*]) (ys :: [*])
type Equal xs ys = And (IsSubset xs ys) (IsSubset ys xs) ~ True

-- | An heterogeneous set of <a>ShaderType</a>s and <a>Typeable</a>s.
data STList :: [*] -> *
N :: STList []
(:-) :: a -> STList xs -> STList (a : xs)
stFold :: (forall x. (Typeable x, ShaderType x) => acc -> x -> acc) -> acc -> STList xs -> acc
staticList :: StaticList xs => Proxy (xs :: [*]) -> (forall x. (Typeable x, ShaderType x) => x -> y) -> [y]
staticSTList :: StaticSTList xs => Proxy (xs :: [*]) -> (forall x. (Typeable x, ShaderType x) => x -> x) -> STList xs
instance (Typeable x, AllTypeable xs) => AllTypeable (x : xs)
instance AllTypeable '[]
instance (ShaderType x, Typeable x, StaticSTList xs, IsMember x xs ~ 'False) => StaticSTList (x : xs)
instance StaticSTList '[]
instance (ShaderType x, Typeable x, StaticList xs) => StaticList (x : xs)
instance StaticList '[]

module FWGL.Shader.Stages

-- | A <a>Shader</a> with a <a>VertexShaderOutput</a> output.
type VertexShader g i o = Shader g i (VertexShaderOutput : o)

-- | The condition for a valid <a>VertexShader</a>.
type ValidVertex g i o = (Valid g i o, IsMember VertexShaderOutput o ~ False)

-- | A <a>Shader</a> with only a <a>FragmentShaderOutput</a> output.
type FragmentShader g i = Shader g i (FragmentShaderOutput : [])

-- | The position of the vertex.
newtype VertexShaderOutput
Vertex :: V4 -> VertexShaderOutput

-- | The RGBA color of the fragment (1.0 = #FF).
newtype FragmentShaderOutput
Fragment :: V4 -> FragmentShaderOutput
instance Typeable VertexShaderOutput
instance Typeable FragmentShaderOutput
instance ShaderType VertexShaderOutput
instance ShaderType FragmentShaderOutput

module FWGL.Shader.GLSL
vertexToGLSLAttr :: ValidVertex g i o => VertexShader g i o -> (String, [(String, Int)])
vertexToGLSL :: ValidVertex g i o => VertexShader g i o -> String
fragmentToGLSL :: Valid g i [] => FragmentShader g i -> String
shaderToGLSL :: String -> String -> String -> ShaderVars -> [(String, String)] -> String
exprToGLSL :: Expr -> String
globalName :: Typeable t => t -> String
attributeName :: Typeable t => t -> String

module FWGL.Internal.GL
data GL a
newtype ActiveTexture
ActiveTexture :: Word -> ActiveTexture

-- | Lift a computation from the <a>IO</a> monad.
liftIO :: MonadIO m => forall a. IO a -> m a
evalGL :: GL a -> Ctx -> IO a
forkGL :: GLES => GL () -> GL ThreadId
asyncGL :: GLES => GL a -> (a -> GL ()) -> GL ()
getCtx :: GLES => GL Ctx
activeTexture :: GLES => GLEnum -> GL ()
attachShader :: GLES => Program -> Shader -> GL ()
bindAttribLocation :: GLES => Program -> GLUInt -> GLString -> GL ()
bindBuffer :: GLES => GLEnum -> Buffer -> GL ()
bindFramebuffer :: GLES => GLEnum -> FrameBuffer -> GL ()
bindRenderbuffer :: GLES => GLEnum -> RenderBuffer -> GL ()
bindTexture :: GLES => GLEnum -> Texture -> GL ()
blendColor :: GLES => Float -> Float -> Float -> Float -> GL ()
blendEquation :: GLES => GLEnum -> GL ()
blendEquationSeparate :: GLES => GLEnum -> GLEnum -> GL ()
blendFunc :: GLES => GLEnum -> GLEnum -> GL ()
blendFuncSeparate :: GLES => GLEnum -> GLEnum -> GLEnum -> GLEnum -> GL ()
bufferData :: GLES => GLEnum -> Array -> GLEnum -> GL ()
bufferSubData :: GLES => GLEnum -> GLPtrDiff -> Array -> GL ()
checkFramebufferStatus :: GLES => GLEnum -> GL GLEnum
clear :: GLES => GLEnum -> GL ()
clearColor :: GLES => Float -> Float -> Float -> Float -> GL ()
clearDepth :: GLES => Float -> GL ()
clearStencil :: GLES => GLInt -> GL ()
colorMask :: GLES => GLBool -> GLBool -> GLBool -> GLBool -> GL ()
compileShader :: GLES => Shader -> GL ()
compressedTexImage2D :: GLES => GLEnum -> GLInt -> GLEnum -> GLSize -> GLSize -> GLInt -> Array -> GL ()
compressedTexSubImage2D :: GLES => GLEnum -> GLInt -> GLInt -> GLInt -> GLSize -> GLSize -> GLEnum -> Array -> GL ()
copyTexImage2D :: GLES => GLEnum -> GLInt -> GLEnum -> GLInt -> GLInt -> GLSize -> GLSize -> GLInt -> GL ()
copyTexSubImage2D :: GLES => GLEnum -> GLInt -> GLInt -> GLInt -> GLInt -> GLInt -> GLSize -> GLSize -> GL ()
createBuffer :: GLES => GL Buffer
createFramebuffer :: GLES => GL FrameBuffer
createProgram :: GLES => GL Program
createRenderbuffer :: GLES => GL RenderBuffer
createShader :: GLES => GLEnum -> GL Shader
createTexture :: GLES => GL Texture
cullFace :: GLES => GLEnum -> GL ()
deleteBuffer :: GLES => Buffer -> GL ()
deleteFramebuffer :: GLES => FrameBuffer -> GL ()
deleteProgram :: GLES => Program -> GL ()
deleteRenderbuffer :: GLES => RenderBuffer -> GL ()
deleteShader :: GLES => Shader -> GL ()
deleteTexture :: GLES => Texture -> GL ()
depthFunc :: GLES => GLEnum -> GL ()
depthMask :: GLES => GLBool -> GL ()
depthRange :: GLES => Float -> Float -> GL ()
detachShader :: GLES => Program -> Shader -> GL ()
disable :: GLES => GLEnum -> GL ()
disableVertexAttribArray :: GLES => GLUInt -> GL ()
drawArrays :: GLES => GLEnum -> GLInt -> GLSize -> GL ()
drawElements :: GLES => GLEnum -> GLSize -> GLEnum -> GLPtr -> GL ()
enable :: GLES => GLEnum -> GL ()
enableVertexAttribArray :: GLES => GLUInt -> GL ()
finish :: GLES => GL ()
flush :: GLES => GL ()
framebufferRenderbuffer :: GLES => GLEnum -> GLEnum -> GLEnum -> RenderBuffer -> GL ()
framebufferTexture2D :: GLES => GLEnum -> GLEnum -> GLEnum -> Texture -> GLInt -> GL ()
frontFace :: GLES => GLEnum -> GL ()
generateMipmap :: GLES => GLEnum -> GL ()
getAttribLocation :: GLES => Program -> GLString -> GL GLInt
getError :: GLES => GL GLEnum
getProgramInfoLog :: GLES => Program -> GL GLString
getShaderInfoLog :: GLES => Shader -> GL GLString
getShaderSource :: GLES => Shader -> GL GLString
getUniformLocation :: GLES => Program -> GLString -> GL UniformLocation
hint :: GLES => GLEnum -> GLEnum -> GL ()
isBuffer :: GLES => Buffer -> GL GLBool
isEnabled :: GLES => GLEnum -> GL GLBool
isFramebuffer :: GLES => FrameBuffer -> GL GLBool
isProgram :: GLES => Program -> GL GLBool
isRenderbuffer :: GLES => RenderBuffer -> GL GLBool
isShader :: GLES => Shader -> GL GLBool
isTexture :: GLES => Texture -> GL GLBool
lineWidth :: GLES => Float -> GL ()
linkProgram :: GLES => Program -> GL ()
pixelStorei :: GLES => GLEnum -> GLInt -> GL ()
polygonOffset :: GLES => Float -> Float -> GL ()
readPixels :: GLES => GLInt -> GLInt -> GLSize -> GLSize -> GLEnum -> GLEnum -> Array -> GL ()
renderbufferStorage :: GLES => GLEnum -> GLEnum -> GLSize -> GLSize -> GL ()
sampleCoverage :: GLES => Float -> GLBool -> GL ()
scissor :: GLES => GLInt -> GLInt -> GLSize -> GLSize -> GL ()
shaderSource :: GLES => Shader -> GLString -> GL ()
stencilFunc :: GLES => GLEnum -> GLInt -> GLUInt -> GL ()
stencilFuncSeparate :: GLES => GLEnum -> GLEnum -> GLInt -> GLUInt -> GL ()
stencilMask :: GLES => GLUInt -> GL ()
stencilMaskSeparate :: GLES => GLEnum -> GLUInt -> GL ()
stencilOp :: GLES => GLEnum -> GLEnum -> GLEnum -> GL ()
stencilOpSeparate :: GLES => GLEnum -> GLEnum -> GLEnum -> GLEnum -> GL ()
texImage2DBuffer :: GLES => GLEnum -> GLInt -> GLInt -> GLSize -> GLSize -> GLInt -> GLEnum -> GLEnum -> Array -> GL ()
texImage2DImage :: GLES => GLEnum -> GLInt -> GLInt -> GLEnum -> GLEnum -> Image -> GL ()
texParameterf :: GLES => GLEnum -> GLEnum -> Float -> GL ()
texParameteri :: GLES => GLEnum -> GLEnum -> GLInt -> GL ()
texSubImage2D :: GLES => GLEnum -> GLInt -> GLInt -> GLInt -> GLSize -> GLSize -> GLEnum -> GLEnum -> Array -> GL ()
uniform1f :: GLES => UniformLocation -> Float -> GL ()
uniform1fv :: GLES => UniformLocation -> Float32Array -> GL ()
uniform1i :: GLES => UniformLocation -> GLInt -> GL ()
uniform1iv :: GLES => UniformLocation -> Int32Array -> GL ()
uniform2f :: GLES => UniformLocation -> Float -> Float -> GL ()
uniform2fv :: GLES => UniformLocation -> Float32Array -> GL ()
uniform2i :: GLES => UniformLocation -> GLInt -> GLInt -> GL ()
uniform2iv :: GLES => UniformLocation -> Int32Array -> GL ()
uniform3f :: GLES => UniformLocation -> Float -> Float -> Float -> GL ()
uniform3fv :: GLES => UniformLocation -> Float32Array -> GL ()
uniform3i :: GLES => UniformLocation -> GLInt -> GLInt -> GLInt -> GL ()
uniform3iv :: GLES => UniformLocation -> Int32Array -> GL ()
uniform4f :: GLES => UniformLocation -> Float -> Float -> Float -> Float -> GL ()
uniform4fv :: GLES => UniformLocation -> Float32Array -> GL ()
uniform4i :: GLES => UniformLocation -> GLInt -> GLInt -> GLInt -> GLInt -> GL ()
uniform4iv :: GLES => UniformLocation -> Int32Array -> GL ()
uniformMatrix2fv :: GLES => UniformLocation -> GLBool -> Float32Array -> GL ()
uniformMatrix3fv :: GLES => UniformLocation -> GLBool -> Float32Array -> GL ()
uniformMatrix4fv :: GLES => UniformLocation -> GLBool -> Float32Array -> GL ()
useProgram :: GLES => Program -> GL ()
validateProgram :: GLES => Program -> GL ()
vertexAttrib1f :: GLES => GLUInt -> Float -> GL ()
vertexAttrib1fv :: GLES => GLUInt -> Float32Array -> GL ()
vertexAttrib2f :: GLES => GLUInt -> Float -> Float -> GL ()
vertexAttrib2fv :: GLES => GLUInt -> Float32Array -> GL ()
vertexAttrib3f :: GLES => GLUInt -> Float -> Float -> Float -> GL ()
vertexAttrib3fv :: GLES => GLUInt -> Float32Array -> GL ()
vertexAttrib4f :: GLES => GLUInt -> Float -> Float -> Float -> Float -> GL ()
vertexAttrib4fv :: GLES => GLUInt -> Float32Array -> GL ()
vertexAttribPointer :: GLES => GLUInt -> GLInt -> GLEnum -> GLBool -> GLSize -> GLPtr -> GL ()
viewport :: GLES => GLInt -> GLInt -> GLSize -> GLSize -> GL ()
instance Functor GL
instance Applicative GL
instance Monad GL
instance MonadIO GL

module FWGL.Shader.CPU

-- | CPU types convertible to GPU types (as uniforms).
class Typeable g => UniformCPU c g | g -> c
setUniform :: UniformCPU c g => UniformLocation -> g -> c -> GL ()

-- | CPU types convertible to GPU types (as attributes).
class Typeable g => AttributeCPU c g | g -> c
encodeAttribute :: AttributeCPU c g => g -> [c] -> GL Array
setAttribute :: AttributeCPU c g => g -> GLUInt -> GL ()
attr :: GLES => GLUInt -> GLInt -> GL ()
instance GLES => UniformCPU M4 M4
instance GLES => UniformCPU M3 M3
instance GLES => UniformCPU M2 M2
instance GLES => AttributeCPU V4 V4
instance GLES => UniformCPU V4 V4
instance GLES => AttributeCPU V3 V3
instance GLES => UniformCPU V3 V3
instance GLES => AttributeCPU V2 V2
instance GLES => UniformCPU V2 V2
instance GLES => UniformCPU ActiveTexture Sampler2D
instance GLES => AttributeCPU Float Float
instance GLES => UniformCPU Float Float


-- | An example of shader variable:
--   
--   <pre>
--   newtype Transform2 = Transform2 M3
--           deriving (Typeable,-- This have a name in the shader.
--                     ShaderType, -- This is a type in the GPU (3x3 matrix).
--                     UniformCPU CM3) -- This can be used as an uniform
--                                        and you can set it using a CPU
--                                        3x3 matrix
--                                        (FWGL.Vector.<a>M3</a>).
--   </pre>
--   
--   An example of vertex shader:
--   
--   <pre>
--   vertexShader :: VertexShader
--   -- The types of the uniforms:
--                           '[Transform2, View2, Depth]
--   -- The types of the attributes:
--                           '[Position2, UV]
--   -- The types of the varying (outputs), excluding <a>VertexShaderOutput</a>.
--                           '[UV]
--   vertexShader 
--   -- Set of uniforms:
--                (Transform2 trans :- View2 view :- Depth z :- N)
--   -- Set of attributes:
--                (Position2 (V2 x y) :- uv@(UV _) :- N) =
--   -- Matrix and vector multiplication:
--                   let V3 x' y' _ = view * trans * V3 x y 1
--   -- Set of outputs:
--                   in Vertex (V4 x' y' z 1) -- Vertex position.
--                      :- uv :- N
--   </pre>
--   
--   Required extensions:
--   
--   <pre>
--   {-# LANGUAGE DataKinds, RebindableSyntax, DeriveDataTypeable,
--                GeneralizedNewtypeDeriving, GADTs #-}
--   </pre>
module FWGL.Shader

-- | A function from a (heterogeneous) set of uniforms and a set of inputs
--   (attributes or varyings) to a set of outputs (varyings).
type Shader gs is os = STList gs -> STList is -> STList os

-- | A <a>Shader</a> with a <a>VertexShaderOutput</a> output.
type VertexShader g i o = Shader g i (VertexShaderOutput : o)

-- | A <a>Shader</a> with only a <a>FragmentShaderOutput</a> output.
type FragmentShader g i = Shader g i (FragmentShaderOutput : [])

-- | The position of the vertex.
newtype VertexShaderOutput
Vertex :: V4 -> VertexShaderOutput

-- | The RGBA color of the fragment (1.0 = #FF).
newtype FragmentShaderOutput
Fragment :: V4 -> FragmentShaderOutput

-- | The class <a>Typeable</a> allows a concrete representation of a type
--   to be calculated.
class Typeable (a :: k)
class AllTypeable (xs :: [*])

-- | A type in the GPU.
class ShaderType t

-- | CPU types convertible to GPU types (as uniforms).
class Typeable g => UniformCPU c g | g -> c

-- | CPU types convertible to GPU types (as attributes).
class Typeable g => AttributeCPU c g | g -> c

-- | A GPU float.
data Float

-- | A GPU sampler (sampler2D in GLSL).
data Sampler2D

-- | A GPU 2D vector. NB: This is a different type from
--   FWGL.Vector.<a>V2</a>.
data V2
V2 :: Float -> Float -> V2

-- | A GPU 3D vector.
data V3
V3 :: Float -> Float -> Float -> V3

-- | A GPU 4D vector.
data V4
V4 :: Float -> Float -> Float -> Float -> V4

-- | A GPU 2x2 matrix.
data M2
M2 :: V2 -> V2 -> M2

-- | A GPU 3x3 matrix.
data M3
M3 :: V3 -> V3 -> V3 -> M3

-- | A GPU 4x4 matrix.
data M4
M4 :: V4 -> V4 -> V4 -> V4 -> M4

-- | Floats in the CPU.
type CFloat = Float

-- | Samplers in the CPU.
type CSampler2D = ActiveTexture

-- | 2D vectors in the CPU.
type CV2 = V2

-- | 3D vectors in the CPU.
type CV3 = V3

-- | 4D vectors in the CPU.
type CV4 = V4

-- | 2x2 matrices in the CPU.
type CM2 = M2

-- | 3x3 matrices in the CPU.
type CM3 = M3

-- | 4x4 matrices in the CPU.
type CM4 = M4
negate :: Float -> Float
fromInteger :: Integer -> Float
fromRational :: Rational -> Float
(*) :: (Mul a b c, ShaderType a, ShaderType b, ShaderType c) => a -> b -> c
(/) :: (Mul a b c, ShaderType a, ShaderType b, ShaderType c) => a -> b -> c
(+) :: (Sum a, ShaderType a) => a -> a -> a
(-) :: (Sum a, ShaderType a) => a -> a -> a
(^) :: (ShaderType a, ShaderType b) => a -> b -> a
(&&) :: Bool -> Bool -> Bool
(||) :: Bool -> Bool -> Bool
(==) :: ShaderType a => a -> a -> Bool
(>=) :: ShaderType a => a -> a -> Bool
(<=) :: ShaderType a => a -> a -> Bool
(<) :: ShaderType a => a -> a -> Bool
(>) :: ShaderType a => a -> a -> Bool
abs :: Float -> Float
sign :: Float -> Float
sqrt :: Float -> Float
texture2D :: Sampler2D -> V2 -> V4

-- | An heterogeneous set of <a>ShaderType</a>s and <a>Typeable</a>s.
data STList :: [*] -> *
N :: STList []
(:-) :: a -> STList xs -> STList (a : xs)

-- | Function composition.
(.) :: (b -> c) -> (a -> b) -> a -> c

-- | Identity function.
id :: a -> a

-- | Constant function.
const :: a -> b -> a

-- | <tt><a>flip</a> f</tt> takes its (first) two arguments in the reverse
--   order of <tt>f</tt>.
flip :: (a -> b -> c) -> b -> a -> c

-- | Application operator. This operator is redundant, since ordinary
--   application <tt>(f x)</tt> means the same as <tt>(f <a>$</a> x)</tt>.
--   However, <a>$</a> has low, right-associative binding precedence, so it
--   sometimes allows parentheses to be omitted; for example:
--   
--   <pre>
--   f $ g $ h x  =  f (g (h x))
--   </pre>
--   
--   It is also useful in higher-order situations, such as <tt><a>map</a>
--   (<a>$</a> 0) xs</tt>, or <tt><a>zipWith</a> (<a>$</a>) fs xs</tt>.
($) :: (a -> b) -> a -> b

module FWGL.Shader.Default2D
type Uniforms = '[View2, Image, Depth, Transform2]
type Attributes = '[Position2, UV]

-- | An uniform that represents the texture used in the default 2D shader.
newtype Image
Image :: Sampler2D -> Image

-- | An uniform that represents the depth used in the default 2D shader.
newtype Depth
Depth :: Float -> Depth

-- | An uniform that represents the transformation matrix used in the
--   default 2D shader.
newtype Transform2
Transform2 :: M3 -> Transform2

-- | An uniform that represents the view matrix used in the default 2D
--   shader.
newtype View2
View2 :: M3 -> View2
newtype Position2
Position2 :: V2 -> Position2
newtype UV
UV :: V2 -> UV
vertexShader :: VertexShader '[Transform2, View2, Depth] '[Position2, UV] '[UV]
fragmentShader :: FragmentShader '[Image] '[UV]
instance Typeable Image
instance Typeable Depth
instance Typeable Transform2
instance Typeable View2
instance Typeable Position2
instance Typeable UV
instance ShaderType Image
instance GLES => UniformCPU CSampler2D Image
instance ShaderType Depth
instance GLES => UniformCPU CFloat Depth
instance ShaderType Transform2
instance GLES => UniformCPU CM3 Transform2
instance ShaderType View2
instance GLES => UniformCPU CM3 View2
instance ShaderType Position2
instance GLES => AttributeCPU CV2 Position2
instance ShaderType UV
instance GLES => AttributeCPU CV2 UV

module FWGL.Shader.Default3D
type Uniforms = '[View3, Transform3, Texture2]
type Attributes = '[Position3, UV, Normal3]
newtype Texture2
Texture2 :: Sampler2D -> Texture2
newtype Transform3
Transform3 :: M4 -> Transform3
newtype View3
View3 :: M4 -> View3
newtype Position3
Position3 :: V3 -> Position3
newtype Normal3
Normal3 :: V3 -> Normal3
newtype UV
UV :: V2 -> UV
vertexShader :: VertexShader '[Transform3, View3] '[Position3, UV, Normal3] '[UV, Normal3]
fragmentShader :: FragmentShader '[Texture2] '[UV, Normal3]
instance Typeable Texture2
instance Typeable Transform3
instance Typeable View3
instance Typeable Position3
instance Typeable Normal3
instance Typeable UV
instance ShaderType Texture2
instance GLES => UniformCPU CSampler2D Texture2
instance ShaderType Transform3
instance GLES => UniformCPU CM4 Transform3
instance ShaderType View3
instance GLES => UniformCPU CM4 View3
instance ShaderType Position3
instance GLES => AttributeCPU CV3 Position3
instance ShaderType Normal3
instance GLES => AttributeCPU CV3 Normal3
instance ShaderType UV
instance GLES => AttributeCPU CV2 UV

module FWGL.Geometry
data AttrList (is :: [*])
AttrListNil :: AttrList []
AttrListCons :: g -> [c] -> AttrList gs -> AttrList (g : gs)

-- | A set of attributes and indices.
data Geometry (is :: [*])
Geometry :: (AttrList is) -> [Word16] -> Int -> Geometry

-- | A 2D geometry.
type Geometry2 = '[Position2, UV]

-- | A 3D geometry.
type Geometry3 = '[Position3, UV, Normal3]
data GPUGeometry
GPUGeometry :: [(String, Buffer, GLUInt -> GL ())] -> Buffer -> Int -> GPUGeometry
attributeBuffers :: GPUGeometry -> [(String, Buffer, GLUInt -> GL ())]
elementBuffer :: GPUGeometry -> Buffer
elementCount :: GPUGeometry -> Int

-- | Create a custom <a>Geometry</a>.
mkGeometry :: GLES => AttrList is -> [Word16] -> Geometry is

-- | Create a 2D <a>Geometry</a>. The first two lists should have the same
--   length.
mkGeometry2 :: GLES => [V2] -> [V2] -> [Word16] -> Geometry Geometry2

-- | Create a 3D <a>Geometry</a>. The first three lists should have the
--   same length.
mkGeometry3 :: GLES => [V3] -> [V2] -> [V3] -> [Word16] -> Geometry Geometry3
castGeometry :: Geometry is -> Geometry is'
facesToArrays :: Vector V3 -> Vector V2 -> Vector V3 -> [[(Int, Int, Int)]] -> [(V3, V2, V3)]
arraysToElements :: Foldable f => f (V3, V2, V3) -> ([V3], [V2], [V3], [Word16])
triangulate :: [a] -> [(a, a, a)]
instance GLES => Resource (Geometry i) GPUGeometry GL
instance Eq (Geometry is)
instance Hashable (Geometry is)
instance Hashable (AttrList is)

module FWGL.Shader.Program
data LoadedProgram
LoadedProgram :: !Program -> (HashMap String Int) -> Int -> LoadedProgram

-- | A vertex shader associated with a compatible fragment shader.
data Program (gs :: [*]) (is :: [*])

-- | Create a <a>Program</a> from the shaders.
program :: (ValidVertex vgs vis vos, Valid fgs vos [], Equal pgs (Union vgs fgs)) => VertexShader vgs vis vos -> FragmentShader fgs vos -> Program pgs vis
loadProgram :: GLES => Program g i -> (LoadedProgram -> GL ()) -> GL ()
castProgram :: Program gs is -> Program gs' is'

-- | The uniforms used in the default 2D program.
type DefaultUniforms2D = Uniforms

-- | The attributes used in the default 2D program.
type DefaultAttributes2D = Attributes

-- | The uniforms used in the default 3D program.
type DefaultUniforms3D = Uniforms

-- | The attributes used in the default 3D program.
type DefaultAttributes3D = Attributes
defaultProgram3D :: Program DefaultUniforms3D DefaultAttributes3D
defaultProgram2D :: Program DefaultUniforms2D DefaultAttributes2D
instance GLES => Resource (Program g i) LoadedProgram GL
instance Eq LoadedProgram
instance Hashable LoadedProgram
instance Eq (Program gs is)
instance Hashable (Program gs is)

module FWGL.Graphics.Types

-- | A monad that represents OpenGL actions with some state
--   (<a>DrawState</a>).
newtype Draw a
Draw :: StateT DrawState GL a -> Draw a
unDraw :: Draw a -> StateT DrawState GL a

-- | The state of the <a>Draw</a> monad.
data DrawState
DrawState :: Maybe (Program [] []) -> Maybe LoadedProgram -> ResMap (Program [] []) LoadedProgram -> ResMap (LoadedProgram, String) UniformLocation -> ResMap (Geometry []) GPUGeometry -> ResMap TextureImage LoadedTexture -> DrawState
program :: DrawState -> Maybe (Program [] [])
loadedProgram :: DrawState -> Maybe LoadedProgram
programs :: DrawState -> ResMap (Program [] []) LoadedProgram
uniforms :: DrawState -> ResMap (LoadedProgram, String) UniformLocation
gpuMeshes :: DrawState -> ResMap (Geometry []) GPUGeometry
textureImages :: DrawState -> ResMap TextureImage LoadedTexture
newtype UniformLocation
UniformLocation :: UniformLocation -> UniformLocation

-- | A texture.
data Texture
TextureImage :: TextureImage -> Texture
TextureLoaded :: LoadedTexture -> Texture
data TextureImage
TexturePixels :: [Color] -> GLSize -> GLSize -> Int -> TextureImage
TextureURL :: String -> Int -> TextureImage
data LoadedTexture
LoadedTexture :: GLSize -> GLSize -> Texture -> LoadedTexture

-- | A set of attributes and indices.
data Geometry (is :: [*])
Geometry :: (AttrList is) -> [Word16] -> Int -> Geometry

-- | A static or dinamic geometry.
data Mesh is
Empty :: Mesh []
Cube :: Mesh Geometry3
StaticGeom :: Geometry is -> Mesh is
DynamicGeom :: Geometry is -> Geometry is -> Mesh is

-- | An object is a set of geometries associated with some uniforms. For
--   example, if you want to draw a rotating cube, its vertices, normals,
--   etc. would be the <a>Geometry</a>, the combination of the geometry and
--   the value of the model matrix would be the <a>Object</a>, and the
--   combination of the object with a <a>Program</a> would be the
--   <a>Layer</a>. In fact, <a>Object</a>s are just descriptions of the
--   actions to perform to draw something. Instead, the Element types in
--   <a>FWGL.Graphics.D2</a> and <a>FWGL.Graphics.D3</a> represent managed
--   (high level) objects, and they are ultimately converted to them.
data Object (gs :: [*]) (is :: [*])
ObjectEmpty :: Object gs is
ObjectMesh :: Mesh is -> Object gs is
ObjectGlobal :: g -> Draw c -> Object gs is -> Object gs' is
ObjectAppend :: Object gs is -> Object gs' is' -> Object gs'' is''

-- | An object associated with a program. It can also be a layer included
--   in another.
data Layer
Layer :: (Program pg pi) -> (Object og oi) -> Layer
SubLayer :: Int -> Int -> Layer -> (Texture -> [Layer]) -> Layer
instance Functor Draw
instance Applicative Draw
instance Monad Draw
instance MonadIO Draw

module FWGL.Graphics.Shapes
rectGeometry :: GLES => V2 -> Geometry Geometry2
cubeGeometry :: GLES => Geometry Geometry3

module FWGL.Input

-- | The general input.
data Input
Input :: HashMap InputEvent [EventData] -> Input
inputEvents :: Input -> HashMap InputEvent [EventData]

-- | An event.
data InputEvent
KeyUp :: InputEvent
KeyDown :: InputEvent
MouseUp :: InputEvent
MouseDown :: InputEvent
MouseMove :: InputEvent
Resize :: InputEvent

-- | The data carried by an event.
data EventData
EventData :: Maybe (Int, Int) -> Maybe (Int, Int) -> Maybe MouseButton -> Maybe Key -> EventData
dataFramebufferSize :: EventData -> Maybe (Int, Int)
dataPointer :: EventData -> Maybe (Int, Int)
dataButton :: EventData -> Maybe MouseButton
dataKey :: EventData -> Maybe Key

-- | Keyboard release.
keyUp :: Key -> SF Input (Event ())

-- | Keyboard press.
keyDown :: Key -> SF Input (Event ())

-- | Keyboard down.
key :: Key -> SF Input (Event ())

-- | Mouse press.
mouseDown :: MouseButton -> SF Input (Event (Int, Int))

-- | Mouse release.
mouseUp :: MouseButton -> SF Input (Event (Int, Int))

-- | Mouse down.
mouse :: MouseButton -> SF Input (Event (Int, Int))

-- | Left click.
click :: SF Input (Event (Int, Int))

-- | Pointer location in pixels.
pointer :: SF Input (Int, Int)

-- | Window<i>framebuffer</i>canvas/etc. resize.
resize :: SF Input (Event (Int, Int))

-- | Window<i>framebuffer</i>canvas size.
size :: SF Input (Int, Int)
instance Show InputEvent
instance Eq InputEvent
instance Enum InputEvent
instance Hashable InputEvent

module FWGL.Backend.IO
class GLES => BackendIO
loadImage :: BackendIO => String -> ((Image, Int, Int) -> IO ()) -> IO ()
setup :: BackendIO => (Int -> Int -> Ctx -> IO state) -> (out -> Ctx -> state -> IO state) -> SF Input out -> IO ()

module FWGL.Backend

module FWGL.Geometry.OBJ
data OBJModel
OBJModel :: Vector V3 -> Vector V2 -> Vector V3 -> [[(Int, Int, Int)]] -> OBJModel
objVertices :: OBJModel -> Vector V3
objUVCoords :: OBJModel -> Vector V2
objNormals :: OBJModel -> Vector V3
objFaces :: OBJModel -> [[(Int, Int, Int)]]
loadOBJ :: FilePath -> IO OBJModel
parseOBJ :: String -> OBJModel
attributesOBJ :: OBJModel -> ([V3], [V2], [V3], [Word16])
geometryOBJ :: GLES => OBJModel -> Geometry Geometry3
instance Show OBJModel

module FWGL.Graphics.Texture

-- | Creates a <a>Texture</a> from a list of pixels.
mkTexture :: GLES => Int -> Int -> [Color] -> Texture

-- | Creates a <a>Texture</a> from an URL or a local file.
textureURL :: String -> Texture

-- | The same as <a>textureURL</a>.
textureFile :: String -> Texture
textureHash :: TextureImage -> Int
emptyTexture :: GLES => GL Texture
instance (BackendIO, GLES) => Resource TextureImage LoadedTexture GL
instance Eq TextureImage
instance Hashable TextureImage

module FWGL.Graphics.Draw

-- | A monad that represents OpenGL actions with some state
--   (<a>DrawState</a>).
data Draw a

-- | The state of the <a>Draw</a> monad.
data DrawState

-- | Execute a <a>Draw</a> action.
execDraw :: Draw () -> DrawState -> GL DrawState

-- | Create a <a>DrawState</a>.
drawInit :: (BackendIO, GLES) => Int -> Int -> GL DrawState

-- | Clear the buffers.
drawBegin :: GLES => Draw ()

-- | Draw a <a>Layer</a>.
drawLayer :: (GLES, BackendIO) => Layer -> Draw ()
drawEnd :: GLES => Draw ()
textureUniform :: (GLES, BackendIO) => Texture -> Draw ActiveTexture

-- | Get the dimensions of a <a>Texture</a>.
textureSize :: (GLES, BackendIO, Num a) => Texture -> Draw (a, a)

-- | Set the program.
setProgram :: GLES => Program g i -> Draw ()

-- | Viewport.
resize :: GLES => Int -> Int -> GL ()
instance GLES => Resource (LoadedProgram, String) UniformLocation GL

module FWGL.Graphics.Custom

-- | An object is a set of geometries associated with some uniforms. For
--   example, if you want to draw a rotating cube, its vertices, normals,
--   etc. would be the <a>Geometry</a>, the combination of the geometry and
--   the value of the model matrix would be the <a>Object</a>, and the
--   combination of the object with a <a>Program</a> would be the
--   <a>Layer</a>. In fact, <a>Object</a>s are just descriptions of the
--   actions to perform to draw something. Instead, the Element types in
--   <a>FWGL.Graphics.D2</a> and <a>FWGL.Graphics.D3</a> represent managed
--   (high level) objects, and they are ultimately converted to them.
data Object (gs :: [*]) (is :: [*])

-- | Join two objects.
(~~) :: (Equal gs gs', Equal is is') => Object gs is -> Object gs' is' -> Object (Union gs gs') (Union is is')

-- | Join two objects, even if they don't provide the same variables.
unsafeJoin :: (Equal gs'' (Union gs gs'), Equal is'' (Union is is')) => Object gs is -> Object gs' is' -> Object gs'' is''

-- | An empty custom object.
nothing :: Object [] []

-- | A custom object with a specified <a>Geometry</a>.
static :: Geometry i -> Object [] i

-- | A vertex shader associated with a compatible fragment shader.
data Program (gs :: [*]) (is :: [*])

-- | Create a <a>Program</a> from the shaders.
program :: (ValidVertex vgs vis vos, Valid fgs vos [], Equal pgs (Union vgs fgs)) => VertexShader vgs vis vos -> FragmentShader fgs vos -> Program pgs vis

-- | Sets a global variable (uniform) of an object.
global :: (Typeable g, UniformCPU c g) => g -> c -> Object gs is -> Object (g : gs) is

-- | Sets a global (uniform) of an object using the <a>Draw</a> monad.
globalDraw :: (Typeable g, UniformCPU c g) => g -> Draw c -> Object gs is -> Object (g : gs) is

-- | Sets a global (uniform) of an object using a <a>Texture</a>.
globalTexture :: (BackendIO, Typeable g, UniformCPU ActiveTexture g) => g -> Texture -> Object gs is -> Object (g : gs) is

-- | Sets a global (uniform) of an object using the dimensions of a
--   <a>Texture</a>.
globalTexSize :: (BackendIO, Typeable g, UniformCPU c g) => g -> Texture -> ((Int, Int) -> c) -> Object gs is -> Object (g : gs) is

-- | An object associated with a program. It can also be a layer included
--   in another.
data Layer

-- | Associate an object with a program.
layer :: (Subset oi pi, Subset og pg) => Program pg pi -> Object og oi -> Layer

-- | Use a <a>Layer</a> as a <a>Texture</a> on another.
subLayer :: Int -> Int -> Layer -> (Texture -> [Layer]) -> Layer

-- | A set of attributes and indices.
data Geometry (is :: [*])
data AttrList (is :: [*])
AttrListNil :: AttrList []
AttrListCons :: g -> [c] -> AttrList gs -> AttrList (g : gs)

-- | Create a custom <a>Geometry</a>.
mkGeometry :: GLES => AttrList is -> [Word16] -> Geometry is

-- | A texture.
data Texture

-- | Creates a <a>Texture</a> from a list of pixels.
mkTexture :: GLES => Int -> Int -> [Color] -> Texture

-- | Creates a <a>Texture</a> from an URL or a local file.
textureURL :: String -> Texture

-- | The same as <a>textureURL</a>.
textureFile :: String -> Texture

-- | An RGBA 32-bit color.
data Color
Color :: !Word8 -> !Word8 -> !Word8 -> !Word8 -> Color

-- | Generate a 1x1 texture.
colorTex :: GLES => Color -> Texture

module FWGL.Utils

-- | Generate a view matrix that transforms the pixel coordinates in OpenGL
--   coordinates.
screenScale :: SF Input M3

-- | Generate a perspective view matrix using the aspect ratio of the
--   framebuffer.
perspective4 :: Float -> Float -> Float -> SF Input M4

-- | Combine a perspective and a view matrix.
perspectiveView :: Float -> Float -> Float -> SF (Input, M4) M4


-- | Simplified 2D graphics system.
module FWGL.Graphics.D2

-- | A 2D object with a <a>Texture</a>, a depth and a transformation.
data Element

-- | A rectangle with a specified <a>Texture</a> and size.
rect :: GLES => V2 -> Texture -> Element

-- | A rectangle with the aspect ratio adapted to its texture.
image :: BackendIO => Float -> Texture -> Element

-- | Set the depth of an element.
depth :: Float -> Element -> Element

-- | A rectangle with the size and aspect ratio adapted to the screen. You
--   have to use the <a>screenScale</a> view matrix.
sprite :: BackendIO => Texture -> Element

-- | A set of attributes and indices.
data Geometry (is :: [*])

-- | A 2D geometry.
type Geometry2 = '[Position2, UV]

-- | An element with a specified <a>Geometry</a> and <a>Texture</a>.
geom :: Texture -> Geometry Geometry2 -> Element

-- | Create a 2D <a>Geometry</a>. The first two lists should have the same
--   length.
mkGeometry2 :: GLES => [V2] -> [V2] -> [Word16] -> Geometry Geometry2

-- | A texture.
data Texture

-- | Creates a <a>Texture</a> from an URL or a local file.
textureURL :: String -> Texture

-- | The same as <a>textureURL</a>.
textureFile :: String -> Texture

-- | Generate a 1x1 texture.
colorTex :: GLES => Color -> Texture

-- | Creates a <a>Texture</a> from a list of pixels.
mkTexture :: GLES => Int -> Int -> [Color] -> Texture

-- | Two-dimensional vector.
data V2
V2 :: !Float -> !Float -> V2

-- | Translate an <a>Element</a>.
pos :: V2 -> Element -> Element

-- | Rotate an <a>Element</a>.
rot :: Float -> Element -> Element

-- | Scale an <a>Element</a>.
scale :: Float -> Element -> Element

-- | Scale an <a>Element</a> in two dimensions.
scaleV :: V2 -> Element -> Element

-- | Transform an <a>Element</a>.
transform :: M3 -> Element -> Element

-- | An object associated with a program. It can also be a layer included
--   in another.
data Layer

-- | Create a standard <a>Layer</a> from a list of <a>Element</a>s.
elements :: BackendIO => [Element] -> Layer

-- | Create a <a>Layer</a> from a view matrix and a list of
--   <a>Element</a>s.
view :: BackendIO => M3 -> [Element] -> Layer

-- | A vertex shader associated with a compatible fragment shader.
data Program (gs :: [*]) (is :: [*])

-- | Create a <a>Layer</a> from a 2D <a>Object</a>, using the default
--   shader.
layer :: BackendIO => Object DefaultUniforms2D Geometry2 -> Layer

-- | Create a <a>Layer</a> from a 2D <a>Object</a>, using a custom shader.
layerPrg :: (BackendIO, Subset og pg) => Program pg Geometry2 -> Object og Geometry2 -> Layer

-- | Create a <a>Program</a> from the shaders.
program :: (ValidVertex vgs vis vos, Valid fgs vos [], Equal pgs (Union vgs fgs)) => VertexShader vgs vis vos -> FragmentShader fgs vos -> Program pgs vis

-- | Use a <a>Layer</a> as a <a>Texture</a> on another.
subLayer :: Int -> Int -> Layer -> (Texture -> [Layer]) -> Layer

-- | An object is a set of geometries associated with some uniforms. For
--   example, if you want to draw a rotating cube, its vertices, normals,
--   etc. would be the <a>Geometry</a>, the combination of the geometry and
--   the value of the model matrix would be the <a>Object</a>, and the
--   combination of the object with a <a>Program</a> would be the
--   <a>Layer</a>. In fact, <a>Object</a>s are just descriptions of the
--   actions to perform to draw something. Instead, the Element types in
--   <a>FWGL.Graphics.D2</a> and <a>FWGL.Graphics.D3</a> represent managed
--   (high level) objects, and they are ultimately converted to them.
data Object (gs :: [*]) (is :: [*])

-- | Create a graphical <a>Object</a> from a list of <a>Element</a>s and a
--   view matrix.
object :: BackendIO => M3 -> [Element] -> Object DefaultUniforms2D Geometry2

-- | Create a graphical <a>Object</a> from a single <a>Element</a>. This
--   lets you set your own globals individually. If the shader uses the
--   view matrix <a>View2</a> (e.g. the default 2D shader), you have to set
--   it with <a>viewObject</a>.
object1 :: BackendIO => Element -> Object '[Image, Depth, Transform2] Geometry2

-- | Join two objects.
(~~) :: (Equal gs gs', Equal is is') => Object gs is -> Object gs' is' -> Object (Union gs gs') (Union is is')

-- | Sets a global variable (uniform) of an object.
global :: (Typeable g, UniformCPU c g) => g -> c -> Object gs is -> Object (g : gs) is

-- | Sets a global (uniform) of an object using a <a>Texture</a>.
globalTexture :: (BackendIO, Typeable g, UniformCPU ActiveTexture g) => g -> Texture -> Object gs is -> Object (g : gs) is

-- | Sets a global (uniform) of an object using the dimensions of a
--   <a>Texture</a>.
globalTexSize :: (BackendIO, Typeable g, UniformCPU c g) => g -> Texture -> ((Int, Int) -> c) -> Object gs is -> Object (g : gs) is

-- | Set the value of the view matrix of a 2D <a>Object</a>.
viewObject :: BackendIO => M3 -> Object gs Geometry2 -> Object (View2 : gs) Geometry2

-- | The uniforms used in the default 2D program.
type DefaultUniforms2D = Uniforms

-- | An uniform that represents the texture used in the default 2D shader.
data Image

-- | An uniform that represents the depth used in the default 2D shader.
data Depth

-- | An uniform that represents the transformation matrix used in the
--   default 2D shader.
data Transform2

-- | An uniform that represents the view matrix used in the default 2D
--   shader.
data View2

-- | Three-dimensional vector.
data V3
V3 :: !Float -> !Float -> !Float -> V3

-- | 3x3 matrix.
data M3
M3 :: !V3 -> !V3 -> !V3 -> M3

-- | Create a 3x3 matrix.
mat3 :: (Float, Float, Float, Float, Float, Float, Float, Float, Float) -> M3

-- | 3x3 matrix multiplication.
mul3 :: M3 -> M3 -> M3

-- | The identity 3x3 matrix.
idMat3 :: M3

-- | 3x3 translation matrix.
transMat3 :: V2 -> M3

-- | 3x3 rotation matrix.
rotMat3 :: Float -> M3

-- | 3x3 scale matrix.
scaleMat3 :: V2 -> M3


-- | Simplified 3D graphics system.
module FWGL.Graphics.D3

-- | A 3D object with a <a>Texture</a> and a transformation.
data Element

-- | A cube with a specified <a>Texture</a>.
cube :: GLES => Texture -> Element

-- | A set of attributes and indices.
data Geometry (is :: [*])

-- | A 3D geometry.
type Geometry3 = '[Position3, UV, Normal3]

-- | An element with a specified <a>Geometry</a> and <a>Texture</a>.
geom :: Texture -> Geometry Geometry3 -> Element

-- | Create a 3D <a>Geometry</a>. The first three lists should have the
--   same length.
mkGeometry3 :: GLES => [V3] -> [V2] -> [V3] -> [Word16] -> Geometry Geometry3

-- | A texture.
data Texture

-- | Creates a <a>Texture</a> from an URL or a local file.
textureURL :: String -> Texture

-- | The same as <a>textureURL</a>.
textureFile :: String -> Texture

-- | Generate a 1x1 texture.
colorTex :: GLES => Color -> Texture

-- | Creates a <a>Texture</a> from a list of pixels.
mkTexture :: GLES => Int -> Int -> [Color] -> Texture

-- | Three-dimensional vector.
data V3
V3 :: !Float -> !Float -> !Float -> V3

-- | Translate an <a>Element</a>.
pos :: V3 -> Element -> Element

-- | Rotate an <a>Element</a> around the X axis.
rotX :: Float -> Element -> Element

-- | Rotate an <a>Element</a> around the X axis.
rotY :: Float -> Element -> Element

-- | Rotate an <a>Element</a> around the X axis.
rotZ :: Float -> Element -> Element

-- | Rotate an <a>Element</a> around an axis and an angle.
rotAA :: V3 -> Float -> Element -> Element

-- | Scale an <a>Element</a>.
scale :: Float -> Element -> Element

-- | Scale an <a>Element</a> in three dimensions.
scaleV :: V3 -> Element -> Element

-- | Transform an <a>Element</a>.
transform :: M4 -> Element -> Element

-- | An object associated with a program. It can also be a layer included
--   in another.
data Layer

-- | Create a standard <a>Layer</a> from a list of <a>Element</a>s.
elements :: BackendIO => [Element] -> Layer

-- | Create a <a>Layer</a> from a view matrix and a list of
--   <a>Element</a>s.
view :: BackendIO => M4 -> [Element] -> Layer

-- | A vertex shader associated with a compatible fragment shader.
data Program (gs :: [*]) (is :: [*])

-- | Create a <a>Layer</a> from a 3D <a>Object</a>, using the default
--   shader.
layer :: BackendIO => Object DefaultUniforms3D Geometry3 -> Layer

-- | Create a <a>Layer</a> from a 3D <a>Object</a>, using a custom shader.
layerPrg :: (BackendIO, Subset og pg) => Program pg Geometry3 -> Object og Geometry3 -> Layer
program :: DrawState -> Maybe (Program [] [])

-- | Use a <a>Layer</a> as a <a>Texture</a> on another.
subLayer :: Int -> Int -> Layer -> (Texture -> [Layer]) -> Layer

-- | An object is a set of geometries associated with some uniforms. For
--   example, if you want to draw a rotating cube, its vertices, normals,
--   etc. would be the <a>Geometry</a>, the combination of the geometry and
--   the value of the model matrix would be the <a>Object</a>, and the
--   combination of the object with a <a>Program</a> would be the
--   <a>Layer</a>. In fact, <a>Object</a>s are just descriptions of the
--   actions to perform to draw something. Instead, the Element types in
--   <a>FWGL.Graphics.D2</a> and <a>FWGL.Graphics.D3</a> represent managed
--   (high level) objects, and they are ultimately converted to them.
data Object (gs :: [*]) (is :: [*])

-- | Create a graphical <a>Object</a> from a list of <a>Element</a>s and a
--   view matrix.
object :: BackendIO => M4 -> [Element] -> Object DefaultUniforms3D Geometry3

-- | Create a graphical <a>Object</a> from a single <a>Element</a>. This
--   lets you set your own globals individually. If the shader uses the
--   view matrix <a>View3</a> (e.g. the default 3D shader), you have to set
--   it with <a>viewObject</a>.
object1 :: BackendIO => Element -> Object '[Transform3, Texture2] Geometry3

-- | Join two objects.
(~~) :: (Equal gs gs', Equal is is') => Object gs is -> Object gs' is' -> Object (Union gs gs') (Union is is')

-- | Sets a global variable (uniform) of an object.
global :: (Typeable g, UniformCPU c g) => g -> c -> Object gs is -> Object (g : gs) is

-- | Sets a global (uniform) of an object using a <a>Texture</a>.
globalTexture :: (BackendIO, Typeable g, UniformCPU ActiveTexture g) => g -> Texture -> Object gs is -> Object (g : gs) is

-- | Sets a global (uniform) of an object using the dimensions of a
--   <a>Texture</a>.
globalTexSize :: (BackendIO, Typeable g, UniformCPU c g) => g -> Texture -> ((Int, Int) -> c) -> Object gs is -> Object (g : gs) is

-- | Set the value of the view matrix of a 3D <a>Object</a>.
viewObject :: BackendIO => M4 -> Object gs Geometry3 -> Object (View3 : gs) Geometry3

-- | The uniforms used in the default 3D program.
type DefaultUniforms3D = Uniforms
data Texture2
data Transform3
data View3

-- | Four-dimensional vector.
data V4
V4 :: !Float -> !Float -> !Float -> !Float -> V4

-- | 4x4 matrix.
data M4
M4 :: !V4 -> !V4 -> !V4 -> !V4 -> M4

-- | Create a 4x4 matrix.
mat4 :: (Float, Float, Float, Float, Float, Float, Float, Float, Float, Float, Float, Float, Float, Float, Float, Float) -> M4

-- | 4x4 matrix multiplication.
mul4 :: M4 -> M4 -> M4

-- | 4x4 perspective matrix.
perspectiveMat4 :: Float -> Float -> Float -> Float -> M4

-- | 4x4 FPS camera matrix.
cameraMat4 :: V3 -> Float -> Float -> M4

-- | 4x4 identity matrix.
idMat4 :: M4

-- | 4x4 translation matrix.
transMat4 :: V3 -> M4

-- | 4x4 rotation matrix (X axis).
rotXMat4 :: Float -> M4

-- | 4x4 rotation matrix (Y axis).
rotYMat4 :: Float -> M4

-- | 4x4 rotation matrix (Z axis).
rotZMat4 :: Float -> M4

-- | 4x4 rotation matrix.
rotAAMat4 :: V3 -> Float -> M4

-- | 4x4 scale matrix.
scaleMat4 :: V3 -> M4

module FWGL.Audio

-- | It doesn't do anything (for now).
data Audio
Audio :: Audio


-- | The main module. You should also import a backend:
--   
--   <ul>
--   <li>FWGL.Backend.JavaScript: GHCJS/WebGL backend (contained in
--   fwgl-javascript)</li>
--   <li>FWGL.Backend.GLFW.GL20: GLFW/OpenGL 2.0 backend (contained in
--   fwgl-glfw)</li>
--   <li>FWGL.Backend.GLFW.GLES20: GLFW/OpenGL ES 2.0 backend (WIP)</li>
--   </ul>
--   
--   And a graphics system:
--   
--   <ul>
--   <li><a>FWGL.Graphics.D2</a>: 2D graphics</li>
--   <li><a>FWGL.Graphics.D3</a>: 3D graphics</li>
--   <li><a>FWGL.Graphics.Custom</a>: advanced custom
--   graphics<a>FWGL.Shader</a> contains the EDSL to make custom
--   shaders.</li>
--   </ul>
module FWGL

-- | The general output.
data Output
Output :: [Layer] -> Audio -> Output

-- | Run a FWGL program.
run :: BackendIO => SF Input Output -> IO ()
