-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | 3D rendering engine written entirely in Haskell
--   
--   LambdaCube is a 3D rendering engine written entirely in Haskell. It
--   targets newer graphics hardware. The engine uses Ogre3D's mesh and
--   material file format. The main goal of this project is to provide a
--   modern and feature rich graphical backend for various Haskell projects
--   (e.g. FRP libraries).
--   
--   While the interface looks huge on the surface, the only part of
--   interest to application developers is the <a>Graphics.LambdaCube</a>
--   module, and possibly <a>Graphics.LambdaCube.Loader.StbImage</a>. The
--   rest is only exposed to make low-level interfacing possible.
@package lambdacube-engine
@version 0.2.4

module Graphics.LambdaCube.Tree
data IndexedTree a
IT :: String -> (Trie a) -> (Trie ByteString) -> IndexedTree a
separator :: ByteString
sep :: Char
root :: String -> a -> IndexedTree a
addNode :: String -> String -> a -> IndexedTree a -> Maybe (IndexedTree a)
deleteNode :: String -> IndexedTree a -> IndexedTree a
updateNode :: (a -> a) -> String -> IndexedTree a -> IndexedTree a
getDataAt :: String -> IndexedTree a -> Maybe a
flattenTree :: (a -> b -> a) -> (a -> b -> r) -> a -> IndexedTree b -> [r]
nextName :: String -> String
instance Show a => Show (IndexedTree a)

module Graphics.LambdaCube.Loader.Generated.ResourceScriptScanner
tokenize :: String -> String -> [Token]

module Graphics.LambdaCube.Loader.Generated.MaterialScriptScanner
tokenize :: String -> String -> [Token]

module Graphics.LambdaCube.Loader.Generated.CompositorScriptScanner
tokenize :: String -> String -> [Token]

module Graphics.LambdaCube.HardwareOcclusionQuery
class HardwareOcclusionQuery a
beginOcclusionQuery :: HardwareOcclusionQuery a => a -> IO ()
endOcclusionQuery :: HardwareOcclusionQuery a => a -> IO ()
pullOcclusionQuery :: HardwareOcclusionQuery a => a -> IO Int
isStillOutstanding :: HardwareOcclusionQuery a => a -> IO Bool

module Graphics.LambdaCube.RenderSystem.GL.OcclusionQuery
data GLOcclusionQuery
GLOcclusionQuery :: GLuint -> GLOcclusionQuery
gloqQueryObject :: GLOcclusionQuery -> GLuint
mkGLOcclusionQuery :: IO GLOcclusionQuery
rmGLOcclusionQuery :: GLOcclusionQuery -> IO ()
glBeginOcclusionQuery :: GLOcclusionQuery -> IO ()
glEndOcclusionQuery :: GLOcclusionQuery -> IO ()
glPullOcclusionQuery :: GLOcclusionQuery -> IO Int
glStillOutstanding :: GLOcclusionQuery -> IO Bool
instance HardwareOcclusionQuery GLOcclusionQuery

module Graphics.LambdaCube.HardwareBuffer
data Usage

-- | Static buffer which the application rarely modifies once created.
--   Modifying the contents of this buffer will involve a performance hit.
HBU_STATIC :: Usage

-- | Indicates the application would like to modify this buffer with the
--   CPU fairly often. Buffers created with this flag will typically end up
--   in AGP memory rather than video memory.
HBU_DYNAMIC :: Usage

-- | Indicates the application will never read the contents of the buffer
--   back, it will only ever write data. Locking a buffer with this flag
--   will ALWAYS return a pointer to new, blank memory rather than the
--   memory associated with the contents of the buffer; this avoids DMA
--   stalls because you can write to a new memory area while the previous
--   one is being used.
HBU_WRITE_ONLY :: Usage

-- | Indicates that the application will be refilling the contents of the
--   buffer regularly (not just updating, but generating the contents from
--   scratch), and therefore does not mind if the contents of the buffer
--   are lost somehow and need to be recreated. This allows and additional
--   level of optimisation on the buffer. This option only really makes
--   sense when combined with HBU_DYNAMIC_WRITE_ONLY.
HBU_DISCARDABLE :: Usage

-- | Combination of HBU_STATIC and HBU_WRITE_ONLY
HBU_STATIC_WRITE_ONLY :: Usage

-- | Combination of HBU_DYNAMIC and HBU_WRITE_ONLY. If you use this,
--   strongly consider using HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE instead if
--   you update the entire contents of the buffer very regularly.
HBU_DYNAMIC_WRITE_ONLY :: Usage

-- | Combination of HBU_DYNAMIC, HBU_WRITE_ONLY and HBU_DISCARDABLE
HBU_DYNAMIC_WRITE_ONLY_DISCARDABLE :: Usage

-- | Locking options
data LockOptions

-- | Normal mode, ie allows read/write and contents are preserved.
HBL_NORMAL :: LockOptions

-- | Discards the entire buffer while locking; this allows optimisation to
--   be performed because synchronisation issues are relaxed. Only allowed
--   on buffers created with the HBU_DYNAMIC flag.
HBL_DISCARD :: LockOptions

-- | Lock the buffer for reading only. Not allowed in buffers which are
--   created with HBU_WRITE_ONLY. Mandatory on static buffers, i.e. those
--   created without the HBU_DYNAMIC flag.
HBL_READ_ONLY :: LockOptions

-- | As HBL_NORMAL, except the application guarantees not to overwrite any
--   region of the buffer which has already been used in this frame, can
--   allow some optimisation on some APIs.
HBL_NO_OVERWRITE :: LockOptions
class Ord a => HardwareBuffer a
lock :: HardwareBuffer a => a -> Int -> Int -> LockOptions -> IO (Ptr Word8)
unlock :: HardwareBuffer a => a -> IO ()
getSizeInBytes :: HardwareBuffer a => a -> Int
getUsage :: HardwareBuffer a => a -> Usage
isSystemMemory :: HardwareBuffer a => a -> Bool
hasShadowBuffer :: HardwareBuffer a => a -> Bool
isLocked :: HardwareBuffer a => a -> IO Bool
instance Eq Usage
instance Ord Usage
instance Eq LockOptions
instance Ord LockOptions

module Graphics.LambdaCube.GpuProgramUsage
data GpuProgramUsage
GpuProgramUsage :: String -> GpuProgramUsage
gpuProgramName :: GpuProgramUsage -> String
instance Eq GpuProgramUsage
instance Ord GpuProgramUsage

module Graphics.LambdaCube.HardwareVertexBuffer
class HardwareBuffer a => HardwareVertexBuffer a
getVertexSize :: HardwareVertexBuffer a => a -> Int
getNumVertices :: HardwareVertexBuffer a => a -> Int

-- | Vertex element semantics, used to identify the meaning of vertex
--   buffer contents
data VertexElementSemantic

-- | Position, 3 reals per vertex
VES_POSITION :: VertexElementSemantic

-- | Blending weights
VES_BLEND_WEIGHTS :: VertexElementSemantic

-- | Blending indices
VES_BLEND_INDICES :: VertexElementSemantic

-- | Normal, 3 reals per vertex
VES_NORMAL :: VertexElementSemantic

-- | Diffuse colours
VES_DIFFUSE :: VertexElementSemantic

-- | Specular colours
VES_SPECULAR :: VertexElementSemantic

-- | Texture coordinates
VES_TEXTURE_COORDINATES :: VertexElementSemantic

-- | Binormal (Y axis if normal is Z)
VES_BINORMAL :: VertexElementSemantic

-- | Tangent (X axis if normal is Z)
VES_TANGENT :: VertexElementSemantic

-- | Vertex element type, used to identify the base types of the vertex
--   contents
data VertexElementType
VET_FLOAT1 :: VertexElementType
VET_FLOAT2 :: VertexElementType
VET_FLOAT3 :: VertexElementType
VET_FLOAT4 :: VertexElementType
VET_SHORT1 :: VertexElementType
VET_SHORT2 :: VertexElementType
VET_SHORT3 :: VertexElementType
VET_SHORT4 :: VertexElementType
VET_UBYTE4 :: VertexElementType

-- | D3D style compact colour
VET_COLOUR_ARGB :: VertexElementType

-- | GL style compact colour
VET_COLOUR_ABGR :: VertexElementType
data VertexElement
VertexElement :: Int -> Int -> VertexElementType -> VertexElementSemantic -> Int -> VertexElement

-- | The source vertex buffer, as bound to an index using
--   VertexBufferBinding
veSource :: VertexElement -> Int

-- | The offset in the buffer that this element starts at
veOffset :: VertexElement -> Int

-- | The type of element
veType :: VertexElement -> VertexElementType

-- | The meaning of the element
veSemantic :: VertexElement -> VertexElementSemantic

-- | Index of the item, only applicable for some elements like texture
--   coords
veIndex :: VertexElement -> Int

-- | Utility method for helping to calculate offsets
getTypeSize :: VertexElementType -> Int

-- | Utility method which returns the count of values in a given type
getTypeCount :: VertexElementType -> Int

-- | Simple converter function which will turn a single-value type into a
--   multi-value type based on a parameter.
multiplyTypeCount :: VertexElementType -> Int -> VertexElementType

-- | Simple converter function which will convert a type into its
--   single-value equivalent to make switches on type easier.
getBaseType :: VertexElementType -> VertexElementType
data VertexDeclaration
VertexDeclaration :: [VertexElement] -> VertexDeclaration

-- | The list of vertex elements that makes up this declaration
vdElementList :: VertexDeclaration -> [VertexElement]
data HardwareVertexBuffer vb => VertexBufferBinding vb
VertexBufferBinding :: IntMap vb -> VertexBufferBinding vb
vbbBindingMap :: VertexBufferBinding vb -> IntMap vb
instance Enum VertexElementSemantic
instance Eq VertexElementSemantic
instance Ord VertexElementSemantic
instance Show VertexElementSemantic
instance Eq VertexElementType
instance Ord VertexElementType
instance Show VertexElementType
instance Eq VertexElement
instance Ord VertexElement
instance Show VertexElement
instance Eq VertexDeclaration
instance Ord VertexDeclaration
instance Show VertexDeclaration
instance HardwareVertexBuffer vb => Eq (VertexBufferBinding vb)
instance HardwareVertexBuffer vb => Ord (VertexBufferBinding vb)

module Graphics.LambdaCube.HardwareIndexBuffer
data IndexType
IT_16BIT :: IndexType
IT_32BIT :: IndexType
class HardwareBuffer a => HardwareIndexBuffer a
getIndexType :: HardwareIndexBuffer a => a -> IndexType
getNumIndexes :: HardwareIndexBuffer a => a -> Int
getIndexSize :: HardwareIndexBuffer a => a -> Int
instance Eq IndexType
instance Ord IndexType
instance Show IndexType

module Graphics.LambdaCube.VertexIndexData
data HardwareVertexBuffer vb => VertexData vb
VertexData :: VertexDeclaration -> VertexBufferBinding vb -> Int -> Int -> VertexData vb

-- | Declaration of the vertex to be used in this operation. remarks Note
--   that this is created for you on construction.
vdVertexDeclaration :: VertexData vb -> VertexDeclaration

-- | The vertex buffer bindings to be used. remarks Note that this is
--   created for you on construction.
vdVertexBufferBinding :: VertexData vb -> VertexBufferBinding vb

-- | The base vertex index to start from
vdVertexStart :: VertexData vb -> Int

-- | The number of vertices used in this operation
vdVertexCount :: VertexData vb -> Int
data HardwareIndexBuffer ib => IndexData ib
IndexData :: ib -> Int -> Int -> IndexData ib

-- | pointer to the HardwareIndexBuffer to use, must be specified if
--   useIndexes = true
idIndexBuffer :: IndexData ib -> ib

-- | index in the buffer to start from for this operation
idIndexStart :: IndexData ib -> Int

-- | The number of indexes to use from the buffer
idIndexCount :: IndexData ib -> Int
instance HardwareVertexBuffer vb => Eq (VertexData vb)
instance HardwareVertexBuffer vb => Ord (VertexData vb)
instance HardwareIndexBuffer ib => Eq (IndexData ib)
instance HardwareIndexBuffer ib => Ord (IndexData ib)

module Graphics.LambdaCube.PixelFormat

-- | The pixel format used for images, textures, and render surfaces
data PixelFormat

-- | Unknown pixel format.
PF_UNKNOWN :: PixelFormat

-- | 8-bit pixel format, all bits luminace. | PF_BYTE_L = PF_L8
PF_L8 :: PixelFormat

-- | 16-bit pixel format, all bits luminace. | PF_SHORT_L = PF_L16
PF_L16 :: PixelFormat

-- | 8-bit pixel format, all bits alpha. | PF_BYTE_A = PF_A8
PF_A8 :: PixelFormat

-- | 8-bit pixel format, 4 bits alpha, 4 bits luminance.
PF_A4L4 :: PixelFormat

-- | 2 byte pixel format, 1 byte luminance, 1 byte alpha
PF_BYTE_LA :: PixelFormat

-- | 16-bit pixel format, 5 bits red, 6 bits green, 5 bits blue.
PF_R5G6B5 :: PixelFormat

-- | 16-bit pixel format, 5 bits red, 6 bits green, 5 bits blue.
PF_B5G6R5 :: PixelFormat

-- | 8-bit pixel format, 2 bits blue, 3 bits green, 3 bits red.
PF_R3G3B2 :: PixelFormat

-- | 16-bit pixel format, 4 bits for alpha, red, green and blue.
PF_A4R4G4B4 :: PixelFormat

-- | 16-bit pixel format, 5 bits for blue, green, red and 1 for alpha.
PF_A1R5G5B5 :: PixelFormat

-- | 24-bit pixel format, 8 bits for red, green and blue.
PF_R8G8B8 :: PixelFormat

-- | 24-bit pixel format, 8 bits for blue, green and red.
PF_B8G8R8 :: PixelFormat

-- | 32-bit pixel format, 8 bits for alpha, red, green and blue.
PF_A8R8G8B8 :: PixelFormat

-- | 32-bit pixel format, 8 bits for blue, green, red and alpha.
PF_A8B8G8R8 :: PixelFormat

-- | 32-bit pixel format, 8 bits for blue, green, red and alpha.
PF_B8G8R8A8 :: PixelFormat

-- | 32-bit pixel format, 8 bits for red, green, blue and alpha.
PF_R8G8B8A8 :: PixelFormat

-- | 32-bit pixel format, 8 bits for red, 8 bits for green, 8 bits for
--   blue; like PF_A8R8G8B8, but alpha will get discarded
PF_X8R8G8B8 :: PixelFormat

-- | 32-bit pixel format, 8 bits for blue, 8 bits for green, 8 bits for
--   red; like PF_A8B8G8R8, but alpha will get discarded
PF_X8B8G8R8 :: PixelFormat

-- | 32-bit pixel format, 2 bits for alpha, 10 bits for red, green and
--   blue.
PF_A2R10G10B10 :: PixelFormat

-- | 32-bit pixel format, 10 bits for blue, green and red, 2 bits for
--   alpha.
PF_A2B10G10R10 :: PixelFormat

-- | DDS (DirectDraw Surface) DXT1 format
PF_DXT1 :: PixelFormat

-- | DDS (DirectDraw Surface) DXT2 format
PF_DXT2 :: PixelFormat

-- | DDS (DirectDraw Surface) DXT3 format
PF_DXT3 :: PixelFormat

-- | DDS (DirectDraw Surface) DXT4 format
PF_DXT4 :: PixelFormat

-- | DDS (DirectDraw Surface) DXT5 format
PF_DXT5 :: PixelFormat

-- | 16-bit pixel format, 16 bits (float) for red
PF_FLOAT16_R :: PixelFormat

-- | 48-bit pixel format, 16 bits (float) for red, 16 bits (float) for
--   green, 16 bits (float) for blue
PF_FLOAT16_RGB :: PixelFormat

-- | 64-bit pixel format, 16 bits (float) for red, 16 bits (float) for
--   green, 16 bits (float) for blue, 16 bits (float) for alpha
PF_FLOAT16_RGBA :: PixelFormat

-- | 16-bit pixel format, 16 bits (float) for red
PF_FLOAT32_R :: PixelFormat

-- | 96-bit pixel format, 32 bits (float) for red, 32 bits (float) for
--   green, 32 bits (float) for blue
PF_FLOAT32_RGB :: PixelFormat

-- | 128-bit pixel format, 32 bits (float) for red, 32 bits (float) for
--   green, 32 bits (float) for blue, 32 bits (float) for alpha
PF_FLOAT32_RGBA :: PixelFormat

-- | 32-bit, 2-channel s10e5 floating point pixel format, 16-bit green,
--   16-bit red
PF_FLOAT16_GR :: PixelFormat

-- | 64-bit, 2-channel floating point pixel format, 32-bit green, 32-bit
--   red
PF_FLOAT32_GR :: PixelFormat

-- | Depth texture format
PF_DEPTH :: PixelFormat

-- | 64-bit pixel format, 16 bits for red, green, blue and alpha
PF_SHORT_RGBA :: PixelFormat

-- | 32-bit pixel format, 16-bit green, 16-bit red
PF_SHORT_GR :: PixelFormat

-- | 48-bit pixel format, 16 bits for red, green and blue
PF_SHORT_RGB :: PixelFormat

-- | Flags defining some on/off properties of pixel formats
data PixelFormatFlags

-- | This format has an alpha channel
PFF_HASALPHA :: PixelFormatFlags

-- | This format is compressed. This invalidates the values in elemBytes,
--   elemBits and the bit counts as these might not be fixed in a
--   compressed format.
PFF_COMPRESSED :: PixelFormatFlags

-- | This is a floating point format
PFF_FLOAT :: PixelFormatFlags

-- | This is a depth format (for depth textures)
PFF_DEPTH :: PixelFormatFlags

-- | Format is in native endian. Generally true for the 16, 24 and 32 bits
--   formats which can be represented as machine integers.
PFF_NATIVEENDIAN :: PixelFormatFlags

-- | This is an intensity format instead of a RGB one. The luminance
--   replaces R,G and B. (but not A)
PFF_LUMINANCE :: PixelFormatFlags

-- | Pixel component format
data PixelComponentType

-- | Byte per component (8 bit fixed 0.0..1.0)
PCT_BYTE :: PixelComponentType

-- | Short per component (16 bit fixed 0.0..1.0))
PCT_SHORT :: PixelComponentType

-- | 16 bit float per component
PCT_FLOAT16 :: PixelComponentType

-- | 32 bit float per component
PCT_FLOAT32 :: PixelComponentType
instance Eq PixelFormat
instance Ord PixelFormat

module Graphics.LambdaCube.Image

-- | Image loader function
type ImageLoader = String -> ByteString -> IO (Maybe Image)

-- | Has information about the size and the pixel format of the image.
data Image
Image :: String -> Int -> Int -> Int -> Int -> PixelFormat -> ByteString -> Image
imName :: Image -> String
imHeight :: Image -> Int
imWidth :: Image -> Int
imDepth :: Image -> Int
imNumMipmaps :: Image -> Int
imFormat :: Image -> PixelFormat

-- | Image can be empty
imData :: Image -> ByteString
imDataPtr :: Image -> Ptr Word8

module Graphics.LambdaCube.Loader.StbImage
loadImage :: ImageLoader

module Graphics.LambdaCube.Common

-- | Comparison functions used for the depth/stencil buffer operations and
--   others.
data CompareFunction
CMPF_ALWAYS_FAIL :: CompareFunction
CMPF_ALWAYS_PASS :: CompareFunction
CMPF_LESS :: CompareFunction
CMPF_LESS_EQUAL :: CompareFunction
CMPF_EQUAL :: CompareFunction
CMPF_NOT_EQUAL :: CompareFunction
CMPF_GREATER_EQUAL :: CompareFunction
CMPF_GREATER :: CompareFunction

-- | High-level filtering options providing shortcuts to settings the
--   minification, magnification and mip filters.
data TextureFilterOptions

-- | Equal to: min=FO_POINT, mag=FO_POINT, mip=FO_NONE
TFO_NONE :: TextureFilterOptions

-- | Equal to: min=FO_LINEAR, mag=FO_LINEAR, mip=FO_POINT
TFO_BILINEAR :: TextureFilterOptions

-- | Equal to: min=FO_LINEAR, mag=FO_LINEAR, mip=FO_LINEAR
TFO_TRILINEAR :: TextureFilterOptions

-- | Equal to: min=FO_ANISOTROPIC, max=FO_ANISOTROPIC, mip=FO_LINEAR
TFO_ANISOTROPIC :: TextureFilterOptions
data FilterType

-- | The filter used when shrinking a texture
FT_MIN :: FilterType

-- | The filter used when magnifying a texture
FT_MAG :: FilterType

-- | The filter used when determining the mipmap
FT_MIP :: FilterType

-- | Filtering options for textures / mipmaps.
data FilterOptions

-- | No filtering, used for FILT_MIP to turn off mipmapping
FO_NONE :: FilterOptions

-- | Use the closest pixel
FO_POINT :: FilterOptions

-- | Average of a 2x2 pixel area, denotes bilinear for MIN and MAG,
--   trilinear for MIP
FO_LINEAR :: FilterOptions

-- | Similar to FO_LINEAR, but compensates for the angle of the texture
--   plane
FO_ANISOTROPIC :: FilterOptions

-- | Light shading modes.
data ShadeOptions
SO_FLAT :: ShadeOptions
SO_GOURAUD :: ShadeOptions
SO_PHONG :: ShadeOptions

-- | Fog modes.
data FogMode

-- | No fog. Duh.
FOG_NONE :: FogMode

-- | Fog density increases exponentially from the camera (fog =
--   1/e^(distance * density))
FOG_EXP :: FogMode

-- | Fog density increases at the square of FOG_EXP, i.e. even quicker (fog
--   = 1/e^(distance * density)^2)
FOG_EXP2 :: FogMode

-- | Fog density increases linearly between the start and end distances
FOG_LINEAR :: FogMode

-- | Hardware culling modes based on vertex winding. This setting applies
--   to how the hardware API culls triangles it is sent.
data CullingMode

-- | Hardware never culls triangles and renders everything it receives.
CULL_NONE :: CullingMode

-- | Hardware culls triangles whose vertices are listed clockwise in the
--   view (default).
CULL_CLOCKWISE :: CullingMode

-- | Hardware culls triangles whose vertices are listed anticlockwise in
--   the view.
CULL_ANTICLOCKWISE :: CullingMode

-- | Manual culling modes based on vertex normals.
data ManualCullingMode

-- | No culling so everything is sent to the hardware.
MANUAL_CULL_NONE :: ManualCullingMode

-- | Cull triangles whose normal is pointing away from the camera
--   (default).
MANUAL_CULL_BACK :: ManualCullingMode

-- | Cull triangles whose normal is pointing towards the camera.
MANUAL_CULL_FRONT :: ManualCullingMode
data WaveformType

-- | Standard sine wave which smoothly changes from low to high and back
--   again.
WFT_SINE :: WaveformType

-- | An angular wave with a constant increase / decrease speed with pointed
--   peaks.
WFT_TRIANGLE :: WaveformType

-- | Half of the time is spent at the min, half at the max with instant
--   transition between.
WFT_SQUARE :: WaveformType

-- | Gradual steady increase from min to max over the period with an
--   instant return to min at the end.
WFT_SAWTOOTH :: WaveformType

-- | Gradual steady decrease from max to min over the period, with an
--   instant return to max at the end.
WFT_INVERSE_SAWTOOTH :: WaveformType

-- | Pulse Width Modulation. Works like WFT_SQUARE, except the high to low
--   transition is controlled by duty cycle. With a duty cycle of 50% (0.5)
--   will give the same output as WFT_SQUARE.
WFT_PWM :: WaveformType

-- | The polygon mode to use when rasterising.
data PolygonMode

-- | Only points are rendered.
PM_POINTS :: PolygonMode

-- | Wireframe models are rendered.
PM_WIREFRAME :: PolygonMode

-- | Solid polygons are rendered.
PM_SOLID :: PolygonMode
data TrackVertexColourType
TrackVertexColourType :: Bool -> Bool -> Bool -> Bool -> TrackVertexColourType
tvcAmbient :: TrackVertexColourType -> Bool
tvcDiffuse :: TrackVertexColourType -> Bool
tvcSpecular :: TrackVertexColourType -> Bool
tvcEmissive :: TrackVertexColourType -> Bool

-- | Sort mode for billboard-set and particle-system
data SortMode

-- | Sort by direction of the camera
SM_DIRECTION :: SortMode

-- | Sort by distance from the camera
SM_DISTANCE :: SortMode
data FrameBufferType
FrameBufferType :: Bool -> Bool -> Bool -> FrameBufferType
fbtColour :: FrameBufferType -> Bool
fbtDepth :: FrameBufferType -> Bool
fbtStencil :: FrameBufferType -> Bool
instance Eq CompareFunction
instance Ord CompareFunction
instance Show CompareFunction
instance Eq TextureFilterOptions
instance Ord TextureFilterOptions
instance Eq FilterType
instance Ord FilterType
instance Eq FilterOptions
instance Ord FilterOptions
instance Eq ShadeOptions
instance Ord ShadeOptions
instance Eq FogMode
instance Ord FogMode
instance Eq CullingMode
instance Ord CullingMode
instance Eq ManualCullingMode
instance Ord ManualCullingMode
instance Eq WaveformType
instance Ord WaveformType
instance Eq PolygonMode
instance Ord PolygonMode
instance Eq TrackVertexColourType
instance Ord TrackVertexColourType
instance Eq SortMode
instance Ord SortMode
instance Eq FrameBufferType
instance Ord FrameBufferType

module Graphics.LambdaCube.RenderOperation

-- | The interpretation of a sequence of vertices.
data OperationType

-- | A list of points, 1 vertex per point.
OT_POINT_LIST :: OperationType

-- | A list of lines, 2 vertices per line.
OT_LINE_LIST :: OperationType

-- | A strip of connected lines, 1 vertex per line plus 1 start vertex.
OT_LINE_STRIP :: OperationType

-- | A list of triangles, 3 vertices per triangle.
OT_TRIANGLE_LIST :: OperationType

-- | A strip of triangles, 3 vertices for the first triangle, and 1 per
--   triangle after that.
OT_TRIANGLE_STRIP :: OperationType

-- | A fan of triangles, 3 vertices for the first triangle, and 1 per
--   triangle after that.
OT_TRIANGLE_FAN :: OperationType
data (HardwareVertexBuffer vb, HardwareIndexBuffer ib) => RenderOperation vb ib
RenderOperation :: VertexData vb -> OperationType -> Maybe (IndexData ib) -> RenderOperation vb ib

-- | Vertex source data
roVertexData :: RenderOperation vb ib -> VertexData vb

-- | The type of operation to perform
roOperationType :: RenderOperation vb ib -> OperationType

-- | Index data - only valid if useIndexes is true
roIndexData :: RenderOperation vb ib -> Maybe (IndexData ib)
instance Eq OperationType
instance Ord OperationType
instance Enum OperationType
instance (HardwareVertexBuffer vb, HardwareIndexBuffer ib) => Eq (RenderOperation vb ib)
instance (HardwareVertexBuffer vb, HardwareIndexBuffer ib) => Ord (RenderOperation vb ib)

module Graphics.LambdaCube.Types

-- | The floating point type used throughout the engine. It is recommended
--   to use this synonym ubiquitously in code interfacing with LambdaCube.
type FloatType = Float
type FloatType2 = (FloatType, FloatType)
type FloatType3 = (FloatType, FloatType, FloatType)
type FloatType4 = (FloatType, FloatType, FloatType, FloatType)
type RGB = FloatType3
type ColourValue = FloatType4

module Graphics.LambdaCube.Utility
groupSetBy :: (a -> a -> Ordering) -> [a] -> [[a]]

-- | Perspective transformation matrix.
perspective :: FloatType -> FloatType -> FloatType -> FloatType -> Mat4

-- | Pure orientation matrix defined by Euler angles.
rotationEuler :: Vec3 -> Proj4

-- | Camera transformation matrix.
lookat :: Vec3 -> Vec3 -> Vec3 -> Proj4
foldM' :: Monad m => (a -> b -> m a) -> a -> [b] -> m a

module Graphics.LambdaCube.Light

-- | Possible types of light sources.
data LightTypes

-- | Point light sources give off light equally in all directions, so they
--   require only position but no direction.
LT_POINT :: LightTypes

-- | Directional lights simulate parallel light beams from a distant
--   source, hence have direction but no position.
LT_DIRECTIONAL :: LightTypes

-- | Spotlights simulate a cone of light from a source so require position
--   and direction, plus extra values for falloff.
LT_SPOTLIGHT :: LightTypes

-- | Light source description.
data Light
Light :: LightTypes -> ColourValue -> ColourValue -> Vec3 -> FloatType -> FloatType -> FloatType -> FloatType -> FloatType -> FloatType -> Light
lgType :: Light -> LightTypes
lgDiffuse :: Light -> ColourValue
lgSpecular :: Light -> ColourValue
lgDirection :: Light -> Vec3
lgSpotOuter :: Light -> FloatType
lgSpotFalloff :: Light -> FloatType
lgRange :: Light -> FloatType
lgAttenuationConst :: Light -> FloatType
lgAttenuationLinear :: Light -> FloatType
lgAttenuationQuad :: Light -> FloatType
instance Eq LightTypes
instance Ord LightTypes
instance Show LightTypes
instance Eq Light
instance Show Light

module Graphics.LambdaCube.AnimationState

-- | Represents the state of an animation and the weight of it's influence.
--   remarks Other classes can hold instances of this class to store the
--   state of any animations they are using.
data AnimationState
AnimationState :: [Float] -> String -> FloatType -> FloatType -> FloatType -> Bool -> Bool -> AnimationState

-- | the blend mask (containing per bone weights)
asBlendMask :: AnimationState -> [Float]
asAnimationName :: AnimationState -> String
asTimePos :: AnimationState -> FloatType
asLength :: AnimationState -> FloatType
asWeight :: AnimationState -> FloatType
asEnabled :: AnimationState -> Bool
asLoop :: AnimationState -> Bool

-- | Class encapsulating a set of AnimationState objects.
data AnimationStateSet
AnimationStateSet :: Int -> Map String AnimationState -> [AnimationState] -> AnimationStateSet
assDirtyFrameNumber :: AnimationStateSet -> Int
assAnimationStates :: AnimationStateSet -> Map String AnimationState

-- | List of enabled animation states
assEnabledAnimationStates :: AnimationStateSet -> [AnimationState]

module Graphics.LambdaCube.BlendMode

-- | Type of texture blend mode.
data LayerBlendType
LBT_COLOUR :: LayerBlendType
LBT_ALPHA :: LayerBlendType

-- | Texture blending operations.
data LayerBlendOperation

-- | replace all colour with texture with no adjustment
LBO_REPLACE :: LayerBlendOperation

-- | add colour components together
LBO_ADD :: LayerBlendOperation

-- | multiply colour components together
LBO_MODULATE :: LayerBlendOperation

-- | blend based on texture alpha
LBO_ALPHA_BLEND :: LayerBlendOperation

-- | Extended texture blending operations.
data LayerBlendOperationEx

-- | use source1 without modification
LBX_SOURCE1 :: LayerBlendOperationEx

-- | use source2 without modification
LBX_SOURCE2 :: LayerBlendOperationEx

-- | multiply source1 and source2 together
LBX_MODULATE :: LayerBlendOperationEx

-- | as LBX_MODULATE but brighten afterwards (x2)
LBX_MODULATE_X2 :: LayerBlendOperationEx

-- | as LBX_MODULATE but brighten more afterwards (x4)
LBX_MODULATE_X4 :: LayerBlendOperationEx

-- | add source1 and source2 together
LBX_ADD :: LayerBlendOperationEx

-- | as LBX_ADD, but subtract 0.5 from the result
LBX_ADD_SIGNED :: LayerBlendOperationEx

-- | as LBX_ADD, but subtract product from the sum
LBX_ADD_SMOOTH :: LayerBlendOperationEx

-- | subtract source2 from source1
LBX_SUBTRACT :: LayerBlendOperationEx

-- | use interpolated alpha value from vertices to scale source1, then add
--   source2 scaled by (1-alpha)
LBX_BLEND_DIFFUSE_ALPHA :: LayerBlendOperationEx

-- | as LBX_BLEND_DIFFUSE_ALPHA, but use alpha from texture
LBX_BLEND_TEXTURE_ALPHA :: LayerBlendOperationEx

-- | as LBX_BLEND_DIFFUSE_ALPHA, but use current alpha from previous stages
LBX_BLEND_CURRENT_ALPHA :: LayerBlendOperationEx

-- | as LBX_BLEND_DIFFUSE_ALPHA but use a constant manual blend value
--   (0.0-1.0)
LBX_BLEND_MANUAL :: LayerBlendOperationEx

-- | dot product of color1 and color2
LBX_DOTPRODUCT :: LayerBlendOperationEx

-- | use interpolated color values from vertices to scale source1, then add
--   source2 scaled by (1-color)
LBX_BLEND_DIFFUSE_COLOUR :: LayerBlendOperationEx

-- | Sources of values for blending operations.
data LayerBlendSource

-- | the colour as built up from previous stages
LBS_CURRENT :: LayerBlendSource

-- | the colour derived from the texture assigned to this layer
LBS_TEXTURE :: LayerBlendSource

-- | the interpolated diffuse colour from the vertices
LBS_DIFFUSE :: LayerBlendSource

-- | the interpolated specular colour from the vertices
LBS_SPECULAR :: LayerBlendSource

-- | a colour supplied manually as a separate argument
LBS_MANUAL :: LayerBlendSource
data LayerBlendModeEx
LayerBlendModeEx :: LayerBlendType -> LayerBlendOperationEx -> LayerBlendSource -> LayerBlendSource -> ColourValue -> ColourValue -> FloatType -> FloatType -> FloatType -> LayerBlendModeEx

-- | The type of blending (colour or alpha)
lbBlendType :: LayerBlendModeEx -> LayerBlendType

-- | The operation to be applied
lbOperation :: LayerBlendModeEx -> LayerBlendOperationEx

-- | The first source of colour/alpha
lbSource1 :: LayerBlendModeEx -> LayerBlendSource

-- | The second source of colour/alpha
lbSource2 :: LayerBlendModeEx -> LayerBlendSource

-- | Manual colour value for manual source1
lbColourArg1 :: LayerBlendModeEx -> ColourValue

-- | Manual colour value for manual source2
lbColourArg2 :: LayerBlendModeEx -> ColourValue

-- | Manual alpha value for manual source1
lbAlphaArg1 :: LayerBlendModeEx -> FloatType

-- | Manual alpha value for manual source2
lbAlphaArg2 :: LayerBlendModeEx -> FloatType

-- | Manual blending factor
lbFactor :: LayerBlendModeEx -> FloatType

-- | Types of blending that you can specify between an object and the
--   existing contents of the scene.
data SceneBlendType

-- | Make the object transparent based on the final alpha values in the
--   texture
SBT_TRANSPARENT_ALPHA :: SceneBlendType

-- | Make the object transparent based on the colour values in the texture
--   (brighter = more opaque)
SBT_TRANSPARENT_COLOUR :: SceneBlendType

-- | Add the texture values to the existing scene content
SBT_ADD :: SceneBlendType

-- | Multiply the 2 colours together
SBT_MODULATE :: SceneBlendType

-- | The default blend mode where source replaces destination
SBT_REPLACE :: SceneBlendType

-- | Blending factors for manually blending objects with the scene.
data SceneBlendFactor
SBF_ONE :: SceneBlendFactor
SBF_ZERO :: SceneBlendFactor
SBF_DEST_COLOUR :: SceneBlendFactor
SBF_SOURCE_COLOUR :: SceneBlendFactor
SBF_ONE_MINUS_DEST_COLOUR :: SceneBlendFactor
SBF_ONE_MINUS_SOURCE_COLOUR :: SceneBlendFactor
SBF_DEST_ALPHA :: SceneBlendFactor
SBF_SOURCE_ALPHA :: SceneBlendFactor
SBF_ONE_MINUS_DEST_ALPHA :: SceneBlendFactor
SBF_ONE_MINUS_SOURCE_ALPHA :: SceneBlendFactor

-- | Blending operations controls how objects are blended into the scene.
data SceneBlendOperation
SBO_ADD :: SceneBlendOperation
SBO_SUBTRACT :: SceneBlendOperation
SBO_REVERSE_SUBTRACT :: SceneBlendOperation
SBO_MIN :: SceneBlendOperation
SBO_MAX :: SceneBlendOperation

-- | Converts SceneBlendType to SceneBlendFactor pair
convertSBTtoSBF :: SceneBlendType -> (SceneBlendFactor, SceneBlendFactor)
instance Eq LayerBlendType
instance Ord LayerBlendType
instance Eq LayerBlendOperation
instance Ord LayerBlendOperation
instance Eq LayerBlendOperationEx
instance Ord LayerBlendOperationEx
instance Eq LayerBlendSource
instance Ord LayerBlendSource
instance Eq LayerBlendModeEx
instance Ord LayerBlendModeEx
instance Eq SceneBlendType
instance Ord SceneBlendType
instance Eq SceneBlendFactor
instance Ord SceneBlendFactor
instance Eq SceneBlendOperation
instance Ord SceneBlendOperation

module Graphics.LambdaCube.Texture
data TextureUsage
TextureUsage :: Usage -> Bool -> Bool -> TextureUsage
tuUsage :: TextureUsage -> Usage

-- | mipmaps will be automatically generated for this texture
tuAutoMipmap :: TextureUsage -> Bool

-- | this texture will be a render target, i.e. used as a target for render
--   to texture setting this flag will ignore all other texture usages
--   except TU_AUTOMIPMAP
tuRenderTarget :: TextureUsage -> Bool
data TextureType

-- | 1D texture, used in combination with 1D texture coordinates
TEX_TYPE_1D :: TextureType

-- | 2D texture, used in combination with 2D texture coordinates (default)
TEX_TYPE_2D :: TextureType

-- | 3D volume texture, used in combination with 3D texture coordinates
TEX_TYPE_3D :: TextureType

-- | 3D cube map, used in combination with 3D texture coordinates
TEX_TYPE_CUBE_MAP :: TextureType
data TextureMipmap

-- | Generate mipmaps up to 1x1
MIP_UNLIMITED :: TextureMipmap

-- | Use TextureManager default
MIP_DEFAULT :: TextureMipmap
MIP_NUMBER :: Int -> TextureMipmap
class (Eq a, HardwareBuffer a) => Texture a
txName :: Texture a => a -> String
txWidth :: Texture a => a -> Int
txHeight :: Texture a => a -> Int
txDepth :: Texture a => a -> Int
txNumRequestedMipmaps :: Texture a => a -> TextureMipmap
txNumMipmaps :: Texture a => a -> Int
txMipmapsHardwareGenerated :: Texture a => a -> Bool
txGamma :: Texture a => a -> FloatType
txHwGamma :: Texture a => a -> Bool
txFSAA :: Texture a => a -> Int
txFSAAHint :: Texture a => a -> String
txTextureType :: Texture a => a -> TextureType
txFormat :: Texture a => a -> PixelFormat
txSrcFormat :: Texture a => a -> PixelFormat
txSrcWidth :: Texture a => a -> Int
txSrcHeight :: Texture a => a -> Int
txSrcDepth :: Texture a => a -> Int
txDesiredFormat :: Texture a => a -> PixelFormat
txDesiredIntegerBitDepth :: Texture a => a -> Int
txDesiredFloatBitDepth :: Texture a => a -> Int
txTreatLuminanceAsAlpha :: Texture a => a -> Bool
instance Eq TextureUsage
instance Ord TextureUsage
instance Eq TextureType
instance Ord TextureType
instance Show TextureType
instance Eq TextureMipmap
instance Ord TextureMipmap

module Graphics.LambdaCube.Mesh
data (HardwareVertexBuffer vb, HardwareIndexBuffer ib) => SubMesh vb ib
SubMesh :: OperationType -> Maybe (VertexData vb) -> Maybe (IndexData ib) -> String -> SubMesh vb ib

-- | The render operation type used to render this submesh
smOperationType :: SubMesh vb ib -> OperationType

-- | Indicates if this submesh shares vertex data with other meshes or
--   whether it has it's own vertices.
smVertexData :: SubMesh vb ib -> Maybe (VertexData vb)

-- | Face index data , smExtremityPoints :: [FloatType3]
smIndexData :: SubMesh vb ib -> Maybe (IndexData ib)

-- | Name of the material this SubMesh uses.
smMaterialName :: SubMesh vb ib -> String
data (HardwareVertexBuffer vb, HardwareIndexBuffer ib) => Mesh vb ib
Mesh :: [SubMesh vb ib] -> FloatType -> Maybe (VertexData vb) -> Mesh vb ib
msSubMeshList :: Mesh vb ib -> [SubMesh vb ib]
msBoundRadius :: Mesh vb ib -> FloatType
msSharedVertexData :: Mesh vb ib -> Maybe (VertexData vb)
calculateBoundingRadius :: (HardwareVertexBuffer vb, HardwareIndexBuffer ib) => Mesh vb ib -> IO FloatType

module Graphics.LambdaCube.Frustum
data Plane
Plane :: Vec3 -> FloatType -> Plane
plNormal :: Plane -> Vec3
plDist :: Plane -> FloatType
newtype Frustum
Frustum :: [Plane] -> Frustum
frPlanes :: Frustum -> [Plane]
pointInFrustum :: Vec3 -> Frustum -> Bool
sphereInFrustum :: Vec3 -> FloatType -> Frustum -> Bool
boxInFrustum :: Vec3 -> Vec3 -> Frustum -> Bool
frustum :: FloatType -> FloatType -> FloatType -> FloatType -> Vec3 -> Vec3 -> Vec3 -> Frustum
frustumFromMatrix :: Mat4 -> Frustum

module Graphics.LambdaCube.GpuProgramParams

-- | The types of constants we may encounter in programs.
data GpuConstantType
GCT_FLOAT1 :: GpuConstantType
GCT_FLOAT2 :: GpuConstantType
GCT_FLOAT3 :: GpuConstantType
GCT_FLOAT4 :: GpuConstantType
GCT_SAMPLER1D :: GpuConstantType
GCT_SAMPLER2D :: GpuConstantType
GCT_SAMPLER3D :: GpuConstantType
GCT_SAMPLERCUBE :: GpuConstantType
GCT_SAMPLER1DSHADOW :: GpuConstantType
GCT_SAMPLER2DSHADOW :: GpuConstantType
GCT_MATRIX_2X2 :: GpuConstantType
GCT_MATRIX_2X3 :: GpuConstantType
GCT_MATRIX_2X4 :: GpuConstantType
GCT_MATRIX_3X2 :: GpuConstantType
GCT_MATRIX_3X3 :: GpuConstantType
GCT_MATRIX_3X4 :: GpuConstantType
GCT_MATRIX_4X2 :: GpuConstantType
GCT_MATRIX_4X3 :: GpuConstantType
GCT_MATRIX_4X4 :: GpuConstantType
GCT_INT1 :: GpuConstantType
GCT_INT2 :: GpuConstantType
GCT_INT3 :: GpuConstantType
GCT_INT4 :: GpuConstantType
GCT_UNKNOWN :: GpuConstantType

-- | The variability of a GPU parameter, as derived from auto-params
--   targetting it.
data GpuParamVariability
GpuParamVariability :: Bool -> Bool -> Bool -> Bool -> GpuParamVariability

-- | No variation except by manual setting - the default
gpvGlobal :: GpuParamVariability -> Bool

-- | Varies per object (based on an auto param usually), but not per light
--   setup
gpvPerObject :: GpuParamVariability -> Bool

-- | Varies with light setup
gpvLights :: GpuParamVariability -> Bool

-- | Varies with pass iteration number
gpvPassIterationNumber :: GpuParamVariability -> Bool

-- | Information about predefined program constants.
data GpuConstantDefinition
GpuConstantDefinition :: GpuConstantType -> Int -> Int -> Int -> Int -> GpuParamVariability -> GpuConstantDefinition

-- | Data type
gcdConstType :: GpuConstantDefinition -> GpuConstantType

-- | Physical start index in buffer (either float or int buffer)
gcdPhysicalIndex :: GpuConstantDefinition -> Int

-- | Logical index - used to communicate this constant to the rendersystem
gcdLogicalIndex :: GpuConstantDefinition -> Int

-- | Number of raw buffer slots per element (some programs pack each array
--   element to float4, some do not)
gcdElementSize :: GpuConstantDefinition -> Int

-- | Length of array
gcdArraySize :: GpuConstantDefinition -> Int

-- | How this parameter varies (bitwise combination of
--   GpuProgramVariability)
gcdVariability :: GpuConstantDefinition -> GpuParamVariability
isFloat :: GpuConstantType -> Bool
isSampler :: GpuConstantType -> Bool

-- | Get the element size of a given type, including whether to pad the
--   elements into multiples of 4 (e.g. SM1 and D3D does, GLSL doesn't)
getElementSize :: GpuConstantType -> Bool -> Int

-- | Struct collecting together the information for named constants.
data GpuNamedConstants
GpuNamedConstants :: Int -> Int -> Map String GpuConstantDefinition -> Bool -> GpuNamedConstants

-- | Total size of the float buffer required
gncFloatBufferSize :: GpuNamedConstants -> Int

-- | Total size of the int buffer required
gncIntBufferSize :: GpuNamedConstants -> Int

-- | Map of parameter names to GpuConstantDefinition
gncMap :: GpuNamedConstants -> Map String GpuConstantDefinition
gncGenerateAllConstantDefinitionArrayEntries :: GpuNamedConstants -> Bool

-- | Structure recording the use of a physical buffer by a logical
--   parameter index. Only used for low-level programs.
data GpuLogicalIndexUse
GpuLogicalIndexUse :: Int -> Int -> Word16 -> GpuLogicalIndexUse

-- | Physical buffer index
gliPhysicalIndex :: GpuLogicalIndexUse -> Int

-- | Current physical size allocation
gliCurrentSize :: GpuLogicalIndexUse -> Int

-- | How the contents of this slot vary
gliVariability :: GpuLogicalIndexUse -> Word16

-- | Container to allow params to safely &amp; update shared list of
--   logical buffer assignments
data GpuLogicalBufferStruct
GpuLogicalBufferStruct :: Map Int GpuLogicalIndexUse -> Int -> GpuLogicalBufferStruct

-- | Map from logical index to physical buffer location
gluMap :: GpuLogicalBufferStruct -> Map Int GpuLogicalIndexUse

-- | Shortcut to know the buffer size needs
gluBufferSize :: GpuLogicalBufferStruct -> Int

-- | A group of manually updated parameters that are shared between many
--   parameter sets.
data GpuSharedParameters
GpuSharedParameters :: GpuNamedConstants -> [Float] -> [Int] -> String -> Int -> Int -> GpuSharedParameters
gspNamedConstants :: GpuSharedParameters -> GpuNamedConstants
gspFloatConstants :: GpuSharedParameters -> [Float]
gspIntConstants :: GpuSharedParameters -> [Int]
gspName :: GpuSharedParameters -> String

-- | Not used when copying data, but might be useful to RS using shared
--   buffers
gspFrameLastUpdated :: GpuSharedParameters -> Int

-- | Version number of the definitions in this buffer
gspVersion :: GpuSharedParameters -> Int

-- | The list of physical mappings that we are going to bring in.
data CopyDataEntry
CopyDataEntry :: GpuConstantDefinition -> GpuConstantDefinition -> CopyDataEntry
cdeSrcDefinition :: CopyDataEntry -> GpuConstantDefinition
cdeDstDefinition :: CopyDataEntry -> GpuConstantDefinition

-- | The usage of a set of shared parameters in a concrete set of
--   GpuProgramParameters.
data GpuSharedParametersUsage
GpuSharedParametersUsage :: GpuSharedParameters -> [CopyDataEntry] -> Int -> GpuSharedParametersUsage
spuSharedParams :: GpuSharedParametersUsage -> GpuSharedParameters
spuCopyDataList :: GpuSharedParametersUsage -> [CopyDataEntry]

-- | Version of shared params we based the copydata on
spuCopyDataVersion :: GpuSharedParametersUsage -> Int

-- | The types of automatically updated values that may be bound to
--   GpuProgram parameters, or used to modify parameters on a per-object
--   basis.
data AutoConstantType

-- | The current world matrix
ACT_WORLD_MATRIX :: AutoConstantType

-- | The current world matrix, inverted
ACT_INVERSE_WORLD_MATRIX :: AutoConstantType

-- | Provides transpose of world matrix. Equivalent to RenderMonkey's
--   <a>WorldTranspose</a>.
ACT_TRANSPOSE_WORLD_MATRIX :: AutoConstantType

-- | The current world matrix, inverted &amp; transposed
ACT_INVERSE_TRANSPOSE_WORLD_MATRIX :: AutoConstantType

-- | The current array of world matrices, as a 3x4 matrix, used for
--   blending
ACT_WORLD_MATRIX_ARRAY_3x4 :: AutoConstantType

-- | The current array of world matrices, used for blending
ACT_WORLD_MATRIX_ARRAY :: AutoConstantType

-- | The current view matrix
ACT_VIEW_MATRIX :: AutoConstantType

-- | The current view matrix, inverted
ACT_INVERSE_VIEW_MATRIX :: AutoConstantType

-- | Provides transpose of view matrix. Equivalent to RenderMonkey's
--   <a>ViewTranspose</a>.
ACT_TRANSPOSE_VIEW_MATRIX :: AutoConstantType

-- | Provides inverse transpose of view matrix. Equivalent to
--   RenderMonkey's <a>ViewInverseTranspose</a>.
ACT_INVERSE_TRANSPOSE_VIEW_MATRIX :: AutoConstantType

-- | The current projection matrix
ACT_PROJECTION_MATRIX :: AutoConstantType

-- | Provides inverse of projection matrix. Equivalent to RenderMonkey's
--   <a>ProjectionInverse</a>.
ACT_INVERSE_PROJECTION_MATRIX :: AutoConstantType

-- | Provides transpose of projection matrix. Equivalent to RenderMonkey's
--   <a>ProjectionTranspose</a>.
ACT_TRANSPOSE_PROJECTION_MATRIX :: AutoConstantType

-- | Provides inverse transpose of projection matrix. Equivalent to
--   RenderMonkey's <a>ProjectionInverseTranspose</a>.
ACT_INVERSE_TRANSPOSE_PROJECTION_MATRIX :: AutoConstantType

-- | The current view &amp; projection matrices concatenated
ACT_VIEWPROJ_MATRIX :: AutoConstantType

-- | Provides inverse of concatenated view and projection matrices.
--   Equivalent to RenderMonkey's <a>ViewProjectionInverse</a>.
ACT_INVERSE_VIEWPROJ_MATRIX :: AutoConstantType

-- | Provides transpose of concatenated view and projection matrices.
--   Equivalent to RenderMonkey's <a>ViewProjectionTranspose</a>.
ACT_TRANSPOSE_VIEWPROJ_MATRIX :: AutoConstantType

-- | Provides inverse transpose of concatenated view and projection
--   matrices. Equivalent to RenderMonkey's
--   <a>ViewProjectionInverseTranspose</a>.
ACT_INVERSE_TRANSPOSE_VIEWPROJ_MATRIX :: AutoConstantType

-- | The current world &amp; view matrices concatenated
ACT_WORLDVIEW_MATRIX :: AutoConstantType

-- | The current world &amp; view matrices concatenated, then inverted
ACT_INVERSE_WORLDVIEW_MATRIX :: AutoConstantType

-- | Provides transpose of concatenated world and view matrices. Equivalent
--   to RenderMonkey's <a>WorldViewTranspose</a>.
ACT_TRANSPOSE_WORLDVIEW_MATRIX :: AutoConstantType

-- | The current world &amp; view matrices concatenated, then inverted
--   &amp; transposed
ACT_INVERSE_TRANSPOSE_WORLDVIEW_MATRIX :: AutoConstantType

-- | The current world, view &amp; projection matrices concatenated
ACT_WORLDVIEWPROJ_MATRIX :: AutoConstantType

-- | Provides inverse of concatenated world, view and projection matrices.
--   Equivalent to RenderMonkey's <a>WorldViewProjectionInverse</a>.
ACT_INVERSE_WORLDVIEWPROJ_MATRIX :: AutoConstantType

-- | Provides transpose of concatenated world, view and projection
--   matrices. Equivalent to RenderMonkey's
--   <a>WorldViewProjectionTranspose</a>.
ACT_TRANSPOSE_WORLDVIEWPROJ_MATRIX :: AutoConstantType

-- | Provides inverse transpose of concatenated world, view and projection
--   matrices. Equivalent to RenderMonkey's
--   <a>WorldViewProjectionInverseTranspose</a>.
ACT_INVERSE_TRANSPOSE_WORLDVIEWPROJ_MATRIX :: AutoConstantType

-- | <ul>
--   <li>1 if requires texture flipping, +1 otherwise. It's useful when you
--   bypassed projection matrix transform, still able use this value to
--   adjust transformed y position.</li>
--   </ul>
ACT_RENDER_TARGET_FLIPPING :: AutoConstantType

-- | Fog colour
ACT_FOG_COLOUR :: AutoConstantType

-- | Fog params: density, linear start, linear end, 1/(end-start)
ACT_FOG_PARAMS :: AutoConstantType

-- | Surface ambient colour, as set in Pass::setAmbient
ACT_SURFACE_AMBIENT_COLOUR :: AutoConstantType

-- | Surface diffuse colour, as set in Pass::setDiffuse
ACT_SURFACE_DIFFUSE_COLOUR :: AutoConstantType

-- | Surface specular colour, as set in Pass::setSpecular
ACT_SURFACE_SPECULAR_COLOUR :: AutoConstantType

-- | Surface emissive colour, as set in Pass::setSelfIllumination
ACT_SURFACE_EMISSIVE_COLOUR :: AutoConstantType

-- | Surface shininess, as set in Pass::setShininess
ACT_SURFACE_SHININESS :: AutoConstantType

-- | The number of active light sources (better than gl_MaxLights)
ACT_LIGHT_COUNT :: AutoConstantType

-- | The ambient light colour set in the scene
ACT_AMBIENT_LIGHT_COLOUR :: AutoConstantType

-- | Light diffuse colour (index determined by setAutoConstant call)
ACT_LIGHT_DIFFUSE_COLOUR :: AutoConstantType

-- | Light specular colour (index determined by setAutoConstant call)
ACT_LIGHT_SPECULAR_COLOUR :: AutoConstantType

-- | Light attenuation parameters, Vector4(range, constant, linear,
--   quadric)
ACT_LIGHT_ATTENUATION :: AutoConstantType
ACT_SPOTLIGHT_PARAMS :: AutoConstantType

-- | A light position in world space (index determined by setAutoConstant
--   call)
ACT_LIGHT_POSITION :: AutoConstantType

-- | A light position in object space (index determined by setAutoConstant
--   call)
ACT_LIGHT_POSITION_OBJECT_SPACE :: AutoConstantType

-- | A light position in view space (index determined by setAutoConstant
--   call)
ACT_LIGHT_POSITION_VIEW_SPACE :: AutoConstantType

-- | A light direction in world space (index determined by setAutoConstant
--   call)
ACT_LIGHT_DIRECTION :: AutoConstantType

-- | A light direction in object space (index determined by setAutoConstant
--   call)
ACT_LIGHT_DIRECTION_OBJECT_SPACE :: AutoConstantType

-- | A light direction in view space (index determined by setAutoConstant
--   call)
ACT_LIGHT_DIRECTION_VIEW_SPACE :: AutoConstantType

-- | The distance of the light from the center of the object a useful
--   approximation as an alternative to per-vertex distance calculations.
ACT_LIGHT_DISTANCE_OBJECT_SPACE :: AutoConstantType

-- | Light power level, a single scalar as set in Light::setPowerScale
--   (index determined by setAutoConstant call)
ACT_LIGHT_POWER_SCALE :: AutoConstantType

-- | Light diffuse colour pre-scaled by Light::setPowerScale (index
--   determined by setAutoConstant call)
ACT_LIGHT_DIFFUSE_COLOUR_POWER_SCALED :: AutoConstantType

-- | Light specular colour pre-scaled by Light::setPowerScale (index
--   determined by setAutoConstant call)
ACT_LIGHT_SPECULAR_COLOUR_POWER_SCALED :: AutoConstantType

-- | Array of light diffuse colours (count set by extra param)
ACT_LIGHT_DIFFUSE_COLOUR_ARRAY :: AutoConstantType

-- | Array of light specular colours (count set by extra param)
ACT_LIGHT_SPECULAR_COLOUR_ARRAY :: AutoConstantType

-- | Array of light diffuse colours scaled by light power (count set by
--   extra param)
ACT_LIGHT_DIFFUSE_COLOUR_POWER_SCALED_ARRAY :: AutoConstantType

-- | Array of light specular colours scaled by light power (count set by
--   extra param)
ACT_LIGHT_SPECULAR_COLOUR_POWER_SCALED_ARRAY :: AutoConstantType

-- | Array of light attenuation parameters, Vector4(range, constant,
--   linear, quadric) (count set by extra param)
ACT_LIGHT_ATTENUATION_ARRAY :: AutoConstantType

-- | Array of light positions in world space (count set by extra param)
ACT_LIGHT_POSITION_ARRAY :: AutoConstantType

-- | Array of light positions in object space (count set by extra param)
ACT_LIGHT_POSITION_OBJECT_SPACE_ARRAY :: AutoConstantType

-- | Array of light positions in view space (count set by extra param)
ACT_LIGHT_POSITION_VIEW_SPACE_ARRAY :: AutoConstantType

-- | Array of light directions in world space (count set by extra param)
ACT_LIGHT_DIRECTION_ARRAY :: AutoConstantType

-- | Array of light directions in object space (count set by extra param)
ACT_LIGHT_DIRECTION_OBJECT_SPACE_ARRAY :: AutoConstantType

-- | Array of light directions in view space (count set by extra param)
ACT_LIGHT_DIRECTION_VIEW_SPACE_ARRAY :: AutoConstantType

-- | Array of distances of the lights from the center of the object a
--   useful approximation as an alternative to per-vertex distance
--   calculations. (count set by extra param)
ACT_LIGHT_DISTANCE_OBJECT_SPACE_ARRAY :: AutoConstantType

-- | Array of light power levels, a single scalar as set in
--   Light::setPowerScale (count set by extra param)
ACT_LIGHT_POWER_SCALE_ARRAY :: AutoConstantType
ACT_SPOTLIGHT_PARAMS_ARRAY :: AutoConstantType
ACT_DERIVED_AMBIENT_LIGHT_COLOUR :: AutoConstantType
ACT_DERIVED_SCENE_COLOUR :: AutoConstantType
ACT_DERIVED_LIGHT_DIFFUSE_COLOUR :: AutoConstantType
ACT_DERIVED_LIGHT_SPECULAR_COLOUR :: AutoConstantType

-- | Array of derived light diffuse colours (count set by extra param)
ACT_DERIVED_LIGHT_DIFFUSE_COLOUR_ARRAY :: AutoConstantType

-- | Array of derived light specular colours (count set by extra param)
ACT_DERIVED_LIGHT_SPECULAR_COLOUR_ARRAY :: AutoConstantType
ACT_LIGHT_NUMBER :: AutoConstantType

-- | Returns (int) 1 if the given light casts shadows, 0 otherwise (index
--   set in extra param)
ACT_LIGHT_CASTS_SHADOWS :: AutoConstantType

-- | The distance a shadow volume should be extruded when using finite
--   extrusion programs.
ACT_SHADOW_EXTRUSION_DISTANCE :: AutoConstantType

-- | The current camera's position in world space
ACT_CAMERA_POSITION :: AutoConstantType

-- | The current camera's position in object space
ACT_CAMERA_POSITION_OBJECT_SPACE :: AutoConstantType

-- | The view/projection matrix of the assigned texture projection frustum
ACT_TEXTURE_VIEWPROJ_MATRIX :: AutoConstantType

-- | Array of view/projection matrices of the first n texture projection
--   frustums
ACT_TEXTURE_VIEWPROJ_MATRIX_ARRAY :: AutoConstantType

-- | The view/projection matrix of the assigned texture projection frustum,
--   combined with the current world matrix
ACT_TEXTURE_WORLDVIEWPROJ_MATRIX :: AutoConstantType

-- | Array of world<i>view</i>projection matrices of the first n texture
--   projection frustums
ACT_TEXTURE_WORLDVIEWPROJ_MATRIX_ARRAY :: AutoConstantType

-- | The view/projection matrix of a given spotlight
ACT_SPOTLIGHT_VIEWPROJ_MATRIX :: AutoConstantType

-- | The view/projection matrix of a given spotlight projection frustum,
--   combined with the current world matrix
ACT_SPOTLIGHT_WORLDVIEWPROJ_MATRIX :: AutoConstantType

-- | A custom parameter which will come from the renderable, using 'data'
--   as the identifier
ACT_CUSTOM :: AutoConstantType

-- | provides current elapsed time
ACT_TIME :: AutoConstantType

-- | Single float value, which repeats itself based on given as parameter
--   <a>cycle time</a>. Equivalent to RenderMonkey's <a>Time0_X</a>.
ACT_TIME_0_X :: AutoConstantType

-- | Cosine of <a>Time0_X</a>. Equivalent to RenderMonkey's
--   <a>CosTime0_X</a>.
ACT_COSTIME_0_X :: AutoConstantType

-- | Sine of <a>Time0_X</a>. Equivalent to RenderMonkey's
--   <a>SinTime0_X</a>.
ACT_SINTIME_0_X :: AutoConstantType

-- | Tangent of <a>Time0_X</a>. Equivalent to RenderMonkey's
--   <a>TanTime0_X</a>.
ACT_TANTIME_0_X :: AutoConstantType

-- | Vector of <a>Time0_X</a>, <a>SinTime0_X</a>, <a>CosTime0_X</a>,
--   <a>TanTime0_X</a>. Equivalent to RenderMonkey's <a>Time0_X_Packed</a>.
ACT_TIME_0_X_PACKED :: AutoConstantType

-- | Single float value, which represents scaled time value [0..1], which
--   repeats itself based on given as parameter <a>cycle time</a>.
--   Equivalent to RenderMonkey's <a>Time0_1</a>.
ACT_TIME_0_1 :: AutoConstantType

-- | Cosine of <a>Time0_1</a>. Equivalent to RenderMonkey's
--   <a>CosTime0_1</a>.
ACT_COSTIME_0_1 :: AutoConstantType

-- | Sine of <a>Time0_1</a>. Equivalent to RenderMonkey's
--   <a>SinTime0_1</a>.
ACT_SINTIME_0_1 :: AutoConstantType

-- | Tangent of <a>Time0_1</a>. Equivalent to RenderMonkey's
--   <a>TanTime0_1</a>.
ACT_TANTIME_0_1 :: AutoConstantType

-- | Vector of <a>Time0_1</a>, <a>SinTime0_1</a>, <a>CosTime0_1</a>,
--   <a>TanTime0_1</a>. Equivalent to RenderMonkey's <a>Time0_1_Packed</a>.
ACT_TIME_0_1_PACKED :: AutoConstantType

-- | Single float value, which represents scaled time value [0..2*Pi],
--   which repeats itself based on given as parameter <a>cycle time</a>.
--   Equivalent to RenderMonkey's <a>Time0_2PI</a>.
ACT_TIME_0_2PI :: AutoConstantType

-- | Cosine of <a>Time0_2PI</a>. Equivalent to RenderMonkey's
--   <a>CosTime0_2PI</a>.
ACT_COSTIME_0_2PI :: AutoConstantType

-- | Sine of <a>Time0_2PI</a>. Equivalent to RenderMonkey's
--   <a>SinTime0_2PI</a>.
ACT_SINTIME_0_2PI :: AutoConstantType

-- | Tangent of <a>Time0_2PI</a>. Equivalent to RenderMonkey's
--   <a>TanTime0_2PI</a>.
ACT_TANTIME_0_2PI :: AutoConstantType

-- | Vector of <a>Time0_2PI</a>, <a>SinTime0_2PI</a>, <a>CosTime0_2PI</a>,
--   <a>TanTime0_2PI</a>. Equivalent to RenderMonkey's
--   <a>Time0_2PI_Packed</a>.
ACT_TIME_0_2PI_PACKED :: AutoConstantType

-- | provides the scaled frame time, returned as a floating point value.
ACT_FRAME_TIME :: AutoConstantType

-- | provides the calculated frames per second, returned as a floating
--   point value.
ACT_FPS :: AutoConstantType

-- | Current viewport width (in pixels) as floating point value. Equivalent
--   to RenderMonkey's <a>ViewportWidth</a>.
ACT_VIEWPORT_WIDTH :: AutoConstantType

-- | Current viewport height (in pixels) as floating point value.
--   Equivalent to RenderMonkey's <a>ViewportHeight</a>.
ACT_VIEWPORT_HEIGHT :: AutoConstantType

-- | This variable represents 1.0/ViewportWidth. Equivalent to
--   RenderMonkey's <a>ViewportWidthInverse</a>.
ACT_INVERSE_VIEWPORT_WIDTH :: AutoConstantType

-- | This variable represents 1.0/ViewportHeight. Equivalent to
--   RenderMonkey's <a>ViewportHeightInverse</a>.
ACT_INVERSE_VIEWPORT_HEIGHT :: AutoConstantType

-- | Packed of <a>ViewportWidth</a>, <a>ViewportHeight</a>,
--   <a>ViewportWidthInverse</a>, <a>ViewportHeightInverse</a>.
ACT_VIEWPORT_SIZE :: AutoConstantType

-- | This variable provides the view direction vector (world space).
--   Equivalent to RenderMonkey's <a>ViewDirection</a>.
ACT_VIEW_DIRECTION :: AutoConstantType

-- | This variable provides the view side vector (world space). Equivalent
--   to RenderMonkey's <a>ViewSideVector</a>.
ACT_VIEW_SIDE_VECTOR :: AutoConstantType

-- | This variable provides the view up vector (world space). Equivalent to
--   RenderMonkey's <a>ViewUpVector</a>.
ACT_VIEW_UP_VECTOR :: AutoConstantType

-- | This variable provides the field of view as a floating point value.
--   Equivalent to RenderMonkey's <a>FOV</a>.
ACT_FOV :: AutoConstantType

-- | This variable provides the near clip distance as a floating point
--   value. Equivalent to RenderMonkey's <a>NearClipPlane</a>.
ACT_NEAR_CLIP_DISTANCE :: AutoConstantType

-- | This variable provides the far clip distance as a floating point
--   value. Equivalent to RenderMonkey's <a>FarClipPlane</a>.
ACT_FAR_CLIP_DISTANCE :: AutoConstantType

-- | provides the pass index number within the technique of the active
--   materil.
ACT_PASS_NUMBER :: AutoConstantType

-- | provides the current iteration number of the pass. The iteration
--   number is the number of times the current render operation has been
--   drawn for the active pass.
ACT_PASS_ITERATION_NUMBER :: AutoConstantType

-- | Provides a parametric animation value [0..1], only available where the
--   renderable specifically implements it.
ACT_ANIMATION_PARAMETRIC :: AutoConstantType
ACT_TEXEL_OFFSETS :: AutoConstantType
ACT_SCENE_DEPTH_RANGE :: AutoConstantType
ACT_SHADOW_SCENE_DEPTH_RANGE :: AutoConstantType

-- | Provides the fixed shadow colour as configured via
--   SceneManager::setShadowColour; useful for integrated modulative
--   shadows.
ACT_SHADOW_COLOUR :: AutoConstantType

-- | Provides texture size of the texture unit (index determined by
--   setAutoConstant call). Packed as float4(width, height, depth, 1)
ACT_TEXTURE_SIZE :: AutoConstantType

-- | Provides inverse texture size of the texture unit (index determined by
--   setAutoConstant call). Packed as float4(1 <i> width, 1 </i> height, 1
--   / depth, 1)
ACT_INVERSE_TEXTURE_SIZE :: AutoConstantType

-- | Provides packed texture size of the texture unit (index determined by
--   setAutoConstant call). Packed as float4(width, height, 1 <i> width, 1
--   </i> height)
ACT_PACKED_TEXTURE_SIZE :: AutoConstantType

-- | Provides the current transform matrix of the texture unit (index
--   determined by setAutoConstant call), as seen by the fixed-function
--   pipeline.
ACT_TEXTURE_MATRIX :: AutoConstantType
ACT_LOD_CAMERA_POSITION :: AutoConstantType
ACT_LOD_CAMERA_POSITION_OBJECT_SPACE :: AutoConstantType

-- | Binds custom per-light constants to the shaders.
ACT_LIGHT_CUSTOM :: AutoConstantType
data ACDataType

-- | no data is required
ACDT_NONE :: ACDataType

-- | the auto constant requires data of type int
ACDT_INT :: ACDataType

-- | the auto constant requires data of type real
ACDT_REAL :: ACDataType
data ElementType
ET_INT :: ElementType
ET_REAL :: ElementType
data AutoConstantDefinition
AutoConstantDefinition :: AutoConstantType -> String -> Int -> ElementType -> ACDataType -> AutoConstantDefinition
acdType :: AutoConstantDefinition -> AutoConstantType
acdName :: AutoConstantDefinition -> String
acdElementCount :: AutoConstantDefinition -> Int

-- | The type of the constant in the program
acdElementType :: AutoConstantDefinition -> ElementType

-- | The type of any extra data
acdDataType :: AutoConstantDefinition -> ACDataType
data AutoConstantEntry
AutoConstantEntry :: AutoConstantType -> Int -> Int -> GpuParamVariability -> AutoConstantEntry

-- | The type of parameter
aceParamType :: AutoConstantEntry -> AutoConstantType

-- | The target (physical) constant index
acePhysicalIndex :: AutoConstantEntry -> Int

-- | The number of elements per individual entry in this constant Used in
--   case people used packed elements smaller than 4 (e.g. GLSL) and bind
--   an auto which is 4-element packed to it
aceElementCount :: AutoConstantEntry -> Int

-- | The variability of this parameter (see GpuParamVariability)
aceVariability :: AutoConstantEntry -> GpuParamVariability
data GpuProgramParameters
GpuProgramParameters :: [GpuNamedConstant] -> GpuProgramParameters
gppNamedConstants :: GpuProgramParameters -> [GpuNamedConstant]
data GpuNamedConstant
GpuNamedConstant :: String -> ElementType -> [Int] -> [FloatType] -> GpuNamedConstant
gncName :: GpuNamedConstant -> String
gncType :: GpuNamedConstant -> ElementType
gncIntValues :: GpuNamedConstant -> [Int]
gncFloatValues :: GpuNamedConstant -> [FloatType]
autoConstantDictionary :: [(AutoConstantType, String, Int, ElementType, ACDataType)]
instance Eq GpuConstantType
instance Eq GpuParamVariability
instance Eq GpuConstantDefinition
instance Eq GpuNamedConstants
instance Eq GpuLogicalIndexUse
instance Eq GpuLogicalBufferStruct
instance Eq GpuSharedParameters
instance Eq CopyDataEntry
instance Eq GpuSharedParametersUsage
instance Eq AutoConstantType
instance Eq ACDataType
instance Eq ElementType
instance Eq AutoConstantDefinition
instance Eq AutoConstantEntry

module Graphics.LambdaCube.GpuProgram
data GpuProgramType
GPT_VERTEX_PROGRAM :: GpuProgramType
GPT_FRAGMENT_PROGRAM :: GpuProgramType
GPT_GEOMETRY_PROGRAM :: GpuProgramType
class Ord p => GpuProgram p
class Ord lp => LinkedGpuProgram lp
data GpuProgram p => GpuProgramDescriptor p
GpuProgramDescriptor :: String -> GpuProgramType -> String -> String -> [String] -> Bool -> Bool -> Int -> Bool -> Bool -> GpuProgramParameters -> Maybe p -> GpuProgramDescriptor p
gpdName :: GpuProgramDescriptor p -> String

-- | The type of the program
gpdType :: GpuProgramDescriptor p -> GpuProgramType

-- | The name of the file to load source from (may be blank)
gpdFilename :: GpuProgramDescriptor p -> String

-- | Syntax code e.g. arbvp1, vs_2_0 etc
gpdSyntaxCode :: GpuProgramDescriptor p -> String
gpdAttach :: GpuProgramDescriptor p -> [String]

-- | Does this (vertex) program include skeletal animation?
gpdSkeletalAnimation :: GpuProgramDescriptor p -> Bool

-- | Does this (vertex) program include morph animation?
gpdMorphAnimation :: GpuProgramDescriptor p -> Bool

-- | Does this (vertex) program include pose animation (count of number of
--   poses supported)
gpdPoseAnimation :: GpuProgramDescriptor p -> Int

-- | Does this (vertex) program require support for vertex texture fetch?
gpdVertexTextureFetch :: GpuProgramDescriptor p -> Bool

-- | Does this (geometry) program require adjacency information?
gpdNeedsAdjacencyInfo :: GpuProgramDescriptor p -> Bool

-- | The default parameters for use with this object
gpdDefaultParams :: GpuProgramDescriptor p -> GpuProgramParameters
gpdGpuProgram :: GpuProgramDescriptor p -> Maybe p
instance Eq GpuProgramType
instance Ord GpuProgramType

module Graphics.LambdaCube.RenderSystem.GL.GpuProgram
getFixedAttributeIndex :: VertexElementSemantic -> Int -> Int
isAttributeValid :: VertexElementSemantic -> Int -> Bool
data GLGpuProgram
GLGpuProgram :: GLuint -> GLGpuProgram
glgpShaderObject :: GLGpuProgram -> GLuint
data GLLinkedGpuProgram
GLLinkedGpuProgram :: GLuint -> GLLinkedGpuProgram
gllgpProgramObject :: GLLinkedGpuProgram -> GLuint
withGLStringLen :: String -> ((Ptr b, Int) -> IO a) -> IO a
setShaderSource :: GLuint -> [String] -> IO ()
shaderInfoLog :: GLuint -> IO String
programInfoLog :: GLuint -> IO String
compileShader :: Integral a => a -> String -> IO (Either GLuint [Char])
mkGLGpuProgram :: GpuProgramType -> String -> IO (Either GLGpuProgram String)
mkGLLinkedGpuProgram :: [GLGpuProgram] -> IO (Either GLLinkedGpuProgram String)
instance Eq GLGpuProgram
instance Ord GLGpuProgram
instance Eq GLLinkedGpuProgram
instance Ord GLLinkedGpuProgram
instance GpuProgram GLGpuProgram
instance LinkedGpuProgram GLLinkedGpuProgram

module Graphics.LambdaCube.TextureUnitState
data TextureEffectType

-- | Generate all texture coords based on angle between camera and vertex
ET_ENVIRONMENT_MAP :: TextureEffectType

-- | Generate texture coords based on a frustum
ET_PROJECTIVE_TEXTURE :: TextureEffectType

-- | Constant u/v scrolling effect
ET_UVSCROLL :: TextureEffectType

-- | Constant u scrolling effect
ET_USCROLL :: TextureEffectType

-- | Constant u/v scrolling effect
ET_VSCROLL :: TextureEffectType

-- | Constant rotation
ET_ROTATE :: TextureEffectType

-- | More complex transform
ET_TRANSFORM :: TextureEffectType
data EnvMapType

-- | Envmap based on vector from camera to vertex position, good for planar
--   geometry
ENV_PLANAR :: EnvMapType

-- | Envmap based on dot of vector from camera to vertex and vertex normal,
--   good for curves
ENV_CURVED :: EnvMapType

-- | Envmap intended to supply reflection vectors for cube mapping
ENV_REFLECTION :: EnvMapType

-- | Envmap intended to supply normal vectors for cube mapping
ENV_NORMAL :: EnvMapType
data TextureTransformType
TT_TRANSLATE_U :: TextureTransformType
TT_TRANSLATE_V :: TextureTransformType
TT_SCALE_U :: TextureTransformType
TT_SCALE_V :: TextureTransformType
TT_ROTATE :: TextureTransformType
data TextureAddressingMode

-- | Texture wraps at values over 1.0
TAM_WRAP :: TextureAddressingMode

-- | Texture mirrors (flips) at joins over 1.0
TAM_MIRROR :: TextureAddressingMode

-- | Texture clamps at 1.0
TAM_CLAMP :: TextureAddressingMode

-- | Texture coordinates outside the range [0.0, 1.0] are set to the border
--   colour
TAM_BORDER :: TextureAddressingMode
data UVWAddressingMode
UVWAddressingMode :: TextureAddressingMode -> TextureAddressingMode -> TextureAddressingMode -> UVWAddressingMode
amU :: UVWAddressingMode -> TextureAddressingMode
amV :: UVWAddressingMode -> TextureAddressingMode
amW :: UVWAddressingMode -> TextureAddressingMode
data TextureCubeFace
CUBE_FRONT :: TextureCubeFace
CUBE_BACK :: TextureCubeFace
CUBE_LEFT :: TextureCubeFace
CUBE_RIGHT :: TextureCubeFace
CUBE_UP :: TextureCubeFace
CUBE_DOWN :: TextureCubeFace
data TextureEffect
TextureEffect :: TextureEffectType -> Int -> FloatType -> FloatType -> WaveformType -> FloatType -> FloatType -> FloatType -> FloatType -> TextureEffect
teType :: TextureEffect -> TextureEffectType
teSubType :: TextureEffect -> Int
teArg1 :: TextureEffect -> FloatType
teArg2 :: TextureEffect -> FloatType
teWaveType :: TextureEffect -> WaveformType
teBase :: TextureEffect -> FloatType
teFrequency :: TextureEffect -> FloatType
tePhase :: TextureEffect -> FloatType
teAmplitude :: TextureEffect -> FloatType
data BindingType

-- | Regular fragment processing unit - the default.
BT_FRAGMENT :: BindingType

-- | Vertex processing unit - indicates this unit will be used for a vertex
--   texture fetch.
BT_VERTEX :: BindingType
data ContentType

-- | Normal texture identified by name
CONTENT_NAMED :: ContentType

-- | A shadow texture, automatically bound by engine
CONTENT_SHADOW :: ContentType
data Texture t => TextureUnitState t
TextureUnitState :: Maybe FloatType -> Bool -> TextureType -> PixelFormat -> TextureMipmap -> Int -> UVWAddressingMode -> ColourValue -> LayerBlendModeEx -> SceneBlendFactor -> SceneBlendFactor -> LayerBlendModeEx -> Bool -> Bool -> FloatType -> FloatType -> FloatType -> FloatType -> FloatType -> FilterOptions -> FilterOptions -> FilterOptions -> Int -> FloatType -> BindingType -> ContentType -> [String] -> Maybe [t] -> String -> String -> [TextureEffect] -> TextureUnitState t

-- | Duration of animation in seconds
tusAnimDuration :: TextureUnitState t -> Maybe FloatType

-- | is this a series of 6 2D textures to make up a cube?
tusCubic :: TextureUnitState t -> Bool
tusTextureType :: TextureUnitState t -> TextureType
tusDesiredFormat :: TextureUnitState t -> PixelFormat

-- | Request number of mipmaps
tusTextureSrcMipmaps :: TextureUnitState t -> TextureMipmap
tusTextureCoordSetIndex :: TextureUnitState t -> Int
tusAddressMode :: TextureUnitState t -> UVWAddressingMode
tusBorderColour :: TextureUnitState t -> ColourValue
tusColourBlendMode :: TextureUnitState t -> LayerBlendModeEx
tusColourBlendFallbackSrc :: TextureUnitState t -> SceneBlendFactor
tusColourBlendFallbackDest :: TextureUnitState t -> SceneBlendFactor
tusAlphaBlendMode :: TextureUnitState t -> LayerBlendModeEx
tusIsAlpha :: TextureUnitState t -> Bool
tusHwGamma :: TextureUnitState t -> Bool
tusUMod :: TextureUnitState t -> FloatType
tusVMod :: TextureUnitState t -> FloatType
tusUScale :: TextureUnitState t -> FloatType
tusVScale :: TextureUnitState t -> FloatType
tusRotate :: TextureUnitState t -> FloatType

-- | Texture filtering - minification
tusMinFilter :: TextureUnitState t -> FilterOptions

-- | Texture filtering - magnification
tusMagFilter :: TextureUnitState t -> FilterOptions

-- | Texture filtering - mipmapping
tusMipFilter :: TextureUnitState t -> FilterOptions

-- | Texture anisotropy
tusMaxAniso :: TextureUnitState t -> Int

-- | Mipmap bias
tusMipmapBias :: TextureUnitState t -> FloatType

-- | Binding type (fragment or vertex pipeline)
tusBindingType :: TextureUnitState t -> BindingType

-- | Content type of texture (normal loaded texture, auto-texture)
tusContentType :: TextureUnitState t -> ContentType
tusFrameNames :: TextureUnitState t -> [String]
tusFrames :: TextureUnitState t -> Maybe [t]

-- | optional name for the TUS
tusName :: TextureUnitState t -> String

-- | optional alias for texture frames
tusTextureAlias :: TextureUnitState t -> String
tusEffects :: TextureUnitState t -> [TextureEffect]
instance Eq TextureEffectType
instance Ord TextureEffectType
instance Eq TextureAddressingMode
instance Ord TextureAddressingMode
instance Eq UVWAddressingMode
instance Ord UVWAddressingMode
instance Eq TextureEffect
instance Ord TextureEffect
instance Eq BindingType
instance Ord BindingType
instance Eq ContentType
instance Ord ContentType
instance Texture t => Eq (TextureUnitState t)
instance Texture t => Ord (TextureUnitState t)

module Graphics.LambdaCube.Pass

-- | Categorisation of passes for the purpose of additive lighting
data IlluminationStage

-- | Part of the rendering which occurs without any kind of direct lighting
IS_AMBIENT :: IlluminationStage

-- | Part of the rendering which occurs per light
IS_PER_LIGHT :: IlluminationStage

-- | Post-lighting rendering
IS_DECAL :: IlluminationStage

-- | Not determined
IS_UNKNOWN :: IlluminationStage
data (Texture t, LinkedGpuProgram lp) => Pass t lp
Pass :: String -> ColourValue -> ColourValue -> ColourValue -> ColourValue -> FloatType -> TrackVertexColourType -> SceneBlendFactor -> SceneBlendFactor -> SceneBlendFactor -> SceneBlendFactor -> Bool -> SceneBlendOperation -> SceneBlendOperation -> Bool -> Bool -> Bool -> CompareFunction -> FloatType -> FloatType -> FloatType -> Bool -> CompareFunction -> Int -> Bool -> Bool -> Bool -> CullingMode -> ManualCullingMode -> Bool -> Int -> Int -> Maybe Int -> Maybe LightTypes -> ShadeOptions -> PolygonMode -> Bool -> Bool -> Bool -> FogMode -> ColourValue -> FloatType -> FloatType -> FloatType -> [TextureUnitState t] -> Maybe GpuProgramUsage -> Maybe GpuProgramUsage -> Maybe GpuProgramUsage -> Maybe lp -> Int -> FloatType -> FloatType -> FloatType -> Bool -> Bool -> FloatType3 -> Bool -> Bool -> IlluminationStage -> Pass t lp

-- | optional name for the pass
psName :: Pass t lp -> String
psAmbient :: Pass t lp -> ColourValue
psDiffuse :: Pass t lp -> ColourValue
psSpecular :: Pass t lp -> ColourValue
psEmissive :: Pass t lp -> ColourValue
psShininess :: Pass t lp -> FloatType
psTracking :: Pass t lp -> TrackVertexColourType
psSourceBlendFactor :: Pass t lp -> SceneBlendFactor
psDestBlendFactor :: Pass t lp -> SceneBlendFactor
psSourceBlendFactorAlpha :: Pass t lp -> SceneBlendFactor
psDestBlendFactorAlpha :: Pass t lp -> SceneBlendFactor

-- | Used to determine if separate alpha blending should be used for color
--   and alpha channels
psSeparateBlend :: Pass t lp -> Bool
psBlendOperation :: Pass t lp -> SceneBlendOperation
psAlphaBlendOperation :: Pass t lp -> SceneBlendOperation

-- | Determines if we should use separate blending operations for color and
--   alpha channels
psSeparateBlendOperation :: Pass t lp -> Bool
psDepthCheck :: Pass t lp -> Bool
psDepthWrite :: Pass t lp -> Bool
psDepthFunc :: Pass t lp -> CompareFunction
psDepthBiasConstant :: Pass t lp -> FloatType
psDepthBiasSlopeScale :: Pass t lp -> FloatType
psDepthBiasPerIteration :: Pass t lp -> FloatType
psColourWrite :: Pass t lp -> Bool
psAlphaRejectFunc :: Pass t lp -> CompareFunction
psAlphaRejectVal :: Pass t lp -> Int
psAlphaToCoverageEnabled :: Pass t lp -> Bool

-- | Transparent depth sorting
psTransparentSorting :: Pass t lp -> Bool

-- | Transparent depth sorting forced
psTransparentSortingForced :: Pass t lp -> Bool
psCullMode :: Pass t lp -> CullingMode
psManualCullMode :: Pass t lp -> ManualCullingMode

-- | Lighting enabled?
psLightingEnabled :: Pass t lp -> Bool

-- | Max simultaneous lights
psMaxSimultaneousLights :: Pass t lp -> Int

-- | Starting light index
psStartLight :: Pass t lp -> Int

-- | Run this pass once per light? Iterate per how many lights?
psLightsPerIteration :: Pass t lp -> Maybe Int

-- | Should it only be run for a certain light type?
psOnlyLightType :: Pass t lp -> Maybe LightTypes

-- | Shading options
psShadeOptions :: Pass t lp -> ShadeOptions

-- | Polygon mode
psPolygonMode :: Pass t lp -> PolygonMode
psNormaliseNormals :: Pass t lp -> Bool
psPolygonModeOverrideable :: Pass t lp -> Bool
psFogOverride :: Pass t lp -> Bool
psFogMode :: Pass t lp -> FogMode
psFogColour :: Pass t lp -> ColourValue
psFogStart :: Pass t lp -> FloatType
psFogEnd :: Pass t lp -> FloatType
psFogDensity :: Pass t lp -> FloatType
psTextureUnitStates :: Pass t lp -> [TextureUnitState t]

-- | Vertex program details
psVertexProgramUsage :: Pass t lp -> Maybe GpuProgramUsage

-- | Fragment program details
psFragmentProgramUsage :: Pass t lp -> Maybe GpuProgramUsage

-- | Geometry program details
psGeometryProgramUsage :: Pass t lp -> Maybe GpuProgramUsage
psLinkedGpuProgram :: Pass t lp -> Maybe lp

-- | number of pass iterations to perform
psPassIterationCount :: Pass t lp -> Int

-- | point size, applies when not using per-vertex point size
psPointSize :: Pass t lp -> FloatType
psPointMinSize :: Pass t lp -> FloatType
psPointMaxSize :: Pass t lp -> FloatType
psPointSpritesEnabled :: Pass t lp -> Bool
psPointAttenuationEnabled :: Pass t lp -> Bool

-- | constant, linear, quadratic coeffs
psPointAttenuationCoeffs :: Pass t lp -> FloatType3

-- | Scissoring for the light?
psLightScissoring :: Pass t lp -> Bool

-- | User clip planes for light?
psLightClipPlanes :: Pass t lp -> Bool

-- | Illumination stage?
psIlluminationStage :: Pass t lp -> IlluminationStage
instance Eq IlluminationStage
instance Ord IlluminationStage
instance (Texture t, LinkedGpuProgram lp) => Eq (Pass t lp)
instance (Texture t, LinkedGpuProgram lp) => Ord (Pass t lp)

module Graphics.LambdaCube.Skeleton
data Bone
Bone :: Vec3 -> U -> Bone
bnPosition :: Bone -> Vec3
bnRotation :: Bone -> U
data KeyFrame
KeyFrame :: Vec3 -> U -> FloatType -> KeyFrame
kfPosition :: KeyFrame -> Vec3
kfRotation :: KeyFrame -> U
kfTime :: KeyFrame -> FloatType
data Animation
Animation :: Vector [KeyFrame] -> FloatType -> String -> Animation
anTracks :: Animation -> Vector [KeyFrame]
anLength :: Animation -> FloatType
anName :: Animation -> String
data Skeleton
Skeleton :: Vector Bone -> Tree Int -> Map String Animation -> Skeleton
skBones :: Skeleton -> Vector Bone
skBoneTree :: Skeleton -> Tree Int
skAnimations :: Skeleton -> Map String Animation
data PoseData
PoseData :: Proj4 -> Proj4 -> Proj4 -> Proj4 -> PoseData
pdJointMatrix :: PoseData -> Proj4
pdInverseBindMatrix :: PoseData -> Proj4
pdWorldMatrix :: PoseData -> Proj4
pdSkinningMatrix :: PoseData -> Proj4
instance Show Bone
instance Show KeyFrame
instance Show Animation
instance Show Skeleton

module Graphics.LambdaCube.Loader.SkeletonXML
readFloat :: String -> String -> Element -> Float
readStr :: String -> String -> Element -> String
readBone :: Element -> (String, Bone)
readKeyFrame :: Element -> KeyFrame
readTrack :: Element -> (String, [KeyFrame])
readAnimation :: [String] -> Element -> (String, Animation)
readSkeleton :: Element -> Skeleton
parseSkeleton :: String -> Skeleton
loadSkeleton :: FilePath -> IO Skeleton

module Graphics.LambdaCube.RenderSystemCapabilities
data Capabilities

-- | Supports generating mipmaps in hardware
RSC_AUTOMIPMAP :: Capabilities
RSC_BLENDING :: Capabilities

-- | Supports anisotropic texture filtering
RSC_ANISOTROPY :: Capabilities

-- | Supports fixed-function DOT3 texture blend
RSC_DOT3 :: Capabilities

-- | Supports cube mapping
RSC_CUBEMAPPING :: Capabilities

-- | Supports hardware stencil buffer
RSC_HWSTENCIL :: Capabilities

-- | Supports hardware vertex and index buffers
RSC_VBO :: Capabilities

-- | Supports vertex programs (vertex shaders)
RSC_VERTEX_PROGRAM :: Capabilities

-- | Supports fragment programs (pixel shaders)
RSC_FRAGMENT_PROGRAM :: Capabilities

-- | Supports performing a scissor test to exclude areas of the screen
RSC_SCISSOR_TEST :: Capabilities

-- | Supports separate stencil updates for both front and back faces
RSC_TWO_SIDED_STENCIL :: Capabilities

-- | Supports wrapping the stencil value at the range extremeties
RSC_STENCIL_WRAP :: Capabilities

-- | Supports hardware occlusion queries
RSC_HWOCCLUSION :: Capabilities

-- | Supports user clipping planes
RSC_USER_CLIP_PLANES :: Capabilities

-- | Supports the VET_UBYTE4 vertex element type
RSC_VERTEX_FORMAT_UBYTE4 :: Capabilities

-- | Supports infinite far plane projection
RSC_INFINITE_FAR_PLANE :: Capabilities

-- | Supports hardware render-to-texture (bigger than framebuffer)
RSC_HWRENDER_TO_TEXTURE :: Capabilities

-- | Supports float textures and render targets
RSC_TEXTURE_FLOAT :: Capabilities

-- | Supports non-power of two textures
RSC_NON_POWER_OF_2_TEXTURES :: Capabilities

-- | Supports 3d (volume) textures
RSC_TEXTURE_3D :: Capabilities

-- | Supports basic point sprite rendering
RSC_POINT_SPRITES :: Capabilities

-- | Supports extra point parameters (minsize, maxsize, attenuation)
RSC_POINT_EXTENDED_PARAMETERS :: Capabilities

-- | Supports vertex texture fetch
RSC_VERTEX_TEXTURE_FETCH :: Capabilities

-- | Supports mipmap LOD biasing
RSC_MIPMAP_LOD_BIAS :: Capabilities

-- | Supports hardware geometry programs
RSC_GEOMETRY_PROGRAM :: Capabilities

-- | Supports rendering to vertex buffers
RSC_HWRENDER_TO_VERTEX_BUFFER :: Capabilities

-- | Supports compressed textures
RSC_TEXTURE_COMPRESSION :: Capabilities

-- | Supports compressed textures in the DXT/ST3C formats
RSC_TEXTURE_COMPRESSION_DXT :: Capabilities

-- | Supports compressed textures in the VTC format
RSC_TEXTURE_COMPRESSION_VTC :: Capabilities

-- | Supports compressed textures in the PVRTC format
RSC_TEXTURE_COMPRESSION_PVRTC :: Capabilities

-- | Supports fixed-function pipeline
RSC_FIXED_FUNCTION :: Capabilities

-- | Supports MRTs with different bit depths
RSC_MRT_DIFFERENT_BIT_DEPTHS :: Capabilities

-- | Supports Alpha to Coverage (A2C)
RSC_ALPHA_TO_COVERAGE :: Capabilities

-- | Supports Blending operations other than +
RSC_ADVANCED_BLEND_OPERATIONS :: Capabilities

-- | Is DirectX feature <a>per stage constants</a> supported
RSC_PERSTAGECONSTANT :: Capabilities

-- | Supports openGL GLEW version 1.5
RSC_GL1_5_NOVBO :: Capabilities

-- | Support for Frame Buffer Objects (FBOs)
RSC_FBO :: Capabilities

-- | Support for Frame Buffer Objects ARB implementation (regular FBO is
--   higher precedence)
RSC_FBO_ARB :: Capabilities

-- | Support for Frame Buffer Objects ATI implementation (ARB FBO is higher
--   precedence)
RSC_FBO_ATI :: Capabilities

-- | Support for PBuffer
RSC_PBUFFER :: Capabilities

-- | Support for GL 1.5 but without HW occlusion workaround
RSC_GL1_5_NOHWOCCLUSION :: Capabilities

-- | Support for point parameters ARB implementation
RSC_POINT_EXTENDED_PARAMETERS_ARB :: Capabilities

-- | Support for point parameters EXT implementation
RSC_POINT_EXTENDED_PARAMETERS_EXT :: Capabilities
data DriverVersion
DriverVersion :: Int -> Int -> Int -> Int -> DriverVersion
dvMajor :: DriverVersion -> Int
dvMinor :: DriverVersion -> Int
dvRelease :: DriverVersion -> Int
dvBuild :: DriverVersion -> Int

-- | Enumeration of GPU vendors.
data GPUVendor
GPU_UNKNOWN :: GPUVendor
GPU_NVIDIA :: GPUVendor
GPU_ATI :: GPUVendor
GPU_INTEL :: GPUVendor
GPU_S3 :: GPUVendor
GPU_MATROX :: GPUVendor
GPU_3DLABS :: GPUVendor
GPU_SIS :: GPUVendor
GPU_IMAGINATION_TECHNOLOGIES :: GPUVendor

-- | Apple Software Renderer
GPU_APPLE :: GPUVendor
data RenderSystemCapabilities
RenderSystemCapabilities :: DriverVersion -> GPUVendor -> Int -> Int -> Set Capabilities -> String -> String -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> Int -> FloatType -> Bool -> Int -> Bool -> Int -> Set String -> RenderSystemCapabilities
rscDriverVersion :: RenderSystemCapabilities -> DriverVersion

-- | GPU Vendor
rscVendor :: RenderSystemCapabilities -> GPUVendor

-- | The number of texture units available
rscNumTextureUnits :: RenderSystemCapabilities -> Int

-- | The stencil buffer bit depth
rscStencilBufferBitDepth :: RenderSystemCapabilities -> Int

-- | Stores the capabilities flags.
rscCapabilities :: RenderSystemCapabilities -> Set Capabilities

-- | The name of the device as reported by the render system
rscDeviceName :: RenderSystemCapabilities -> String

-- | The identifier associated with the render system for which these
--   capabilities are valid
rscRenderSystemName :: RenderSystemCapabilities -> String

-- | The number of floating-point constants vertex programs support
rscVertexProgramConstantFloatCount :: RenderSystemCapabilities -> Int

-- | The number of integer constants vertex programs support
rscVertexProgramConstantIntCount :: RenderSystemCapabilities -> Int

-- | The number of boolean constants vertex programs support
rscVertexProgramConstantBoolCount :: RenderSystemCapabilities -> Int

-- | The number of floating-point constants geometry programs support
rscGeometryProgramConstantFloatCount :: RenderSystemCapabilities -> Int

-- | The number of integer constants vertex geometry support
rscGeometryProgramConstantIntCount :: RenderSystemCapabilities -> Int

-- | The number of boolean constants vertex geometry support
rscGeometryProgramConstantBoolCount :: RenderSystemCapabilities -> Int

-- | The number of floating-point constants fragment programs support
rscFragmentProgramConstantFloatCount :: RenderSystemCapabilities -> Int

-- | The number of integer constants fragment programs support
rscFragmentProgramConstantIntCount :: RenderSystemCapabilities -> Int

-- | The number of boolean constants fragment programs support
rscFragmentProgramConstantBoolCount :: RenderSystemCapabilities -> Int

-- | The number of simultaneous render targets supported
rscNumMultiRenderTargets :: RenderSystemCapabilities -> Int

-- | The maximum point size
rscMaxPointSize :: RenderSystemCapabilities -> FloatType

-- | Are non-POW2 textures feature-limited?
rscNonPOW2TexturesLimited :: RenderSystemCapabilities -> Bool

-- | The number of vertex texture units supported
rscNumVertexTextureUnits :: RenderSystemCapabilities -> Int

-- | Are vertex texture units shared with fragment processor?
rscVertexTextureUnitsShared :: RenderSystemCapabilities -> Bool

-- | The number of vertices a geometry program can emit in a single run
rscGeometryProgramNumOutputVertices :: RenderSystemCapabilities -> Int

-- | The list of supported shader profiles
rscSupportedShaderProfiles :: RenderSystemCapabilities -> Set String
instance Eq Capabilities
instance Ord Capabilities
instance Eq DriverVersion
instance Eq GPUVendor

module Graphics.LambdaCube.RenderSystem
data TexCoordCalcMethod

-- | No calculated texture coordinates
TEXCALC_NONE :: TexCoordCalcMethod

-- | Environment map based on vertex normals
TEXCALC_ENVIRONMENT_MAP :: TexCoordCalcMethod

-- | Environment map based on vertex positions
TEXCALC_ENVIRONMENT_MAP_PLANAR :: TexCoordCalcMethod

-- | Environment map based on vertex positions
TEXCALC_ENVIRONMENT_MAP_REFLECTION :: TexCoordCalcMethod

-- | Environment map based on vertex positions
TEXCALC_ENVIRONMENT_MAP_NORMAL :: TexCoordCalcMethod

-- | Projective texture
TEXCALC_PROJECTIVE_TEXTURE :: TexCoordCalcMethod
data StencilOperation

-- | Leave the stencil buffer unchanged
SOP_KEEP :: StencilOperation

-- | Set the stencil value to zero
SOP_ZERO :: StencilOperation

-- | Set the stencil value to the reference value
SOP_REPLACE :: StencilOperation

-- | Increase the stencil value by 1, clamping at the maximum value
SOP_INCREMENT :: StencilOperation

-- | Decrease the stencil value by 1, clamping at 0
SOP_DECREMENT :: StencilOperation

-- | Increase the stencil value by 1, wrapping back to 0 when incrementing
--   the maximum value
SOP_INCREMENT_WRAP :: StencilOperation

-- | Decrease the stencil value by 1, wrapping when decrementing 0
SOP_DECREMENT_WRAP :: StencilOperation

-- | Invert the bits of the stencil buffer
SOP_INVERT :: StencilOperation
class (HardwareVertexBuffer vb, HardwareIndexBuffer ib, HardwareOcclusionQuery q, Texture t, GpuProgram p, LinkedGpuProgram lp) => RenderSystem rs vb ib q t p lp | rs -> vb ib q t p lp
prepareRender :: RenderSystem rs vb ib q t p lp => rs -> IO ()
finishRender :: RenderSystem rs vb ib q t p lp => rs -> IO ()
createVertexBuffer :: RenderSystem rs vb ib q t p lp => rs -> Int -> Int -> Usage -> Bool -> IO vb
createIndexBuffer :: RenderSystem rs vb ib q t p lp => rs -> IndexType -> Int -> Usage -> Bool -> IO ib
createTexture :: RenderSystem rs vb ib q t p lp => rs -> String -> TextureType -> Int -> Int -> Int -> TextureMipmap -> PixelFormat -> TextureUsage -> Bool -> Int -> String -> Maybe [Image] -> IO t
withFrameBuffer :: RenderSystem rs vb ib q t p lp => rs -> Int -> Int -> Int -> Int -> (Ptr Word8 -> IO ()) -> IO ()
dirtyHackCopyTexImage :: RenderSystem rs vb ib q t p lp => rs -> t -> Int -> Int -> Int -> Int -> IO ()
createGpuProgram :: RenderSystem rs vb ib q t p lp => rs -> GpuProgramType -> String -> IO (Either p String)
createLinkedGpuProgram :: RenderSystem rs vb ib q t p lp => rs -> [p] -> IO (Either lp String)
getName :: RenderSystem rs vb ib q t p lp => rs -> String
createOcclusionQuery :: RenderSystem rs vb ib q t p lp => rs -> IO q
setAmbientLight :: RenderSystem rs vb ib q t p lp => rs -> Float -> Float -> Float -> IO ()
setShadingType :: RenderSystem rs vb ib q t p lp => rs -> ShadeOptions -> IO ()
setLightingEnabled :: RenderSystem rs vb ib q t p lp => rs -> Bool -> IO ()
setWBufferEnabled :: RenderSystem rs vb ib q t p lp => rs -> Bool -> IO ()
setWaitForVerticalBlank :: RenderSystem rs vb ib q t p lp => rs -> Bool -> IO ()
useLights :: RenderSystem rs vb ib q t p lp => rs -> [(Proj4, Light)] -> IO ()
setWorldMatrix :: RenderSystem rs vb ib q t p lp => rs -> Proj4 -> IO ()
setViewMatrix :: RenderSystem rs vb ib q t p lp => rs -> Proj4 -> IO ()
setProjectionMatrix :: RenderSystem rs vb ib q t p lp => rs -> Mat4 -> IO ()
setSurfaceParams :: RenderSystem rs vb ib q t p lp => rs -> ColourValue -> ColourValue -> ColourValue -> ColourValue -> FloatType -> TrackVertexColourType -> IO ()
setPointSpritesEnabled :: RenderSystem rs vb ib q t p lp => rs -> Bool -> IO ()
setPointParameters :: RenderSystem rs vb ib q t p lp => rs -> FloatType -> Bool -> FloatType -> FloatType -> FloatType -> FloatType -> FloatType -> IO ()
setActiveTextureUnit :: RenderSystem rs vb ib q t p lp => rs -> Int -> IO ()
setTexture :: RenderSystem rs vb ib q t p lp => rs -> Maybe t -> IO ()
setVertexTexture :: RenderSystem rs vb ib q t p lp => rs -> Maybe t -> IO ()
setTextureCoordCalculation :: RenderSystem rs vb ib q t p lp => rs -> TexCoordCalcMethod -> IO ()
setTextureBlendMode :: RenderSystem rs vb ib q t p lp => rs -> LayerBlendModeEx -> LayerBlendModeEx -> IO ()
setTextureUnitFiltering :: RenderSystem rs vb ib q t p lp => rs -> TextureType -> FilterOptions -> FilterOptions -> FilterOptions -> IO ()
setTextureLayerAnisotropy :: RenderSystem rs vb ib q t p lp => rs -> TextureType -> Int -> IO ()
setTextureAddressingMode :: RenderSystem rs vb ib q t p lp => rs -> TextureType -> UVWAddressingMode -> IO ()
setTextureBorderColour :: RenderSystem rs vb ib q t p lp => rs -> TextureType -> ColourValue -> IO ()
setTextureMipmapBias :: RenderSystem rs vb ib q t p lp => rs -> FloatType -> IO ()
setTextureMatrix :: RenderSystem rs vb ib q t p lp => rs -> Proj4 -> IO ()
setSceneBlending :: RenderSystem rs vb ib q t p lp => rs -> SceneBlendFactor -> SceneBlendFactor -> SceneBlendOperation -> IO ()
setSeparateSceneBlending :: RenderSystem rs vb ib q t p lp => rs -> SceneBlendFactor -> SceneBlendFactor -> SceneBlendFactor -> SceneBlendFactor -> SceneBlendOperation -> SceneBlendOperation -> IO ()
setAlphaRejectSettings :: RenderSystem rs vb ib q t p lp => rs -> CompareFunction -> Int -> Bool -> IO ()
setViewport :: RenderSystem rs vb ib q t p lp => rs -> Int -> Int -> Int -> Int -> IO ()
setCullingMode :: RenderSystem rs vb ib q t p lp => rs -> CullingMode -> IO ()
setDepthBufferParams :: RenderSystem rs vb ib q t p lp => rs -> Bool -> Bool -> CompareFunction -> IO ()
setDepthBufferCheckEnabled :: RenderSystem rs vb ib q t p lp => rs -> Bool -> IO ()
setDepthBufferWriteEnabled :: RenderSystem rs vb ib q t p lp => rs -> Bool -> IO ()
setDepthBufferFunction :: RenderSystem rs vb ib q t p lp => rs -> CompareFunction -> IO ()
setColourBufferWriteEnabled :: RenderSystem rs vb ib q t p lp => rs -> Bool -> Bool -> Bool -> Bool -> IO ()
setDepthBias :: RenderSystem rs vb ib q t p lp => rs -> FloatType -> FloatType -> IO ()
setFog :: RenderSystem rs vb ib q t p lp => rs -> FogMode -> ColourValue -> FloatType -> FloatType -> FloatType -> IO ()
setPolygonMode :: RenderSystem rs vb ib q t p lp => rs -> PolygonMode -> IO ()
setStencilCheckEnabled :: RenderSystem rs vb ib q t p lp => rs -> Bool -> IO ()
setStencilBufferParams :: RenderSystem rs vb ib q t p lp => rs -> CompareFunction -> Word32 -> Word32 -> StencilOperation -> StencilOperation -> StencilOperation -> Bool -> IO ()
setNormaliseNormals :: RenderSystem rs vb ib q t p lp => rs -> Bool -> IO ()
render :: RenderSystem rs vb ib q t p lp => rs -> RenderOperation vb ib -> IO ()
bindGeometry :: RenderSystem rs vb ib q t p lp => rs -> RenderOperation vb ib -> [TextureUnitState t] -> IO ()
unbindGeometry :: RenderSystem rs vb ib q t p lp => rs -> RenderOperation vb ib -> IO ()
getCapabilities :: RenderSystem rs vb ib q t p lp => rs -> RenderSystemCapabilities
bindLinkedGpuProgram :: RenderSystem rs vb ib q t p lp => rs -> lp -> IO ()
unbindLinkedGpuProgram :: RenderSystem rs vb ib q t p lp => rs -> IO ()
setScissorTest :: RenderSystem rs vb ib q t p lp => rs -> Bool -> Int -> Int -> Int -> Int -> IO ()
clearFrameBuffer :: RenderSystem rs vb ib q t p lp => rs -> FrameBufferType -> ColourValue -> FloatType -> Word16 -> IO ()
getHorizontalTexelOffset :: RenderSystem rs vb ib q t p lp => rs -> IO FloatType
getVerticalTexelOffset :: RenderSystem rs vb ib q t p lp => rs -> IO FloatType
getMinimumDepthInputValue :: RenderSystem rs vb ib q t p lp => rs -> FloatType
getMaximumDepthInputValue :: RenderSystem rs vb ib q t p lp => rs -> FloatType
class (HardwareVertexBuffer vb, HardwareIndexBuffer ib, Texture t, LinkedGpuProgram lp) => Renderable r vb ib t lp | r -> vb ib t lp
prepare :: Renderable r vb ib t lp => Proj4 -> r -> [RenderEntity vb ib t lp]
data (HardwareVertexBuffer vb, HardwareIndexBuffer ib, Texture t, LinkedGpuProgram lp) => RenderEntity vb ib t lp
RenderEntity :: RenderOperation vb ib -> [Pass t lp] -> Proj4 -> FloatType -> RenderEntity vb ib t lp
reOperation :: RenderEntity vb ib t lp -> RenderOperation vb ib
rePassList :: RenderEntity vb ib t lp -> [Pass t lp]
reMatrix :: RenderEntity vb ib t lp -> Proj4
reBoundRadius :: RenderEntity vb ib t lp -> FloatType
setPass :: RenderSystem rs vb ib q t p lp => FloatType -> rs -> Pass t lp -> IO ()
setTextureUnitSettings :: RenderSystem rs vb ib q t p lp => FloatType -> rs -> Int -> TextureUnitState t -> IO ()
instance Eq TexCoordCalcMethod
instance Eq StencilOperation

module Graphics.LambdaCube.RenderQueue

-- | Standard render queue priorities. Note that any enumeration type can
--   be used to specify render priorities (i.e. top-level drawing order),
--   this is just a simple convenience type.
data RenderQueuePriority
RQP_Background :: RenderQueuePriority
RQP_EarlySky :: RenderQueuePriority
RQP_EarlyWorld :: RenderQueuePriority
RQP_Main :: RenderQueuePriority
RQP_LateWorld :: RenderQueuePriority
RQP_LateSky :: RenderQueuePriority
RQP_Overlay :: RenderQueuePriority

-- | The default render queue priority.
defaultRQP :: Maybe RenderQueuePriority
renderableDefaultPriority :: Int
data RenderGroupOptions
RenderGroupOptions :: Bool -> RenderGroupOptions
rqoShadowsEnabled :: RenderGroupOptions -> Bool
defaultRenderGroupOptions :: RenderGroupOptions

-- | Struct associating a single Pass with a single Renderable.
data (HardwareVertexBuffer vb, HardwareIndexBuffer ib, Texture t, LinkedGpuProgram lp) => RenderablePass vb ib t lp
RenderablePass :: RenderOperation vb ib -> Pass t lp -> Proj4 -> [(Proj4, Light)] -> RenderablePass vb ib t lp
rpOperation :: RenderablePass vb ib t lp -> RenderOperation vb ib
rpPass :: RenderablePass vb ib t lp -> Pass t lp
rpMatrix :: RenderablePass vb ib t lp -> Proj4
rpLights :: RenderablePass vb ib t lp -> [(Proj4, Light)]
data RenderStatistics
RenderStatistics :: Int -> Int -> Int -> RenderStatistics
rsFaceCount :: RenderStatistics -> Int
rsVertexCount :: RenderStatistics -> Int
rsBatchCount :: RenderStatistics -> Int
emptyRenderStatistics :: RenderStatistics
renderPassGroup :: RenderSystem rs vb ib q t p lp => FloatType -> rs -> RenderStatistics -> [RenderablePass vb ib t lp] -> IO RenderStatistics
renderCollection :: RenderSystem rs vb ib q t p lp => FloatType -> rs -> IntMap RenderGroupOptions -> [(Proj4, Light)] -> RenderStatistics -> [(Proj4, [RenderEntity vb ib t lp], Int, Int)] -> IO RenderStatistics
renderQueue :: RenderSystem rs vb ib q t p lp => FloatType -> rs -> IntMap RenderGroupOptions -> RenderStatistics -> [(Proj4, Light)] -> [(Proj4, [RenderEntity vb ib t lp], Int, Int)] -> IO RenderStatistics
instance Enum RenderQueuePriority
instance Show RenderStatistics

module Graphics.LambdaCube.VertexBufferVector

-- | The types of <a>VectorVertexData</a> without the data.
data VectorVertexType
VVT_POSITION :: VectorVertexType
VVT_BLEND_WEIGHTS :: VectorVertexType
VVT_BLEND_INDICES :: VectorVertexType
VVT_NORMAL :: VectorVertexType
VVT_DIFFUSE :: VectorVertexType
VVT_SPECULAR :: VectorVertexType
VVT_TEXTURE_COORDINATES1 :: VectorVertexType
VVT_TEXTURE_COORDINATES2 :: VectorVertexType
VVT_TEXTURE_COORDINATES3 :: VectorVertexType
VVT_BINORMAL :: VectorVertexType
VVT_TANGENT :: VectorVertexType

-- | Primitive buffer data
data VectorVertexData
VVD_POSITION :: (Vector Vec3) -> VectorVertexData
VVD_BLEND_WEIGHTS :: (Vector FloatType) -> VectorVertexData
VVD_BLEND_INDICES :: (Vector Int) -> VectorVertexData
VVD_NORMAL :: (Vector Vec3) -> VectorVertexData
VVD_DIFFUSE :: (Vector Vec4) -> VectorVertexData
VVD_SPECULAR :: (Vector Vec3) -> VectorVertexData
VVD_TEXTURE_COORDINATES1 :: (Vector FloatType) -> VectorVertexData
VVD_TEXTURE_COORDINATES2 :: (Vector Vec2) -> VectorVertexData
VVD_TEXTURE_COORDINATES3 :: (Vector Vec3) -> VectorVertexData
VVD_BINORMAL :: (Vector Vec3) -> VectorVertexData
VVD_TANGENT :: (Vector Vec3) -> VectorVertexData
type VVB = Vector VectorVertexData
type VIB = Vector Int

-- | Multimaterial geometry, including a default geometry for submeshes
--   that don't provide their own.
data VMesh
VMesh :: [VSubMesh] -> Maybe VVB -> VMesh

-- | The collection of single-material submeshes making up the mesh.
vmSubMeshList :: VMesh -> [VSubMesh]

-- | Default geometry for submeshes.
vmSharedVertexData :: VMesh -> Maybe VVB

-- | Geometry with associated material.
data VSubMesh
VSubMesh :: String -> OperationType -> Maybe VVB -> Maybe VIB -> VSubMesh

-- | The material associated with the submesh.
vsmMaterialName :: VSubMesh -> String

-- | The type of primitives making up the geometry.
vsmOperationType :: VSubMesh -> OperationType

-- | Optional vertex buffer (supplied by the containing mesh if absent).
vsmVertexData :: VSubMesh -> Maybe VVB

-- | Optional index buffer.
vsmIndexData :: VSubMesh -> Maybe VIB

-- | Extract the type of the vertex data.
vectorVertexType :: VectorVertexData -> VectorVertexType
toVectorIndexData :: HardwareIndexBuffer ib => IndexData ib -> IO VIB
fromVectorIndexData :: RenderSystem rs vb ib q t p lp => rs -> VIB -> IO (IndexData ib)
toVectorVertexData :: HardwareVertexBuffer vb => VertexData vb -> IO (Vector VectorVertexData)
fromVectorVertexData :: RenderSystem rs vb ib q t p lp => rs -> Vector VectorVertexData -> IO (VertexData vb)
meshFromV :: RenderSystem rs vb ib q t p lp => rs -> VMesh -> IO (Mesh vb ib)
vFromMesh :: (HardwareVertexBuffer vb, HardwareIndexBuffer ib) => Mesh vb ib -> IO VMesh
instance Eq VectorVertexType
instance Ord VectorVertexType
instance Show VectorVertexType
instance Show VectorVertexData


-- | Functions for combining meshes.
module Graphics.LambdaCube.MeshUtil

-- | Build a single mesh that represents the union of a list of transformed
--   meshes (given the orientation and translation for each constituent).
--   The resulting mesh is optimised with respect to context switches
--   during rendering.
mkVMesh :: [(U, Vec3, VMesh)] -> VMesh

-- | Build a single mesh that represents the union of a list of transformed
--   meshes (given the transformation matrix for each constituent). The
--   resulting mesh is optimised with respect to context switches during
--   rendering.
mkVMesh' :: [(Proj4, VMesh)] -> VMesh

module Graphics.LambdaCube.Loader.VMesh
lift :: IO b -> Get b
putIndices :: Maybe (Vector Int) -> Put
getIndices :: Get (Maybe (Vector Int))
decodeVMesh :: ByteString -> VMesh
encodeVMesh :: VMesh -> ByteString
loadVMesh :: FilePath -> IO VMesh
saveVMesh :: FilePath -> VMesh -> IO ()
instance Binary VMesh
instance Binary VSubMesh
instance Binary OperationType
instance Binary VectorVertexData
instance Binary a => Binary (Vector a)
instance Binary Mat4
instance Binary Mat3
instance Binary Mat2
instance Binary Vec4
instance Binary Vec3
instance Binary Vec2

module Graphics.LambdaCube.Loader.MeshXML
readBool :: String -> Bool -> Element -> Bool
readInt :: String -> Int -> Element -> Int
readFloatType :: String -> FloatType -> Element -> FloatType
readStr :: String -> String -> Element -> String
readBoneAssignments :: Element -> ([Int], [FloatType])
readDecl :: (Element, Int) -> [VertexElement]
readGeometry :: RenderSystem rs vb ib q t p lp => rs -> Element -> IO (VertexData vb)
readSubMesh :: RenderSystem rs vb ib q t p lp => rs -> Element -> IO (SubMesh vb ib)
readMesh :: RenderSystem rs vb ib q t p lp => rs -> Element -> IO (Mesh vb ib)
parseMesh :: RenderSystem rs vb ib q t p lp => rs -> String -> IO (Mesh vb ib)
loadMesh :: RenderSystem rs vb ib q t p lp => rs -> FilePath -> IO (Mesh vb ib)

module Graphics.LambdaCube.Technique
data IlluminationPassesState
IPS_COMPILE_DISABLED :: IlluminationPassesState
IPS_NOT_COMPILED :: IlluminationPassesState
IPS_COMPILED :: IlluminationPassesState
data IncludeOrExclude

-- | Inclusive - only support if present
INCLUDE :: IncludeOrExclude

-- | Exclusive - do not support if present
EXCLUDE :: IncludeOrExclude
data GPUVendorRule
GPUVendorRule :: GPUVendor -> IncludeOrExclude -> GPUVendorRule
gvrVendor :: GPUVendorRule -> GPUVendor
gvrIncludeOrExclude :: GPUVendorRule -> IncludeOrExclude
data GPUDeviceNameRule
GPUDeviceNameRule :: String -> IncludeOrExclude -> Bool -> GPUDeviceNameRule
gdrDevicePattern :: GPUDeviceNameRule -> String
gdrIncludeOrExclude :: GPUDeviceNameRule -> IncludeOrExclude
gdrCaseSensitive :: GPUDeviceNameRule -> Bool
data (Texture t, LinkedGpuProgram lp) => Technique t lp
Technique :: [Pass t lp] -> Int -> Int -> String -> [GPUVendorRule] -> [GPUDeviceNameRule] -> Technique t lp

-- | List of primary passes
tchPasses :: Technique t lp -> [Pass t lp]

-- | LOD level
tchLodIndex :: Technique t lp -> Int

-- | Scheme index, derived from scheme name but the names are held on
--   MaterialManager, for speed an index is used here.
tchSchemeIndex :: Technique t lp -> Int

-- | optional name for the technique
tchName :: Technique t lp -> String
tchGPUVendorRules :: Technique t lp -> [GPUVendorRule]
tchGPUDeviceNameRules :: Technique t lp -> [GPUDeviceNameRule]
instance Eq IlluminationPassesState
instance Eq IncludeOrExclude
instance Eq GPUVendorRule
instance Eq GPUDeviceNameRule

module Graphics.LambdaCube.Material
data (Texture t, LinkedGpuProgram lp) => Material t lp
Material :: String -> [Technique t lp] -> Maybe [Technique t lp] -> [FloatType] -> [FloatType] -> Bool -> Bool -> String -> Material t lp
mtName :: Material t lp -> String

-- | All techniques, supported and unsupported
mtTechniques :: Material t lp -> [Technique t lp]

-- | Supported techniques of any sort
mtSupportedTechniques :: Material t lp -> Maybe [Technique t lp]

-- | distance list used to specify LOD
mtUserLodValues :: Material t lp -> [FloatType]

-- | distance list used to specify LOD
mtLodValues :: Material t lp -> [FloatType]
mtReceiveShadows :: Material t lp -> Bool
mtTransparencyCastsShadows :: Material t lp -> Bool

-- | Text description of why any techniques are not supported
mtUnsupportedReasons :: Material t lp -> String

module Graphics.LambdaCube.Compositor
data PassType

-- | Clear target to one colour
PT_CLEAR :: PassType

-- | Set stencil operation
PT_STENCIL :: PassType

-- | Render the scene or part of it
PT_RENDERSCENE :: PassType

-- | Render a full screen quad
PT_RENDERQUAD :: PassType

-- | Input mode of a TargetPass
data InputMode

-- | No input
IM_NONE :: InputMode

-- | Output of previous Composition in chain
IM_PREVIOUS :: InputMode
data (Texture t, LinkedGpuProgram lp) => Compositor t lp
Compositor :: String -> [CompositionTechnique t lp] -> Maybe [CompositionTechnique t lp] -> Compositor t lp
cmpName :: Compositor t lp -> String
cmpTechniques :: Compositor t lp -> [CompositionTechnique t lp]
cmpSupportedTechniques :: Compositor t lp -> Maybe [CompositionTechnique t lp]
data Texture t => TextureDefinition t
TextureDefinition :: String -> Maybe Int -> Maybe Int -> FloatType -> FloatType -> [PixelFormat] -> Bool -> Bool -> Bool -> Maybe t -> TextureDefinition t
tdName :: TextureDefinition t -> String

-- | Nothing means adapt to target width
tdWidth :: TextureDefinition t -> Maybe Int

-- | Nothing means adapt to target height
tdHeight :: TextureDefinition t -> Maybe Int

-- | multiple of target width to use (if width = Nothing)
tdWidthFactor :: TextureDefinition t -> FloatType

-- | multiple of target height to use (if height = Nothing)
tdHeightFactor :: TextureDefinition t -> FloatType

-- | more than one means MRT
tdFormatList :: TextureDefinition t -> [PixelFormat]

-- | FSAA enabled; true = determine from main target (if render_scene),
--   false = disable
tdFsaa :: TextureDefinition t -> Bool

-- | Do sRGB gamma correction on write (only 8-bit per channel formats)
tdHwGammaWrite :: TextureDefinition t -> Bool

-- | whether to use shared textures for this one
tdShared :: TextureDefinition t -> Bool
tdTexture :: TextureDefinition t -> Maybe t
data InputTex
InputTex :: String -> Int -> InputTex

-- | Name (local) of the input texture
itName :: InputTex -> String

-- | MRT surface index if applicable
itMrtIndex :: InputTex -> Int
data (Texture t, LinkedGpuProgram lp) => CompositionTechnique t lp
CompositionTechnique :: [TextureDefinition t] -> [CompositionTargetPass t lp] -> CompositionTargetPass t lp -> String -> CompositionTechnique t lp

-- | Local texture definitions
ctTextureDefinitions :: CompositionTechnique t lp -> [TextureDefinition t]

-- | Intermediate target passes
ctTargetPasses :: CompositionTechnique t lp -> [CompositionTargetPass t lp]

-- | Output target pass (can be only one)
ctOutputTarget :: CompositionTechnique t lp -> CompositionTargetPass t lp

-- | Optional scheme name
ctSchemeName :: CompositionTechnique t lp -> String
data (Texture t, LinkedGpuProgram lp) => CompositionTargetPass t lp
CompositionTargetPass :: InputMode -> String -> Maybe (TextureDefinition t) -> [CompositionPass t lp] -> Bool -> Word32 -> FloatType -> String -> Bool -> CompositionTargetPass t lp

-- | Input name
ctpInputMode :: CompositionTargetPass t lp -> InputMode

-- | (local) output texture
ctpOutputName :: CompositionTargetPass t lp -> String
ctpOutput :: CompositionTargetPass t lp -> Maybe (TextureDefinition t)

-- | Passes
ctpPasses :: CompositionTargetPass t lp -> [CompositionPass t lp]

-- | This target pass is only executed initially after the effect has been
--   enabled.
ctpOnlyInitial :: CompositionTargetPass t lp -> Bool

-- | Visibility mask for this render
ctpVisibilityMask :: CompositionTargetPass t lp -> Word32

-- | LOD bias of this render
ctpLodBias :: CompositionTargetPass t lp -> FloatType

-- | Material scheme name
ctpMaterialScheme :: CompositionTargetPass t lp -> String

-- | Shadows option
ctpShadowsEnabled :: CompositionTargetPass t lp -> Bool
data (Texture t, LinkedGpuProgram lp) => CompositionPass t lp
CompositionPass :: PassType -> Word32 -> String -> Maybe (Material t lp) -> Int -> Int -> (Bool, Bool, Bool) -> ColourValue -> FloatType -> Word32 -> IntMap InputTex -> Bool -> CompareFunction -> Word32 -> Word32 -> StencilOperation -> StencilOperation -> StencilOperation -> Bool -> Bool -> FloatType -> FloatType -> FloatType -> FloatType -> Bool -> Bool -> CompositionPass t lp

-- | Type of composition pass
cpType :: CompositionPass t lp -> PassType

-- | Identifier for this pass
cpIdentifier :: CompositionPass t lp -> Word32

-- | Material used for rendering
cpMaterialName :: CompositionPass t lp -> String
cpMaterial :: CompositionPass t lp -> Maybe (Material t lp)

-- | <ul>
--   <li><i>first,last</i> render queue to render this pass (in case of
--   PT_RENDERSCENE)</li>
--   </ul>
cpFirstRenderQueue :: CompositionPass t lp -> Int
cpLastRenderQueue :: CompositionPass t lp -> Int

-- | Clear buffers (in case of PT_CLEAR), hint: [colour] [depth] [stencil]
cpClearBuffers :: CompositionPass t lp -> (Bool, Bool, Bool)

-- | Clear colour (in case of PT_CLEAR)
cpClearColour :: CompositionPass t lp -> ColourValue

-- | Clear depth (in case of PT_CLEAR)
cpClearDepth :: CompositionPass t lp -> FloatType

-- | Clear stencil value (in case of PT_CLEAR)
cpClearStencil :: CompositionPass t lp -> Word32

-- | Inputs (for material used for rendering the quad)
cpInputs :: CompositionPass t lp -> IntMap InputTex

-- | Stencil operation parameters
cpStencilCheck :: CompositionPass t lp -> Bool
cpStencilFunc :: CompositionPass t lp -> CompareFunction
cpStencilRefValue :: CompositionPass t lp -> Word32
cpStencilMask :: CompositionPass t lp -> Word32
cpStencilFailOp :: CompositionPass t lp -> StencilOperation
cpStencilDepthFailOp :: CompositionPass t lp -> StencilOperation
cpStencilPassOp :: CompositionPass t lp -> StencilOperation
cpStencilTwoSidedOperation :: CompositionPass t lp -> Bool

-- | true if quad should not cover whole screen
cpQuadCornerModified :: CompositionPass t lp -> Bool

-- | quad positions in normalised coordinates [-1;1]x[-1;1] (in case of
--   PT_RENDERQUAD)
cpQuadLeft :: CompositionPass t lp -> FloatType
cpQuadTop :: CompositionPass t lp -> FloatType
cpQuadRight :: CompositionPass t lp -> FloatType
cpQuadBottom :: CompositionPass t lp -> FloatType
cpQuadFarCorners :: CompositionPass t lp -> Bool
cpQuadFarCornersViewSpace :: CompositionPass t lp -> Bool
instance Eq InputMode

module Graphics.LambdaCube.Entity

-- | The sub-parts of an Entity. Its primary function is to provide the
--   link between the Material which the SubEntity uses (which may be the
--   default Material for the SubMesh or may have been changed for this
--   object) and the SubMesh data.
data (HardwareVertexBuffer vb, HardwareIndexBuffer ib, Texture t, LinkedGpuProgram lp) => SubEntity vb ib t lp
SubEntity :: Material t lp -> SubMesh vb ib -> SubEntity vb ib t lp

-- | Cached pointer to material.
seMaterial :: SubEntity vb ib t lp -> Material t lp

-- | Pointer to the SubMesh defining geometry.
seSubMesh :: SubEntity vb ib t lp -> SubMesh vb ib
data VertexDataBindChoice
BIND_ORIGINAL :: VertexDataBindChoice
BIND_SOFTWARE_SKELETAL :: VertexDataBindChoice
BIND_SOFTWARE_MORPH :: VertexDataBindChoice
BIND_HARDWARE_MORPH :: VertexDataBindChoice
data (HardwareVertexBuffer vb, HardwareIndexBuffer ib, Texture t, LinkedGpuProgram lp) => Entity vb ib t lp
Entity :: String -> Int -> Mesh vb ib -> [SubEntity vb ib t lp] -> Entity vb ib t lp
enName :: Entity vb ib t lp -> String
enRenderQueue :: Entity vb ib t lp -> Int
enMesh :: Entity vb ib t lp -> Mesh vb ib
enSubEntityList :: Entity vb ib t lp -> [SubEntity vb ib t lp]
prepareEntity :: (HardwareIndexBuffer ib, HardwareVertexBuffer vb, Texture t, LinkedGpuProgram lp) => Proj4 -> Entity vb ib t lp -> [RenderEntity vb ib t lp]
instance (HardwareVertexBuffer vb, HardwareIndexBuffer ib, Texture t, LinkedGpuProgram lp) => Renderable (Entity vb ib t lp) vb ib t lp

module Graphics.LambdaCube.Loader.ParserUtil
(<$=) :: IsParser p Token => b -> String -> p b
(<*=) :: IsParser p Token => p a -> String -> p a
pBool :: AnaParser [Token] Pair Token (Maybe Token) Bool
pOnOff :: AnaParser [Token] Pair Token (Maybe Token) Bool
pInt :: AnaParser [Token] Pair Token (Maybe Token) Int
pFloat :: AnaParser [Token] Pair Token (Maybe Token) FloatType
pName :: AnaParser [Token] Pair Token (Maybe Token) String
pEnum :: IsParser p Token => [(String, t)] -> p t
pColour :: FloatType -> AnaParser [Token] Pair Token (Maybe Token) (Either FloatType4 ())
pFloat3 :: AnaParser [Token] Pair Token (Maybe Token) FloatType3
pFloat4 :: AnaParser [Token] Pair Token (Maybe Token) FloatType4
pRGBOrRGBA :: FloatType -> AnaParser [Token] Pair Token (Maybe Token) FloatType4
pRGBA :: AnaParser [Token] Pair Token (Maybe Token) FloatType4
pRGB :: FloatType -> AnaParser [Token] Pair Token (Maybe Token) FloatType4
def :: a -> [a] -> a
boolVals :: [(String, Bool)]
onoffVals :: [(String, Bool)]
ruleopVals :: [(String, IncludeOrExclude)]
cmpfuncVals :: [(String, CompareFunction)]
shadingVals :: [(String, ShadeOptions)]
polymodeVals :: [(String, PolygonMode)]
blendopVals :: [(String, SceneBlendOperation)]
blendVals :: [(String, SceneBlendFactor)]
sceneblendVals :: [(String, SceneBlendType)]
illumstageVals :: [(String, IlluminationStage)]
cullhwVals :: [(String, CullingMode)]
cullswVals :: [(String, ManualCullingMode)]
lighttypeVals :: [(String, LightTypes)]
copVals :: [(String, LayerBlendOperation)]
btyVals :: [(String, BindingType)]
ctyVals :: [(String, ContentType)]
pixelformatVals :: [(String, PixelFormat)]
textypeVals :: [(String, TextureType)]
texaddressVals :: [(String, TextureAddressingMode)]
texfilteringVals :: [(String, (FilterOptions, FilterOptions, FilterOptions))]
filteringVals :: [(String, FilterOptions)]
envmapVals :: [(String, Maybe EnvMapType)]
xformtypeVals :: [(String, TextureTransformType)]
wavetypeVals :: [(String, WaveformType)]
stencilopVals :: [(String, StencilOperation)]
fogmodeVals :: [(String, FogMode)]
layerblendopexVals :: [(String, LayerBlendOperationEx)]
layerblendsrcVals :: [(String, LayerBlendSource)]
inputVals :: [(String, InputMode)]
compositorPixelFormatVals :: [(String, PixelFormat)]

module Graphics.LambdaCube.Loader.ResourceScript
loadResourcesCfg :: FilePath -> IO (Maybe [(String, [(PathType, String)])])

-- | The type of path leading to a resource.
data PathType

-- | An ordinary directory.
PathDir :: PathType

-- | A zip compressed directory.
PathZip :: PathType
type ResourcePath = (PathType, String)
type ResourceGroup = (String, [ResourcePath])

module Graphics.LambdaCube.World
newtype LCM w e a
LCM :: (forall r. (a -> w -> IO r) -> (e -> w -> IO r) -> w -> IO r) -> LCM w e a
unLCM :: LCM w e a -> forall r. (a -> w -> IO r) -> (e -> w -> IO r) -> w -> IO r

-- | Embed a LambdaCube program in IO. The embedding manages a world,
--   therefore it requires all the information to create one: the render
--   system and a list of image loaders.
runLCM :: RenderSystem r vb ib q t1 p lp => r -> [ImageLoader] -> LCM (World r vb ib q t1 p lp) e a -> IO ()
inLCM :: (w -> IO w) -> LCM w e ()
peekLCM :: LCM w e w
pokeLCM :: w -> LCM w e ()
throwLCM :: e -> LCM w e a
catchLCM :: LCM w a a -> LCM w e a
errorLCM :: String -> String -> LCM w e ()
debugLCM :: String -> String -> LCM w e ()
data (HardwareVertexBuffer vb, HardwareIndexBuffer ib, Texture t, LinkedGpuProgram lp) => FlattenScene vb ib t lp
FlattenScene :: [(Proj4, [RenderEntity vb ib t lp], Int, Int)] -> [(Proj4, Camera)] -> [(Proj4, Light)] -> FlattenScene vb ib t lp

-- | List of Renderable information including WorldMatrix RenderQueueID and
--   RenderPriority
fsRenderable :: FlattenScene vb ib t lp -> [(Proj4, [RenderEntity vb ib t lp], Int, Int)]
fsCamera :: FlattenScene vb ib t lp -> [(Proj4, Camera)]
fsLight :: FlattenScene vb ib t lp -> [(Proj4, Light)]
data RenderSystem r vb ib q t p lp => World r vb ib q t p lp
World :: ResourceLibrary vb ib t p lp -> r -> Scene vb ib t lp -> Map String (RenderTarget t lp) -> IntMap RenderGroupOptions -> [ImageLoader] -> World r vb ib q t p lp
wrResource :: World r vb ib q t p lp -> ResourceLibrary vb ib t p lp
wrRenderSystem :: World r vb ib q t p lp -> r
wrScene :: World r vb ib q t p lp -> Scene vb ib t lp
wrTargets :: World r vb ib q t p lp -> Map String (RenderTarget t lp)
wrRenderOptions :: World r vb ib q t p lp -> IntMap RenderGroupOptions
wrImageLoaders :: World r vb ib q t p lp -> [ImageLoader]
updateWorld :: (w -> w) -> LCM w e ()
updateResource :: RenderSystem r vb ib q t p lp => (ResourceLibrary vb ib t p lp -> ResourceLibrary vb ib t p lp) -> LCM (World r vb ib q t p lp) e ()
mapScene :: RenderSystem r vb ib q t p lp => (Scene vb ib t lp -> Scene vb ib t lp) -> World r vb ib q t p lp -> World r vb ib q t p lp
mapTargets :: RenderSystem r vb ib q t p lp => (Map String (RenderTarget t lp) -> Map String (RenderTarget t lp)) -> World r vb ib q t p lp -> World r vb ib q t p lp
mkWorld :: RenderSystem r vb ib q t p lp => r -> [ImageLoader] -> World r vb ib q t p lp
mkResource :: (HardwareVertexBuffer vb, HardwareIndexBuffer ib, Texture t, GpuProgram p, LinkedGpuProgram lp) => ResourceLibrary vb ib t p lp
mkScene :: (HardwareVertexBuffer vb, HardwareIndexBuffer ib, Texture t, LinkedGpuProgram lp) => Scene vb ib t lp
data (HardwareVertexBuffer vb, HardwareIndexBuffer ib, Texture t, GpuProgram p, LinkedGpuProgram lp) => ResourceLibrary vb ib t p lp
ResourceLibrary :: [ResourceGroup] -> Map String (Mesh vb ib) -> Map String (Material t lp) -> Map String t -> Map String (GpuProgramDescriptor p) -> Map (String, String, String) lp -> Map String (Compositor t lp) -> ResourceLibrary vb ib t p lp
rlResourceGroups :: ResourceLibrary vb ib t p lp -> [ResourceGroup]
rlMeshMap :: ResourceLibrary vb ib t p lp -> Map String (Mesh vb ib)
rlMaterialMap :: ResourceLibrary vb ib t p lp -> Map String (Material t lp)
rlTextureMap :: ResourceLibrary vb ib t p lp -> Map String t
rlGpuProgramMap :: ResourceLibrary vb ib t p lp -> Map String (GpuProgramDescriptor p)
rlLinkedGpuProgramMap :: ResourceLibrary vb ib t p lp -> Map (String, String, String) lp
rlCompositorMap :: ResourceLibrary vb ib t p lp -> Map String (Compositor t lp)

-- | Camera description.
data Camera
Camera :: String -> FloatType -> FloatType -> FloatType -> Maybe FloatType -> PolygonMode -> Camera

-- | The name of the camera.
cmName :: Camera -> String

-- | Field of view in radians.
cmFov :: Camera -> FloatType

-- | Near plane clipping distance.
cmNear :: Camera -> FloatType

-- | Far plane clipping distance.
cmFar :: Camera -> FloatType

-- | Camera aspect ratio (width/height).
cmAspectRatio :: Camera -> Maybe FloatType

-- | Rendering type.
cmPolygonMode :: Camera -> PolygonMode
cameraProjectionMatrix :: FloatType -> Camera -> Mat4
data (HardwareVertexBuffer vb, HardwareIndexBuffer ib, Texture t, LinkedGpuProgram lp) => SceneObject vb ib t lp
SO_Entity :: (Entity vb ib t lp) -> SceneObject vb ib t lp
SO_Camera :: Camera -> SceneObject vb ib t lp
SO_Light :: Light -> SceneObject vb ib t lp
data (Texture t, LinkedGpuProgram lp) => RenderTarget t lp
RenderTarget :: String -> Int -> Int -> [Viewport t lp] -> Maybe String -> RenderTarget t lp
rtName :: RenderTarget t lp -> String
rtWidth :: RenderTarget t lp -> Int
rtHeight :: RenderTarget t lp -> Int
rtViewport :: RenderTarget t lp -> [Viewport t lp]
rtTexture :: RenderTarget t lp -> Maybe String
data (Texture t, LinkedGpuProgram lp) => Viewport t lp
Viewport :: FloatType -> FloatType -> FloatType -> FloatType -> String -> [Compositor t lp] -> ColourValue -> Bool -> FrameBufferType -> Viewport t lp
vpLeft :: Viewport t lp -> FloatType
vpTop :: Viewport t lp -> FloatType
vpWidth :: Viewport t lp -> FloatType
vpHeight :: Viewport t lp -> FloatType
vpCamera :: Viewport t lp -> String
vpCompositors :: Viewport t lp -> [Compositor t lp]
vpBackColour :: Viewport t lp -> ColourValue
vpClearEveryFrame :: Viewport t lp -> Bool
vpClearBuffers :: Viewport t lp -> FrameBufferType
getViewportSize :: (Texture t, LinkedGpuProgram lp) => RenderTarget t lp -> Viewport t lp -> (Int, Int, Int, Int)
data (HardwareVertexBuffer vb, HardwareIndexBuffer ib, Texture t, LinkedGpuProgram lp) => SceneNode vb ib t lp
SceneNode :: String -> [SceneObject vb ib t lp] -> Proj4 -> SceneNode vb ib t lp
snName :: SceneNode vb ib t lp -> String
snObject :: SceneNode vb ib t lp -> [SceneObject vb ib t lp]
snTransform :: SceneNode vb ib t lp -> Proj4
data Sky
SkyBox :: Sky
SkyDome :: Sky
SkyPlane :: Sky
data (HardwareVertexBuffer vb, HardwareIndexBuffer ib, Texture t, LinkedGpuProgram lp) => Scene vb ib t lp
Scene :: IndexedTree (SceneNode vb ib t lp) -> Maybe Sky -> Scene vb ib t lp
scGraph :: Scene vb ib t lp -> IndexedTree (SceneNode vb ib t lp)
scSky :: Scene vb ib t lp -> Maybe Sky

-- | Add a new vector mesh to the world.
addVMesh :: RenderSystem r vb ib q t p lp => String -> VMesh -> LCM (World r vb ib q t p lp) e ()

-- | Retrieve a vector mesh from the world by name.
getVMesh :: RenderSystem r vb ib q t p lp => String -> LCM (World r vb ib q t p lp) e VMesh
addMesh :: RenderSystem r vb ib q t p lp => String -> Mesh vb ib -> World r vb ib q t p lp -> World r vb ib q1 t p lp
getMesh :: RenderSystem r vb ib q t p lp => String -> LCM (World r vb ib q t p lp) e (Mesh vb ib)
loadMaterialResources :: RenderSystem rs vb ib q t p lp => Material t lp -> LCM (World rs vb ib q t p lp) e (Material t lp)
getLoadedMaterial :: RenderSystem r vb ib q t p lp => String -> LCM (World r vb ib q t p lp) e (Maybe (Material t lp))
setEntityMaterial :: RenderSystem r vb ib q t p lp => [String] -> Entity vb ib t lp -> LCM (World r vb ib q t p lp) e (Entity vb ib t lp)
createEntity :: (RenderSystem r vb ib q t p lp, Enum rqp) => String -> String -> rqp -> LCM (World r vb ib q t p lp) e (Entity vb ib t lp)

-- | Get the raw data for a resource in a lazy bytestring given its path.
--   The data is cached, so this does not necessarily require disk I/O.
readFile :: RenderSystem r vb ib q t p lp => FilePath -> LCM (World r vb ib q t p lp) e ByteString

-- | Get the raw data for a resource in a strict bytestring given its path.
--   The data is cached, so this does not necessarily require disk I/O.
readFile' :: RenderSystem r vb ib q t p lp => FilePath -> LCM (World r vb ib q t p lp) e ByteString
loadFile :: [ResourceGroup] -> FilePath -> IO (Maybe ByteString)
renderFlatScene :: RenderSystem r vb ib q t p lp => FloatType -> String -> FlattenScene vb ib t lp -> LCM (World r vb ib q t p lp) e ()

-- | Create a new texture.
addRenderTexture :: RenderSystem r vb ib q a p lp => String -> Int -> Int -> LCM (World r vb ib q a p lp) e ()

-- | Specify the viewports to display in the window.
addRenderWindow :: RenderSystem r vb ib q t p lp => String -> Int -> Int -> [LCM (World r vb ib q t p lp) e (Viewport t lp)] -> LCM (World r vb ib q t p lp) e ()

-- | Create render textures, and setup compositor chain.
mkCompositorChain :: RenderSystem r vb ib q t p lp => [Compositor t lp] -> LCM (World r vb ib q t p lp) e [Compositor t lp]

-- | Create a viewport and attach given compositors.
viewport :: RenderSystem r vb ib q t p lp => FloatType -> FloatType -> FloatType -> FloatType -> String -> [String] -> LCM (World r vb ib q t p lp) e (Viewport t lp)

-- | Adjust the dimensions of a given render target.
updateTargetSize :: RenderSystem rs vb ib q t p lp => String -> Int -> Int -> LCM (World rs vb ib q t p lp) e ()
instance MonadIO (LCM w e)
instance Monad (LCM w e)
instance Applicative (LCM w e)
instance Functor (LCM w e)

module Graphics.LambdaCube.SceneGraph
type MkSceneObjectAction r vb ib q t p lp e = LCM (World r vb ib q t p lp) e (SceneObject vb ib t lp)
type MkNodeAction r vb ib q t p lp e = LCM (World r vb ib q t p lp) e ((String, String), SceneNode vb ib t lp)

-- | Construct a scene object representing a camera with the given
--   specification.
camera :: RenderSystem r vb ib q t p lp => Camera -> MkSceneObjectAction r vb ib q t p lp e

-- | Construct a scene object representing a basic camera with the given
--   name.
simpleCamera :: RenderSystem r vb ib q t p lp => String -> MkSceneObjectAction r vb ib q t p lp e

-- | Construct a scene object representing a wireframe-mode camera with the
--   given name.
wireCamera :: RenderSystem r vb ib q t p lp => String -> MkSceneObjectAction r vb ib q t p lp e

-- | Construct a scene object representing a light source with the given
--   specification.
light :: RenderSystem r vb ib q t p lp => Light -> MkSceneObjectAction r vb ib q t p lp e

-- | Construct a scene object representing a basic light source.
defaultLight :: RenderSystem r vb ib q t p lp => MkSceneObjectAction r vb ib q t p lp e

-- | Construct a scene object representing a polygon mesh.
mesh :: (RenderSystem rs vb ib q t p lp, Enum rqp) => Maybe rqp -> Maybe [String] -> String -> MkSceneObjectAction rs vb ib q t p lp e

-- | Construct a scene graph node description.
node :: RenderSystem r vb ib q t p lp => String -> String -> Proj4 -> [MkSceneObjectAction r vb ib q t p lp e] -> MkNodeAction r vb ib q t p lp e

-- | Add a list of new nodes to the global scene.
addScene :: RenderSystem r vb ib q t p lp => [MkNodeAction r vb ib q t p lp e] -> LCM (World r vb ib q t p lp) e ()

-- | Update the transformation matrices of the given nodes.
updateTransforms :: RenderSystem r vb ib q t p lp => [(String, Proj4)] -> LCM (World r vb ib q t p lp) e ()

-- | Update the objects associated with the given nodes.
updateObjects :: RenderSystem rs vb ib q t p lp => [(String, [MkSceneObjectAction rs vb ib q t p lp e])] -> LCM (World rs vb ib q t p lp) e ()
flattenScene :: (HardwareVertexBuffer vb, HardwareIndexBuffer ib, Texture t, LinkedGpuProgram lp) => Scene vb ib t lp -> FlattenScene vb ib t lp

-- | Render the given target.
renderWorld :: RenderSystem r vb ib q t p lp => FloatType -> String -> LCM (World r vb ib q t p lp) e ()

module Graphics.LambdaCube.Loader.CompositorScript
parseCompositor :: (LinkedGpuProgram lp, Texture t) => String -> String -> IO (Maybe [Compositor t lp])

module Graphics.LambdaCube.Loader.MaterialScript
parseMaterial :: (Texture t, LinkedGpuProgram lp, GpuProgram p) => String -> String -> IO (Maybe ([Material t lp], [GpuProgramDescriptor p], [GpuProgramDescriptor p]))

module Graphics.LambdaCube.Resource
data (Texture t, GpuProgram p, LinkedGpuProgram lp) => ResourceItem t p lp
RI_Material :: (String, Material t lp) -> ResourceItem t p lp
RI_GpuProgram :: (String, GpuProgramDescriptor p) -> ResourceItem t p lp
RI_Compositor :: (String, Compositor t lp) -> ResourceItem t p lp
addConfig :: RenderSystem r vb ib q t p lp => FilePath -> LCM (World r vb ib q t p lp) e ()

-- | Add a resource library (essentially a collection of paths) to the
--   current set of search paths stored in the world.
addResourceLibrary :: RenderSystem r vb ib q t p lp => [ResourceGroup] -> LCM (World r vb ib q t p lp) e ()

module Graphics.LambdaCube.RenderSystem.GL.Utils
peek4 :: Storable a => (a -> a -> a -> a -> b) -> Ptr a -> IO b
peek4M :: Storable a => (a -> a -> a -> a -> IO b) -> Ptr a -> IO b
getFloat :: GLenum -> IO GLfloat
getInteger :: GLenum -> IO GLint
getBoolean :: GLenum -> IO GLboolean
getBoolean4 :: GLenum -> IO (GLboolean, GLboolean, GLboolean, GLboolean)
getInteger4 :: GLenum -> IO (GLint, GLint, GLint, GLint)
getString :: GLenum -> IO String
getGLExtensions :: IO [String]
getGLVersion :: IO (Int, Int)
getGLUsage :: Usage -> GLenum
getGLType :: VertexElementType -> GLenum
getGLTextureTarget :: TextureType -> GLenum
optionalPO2 :: RenderSystemCapabilities -> Int -> Int
getMaxMipmaps :: Int -> Int -> Int -> PixelFormat -> GLint
getNativeFormat :: TextureType -> PixelFormat -> Bool -> PixelFormat
getClosestGLInternalFormat :: PixelFormat -> Bool -> GLint
getBlendMode :: SceneBlendFactor -> GLenum
getBlendEquation :: SceneBlendOperation -> GLenum
getTextureAddressingMode :: TextureAddressingMode -> GLenum
getLayerBlendSource :: LayerBlendSource -> GLenum
getTextureCombineFunction :: Bool -> LayerBlendOperationEx -> GLenum
convertCompareFunction :: CompareFunction -> GLenum

module Graphics.LambdaCube.RenderSystem.GL.IndexBuffer

-- | Specialisation of HardwareIndexBuffer for GL
data GLIndexBuffer
GLIndexBuffer :: IndexType -> Int -> Usage -> IORef (Maybe (Int, Int, Bool)) -> Maybe (Ptr Word8) -> GLuint -> GLIndexBuffer
glibType :: GLIndexBuffer -> IndexType
glibNumIndexes :: GLIndexBuffer -> Int
glibUsage :: GLIndexBuffer -> Usage
glibLockInfo :: GLIndexBuffer -> IORef (Maybe (Int, Int, Bool))
glibShadowBuffer :: GLIndexBuffer -> Maybe (Ptr Word8)
glibBufferObject :: GLIndexBuffer -> GLuint
glibIsLocked :: GLIndexBuffer -> IO Bool
glibLock :: GLIndexBuffer -> Int -> Int -> LockOptions -> IO (Ptr Word8)
glibUnlock :: GLIndexBuffer -> IO ()
mkGLIndexBuffer :: IndexType -> Int -> Usage -> Bool -> IO GLIndexBuffer
rmGLIndexBuffer :: GLIndexBuffer -> IO ()
instance Eq GLIndexBuffer
instance HardwareBuffer GLIndexBuffer
instance HardwareIndexBuffer GLIndexBuffer
instance Ord GLIndexBuffer

module Graphics.LambdaCube.RenderSystem.GL.VertexBuffer

-- | Specialisation of HardwareVertexBuffer for GL
data GLVertexBuffer
GLVertexBuffer :: Int -> Int -> Usage -> IORef (Maybe (Int, Int, Bool)) -> Maybe (Ptr Word8) -> GLuint -> GLVertexBuffer
glvbNumVertices :: GLVertexBuffer -> Int
glvbVertexSize :: GLVertexBuffer -> Int
glvbUsage :: GLVertexBuffer -> Usage
glvbLockInfo :: GLVertexBuffer -> IORef (Maybe (Int, Int, Bool))
glvbShadowBuffer :: GLVertexBuffer -> Maybe (Ptr Word8)
glvbBufferObject :: GLVertexBuffer -> GLuint
glvbIsLocked :: GLVertexBuffer -> IO Bool
glvbLock :: GLVertexBuffer -> Int -> Int -> LockOptions -> IO (Ptr Word8)
glvbUnlock :: GLVertexBuffer -> IO ()
mkGLVertexBuffer :: Int -> Int -> Usage -> Bool -> IO GLVertexBuffer
rmGLVertexBuffer :: GLVertexBuffer -> IO ()
instance Eq GLVertexBuffer
instance HardwareBuffer GLVertexBuffer
instance HardwareVertexBuffer GLVertexBuffer
instance Ord GLVertexBuffer

module Graphics.LambdaCube.RenderSystem.GL.Capabilities
mkGLCapabilities :: IO RenderSystemCapabilities

module Graphics.LambdaCube.RenderSystem.GL.Texture
data GLTexture
GLTexture :: String -> Int -> Int -> Int -> TextureMipmap -> Int -> Bool -> FloatType -> Bool -> Int -> String -> TextureType -> PixelFormat -> TextureUsage -> PixelFormat -> Int -> Int -> Int -> PixelFormat -> Int -> Int -> Bool -> GLuint -> GLTexture
gltxName :: GLTexture -> String
gltxWidth :: GLTexture -> Int
gltxHeight :: GLTexture -> Int
gltxDepth :: GLTexture -> Int
gltxNumRequestedMipmaps :: GLTexture -> TextureMipmap
gltxNumMipmaps :: GLTexture -> Int
gltxMipmapsHardwareGenerated :: GLTexture -> Bool
gltxGamma :: GLTexture -> FloatType
gltxHwGamma :: GLTexture -> Bool
gltxFSAA :: GLTexture -> Int
gltxFSAAHint :: GLTexture -> String
gltxTextureType :: GLTexture -> TextureType
gltxFormat :: GLTexture -> PixelFormat
gltxUsage :: GLTexture -> TextureUsage
gltxSrcFormat :: GLTexture -> PixelFormat
gltxSrcWidth :: GLTexture -> Int
gltxSrcHeight :: GLTexture -> Int
gltxSrcDepth :: GLTexture -> Int
gltxDesiredFormat :: GLTexture -> PixelFormat
gltxDesiredIntegerBitDepth :: GLTexture -> Int
gltxDesiredFloatBitDepth :: GLTexture -> Int
gltxTreatLuminanceAsAlpha :: GLTexture -> Bool
gltxTextureObject :: GLTexture -> GLuint
mkGLTexture :: RenderSystemCapabilities -> String -> TextureType -> Int -> Int -> Int -> TextureMipmap -> PixelFormat -> TextureUsage -> Bool -> Int -> String -> Maybe [Image] -> IO GLTexture
instance Texture GLTexture
instance HardwareBuffer GLTexture
instance Ord GLTexture
instance Eq GLTexture

module Graphics.LambdaCube.RenderSystem.GL.RenderSystem
data GLState
GLState :: (Proj4, [(Proj4, Light)]) -> (FloatType4, FloatType4, FloatType4, FloatType4, FloatType, TrackVertexColourType) -> GLState
stLight :: GLState -> (Proj4, [(Proj4, Light)])
stSurface :: GLState -> (FloatType4, FloatType4, FloatType4, FloatType4, FloatType, TrackVertexColourType)
mkGLState :: IO (IORef GLState)
data GLRenderSystem
GLRenderSystem :: IORef Proj4 -> IORef Proj4 -> RenderSystemCapabilities -> IORef GLState -> GLRenderSystem
glrsWorldMatrix :: GLRenderSystem -> IORef Proj4
glrsViewMatrix :: GLRenderSystem -> IORef Proj4
glrsCapabilities :: GLRenderSystem -> RenderSystemCapabilities
glrsState :: GLRenderSystem -> IORef GLState
mkGLRenderSystem :: IO GLRenderSystem
glWithFrameBuffer :: Int -> Int -> Int -> Int -> (Ptr Word8 -> IO ()) -> IO ()
glDirtyHackCopyTexImage :: GLTexture -> Int -> Int -> Int -> Int -> IO ()
glPrepareRender :: IO ()
glFinishRender :: IO ()
glSetDepthBias :: FloatType -> FloatType -> IO ()
glSetViewport :: Int -> Int -> Int -> Int -> IO ()
glSetPolygonMode :: PolygonMode -> IO ()
glSetupMatrix :: Proj4 -> Proj4 -> IO ()
glSetWorldMatrix :: GLRenderSystem -> Proj4 -> IO ()
glSetViewMatrix :: GLRenderSystem -> Proj4 -> IO ()
glSetProjectionMatrix :: Mat4 -> IO ()
glClearFrameBuffer :: FrameBufferType -> FloatType4 -> FloatType -> Word16 -> IO ()
glBindGeometry :: Texture t => RenderOperation GLVertexBuffer GLIndexBuffer -> [TextureUnitState t] -> IO ()
glUnBindGeometry :: RenderSystemCapabilities -> RenderOperation GLVertexBuffer GLIndexBuffer -> IO ()
glRender :: RenderOperation GLVertexBuffer GLIndexBuffer -> IO ()
bindElement :: (Texture t, HardwareIndexBuffer ib) => RenderOperation GLVertexBuffer ib -> [TextureUnitState t] -> VertexElement -> IO ()
glSetShadingType :: ShadeOptions -> IO ()
glSetAlphaRejectSettings :: RenderSystemCapabilities -> CompareFunction -> Int -> Bool -> IO ()
glSetDepthBufferCheckEnabled :: Bool -> IO ()
glSetDepthBufferWriteEnabled :: Bool -> IO ()
glSetDepthBufferFunction :: CompareFunction -> IO ()
glSetPointSpritesEnabled :: RenderSystemCapabilities -> Bool -> IO ()
glSetSceneBlending :: SceneBlendFactor -> SceneBlendFactor -> SceneBlendOperation -> IO ()
glSetSurfaceParams :: GLRenderSystem -> FloatType4 -> FloatType4 -> FloatType4 -> FloatType4 -> FloatType -> TrackVertexColourType -> IO ()
glSetLightingEnabled :: Bool -> IO ()
glSetFog :: FogMode -> FloatType4 -> FloatType -> FloatType -> FloatType -> IO ()
glSetSeparateSceneBlending :: SceneBlendFactor -> SceneBlendFactor -> SceneBlendFactor -> SceneBlendFactor -> SceneBlendOperation -> SceneBlendOperation -> IO ()
glSetPointParameters :: RenderSystem rs vb ib q t p lp => rs -> FloatType -> Bool -> FloatType -> FloatType -> FloatType -> FloatType -> FloatType -> IO ()
glSetActiveTextureUnit :: Int -> IO ()
glSetTexture :: Maybe GLTexture -> IO ()
glUseLights :: GLRenderSystem -> [(Proj4, Light)] -> IO ()
glSetTextureAddressingMode :: TextureType -> UVWAddressingMode -> IO ()
glSetTextureBorderColour :: TextureType -> FloatType4 -> IO ()
glSetTextureUnitFiltering :: TextureType -> FilterOptions -> FilterOptions -> FilterOptions -> IO ()
glSetTextureLayerAnisotropy :: TextureType -> Int -> IO ()
glSetTextureMipmapBias :: FloatType -> IO ()
glSetTextureBlendMode :: RenderSystemCapabilities -> LayerBlendModeEx -> LayerBlendModeEx -> IO ()
glSetCullingMode :: CullingMode -> IO ()
glSetColourBufferWriteEnabled :: Bool -> Bool -> Bool -> Bool -> IO ()
glBindLinkedGpuProgram :: GLLinkedGpuProgram -> IO ()
glUnBindLinkedGpuProgram :: IO ()
glSetTextureMatrix :: Proj4 -> IO ()
glSetTextureCoordCalculation :: TexCoordCalcMethod -> IO ()
instance RenderSystem GLRenderSystem GLVertexBuffer GLIndexBuffer GLOcclusionQuery GLTexture GLGpuProgram GLLinkedGpuProgram
instance Eq Proj4

module Graphics.LambdaCube.RenderSystem.GL
mkGLRenderSystem :: IO GLRenderSystem
type GLEntity = Entity GLVertexBuffer GLIndexBuffer GLTexture GLLinkedGpuProgram
type GLRenderEntity = RenderEntity GLVertexBuffer GLIndexBuffer GLTexture GLLinkedGpuProgram

-- | Specialisation of HardwareVertexBuffer for GL
data GLVertexBuffer

-- | Specialisation of HardwareIndexBuffer for GL
data GLIndexBuffer


-- | This is the public interface of LambdaCube. All the other modules are
--   exposed for the benefit of library writers, but if you feel the need
--   to use any of them as a simple user, that should be considered a
--   defect and reported in the issue tracker.
module Graphics.LambdaCube
class (HardwareVertexBuffer vb, HardwareIndexBuffer ib, HardwareOcclusionQuery q, Texture t, GpuProgram p, LinkedGpuProgram lp) => RenderSystem rs vb ib q t p lp | rs -> vb ib q t p lp
data RenderSystem r vb ib q t p lp => World r vb ib q t p lp
data LCM w e a

-- | Embed a LambdaCube program in IO. The embedding manages a world,
--   therefore it requires all the information to create one: the render
--   system and a list of image loaders.
runLCM :: RenderSystem r vb ib q t1 p lp => r -> [ImageLoader] -> LCM (World r vb ib q t1 p lp) e a -> IO ()

-- | The type of path leading to a resource.
data PathType

-- | An ordinary directory.
PathDir :: PathType

-- | A zip compressed directory.
PathZip :: PathType

-- | Add a resource library (essentially a collection of paths) to the
--   current set of search paths stored in the world.
addResourceLibrary :: RenderSystem r vb ib q t p lp => [ResourceGroup] -> LCM (World r vb ib q t p lp) e ()

-- | Get the raw data for a resource in a lazy bytestring given its path.
--   The data is cached, so this does not necessarily require disk I/O.
readFile :: RenderSystem r vb ib q t p lp => FilePath -> LCM (World r vb ib q t p lp) e ByteString

-- | Get the raw data for a resource in a strict bytestring given its path.
--   The data is cached, so this does not necessarily require disk I/O.
readFile' :: RenderSystem r vb ib q t p lp => FilePath -> LCM (World r vb ib q t p lp) e ByteString

-- | Add a list of new nodes to the global scene.
addScene :: RenderSystem r vb ib q t p lp => [MkNodeAction r vb ib q t p lp e] -> LCM (World r vb ib q t p lp) e ()

-- | Update the transformation matrices of the given nodes.
updateTransforms :: RenderSystem r vb ib q t p lp => [(String, Proj4)] -> LCM (World r vb ib q t p lp) e ()

-- | Update the objects associated with the given nodes.
updateObjects :: RenderSystem rs vb ib q t p lp => [(String, [MkSceneObjectAction rs vb ib q t p lp e])] -> LCM (World rs vb ib q t p lp) e ()

-- | Light source description.
data Light
Light :: LightTypes -> ColourValue -> ColourValue -> Vec3 -> FloatType -> FloatType -> FloatType -> FloatType -> FloatType -> FloatType -> Light
lgType :: Light -> LightTypes
lgDiffuse :: Light -> ColourValue
lgSpecular :: Light -> ColourValue
lgDirection :: Light -> Vec3
lgSpotOuter :: Light -> FloatType
lgSpotFalloff :: Light -> FloatType
lgRange :: Light -> FloatType
lgAttenuationConst :: Light -> FloatType
lgAttenuationLinear :: Light -> FloatType
lgAttenuationQuad :: Light -> FloatType

-- | Possible types of light sources.
data LightTypes

-- | Point light sources give off light equally in all directions, so they
--   require only position but no direction.
LT_POINT :: LightTypes

-- | Directional lights simulate parallel light beams from a distant
--   source, hence have direction but no position.
LT_DIRECTIONAL :: LightTypes

-- | Spotlights simulate a cone of light from a source so require position
--   and direction, plus extra values for falloff.
LT_SPOTLIGHT :: LightTypes

-- | Camera description.
data Camera
Camera :: String -> FloatType -> FloatType -> FloatType -> Maybe FloatType -> PolygonMode -> Camera

-- | The name of the camera.
cmName :: Camera -> String

-- | Field of view in radians.
cmFov :: Camera -> FloatType

-- | Near plane clipping distance.
cmNear :: Camera -> FloatType

-- | Far plane clipping distance.
cmFar :: Camera -> FloatType

-- | Camera aspect ratio (width/height).
cmAspectRatio :: Camera -> Maybe FloatType

-- | Rendering type.
cmPolygonMode :: Camera -> PolygonMode

-- | Standard render queue priorities. Note that any enumeration type can
--   be used to specify render priorities (i.e. top-level drawing order),
--   this is just a simple convenience type.
data RenderQueuePriority
RQP_Background :: RenderQueuePriority
RQP_EarlySky :: RenderQueuePriority
RQP_EarlyWorld :: RenderQueuePriority
RQP_Main :: RenderQueuePriority
RQP_LateWorld :: RenderQueuePriority
RQP_LateSky :: RenderQueuePriority
RQP_Overlay :: RenderQueuePriority

-- | The default render queue priority.
defaultRQP :: Maybe RenderQueuePriority

-- | Construct a scene graph node description.
node :: RenderSystem r vb ib q t p lp => String -> String -> Proj4 -> [MkSceneObjectAction r vb ib q t p lp e] -> MkNodeAction r vb ib q t p lp e

-- | Construct a scene object representing a camera with the given
--   specification.
camera :: RenderSystem r vb ib q t p lp => Camera -> MkSceneObjectAction r vb ib q t p lp e

-- | Construct a scene object representing a basic camera with the given
--   name.
simpleCamera :: RenderSystem r vb ib q t p lp => String -> MkSceneObjectAction r vb ib q t p lp e

-- | Construct a scene object representing a wireframe-mode camera with the
--   given name.
wireCamera :: RenderSystem r vb ib q t p lp => String -> MkSceneObjectAction r vb ib q t p lp e

-- | Construct a scene object representing a light source with the given
--   specification.
light :: RenderSystem r vb ib q t p lp => Light -> MkSceneObjectAction r vb ib q t p lp e

-- | Construct a scene object representing a basic light source.
defaultLight :: RenderSystem r vb ib q t p lp => MkSceneObjectAction r vb ib q t p lp e

-- | Construct a scene object representing a polygon mesh.
mesh :: (RenderSystem rs vb ib q t p lp, Enum rqp) => Maybe rqp -> Maybe [String] -> String -> MkSceneObjectAction rs vb ib q t p lp e

-- | Create a new texture.
addRenderTexture :: RenderSystem r vb ib q a p lp => String -> Int -> Int -> LCM (World r vb ib q a p lp) e ()

-- | Specify the viewports to display in the window.
addRenderWindow :: RenderSystem r vb ib q t p lp => String -> Int -> Int -> [LCM (World r vb ib q t p lp) e (Viewport t lp)] -> LCM (World r vb ib q t p lp) e ()

-- | Create a viewport and attach given compositors.
viewport :: RenderSystem r vb ib q t p lp => FloatType -> FloatType -> FloatType -> FloatType -> String -> [String] -> LCM (World r vb ib q t p lp) e (Viewport t lp)

-- | Render the given target.
renderWorld :: RenderSystem r vb ib q t p lp => FloatType -> String -> LCM (World r vb ib q t p lp) e ()

-- | Adjust the dimensions of a given render target.
updateTargetSize :: RenderSystem rs vb ib q t p lp => String -> Int -> Int -> LCM (World rs vb ib q t p lp) e ()

-- | The types of <a>VectorVertexData</a> without the data.
data VectorVertexType
VVT_POSITION :: VectorVertexType
VVT_BLEND_WEIGHTS :: VectorVertexType
VVT_BLEND_INDICES :: VectorVertexType
VVT_NORMAL :: VectorVertexType
VVT_DIFFUSE :: VectorVertexType
VVT_SPECULAR :: VectorVertexType
VVT_TEXTURE_COORDINATES1 :: VectorVertexType
VVT_TEXTURE_COORDINATES2 :: VectorVertexType
VVT_TEXTURE_COORDINATES3 :: VectorVertexType
VVT_BINORMAL :: VectorVertexType
VVT_TANGENT :: VectorVertexType

-- | Primitive buffer data
data VectorVertexData
VVD_POSITION :: (Vector Vec3) -> VectorVertexData
VVD_BLEND_WEIGHTS :: (Vector FloatType) -> VectorVertexData
VVD_BLEND_INDICES :: (Vector Int) -> VectorVertexData
VVD_NORMAL :: (Vector Vec3) -> VectorVertexData
VVD_DIFFUSE :: (Vector Vec4) -> VectorVertexData
VVD_SPECULAR :: (Vector Vec3) -> VectorVertexData
VVD_TEXTURE_COORDINATES1 :: (Vector FloatType) -> VectorVertexData
VVD_TEXTURE_COORDINATES2 :: (Vector Vec2) -> VectorVertexData
VVD_TEXTURE_COORDINATES3 :: (Vector Vec3) -> VectorVertexData
VVD_BINORMAL :: (Vector Vec3) -> VectorVertexData
VVD_TANGENT :: (Vector Vec3) -> VectorVertexData

-- | Multimaterial geometry, including a default geometry for submeshes
--   that don't provide their own.
data VMesh
VMesh :: [VSubMesh] -> Maybe VVB -> VMesh

-- | The collection of single-material submeshes making up the mesh.
vmSubMeshList :: VMesh -> [VSubMesh]

-- | Default geometry for submeshes.
vmSharedVertexData :: VMesh -> Maybe VVB

-- | Geometry with associated material.
data VSubMesh
VSubMesh :: String -> OperationType -> Maybe VVB -> Maybe VIB -> VSubMesh

-- | The material associated with the submesh.
vsmMaterialName :: VSubMesh -> String

-- | The type of primitives making up the geometry.
vsmOperationType :: VSubMesh -> OperationType

-- | Optional vertex buffer (supplied by the containing mesh if absent).
vsmVertexData :: VSubMesh -> Maybe VVB

-- | Optional index buffer.
vsmIndexData :: VSubMesh -> Maybe VIB

-- | The interpretation of a sequence of vertices.
data OperationType

-- | A list of points, 1 vertex per point.
OT_POINT_LIST :: OperationType

-- | A list of lines, 2 vertices per line.
OT_LINE_LIST :: OperationType

-- | A strip of connected lines, 1 vertex per line plus 1 start vertex.
OT_LINE_STRIP :: OperationType

-- | A list of triangles, 3 vertices per triangle.
OT_TRIANGLE_LIST :: OperationType

-- | A strip of triangles, 3 vertices for the first triangle, and 1 per
--   triangle after that.
OT_TRIANGLE_STRIP :: OperationType

-- | A fan of triangles, 3 vertices for the first triangle, and 1 per
--   triangle after that.
OT_TRIANGLE_FAN :: OperationType

-- | Extract the type of the vertex data.
vectorVertexType :: VectorVertexData -> VectorVertexType

-- | Add a new vector mesh to the world.
addVMesh :: RenderSystem r vb ib q t p lp => String -> VMesh -> LCM (World r vb ib q t p lp) e ()

-- | Retrieve a vector mesh from the world by name.
getVMesh :: RenderSystem r vb ib q t p lp => String -> LCM (World r vb ib q t p lp) e VMesh
