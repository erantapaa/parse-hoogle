-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A fork of the popular websockets package. It is used for the practical assignments of the University of Twente. A sensible and clean way to write WebSocket-capable servers in Haskell.
--   
@package twentefp-websockets
@version 0.1.0.1

module Network.WebSockets

-- | Create a standardized socket. Should only be used for a quick and
--   dirty solution! Should be preceded by the call
--   Network.Socket.withSocketsDo
makeSocket :: String -> Int -> IO Socket

-- | Closes a socket. This function serves as a quick utility to close a
--   socket and as a reminder that you need to close sockets made by
--   makeSocket.
closeSocket :: Socket -> IO ()

-- | A new client connected to the server. We haven't accepted the
--   connection yet, though.
data PendingConnection

-- | Use data from the socket to create a Pending Connection. This is a
--   blocking function. It tries to first accept a connection before
--   creating a pending connection. Then you are able to choose if you want
--   to accept the connection or not.
makePendingConnection :: Socket -> IO PendingConnection

-- | Useful for e.g. inspecting the request path.
pendingRequest :: PendingConnection -> RequestHead
data AcceptRequest
AcceptRequest :: Maybe ByteString -> AcceptRequest

-- | The subprotocol to speak with the client. If
--   <tt>pendingSubprotcols</tt> is non-empty, <a>acceptSubprotocol</a>
--   must be one of the subprotocols from the list.
acceptSubprotocol :: AcceptRequest -> Maybe ByteString
acceptRequest :: PendingConnection -> IO Connection
acceptRequestWith :: PendingConnection -> AcceptRequest -> IO Connection
rejectRequest :: PendingConnection -> ByteString -> IO ()
data Connection
data ConnectionOptions
ConnectionOptions :: IO () -> ConnectionOptions
connectionOnPong :: ConnectionOptions -> IO ()
defaultConnectionOptions :: ConnectionOptions
receive :: Connection -> IO Message

-- | Receive an application message. Automatically respond to control
--   messages.
--   
--   When the peer sends a close control message, an exception of type
--   <a>CloseRequest</a> is thrown. The peer can send a close control
--   message either to initiate a close or in response to a close message
--   we have sent to the peer. In either case the <a>CloseRequest</a>
--   exception will be thrown. The RFC specifies that the server is
--   responsible for closing the TCP connection, which should happen after
--   receiving the <a>CloseRequest</a> exception from this function.
--   
--   This will throw <a>ConnectionClosed</a> if the TCP connection dies
--   unexpectedly.
receiveDataMessage :: Connection -> IO DataMessage

-- | Receive a message, converting it to whatever format is needed.
receiveData :: WebSocketsData a => Connection -> IO a
send :: Connection -> Message -> IO ()

-- | Send a <a>DataMessage</a>
sendDataMessage :: Connection -> DataMessage -> IO ()

-- | Send a message as text
sendTextData :: WebSocketsData a => Connection -> a -> IO ()

-- | Send a message as binary data
sendBinaryData :: WebSocketsData a => Connection -> a -> IO ()

-- | Send a friendly close message. Note that after sending this message,
--   you should still continue calling <a>receiveDataMessage</a> to process
--   any in-flight messages. The peer will eventually respond with a close
--   control message of its own which will cause <a>receiveDataMessage</a>
--   to throw the <a>CloseRequest</a> exception. This exception is when you
--   can finally consider the connection closed.
sendClose :: WebSocketsData a => Connection -> a -> IO ()

-- | Send a ping
sendPing :: WebSocketsData a => Connection -> a -> IO ()

-- | Request headers
type Headers = [(CI ByteString, ByteString)]

-- | A request with a body
data Request
Request :: RequestHead -> ByteString -> Request

-- | An HTTP request. The request body is not yet read.
data RequestHead
RequestHead :: !ByteString -> Headers -> Bool -> RequestHead
requestPath :: RequestHead -> !ByteString
requestHeaders :: RequestHead -> Headers
requestSecure :: RequestHead -> Bool

-- | List of subprotocols specified by the client, in order of preference.
--   If the client did not specify a list of subprotocols, this will be the
--   empty list.
getRequestSubprotocols :: RequestHead -> [ByteString]

-- | A response including a body
data Response
Response :: ResponseHead -> ByteString -> Response

-- | HTTP response, without body.
data ResponseHead
ResponseHead :: !Int -> !ByteString -> Headers -> ResponseHead
responseCode :: ResponseHead -> !Int
responseMessage :: ResponseHead -> !ByteString
responseHeaders :: ResponseHead -> Headers

-- | The kind of message a server application typically deals with
data Message
ControlMessage :: ControlMessage -> Message
DataMessage :: DataMessage -> Message

-- | Different control messages
data ControlMessage
Close :: Word16 -> ByteString -> ControlMessage
Ping :: ByteString -> ControlMessage
Pong :: ByteString -> ControlMessage

-- | For an end-user of this library, dealing with <tt>Frame</tt>s would be
--   a bit low-level. This is why define another type on top of it, which
--   represents data for the application layer.
data DataMessage
Text :: ByteString -> DataMessage
Binary :: ByteString -> DataMessage

-- | In order to have an even more high-level API, we define a typeclass
--   for values the user can receive from and send to the socket. A few
--   warnings apply:
--   
--   <ul>
--   <li>Natively, everything is represented as a <a>ByteString</a>, so
--   this is the fastest instance</li>
--   <li>You should only use the <a>Text</a> or the <a>Text</a> instance
--   when you are sure that the data is UTF-8 encoded (which is the case
--   for <a>Text</a> messages).</li>
--   <li>Messages can be very large. If this is the case, it might be
--   inefficient to use the strict <a>ByteString</a> and <a>Text</a>
--   instances.</li>
--   </ul>
class WebSocketsData a
fromLazyByteString :: WebSocketsData a => ByteString -> a
toLazyByteString :: WebSocketsData a => a -> ByteString

-- | Error in case of failed handshake. Will be thrown as an
--   <a>Exception</a>.
--   
--   TODO: This should probably be in the Handshake module, and is solely
--   here to prevent a cyclic dependency.
data HandshakeException

-- | We don't have a match for the protocol requested by the client. todo:
--   version parameter
NotSupported :: HandshakeException

-- | The request was somehow invalid (missing headers or wrong security
--   token)
MalformedRequest :: RequestHead -> String -> HandshakeException

-- | The servers response was somehow invalid (missing headers or wrong
--   security token)
MalformedResponse :: ResponseHead -> String -> HandshakeException

-- | The request was well-formed, but the library user rejected it. (e.g.
--   "unknown path")
RequestRejected :: Request -> String -> HandshakeException

-- | for example "EOF came too early" (which is actually a parse error) or
--   for your own errors. (like "unknown path"?)
OtherHandshakeException :: String -> HandshakeException

-- | Various exceptions that can occur while receiving or transmitting
--   messages
data ConnectionException

-- | The peer has requested that the connection be closed, and included a
--   close code and a reason for closing. When receiving this exception, no
--   more messages can be sent. Also, the server is responsible for closing
--   the TCP connection once this exception is received.
--   
--   See <a>http://tools.ietf.org/html/rfc6455#section-7.4</a> for a list
--   of close codes.
CloseRequest :: Word16 -> ByteString -> ConnectionException

-- | The peer unexpectedly closed the connection while we were trying to
--   receive some data. This is a violation of the websocket RFC since the
--   TCP connection should only be closed after sending and receiving close
--   control messages.
ConnectionClosed :: ConnectionException

-- | WebSockets application that can be ran by a server. Once this
--   <a>IO</a> action finishes, the underlying socket is closed
--   automatically.
type ServerApp = PendingConnection -> IO ()

-- | Provides a simple server. This function blocks forever. Note that this
--   is merely provided for quick-and-dirty standalone applications, for
--   real applications, you should use a real server.
runServer :: String -> Int -> ServerApp -> IO ()

-- | A version of <a>runServer</a> which allows you to customize some
--   options.
runServerWith :: String -> Int -> ConnectionOptions -> ServerApp -> IO ()
type ServerProgram = Connection -> StdOutMutex -> ConnectionSendMutex -> IO ()
server :: String -> Int -> ServerProgram -> IO ()
type StdOutMutex = Mutex [[Char]]
safeSendText :: ConnectionSendMutex -> Connection -> Text -> IO ()
safeSend :: ConnectionSendMutex -> Connection -> DataMessage -> IO ()
type ConnectionSendMutex = Mutex ()

-- | A client application interacting with a single server. Once this
--   <a>IO</a> action finished, the underlying socket is closed
--   automatically.
type ClientApp a = Connection -> IO a
runClient :: String -> Int -> String -> ClientApp a -> IO a
runClientWith :: String -> Int -> String -> ConnectionOptions -> Headers -> ClientApp a -> IO a
runClientWithSocket :: Socket -> String -> String -> ConnectionOptions -> Headers -> ClientApp a -> IO a
runClientWithStream :: (InputStream ByteString, OutputStream ByteString) -> String -> String -> ConnectionOptions -> Headers -> ClientApp a -> IO a
