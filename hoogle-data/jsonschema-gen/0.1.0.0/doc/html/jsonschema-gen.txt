-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | JSON Schema generator from Algebraic data type
--   
@package jsonschema-gen
@version 0.1.0.0

module Data.JSON.Schema.Generator.Types

-- | A schema for a JSON value.
data Schema
SCSchema :: !Text -> !Text -> !Schema -> ![(Text, Schema)] -> Schema
scId :: Schema -> !Text
scUsedSchema :: Schema -> !Text
scSchemaType :: Schema -> !Schema
scDefinitions :: Schema -> ![(Text, Schema)]
SCString :: !(Maybe Text) -> !Bool -> !(Maybe Text) -> !(Maybe Integer) -> !(Maybe Integer) -> Schema
scDescription :: Schema -> !(Maybe Text)
scNullable :: Schema -> !Bool
scFormat :: Schema -> !(Maybe Text)
scLowerBound :: Schema -> !(Maybe Integer)
scUpperBound :: Schema -> !(Maybe Integer)
SCInteger :: !(Maybe Text) -> !Bool -> !(Maybe Integer) -> !(Maybe Integer) -> Schema
scDescription :: Schema -> !(Maybe Text)
scNullable :: Schema -> !Bool
scLowerBound :: Schema -> !(Maybe Integer)
scUpperBound :: Schema -> !(Maybe Integer)
SCNumber :: !(Maybe Text) -> !Bool -> !(Maybe Integer) -> !(Maybe Integer) -> Schema
scDescription :: Schema -> !(Maybe Text)
scNullable :: Schema -> !Bool
scLowerBound :: Schema -> !(Maybe Integer)
scUpperBound :: Schema -> !(Maybe Integer)
SCBoolean :: !(Maybe Text) -> !Bool -> Schema
scDescription :: Schema -> !(Maybe Text)
scNullable :: Schema -> !Bool
SCConst :: !Text -> !(Maybe Text) -> !Text -> Schema
scTitle :: Schema -> !Text
scDescription :: Schema -> !(Maybe Text)
scValue :: Schema -> !Text
SCObject :: !Text -> !(Maybe Text) -> !Bool -> ![(Text, Schema)] -> ![(Text, Schema)] -> ![Text] -> Schema
scTitle :: Schema -> !Text
scDescription :: Schema -> !(Maybe Text)
scNullable :: Schema -> !Bool
scProperties :: Schema -> ![(Text, Schema)]
scPatternProps :: Schema -> ![(Text, Schema)]
scRequired :: Schema -> ![Text]
SCArray :: !Text -> !(Maybe Text) -> !Bool -> ![Schema] -> !(Maybe Integer) -> !(Maybe Integer) -> Schema
scTitle :: Schema -> !Text
scDescription :: Schema -> !(Maybe Text)
scNullable :: Schema -> !Bool
scItems :: Schema -> ![Schema]
scLowerBound :: Schema -> !(Maybe Integer)
scUpperBound :: Schema -> !(Maybe Integer)
SCOneOf :: !Text -> !(Maybe Text) -> !Bool -> ![SchemaChoice] -> Schema
scTitle :: Schema -> !Text
scDescription :: Schema -> !(Maybe Text)
scNullable :: Schema -> !Bool
scChoices :: Schema -> ![SchemaChoice]
SCRef :: !Text -> !Bool -> Schema
scReference :: Schema -> !Text
scNullable :: Schema -> !Bool
SCNull :: Schema

-- | A sum encoding for ADT.
--   
--   A smart consturctor for String.
data SchemaChoice

-- | Encoding for constructors that are all unit type. e.g. "test":
--   {"enum": ["xxx", "yyy", "zzz"]}
SCChoiceEnum :: !Text -> !Text -> SchemaChoice
sctName :: SchemaChoice -> !Text
sctTitle :: SchemaChoice -> !Text

-- | Encoding for constructors that are non record type. e.g. "test":
--   [{"tag": "xxx", "contents": []},...] or "test": [{"xxx": [],},...]
SCChoiceArray :: !Text -> !Text -> ![Schema] -> SchemaChoice
sctName :: SchemaChoice -> !Text
sctTitle :: SchemaChoice -> !Text
sctArray :: SchemaChoice -> ![Schema]

-- | Encoding for constructos that are record type. e.g. "test": [{"tag":
--   "xxx", "contents": {"aaa": "yyy",...}},...] or "test": [{"xxx":
--   []},...]
SCChoiceMap :: !Text -> !Text -> ![(Text, Schema)] -> ![Text] -> SchemaChoice
sctName :: SchemaChoice -> !Text
sctTitle :: SchemaChoice -> !Text
sctMap :: SchemaChoice -> ![(Text, Schema)]
sctRequired :: SchemaChoice -> ![Text]

-- | A smart consturctor for Integer.
scString :: Schema

-- | A smart consturctor for Number.
scInteger :: Schema

-- | A smart consturctor for Boolean.
scNumber :: Schema
scBoolean :: Schema
instance Show SchemaChoice
instance Show Schema

module Data.JSON.Schema.Generator.Convert
convert :: Options -> Schema -> Value

module Data.JSON.Schema.Generator.Class
class JSONSchemaGen a where toSchema = genericToSchema
toSchema :: JSONSchemaGen a => Options -> Proxy a -> Schema
class JSONSchemaPrim a
toSchemaPrim :: JSONSchemaPrim a => Options -> Proxy a -> Schema
class GJSONSchemaGen f
gToSchema :: GJSONSchemaGen f => Options -> Proxy (f a) -> Schema
genericToSchema :: (Generic a, GJSONSchemaGen (Rep a)) => Options -> Proxy a -> Schema

-- | Options that specify how to generate schema definition automatically
--   from your datatype.
data Options
Options :: String -> String -> Map TypeRep String -> Map String PropType -> Options

-- | shcema id prefix.
baseUri :: Options -> String

-- | schema id suffix. File extension for example.
schemaIdSuffix :: Options -> String

-- | a mapping from datatypes to referenced schema ids.
typeRefMap :: Options -> Map TypeRep String

-- | a mapping to assign a preffered type to a field.
fieldTypeMap :: Options -> Map String PropType
data PropType
PropType :: (Proxy a) -> PropType

-- | Default geerating <a>Options</a>:
--   
--   <pre>
--   <a>Options</a>
--   { <a>baseUri</a>        = ""
--   , <a>schemaIdSuffix</a> = ""
--   , <tt>refSchemaMap</tt>   = Map.empty
--   }
--   </pre>
defaultOptions :: Options
instance Show Options

module Data.JSON.Schema.Generator.Generic
instance [overlap ok] And True False False
instance [overlap ok] And False True False
instance [overlap ok] And False False False
instance [overlap ok] And True True True
instance [overlap ok] AllNullary U1 True
instance [overlap ok] AllNullary (K1 i c) False
instance [overlap ok] AllNullary (a :*: b) False
instance [overlap ok] AllNullary a allNullary => AllNullary (M1 i c a) allNullary
instance [overlap ok] (AllNullary a allNullaryL, AllNullary b allNullaryR, And allNullaryL allNullaryR allNullary) => AllNullary (a :+: b) allNullary
instance [overlap ok] IsRecord U1 False
instance [overlap ok] IsRecord (K1 i c) True
instance [overlap ok] IsRecord f isRecord => IsRecord (M1 S c f) isRecord
instance [overlap ok] IsRecord (M1 S NoSelector f) False
instance [overlap ok] IsRecord f isRecord => IsRecord (f :*: g) isRecord
instance [overlap ok] IsNullable (K1 i a)
instance [overlap ok] IsNullable (K1 i (Maybe a))
instance [overlap ok] (Typeable a, JSONSchemaGen a) => JSONSchemaPrim a
instance [overlap ok] JSONSchemaPrim a => JSONSchemaPrim (HashMap String a)
instance [overlap ok] JSONSchemaPrim a => JSONSchemaPrim (Map String a)
instance [overlap ok] JSONSchemaPrim a => JSONSchemaPrim [a]
instance [overlap ok] JSONSchemaPrim Bool
instance [overlap ok] JSONSchemaPrim Double
instance [overlap ok] JSONSchemaPrim Float
instance [overlap ok] JSONSchemaPrim Integer
instance [overlap ok] JSONSchemaPrim Int
instance [overlap ok] JSONSchemaPrim UTCTime
instance [overlap ok] JSONSchemaPrim Text
instance [overlap ok] JSONSchemaPrim String
instance [overlap ok] JSONSchemaPrim a => ToJSONSchemaDef (K1 i a)
instance [overlap ok] JSONSchemaPrim a => ToJSONSchemaDef (K1 i (Maybe a))
instance [overlap ok] (ProductToList a, ProductToList b) => ProductToList (a :*: b)
instance [overlap ok] (IsNullable a, ToJSONSchemaDef a) => ProductToList (S1 s a)
instance [overlap ok] (RecordToPairs a, RecordToPairs b) => RecordToPairs (a :*: b)
instance [overlap ok] (Selector s, IsNullable a, ToJSONSchemaDef a) => RecordToPairs (S1 s a)
instance [overlap ok] RecordToPairs U1
instance [overlap ok] RecordToPairs f => ConToArrayOrMap f False
instance [overlap ok] RecordToPairs f => ConToArrayOrMap f True
instance [overlap ok] (SumToArrayOrMap a, SumToArrayOrMap b) => SumToArrayOrMap (a :+: b)
instance [overlap ok] (Constructor c, IsRecord f isRecord, ConToArrayOrMap f isRecord) => SumToArrayOrMap (C1 c f)
instance [overlap ok] (SumToEnum a, SumToEnum b) => SumToEnum (a :+: b)
instance [overlap ok] Constructor c => SumToEnum (C1 c U1)
instance [overlap ok] SumToArrayOrMap f => SchemaTypeM f False
instance [overlap ok] SumToEnum f => SchemaTypeM f True
instance [overlap ok] ProductToList f => SchemaTypeS f False
instance [overlap ok] RecordToPairs f => SchemaTypeS f True
instance [overlap ok] (AllNullary f allNullary, SchemaTypeM f allNullary) => SchemaType f
instance [overlap ok] (IsRecord f isRecord, SchemaTypeS f isRecord, Constructor c) => SchemaType (C1 c f)
instance [overlap ok] Constructor c => SchemaType (C1 c U1)
instance [overlap ok] (Datatype d, SchemaType f) => GJSONSchemaGen (D1 d f)


-- | A generator for JSON Schemas from ADT.
module Data.JSON.Schema.Generator

-- | Options that specify how to generate schema definition automatically
--   from your datatype.
data Options
Options :: String -> String -> Map TypeRep String -> Map String PropType -> Options

-- | shcema id prefix.
baseUri :: Options -> String

-- | schema id suffix. File extension for example.
schemaIdSuffix :: Options -> String

-- | a mapping from datatypes to referenced schema ids.
typeRefMap :: Options -> Map TypeRep String

-- | a mapping to assign a preffered type to a field.
fieldTypeMap :: Options -> Map String PropType
data PropType
PropType :: (Proxy a) -> PropType

-- | Default geerating <a>Options</a>:
--   
--   <pre>
--   <a>Options</a>
--   { <a>baseUri</a>        = ""
--   , <a>schemaIdSuffix</a> = ""
--   , <tt>refSchemaMap</tt>   = Map.empty
--   }
--   </pre>
defaultOptions :: Options

-- | Generate a JSON Schema from a proxy value of a type. This uses the
--   default options to generate schema in json format.
generate :: JSONSchemaGen a => Proxy a -> ByteString

-- | Generate a JSON Schema from a proxy vaulue of a type. This uses the
--   specified options to generate schema in json format.
generate' :: JSONSchemaGen a => Options -> Options -> Proxy a -> ByteString
class JSONSchemaGen a where toSchema = genericToSchema
toSchema :: JSONSchemaGen a => Options -> Proxy a -> Schema
class JSONSchemaPrim a
toSchemaPrim :: JSONSchemaPrim a => Options -> Proxy a -> Schema
convert :: Options -> Schema -> Value
class GJSONSchemaGen f
gToSchema :: GJSONSchemaGen f => Options -> Proxy (f a) -> Schema
genericToSchema :: (Generic a, GJSONSchemaGen (Rep a)) => Options -> Proxy a -> Schema
