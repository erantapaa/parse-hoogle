-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The RogueStar Animation and Graphics Library: Mathematics
--   
--   RSAGL, the RogueStar Animation and Graphics Library, was specifically
--   designed for a computer game called roguestar, but effort has been
--   made to make it accessable to other projects that might benefit from
--   it. This package includes mathematical algorithms to support the
--   project.
@package rsagl-math
@version 0.6.0.1

module RSAGL.Math.Types
data RSfloat
data RSdouble
toGLfloat :: RSfloat -> GLfloat
toGLdouble :: RSdouble -> GLdouble
fromGLfloat :: GLfloat -> RSfloat
fromGLdouble :: GLdouble -> RSdouble
f2f :: (RealFloat a, RealFloat b) => a -> b
instance Enum RSfloat
instance Eq RSfloat
instance Floating RSfloat
instance Fractional RSfloat
instance Num RSfloat
instance Ord RSfloat
instance Read RSfloat
instance Real RSfloat
instance RealFloat RSfloat
instance RealFrac RSfloat
instance Show RSfloat
instance NearZero RSfloat
instance Enum RSdouble
instance Eq RSdouble
instance Floating RSdouble
instance Fractional RSdouble
instance Num RSdouble
instance Ord RSdouble
instance Read RSdouble
instance Real RSdouble
instance RealFloat RSdouble
instance RealFrac RSdouble
instance Show RSdouble
instance NearZero RSdouble
instance Random RSdouble
instance Random RSfloat

module RSAGL.Math.FMod
class FMod f
fmod :: FMod f => f -> f -> f
instance FMod RSdouble
instance FMod RSfloat
instance FMod Double
instance FMod Float

module RSAGL.Math.ListUtils

-- | Transforms a list to a list of adjacent elements.
--   
--   <pre>
--   doubles [1,2,3,4,5] = [(1,2),(2,3),(3,4),(4,5)]
--   </pre>
doubles :: [a] -> [(a, a)]

-- | loopedDoubles transforms a list to a list of adjacent elements,
--   looping back to the beginning of the list.
--   
--   <pre>
--   loopedRSdoubles [1,2,3,4,5] = [(1,2),(2,3),(3,4),(4,5),(5,1)]
--   </pre>
loopedDoubles :: [a] -> [(a, a)]

-- | Answers a list containing every sequence of n consecutive elements in
--   the parameter.
--   
--   <pre>
--   consecutives 3 [1,2,3,4] = [[1,2,3],[2,3,4]]
--   </pre>
consecutives :: Int -> [a] -> [[a]]

-- | Answers a list containing every sequence of n consecutive elements in
--   the parameter, looping back to the beginning of the list.
--   
--   <pre>
--   consecutives 3 [1,2,3,4] = [[1,2,3],[2,3,4],[3,4,1],[4,1,2]]
--   </pre>
loopedConsecutives :: Int -> [a] -> [[a]]

-- | Creates a list of numbers from 0.0 to 1.0, using n steps. This can't
--   be done with the enum-from-to method, due to roundoff errors.
zeroToOne :: Integer -> [RSdouble]


-- | Provides generic typeclasses for common operations among many types:
--   addition, subtraction, scalar multiplication, magnitude, and zero.
module RSAGL.Math.AbstractVector

-- | A convenience class for many vector types.
class (AbstractZero v, AbstractAdd v v, AbstractSubtract v v, AbstractScale v) => AbstractVector v

-- | A data type that has an additive identity.
class AbstractZero a
zero :: AbstractZero a => a

-- | A data type that supports addition.
--   
--   <ul>
--   <li><pre>a <a>add</a> zero = a</pre></li>
--   </ul>
class AbstractAdd p v | p -> v
add :: AbstractAdd p v => p -> v -> p

-- | A data type that supports subtraction.
--   
--   <ul>
--   <li><pre>a <a>sub</a> a = zero</pre></li>
--   </ul>
class AbstractSubtract p v | p -> v
sub :: AbstractSubtract p v => p -> p -> v

-- | A data type that supports scalar multiplication.
--   
--   <ul>
--   <li><pre>scalarMultiply 0 a = zero</pre></li>
--   </ul>
class AbstractScale v
scalarMultiply :: AbstractScale v => RSdouble -> v -> v

-- | A data type that supports scalar magnitude.
--   
--   <ul>
--   <li><pre>magnitude (scalarMultiply (recip $ magnitude a) a) =
--   1</pre></li>
--   </ul>
class AbstractMagnitude v
magnitude :: AbstractMagnitude v => v -> RSdouble

-- | Force a vector to the specified magnitude.
abstractScaleTo :: (AbstractScale v, AbstractMagnitude v) => RSdouble -> v -> v

-- | Sum of a list.
abstractSum :: (AbstractAdd p v, AbstractZero p) => [v] -> p

-- | Average of a list.
abstractAverage :: (AbstractAdd p v, AbstractSubtract p v, AbstractVector v, AbstractZero p) => [p] -> p

-- | Distance between two points, based on the <a>magnitude</a> of the
--   difference.
abstractDistance :: (AbstractMagnitude v, AbstractSubtract p v) => p -> p -> RSdouble
instance AbstractVector a => AbstractVector [a]
instance AbstractMagnitude a => AbstractMagnitude [a]
instance AbstractScale a => AbstractScale [a]
instance AbstractSubtract a b => AbstractSubtract [a] [b]
instance AbstractAdd a b => AbstractAdd [a] [b]
instance AbstractZero a => AbstractZero [a]
instance AbstractZero RSdouble
instance AbstractVector RSdouble
instance AbstractMagnitude RSdouble
instance AbstractScale RSdouble
instance AbstractSubtract RSdouble RSdouble
instance AbstractAdd RSdouble RSdouble
instance AbstractZero RSfloat
instance AbstractVector RSfloat
instance AbstractMagnitude RSfloat
instance AbstractScale RSfloat
instance AbstractSubtract RSfloat RSfloat
instance AbstractAdd RSfloat RSfloat
instance AbstractScale a => AbstractScale (x -> a)
instance AbstractSubtract a a' => AbstractSubtract (x -> a) (x -> a')
instance AbstractAdd a a' => AbstractAdd (x -> a) (x -> a')
instance (AbstractVector a, AbstractVector b) => AbstractVector (a, b)
instance (AbstractMagnitude a, AbstractMagnitude b) => AbstractMagnitude (a, b)
instance (AbstractScale a, AbstractScale b) => AbstractScale (a, b)
instance (AbstractSubtract a a', AbstractSubtract b b') => AbstractSubtract (a, b) (a', b')
instance (AbstractAdd a a', AbstractAdd b b') => AbstractAdd (a, b) (a', b')
instance (AbstractZero a, AbstractZero b) => AbstractZero (a, b)
instance HasResolution a => AbstractVector (Fixed a)
instance HasResolution a => AbstractMagnitude (Fixed a)
instance HasResolution a => AbstractScale (Fixed a)
instance HasResolution a => AbstractSubtract (Fixed a) (Fixed a)
instance HasResolution a => AbstractAdd (Fixed a) (Fixed a)
instance HasResolution a => AbstractZero (Fixed a)
instance AbstractZero Double
instance AbstractVector Double
instance AbstractMagnitude Double
instance AbstractScale Double
instance AbstractSubtract Double Double
instance AbstractAdd Double Double
instance AbstractVector Float
instance AbstractMagnitude Float
instance AbstractScale Float
instance AbstractSubtract Float Float
instance AbstractAdd Float Float
instance AbstractZero Float
instance AbstractMagnitude Integer
instance AbstractSubtract Integer Integer
instance AbstractAdd Integer Integer
instance AbstractZero Integer

module RSAGL.Math.Angle

-- | An angular value.
data Angle

-- | An angular value. <a>BoundAngle</a>s are always in the range between
--   -180 and 180 degrees, inclusive.
newtype BoundAngle
BoundAngle :: Angle -> BoundAngle

-- | There are 260 degrees in a circle.
fromDegrees :: RSdouble -> Angle

-- | There are 2*pi radians in a circle.
fromRadians :: RSdouble -> Angle

-- | There is 1 rotation in a circle.
fromRotations :: RSdouble -> Angle

-- | Get an angle based on time of day, hours, minutes, seconds, where noon
--   is considered a zero angle.
fromTimeOfDayHMS :: RSdouble -> RSdouble -> RSdouble -> Angle

-- | There are 21600 arc minutes in a circle, 60 arc minutes in a degree.
fromArcMinutes :: RSdouble -> Angle

-- | There are 1296000 arc seconds in a circle, 60 arc seconds in an arc
--   minutes.
fromArcSeconds :: RSdouble -> Angle
sine :: Angle -> RSdouble
arcSine :: RSdouble -> Angle
cosine :: Angle -> RSdouble
arcCosine :: RSdouble -> Angle
tangent :: Angle -> RSdouble
arcTangent :: RSdouble -> Angle
cartesianToPolar :: (RSdouble, RSdouble) -> (Angle, RSdouble)
polarToCartesian :: (Angle, RSdouble) -> (RSdouble, RSdouble)

-- | <a>toRadians</a> answers the angle in the range of -pi .. pi,
--   inclusive.
toRadians :: Angle -> RSdouble

-- | toRadians answers the angle in radians with no range limitation.
toRadians_ :: Angle -> RSdouble

-- | Answers the angle in the range of -180 to 180, inclusive.
toDegrees :: Angle -> RSdouble

-- | <a>toDegrees_</a> answers the angle in degrees with no range
--   limitation.
toDegrees_ :: Angle -> RSdouble

-- | <a>toRotations</a> answers the angle in the range of -0.5 to 0.5,
--   inclusive.
toRotations :: Angle -> RSdouble

-- | <a>toRotations</a> answers the angle in rotations with no range
--   limitation.
toRotations_ :: Angle -> RSdouble
scaleAngle :: RSdouble -> Angle -> Angle
supplementaryAngle :: Angle -> Angle
zero_angle :: Angle

-- | angularIncrements answers n evenly distributed angles from 0 to 2*pi.
angularIncrements :: Integer -> [Angle]
angleAdd :: Angle -> Angle -> Angle
angleSubtract :: Angle -> Angle -> Angle
angleNegate :: Angle -> Angle

-- | Absolute value of an angle.
absoluteAngle :: Angle -> Angle
unboundAngle :: BoundAngle -> Angle
instance Read Angle
instance Show Angle
instance Read BoundAngle
instance Show BoundAngle
instance AbstractMagnitude Angle
instance AbstractVector Angle
instance AbstractScale Angle
instance AbstractSubtract BoundAngle Angle
instance AbstractSubtract Angle Angle
instance AbstractAdd BoundAngle Angle
instance AbstractAdd Angle Angle
instance AbstractZero BoundAngle
instance AbstractZero Angle
instance Ord Angle
instance Eq Angle

module RSAGL.Math.Interpolation
lerp :: (AbstractScale v, AbstractSubtract p v, AbstractAdd p v, RealFloat r) => r -> (p, p) -> p
lerpClamped :: (AbstractScale v, AbstractSubtract p v, AbstractAdd p v, RealFloat r) => r -> (p, p) -> p
lerpBetween :: (AbstractScale v, AbstractSubtract p v, AbstractAdd p v, RealFloat r) => (r, r, r) -> (p, p) -> p
lerpBetweenMutated :: (AbstractScale v, AbstractSubtract p v, AbstractAdd p v, RealFloat r) => (r -> r) -> (r, r, r) -> (p, p) -> p
lerpBetweenClamped :: (AbstractScale v, AbstractSubtract p v, AbstractAdd p v, RealFloat r, Ord r) => (r, r, r) -> (p, p) -> p
lerpBetweenClampedMutated :: (AbstractScale v, AbstractSubtract p v, AbstractAdd p v, RealFloat r, Ord r) => (r -> r) -> (r, r, r) -> (p, p) -> p
lerp_mutator_continuous_1st :: RealFloat r => r -> r
lerpMap :: (RealFloat r, AbstractScale v, AbstractSubtract p v, AbstractAdd p v) => [(r, p)] -> r -> p

module RSAGL.Math.Vector
data Point3D
Point3D :: {-# UNPACK #-} !RSdouble -> {-# UNPACK #-} !RSdouble -> {-# UNPACK #-} !RSdouble -> Point3D
origin_point_3d :: Point3D
data Vector3D
Vector3D :: {-# UNPACK #-} !RSdouble -> {-# UNPACK #-} !RSdouble -> {-# UNPACK #-} !RSdouble -> Vector3D
data SurfaceVertex3D
SurfaceVertex3D :: Point3D -> Vector3D -> SurfaceVertex3D
sv3d_position :: SurfaceVertex3D -> Point3D
sv3d_normal :: SurfaceVertex3D -> Vector3D
zero_vector :: Vector3D
point3d :: (RSdouble, RSdouble, RSdouble) -> Point3D
points3d :: [(RSdouble, RSdouble, RSdouble)] -> [Point3D]
point2d :: (RSdouble, RSdouble) -> Point3D
points2d :: [(RSdouble, RSdouble)] -> [Point3D]
vector3d :: (RSdouble, RSdouble, RSdouble) -> Vector3D
dotProduct :: Vector3D -> Vector3D -> RSdouble
angleBetween :: Vector3D -> Vector3D -> Angle
crossProduct :: Vector3D -> Vector3D -> Vector3D
distanceBetween :: Xyz xyz => xyz -> xyz -> RSdouble
distanceBetweenSquared :: Xyz xyz => xyz -> xyz -> RSdouble
aNonZeroVector :: Vector3D -> Maybe Vector3D
aLargeVector :: RSdouble -> Vector3D -> Maybe Vector3D
vectorAdd :: Vector3D -> Vector3D -> Vector3D
vectorSum :: [Vector3D] -> Vector3D
vectorScale :: RSdouble -> Vector3D -> Vector3D
vectorScaleTo :: RSdouble -> Vector3D -> Vector3D
vectorToFrom :: Xyz xyz => xyz -> xyz -> Vector3D
vectorNormalize :: Vector3D -> Vector3D
vectorAverage :: [Vector3D] -> Vector3D
vectorLength :: Vector3D -> RSdouble
vectorLengthSquared :: Vector3D -> RSdouble
newell :: [Point3D] -> Maybe Vector3D
class Xyz a
toXYZ :: Xyz a => a -> XYZ
fromXYZ :: Xyz a => XYZ -> a
type XYZ = (RSdouble, RSdouble, RSdouble)
vectorString :: Xyz a => a -> String
randomXYZ :: (RandomGen g, Xyz p) => (RSdouble, RSdouble) -> g -> (p, g)
fixOrtho :: Vector3D -> Vector3D -> Vector3D
fixOrtho2 :: Vector3D -> Vector3D -> (Vector3D, Vector3D)
fixOrtho2Left :: Vector3D -> Vector3D -> (Vector3D, Vector3D)
orthos :: Vector3D -> (Vector3D, Vector3D)
instance Read Point3D
instance Show Point3D
instance Eq Point3D
instance Read Vector3D
instance Show Vector3D
instance Eq Vector3D
instance Read SurfaceVertex3D
instance Show SurfaceVertex3D
instance NFData SurfaceVertex3D
instance AbstractVector Vector3D
instance AbstractMagnitude Vector3D
instance AbstractScale Vector3D
instance AbstractSubtract Vector3D Vector3D
instance AbstractAdd Vector3D Vector3D
instance AbstractZero Vector3D
instance NFData Vector3D
instance Xyz Vector3D
instance NFData Point3D
instance AbstractSubtract Point3D Vector3D
instance AbstractAdd Point3D Vector3D
instance AbstractZero Point3D
instance Xyz Point3D
instance Xyz (RSdouble, RSdouble, RSdouble)

module RSAGL.Math.Matrix
data Matrix
matrix :: [[RSdouble]] -> Matrix

-- | Generate a column matrix of length 4, perform an affine transformation
--   on it, and produce the resulting value.
transformHomogenous :: RSdouble -> RSdouble -> RSdouble -> RSdouble -> (RSdouble -> RSdouble -> RSdouble -> a) -> Matrix -> a
rowMajorForm :: Matrix -> [[RSdouble]]
colMajorForm :: Matrix -> [[RSdouble]]
rowAt :: Matrix -> Int -> [RSdouble]
matrixAt :: Matrix -> (Int, Int) -> RSdouble
identity_matrix :: Matrix
translationMatrix :: Vector3D -> Matrix
rotationMatrix :: Vector3D -> Angle -> Matrix
scaleMatrix :: Vector3D -> Matrix
xyzMatrix :: Vector3D -> Vector3D -> Vector3D -> Matrix
matrixAdd :: Matrix -> Matrix -> Matrix
matrixMultiply :: Matrix -> Matrix -> Matrix
matrixTranspose :: Matrix -> Matrix
matrixInverse :: Matrix -> Matrix
determinant :: Matrix -> RSdouble
matrixInversePrim :: Matrix -> Matrix
matrixTransposePrim :: Matrix -> Matrix
matrixInverseTransposePrim :: Matrix -> Matrix
determinantPrim :: Matrix -> RSdouble
instance Show Matrix
instance Eq Matrix


-- | Affine Transformations of Arbitrary Geometric Objects
module RSAGL.Math.Affine

-- | <a>AffineTransformable</a> objects are subject to affine
--   transformations using matrix multiplication.
class AffineTransformable a
transform :: AffineTransformable a => Matrix -> a -> a
scale :: AffineTransformable a => Vector3D -> a -> a
translate :: AffineTransformable a => Vector3D -> a -> a
rotate :: AffineTransformable a => Vector3D -> Angle -> a -> a
rotateX :: AffineTransformable a => Angle -> a -> a
rotateY :: AffineTransformable a => Angle -> a -> a
rotateZ :: AffineTransformable a => Angle -> a -> a

-- | Specific scale preserving proportions.
scale' :: AffineTransformable a => RSdouble -> a -> a

-- | Apply the inverse of an affine transformation, defined by a 4x4
--   matrix.
inverseTransform :: AffineTransformable a => Matrix -> a -> a

-- | Apply a function under an affine transformation.
--   <tt>withTransformation m id</tt> is an identity if <tt>m</tt> is
--   invertable.
withTransformation :: AffineTransformable a => Matrix -> (a -> a) -> a -> a

-- | Apply a function treating a particular point as the origin. For
--   example, combining <a>transformAbout</a> with <a>rotate</a> performs a
--   rotation about an arbitrary point rather than the origin.
transformAbout :: AffineTransformable a => Point3D -> (a -> a) -> a -> a

-- | Specific translation along the vector between two points. This
--   ordinary use is to set the second point as the center of a model
--   (typically origin_point_3d) and the first point as the desired
--   position of the model.
translateToFrom :: AffineTransformable a => Point3D -> Point3D -> a -> a

-- | Specific rotation along the shortest path that brings the second
--   vector in line with the first.
rotateToFrom :: AffineTransformable a => Vector3D -> Vector3D -> a -> a

-- | Specific scale along an arbitary axis.
scaleAlong :: AffineTransformable a => Vector3D -> RSdouble -> a -> a
instance AffineTransformable (IO a)
instance AffineTransformable SurfaceVertex3D
instance AffineTransformable Point3D
instance AffineTransformable Vector3D
instance AffineTransformable Matrix
instance (AffineTransformable a, AffineTransformable b, AffineTransformable c) => AffineTransformable (a, b, c)
instance (AffineTransformable a, AffineTransformable b) => AffineTransformable (a, b)
instance AffineTransformable a => AffineTransformable [a]
instance AffineTransformable a => AffineTransformable (Maybe a)

module RSAGL.Math.BoundingBox

-- | A simple bounding box. Operations on bounding boxes are designed to be
--   fast, not accurate. The only guarantee on any bounding box operation
--   is that objects reported to be outside a bounding box, are.
data BoundingBox

-- | A convenience class for any finite geometry. In particular, it's easy
--   to concatenate the bounding box of multiple geometries by placing them
--   in a list and taking the bounding box of the entire list.
class Bound3D a
boundingBox :: Bound3D a => a -> BoundingBox

-- | View of a bounding box in the form of a bounding spehre.
boundingCenterRadius :: BoundingBox -> (Point3D, RSdouble)

-- | Estimates distance between a point and the outside surface of a
--   bounding box. If the value is negative, then the point lies inside the
--   bound region.
minimalDistanceToBoundingBox :: Point3D -> BoundingBox -> RSdouble
instance Show BoundingBox
instance AffineTransformable BoundingBox
instance Bound3D BoundingBox
instance Bound3D a => Bound3D [a]
instance Bound3D SurfaceVertex3D
instance Bound3D Point3D

module RSAGL.Math.Curve

-- | A <a>Curve</a> is a parametric function from a one-dimensional space
--   into a space of an arbitrary datatype. The key feature of a
--   <a>Curve</a> is that it is aware of it's own sampling interval. Using
--   this information and appropriate arithmetic and scalar multiplication
--   functions provided by RSAGL.AbstractVector, a <a>Curve</a> can be
--   differentiated or integrated.
data Curve a

-- | Combine two curves using an arbitrary function.
zipCurve :: (x -> y -> z) -> Curve x -> Curve y -> Curve z

-- | Sample a curve at regular intervals in the range 0..1 inclusive.
iterateCurve :: Integer -> Curve x -> [x]

-- | Transpose the inner and outer components of a curve.
transposeCurve :: Curve (Curve a) -> Curve (Curve a)

-- | Define a simple curve.
curve :: (RSdouble -> a) -> Curve a

-- | A <a>Surface</a> is a based on a <a>Curve</a> with an output of
--   another <a>Curve</a>.
data Surface a

-- | Define a simple surface.
surface :: (RSdouble -> RSdouble -> a) -> Surface a
wrapSurface :: Curve (Curve a) -> Surface a
unwrapSurface :: Surface a -> Curve (Curve a)

-- | Transpose the axes of a <a>Surface</a>.
transposeSurface :: Surface a -> Surface a

-- | Combine two surfaces using an arbitrary function.
zipSurface :: (x -> y -> z) -> Surface x -> Surface y -> Surface z

-- | Sample a surface at regularly spaced lattice points in the range 0..1
--   inclusive.
iterateSurface :: (Integer, Integer) -> Surface a -> [[a]]

-- | Sample the outer <a>Curve</a> of a <a>Surface</a> at regularly spaced
--   intervals.
halfIterateSurface :: Integer -> Surface a -> [Curve a]

-- | Transpose a surface while flipping the inner curve, so that that
--   orientable surfaces retain their original orientation.
flipTransposeSurface :: Surface a -> Surface a

-- | Translate a curve along the axis of the input parameter.
translateCurve :: RSdouble -> Curve a -> Curve a

-- | Scale a curve along the axis of the input parameter. Factors greater
--   than one have a <a>zoom in</a> effect, while factors less than one
--   have a <a>zoom out</a> effect.
scaleCurve :: RSdouble -> Curve a -> Curve a

-- | Clamp lower and upper bounds of a curve along the axis of the input
--   parameter.
clampCurve :: (RSdouble, RSdouble) -> Curve a -> Curve a

-- | Loop a curve onto itself at the specified bounds.
loopCurve :: (RSdouble, RSdouble) -> Curve a -> Curve a

-- | Transform a curve by manipulating control points.
controlCurve :: (RSdouble, RSdouble) -> (RSdouble, RSdouble) -> Curve a -> Curve a

-- | Lift two curve transformations onto each axis of a second order curve.
transformCurve2 :: (forall u. Curve u -> Curve u) -> (forall v. Curve v -> Curve v) -> Curve (Curve a) -> Curve (Curve a)

-- | An identity <a>Surface</a>.
uv_identity :: Surface (RSdouble, RSdouble)

-- | Translate a surface over each of its input parameter axes, as
--   translateCurve.
translateSurface :: (RSdouble, RSdouble) -> Surface a -> Surface a

-- | Scale a surface along each of its input parameter axes, as scaleCurve.
scaleSurface :: (RSdouble, RSdouble) -> Surface a -> Surface a

-- | Lift a transformation on a second order <a>Curve</a> onto a Surface.
transformSurface :: (Curve (Curve a) -> Curve (Curve a)) -> Surface a -> Surface a

-- | Lift two curve transformations onto each axis of a Surface.
transformSurface2 :: (forall u. Curve u -> Curve u) -> (forall v. Curve v -> Curve v) -> Surface a -> Surface a

-- | Take the piecewise derivative of a <a>Surface</a> along the inner and
--   outer curves.
surfaceDerivative :: (AbstractSubtract p v, AbstractScale v) => Surface p -> Surface (v, v)

-- | Take the derivative of a <a>Curve</a>.
curveDerivative :: (AbstractSubtract p v, AbstractScale v) => Curve p -> Curve v

-- | Determine the orientation of a <a>Surface</a> by passing very small
--   circles centered on each sampled point as the parametric input.
--   
--   A gotchya with this operation is that as much as 3/4ths of the
--   orientation loop may lie outside of the 0..1 range that is normally
--   sampled. Depending on how the surface is constructed, this may produce
--   unexpected results. The solution is to clamp the the problematic
--   parametric inputs at 0 and 1 using <tt>clampSurface</tt>.
--   
--   As a rule, do clamp longitudinal axes that come to a singularity at
--   each end. Do not clamp latitudinal axes that are connected at each
--   end.
orientationLoops :: Surface p -> Surface (Curve p)

-- | Try to determine the normal vector to a curve.
newellCurve :: Curve Point3D -> Maybe Vector3D

-- | Try to determine the normal vectors of a surface using multiple
--   techniques.
surfaceNormals3D :: Surface Point3D -> Surface SurfaceVertex3D
type SamplingAlgorithm a = Curve a -> [IntervalSample a]

-- | An interval of a curve, including the curve, lower and upper bounds of
--   the interval, and an instantaneous sample value for that interval.
data IntervalSample a

-- | Lower and upper bounds of an <a>IntervalSample</a>.
intervalRange :: IntervalSample a -> (RSdouble, RSdouble)

-- | Size of the range of an <a>IntervalSample</a>.
intervalSize :: IntervalSample a -> RSdouble
intervalSample :: Curve a -> RSdouble -> RSdouble -> IntervalSample a

-- | Integral of the sample value over the range of the
--   <a>IntervalSample</a>.
intervalSingleIntegral :: AbstractScale a => IntervalSample a -> a

-- | Sampling algorithm that takes a fixed count of samples.
linearSamples :: Integer -> SamplingAlgorithm a

-- | Sampling algorithm that takes increasing numbers of samples over
--   intervals where the magnitude of the sample is large.
adaptiveMagnitudeSamples :: AbstractMagnitude a => Integer -> SamplingAlgorithm a

-- | Definite integral of a curve.
integrateCurve :: (AbstractAdd p v, AbstractScale v, AbstractZero p) => SamplingAlgorithm v -> Curve v -> p -> p
instance NFData (Surface a)
instance AffineTransformable a => AffineTransformable (Surface a)
instance Applicative Surface
instance Functor Surface
instance NFData (Curve a)
instance AffineTransformable a => AffineTransformable (Curve a)
instance Applicative Curve
instance Functor Curve


-- | It's useful to work with the set of coordinate systems restricted to
--   those that use orthogonal unit-scaled axes, that is, that are subject
--   only to rotation and translation. This is because these coordinate
--   systems are the describe rigid objects.
module RSAGL.Math.Orthogonal

-- | A reference to the +Y axis.
up :: a -> FUR a

-- | A reference to the -Y axis.
down :: a -> FUR a

-- | A reference to the -X axis.
left :: a -> FUR a

-- | A reference to the +X axis.
right :: a -> FUR a

-- | A reference to the +Z axis.
forward :: a -> FUR a

-- | A reference to the -Z axis.
backward :: a -> FUR a

-- | Combine two axial references to describe a rigid affine
--   transformation. Accepts any combination of non-coaxial references. In
--   the affine transformation, the old axes will be mapped onto the
--   specified freeform axes.
--   
--   The first parameter is absolute, meaning that the source axis will
--   always map perfectly onto the destination axis. The second parameter
--   will be obeyed on a <a>best effort</a> basis.
orthogonalFrame :: AffineTransformable a => FUR Vector3D -> FUR Vector3D -> a -> a

-- | Translates and rotates a model to aim at a given position or in a
--   given direction from a given vantage point. This is analogous to
--   camera look-at functions, and could be used, for example, to cause a
--   model of an eyeball to track a particular target. The first parameter
--   is the position of the model. Typically the second parameter will be
--   the position of the target, and the third parameter will <tt>(up $
--   Vector3D 0 1 0)</tt>.
modelLookAt :: AffineTransformable a => Point3D -> FUR (Either Point3D Vector3D) -> FUR (Either Point3D Vector3D) -> a -> a
data FUR a
instance Functor FUR

module RSAGL.Math.Ray

-- | Rays with endpoints and vectors.
--   
--   Although a ray is isomorphic to a <a>SurfaceVertex3D</a>, it does not
--   have the same behavior.
data Ray3D
Ray3D :: Point3D -> Vector3D -> Ray3D
ray_endpoint :: Ray3D -> Point3D
ray_vector :: Ray3D -> Vector3D

-- | The parametric function of a ray. The parameter is measured as a
--   proportion of the length of the vector. <tt>projectRay 0</tt> is the
--   endpoint of the ray. <tt>projectRay 1</tt> is the endpoint offset by
--   the ray's vector.
projectRay :: RSdouble -> Ray3D -> Point3D

-- | The inverse operation to <a>projectRay</a>. This could also be
--   understood as the height of the point above the plane defined by the
--   ray.
distanceAlong :: Ray3D -> Point3D -> RSdouble

-- | The angle between vector of the ray and the vector from the endpoint
--   of the ray to the specified point.
angleFrom :: Ray3D -> Point3D -> Angle

-- | A ray normalize to a length of 1.
normalizeRay :: Ray3D -> Ray3D
instance Read Ray3D
instance Show Ray3D
instance AffineTransformable Ray3D

module RSAGL.Math.CurveExtras
sphericalCoordinates :: ((Angle, Angle) -> a) -> Surface a
cylindricalCoordinates :: ((Angle, RSdouble) -> a) -> Surface a
toroidalCoordinates :: ((Angle, Angle) -> a) -> Surface a
circularCoordinates :: ((RSdouble, RSdouble) -> a) -> Surface a
polarCoordinates :: ((Angle, RSdouble) -> a) -> Surface a
transformUnitSquareToUnitCircle :: (RSdouble, RSdouble) -> (RSdouble, RSdouble)
transformUnitCubeToUnitSphere :: Point3D -> Point3D
circleXY :: Curve Point3D
regularPolygon :: Integer -> Curve Point3D
linearInterpolation :: (AbstractSubtract p v, AbstractAdd p v, AbstractMagnitude v, AbstractScale v) => [p] -> Curve p
loopedLinearInterpolation :: (AbstractSubtract p v, AbstractAdd p v, AbstractMagnitude v, AbstractScale v) => [p] -> Curve p
smoothCurve :: (AbstractAdd p v, AbstractSubtract p v, AbstractVector v, AbstractZero p) => Integer -> RSdouble -> Curve p -> Curve p

-- | Loop a curve onto itself at the specified bounds.
loopCurve :: (RSdouble, RSdouble) -> Curve a -> Curve a

module RSAGL.Math
