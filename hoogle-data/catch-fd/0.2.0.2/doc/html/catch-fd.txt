-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | MonadThrow and MonadCatch, using functional dependencies
--   
--   MonadThrow and MonadCatch, using functional dependencies
@package catch-fd
@version 0.2.0.2


-- | <ul>
--   <li><i>Computation type:</i> Computations which may fail or throw
--   exceptions; and computations which may catch failures and thrown
--   exceptions.</li>
--   <li><i>Binding strategy:</i> Failure records information about the
--   cause/location of the failure. Failure values bypass the bound
--   function; other values are used as inputs to the bound function (same
--   as <tt><a>MonadError</a></tt>).</li>
--   <li><i>Useful for:</i> Building computations from sequences of
--   functions that may fail; and using exception handling to structure
--   error handling. The handler may or may not throw an exception, which
--   does not have to be of the same type as the original thrown exception
--   (see <tt><a>mapE</a></tt>).</li>
--   <li><i>Zero and plus:</i> Zero is represented by an empty error, and
--   the plus operation executes its second argument if the first fails
--   (same as <tt><a>MonadError</a></tt>).</li>
--   <li><i>Example type:</i> <tt><a>Either</a> <tt>String</tt> a</tt></li>
--   </ul>
--   
--   The Throw and Catch monads.
module Control.Monad.Catch.Class

-- | The strategy of combining computations that can throw exceptions.
--   
--   Is parameterized over the type of error information and the monad type
--   constructor. It is common to use <tt><a>Either</a>
--   <tt>String</tt></tt>. In some cases you will have to define an
--   instance of <tt><a>MonadThrow</a></tt>, though rarely a definition of
--   <tt><a>throw</a></tt>
class Monad m => MonadThrow e m | m -> e where throw = lift . throw
throw :: MonadThrow e m => e -> m a

-- | The strategy of combining computations that can handle thrown
--   exceptions, as well as throwing exceptions in the original
--   computation.
--   
--   Is parameterized over the type of error information and the original
--   monad type constructor, as well as the handler monad type constructor.
--   The handler monad type constructor commonly differs from the original
--   monad type constructor due to a change in the type of the error
--   information.
class (MonadThrow e m, Monad n) => MonadCatch e m n | n e -> m
catch :: MonadCatch e m n => m a -> (e -> n a) -> n a

-- | Map the thrown value using the given function
mapE :: (MonadCatch e m n, MonadThrow e' n) => (e -> e') -> m a -> n a
instance (Monoid w, MonadCatch e m n) => MonadCatch e (WriterT w m) (WriterT w n)
instance (Monoid w, MonadCatch e m n) => MonadCatch e (WriterT w m) (WriterT w n)
instance MonadCatch e m n => MonadCatch e (StateT s m) (StateT s n)
instance MonadCatch e m n => MonadCatch e (StateT s m) (StateT s n)
instance (Monoid w, MonadCatch e m n) => MonadCatch e (RWST r w s m) (RWST r w s n)
instance (Monoid w, MonadCatch e m n) => MonadCatch e (RWST r w s m) (RWST r w s n)
instance MonadCatch e m n => MonadCatch e (ReaderT r m) (ReaderT r n)
instance MonadCatch e m n => MonadCatch e (MaybeT m) (MaybeT n)
instance MonadCatch e m n => MonadCatch e (ListT m) (ListT n)
instance MonadCatch e m n => MonadCatch e (IdentityT m) (IdentityT n)
instance (Monoid w, MonadThrow e m) => MonadThrow e (WriterT w m)
instance (Monoid w, MonadThrow e m) => MonadThrow e (WriterT w m)
instance MonadThrow e m => MonadThrow e (StateT s m)
instance MonadThrow e m => MonadThrow e (StateT s m)
instance (Monoid w, MonadThrow e m) => MonadThrow e (RWST r w s m)
instance (Monoid w, MonadThrow e m) => MonadThrow e (RWST r w s m)
instance MonadThrow e m => MonadThrow e (ReaderT r m)
instance MonadThrow e m => MonadThrow e (MaybeT m)
instance MonadThrow e m => MonadThrow e (ListT m)
instance MonadThrow e m => MonadThrow e (IdentityT m)
instance (Error e, Error e', Monad m) => MonadCatch e (ErrorT e m) (ErrorT e' m)
instance (Error e, Monad m) => MonadThrow e (ErrorT e m)
instance MonadCatch e (Either e) (Either e')
instance MonadThrow e (Either e)
instance MonadCatch IOException IO IO
instance MonadThrow IOException IO


-- | <ul>
--   <li><i>Computation type:</i> Computations which may fail or throw
--   exceptions; and computations which may catch failures and thrown
--   exceptions.</li>
--   <li><i>Binding strategy:</i> Failure records information about the
--   cause/location of the failure. Failure values bypass the bound
--   function; other values are used as inputs to the bound function (same
--   as <tt><a>MonadError</a></tt>).</li>
--   <li><i>Useful for:</i> Building computations from sequences of
--   functions that may fail; and using exception handling to structure
--   error handling. The handler may or may not throw an exception, which
--   does not have to be of the same type as the original thrown exception
--   (see <tt><a>mapE</a></tt>).</li>
--   <li><i>Zero and plus:</i> Zero is represented by an empty error, and
--   the plus operation executes its second argument if the first fails
--   (same as <tt><a>MonadError</a></tt>).</li>
--   <li><i>Example type:</i> <tt><tt>Either</tt> <tt>String</tt>
--   a</tt></li>
--   </ul>
--   
--   The Throw and Catch monads.
module Control.Monad.Catch

-- | The strategy of combining computations that can throw exceptions.
--   
--   Is parameterized over the type of error information and the monad type
--   constructor. It is common to use <tt><a>Either</a>
--   <tt>String</tt></tt>. In some cases you will have to define an
--   instance of <tt><a>MonadThrow</a></tt>, though rarely a definition of
--   <tt><a>throw</a></tt>
class Monad m => MonadThrow e m | m -> e where throw = lift . throw
throw :: MonadThrow e m => e -> m a

-- | The strategy of combining computations that can handle thrown
--   exceptions, as well as throwing exceptions in the original
--   computation.
--   
--   Is parameterized over the type of error information and the original
--   monad type constructor, as well as the handler monad type constructor.
--   The handler monad type constructor commonly differs from the original
--   monad type constructor due to a change in the type of the error
--   information.
class (MonadThrow e m, Monad n) => MonadCatch e m n | n e -> m
catch :: MonadCatch e m n => m a -> (e -> n a) -> n a

-- | Map the thrown value using the given function
mapE :: (MonadCatch e m n, MonadThrow e' n) => (e -> e') -> m a -> n a
type MonadError e m = (MonadThrow e m, MonadCatch e m m)
newtype WrappedMonadError m a
WrapMonadError :: m a -> WrappedMonadError m a
unwrapMonadError :: WrappedMonadError m a -> m a
newtype WrappedMonadCatch m a
WrapMonadCatch :: m a -> WrappedMonadCatch m a
unwrapMonadCatch :: WrappedMonadCatch m a -> m a
instance MonadWriter w m => MonadWriter w (WrappedMonadCatch m)
instance MonadState s m => MonadState s (WrappedMonadCatch m)
instance MonadReader r m => MonadReader r (WrappedMonadCatch m)
instance MonadRWS r w s m => MonadRWS r w s (WrappedMonadCatch m)
instance MonadCatch e m m => MonadError e (WrappedMonadCatch m)
instance MonadCont m => MonadCont (WrappedMonadCatch m)
instance MonadCatch e m n => MonadCatch e (WrappedMonadCatch m) (WrappedMonadCatch n)
instance MonadThrow e m => MonadThrow e (WrappedMonadCatch m)
instance MonadIO m => MonadIO (WrappedMonadCatch m)
instance MonadTrans WrappedMonadCatch
instance Monad m => Monad (WrappedMonadCatch m)
instance Alternative m => Alternative (WrappedMonadCatch m)
instance Applicative m => Applicative (WrappedMonadCatch m)
instance Functor m => Functor (WrappedMonadCatch m)
instance MonadWriter w m => MonadWriter w (WrappedMonadError m)
instance MonadState s m => MonadState s (WrappedMonadError m)
instance MonadReader r m => MonadReader r (WrappedMonadError m)
instance MonadRWS r w s m => MonadRWS r w s (WrappedMonadError m)
instance MonadError e m => MonadError e (WrappedMonadError m)
instance MonadCont m => MonadCont (WrappedMonadError m)
instance MonadError e m => MonadCatch e (WrappedMonadError m) (WrappedMonadError m)
instance MonadError e m => MonadThrow e (WrappedMonadError m)
instance MonadIO m => MonadIO (WrappedMonadError m)
instance MonadTrans WrappedMonadError
instance Monad m => Monad (WrappedMonadError m)
instance Alternative m => Alternative (WrappedMonadError m)
instance Applicative m => Applicative (WrappedMonadError m)
instance Functor m => Functor (WrappedMonadError m)
