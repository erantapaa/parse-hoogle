-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Bifunctors
--   
@package bifunctors
@version 5


module Data.Bifoldable

-- | Minimal definition either <a>bifoldr</a> or <a>bifoldMap</a>
--   
--   <a>Bifoldable</a> identifies foldable structures with two different
--   varieties of elements. Common examples are <a>Either</a> and '(,)':
--   
--   <pre>
--   instance Bifoldable Either where
--     bifoldMap f _ (Left  a) = f a
--     bifoldMap _ g (Right b) = g b
--   
--   instance Bifoldable (,) where
--     bifoldr f g z (a, b) = f a (g b z)
--   </pre>
--   
--   When defining more than the minimal set of definitions, one should
--   ensure that the following identities hold:
--   
--   <pre>
--   <a>bifold</a> ≡ <a>bifoldMap</a> <a>id</a> <a>id</a>
--   <a>bifoldMap</a> f g ≡ <a>bifoldr</a> (<a>mappend</a> . f) (<a>mappend</a> . g) <a>mempty</a>
--   <a>bifoldr</a> f g z t ≡ <a>appEndo</a> (<a>bifoldMap</a> (Endo . f) (Endo . g) t) z
--   </pre>
class Bifoldable p where bifold = bifoldMap id id bifoldMap f g = bifoldr (mappend . f) (mappend . g) mempty bifoldr f g z t = appEndo (bifoldMap (Endo . f) (Endo . g) t) z bifoldl f g z t = appEndo (getDual (bifoldMap (Dual . Endo . flip f) (Dual . Endo . flip g) t)) z
bifold :: (Bifoldable p, Monoid m) => p m m -> m
bifoldMap :: (Bifoldable p, Monoid m) => (a -> m) -> (b -> m) -> p a b -> m
bifoldr :: Bifoldable p => (a -> c -> c) -> (b -> c -> c) -> c -> p a b -> c
bifoldl :: Bifoldable p => (c -> a -> c) -> (c -> b -> c) -> c -> p a b -> c

-- | As <a>bifoldr</a>, but strict in the result of the reduction functions
--   at each step.
bifoldr' :: Bifoldable t => (a -> c -> c) -> (b -> c -> c) -> c -> t a b -> c

-- | Right associative monadic bifold over a structure.
bifoldrM :: (Bifoldable t, Monad m) => (a -> c -> m c) -> (b -> c -> m c) -> c -> t a b -> m c

-- | As <a>bifoldl</a>, but strict in the result of the reductionf unctions
--   at each step.
bifoldl' :: Bifoldable t => (a -> b -> a) -> (a -> c -> a) -> a -> t b c -> a

-- | Left associative monadic bifold over a structure.
bifoldlM :: (Bifoldable t, Monad m) => (a -> b -> m a) -> (a -> c -> m a) -> a -> t b c -> m a

-- | As <a>bitraverse</a>, but ignores the results of the functions, merely
--   performing the "actions".
bitraverse_ :: (Bifoldable t, Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f ()

-- | As <a>bitraverse_</a>, but with the structure as the primary argument.
bifor_ :: (Bifoldable t, Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f ()

-- | As <a>bimapM</a>, but ignores the results of the functions, merely
--   performing the "actions".
bimapM_ :: (Bifoldable t, Monad m) => (a -> m c) -> (b -> m d) -> t a b -> m ()

-- | As <a>bimapM_</a>, but with the structure as the primary argument.
biforM_ :: (Bifoldable t, Monad m) => t a b -> (a -> m c) -> (b -> m d) -> m ()

-- | As <a>bisequenceA</a>, but ignores the results of the actions.
bisequenceA_ :: (Bifoldable t, Applicative f) => t (f a) (f b) -> f ()

-- | As <a>bisequence</a>, but ignores the results of the actions.
bisequence_ :: (Bifoldable t, Monad m) => t (m a) (m b) -> m ()

-- | Collects the list of elements of a structure in order.
biList :: Bifoldable t => t a a -> [a]

-- | Reduces a structure of lists to the concatenation of those lists.
biconcat :: Bifoldable t => t [a] [a] -> [a]

-- | Given a means of mapping the elements of a structure to lists,
--   computes the concatenation of all such lists in order.
biconcatMap :: Bifoldable t => (a -> [c]) -> (b -> [c]) -> t a b -> [c]

-- | Determines whether any element of the structure satisfies the
--   appropriate predicate.
biany :: Bifoldable t => (a -> Bool) -> (b -> Bool) -> t a b -> Bool

-- | Determines whether all elements of the structure satisfy the
--   appropriate predicate.
biall :: Bifoldable t => (a -> Bool) -> (b -> Bool) -> t a b -> Bool
instance Bifoldable Either
instance Bifoldable Tagged
instance Bifoldable ((,,,,,,) x y z w v)
instance Bifoldable ((,,,,,) x y z w)
instance Bifoldable ((,,,,) x y z)
instance Bifoldable ((,,,) x y)
instance Bifoldable ((,,) x)
instance Bifoldable Const
instance Bifoldable (,)
instance Bifoldable Arg


module Data.Bifunctor

-- | Minimal definition either <a>bimap</a> or <a>first</a> and
--   <a>second</a>
--   
--   Formally, the class <a>Bifunctor</a> represents a bifunctor from
--   <tt>Hask</tt> -&gt; <tt>Hask</tt>.
--   
--   Intuitively it is a bifunctor where both the first and second
--   arguments are covariant.
--   
--   You can define a <a>Bifunctor</a> by either defining <a>bimap</a> or
--   by defining both <a>first</a> and <a>second</a>.
--   
--   If you supply <a>bimap</a>, you should ensure that:
--   
--   <pre>
--   <a>bimap</a> <a>id</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply <a>first</a> and <a>second</a>, ensure:
--   
--   <pre>
--   <a>first</a> <a>id</a> ≡ <a>id</a>
--   <a>second</a> <a>id</a> ≡ <a>id</a>
--   </pre>
--   
--   If you supply both, you should also ensure:
--   
--   <pre>
--   <a>bimap</a> f g ≡ <a>first</a> f <a>.</a> <a>second</a> g
--   </pre>
--   
--   These ensure by parametricity:
--   
--   <pre>
--   <a>bimap</a>  (f <a>.</a> g) (h <a>.</a> i) ≡ <a>bimap</a> f h <a>.</a> <a>bimap</a> g i
--   <a>first</a>  (f <a>.</a> g) ≡ <a>first</a>  f <a>.</a> <a>first</a>  g
--   <a>second</a> (f <a>.</a> g) ≡ <a>second</a> f <a>.</a> <a>second</a> g
--   </pre>
class Bifunctor p where bimap f g = first f . second g first f = bimap f id second = bimap id
bimap :: Bifunctor p => (a -> b) -> (c -> d) -> p a c -> p b d
first :: Bifunctor p => (a -> b) -> p a c -> p b c
second :: Bifunctor p => (b -> c) -> p a b -> p a c
instance Bifunctor Tagged
instance Bifunctor Const
instance Bifunctor Either
instance Bifunctor ((,,,,,,) x y z w v)
instance Bifunctor ((,,,,,) x y z w)
instance Bifunctor ((,,,,) x y z)
instance Bifunctor ((,,,) x y)
instance Bifunctor ((,,) x)
instance Bifunctor Arg
instance Bifunctor (,)


module Data.Bitraversable

-- | Minimal complete definition either <a>bitraverse</a> or
--   <a>bisequenceA</a>.
--   
--   <a>Bitraversable</a> identifies bifunctorial data structures whose
--   elements can be traversed in order, performing <a>Applicative</a> or
--   <a>Monad</a> actions at each element, and collecting a result
--   structure with the same shape.
--   
--   A definition of <tt>traverse</tt> must satisfy the following laws:
--   
--   <ul>
--   <li><i><i>naturality</i></i> <tt><a>bitraverse</a> (t . f) (t . g) ≡ t
--   . <a>bitraverse</a> f g</tt> for every applicative transformation
--   <tt>t</tt></li>
--   <li><i><i>identity</i></i> <tt><a>bitraverse</a> <tt>Identity</tt>
--   <tt>Identity</tt> ≡ <tt>Identity</tt></tt></li>
--   <li><i><i>composition</i></i> <tt><tt>Compose</tt> . <a>fmap</a>
--   (<a>bitraverse</a> g1 g2) . <a>bitraverse</a> f1 f2 ≡
--   <tt>traverse</tt> (<tt>Compose</tt> . <a>fmap</a> g1 . f1)
--   (<tt>Compose</tt> . <a>fmap</a> g2 . f2)</tt></li>
--   </ul>
--   
--   A definition of <a>bisequenceA</a> must satisfy the following laws:
--   
--   <ul>
--   <li><i><i>naturality</i></i> <tt><a>bisequenceA</a> . <a>bimap</a> t t
--   ≡ t . <a>bisequenceA</a></tt> for every applicative transformation
--   <tt>t</tt></li>
--   <li><i><i>identity</i></i> <tt><a>bisequenceA</a> . <a>bimap</a>
--   <tt>Identity</tt> <tt>Identity</tt> ≡ <tt>Identity</tt></tt></li>
--   <li><i><i>composition</i></i> <tt><a>bisequenceA</a> . <a>bimap</a>
--   <tt>Compose</tt> <tt>Compose</tt> ≡ <tt>Compose</tt> . <a>fmap</a>
--   <a>bisequenceA</a> . <a>bisequenceA</a></tt></li>
--   </ul>
--   
--   where an <i>applicative transformation</i> is a function
--   
--   <pre>
--   t :: (<a>Applicative</a> f, <a>Applicative</a> g) =&gt; f a -&gt; g a
--   </pre>
--   
--   preserving the <a>Applicative</a> operations:
--   
--   <pre>
--   t (<a>pure</a> x) = <a>pure</a> x
--   t (f <a>&lt;*&gt;</a> x) = t f <a>&lt;*&gt;</a> t x
--   </pre>
--   
--   and the identity functor <tt>Identity</tt> and composition functors
--   <tt>Compose</tt> are defined as
--   
--   <pre>
--   newtype Identity a = Identity { runIdentity :: a }
--   
--   instance Functor Identity where
--     fmap f (Identity x) = Identity (f x)
--   
--   instance Applicative Identity where
--     pure = Identity
--     Identity f &lt;*&gt; Identity x = Identity (f x)
--   
--   newtype Compose f g a = Compose (f (g a))
--   
--   instance (Functor f, Functor g) =&gt; Functor (Compose f g) where
--     fmap f (Compose x) = Compose (fmap (fmap f) x)
--   
--   instance (Applicative f, Applicative g) =&gt; Applicative (Compose f g) where
--     pure = Compose . pure . pure
--     Compose f &lt;*&gt; Compose x = Compose ((&lt;*&gt;) &lt;$&gt; f &lt;*&gt; x)
--   </pre>
--   
--   Some simple examples are <a>Either</a> and '(,)':
--   
--   <pre>
--   instance Bitraversable Either where
--     bitraverse f _ (Left x) = Left &lt;$&gt; f x
--     bitraverse _ g (Right y) = Right &lt;$&gt; g y
--   
--   instance Bitraversable (,) where
--     bitraverse f g (x, y) = (,) &lt;$&gt; f x &lt;*&gt; g y
--   </pre>
--   
--   <a>Bitraversable</a> relates to its superclasses in the following
--   ways:
--   
--   <pre>
--   <a>bimap</a> f g ≡ <tt>runIdentity</tt> . <a>bitraverse</a> (<tt>Identity</tt> . f) (<tt>Identity</tt> . g)
--   <a>bifoldMap</a> f g = <a>getConst</a> . <a>bitraverse</a> (<a>Const</a> . f) (<a>Const</a> . g)
--   </pre>
--   
--   These are available as <a>bimapDefault</a> and <a>bifoldMapDefault</a>
--   respectively.
class (Bifunctor t, Bifoldable t) => Bitraversable t where bitraverse f g = bisequenceA . bimap f g bisequenceA = bitraverse id id bimapM f g = unwrapMonad . bitraverse (WrapMonad . f) (WrapMonad . g) bisequence = bimapM id id
bitraverse :: (Bitraversable t, Applicative f) => (a -> f c) -> (b -> f d) -> t a b -> f (t c d)
bisequenceA :: (Bitraversable t, Applicative f) => t (f a) (f b) -> f (t a b)
bimapM :: (Bitraversable t, Monad m) => (a -> m c) -> (b -> m d) -> t a b -> m (t c d)
bisequence :: (Bitraversable t, Monad m) => t (m a) (m b) -> m (t a b)

-- | <a>bifor</a> is <a>bitraverse</a> with the structure as the first
--   argument.
bifor :: (Bitraversable t, Applicative f) => t a b -> (a -> f c) -> (b -> f d) -> f (t c d)

-- | <a>biforM</a> is <a>bimapM</a> with the structure as the first
--   argument.
biforM :: (Bitraversable t, Monad m) => t a b -> (a -> m c) -> (b -> m d) -> m (t c d)

-- | Traverses a structure from left to right, threading a state of type
--   <tt>a</tt> and using the given actions to compute new elements for the
--   structure.
bimapAccumL :: Bitraversable t => (a -> b -> (a, c)) -> (a -> d -> (a, e)) -> a -> t b d -> (a, t c e)

-- | Traverses a structure from right to left, threading a state of type
--   <tt>a</tt> and using the given actions to compute new elements for the
--   structure.
bimapAccumR :: Bitraversable t => (a -> b -> (a, c)) -> (a -> d -> (a, e)) -> a -> t b d -> (a, t c e)

-- | A default definition of <a>bimap</a> in terms of the
--   <a>Bitraversable</a> operations.
bimapDefault :: Bitraversable t => (a -> b) -> (c -> d) -> t a c -> t b d

-- | A default definition of <a>bifoldMap</a> in terms of the
--   <a>Bitraversable</a> operations.
bifoldMapDefault :: (Bitraversable t, Monoid m) => (a -> m) -> (b -> m) -> t a b -> m
instance Applicative Id
instance Functor Id
instance Applicative (StateR s)
instance Functor (StateR s)
instance Applicative (StateL s)
instance Functor (StateL s)
instance Bitraversable Tagged
instance Bitraversable Const
instance Bitraversable Either
instance Bitraversable ((,,,,,,) x y z w v)
instance Bitraversable ((,,,,,) x y z w)
instance Bitraversable ((,,,,) x y z)
instance Bitraversable ((,,,) x y)
instance Bitraversable ((,,) x)
instance Bitraversable (,)
instance Bitraversable Arg


module Data.Biapplicative
class Bifunctor p => Biapplicative p where a *>> b = bimap (const id) (const id) <<$>> a <<*>> b a <<* b = bimap const const <<$>> a <<*>> b
bipure :: Biapplicative p => a -> b -> p a b
(<<*>>) :: Biapplicative p => p (a -> b) (c -> d) -> p a c -> p b d
(*>>) :: Biapplicative p => p a b -> p c d -> p c d
(<<*) :: Biapplicative p => p a b -> p c d -> p a b
(<<$>>) :: (a -> b) -> a -> b
(<<**>>) :: Biapplicative p => p a c -> p (a -> b) (c -> d) -> p b d

-- | Lift binary functions
biliftA2 :: Biapplicative w => (a -> b -> c) -> (d -> e -> f) -> w a d -> w b e -> w c f

-- | Lift ternary functions
biliftA3 :: Biapplicative w => (a -> b -> c -> d) -> (e -> f -> g -> h) -> w a e -> w b f -> w c g -> w d h
instance Biapplicative Const
instance Biapplicative Tagged
instance (Monoid x, Monoid y, Monoid z, Monoid w, Monoid v) => Biapplicative ((,,,,,,) x y z w v)
instance (Monoid x, Monoid y, Monoid z, Monoid w) => Biapplicative ((,,,,,) x y z w)
instance (Monoid x, Monoid y, Monoid z) => Biapplicative ((,,,,) x y z)
instance (Monoid x, Monoid y) => Biapplicative ((,,,) x y)
instance Monoid x => Biapplicative ((,,) x)
instance Biapplicative Arg
instance Biapplicative (,)


module Data.Bifunctor.Biff

-- | Compose two <a>Functor</a>s on the inside of a <a>Bifunctor</a>.
newtype Biff p f g a b
Biff :: p (f a) (g b) -> Biff p f g a b
runBiff :: Biff p f g a b -> p (f a) (g b)
instance Eq (p (f a) (g b)) => Eq (Biff p f g a b)
instance Ord (p (f a) (g b)) => Ord (Biff p f g a b)
instance Show (p (f a) (g b)) => Show (Biff p f g a b)
instance Read (p (f a) (g b)) => Read (Biff p f g a b)
instance (Bitraversable p, Traversable f, Traversable g) => Bitraversable (Biff p f g)
instance (Bitraversable p, Traversable g) => Traversable (Biff p f g a)
instance (Bifoldable p, Foldable f, Foldable g) => Bifoldable (Biff p f g)
instance (Bifoldable p, Foldable g) => Foldable (Biff p f g a)
instance (Biapplicative p, Applicative f, Applicative g) => Biapplicative (Biff p f g)
instance (Bifunctor p, Functor g) => Functor (Biff p f g a)
instance (Bifunctor p, Functor f, Functor g) => Bifunctor (Biff p f g)


-- | From the Functional Pearl "Clowns to the Left of me, Jokers to the
--   Right: Dissecting Data Structures" by Conor McBride.
module Data.Bifunctor.Clown

-- | Make a <a>Functor</a> over the first argument of a <a>Bifunctor</a>.
newtype Clown f a b
Clown :: f a -> Clown f a b
runClown :: Clown f a b -> f a
instance Eq (f a) => Eq (Clown f a b)
instance Ord (f a) => Ord (Clown f a b)
instance Show (f a) => Show (Clown f a b)
instance Read (f a) => Read (Clown f a b)
instance Traversable (Clown f a)
instance Traversable f => Bitraversable (Clown f)
instance Foldable (Clown f a)
instance Foldable f => Bifoldable (Clown f)
instance Applicative f => Biapplicative (Clown f)
instance Functor (Clown f a)
instance Functor f => Bifunctor (Clown f)


module Data.Bifunctor.Flip

-- | Make a <a>Bifunctor</a> flipping the arguments of a <a>Bifunctor</a>.
newtype Flip p a b
Flip :: p b a -> Flip p a b
runFlip :: Flip p a b -> p b a
instance Eq (p b a) => Eq (Flip p a b)
instance Ord (p b a) => Ord (Flip p a b)
instance Show (p b a) => Show (Flip p a b)
instance Read (p b a) => Read (Flip p a b)
instance Bitraversable p => Traversable (Flip p a)
instance Bitraversable p => Bitraversable (Flip p)
instance Bifoldable p => Foldable (Flip p a)
instance Bifoldable p => Bifoldable (Flip p)
instance Biapplicative p => Biapplicative (Flip p)
instance Bifunctor p => Functor (Flip p a)
instance Bifunctor p => Bifunctor (Flip p)


module Data.Bifunctor.Join

-- | Make a <a>Functor</a> over both arguments of a <a>Bifunctor</a>.
newtype Join p a
Join :: p a a -> Join p a
runJoin :: Join p a -> p a a
instance Read (p a a) => Read (Join p a)
instance Show (p a a) => Show (Join p a)
instance Ord (p a a) => Ord (Join p a)
instance Eq (p a a) => Eq (Join p a)
instance Bitraversable p => Traversable (Join p)
instance Bifoldable p => Foldable (Join p)
instance Biapplicative p => Applicative (Join p)
instance Bifunctor p => Functor (Join p)


-- | From the Functional Pearl "Clowns to the Left of me, Jokers to the
--   Right: Dissecting Data Structures" by Conor McBride.
module Data.Bifunctor.Joker

-- | Make a <a>Functor</a> over the second argument of a <a>Bifunctor</a>.
newtype Joker g a b
Joker :: g b -> Joker g a b
runJoker :: Joker g a b -> g b
instance Eq (g b) => Eq (Joker g a b)
instance Ord (g b) => Ord (Joker g a b)
instance Show (g b) => Show (Joker g a b)
instance Read (g b) => Read (Joker g a b)
instance Traversable g => Traversable (Joker g a)
instance Traversable g => Bitraversable (Joker g)
instance Foldable g => Foldable (Joker g a)
instance Foldable g => Bifoldable (Joker g)
instance Applicative g => Biapplicative (Joker g)
instance Functor g => Functor (Joker g a)
instance Functor g => Bifunctor (Joker g)


-- | The product of two bifunctors.
module Data.Bifunctor.Product

-- | Form the product of two bifunctors
data Product f g a b
Pair :: (f a b) -> (g a b) -> Product f g a b
instance (Eq (f a b), Eq (g a b)) => Eq (Product f g a b)
instance (Ord (f a b), Ord (g a b)) => Ord (Product f g a b)
instance (Show (f a b), Show (g a b)) => Show (Product f g a b)
instance (Read (f a b), Read (g a b)) => Read (Product f g a b)
instance (Bitraversable f, Bitraversable g) => Bitraversable (Product f g)
instance (Bifoldable f, Bifoldable g) => Bifoldable (Product f g)
instance (Biapplicative f, Biapplicative g) => Biapplicative (Product f g)
instance (Bifunctor f, Bifunctor g) => Bifunctor (Product f g)


module Data.Bifunctor.Tannen

-- | Compose a <a>Functor</a> on the outside of a <a>Bifunctor</a>.
newtype Tannen f p a b
Tannen :: f (p a b) -> Tannen f p a b
runTannen :: Tannen f p a b -> f (p a b)
instance Eq (f (p a b)) => Eq (Tannen f p a b)
instance Ord (f (p a b)) => Ord (Tannen f p a b)
instance Show (f (p a b)) => Show (Tannen f p a b)
instance Read (f (p a b)) => Read (Tannen f p a b)
instance (Traversable f, Bitraversable p) => Bitraversable (Tannen f p)
instance (Traversable f, Bitraversable p) => Traversable (Tannen f p a)
instance (Foldable f, Bifoldable p) => Bifoldable (Tannen f p)
instance (Foldable f, Bifoldable p) => Foldable (Tannen f p a)
instance (Applicative f, Biapplicative p) => Biapplicative (Tannen f p)
instance (Functor f, Bifunctor p) => Functor (Tannen f p a)
instance (Functor f, Bifunctor p) => Bifunctor (Tannen f p)


module Data.Bifunctor.Wrapped

-- | Make a <a>Functor</a> over the second argument of a <a>Bifunctor</a>.
newtype WrappedBifunctor p a b
WrapBifunctor :: p a b -> WrappedBifunctor p a b
unwrapBifunctor :: WrappedBifunctor p a b -> p a b
instance Eq (p a b) => Eq (WrappedBifunctor p a b)
instance Ord (p a b) => Ord (WrappedBifunctor p a b)
instance Show (p a b) => Show (WrappedBifunctor p a b)
instance Read (p a b) => Read (WrappedBifunctor p a b)
instance Bitraversable p => Bitraversable (WrappedBifunctor p)
instance Bitraversable p => Traversable (WrappedBifunctor p a)
instance Bifoldable p => Bifoldable (WrappedBifunctor p)
instance Bifoldable p => Foldable (WrappedBifunctor p a)
instance Biapplicative p => Biapplicative (WrappedBifunctor p)
instance Bifunctor p => Functor (WrappedBifunctor p a)
instance Bifunctor p => Bifunctor (WrappedBifunctor p)
