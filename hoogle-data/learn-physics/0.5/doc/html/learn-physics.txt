-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell code for learning physics
--   
@package learn-physics
@version 0.5


-- | Some tools related to the gloss 2D graphics and animation library.
module Physics.Learn.Visual.GlossTools

-- | assumes radians coming in
polarToCart :: (Float, Float) -> (Float, Float)

-- | theta=0 is positive x axis, output angle in radians
cartToPolar :: (Float, Float) -> (Float, Float)

-- | An arrow
arrow :: Point -> Point -> Picture

-- | A think arrow
thickArrow :: Float -> Point -> Point -> Picture


-- | Functions for approximately solving equations like f(x) = 0. These
--   functions proceed by assuming that f is continuous, and that a root is
--   bracketed. A bracket around a root consists of numbers a, b such that
--   f(a) f(b) &lt;= 0. Since the product changes sign, there must be an x
--   with a &lt; x &lt; b such that f(x) = 0.
module Physics.Learn.RootFinding

-- | Find a list of roots for a function over a given range. There are no
--   guarantees that all roots will be found. Uses <a>findRootsN</a> with
--   1000 intervals.
findRoots :: (Double -> Double) -> (Double, Double) -> [Double]

-- | Find a list of roots for a function over a given range. First
--   parameter is the initial number of intervals to use to find the roots.
--   If roots are closely spaced, this number of intervals may need to be
--   large.
findRootsN :: Int -> (Double -> Double) -> (Double, Double) -> [Double]

-- | Find a single root in a bracketed region. The algorithm continues
--   until it exhausts the precision of a <a>Double</a>. This could cause
--   the function to hang.
findRoot :: (Double -> Double) -> (Double, Double) -> Double

-- | Given an initial bracketing of a root (an interval (a,b) for which
--   f(a) f(b) &lt;= 0), produce a bracket of arbitrary smallness.
bracketRoot :: (Ord a, Fractional a) => a -> (a -> a) -> (a, a) -> (a, a)

-- | Given a bracketed root, return a half-width bracket.
bracketRootStep :: (Ord a, Fractional a) => (a -> a) -> ((a, a), (a, a)) -> ((a, a), (a, a))


-- | Composite Trapezoid Rule and Composite Simpson's Rule
module Physics.Learn.CompositeQuadrature

-- | Composite Trapezoid Rule
compositeTrapezoid :: (VectorSpace v, Fractional (Scalar v)) => Int -> Scalar v -> Scalar v -> (Scalar v -> v) -> v

-- | Composite Simpson's Rule
compositeSimpson :: (VectorSpace v, Fractional (Scalar v)) => Int -> Scalar v -> Scalar v -> (Scalar v -> v) -> v


-- | This module defines some common vector operations. It is intended that
--   this module not be imported directly, but that its functionality be
--   gained by importing either <tt>SimpleVec</tt> or <tt>CarrotVec</tt>,
--   but not both. Choose <tt>SimpleVec</tt> for vector operations (such as
--   vector addition) with simple concrete types, which work only with the
--   type <a>Vec</a> of three-dimensional vectors. Choose
--   <tt>CarrotVec</tt> for vector operations that work with any type in
--   the appropriate type class.
module Physics.Learn.CommonVec

-- | A type for vectors.
data Vec
Vec :: Double -> Double -> Double -> Vec

-- | x component
xComp :: Vec -> Double

-- | y component
yComp :: Vec -> Double

-- | z component
zComp :: Vec -> Double

-- | Form a vector by giving its x, y, and z components.
vec :: Double -> Double -> Double -> Vec

-- | Cross product.
(><) :: Vec -> Vec -> Vec

-- | Unit vector in the x direction.
iHat :: Vec

-- | Unit vector in the y direction.
jHat :: Vec

-- | Unit vector in the z direction.
kHat :: Vec
instance [safe] Eq Vec
instance [safe] Show Vec


-- | Basic operations on the vector type <a>Vec</a>, such as vector
--   addition and scalar multiplication. This module is simple in the sense
--   that the operations on vectors all have simple, concrete types,
--   without the need for type classes. This makes using and reasoning
--   about vector operations easier for a person just learning Haskell.
module Physics.Learn.SimpleVec

-- | A type for vectors.
data Vec

-- | x component
xComp :: Vec -> Double

-- | y component
yComp :: Vec -> Double

-- | z component
zComp :: Vec -> Double

-- | Form a vector by giving its x, y, and z components.
vec :: Double -> Double -> Double -> Vec

-- | Vector addition.
(^+^) :: Vec -> Vec -> Vec

-- | Vector subtraction.
(^-^) :: Vec -> Vec -> Vec

-- | Scalar multiplication, where the scalar is on the left and the vector
--   is on the right.
(*^) :: Double -> Vec -> Vec

-- | Scalar multiplication, where the scalar is on the right and the vector
--   is on the left.
(^*) :: Vec -> Double -> Vec

-- | Division of a vector by a scalar.
(^/) :: Vec -> Double -> Vec

-- | Dot product of two vectors.
(<.>) :: Vec -> Vec -> Double

-- | Cross product.
(><) :: Vec -> Vec -> Vec

-- | Magnitude of a vector.
magnitude :: Vec -> Double

-- | The zero vector.
zeroV :: Vec

-- | The additive inverse of a vector.
negateV :: Vec -> Vec

-- | Sum of a list of vectors.
sumV :: [Vec] -> Vec

-- | Unit vector in the x direction.
iHat :: Vec

-- | Unit vector in the y direction.
jHat :: Vec

-- | Unit vector in the z direction.
kHat :: Vec


-- | This module defines some basic vector functionality. It uses the same
--   internal data representation as <tt>SimpleVec</tt>, but declares
--   <a>Vec</a> to be an instance of <a>VectorSpace</a>. We import
--   <a>zeroV</a>, <a>negateV</a>, <a>sumV</a>, <a>^+^</a>, <a>^-^</a> from
--   <a>AdditiveGroup</a>, and <a>*^</a>, <a>^*</a>, <a>^/</a>,
--   <a>&lt;.&gt;</a>, <a>magnitude</a> from <a>VectorSpace</a>.
--   
--   <tt>CarrotVec</tt> exports exactly the same symbols as
--   <tt>SimpleVec</tt>; they are just defined differently.
module Physics.Learn.CarrotVec

-- | A type for vectors.
data Vec

-- | x component
xComp :: Vec -> Double

-- | y component
yComp :: Vec -> Double

-- | z component
zComp :: Vec -> Double

-- | Form a vector by giving its x, y, and z components.
vec :: Double -> Double -> Double -> Vec

-- | Add vectors
(^+^) :: AdditiveGroup v => v -> v -> v

-- | Group subtraction
(^-^) :: AdditiveGroup v => v -> v -> v

-- | Scale a vector
(*^) :: VectorSpace v => Scalar v -> v -> v

-- | Vector multiplied by scalar
(^*) :: (VectorSpace v, (~) * s (Scalar v)) => v -> s -> v

-- | Vector divided by scalar
(^/) :: (VectorSpace v, (~) * s (Scalar v), Fractional s) => v -> s -> v

-- | Inner/dot product
(<.>) :: InnerSpace v => v -> v -> Scalar v

-- | Cross product.
(><) :: Vec -> Vec -> Vec

-- | Length of a vector. See also <a>magnitudeSq</a>.
magnitude :: (InnerSpace v, (~) * s (Scalar v), Floating s) => v -> s

-- | The zero element: identity for '(^+^)'
zeroV :: AdditiveGroup v => v

-- | Additive inverse
negateV :: AdditiveGroup v => v -> v

-- | Sum over several vectors
sumV :: (Foldable f, AdditiveGroup v) => f v -> v

-- | Unit vector in the x direction.
iHat :: Vec

-- | Unit vector in the y direction.
jHat :: Vec

-- | Unit vector in the z direction.
kHat :: Vec
instance InnerSpace Vec
instance VectorSpace Vec
instance AdditiveGroup Vec


-- | A module for working with the idea of position and coordinate systems.
module Physics.Learn.Position

-- | A type for position. Position is not a vector because it makes no
--   sense to add positions.
data Position

-- | A displacement is a vector.
type Displacement = Vec

-- | A scalar field associates a number with each position in space.
type ScalarField = Position -> Double

-- | A vector field associates a vector with each position in space.
type VectorField = Position -> Vec

-- | Sometimes we want to be able to talk about a field without saying
--   whether it is a scalar field or a vector field.
type Field v = Position -> v

-- | A coordinate system is a function from three parameters to space.
type CoordinateSystem = (Double, Double, Double) -> Position

-- | The Cartesian coordinate system. Coordinates are (x,y,z).
cartesian :: CoordinateSystem

-- | The cylindrical coordinate system. Coordinates are (s,phi,z), where s
--   is the distance from the z axis and phi is the angle with the x axis.
cylindrical :: CoordinateSystem

-- | The spherical coordinate system. Coordinates are (r,theta,phi), where
--   r is the distance from the origin, theta is the angle with the z axis,
--   and phi is the azimuthal angle.
spherical :: CoordinateSystem

-- | A helping function to take three numbers x, y, and z and form the
--   appropriate position using Cartesian coordinates.
cart :: Double -> Double -> Double -> Position

-- | A helping function to take three numbers s, phi, and z and form the
--   appropriate position using cylindrical coordinates.
cyl :: Double -> Double -> Double -> Position

-- | A helping function to take three numbers r, theta, and phi and form
--   the appropriate position using spherical coordinates.
sph :: Double -> Double -> Double -> Position

-- | Returns the three Cartesian coordinates as a triple from a position.
cartesianCoordinates :: Position -> (Double, Double, Double)

-- | Returns the three cylindrical coordinates as a triple from a position.
cylindricalCoordinates :: Position -> (Double, Double, Double)

-- | Returns the three spherical coordinates as a triple from a position.
sphericalCoordinates :: Position -> (Double, Double, Double)

-- | Displacement from source position to target position.
displacement :: Position -> Position -> Displacement

-- | Shift a position by a displacement.
shiftPosition :: Displacement -> Position -> Position

-- | An object is a map into <a>Position</a>.
shiftObject :: Displacement -> (a -> Position) -> (a -> Position)

-- | A field is a map from <a>Position</a>.
shiftField :: Displacement -> (Position -> v) -> (Position -> v)

-- | Add two scalar fields or two vector fields.
addFields :: AdditiveGroup v => [Field v] -> Field v

-- | The vector field in which each point in space is associated with a
--   unit vector in the direction of increasing spherical coordinate r,
--   while spherical coordinates theta and phi are held constant. Defined
--   everywhere except at the origin. The unit vector <a>rHat</a> points in
--   different directions at different points in space. It is therefore
--   better interpreted as a vector field, rather than a vector.
rHat :: VectorField

-- | The vector field in which each point in space is associated with a
--   unit vector in the direction of increasing spherical coordinate theta,
--   while spherical coordinates r and phi are held constant. Defined
--   everywhere except on the z axis.
thetaHat :: VectorField

-- | The vector field in which each point in space is associated with a
--   unit vector in the direction of increasing (cylindrical or spherical)
--   coordinate phi, while cylindrical coordinates s and z (or spherical
--   coordinates r and theta) are held constant. Defined everywhere except
--   on the z axis.
phiHat :: VectorField

-- | The vector field in which each point in space is associated with a
--   unit vector in the direction of increasing cylindrical coordinate s,
--   while cylindrical coordinates phi and z are held constant. Defined
--   everywhere except on the z axis.
sHat :: VectorField

-- | The vector field in which each point in space is associated with a
--   unit vector in the direction of increasing Cartesian coordinate x,
--   while Cartesian coordinates y and z are held constant. Defined
--   everywhere.
xHat :: VectorField

-- | The vector field in which each point in space is associated with a
--   unit vector in the direction of increasing Cartesian coordinate y,
--   while Cartesian coordinates x and z are held constant. Defined
--   everywhere.
yHat :: VectorField

-- | The vector field in which each point in space is associated with a
--   unit vector in the direction of increasing Cartesian coordinate z,
--   while Cartesian coordinates x and y are held constant. Defined
--   everywhere.
zHat :: VectorField
instance Show Position


-- | Coordinate fields for Cartesian, cylindrical, and spherical
--   coordinates.
module Physics.Learn.CoordinateFields

-- | The x Cartesian coordinate of a position.
x :: ScalarField

-- | The y Cartesian coordinate of a position.
y :: ScalarField

-- | The z Cartesian (or cylindrical) coordinate of a position.
z :: ScalarField

-- | The s cylindrical coordinate of a position. This is the distance of
--   the position from the z axis.
s :: ScalarField

-- | The phi cylindrical (or spherical) coordinate of a position. This is
--   the angle from the positive x axis to the projection of the position
--   onto the xy plane.
phi :: ScalarField

-- | The r spherical coordinate of a position. This is the distance of the
--   position from the origin.
r :: ScalarField

-- | The theta spherical coordinate of a position. This is the angle from
--   the positive z axis to the position.
theta :: ScalarField


-- | A module for working with coordinate systems.
module Physics.Learn.CoordinateSystem

-- | Specification of a coordinate system requires a map from coordinates
--   into space, and a map from space into coordinates.
data CoordinateSystem
CoordinateSystem :: ((Double, Double, Double) -> Position) -> (Position -> (Double, Double, Double)) -> CoordinateSystem

-- | a map from coordinates into space
toPosition :: CoordinateSystem -> (Double, Double, Double) -> Position

-- | a map from space into coordinates
fromPosition :: CoordinateSystem -> Position -> (Double, Double, Double)

-- | The standard Cartesian coordinate system
standardCartesian :: CoordinateSystem

-- | The standard cylindrical coordinate system
standardCylindrical :: CoordinateSystem

-- | The standard spherical coordinate system
standardSpherical :: CoordinateSystem

-- | Define a new coordinate system in terms of an existing one. First
--   parameter is a map from old coordinates to new coordinates. Second
--   parameter is the inverse map from new coordinates to old coordinates.
newCoordinateSystem :: ((Double, Double, Double) -> (Double, Double, Double)) -> ((Double, Double, Double) -> (Double, Double, Double)) -> CoordinateSystem -> CoordinateSystem


-- | This module contains functions for working with <a>Curve</a>s and line
--   integrals along <a>Curve</a>s.
module Physics.Learn.Curve

-- | <a>Curve</a> is a parametrized function into three-space, an initial
--   limit, and a final limit.
data Curve
Curve :: (Double -> Position) -> Double -> Double -> Curve

-- | function from one parameter into space
curveFunc :: Curve -> Double -> Position

-- | starting value of the parameter
startingCurveParam :: Curve -> Double

-- | ending value of the parameter
endingCurveParam :: Curve -> Double

-- | Reparametrize a curve from 0 to 1.
normalizeCurve :: Curve -> Curve

-- | Concatenate two curves.
concatCurves :: Curve -> Curve -> Curve

-- | Concatenate a list of curves. Parametrizes curves equally.
concatenateCurves :: [Curve] -> Curve

-- | Reverse a curve.
reverseCurve :: Curve -> Curve

-- | Evaluate the position of a curve at a parameter.
evalCurve :: Curve -> Double -> Position

-- | Shift a curve by a displacement.
shiftCurve :: Displacement -> Curve -> Curve

-- | The straight-line curve from one position to another.
straightLine :: Position -> Position -> Curve

-- | Calculates integral f dl over curve, where dl is a scalar line
--   element.
simpleLineIntegral :: (InnerSpace v, Scalar v ~ Double) => Int -> Field v -> Curve -> v

-- | A dotted line integral. Convenience function for
--   <a>compositeSimpsonDottedLineIntegral</a>.
dottedLineIntegral :: Int -> VectorField -> Curve -> Double

-- | Calculates integral vf x dl over curve. Convenience function for
--   <a>compositeSimpsonCrossedLineIntegral</a>.
crossedLineIntegral :: Int -> VectorField -> Curve -> Vec

-- | A dotted line integral, performed in an unsophisticated way.
compositeTrapezoidDottedLineIntegral :: Int -> VectorField -> Curve -> Double

-- | Calculates integral vf x dl over curve in an unsophisticated way.
compositeTrapezoidCrossedLineIntegral :: Int -> VectorField -> Curve -> Vec

-- | Quadratic approximation to vector field. Quadratic approximation to
--   curve. Composite strategy. Dotted line integral.
compositeSimpsonDottedLineIntegral :: Int -> VectorField -> Curve -> Double

-- | Quadratic approximation to vector field. Quadratic approximation to
--   curve. Composite strategy. Crossed line integral.
compositeSimpsonCrossedLineIntegral :: Int -> VectorField -> Curve -> Vec


-- | This module contains helping functions for using Gnuplot.
module Physics.Learn.Visual.PlotTools

-- | An <a>Attribute</a> with a given label at a given position.
label :: String -> (Double, Double) -> Attribute

-- | An <a>Attribute</a> that requests postscript output.
postscript :: Attribute

-- | An <a>Attribute</a> giving the postscript file name.
psFile :: FilePath -> Attribute

-- | An example of the use of <a>label</a>. See the source code.
examplePlot1 :: IO ()

-- | An example of the use of <a>postscript</a> and <a>psFile</a>. See the
--   source code.
examplePlot2 :: IO ()

-- | Plot a Curve in the xy plane using Gnuplot
plotXYCurve :: Curve -> IO ()


-- | This module contains functions for working with <a>Surface</a>s and
--   surface integrals over <a>Surface</a>s.
module Physics.Learn.Surface

-- | Surface is a parametrized function from two parameters to space, lower
--   and upper limits on the first parameter, and lower and upper limits
--   for the second parameter (expressed as functions of the first
--   parameter).
data Surface
Surface :: ((Double, Double) -> Position) -> Double -> Double -> (Double -> Double) -> (Double -> Double) -> Surface

-- | function from two parameters (s,t) into space
surfaceFunc :: Surface -> (Double, Double) -> Position

-- | s_l
lowerLimit :: Surface -> Double

-- | s_u
upperLimit :: Surface -> Double

-- | t_l(s)
lowerCurve :: Surface -> Double -> Double

-- | t_u(s)
upperCurve :: Surface -> Double -> Double

-- | A unit sphere, centered at the origin.
unitSphere :: Surface

-- | A sphere with given radius centered at the origin.
centeredSphere :: Double -> Surface

-- | Sphere with given radius and center.
sphere :: Double -> Position -> Surface

-- | The upper half of a unit sphere, centered at the origin.
northernHemisphere :: Surface

-- | A disk with given radius, centered at the origin.
disk :: Double -> Surface

-- | Shift a surface by a displacement.
shiftSurface :: Displacement -> Surface -> Surface

-- | A plane surface integral, in which area element is a scalar.
surfaceIntegral :: (VectorSpace v, Scalar v ~ Double) => Int -> Int -> Field v -> Surface -> v

-- | A dotted surface integral, in which area element is a vector.
dottedSurfaceIntegral :: Int -> Int -> VectorField -> Surface -> Double


-- | This module contains functions for working with <a>Volume</a>s and
--   volume integrals over <a>Volume</a>s.
module Physics.Learn.Volume

-- | Volume is a parametrized function from three parameters to space,
--   lower and upper limits on the first parameter, lower and upper limits
--   for the second parameter (expressed as functions of the first
--   parameter), and lower and upper limits for the third parameter
--   (expressed as functions of the first and second parameters).
data Volume
Volume :: ((Double, Double, Double) -> Position) -> Double -> Double -> (Double -> Double) -> (Double -> Double) -> (Double -> Double -> Double) -> (Double -> Double -> Double) -> Volume

-- | function from 3 parameters to space
volumeFunc :: Volume -> (Double, Double, Double) -> Position

-- | s_a
loLimit :: Volume -> Double

-- | s_b
upLimit :: Volume -> Double

-- | t_a(s)
loCurve :: Volume -> Double -> Double

-- | t_b(s)
upCurve :: Volume -> Double -> Double

-- | u_a(s,t)
loSurf :: Volume -> Double -> Double -> Double

-- | u_b(s,t)
upSurf :: Volume -> Double -> Double -> Double

-- | A unit ball, centered at the origin.
unitBall :: Volume

-- | A unit ball, centered at the origin. Specified in Cartesian
--   coordinates.
unitBallCartesian :: Volume

-- | A ball with given radius, centered at the origin.
centeredBall :: Double -> Volume

-- | Ball with given radius and center.
ball :: Double -> Position -> Volume

-- | Upper half ball, unit radius, centered at origin.
northernHalfBall :: Volume

-- | Cylinder with given radius and height. Circular base of the cylinder
--   is centered at the origin. Circular top of the cylinder lies in plane
--   z = h.
centeredCylinder :: Double -> Double -> Volume

-- | Shift a volume by a displacement.
shiftVolume :: Displacement -> Volume -> Volume

-- | A volume integral
volumeIntegral :: (VectorSpace v, Scalar v ~ Double) => Int -> Int -> Int -> Field v -> Volume -> v


-- | This module contains functions for working with current, magnetic
--   field, and magnetic flux.
module Physics.Learn.Current

-- | Electric current, in units of Amperes (A)
type Current = Double

-- | A current distribution is a line current (current through a wire), a
--   surface current, a volume current, or a combination of these. The
--   <a>VectorField</a> describes a surface current density or a volume
--   current density.
data CurrentDistribution

-- | current through a wire
LineCurrent :: Current -> Curve -> CurrentDistribution

-- | <a>VectorField</a> is surface current density (A/m)
SurfaceCurrent :: VectorField -> Surface -> CurrentDistribution

-- | <a>VectorField</a> is volume current density (A/m^2)
VolumeCurrent :: VectorField -> Volume -> CurrentDistribution

-- | combination of current distributions
MultipleCurrents :: [CurrentDistribution] -> CurrentDistribution

-- | The magnetic field produced by a current distribution. This is the
--   simplest way to find the magnetic field, because it works for any
--   current distribution (line, surface, volume, or combination).
bField :: CurrentDistribution -> VectorField

-- | Magnetic field produced by a line current (current through a wire).
--   The function <a>bField</a> calls this function to evaluate the
--   magnetic field produced by a line current.
bFieldFromLineCurrent :: Current -> Curve -> VectorField

-- | Magnetic field produced by a surface current. The function
--   <a>bField</a> calls this function to evaluate the magnetic field
--   produced by a surface current. This function assumes that surface
--   current density will be specified parallel to the surface, and does
--   not check if that is true.
bFieldFromSurfaceCurrent :: VectorField -> Surface -> VectorField

-- | Magnetic field produced by a volume current. The function
--   <a>bField</a> calls this function to evaluate the magnetic field
--   produced by a volume current.
bFieldFromVolumeCurrent :: VectorField -> Volume -> VectorField

-- | The magnetic flux through a surface produced by a current
--   distribution.
magneticFlux :: Surface -> CurrentDistribution -> Double


-- | A <a>StateSpace</a> is an affine space where the associated vector
--   space has scalars that are instances of <a>Fractional</a>. If p is an
--   instance of <a>StateSpace</a>, then the associated vectorspace
--   <a>Diff</a> p is intended to represent the space of (time) derivatives
--   of paths in p.
--   
--   <a>StateSpace</a> is very similar to Conal Elliott's
--   <tt>AffineSpace</tt>.
module Physics.Learn.StateSpace

-- | An instance of <a>StateSpace</a> is a data type that can serve as the
--   state of some system. Alternatively, a <a>StateSpace</a> is a
--   collection of dependent variables for a differential equation. A
--   <a>StateSpace</a> has an associated vector space for the (time)
--   derivatives of the state. The associated vector space is a linearized
--   version of the <a>StateSpace</a>.
class (VectorSpace (Diff p), Fractional (Scalar (Diff p))) => StateSpace p where type family Diff p
(.-.) :: StateSpace p => p -> p -> Diff p
(.+^) :: StateSpace p => p -> Diff p -> p

-- | Point minus vector
(.-^) :: StateSpace p => p -> Diff p -> p

-- | The scalars of the associated vector space can be thought of as time
--   intervals.
type Time p = Scalar (Diff p)

-- | A differential equation expresses how the dependent variables (state)
--   change with the independent variable (time). A differential equation
--   is specified by giving the (time) derivative of the state as a
--   function of the state. The (time) derivative of a state is an element
--   of the associated vector space.
type DifferentialEquation state = state -> Diff state

-- | An initial value problem is a differential equation along with an
--   initial state.
type InitialValueProblem state = (DifferentialEquation state, state)

-- | An evolution method is a way of approximating the state after
--   advancing a finite interval in the independent variable (time) from a
--   given state.
type EvolutionMethod state = DifferentialEquation state -> Time state -> state -> state

-- | A (numerical) solution method is a way of converting an initial value
--   problem into a list of states (a solution). The list of states need
--   not be equally spaced in time.
type SolutionMethod state = InitialValueProblem state -> [state]

-- | Given an evolution method and a time step, return the solution method
--   which applies the evolution method repeatedly with with given time
--   step. The solution method returned will produce an infinite list of
--   states.
stepSolution :: EvolutionMethod state -> Time state -> SolutionMethod state

-- | The Euler method is the simplest evolution method. It increments the
--   state by the derivative times the time step.
eulerMethod :: StateSpace state => EvolutionMethod state
instance StateSpace p => StateSpace [p]
instance VectorSpace v => VectorSpace [v]
instance AdditiveGroup v => AdditiveGroup [v]
instance (StateSpace p, StateSpace q, StateSpace r, Time p ~ Time q, Time q ~ Time r) => StateSpace (p, q, r)
instance (StateSpace p, StateSpace q, Time p ~ Time q) => StateSpace (p, q)
instance StateSpace Position
instance StateSpace Vec
instance StateSpace Double


-- | Differential equation solving using 4th-order Runge-Kutta
module Physics.Learn.RungeKutta

-- | Take a single 4th-order Runge-Kutta step
rungeKutta4 :: StateSpace p => (p -> Diff p) -> Time p -> p -> p

-- | Solve a first-order system of differential equations with 4th-order
--   Runge-Kutta
integrateSystem :: StateSpace p => (p -> Diff p) -> Time p -> p -> [p]


-- | Newton's second law and all that
module Physics.Learn.Mechanics

-- | Time (in s).
type TheTime = Double

-- | A time step (in s).
type TimeStep = Double

-- | Velocity of a particle (in m/s).
type Velocity = Vec

-- | A simple one-particle state, to get started quickly with mechanics of
--   one particle.
type SimpleState = (TheTime, Position, Velocity)

-- | An acceleration function gives the particle's acceleration as a
--   function of the particle's state. The specification of this function
--   is what makes one single-particle mechanics problem different from
--   another. In order to write this function, add all of the forces that
--   act on the particle, and divide this net force by the particle's mass.
--   (Newton's second law).
type SimpleAccelerationFunction = SimpleState -> Vec

-- | Time derivative of state for a single particle with a constant mass.
simpleStateDeriv :: SimpleAccelerationFunction -> DifferentialEquation SimpleState

-- | Single Runge-Kutta step
simpleRungeKuttaStep :: SimpleAccelerationFunction -> TimeStep -> SimpleState -> SimpleState

-- | The state of a single particle is given by the position of the
--   particle and the velocity of the particle.
data St
St :: Position -> Velocity -> St
position :: St -> Position
velocity :: St -> Velocity

-- | The associated vector space for the state of a single particle.
data DSt
DSt :: Vec -> Vec -> DSt

-- | The state of a system of one particle is given by the current time,
--   the position of the particle, and the velocity of the particle.
--   Including time in the state like this allows us to have time-dependent
--   forces.
type OneParticleSystemState = (TheTime, St)

-- | An acceleration function gives the particle's acceleration as a
--   function of the particle's state.
type OneParticleAccelerationFunction = OneParticleSystemState -> Vec

-- | Time derivative of state for a single particle with a constant mass.
oneParticleStateDeriv :: OneParticleAccelerationFunction -> DifferentialEquation OneParticleSystemState

-- | Single Runge-Kutta step
oneParticleRungeKuttaStep :: OneParticleAccelerationFunction -> TimeStep -> OneParticleSystemState -> OneParticleSystemState

-- | List of system states
oneParticleRungeKuttaSolution :: OneParticleAccelerationFunction -> TimeStep -> OneParticleSystemState -> [OneParticleSystemState]

-- | The state of a system of two particles is given by the current time,
--   the position and velocity of particle 1, and the position and velocity
--   of particle 2.
type TwoParticleSystemState = (TheTime, St, St)

-- | An acceleration function gives a pair of accelerations (one for
--   particle 1, one for particle 2) as a function of the system's state.
type TwoParticleAccelerationFunction = TwoParticleSystemState -> (Vec, Vec)

-- | Time derivative of state for two particles with constant mass.
twoParticleStateDeriv :: TwoParticleAccelerationFunction -> DifferentialEquation TwoParticleSystemState

-- | Single Runge-Kutta step for two-particle system
twoParticleRungeKuttaStep :: TwoParticleAccelerationFunction -> TimeStep -> TwoParticleSystemState -> TwoParticleSystemState

-- | The state of a system of many particles is given by the current time
--   and a list of one-particle states.
type ManyParticleSystemState = (TheTime, [St])

-- | An acceleration function gives a list of accelerations (one for each
--   particle) as a function of the system's state.
type ManyParticleAccelerationFunction = ManyParticleSystemState -> [Vec]

-- | Time derivative of state for many particles with constant mass.
manyParticleStateDeriv :: ManyParticleAccelerationFunction -> DifferentialEquation ManyParticleSystemState

-- | Single Runge-Kutta step for many-particle system
manyParticleRungeKuttaStep :: ManyParticleAccelerationFunction -> TimeStep -> ManyParticleSystemState -> ManyParticleSystemState
instance Show St
instance Show DSt
instance StateSpace St
instance VectorSpace DSt
instance AdditiveGroup DSt


-- | Some tools related to the not-gloss 3D graphics and animation library.
module Physics.Learn.Visual.VisTools

-- | Make a <a>V3</a> object from a <a>Vec</a>.
v3FromVec :: Vec -> V3 Double

-- | Make a <a>V3</a> object from a <a>Position</a>.
v3FromPos :: Position -> V3 Double

-- | A VisObject arrow from a vector
visVec :: Color -> Vec -> VisObject Double

-- | Place a vector at a particular position.
oneVector :: Color -> Position -> Vec -> VisObject Double

-- | Display a vector field.
displayVectorField :: Color -> Double -> [Position] -> VectorField -> VisObject Double

-- | A displayable VisObject for a curve.
curveObject :: Color -> Curve -> VisObject Double
instance Show Cart
instance Show Sph


-- | This module contains functions for working with charge, electric
--   field, electric flux, and electric potential.
module Physics.Learn.Charge

-- | Electric charge, in units of Coulombs (C)
type Charge = Double

-- | A charge distribution is a point charge, a line charge, a surface
--   charge, a volume charge, or a combination of these. The
--   <a>ScalarField</a> describes a linear charge density, a surface charge
--   density, or a volume charge density.
data ChargeDistribution

-- | point charge
PointCharge :: Charge -> Position -> ChargeDistribution

-- | <a>ScalarField</a> is linear charge density (C/m)
LineCharge :: ScalarField -> Curve -> ChargeDistribution

-- | <a>ScalarField</a> is surface charge density (C/m^2)
SurfaceCharge :: ScalarField -> Surface -> ChargeDistribution

-- | <a>ScalarField</a> is volume charge density (C/m^3)
VolumeCharge :: ScalarField -> Volume -> ChargeDistribution

-- | combination of charge distributions
MultipleCharges :: [ChargeDistribution] -> ChargeDistribution

-- | Total charge (in C) of a charge distribution.
totalCharge :: ChargeDistribution -> Charge

-- | The electric field produced by a charge distribution. This is the
--   simplest way to find the electric field, because it works for any
--   charge distribution (point, line, surface, volume, or combination).
eField :: ChargeDistribution -> VectorField

-- | Electric field produced by a point charge. The function <a>eField</a>
--   calls this function to evaluate the electric field produced by a point
--   charge.
eFieldFromPointCharge :: Charge -> Position -> VectorField

-- | Electric field produced by a line charge. The function <a>eField</a>
--   calls this function to evaluate the electric field produced by a line
--   charge.
eFieldFromLineCharge :: ScalarField -> Curve -> VectorField

-- | Electric field produced by a surface charge. The function
--   <a>eField</a> calls this function to evaluate the electric field
--   produced by a surface charge.
eFieldFromSurfaceCharge :: ScalarField -> Surface -> VectorField

-- | Electric field produced by a volume charge. The function <a>eField</a>
--   calls this function to evaluate the electric field produced by a
--   volume charge.
eFieldFromVolumeCharge :: ScalarField -> Volume -> VectorField

-- | The electric flux through a surface produced by a charge distribution.
electricFlux :: Surface -> ChargeDistribution -> Double

-- | Electric potential from electric field, given a position to be the
--   zero of electric potential.
electricPotentialFromField :: Position -> VectorField -> ScalarField

-- | Electric potential produced by a charge distribution. The position
--   where the electric potential is zero is taken to be infinity.
electricPotentialFromCharge :: ChargeDistribution -> ScalarField


-- | Functions for learning physics.
module Physics.Learn

-- | Time (in s).
type TheTime = Double

-- | A time step (in s).
type TimeStep = Double

-- | Velocity of a particle (in m/s).
type Velocity = Vec

-- | A simple one-particle state, to get started quickly with mechanics of
--   one particle.
type SimpleState = (TheTime, Position, Velocity)

-- | An acceleration function gives the particle's acceleration as a
--   function of the particle's state. The specification of this function
--   is what makes one single-particle mechanics problem different from
--   another. In order to write this function, add all of the forces that
--   act on the particle, and divide this net force by the particle's mass.
--   (Newton's second law).
type SimpleAccelerationFunction = SimpleState -> Vec

-- | Time derivative of state for a single particle with a constant mass.
simpleStateDeriv :: SimpleAccelerationFunction -> DifferentialEquation SimpleState

-- | Single Runge-Kutta step
simpleRungeKuttaStep :: SimpleAccelerationFunction -> TimeStep -> SimpleState -> SimpleState

-- | The state of a single particle is given by the position of the
--   particle and the velocity of the particle.
data St
St :: Position -> Velocity -> St
position :: St -> Position
velocity :: St -> Velocity

-- | The associated vector space for the state of a single particle.
data DSt
DSt :: Vec -> Vec -> DSt

-- | The state of a system of one particle is given by the current time,
--   the position of the particle, and the velocity of the particle.
--   Including time in the state like this allows us to have time-dependent
--   forces.
type OneParticleSystemState = (TheTime, St)

-- | An acceleration function gives the particle's acceleration as a
--   function of the particle's state.
type OneParticleAccelerationFunction = OneParticleSystemState -> Vec

-- | Time derivative of state for a single particle with a constant mass.
oneParticleStateDeriv :: OneParticleAccelerationFunction -> DifferentialEquation OneParticleSystemState

-- | Single Runge-Kutta step
oneParticleRungeKuttaStep :: OneParticleAccelerationFunction -> TimeStep -> OneParticleSystemState -> OneParticleSystemState

-- | List of system states
oneParticleRungeKuttaSolution :: OneParticleAccelerationFunction -> TimeStep -> OneParticleSystemState -> [OneParticleSystemState]

-- | The state of a system of two particles is given by the current time,
--   the position and velocity of particle 1, and the position and velocity
--   of particle 2.
type TwoParticleSystemState = (TheTime, St, St)

-- | An acceleration function gives a pair of accelerations (one for
--   particle 1, one for particle 2) as a function of the system's state.
type TwoParticleAccelerationFunction = TwoParticleSystemState -> (Vec, Vec)

-- | Time derivative of state for two particles with constant mass.
twoParticleStateDeriv :: TwoParticleAccelerationFunction -> DifferentialEquation TwoParticleSystemState

-- | Single Runge-Kutta step for two-particle system
twoParticleRungeKuttaStep :: TwoParticleAccelerationFunction -> TimeStep -> TwoParticleSystemState -> TwoParticleSystemState

-- | The state of a system of many particles is given by the current time
--   and a list of one-particle states.
type ManyParticleSystemState = (TheTime, [St])

-- | An acceleration function gives a list of accelerations (one for each
--   particle) as a function of the system's state.
type ManyParticleAccelerationFunction = ManyParticleSystemState -> [Vec]

-- | Time derivative of state for many particles with constant mass.
manyParticleStateDeriv :: ManyParticleAccelerationFunction -> DifferentialEquation ManyParticleSystemState

-- | Single Runge-Kutta step for many-particle system
manyParticleRungeKuttaStep :: ManyParticleAccelerationFunction -> TimeStep -> ManyParticleSystemState -> ManyParticleSystemState

-- | Electric charge, in units of Coulombs (C)
type Charge = Double

-- | A charge distribution is a point charge, a line charge, a surface
--   charge, a volume charge, or a combination of these. The
--   <a>ScalarField</a> describes a linear charge density, a surface charge
--   density, or a volume charge density.
data ChargeDistribution

-- | point charge
PointCharge :: Charge -> Position -> ChargeDistribution

-- | <a>ScalarField</a> is linear charge density (C/m)
LineCharge :: ScalarField -> Curve -> ChargeDistribution

-- | <a>ScalarField</a> is surface charge density (C/m^2)
SurfaceCharge :: ScalarField -> Surface -> ChargeDistribution

-- | <a>ScalarField</a> is volume charge density (C/m^3)
VolumeCharge :: ScalarField -> Volume -> ChargeDistribution

-- | combination of charge distributions
MultipleCharges :: [ChargeDistribution] -> ChargeDistribution

-- | Total charge (in C) of a charge distribution.
totalCharge :: ChargeDistribution -> Charge

-- | Electric current, in units of Amperes (A)
type Current = Double

-- | A current distribution is a line current (current through a wire), a
--   surface current, a volume current, or a combination of these. The
--   <a>VectorField</a> describes a surface current density or a volume
--   current density.
data CurrentDistribution

-- | current through a wire
LineCurrent :: Current -> Curve -> CurrentDistribution

-- | <a>VectorField</a> is surface current density (A/m)
SurfaceCurrent :: VectorField -> Surface -> CurrentDistribution

-- | <a>VectorField</a> is volume current density (A/m^2)
VolumeCurrent :: VectorField -> Volume -> CurrentDistribution

-- | combination of current distributions
MultipleCurrents :: [CurrentDistribution] -> CurrentDistribution

-- | The electric field produced by a charge distribution. This is the
--   simplest way to find the electric field, because it works for any
--   charge distribution (point, line, surface, volume, or combination).
eField :: ChargeDistribution -> VectorField

-- | The electric flux through a surface produced by a charge distribution.
electricFlux :: Surface -> ChargeDistribution -> Double

-- | Electric potential from electric field, given a position to be the
--   zero of electric potential.
electricPotentialFromField :: Position -> VectorField -> ScalarField

-- | Electric potential produced by a charge distribution. The position
--   where the electric potential is zero is taken to be infinity.
electricPotentialFromCharge :: ChargeDistribution -> ScalarField

-- | The magnetic field produced by a current distribution. This is the
--   simplest way to find the magnetic field, because it works for any
--   current distribution (line, surface, volume, or combination).
bField :: CurrentDistribution -> VectorField

-- | The magnetic flux through a surface produced by a current
--   distribution.
magneticFlux :: Surface -> CurrentDistribution -> Double

-- | A type for vectors.
data Vec

-- | x component
xComp :: Vec -> Double

-- | y component
yComp :: Vec -> Double

-- | z component
zComp :: Vec -> Double

-- | Form a vector by giving its x, y, and z components.
vec :: Double -> Double -> Double -> Vec

-- | Add vectors
(^+^) :: AdditiveGroup v => v -> v -> v

-- | Group subtraction
(^-^) :: AdditiveGroup v => v -> v -> v

-- | Scale a vector
(*^) :: VectorSpace v => Scalar v -> v -> v

-- | Vector multiplied by scalar
(^*) :: (VectorSpace v, (~) * s (Scalar v)) => v -> s -> v

-- | Vector divided by scalar
(^/) :: (VectorSpace v, (~) * s (Scalar v), Fractional s) => v -> s -> v

-- | Inner/dot product
(<.>) :: InnerSpace v => v -> v -> Scalar v

-- | Cross product.
(><) :: Vec -> Vec -> Vec

-- | Length of a vector. See also <a>magnitudeSq</a>.
magnitude :: (InnerSpace v, (~) * s (Scalar v), Floating s) => v -> s

-- | The zero element: identity for '(^+^)'
zeroV :: AdditiveGroup v => v

-- | Additive inverse
negateV :: AdditiveGroup v => v -> v

-- | Sum over several vectors
sumV :: (Foldable f, AdditiveGroup v) => f v -> v

-- | Unit vector in the x direction.
iHat :: Vec

-- | Unit vector in the y direction.
jHat :: Vec

-- | Unit vector in the z direction.
kHat :: Vec

-- | A type for position. Position is not a vector because it makes no
--   sense to add positions.
data Position

-- | A displacement is a vector.
type Displacement = Vec

-- | A scalar field associates a number with each position in space.
type ScalarField = Position -> Double

-- | A vector field associates a vector with each position in space.
type VectorField = Position -> Vec

-- | Sometimes we want to be able to talk about a field without saying
--   whether it is a scalar field or a vector field.
type Field v = Position -> v

-- | A coordinate system is a function from three parameters to space.
type CoordinateSystem = (Double, Double, Double) -> Position

-- | The Cartesian coordinate system. Coordinates are (x,y,z).
cartesian :: CoordinateSystem

-- | The cylindrical coordinate system. Coordinates are (s,phi,z), where s
--   is the distance from the z axis and phi is the angle with the x axis.
cylindrical :: CoordinateSystem

-- | The spherical coordinate system. Coordinates are (r,theta,phi), where
--   r is the distance from the origin, theta is the angle with the z axis,
--   and phi is the azimuthal angle.
spherical :: CoordinateSystem

-- | A helping function to take three numbers x, y, and z and form the
--   appropriate position using Cartesian coordinates.
cart :: Double -> Double -> Double -> Position

-- | A helping function to take three numbers s, phi, and z and form the
--   appropriate position using cylindrical coordinates.
cyl :: Double -> Double -> Double -> Position

-- | A helping function to take three numbers r, theta, and phi and form
--   the appropriate position using spherical coordinates.
sph :: Double -> Double -> Double -> Position

-- | Returns the three Cartesian coordinates as a triple from a position.
cartesianCoordinates :: Position -> (Double, Double, Double)

-- | Returns the three cylindrical coordinates as a triple from a position.
cylindricalCoordinates :: Position -> (Double, Double, Double)

-- | Returns the three spherical coordinates as a triple from a position.
sphericalCoordinates :: Position -> (Double, Double, Double)

-- | Displacement from source position to target position.
displacement :: Position -> Position -> Displacement

-- | Shift a position by a displacement.
shiftPosition :: Displacement -> Position -> Position

-- | An object is a map into <a>Position</a>.
shiftObject :: Displacement -> (a -> Position) -> (a -> Position)

-- | A field is a map from <a>Position</a>.
shiftField :: Displacement -> (Position -> v) -> (Position -> v)

-- | Add two scalar fields or two vector fields.
addFields :: AdditiveGroup v => [Field v] -> Field v

-- | The vector field in which each point in space is associated with a
--   unit vector in the direction of increasing spherical coordinate r,
--   while spherical coordinates theta and phi are held constant. Defined
--   everywhere except at the origin. The unit vector <a>rHat</a> points in
--   different directions at different points in space. It is therefore
--   better interpreted as a vector field, rather than a vector.
rHat :: VectorField

-- | The vector field in which each point in space is associated with a
--   unit vector in the direction of increasing spherical coordinate theta,
--   while spherical coordinates r and phi are held constant. Defined
--   everywhere except on the z axis.
thetaHat :: VectorField

-- | The vector field in which each point in space is associated with a
--   unit vector in the direction of increasing (cylindrical or spherical)
--   coordinate phi, while cylindrical coordinates s and z (or spherical
--   coordinates r and theta) are held constant. Defined everywhere except
--   on the z axis.
phiHat :: VectorField

-- | The vector field in which each point in space is associated with a
--   unit vector in the direction of increasing cylindrical coordinate s,
--   while cylindrical coordinates phi and z are held constant. Defined
--   everywhere except on the z axis.
sHat :: VectorField

-- | The vector field in which each point in space is associated with a
--   unit vector in the direction of increasing Cartesian coordinate x,
--   while Cartesian coordinates y and z are held constant. Defined
--   everywhere.
xHat :: VectorField

-- | The vector field in which each point in space is associated with a
--   unit vector in the direction of increasing Cartesian coordinate y,
--   while Cartesian coordinates x and z are held constant. Defined
--   everywhere.
yHat :: VectorField

-- | The vector field in which each point in space is associated with a
--   unit vector in the direction of increasing Cartesian coordinate z,
--   while Cartesian coordinates x and y are held constant. Defined
--   everywhere.
zHat :: VectorField

-- | <a>Curve</a> is a parametrized function into three-space, an initial
--   limit, and a final limit.
data Curve
Curve :: (Double -> Position) -> Double -> Double -> Curve

-- | function from one parameter into space
curveFunc :: Curve -> Double -> Position

-- | starting value of the parameter
startingCurveParam :: Curve -> Double

-- | ending value of the parameter
endingCurveParam :: Curve -> Double

-- | Reparametrize a curve from 0 to 1.
normalizeCurve :: Curve -> Curve

-- | Concatenate two curves.
concatCurves :: Curve -> Curve -> Curve

-- | Concatenate a list of curves. Parametrizes curves equally.
concatenateCurves :: [Curve] -> Curve

-- | Reverse a curve.
reverseCurve :: Curve -> Curve

-- | Evaluate the position of a curve at a parameter.
evalCurve :: Curve -> Double -> Position

-- | Shift a curve by a displacement.
shiftCurve :: Displacement -> Curve -> Curve

-- | The straight-line curve from one position to another.
straightLine :: Position -> Position -> Curve

-- | Calculates integral f dl over curve, where dl is a scalar line
--   element.
simpleLineIntegral :: (InnerSpace v, Scalar v ~ Double) => Int -> Field v -> Curve -> v

-- | A dotted line integral. Convenience function for
--   <a>compositeSimpsonDottedLineIntegral</a>.
dottedLineIntegral :: Int -> VectorField -> Curve -> Double

-- | Calculates integral vf x dl over curve. Convenience function for
--   <a>compositeSimpsonCrossedLineIntegral</a>.
crossedLineIntegral :: Int -> VectorField -> Curve -> Vec

-- | Surface is a parametrized function from two parameters to space, lower
--   and upper limits on the first parameter, and lower and upper limits
--   for the second parameter (expressed as functions of the first
--   parameter).
data Surface
Surface :: ((Double, Double) -> Position) -> Double -> Double -> (Double -> Double) -> (Double -> Double) -> Surface

-- | function from two parameters (s,t) into space
surfaceFunc :: Surface -> (Double, Double) -> Position

-- | s_l
lowerLimit :: Surface -> Double

-- | s_u
upperLimit :: Surface -> Double

-- | t_l(s)
lowerCurve :: Surface -> Double -> Double

-- | t_u(s)
upperCurve :: Surface -> Double -> Double

-- | A unit sphere, centered at the origin.
unitSphere :: Surface

-- | A sphere with given radius centered at the origin.
centeredSphere :: Double -> Surface

-- | Sphere with given radius and center.
sphere :: Double -> Position -> Surface

-- | The upper half of a unit sphere, centered at the origin.
northernHemisphere :: Surface

-- | A disk with given radius, centered at the origin.
disk :: Double -> Surface

-- | Shift a surface by a displacement.
shiftSurface :: Displacement -> Surface -> Surface

-- | A plane surface integral, in which area element is a scalar.
surfaceIntegral :: (VectorSpace v, Scalar v ~ Double) => Int -> Int -> Field v -> Surface -> v

-- | A dotted surface integral, in which area element is a vector.
dottedSurfaceIntegral :: Int -> Int -> VectorField -> Surface -> Double

-- | Volume is a parametrized function from three parameters to space,
--   lower and upper limits on the first parameter, lower and upper limits
--   for the second parameter (expressed as functions of the first
--   parameter), and lower and upper limits for the third parameter
--   (expressed as functions of the first and second parameters).
data Volume
Volume :: ((Double, Double, Double) -> Position) -> Double -> Double -> (Double -> Double) -> (Double -> Double) -> (Double -> Double -> Double) -> (Double -> Double -> Double) -> Volume

-- | function from 3 parameters to space
volumeFunc :: Volume -> (Double, Double, Double) -> Position

-- | s_a
loLimit :: Volume -> Double

-- | s_b
upLimit :: Volume -> Double

-- | t_a(s)
loCurve :: Volume -> Double -> Double

-- | t_b(s)
upCurve :: Volume -> Double -> Double

-- | u_a(s,t)
loSurf :: Volume -> Double -> Double -> Double

-- | u_b(s,t)
upSurf :: Volume -> Double -> Double -> Double

-- | A unit ball, centered at the origin.
unitBall :: Volume

-- | A unit ball, centered at the origin. Specified in Cartesian
--   coordinates.
unitBallCartesian :: Volume

-- | A ball with given radius, centered at the origin.
centeredBall :: Double -> Volume

-- | Ball with given radius and center.
ball :: Double -> Position -> Volume

-- | Upper half ball, unit radius, centered at origin.
northernHalfBall :: Volume

-- | Cylinder with given radius and height. Circular base of the cylinder
--   is centered at the origin. Circular top of the cylinder lies in plane
--   z = h.
centeredCylinder :: Double -> Double -> Volume

-- | Shift a volume by a displacement.
shiftVolume :: Displacement -> Volume -> Volume

-- | A volume integral
volumeIntegral :: (VectorSpace v, Scalar v ~ Double) => Int -> Int -> Int -> Field v -> Volume -> v

-- | An instance of <a>StateSpace</a> is a data type that can serve as the
--   state of some system. Alternatively, a <a>StateSpace</a> is a
--   collection of dependent variables for a differential equation. A
--   <a>StateSpace</a> has an associated vector space for the (time)
--   derivatives of the state. The associated vector space is a linearized
--   version of the <a>StateSpace</a>.
class (VectorSpace (Diff p), Fractional (Scalar (Diff p))) => StateSpace p where type family Diff p
(.-.) :: StateSpace p => p -> p -> Diff p
(.+^) :: StateSpace p => p -> Diff p -> p

-- | Point minus vector
(.-^) :: StateSpace p => p -> Diff p -> p

-- | The scalars of the associated vector space can be thought of as time
--   intervals.
type Time p = Scalar (Diff p)

-- | A differential equation expresses how the dependent variables (state)
--   change with the independent variable (time). A differential equation
--   is specified by giving the (time) derivative of the state as a
--   function of the state. The (time) derivative of a state is an element
--   of the associated vector space.
type DifferentialEquation state = state -> Diff state

-- | An initial value problem is a differential equation along with an
--   initial state.
type InitialValueProblem state = (DifferentialEquation state, state)

-- | An evolution method is a way of approximating the state after
--   advancing a finite interval in the independent variable (time) from a
--   given state.
type EvolutionMethod state = DifferentialEquation state -> Time state -> state -> state

-- | A (numerical) solution method is a way of converting an initial value
--   problem into a list of states (a solution). The list of states need
--   not be equally spaced in time.
type SolutionMethod state = InitialValueProblem state -> [state]

-- | Given an evolution method and a time step, return the solution method
--   which applies the evolution method repeatedly with with given time
--   step. The solution method returned will produce an infinite list of
--   states.
stepSolution :: EvolutionMethod state -> Time state -> SolutionMethod state

-- | The Euler method is the simplest evolution method. It increments the
--   state by the derivative times the time step.
eulerMethod :: StateSpace state => EvolutionMethod state

-- | Take a single 4th-order Runge-Kutta step
rungeKutta4 :: StateSpace p => (p -> Diff p) -> Time p -> p -> p

-- | Solve a first-order system of differential equations with 4th-order
--   Runge-Kutta
integrateSystem :: StateSpace p => (p -> Diff p) -> Time p -> p -> [p]

-- | An <a>Attribute</a> with a given label at a given position.
label :: String -> (Double, Double) -> Attribute

-- | An <a>Attribute</a> that requests postscript output.
postscript :: Attribute

-- | An <a>Attribute</a> giving the postscript file name.
psFile :: FilePath -> Attribute

-- | assumes radians coming in
polarToCart :: (Float, Float) -> (Float, Float)

-- | theta=0 is positive x axis, output angle in radians
cartToPolar :: (Float, Float) -> (Float, Float)

-- | An arrow
arrow :: Point -> Point -> Picture

-- | A think arrow
thickArrow :: Float -> Point -> Point -> Picture

-- | Make a <a>V3</a> object from a <a>Vec</a>.
v3FromVec :: Vec -> V3 Double

-- | Make a <a>V3</a> object from a <a>Position</a>.
v3FromPos :: Position -> V3 Double

-- | A VisObject arrow from a vector
visVec :: Color -> Vec -> VisObject Double

-- | Place a vector at a particular position.
oneVector :: Color -> Position -> Vec -> VisObject Double

-- | Display a vector field.
displayVectorField :: Color -> Double -> [Position] -> VectorField -> VisObject Double

-- | A displayable VisObject for a curve.
curveObject :: Color -> Curve -> VisObject Double
