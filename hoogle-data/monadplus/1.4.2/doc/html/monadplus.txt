-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell98 partial maps and filters over MonadPlus.
--   
--   Filtering and folding over arbitrary <a>MonadPlus</a> instances. This
--   package generalizes many common stream operations such as
--   <a>filter</a>, <a>catMaybes</a> etc.
@package monadplus
@version 1.4.2


-- | Partial maps and filters over <a>MonadPlus</a> instances. The basic
--   idea here is that the monad interface together with the monoidal
--   structure of <a>MonadPlus</a> is enough to implement partial maps and
--   filters (i.e. <a>mmapMaybe</a> and <a>mfilter</a>).
--   
--   This is especially useful for sequential structures such as event
--   lists, tracks etc.
--   
--   Inspired by the following blog post:
--   
--   <ul>
--   <li><a>http://conal.net/blog/posts/a-handy-generalized-filter</a></li>
--   </ul>
module Control.Monad.Plus

-- | This generalizes the list-based <a>concat</a> function.
msum :: MonadPlus m => [m a] -> m a

-- | This generalizes the list-based <a>concat</a> function.
msum' :: (MonadPlus m, Foldable t) => t (m a) -> m a

-- | Fold a value into an arbitrary <a>MonadPlus</a> type.
--   
--   This function generalizes the <a>toList</a> function.
mfold :: (MonadPlus m, Foldable t) => t a -> m a

-- | Translate a list to an arbitrary <a>MonadPlus</a> type.
--   
--   This function generalizes the <a>listToMaybe</a> function.
mfromList :: MonadPlus m => [a] -> m a

-- | Translate maybe to an arbitrary <a>MonadPlus</a> type.
--   
--   This function generalizes the <a>maybeToList</a> function.
mfromMaybe :: MonadPlus m => Maybe a -> m a

-- | Convert a partial function to a function returning an arbitrary
--   <a>MonadPlus</a> type.
mreturn :: MonadPlus m => (a -> Maybe b) -> a -> m b

-- | The <a>partition</a> function takes a predicate a list and returns the
--   pair of lists of elements which do and do not satisfy the predicate,
--   respectively; i.e.,
--   
--   <pre>
--   partition p xs == (filter p xs, filter (not . p) xs)
--   </pre>
--   
--   This function generalizes the <a>partition</a> function.
mpartition :: MonadPlus m => (a -> Bool) -> m a -> (m a, m a)

-- | Join list elements together.
--   
--   This function generalizes the <a>catMaybes</a> function.
mscatter :: MonadPlus m => m [b] -> m b

-- | Join foldable elements together.
--   
--   This function generalizes the <a>catMaybes</a> function.
mscatter' :: (MonadPlus m, Foldable t) => m (t b) -> m b

-- | Pass through <tt>Just</tt> elements.
--   
--   This function generalizes the <a>catMaybes</a> function.
mcatMaybes :: MonadPlus m => m (Maybe a) -> m a

-- | Pass through <tt>Left</tt> elements.
--   
--   This function generalizes the <a>lefts</a> function.
mlefts :: MonadPlus m => m (Either a b) -> m a

-- | Pass through <tt>Right</tt> elements.
--   
--   This function generalizes the <a>rights</a> function.
mrights :: MonadPlus m => m (Either a b) -> m b

-- | Separate <tt>Left</tt> and <tt>Right</tt> elements.
--   
--   This function generalizes the <a>partitionEithers</a> function.
mpartitionEithers :: MonadPlus m => m (Either a b) -> (m a, m b)

-- | Modify or discard a value.
--   
--   This function generalizes the <a>mapMaybe</a> function.
mmapMaybe :: MonadPlus m => (a -> Maybe b) -> m a -> m b

-- | Modify, discard or spawn values.
--   
--   This function generalizes the <a>concatMap</a> function.
mconcatMap :: MonadPlus m => (a -> [b]) -> m a -> m b

-- | Modify, discard or spawn values.
--   
--   This function generalizes the <a>concatMap</a> function.
mconcatMap' :: (MonadPlus m, Foldable t) => (a -> t b) -> m a -> m b

-- | Wrapper for partial functions with <a>MonadPlus</a> instance.
newtype Partial a b
Partial :: (a -> Maybe b) -> Partial a b
getPartial :: Partial a b -> a -> Maybe b

-- | Convert a predicate to a partial function.
partial :: (a -> Bool) -> a -> Maybe a

-- | Convert a partial function to a predicate.
predicate :: (a -> Maybe a) -> a -> Bool

-- | Convert a total function to a partial function.
always :: (a -> b) -> a -> Maybe b

-- | Make a partial function that always rejects its input.
never :: a -> Maybe c
instance Monoid (Partial a b)
instance Alternative (Partial r)
instance Applicative (Partial r)
instance MonadPlus (Partial r)
instance Monad (Partial r)
instance Functor (Partial r)


-- | Partial maps and filters over <a>Alternative</a> instances.
--   
--   This is considerably weaker than <tt>MonadPlus</tt>, as we have no
--   possibility of removing intermediate structure, as in
--   <tt>mcatMaybes</tt>.
module Control.Applicative.Alternative

-- | The sum of a collection of actions, generalizing <a>concat</a>.
asum :: (Foldable t, Alternative f) => t (f a) -> f a

-- | Fold a value into an arbitrary <tt>MonadPlus</tt> type.
--   
--   This function generalizes the <tt>toList</tt> function.
afold :: (Alternative f, Foldable t) => t a -> f a

-- | This function generalizes the <tt>listToMaybe</tt> function.
afromList :: Alternative f => [a] -> f a

-- | Translate maybe to an arbitrary <a>Alternative</a> type.
--   
--   This function generalizes the <tt>maybeToList</tt> function.
afromMaybe :: Alternative f => Maybe a -> f a
