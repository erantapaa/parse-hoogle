-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Leibnizian equality
--   
@package eq
@version 4.0.4


-- | Leibnizian equality. Injectivity in the presence of type families is
--   provided by a generalization of a trick by Oleg Kiselyv posted here:
--   
--   
--   <a>http://www.haskell.org/pipermail/haskell-cafe/2010-May/077177.html</a>
module Data.Eq.Type

-- | Leibnizian equality states that two things are equal if you can
--   substite one for the other in all contexts
data (:=) a b
Refl :: (forall c. c a -> c b) -> (:=) a b
subst :: (:=) a b -> forall c. c a -> c b

-- | Equality is reflexive
refl :: a := a

-- | Equality is transitive
trans :: a := b -> b := c -> a := c

-- | Equality is symmetric
symm :: (a := b) -> (b := a)

-- | If two things are equal you can convert one to the other
coerce :: a := b -> a -> b

-- | You can lift equality into any type constructor
lift :: a := b -> f a := f b

-- | ... in any position
lift2 :: a := b -> f a c := f b c
lift2' :: a := b -> c := d -> f a c := f b d
lift3 :: a := b -> f a c d := f b c d
lift3' :: a := b -> c := d -> e := f -> g a c e := g b d f
instance Groupoid (:=)
instance Semigroupoid (:=)
instance Category (:=)
