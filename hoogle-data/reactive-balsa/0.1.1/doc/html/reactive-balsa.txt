-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Programmatically edit MIDI events via ALSA and reactive-banana
--   
--   MIDI is the Musical Instrument Digital Interface, ALSA is the Advanced
--   Linux Sound Architecture. This package allows to manipulate a sequence
--   of MIDI events via ALSA. It is intended to be plugged as a playing
--   assistant between a MIDI input device (e.g. a keyboard or a controller
--   bank) and a MIDI controlled synthesizer (e.g. a software synthesizer
--   or an external synthesizer). For software synthesizers see the Haskell
--   packages <tt>synthesizer-alsa</tt>, <tt>synthesizer-llvm</tt>,
--   <tt>supercollider-midi</tt>, <tt>hsc3</tt>, <tt>YampaSynth</tt> or the
--   C packages <tt>fluidsynth</tt> and <tt>Timidity</tt>.
--   
--   Applications include: Remapping of channels, controller, instruments,
--   keys, Keyboard splitting, Conversion from notes to controllers, Latch
--   mode, Convert parallel chords to serial patterns, Automated change of
--   MIDI controllers, Delay and echo.
--   
--   It is intended that you write programs for MIDI stream manipulation.
--   It is not intended to provide an executable program with all the
--   functionality available in a custom programming interface. It is most
--   fun to play with the stream editors in GHCi. However we provide an
--   example module that demonstrates various effects.
@package reactive-balsa
@version 0.1.1

module Reactive.Banana.ALSA.Utility
partition :: (a -> Bool) -> Event f a -> (Event f a, Event f a)
mapMaybe :: (a -> Maybe b) -> Event f a -> Event f b
partitionMaybe :: (a -> Maybe b) -> Event f a -> (Event f b, Event f a)
bypass :: (a -> Maybe b) -> (Event f a -> Event f c) -> (Event f b -> Event f c) -> Event f a -> Event f c
traverse :: s -> (a -> State s b) -> Event f a -> (Event f b, Behavior f s)
sequence :: s -> Event f (State s a) -> (Event f a, Behavior f s)

module Reactive.Banana.ALSA.Time

-- | The <a>T</a> types are used instead of floating point types, because
--   the latter ones caused unpredictable 'negative number' errors. The
--   denominator must always be a power of 10, this way we can prevent
--   unlimited grow of denominators.
type Abs = Rational
newtype T
Cons :: Rational -> T
decons :: T -> Rational
cons :: String -> Rational -> T
inc :: T -> Abs -> Abs
subSat :: Abs -> Abs -> T
scale :: Double -> T -> T
scaleCeiling :: Double -> T -> T
scaleInt :: Integral i => i -> T -> T
div :: T -> T -> Double
nano :: Num a => a
fromStamp :: Stamp -> Abs
toStamp :: Abs -> Stamp
fromEvent :: T -> Abs
instance Show T
instance Eq T
instance Ord T
instance C T
instance Monoid T

module Reactive.Banana.ALSA.Common
data Handle
Handle :: T DuplexMode -> T -> T -> T -> T -> Handle
sequ :: Handle -> T DuplexMode
client :: Handle -> T
portPublic :: Handle -> T
portPrivate :: Handle -> T
queue :: Handle -> T
init :: IO Handle
exit :: Handle -> IO ()
with :: ReaderT Handle IO a -> IO a

-- | make ALSA set the time stamps in incoming events
setTimeStamping :: ReaderT Handle IO ()
startQueue :: ReaderT Handle IO ()

-- | Connect ourselve to an input client and an output client. The function
--   expects a list of alternative clients that are checked successively.
connect :: [String] -> [String] -> ReaderT Handle IO ()
connectFrom :: T -> ReaderT Handle IO T
connectTo :: T -> ReaderT Handle IO T
timidity :: String
haskellSynth :: String
inputs :: [String]
outputs :: [String]
connectTimidity :: ReaderT Handle IO ()
connectLLVM :: ReaderT Handle IO ()
connectAny :: ReaderT Handle IO ()
parseAddresses :: [String] -> ReaderT Handle IO T
sendNote :: Channel -> T -> Velocity -> Pitch -> ReaderT Handle IO ()
sendKey :: Channel -> Bool -> Velocity -> Pitch -> ReaderT Handle IO ()
sendController :: Channel -> Controller -> Int -> ReaderT Handle IO ()
sendProgram :: Channel -> Program -> ReaderT Handle IO ()
sendMode :: Channel -> T -> ReaderT Handle IO ()
channel :: Int -> Channel
pitch :: Int -> Pitch
velocity :: Int -> Velocity
controller :: Int -> Controller
program :: Int -> Program
normalVelocity :: Velocity
defaultTempoCtrl :: (Channel, Controller)

-- | This class unifies several ways of handling multiple events at once.
class Events ev
flattenEvents :: Events ev => ev -> [Future Data]
makeEvent :: Handle -> Abs -> Data -> T
makeEcho :: Handle -> Abs -> T
outputEvent :: Abs -> Data -> ReaderT Handle IO ()
simpleNote :: Channel -> Pitch -> Velocity -> Note

-- | The times are relative to the start time of the bundle and do not need
--   to be ordered.
data Future a
Future :: T -> a -> Future a
futureTime :: Future a -> T
futureData :: Future a -> a
type Bundle a = [Future a]
type EventBundle = Bundle T
type EventDataBundle = Bundle Data
singletonBundle :: a -> Bundle a
immediateBundle :: [a] -> Bundle a
now :: a -> Future a

-- | Transpose a note event by the given number of semitones. Non-note
--   events are returned without modification. If by transposition a note
--   leaves the range of representable MIDI notes, then we return Nothing.
transpose :: Int -> Data -> Maybe Data

-- | Swap order of keys. Non-note events are returned without modification.
--   If by reversing a note leaves the range of representable MIDI notes,
--   then we return Nothing.
reverse :: Data -> Maybe Data
setChannel :: Channel -> Data -> Data

-- | <pre>
--   &gt; replaceProgram [1,2,3,4] 5 [10,11,12,13]
--   (True,[10,11,2,13])
--   </pre>
replaceProgram :: Real i => [i] -> i -> [i] -> (Bool, [i])
programFromBanks :: Real i => [i] -> [i] -> i

-- | Interpret program changes as a kind of bank switches in order to
--   increase the range of instruments that can be selected via a block of
--   patch select buttons.
--   
--   <tt>programAsBanks ns</tt> divides the first <tt>sum ns</tt>
--   instruments into sections of sizes <tt>ns!!0, ns!!1, ...</tt>. Each
--   program in those sections is interpreted as a bank in a hierarchy,
--   where the lower program numbers are the least significant banks.
--   Programs from <tt>sum ns</tt> on are passed through as they are.
--   <tt>product ns</tt> is the number of instruments that you can address
--   using this trick. In order to avoid overflow it should be less than
--   128.
--   
--   E.g. <tt>programAsBanks [n,m]</tt> interprets subsequent program
--   changes to <tt>a</tt> (<tt>0&lt;=a&lt;n</tt>) and <tt>n+b</tt>
--   (<tt>0&lt;=b&lt;m</tt>) as a program change to <tt>b*n+a</tt>.
--   <tt>programAsBanks [8,8]</tt> allows to select 64 instruments by 16
--   program change buttons, whereas <tt>programAsBanks [8,4,4]</tt> allows
--   to address the full range of MIDI 128 instruments with the same number
--   of buttons.
programsAsBanks :: [Int] -> Data -> State [Int] Data
nextProgram :: Note -> State [Program] (Maybe Data)
seekProgram :: Int -> Program -> State [Program] (Maybe Data)

-- | Before every note switch to another instrument according to a list of
--   programs given as state of the State monad. I do not know how to
--   handle multiple channels in a reasonable way. Currently I just switch
--   the instrument independent from the channel, and send the program
--   switch to the same channel as the beginning note.
traversePrograms :: Data -> State [Program] (Maybe Data)

-- | This function extends <a>traversePrograms</a>. It reacts on external
--   program changes by seeking an according program in the list. This way
--   we can reset the pointer into the instrument list. However the search
--   must be limited in order to prevent an infinite loop if we receive a
--   program that is not contained in the list.
traverseProgramsSeek :: Int -> Data -> State [Program] (Maybe Data)
reduceNoteVelocity :: Velocity -> Note -> Note
delayAdd :: Velocity -> T -> Data -> EventDataBundle

-- | Map NoteOn events to a controller value. This way you may play notes
--   via the resonance frequency of a filter.
controllerFromNote :: (Int -> Int) -> Controller -> Data -> Maybe Data
type KeySet = Map (Pitch, Channel) Velocity
type KeyQueue = [((Pitch, Channel), Velocity)]
eventsFromKey :: T -> T -> ((Pitch, Channel), Velocity) -> EventDataBundle
maybePitch :: Int -> Maybe Pitch
increasePitch :: Int -> Pitch -> Maybe Pitch
subtractPitch :: Pitch -> Pitch -> Int

-- | properFraction is useless for negative numbers
splitFraction :: RealFrac a => a -> (Int, a)
fraction :: RealFrac a => a -> a
ctrlDur :: (T, T) -> Int -> T
ctrlDurLinear :: (T, T) -> Int -> T
ctrlDurExponential :: (T, T) -> Int -> T
controllerMatch :: Channel -> Controller -> Ctrl -> Bool
checkChannel :: (Channel -> Bool) -> (Data -> Bool)
checkPitch :: (Pitch -> Bool) -> (Data -> Bool)
checkController :: (Controller -> Bool) -> (Data -> Bool)
checkMode :: (T -> Bool) -> (Data -> Bool)
checkProgram :: (Program -> Bool) -> (Data -> Bool)
isAllNotesOff :: Data -> Bool
data NoteBoundary
NoteBoundary :: (Pitch, Channel) -> Velocity -> Bool -> NoteBoundary
data NoteBoundaryExt
NoteBoundaryExt :: NoteBoundary -> NoteBoundaryExt
AllNotesOff :: NoteBoundaryExt
maybeNote :: Data -> Maybe NoteBoundary
maybeNoteExt :: Data -> Maybe NoteBoundaryExt
noteFromBnd :: NoteBoundary -> Data
mergeStable :: C time => T time body -> T time body -> T time body
mergeEither :: C time => T time a -> T time b -> T time (Either a b)
instance Eq NoteBoundary
instance Show NoteBoundary
instance Eq NoteBoundaryExt
instance Show NoteBoundaryExt
instance Functor Future
instance (Events ev0, Events ev1, Events ev2) => Events (ev0, ev1, ev2)
instance (Events ev0, Events ev1) => Events (ev0, ev1)
instance Events ev => Events [ev]
instance Events ev => Events (Maybe ev)
instance Events ev => Events (Future ev)
instance Events NoteBoundary
instance Events Data

module Reactive.Banana.ALSA.Guitar
class Transpose pitch
getPitch :: Transpose pitch => pitch -> Pitch
transpose :: Transpose pitch => Int -> pitch -> Maybe pitch
mapChordToString :: (Transpose pitch, Ord pitch) => [Pitch] -> [pitch] -> [pitch]
choosePitchForString :: (Transpose pitch, Ord pitch) => [pitch] -> Pitch -> Maybe pitch
stringPitches :: [Pitch]
instance Transpose Pitch

module Reactive.Banana.ALSA.KeySet
class C set
reset :: C set => State set [NoteBoundary]
size :: C set => set -> Int
toList :: C set => set -> [((Pitch, Channel), Velocity)]
index :: C set => Int -> set -> Maybe ((Pitch, Channel), Velocity)
change :: C set => NoteBoundary -> State set [NoteBoundary]
newtype Pressed
Pressed :: Map (Pitch, Channel) Velocity -> Pressed
deconsPressed :: Pressed -> Map (Pitch, Channel) Velocity
pressed :: Pressed
pressedAcc :: T Pressed (Map (Pitch, Channel) Velocity)
newtype Latch
Latch :: Map (Pitch, Channel) Velocity -> Latch
deconsLatch :: Latch -> Map (Pitch, Channel) Velocity
latch :: Latch
latchAcc :: T Latch (Map (Pitch, Channel) Velocity)
latchChange :: NoteBoundary -> State Latch (Maybe NoteBoundary)
data GroupLatch
GroupLatch :: Set (Pitch, Channel) -> Map (Pitch, Channel) Velocity -> GroupLatch
groupLatchPressed_ :: GroupLatch -> Set (Pitch, Channel)
groupLatchPlayed_ :: GroupLatch -> Map (Pitch, Channel) Velocity
groupLatch :: GroupLatch
groupLatchPressed :: T GroupLatch (Set (Pitch, Channel))
groupLatchPlayed :: T GroupLatch (Map (Pitch, Channel) Velocity)
data SerialLatch
SerialLatch :: Int -> Int -> Map Int ((Pitch, Channel), Velocity) -> SerialLatch
serialLatchSize_ :: SerialLatch -> Int
serialLatchCursor_ :: SerialLatch -> Int
serialLatchPlayed_ :: SerialLatch -> Map Int ((Pitch, Channel), Velocity)
serialLatch :: Int -> SerialLatch
serialLatchCursor :: T SerialLatch Int
serialLatchPlayed :: T SerialLatch (Map Int ((Pitch, Channel), Velocity))
releasePlayedKeys :: State (Map (Pitch, Channel) Velocity) [NoteBoundary]
releaseKey :: (Pitch, Channel) -> Velocity -> NoteBoundary
instance Show Pressed
instance Show Latch
instance Show GroupLatch
instance Show SerialLatch
instance C SerialLatch
instance C GroupLatch
instance C Latch
instance C Pressed

module Reactive.Banana.ALSA.Training
all :: RandomGen g => g -> [([Pitch], [Pitch])]

-- | intervals within an octave, all starting with a C
intervals :: RandomGen g => g -> [([Pitch], [Pitch])]

-- | choose two arbitrary notes from an increasing set of notes
twoNotes :: RandomGen g => g -> [([Pitch], [Pitch])]

-- | choose three arbitrary notes from an increasing set of notes
threeNotes :: RandomGen g => g -> [([Pitch], [Pitch])]
reverseThreeNotes :: RandomGen g => g -> [([Pitch], [Pitch])]
sortThreeNotes :: RandomGen g => g -> [([Pitch], [Pitch])]

-- | transpose an interval to begin with C
transposeTwoNotes :: RandomGen g => g -> [([Pitch], [Pitch])]

module Reactive.Banana.ALSA.Pattern
type T t time set = Behavior t set -> Event t time -> Event t [NoteBoundary]
mono :: C set => Selector set i -> Behavior t set -> Event t i -> Event t [NoteBoundary]
poly :: C set => Selector set i -> Behavior t set -> Event t [IndexNote i] -> Event t [NoteBoundary]
type Selector set i = i -> set -> [((Pitch, Channel), Velocity)]
data IndexNote i
IndexNote :: Int -> i -> IndexNote i
item :: i -> Int -> IndexNote i
data Poly set i
Poly :: (Selector set i) -> (T Int [IndexNote i]) -> Poly set i

-- | Generate notes according to the key set, where notes for negative and
--   too large indices are padded with keys that are transposed by octaves.
selectFromOctaveChord :: C set => Selector set Int
selectFromChord :: C set => Selector set Int
selectFromChordRatio :: C set => Selector set Double
selectInversion :: C set => Selector set Double

-- | See Haskore/FlipSong
--   
--   flipSeq m !! n = cross sum of the m-ary representation of n modulo m.
--   
--   For m=2 this yields
--   http:<i></i>www.research.att.com<i>cgi-bin</i>access.cgi<i>as</i>njas<i>sequences</i>eisA.cgi?Anum=A010060
flipSeq :: Int -> [Int]
cycleUpIndex :: Behavior t Int -> Event t time -> Event t Int
pingPongIndex :: Behavior t Int -> Event t time -> Event t Int
cycleDownIndex :: Behavior t Int -> Event t time -> Event t Int
crossSumIndex :: Behavior t Int -> Event t time -> Event t Int
crossSumStaticIndex :: Int -> Event t time -> Event t Int
fromList :: [a] -> Event t time -> Event t a
cycleUp :: C set => Behavior t Int -> T t time set
crossSum :: C set => Behavior t Int -> T t time set
pingPong :: C set => Behavior t Int -> T t time set
cycleDown :: C set => Behavior t Int -> T t time set
bruijn :: C set => Int -> Int -> T t time set
binaryStaccato :: C set => T t time set
binaryAccident :: C set => T t time set
binaryLegato :: C set => T t time set
decomposePositional :: Integer -> Integer -> [Integer]
cycleUpOctave :: C set => Behavior t Int -> T t time set
random :: C set => T t time set
randomInversions :: C set => T t time set
cycleUpInversions :: C set => Int -> T t time set
inversions :: C set => [Double] -> T t time set
examplePolyTempo0 :: T Int [IndexNote Int]
examplePolyTempo1 :: T Int [IndexNote Int]
instance Show i => Show (IndexNote i)
instance Eq i => Eq (IndexNote i)
instance Ord i => Ord (IndexNote i)
instance Traversable IndexNote
instance Foldable IndexNote
instance Functor IndexNote

module Reactive.Banana.ALSA.Sequencer
newtype Reactor t a
Reactor :: ReaderT (AddHandler T, Handle) (StateT Schedule (Moment t)) a -> Reactor t a
runReactor :: Reactor t a -> ReaderT (AddHandler T, Handle) (StateT Schedule (Moment t)) a
liftNetworkDescription :: Moment t a -> Reactor t a
type Schedule = Tag
startSchedule :: Schedule
nextSchedule :: Schedule -> Schedule
getHandle :: Reactor t Handle
run :: Events ev => (forall t. Frameworks t => Event t Data -> Event t ev) -> ReaderT Handle IO ()
runM :: Events ev => (forall t. Frameworks t => Behavior t Abs -> Event t Data -> Reactor t (Event t ev)) -> ReaderT Handle IO ()
outputEvents :: Events evs => Handle -> Abs -> evs -> IO ()
checkSchedule :: Schedule -> T -> Bool
reactimate :: Frameworks t => Event t (IO ()) -> Reactor t ()
sendEchos :: Handle -> Schedule -> [Abs] -> IO ()
cancelEchos :: Handle -> Schedule -> IO ()
reserveSchedule :: Frameworks t => Reactor t (Event t Abs, [Abs] -> IO (), IO ())
scheduleQueue :: (Frameworks t, Show a) => Behavior t Abs -> Event t (Bundle a) -> Reactor t (Event t a)
debug :: String -> IO ()
bypass :: (Events a, Events c) => (a -> Maybe b) -> (Event f b -> Event f c) -> Event f a -> Event f [Future Data]

-- | register pressed keys
pressed :: C set => set -> Event f NoteBoundaryExt -> (Event f [NoteBoundary], Behavior f set)
latch :: Event f NoteBoundary -> (Event f NoteBoundary, Behavior f (Map (Pitch, Channel) Velocity))

-- | Demonstration of scheduleQueue, but for real use prefer <a>delay</a>,
--   since this uses precisely timed delivery by ALSA.
delaySchedule :: Frameworks t => T -> Behavior t Abs -> Event t Data -> Reactor t (Event t Data)
delay :: T -> Event t ev -> Event t (Future ev)
delayAdd :: T -> Event t ev -> Event t (Future ev)

-- | Generate a beat according to the tempo control. The input signal
--   specifies the period between two beats. The output events hold the
--   times, where they occur.
beat :: Frameworks t => Behavior t T -> Reactor t (Event t Abs)

-- | Similar to <a>beat</a> but warrants a maximum reaction time to tempo
--   changes. This way you can alter slow tempos to faster one more
--   quickly.
beatQuant :: Frameworks t => T -> Behavior t T -> Reactor t (Event t Abs)

-- | Similar to <a>beat</a> but it reacts immediately to tempo changes.
--   This requires the ability of ALSA to cancel sent Echo messages and it
--   requires to know the precise time points of tempo changes, thus we
--   need the Discrete input instead of Behaviour and we need a behaviour
--   for the current time.
beatVar :: Frameworks t => Behavior t Abs -> Behavior t T -> Reactor t (Event t Abs)
tempoCtrl :: C ev => Channel -> Controller -> T -> (T, T) -> Event t ev -> (Behavior t T, Event t ev)
controllerRaw :: C ev => Channel -> Controller -> Int -> Event t ev -> Behavior t Int
controllerExponential :: (Floating a, C ev) => Channel -> Controller -> a -> (a, a) -> Event t ev -> Behavior t a
controllerLinear :: (Fractional a, C ev) => Channel -> Controller -> a -> (a, a) -> Event t ev -> Behavior t a
cyclePrograms :: [Program] -> Event t Data -> Event t (Maybe Data)

-- | <pre>
--   cycleProgramsDefer t
--   </pre>
--   
--   After a note that triggers a program change, we won't change the
--   program in the next <tt>t</tt> seconds. This is in order to allow
--   chords being played and in order to skip accidentally played notes.
cycleProgramsDefer :: T -> [Program] -> Behavior t Abs -> Event t Data -> Event t (Maybe Data)
newtype PitchChannel
PitchChannel :: ((Pitch, Channel), Velocity) -> PitchChannel
noteSequence :: T -> NoteEv -> [Note] -> EventDataBundle

-- | This process simulates playing chords on a guitar. If you press some
--   keys like C, E, G on the keyboard, then this process figures out what
--   tones would be played on a guitar.
--   
--   Call it like <tt>guitar stepTime chords triggers</tt>.
--   
--   <tt>stepTime</tt> is the delay between to successive notes. A good
--   value is 0.03 (seconds). The chords to be played are passed in by
--   <tt>chords</tt>. This should be the output of <a>pressed</a>. Further
--   on the function needs events that trigger playing the chord in
--   <tt>trigger</tt> argument. The trigger consists of the trigger time
--   and the direction to be played (<a>True</a> = down from high to low
--   pitches, <a>False</a> = up from low to high pitches). The trigger may
--   be derived from a specific key that is pressed and released, or two
--   keys, one for each direction.
guitar :: C set => T -> Behavior t set -> Event t Bool -> Event t EventDataBundle

-- | Audio perception trainer
--   
--   Play sets of notes and let the human player answer to them according
--   to a given scheme. Repeat playing the notes sets until the trainee
--   answers correctly. Then continue with other sequences, maybe more
--   complicated ones.
--   
--   possible tasks:
--   
--   <ul>
--   <li>replay a RBU.sequence of pitches on the keyboard: single notes for
--   training abolute pitches, intervals all with the same base notes,
--   intervals with different base notes</li>
--   <li>transpose a set of pitches: tranpose to a certain base note,
--   transpose by a certain interval</li>
--   <li>play a set of pitches in a different order: reversed order, in
--   increasing pitch</li>
--   <li>replay a set of simultaneously pressed keys</li>
--   </ul>
--   
--   The difficulty can be increased by not connecting the keyboard
--   directly with the sound generator. This way, the trainee cannot
--   verify, how the pressed keys differ from the target keys.
--   
--   Sometimes it seems that you are catched in an infinite loop. This
--   happens if there were too many keys pressed. The trainer collects all
--   key press events, not only the ones that occur after the target set is
--   played. This way you can correct yourself immediately, before the
--   target is repeatedly played. The downside is, that there may be key
--   press events hanging around. You can get rid of them by pressing a key
--   again and again, but slowly, until the target is played, again. Then
--   the queue of registered keys should be empty and you can proceed
--   training.
trainer :: Frameworks t => Channel -> T -> T -> [([Pitch], [Pitch])] -> Behavior t Abs -> Event t Data -> Reactor t (Event t EventDataBundle)
sweep :: Frameworks t => T -> (Double -> Double) -> Behavior t Double -> Reactor t (Event t Abs, Behavior t Double)
makeControllerLinear :: Channel -> Controller -> Behavior t Int -> Behavior t Int -> Event t Abs -> Behavior t Double -> Event t Data

-- | Use a MIDI controller for selecting a note from a key set. Only the
--   pitch class of the keys is respected. The controller behavior must be
--   in the range 0-127. This way, it accesses the whole range of MIDI
--   notes. The output note is stopped and a new note is played whenever
--   turning the knob alters the note pitch. The advantage of the effect is
--   that the pitch range of the knob does not depend on the number of
--   pressed keys. The disadvantage is that there a distinct distances
--   between the pitches.
snapSelect :: (Frameworks t, C set) => Behavior t set -> Behavior t Int -> Reactor t (Event t [Data])
transposeToClosestOctave :: Int -> Pitch -> Pitch
uniqueChanges :: (Frameworks t, Eq a) => Behavior t a -> Reactor t (Event t a)
instance Functor (Reactor t)
instance Applicative (Reactor t)
instance Monad (Reactor t)
instance Frameworks t => MonadIO (Reactor t)
instance MonadFix (Reactor t)
instance Show PitchChannel
instance Transpose PitchChannel
instance Ord PitchChannel
instance Eq PitchChannel

module Reactive.Banana.ALSA.Example
run :: ReaderT Handle IO a -> IO a
runTimidity :: ReaderT Handle IO a -> IO a
runLLVM :: ReaderT Handle IO a -> IO a
pass :: ReaderT Handle IO ()
continuousSelect :: ReaderT Handle IO ()
snapSelect :: ReaderT Handle IO ()
guitar :: ReaderT Handle IO ()
sweep :: ReaderT Handle IO ()
cyclePrograms :: ReaderT Handle IO ()
splitPattern :: ReaderT Handle IO ()
split :: ReaderT Handle IO ()
serialCycleUp :: ReaderT Handle IO ()
randomInversions :: ReaderT Handle IO ()
random :: ReaderT Handle IO ()
bruijn :: ReaderT Handle IO ()
crossSum :: ReaderT Handle IO ()
binary :: ReaderT Handle IO ()
pingPongAuto :: ReaderT Handle IO ()
pingPong :: ReaderT Handle IO ()
cycleUpAuto :: ReaderT Handle IO ()
cycleUp :: ReaderT Handle IO ()
delayTranspose :: ReaderT Handle IO ()
delayAdd :: ReaderT Handle IO ()
delay :: ReaderT Handle IO ()
groupLatch :: ReaderT Handle IO ()
latch :: ReaderT Handle IO ()
reverse :: ReaderT Handle IO ()
transpose :: ReaderT Handle IO ()
time :: Rational -> T
getTempo :: C ev => Event t ev -> (Behavior t T, Event t ev)
pattern :: C set => set -> (forall t. Frameworks t => Behavior t set -> Event t Abs -> Event t [NoteBoundary]) -> ReaderT Handle IO ()
cycleUpOffset :: ReaderT Handle IO ()
trainer :: RandomGen g => g -> ReaderT Handle IO ()
