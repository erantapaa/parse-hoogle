-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Reliable, high-performance processing with left-fold enumerators
--   
--   Typical buffer–based incremental I/O is based around a single loop,
--   which reads data from some source (such as a socket or file),
--   transforms it, and generates one or more outputs (such as a line
--   count, HTTP responses, or modified file). Although efficient and safe,
--   these loops are all single–purpose; it is difficult or impossible to
--   compose buffer–based processing loops.
--   
--   Haskell’s concept of “lazy I/O” allows pure code to operate on data
--   from an external source. However, lazy I/O has several shortcomings.
--   Most notably, resources such as memory and file handles can be
--   retained for arbitrarily long periods of time, causing unpredictable
--   performance and error conditions.
--   
--   Enumerators are an efficient, predictable, and safe alternative to
--   lazy I/O. Discovered by Oleg Kiselyov, they allow large datasets to be
--   processed in near–constant space by pure code. Although somewhat more
--   complex to write, using enumerators instead of lazy I/O produces more
--   correct programs.
--   
--   This library contains an enumerator implementation for Haskell,
--   designed to be both simple and efficient. Three core types are
--   defined, along with numerous helper functions:
--   
--   <ul>
--   <li><i>Iteratee</i>: Data sinks, analogous to left folds. Iteratees
--   consume a sequence of <i>input</i> values, and generate a single
--   <i>output</i> value. Many iteratees are designed to perform side
--   effects (such as printing to <tt>stdout</tt>), so they can also be
--   used as monad transformers.</li>
--   <li><i>Enumerator</i>: Data sources, which generate input sequences.
--   Typical enumerators read from a file handle, socket, random number
--   generator, or other external stream. To operate, enumerators are
--   passed an iteratee, and provide that iteratee with input until either
--   the iteratee has completed its computation, or EOF.</li>
--   <li><i>Enumeratee</i>: Data transformers, which operate as both
--   enumerators and iteratees. Enumeratees read from an <i>outer</i>
--   enumerator, and provide the transformed data to an <i>inner</i>
--   iteratee.</li>
--   </ul>
@package enumerator
@version 0.4.19


-- | Core enumerator types, and some useful primitives.
--   
--   Be careful when using the functions defined in this module, as they
--   will allow you to create iteratees which violate the monad laws.
module Data.Enumerator.Internal

-- | A <a>Stream</a> is a sequence of chunks generated by an
--   <a>Enumerator</a>.
--   
--   <tt>(<a>Chunks</a> [])</tt> is used to indicate that a stream is still
--   active, but currently has no available data. Iteratees should ignore
--   empty chunks.
data Stream a
Chunks :: [a] -> Stream a
EOF :: Stream a

-- | The primary data type for this library; an iteratee consumes chunks of
--   input from a stream until it either yields a value or encounters an
--   error.
--   
--   Compatibility note: <tt>Iteratee</tt> will become abstract in
--   <tt>enumerator_0.5</tt>. If you depend on internal implementation
--   details, please import <tt><a>Data.Enumerator.Internal</a></tt>.
newtype Iteratee a m b
Iteratee :: m (Step a m b) -> Iteratee a m b
runIteratee :: Iteratee a m b -> m (Step a m b)
data Step a m b

-- | The <a>Iteratee</a> is capable of accepting more input. Note that more
--   input is not necessarily required; the <a>Iteratee</a> might be able
--   to generate a value immediately if it receives <a>EOF</a>.
Continue :: (Stream a -> Iteratee a m b) -> Step a m b

-- | The <a>Iteratee</a> cannot receive any more input, and has generated a
--   result. Included in this value is left-over input, which can be passed
--   to composed <a>Iteratee</a>s.
Yield :: b -> (Stream a) -> Step a m b

-- | The <a>Iteratee</a> encountered an error which prevents it from
--   proceeding further.
Error :: SomeException -> Step a m b

-- | Enumerators are sources of data, to be consumed by iteratees.
--   Enumerators typically read from an external source (parser, handle,
--   random generator, etc), then feed chunks into an tteratee until:
--   
--   <ul>
--   <li>The input source runs out of data.</li>
--   <li>The iteratee yields a result value.</li>
--   <li>The iteratee throws an exception.</li>
--   </ul>
type Enumerator a m b = Step a m b -> Iteratee a m b

-- | An enumeratee acts as a stream adapter; place one between an
--   enumerator and an iteratee, and it changes the type or contents of the
--   input stream.
--   
--   Most users will want to combine enumerators, enumeratees, and
--   iteratees using the stream combinators <tt>joinI</tt> and
--   <tt>joinE</tt>, or their operator aliases <tt>(=$)</tt> and
--   <tt>($=)</tt>. These combinators are used to manage how left-over
--   input is passed between elements of the data processing pipeline.
type Enumeratee ao ai m b = Step ai m b -> Iteratee ao m (Step ai m b)

-- | <pre>
--   <a>returnI</a> step = <a>Iteratee</a> (return step)
--   </pre>
returnI :: Monad m => Step a m b -> Iteratee a m b

-- | <pre>
--   <a>continue</a> k = <a>returnI</a> (<a>Continue</a> k)
--   </pre>
continue :: Monad m => (Stream a -> Iteratee a m b) -> Iteratee a m b

-- | <pre>
--   <a>yield</a> x extra = <a>returnI</a> (<a>Yield</a> x extra)
--   </pre>
--   
--   WARNING: due to the current encoding of iteratees in this library,
--   careless use of the <a>yield</a> primitive may violate the monad laws.
--   To prevent this, always make sure that an iteratee never yields extra
--   data unless it has received at least one input element.
--   
--   More strictly, iteratees may not yield data that they did not receive
--   as input. Don't use <a>yield</a> to “inject” elements into the stream.
yield :: Monad m => b -> Stream a -> Iteratee a m b

-- | The most primitive stream operator. <tt>iter &gt;&gt;== enum</tt>
--   returns a new iteratee which will read from <tt>enum</tt> before
--   continuing.
(>>==) :: Monad m => Iteratee a m b -> (Step a m b -> Iteratee a' m b') -> Iteratee a' m b'

-- | <pre>
--   (<a>==&lt;&lt;</a>) = flip (<a>&gt;&gt;==</a>)
--   </pre>
(==<<) :: Monad m => (Step a m b -> Iteratee a' m b') -> Iteratee a m b -> Iteratee a' m b'

-- | <pre>
--   (<a>$$</a>) = (<a>==&lt;&lt;</a>)
--   </pre>
--   
--   This is somewhat easier to read when constructing an iteratee from
--   many processing stages. You can treat it like <tt>(<a>$</a>)</tt>, and
--   read the data flow from left to right.
--   
--   Since: 0.1.1
($$) :: Monad m => (Step a m b -> Iteratee a' m b') -> Iteratee a m b -> Iteratee a' m b'

-- | <pre>
--   (<a>&gt;==&gt;</a>) enum1 enum2 step = enum1 step <a>&gt;&gt;==</a> enum2
--   </pre>
--   
--   The moral equivalent of <tt>(<a>&gt;=&gt;</a>)</tt> for iteratees.
--   
--   Since: 0.1.1
(>==>) :: Monad m => Enumerator a m b -> (Step a m b -> Iteratee a' m b') -> Step a m b -> Iteratee a' m b'

-- | <pre>
--   (<a>&lt;==&lt;</a>) = flip (<a>&gt;==&gt;</a>)
--   </pre>
--   
--   Since: 0.1.1
(<==<) :: Monad m => (Step a m b -> Iteratee a' m b') -> Enumerator a m b -> Step a m b -> Iteratee a' m b'

-- | Sends <a>EOF</a> to its iteratee. Most clients should use <tt>run</tt>
--   or <tt>run_</tt> instead.
enumEOF :: Monad m => Enumerator a m b

-- | A common pattern in <a>Enumerator</a> implementations is to check
--   whether the inner <a>Iteratee</a> has finished, and if so, to return
--   its output. <a>checkContinue0</a> passes its parameter a continuation
--   if the <a>Iteratee</a> can still consume input; if not, it returns the
--   iteratee's step.
--   
--   The type signature here is a bit crazy, but it's actually very easy to
--   use. Take this code:
--   
--   <pre>
--   repeat :: Monad m =&gt; a -&gt; Enumerator a m b
--   repeat x = loop where
--   	loop (Continue k) = k (Chunks [x]) &gt;&gt;== loop
--   	loop step = returnI step
--   </pre>
--   
--   And rewrite it without the boilerplate:
--   
--   <pre>
--   repeat :: Monad m =&gt; a -&gt; Enumerator a m b
--   repeat x = checkContinue0 $ \loop k -&gt; k (Chunks [x] &gt;&gt;== loop
--   </pre>
--   
--   Since: 0.4.9
checkContinue0 :: Monad m => (Enumerator a m b -> (Stream a -> Iteratee a m b) -> Iteratee a m b) -> Enumerator a m b

-- | Like <a>checkContinue0</a>, but allows each loop step to use a state
--   value:
--   
--   <pre>
--   iterate :: Monad m =&gt; (a -&gt; a) -&gt; a -&gt; Enumerator a m b
--   iterate f = checkContinue1 $ \loop a k -&gt; k (Chunks [a]) &gt;&gt;== loop (f a)
--   </pre>
--   
--   Since: 0.4.9
checkContinue1 :: Monad m => ((s1 -> Enumerator a m b) -> s1 -> (Stream a -> Iteratee a m b) -> Iteratee a m b) -> s1 -> Enumerator a m b

-- | A common pattern in <a>Enumeratee</a> implementations is to check
--   whether the inner <a>Iteratee</a> has finished, and if so, to return
--   its output. <a>checkDone</a> passes its parameter a continuation if
--   the <a>Iteratee</a> can still consume input, or yields otherwise.
--   
--   Since: 0.4.3
checkDoneEx :: Monad m => Stream a' -> ((Stream a -> Iteratee a m b) -> Iteratee a' m (Step a m b)) -> Enumeratee a' a m b

-- | <pre>
--   <a>checkDone</a> = <a>checkDoneEx</a> (<a>Chunks</a> [])
--   </pre>
--   
--   Use this for enumeratees which do not have an input buffer.
checkDone :: Monad m => ((Stream a -> Iteratee a m b) -> Iteratee a' m (Step a m b)) -> Enumeratee a' a m b
instance Show a => Show (Stream a)
instance Eq a => Eq (Stream a)
instance Applicative Stream
instance Functor Stream
instance Monad m => Applicative (Iteratee a m)
instance Monad m => Functor (Iteratee a m)
instance (Typeable a, Typeable1 m) => Typeable1 (Step a m)
instance (Typeable a, Typeable1 m) => Typeable1 (Iteratee a m)
instance Typeable1 Stream
instance MonadIO m => MonadIO (Iteratee a m)
instance MonadTrans (Iteratee a)
instance Monad m => Monad (Iteratee a m)
instance Monoid (Stream a)
instance Monad Stream


-- | For compatibility reasons, this module should imported qualified:
--   
--   <pre>
--   import qualified Data.Enumerator as E
--   </pre>
module Data.Enumerator

-- | The primary data type for this library; an iteratee consumes chunks of
--   input from a stream until it either yields a value or encounters an
--   error.
--   
--   Compatibility note: <tt>Iteratee</tt> will become abstract in
--   <tt>enumerator_0.5</tt>. If you depend on internal implementation
--   details, please import <tt><a>Data.Enumerator.Internal</a></tt>.
newtype Iteratee a m b
Iteratee :: m (Step a m b) -> Iteratee a m b
runIteratee :: Iteratee a m b -> m (Step a m b)

-- | Enumerators are sources of data, to be consumed by iteratees.
--   Enumerators typically read from an external source (parser, handle,
--   random generator, etc), then feed chunks into an tteratee until:
--   
--   <ul>
--   <li>The input source runs out of data.</li>
--   <li>The iteratee yields a result value.</li>
--   <li>The iteratee throws an exception.</li>
--   </ul>
type Enumerator a m b = Step a m b -> Iteratee a m b

-- | An enumeratee acts as a stream adapter; place one between an
--   enumerator and an iteratee, and it changes the type or contents of the
--   input stream.
--   
--   Most users will want to combine enumerators, enumeratees, and
--   iteratees using the stream combinators <tt>joinI</tt> and
--   <tt>joinE</tt>, or their operator aliases <tt>(=$)</tt> and
--   <tt>($=)</tt>. These combinators are used to manage how left-over
--   input is passed between elements of the data processing pipeline.
type Enumeratee ao ai m b = Step ai m b -> Iteratee ao m (Step ai m b)

-- | Run an iteratee until it finishes, and return either the final value
--   (if it succeeded) or the error (if it failed).
--   
--   <pre>
--   import Data.Enumerator
--   import Data.Enumerator.List as EL
--   
--   main = do
--       result &lt;- run (EL.iterate succ 'A' $$ EL.take 5)
--       case result of
--           Left exc -&gt; putStrLn ("Got an exception: " ++ show exc)
--           Right chars -&gt; putStrLn ("Got characters: " ++ show chars)
--   </pre>
run :: Monad m => Iteratee a m b -> m (Either SomeException b)

-- | Like <a>run</a>, except errors are converted to exceptions and thrown.
--   Primarily useful for small scripts or other simple cases.
--   
--   <pre>
--   import Data.Enumerator
--   import Data.Enumerator.List as EL
--   
--   main = do
--       chars &lt;- run_ (EL.iterate succ 'A' $$ EL.take 5)
--       putStrLn ("Got characters: " ++ show chars)
--   </pre>
--   
--   Since: 0.4.1
run_ :: Monad m => Iteratee a m b -> m b

-- | The most primitive stream operator. <tt>iter &gt;&gt;== enum</tt>
--   returns a new iteratee which will read from <tt>enum</tt> before
--   continuing.
(>>==) :: Monad m => Iteratee a m b -> (Step a m b -> Iteratee a' m b') -> Iteratee a' m b'

-- | <pre>
--   (<a>==&lt;&lt;</a>) = flip (<a>&gt;&gt;==</a>)
--   </pre>
(==<<) :: Monad m => (Step a m b -> Iteratee a' m b') -> Iteratee a m b -> Iteratee a' m b'

-- | <pre>
--   (<a>$$</a>) = (<a>==&lt;&lt;</a>)
--   </pre>
--   
--   This is somewhat easier to read when constructing an iteratee from
--   many processing stages. You can treat it like <tt>(<a>$</a>)</tt>, and
--   read the data flow from left to right.
--   
--   Since: 0.1.1
($$) :: Monad m => (Step a m b -> Iteratee a' m b') -> Iteratee a m b -> Iteratee a' m b'

-- | <pre>
--   (<a>&gt;==&gt;</a>) enum1 enum2 step = enum1 step <a>&gt;&gt;==</a> enum2
--   </pre>
--   
--   The moral equivalent of <tt>(<a>&gt;=&gt;</a>)</tt> for iteratees.
--   
--   Since: 0.1.1
(>==>) :: Monad m => Enumerator a m b -> (Step a m b -> Iteratee a' m b') -> Step a m b -> Iteratee a' m b'

-- | <pre>
--   (<a>&lt;==&lt;</a>) = flip (<a>&gt;==&gt;</a>)
--   </pre>
--   
--   Since: 0.1.1
(<==<) :: Monad m => (Step a m b -> Iteratee a' m b') -> Enumerator a m b -> Step a m b -> Iteratee a' m b'

-- | “Wraps” an iteratee <i>inner</i> in an enumeratee <i>wrapper</i>. The
--   resulting iteratee will consume <i>wrapper</i>’s input type and yield
--   <i>inner</i>’s output type.
--   
--   Note: if the inner iteratee yields leftover input when it finishes,
--   that extra will be discarded.
--   
--   As an example, consider an iteratee that converts a stream of
--   UTF8-encoded bytes into a single <tt>Text</tt>:
--   
--   <pre>
--   consumeUTF8 :: Monad m =&gt; Iteratee ByteString m Text
--   </pre>
--   
--   It could be written with either <a>joinI</a> or <tt>(=$)</tt>:
--   
--   <pre>
--   import Data.Enumerator.Text as ET
--   
--   consumeUTF8 = joinI (decode utf8 $$ ET.consume)
--   consumeUTF8 = decode utf8 =$ ET.consume
--   </pre>
--   
--   Since: 0.4.9
(=$) :: Monad m => Enumeratee ao ai m b -> Iteratee ai m b -> Iteratee ao m b

-- | “Wraps” an enumerator <i>inner</i> in an enumeratee <i>wrapper</i>.
--   The resulting enumerator will generate <i>wrapper</i>’s output type.
--   
--   As an example, consider an enumerator that yields line character
--   counts for a text file (e.g. for source code readability checking):
--   
--   <pre>
--   enumFileCounts :: FilePath -&gt; Enumerator Int IO b
--   </pre>
--   
--   It could be written with either <a>joinE</a> or <tt>($=)</tt>:
--   
--   <pre>
--   import Data.Text as T
--   import Data.Enumerator.List as EL
--   import Data.Enumerator.Text as ET
--   
--   enumFileCounts path = joinE (enumFile path) (EL.map T.length)
--   enumFileCounts path = enumFile path $= EL.map T.length
--   </pre>
--   
--   Compatibility note: in version 0.4.15, the associativity of
--   <tt>($=)</tt> was changed from <tt>infixr 0</tt> to <tt>infixl 1</tt>.
--   
--   Since: 0.4.9
($=) :: Monad m => Enumerator ao m (Step ai m b) -> Enumeratee ao ai m b -> Enumerator ai m b

-- | Composes two enumeratees.
--   
--   Note that if the inner enumeratee yields left-over input, this will be
--   discarded.
--   
--   Example: converting bytes into lower-case text:
--   
--   <pre>
--   import Data.ByteString
--   import Data.Text
--   import Data.Enumerator.List as EnumList
--   import Data.Enumerator.Text
--   
--   decodeAndLower :: Monad m =&gt; Enumeratee ByteString Text m b
--   decodeAndLower = decode utf8 =$= EnumList.map toLower
--   </pre>
--   
--   Since: 0.4.17
(=$=) :: Monad m => Enumeratee a1 a2 m (Step a3 m b) -> Enumeratee a2 a3 m b -> Enumeratee a1 a3 m b

-- | The moral equivalent of <a>throwIO</a> for iteratees.
throwError :: (Monad m, Exception e) => e -> Iteratee a m b

-- | Runs the iteratee, and calls an exception handler if an <a>Error</a>
--   is returned. By handling errors within the enumerator library, and
--   requiring all errors to be represented by <a>SomeException</a>,
--   libraries with varying error types can be easily composed.
--   
--   WARNING: Within the error handler, it is difficult or impossible to
--   know how much input the original iteratee has consumed. Users are
--   strongly advised to wrap all uses of <tt>catchError</tt> with an
--   appropriate isolation enumeratee, such as
--   <tt>Data.Enumerator.List.isolate</tt> or
--   <tt>Data.Enumerator.Binary.isolate</tt>, which will handle input
--   framing even in the face of unexpected errors.
--   
--   Since: 0.1.1
catchError :: Monad m => Iteratee a m b -> (SomeException -> Iteratee a m b) -> Iteratee a m b

-- | Compose a list of <a>Enumerator</a>s using
--   <tt>(<a>&gt;==&gt;</a>).</tt>
concatEnums :: Monad m => [Enumerator a m b] -> Enumerator a m b

-- | “Wraps” an iteratee <i>inner</i> in an enumeratee <i>wrapper</i>. The
--   resulting iteratee will consume <i>wrapper</i>’s input type and yield
--   <i>inner</i>’s output type.
--   
--   See the documentation for (<a>=$</a>).
--   
--   <pre>
--   joinI (enum $$ iter) = enum =$ iter
--   </pre>
joinI :: Monad m => Iteratee a m (Step a' m b) -> Iteratee a m b

-- | “Wraps” an enumerator <i>inner</i> in an enumeratee <i>wrapper</i>.
--   The resulting enumerator will generate <i>wrapper</i>’s output type.
--   
--   See the documentation for (<a>$=</a>).
--   
--   <pre>
--   joinE enum enee = enum $= enee
--   </pre>
--   
--   Since: 0.4.5
joinE :: Monad m => Enumerator ao m (Step ai m b) -> Enumeratee ao ai m b -> Enumerator ai m b

-- | Feeds outer input elements into the provided iteratee until it yields
--   an inner input, passes that to the inner iteratee, and then loops.
sequence :: Monad m => Iteratee ao m ai -> Enumeratee ao ai m b

-- | Check whether a stream has reached EOF. Note that if the stream is not
--   at EOF, <tt>isEOF</tt> may cause data to be read from the enumerator.
isEOF :: Monad m => Iteratee a m Bool

-- | Try to run an IO computation. If it throws an exception, the exception
--   is caught and passed to <a>throwError</a>.
--   
--   Since: 0.4.9
tryIO :: MonadIO m => IO b -> Iteratee a m b

-- | Lift an <a>Iteratee</a> onto a monad transformer, re-wrapping its
--   inner monadic values.
--   
--   Since: 0.1.1
liftTrans :: (Monad m, MonadTrans t, Monad (t m)) => Iteratee a m b -> Iteratee a (t m) b

-- | Print chunks as they're received from the enumerator, optionally
--   printing empty chunks.
printChunks :: (MonadIO m, Show a) => Bool -> Iteratee a m ()

-- | <tt><a>enumList</a> n xs</tt> enumerates <i>xs</i> as a stream,
--   passing <i>n</i> inputs per chunk. This is primarily useful for
--   testing, debugging, and REPL exploration.
--   
--   Compatibility note: In version 0.5, <a>enumList</a> will be changed to
--   the type:
--   
--   <pre>
--   enumList :: Monad m =&gt; [a] -&gt; Enumerator a m b
--   </pre>
enumList :: Monad m => Integer -> [a] -> Enumerator a m b

-- | <tt><a>enumLists</a> xs</tt> enumerates <i>xs</i> as a stream, where
--   each element is a separate chunk. This is primarily useful for testing
--   and debugging.
--   
--   Since: 0.4.15
enumLists :: Monad m => [[a]] -> Enumerator a m b

-- | Run an iteratee with the given input, and return either the final
--   value (if it succeeded) or the error (if it failed).
--   
--   Since: 0.4.15
runLists :: [[a]] -> Iteratee a Identity b -> Either SomeException b

-- | Like <a>runLists</a>, except errors are converted to exceptions and
--   thrown.
--   
--   Since: 0.4.15
runLists_ :: [[a]] -> Iteratee a Identity b -> b

-- | Peek at the next element in the stream, or <a>Nothing</a> if the
--   stream has ended.
peek :: Monad m => Iteratee a m (Maybe a)

-- | Get the last element in the stream, or <a>Nothing</a> if the stream
--   has ended.
--   
--   Consumes the entire stream.
last :: Monad m => Iteratee a m (Maybe a)

-- | Get how many elements remained in the stream.
--   
--   Consumes the entire stream.
length :: Monad m => Iteratee a m Integer

-- | Deprecated in 0.4.5: use <a>continue</a> instead
liftI :: Monad m => (Stream a -> Step a m b) -> Iteratee a m b

-- | Deprecated in 0.4.5: use <a>head</a> instead
head :: Monad m => Iteratee a m (Maybe a)

-- | Deprecated in 0.4.5: use <a>drop</a> instead
drop :: Monad m => Integer -> Iteratee a m ()

-- | Deprecated in 0.4.5: use <a>dropWhile</a> instead
dropWhile :: Monad m => (a -> Bool) -> Iteratee a m ()

-- | Deprecated in 0.4.5: use <a>takeWhile</a> instead
span :: Monad m => (a -> Bool) -> Iteratee a m [a]

-- | Deprecated in 0.4.5: use <a>takeWhile</a> instead
break :: Monad m => (a -> Bool) -> Iteratee a m [a]

-- | Deprecated in 0.4.5: use <a>consume</a> instead
consume :: Monad m => Iteratee a m [a]

-- | Deprecated in 0.4.8: use <a>fold</a> instead
--   
--   Since: 0.4.5
foldl :: Monad m => (b -> a -> b) -> b -> Iteratee a m b

-- | Deprecated in 0.4.8: use <a>fold</a> instead
--   
--   Since: 0.4.5
foldl' :: Monad m => (b -> a -> b) -> b -> Iteratee a m b

-- | Deprecated in 0.4.8: use <a>foldM</a> instead
--   
--   Since: 0.4.5
foldM :: Monad m => (b -> a -> m b) -> b -> Iteratee a m b

-- | Deprecated in 0.4.8: use <a>iterate</a> instead
--   
--   Since: 0.4.5
iterate :: Monad m => (a -> a) -> a -> Enumerator a m b

-- | Deprecated in 0.4.8: use <a>iterateM</a> instead
--   
--   Since: 0.4.5
iterateM :: Monad m => (a -> m a) -> a -> Enumerator a m b

-- | Deprecated in 0.4.8: use <a>repeat</a> instead
--   
--   Since: 0.4.5
repeat :: Monad m => a -> Enumerator a m b

-- | Deprecated in 0.4.8: use <a>repeatM</a> instead
--   
--   Since: 0.4.5
repeatM :: Monad m => m a -> Enumerator a m b

-- | Deprecated in 0.4.8: use <a>replicate</a> instead
--   
--   Since: 0.4.5
replicate :: Monad m => Integer -> a -> Enumerator a m b

-- | Deprecated in 0.4.8: use <a>replicateM</a> instead
--   
--   Since: 0.4.5
replicateM :: Monad m => Integer -> m a -> Enumerator a m b

-- | Deprecated in 0.4.8: use <a>generateM</a> instead
--   
--   Since: 0.4.5
generateM :: Monad m => m (Maybe a) -> Enumerator a m b

-- | Deprecated in 0.4.8: use <a>map</a> instead
map :: Monad m => (ao -> ai) -> Enumeratee ao ai m b

-- | Deprecated in 0.4.8: use <a>mapM</a> instead
--   
--   Since: 0.4.3
mapM :: Monad m => (ao -> m ai) -> Enumeratee ao ai m b

-- | Deprecated in 0.4.8: use <a>concatMap</a> instead
--   
--   Since: 0.4.3
concatMap :: Monad m => (ao -> [ai]) -> Enumeratee ao ai m b

-- | Deprecated in 0.4.8: use <a>concatMapM</a> instead
--   
--   Since: 0.4.5
concatMapM :: Monad m => (ao -> m [ai]) -> Enumeratee ao ai m b

-- | Deprecated in 0.4.8: use <a>filter</a> instead
--   
--   Since: 0.4.5
filter :: Monad m => (a -> Bool) -> Enumeratee a a m b

-- | Deprecated in 0.4.8: use <a>filterM</a> instead
--   
--   Since: 0.4.5
filterM :: Monad m => (a -> m Bool) -> Enumeratee a a m b

-- | Deprecated in 0.4.5: use <a>fold</a> instead
--   
--   Since: 0.1.1
liftFoldL :: Monad m => (b -> a -> b) -> b -> Iteratee a m b

-- | Deprecated in 0.4.5: use <a>fold</a> instead
--   
--   Since: 0.1.1
liftFoldL' :: Monad m => (b -> a -> b) -> b -> Iteratee a m b

-- | Deprecated in 0.4.5: use <a>foldM</a> instead
--   
--   Since: 0.1.1
liftFoldM :: Monad m => (b -> a -> m b) -> b -> Iteratee a m b


-- | This module is intended to be imported qualified:
--   
--   <pre>
--   import qualified Data.Enumerator.List as EL
--   </pre>
--   
--   Since: 0.4.5
module Data.Enumerator.List

-- | Consume the entire input stream with a strict left fold, one element
--   at a time.
--   
--   Since: 0.4.8
fold :: Monad m => (b -> a -> b) -> b -> Iteratee a m b

-- | Consume the entire input stream with a strict monadic left fold, one
--   element at a time.
--   
--   Since: 0.4.8
foldM :: Monad m => (b -> a -> m b) -> b -> Iteratee a m b

-- | <tt><a>map</a> f</tt> applies <i>f</i> to each input element and feeds
--   the resulting outputs to the inner iteratee.
--   
--   Since: 0.4.8
map :: Monad m => (ao -> ai) -> Enumeratee ao ai m b

-- | <tt><a>mapM</a> f</tt> applies <i>f</i> to each input element and
--   feeds the resulting outputs to the inner iteratee.
--   
--   Since: 0.4.8
mapM :: Monad m => (ao -> m ai) -> Enumeratee ao ai m b

-- | <tt><a>mapM_</a> f</tt> applies <i>f</i> to each input element, and
--   discards the results.
--   
--   Since: 0.4.11
mapM_ :: Monad m => (a -> m b) -> Iteratee a m ()

-- | <tt><a>concatMap</a> f</tt> applies <i>f</i> to each input element and
--   feeds the resulting outputs to the inner iteratee.
--   
--   Since: 0.4.8
concatMap :: Monad m => (ao -> [ai]) -> Enumeratee ao ai m b

-- | <tt><a>concatMapM</a> f</tt> applies <i>f</i> to each input element
--   and feeds the resulting outputs to the inner iteratee.
--   
--   Since: 0.4.8
concatMapM :: Monad m => (ao -> m [ai]) -> Enumeratee ao ai m b

-- | Similar to <a>map</a>, but with a stateful step function.
--   
--   Since: 0.4.9
mapAccum :: Monad m => (s -> ao -> (s, ai)) -> s -> Enumeratee ao ai m b

-- | Similar to <a>mapM</a>, but with a stateful step function.
--   
--   Since: 0.4.9
mapAccumM :: Monad m => (s -> ao -> m (s, ai)) -> s -> Enumeratee ao ai m b

-- | Similar to <a>concatMap</a>, but with a stateful step function.
--   
--   Since: 0.4.11
concatMapAccum :: Monad m => (s -> ao -> (s, [ai])) -> s -> Enumeratee ao ai m b

-- | Similar to <a>concatMapM</a>, but with a stateful step function.
--   
--   Since: 0.4.11
concatMapAccumM :: Monad m => (s -> ao -> m (s, [ai])) -> s -> Enumeratee ao ai m b

-- | <tt><a>iterate</a> f x</tt> enumerates an infinite stream of repeated
--   applications of <i>f</i> to <i>x</i>.
--   
--   Analogous to <a>iterate</a>.
--   
--   Since: 0.4.8
iterate :: Monad m => (a -> a) -> a -> Enumerator a m b

-- | Similar to <a>iterate</a>, except the iteration function is monadic.
--   
--   Since: 0.4.8
iterateM :: Monad m => (a -> m a) -> a -> Enumerator a m b

-- | Enumerates an infinite stream of a single element.
--   
--   Analogous to <a>repeat</a>.
--   
--   Since: 0.4.8
repeat :: Monad m => a -> Enumerator a m b

-- | Enumerates an infinite stream of element. Each element is computed by
--   the underlying monad.
--   
--   Since: 0.4.8
repeatM :: Monad m => m a -> Enumerator a m b

-- | <tt><a>replicate</a> n x</tt> enumerates a stream containing <i>n</i>
--   copies of <i>x</i>.
--   
--   Analogous to <a>replicate</a>.
--   
--   Since: 0.4.8
replicate :: Monad m => Integer -> a -> Enumerator a m b

-- | <tt><a>replicateM</a> n m_x</tt> enumerates a stream of <i>n</i>
--   elements, with each element computed by <i>m_x</i>.
--   
--   Since: 0.4.8
replicateM :: Monad m => Integer -> m a -> Enumerator a m b

-- | Like <a>repeatM</a>, except the computation may terminate the stream
--   by returning <a>Nothing</a>.
--   
--   Since: 0.4.8
generateM :: Monad m => m (Maybe a) -> Enumerator a m b

-- | Enumerates a stream of elements by repeatedly applying a function to
--   some state.
--   
--   Similar to <a>iterate</a>.
--   
--   Since: 0.4.8
unfold :: Monad m => (s -> Maybe (a, s)) -> s -> Enumerator a m b

-- | Enumerates a stream of elements by repeatedly applying a computation
--   to some state.
--   
--   Similar to <a>iterateM</a>.
--   
--   Since: 0.4.8
unfoldM :: Monad m => (s -> m (Maybe (a, s))) -> s -> Enumerator a m b

-- | <tt><a>drop</a> n</tt> ignores <i>n</i> input elements from the
--   stream.
--   
--   Since: 0.4.5
drop :: Monad m => Integer -> Iteratee a m ()

-- | <tt><a>dropWhile</a> p</tt> ignores input from the stream until the
--   first element which does not match the predicate.
--   
--   Since: 0.4.5
dropWhile :: Monad m => (a -> Bool) -> Iteratee a m ()

-- | Applies a predicate to the stream. The inner iteratee only receives
--   elements for which the predicate is <tt>True</tt>.
--   
--   Since: 0.4.8
filter :: Monad m => (a -> Bool) -> Enumeratee a a m b

-- | Applies a monadic predicate to the stream. The inner iteratee only
--   receives elements for which the predicate returns <tt>True</tt>.
--   
--   Since: 0.4.8
filterM :: Monad m => (a -> m Bool) -> Enumeratee a a m b

-- | Remove duplicate elements from a stream, passing through the first
--   instance of each value.
--   
--   Similar to <tt>nub</tt>, but more efficient because it uses a
--   <a>Set</a> internally.
--   
--   Since: 0.4.11
unique :: (Ord a, Monad m) => Enumeratee a a m b

-- | Get the next element from the stream, or <a>Nothing</a> if the stream
--   has ended.
--   
--   Since: 0.4.5
head :: Monad m => Iteratee a m (Maybe a)

-- | Get the next element from the stream, or raise an error if the stream
--   has ended.
--   
--   Since: 0.4.14
head_ :: Monad m => Iteratee a m a

-- | <tt><a>take</a> n</tt> extracts the next <i>n</i> elements from the
--   stream, as a list.
--   
--   Since: 0.4.5
take :: Monad m => Integer -> Iteratee a m [a]

-- | <tt><a>takeWhile</a> p</tt> extracts input from the stream until the
--   first element which does not match the predicate.
--   
--   Since: 0.4.5
takeWhile :: Monad m => (a -> Bool) -> Iteratee a m [a]

-- | <pre>
--   <a>consume</a> = <a>takeWhile</a> (const True)
--   </pre>
--   
--   Since: 0.4.5
consume :: Monad m => Iteratee a m [a]

-- | Pass input from a stream through two iteratees at once. Excess input
--   is yielded if it was not consumed by either iteratee.
--   
--   Analogous to <a>zip</a>.
--   
--   Since: 0.4.14
zip :: Monad m => Iteratee a m b1 -> Iteratee a m b2 -> Iteratee a m (b1, b2)

-- | Pass input from a stream through three iteratees at once. Excess input
--   is yielded if it was not consumed by any iteratee.
--   
--   Analogous to <a>zip3</a>.
--   
--   Since: 0.4.14
zip3 :: Monad m => Iteratee a m b1 -> Iteratee a m b2 -> Iteratee a m b3 -> Iteratee a m (b1, b2, b3)

-- | Pass input from a stream through four iteratees at once. Excess input
--   is yielded if it was not consumed by any iteratee.
--   
--   Analogous to <a>zip4</a>.
--   
--   Since: 0.4.14
zip4 :: Monad m => Iteratee a m b1 -> Iteratee a m b2 -> Iteratee a m b3 -> Iteratee a m b4 -> Iteratee a m (b1, b2, b3, b4)

-- | Pass input from a stream through five iteratees at once. Excess input
--   is yielded if it was not consumed by any iteratee.
--   
--   Analogous to <a>zip5</a>.
--   
--   Since: 0.4.14
zip5 :: Monad m => Iteratee a m b1 -> Iteratee a m b2 -> Iteratee a m b3 -> Iteratee a m b4 -> Iteratee a m b5 -> Iteratee a m (b1, b2, b3, b4, b5)

-- | Pass input from a stream through six iteratees at once. Excess input
--   is yielded if it was not consumed by any iteratee.
--   
--   Analogous to <a>zip6</a>.
--   
--   Since: 0.4.14
zip6 :: Monad m => Iteratee a m b1 -> Iteratee a m b2 -> Iteratee a m b3 -> Iteratee a m b4 -> Iteratee a m b5 -> Iteratee a m b6 -> Iteratee a m (b1, b2, b3, b4, b5, b6)

-- | Pass input from a stream through seven iteratees at once. Excess input
--   is yielded if it was not consumed by any iteratee.
--   
--   Analogous to <a>zip7</a>.
--   
--   Since: 0.4.14
zip7 :: Monad m => Iteratee a m b1 -> Iteratee a m b2 -> Iteratee a m b3 -> Iteratee a m b4 -> Iteratee a m b5 -> Iteratee a m b6 -> Iteratee a m b7 -> Iteratee a m (b1, b2, b3, b4, b5, b6, b7)

-- | Pass input from a stream through two iteratees at once. Excess input
--   is yielded if it was not consumed by either iteratee. Output from the
--   iteratees is combined with a user-provided function.
--   
--   Analogous to <a>zipWith</a>.
--   
--   Since: 0.4.14
zipWith :: Monad m => (b1 -> b2 -> c) -> Iteratee a m b1 -> Iteratee a m b2 -> Iteratee a m c

-- | Pass input from a stream through two iteratees at once. Excess input
--   is yielded if it was not consumed by either iteratee. Output from the
--   iteratees is combined with a user-provided function.
--   
--   Analogous to <a>zipWith3</a>.
--   
--   Since: 0.4.14
zipWith3 :: Monad m => (b1 -> b2 -> b3 -> c) -> Iteratee a m b1 -> Iteratee a m b2 -> Iteratee a m b3 -> Iteratee a m c

-- | Pass input from a stream through two iteratees at once. Excess input
--   is yielded if it was not consumed by either iteratee. Output from the
--   iteratees is combined with a user-provided function.
--   
--   Analogous to <a>zipWith4</a>.
--   
--   Since: 0.4.14
zipWith4 :: Monad m => (b1 -> b2 -> b3 -> b4 -> c) -> Iteratee a m b1 -> Iteratee a m b2 -> Iteratee a m b3 -> Iteratee a m b4 -> Iteratee a m c

-- | Pass input from a stream through two iteratees at once. Excess input
--   is yielded if it was not consumed by either iteratee. Output from the
--   iteratees is combined with a user-provided function.
--   
--   Analogous to <a>zipWith5</a>.
--   
--   Since: 0.4.14
zipWith5 :: Monad m => (b1 -> b2 -> b3 -> b4 -> b5 -> c) -> Iteratee a m b1 -> Iteratee a m b2 -> Iteratee a m b3 -> Iteratee a m b4 -> Iteratee a m b5 -> Iteratee a m c

-- | Pass input from a stream through two iteratees at once. Excess input
--   is yielded if it was not consumed by either iteratee. Output from the
--   iteratees is combined with a user-provided function.
--   
--   Analogous to <a>zipWith6</a>.
--   
--   Since: 0.4.14
zipWith6 :: Monad m => (b1 -> b2 -> b3 -> b4 -> b5 -> b6 -> c) -> Iteratee a m b1 -> Iteratee a m b2 -> Iteratee a m b3 -> Iteratee a m b4 -> Iteratee a m b5 -> Iteratee a m b6 -> Iteratee a m c

-- | Pass input from a stream through two iteratees at once. Excess input
--   is yielded if it was not consumed by either iteratee. Output from the
--   iteratees is combined with a user-provided function.
--   
--   Analogous to <a>zipWith7</a>.
--   
--   Since: 0.4.14
zipWith7 :: Monad m => (b1 -> b2 -> b3 -> b4 -> b5 -> b6 -> b7 -> c) -> Iteratee a m b1 -> Iteratee a m b2 -> Iteratee a m b3 -> Iteratee a m b4 -> Iteratee a m b5 -> Iteratee a m b6 -> Iteratee a m b7 -> Iteratee a m c

-- | <tt><a>require</a> n</tt> buffers input until at least <i>n</i>
--   elements are available, or throws an error if the stream ends early.
--   
--   Since: 0.4.5
require :: Monad m => Integer -> Iteratee a m ()

-- | <tt><a>isolate</a> n</tt> reads at most <i>n</i> elements from the
--   stream, and passes them to its iteratee. If the iteratee finishes
--   early, elements continue to be consumed from the outer stream until
--   <i>n</i> have been consumed.
--   
--   Since: 0.4.5
isolate :: Monad m => Integer -> Enumeratee a a m b

-- | <tt><a>isolateWhile</a> p</tt> reads elements from the stream until
--   <i>p</i> is false, and passes them to its iteratee. If the iteratee
--   finishes early, elements continue to be consumed from the outer stream
--   until <i>p</i> is false.
--   
--   Since: 0.4.16
isolateWhile :: Monad m => (a -> Bool) -> Enumeratee a a m b

-- | Split on elements satisfying a given predicate.
--   
--   Since: 0.4.8
splitWhen :: Monad m => (a -> Bool) -> Enumeratee a [a] m b


-- | Byte-oriented alternatives to <a>Data.Enumerator.List</a>. Note that
--   the enumeratees in this module must unpack their inputs to work
--   properly. If you do not need to handle leftover input on a
--   byte-by-byte basis, the chunk-oriented versions will be much faster.
--   
--   This module is intended to be imported qualified:
--   
--   <pre>
--   import qualified Data.Enumerator.Binary as EB
--   </pre>
--   
--   Since: 0.4.5
module Data.Enumerator.Binary

-- | Read bytes (in chunks of the given buffer size) from the handle, and
--   stream them to an <a>Iteratee</a>. If an exception occurs during file
--   IO, enumeration will stop and <a>Error</a> will be returned.
--   Exceptions from the iteratee are not caught.
--   
--   This enumerator blocks until at least one byte is available from the
--   handle, and might read less than the maximum buffer size in some
--   cases.
--   
--   The handle should be opened with no encoding, and in <a>ReadMode</a>
--   or <a>ReadWriteMode</a>.
--   
--   Since: 0.4.5
enumHandle :: MonadIO m => Integer -> Handle -> Enumerator ByteString m b

-- | Read bytes (in chunks of the given buffer size) from the handle, and
--   stream them to an <a>Iteratee</a>. If an exception occurs during file
--   IO, enumeration will stop and <a>Error</a> will be returned.
--   Exceptions from the iteratee are not caught.
--   
--   This enumerator blocks until at least one byte is available from the
--   handle, and might read less than the maximum buffer size in some
--   cases.
--   
--   The handle should be opened with no encoding, and in <a>ReadMode</a>
--   or <a>ReadWriteMode</a>.
--   
--   If an offset is specified, the handle will be seeked to that offset
--   before reading. If the handle cannot be seeked, an error will be
--   thrown.
--   
--   If a maximum count is specified, the number of bytes read will not
--   exceed that count.
--   
--   Since: 0.4.8
enumHandleRange :: MonadIO m => Integer -> Maybe Integer -> Maybe Integer -> Handle -> Enumerator ByteString m b

-- | Opens a file path in binary mode, and passes the handle to
--   <a>enumHandle</a>. The file will be closed when enumeration finishes.
--   
--   Since: 0.4.5
enumFile :: FilePath -> Enumerator ByteString IO b

-- | Opens a file path in binary mode, and passes the handle to
--   <a>enumHandleRange</a>. The file will be closed when enumeration
--   finishes.
--   
--   Since: 0.4.8
enumFileRange :: FilePath -> Maybe Integer -> Maybe Integer -> Enumerator ByteString IO b

-- | Read bytes from a stream and write them to a handle. If an exception
--   occurs during file IO, enumeration will stop and <a>Error</a> will be
--   returned.
--   
--   The handle should be opened with no encoding, and in <a>WriteMode</a>
--   or <a>ReadWriteMode</a>.
--   
--   Since: 0.4.5
iterHandle :: MonadIO m => Handle -> Iteratee ByteString m ()

-- | Consume the entire input stream with a strict left fold, one byte at a
--   time.
--   
--   Since: 0.4.8
fold :: Monad m => (b -> Word8 -> b) -> b -> Iteratee ByteString m b

-- | Consume the entire input stream with a strict monadic left fold, one
--   byte at a time.
--   
--   Since: 0.4.8
foldM :: Monad m => (b -> Word8 -> m b) -> b -> Iteratee ByteString m b

-- | <tt><a>map</a> f</tt> applies <i>f</i> to each input byte and feeds
--   the resulting outputs to the inner iteratee.
--   
--   Since: 0.4.8
map :: Monad m => (Word8 -> Word8) -> Enumeratee ByteString ByteString m b

-- | <tt><a>mapM</a> f</tt> applies <i>f</i> to each input byte and feeds
--   the resulting outputs to the inner iteratee.
--   
--   Since: 0.4.8
mapM :: Monad m => (Word8 -> m Word8) -> Enumeratee ByteString ByteString m b

-- | <tt><a>mapM_</a> f</tt> applies <i>f</i> to each input byte, and
--   discards the results.
--   
--   Since: 0.4.11
mapM_ :: Monad m => (Word8 -> m ()) -> Iteratee ByteString m ()

-- | <tt><a>concatMap</a> f</tt> applies <i>f</i> to each input byte and
--   feeds the resulting outputs to the inner iteratee.
--   
--   Since: 0.4.8
concatMap :: Monad m => (Word8 -> ByteString) -> Enumeratee ByteString ByteString m b

-- | <tt><a>concatMapM</a> f</tt> applies <i>f</i> to each input byte and
--   feeds the resulting outputs to the inner iteratee.
--   
--   Since: 0.4.8
concatMapM :: Monad m => (Word8 -> m ByteString) -> Enumeratee ByteString ByteString m b

-- | Similar to <a>map</a>, but with a stateful step function.
--   
--   Since: 0.4.9
mapAccum :: Monad m => (s -> Word8 -> (s, Word8)) -> s -> Enumeratee ByteString ByteString m b

-- | Similar to <a>mapM</a>, but with a stateful step function.
--   
--   Since: 0.4.9
mapAccumM :: Monad m => (s -> Word8 -> m (s, Word8)) -> s -> Enumeratee ByteString ByteString m b

-- | Similar to <a>concatMap</a>, but with a stateful step function.
--   
--   Since: 0.4.11
concatMapAccum :: Monad m => (s -> Word8 -> (s, ByteString)) -> s -> Enumeratee ByteString ByteString m b

-- | Similar to <a>concatMapM</a>, but with a stateful step function.
--   
--   Since: 0.4.11
concatMapAccumM :: Monad m => (s -> Word8 -> m (s, ByteString)) -> s -> Enumeratee ByteString ByteString m b

-- | <tt><a>iterate</a> f x</tt> enumerates an infinite stream of repeated
--   applications of <i>f</i> to <i>x</i>.
--   
--   Analogous to <a>iterate</a>.
--   
--   Since: 0.4.8
iterate :: Monad m => (Word8 -> Word8) -> Word8 -> Enumerator ByteString m b

-- | Similar to <a>iterate</a>, except the iteration function is monadic.
--   
--   Since: 0.4.8
iterateM :: Monad m => (Word8 -> m Word8) -> Word8 -> Enumerator ByteString m b

-- | Enumerates an infinite stream of a single byte.
--   
--   Analogous to <a>repeat</a>.
--   
--   Since: 0.4.8
repeat :: Monad m => Word8 -> Enumerator ByteString m b

-- | Enumerates an infinite stream of byte. Each byte is computed by the
--   underlying monad.
--   
--   Since: 0.4.8
repeatM :: Monad m => m Word8 -> Enumerator ByteString m b

-- | <tt><a>replicate</a> n x</tt> enumerates a stream containing <i>n</i>
--   copies of <i>x</i>.
--   
--   Since: 0.4.8
replicate :: Monad m => Integer -> Word8 -> Enumerator ByteString m b

-- | <tt><a>replicateM</a> n m_x</tt> enumerates a stream of <i>n</i>
--   bytes, with each byte computed by <i>m_x</i>.
--   
--   Since: 0.4.8
replicateM :: Monad m => Integer -> m Word8 -> Enumerator ByteString m b

-- | Like <a>repeatM</a>, except the computation may terminate the stream
--   by returning <a>Nothing</a>.
--   
--   Since: 0.4.8
generateM :: Monad m => m (Maybe Word8) -> Enumerator ByteString m b

-- | Enumerates a stream of bytes by repeatedly applying a function to some
--   state.
--   
--   Similar to <a>iterate</a>.
--   
--   Since: 0.4.8
unfold :: Monad m => (s -> Maybe (Word8, s)) -> s -> Enumerator ByteString m b

-- | Enumerates a stream of bytes by repeatedly applying a computation to
--   some state.
--   
--   Similar to <a>iterateM</a>.
--   
--   Since: 0.4.8
unfoldM :: Monad m => (s -> m (Maybe (Word8, s))) -> s -> Enumerator ByteString m b

-- | <tt><a>drop</a> n</tt> ignores <i>n</i> bytes of input from the
--   stream.
--   
--   Since: 0.4.5
drop :: Monad m => Integer -> Iteratee ByteString m ()

-- | <tt><a>dropWhile</a> p</tt> ignores input from the stream until the
--   first byte which does not match the predicate.
--   
--   Since: 0.4.5
dropWhile :: Monad m => (Word8 -> Bool) -> Iteratee ByteString m ()

-- | Applies a predicate to the stream. The inner iteratee only receives
--   characters for which the predicate is <tt>True</tt>.
--   
--   Since: 0.4.8
filter :: Monad m => (Word8 -> Bool) -> Enumeratee ByteString ByteString m b

-- | Applies a monadic predicate to the stream. The inner iteratee only
--   receives bytes for which the predicate returns <tt>True</tt>.
--   
--   Since: 0.4.8
filterM :: Monad m => (Word8 -> m Bool) -> Enumeratee ByteString ByteString m b

-- | Get the next byte from the stream, or <a>Nothing</a> if the stream has
--   ended.
--   
--   Since: 0.4.5
head :: Monad m => Iteratee ByteString m (Maybe Word8)

-- | Get the next element from the stream, or raise an error if the stream
--   has ended.
--   
--   Since: 0.4.14
head_ :: Monad m => Iteratee ByteString m Word8

-- | <tt><a>take</a> n</tt> extracts the next <i>n</i> bytes from the
--   stream, as a lazy ByteString.
--   
--   Since: 0.4.5
take :: Monad m => Integer -> Iteratee ByteString m ByteString

-- | <tt><a>takeWhile</a> p</tt> extracts input from the stream until the
--   first byte which does not match the predicate.
--   
--   Since: 0.4.5
takeWhile :: Monad m => (Word8 -> Bool) -> Iteratee ByteString m ByteString

-- | <pre>
--   <a>consume</a> = <a>takeWhile</a> (const True)
--   </pre>
--   
--   Since: 0.4.5
consume :: Monad m => Iteratee ByteString m ByteString

-- | Pass input from a stream through two iteratees at once. Excess input
--   is yielded if it was not consumed by either iteratee.
--   
--   Analogous to <a>zip</a>.
--   
--   Since: 0.4.14
zip :: Monad m => Iteratee ByteString m b1 -> Iteratee ByteString m b2 -> Iteratee ByteString m (b1, b2)

-- | Pass input from a stream through three iteratees at once. Excess input
--   is yielded if it was not consumed by any iteratee.
--   
--   Analogous to <a>zip3</a>.
--   
--   Since: 0.4.14
zip3 :: Monad m => Iteratee ByteString m b1 -> Iteratee ByteString m b2 -> Iteratee ByteString m b3 -> Iteratee ByteString m (b1, b2, b3)

-- | Pass input from a stream through four iteratees at once. Excess input
--   is yielded if it was not consumed by any iteratee.
--   
--   Analogous to <a>zip4</a>.
--   
--   Since: 0.4.14
zip4 :: Monad m => Iteratee ByteString m b1 -> Iteratee ByteString m b2 -> Iteratee ByteString m b3 -> Iteratee ByteString m b4 -> Iteratee ByteString m (b1, b2, b3, b4)

-- | Pass input from a stream through five iteratees at once. Excess input
--   is yielded if it was not consumed by any iteratee.
--   
--   Analogous to <a>zip5</a>.
--   
--   Since: 0.4.14
zip5 :: Monad m => Iteratee ByteString m b1 -> Iteratee ByteString m b2 -> Iteratee ByteString m b3 -> Iteratee ByteString m b4 -> Iteratee ByteString m b5 -> Iteratee ByteString m (b1, b2, b3, b4, b5)

-- | Pass input from a stream through six iteratees at once. Excess input
--   is yielded if it was not consumed by any iteratee.
--   
--   Analogous to <a>zip6</a>.
--   
--   Since: 0.4.14
zip6 :: Monad m => Iteratee ByteString m b1 -> Iteratee ByteString m b2 -> Iteratee ByteString m b3 -> Iteratee ByteString m b4 -> Iteratee ByteString m b5 -> Iteratee ByteString m b6 -> Iteratee ByteString m (b1, b2, b3, b4, b5, b6)

-- | Pass input from a stream through seven iteratees at once. Excess input
--   is yielded if it was not consumed by any iteratee.
--   
--   Analogous to <a>zip7</a>.
--   
--   Since: 0.4.14
zip7 :: Monad m => Iteratee ByteString m b1 -> Iteratee ByteString m b2 -> Iteratee ByteString m b3 -> Iteratee ByteString m b4 -> Iteratee ByteString m b5 -> Iteratee ByteString m b6 -> Iteratee ByteString m b7 -> Iteratee ByteString m (b1, b2, b3, b4, b5, b6, b7)

-- | Pass input from a stream through two iteratees at once. Excess input
--   is yielded if it was not consumed by either iteratee. Output from the
--   iteratees is combined with a user-provided function.
--   
--   Analogous to <a>zipWith</a>.
--   
--   Since: 0.4.14
zipWith :: Monad m => (b1 -> b2 -> c) -> Iteratee ByteString m b1 -> Iteratee ByteString m b2 -> Iteratee ByteString m c

-- | Pass input from a stream through two iteratees at once. Excess input
--   is yielded if it was not consumed by either iteratee. Output from the
--   iteratees is combined with a user-provided function.
--   
--   Analogous to <a>zipWith3</a>.
--   
--   Since: 0.4.14
zipWith3 :: Monad m => (b1 -> b2 -> b3 -> c) -> Iteratee ByteString m b1 -> Iteratee ByteString m b2 -> Iteratee ByteString m b3 -> Iteratee ByteString m c

-- | Pass input from a stream through two iteratees at once. Excess input
--   is yielded if it was not consumed by either iteratee. Output from the
--   iteratees is combined with a user-provided function.
--   
--   Analogous to <a>zipWith4</a>.
--   
--   Since: 0.4.14
zipWith4 :: Monad m => (b1 -> b2 -> b3 -> b4 -> c) -> Iteratee ByteString m b1 -> Iteratee ByteString m b2 -> Iteratee ByteString m b3 -> Iteratee ByteString m b4 -> Iteratee ByteString m c

-- | Pass input from a stream through two iteratees at once. Excess input
--   is yielded if it was not consumed by either iteratee. Output from the
--   iteratees is combined with a user-provided function.
--   
--   Analogous to <a>zipWith5</a>.
--   
--   Since: 0.4.14
zipWith5 :: Monad m => (b1 -> b2 -> b3 -> b4 -> b5 -> c) -> Iteratee ByteString m b1 -> Iteratee ByteString m b2 -> Iteratee ByteString m b3 -> Iteratee ByteString m b4 -> Iteratee ByteString m b5 -> Iteratee ByteString m c

-- | Pass input from a stream through two iteratees at once. Excess input
--   is yielded if it was not consumed by either iteratee. Output from the
--   iteratees is combined with a user-provided function.
--   
--   Analogous to <a>zipWith6</a>.
--   
--   Since: 0.4.14
zipWith6 :: Monad m => (b1 -> b2 -> b3 -> b4 -> b5 -> b6 -> c) -> Iteratee ByteString m b1 -> Iteratee ByteString m b2 -> Iteratee ByteString m b3 -> Iteratee ByteString m b4 -> Iteratee ByteString m b5 -> Iteratee ByteString m b6 -> Iteratee ByteString m c

-- | Pass input from a stream through two iteratees at once. Excess input
--   is yielded if it was not consumed by either iteratee. Output from the
--   iteratees is combined with a user-provided function.
--   
--   Analogous to <a>zipWith7</a>.
--   
--   Since: 0.4.14
zipWith7 :: Monad m => (b1 -> b2 -> b3 -> b4 -> b5 -> b6 -> b7 -> c) -> Iteratee ByteString m b1 -> Iteratee ByteString m b2 -> Iteratee ByteString m b3 -> Iteratee ByteString m b4 -> Iteratee ByteString m b5 -> Iteratee ByteString m b6 -> Iteratee ByteString m b7 -> Iteratee ByteString m c

-- | <tt><a>require</a> n</tt> buffers input until at least <i>n</i> bytes
--   are available, or throws an error if the stream ends early.
--   
--   Since: 0.4.5
require :: Monad m => Integer -> Iteratee ByteString m ()

-- | <tt><a>isolate</a> n</tt> reads at most <i>n</i> bytes from the
--   stream, and passes them to its iteratee. If the iteratee finishes
--   early, bytes continue to be consumed from the outer stream until
--   <i>n</i> have been consumed.
--   
--   Since: 0.4.5
isolate :: Monad m => Integer -> Enumeratee ByteString ByteString m b

-- | <tt><a>isolateWhile</a> p</tt> reads bytes from the stream until
--   <i>p</i> is false, and passes them to its iteratee. If the iteratee
--   finishes early, bytes continue to be consumed from the outer stream
--   until <i>p</i> is false.
--   
--   Since: 0.4.16
isolateWhile :: Monad m => (Word8 -> Bool) -> Enumeratee ByteString ByteString m b

-- | Split on bytes satisfying a given predicate.
--   
--   Since: 0.4.8
splitWhen :: Monad m => (Word8 -> Bool) -> Enumeratee ByteString ByteString m b


-- | Character-oriented alternatives to <a>Data.Enumerator.List</a>. Note
--   that the enumeratees in this module must unpack their inputs to work
--   properly. If you do not need to handle leftover input on a
--   char-by-char basis, the chunk-oriented versions will be much faster.
--   
--   This module is intended to be imported qualified:
--   
--   <pre>
--   import qualified Data.Enumerator.Text as ET
--   </pre>
--   
--   Since: 0.2
module Data.Enumerator.Text

-- | Read lines of text from a handle, and stream them to an
--   <a>Iteratee</a>. If an exception occurs during file IO, enumeration
--   will stop and <a>Error</a> will be returned. Exceptions from the
--   iteratee are not caught.
--   
--   The handle should be opened with an appropriate text encoding, and in
--   <a>ReadMode</a> or <a>ReadWriteMode</a>.
--   
--   This function may be significantly slower than using
--   <tt>Data.Enumerator.Binary.enumHandle</tt>, due to the additional
--   overhead of decoding input data to Unicode. Users who can depend on
--   their input files being in a certain encoding (such as UTF8) are
--   encouraged to use binary input and <a>decode</a>.
--   
--   Changed in 0.4.18: Lines streamed from <a>enumHandle</a> and
--   <a>enumFile</a> now include their trailing newline.
--   
--   Since: 0.2
enumHandle :: MonadIO m => Handle -> Enumerator Text m b

-- | Read lines of text from a file, and stream them to an <a>Iteratee</a>.
--   If an exception occurs during file IO, enumeration will stop and
--   <a>Error</a> will be returned. Exceptions from the iteratee are not
--   caught.
--   
--   The file will be opened in text mode, and will be closed when the
--   <a>Iteratee</a> finishes.
--   
--   This function may be significantly slower than using
--   <tt>Data.Enumerator.Binary.enumFile</tt>, due to the additional
--   overhead of decoding input data to Unicode. Users who can depend on
--   their input files being in a certain encoding (such as UTF8) are
--   encouraged to use binary input and <a>decode</a>.
--   
--   Changed in 0.4.18: Lines streamed from <a>enumHandle</a> and
--   <a>enumFile</a> now include their trailing newline.
--   
--   Since: 0.2
enumFile :: FilePath -> Enumerator Text IO b

-- | Read text from a stream and write it to a handle. If an exception
--   occurs during file IO, enumeration will stop and <a>Error</a> will be
--   returned.
--   
--   The handle should be opened with an appropriate text encoding, and in
--   <a>WriteMode</a> or <a>ReadWriteMode</a>.
--   
--   Since: 0.2
iterHandle :: MonadIO m => Handle -> Iteratee Text m ()

-- | Consume the entire input stream with a strict left fold, one character
--   at a time.
--   
--   Since: 0.4.8
fold :: Monad m => (b -> Char -> b) -> b -> Iteratee Text m b

-- | Consume the entire input stream with a strict monadic left fold, one
--   character at a time.
--   
--   Since: 0.4.8
foldM :: Monad m => (b -> Char -> m b) -> b -> Iteratee Text m b

-- | <tt><a>map</a> f</tt> applies <i>f</i> to each input character and
--   feeds the resulting outputs to the inner iteratee.
--   
--   Since: 0.4.8
map :: Monad m => (Char -> Char) -> Enumeratee Text Text m b

-- | <tt><a>mapM</a> f</tt> applies <i>f</i> to each input character and
--   feeds the resulting outputs to the inner iteratee.
--   
--   Since: 0.4.8
mapM :: Monad m => (Char -> m Char) -> Enumeratee Text Text m b

-- | <tt><a>mapM_</a> f</tt> applies <i>f</i> to each input character, and
--   discards the results.
--   
--   Since: 0.4.11
mapM_ :: Monad m => (Char -> m ()) -> Iteratee Text m ()

-- | <tt><a>concatMap</a> f</tt> applies <i>f</i> to each input character
--   and feeds the resulting outputs to the inner iteratee.
--   
--   Since: 0.4.8
concatMap :: Monad m => (Char -> Text) -> Enumeratee Text Text m b

-- | <tt><a>concatMapM</a> f</tt> applies <i>f</i> to each input character
--   and feeds the resulting outputs to the inner iteratee.
--   
--   Since: 0.4.8
concatMapM :: Monad m => (Char -> m Text) -> Enumeratee Text Text m b

-- | Similar to <a>map</a>, but with a stateful step function.
--   
--   Since: 0.4.9
mapAccum :: Monad m => (s -> Char -> (s, Char)) -> s -> Enumeratee Text Text m b

-- | Similar to <a>mapM</a>, but with a stateful step function.
--   
--   Since: 0.4.9
mapAccumM :: Monad m => (s -> Char -> m (s, Char)) -> s -> Enumeratee Text Text m b

-- | Similar to <a>concatMap</a>, but with a stateful step function.
--   
--   Since: 0.4.11
concatMapAccum :: Monad m => (s -> Char -> (s, Text)) -> s -> Enumeratee Text Text m b

-- | Similar to <a>concatMapM</a>, but with a stateful step function.
--   
--   Since: 0.4.11
concatMapAccumM :: Monad m => (s -> Char -> m (s, Text)) -> s -> Enumeratee Text Text m b

-- | <tt><a>iterate</a> f x</tt> enumerates an infinite stream of repeated
--   applications of <i>f</i> to <i>x</i>.
--   
--   Analogous to <a>iterate</a>.
--   
--   Since: 0.4.8
iterate :: Monad m => (Char -> Char) -> Char -> Enumerator Text m b

-- | Similar to <a>iterate</a>, except the iteration function is monadic.
--   
--   Since: 0.4.8
iterateM :: Monad m => (Char -> m Char) -> Char -> Enumerator Text m b

-- | Enumerates an infinite stream of a single character.
--   
--   Analogous to <a>repeat</a>.
--   
--   Since: 0.4.8
repeat :: Monad m => Char -> Enumerator Text m b

-- | Enumerates an infinite stream of characters. Each character is
--   computed by the underlying monad.
--   
--   Since: 0.4.8
repeatM :: Monad m => m Char -> Enumerator Text m b

-- | <tt><a>replicate</a> n x</tt> enumerates a stream containing <i>n</i>
--   copies of <i>x</i>.
--   
--   Since: 0.4.8
replicate :: Monad m => Integer -> Char -> Enumerator Text m b

-- | <tt><a>replicateM</a> n m_x</tt> enumerates a stream of <i>n</i>
--   characters, with each character computed by <i>m_x</i>.
--   
--   Since: 0.4.8
replicateM :: Monad m => Integer -> m Char -> Enumerator Text m b

-- | Like <a>repeatM</a>, except the computation may terminate the stream
--   by returning <a>Nothing</a>.
--   
--   Since: 0.4.8
generateM :: Monad m => m (Maybe Char) -> Enumerator Text m b

-- | Enumerates a stream of characters by repeatedly applying a function to
--   some state.
--   
--   Similar to <a>iterate</a>.
--   
--   Since: 0.4.8
unfold :: Monad m => (s -> Maybe (Char, s)) -> s -> Enumerator Text m b

-- | Enumerates a stream of characters by repeatedly applying a computation
--   to some state.
--   
--   Similar to <a>iterateM</a>.
--   
--   Since: 0.4.8
unfoldM :: Monad m => (s -> m (Maybe (Char, s))) -> s -> Enumerator Text m b

-- | <tt><a>drop</a> n</tt> ignores <i>n</i> characters of input from the
--   stream.
--   
--   Since: 0.4.5
drop :: Monad m => Integer -> Iteratee Text m ()

-- | <tt><a>dropWhile</a> p</tt> ignores input from the stream until the
--   first character which does not match the predicate.
--   
--   Since: 0.4.5
dropWhile :: Monad m => (Char -> Bool) -> Iteratee Text m ()

-- | Applies a predicate to the stream. The inner iteratee only receives
--   characters for which the predicate is <tt>True</tt>.
--   
--   Since: 0.4.8
filter :: Monad m => (Char -> Bool) -> Enumeratee Text Text m b

-- | Applies a monadic predicate to the stream. The inner iteratee only
--   receives characters for which the predicate returns <tt>True</tt>.
--   
--   Since: 0.4.8
filterM :: Monad m => (Char -> m Bool) -> Enumeratee Text Text m b

-- | Get the next character from the stream, or <a>Nothing</a> if the
--   stream has ended.
--   
--   Since: 0.4.5
head :: Monad m => Iteratee Text m (Maybe Char)

-- | Get the next element from the stream, or raise an error if the stream
--   has ended.
--   
--   Since: 0.4.14
head_ :: Monad m => Iteratee Text m Char

-- | <tt><a>take</a> n</tt> extracts the next <i>n</i> characters from the
--   stream, as a lazy Text.
--   
--   Since: 0.4.5
take :: Monad m => Integer -> Iteratee Text m Text

-- | <tt><a>takeWhile</a> p</tt> extracts input from the stream until the
--   first character which does not match the predicate.
--   
--   Since: 0.4.5
takeWhile :: Monad m => (Char -> Bool) -> Iteratee Text m Text

-- | <pre>
--   <a>consume</a> = <a>takeWhile</a> (const True)
--   </pre>
--   
--   Since: 0.4.5
consume :: Monad m => Iteratee Text m Text

-- | Pass input from a stream through two iteratees at once. Excess input
--   is yielded if it was not consumed by either iteratee.
--   
--   Analogous to <a>zip</a>.
--   
--   Since: 0.4.14
zip :: Monad m => Iteratee Text m b1 -> Iteratee Text m b2 -> Iteratee Text m (b1, b2)

-- | Pass input from a stream through three iteratees at once. Excess input
--   is yielded if it was not consumed by any iteratee.
--   
--   Analogous to <a>zip3</a>.
--   
--   Since: 0.4.14
zip3 :: Monad m => Iteratee Text m b1 -> Iteratee Text m b2 -> Iteratee Text m b3 -> Iteratee Text m (b1, b2, b3)

-- | Pass input from a stream through four iteratees at once. Excess input
--   is yielded if it was not consumed by any iteratee.
--   
--   Analogous to <a>zip4</a>.
--   
--   Since: 0.4.14
zip4 :: Monad m => Iteratee Text m b1 -> Iteratee Text m b2 -> Iteratee Text m b3 -> Iteratee Text m b4 -> Iteratee Text m (b1, b2, b3, b4)

-- | Pass input from a stream through five iteratees at once. Excess input
--   is yielded if it was not consumed by any iteratee.
--   
--   Analogous to <a>zip5</a>.
--   
--   Since: 0.4.14
zip5 :: Monad m => Iteratee Text m b1 -> Iteratee Text m b2 -> Iteratee Text m b3 -> Iteratee Text m b4 -> Iteratee Text m b5 -> Iteratee Text m (b1, b2, b3, b4, b5)

-- | Pass input from a stream through six iteratees at once. Excess input
--   is yielded if it was not consumed by any iteratee.
--   
--   Analogous to <a>zip6</a>.
--   
--   Since: 0.4.14
zip6 :: Monad m => Iteratee Text m b1 -> Iteratee Text m b2 -> Iteratee Text m b3 -> Iteratee Text m b4 -> Iteratee Text m b5 -> Iteratee Text m b6 -> Iteratee Text m (b1, b2, b3, b4, b5, b6)

-- | Pass input from a stream through seven iteratees at once. Excess input
--   is yielded if it was not consumed by any iteratee.
--   
--   Analogous to <a>zip7</a>.
--   
--   Since: 0.4.14
zip7 :: Monad m => Iteratee Text m b1 -> Iteratee Text m b2 -> Iteratee Text m b3 -> Iteratee Text m b4 -> Iteratee Text m b5 -> Iteratee Text m b6 -> Iteratee Text m b7 -> Iteratee Text m (b1, b2, b3, b4, b5, b6, b7)

-- | Pass input from a stream through two iteratees at once. Excess input
--   is yielded if it was not consumed by either iteratee. Output from the
--   iteratees is combined with a user-provided function.
--   
--   Analogous to <a>zipWith</a>.
--   
--   Since: 0.4.14
zipWith :: Monad m => (b1 -> b2 -> c) -> Iteratee Text m b1 -> Iteratee Text m b2 -> Iteratee Text m c

-- | Pass input from a stream through two iteratees at once. Excess input
--   is yielded if it was not consumed by either iteratee. Output from the
--   iteratees is combined with a user-provided function.
--   
--   Analogous to <a>zipWith3</a>.
--   
--   Since: 0.4.14
zipWith3 :: Monad m => (b1 -> b2 -> b3 -> c) -> Iteratee Text m b1 -> Iteratee Text m b2 -> Iteratee Text m b3 -> Iteratee Text m c

-- | Pass input from a stream through two iteratees at once. Excess input
--   is yielded if it was not consumed by either iteratee. Output from the
--   iteratees is combined with a user-provided function.
--   
--   Analogous to <a>zipWith4</a>.
--   
--   Since: 0.4.14
zipWith4 :: Monad m => (b1 -> b2 -> b3 -> b4 -> c) -> Iteratee Text m b1 -> Iteratee Text m b2 -> Iteratee Text m b3 -> Iteratee Text m b4 -> Iteratee Text m c

-- | Pass input from a stream through two iteratees at once. Excess input
--   is yielded if it was not consumed by either iteratee. Output from the
--   iteratees is combined with a user-provided function.
--   
--   Analogous to <a>zipWith5</a>.
--   
--   Since: 0.4.14
zipWith5 :: Monad m => (b1 -> b2 -> b3 -> b4 -> b5 -> c) -> Iteratee Text m b1 -> Iteratee Text m b2 -> Iteratee Text m b3 -> Iteratee Text m b4 -> Iteratee Text m b5 -> Iteratee Text m c

-- | Pass input from a stream through two iteratees at once. Excess input
--   is yielded if it was not consumed by either iteratee. Output from the
--   iteratees is combined with a user-provided function.
--   
--   Analogous to <a>zipWith6</a>.
--   
--   Since: 0.4.14
zipWith6 :: Monad m => (b1 -> b2 -> b3 -> b4 -> b5 -> b6 -> c) -> Iteratee Text m b1 -> Iteratee Text m b2 -> Iteratee Text m b3 -> Iteratee Text m b4 -> Iteratee Text m b5 -> Iteratee Text m b6 -> Iteratee Text m c

-- | Pass input from a stream through two iteratees at once. Excess input
--   is yielded if it was not consumed by either iteratee. Output from the
--   iteratees is combined with a user-provided function.
--   
--   Analogous to <a>zipWith7</a>.
--   
--   Since: 0.4.14
zipWith7 :: Monad m => (b1 -> b2 -> b3 -> b4 -> b5 -> b6 -> b7 -> c) -> Iteratee Text m b1 -> Iteratee Text m b2 -> Iteratee Text m b3 -> Iteratee Text m b4 -> Iteratee Text m b5 -> Iteratee Text m b6 -> Iteratee Text m b7 -> Iteratee Text m c

-- | <tt><a>require</a> n</tt> buffers input until at least <i>n</i>
--   characters are available, or throws an error if the stream ends early.
--   
--   Since: 0.4.5
require :: Monad m => Integer -> Iteratee Text m ()

-- | <tt><a>isolate</a> n</tt> reads at most <i>n</i> characters from the
--   stream, and passes them to its iteratee. If the iteratee finishes
--   early, characters continue to be consumed from the outer stream until
--   <i>n</i> have been consumed.
--   
--   Since: 0.4.5
isolate :: Monad m => Integer -> Enumeratee Text Text m b

-- | <tt><a>isolateWhile</a> p</tt> reads characters from the stream until
--   <i>p</i> is false, and passes them to its iteratee. If the iteratee
--   finishes early, characters continue to be consumed from the outer
--   stream until <i>p</i> is false.
--   
--   Since: 0.4.16
isolateWhile :: Monad m => (Char -> Bool) -> Enumeratee Text Text m b

-- | Split on characters satisfying a given predicate.
--   
--   Since: 0.4.8
splitWhen :: Monad m => (Char -> Bool) -> Enumeratee Text Text m b

-- | <pre>
--   <a>lines</a> = <a>splitWhen</a> (== '\n')
--   </pre>
--   
--   Since: 0.4.8
lines :: Monad m => Enumeratee Text Text m b
data Codec

-- | Convert text into bytes, using the provided codec. If the codec is not
--   capable of representing an input character, an error will be thrown.
--   
--   Since: 0.2
encode :: Monad m => Codec -> Enumeratee Text ByteString m b

-- | Convert bytes into text, using the provided codec. If the codec is not
--   capable of decoding an input byte sequence, an error will be thrown.
--   
--   Since: 0.2
decode :: Monad m => Codec -> Enumeratee ByteString Text m b
utf8 :: Codec
utf16_le :: Codec
utf16_be :: Codec
utf32_le :: Codec
utf32_be :: Codec
ascii :: Codec
iso8859_1 :: Codec
instance Show Codec


-- | This module provides functions for running monad transformers within
--   iteratees. Most types defined in the "transformers" library are
--   supported.
--   
--   Functions suffixed with an apostrophe (<tt>'</tt>) apply to the strict
--   variant of their transformer type.
--   
--   Since: 0.4.16
module Data.Enumerator.Trans

-- | Lifted version of <a>runIdentityT</a>
--   
--   Since: 0.4.16
runIdentityI :: Monad m => Iteratee a (IdentityT m) b -> Iteratee a m b

-- | Lifted version of <a>runMaybeT</a>
--   
--   Since: 0.4.16
runMaybeI :: Monad m => Iteratee a (MaybeT m) b -> Iteratee a m (Maybe b)

-- | Lifted version of <a>runErrorT</a>
--   
--   Since: 0.4.16
runErrorI :: (Error e, Monad m) => Iteratee a (ErrorT e m) b -> Iteratee a m (Either e b)

-- | Lifted version of <a>runReaderT</a>
--   
--   Since: 0.4.16
runReaderI :: Monad m => r -> Iteratee a (ReaderT r m) b -> Iteratee a m b

-- | Lifted version of (lazy) <a>runStateT</a>
--   
--   Since: 0.4.16
runStateI :: Monad m => s -> Iteratee a (StateT s m) b -> Iteratee a m (b, s)

-- | Lifted version of (lazy) <a>evalStateT</a>
--   
--   Since: 0.4.16
evalStateI :: Monad m => s -> Iteratee a (StateT s m) b -> Iteratee a m b

-- | Lifted version of (strict) <a>runStateT</a>
--   
--   Since: 0.4.16
runStateI' :: Monad m => s -> Iteratee a (StateT s m) b -> Iteratee a m (b, s)

-- | Lifted version of (strict) <a>evalStateT</a>
--   
--   Since: 0.4.16
evalStateI' :: Monad m => s -> Iteratee a (StateT s m) b -> Iteratee a m b

-- | Lifted version of (lazy) <a>runWriterT</a>
--   
--   Since: 0.4.16
runWriterI :: (Monoid w, Monad m) => Iteratee a (WriterT w m) b -> Iteratee a m (b, w)

-- | Lifted version of (lazy) <a>execWriterT</a>
--   
--   Since: 0.4.16
execWriterI :: (Monoid w, Monad m) => Iteratee a (WriterT w m) b -> Iteratee a m w

-- | Lifted version of (strict) <a>runWriterT</a>
--   
--   Since: 0.4.16
runWriterI' :: (Monoid w, Monad m) => Iteratee a (WriterT w m) b -> Iteratee a m (b, w)

-- | Lifted version of (strict) <a>execWriterT</a>
--   
--   Since: 0.4.16
execWriterI' :: (Monoid w, Monad m) => Iteratee a (WriterT w m) b -> Iteratee a m w

-- | Lifted version of (lazy) <a>runRWST</a>
--   
--   Since: 0.4.16
runRWSI :: (Monoid w, Monad m) => r -> s -> Iteratee a (RWST r w s m) b -> Iteratee a m (b, s, w)

-- | Lifted version of (lazy) <a>evalRWST</a>
--   
--   Since: 0.4.16
evalRWSI :: (Monoid w, Monad m) => r -> s -> Iteratee a (RWST r w s m) b -> Iteratee a m (b, w)

-- | Lifted version of (lazy) <a>execRWST</a>
--   
--   Since: 0.4.16
execRWSI :: (Monoid w, Monad m) => r -> s -> Iteratee a (RWST r w s m) b -> Iteratee a m (s, w)

-- | Lifted version of (strict) <a>runRWST</a>
--   
--   Since: 0.4.16
runRWSI' :: (Monoid w, Monad m) => r -> s -> Iteratee a (RWST r w s m) b -> Iteratee a m (b, s, w)

-- | Lifted version of (strict) <a>evalRWST</a>
--   
--   Since: 0.4.16
evalRWSI' :: (Monoid w, Monad m) => r -> s -> Iteratee a (RWST r w s m) b -> Iteratee a m (b, w)

-- | Lifted version of (strict) <a>execRWST</a>
--   
--   Since: 0.4.16
execRWSI' :: (Monoid w, Monad m) => r -> s -> Iteratee a (RWST r w s m) b -> Iteratee a m (s, w)
