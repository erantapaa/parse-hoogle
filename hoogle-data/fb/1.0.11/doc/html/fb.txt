-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Bindings to Facebook's API.
--   
@package fb
@version 1.0.11

module Facebook

-- | <tt>FacebookT auth m a</tt> is this library's monad transformer.
--   Contains information needed to issue commands and queries to Facebook.
--   The phantom type <tt>auth</tt> may be either <a>Auth</a> (you have
--   supplied your <a>Credentials</a>) or <a>NoAuth</a> (you have not
--   supplied any <a>Credentials</a>).
data FacebookT auth m a

-- | Run a computation in the <a>FacebookT</a> monad transformer with your
--   credentials.
runFacebookT :: Credentials -> Manager -> FacebookT Auth m a -> m a

-- | Run a computation in the <a>FacebookT</a> monad without credentials.
runNoAuthFacebookT :: Manager -> FacebookT NoAuth m a -> m a

-- | Transform the computation inside a <a>FacebookT</a>.
mapFacebookT :: (m a -> n b) -> FacebookT anyAuth m a -> FacebookT anyAuth n b

-- | Same as <a>runFacebookT</a>, but uses Facebook's beta tier (see
--   <a>https://developers.facebook.com/support/beta-tier/</a>).
beta_runFacebookT :: Credentials -> Manager -> FacebookT Auth m a -> m a

-- | Same as <a>runNoAuthFacebookT</a>, but uses Facebook's beta tier (see
--   <a>https://developers.facebook.com/support/beta-tier/</a>).
beta_runNoAuthFacebookT :: Manager -> FacebookT NoAuth m a -> m a

-- | Phantom type stating that you have provided your <a>Credentials</a>
--   and thus have access to the whole API.
data Auth

-- | Phantom type stating that you have <i>not</i> provided your
--   <a>Credentials</a>. This means that you'll be limited about which APIs
--   you'll be able use.
data NoAuth

-- | Credentials that you get for your app when you register on Facebook.
data Credentials
Credentials :: Text -> Text -> Text -> Credentials

-- | Your application name (e.g. for Open Graph calls).
appName :: Credentials -> Text

-- | Your application ID.
appId :: Credentials -> Text

-- | Your application secret key.
appSecret :: Credentials -> Text

-- | An access token. While you can make some API calls without an access
--   token, many require an access token and some will give you more
--   information with an appropriate access token.
--   
--   There are two kinds of access tokens:
--   
--   <ul>
--   <li><i>User access token</i> An access token obtained after an user
--   accepts your application. Let's you access more information about that
--   user and act on their behalf (depending on which permissions you've
--   asked for).</li>
--   <li><i>App access token</i> An access token that allows you to take
--   administrative actions for your application.</li>
--   </ul>
--   
--   These two kinds of access tokens are distinguished by the phantom type
--   on <a>AccessToken</a>, which can be <a>UserKind</a> or <a>AppKind</a>.
data AccessToken kind
UserAccessToken :: UserId -> AccessTokenData -> UTCTime -> AccessToken UserKind
AppAccessToken :: AccessTokenData -> AccessToken AppKind

-- | Type synonym for <tt><a>AccessToken</a> <a>UserKind</a></tt>.
type UserAccessToken = AccessToken UserKind

-- | Type synonym for <tt><a>AccessToken</a> <a>AppKind</a></tt>.
type AppAccessToken = AccessToken AppKind

-- | The access token data that is passed to Facebook's API calls.
type AccessTokenData = Text

-- | <tt>True</tt> if the access token has expired, otherwise
--   <tt>False</tt>.
hasExpired :: (Functor m, MonadIO m) => AccessToken anyKind -> m Bool

-- | <tt>True</tt> if the access token is valid. An expired access token is
--   not valid (see <a>hasExpired</a>). However, a non-expired access token
--   may not be valid as well. For example, in the case of an user access
--   token, they may have changed their password, logged out from Facebook
--   or blocked your app.
isValid :: (MonadBaseControl IO m, MonadResource m) => AccessToken anyKind -> FacebookT anyAuth m Bool

-- | Phantom type used mark an <a>AccessToken</a> as an app access token.
data AppKind

-- | Get an app access token from Facebook using your credentials.
getAppAccessToken :: (MonadResource m, MonadBaseControl IO m) => FacebookT Auth m AppAccessToken

-- | Phantom type used mark an <a>AccessToken</a> as an user access token.
data UserKind

-- | URL where the user is redirected to after Facebook authenticates the
--   user authorizes your application. This URL should be inside the domain
--   registered for your Facebook application.
type RedirectUrl = Text

-- | A permission that is asked for the user when he authorizes your app.
--   Please refer to Facebook's documentation at
--   <a>https://developers.facebook.com/docs/reference/api/permissions/</a>
--   to see which permissions are available.
--   
--   This is a <tt>newtype</tt> of <a>Text</a> that supports only
--   <a>IsString</a>. This means that to create a <a>Permission</a> you
--   should use the <tt>OverloadedStrings</tt> language extension. For
--   example,
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   perms :: [Permission]
--   perms = ["user_about_me", "email", "offline_access"]
--   </pre>
data Permission

-- | The first step to get an user access token. Returns the Facebook URL
--   you should redirect you user to. Facebook will authenticate the user,
--   authorize your app and then redirect the user back into the provider
--   <a>RedirectUrl</a>.
getUserAccessTokenStep1 :: Monad m => RedirectUrl -> [Permission] -> FacebookT Auth m Text

-- | The second step to get an user access token. If the user is
--   successfully authenticate and they authorize your application, then
--   they'll be redirected back to the <a>RedirectUrl</a> you've passed to
--   <a>getUserAccessTokenStep1</a>. You should take the request query
--   parameters passed to your <a>RedirectUrl</a> and give to this function
--   that will complete the user authentication flow and give you an
--   <tt><a>UserAccessToken</a></tt>.
getUserAccessTokenStep2 :: (MonadBaseControl IO m, MonadResource m) => RedirectUrl -> [Argument] -> FacebookT Auth m UserAccessToken

-- | The URL an user should be redirected to in order to log them out of
--   their Facebook session. Facebook will then redirect the user to the
--   provided URL after logging them out. Note that, at the time of this
--   writing, Facebook's policies require you to log the user out of
--   Facebook when they ask to log out of your site.
--   
--   Note also that Facebook may refuse to redirect the user to the
--   provided URL if their user access token is invalid. In order to
--   prevent this bug, we suggest that you use <a>isValid</a> before
--   redirecting the user to the URL provided by <a>getUserLogoutUrl</a>
--   since this function doesn't do any validity checks.
getUserLogoutUrl :: Monad m => UserAccessToken -> RedirectUrl -> FacebookT Auth m Text

-- | Extend the expiration time of an user access token (see
--   <a>https://developers.facebook.com/docs/offline-access-deprecation/</a>,
--   <a>https://developers.facebook.com/roadmap/offline-access-removal/</a>).
--   Only short-lived user access tokens may extended into long-lived user
--   access tokens, you must get a new short-lived user access token if you
--   need to extend a long-lived one. Returns <tt>Left exc</tt> if there is
--   an error while extending, or <tt>Right token</tt> with the new user
--   access token (which could have the same data and expiration time as
--   before, but you can't assume this). Note that expired access tokens
--   can't be extended, only valid tokens.
extendUserAccessToken :: (MonadBaseControl IO m, MonadResource m) => UserAccessToken -> FacebookT Auth m (Either FacebookException UserAccessToken)

-- | Get detailed information about an access token.
debugToken :: (MonadBaseControl IO m, MonadResource m) => AppAccessToken -> AccessTokenData -> FacebookT Auth m DebugToken

-- | Detailed information about an access token (cf. <a>debugToken</a>).
data DebugToken
DebugToken :: Maybe Text -> Maybe Text -> Maybe UTCTime -> Maybe Bool -> Maybe UTCTime -> Maybe [Permission] -> Maybe Id -> Maybe UserAccessToken -> DebugToken
dtAppId :: DebugToken -> Maybe Text
dtAppName :: DebugToken -> Maybe Text
dtExpiresAt :: DebugToken -> Maybe UTCTime
dtIsValid :: DebugToken -> Maybe Bool
dtIssuedAt :: DebugToken -> Maybe UTCTime
dtScopes :: DebugToken -> Maybe [Permission]
dtUserId :: DebugToken -> Maybe Id
dtAccessToken :: DebugToken -> Maybe UserAccessToken

-- | Parses a Facebook signed request
--   (<a>https://developers.facebook.com/docs/authentication/signed_request/</a>),
--   verifies its authencity and integrity using the HMAC and decodes its
--   JSON object.
parseSignedRequest :: (FromJSON a, Monad m) => ByteString -> FacebookT Auth m (Maybe a)

-- | A Facebook user profile (see
--   <a>https://developers.facebook.com/docs/reference/api/user/</a>).
--   
--   <i>NOTE:</i> We still don't support all fields supported by Facebook.
--   Please fill an issue if you need access to any other fields.
data User
User :: UserId -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Gender -> Maybe Text -> Maybe Text -> Maybe Bool -> Maybe Text -> Maybe Place -> User
userId :: User -> UserId
userName :: User -> Maybe Text
userFirstName :: User -> Maybe Text
userMiddleName :: User -> Maybe Text
userLastName :: User -> Maybe Text
userGender :: User -> Maybe Gender
userLocale :: User -> Maybe Text
userUsername :: User -> Maybe Text
userVerified :: User -> Maybe Bool
userEmail :: User -> Maybe Text
userLocation :: User -> Maybe Place

-- | A Facebook user ID such as <tt>1008905713901</tt>.
type UserId = Id

-- | An user's gender.
data Gender
Male :: Gender
Female :: Gender

-- | Get an user using his user ID. The user access token is optional, but
--   when provided more information can be returned back by Facebook. The
--   user ID may be <tt>"me"</tt>, in which case you must provide an user
--   access token and information about the token's owner is given.
getUser :: (MonadResource m, MonadBaseControl IO m) => UserId -> [Argument] -> Maybe UserAccessToken -> FacebookT anyAuth m User

-- | Search users by keyword.
searchUsers :: (MonadResource m, MonadBaseControl IO m) => Text -> [Argument] -> Maybe UserAccessToken -> FacebookT anyAuth m (Pager User)

-- | Get a list of check-ins made by a given user.
getUserCheckins :: (MonadResource m, MonadBaseControl IO m) => UserId -> [Argument] -> UserAccessToken -> FacebookT anyAuth m (Pager Checkin)

-- | A friend connection of a <a>User</a>.
data Friend
Friend :: UserId -> Text -> Friend
friendId :: Friend -> UserId
friendName :: Friend -> Text

-- | Get the list of friends of the given user.
getUserFriends :: (MonadResource m, MonadBaseControl IO m) => UserId -> [Argument] -> UserAccessToken -> FacebookT anyAuth m (Pager Friend)

-- | Get the friend lists of the given user.
getUserFriendLists :: (MonadResource m, MonadBaseControl IO m) => UserId -> [Argument] -> UserAccessToken -> FacebookT anyAuth m (Pager FriendList)

-- | A Facebook page (see
--   <a>https://developers.facebook.com/docs/reference/api/page/</a>).
--   
--   <i>NOTE:</i> Does not yet support all fields. Please file an issue if
--   you need any other fields.
data Page
Page :: Id -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Bool -> Maybe Bool -> Maybe Integer -> Maybe Location -> Maybe Text -> Maybe Integer -> Maybe Text -> Maybe Text -> Maybe Integer -> Page
pageId :: Page -> Id
pageName :: Page -> Maybe Text
pageLink :: Page -> Maybe Text
pageCategory :: Page -> Maybe Text
pageIsPublished :: Page -> Maybe Bool
pageCanPost :: Page -> Maybe Bool
pageLikes :: Page -> Maybe Integer
pageLocation :: Page -> Maybe Location
pagePhone :: Page -> Maybe Text
pageCheckins :: Page -> Maybe Integer
pagePicture :: Page -> Maybe Text
pageWebsite :: Page -> Maybe Text
pageTalkingAboutCount :: Page -> Maybe Integer

-- | Get a page using its ID. The user access token is optional.
getPage :: (MonadResource m, MonadBaseControl IO m) => Id -> [Argument] -> Maybe UserAccessToken -> FacebookT anyAuth m Page

-- | Search pages by keyword. The user access token is optional.
searchPages :: (MonadResource m, MonadBaseControl IO m) => Text -> [Argument] -> Maybe UserAccessToken -> FacebookT anyAuth m (Pager Page)

-- | An action of your app. Please refer to Facebook's documentation at
--   <a>https://developers.facebook.com/docs/opengraph/keyconcepts/#actions-objects</a>
--   to see how you can create actions.
--   
--   This is a <tt>newtype</tt> of <a>Text</a> that supports only
--   <a>IsString</a>. This means that to create an <a>Action</a> you should
--   use the <tt>OverloadedStrings</tt> language extension. For example,
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   foo token = do
--     ...
--     createAction "cook" [...] token
--   </pre>
data Action

-- | Creates an Open Graph action on the user's timeline. Returns the
--   <a>Id</a> of the newly created action. For example:
--   
--   <pre>
--   now &lt;- liftIO getCurrentTime
--   createAction "cook"
--                [ "recipe" #= "http://example.com/cookie.html"
--                , "when"   #= now ]
--                token
--   </pre>
createAction :: (MonadResource m, MonadBaseControl IO m) => Action -> [Argument] -> Maybe AppAccessToken -> UserAccessToken -> FacebookT Auth m Id

-- | A Facebook check-in (see
--   <a>https://developers.facebook.com/docs/reference/api/checkin/</a>).
--   
--   <i>NOTE:</i> We still don't support all fields supported by Facebook.
--   Please fill an issue if you need access to any other fields.
data Checkin
Checkin :: Id -> Maybe CheckinFrom -> Maybe Place -> Maybe UTCTime -> Maybe (Pager Tag) -> Maybe Text -> Checkin
checkinId :: Checkin -> Id
checkinFrom :: Checkin -> Maybe CheckinFrom
checkinPlace :: Checkin -> Maybe Place
checkinCreatedTime :: Checkin -> Maybe UTCTime
checkinTags :: Checkin -> Maybe (Pager Tag)
checkinMessage :: Checkin -> Maybe Text

-- | Information about the user who made the check-in.
data CheckinFrom
CheckinFrom :: UserId -> Text -> CheckinFrom
checkinFromId :: CheckinFrom -> UserId
checkinFromName :: CheckinFrom -> Text

-- | Get a checkin from its ID. The user access token is optional, but when
--   provided more information can be returned back by Facebook.
getCheckin :: (MonadResource m, MonadBaseControl IO m) => Id -> [Argument] -> Maybe UserAccessToken -> FacebookT anyAuth m Checkin

-- | Creates a 'check-in' and returns its ID. Place and coordinates are
--   both required by Facebook.
createCheckin :: (MonadResource m, MonadBaseControl IO m) => Id -> GeoCoordinates -> [Argument] -> UserAccessToken -> FacebookT Auth m Id

-- | A Facebook <tt>Order</tt> oject.
data Order
Order :: OrderId -> UserId -> UserId -> Integer -> OrderStatus -> OrderApplication -> Text -> Maybe Text -> ZonedTime -> ZonedTime -> Order
orderId :: Order -> OrderId
orderFrom :: Order -> UserId
orderTo :: Order -> UserId
orderAmount :: Order -> Integer
orderStatus :: Order -> OrderStatus
orderApplication :: Order -> OrderApplication
orderCountry :: Order -> Text
orderRefundCode :: Order -> Maybe Text
orderCreatedTime :: Order -> ZonedTime
orderUpdatedTime :: Order -> ZonedTime

-- | <a>Order</a> Id type.
type OrderId = Id

-- | A trimmed down version of Facebook Application as it is used in
--   <a>Order</a>.
data OrderApplication

-- | A Facebook <a>Order</a> status type.
data OrderStatus

-- | Get an <a>Order</a> using its <a>OrderId</a>. The user access token is
--   mandatory.
getOrder :: (MonadResource m, MonadBaseControl IO m) => OrderId -> UserAccessToken -> FacebookT anyAuth m Order

-- | A friend list for a <a>User</a>.
data FriendList
FriendList :: Id -> Text -> FriendListType -> FriendList
friendListId :: FriendList -> Id
friendListName :: FriendList -> Text
friendListType :: FriendList -> FriendListType
data FriendListType
CloseFriendsList :: FriendListType
AcquaintancesList :: FriendListType
RestrictedList :: FriendListType
UserCreatedList :: FriendListType
EducationList :: FriendListType
WorkList :: FriendListType
CurrentCityList :: FriendListType
FamilyList :: FriendListType

-- | Get the members of a friend list.
getFriendListMembers :: (MonadResource m, MonadBaseControl IO m) => Id -> [Argument] -> UserAccessToken -> FacebookT anyAuth m (Pager Friend)

-- | Create an <a>Argument</a> with a <a>SimpleType</a>. See the docs on
--   <tt>createAction</tt> for an example.
(#=) :: SimpleType a => ByteString -> a -> Argument

-- | Class for data types that may be represented as a Facebook simple
--   type. (see
--   <a>https://developers.facebook.com/docs/opengraph/simpletypes/</a>).
class SimpleType a
encodeFbParam :: SimpleType a => a -> ByteString

-- | <tt>newtype</tt> for <a>UTCTime</a> that follows Facebook's
--   conventions of JSON parsing.
--   
--   <ul>
--   <li>As a string, while <tt>aeson</tt> expects a format of
--   <tt>%FT%T%Q</tt>, Facebook gives time values formatted as
--   <tt>%FT%T%z</tt>.</li>
--   <li>As a number, <a>FbUTCTime</a> accepts a number of seconds since
--   the Unix epoch.</li>
--   </ul>
newtype FbUTCTime
FbUTCTime :: UTCTime -> FbUTCTime
unFbUTCTime :: FbUTCTime -> UTCTime

-- | Information about a place. This is not a Graph Object, instead it's
--   just a field of a Object. (Not to be confused with the <tt>Page</tt>
--   object.)
data Place
Place :: Id -> Maybe Text -> Maybe Location -> Place

-- | <tt>Page</tt> ID.
placeId :: Place -> Id

-- | <tt>Page</tt> name.
placeName :: Place -> Maybe Text
placeLocation :: Place -> Maybe Location

-- | A geographical location.
data Location
Location :: Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe Text -> Maybe GeoCoordinates -> Location
locationStreet :: Location -> Maybe Text
locationCity :: Location -> Maybe Text
locationState :: Location -> Maybe Text
locationCountry :: Location -> Maybe Text
locationZip :: Location -> Maybe Text
locationCoords :: Location -> Maybe GeoCoordinates

-- | Geographical coordinates.
data GeoCoordinates
GeoCoordinates :: !Double -> !Double -> GeoCoordinates
latitude :: GeoCoordinates -> !Double
longitude :: GeoCoordinates -> !Double

-- | A tag (i.e. "I'll <i>tag</i> you on my post").
data Tag
Tag :: Id -> Text -> Tag

-- | Who is tagged.
tagId :: Tag -> Id

-- | Name of the tagged person.
tagName :: Tag -> Text

-- | Many Graph API results are returned as a JSON object with the
--   following structure:
--   
--   <pre>
--   {
--     "data": [
--       ...item 1...,
--            :
--       ...item n...
--     ],
--     "paging": {
--       "previous": "http://...link to previous page...",
--       "next":     "http://...link to next page..."
--     }
--   }
--   </pre>
--   
--   Only the <tt>"data"</tt> field is required, the others may or may not
--   appear.
--   
--   A <tt>Pager a</tt> datatype encodes such result where each item has
--   type <tt>a</tt>. You may use functions <a>fetchNextPage</a> and
--   <a>fetchPreviousPage</a> to navigate through the results.
data Pager a
Pager :: [a] -> Maybe String -> Maybe String -> Pager a
pagerData :: Pager a -> [a]
pagerPrevious :: Pager a -> Maybe String
pagerNext :: Pager a -> Maybe String

-- | Tries to fetch the next page of a <a>Pager</a>. Returns <a>Nothing</a>
--   whenever the current <tt>Pager</tt> does not have a <a>pagerNext</a>.
fetchNextPage :: (MonadResource m, MonadBaseControl IO m, FromJSON a) => Pager a -> FacebookT anyAuth m (Maybe (Pager a))

-- | Tries to fetch the previous page of a <a>Pager</a>. Returns
--   <a>Nothing</a> whenever the current <tt>Pager</tt> does not have a
--   <a>pagerPrevious</a>.
fetchPreviousPage :: (MonadResource m, MonadBaseControl IO m, FromJSON a) => Pager a -> FacebookT anyAuth m (Maybe (Pager a))

-- | Tries to fetch all next pages and returns a <a>Source</a> with all
--   results. The <a>Source</a> will include the results from this page as
--   well. Previous pages will not be considered. Next pages will be
--   fetched on-demand.
fetchAllNextPages :: (Monad m, MonadResourceBase n, FromJSON a) => Pager a -> FacebookT anyAuth m (Source n a)

-- | Tries to fetch all previous pages and returns a <a>Source</a> with all
--   results. The <a>Source</a> will include the results from this page as
--   well. Next pages will not be considered. Previous pages will be
--   fetched on-demand.
fetchAllPreviousPages :: (Monad m, MonadResourceBase n, FromJSON a) => Pager a -> FacebookT anyAuth m (Source n a)

-- | Add or modify a subscription for real-time updates. If there were no
--   previous subscriptions for the given <a>RealTimeUpdateObject</a>, then
--   a new subscription is created. If there was any previous subscription
--   for the given <a>RealTimeUpdateObject</a>, it's overriden by this one
--   (even if the other subscription had a different callback URL).
modifySubscription :: (MonadResource m, MonadBaseControl IO m) => RealTimeUpdateObject -> [RealTimeUpdateField] -> RealTimeUpdateUrl -> RealTimeUpdateToken -> AppAccessToken -> FacebookT Auth m ()

-- | List current real-time update subscriptions.
listSubscriptions :: (MonadResource m, MonadBaseControl IO m) => AppAccessToken -> FacebookT Auth m [RealTimeUpdateSubscription]

-- | The type of objects that a real-time update refers to.
data RealTimeUpdateObject
UserRTUO :: RealTimeUpdateObject
PermissionsRTUO :: RealTimeUpdateObject
PageRTUO :: RealTimeUpdateObject
ErrorsRTUO :: RealTimeUpdateObject
OtherRTUO :: Text -> RealTimeUpdateObject

-- | A field of a <a>RealTimeUpdateObject</a> that you would like to
--   receive notifications when changed.
type RealTimeUpdateField = ByteString

-- | The URL on your server that will receive the real-time updates. Please
--   refer to Facebook's documentation in order to see what this URL needs
--   to implement.
type RealTimeUpdateUrl = Text

-- | A token that is sent back by Facebook's servers to your server in
--   order to verify that you really were trying to modify your
--   subscription.
type RealTimeUpdateToken = ByteString

-- | Information returned by Facebook about a real-time update notification
--   subscription.
data RealTimeUpdateSubscription
RealTimeUpdateSubscription :: RealTimeUpdateObject -> RealTimeUpdateUrl -> [RealTimeUpdateField] -> Bool -> RealTimeUpdateSubscription
rtusObject :: RealTimeUpdateSubscription -> RealTimeUpdateObject
rtusCallbackUrl :: RealTimeUpdateSubscription -> RealTimeUpdateUrl
rtusFields :: RealTimeUpdateSubscription -> [RealTimeUpdateField]
rtusActive :: RealTimeUpdateSubscription -> Bool

-- | Verifies the input's authenticity (i.e. it comes from Facebook) and
--   integrity by calculating its HMAC-SHA1 (using your application secret
--   as the key) and verifying that it matches the value from the HTTP
--   request's <tt>X-Hub-Signature</tt> header's value. If it's not valid,
--   <tt>Nothing</tt> is returned, otherwise <tt>Just data</tt> is returned
--   where <tt>data</tt> is the original data.
verifyRealTimeUpdateNotifications :: Monad m => ByteString -> ByteString -> FacebookT Auth m (Maybe ByteString)

-- | Same as <a>verifyRealTimeUpdateNotifications</a> but also parses the
--   response as JSON. Returns <tt>Nothing</tt> if either the signature is
--   invalid or the data can't be parsed (use
--   <a>verifyRealTimeUpdateNotifications</a> if you need to distinguish
--   between these two error conditions).
getRealTimeUpdateNotifications :: (Monad m, FromJSON a) => ByteString -> ByteString -> FacebookT Auth m (Maybe (RealTimeUpdateNotification a))

-- | When data changes and there's a valid subscription, Facebook will
--   <tt>POST</tt> to your <a>RealTimeUpdateUrl</a> with a JSON-encoded
--   object containing the notifications. A 'RealTimeUpdateNotification a'
--   represents such object where <tt>a</tt> is type of the entries (e.g.,
--   <a>RealTimeUpdateNotificationUserEntry</a>).
--   
--   If you have a single <a>RealTimeUpdateUrl</a> for different kinds of
--   notifications, you may parse a <tt>RealTimeUpdateNotification
--   <a>Value</a></tt> and then manually parse the <a>Value</a> depending
--   on the value of <a>rtunObject</a>.
--   
--   We recommend using <a>getRealTimeUpdateNotifications</a>.
data RealTimeUpdateNotification a
RealTimeUpdateNotification :: RealTimeUpdateObject -> [a] -> RealTimeUpdateNotification a
rtunObject :: RealTimeUpdateNotification a -> RealTimeUpdateObject
rtunEntries :: RealTimeUpdateNotification a -> [a]

-- | A notification for the <a>UserRTUO</a> object.
data RealTimeUpdateNotificationUserEntry
RealTimeUpdateNotificationUserEntry :: Id -> [RealTimeUpdateField] -> Integer -> RealTimeUpdateNotificationUserEntry
rtuneUserId :: RealTimeUpdateNotificationUserEntry -> Id
rtuneChangedFields :: RealTimeUpdateNotificationUserEntry -> [RealTimeUpdateField]
rtuneTime :: RealTimeUpdateNotificationUserEntry -> Integer

-- | Query the Facebook Graph using FQL.
fqlQuery :: (MonadResource m, MonadBaseControl IO m, FromJSON a) => Text -> Maybe (AccessToken anyKind) -> FacebookT anyAuth m (Pager a)

-- | <tt>newtype</tt> wrapper around <a>UTCTime</a> that is able to parse
--   FQL's time representation as seconds since the Unix epoch.

-- | <i>Deprecated: Deprecated since fb 0.14.7, please use FbUTCTime
--   instead.</i>
newtype FQLTime

-- | <i>Deprecated: Deprecated since fb 0.14.7, please use FbUTCTime
--   instead.</i>
FQLTime :: UTCTime -> FQLTime
unFQLTime :: FQLTime -> UTCTime

-- | <tt>newtype</tt> wrapper around lists that works around FQL's strange
--   lists.
--   
--   For example, if you fetch the <tt>tagged_uids</tt> field from
--   <tt>location_post</tt>, you'll find that Facebook's FQL represents an
--   empty list of tagged UIDs as plain JSON array (<tt>[]</tt>). However,
--   it represents a singleton list as an object <tt>{"1234": 1234}</tt>
--   instead of the much more correct <tt>[1234]</tt>.
--   
--   On the other hand, not all FQL arrays are represented in this bogus
--   manner. Also, some so-called arrays by FQL's documentation are
--   actually objects, see <a>FQLObject</a>.
newtype FQLList a
FQLList :: [a] -> FQLList a
unFQLList :: FQLList a -> [a]

-- | <tt>newtype</tt> wrapper around any object that works around FQL's
--   strange objects.
--   
--   For example, if you fetch the <tt>app_data</tt> field from
--   <tt>stream</tt>, you'll find that empty objects are actually
--   represented as empty lists <tt>[]</tt> instead of a proper empty
--   object <tt>{}</tt>. Also note that FQL's documentation says that
--   <tt>app_data</tt> is an array, which it clear is not. See also
--   <a>FQLList</a>.
newtype FQLObject a
FQLObject :: a -> FQLObject a
unFQLObject :: FQLObject a -> a

-- | Get a list of test users.
getTestUsers :: (MonadResource m, MonadBaseControl IO m) => AppAccessToken -> FacebookT Auth m (Pager TestUser)

-- | Remove an existing test user.
removeTestUser :: (MonadResource m, MonadBaseControl IO m) => TestUser -> AppAccessToken -> FacebookT Auth m Bool

-- | Create a new test user.
createTestUser :: (MonadResource m, MonadBaseControl IO m) => CreateTestUser -> AppAccessToken -> FacebookT Auth m TestUser

-- | Make a friend connection between two test users.
--   
--   This is how Facebook's API work: two calls must be made. The first
--   call has the format: "/userA_id/friends/userB_id" with the access
--   token of user A as query parameter. The second call has the format:
--   "/userB_id/friends/userA_id" with the access token of user B as query
--   parameter. The first call creates a friend request and the second call
--   accepts the friend request.
makeFriendConn :: (MonadResource m, MonadBaseControl IO m) => TestUser -> TestUser -> FacebookT Auth m ()

-- | Create an <a>UserAccessToken</a> from a <a>TestUser</a>. It's
--   incomplete because it will not have the right expiration time.
incompleteTestUserAccessToken :: TestUser -> Maybe UserAccessToken

-- | A Facebook test user.
data TestUser
TestUser :: UserId -> Maybe AccessTokenData -> Maybe Text -> Maybe Text -> Maybe Text -> TestUser
tuId :: TestUser -> UserId
tuAccessToken :: TestUser -> Maybe AccessTokenData
tuLoginUrl :: TestUser -> Maybe Text
tuEmail :: TestUser -> Maybe Text
tuPassword :: TestUser -> Maybe Text

-- | Data type used to hold information of a new test user. This type also
--   accepts a Data.Default value.
data CreateTestUser
CreateTestUser :: CreateTestUserInstalled -> Maybe Text -> Maybe Text -> CreateTestUser
ctuInstalled :: CreateTestUser -> CreateTestUserInstalled
ctuName :: CreateTestUser -> Maybe Text
ctuLocale :: CreateTestUser -> Maybe Text

-- | Specify if the app is to be installed on the new test user. If it is,
--   then you must tell what permissions should be given.
data CreateTestUserInstalled
CreateTestUserNotInstalled :: CreateTestUserInstalled
CreateTestUserInstalled :: [Permission] -> CreateTestUserInstalled
ctuiPermissions :: CreateTestUserInstalled -> [Permission]

-- | Uses Facebook's default. It seems that this is equivalent to
--   <tt>CreateTestUserInstalled []</tt>, but Facebook's documentation is
--   not clear about it.
CreateTestUserFbDefault :: CreateTestUserInstalled

-- | Make a raw <tt>GET</tt> request to Facebook's Graph API.
getObject :: (MonadResource m, MonadBaseControl IO m, FromJSON a) => Text -> [Argument] -> Maybe (AccessToken anyKind) -> FacebookT anyAuth m a

-- | Make a raw <tt>POST</tt> request to Facebook's Graph API.
postObject :: (MonadResource m, MonadBaseControl IO m, FromJSON a) => Text -> [Argument] -> AccessToken anyKind -> FacebookT Auth m a

-- | Make a raw <tt>DELETE</tt> request to Facebook's Graph API.
deleteObject :: (MonadResource m, MonadBaseControl IO m, FromJSON a) => Text -> [Argument] -> AccessToken anyKind -> FacebookT Auth m a

-- | Make a raw <tt>GET</tt> request to the /search endpoint of Facebookâ€™s
--   Graph API. Returns a raw JSON <a>Value</a>.
searchObjects :: (MonadResource m, MonadBaseControl IO m, FromJSON a) => Text -> Text -> [Argument] -> Maybe UserAccessToken -> FacebookT anyAuth m (Pager a)

-- | The identification code of an object.
newtype Id
Id :: Text -> Id
idCode :: Id -> Text

-- | An argument given to an API call.
type Argument = (ByteString, ByteString)

-- | An exception that may be thrown by functions on this package. Includes
--   any information provided by Facebook.
data FacebookException

-- | An exception coming from Facebook.
FacebookException :: Text -> Text -> FacebookException
fbeType :: FacebookException -> Text
fbeMessage :: FacebookException -> Text

-- | An exception coming from the <tt>fb</tt> package's code.
FbLibraryException :: Text -> FacebookException
fbeMessage :: FacebookException -> Text

-- | Retrieves the <a>Text</a> back from a <a>Permission</a>. Most of the
--   time you won't need to use this function, but you may need it if
--   you're a library author.
unPermission :: Permission -> Text
