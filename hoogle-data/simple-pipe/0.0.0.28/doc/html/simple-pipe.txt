-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | simple pipeline library like conduit
--   
--   examples/upperFile.hs
--   
--   <ul>
--   <li>read file (sample.txt)</li>
--   <li>take 3 lines</li>
--   <li>to upper all lines</li>
--   <li>write to stdout</li>
--   </ul>
--   
--   extensions
--   
--   <ul>
--   <li>PackageImports</li>
--   </ul>
--   
--   <pre>
--   import Data.Pipe
--   import Data.Char
--   import System.IO
--   import "monads-tf" Control.Monad.Trans
--   
--   main :: IO ()
--   main = do
--   	_ &lt;- runPipe $ readFileP "sample.txt"
--   	=$= takeP 3
--   	=$= convert (map toUpper)
--   	=$= writeString
--   	return ()
--   
--   readFileP :: FilePath -&gt; Pipe () String IO ()
--   readFileP fp = bracket (openFile fp ReadMode) hClose hRead
--   
--   hRead :: Handle -&gt; Pipe () String IO ()
--   hRead h = do
--   	eof &lt;- lift $ hIsEOF h
--   	if eof then return () else do
--   		l &lt;- lift $ hGetLine h
--   		yield l
--   		hRead h
--   
--   writeString :: Pipe String () IO ()
--   writeString = do
--   	ms &lt;- await
--   	case ms of
--   		Just s -&gt; lift (putStrLn s) &gt;&gt; writeString
--   		_ -&gt; return ()
--   
--   takeP :: Monad m =&gt; Int -&gt; Pipe a a m ()
--   takeP 0 = return ()
--   takeP n = do
--   mx &lt;- await
--   case mx of
--   	Just x -&gt; yield x &gt;&gt; takeP (n - 1)
--   	_ -&gt; return ()
--   </pre>
@package simple-pipe
@version 0.0.0.28

module Data.Pipe.Lazy
class PipeClass pl => PipeLazy pl
toLazy :: (PipeLazy pl, MonadBaseControl IO m) => pl i o m r -> m [o]
instance PipeLazy Pipe

module Data.Pipe
class PipeClass p where p finalize f = p `onBreak` f `onDone` f
runPipe :: (PipeClass p, Monad m) => p i o m r -> m (Maybe r)
(=$=) :: (PipeClass p, Monad m) => p a b m x -> p b c m y -> p a c m y
yield :: (PipeClass p, Monad m) => o -> p i o m ()
await :: (PipeClass p, Monad m) => p i o m (Maybe i)
onBreak :: (PipeClass p, Monad m) => p i o m r -> m b -> p i o m r
onDone :: (PipeClass p, Monad m) => p i o m r -> m b -> p i o m r
finalize :: (PipeClass p, Monad m) => p i o m r -> m b -> p i o m r
mapMonad :: (PipeClass p, Monad m) => (forall a. m a -> m a) -> p i o m r -> p i o m r
mapOut :: (PipeClass p, Monad m) => (o -> o') -> p i o m r -> p i o' m r
mapIn :: (PipeClass p, Monad m) => (i' -> i) -> p i o m r -> p i' o m r

-- | Minimal complete definition: <a>appLeft</a>
class PipeClass pc => PipeChoice pc where appRight f = mapIn mirror . mapOut mirror $ appLeft f where mirror (Left x) = Right x mirror (Right y) = Left y f ++++ g = appLeft f =$= appRight g f |||| g = mapOut untag (f ++++ g) where untag (Left x) = x untag (Right y) = y
appLeft :: (PipeChoice pc, Monad m) => pc b c m r -> pc (Either b d) (Either c d) m r
appRight :: (PipeChoice pc, Monad m) => pc b c m r -> pc (Either d b) (Either d c) m r
(++++) :: (PipeChoice pc, Monad m) => pc b c m r -> pc b' c' m r -> pc (Either b b') (Either c c') m r
(||||) :: (PipeChoice pc, Monad m) => pc b d m r -> pc c d m r -> pc (Either b c) d m r
(=@=) :: (PipeClass p, PipeChoice p, Monad m, Monad (p i (Either a r) m), Monad (p a o m), Monad (p r o m), Monad (p (Either a r) o m)) => p i a m r -> p a o m r' -> p i o m r
runPipe_ :: (PipeClass p, Monad m) => p i o m r -> m ()
convert :: (PipeClass p, Monad m, Monad (p a b m)) => (a -> b) -> p a b m ()
data Pipe i o m r
finally :: (MonadBaseControl IO m, PipeClass p) => p i o m r -> m b -> p i o m r
bracket :: (MonadBaseControl IO m, PipeClass p, MonadTrans (p i o), Monad (p i o m)) => m a -> (a -> m b) -> (a -> p i o m r) -> p i o m r

module Data.Pipe.Flow
before :: (PipeClass p, Monad m, Monad (p a a m)) => (a -> Bool) -> p a a m ()
until :: (PipeClass p, Monad m, Monad (p a a m)) => (a -> Bool) -> p a a m ()
filter :: (PipeClass p, Monad m, Monad (p a a m)) => (a -> Bool) -> p a a m ()

module Data.Pipe.List
fromList :: (Monad m, Monad (p () a m), PipeClass p) => [a] -> p () a m ()

-- | Consume all values from the stream and return as a list. This will
--   pull all values into memory.
toList :: (Monad m, Monad (p a () m), PipeClass p) => p a () m [a]

module Data.Pipe.IO
fromHandle :: (PipeClass p, MonadBase IO m, MonadTrans (p i Char), Monad (p i Char m)) => Handle -> p i Char m ()
toHandle :: (PipeClass p, MonadBase IO m, MonadTrans (p Char o), Monad (p Char o m)) => Handle -> p Char o m ()
fromFile :: (PipeClass p, MonadBaseControl IO m, MonadTrans (p i Char), Monad (p i Char m)) => FilePath -> p i Char m ()
toFile :: (PipeClass p, MonadBaseControl IO m, MonadTrans (p Char o), Monad (p Char o m)) => FilePath -> p Char o m ()
debug :: (PipeClass p, MonadBase IO m, MonadTrans (p a a), Monad (p a a m), Show a) => p a a m ()

module Data.Pipe.ByteString
fromHandle :: (PipeClass p, MonadBase IO m, MonadTrans (p i ByteString), Monad (p i ByteString m)) => Handle -> p i ByteString m ()
toHandle :: (PipeClass p, MonadBase IO m, MonadTrans (p ByteString o), Monad (p ByteString o m)) => Handle -> p ByteString o m ()
fromFile :: (PipeClass p, MonadBaseControl IO m, MonadTrans (p i ByteString), Monad (p i ByteString m)) => FilePath -> p i ByteString m ()
toFile :: (PipeClass p, MonadBaseControl IO m, MonadTrans (p ByteString o), Monad (p ByteString o m)) => FilePath -> p ByteString o m ()
fromHandleLn :: (PipeClass p, MonadBase IO m, MonadTrans (p i ByteString), Monad (p i ByteString m)) => Handle -> p i ByteString m ()
toHandleLn :: (PipeClass p, MonadBase IO m, MonadTrans (p ByteString o), Monad (p ByteString o m)) => Handle -> p ByteString o m ()
fromFileLn :: (PipeClass p, MonadBaseControl IO m, MonadTrans (p i ByteString), Monad (p i ByteString m)) => FilePath -> p i ByteString m ()
toFileLn :: (PipeClass p, MonadBaseControl IO m, MonadTrans (p ByteString o), Monad (p ByteString o m)) => FilePath -> p ByteString o m ()
toLazy :: (PipeClass p, PipeLazy p, MonadBaseControl IO m) => p i ByteString m r -> m ByteString

module Data.Pipe.TChan
fromTChan :: (PipeClass p, MonadBase IO m, MonadTrans (p x a), Monad (p x a m)) => TChan a -> p x a m ()
toTChan :: (PipeClass p, MonadBase IO m, MonadTrans (p a x), Monad (p a x m)) => TChan a -> p a x m ()
fromTChans :: (PipeClass p, MonadBase IO m, MonadTrans (p x a), Monad (p x a m)) => [TChan a] -> p x a m ()
toTChans :: (PipeClass p, MonadBase IO m, MonadTrans (p (a, b) x), Monad (p (a, b) x m)) => [(a -> Bool, TChan b)] -> p (a, b) x m ()
toTChansM :: (PipeClass p, MonadBase IO m, MonadTrans (p (a, b) x), Monad (p (a, b) x m)) => m [(a -> Bool, TChan b)] -> p (a, b) x m ()
