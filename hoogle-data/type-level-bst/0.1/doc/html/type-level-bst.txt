-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | type-level binary search trees in haskell
--   
@package type-level-bst
@version 0.1


-- | An efficient implementation of type-level binary search trees and of
--   dependently-typed extensible records and unions.
--   
--   Comments on some type families and functions contain the time
--   complexity in the Big-O notation on an assumption that <tt>t</tt> (or
--   <tt>t'</tt>) is balanced.
--   
--   This library does not export a <tt>proxy</tt> type. Since
--   <tt>proxy</tt> is polymorphic, you can use your own proxy type, and
--   you can also use the one in <a>Data.Proxy</a>.
module Type.BST

-- | Type-level binary search tree used as an "ordered map".
--   
--   <tt>a</tt> is supposed to be a proper type <tt><a>Item</a> key
--   val</tt> of the kind <tt>*</tt>, where <tt>key</tt> is a key type of
--   an arbitrary kind <tt>val</tt> is a value type of the kind <tt>*</tt>.
--   All <a>Item</a>s in a <a>BST</a> should have different keys.
--   
--   Type inference works very well with <a>BST</a>s, and value types can
--   naturally be <i>polymorphic</i>.
--   
--   If you want to build a new <a>BST</a>, use <a>Fromlist</a>, whose
--   result is guaranteed to be balanced.
data BST a
Leaf :: BST a
Node :: (BST a) -> a -> (BST a) -> BST a

-- | Dependently-typed record, or an <i>extensible</i> record. If you want
--   to build a new <a>Record</a>, use <a>fromlist</a>.

-- | Dependently-typed union, or an <i>extensible</i> union. If you want to
--   build a new <a>Union</a>, use <a>inj</a> or <a>fromsum</a>.
class Fromlistable (as :: [*]) where type family Fromlist as :: BST *
fromlist :: Fromlistable as => List as -> Record (Fromlist as)
class Fromsumable (as :: [*])
fromsum :: Fromsumable as => Sum as -> Union (Fromlist as)
class Foldable (t :: BST *)
virtual :: Foldable t => Record t

-- | <i>O(n)</i>. Convert from a <a>Record</a> to a <a>List</a>.
tolist :: Foldable t => Record t -> List (Tolist t)

-- | <i>O(n)</i>. Convert from a <a>Union</a> to a <a>Sum</a>.
tosum :: Foldable t => Union t -> Sum (Tolist t)

-- | <i>O(n)</i>. Convert from a <a>BST</a> to a type-level sorted list.

-- | <tt>t</tt> has an <a>Item</a> with <tt>key</tt>.
class Searchable t key (At t key) => Accessible (t :: BST *) (key :: k) where type family At t key :: *

-- | <i>O(log n)</i>. Get the value at <tt>key</tt> in a <a>Record</a>.
--   
--   A special version of <a>atX</a> with a tighter context and without
--   <a>Maybe</a>.
at :: Accessible t key => Record t -> proxy key -> At t key

-- | <i>O(log n)</i>. Get the value at <tt>key</tt> in a <a>Union</a>.
--   
--   A special version of <a>projX</a> with a tighter context.
proj :: Accessible t key => Union t -> proxy key -> Maybe (At t key)

-- | <i>O(log n)</i>. Injection to a dependently-typed union. One way to
--   build a <a>Union</a>.
--   
--   A special version of <a>injX</a> with a tighter context and without
--   <a>Maybe</a>.
--   
--   <pre>
--   Just (inj p x) == injX p x
--   </pre>
inj :: Accessible t key => proxy key -> At t key -> Union t

-- | Infix synonym for <a>at</a>.
(!) :: Accessible t key => Record t -> proxy key -> At t key

-- | When f is either <a>Record</a> or <a>Union</a>,
--   
--   <pre>
--   AccessibleF f t key == Accessible t key
--   </pre>
class (Accessible t key, SearchableF f t key (At t key)) => AccessibleF (f :: BST * -> *) (t :: BST *) (key :: k)

-- | <i>O(log n)</i>. <a>smap</a> stands for "super-map". Change the value
--   of the <a>Item</a> at <tt>key</tt> in <tt>f t</tt> by applying the
--   function <tt>At t key -&gt; b</tt>. A special version of <a>smapX</a>
--   with a tighter context.
smap :: AccessibleF f t key => proxy key -> (At t key -> b) -> f t -> f (Smap t key (At t key) b)

-- | <i>O(log n)</i>. <a>supdate</a> stands for "super-update". A special
--   version of <a>supdateX</a> with a tighter context.
--   
--   <pre>
--   supdate p x == smap p (const x)
--   </pre>
supdate :: AccessibleF f t key => proxy key -> b -> f t -> f (Smap t key (At t key) b)

-- | <i>O(log n)</i>. A special version of <a>smap</a> that does not change
--   the value type. A special version of <a>adjustX</a> with a tighter
--   context.
adjust :: AccessibleF f t key => proxy key -> (At t key -> At t key) -> f t -> f t

-- | <i>O(log n)</i>. A special version of <a>supdate</a> that does not
--   change the value type. A special version of <a>updateX</a> with a
--   tighter context.
--   
--   <pre>
--   update p x == adjust p (const x)
--   </pre>
update :: AccessibleF f t key => proxy key -> At t key -> f t -> f t

-- | Infix operator that works almost like <a>smap</a>.
--   
--   <pre>
--   (p |&gt; f) &lt;$*&gt; c = smap p f c
--   </pre>
(<$*>) :: AccessibleF f t key => key |> (At t key -> b) -> f t -> f (Smap t key (At t key) b)
class (Accessible t key, a ~ At t key) => Contains (t :: BST *) (key :: k) (a :: *) | t key -> a
class Contains t key a => ContainedBy (key :: k) (a :: *) (t :: BST *) | t key -> a

-- | <tt>t</tt> <i>may</i> have an <a>Item</a> with a key type <tt>key</tt>
--   and a value type <tt>a</tt>.
--   
--   When <tt><a>Accessible</a> t key</tt>, <tt>a</tt> should be
--   <tt><a>At</a> t key</tt>, but when not, <tt>a</tt> can be any type.
class Smap t key a a ~ t => Searchable (t :: BST *) (key :: k) (a :: *) where type family Smap t key a (b :: *) :: BST *
atX :: Searchable t key a => Record t -> proxy key -> Maybe a
projX :: Searchable t key a => Union t -> proxy key -> Maybe a
injX :: Searchable t key a => proxy key -> a -> Maybe (Union t)

-- | Infix synonym for <a>atX</a>.
(!?) :: Searchable t key a => Record t -> proxy key -> Maybe a

-- | When f is either <a>Record</a> or <a>Union</a>,
--   
--   <pre>
--   SearchableF f t key == Searchable t key
--   </pre>
class Searchable t key a => SearchableF (f :: BST * -> *) (t :: BST *) (key :: k) (a :: *)
smapX :: SearchableF f t key a => proxy key -> (a -> b) -> f t -> f (Smap t key a b)

-- | <i>O(log n)</i>. <a>supdate</a> with a looser context.
supdateX :: SearchableF f t key (At t key) => proxy key -> b -> f t -> f (Smap t key (At t key) b)

-- | <i>O(log n)</i>. <a>adjust</a> with a looser context.
adjustX :: SearchableF f t key a => proxy key -> (a -> a) -> f t -> f t

-- | <i>O(log n)</i>. <a>update</a> with a looser context.
updateX :: SearchableF f t key a => proxy key -> a -> f t -> f t

-- | Infix operator that works almost like <a>smapX</a>.
--   
--   <pre>
--   (p |&gt; f) &lt;$*?&gt; c = smapX p f cz
--   </pre>
(<$*?>) :: SearchableF f t key a => key |> (a -> b) -> f t -> f (Smap t key a b)
class UnioncasableX t t' res => Unioncasable (t :: BST *) (t' :: BST *) (res :: *)

-- | <i>O(log n + log n')</i>. Pattern matching on <tt><a>Union</a> t</tt>,
--   where <tt><a>Record</a> t'</tt> contains functions that return
--   <tt>res</tt> for <i>all</i> items in <tt>t</tt>.
--   
--   A special version of <a>unioncaseX</a> with a tighter context.
unioncase :: Unioncasable t t' res => Union t -> Record t' -> res
class UnioncasableX (t :: BST *) (t' :: BST *) (res :: *)
unioncaseX :: UnioncasableX t t' res => Union t -> Record t' -> res

-- | <tt>t</tt> includes <tt>t'</tt>; in other words, <tt>t</tt> contains
--   all items in <tt>t'</tt>.
class Includes (t :: BST *) (t' :: BST *)

-- | <tt>t</tt> is included by <tt>t'</tt>; in other words, <tt>t'</tt>
--   contains all items in <tt>t</tt>.
--   
--   <pre>
--   IncludedBy t t' == Includes t' t
--   </pre>
class Includes t' t => IncludedBy (t :: BST *) (t' :: BST *)

-- | <i>O(n log n')</i>. A special version of <a>metamorphose</a> with a
--   tighter context guaranteeing the safety of the conversion.
shrink :: (Metamorphosable Record t t', Includes t t') => Record t -> Record t'

-- | <i>O(log n + log n')</i>. A special version of <a>metamorphose</a>
--   with a tighter context guaranteeing the safety of the conversion.
expand :: (Metamorphosable Union t t', IncludedBy t t') => Union t -> Union t'
class (Foldable t, Fromlistable (Tolist t)) => Balanceable (t :: BST *) where type family Balance t :: BST *
balance :: Balanceable t => Record t -> Record (Balance t)
class Metamorphosable (f :: BST * -> *) (t :: BST *) (t' :: BST *)
metamorphose :: Metamorphosable f t t' => f t -> f t'
class Mergeable (t :: BST *) (t' :: BST *) where type family Merge t t' :: BST * type family MergeE t t' :: BST *
merge :: Mergeable t t' => Record t -> Record t' -> Record (Merge t t')
mergeE :: Mergeable t t' => Record t -> Record t' -> Record (MergeE t t')
class Insertable (t :: BST *) (key :: k) where type family Insert t key (a :: *) :: BST *
insert :: Insertable t key => proxy key -> a -> Record t -> Record (Insert t key a)
class Deletable (t :: BST *) (key :: k) where type family Delete t key :: BST *
delete :: Deletable t key => proxy key -> Record t -> Record (Delete t key)
class Minnable (t :: BST *) where type family Findmin t :: *
splitmin :: Minnable t => Record t -> (Findmin t, Record (Deletemin t))

-- | <i>O(log n)</i>. Get the value of the <a>Item</a> at the minimum key
--   in the <a>Record</a>.
--   
--   <pre>
--   findmin = fst . splitmin
--   </pre>
findmin :: Minnable t => Record t -> Findmin t

-- | <i>O(log n)</i>. Delete the <a>Item</a> at the minimum key from the
--   <a>Record</a>.
--   
--   <pre>
--   deletemin = snd . splitmin
--   </pre>
deletemin :: Minnable t => Record t -> Record (Deletemin t)
class Maxable (t :: BST *) where type family Findmax t :: *
splitmax :: Maxable t => Record t -> (Findmax t, Record (Deletemax t))

-- | <i>O(log n)</i>. Get the value of the <a>Item</a> at the maximum key
--   in the <a>Record</a>.
--   
--   <pre>
--   findmin = fst . splitmin
--   </pre>
findmax :: Maxable t => Record t -> Findmax t

-- | <i>O(log n)</i>. Delete the <a>Item</a> at the maximum key from the
--   <a>Record</a>.
--   
--   <pre>
--   deletemin = snd . splitmin
--   </pre>
deletemax :: Maxable t => Record t -> Record (Deletemax t)

-- | <a>Item</a> used in <tt>BST</tt>.
newtype Item key a
Item :: a -> Item key a
value :: Item key a -> a

-- | Infix synonym for <a>Item</a>.
type (|>) = Item

-- | When <tt>x</tt> has a type <tt>T</tt>, <tt>(<a>Item</a> :: <a>With</a>
--   key) x</tt> works as <tt><a>Item</a> x :: <a>Item</a> key T</tt>.
--   
--   Using <a>With</a>, you can avoid writing <tt>T</tt>.
type With key = forall a. a -> Item key a

-- | Give a new key to an <a>Item</a>.
newkey :: Item key a -> proxy key' -> Item key' a

-- | Make an <a>Item</a> setting a key with <tt>proxy</tt>.
item :: proxy key -> a -> Item key a

-- | Infix synonym for <a>item</a>.
(|>) :: proxy key -> a -> Item key a

-- | Dependently-typed list.

-- | Infix synonym for <a>Cons</a>.
(.:.) :: a -> List as -> List (a : as)

-- | Dependently-typed sum.

-- | Compare two types.

-- | The largest type (and kind) on <a>Compare</a>.
data LargestK
Largest :: LargestK

-- | The smallest type (and kind) on <a>Compare</a>.
data SmallestK
Smallest :: SmallestK

-- | Compare two types. Users can add instances.

-- | Conversion of types to readable <a>String</a>s. Analogous to
--   <a>Show</a>.
class Showtype (a :: k) where showtype p = showtypesPrec 0 p "" showtypesPrec _ p s = showtype p ++ s
showtype :: Showtype a => proxy a -> String
showtypesPrec :: Showtype a => Int -> proxy a -> String -> String
