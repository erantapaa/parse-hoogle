-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Database Supported Haskell
--   
--   This is a Haskell library for database-supported program execution.
--   Using this library a relational database management system (RDBMS) can
--   be used as a coprocessor for the Haskell programming language,
--   especially for those program fragments that carry out data-intensive
--   and data-parallel computations.
--   
--   Database executable program fragments can be written using the monad
--   comprehension notation [2] and list processing combinators from the
--   Haskell list prelude. Note that rather than embedding a relational
--   language into Haskell, we turn idiomatic Haskell programs into SQL
--   queries.
--   
--   DSH faithfully represents list order and nesting, and compiles the
--   list processing combinators into relational queries. The
--   implementation avoids unnecessary data transfer and context switching
--   between the database coprocessor and the Haskell runtime by ensuring
--   that the number of generated relational queries is only determined by
--   the program fragment's type and not by the database size.
--   
--   DSH can be used to allow existing Haskell programs to operate on large
--   scale data (e.g., larger than the available heap) or query existing
--   database resident data with Haskell.
--   
--   Note that this package is flagged experimental and therefore is not
--   suited for production use. This is a proof of concept implementation
--   only. To learn more about DSH, our paper entitled as <a>Haskell Boards
--   the Ferry: Database- Supported Program Execution for Haskell</a> [1]
--   is a recommended reading. The package includes a couple of examples
--   that demonstrate how to use DSH.
--   
--   The latest release implements new features described in our
--   work-in-progress paper entitled as <a>Algebraic Data Types for
--   Language-Integrated Queries</a> [3].
--   
--   <ol>
--   
--   <li><a>http://db.inf.uni-tuebingen.de/files/giorgidze/ifl2010.pdf</a></li>
--   
--   <li><a>http://db.inf.uni-tuebingen.de/files/giorgidze/haskell2011.pdf</a></li>
--   
--   <li><a>http://db.inf.uni-tuebingen.de/files/giorgidze/adtq.pdf</a></li>
--   </ol>
@package DSH
@version 0.8.2.3


-- | DSH compiler module exposes the function fromQ that can be used to
--   execute DSH programs on a database. It transform the DSH program into
--   FerryCore which is then translated into SQL (through a table algebra).
--   The SQL code is executed on the database and then processed to form a
--   Haskell value.
module Database.DSH.Compiler

-- | Execute the query on the database
fromQ :: (QA a, IConnection conn) => conn -> Q a -> IO a

-- | Convert the query into unoptimised algebraic plan
debugPlan :: (IConnection conn, Reify a) => conn -> Exp a -> IO String
debugCore :: (IConnection conn, Reify a) => conn -> Exp a -> IO String

-- | Convert the query into optimised algebraic plan
debugPlanOpt :: (IConnection conn, Reify a) => conn -> Exp a -> IO String

-- | Convert the query into SQL
debugSQL :: (IConnection conn, Reify a) => conn -> Exp a -> IO String
debugCoreDot :: (IConnection conn, Reify a) => conn -> Exp a -> IO String


-- | This module provides the reference implementation of DSH by
--   interpreting the embedded representation.
module Database.DSH.Interpreter
fromQ :: (QA a, IConnection conn) => conn -> Q a -> IO a


-- | This module is intended to be imported <tt>qualified</tt>, to avoid
--   name clashes with <a>Prelude</a> functions. For example:
--   
--   <pre>
--   import qualified Database.DSH as Q
--   import Database.DSH (Q)
--   </pre>
--   
--   Alternatively you can hide <a>Prelude</a> and import this module like
--   this:
--   
--   <pre>
--   import Prelude ()
--   import Database.DSH
--   </pre>
--   
--   In this case you still get Prelude definitions that are not provided
--   by Database.DSH.
module Database.DSH
table :: (QA a, TA a) => String -> Q [a]
tableDB :: (QA a, TA a) => String -> Q [a]
tableWithKeys :: (QA a, TA a) => String -> [[String]] -> Q [a]
tableCSV :: (QA a, TA a) => String -> Q [a]
toQ :: QA a => a -> Q a
unit :: Q ()
false :: Q Bool
true :: Q Bool
not :: Q Bool -> Q Bool
(&&) :: Q Bool -> Q Bool -> Q Bool
(||) :: Q Bool -> Q Bool -> Q Bool
eq :: (QA a, Eq a) => Q a -> Q a -> Q Bool
(==) :: (QA a, Eq a) => Q a -> Q a -> Q Bool
neq :: (QA a, Eq a) => Q a -> Q a -> Q Bool
(/=) :: (QA a, Eq a) => Q a -> Q a -> Q Bool
lt :: (QA a, Ord a) => Q a -> Q a -> Q Bool
(<) :: (QA a, Ord a) => Q a -> Q a -> Q Bool
lte :: (QA a, Ord a) => Q a -> Q a -> Q Bool
(<=) :: (QA a, Ord a) => Q a -> Q a -> Q Bool
gte :: (QA a, Ord a) => Q a -> Q a -> Q Bool
(>=) :: (QA a, Ord a) => Q a -> Q a -> Q Bool
gt :: (QA a, Ord a) => Q a -> Q a -> Q Bool
(>) :: (QA a, Ord a) => Q a -> Q a -> Q Bool
min :: (QA a, Ord a) => Q a -> Q a -> Q a
max :: (QA a, Ord a) => Q a -> Q a -> Q a
bool :: QA a => Q a -> Q a -> Q Bool -> Q a
cond :: QA a => Q Bool -> Q a -> Q a -> Q a
ifThenElse :: QA a => Q Bool -> Q a -> Q a -> Q a
(?) :: QA a => Q Bool -> (Q a, Q a) -> Q a
listToMaybe :: QA a => Q [a] -> Q (Maybe a)
maybeToList :: QA a => Q (Maybe a) -> Q [a]
nothing :: QA a => Q (Maybe a)
just :: QA a => Q a -> Q (Maybe a)
isNothing :: QA a => Q (Maybe a) -> Q Bool
isJust :: QA a => Q (Maybe a) -> Q Bool
fromJust :: QA a => Q (Maybe a) -> Q a
maybe :: (QA a, QA b) => Q b -> (Q a -> Q b) -> Q (Maybe a) -> Q b
fromMaybe :: QA a => Q a -> Q (Maybe a) -> Q a
catMaybes :: QA a => Q [Maybe a] -> Q [a]
mapMaybe :: (QA a, QA b) => (Q a -> Q (Maybe b)) -> Q [a] -> Q [b]
pairToEither :: (QA a, QA b) => Q ([a], [b]) -> Q (Either a b)
eitherToPair :: (QA a, QA b) => Q (Either a b) -> Q ([a], [b])
left :: (QA a, QA b) => Q a -> Q (Either a b)
right :: (QA a, QA b) => Q b -> Q (Either a b)
isLeft :: (QA a, QA b) => Q (Either a b) -> Q Bool
isRight :: (QA a, QA b) => Q (Either a b) -> Q Bool
either :: (QA a, QA b, QA c) => (Q a -> Q c) -> (Q b -> Q c) -> Q (Either a b) -> Q c
lefts :: (QA a, QA b) => Q [Either a b] -> Q [a]
rights :: (QA a, QA b) => Q [Either a b] -> Q [b]
partitionEithers :: (QA a, QA b) => Q [Either a b] -> Q ([a], [b])
nil :: QA a => Q [a]
empty :: QA a => Q [a]
cons :: QA a => Q a -> Q [a] -> Q [a]
(<|) :: QA a => Q a -> Q [a] -> Q [a]
snoc :: QA a => Q [a] -> Q a -> Q [a]
(|>) :: QA a => Q [a] -> Q a -> Q [a]
singleton :: QA a => Q a -> Q [a]
head :: QA a => Q [a] -> Q a
tail :: QA a => Q [a] -> Q [a]
take :: QA a => Q Integer -> Q [a] -> Q [a]
drop :: QA a => Q Integer -> Q [a] -> Q [a]
map :: (QA a, QA b) => (Q a -> Q b) -> Q [a] -> Q [b]
append :: QA a => Q [a] -> Q [a] -> Q [a]
(++) :: QA a => Q [a] -> Q [a] -> Q [a]
filter :: QA a => (Q a -> Q Bool) -> Q [a] -> Q [a]
groupWithKey :: (QA a, QA b, Ord b) => (Q a -> Q b) -> Q [a] -> Q [(b, [a])]
groupWith :: (QA a, QA b, Ord b) => (Q a -> Q b) -> Q [a] -> Q [[a]]
sortWith :: (QA a, QA b, Ord b) => (Q a -> Q b) -> Q [a] -> Q [a]
last :: QA a => Q [a] -> Q a
init :: QA a => Q [a] -> Q [a]
null :: QA a => Q [a] -> Q Bool
length :: QA a => Q [a] -> Q Integer
index :: QA a => Q [a] -> Q Integer -> Q a
(!!) :: QA a => Q [a] -> Q Integer -> Q a
reverse :: QA a => Q [a] -> Q [a]
and :: Q [Bool] -> Q Bool
or :: Q [Bool] -> Q Bool
any :: QA a => (Q a -> Q Bool) -> Q [a] -> Q Bool
all :: QA a => (Q a -> Q Bool) -> Q [a] -> Q Bool
sum :: (QA a, Num a) => Q [a] -> Q a
concat :: QA a => Q [[a]] -> Q [a]
concatMap :: (QA a, QA b) => (Q a -> Q [b]) -> Q [a] -> Q [b]
maximum :: (QA a, Ord a) => Q [a] -> Q a
minimum :: (QA a, Ord a) => Q [a] -> Q a
splitAt :: QA a => Q Integer -> Q [a] -> Q ([a], [a])
takeWhile :: QA a => (Q a -> Q Bool) -> Q [a] -> Q [a]
dropWhile :: QA a => (Q a -> Q Bool) -> Q [a] -> Q [a]
span :: QA a => (Q a -> Q Bool) -> Q [a] -> Q ([a], [a])
break :: QA a => (Q a -> Q Bool) -> Q [a] -> Q ([a], [a])
elem :: (QA a, Eq a) => Q a -> Q [a] -> Q Bool
notElem :: (QA a, Eq a) => Q a -> Q [a] -> Q Bool
lookup :: (QA a, QA b, Eq a) => Q a -> Q [(a, b)] -> Q (Maybe b)
zip :: (QA a, QA b) => Q [a] -> Q [b] -> Q [(a, b)]
zipWith :: (QA a, QA b, QA c) => (Q a -> Q b -> Q c) -> Q [a] -> Q [b] -> Q [c]
unzip :: (QA a, QA b) => Q [(a, b)] -> Q ([a], [b])
zip3 :: (QA a, QA b, QA c) => Q [a] -> Q [b] -> Q [c] -> Q [(a, b, c)]
zipWith3 :: (QA a, QA b, QA c, QA d) => (Q a -> Q b -> Q c -> Q d) -> Q [a] -> Q [b] -> Q [c] -> Q [d]
unzip3 :: (QA a, QA b, QA c) => Q [(a, b, c)] -> Q ([a], [b], [c])
nub :: (QA a, Eq a) => Q [a] -> Q [a]
fst :: (QA a, QA b) => Q (a, b) -> Q a
snd :: (QA a, QA b) => Q (a, b) -> Q b
integerToDouble :: Q Integer -> Q Double
return :: QA a => Q a -> Q [a]
(>>=) :: (QA a, QA b) => Q [a] -> (Q a -> Q [b]) -> Q [b]
(>>) :: (QA a, QA b) => Q [a] -> Q [b] -> Q [b]
mzip :: (QA a, QA b) => Q [a] -> Q [b] -> Q [(a, b)]
guard :: Q Bool -> Q [()]
pair :: (QA a, QA b) => Q a -> Q b -> Q (a, b)
triple :: (QA a, QA b, QA c) => Q a -> Q b -> Q c -> Q (a, b, c)
tuple7 :: (QA a_12, QA b_13, QA c_14, QA d_15, QA e_16, QA f_17, QA g_18) => Q a_12 -> Q b_13 -> Q c_14 -> Q d_15 -> Q e_16 -> Q f_17 -> Q g_18 -> Q ((,,,,,,) a_12 b_13 c_14 d_15 e_16 f_17 g_18)
tuple6 :: (QA a_12, QA b_13, QA c_14, QA d_15, QA e_16, QA f_17) => Q a_12 -> Q b_13 -> Q c_14 -> Q d_15 -> Q e_16 -> Q f_17 -> Q ((,,,,,) a_12 b_13 c_14 d_15 e_16 f_17)
tuple5 :: (QA a_12, QA b_13, QA c_14, QA d_15, QA e_16) => Q a_12 -> Q b_13 -> Q c_14 -> Q d_15 -> Q e_16 -> Q ((,,,,) a_12 b_13 c_14 d_15 e_16)
tuple4 :: (QA a_12, QA b_13, QA c_14, QA d_15) => Q a_12 -> Q b_13 -> Q c_14 -> Q d_15 -> Q ((,,,) a_12 b_13 c_14 d_15)
tuple3 :: (QA a_12, QA b_13, QA c_14) => Q a_12 -> Q b_13 -> Q c_14 -> Q ((,,) a_12 b_13 c_14)
tuple2 :: (QA a_12, QA b_13) => Q a_12 -> Q b_13 -> Q ((,) a_12 b_13)
data Q a
class Reify (Rep a) => QA a
class TA a
class (QA a, QA r) => Elim a r
elim :: Elim a r => Q a -> Eliminator a r
class View a
view :: View a => a -> ToView a
deriveDSH :: Name -> Q [Dec]
deriveQA :: Name -> Q [Dec]
deriveTupleRangeQA :: Int -> Int -> Q [Dec]
deriveTA :: Name -> Q [Dec]
deriveTupleRangeTA :: Int -> Int -> Q [Dec]
deriveView :: Name -> Q [Dec]
deriveTupleRangeView :: Int -> Int -> Q [Dec]
deriveElim :: Name -> Q [Dec]
deriveSmartConstructors :: Name -> Q [Dec]
deriveTupleRangeSmartConstructors :: Int -> Int -> Q [Dec]
