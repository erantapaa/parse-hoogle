-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Efficient implementation of lazy monolithic arrays (lazy in indexes).
--   
--   This package built on standard array package adds support for lazy
--   monolithic arrays. Such arrays are lazy not only in their values, but
--   in their indexes as well. Read the paper "Efficient Graph Algorithms
--   Using Lazy Monolithic Arrays"
--   (<a>http://citeseer.ist.psu.edu/95126.html</a>) for further details.
@package lazyarray
@version 0.1.3


-- | This is an implementation of monolithic lazy array. If you want to
--   know what an monolithic lazy array is good for, you can read for
--   example the paper "Efficient Graph Algorithms Using Lazy Monolithic
--   Arrays": <a>http://citeseer.ist.psu.edu/95126.html</a>.
--   
--   This module implements lowlevel lazy array somewhat similar to
--   <tt>Data.LazyArray.lArrayFirst</tt>, so read its description first.
--   This implementation uses no temporary buffer (at least in optimised
--   GHC build) and for index i it returns not the first associated
--   element, but the first 'nonzero' element (or 'zero' if there are no
--   elements). Don't forget to import some kind of arrays when using this
--   module.
--   
--   Benchmark of various implementations of DFS can be found in the
--   <a>Data.LazyArray</a> module.
module Data.LazyArray.Lowlevel

-- | The lazyarray in construction is not classic <a>Array</a>, but has the
--   same parameters.
data LArray i e

-- | Creates an lazy array, using first argument as 'zero' element for this
--   array. The list of associations is left intact until needed by
--   <a>laAt</a> or <a>laFreeze</a>.
laCreate :: Ix i => e -> (i, i) -> [(i, e)] -> LArray i e

-- | Returns an element on the i-th position of the lazy array. If it was
--   already found, just return it. If it was not found yet, consume the
--   list of associations until it is empty or the 'nonzero' association
--   for i is found. If no 'nonzero' association is found, returns 'zero'.
--   All visited elements from the association list are processed and not
--   visited any more.
--   
--   When not concerned about the laziness and time complexity,
--   
--   <pre>
--   (laCreate zero bnds assoc) `laAt` i = zero `fromMaybe` (find (\(i',e)-&gt;i'==i &amp;&amp; e/=zero) assoc)
--   </pre>
laAt :: (Ix i, Eq e) => LArray i e -> i -> e

-- | Convert lazy array to <a>Array</a>. Because the result is not lazy,
--   this function <i>forces the evaluation of the whole association
--   list</i> before returning, so it should be used when the lazy array is
--   fully contructed (ie. the association list is ended by []).
--   
--   Once again - this function is really "non-lazy", as it traverses the
--   whole associtation list, no matter which elements from the resulting
--   <a>Array</a> will be needed. Even if only 1-st element is needed and
--   even if it could already be found, the whole rest of the association
--   list is processed. (Small heuristic is implemented - when all members
--   of resulting Array are 'nonzero', the traversal of the association
--   list is stopped.)
--   
--   This function uses <tt>Data.Array.MArray.unsafeFreeze</tt> to convert
--   <a>IOArray</a> to <a>Array</a>. It is used after the whole association
--   list is processed, so it is safe, and when using optimised GHC build,
--   it imposes no time or space overhead.
laFreeze :: (Ix i, Eq e) => LArray i e -> Array i e

-- | This method creates lazy array using <a>Nothing</a> for 'zero'
--   element. It is just a simple wrapper of <a>laCreate</a>:
--   
--   <pre>
--   mlaCreate bnds assoc = laCreate Nothing bnds (map (\(i,e)-&gt;(i,Just e)) assoc)
--   </pre>
mlaCreate :: Ix i => (i, i) -> [(i, e)] -> LArray i (Maybe e)


-- | This is an implementation of monolithic lazy array. If you want to
--   know what an monolithic lazy array is good for, you can read for
--   example the paper "Efficient Graph Algorithms Using Lazy Monolithic
--   Arrays" (<a>http://citeseer.ist.psu.edu/95126.html</a>).
--   
--   Module <a>Data.LazyArray</a> implements the monolithic lazy array
--   using <a>Array</a> with temporary buffer. For implementation without
--   the temporary buffer see <a>Data.LazyArray.Lowlevel</a> module.
--   
--   Don't forget to import some kind of arrays when using this module.
--   Results of small benchmark and a discussion can be found at the bottom
--   of this page.
module Data.LazyArray

-- | This function returns an array, which i-th element is a list, that
--   contains all values associated with i in the list of associations, in
--   that order. In other words, the result of <tt>lArray bnds assoc</tt>
--   is
--   
--   <tt>lArray bnds assoc = array bnds [(i,[e|(i',e)&lt;-assoc,i'==i] |
--   i&lt;-range bnds]</tt>.
--   
--   The important difference between the two sides of previous equation is
--   that <tt>lArray</tt> works in linear time, ie. each member in the
--   <tt>assoc</tt> list is accessed exactly once, and <tt>lArray</tt> is
--   lazy in its second argument. It means the <tt>assoc</tt> list is left
--   intact until an i-th element of the resulting array needs to be
--   evaluated. At that time the <tt>assoc</tt> list is examined until the
--   first pair (i,e') is found. Until such pair is found, processed
--   elements of <tt>assoc</tt> are stored at appropriate indexes in the
--   resulting array.
--   
--   The implementation uses temporary array for such processed elements of
--   <tt>assoc</tt> list, that were not yet 'requested' [or 'evaluated'] in
--   the resulting array. This array can be freed when all lists of the
--   resulting array are fully evaluated.
--   
--   Here is an example of how to use the monolithic lazy array. Given a
--   graph of type <a>Array</a> <a>Int</a> [<a>Int</a>] we construct the
--   dfs numbering from a given vertex. Obviously, only the first element
--   of the <tt>lArray</tt> is needed - <a>lArrayFirst</a>,
--   <a>lArrayMaybe</a> or <a>Data.LazyArray.Lowlevel</a> are better choice
--   here.
--   
--   <pre>
--   dnum::Array Int [Int]-&gt;Int-&gt;Array Int (Maybe Int)
--   dnum g s = amap listToMaybe marks where
--      list = dfs' [s] 0
--      marks = lArray (bounds g) list
--      dfs' []     _ = []
--      dfs' (s:ss) n = (s,n) : if n == head (marks!s) then dfs' ((g!s)++ss) (n+1) else dfs' ss n
--   </pre>
lArray :: Ix i => (i, i) -> [(i, e)] -> Array i [e]

-- | It is often needed to apply some function to the list of elements
--   belonging to the same index. Function <tt>lArrayMap</tt> is provided,
--   and could be defined like <tt>lArrayMap f = (amap f) . lArray</tt>.
--   Obviously, <tt>lArray = lArrayMap id</tt>.
lArrayMap :: Ix i => ([e] -> e') -> (i, i) -> [(i, e)] -> Array i e'

-- | This is equivalent to <tt>lArrayMaybe = lArrayMap listToMaybe</tt> but
--   a bit faster.
lArrayMaybe :: Ix i => (i, i) -> [(i, e)] -> Array i (Maybe e)

-- | This is equivalent to <tt>lArrayFirst zero = lArrayMap (\x-&gt;case x
--   of []-&gt;zero; e:_-&gt;e)</tt> but a bit faster.
lArrayFirst :: Ix i => e -> (i, i) -> [(i, e)] -> Array i e
