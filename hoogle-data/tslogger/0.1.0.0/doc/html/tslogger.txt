-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Thread-safe logging.
--   
@package tslogger
@version 0.1.0.0


-- | Thread-safe Logging with bonus controlled-schedule debugging
--   capabilities.
--   
--   This module supports logging to memory, serializing messages and
--   deferring the work of actually printing them. Another thread can flush
--   the logged messages at its leisure.
--   
--   The second capability of this infrastructure is to use the debugging
--   print messages as points at which to gate the execution of the
--   program. That is, each <tt>logStrLn_</tt> call becomes a place where
--   the program blocks and checks in with a central coordinator, which
--   only allows one thread to unblock at a time. Thus, if there are
--   sufficient debug logging messages in the program, this can enable a
--   form of deterministic replay (and quickcheck-style testing of
--   different interleavings).
module System.Log.TSLogger

-- | Debugging flag shared by several modules. This is activated by setting
--   the environment variable <tt>DEBUG=1..5</tt>.
--   
--   By convention <tt>DEBUG=100</tt> turns on full sequentialization of
--   the program and control over the interleavings in concurrent code,
--   enabling systematic debugging of concurrency problems.
dbgLvl :: Int

-- | This codifies the convention of keeping fine-grained
--   pre-each-memory-modification messages at higher debug levels. These
--   are used for fuzz testing concurrent interleavings. Setting
--   <a>dbgRange</a> in the <a>DbgCfg</a> to this value should give you
--   only the messages necessary for stress testing schedules.
defaultMemDbgRange :: (Int, Int)

-- | Create a new logger, which includes forking a coordinator thread.
--   Takes as argument the number of worker threads participating in the
--   computation.
newLogger :: (Int, Int) -> [OutDest] -> WaitMode -> IO Logger

-- | Write a log message from the current thread, IF the level of the
--   message falls into the range accepted by the given <a>Logger</a>,
--   otherwise, the message is ignored.
logOn :: Logger -> LogMsg -> IO ()

-- | A Logger coordinates a set of threads that print debug logging
--   messages.
--   
--   This are abstract objects supporting only the operations provided by
--   this module and the non-hidden fields of the Logger.
data Logger

-- | Several different ways we know to wait for quiescence in the
--   concurrent mutator before proceeding.
data WaitMode

-- | UNFINISHED: Dynamically track tasks/workers. The num workers starts at
--   1 and then is modified with <a>incrTasks</a> and <a>decrTasks</a>.
WaitDynamic :: WaitMode

-- | A fixed set of threads must check-in each round before proceeding.
WaitNum :: Int -> IO Int -> WaitMode

-- | How many threads total must check in?
numThreads :: WaitMode -> Int

-- | Poll how many threads WON'T participate this round. After all
--   *productive* threads have checked in this number must grow to
--   eventually include all other threads.
downThreads :: WaitMode -> IO Int

-- | In this mode, logging calls are non-blocking and return immediately,
--   rather than waiting on a central coordinator. This is what we want if
--   we're simply printing debugging output, not controlling the schedule
--   for stress testing.
DontWait :: WaitMode

-- | We allow logging in O(1) time in String or ByteString format. In
--   practice the distinction is not that important, because only *thunks*
--   should be logged; the thread printing the logs should deal with
--   forcing those thunks.
data LogMsg
StrMsg :: Int -> String -> LogMsg
lvl :: LogMsg -> Int
body :: LogMsg -> String

-- | This sort of message is chatter and NOT meant to participate in the
--   scheduler-testing framework. | ByteStrMsg { lvl::Int, }
OffTheRecord :: Int -> String -> LogMsg
lvl :: LogMsg -> Int
obod :: LogMsg -> String
mapMsg :: (String -> String) -> LogMsg -> LogMsg

-- | A destination for log messages
data OutDest

-- | Output via GHC's <tt>traceEvent</tt> runtime events.
OutputEvents :: OutDest

-- | Printed human-readable output to a handle.
OutputTo :: Handle -> OutDest

-- | Accumulate output in memory and flush when appropriate.
OutputInMemory :: OutDest

-- | Exceptions that walk up the fork-tree of threads.
--   
--   WARNING: By holding onto the ThreadId we keep the parent thread from
--   being garbage collected (at least as of GHC 7.6). This means that even
--   if it was complete, it will still be hanging around to accept the
--   exception below.
forkWithExceptions :: (IO () -> IO ThreadId) -> String -> IO () -> IO ThreadId

-- | The state for an exponential backoff.
data Backoff

-- | Create an object used for exponentential backoff; see <a>backoff</a>.
newBackoff :: Int -> IO Backoff

-- | Perform the backoff, possibly delaying the thread.
backoff :: Backoff -> IO Backoff

-- | DebugConfig: what level of debugging support is activated?
data DbgCfg
DbgCfg :: Maybe (Int, Int) -> [OutDest] -> Bool -> DbgCfg

-- | Inclusive range of debug messages to accept (i.e. filter on priority
--   level). If Nothing, use the default level, which is (0,N) where N is
--   controlled by the DEBUG environment variable. The convention is to use
--   Just (0,0) to disable logging.
dbgRange :: DbgCfg -> Maybe (Int, Int)

-- | Destinations for debug log messages.
dbgDests :: DbgCfg -> [OutDest]

-- | In additional to logging debug messages, control thread interleaving
--   at these points when this is True.
dbgScheduling :: DbgCfg -> Bool
instance Show WaitMode
instance Show LogMsg
instance Eq LogMsg
instance Ord LogMsg
instance Read LogMsg
instance Show Backoff
instance Show (IO Int)
instance Show (IO Bool)
