-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Parse source to template-haskell abstract syntax.
--   
--   The translation from haskell-src-exts abstract syntax to
--   template-haskell abstract syntax isn't 100% complete yet.
@package haskell-src-meta-mwotton
@version 0.1.0


-- | Here!
module Language.Haskell.Meta.QQ.Here
here :: QuasiQuoter


module Language.Haskell.Meta.Syntax.Translate
class ToName a
toName :: (ToName a) => a -> Name
class ToLit a
toLit :: (ToLit a) => a -> Lit
class ToType a
toType :: (ToType a) => a -> Type
class ToPat a
toPat :: (ToPat a) => a -> Pat
class ToExp a
toExp :: (ToExp a) => a -> Exp
class ToDec a
toDec :: (ToDec a) => a -> Dec
class ToStmt a
toStmt :: (ToStmt a) => a -> Stmt
class ToLoc a
toLoc :: (ToLoc a) => a -> Loc
class ToKind a
toKind :: (ToKind a) => a -> Kind
class ToTVB a
toTVB :: (ToTVB a) => a -> TyVarBndr
class ToPred a
toPred :: (ToPred a) => a -> Pred
errorMsg :: (Typeable a) => String -> a -> String
toFieldExp :: FieldUpdate -> FieldExp
(.->.) :: Type -> Type -> Type
foldAppT :: Type -> [Type] -> Type
hsBindsToDecs :: Binds -> [Dec]
hsBangTypeToStrictType :: BangType -> (Strict, Type)
qualConDeclToCon :: QualConDecl -> Con
conDeclToCon :: ConDecl -> Con
bangToVarStrictTypes :: [Name] -> BangType -> [VarStrictType]
bangToStrictType :: BangType -> StrictType
hsMatchesToFunD :: [Match] -> Dec
hsMatchToClause :: Match -> Clause
hsRhsToBody :: Rhs -> Body
hsGuardedRhsToBody :: GuardedRhs -> Body
hsStmtToGuard :: Stmt -> Guard
instance ToDec Decl
instance ToStmt Stmt
instance ToType Asst
instance ToType Type
instance ToPred Asst
instance ToKind Kind
instance ToTVB TyVarBind
instance ToName TyVarBind
instance ToLoc SrcLoc
instance ToExp Splice
instance ToExp Exp
instance ToExp QOp
instance ToPat Pat
instance ToLit Literal
instance ToName QName
instance ToName SpecialCon
instance ToName Module
instance ToName Name
instance ToName String
instance ToLit Double
instance ToLit Float
instance ToLit Int
instance ToLit Integer
instance ToLit String
instance ToLit Char
instance (ToPat a, ToPat b, ToPat c, ToPat d) => ToPat (a, b, c, d)
instance (ToPat a, ToPat b, ToPat c) => ToPat (a, b, c)
instance (ToPat a, ToPat b) => ToPat (a, b)
instance (ToPat a) => ToPat [a]
instance ToPat Lit
instance (ToExp a, ToExp b, ToExp c, ToExp d) => ToExp (a, b, c, d)
instance (ToExp a, ToExp b, ToExp c) => ToExp (a, b, c)
instance (ToExp a, ToExp b) => ToExp (a, b)
instance (ToExp a) => ToExp [a]
instance ToExp Lit


module Language.Haskell.Meta.Syntax.Vars
class Vars e v
vars :: (Vars e v, Ord v) => e -> Set v
fvs :: (Vars e v, Ord v) => e -> Set v
bvs :: (Vars e v, Ord v) => e -> Set v
instance Vars Stmt Name
instance Vars Guard Name
instance Vars Body Name
instance Vars Clause Name
instance Vars Dec Name
instance Vars Match Name
instance Vars Exp Name
instance Vars Range Name
instance Vars Pat Name
instance (Vars e v) => Vars [e] v


module Language.Haskell.TH.Instances.Lift
instance Ord InlineSpec
instance Ord Pred
instance Ord TyVarBndr
instance Ord Pragma
instance Ord FamFlavour
instance Ord Kind
instance Ord Lit
instance Ord Pat
instance Ord Match
instance Ord Range
instance Ord Guard
instance Ord Callconv
instance Ord Safety
instance Ord Strict
instance Ord Clause
instance Ord Body
instance Ord Con
instance Ord FunDep
instance Ord Foreign
instance Ord Type
instance Ord Stmt
instance Ord Dec
instance Ord Exp
instance Lift FixityDirection
instance Lift Fixity
instance Lift Info
instance Lift Type
instance Lift Range
instance Lift Stmt
instance Lift Match
instance Lift Safety
instance Lift Callconv
instance Lift Foreign
instance Lift FunDep
instance Lift Strict
instance Lift Guard
instance Lift Clause
instance Lift Con
instance Lift Body
instance Lift Pat
instance Lift Lit
instance Lift Exp
instance Lift Dec
instance Lift NameSpace
instance Lift NameFlavour
instance Lift FamFlavour
instance Lift Kind
instance Lift TyVarBndr
instance Lift Pred
instance Lift InlineSpec
instance Lift Pragma
instance Lift OccName
instance Lift PkgName
instance Lift ModName
instance Lift Name
instance Lift Rational
instance Ppr Lit
instance Ppr Loc
instance Eq Loc
instance Show Loc
instance Lift ()


module Language.Haskell.Meta.Syntax


module Language.Haskell.Meta.Parse
parsePat :: String -> Either String Pat
parseExp :: String -> Either String Exp
parseType :: String -> Either String Type
parseDecs :: String -> Either String [Dec]
myDefaultParseMode :: ParseMode
myDefaultExtensions :: [Extension]
parseResultToEither :: ParseResult a -> Either String a
parseHsModule :: String -> Either String Module
parseHsDecls :: String -> Either String [Decl]
parseHsType :: String -> Either String Type
parseHsExp :: String -> Either String Exp
parseHsPat :: String -> Either String Pat
pprHsModule :: Module -> String
moduleDecls :: Module -> [Decl]
emptySrcLoc :: SrcLoc
emptyHsModule :: String -> Module


module Language.Haskell.Meta


-- | This module is a staging ground for to-be-organized-and-merged-nicely
--   code.
module Language.Haskell.Meta.Utils
cleanNames :: (Data a) => a -> a

-- | The type passed in must have a <tt>Show</tt> instance which produces a
--   valid Haskell expression. Returns an empty <tt>String</tt> if this is
--   not the case. This is not TH-specific, but useful in general.
pretty :: (Show a) => a -> String
pp :: (Data a, Ppr a) => a -> String
ppDoc :: (Data a, Ppr a) => a -> Doc
gpretty :: (Data a) => a -> String

-- | <pre>
--   unQ = unsafePerformIO . runQ
--   </pre>
unQ :: Q a -> a
nameToRawCodeStr :: Name -> String
(|$|) :: ExpQ -> ExpQ -> ExpQ
(|.|) :: ExpQ -> ExpQ -> ExpQ
(|->|) :: TypeQ -> TypeQ -> TypeQ
unForall :: Type -> Type
functionT :: [TypeQ] -> TypeQ
mkVarT :: String -> TypeQ
myNames :: [Name]
tvbName :: TyVarBndr -> Name

-- | Stolen from Igloo's th-lift.
--   
--   Produces pretty code suitable for human consumption.
splitCon :: Con -> (Name, [Type])
strictTypeTy :: StrictType -> Type
varStrictTypeTy :: VarStrictType -> Type
conTypes :: Con -> [Type]
conToConType :: Type -> Con -> Type
decCons :: Dec -> [Con]
decTyVars :: Dec -> [Name]
decName :: Dec -> Maybe Name
foreignName :: Foreign -> Name
unwindT :: Type -> [Type]
unwindE :: Exp -> [Exp]

-- | The arity of a Type.
arityT :: Type -> Int
typeToName :: Type -> Maybe Name

-- | Randomly useful.
nameSpaceOf :: Name -> Maybe NameSpace
conName :: Con -> Name
recCName :: Con -> Maybe Name
dataDCons :: Dec -> [Con]
fromDataConI :: Info -> Q (Maybe Exp)
fromTyConI :: Info -> Maybe Dec
mkFunD :: Name -> [Pat] -> Exp -> Dec
mkClauseQ :: [PatQ] -> ExpQ -> ClauseQ

-- | The strategy for producing QuasiQuoters which this datatype aims to
--   facilitate is as follows. Given a collection of datatypes which make
--   up the to-be-quasiquoted languages AST, make each type in this
--   collection an instance of at least <tt>Show</tt> and <tt>Lift</tt>.
--   Now, assuming <tt>parsePat</tt> and <tt>parseExp</tt>, both of type
--   <tt>String -&gt; Q a</tt> (where <tt>a</tt> is the top level type of
--   the AST), are the pair of functions you wish to use for parsing in
--   pattern and expression context respectively, put them inside a
--   <tt>Quoter</tt> datatype and pass this to quasify.
data Quoter a
Quoter :: ((Lift a) => String -> Q a) -> ((Show a) => String -> Q a) -> Quoter a
expQ :: Quoter a -> (Lift a) => String -> Q a
patQ :: Quoter a -> (Show a) => String -> Q a
quasify :: (Show a, Lift a) => Quoter a -> QuasiQuoter
toExpQ :: (Lift a) => (String -> Q a) -> (String -> ExpQ)
toPatQ :: (Show a) => (String -> Q a) -> (String -> PatQ)
showToPatQ :: (Show a) => a -> PatQ
eitherQ :: (e -> String) -> Either e a -> Q a
normalizeT :: (Data a) => a -> a
instance Typeable QuasiQuoter
instance Typeable1 Q
instance Show (Q Doc)
instance Show (Q String)
instance Show TypeQ
instance Show DecQ
instance Show (Q [Dec])
instance Show ExpQ


-- | Eat your face!
module Language.Haskell.Meta.QQ.Hs

-- | <pre>
--   ghci&gt; [$hs|\x -&gt; (x,x)|] 42
--   (42,42)
--   ghci&gt; (\[$hs|a@(x,_)|] -&gt; (a,x)) (42,88)
--   ((42,88),42)
--   </pre>
hs :: QuasiQuoter
pat :: QuasiQuoter

module Language.Haskell.Meta.QQ.HsHere
here :: QuasiQuoter
instance Typeable Here
instance Eq Here
instance Show Here
instance Data Here
instance Lift Here


-- | Idiom brackets. Vixey's idea.
module Language.Haskell.Meta.QQ.Idiom
i :: QuasiQuoter

module Language.Haskell.Meta.QQ.BF
bf :: QuasiQuoter
bf2 :: QuasiQuoter
bfHelloWorld :: String
instance Eq Bf
instance Ord Bf
instance Read Bf
instance Show Bf
instance Show Mem
instance Lift Bf

module Language.Haskell.Meta.QQ.SKI
data SKI
S :: SKI
K :: SKI
I :: SKI
E :: Exp -> SKI
(:$) :: SKI -> SKI -> SKI
ski :: QuasiQuoter
instance Typeable SKI
instance Eq SKI
instance Data SKI
instance Show SKI
instance Lift SKI
