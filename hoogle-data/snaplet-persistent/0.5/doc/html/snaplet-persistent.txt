-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | persistent snaplet for the Snap Framework
--   
@package snaplet-persistent
@version 0.5

module Snap.Snaplet.Persistent

-- | Initialize Persistent with an initial SQL function called right after
--   the connection pool has been created. This is most useful for calling
--   migrations upfront right after initialization.
--   
--   Example:
--   
--   <pre>
--   initPersist (runMigrationUnsafe migrateAll)
--   </pre>
--   
--   where migrateAll is the migration function that was auto-generated by
--   the QQ statement in your persistent schema definition in the call to
--   <tt>mkMigrate</tt>.
initPersist :: SqlPersistT (NoLoggingT IO) a -> SnapletInit b PersistState

-- | Backend-agnostic initalization with an initial SQL function called
--   right after the connection pool has been created. This is most useful
--   for calling migrations upfront right after initialization.
--   
--   Example:
--   
--   <pre>
--   initPersist mkPool (runMigrationUnsafe migrateAll)
--   </pre>
--   
--   where migrateAll is the migration function that was auto-generated by
--   the QQ statement in your persistent schema definition in the call to
--   <tt>mkMigrate</tt>.
--   
--   mkPool is a function to construct a pool of connections to your
--   database
initPersistGeneric :: Initializer b PersistState (Pool SqlBackend) -> SqlPersistT (NoLoggingT IO) a -> SnapletInit b PersistState
newtype PersistState
PersistState :: ConnectionPool -> PersistState
persistPool :: PersistState -> ConnectionPool

-- | Implement this type class to have any monad work with
--   snaplet-persistent. A default instance is provided for (Handler b
--   PersistState).
class MonadIO m => HasPersistPool m
getPersistPool :: HasPersistPool m => m ConnectionPool

-- | Constructs a connection pool from Config.
mkPgPool :: MonadIO m => Config -> m ConnectionPool

-- | Conscruts a connection pool in a snaplet context.
mkSnapletPgPool :: (MonadIO (m b v), MonadSnaplet m) => m b v ConnectionPool

-- | Runs a SqlPersist action in any monad with a HasPersistPool instance.
runPersist :: HasPersistPool m => SqlPersistT (ResourceT (NoLoggingT IO)) b -> m b

-- | Run a database action
withPool :: MonadIO m => ConnectionPool -> SqlPersistT (ResourceT (NoLoggingT IO)) a -> m a

-- | Make a Key from an Int.
mkKey :: ToBackendKey SqlBackend entity => Int -> Key entity

-- | Makes a Key from a ByteString. Calls error on failure.
mkKeyBS :: ToBackendKey SqlBackend entity => ByteString -> Key entity

-- | Makes a Key from Text. Calls error on failure.
mkKeyT :: ToBackendKey SqlBackend entity => Text -> Key entity

-- | Makes a Text representation of a Key.
showKey :: ToBackendKey SqlBackend e => Key e -> Text

-- | Makes a ByteString representation of a Key.
showKeyBS :: ToBackendKey SqlBackend e => Key e -> ByteString

-- | Converts a Key to Int. Fails with error if the conversion fails.
mkInt :: ToBackendKey SqlBackend a => Key a -> Int

-- | Converts a Key to Word64. Fails with error if the conversion fails.
mkWord64 :: ToBackendKey SqlBackend a => Key a -> Word64

-- | Follows a foreign key field in one entity and retrieves the
--   corresponding entity from the database.
followForeignKey :: (PersistEntity a, HasPersistPool m, PersistEntityBackend a ~ SqlBackend) => (t -> Key a) -> Entity t -> m (Maybe (Entity a))
fromPersistValue' :: PersistField c => PersistValue -> c
instance MonadIO m => HasPersistPool (ReaderT ConnectionPool m)
instance HasPersistPool (Handler b PersistState)
instance HasPersistPool m => HasPersistPool (NoLoggingT m)

module Snap.Snaplet.Auth.Backends.Persistent
data PersistAuthManager

-- | Initializer that gets AuthSettings from a config file.
initPersistAuthManager :: SnapletLens b SessionManager -> ConnectionPool -> SnapletInit b (AuthManager b)

-- | Initializer that lets you specify AuthSettings.
initPersistAuthManager' :: AuthSettings -> SnapletLens b SessionManager -> ConnectionPool -> SnapletInit b (AuthManager b)

-- | The list of entity definitions this snaplet exposes. You need them so
--   that you can append to your application's list of entity definitions
--   and perform the migration in one block.
--   
--   See how this example combined an app's own entity definitions and the
--   auth snaplet's in one migration block:
--   
--   <pre>
--   share [mkMigrate "migrateAll"] $
--      authEntityDefs ++
--      $(persistFileWith lowerCaseSettings "schema.txt")
--   </pre>
authEntityDefs :: [EntityDef]
data SnapAuthUser
SnapAuthUser :: !Text -> !Text -> !Text -> !(Maybe UTCTime) -> !(Maybe UTCTime) -> !(Maybe Text) -> !Int -> !Int -> !(Maybe UTCTime) -> !(Maybe UTCTime) -> !(Maybe UTCTime) -> !(Maybe Text) -> !(Maybe Text) -> !UTCTime -> !UTCTime -> !(Maybe Text) -> !(Maybe UTCTime) -> !String -> !String -> SnapAuthUser
snapAuthUserLogin :: SnapAuthUser -> !Text
snapAuthUserEmail :: SnapAuthUser -> !Text
snapAuthUserPassword :: SnapAuthUser -> !Text
snapAuthUserActivatedAt :: SnapAuthUser -> !(Maybe UTCTime)
snapAuthUserSuspendedAt :: SnapAuthUser -> !(Maybe UTCTime)
snapAuthUserRememberToken :: SnapAuthUser -> !(Maybe Text)
snapAuthUserLoginCount :: SnapAuthUser -> !Int
snapAuthUserFailedLoginCount :: SnapAuthUser -> !Int
snapAuthUserLockedOutUntil :: SnapAuthUser -> !(Maybe UTCTime)
snapAuthUserCurrentLoginAt :: SnapAuthUser -> !(Maybe UTCTime)
snapAuthUserLastLoginAt :: SnapAuthUser -> !(Maybe UTCTime)
snapAuthUserCurrentIp :: SnapAuthUser -> !(Maybe Text)
snapAuthUserLastIp :: SnapAuthUser -> !(Maybe Text)
snapAuthUserCreatedAt :: SnapAuthUser -> !UTCTime
snapAuthUserUpdatedAt :: SnapAuthUser -> !UTCTime
snapAuthUserResetToken :: SnapAuthUser -> !(Maybe Text)
snapAuthUserResetRequestedAt :: SnapAuthUser -> !(Maybe UTCTime)
snapAuthUserRoles :: SnapAuthUser -> !String
snapAuthUserMeta :: SnapAuthUser -> !String
type SnapAuthUserId = Key SnapAuthUser
migrateAuth :: Migration

-- | Function to convert a <a>SnapAuthUser</a> entity into the auth
--   snaplet's <a>AuthUser</a>.
db2au :: Entity SnapAuthUser -> AuthUser

-- | Splices for <a>SnapAuthUser</a> that are equivalent to the ones for
--   <a>AuthUser</a>.
dbUserSplices :: Monad n => Splices (RuntimeSplice n (Entity SnapAuthUser) -> Splice n)

-- | Get the db key from an <a>AuthUser</a>
userDBKey :: AuthUser -> Maybe SnapAuthUserId
textPassword :: Password -> Text
instance IAuthBackend PersistAuthManager
