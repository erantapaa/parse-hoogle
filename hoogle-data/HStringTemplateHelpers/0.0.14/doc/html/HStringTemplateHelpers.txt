-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Convenience functions and instances for HStringTemplate
--   
--   Convenience functions and instances for HStringTemplate. I will
--   deprecate this package if its contents are integrated into
--   HStringTemplate.
@package HStringTemplateHelpers
@version 0.0.14


-- | Functions I found useful for doing webapps with HStringTemplate.
--   
--   More usage examples can be found by grep -r
--   "Text.StringTemplate.Helpers" in happs-tutorial, on hackage.
module Text.StringTemplate.Helpers

-- | Helper function to calculate a map of directory groups from a
--   top-level directory
--   
--   Each directory gives rise to its own groups.
--   
--   Groups are independent; groups from higher in the directory structure
--   do not have access to groups lower.
--   
--   The top group has key "." (mnemonic, current directory), other groups
--   have key names of subdirectories, including the starting ., eg
--   "./templates/path/to/subdir"
directoryGroups' :: (FilePath -> IO a) -> FilePath -> IO (Map FilePath a)

-- | Strict directoryGroups, which is the right thing.
directoryGroups :: Stringable a => FilePath -> IO (Map FilePath (STGroup a))

-- | Non-strict. I'm pretty sure this is wrong. Based on default
--   directoryGroup function in HStringTemplate package
directoryGroupsOld :: Stringable a => FilePath -> IO (Map FilePath (STGroup a))

-- | The STGroup can't be shown in a useful way because it's a function
--   type, but you can at least show the directories via Data.Map.keys.
dirgroupKeys :: Stringable a => STDirGroups a -> [FilePath]

-- | <pre>
--   example: getTG "./baselayout" ts'
--   </pre>
getTemplateGroup :: Stringable a => FilePath -> STDirGroups a -> STGroup a

-- | <pre>
--   example: renderTemplateDirGroup ts' "./baselayout" "base" 
--   </pre>
renderTemplateDirGroup :: ToSElem a => STDirGroups String -> FilePath -> String -> [(String, a)] -> String
lookupDirgroup :: Stringable a => FilePath -> STDirGroups a -> Maybe (STGroup a)

-- | Chooses a template from an STGroup, or errors if not found.
--   
--   Render that template using attrs.
--   
--   If a template k/v pair is repeated, it appears twice. (Perhaps a clue
--   to buggy behavior?)
--   
--   Repeated keys could be eliminated by running clean:
--   
--   <pre>
--   clean = nubBy (\(a1,b1) (a2,b2) -&gt; a1 == a2) . sortBy (\(a1,b1) (a2,b2) -&gt; a1 `compare` a2)
--   </pre>
--   
--   The ToSElem type is probably either String or [String]
renderTemplateGroup :: ToSElem a => STGroup String -> [(String, a)] -> [Char] -> String

-- | <pre>
--   render1 [("name","Bill")] "Hi, my name is $name$"
--   render1 attribs tmpl = render . setManyAttrib attribs . newSTMP $ tmpl
--   </pre>
render1 :: [(String, String)] -> String -> String
type STDirGroups a = Map FilePath (STGroup a)
readTmplDef :: Read b => b -> STGroup String -> FilePath -> b
readTmplM :: (Monad m, Read a) => STGroup String -> FilePath -> m a
readTmplTuples :: STGroup String -> String -> [(String, String)]
badTmplVarName :: String -> Bool

-- | directoryGroup helper function for more flexibility, and rewritten to
--   use do notation rather than applicative style that melted my brain.
--   
--   ignoreTemplate specifies a filter for templates that should be
--   skipped, eg backup files etc.
--   
--   errorTemplate specifies a filter which will cause function to fail.
--   
--   <pre>
--   directoryGroupHAppS = directoryGroupNew' ignoret badTmplVarName
--   where ignoret f = not . null . filter (=='#') $ f 
--   </pre>
directoryGroupNew' :: Stringable a => (FilePath -> Bool) -> (String -> Bool) -> FilePath -> IO (STGroup a)
