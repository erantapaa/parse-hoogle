-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | pluggable pure logic serializable reactor
--   
--   A library to help write reaction drivers where a reaction can produce
--   new reactions and events upon receiving an event. This library focuses
--   on logic and serialization.
@package reaction-logic
@version 2010.11.17

module Data.Reactor.Untypeds

-- | A box to contain any value
data Untyped
Untyped :: b -> Untyped
casting :: (Typeable a, Typeable c) => (a -> b) -> c -> Maybe b

-- | A box to contain a serializable
data Serial
Serial :: b -> Serial
toUntyped :: Serial -> Untyped

-- | Try to parse a string into a Serial box. It needs some hints on which
--   types could go inside the box
parseSerial :: [Serial] -> Serial -> Maybe Serial
type ParseSerial a = (Serial -> Maybe Serial) -> a -> Maybe a
instance Read Serial
instance Show Serial


-- | Reaction box and stepping function. <a>Reaction</a>s leave the monad
--   parameter free for the programmer. Around m a state transformer gives
--   them the chance to use per reaction state.
module Data.Reactor.Reaction

-- | A Reaction object is a container for a reaction. It's free in the type
--   of value to react and in its internal state.
data Reaction m
Reaction :: (a -> StateT b m (Response m)) -> b -> Reaction m

-- | The reaction to an event of type <tt>a</tt>. It can modify its
--   individual state in the outer monad layer. There are no constraint on
--   the inner monad.
reaction :: Reaction m -> a -> StateT b m (Response m)

-- | Internal state of the reaction. Upon creation it must contatin the
--   initial state.
reastate :: Reaction m -> b

-- | Try a reaction of a Reaction, given an event in an Untyped box. If the
--   event is not of the right type, the result is Nothing, otherwise an
--   action in the monad m returning a modified <a>Response</a>, with Bool
--   mapped to Maybe (Reaction m).
step :: (Monad m, Functor m) => Reaction m -> Internal -> Maybe (m ([Reaction m], [Internal], Maybe (Reaction m)))

-- | External event, it must be serializable
type External = Serial

-- | Internal event, don't need to be serializable
type Internal = Untyped

-- | Internal state serializations, it must be serializable
type Recover = Serial

-- | The value reactions compute.
data Response m
Response :: Bool -> [Reaction m] -> [Internal] -> Response m

-- | True to continue the reaction, or False if reaction if dead
continue :: Response m -> Bool

-- | a list of new reactions, just borned ready for the next event
newreas :: Response m -> [Reaction m]

-- | some events to broadcast now as effects of the reaction
newevents :: Response m -> [Internal]
prop_data_reactor_reaction :: Gen Bool

module Data.Reactor.Pruned

-- | build a pruned given some functions and a value
mkPruned :: Monad m => (a -> m (a, [a])) -> (a -> Bool) -> (a -> b -> a) -> (a -> b) -> a -> Pruned m b

-- | A pruned object keeps a pruned tree of values
data Pruned m b
Pruned :: m (Maybe (Pruned m b)) -> [b] -> ([b] -> Pruned m b) -> Pruned m b

-- | expand the pruned , Nothing if nothing in it at the end
expand :: Pruned m b -> m (Maybe (Pruned m b))

-- | collect the pruned values
serialize :: Pruned m b -> [b]

-- | restore the pruned given it's values
restore :: Pruned m b -> [b] -> Pruned m b
prop_data_reactor_pruned :: Gen Bool
instance Foldable Node
instance Functor Node
instance Traversable Node


-- | Resizable dependency graph.
module Data.Reactor.MinimalGraph
type Index = Int

-- | MinimalGraph object definition. Add and resisze are splitted to permit
--   new index to be used in computation of new constraint group .
data MinimalGraph a
MinimalGraph :: ((a, [Index]) -> (Index, MinimalGraph a)) -> ([Index] -> Maybe (MinimalGraph a)) -> [a] -> MinimalGraph a

-- | append a new value given its minimalendencies. Return its index
add :: MinimalGraph a -> (a, [Index]) -> (Index, MinimalGraph a)

-- | possibly reduce the object as to contain only the subgraph
resize :: MinimalGraph a -> [Index] -> Maybe (MinimalGraph a)

-- | elements in the graph
values :: MinimalGraph a -> [a]

-- | Create an empty minimal graph.
mkMinimalGraph :: MinimalGraph a
prop_data_reactor_minimalgraph :: Gen Bool


-- | Operational values wrap reactions with some historical tag. Index is
--   taken from <a>Data.Reactor.MinimalGraph</a> and is a key to an
--   happened External event.
module Data.Reactor.Operational

-- | <a>Reaction</a> contextualized with its history.
data Operational m
Operational :: Maybe Index -> Either Index (Reaction m) -> Operational m

-- | Nothing if the reaction is a base reaction or just an index to the
--   contextualized event which borned it
borned :: Operational m -> Maybe Index

-- | an index to the event that killed the reaction or the alive reaction
alive :: Operational m -> Either Index (Reaction m)

-- | The operational transformer. For reactions to react we store the index
--   to external event and the actual internal event in the reader and
--   store the new events produced by reactions in the writer
type OperationalLayer m = ReaderT (Index, Internal) (WriterT [Internal] m)

-- | Pruned object builder for <a>Operational</a> values
mkOperationalPruned :: (Functor m, Monad m) => Operational m -> Pruned (OperationalLayer m) (Maybe Serial, [Index])

module Data.Reactor.Serialization

-- | a SerialReactor parser. It tries to fix the existentials, in the
--   Recover and External boxes. Possible templates must be given for the
--   task.
parseSerialReactor :: ParseSerial (SerialReactor c)

-- | passive serialization of a reactor
type SerialReactor c = (ReactionStates, [SerialExternal c])

-- | active serialization of a reactor
type Serialization c = MinimalGraph (SerialExternal c)


-- | A reactor is an object to hold a bunch of reactions, which create
--   other reactions and events and respond to events.
module Data.Reactor

-- | The reactor object. Once created this closures control its lifecycle.
--   Updaters return Nothing when the reactor is wrapped around no
--   reactions.
data Reactor m c
Reactor :: ([External] -> m (Maybe (Reactor m c))) -> (SerialReactor c -> m (Maybe (Reactor m c))) -> SerialReactor c -> Reactor m c

-- | Update itself digesting a new event
insertExternals :: Reactor m c -> [External] -> m (Maybe (Reactor m c))

-- | Regenerate itself from a serialization
restoreReactor :: Reactor m c -> SerialReactor c -> m (Maybe (Reactor m c))

-- | Serialize its internals, for later restoring.
serializeReactor :: Reactor m c -> SerialReactor c

-- | build a reactor object from a list of basic reactions
mkReactor :: (Functor m, MonadState c m) => [Reaction m] -> Reactor m c
