-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Automatically convert Generic instances to and from church representations
--   
@package generic-church
@version 0.3.0.0


-- | This module provides two functions, <tt><a>toChurch</a></tt> and
--   <tt><a>fromChurch</a></tt>. These form an isomorphism between a type
--   and its church representation of a type To use this, simply define an
--   empty instance of <tt><a>ChurchRep</a></tt> for a type with a
--   <a>Generic</a> instance and defaulting magic will take care of the
--   rest. For example
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   data MyType = Foo Int Bool | Bar | Baz Char
--               deriving(Generic, Show)
--   
--   instance ChurchRep MyType
--   </pre>
--   
--   Then if we fire up GHCi
--   
--   <pre>
--   &gt;&gt;&gt; toChurch (Foo 1 True) (\int bool -&gt; int + 1) 0 (const 1)
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromChurch (\foo bar baz -&gt; bar) :: MyType
--   Bar
--   </pre>
module Data.Church

-- | This is the central type for this package. Unfortunately, it's built
--   around type families so it's not so easy to read. A helpful algorithm
--   for figuring out what the <a>Church</a> of a type <tt>Foo</tt> is,
--   
--   <ol>
--   <li>For each constructor, write out its type signature<ol><li>Replace
--   the <tt>Foo</tt> at the end of each signature with
--   <tt>c</tt></li><li>Join these type signatures together with arrows
--   <tt>(a -&gt; b -&gt; c) -&gt; c -&gt; ...</tt></li><li>Append a final
--   <tt> -&gt; c</tt> to the end of this</li></ol></li>
--   </ol>
--   
--   For example, for <a>Maybe</a>
--   
--   <ol>
--   <li><tt><a>Nothing</a> :: Maybe a</tt> and <tt><a>Just</a> :: a -&gt;
--   Maybe a</tt>.</li>
--   <li>We then have <tt>c</tt> and <tt>a -&gt; c</tt>.</li>
--   <li>Joining these gives <tt>c -&gt; (a -&gt; c)</tt></li>
--   <li><tt>c -&gt; (a -&gt; c) -&gt; c</tt> is our church
--   representation</li>
--   </ol>
type Church t c = ChurchSum (ToList (StripMeta (Rep t ())) (ListTerm ())) c
class ChurchRep a where toChurch = toChurchHelper (Proxy :: Proxy r) fromChurch c = to (build p c :: Rep a ()) where p = Proxy :: Proxy (MakePaths (Rep a ()) [] []) toChurchHelper p = elim p . flip toList (ListTerm :: ListTerm ()) . Just . stripMeta . from' where from' :: Generic a => a -> Rep a () from' = from
toChurch :: (ChurchRep a, ChurchRep a) => a -> Church a r
fromChurch :: ChurchRep a => Church a (Rep a ()) -> a
toChurchP :: ChurchRep a => Proxy r -> a -> Church a r
fromChurchP :: ChurchRep a => Proxy a -> Church a (Rep a ()) -> a

-- | Since types with the same church representation are identical, we can
--   cast between them.
churchCast :: (ChurchRep a, ChurchRep b, Church a (Rep b ()) ~ Church b (Rep b ())) => a -> b

-- | A more explicit version of <tt>churchCast</tt> that let's you specify
--   the target of the cast with a <tt>Proxy</tt>.
churchCastP :: (ChurchRep a, ChurchRep b, Church a (Rep b ()) ~ Church b (Rep b ())) => Proxy b -> a -> b
instance ChurchRep (Either a b)
instance ChurchRep (Maybe a)
instance ChurchRep (a, b, c, d, e, f, g)
instance ChurchRep (a, b, c, d, e, f)
instance ChurchRep (a, b, c, d, e)
instance ChurchRep (a, b, c, d)
instance ChurchRep (a, b, c)
instance ChurchRep (a, b)
instance ChurchRep ()
instance ChurchRep [a]
instance ChurchRep Ordering
instance ChurchRep Bool
