-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Binary and exponential searches
--   
--   These modules address the problem of finding the boundary of an
--   upward-closed set of integers, using a combination of exponential and
--   binary searches. Variants are provided for searching within bounded
--   and unbounded intervals of both <a>Integer</a> and bounded integral
--   types.
@package binary-search
@version 0.1


-- | Searching unbounded intervals of integers for the boundary of an
--   upward-closed set, using a combination of exponential and binary
--   search.
module Numeric.Search.Integer

-- | <i>O(log(abs n))</i>. Search the integers.
--   
--   If <tt>p</tt> is an upward-closed predicate, <tt>search p</tt> returns
--   the least <tt>n</tt> satisfying <tt>p</tt>. If no such <tt>n</tt>
--   exists, either because no integer satisfies <tt>p</tt> or all do,
--   <tt>search p</tt> does not terminate.
--   
--   For example, the following function computes discrete logarithms (base
--   2):
--   
--   <pre>
--   discreteLog :: Integer -&gt; Integer
--   discreteLog n = search (\ k -&gt; 2^k &lt;= n)
--   </pre>
search :: (Integer -> Bool) -> Integer

-- | <i>O(log(n-l))</i>. Search the integers from a given lower bound.
--   
--   If <tt>p</tt> is an upward-closed predicate, <tt>searchFrom p l =
--   <a>search</a> (\ i -&gt; i &gt;= l &amp;&amp; p i)</tt>. If no such
--   <tt>n</tt> exists (because no integer satisfies <tt>p</tt>),
--   <tt>searchFrom p</tt> does not terminate.
searchFrom :: (Integer -> Bool) -> Integer -> Integer

-- | <i>O(log(h-n))</i>. Search the integers up to a given upper bound.
--   
--   If <tt>p</tt> is an upward-closed predicate, <tt>searchTo p h ==
--   <a>Just</a> n</tt> if and only if <tt>n</tt> is the least number <tt>n
--   &lt;= h</tt> satisfying <tt>p</tt>.
searchTo :: (Integer -> Bool) -> Integer -> Maybe Integer

-- | <i>O(m log(n\</i>m))/. Two-dimensional search, using an algorithm due
--   described in
--   
--   <ul>
--   <li>Richard Bird, <i>Saddleback search: a lesson in algorithm
--   design</i>, in <i>Mathematics of Program Construction</i> 2006,
--   Springer LNCS vol. 4014, pp82-89.</li>
--   </ul>
--   
--   If <tt>p</tt> is closed upwards in each argument on non-negative
--   integers, <tt>search2 p</tt> returns the minimal non-negative pairs
--   satisfying <tt>p</tt>, listed in order of increasing x-coordinate.
--   
--   <i>m</i> and <i>n</i> refer to the smaller and larger dimensions of
--   the rectangle containing the boundary.
--   
--   For example,
--   
--   <pre>
--   search2 (\ x y -&gt; x^2 + y^2 &gt;= 25)  ==  [(0,5),(3,4),(4,3),(5,0)]
--   </pre>
search2 :: (Integer -> Integer -> Bool) -> [(Integer, Integer)]


-- | Binary search of a bounded interval of an integral type for the
--   boundary of an upward-closed set, using a combination of exponential
--   and binary search.
module Numeric.Search.Range

-- | <i>O(log(h-l))</i>. Search a bounded interval of some integral type.
--   
--   If <tt>p</tt> is an upward-closed predicate, <tt>searchFromTo p l h ==
--   Just n</tt> if and only if <tt>n</tt> is the least number <tt>l &lt;=
--   n &lt;= h</tt> satisfying <tt>p</tt>.
--   
--   For example, the following function determines the first index (if
--   any) at which a value occurs in an ordered array:
--   
--   <pre>
--   searchArray :: Ord a =&gt; a -&gt; Array Int a -&gt; Maybe Int
--   searchArray x array = do
--     let (lo, hi) = bounds array
--     k &lt;- searchFromTo (\ i -&gt; array!i &gt;= x) lo hi
--     guard (array!k == x)
--     return k
--   </pre>
searchFromTo :: Integral a => (a -> Bool) -> a -> a -> Maybe a


-- | Searching unbounded intervals within bounded integral types for the
--   boundary of an upward-closed set, using a combination of exponential
--   and binary search.
module Numeric.Search.Bounded

-- | <i>O(log(abs n))</i>. Search a bounded integral type.
--   
--   If <tt>p</tt> is an upward-closed predicate, <tt>search p</tt> returns
--   <tt>Just n</tt> if and only if <tt>n</tt> is the least such satisfying
--   <tt>p</tt>.
search :: (Bounded a, Integral a) => (a -> Bool) -> Maybe a

-- | <i>O(log(abs n))</i>. Search the part of a bounded integral type from
--   a given point.
--   
--   If <tt>p</tt> is an upward-closed predicate, <tt>searchFrom p l</tt>
--   returns <tt>Just n</tt> if and only if <tt>n</tt> is the least <tt>n
--   &gt;= l</tt> satisfying <tt>p</tt>.
searchFrom :: (Bounded a, Integral a) => (a -> Bool) -> a -> Maybe a

-- | <i>O(log(abs n))</i>. Search the part of a bounded integral type up to
--   a given point.
--   
--   If <tt>p</tt> is an upward-closed predicate, <tt>searchTo p h</tt>
--   returns <tt>Just n</tt> if and only if <tt>n</tt> is the least <tt>n
--   &lt;= h</tt> satisfying <tt>p</tt>.
searchTo :: (Bounded a, Integral a) => (a -> Bool) -> a -> Maybe a


-- | Monadic binary search combinators.
module Numeric.Search.Combinator.Monadic

-- | The generalized type for binary search functions.
type BinarySearchM m a b = InitializerM m a b -> CutterM m a b -> PredicateM m a b -> m (Seq (Range a b))

-- | <a>BookEnd</a> comes in order [LEnd, REnd, LEnd, REnd ...], and
--   represents the ongoing state of the search results. Two successive
--   <a>BookEnd</a> <tt>LEnd x1 y1</tt>, <tt>REnd x2 y1</tt> represents a
--   claim that <tt>pred x == y1</tt> for all <tt>x</tt> such that <tt>x1
--   &lt;= x &lt;= x2</tt> . Like this:
--   
--   <pre>
--   is (x^2 &gt; 20000) ?
--   
--   LEnd    REnd  LEnd     REnd
--   0        100  200       300
--   |_ False _|    |_ True  _|
--   </pre>
data BookEnd a b
REnd :: !a -> !b -> BookEnd a b
LEnd :: !a -> !b -> BookEnd a b

-- | <a>Range</a> <tt>((x1,x2),y)</tt> denotes that <tt>pred x == y</tt>
--   for all <tt>x1 &lt;= x &lt;= x2</tt> .
type Range a b = ((a, a), b)

-- | <a>PredicateM</a> <tt>m a b</tt> calculates the predicate in the
--   context <tt>m</tt>.
type PredicateM m a b = a -> m b

-- | <a>InitializerM</a> generates the initial set of ranges.
type InitializerM m a b = PredicateM m a b -> m (Seq (BookEnd a b))

-- | <a>CutterM</a> <tt>p x1 x2</tt> decides if we should further
--   investigate the gap between <tt>x1</tt> and <tt>x2</tt>. If so, it
--   gives a new value <tt>x3</tt> wrapped in a <a>Just</a>. <a>CutterM</a>
--   may optionally use the predicate.
type CutterM m a b = PredicateM m a b -> a -> a -> m (Maybe a)

-- | an initializer with the initial range specified.
initConstM :: Monad m => a -> a -> InitializerM m a b

-- | an initializer that searches for the full bound.
initBoundedM :: (Monad m, Bounded a) => InitializerM m a b

-- | a cutter for integral types.
cutIntegralM :: (Monad m, Integral a) => CutterM m a b

-- | The most generalized version of search.
searchWithM :: (Functor m, Monad m, Eq b) => BinarySearchM m a b
instance (Eq a, Eq b) => Eq (BookEnd a b)
instance (Show a, Show b) => Show (BookEnd a b)


-- | Pure counterpart for binary search.
module Numeric.Search.Combinator.Pure


-- | This package provides combinators to construct many variants of binary
--   search. Most generally, it provides the binary search over predicate
--   of the form <tt>(<a>Eq</a> b, <a>Monad</a> m) =&gt; a -&gt; m b</tt> .
--   The other searches are derived as special cases of this function.
--   
--   <tt>BinarySearch</tt> assumes two things;
--   
--   <ol>
--   <li><tt>b</tt>, the codomain of <a>PredicateM</a> belongs to type
--   class <a>Eq</a>.</li>
--   <li>Each value of <tt>b</tt> form a convex set in the codomain space
--   of the PredicateM. That is, if for certain pair <tt>(left, right) ::
--   (a, a)</tt> satisfies <tt>pred left == val &amp;&amp; pred right ==
--   val</tt>, then also <tt>pred x == val</tt> for all <tt>x</tt> such
--   that <tt>left &lt;= x &lt;= right</tt> .</li>
--   </ol>
module Numeric.Search

-- | <a>Range</a> <tt>((x1,x2),y)</tt> denotes that <tt>pred x == y</tt>
--   for all <tt>x1 &lt;= x &lt;= x2</tt> .
type Range a b = ((a, a), b)

-- | The generalized type for binary search functions.
type BinarySearchM m a b = InitializerM m a b -> CutterM m a b -> PredicateM m a b -> m (Seq (Range a b))

-- | <a>PredicateM</a> <tt>m a b</tt> calculates the predicate in the
--   context <tt>m</tt>.
type PredicateM m a b = a -> m b

-- | <a>InitializerM</a> generates the initial set of ranges.
type InitializerM m a b = PredicateM m a b -> m (Seq (BookEnd a b))

-- | <a>CutterM</a> <tt>p x1 x2</tt> decides if we should further
--   investigate the gap between <tt>x1</tt> and <tt>x2</tt>. If so, it
--   gives a new value <tt>x3</tt> wrapped in a <a>Just</a>. <a>CutterM</a>
--   may optionally use the predicate.
type CutterM m a b = PredicateM m a b -> a -> a -> m (Maybe a)

-- | The most generalized version of search.
searchWithM :: (Functor m, Monad m, Eq b) => BinarySearchM m a b
