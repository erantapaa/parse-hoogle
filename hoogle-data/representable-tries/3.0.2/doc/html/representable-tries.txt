-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Tries from representations of polynomial functors
--   
--   Tries from representations of polynomial functors
@package representable-tries
@version 3.0.2


-- | Zeroless numbers encoded in zeroless binary numbers
module Numeric.Nat.Zeroless
data D0

-- | 0
D0 :: D0
data D1 n

-- | 2n + 1
D1 :: n -> D1 n
data D2 n

-- | 2n + 2
D2 :: n -> D2 n
type (:+:) n m = Add C0 n m
class Zeroless n
ind :: Zeroless n => f D0 -> (forall m. Zeroless m => f m -> f (D1 m)) -> (forall m. Zeroless m => f m -> f (D2 m)) -> f n
caseNat :: Zeroless n => (n ~ D0 => r) -> (forall x. (n ~ D1 x, Zeroless x) => x -> r) -> (forall x. (n ~ D2 x, Zeroless x) => x -> r) -> n -> r
data LT
data GT
data EQ
type Compare m n = Compare' EQ m n
type N1 = D1 D0
type N8 = D2 (D1 (D1 D0))
type N16 = D2 (D1 (D1 (D1 D0)))
type N32 = D2 (D1 (D1 (D1 (D1 D0))))
type N64 = D2 (D1 (D1 (D1 (D1 (D1 D0)))))
newtype Nat n
Nat :: Int -> Nat n
fromNat :: Nat n -> Int
nat :: Zeroless n => Nat n
newtype Fin n
Fin :: Int -> Fin n
fromFin :: Fin n -> Int
type Reverse n = Reverse' D0 n
instance Positive n => Enum (Fin n)
instance Positive n => Bounded (Fin n)
instance Positive n => Num (Fin n)
instance Ord (Fin n)
instance Eq (Fin n)
instance Show (Fin n)
instance Zeroless n => Enum (Nat n)
instance Zeroless n => Bounded (Nat n)
instance Zeroless n => Show (Nat n)
instance Zeroless n => Ord (Nat n)
instance Zeroless n => Eq (Nat n)
instance Zeroless n => Positive (D2 n)
instance Zeroless n => Positive (D1 n)
instance Zeroless n => Zeroless (D2 n)
instance Zeroless n => Zeroless (D1 n)
instance Zeroless D0

module Data.Traversable.Fair
foldMapBoth :: (Foldable f, Foldable g, Monoid m) => (a -> m) -> f a -> g a -> m

-- | traverse both containers, interleaving effects for fairness
traverseBoth :: (Traversable f, Traversable g, Applicative m) => (a -> m b) -> f a -> g a -> m (f b, g b)
foldMapWithKeyBoth :: (FoldableWithKey f, FoldableWithKey g, Monoid m) => (Key f -> a -> m) -> (Key g -> a -> m) -> f a -> g a -> m

-- | traverse both containers, interleaving effects for fairness
traverseWithKeyBoth :: (TraversableWithKey f, TraversableWithKey g, Applicative m) => (Key f -> a -> m b) -> (Key g -> a -> m b) -> f a -> g a -> m (f b, g b)

-- | fold both containers, interleaving results for fairness
foldMapBoth1 :: (Foldable1 f, Foldable1 g, Semigroup m) => (a -> m) -> f a -> g a -> m

-- | traverse both containers, interleaving effects for fairness
traverseBoth1 :: (Traversable1 f, Traversable1 g, Apply m) => (a -> m b) -> f a -> g a -> m (f b, g b)

-- | fold both containers, interleaving results for fairness
foldMapWithKeyBoth1 :: (FoldableWithKey1 f, FoldableWithKey1 g, Semigroup m) => (Key f -> a -> m) -> (Key g -> a -> m) -> f a -> g a -> m

-- | traverse both containers, interleaving effects for fairness
traverseWithKeyBoth1 :: (TraversableWithKey1 f, TraversableWithKey1 g, Apply m) => (Key f -> a -> m b) -> (Key g -> a -> m b) -> f a -> g a -> m (f b, g b)


module Data.Functor.Representable.Trie.List
data ListTrie f a
ListTrie :: a -> (f (ListTrie f a)) -> ListTrie f a
nil :: ListTrie f a -> a
cons :: Indexable f => Key f -> ListTrie f a -> ListTrie f a
instance Representable f => Representable (ListTrie f)
instance Lookup f => Lookup (ListTrie f)
instance Adjustable f => Adjustable (ListTrie f)
instance Indexable f => Indexable (ListTrie f)
instance Representable f => Distributive (ListTrie f)
instance TraversableWithKey1 f => TraversableWithKey1 (ListTrie f)
instance TraversableWithKey f => TraversableWithKey (ListTrie f)
instance FoldableWithKey1 f => FoldableWithKey1 (ListTrie f)
instance FoldableWithKey f => FoldableWithKey (ListTrie f)
instance Traversable1 f => Traversable1 (ListTrie f)
instance Traversable f => Traversable (ListTrie f)
instance Foldable1 f => Foldable1 (ListTrie f)
instance Foldable f => Foldable (ListTrie f)
instance Keyed f => Keyed (ListTrie f)
instance ZipWithKey f => ZipWithKey (ListTrie f)
instance Zip f => Zip (ListTrie f)
instance Representable f => Monad (ListTrie f)
instance Representable f => Bind (ListTrie f)
instance Representable f => Applicative (ListTrie f)
instance Representable f => Apply (ListTrie f)
instance Functor f => Functor (ListTrie f)


module Data.Functor.Representable.Trie.Either
data EitherTrie f g a
EitherTrie :: (f a) -> (g a) -> EitherTrie f g a
left :: EitherTrie f g a -> f a
right :: EitherTrie f g a -> g a
instance (Representable f, Representable g) => Representable (EitherTrie f g)
instance (Lookup f, Lookup g) => Lookup (EitherTrie f g)
instance (Adjustable f, Adjustable g) => Adjustable (EitherTrie f g)
instance (Indexable f, Indexable g) => Indexable (EitherTrie f g)
instance (Representable f, Representable g) => Distributive (EitherTrie f g)
instance (TraversableWithKey1 f, TraversableWithKey1 g) => TraversableWithKey1 (EitherTrie f g)
instance (TraversableWithKey f, TraversableWithKey g) => TraversableWithKey (EitherTrie f g)
instance (FoldableWithKey1 f, FoldableWithKey1 g) => FoldableWithKey1 (EitherTrie f g)
instance (FoldableWithKey f, FoldableWithKey g) => FoldableWithKey (EitherTrie f g)
instance (Traversable1 f, Traversable1 g) => Traversable1 (EitherTrie f g)
instance (Traversable f, Traversable g) => Traversable (EitherTrie f g)
instance (Foldable1 f, Foldable1 g) => Foldable1 (EitherTrie f g)
instance (Foldable f, Foldable g) => Foldable (EitherTrie f g)
instance (ZipWithKey f, ZipWithKey g) => ZipWithKey (EitherTrie f g)
instance (Zip f, Zip g) => Zip (EitherTrie f g)
instance (Keyed f, Keyed g) => Keyed (EitherTrie f g)
instance (Representable f, Representable g) => Monad (EitherTrie f g)
instance (Apply f, Representable f, Apply g, Representable g) => Bind (EitherTrie f g)
instance (Applicative f, Applicative g) => Applicative (EitherTrie f g)
instance (Apply f, Apply g) => Apply (EitherTrie f g)
instance (Functor f, Functor g) => Functor (EitherTrie f g)
instance (Applicative f, Applicative g, Monoid a) => Monoid (EitherTrie f g a)
instance (Apply f, Apply g, Semigroup s) => Semigroup (EitherTrie f g s)


module Data.Functor.Representable.Trie.Bool
data BoolTrie a
BoolTrie :: a -> a -> BoolTrie a
instance Eq a => Eq (BoolTrie a)
instance Ord a => Ord (BoolTrie a)
instance Show a => Show (BoolTrie a)
instance Read a => Read (BoolTrie a)
instance Representable BoolTrie
instance Lookup BoolTrie
instance Adjustable BoolTrie
instance Indexable BoolTrie
instance Distributive BoolTrie
instance TraversableWithKey1 BoolTrie
instance TraversableWithKey BoolTrie
instance FoldableWithKey1 BoolTrie
instance FoldableWithKey BoolTrie
instance Traversable1 BoolTrie
instance Traversable BoolTrie
instance Foldable1 BoolTrie
instance Foldable BoolTrie
instance ZipWithKey BoolTrie
instance Zip BoolTrie
instance Keyed BoolTrie
instance Monad BoolTrie
instance Bind BoolTrie
instance Applicative BoolTrie
instance Apply BoolTrie
instance Functor BoolTrie


module Data.Functor.Representable.Trie
class (Adjustable (BaseTrie a), TraversableWithKey1 (BaseTrie a), Representable (BaseTrie a)) => HasTrie a where type family BaseTrie a :: * -> *
embedKey :: HasTrie a => a -> Key (BaseTrie a)
projectKey :: HasTrie a => Key (BaseTrie a) -> a

-- | Lift a memoizer to work with one more argument.
mup :: HasTrie t => (b -> c) -> (t -> b) -> t -> c
memo :: HasTrie t => (t -> a) -> t -> a

-- | Memoize a binary function, on its first argument and then on its
--   second. Take care to exploit any partial evaluation.
memo2 :: (HasTrie s, HasTrie t) => (s -> t -> a) -> s -> t -> a

-- | Memoize a ternary function on successive arguments. Take care to
--   exploit any partial evaluation.
memo3 :: (HasTrie r, HasTrie s, HasTrie t) => (r -> s -> t -> a) -> r -> s -> t -> a

-- | Apply a unary function inside of a tabulate
inTrie :: (HasTrie a, HasTrie c) => ((a -> b) -> c -> d) -> (a :->: b) -> c :->: d

-- | Apply a binary function inside of a tabulate
inTrie2 :: (HasTrie a, HasTrie c, HasTrie e) => ((a -> b) -> (c -> d) -> e -> f) -> (a :->: b) -> (c :->: d) -> e :->: f

-- | Apply a ternary function inside of a tabulate
inTrie3 :: (HasTrie a, HasTrie c, HasTrie e, HasTrie g) => ((a -> b) -> (c -> d) -> (e -> f) -> g -> h) -> (a :->: b) -> (c :->: d) -> (e :->: f) -> g :->: h
trie :: HasTrie t => (t -> a) -> (t :->: a)
untrie :: HasTrie t => (t :->: a) -> t -> a
newtype (:->:) a b
Trie :: BaseTrie a b -> :->: a b
runTrie :: :->: a b -> BaseTrie a b
data Entry a b
Entry :: a -> b -> Entry a b
instance (HasTrie a, HasTrie b, HasTrie c, HasTrie d) => HasTrie (a, b, c, d)
instance (HasTrie a, HasTrie b, HasTrie c) => HasTrie (a, b, c)
instance HasTrie Char
instance HasTrie Word64
instance HasTrie Word32
instance HasTrie Word16
instance HasTrie Word8
instance HasTrie Word
instance HasTrie Int64
instance HasTrie Int32
instance HasTrie Int16
instance HasTrie Int8
instance HasTrie Int
instance HasTrie v => HasTrie (IntMap v)
instance (HasTrie k, HasTrie v) => HasTrie (Map k v)
instance HasTrie a => HasTrie (Seq a)
instance HasTrie a => HasTrie [a]
instance HasTrie a => HasTrie (Maybe a)
instance (HasTrie a, HasTrie b) => HasTrie (Either a b)
instance (HasTrie a, HasTrie b) => HasTrie (Entry a b)
instance (HasTrie a, HasTrie b) => HasTrie (a, b)
instance HasTrie a => HasTrie (Product a)
instance HasTrie a => HasTrie (Sum a)
instance HasTrie a => HasTrie (Dual a)
instance HasTrie Any
instance HasTrie Bool
instance HasTrie ()
instance (HasTrie m, Semigroup m) => Extend ((:->:) m)
instance (HasTrie m, Monoid m) => Comonad ((:->:) m)
instance HasTrie a => MonadReader a ((:->:) a)
instance HasTrie a => Monad ((:->:) a)
instance HasTrie a => Bind ((:->:) a)
instance HasTrie a => Applicative ((:->:) a)
instance HasTrie a => Apply ((:->:) a)
instance (HasTrie a, Show a, Show b) => Show (a :->: b)
instance (HasTrie a, Ord b) => Ord (a :->: b)
instance (HasTrie a, Eq b) => Eq (a :->: b)
instance HasTrie a => TraversableWithKey1 ((:->:) a)
instance HasTrie a => Traversable1 ((:->:) a)
instance HasTrie a => FoldableWithKey1 ((:->:) a)
instance HasTrie a => Foldable1 ((:->:) a)
instance HasTrie a => TraversableWithKey ((:->:) a)
instance HasTrie a => Traversable ((:->:) a)
instance HasTrie a => FoldableWithKey ((:->:) a)
instance HasTrie a => Foldable ((:->:) a)
instance HasTrie a => Keyed ((:->:) a)
instance HasTrie a => Functor ((:->:) a)
instance HasTrie e => Adjunction (Entry e) ((:->:) e)
instance HasTrie e => ZipWithKey ((:->:) e)
instance HasTrie e => Zip ((:->:) e)
instance HasTrie e => Adjustable ((:->:) e)
instance HasTrie e => Representable ((:->:) e)
instance HasTrie e => Distributive ((:->:) e)
instance HasTrie e => Indexable ((:->:) e)
instance HasTrie e => Lookup ((:->:) e)
instance Functor (Entry a)


module Control.Monad.Reader.Trie
newtype ReaderTrieT a m b
ReaderTrieT :: a :->: m b -> ReaderTrieT a m b
runReaderTrieT :: ReaderTrieT a m b -> a :->: m b
instance (HasTrie a, MonadWriter w m) => MonadWriter w (ReaderTrieT a m)
instance (HasTrie a, MonadIO m) => MonadIO (ReaderTrieT a m)
instance (HasTrie a, Representable m, Monoid a, Monoid (Key m)) => Comonad (ReaderTrieT a m)
instance (HasTrie a, Representable m, Semigroup a, Semigroup (Key m)) => Extend (ReaderTrieT a m)
instance (HasTrie a, TraversableWithKey1 m) => TraversableWithKey1 (ReaderTrieT a m)
instance (HasTrie a, TraversableWithKey m) => TraversableWithKey (ReaderTrieT a m)
instance (HasTrie a, Traversable1 m) => Traversable1 (ReaderTrieT a m)
instance (HasTrie a, Traversable m) => Traversable (ReaderTrieT a m)
instance (HasTrie a, FoldableWithKey1 m) => FoldableWithKey1 (ReaderTrieT a m)
instance (HasTrie a, FoldableWithKey m) => FoldableWithKey (ReaderTrieT a m)
instance (HasTrie a, Foldable1 m) => Foldable1 (ReaderTrieT a m)
instance (HasTrie a, Foldable m) => Foldable (ReaderTrieT a m)
instance (HasTrie a, Representable m) => Representable (ReaderTrieT a m)
instance (HasTrie a, Lookup ((:->:) a), Lookup m) => Lookup (ReaderTrieT a m)
instance (HasTrie a, Adjustable m) => Adjustable (ReaderTrieT a m)
instance (HasTrie a, Indexable m) => Indexable (ReaderTrieT a m)
instance (HasTrie a, Keyed m) => Keyed (ReaderTrieT a m)
instance (HasTrie a, ZipWithKey m) => ZipWithKey (ReaderTrieT a m)
instance (HasTrie a, Zip m) => Zip (ReaderTrieT a m)
instance (HasTrie a, Distributive m) => Distributive (ReaderTrieT a m)
instance HasTrie a => MonadTrans (ReaderTrieT a)
instance (HasTrie a, Monad m) => MonadReader a (ReaderTrieT a m)
instance (HasTrie a, Monad m) => Monad (ReaderTrieT a m)
instance (HasTrie a, Bind m) => Bind (ReaderTrieT a m)
instance (HasTrie a, Applicative m) => Applicative (ReaderTrieT a m)
instance (HasTrie a, Apply m) => Apply (ReaderTrieT a m)
instance (HasTrie a, Functor m) => Functor (ReaderTrieT a m)
