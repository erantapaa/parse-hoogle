-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | General purpose templates in haskell
--   
@package StrappedTemplates
@version 0.2.0.2

module Text.Strapped.Types

-- | RenderT m
--   
--   <ul>
--   <li>m -&gt; Monad we are transforming</li>
--   </ul>
newtype RenderT m a
RenderT :: ExceptT StrapError (StateT (RenderState m) m) a -> RenderT m a
runRenderT :: RenderT m a -> ExceptT StrapError (StateT (RenderState m) m) a
data RenderState m
RenderState :: SourcePos -> StrappedConfig -> BlockMap -> InputBucket m -> RenderState m
position :: RenderState m -> SourcePos
renderConfig :: RenderState m -> StrappedConfig
blocks :: RenderState m -> BlockMap
bucket :: RenderState m -> InputBucket m
type Output = Builder
type BlockMap = Map String [ParsedPiece]
data Expression
LookupExpression :: String -> Expression
LiteralExpression :: Literal -> Expression
ListExpression :: [ParsedExpression] -> Expression
Multipart :: [ParsedExpression] -> Expression
data ParsedExpression
ParsedExpression :: Expression -> SourcePos -> ParsedExpression
data Piece
StaticPiece :: Output -> Piece
BlockPiece :: String -> [ParsedPiece] -> Piece
ForPiece :: String -> ParsedExpression -> [ParsedPiece] -> Piece
IfPiece :: ParsedExpression -> [ParsedPiece] -> [ParsedPiece] -> Piece
FuncPiece :: ParsedExpression -> Piece
Decl :: String -> ParsedExpression -> Piece
Include :: String -> Piece
Inherits :: String -> BlockMap -> Piece
data ParsedPiece
ParsedPiece :: a -> SourcePos -> ParsedPiece
class Renderable a
renderOutput :: Renderable a => StrappedConfig -> a -> Output
data Input m
Func :: (Literal -> RenderT m Literal) -> Input m
LitVal :: Literal -> Input m
data Literal
LitDyn :: !a -> Literal
LitText :: !Text -> Literal
LitSafe :: !Text -> Literal
LitInteger :: !Integer -> Literal
LitDouble :: !Double -> Literal
LitBuilder :: !Builder -> Literal
LitList :: ![Literal] -> Literal
LitBool :: !Bool -> Literal
LitEmpty :: Literal
class ToLiteral a
toLiteral :: ToLiteral a => a -> Literal
class Block a
process :: (Block a, MonadIO m) => a -> RenderT m Output
class Booly a
toBool :: Booly a => a -> Bool
data StrapError
StrapError :: String -> StrapError
InputNotFound :: String -> StrapError
TemplateNotFound :: String -> StrapError
PositionedError :: StrapError -> SourcePos -> StrapError
data InputBucket m
InputBucket :: [(Map String (Input m))] -> InputBucket m
type TemplateStore = String -> IO (Maybe Template)
data Template
Template :: [ParsedPiece] -> Template
type ParserM = GenParser Char StrappedConfig
data BlockParser
BlockParser :: (ParserM a) -> BlockParser
data StrappedConfig
StrappedConfig :: [BlockParser] -> TemplateStore -> (Text -> Text) -> StrappedConfig
customParsers :: StrappedConfig -> [BlockParser]
templateStore :: StrappedConfig -> TemplateStore
escapeFunc :: StrappedConfig -> Text -> Text
instance Show StrapError
instance Eq StrapError
instance Functor m => Functor (RenderT m)
instance (Monad m, Functor m) => Applicative (RenderT m)
instance Monad m => Monad (RenderT m)
instance MonadIO m => MonadIO (RenderT m)
instance Show Template
instance Show Piece
instance Show Literal
instance Booly Literal
instance IsString Literal
instance ToLiteral String
instance ToLiteral Bool
instance ToLiteral [Literal]
instance ToLiteral Builder
instance ToLiteral Double
instance ToLiteral Integer
instance ToLiteral Text
instance Show ParsedPiece
instance Show ParsedExpression
instance Show Expression
instance Show Builder
instance Monad m => MonadError StrapError (RenderT m)
instance MonadTrans RenderT

module Text.Strapped.Render

-- | If the first bucket fails, try the second.
combineBuckets :: InputBucket m -> InputBucket m -> InputBucket m

-- | Basic bucket. Matches on string and return input. Returns Nothing for
--   everything else.
varBucket :: String -> Input m -> InputBucket m
bucketLookup :: String -> InputBucket m -> Maybe (Input m)
bucketFromList :: [(String, Input m)] -> InputBucket m
emptyBucket :: InputBucket m
render :: MonadIO m => StrappedConfig -> InputBucket m -> String -> m (Either StrapError Output)

-- | Default render configuration. No text escaping.
defaultConfig :: StrappedConfig
reduceExpression :: Monad m => ParsedExpression -> RenderT m Literal
putBucket :: Monad m => (InputBucket m) -> RenderT m ()
getBucket :: Monad m => RenderT m (InputBucket m)
getConfig :: Monad m => RenderT m StrappedConfig
getState :: Monad m => RenderT m (RenderState m)
putState :: Monad m => RenderState m -> RenderT m ()
instance Block Piece
instance Renderable Literal
instance Renderable Builder

module Text.Strapped.Parser

-- | Take config, a template body and a template name and return either an
--   error or a renderable template.
parseTemplate :: StrappedConfig -> String -> String -> Either ParseError Template

-- | Parse an expression that produces a <a>Literal</a>
parseExpression :: ParserM a -> ParserM ParsedExpression
parseContent :: ParserM a -> ParserM [ParsedPiece]

-- | Parse the beginning of a tag
tagStart :: ParserM String

-- | Parse the end of a tag.
tagEnd :: ParserM String

-- | Look at a tag but don't consume
peekTag :: ParserM a -> ParserM ()

-- | Try a tag and consume if it matches
tryTag :: ParserM a -> ParserM ()

-- | Parse content between <a>tagStart</a> and <a>tagEnd</a>
tag :: ParserM a -> ParserM a

-- | Parse alpha-numeric characters and '_'
wordString :: ParserM String

-- | Parse alpha-numeric characters and '_./'
pathString :: ParserM String

-- | Look at a character but don't consume
peekChar :: Char -> ParserM ()

module Text.Strapped.Utils
templateStoreFromList :: StrappedConfig -> [(String, String)] -> Either ParseError TemplateStore

-- | Given a file path and extension, load all templates in a directory,
--   recursively.
templateStoreFromDirectory :: StrappedConfig -> FilePath -> String -> IO (Either ParseError TemplateStore)
putStore :: TemplateStore -> StrappedConfig -> StrappedConfig
showToBuilder :: Show a => a -> Builder
lit :: ToLiteral a => a -> Input m
dyn :: (Renderable a, Typeable a) => a -> Input m

module Text.Strapped
render :: MonadIO m => StrappedConfig -> InputBucket m -> String -> m (Either StrapError Output)

-- | Default render configuration. No text escaping.
defaultConfig :: StrappedConfig
showToBuilder :: Show a => a -> Builder

-- | If the first bucket fails, try the second.
combineBuckets :: InputBucket m -> InputBucket m -> InputBucket m

-- | Basic bucket. Matches on string and return input. Returns Nothing for
--   everything else.
varBucket :: String -> Input m -> InputBucket m
bucketLookup :: String -> InputBucket m -> Maybe (Input m)
bucketFromList :: [(String, Input m)] -> InputBucket m
emptyBucket :: InputBucket m
lit :: ToLiteral a => a -> Input m
dyn :: (Renderable a, Typeable a) => a -> Input m

-- | Take config, a template body and a template name and return either an
--   error or a renderable template.
parseTemplate :: StrappedConfig -> String -> String -> Either ParseError Template
templateStoreFromList :: StrappedConfig -> [(String, String)] -> Either ParseError TemplateStore

-- | Given a file path and extension, load all templates in a directory,
--   recursively.
templateStoreFromDirectory :: StrappedConfig -> FilePath -> String -> IO (Either ParseError TemplateStore)
putStore :: TemplateStore -> StrappedConfig -> StrappedConfig
