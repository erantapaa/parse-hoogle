-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A PostgreSQL access library with compile-time SQL type inference
--   
@package postgresql-typed
@version 0.4.0


-- | Classes to support type inference, value encoding/decoding, and
--   instances to support built-in PostgreSQL types.
module Database.PostgreSQL.Typed.Types
type OID = Word32

-- | A value passed to or from PostgreSQL in raw format.
data PGValue
PGNullValue :: PGValue

-- | The standard text encoding format (also used for unknown formats)
PGTextValue :: PGTextValue -> PGValue
pgTextValue :: PGValue -> PGTextValue

-- | Special binary-encoded data. Not supported in all cases.
PGBinaryValue :: PGBinaryValue -> PGValue
pgBinaryValue :: PGValue -> PGBinaryValue

-- | A list of (nullable) data values, e.g. a single row or query
--   parameters.
type PGValues = [PGValue]

-- | A proxy type for PostgreSQL types. The type argument should be an
--   (internal) name of a database type (see <tt>\dT+</tt>).
data PGTypeName (t :: Symbol)
PGTypeProxy :: PGTypeName

-- | Parameters that affect how marshalling happens. Currenly we force all
--   other relevant parameters at connect time. Nothing values represent
--   unknown.
data PGTypeEnv
PGTypeEnv :: Maybe Bool -> PGTypeEnv

-- | If <tt>integer_datetimes</tt> is <tt>on</tt>; only relevant for binary
--   encoding.
pgIntegerDatetimes :: PGTypeEnv -> Maybe Bool
unknownPGTypeEnv :: PGTypeEnv

-- | Generic class of composite (row or record) types.
newtype PGRecord
PGRecord :: [Maybe PGTextValue] -> PGRecord

-- | A valid PostgreSQL type. This is just an indicator class: no
--   implementation is needed. Unfortunately this will generate orphan
--   instances wherever used.
class KnownSymbol t => PGType t where pgTypeName = symbolVal pgBinaryColumn _ _ = False
pgTypeName :: PGType t => PGTypeName t -> String
pgBinaryColumn :: PGType t => PGTypeEnv -> PGTypeName t -> Bool

-- | A <tt>PGParameter t a</tt> instance describes how to encode a
--   PostgreSQL type <tt>t</tt> from <tt>a</tt>.
class PGType t => PGParameter t a where pgLiteral t = pgQuote . pgEncode t pgEncodeValue _ t = PGTextValue . pgEncode t
pgEncode :: PGParameter t a => PGTypeName t -> a -> PGTextValue
pgLiteral :: PGParameter t a => PGTypeName t -> a -> ByteString
pgEncodeValue :: PGParameter t a => PGTypeEnv -> PGTypeName t -> a -> PGValue

-- | A <tt>PGColumn t a</tt> instance describes how te decode a PostgreSQL
--   type <tt>t</tt> to <tt>a</tt>.
class PGType t => PGColumn t a where pgDecodeBinary _ t _ = error $ "pgDecodeBinary " ++ pgTypeName t ++ ": not supported" pgDecodeValue _ t (PGTextValue v) = pgDecode t v pgDecodeValue e t (PGBinaryValue v) = pgDecodeBinary e t v pgDecodeValue _ t PGNullValue = error $ "NULL in " ++ pgTypeName t ++ " column (use Maybe or COALESCE)"
pgDecode :: PGColumn t a => PGTypeName t -> PGTextValue -> a
pgDecodeBinary :: PGColumn t a => PGTypeEnv -> PGTypeName t -> PGBinaryValue -> a
pgDecodeValue :: PGColumn t a => PGTypeEnv -> PGTypeName t -> PGValue -> a

-- | Final parameter encoding function used when a (nullable) parameter is
--   passed to a prepared query.
pgEncodeParameter :: PGParameter t a => PGTypeEnv -> PGTypeName t -> a -> PGValue

-- | Final parameter escaping function used when a (nullable) parameter is
--   passed to be substituted into a simple query.
pgEscapeParameter :: PGParameter t a => PGTypeEnv -> PGTypeName t -> a -> ByteString

-- | Final column decoding function used for a nullable result value.
pgDecodeColumn :: PGColumn t (Maybe a) => PGTypeEnv -> PGTypeName t -> PGValue -> Maybe a

-- | Final column decoding function used for a non-nullable result value.
pgDecodeColumnNotNull :: PGColumn t a => PGTypeEnv -> PGTypeName t -> PGValue -> a

-- | Produce a SQL string literal by wrapping (and escaping) a string with
--   single quotes.
pgQuote :: ByteString -> ByteString

-- | Double-quote a value if it's "", "null", or contains any whitespace,
--   '"', '\', or the characters given in the first argument. Checking all
--   these things may not be worth it. We could just double-quote
--   everything.
pgDQuote :: [Char] -> ByteString -> Builder

-- | Parse double-quoted values ala <a>pgDQuote</a>.
parsePGDQuote :: Bool -> [Char] -> (ByteString -> Bool) -> Parser (Maybe ByteString)
buildPGValue :: Builder -> ByteString
instance [overlap ok] Show PGValue
instance [overlap ok] Eq PGValue
instance [overlap ok] Show PGTypeEnv
instance [overlap ok] PGColumn "jsonb" Value
instance [overlap ok] PGParameter "jsonb" Value
instance [overlap ok] PGType "jsonb"
instance [overlap ok] PGColumn "json" Value
instance [overlap ok] PGParameter "json" Value
instance [overlap ok] PGType "json"
instance [overlap ok] PGRecordType "record"
instance [overlap ok] PGType "record"
instance [overlap ok] PGRecordType t => PGColumn t PGRecord
instance [overlap ok] PGRecordType t => PGParameter t PGRecord
instance [overlap ok] PGColumn "uuid" UUID
instance [overlap ok] PGParameter "uuid" UUID
instance [overlap ok] PGType "uuid"
instance [overlap ok] PGColumn "numeric" Scientific
instance [overlap ok] PGParameter "numeric" Scientific
instance [overlap ok] PGColumn "numeric" Rational
instance [overlap ok] PGParameter "numeric" Rational
instance [overlap ok] PGType "numeric"
instance [overlap ok] PGColumn "interval" DiffTime
instance [overlap ok] PGParameter "interval" DiffTime
instance [overlap ok] PGType "interval"
instance [overlap ok] PGColumn "timestamp with time zone" UTCTime
instance [overlap ok] PGParameter "timestamp with time zone" UTCTime
instance [overlap ok] PGType "timestamp with time zone"
instance [overlap ok] PGColumn "timestamp without time zone" LocalTime
instance [overlap ok] PGParameter "timestamp without time zone" LocalTime
instance [overlap ok] PGType "timestamp without time zone"
instance [overlap ok] PGColumn "time without time zone" TimeOfDay
instance [overlap ok] PGParameter "time without time zone" TimeOfDay
instance [overlap ok] PGType "time without time zone"
instance [overlap ok] PGColumn "date" Day
instance [overlap ok] PGParameter "date" Day
instance [overlap ok] PGType "date"
instance [overlap ok] PGColumn "bytea" ByteString
instance [overlap ok] PGParameter "bytea" ByteString
instance [overlap ok] PGColumn "bytea" ByteString
instance [overlap ok] PGParameter "bytea" ByteString
instance [overlap ok] PGType "bytea"
instance [overlap ok] PGStringType "bpchar"
instance [overlap ok] PGStringType "name"
instance [overlap ok] PGStringType "character varying"
instance [overlap ok] PGStringType "text"
instance [overlap ok] PGType "bpchar"
instance [overlap ok] PGType "name"
instance [overlap ok] PGType "character varying"
instance [overlap ok] PGType "text"
instance [overlap ok] PGStringType t => PGColumn t Text
instance [overlap ok] PGStringType t => PGParameter t Text
instance [overlap ok] PGStringType t => PGColumn t Text
instance [overlap ok] PGStringType t => PGParameter t Text
instance [overlap ok] PGStringType t => PGColumn t ByteString
instance [overlap ok] PGStringType t => PGParameter t ByteString
instance [overlap ok] PGStringType t => PGColumn t ByteString
instance [overlap ok] PGStringType t => PGParameter t ByteString
instance [overlap ok] PGStringType t => PGColumn t String
instance [overlap ok] PGStringType t => PGParameter t String
instance [overlap ok] PGColumn "\"char\"" Char
instance [overlap ok] PGParameter "\"char\"" Char
instance [overlap ok] PGType "\"char\""
instance [overlap ok] PGColumn "double precision" Double
instance [overlap ok] PGParameter "double precision" Double
instance [overlap ok] PGType "double precision"
instance [overlap ok] PGColumn "real" Float
instance [overlap ok] PGParameter "real" Float
instance [overlap ok] PGType "real"
instance [overlap ok] PGColumn "bigint" Int64
instance [overlap ok] PGParameter "bigint" Int64
instance [overlap ok] PGType "bigint"
instance [overlap ok] PGColumn "integer" Int32
instance [overlap ok] PGParameter "integer" Int32
instance [overlap ok] PGType "integer"
instance [overlap ok] PGColumn "smallint" Int16
instance [overlap ok] PGParameter "smallint" Int16
instance [overlap ok] PGType "smallint"
instance [overlap ok] PGColumn "oid" OID
instance [overlap ok] PGParameter "oid" OID
instance [overlap ok] PGType "oid"
instance [overlap ok] PGColumn "boolean" Bool
instance [overlap ok] PGParameter "boolean" Bool
instance [overlap ok] PGType "boolean"
instance [overlap ok] PGColumn "void" ()
instance [overlap ok] PGType "void"
instance [overlap ok] PGColumn t a => PGColumn t (Maybe a)
instance [overlap ok] PGParameter t a => PGParameter t (Maybe a)


-- | Automatic (dynamic) marshalling of PostgreSQL values based on Haskell
--   types (not SQL statements). This is intended for direct construction
--   of queries and query data, bypassing the normal SQL type inference.
module Database.PostgreSQL.Typed.Dynamic

-- | Represents canonical/default PostgreSQL representation for various
--   Haskell types, allowing convenient type-driven marshalling.
class PGType t => PGRep t a | a -> t where pgTypeOf _ = PGTypeProxy pgEncodeRep x = pgEncodeValue unknownPGTypeEnv (pgTypeOf x) x pgLiteralRep x = pgLiteral (pgTypeOf x) x pgDecodeRep (PGTextValue v) = pgDecode (PGTypeProxy :: PGTypeName t) v pgDecodeRep _ = error $ "pgDecodeRep " ++ pgTypeName (PGTypeProxy :: PGTypeName t) ++ ": unsupported PGValue"
pgTypeOf :: PGRep t a => a -> PGTypeName t
pgEncodeRep :: PGRep t a => a -> PGValue
pgLiteralRep :: PGRep t a => a -> ByteString
pgDecodeRep :: PGRep t a => PGValue -> a
pgLiteralString :: PGRep t a => a -> String

-- | Produce a safely type-cast literal value for interpolation in a SQL
--   statement.
pgSafeLiteral :: PGRep t a => a -> ByteString
pgSafeLiteralString :: PGRep t a => a -> String

-- | Create an expression that literally substitutes each instance of
--   <tt>${expr}</tt> for the result of <tt>pgSafeLiteral expr</tt>. This
--   lets you do safe, type-driven literal substitution into SQL fragments
--   without needing a full query, bypassing placeholder inference and any
--   prepared queries. Unlike most other TH functions, this does not
--   require any database connection.
pgSubstituteLiterals :: String -> ExpQ
instance PGRep "uuid" UUID
instance PGRep "numeric" Scientific
instance PGRep "numeric" Rational
instance PGRep "interval" DiffTime
instance PGRep "timestamp with time zone" UTCTime
instance PGRep "timestamp without time zone" LocalTime
instance PGRep "time without time zone" TimeOfDay
instance PGRep "date" Day
instance PGRep "text" Text
instance PGRep "text" ByteString
instance PGRep "text" String
instance PGRep "\"char\"" Char
instance PGRep "double precision" Double
instance PGRep "real" Float
instance PGRep "bigint" Int64
instance PGRep "integer" Int32
instance PGRep "smallint" Int16
instance PGRep "oid" OID
instance PGRep "boolean" Bool
instance PGRep t a => PGRep t (Maybe a)


-- | Representaion of PostgreSQL's array type. Currently this only supports
--   one-dimensional arrays. PostgreSQL arrays in theory can dynamically be
--   any (rectangular) shape.
module Database.PostgreSQL.Typed.Array

-- | The cannonical representation of a PostgreSQL array of any type, which
--   may always contain NULLs. Currenly only one-dimetional arrays are
--   supported, although in PostgreSQL, any array may be of any
--   dimentionality.
type PGArray a = [Maybe a]

-- | Class indicating that the first PostgreSQL type is an array of the
--   second. This implies <a>PGParameter</a> and <a>PGColumn</a> instances
--   that will work for any type using comma as a delimiter (i.e., anything
--   but <tt>box</tt>). This will only work with 1-dimensional arrays.
class (PGType ta, PGType t) => PGArrayType ta t | ta -> t, t -> ta where pgArrayElementType PGTypeProxy = PGTypeProxy pgArrayDelim _ = ','
pgArrayElementType :: PGArrayType ta t => PGTypeName ta -> PGTypeName t
pgArrayDelim :: PGArrayType ta t => PGTypeName ta -> Char
instance PGType "int8range" => PGArrayType "int8range[]" "int8range"
instance PGType "int8range" => PGType "int8range[]"
instance PGType "daterange" => PGArrayType "daterange[]" "daterange"
instance PGType "daterange" => PGType "daterange[]"
instance PGType "tstzrange" => PGArrayType "tstzrange[]" "tstzrange"
instance PGType "tstzrange" => PGType "tstzrange[]"
instance PGType "tsrange" => PGArrayType "tsrange[]" "tsrange"
instance PGType "tsrange" => PGType "tsrange[]"
instance PGType "numrange" => PGArrayType "numrange[]" "numrange"
instance PGType "numrange" => PGType "numrange[]"
instance PGType "int4range" => PGArrayType "int4range[]" "int4range"
instance PGType "int4range" => PGType "int4range[]"
instance PGType "regdictionary" => PGArrayType "regdictionary[]" "regdictionary"
instance PGType "regdictionary" => PGType "regdictionary[]"
instance PGType "regconfig" => PGArrayType "regconfig[]" "regconfig"
instance PGType "regconfig" => PGType "regconfig[]"
instance PGType "gtsvector" => PGArrayType "gtsvector[]" "gtsvector"
instance PGType "gtsvector" => PGType "gtsvector[]"
instance PGType "tsquery" => PGArrayType "tsquery[]" "tsquery"
instance PGType "tsquery" => PGType "tsquery[]"
instance PGType "tsvector" => PGArrayType "tsvector[]" "tsvector"
instance PGType "tsvector" => PGType "tsvector[]"
instance PGType "txid_snapshot" => PGArrayType "txid_snapshot[]" "txid_snapshot"
instance PGType "txid_snapshot" => PGType "txid_snapshot[]"
instance PGType "uuid" => PGArrayType "uuid[]" "uuid"
instance PGType "uuid" => PGType "uuid[]"
instance PGType "cstring" => PGArrayType "cstring[]" "cstring"
instance PGType "cstring" => PGType "cstring[]"
instance PGType "record" => PGArrayType "record[]" "record"
instance PGType "record" => PGType "record[]"
instance PGType "regtype" => PGArrayType "regtype[]" "regtype"
instance PGType "regtype" => PGType "regtype[]"
instance PGType "regclass" => PGArrayType "regclass[]" "regclass"
instance PGType "regclass" => PGType "regclass[]"
instance PGType "regoperator" => PGArrayType "regoperator[]" "regoperator"
instance PGType "regoperator" => PGType "regoperator[]"
instance PGType "regoper" => PGArrayType "regoper[]" "regoper"
instance PGType "regoper" => PGType "regoper[]"
instance PGType "regprocedure" => PGArrayType "regprocedure[]" "regprocedure"
instance PGType "regprocedure" => PGType "regprocedure[]"
instance PGType "refcursor" => PGArrayType "refcursor[]" "refcursor"
instance PGType "refcursor" => PGType "refcursor[]"
instance PGType "numeric" => PGArrayType "numeric[]" "numeric"
instance PGType "numeric" => PGType "numeric[]"
instance PGType "varbit" => PGArrayType "varbit[]" "varbit"
instance PGType "varbit" => PGType "varbit[]"
instance PGType "bit" => PGArrayType "bit[]" "bit"
instance PGType "bit" => PGType "bit[]"
instance PGType "time with time zone" => PGArrayType "time with time zone[]" "time with time zone"
instance PGType "time with time zone" => PGType "time with time zone[]"
instance PGType "interval" => PGArrayType "interval[]" "interval"
instance PGType "interval" => PGType "interval[]"
instance PGType "timestamp with time zone" => PGArrayType "timestamp with time zone[]" "timestamp with time zone"
instance PGType "timestamp with time zone" => PGType "timestamp with time zone[]"
instance PGType "timestamp without time zone" => PGArrayType "timestamp without time zone[]" "timestamp without time zone"
instance PGType "timestamp without time zone" => PGType "timestamp without time zone[]"
instance PGType "time without time zone" => PGArrayType "time without time zone[]" "time without time zone"
instance PGType "time without time zone" => PGType "time without time zone[]"
instance PGType "date" => PGArrayType "date[]" "date"
instance PGType "date" => PGType "date[]"
instance PGType "character varying" => PGArrayType "character varying[]" "character varying"
instance PGType "character varying" => PGType "character varying[]"
instance PGType "bpchar" => PGArrayType "bpchar[]" "bpchar"
instance PGType "bpchar" => PGType "bpchar[]"
instance PGType "aclitem" => PGArrayType "aclitem[]" "aclitem"
instance PGType "aclitem" => PGType "aclitem[]"
instance PGType "inet" => PGArrayType "inet[]" "inet"
instance PGType "inet" => PGType "inet[]"
instance PGType "macaddr" => PGArrayType "macaddr[]" "macaddr"
instance PGType "macaddr" => PGType "macaddr[]"
instance PGType "money" => PGArrayType "money[]" "money"
instance PGType "money" => PGType "money[]"
instance PGType "circle" => PGArrayType "circle[]" "circle"
instance PGType "circle" => PGType "circle[]"
instance PGType "tinterval" => PGArrayType "tinterval[]" "tinterval"
instance PGType "tinterval" => PGType "tinterval[]"
instance PGType "reltime" => PGArrayType "reltime[]" "reltime"
instance PGType "reltime" => PGType "reltime[]"
instance PGType "abstime" => PGArrayType "abstime[]" "abstime"
instance PGType "abstime" => PGType "abstime[]"
instance PGType "double precision" => PGArrayType "double precision[]" "double precision"
instance PGType "double precision" => PGType "double precision[]"
instance PGType "real" => PGArrayType "real[]" "real"
instance PGType "real" => PGType "real[]"
instance PGType "cidr" => PGArrayType "cidr[]" "cidr"
instance PGType "cidr" => PGType "cidr[]"
instance PGType "line" => PGArrayType "line[]" "line"
instance PGType "line" => PGType "line[]"
instance PGType "polygon" => PGArrayType "polygon[]" "polygon"
instance PGType "polygon" => PGType "polygon[]"
instance PGType "box" => PGArrayType "box[]" "box"
instance PGType "box" => PGType "box[]"
instance PGType "path" => PGArrayType "path[]" "path"
instance PGType "path" => PGType "path[]"
instance PGType "lseg" => PGArrayType "lseg[]" "lseg"
instance PGType "lseg" => PGType "lseg[]"
instance PGType "point" => PGArrayType "point[]" "point"
instance PGType "point" => PGType "point[]"
instance PGType "xml" => PGArrayType "xml[]" "xml"
instance PGType "xml" => PGType "xml[]"
instance PGType "json" => PGArrayType "json[]" "json"
instance PGType "json" => PGType "json[]"
instance PGType "oidvector" => PGArrayType "oidvector[]" "oidvector"
instance PGType "oidvector" => PGType "oidvector[]"
instance PGType "cid" => PGArrayType "cid[]" "cid"
instance PGType "cid" => PGType "cid[]"
instance PGType "xid" => PGArrayType "xid[]" "xid"
instance PGType "xid" => PGType "xid[]"
instance PGType "tid" => PGArrayType "tid[]" "tid"
instance PGType "tid" => PGType "tid[]"
instance PGType "oid" => PGArrayType "oid[]" "oid"
instance PGType "oid" => PGType "oid[]"
instance PGType "text" => PGArrayType "text[]" "text"
instance PGType "text" => PGType "text[]"
instance PGType "regproc" => PGArrayType "regproc[]" "regproc"
instance PGType "regproc" => PGType "regproc[]"
instance PGType "integer" => PGArrayType "integer[]" "integer"
instance PGType "integer" => PGType "integer[]"
instance PGType "int2vector" => PGArrayType "int2vector[]" "int2vector"
instance PGType "int2vector" => PGType "int2vector[]"
instance PGType "smallint" => PGArrayType "smallint[]" "smallint"
instance PGType "smallint" => PGType "smallint[]"
instance PGType "bigint" => PGArrayType "bigint[]" "bigint"
instance PGType "bigint" => PGType "bigint[]"
instance PGType "name" => PGArrayType "name[]" "name"
instance PGType "name" => PGType "name[]"
instance PGType "\"char\"" => PGArrayType "\"char\"[]" "\"char\""
instance PGType "\"char\"" => PGType "\"char\"[]"
instance PGType "bytea" => PGArrayType "bytea[]" "bytea"
instance PGType "bytea" => PGType "bytea[]"
instance PGType "boolean" => PGArrayType "boolean[]" "boolean"
instance PGType "boolean" => PGType "boolean[]"
instance (PGArrayType ta t, PGColumn t a) => PGColumn ta (PGArray a)
instance (PGArrayType ta t, PGParameter t a) => PGParameter ta (PGArray a)


-- | Representaion of PostgreSQL's range type. There are a number of
--   existing range data types, but PostgreSQL's is rather particular. This
--   tries to provide a one-to-one mapping.
module Database.PostgreSQL.Typed.Range

-- | A end-point for a range, which may be nothing (infinity, NULL in
--   PostgreSQL), open (inclusive), or closed (exclusive)
data Bound a

-- | Equivalent to <tt>Bounded False Â±Infinity</tt>
Unbounded :: Bound a
Bounded :: Bool -> a -> Bound a

-- | <tt>True</tt> if the range includes this bound
_boundClosed :: Bound a -> Bool
_bound :: Bound a -> a
newtype LowerBound a
Lower :: Bound a -> LowerBound a
boundLower :: LowerBound a -> Bound a

-- | Takes into account open vs. closed (but does not understand equivalent
--   discrete bounds)

-- | The constraint is only necessary for <tt>maxBound</tt>, unfortunately
newtype UpperBound a
Upper :: Bound a -> UpperBound a
boundUpper :: UpperBound a -> Bound a

-- | Takes into account open vs. closed (but does not understand equivalent
--   discrete bounds)

-- | The constraint is only necessary for <tt>minBound</tt>, unfortunately
compareBounds :: Ord a => LowerBound a -> UpperBound a -> Bound Bool
data Range a
Empty :: Range a
Range :: LowerBound a -> UpperBound a -> Range a
lower :: Range a -> LowerBound a
upper :: Range a -> UpperBound a
bound :: Bound a -> Maybe a

-- | Unbounded endpoints are always open.
boundClosed :: Bound a -> Bool

-- | Construct from parts: <tt>makeBound (boundClosed b) (bound b) ==
--   b</tt>
makeBound :: Bool -> Maybe a -> Bound a

-- | Empty ranges treated as <a>Unbounded</a>
lowerBound :: Range a -> Bound a

-- | Empty ranges treated as <a>Unbounded</a>
upperBound :: Range a -> Bound a

-- | Equivalent to <tt>boundClosed . lowerBound</tt>
lowerClosed :: Range a -> Bool

-- | Equivalent to <tt>boundClosed . upperBound</tt>
upperClosed :: Range a -> Bool
empty :: Range a
isEmpty :: Ord a => Range a -> Bool
full :: Range a
isFull :: Range a -> Bool

-- | Create a point range <tt>[x,x]</tt>
point :: Eq a => a -> Range a

-- | Extract a point: <tt>getPoint (point x) == Just x</tt>
getPoint :: Eq a => Range a -> Maybe a
range :: Ord a => Bound a -> Bound a -> Range a
normal :: Ord a => Maybe a -> Maybe a -> Range a
bounded :: Ord a => a -> a -> Range a
normalize :: Ord a => Range a -> Range a

-- | <a>normalize</a> for discrete (non-continuous) range types, using the
--   <a>Enum</a> instance
normalize' :: (Ord a, Enum a) => Range a -> Range a

-- | Contains range
(@>) :: Ord a => Range a -> Range a -> Bool

-- | Contains range
(<@) :: Ord a => Range a -> Range a -> Bool

-- | Contains element
(@>.) :: Ord a => Range a -> a -> Bool
overlaps :: Ord a => Range a -> Range a -> Bool
intersect :: Ord a => Range a -> Range a -> Range a

-- | Class indicating that the first PostgreSQL type is a range of the
--   second. This implies <a>PGParameter</a> and <a>PGColumn</a> instances
--   that will work for any type.
class (PGType tr, PGType t) => PGRangeType tr t | tr -> t where pgRangeElementType PGTypeProxy = PGTypeProxy
pgRangeElementType :: PGRangeType tr t => PGTypeName tr -> PGTypeName t
instance Eq a => Eq (Bound a)
instance Eq a => Eq (LowerBound a)
instance Functor LowerBound
instance Eq a => Eq (UpperBound a)
instance Functor UpperBound
instance Eq a => Eq (Range a)
instance PGRangeType "int8range" "bigint"
instance PGType "int8range"
instance PGRangeType "daterange" "date"
instance PGType "daterange"
instance PGRangeType "tstzrange" "timestamp with time zone"
instance PGType "tstzrange"
instance PGRangeType "tsrange" "timestamp without time zone"
instance PGType "tsrange"
instance PGRangeType "numrange" "numeric"
instance PGType "numrange"
instance PGRangeType "int4range" "integer"
instance PGType "int4range"
instance (PGRangeType tr t, PGColumn t a) => PGColumn tr (Range a)
instance (PGRangeType tr t, PGParameter t a) => PGParameter tr (Range a)
instance Ord a => Monoid (Range a)
instance Show a => Show (Range a)
instance Functor Range
instance Bounded a => Bounded (UpperBound a)
instance Ord a => Ord (UpperBound a)
instance Bounded a => Bounded (LowerBound a)
instance Ord a => Ord (LowerBound a)
instance Functor Bound


-- | Representaion of PostgreSQL's inet/cidr types using
--   <a>Network.Socket</a>. We don't (yet) supply PGColumn (parsing)
--   instances.
module Database.PostgreSQL.Typed.Inet
data PGInet
PGInet :: !HostAddress -> !Int -> PGInet
pgInetAddr :: PGInet -> !HostAddress
pgInetMask :: PGInet -> !Int
PGInet6 :: !HostAddress6 -> !Int -> PGInet
pgInetAddr6 :: PGInet -> !HostAddress6
pgInetMask :: PGInet -> !Int
sockAddrPGInet :: SockAddr -> Maybe PGInet
instance PGParameter "cidr" PGInet
instance PGParameter "inet" PGInet
instance PGType "cidr"
instance PGType "inet"
instance Show PGInet


-- | The Protocol module allows for direct, low-level communication with a
--   PostgreSQL server over TCP/IP. You probably don't want to use this
--   module directly.
module Database.PostgreSQL.Typed.Protocol

-- | Information for how to connect to a database, to be passed to
--   <a>pgConnect</a>.
data PGDatabase
PGDatabase :: HostName -> PortID -> ByteString -> ByteString -> ByteString -> Bool -> (MessageFields -> IO ()) -> PGDatabase

-- | The hostname (ignored if <a>pgDBPort</a> is <a>UnixSocket</a>)
pgDBHost :: PGDatabase -> HostName

-- | The port, likely either <tt>PortNumber 5432</tt> or <tt>UnixSocket
--   "/tmp/.s.PGSQL.5432"</tt>
pgDBPort :: PGDatabase -> PortID

-- | The name of the database
pgDBName :: PGDatabase -> ByteString
pgDBUser :: PGDatabase -> ByteString
pgDBPass :: PGDatabase -> ByteString

-- | Log all low-level server messages
pgDBDebug :: PGDatabase -> Bool

-- | How to log server notice messages (e.g., <tt>print . PGError</tt>)
pgDBLogMessage :: PGDatabase -> MessageFields -> IO ()

-- | A database connection with sane defaults: localhost:5432:postgres
defaultPGDatabase :: PGDatabase

-- | An established connection to the PostgreSQL server. These objects are
--   not thread-safe and must only be used for a single request at a time.
data PGConnection

-- | PGException is thrown upon encountering an <a>ErrorResponse</a> with
--   severity of ERROR, FATAL, or PANIC. It holds the message of the error.
data PGError
PGError :: MessageFields -> PGError
pgErrorFields :: PGError -> MessageFields

-- | Message SQLState code. See
--   <a>http://www.postgresql.org/docs/current/static/errcodes-appendix.html</a>.
pgErrorCode :: PGError -> ByteString
pgTypeEnv :: PGConnection -> PGTypeEnv

-- | Connect to a PostgreSQL server.
pgConnect :: PGDatabase -> IO PGConnection

-- | Disconnect cleanly from the PostgreSQL server.
pgDisconnect :: PGConnection -> IO ()

-- | Possibly re-open a connection to a different database, either reusing
--   the connection if the given database is already connected or closing
--   it and opening a new one. Regardless, the input connection must not be
--   used afterwards.
pgReconnect :: PGConnection -> PGDatabase -> IO PGConnection

-- | Describe a SQL statement/query. A statement description consists of 0
--   or more parameter descriptions (a PostgreSQL type) and zero or more
--   result field descriptions (for queries) (consist of the name of the
--   field, the type of the field, and a nullability indicator).
pgDescribe :: PGConnection -> ByteString -> [OID] -> Bool -> IO ([OID], [(ByteString, OID, Bool)])

-- | A simple query is one which requires sending only a single
--   <a>SimpleQuery</a> message to the PostgreSQL server. The query is sent
--   as a single string; you cannot bind parameters. Note that queries can
--   return 0 results (an empty list).
pgSimpleQuery :: PGConnection -> ByteString -> IO (Int, [PGValues])

-- | A simple query which may contain multiple queries (separated by
--   semi-colons) whose results are all ignored.
pgSimpleQueries_ :: PGConnection -> ByteString -> IO ()

-- | Prepare a statement, bind it, and execute it. If the given statement
--   has already been prepared (and not yet closed) on this connection, it
--   will be re-used.
pgPreparedQuery :: PGConnection -> ByteString -> [OID] -> PGValues -> [Bool] -> IO (Int, [PGValues])

-- | Like <a>pgPreparedQuery</a> but requests results lazily in chunks of
--   the given size. Does not use a named portal, so other requests may not
--   intervene.
pgPreparedLazyQuery :: PGConnection -> ByteString -> [OID] -> PGValues -> [Bool] -> Word32 -> IO [PGValues]

-- | Close a previously prepared query (if necessary).
pgCloseStatement :: PGConnection -> ByteString -> [OID] -> IO ()
instance Typeable PGError
instance Show PGState
instance Eq PGState
instance Show ColDescription
instance Show PGFrontendMessage
instance Show PGBackendMessage
instance Exception PGError
instance Show PGError
instance Eq PGDatabase


-- | Support functions for compile-time PostgreSQL connection and state
--   management. You can use these to build your own Template Haskell
--   functions using the PostgreSQL connection.
module Database.PostgreSQL.Typed.TH

-- | Generate a <a>PGDatabase</a> based on the environment variables:
--   <tt>TPG_HOST</tt> (localhost); <tt>TPG_SOCK</tt> or <tt>TPG_PORT</tt>
--   (5432); <tt>TPG_DB</tt> or user; <tt>TPG_USER</tt> or <tt>USER</tt>
--   (postgres); <tt>TPG_PASS</tt> ()
getTPGDatabase :: IO PGDatabase

-- | Run an action using the Template Haskell PostgreSQL connection.
withTPGConnection :: (PGConnection -> IO a) -> IO a

-- | Specify an alternative database to use during compilation. This lets
--   you override the default connection parameters that are based on TPG
--   environment variables. This should be called as a top-level
--   declaration and produces no code. It uses <a>pgReconnect</a> so is
--   safe to call multiple times with the same database.
useTPGDatabase :: PGDatabase -> DecsQ

-- | Force reloading of all types from the database. This may be needed if
--   you make structural changes to the database during compile-time.
reloadTPGTypes :: DecsQ
data TPGValueInfo
TPGValueInfo :: ByteString -> !OID -> TPGType -> Bool -> TPGValueInfo
tpgValueName :: TPGValueInfo -> ByteString
tpgValueTypeOID :: TPGValueInfo -> !OID
tpgValueType :: TPGValueInfo -> TPGType
tpgValueNullable :: TPGValueInfo -> Bool

-- | A type-aware wrapper to <a>pgDescribe</a>
tpgDescribe :: ByteString -> [String] -> Bool -> IO ([TPGValueInfo], [TPGValueInfo])

-- | TH expression to encode a <a>PGParameter</a> value to a <a>Maybe</a>
--   <a>ByteString</a>.
tpgTypeEncoder :: Bool -> TPGValueInfo -> Name -> Exp

-- | TH expression to decode a <a>Maybe</a> <a>ByteString</a> to a
--   (<a>Maybe</a>) <a>PGColumn</a> value.
tpgTypeDecoder :: Bool -> TPGValueInfo -> Name -> Exp

-- | TH expression calling <a>pgBinaryColumn</a>.
tpgTypeBinary :: TPGValueInfo -> Name -> Exp

module Database.PostgreSQL.Typed.Query
class PGQuery q a | q -> a
pgRunQuery :: PGQuery q a => PGConnection -> q -> IO (Int, [a])
unsafeModifyQuery :: PGQuery q a => q -> (ByteString -> ByteString) -> q

-- | A simple one-shot query that simply substitutes literal
--   representations of parameters for placeholders.
type PGSimpleQuery = QueryParser SimpleQuery

-- | A prepared query that automatically is prepared in the database the
--   first time it is run and bound with new parameters each subsequent
--   time.
type PGPreparedQuery = QueryParser PreparedQuery

-- | Make a simple query directly from a query string, with no type
--   inference
rawPGSimpleQuery :: ByteString -> PGSimpleQuery PGValues

-- | Make a prepared query directly from a query string and bind
--   parameters, with no type inference
rawPGPreparedQuery :: ByteString -> PGValues -> PGPreparedQuery PGValues

-- | Flags affecting how and what type of query to build with
--   <a>makePGQuery</a>.
data QueryFlags
QueryFlags :: Bool -> Maybe Bool -> Maybe [String] -> QueryFlags

-- | Create a query -- otherwise just call <a>pgSubstituteLiterals</a> to
--   create a string (SQL fragment).
flagQuery :: QueryFlags -> Bool

-- | Disable nullability inference, treating all values as nullable (if
--   <a>True</a>) or not (if <a>False</a>).
flagNullable :: QueryFlags -> Maybe Bool

-- | Prepare and re-use query, binding parameters of the given types
--   (inferring the rest, like PREPARE).
flagPrepare :: QueryFlags -> Maybe [String]

-- | <a>QueryFlags</a> for a default (simple) query.
simpleQueryFlags :: QueryFlags

-- | Parse flags off the beginning of a query string, returning the flags
--   and the remaining string.
parseQueryFlags :: String -> (QueryFlags, String)

-- | Construct a <a>PGQuery</a> from a SQL string.
makePGQuery :: QueryFlags -> String -> ExpQ

-- | A quasi-quoter for PGSQL queries.
--   
--   Used in expression context, it may contain any SQL statement
--   <tt>[pgSQL|SELECT ...|]</tt>. The statement may contain
--   PostgreSQL-style placeholders (<tt>$1</tt>, <tt>$2</tt>, ...) or
--   in-line placeholders (<tt>${1+1}</tt>) containing any valid Haskell
--   expression (except <tt>{}</tt>). It will be replaced by a
--   <a>PGQuery</a> object that can be used to perform the SQL statement.
--   If there are more <tt>$N</tt> placeholders than expressions, it will
--   instead be a function accepting the additional parameters and
--   returning a <a>PGQuery</a>.
--   
--   Note that all occurrences of <tt>$N</tt> or <tt>${</tt> will be
--   treated as placeholders, regardless of their context in the SQL (e.g.,
--   even within SQL strings or other places placeholders are disallowed by
--   PostgreSQL), which may cause invalid SQL or other errors. If you need
--   to pass a literal <tt>$</tt> through in these contexts, you may double
--   it to escape it as <tt>$$N</tt> or <tt>$${</tt>.
--   
--   The statement may start with one of more special flags affecting the
--   interpretation:
--   
--   <ul>
--   <li><i><tt>?</tt></i> To disable nullability inference, treating all
--   result values as nullable, thus returning <a>Maybe</a> values
--   regardless of inferred nullability. This makes unexpected NULL errors
--   impossible.</li>
--   <li><i><tt>!</tt></i> To disable nullability inference, treating all
--   result values as <i>not</i> nullable, thus only returning <a>Maybe</a>
--   where requested. This is makes unexpected NULL errors more
--   likely.</li>
--   <li><i><tt>$</tt></i> To create a <a>PGPreparedQuery</a> rather than a
--   <a>PGSimpleQuery</a>, by default inferring parameter types.</li>
--   <li><i><tt>$(type,...)</tt></i> To specify specific types to a
--   prepared query (see
--   <a>http://www.postgresql.org/docs/current/static/sql-prepare.html</a>
--   for details).</li>
--   <li><i><tt>#</tt></i> Only do literal <tt>${}</tt> substitution using
--   <a>pgSubstituteLiterals</a> and return a string, not a query.</li>
--   </ul>
--   
--   <a>pgSQL</a> can also be used at the top-level to execute SQL
--   statements at compile-time (without any parameters and ignoring
--   results). Here the query can only be prefixed with <tt>!</tt> to make
--   errors non-fatal.
pgSQL :: QuasiQuoter

-- | Execute a query that does not return results. Return the number of
--   rows affected (or -1 if not known).
pgExecute :: PGQuery q () => PGConnection -> q -> IO Int

-- | Run a query and return a list of row results.
pgQuery :: PGQuery q a => PGConnection -> q -> IO [a]

-- | Run a prepared query in lazy mode, where only chunk size rows are
--   requested at a time. If you eventually retrieve all the rows this way,
--   it will be far less efficient than using <tt>pgQuery</tt>, since every
--   chunk requires an additional round-trip. Although you may safely stop
--   consuming rows early, currently you may not interleave any other
--   database operation while reading rows. (This limitation could
--   theoretically be lifted if required.)
pgLazyQuery :: PGConnection -> PGPreparedQuery a -> Word32 -> IO [a]
instance IsString (PGSimpleQuery ())
instance IsString (PGSimpleQuery PGValues)
instance Functor (QueryParser q)
instance PGRawQuery q => PGQuery (QueryParser q a) a
instance PGRawQuery PreparedQuery
instance PGQuery PreparedQuery PGValues
instance PGRawQuery SimpleQuery
instance PGQuery SimpleQuery PGValues
instance PGQuery ByteString PGValues


-- | Support for PostgreSQL enums.
module Database.PostgreSQL.Typed.Enum

-- | A type based on a PostgreSQL enum. Automatically instantiated by
--   <a>makePGEnum</a>.
class (Eq a, Ord a, Enum a, Bounded a, Show a) => PGEnum a

-- | List of all the values in the enum along with their database names.
pgEnumValues :: PGEnum a => [(a, String)]

-- | Create a new enum type corresponding to the given PostgreSQL enum
--   type. For example, if you have <tt>CREATE TYPE foo AS ENUM ('abc',
--   'DEF');</tt>, then <tt>makePGEnum "foo" "Foo" ("Foo_"++)</tt> will be
--   equivalent to:
--   
--   <pre>
--   data Foo = Foo_abc | Foo_DEF deriving (Eq, Ord, Enum, Bounded, Typeable)
--   instance Show Foo where show Foo_abc = "abc" ...
--   instance PGType "foo"
--   instance PGParameter "foo" Foo where ...
--   instance PGColumn "foo" Foo where ...
--   instance PGRep "foo" Foo
--   instance PGEnum Foo where pgEnumValues = [(Foo_abc, "abc"), (Foo_DEF, "DEF")]
--   </pre>
--   
--   Requires language extensions: TemplateHaskell, FlexibleInstances,
--   MultiParamTypeClasses, DeriveDataTypeable, DataKinds
makePGEnum :: String -> String -> (String -> String) -> DecsQ


-- | This module exposes the high-level Template Haskell interface for
--   querying and manipulating the PostgreSQL server.
--   
--   All SQL string arguments support expression interpolation. Just
--   enclose your expression in <tt>{}</tt> in the SQL string.
--   
--   Note that transactions are messy and untested. Attempt to use them at
--   your own risk.
module Database.PostgreSQL.Typed.TemplatePG

-- | <pre>
--   queryTuples :: String -&gt; (PGConnection -&gt; IO [(column1, column2, ...)])
--   </pre>
--   
--   Query a PostgreSQL server and return the results as a list of tuples.
--   
--   Example (where <tt>h</tt> is a handle from <a>pgConnect</a>):
--   
--   <pre>
--   $(queryTuples "SELECT usesysid, usename FROM pg_user") h :: IO [(Maybe String, Maybe Integer)]
--   </pre>
queryTuples :: String -> ExpQ

-- | <pre>
--   queryTuple :: String -&gt; (PGConnection -&gt; IO (Maybe (column1, column2, ...)))
--   </pre>
--   
--   Convenience function to query a PostgreSQL server and return the first
--   result as a tuple. If the query produces no results, return
--   <a>Nothing</a>.
--   
--   Example (where <tt>h</tt> is a handle from <a>pgConnect</a>):
--   
--   <pre>
--   let sysid = 10::Integer;
--   $(queryTuple "SELECT usesysid, usename FROM pg_user WHERE usesysid = {sysid}") h :: IO (Maybe (Maybe String, Maybe Integer))
--   </pre>
queryTuple :: String -> ExpQ

-- | <pre>
--   execute :: String -&gt; (PGConnection -&gt; IO ())
--   </pre>
--   
--   Convenience function to execute a statement on the PostgreSQL server.
--   
--   Example (where <tt>h</tt> is a handle from <a>pgConnect</a>):
execute :: String -> ExpQ

-- | Ignore duplicate key errors. This is also limited to the <a>IO</a>
--   Monad.
insertIgnore :: IO () -> IO ()

-- | Run a sequence of IO actions (presumably SQL statements) wrapped in a
--   transaction. Unfortunately you're restricted to using this in the
--   <a>IO</a> Monad for now due to the use of <a>onException</a>. I'm
--   debating adding a <tt>MonadPeelIO</tt> version.
withTransaction :: PGConnection -> IO a -> IO a

-- | Roll back a transaction.
rollback :: PGConnection -> IO ()
type PGException = PGError
pgConnect :: HostName -> PortID -> ByteString -> ByteString -> ByteString -> IO PGConnection

-- | Disconnect cleanly from the PostgreSQL server.
pgDisconnect :: PGConnection -> IO ()

module Database.PostgreSQL.Typed

-- | PGException is thrown upon encountering an <a>ErrorResponse</a> with
--   severity of ERROR, FATAL, or PANIC. It holds the message of the error.
data PGError
PGError :: MessageFields -> PGError
pgErrorFields :: PGError -> MessageFields

-- | Information for how to connect to a database, to be passed to
--   <a>pgConnect</a>.
data PGDatabase
PGDatabase :: HostName -> PortID -> ByteString -> ByteString -> ByteString -> Bool -> (MessageFields -> IO ()) -> PGDatabase

-- | The hostname (ignored if <a>pgDBPort</a> is <a>UnixSocket</a>)
pgDBHost :: PGDatabase -> HostName

-- | The port, likely either <tt>PortNumber 5432</tt> or <tt>UnixSocket
--   "/tmp/.s.PGSQL.5432"</tt>
pgDBPort :: PGDatabase -> PortID

-- | The name of the database
pgDBName :: PGDatabase -> ByteString
pgDBUser :: PGDatabase -> ByteString
pgDBPass :: PGDatabase -> ByteString

-- | Log all low-level server messages
pgDBDebug :: PGDatabase -> Bool

-- | How to log server notice messages (e.g., <tt>print . PGError</tt>)
pgDBLogMessage :: PGDatabase -> MessageFields -> IO ()

-- | A database connection with sane defaults: localhost:5432:postgres
defaultPGDatabase :: PGDatabase

-- | An established connection to the PostgreSQL server. These objects are
--   not thread-safe and must only be used for a single request at a time.
data PGConnection

-- | Connect to a PostgreSQL server.
pgConnect :: PGDatabase -> IO PGConnection

-- | Disconnect cleanly from the PostgreSQL server.
pgDisconnect :: PGConnection -> IO ()

-- | Specify an alternative database to use during compilation. This lets
--   you override the default connection parameters that are based on TPG
--   environment variables. This should be called as a top-level
--   declaration and produces no code. It uses <a>pgReconnect</a> so is
--   safe to call multiple times with the same database.
useTPGDatabase :: PGDatabase -> DecsQ

-- | A quasi-quoter for PGSQL queries.
--   
--   Used in expression context, it may contain any SQL statement
--   <tt>[pgSQL|SELECT ...|]</tt>. The statement may contain
--   PostgreSQL-style placeholders (<tt>$1</tt>, <tt>$2</tt>, ...) or
--   in-line placeholders (<tt>${1+1}</tt>) containing any valid Haskell
--   expression (except <tt>{}</tt>). It will be replaced by a
--   <a>PGQuery</a> object that can be used to perform the SQL statement.
--   If there are more <tt>$N</tt> placeholders than expressions, it will
--   instead be a function accepting the additional parameters and
--   returning a <a>PGQuery</a>.
--   
--   Note that all occurrences of <tt>$N</tt> or <tt>${</tt> will be
--   treated as placeholders, regardless of their context in the SQL (e.g.,
--   even within SQL strings or other places placeholders are disallowed by
--   PostgreSQL), which may cause invalid SQL or other errors. If you need
--   to pass a literal <tt>$</tt> through in these contexts, you may double
--   it to escape it as <tt>$$N</tt> or <tt>$${</tt>.
--   
--   The statement may start with one of more special flags affecting the
--   interpretation:
--   
--   <ul>
--   <li><i><tt>?</tt></i> To disable nullability inference, treating all
--   result values as nullable, thus returning <a>Maybe</a> values
--   regardless of inferred nullability. This makes unexpected NULL errors
--   impossible.</li>
--   <li><i><tt>!</tt></i> To disable nullability inference, treating all
--   result values as <i>not</i> nullable, thus only returning <a>Maybe</a>
--   where requested. This is makes unexpected NULL errors more
--   likely.</li>
--   <li><i><tt>$</tt></i> To create a <a>PGPreparedQuery</a> rather than a
--   <a>PGSimpleQuery</a>, by default inferring parameter types.</li>
--   <li><i><tt>$(type,...)</tt></i> To specify specific types to a
--   prepared query (see
--   <a>http://www.postgresql.org/docs/current/static/sql-prepare.html</a>
--   for details).</li>
--   <li><i><tt>#</tt></i> Only do literal <tt>${}</tt> substitution using
--   <a>pgSubstituteLiterals</a> and return a string, not a query.</li>
--   </ul>
--   
--   <a>pgSQL</a> can also be used at the top-level to execute SQL
--   statements at compile-time (without any parameters and ignoring
--   results). Here the query can only be prefixed with <tt>!</tt> to make
--   errors non-fatal.
pgSQL :: QuasiQuoter

-- | Run a query and return a list of row results.
pgQuery :: PGQuery q a => PGConnection -> q -> IO [a]

-- | Execute a query that does not return results. Return the number of
--   rows affected (or -1 if not known).
pgExecute :: PGQuery q () => PGConnection -> q -> IO Int
