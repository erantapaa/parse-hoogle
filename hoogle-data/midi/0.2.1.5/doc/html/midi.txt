-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Handling of MIDI messages and files
--   
@package midi
@version 0.2.1.5


-- | Definition of a datatype that reports on the success of a parser.
module Sound.MIDI.Parser.Report

-- | This datatype is the result of a parser. First it stores a sequence of
--   warnings. Warnings are for corruptions of the input which can be
--   fixed. After encountering a series of warnings, there is finally an
--   end, either a successful one, with the result as <tt>(Right
--   result)</tt> or an eventual non-fixable problem indicated by <tt>(Left
--   errorMessage)</tt>.
data T a
Cons :: [UserMessage] -> Either UserMessage a -> T a
warnings :: T a -> [UserMessage]
result :: T a -> Either UserMessage a
type UserMessage = String
instance Show a => Show (T a)
instance Eq a => Eq (T a)


-- | MIDI controller data type and common controller definitions.
--   
--   See <a>http://www.midi.org/techspecs/midimessages.php</a>.
module Sound.MIDI.Controller
type T = Controller
type Value = Int
fromInt :: Int -> T
toInt :: T -> Int
bankSelect :: T
modulation :: T
breathControl :: T
footControl :: T
portamentoTime :: T
dataEntry :: T
volume :: T
balance :: T
panorama :: T
expression :: T
effectControl1 :: T
effectControl2 :: T
generalPurpose1 :: T
generalPurpose2 :: T
generalPurpose3 :: T
generalPurpose4 :: T
vectorX :: T
vectorY :: T
soundController1 :: T
soundController2 :: T
soundController3 :: T
soundController4 :: T
soundController5 :: T
soundController6 :: T
soundController7 :: T
soundController8 :: T
soundController9 :: T
soundController10 :: T
portamentoControl :: T
effect1Depth :: T
effect2Depth :: T
effect3Depth :: T
effect4Depth :: T
effect5Depth :: T
bankSelectMSB :: T
modulationMSB :: T
breathControlMSB :: T
footControlMSB :: T
portamentoTimeMSB :: T
dataEntryMSB :: T
volumeMSB :: T
balanceMSB :: T
panoramaMSB :: T
expressionMSB :: T
effectControl1MSB :: T
effectControl2MSB :: T
generalPurpose1MSB :: T
generalPurpose2MSB :: T
generalPurpose3MSB :: T
generalPurpose4MSB :: T
bankSelectLSB :: T
modulationLSB :: T
breathControlLSB :: T
footControlLSB :: T
portamentoTimeLSB :: T
dataEntryLSB :: T
volumeLSB :: T
balanceLSB :: T
panoramaLSB :: T
expressionLSB :: T
effectControl1LSB :: T
effectControl2LSB :: T
generalPurpose1LSB :: T
generalPurpose2LSB :: T
generalPurpose3LSB :: T
generalPurpose4LSB :: T
soundVariation :: T
timbre :: T
harmonicIntensity :: T
releaseTime :: T
attackTime :: T
brightness :: T
decayTime :: T
vibratoRate :: T
vibratoDepth :: T
vibratoDelay :: T
reverbSendLevel :: T
chorusSendLevel :: T
legato :: T
sustain :: T
portamento :: T
sustenuto :: T
softPedal :: T
hold2 :: T
generalPurpose5 :: T
generalPurpose6 :: T
generalPurpose7 :: T
generalPurpose8 :: T
externalEffectDepth :: T
tremoloDepth :: T
chorusDepth :: T
celesteDepth :: T
phaserDepth :: T
dataIncrement :: T
dataDecrement :: T
nonRegisteredParameterLSB :: T
nonRegisteredParameterMSB :: T
registeredParameterLSB :: T
registeredParameterMSB :: T


-- | Taken from Haskore.
module Sound.MIDI.IO

-- | Like <a>openFile</a>, but open the file in binary mode. On Windows,
--   reading a file in text mode (which is the default) will translate CRLF
--   to LF, and writing will translate LF to CRLF. This is usually what you
--   want with text files. With binary files this is undesirable; also, as
--   usual under Microsoft operating systems, text mode treats control-Z as
--   EOF. Binary mode turns off all special treatment of end-of-line and
--   end-of-file characters. (See also <a>hSetBinaryMode</a>.)
openBinaryFile :: FilePath -> IOMode -> IO Handle
readBinaryFile :: FilePath -> IO ByteList

-- | Hugs makes trouble here because it performs UTF-8 conversions. E.g.
--   <tt>[255]</tt> is output as <tt>[195,191]</tt> It would be easy to
--   replace these routines by FastPackedString(fps).ByteList.Lazy, however
--   this introduces a new package dependency.
writeBinaryFile :: FilePath -> ByteList -> IO ()
type ByteList = [Word8]
listCharFromByte :: ByteList -> String
listByteFromChar :: String -> ByteList


-- | System Real Time messages
module Sound.MIDI.Message.System.RealTime
data T
TimingClock :: T
Start :: T
Continue :: T
Stop :: T
ActiveSensing :: T
Reset :: T
get :: C parser => Int -> Fragile parser T
put :: C writer => T -> writer
instance Eq T
instance Ord T
instance Show T
instance Enum T
instance Ix T

module Sound.MIDI.KeySignature
data T
Cons :: Mode -> Accidentals -> T

-- | Accidentals as used in key signature.
newtype Accidentals
Accidentals :: Int -> Accidentals

-- | The Key Signature specifies a mode, either major or minor.
data Mode
Major :: Mode
Minor :: Mode
keyName :: Mode -> Accidentals -> String
cfMajor :: T
gfMajor :: T
dfMajor :: T
afMajor :: T
efMajor :: T
bfMajor :: T
fMajor :: T
cMajor :: T
gMajor :: T
dMajor :: T
aMajor :: T
eMajor :: T
bMajor :: T
fsMajor :: T
csMajor :: T
afMinor :: T
efMinor :: T
bfMinor :: T
fMinor :: T
cMinor :: T
gMinor :: T
dMinor :: T
aMinor :: T
eMinor :: T
bMinor :: T
fsMinor :: T
csMinor :: T
gsMinor :: T
dsMinor :: T
asMinor :: T
get :: C parser => Fragile parser T
toBytes :: T -> [Int]
instance Show Mode
instance Eq Mode
instance Ord Mode
instance Ix Mode
instance Enum Mode
instance Bounded Mode
instance Show Accidentals
instance Eq Accidentals
instance Ord Accidentals
instance Ix Accidentals
instance Eq T
instance Ord T
instance Arbitrary Accidentals
instance Random Accidentals
instance Enum Accidentals
instance Bounded Accidentals
instance Arbitrary Mode
instance Random Mode
instance Arbitrary T
instance Show T


-- | Channel mode messages
module Sound.MIDI.Message.Channel.Mode
data T
AllSoundOff :: T
ResetAllControllers :: T
LocalControl :: Bool -> T
AllNotesOff :: T
OmniMode :: Bool -> T
MonoMode :: Int -> T
PolyMode :: T
get :: C parser => Int -> Fragile parser T
put :: C writer => T -> writer

-- | This function is also used in alsa-midi, we could give it the result
--   type <tt>Parser.PossiblyIncomplete T</tt> otherwise.
fromControllerValue :: (Show a, Integral a) => (a, a) -> (Maybe UserMessage, T)
toControllerValue :: Integral a => T -> (a, a)
instance Show T
instance Eq T
instance Ord T
instance Arbitrary T


-- | System Common messages
module Sound.MIDI.Message.System.Common
data T
TimeCodeQuarterFrame :: TimeNibbleType -> Int -> T
SongPositionPointer :: Int -> T
SongSelect :: Int -> T
TuneRequest :: T
data TimeNibbleType
FrameLS :: TimeNibbleType
FrameMS :: TimeNibbleType
SecondsLS :: TimeNibbleType
SecondsMS :: TimeNibbleType
MinutesLS :: TimeNibbleType
MinutesMS :: TimeNibbleType
HoursLS :: TimeNibbleType

-- | also includes SMPTE type
HoursMS :: TimeNibbleType
get :: C parser => Int -> Fragile parser T
put :: C writer => T -> writer
instance Eq TimeNibbleType
instance Ord TimeNibbleType
instance Show TimeNibbleType
instance Enum TimeNibbleType
instance Ix TimeNibbleType


-- | MIDI device manufacturers and their id's.
module Sound.MIDI.Manufacturer
data T
get :: C parser => Fragile parser T
put :: C writer => T -> writer
sequential :: T
idp :: T
octavePlateau :: T
moog :: T
passport :: T
lexicon :: T
kurzweil :: T
fender :: T
gulbransen :: T
akg :: T
voyce :: T
waveframe :: T
ada :: T
garfield :: T
ensoniq :: T
oberheim :: T
apple :: T
greyMatter :: T
digidesign :: T
palmTree :: T
jlCooper :: T
lowrey :: T
adamsSmith :: T
emu :: T
harmony :: T
art :: T
baldwin :: T
eventide :: T
inventronics :: T
keyConcepts :: T
clarity :: T
timeWarner :: T
digitalMusic :: T
iota :: T
newEngland :: T
artisyn :: T
ivl :: T
southernMusic :: T
lakeButler :: T
alesis :: T
dod :: T
studerEditech :: T
perfectFret :: T
kat :: T
opcode :: T
rane :: T
anadi :: T
kmx :: T
brenell :: T
peavey :: T
systems360 :: T
spectrum :: T
marquis :: T
zeta :: T
axxes :: T
orban :: T
kti :: T
breakaway :: T
cae :: T
rocktron :: T
pianoDisc :: T
cannon :: T
rogers :: T
blueSkyLogic :: T
encore :: T
uptown :: T
voce :: T
cti :: T
ssResearch :: T
broderbund :: T
allenOrgan :: T
musicQuest :: T
aphex :: T
gallienKrueger :: T
ibm :: T
hotzInstruments :: T
etaLighting :: T
nsi :: T
adLib :: T
richmond :: T
microsoft :: T
softwareToolworks :: T
rjmgNiche :: T
intone :: T
grooveTubes :: T
euphonix :: T
interMIDI :: T
loneWolf :: T
musonix :: T
taHorng :: T
eTek :: T
electrovoice :: T
midisoft :: T
qSoundLabs :: T
westrex :: T
nVidia :: T
ess :: T
mediaTrix :: T
brooktree :: T
otari :: T
keyElectronics :: T
crystalake :: T
crystal :: T
rockwell :: T
siliconGraphics :: T
midiman :: T
preSonus :: T
topaz :: T
castLighting :: T
microsoftConsumer :: T
fastForward :: T
headspace :: T
vanKoevering :: T
altech :: T
vlsi :: T
chromaticResearch :: T
sapphire :: T
idrc :: T
justonic :: T
torComp :: T
newtek :: T
soundSculpture :: T
walker :: T
pavo :: T
inVision :: T
tSquareDesign :: T
nemesys :: T
dbx :: T
syndyne :: T
bitheadz :: T
cakewalk :: T
staccato :: T
nationalSemiconductor :: T
boomTheory :: T
virtualDSP :: T
antares :: T
angelSoftware :: T
stLouis :: T
lyrrus :: T
passac :: T
siel :: T
synthaxe :: T
hohner :: T
twister :: T
solton :: T
jellinghaus :: T
southworth :: T
ppg :: T
jen :: T
ssl :: T
audioVeritrieb :: T
elka :: T
dynacord :: T
viscount :: T
clavia :: T
audioArchitect :: T
generalMusic :: T
soundcraft :: T
wersi :: T
avab :: T
digigram :: T
waldorf :: T
quasimidi :: T
dream :: T
strandLighting :: T
amek :: T
drBohm :: T
trident :: T
realWorldDesign :: T
yesTechnology :: T
audiomatica :: T
bontempiFarfisa :: T
fbtElectronica :: T
miditemp :: T
larkingAudio :: T
zero88lighting :: T
miconAudio :: T
forefront :: T
kenton :: T
adb :: T
jimMarshall :: T
dda :: T
bssAudio :: T
tcElectronic :: T
medeli :: T
charlieLab :: T
blueChip :: T
beeOH :: T
lgSemiconductor :: T
tesi :: T
emagic :: T
behringer :: T
access :: T
synoptic :: T
hanmesoft :: T
terratec :: T
proel :: T
ibk :: T
kawai :: T
roland :: T
korg :: T
yamaha :: T
casio :: T
kamiya :: T
akai :: T
japanVictor :: T
mesosha :: T
hoshinoGakki :: T
fujitsuElect :: T
sony :: T
nisshinOnpa :: T
teac :: T
matsushitaElec :: T
fostex :: T
zoom :: T
midori :: T
matsushitaComm :: T
suzuki :: T
nonCommercial :: T
nonRealTime :: T
realTime :: T
instance Show T
instance Eq T
instance Ord T


-- | System Exclusive messages
module Sound.MIDI.Message.System.Exclusive
data T
Commercial :: T -> ByteList -> T
NonCommercial :: ByteList -> T

-- | <i>Deprecated: structure must be defined, yet</i>
NonRealTime :: NonRealTime -> T

-- | <i>Deprecated: structure must be defined, yet</i>
RealTime :: RealTime -> T
get :: C parser => Fragile parser T
getIncomplete :: C parser => Partial (Fragile parser) T

-- | It is not checked whether SysEx messages contain only 7-bit values.
put :: C writer => T -> writer


-- | System messages
module Sound.MIDI.Message.System
data T
Exclusive :: T -> T
Common :: T -> T
RealTime :: T -> T
get :: C parser => Int -> Fragile parser T
getIncomplete :: C parser => Int -> Partial (Fragile parser) T
put :: C writer => T -> writer

module Sound.MIDI.MachineControl
splitCommandList :: [Word8] -> [(Word8, [Word8])]
getCommand :: C parser => Word8 -> Fragile parser Command

-- | Read MIDI machine control commands until an F7 marker for SysEx end.
getCommands :: C parser => Partial parser [Command]
data Command
Stop :: Command
Play :: Command
DeferredPlay :: Command
FastForward :: Command
Rewind :: Command
RecordStrobe :: Command
RecordExit :: Command
RecordPause :: Command
Pause :: Command
Eject :: Command
Chase :: Command
CommandErrorReset :: Command
Reset :: Command
Wait :: Command
Resume :: Command
runParser :: Partial (T ByteList) a -> ByteList -> (PossiblyIncomplete a, [UserMessage])
instance Show Command

module Sound.MIDI.File.Event.SystemExclusive

-- | There are three forms of System Exclusive Messages in MIDI files:
--   monolithic, chopped into packets, escape form (with unrestricted
--   binary data).
--   
--   Currently we only support first and last type explicitly. But we leave
--   the trailing 0xF7 markers which can be used to detect whether the
--   messages are actually meant as packets.
--   
--   Since I don't know where manufacturer information is in the packets
--   form, I omit manufacturer handling for now.

-- | <i>Deprecated: implement this data type properly</i>
data T
Regular :: ByteList -> T
Escape :: ByteList -> T
get :: C parser => Int -> Fragile parser T
put :: C writer => T -> writer
instance Show T
instance Eq T
instance Ord T


-- | Channel voice messages
module Sound.MIDI.Message.Channel.Voice
data T
NoteOff :: Pitch -> Velocity -> T
NoteOn :: Pitch -> Velocity -> T
PolyAftertouch :: Pitch -> Pressure -> T
ProgramChange :: Program -> T
Control :: T -> ControllerValue -> T
PitchBend :: PitchBendRange -> T
MonoAftertouch :: Pressure -> T
get :: C parser => Int -> Int -> Fragile parser T
putWithStatus :: C writer => (Int -> T writer) -> T -> T writer
type ControllerValue = Value
type PitchBendRange = Int
type Pressure = Int
isNote :: T -> Bool

-- | NoteOn with zero velocity is considered NoteOff according to MIDI
--   specification.
isNoteOn :: T -> Bool

-- | NoteOn with zero velocity is considered NoteOff according to MIDI
--   specification.
isNoteOff :: T -> Bool

-- | A MIDI problem is that one cannot uniquely map a MIDI key to a
--   frequency. The frequency depends on the instrument. I don't know if
--   the deviations are defined for General MIDI. If this applies one could
--   add transposition information to the use patch map. For now I have
--   chosen a value that leads to the right frequency for some piano sound
--   in my setup.
zeroKey :: Pitch

-- | Convert all <tt>NoteOn p 0</tt> to <tt>NoteOff p 64</tt>. The latter
--   one is easier to process.
explicitNoteOff :: T -> T

-- | Convert all <tt>NoteOff p 64</tt> to <tt>NoteOn p 0</tt>. The latter
--   one can be encoded more efficiently using the running status.
implicitNoteOff :: T -> T

-- | Map integral MIDI controller value to floating point value. Maximum
--   integral MIDI controller value 127 is mapped to 1. Minimum integral
--   MIDI controller value 0 is mapped to 0.
realFromControllerValue :: (Integral a, Fractional b) => a -> b
bankSelect :: T
modulation :: T
breathControl :: T
footControl :: T
portamentoTime :: T
dataEntry :: T
mainVolume :: T
balance :: T
panorama :: T
expression :: T
generalPurpose1 :: T
generalPurpose2 :: T
generalPurpose3 :: T
generalPurpose4 :: T
vectorX :: T
vectorY :: T
bankSelectMSB :: T
modulationMSB :: T
breathControlMSB :: T
footControlMSB :: T
portamentoTimeMSB :: T
dataEntryMSB :: T
mainVolumeMSB :: T
balanceMSB :: T
panoramaMSB :: T
expressionMSB :: T
generalPurpose1MSB :: T
generalPurpose2MSB :: T
generalPurpose3MSB :: T
generalPurpose4MSB :: T
bankSelectLSB :: T
modulationLSB :: T
breathControlLSB :: T
footControlLSB :: T
portamentoTimeLSB :: T
dataEntryLSB :: T
mainVolumeLSB :: T
balanceLSB :: T
panoramaLSB :: T
expressionLSB :: T
generalPurpose1LSB :: T
generalPurpose2LSB :: T
generalPurpose3LSB :: T
generalPurpose4LSB :: T
sustain :: T
porta :: T
sustenuto :: T
softPedal :: T
hold2 :: T
generalPurpose5 :: T
generalPurpose6 :: T
generalPurpose7 :: T
generalPurpose8 :: T
extDepth :: T
tremoloDepth :: T
chorusDepth :: T
celesteDepth :: T
phaserDepth :: T
dataIncrement :: T
dataDecrement :: T
nonRegisteredParameterLSB :: T
nonRegisteredParameterMSB :: T
registeredParameterLSB :: T
registeredParameterMSB :: T
data Pitch
fromPitch :: Pitch -> Int
toPitch :: Int -> Pitch
data Velocity
fromVelocity :: Velocity -> Int
toVelocity :: Int -> Velocity
data Program
fromProgram :: Program -> Int
toProgram :: Int -> Program

-- | We do not define <a>Controller</a> as enumeration with many
--   constructors, because some controllers have multiple names and some
--   are undefined. It is also more efficient this way. Thus you cannot use
--   <tt>case</tt> for processing controller types, but you can use
--   <a>lookup</a> instead.
--   
--   <pre>
--   maybe (putStrLn "unsupported controller") putStrLn $
--   lookup ctrl $
--      (portamento, "portamento") :
--      (modulation, "modulation") :
--      []
--   </pre>
data Controller
fromController :: Controller -> Int
toController :: Int -> Controller
increasePitch :: Int -> Pitch -> Pitch
subtractPitch :: Pitch -> Pitch -> Int

-- | Convert pitch to frequency according to the default tuning given in
--   MIDI 1.0 Detailed Specification.
frequencyFromPitch :: Floating a => Pitch -> a

-- | The velocity of an ordinary key stroke and the maximum possible
--   velocity.
maximumVelocity :: Velocity

-- | The velocity of an ordinary key stroke and the maximum possible
--   velocity.
normalVelocity :: Velocity

-- | MIDI specification says, if velocity is simply mapped to amplitude,
--   then this should be done by an exponential function. Thus we map
--   <a>normalVelocity</a> (64) to 0, <a>maximumVelocity</a> (127) to 1,
--   and <tt>minimumVelocity</tt> (1) to -1. That is, normally you should
--   write something like <tt>amplitude = 2 ** realFromVelocity vel</tt> or
--   <tt>3 ** realFromVelocity vel</tt>.
realFromVelocity :: Fractional b => Velocity -> b
instance Show Pitch
instance Eq Pitch
instance Ord Pitch
instance Ix Pitch
instance Show Velocity
instance Eq Velocity
instance Ord Velocity
instance Show Program
instance Eq Program
instance Ord Program
instance Ix Program
instance Show T
instance Eq T
instance Ord T
instance Bounded Program
instance Bounded Velocity
instance Bounded Pitch
instance Enum Program
instance Enum Pitch
instance Arbitrary Program
instance Random Program
instance Arbitrary Velocity
instance Random Velocity
instance Arbitrary Pitch
instance Random Pitch
instance Arbitrary T


-- | Channel messages
module Sound.MIDI.Message.Channel
data T
Cons :: Channel -> Body -> T
messageChannel :: T -> Channel
messageBody :: T -> Body
data Body
Voice :: T -> Body
Mode :: T -> Body

-- | Parse a MIDI Channel message. Note that since getting the first byte
--   is a little complex (there are issues with running status), the code,
--   channel and first data byte must be determined by the caller.
get :: C parser => Int -> Channel -> Int -> Fragile parser T

-- | Parse an event. Note that in the case of a regular MIDI Event, the tag
--   is the status, and we read the first byte of data before we call
--   <a>get</a>. In the case of a MIDIEvent with running status, we find
--   out the status from the parser (it's been nice enough to keep track of
--   it for us), and the tag that we've already gotten is the first byte of
--   data.
getWithStatus :: C parser => Int -> Fragile (T parser) T
put :: C writer => T -> writer
putWithStatus :: C writer => T -> T writer

-- | This definition should be in Message.Channel, but this results in a
--   cyclic import.
data Channel
fromChannel :: Channel -> Int
toChannel :: Int -> Channel
data Pitch
fromPitch :: Pitch -> Int
toPitch :: Int -> Pitch
data Velocity
fromVelocity :: Velocity -> Int
toVelocity :: Int -> Velocity
data Program
fromProgram :: Program -> Int
toProgram :: Int -> Program

-- | We do not define <a>Controller</a> as enumeration with many
--   constructors, because some controllers have multiple names and some
--   are undefined. It is also more efficient this way. Thus you cannot use
--   <tt>case</tt> for processing controller types, but you can use
--   <a>lookup</a> instead.
--   
--   <pre>
--   maybe (putStrLn "unsupported controller") putStrLn $
--   lookup ctrl $
--      (portamento, "portamento") :
--      (modulation, "modulation") :
--      []
--   </pre>
data Controller
fromController :: Controller -> Int
toController :: Int -> Controller

-- | for internal use
decodeStatus :: Int -> (Int, Channel)
instance Show Body
instance Eq Body
instance Ord Body
instance Show T
instance Eq T
instance Ord T
instance Arbitrary T


-- | MIDI messages for real-time communication with MIDI devices. This does
--   not cover MIDI file events. For these refer to
--   <a>Sound.MIDI.File.Event</a>.
module Sound.MIDI.Message
data T
Channel :: T -> T
System :: T -> T
get :: C parser => Fragile parser T
getWithStatus :: C parser => Fragile (T parser) T
getIncompleteWithStatus :: C parser => Partial (Fragile (T parser)) T
put :: C writer => T -> writer
putWithStatus :: C writer => T -> T writer
maybeFromByteString :: ByteString -> T T
toByteString :: T -> ByteString

module Sound.MIDI.File.Event.Meta
data T
SequenceNum :: Int -> T
TextEvent :: String -> T
Copyright :: String -> T
TrackName :: String -> T
InstrumentName :: String -> T
Lyric :: String -> T
Marker :: String -> T
CuePoint :: String -> T
MIDIPrefix :: Channel -> T
EndOfTrack :: T
SetTempo :: Tempo -> T
SMPTEOffset :: SMPTEHours -> SMPTEMinutes -> SMPTESeconds -> SMPTEFrames -> SMPTEBits -> T
TimeSig :: Int -> Int -> Int -> Int -> T
KeySig :: T -> T
SequencerSpecific :: ByteList -> T
Unknown :: Int -> ByteList -> T
type ElapsedTime = Integer
fromElapsedTime :: ElapsedTime -> Integer
toElapsedTime :: Integer -> ElapsedTime
type Tempo = Int
fromTempo :: Tempo -> Int
toTempo :: Int -> Tempo

-- | The default SetTempo value, in microseconds per quarter note. This
--   expresses the default of 120 beats per minute.
defltTempo :: Tempo
type SMPTEHours = Int
type SMPTEMinutes = Int
type SMPTESeconds = Int
type SMPTEFrames = Int
type SMPTEBits = Int
get :: C parser => Fragile parser T
put :: C writer => T -> writer
instance Show T
instance Eq T
instance Ord T
instance Arbitrary T


-- | MIDI messages in MIDI files. They are not a superset of the messages,
--   that are used for real-time communication between MIDI devices. For
--   these refer to <a>Sound.MIDI.Message</a>. Namely System Common and
--   System Real Time messages are missing. If you need both real-time and
--   file messages (say for ALSA sequencer), you need a custom datatype.
module Sound.MIDI.File.Event
data T
MIDIEvent :: T -> T
MetaEvent :: T -> T
SystemExclusive :: T -> T
get :: C parser => Fragile (T parser) T

-- | The following functions encode various <a>T</a> elements into the raw
--   data of a standard MIDI file.
put :: C writer => T -> T writer
type TrackEvent = (ElapsedTime, T)

-- | Each event is preceded by the delta time: the time in ticks between
--   the last event and the current event. Parse a time and an event,
--   ignoring System Exclusive messages.
getTrackEvent :: C parser => Fragile (T parser) TrackEvent
type ElapsedTime = Integer
fromElapsedTime :: ElapsedTime -> Integer
toElapsedTime :: Integer -> ElapsedTime
mapBody :: (T -> T) -> (TrackEvent -> TrackEvent)
maybeMIDIEvent :: T -> Maybe T
maybeMetaEvent :: T -> Maybe T
maybeVoice :: T -> Maybe (Channel, T)
mapVoice :: (T -> T) -> T -> T
instance Show T
instance Eq T
instance Ord T
instance Arbitrary T

module Sound.MIDI.Message.Class.Check

-- | All methods have default implementations that return <a>Nothing</a>.
--   This helps implementing event data types that support only a subset of
--   types of events.
--   
--   Maybe a better approach is to provide type classes for every type of
--   event and make <a>C</a> a subclass of all of them.
class C event where note _chan _ev = Nothing program _chan _ev = Nothing anyController _chan _ev = Nothing pitchBend _chan _ev = Nothing channelPressure _chan _ev = Nothing mode _chan _ev = Nothing
note :: C event => Channel -> event -> Maybe (Velocity, Pitch, Bool)
program :: C event => Channel -> event -> Maybe Program
anyController :: C event => Channel -> event -> Maybe (Controller, Int)
pitchBend :: C event => Channel -> event -> Maybe Int
channelPressure :: C event => Channel -> event -> Maybe Int
mode :: C event => Channel -> event -> Maybe T

-- | Like <a>note</a>, but converts <tt>NoteOn p 0</tt> to <tt>NoteOff p
--   64</tt>. See <a>explicitNoteOff</a>.
noteExplicitOff :: C event => Channel -> event -> Maybe (Velocity, Pitch, Bool)

-- | Like <a>note</a>, but converts <tt>NoteOff p 64</tt> to <tt>NoteOn p
--   0</tt>. See <a>implicitNoteOff</a>.
noteImplicitOff :: C event => Channel -> event -> Maybe (Velocity, Pitch, Bool)
controller :: C event => Channel -> Controller -> event -> Maybe Int
liftMidi :: (Channel -> T -> Maybe a) -> (Channel -> T -> Maybe a)
instance C T
instance C T

module Sound.MIDI.Message.Class.Query

-- | All methods have default implementations that return <a>Nothing</a>.
--   This helps implementing event data types that support only a subset of
--   types of events.
--   
--   Maybe a better approach is to provide type classes for every type of
--   event and make <a>C</a> a subclass of all of them.
class C event where note _ev = Nothing program _ev = Nothing anyController _ev = Nothing pitchBend _ev = Nothing channelPressure _ev = Nothing mode _ev = Nothing
note :: C event => event -> Maybe (Channel, (Velocity, Pitch, Bool))
program :: C event => event -> Maybe (Channel, Program)
anyController :: C event => event -> Maybe (Channel, (Controller, Int))
pitchBend :: C event => event -> Maybe (Channel, Int)
channelPressure :: C event => event -> Maybe (Channel, Int)
mode :: C event => event -> Maybe (Channel, T)

-- | Like <a>note</a>, but converts <tt>NoteOn p 0</tt> to <tt>NoteOff p
--   64</tt>. See <a>explicitNoteOff</a>.
noteExplicitOff :: C event => event -> Maybe (Channel, (Velocity, Pitch, Bool))

-- | Like <a>note</a>, but converts <tt>NoteOff p 64</tt> to <tt>NoteOn p
--   0</tt>. See <a>implicitNoteOff</a>.
noteImplicitOff :: C event => event -> Maybe (Channel, (Velocity, Pitch, Bool))
liftMidi :: (T -> Maybe (Channel, a)) -> (T -> Maybe (Channel, a))
instance C T
instance C T

module Sound.MIDI.Message.Class.Construct
class C event
note :: C event => Channel -> (Velocity, Pitch, Bool) -> event
program :: C event => Channel -> Program -> event
anyController :: C event => Channel -> (Controller, Int) -> event
pitchBend :: C event => Channel -> Int -> event
channelPressure :: C event => Channel -> Int -> event
mode :: C event => Channel -> T -> event
liftChannel :: (a -> Body) -> (Channel -> a -> T)

-- | Like <a>note</a>, but converts <tt>NoteOn p 0</tt> to <tt>NoteOff p
--   64</tt>. See <a>explicitNoteOff</a>.
noteExplicitOff :: C event => Channel -> (Velocity, Pitch, Bool) -> event

-- | Like <a>note</a>, but converts <tt>NoteOff p 64</tt> to <tt>NoteOn p
--   0</tt>. See <a>implicitNoteOff</a>.
noteImplicitOff :: C event => Channel -> (Velocity, Pitch, Bool) -> event
liftMidi :: (Channel -> a -> T) -> (Channel -> a -> T)
instance C T
instance C T


-- | General-MIDI definitions.
--   
--   Taken from Haskore.
module Sound.MIDI.General
instrumentNameToProgram :: String -> Maybe Program
instrumentNames :: [String]
instrumentPrograms :: [(String, Program)]
instrumentFromProgram :: Program -> Instrument
instrumentToProgram :: Instrument -> Program
instrumentChannels :: [Channel]
instruments :: [Instrument]
data Instrument
AcousticGrandPiano :: Instrument
BrightAcousticPiano :: Instrument
ElectricGrandPiano :: Instrument
HonkyTonk :: Instrument
ElectricPiano1 :: Instrument
ElectricPiano2 :: Instrument
Harpsichord :: Instrument
Clavinet :: Instrument
Celesta :: Instrument
Glockenspiel :: Instrument
MusicBox :: Instrument
Vibraphone :: Instrument
Marimba :: Instrument
Xylophone :: Instrument
TubularBells :: Instrument
Dulcimer :: Instrument
DrawbarOrgan :: Instrument
PercussiveOrgan :: Instrument
RockOrgan :: Instrument
ChurchOrgan :: Instrument
ReedOrgan :: Instrument
Accordion :: Instrument
Harmonica :: Instrument
TangoAccordian :: Instrument
AcousticGuitarNylon :: Instrument
AcousticGuitarSteel :: Instrument
ElectricGuitarJazz :: Instrument
ElectricGuitarClean :: Instrument
ElectricGuitarMuted :: Instrument
OverdrivenGuitar :: Instrument
DistortionGuitar :: Instrument
GuitarHarmonics :: Instrument
AcousticBass :: Instrument
ElectricBassFinger :: Instrument
ElectricBassPick :: Instrument
FretlessBass :: Instrument
SlapBass1 :: Instrument
SlapBass2 :: Instrument
SynthBass1 :: Instrument
SynthBass2 :: Instrument
Violin :: Instrument
Viola :: Instrument
Cello :: Instrument
Contrabass :: Instrument
TremoloStrings :: Instrument
PizzicatoStrings :: Instrument
OrchestralHarp :: Instrument
Timpani :: Instrument
StringEnsemble1 :: Instrument
StringEnsemble2 :: Instrument
SynthStrings1 :: Instrument
SynthStrings2 :: Instrument
ChoirAahs :: Instrument
VoiceOohs :: Instrument
SynthVoice :: Instrument
OrchestraHit :: Instrument
Trumpet :: Instrument
Trombone :: Instrument
Tuba :: Instrument
MutedTrumpet :: Instrument
FrenchHorn :: Instrument
BrassSection :: Instrument
SynthBrass1 :: Instrument
SynthBrass2 :: Instrument
SopranoSax :: Instrument
AltoSax :: Instrument
TenorSax :: Instrument
BaritoneSax :: Instrument
Oboe :: Instrument
EnglishHorn :: Instrument
Bassoon :: Instrument
Clarinet :: Instrument
Piccolo :: Instrument
Flute :: Instrument
Recorder :: Instrument
PanFlute :: Instrument
BlownBottle :: Instrument
Skakuhachi :: Instrument
Whistle :: Instrument
Ocarina :: Instrument
Lead1Square :: Instrument
Lead2Sawtooth :: Instrument
Lead3Calliope :: Instrument
Lead4Chiff :: Instrument
Lead5Charang :: Instrument
Lead6Voice :: Instrument
Lead7Fifths :: Instrument
Lead8BassLead :: Instrument
Pad1NewAge :: Instrument
Pad2Warm :: Instrument
Pad3Polysynth :: Instrument
Pad4Choir :: Instrument
Pad5Bowed :: Instrument
Pad6Metallic :: Instrument
Pad7Halo :: Instrument
Pad8Sweep :: Instrument
FX1Rain :: Instrument
FX2Soundtrack :: Instrument
FX3Crystal :: Instrument
FX4Atmosphere :: Instrument
FX5Brightness :: Instrument
FX6Goblins :: Instrument
FX7Echoes :: Instrument
FX8SciFi :: Instrument
Sitar :: Instrument
Banjo :: Instrument
Shamisen :: Instrument
Koto :: Instrument
Kalimba :: Instrument
Bagpipe :: Instrument
Fiddle :: Instrument
Shanai :: Instrument
TinkleBell :: Instrument
Agogo :: Instrument
SteelDrums :: Instrument
Woodblock :: Instrument
TaikoDrum :: Instrument
MelodicTom :: Instrument
SynthDrum :: Instrument
ReverseCymbal :: Instrument
GuitarFretNoise :: Instrument
BreathNoise :: Instrument
Seashore :: Instrument
BirdTweet :: Instrument
TelephoneRing :: Instrument
Helicopter :: Instrument
Applause :: Instrument
Gunshot :: Instrument
drumChannel :: Channel
drumProgram :: Program
drumMinKey :: Pitch
drumKeyTable :: [(Drum, Pitch)]
drumFromKey :: Pitch -> Drum
drumToKey :: Drum -> Pitch
drums :: [Drum]
data Drum
AcousticBassDrum :: Drum
BassDrum1 :: Drum
SideStick :: Drum
AcousticSnare :: Drum
HandClap :: Drum
ElectricSnare :: Drum
LowFloorTom :: Drum
ClosedHiHat :: Drum
HighFloorTom :: Drum
PedalHiHat :: Drum
LowTom :: Drum
OpenHiHat :: Drum
LowMidTom :: Drum
HiMidTom :: Drum
CrashCymbal1 :: Drum
HighTom :: Drum
RideCymbal1 :: Drum
ChineseCymbal :: Drum
RideBell :: Drum
Tambourine :: Drum
SplashCymbal :: Drum
Cowbell :: Drum
CrashCymbal2 :: Drum
Vibraslap :: Drum
RideCymbal2 :: Drum
HiBongo :: Drum
LowBongo :: Drum
MuteHiConga :: Drum
OpenHiConga :: Drum
LowConga :: Drum
HighTimbale :: Drum
LowTimbale :: Drum
HighAgogo :: Drum
LowAgogo :: Drum
Cabasa :: Drum
Maracas :: Drum
ShortWhistle :: Drum
LongWhistle :: Drum
ShortGuiro :: Drum
LongGuiro :: Drum
Claves :: Drum
HiWoodBlock :: Drum
LowWoodBlock :: Drum
MuteCuica :: Drum
OpenCuica :: Drum
MuteTriangle :: Drum
OpenTriangle :: Drum
instance Show Instrument
instance Eq Instrument
instance Ord Instrument
instance Ix Instrument
instance Enum Instrument
instance Bounded Instrument
instance Show Drum
instance Eq Drum
instance Ord Drum
instance Ix Drum
instance Enum Drum
instance Bounded Drum
instance Arbitrary Drum
instance Random Drum
instance Arbitrary Instrument
instance Random Instrument


-- | MIDI-File Datatype
--   
--   Taken from Haskore.
module Sound.MIDI.File

-- | The datatypes for MIDI Files and MIDI Events
data T
Cons :: Type -> Division -> [Track] -> T
data Division
Ticks :: Tempo -> Division
SMPTE :: Int -> Int -> Division
type Track = T ElapsedTime T
data Type
Mixed :: Type
Parallel :: Type
Serial :: Type

-- | An empty MIDI file. Tempo is set to one tick per quarter note.
empty :: T
type ElapsedTime = Integer
fromElapsedTime :: ElapsedTime -> Integer
toElapsedTime :: Integer -> ElapsedTime
type Tempo = Int
fromTempo :: Tempo -> Int
toTempo :: Int -> Tempo

-- | Convert all <tt>NoteOn p 0</tt> to <tt>NoteOff p 64</tt>. The latter
--   one is easier to process.
explicitNoteOff :: T -> T

-- | Convert all <tt>NoteOff p 64</tt> to <tt>NoteOn p 0</tt>. The latter
--   one can be encoded more efficiently using the running status.
implicitNoteOff :: T -> T
getTracks :: T -> [Track]

-- | Merge all tracks into a single track according to the MIDI file type.
mergeTracks :: C time => Type -> [T time event] -> T time event

-- | Process and remove all <tt>SetTempo</tt> events. The result is an
--   event list where the times are measured in seconds.
secondsFromTicks :: Division -> T ElapsedTime T -> T Rational T
ticksPerQuarterNote :: Division -> Tempo

-- | Show the <a>T</a> with one event per line, suited for comparing
--   MIDIFiles with <tt>diff</tt>. Can this be replaced by <a>showFile</a>?

-- | <i>Deprecated: only use this for debugging</i>
showLines :: T -> String

-- | A hack that changes the velocities by a rational factor.

-- | <i>Deprecated: only use this for debugging</i>
changeVelocity :: Double -> T -> T

-- | Change the time base.

-- | <i>Deprecated: only use this for debugging</i>
resampleTime :: Double -> T -> T

-- | <i>Deprecated: only use this for debugging</i>
showEvent :: T -> ShowS

-- | <i>Deprecated: only use this for debugging</i>
showTime :: ElapsedTime -> ShowS

-- | Sort MIDI note events lexicographically. This is to make MIDI files
--   unique and robust against changes in the computation. In principle
--   Performance.merge should handle this but due to rounding errors in
--   Float the order of note events still depends on some internal issues.
--   The sample rate of MIDI events should be coarse enough to assert
--   unique results.

-- | <i>Deprecated: only use this for debugging</i>
sortEvents :: T -> T

-- | Old versions of <a>Haskore.Interface.MIDI.Write</a> wrote
--   <a>ProgramChange</a> and <a>SetTempo</a> once at the beginning of a
--   file in that order. The current version supports multiple
--   <a>ProgramChange</a>s in a track and thus a <a>ProgramChange</a> is
--   set immediately before a note. Because of this a <a>ProgramChange</a>
--   is now always after a <a>SetTempo</a>. For checking equivalence with
--   old MIDI files we can switch this back.

-- | <i>Deprecated: only use this for debugging</i>
progChangeBeforeSetTempo :: T -> T
instance Show Type
instance Eq Type
instance Ord Type
instance Ix Type
instance Enum Type
instance Bounded Type
instance Show Division
instance Eq Division
instance Show T
instance Eq T
instance Arbitrary Division
instance Arbitrary T


-- | Loading MIDI Files
--   
--   This module loads and parses a MIDI File. It can convert it into a
--   <a>T</a> data type object or simply print out the contents of the
--   file.
module Sound.MIDI.File.Load

-- | The main load function. Warnings are written to standard error output
--   and an error is signaled by a user exception. This function will not
--   be appropriate in GUI applications. For these, use
--   <a>maybeFromByteString</a> instead.
fromFile :: FilePath -> IO T

-- | This function ignores warnings, turns exceptions into errors, and
--   return partial results without warnings. Use this only in testing but
--   never in production code!
fromByteList :: ByteList -> T
maybeFromByteList :: ByteList -> T T
maybeFromByteString :: ByteString -> T T

-- | Functions to show the decoded contents of a MIDI file in an
--   easy-to-read format. This is for debugging purposes and should not be
--   used in production code.

-- | <i>Deprecated: only use this for debugging</i>
showFile :: FilePath -> IO ()


-- | Save MIDI data to files.
--   
--   The functions in this module allow <a>T</a>s to be written into
--   Standard MIDI files (<tt>*.mid</tt>) that can be read and played by
--   music programs such as Cakewalk.
module Sound.MIDI.File.Save

-- | Directly write to a file. Since chunks lengths are not known before
--   writing, we need to seek in a file. Thus you cannot write to pipes
--   with this function.
toSeekableFile :: FilePath -> T -> IO ()

-- | The function <a>toFile</a> is the main function for writing <a>T</a>
--   values to an actual file.
toFile :: FilePath -> T -> IO ()

-- | Convert a MIDI file to a <a>ByteList</a>.
toByteList :: T -> ByteList

-- | Convert a MIDI file to a lazy <a>ByteString</a>.
toByteString :: T -> ByteString

-- | Convert a MIDI file to a lazy <a>ByteString</a>. It converts
--   <tt>NoteOff p 64</tt> to <tt>NoteOn p 0</tt> and then uses the running
--   MIDI status in order to compress the file.
toCompressedByteString :: T -> ByteString
