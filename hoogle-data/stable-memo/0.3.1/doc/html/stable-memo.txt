-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Memoization based on argument identity
--   
@package stable-memo
@version 0.3.1


-- | This module provides memo combinators with slightly different behavior
--   from those in <a>Data.StableMemo</a>. The memo tables generated by
--   these combinators use weak pointers to store the values, so they not
--   only do not unnecessarily retain the arguments, but they also do not
--   retain the function outputs. This can be useful for memoized functions
--   that are expected to be around for a long time. If the result for an
--   input has already been computed and happens to still be in the heap,
--   it will be reused, otherwise it will be recomputed.
module Data.StableMemo.Weak

-- | Memoize a unary function.
memo :: (a -> b) -> (a -> b)

-- | Curried memoization to share partial evaluation
memo2 :: (a -> b -> c) -> (a -> b -> c)

-- | Curried memoization to share partial evaluation
memo3 :: (a -> b -> c -> d) -> (a -> b -> c -> d)

-- | Memoize a function with support for a certain form of polymorphic
--   recursion.
memoPoly :: (forall a. f a -> g a) -> f b -> g b


-- | This module provides a small set of functions for memoization. Whereas
--   most memo combinators memoize based on equality, these do it based on
--   whether the exact same argument has been passed to the function before
--   (that is, is the same argument in memory).
--   
--   <ul>
--   <li>They only evaluate keys to WHNF.</li>
--   <li>Relative to value-base memoization, this can be more suitable for
--   recursive functions over graphs with cycles.</li>
--   <li>These don't retain the keys they have seen so far, which allows
--   mappings to be garbage collected if they will no longer be used.
--   Finalizers are put in place to remove the corresponding entries from
--   the memo table if this happens.</li>
--   <li><a>Data.StableMemo.Weak</a> provides an alternative set of
--   combinators that also avoid retaining the results of the function,
--   only reusing results if they have not yet been garbage collected.</li>
--   <li>There is no type class constraint on the function's argument.</li>
--   </ul>
--   
--   These will not work for arguments which happen to have the same value
--   but are not the same heap object. This rules out many candidates for
--   memoization, such as the most common example, the naive Fibonacci
--   implementation whose domain is machine Ints; it can still be made to
--   work for some domains, though, such as the lazy naturals.
--   
--   <pre>
--   data Nat = Succ Nat | Zero
--   
--   fib :: Nat -&gt; Integer
--   fib = memo fib'
--     where fib' Zero                = 0
--           fib' (Succ Zero)         = 1
--           fib' (Succ n1@(Succ n2)) = fib n1 + fib n2
--   </pre>
--   
--   Below is an implementation of map that preserves sharing of the spine
--   for cyclic lists. It should even be safe to use this on arbitrarily
--   long, acyclic lists since as long as the garbage collector is chasing
--   you, the size of the memo table should stay under control, too.
--   
--   <pre>
--   map :: (a -&gt; b) -&gt; [a] -&gt; [b]
--   map f = go
--     where go = memo map'
--           map' []     = []
--           map' (x:xs) = f x : go xs
--   </pre>
module Data.StableMemo

-- | Memoize a unary function.
memo :: (a -> b) -> (a -> b)

-- | Curried memoization to share partial evaluation
memo2 :: (a -> b -> c) -> (a -> b -> c)

-- | Curried memoization to share partial evaluation
memo3 :: (a -> b -> c -> d) -> (a -> b -> c -> d)

-- | Memoize a function with support for a certain form of polymorphic
--   recursion.
memoPoly :: (forall a. f a -> g a) -> f b -> g b
