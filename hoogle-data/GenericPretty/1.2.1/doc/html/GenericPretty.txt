-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A generic, derivable, haskell pretty printer.
--   
--   GenericPretty is a Haskell library that supports automatic derivation
--   of pretty printing functions on user defined data types.
--   
--   The form of generics used is based on that introduced in the paper:
--   Magalhaes, Dijkstra, Jeuring, and Loh, A Generic Deriving Mechanism
--   for Haskell, 3'rd ACM Symposium on Haskell, pp. 37-48, September 2010,
--   <a>http://dx.doi.org/10.1145/1863523.1863529</a>. Changes from the
--   original paper in the GHC implementation are described here:
--   <a>http://www.haskell.org/haskellwiki/GHC.Generics#Changes_from_the_paper</a>.
--   
--   This package requires the use of the new GHC.Generics features
--   <a>http://www.haskell.org/haskellwiki/GHC.Generics</a>, present from
--   GHC 7.2. Use of these features is indicated by the DeriveGeneric
--   pragma or the flag -XDeriveGeneric.
--   
--   Pretty printing produces values of type Text.PrettyPrint.Doc, using
--   the Text.PrettyPrint library
--   <a>http://www.haskell.org/ghc/docs/latest/html/libraries/pretty-1.1.1.0/Text-PrettyPrint.html</a>.
--   
--   The output provided is a pretty printed version of that provided by
--   Prelude.show. That is, rendering the document provided by this pretty
--   printer yields an output identical to that of Prelude.show, except for
--   extra whitespace.
--   
--   For information about the functions exported by the package please see
--   the API linked further down this page. For examples of usage, both
--   basic and more complex see the README file and the haskell source code
--   files in the TestSuite folder, both included in the package. Finally
--   for installation instructions also see the README file or this page:
--   <a>http://www.haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package</a>
@package GenericPretty
@version 1.2.1


-- | GenericPretty is a Haskell library that supports automatic derivation
--   of pretty printing functions on user defined data types.
--   
--   The output provided is a pretty printed version of that provided by
--   <a>show</a>. That is, rendering the document provided by this pretty
--   printer yields an output identical to that of <a>show</a>, except for
--   extra whitespace.
--   
--   For examples of usage please see the README file included in the
--   package.
--   
--   For more information see the HackageDB project page:
--   <a>http://hackage.haskell.org/package/GenericPretty</a>
module Text.PrettyPrint.GenericPretty

-- | The class <a>Out</a> is the equivalent of <a>Show</a>
--   
--   It provides conversion of values to pretty printable Pretty.Doc's.
--   
--   Minimal complete definition: <a>docPrec</a> or <a>doc</a>.
--   
--   Derived instances of <a>Out</a> have the following properties
--   
--   <ul>
--   <li>The result of <a>docPrec</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>docPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>docPrec</a> will produce the record-syntax form, with the fields
--   given in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   data Tree a =  Leaf a  |  Node (Tree a) (Tree a) deriving (Generic)
--   </pre>
--   
--   The derived instance of <a>Out</a> is equivalent to:
--   
--   <pre>
--   instance (Out a) =&gt; Out (Tree a) where
--    
--           docPrec d (Leaf m) = Pretty.sep $ wrapParens (d &gt; appPrec) $
--                text "Leaf" : [nest (constrLen + parenLen) (docPrec (appPrec+1) m)]
--             where appPrec = 10
--                   constrLen = 5;
--                   parenLen = if(d &gt; appPrec) then 1 else 0
--   
--           docPrec d (Node u v) = Pretty.sep $ wrapParens (d &gt; appPrec) $
--                text "Node" : 
--                nest (constrLen + parenLen) (docPrec (appPrec+1) u) : 
--                [nest (constrLen + parenLen) (docPrec (appPrec+1) v)]
--             where appPrec = 10
--                   constrLen = 5
--                   parenLen = if(d &gt; appPrec) then 1 else 0
--   </pre>
class Out a where docPrec n x = sep $ out1 (from x) Pref n False doc x = sep $ out1 (from x) Pref 0 False docList = docListWith doc
docPrec :: Out a => Int -> a -> Doc
doc :: Out a => a -> Doc
docList :: Out a => [a] -> Doc

-- | The default Pretty Printer,
--   
--   Equivalent to:
--   
--   <pre>
--   ppStyle defaultStyle
--   </pre>
--   
--   Where defaultStyle = (mode=PageMode, lineLength=80,
--   ribbonsPerLine=1.5)
pp :: Out a => a -> IO ()

-- | Semi-customizable pretty printer.
--   
--   Equivalent to:
--   
--   <pre>
--   ppStyle customStyle
--   </pre>
--   
--   Where customStyle uses the specified line length, mode = PageMode and
--   ribbonsPerLine = 1.
ppLen :: Out a => Int -> a -> IO ()

-- | Customizable pretty printer.
--   
--   Takes a user defined <a>Style</a> as a parameter and uses
--   <a>outputIO</a> to obtain the result
--   
--   Equivalent to:
--   
--   <pre>
--   fullPP outputIO (putChar '\n')
--   </pre>
ppStyle :: Out a => Style -> a -> IO ()

-- | The default pretty printer returning <a>String</a>s
--   
--   Equivalent to
--   
--   <pre>
--   prettyStyle defaultStyle
--   </pre>
--   
--   Where defaultStyle = (mode=PageMode, lineLength=80,
--   ribbonsPerLine=1.5)
pretty :: Out a => a -> String

-- | Semi-customizable pretty printer.
--   
--   Equivalent to:
--   
--   <pre>
--   prettyStyle customStyle
--   </pre>
--   
--   Where customStyle uses the specified line length, mode = PageMode and
--   ribbonsPerLine = 1.
prettyLen :: Out a => Int -> a -> String

-- | Customizable pretty printer
--   
--   Takes a user defined <a>Style</a> as a parameter and uses
--   <a>outputStr</a> to obtain the result
--   
--   Equivalent to:
--   
--   <pre>
--   fullPP outputStr ""
--   </pre>
prettyStyle :: Out a => Style -> a -> String

-- | <a>fullPP</a> is a fully customizable Pretty Printer
--   
--   Every other pretty printer just gives some default values to
--   <a>fullPP</a>
fullPP :: Out a => (TextDetails -> b -> b) -> b -> Style -> a -> b

-- | Representable types of kind *. This class is derivable in GHC with the
--   DeriveGeneric flag on.
class Generic a

-- | Utility function that handles the text conversion for <a>fullPP</a>.
--   
--   <a>outputIO</a> transforms the text into <a>String</a>s and outputs it
--   directly.
outputIO :: TextDetails -> IO () -> IO ()

-- | Utility function that handles the text conversion for <a>fullPP</a>.
--   
--   <a>outputStr</a> just leaves the text as a <a>String</a> which is
--   usefull if you want to further process the pretty printed result.
outputStr :: TextDetails -> String -> String
instance (Out a, Out b, Out c, Out d, Out e, Out f, Out g) => Out (a, b, c, d, e, f, g)
instance (Out a, Out b, Out c, Out d, Out e, Out f) => Out (a, b, c, d, e, f)
instance (Out a, Out b, Out c, Out d, Out e) => Out (a, b, c, d, e)
instance (Out a, Out b, Out c, Out d) => Out (a, b, c, d)
instance (Out a, Out b, Out c) => Out (a, b, c)
instance (Out a, Out b) => Out (a, b)
instance (Out a, Out b) => Out (Either a b)
instance Out a => Out (Maybe a)
instance Out Bool
instance Out a => Out [a]
instance Out Rational
instance Out Double
instance Out Float
instance Out Integer
instance Out Int
instance Out Char
instance Out ()
instance (GOut f, GOut g) => GOut (f :*: g)
instance (GOut f, GOut g) => GOut (f :+: g)
instance Out f => GOut (K1 t f)
instance (GOut f, Constructor c) => GOut (M1 C c f)
instance (GOut f, Selector c) => GOut (M1 S c f)
instance (GOut f, Datatype c) => GOut (M1 D c f)
instance GOut U1
