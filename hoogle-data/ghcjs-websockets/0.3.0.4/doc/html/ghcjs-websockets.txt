-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | GHCJS interface for the Javascript Websocket API
--   
@package ghcjs-websockets
@version 0.3.0.4


-- | Low-level API for the <a>Connection</a> socket wrapper, for situations
--   like debugging when things exported by <a>JavaScript.WebSockets</a> is
--   not enough. Most everyday usage should be covered by the
--   aforementioned module, so don't import this unless you really really
--   have to.
module JavaScript.WebSockets.Internal

-- | Encapsulates a (reference to a) Javascript Websocket connection. Can
--   be created/accessed with either <tt>openConnection</tt> or
--   (preferably) <tt>withUrl</tt>.
--   
--   Care must be taken to close the connection once you are done if using
--   <tt>openConnection</tt>, or unprocessed messages and callbacks will
--   continue to queue up.
data Connection
Connection :: Socket -> ConnectionQueue -> ConnectionWaiters -> Text -> IORef (Maybe ConnClosing) -> MVar () -> Connection

-- | JSRef to JS Websocket object
_connSocket :: Connection -> Socket

-- | JSRef to JSArray of queued incoming messages, managed directly in FFI
_connQueue :: Connection -> ConnectionQueue

-- | JSRef to JSArray of queue of waiting receivers, managed directly in
--   FFI
_connWaiters :: Connection -> ConnectionWaiters

-- | Text of server socket was originally opened with
_connOrigin :: Connection -> Text

-- | IORef with Nothing if the connection is still open and <tt>Just
--   reason</tt> if it's closed, with the reason
_connClosed :: Connection -> IORef (Maybe ConnClosing)

-- | Mutex for thread-safe manipulation
_connBlock :: Connection -> MVar ()

-- | Sum type over the data that can be sent or received through a
--   JavaScript websocket.
--   
--   What an incoming message is classified as depends on the Javascript
--   Websockets API <a>http://www.w3.org/TR/websockets/</a>, which provides
--   a "typed" input channel of either text or binary blob.
--   
--   There are several convenience functions to help you never have to deal
--   with this explicitly; its main purpose is if you want to explicitly
--   branch on a <tt>receiveMessage</tt> depending on what kind of message
--   you receive and do separate things. <tt>receiveText</tt> and
--   <tt>receiveData</tt> will both allow you to "filter" incoming messages
--   by their type.
data SocketMsg
SocketMsgText :: Text -> SocketMsg
SocketMsgData :: ByteString -> SocketMsg

-- | Data type containing information on <a>Connection</a> closes.
--   
--   <ul>
--   <li><a>ManualClose</a>: Closed by the Haskell <a>WebSockets</a>
--   interface, using <a>closeConnection</a> or variants.</li>
--   <li><a>JSClose</a>: Closed on the Javascript end, either by a
--   connection error or server request, or what have you. Contains
--   information from the Javascript Websockets API
--   <a>http://www.w3.org/TR/websockets/#event-definitions</a>.The first
--   field is whether or not it was a clean close; the second field is the
--   closing reason code; the third field is a <a>Text</a> with the reason
--   given by the Websockets API.</li>
--   <li><tt>OpenInterupptedClose</tt>: There was an unexpected error
--   encountered when attempting to open the connection.</li>
--   <li><a>UnexpectedClose</a>: Otherwise uncategorized closed status,
--   with a <a>Text</a> field offering a reason.</li>
--   </ul>
data ConnClosing
ManualClose :: ConnClosing
JSClose :: (Maybe Bool) -> (Maybe Int) -> (Maybe Text) -> ConnClosing
OpenInterruptedClose :: ConnClosing
UnexpectedClose :: Text -> ConnClosing
type Socket = JSRef Socket_

-- | A typeclass offering a gratuitous abstraction over what can be sent
--   through a <a>Connection</a>. Allows you to wrap things in a
--   <a>SocketMsg</a> automatically. The only instances that should really
--   ever exist are <a>Text</a> and instances of <a>Binary</a>.
class WSSendable s
wrapSendable :: WSSendable s => s -> SocketMsg

-- | A typeclass offering a gratuitous abstraction over what can be
--   received through a <a>Connection</a>. Allows you to unwrap things in a
--   <a>SocketMsg</a> automatically. The only instances that should really
--   ever exist are <a>Text</a> and instances of <a>Binary</a>.
class WSReceivable s
unwrapReceivable :: WSReceivable s => SocketMsg -> Either SocketMsg s

-- | An exception that may be thrown when using the various
--   <a>Connection</a> operations. Right now, only includes
--   <a>ConnectionClosed</a>, which is thrown when using an "unsafe"
--   <tt>receive</tt> on a closed <a>Connection</a>, or if a
--   <a>Connection</a> closes while an unsafe <tt>receive</tt> is waiting.
data ConnectionException
ConnectionClosed :: Text -> ConnectionException
_socketOrigin :: ConnectionException -> Text

-- | A version of <tt>openConnection</tt> that doesn't wait for the
--   connection to be opened. Returns an <a>MVar</a> where the connection
--   can be expected to be placed when it is opened.
openConnectionImmediate :: Text -> IO (MVar Connection)

-- | Manually closes the given <a>Connection</a>. Will un-block all threads
--   currently waiting on the <a>Connection</a> for messages (releasing
--   their callbacks) and disable sending and receiving in the future.
--   
--   All leftover messages that were never processed on the Haskell end
--   will be deleted; use <a>dumpConnectionQueue</a> to manually fetch them
--   before closing, or <a>closeConnectionLeftovers</a> to recover them
--   while closing.
closeConnection :: Connection -> IO ()

-- | Manually closes the given <a>Connection</a>. It un-blocks all threads
--   currently waiting on the connection and disables all sending and
--   receiving in the future.
--   
--   The result is a list of all messages received by the connection but
--   not yet retrieved by <tt>receive</tt>, etc. on the Haskell end.
--   
--   To close and ignore leftovers, use <a>closeConnection</a>.
closeConnectionLeftovers :: Connection -> IO [SocketMsg]

-- | Clears the message queue (messages waiting to be <tt>receive</tt>d) on
--   the given <a>Connection</a>. Is essentially a no-op on closed
--   connections.
clearConnectionQueue :: Connection -> IO ()

-- | Returns all incoming messages received by the socket and queued for
--   retrieval using <tt>receive</tt> functions. Empties the queue.
dumpConnectionQueue :: Connection -> IO [SocketMsg]

-- | Check if the given <a>Connection</a> is closed. Returns a <a>Bool</a>.
--   To check *why* it was closed, see <a>connectionCloseReason</a>.
connectionClosed :: Connection -> IO Bool

-- | Returns <tt>Nothing</tt> if the given <a>Connection</a> is still open,
--   or <tt>Just closing</tt> containing a <a>ConnClosing</a> with
--   information on why the connection was closed.
--   
--   For just a <a>Bool</a> saying whether or not the connection is closed,
--   try <a>connectionClosed</a>.
connectionCloseReason :: Connection -> IO (Maybe ConnClosing)

-- | Returns the "readyState" of the connection's javascript websockets
--   API: 0 is connecting, 1 is open, 2 is closing, and 3 is closed.
--   Shouldn't really be used except for debugging purposes. Use
--   <a>connectionCloseReason</a> whenever possible to get information in a
--   nice haskelley sum type.
connectionStateCode :: Connection -> IO Int

-- | Sends the given <a>SocketMsg</a> through the given <a>Connection</a>.
--   A <a>SocketMsg</a> is a sum type of either 'SocketMsgText t',
--   containing (strict) <a>Text</a>, or 'SocketMsgData d', containing a
--   (lazy) <a>ByteString</a>.
--   
--   Returns <a>True</a> if the connection is open, and <a>False</a> if it
--   is closed. In the future will return more feedback about whether or
--   not the send was completed succesfully.
sendMessage :: Connection -> SocketMsg -> IO Bool

-- | Block and wait until the <a>Connection</a> receives any message, and
--   returns the message wrapped in a <a>SocketMsg</a>. A <a>SocketMsg</a>
--   is a sum type of either 'SocketMsgText t', containing (strict)
--   <a>Text</a>, or 'SocketMsgData d', containing a (lazy)
--   <a>ByteString</a>.
--   
--   Will return 'Just msg' as soon as any message is received, or
--   <a>Nothing</a> if the <a>Connection</a> closes first. Returns
--   <a>Nothing</a> immediately if the <a>Connection</a> is already closed.
receiveMessageMaybe :: Connection -> IO (Maybe SocketMsg)

-- | Execute process with the connection mutex lock in effect. Will wait
--   until the lock is released before starting, if lock was already in
--   place.
--   
--   Will break almost every <a>Connection</a> function if you run one
--   while this is in effect, because almost all of them require the lock
--   to begin.
withConnBlock :: Connection -> IO a -> IO a

-- | Execute process with the connection mutex lock in effect, with
--   asynchronos exceptions masked (See <a>Control.Exception</a>). Will
--   wait until the lock is released before starting, if lock was already
--   in place.
--   
--   Will break almost every <a>Connection</a> function if you run one
--   while this is in effect, because almost all of them require the lock
--   to begin.
withConnBlockMasked :: Connection -> IO a -> IO a
instance [incoherent] Typeable SocketMsg
instance [incoherent] Typeable ConnectionException
instance [incoherent] Show SocketMsg
instance [incoherent] Eq SocketMsg
instance [incoherent] Show ConnClosing
instance [incoherent] Eq ConnClosing
instance [incoherent] Eq ConnectionException
instance [incoherent] Binary a => WSReceivable a
instance [incoherent] WSReceivable Text
instance [incoherent] Binary a => WSSendable a
instance [incoherent] WSSendable Text
instance [incoherent] Exception ConnectionException
instance [incoherent] Show ConnectionException


-- | Contains functions and operations for working with Javascript
--   Websocket connections, which are encapsulated in the <a>Connection</a>
--   object.
--   
--   It includes operations for opening, closing, inspecting connections
--   and operations for sending and receiving text and serializable data
--   (instances of <a>Binary</a>) through them.
--   
--   Most of the necessary functionality is in hopefully in
--   <a>JavaScript.WebSockets</a>; more of the low-level API is exposed in
--   <a>JavaScript.WebSockets.Internal</a> if you need it for library
--   construction.
module JavaScript.WebSockets

-- | Encapsulates a (reference to a) Javascript Websocket connection. Can
--   be created/accessed with either <tt>openConnection</tt> or
--   (preferably) <tt>withUrl</tt>.
--   
--   Care must be taken to close the connection once you are done if using
--   <tt>openConnection</tt>, or unprocessed messages and callbacks will
--   continue to queue up.
data Connection

-- | A typeclass offering a gratuitous abstraction over what can be sent
--   through a <a>Connection</a>. Allows you to wrap things in a
--   <a>SocketMsg</a> automatically. The only instances that should really
--   ever exist are <a>Text</a> and instances of <a>Binary</a>.
class WSSendable s

-- | A typeclass offering a gratuitous abstraction over what can be
--   received through a <a>Connection</a>. Allows you to unwrap things in a
--   <a>SocketMsg</a> automatically. The only instances that should really
--   ever exist are <a>Text</a> and instances of <a>Binary</a>.
class WSReceivable s

-- | Sum type over the data that can be sent or received through a
--   JavaScript websocket.
--   
--   What an incoming message is classified as depends on the Javascript
--   Websockets API <a>http://www.w3.org/TR/websockets/</a>, which provides
--   a "typed" input channel of either text or binary blob.
--   
--   There are several convenience functions to help you never have to deal
--   with this explicitly; its main purpose is if you want to explicitly
--   branch on a <tt>receiveMessage</tt> depending on what kind of message
--   you receive and do separate things. <tt>receiveText</tt> and
--   <tt>receiveData</tt> will both allow you to "filter" incoming messages
--   by their type.
data SocketMsg
SocketMsgText :: Text -> SocketMsg
SocketMsgData :: ByteString -> SocketMsg

-- | Data type containing information on <a>Connection</a> closes.
--   
--   <ul>
--   <li><a>ManualClose</a>: Closed by the Haskell <a>WebSockets</a>
--   interface, using <a>closeConnection</a> or variants.</li>
--   <li><a>JSClose</a>: Closed on the Javascript end, either by a
--   connection error or server request, or what have you. Contains
--   information from the Javascript Websockets API
--   <a>http://www.w3.org/TR/websockets/#event-definitions</a>.The first
--   field is whether or not it was a clean close; the second field is the
--   closing reason code; the third field is a <a>Text</a> with the reason
--   given by the Websockets API.</li>
--   <li><tt>OpenInterupptedClose</tt>: There was an unexpected error
--   encountered when attempting to open the connection.</li>
--   <li><a>UnexpectedClose</a>: Otherwise uncategorized closed status,
--   with a <a>Text</a> field offering a reason.</li>
--   </ul>
data ConnClosing
ManualClose :: ConnClosing
JSClose :: (Maybe Bool) -> (Maybe Int) -> (Maybe Text) -> ConnClosing
OpenInterruptedClose :: ConnClosing
UnexpectedClose :: Text -> ConnClosing

-- | An exception that may be thrown when using the various
--   <a>Connection</a> operations. Right now, only includes
--   <a>ConnectionClosed</a>, which is thrown when using an "unsafe"
--   <tt>receive</tt> on a closed <a>Connection</a>, or if a
--   <a>Connection</a> closes while an unsafe <tt>receive</tt> is waiting.
data ConnectionException
ConnectionClosed :: Text -> ConnectionException
_socketOrigin :: ConnectionException -> Text

-- | Performs the given <tt>Connection -&gt; IO a</tt> process attached to
--   the given server url. Handles opening and closing the
--   <a>Connection</a> for you (and clearing the message queue afterwards),
--   and cleans up on errors.
--   
--   If any messages were received by the socket but never
--   processed/received on the Haskell end, this will delete and drop them.
--   Use <a>withUrlLeftovers</a> to get a hold of them.
withUrl :: Text -> (Connection -> IO a) -> IO a

-- | Like <a>withUrl</a>, except returns also the "leftover messages" that
--   were received by the socket but never processed on the Haskell end
--   with <a>receive</a>.
withUrlLeftovers :: Text -> (Connection -> IO a) -> IO (a, [SocketMsg])

-- | Opens a websocket connection to the given url, and returns the
--   <a>Connection</a> after connection is completed and opened. Care
--   should be taken to ensure that the <a>Connection</a> is later closed
--   with <a>closeConnection</a>.
--   
--   Consider using <a>withUrl</a>, which handles closing with bracketing
--   and error handling so you don't have to worry about closing the
--   connection yourself.
--   
--   Blocks until the connection has been established and opened.
--   
--   If an async exception happens while this is waiting, the socket will
--   be closed as the exception bubbles up.
openConnection :: Text -> IO Connection

-- | Manually closes the given <a>Connection</a>. Will un-block all threads
--   currently waiting on the <a>Connection</a> for messages (releasing
--   their callbacks) and disable sending and receiving in the future.
--   
--   All leftover messages that were never processed on the Haskell end
--   will be deleted; use <a>dumpConnectionQueue</a> to manually fetch them
--   before closing, or <a>closeConnectionLeftovers</a> to recover them
--   while closing.
closeConnection :: Connection -> IO ()

-- | Manually closes the given <a>Connection</a>. It un-blocks all threads
--   currently waiting on the connection and disables all sending and
--   receiving in the future.
--   
--   The result is a list of all messages received by the connection but
--   not yet retrieved by <tt>receive</tt>, etc. on the Haskell end.
--   
--   To close and ignore leftovers, use <a>closeConnection</a>.
closeConnectionLeftovers :: Connection -> IO [SocketMsg]

-- | Clears the message queue (messages waiting to be <tt>receive</tt>d) on
--   the given <a>Connection</a>. Is essentially a no-op on closed
--   connections.
clearConnectionQueue :: Connection -> IO ()

-- | Returns all incoming messages received by the socket and queued for
--   retrieval using <tt>receive</tt> functions. Empties the queue.
dumpConnectionQueue :: Connection -> IO [SocketMsg]

-- | Check if the given <a>Connection</a> is closed. Returns a <a>Bool</a>.
--   To check *why* it was closed, see <a>connectionCloseReason</a>.
connectionClosed :: Connection -> IO Bool

-- | Returns <tt>Nothing</tt> if the given <a>Connection</a> is still open,
--   or <tt>Just closing</tt> containing a <a>ConnClosing</a> with
--   information on why the connection was closed.
--   
--   For just a <a>Bool</a> saying whether or not the connection is closed,
--   try <a>connectionClosed</a>.
connectionCloseReason :: Connection -> IO (Maybe ConnClosing)

-- | Returns the origin url of the given <a>Connection</a>.
connectionOrigin :: Connection -> Text

-- | Send the given serializable (instance of <a>Binary</a>) data on the
--   given connection.
--   
--   Returns <a>True</a> if the connection is open, and <a>False</a> if it
--   is closed. In the future will return more feedback about whether or
--   not the send was completed succesfully.
sendData :: Binary a => Connection -> a -> IO Bool

-- | Send the given serializable (instance of <a>Binary</a>) data on the
--   given connection.
--   
--   Fails silently if the connection is closed or otherwise was not
--   succesful. Use <a>sendData</a> to get feedback on the result of the
--   send.
sendData_ :: Binary a => Connection -> a -> IO ()

-- | Send the given (strict) <a>Text</a> on the given connection.
--   
--   Returns <a>True</a> if the connection is open, and <a>False</a> if it
--   is closed. In the future will return more feedback about whether or
--   not the send was completed succesfully.
sendText :: Connection -> Text -> IO Bool

-- | Send the given (strict) <a>Text</a> on the given connection.
--   
--   Fails silently if the connection is closed or otherwise was not
--   succesful. Use <a>sendText</a> to get feedback on the result of the
--   send.
sendText_ :: Connection -> Text -> IO ()

-- | Sends the given <a>SocketMsg</a> through the given <a>Connection</a>.
--   A <a>SocketMsg</a> is a sum type of either 'SocketMsgText t',
--   containing (strict) <a>Text</a>, or 'SocketMsgData d', containing a
--   (lazy) <a>ByteString</a>.
--   
--   Returns <a>True</a> if the connection is open, and <a>False</a> if it
--   is closed. In the future will return more feedback about whether or
--   not the send was completed succesfully.
sendMessage :: Connection -> SocketMsg -> IO Bool

-- | Sends the given <a>SocketMsg</a> through the given <a>Connection</a>.
--   A <a>SocketMsg</a> is a sum type of either 'SocketMsgText t',
--   containing (strict) <a>Text</a>, or 'SocketMsgData d', containing a
--   (lazy) <tt>ByteString</tt>.
--   
--   Fails silently if the connection is closed or otherwise was not
--   succesful. Use <a>sendMessage</a> to get feedback on the result of the
--   send.
sendMessage_ :: Connection -> SocketMsg -> IO ()

-- | Send the given item through the given <a>Connection</a>.
--   
--   You can <a>send</a> either (strict) <a>Text</a> or any instance of
--   <a>Binary</a>, due to over-indulgent typeclass magic; this is
--   basically a function that works everywhere you would use
--   <a>sendText</a> or <a>sendData</a>.
--   
--   Returns <a>True</a> if the connection is open, and <a>False</a> if it
--   is closed. In the future will return more feedback about whether or
--   not the send was completed succesfully.
send :: WSSendable a => Connection -> a -> IO Bool

-- | Send the given item through the given <a>Connection</a>.
--   
--   You can <a>send_</a> either (strict) <a>Text</a> or any instance of
--   <a>Binary</a>, due to over-indulgent typeclass magic; this is
--   basically a function that works everywhere you would use
--   <a>sendText_</a> or <a>sendData_</a>.
--   
--   Fails silently if the connection is closed or otherwise was not
--   succesful. Use <a>send</a> to get feedback on the result of the send.
send_ :: WSSendable a => Connection -> a -> IO ()

-- | Block and wait until either something decodable as the desired type is
--   received (returning it), or the <a>Connection</a> closes (throwing a
--   <a>ConnectionException</a>). Throws the exception immediately if the
--   <a>Connection</a> is already closed and there are no queued messages
--   left.
--   
--   This is polymorphic on its return type, so remember to let the type
--   inference system know what you want at some point or just give an
--   explicit type signature --- <tt>receiveData conn :: IO (Maybe
--   Int)</tt>, for example.
--   
--   All non-decodable or non-matching data that comes along is discarded.
--   
--   You can <a>receive</a> either (strict) <a>Text</a> or any instance of
--   <a>Binary</a>, due to over-indulgent typeclass magic; this is
--   basically a function that works everywhere you would use
--   <a>receiveText</a> or <a>receiveData</a>.
--   
--   To handle closed sockets with <a>Maybe</a>, use <a>receiveMaybe</a>.
receive :: WSReceivable a => Connection -> IO a

-- | Block and wait until either something decodable as the desired type is
--   received (returning <tt>Just x</tt>), or the <a>Connection</a> closes
--   (returning <tt>Nothing</tt>). Returns <tt>Nothing</tt> immediately if
--   the <a>Connection</a> is already closed and there are no queued
--   messages left.
--   
--   This is polymorphic on its return type, so remember to let the type
--   inference system know what you want at some point or just give an
--   explicit type signature --- <tt>receiveData conn :: IO (Maybe
--   Int)</tt>, for example.
--   
--   All non-decodable or non-matching data that comes along is discarded.
--   
--   You can <a>receive</a> either (strict) <a>Text</a> or any instance of
--   <a>Binary</a>, due to over-indulgent typeclass magic; this is
--   basically a function that works everywhere you would use
--   <a>receiveText</a> or <a>receiveData</a>.
receiveMaybe :: WSReceivable a => Connection -> IO (Maybe a)

-- | Block and wait until the <a>Connection</a> receives a "typed"
--   <a>Text</a>. This is determined by Javascript's own "typed" Websockets
--   API <a>http://www.w3.org/TR/websockets/</a>, which receives data typed
--   either as text or as a binary blob. Returns the first encountered
--   text. Throws a <a>ConnectionException</a> if the <a>Connection</a>
--   closes first, and throws one immediately if the connection is already
--   closed and there are no queued messages left.
--   
--   All "binary blobs" encountered are discarded.
--   
--   To handle closed sockets with <a>Maybe</a>, use
--   <a>receiveTextMaybe</a>.
receiveText :: Connection -> IO Text

-- | Block and wait until the <a>Connection</a> receives a "typed"
--   <a>Text</a>. This is determined by Javascript's own "typed" Websockets
--   API <a>http://www.w3.org/TR/websockets/</a>, which receives data typed
--   either as text or as a binary blob. Returns <tt>Just t</tt> on the
--   first encountered text. Returns <tt>Nothing</tt> if the
--   <a>Connection</a> closes while it is waiting, or immediately if the
--   connection is already closed and there are no queued messages left.
--   
--   All "binary blobs" encountered are discarded.
receiveTextMaybe :: Connection -> IO (Maybe Text)

-- | Block and wait until the <a>Connection</a> receives a "binary blob"
--   decodable as the desired instance of <a>Binary</a>. Returns the first
--   succesfully decoded data, and throws a <a>ConnectionException</a> if
--   the <a>Connection</a> closes first. Throws the exception immediately
--   if the <a>Connection</a> is already closed and there are no queued
--   messages left.
--   
--   This is polymorphic on its return type, so remember to let the type
--   inference system know what you want at some point or just give an
--   explicit type signature --- <tt>receiveData conn :: IO (Maybe
--   Int)</tt>, for example.
--   
--   All incoming messages received that cannot be decoded as the data type
--   (or are text) will be discarded.
--   
--   To handle closed sockets with <a>Maybe</a>, use
--   <a>receiveDataMaybe</a>.
receiveData :: Binary a => Connection -> IO a

-- | Block and wait until the <a>Connection</a> receives a "binary blob"
--   decodable as the desired instance of <a>Binary</a>. Returns <tt>Just
--   x</tt> as soon as it is able to decode a blob, and <tt>Nothing</tt> if
--   the <a>Connection</a> closes while it is waiting. Returns
--   <tt>Nothing</tt> immediately if the <a>Connection</a> is already
--   closed and there are no queued messages left.
--   
--   All incoming messages received that cannot be decoded as the data type
--   (or are text) will be discarded.
--   
--   This is polymorphic on its return type, so remember to let the type
--   inference system know what you want at some point or just give an
--   explicit type signature --- <tt>receiveData conn :: IO (Maybe
--   Int)</tt>, for example.
receiveDataMaybe :: Binary a => Connection -> IO (Maybe a)

-- | Block and wait until the <a>Connection</a> receives any message, and
--   returns the message wrapped in a <a>SocketMsg</a>. A <a>SocketMsg</a>
--   is a sum type of either 'SocketMsgText t', containing (strict)
--   <a>Text</a>, or 'SocketMsgData d', containing a (lazy)
--   <tt>ByteString</tt>.
--   
--   Will return the message as soon as any is received, or throw a
--   <a>ConnectionException</a> if the connection is closed while waiting.
--   Throws an exception immediately if the connection is already closed.
--   
--   To handle closed sockets with <a>Maybe</a>, use
--   <a>receiveMessageMaybe</a>.
receiveMessage :: Connection -> IO SocketMsg

-- | Block and wait until the <a>Connection</a> receives any message, and
--   returns the message wrapped in a <a>SocketMsg</a>. A <a>SocketMsg</a>
--   is a sum type of either 'SocketMsgText t', containing (strict)
--   <a>Text</a>, or 'SocketMsgData d', containing a (lazy)
--   <a>ByteString</a>.
--   
--   Will return 'Just msg' as soon as any message is received, or
--   <a>Nothing</a> if the <a>Connection</a> closes first. Returns
--   <a>Nothing</a> immediately if the <a>Connection</a> is already closed.
receiveMessageMaybe :: Connection -> IO (Maybe SocketMsg)

-- | Block and wait until the <a>Connection</a> receives any message, and
--   attempts to decode it depending on the desired type. If <a>Text</a> is
--   requested, assumes Utf8-encoded text or just a plain Javascript
--   string. If an instance of <a>Binary</a> is requested, attempts to
--   decode it into that instance. Successful parses return 'Right x', and
--   failed parses return 'Left SocketMsg' (A sum type between
--   <a>SocketMsgText</a> containing (strict) <a>Text</a> and
--   <a>SocketMsgData</a> containing a (lazy) <tt>ByteString</tt>). Nothing
--   is ever discarded.
--   
--   Will return the message as soon as any is received, or throw a
--   <a>ConnectionException</a> if the connection is closed while waiting.
--   Throws an exception immediately if the connection is already closed
--   and there are no queued messages left.
--   
--   To handle closed sockets with <a>Maybe</a>, use
--   <a>receiveEitherMaybe</a>.
receiveEither :: WSReceivable a => Connection -> IO (Either SocketMsg a)

-- | Block and wait until the <a>Connection</a> receives any message, and
--   attempts to decode it depending on the desired type. If <a>Text</a> is
--   requested, assumes Utf8-encoded text or just a plain Javascript
--   string. If an instance of <a>Binary</a> is requested, attempts to
--   decode it into that instance. Successful parses return 'Right x', and
--   failed parses return 'Left SocketMsg' (A sum type between
--   <a>SocketMsgText</a> containing (strict) <a>Text</a> and
--   <a>SocketMsgData</a> containing a (lazy) <tt>ByteString</tt>). Nothing
--   is ever discarded.
--   
--   Returns <tt>Just result</tt> on the first message received, or
--   <tt>Nothing</tt> if the <a>Connection</a> closes while waiting.
--   Returns <tt>Nothing</tt> if the connection is already closed and there
--   are no queued messages left.
receiveEitherMaybe :: WSReceivable a => Connection -> IO (Maybe (Either SocketMsg a))
