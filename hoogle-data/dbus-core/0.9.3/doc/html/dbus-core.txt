-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Low-level D-Bus protocol implementation
--   
--   OBSOLETE: Use the "dbus" package instead.
--   
--   <a>http://hackage.haskell.org/package/dbus</a>
@package dbus-core
@version 0.9.3

module DBus.Types
data Type
TypeBoolean :: Type
TypeWord8 :: Type
TypeWord16 :: Type
TypeWord32 :: Type
TypeWord64 :: Type
TypeInt16 :: Type
TypeInt32 :: Type
TypeInt64 :: Type
TypeDouble :: Type
TypeString :: Type
TypeSignature :: Type
TypeObjectPath :: Type
TypeVariant :: Type
TypeArray :: Type -> Type
TypeDictionary :: Type -> Type -> Type
TypeStructure :: [Type] -> Type
data Signature
signature :: Text -> Maybe Signature
signature_ :: Text -> Signature
signatureText :: Signature -> Text
signatureTypes :: Signature -> [Type]
class IsVariant a => IsValue a
class IsValue a => IsAtom a
typeOf :: IsValue a => a -> Type

-- | <a>Variant</a>s may contain any other built‐in D‐Bus value. Besides
--   representing native <tt>VARIANT</tt> values, they allow type‐safe
--   storage and deconstruction of heterogeneous collections.
data Variant
class IsVariant a
toVariant :: IsVariant a => a -> Variant
fromVariant :: IsVariant a => Variant -> Maybe a

-- | Every variant is strongly‐typed; that is, the type of its contained
--   value is known at all times. This function retrieves that type, so
--   that the correct cast can be used to retrieve the value.
variantType :: Variant -> Type
data ObjectPath
objectPath :: Text -> Maybe ObjectPath
objectPath_ :: Text -> ObjectPath
objectPathText :: ObjectPath -> Text
data InterfaceName
interfaceName :: Text -> Maybe InterfaceName
interfaceName_ :: Text -> InterfaceName
interfaceNameText :: InterfaceName -> Text
data MemberName
memberName :: Text -> Maybe MemberName
memberName_ :: Text -> MemberName
memberNameText :: MemberName -> Text
data ErrorName
errorName :: Text -> Maybe ErrorName
errorName_ :: Text -> ErrorName
errorNameText :: ErrorName -> Text
data BusName
busName :: Text -> Maybe BusName
busName_ :: Text -> BusName
busNameText :: BusName -> Text
data Structure
data Array
data Dictionary
structureItems :: Structure -> [Variant]
arrayItems :: Array -> [Variant]
dictionaryItems :: Dictionary -> [(Variant, Variant)]

module DBus.Constants
dbusName :: BusName
dbusPath :: ObjectPath
dbusInterface :: InterfaceName
interfaceIntrospectable :: InterfaceName
interfacePeer :: InterfaceName
interfaceProperties :: InterfaceName
errorAccessDenied :: ErrorName
errorAuthFailed :: ErrorName
errorDisconnected :: ErrorName
errorFailed :: ErrorName
errorNoReply :: ErrorName
errorNoServer :: ErrorName
errorTimedOut :: ErrorName
errorTimeout :: ErrorName
errorServiceUnknown :: ErrorName
errorUnknownObject :: ErrorName
errorUnknownInterface :: ErrorName
errorUnknownMethod :: ErrorName
errorInvalidParameters :: ErrorName
errorSpawnChildExited :: ErrorName
errorSpawnChildSignaled :: ErrorName
errorSpawnConfigInvalid :: ErrorName
errorSpawnExecFailed :: ErrorName
errorSpawnForkFailed :: ErrorName
errorSpawnFailed :: ErrorName
errorSpawnFailedToSetup :: ErrorName
errorSpawnFileInvalid :: ErrorName
errorSpawnNoMemory :: ErrorName
errorSpawnPermissionsInvalid :: ErrorName
errorSpawnServiceNotFound :: ErrorName
errorSpawnServiceNotValid :: ErrorName
errorAddressInUse :: ErrorName
errorAdtAuditDataUnknown :: ErrorName
errorBadAddress :: ErrorName
errorFileExists :: ErrorName
errorFileNotFound :: ErrorName
errorInconsistentMessage :: ErrorName
errorInvalidFileContent :: ErrorName
errorIOError :: ErrorName
errorLimitsExceeded :: ErrorName
errorMatchRuleInvalid :: ErrorName
errorMatchRuleNotFound :: ErrorName
errorNameHasNoOwner :: ErrorName
errorNoMemory :: ErrorName
errorNoNetwork :: ErrorName
errorNotSupported :: ErrorName
errorObjectPathInUse :: ErrorName
errorSELinuxSecurityContextUnknown :: ErrorName
errorUnixProcessIdUnknown :: ErrorName

module DBus.Introspection
data Object
Object :: ObjectPath -> [Interface] -> [Object] -> Object
data Interface
Interface :: InterfaceName -> [Method] -> [Signal] -> [Property] -> Interface
data Method
Method :: MemberName -> [Parameter] -> [Parameter] -> Method
data Signal
Signal :: MemberName -> [Parameter] -> Signal
data Parameter
Parameter :: Text -> Signature -> Parameter
data Property
Property :: Text -> Signature -> [PropertyAccess] -> Property
data PropertyAccess
Read :: PropertyAccess
Write :: PropertyAccess
toXML :: Object -> Maybe Text
fromXML :: ObjectPath -> Text -> Maybe Object
instance Show Parameter
instance Eq Parameter
instance Show Signal
instance Eq Signal
instance Show Method
instance Eq Method
instance Show PropertyAccess
instance Eq PropertyAccess
instance Show Property
instance Eq Property
instance Show Interface
instance Eq Interface
instance Show Object
instance Eq Object
instance Monad XmlWriter

module DBus.Message
class Message a
messageFlags :: Message a => a -> Set Flag
messageBody :: Message a => a -> [Variant]
data Flag
NoReplyExpected :: Flag
NoAutoStart :: Flag

-- | A value used to uniquely identify a particular message within a
--   session. <a>Serial</a>s are 32‐bit unsigned integers, and eventually
--   wrap.
data Serial
serialValue :: Serial -> Word32
data Unknown
Unknown :: Word8 -> Set Flag -> [Variant] -> Unknown
unknownType :: Unknown -> Word8
unknownFlags :: Unknown -> Set Flag
unknownBody :: Unknown -> [Variant]
data MethodCall
MethodCall :: ObjectPath -> MemberName -> Maybe InterfaceName -> Maybe BusName -> Set Flag -> [Variant] -> MethodCall
methodCallPath :: MethodCall -> ObjectPath
methodCallMember :: MethodCall -> MemberName
methodCallInterface :: MethodCall -> Maybe InterfaceName
methodCallDestination :: MethodCall -> Maybe BusName
methodCallFlags :: MethodCall -> Set Flag
methodCallBody :: MethodCall -> [Variant]
data MethodReturn
MethodReturn :: Serial -> Maybe BusName -> [Variant] -> MethodReturn
methodReturnSerial :: MethodReturn -> Serial
methodReturnDestination :: MethodReturn -> Maybe BusName
methodReturnBody :: MethodReturn -> [Variant]
data Error
Error :: ErrorName -> Serial -> Maybe BusName -> [Variant] -> Error
errorName :: Error -> ErrorName
errorSerial :: Error -> Serial
errorDestination :: Error -> Maybe BusName
errorBody :: Error -> [Variant]
errorMessage :: Error -> Text
data Signal
Signal :: Maybe BusName -> ObjectPath -> InterfaceName -> MemberName -> [Variant] -> Signal
signalDestination :: Signal -> Maybe BusName
signalPath :: Signal -> ObjectPath
signalInterface :: Signal -> InterfaceName
signalMember :: Signal -> MemberName
signalBody :: Signal -> [Variant]

-- | Not an actual message type, but a wrapper around messages received
--   from the bus. Each value contains the message’s <a>Serial</a> and
--   possibly the origin’s <a>BusName</a>
data ReceivedMessage
ReceivedMethodCall :: Serial -> (Maybe BusName) -> MethodCall -> ReceivedMessage
ReceivedMethodReturn :: Serial -> (Maybe BusName) -> MethodReturn -> ReceivedMessage
ReceivedError :: Serial -> (Maybe BusName) -> Error -> ReceivedMessage
ReceivedSignal :: Serial -> (Maybe BusName) -> Signal -> ReceivedMessage
ReceivedUnknown :: Serial -> (Maybe BusName) -> Unknown -> ReceivedMessage
receivedSerial :: ReceivedMessage -> Serial
receivedSender :: ReceivedMessage -> Maybe BusName
receivedBody :: ReceivedMessage -> [Variant]

module DBus.Wire
data Endianness
LittleEndian :: Endianness
BigEndian :: Endianness
data MarshalError
data UnmarshalError

-- | Convert a <a>Message</a> into a <a>ByteString</a>. Although unusual,
--   it is possible for marshaling to fail; if this occurs, an error will
--   be returned instead.
marshalMessage :: Message a => Endianness -> Serial -> a -> Either MarshalError ByteString

-- | Parse a <a>ByteString</a> into a <a>ReceivedMessage</a>. The result
--   can be inspected to see what type of message was parsed. Unknown
--   message types can still be parsed successfully, as long as they
--   otherwise conform to the D‐Bus standard.
unmarshalMessage :: ByteString -> Either UnmarshalError ReceivedMessage

module DBus.Address
data Address
addressMethod :: Address -> Text
addressParameters :: Address -> Map Text Text
address :: Text -> Maybe Address
addresses :: Text -> Maybe [Address]
addressText :: Address -> Text
getSystem :: IO (Maybe [Address])
getSession :: IO (Maybe [Address])
getStarter :: IO (Maybe [Address])
instance Eq Address
instance Show Address

module DBus.Connection

-- | A <a>Connection</a> is an opaque handle to an open D‐Bus channel, with
--   an internal state for maintaining the current message serial.
data Connection
data ConnectionError

-- | Open a connection to some address, using a given authentication
--   mechanism. If the connection fails, a <a>ConnectionError</a> will be
--   thrown.
connect :: [Transport] -> [Mechanism] -> Address -> IO Connection

-- | Close an open connection. Once closed, the <a>Connection</a> is no
--   longer valid and must not be used.
disconnect :: Connection -> IO ()

-- | Send a single message, with a generated <a>Serial</a>. The second
--   parameter exists to prevent race conditions when registering a reply
--   handler; it receives the serial the message <i>will</i> be sent with,
--   before it’s actually sent.
--   
--   Only one message may be sent at a time; if multiple threads attempt to
--   send messages in parallel, one will block until after the other has
--   finished.
send :: Message msg => Connection -> msg -> (Serial -> IO a) -> IO (Either MarshalError a)

-- | Receive the next message from the connection, blocking until one is
--   available.
--   
--   Only one message may be received at a time; if multiple threads
--   attempt to receive messages in parallel, one will block until after
--   the other has finished.
receive :: Connection -> IO (Either UnmarshalError ReceivedMessage)
data Mechanism
mechanism :: (Socket -> IO Bool) -> Mechanism
external :: Mechanism

-- | A <a>Transport</a> is anything which can send and receive bytestrings,
--   typically via a socket.
data Transport
data Socket
transport :: Text -> (Address -> IO Socket) -> Transport
socket :: (ByteString -> IO ()) -> (Word32 -> IO ByteString) -> IO () -> Socket
socketPut :: Socket -> ByteString -> IO ()
socketGet :: Socket -> Word32 -> IO ByteString
unix :: Transport
tcp :: Transport
instance Show Connection

module DBus.Client
data Client
connect :: Address -> IO Client
attach :: Connection -> IO Client

-- | Stop a <a>Client</a>’s callback thread and close its underlying
--   socket.
disconnect :: Client -> IO ()
call :: Client -> MethodCall -> IO (Either Error MethodReturn)
call_ :: Client -> MethodCall -> IO MethodReturn
emit :: Client -> Signal -> IO ()
data MatchRule
MatchRule :: Maybe BusName -> Maybe BusName -> Maybe ObjectPath -> Maybe InterfaceName -> Maybe MemberName -> MatchRule
matchSender :: MatchRule -> Maybe BusName
matchDestination :: MatchRule -> Maybe BusName
matchPath :: MatchRule -> Maybe ObjectPath
matchInterface :: MatchRule -> Maybe InterfaceName
matchMember :: MatchRule -> Maybe MemberName
listen :: Client -> MatchRule -> (BusName -> Signal -> IO ()) -> IO ()
data Method
data Reply
ReplyReturn :: [Variant] -> Reply
ReplyError :: ErrorName -> [Variant] -> Reply

-- | Normally, any exceptions raised while executing a method will be given
--   the generic <tt>"org.freedesktop.DBus.Error.Failed"</tt> name.
--   <a>throwError</a> allows the programmer to specify an error name, and
--   provide additional information to the remote application. You may use
--   this instead of <a>throwIO</a> to abort a method call.
throwError :: ErrorName -> Text -> [Variant] -> IO a
method :: InterfaceName -> MemberName -> Signature -> Signature -> ([Variant] -> IO Reply) -> Method
export :: Client -> ObjectPath -> [Method] -> IO ()
setMessageProcessor :: Client -> (ReceivedMessage -> IO Bool) -> IO ()

module DBus.Client.Simple
data Client

-- | Connect to the bus specified in the environment variable
--   <tt>DBUS_SYSTEM_BUS_ADDRESS</tt>, or to
--   <tt>unix:path=/var/run/dbus/system_bus_socket</tt> if
--   <tt>DBUS_SYSTEM_BUS_ADDRESS</tt> is not set.
connectSystem :: IO Client

-- | Connect to the bus specified in the environment variable
--   <tt>DBUS_SESSION_BUS_ADDRESS</tt>, which must be set.
connectSession :: IO Client

-- | Connect to the bus specified in the environment variable
--   <tt>DBUS_STARTER_ADDRESS</tt>, which must be set.
connectStarter :: IO Client

-- | Stop a <a>Client</a>’s callback thread and close its underlying
--   socket.
disconnect :: Client -> IO ()
emit :: Client -> ObjectPath -> InterfaceName -> MemberName -> [Variant] -> IO ()
data Proxy
proxy :: Client -> BusName -> ObjectPath -> IO Proxy
call :: Proxy -> InterfaceName -> MemberName -> [Variant] -> IO [Variant]
listen :: Proxy -> InterfaceName -> MemberName -> (BusName -> Signal -> IO ()) -> IO ()
data RequestNameFlag
AllowReplacement :: RequestNameFlag
ReplaceExisting :: RequestNameFlag
DoNotQueue :: RequestNameFlag
data RequestNameReply
PrimaryOwner :: RequestNameReply
InQueue :: RequestNameReply
Exists :: RequestNameReply
AlreadyOwner :: RequestNameReply
data ReleaseNameReply
Released :: ReleaseNameReply
NonExistent :: ReleaseNameReply
NotOwner :: ReleaseNameReply
requestName :: Client -> BusName -> [RequestNameFlag] -> IO RequestNameReply
releaseName :: Client -> BusName -> IO ReleaseNameReply
data Method

-- | Used to automatically generate method signatures for introspection
--   documents. To support automatic signatures, a method#8217;s parameters
--   and return value must all be instances of <a>IsValue</a>.
--   
--   This class maps Haskell idioms to D‐Bus; it is therefore unable to
--   generate some signatures. In particular, it does not support methods
--   which accept/return a single structure, or single‐element structures.
--   It also cannot generate signatures for methods with parameters or
--   return values which are only instances of <a>IsVariant</a>. For these
--   cases, please use <a>method</a>.
--   
--   To match common Haskell use, if the return value is a tuple, it will
--   be converted to a list of return values.
class AutoSignature a

-- | Used to automatically generate a <a>Reply</a> from a return value. See
--   <a>AutoSignature</a> for some caveats about supported signatures.
--   
--   To match common Haskell use, if the return value is a tuple, it will
--   be converted to a list of return values.
class AutoReply fun

-- | Prepare a Haskell function for export. This automatically detects the
--   function#8217;s type signature; see <a>AutoSignature</a> and
--   <a>AutoReply</a>.
--   
--   To manage the type signature and marshaling yourself, use
--   <a>method</a> instead.
method :: (AutoSignature fun, AutoReply fun) => InterfaceName -> MemberName -> fun -> Method

-- | Export the given functions under the given <a>ObjectPath</a> and
--   <a>InterfaceName</a>. The functions may accept/return any types that
--   are instances of <a>IsValue</a>; see <a>AutoSignature</a>.
--   
--   <pre>
--   sayHello :: Text -&gt; IO Text
--   sayHello name = return (<a>concat</a> ["Hello ", name, "!"])
--   
--   export client "/hello_world"
--       [ <a>method</a> "com.example.HelloWorld" "Hello" sayHello
--       ]
--   </pre>
export :: Client -> ObjectPath -> [Method] -> IO ()

-- | Normally, any exceptions raised while executing a method will be given
--   the generic <tt>"org.freedesktop.DBus.Error.Failed"</tt> name.
--   <a>throwError</a> allows the programmer to specify an error name, and
--   provide additional information to the remote application. You may use
--   this instead of <a>throwIO</a> to abort a method call.
throwError :: ErrorName -> Text -> [Variant] -> IO a
instance [overlap ok] Show RequestNameFlag
instance [overlap ok] Show RequestNameReply
instance [overlap ok] Show ReleaseNameReply
instance [overlap ok] (IsVariant a, AutoReply fun) => AutoReply (a -> fun)
instance [overlap ok] IsVariant a => AutoReply (IO a)
instance [overlap ok] AutoReply (IO ())
instance [overlap ok] (IsValue a, AutoSignature fun) => AutoSignature (a -> fun)
instance [overlap ok] IsValue a => AutoSignature (IO a)
instance [overlap ok] AutoSignature (IO ())
