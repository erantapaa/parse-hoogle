-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Integer sets with a constant time translate operation.
--   
--   This package implements integer sets with a constant time translate
--   operation, defined as <tt>translate x s = map (+x) s</tt>. It is based
--   on Finger-Trees storing differences of consecutive entries of the
--   ordered sequence of set elements.
@package translatable-intset
@version 0.1


-- | An implementation of integer sets with a constant time
--   <a>translate</a> operation, where <a>translate</a> is defined to be
--   <tt><a>translate</a> x s = <a>map</a> (+x) s</tt>.
--   
--   Since many function names (but not the type name) clash with
--   <a>Prelude</a> names, this module is usually imported
--   <tt>qualified</tt>, e.g.
--   
--   <pre>
--   import Data.IntSet.Translatable (IntSet)
--   import qualified Data.IntSet.Translatable as IntSet
--   </pre>
--   
--   This implementation is based on <i>Finger-Trees</i> storing
--   differences of consecutive entries of the ordered sequence of set
--   elements. With this representation, a translation of all elements can
--   be realized by changing only the leftmost element of the Finger-Tree
--   which is a constant time operation. Together with caching of the
--   accumulated differences most set operations can be implemented
--   efficiently too.
module Data.IntSet.Translatable
data IntSet

-- | <i>O(???)</i>. See <a>difference</a>.
(\\) :: IntSet -> IntSet -> IntSet

-- | <i>O(1)</i>. Is the set empty?
null :: IntSet -> Bool

-- | <i>O(1)</i>. Cardinality of the set.
size :: IntSet -> Int

-- | <i>O(log(n))</i>. Is the value a member of the set?
member :: Int -> IntSet -> Bool

-- | <i>O(log(n)</i>. Is the element not in the set?
notMember :: Int -> IntSet -> Bool

-- | <i>O(1)</i>. The empty set.
empty :: IntSet

-- | <i>O(1)</i>. A set of one element.
singleton :: Int -> IntSet

-- | <i>O(log(n))</i>. Add a value to the set.
insert :: Int -> IntSet -> IntSet

-- | <i>O(log(n))</i>. Delete a value in the set. Returns the original set
--   when the value was not present.
delete :: Int -> IntSet -> IntSet

-- | <i>O(m log(n </i>/<i> m))</i> where <i>m&lt;=n</i>. The union of two
--   sets. <i>O(log m)</i> if all elements of one set are larger than all
--   elements of the other set.
union :: IntSet -> IntSet -> IntSet

-- | The union of a list of sets.
unions :: [IntSet] -> IntSet

-- | <i>O(???)</i>. Difference between two sets.
difference :: IntSet -> IntSet -> IntSet

-- | <i>O(???)</i>. The intersection of two sets.
intersection :: IntSet -> IntSet -> IntSet

-- | <i>O(n)</i>. Filter all elements that satisfy some predicate.
filter :: (Int -> Bool) -> IntSet -> IntSet

-- | <i>O(n)</i>. Partition the set into two sets, one with all elements
--   that satisfy the predicate and one with all elements that don't
--   satisfy the predicate. See also <a>split</a>.
partition :: (Int -> Bool) -> IntSet -> (IntSet, IntSet)

-- | <i>O(log(min(i,n-i)))</i>. The expression (<tt><a>split</a> x
--   set</tt>) is a pair <tt>(set1,set2)</tt> where <tt>set1</tt> comprises
--   the elements of <tt>set</tt> less than <tt>x</tt> and <tt>set2</tt>
--   comprises the elements of <tt>set</tt> greater than <tt>x</tt>.
--   
--   <pre>
--   split 3 (fromList [1..5]) == (fromList [1,2], fromList [4,5])
--   </pre>
split :: Int -> IntSet -> (IntSet, IntSet)

-- | <i>O(log(min(i,n-i)))</i>. Performs a <a>split</a> but also returns
--   whether the pivot element was found in the original set.
splitMember :: Int -> IntSet -> (IntSet, Bool, IntSet)

-- | <i>O(1)</i>. The minimal element of the set.
findMin :: IntSet -> Int

-- | <i>O(1)</i>. The maximal element of a set.
findMax :: IntSet -> Int

-- | <i>O(1)</i>. Delete the minimal element.
deleteMin :: IntSet -> IntSet

-- | <i>O(1)</i>. Delete the maximal element.
deleteMax :: IntSet -> IntSet

-- | <i>O(1)</i>. Delete and find the minimal element.
--   
--   <pre>
--   deleteFindMin set = (findMin set, deleteMin set)
--   </pre>
deleteFindMin :: IntSet -> (Int, IntSet)

-- | <i>O(1)</i>. Delete and find the maximal element.
--   
--   <pre>
--   deleteFindMax set = (findMax set, deleteMax set)
--   </pre>
deleteFindMax :: IntSet -> (Int, IntSet)

-- | <i>O(1)</i>. Retrieves the maximal key of the set, and the set
--   stripped of that element, or <a>Nothing</a> if passed an empty set.
maxView :: IntSet -> Maybe (Int, IntSet)

-- | <i>O(1)</i>. Retrieves the minimal key of the set, and the set
--   stripped of that element, or <a>Nothing</a> if passed an empty set.
minView :: IntSet -> Maybe (Int, IntSet)

-- | <i>O(n*log(n))</i>. <tt><a>map</a> f s</tt> is the set obtained by
--   applying <tt>f</tt> to each element of <tt>s</tt>.
--   
--   It's worth noting that the size of the result may be smaller if, for
--   some <tt>(x,y)</tt>, <tt>x /= y &amp;&amp; f x == f y</tt>
map :: (Int -> Int) -> IntSet -> IntSet

-- | <i>O(1)</i>. Add a constant value to all elements of the set.
--   
--   <pre>
--   translate x s == map (+x) s
--   </pre>
translate :: Int -> IntSet -> IntSet

-- | <i>O(n)</i>. Fold over the elements of a set in an unspecified order.
--   
--   <pre>
--   sum set   == fold (+) 0 set
--   elems set == fold (:) [] set
--   </pre>
fold :: (Int -> b -> b) -> b -> IntSet -> b

-- | <i>O(n)</i>. The elements of a set. (For sets, this is equivalent to
--   toList)
elems :: IntSet -> [Int]

-- | <i>O(n)</i>. Convert the set to a list of elements.
toList :: IntSet -> [Int]

-- | <i>O(n*log(n))</i>. Create a set from a list of integers.
fromList :: [Int] -> IntSet

-- | <i>O(n)</i>. Convert the set to an ascending list of elements.
toAscList :: IntSet -> [Int]

-- | <i>O(n)</i>. Build a set from an ascending list of elements. <i>The
--   precondition (input list is ascending) is not checked.</i>
fromAscList :: [Int] -> IntSet

-- | <i>O(n)</i>. Build a set from an ascending list of distinct elements.
--   <i>The precondition (input list is strictly ascending) is not
--   checked.</i>
fromDistinctAscList :: [Int] -> IntSet
instance Eq IntSet
instance Eq Diff
instance Monoid IntSet
instance Read IntSet
instance Show IntSet
instance Ord IntSet
instance Measured DiffSum Diff
instance Monoid DiffSum
