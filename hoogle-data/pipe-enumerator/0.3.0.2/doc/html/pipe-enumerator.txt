-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A bidirectional bridge between pipes and iteratees
--   
--   This library defines a set of functions that convert between the
--   <a>Pipes</a> and <a>Data.Enumerator</a> paradigms. The conversion is
--   bidirectional: an appropriately-typed pipe can be converted into an
--   <a>Data.Enumerator.Iteratee</a> and back into a pipe. In addition, a
--   pipe can be fed into an iteratee (or, more specifically,
--   <a>Data.Enumerator.Step</a>), resulting in an
--   <a>Data.Enumerator.Enumerator</a>. The library has been designed
--   specifically for use with Snap, but I'm sure that many other
--   interesting uses of it exist.
@package pipe-enumerator
@version 0.3.0.2


-- | This module defines a set of functions that convert between the
--   <a>Pipes</a> and <a>Data.Enumerator</a> paradigms. The conversion is
--   bidirectional: an appropriately-typed pipe can be converted into an
--   <a>Iteratee</a> and back into a pipe. In addition, a pipe can be fed
--   into an iteratee (or, more specifically, <a>Step</a>), resulting in an
--   <a>Enumerator</a>.
--   
--   The library has been designed specifically for use with Snap, but I'm
--   sure that many other interesting uses of it exist.
module Pipes.Enumerator

-- | Converts a <a>Stream</a> to an optional list.
fromStream :: Stream a -> Maybe [a]

-- | Converts an optional list to a <a>Stream</a>.
toStream :: Maybe [a] -> Stream a

-- | Converts an optional value to a singleton <a>Stream</a>.
toSingletonStream :: Maybe a -> Stream a

-- | Converts an <a>Iteratee</a> into a <a>Consumer</a>.
iterateeToPipe :: Monad m => Iteratee a m r -> Proxy () (Maybe a) b' b m (Either SomeException (r, Maybe [a]))

-- | Converts a <a>Step</a> into a <a>Consumer</a>.
stepToPipe :: Monad m => Step a m r -> Proxy () (Maybe a) b' b m (Either SomeException (r, Maybe [a]))

-- | Converts a <a>Pipe</a> into an <a>Iteratee</a>. Any output of the pipe
--   is quietly discarded.
pipeToIteratee :: Monad m => Proxy a' (Maybe a) () b m r -> Iteratee a m r

-- | Feed the output of a <a>Pipe</a> to a <a>Step</a>, effectively
--   converting it into an <a>Enumerator</a>, generalised slightly to allow
--   distinct input and output types. The chunks of the input stream are
--   fed into the pipe one element at the time, and the pipe's output is
--   fed to the iteratee one element per chunk. Once the input reaches
--   <a>EOF</a>, the pipe is fed an infinite stream of <a>Nothing</a> until
--   it ends with a pure value, which is discarded. In effect, both the
--   pipe and the iteratee are always consumed fully.
pipeToEnumerator :: Monad m => Proxy a' (Maybe a) () b m r' -> Step b m r -> Iteratee a m r

-- | Feed the output of a <a>Pipe</a> to a <a>Step</a>, effectively
--   converting it into an <a>Enumerator</a>, generalised to allow distinct
--   input and output types and a custom monadic function for merging of
--   the pipe's and step's results into a single result of the constructed
--   iteratee. The chunks of the input stream are fed into the pipe one
--   element at the time, and the pipe's output is fed to the iteratee one
--   element per chunk. Once the input reaches <a>EOF</a>, the pipe is fed
--   an infinite stream of <a>Nothing</a> until it ends with a pure value,
--   which is combined with the step's result using the supplied monadic
--   function <tt>f</tt>. In effect, both the pipe and the iteratee are
--   always consumed fully, with the resulting iteratee returning the
--   results of both transformers.
pipeToEnumerator' :: Monad m => (r1 -> r2 -> m r) -> Proxy a' (Maybe a) () b m r1 -> Step b m r2 -> Iteratee a m r
