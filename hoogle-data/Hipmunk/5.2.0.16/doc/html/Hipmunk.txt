-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A Haskell binding for Chipmunk.
--   
--   Chipmunk is a fast, simple, portable, 2D physics engine
--   (<a>http://code.google.com/p/chipmunk-physics/</a>). This package the
--   Chipmunk 5.3.4 source and Haskell bindings to all of its functions. It
--   is completely self-contained. Please see
--   <a>http://hackage.haskell.org/package/HipmunkPlayground</a> for a
--   demonstration of this library.
--   
--   Version 5.2.0.16:
--   
--   <ul>
--   <li>Bump dependency on transformers. (Thanks, Alfredo Di Napoli!)</li>
--   </ul>
--   
--   Version 5.2.0.15:
--   
--   <ul>
--   <li>Fix for working with GHC 7.6 again.</li>
--   </ul>
--   
--   Version 5.2.0.14:
--   
--   <ul>
--   <li>Compatibility with GHC 7.8. (Thanks, Michael Tolly!)</li>
--   </ul>
--   
--   Version 5.2.0.11:
--   
--   <ul>
--   <li>Compatibility with base == 4.6.* (Thanks, Zack Corr!)</li>
--   </ul>
--   
--   Version 5.2.0.10:
--   
--   <ul>
--   <li>Compatibility with base &lt; 4.4</li>
--   </ul>
--   
--   New in version 5.2.0.9:
--   
--   <ul>
--   <li>Added Physics.Hipmunk.Constraint.setMaxBias and setMaxForce.
--   Thanks to Stephen Paul Weber.</li>
--   </ul>
--   
--   New in version 5.2.0.6:
--   
--   <ul>
--   <li>Fixed a memory leak related to collision handlers.</li>
--   </ul>
--   
--   New in version 5.2.0.5:
--   
--   <ul>
--   <li>Always compile <tt>wrapper.c</tt> and fix Haddock errors while
--   handling Unicode. Thanks, Joachim Breitner.</li>
--   </ul>
--   
--   New in version 5.2.0.4:
--   
--   <ul>
--   <li>New system-chipmunk flag. When activated, the package will use the
--   system-wide installed Chipmunk library. Thanks, Joachim Breitner.</li>
--   </ul>
--   
--   New in version 5.2.0.3:
--   
--   <ul>
--   <li>Update to Chipmunk 5.3.5 and bump dependencies to match GHC 7.2.1.
--   (Thanks, Sönke Hahn!)</li>
--   <li>Now Sönke Hahn is also a Hipmunk maintainer. Awesome!</li>
--   </ul>
--   
--   New in version 5.2.0.2:
--   
--   <ul>
--   <li>Update to Chipmunk 5.3.4. Note, however, that not all
--   functionality available in Chipmunk 5.3.4 is here yet. But the bug
--   fixes and performance improvements are.</li>
--   <li>Fix linking bug present since Hipmunk 5.1.0. Thanks, Sönke
--   Hahn.</li>
--   <li>Correctly destroy the space in the presence of callbacks.</li>
--   <li>Workaround difficult-to-reproduce bug in Chipmunk where the number
--   of contact points in an arbiter would get garbage. When that happens
--   (and the garbage does look like garbage) we give an empty list of
--   contact points.</li>
--   </ul>
--   
--   Licensed under the MIT license (like Chipmunk itself).
@package Hipmunk
@version 5.2.0.16


-- | Functionality used by various modules and routines for initialization
--   and change of global variables.
module Physics.Hipmunk.Common

-- | Initilizes the Chipmunk library. This should be called once before
--   using any functions of this library.
initChipmunk :: IO ()

-- | The floating point type used internally in Chipmunk.
type CpFloat = Double

-- | <tt>infinity</tt> may be used to create bodies with an infinite mass.
infinity :: CpFloat

-- | Type synonym used to hint that the argument or result represents time.
type Time = CpFloat

-- | Type synonym used to hint that the argument or result represents an
--   angle in radians.
type Angle = CpFloat

-- | Type synonym used to hint that the argument or result represents a
--   distance.
type Distance = CpFloat

-- | Type synonym used to hint that the argument or result represents a
--   damping constant.
type Damping = CpFloat

-- | <tt>resetShapeCounter</tt> reset the shape counter to its default
--   value. This is used to add determinism to a simulation. As the ids
--   created with this counter may affect the order in which the collisions
--   happen, there may be very slight differences in different simulations.
--   It may be very useful to call <tt>resetShapeCounter</tt> everytime you
--   start a new simulation.
--   
--   However, be careful as you should not use shapes created before a call
--   to <tt>resetCounter</tt> with shapes created after it as they may have
--   the same id. This means that you can't add shapes created after the
--   call to a space created before it.
resetShapeCounter :: IO ()
contactPersistence :: StateVar CInt
collisionSlop :: StateVar CpFloat
type BiasCoef = CpFloat
biasCoef :: StateVar BiasCoef
constraintBiasCoef :: StateVar BiasCoef

-- | A two-dimensional vector. It is an instance of <a>Num</a> however the
--   operations <a>signum</a> and <tt>(*)</tt> are not supported.
data Vector
Vector :: !CpFloat -> !CpFloat -> Vector

-- | Type synonym used to hint that the argument or result represents a
--   position.
type Position = Vector

-- | Constructs an unitary vector pointing to the given angle (in radians).
fromAngle :: Angle -> Vector

-- | The length of a vector.
len :: Vector -> CpFloat

-- | Normalizes the vector (i.e. divides it by its length).
normalize :: Vector -> Vector

-- | Scales the components of a vector by the same amount.
scale :: Vector -> CpFloat -> Vector

-- | <tt>toAngle v</tt> is the angle that <tt>v</tt> has with the vector
--   <tt>Vector 1 0</tt> (modulo <tt>2*pi</tt>).
toAngle :: Vector -> Angle

-- | <tt>v1 `dot` v2</tt> computes the familiar dot operation.
dot :: Vector -> Vector -> CpFloat

-- | <tt>v1 `cross` v2</tt> computes the familiar cross operation.
cross :: Vector -> Vector -> CpFloat

-- | <tt>perp v</tt> is a vector of same length as <tt>v</tt> but
--   perpendicular to <tt>v</tt> (i.e. <tt>toAngle (perp v) - toAngle
--   v</tt> equals <tt>pi/2</tt> modulo <tt>2*pi</tt>).
perp :: Vector -> Vector

-- | <tt>v1 `project` v2</tt> is the vector projection of <tt>v1</tt> onto
--   <tt>v2</tt>.
project :: Vector -> Vector -> Vector

-- | <tt>v1 `rotate` v2</tt> uses complex multiplication to rotate (and
--   scale) <tt>v1</tt> by <tt>v2</tt>.
rotate :: Vector -> Vector -> Vector

-- | The inverse operation of <tt>rotate</tt>, such that <tt>unrotate
--   (rotate v1 v2) v2</tt> equals <tt>v1</tt>.
unrotate :: Vector -> Vector -> Vector
instance Eq Vector
instance Show Vector
instance Ord Vector
instance Storable Vector
instance Num Vector


-- | Rigid bodies and their properties.
module Physics.Hipmunk.Body

-- | A rigid body representing the physical properties of an object, but
--   without a shape. It may help to think of it as a particle that is able
--   to rotate.
data Body

-- | <tt>newBody mass inertia</tt> creates a new <a>Body</a> with the given
--   mass and moment of inertia.
--   
--   It is recommended to call <tt>setPosition</tt> afterwards.
newBody :: Mass -> Moment -> IO Body
type Mass = CpFloat
mass :: Body -> StateVar Mass
type Moment = CpFloat
moment :: Body -> StateVar Moment

-- | Note that using this function to change the position on every step is
--   not recommended as it may leave the velocity out of sync.
position :: Body -> StateVar Position
type Velocity = Vector
velocity :: Body -> StateVar Velocity

-- | Maximum linear velocity after integrating, defaults to infinity.
maxVelocity :: Body -> StateVar CpFloat
type Force = Vector
force :: Body -> StateVar Force
angle :: Body -> StateVar Angle
type AngVel = CpFloat
angVel :: Body -> StateVar AngVel

-- | Maximum angular velocity after integrating, defaults to infinity.
maxAngVel :: Body -> StateVar CpFloat
type Torque = CpFloat
torque :: Body -> StateVar Torque

-- | <tt>slew b newpos dt</tt> changes the body <tt>b</tt>'s velocity so
--   that it reaches <tt>newpos</tt> in <tt>dt</tt> time.
--   
--   It is usually used to change the position of a static body in the
--   world. In that case, remember to reset the velocity to zero
--   afterwards!
slew :: Body -> Position -> Time -> IO ()

-- | <tt>updateVelocity b gravity damping dt</tt> redefines body
--   <tt>b</tt>'s linear and angular velocity to account for the
--   force/torque being applied to it, the gravity and a damping factor
--   during <tt>dt</tt> time using Euler integration.
--   
--   Note that this function only needs to be called if you are not adding
--   the body to a space.
updateVelocity :: Body -> Vector -> Damping -> Time -> IO ()

-- | <tt>updatePosition b dt</tt> redefines the body position like
--   <a>updateVelocity</a> (and it also shouldn't be called if you are
--   adding this body to a space).
updatePosition :: Body -> Time -> IO ()

-- | <tt>resetForces b</tt> redefines as zero all forces and torque acting
--   on body <tt>b</tt>.
resetForces :: Body -> IO ()

-- | <tt>applyForce b f r</tt> applies to the body <tt>b</tt> the force
--   <tt>f</tt> with offset <tt>r</tt>, both vectors in world coordinates.
--   This is the most stable way to change a body's velocity.
--   
--   Note that the force is accumulated in the body, so you may need to
--   call <a>applyOnlyForce</a>.
applyForce :: Body -> Vector -> Position -> IO ()

-- | <tt>applyOnlyForce b f r</tt> applies a force like <a>applyForce</a>,
--   but calling <a>resetForces</a> before. Note that using this function
--   is preferable as it is optimized over this common case.
applyOnlyForce :: Body -> Vector -> Position -> IO ()

-- | <tt>applyImpulse b j r</tt> applies to the body <tt>b</tt> the impulse
--   <tt>j</tt> with offset <tt>r</tt>, both vectors in world coordinates.
applyImpulse :: Body -> Vector -> Position -> IO ()

-- | <tt>dampedSpring (b1,a1) (b2,a2) rlen k dmp dt</tt> applies a damped
--   spring force between bodies <tt>b1</tt> and <tt>b2</tt> at anchors
--   <tt>a1</tt> and <tt>a2</tt>, respectively. <tt>k</tt> is the spring
--   constant (force/distance), <tt>rlen</tt> is the rest length of the
--   spring, <tt>dmp</tt> is the damping constant (force/velocity), and
--   <tt>dt</tt> is the time step to apply the force over. Both anchors are
--   in body coordinates.
--   
--   Note: large damping values can be unstable, you should use the damped
--   spring constraint instead.
applyDampedSpring :: (Body, Position) -> (Body, Position) -> Distance -> CpFloat -> Damping -> Time -> IO ()

-- | For a vector <tt>p</tt> in body <tt>b</tt>'s coordinates,
--   <tt>localToWorld b p</tt> returns the corresponding vector in world
--   coordinates.
localToWorld :: Body -> Position -> IO Position

-- | For a vector <tt>p</tt> in world coordinates, <tt>worldToLocal b
--   p</tt> returns the corresponding vector in body <tt>b</tt>'s
--   coordinates.
worldToLocal :: Body -> Position -> IO Position


-- | Shapes used for collisions, their properties and some useful polygon
--   functions.
module Physics.Hipmunk.Shape

-- | A collision shape is attached to a <a>Body</a> to define its shape.
--   Multiple shapes may be attached, including overlapping ones (shapes of
--   a body don't generate collisions with each other).
--   
--   Note that to have any effect, a <a>Shape</a> must also be added to a
--   <a>Space</a>, even if the body was already added.
data Shape

-- | There are three types of shapes that can be attached to bodies:
data ShapeType

-- | A circle is the fastest collision type. It also rolls smoothly.
Circle :: !Distance -> ShapeType
radius :: ShapeType -> !Distance

-- | A line segment is meant to be used as a static shape. (It can be used
--   with moving bodies, however two line segments never generate
--   collisions between each other.)
LineSegment :: !Position -> !Position -> !Distance -> ShapeType
start :: ShapeType -> !Position
end :: ShapeType -> !Position
thickness :: ShapeType -> !Distance

-- | Polygons are the slowest of all shapes but the most flexible. The list
--   of vertices must form a convex hull with clockwise winding. Note that
--   if you want a non-convex polygon you may add several convex polygons
--   to the body.
Polygon :: ![Position] -> ShapeType
vertices :: ShapeType -> ![Position]

-- | <tt>newShape b type off</tt> creates a new shape attached to body
--   <tt>b</tt> at offset <tt>off</tt>. Note that you have to add the shape
--   to a space otherwise it won't generate collisions.
newShape :: Body -> ShapeType -> Position -> IO Shape

-- | The collision type is used to determine which collision callback will
--   be called. Its actual value doesn't have a meaning for Chipmunk other
--   than the correspondence between shapes and the collision pair
--   functions you add. (default is zero)
type CollisionType = Word32
collisionType :: Shape -> StateVar CollisionType

-- | Groups are used to filter collisions between shapes. If the group is
--   zero, then it imposes no restriction to the collisions. However, if
--   the group is non-zero then the shape will not collide with other
--   shapes in the same non-zero group. (default is zero)
--   
--   This is primarely used to create multi-body, multi-shape objects such
--   as ragdolls. It may be thought as a lightweight alternative to
--   creating a callback that filters the collisions.
type Group = Word32
group :: Shape -> StateVar Group

-- | Layers are similar to groups, but use a bitmask. For a collision to
--   occur, two shapes must have at least one layer in common. In other
--   words, <tt>layer1 .&amp;. layer2</tt> should be non-zero. (default is
--   <tt>-1</tt>, meaning all bits set)
--   
--   Note that although this type may have more than 32 bits, for
--   portability you should only rely on the lower 32 bits.
type Layers = Word32
layers :: Shape -> StateVar Layers

-- | The elasticity of the shape is such that <tt>0.0</tt> gives no bounce
--   while <tt>1.0</tt> give a "perfect" bounce. Note that due to
--   inaccuracies using <tt>1.0</tt> or greater is not recommended.
--   
--   The amount of elasticity applied during a collision is calculated by
--   multiplying the elasticity of both shapes. (default is zero)
--   
--   By default old-style elastic iterations are done when the space
--   <tt>step</tt>s. This used to result in a not-so-good simulation, but
--   now this is the recommended setting.
type Elasticity = CpFloat
elasticity :: Shape -> StateVar Elasticity

-- | The friction coefficient of the shape according to Coulumb friction
--   model (i.e. <tt>0.0</tt> is frictionless, iron on iron is around
--   <tt>1.0</tt>, and it could be greater then <tt>1.0</tt>).
--   
--   The amount of friction applied during a collision is determined by
--   multiplying the friction coefficient of both shapes. (default is zero)
type Friction = CpFloat
friction :: Shape -> StateVar Friction

-- | The surface velocity of the shape. Useful to create conveyor belts and
--   players that move around. This value is only used when calculating
--   friction, not collision. (default is zero)
type SurfaceVel = Vector
surfaceVel :: Shape -> StateVar SurfaceVel

-- | <tt>body s</tt> is the body that this shape is associated to. Useful
--   especially in a space callback.
body :: Shape -> Body

-- | <tt>momentForShape m s off</tt> is a convenience function that
--   calculates the moment of inertia for shape <tt>s</tt> with mass
--   <tt>m</tt> and at a offset <tt>off</tt> of the body's center. Uses
--   <a>momentForCircle</a>, <a>momentForSegment</a> and
--   <a>momentForPoly</a> internally.
momentForShape :: Mass -> ShapeType -> Position -> Moment

-- | <tt>momentForCircle m (ri,ro) off</tt> is the moment of inertia of a
--   circle of <tt>m</tt> mass, inner radius of <tt>ri</tt>, outer radius
--   of <tt>ro</tt> and at an offset <tt>off</tt> from the center of the
--   body.
momentForCircle :: Mass -> (Distance, Distance) -> Position -> Moment

-- | <tt>momentForSegment m p1 p2</tt> is the moment of inertia of a
--   segment of mass <tt>m</tt> going from point <tt>p1</tt> to point
--   <tt>p2</tt>.
momentForSegment :: Mass -> Position -> Position -> Moment

-- | <tt>momentForPoly m verts off</tt> is the moment of inertia of a
--   polygon of <tt>m</tt> mass, at offset <tt>off</tt> from the center of
--   the body and comprised of <tt>verts</tt> vertices. This is similar to
--   <a>Polygon</a> (and the same restrictions for the vertices apply as
--   well).
momentForPoly :: Mass -> [Position] -> Position -> Moment

-- | <tt>shapePointQuery shape p</tt> returns <tt>True</tt> iff the point
--   in position <tt>p</tt> (in world's coordinates) lies within the shape
--   <tt>shape</tt>.
shapePointQuery :: Shape -> Position -> IO Bool

-- | <tt>shapeSegmentQuery shape p1 p2</tt> returns <tt>Just (t,n)</tt> iff
--   the segment from <tt>p1</tt> to <tt>p2</tt> (in world's coordinates)
--   intersects with the shape <tt>shape</tt>. In that case, <tt>0 &lt;= t
--   &lt;= 1</tt> indicates that one of the intersections is at point
--   <tt>p1 + (p2 - p1) `scale` t</tt> with normal <tt>n</tt>.
shapeSegmentQuery :: Shape -> Position -> Position -> IO (Maybe (CpFloat, Vector))

-- | A line segment.
type Segment = (Position, Position)

-- | A possible intersection between two segments.
data Intersection

-- | Don't intercept.
IntNowhere :: Intersection

-- | Intercept in a point.
IntPoint :: !Position -> Intersection

-- | Share a segment.
IntSegmt :: !Segment -> Intersection

-- | The epsilon used in the algorithms below when necessary to compare
--   floats for "equality".
epsilon :: CpFloat

-- | "Equality" under <a>epsilon</a>. That is, <tt>a .==. b</tt> if <tt>abs
--   (a - b) &lt;= epsilon</tt>.
(.==.) :: CpFloat -> CpFloat -> Bool

-- | <tt>isLeft (p1,p2) vert</tt> is
--   
--   <ul>
--   <li><tt>LT</tt> if <tt>vert</tt> is at the left of the line defined by
--   <tt>(p1,p2)</tt>.</li>
--   <li><tt>EQ</tt> if <tt>vert</tt> is at the line <tt>(p1,p2)</tt>.</li>
--   <li><tt>GT</tt> otherwise.</li>
--   </ul>
isLeft :: (Position, Position) -> Position -> Ordering

-- | <i>O(n)</i>. <tt>isClockwise verts</tt> is <tt>True</tt> iff
--   <tt>verts</tt> form a clockwise polygon.
isClockwise :: [Position] -> Bool

-- | <i>O(n)</i>. <tt>isConvex verts</tt> is <tt>True</tt> iff
--   <tt>vers</tt> form a convex polygon.
isConvex :: [Position] -> Bool

-- | <i>O(1)</i>. <tt>intersects seg1 seg2</tt> is the intersection between
--   the two segments <tt>seg1</tt> and <tt>seg2</tt>. See
--   <a>Intersection</a>.
intersects :: Segment -> Segment -> Intersection

-- | <i>O(n)</i>. <tt>polyReduce delta verts</tt> removes from
--   <tt>verts</tt> all points that have less than <tt>delta</tt> distance
--   in relation to the one preceding it.
--   
--   Note that a very small polygon may be completely "eaten" if all its
--   vertices are within a <tt>delta</tt> radius from the first.
polyReduce :: Distance -> [Position] -> [Position]

-- | <i>O(n)</i>. <tt>polyCenter verts</tt> is the position in the center
--   of the polygon formed by <tt>verts</tt>.
polyCenter :: [Position] -> Position

-- | <i>O(n log n)</i>. <tt>convexHull verts</tt> is the convex hull of the
--   polygon defined by <tt>verts</tt>. The vertices of the convex hulls
--   are given in clockwise winding. The polygon doesn't have to be simple.
--   
--   Implemented using Graham scan, see
--   <a>http://cgm.cs.mcgill.ca/~beezer/cs507/3coins.html</a>.
convexHull :: [Position] -> [Position]
instance Eq ShapeType
instance Ord ShapeType
instance Show ShapeType
instance Eq Intersection
instance Ord Intersection
instance Show Intersection


-- | Constraints that restrict the bodies' movement.
module Physics.Hipmunk.Constraint

-- | Represents a constraint between two bodies. Don't forget to add the
--   bodies and the constraint itself to the space. The phantom type
--   indicates the type of the constraint.
data Constraint a

-- | <tt>newConstraint b1 b2 type_</tt> connects the two bodies <tt>b1</tt>
--   and <tt>b2</tt> with a constraint of the given type. Note that you
--   should add the <a>Constraint</a> to a space.
--   
--   The <a>ConstraintType</a> type class is implemented by all constraint
--   types to allow them to be manipulated by the same framework while
--   retaining type-safety, consequently it isn't exported.
newConstraint :: ConstraintType a => Body -> Body -> a -> IO (Constraint a)

-- | <tt>redefine constr type_</tt> redefines <tt>constr</tt>'s parameters
--   on-the-fly, allowing you to dynamically change the constraint's
--   behaviour.
redefineC :: ConstraintType a => Constraint a -> a -> IO ()

-- | Sets the constraint's bias coefficient. By default it is equal to the
--   last value set globally with <tt>setConstraintBiasCoef</tt>, which
--   initially is <tt>0.1</tt>
setBiasCoefC :: BiasCoef -> Constraint a -> IO ()
setMaxBias :: CpFloat -> Constraint a -> IO ()
setMaxForce :: CpFloat -> Constraint a -> IO ()

-- | An unknown constraint "type". Note that this isn't a
--   <a>ConstraintType</a> because you can't create a constraint of
--   <tt>Unknown</tt> type.
data Unknown

-- | Completely safe function that discards the constraint type (which is a
--   phantom type). You can "remember" it again by using
--   <tt>unsafeRemember</tt> from the <tt>Unsafe</tt> module.
forgetC :: Constraint a -> Constraint Unknown

-- | A pin joint connects the bodies with a solid pin. The anchor points
--   are kept at a fixed distance.
data Pin
Pin :: !Position -> !Position -> Pin

-- | First anchor.
pinAnchor1 :: Pin -> !Position

-- | Second anchor.
pinAnchor2 :: Pin -> !Position

-- | A slide joint is similar to a pin joint, however it has a minimum and
--   a maximum distance.
data Slide
Slide :: !Position -> !Position -> !Distance -> !Distance -> Slide

-- | First anchor.
slideAnchor1 :: Slide -> !Position

-- | Second anchor.
slideAnchor2 :: Slide -> !Position

-- | Minimum distance.
slideMinDist :: Slide -> !Distance

-- | Maximum distance.
slideMaxDist :: Slide -> !Distance

-- | A pivot joint allows the bodies to pivot around a single point.
data Pivot

-- | You may specify the pivot point in world's coordinates (so both bodies
--   should be already in place).
Pivot1 :: !Position -> Pivot

-- | Pivot point in world's coordinates.
pivotPos :: Pivot -> !Position

-- | Or you may specify the joint as two anchors (on each body's
--   coordinates), removing the need having the bodies already in place.
Pivot2 :: !Position -> !Position -> Pivot

-- | First anchor.
pivotAnchor1 :: Pivot -> !Position

-- | Second anchor.
pivotAnchor2 :: Pivot -> !Position

-- | A groove joint attaches a point on the second body to a groove in the
--   first one.
data Groove
Groove :: !(Position, Position) -> !Position -> Groove

-- | Groove, in first body's coordinates.
groovePoints :: Groove -> !(Position, Position)

-- | Pivot, in second body's coordinates.
groovePivot :: Groove -> !Position

-- | A gear joint restricts the bodies movement to be coordinated as if
--   they were attached like dented gears.
data Gear
Gear :: !Angle -> !CpFloat -> Gear

-- | Phase of the movement.
gearPhase :: Gear -> !Angle

-- | Ratio between the gears.
gearRatio :: Gear -> !CpFloat

-- | A simple damped spring. Generally this constraint should be used
--   instead of <tt>applyDampedSpring</tt>.
data DampedSpring
DampedSpring :: !Position -> !Position -> !Distance -> !CpFloat -> !Damping -> DampedSpring

-- | First anchor.
dampedAnchor1 :: DampedSpring -> !Position

-- | Second anchor.
dampedAnchor2 :: DampedSpring -> !Position

-- | Rest length.
dampedRestLength :: DampedSpring -> !Distance

-- | Stiffness.
dampedStiffness :: DampedSpring -> !CpFloat

-- | Damping.
dampedDamping :: DampedSpring -> !Damping

-- | A damped rotary spring constraint.
data DampedRotarySpring
DampedRotarySpring :: !Angle -> !CpFloat -> !Damping -> DampedRotarySpring

-- | Rest angle.
dampedRotRestAngle :: DampedRotarySpring -> !Angle

-- | Stiffness.
dampedRotStiffness :: DampedRotarySpring -> !CpFloat

-- | Damping.
dampedRotDamping :: DampedRotarySpring -> !Damping

-- | A ratchet constraint.
data Ratchet
Ratchet :: !CpFloat -> !CpFloat -> Ratchet

-- | Phase.
ratchetPhase :: Ratchet -> !CpFloat

-- | Ratchet.
ratchet :: Ratchet -> !CpFloat

-- | A rotary limit constraints the difference of angle between two bodies.
data RotaryLimit
RotaryLimit :: Distance -> Distance -> RotaryLimit

-- | Minimum distance.
rotaryMinDist :: RotaryLimit -> Distance

-- | Maximum distance.
rotaryMaxDist :: RotaryLimit -> Distance

-- | A simple motor that applies opposite impulses to each body. The rate
--   is used to compute the torque.
data SimpleMotor
SimpleMotor :: CpFloat -> SimpleMotor

-- | Rate.
simpleMotorRate :: SimpleMotor -> CpFloat
instance Eq Pin
instance Ord Pin
instance Show Pin
instance Eq Slide
instance Ord Slide
instance Show Slide
instance Eq Pivot
instance Ord Pivot
instance Show Pivot
instance Eq Groove
instance Ord Groove
instance Show Groove
instance Eq Gear
instance Ord Gear
instance Show Gear
instance Eq DampedSpring
instance Ord DampedSpring
instance Show DampedSpring
instance Eq DampedRotarySpring
instance Ord DampedRotarySpring
instance Show DampedRotarySpring
instance Eq Ratchet
instance Ord Ratchet
instance Show Ratchet
instance Eq RotaryLimit
instance Ord RotaryLimit
instance Show RotaryLimit
instance Eq SimpleMotor
instance Ord SimpleMotor
instance Show SimpleMotor
instance ConstraintType SimpleMotor
instance ConstraintType RotaryLimit
instance ConstraintType Ratchet
instance ConstraintType DampedRotarySpring
instance ConstraintType DampedSpring
instance ConstraintType Gear
instance ConstraintType Groove
instance ConstraintType Pivot
instance ConstraintType Slide
instance ConstraintType Pin


-- | The space, where the simulation happens and the various entities
--   interact.
module Physics.Hipmunk.Space

-- | A space is where the simulation really occurs. You add bodies, shapes
--   and constraints to a space and then <tt>step</tt> it to update it as
--   whole.
data Space

-- | Creates a new, empty space. Some of the memory resources associated
--   with the space must be manually freed through <a>freeSpace</a> when
--   the <a>Space</a> is no longer necessary.
newSpace :: IO Space

-- | <tt>freeSpace sp</tt> frees some memory resources that can't be
--   automatically deallocated in a portable way. The space <tt>sp</tt>
--   then becomes invalid and should not be used (passing <tt>sp</tt> to
--   any other function, including <a>freeSpace</a>, results in undefined
--   behavior).
freeSpace :: Space -> IO ()

-- | Type class implemented by entities that can be added to a space.
class Entity a
spaceAdd :: Entity a => Space -> a -> IO ()
spaceRemove :: Entity a => Space -> a -> IO ()

-- | A <a>StaticShape</a> is a <a>Shape</a> container that, when added to a
--   space via <a>spaceAdd</a>, is added to the static list of shapes.
--   
--   A static shape is one assumed not to move. If you move a static shape
--   after adding it, then you need to <a>rehashStatic</a>.
--   
--   You should not add the same shape as active and static, nor should you
--   add as active and try to remove as static or vice versa.
newtype StaticShape
Static :: Shape -> StaticShape
unStatic :: StaticShape -> Shape

-- | The number of iterations to use when solving constraints. (default is
--   10).
type Iterations = CInt
iterations :: Space -> StateVar Iterations

-- | The number of elastic iterations to use when solving constraints. If
--   <tt>0</tt>, then old-style elastic code is used. (default is 0).
--   
--   This property is deprecated. You should no longer need to set any
--   value other than the default.
type ElasticIterations = CInt

-- | <i>Deprecated: Elastic iterations should no longer be needed </i>
elasticIterations :: Space -> StateVar ElasticIterations

-- | The gravity applied to the system. (default is 0)
type Gravity = Vector
gravity :: Space -> StateVar Gravity

-- | The amount of viscous damping applied to the system. (default is 1)
damping :: Space -> StateVar Damping

-- | The time stamp of the simulation, increased in 1 every time
--   <a>step</a> is called.
type TimeStamp = CInt
timeStamp :: Space -> GettableStateVar TimeStamp
resizeStaticHash :: Space -> Distance -> CInt -> IO ()
resizeActiveHash :: Space -> Distance -> CInt -> IO ()

-- | Rehashes the shapes in the static spatial hash. You only need to call
--   this if you move one of the static shapes.
rehashStatic :: Space -> IO ()

-- | <tt>spaceQuery sp pos l g cb</tt> will call <tt>cb</tt> for every
--   shape that
--   
--   <ul>
--   <li>Contains point <tt>pos</tt> (in world's coordinates).</li>
--   <li>Isn't of the same group as <tt>g</tt>.</li>
--   <li>Shares at least one layer with <tt>l</tt>.</li>
--   </ul>
--   
--   The order in which the callback is called is unspecified. However it
--   is guaranteed that it will be called once, and only once, for each of
--   the shapes described above (and never for those who aren't).
spaceQuery :: Space -> Position -> Layers -> Group -> (Shape -> IO ()) -> IO ()

-- | <tt>spaceQueryList sp pos l g</tt> acts like <a>spaceQuery</a> but
--   returns a list of <a>Shape</a>s instead of calling a callback. This is
--   just a convenience function.
spaceQueryList :: Space -> Position -> Layers -> Group -> IO [Shape]

-- | <tt>step sp dt</tt> will update the space <tt>sp</tt> for a
--   <tt>dt</tt> time step.
--   
--   It is highly recommended to use a fixed <tt>dt</tt> to increase the
--   efficiency of contact persistence. Some tips may be found in
--   <a>http://www.gaffer.org/game-physics/fix-your-timestep</a>.
step :: Space -> Time -> IO ()
instance Entity StaticShape
instance Entity (Constraint a)
instance Entity Shape
instance Entity Body


-- | Callbacks are functions that are called whenever certain events
--   happen. For example, you may use a callback to know when a player
--   bumps into an enemy. Or when a bullet hits its target. Or how strong
--   was a collision.
module Physics.Hipmunk.Callbacks

-- | Phantom type used in <tt>Begin</tt> collision events.
data Begin

-- | Phantom type used in <tt>PreSolve</tt> collision events.
data PreSolve

-- | Phantom type used in <tt>PostSolve</tt> collision events.
data PostSolve

-- | Phantom type used in <tt>Separate</tt> collision events.
data Separate

-- | Phantom type used in <tt>PostStep</tt> callbacks.
--   
--   The phantom type <tt>t</tt> inside this <tt>PostStep</tt> phantom type
--   is the collision event that originated this <tt>PostStep</tt>
--   callback. For example, if you add a <tt>PostStep</tt> from a
--   <tt>Begin</tt> handler, then it will have type <tt>PostStep
--   Begin</tt>. It is used by the <tt>PostStep</tt>'s instance of
--   <a>NotSeparate</a>.
data PostStep t

-- | Class of collision events other than <tt>Separate</tt>. That is,
--   collision events where the shapes are touching or overlapping.
class NotSeparate t

-- | Class of callbacks called from collision events. That is, everything
--   other than <a>PostStep</a>.
class NotPostStep t

-- | Monad where callbacks are run. Within this monad you have access to
--   functions describing the collision. You can also run any IO actions
--   using <a>liftIO</a> from <tt>transformers</tt> package. However,
--   remember not to call <a>spaceAdd</a> or <a>spaceRemove</a> outside a
--   <tt>PostStep</tt> callback -- use <a>postStep</a> instead, for
--   example:
--   
--   <pre>
--   postStep entity (currentSpaceRemove entity)
--   </pre>
--   
--   The phantom type <tt>t</tt> describes the type of callback, which can
--   be
--   
--   <ul>
--   <li><i><a>Begin</a></i> When the collision first occurs.</li>
--   <li><i><a>PreSolve</a></i> Before the collision is processed.</li>
--   <li><i><a>PostSolve</a></i> After the collision is processed.</li>
--   <li><i><a>Separate</a></i> When the collision ends.</li>
--   <li><i><a>PostStep</a></i> After the <tt>step</tt> finishes.</li>
--   </ul>
--   
--   This phantom type is used to disallow invalid operations. For example,
--   you can't calculate the normal of a collision if you are in a
--   <tt>Separate</tt> event, as there is no collision inside this event.
--   And you can't add a new post-step callback inside a post-step
--   callback.
data Callback t a

-- | Shapes involved in this collision.
shapes :: Callback t (Shape, Shape)

-- | <tt>True</tt> iff this is the first step that the shapes touched.
isFirstContact :: Callback t Bool

-- | The normal vector of the collision.
normal :: NotSeparate t => Callback t Vector

-- | Points where the collision occured.
points :: NotSeparate t => Callback t [Position]

-- | The total impulse that was applied to resolve the collision. Returns
--   incorrect results if elastic iterations are being used.
totalImpulse :: NotSeparate t => Callback (PostStep t) Vector

-- | The total impulse with friction that was applied to resolve the
--   collision. Returns incorrect results if elastic iterations are being
--   used.
totalImpulseWithFriction :: NotSeparate t => Callback (PostStep t) Vector

-- | Add an entity to the current <a>Space</a> from where this callback was
--   called. Don't add the same entity twice to a space.
--   
--   You can add entities only in <a>PostStep</a> callbacks. You should not
--   use <tt>liftIO</tt> and <tt>spaceAdd</tt>.
currentSpaceAdd :: Entity a => a -> Callback (PostStep t) ()

-- | Remove an entity from the current <a>Space</a> from where this
--   callback was called. Don't remove an entity that wasn't added.
--   
--   You can remove entities only in <a>PostStep</a> callbacks. You should
--   not use <tt>liftIO</tt> and <tt>spaceRemove</tt>.
currentSpaceRemove :: Entity a => a -> Callback (PostStep t) ()

-- | <tt>postStep e cb</tt> registers a callback <tt>cb</tt> for the
--   <a>PostStep</a> phase on a given entity <tt>e</tt>. <tt>PostStep</tt>
--   callbacks are called once when the <tt>step</tt> call finishes (and
--   only on the current time step). This is the only kind of callbacks
--   that may call <a>currentSpaceAdd</a> and <a>currentSpaceRemove</a>.
--   
--   Each entity may have <i>at most one</i> callback registered on it. If
--   a second callback <tt>cb2</tt> gets registered on the same entity
--   <tt>e</tt>, then callback <tt>cb</tt> <i>will not</i> be called, only
--   <tt>cb2</tt>. This is not a bug, but a feature. This allows you to
--   say, for example, <tt>postStep shape (currentSpaceRemove shape)</tt>
--   every time <tt>shape</tt> collides. Even if <tt>shape</tt> collided
--   many times in a single time step, only the last callback would be
--   called and <tt>shape</tt> would be removed just once.
--   
--   Note that this function registers a callback from within another
--   callback, as this is the motivation of using <tt>PostStep</tt>
--   callbacks.
postStep :: (Entity a, NotPostStep t) => a -> Callback (PostStep t) () -> Callback t ()

-- | As <a>postStep</a>, registers a <tt>PostStep</tt> callback. Unlike
--   <a>postStep</a>, this function allows you to register a
--   <tt>PostStep</tt> callback from anywhere. Also, from this callback you
--   won't be in <a>Callback</a> monad. It is therefore unsafe and should
--   not be used unless you really know what you are doing.
unsafePostStep :: Entity a => Space -> a -> IO () -> IO ()

-- | A 4-tuple of callbacks, one for each kind of collision event.
--   
--   <tt>beginHandler</tt> and <tt>preSolveHandler</tt> should return a
--   <tt>Bool</tt> stating <tt>True</tt> if the collision should be
--   processed or <tt>False</tt> if the collision should be ignored. If
--   <tt>beginHandler</tt> returns <tt>False</tt>, the collision will be
--   completely ignored. If <tt>preSolveHandler</tt> returns
--   <tt>False</tt>, then the collision will be ignored only for this time
--   step.
--   
--   You may also use <tt>Nothing</tt> to use the default handlers. The
--   default is to process all collisions. That is, <tt>Handler Nothing
--   Nothing Nothing Nothing</tt> is the same as
--   
--   <pre>
--   Handler {beginHandler     = Just (return True)
--           ,preSolveHandler  = Just (return True)
--           ,postSolveHandler = Just (return ())
--           ,separateHandler  = Just (return ())}
--   </pre>
--   
--   however using <tt>Nothing</tt> is more efficient (the Chipmunk library
--   won't need to call a Haskell function).
--   
--   Note that assigning <tt>Nothing</tt> <i>does not</i> mean that the
--   default set with <a>setDefaultCollisionHandler</a> will be called.
--   That default is called only if there isn't a registered handler for
--   the given collision types.
data CollisionHandler
Handler :: Maybe (Callback Begin Bool) -> Maybe (Callback PreSolve Bool) -> Maybe (Callback PostSolve ()) -> Maybe (Callback Separate ()) -> CollisionHandler
beginHandler :: CollisionHandler -> Maybe (Callback Begin Bool)
preSolveHandler :: CollisionHandler -> Maybe (Callback PreSolve Bool)
postSolveHandler :: CollisionHandler -> Maybe (Callback PostSolve ())
separateHandler :: CollisionHandler -> Maybe (Callback Separate ())

-- | Defines a new default collision handler. This handler is used whenever
--   two shapes <tt>a</tt> and <tt>b</tt> collide such that no other
--   collision pair function was defined to <tt>a</tt>'s and <tt>b</tt>'s
--   collision types. The default is <tt>Handler Nothing Nothing Nothing
--   Nothing</tt>.
setDefaultCollisionHandler :: Space -> CollisionHandler -> IO ()

-- | <tt>addCollisionHandler sp (cta,ctb) handler</tt> defines
--   <tt>handler</tt> as the handler to be used whenever a collision occurs
--   between a shape of collision type <tt>cta</tt> and another of
--   collision type <tt>ctb</tt> (and vice versa). Any other callback
--   already registered to handle <tt>(cta,ctb)</tt> will be removed.
--   
--   Note that you should <i>not</i> add handlers to both combinations of
--   <tt>(cta,ctb)</tt> and <tt>(ctb,cta)</tt>. Doing so results in
--   undefined behaviour. A good rule of thumb is to always use <tt>cta
--   &lt;= ctb</tt>, although this is not necessary.
addCollisionHandler :: Space -> CollisionType -> CollisionType -> CollisionHandler -> IO ()

-- | <tt>removeCollisionHandler sp (cta,ctb)</tt> removes the handler that
--   was registered to handle <tt>(cta,ctb)</tt>, if any (see
--   <a>addCollisionHandler</a>). Any collisions that would be handled by
--   the removed handler will be handled by the default one (see
--   <a>setDefaultCollisionHandler</a>).
--   
--   Note that you should <i>always</i> use the same order that was passed
--   to <a>addCollisionHandler</a>. In other words, after
--   <tt>addCollisionHandler sp (cta,ctb) handler</tt> you should use
--   <tt>removeCollisionHandler sp (cta,ctb)</tt>, and <i>never</i>
--   <tt>removeCollisionHandler sp (ctb,cta)</tt> (note the swapped tuple).
--   
--   Although pointless, it is harmless to remove a callback that was not
--   added.
removeCollisionHandler :: Space -> CollisionType -> CollisionType -> IO ()
instance MakeChipmunkCB ()
instance MakeChipmunkCB CInt
instance MonadIO (Callback t)
instance Applicative (Callback t)
instance Monad (Callback t)
instance Functor (Callback t)
instance NotPostStep Separate
instance NotPostStep PostSolve
instance NotPostStep PreSolve
instance NotPostStep Begin
instance NotSeparate t => NotSeparate (PostStep t)
instance NotSeparate PostSolve
instance NotSeparate PreSolve
instance NotSeparate Begin


-- | All functions on this module are <i>UNSAFE</i> in the sense that they
--   may reduce the physical accuracy or numerical stability of the
--   simulation if you use them correctly, or may crash your system if you
--   are not careful enough. Read their documentation carefully and use
--   them only if you really need and know what you are doing.
module Physics.Hipmunk.Unsafe

-- | <tt>unsafeShapeRedefine shape type off</tt> redefines <tt>shape</tt>
--   to have new parameters described on <tt>type</tt> and to be at offset
--   <tt>off</tt>. Be careful, <i>you should not change the shape type</i>.
--   For example, it is unsafe to change a circle shape's radius, but it is
--   an error to try to change a circle into a segment or a polygon. Note
--   also that these errors <i>are not</i> <i>checked</i>, meaning <i>they
--   will probably crash Chipmunk</i>.
unsafeShapeRedefine :: Shape -> ShapeType -> Position -> IO ()

-- | Unsafe function that changes the constraint type to anything. It is
--   unsafe because you should call <tt>redefine</tt> only on the same kind
--   of constraint you created, and this function allows you to bypass the
--   type system checks. Note also that, unlike Chipmunk, we don't check at
--   run-time that <tt>redefine</tt> is being called on the right type!
unsafeRememberC :: ConstraintType a => Constraint Unknown -> Constraint a


-- | This module re-exports all other Hipmunk modules. It is meant to be
--   imported qualified such as
--   
--   <pre>
--   import qualified Physics.Hipmunk as H
--   </pre>
--   
--   however it doesn't clash with the <tt>Prelude</tt>.
module Physics.Hipmunk
