-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A search and indexing engine.
--   
--   The Holumbus-Searchengine library provides a document indexer and
--   crawler to build indexes over document collections as well as a
--   sophisticated query interface for these indexes.
--   
--   Changes from 1.2.2: New HashedIndex with DocIds generated by a hash
--   function
@package Holumbus-Searchengine
@version 1.2.3


-- | Version : 0.1
--   
--   Small utility functions which are probably useful somewhere else, too.
module Holumbus.Utility

-- | Split a string into seperate strings at a specific character sequence.
split :: Eq a => [a] -> [a] -> [[a]]

-- | Join with a seperating character sequence.
join :: Eq a => [a] -> [[a]] -> [a]

-- | Removes leading and trailing whitespace from a string.
strip :: String -> String

-- | Removes leading whitespace from a string.
stripl :: String -> String

-- | Removes trailing whitespace from a string.
stripr :: String -> String

-- | Strip leading and trailing elements matching a predicate.
stripWith :: (a -> Bool) -> [a] -> [a]

-- | found on the haskell cafe mailing list
--   (<a>http://www.haskell.org/pipermail/haskell-cafe/2008-April/041970.html</a>).
--   Depends on bytestring &gt;= 0.9.0.4 (?)
strictDecodeFile :: Binary a => FilePath -> IO a

-- | partition the list of input data into a list of input data lists of
--   approximately the same specified length
partitionListByLength :: Int -> [a] -> [[a]]

-- | partition the list of input data into a list of a specified number of
--   input data lists with approximately the same length
partitionListByCount :: Int -> [a] -> [[a]]

-- | Escapes non-alphanumeric or space characters in a String
escape :: String -> String

-- | Compute the base of a webpage stolen from Uwe Schmidt,
--   http://www.haskell.org/haskellwiki/HXT
computeDocBase :: ArrowXml a => a XmlTree String
traceOffset :: Int
trcMsg :: String -> IO ()
getByPath :: ArrowXml a => [String] -> a XmlTree XmlTree
robotsNo :: String -> LA XmlTree XmlTree
robotsNoIndex :: ArrowXml a => a XmlTree XmlTree
robotsNoFollow :: ArrowXml a => a XmlTree XmlTree


-- | Version : 0.2
--   
--   The unique Holumbus mechanism for generating fuzzy sets.
module Holumbus.Query.Fuzzy

-- | A set of string which have been <a>fuzzed</a> with an associated
--   score.
type FuzzySet = Map String FuzzyScore

-- | Some replacements which can be applied to a string to generate a
--   <a>FuzzySet</a>. The scores of the replacements will be normalized to
--   a maximum of 1.0.
type Replacements = [Replacement]

-- | A single replacements, where the first will be replaced by the second
--   and vice versa in the target string. The score indicates the amount of
--   fuzzines that one single application of this replacement in just one
--   direction will cause on the target string.
type Replacement = ((String, String), FuzzyScore)

-- | The score indicating an amount of fuzziness.
type FuzzyScore = Float

-- | The configuration of a fuzzy query.
data FuzzyConfig
FuzzyConfig :: Bool -> Bool -> FuzzyScore -> Replacements -> FuzzyConfig

-- | Indicates whether the replacements should be applied.
applyReplacements :: FuzzyConfig -> Bool

-- | Indicates whether the swapping of adjacent characters should be
--   applied.
applySwappings :: FuzzyConfig -> Bool

-- | The maximum allowed fuzziness.
maxFuzziness :: FuzzyConfig -> FuzzyScore

-- | The replacements that should be applied.
customReplacements :: FuzzyConfig -> Replacements

-- | Some default replacements for the english language.
englishReplacements :: Replacements

-- | Some default replacements for the german language.
germanReplacements :: Replacements

-- | Continue fuzzing a string with the an explicitly specified list of
--   replacements until a given score threshold is reached.
fuzz :: FuzzyConfig -> String -> FuzzySet

-- | Transform a fuzzy set into a list (ordered by score).
toList :: FuzzySet -> [(String, FuzzyScore)]
instance Show FuzzyConfig
instance Binary FuzzyConfig


-- | Load and store indexes
module Holumbus.Index.Common.LoadStore

-- | Try to determine the file type automatically. The file is loaded as
--   XML if the filename ends with ".xml" and otherwise is loaded as binary
--   file.
loadFromFile :: (XmlPickler a, Binary a) => FilePath -> IO a

-- | Load from XML file.
loadFromXmlFile :: XmlPickler a => FilePath -> IO a

-- | Write to XML file.
writeToXmlFile :: XmlPickler a => FilePath -> a -> IO ()

-- | Load from a binary file.
loadFromBinFile :: Binary a => FilePath -> IO a

-- | Write to a binary file.
writeToBinFile :: Binary a => FilePath -> a -> IO ()


-- | The document identifier type DocId
module Holumbus.Index.Common.DocId

-- | The unique identifier of a document (created upon insertion into the
--   document table).
newtype DocId
DocId :: Int64 -> DocId
theDocId :: DocId -> Int64
incrDocId :: DocId -> DocId
addDocId :: DocId -> DocId -> DocId
subDocId :: DocId -> DocId -> DocId
nullDocId :: DocId
firstDocId :: DocId
mkDocId :: Integer -> DocId
xpDocId :: PU DocId
instance Eq DocId
instance Ord DocId
instance Enum DocId
instance NFData DocId
instance Binary DocId
instance Show DocId


-- | DocId maps
module Holumbus.Index.Common.DocIdMap
data DocIdMap v
emptyDocIdMap :: DocIdMap v
singletonDocIdMap :: DocId -> v -> DocIdMap v
nullDocIdMap :: DocIdMap v -> Bool
memberDocIdMap :: DocId -> DocIdMap v -> Bool
lookupDocIdMap :: DocId -> DocIdMap v -> Maybe v
insertDocIdMap :: DocId -> v -> DocIdMap v -> DocIdMap v
deleteDocIdMap :: DocId -> DocIdMap v -> DocIdMap v
insertWithDocIdMap :: (v -> v -> v) -> DocId -> v -> DocIdMap v -> DocIdMap v
sizeDocIdMap :: DocIdMap v -> Int
minKeyDocIdMap :: DocIdMap v -> DocId
maxKeyDocIdMap :: DocIdMap v -> DocId
isIntervallDocIdMap :: DocIdMap v -> Bool
unionDocIdMap :: DocIdMap v -> DocIdMap v -> DocIdMap v
intersectionDocIdMap :: DocIdMap v -> DocIdMap v -> DocIdMap v
differenceDocIdMap :: DocIdMap v -> DocIdMap v -> DocIdMap v
unionWithDocIdMap :: (v -> v -> v) -> DocIdMap v -> DocIdMap v -> DocIdMap v
intersectionWithDocIdMap :: (v -> v -> v) -> DocIdMap v -> DocIdMap v -> DocIdMap v
differenceWithDocIdMap :: (v -> v -> Maybe v) -> DocIdMap v -> DocIdMap v -> DocIdMap v
unionsWithDocIdMap :: (v -> v -> v) -> [DocIdMap v] -> DocIdMap v
mapDocIdMap :: (v -> r) -> DocIdMap v -> DocIdMap r
filterDocIdMap :: (v -> Bool) -> DocIdMap v -> DocIdMap v
filterWithKeyDocIdMap :: (DocId -> v -> Bool) -> DocIdMap v -> DocIdMap v
mapWithKeyDocIdMap :: (DocId -> v -> r) -> DocIdMap v -> DocIdMap r
foldDocIdMap :: (v -> b -> b) -> b -> DocIdMap v -> b
foldWithKeyDocIdMap :: (DocId -> v -> b -> b) -> b -> DocIdMap v -> b
fromListDocIdMap :: [(DocId, v)] -> DocIdMap v
toListDocIdMap :: DocIdMap v -> [(DocId, v)]
keysDocIdMap :: DocIdMap v -> [DocId]
elemsDocIdMap :: DocIdMap v -> [v]
instance Eq v => Eq (DocIdMap v)
instance Show v => Show (DocIdMap v)
instance Foldable DocIdMap
instance Binary v => Binary (DocIdMap v)
instance NFData v => NFData (DocIdMap v)


-- | Basic data types for index
module Holumbus.Index.Common.BasicTypes

-- | The URI describing the location of the original document.
type URI = String

-- | The title of a document.
type Title = String

-- | The content of a document.
type Content = String

-- | The position of a word in the document. type Position = Int
type Position = Word32

-- | The name of a context.
type Context = String

-- | A single word.
type Word = String


-- | The Document datatype
module Holumbus.Index.Common.Document

-- | A document consists of a title and its unique identifier (URI) and a
--   customizable component
data Document a
Document :: !Title -> !URI -> !Maybe a -> Document a
title :: Document a -> !Title
uri :: Document a -> !URI
custom :: Document a -> !Maybe a
instance Show a => Show (Document a)
instance Eq a => Eq (Document a)
instance Ord a => Ord (Document a)
instance NFData a => NFData (Document a)
instance XmlPickler a => XmlPickler (Document a)
instance Binary a => Binary (Document a)


-- | The Occurences data type
module Holumbus.Index.Common.Occurences

-- | The occurrences in a number of documents. A mapping from document ids
--   to the positions in the document.
type Occurrences = DocIdMap Positions

-- | Create an empty set of positions.
emptyOccurrences :: Occurrences

-- | Create an empty set of positions.
singletonOccurrence :: DocId -> Position -> Occurrences

-- | Test on empty set of positions.
nullOccurrences :: Occurrences -> Bool

-- | Determine the number of positions in a set of occurrences.
sizeOccurrences :: Occurrences -> Int
insertOccurrence :: DocId -> Position -> Occurrences -> Occurrences
deleteOccurrence :: DocId -> Position -> Occurrences -> Occurrences
updateOccurrences :: (DocId -> DocId) -> Occurrences -> Occurrences

-- | Merge two occurrences.
mergeOccurrences :: Occurrences -> Occurrences -> Occurrences
diffOccurrences :: Occurrences -> Occurrences -> Occurrences

-- | Substract occurrences from some other occurrences.
substractOccurrences :: Occurrences -> Occurrences -> Occurrences

-- | The XML pickler for the occurrences of a word.
xpOccurrences :: PU Occurrences

-- | The positions of the word in the document.
type Positions = EnumSet Position
emptyPos :: Positions
singletonPos :: Position -> Positions
memberPos :: Position -> Positions -> Bool
toAscListPos :: Positions -> [Position]
fromListPos :: [Position] -> Positions
sizePos :: Positions -> Int
unionPos :: Positions -> Positions -> Positions
foldPos :: (Position -> r -> r) -> r -> Positions -> r

-- | The XML pickler for a set of positions.
xpPositions :: PU Positions
instance (Binary v, Enum v) => Binary (EnumSet v)
instance (NFData v, Enum v) => NFData (EnumSet v)


-- | The RawResult data type
module Holumbus.Index.Common.RawResult

-- | The raw result returned when searching the index.
type RawResult = [(Word, Occurrences)]

-- | Transform the raw result into a tree structure ordered by word.
resultByWord :: Context -> RawResult -> Map Word (Map Context Occurrences)

-- | Transform the raw result into a tree structure ordered by document.
resultByDocument :: Context -> RawResult -> DocIdMap (Map Context (Map Word Positions))


-- | Data types used in all PrefixTree modules
module Holumbus.Data.PrefixTree.Types
type Sym = Char
type Key = [Sym]


-- | A simplified version of PrefixTree for implementing sets.
--   
--   There is one important difference to the PrefixTree implementation:
--   The fields are not marked to be strict. This enables building the set
--   on the fly.
--   
--   This feature is used in fuzzy search, when an index tree is restricted
--   to a set of keys, e.g. the set of all none case significant keys
module Holumbus.Data.PrefixTree.PrefixSet

-- | Set of strings implemented as lazy prefix tree. <tt>type PrefixSet =
--   PrefixTree ()</tt> is not feasable because of the strict fields in the
--   PrefixTree definition
data PrefixSet
PSempty :: PrefixSet
PSelem :: PrefixSet -> PrefixSet
PSnext :: Sym -> PrefixSet -> PrefixSet -> PrefixSet
emptyPS :: PrefixSet
elemPS :: PrefixSet -> PrefixSet
elem0PS :: PrefixSet
nextPS :: Sym -> PrefixSet -> PrefixSet -> PrefixSet
lastPS :: Sym -> PrefixSet -> PrefixSet
nullPS :: PrefixSet -> Bool
singlePS :: Key -> PrefixSet
prefixPS :: Key -> PrefixSet
unionPS :: PrefixSet -> PrefixSet -> PrefixSet
foldPS :: (Key -> b -> b) -> b -> (Key -> Key) -> PrefixSet -> b
foldWithKeyPS :: (Key -> b -> b) -> b -> PrefixSet -> b
elemsPS :: PrefixSet -> [Key]
fuzzyCharPS :: (Sym -> [Sym]) -> PrefixSet -> PrefixSet
fuzzyCharsPS :: (Sym -> [Key]) -> PrefixSet -> PrefixSet
instance Show PrefixSet


-- | An efficient implementation of maps from strings to arbitrary values.
--   
--   Values can associated with an arbitrary byte key. Searching for keys
--   is very fast, but the prefix tree probably consumes more memory than
--   <a>Data.Map</a>. The main differences are the special
--   <a>prefixFind</a> functions, which can be used to perform prefix
--   queries. The interface is heavily borrowed from <a>Data.Map</a> and
--   <a>Data.IntMap</a>.
--   
--   Most other function names clash with <a>Prelude</a> names, therefore
--   this module is usually imported <tt>qualified</tt>, e.g.
--   
--   <pre>
--   import Holumbus.Data.PrefixTree (PrefixTree)
--   import qualified Holumbus.Data.PrefixTree as T
--   </pre>
--   
--   Many functions have a worst-case complexity of <i>O(min(n,L))</i>.
--   This means that the operation can become linear with the number of
--   elements with a maximum of <i>L</i>, the length of the key (the number
--   of bytes in the list). The functions for searching a prefix have a
--   worst-case complexity of <i>O(max(L,R))</i>. This means that the
--   operation can become linear with <i>R</i>, the number of elements
--   found for the prefix, with a minimum of <i>L</i>.
--   
--   The module exports include the internal data types, their constructors
--   and access functions for ultimate flexibility. Derived modules should
--   not export these (as shown in <a>Holumbus.Data.StrMap</a>) to provide
--   only a restricted interface.
module Holumbus.Data.PrefixTree.Core
data PrefixTree v
Empty :: PrefixTree v
Val :: v -> !PrefixTree v -> PrefixTree v
value' :: PrefixTree v -> v
tree :: PrefixTree v -> !PrefixTree v
Branch :: {-# UNPACK #-} !Sym -> !PrefixTree v -> !PrefixTree v -> PrefixTree v
sym :: PrefixTree v -> {-# UNPACK #-} !Sym
child :: PrefixTree v -> !PrefixTree v
next :: PrefixTree v -> !PrefixTree v
Leaf :: v -> PrefixTree v
value' :: PrefixTree v -> v
Last :: {-# UNPACK #-} !Sym -> !PrefixTree v -> PrefixTree v
sym :: PrefixTree v -> {-# UNPACK #-} !Sym
child :: PrefixTree v -> !PrefixTree v
LsSeq :: !Key1 -> !PrefixTree v -> PrefixTree v
syms :: PrefixTree v -> !Key1
child :: PrefixTree v -> !PrefixTree v
BrSeq :: !Key1 -> !PrefixTree v -> !PrefixTree v -> PrefixTree v
syms :: PrefixTree v -> !Key1
child :: PrefixTree v -> !PrefixTree v
next :: PrefixTree v -> !PrefixTree v
LsSeL :: !Key1 -> v -> PrefixTree v
syms :: PrefixTree v -> !Key1
value' :: PrefixTree v -> v
BrSeL :: !Key1 -> v -> !PrefixTree v -> PrefixTree v
syms :: PrefixTree v -> !Key1
value' :: PrefixTree v -> v
next :: PrefixTree v -> !PrefixTree v
BrVal :: {-# UNPACK #-} !Sym -> v -> !PrefixTree v -> PrefixTree v
sym :: PrefixTree v -> {-# UNPACK #-} !Sym
value' :: PrefixTree v -> v
next :: PrefixTree v -> !PrefixTree v
LsVal :: {-# UNPACK #-} !Sym -> v -> PrefixTree v
sym :: PrefixTree v -> {-# UNPACK #-} !Sym
value' :: PrefixTree v -> v

-- | strict list of chars with unpacked fields
--   
--   for internal use in prefix tree to optimize space efficiency
data Key1
Nil :: Key1
Cons :: {-# UNPACK #-} !Sym -> !Key1 -> Key1
(.++.) :: Key1 -> Key1 -> Key1
toKey :: Key1 -> Key
fromKey :: Key -> Key1
length1 :: Key1 -> Int
empty :: PrefixTree v
val :: v -> PrefixTree v -> PrefixTree v
branch :: Sym -> PrefixTree v -> PrefixTree v -> PrefixTree v
lsseq :: Key1 -> PrefixTree v -> PrefixTree v
brseq :: Key1 -> PrefixTree v -> PrefixTree v -> PrefixTree v
siseq :: Key1 -> PrefixTree v -> PrefixTree v
norm :: PrefixTree v -> PrefixTree v
deepNorm :: PrefixTree v -> PrefixTree v
normError :: String -> a

-- | <i>O(1)</i> Is the map empty?
null :: PrefixTree a -> Bool

-- | <i>O(1)</i> Create a map with a single element.
singleton :: Key -> a -> PrefixTree a

-- | <i>O(1)</i> Extract the value of a node (if there is one)
value :: Monad m => PrefixTree a -> m a

-- | <i>O(1)</i> Extract the value of a node or return a default value if
--   no value exists.
valueWithDefault :: a -> PrefixTree a -> a

-- | <i>O(1)</i> Extract the successors of a node
succ :: PrefixTree a -> PrefixTree a

-- | <i>O(min(n,L))</i> Find the value associated with a key. The function
--   will <tt>return</tt> the result in the monad or <tt>fail</tt> in it if
--   the key isn't in the map.
lookup :: Monad m => Key -> PrefixTree a -> m a

-- | <i>O(min(n,L))</i> Find the value associated with a key. The function
--   will <tt>return</tt> the result in the monad or <tt>fail</tt> in it if
--   the key isn't in the map.
findWithDefault :: a -> Key -> PrefixTree a -> a

-- | <i>O(min(n,L))</i> Is the key a member of the map?
member :: Key -> PrefixTree a -> Bool

-- | <i>O(min(n,L))</i> Find the value at a key. Calls error when the
--   element can not be found.
(!) :: PrefixTree a -> Key -> a

-- | <i>O(min(n,L))</i> Insert a new key and value into the map. If the key
--   is already present in the map, the associated value will be replaced
--   with the new value.
insert :: Key -> a -> PrefixTree a -> PrefixTree a

-- | <i>O(min(n,L))</i> Insert with a combining function. If the key is
--   already present in the map, the value of <tt>f new_value
--   old_value</tt> will be inserted.
insertWith :: (a -> a -> a) -> Key -> a -> PrefixTree a -> PrefixTree a

-- | <i>O(min(n,L))</i> Insert with a combining function. If the key is
--   already present in the map, the value of <tt>f key new_value
--   old_value</tt> will be inserted.
insertWithKey :: (Key -> a -> a -> a) -> Key -> a -> PrefixTree a -> PrefixTree a

-- | <i>O(min(n,L))</i> Updates a value at a given key (if that key is in
--   the trie) or deletes the element if the result of the updating
--   function is <a>Nothing</a>. If the key is not found, the trie is
--   returned unchanged.
update :: (a -> Maybe a) -> Key -> PrefixTree a -> PrefixTree a

-- | <i>O(min(n,L))</i> Updates a value at a given key (if that key is in
--   the trie) or deletes the element if the result of the updating
--   function is <a>Nothing</a>. If the key is not found, the trie is
--   returned unchanged.
updateWithKey :: (Key -> a -> Maybe a) -> Key -> PrefixTree a -> PrefixTree a

-- | <i>O(min(n,L))</i> Delete an element from the map. If no element
--   exists for the key, the map remains unchanged.
delete :: Key -> PrefixTree a -> PrefixTree a
lookupPx' :: Key -> PrefixTree a -> PrefixTree a
lookup' :: Key -> PrefixTree a -> Maybe a

-- | <i>O(max(L,R))</i> Find all values where the string is a prefix of the
--   key.
prefixFind :: Key -> PrefixTree a -> [a]

-- | <i>O(max(L,R))</i> Find all values where the string is a prefix of the
--   key and include the keys in the result.
prefixFindWithKey :: Key -> PrefixTree a -> [(Key, a)]
insert' :: (a -> a -> a) -> a -> Key -> PrefixTree a -> PrefixTree a
update' :: (a -> Maybe a) -> Key -> PrefixTree a -> PrefixTree a

-- | <i>O(n+m)</i> Left-biased union of two maps. It prefers the first map
--   when duplicate keys are encountered, i.e. (<a>union</a> ==
--   <a>unionWith</a> <a>const</a>).
union :: PrefixTree a -> PrefixTree a -> PrefixTree a

-- | <i>O(n+m)</i> Union with a combining function.
unionWith :: (a -> a -> a) -> PrefixTree a -> PrefixTree a -> PrefixTree a
union' :: (a -> a -> a) -> PrefixTree a -> PrefixTree a -> PrefixTree a

-- | <i>O(n+m)</i> Union with a combining function, including the key.
unionWithKey :: (Key -> a -> a -> a) -> PrefixTree a -> PrefixTree a -> PrefixTree a
union'' :: (Key -> a -> a -> a) -> (Key -> Key) -> PrefixTree a -> PrefixTree a -> PrefixTree a

-- | <i>(O(min(n,m))</i> Difference between two tries (based on keys).
difference :: PrefixTree a -> PrefixTree b -> PrefixTree a

-- | <i>(O(min(n,m))</i> Difference with a combining function. If the
--   combining function always returns <a>Nothing</a>, this is equal to
--   proper set difference.
differenceWith :: (a -> b -> Maybe a) -> PrefixTree a -> PrefixTree b -> PrefixTree a

-- | <i>O(min(n,m))</i> Difference with a combining function, including the
--   key. If two equal keys are encountered, the combining function is
--   applied to the key and both values. If it returns <a>Nothing</a>, the
--   element is discarded, if it returns <a>Just</a> a value, the element
--   is updated with the new value.
differenceWithKey :: (Key -> a -> b -> Maybe a) -> PrefixTree a -> PrefixTree b -> PrefixTree a
diff'' :: (Key -> a -> b -> Maybe a) -> (Key -> Key) -> PrefixTree a -> PrefixTree b -> PrefixTree a

-- | cut off all branches from a tree <tt>t2</tt> that are not part of set
--   <tt>t1</tt>
--   
--   the following laws must holds
--   
--   <tt>lookup' k' . cutPx' (singlePS k) $ t == lookup' k t</tt> for every
--   <tt>k'</tt> with <tt>k</tt> prefix of <tt>k'</tt>
--   
--   <tt>lookup' k' . cutPx' (singlePS k) $ t == Nothing</tt> for every
--   <tt>k'</tt> with <tt>k</tt> not being a prefix of <tt>k'</tt>
cutPx'' :: (PrefixTree a -> PrefixTree a) -> PrefixSet -> PrefixTree a -> PrefixTree a
cutPx' :: PrefixSet -> PrefixTree a -> PrefixTree a
cutAllPx' :: PrefixSet -> PrefixTree a -> PrefixTree a

-- | <i>O(n)</i> Map a function over all values in the prefix tree.
map :: (a -> b) -> PrefixTree a -> PrefixTree b
mapWithKey :: (Key -> a -> b) -> PrefixTree a -> PrefixTree b
map' :: (Key -> a -> b) -> (Key -> Key) -> PrefixTree a -> PrefixTree b

-- | Variant of map that works on normalized trees
mapN :: (a -> b) -> PrefixTree a -> PrefixTree b
mapWithKeyN :: (Key -> a -> b) -> PrefixTree a -> PrefixTree b
map'' :: (Key -> a -> b) -> (Key -> Key) -> PrefixTree a -> PrefixTree b

-- | Monadic map
mapM :: Monad m => (a -> m b) -> PrefixTree a -> m (PrefixTree b)

-- | Monadic mapWithKey
mapWithKeyM :: Monad m => (Key -> a -> m b) -> PrefixTree a -> m (PrefixTree b)
mapM'' :: Monad m => (Key -> a -> m b) -> (Key -> Key) -> PrefixTree a -> m (PrefixTree b)
data PrefixTreeVisitor a b
PTV :: b -> (a -> b -> b) -> (Sym -> b -> b -> b) -> (a -> b) -> (Sym -> b -> b) -> (Key1 -> b -> b) -> (Key1 -> b -> b -> b) -> (Key1 -> a -> b) -> (Key1 -> a -> b -> b) -> (Sym -> a -> b) -> (Sym -> a -> b -> b) -> PrefixTreeVisitor a b
v_empty :: PrefixTreeVisitor a b -> b
v_val :: PrefixTreeVisitor a b -> a -> b -> b
v_branch :: PrefixTreeVisitor a b -> Sym -> b -> b -> b
v_leaf :: PrefixTreeVisitor a b -> a -> b
v_last :: PrefixTreeVisitor a b -> Sym -> b -> b
v_lsseq :: PrefixTreeVisitor a b -> Key1 -> b -> b
v_brseq :: PrefixTreeVisitor a b -> Key1 -> b -> b -> b
v_lssel :: PrefixTreeVisitor a b -> Key1 -> a -> b
v_brsel :: PrefixTreeVisitor a b -> Key1 -> a -> b -> b
v_lsval :: PrefixTreeVisitor a b -> Sym -> a -> b
v_brval :: PrefixTreeVisitor a b -> Sym -> a -> b -> b
visit :: PrefixTreeVisitor a b -> PrefixTree a -> b

-- | space required by a prefix tree (logically)
--   
--   Singletons are counted as 0, all other n-ary constructors are counted
--   as n+1 (1 for the constructor and 1 for every field) cons nodes of
--   char lists are counted 2, 1 for the cons, 1 for the char for values
--   only the ref to the value is counted, not the space for the value
--   itself key chars are assumed to be unboxed
space :: PrefixTree a -> Int
keyChars :: PrefixTree a -> Int

-- | statistics about the # of different nodes in an optimized prefix tree
stat :: PrefixTree a -> PrefixTree Int

-- | <i>O(n)</i> Fold over all key/value pairs in the map.
foldWithKey :: (Key -> a -> b -> b) -> b -> PrefixTree a -> b

-- | <i>O(n)</i> Fold over all values in the map.
fold :: (a -> b -> b) -> b -> PrefixTree a -> b
fold' :: (Key -> a -> b -> b) -> b -> (Key -> Key) -> PrefixTree a -> b

-- | <i>O(n)</i> Convert into an ordinary map.
toMap :: PrefixTree a -> Map Key a

-- | <i>O(n)</i> Convert an ordinary map into a Prefix tree
fromMap :: Map Key a -> PrefixTree a

-- | <i>O(n)</i> Returns all elements as list of key value pairs,
toList :: PrefixTree a -> [(Key, a)]

-- | <i>O(n)</i> Creates a trie from a list of key/value pairs.
fromList :: [(Key, a)] -> PrefixTree a

-- | <i>O(n)</i> The number of elements.
size :: PrefixTree a -> Int

-- | <i>O(n)</i> Returns all values.
elems :: PrefixTree a -> [a]

-- | <i>O(n)</i> Returns all values.
keys :: PrefixTree a -> [Key]

-- | returns all key-value pairs in breadth first order (short words first)
--   this enables prefix search with upper bounds on the size of the result
--   set e.g. <tt> search ... &gt;&gt;&gt; toListBF &gt;&gt;&gt; take 1000
--   </tt> will give the 1000 shortest words found in the result set and
--   will ignore all long words
--   
--   toList is derived from the following code found in the net when
--   searching haskell breadth first search
--   
--   Haskell Standard Libraray Implementation
--   
--   <pre>
--   br :: Tree a -&gt; [a]
--   br t = map rootLabel $
--          concat $
--          takeWhile (not . null) $                
--          iterate (concatMap subForest) [t]
--   </pre>
toListBF :: PrefixTree v -> [(Key, v)]
rootLabel :: (Key -> Key) -> PrefixTree v -> [(Key, v)]
subForest :: (Key -> Key) -> PrefixTree v -> [(Key -> Key, PrefixTree v)]

-- | <i>O(max(L,R))</i> Find all values where the string is a prefix of the
--   key and include the keys in the result. The result list contains short
--   words first
prefixFindWithKeyBF :: Key -> PrefixTree a -> [(Key, a)]
instance Show Key1
instance Eq Key1
instance Ord Key1
instance Show v => Show (PrefixTree v)
instance Eq v => Eq (PrefixTree v)
instance Ord v => Ord (PrefixTree v)
instance Binary a => Binary (PrefixTree a)
instance NFData a => NFData (PrefixTree a)
instance Read a => Read (PrefixTree a)
instance Foldable PrefixTree
instance Functor PrefixTree


-- | Functions for fuzzy search in a prefix tree
module Holumbus.Data.PrefixTree.FuzzySearch

-- | <i>O(max(L,R))</i> Find all values where the string is a prefix of the
--   key.
prefixFindCaseWithKey :: Key -> PrefixTree a -> [(Key, a)]
prefixFindNoCaseWithKey :: Key -> PrefixTree a -> [(Key, a)]
prefixFindNoCase :: Key -> PrefixTree a -> [a]
lookupNoCase :: Key -> PrefixTree a -> [(Key, a)]

-- | <i>O(max(L,R))</i> Find all values where the string is a prefix of the
--   key. Breadth first variant, short words first in the result list
prefixFindCaseWithKeyBF :: Key -> PrefixTree a -> [(Key, a)]
prefixFindNoCaseWithKeyBF :: Key -> PrefixTree a -> [(Key, a)]
lookupNoCaseBF :: Key -> PrefixTree a -> [(Key, a)]
noCaseKeys :: Key -> PrefixSet
noLowerCaseKeys :: Key -> PrefixSet
noCasePS :: PrefixSet -> PrefixSet
noLowerCasePS :: PrefixSet -> PrefixSet
noUmlautPS :: PrefixSet -> PrefixSet


-- | Version : 0.1
--   
--   This module provides compression for streams of 32-bit words. Because
--   of some internal restriction in GHC, which makes all fixed integer
--   size equal in terms of bit-width, the algorithm tries to crunch as
--   much numbers as possible into a single 64-bit word.
--   
--   Based on the Simple9 encoding scheme from this article:
--   
--   <ul>
--   <li>Vo N. Anh, Alstair Moffat, "<i>Inverted Index Compression Using
--   Word-Aligned Binary Codes</i>", Information Retrieval, 8 (1), 2005,
--   pages 151-166</li>
--   </ul>
module Holumbus.Data.Crunch

-- | Crunching <a>Word8</a> values, defined in terms of <a>crunch64</a>.
crunch8 :: [Word8] -> [Word64]

-- | Crunching <a>Word16</a> values, defined in terms of <a>crunch64</a>.
crunch16 :: [Word16] -> [Word64]

-- | Crunching <a>Word32</a> values, defined in terms of <a>crunch64</a>.
crunch32 :: [Word32] -> [Word64]

-- | Crunch some values by encoding several values into one <a>Word64</a>.
--   The values may not exceed the upper limit of <tt>(2 ^ 60) - 1</tt>.
--   This precondition is not checked! The compression works best on small
--   values, therefore a difference encoding (like the one in
--   <a>Holumbus.Data.DiffList</a>) prior to compression pays off well.
crunch64 :: [Word64] -> [Word64]

-- | Decrunching to <a>Word8</a> values, defined in terms of
--   <a>decrunch64</a>.
decrunch8 :: [Word64] -> [Word8]

-- | Decrunching to <a>Word16</a> values, defined in terms of
--   <a>decrunch64</a>.
decrunch16 :: [Word64] -> [Word16]

-- | Decrunching to <a>Word32</a> values, defined in terms of
--   <a>decrunch64</a>.
decrunch32 :: [Word64] -> [Word32]

-- | Decrunch a list of crunched values. No checking for properly encoded
--   values is done, weird results have to be expected if calling this
--   function on a list of arbitrary values.
decrunch64 :: [Word64] -> [Word64]
instance Show Width
instance Eq Width
instance Enum Width


-- | Version : 0.1
--   
--   Providing space efficient difference encoding for lists of integers.
--   The encoded lists are compressed using <a>Holumbus.Data.Crunch</a> to
--   save even more space. For convenience, conversion functions for
--   <a>Data.IntSet</a> are provided. Only works for non-negative integers.
module Holumbus.Index.Common.DiffList

-- | A list of differences.
type DiffList = [Diff]

-- | Convert a set of integers into a list of difference encoded values.
fromPositions :: Positions -> DiffList

-- | Convert the difference encoded values to a list of integers.
toPositions :: DiffList -> Positions

-- | Convert a list of positions into a list of difference encoded values.
fromList :: [Position] -> DiffList

-- | Convert the difference encoded values to a list of integers. The
--   resulting list will be sorted in ascending order
toList :: DiffList -> [Position]

-- | Returns all differences. Used for debugging purposes.
diffs :: DiffList -> [Word32]


-- | Version : 0.1
--   
--   This module provides several specific compression mechanisms for
--   different parts of indexes. Right now, just a general compression
--   scheme for the <a>Occurrences</a> and <a>Positions</a> are provided.
module Holumbus.Index.Compression
type CompressedOccurrences = DocIdMap CompressedPositions
type CompressedPositions = DiffList

-- | Compress the occurrences by just compressing all contained positions.
deflateOcc :: Occurrences -> CompressedOccurrences

-- | Save some memory on the positions by just saving their differences and
--   compressing these.
deflatePos :: Positions -> CompressedPositions

-- | Decompressing the occurrences by just decompressing all contained
--   positions.
inflateOcc :: CompressedOccurrences -> Occurrences

-- | Convert the compressed differences back to a set of integers.
inflatePos :: CompressedPositions -> Positions


-- | Facade for prefix tree implementation
module Holumbus.Data.PrefixTree
data PrefixTree v
Empty :: PrefixTree v
Val :: v -> !PrefixTree v -> PrefixTree v
value' :: PrefixTree v -> v
tree :: PrefixTree v -> !PrefixTree v
Branch :: {-# UNPACK #-} !Sym -> !PrefixTree v -> !PrefixTree v -> PrefixTree v
sym :: PrefixTree v -> {-# UNPACK #-} !Sym
child :: PrefixTree v -> !PrefixTree v
next :: PrefixTree v -> !PrefixTree v
Leaf :: v -> PrefixTree v
value' :: PrefixTree v -> v
Last :: {-# UNPACK #-} !Sym -> !PrefixTree v -> PrefixTree v
sym :: PrefixTree v -> {-# UNPACK #-} !Sym
child :: PrefixTree v -> !PrefixTree v
LsSeq :: !Key1 -> !PrefixTree v -> PrefixTree v
syms :: PrefixTree v -> !Key1
child :: PrefixTree v -> !PrefixTree v
BrSeq :: !Key1 -> !PrefixTree v -> !PrefixTree v -> PrefixTree v
syms :: PrefixTree v -> !Key1
child :: PrefixTree v -> !PrefixTree v
next :: PrefixTree v -> !PrefixTree v
LsSeL :: !Key1 -> v -> PrefixTree v
syms :: PrefixTree v -> !Key1
value' :: PrefixTree v -> v
BrSeL :: !Key1 -> v -> !PrefixTree v -> PrefixTree v
syms :: PrefixTree v -> !Key1
value' :: PrefixTree v -> v
next :: PrefixTree v -> !PrefixTree v
BrVal :: {-# UNPACK #-} !Sym -> v -> !PrefixTree v -> PrefixTree v
sym :: PrefixTree v -> {-# UNPACK #-} !Sym
value' :: PrefixTree v -> v
next :: PrefixTree v -> !PrefixTree v
LsVal :: {-# UNPACK #-} !Sym -> v -> PrefixTree v
sym :: PrefixTree v -> {-# UNPACK #-} !Sym
value' :: PrefixTree v -> v
type Key = [Sym]

-- | <i>O(min(n,L))</i> Find the value at a key. Calls error when the
--   element can not be found.
(!) :: PrefixTree a -> Key -> a

-- | <i>O(1)</i> Extract the value of a node (if there is one)
value :: Monad m => PrefixTree a -> m a

-- | <i>O(1)</i> Extract the value of a node or return a default value if
--   no value exists.
valueWithDefault :: a -> PrefixTree a -> a

-- | <i>O(1)</i> Is the map empty?
null :: PrefixTree a -> Bool

-- | <i>O(n)</i> The number of elements.
size :: PrefixTree a -> Int

-- | <i>O(min(n,L))</i> Is the key a member of the map?
member :: Key -> PrefixTree a -> Bool

-- | <i>O(min(n,L))</i> Find the value associated with a key. The function
--   will <tt>return</tt> the result in the monad or <tt>fail</tt> in it if
--   the key isn't in the map.
lookup :: Monad m => Key -> PrefixTree a -> m a

-- | <i>O(min(n,L))</i> Find the value associated with a key. The function
--   will <tt>return</tt> the result in the monad or <tt>fail</tt> in it if
--   the key isn't in the map.
findWithDefault :: a -> Key -> PrefixTree a -> a

-- | <i>O(max(L,R))</i> Find all values where the string is a prefix of the
--   key.
prefixFind :: Key -> PrefixTree a -> [a]

-- | <i>O(max(L,R))</i> Find all values where the string is a prefix of the
--   key and include the keys in the result.
prefixFindWithKey :: Key -> PrefixTree a -> [(Key, a)]

-- | <i>O(max(L,R))</i> Find all values where the string is a prefix of the
--   key and include the keys in the result. The result list contains short
--   words first
prefixFindWithKeyBF :: Key -> PrefixTree a -> [(Key, a)]
empty :: PrefixTree v

-- | <i>O(1)</i> Create a map with a single element.
singleton :: Key -> a -> PrefixTree a

-- | <i>O(min(n,L))</i> Insert a new key and value into the map. If the key
--   is already present in the map, the associated value will be replaced
--   with the new value.
insert :: Key -> a -> PrefixTree a -> PrefixTree a

-- | <i>O(min(n,L))</i> Insert with a combining function. If the key is
--   already present in the map, the value of <tt>f new_value
--   old_value</tt> will be inserted.
insertWith :: (a -> a -> a) -> Key -> a -> PrefixTree a -> PrefixTree a

-- | <i>O(min(n,L))</i> Insert with a combining function. If the key is
--   already present in the map, the value of <tt>f key new_value
--   old_value</tt> will be inserted.
insertWithKey :: (Key -> a -> a -> a) -> Key -> a -> PrefixTree a -> PrefixTree a

-- | <i>O(min(n,L))</i> Delete an element from the map. If no element
--   exists for the key, the map remains unchanged.
delete :: Key -> PrefixTree a -> PrefixTree a

-- | <i>O(min(n,L))</i> Updates a value at a given key (if that key is in
--   the trie) or deletes the element if the result of the updating
--   function is <a>Nothing</a>. If the key is not found, the trie is
--   returned unchanged.
update :: (a -> Maybe a) -> Key -> PrefixTree a -> PrefixTree a

-- | <i>O(min(n,L))</i> Updates a value at a given key (if that key is in
--   the trie) or deletes the element if the result of the updating
--   function is <a>Nothing</a>. If the key is not found, the trie is
--   returned unchanged.
updateWithKey :: (Key -> a -> Maybe a) -> Key -> PrefixTree a -> PrefixTree a

-- | <i>O(n)</i> Map a function over all values in the prefix tree.
map :: (a -> b) -> PrefixTree a -> PrefixTree b
mapWithKey :: (Key -> a -> b) -> PrefixTree a -> PrefixTree b

-- | Monadic map
mapM :: Monad m => (a -> m b) -> PrefixTree a -> m (PrefixTree b)

-- | Monadic mapWithKey
mapWithKeyM :: Monad m => (Key -> a -> m b) -> PrefixTree a -> m (PrefixTree b)

-- | <i>O(n)</i> Fold over all values in the map.
fold :: (a -> b -> b) -> b -> PrefixTree a -> b

-- | <i>O(n)</i> Fold over all key/value pairs in the map.
foldWithKey :: (Key -> a -> b -> b) -> b -> PrefixTree a -> b

-- | <i>O(n+m)</i> Left-biased union of two maps. It prefers the first map
--   when duplicate keys are encountered, i.e. (<a>union</a> ==
--   <a>unionWith</a> <a>const</a>).
union :: PrefixTree a -> PrefixTree a -> PrefixTree a

-- | <i>O(n+m)</i> Union with a combining function.
unionWith :: (a -> a -> a) -> PrefixTree a -> PrefixTree a -> PrefixTree a

-- | <i>O(n+m)</i> Union with a combining function, including the key.
unionWithKey :: (Key -> a -> a -> a) -> PrefixTree a -> PrefixTree a -> PrefixTree a

-- | <i>(O(min(n,m))</i> Difference between two tries (based on keys).
difference :: PrefixTree a -> PrefixTree b -> PrefixTree a

-- | <i>(O(min(n,m))</i> Difference with a combining function. If the
--   combining function always returns <a>Nothing</a>, this is equal to
--   proper set difference.
differenceWith :: (a -> b -> Maybe a) -> PrefixTree a -> PrefixTree b -> PrefixTree a

-- | <i>O(min(n,m))</i> Difference with a combining function, including the
--   key. If two equal keys are encountered, the combining function is
--   applied to the key and both values. If it returns <a>Nothing</a>, the
--   element is discarded, if it returns <a>Just</a> a value, the element
--   is updated with the new value.
differenceWithKey :: (Key -> a -> b -> Maybe a) -> PrefixTree a -> PrefixTree b -> PrefixTree a

-- | <i>O(n)</i> Returns all values.
keys :: PrefixTree a -> [Key]

-- | <i>O(n)</i> Returns all values.
elems :: PrefixTree a -> [a]

-- | <i>O(n)</i> Returns all elements as list of key value pairs,
toList :: PrefixTree a -> [(Key, a)]

-- | <i>O(n)</i> Creates a trie from a list of key/value pairs.
fromList :: [(Key, a)] -> PrefixTree a

-- | returns all key-value pairs in breadth first order (short words first)
--   this enables prefix search with upper bounds on the size of the result
--   set e.g. <tt> search ... &gt;&gt;&gt; toListBF &gt;&gt;&gt; take 1000
--   </tt> will give the 1000 shortest words found in the result set and
--   will ignore all long words
--   
--   toList is derived from the following code found in the net when
--   searching haskell breadth first search
--   
--   Haskell Standard Libraray Implementation
--   
--   <pre>
--   br :: Tree a -&gt; [a]
--   br t = map rootLabel $
--          concat $
--          takeWhile (not . null) $                
--          iterate (concatMap subForest) [t]
--   </pre>
toListBF :: PrefixTree v -> [(Key, v)]

-- | <i>O(n)</i> Convert into an ordinary map.
toMap :: PrefixTree a -> Map Key a

-- | <i>O(n)</i> Convert an ordinary map into a Prefix tree
fromMap :: Map Key a -> PrefixTree a

-- | space required by a prefix tree (logically)
--   
--   Singletons are counted as 0, all other n-ary constructors are counted
--   as n+1 (1 for the constructor and 1 for every field) cons nodes of
--   char lists are counted 2, 1 for the cons, 1 for the char for values
--   only the ref to the value is counted, not the space for the value
--   itself key chars are assumed to be unboxed
space :: PrefixTree a -> Int
keyChars :: PrefixTree a -> Int

-- | <i>O(max(L,R))</i> Find all values where the string is a prefix of the
--   key.
prefixFindCaseWithKey :: Key -> PrefixTree a -> [(Key, a)]
prefixFindNoCaseWithKey :: Key -> PrefixTree a -> [(Key, a)]
prefixFindNoCase :: Key -> PrefixTree a -> [a]
lookupNoCase :: Key -> PrefixTree a -> [(Key, a)]

-- | <i>O(max(L,R))</i> Find all values where the string is a prefix of the
--   key. Breadth first variant, short words first in the result list
prefixFindCaseWithKeyBF :: Key -> PrefixTree a -> [(Key, a)]
prefixFindNoCaseWithKeyBF :: Key -> PrefixTree a -> [(Key, a)]
lookupNoCaseBF :: Key -> PrefixTree a -> [(Key, a)]

module Holumbus.Crawler.PdfToText

-- | Conversion of pdf data into plain text. The conversion is done by
--   calling an external program <tt>pdftotext</tt> (contained in linux
--   packages <tt>xpdf</tt>). IO is done via the ByteString API.
pdfToText :: String -> IO String
pdfToTextBS :: ByteString -> IO String
pdfToTextA :: IOSArrow String String
pdfResource :: MVar (FilePath, FilePath)
requestPdf :: IO (FilePath, FilePath)
releasePdf :: (FilePath, FilePath) -> IO ()


-- | Common data types shared by all index types and a unified interface
--   for all different index types. This module defines the common
--   interfaces of indexes and their document tables as well as full-text
--   caches.
module Holumbus.Index.Common

-- | This class provides a generic interface to different types of index
--   implementations.
class HolIndex i where insertPosition c w d p i = insertOccurrences c w (singletonOccurrence d p) i deletePosition c w d p i = deleteOccurrences c w (singletonOccurrence d p) i updateDocIds' f = updateDocIds (const . const $ f) fromList e = foldl (\ i (c, w, o) -> insertOccurrences c w o i) e
sizeWords :: HolIndex i => i -> Int
contexts :: HolIndex i => i -> [Context]
allWords :: HolIndex i => i -> Context -> RawResult
prefixCase :: HolIndex i => i -> Context -> String -> RawResult
prefixNoCase :: HolIndex i => i -> Context -> String -> RawResult
lookupCase :: HolIndex i => i -> Context -> String -> RawResult
lookupNoCase :: HolIndex i => i -> Context -> String -> RawResult
insertOccurrences :: HolIndex i => Context -> Word -> Occurrences -> i -> i
deleteOccurrences :: HolIndex i => Context -> Word -> Occurrences -> i -> i
insertPosition :: HolIndex i => Context -> Word -> DocId -> Position -> i -> i
deletePosition :: HolIndex i => Context -> Word -> DocId -> Position -> i -> i
mergeIndexes :: HolIndex i => i -> i -> i
substractIndexes :: HolIndex i => i -> i -> i
splitByContexts :: HolIndex i => i -> Int -> [i]
splitByDocuments :: HolIndex i => i -> Int -> [i]
splitByWords :: HolIndex i => i -> Int -> [i]
updateDocIds :: HolIndex i => (Context -> Word -> DocId -> DocId) -> i -> i
updateDocIds' :: HolIndex i => (DocId -> DocId) -> i -> i
toList :: HolIndex i => i -> [(Context, Word, Occurrences)]
fromList :: HolIndex i => i -> [(Context, Word, Occurrences)] -> i

-- | This class provides a generic interface to different monadic types of
--   index implementations.
class Monad m => HolIndexM m i where insertPositionM c w d p i = insertOccurrencesM c w (singletonOccurrence d p) i deletePositionM c w d p i = deleteOccurrencesM c w (singletonOccurrence d p) i fromListM e = foldM (\ i (c, w, o) -> insertOccurrencesM c w o i) e
sizeWordsM :: HolIndexM m i => i -> m Int
contextsM :: HolIndexM m i => i -> m [Context]
allWordsM :: HolIndexM m i => i -> Context -> m RawResult
prefixCaseM :: HolIndexM m i => i -> Context -> String -> m RawResult
prefixNoCaseM :: HolIndexM m i => i -> Context -> String -> m RawResult
lookupCaseM :: HolIndexM m i => i -> Context -> String -> m RawResult
lookupNoCaseM :: HolIndexM m i => i -> Context -> String -> m RawResult
insertOccurrencesM :: HolIndexM m i => Context -> Word -> Occurrences -> i -> m i
deleteOccurrencesM :: HolIndexM m i => Context -> Word -> Occurrences -> i -> m i
insertPositionM :: HolIndexM m i => Context -> Word -> DocId -> Position -> i -> m i
deletePositionM :: HolIndexM m i => Context -> Word -> DocId -> Position -> i -> m i
mergeIndexesM :: HolIndexM m i => i -> i -> m i
updateDocIdsM :: HolIndexM m i => (Context -> Word -> DocId -> DocId) -> i -> m i
updateDocIdsM' :: HolIndexM m i => (DocId -> DocId) -> i -> m i
toListM :: HolIndexM m i => i -> m [(Context, Word, Occurrences)]
fromListM :: HolIndexM m i => i -> [(Context, Word, Occurrences)] -> m i
class HolDocuments d a where nullDocs = (== 0) . sizeDocs unionDocs dt1 = foldDocIdMap addDoc dt1 . toMap where addDoc d dt = snd . insertDoc dt $ d removeByURI ds u = maybe ds (removeById ds) (lookupByURI ds u) editDocIds f = fromMap . foldWithKeyDocIdMap (insertDocIdMap . f) emptyDocIdMap . toMap
nullDocs :: HolDocuments d a => d a -> Bool
sizeDocs :: HolDocuments d a => d a -> Int
lookupById :: (HolDocuments d a, Monad m) => d a -> DocId -> m (Document a)
lookupByURI :: (HolDocuments d a, Monad m) => d a -> URI -> m DocId
unionDocs :: HolDocuments d a => d a -> d a -> d a
disjointDocs :: HolDocuments d a => d a -> d a -> Bool
makeEmpty :: HolDocuments d a => d a -> d a
insertDoc :: HolDocuments d a => d a -> (Document a) -> (DocId, d a)
updateDoc :: HolDocuments d a => d a -> DocId -> (Document a) -> d a
removeById :: HolDocuments d a => d a -> DocId -> d a
removeByURI :: HolDocuments d a => d a -> URI -> d a
updateDocuments :: HolDocuments d a => (Document a -> Document a) -> d a -> d a
filterDocuments :: HolDocuments d a => (Document a -> Bool) -> d a -> d a
fromMap :: HolDocuments d a => DocIdMap (Document a) -> d a
toMap :: HolDocuments d a => d a -> DocIdMap (Document a)
editDocIds :: HolDocuments d a => (DocId -> DocId) -> d a -> d a
class (HolDocuments d a, HolIndex i) => HolDocIndex d a i where defragmentDocIndex = (,)
unionDocIndex :: HolDocIndex d a i => d a -> i -> d a -> i -> (d a, i)
defragmentDocIndex :: HolDocIndex d a i => d a -> i -> (d a, i)
class HolCache c
getDocText :: HolCache c => c -> Context -> DocId -> IO (Maybe Content)
putDocText :: HolCache c => c -> Context -> DocId -> Content -> IO ()
mergeCaches :: HolCache c => c -> c -> IO c
instance HolIndex i => HolIndexM IO i


-- | A more space efficient substitute for Holumbus.Index.Documents
module Holumbus.Index.CompactDocuments
data Documents a
Documents :: !DocMap a -> !URIMap -> !DocId -> Documents a

-- | A mapping from a document id to the document itself.
idToDoc :: Documents a -> !DocMap a

-- | A space efficient mapping from the URI of a document to its id.
docToId :: Documents a -> !URIMap

-- | The last used document id.
lastDocId :: Documents a -> !DocId
newtype CompressedDoc a
CDoc :: ByteString -> CompressedDoc a
unCDoc :: CompressedDoc a -> ByteString
type DocMap a = DocIdMap (CompressedDoc a)

-- | The table which is used to map a document to an artificial id and vice
--   versa.
type URIMap = PrefixTree DocId

-- | Create an empty table.
emptyDocuments :: Documents a

-- | Create a document table containing a single document.
singleton :: Binary a => Document a -> Documents a

-- | Simplify a document table by transforming the custom information into
--   a string.
simplify :: (Binary a, Show a) => Documents a -> Documents String
toDocument :: Binary a => CompressedDoc a -> Document a
fromDocument :: Binary a => Document a -> CompressedDoc a
fromDocMap :: Binary a => DocMap a -> DocIdMap (Document a)
toDocMap :: Binary a => DocIdMap (Document a) -> DocMap a
instance Eq (CompressedDoc a)
instance Show (CompressedDoc a)
instance Show (Documents a)
instance NFData (CompressedDoc a)
instance Binary a => Binary (CompressedDoc a)
instance (Binary a, XmlPickler a) => XmlPickler (CompressedDoc a)
instance Binary a => Binary (Documents a)
instance (Binary a, XmlPickler a) => XmlPickler (Documents a)
instance NFData a => NFData (Documents a)
instance Eq a => Eq (Documents a)
instance Binary a => HolDocuments Documents a
instance (Binary a, HolIndex i) => HolDocIndex Documents a i


-- | A simple version of Holumbus.Index.Documents. This implementation is
--   only for reading a document table in the search part of an
--   application. The mapping of URIs to DocIds is only required during
--   index building, not when accessing the index. So this 2. mapping is
--   removed in this implementation for saving space
module Holumbus.Index.CompactSmallDocuments

-- | The table to store the document descriptions
--   
--   This table does not contain the reverse map from URIs do DocIds, this
--   reverse map is only needed when crawling, not for searching the index.
--   As a consequence, most of the indes operations are not implemented
--   
--   see also <a>Documents</a> data type
newtype SmallDocuments a
SmallDocuments :: DocMap a -> SmallDocuments a

-- | A mapping from a doc id to the document itself.
idToSmallDoc :: SmallDocuments a -> DocMap a

-- | Create an empty table.
emptyDocuments :: SmallDocuments a

-- | Create a document table containing a single document.
singleton :: Binary a => Document a -> SmallDocuments a

-- | Convert a Compact document table into a small compact document table.
--   Called at the end of building an index
docTable2smallDocTable :: Documents a -> SmallDocuments a
instance Binary a => Binary (SmallDocuments a)
instance (Binary a, XmlPickler a) => XmlPickler (SmallDocuments a)
instance NFData a => NFData (SmallDocuments a)
instance Binary a => HolDocuments SmallDocuments a
instance (Binary a, HolIndex i) => HolDocIndex SmallDocuments a i

module Holumbus.Index.Inverted.CompressedPrefixMem

-- | The index consists of a table which maps documents to ids and a number
--   of index parts.
newtype Inverted occ
Inverted :: Parts occ -> Inverted occ

-- | The parts of the index, each representing one context.
unInverted :: Inverted occ -> Parts occ

-- | The index parts are identified by a name, which should denote the
--   context of the words.
type Parts occ = Map Context (Part occ)

-- | The index part is the real inverted index. Words are mapped to their
--   occurrences. The part is implemented as a prefix tree
type Part occ = PrefixTree occ

-- | The pure inverted index implemented as a prefix tree without any space
--   optimizations. This may be taken as a reference for space and time
--   measurements for the other index structures
type Inverted0 = Inverted Occ0

-- | The inverted index with simple-9 encoding of the occurence sets
type InvertedCompressed = Inverted OccCompressed

-- | The inverted index with serialized occurence maps with simple-9
--   encoded sets
type InvertedSerialized = Inverted OccSerialized

-- | The inverted index with serialized occurence maps with simple-9
--   encoded sets and with the serialized bytestrings compressed with bzip2
type InvertedCSerialized = Inverted OccCSerialized

-- | The pure inverted index with serialized occurence maps and with the
--   serialized bytestrings compressed with bzip2, no simple-9 encoding.
--   This is the most space efficient index of the 5 variants, even a few
--   percent smaller then InvertedCSerialized, and a few percent faster in
--   lookup
type InvertedOSerialized = Inverted OccOSerialized
class ComprOccurrences s
toOccurrences :: ComprOccurrences s => s -> Occurrences
fromOccurrences :: ComprOccurrences s => Occurrences -> s
emptyInverted0 :: Inverted0
emptyInvertedCompressed :: InvertedCompressed
emptyInvertedSerialized :: InvertedSerialized
emptyInvertedCSerialized :: InvertedCSerialized
emptyInvertedOSerialized :: InvertedOSerialized
class Sizeof a
sizeof :: Sizeof a => a -> Int64
sizeofAttrsInverted :: Sizeof i => Inverted i -> Int64
mapOcc :: ComprOccurrences s => (Occurrences -> Occurrences) -> s -> s
zipOcc :: ComprOccurrences s => (Occurrences -> Occurrences -> Occurrences) -> s -> s -> s
emptyOcc :: ComprOccurrences s => s
theOcc :: ComprOccurrences s => s -> Occurrences
nullOcc :: ComprOccurrences s => s -> Bool
unionOcc :: ComprOccurrences s => Occurrences -> s -> s
diffOcc :: ComprOccurrences s => Occurrences -> s -> s
insertPosOcc :: ComprOccurrences s => DocId -> Position -> s -> s
deletePosOcc :: ComprOccurrences s => DocId -> Position -> s -> s
updateDocIdOcc :: ComprOccurrences s => (DocId -> DocId) -> s -> s
deleteDocIds :: ComprOccurrences s => Occurrences -> s -> s

-- | Remove DocIds from index
removeDocIdsInverted :: ComprOccurrences i => Occurrences -> Inverted i -> Inverted i
instance Eq ByteString
instance Show ByteString
instance Eq OccCompressed
instance Show OccCompressed
instance Eq OccSerialized
instance Show OccSerialized
instance Eq OccCSerialized
instance Show OccCSerialized
instance Eq OccOSerialized
instance Show OccOSerialized
instance Show occ => Show (Inverted occ)
instance Eq occ => Eq (Inverted occ)
instance (Binary occ, ComprOccurrences occ) => HolIndex (Inverted occ)
instance Binary occ => Binary (Inverted occ)
instance ComprOccurrences occ => XmlPickler (Inverted occ)
instance NFData occ => NFData (Inverted occ)
instance Sizeof OccOSerialized
instance Binary OccOSerialized
instance NFData OccOSerialized
instance ComprOccurrences OccOSerialized
instance Sizeof OccCSerialized
instance Binary OccCSerialized
instance NFData OccCSerialized
instance ComprOccurrences OccCSerialized
instance Sizeof OccSerialized
instance Binary OccSerialized
instance NFData OccSerialized
instance ComprOccurrences OccSerialized
instance Sizeof OccCompressed
instance Binary OccCompressed
instance NFData OccCompressed
instance ComprOccurrences OccCompressed
instance Sizeof Occ0
instance Binary Occ0
instance NFData Occ0
instance ComprOccurrences Occ0
instance Sizeof ByteString
instance Binary ByteString
instance NFData ByteString


-- | A more space efficient substitute for Holumbus.Index.Documents and a
--   more flexible implementation than Holumbus.Index.CompactDocuments.
--   
--   DocIds are computed by a hash function, so the inverse map from URIs
--   to DocIds is substituted by the hash function
module Holumbus.Index.HashedDocuments
newtype Documents a

-- | A mapping from a document id to the document itself.
Documents :: DocMap a -> Documents a
idToDoc :: Documents a -> DocMap a
newtype CompressedDoc a
CDoc :: ByteString -> CompressedDoc a
unCDoc :: CompressedDoc a -> ByteString

-- | The table which is used to map a document to an artificial id and vice
--   versa.
type DocMap a = DocIdMap (CompressedDoc a)

-- | Create an empty table.
emptyDocuments :: Documents a

-- | Create a document table containing a single document.
singleton :: Binary a => Document a -> Documents a
toDocument :: Binary a => CompressedDoc a -> Document a
fromDocument :: Binary a => Document a -> CompressedDoc a
fromDocMap :: Binary a => DocMap a -> DocIdMap (Document a)
toDocMap :: Binary a => DocIdMap (Document a) -> DocMap a
instance Eq (CompressedDoc a)
instance Show (CompressedDoc a)
instance Eq (Documents a)
instance Show (Documents a)
instance NFData (Documents a)
instance NFData (CompressedDoc a)
instance Binary a => Binary (CompressedDoc a)
instance (Binary a, XmlPickler a) => XmlPickler (CompressedDoc a)
instance Binary a => Binary (Documents a)
instance (Binary a, XmlPickler a) => XmlPickler (Documents a)
instance Binary a => HolDocuments Documents a
instance (Binary a, HolIndex i) => HolDocIndex Documents a i


-- | A variant of the Inverted.Memory index with an optimized prefix tree
--   instead of a trie as central data structure. This version should be
--   more space efficient as the trie and more runtime efficient when
--   combining whole indexes.
--   
--   For switching from Memory to this module, only the import has to be
--   modified
module Holumbus.Index.Inverted.PrefixMem

-- | The index consists of a table which maps documents to ids and a number
--   of index parts.
newtype Inverted
Inverted :: Parts -> Inverted
indexParts :: Inverted -> Parts

-- | The index parts are identified by a name, which should denote the
--   context of the words.
type Parts = Map Context Part

-- | The index part is the real inverted index. Words are mapped to their
--   occurrences.
type Part = PrefixTree CompressedOccurrences

-- | Create an index with just one word in one context.
singleton :: Context -> String -> Occurrences -> Inverted

-- | Create an empty index.
emptyInverted :: Inverted
instance Show Inverted
instance Eq Inverted
instance Binary Inverted
instance XmlPickler Inverted
instance NFData Inverted
instance HolIndex Inverted


-- | The data type for results of Holumbus queries.
--   
--   The result of a query is defined in terms of two partial results, the
--   documents containing the search terms and the words which are possible
--   completions of the serach terms.
module Holumbus.Query.Result

-- | The combined result type for Holumbus queries.
data Result a
Result :: (DocHits a) -> WordHits -> Result a

-- | The documents matching the query.
docHits :: Result a -> (DocHits a)

-- | The words which are completions of the query terms.
wordHits :: Result a -> WordHits

-- | A mapping from a document to it's score and the contexts where it was
--   found.
type DocHits a = DocIdMap (DocInfo a, DocContextHits)

-- | A mapping from a context to the words of the document that were found
--   in this context.
type DocContextHits = Map Context DocWordHits

-- | A mapping from a word of the document in a specific context to it's
--   positions.
type DocWordHits = Map Word Positions

-- | A mapping from a word to it's score and the contexts where it was
--   found.
type WordHits = Map Word (WordInfo, WordContextHits)

-- | A mapping from a context to the documents that contain the word that
--   were found in this context.
type WordContextHits = Map Context WordDocHits

-- | A mapping from a document containing the word to the positions of the
--   word.
type WordDocHits = Occurrences

-- | Information about an document.
data DocInfo a
DocInfo :: (Document a) -> Score -> DocInfo a

-- | The document itself.
document :: DocInfo a -> (Document a)

-- | The score for the document (initial score for all documents is
--   <tt>0.0</tt>).
docScore :: DocInfo a -> Score

-- | Information about a word.
data WordInfo
WordInfo :: Terms -> Score -> WordInfo

-- | The search terms that led to this very word.
terms :: WordInfo -> Terms

-- | The frequency of the word in the document for a context.
wordScore :: WordInfo -> Score

-- | The score of a hit (either a document hit or a word hit).
type Score = Float

-- | Create an empty result.
emptyResult :: Result a

-- | Test if the result contains anything.
null :: Result a -> Bool

-- | Query the number of documents in a result.
sizeDocHits :: Result a -> Int

-- | Query the number of documents in a result.
sizeWordHits :: Result a -> Int

-- | Query the maximum score of the documents.
maxScoreDocHits :: Result a -> Score

-- | Query the maximum score of the words.
maxScoreWordHits :: Result a -> Score

-- | Extract all documents from a result
getDocuments :: Result a -> [Document a]

-- | Set the score in a document info.
setDocScore :: Score -> DocInfo a -> DocInfo a

-- | Set the score in a word info.
setWordScore :: Score -> WordInfo -> WordInfo

-- | The XML pickler for the document hits. Will be sorted by score.
xpDocHits :: XmlPickler a => PU (DocHits a)

-- | The XML pickler for the word hits. Will be sorted alphabetically by
--   the words.
xpWordHits :: PU WordHits
instance Eq a => Eq (DocInfo a)
instance Show a => Show (DocInfo a)
instance Eq WordInfo
instance Show WordInfo
instance Eq a => Eq (Result a)
instance Show a => Show (Result a)
instance XmlPickler WordInfo
instance XmlPickler a => XmlPickler (DocInfo a)
instance XmlPickler a => XmlPickler (Result a)
instance NFData WordInfo
instance NFData a => NFData (DocInfo a)
instance NFData a => NFData (Result a)
instance Binary WordInfo
instance Binary a => Binary (DocInfo a)
instance Binary a => Binary (Result a)


-- | Version : 0.3
--   
--   The data type for intermediate results occuring during query
--   processing.
module Holumbus.Query.Intermediate

-- | The intermediate result used during query processing.
type Intermediate = DocIdMap IntermediateContexts

-- | Create an empty intermediate result.
emptyIntermediate :: Intermediate

-- | Check if the intermediate result is empty.
null :: Intermediate -> Bool

-- | Returns the number of documents in the intermediate result.
sizeIntermediate :: Intermediate -> Int

-- | Union two sets of intermediate results.
union :: Intermediate -> Intermediate -> Intermediate

-- | Substract two sets of intermediate results.
difference :: Intermediate -> Intermediate -> Intermediate

-- | Intersect two sets of intermediate results.
intersection :: Intermediate -> Intermediate -> Intermediate

-- | Merges a bunch of intermediate results into one intermediate result by
--   unioning them.
unions :: [Intermediate] -> Intermediate

-- | Create an intermediate result from a list of words and their
--   occurrences.
fromList :: Word -> Context -> RawResult -> Intermediate

-- | Convert to a <tt>Result</tt> by generating the <a>WordHits</a>
--   structure.
toResult :: HolDocuments d c => d c -> Intermediate -> Result c


-- | Version : 0.2
--   
--   The Holumbus query language definition.
--   
--   The specific syntax of any query language can be designed
--   independently by creating appropriate parsers. Also see
--   <a>Holumbus.Query.Language.Parser</a>.
module Holumbus.Query.Language.Grammar

-- | The query language.
data Query

-- | Single case-insensitive word.
Word :: String -> Query

-- | Single case-insensitive phrase.
Phrase :: String -> Query

-- | Single case-sensitive word.
CaseWord :: String -> Query

-- | Single case-sensitive phrase.
CasePhrase :: String -> Query

-- | Single fuzzy word.
FuzzyWord :: String -> Query

-- | Restrict query to a list of contexts.
Specifier :: [Context] -> Query -> Query

-- | Negate the query.
Negation :: Query -> Query

-- | Combine two queries through a binary operation.
BinQuery :: BinOp -> Query -> Query -> Query

-- | A binary operation.
data BinOp

-- | Intersect two queries.
And :: BinOp

-- | Union two queries.
Or :: BinOp

-- | Filter a query by another, <tt>q1 BUT q2</tt> is equivalent to <tt>q1
--   AND NOT q2</tt>.
But :: BinOp

-- | Transforms all <tt>(BinQuery And q1 q2)</tt> where one of <tt>q1</tt>
--   or <tt>q2</tt> is a <tt>Negation</tt> into <tt>BinQuery Filter q1
--   q2</tt> or <tt>BinQuery Filter q2 q1</tt> respectively.
optimize :: Query -> Query

-- | Check if the query arguments comply with some custom predicate.
checkWith :: (String -> Bool) -> Query -> Bool

-- | Returns a list of all terms in the query.
extractTerms :: Query -> [String]
instance Eq BinOp
instance Show BinOp
instance Eq Query
instance Show Query
instance Binary BinOp
instance Binary Query


-- | Version : 0.2
--   
--   The Holumbus query parser, based on the famous Parsec library.
--   
--   The parser implements a default syntax for the query grammar which
--   exposes all possible query types and operators to the user.
module Holumbus.Query.Language.Parser

-- | Parse a query using the default syntax provided by the Holumbus
--   framework.
parseQuery :: String -> Either String Query


-- | The Holumbus query processor. Supports exact word or phrase queries as
--   well as fuzzy word and case-insensitive word and phrase queries.
--   Boolean operators like AND, OR and NOT are supported. Context
--   specifiers and priorities are supported, too.
module Holumbus.Query.Processor

-- | The configuration for the query processor.
data ProcessConfig
ProcessConfig :: !FuzzyConfig -> !Bool -> !Int -> !Int -> ProcessConfig

-- | The configuration for fuzzy queries.
fuzzyConfig :: ProcessConfig -> !FuzzyConfig

-- | Optimize the query before processing.
optimizeQuery :: ProcessConfig -> !Bool

-- | The maximum number of words used from a prefix. Zero switches off
--   limiting.
wordLimit :: ProcessConfig -> !Int

-- | The maximum number of documents taken into account. Zero switches off
--   limiting.
docLimit :: ProcessConfig -> !Int

-- | Process a query on a specific index with regard to the configuration.
processQuery :: (HolIndex i, HolDocuments d c) => ProcessConfig -> i -> d c -> Query -> Result c

-- | Process a query only partially in terms of a distributed index. Only
--   the intermediate result will be returned.
processPartial :: HolIndex i => ProcessConfig -> i -> Int -> Query -> Intermediate

-- | Monadic version of <a>processQuery</a>.
processQueryM :: (HolIndexM m i, HolDocuments d c) => ProcessConfig -> i -> d c -> Query -> m (Result c)

-- | Monadic version of <a>processPartial</a>.
processPartialM :: HolIndexM m i => ProcessConfig -> i -> Int -> Query -> m Intermediate
instance Binary ProcessConfig


-- | Version : 0.3
--   
--   The ranking mechanism for Holumbus.
--   
--   Customized ranking functions for both documents and suggested words
--   can be provided by the user. Some predefined ranking functions are
--   avaliable, too.
module Holumbus.Query.Ranking

-- | The configuration of the ranking mechanism.
data RankConfig a
RankConfig :: DocRanking a -> WordRanking -> RankConfig a

-- | A function to determine the score of a document.
docRanking :: RankConfig a -> DocRanking a

-- | A funciton to determine the score of a word.
wordRanking :: RankConfig a -> WordRanking

-- | The signature of a function to determine the score of a document.
type DocRanking a = DocId -> DocInfo a -> DocContextHits -> Score

-- | The signature of a function to determine the score of a word.
type WordRanking = Word -> WordInfo -> WordContextHits -> Score

-- | Rank the result with custom ranking functions.
rank :: RankConfig a -> Result a -> Result a

-- | Rank documents by count.
docRankByCount :: DocId -> DocInfo a -> DocContextHits -> Score

-- | Rank documents by context-weighted count. The weights will be
--   normalized to a maximum of 1.0. Contexts with no weight (or a weight
--   of zero) will be ignored.
docRankWeightedByCount :: [(Context, Score)] -> DocId -> DocInfo a -> DocContextHits -> Score

-- | Rank words by count.
wordRankByCount :: Word -> WordInfo -> WordContextHits -> Score

-- | Rank words by context-weighted count. The weights will be normalized
--   to a maximum of 1.0. Contexts with no weight (or a weight of zero)
--   will be ignored.
wordRankWeightedByCount :: [(Context, Score)] -> Word -> WordInfo -> WordContextHits -> Score

module Holumbus.Crawler.XmlArrows

-- | Remove contents, when document status isn't ok, but remain meta info
checkDocumentStatus :: IOSArrow XmlTree XmlTree

module Holumbus.Crawler.Util

-- | create temp file name
mkTmpFile :: Int -> String -> Int -> String

-- | Simple predicate genertor for filtering of URIs If the first predicate
--   (isAllowed) holds and the second (isDenied) does not hold the
--   predicate holds. This can be used for constructing simple URL filters
simpleFollowRef :: (String -> Bool) -> (String -> Bool) -> (String -> Bool)

-- | A convenient function, that takes two lists of strings in regexp
--   syntax, The first list are the patterns for the allowed strings, the
--   second one for the patterns to deny the string. Two regular
--   expressions are build from these lists of strings, and the string to
--   be tested is matched against both regexes
simpleFollowRef' :: [String] -> [String] -> (String -> Bool)
match :: String -> String -> Bool
sed :: (String -> String) -> String -> String -> String
split :: String -> String -> (String, String)
tokenize :: String -> String -> [String]
parseRE :: String -> Regex

module Holumbus.Crawler.URIs

-- | An URI is represented as a String
type URI = String
type URIWithLevel = (URI, Int)

-- | A set of URIs implemeted as a prefix tree. This implementation is
--   space efficient, because of many equal prefixes in the crawled set of
--   URIs
type URIs = URIs' ()
type URIsWithLevel = URIs' Int
type URIs' a = PrefixTree a
emptyURIs :: URIs' a
singletonURIs :: URI -> URIs
singletonURIs' :: URI -> a -> URIs' a
nullURIs :: URIs' a -> Bool
memberURIs :: URI -> URIs' a -> Bool
cardURIs :: URIs' a -> Int
nextURI :: URIs' a -> (URI, a)
nextURIs :: Int -> URIs' a -> [(URI, a)]
insertURI :: URI -> URIs -> URIs
insertURI' :: URI -> a -> URIs' a -> URIs' a
deleteURI :: URI -> URIs' a -> URIs' a
deleteURIs :: URIs' b -> URIs' a -> URIs' a
unionURIs :: URIs -> URIs -> URIs
unionURIs' :: (a -> a -> a) -> URIs' a -> URIs' a -> URIs' a
diffURIs :: URIs' a -> URIs' a -> URIs' a
fromListURIs :: [URI] -> URIs
fromListURIs' :: [(URI, a)] -> URIs' a
toListURIs :: URIs' a -> [URI]
toListURIs' :: URIs' a -> [(URI, a)]
foldURIs :: (URI -> b -> b) -> b -> URIs -> b
foldURIs' :: (URI -> a -> b -> b) -> b -> URIs' a -> b

module Holumbus.Crawler.RobotTypes
type Robots = Map URI RobotRestriction
type RobotRestriction = [RobotSpec]
type RobotSpec = (URI, RobotAction)
data RobotAction
Disallow :: RobotAction
Allow :: RobotAction
type AddRobotsAction = URI -> Robots -> IO Robots
xpRobots :: PU Robots
xpRobotRestriction :: PU RobotRestriction
emptyRobots :: Robots
robotsExtend :: String -> AddRobotsAction
robotsIndex :: URI -> Robots -> Bool
robotsFollow :: URI -> Robots -> Bool
robotsNo :: String -> LA XmlTree XmlTree

-- | robots no index filter. This filter checks HTML documents for a
--   &lt;meta name="robots" content="noindex"&gt; in the head of the
--   document
robotsNoIndex :: ArrowXml a => a XmlTree XmlTree

-- | robots no follow filter. This filter checks HTML documents for a
--   &lt;meta name="robots" content="nofollow"&gt; in the head of the
--   document
robotsNoFollow :: ArrowXml a => a XmlTree XmlTree
instance Eq RobotAction
instance Show RobotAction
instance Read RobotAction
instance Enum RobotAction
instance XmlPickler RobotAction
instance NFData RobotAction
instance Binary RobotAction

module Holumbus.Crawler.Logger
hxtLoggerName :: String
hxtSetTraceAndErrorLogger :: Priority -> IOStateArrow s b b
hxtSetLogLevel :: Priority -> IOStateArrow s b b
hxtSetErrorLog :: IOStateArrow s b b

-- | Set trace level in config
logC :: MonadIO m => String -> Priority -> [String] -> m ()
noticeC, errC, warnC, debugC, infoC :: MonadIO m => String -> [String] -> m ()
setLogLevel :: MonadIO m => String -> Priority -> m ()

module Holumbus.Crawler.Constants
defaultCrawlerName :: String
curl_user_agent :: String
curl_max_time :: String
curl_connect_timeout :: String
curl_max_filesize :: String
curl_location :: String
curl_max_redirects :: String
http_location :: String
http_last_modified :: String


-- | A map-fold function for interleaved map and fold. The elements of a
--   list are processed like in a binary tree.
module Control.Sequential.MapFoldBinary

-- | Pure version of binary map fold
--   
--   <tt>mapFoldBinary id (+) [1..8]</tt> adds the elements of a list in
--   the following order: <tt>(((1+2)+(3+4))+((5+6)+(7+8)))</tt>
mapFoldBinary :: (a -> b) -> (b -> b -> b) -> [a] -> b

-- | Monadic version of a binary map fold
--   
--   The elements of a list are mapped and folded in the same way as in the
--   pure version. The map and fold operations are interleaved. In the
--   above example the expressions are evaluated from left to right,
--   folding is performed, as early as possible.
mapFoldBinaryM :: Monad m => (a -> m b) -> (b -> b -> m b) -> [a] -> m b

module Control.Monad.ReaderStateIO

-- | reader state io monad implemented directly without any monad
--   transformers
newtype ReaderStateIO env state res
RSIO :: (env -> state -> IO (res, state)) -> ReaderStateIO env state res
modifyIO :: (state -> IO state) -> ReaderStateIO env state ()
runReaderStateIO :: ReaderStateIO env state res -> env -> state -> IO (res, state)
instance MonadReader env (ReaderStateIO env state)
instance MonadState state (ReaderStateIO env state)
instance MonadIO (ReaderStateIO env state)
instance Monad (ReaderStateIO env state)

module Holumbus.Crawler.Types

-- | The action to combine the result of a single document with the
--   accumulator for the overall crawler result. This combining function
--   runs in the IO monad to enable storing parts of the result externally
--   but it is not a CrawlerAction, else parallel crawling with forkIO is
--   not longer applicable
type AccumulateDocResult a r = (URI, a) -> r -> IO r

-- | The folding operator for merging partial results when working with
--   mapFold and parallel crawling
type MergeDocResults r = r -> r -> IO r

-- | The operator for saving intermediate results
type SavePartialResults r = FilePath -> r -> IO r

-- | The extractor function for a single document
type ProcessDocument a = IOSArrow XmlTree a

-- | The crawler action monad
type CrawlerAction a r = ReaderStateIO (CrawlerConfig a r) (CrawlerState r)

-- | The crawler configuration record
data CrawlerConfig a r
CrawlerConfig :: SysConfig -> IOSArrow XmlTree XmlTree -> IOSArrow XmlTree URI -> IOSArrow XmlTree XmlTree -> ProcessDocument a -> AccumulateDocResult a r -> MergeDocResults r -> (URI -> Bool) -> (CrawlerConfig a r -> AddRobotsAction) -> !Int -> !Int -> !Int -> !Int -> !Int -> !String -> (FilePath -> CrawlerAction a r ()) -> !Priority -> !Priority -> CrawlerConfig a r
cc_sysConfig :: CrawlerConfig a r -> SysConfig
cc_preRefsFilter :: CrawlerConfig a r -> IOSArrow XmlTree XmlTree
cc_processRefs :: CrawlerConfig a r -> IOSArrow XmlTree URI
cc_preDocFilter :: CrawlerConfig a r -> IOSArrow XmlTree XmlTree
cc_processDoc :: CrawlerConfig a r -> ProcessDocument a
cc_accumulate :: CrawlerConfig a r -> AccumulateDocResult a r
cc_fold :: CrawlerConfig a r -> MergeDocResults r
cc_followRef :: CrawlerConfig a r -> URI -> Bool
cc_addRobotsTxt :: CrawlerConfig a r -> CrawlerConfig a r -> AddRobotsAction
cc_clickLevel :: CrawlerConfig a r -> !Int
cc_maxNoOfDocs :: CrawlerConfig a r -> !Int
cc_maxParDocs :: CrawlerConfig a r -> !Int
cc_maxParThreads :: CrawlerConfig a r -> !Int
cc_saveIntervall :: CrawlerConfig a r -> !Int
cc_savePathPrefix :: CrawlerConfig a r -> !String
cc_savePreAction :: CrawlerConfig a r -> FilePath -> CrawlerAction a r ()
cc_traceLevel :: CrawlerConfig a r -> !Priority
cc_traceLevelHxt :: CrawlerConfig a r -> !Priority

-- | The crawler state record
data CrawlerState r
CrawlerState :: !URIsWithLevel -> !URIs -> !Robots -> !Int -> !Int -> ![Int] -> !r -> !r -> CrawlerState r
cs_toBeProcessed :: CrawlerState r -> !URIsWithLevel
cs_alreadyProcessed :: CrawlerState r -> !URIs
cs_robots :: CrawlerState r -> !Robots
cs_noOfDocs :: CrawlerState r -> !Int
cs_noOfDocsSaved :: CrawlerState r -> !Int
cs_listOfDocsSaved :: CrawlerState r -> ![Int]
cs_resultAccu :: CrawlerState r -> !r
cs_resultInit :: CrawlerState r -> !r

-- | selector functions for CrawlerState
theToBeProcessed :: Selector (CrawlerState r) URIsWithLevel
theAlreadyProcessed :: Selector (CrawlerState r) URIs
theRobots :: Selector (CrawlerState r) Robots
theNoOfDocs :: Selector (CrawlerState r) Int
theNoOfDocsSaved :: Selector (CrawlerState r) Int
theListOfDocsSaved :: Selector (CrawlerState r) [Int]
theResultAccu :: Selector (CrawlerState r) r
theResultInit :: Selector (CrawlerState r) r

-- | selector functions for CrawlerConfig
theSysConfig :: Selector (CrawlerConfig a r) SysConfig
theTraceLevel :: Selector (CrawlerConfig a r) Priority
theTraceLevelHxt :: Selector (CrawlerConfig a r) Priority
theClickLevel :: Selector (CrawlerConfig a r) Int
theMaxNoOfDocs :: Selector (CrawlerConfig a r) Int
theMaxParDocs :: Selector (CrawlerConfig a r) Int
theMaxParThreads :: Selector (CrawlerConfig a r) Int
theSaveIntervall :: Selector (CrawlerConfig a r) Int
theSavePathPrefix :: Selector (CrawlerConfig a r) String
theSavePreAction :: Selector (CrawlerConfig a r) (FilePath -> CrawlerAction a r ())
theFollowRef :: Selector (CrawlerConfig a r) (URI -> Bool)
theAddRobotsAction :: Selector (CrawlerConfig a r) (CrawlerConfig a r -> AddRobotsAction)
theAccumulateOp :: Selector (CrawlerConfig a r) (AccumulateDocResult a r)
theFoldOp :: Selector (CrawlerConfig a r) (MergeDocResults r)
thePreRefsFilter :: Selector (CrawlerConfig a r) (IOSArrow XmlTree XmlTree)
theProcessRefs :: Selector (CrawlerConfig a r) (IOSArrow XmlTree URI)
thePreDocFilter :: Selector (CrawlerConfig a r) (IOSArrow XmlTree XmlTree)
theProcessDoc :: Selector (CrawlerConfig a r) (IOSArrow XmlTree a)
defaultCrawlerConfig :: AccumulateDocResult a r -> MergeDocResults r -> CrawlerConfig a r
theInputOptions :: Selector (CrawlerConfig a r) Attributes
theCrawlerName :: Selector (CrawlerConfig a r) String
theMaxTime :: Selector (CrawlerConfig a r) Int
theConnectTimeout :: Selector (CrawlerConfig a r) Int

-- | Add attributes for accessing documents
addSysConfig :: SysConfig -> CrawlerConfig a r -> CrawlerConfig a r

-- | Insert a robots no follow filter before thePreRefsFilter
addRobotsNoFollow :: CrawlerConfig a r -> CrawlerConfig a r

-- | Insert a robots no follow filter before thePreRefsFilter
addRobotsNoIndex :: CrawlerConfig a r -> CrawlerConfig a r

-- | Set the log level
setCrawlerTraceLevel :: Priority -> Priority -> CrawlerConfig a r -> CrawlerConfig a r

-- | Set save intervall in config
setCrawlerSaveConf :: Int -> String -> CrawlerConfig a r -> CrawlerConfig a r

-- | Set action performed before saving crawler state
setCrawlerSaveAction :: (FilePath -> CrawlerAction a r ()) -> CrawlerConfig a r -> CrawlerConfig a r

-- | Set max # of steps (clicks) to reach a document
setCrawlerClickLevel :: Int -> CrawlerConfig a r -> CrawlerConfig a r

-- | Set max # of documents to be crawled and max # of documents crawled in
--   parallel
setCrawlerMaxDocs :: Int -> Int -> Int -> CrawlerConfig a r -> CrawlerConfig a r

-- | Set the pre hook filter executed before the hrefs are collected
setCrawlerPreRefsFilter :: IOSArrow XmlTree XmlTree -> CrawlerConfig a r -> CrawlerConfig a r
putCrawlerState :: Binary r => CrawlerState r -> Put
getCrawlerState :: Binary r => Get (CrawlerState r)
initCrawlerState :: r -> CrawlerState r

-- | Load a component from the crawler configuration
getConf :: Selector (CrawlerConfig a r) v -> CrawlerAction a r v
getState :: Selector (CrawlerState r) v -> CrawlerAction a r v
putState :: Selector (CrawlerState r) v -> v -> CrawlerAction a r ()
modifyState :: Selector (CrawlerState r) v -> (v -> v) -> CrawlerAction a r ()
modifyStateIO :: Selector (CrawlerState r) v -> (v -> IO v) -> CrawlerAction a r ()
instance Show r => Show (CrawlerState r)
instance Binary r => Binary (CrawlerState r)
instance XmlPickler r => XmlPickler (CrawlerState r)
instance NFData r => NFData (CrawlerState r)

module Holumbus.Crawler.Robots

-- | Add a robots.txt description for a given URI, if it's not already
--   there. The 1. main function of this module
robotsAddHost :: CrawlerConfig a r -> AddRobotsAction
robotsDontAddHost :: CrawlerConfig a r -> AddRobotsAction

-- | Check whether a robot is not allowed to access a page. The 2. main
--   function of this module
robotsDisallow :: Robots -> URI -> Bool
getURIPart :: (URI -> String) -> URI -> String

-- | Get the protocol-host-port part of an URI
getHost :: URI -> URI
isRobotsScheme :: URI -> Bool

-- | Access, parse and evaluate a robots.txt file for a given URI
robotsGetSpec :: CrawlerConfig a r -> URI -> IO (URI, RobotRestriction)

-- | Try to get the robots.txt file for a given host. If it's not there or
--   any errors occur during access, the empty string is returned
getRobotsTxt :: CrawlerConfig c r -> URI -> IO String

-- | Parse the robots.txt, select the crawler specific parts and build a
--   robots restriction value
evalRobotsTxt :: String -> String -> RobotRestriction

-- | Enable the evaluation of robots.txt
enableRobotsTxt :: CrawlerConfig a r -> CrawlerConfig a r

-- | Disable the evaluation of robots.txt
disableRobotsTxt :: CrawlerConfig a r -> CrawlerConfig a r

module Holumbus.Crawler.Html
defaultHtmlCrawlerConfig :: AccumulateDocResult a r -> MergeDocResults r -> CrawlerConfig a r

-- | Collect all HTML references to other documents within a, frame and
--   iframe elements
getHtmlReferences :: ArrowXml a => a XmlTree URI
getDocReferences :: ArrowXml a => a XmlTree URI

-- | construct an absolute URI by a base URI and a possibly relative URI
toAbsRef :: URI -> URI -> URI

-- | Compute the base URI of a HTML page with respect to a possibly given
--   base element in the head element of a html page.
--   
--   Stolen from Uwe Schmidt, http://www.haskell.org/haskellwiki/HXT and
--   then stolen back again by Uwe from Holumbus.Utility
computeDocBase :: ArrowXml a => a XmlTree String
getByPath :: ArrowXml a => [String] -> a XmlTree XmlTree
getHtmlTitle :: ArrowXml a => a XmlTree String
getHtmlPlainText :: ArrowXml a => a XmlTree String
getAllText :: ArrowXml a => a XmlTree XmlTree -> a XmlTree String
isHtmlContents :: ArrowXml a => a XmlTree XmlTree
isPdfContents :: ArrowXml a => a XmlTree XmlTree
getTitleOrDocName :: ArrowXml a => a XmlTree String
isElemWithAttr :: ArrowXml a => String -> String -> (String -> Bool) -> a XmlTree XmlTree
application_pdf :: String

-- | normalize whitespace by splitting a text into words and joining this
--   together with unwords
normalizeWS :: String -> String

-- | take the first n chars of a string, if the input is too long the cut
--   off is indicated by "..." at the end
limitLength :: Int -> String -> String


-- | A map-fold function for performing list folds in parallel.
module Control.Concurrent.MapFold
mapFold :: NFData b => Int -> (a -> IO b) -> (b -> b -> IO b) -> [a] -> IO b

module Holumbus.Crawler.Core
saveCrawlerState :: Binary r => FilePath -> CrawlerAction a r ()
loadCrawlerState :: Binary r => FilePath -> CrawlerAction a r ()
uriProcessed :: URI -> CrawlerAction a r ()
urisProcessed :: URIs -> CrawlerAction a r ()
uriToBeProcessed :: URI -> Int -> CrawlerAction a r ()
urisToBeProcessed :: URIsWithLevel -> CrawlerAction a r ()
uriAddToRobotsTxt :: URI -> CrawlerAction a r ()
accumulateRes :: NFData r => (URI, a) -> CrawlerAction a r ()
crawlDocs :: (NFData a, NFData r, Binary r) => [URI] -> CrawlerAction a r ()
crawlerLoop :: (NFData a, NFData r, Binary r) => CrawlerAction a r ()
crawlerResume :: (NFData a, NFData r, Binary r) => String -> CrawlerAction a r ()
crawlerCheckSaveState :: Binary r => CrawlerAction a r ()
crawlerSaveState :: Binary r => CrawlerAction a r ()
type MapFold a r = (a -> IO r) -> (r -> r -> IO r) -> [a] -> IO r
crawlNextDocs :: NFData r => MapFold URIWithLevel (URIs, URIsWithLevel, r) -> CrawlerAction a r ()
processDoc' :: URIWithLevel -> CrawlerAction a r (URIs, URIsWithLevel, [(URI, a)])
combineDocResults' :: NFData r => MergeDocResults r -> (URIs, URIsWithLevel, r) -> (URIs, URIsWithLevel, r) -> IO (URIs, URIsWithLevel, r)

-- | crawl a single doc, mark doc as processed, collect new hrefs and
--   combine doc result with accumulator in state
crawlNextDoc :: (NFData a, NFData r) => CrawlerAction a r ()

-- | Run the process document arrow and prepare results
processDoc :: URIWithLevel -> CrawlerAction a r (URI, [URIWithLevel], [(URI, a)])

-- | filter uris rejected by robots.txt
isAllowedByRobots :: URI -> CrawlerAction a r Bool

-- | From a document two results are computed, 1. the list of all hrefs in
--   the contents, and 2. the collected info contained in the page. This
--   result is augmented with the transfer uri such that following
--   functions know the source of this contents. The transfer-URI may be
--   another one as the input uri, there could happen a redirect in the
--   http request.
--   
--   The two listA arrows make the whole arrow deterministic, so it never
--   fails
processDocArrow :: CrawlerConfig c r -> URI -> IOSArrow a (URI, ([URI], [(URI, c)]))

-- | compute the real URI in case of a 301 or 302 response (moved
--   permanently or temporary), else the arrow will fail
getLocationReference :: ArrowXml a => a XmlTree String

-- | compute the real URI of the document, in case of a move response this
--   is contained in the "http-location" attribute, else it's the
--   tranferURI.
getRealDocURI :: ArrowXml a => a XmlTree String
initCrawler :: CrawlerAction a r ()
runCrawler :: CrawlerAction a r x -> CrawlerConfig a r -> CrawlerState r -> IO (x, CrawlerState r)
execCrawler :: CrawlerAction a r x -> CrawlerConfig a r -> CrawlerState r -> IO (CrawlerState r)

module Holumbus.Crawler

module Holumbus.Crawler.CacheCore
type CacheCrawlerConfig = CrawlerConfig () CacheState
type CacheCrawlerState = CrawlerState CacheState
newtype CacheState
CS :: () -> CacheState
emptyCacheState :: CacheState
unionCacheStatesM :: Monad m => CacheState -> CacheState -> m CacheState
insertCacheM :: Monad m => (URI, ()) -> CacheState -> m CacheState
cacheCrawlerConfig :: SysConfig -> (URI -> Bool) -> CacheCrawlerConfig
stdCacher :: (Int, Int, Int) -> (Int, String) -> (Priority, Priority) -> SysConfig -> (CacheCrawlerConfig -> CacheCrawlerConfig) -> Maybe String -> [URI] -> (URI -> Bool) -> IO CacheCrawlerState
instance XmlPickler CacheState
instance Binary CacheState
instance NFData CacheState

module Holumbus.Crawler.IndexerCore
type RawDoc c = (RawContexts, RawTitle, Maybe c)
type RawContexts = [RawContext]
type RawContext = (Context, RawWords)
type RawWords = [RawWord]
type RawWord = (Word, Position)
type RawTitle = String
type IndexCrawlerConfig i d c = CrawlerConfig (RawDoc c) (IndexerState i d c)
data IndexContextConfig
IndexContextConfig :: String -> IOSArrow XmlTree String -> (String -> [String]) -> (String -> Bool) -> IndexContextConfig
ixc_name :: IndexContextConfig -> String
ixc_collectText :: IndexContextConfig -> IOSArrow XmlTree String
ixc_textToWords :: IndexContextConfig -> String -> [String]
ixc_boringWord :: IndexContextConfig -> String -> Bool
data IndexerState i d c
IndexerState :: !i -> !d c -> IndexerState i d c
ixs_index :: IndexerState i d c -> !i
ixs_documents :: IndexerState i d c -> !d c
emptyIndexerState :: i -> d c -> IndexerState i d c
indexCrawlerConfig :: (HolIndexM IO i, HolDocuments d c, HolDocIndex d c i, NFData i, NFData c, NFData (d c)) => SysConfig -> (URI -> Bool) -> Maybe (IOSArrow XmlTree String) -> Maybe (IOSArrow XmlTree XmlTree) -> Maybe (IOSArrow XmlTree String) -> Maybe (IOSArrow XmlTree c) -> [IndexContextConfig] -> IndexCrawlerConfig i d c
stdIndexer :: (Binary i, Binary (d c), Binary c, HolIndexM IO i, HolDocuments d c, NFData i, NFData (d c), NFData c) => IndexCrawlerConfig i d c -> Maybe String -> [URI] -> IndexerState i d c -> IO (IndexCrawlerState i d c)
unionIndexerStatesM :: (MonadIO m, HolIndexM m i, HolDocuments d c, HolDocIndex d c i) => IndexerState i d c -> IndexerState i d c -> m (IndexerState i d c)
insertRawDocM :: (MonadIO m, HolIndexM m i, HolDocuments d c, NFData i, NFData c, NFData (d c)) => (URI, RawDoc c) -> IndexerState i d c -> m (IndexerState i d c)
instance (Show i, Show (d c)) => Show (IndexerState i d c)
instance (XmlPickler i, XmlPickler (d c)) => XmlPickler (IndexerState i d c)
instance (Binary i, Binary (d c)) => Binary (IndexerState i d c)
instance (NFData i, NFData (d c)) => NFData (IndexerState i d c)

module Holumbus.Index.CompactIndex

-- | A document consists of a title and its unique identifier (URI) and a
--   customizable component
data Document a
data Documents a

-- | The table to store the document descriptions
--   
--   This table does not contain the reverse map from URIs do DocIds, this
--   reverse map is only needed when crawling, not for searching the index.
--   As a consequence, most of the indes operations are not implemented
--   
--   see also <a>Documents</a> data type
data SmallDocuments a
type Inverted = Inverted0
emptyInverted :: Inverted
removeDocIdsInverted :: Occurrences -> Inverted -> Inverted
type CompactInverted = InvertedOSerialized
emptyCompactInverted :: CompactInverted
inverted2compactInverted :: Inverted -> CompactInverted
type HolumbusState di = IndexerState Inverted Documents di
type HolumbusConfig di = IndexCrawlerConfig Inverted Documents di
emptyHolumbusState :: HolumbusState di
defragmentHolumbusState :: Binary di => HolumbusState di -> HolumbusState di
emptyIndexerState :: i -> d c -> IndexerState i d c

-- | Create an empty table.
emptyDocuments :: Documents a
mergeAndWritePartialRes' :: (MonadIO m, NFData i, Binary i) => (SmallDocuments i -> SmallDocuments i) -> [String] -> String -> m ()
writeXml :: (MonadIO m, XmlPickler a) => FilePath -> a -> m ()
writeBin :: (MonadIO m, Binary a) => FilePath -> a -> m ()
writeSearchBin :: (Binary c, MonadIO m) => FilePath -> HolumbusState c -> m ()
writePartialIndex :: (NFData c, XmlPickler c, Binary c) => Bool -> FilePath -> CrawlerAction a (HolumbusState c) ()

module Holumbus.Index.HashedIndex

-- | A document consists of a title and its unique identifier (URI) and a
--   customizable component
data Document a
data Documents a
type SmallDocuments = Documents
type Inverted = Inverted0
emptyInverted :: Inverted
removeDocIdsInverted :: Occurrences -> Inverted -> Inverted
type CompactInverted = InvertedOSerialized
emptyCompactInverted :: CompactInverted
inverted2compactInverted :: Inverted -> CompactInverted
type HolumbusState di = IndexerState Inverted Documents di
type HolumbusConfig di = IndexCrawlerConfig Inverted Documents di
emptyHolumbusState :: HolumbusState di
defragmentHolumbusState :: Binary di => HolumbusState di -> HolumbusState di
emptyIndexerState :: i -> d c -> IndexerState i d c

-- | Create an empty table.
emptyDocuments :: Documents a
mergeAndWritePartialRes' :: (MonadIO m, NFData i, Binary i) => (SmallDocuments i -> SmallDocuments i) -> [String] -> String -> m ()
writeXml :: (MonadIO m, XmlPickler a) => FilePath -> a -> m ()
writeBin :: (MonadIO m, Binary a) => FilePath -> a -> m ()
writeSearchBin :: (Binary c, MonadIO m) => FilePath -> HolumbusState c -> m ()
writePartialIndex :: (NFData c, XmlPickler c, Binary c) => Bool -> FilePath -> CrawlerAction a (HolumbusState c) ()
