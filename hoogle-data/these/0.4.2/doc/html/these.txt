-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An either-or-both data type, with corresponding hybrid error/writer monad transformer.
--   
--   An either-or-both data type, with corresponding hybrid error/writer
--   monad transformer.
@package these
@version 0.4.2


-- | The <a>These</a> type and associated operations. Now enhanced with
--   <tt>Control.Lens</tt> magic!
module Data.These

-- | The <a>These</a> type represents values with two non-exclusive
--   possibilities.
--   
--   This can be useful to represent combinations of two values, where the
--   combination is defined if either input is. Algebraically, the type
--   <tt>These A B</tt> represents <tt>(A + B + AB)</tt>, which doesn't
--   factor easily into sums and products--a type like <tt>Either A (B,
--   Maybe A)</tt> is unclear and awkward to use.
--   
--   <a>These</a> has straightforward instances of <a>Functor</a>,
--   <a>Monad</a>, &amp;c., and behaves like a hybrid error/writer monad,
--   as would be expected.
data These a b
This :: a -> These a b
That :: b -> These a b
These :: a -> b -> These a b

-- | Case analysis for the <a>These</a> type.
these :: (a -> c) -> (b -> c) -> (a -> b -> c) -> These a b -> c

-- | Takes two default values and produces a tuple.
fromThese :: a -> b -> These a b -> (a, b)

-- | Coalesce with the provided operation.
mergeThese :: (a -> a -> a) -> These a a -> a

-- | A <tt>Traversal</tt> of the first half of a <a>These</a>, suitable for
--   use with <tt>Control.Lens</tt>.
here :: Applicative f => (a -> f b) -> These a t -> f (These b t)

-- | A <tt>Traversal</tt> of the second half of a <a>These</a>, suitable
--   for use with <tt>Control.Lens</tt>.
there :: Applicative f => (a -> f b) -> These t a -> f (These t b)

-- | A <tt>Prism</tt> selecting the <a>This</a> constructor.
_This :: (Choice p, Applicative f) => p a (f a) -> p (These a b) (f (These a b))

-- | A <tt>Prism</tt> selecting the <a>That</a> constructor.
_That :: (Choice p, Applicative f) => p b (f b) -> p (These a b) (f (These a b))

-- | A <tt>Prism</tt> selecting the <a>These</a> constructor. <a>These</a>
--   names are ridiculous!
_These :: (Choice p, Applicative f) => p (a, b) (f (a, b)) -> p (These a b) (f (These a b))

-- | <pre>
--   <a>justThis</a> = preview <a>_This</a>
--   </pre>
justThis :: These a b -> Maybe a

-- | <pre>
--   <a>justThat</a> = preview <a>_That</a>
--   </pre>
justThat :: These a b -> Maybe b

-- | <pre>
--   <a>justThese</a> = preview <a>_These</a>
--   </pre>
justThese :: These a b -> Maybe (a, b)

-- | Select all <a>This</a> constructors from a list.
catThis :: [These a b] -> [a]

-- | Select all <a>That</a> constructors from a list.
catThat :: [These a b] -> [b]

-- | Select all <a>These</a> constructors from a list.
catThese :: [These a b] -> [(a, b)]

-- | Select each constructor and partition them into separate lists.
partitionThese :: [These a b] -> ([(a, b)], ([a], [b]))

-- | <pre>
--   <a>isThis</a> = <a>isJust</a> . <a>justThis</a>
--   </pre>
isThis :: These a b -> Bool

-- | <pre>
--   <a>isThat</a> = <a>isJust</a> . <a>justThat</a>
--   </pre>
isThat :: These a b -> Bool

-- | <pre>
--   <a>isThese</a> = <a>isJust</a> . <a>justThese</a>
--   </pre>
isThese :: These a b -> Bool

-- | <a>Bifunctor</a> map.
mapThese :: (a -> c) -> (b -> d) -> These a b -> These c d

-- | <pre>
--   <a>mapThis</a> = over <a>here</a>
--   </pre>
mapThis :: (a -> c) -> These a b -> These c b

-- | <pre>
--   <a>mapThat</a> = over <a>there</a>
--   </pre>
mapThat :: (b -> d) -> These a b -> These a d
instance (Eq a, Eq b) => Eq (These a b)
instance (Ord a, Ord b) => Ord (These a b)
instance (Read a, Read b) => Read (These a b)
instance (Show a, Show b) => Show (These a b)
instance Monoid a => Monad (These a)
instance Monoid a => Bind (These a)
instance Monoid a => Applicative (These a)
instance Monoid a => Apply (These a)
instance Bitraversable1 These
instance Bitraversable These
instance Bifoldable1 These
instance Bifoldable These
instance Bifunctor These
instance Traversable (These a)
instance Foldable (These a)
instance Functor (These a)
instance (Semigroup a, Semigroup b) => Semigroup (These a b)


-- | <a>These</a>-based zipping and unzipping of functors with non-uniform
--   shapes, plus traversal of (bi)foldable (bi)functors through said
--   functors.
module Data.Align

-- | Functors supporting a zip operation that takes the union of
--   non-uniform shapes.
--   
--   If your functor is actually a functor from <tt>Kleisli Maybe</tt> to
--   <tt>Hask</tt> (so it supports <tt>maybeMap :: (a -&gt; Maybe b) -&gt;
--   f a -&gt; f b</tt>), then an <tt>Align</tt> instance is making your
--   functor lax monoidal w.r.t. the cartesian monoidal structure on
--   <tt>Kleisli Maybe</tt>, because <tt>These</tt> is the cartesian
--   product in that category <tt>(a -&gt; Maybe (These b c) ~ (a -&gt;
--   Maybe b, a -&gt; Maybe c))</tt>. This insight is due to rwbarton.
--   
--   Minimal definition: <tt>nil</tt> and either <tt>align</tt> or
--   <tt>alignWith</tt>.
--   
--   Laws:
--   
--   <pre>
--   (`align` nil) = fmap This
--   (nil `align`) = fmap That
--   join align = fmap (join These)
--   align (f &lt;$&gt; x) (g &lt;$&gt; y) = bimap f g &lt;$&gt; align x y
--   alignWith f a b = f &lt;$&gt; align a b
--   </pre>
class Functor f => Align f where align = alignWith id alignWith f a b = f <$> align a b
nil :: Align f => f a
align :: Align f => f a -> f b -> f (These a b)
alignWith :: Align f => (These a b -> c) -> f a -> f b -> f c

-- | Align two structures and combine with <a>mappend</a>.
malign :: (Align f, Monoid a) => f a -> f a -> f a

-- | Align two structures as in <a>zip</a>, but filling in blanks with
--   <a>Nothing</a>.
padZip :: Align f => f a -> f b -> f (Maybe a, Maybe b)

-- | Align two structures as in <a>zipWith</a>, but filling in blanks with
--   <a>Nothing</a>.
padZipWith :: Align f => (Maybe a -> Maybe b -> c) -> f a -> f b -> f c

-- | Left-padded <a>zip</a>.
lpadZip :: [a] -> [b] -> [(Maybe a, b)]

-- | Left-padded <a>zipWith</a>.
lpadZipWith :: (Maybe a -> b -> c) -> [a] -> [b] -> [c]

-- | Right-padded <a>zip</a>.
rpadZip :: [a] -> [b] -> [(a, Maybe b)]

-- | Right-padded <a>zipWith</a>.
rpadZipWith :: (a -> Maybe b -> c) -> [a] -> [b] -> [c]
alignVectorWith :: (Vector v a, Vector v b, Vector v c) => (These a b -> c) -> v a -> v b -> v c

-- | Alignable functors supporting an "inverse" to <a>align</a>: splitting
--   a union shape into its component parts.
--   
--   Minimal definition: nothing; a default definition is provided, but it
--   may not have the desired definition for all functors. See the source
--   for more information.
--   
--   Laws:
--   
--   <pre>
--   unalign nil                 = (nil,           nil)
--   unalign (This        &lt;$&gt; x) = (Just    &lt;$&gt; x, Nothing &lt;$  x)
--   unalign (That        &lt;$&gt; y) = (Nothing &lt;$  y, Just    &lt;$&gt; y)
--   unalign (join These  &lt;$&gt; x) = (Just    &lt;$&gt; x, Just    &lt;$&gt; x)
--   unalign ((x `These`) &lt;$&gt; y) = (Just x  &lt;$  y, Just    &lt;$&gt; y)
--   unalign ((`These` y) &lt;$&gt; x) = (Just    &lt;$&gt; x, Just y  &lt;$  x)
--   </pre>
class Align f => Unalign f where unalign x = (fmap left x, fmap right x) where left = these Just (const Nothing) (\ a _ -> Just a) right = these (const Nothing) Just (\ _ b -> Just b)
unalign :: Unalign f => f (These a b) -> (f (Maybe a), f (Maybe b))

-- | Foldable functors supporting traversal through an alignable functor.
--   
--   Minimal definition: <tt>crosswalk</tt> or <tt>sequenceL</tt>.
--   
--   Laws:
--   
--   <pre>
--   crosswalk (const nil) = const nil
--   crosswalk f = sequenceL . fmap f
--   </pre>
class (Functor t, Foldable t) => Crosswalk t where crosswalk f = sequenceL . fmap f sequenceL = crosswalk id
crosswalk :: (Crosswalk t, Align f) => (a -> f b) -> t a -> f (t b)
sequenceL :: (Crosswalk t, Align f) => t (f a) -> f (t a)

-- | Bifoldable bifunctors supporting traversal through an alignable
--   functor.
--   
--   Minimal definition: <tt>bicrosswalk</tt> or <tt>bisequenceL</tt>.
--   
--   Laws:
--   
--   <pre>
--   bicrosswalk (const empty) (const empty) = const empty
--   bicrosswalk f g = bisequenceL . bimap f g
--   </pre>
class (Bifunctor t, Bifoldable t) => Bicrosswalk t where bicrosswalk f g = bisequenceL . bimap f g bisequenceL = bicrosswalk id id
bicrosswalk :: (Bicrosswalk t, Align f) => (a -> f c) -> (b -> f d) -> t a b -> f (t c d)
bisequenceL :: (Bicrosswalk t, Align f) => t (f a) (f b) -> f (t a b)
instance Bicrosswalk These
instance Bicrosswalk Either
instance Crosswalk (These a)
instance Crosswalk []
instance Crosswalk Maybe
instance Crosswalk Identity
instance Monad m => Unalign (Stream m)
instance (Unalign f, Unalign g) => Unalign (Product f g)
instance Unalign ZipList
instance Unalign []
instance Unalign Maybe
instance Monad m => Align (Stream m)
instance (Align f, Align g) => Align (Product f g)
instance Align IntMap
instance Ord k => Align (Map k)
instance Align Seq
instance Align ZipList
instance Align []
instance Align Maybe


-- | The <a>ChronicleT</a> monad, a hybrid error/writer monad that allows
--   both accumulating outputs and aborting computation with a final
--   output.
module Control.Monad.Trans.Chronicle

-- | A chronicle monad parameterized by the output type <tt>c</tt>.
--   
--   The <a>return</a> function produces a computation with no output, and
--   <a>&gt;&gt;=</a> combines multiple outputs with <a>mappend</a>.
type Chronicle c = ChronicleT c Identity
chronicle :: These c a -> Chronicle c a
runChronicle :: Chronicle c a -> These c a

-- | The <a>ChronicleT</a> monad transformer.
--   
--   The <a>return</a> function produces a computation with no output, and
--   <a>&gt;&gt;=</a> combines multiple outputs with <a>mappend</a>.
newtype ChronicleT c m a
ChronicleT :: m (These c a) -> ChronicleT c m a
runChronicleT :: ChronicleT c m a -> m (These c a)

-- | <tt><a>dictate</a> c</tt> is an action that records the output
--   <tt>c</tt>.
--   
--   Equivalent to <a>tell</a> for the <tt>Writer</tt> monad.
dictate :: (Monoid c, Monad m) => c -> ChronicleT c m ()

-- | <tt><a>confess</a> c</tt> is an action that ends with a final output
--   <tt>c</tt>.
--   
--   Equivalent to <a>throwError</a> for the <a>Error</a> monad.
confess :: (Monoid c, Monad m) => c -> ChronicleT c m a

-- | <tt><a>memento</a> m</tt> is an action that executes the action
--   <tt>m</tt>, returning either its record if it ended with
--   <a>confess</a>, or its final value otherwise, with any record added to
--   the current record.
--   
--   Similar to <a>catchError</a> in the <a>Error</a> monad, but with a
--   notion of non-fatal errors (which are accumulated) vs. fatal errors
--   (which are caught without accumulating).
memento :: (Monoid c, Monad m) => ChronicleT c m a -> ChronicleT c m (Either c a)

-- | <tt><a>absolve</a> x m</tt> is an action that executes the action
--   <tt>m</tt> and discards any record it had. The default value
--   <tt>x</tt> will be used if <tt>m</tt> ended via <a>confess</a>.
absolve :: (Monoid c, Monad m) => a -> ChronicleT c m a -> ChronicleT c m a

-- | <tt><a>condemn</a> m</tt> is an action that executes the action
--   <tt>m</tt> and keeps its value only if it had no record. Otherwise,
--   the value (if any) will be discarded and only the record kept.
--   
--   This can be seen as converting non-fatal errors into fatal ones.
condemn :: (Monoid c, Monad m) => ChronicleT c m a -> ChronicleT c m a

-- | <tt><a>retcon</a> f m</tt> is an action that executes the action
--   <tt>m</tt> and applies the function <tt>f</tt> to its output, leaving
--   the return value unchanged.
--   
--   Equivalent to <a>censor</a> for the <tt>Writer</tt> monad.
retcon :: (Monoid c, Monad m) => (c -> c) -> ChronicleT c m a -> ChronicleT c m a
instance (Monoid c, MonadWriter w m) => MonadWriter w (ChronicleT c m)
instance (Monoid c, MonadState s m) => MonadState s (ChronicleT c m)
instance (Monoid c, MonadRWS r w s m) => MonadRWS r w s (ChronicleT c m)
instance (Monoid c, MonadReader r m) => MonadReader r (ChronicleT c m)
instance (Monoid c, MonadError e m) => MonadError e (ChronicleT c m)
instance (Monoid c, Monad m) => MonadPlus (ChronicleT c m)
instance (Monoid c, Applicative m, Monad m) => Alternative (ChronicleT c m)
instance (Monoid c, MonadIO m) => MonadIO (ChronicleT c m)
instance Monoid c => MonadTrans (ChronicleT c)
instance (Monoid c, Monad m) => Monad (ChronicleT c m)
instance (Monoid c, Apply m, Monad m) => Bind (ChronicleT c m)
instance (Monoid c, Applicative m) => Applicative (ChronicleT c m)
instance (Monoid c, Apply m) => Apply (ChronicleT c m)
instance Functor m => Functor (ChronicleT c m)


-- | Hybrid error/writer monad class that allows both accumulating outputs
--   and aborting computation with a final output.
--   
--   The expected use case is for computations with a notion of fatal vs.
--   non-fatal errors.
module Control.Monad.Chronicle.Class
class Monad m => MonadChronicle c m | m -> c
dictate :: MonadChronicle c m => c -> m ()
confess :: MonadChronicle c m => c -> m a
memento :: MonadChronicle c m => m a -> m (Either c a)
absolve :: MonadChronicle c m => a -> m a -> m a
condemn :: MonadChronicle c m => m a -> m a
retcon :: MonadChronicle c m => (c -> c) -> m a -> m a
chronicle :: MonadChronicle c m => These c a -> m a

-- | The <a>ChronicleT</a> monad transformer.
--   
--   The <a>return</a> function produces a computation with no output, and
--   <a>&gt;&gt;=</a> combines multiple outputs with <a>mappend</a>.
newtype ChronicleT c m a
ChronicleT :: m (These c a) -> ChronicleT c m a
runChronicleT :: ChronicleT c m a -> m (These c a)
runChronicle :: Chronicle c a -> These c a
instance (Monoid w, MonadChronicle c m) => MonadChronicle c (RWST r w s m)
instance (Monoid w, MonadChronicle c m) => MonadChronicle c (RWST r w s m)
instance (Monoid w, MonadChronicle c m) => MonadChronicle c (WriterT w m)
instance (Monoid w, MonadChronicle c m) => MonadChronicle c (WriterT w m)
instance MonadChronicle c m => MonadChronicle c (StateT s m)
instance MonadChronicle c m => MonadChronicle c (StateT s m)
instance MonadChronicle c m => MonadChronicle c (ReaderT r m)
instance (Error e, MonadChronicle c m) => MonadChronicle c (ErrorT e m)
instance MonadChronicle c m => MonadChronicle c (MaybeT m)
instance MonadChronicle c m => MonadChronicle c (IdentityT m)
instance (Monoid c, Monad m) => MonadChronicle c (ChronicleT c m)
instance Monoid c => MonadChronicle c (These c)

module Control.Monad.Chronicle
class Monad m => MonadChronicle c m | m -> c
dictate :: MonadChronicle c m => c -> m ()
confess :: MonadChronicle c m => c -> m a
memento :: MonadChronicle c m => m a -> m (Either c a)
absolve :: MonadChronicle c m => a -> m a -> m a
condemn :: MonadChronicle c m => m a -> m a
retcon :: MonadChronicle c m => (c -> c) -> m a -> m a
chronicle :: MonadChronicle c m => These c a -> m a

-- | A chronicle monad parameterized by the output type <tt>c</tt>.
--   
--   The <a>return</a> function produces a computation with no output, and
--   <a>&gt;&gt;=</a> combines multiple outputs with <a>mappend</a>.
type Chronicle c = ChronicleT c Identity
runChronicle :: Chronicle c a -> These c a

-- | The <a>ChronicleT</a> monad transformer.
--   
--   The <a>return</a> function produces a computation with no output, and
--   <a>&gt;&gt;=</a> combines multiple outputs with <a>mappend</a>.
newtype ChronicleT c m a
ChronicleT :: m (These c a) -> ChronicleT c m a
runChronicleT :: ChronicleT c m a -> m (These c a)
