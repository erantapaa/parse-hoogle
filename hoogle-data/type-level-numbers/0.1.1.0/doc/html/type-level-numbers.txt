-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Type level numbers implemented using type families.
--   
@package type-level-numbers
@version 0.1.1.0


module TypeLevel.Reify

-- | Value with type tag
data Witness t a
Witness :: a -> Witness t a
getValue :: Witness t a -> a

-- | Convert type level into value level using
class Reify t a
witness :: Reify t a => Witness t a
instance Typeable Witness
instance Show a => Show (Witness t a)
instance Eq a => Eq (Witness t a)
instance (Data t, Data a) => Data (Witness t a)

module TypeLevel.Boolean

-- | Data type for truth
data True

-- | Data type for false.
data False

-- | Negation
notT :: a -> Not a

-- | And for boolean types
andT :: a -> b -> And a b

-- | Or for boolean types
orT :: a -> b -> Or a b

-- | Exlusive or for boolean types
xorT :: a -> b -> Xor a b
instance Reify False Bool
instance Reify True Bool
instance Show True
instance Show False


-- | This module contain interface type classes for operations with type
--   level numbers.
module TypeLevel.Number.Classes

-- | Type family for comparing two numbers. It's expected that for any two
--   valid <tt>n</tt> and <tt>m</tt> 'Compare n m' is equal to IsLess when
--   'n&lt;m', IsEqual when 'n=m' and IsGreater when 'n&gt;m'.
compareN :: n -> m -> Compare n m
data IsLesser
data IsEqual
data IsGreater

-- | Numbers n and m are instances of this class if and only is n &lt; m.
class Lesser n m

-- | Numbers n and m are instances of this class if and only is n &lt;= m.
class LesserEq n m

-- | Numbers n and m are instances of this class if and only is n &gt; m.
class Greater n m

-- | Numbers n and m are instances of this class if and only is n &gt;= m.
class GreaterEq n m

-- | Positive number.
class Positive n

-- | Non-zero number. For naturals it's same as positive
class NonZero n

-- | Next number.
nextN :: n -> Next n

-- | Previous number
prevN :: n -> Prev n

-- | Negate number.
negateN :: n -> Negate n

-- | Sum of two numbers.
addN :: n -> m -> Add n m

-- | Difference of two numbers.
subN :: n -> m -> Sub n m

-- | Product of two numbers.
mulN :: n -> m -> Mul n m

-- | Division of two numbers. <tt>n</tt> and <tt>m</tt> should be instances
--   of this class only if remainder of 'n/m' is zero.
divN :: n -> m -> Div n m

-- | Usually numbers have non-unique representation. This type family is
--   canonical representation of number.
instance OneOfTwo (Compare n m) IsGreater IsEqual => GreaterEq n m
instance OneOfTwo (Compare n m) IsLesser IsEqual => LesserEq n m
instance Compare n m ~ IsGreater => Greater n m
instance Compare n m ~ IsLesser => Lesser n m
instance OneOfTwo a a a
instance OneOfTwo a b a
instance OneOfTwo a a b
instance Show IsGreater
instance Show IsEqual
instance Show IsLesser


-- | This is type level natural numbers. They are represented using binary
--   encoding which means that reasonable large numbers could be
--   represented. With default context stack depth (20) maximal number is
--   2^18-1 (262143).
--   
--   <pre>
--   Z           = 0
--   I Z         = 1
--   O (I Z)     = 2
--   I (I Z)     = 3
--   O (O (I Z)) = 4
--   ...
--   </pre>
--   
--   It's easy to see that representation for each number is not unique.
--   One could add any numbers of leading zeroes:
--   
--   <pre>
--   I Z = I (O Z) = I (O (O Z)) = 1
--   </pre>
--   
--   In order to enforce uniqueness of representation only numbers without
--   leading zeroes are members of Nat type class. This means than types
--   are equal if and only if numbers are equal.
--   
--   Natural numbers support comparison and following operations: Next,
--   Prev, Add, Sub, Mul. All operations on numbers return normalized
--   numbers.
--   
--   Interface type classes are reexported from TypeLevel.Number.Classes
module TypeLevel.Number.Nat

-- | One bit.
data I n

-- | Zero bit.
data O n

-- | Bit stream terminator.
data Z

-- | Type class for natural numbers. Only numbers without leading zeroes
--   are members of this type class.
class Nat n
toInt :: (Nat n, Integral i) => n -> i

-- | Some natural number
data SomeNat
SomeNat :: n -> SomeNat

-- | Apply function which could work with any <a>Nat</a> value only know at
--   runtime.
withNat :: Integral i => (forall n. Nat n => n -> a) -> i -> a

-- | Create type for natural number.
natT :: Integer -> TypeQ

-- | Create value for type level natural. Value itself is undefined.
nat :: Integer -> ExpQ
instance Typeable SomeNat
instance Nat (O n) => NonZero (O n)
instance Nat (I n) => NonZero (I n)
instance Nat (O n) => Positive (O n)
instance Nat (I n) => Positive (I n)
instance Nat (I n) => Show (I n)
instance Nat (O n) => Show (O n)
instance Show Z
instance Nat (I n) => Reify (I n) Int64
instance Nat (O n) => Reify (O n) Int64
instance Reify Z Int64
instance Nat (I n) => Reify (I n) Int32
instance Nat (O n) => Reify (O n) Int32
instance Reify Z Int32
instance (Nat (I n), Lesser (I n) (O (O (O (O (O (O (O (O (O (O (O (O (O (O (O (I Z))))))))))))))))) => Reify (I n) Int16
instance (Nat (O n), Lesser (O n) (O (O (O (O (O (O (O (O (O (O (O (O (O (O (O (I Z))))))))))))))))) => Reify (O n) Int16
instance Reify Z Int16
instance (Nat (I n), Lesser (I n) (O (O (O (O (O (O (O (I Z))))))))) => Reify (I n) Int8
instance (Nat (O n), Lesser (O n) (O (O (O (O (O (O (O (I Z))))))))) => Reify (O n) Int8
instance Reify Z Int8
instance Nat (I n) => Reify (I n) Word64
instance Nat (O n) => Reify (O n) Word64
instance Reify Z Word64
instance Nat (I n) => Reify (I n) Word32
instance Nat (O n) => Reify (O n) Word32
instance Reify Z Word32
instance (Nat (I n), Lesser (I n) (O (O (O (O (O (O (O (O (O (O (O (O (O (O (O (O (I Z)))))))))))))))))) => Reify (I n) Word16
instance (Nat (O n), Lesser (O n) (O (O (O (O (O (O (O (O (O (O (O (O (O (O (O (O (I Z)))))))))))))))))) => Reify (O n) Word16
instance Reify Z Word16
instance (Nat (I n), Lesser (I n) (O (O (O (O (O (O (O (O (I Z)))))))))) => Reify (I n) Word8
instance (Nat (O n), Lesser (O n) (O (O (O (O (O (O (O (O (I Z)))))))))) => Reify (O n) Word8
instance Reify Z Word8
instance Nat (I n) => Reify (I n) Int
instance Nat (O n) => Reify (O n) Int
instance Reify Z Int
instance Nat (I n) => Reify (I n) Integer
instance Nat (O n) => Reify (O n) Integer
instance Reify Z Integer
instance Show SomeNat
instance (Nat n, Positive n) => Pos n
instance Number_Is_Denormalized Z => Nat (O Z)
instance Nat (I n) => Nat (I (I n))
instance Nat (I n) => Nat (O (I n))
instance Nat (O n) => Nat (I (O n))
instance Nat (O n) => Nat (O (O n))
instance Nat (I Z)
instance Nat Z

module TypeLevel.Number.Nat.Num
type N0 = Z
type N1 = I Z
type N2 = O (I Z)
type N3 = I (I Z)
type N4 = O (O (I Z))
type N5 = I (O (I Z))
type N6 = O (I (I Z))
type N7 = I (I (I Z))
type N8 = O (O (O (I Z)))
type N9 = I (O (O (I Z)))
n0 :: N0
n1 :: N1
n2 :: N2
n3 :: N3
n4 :: N4
n5 :: N5
n6 :: N6
n7 :: N7
n8 :: N8
n9 :: N9


-- | Type level signed integer numbers are implemented using balanced
--   ternary encoding much in the same way as natural numbers.
--   
--   Currently following operations are supported: Next, Prev, Add, Sub,
--   Mul.
module TypeLevel.Number.Int

-- | Digit stream terminator
data ZZ

-- | Digit -1
data Dn n

-- | Digit 0
data D0 n

-- | Digit 1
data D1 n

-- | Type class for type level integers. Only numbers without leading
--   zeroes are members of the class.
class IntT n
toInt :: (IntT n, Integral i) => n -> i

-- | Some natural number
data SomeInt

-- | Apply function which could work with any <tt>Nat</tt> value only know
--   at runtime.
withInt :: Integral i => (forall n. IntT n => n -> a) -> i -> a

-- | Generate type for integer number.
intT :: Integer -> TypeQ
instance Typeable SomeInt
instance Show SomeInt
instance IntT (D1 n) => Show (D1 n)
instance IntT (D0 n) => Show (D0 n)
instance IntT (Dn n) => Show (Dn n)
instance Show ZZ
instance IntT (D1 n) => IntT (D1 (D1 n))
instance IntT (D1 n) => IntT (D0 (D1 n))
instance IntT (D1 n) => IntT (Dn (D1 n))
instance IntT (D0 n) => IntT (D1 (D0 n))
instance IntT (D0 n) => IntT (D0 (D0 n))
instance IntT (D0 n) => IntT (Dn (D0 n))
instance IntT (Dn n) => IntT (D1 (Dn n))
instance IntT (Dn n) => IntT (D0 (Dn n))
instance IntT (Dn n) => IntT (Dn (Dn n))
instance IntT (Dn ZZ)
instance IntT (D1 ZZ)
instance IntT ZZ
