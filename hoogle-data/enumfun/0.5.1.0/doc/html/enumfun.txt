-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Finitely represented /total/ EnumMaps
--   
--   Finitely represented <i>total</i> EnumMaps. Comprises a partial
--   EnumMap and a default value. Has Applicative and Monad instances,
--   unlike EnumMap.
--   
--   Inspired by Conal's Data.TotalMap:
--   <a>http://hackage.haskell.org/package/total-map</a>
@package enumfun
@version 0.5.1.0


-- | Finitely represented <i>total</i> EnumMaps. Comprises a partial
--   EnumMap and a default value. Has Applicative and Monad instances,
--   unlike EnumMap.
--   
--   Inspired by Conal's Data.TotalMap:
--   <a>http://hackage.haskell.org/package/total-map</a>
module Data.EnumFun.Strict

-- | Total EnumMap.
data EnumFun k v

-- | Default value and a finite map.
EnumFun :: !v -> !(EnumMap k v) -> EnumFun k v

-- | Sample a total map. Semantic function.
(!) :: Enum k => EnumFun k v -> k -> v

-- | Optimise an <a>EnumFun</a>, weeding out any explicit default values. A
--   semantic no-op, i.e., <tt>(!) . trim == (!)</tt>.
trim :: Eq v => EnumFun k v -> EnumFun k v

-- | Create an <a>EnumFun</a> from a default value and a list of key/value
--   pairs.
fromList :: Enum k => v -> [(k, v)] -> EnumFun k v

-- | Convert from a Lazy EnumFun. The operation is essentially free; we
--   only needed two distinct types for the different class instances.
fromLazy :: EnumFun k v -> EnumFun k v
instance Enum k => Monad (EnumFun k)
instance (Enum k, Monoid v) => Monoid (EnumFun k v)
instance Enum k => Applicative (EnumFun k)


-- | Finitely represented <i>total</i> EnumMaps. Comprises a partial
--   EnumMap and a default value. Has Applicative and Monad instances,
--   unlike EnumMap.
--   
--   Inspired by Conal's Data.TotalMap:
--   <a>http://hackage.haskell.org/package/total-map</a>
module Data.EnumFun.Lazy

-- | Total EnumMap.
data EnumFun k v

-- | Default value and a finite map.
EnumFun :: v -> (EnumMap k v) -> EnumFun k v

-- | Sample a total map. Semantic function.
(!) :: Enum k => EnumFun k v -> k -> v

-- | Optimise an <a>EnumFun</a>, weeding out any explicit default values. A
--   semantic no-op, i.e., <tt>(!) . trim == (!)</tt>.
trim :: Eq v => EnumFun k v -> EnumFun k v

-- | Create an <a>EnumFun</a> from a default value and a list of key/value
--   pairs.
fromList :: Enum k => v -> [(k, v)] -> EnumFun k v

-- | Convert from a Strict EnumFun. The operation is essentially free; we
--   only needed two distinct types for the different class instances.
fromStrict :: EnumFun k v -> EnumFun k v
instance Enum k => Monad (EnumFun k)
instance (Enum k, Monoid v) => Monoid (EnumFun k v)
instance Enum k => Applicative (EnumFun k)
