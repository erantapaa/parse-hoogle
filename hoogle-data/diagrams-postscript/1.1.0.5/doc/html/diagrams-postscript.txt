-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Postscript backend for diagrams drawing EDSL
--   
@package diagrams-postscript
@version 1.1.0.5


-- | Generic tools for generating Postscript files. There is some limited
--   support for tracking the state of the renderer when given a
--   side-effecting (in the Postscript) command. Only drawing operations
--   are supported, not general Postscript language generation.
--   
--   In the future the tracking of rendering state could lead to optimizing
--   output, but for now little optimization is attempted. Most systems are
--   equiped with tools to optimize Postscript such as <tt>eps2eps</tt>.
--   
--   For details on the PostScript language see the PostScript(R) Language
--   Reference:
--   <a>http://www.adobe.com/products/postscript/pdfs/PLRM.pdf</a>
module Graphics.Rendering.Postscript

-- | Type of the monad that tracks the state from side-effecting commands.
data Render m
data RenderState
drawState :: Lens' RenderState DrawState

-- | Abstraction of the drawing surface details.
data Surface

-- | Type for a monad that writes Postscript using the commands we will
--   define later.
newtype PSWriter m
PSWriter :: WriterT (DList String) IO m -> PSWriter m
runPSWriter :: PSWriter m -> WriterT (DList String) IO m

-- | Handles opening and closing the file associated with the passed
--   <a>Surface</a> and renders the commands built up in the <a>Render</a>
--   argument.
renderWith :: MonadIO m => Surface -> Render a -> m a

-- | Renders multiple pages given as a list of <a>Render</a> actions to the
--   file associated with the <a>Surface</a> argument.
renderPagesWith :: MonadIO m => Surface -> [Render a] -> m [a]

-- | Builds a surface and performs an action on that surface.
withEPSSurface :: String -> Int -> Int -> (Surface -> IO a) -> IO a

-- | Start a new path.
newPath :: Render ()

-- | Move the current point.
moveTo :: Double -> Double -> Render ()

-- | Add a line to the current path from the current point to the given
--   point. The current point is also moved with this command.
lineTo :: Double -> Double -> Render ()

-- | Add a cubic Bézier curve segment to the current path from the current
--   point. The current point is also moved with this command.
curveTo :: Double -> Double -> Double -> Double -> Double -> Double -> Render ()

-- | Add a line segment to the current path using relative coordinates.
relLineTo :: Double -> Double -> Render ()

-- | Add a cubic Bézier curve segment to the current path from the current
--   point using relative coordinates.
relCurveTo :: Double -> Double -> Double -> Double -> Double -> Double -> Render ()

-- | Draw an arc given a center, radius, start, and end angle.
arc :: Double -> Double -> Double -> Double -> Double -> Render ()

-- | Close the current path.
closePath :: Render ()

-- | Stroke the current path.
stroke :: Render ()
fill :: Render ()

-- | Fill the current path without affecting the graphics state.
fillPreserve :: Render ()

-- | Apply a transform matrix to the current transform.
transform :: Double -> Double -> Double -> Double -> Double -> Double -> Render ()

-- | Push the current state of the renderer onto the state stack.
save :: Render ()

-- | Replace the current state by popping the state stack.
restore :: Render ()

-- | Push the current graphics state.
gsave :: Render ()

-- | Pop the current graphics state.
grestore :: Render ()

-- | Push the current transform matrix onto the execution stack.
saveMatrix :: Render ()

-- | Set the current transform matrix to be the matrix found by popping the
--   execution stack.
restoreMatrix :: Render ()

-- | Translate the current transform matrix.
translate :: Double -> Double -> Render ()

-- | Scale the current transform matrix.
scale :: Double -> Double -> Render ()

-- | Rotate the current transform matrix.
rotate :: Double -> Render ()

-- | Set the color of the stroke. Ignore gradients.
strokeColor :: Texture -> Render ()

-- | Set the color of the stroke.
strokeColorCMYK :: CMYK -> Render ()

-- | Set the color of the fill. Ignore gradients.
fillColor :: Texture -> Render ()

-- | Set the color of the fill.
fillColorCMYK :: CMYK -> Render ()

-- | Set the line width.
lineWidth :: Double -> Render ()

-- | Set the line cap style.
lineCap :: LineCap -> Render ()

-- | Set the line join method.
lineJoin :: LineJoin -> Render ()

-- | Set the miter limit.
miterLimit :: Double -> Render ()

-- | Set the dash style.
setDash :: [Double] -> Double -> Render ()

-- | Draw a string at the current point.
showText :: String -> Render ()

-- | Draw a string by first measuring the width then offseting by half.
showTextCentered :: String -> Render ()

-- | Draw a string with offset factors from center relative to the width
--   and height.
showTextAlign :: Double -> Double -> String -> Render ()

-- | Draw a string uniformally scaling to fit within a bounding box.
showTextInBox :: (Double, Double) -> (Double, Double) -> String -> Render ()

-- | Clip with the current path.
clip :: Render ()
data FontSlant
FontSlantNormal :: FontSlant
FontSlantItalic :: FontSlant
FontSlantOblique :: FontSlant
FontSlant :: Double -> FontSlant
data FontWeight
FontWeightNormal :: FontWeight
FontWeightBold :: FontWeight
face :: Lens' PostscriptFont String
slant :: Lens' PostscriptFont FontSlant
weight :: Lens' PostscriptFont FontWeight
size :: Lens' PostscriptFont Double
isLocal :: Lens' PostscriptFont Bool
fillRule :: Lens' DrawState FillRule
ignoreFill :: Lens' DrawState Bool
font :: Lens' DrawState PostscriptFont
data CMYK
CMYK :: Double -> Double -> Double -> Double -> CMYK
_cyan :: CMYK -> Double
_magenta :: CMYK -> Double
_yellow :: CMYK -> Double
_blacK :: CMYK -> Double
cyan :: Lens' CMYK Double
magenta :: Lens' CMYK Double
yellow :: Lens' CMYK Double
blacK :: Lens' CMYK Double
instance Functor PSWriter
instance Applicative PSWriter
instance Monad PSWriter
instance MonadWriter (DList String) PSWriter
instance Functor Render
instance Applicative Render
instance Monad Render
instance MonadState RenderState Render
instance Eq DrawState
instance Show FontSlant
instance Eq FontSlant
instance Show FontWeight
instance Eq FontWeight
instance Eq PostscriptFont
instance Show PostscriptFont
instance Show CMYK
instance Eq CMYK


-- | Support for CMYK color attributes in the Postscript backend.
module Diagrams.Backend.Postscript.CMYK
data CMYK
CMYK :: Double -> Double -> Double -> Double -> CMYK
_cyan :: CMYK -> Double
_magenta :: CMYK -> Double
_yellow :: CMYK -> Double
_blacK :: CMYK -> Double

-- | The color with which lines (strokes) are drawn. Note that child colors
--   always override parent colors; that is, <tt><a>lineColorCMYK</a> c1 .
--   <a>lineColorCMYK</a> c2 $ d</tt> is equivalent to
--   <tt><a>lineColorCMYK</a> c2 $ d</tt>. More precisely, the semigroup
--   structure on line color attributes is that of <a>Last</a>.
data LineColorCMYK
getLineColorCMYK :: LineColorCMYK -> CMYK
mkLineColorCMYK :: CMYK -> LineColorCMYK
styleLineColorCMYK :: Setter' (Style v) CMYK

-- | Set the line (stroke) color.
lineColorCMYK :: HasStyle a => CMYK -> a -> a

-- | Apply a <a>lineColorCMYK</a> attribute.
lineColorCMYKA :: HasStyle a => LineColorCMYK -> a -> a

-- | A synonym for <a>lineColorCMYK</a>.
lcCMYK :: HasStyle a => CMYK -> a -> a

-- | The color with which shapes are filled. Note that child colors always
--   override parent colors; that is, <tt><a>fillColorCMYK</a> c1 .
--   <a>fillColorCMYK</a> c2 $ d</tt> is equivalent to
--   <tt><a>lineColorCMYK</a> c2 $ d</tt>. More precisely, the semigroup
--   structure on fill color attributes is that of <a>Last</a>.
data FillColorCMYK
getFillColorCMYK :: FillColorCMYK -> CMYK
mkFillColorCMYK :: CMYK -> FillColorCMYK
styleFillColorCMYK :: Setter' (Style v) CMYK

-- | Set a "recommended" fill color, to be used only if no explicit calls
--   to <tt>fillColor</tt> (or <tt>fc</tt>, or <tt>fcA</tt>) are used.
recommendFillColorCMYK :: HasStyle a => CMYK -> a -> a

-- | Set the fill color.
fillColorCMYK :: HasStyle a => CMYK -> a -> a

-- | A synonym for <a>fillColorCMYK</a>
fcCMYK :: HasStyle a => CMYK -> a -> a
instance Typeable LineColorCMYK
instance Typeable FillColorCMYK
instance Semigroup LineColorCMYK
instance Semigroup FillColorCMYK
instance Default FillColorCMYK
instance AttributeClass FillColorCMYK
instance Default LineColorCMYK
instance AttributeClass LineColorCMYK


-- | A Postscript rendering backend for diagrams.
--   
--   To build diagrams for Postscript rendering use the <tt>Postscript</tt>
--   type in the diagram type construction
--   
--   <pre>
--   d :: Diagram Postscript R2
--   d = ...
--   </pre>
--   
--   and render giving the <tt>Postscript</tt> token
--   
--   <pre>
--   renderDia Postscript (PostscriptOptions "file.eps" (Width 400) EPS) d
--   </pre>
--   
--   This IO action will write the specified file.
module Diagrams.Backend.Postscript

-- | This data declaration is simply used as a token to distinguish this
--   rendering engine.
data Postscript
Postscript :: Postscript
type B = Postscript

-- | Backend-specific rendering options.
psfileName :: Lens' (Options Postscript R2) String
psSizeSpec :: Lens' (Options Postscript R2) SizeSpec2D
psOutputFormat :: Lens' (Options Postscript R2) OutputFormat

-- | Postscript only supports EPS style output at the moment. Future
--   formats would each have their own associated properties that affect
--   the output.
data OutputFormat

-- | Encapsulated Postscript output.
EPS :: OutputFormat
renderDias :: (Semigroup m, Monoid m) => Options Postscript R2 -> [QDiagram Postscript R2 m] -> IO [()]
instance Typeable Postscript
instance Typeable OutputFormat
instance Eq Postscript
instance Ord Postscript
instance Read Postscript
instance Show Postscript
instance Eq OutputFormat
instance Ord OutputFormat
instance Read OutputFormat
instance Show OutputFormat
instance Enum OutputFormat
instance Bounded OutputFormat
instance Generic OutputFormat
instance Show (Options Postscript R2)
instance Datatype D1OutputFormat
instance Constructor C1_0OutputFormat
instance Renderable Text Postscript
instance Renderable (Path R2) Postscript
instance Renderable (Trail R2) Postscript
instance Renderable (Segment Closed R2) Postscript
instance Hashable (Options Postscript R2)
instance Backend Postscript R2
instance Monoid (Render Postscript R2)
instance Hashable OutputFormat


-- | Convenient creation of command-line-driven executables for rendering
--   diagrams using the Postscript backend.
--   
--   <ul>
--   <li><a>defaultMain</a> creates an executable which can render a single
--   diagram at various options.</li>
--   <li><a>multiMain</a> is like <a>defaultMain</a> but allows for a list
--   of diagrams from which the user can choose one to render.</li>
--   <li><a>pagesMain</a> is like <a>defaultMain</a> but renders a list of
--   diagrams as pages in a single file.</li>
--   <li><a>animMain</a> renders an animation at a given frame rate into
--   separate files with an index number.</li>
--   <li><a>mainWith</a> is a generic form that does all of the above but
--   with a slightly scarier type. See <a>Diagrams.Backend.CmdLine</a>.
--   This form can also take a function type that has a subtable final
--   result (any of arguments to the above types) and <a>Parseable</a>
--   arguments.</li>
--   </ul>
--   
--   If you want to generate diagrams programmatically---<i>i.e.</i> if you
--   want to do anything more complex than what the below functions
--   provide---you have several options.
--   
--   <ul>
--   <li>Use a function with <a>mainWith</a>. This may require making
--   <a>Parseable</a> instances for custom argument types.</li>
--   <li>Make a new <a>Mainable</a> instance. This may require a newtype
--   wrapper on your diagram type to avoid the existing instances. This
--   gives you more control over argument parsing, intervening steps, and
--   diagram creation.</li>
--   <li>Build option records and pass them along with a diagram to
--   <a>mainRender</a> from <a>Diagrams.Backend.CmdLine</a>.</li>
--   <li>An even more flexible approach is to directly call
--   <a>renderDia</a>; see <a>Diagrams.Backend.Postscript</a> for more
--   information.</li>
--   </ul>
--   
--   For a tutorial on command-line diagram creation see
--   <a>http://projects.haskell.org/diagrams/doc/cmdline.html</a>.
module Diagrams.Backend.Postscript.CmdLine

-- | Main entry point for command-line diagram creation. This is the method
--   that users will call from their program <tt>main</tt>. For instance an
--   expected user program would take the following form.
--   
--   <pre>
--   import Diagrams.Prelude
--   import Diagrams.Backend.TheBestBackend.CmdLine
--   
--   d :: Diagram B R2
--   d = ...
--   
--   main = mainWith d
--   </pre>
--   
--   Most backends should be able to use the default implementation. A
--   different implementation should be used to handle more complex
--   interactions with the user.
mainWith :: (Mainable d, Parseable (MainOpts d)) => d -> IO ()

-- | This is the simplest way to render diagrams, and is intended to be
--   used like so:
--   
--   <pre>
--   ... other definitions ...
--   myDiagram = ...
--   
--   main = defaultMain myDiagram
--   </pre>
--   
--   Compiling a source file like the above example will result in an
--   executable which takes command-line options for setting the size,
--   output file, and so on, and renders <tt>myDiagram</tt> with the
--   specified options.
--   
--   Pass <tt>--help</tt> to the generated executable to see all available
--   options. Currently it looks something like
--   
--   <pre>
--   ./Program
--   
--   Usage: ./Program [-w|--width WIDTH] [-h|--height HEIGHT] [-o|--output OUTPUT]
--     Command-line diagram generation.
--   
--   Available options:
--     -?,--help                Show this help text
--     -w,--width WIDTH         Desired WIDTH of the output image
--     -h,--height HEIGHT       Desired HEIGHT of the output image
--     -o,--output OUTPUT       OUTPUT file
--   </pre>
--   
--   For example, a common scenario is
--   
--   <pre>
--   $ ghc --make MyDiagram
--   
--     # output image.eps with a width of 400pt (and auto-determined height)
--   $ ./MyDiagram -o image.eps -w 400
--   </pre>
defaultMain :: Diagram Postscript R2 -> IO ()

-- | <tt>multiMain</tt> is like <a>defaultMain</a>, except instead of a
--   single diagram it takes a list of diagrams paired with names as input.
--   The generated executable then takes a <tt>--selection</tt> option
--   specifying the name of the diagram that should be rendered. The list
--   of available diagrams may also be printed by passing the option
--   <tt>--list</tt>.
--   
--   Example usage:
--   
--   <pre>
--   $ ghc --make MultiTest
--   [1 of 1] Compiling Main             ( MultiTest.hs, MultiTest.o )
--   Linking MultiTest ...
--   $ ./MultiTest --list
--   Available diagrams:
--     foo bar
--   $ ./MultiTest --selection bar -o Bar.eps -w 200
--   </pre>
multiMain :: [(String, Diagram Postscript R2)] -> IO ()

-- | <tt>pagesMain</tt> is like <a>defaultMain</a>, except instead of a
--   single diagram it takes a list of diagrams and each will be rendered
--   as a page in the Postscript file.
--   
--   Example usage:
--   
--   <pre>
--   $ ghc --make MultiPage
--   [1 of 1] Compiling Main             ( MultiPage.hs, MultiPage.o )
--   Linking MultiPage ...
--   $ ./MultiPage -o Pages.ps -w 200
--   </pre>
pagesMain :: [Diagram Postscript R2] -> IO ()

-- | <tt>animMain</tt> is like <a>defaultMain</a>, but renders an animation
--   instead of a diagram. It takes as input an animation and produces a
--   command-line program which will crudely "render" the animation by
--   rendering one image for each frame, named by extending the given
--   output file name by consecutive integers. For example if the given
--   output file name is <tt>foo/blah.eps</tt>, the frames will be saved in
--   <tt>foo/blah001.eps</tt>, <tt>foo/blah002.eps</tt>, and so on (the
--   number of padding digits used depends on the total number of frames).
--   It is up to the user to take these images and stitch them together
--   into an actual animation format (using, <i>e.g.</i> <tt>ffmpeg</tt>).
--   
--   Of course, this is a rather crude method of rendering animations; more
--   sophisticated methods will likely be added in the future.
--   
--   The <tt>--fpu</tt> option can be used to control how many frames will
--   be output for each second (unit time) of animation.
animMain :: Animation Postscript R2 -> IO ()

-- | This data declaration is simply used as a token to distinguish this
--   rendering engine.
data Postscript
type B = Postscript
instance Mainable (Animation Postscript R2)
instance Mainable [Diagram Postscript R2]
instance Mainable [(String, Diagram Postscript R2)]
instance Mainable (Diagram Postscript R2)
