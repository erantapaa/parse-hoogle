-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Mix concurrent and sequential computation
--   
@package Concurrential
@version 0.5.0.0


-- | The functions <tt>sequentially</tt> and <tt>concurrently</tt> inject
--   <tt>IO</tt> terms into the <tt>ConcurrentialAp</tt> applicative
--   functor, whose applicative instance will exploit as much concurrency
--   as possible such that all <tt>sequentially</tt> terms will be run in
--   the order in which they would have been run had they been typical IOs.
--   
--   Terms of <tt>ConcurrentialAp</tt> can be transformed into terms of
--   <tt>Concurrential</tt>, which is a monad. The order of sequential
--   terms is respected even through binds; a sequential term will not be
--   evaluted until all binds appearing syntactically earlier than it have
--   been expanded.
module Control.Concurrent.Concurrential

-- | Description of computation which is composed of sequential and
--   concurrent parts in some monad <tt>m</tt>.
data Concurrential t

-- | Concurrential without a Monad instance, but an Applicative instance
--   which exploits concurrency.
newtype ConcurrentialAp t
ConcurrentialAp :: Concurrential t -> ConcurrentialAp t

-- | Run a Concurrential term, realizing the effects of the IO terms which
--   compose it.
runConcurrential :: Concurrential t -> (Async t -> IO r) -> IO r

-- | Create an effect which must be run sequentially. If a <tt>sequentially
--   io</tt> appears in a <tt>Concurrential t</tt> term then it will always
--   be run to completion before any later sequential part of the term is
--   run. Consider the following terms:
--   
--   <pre>
--   a = someConcurrential *&gt; sequentially io *&gt; someOtherConcurrential
--   b = someConcurrential *&gt; concurrently io *&gt; someOtherConcurrential
--   c = someConcurrential *&gt; sequentially io *&gt; concurrently otherIo
--   
--   </pre>
--   
--   When running the term <tt>a</tt>, we are guaranteed that <tt>io</tt>
--   is completed before any sequential part of
--   <tt>someOtherConcurrential</tt> is begun, but when running the term
--   <tt>b</tt>, this is not the case; <tt>io</tt> may be interleaved with
--   or even run after any part of <tt>someOtherConcurrential</tt>. The
--   term <tt>c</tt> highlights an important point: <tt>concurrently
--   otherIo</tt> may be run before, during or after <tt>sequentially
--   io</tt>! The ordering through applicative combinators is guaranteed
--   only among sequential terms.
sequentially :: IO t -> ConcurrentialAp t

-- | Create an effect which is run concurrently where possible, i.e.
--   whenever it combined applicatively with other terms. For instance:
--   
--   <pre>
--   a = concurrently io *&gt; someConcurrential
--   b = concurrently io &gt;&gt; someConcurrential
--   
--   </pre>
--   
--   When running the term <tt>a</tt>, the IO term <tt>io</tt> will be run
--   concurrently with <tt>someConcurrential</tt>, but not so in
--   <tt>b</tt>, because monadic composition has been used.
concurrently :: IO t -> ConcurrentialAp t

-- | Inject a ConcurrentialAp into Concurrential, losing the
--   concurrency-enabling Applicative instance but gaining a Monad
--   instance.
concurrentially :: ConcurrentialAp t -> Concurrential t

-- | Wait for an asynchronous action to complete, and return its value. If
--   the asynchronous action threw an exception, then the exception is
--   re-thrown by <a>wait</a>.
--   
--   <pre>
--   wait = atomically . waitSTM
--   </pre>
wait :: Async a -> IO a
instance Typeable SomeAsync
instance Typeable Choice
instance Typeable Concurrential
instance Typeable ConcurrentialAp
instance Functor Identity
instance Applicative ConcurrentialAp
instance Functor ConcurrentialAp
instance Monad Concurrential
instance Applicative Concurrential
instance Functor Concurrential
instance Functor m => Functor (Choice m)
instance Monad Identity
instance Applicative Identity
