-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Fast unboxed arrays with a flexible interface
--   
--   Fast unboxed arrays with a flexible interface. The library is built of
--   fusible combinators, as described in the paper /Stream Fusion: From
--   Lists to Streams to Nothing at All/.
--   
--   For best results, compile with your user programs with -O2 -fvia-C
--   -optc-O3.
--   
--   This library is deprecated: please consider using the vector package,
--   <a>http://hackage.haskell.org/package/vector</a>.
@package uvector
@version 0.1.1.1


-- | Description
--   --------------------------------------------------------------- This
--   module defines unlifted arrays generically as a GADT.
--   
--   Slicing is implemented by each <a>BUArr</a> having the slicing
--   information. A possible alternative design would be to maintain this
--   information in <a>UArr</a>, but not in the representations, but at the
--   root. This may seem attractive at first, but seems to be more
--   disruptive without any real benefits _ this is essentially, because we
--   then need the slicing information at each level; ie, also at the leafs
--   where it is sufficient using the current implementation.
--   
--   Todo
--   ----------------------------------------------------------------------
module Data.Array.Vector.UArr

-- | This type class determines the types that can be elements immutable
--   unboxed arrays. The representation type of these arrays is defined by
--   way of an associated type. All representation-dependent functions are
--   methods of this class.
class UA e where { data family UArr e; data family MUArr e :: * -> *; }
lengthU :: (UA e) => UArr e -> Int
indexU :: (UA e) => UArr e -> Int -> e
sliceU :: (UA e) => UArr e -> Int -> Int -> UArr e
lengthMU :: (UA e) => MUArr e s -> Int
newMU :: (UA e) => Int -> ST s (MUArr e s)
readMU :: (UA e) => MUArr e s -> Int -> ST s e
writeMU :: (UA e) => MUArr e s -> Int -> e -> ST s ()
copyMU :: (UA e) => MUArr e s -> Int -> UArr e -> ST s ()
unsafeFreezeMU :: (UA e) => MUArr e s -> Int -> ST s (UArr e)
memcpyMU :: (UA e) => MUArr e s -> MUArr e s -> Int -> ST s ()
memcpyOffMU :: (UA e) => MUArr e s -> MUArr e s -> Int -> Int -> Int -> ST s ()
memmoveOffMU :: (UA e) => MUArr e s -> MUArr e s -> Int -> Int -> Int -> ST s ()
class (UAE e) => UPrim e
mkUAPrim :: (UPrim e) => BUArr e -> UArr e
unUAPrim :: (UPrim e) => UArr e -> BUArr e
mkMUAPrim :: (UPrim e) => MBUArr s e -> MUArr e s
unMUAPrim :: (UPrim e) => MUArr e s -> MBUArr s e

-- | <i>O(1)</i>. Yield an array of units.
unitsU :: Int -> UArr ()

-- | <i>O(1)</i>. Elementwise pairing of array elements.
--   
--   <i>N.B</i>: The output will be as long as the first array (and will
--   thus access past the end of the second array), unlike its List
--   counterpart. This will not occur at the time zipU is called, but only
--   after the resulting array is accessed.
zipU :: (UA a, UA b) => UArr a -> UArr b -> UArr (a :*: b)

-- | <i>O(1)</i>. Elementwise unpairing of array elements.
unzipU :: (UA a, UA b) => UArr (a :*: b) -> (UArr a :*: UArr b)

-- | <i>O(1)</i>. Yield the first components of an array of pairs.
fstU :: (UA a, UA b) => UArr (a :*: b) -> UArr a

-- | <i>O(1)</i>. Yield the second components of an array of pairs.
sndU :: (UA a, UA b) => UArr (a :*: b) -> UArr b

-- | <i>O(n)</i>. <a>newU</a> constructs an immutable array of the given
--   size by performing the provided initialization function on a mutable
--   representation of the output array.
newU :: (UA e) => Int -> (forall s. MUArr e s -> ST s ()) -> UArr e
newDynU :: (UA e) => Int -> (forall s. MUArr e s -> ST s Int) -> UArr e
newDynResU :: (UA e) => Int -> (forall s. MUArr e s -> ST s (Int :*: r)) -> UArr e :*: r

-- | <i>O(1)</i>. <a>unsafeFreezeAllMU</a> converts an entire mutable array
--   into an immutable array, without copying. The mutable array must not
--   be mutated after this.
unsafeFreezeAllMU :: (UA e) => MUArr e s -> ST s (UArr e)

-- | Elementwise pairing of mutable arrays. This is an unsafe operation, as
--   no copying is performed, so changes to the pair array will affect the
--   original arrays, and vice versa.
unsafeZipMU :: (UA a, UA b) => MUArr a s -> MUArr b s -> MUArr (a :*: b) s

-- | Elementwise unpairing of mutable arrays. This is an unsafe operation,
--   as no copying is performed, so changes to the unpaired arrays will
--   affect the original, and vice versa.
unsafeUnzipMU :: (UA a, UA b) => MUArr (a :*: b) s -> MUArr a s :*: MUArr b s
instance (Integral a, UA a) => UA (Ratio a)
instance (RealFloat a, UA a) => UA (Complex a)
instance UA Int64
instance UPrim Int64
instance UA Int32
instance UPrim Int32
instance UA Int16
instance UPrim Int16
instance UA Int8
instance UPrim Int8
instance UA Word64
instance UPrim Word64
instance UA Word32
instance UPrim Word32
instance UA Word16
instance UPrim Word16
instance UA Word8
instance UPrim Word8
instance UA Double
instance UPrim Double
instance UA Float
instance UPrim Float
instance UA Word
instance UPrim Word
instance UA Int
instance UPrim Int
instance UA Char
instance UPrim Char
instance UA Bool
instance UPrim Bool
instance (UA a, UA b) => UA (a :*: b)
instance UA ()


-- | The top level interface to operations on strict, non-nested, fusible
--   arrays.
--   
--   Note that the time complexities provided for functions in this package
--   depend on fusion. Thus the times given assume that fusion did not
--   occur and that the full operation is performed. In some cases fusion
--   can take multiple <i>O(n)</i> operations on UArrs and optimize them
--   out of the generated code completely.
module Data.Array.Vector

-- | This type class determines the types that can be elements immutable
--   unboxed arrays. The representation type of these arrays is defined by
--   way of an associated type. All representation-dependent functions are
--   methods of this class.
class UA e where { data family UArr e; data family MUArr e :: * -> *; }
sliceU :: (UA e) => UArr e -> Int -> Int -> UArr e
lengthMU :: (UA e) => MUArr e s -> Int
newMU :: (UA e) => Int -> ST s (MUArr e s)
readMU :: (UA e) => MUArr e s -> Int -> ST s e
writeMU :: (UA e) => MUArr e s -> Int -> e -> ST s ()
copyMU :: (UA e) => MUArr e s -> Int -> UArr e -> ST s ()
unsafeFreezeMU :: (UA e) => MUArr e s -> Int -> ST s (UArr e)
memcpyMU :: (UA e) => MUArr e s -> MUArr e s -> Int -> ST s ()
memcpyOffMU :: (UA e) => MUArr e s -> MUArr e s -> Int -> Int -> Int -> ST s ()
memmoveOffMU :: (UA e) => MUArr e s -> MUArr e s -> Int -> Int -> Int -> ST s ()

-- | <i>O(1)</i>. <a>streamU</a> generates a stream from an array, from
--   left to right.
streamU :: (UA a) => UArr a -> Stream a

-- | <i>O(n)</i>. <a>unstreamU</a> creates an array from a stream, filling
--   it from left to right.
unstreamU :: (UA a) => Stream a -> UArr a

-- | <i>O(n)</i>. <a>toU</a> turns a list into a <a>UArr</a>.
toU :: (UA e) => [e] -> UArr e

-- | <i>O(n)</i>. <a>fromU</a> collects the elements of a <a>UArr</a> into
--   a list.
fromU :: (UA e) => UArr e -> [e]

-- | <i>O(1)</i>. <a>emptyU</a> yields an empty array.
emptyU :: (UA e) => UArr e

-- | <i>O(1)</i>. <a>singletonU</a> yields a singleton array containing the
--   given element.
singletonU :: (UA e) => e -> UArr e

-- | <i>O(n)</i>. <a>consU</a> prepends the given element to an array.
consU :: (UA e) => e -> UArr e -> UArr e

-- | <i>O(n)</i>. <a>snocU</a> appends the given element to an array.
snocU :: (UA e) => UArr e -> e -> UArr e

-- | <i>O(n)</i>. <a>appendU</a> concatenates two arrays.
appendU :: (UA e) => UArr e -> UArr e -> UArr e

-- | <i>O(n)</i>. Concatenate a list of arrays.
concatU :: (UA e) => [UArr e] -> UArr e

-- | <i>O(1)</i>. <a>headU</a> yields the first element of an array.
headU :: (UA e) => UArr e -> e

-- | <i>O(n)</i>. <a>lastU</a> yields the last element of an array.
lastU :: (UA e) => UArr e -> e

-- | <i>O(n)</i>. <a>tailU</a> yields the given array without its initial
--   element.
tailU :: (UA e) => UArr e -> UArr e

-- | <i>O(n)</i>. <a>initU</a> yields the input array without its last
--   element.
initU :: (UA e) => UArr e -> UArr e

-- | <i>O(1)</i>. <a>nullU</a> tests whether the given array is empty.
nullU :: (UA e) => UArr e -> Bool

-- | <i>O(1)</i>. Yield an array of units.
unitsU :: Int -> UArr ()

-- | <i>O(1)</i>. <a>lengthU</a> returns the length of a <a>UArr</a> as an
--   <a>Int</a>.
lengthU :: (UA e) => UArr e -> Int

-- | <i>O(n)</i>. <a>mapU</a> maps a function over an array.
mapU :: (UA e, UA e') => (e -> e') -> UArr e -> UArr e'

-- | <i>O(n)</i>. <a>foldU</a> reduces an array using an associative
--   combination function and its unit.
foldU :: (UA a) => (a -> a -> a) -> a -> UArr a -> a

-- | <i>O(n)</i>. <a>fold1U</a> is a variant of <a>foldU</a> that requires
--   a non-empty input array. Throws an exception if its input array is
--   empty.
fold1U :: (UA a) => (a -> a -> a) -> UArr a -> a

-- | <i>O(n)</i>. <a>fold1MaybeU</a> behaves like <a>fold1U</a> but returns
--   <a>NothingS</a> if the input array is empty.
fold1MaybeU :: (UA a) => (a -> a -> a) -> UArr a -> MaybeS a

-- | <i>O(n)</i>. <a>foldlU</a> reduces an array proceeding from the left.
foldlU :: (UA a) => (b -> a -> b) -> b -> UArr a -> b

-- | <i>O(n)</i>. <a>foldl1U</a> is a variant of <a>foldlU</a> that assumes
--   a non-empty input array, but requires no starting element. Throws an
--   exception if the input array is empty.
foldl1U :: (UA a) => (a -> a -> a) -> UArr a -> a

-- | <i>O(n)</i> <a>foldrU</a>, applied to a binary operator, a starting
--   value (typically the right-identity of the operator), and a 'UArr a',
--   reduces the 'UArr a' using the binary operator, from right to left.
foldrU :: (UA a) => (a -> b -> b) -> b -> UArr a -> b

-- | <i>O(n)</i> A variant of <a>foldr</a> that has no starting value
--   argument, and thus must be applied to a non-empty 'UArr a'.
foldr1U :: (UA a) => (a -> a -> a) -> UArr a -> a

-- | <i>O(n)</i>. <a>foldl1MaybeU</a> behaves like <a>foldl1U</a> but
--   returns <a>NothingS</a> if the input array is empty.
foldl1MaybeU :: (UA a) => (a -> a -> a) -> UArr a -> MaybeS a

-- | <i>O(n)</i>. <a>andU</a> yields the conjunction of a boolean array.
andU :: UArr Bool -> Bool

-- | <i>O(n)</i>. <a>andU</a> yields the disjunction of a boolean array.
orU :: UArr Bool -> Bool

-- | <i>O(n)</i>. <tt><a>anyU</a> p u</tt> determines whether any element
--   in array <tt>u</tt> satisfies predicate <tt>p</tt>.
anyU :: (UA e) => (e -> Bool) -> UArr e -> Bool

-- | <i>O(n)</i>. <tt><a>allU</a> p u</tt> determines whether all elements
--   in array <tt>u</tt> satisfy predicate <tt>p</tt>.
allU :: (UA e) => (e -> Bool) -> UArr e -> Bool

-- | <i>O(n)</i>. <a>sumU</a> computes the sum of an array of a <a>Num</a>
--   instance.
sumU :: (Num e, UA e) => UArr e -> e

-- | <i>O(n)</i>. <a>productU</a> computes the product of an array of a
--   <a>Num</a> instance.
productU :: (Num e, UA e) => UArr e -> e

-- | <i>O(n)</i>. <a>maximumU</a> finds the maximum element in an array of
--   orderable elements.
maximumU :: (Ord e, UA e) => UArr e -> e

-- | <i>O(n)</i>. <a>minimumU</a> finds the minimum element in an array of
--   orderable elements.
minimumU :: (Ord e, UA e) => UArr e -> e

-- | <i>O(n)</i>. <a>maximumByU</a> finds the maximum element in an array
--   under the given ordering.
maximumByU :: (UA e) => (e -> e -> Ordering) -> UArr e -> e

-- | <i>O(n)</i>. <a>minimumByU</a> finds the minimum element in an array
--   under the given ordering.
minimumByU :: (UA e) => (e -> e -> Ordering) -> UArr e -> e

-- | <i>O(n)</i>. <a>scanlU</a> is equivalent to <a>foldlU</a> on all
--   prefixes (except the array itself) of the input array.
--   
--   <i>N.B</i>: the behavior of this function differs from that of
--   Data.List. Compare:
--   
--   <tt>scanl (+) 0.0 [1..5]</tt> gives
--   <tt>[0.0,1.0,3.0,6.0,10.0,15.0]</tt>
--   
--   <tt>scanlU (+) 0.0 $ toU [1..5]</tt> gives <tt>toU
--   [0.0,1.0,3.0,6.0,10.0]</tt>
--   
--   To get behavior closer to the List counterpart, see <a>scanResU</a>.
scanlU :: (UA a, UA b) => (b -> a -> b) -> b -> UArr a -> UArr b

-- | <i>O(n)</i>. <a>scanl1U</a> is like <a>scanlU</a>, but requires no
--   starting value.
scanl1U :: (UA a) => (a -> a -> a) -> UArr a -> UArr a

-- | <i>O(n)</i>. <a>scanU</a> is equivalent to <a>foldU</a> on all
--   prefixes (except the array itself) of the input array.
scanU :: (UA a) => (a -> a -> a) -> a -> UArr a -> UArr a

-- | <i>O(n)</i>. <a>scan1U</a> is like <a>scanU</a>, but requires no
--   starting value.
scan1U :: (UA a) => (a -> a -> a) -> UArr a -> UArr a

-- | <i>O(n)</i>. <a>scanResU</a> behaves like <a>scanU</a>, but yields a
--   strict pair with the <a>scanU</a> result as its <tt>fstS</tt> and the
--   <a>missing</a> element (<a>foldU</a> on the same arguments) as its
--   <tt>sndS</tt>. Compare:
--   
--   <tt>scanl (+) 0.0 [1..5]</tt> gives
--   <tt>[0.0,1.0,3.0,6.0,10.0,15.0]</tt>
--   
--   <tt>scanlU (+) 0.0 $ toU [1..5]</tt> gives <tt>toU
--   [0.0,1.0,3.0,6.0,10.0]</tt>
--   
--   <tt>scanResU (+) 0.0 $ toU [1..5]</tt> gives <tt>toU
--   [0.0,1.0,3.0,6.0,10.0] :*: 15.0</tt>.
scanResU :: (UA a) => (a -> a -> a) -> a -> UArr a -> UArr a :*: a

-- | <i>O(n)</i>. <a>mapAccumLU</a> is an accumulating map from left to
--   right. Unlike its List counterpart, it does not return the
--   accumulator.
mapAccumLU :: (UA a, UA b) => (c -> a -> c :*: b) -> c -> UArr a -> UArr b

-- | <i>O(n)</i>. <tt><a>iterateU</a> n f a</tt> constructs an array of
--   size <tt>n</tt> by iteratively applying <tt>f</tt> to <tt>a</tt>.
iterateU :: (UA a) => Int -> (a -> a) -> a -> UArr a

-- | <i>O(n)</i>. <tt><a>replicateU</a> n e</tt> yields an array containing
--   <tt>n</tt> repetitions of <tt>e</tt>.
replicateU :: (UA e) => Int -> e -> UArr e

-- | <i>O(n)</i>. <tt><a>replicateEachU</a> n r e</tt> yields an array such
--   that each element in <tt>e</tt> is repeated as many times as the value
--   contained at the corresponding index in <tt>r</tt>. For example:
--   
--   <tt>replicateEachU 10 (toU [1..3]) (toU [3..5])</tt> yields <tt>toU
--   [3.0,4.0,4.0,5.0,5.0,5.0]</tt>
--   
--   <i>N.B</i>: the <tt>n</tt> parameter specifies how many elements are
--   <i>allocated</i> for the output array, but the function will happily
--   overrun the allocated buffer for all sorts of interesting effects! The
--   caller is expected to ensure that <tt>n &lt;= sumU r</tt>.
replicateEachU :: (UA e) => Int -> UArr Int -> UArr e -> UArr e

-- | <i>O(n)</i>. <tt><a>unfoldU</a> n f z</tt> builds an array of size
--   <tt>n</tt> from a seed value <tt>z</tt> by iteratively applying
--   <tt>f</tt>, stopping when <tt>n</tt> elements have been generated or
--   <tt>f</tt> returns <a>NothingS</a>.
unfoldU :: (UA a) => Int -> (b -> MaybeS (a :*: b)) -> b -> UArr a

-- | <i>O(n)</i>. <a>takeU</a> yields the prefix of the given length of an
--   array.
takeU :: (UA e) => Int -> UArr e -> UArr e

-- | <i>O(n)</i>. <a>dropU</a> yields the suffix obtained by dropping the
--   given number of elements from an array.
dropU :: (UA e) => Int -> UArr e -> UArr e

-- | <i>O(n)</i>. <a>splitAtU</a> splits an array into two subarrays at the
--   given index.
splitAtU :: (UA e) => Int -> UArr e -> (UArr e, UArr e)

-- | <i>O(n)</i>. <a>takeWhileU</a>, applied to a predicate <tt>p</tt> and
--   a UArr <tt>xs</tt>, returns the longest prefix (possibly empty) of
--   <tt>xs</tt> of elements that satisfy <tt>p</tt>.
takeWhileU :: (UA e) => (e -> Bool) -> UArr e -> UArr e

-- | <i>O(n)</i>. <a>dropWhileU</a> <tt>p xs</tt> returns the suffix
--   remaining after <a>takeWhileU</a> <tt>p xs</tt>.
dropWhileU :: (UA e) => (e -> Bool) -> UArr e -> UArr e

-- | <i>O(n)</i>. <a>elemU</a> determines whether the given element is in
--   an array.
elemU :: (Eq e, UA e) => e -> UArr e -> Bool

-- | <i>O(n)</i>. Negation of <a>elemU</a>.
notElemU :: (Eq e, UA e) => e -> UArr e -> Bool

-- | <i>O(n)</i>. <a>filterU</a> extracts all elements from an array that
--   satisfy the given predicate.
filterU :: (UA e) => (e -> Bool) -> UArr e -> UArr e

-- | <i>O(n)</i>, <i>fusion</i>. The <a>findU</a> function takes a
--   predicate and an array and returns the first element in the list
--   matching the predicate, or <a>Nothing</a> if there is no such element.
findU :: (UA a) => (a -> Bool) -> UArr a -> Maybe a

-- | <i>O(n)</i>, <i>fusion</i>. The <a>findIndexU</a> function takes a
--   predicate and an array and returns the index of the first element in
--   the array satisfying the predicate, or <a>Nothing</a> if there is no
--   such element.
findIndexU :: (UA a) => (a -> Bool) -> UArr a -> Maybe Int

-- | <a>indexU</a> extracts an element out of an immutable unboxed array.
--   
--   TODO: use indexU, the non-streaming version.
indexU :: (UA e) => UArr e -> Int -> e

-- | <i>O(n)</i>, <i>fusion</i>. <a>lookupU</a> <tt>key assocs</tt> looks
--   up a key in an array of pairs treated as an association table.
lookupU :: (Eq a, UA a, UA b) => a -> UArr (a :*: b) -> Maybe b

-- | <i>O(1)</i>. Elementwise pairing of array elements.
--   
--   <i>N.B</i>: The output will be as long as the first array (and will
--   thus access past the end of the second array), unlike its List
--   counterpart. This will not occur at the time zipU is called, but only
--   after the resulting array is accessed.
zipU :: (UA a, UA b) => UArr a -> UArr b -> UArr (a :*: b)

-- | <i>O(1)</i>. <a>zip3U</a> takes three arrays and returns an array of
--   triples.
zip3U :: (UA e1, UA e2, UA e3) => UArr e1 -> UArr e2 -> UArr e3 -> UArr ((e1 :*: e2) :*: e3)

-- | <i>O(1)</i>. Elementwise unpairing of array elements.
unzipU :: (UA a, UA b) => UArr (a :*: b) -> (UArr a :*: UArr b)

-- | <i>O(1)</i>. <a>unzip3U</a> unpairs an array of strict triples into
--   three arrays.
unzip3U :: (UA e1, UA e2, UA e3) => UArr ((e1 :*: e2) :*: e3) -> ((UArr e1 :*: UArr e2) :*: UArr e3)

-- | <i>O(n)</i>. <a>zipWithU</a> applies a function to corresponding
--   elements of two arrays, yielding an array containing the results.
zipWithU :: (UA a, UA b, UA c) => (a -> b -> c) -> UArr a -> UArr b -> UArr c

-- | <i>O(n)</i>. <a>zipWith3U</a> applies a function to corresponding
--   elements of three arrays, yielding an array with the results.
zipWith3U :: (UA a, UA b, UA c, UA d) => (a -> b -> c -> d) -> UArr a -> UArr b -> UArr c -> UArr d

-- | <i>O(1)</i>. Yield the first components of an array of pairs.
fstU :: (UA a, UA b) => UArr (a :*: b) -> UArr a

-- | <i>O(1)</i>. Yield the second components of an array of pairs.
sndU :: (UA a, UA b) => UArr (a :*: b) -> UArr b

-- | <i>O(n)</i>. <a>enumFromToU</a> yields an enumerated array, analogous
--   to <a>enumFromTo</a>, but only works on instances of Integral.
enumFromToU :: (UA a, Integral a) => a -> a -> UArr a

-- | <i>O(n)</i>. Like <a>enumFromToU</a>, but works on fractional numbers
--   (still incrementing by 1 each time).
enumFromToFracU :: (UA a, RealFrac a) => a -> a -> UArr a

-- | <i>O(n)</i>. <a>enumFromThenToU</a> yields an enumerated array using a
--   specific step value.
enumFromThenToU :: Int -> Int -> Int -> UArr Int

-- | <i>O(n)</i>. <tt><a>enumFromStepLenU</a> s d n</tt> yields an
--   enumerated array of length <tt>n</tt> starting from <tt>s</tt> with an
--   increment of <tt>d</tt>.
enumFromStepLenU :: Int -> Int -> Int -> UArr Int

-- | <i>O(n)</i>. <tt><a>enumFromToEachU</a> n u</tt> yields an array by
--   taking each strict pair <tt>u</tt> and treating it as a range to
--   generate successive values over. For example:
--   
--   <tt>enumFromToEachU 7 (toU [3 :*: 6, 8 :*: 10])</tt> yields <tt>toU
--   [3,4,5,6,8,9,10]</tt>
--   
--   <i>N.B</i>: This function will allocate <tt>n</tt> slots for the
--   output array, and will happily overrun its allocated space if the
--   <tt>u</tt> leads it to do so. The caller is expected to ensure that
--   <tt>n <a>= (sumU . mapU (\(x :*: y) -</a> y - x + 1) $ u)</tt>.
enumFromToEachU :: Int -> UArr (Int :*: Int) -> UArr Int

-- | <i>O(n)</i>. <tt><a>combineU</a> f a1 a2</tt> yields an array by
--   picking elements from <tt>a1</tt> if <tt>f</tt> is <tt>True</tt> at
--   the given position, and picking elements from <tt>a2</tt> otherwise.
--   For example:
--   
--   <pre>
--   combineU (toU [True,True,False,True,False,False]) (toU [1..3]) (toU [4..6])
--   </pre>
--   
--   yields <tt>toU [1.0,2.0,4.0,3.0,5.0,6.0]</tt>.
combineU :: (UA a) => UArr Bool -> UArr a -> UArr a -> UArr a

-- | <i>O(n)</i>. <a>packU</a> extracts all elements from an array
--   according to the provided flag array. For example:
--   
--   <pre>
--   packU (toU [1..5]) (toU [True,False,False,False,True])
--   </pre>
--   
--   yields <tt>toU [1.0,5.0]</tt>.
packU :: (UA e) => UArr e -> UArr Bool -> UArr e

-- | <i>O(n)</i>. <a>indexedU</a> associates each element of the array with
--   its index.
indexedU :: (UA e) => UArr e -> UArr (Int :*: e)

-- | <i>O(n)</i>. <tt><a>repeatU</a> n u</tt> repeats an array <tt>u</tt>
--   <tt>n</tt> times.
repeatU :: (UA e) => Int -> UArr e -> UArr e

-- | <i>O(n)</i>. <a>newU</a> constructs an immutable array of the given
--   size by performing the provided initialization function on a mutable
--   representation of the output array.
newU :: (UA e) => Int -> (forall s. MUArr e s -> ST s ()) -> UArr e

-- | <i>O(1)</i>. <a>unsafeFreezeAllMU</a> converts an entire mutable array
--   into an immutable array, without copying. The mutable array must not
--   be mutated after this.
unsafeFreezeAllMU :: (UA e) => MUArr e s -> ST s (UArr e)

-- | <i>O(n)</i>. <a>permuteMU</a> permutes a <a>MUArr</a> according to a
--   UArr of permuted indices.
permuteMU :: (UA e) => MUArr e s -> UArr e -> UArr Int -> ST s ()

-- | <i>O(n)</i>. <tt><a>atomicUpdateMU</a> arr upds</tt> replaces elements
--   at specific indices of <tt>arr</tt> based on the contents of
--   <tt>upds</tt> (where <tt><tt>fstS</tt></tt> indicates the index to
--   replace, <tt><tt>sndS</tt></tt> the replacement value).
atomicUpdateMU :: (UA e) => MUArr e s -> UArr (Int :*: e) -> ST s ()

-- | <i>O(n)</i>. <a>unstreamMU</a> fills a mutable array from a stream
--   from left to right and yields the number of elements written.
unstreamMU :: (UA a) => MUArr a s -> Stream a -> ST s Int

-- | Elementwise pairing of mutable arrays. This is an unsafe operation, as
--   no copying is performed, so changes to the pair array will affect the
--   original arrays, and vice versa.
unsafeZipMU :: (UA a, UA b) => MUArr a s -> MUArr b s -> MUArr (a :*: b) s

-- | Elementwise unpairing of mutable arrays. This is an unsafe operation,
--   as no copying is performed, so changes to the unpaired arrays will
--   affect the original, and vice versa.
unsafeUnzipMU :: (UA a, UA b) => MUArr (a :*: b) s -> MUArr a s :*: MUArr b s

-- | Strict pair
data (:*:) a b
(:*:) :: !a -> !b -> :*: a b

-- | Strict sum
data EitherS a b
LeftS :: !a -> EitherS a b
RightS :: !b -> EitherS a b

-- | Analog to <a>fst</a> in regular pairs.
fstS :: a :*: b -> a

-- | Analog to <a>snd</a> in regular pairs.
sndS :: a :*: b -> b

-- | Converts a pair to a strict pair.
pairS :: (a, b) -> a :*: b

-- | Converts a strict pair to a pair.
unpairS :: a :*: b -> (a, b)
unsafe_pairS :: (a, b) -> a :*: b
unsafe_unpairS :: a :*: b -> (a, b)

-- | Analogous to <a>curry</a> in regular pairs.
curryS :: (a :*: b -> c) -> a -> b -> c

-- | Analogous to <a>uncurry</a> in regular pairs.
uncurryS :: (a -> b -> c) -> a :*: b -> c

-- | Strict Maybe
data MaybeS a
NothingS :: MaybeS a
JustS :: !a -> MaybeS a

-- | <i>O(1)</i>. <tt><a>maybeS</a> n f m</tt> is the catamorphism for
--   <a>MaybeS</a>, returning <tt>n</tt> if <tt>m</tt> is <a>NothingS</a>,
--   and applying <tt>f</tt> to the value wrapped in <a>JustS</a>
--   otherwise.
maybeS :: b -> (a -> b) -> MaybeS a -> b

-- | <i>O(1)</i>. <tt><a>fromMaybeS</a> n m</tt> returns <tt>n</tt> if
--   <tt>m</tt> is <a>NothingS</a> and the value wrapped in <a>JustS</a>
--   otherwise.
fromMaybeS :: a -> MaybeS a -> a
