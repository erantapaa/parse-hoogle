-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A modern command-line parser for Haskell.
--   
--   A modern command-line parser for Haskell.
@package lambda-options
@version 0.7.0.0

module Text.LambdaOptions.Internal.Opaque
data Opaque
Opaque :: a -> Opaque
type OpaqueCallback r = [Opaque] -> r

module Text.LambdaOptions.Internal.Wrap
class Wrap r f | f -> r
wrap :: Wrap r f => f -> OpaqueCallback r
instance (Monad m, Typeable a, Wrap (m ()) f) => Wrap (m ()) (a -> f)
instance Monad m => Wrap (m ()) (m ())

module Text.LambdaOptions.Parseable

-- | Class describing parseable values. Much like the <a>Read</a> class.
class Parseable a
parse :: Parseable a => [String] -> (Maybe a, Int)
instance Parseable a => Parseable (Maybe a)
instance Parseable Float
instance Parseable String
instance Parseable Integer
instance Parseable Int
instance Parseable Word

module Text.LambdaOptions.Internal.OpaqueParser
type OpaqueParser = [String] -> (Maybe Opaque, Int)
class GetOpaqueParsers f
getOpaqueParsers :: GetOpaqueParsers f => Proxy f -> [(TypeRep, OpaqueParser)]
instance Monad m => GetOpaqueParsers (m ())
instance (Parseable a, Typeable a, GetOpaqueParsers b) => GetOpaqueParsers (a -> b)

module Text.LambdaOptions.List

-- | A simple wrapper over <tt>[a]</tt>. Used to avoid overlapping
--   instances for <tt>Parseable [a]</tt> and <tt>Parseable String</tt>
newtype List a
List :: [a] -> List a
instance Typeable List
instance Data a => Data (List a)
instance Show a => Show (List a)
instance Read a => Read (List a)
instance Eq a => Eq (List a)
instance Ord a => Ord (List a)
instance Parseable a => Parseable (List a)

module Text.LambdaOptions.Keyword

-- | An option keyword, such as <tt>"--help"</tt>
data Keyword
Keyword :: [String] -> String -> String -> Keyword

-- | All the aliases for this keyword.
kwNames :: Keyword -> [String]

-- | Text to describe the arguments to the option given by this keyword.
kwArgText :: Keyword -> String

-- | Text to describe the function of the option given by this keyword.
kwText :: Keyword -> String

-- | Convenience <a>Keyword</a> creation class.
class ToKeyword a
toKeyword :: ToKeyword a => a -> Keyword

-- | Shorthand for <a>toKeyword</a>.
kw :: ToKeyword a => a -> Keyword

-- | Sets the <a>kwArgText</a> field in the keyword. Intended to be used
--   infix:
--   
--   <pre>
--   kw "--directory" `argText` "DIR" `text` "Write files to DIR."
--   </pre>
argText :: Keyword -> String -> Keyword

-- | Sets the <a>kwText</a> field in the keyword. Intended to be used
--   infix.
--   
--   <pre>
--   kw "--quiet" `text` "Suppress message display."
--   </pre>
text :: Keyword -> String -> Keyword
instance Typeable Keyword
instance Data Keyword
instance Show Keyword
instance Eq Keyword
instance Ord Keyword
instance ToKeyword [String]
instance ToKeyword String
instance ToKeyword Keyword
instance IsString Keyword

module Text.LambdaOptions.Formatter

-- | User configuration for formatting.
data FormatConfig
FormatConfig :: Int -> FormatConfig
fmtMaxWidth :: FormatConfig -> Int

-- | <pre>
--   FormatConfig { fmtMaxWidth = 80 }
--   </pre>
defaultFormatConfig :: FormatConfig

-- | Formats the given string with the given configuration.
format :: FormatConfig -> String -> String

-- | Formats the given keywords with the given configuration.
formatKeywords :: FormatConfig -> [Keyword] -> String
instance Show FormatConfig
instance Read FormatConfig
instance Eq FormatConfig
instance Ord FormatConfig

module Text.LambdaOptions.Core

-- | Tries to parse the supplied options against input arguments. If
--   successful, parsed option callbacks are returned in <a>Right</a>.
--   Otherwise an <a>OptionsError</a> is returned in <a>Left</a>.
--   
--   Example program:
--   
--   <pre>
--   import System.Environment
--   import Text.LambdaOptions
--   
--   
--   options :: Options IO ()
--   options = do
--       addOption (kw ["--help", "-h"] `text` "Display this help text.") $ \(HelpDescription desc) -&gt; do
--           putStrLn "Usage:"
--           putStrLn desc
--       addOption (kw "--user" `argText` "NAME" `text` "Prints name.") $ \name -&gt; do
--           putStrLn $ "Name:" ++ name
--       addOption (kw "--user" `argText` "NAME AGE" `text` "Prints name and age.") $ \name age -&gt; do
--           putStrLn $ "Name:" ++ name ++ " Age:" ++ show (age :: Int)
--   
--   
--   main :: IO ()
--   main = do
--       args &lt;- getArgs
--       case runOptions options args of
--           Left (ParseFailed msg _ _) -&gt; do
--               putStrLn msg
--               putStrLn $ getHelpDescription options
--           Right action -&gt; action
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; example.exe --user John 20 --user Jane
--   Name:John Age:20
--   Name:Jane
--   
--   &gt;&gt;&gt; example.exe -h
--   Usage:
--   -h, --help                  Display this help text.
--       --user NAME             Prints name.
--       --user NAME AGE         Prints name and age.
--   
--   &gt;&gt;&gt; example.exe --user BadLuckBrian thirteen
--   Unknown option at index 2: `thirteen'
--   Usage:
--   -h, --help                  Display this help text.
--       --user NAME             Prints name.
--       --user NAME AGE         Prints name and age.
--   </pre>
runOptions :: Monad m => Options m () -> [String] -> Either OptionsError (m ())

-- | A monad for parsing options.
data Options m a

-- | Contains information about what went wrong during an unsuccessful
--   options parse.
data OptionsError

-- | Contains <tt>(error-message)</tt> <tt>(begin-args-index)</tt>
--   <tt>(end-args-index)</tt>
ParseFailed :: String -> Int -> Int -> OptionsError

-- | Describes the callback <tt>f</tt> to be called for a successfully
--   parsed option.
--   
--   The function (or value) <tt>f</tt> can have any arity and ultimately
--   returns a value with type <tt>Monad m =&gt; m ()</tt>
--   
--   Each of the callback's arguments must have a type <tt>t</tt> which
--   implements <a>Parseable</a> and <a>Typeable</a>.
--   
--   Think of this as the following constraint synonym:
--   
--   <pre>
--   type OptionCallback m f = (Monad m, f ~ (Parseable t*, Typeable t*) =&gt; t0 -&gt; t1 -&gt; ... -&gt; tN -&gt; m ())
--   </pre>
--   
--   Example callbacks:
--   
--   <pre>
--   f0 = putStrLn "Option parsed!" :: IO ()
--   f1 = put :: String -&gt; State String ()
--   f2 n = liftIO (print n) :: (MonadIO m) =&gt; Int -&gt; m ()
--   f3 name year ratio = lift (print (name, year, ratio)) :: (MonadTrans m) =&gt; String -&gt; Int -&gt; Float -&gt; m IO ()
--   </pre>
type OptionCallback m f = (Monad m, GetOpaqueParsers f, Wrap (m ()) f)

-- | Adds the supplied option to the <tt>Options m ()</tt> context.
--   
--   If the keyword is matched and the types of the callback's parameters
--   can successfully be parsed, the callback is called with the parsed
--   arguments.
addOption :: OptionCallback m f => Keyword -> f -> Options m ()

-- | When used as a callback argument, this contains the help description
--   given by the added options.
--   
--   Example:
--   
--   <pre>
--   addOption (kw ["--help", "-h"]) $ \(HelpDescription desc) -&gt; do
--       putStrLn desc
--   </pre>
newtype HelpDescription
HelpDescription :: String -> HelpDescription

-- | Produces the help description given by the input options.
getHelpDescription :: Monad m => Options m a -> String
instance Typeable HelpDescription
instance Applicative (Options m)
instance Functor (Options m)
instance Monad (Options m)
instance MonadState (OptionsState m) (Options m)
instance Show OptionsError
instance Parseable HelpDescription

module Text.LambdaOptions
