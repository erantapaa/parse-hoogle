-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Chunked XML parsing using iteratees
--   
--   This package provides chunked XML parsing using iteratees. It is
--   especially suited to implementing XML-based socket protocols, but is
--   useful wherever lazy parsing is needed on production systems where you
--   can't tolerate the problems that come with Haskell's lazy I/O.
--   
--   The XML is presented as a lazy tree, and is processed by a handler
--   implemented using a monad transformer called XMLT. The resulting monad
--   is suspended whenever it tries to read a part of the tree that hasn't
--   been parsed yet, and continued as soon as it is available. The
--   resulting code looks and functions very much as if you were using lazy
--   I/O, only without the associated problems. Your handlers can have
--   effects, yet they come out in quite a functional style.
--   
--   Background: Haskell's lazy I/O can be problematic in some applications
--   because it doesn't handle I/O errors properly, and you can't predict
--   when it will clean up its resources, which could result in file
--   handles running out.
@package hexpat-iteratee
@version 0.6

module Text.XML.Expat.Chunked

-- | A tree representation that uses a monadic list as its child list type.
--   
--   Note that you can use the type function <a>ListOf</a> to give a list
--   of any node type, using that node's associated list type, e.g.
--   <tt>ListOf (UNode Text)</tt>
--   
--   The <i>s</i> parameter is a dummy type used to prevent nodes escaping
--   from the handler. See <tt>s</tt> for more explanation.
type Node s m tag text = NodeG (ListT (XMLT s m)) tag text

-- | The tree representation of the XML document.
--   
--   <tt>c</tt> is the container type for the element's children, which is
--   [] in the <tt>hexpat</tt> package, and a monadic list type for
--   <tt>hexpat-iteratee</tt>.
--   
--   <tt>tag</tt> is the tag type, which can either be one of several
--   string types, or a special type from the
--   <tt>Text.XML.Expat.Namespaced</tt> or
--   <tt>Text.XML.Expat.Qualified</tt> modules.
--   
--   <tt>text</tt> is the string type for text content.
data NodeG c :: (* -> *) tag text :: (* -> *) -> * -> * -> *
Element :: !tag -> ![(tag, text)] -> c (NodeG c tag text) -> NodeG tag text
eName :: NodeG tag text -> !tag
eAttributes :: NodeG tag text -> ![(tag, text)]
eChildren :: NodeG tag text -> c (NodeG c tag text)
Text :: !text -> NodeG tag text

-- | Type alias for a single node with unqualified tag names where tag and
--   text are the same string type.
--   
--   The <i>s</i> parameter is a dummy type used to prevent nodes escaping
--   from the handler. See <tt>s</tt> for more explanation.
type UNode s m text = Node s m text text

-- | Type alias for a single annotated node where qualified names are used
--   for tags
--   
--   The <i>s</i> parameter is a dummy type used to prevent nodes escaping
--   from the handler. See <tt>s</tt> for more explanation.
type QNode s m a text = Node s a (QName text) text

-- | Type alias for a single annotated node where namespaced names are used
--   for tags
--   
--   The <i>s</i> parameter is a dummy type used to prevent nodes escaping
--   from the handler. See <tt>s</tt> for more explanation.
type NNode s m text a = Node s a (NName text) text
data ParseOptions tag text :: * -> * -> *
ParseOptions :: Maybe Encoding -> Maybe (tag -> Maybe text) -> ParseOptions tag text

-- | The encoding parameter, if provided, overrides the document's encoding
--   declaration.
overrideEncoding :: ParseOptions tag text -> Maybe Encoding

-- | If provided, entity references (i.e. <tt>&amp;nbsp;</tt> and friends)
--   will be decoded into text using the supplied lookup function
entityDecoder :: ParseOptions tag text -> Maybe (tag -> Maybe text)
defaultParseOptions :: ParseOptions tag text

-- | Encoding types available for the document encoding.
data Encoding :: *
ASCII :: Encoding
UTF8 :: Encoding
UTF16 :: Encoding
ISO88591 :: Encoding

-- | An iteratee that parses the input document, passing a representation
--   of it to the specified handler monad. The monad runs lazily using
--   co-routines, so if it requests a part of the tree that hasn't been
--   parsed yet, it will be suspended, and continued when it's available.
--   
--   This implementation does <i>not</i> use Haskell's lazy I/O.
--   
--   The <i>s</i> type argument is a dummy type, which you should just
--   leave polymorphic by typing <i>s</i> when using the type. The "forall
--   s ." in the type signature prevents any parsed nodes escaping from the
--   handler, because they may refer to parts of the tree that haven't been
--   parsed yet, and this parsing can't take happen outside the handler. If
--   you need to extract nodes from your handler, use a function like
--   <a>fromNodeContainer</a> to convert the container type.
parse :: (MonadIO m, GenericXMLString tag, GenericXMLString text) => ParseOptions tag text -> (forall s. ListT (XMLT s m) (Node s m tag text) -> XMLT s m a) -> m (IterateeG WrappedByteString Word8 m (Either ErrMsg a))

-- | The monad transformer used for writing your handler for chunked XML
--   trees, which executes as a co-routine.
data XMLT s m a

-- | Parse error, consisting of message text and error location
data XMLParseError :: *
XMLParseError :: String -> XMLParseLocation -> XMLParseError

-- | Specifies a location of an event within the input text
data XMLParseLocation :: *
XMLParseLocation :: Int64 -> Int64 -> Int64 -> Int64 -> XMLParseLocation

-- | Line number of the event
xmlLineNumber :: XMLParseLocation -> Int64

-- | Column number of the event
xmlColumnNumber :: XMLParseLocation -> Int64

-- | Byte index of event from start of document
xmlByteIndex :: XMLParseLocation -> Int64

-- | The number of bytes in the event
xmlByteCount :: XMLParseLocation -> Int64
instance MonadIO m => MonadIO (XMLT s m)
instance MonadTrans (XMLT s)
instance Monad m => Monad (XMLT s m)
instance Monad m => Functor (XMLT s m)
