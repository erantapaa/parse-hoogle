-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Simple lightweight JSON parser, generator & manipulator based on ByteString
--   
--   Simple Lightweight JSON parser &amp; generator based on ByteString.
@package AttoJson
@version 0.5.10

module Text.JSON.AttoJSON

-- | Data types for JSON value.
data JSValue

-- | JSON String
JSString :: !ByteString -> JSValue
fromJSString :: JSValue -> !ByteString

-- | JSON Number
JSNumber :: Rational -> JSValue

-- | JSON Object
JSObject :: (Map ByteString JSValue) -> JSValue

-- | JSON Array
JSArray :: [JSValue] -> JSValue

-- | JSON Bool
JSBool :: !Bool -> JSValue

-- | JSON Null
JSNull :: JSValue

-- | Type Class for the value that can be converted from/into
--   <a>JSValue</a>.
class JSON a
fromJSON :: JSON a => JSValue -> Maybe a
toJSON :: JSON a => a -> JSValue

-- | Parse JSON source. Returns <a>JSValue</a> (<a>Right</a>) if succeed,
--   Returns <a>Left</a> if failed.
--   
--   The input string should be UTF8-encoded. Unicode escapes (e.g.
--   <tt>"\u266B"</tt>) are encoded in UTF8 by the parser, so
--   incompatibilities will arise if you try to use AttoJSON with other
--   encodings.
parseJSON :: ByteString -> Either String JSValue

-- | Maybe version of <a>parseJSON</a>.
readJSON :: ByteString -> Maybe JSValue

-- | Print <a>JSValue</a> as JSON source (not pretty).
--   
--   The output string will be in UTF8 (provided the JSValue was
--   constructed with UTF8 strings). Only characters that have to be
--   escaped (control characters, <tt>\</tt>, and <tt>"</tt>) will be
--   escaped.
showJSON :: JSValue -> ByteString

-- | Same as <a>showJSON</a>, but escape non-ASCII characters as well.
showJSON' :: JSValue -> ByteString

-- | Get the value for field in Object and decode it.
lookup :: JSON a => ByteString -> JSValue -> Maybe a

-- | DEPRECATED: Alias of <a>lookup</a>. Use <a>lookup</a>.
getField :: JSON a => ByteString -> JSValue -> Maybe a

-- | <a>lookup</a> with default value.
findWithDefault :: JSON a => a -> ByteString -> JSValue -> a

-- | Same as <a>lookup</a> but it can process nested Object. ex:
--   
--   <pre>
--   lookupDeep ["user", "name"] (JSObject [("user", JSObject [("name", JSString "hoge")])]) == Just "hoge"
--   </pre>
lookupDeep :: JSON a => [ByteString] -> JSValue -> Maybe a

-- | DEPRECATED: Alias of <a>lookupDeep</a>
getFields :: JSON a => [ByteString] -> JSValue -> Maybe a

-- | <a>getFields</a> with default value.
findDeepWithDefault :: JSON a => a -> [ByteString] -> JSValue -> a

-- | Update or Insert the value for field in Object.
updateField :: JSON a => ByteString -> a -> JSValue -> JSValue
updateFields :: [(ByteString, JSValue)] -> JSValue -> JSValue
instance [overlap ok] Typeable JSValue
instance [overlap ok] Show JSValue
instance [overlap ok] Eq JSValue
instance [overlap ok] Data JSValue
instance [overlap ok] JSON a => JSON (Maybe a)
instance [overlap ok] JSON a => JSON (Map ByteString a)
instance [overlap ok] JSON a => JSON (Map String a)
instance [overlap ok] JSON a => JSON [(ByteString, a)]
instance [overlap ok] JSON a => JSON [(String, a)]
instance [overlap ok] JSON a => JSON [a]
instance [overlap ok] JSON ()
instance [overlap ok] JSON Bool
instance [overlap ok] JSON String
instance [overlap ok] JSON ByteString
instance [overlap ok] JSON Double
instance [overlap ok] JSON Integer
instance [overlap ok] JSON Int
instance [overlap ok] JSON Rational
instance [overlap ok] JSON JSValue
