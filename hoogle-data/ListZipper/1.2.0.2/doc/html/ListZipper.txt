-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Simple zipper for lists
--   
--   List zipper with O(1) get element at cursor, insert at cursor, delete
--   at cursor, move right, and move left operations.
@package ListZipper
@version 1.2.0.2

module Data.List.Zipper
data Zipper a
Zip :: ![a] -> ![a] -> Zipper a

-- | <tt>empty</tt> is an empty zipper
empty :: Zipper a

-- | <tt>fromList xs</tt> returns a zipper containing the elements of xs,
--   focused on the first element.
fromList :: [a] -> Zipper a

-- | <tt>fromListEnd xs</tt> returns a zipper containing the elements of
--   xs, focused just off the right end of the list.
fromListEnd :: [a] -> Zipper a
toList :: Zipper a -> [a]

-- | <tt>beginp z</tt> returns <tt>True</tt> if the zipper is at the start.
beginp :: Zipper a -> Bool

-- | <tt>endp z</tt> returns <tt>True</tt> if the zipper is at the end. It
--   is not safe to call <tt>cursor</tt> on <tt>z</tt> if <tt>endp z</tt>
--   returns <tt>True</tt>.
endp :: Zipper a -> Bool

-- | <tt>emptyp z</tt> returns <tt>True</tt> if the zipper is completely
--   empty. forall z. emptyp z == beginp z &amp;&amp; endp z
emptyp :: Zipper a -> Bool
start, end :: Zipper a -> Zipper a

-- | <tt>cursor z</tt> returns the targeted element in <tt>z</tt>.
--   
--   This function is not total, but the invariant is that <tt>endp z ==
--   False</tt> means that you can safely call <tt>cursor z</tt>.
cursor :: Zipper a -> a

-- | <tt>safeCursor</tt> is like <tt>cursor</tt> but total.
safeCursor :: Zipper a -> Maybe a

-- | <tt>left z</tt> returns the zipper with the focus shifted left one
--   element.
left :: Zipper a -> Zipper a

-- | <tt>right z</tt> returns the zipper with the focus shifted right one
--   element; this can move the cursor off the end.
right :: Zipper a -> Zipper a

-- | <tt>insert x z</tt> adds x at the cursor.
insert :: a -> Zipper a -> Zipper a

-- | <tt>delete z</tt> removes the element at the cursor (if any). Safe to
--   call on an empty zipper. forall x z. delete (insert x z) == z
delete :: Zipper a -> Zipper a

-- | <tt>push x z</tt> inserts x into the zipper, and advances the cursor
--   past it.
push :: a -> Zipper a -> Zipper a

-- | <tt>pop z</tt> removes the element before the cursor (if any). Safe to
--   call on an empty zipper. forall x z. pop (push x z) == z
pop :: Zipper a -> Zipper a

-- | <tt>replace a z</tt> changes the current element in the zipper to the
--   passed in value. If there is no current element, the zipper is
--   unchanged. If you want to add the element in that case instead, use
--   <tt>insert a (delete z)</tt>.
replace :: a -> Zipper a -> Zipper a

-- | <tt>reversez z</tt> returns the zipper with the elements in the
--   reverse order. O(1). The cursor is moved to the previous element, so
--   if the cursor was at the start, it's now off the right end, and if it
--   was off the right end, it's now at the start of the reversed list.
reversez :: Zipper a -> Zipper a

-- | <tt>foldrz f x zip</tt> calls <tt>f</tt> with the zipper focused on
--   each element in order, starting with the current. You are guaranteed
--   that f can safely call <a>cursor</a> on its argument; the zipper won't
--   be at the end.
foldrz :: (Zipper a -> b -> b) -> b -> Zipper a -> b

-- | <tt>foldlz f x zip</tt> calls f with the zipper focused on each
--   element in order, starting with the current. You are guaranteed that f
--   can safely call <a>cursor</a> on its argument; the zipper won't be at
--   the end.
foldlz :: (b -> Zipper a -> b) -> b -> Zipper a -> b

-- | <tt>foldlz'</tt> is foldlz with a strict accumulator
foldlz' :: (b -> Zipper a -> b) -> b -> Zipper a -> b

-- | <tt>extractz</tt>, <tt>extendz</tt>, and <tt>duplicatez</tt> can be
--   used to implement Copointed and Comonad from category-extras. I didn't
--   add the instances here so as not to introduce a dependency on that
--   package.
extractz :: Zipper a -> a
duplicatez :: Zipper a -> Zipper (Zipper a)
extendz :: (Zipper a -> b) -> Zipper a -> Zipper b
instance Eq a => Eq (Zipper a)
instance Show a => Show (Zipper a)
instance Functor Zipper
instance CoArbitrary a => CoArbitrary (Zipper a)
instance Arbitrary a => Arbitrary (Zipper a)
