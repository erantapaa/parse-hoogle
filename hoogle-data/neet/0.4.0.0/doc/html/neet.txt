-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A NEAT library for Haskell
--   
@package neet
@version 0.4.0.0


module Neet.Training

-- | Training structure. The idea is that if it is <a>StillTraining</a>, it
--   is presenting you with something that must have its score evaluated,
--   and a way to advance the training by providing that score. If it is
--   <a>DoneTraining</a>, everything has been iterated through.
data Training candidate score result
StillTraining :: candidate -> (score -> Training candidate score result) -> Training candidate score result
DoneTraining :: result -> Training candidate score result
trainSingle :: a -> Training a b b
trainTraversable :: Traversable t => t a -> Training a b (t b)
instance Applicative (Training candidate score)
instance Functor (Training candidate score)
instance (Show c, Show r) => Show (Training c s r)


module Neet.Parameters

-- | The genetic parameters
data Parameters
Parameters :: MutParams -> MutParams -> Int -> SpeciesParams -> Maybe Int -> Parameters
mutParams :: Parameters -> MutParams

-- | Mutation parameters for small populations
mutParamsS :: Parameters -> MutParams

-- | The minimum size for a species to be considered large
largeSize :: Parameters -> Int

-- | Parameters for the distance function
specParams :: Parameters -> SpeciesParams

-- | Drop a species if it doesn't improve for this long, and it hasn't
--   hosted the most successful genome.
dropTime :: Parameters -> Maybe Int

-- | The parameters used in the original NEAT paper, except the
--   perturbation amount and threshold for size.
defParams :: Parameters

-- | Distance Parameters
data DistParams
DistParams :: Double -> Double -> Double -> Double -> DistParams

-- | Coefficient to the number of excess genes
dp1 :: DistParams -> Double

-- | Coefficient to the number of disjoint genes
dp2 :: DistParams -> Double

-- | Coefficient to the average weight differences
dp3 :: DistParams -> Double

-- | How close counts as the same species
delta_t :: DistParams -> Double

-- | Parameters used for distance in the paper
defDistParams :: DistParams

-- | Mutation Parameters
data MutParams
MutParams :: Double -> Double -> Double -> Double -> Double -> Double -> Double -> Double -> Bool -> Double -> Double -> MutParams

-- | How often weights are mutated
mutWeightRate :: MutParams -> Double

-- | How often weights are replaced if mutated
newWeightRate :: MutParams -> Double

-- | Max amount of perturbation
pertAmount :: MutParams -> Double

-- | A new max is between negative this and positive this
weightRange :: MutParams -> Double

-- | How often new connections are made
addConnRate :: MutParams -> Double

-- | How often new nodes are added
addNodeRate :: MutParams -> Double

-- | How likely it is for a connection to be erased
delConnChance :: MutParams -> Double

-- | How likely it is for a node to be erased
delNodeChance :: MutParams -> Double

-- | Whether to allow recurrent connections
recurrencies :: MutParams -> Bool

-- | Percent of population that mutates without crossover
noCrossover :: MutParams -> Double

-- | How likely that a disabled parent results in a disabled child
disableChance :: MutParams -> Double

-- | Mutation parameters for defParams
defMutParams :: MutParams
defMutParamsS :: MutParams

-- | Settings for distance. <a>Simple</a> is for fixed distance
--   calculations. <a>Target</a> should be used when you want the threshold
--   value for distance to change to try to meet a desired species count.
data SpeciesParams
Simple :: DistParams -> SpeciesParams
Target :: DistParams -> SpeciesTarget -> SpeciesParams
distParams :: SpeciesParams -> DistParams

-- | How to seek a target species count
data SpeciesTarget
SpeciesTarget :: (Int, Int) -> Double -> SpeciesTarget

-- | Desired range of species count, inclusive
targetCount :: SpeciesTarget -> (Int, Int)

-- | How much to adjust the distance threshold if there are too many/not
--   enough species
adjustAmount :: SpeciesTarget -> Double

-- | Search Strategy
data SearchStrat
Complexify :: SearchStrat
Phased :: PhaseParams -> SearchStrat

-- | Parameters for phased search
data PhaseParams
PhaseParams :: Double -> Int -> PhaseParams

-- | How much to add to the mean complexity to get the next complexity
phaseAddAmount :: PhaseParams -> Double

-- | How many generations without a drop in complexity warrants going back
--   to a complexify strategy
phaseWaitTime :: PhaseParams -> Int

-- | State of phasing
data PhaseState

-- | The argument is the current threshold to start pruning at.
Complexifying :: Double -> PhaseState

-- | The first argument is how many generations the mean complexity has not
--   fallen. The second is the last mean complexity.
Pruning :: Int -> Double -> PhaseState
instance Show DistParams
instance Show SpeciesTarget
instance Show SpeciesParams
instance Show MutParams
instance Show Parameters
instance Show PhaseParams
instance Show SearchStrat
instance Show PhaseState


module Control.Monad.Fresh.Class

-- | A class for monads that can give fresh values.
--   
--   At least for Eq s, an instance of <a>MonadFresh</a> should satisfy
--   
--   <pre>
--   (<a>==</a>) <tt>&lt;$&gt;</tt> <a>fresh</a> <tt>&lt;*&gt;</tt> <a>fresh</a> â‰¡ <a>fresh</a> <tt>*&gt;</tt> <a>fresh</a> <tt>*&gt;</tt> <tt>pure</tt> <a>False</a>
--   </pre>
--   
--   and something similar for any number of fresh.
class Monad m => MonadFresh s m | m -> s
fresh :: MonadFresh s m => m s
nFresh :: MonadFresh s m => Int -> m [s]


module Neet.Genome

-- | The IDs node genes use to refer to nodes.
newtype NodeId
NodeId :: Int -> NodeId
getNodeId :: NodeId -> Int

-- | Types of nodes
data NodeType
Input :: NodeType
Hidden :: NodeType
Output :: NodeType

-- | Node genes
data NodeGene
NodeGene :: NodeType -> Rational -> NodeGene
nodeType :: NodeGene -> NodeType

-- | A hint for recurrency
yHint :: NodeGene -> Rational

-- | Connection genes
data ConnGene
ConnGene :: NodeId -> NodeId -> Double -> Bool -> Bool -> ConnGene
connIn :: ConnGene -> NodeId
connOut :: ConnGene -> NodeId
connWeight :: ConnGene -> Double
connEnabled :: ConnGene -> Bool

-- | A hint for recurrency
connRec :: ConnGene -> Bool

-- | Innovation IDs
newtype InnoId
InnoId :: Int -> InnoId
getInnoId :: InnoId -> Int

-- | Signature of a connection, used in matching innovations fromthe same
--   generation.
data ConnSig

-- | A NEAT genome. The innovation numbers are stored in here, and not the
--   genes, to prevent data duplication.
data Genome
Genome :: Int -> IntMap NodeGene -> IntMap ConnGene -> NodeId -> Genome
ioCount :: Genome -> Int
nodeGenes :: Genome -> IntMap NodeGene
connGenes :: Genome -> IntMap ConnGene
nextNode :: Genome -> NodeId

-- | Takes the number of inputs, the number of outputs, and gives a genome
--   with the inputs fully connected to the outputs with random weights.
--   The order of the connections are deterministic, so when generating a
--   population, you can just start the innovation number at (iSize + 1) *
--   oSize, since the network includes an additional input for the bias.
fullConn :: MonadRandom m => MutParams -> Int -> Int -> m Genome

-- | Like <a>fullConn</a>, but with only some input-outputs connected.
--   First integer parameters is the max number of connections to start
--   with.
sparseConn :: MonadRandom m => MutParams -> Int -> Int -> Int -> m Genome

-- | Total number of links and nodes.
genomeComplexity :: Genome -> Int

-- | Mutates the genome, using the specified parameters and innovation
--   context.
mutateAdd :: (MonadRandom m, MonadFresh InnoId m) => MutParams -> Map ConnSig InnoId -> Genome -> m (Map ConnSig InnoId, Genome)

-- | Mutates the genome, but uses subtractive mutations instead of
--   additive.
mutateSub :: MonadRandom m => MutParams -> Genome -> m Genome

-- | Crossover. The first argument is the fittest genome.
crossover :: MonadRandom m => MutParams -> Genome -> Genome -> m Genome

-- | Breed two genomes together
breed :: (MonadRandom m, MonadFresh InnoId m) => MutParams -> Map ConnSig InnoId -> Genome -> Genome -> m (Map ConnSig InnoId, Genome)

-- | Genetic distance between two genomes
distance :: Parameters -> Genome -> Genome -> Double

-- | Parameters for search. The type parameter determines the intermediate
--   type for determining if a solution is valid.
data GenScorer score
GS :: (Genome -> score) -> (score -> Double) -> (score -> Bool) -> GenScorer score

-- | Scoring function
gScorer :: GenScorer score -> Genome -> score

-- | Convert the score to a fitness
fitnessFunction :: GenScorer score -> score -> Double

-- | Determines if a result is win
winCriteria :: GenScorer score -> score -> Bool

-- | This graph produced is ugly and janky and will have bugs, like hidden
--   nodes occasionally appearing with output nodes, and weird clustering
--   overall. If you see some problems in the graph, confirm with the Show
--   instance or something else that there really is a problem.
renderGenome :: Genome -> IO ()

-- | A nicer way to display a <a>Genome</a> than the Show instance.
printGenome :: Genome -> IO ()

-- | Validates a <a>Genome</a>, returning Nothing on success.
validateGenome :: Genome -> Maybe [String]
instance Show NodeId
instance Eq NodeId
instance Ord NodeId
instance PrintDot NodeId
instance Serialize NodeId
instance Show NodeType
instance Eq NodeType
instance Generic NodeType
instance Show NodeGene
instance Generic NodeGene
instance Show ConnGene
instance Generic ConnGene
instance Show InnoId
instance Eq InnoId
instance Ord InnoId
instance Show Genome
instance Generic Genome
instance Show ConnSig
instance Eq ConnSig
instance Ord ConnSig
instance Datatype D1NodeType
instance Constructor C1_0NodeType
instance Constructor C1_1NodeType
instance Constructor C1_2NodeType
instance Datatype D1NodeGene
instance Constructor C1_0NodeGene
instance Selector S1_0_0NodeGene
instance Selector S1_0_1NodeGene
instance Datatype D1ConnGene
instance Constructor C1_0ConnGene
instance Selector S1_0_0ConnGene
instance Selector S1_0_1ConnGene
instance Selector S1_0_2ConnGene
instance Selector S1_0_3ConnGene
instance Selector S1_0_4ConnGene
instance Datatype D1Genome
instance Constructor C1_0Genome
instance Selector S1_0_0Genome
instance Selector S1_0_1Genome
instance Selector S1_0_2Genome
instance Selector S1_0_3Genome
instance Serialize Genome
instance Serialize ConnGene
instance Serialize NodeGene
instance Serialize NodeType


module Neet.Network

-- | Modified sigmoid function from the original NEAT paper
modSig :: Double -> Double

-- | Sparse recurrent network, like those made by NEAT
data Network
Network :: [NodeId] -> [NodeId] -> IntMap Neuron -> Int -> Network

-- | Which nodes are inputs
netInputs :: Network -> [NodeId]

-- | Which nodes are outputs
netOutputs :: Network -> [NodeId]
netState :: Network -> IntMap Neuron

-- | Upper bound on depth
netDepth :: Network -> Int

-- | A single neuron
data Neuron
Neuron :: Double -> IntMap Double -> Rational -> NodeType -> Neuron

-- | The current activation
activation :: Neuron -> Double

-- | The inputs to this Neuron
connections :: Neuron -> IntMap Double

-- | Visualization height
yHeight :: Neuron -> Rational

-- | Type, used in pushThrough
neurType :: Neuron -> NodeType
mkPhenotype :: Genome -> Network

-- | Takes the previous step's activations and current inputs and gives a
--   function to update a neuron.
stepNeuron :: IntMap Double -> Neuron -> Neuron

-- | Steps a network one step. Takes the network and the current input,
--   minus the bias.
stepNetwork :: Network -> [Double] -> Network

-- | Steps a network for at least its depth
snapshot :: Network -> [Double] -> Network

-- | Specialized <a>snapshot</a> for nonrecurrent nets. Will break on
--   recurrent connections.
pushThrough :: Network -> [Double] -> [Double]

-- | Gets the output of the current state
getOutput :: Network -> [Double]
instance Show Neuron
instance Show Network


module Neet.Species

-- | A NEAT Species.
data Species
Species :: Int -> [Genome] -> SpecScore -> Int -> Species
specSize :: Species -> Int

-- | All the organisms in this species
specOrgs :: Species -> [Genome]
specScore :: Species -> SpecScore

-- | Number of gens ago the best score improved
lastImprovement :: Species -> Int

-- | Scoring data
data SpecScore
SpecScore :: !Double -> !Genome -> SpecScore
bestScore :: SpecScore -> !Double
bestGen :: SpecScore -> !Genome

-- | Creates a new <a>Species</a> with starter stats from a <a>Genome</a>
--   and the rest
newSpec :: Genome -> [Genome] -> Species

-- | A result of evaluating a species
data TestResult
TR :: MultiMap Double Genome -> !SpecScore -> !Double -> TestResult

-- | The score of each organism
trScores :: TestResult -> MultiMap Double Genome

-- | Result <a>SpecScore</a>
trSS :: TestResult -> !SpecScore

-- | Total adjusted fitness
trAdj :: TestResult -> !Double

-- | Output the result of testing fitness. The first argument tells how to
--   process each genome, with extra effects possible. If you don't need
--   that, you can just <a>fmap</a> over your fitness function and put
--   Identity over the result.
runFitTestWStrategy :: Functor f => (forall t. Traversable t => t Genome -> f (t Double)) -> Species -> f TestResult

-- | Takes a new SpecScore and updates the metadata of a species
updateSpec :: SpecScore -> Species -> Species

-- | Gets the max distance between two genomes in a species
maxDist :: Parameters -> Species -> Double

-- | Total complexity of all member genomes
speciesComplexity :: Species -> Int

-- | Validates a species, possibly returning errors
validateSpecies :: Species -> Maybe [String]
instance Show Species


module Neet.Population

-- | A NEAT Population
data Population
Population :: Int -> !(Map SpecId Species) -> !Double -> !Genome -> !SpecId -> !PopContext -> !SpecId -> Parameters -> SearchStrat -> PhaseState -> Int -> Population

-- | Size of the population
popSize :: Population -> Int

-- | The species
popSpecs :: Population -> !(Map SpecId Species)

-- | Best score so far
popBScore :: Population -> !Double

-- | Best genome so far
popBOrg :: Population -> !Genome

-- | Id of the species that hosted the best score
popBSpec :: Population -> !SpecId

-- | Tracking state and fresh values
popCont :: Population -> !PopContext

-- | The next species ID
nextSpec :: Population -> !SpecId

-- | Parameters for large species
popParams :: Population -> Parameters
popStrat :: Population -> SearchStrat
popPhase :: Population -> PhaseState

-- | Current generation
popGen :: Population -> Int
newtype SpecId
SpecId :: Int -> SpecId

-- | Custom state monad
data PopM a
data PopContext
runPopM :: PopM a -> PopContext -> (a, PopContext)

-- | Settings for creating a new population
data PopSettings
PS :: Int -> Int -> Int -> Parameters -> Maybe Int -> Maybe PhaseParams -> PopSettings

-- | How big the population should be
psSize :: PopSettings -> Int

-- | Number of inputs
psInputs :: PopSettings -> Int

-- | Number of outputs
psOutputs :: PopSettings -> Int

-- | Parameters for large species
psParams :: PopSettings -> Parameters

-- | If Just n, will be sparse with n connections. Otherwise fully
--   connected.
sparse :: PopSettings -> Maybe Int
psStrategy :: PopSettings -> Maybe PhaseParams

-- | Generates a starter population
newPop :: Int -> PopSettings -> Population
trainOnce :: Applicative f => TrainMethod f -> Population -> f Population

-- | Describes how to handle each species or genome when processing
--   fitness, allowing the addition of additional effects
newtype TrainMethod f
TrainMethod :: (forall t. Traversable t => t Genome -> f (t Double)) -> TrainMethod f

-- | How to process each <a>Genome</a> of a species into a score.
tmGen :: TrainMethod f -> forall t. Traversable t => t Genome -> f (t Double)

-- | Train method without any additional effects
pureTrain :: GenScorer a -> TrainMethod Identity

-- | Train method that possibly returns a solution
winTrain :: GenScorer a -> TrainMethod ((,) (First Genome))

-- | Train the population n times. Values less than 1 return the original.
trainN :: (Applicative f, Monad f) => TrainMethod f -> Int -> Population -> f Population

-- | Train until the provided goal is reached, or the max number of
--   generations (first parameter) is reached. Possibly also returns a
--   solution and the number of generations elapsed.
trainUntil :: Int -> GenScorer a -> Population -> (Population, Maybe (Genome, Int))

-- | Train without effects
trainPure :: GenScorer a -> Population -> Population

-- | Gets the number of species
speciesCount :: Population -> Int

-- | Validate a population, possibly returning a list of errors
validatePopulation :: Population -> Maybe [String]
instance Show SpecId
instance Eq SpecId
instance Ord SpecId
instance Show PopContext
instance Show Population
instance Functor PopM
instance Applicative PopM
instance Monad PopM
instance Show PopSettings
instance Functor SpecM
instance Applicative SpecM
instance Monad SpecM
instance MonadFresh SpecId SpecM
instance MonadFresh InnoId PopM
instance MonadRandom PopM


module Neet


module Neet.Examples.XOR
xorFit :: GenScorer [Double]
andFit :: GenScorer [Double]
orFit :: GenScorer [Double]

-- | Automated XOR experiment
xorExperiment :: IO ()
