-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A query language for transforming HTML5
--   
--   Hquery is a tool for transforming XmlHtml trees. It is an
--   implementation of Lift's CssSelectors in haskell. It operates over
--   <a>xmlhtml</a> <a>Node</a>s, allowing you to build transformers for
--   creating and modifying template trees. See <a>Text.Hquery</a> for some
--   examples.
@package hquery
@version 0.1.1.0


-- | This module exports various useful utility functions for working with
--   XmlHtml Nodes. For example, the equality operator on Node does a
--   structural comparison of the nodes. However, this is not entirely
--   useful, since transformed nodes may be equal but e.g. have their
--   attributes in a different order in the list. Among other things, this
--   module defines an EqNode type which has an Eq instance that does
--   semantic equality instead of structural equality.
module Text.Hquery.Utils
newtype EqNode
EqNode :: Node -> EqNode

-- | Test a list of attributes for equality. This has special handling for
--   the <a>class</a> attribute, so that the order in which the classes are
--   applied to the node doesn't matter. Additionally, the oder of the
--   attributes in either list is also ignored.
attrsEq :: [(Text, Text)] -> [(Text, Text)] -> Bool

-- | A top level semantic node equality funciton.
nodeEq :: Node -> Node -> Bool

-- | Strip nodes that contain only whitespace. This can be useful when
--   doing equality comparisons of trees (e.g. in testing). XmlHtml keeps
--   all whitespace, which can cause structural equality differences in
--   trees which were produced programattically vs. hand written and nicely
--   formatted trees.
stripWhitespaceNodes :: Node -> Maybe Node
flattenTextNodes :: [Node] -> [Node]
mapChildren :: ([Node] -> [Node]) -> Cursor -> Cursor
instance Show EqNode
instance Eq EqNode


-- | ADTs for representing what node operations to perform, and their
--   parsers.
module Text.Hquery.Internal.Selector
data AttrMod
Remove :: AttrMod
AppendAttr :: AttrMod
Set :: AttrMod
data AttrSel
AttrSel :: Text -> AttrMod -> AttrSel
CData :: AttrSel
Append :: AttrSel
data CssSel
Id :: Text -> CssSel
Name :: Text -> CssSel
Class :: Text -> CssSel
Attr :: Text -> Text -> CssSel
Elem :: Text -> CssSel
Star :: CssSel
data Matchable
Sel :: CssSel -> Matchable
RSel :: CssSel -> Matchable -> Matchable
attrModParser :: Parser AttrMod
attrSelParser :: Parser (Maybe AttrSel)
cssSelParser :: Parser CssSel
commandParser :: Parser (CssSel, Maybe AttrSel)
instance Show AttrMod
instance Eq AttrMod
instance Show AttrSel
instance Eq AttrSel
instance Show CssSel
instance Eq CssSel
instance Show Matchable
instance Eq Matchable


-- | This module contains all of the actual tree traversal/matching code.
module Text.Hquery.Internal.Transform
buildAttrMod :: Text -> AttrMod -> Text -> Cursor -> Cursor
transform :: CssSel -> (Cursor -> Maybe Cursor) -> [Node] -> [Node]
transformMatchable :: Matchable -> (Cursor -> Maybe Cursor) -> [Node] -> [Node]
selMatches :: CssSel -> Node -> Bool
matchAttr :: (Text -> Bool) -> Text -> Node -> Bool


-- | NOTE: This exception should only be used to indicate an Hquery bug.
module Text.Hquery.Internal.Error
data HqueryInternalException
HqueryInternalException :: String -> HqueryInternalException

-- | Unconditionally throw an HqueryInternalException with the specified
--   error message. This should not be used for user errors, just internal
--   hquery errors.
raise :: String -> a
instance Typeable HqueryInternalException
instance Show HqueryInternalException
instance Exception HqueryInternalException


-- | This module exports the top level constructors used for building node
--   transformations. For example, if your template is
--   
--   <pre>
--   &lt;div class="person"&gt;
--     &lt;div class="name"&gt;&lt;/div&gt;
--     &lt;div class="occupation"&gt;&lt;/div&gt;
--   &lt;/div&gt;
--   </pre>
--   
--   and you invoke hquery like this:
--   
--   <pre>
--   import Text.Hquery
--   template = ... -- parse your template here
--   people = [ ("Justin Bieber", "Celebrity")
--            , ("Jens Kidman", "Musician")
--            ]
--   bindPerson (n, o) = hq ".name *" n . hq ".occupation *" o
--   f = hq ".person *" $ map bindPerson people
--   f template
--   </pre>
--   
--   you'll get markup like this:
--   
--   <pre>
--   &lt;div class="person"&gt;
--     &lt;div class="name"&gt;Justin Bieber&lt;/div&gt;
--     &lt;div class="occupation"&gt;Celebrity&lt;/div&gt;
--   &lt;/div&gt;
--   &lt;div class="person"&gt;
--     &lt;div class="name"&gt;Jens Kidman&lt;/div&gt;
--     &lt;div class="occupation"&gt;Musician&lt;/div&gt;
--   &lt;/div&gt;
--   </pre>
--   
--   You can also add, remove, and append to element attributes. For
--   example if we have: <tt> &lt;div class="foo"&gt;&lt;/div&gt; </tt>,
--   below are some example transformations:
--   
--   <ul>
--   <li><tt> hq "div [class+]" "hidden" </tt> gives <tt> &lt;div
--   class="foo hidden"&gt;&lt;/div&gt; </tt></li>
--   <li><tt> hq ".foo [id]" "bar" </tt> gives <tt> &lt;div id="bar"
--   class="foo"&gt;&lt;/div&gt; </tt></li>
--   <li><tt> hq "* [class!]" "foo" </tt> gives <tt>
--   &lt;div&gt;&lt;/div&gt; </tt></li>
--   </ul>
--   
--   This module exports several constructors for common types of node
--   transformations. These constructors simply give you back a <tt>
--   <a>Node</a> -&gt; <a>Node</a> </tt>, which you can then apply however
--   you choose.
module Text.Hquery
class MakeTransformer a
hq :: MakeTransformer a => String -> a -> [Node] -> [Node]
data Group
Group :: [Node] -> Group
nothing :: [Node]
instance MakeTransformer [Node]
instance MakeTransformer [[Node] -> [Node]]
instance MakeTransformer ([Node] -> [Node])
instance MakeTransformer Group
instance MakeTransformer Node
instance MakeTransformer [String]
instance MakeTransformer String
instance MakeTransformer a => MakeTransformer (Maybe a)
