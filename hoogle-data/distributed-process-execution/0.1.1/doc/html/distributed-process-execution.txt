-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Execution Framework for The Cloud Haskell Application Platform
--   
--   The Execution Framework provides tools for load regulation, workload
--   shedding and remote hand-off. The currently implementation provides
--   only a subset of the plumbing required, comprising tools for event
--   management, mailbox buffering and message routing.
@package distributed-process-execution
@version 0.1.1


-- | <ul>
--   <li><i>Message Exchanges</i></li>
--   </ul>
--   
--   The concept of a <i>message exchange</i> is borrowed from the world of
--   messaging and enterprise integration. The <i>exchange</i> acts like a
--   kind of mailbox, accepting inputs from <i>producers</i> and forwarding
--   these messages to one or more <i>consumers</i>, depending on the
--   implementation's semantics.
--   
--   This module provides some basic types of message exchange and exposes
--   an API for defining your own custom <i>exchange types</i>.
--   
--   <ul>
--   <li><i>Broadcast Exchanges</i></li>
--   </ul>
--   
--   The broadcast exchange type, started via <a>broadcastExchange</a>,
--   forward their inputs to all registered consumers (as the name
--   suggests). This exchange type is highly optimised for local
--   (intra-node) traffic and provides two different kinds of client
--   binding, one which causes messages to be delivered directly to the
--   client's mailbox (viz <a>bindToBroadcaster</a>), the other providing a
--   separate stream of messages that can be obtained using the
--   <tt>expect</tt> and <tt>receiveX</tt> family of messaging primitives
--   (and thus composed with other forms of input selection, such as typed
--   channels and selective reads on the process mailbox).
--   
--   <i>Important:</i> When a <tt>ProcessId</tt> is registered via
--   <a>bindToBroadcaster</a>, only the payload of the <a>Message</a>
--   (i.e., the underlying <tt>Serializable</tt> datum) is forwarded to the
--   consumer, <i>not</i> the whole <a>Message</a> itself.
--   
--   <ul>
--   <li><i>Router Exchanges</i></li>
--   </ul>
--   
--   The <i>router</i> API provides a means to selectively route messages
--   to one or more clients, depending on the content of the
--   <a>Message</a>. Two modes of binding (and client selection) are
--   provided out of the box, one of which matches the message <a>key</a>,
--   the second of which matches on a name and value from the
--   <a>headers</a>. Alternative mechanisms for content based routing can
--   be derived by modifying the <a>BindingSelector</a> expression passed
--   to <a>router</a>
--   
--   See <a>messageKeyRouter</a> and <a>headerContentRouter</a> for the
--   built-in routing exchanges, and <a>router</a> for the extensible
--   routing API.
--   
--   <ul>
--   <li><i>Custom Exchange Types</i></li>
--   </ul>
--   
--   Both the <i>broadcast</i> and <i>router</i> exchanges are implemented
--   as custom <i>exchange types</i>. The mechanism for defining custom
--   exchange behaviours such as these is very simple. Raw exchanges are
--   started by evaluating <a>startExchange</a> with a specific
--   <a>ExchangeType</a> record. This type is parameterised by the internal
--   <i>state</i> it holds, and defines two API callbacks in its
--   <a>configureEx</a> and <a>routeEx</a> fields. The former is evaluated
--   whenever a client process evaluates <a>configureExchange</a>, the
--   latter whenever a client evaluates <a>post</a> or <a>postMessage</a>.
--   The <a>configureEx</a> callback takes a raw <tt>Message</tt> (from
--   <a>Control.Distributed.Process</a>) and is responsible for decoding
--   the message and updating its own state (if required). It is via this
--   callback that custom exchange types can receive information about
--   clients and handle it in their own way. The <a>routeEx</a> callback is
--   evaluated with the exchange type's own internal state and the
--   <a>Message</a> originally sent to the exchange process (via
--   <a>post</a>) and is responsible for delivering the message to its
--   clients in whatever way makes sense for that exchange type.
module Control.Distributed.Process.Execution.Exchange

-- | Opaque handle to an exchange.
data Exchange

-- | Messages sent to an exchange can optionally provide a routing key and
--   a list of (key, value) headers in addition to the underlying payload.
data Message
Message :: !String -> ![(String, String)] -> !Message -> Message

-- | a <i>routing key</i> for the payload
key :: Message -> !String

-- | arbitrary key-value headers
headers :: Message -> ![(String, String)]

-- | the underlying <tt>Message</tt> payload
payload :: Message -> !Message

-- | Starts an <i>exchange process</i> with the given <a>ExchangeType</a>.
startExchange :: ExchangeType s -> Process Exchange

-- | Starts an exchange as part of a supervision tree.
--   
--   Example: &gt; childSpec = toChildStart $ startSupervised exType
startSupervised :: ExchangeType s -> SupervisorPid -> Process Exchange

-- | Starts an exchange as part of a supervision tree.
--   
--   Example: &gt; childSpec = toChildStart $ startSupervisedRef exType
startSupervisedRef :: ExchangeType s -> SupervisorPid -> Process (ProcessId, Message)
runExchange :: ExchangeType s -> MVar (ControlPort ControlMessage) -> Process ()

-- | Posts an arbitrary <a>Serializable</a> datum to an <i>exchange</i>.
--   The raw datum is wrapped in the <a>Message</a> data type, with its
--   <a>key</a> set to <tt>""</tt> and its <a>headers</a> to <tt>[]</tt>.
post :: Serializable a => Exchange -> a -> Process ()

-- | Posts a <a>Message</a> to an <i>exchange</i>.
postMessage :: Exchange -> Message -> Process ()

-- | Sends an arbitrary <a>Serializable</a> datum to an <i>exchange</i>,
--   for use as a configuration change - see <a>configureEx</a> for
--   details.
configureExchange :: Serializable m => Exchange -> m -> Process ()

-- | Utility for creating a <a>Message</a> datum from its <a>key</a>,
--   <a>headers</a> and <a>payload</a>.
createMessage :: Serializable m => String -> [(String, String)] -> m -> Message

-- | Start a new <i>broadcast exchange</i> and return a handle to the
--   exchange.
broadcastExchange :: Process Exchange

-- | The <a>ExchangeType</a> of a broadcast exchange. Can be combined with
--   the <tt>startSupervisedRef</tt> and <tt>startSupervised</tt> APIs.
broadcastExchangeT :: Process BroadcastExchange

-- | Create a binding to the given <i>broadcast exchange</i> for the
--   calling process and return an <a>InputStream</a> that can be used in
--   the <tt>expect</tt> and <tt>receiveWait</tt> family of messaging
--   primitives. This form of client interaction helps avoid cluttering the
--   caller's mailbox with <a>Message</a> data, since the
--   <tt>InputChannel</tt> provides a separate input stream (in a similar
--   fashion to a typed channel). Example:
--   
--   <pre>
--   is &lt;- broadcastClient ex
--   msg &lt;- receiveWait [ matchInputStream is ]
--   handleMessage (payload msg)
--   </pre>
broadcastClient :: Exchange -> Process (InputStream Message)

-- | Bind the calling process to the given <i>broadcast exchange</i>. For
--   each <a>Message</a> the exchange receives, <i>only the payload will be
--   sent</i> to the calling process' mailbox.
--   
--   Example:
--   
--   (producer) &gt; post ex <a>Hello</a>
--   
--   (consumer) &gt; bindToBroadcaster ex &gt; expect &gt;&gt;= liftIO .
--   putStrLn
bindToBroadcaster :: Exchange -> Process ()
type BroadcastExchange = ExchangeType BroadcastEx
type HeaderName = String

-- | The binding key used by the built-in key and header based routers.
data Binding
BindKey :: !String -> Binding
bindingKey :: Binding -> !String
BindHeader :: !String -> !HeaderName -> Binding
bindingKey :: Binding -> !String
headerName :: Binding -> !HeaderName
BindNone :: Binding

-- | Things that can be used as binding keys in a router.
class (Hashable k, Eq k, Serializable k) => Bindable k

-- | Used to convert a <a>Message</a> into a <a>Bindable</a> routing key.
type BindingSelector k = Message -> Process k

-- | Given to a <i>router</i> to indicate whether clients should receive
--   <a>Message</a> payloads only, or the whole <a>Message</a> object
--   itself.
data RelayType
PayloadOnly :: RelayType
WholeMessage :: RelayType

-- | Defines a <i>router</i> exchange. The <a>BindingSelector</a> is used
--   to construct a binding (i.e., an instance of the <a>Bindable</a> type
--   <tt>k</tt>) for each incoming <a>Message</a>. Such bindings are
--   matched against bindings stored in the exchange. Clients of a
--   <i>router</i> exchange are identified by a binding, mapped to one or
--   more <a>ProcessId</a>s.
--   
--   The format of the bindings, nature of their storage and mechanism for
--   submitting new bindings is implementation dependent (i.e., will vary
--   by exchange type). For example, the <a>messageKeyRouter</a> and
--   <a>headerContentRouter</a> implementations both use the <a>Binding</a>
--   data type, which can represent a <a>Message</a> key or a
--   <a>HeaderName</a> and content. As with all custom exchange types,
--   bindings should be submitted by evaluating <a>configureExchange</a>
--   with a suitable data type.
router :: Bindable k => RelayType -> BindingSelector k -> Process Exchange

-- | Defines a <i>router</i> that can be used in a supervision tree.
supervisedRouter :: Bindable k => RelayType -> BindingSelector k -> SupervisorPid -> Process Exchange

-- | Send a <a>Serializable</a> message to the supplied <a>Exchange</a>.
--   The given datum will be converted to a <a>Message</a>, with the
--   <a>key</a> set to <tt>""</tt> and the <a>headers</a> to <tt>[]</tt>.
--   
--   The routing behaviour will be dependent on the choice of
--   <a>BindingSelector</a> given when initialising the <i>router</i>.
route :: Serializable m => Exchange -> m -> Process ()

-- | Send a <a>Message</a> to the supplied <a>Exchange</a>. The routing
--   behaviour will be dependent on the choice of <a>BindingSelector</a>
--   given when initialising the <i>router</i>.
routeMessage :: Exchange -> Message -> Process ()

-- | A router that matches on a <a>Message</a> <a>key</a>. To bind a client
--   <tt>Process</tt> to such an exchange, use the <a>bindKey</a> function.
messageKeyRouter :: RelayType -> Process Exchange

-- | Add a binding (for the calling process) to a <a>messageKeyRouter</a>
--   exchange.
bindKey :: String -> Exchange -> Process ()

-- | A router that matches on a specific (named) header. To bind a client
--   <tt>Process</tt> to such an exchange, use the <a>bindHeader</a>
--   function.
headerContentRouter :: RelayType -> HeaderName -> Process Exchange

-- | Add a binding (for the calling process) to a
--   <a>headerContentRouter</a> exchange.
bindHeader :: HeaderName -> String -> Exchange -> Process ()

-- | Different exchange types are defined using record syntax. The
--   <a>configureEx</a> and <a>routeEx</a> API functions are called during
--   the exchange lifecycle when incoming traffic arrives. Configuration
--   messages are completely arbitrary types and the exchange type author
--   is entirely responsible for decoding them. Messages posted to the
--   exchange (see the <a>Message</a> data type) are passed to the
--   <a>routeEx</a> API function along with the exchange type's own
--   internal state. Both API functions return a new (potentially updated)
--   state and run in the <tt>Process</tt> monad.
data ExchangeType s
ExchangeType :: String -> s -> (s -> Message -> Process s) -> (s -> Message -> Process s) -> ExchangeType s
name :: ExchangeType s -> String
state :: ExchangeType s -> s
configureEx :: ExchangeType s -> s -> Message -> Process s
routeEx :: ExchangeType s -> s -> Message -> Process s

-- | Utility for custom exchange type authors - evaluates a set of
--   primitive message handlers from left to right, returning the first
--   which evaluates to <tt>Just a</tt>, or the initial <tt>e</tt> value if
--   all the handlers yield <tt>Nothing</tt>.
applyHandlers :: a -> Message -> [Message -> Process (Maybe a)] -> Process a


-- | <ul>
--   <li><i>Overview</i></li>
--   </ul>
--   
--   The <i>EventManager</i> is a parallel/concurrent event handling tool,
--   built on top of the <i>Exchange API</i>. Arbitrary events are
--   published to the event manager using <a>notify</a>, and are broadcast
--   simulataneously to a set of registered <i>event handlers</i>.
--   
--   <ul>
--   <li><i>Defining and Registering Event Handlers</i></li>
--   </ul>
--   
--   Event handlers are defined as <tt>Serializable m =&gt; s -&gt; m -&gt;
--   Process s</tt>, i.e., an expression taking an initial state, an
--   arbitrary <tt>Serializable</tt> event/message and performing an action
--   in the <tt>Process</tt> monad that evaluates to a new state.
--   
--   See <a>Control.Distributed.Process.Execution.Exchange</a>.
module Control.Distributed.Process.Execution.EventManager

-- | Opaque handle to an Event Manager.
data EventManager

-- | Start a new <i>Event Manager</i> process and return an opaque handle
--   to it.
start :: Process EventManager
startSupervised :: SupervisorPid -> Process EventManager
startSupervisedRef :: SupervisorPid -> Process (ProcessId, Message)

-- | Broadcast an event to all registered handlers.
notify :: Serializable a => EventManager -> a -> Process ()

-- | Add a new event handler. The handler runs in its own process, which is
--   spawned locally on behalf of the caller.
addHandler :: Serializable a => EventManager -> (s -> a -> Process s) -> Process s -> Process ProcessId

-- | As <a>addHandler</a>, but operates over a raw
--   <tt>Control.Distributed.Process.Message</tt>.
addMessageHandler :: EventManager -> (s -> Message -> Process (Maybe s)) -> Process s -> Process ProcessId
instance Typeable EventManager
instance Generic EventManager
instance Datatype D1EventManager
instance Constructor C1_0EventManager
instance Selector S1_0_0EventManager
instance Resolvable EventManager
instance Binary EventManager


-- | Generic process that acts as an external mailbox and message buffer.
--   
--   <ul>
--   <li><i>Overview</i></li>
--   </ul>
--   
--   For use when rate limiting is not possible (or desired), this module
--   provides a <i>buffer process</i> that receives mail via its
--   <a>post</a> API, buffers the received messages and delivers them when
--   its <i>owning process</i> asks for them. A mailbox has to be started
--   with a maximum buffer size - the so called <i>limit</i> - and will
--   discard messages once its internal storage reaches this user defined
--   threshold.
--   
--   The usual behaviour of the <i>buffer process</i> is to accumulate
--   messages in its internal memory. When a client evaluates
--   <a>notify</a>, the buffer will send a <a>NewMail</a> message to the
--   (real) mailbox of its owning process as soon as it has any message(s)
--   ready to deliver. If the buffer already contains undelivered mail, the
--   <a>NewMail</a> message will be dispatched immediately.
--   
--   When the owning process wishes to receive mail, evaluating
--   <a>deliver</a> (from any process) will cause the buffer to send its
--   owner a <a>Delivery</a> message containing the accumulated messages
--   and additional information about the number of messages it is
--   delivering, the number of messages dropped since the last delivery and
--   a handle for the mailbox (so that processes can have multiple
--   mailboxes if required, and distinguish between them).
--   
--   <ul>
--   <li><i>Overflow Handling</i></li>
--   </ul>
--   
--   A mailbox handles overflow - when the number of messages it is holding
--   reaches the limit - differently depending on the <a>BufferType</a>
--   selected when it starts. The <tt>Queue</tt> buffer will, once the
--   limit is reached, drop older messages first (i.e., the head of the
--   queue) to make space for newer ones. The <tt>Ring</tt> buffer works
--   similarly, but blocks new messages so as to preserve existing ones
--   instead. Finally, the <tt>Stack</tt> buffer will drop the last (i.e.,
--   most recently received) message to make room for new mail.
--   
--   Mailboxes can be <i>resized</i> by evaluating <a>resize</a> with a new
--   value for the limit. If the new limit is older that the
--   current/previous one, messages are dropped as though the mailbox had
--   previously seen a volume of mail equal to the difference (in size)
--   between the limits. In this situation, the <tt>Queue</tt> will drop as
--   many older messages as neccessary to come within the limit, whilst the
--   other two buffer types will drop as many newer messages as needed.
--   
--   <ul>
--   <li><i>Ordering Guarantees</i></li>
--   </ul>
--   
--   When messages are delivered to the owner, they arrive as a list of raw
--   <tt>Message</tt> entries, given in descending age order (i.e., eldest
--   first). Whilst this approximates the FIFO ordering a process' mailbox
--   would usually offer, the <tt>Stack</tt> buffer will appear to offer no
--   ordering at all, since it always deletes the most recent message(s).
--   The <tt>Queue</tt> and <tt>Ring</tt> buffers will maintain a more
--   queue-like (i.e., FIFO) view of received messages, with the obvious
--   constraint the newer or older data might have been deleted.
--   
--   <ul>
--   <li><i>Post API and Relaying</i></li>
--   </ul>
--   
--   For messages to be properly handled by the mailbox, they can either be
--   sent via the <a>post</a> API or directly to the <a>Mailbox</a>.
--   Messages sent directly to the mailbox will still be handled via the
--   internal buffers and subjected to the mailbox limits. The <a>post</a>
--   API is really just a means to ensure that the conversion from
--   <tt>Serializable a -&gt; Message</tt> is done in the caller's process
--   and uses the safe <tt>wrapMessage</tt> variant.
--   
--   <ul>
--   <li><i>Acknowledgements</i></li>
--   </ul>
--   
--   This API is based on the work of Erlang programmers Fred Hebert and
--   Geoff Cant, its design closely mirroring that of the the <i>pobox</i>
--   library application.
module Control.Distributed.Process.Execution.Mailbox

-- | Opaque handle to a mailbox.
data Mailbox

-- | Start a mailbox for the supplied <tt>ProcessId</tt>.
--   
--   <pre>
--   start = spawnLocal $ run
--   </pre>
startMailbox :: ProcessId -> BufferType -> Limit -> Process Mailbox

-- | As <a>startMailbox</a>, but suitable for use in supervisor child
--   specs. This variant is for use when you want to access to the
--   underlying <a>Mailbox</a> handle in your supervised child refs. See
--   supervisor's <tt>ChildRef</tt> data type for more information.
--   
--   Example: &gt; childSpec = toChildStart $ startSupervised pid
--   bufferType mboxLimit
--   
--   See <a>Control.Distributed.Process.Supervisor</a>
startSupervised :: ProcessId -> BufferType -> Limit -> SupervisorPid -> Process (ProcessId, Message)

-- | As <a>startMailbox</a>, but suitable for use in supervisor child
--   specs.
--   
--   Example: &gt; childSpec = toChildStart $ startSupervisedMailbox pid
--   bufferType mboxLimit
--   
--   See <a>Control.Distributed.Process.Supervisor</a>
startSupervisedMailbox :: ProcessId -> BufferType -> Limit -> SupervisorPid -> Process Mailbox

-- | Start a mailbox for the calling process.
--   
--   <pre>
--   create = getSelfPid &gt;&gt;= start
--   </pre>
createMailbox :: BufferType -> Limit -> Process Mailbox

-- | Alters the mailbox's <i>limit</i> - this might cause messages to be
--   dropped!
resize :: Mailbox -> Integer -> Process ()

-- | Obtain statistics (from/to anywhere) about a mailbox.
statistics :: Mailbox -> Process MailboxStats

-- | Monitor a mailbox.
monitor :: Mailbox -> Process MonitorRef

-- | Represents the maximum number of messages the internal buffer can
--   hold.
type Limit = Integer

-- | Describes the different types of buffer.
data BufferType

-- | FIFO buffer, limiter drops the eldest message (queue head)
Queue :: BufferType

-- | unordered buffer, limiter drops the newest (top) message
Stack :: BufferType

-- | FIFO buffer, limiter refuses (i.e., drops) new messages
Ring :: BufferType

-- | Bundle of statistics data, available on request via the
--   <tt>mailboxStats</tt> API call.
data MailboxStats
MailboxStats :: Integer -> Integer -> Limit -> ProcessId -> MailboxStats
pendingMessages :: MailboxStats -> Integer
droppedMessages :: MailboxStats -> Integer
currentLimit :: MailboxStats -> Limit
owningProcess :: MailboxStats -> ProcessId

-- | Posts a message to someone's mailbox.
post :: Serializable a => Mailbox -> a -> Process ()

-- | Instructs the mailbox to send a <a>NewMail</a> signal as soon as any
--   mail is available for delivery. Once the signal is sent, it will not
--   be resent, even when further mail arrives, until <a>notify</a> is
--   called again.
--   
--   NB: signals are <i>only</i> delivered to the mailbox's owning process.
notify :: Mailbox -> Process ()

-- | Instructs the mailbox to deliver all pending messages to the owner.
deliver :: Mailbox -> Process ()

-- | Instructs the mailbox to send a <a>Delivery</a> as soon as any mail is
--   available, or immediately (if the buffer already contains data).
--   
--   NB: signals are <i>only</i> delivered to the mailbox's owning process.
active :: Mailbox -> Filter -> Process ()

-- | Marker message indicating to the owning process that mail has arrived.
data NewMail
NewMail :: !Mailbox -> !Integer -> NewMail

-- | Mail delivery.
data Delivery
Delivery :: Mailbox -> [Message] -> Integer -> Integer -> Delivery

-- | handle to the sending mailbox
box :: Delivery -> Mailbox

-- | list of raw messages
messages :: Delivery -> [Message]

-- | number of messages delivered
count :: Delivery -> Integer

-- | total dropped/skipped messages
totalDropped :: Delivery -> Integer
data FilterResult
Keep :: FilterResult
Skip :: FilterResult
Send :: FilterResult

-- | A <i>do-nothing</i> filter that accepts all messages (i.e., returns
--   <tt>Keep</tt> for any input).
acceptEverything :: Closure (Message -> Process FilterResult)

-- | A filter that takes a <tt>Closure (Message -&gt; Process
--   FilterResult)</tt> holding the filter function and applies it remotely
--   (i.e., in the mailbox's own managed process).
acceptMatching :: Closure (Closure (Message -> Process FilterResult) -> Message -> Process FilterResult)
__remoteTable :: RemoteTable -> RemoteTable
instance Typeable BufferType
instance Typeable MailboxStats
instance Typeable Post
instance Typeable StatsReq
instance Typeable FilterResult
instance Typeable Mode
instance Typeable ControlMessage
instance Typeable Mailbox
instance Typeable Delivery
instance Typeable NewMail
instance Eq BufferType
instance Show BufferType
instance Generic MailboxStats
instance Show MailboxStats
instance Generic Post
instance Generic StatsReq
instance Generic FilterResult
instance Generic Mode
instance Generic ControlMessage
instance Generic Mailbox
instance Eq Mailbox
instance Generic Delivery
instance Generic NewMail
instance Show NewMail
instance Datatype D1MailboxStats
instance Constructor C1_0MailboxStats
instance Selector S1_0_0MailboxStats
instance Selector S1_0_1MailboxStats
instance Selector S1_0_2MailboxStats
instance Selector S1_0_3MailboxStats
instance Datatype D1Post
instance Constructor C1_0Post
instance Datatype D1StatsReq
instance Constructor C1_0StatsReq
instance Datatype D1FilterResult
instance Constructor C1_0FilterResult
instance Constructor C1_1FilterResult
instance Constructor C1_2FilterResult
instance Datatype D1Mode
instance Constructor C1_0Mode
instance Constructor C1_1Mode
instance Constructor C1_2Mode
instance Datatype D1ControlMessage
instance Constructor C1_0ControlMessage
instance Constructor C1_1ControlMessage
instance Datatype D1Mailbox
instance Constructor C1_0Mailbox
instance Selector S1_0_0Mailbox
instance Selector S1_0_1Mailbox
instance Datatype D1Delivery
instance Constructor C1_0Delivery
instance Selector S1_0_0Delivery
instance Selector S1_0_1Delivery
instance Selector S1_0_2Delivery
instance Selector S1_0_3Delivery
instance Datatype D1NewMail
instance Constructor C1_0NewMail
instance Buffered State
instance Binary ControlMessage
instance Show Mode
instance Binary Mode
instance Binary FilterResult
instance Binary StatsReq
instance Binary Post
instance Binary MailboxStats
instance Binary Delivery
instance Binary NewMail
instance Routable Mailbox
instance Resolvable Mailbox
instance Linkable Mailbox
instance Show Mailbox
instance Binary Mailbox


-- | <ul>
--   <li><i>Inter-Process Traffic Management</i></li>
--   </ul>
--   
--   The <i>Execution Framework</i> provides tools for load regulation,
--   workload shedding and remote hand-off. The currently implementation
--   provides only a subset of the plumbing required, comprising tools for
--   event management, mailbox buffering and message routing.
module Control.Distributed.Process.Execution
