-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Alternative Core language for GHC plugins
--   
@package sequent-core
@version 0.5.0.1


-- | The AST for Sequent Core, with basic operations.
module Language.SequentCore.Syntax

-- | An expression producing a value. These include literals, lambdas, and
--   variables, as well as types and coercions (see GHC's <a>Expr</a> for
--   the reasoning). They also include computed values, which bind the
--   current continuation in the body of a command.
data Term b

-- | A primitive literal value.
Lit :: Literal -> Term b

-- | A term variable. Must <i>not</i> be a nullary constructor; use
--   <a>Cons</a> for this.
Var :: Id -> Term b

-- | A function. Binds some arguments and a continuation. The body is a
--   command.
Lam :: [b] -> b -> (Command b) -> Term b

-- | A value formed by a saturated constructor application.
Cons :: DataCon -> [Term b] -> Term b

-- | A value produced by a computation. Binds a continuation.
Compute :: b -> (Command b) -> Term b

-- | A type. Used to pass a type as an argument to a type-level lambda.
Type :: Type -> Term b

-- | A coercion. Used to pass evidence for the <tt>cast</tt> operation to a
--   lambda.
Coercion :: Coercion -> Term b

-- | A continuation. Allowed <i>only</i> as the body of a non-recursive
--   <tt>let</tt>.
Cont :: (Cont b) -> Term b

-- | A continuation, representing a strict context of a Haskell expression.
--   Computation in the sequent calculus is expressed as the interaction of
--   a value with a continuation.
data Cont b

-- | Apply the value to an argument.
App :: (Term b) -> (Cont b) -> Cont b

-- | Perform case analysis on the value.
Case :: b -> [Alt b] -> Cont b

-- | Cast the value using the given coercion.
Cast :: Coercion -> (Cont b) -> Cont b

-- | Annotate the enclosed frame. Used by the profiler.
Tick :: (Tickish Id) -> (Cont b) -> Cont b

-- | Reference to a bound continuation.
Return :: ContId -> Cont b

-- | A general computation. A command brings together a list of bindings,
--   some term, and a <i>continuation</i> saying what to do with the value
--   produced by the term. The term and continuation comprise a <i>cut</i>
--   in the sequent calculus.
--   
--   <b>Invariant</b>: If <a>cmdTerm</a> is a variable representing a
--   constructor, then <a>cmdCont</a> must <i>not</i> begin with as many
--   <a>App</a> frames as the constructor's arity. In other words, the
--   command must not represent a saturated application of a constructor.
--   Such an application should be represented by a <a>Cons</a> value
--   instead. When in doubt, use <a>mkCommand</a> to enforce this
--   invariant.
data Command b
Command :: [Bind b] -> Term b -> Cont b -> Command b

-- | Bindings surrounding the computation.
cmdLet :: Command b -> [Bind b]

-- | The term producing the value.
cmdTerm :: Command b -> Term b

-- | What to do with the value.
cmdCont :: Command b -> Cont b

-- | A binding. Similar to the <tt>Bind</tt> datatype from GHC. Can be
--   either a single non-recursive binding or a mutually recursive block.
data Bind b

-- | A single non-recursive binding.
NonRec :: b -> (Term b) -> Bind b

-- | A block of mutually recursive bindings.
Rec :: [(b, Term b)] -> Bind b

-- | A case alternative. Given by the head constructor (or literal), a list
--   of bound variables (empty for a literal), and the body as a
--   <a>Command</a>.
data Alt b
Alt :: AltCon -> [b] -> (Command b) -> Alt b

-- | A case alternative constructor (i.e. pattern match)
data AltCon :: *
DataAlt :: DataCon -> AltCon

-- | A literal: <tt>case e of { 1 -&gt; ... }</tt> Invariant: always an
--   *unlifted* literal See Note [Literal alternatives]
LitAlt :: Literal -> AltCon

-- | Trivial alternative: <tt>case e of { _ -&gt; ... }</tt>
DEFAULT :: AltCon

-- | Some expression -- a term, a command, or a continuation. Useful for
--   writing mutually recursive functions.
data Expr a
T :: Term a -> Expr a
unT :: Expr a -> Term a
C :: Command a -> Expr a
unC :: Expr a -> Command a
K :: Cont a -> Expr a
unK :: Expr a -> Cont a

-- | An entire program.
type Program a = [Bind a]

-- | The identifier for a covariable, which is like a variable but it binds
--   a continuation.
type ContId = Id

-- | Usual instance of <a>Term</a>, with <a>Var</a>s for binders
type SeqCoreTerm = Term Var

-- | Usual instance of <a>Cont</a>, with <a>Var</a>s for binders
type SeqCoreCont = Cont Var

-- | Usual instance of <a>Command</a>, with <a>Var</a>s for binders
type SeqCoreCommand = Command Var

-- | Usual instance of <a>Bind</a>, with <a>Var</a>s for binders
type SeqCoreBind = Bind Var

-- | Usual binders for Sequent Core terms
type SeqCoreBndr = Var

-- | Usual instance of <a>Alt</a>, with <a>Var</a>s for binders
type SeqCoreAlt = Alt Var

-- | Usual instance of <a>Expr</a>, with <a>Var</a>s for binders
type SeqCoreExpr = Expr Var

-- | Usual instance of <a>Term</a>, with <a>Var</a>s for binders
type SeqCoreProgram = Program Var

-- | Constructs a command, given <tt>let</tt> bindings, a term, and a
--   continuation.
--   
--   This smart constructor enforces the invariant that a saturated
--   constructor invocation is represented as a <a>Cons</a> value rather
--   than using <a>App</a> frames.
mkCommand :: HasId b => [Bind b] -> Term b -> Cont b -> Command b

-- | Wraps a command that returns to the given continuation id in a term
--   using <a>Compute</a>. If the command is a value command (see
--   <a>asValueCommand</a>), unwraps it instead.
mkCompute :: HasId b => b -> Command b -> Term b

-- | Adds the given bindings outside those in the given command.
addLets :: [Bind b] -> Command b -> Command b

-- | Adds the given binding outside the given command, possibly using a
--   case binding rather than a let. See <a>CoreSyn</a> on the let/app
--   invariant.
addNonRec :: HasId b => b -> Term b -> Command b -> Command b
lambdas :: Term b -> ([b], Maybe (b, Command b))

-- | Divide a continuation into a sequence of arguments and an outer
--   continuation. If <tt>k</tt> is not an application continuation, then
--   <tt>collectArgs k == ([], k)</tt>.
collectArgs :: Cont b -> ([Term b], Cont b)

-- | Divide a continuation into a sequence of type arguments and an outer
--   continuation. If <tt>k</tt> is not an application continuation or only
--   applies non-type arguments, then <tt>collectTypeArgs k == ([],
--   k)</tt>.
collectTypeArgs :: Cont b -> ([KindOrType], Cont b)

-- | Divide a continuation into a sequence of type arguments, then a
--   sequence of non-type arguments, then an outer continuation. If
--   <tt>k</tt> is not an application continuation, then
--   <tt>collectTypeAndOtherArgs k == ([], [], k)</tt>.
collectTypeAndOtherArgs :: Cont b -> ([KindOrType], [Term b], Cont b)

-- | Divide a continuation into a sequence of up to <tt>n</tt> arguments
--   and an outer continuation. If <tt>k</tt> is not an application
--   continuation, then <tt>collectArgsUpTo n k == ([], k)</tt>.
collectArgsUpTo :: Int -> Cont b -> ([Term b], Cont b)

-- | Divide a list of terms into an initial sublist of types and the
--   remaining terms.
partitionTypes :: [Term b] -> ([KindOrType], [Term b])

-- | True if the given command is a simple lambda, with no let bindings and
--   no continuation.
isLambda :: Command b -> Bool
isValueArg :: Term b -> Bool

-- | True if the given term is a type. See <a>Type</a>.
isTypeTerm :: Term b -> Bool

-- | True if the given term is a coercion. See <a>Coercion</a>.
isCoTerm :: Term b -> Bool

-- | True if the given term is a type or coercion.
isErasedTerm :: Term b -> Bool

-- | True if the given term appears at runtime, i.e. is neither a type nor
--   a coercion.
isRuntimeTerm :: Term b -> Bool

-- | True if the given term can appear in an expression without
--   restriction. Not true if the term is a type, coercion, or
--   continuation; these can only appear on the RHS of a let or (except for
--   continuations) as an argument in a function call.
isProperTerm :: Term b -> Bool

-- | True if the given command is so simple we can duplicate it freely.
--   This means it has no bindings and its term and continuation are both
--   trivial.
isTrivial :: HasId b => Command b -> Bool

-- | True if the given term is so simple we can duplicate it freely. Some
--   literals are not trivial, and a lambda whose argument is not erased or
--   whose body is non-trivial is also non-trivial.
isTrivialTerm :: HasId b => Term b -> Bool

-- | True if the given continuation is so simple we can duplicate it
--   freely. This is true of casts and of applications of erased arguments
--   (types and coercions). Ticks are not considered trivial, since this
--   would cause them to be inlined.
isTrivialCont :: Cont b -> Bool

-- | True if the given continuation is a return continuation, <tt>Return
--   _</tt>.
isReturnCont :: Cont b -> Bool

-- | If a command represents a saturated call to some function, splits it
--   into the function, the arguments, and the remaining continuation after
--   the arguments.
commandAsSaturatedCall :: HasId b => Command b -> Maybe (Term b, [Term b], Cont b)

-- | If the given term is a function, and the given continuation would
--   provide enough arguments to saturate it, returns the arguments and the
--   remainder of the continuation.
asSaturatedCall :: HasId b => Term b -> Cont b -> Maybe ([Term b], Cont b)

-- | If a command does nothing but provide a value to the given
--   continuation id, returns that value.
asValueCommand :: ContId -> Command b -> Maybe (Term b)
flattenBind :: Bind b -> [(b, Term b)]
flattenBinds :: [Bind b] -> [(b, Term b)]
bindersOf :: Bind b -> [b]
bindersOfBinds :: [Bind b] -> [b]

-- | Compute (a conservative estimate of) the arity of a term.
termArity :: HasId b => Term b -> Int

-- | Compute the type of a term.
termType :: HasId b => Term b -> Type

-- | Compute the type a continuation accepts. If <tt>contType cont</tt> is
--   Foo and <tt>cont</tt> is bound to <tt>k</tt>, then <tt>k</tt>'s
--   <tt>idType</tt> will be <tt>!Foo</tt>.
contType :: HasId b => Cont b -> Type

-- | Find whether an expression is definitely bottom.
termIsBottom :: Term b -> Bool

-- | Find whether a command definitely evaluates to bottom.
commandIsBottom :: Command b -> Bool

-- | Decide whether a term should be bound using <tt>case</tt> rather than
--   <tt>let</tt>. See <a>needsCaseBinding</a>.
needsCaseBinding :: Type -> Term b -> Bool
termOkForSpeculation :: Term b -> Bool
commandOkForSpeculation :: Command b -> Bool
contOkForSpeculation :: Cont b -> Bool
termOkForSideEffects :: Term b -> Bool
commandOkForSideEffects :: Command b -> Bool
contOkForSideEffects :: Cont b -> Bool
termIsCheap :: HasId b => Term b -> Bool
contIsCheap :: HasId b => Cont b -> Bool
commandIsCheap :: HasId b => Command b -> Bool
termIsExpandable :: HasId b => Term b -> Bool
contIsExpandable :: HasId b => Cont b -> Bool
commandIsExpandable :: HasId b => Command b -> Bool

-- | Find whether an id is a continuation id.
isContId :: Id -> Bool

-- | Tag an id as a continuation id.
asContId :: Id -> ContId
mkContTy :: Type -> Type
contTyArg :: Type -> Type

-- | True if the two given terms are the same, up to renaming of bound
--   variables.
(=~=) :: AlphaEq a => a -> a -> Bool

-- | The class of types that can be compared up to alpha-equivalence.
class AlphaEq a where aeq = aeqIn emptyAlphaEnv
aeq :: AlphaEq a => a -> a -> Bool
aeqIn :: AlphaEq a => AlphaEnv -> a -> a -> Bool

-- | The type of the environment of an alpha-equivalence comparison. Only
--   needed by user code if two terms need to be compared under some
--   assumed correspondences between free variables. See GHC's
--   <a>VarEnv</a> module for operations.
type AlphaEnv = RnEnv2

-- | A class of types that contain an identifier. Useful so that we can
--   compare, say, elements of <tt>Command b</tt> for any <tt>b</tt> that
--   wraps an identifier with additional information.
class HasId a
identifier :: HasId a => a -> Id
instance HasId b => AlphaEq (Bind b)
instance AlphaEq a => AlphaEq [a]
instance AlphaEq Coercion
instance AlphaEq Type
instance HasId b => AlphaEq (Alt b)
instance HasId b => AlphaEq (Command b)
instance HasId b => AlphaEq (Cont b)
instance HasId b => AlphaEq (Term b)
instance HasId Var


-- | Instances and functions for pretty-printing Sequent Core terms using
--   GHC's built-in pretty printer.
module Language.SequentCore.Pretty

-- | Print the given bindings as a sequence of top-level bindings.
pprTopLevelBinds :: OutputableBndr b => [Bind b] -> SDoc
instance OutputableBndr b => Outputable (Alt b)
instance OutputableBndr b => Outputable (Cont b)
instance OutputableBndr b => Outputable (Command b)
instance OutputableBndr b => Outputable (Term b)
instance OutputableBndr b => Outputable (Bind b)

module Language.SequentCore.Lint
lintCoreBindings :: [SeqCoreBind] -> Maybe SDoc
lintTerm :: TvSubst -> SeqCoreTerm -> Maybe SDoc

module Language.SequentCore.Subst

-- | A substitution environment, containing both <a>Id</a> and <a>TyVar</a>
--   substitutions.
--   
--   Some invariants apply to how you use the substitution:
--   
--   <ol>
--   <li>The in-scope set contains at least those <a>Id</a>s and
--   <a>TyVar</a>s that will be in scope <i>after</i> applying the
--   substitution to a term. Precisely, the in-scope set must be a superset
--   of the free vars of the substitution range that might possibly clash
--   with locally-bound variables in the thing being substituted in.</li>
--   <li>You may apply the substitution only <i>once</i></li>
--   </ol>
--   
--   There are various ways of setting up the in-scope set such that the
--   first of these invariants hold:
--   
--   <ul>
--   <li>Arrange that the in-scope set really is all the things in
--   scope</li>
--   <li>Arrange that it's the free vars of the range of the
--   substitution</li>
--   <li>Make it empty, if you know that all the free vars of the
--   substitution are fresh, and hence can't possibly clash</li>
--   </ul>
data Subst
Subst :: InScopeSet -> IdSubstEnv -> TvSubstEnv -> CvSubstEnv -> Subst

-- | A substitition of <a>Type</a>s for <a>TyVar</a>s and <a>Kind</a>s for
--   <a>KindVar</a>s
type TvSubstEnv = TyVarEnv Type

-- | An environment for substituting for <a>Id</a>s
type IdSubstEnv = IdEnv SeqCoreTerm

-- | A set of variables that are in scope at some point
data InScopeSet :: *

-- | De-shadowing the program is sometimes a useful pre-pass. It can be
--   done simply by running over the bindings with an empty substitution,
--   because substitution returns a result that has no-shadowing
--   guaranteed.
--   
--   (Actually, within a single <i>type</i> there might still be shadowing,
--   because <a>substTy</a> is a no-op for the empty substitution, but
--   that's probably OK.)
--   
--   <ul>
--   <li><i>Aug 09</i> This function is not used in GHC at the moment, but
--   seems so short and simple that I'm going to leave it here</li>
--   </ul>
deShadowBinds :: [SeqCoreBind] -> [SeqCoreBind]

-- | Substitutes for the <a>Id</a>s within the <tt>WorkerInfo</tt> given
--   the new function <a>Id</a>
substSpec :: Subst -> Id -> SpecInfo -> SpecInfo
substRulesForImportedIds :: Subst -> [CoreRule] -> [CoreRule]

-- | See <a>substTy</a>
substTy :: Subst -> Type -> Type

-- | See <a>substCo</a>
substCo :: Subst -> Coercion -> Coercion
substTerm :: SDoc -> Subst -> SeqCoreTerm -> SeqCoreTerm

-- | Apply a substititon to an entire <tt>CoreBind</tt>, additionally
--   returning an updated <a>Subst</a> that should be used by subsequent
--   substitutons.
substBind :: Subst -> SeqCoreBind -> (Subst, SeqCoreBind)

-- | Apply a substititon to an entire <tt>CoreBind</tt>, additionally
--   returning an updated <a>Subst</a> that should be used by subsequent
--   substitutons.
substBindSC :: Subst -> SeqCoreBind -> (Subst, SeqCoreBind)

-- | Substitutes for the <a>Id</a>s within an unfolding
substUnfolding :: Subst -> Unfolding -> Unfolding

-- | Substitutes for the <a>Id</a>s within an unfolding
substUnfoldingSC :: Subst -> Unfolding -> Unfolding

-- | Find the substitution for an <a>Id</a> in the <a>Subst</a>
lookupIdSubst :: SDoc -> Subst -> Id -> SeqCoreTerm

-- | Find the substitution for a <a>TyVar</a> in the <a>Subst</a>
lookupTvSubst :: Subst -> TyVar -> Type

-- | Find the coercion substitution for a <a>CoVar</a> in the <a>Subst</a>
lookupCvSubst :: Subst -> CoVar -> Coercion
substIdOcc :: Subst -> Id -> Id
substTickish :: Subst -> Tickish Id -> Tickish Id
substVarSet :: Subst -> VarSet -> VarSet
emptySubst :: Subst
mkEmptySubst :: InScopeSet -> Subst
mkSubst :: InScopeSet -> TvSubstEnv -> CvSubstEnv -> IdSubstEnv -> Subst

-- | Simultaneously substitute for a bunch of variables No left-right
--   shadowing ie the substitution for (x y. e) a1 a2 so neither x nor y
--   scope over a1 a2
mkOpenSubst :: InScopeSet -> [(Var, SeqCoreTerm)] -> Subst

-- | Find the in-scope set: see <a>CoreSubst#in_scope_invariant</a>
substInScope :: Subst -> InScopeSet
isEmptySubst :: Subst -> Bool

-- | Add a substitution for an <a>Id</a> to the <a>Subst</a>: you must
--   ensure that the in-scope set is such that the
--   <a>CoreSubst#in_scope_invariant</a> is true after extending the
--   substitution like this
extendIdSubst :: Subst -> Id -> SeqCoreTerm -> Subst

-- | Adds multiple <a>Id</a> substitutions to the <a>Subst</a>: see also
--   <a>extendIdSubst</a>
extendIdSubstList :: Subst -> [(Id, SeqCoreTerm)] -> Subst

-- | Add a substitution for a <a>TyVar</a> to the <a>Subst</a>: you must
--   ensure that the in-scope set is such that the
--   <a>CoreSubst#in_scope_invariant</a> is true after extending the
--   substitution like this
extendTvSubst :: Subst -> TyVar -> Type -> Subst

-- | Adds multiple <a>TyVar</a> substitutions to the <a>Subst</a>: see also
--   <a>extendTvSubst</a>
extendTvSubstList :: Subst -> [(TyVar, Type)] -> Subst

-- | Add a substitution from a <a>CoVar</a> to a <a>Coercion</a> to the
--   <a>Subst</a>: you must ensure that the in-scope set is such that the
--   <a>CoreSubst#in_scope_invariant</a> is true after extending the
--   substitution like this
extendCvSubst :: Subst -> CoVar -> Coercion -> Subst

-- | Adds multiple <a>CoVar</a> -&gt; <a>Coercion</a> substitutions to the
--   <a>Subst</a>: see also <a>extendCvSubst</a>
extendCvSubstList :: Subst -> [(CoVar, Coercion)] -> Subst

-- | Add a substitution appropriate to the thing being substituted (whether
--   an expression, type, or coercion). See also <a>extendIdSubst</a>,
--   <a>extendTvSubst</a>, and <a>extendCvSubst</a>.
extendSubst :: Subst -> Var -> SeqCoreTerm -> Subst

-- | Add a substitution as appropriate to each of the terms being
--   substituted (whether expressions, types, or coercions). See also
--   <a>extendSubst</a>.
extendSubstList :: Subst -> [(Var, SeqCoreTerm)] -> Subst
extendSubstWithVar :: Subst -> Var -> Var -> Subst

-- | Remove all substitutions for <a>Id</a>s and <a>Var</a>s that might
--   have been built up while preserving the in-scope set
zapSubstEnv :: Subst -> Subst

-- | Add the <a>Var</a> to the in-scope set, but do not remove any existing
--   substitutions for it
addInScopeSet :: Subst -> VarSet -> Subst

-- | Add the <a>Var</a> to the in-scope set: as a side effect, and remove
--   any existing substitutions for it
extendInScope :: Subst -> Var -> Subst

-- | Add the <a>Var</a>s to the in-scope set: see also <a>extendInScope</a>
extendInScopeList :: Subst -> [Var] -> Subst

-- | Optimized version of <a>extendInScopeList</a> that can be used if you
--   are certain all the things being added are <a>Id</a>s and hence none
--   are <a>TyVar</a>s or <a>CoVar</a>s
extendInScopeIds :: Subst -> [Id] -> Subst
isInScope :: Var -> Subst -> Bool
setInScope :: Subst -> InScopeSet -> Subst
delBndr :: Subst -> Var -> Subst
delBndrs :: Subst -> [Var] -> Subst

-- | Substitutes a <a>Var</a> for another one according to the <a>Subst</a>
--   given, returning the result and an updated <a>Subst</a> that should be
--   used by subsequent substitutons. <a>IdInfo</a> is preserved by this
--   process, although it is substituted into appropriately.
substBndr :: Subst -> Var -> (Subst, Var)

-- | Applies <a>substBndr</a> to a number of <a>Var</a>s, accumulating a
--   new <a>Subst</a> left-to-right
substBndrs :: Subst -> [Var] -> (Subst, [Var])

-- | Substitute in a mutually recursive group of <a>Id</a>s
substRecBndrs :: Subst -> [Id] -> (Subst, [Id])
cloneBndr :: Subst -> Unique -> Var -> (Subst, Var)
cloneBndrs :: Subst -> UniqSupply -> [Var] -> (Subst, [Var])

-- | Very similar to <a>substBndr</a>, but it always allocates a new
--   <a>Unique</a> for each variable in its output. It substitutes the
--   IdInfo though.
cloneIdBndr :: Subst -> UniqSupply -> Id -> (Subst, Id)

-- | Applies <a>cloneIdBndr</a> to a number of <a>Id</a>s, accumulating a
--   final substitution from left to right
cloneIdBndrs :: Subst -> UniqSupply -> [Id] -> (Subst, [Id])

-- | Clone a mutually recursive group of <a>Id</a>s
cloneRecIdBndrs :: Subst -> UniqSupply -> [Id] -> (Subst, [Id])
instance Outputable Subst


-- | Translation between Sequent Core and native GHC Core.
module Language.SequentCore.Translate

-- | Translates a list of Core bindings into Sequent Core.
fromCoreModule :: [CoreBind] -> [SeqCoreBind]

-- | Translates a single Core expression as a Sequent Core term.
termFromCoreExpr :: CoreExpr -> SeqCoreTerm

-- | Translates a list of top-level bindings into Core.
bindsToCore :: [SeqCoreBind] -> [CoreBind]

-- | Translates a command into Core.
commandToCoreExpr :: ContId -> SeqCoreCommand -> CoreExpr

-- | Translates a term into Core.
termToCoreExpr :: SeqCoreTerm -> CoreExpr

-- | Translates a continuation into a function that will wrap a Core
--   expression with a fragment of context (an argument to apply to, a case
--   expression to run, etc.).
contToCoreExpr :: ContId -> SeqCoreCont -> (CoreExpr -> CoreExpr)

-- | Take an operation on Sequent Core terms and perform it on Core
--   expressions
onCoreExpr :: (SeqCoreTerm -> SeqCoreTerm) -> (CoreExpr -> CoreExpr)

-- | Take an operation on Core expressions and perform it on Sequent Core
--   terms
onSequentCoreTerm :: (CoreExpr -> CoreExpr) -> (SeqCoreTerm -> SeqCoreTerm)


-- | Tools for writing a GHC plugin using the Sequent Core language in
--   place of GHC Core.
module Language.SequentCore.Plugin

-- | Given a function that processes a module's bindings as Sequent Core
--   terms, perform the same processing as a Core-to-Core pass usable from
--   a GHC plugin. Intended to be passed to the <tt>CoreDoPluginPass</tt>
--   constructor as part of your plugin's <tt>installCoreToDos</tt>
--   function. See <a>Language.SequentCore.Dump</a> for an example and the
--   GHC manual for more details.
sequentPass :: ([SeqCoreBind] -> CoreM [SeqCoreBind]) -> (ModGuts -> CoreM ModGuts)


-- | An example GHC optimizer plugin using Sequent Core. Simply translates
--   the given Core code to Sequent Core, passes it through Lint, dumps it
--   to the screen, then translates back. This allows inspection of the
--   Sequent Core code for a module and also tests the translation and
--   linting functions.
--   
--   Note that translating to Sequent Core and back should give an
--   <i>equivalent</i> program, but it may vary slightly. The effects
--   should be benign, such as a <tt>let</tt> floating around in an
--   expression (but never across a lambda).
module Language.SequentCore.Dump

-- | The plugin. A GHC plugin is a module that exports a value called
--   <tt>plugin</tt> with the type <a>Plugin</a>.
plugin :: Plugin


-- | An optimizer plugin that reports specified information about the
--   module from a Sequent Core standpoint.
module Language.SequentCore.Inspect

-- | The plugin. A GHC plugin is a module that exports a value called
--   <tt>plugin</tt> with the type <a>Plugin</a>.
plugin :: Plugin


-- | A proof of concept to demonstrate that the Sequent Core syntax can be
--   used for basic optimization in the style of GHC's simplifier. In some
--   ways, it is easier to use Sequent Core for these, as the continuations
--   are expressed directly in the program syntax rather than needing to be
--   built up on the fly.
module Language.SequentCore.Simpl

-- | Plugin data. The initializer replaces all instances of the original
--   simplifier with the new one.
plugin :: Plugin


-- | A simple reimplementation of the SpecConstr pass using Sequent Core.
--   
--   Based on <a>Call-pattern specialization for Haskell programs</a>,
--   Simon Peyton Jones, submitted to ICFP 2007.
module Language.SequentCore.SpecConstr

-- | Plugin data. The initialization code replaces the built-in SpecConstr
--   pass in the Core-to-Core pipeline.
plugin :: Plugin
instance Outputable Spec
instance Outputable CallPat
instance Monoid ScUsage
instance Outputable HowBound
instance Outputable ScUsage
instance Outputable ScEnv


module Language.SequentCore
