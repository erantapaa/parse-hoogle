-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Arrow classes and transformers
--   
--   Several classes that extend the Arrow class, and some transformers
--   that implement or lift these classes.
@package arrows
@version 0.4.4.1


-- | Transformation of state readers.
--   
--   <i>TODO:</i> define operations for this arrow.
module Control.Arrow.Transformer.CoState
newtype CoStateArrow s a b c
CoStateArrow :: (a (s -> b) (s -> c)) -> CoStateArrow s a b c
instance ArrowPlus a => Monoid (CoStateArrow s a b c)
instance ArrowPlus a => Alternative (CoStateArrow s a b)
instance Arrow a => Applicative (CoStateArrow s a b)
instance Arrow a => Functor (CoStateArrow s a b)
instance ArrowPlus a => ArrowPlus (CoStateArrow s a)
instance ArrowZero a => ArrowZero (CoStateArrow s a)
instance ArrowLoop a => ArrowLoop (CoStateArrow s a)
instance Arrow a => Arrow (CoStateArrow s a)
instance Category a => Category (CoStateArrow s a)


-- | Arrow transformers, for making new arrow types out of old ones.
module Control.Arrow.Transformer

-- | Construct a new arrow from an existing one.
class (Arrow a, Arrow (f a)) => ArrowTransformer f a
lift :: ArrowTransformer f a => a b c -> f a b c


-- | Subclasses of <a>Arrow</a> providing additional operations.
--   
--   The signatures are designed to be compatible with the proposed
--   notation for arrows, cf. <a>http://www.haskell.org/arrows/</a>.
module Control.Arrow.Operations

-- | An arrow type that provides a modifiable state, based of section 9 of
--   <i>Generalising Monads to Arrows</i>, by John Hughes, <i>Science of
--   Computer Programming</i> 37:67-111, May 2000.
class Arrow a => ArrowState s a | a -> s
fetch :: ArrowState s a => a e s
store :: ArrowState s a => a s ()

-- | An arrow type that provides a read-only state (an environment). If you
--   also need to modify the state, use <a>ArrowState</a>.
class Arrow a => ArrowReader r a | a -> r
readState :: ArrowReader r a => a b r
newReader :: ArrowReader r a => a e b -> a (e, r) b

-- | An arrow type that collects additional output (of some <a>Monoid</a>
--   type).
class (Monoid w, Arrow a) => ArrowWriter w a | a -> w
write :: ArrowWriter w a => a w ()
newWriter :: ArrowWriter w a => a e b -> a e (b, w)

-- | An arrow type that includes errors (or exceptions).
--   
--   Minimal definition: <a>raise</a> and <a>tryInUnless</a>.
--   
--   <i>TODO:</i> the operations here are inconsistent with other arrow
--   transformers.
class Arrow a => ArrowError ex a | a -> ex where handle f h = tryInUnless f (arr snd) h newError f = handle (f >>> arr Right) (arr (Left . snd))
raise :: ArrowError ex a => a ex b
handle :: ArrowError ex a => a e b -> a (e, ex) b -> a e b
tryInUnless :: ArrowError ex a => a e b -> a (e, b) c -> a (e, ex) c -> a e c
newError :: ArrowError ex a => a e b -> a e (Either ex b)

-- | A suitable value for <a>tryInUnless</a> when the arrow type belongs to
--   <a>ArrowChoice</a>. To use it, you must define either <a>handle</a> or
--   <a>newError</a>.
tryInUnlessDefault :: (ArrowError ex a, ArrowChoice a) => a e b -> a (e, b) c -> a (e, ex) c -> a e c

-- | An arrow type that can be used to interpret synchronous circuits.
class ArrowLoop a => ArrowCircuit a
delay :: ArrowCircuit a => b -> a b b


-- | Simple Mealy-style automata.
module Control.Arrow.Transformer.Automaton

-- | An arrow type comprising Mealy-style automata, each step of which is
--   is a computation in the original arrow type.
newtype Automaton a b c
Automaton :: (a b (c, Automaton a b c)) -> Automaton a b c

-- | Encapsulating an automaton by running it on a stream of inputs,
--   obtaining a stream of outputs.
--   
--   Typical usage in arrow notation:
--   
--   <pre>
--   proc p -&gt; do
--   	...
--   	ys &lt;- (|runAutomaton (\x -&gt; ...)|) xs
--   </pre>
--   
--   Here <tt>xs</tt> refers to the input stream and <tt>x</tt> to
--   individual elements of that stream. <tt>ys</tt> is bound to the output
--   stream.
runAutomaton :: (ArrowLoop a, ArrowApply a) => Automaton a (e, b) c -> a (e, Stream b) (Stream c)
instance ArrowAddState r a a' => ArrowAddState r (Automaton a) (Automaton a')
instance ArrowAddReader r a a' => ArrowAddReader r (Automaton a) (Automaton a')
instance ArrowAddWriter w a a' => ArrowAddWriter w (Automaton a) (Automaton a')
instance ArrowState s a => ArrowState s (Automaton a)
instance ArrowReader r a => ArrowReader r (Automaton a)
instance ArrowError r a => ArrowError r (Automaton a)
instance ArrowWriter w a => ArrowWriter w (Automaton a)
instance (ArrowLoop a, ArrowApply a) => ArrowAddStream (Automaton a) a
instance ArrowPlus a => Monoid (Automaton a b c)
instance ArrowPlus a => Alternative (Automaton a b)
instance Arrow a => Applicative (Automaton a b)
instance Arrow a => Functor (Automaton a b)
instance ArrowLoop a => ArrowCircuit (Automaton a)
instance ArrowLoop a => ArrowLoop (Automaton a)
instance ArrowPlus a => ArrowPlus (Automaton a)
instance ArrowZero a => ArrowZero (Automaton a)
instance ArrowChoice a => ArrowChoice (Automaton a)
instance Arrow a => Arrow (Automaton a)
instance Arrow a => Category (Automaton a)
instance Arrow a => ArrowTransformer Automaton a


-- | An arrow transformer that adds error handling.
--   
--   <i>TODO:</i> the operations here are inconsistent with other arrow
--   transformers.
module Control.Arrow.Transformer.Error

-- | An arrow that augments an existing arrow with possible errors. The
--   <a>ArrowError</a> class contains methods for raising and handling
--   these errors.
newtype ErrorArrow ex a b c
ErrorArrow :: (a b (Either ex c)) -> ErrorArrow ex a b c

-- | Encapsulate an error-raising computation, by completely handling any
--   errors.
--   
--   Typical usage in arrow notation:
--   
--   <pre>
--   proc p -&gt; ...
--   	body `runError` \ex -&gt; handler
--   </pre>
runError :: ArrowChoice a => ErrorArrow ex a e b -> a (e, ex) b -> a e b

-- | Adding a <a>ErrorArrow</a> to an arrow type, but not necessarily as
--   the outer arrow transformer.
--   
--   Typically a composite arrow type is built by applying a series of
--   arrow transformer to a base arrow (usually either a function arrow or
--   a <a>Kleisli</a> arrow. One can add a transformer to the top of this
--   stack using the <a>lift</a> method of the <a>ArrowTransformer</a>
--   class, or remove a state transformer from the top of the stack using
--   the <a>runError</a> encapsulation operator. The methods of this class
--   add and remove state transformers anywhere in the stack. In the
--   instance
--   
--   <pre>
--   instance Arrow a =&gt; ArrowAddError ex (ArrowError ex a) a
--   </pre>
--   
--   they are equivalent to <a>lift</a> and <a>runError</a> respectively.
--   Instances are lifted through other transformers with
--   
--   <pre>
--   instance ArrowAddError ex a a' =&gt;
--   	ArrowAddError ex (FooArrow a) (FooArrow a')
--   </pre>
--   
--   This could be combined with <a>handle</a>, since the resulting arrow
--   is always the arrow of the handler. Separating them has the advantage
--   of consistency with the other arrows, and might give more helpful type
--   error messages.
class (ArrowError ex a, Arrow a') => ArrowAddError ex a a' | a -> a'
liftError :: ArrowAddError ex a a' => a' e b -> a e b
elimError :: ArrowAddError ex a a' => a e b -> a' (e, ex) b -> a' e b
instance (ArrowAddWriter w a a', ArrowChoice a, ArrowChoice a') => ArrowAddWriter w (ErrorArrow ex a) (ErrorArrow ex a')
instance (ArrowAddState s a a', ArrowChoice a, ArrowChoice a') => ArrowAddState s (ErrorArrow ex a) (ErrorArrow ex a')
instance (ArrowAddReader r a a', ArrowChoice a, ArrowChoice a') => ArrowAddReader r (ErrorArrow ex a) (ErrorArrow ex a')
instance (ArrowWriter w a, ArrowChoice a) => ArrowWriter w (ErrorArrow ex a)
instance (ArrowState s a, ArrowChoice a) => ArrowState s (ErrorArrow ex a)
instance (ArrowReader r a, ArrowChoice a) => ArrowReader r (ErrorArrow ex a)
instance (Monoid ex, ArrowChoice a) => ArrowPlus (ErrorArrow ex a)
instance (Monoid ex, ArrowChoice a) => ArrowZero (ErrorArrow ex a)
instance ArrowChoice a => ArrowAddError ex (ErrorArrow ex a) a
instance ArrowChoice a => ArrowError ex (ErrorArrow ex a)
instance (Monoid ex, ArrowChoice a) => Monoid (ErrorArrow ex a b c)
instance (Monoid ex, ArrowChoice a) => Alternative (ErrorArrow ex a b)
instance ArrowChoice a => Applicative (ErrorArrow ex a b)
instance ArrowChoice a => Functor (ErrorArrow ex a b)
instance (ArrowChoice a, ArrowLoop a) => ArrowLoop (ErrorArrow ex a)
instance (ArrowChoice a, ArrowApply a) => ArrowApply (ErrorArrow ex a)
instance ArrowChoice a => ArrowChoice (ErrorArrow ex a)
instance ArrowChoice a => Arrow (ErrorArrow ex a)
instance ArrowChoice a => Category (ErrorArrow ex a)
instance ArrowChoice a => ArrowTransformer (ErrorArrow ex) a


-- | An arrow transformer that adds a modifiable state, based of section 9
--   of <i>Generalising Monads to Arrows</i>, by John Hughes, <i>Science of
--   Computer Programming</i> 37:67-111, May 2000.
module Control.Arrow.Transformer.State

-- | An arrow type that augments an existing arrow with a modifiable state.
--   The <a>ArrowState</a> class contains the operations on this state.
newtype StateArrow s a b c
StateArrow :: (a (b, s) (c, s)) -> StateArrow s a b c

-- | Encapsulation of a state-using computation, exposing the initial and
--   final states.
--   
--   Typical usage in arrow notation:
--   
--   <pre>
--   proc p -&gt; do
--   	...
--   	(result, final_state) &lt;- (|runState cmd|) init_state
--   </pre>
runState :: Arrow a => StateArrow s a e b -> a (e, s) (b, s)

-- | Adding a <a>StateArrow</a> to an arrow type, but not necessarily as
--   the outer arrow transformer.
--   
--   Typically a composite arrow type is built by applying a series of
--   arrow transformer to a base arrow (usually either a function arrow or
--   a <a>Kleisli</a> arrow. One can add a transformer to the top of this
--   stack using the <a>lift</a> method of the <a>ArrowTransformer</a>
--   class, or remove a state transformer from the top of the stack using
--   the <a>runState</a> encapsulation operator. The methods of this class
--   add and remove state transformers anywhere in the stack. In the
--   instance
--   
--   <pre>
--   instance Arrow a =&gt; ArrowAddState s (ArrowState s a) a
--   </pre>
--   
--   they are equivalent to <a>lift</a> and <a>runState</a> respectively.
--   Instances are lifted through other transformers with
--   
--   <pre>
--   instance ArrowAddState s a a' =&gt;
--   	ArrowAddState s (FooArrow a) (FooArrow a')
--   </pre>
class (ArrowState s a, Arrow a') => ArrowAddState s a a' | a -> a'
liftState :: ArrowAddState s a a' => a' e b -> a e b
elimState :: ArrowAddState s a a' => a e b -> a' (e, s) (b, s)
instance ArrowAddError ex a a' => ArrowAddError ex (StateArrow s a) (StateArrow s a')
instance ArrowAddWriter w a a' => ArrowAddWriter w (StateArrow s a) (StateArrow s a')
instance ArrowAddReader r a a' => ArrowAddReader r (StateArrow s a) (StateArrow s a')
instance ArrowPlus a => Monoid (StateArrow s a b c)
instance ArrowPlus a => Alternative (StateArrow s a b)
instance Arrow a => Applicative (StateArrow s a b)
instance Arrow a => Functor (StateArrow s a b)
instance ArrowPlus a => ArrowPlus (StateArrow s a)
instance ArrowLoop a => ArrowLoop (StateArrow s a)
instance ArrowApply a => ArrowApply (StateArrow s a)
instance ArrowChoice a => ArrowChoice (StateArrow s a)
instance ArrowWriter w a => ArrowWriter w (StateArrow s a)
instance ArrowReader r a => ArrowReader r (StateArrow s a)
instance ArrowError ex a => ArrowError ex (StateArrow s a)
instance ArrowCircuit a => ArrowCircuit (StateArrow s a)
instance ArrowZero a => ArrowZero (StateArrow s a)
instance Arrow a => ArrowAddState s (StateArrow s a) a
instance Arrow a => ArrowState s (StateArrow s a)
instance Arrow a => ArrowTransformer (StateArrow s) a
instance Arrow a => Arrow (StateArrow s a)
instance Category a => Category (StateArrow s a)


-- | Arrow transformer adding static information.
module Control.Arrow.Transformer.Static

-- | An arrow type that augments the underlying arrow with static
--   information.
newtype StaticArrow f a b c
StaticArrow :: (f (a b c)) -> StaticArrow f a b c

-- | A special case is monads applied to the whole arrow, in contrast to
--   <a>Kleisli</a> arrows, in which the monad is applied to the output.
type StaticMonadArrow m = StaticArrow (WrappedMonad m)

-- | A special case.
type StaticArrowArrow a s = StaticArrow (WrappedArrow a s)
wrap :: (Applicative f, Arrow a) => f (a b c) -> StaticArrow f a b c
unwrap :: (Applicative f, Arrow a) => StaticArrow f a b c -> f (a b c)
wrapA :: (Arrow a, Arrow a') => a s (a' b c) -> StaticArrowArrow a s a' b c
unwrapA :: (Arrow a, Arrow a') => StaticArrowArrow a s a' b c -> a s (a' b c)
wrapM :: (Monad m, Arrow a) => m (a b c) -> StaticMonadArrow m a b c
unwrapM :: (Monad m, Arrow a) => StaticMonadArrow m a b c -> m (a b c)
instance (ArrowAddError ex a a', Applicative f) => ArrowAddError ex (StaticArrow f a) (StaticArrow f a')
instance (ArrowAddWriter w a a', Applicative f) => ArrowAddWriter w (StaticArrow f a) (StaticArrow f a')
instance (ArrowAddReader r a a', Applicative f) => ArrowAddReader r (StaticArrow f a) (StaticArrow f a')
instance (ArrowAddState s a a', Applicative f) => ArrowAddState s (StaticArrow f a) (StaticArrow f a')
instance (ArrowAddStream a a', Applicative f) => ArrowAddStream (StaticArrow f a) (StaticArrow f a')
instance (ArrowPlus a, Applicative f) => Monoid (StaticArrow f a b c)
instance (ArrowPlus a, Applicative f) => Alternative (StaticArrow f a b)
instance (Arrow a, Applicative f) => Applicative (StaticArrow f a b)
instance (Arrow a, Applicative f) => Functor (StaticArrow f a b)
instance (ArrowPlus a, Applicative f) => ArrowPlus (StaticArrow f a)
instance (ArrowLoop a, Applicative f) => ArrowLoop (StaticArrow f a)
instance (ArrowChoice a, Applicative f) => ArrowChoice (StaticArrow f a)
instance (ArrowWriter w a, Applicative f) => ArrowWriter w (StaticArrow f a)
instance (ArrowState s a, Applicative f) => ArrowState s (StaticArrow f a)
instance (ArrowReader r a, Applicative f) => ArrowReader r (StaticArrow f a)
instance (ArrowError ex a, Applicative f) => ArrowError ex (StaticArrow f a)
instance (ArrowCircuit a, Applicative f) => ArrowCircuit (StaticArrow f a)
instance (ArrowZero a, Applicative f) => ArrowZero (StaticArrow f a)
instance (Arrow a, Applicative f) => Arrow (StaticArrow f a)
instance (Category a, Applicative f) => Category (StaticArrow f a)
instance (Arrow a, Applicative f) => ArrowTransformer (StaticArrow f) a


-- | Arrow transformer lifting an arrow to streams.
module Control.Arrow.Transformer.Stream

-- | Arrows between streams.
--   
--   <i>Note</i>: <a>lift</a> is only a functor if <a>***</a> in the
--   underlying arrow is.
newtype StreamArrow a b c
StreamArrow :: (a (Stream b) (Stream c)) -> StreamArrow a b c

-- | Run a stream processor on a stream of inputs, obtaining a stream of
--   outputs.
--   
--   Typical usage in arrow notation:
--   
--   <pre>
--   proc p -&gt; do
--   	...
--   	ys &lt;- (|runStream (\x -&gt; ...)|) xs
--   </pre>
--   
--   Here <tt>xs</tt> refers to the input stream and <tt>x</tt> to
--   individual elements of that stream. <tt>ys</tt> is bound to the output
--   stream.
runStream :: ArrowLoop a => StreamArrow a (e, b) c -> a (e, Stream b) (Stream c)

-- | Mappings of streams
type StreamMap = StreamArrow (->)

-- | In-place state updates.
--   
--   <i>Note</i>: this is an arrow type, and <a>lift</a> can be used to
--   promote arrows from <tt><a>Kleisli</a> (<a>ST</a> s)</tt>: the
--   resulting arrow updates the state for each stream element in turn, and
--   as long as the final state in not required all is well. However,
--   <a>lift</a> does not preserve composition, because this monad isn't
--   commutative. In particular, a composition of <a>lift</a>s of state
--   transformers will not work, as the second will require the final state
--   of the first.
type StreamMapST s = StreamArrow (Kleisli (ST s))

-- | Encapsulate a local state.
runStreamST :: (forall s. StreamMapST s e c) -> StreamMap e c

-- | Adding a <a>StreamArrow</a> to an arrow type, but not necessarily as
--   the outer arrow transformer.
--   
--   Typically a composite arrow type is built by applying a series of
--   arrow transformer to a base arrow (usually either a function arrow or
--   a <a>Kleisli</a> arrow. One can add a transformer to the top of this
--   stack using the <a>lift</a> method of the <a>ArrowTransformer</a>
--   class, or remove a state transformer from the top of the stack using
--   the <a>runStream</a> encapsulation operator. The methods of this class
--   add and remove state transformers anywhere in the stack. In the
--   instance
--   
--   <pre>
--   instance Arrow a =&gt; ArrowAddStream (ArrowStream a) a
--   </pre>
--   
--   they are equivalent to <a>lift</a> and <a>runStream</a> respectively.
--   Instances are lifted through other transformers with
--   
--   <pre>
--   instance ArrowAddStream a a' =&gt;
--   	ArrowAddStream (FooArrow a) (FooArrow a')
--   </pre>
class (ArrowCircuit a, Arrow a') => ArrowAddStream a a' | a -> a'
liftStream :: ArrowAddStream a a' => a' e b -> a e b
elimStream :: ArrowAddStream a a' => a (e, b) c -> a' (e, Stream b) (Stream c)
instance ArrowLoop a => ArrowAddStream (StreamArrow a) a
instance ArrowPlus a => Monoid (StreamArrow a b c)
instance ArrowPlus a => Alternative (StreamArrow a b)
instance Arrow a => Applicative (StreamArrow a b)
instance Arrow a => Functor (StreamArrow a b)
instance ArrowLoop a => ArrowCircuit (StreamArrow a)
instance ArrowPlus a => ArrowPlus (StreamArrow a)
instance ArrowLoop a => ArrowLoop (StreamArrow a)
instance Arrow a => ArrowChoice (StreamArrow a)
instance ArrowWriter w a => ArrowWriter w (StreamArrow a)
instance ArrowState s a => ArrowState s (StreamArrow a)
instance ArrowZero a => ArrowZero (StreamArrow a)
instance Arrow a => ArrowTransformer StreamArrow a
instance Arrow a => Arrow (StreamArrow a)
instance Category a => Category (StreamArrow a)


-- | Arrow transformer that adds accumulation of output.
module Control.Arrow.Transformer.Writer

-- | An arrow type that augments an existing arrow with accumulating
--   output. The <a>ArrowWriter</a> class contains the relevant operations.
newtype WriterArrow w a b c
WriterArrow :: (a b (c, w)) -> WriterArrow w a b c

-- | Encapsulation of a writer computation, providing the accumulated
--   output.
--   
--   Typical usage in arrow notation:
--   
--   <pre>
--   proc p -&gt; do
--   	...
--   	(result, output) &lt;- (|runWriter cmd|)
--   </pre>
runWriter :: (Arrow a, Monoid w) => WriterArrow w a e b -> a e (b, w)

-- | Adding a <a>WriterArrow</a> to an arrow type, but not necessarily as
--   the outer arrow transformer.
--   
--   Typically a composite arrow type is built by applying a series of
--   arrow transformer to a base arrow (usually either a function arrow or
--   a <a>Kleisli</a> arrow. One can add a transformer to the top of this
--   stack using the <a>lift</a> method of the <a>ArrowTransformer</a>
--   class, or remove a state transformer from the top of the stack using
--   the <a>runWriter</a> encapsulation operator. The methods of this class
--   add and remove state transformers anywhere in the stack. In the
--   instance
--   
--   <pre>
--   instance Arrow a =&gt; ArrowAddWriter w (ArrowWriter w a) a
--   </pre>
--   
--   they are equivalent to <a>lift</a> and <a>runWriter</a> respectively.
--   Instances are lifted through other transformers with
--   
--   <pre>
--   instance ArrowAddWriter w a a' =&gt;
--   	ArrowAddWriter w (FooArrow a) (FooArrow a')
--   </pre>
class (ArrowWriter w a, Arrow a') => ArrowAddWriter w a a' | a -> a'
liftWriter :: ArrowAddWriter w a a' => a' e b -> a e b
elimWriter :: ArrowAddWriter w a a' => a e b -> a' e (b, w)
instance (ArrowAddState s a a', Monoid w) => ArrowAddState s (WriterArrow w a) (WriterArrow w a')
instance (ArrowAddReader r a a', Monoid w) => ArrowAddReader r (WriterArrow w a) (WriterArrow w a')
instance (ArrowAddError ex a a', Monoid w) => ArrowAddError ex (WriterArrow w a) (WriterArrow w a')
instance (ArrowState s a, Monoid w) => ArrowState s (WriterArrow w a)
instance (ArrowReader r a, Monoid w) => ArrowReader r (WriterArrow w a)
instance (ArrowError ex a, Monoid w) => ArrowError ex (WriterArrow w a)
instance (ArrowCircuit a, Monoid w) => ArrowCircuit (WriterArrow w a)
instance (Arrow a, Monoid w) => ArrowAddWriter w (WriterArrow w a) a
instance (Arrow a, Monoid w) => ArrowWriter w (WriterArrow w a)
instance (ArrowPlus a, Monoid w) => Monoid (WriterArrow w a b c)
instance (ArrowPlus a, Monoid w) => Alternative (WriterArrow w a b)
instance (Arrow a, Monoid w) => Applicative (WriterArrow w a b)
instance (Arrow a, Monoid w) => Functor (WriterArrow w a b)
instance (ArrowLoop a, Monoid w) => ArrowLoop (WriterArrow w a)
instance (ArrowPlus a, Monoid w) => ArrowPlus (WriterArrow w a)
instance (ArrowZero a, Monoid w) => ArrowZero (WriterArrow w a)
instance (ArrowApply a, Monoid w) => ArrowApply (WriterArrow w a)
instance (ArrowChoice a, Monoid w) => ArrowChoice (WriterArrow w a)
instance (Arrow a, Monoid w) => Arrow (WriterArrow w a)
instance (Arrow a, Monoid w) => Category (WriterArrow w a)
instance (Arrow a, Monoid w) => ArrowTransformer (WriterArrow w) a


-- | Arrow transformer that adds a read-only state (i.e. an environment).
module Control.Arrow.Transformer.Reader

-- | An arrow type that augments an existing arrow with a read-only state
--   (or environment). The <a>ArrowReader</a> class contains the operations
--   on this state.
newtype ReaderArrow r a b c
ReaderArrow :: (a (b, r) c) -> ReaderArrow r a b c

-- | Encapsulation of a state-reading computation, taking a value for the
--   state.
--   
--   Typical usage in arrow notation:
--   
--   <pre>
--   proc p -&gt; ...
--   	(|runReader cmd|) env
--   </pre>
runReader :: Arrow a => ReaderArrow r a e b -> a (e, r) b

-- | Adding a <a>ReaderArrow</a> to an arrow type, but not necessarily as
--   the outer arrow transformer.
--   
--   Typically a composite arrow type is built by applying a series of
--   arrow transformer to a base arrow (usually either a function arrow or
--   a <a>Kleisli</a> arrow. One can add a transformer to the top of this
--   stack using the <a>lift</a> method of the <a>ArrowTransformer</a>
--   class, or remove a state transformer from the top of the stack using
--   the <a>runReader</a> encapsulation operator. The methods of this class
--   add and remove state transformers anywhere in the stack. In the
--   instance
--   
--   <pre>
--   instance Arrow a =&gt; ArrowAddReader r (ArrowReader r a) a
--   </pre>
--   
--   they are equivalent to <a>lift</a> and <a>runReader</a> respectively.
--   Instances are lifted through other transformers with
--   
--   <pre>
--   instance ArrowAddReader r a a' =&gt;
--   	ArrowAddReader r (FooArrow a) (FooArrow a')
--   </pre>
class (ArrowReader r a, Arrow a') => ArrowAddReader r a a' | a -> a'
liftReader :: ArrowAddReader r a a' => a' e b -> a e b
elimReader :: ArrowAddReader r a a' => a e b -> a' (e, r) b
instance ArrowPlus a => Monoid (ReaderArrow r a b c)
instance ArrowPlus a => Alternative (ReaderArrow r a b)
instance Arrow a => Applicative (ReaderArrow r a b)
instance Arrow a => Functor (ReaderArrow r a b)
instance ArrowAddWriter s a a' => ArrowAddWriter s (ReaderArrow r a) (ReaderArrow r a')
instance ArrowAddState s a a' => ArrowAddState s (ReaderArrow r a) (ReaderArrow r a')
instance ArrowAddError ex a a' => ArrowAddError ex (ReaderArrow r a) (ReaderArrow r a')
instance ArrowWriter s a => ArrowWriter s (ReaderArrow r a)
instance ArrowState s a => ArrowState s (ReaderArrow r a)
instance ArrowError ex a => ArrowError ex (ReaderArrow r a)
instance ArrowCircuit a => ArrowCircuit (ReaderArrow r a)
instance Arrow a => ArrowAddReader r (ReaderArrow r a) a
instance Arrow a => ArrowReader r (ReaderArrow r a)
instance ArrowLoop a => ArrowLoop (ReaderArrow r a)
instance ArrowPlus a => ArrowPlus (ReaderArrow r a)
instance ArrowZero a => ArrowZero (ReaderArrow r a)
instance ArrowApply a => ArrowApply (ReaderArrow r a)
instance ArrowChoice a => ArrowChoice (ReaderArrow r a)
instance Arrow a => Arrow (ReaderArrow r a)
instance Arrow a => Category (ReaderArrow r a)
instance Arrow a => ArrowTransformer (ReaderArrow r) a

module Control.Arrow.Transformer.All
