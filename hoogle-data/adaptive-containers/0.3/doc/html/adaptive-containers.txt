-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Self optimizing container types
--   
--   Self optimizing polymorphic container types.
--   
--   Adaptive containers are polymorphic container types that use class
--   associated data types to specialize particular element types to a more
--   efficient container representation. The resulting structures tend to
--   be both more time and space efficient.
--   
--   A self-optimizing pair, for example, will unpack the constructors,
--   yielding a representation for (Int,Char) requiring 8 bytes, instead of
--   24.
--   
--   This difference can be visualized. Consider the expression:
--   
--   <pre>
--   [ (x,y) | x &lt;- [1..3], y &lt;- [x..3] ]
--   </pre>
--   
--   <ul>
--   <li><i>[(Int,Int)]</i>: A regular list of pairs
--   <a>http://code.haskell.org/~dons/images/vacuum/tuple-list.png</a></li>
--   <li><i>[Pair Int Int]</i>: An adaptive list of pairs
--   <a>http://code.haskell.org/~dons/images/vacuum/pair-list.png</a></li>
--   <li><i>List (Pair Int Int)</i>: An adaptive list of adaptive pairs
--   <a>http://code.haskell.org/~dons/images/vacuum/list-pair.png</a></li>
--   </ul>
--   
--   Currently supported adaptive containers: pairs, lists, maybes
--   
--   Most unboxed element types are supported.
@package adaptive-containers
@version 0.3


-- | Self optimzing sum types.
--   
--   This library statically adapts the polymorphic container
--   representation of Maybe to specific, more efficient representations,
--   when instantiated with particular monomorphic types. It does this via
--   an associated more efficient data type for each pair of elements you
--   wish to store in your container.
--   
--   That is, instead of representing 'Maybe Int' as:
--   
--   <pre>
--   Just
--     | 
--   I# 3#
--   </pre>
--   
--   A self-optimizing pair will unpack the constructors, yielding this
--   data representation:
--   
--   <pre>
--   JustInt 3#
--   </pre>
--   
--   Saving an indirection. The resulting structure should be both more
--   time and space efficient than the generic polymorphic container it is
--   derived from.
--   
--   Self adaptive polymorphic containers are able to unpack their
--   components, something not possible with, for example, strict
--   polymorphic containers.
module Data.Adaptive.Maybe
class AdaptMaybe a where { data family Maybe a; }
just :: AdaptMaybe a => a -> Maybe a
nothing :: AdaptMaybe a => Maybe a
isJust :: AdaptMaybe a => Maybe a -> Bool
maybe :: AdaptMaybe a => b -> (a -> b) -> Maybe a -> b

-- | The <a>isNothing</a> function returns <a>True</a> iff its argument is
--   <tt>Nothing</tt>.
isNothing :: AdaptMaybe a => Maybe a -> Bool

-- | The <a>fromJust</a> function extracts the element out of a
--   <tt>Just</tt> and throws an error if its argument is <tt>Nothing</tt>.
fromJust :: AdaptMaybe a => Maybe a -> a

-- | The <a>fromMaybe</a> function takes a default value and and
--   <a>Maybe</a> value. If the <a>Maybe</a> is <tt>Nothing</tt>, it
--   returns the default values; otherwise, it returns the value contained
--   in the <a>Maybe</a>.
fromMaybe :: AdaptMaybe a => a -> Maybe a -> a

-- | The <a>maybeToList</a> function returns an empty list when given
--   <tt>Nothing</tt> or a singleton list when not given <tt>Nothing</tt>.
maybeToList :: AdaptMaybe a => Maybe a -> [a]

-- | The <a>listToMaybe</a> function returns <tt>Nothing</tt> on an empty
--   list or <tt><tt>Just</tt> a</tt> where <tt>a</tt> is the first element
--   of the list.
listToMaybe :: AdaptMaybe a => [a] -> Maybe a

-- | The <a>catMaybes</a> function takes a list of <a>Maybe</a>s and
--   returns a list of all the <tt>Just</tt> values.
catMaybes :: AdaptMaybe a => [Maybe a] -> [a]

-- | The <a>mapMaybe</a> function is a version of <a>map</a> which can
--   throw out elements. In particular, the functional argument returns
--   something of type <tt><a>Maybe</a> b</tt>. If this is
--   <tt>Nothing</tt>, no element is added on to the result list. If it
--   just <tt><tt>Just</tt> b</tt>, then <tt>b</tt> is included in the
--   result list.
mapMaybe :: AdaptMaybe b => (a -> Maybe b) -> [a] -> [b]
instance AdaptMaybe Char
instance AdaptMaybe Float
instance AdaptMaybe Double
instance AdaptMaybe Word64
instance AdaptMaybe Word32
instance AdaptMaybe Word16
instance AdaptMaybe Word8
instance AdaptMaybe Word
instance AdaptMaybe Int64
instance AdaptMaybe Int32
instance AdaptMaybe Int16
instance AdaptMaybe Int8
instance AdaptMaybe Integer
instance AdaptMaybe Int


-- | Self optimzing pair types.
--   
--   This library statically adapts the polymorphic container
--   representation of tuples to specific, more efficient representations,
--   when instantiated with particular monomorphic types. It does this via
--   an associated more efficient data type for each pair of elements you
--   wish to store in your container.
--   
--   That is, instead of representing '(Int,Char)' as:
--   
--   <pre>
--        (,)
--       /   \
--   I# 3#   C# x#
--   </pre>
--   
--   A self-optimizing pair will unpack the constructors, yielding this
--   data representation:
--   
--   <pre>
--   PairIntChar 3# x#
--   </pre>
--   
--   Saving two indirections. The resulting structure should be both more
--   time and space efficient than the generic polymorphic container it is
--   derived from. For example, adaptive pairs use 8 bytes to store an Int
--   and Char pair, while a lazy pair uses 24 bytes.
--   
--   <pre>
--   &gt; Prelude Size&gt; unsafeSizeof ((42, 'x') :: (Int,Char))
--   &gt; 24
--   </pre>
--   
--   <pre>
--   Prelude Size&gt; unsafeSizeof (pair 42 'x' :: Pair Int Char)
--   &gt; 8
--   </pre>
--   
--   You can inspect the size and layout of your adaptive structures using
--   two scripts, one for measuring the size of a closure, described in
--   <a>http://ghcmutterings.wordpress.com/2009/02/</a>, and vacuum-cairo,
--   for rendering the heap structure explicitly
--   <a>http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vacuum-cairo</a>
--   
--   Types that instantiate the <tt>Adapt</tt> class will self-adapt this
--   way.
--   
--   Self adaptive polymorphic containers are able to unpack their
--   components, something not possible with, for example, strict
--   polymorphic containers.
module Data.Adaptive.Tuple

-- | Representation-improving polymorphic tuples.
class AdaptPair a b where { data family Pair a b; }
fst :: AdaptPair a b => Pair a b -> a
snd :: AdaptPair a b => Pair a b -> b
curry :: AdaptPair a b => (Pair a b -> c) -> a -> b -> c

-- | Construct a new pair.
pair :: AdaptPair a b => a -> b -> Pair a b

-- | <a>uncurry</a> converts a curried function to a function on pairs.
uncurry :: AdaptPair a b => (a -> b -> c) -> (Pair a b -> c)

-- | Convert an adaptive pair to a regular polymorphic tuple
fromPair :: AdaptPair a b => Pair a b -> (a, b)

-- | Convert a regular polymorphic tuple to an adaptive pair
toPair :: AdaptPair a b => (a, b) -> Pair a b
instance AdaptPair Char Char
instance AdaptPair Char Float
instance AdaptPair Char Double
instance AdaptPair Char Word64
instance AdaptPair Char Word32
instance AdaptPair Char Word16
instance AdaptPair Char Word8
instance AdaptPair Char Word
instance AdaptPair Char Int64
instance AdaptPair Char Int32
instance AdaptPair Char Int16
instance AdaptPair Char Int8
instance AdaptPair Char Integer
instance AdaptPair Char Int
instance AdaptPair Float Char
instance AdaptPair Float Float
instance AdaptPair Float Double
instance AdaptPair Float Word64
instance AdaptPair Float Word32
instance AdaptPair Float Word16
instance AdaptPair Float Word8
instance AdaptPair Float Word
instance AdaptPair Float Int64
instance AdaptPair Float Int32
instance AdaptPair Float Int16
instance AdaptPair Float Int8
instance AdaptPair Float Integer
instance AdaptPair Float Int
instance AdaptPair Double Char
instance AdaptPair Double Float
instance AdaptPair Double Double
instance AdaptPair Double Word64
instance AdaptPair Double Word32
instance AdaptPair Double Word16
instance AdaptPair Double Word8
instance AdaptPair Double Word
instance AdaptPair Double Int64
instance AdaptPair Double Int32
instance AdaptPair Double Int16
instance AdaptPair Double Int8
instance AdaptPair Double Integer
instance AdaptPair Double Int
instance AdaptPair Word64 Char
instance AdaptPair Word64 Float
instance AdaptPair Word64 Double
instance AdaptPair Word64 Word64
instance AdaptPair Word64 Word32
instance AdaptPair Word64 Word16
instance AdaptPair Word64 Word8
instance AdaptPair Word64 Word
instance AdaptPair Word64 Int64
instance AdaptPair Word64 Int32
instance AdaptPair Word64 Int16
instance AdaptPair Word64 Int8
instance AdaptPair Word64 Integer
instance AdaptPair Word64 Int
instance AdaptPair Word32 Char
instance AdaptPair Word32 Float
instance AdaptPair Word32 Double
instance AdaptPair Word32 Word64
instance AdaptPair Word32 Word32
instance AdaptPair Word32 Word16
instance AdaptPair Word32 Word8
instance AdaptPair Word32 Word
instance AdaptPair Word32 Int64
instance AdaptPair Word32 Int32
instance AdaptPair Word32 Int16
instance AdaptPair Word32 Int8
instance AdaptPair Word32 Integer
instance AdaptPair Word32 Int
instance AdaptPair Word16 Char
instance AdaptPair Word16 Float
instance AdaptPair Word16 Double
instance AdaptPair Word16 Word64
instance AdaptPair Word16 Word32
instance AdaptPair Word16 Word16
instance AdaptPair Word16 Word8
instance AdaptPair Word16 Word
instance AdaptPair Word16 Int64
instance AdaptPair Word16 Int32
instance AdaptPair Word16 Int16
instance AdaptPair Word16 Int8
instance AdaptPair Word16 Integer
instance AdaptPair Word16 Int
instance AdaptPair Word8 Char
instance AdaptPair Word8 Float
instance AdaptPair Word8 Double
instance AdaptPair Word8 Word64
instance AdaptPair Word8 Word32
instance AdaptPair Word8 Word16
instance AdaptPair Word8 Word8
instance AdaptPair Word8 Word
instance AdaptPair Word8 Int64
instance AdaptPair Word8 Int32
instance AdaptPair Word8 Int16
instance AdaptPair Word8 Int8
instance AdaptPair Word8 Integer
instance AdaptPair Word8 Int
instance AdaptPair Word Char
instance AdaptPair Word Float
instance AdaptPair Word Double
instance AdaptPair Word Word64
instance AdaptPair Word Word32
instance AdaptPair Word Word16
instance AdaptPair Word Word8
instance AdaptPair Word Word
instance AdaptPair Word Int64
instance AdaptPair Word Int32
instance AdaptPair Word Int16
instance AdaptPair Word Int8
instance AdaptPair Word Integer
instance AdaptPair Word Int
instance AdaptPair Int64 Char
instance AdaptPair Int64 Float
instance AdaptPair Int64 Double
instance AdaptPair Int64 Word64
instance AdaptPair Int64 Word32
instance AdaptPair Int64 Word16
instance AdaptPair Int64 Word8
instance AdaptPair Int64 Word
instance AdaptPair Int64 Int64
instance AdaptPair Int64 Int32
instance AdaptPair Int64 Int16
instance AdaptPair Int64 Int8
instance AdaptPair Int64 Integer
instance AdaptPair Int64 Int
instance AdaptPair Int32 Char
instance AdaptPair Int32 Float
instance AdaptPair Int32 Double
instance AdaptPair Int32 Word64
instance AdaptPair Int32 Word32
instance AdaptPair Int32 Word16
instance AdaptPair Int32 Word8
instance AdaptPair Int32 Word
instance AdaptPair Int32 Int64
instance AdaptPair Int32 Int32
instance AdaptPair Int32 Int16
instance AdaptPair Int32 Int8
instance AdaptPair Int32 Integer
instance AdaptPair Int32 Int
instance AdaptPair Int16 Char
instance AdaptPair Int16 Float
instance AdaptPair Int16 Double
instance AdaptPair Int16 Word64
instance AdaptPair Int16 Word32
instance AdaptPair Int16 Word16
instance AdaptPair Int16 Word8
instance AdaptPair Int16 Word
instance AdaptPair Int16 Int64
instance AdaptPair Int16 Int32
instance AdaptPair Int16 Int16
instance AdaptPair Int16 Int8
instance AdaptPair Int16 Integer
instance AdaptPair Int16 Int
instance AdaptPair Int8 Char
instance AdaptPair Int8 Float
instance AdaptPair Int8 Double
instance AdaptPair Int8 Word64
instance AdaptPair Int8 Word32
instance AdaptPair Int8 Word16
instance AdaptPair Int8 Word8
instance AdaptPair Int8 Word
instance AdaptPair Int8 Int64
instance AdaptPair Int8 Int32
instance AdaptPair Int8 Int16
instance AdaptPair Int8 Int8
instance AdaptPair Int8 Integer
instance AdaptPair Int8 Int
instance AdaptPair Integer Char
instance AdaptPair Integer Float
instance AdaptPair Integer Double
instance AdaptPair Integer Word64
instance AdaptPair Integer Word32
instance AdaptPair Integer Word16
instance AdaptPair Integer Word8
instance AdaptPair Integer Word
instance AdaptPair Integer Int64
instance AdaptPair Integer Int32
instance AdaptPair Integer Int16
instance AdaptPair Integer Int8
instance AdaptPair Integer Integer
instance AdaptPair Integer Int
instance AdaptPair Int Char
instance AdaptPair Int Float
instance AdaptPair Int Double
instance AdaptPair Int Word64
instance AdaptPair Int Word32
instance AdaptPair Int Word16
instance AdaptPair Int Word8
instance AdaptPair Int Word
instance AdaptPair Int Int64
instance AdaptPair Int Int32
instance AdaptPair Int Int16
instance AdaptPair Int Int8
instance AdaptPair Int Integer
instance AdaptPair Int Int
instance AdaptPair Bool Bool
instance AdaptPair () ()
instance (Show a, Show b, AdaptPair a b) => Show (Pair a b)
instance (Ord a, Ord b, AdaptPair a b) => Ord (Pair a b)
instance (Eq a, Eq b, AdaptPair a b) => Eq (Pair a b)
instance (Bounded a, Bounded b, AdaptPair a b) => Bounded (Pair a b)


-- | Self adapting polymorphic lists.
--   
--   This library statically specializes the polymorphic container
--   representation of lists to specific, more efficient representations,
--   when instantiated with particular monomorphic types. It does this via
--   an associated more efficient data type for each pair of elements you
--   wish to store in your container.
--   
--   The resulting list structures use less space, and functions on them
--   tend to be faster, than regular lists.
--   
--   Instead of representing '[1..5] :: [Int]' as:
--   
--   <pre>
--        (:) 
--       /   \
--      /     \
--   I# 1#    (:)
--           /   \
--          /     \
--       I# 2#    (:)
--               /   \
--              /     \
--           I# 3#    []
--   </pre>
--   
--   The compiler will select an associated data type that packs better,
--   via the class instances, resulting in:
--   
--   <pre>
--   ConsInt 1#
--    |
--   ConsInt 2#
--    |
--   ConsInt 3#
--    |
--    []
--   </pre>
--   
--   The user however, still sees a polymorphic list type.
--   
--   This list type currently doesn't fuse.
module Data.Adaptive.List

-- | Representation-improving polymorphic lists.
class AdaptList a where { data family List a; }
empty :: AdaptList a => List a
cons :: AdaptList a => a -> List a -> List a
null :: AdaptList a => List a -> Bool
head :: AdaptList a => List a -> a
tail :: AdaptList a => List a -> List a

-- | <i>O(n)</i>, convert an adaptive list to a regular list
toList :: AdaptList a => List a -> [a]

-- | <i>O(n)</i>, convert an adaptive list to a regular list
fromList :: AdaptList a => [a] -> List a

-- | <i>O(n)</i>, construct a list by enumerating a range
enumFromToList :: (AdaptList a, Ord a, Enum a) => a -> a -> List a

-- | <i>O(1)</i>, uncons, take apart a list into the head and tail.
uncons :: AdaptList a => List a -> Maybe (a, List a)

-- | <i>O(n)</i>, Append two lists, i.e.,
--   
--   <pre>
--   [x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
--   [x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]
--   </pre>
--   
--   If the first list is not finite, the result is the first list. The
--   spine of the first list argument must be copied.
(++) :: AdaptList a => List a -> List a -> List a

-- | <i>O(n)</i>, Extract the last element of a list, which must be finite
--   and non-empty.
last :: AdaptList a => List a -> a

-- | <i>O(n)</i>. Return all the elements of a list except the last one.
--   The list must be finite and non-empty.
init :: AdaptList a => List a -> List a

-- | <i>O(n)</i>. <a>length</a> returns the length of a finite list as an
--   <a>Int</a>. It is an instance of the more general
--   <tt>Data.List.genericLength</tt>, the result type of which may be any
--   kind of number.
length :: AdaptList a => List a -> Int

-- | <i>O(n)</i>. <a>map</a> <tt>f xs</tt> is the list obtained by applying
--   <tt>f</tt> to each element of <tt>xs</tt>, i.e.,
--   
--   <pre>
--   map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
--   map f [x1, x2, ...] == [f x1, f x2, ...]
--   </pre>
--   
--   Properties:
--   
--   <pre>
--   map f . map g         = map (f . g)
--   map f (repeat x)      = repeat (f x)
--   map f (replicate n x) = replicate n (f x)
--   </pre>
map :: (AdaptList a, AdaptList b) => (a -> b) -> List a -> List b

-- | <i>O(n)</i>. <a>reverse</a> <tt>xs</tt> returns the elements of
--   <tt>xs</tt> in reverse order. <tt>xs</tt> must be finite. Will fuse as
--   a consumer only.
reverse :: AdaptList a => List a -> List a

-- | <i>O(n)</i>. The <a>intersperse</a> function takes an element and a
--   list and `intersperses' that element between the elements of the list.
--   For example,
--   
--   <pre>
--   intersperse ',' "abcde" == "a,b,c,d,e"
--   </pre>
intersperse :: AdaptList a => a -> List a -> List a

-- | <i>O(n)</i>. <a>intercalate</a> <tt>xs xss</tt> is equivalent to
--   <tt>(<a>concat</a> (<a>intersperse</a> xs xss))</tt>. It inserts the
--   list <tt>xs</tt> in between the lists in <tt>xss</tt> and concatenates
--   the result.
--   
--   <pre>
--   intercalate = concat . intersperse
--   </pre>
intercalate :: (AdaptList (List a), AdaptList a) => List a -> List (List a) -> List a

-- | <i>O(n)</i>. <a>foldl</a>, applied to a binary operator, a starting
--   value (typically the left-identity of the operator), and a list,
--   reduces the list using the binary operator, from left to right:
--   
--   <pre>
--   foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn
--   </pre>
--   
--   The list must be finite. The accumulator is whnf strict.
foldl :: AdaptList b => (a -> b -> a) -> a -> List b -> a

-- | <i>O(n)</i>. <a>foldl1</a> is a variant of <a>foldl</a> that has no
--   starting value argument, and thus must be applied to non-empty lists.
foldl1 :: AdaptList a => (a -> a -> a) -> List a -> a

-- | <i>O(n)</i>. <a>foldr</a>, applied to a binary operator, a starting
--   value (typically the right-identity of the operator), and a list,
--   reduces the list using the binary operator, from right to left:
--   
--   <pre>
--   foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)
--   </pre>
foldr :: AdaptList a => (a -> b -> b) -> b -> List a -> b

-- | <i>O(n)</i>. <a>foldr1</a> is a variant of <a>foldr</a> that has no
--   starting value argument, and thus must be applied to non-empty lists.
foldr1 :: AdaptList a => (a -> a -> a) -> List a -> a

-- | <i>O(n)</i>. Concatenate a list of lists. concat :: [[a]] -&gt; [a]
concat :: (AdaptList (List a), AdaptList a) => List (List a) -> List a

-- | <i>O(n)</i>, <i>fusion</i>. Map a function over a list and concatenate
--   the results.
concatMap :: (AdaptList a1, AdaptList a) => (a -> List a1) -> List a -> List a1

-- | <i>O(n)</i>. <a>and</a> returns the conjunction of a Boolean list. For
--   the result to be <a>True</a>, the list must be finite; <a>False</a>,
--   however, results from a <a>False</a> value at a finite index of a
--   finite or infinite list.
and :: List Bool -> Bool

-- | <i>O(n)</i>. <a>or</a> returns the disjunction of a Boolean list. For
--   the result to be <a>False</a>, the list must be finite; <a>True</a>,
--   however, results from a <a>True</a> value at a finite index of a
--   finite or infinite list.
or :: List Bool -> Bool

-- | <i>O(n)</i>. Applied to a predicate and a list, <a>any</a> determines
--   if any element of the list satisfies the predicate.
any :: AdaptList a => (a -> Bool) -> List a -> Bool

-- | Applied to a predicate and a list, <a>all</a> determines if all
--   elements of the list satisfy the predicate.
all :: AdaptList a => (a -> Bool) -> List a -> Bool

-- | <i>O(n)</i>, <i>fusion</i>. The <a>sum</a> function computes the sum
--   of a finite list of numbers.
sum :: (AdaptList a, Num a) => List a -> a

-- | <i>O(n)</i>,<i>fusion</i>. The <a>product</a> function computes the
--   product of a finite list of numbers.
product :: (AdaptList a, Num a) => List a -> a

-- | <i>O(n)</i>. <a>maximum</a> returns the maximum value from a list,
--   which must be non-empty, finite, and of an ordered type. It is a
--   special case of <tt>Data.List.maximumBy</tt>, which allows the
--   programmer to supply their own comparison function.
maximum :: (AdaptList a, Ord a) => List a -> a

-- | <i>O(n)</i>. <a>minimum</a> returns the minimum value from a list,
--   which must be non-empty, finite, and of an ordered type. It is a
--   special case of <tt>Data.List.minimumBy</tt>, which allows the
--   programmer to supply their own comparison function.
minimum :: (AdaptList a, Ord a) => List a -> a

-- | <i>O(n)</i>. <a>scanl</a> is similar to <a>foldl</a>, but returns a
--   list of successive reduced values from the left:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
--   
--   Properties:
--   
--   <pre>
--   last (scanl f z xs) == foldl f z x
--   </pre>
scanl :: (AdaptList b, AdaptList a) => (a -> b -> a) -> a -> List b -> List a

-- | <i>O(n)</i>. <a>scanl1</a> is a variant of <a>scanl</a> that has no
--   starting value argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
scanl1 :: AdaptList a => (a -> a -> a) -> List a -> List a

-- | <i>O(n)</i>. <a>scanr</a> is the right-to-left dual of <a>scanl</a>.
--   Properties:
--   
--   <pre>
--   head (scanr f z xs) == foldr f z xs
--   </pre>
scanr :: (AdaptList a, AdaptList b) => (a -> b -> b) -> b -> List a -> List b

-- | <a>scanr1</a> is a variant of <a>scanr</a> that has no starting value
--   argument.
scanr1 :: AdaptList a => (a -> a -> a) -> List a -> List a

-- | <i>O(n)</i>, <a>iterate</a> <tt>f x</tt> returns an infinite list of
--   repeated applications of <tt>f</tt> to <tt>x</tt>:
--   
--   <pre>
--   iterate f x == [x, f x, f (f x), ...]
--   </pre>
iterate :: AdaptList a => (a -> a) -> a -> List a

-- | <i>O(n)</i>. <a>repeat</a> <tt>x</tt> is an infinite list, with
--   <tt>x</tt> the value of every element.
repeat :: AdaptList a => a -> List a

-- | <i>O(n)</i>. <a>replicate</a> <tt>n x</tt> is a list of length
--   <tt>n</tt> with <tt>x</tt> the value of every element. It is an
--   instance of the more general <tt>Data.List.genericReplicate</tt>, in
--   which <tt>n</tt> may be of any integral type.
replicate :: AdaptList a => Int -> a -> List a

-- | <i>fusion</i>. <a>cycle</a> ties a finite list into a circular one, or
--   equivalently, the infinite repetition of the original list. It is the
--   identity on infinite lists.
cycle :: AdaptList a => List a -> List a

-- | The <a>unfoldr</a> function is a `dual' to <a>foldr</a>: while
--   <a>foldr</a> reduces a list to a summary value, <a>unfoldr</a> builds
--   a list from a seed value. The function takes the element and returns
--   <tt>Nothing</tt> if it is done producing the list or returns
--   <tt>Just</tt> <tt>(a,b)</tt>, in which case, <tt>a</tt> is a prepended
--   to the list and <tt>b</tt> is used as the next element in a recursive
--   call. For example,
--   
--   <pre>
--   iterate f == unfoldr (\x -&gt; Just (x, f x))
--   </pre>
--   
--   In some cases, <a>unfoldr</a> can undo a <a>foldr</a> operation:
--   
--   <pre>
--   unfoldr f' (foldr f z xs) == xs
--   </pre>
--   
--   if the following holds:
--   
--   <pre>
--   f' (f x y) = Just (x,y)
--   f' z       = Nothing
--   </pre>
--   
--   A simple use of unfoldr:
--   
--   <pre>
--   unfoldr (\b -&gt; if b == 0 then Nothing else Just (b, b-1)) 10
--    [10,9,8,7,6,5,4,3,2,1]
--   </pre>
--   
--   <i>TODO</i>: AdaptPair state.
unfoldr :: AdaptList a => (b -> Maybe (a, b)) -> b -> List a

-- | <i>O(n)</i>. <a>take</a> <tt>n</tt>, applied to a list <tt>xs</tt>,
--   returns the prefix of <tt>xs</tt> of length <tt>n</tt>, or <tt>xs</tt>
--   itself if <tt>n &gt; <a>length</a> xs</tt>:
--   
--   <pre>
--   take 5 "Hello World!" == "Hello"
--   take 3 [1,2,3,4,5] == [1,2,3]
--   take 3 [1,2] == [1,2]
--   take 3 [] == []
--   take (-1) [1,2] == []
--   take 0 [1,2] == []
--   </pre>
--   
--   It is an instance of the more general <tt>Data.List.genericTake</tt>,
--   in which <tt>n</tt> may be of any integral type.
take :: AdaptList a => Int -> List a -> List a

-- | <i>O(n)</i>. <a>drop</a> <tt>n xs</tt> returns the suffix of
--   <tt>xs</tt> after the first <tt>n</tt> elements, or <tt>[]</tt> if
--   <tt>n &gt; <a>length</a> xs</tt>:
--   
--   <pre>
--   drop 6 "Hello World!" == "World!"
--   drop 3 [1,2,3,4,5] == [4,5]
--   drop 3 [1,2] == []
--   drop 3 [] == []
--   drop (-1) [1,2] == [1,2]
--   drop 0 [1,2] == [1,2]
--   </pre>
--   
--   It is an instance of the more general <tt>Data.List.genericDrop</tt>,
--   in which <tt>n</tt> may be of any integral type.
drop :: AdaptList a => Int -> List a -> List a

-- | <a>splitAt</a> <tt>n xs</tt> returns a tuple where first element is
--   <tt>xs</tt> prefix of length <tt>n</tt> and second element is the
--   remainder of the list:
--   
--   <pre>
--   splitAt 6 "Hello World!" == ("Hello ","World!")
--   splitAt 3 [1,2,3,4,5] == ([1,2,3],[4,5])
--   splitAt 1 [1,2,3] == ([1],[2,3])
--   splitAt 3 [1,2,3] == ([1,2,3],[])
--   splitAt 4 [1,2,3] == ([1,2,3],[])
--   splitAt 0 [1,2,3] == ([],[1,2,3])
--   splitAt (-1) [1,2,3] == ([],[1,2,3])
--   </pre>
--   
--   It is equivalent to <tt>(<a>take</a> n xs, <a>drop</a> n xs)</tt>.
--   <a>splitAt</a> is an instance of the more general
--   <tt>Data.List.genericSplitAt</tt>, in which <tt>n</tt> may be of any
--   integral type.
splitAt :: AdaptList a => Int -> List a -> (List a, List a)

-- | <i>O(n)</i>. <a>elem</a> is the list membership predicate, usually
--   written in infix form, e.g., <tt>x <a>elem</a> xs</tt>.
elem :: (AdaptList a, Eq a) => a -> List a -> Bool

-- | <i>O(n)</i>. <a>notElem</a> is the negation of <a>elem</a>.
notElem :: (AdaptList a, Eq a) => a -> List a -> Bool

-- | <i>O(n)</i>. <a>filter</a>, applied to a predicate and a list, returns
--   the list of those elements that satisfy the predicate; i.e.,
--   
--   <pre>
--   filter p xs = [ x | x &lt;- xs, p x]
--   </pre>
--   
--   Properties:
--   
--   <pre>
--   filter p (filter q s) = filter (\x -&gt; q x &amp;&amp; p x) s
--   </pre>
filter :: AdaptList a => (a -> Bool) -> List a -> List a

-- | <i>O(n)</i>,<i>fusion</i>. <a>zip</a> takes two lists and returns a
--   list of corresponding pairs. If one input list is short, excess
--   elements of the longer list are discarded.
--   
--   Properties:
--   
--   <pre>
--   zip a b = zipWith (,) a b
--   </pre>
zip :: (AdaptPair a b, AdaptList a, AdaptList b, AdaptList (Pair a b)) => List a -> List b -> List (Pair a b)
errorEmptyList :: String -> a
moduleError :: String -> String -> a
bottom :: a
instance AdaptList (Pair Char Char)
instance AdaptList (Pair Char Float)
instance AdaptList (Pair Char Double)
instance AdaptList (Pair Char Word64)
instance AdaptList (Pair Char Word32)
instance AdaptList (Pair Char Word16)
instance AdaptList (Pair Char Word8)
instance AdaptList (Pair Char Word)
instance AdaptList (Pair Char Int64)
instance AdaptList (Pair Char Int32)
instance AdaptList (Pair Char Int16)
instance AdaptList (Pair Char Int8)
instance AdaptList (Pair Char Integer)
instance AdaptList (Pair Char Int)
instance AdaptList (Pair Float Char)
instance AdaptList (Pair Float Float)
instance AdaptList (Pair Float Double)
instance AdaptList (Pair Float Word64)
instance AdaptList (Pair Float Word32)
instance AdaptList (Pair Float Word16)
instance AdaptList (Pair Float Word8)
instance AdaptList (Pair Float Word)
instance AdaptList (Pair Float Int64)
instance AdaptList (Pair Float Int32)
instance AdaptList (Pair Float Int16)
instance AdaptList (Pair Float Int8)
instance AdaptList (Pair Float Integer)
instance AdaptList (Pair Float Int)
instance AdaptList (Pair Double Char)
instance AdaptList (Pair Double Float)
instance AdaptList (Pair Double Double)
instance AdaptList (Pair Double Word64)
instance AdaptList (Pair Double Word32)
instance AdaptList (Pair Double Word16)
instance AdaptList (Pair Double Word8)
instance AdaptList (Pair Double Word)
instance AdaptList (Pair Double Int64)
instance AdaptList (Pair Double Int32)
instance AdaptList (Pair Double Int16)
instance AdaptList (Pair Double Int8)
instance AdaptList (Pair Double Integer)
instance AdaptList (Pair Double Int)
instance AdaptList (Pair Word64 Char)
instance AdaptList (Pair Word64 Float)
instance AdaptList (Pair Word64 Double)
instance AdaptList (Pair Word64 Word64)
instance AdaptList (Pair Word64 Word32)
instance AdaptList (Pair Word64 Word16)
instance AdaptList (Pair Word64 Word8)
instance AdaptList (Pair Word64 Word)
instance AdaptList (Pair Word64 Int64)
instance AdaptList (Pair Word64 Int32)
instance AdaptList (Pair Word64 Int16)
instance AdaptList (Pair Word64 Int8)
instance AdaptList (Pair Word64 Integer)
instance AdaptList (Pair Word64 Int)
instance AdaptList (Pair Word32 Char)
instance AdaptList (Pair Word32 Float)
instance AdaptList (Pair Word32 Double)
instance AdaptList (Pair Word32 Word64)
instance AdaptList (Pair Word32 Word32)
instance AdaptList (Pair Word32 Word16)
instance AdaptList (Pair Word32 Word8)
instance AdaptList (Pair Word32 Word)
instance AdaptList (Pair Word32 Int64)
instance AdaptList (Pair Word32 Int32)
instance AdaptList (Pair Word32 Int16)
instance AdaptList (Pair Word32 Int8)
instance AdaptList (Pair Word32 Integer)
instance AdaptList (Pair Word32 Int)
instance AdaptList (Pair Word16 Char)
instance AdaptList (Pair Word16 Float)
instance AdaptList (Pair Word16 Double)
instance AdaptList (Pair Word16 Word64)
instance AdaptList (Pair Word16 Word32)
instance AdaptList (Pair Word16 Word16)
instance AdaptList (Pair Word16 Word8)
instance AdaptList (Pair Word16 Word)
instance AdaptList (Pair Word16 Int64)
instance AdaptList (Pair Word16 Int32)
instance AdaptList (Pair Word16 Int16)
instance AdaptList (Pair Word16 Int8)
instance AdaptList (Pair Word16 Integer)
instance AdaptList (Pair Word16 Int)
instance AdaptList (Pair Word8 Char)
instance AdaptList (Pair Word8 Float)
instance AdaptList (Pair Word8 Double)
instance AdaptList (Pair Word8 Word64)
instance AdaptList (Pair Word8 Word32)
instance AdaptList (Pair Word8 Word16)
instance AdaptList (Pair Word8 Word8)
instance AdaptList (Pair Word8 Word)
instance AdaptList (Pair Word8 Int64)
instance AdaptList (Pair Word8 Int32)
instance AdaptList (Pair Word8 Int16)
instance AdaptList (Pair Word8 Int8)
instance AdaptList (Pair Word8 Integer)
instance AdaptList (Pair Word8 Int)
instance AdaptList (Pair Word Char)
instance AdaptList (Pair Word Float)
instance AdaptList (Pair Word Double)
instance AdaptList (Pair Word Word64)
instance AdaptList (Pair Word Word32)
instance AdaptList (Pair Word Word16)
instance AdaptList (Pair Word Word8)
instance AdaptList (Pair Word Word)
instance AdaptList (Pair Word Int64)
instance AdaptList (Pair Word Int32)
instance AdaptList (Pair Word Int16)
instance AdaptList (Pair Word Int8)
instance AdaptList (Pair Word Integer)
instance AdaptList (Pair Word Int)
instance AdaptList (Pair Int64 Char)
instance AdaptList (Pair Int64 Float)
instance AdaptList (Pair Int64 Double)
instance AdaptList (Pair Int64 Word64)
instance AdaptList (Pair Int64 Word32)
instance AdaptList (Pair Int64 Word16)
instance AdaptList (Pair Int64 Word8)
instance AdaptList (Pair Int64 Word)
instance AdaptList (Pair Int64 Int64)
instance AdaptList (Pair Int64 Int32)
instance AdaptList (Pair Int64 Int16)
instance AdaptList (Pair Int64 Int8)
instance AdaptList (Pair Int64 Integer)
instance AdaptList (Pair Int64 Int)
instance AdaptList (Pair Int32 Char)
instance AdaptList (Pair Int32 Float)
instance AdaptList (Pair Int32 Double)
instance AdaptList (Pair Int32 Word64)
instance AdaptList (Pair Int32 Word32)
instance AdaptList (Pair Int32 Word16)
instance AdaptList (Pair Int32 Word8)
instance AdaptList (Pair Int32 Word)
instance AdaptList (Pair Int32 Int64)
instance AdaptList (Pair Int32 Int32)
instance AdaptList (Pair Int32 Int16)
instance AdaptList (Pair Int32 Int8)
instance AdaptList (Pair Int32 Integer)
instance AdaptList (Pair Int32 Int)
instance AdaptList (Pair Int16 Char)
instance AdaptList (Pair Int16 Float)
instance AdaptList (Pair Int16 Double)
instance AdaptList (Pair Int16 Word64)
instance AdaptList (Pair Int16 Word32)
instance AdaptList (Pair Int16 Word16)
instance AdaptList (Pair Int16 Word8)
instance AdaptList (Pair Int16 Word)
instance AdaptList (Pair Int16 Int64)
instance AdaptList (Pair Int16 Int32)
instance AdaptList (Pair Int16 Int16)
instance AdaptList (Pair Int16 Int8)
instance AdaptList (Pair Int16 Integer)
instance AdaptList (Pair Int16 Int)
instance AdaptList (Pair Int8 Char)
instance AdaptList (Pair Int8 Float)
instance AdaptList (Pair Int8 Double)
instance AdaptList (Pair Int8 Word64)
instance AdaptList (Pair Int8 Word32)
instance AdaptList (Pair Int8 Word16)
instance AdaptList (Pair Int8 Word8)
instance AdaptList (Pair Int8 Word)
instance AdaptList (Pair Int8 Int64)
instance AdaptList (Pair Int8 Int32)
instance AdaptList (Pair Int8 Int16)
instance AdaptList (Pair Int8 Int8)
instance AdaptList (Pair Int8 Integer)
instance AdaptList (Pair Int8 Int)
instance AdaptList (Pair Integer Char)
instance AdaptList (Pair Integer Float)
instance AdaptList (Pair Integer Double)
instance AdaptList (Pair Integer Word64)
instance AdaptList (Pair Integer Word32)
instance AdaptList (Pair Integer Word16)
instance AdaptList (Pair Integer Word8)
instance AdaptList (Pair Integer Word)
instance AdaptList (Pair Integer Int64)
instance AdaptList (Pair Integer Int32)
instance AdaptList (Pair Integer Int16)
instance AdaptList (Pair Integer Int8)
instance AdaptList (Pair Integer Integer)
instance AdaptList (Pair Integer Int)
instance AdaptList (Pair Int Char)
instance AdaptList (Pair Int Float)
instance AdaptList (Pair Int Double)
instance AdaptList (Pair Int Word64)
instance AdaptList (Pair Int Word32)
instance AdaptList (Pair Int Word16)
instance AdaptList (Pair Int Word8)
instance AdaptList (Pair Int Word)
instance AdaptList (Pair Int Int64)
instance AdaptList (Pair Int Int32)
instance AdaptList (Pair Int Int16)
instance AdaptList (Pair Int Int8)
instance AdaptList (Pair Int Integer)
instance AdaptList (Pair Int Int)
instance AdaptList Char
instance AdaptList Float
instance AdaptList Double
instance AdaptList Word64
instance AdaptList Word32
instance AdaptList Word16
instance AdaptList Word8
instance AdaptList Word
instance AdaptList Int64
instance AdaptList Int32
instance AdaptList Int16
instance AdaptList Int8
instance AdaptList Integer
instance AdaptList Int
instance AdaptList Bool
instance IsString (List Char)
instance (AdaptList a, Show a) => Show (List a)
instance (AdaptList a, Ord a) => Ord (List a)
instance (AdaptList a, Eq a) => Eq (List a)
