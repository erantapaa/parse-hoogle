-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Type-safe EDSL for SQL queries on persistent backends.
--   
@package esqueleto
@version 2.2.10


-- | This is an internal module, anything exported by this module may
--   change without a major version bump. Please use only
--   <a>Database.Esqueleto</a> if possible.
module Database.Esqueleto.Internal.Language

-- | Finally tagless representation of <tt>esqueleto</tt>'s EDSL.
class (Functor query, Applicative query, Monad query) => Esqueleto query expr backend | query -> expr backend, expr -> query backend
fromStart :: (Esqueleto query expr backend, PersistEntity a, PersistEntityBackend a ~ backend) => query (expr (PreprocessedFrom (expr (Entity a))))
fromStartMaybe :: (Esqueleto query expr backend, PersistEntity a, PersistEntityBackend a ~ backend) => query (expr (PreprocessedFrom (expr (Maybe (Entity a)))))
fromJoin :: (Esqueleto query expr backend, IsJoinKind join) => expr (PreprocessedFrom a) -> expr (PreprocessedFrom b) -> query (expr (PreprocessedFrom (join a b)))
fromFinish :: Esqueleto query expr backend => expr (PreprocessedFrom a) -> query a
where_ :: Esqueleto query expr backend => expr (Value Bool) -> query ()
on :: Esqueleto query expr backend => expr (Value Bool) -> query ()
groupBy :: (Esqueleto query expr backend, ToSomeValues expr a) => a -> query ()
orderBy :: Esqueleto query expr backend => [expr OrderBy] -> query ()
asc :: (Esqueleto query expr backend, PersistField a) => expr (Value a) -> expr OrderBy
desc :: (Esqueleto query expr backend, PersistField a) => expr (Value a) -> expr OrderBy
limit :: Esqueleto query expr backend => Int64 -> query ()
offset :: Esqueleto query expr backend => Int64 -> query ()
distinct :: Esqueleto query expr backend => query a -> query a
distinctOn :: Esqueleto query expr backend => [expr DistinctOn] -> query a -> query a
don :: Esqueleto query expr backend => expr (Value a) -> expr DistinctOn
distinctOnOrderBy :: Esqueleto query expr backend => [expr OrderBy] -> query a -> query a
rand :: Esqueleto query expr backend => expr OrderBy
having :: Esqueleto query expr backend => expr (Value Bool) -> query ()
locking :: Esqueleto query expr backend => LockingKind -> query ()
sub_select :: (Esqueleto query expr backend, PersistField a) => query (expr (Value a)) -> expr (Value a)
sub_selectDistinct :: (Esqueleto query expr backend, PersistField a) => query (expr (Value a)) -> expr (Value a)
(^.) :: (Esqueleto query expr backend, PersistEntity val, PersistField typ) => expr (Entity val) -> EntityField val typ -> expr (Value typ)
(?.) :: (Esqueleto query expr backend, PersistEntity val, PersistField typ) => expr (Maybe (Entity val)) -> EntityField val typ -> expr (Value (Maybe typ))
val :: (Esqueleto query expr backend, PersistField typ) => typ -> expr (Value typ)
isNothing :: (Esqueleto query expr backend, PersistField typ) => expr (Value (Maybe typ)) -> expr (Value Bool)
just :: Esqueleto query expr backend => expr (Value typ) -> expr (Value (Maybe typ))
nothing :: Esqueleto query expr backend => expr (Value (Maybe typ))
joinV :: Esqueleto query expr backend => expr (Value (Maybe (Maybe typ))) -> expr (Value (Maybe typ))
countRows :: (Esqueleto query expr backend, Num a) => expr (Value a)
count :: (Esqueleto query expr backend, Num a) => expr (Value typ) -> expr (Value a)
not_ :: Esqueleto query expr backend => expr (Value Bool) -> expr (Value Bool)
(==.) :: (Esqueleto query expr backend, PersistField typ) => expr (Value typ) -> expr (Value typ) -> expr (Value Bool)
(>=.) :: (Esqueleto query expr backend, PersistField typ) => expr (Value typ) -> expr (Value typ) -> expr (Value Bool)
(>.) :: (Esqueleto query expr backend, PersistField typ) => expr (Value typ) -> expr (Value typ) -> expr (Value Bool)
(<=.) :: (Esqueleto query expr backend, PersistField typ) => expr (Value typ) -> expr (Value typ) -> expr (Value Bool)
(<.) :: (Esqueleto query expr backend, PersistField typ) => expr (Value typ) -> expr (Value typ) -> expr (Value Bool)
(!=.) :: (Esqueleto query expr backend, PersistField typ) => expr (Value typ) -> expr (Value typ) -> expr (Value Bool)
(&&.) :: Esqueleto query expr backend => expr (Value Bool) -> expr (Value Bool) -> expr (Value Bool)
(||.) :: Esqueleto query expr backend => expr (Value Bool) -> expr (Value Bool) -> expr (Value Bool)
(+.) :: (Esqueleto query expr backend, PersistField a) => expr (Value a) -> expr (Value a) -> expr (Value a)
(-.) :: (Esqueleto query expr backend, PersistField a) => expr (Value a) -> expr (Value a) -> expr (Value a)
(/.) :: (Esqueleto query expr backend, PersistField a) => expr (Value a) -> expr (Value a) -> expr (Value a)
(*.) :: (Esqueleto query expr backend, PersistField a) => expr (Value a) -> expr (Value a) -> expr (Value a)
random_ :: (Esqueleto query expr backend, PersistField a, Num a) => expr (Value a)
round_ :: (Esqueleto query expr backend, PersistField a, Num a, PersistField b, Num b) => expr (Value a) -> expr (Value b)
ceiling_ :: (Esqueleto query expr backend, PersistField a, Num a, PersistField b, Num b) => expr (Value a) -> expr (Value b)
floor_ :: (Esqueleto query expr backend, PersistField a, Num a, PersistField b, Num b) => expr (Value a) -> expr (Value b)
sum_ :: (Esqueleto query expr backend, PersistField a, PersistField b) => expr (Value a) -> expr (Value (Maybe b))
min_ :: (Esqueleto query expr backend, PersistField a) => expr (Value a) -> expr (Value (Maybe a))
max_ :: (Esqueleto query expr backend, PersistField a) => expr (Value a) -> expr (Value (Maybe a))
avg_ :: (Esqueleto query expr backend, PersistField a, PersistField b) => expr (Value a) -> expr (Value (Maybe b))
castNum :: (Esqueleto query expr backend, Num a, Num b) => expr (Value a) -> expr (Value b)
castNumM :: (Esqueleto query expr backend, Num a, Num b) => expr (Value (Maybe a)) -> expr (Value (Maybe b))
coalesce :: (Esqueleto query expr backend, PersistField a) => [expr (Value (Maybe a))] -> expr (Value (Maybe a))
coalesceDefault :: (Esqueleto query expr backend, PersistField a) => [expr (Value (Maybe a))] -> expr (Value a) -> expr (Value a)
lower_ :: (Esqueleto query expr backend, PersistField a, IsString a) => expr (Value a) -> expr (Value a)
like :: (Esqueleto query expr backend, PersistField s, IsString s) => expr (Value s) -> expr (Value s) -> expr (Value Bool)
ilike :: (Esqueleto query expr backend, PersistField s, IsString s) => expr (Value s) -> expr (Value s) -> expr (Value Bool)
(%) :: (Esqueleto query expr backend, PersistField s, IsString s) => expr (Value s)
concat_ :: (Esqueleto query expr backend, PersistField s, IsString s) => [expr (Value s)] -> expr (Value s)
(++.) :: (Esqueleto query expr backend, PersistField s, IsString s) => expr (Value s) -> expr (Value s) -> expr (Value s)
subList_select :: (Esqueleto query expr backend, PersistField a) => query (expr (Value a)) -> expr (ValueList a)
subList_selectDistinct :: (Esqueleto query expr backend, PersistField a) => query (expr (Value a)) -> expr (ValueList a)
valList :: (Esqueleto query expr backend, PersistField typ) => [typ] -> expr (ValueList typ)
in_ :: (Esqueleto query expr backend, PersistField typ) => expr (Value typ) -> expr (ValueList typ) -> expr (Value Bool)
notIn :: (Esqueleto query expr backend, PersistField typ) => expr (Value typ) -> expr (ValueList typ) -> expr (Value Bool)
exists :: Esqueleto query expr backend => query () -> expr (Value Bool)
notExists :: Esqueleto query expr backend => query () -> expr (Value Bool)
set :: (Esqueleto query expr backend, PersistEntity val) => expr (Entity val) -> [expr (Update val)] -> query ()
(=.) :: (Esqueleto query expr backend, PersistEntity val, PersistField typ) => EntityField val typ -> expr (Value typ) -> expr (Update val)
(+=.) :: (Esqueleto query expr backend, PersistEntity val, PersistField a) => EntityField val a -> expr (Value a) -> expr (Update val)
(-=.) :: (Esqueleto query expr backend, PersistEntity val, PersistField a) => EntityField val a -> expr (Value a) -> expr (Update val)
(*=.) :: (Esqueleto query expr backend, PersistEntity val, PersistField a) => EntityField val a -> expr (Value a) -> expr (Update val)
(/=.) :: (Esqueleto query expr backend, PersistEntity val, PersistField a) => EntityField val a -> expr (Value a) -> expr (Update val)
(<#) :: Esqueleto query expr backend => (a -> b) -> expr (Value a) -> expr (Insertion b)
(<&>) :: Esqueleto query expr backend => expr (Insertion (a -> b)) -> expr (Value a) -> expr (Insertion b)
case_ :: (Esqueleto query expr backend, PersistField a) => [(expr (Value Bool), expr (Value a))] -> expr (Value a) -> expr (Value a)

-- | <tt>FROM</tt> clause: bring entities into scope.
--   
--   This function internally uses two type classes in order to provide
--   some flexibility of how you may call it. Internally we refer to these
--   type classes as the two different magics.
--   
--   The innermost magic allows you to use <tt>from</tt> with the following
--   types:
--   
--   <ul>
--   <li><tt>expr (Entity val)</tt>, which brings a single entity into
--   scope.</li>
--   <li><tt>expr (Maybe (Entity val))</tt>, which brings a single entity
--   that may be <tt>NULL</tt> into scope. Used for <tt>OUTER
--   JOIN</tt>s.</li>
--   <li>A <tt>JOIN</tt> of any other two types allowed by the innermost
--   magic, where a <tt>JOIN</tt> may be an <a>InnerJoin</a>, a
--   <a>CrossJoin</a>, a <a>LeftOuterJoin</a>, a <a>RightOuterJoin</a>, or
--   a <a>FullOuterJoin</a>. The <tt>JOINs</tt> have left fixity.</li>
--   </ul>
--   
--   The outermost magic allows you to use <tt>from</tt> on any tuples of
--   types supported by innermost magic (and also tuples of tuples, and so
--   on), up to 8-tuples.
--   
--   Note that using <tt>from</tt> for the same entity twice does work and
--   corresponds to a self-join. You don't even need to use two different
--   calls to <tt>from</tt>, you may use a <tt>JOIN</tt> or a tuple.
--   
--   The following are valid examples of uses of <tt>from</tt> (the types
--   of the arguments of the lambda are inside square brackets):
--   
--   <pre>
--   <a>from</a> $ \person -&gt; ...
--   <a>from</a> $ \(person, blogPost) -&gt; ...
--   <a>from</a> $ \(p `'LeftOuterJoin`` mb) -&gt; ...
--   <a>from</a> $ \(p1 `'InnerJoin`` f `'InnerJoin`` p2) -&gt; ...
--   <a>from</a> $ \((p1 `'InnerJoin`` f) `'InnerJoin`` p2) -&gt; ...
--   </pre>
--   
--   The types of the arguments to the lambdas above are, respectively:
--   
--   <pre>
--   person
--     :: ( Esqueleto query expr backend
--        , PersistEntity Person
--        , PersistEntityBackend Person ~ backend
--        ) =&gt; expr (Entity Person)
--   (person, blogPost)
--     :: (...) =&gt; (expr (Entity Person), expr (Entity BlogPost))
--   (p `'LeftOuterJoin`` mb)
--     :: (...) =&gt; InnerJoin (expr (Entity Person)) (expr (Maybe (Entity BlogPost)))
--   (p1 `'InnerJoin`` f `'InnerJoin`` p2)
--     :: (...) =&gt; InnerJoin
--                   (InnerJoin (expr (Entity Person))
--                              (expr (Entity Follow)))
--                   (expr (Entity Person))
--   (p1 `'InnerJoin`` (f `'InnerJoin`` p2)) ::
--     :: (...) =&gt; InnerJoin
--                   (expr (Entity Person))
--                   (InnerJoin (expr (Entity Follow))
--                              (expr (Entity Person)))
--   </pre>
--   
--   Note that some backends may not support all kinds of <tt>JOIN</tt>s.
from :: From query expr backend a => (a -> query b) -> query b

-- | A single value (as opposed to a whole entity). You may use
--   <tt>(<a>^.</a>)</tt> or <tt>(<a>?.</a>)</tt> to get a <a>Value</a>
--   from an <a>Entity</a>.
data Value a
Value :: a -> Value a

-- | Unwrap a <a>Value</a>.
--   
--   <i>Since: 1.4.1</i>
unValue :: Value a -> a

-- | A list of single values. There's a limited set of functions able to
--   work with this data type (such as <a>subList_select</a>,
--   <a>valList</a>, <a>in_</a> and <a>exists</a>).
data ValueList a
ValueList :: a -> ValueList a

-- | A wrapper type for for any <tt>expr (Value a)</tt> for all a.
data SomeValue expr
SomeValue :: expr (Value a) -> SomeValue expr

-- | A class of things that can be converted into a list of SomeValue. It
--   has instances for tuples and is the reason why <a>groupBy</a> can take
--   tuples, like <tt><a>groupBy</a> (foo <a>^.</a> FooId, foo <a>^.</a>
--   FooName, foo <a>^.</a> FooType)</tt>.
class ToSomeValues expr a
toSomeValues :: ToSomeValues expr a => a -> [SomeValue expr]

-- | Data type that represents an <tt>INNER JOIN</tt> (see
--   <a>LeftOuterJoin</a> for an example).
data InnerJoin a b
InnerJoin :: a -> b -> InnerJoin a b

-- | Data type that represents a <tt>CROSS JOIN</tt> (see
--   <a>LeftOuterJoin</a> for an example).
data CrossJoin a b
CrossJoin :: a -> b -> CrossJoin a b

-- | Data type that represents a <tt>LEFT OUTER JOIN</tt>. For example,
--   
--   <pre>
--   select $
--   <a>from</a> $ \(person `'LeftOuterJoin`` pet) -&gt;
--     ...
--   </pre>
--   
--   is translated into
--   
--   <pre>
--   SELECT ...
--   FROM Person LEFT OUTER JOIN Pet
--   ...
--   </pre>
--   
--   See also: <a>from</a>.
data LeftOuterJoin a b
LeftOuterJoin :: a -> b -> LeftOuterJoin a b

-- | Data type that represents a <tt>RIGHT OUTER JOIN</tt> (see
--   <a>LeftOuterJoin</a> for an example).
data RightOuterJoin a b
RightOuterJoin :: a -> b -> RightOuterJoin a b

-- | Data type that represents a <tt>FULL OUTER JOIN</tt> (see
--   <a>LeftOuterJoin</a> for an example).
data FullOuterJoin a b
FullOuterJoin :: a -> b -> FullOuterJoin a b

-- | Exception thrown whenever <a>on</a> is used to create an <tt>ON</tt>
--   clause but no matching <tt>JOIN</tt> is found.
data OnClauseWithoutMatchingJoinException
OnClauseWithoutMatchingJoinException :: String -> OnClauseWithoutMatchingJoinException

-- | Phantom type used by <a>orderBy</a>, <a>asc</a> and <a>desc</a>.
data OrderBy

-- | Phantom type used by <a>distinctOn</a> and <a>don</a>.
data DistinctOn

-- | Phantom type for a <tt>SET</tt> operation on an entity of the given
--   type (see <a>set</a> and '(=.)').
data Update typ

-- | Phantom type used by <tt>insertSelect</tt>.
data Insertion a

-- | Different kinds of locking clauses supported by <a>locking</a>.
--   
--   Note that each RDBMS has different locking support. The constructors
--   of this datatype specify only the <i>syntax</i> of the locking
--   mechanism, not its <i>semantics</i>. For example, even though both
--   MySQL and PostgreSQL support <a>ForUpdate</a>, there are no guarantees
--   that they will behave the same.
--   
--   <i>Since: 2.2.7</i>
data LockingKind

-- | <tt>FOR UPDATE</tt> syntax. Supported by MySQL, Oracle and PostgreSQL.
--   
--   <i>Since: 2.2.7</i>
ForUpdate :: LockingKind

-- | <tt>FOR SHARE</tt> syntax. Supported by PostgreSQL.
--   
--   <i>Since: 2.2.7</i>
ForShare :: LockingKind

-- | <tt>LOCK IN SHARE MODE</tt> syntax. Supported by MySQL.
--   
--   <i>Since: 2.2.7</i>
LockInShareMode :: LockingKind

-- | (Internal) A kind of <tt>JOIN</tt>.
data JoinKind

-- | <pre>
--   INNER JOIN
--   </pre>
InnerJoinKind :: JoinKind

-- | <pre>
--   CROSS JOIN
--   </pre>
CrossJoinKind :: JoinKind

-- | <pre>
--   LEFT OUTER JOIN
--   </pre>
LeftOuterJoinKind :: JoinKind

-- | <pre>
--   RIGHT OUTER JOIN
--   </pre>
RightOuterJoinKind :: JoinKind

-- | <pre>
--   FULL OUTER JOIN
--   </pre>
FullOuterJoinKind :: JoinKind

-- | (Internal) Functions that operate on types (that should be) of kind
--   <a>JoinKind</a>.
class IsJoinKind join
smartJoin :: IsJoinKind join => a -> b -> join a b
reifyJoinKind :: IsJoinKind join => join a b -> JoinKind

-- | (Internal) Phantom type used to process <a>from</a> (see
--   <a>fromStart</a>).
data PreprocessedFrom a

-- | (Internal) Class that implements the tuple <a>from</a> magic (see
--   <a>fromStart</a>).
class Esqueleto query expr backend => From query expr backend a

-- | (Internal) Class that implements the <tt>JOIN</tt> <a>from</a> magic
--   (see <a>fromStart</a>).
class Esqueleto query expr backend => FromPreprocess query expr backend a

-- | Syntax sugar for <a>case_</a>.
--   
--   <i>Since: 2.1.2</i>
when_ :: expr (Value Bool) -> () -> expr a -> (expr (Value Bool), expr a)

-- | Syntax sugar for <a>case_</a>.
--   
--   <i>Since: 2.1.2</i>
then_ :: ()

-- | Syntax sugar for <a>case_</a>.
--   
--   <i>Since: 2.1.2</i>
else_ :: expr a -> expr a
instance Typeable Value
instance Typeable ValueList
instance Typeable OnClauseWithoutMatchingJoinException
instance Eq a => Eq (Value a)
instance Ord a => Ord (Value a)
instance Show a => Show (Value a)
instance Eq a => Eq (ValueList a)
instance Ord a => Ord (ValueList a)
instance Show a => Show (ValueList a)
instance Eq JoinKind
instance Eq OnClauseWithoutMatchingJoinException
instance Ord OnClauseWithoutMatchingJoinException
instance Show OnClauseWithoutMatchingJoinException
instance (Esqueleto query expr backend, FromPreprocess query expr backend a, FromPreprocess query expr backend b, IsJoinKind join) => FromPreprocess query expr backend (join a b)
instance (Esqueleto query expr backend, PersistEntity val, PersistEntityBackend val ~ backend) => FromPreprocess query expr backend (expr (Maybe (Entity val)))
instance (Esqueleto query expr backend, PersistEntity val, PersistEntityBackend val ~ backend) => FromPreprocess query expr backend (expr (Entity val))
instance (From query expr backend a, From query expr backend b, From query expr backend c, From query expr backend d, From query expr backend e, From query expr backend f, From query expr backend g, From query expr backend h) => From query expr backend (a, b, c, d, e, f, g, h)
instance (From query expr backend a, From query expr backend b, From query expr backend c, From query expr backend d, From query expr backend e, From query expr backend f, From query expr backend g) => From query expr backend (a, b, c, d, e, f, g)
instance (From query expr backend a, From query expr backend b, From query expr backend c, From query expr backend d, From query expr backend e, From query expr backend f) => From query expr backend (a, b, c, d, e, f)
instance (From query expr backend a, From query expr backend b, From query expr backend c, From query expr backend d, From query expr backend e) => From query expr backend (a, b, c, d, e)
instance (From query expr backend a, From query expr backend b, From query expr backend c, From query expr backend d) => From query expr backend (a, b, c, d)
instance (From query expr backend a, From query expr backend b, From query expr backend c) => From query expr backend (a, b, c)
instance (From query expr backend a, From query expr backend b) => From query expr backend (a, b)
instance (Esqueleto query expr backend, FromPreprocess query expr backend (FullOuterJoin a b)) => From query expr backend (FullOuterJoin a b)
instance (Esqueleto query expr backend, FromPreprocess query expr backend (RightOuterJoin a b)) => From query expr backend (RightOuterJoin a b)
instance (Esqueleto query expr backend, FromPreprocess query expr backend (LeftOuterJoin a b)) => From query expr backend (LeftOuterJoin a b)
instance (Esqueleto query expr backend, FromPreprocess query expr backend (CrossJoin a b)) => From query expr backend (CrossJoin a b)
instance (Esqueleto query expr backend, FromPreprocess query expr backend (InnerJoin a b)) => From query expr backend (InnerJoin a b)
instance (Esqueleto query expr backend, FromPreprocess query expr backend (expr (Maybe (Entity val)))) => From query expr backend (expr (Maybe (Entity val)))
instance (Esqueleto query expr backend, FromPreprocess query expr backend (expr (Entity val))) => From query expr backend (expr (Entity val))
instance Exception OnClauseWithoutMatchingJoinException
instance IsJoinKind FullOuterJoin
instance IsJoinKind RightOuterJoin
instance IsJoinKind LeftOuterJoin
instance IsJoinKind CrossJoin
instance IsJoinKind InnerJoin
instance (ToSomeValues expr a, ToSomeValues expr b, ToSomeValues expr c, ToSomeValues expr d, ToSomeValues expr e, ToSomeValues expr f, ToSomeValues expr g, ToSomeValues expr h) => ToSomeValues expr (a, b, c, d, e, f, g, h)
instance (ToSomeValues expr a, ToSomeValues expr b, ToSomeValues expr c, ToSomeValues expr d, ToSomeValues expr e, ToSomeValues expr f, ToSomeValues expr g) => ToSomeValues expr (a, b, c, d, e, f, g)
instance (ToSomeValues expr a, ToSomeValues expr b, ToSomeValues expr c, ToSomeValues expr d, ToSomeValues expr e, ToSomeValues expr f) => ToSomeValues expr (a, b, c, d, e, f)
instance (ToSomeValues expr a, ToSomeValues expr b, ToSomeValues expr c, ToSomeValues expr d, ToSomeValues expr e) => ToSomeValues expr (a, b, c, d, e)
instance (ToSomeValues expr a, ToSomeValues expr b, ToSomeValues expr c, ToSomeValues expr d) => ToSomeValues expr (a, b, c, d)
instance (ToSomeValues expr a, ToSomeValues expr b, ToSomeValues expr c) => ToSomeValues expr (a, b, c)
instance (ToSomeValues expr a, ToSomeValues expr b) => ToSomeValues expr (a, b)
instance Functor Value


-- | This is an internal module, anything exported by this module may
--   change without a major version bump. Please use only
--   <a>Database.Esqueleto</a> if possible.
module Database.Esqueleto.Internal.Sql

-- | SQL backend for <tt>esqueleto</tt> using <a>SqlPersistT</a>.
data SqlQuery a

-- | An expression on the SQL backend.
--   
--   There are many comments describing the constructors of this data type.
--   However, Haddock doesn't like GADTs, so you'll have to read them by
--   hitting "Source".
data SqlExpr a

-- | Constraint synonym for <tt>persistent</tt> entities whose backend is
--   <a>SqlPersistT</a>.
type SqlEntity ent = (PersistEntity ent, PersistEntityBackend ent ~ SqlBackend)

-- | Execute an <tt>esqueleto</tt> <tt>SELECT</tt> query inside
--   <tt>persistent</tt>'s <a>SqlPersistT</a> monad and return a list of
--   rows.
--   
--   We've seen that <a>from</a> has some magic about which kinds of things
--   you may bring into scope. This <a>select</a> function also has some
--   magic for which kinds of things you may bring back to Haskell-land by
--   using <tt>SqlQuery</tt>'s <tt>return</tt>:
--   
--   <ul>
--   <li>You may return a <tt>SqlExpr (<a>Entity</a> v)</tt> for an entity
--   <tt>v</tt> (i.e., like the <tt>*</tt> in SQL), which is then returned
--   to Haskell-land as just <tt>Entity v</tt>.</li>
--   <li>You may return a <tt>SqlExpr (Maybe (Entity v))</tt> for an entity
--   <tt>v</tt> that may be <tt>NULL</tt>, which is then returned to
--   Haskell-land as <tt>Maybe (Entity v)</tt>. Used for <tt>OUTER
--   JOIN</tt>s.</li>
--   <li>You may return a <tt>SqlExpr (<a>Value</a> t)</tt> for a value
--   <tt>t</tt> (i.e., a single column), where <tt>t</tt> is any instance
--   of <a>PersistField</a>, which is then returned to Haskell-land as
--   <tt>Value t</tt>. You may use <tt>Value</tt> to return projections of
--   an <tt>Entity</tt> (see <tt>(<a>^.</a>)</tt> and <tt>(<a>?.</a>)</tt>)
--   or to return any other value calculated on the query (e.g.,
--   <a>countRows</a> or <a>sub_select</a>).</li>
--   </ul>
--   
--   The <tt>SqlSelect a r</tt> class has functional dependencies that
--   allow type information to flow both from <tt>a</tt> to <tt>r</tt> and
--   vice-versa. This means that you'll almost never have to give any type
--   signatures for <tt>esqueleto</tt> queries. For example, the query
--   <tt><a>select</a> $ from $ \p -&gt; return p</tt> alone is ambiguous,
--   but in the context of
--   
--   <pre>
--   do ps &lt;- <a>select</a> $
--            <a>from</a> $ \p -&gt;
--            return p
--      liftIO $ mapM_ (putStrLn . personName . entityVal) ps
--   </pre>
--   
--   we are able to infer from that single <tt>personName . entityVal</tt>
--   function composition that the <tt>p</tt> inside the query is of type
--   <tt>SqlExpr (Entity Person)</tt>.
select :: (SqlSelect a r, MonadIO m) => SqlQuery a -> SqlPersistT m [r]

-- | Execute an <tt>esqueleto</tt> <tt>SELECT</tt> query inside
--   <tt>persistent</tt>'s <a>SqlPersistT</a> monad and return a
--   <a>Source</a> of rows.
selectSource :: (SqlSelect a r, MonadResource m) => SqlQuery a -> Source (SqlPersistT m) r

-- | Execute an <tt>esqueleto</tt> <tt>SELECT DISTINCT</tt> query inside
--   <tt>persistent</tt>'s <a>SqlPersistT</a> monad and return a list of
--   rows.

-- | <i>Deprecated: Since 2.2.4: use <a>select</a> and <a>distinct</a>.</i>
selectDistinct :: (SqlSelect a r, MonadIO m) => SqlQuery a -> SqlPersistT m [r]

-- | Execute an <tt>esqueleto</tt> <tt>SELECT DISTINCT</tt> query inside
--   <tt>persistent</tt>'s <a>SqlPersistT</a> monad and return a
--   <a>Source</a> of rows.

-- | <i>Deprecated: Since 2.2.4: use <a>selectSource</a> and
--   <a>distinct</a>.</i>
selectDistinctSource :: (SqlSelect a r, MonadResource m) => SqlQuery a -> Source (SqlPersistT m) r

-- | Execute an <tt>esqueleto</tt> <tt>DELETE</tt> query inside
--   <tt>persistent</tt>'s <a>SqlPersistT</a> monad. Note that currently
--   there are no type checks for statements that should not appear on a
--   <tt>DELETE</tt> query.
--   
--   Example of usage:
--   
--   <pre>
--   <a>delete</a> $
--   <a>from</a> $ \appointment -&gt;
--   <a>where_</a> (appointment <a>^.</a> AppointmentDate <a>&lt;.</a> <a>val</a> now)
--   </pre>
--   
--   Unlike <a>select</a>, there is a useful way of using <a>delete</a>
--   that will lead to type ambiguities. If you want to delete all rows
--   (i.e., no <a>where_</a> clause), you'll have to use a type signature:
--   
--   <pre>
--   <a>delete</a> $
--   <a>from</a> $ \(appointment :: <a>SqlExpr</a> (<a>Entity</a> Appointment)) -&gt;
--   return ()
--   </pre>
delete :: MonadIO m => SqlQuery () -> SqlPersistT m ()

-- | Same as <a>delete</a>, but returns the number of rows affected.
deleteCount :: MonadIO m => SqlQuery () -> SqlPersistT m Int64

-- | Execute an <tt>esqueleto</tt> <tt>UPDATE</tt> query inside
--   <tt>persistent</tt>'s <a>SqlPersistT</a> monad. Note that currently
--   there are no type checks for statements that should not appear on a
--   <tt>UPDATE</tt> query.
--   
--   Example of usage:
--   
--   <pre>
--   <a>update</a> $ p -&gt; do
--   <a>set</a> p [ PersonAge <a>=.</a> <a>just</a> (<a>val</a> thisYear) -. p <a>^.</a> PersonBorn ]
--   <a>where_</a> $ isNothing (p <a>^.</a> PersonAge)
--   </pre>
update :: (MonadIO m, SqlEntity val) => (SqlExpr (Entity val) -> SqlQuery ()) -> SqlPersistT m ()

-- | Same as <a>update</a>, but returns the number of rows affected.
updateCount :: (MonadIO m, SqlEntity val) => (SqlExpr (Entity val) -> SqlQuery ()) -> SqlPersistT m Int64

-- | Insert a <a>PersistField</a> for every unique selected value.

-- | <i>Deprecated: Since 2.2.4: use <a>insertSelect</a> and
--   <a>distinct</a>.</i>
insertSelectDistinct :: (MonadIO m, PersistEntity a) => SqlQuery (SqlExpr (Insertion a)) -> SqlPersistT m ()

-- | Insert a <a>PersistField</a> for every selected value.
insertSelect :: (MonadIO m, PersistEntity a) => SqlQuery (SqlExpr (Insertion a)) -> SqlPersistT m ()

-- | (Internal) Create a case statement.
--   
--   Since: 2.1.1
unsafeSqlCase :: PersistField a => [(SqlExpr (Value Bool), SqlExpr (Value a))] -> SqlExpr (Value a) -> SqlExpr (Value a)

-- | (Internal) Create a custom binary operator. You <i>should</i>
--   <i>not</i> use this function directly since its type is very general,
--   you should always use it with an explicit type signature. For example:
--   
--   <pre>
--   (==.) :: SqlExpr (Value a) -&gt; SqlExpr (Value a) -&gt; SqlExpr (Value Bool)
--   (==.) = unsafeSqlBinOp " = "
--   </pre>
--   
--   In the example above, we constraint the arguments to be of the same
--   type and constraint the result to be a boolean value.
unsafeSqlBinOp :: Builder -> SqlExpr (Value a) -> SqlExpr (Value b) -> SqlExpr (Value c)

-- | Similar to <a>unsafeSqlBinOp</a>, but may also be applied to composite
--   keys. Uses the operator given as the second argument whenever applied
--   to composite keys.
--   
--   Usage example:
--   
--   <pre>
--   (==.) :: SqlExpr (Value a) -&gt; SqlExpr (Value a) -&gt; SqlExpr (Value Bool)
--   (==.) = unsafeSqlBinOpComposite " = " " AND "
--   </pre>
--   
--   Persistent has a hack for implementing composite keys (see
--   <a>ECompositeKey</a> doc for more details), so we're forced to use a
--   hack here as well. We deconstruct <a>ERaw</a> values based on two
--   rules:
--   
--   <ul>
--   <li>If it is a single placeholder, then it's assumed to be coming from
--   a <a>PersistList</a> and thus its components are separated so that
--   they may be applied to a composite key.</li>
--   <li>If it is not a single placeholder, then it's assumed to be a
--   foreign (composite or not) key, so we enforce that it has no
--   placeholders and split it on the commas.</li>
--   </ul>
unsafeSqlBinOpComposite :: Builder -> Builder -> SqlExpr (Value a) -> SqlExpr (Value b) -> SqlExpr (Value c)

-- | (Internal) A raw SQL value. The same warning from
--   <a>unsafeSqlBinOp</a> applies to this function as well.
unsafeSqlValue :: Builder -> SqlExpr (Value a)

-- | (Internal) A raw SQL function. Once again, the same warning from
--   <a>unsafeSqlBinOp</a> applies to this function as well.
unsafeSqlFunction :: UnsafeSqlFunctionArgument a => Builder -> a -> SqlExpr (Value b)

-- | (Internal) An unsafe SQL function to extract a subfield from a
--   compound field, e.g. datetime. See <a>unsafeSqlBinOp</a> for warnings.
--   
--   Since: 1.3.6.
unsafeSqlExtractSubField :: UnsafeSqlFunctionArgument a => Builder -> a -> SqlExpr (Value b)
class UnsafeSqlFunctionArgument a

-- | (Internal) Execute an <tt>esqueleto</tt> <tt>SELECT</tt>
--   <a>SqlQuery</a> inside <tt>persistent</tt>'s <a>SqlPersistT</a> monad.
rawSelectSource :: (SqlSelect a r, MonadIO m1, MonadIO m2) => Mode -> SqlQuery a -> SqlPersistT m1 (Acquire (Source m2 r))

-- | (Internal) Run a <a>Source</a> of rows.
runSource :: Monad m => Source (SqlPersistT m) r -> SqlPersistT m [r]

-- | (Internal) Execute an <tt>esqueleto</tt> statement inside
--   <tt>persistent</tt>'s <a>SqlPersistT</a> monad.
rawEsqueleto :: (MonadIO m, SqlSelect a r) => Mode -> SqlQuery a -> SqlPersistT m Int64

-- | (Internal) Pretty prints a <a>SqlQuery</a> into a SQL query.
--   
--   Note: if you're curious about the SQL query being generated by
--   <tt>esqueleto</tt>, instead of manually using this function (which is
--   possible but tedious), you may just turn on query logging of
--   <tt>persistent</tt>.
toRawSql :: SqlSelect a r => Mode -> IdentInfo -> SqlQuery a -> (Builder, [PersistValue])

-- | (Internal) Mode of query being converted by <a>toRawSql</a>.
data Mode
SELECT :: Mode
DELETE :: Mode
UPDATE :: Mode
INSERT_INTO :: Mode

-- | List of identifiers already in use and supply of temporary
--   identifiers.
data IdentState
initialIdentState :: IdentState

-- | Information needed to escape and use identifiers.
type IdentInfo = (SqlBackend, IdentState)

-- | (Internal) Class for mapping results coming from <a>SqlQuery</a> into
--   actual results.
--   
--   This looks very similar to <tt>RawSql</tt>, and it is! However, there
--   are some crucial differences and ultimately they're different classes.
class SqlSelect a r | a -> r, r -> a where sqlInsertInto = error "Type does not support sqlInsertInto."
sqlSelectCols :: SqlSelect a r => IdentInfo -> a -> (Builder, [PersistValue])
sqlSelectColCount :: SqlSelect a r => Proxy a -> Int
sqlSelectProcessRow :: SqlSelect a r => [PersistValue] -> Either Text r
sqlInsertInto :: SqlSelect a r => IdentInfo -> a -> (Builder, [PersistValue])

-- | (Internal) Coerce a value's type from 'SqlExpr (Value a)' to 'SqlExpr
--   (Value b)'. You should <i>not</i> use this function unless you know
--   what you're doing!
veryUnsafeCoerceSqlExprValue :: SqlExpr (Value a) -> SqlExpr (Value b)

-- | (Internal) Coerce a value's type from 'SqlExpr (ValueList a)' to
--   'SqlExpr (Value a)'. Does not work with empty lists.
veryUnsafeCoerceSqlExprValueList :: SqlExpr (ValueList a) -> SqlExpr (Value a)
instance (SqlSelect a ra, SqlSelect b rb, SqlSelect c rc, SqlSelect d rd, SqlSelect e re, SqlSelect f rf, SqlSelect g rg, SqlSelect h rh, SqlSelect i ri, SqlSelect j rj, SqlSelect k rk, SqlSelect l rl, SqlSelect m rm, SqlSelect n rn, SqlSelect o ro, SqlSelect p rp) => SqlSelect (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) (ra, rb, rc, rd, re, rf, rg, rh, ri, rj, rk, rl, rm, rn, ro, rp)
instance (SqlSelect a ra, SqlSelect b rb, SqlSelect c rc, SqlSelect d rd, SqlSelect e re, SqlSelect f rf, SqlSelect g rg, SqlSelect h rh, SqlSelect i ri, SqlSelect j rj, SqlSelect k rk, SqlSelect l rl, SqlSelect m rm, SqlSelect n rn, SqlSelect o ro) => SqlSelect (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o) (ra, rb, rc, rd, re, rf, rg, rh, ri, rj, rk, rl, rm, rn, ro)
instance (SqlSelect a ra, SqlSelect b rb, SqlSelect c rc, SqlSelect d rd, SqlSelect e re, SqlSelect f rf, SqlSelect g rg, SqlSelect h rh, SqlSelect i ri, SqlSelect j rj, SqlSelect k rk, SqlSelect l rl, SqlSelect m rm, SqlSelect n rn) => SqlSelect (a, b, c, d, e, f, g, h, i, j, k, l, m, n) (ra, rb, rc, rd, re, rf, rg, rh, ri, rj, rk, rl, rm, rn)
instance (SqlSelect a ra, SqlSelect b rb, SqlSelect c rc, SqlSelect d rd, SqlSelect e re, SqlSelect f rf, SqlSelect g rg, SqlSelect h rh, SqlSelect i ri, SqlSelect j rj, SqlSelect k rk, SqlSelect l rl, SqlSelect m rm) => SqlSelect (a, b, c, d, e, f, g, h, i, j, k, l, m) (ra, rb, rc, rd, re, rf, rg, rh, ri, rj, rk, rl, rm)
instance (SqlSelect a ra, SqlSelect b rb, SqlSelect c rc, SqlSelect d rd, SqlSelect e re, SqlSelect f rf, SqlSelect g rg, SqlSelect h rh, SqlSelect i ri, SqlSelect j rj, SqlSelect k rk, SqlSelect l rl) => SqlSelect (a, b, c, d, e, f, g, h, i, j, k, l) (ra, rb, rc, rd, re, rf, rg, rh, ri, rj, rk, rl)
instance (SqlSelect a ra, SqlSelect b rb, SqlSelect c rc, SqlSelect d rd, SqlSelect e re, SqlSelect f rf, SqlSelect g rg, SqlSelect h rh, SqlSelect i ri, SqlSelect j rj, SqlSelect k rk) => SqlSelect (a, b, c, d, e, f, g, h, i, j, k) (ra, rb, rc, rd, re, rf, rg, rh, ri, rj, rk)
instance (SqlSelect a ra, SqlSelect b rb, SqlSelect c rc, SqlSelect d rd, SqlSelect e re, SqlSelect f rf, SqlSelect g rg, SqlSelect h rh, SqlSelect i ri, SqlSelect j rj) => SqlSelect (a, b, c, d, e, f, g, h, i, j) (ra, rb, rc, rd, re, rf, rg, rh, ri, rj)
instance (SqlSelect a ra, SqlSelect b rb, SqlSelect c rc, SqlSelect d rd, SqlSelect e re, SqlSelect f rf, SqlSelect g rg, SqlSelect h rh, SqlSelect i ri) => SqlSelect (a, b, c, d, e, f, g, h, i) (ra, rb, rc, rd, re, rf, rg, rh, ri)
instance (SqlSelect a ra, SqlSelect b rb, SqlSelect c rc, SqlSelect d rd, SqlSelect e re, SqlSelect f rf, SqlSelect g rg, SqlSelect h rh) => SqlSelect (a, b, c, d, e, f, g, h) (ra, rb, rc, rd, re, rf, rg, rh)
instance (SqlSelect a ra, SqlSelect b rb, SqlSelect c rc, SqlSelect d rd, SqlSelect e re, SqlSelect f rf, SqlSelect g rg) => SqlSelect (a, b, c, d, e, f, g) (ra, rb, rc, rd, re, rf, rg)
instance (SqlSelect a ra, SqlSelect b rb, SqlSelect c rc, SqlSelect d rd, SqlSelect e re, SqlSelect f rf) => SqlSelect (a, b, c, d, e, f) (ra, rb, rc, rd, re, rf)
instance (SqlSelect a ra, SqlSelect b rb, SqlSelect c rc, SqlSelect d rd, SqlSelect e re) => SqlSelect (a, b, c, d, e) (ra, rb, rc, rd, re)
instance (SqlSelect a ra, SqlSelect b rb, SqlSelect c rc, SqlSelect d rd) => SqlSelect (a, b, c, d) (ra, rb, rc, rd)
instance (SqlSelect a ra, SqlSelect b rb, SqlSelect c rc) => SqlSelect (a, b, c) (ra, rb, rc)
instance (SqlSelect a ra, SqlSelect b rb) => SqlSelect (a, b) (ra, rb)
instance PersistField a => SqlSelect (SqlExpr (Value a)) (Value a)
instance PersistEntity a => SqlSelect (SqlExpr (Maybe (Entity a))) (Maybe (Entity a))
instance PersistEntity a => SqlSelect (SqlExpr (Entity a)) (Entity a)
instance SqlSelect () ()
instance SqlSelect (SqlExpr InsertFinal) InsertFinal
instance (UnsafeSqlFunctionArgument a, UnsafeSqlFunctionArgument b, UnsafeSqlFunctionArgument c, UnsafeSqlFunctionArgument d) => UnsafeSqlFunctionArgument (a, b, c, d)
instance (UnsafeSqlFunctionArgument a, UnsafeSqlFunctionArgument b, UnsafeSqlFunctionArgument c) => UnsafeSqlFunctionArgument (a, b, c)
instance (UnsafeSqlFunctionArgument a, UnsafeSqlFunctionArgument b) => UnsafeSqlFunctionArgument (a, b)
instance UnsafeSqlFunctionArgument a => UnsafeSqlFunctionArgument [a]
instance a ~ Value b => UnsafeSqlFunctionArgument (SqlExpr a)
instance ToSomeValues SqlExpr (SqlExpr (Value a))
instance Esqueleto SqlQuery SqlExpr SqlBackend
instance Monoid LimitClause
instance Monoid GroupByClause
instance Monoid WhereClause
instance Monoid DistinctClause
instance Monoid SideData
instance Applicative SqlQuery
instance Monad SqlQuery
instance Functor SqlQuery


-- | This module contain PostgreSQL-specific functions.
--   
--   <i>Since: 2.2.8</i>
module Database.Esqueleto.PostgreSQL

-- | (<tt>array_agg</tt>) Concatenate input values, including
--   <tt>NULL</tt>s, into an array.
--   
--   <i>Since: 2.2.8</i>
arrayAgg :: SqlExpr (Value a) -> SqlExpr (Value [a])

-- | (<tt>string_agg</tt>) Concatenate input values separated by a
--   delimiter.
--   
--   <i>Since: 2.2.8</i>
stringAgg :: IsString s => SqlExpr (Value s) -> SqlExpr (Value s) -> SqlExpr (Value s)


-- | The <tt>esqueleto</tt> EDSL (embedded domain specific language). This
--   module replaces <tt>Database.Persist</tt>, so instead of importing
--   that module you should just import this one:
--   
--   <pre>
--   -- For a module using just esqueleto.
--   import Database.Esqueleto
--   </pre>
--   
--   If you need to use <tt>persistent</tt>'s default support for queries
--   as well, either import it qualified:
--   
--   <pre>
--   -- For a module that mostly uses esqueleto.
--   import Database.Esqueleto
--   import qualified Database.Persistent as P
--   </pre>
--   
--   or import <tt>esqueleto</tt> itself qualified:
--   
--   <pre>
--   -- For a module uses esqueleto just on some queries.
--   import Database.Persistent
--   import qualified Database.Esqueleto as E
--   </pre>
--   
--   Other than identifier name clashes, <tt>esqueleto</tt> does not
--   conflict with <tt>persistent</tt> in any way.
module Database.Esqueleto

-- | Finally tagless representation of <tt>esqueleto</tt>'s EDSL.
class (Functor query, Applicative query, Monad query) => Esqueleto query expr backend | query -> expr backend, expr -> query backend
where_ :: Esqueleto query expr backend => expr (Value Bool) -> query ()
on :: Esqueleto query expr backend => expr (Value Bool) -> query ()
groupBy :: (Esqueleto query expr backend, ToSomeValues expr a) => a -> query ()
orderBy :: Esqueleto query expr backend => [expr OrderBy] -> query ()
asc :: (Esqueleto query expr backend, PersistField a) => expr (Value a) -> expr OrderBy
desc :: (Esqueleto query expr backend, PersistField a) => expr (Value a) -> expr OrderBy
limit :: Esqueleto query expr backend => Int64 -> query ()
offset :: Esqueleto query expr backend => Int64 -> query ()
distinct :: Esqueleto query expr backend => query a -> query a
distinctOn :: Esqueleto query expr backend => [expr DistinctOn] -> query a -> query a
don :: Esqueleto query expr backend => expr (Value a) -> expr DistinctOn
distinctOnOrderBy :: Esqueleto query expr backend => [expr OrderBy] -> query a -> query a
rand :: Esqueleto query expr backend => expr OrderBy
having :: Esqueleto query expr backend => expr (Value Bool) -> query ()
locking :: Esqueleto query expr backend => LockingKind -> query ()
sub_select :: (Esqueleto query expr backend, PersistField a) => query (expr (Value a)) -> expr (Value a)
sub_selectDistinct :: (Esqueleto query expr backend, PersistField a) => query (expr (Value a)) -> expr (Value a)
(^.) :: (Esqueleto query expr backend, PersistEntity val, PersistField typ) => expr (Entity val) -> EntityField val typ -> expr (Value typ)
(?.) :: (Esqueleto query expr backend, PersistEntity val, PersistField typ) => expr (Maybe (Entity val)) -> EntityField val typ -> expr (Value (Maybe typ))
val :: (Esqueleto query expr backend, PersistField typ) => typ -> expr (Value typ)
isNothing :: (Esqueleto query expr backend, PersistField typ) => expr (Value (Maybe typ)) -> expr (Value Bool)
just :: Esqueleto query expr backend => expr (Value typ) -> expr (Value (Maybe typ))
nothing :: Esqueleto query expr backend => expr (Value (Maybe typ))
joinV :: Esqueleto query expr backend => expr (Value (Maybe (Maybe typ))) -> expr (Value (Maybe typ))
countRows :: (Esqueleto query expr backend, Num a) => expr (Value a)
count :: (Esqueleto query expr backend, Num a) => expr (Value typ) -> expr (Value a)
not_ :: Esqueleto query expr backend => expr (Value Bool) -> expr (Value Bool)
(==.) :: (Esqueleto query expr backend, PersistField typ) => expr (Value typ) -> expr (Value typ) -> expr (Value Bool)
(>=.) :: (Esqueleto query expr backend, PersistField typ) => expr (Value typ) -> expr (Value typ) -> expr (Value Bool)
(>.) :: (Esqueleto query expr backend, PersistField typ) => expr (Value typ) -> expr (Value typ) -> expr (Value Bool)
(<=.) :: (Esqueleto query expr backend, PersistField typ) => expr (Value typ) -> expr (Value typ) -> expr (Value Bool)
(<.) :: (Esqueleto query expr backend, PersistField typ) => expr (Value typ) -> expr (Value typ) -> expr (Value Bool)
(!=.) :: (Esqueleto query expr backend, PersistField typ) => expr (Value typ) -> expr (Value typ) -> expr (Value Bool)
(&&.) :: Esqueleto query expr backend => expr (Value Bool) -> expr (Value Bool) -> expr (Value Bool)
(||.) :: Esqueleto query expr backend => expr (Value Bool) -> expr (Value Bool) -> expr (Value Bool)
(+.) :: (Esqueleto query expr backend, PersistField a) => expr (Value a) -> expr (Value a) -> expr (Value a)
(-.) :: (Esqueleto query expr backend, PersistField a) => expr (Value a) -> expr (Value a) -> expr (Value a)
(/.) :: (Esqueleto query expr backend, PersistField a) => expr (Value a) -> expr (Value a) -> expr (Value a)
(*.) :: (Esqueleto query expr backend, PersistField a) => expr (Value a) -> expr (Value a) -> expr (Value a)
random_ :: (Esqueleto query expr backend, PersistField a, Num a) => expr (Value a)
round_ :: (Esqueleto query expr backend, PersistField a, Num a, PersistField b, Num b) => expr (Value a) -> expr (Value b)
ceiling_ :: (Esqueleto query expr backend, PersistField a, Num a, PersistField b, Num b) => expr (Value a) -> expr (Value b)
floor_ :: (Esqueleto query expr backend, PersistField a, Num a, PersistField b, Num b) => expr (Value a) -> expr (Value b)
sum_ :: (Esqueleto query expr backend, PersistField a, PersistField b) => expr (Value a) -> expr (Value (Maybe b))
min_ :: (Esqueleto query expr backend, PersistField a) => expr (Value a) -> expr (Value (Maybe a))
max_ :: (Esqueleto query expr backend, PersistField a) => expr (Value a) -> expr (Value (Maybe a))
avg_ :: (Esqueleto query expr backend, PersistField a, PersistField b) => expr (Value a) -> expr (Value (Maybe b))
castNum :: (Esqueleto query expr backend, Num a, Num b) => expr (Value a) -> expr (Value b)
castNumM :: (Esqueleto query expr backend, Num a, Num b) => expr (Value (Maybe a)) -> expr (Value (Maybe b))
coalesce :: (Esqueleto query expr backend, PersistField a) => [expr (Value (Maybe a))] -> expr (Value (Maybe a))
coalesceDefault :: (Esqueleto query expr backend, PersistField a) => [expr (Value (Maybe a))] -> expr (Value a) -> expr (Value a)
lower_ :: (Esqueleto query expr backend, PersistField a, IsString a) => expr (Value a) -> expr (Value a)
like :: (Esqueleto query expr backend, PersistField s, IsString s) => expr (Value s) -> expr (Value s) -> expr (Value Bool)
ilike :: (Esqueleto query expr backend, PersistField s, IsString s) => expr (Value s) -> expr (Value s) -> expr (Value Bool)
(%) :: (Esqueleto query expr backend, PersistField s, IsString s) => expr (Value s)
concat_ :: (Esqueleto query expr backend, PersistField s, IsString s) => [expr (Value s)] -> expr (Value s)
(++.) :: (Esqueleto query expr backend, PersistField s, IsString s) => expr (Value s) -> expr (Value s) -> expr (Value s)
subList_select :: (Esqueleto query expr backend, PersistField a) => query (expr (Value a)) -> expr (ValueList a)
subList_selectDistinct :: (Esqueleto query expr backend, PersistField a) => query (expr (Value a)) -> expr (ValueList a)
valList :: (Esqueleto query expr backend, PersistField typ) => [typ] -> expr (ValueList typ)
in_ :: (Esqueleto query expr backend, PersistField typ) => expr (Value typ) -> expr (ValueList typ) -> expr (Value Bool)
notIn :: (Esqueleto query expr backend, PersistField typ) => expr (Value typ) -> expr (ValueList typ) -> expr (Value Bool)
exists :: Esqueleto query expr backend => query () -> expr (Value Bool)
notExists :: Esqueleto query expr backend => query () -> expr (Value Bool)
set :: (Esqueleto query expr backend, PersistEntity val) => expr (Entity val) -> [expr (Update val)] -> query ()
(=.) :: (Esqueleto query expr backend, PersistEntity val, PersistField typ) => EntityField val typ -> expr (Value typ) -> expr (Update val)
(+=.) :: (Esqueleto query expr backend, PersistEntity val, PersistField a) => EntityField val a -> expr (Value a) -> expr (Update val)
(-=.) :: (Esqueleto query expr backend, PersistEntity val, PersistField a) => EntityField val a -> expr (Value a) -> expr (Update val)
(*=.) :: (Esqueleto query expr backend, PersistEntity val, PersistField a) => EntityField val a -> expr (Value a) -> expr (Update val)
(/=.) :: (Esqueleto query expr backend, PersistEntity val, PersistField a) => EntityField val a -> expr (Value a) -> expr (Update val)
(<#) :: Esqueleto query expr backend => (a -> b) -> expr (Value a) -> expr (Insertion b)
(<&>) :: Esqueleto query expr backend => expr (Insertion (a -> b)) -> expr (Value a) -> expr (Insertion b)
case_ :: (Esqueleto query expr backend, PersistField a) => [(expr (Value Bool), expr (Value a))] -> expr (Value a) -> expr (Value a)

-- | Syntax sugar for <a>case_</a>.
--   
--   <i>Since: 2.1.2</i>
when_ :: expr (Value Bool) -> () -> expr a -> (expr (Value Bool), expr a)

-- | Syntax sugar for <a>case_</a>.
--   
--   <i>Since: 2.1.2</i>
then_ :: ()

-- | Syntax sugar for <a>case_</a>.
--   
--   <i>Since: 2.1.2</i>
else_ :: expr a -> expr a

-- | <tt>FROM</tt> clause: bring entities into scope.
--   
--   This function internally uses two type classes in order to provide
--   some flexibility of how you may call it. Internally we refer to these
--   type classes as the two different magics.
--   
--   The innermost magic allows you to use <tt>from</tt> with the following
--   types:
--   
--   <ul>
--   <li><tt>expr (Entity val)</tt>, which brings a single entity into
--   scope.</li>
--   <li><tt>expr (Maybe (Entity val))</tt>, which brings a single entity
--   that may be <tt>NULL</tt> into scope. Used for <tt>OUTER
--   JOIN</tt>s.</li>
--   <li>A <tt>JOIN</tt> of any other two types allowed by the innermost
--   magic, where a <tt>JOIN</tt> may be an <a>InnerJoin</a>, a
--   <a>CrossJoin</a>, a <a>LeftOuterJoin</a>, a <a>RightOuterJoin</a>, or
--   a <a>FullOuterJoin</a>. The <tt>JOINs</tt> have left fixity.</li>
--   </ul>
--   
--   The outermost magic allows you to use <tt>from</tt> on any tuples of
--   types supported by innermost magic (and also tuples of tuples, and so
--   on), up to 8-tuples.
--   
--   Note that using <tt>from</tt> for the same entity twice does work and
--   corresponds to a self-join. You don't even need to use two different
--   calls to <tt>from</tt>, you may use a <tt>JOIN</tt> or a tuple.
--   
--   The following are valid examples of uses of <tt>from</tt> (the types
--   of the arguments of the lambda are inside square brackets):
--   
--   <pre>
--   <a>from</a> $ \person -&gt; ...
--   <a>from</a> $ \(person, blogPost) -&gt; ...
--   <a>from</a> $ \(p `'LeftOuterJoin`` mb) -&gt; ...
--   <a>from</a> $ \(p1 `'InnerJoin`` f `'InnerJoin`` p2) -&gt; ...
--   <a>from</a> $ \((p1 `'InnerJoin`` f) `'InnerJoin`` p2) -&gt; ...
--   </pre>
--   
--   The types of the arguments to the lambdas above are, respectively:
--   
--   <pre>
--   person
--     :: ( Esqueleto query expr backend
--        , PersistEntity Person
--        , PersistEntityBackend Person ~ backend
--        ) =&gt; expr (Entity Person)
--   (person, blogPost)
--     :: (...) =&gt; (expr (Entity Person), expr (Entity BlogPost))
--   (p `'LeftOuterJoin`` mb)
--     :: (...) =&gt; InnerJoin (expr (Entity Person)) (expr (Maybe (Entity BlogPost)))
--   (p1 `'InnerJoin`` f `'InnerJoin`` p2)
--     :: (...) =&gt; InnerJoin
--                   (InnerJoin (expr (Entity Person))
--                              (expr (Entity Follow)))
--                   (expr (Entity Person))
--   (p1 `'InnerJoin`` (f `'InnerJoin`` p2)) ::
--     :: (...) =&gt; InnerJoin
--                   (expr (Entity Person))
--                   (InnerJoin (expr (Entity Follow))
--                              (expr (Entity Person)))
--   </pre>
--   
--   Note that some backends may not support all kinds of <tt>JOIN</tt>s.
from :: From query expr backend a => (a -> query b) -> query b

-- | A single value (as opposed to a whole entity). You may use
--   <tt>(<a>^.</a>)</tt> or <tt>(<a>?.</a>)</tt> to get a <a>Value</a>
--   from an <a>Entity</a>.
data Value a
Value :: a -> Value a

-- | Unwrap a <a>Value</a>.
--   
--   <i>Since: 1.4.1</i>
unValue :: Value a -> a

-- | A list of single values. There's a limited set of functions able to
--   work with this data type (such as <a>subList_select</a>,
--   <a>valList</a>, <a>in_</a> and <a>exists</a>).
data ValueList a
ValueList :: a -> ValueList a

-- | Phantom type used by <a>orderBy</a>, <a>asc</a> and <a>desc</a>.
data OrderBy

-- | Phantom type used by <a>distinctOn</a> and <a>don</a>.
data DistinctOn

-- | Different kinds of locking clauses supported by <a>locking</a>.
--   
--   Note that each RDBMS has different locking support. The constructors
--   of this datatype specify only the <i>syntax</i> of the locking
--   mechanism, not its <i>semantics</i>. For example, even though both
--   MySQL and PostgreSQL support <a>ForUpdate</a>, there are no guarantees
--   that they will behave the same.
--   
--   <i>Since: 2.2.7</i>
data LockingKind

-- | <tt>FOR UPDATE</tt> syntax. Supported by MySQL, Oracle and PostgreSQL.
--   
--   <i>Since: 2.2.7</i>
ForUpdate :: LockingKind

-- | <tt>FOR SHARE</tt> syntax. Supported by PostgreSQL.
--   
--   <i>Since: 2.2.7</i>
ForShare :: LockingKind

-- | <tt>LOCK IN SHARE MODE</tt> syntax. Supported by MySQL.
--   
--   <i>Since: 2.2.7</i>
LockInShareMode :: LockingKind

-- | Data type that represents an <tt>INNER JOIN</tt> (see
--   <a>LeftOuterJoin</a> for an example).
data InnerJoin a b
InnerJoin :: a -> b -> InnerJoin a b

-- | Data type that represents a <tt>CROSS JOIN</tt> (see
--   <a>LeftOuterJoin</a> for an example).
data CrossJoin a b
CrossJoin :: a -> b -> CrossJoin a b

-- | Data type that represents a <tt>LEFT OUTER JOIN</tt>. For example,
--   
--   <pre>
--   select $
--   <a>from</a> $ \(person `'LeftOuterJoin`` pet) -&gt;
--     ...
--   </pre>
--   
--   is translated into
--   
--   <pre>
--   SELECT ...
--   FROM Person LEFT OUTER JOIN Pet
--   ...
--   </pre>
--   
--   See also: <a>from</a>.
data LeftOuterJoin a b
LeftOuterJoin :: a -> b -> LeftOuterJoin a b

-- | Data type that represents a <tt>RIGHT OUTER JOIN</tt> (see
--   <a>LeftOuterJoin</a> for an example).
data RightOuterJoin a b
RightOuterJoin :: a -> b -> RightOuterJoin a b

-- | Data type that represents a <tt>FULL OUTER JOIN</tt> (see
--   <a>LeftOuterJoin</a> for an example).
data FullOuterJoin a b
FullOuterJoin :: a -> b -> FullOuterJoin a b

-- | Exception thrown whenever <a>on</a> is used to create an <tt>ON</tt>
--   clause but no matching <tt>JOIN</tt> is found.
data OnClauseWithoutMatchingJoinException
OnClauseWithoutMatchingJoinException :: String -> OnClauseWithoutMatchingJoinException

-- | SQL backend for <tt>esqueleto</tt> using <a>SqlPersistT</a>.
data SqlQuery a

-- | An expression on the SQL backend.
--   
--   There are many comments describing the constructors of this data type.
--   However, Haddock doesn't like GADTs, so you'll have to read them by
--   hitting "Source".
data SqlExpr a

-- | Constraint synonym for <tt>persistent</tt> entities whose backend is
--   <a>SqlPersistT</a>.
type SqlEntity ent = (PersistEntity ent, PersistEntityBackend ent ~ SqlBackend)

-- | Execute an <tt>esqueleto</tt> <tt>SELECT</tt> query inside
--   <tt>persistent</tt>'s <a>SqlPersistT</a> monad and return a list of
--   rows.
--   
--   We've seen that <a>from</a> has some magic about which kinds of things
--   you may bring into scope. This <a>select</a> function also has some
--   magic for which kinds of things you may bring back to Haskell-land by
--   using <tt>SqlQuery</tt>'s <tt>return</tt>:
--   
--   <ul>
--   <li>You may return a <tt>SqlExpr (<a>Entity</a> v)</tt> for an entity
--   <tt>v</tt> (i.e., like the <tt>*</tt> in SQL), which is then returned
--   to Haskell-land as just <tt>Entity v</tt>.</li>
--   <li>You may return a <tt>SqlExpr (Maybe (Entity v))</tt> for an entity
--   <tt>v</tt> that may be <tt>NULL</tt>, which is then returned to
--   Haskell-land as <tt>Maybe (Entity v)</tt>. Used for <tt>OUTER
--   JOIN</tt>s.</li>
--   <li>You may return a <tt>SqlExpr (<a>Value</a> t)</tt> for a value
--   <tt>t</tt> (i.e., a single column), where <tt>t</tt> is any instance
--   of <a>PersistField</a>, which is then returned to Haskell-land as
--   <tt>Value t</tt>. You may use <tt>Value</tt> to return projections of
--   an <tt>Entity</tt> (see <tt>(<a>^.</a>)</tt> and <tt>(<a>?.</a>)</tt>)
--   or to return any other value calculated on the query (e.g.,
--   <a>countRows</a> or <a>sub_select</a>).</li>
--   </ul>
--   
--   The <tt>SqlSelect a r</tt> class has functional dependencies that
--   allow type information to flow both from <tt>a</tt> to <tt>r</tt> and
--   vice-versa. This means that you'll almost never have to give any type
--   signatures for <tt>esqueleto</tt> queries. For example, the query
--   <tt><a>select</a> $ from $ \p -&gt; return p</tt> alone is ambiguous,
--   but in the context of
--   
--   <pre>
--   do ps &lt;- <a>select</a> $
--            <a>from</a> $ \p -&gt;
--            return p
--      liftIO $ mapM_ (putStrLn . personName . entityVal) ps
--   </pre>
--   
--   we are able to infer from that single <tt>personName . entityVal</tt>
--   function composition that the <tt>p</tt> inside the query is of type
--   <tt>SqlExpr (Entity Person)</tt>.
select :: (SqlSelect a r, MonadIO m) => SqlQuery a -> SqlPersistT m [r]

-- | Execute an <tt>esqueleto</tt> <tt>SELECT DISTINCT</tt> query inside
--   <tt>persistent</tt>'s <a>SqlPersistT</a> monad and return a list of
--   rows.

-- | <i>Deprecated: Since 2.2.4: use <a>select</a> and <a>distinct</a>.</i>
selectDistinct :: (SqlSelect a r, MonadIO m) => SqlQuery a -> SqlPersistT m [r]

-- | Execute an <tt>esqueleto</tt> <tt>SELECT</tt> query inside
--   <tt>persistent</tt>'s <a>SqlPersistT</a> monad and return a
--   <a>Source</a> of rows.
selectSource :: (SqlSelect a r, MonadResource m) => SqlQuery a -> Source (SqlPersistT m) r

-- | Execute an <tt>esqueleto</tt> <tt>SELECT DISTINCT</tt> query inside
--   <tt>persistent</tt>'s <a>SqlPersistT</a> monad and return a
--   <a>Source</a> of rows.

-- | <i>Deprecated: Since 2.2.4: use <a>selectSource</a> and
--   <a>distinct</a>.</i>
selectDistinctSource :: (SqlSelect a r, MonadResource m) => SqlQuery a -> Source (SqlPersistT m) r

-- | Execute an <tt>esqueleto</tt> <tt>DELETE</tt> query inside
--   <tt>persistent</tt>'s <a>SqlPersistT</a> monad. Note that currently
--   there are no type checks for statements that should not appear on a
--   <tt>DELETE</tt> query.
--   
--   Example of usage:
--   
--   <pre>
--   <a>delete</a> $
--   <a>from</a> $ \appointment -&gt;
--   <a>where_</a> (appointment <a>^.</a> AppointmentDate <a>&lt;.</a> <a>val</a> now)
--   </pre>
--   
--   Unlike <a>select</a>, there is a useful way of using <a>delete</a>
--   that will lead to type ambiguities. If you want to delete all rows
--   (i.e., no <a>where_</a> clause), you'll have to use a type signature:
--   
--   <pre>
--   <a>delete</a> $
--   <a>from</a> $ \(appointment :: <a>SqlExpr</a> (<a>Entity</a> Appointment)) -&gt;
--   return ()
--   </pre>
delete :: MonadIO m => SqlQuery () -> SqlPersistT m ()

-- | Same as <a>delete</a>, but returns the number of rows affected.
deleteCount :: MonadIO m => SqlQuery () -> SqlPersistT m Int64

-- | Execute an <tt>esqueleto</tt> <tt>UPDATE</tt> query inside
--   <tt>persistent</tt>'s <a>SqlPersistT</a> monad. Note that currently
--   there are no type checks for statements that should not appear on a
--   <tt>UPDATE</tt> query.
--   
--   Example of usage:
--   
--   <pre>
--   <a>update</a> $ p -&gt; do
--   <a>set</a> p [ PersonAge <a>=.</a> <a>just</a> (<a>val</a> thisYear) -. p <a>^.</a> PersonBorn ]
--   <a>where_</a> $ isNothing (p <a>^.</a> PersonAge)
--   </pre>
update :: (MonadIO m, SqlEntity val) => (SqlExpr (Entity val) -> SqlQuery ()) -> SqlPersistT m ()

-- | Same as <a>update</a>, but returns the number of rows affected.
updateCount :: (MonadIO m, SqlEntity val) => (SqlExpr (Entity val) -> SqlQuery ()) -> SqlPersistT m Int64

-- | Insert a <a>PersistField</a> for every selected value.
insertSelect :: (MonadIO m, PersistEntity a) => SqlQuery (SqlExpr (Insertion a)) -> SqlPersistT m ()

-- | Insert a <a>PersistField</a> for every unique selected value.

-- | <i>Deprecated: Since 2.2.4: use <a>insertSelect</a> and
--   <a>distinct</a>.</i>
insertSelectDistinct :: (MonadIO m, PersistEntity a) => SqlQuery (SqlExpr (Insertion a)) -> SqlPersistT m ()

-- | <tt>valkey i = <a>val</a> . <a>toSqlKey</a></tt>
--   (<a>https://github.com/prowdsponsor/esqueleto/issues/9</a>).
valkey :: (Esqueleto query expr backend, ToBackendKey SqlBackend entity, PersistField (Key entity)) => Int64 -> expr (Value (Key entity))

-- | <tt>valJ</tt> is like <tt>val</tt> but for something that is already a
--   <tt>Value</tt>. The use case it was written for was, given a
--   <tt>Value</tt> lift the <tt>Key</tt> for that <tt>Value</tt> into the
--   query expression in a type safe way. However, the implementation is
--   more generic than that so we call it <tt>valJ</tt>.
--   
--   Its important to note that the input entity and the output entity are
--   constrained to be the same by the type signature on the function
--   (<a>https://github.com/prowdsponsor/esqueleto/pull/69</a>).
--   
--   <i>Since: 1.4.2</i>
valJ :: (Esqueleto query expr backend, PersistField (Key entity)) => Value (Key entity) -> expr (Value (Key entity))

-- | Synonym for <a>delete</a> that does not clash with
--   <tt>esqueleto</tt>'s <a>delete</a>.
deleteKey :: (PersistStore (PersistEntityBackend val), MonadIO m, PersistEntity val) => Key val -> ReaderT (PersistEntityBackend val) m ()
