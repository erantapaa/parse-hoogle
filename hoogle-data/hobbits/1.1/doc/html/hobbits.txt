-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A library for canonically representing terms with binding
--   
--   A library for canonically representing terms with binding via a
--   constructor for introducing fresh names and a restricted API that
--   avoids the need for alpha-equivalence.
@package hobbits
@version 1.1


-- | Using the haskell-src-meta package to parse Haskell patterns.
module Data.Binding.Hobbits.PatternParser
parsePattern :: String -> String -> Either String Pat


-- | The type-level constructors of type lists.
module Data.Type.List.List
data Nil
data (:>) r a
proxyCons :: Proxy r -> f a -> Proxy (r :> a)
instance Typeable Nil
instance Typeable2 :>


-- | Proofs regarding a type list as an append of two others.
module Data.Type.List.Proof.Append

-- | An <tt>Append ctx1 ctx2 ctx</tt> is a "proof" that <tt>ctx = ctx1
--   <a>:++:</a> ctx2</tt>.
data Append ctx1 ctx2 ctx
Append_Base :: Append ctx Nil ctx
Append_Step :: Append ctx1 ctx2 ctx -> Append ctx1 (ctx2 :> a) (ctx :> a)

-- | Appends two <a>Append</a> proofs.
trans :: Append ctx1 ctx2 ex_ctx -> Append ex_ctx ctx3 ctx -> Append ctx1 (ctx2 :++: ctx3) ctx

-- | Returns a proof that ctx :=: ctx1 :++: ctx2
appendPf :: Append ctx1 ctx2 ctx -> (ctx :=: (ctx1 :++: ctx2))

-- | Returns the length of an <a>Append</a> proof.
length :: Append ctx1 ctx2 ctx3 -> Int


-- | Proofs regarding membership of a type in a type list.
module Data.Type.List.Proof.Member

-- | A <tt>Member ctx a</tt> is a "proof" that the type <tt>a</tt> is in
--   the type list <tt>ctx</tt>, meaning that <tt>ctx</tt> equals
--   
--   <pre>
--   t0 ':&gt;' a ':&gt;' t1 ':&gt;' ... ':&gt;' tn
--   </pre>
--   
--   for some types <tt>t0,t1,...,tn</tt>.
data Member ctx a
Member_Base :: Member (ctx :> a) a
Member_Step :: Member ctx a -> Member (ctx :> b) a
toEq :: Member (Nil :> a) b -> b :=: a
weakenL :: Proxy r1 -> Member r2 a -> Member (r1 :++: r2) a
same :: Member r a -> Member r b -> Maybe (a :=: b)
weakenR :: Member r1 a -> Append r1 r2 r -> Member r a
split :: Append r1 r2 r -> Member r a -> Either (Member r1 a) (Member r2 a)
instance Typeable2 Member
instance Show (Member r a)


-- | Vectors indexed by a type list
module Data.Type.List.Map

-- | A <tt>MapC f c</tt> is a vector with exactly one element of type <tt>f
--   a</tt> for each type <tt>a</tt> in the type list <tt>c</tt>.
data MapC f c
Nil :: MapC f Nil
(:>) :: MapC f c -> f a -> MapC f (c :> a)

-- | Create an empty <a>MapC</a> vector.
empty :: MapC f Nil

-- | Create a singleton <a>MapC</a> vector.
singleton :: f a -> MapC f (Nil :> a)

-- | Look up an element of a <a>MapC</a> vector using a <a>Member</a>
--   proof.
lookup :: Member c a -> MapC f c -> f a

-- | Map a function to all elements of a <a>MapC</a> vector.
mapC :: (forall x. f x -> g x) -> MapC f c -> MapC g c

-- | Map a binary function to all pairs of elements of two <a>MapC</a>
--   vectors.
mapC2 :: (forall x. f x -> g x -> h x) -> MapC f c -> MapC g c -> MapC h c

-- | Append two <a>MapC</a> vectors.
append :: MapC f c1 -> MapC f c2 -> MapC f (c1 :++: c2)

-- | Make an <a>Append</a> proof from any <a>MapC</a> vector for the second
--   argument of the append.
mkAppend :: MapC f c2 -> Append c1 c2 (c1 :++: c2)

-- | A version of <a>mkAppend</a> that takes in a <a>Proxy</a> argument.
mkMonoAppend :: Proxy c1 -> MapC f c2 -> Append c1 c2 (c1 :++: c2)

-- | Split a <a>MapC</a> vector into two pieces.
split :: Append c1 c2 c -> MapC f c -> (MapC f c1, MapC f c2)

-- | Create a <a>Proxy</a> object for the type list of a <a>MapC</a>
--   vector.
proxy :: MapC f c -> Proxy c

-- | Create a vector of proofs that each type in <tt>c</tt> is a
--   <a>Member</a> of <tt>c</tt>.
members :: MapC f c -> MapC (Member c) c

-- | Replace a single element of a <a>MapC</a> vector.
replace :: MapC f c -> Member c a -> f a -> MapC f c


-- | A <i>type list</i> contains types as elements. We use GADT proofs
--   terms to establish membership and append relations. A
--   <tt>Data.Type.List.Map.MapC</tt> <tt>f</tt> is a vector indexed by a
--   type list, where <tt>f :: * -&gt; *</tt> is applied to each type
--   element.
module Data.Type.List


-- | This module is internal to the Hobbits library, and should not be used
--   directly.
module Data.Binding.Hobbits.Internal

-- | A <tt>Name a</tt> is a bound name that is associated with type
--   <tt>a</tt>.
newtype Name a
MkName :: Int -> Name a

-- | An <tt>Mb ctx b</tt> is a multi-binding that binds exactly one name
--   for each type in <tt>ctx</tt>, where <tt>ctx</tt> has the form
--   <tt><a>Nil</a> <a>:&gt;</a> t1 <a>:&gt;</a> ... <a>:&gt;</a> tn</tt>.
data Mb ctx b
MkMb :: (MapC Name ctx) -> b -> Mb ctx b

-- | The type <tt>Cl a</tt> represents a closed term of type <tt>a</tt>,
--   i.e., an expression of type <tt>a</tt> with no free (Haskell)
--   variables. Since this cannot be checked directly in the Haskell type
--   system, the <tt>Cl</tt> data type is hidden, and the user can only
--   create closed terms using Template Haskell, through the
--   <tt>mkClosed</tt> operator.
newtype Cl a
Cl :: a -> Cl a
unCl :: Cl a -> a
data ExMember
ExMember :: Member c a -> ExMember
memberFromLen :: Int -> ExMember
unsafeLookupC :: Int -> Member c a
data ExProxy
ExProxy :: MapC Proxy ctx -> ExProxy
proxyFromLen :: Int -> ExProxy
unsafeProxyFromLen :: Int -> MapC Proxy ctx
unsafeNamesFromInts :: [Int] -> MapC Name ctx
counter :: IORef Int
fresh_name :: a -> Int
instance Typeable1 Name
instance Typeable2 Mb
instance Eq (Name a)


-- | This module defines multi-bindings as the type <a>Mb</a>, as well as a
--   number of operations on multi-bindings. See the paper E. Westbrook, N.
--   Frisby, P. Brauner, "Hobbits for Haskell: A Library for Higher-Order
--   Encodings in Functional Programming Languages" for more information.
module Data.Binding.Hobbits.Mb

-- | A <tt>Name a</tt> is a bound name that is associated with type
--   <tt>a</tt>.
data Name a

-- | A <tt>Binding</tt> is simply a multi-binding that binds one name
type Binding a = Mb (Nil :> a)

-- | An <tt>Mb ctx b</tt> is a multi-binding that binds exactly one name
--   for each type in <tt>ctx</tt>, where <tt>ctx</tt> has the form
--   <tt><a>Nil</a> <a>:&gt;</a> t1 <a>:&gt;</a> ... <a>:&gt;</a> tn</tt>.
data Mb ctx b

-- | <tt>nu f</tt> creates a binding which binds a fresh name <tt>n</tt>
--   and whose body is the result of <tt>f n</tt>.
nu :: (Name a -> b) -> Binding a b

-- | Creates an empty binding that binds 0 names.
emptyMb :: a -> Mb Nil a

-- | The expression <tt>nuMulti p f</tt> creates a multi-binding of zero or
--   more names, one for each element of the vector <tt>p</tt>. The bound
--   names are passed the names to <tt>f</tt>, which returns the body of
--   the multi-binding. The argument <tt>p</tt>, of type <tt><a>Mb</a> f
--   ctx</tt>, acts as a "phantom" argument, used to reify the list of
--   types <tt>ctx</tt> at the term level; thus it is unimportant what the
--   type function <tt>f</tt> is.
nuMulti :: MapC f ctx -> (MapC Name ctx -> b) -> Mb ctx b

-- | Eliminates an empty binding, returning its body. Note that
--   <tt>elimEmptyMb</tt> is the inverse of <tt>emptyMb</tt>.
elimEmptyMb :: Mb Nil a -> a

-- | Combines a binding inside another binding into a single binding.
mbCombine :: Mb c1 (Mb c2 b) -> Mb (c1 :++: c2) b

-- | Separates a binding into two nested bindings. The first argument, of
--   type <tt><a>Append</a> c1 c2 c</tt>, is a "phantom" argument to
--   indicate how the context <tt>c</tt> should be split.
mbSeparate :: Append c1 c2 c -> Mb c a -> Mb c1 (Mb c2 a)

-- | Returns a proxy object that enumerates all the types in ctx.
mbToProxy :: Mb ctx a -> MapC Proxy ctx

-- | <tt>cmpName n m</tt> compares names <tt>n</tt> and <tt>m</tt> of types
--   <tt>Name a</tt> and <tt>Name b</tt>, respectively. When they are
--   equal, <tt>Some e</tt> is returned for <tt>e</tt> a proof of type
--   <tt>a :=: b</tt> that their types are equal. Otherwise, <tt>None</tt>
--   is returned.
--   
--   For example:
--   
--   <pre>
--   nu $ \n -&gt; nu $ \m -&gt; cmpName n n   ==   nu $ \n -&gt; nu $ \m -&gt; Some Refl
--   nu $ \n -&gt; nu $ \m -&gt; cmpName n m   ==   nu $ \n -&gt; nu $ \m -&gt; None
--   </pre>
cmpName :: Name a -> Name b -> Maybe (a :=: b)

-- | Compares two names inside bindings, taking alpha-equivalence into
--   account; i.e., if both are the <tt>i</tt>th name, or both are the same
--   name not bound in their respective multi-bindings, then they compare
--   as equal. The return values are the same as for <a>cmpName</a>, so
--   that <tt>Some Refl</tt> is returned when the names are equal and
--   <tt>Nothing</tt> is returned when they are not.
mbCmpName :: Mb c (Name a) -> Mb c (Name b) -> Maybe (a :=: b)

-- | Checks if a name is bound in a multi-binding, returning <tt>Left
--   mem</tt> when the name is bound, where <tt>mem</tt> is a proof that
--   the type of the name is in the type list for the multi-binding, and
--   returning <tt>Right n</tt> when the name is not bound, where
--   <tt>n</tt> is the name.
--   
--   For example:
--   
--   <pre>
--   nu $ \n -&gt; mbNameBoundP (nu $ \m -&gt; m)  ==  nu $ \n -&gt; Left Member_Base
--   nu $ \n -&gt; mbNameBoundP (nu $ \m -&gt; n)  ==  nu $ \n -&gt; Right n
--   </pre>
mbNameBoundP :: Mb ctx (Name a) -> Either (Member ctx a) (Name a)

-- | The class <tt>Liftable a</tt> gives a "lifting function" for a, which
--   can take any data of type <tt>a</tt> out of a multi-binding of type
--   <tt><a>Mb</a> ctx a</tt>.
class Liftable a
mbLift :: Liftable a => Mb ctx a -> a

-- | The class <tt>Liftable1 f</tt> gives a lifting function for each type
--   <tt>f a</tt> when <tt>a</tt> itself is <tt>Liftable</tt>.
class Liftable1 f
mbLift1 :: (Liftable1 f, Liftable a) => Mb ctx (f a) -> f a

-- | The class <tt>Liftable2 f</tt> gives a lifting function for each type
--   <tt>f a b</tt> when <tt>a</tt> and <tt>b</tt> are <tt>Liftable</tt>.
class Liftable2 f
mbLift2 :: (Liftable2 f, Liftable a, Liftable b) => Mb ctx (f a b) -> f a b

-- | Lift a list (but not its elements) out of a multi-binding
mbList :: Mb c [a] -> [Mb c a]

-- | <pre>
--   nus = nuMulti
--   </pre>
nus :: MapC f ctx -> (MapC Name ctx -> b) -> Mb ctx b
instance [overlap ok] (Liftable2 f, Liftable a) => Liftable1 (f a)
instance [overlap ok] Liftable1 []
instance [overlap ok] (Liftable1 f, Liftable a) => Liftable (f a)
instance [overlap ok] Liftable (Member c a)
instance [overlap ok] Liftable Char
instance [overlap ok] Liftable Int
instance [overlap ok] Show a => Show (Mb c a)
instance [overlap ok] Show (MapC Name c)
instance [overlap ok] Show (Name a)


-- | Defines a quasi-quoter for writing patterns that match the bodies of
--   <a>Mb</a> multi-bindings. Uses the haskell-src-exts parser. <tt>[nuP|
--   P ]</tt> defines a pattern that will match a multi-binding whose body
--   matches <tt>P</tt>. Any variables matched by <tt>P</tt> will remain
--   inside the binding; thus, for example, in the pattern <tt>[nuP| x
--   |]</tt>, <tt>x</tt> matches the entire multi-binding.
--   
--   Examples:
--   
--   <pre>
--   case (nu Left) of [nuP| Left x |] -&gt; x  ==  nu id
--   </pre>
--   
--   <ul>
--   <li><i>clP| P |</i> does the same for the Cl type, and [clNuP| P |]
--   works for both simultaneously: Cl (Mb ctx a).</li>
--   </ul>
module Data.Binding.Hobbits.QQ
nuP :: QuasiQuoter
clP :: QuasiQuoter
clNuP :: QuasiQuoter


-- | This module defines the NuElim typeclass, which allows eliminations of
--   (multi-) bindings. The high-level idea is that, when a fresh name is
--   created with <a>nu</a>, the fresh name can also be substituted for the
--   bound name in a binding. See the documentation for <a>nuWithElim1</a>
--   and <tt>nuWithElimMulti</tt> for details.
module Data.Binding.Hobbits.NuElim

-- | Applies a function in a multi-binding to an argument in a
--   multi-binding that binds the same number and types of names.
mbApply :: (NuElim a, NuElim b) => Mb ctx (a -> b) -> Mb ctx a -> Mb ctx b
mbMapAndSwap :: NuElim a => (Mb ctx1 a -> b) -> Mb ctx1 (Mb ctx2 a) -> Mb ctx2 b

-- | Take a multi-binding inside another multi-binding and move the outer
--   binding inside the inner one.
mbRearrange :: NuElim a => Mb ctx1 (Mb ctx2 a) -> Mb ctx2 (Mb ctx1 a)

-- | The expression <tt>nuWithElimMulti args f</tt> takes a sequence
--   <tt>args</tt> of zero or more multi-bindings, each of type <tt>Mb ctx
--   ai</tt> for the same type context <tt>ctx</tt> of bound names, and a
--   function <tt>f</tt> and does the following:
--   
--   <ul>
--   <li>Creates a multi-binding that binds names <tt>n1,...,nn</tt>, one
--   name for each type in <tt>ctx</tt>;</li>
--   <li>Substitutes the names <tt>n1,...,nn</tt> for the names bound by
--   each argument in the <tt>args</tt> sequence, yielding the bodies of
--   the <tt>args</tt> (using the new name <tt>n</tt>); and then</li>
--   <li>Passes the sequence <tt>n1,...,nn</tt> along with the result of
--   substituting into <tt>args</tt> to the function <tt>f</tt>, which then
--   returns the value for the newly created binding.</li>
--   </ul>
--   
--   Note that the types in <tt>args</tt> must each have a <tt>NuElim</tt>
--   instance; this is represented with the <tt>NuElimList</tt> type class.
--   
--   Here are some examples:
--   
--   <pre>
--   commuteFun :: (NuElim a, NuElim b) =&gt; Mb ctx (a -&gt; b) -&gt; Mb ctx a -&gt; Mb ctx b
--   commuteFun f a =
--       nuWithElimMulti ('mbToProxy' f) ('Nil' :&gt; f :&gt; a)
--                       (\_ ('Nil' :&gt; 'Identity' f' :&gt; 'Identity' a') -&gt; f' a')
--   </pre>
nuMultiWithElim :: (NuElimList args, NuElim b) => MapC f ctx -> MapC (Mb ctx) args -> (MapC Name ctx -> MapC Identity args -> b) -> Mb ctx b

-- | Similar to <a>nuMultiWithElim</a> but binds only one name.
nuWithElim :: (NuElimList args, NuElim b) => MapC (Mb (Nil :> a)) args -> (Name a -> MapC Identity args -> b) -> Binding a b

-- | Similar to <a>nuMultiWithElim</a> but takes only one argument
nuMultiWithElim1 :: (NuElim arg, NuElim b) => MapC f ctx -> Mb ctx arg -> (MapC Name ctx -> arg -> b) -> Mb ctx b

-- | Similar to <a>nuMultiWithElim</a> but takes only one argument that
--   binds a single name.
nuWithElim1 :: (NuElim arg, NuElim b) => Binding a arg -> (Name a -> arg -> b) -> Binding a b

-- | Instances of the <tt>NuElim a</tt> class allow the type <tt>a</tt> to
--   be used with <tt>nuWithElimMulti</tt> and <a>nuWithElim1</a>. The
--   structure of this class is mostly hidden from the user; see
--   <a>mkNuElimData</a> to see how to create instances of the
--   <tt>NuElim</tt> class.
class NuElim a
nuElimProof :: NuElim a => NuElimProof a

-- | Template Haskell function for creating NuElim instances for (G)ADTs.
--   Typical usage is to include the following line in the source file for
--   (G)ADT <tt>T</tt> (here assumed to have two type arguments):
--   
--   <pre>
--   $(mkNuElimData [t| forall a b . T a b |])
--   </pre>
--   
--   The <a>mkNuElimData</a> call here will create an instance declaration
--   for <tt><a>NuElim</a> (T a b)</tt>. It is also possible to include a
--   context in the forall type; for example, if we define the <tt>ID</tt>
--   data type as follows:
--   
--   <pre>
--   data ID a = ID a
--   </pre>
--   
--   then we can create a <a>NuElim</a> instance for it like this:
--   
--   <pre>
--   $( mkNuElimData [t| NuElim a =&gt; ID a |])
--   </pre>
--   
--   Note that, when a context is included, the Haskell parser will add the
--   <tt>forall a</tt> for you.
mkNuElimData :: Q Type -> Q [Dec]
class NuElimList args
nuElimListProof :: NuElimList args => MapC NuElimObj args
class NuElim1 f
nuElimProof1 :: (NuElim1 f, NuElim a) => NuElimObj (f a)
data NuElimProof a
instance (NuElim1 f, NuElimList ctx) => NuElim (MapC f ctx)
instance (NuElimList args, NuElim a) => NuElimList (args :> a)
instance NuElimList Nil
instance NuElim a => NuElim [a]
instance (NuElim a, NuElim b) => NuElim (Either a b)
instance (NuElim a, NuElim b, NuElim c, NuElim d) => NuElim (a, b, c, d)
instance (NuElim a, NuElim b, NuElim c) => NuElim (a, b, c)
instance (NuElim a, NuElim b) => NuElim (a, b)
instance NuElim Char
instance NuElim Int
instance NuElim a => NuElim (Mb ctx a)
instance (NuElim a, NuElim b) => NuElim (a -> b)
instance NuElim (Name a)


-- | This module uses Template Haskell to distinguish closed terms, so that
--   the library can trust such functions to not contain any <tt>Name</tt>
--   values in their closure.
module Data.Binding.Hobbits.Closed

-- | The type <tt>Cl a</tt> represents a closed term of type <tt>a</tt>,
--   i.e., an expression of type <tt>a</tt> with no free (Haskell)
--   variables. Since this cannot be checked directly in the Haskell type
--   system, the <tt>Cl</tt> data type is hidden, and the user can only
--   create closed terms using Template Haskell, through the
--   <tt>mkClosed</tt> operator.
data Cl a

-- | <tt>cl</tt> is used with Template Haskell quotations to create closed
--   terms of type <a>Cl</a>. A quoted expression is closed if all of the
--   names occuring in it are
--   
--   1) bound globally or 2) bound within the quotation or 3) also of type
--   <a>Cl</a>.
cl :: Q Exp -> Q Exp

-- | Closed terms are closed (sorry) under application.
clApply :: Cl (a -> b) -> Cl a -> Cl b
unCl :: Cl a -> a

-- | <tt>mbApplyCl</tt> <tt>f</tt> <tt>b</tt> applies a closed function
--   <tt>f</tt> to the body of multi-binding <tt>b</tt>. For example:
--   
--   <pre>
--   mbApplyCl $(cl [| f |]) (nu $ \n -&gt; n)   =   nu f
--   </pre>
mbApplyCl :: Cl (a -> b) -> Mb ctx a -> Mb ctx b

-- | <tt>mbLiftClosed</tt> is safe because closed terms don't contain
--   names.
mbLiftClosed :: Mb ctx (Cl a) -> Cl a

-- | <tt>noClosedNames</tt> encodes the hobbits guarantee that no name can
--   escape its multi-binding.
noClosedNames :: Cl (Name a) -> b

-- | <pre>
--   mkClosed = cl
--   </pre>
mkClosed :: Q Exp -> Q Exp

-- | <pre>
--   Closed = Cl
--   </pre>
type Closed = Cl

-- | <pre>
--   unClosed = unCl
--   </pre>
unClosed :: Cl a -> a


-- | This library implements multi-bindings as described in the paper E.
--   Westbrook, N. Frisby, P. Brauner, "Hobbits for Haskell: A Library for
--   Higher-Order Encodings in Functional Programming Languages".
module Data.Binding.Hobbits


module Data.Binding.Hobbits.Examples.LambdaLifting.Terms
data L a
data D a
data Term :: * -> *
Var :: Name (L a) -> Term a
Lam :: Binding (L b) (Term a) -> Term (b -> a)
App :: Term (b -> a) -> Term b -> Term a
lam :: (Term a -> Term b) -> Term (a -> b)
data DTerm :: * -> *
TVar :: Name (L a) -> DTerm a
TDVar :: Name (D a) -> DTerm a
TApp :: DTerm (a -> b) -> DTerm a -> DTerm b
data Decl :: * -> *
Decl_One :: Binding (L a) (DTerm b) -> Decl (a -> b)
Decl_Cons :: Binding (L a) (Decl b) -> Decl (a -> b)
data Decls :: * -> *
Decls_Base :: DTerm a -> Decls a
Decls_Cons :: Decl b -> Binding (D b) (Decls a) -> Decls a
instance Show (Decls a)
instance Show (DTerm a)
instance Show (Term a)


module Data.Binding.Hobbits.Examples.LambdaLifting.Examples
ex1 :: Term ((b1 -> b) -> b1 -> b)
ex2 :: Term ((((b2 -> b1) -> b2 -> b1) -> b) -> b)
ex3 :: Term (b3 -> (((b3 -> b2 -> b1) -> b2 -> b1) -> b) -> b)
ex4 :: Term (((b1 -> b) -> b2 -> b) -> (((b1 -> b) -> b2 -> b) -> b2 -> b1) -> b2 -> b1)
ex5 :: Term (((b2 -> b1) -> b) -> (b2 -> b1) -> b)
ex6 :: Binding (L ((b -> b) -> a)) (Term a)
ex7 :: Binding (L ((b2 -> b2) -> b1)) (Term ((b1 -> b) -> b))
exP :: Term (((b1 -> b1) -> b) -> (b1 -> b1) -> b)


-- | The lambda lifting example from the paper E. Westbrook, N. Frisby, P.
--   Brauner, "Hobbits for Haskell: A Library for Higher-Order Encodings in
--   Functional Programming Languages".
module Data.Binding.Hobbits.Examples.LambdaLifting
lambdaLift :: Term a -> Decls a
mbLambdaLift :: Mb c (Term a) -> Mb c (Decls a)
