-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Derivative Parsing
--   
--   A parser based on derivatives of parser combinators (Might and
--   Darais). Our paper on Arxiv details the theory of parsing with
--   derivatives: <a>http://arxiv.org/abs/1010.5023</a>. This
--   implementation uses my latest work on the theory that brings the
--   O(n*|G|^2) complexity bound to O(n) for parsing most
--   not-painfully-ambiguous grammars. (|G| would be the size of the
--   initial grammar, n would be size of the input. These bounds are based
--   off of observation and intuition; they are not proven yet.) This
--   implementation will not terminate if the resulting parse forest is
--   infinite. We know how to extend the implementation to work for
--   infinite parse forests with little effort. If this is something you
--   would like to see, send me an email.
@package derp
@version 0.1.6

module Text.Derp

-- | Represents both a formal context-free language and the reduction of a
--   member of that language to a value of type <tt>a</tt>.
data Parser t a
data Token t
Token :: t -> String -> Token t
tokenClass :: Token t -> t
tokenValue :: Token t -> String

-- | Alternation.
(<|>) :: (Ord t, Ord a) => Parser t a -> Parser t a -> Parser t a

-- | Concatenation.
(<~>) :: (Ord t, Ord a, Ord b) => Parser t a -> Parser t b -> Parser t (a, b)

-- | Reduction.
(==>) :: (Ord t, Ord a, Ord b) => Parser t a -> (a -> b) -> Parser t b

-- | Null-parse extraction.
nul :: (Ord t, Ord a) => Parser t a -> Parser t a

-- | Terminal.
ter :: Ord t => t -> Parser t String

-- | Epsilon/empty-string.
eps :: (Ord t, Ord a) => a -> Parser t a

-- | The empty language.
emp :: (Ord t, Ord a) => Parser t a

-- | The main derivative function.
derive :: Parser t a -> Token t -> Parser t a

-- | The optimization step of the algorithm.
compact :: Parser t a -> Parser t a

-- | Extract the parse-null set of a parser.
parseNull :: (Ord t, Ord a) => Parser t a -> Set a

-- | The number of compact steps that usually keeps a parser constant in
--   size while parsing.
defaultCompactSteps :: Int

-- | A specified number of compactions.
compactNum :: Int -> Parser t a -> Parser t a

-- | Derivation followed by a specified number of compactions.
deriveStepNum :: Int -> Parser t a -> Token t -> Parser t a

-- | Parse using a specified number of intermediate compactions.
runParseNum :: (Ord t, Ord a) => Int -> Parser t a -> [Token t] -> Set a
runParseStagesNum :: (Ord t, Ord a) => Int -> Parser t a -> [Token t] -> [(Parser t a, Set a, [Token t])]
runParseStages :: (Ord t, Ord a) => Parser t a -> [Token t] -> [(Parser t a, Set a, [Token t])]
runParseLongestMatchNum :: (Ord t, Ord a) => Int -> Parser t a -> [Token t] -> Maybe (Int, Set a, [Token t])
runParseLongestMatch :: (Ord t, Ord a) => Parser t a -> [Token t] -> Maybe (Int, Set a, [Token t])

-- | Derivation followed by the default number of compactions.
deriveStep :: Parser t a -> Token t -> Parser t a

-- | Parse using the default number of intermediate compactions. This is
--   the main parsing function. Examples:
--   
--   <pre>
--   let e =     ter "num"
--           &lt;|&gt; e &lt;~&gt; ter "+" &lt;~&gt; e ==&gt; (\(x1,(o,x2)) -&gt; "(" ++ x1 ++ o ++ x2 ++ ")")
--   in runParse e [Token "num" "1", Token "+" "+", Token "num" 3", Token "+" "+", Token "num" "5"]
--   </pre>
--   
--   evaluates to:
--   
--   <pre>
--   Set.fromList ["((1+3)+5)", "(1+(3+5))"]
--   </pre>
--   
--   <pre>
--   let e =     ter "num" ==&gt; read 
--           &lt;|&gt; e &lt;~&gt; ter "+" &lt;~&gt; e ==&gt; (\(x1,(_,x2)) -&gt; x1 + x2)
--   in runParse e [Token "num" "1", Token "+" "+", Token "num" 3", Token "+" "+", Token "num" "5"]
--   </pre>
--   
--   evaluates to:
--   
--   <pre>
--   Set.fromList [9]
--   </pre>
runParse :: (Ord t, Ord a) => Parser t a -> [Token t] -> Set a
xsR :: () -> Parser String String
xsL :: () -> Parser String String
xsIn :: [Token String]
parens :: () -> Parser String String
parensIn :: [Token String]
amb :: () -> Parser String String
ambIn :: [Token String]
sexp :: () -> Parser String String
sexpIn :: [Token String]
someStuff :: [Token String]
someStuffG :: () -> Parser String String
instance Eq t => Eq (Token t)
instance Ord t => Ord (Token t)
instance Show t => Show (Token t)
instance Eq ParserRecType
instance Ord ParserRecType
instance Show ParserRecType
instance Eq a => Eq (FPValue a)
instance Ord a => Ord (FPValue a)
instance Show a => Show (FPValue a)
instance Show (Parser t a)
