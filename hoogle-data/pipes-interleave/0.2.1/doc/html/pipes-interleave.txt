-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Interleave and merge streams of elements
--   
--   Interleave and merge streams of elements
@package pipes-interleave
@version 0.2.1

module Pipes.Interleave

-- | Interleave elements from a set of <tt>Producers</tt> such that the
--   interleaved stream is increasing with respect to the given ordering.
--   
--   <pre>
--   &gt;&gt;&gt; toList $ interleave compare [each [1,3..10], each [1,5..20]]
--   [1,1,3,5,5,7,9,9,13,17]
--   </pre>
interleave :: Monad m => (a -> a -> Ordering) -> [Producer a m ()] -> Producer a m ()

-- | Given a stream of increasing elements, combine those equal under the
--   given equality relation
--   
--   <pre>
--   &gt;&gt;&gt; let append (k,v) (_,v') = return (k, v+v')
--   
--   &gt;&gt;&gt; toList $ combine ((==) `on` fst) append (each [(1,1), (1,4), (2,3), (3,10)])
--   [(1,5),(2,3),(3,10)]
--   </pre>
combine :: Monad m => (a -> a -> Bool) -> (a -> a -> a) -> Producer a m r -> Producer a m r

-- | <a>combine</a> with monadic side-effects in combine operation.
combineM :: Monad m => (a -> a -> Bool) -> (a -> a -> m a) -> Producer a m r -> Producer a m r

-- | Equivalent to <a>combine</a> composed with <a>interleave</a>
--   
--   <pre>
--   &gt;&gt;&gt; let append (k,v) (_,v') = return (k, v+v')
--   
--   &gt;&gt;&gt; let producers = [ each [(i,2) | i &lt;- [1,3..10]], each [(i,10) | i &lt;- [1,5..20]] ] :: [Producer (Int,Int) Identity ()]
--   
--   &gt;&gt;&gt; toList $ merge (compare `on` fst) append producers
--   [(1,12),(3,2),(5,12),(7,2),(9,12),(13,10),(17,10)]
--   </pre>
merge :: Monad m => (a -> a -> Ordering) -> (a -> a -> a) -> [Producer a m ()] -> Producer a m ()

-- | Merge with monadic side-effects in combine operation.
mergeM :: Monad m => (a -> a -> Ordering) -> (a -> a -> m a) -> [Producer a m ()] -> Producer a m ()

-- | Split stream into groups of equal elements. Note that this is a
--   non-local operation: if the <a>Producer</a> generates a large run of
--   equal elements, all of them will remain in memory until the run ends.
--   
--   <pre>
--   &gt;&gt;&gt; toList $ groupBy ((==) `on` fst) (each [(1,1), (1,4), (2,3), (3,10)])
--   [[(1,1),(1,4)],[(2,3)],[(3,10)]]
--   </pre>
groupBy :: Monad m => (a -> a -> Bool) -> Producer a m r -> Producer [a] m r
