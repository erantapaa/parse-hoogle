-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | OpenGL interface for interactive port graph rewriting
--   
--   Once a graph rewriting system has been specified using the
--   <tt>graph-rewriting</tt> library this package can be used to create an
--   application that allows to experiment with this system by
--   interactively applying the rewrite rules. The usage of the interface
--   is the same for all applications. In the center you will see the
--   graph. It might be moving around which is due the force-directed
--   layouting. On the top-left corner you will find a menu with the
--   individual rewriting rules of the rewriting system. The controls are
--   described in the <a>GraphRewriting.GL.UI</a> module.
@package graph-rewriting-gl
@version 0.7.5

module GraphRewriting.GL.Render

-- | Here the OpenGL code for rendering a node can be given. The node-size
--   is expected to be roughly 2 (radius 1) but this is not a requirement.
class Render a
render :: Render a => a -> IO ()
convertDouble :: Double -> GLdouble
convertGLdouble :: GLdouble -> Double
vector :: Vector2 -> Vector3 GLdouble
vertex :: Vector2 -> IO ()
vector2 :: (Double, Double) -> Vector3 GLdouble
vertex2 :: (Double, Double) -> IO ()
renderString :: String -> IO ()


-- | This module provides an easy-to-use interface to create an
--   interactive, graphical front-end for you graph rewriting system. The
--   controls of the GUI are as follows:
--   
--   <ul>
--   <li>Left-click on a menu entry to <i>select</i> a rewriting rule. At
--   all times all redexes with respect to the selected rule are marked red
--   in the graph. Note that the menu is hierarchical, which means that
--   selecting a rule that has subordinate entries has the effect of all
--   these entries being selected.</li>
--   <li>Right-click on a menu entry to apply the corresponding rule at
--   every applicable position in the graph simultaneously (in no
--   particular order). Redexes that are destroyed (or created) by prior
--   contractions in this process are not reduced, thus if single
--   applications of the rule terminate, so does its simultaneous
--   application. Right-clicking does <i>not</i> select the rule.</li>
--   <li>Right-click on a node of the graph to apply the selected rewriting
--   rule at that position. You know before whether it is a applicable,
--   since all redexes in the graph with respect to the selected rule are
--   marked red. Right-clicking on a non-redexs node has no effect. The
--   layouting stops while the right mouse-button is pressed.</li>
--   <li>Drag the background of the canvas to scroll around.</li>
--   <li>Drag individual nodes of the graph around to manually change the
--   layouting of the graph.</li>
--   <li>Use your mouse-wheel to zoom in/out. Make sure to keep the mouse
--   curser in the canvas area and not the menu while zooming.</li>
--   <li>Press space to pause/resume layouting. Currently layouting is
--   automatically resumed when the graph is rewritten by right-clicking on
--   an individual node and not when right-clicking on a menu entry. This
--   also requires the mouse cursor to be positioned in the canvas
--   area.</li>
--   </ul>
--   
--   Please have a look the graph-rewriting-ski package for an example
--   application that makes use of this library.
module GraphRewriting.GL.UI

-- | Initialises GLUT. Returns program name and command line arguments.
initialise :: IO (String, [String])
run :: (View Position n, Render n', View Position n', View Rotation n', PortSpec n', View [Port] n') => Int -> (Graph n -> Graph n') -> (Node -> Rewrite n a) -> Graph n -> LabelledTree (Rule n) -> IO ()
data LabelledTree a
Branch :: String -> [LabelledTree a] -> LabelledTree a
Leaf :: String -> a -> LabelledTree a
showLabelledTree :: Show a => Int -> a -> (a -> a -> a) -> LabelledTree a -> String
