-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | For testing partial and infinite values.
--   
@package ChasingBottoms
@version 1.3.0.13


-- | A simple implementation of natural numbers on top of <a>Integer</a>s.
--   Note that since <a>Integer</a>s are used there is no infinite natural
--   number; in other words, <a>succ</a> is strict.
module Test.ChasingBottoms.Nat

-- | Natural numbers.
--   
--   No <a>Data</a> instance is provided, because the implementation should
--   be abstract.
data Nat

-- | <tt><a>isSucc</a> 0 == <a>False</a></tt>, for other total natural
--   numbers it is <a>True</a>.
isSucc :: Nat -> Bool

-- | <tt><a>fromSucc</a> 0 == <a>Nothing</a></tt>, <tt><a>fromSucc</a>
--   (n+1) == <a>Just</a> n</tt> for a total natural number <tt>n</tt>.
fromSucc :: Nat -> Maybe Nat

-- | <a>natrec</a> performs primitive recursion on natural numbers.
natrec :: a -> (Nat -> a -> a) -> Nat -> a

-- | <a>foldN</a> is a fold on natural numbers:
--   
--   <pre>
--   <a>foldN</a> g h = <a>natrec</a> g (<a>curry</a> <a>$</a> h . <a>snd</a>)
--   </pre>
foldN :: a -> (a -> a) -> Nat -> a
instance Typeable Nat
instance Eq Nat
instance Ord Nat
instance CoArbitrary Nat
instance Arbitrary Nat
instance Show Nat
instance Enum Nat
instance Integral Nat
instance Real Nat
instance Num Nat


-- | When dealing with "hard bottoms", i.e. non-terminating computations
--   that do not result in exceptions, the following functions may be
--   handy.
--   
--   Note that a computation is considered to have terminated when it has
--   reached weak head normal form (i.e. something distinct from bottom).
module Test.ChasingBottoms.TimeOut
data Result a
Value :: a -> Result a
NonTermination :: Result a
Exception :: SomeException -> Result a

-- | <tt><a>timeOut</a> n c</tt> runs <tt>c</tt> for at most <tt>n</tt>
--   seconds (modulo scheduling issues).
--   
--   <ul>
--   <li>If the computation terminates before that, then <tt><a>Value</a>
--   v</tt> is returned, where <tt>v</tt> is the resulting value. Note that
--   this value may be equal to bottom, e.g. if <tt>c = <a>return</a>
--   <a>bottom</a></tt>.</li>
--   <li>If the computation does not terminate, then <a>NonTermination</a>
--   is returned.</li>
--   <li>If the computation raises an exception, then <tt><a>Exception</a>
--   e</tt> is returned, where <tt>e</tt> is the exception.</li>
--   </ul>
--   
--   Note that a user-defined exception is used to terminate the
--   computation, so if <tt>c</tt> catches all exceptions, or blocks
--   asynchronous exceptions, then <a>timeOut</a> may fail to function
--   properly.
timeOut :: Int -> IO a -> IO (Result a)

-- | <a>timeOut'</a> is a variant which can be used for pure computations.
--   The definition,
--   
--   <pre>
--   <a>timeOut'</a> n = <a>timeOut</a> n . <a>evaluate</a>
--   </pre>
--   
--   ensures that <tt><a>timeOut'</a> 1 <a>bottom</a></tt> usually returns
--   <tt><a>Exception</a> &lt;something&gt;</tt>. (<tt><a>timeOut</a> 1
--   (<a>return</a> <a>bottom</a>)</tt> usually returns <tt><a>Value</a>
--   <a>bottom</a></tt>; in other words, the computation reaches whnf
--   almost immediately, defeating the purpose of the time-out.)
timeOut' :: Int -> a -> IO (Result a)

-- | <a>timeOutMicro</a> takes a delay in microseconds. Note that the
--   resolution is not necessarily very high (the last time I checked it
--   was 0.02 seconds when using the standard runtime system settings for
--   GHC).
timeOutMicro :: Int -> IO a -> IO (Result a)

-- | <a>timeOutMicro'</a> is the equivalent variant of <a>timeOutMicro</a>:
--   
--   <pre>
--   <a>timeOutMicro'</a> n = <a>timeOutMicro</a> n . <a>evaluate</a>
--   </pre>
timeOutMicro' :: Int -> a -> IO (Result a)
instance Typeable Result
instance Typeable Die
instance Show a => Show (Result a)
instance Show Die
instance Exception Die


module Test.ChasingBottoms.IsBottom

-- | <tt><a>isBottom</a> a</tt> returns <a>False</a> if <tt>a</tt> is
--   distinct from bottom. If <tt>a</tt> equals bottom and results in an
--   exception of a certain kind (see below), then <tt><a>isBottom</a> a =
--   <a>True</a></tt>. If <tt>a</tt> never reaches a weak head normal form
--   and never throws one of these exceptions, then <tt><a>isBottom</a>
--   a</tt> never terminates.
--   
--   The exceptions that yield <a>True</a> correspond to "pure bottoms",
--   i.e. bottoms that can originate in pure code:
--   
--   <ul>
--   <li><a>ArrayException</a></li>
--   <li><a>ErrorCall</a></li>
--   <li><a>NoMethodError</a></li>
--   <li><a>NonTermination</a></li>
--   <li><a>PatternMatchFail</a></li>
--   <li><a>RecConError</a></li>
--   <li><a>RecSelError</a></li>
--   <li><a>RecUpdError</a></li>
--   </ul>
--   
--   Assertions are excluded, because their behaviour depends on compiler
--   flags (not pure, and a failed assertion should really yield an
--   exception and nothing else). The same applies to arithmetic exceptions
--   (machine dependent, except possibly for <a>DivideByZero</a>, but the
--   value infinity makes that case unclear as well).
isBottom :: a -> Bool

-- | <a>bottom</a> generates a bottom that is suitable for testing using
--   <a>isBottom</a>.
bottom :: a

-- | <tt><a>nonBottomError</a> s</tt> raises an exception
--   (<a>AssertionFailed</a>) that is not caught by <a>isBottom</a>. Use
--   <tt>s</tt> to describe the exception.
nonBottomError :: String -> a

-- | <tt><a>isBottomTimeOut</a> timeOutLimit</tt> works like
--   <a>isBottom</a>, but if <tt>timeOutLimit</tt> is <tt><a>Just</a>
--   lim</tt>, then computations taking more than <tt>lim</tt> seconds are
--   also considered to be equal to bottom. Note that this is a very crude
--   approximation of what a bottom is. Also note that this "function" may
--   return different answers upon different invocations. Take it for what
--   it is worth.
--   
--   <a>isBottomTimeOut</a> is subject to all the same vagaries as
--   <a>timeOut</a>.
isBottomTimeOut :: Maybe Int -> a -> Bool


-- | Functions for converting arbitrary (non-function, partial, possibly
--   infinite) values into strings.
module Test.ChasingBottoms.ApproxShow

-- | Precedence level.
type Prec = Int
class ApproxShow a where approxShows n a = approxShowsPrec n 0 a approxShow n a = approxShowsPrec n 0 a ""
approxShowsPrec :: ApproxShow a => Nat -> Prec -> a -> ShowS
approxShows :: ApproxShow a => Nat -> a -> ShowS
approxShow :: ApproxShow a => Nat -> a -> String
instance Data a => ApproxShow a


module Test.ChasingBottoms.Approx

-- | <a>Approx</a> is a class for approximation functions as described in
--   The generic approximation lemma, Graham Hutton and Jeremy Gibbons,
--   Information Processing Letters, 79(4):197-201, Elsevier Science,
--   August 2001, <a>http://www.cs.nott.ac.uk/~gmh/bib.html</a>.
--   
--   Instances are provided for all members of the <a>Data</a> type class.
--   Due to the limitations of the <a>Data.Generics</a> approach to generic
--   programming, which is not really aimed at this kind of application,
--   the implementation is only guaranteed to perform correctly, with
--   respect to the paper (and modulo any bugs), on non-mutually-recursive
--   sum-of-products datatypes. In particular, nested and mutually
--   recursive types are not handled correctly with respect to the paper.
--   The specification below is correct, though (if we assume that the
--   <a>Data</a> instances are well-behaved).
--   
--   In practice the <a>approxAll</a> function can probably be more useful
--   than <a>approx</a>. It traverses down <i>all</i> subterms, and it
--   should be possible to prove a variant of the approximation lemma which
--   <a>approxAll</a> satisfies.
class Approx a
approxAll :: Approx a => Nat -> a -> a
approx :: Approx a => Nat -> a -> a
instance Data a => Approx a


-- | Generic semantic equality and order. The semantic order referred to is
--   that of a typical CPO for Haskell types, where e.g. <tt>(<a>True</a>,
--   <a>bottom</a>) <a>&lt;=!</a> (<a>True</a>, <a>False</a>)</tt>, but
--   where <tt>(<a>True</a>, <a>True</a>)</tt> and <tt>(<a>True</a>,
--   <a>False</a>)</tt> are incomparable.
--   
--   The implementation is based on <a>isBottom</a>, and has the same
--   limitations. Note that non-bottom functions are not handled by any of
--   the functions described below.
--   
--   One could imagine using QuickCheck for testing equality of functions,
--   but I have not managed to tweak the type system so that it can be done
--   transparently.
module Test.ChasingBottoms.SemanticOrd

-- | The behaviour of some of the functions below can be tweaked.
data Tweak
Tweak :: Maybe Nat -> Maybe Int -> Tweak

-- | If equal to <tt><a>Just</a> n</tt>, an <tt><a>approxAll</a> n</tt> is
--   performed on all arguments before doing whatever the function is
--   supposed to be doing.
approxDepth :: Tweak -> Maybe Nat

-- | If equal to <tt><a>Just</a> n</tt>, then all computations that take
--   more than <tt>n</tt> seconds to complete are considered to be equal to
--   <a>bottom</a>. This functionality is implemented using
--   <a>isBottomTimeOut</a>.
timeOutLimit :: Tweak -> Maybe Int

-- | No tweak (both fields are <a>Nothing</a>).
noTweak :: Tweak

-- | <a>SemanticEq</a> contains methods for testing whether two terms are
--   semantically equal.
class SemanticEq a where (/=!) = \ x y -> not (x ==! y) (==!) = semanticEq noTweak
(==!, /=!) :: SemanticEq a => a -> a -> Bool
semanticEq :: SemanticEq a => Tweak -> a -> a -> Bool

-- | <a>SemanticOrd</a> contains methods for testing whether two terms are
--   related according to the semantic domain ordering.
class SemanticEq a => SemanticOrd a where (>=!) = flip (<=!) (<!) = \ x y -> x <=! y && x /=! y (>!) = \ x y -> x >=! y && x /=! y x <=! y = case semanticCompare noTweak x y of { Just LT -> True Just EQ -> True _ -> False } (\/!) = semanticJoin noTweak (/\!) = semanticMeet noTweak
(<!, >!, >=!, <=!) :: SemanticOrd a => a -> a -> Bool
semanticCompare :: SemanticOrd a => Tweak -> a -> a -> Maybe Ordering
(\/!) :: SemanticOrd a => a -> a -> Maybe a
(/\!) :: SemanticOrd a => a -> a -> a
semanticJoin :: SemanticOrd a => Tweak -> a -> a -> Maybe a
semanticMeet :: SemanticOrd a => Tweak -> a -> a -> a
instance Eq Tweak
instance Ord Tweak
instance Show Tweak
instance Data a => SemanticOrd a
instance Data a => SemanticEq a


-- | Note: <i>This module is unfinished and experimental. However, I do not
--   think that I will ever finish it, so I have released it in its current
--   state. The documentation below may not be completely correct. The
--   source code lists some things which should be addressed.</i>
--   
--   A framework for generating possibly non-strict, partial, continuous
--   functions.
--   
--   The functions generated using the standard QuickCheck <a>Arbitrary</a>
--   instances are all strict. In the presence of partial and infinite
--   values testing using only strict functions leads to worse coverage
--   than if more general functions are used, though.
--   
--   Using <a>isBottom</a> it is relatively easy to generate possibly
--   non-strict functions that are, in general, not monotone. For instance,
--   using
--   
--   <pre>
--   type Cogen a = forall b. a -&gt; Gen b -&gt; Gen b
--   
--   integer :: Gen Integer
--   integer = frequency [ (1, return bottom), (10, arbitrary) ]
--   
--   coBool :: CoGen Bool
--   coBool b | isBottom b = variant 0
--   coBool False          = variant 1
--   coBool True           = variant 2
--   
--   function :: Cogen a -&gt; Gen b -&gt; Gen (a -&gt; b)
--   function coGen gen = promote (\a -&gt; coGen a gen)
--   </pre>
--   
--   we can generate possibly non-strict functions from <a>Bool</a> to
--   <a>Integer</a> using <tt>function coBool integer</tt>. There is a high
--   likelihood that the functions generated are not monotone, though. The
--   reason that we can get non-monotone functions in a language like
--   Haskell is that we are using the impure function <a>isBottom</a>.
--   
--   Sometimes using possibly non-monotone functions is good enough, since
--   that set of functions is a superset of the continuous functions.
--   However, say that we want to test that <tt>x <a>&lt;=!</a> y</tt>
--   implies that <tt>f x <a>&lt;=!</a> f y</tt> for all functions
--   <tt>f</tt> (whenever the latter expression returns a total result).
--   This property is not valid in the presence of non-monotone functions.
--   
--   By avoiding <a>isBottom</a> and, unlike the standard
--   <a>coarbitrary</a> functions, deferring some pattern matches, we can
--   generate continuous, possibly non-strict functions. There are two
--   steps involved in generating a continuous function using the framework
--   defined here.
--   
--   <ol>
--   <li>First the argument to the function is turned into a
--   <a>PatternMatch</a>. A <a>PatternMatch</a> wraps up the pattern match
--   on the top-level constructor of the argument, plus all further pattern
--   matches on the children of the argument. Just like when
--   <a>coarbitrary</a> is used a pattern match is represented as a
--   generator transformer. The difference here is that there is not just
--   one transformation per input, but one transformation per constructor
--   in the input. <a>PatternMatch</a>es can be constructed generically
--   using <a>match</a>.</li>
--   <li>Then the result is generated, almost like for a normal
--   <a>Arbitrary</a> instance. However, for each constructor generated a
--   subset of the transformations from step 1 are applied. This
--   transformation application is wrapped up in the function
--   <a>transform</a>.</li>
--   </ol>
--   
--   The net result of this is that some pattern matches are performed
--   later, or not at all, so functions can be lazy.
--   
--   Here is an example illustrating typical use of this framework:
--   
--   <pre>
--   data Tree a
--     = Branch (Tree a) (Tree a)
--     | Leaf a
--       deriving (Show, Typeable, Data)
--   
--   finiteTreeOf :: MakeResult a -&gt; MakeResult (Tree a)
--   finiteTreeOf makeResult = sized' tree
--     where
--     tree size = transform $
--       if size == 0 then
--         baseCase
--        else
--         frequency' [ (1, baseCase)
--                    , (1, liftM2 Branch tree' tree')
--                    ]
--       where
--       tree' = tree (size `div` 2)
--   
--       baseCase =
--         frequency' [ (1, return bottom)
--                    , (2, liftM Leaf makeResult)
--                    ]
--   </pre>
--   
--   Note the use of <a>transform</a>. To use this function to generate
--   functions of type <tt>Bool -&gt; Tree Integer</tt> we can use
--   
--   <pre>
--   forAll (functionTo (finiteTreeOf flat)) $
--     \(f :: Bool -&gt; Tree Integer) -&gt;
--       ...
--   </pre>
module Test.ChasingBottoms.ContinuousFunctions

-- | Generator for continuous, not necessarily strict functions. Functions
--   are generated by first generating pattern matches, and then generating
--   a result.
function :: MakePM a -> MakeResult b -> Gen (a -> b)

-- | <a>functionTo</a> specialises <a>function</a>:
--   
--   <pre>
--   <a>functionTo</a> = <a>function</a> <a>match</a>
--   </pre>
functionTo :: Data a => MakeResult b -> Gen (a -> b)

-- | <a>PatternMatch</a> packages up the possible outcomes of a pattern
--   match in a style suitable for generating functions. A pattern match is
--   a generator (<a>Gen</a>) transformer based on the top-level
--   constructor, and a sequence (see
--   <a>http://www.soi.city.ac.uk/~ross/software/html/Data.Sequence.html</a>)
--   of <a>PatternMatch</a>es based on the children of that constructor.
data PatternMatch
PatternMatch :: GenTransformer -> Seq PatternMatch -> PatternMatch

-- | A generator transformer, in the style of <a>coarbitrary</a>.
apply :: PatternMatch -> GenTransformer

-- | Further pattern matches made possible by this match.
more :: PatternMatch -> Seq PatternMatch

-- | The type of a generator transformer.
type GenTransformer = forall a. Gen a -> Gen a

-- | The type of a <a>PatternMatch</a> generator.
type MakePM a = a -> PatternMatch

-- | Monad for generating results given previously generated pattern
--   matches.
--   
--   A <tt><a>MakeResult</a> a</tt> should be implemented almost as other
--   generators for the type <tt>a</tt>, with the difference that
--   <a>transform</a> should be used wherever the resulting function should
--   be allowed to pattern match (typically for each constructor emitted).
--   See example above.
data MakeResult a

-- | <a>transform</a> makes sure that the pattern matches get to influence
--   the generated value. See <a>MakeResult</a>.
transform :: MakeResult a -> MakeResult a

-- | Lifting of a <a>Gen</a>.
lift' :: Gen a -> MakeResult a

-- | Lifting of <a>arbitrary</a>.
arbitrary' :: Arbitrary a => MakeResult a

-- | Lifting of <a>choose</a>.
choose' :: Random a => (a, a) -> MakeResult a

-- | Lifting of <a>elements</a>.
elements' :: [a] -> MakeResult a

-- | Lifting of <a>oneof</a>.
oneof' :: [MakeResult a] -> MakeResult a

-- | Lifting of <a>frequency</a>.
frequency' :: [(Int, MakeResult a)] -> MakeResult a

-- | Lifting of <a>sized</a>.
sized' :: (Int -> MakeResult a) -> MakeResult a

-- | Lifting of <a>resize</a>.
resize' :: Int -> MakeResult a -> MakeResult a

-- | Generic implementation of <a>PatternMatch</a> construction.
match :: Data a => MakePM a

-- | An implementation of <tt><a>MakeResult</a> a</tt> which is suitable
--   when <tt>a</tt> is flat and has an <a>Arbitrary</a> instance. Yields
--   bottoms around 10% of the time.
flat :: Arbitrary a => MakeResult a

-- | This <a>MakeResult</a> yields finite partial lists.
finiteListOf :: MakeResult a -> MakeResult [a]

-- | This <a>MakeResult</a> yields infinite partial lists.
infiniteListOf :: MakeResult a -> MakeResult [a]

-- | This <a>MakeResult</a> yields finite or infinite partial lists.
listOf :: MakeResult a -> MakeResult [a]
instance Typeable Tree
instance Show a => Show (Tree a)
instance Data a => Data (Tree a)
instance Functor MakeResult
instance Applicative MakeResult
instance Monad MakeResult


-- | This module just re-exports all the other modules.
module Test.ChasingBottoms
