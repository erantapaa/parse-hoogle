-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Used to be Haskell 98 Lenses
--   
@package data-lens
@version 2.10.7

module Control.Category.Product
class Category c => Tensor c where first = (*** id) second = (id ***)
(***) :: Tensor c => c w x -> c y z -> c (w, y) (x, z)
first :: Tensor c => c w x -> c (w, z) (x, z)
second :: Tensor c => c y z -> c (w, y) (w, z)
instance Tensor (->)

module Data.Lens.Common
newtype Lens a b
Lens :: (a -> Store b a) -> Lens a b
runLens :: Lens a b -> a -> Store b a

-- | build a lens out of a getter and setter
lens :: (a -> b) -> (b -> a -> a) -> Lens a b

-- | build a lens out of an isomorphism
iso :: (a -> b) -> (b -> a) -> Lens a b

-- | Gets the getter function from a lens.
getL :: Lens a b -> a -> b

-- | Gets the setter function from a lens.
setL :: Lens a b -> b -> a -> a

-- | Gets the modifier function from a lens.
modL :: Lens a b -> (b -> b) -> a -> a
mergeL :: Lens a c -> Lens b c -> Lens (Either a b) c
(^$) :: Lens a b -> a -> b
(^$!) :: Lens a b -> a -> b

-- | functional getter, which acts like a field accessor
(^.) :: a -> Lens a b -> b

-- | functional getter, which acts like a field accessor
(^!) :: a -> Lens a b -> b
(^=) :: Lens a b -> b -> a -> a
(^!=) :: Lens a b -> b -> a -> a

-- | functional modify
(^%=) :: Lens a b -> (b -> b) -> a -> a

-- | functional modify
(^!%=) :: Lens a b -> (b -> b) -> a -> a

-- | functorial modify
(^%%=) :: Functor f => Lens a b -> (b -> f b) -> a -> f a
(^+=) :: Num b => Lens a b -> b -> a -> a
(^!+=) :: Num b => Lens a b -> b -> a -> a
(^-=) :: Num b => Lens a b -> b -> a -> a
(^!-=) :: Num b => Lens a b -> b -> a -> a
(^*=) :: Num b => Lens a b -> b -> a -> a
(^!*=) :: Num b => Lens a b -> b -> a -> a
(^/=) :: Fractional b => Lens a b -> b -> a -> a
(^!/=) :: Fractional b => Lens a b -> b -> a -> a
fstLens :: Lens (a, b) a
sndLens :: Lens (a, b) b
mapLens :: Ord k => k -> Lens (Map k v) (Maybe v)
intMapLens :: Int -> Lens (IntMap v) (Maybe v)
setLens :: Ord k => k -> Lens (Set k) Bool
intSetLens :: Int -> Lens IntSet Bool
instance Tensor Lens
instance Category Lens
instance Semigroupoid Lens

module Data.Lens.Lazy

-- | get the value of a lens into state
access :: Monad m => Lens a b -> StateT a m b

-- | set a value using a lens into state
(~=) :: Monad m => Lens a b -> b -> StateT a m b

-- | set a value using a lens into state
(!=) :: Monad m => Lens a b -> b -> StateT a m b

-- | infix modification a value through a lens into state
(%=) :: Monad m => Lens a b -> (b -> b) -> StateT a m b

-- | infix modification a value through a lens into state
(!%=) :: Monad m => Lens a b -> (b -> b) -> StateT a m b

-- | infix modification of a value through a lens into state with a
--   supplemental response
(%%=) :: Monad m => Lens a b -> (b -> (c, b)) -> StateT a m c

-- | infix modification of a value through a lens into state with a
--   supplemental response
(!%%=) :: Monad m => Lens a b -> (b -> (c, b)) -> StateT a m c
(+=) :: (Monad m, Num b) => Lens a b -> b -> StateT a m b
(!+=) :: (Monad m, Num b) => Lens a b -> b -> StateT a m b
(-=) :: (Monad m, Num b) => Lens a b -> b -> StateT a m b
(!-=) :: (Monad m, Num b) => Lens a b -> b -> StateT a m b
(*=) :: (Monad m, Num b) => Lens a b -> b -> StateT a m b
(!*=) :: (Monad m, Num b) => Lens a b -> b -> StateT a m b
(//=) :: (Monad m, Fractional b) => Lens a b -> b -> StateT a m b
(!/=) :: (Monad m, Fractional b) => Lens a b -> b -> StateT a m b
(&&=) :: Monad m => Lens a Bool -> Bool -> StateT a m Bool
(!&&=) :: Monad m => Lens a Bool -> Bool -> StateT a m Bool
(||=) :: Monad m => Lens a Bool -> Bool -> StateT a m Bool
(!||=) :: Monad m => Lens a Bool -> Bool -> StateT a m Bool
focus :: Monad m => Lens a b -> StateT b m c -> StateT a m c

module Data.Lens.Strict

-- | get the value of a lens into state
access :: Monad m => Lens a b -> StateT a m b

-- | set a value using a lens into state
(~=) :: Monad m => Lens a b -> b -> StateT a m b

-- | set a value using a lens into state
(!=) :: Monad m => Lens a b -> b -> StateT a m b

-- | infix modification a value through a lens into state
(%=) :: Monad m => Lens a b -> (b -> b) -> StateT a m b

-- | infix modification a value through a lens into state
(!%=) :: Monad m => Lens a b -> (b -> b) -> StateT a m b

-- | infix modification of a value through a lens into state with a
--   supplemental response
(%%=) :: Monad m => Lens a b -> (b -> (c, b)) -> StateT a m c

-- | infix modification of a value through a lens into state with a
--   supplemental response
(!%%=) :: Monad m => Lens a b -> (b -> (c, b)) -> StateT a m c
(+=) :: (Monad m, Num b) => Lens a b -> b -> StateT a m b
(!+=) :: (Monad m, Num b) => Lens a b -> b -> StateT a m b
(-=) :: (Monad m, Num b) => Lens a b -> b -> StateT a m b
(!-=) :: (Monad m, Num b) => Lens a b -> b -> StateT a m b
(*=) :: (Monad m, Num b) => Lens a b -> b -> StateT a m b
(!*=) :: (Monad m, Num b) => Lens a b -> b -> StateT a m b
(//=) :: (Monad m, Fractional b) => Lens a b -> b -> StateT a m b
(!/=) :: (Monad m, Fractional b) => Lens a b -> b -> StateT a m b
(&&=) :: Monad m => Lens a Bool -> Bool -> StateT a m Bool
(!&&=) :: Monad m => Lens a Bool -> Bool -> StateT a m Bool
(||=) :: Monad m => Lens a Bool -> Bool -> StateT a m Bool
(!||=) :: Monad m => Lens a Bool -> Bool -> StateT a m Bool
focus :: Monad m => Lens a b -> StateT b m c -> StateT a m c

module Data.Lens.Partial.Common
newtype PartialLens a b
PLens :: (a -> Maybe (Store b a)) -> PartialLens a b
runPLens :: PartialLens a b -> a -> (Coproduct Identity (Store b)) a
null :: PartialLens a b
totalLens :: Lens a b -> PartialLens a b
getPL :: PartialLens a b -> a -> Maybe b
getorPL :: PartialLens a b -> b -> a -> b
getorAPL :: Applicative f => PartialLens a b -> f b -> a -> f b
mergePL :: PartialLens a c -> PartialLens b c -> PartialLens (Either a b) c
nullPL :: PartialLens a b -> a -> Bool
getorEmptyPL :: Monoid o => PartialLens a b -> (b -> o) -> a -> o
sumPL :: Num c => PartialLens a b -> (b -> c) -> a -> c
productPL :: Num c => PartialLens a b -> (b -> c) -> a -> c
anyPL :: PartialLens a b -> (b -> Bool) -> a -> Bool
allPL :: PartialLens a b -> (b -> Bool) -> a -> Bool
trySetPL :: PartialLens a b -> a -> Maybe (b -> a)
setPL :: PartialLens a b -> b -> a -> a
modPL :: PartialLens a b -> (b -> b) -> a -> a
(^$) :: PartialLens a b -> a -> Maybe b
(^.) :: a -> PartialLens a b -> Maybe b
(^=) :: PartialLens a b -> b -> a -> a
(^%=) :: PartialLens a b -> (b -> b) -> a -> a

-- | applicative modify
(^%%=) :: Applicative f => PartialLens a b -> (b -> f b) -> a -> f a
(^+=) :: Num b => PartialLens a b -> b -> a -> a
(^*=) :: Num b => PartialLens a b -> b -> a -> a
(^-=) :: Num b => PartialLens a b -> b -> a -> a
(^/=) :: Fractional b => PartialLens a b -> b -> a -> a
justLens :: PartialLens (Maybe a) a
leftLens :: PartialLens (Either a b) a
rightLens :: PartialLens (Either a b) b
headLens :: PartialLens [a] a
tailLens :: PartialLens [a] [a]
instance Tensor PartialLens
instance Category PartialLens

module Data.Lens.Partial.Lazy
maybeZero :: MonadPlus m => Maybe a -> m a
joinMaybe :: MonadPlus m => m (Maybe a) -> m a

-- | get the value of a partial lens into state
access :: Monad m => PartialLens a b -> StateT a m (Maybe b)

-- | returns mzero in case of a null reference
accessPlus :: MonadPlus m => PartialLens a b -> StateT a m b

-- | set a value using a partial lens into state returns <a>Nothing</a> in
--   case of a null reference
(~=) :: Monad m => PartialLens a b -> b -> StateT a m (Maybe b)

-- | infix modification a value through a partial lens into state returns
--   <a>Nothing</a> in case of a null reference
(%=) :: Monad m => PartialLens a b -> (b -> b) -> StateT a m (Maybe b)

-- | infix modification of a value through a partial lens into state with a
--   supplemental response. returns <a>Nothing</a> in case of a null
--   reference
(%%=) :: Monad m => PartialLens a b -> (b -> (c, b)) -> StateT a m (Maybe c)
(+=) :: (Monad m, Num b) => PartialLens a b -> b -> StateT a m (Maybe b)
(*=) :: (Monad m, Num b) => PartialLens a b -> b -> StateT a m (Maybe b)
(-=) :: (Monad m, Num b) => PartialLens a b -> b -> StateT a m (Maybe b)
(//=) :: (Monad m, Fractional b) => PartialLens a b -> b -> StateT a m (Maybe b)
(&&=) :: Monad m => PartialLens a Bool -> Bool -> StateT a m (Maybe Bool)
(||=) :: Monad m => PartialLens a Bool -> Bool -> StateT a m (Maybe Bool)
