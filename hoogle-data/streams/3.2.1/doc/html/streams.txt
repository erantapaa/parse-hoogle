-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Various Haskell 2010 stream comonads
--   
@package streams
@version 3.2.1


-- | This is an infinite bidirectional zipper
module Data.Stream.Infinite.Functional.Zipper
data Zipper a
(:~) :: !Integer -> !(Integer -> a) -> Zipper a

-- | Move the head of the zipper to the right
tail :: Zipper a -> Zipper a

-- | Move the head of the zipper to the left
untail :: Zipper a -> Zipper a

-- | <tt><a>intersperse</a> y xs</tt> creates an alternating stream of
--   elements from <tt>xs</tt> and <tt>y</tt>.
intersperse :: a -> Zipper a -> Zipper a

-- | Interleave two Zippers <tt>xs</tt> and <tt>ys</tt>, alternating
--   elements from each list.
--   
--   <pre>
--   [x1,x2,...] `interleave` [y1,y2,...] == [x1,y1,x2,y2,...]
--   interleave = (&lt;&gt;)
--   </pre>
interleave :: Zipper a -> Zipper a -> Zipper a

-- | <a>transpose</a> computes the transposition of a stream of streams.
transpose :: Zipper (Zipper a) -> Zipper (Zipper a)
take :: Integer -> Zipper a -> [a]

-- | <tt><a>drop</a> n xs</tt> drops the first <tt>n</tt> elements off the
--   front of the sequence <tt>xs</tt>.
drop :: Integer -> Zipper a -> Zipper a

-- | <tt><a>splitAt</a> n xs</tt> returns a pair consisting of the prefix
--   of <tt>xs</tt> of length <tt>n</tt> and the remaining stream
--   immediately following this prefix.
--   
--   <i>Beware</i>: passing a negative integer as the first argument will
--   cause an error if you access the taken portion
splitAt :: Integer -> Zipper a -> ([a], Zipper a)

-- | <a>reverse</a> <tt>xs</tt> returns the elements of <tt>xs</tt> in
--   reverse order. <tt>xs</tt> must be finite.
reverse :: [a] -> [a]

-- | <tt>xs !! n</tt> returns the element of the stream <tt>xs</tt> at
--   index <tt>n</tt>. Note that the head of the stream has index 0.
(!!) :: Zipper a -> Integer -> a

-- | The <a>unzip</a> function is the inverse of the <a>zip</a> function.
unzip :: Zipper (a, b) -> (Zipper a, Zipper b)
toSequence :: (Integer -> a) -> Zipper a

-- | Extract the focused element
head :: Zipper a -> a

-- | Cons before the head of the zipper. The head now points to the new
--   element
(<|) :: a -> Zipper a -> Zipper a

-- | Move the head of the zipper one step to the right, returning the value
--   we move over.
uncons :: Zipper a -> (a, Zipper a)

-- | <tt><a>takeWhile</a> p xs</tt> returns the longest prefix of the
--   stream <tt>xs</tt> for which the predicate <tt>p</tt> holds.
takeWhile :: (a -> Bool) -> Zipper a -> [a]

-- | <tt><a>dropWhile</a> p xs</tt> returns the suffix remaining after
--   <tt><a>takeWhile</a> p xs</tt>.
--   
--   <i>Beware</i>: this function may diverge if every element of
--   <tt>xs</tt> satisfies <tt>p</tt>, e.g. <tt>dropWhile even (repeat
--   0)</tt> will loop.
dropWhile :: (a -> Bool) -> Zipper a -> Zipper a

-- | <tt><a>span</a> p xs</tt> returns the longest prefix of <tt>xs</tt>
--   that satisfies <tt>p</tt>, together with the remainder of the stream.
span :: (a -> Bool) -> Zipper a -> ([a], Zipper a)

-- | The <a>break</a> <tt>p</tt> function is equivalent to <a>span</a>
--   <tt>not . p</tt>.
break :: (a -> Bool) -> Zipper a -> ([a], Zipper a)

-- | The <tt>isPrefix</tt> function returns <tt>True</tt> if the first
--   argument is a prefix of the second.
isPrefixOf :: Eq a => [a] -> Zipper a -> Bool

-- | The <a>findIndex</a> function takes a predicate and a stream and
--   returns the index of the first element in the stream that satisfies
--   the predicate,
--   
--   <i>Beware</i>: <a>findIndex</a> <tt>p</tt> <tt>xs</tt> will diverge if
--   none of the elements of <tt>xs</tt> satisfy <tt>p</tt>.
findIndex :: (a -> Bool) -> Zipper a -> Integer

-- | The <a>elemIndex</a> function returns the index of the first element
--   in the given stream which is equal (by <a>==</a>) to the query
--   element,
--   
--   <i>Beware</i>: <tt><a>elemIndex</a> x xs</tt> will diverge if none of
--   the elements of <tt>xs</tt> equal <tt>x</tt>.
elemIndex :: Eq a => a -> Zipper a -> Integer

-- | The <a>zip</a> function takes two streams and returns a list of
--   corresponding pairs.
--   
--   <pre>
--   zip = liftA2 (,)
--   </pre>
zip :: Zipper a -> Zipper b -> Zipper (a, b)

-- | The <a>zipWith</a> function generalizes <a>zip</a>. Rather than
--   tupling the functions, the elements are combined using the function
--   passed as the first argument to <a>zipWith</a>.
--   
--   <pre>
--   zipWith = liftA2
--   </pre>
zipWith :: (a -> b -> c) -> Zipper a -> Zipper b -> Zipper c
instance Typeable Zipper
instance Semigroup (Zipper a)
instance Monad Zipper
instance Applicative Zipper
instance ComonadApply Zipper
instance Apply Zipper
instance Comonad Zipper
instance Extend Zipper
instance Functor Zipper


-- | Anticausal streams implemented as non-empty skew binary random access
--   lists
--   
--   The Applicative zips streams, the monad diagonalizes
module Data.Stream.Infinite.Skew
data Stream a

-- | <i>O(1)</i> cons
(<|) :: a -> Stream a -> Stream a

-- | <i>O(log n)</i>.
(!!) :: Stream a -> Integer -> a

-- | <i>O(1)</i>
head :: Stream a -> a

-- | <i>O(1)</i>.
tail :: Stream a -> Stream a
tails :: Stream a -> Stream (Stream a)

-- | <i>O(1)</i>.
uncons :: Stream a -> (a, Stream a)

-- | <i>O(log n)</i>.
drop :: Integer -> Stream a -> Stream a
dropWhile :: (a -> Bool) -> Stream a -> Stream a
span :: (a -> Bool) -> Stream a -> ([a], Stream a)
break :: (a -> Bool) -> Stream a -> ([a], Stream a)
split :: (a -> Bool) -> Stream a -> ([a], Stream a)
splitW :: (Stream a -> Bool) -> Stream a -> ([a], Stream a)
repeat :: a -> Stream a
insert :: Ord a => a -> Stream a -> Stream a
insertBy :: (a -> a -> Ordering) -> a -> Stream a -> Stream a
adjust :: Integer -> (a -> a) -> Stream a -> Stream a
update :: Integer -> a -> Stream a -> Stream a
fromList :: [a] -> Stream a
from :: Num a => a -> Stream a
indexed :: Stream a -> Stream (Integer, a)
interleave :: Stream a -> Stream a -> Stream a
instance Show a => Show (Complete a)
instance Monad Stream
instance Semigroup (Stream a)
instance Representable Stream
instance Distributive Stream
instance Traversable1 Stream
instance Traversable Stream
instance Foldable1 Stream
instance Foldable Stream
instance Alt Stream
instance Applicative Stream
instance ComonadApply Stream
instance Apply Stream
instance Comonad Stream
instance Extend Stream
instance Functor Stream
instance Show a => Show (Stream a)
instance Traversable1 Complete
instance Traversable Complete
instance Foldable1 Complete
instance Foldable Complete
instance Comonad Complete
instance Extend Complete
instance Functor Complete


module Data.Stream.Infinite
data Stream a
(:>) :: a -> Stream a -> Stream a

-- | Extract the first element of the sequence.
head :: Stream a -> a

-- | Extract the sequence following the head of the stream.
tail :: Stream a -> Stream a

-- | The <a>inits</a> function takes a stream <tt>xs</tt> and returns all
--   the finite prefixes of <tt>xs</tt>.
--   
--   Note that this <a>inits</a> is lazier then <tt>Data.List.inits</tt>:
--   
--   <pre>
--   inits _|_ = [] ::: _|_
--   </pre>
--   
--   while for <tt>Data.List.inits</tt>:
--   
--   <pre>
--   inits _|_ = _|_
--   </pre>
inits :: Stream a -> Stream [a]

-- | The <a>tails</a> function takes a stream <tt>xs</tt> and returns all
--   the suffixes of <tt>xs</tt>.
tails :: Stream a -> Stream (Stream a)

-- | Map a pure function over a stream
map :: (a -> b) -> Stream a -> Stream b

-- | <tt><a>intersperse</a> y xs</tt> creates an alternating stream of
--   elements from <tt>xs</tt> and <tt>y</tt>.
intersperse :: a -> Stream a -> Stream a

-- | Interleave two Streams <tt>xs</tt> and <tt>ys</tt>, alternating
--   elements from each list.
--   
--   <pre>
--   [x1,x2,...] `interleave` [y1,y2,...] == [x1,y1,x2,y2,...]
--   </pre>
interleave :: Stream a -> Stream a -> Stream a

-- | <a>scanl</a> yields a stream of successive reduced values from:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
scanl :: (a -> b -> a) -> a -> Stream b -> Stream a

-- | <a>scanl</a> yields a stream of successive reduced values from:
--   
--   <pre>
--   scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--   </pre>
scanl' :: (a -> b -> a) -> a -> Stream b -> Stream a

-- | <a>scanl1</a> is a variant of <a>scanl</a> that has no starting value
--   argument:
--   
--   <pre>
--   scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--   </pre>
scanl1 :: (a -> a -> a) -> Stream a -> Stream a

-- | <tt>scanl1'</tt> is a strict <a>scanl</a> that has no starting value.
scanl1' :: (a -> a -> a) -> Stream a -> Stream a

-- | <a>transpose</a> computes the transposition of a stream of streams.
transpose :: Stream (Stream a) -> Stream (Stream a)

-- | <tt><a>iterate</a> f x</tt> produces the infinite sequence of repeated
--   applications of <tt>f</tt> to <tt>x</tt>.
--   
--   <pre>
--   iterate f x = [x, f x, f (f x), ..]
--   </pre>
iterate :: (a -> a) -> a -> Stream a

-- | <a>repeat</a> <tt>x</tt> returns a constant stream, where all elements
--   are equal to <tt>x</tt>.
repeat :: a -> Stream a

-- | <tt><a>cycle</a> xs</tt> returns the infinite repetition of
--   <tt>xs</tt>:
--   
--   <pre>
--   cycle [1,2,3] = Cons 1 (Cons 2 (Cons 3 (Cons 1 (Cons 2 ...
--   </pre>
cycle :: NonEmpty a -> Stream a

-- | The unfold function is similar to the unfold for lists. Note there is
--   no base case: all streams must be infinite.
unfold :: (a -> (b, a)) -> a -> Stream b

-- | <tt><a>take</a> n xs</tt> returns the first <tt>n</tt> elements of
--   <tt>xs</tt>.
--   
--   <i>Beware</i>: passing a negative integer as the first argument will
--   cause an error.
take :: Int -> Stream a -> [a]

-- | <tt><a>drop</a> n xs</tt> drops the first <tt>n</tt> elements off the
--   front of the sequence <tt>xs</tt>.
--   
--   <i>Beware</i>: passing a negative integer as the first argument will
--   cause an error.
drop :: Int -> Stream a -> Stream a

-- | <tt><a>splitAt</a> n xs</tt> returns a pair consisting of the prefix
--   of <tt>xs</tt> of length <tt>n</tt> and the remaining stream
--   immediately following this prefix.
--   
--   <i>Beware</i>: passing a negative integer as the first argument will
--   cause an error.
splitAt :: Int -> Stream a -> ([a], Stream a)

-- | <tt><a>takeWhile</a> p xs</tt> returns the longest prefix of the
--   stream <tt>xs</tt> for which the predicate <tt>p</tt> holds.
takeWhile :: (a -> Bool) -> Stream a -> [a]

-- | <tt><a>dropWhile</a> p xs</tt> returns the suffix remaining after
--   <tt><a>takeWhile</a> p xs</tt>.
--   
--   <i>Beware</i>: this function may diverge if every element of
--   <tt>xs</tt> satisfies <tt>p</tt>, e.g. <tt>dropWhile even (repeat
--   0)</tt> will loop.
dropWhile :: (a -> Bool) -> Stream a -> Stream a

-- | <tt><a>span</a> p xs</tt> returns the longest prefix of <tt>xs</tt>
--   that satisfies <tt>p</tt>, together with the remainder of the stream.
span :: (a -> Bool) -> Stream a -> ([a], Stream a)

-- | The <a>break</a> <tt>p</tt> function is equivalent to <a>span</a>
--   <tt>not . p</tt>.
break :: (a -> Bool) -> Stream a -> ([a], Stream a)

-- | <tt><a>filter</a> p xs</tt>, removes any elements from <tt>xs</tt>
--   that do not satisfy <tt>p</tt>.
--   
--   <i>Beware</i>: this function may diverge if there is no element of
--   <tt>xs</tt> that satisfies <tt>p</tt>, e.g. <tt>filter odd (repeat
--   0)</tt> will loop.
filter :: (a -> Bool) -> Stream a -> Stream a

-- | The <a>partition</a> function takes a predicate <tt>p</tt> and a
--   stream <tt>xs</tt>, and returns a pair of streams. The first stream
--   corresponds to the elements of <tt>xs</tt> for which <tt>p</tt> holds;
--   the second stream corresponds to the elements of <tt>xs</tt> for which
--   <tt>p</tt> does not hold.
--   
--   <i>Beware</i>: One of the elements of the tuple may be undefined. For
--   example, <tt>fst (partition even (repeat 0)) == repeat 0</tt>; on the
--   other hand <tt>snd (partition even (repeat 0))</tt> is undefined.
partition :: (a -> Bool) -> Stream a -> (Stream a, Stream a)

-- | The <a>group</a> function takes a stream and returns a stream of lists
--   such that flattening the resulting stream is equal to the argument.
--   Moreover, each sublist in the resulting stream contains only equal
--   elements. For example,
--   
--   <pre>
--   group $ cycle "Mississippi" = "M" ::: "i" ::: "ss" ::: "i" ::: "ss" ::: "i" ::: "pp" ::: "i" ::: "M" ::: "i" ::: ...
--   </pre>
group :: Eq a => Stream a -> Stream (NonEmpty a)
groupBy :: (a -> a -> Bool) -> Stream a -> Stream (NonEmpty a)

-- | The <tt>isPrefix</tt> function returns <tt>True</tt> if the first
--   argument is a prefix of the second.
isPrefixOf :: Eq a => [a] -> Stream a -> Bool

-- | <tt>xs !! n</tt> returns the element of the stream <tt>xs</tt> at
--   index <tt>n</tt>. Note that the head of the stream has index 0.
--   
--   <i>Beware</i>: passing a negative integer as the first argument will
--   cause an error.
(!!) :: Stream a -> Int -> a

-- | The <a>elemIndex</a> function returns the index of the first element
--   in the given stream which is equal (by <a>==</a>) to the query
--   element,
--   
--   <i>Beware</i>: <tt><a>elemIndex</a> x xs</tt> will diverge if none of
--   the elements of <tt>xs</tt> equal <tt>x</tt>.
elemIndex :: Eq a => a -> Stream a -> Int

-- | The <a>elemIndices</a> function extends <a>elemIndex</a>, by returning
--   the indices of all elements equal to the query element, in ascending
--   order.
--   
--   <i>Beware</i>: <a>elemIndices</a> <tt>x</tt> <tt>xs</tt> will diverge
--   if any suffix of <tt>xs</tt> does not contain <tt>x</tt>.
elemIndices :: Eq a => a -> Stream a -> Stream Int

-- | The <a>findIndex</a> function takes a predicate and a stream and
--   returns the index of the first element in the stream that satisfies
--   the predicate,
--   
--   <i>Beware</i>: <a>findIndex</a> <tt>p</tt> <tt>xs</tt> will diverge if
--   none of the elements of <tt>xs</tt> satisfy <tt>p</tt>.
findIndex :: (a -> Bool) -> Stream a -> Int

-- | The <a>findIndices</a> function extends <a>findIndex</a>, by returning
--   the indices of all elements satisfying the predicate, in ascending
--   order.
--   
--   <i>Beware</i>: <a>findIndices</a> <tt>p</tt> <tt>xs</tt> will diverge
--   if all the elements of any suffix of <tt>xs</tt> fails to satisfy
--   <tt>p</tt>.
findIndices :: (a -> Bool) -> Stream a -> Stream Int

-- | The <a>zip</a> function takes two streams and returns a list of
--   corresponding pairs.
zip :: Stream a -> Stream b -> Stream (a, b)

-- | The <a>zipWith</a> function generalizes <a>zip</a>. Rather than
--   tupling the functions, the elements are combined using the function
--   passed as the first argument to <a>zipWith</a>.
zipWith :: (a -> b -> c) -> Stream a -> Stream b -> Stream c

-- | The <a>unzip</a> function is the inverse of the <a>zip</a> function.
unzip :: Stream (a, b) -> (Stream a, Stream b)

-- | The <a>words</a> function breaks a stream of characters into a stream
--   of words, which were delimited by white space.
--   
--   <i>Beware</i>: if the stream of characters <tt>xs</tt> does not
--   contain white space, accessing the tail of <tt>words xs</tt> will
--   loop.
words :: Stream Char -> Stream String

-- | The <a>unwords</a> function is an inverse operation to <a>words</a>.
--   It joins words with separating spaces.
unwords :: Stream String -> Stream Char

-- | The <a>lines</a> function breaks a stream of characters into a list of
--   strings at newline characters. The resulting strings do not contain
--   newlines.
--   
--   <i>Beware</i>: if the stream of characters <tt>xs</tt> does not
--   contain newline characters, accessing the tail of <tt>lines xs</tt>
--   will loop.
lines :: Stream Char -> Stream String

-- | The <a>unlines</a> function is an inverse operation to <a>lines</a>.
--   It joins lines, after appending a terminating newline to each.
unlines :: Stream String -> Stream Char

-- | The <a>fromList</a> converts an infinite list to a stream.
--   
--   <i>Beware</i>: Passing a finite list, will cause an error.
fromList :: [a] -> Stream a
instance Typeable Stream
instance Show a => Show (Stream a)
instance Data a => Data (Stream a)
instance Monad Stream
instance Traversable1 Stream
instance Foldable1 Stream
instance Traversable Stream
instance Foldable Stream
instance Applicative Stream
instance ComonadApply Stream
instance Apply Stream
instance Comonad Stream
instance Extend Stream
instance Representable Stream
instance Distributive Stream
instance Functor Stream


-- | This library can be used to generate values (for example, new names)
--   without the need to thread state. This means that functions that need
--   to generate new values only need a supply object as an argument, and
--   they do not need to return a new supply object as a result. This
--   decreases the number of data-dependencies in a program, which makes it
--   easier to exploit parallelism.
--   
--   The technique for generating new values is based on the paper ''On
--   Generating Unique Names'' by Lennart Augustsson, Mikael Rittri, and
--   Dan Synek.
module Data.Stream.Supply
data Supply a
newSupply :: (a -> a) -> a -> IO (Supply a)
newEnumSupply :: Enum a => IO (Supply a)
newNumSupply :: Num a => IO (Supply a)
newDupableSupply :: (a -> a) -> a -> IO (Supply a)
newDupableEnumSupply :: Enum a => IO (Supply a)
newDupableNumSupply :: Num a => IO (Supply a)
leftSupply :: Supply a -> Supply a
rightSupply :: Supply a -> Supply a
split :: Supply a -> Stream (Supply a)
splits :: Integral b => Supply a -> b -> Supply a
splitSkew :: Supply a -> Stream (Supply a)
split2 :: Supply a -> (Supply a, Supply a)
split3 :: Supply a -> (Supply a, Supply a, Supply a)
split4 :: Supply a -> (Supply a, Supply a, Supply a, Supply a)
instance Typeable Supply
instance Show a => Show (Supply a)
instance Read a => Read (Supply a)
instance Eq a => Eq (Supply a)
instance Ord a => Ord (Supply a)
instance Data a => Data (Supply a)
instance Traversable1 Supply
instance Traversable Supply
instance Foldable1 Supply
instance Foldable Supply
instance Applicative Supply
instance Apply Supply
instance Comonad Supply
instance Extend Supply
instance Functor Supply


-- | Anticausal streams implemented as non-empty skew binary random access
--   lists
--   
--   The Applicative zips streams, but since these are potentially infinite
--   this is stricter than would be desired. You almost always want
module Data.Stream.Future.Skew
data Future a
Last :: !(Complete a) -> Future a
(:<) :: !(Complete a) -> Future a -> Future a

-- | <i>O(1)</i> cons
(<|) :: a -> Future a -> Future a
cons :: a -> Future a -> Future a

-- | <i>O(log n)</i>.
length :: Future a -> Int

-- | <i>O(1)</i>
head :: Future a -> a

-- | <i>O(1)</i>.
tail :: Future a -> Maybe (Future a)
tails :: Future a -> Future (Future a)

-- | <i>O(log n)</i>.
last :: Future a -> a

-- | <i>O(1)</i>.
uncons :: Future a -> (a, Maybe (Future a))

-- | <i>O(log n)</i>.
index :: Int -> Future a -> a

-- | <i>O(log n)</i>.
drop :: Int -> Future a -> Maybe (Future a)
dropWhile :: (a -> Bool) -> Future a -> Maybe (Future a)
indexed :: Future a -> Future (Int, a)
from :: Num a => a -> Future a
break :: (a -> Bool) -> Future a -> ([a], Maybe (Future a))
span :: (a -> Bool) -> Future a -> ([a], Maybe (Future a))
split :: (a -> Bool) -> Future a -> ([a], Maybe (Future a))
splitW :: (Future a -> Bool) -> Future a -> ([a], Maybe (Future a))
repeat :: a -> Future a

-- | <i>O(log n)</i>
replicate :: Int -> a -> Future a
insert :: Ord a => a -> Future a -> Future a
insertBy :: (a -> a -> Ordering) -> a -> Future a -> Future a
update :: Int -> a -> Future a -> Future a
adjust :: Int -> (a -> a) -> Future a -> Future a
fromList :: [a] -> Future a
toFuture :: [a] -> Maybe (Future a)
instance Show a => Show (Complete a)
instance Traversable1 Future
instance Traversable Future
instance Foldable1 Future
instance Foldable Future
instance Alt Future
instance Applicative Future
instance ComonadApply Future
instance Apply Future
instance Comonad Future
instance Extend Future
instance Functor Future
instance Show a => Show (Future a)
instance Traversable1 Complete
instance Traversable Complete
instance Foldable1 Complete
instance Foldable Complete
instance Comonad Complete
instance Extend Complete
instance Functor Complete


module Data.Stream.Future
data Future a
Last :: a -> Future a
(:<) :: a -> Future a -> Future a
cons :: a -> Future a -> Future a
(<|) :: a -> Future a -> Future a
head :: Future a -> a
tail :: Future a -> Maybe (Future a)
length :: Future a -> Int
tails :: Future a -> Future (Future a)
map :: (a -> b) -> Future a -> Future b
index :: Int -> Future a -> a
instance Typeable Future
instance Eq a => Eq (Future a)
instance Ord a => Ord (Future a)
instance Show a => Show (Future a)
instance Read a => Read (Future a)
instance Data a => Data (Future a)
instance Applicative Future
instance Semigroup (Future a)
instance Alt Future
instance ComonadApply Future
instance Apply Future
instance Comonad Future
instance Extend Future
instance Traversable1 Future
instance Foldable1 Future
instance Traversable Future
instance Foldable Future
instance Functor Future
