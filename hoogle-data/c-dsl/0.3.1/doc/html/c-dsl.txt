-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A higher level DSL on top of language-c
--   
--   This DSL is meant to make it easier to write language-c's DSL by
--   providing simple functions/operators for writing C AST's in Haskell.
@package c-dsl
@version 0.3.1

module Language.C.DSL.Stat

-- | An if statement with no else clause
cif :: CExpr -> CStat -> CStat

-- | An if statement with an else clause
cifElse :: CExpr -> CStat -> CStat -> CStat

-- | A while loop, the <a>CExpr</a> is the looping condition.
while :: CExpr -> CStat -> CStat

-- | A for loop, an example use
--   
--   <pre>
--   for(int "x" .= 1, 1, PlusPlus `pre` "x")
--     "printf"#[str "%d\n", "x"]
--   </pre>
for :: (CDecl, CExpr, CExpr) -> CStat -> CStat

-- | A for loop with no declarations.
noDeclFor :: (CExpr, CExpr) -> CStat -> CStat

-- | A do while loop.
doWhile :: CExpr -> CStat -> CStat
cbreak :: CStat
ccont :: CStat
creturn :: CExpr -> CStat
cvoidReturn :: CStat
liftE :: CExpr -> CStat
class BlockLike a
intoB :: BlockLike a => a -> CBlockItem
block :: [CBlockItem] -> CStat
hBlock :: BlockLike a => [a] -> CStat
instance BlockLike CDecl
instance BlockLike CExpr
instance BlockLike CStat


-- | The home of all the orphaned <a>IsString</a> instances used throughout
--   the DSL.
module Language.C.DSL.StringLike
instance IsString CTypeSpec
instance IsString CDecl
instance IsString CDeclr
instance IsString CExpr
instance IsString Ident


-- | This module contians the DSL for writing <tt>CExpr</tt>s. It doesn't
--   export the orphan instance for <tt>IsString CExpr</tt> which can be
--   found in <a>Language.C.DSL.StringLike</a>.
module Language.C.DSL.Exp

-- | Lift a Haskell string into a literal C string.
str :: String -> CExpr
cOp :: CBinaryOp -> CExpr -> CExpr -> CExpr

-- | Equality test, <tt>a ==: b</tt> is equivalent to <tt>a == b</tt>
(==:) :: CExpr -> CExpr -> CExpr

-- | Inequality test, <tt>a /=: b</tt> is equivalent to <tt>a != b</tt>
(/=:) :: CExpr -> CExpr -> CExpr

-- | Less-than test, <tt>a &lt;: b</tt> is equivalent to <tt>a &lt; b</tt>
(<:) :: CExpr -> CExpr -> CExpr

-- | Greater-than test, <tt>a &gt;: b</tt> is equivalent to <tt>a &gt;
--   b</tt>
(>:) :: CExpr -> CExpr -> CExpr

-- | Less than or equal to, <tt>a &lt;=: b</tt> is equivalent to <tt>a
--   &lt;= b</tt>
(<=:) :: CExpr -> CExpr -> CExpr

-- | Greater than or equal to, <tt>a &gt;=: b</tt> is equivalent to <tt>a
--   &gt;= b</tt>
(>=:) :: CExpr -> CExpr -> CExpr

-- | The ternary operator in C. <tt>ternary a b c</tt> will turn into <tt>a
--   ? b : c</tt>.
ternary :: CExpr -> CExpr -> CExpr -> CExpr

-- | A function mapping identifier in C to be used as variables. Normally
--   this can be avoided since <a>Language.C.DSL.StringLike</a> provides an
--   <a>IsString</a> instance.
var :: Ident -> CExpr

-- | Function calls, <tt>f#[a, b, c]</tt> will become <tt>f(a, b, c)</tt>.
--   Note that <tt>f</tt> is also an expression.
(#) :: CExpr -> [CExpr] -> CExpr

-- | The assignment operator. <tt>var &lt;-- value</tt> will become <tt>var
--   = value;</tt> in C.
(<--) :: CExpr -> CExpr -> CExpr

-- | This is the more generalized version of '(&lt;--)'. It allows any
--   <a>CAssignOp</a> to be passed in to facilitate writing <tt>a += b</tt>
--   and similar.
assign :: CAssignOp -> CExpr -> CExpr -> CExpr

-- | A simplified unary operator type. It can be converted to <a>C</a>s
--   version using <a>toCUnaryOp</a>.
data UnOp
PlusPlus :: UnOp
MinusMinus :: UnOp
Minus :: UnOp
Plus :: UnOp
Not :: UnOp

-- | The address of operator <tt>&amp;</tt>.
Addr :: UnOp

-- | The dereferencing operator in C <tt>*</tt>.
Ind :: UnOp

-- | Convert a <a>UnOp</a> to the corresponding <a>CUnaryOp</a>.
toCUnaryOp :: UnOp -> CUnaryOp

-- | Apply a unary operator prefix, <tt>op <a>pre</a> exp</tt> will
--   transform into something like <tt>op exp</tt> in C. This only matters
--   for <a>PlusPlus</a> and <a>MinusMinus</a>.
pre :: UnOp -> CExpr -> CExpr

-- | The postfix equivalent of <a>pre</a>.
post :: CExpr -> UnOp -> CExpr

-- | A quick wrapper of <tt>pre Ind exp</tt> since it's so common.
star :: CExpr -> CExpr

-- | The C comma operator, <tt>comma [a, b, c]</tt> is equivalent to <tt>a,
--   b, c</tt> in C.
comma :: [CExpr] -> CExpr

-- | Implements C style casts for expressions.
castTo :: CExpr -> CDecl -> CExpr

-- | <tt>size of</tt> for types.
sizeOfDecl :: CDecl -> CExpr

-- | <tt>size of</tt> for expressions. Carefully note that <tt>sizeOf
--   <a>someType</a></tt> will incorrectly treat <tt>someType</tt> as a
--   variable, not a type.
sizeOf :: CExpr -> CExpr

-- | Access a field of a struct, this C's <tt>.</tt> operator.
(&) :: CExpr -> String -> CExpr

-- | The automatic dereferencing <tt>-&gt;</tt> in C.
(&*) :: CExpr -> String -> CExpr

-- | This is the indexing operator in C, <tt>a ! i</tt> is <tt>a[i]</tt>.
(!) :: CExpr -> CExpr -> CExpr
instance Eq UnOp
instance Show UnOp
instance Fractional CExpr
instance Num CExpr

module Language.C.DSL.Decl

-- | A low level way to declare something.
decl :: CDeclSpec -> CDeclr -> Maybe CExpr -> CDecl

-- | The <a>CTypeSpec</a> for <tt>void</tt>
voidSpec :: CTypeSpec

-- | The <a>CTypeSpec</a> for <tt>char</tt>
charSpec :: CTypeSpec

-- | The <a>CTypeSpec</a> for <tt>short</tt>
shortSpec :: CTypeSpec

-- | The <a>CTypeSpec</a> for <tt>int</tt>
intSpec :: CTypeSpec

-- | The <a>CTypeSpec</a> for <tt>long</tt>
longSpec :: CTypeSpec

-- | The <a>CTypeSpec</a> for <tt>float</tt>
floatSpec :: CTypeSpec

-- | The <a>CTypeSpec</a> for <tt>double</tt>
doubleSpec :: CTypeSpec

-- | The <a>CDeclSpec</a> for declarations of type <tt>void</tt>
voidTy :: CDeclSpec

-- | The <a>CDeclSpec</a> for declarations of type <tt>char</tt>
charTy :: CDeclSpec

-- | The <a>CDeclSpec</a> for declarations of type <tt>short</tt>
shortTy :: CDeclSpec

-- | The <a>CDeclSpec</a> for declarations of type <tt>int</tt>
intTy :: CDeclSpec

-- | The <a>CDeclSpec</a> for declarations of type <tt>long</tt>
longTy :: CDeclSpec

-- | The <a>CDeclSpec</a> for declarations of type <tt>float</tt>
floatTy :: CDeclSpec

-- | The <a>CDeclSpec</a> for declarations of type <tt>double</tt>
doubleTy :: CDeclSpec

-- | Turns a string into the corresponding typedefed type.
--   
--   For example
--   
--   <pre>
--   struct "foo" [("bar, ty "quux")]
--   </pre>
--   
--   will generate the corresponding
--   
--   <pre>
--   typedef foo {quux bar;} foo
--   </pre>
ty :: Ident -> CTypeSpec

-- | Modifies a declarator to be a pointer. For example <tt>ptr
--   someName</tt> would be <tt>*x</tt> in C.
ptr :: CDeclr -> CDeclr

-- | A short cut for declaring a <tt>char</tt>.
--   
--   <pre>
--   char "x" .= 1
--   uninit $ char "y"
--   </pre>
--   
--   Would generate
--   
--   <pre>
--   char x = 1;
--   char y;
--   </pre>
char :: CDeclr -> Maybe CExpr -> CDecl

-- | A short cut for declaring a <tt>short</tt>
short :: CDeclr -> Maybe CExpr -> CDecl

-- | A short cut for declaring a <tt>int</tt>
int :: CDeclr -> Maybe CExpr -> CDecl

-- | A short cut for declaring a <tt>long</tt>
long :: CDeclr -> Maybe CExpr -> CDecl

-- | A short cut for declaring a <tt>float</tt>
float :: CDeclr -> Maybe CExpr -> CDecl

-- | A short cut for declaring a <tt>double</tt>
double :: CDeclr -> Maybe CExpr -> CDecl

-- | Equivalent to <tt><a>char</a></tt> but wraps the
--   <tt><a>CDeclr</a></tt> in a pointer. This means that <tt>uninit $
--   charPtr someName</tt> is equivalent to <tt>char *someName;</tt>
charPtr :: CDeclr -> Maybe CExpr -> CDecl
shortPtr :: CDeclr -> Maybe CExpr -> CDecl
intPtr :: CDeclr -> Maybe CExpr -> CDecl
longPtr :: CDeclr -> Maybe CExpr -> CDecl
floatPtr :: CDeclr -> Maybe CExpr -> CDecl
doublePtr :: CDeclr -> Maybe CExpr -> CDecl

-- | Supplies an initializer for an for a declaration. This is meant to be
--   used with the <a>char</a> and friends short cuts
(.=) :: (Maybe CExpr -> CDecl) -> CExpr -> CDecl

-- | Leave a declaration uninitialized. This is meant to be used with the
--   <a>char</a> and friends declaration
uninit :: (Maybe CExpr -> CDecl) -> CDecl
csu :: CStructTag -> String -> [(String, CTypeSpec)] -> CDecl

-- | Create a structure, for example <tt>struct <a>foo</a> [(<a>bar</a>,
--   intTy)]</tt> is <tt>typedef struct foo {int bar;} foo;</tt>
struct :: String -> [(String, CTypeSpec)] -> CDecl

-- | Equivalent to <a>struct</a> but generates a C union instead.
union :: String -> [(String, CTypeSpec)] -> CDecl

-- | Defines a C function. For example
--   
--   <pre>
--   test =
--      fun [intTy] "test"[int "a", int "b"] $ hblock [
--          creturn ("a" + "b")
--      ]
--   </pre>
--   
--   Would be the equivalent of
--   
--   <pre>
--   int test(int a, int b)
--   {
--      return a + b;
--   }
--   </pre>
fun :: [CDeclSpec] -> String -> [Maybe CExpr -> CDecl] -> CStat -> CFunDef

-- | Identical to fun except this annotates the list of attributes given as
--   a list of strings.
annotatedFun :: [CDeclSpec] -> String -> [Maybe CExpr -> CDecl] -> [String] -> CStat -> CFunDef
class External a
export :: External a => a -> CExtDecl

-- | Exports a series of declarations to a translation unit.
transUnit :: [CExtDecl] -> CTranslUnit
instance External CStrLit
instance External CDecl
instance External CFunDef


-- | This module provides a more pleasant way to write C ASTs for
--   language-c As a simple example,
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   import Language.C.DSL
--   
--   example :: CFunDef
--   example =
--     fun [intTy] "foo"[int "a", int "b"] $ block [
--         creturn $ "a" + "b"
--     ]
--   </pre>
--   
--   And when loaded into GHCi
--   
--   <pre>
--   Main*&gt; pretty example
--   int foo(int a, int b)
--   {
--     return a + b;
--   }
--   </pre>
--   
--   This module also exports <a>Language.C</a> for simplicity.
module Language.C.DSL
