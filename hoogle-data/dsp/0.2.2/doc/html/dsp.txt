-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell Digital Signal Processing
--   
--   Digital Signal Processing, Fourier Transform, Linear Algebra,
--   Interpolation
@package dsp
@version 0.2.2


-- | Simple module for generating Maclaurin series representation of a few
--   functions:
--   
--   <pre>
--   f(x) = sum [ a_i * x^i | i &lt;- [0..] ]
--   </pre>
--   
--   The <tt>Int</tt> parameter for all functions is the <i>order</i> of
--   the polynomial, eg:
--   
--   <pre>
--   [ a_i | i &lt;- [0..N] ]
--   </pre>
--   
--   and not the number of non-zero terms
module Polynomial.Maclaurin

-- | e^x
polyexp :: Int -> [Double]

-- | ln (1+x), 0 &lt;= x &lt;= 1
polyln1 :: Int -> [Double]

-- | cos x
polycos :: Int -> [Double]

-- | sin x
polysin :: Int -> [Double]

-- | atan x, -1 &lt; x &lt; 1
polyatan :: Int -> [Double]

-- | cosh x
polycosh :: Int -> [Double]

-- | sinh x
polysinh :: Int -> [Double]

-- | atanh x
polyatanh :: Int -> [Double]


-- | Radix-2 Decimation in Time FFT
module Numeric.Transform.Fourier.R2DIT

-- | Radix-2 Decimation in Time FFT
fft_r2dit :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> a -> (Array a (Complex b) -> Array a (Complex b)) -> Array a (Complex b)


-- | This is an implementation of Goertzel's algorithm, which computes one
--   bin of a DFT. A description can be found in Oppenheim and Schafer's
--   <i>Discrete Time Signal Processing</i>, pp 585-587.
module Numeric.Transform.Fourier.Goertzel

-- | Goertzel's algorithm for complex inputs
cgoertzel :: (RealFloat a, Ix b, Integral b) => Array b (Complex a) -> b -> Complex a

-- | Power via Goertzel's algorithm for complex inputs
cgoertzel_power :: (RealFloat a, Ix b, Integral b) => Array b (Complex a) -> b -> a

-- | Goertzel's algorithm for real inputs
rgoertzel :: (RealFloat a, Ix b, Integral b) => Array b a -> b -> Complex a

-- | Power via Goertzel's algorithm for real inputs
rgoertzel_power :: (RealFloat a, Ix b, Integral b) => Array b a -> b -> a


-- | Rader's Algorithm for computing prime length FFT's
module Numeric.Transform.Fourier.Rader

-- | Rader's Algorithm using direct convolution
fft_rader1 :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> a -> Array a (Complex b)

-- | Rader's Algorithm using FFT convolution
fft_rader2 :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> a -> (Array a (Complex b) -> Array a (Complex b)) -> Array a (Complex b)


-- | Prime Factor Algorithm
module Numeric.Transform.Fourier.PFA

-- | Prime Factor Algorithm doing row FFT's then column FFT's
fft_pfa :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> a -> a -> (Array a (Complex b) -> Array a (Complex b)) -> Array a (Complex b)


-- | Hard-coded FFT transforms
module Numeric.Transform.Fourier.FFTHard

-- | Length 2 FFT
fft'2 :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> Array a (Complex b)

-- | Length 3 FFT
fft'3 :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> Array a (Complex b)

-- | Length 4 FFT
fft'4 :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> Array a (Complex b)


-- | Not so naive implementation of a Discrete Fourier Transform.
module Numeric.Transform.Fourier.DFT
dft :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> Array a (Complex b)


-- | Cooley-Tukey algorithm for computing the FFT
module Numeric.Transform.Fourier.CT

-- | Cooley-Tukey algorithm doing row FFT's then column FFT's
fft_ct1 :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> a -> a -> (Array a (Complex b) -> Array a (Complex b)) -> Array a (Complex b)

-- | Cooley-Tukey algorithm doing column FFT's then row FFT's
fft_ct2 :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> a -> a -> (Array a (Complex b) -> Array a (Complex b)) -> Array a (Complex b)


-- | Simple module for computing the median on a list
--   
--   Reference: Ross, NRiC
module Numeric.Statistics.Median

-- | Compute the median of a list
median :: (Ord a, Fractional a) => [a] -> a

-- | Compute the center of the list in a more lazy manner and thus halves
--   memory requirement.
medianFast :: (Ord a, Fractional a) => [a] -> a


-- | Function for white noise
--   
--   This is pretty useless, but it is here to be comprehensive
module Numeric.Random.Spectrum.White
white :: [Double] -> [Double]


-- | Function for purple noise, which is differentiated white noise
--   
--   This currently just does a simple first-order difference. This is
--   equivalent to filtering the white noise with <tt> h[n] = [1,-1] </tt>
--   A better solution would be to use a proper FIR differentiator.
module Numeric.Random.Spectrum.Purple
purple :: [Double] -> [Double]


-- | Function for brown noise, which is integrated white noise
module Numeric.Random.Spectrum.Brown
brown :: [Double] -> [Double]


-- | A Haskell program for MT19937 pseudorandom number generator
module Numeric.Random.Generator.MT19937
type W = Word32
genrand :: W -> [W]
test :: IO ()


-- | Functions for turning a list of random integers (as <a>Word32</a>) in
--   a list of Uniform RV's
module Numeric.Random.Distribution.Uniform

-- | 32 bits in [0,1]
uniform32cc :: [Word32] -> [Double]

-- | 32 bits in [0,1)
uniform32co :: [Word32] -> [Double]

-- | 32 bits in (0,1]
uniform32oc :: [Word32] -> [Double]

-- | 32 bits in (0,1)
uniform32oo :: [Word32] -> [Double]

-- | 53 bits in [0,1], ie 64-bit IEEE 754 in [0,1]
uniform53cc :: [Word32] -> [Double]

-- | 53 bits in [0,1), ie 64-bit IEEE 754 in [0,1)
uniform53co :: [Word32] -> [Double]

-- | 53 bits in (0,1]
uniform53oc :: [Word32] -> [Double]

-- | 53 bits in (0,1)
uniform53oo :: [Word32] -> [Double]

-- | transforms uniform [0,1] to [a,b]
uniform :: Double -> Double -> [Double] -> [Double]


-- | UNTESTED
--   
--   Module for transforming a list of uniform random variables into a list
--   of geometric random variables.
--   
--   <pre>
--   P{X=n} = (1-p)^(n-1)*p
--   </pre>
--   
--   Reference: Ross
module Numeric.Random.Distribution.Geometric

-- | Generates a list of geometric random variables from a list of uniforms
geometric :: Double -> [Double] -> [Double]


-- | UNTESTED
--   
--   Module for transforming a list of uniform random variables into a list
--   of gamma random variables.
--   
--   <pre>
--   f(x) = lambda * exp(-lambda*x) * (lambda * x)^(t-1) / Gamma(t)
--   </pre>
--   
--   Reference: Ross
module Numeric.Random.Distribution.Gamma

-- | Generates a list of gamma random variables from a list of uniforms via
--   the inverse transformation method
gamma :: Int -> Double -> [Double] -> [Double]


-- | UNTESTED
--   
--   Module for transforming a list of uniform random variables into a list
--   of exponential random variables.
--   
--   <pre>
--   f(x) = lambda * exp(-lambda*x)
--   </pre>
--   
--   <pre>
--   F(x) = 1 - exp(-lambda*x)
--   </pre>
--   
--   <pre>
--   lambda = 1 / mu
--   </pre>
--   
--   Reference: Ross
module Numeric.Random.Distribution.Exponential

-- | Generates a list of exponential random variables from a list of
--   uniforms via the inverse transformation method
--   
--   <pre>
--   F(x) = 1 - exp(-lambda*x)
--   </pre>
--   
--   <pre>
--   F^-1(x) = -log(1 - x) / lambda
--   </pre>
exponential_inv :: Double -> [Double] -> [Double]


-- | UNTESTED
--   
--   Module for transforming a list of uniform random variables into a list
--   of binomial random variables.
--   
--   Reference: Ross
module Numeric.Random.Distribution.Binomial

-- | Generates a list of binomial random variables from a list of uniforms
binomial :: Int -> Double -> [Double] -> [Double]


-- | Function approximation using Chebyshev polynomials
--   
--   <pre>
--   f(x) = ( sum (k=0..N-1) c_k * T_k(x) ) - 0.5 * c_0
--   </pre>
--   
--   over the interval <tt> [a,b] </tt>
--   
--   Reference: NRiC
module Numeric.Approximation.Chebyshev

-- | Calculates the Chebyshev approximation to <tt>f(x)</tt> over
--   <tt>[a,b]</tt>
cheby_approx :: (Double -> Double) -> Double -> Double -> Int -> [Double]

-- | Evaluates the Chebyshev approximation to <tt>f(x)</tt> over
--   <tt>[a,b]</tt> at <tt>x</tt>
cheby_eval :: [Double] -> Double -> Double -> Double -> Double


-- | Two-step simplex algorithm
--   
--   I only guarantee that this module wastes inodes
module Matrix.Simplex

-- | Type for results of the simplex algorithm
data Simplex a
Unbounded :: Simplex a
Infeasible :: Simplex a
Optimal :: a -> Simplex a

-- | The simplex algorithm for standard form:
--   
--   min c'x
--   
--   where Ax = b, x &gt;= 0
--   
--   a!(0,0) = -z
--   
--   a!(0,j) = c'
--   
--   a!(i,0) = b
--   
--   a!(i,j) = A_ij
simplex :: Array (Int, Int) Double -> Simplex (Array (Int, Int) Double)

-- | The two-phase simplex algorithm
twophase :: Array (Int, Int) Double -> Simplex (Array (Int, Int) Double)
instance Read a => Read (Simplex a)
instance Show a => Show (Simplex a)


-- | Simple phase unwrapping algorithm
module DSP.Unwrap

-- | This is the simple phase unwrapping algorithm from Oppenheim and
--   Schafer.
unwrap :: (Ix a, Integral a, Ord b, Floating b) => b -> Array a b -> Array a b


-- | NCO and NCOM functions
module DSP.Source.Oscillator

-- | <a>nco</a> creates a sine wave with normalized frequency wn
--   (numerically controlled oscillator, or NCO) using the recurrence
--   relation y[n] = 2cos(wn)*y[n-1] - y[n-2]. Eventually, cumulative
--   errors will creep into the data. This is unavoidable since performing
--   AGC on this type of real data is hard. The good news is that the error
--   is small with floating point data.
nco :: RealFloat a => a -> a -> [a]

-- | <a>ncom</a> mixes (multiplies) x by a real sine wave with normalized
--   frequency wn. This is usually called an NCOM: Numerically Controlled
--   Oscillator and Modulator.
ncom :: RealFloat a => a -> a -> [a] -> [a]

-- | <a>quadrature_nco</a> returns an infinite list representing a complex
--   phasor with a phase step of wn radians, ie a quadrature nco with
--   normalized frequency wn radians/sample. Since Haskell uses lazy
--   evaluation, rotate will only be computed once, so this NCO uses only
--   one sin and one cos for the entire list, at the expense of 4 mults, 1
--   add, and 1 subtract per point.
quadrature_nco :: RealFloat a => a -> a -> [Complex a]

-- | <a>complex_ncom</a> mixes the complex input x with a quardatue nco
--   with normalized frequency wn radians/sample using complex multiplies
--   (perform a complex spectral shift)
complex_ncom :: RealFloat a => a -> a -> [Complex a] -> [Complex a]

-- | <a>quadrature_ncom</a> mixes the complex input x with a quadrature nco
--   with normalized frequency wn radians/sample in quadrature (I/Q
--   modulation)
quadrature_ncom :: RealFloat a => a -> a -> [Complex a] -> [a]
agc :: RealFloat a => Complex a -> Complex a


-- | Flowgraph functions
--   
--   DO NOT USE YET
module DSP.Flowgraph

-- | Cascade of functions, eg
--   
--   <pre>
--   cascade [ f1, f2, f3 ] x == (f3 . f2 . f1) x
--   </pre>
cascade :: Num a => [[a] -> [a]] -> [a] -> [a]

-- | Gain node
--   
--   <pre>
--   y[n] = a * x[n]
--   </pre>
gain :: Num a => a -> [a] -> [a]

-- | Bias node
--   
--   <pre>
--   y[n] = x[n] + a
--   </pre>
bias :: Num a => a -> [a] -> [a]

-- | Adder node
--   
--   <pre>
--   z[n] = x[n] + y[n]
--   </pre>
adder :: Num a => [a] -> [a] -> [a]

module Numeric.Special.Trigonometric
csc :: Floating a => a -> a
sec :: Floating a => a -> a
cot :: Floating a => a -> a
acsc :: Floating a => a -> a
asec :: Floating a => a -> a
acot :: Floating a => a -> a
csch :: Floating a => a -> a
sech :: Floating a => a -> a
coth :: Floating a => a -> a
acsch :: Floating a => a -> a
asech :: Floating a => a -> a
acoth :: Floating a => a -> a


-- | Module implementing LU decomposition and related functions
module Matrix.LU

-- | LU decomposition via Crout's Algorithm
lu :: Array (Int, Int) Double -> Array (Int, Int) Double

-- | Solution to Ax=b via LU decomposition
lu_solve :: Array (Int, Int) Double -> Array Int Double -> Array Int Double

-- | Improve a solution to Ax=b via LU decomposition
improve :: Array (Int, Int) Double -> Array (Int, Int) Double -> Array Int Double -> Array Int Double -> Array Int Double

-- | Matrix inversion via LU decomposition
inverse :: Array (Int, Int) Double -> Array (Int, Int) Double

-- | Determinant of a matrix via LU decomposition
lu_det :: Array (Int, Int) Double -> Double

-- | LU solver using original matrix
solve :: Array (Int, Int) Double -> Array Int Double -> Array Int Double

-- | determinant using original matrix
det :: Array (Int, Int) Double -> Double


-- | Basic matrix routines
module Matrix.Matrix

-- | Matrix-matrix multiplication: A x B = C
mm_mult :: (Ix a, Integral a, Num b) => Array (a, a) b -> Array (a, a) b -> Array (a, a) b

-- | Matrix-vector multiplication: A x b = c
mv_mult :: (Ix a, Integral a, Num b) => Array (a, a) b -> Array a b -> Array a b

-- | Transpose of a matrix
m_trans :: (Ix a, Integral a, Num b) => Array (a, a) b -> Array (a, a) b

-- | Hermitian transpose (conjugate transpose) of a matrix
m_hermit :: (Ix a, Integral a, RealFloat b) => Array (a, a) (Complex b) -> Array (a, a) (Complex b)


-- | General case of Prony's Method where K &gt; p+q
--   
--   References: L&amp;I, Sect 8.1; P&amp;B, Sect 7.5; P&amp;M, Sect 8.5.2
--   
--   Notation follows L&amp;I
module DSP.Filter.IIR.Prony

-- | Implementation of Prony's method
prony :: Int -> Int -> Array Int Double -> (Array Int Double, Array Int Double)


-- | Functions for creating rectangular windowed FIR filters
module DSP.Filter.FIR.Taps

-- | Lowpass filter
lpf :: (Ix a, Integral a, Enum b, Floating b, Eq b) => b -> a -> Array a b

-- | Highpass filter
hpf :: (Ix a, Integral a, Enum b, Floating b, Eq b) => b -> a -> Array a b

-- | Bandpass filter
bpf :: (Ix a, Integral a, Enum b, Floating b, Eq b) => b -> b -> a -> Array a b

-- | Bandstop filter
bsf :: (Ix a, Integral a, Enum b, Floating b, Eq b) => b -> b -> a -> Array a b

-- | Multiband filter
mbf :: (Ix a, Integral a, Enum b, Floating b, Eq b) => [b] -> [b] -> a -> Array a b

-- | Raised-cosine filter
rc :: (Ix a, Integral a, Enum b, Floating b, Eq b) => b -> b -> a -> Array a b


-- | Finite Impuse Response filtering functions
module DSP.Filter.FIR.FIR

-- | Implements the following function, which is a FIR filter
--   
--   <pre>
--   y[n] = sum(k=0,M) h[k]*x[n-k]
--   </pre>
--   
--   We implement the fir function with five helper functions, depending on
--   the type of the filter. In the following functions, we use the O&amp;S
--   convention that m is the order of the filter, which is equal to the
--   number of taps minus one.
fir :: (Num a, Eq a) => Array Int a -> [a] -> [a]
test :: Bool


-- | IIR functions
--   
--   IMPORTANT NOTE:
--   
--   Except in integrator, we use the convention that
--   
--   <pre>
--   y[n] = sum(k=0..M) b_k*x[n-k] - sum(k=1..N) a_k*y[n-k]
--   </pre>
--   
--   <pre>
--   sum(k=0..M) b_k*z^-1
--   </pre>
--   
--   <pre>
--   H(z) = ------------------------
--   </pre>
--   
--   <pre>
--   1 + sum(k=1..N) a_k*z^-1
--   </pre>
module DSP.Filter.IIR.IIR

-- | This is an integrator when a==1, and a leaky integrator when <tt>0
--   &lt; a &lt; 1</tt>.
--   
--   <pre>
--   y[n] = a * y[n-1] + x[n]
--   </pre>
integrator :: Num a => a -> [a] -> [a]

-- | First order section, DF1
--   
--   <pre>
--   v[n] = b0 * x[n] + b1 * x[n-1]
--   </pre>
--   
--   <pre>
--   y[n] = v[n] - a1 * y[n-1]
--   </pre>
fos_df1 :: Num a => a -> a -> a -> [a] -> [a]

-- | First order section, DF2
--   
--   <pre>
--   w[n] = -a1 * w[n-1] + x[n]
--   </pre>
--   
--   <pre>
--   y[n] = b0 * w[n] + b1 * w[n-1]
--   </pre>
fos_df2 :: Num a => a -> a -> a -> [a] -> [a]

-- | First order section, DF2T
--   
--   <pre>
--   v0[n] = b0 * x[n] + v1[n-1]
--   </pre>
--   
--   <pre>
--   y[n] = v0[n]
--   </pre>
--   
--   <pre>
--   v1[n] = -a1 * y[n] + b1 * x[n]
--   </pre>
fos_df2t :: Num a => a -> a -> a -> [a] -> [a]

-- | Direct Form I for a second order section
--   
--   <pre>
--   v[n] = b0 * x[n] + b1 * x[n-1] + b2 * x[n-2]
--   </pre>
--   
--   <pre>
--   y[n] = v[n] - a1 * y[n-1] - a2 * y[n-2]
--   </pre>
biquad_df1 :: Num a => a -> a -> a -> a -> a -> [a] -> [a]

-- | Direct Form II for a second order section (biquad)
--   
--   <pre>
--   w[n] = -a1 * w[n-1] - a2 * w[n-2] + x[n]
--   </pre>
--   
--   <pre>
--   y[n] = b0 * w[n] + b1 * w[n-1] + b2 * w[n-2]
--   </pre>
biquad_df2 :: Num a => a -> a -> a -> a -> a -> [a] -> [a]

-- | Transposed Direct Form II for a second order section
--   
--   <pre>
--   v0[n] = b0 * x[n] + v1[n-1]
--   </pre>
--   
--   <pre>
--   y[n] = v0[n]
--   </pre>
--   
--   <pre>
--   v1[n] = -a1 * y[n] + b1 * x[n] + v2[n-1]
--   </pre>
--   
--   <pre>
--   v2[n] = -a2 * y[n] + b2 * x[n]
--   </pre>
biquad_df2t :: Num a => a -> a -> a -> a -> a -> [a] -> [a]

-- | Direct Form I IIR
--   
--   <pre>
--   v[n] = sum(k=0..M) b_k*x[n-k]
--   </pre>
--   
--   <pre>
--   y[n] = v[n] - sum(k=1..N) a_k*y[n-k]
--   </pre>
--   
--   <tt>v[n]</tt> is calculated with <a>fir</a>
iir_df1 :: (Num a, Eq a) => (Array Int a, Array Int a) -> [a] -> [a]

-- | Direct Form II IIR
--   
--   <pre>
--   w[n] = x[n] - sum(k=1..N) a_k*w[n-k]
--   </pre>
--   
--   <pre>
--   y[n] = sum(k=0..M) b_k*w[n-k]
--   </pre>
iir_df2 :: Num a => (Array Int a, Array Int a) -> [a] -> [a]
xt :: [Double]
yt :: [Double]
f1 :: Fractional a => [a] -> [a]
f2 :: Fractional a => [a] -> [a]
f3 :: Fractional a => [a] -> [a]
f4 :: [Double] -> [Double]
f5 :: [Double] -> [Double]


-- | Polyphase interpolators and decimators
--   
--   Reference: C&amp;R
module DSP.Multirate.Polyphase

-- | Polyphase interpolator
poly_interp :: (Num a, Eq a) => Int -> Array Int a -> [a] -> [a]


-- | Simple module for handling polynomials.
module Polynomial.Basic

-- | Evaluate a polynomial using Horner's method.
polyeval :: Num a => [a] -> a -> a

-- | Add two polynomials
polyadd :: Num a => [a] -> [a] -> [a]
polyAddScalar :: Num a => a -> [a] -> [a]

-- | Subtract two polynomials
polysub :: Num a => [a] -> [a] -> [a]

-- | Scale a polynomial
polyscale :: Num a => a -> [a] -> [a]

-- | Multiply two polynomials
polymult :: Num a => [a] -> [a] -> [a]
polymultAlt :: Num a => [a] -> [a] -> [a]

-- | Divide two polynomials
polydiv :: Fractional a => [a] -> [a] -> [a]

-- | Modulus of two polynomials (remainder of division)
polymod :: Fractional a => [a] -> [a] -> [a]

-- | Raise a polynomial to a non-negative integer power
polypow :: (Num a, Integral b) => [a] -> b -> [a]

-- | Polynomial substitution y(n) = x(w(n))
polysubst :: Num a => [a] -> [a] -> [a]
polysubstAlt :: Num a => [a] -> [a] -> [a]

-- | Polynomial substitution <tt>y(n) = x(w(n))</tt> where the coefficients
--   of <tt>x</tt> are also polynomials.
polyPolySubst :: Num a => [a] -> [[a]] -> [a]

-- | Polynomial derivative
polyderiv :: Num a => [a] -> [a]

-- | Polynomial integration
polyinteg :: Fractional a => [a] -> a -> [a]

-- | Convert roots to a polynomial
roots2poly :: Num a => [a] -> [a]


-- | Simple module for generating Chebyshev polynomials
--   
--   <pre>
--   T_0(x) = 1
--   </pre>
--   
--   <pre>
--   T_1(x) = x
--   </pre>
--   
--   <pre>
--   T_N+1(x) = 2x T_N(x) - T_N-1(x)
--   </pre>
module Polynomial.Chebyshev

-- | generates Chebyshev polynomials
cheby :: (Integral a, Num b) => a -> [b]


-- | Analog prototype filter transforms
module DSP.Filter.Analog.Transform

-- | Lowpass to lowpass: <tt>s --&gt; s/wc</tt>
a_lp2lp :: Double -> ([Double], [Double]) -> ([Double], [Double])

-- | Lowpass to highpass: <tt>s --&gt; wc/s</tt>
a_lp2hp :: Double -> ([Double], [Double]) -> ([Double], [Double])

-- | Lowpass to bandpass: <tt>s --&gt; (s^2 + wl*wu) / (s(wu-wl))</tt>
a_lp2bp :: Double -> Double -> ([Double], [Double]) -> ([Double], [Double])

-- | Lowpass to bandstop: <tt>s --&gt; (s(wu-wl)) / (s^2 + wl*wu)</tt>
a_lp2bs :: Double -> Double -> ([Double], [Double]) -> ([Double], [Double])
substitute :: ([Double], [Double]) -> ([Double], [Double]) -> ([Double], [Double])
propSubstituteRecip :: ([Double], [Double]) -> ([Double], [Double]) -> Bool
propSubstituteAlt :: ([Double], [Double]) -> ([Double], [Double]) -> Bool


-- | Digital IIR filter transforms
--   
--   Reference: R&amp;G, pg 260; O&amp;S, pg 434; P&amp;M, pg 699
--   
--   Notation follows O&amp;S
module DSP.Filter.IIR.Transform

-- | Lowpass to lowpass: <tt>z^-1 --&gt; (z^-1 - a)/(1 - a*z^-1)</tt>
d_lp2lp :: Double -> Double -> ([Double], [Double]) -> ([Double], [Double])

-- | Lowpass to Highpass: <tt>z^-1 --&gt; -(z^-1 + a)/(1 + a*z^-1)</tt>
d_lp2hp :: Double -> Double -> ([Double], [Double]) -> ([Double], [Double])

-- | Lowpass to Bandpass: z^-1 --&gt;
d_lp2bp :: Double -> Double -> Double -> ([Double], [Double]) -> ([Double], [Double])

-- | Lowpass to Bandstop: z^-1 --&gt;
d_lp2bs :: Double -> Double -> Double -> ([Double], [Double]) -> ([Double], [Double])


-- | Polynomial interpolators. Taken from:
--   
--   Olli Niemitalo (ollinie@freenet.hut.fi), <a>Polynomial Interpolators
--   for High-Quality Resampling of Oversampled Audio</a> Search for
--   <a>deip.pdf</a> with Google and you will find it.
module DSP.Filter.FIR.PolyInterp

-- | <a>mkcoef</a> takes the continuous impluse response function (one of
--   the functions below, <tt>f</tt>) and number of points in the
--   interpolation, <tt>p</tt>, time shifts it by <tt>x</tt>, samples it,
--   and creates an array with the interpolation coeficients that can be
--   used as a FIR filter.
mkcoef :: (Num a, Ix b, Integral b) => (a -> a) -> b -> a -> Array b a
bspline_1p0o :: (Ord a, Fractional a) => a -> a
bspline_2p1o :: (Ord a, Fractional a) => a -> a
bspline_4p3o :: (Ord a, Fractional a) => a -> a
bspline_6p5o :: (Ord a, Fractional a) => a -> a
lagrange_4p3o :: (Ord a, Fractional a) => a -> a
lagrange_6p5o :: (Ord a, Fractional a) => a -> a
hermite_4p3o :: (Ord a, Fractional a) => a -> a
hermite_6p3o :: (Ord a, Fractional a) => a -> a
hermite_6p5o :: (Ord a, Fractional a) => a -> a
sndosc_4p5o :: (Ord a, Fractional a) => a -> a
sndosc_6p5o :: (Ord a, Fractional a) => a -> a
watte_4p2o :: (Ord a, Fractional a) => a -> a
parabolic2x_4p2o :: (Ord a, Fractional a) => a -> a
optimal_2p3o2x :: (Ord a, Fractional a) => a -> a
optimal_2p3o4x :: (Ord a, Fractional a) => a -> a
optimal_2p3o8x :: (Ord a, Fractional a) => a -> a
optimal_2p3o16x :: (Ord a, Fractional a) => a -> a
optimal_2p3o32x :: (Ord a, Fractional a) => a -> a
optimal_4p2o2x :: (Ord a, Fractional a) => a -> a
optimal_4p2o4x :: (Ord a, Fractional a) => a -> a
optimal_4p2o8x :: (Ord a, Fractional a) => a -> a
optimal_4p2o16x :: (Ord a, Fractional a) => a -> a
optimal_4p2o32x :: (Ord a, Fractional a) => a -> a
optimal_4p3o2x :: (Ord a, Fractional a) => a -> a
optimal_4p3o4x :: (Ord a, Fractional a) => a -> a
optimal_4p3o8x :: (Ord a, Fractional a) => a -> a
optimal_4p3o16x :: (Ord a, Fractional a) => a -> a
optimal_4p3o32x :: (Ord a, Fractional a) => a -> a
optimal_4p4o2x :: (Ord a, Fractional a) => a -> a
optimal_4p4o4x :: (Ord a, Fractional a) => a -> a
optimal_4p4o8x :: (Ord a, Fractional a) => a -> a
optimal_4p4o16x :: (Ord a, Fractional a) => a -> a
optimal_4p4o32x :: (Ord a, Fractional a) => a -> a
optimal_6p4o2x :: (Ord a, Fractional a) => a -> a
optimal_6p4o4x :: (Ord a, Fractional a) => a -> a
optimal_6p4o8x :: (Ord a, Fractional a) => a -> a
optimal_6p4o16x :: (Ord a, Fractional a) => a -> a
optimal_6p4o32x :: (Ord a, Fractional a) => a -> a
optimal_6p5o2x :: (Ord a, Fractional a) => a -> a
optimal_6p5o4x :: (Ord a, Fractional a) => a -> a
optimal_6p5o8x :: (Ord a, Fractional a) => a -> a
optimal_6p5o16x :: (Ord a, Fractional a) => a -> a
optimal_6p5o32x :: (Ord a, Fractional a) => a -> a


-- | Herrmann type smooth FIR filters, from Hamming, Chapter 7, also known
--   as maximally flat FIR filters
--   
--   If x is the -3 dB point, then p/q = -(x+1)/(x-1)
module DSP.Filter.FIR.Smooth

-- | designs smooth FIR filters
smoothfir :: (Ix a, Integral a, Fractional b) => a -> a -> Array a b


-- | The module contains a function for performing the bilinear transform.
--   
--   The input is a rational polynomial representation of the s-domain
--   function to be transformed.
--   
--   In the bilinear transform, we substitute
--   
--   <pre>
--   2    1 - z^-1
--   </pre>
--   
--   <pre>
--   s &lt;--  -- * --------
--   </pre>
--   
--   <pre>
--   ts   1 + z^-1
--   </pre>
--   
--   into the rational polynomial, where ts is the sampling period. To get
--   a rational polynomial back, we use the following method:
--   
--   <ol>
--   <li>Substitute s^n with (2/ts * (1-z^-1))^n == [ -2/ts, 2/ts ]^n</li>
--   <li>Multiply the results by (1+z^-1)^n == [ 1, 1 ]^n</li>
--   <li>Add up all of the common terms</li>
--   <li>Normalize all of the coeficients by a0</li>
--   </ol>
--   
--   where n is the maximum order of the numerator and denominator
module DSP.Filter.IIR.Bilinear
zm :: (Integral b, Fractional a) => a -> b -> [a]
zp :: (Integral b, Num a) => b -> [a]
step1 :: Fractional a => a -> [a] -> [[a]]
step2 :: (Num a, Integral b) => b -> [[a]] -> [[a]]
step3 :: Num a => [[a]] -> [a]
step4 :: Fractional a => a -> [a] -> [a]

-- | Performs the bilinear transform
bilinear :: Double -> ([Double], [Double]) -> ([Double], [Double])

-- | Function for frequency prewarping
prewarp :: Double -> Double -> Double


-- | Root finder using Laguerre's method
module Polynomial.Roots

-- | Root finder using Laguerre's method
roots :: RealFloat a => a -> Int -> [Complex a] -> [Complex a]


-- | Matched-z transform
--   
--   References: Proakis and Manolakis, Rabiner and Gold
module DSP.Filter.IIR.Matchedz

-- | Performs the matched-z transform
matchedz :: Double -> ([Double], [Double]) -> ([Double], [Double])


-- | Module for generating analog filter prototypes
module DSP.Filter.Analog.Prototype

-- | Generates Butterworth filter prototype
butterworth :: Int -> ([Double], [Double])

-- | Generates Chebyshev filter prototype
chebyshev1 :: Double -> Int -> ([Double], [Double])

-- | Generates Inverse Chebyshev filter prototype
chebyshev2 :: Double -> Int -> ([Double], [Double])


-- | Test vectors from Kay, <i>Modern Spectral Estimation</i>
module DSP.Estimation.Spectral.KayData

-- | Complex test data
xc :: Array Int (Complex Double)

-- | Real test data
xr :: Array Int Double


-- | This module contains a routine that solves the system Ax=b, where A is
--   positive definite, using Cholesky decomposition.
module Matrix.Cholesky
cholesky :: (Ix a, Integral a, RealFloat b) => Array (a, a) (Complex b) -> Array a (Complex b) -> Array a (Complex b)


-- | This module contains an implementation of Levinson-Durbin recursion.
module Matrix.Levinson

-- | levinson takes an array, r, of autocorrelation values, and a model
--   order, p, and returns an array, a, of the model estimate and rho, the
--   noise power.
levinson :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> a -> (Array a (Complex b), b)


-- | This is an implementation of the Quinn-Fernandes algorithm for
--   estimating the frequency of a real sinusoid in noise.
module DSP.Estimation.Frequency.QuinnFernandes

-- | The Quinn-Fernandes algorithm
qf :: (Ix a, Integral a, RealFloat b) => Array a b -> b -> b


-- | This module implements an algorithm to maximize the peak value of a
--   DFT/FFT. It is based off an aticle by Mark Sullivan from Personal
--   Engineering Magazine.
--   
--   Maximizes
--   
--   <pre>
--   S(w) = 1/N * sum(k=0,N-1) |x[k] * e^(-jwk)|^2
--   </pre>
--   
--   which is equivalent to solving
--   
--   <pre>
--   S'(w) = Im{X(w) * ~Y(w)} = 0
--   </pre>
--   
--   where
--   
--   <tt>X(w) = sum(k=0,N-1) (x[k] * e^(-jwk))</tt> <tt>Y(w) = X'(w) =
--   sum(k=0,N-1) (k * x[k] * e^(-jwk))</tt>
--   
--   This algorithm used the bisection method for finding the zero of a
--   function. The search area is +- half a bin width.
--   
--   Regula falsi requires an additional (x,f(x)) pair which is expensive
--   in this case. Newton's method could be used but requires S''(w), which
--   takes twice as long to caculate as S'(w). Brent's method may be best
--   here, but it also requires three (x,f(x)) pairs
module DSP.Estimation.Frequency.PerMax

-- | Discrete frequency periodigram maximizer
permax :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> a -> b


-- | Simple module for computing the various moments of a list
--   
--   Reference: Ross, NRiC
module Numeric.Statistics.Moment

-- | Compute the mean of a list
--   
--   <pre>
--   Mean(X) = 1/N sum(i=1..N) x_i
--   </pre>
mean :: Fractional a => [a] -> a

-- | Compute the variance of a list
--   
--   <pre>
--   Var(X) = sigma^2
--   </pre>
--   
--   <pre>
--   = 1/N-1 sum(i=1..N) (x_i-mu)^2
--   </pre>
var :: Fractional a => [a] -> a

-- | Compute the standard deviation of a list
--   
--   <pre>
--   StdDev(X) = sigma = sqrt (Var(X))
--   </pre>
stddev :: RealFloat a => [a] -> a

-- | Compute the average deviation of a list
--   
--   <pre>
--   AvgDev(X) = 1/N sum(i=1..N) |x_i-mu|
--   </pre>
avgdev :: RealFloat a => [a] -> a

-- | Compute the skew of a list
--   
--   <pre>
--   Skew(X) = 1/N sum(i=1..N) ((x_i-mu)/sigma)^3
--   </pre>
skew :: RealFloat a => [a] -> a

-- | Compute the kurtosis of a list
--   
--   <pre>
--   Kurt(X) = ( 1/N sum(i=1..N) ((x_i-mu)/sigma)^4 ) - 3
--   </pre>
kurtosis :: RealFloat a => [a] -> a


-- | UNTESTED
--   
--   Module for transforming a list of uniform random variables into a list
--   of Poisson random variables.
--   
--   Reference: Ross Donald E. Knuth (1969). Seminumerical Algorithms, The
--   Art of Computer Programming, Volume 2
module Numeric.Random.Distribution.Poisson

-- | Generates a list of poisson random variables from a list of uniforms.
poisson :: Double -> [Double] -> [Int]
test :: Int -> Double -> Double
testHead :: Int -> Double -> Double


-- | UNTESTED
--   
--   Simple module for computing the covariance of two lists
--   
--   <pre>
--   Cov(X1,X2) = 1/(N-1) * sum (i=1..N) ((x1_i - mu1)(x2_i - mu2))
--   </pre>
--   
--   Reference: Ross, NRiC
module Numeric.Statistics.Covariance
cov :: Fractional a => [a] -> [a] -> a


-- | UNTESTED: DO NOT USE
--   
--   Student's t-test functions
--   
--   Reference: NRiC
module Numeric.Statistics.TTest
ttest :: [Double] -> [Double] -> Double
tutest :: [Double] -> [Double] -> Double
tptest :: [Double] -> [Double] -> Double


-- | This module contains routines to perform cross- and auto-correlation.
--   These formulas can be found in most DSP textbooks.
--   
--   In the following routines, x and y are assumed to be of the same
--   length.
module DSP.Correlation

-- | raw cross-correllation
rxy :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> Array a (Complex b) -> a -> Complex b

-- | biased cross-correllation
rxy_b :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> Array a (Complex b) -> a -> Complex b

-- | unbiased cross-correllation
rxy_u :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> Array a (Complex b) -> a -> Complex b

-- | raw auto-correllation
rxx :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> a -> Complex b

-- | biased auto-correllation
rxx_b :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> a -> Complex b

-- | unbiased auto-correllation
rxx_u :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> a -> Complex b
test :: Bool


-- | This module contains routines to perform cross- and auto-covariance
--   These formulas can be found in most DSP textbooks.
--   
--   In the following routines, x and y are assumed to be of the same
--   length.
module DSP.Covariance

-- | raw cross-covariance
--   
--   We define covariance in terms of correlation.
--   
--   Cxy(X,Y) = E[(X - E[X])(Y - E[Y])] = E[XY] - E[X]E[Y] = Rxy(X,Y) -
--   E[X]E[Y]
cxy :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> Array a (Complex b) -> a -> Complex b

-- | biased cross-covariance
cxy_b :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> Array a (Complex b) -> a -> Complex b

-- | unbiased cross-covariance
cxy_u :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> Array a (Complex b) -> a -> Complex b

-- | raw auto-covariance
--   
--   Cxx(X,X) = E[(X - E[X])(X - E[X])] = E[XX] - E[X]E[X] = Rxy(X,X) -
--   E[X]^2
cxx :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> a -> Complex b

-- | biased auto-covariance
cxx_b :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> a -> Complex b

-- | unbiased auto-covariance
cxx_u :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> a -> Complex b


-- | This module contains a few algorithms for ARMA parameter estimation.
--   Algorithms are taken from Steven M. Kay, _Modern Spectral Estimation:
--   Theory and Application_, which is one of the standard texts on the
--   subject. When possible, variable conventions are the same in the code
--   as they are found in the text.
--   
--   BROKEN: DO NOT USE
module DSP.Estimation.Spectral.ARMA

-- | THIS DOES NOT WORK
arma_mywe :: (RealFloat b, Integral i, Ix i) => Array i (Complex b) -> i -> i -> Array i (Complex b)


-- | Module to perform the linear convolution of two sequences
module DSP.Convolution

-- | <tt>conv</tt> convolves two finite sequences
conv :: (Ix a, Integral a, Num b) => Array a b -> Array a b -> Array a b
test :: Bool


-- | Basic signals
module DSP.Source.Basic

-- | all zeros
zeros :: Num a => [a]

-- | single impulse
impulse :: Num a => [a]

-- | unit step
step :: Num a => [a]

-- | ramp
ramp :: Num a => [a]


-- | Basic functions for manipulating signals
module DSP.Basic

-- | <a>linspace</a> generates a list of values linearly spaced between
--   specified start and end values (array will include both start and end
--   values).
--   
--   <pre>
--   linspace 0.0 1.0 5 == [ 0.0, 0.25, 0.5, 0.75 1.0 ]
--   </pre>
linspace :: Double -> Double -> Int -> [Double]

-- | <a>logspace</a> generates a list of values logarithmically spaced
--   between the values 10 ** start and 10 ** end (array will include both
--   start and end values).
--   
--   <pre>
--   logspace 0.0 1.0 4 == [ 1.0, 2.1544, 4.6416, 10.0 ]
--   </pre>
logspace :: Double -> Double -> Int -> [Double]

-- | <a>delay</a> is the unit delay function, eg,
--   
--   <pre>
--   delay1 [ 1, 2, 3 ] == [ 0, 1, 2, 3 ]
--   </pre>
delay1 :: Num a => [a] -> [a]

-- | <a>delay</a> is the n sample delay function, eg,
--   
--   <pre>
--   delay 3 [ 1, 2, 3 ] == [ 0, 0, 0, 1, 2, 3 ]
--   </pre>
delay :: Num a => Int -> [a] -> [a]

-- | <tt>downsample</tt> throws away every n'th sample, eg,
--   
--   <pre>
--   downsample 2 [ 1, 2, 3, 4, 5, 6 ] == [ 1, 3, 5 ]
--   </pre>
downsample :: Int -> [a] -> [a]
downsampleRec :: Int -> [a] -> [a]

-- | <tt>upsample</tt> inserts n-1 zeros between each sample, eg,
--   
--   <pre>
--   upsample 2 [ 1, 2, 3 ] == [ 1, 0, 2, 0, 3, 0 ]
--   </pre>
upsample :: Num a => Int -> [a] -> [a]
upsampleRec :: Num a => Int -> [a] -> [a]

-- | <tt>upsampleAndHold</tt> replicates each sample n times, eg,
--   
--   <pre>
--   upsampleAndHold 3 [ 1, 2, 3 ] == [ 1, 1, 1, 2, 2, 2, 3, 3, 3 ]
--   </pre>
upsampleAndHold :: Int -> [a] -> [a]

-- | merges elements from two lists into one list in an alternating way
--   
--   <pre>
--   interleave [0,1,2,3] [10,11,12,13] == [0,10,1,11,2,12,3,13]
--   </pre>
interleave :: [a] -> [a] -> [a]

-- | split a list into two lists in an alternating way
--   
--   <pre>
--   uninterleave [1,2,3,4,5,6] == ([1,3,5],[2,4,6])
--   </pre>
--   
--   It's a special case of <a>split</a>.
uninterleave :: [a] -> ([a], [a])

-- | pad a sequence with zeros to length n
--   
--   <pre>
--   pad [ 1, 2, 3 ] 6 == [ 1, 2, 3, 0, 0, 0 ]
--   </pre>
pad :: (Ix a, Integral a, Num b) => Array a b -> a -> Array a b

-- | generates a <a>Just</a> if the given condition holds
toMaybe :: Bool -> a -> Maybe a

-- | Computes the square of the Euclidean norm of a 2D point
norm2sqr :: Num a => (a, a) -> a

-- | Power with fixed exponent type. This eliminates warnings about using
--   default types.
(^!) :: Num a => a -> Int -> a


-- | This module contains a few simple algorithms for interpolating the
--   peak location of a DFT/FFT.
module DSP.Estimation.Frequency.FCI

-- | Quinn's First Estimator (FCI1)
quinn1 :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> a -> b

-- | Quinn's Second Estimator (FCI2)
quinn2 :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> a -> b

-- | Quinn's Third Estimator (FCI3)
quinn3 :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> a -> b

-- | Eric Jacobsen's Estimator
jacobsen :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> a -> b

-- | MacLeod's Three Point Estimator
macleod3 :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> a -> b

-- | MacLeod's Three Point Estimator
macleod5 :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> a -> b

-- | Rife and Vincent's Estimator
rv :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> a -> b


-- | This module contains an implementation of Pisarenko Harmonic
--   Decomposition for a single real sinusoid. For this case, eigenvalues
--   do not need to be computed.
module DSP.Estimation.Frequency.Pisarenko

-- | Pisarenko's method for a single sinusoid
pisarenko :: (Ix a, Integral a, Floating b) => Array a b -> b


-- | This module contains a few algorithms for weighted linear predictors
--   for estimating the frequency of a complex sinusoid in noise.
module DSP.Estimation.Frequency.WLP

-- | The weighted linear predictor form of the frequency estimator
wlp :: (Ix a, Integral a, RealFloat b) => Array a b -> Array a (Complex b) -> b

-- | WLP using Lank, Reed, and Pollon's window
lrp :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> b

-- | WLP using kay's window
kay :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> b

-- | WLP using Lovell and Williamson's window
lw :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> b

-- | WLP using Clarkson, Kootsookos, and Quinn's window
ckq :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> b -> b -> b


-- | This module contains a few algorithms for AR parameter estimation.
--   Algorithms are taken from Steven M. Kay, /Modern Spectral Estimation:
--   Theory and Application/, which is one of the standard texts on the
--   subject. When possible, variable conventions are the same in the code
--   as they are found in the text.
module DSP.Estimation.Spectral.AR

-- | Computes an AR(p) model estimate from x using the Yule-Walker method
ar_yw :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> a -> (Array a (Complex b), b)

-- | Computes an AR(p) model estimate from x using the covariance method
ar_cov :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> a -> (Array a (Complex b), b)

-- | Computes an AR(p) model estimate from x using the modified covariance
--   method
ar_mcov :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> a -> (Array a (Complex b), b)

-- | Computes an AR(p) model estimate from x using the Burg' method
ar_burg :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> a -> (Array a (Complex b), b)


-- | This module contains one algorithm for MA parameter estimation. It is
--   taken from Steven M. Kay, _Modern Spectral Estimation: Theory and
--   Application_, which is one of the standard texts on the subject. When
--   possible, variable conventions are the same in the code as they are
--   found in the text.
module DSP.Estimation.Spectral.MA

-- | Computes an MA(q) model estimate from x using the Durbin's method
--   where l is the order of the AR process used in the algorithm
ma_durbin :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> a -> a -> (Array a (Complex b), b)


-- | Module for generating analog filter responses
--   
--   Formulas are from Oppenheim and Schafer, Appendix B
module DSP.Filter.Analog.Response

-- | Butterworth filter response function
butterworth_H :: Int -> Double -> Double -> Double

-- | Chebyshev filter response function
chebyshev1_H :: Int -> Double -> Double -> Double -> Double

-- | Inverse Chebyshev filter response function
--   
--   Note that <tt>w_c</tt> is a property of the stopband for this filter
chebyshev2_H :: Int -> Double -> Double -> Double -> Double


-- | Commonly used window functions. Except for the Parzen window, the
--   results of all of these <i>look</i> right, but I have to check them
--   against either Matlab or my C code.
--   
--   More windowing functions exist, but I have to dig through my papers to
--   find the equations.
module DSP.Window

-- | Applys a window, <tt>w</tt>, to a sequence <tt>x</tt>
window :: Array Int Double -> Array Int Double -> Array Int Double

-- | rectangular window
rectangular :: Int -> Array Int Double

-- | Bartlett window
bartlett :: Int -> Array Int Double

-- | Hanning window
hanning :: Int -> Array Int Double

-- | Hamming window
hamming :: Int -> Array Int Double

-- | Blackman window
blackman :: Int -> Array Int Double

-- | rectangular window
kaiser :: Double -> Int -> Array Int Double

-- | Generalized Hamming window
gen_hamming :: Double -> Int -> Array Int Double

-- | rectangular window
parzen :: Int -> Array Int Double


-- | This module implements the Kaiser Window Method for designing FIR
--   filters.
module DSP.Filter.FIR.Kaiser

-- | Designs a lowpass Kaiser filter
kaiser_lpf :: Double -> Double -> Double -> Double -> Array Int Double

-- | Designs a highpass Kaiser filter
kaiser_hpf :: Double -> Double -> Double -> Double -> Array Int Double


-- | <i>Deprecated: Use DSP.Window instead </i>
module DSP.Filter.FIR.Window


-- | Module to sharpen FIR filters
--   
--   Reference: Hamming, Sect 6.6
--   
--   <tt>H'(z) = 3 * H(z)^2 - s * H(z)^3</tt> <tt> = H(z)^2 * (3 - 2 *
--   H(z))</tt>
--   
--   Procedure:
--   
--   <ol>
--   <li>Filter the signal once with H(z)</li>
--   <li>Double this</li>
--   <li>Subtract this from 3x</li>
--   <li>Filter this twice by H(z) or once by H(z)^2</li>
--   </ol>
module DSP.Filter.FIR.Sharpen

-- | Filter shaprening routine
sharpen :: (Num a, Eq a) => Array Int a -> ([a] -> [a])


-- | Lowpass IIR design functions
--   
--   Method:
--   
--   <ol>
--   <li>Design analog prototype</li>
--   <li>Perform analog-to-analog frequency transformation</li>
--   <li>Perform bilinear transform</li>
--   </ol>
module DSP.Filter.IIR.Design
poly2iir :: ([a], [b]) -> (Array Int a, Array Int b)

-- | Generates lowpass Butterworth IIR filters
mkButterworth :: (Double, Double) -> (Double, Double) -> (Array Int Double, Array Int Double)

-- | Generates lowpass Chebyshev IIR filters
mkChebyshev1 :: (Double, Double) -> (Double, Double) -> (Array Int Double, Array Int Double)

-- | Generates lowpass Inverse Chebyshev IIR filters
mkChebyshev2 :: (Double, Double) -> (Double, Double) -> (Array Int Double, Array Int Double)


-- | CIC filters
--   
--   R = rate change
--   
--   M = differential delay in combs
--   
--   N = number of stages
module DSP.Multirate.CIC

-- | CIC interpolator
cic_interpolate :: Num a => Int -> Int -> Int -> [a] -> [a]

-- | CIC interpolator
cic_decimate :: Num a => Int -> Int -> Int -> [a] -> [a]


-- | Halfband interpolators and decimators
--   
--   Reference: C&amp;R
module DSP.Multirate.Halfband

-- | Halfband interpolator
hb_interp :: (Num a, Eq a) => Array Int a -> [a] -> [a]

-- | Halfband decimator
hb_decim :: (Num a, Eq a) => Array Int a -> [a] -> [a]


-- | Module for transforming a list of uniform random variables into a list
--   of normal random variables.
module Numeric.Random.Distribution.Normal

-- | Normal random variables via the Central Limit Theorm (not explicity
--   given, but see Ross)
--   
--   If mu=0 and sigma=1, then this will generate numbers in the range
--   [-n<i>2,n</i>2]
normal_clt :: Int -> (Double, Double) -> [Double] -> [Double]

-- | Normal random variables via the Box-Mueller Polar Method (Ross, pp
--   450--452)
--   
--   If mu=0 and sigma=1, then this will generate numbers in the range
--   [-8.57,8.57] assuing that the uniform RNG is really giving full
--   precision for doubles.
normal_bm :: (Double, Double) -> [Double] -> [Double]

-- | Acceptance-Rejection Method (Ross, pp 448--450)
--   
--   If mu=0 and sigma=1, then this will generate numbers in the range
--   [-36.74,36.74] assuming that the uniform RNG is really giving full
--   precision for doubles.
normal_ar :: (Double, Double) -> [Double] -> [Double]

-- | Ratio Method (Kinderman-Monahan) (Knuth, v2, 2ed, pp 125--127)
--   
--   If mu=0 and sigma=1, then this will generate numbers in the range
--   [-1e15,1e15] (?) assuming that the uniform RNG is really giving full
--   precision for doubles.
normal_r :: (Double, Double) -> [Double] -> [Double]


-- | Functions for pinking noise
--   
--   <a>http://www.firstpr.com.au/dsp/pink-noise/</a>
module Numeric.Random.Spectrum.Pink

-- | Kellet's filter
kellet :: [Double] -> [Double]

-- | Voss's algorithm
--   
--   UNTESTED, but the algorithm looks like it is working based on my hand
--   tests.
voss :: Int -> [Double] -> [Double]


-- | Radix-2 Decimation in Frequency FFT
module Numeric.Transform.Fourier.R2DIF

-- | Radix-2 Decimation in Frequency FFT
fft_r2dif :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> a -> (Array a (Complex b) -> Array a (Complex b)) -> Array a (Complex b)


-- | Radix-4 Decimation in Frequency FFT
module Numeric.Transform.Fourier.R4DIF

-- | Radix-4 Decimation in Frequency FFT
fft_r4dif :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> a -> (Array a (Complex b) -> Array a (Complex b)) -> Array a (Complex b)


-- | FFT driver functions
module Numeric.Transform.Fourier.FFT

-- | This is the driver routine for calculating FFT's. All of the recursion
--   in the various algorithms are defined in terms of <a>fft</a>.
fft :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> Array a (Complex b)

-- | Inverse FFT, including scaling factor, defined in terms of <a>fft</a>
ifft :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> Array a (Complex b)

-- | This is the algorithm for computing 2N-point real FFT with an N-point
--   complex FFT, defined in terms of <a>fft</a>
rfft :: (Ix a, Integral a, RealFloat b) => Array a b -> Array a (Complex b)

-- | This is the algorithm for computing a 2N-point real inverse FFT with
--   an N-point complex FFT, defined in terms of <a>ifft</a>
irfft :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> Array a b

-- | Algorithm for 2 N-point real FFT's computed with N-point complex FFT,
--   defined in terms of <a>fft</a>
r2fft :: (Ix a, Integral a, RealFloat b) => Array a b -> Array a b -> (Array a (Complex b), Array a (Complex b))


-- | Module to perform fast linear convolution of two sequences
module DSP.FastConvolution

-- | <tt>fast_conv</tt> convolves two finite sequences using DFT
--   relationships
fast_conv :: RealFloat b => Array Int (Complex b) -> Array Int (Complex b) -> Array Int (Complex b)


-- | Utility functions based on the FFT
module Numeric.Transform.Fourier.FFTUtils
fft_mag :: (RealFloat b, Integral a, Ix a) => Array a (Complex b) -> Array a b
fft_db :: (RealFloat b, Integral a, Ix a) => Array a (Complex b) -> Array a b
fft_phase :: (Integral a, Ix a) => Array a (Complex Double) -> Array a Double
fft_grd :: (Integral i, RealFloat a, Ix i) => Array i (Complex a) -> Array i a
fft_info :: (Integral i, Ix i) => Array i (Complex Double) -> (Array i Double, Array i Double, Array i Double, Array i Double)
rfft_mag :: (RealFloat b, Integral a, Ix a) => Array a b -> Array a b
rfft_db :: (RealFloat b, Integral a, Ix a) => Array a b -> Array a b
rfft_phase :: (Integral a, Ix a) => Array a Double -> Array a Double
rfft_grd :: (Integral i, Ix i, RealFloat a) => Array i a -> Array i a
rfft_info :: (Integral i, Ix i) => Array i Double -> (Array i Double, Array i Double, Array i Double, Array i Double)
write_fft_info :: (Ix i, Integral i) => String -> Array i (Complex Double) -> IO ()
write_rfft_info :: String -> Array Int Double -> IO ()


-- | Sliding FFT Algorithm
module Numeric.Transform.Fourier.SlidingFFT

-- | Sliding FFT
sfft :: RealFloat a => Int -> [Complex a] -> [Array Int (Complex a)]


-- | Split-Radix Decimation in Frequency FFT
module Numeric.Transform.Fourier.SRDIF

-- | Split-Radix Decimation in Frequency FFT
fft_srdif :: (Ix a, Integral a, RealFloat b) => Array a (Complex b) -> a -> (Array a (Complex b) -> Array a (Complex b)) -> Array a (Complex b)


-- | Cookbook formulae for audio EQ biquad filter coefficients by Robert
--   Bristow-Johnson <a>robert@wavemechanics.com</a>
--   
--   
--   <a>http://www.harmony-central.com/Computer/Programming/Audio-EQ-Cookbook.txt</a>
module DSP.Filter.IIR.Cookbook
lpf :: Floating a => a -> a -> [a] -> [a]
hpf :: Floating a => a -> a -> [a] -> [a]
bpf_csg :: Floating a => a -> a -> [a] -> [a]
bpf_cpg :: Floating a => a -> a -> [a] -> [a]
notch :: Floating a => a -> a -> [a] -> [a]
apf :: Floating a => a -> a -> [a] -> [a]
peakingEQ :: Floating a => a -> a -> a -> [a] -> [a]
lowShelf :: Floating a => a -> a -> a -> [a] -> [a]
highShelf :: Floating a => a -> a -> a -> [a] -> [a]
