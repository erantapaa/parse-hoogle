-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Universally Unique Identifiers with little-endian-ish encoding tools
--   
@package uuid-le
@version 0.2014.1


module Data.UUID.LittleEndian

-- | Encode a UUID into a <a>ByteString</a> in little-endian-ish byte
--   order.
toByteString :: UUID -> ByteString

-- | Extract a UUID from a <a>ByteString</a> in little-endian-ish byte
--   order. The argument must be 16 bytes long, otherwise <a>Nothing</a> is
--   returned.
fromByteString :: ByteString -> Maybe UUID

-- | Covert a UUID into a sequence of <a>Word32</a> values. When stored in
--   network byte order, this tuple encodes the UUID in little-endian-ish
--   byte order.
toWords :: UUID -> (Word32, Word32, Word32, Word32)

-- | Create a UUID from a sequence of <a>Word32</a> values. The opposite of
--   <a>toWords</a>.
fromWords :: Word32 -> Word32 -> Word32 -> Word32 -> UUID

-- | The UUID type. A <a>Random</a> instance is provided which produces
--   version 4 UUIDs as specified in RFC 4122. The <a>Storable</a> and
--   <a>Binary</a> instances are compatible with RFC 4122, storing the
--   fields in network order as 16 bytes.
data UUID :: *

-- | Convert a UUID into a hypenated string using lower-case letters.
--   Example:
--   
--   <pre>
--   toString &lt;$&gt; fromString "550e8400-e29b-41d4-a716-446655440000"
--   </pre>
toString :: UUID -> String

-- | If the passed in <a>String</a> can be parsed as a <a>UUID</a>, it will
--   be. The hyphens may not be omitted. Example:
--   
--   <pre>
--   fromString "c2cc10e1-57d6-4b6f-9899-38d972112d8c"
--   </pre>
--   
--   Hex digits may be upper or lower-case.
fromString :: String -> Maybe UUID

-- | Convert a UUID into a hyphentated string using lower-case letters,
--   packed as ASCII bytes into <a>ByteString</a>.
--   
--   This should be equivalent to <a>toString</a> with <a>pack</a>.
toASCIIBytes :: UUID -> ByteString

-- | If the passed in <a>ByteString</a> can be parsed as an ASCII
--   representation of a <a>UUID</a>, it will be. The hyphens may not be
--   omitted.
--   
--   This should be equivalent to <a>fromString</a> with <a>unpack</a>.
fromASCIIBytes :: ByteString -> Maybe UUID

-- | Similar to <a>toASCIIBytes</a> except we produce a lazy
--   <a>ByteString</a>.
toLazyASCIIBytes :: UUID -> ByteString

-- | Similar to <a>fromASCIIBytes</a> except parses from a lazy
--   <a>ByteString</a>.
fromLazyASCIIBytes :: ByteString -> Maybe UUID

-- | Returns true if the passed-in UUID is the <a>nil</a> UUID.
null :: UUID -> Bool

-- | The nil UUID, as defined in RFC 4122. It is a UUID of all zeros.
--   <tt><a>null</a> u</tt> iff <tt><tt>u</tt> == <a>nil</a></tt>.
nil :: UUID

-- | Swaps the endianity of a UUID <a>Word32</a> tuple.
swapTupleEndianity :: (Word32, Word32, Word32, Word32) -> (Word32, Word32, Word32, Word32)

-- | Swaps the endianity of a UUID byte list, if the list is at least eight
--   bytes long. Otherwise, it returns the original list.
swapListEndianity :: [Word8] -> [Word8]
