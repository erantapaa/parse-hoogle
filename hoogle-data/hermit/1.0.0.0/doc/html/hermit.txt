-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Haskell Equational Reasoning Model-to-Implementation Tunnel
--   
@package hermit
@version 1.0.0.0

module HERMIT.Parser
type Script = [ExprH]
parseScript :: String -> Either String Script
unparseScript :: Script -> String
unparseExprH :: ExprH -> String

-- | A simple expression language AST, for things parsed from <a>String</a>
--   or JSON structures.
data ExprH

-- | Variable names (refers to source code).
SrcName :: String -> ExprH

-- | Commands (to be looked up in <a>Dictionary</a>).
CmdName :: String -> ExprH

-- | Application.
AppH :: ExprH -> ExprH -> ExprH

-- | Core Fragment
CoreH :: String -> ExprH

-- | List of expressions
ListH :: [ExprH] -> ExprH
parseExprH :: String -> Either String ExprH
instance Eq ExprH
instance Show ExprH
instance Eq Token
instance Show Token

module HERMIT.GHC.Typechecker

-- | Re-Setup the typechecking environment from a ModGuts
initTcFromModGuts :: HscEnv -> ModGuts -> HscSource -> Bool -> TcM r -> IO (Messages, Maybe r)
mk_type_env :: ModGuts -> TypeEnv
tcLookupGlobal :: Name -> TcM TyThing

module HERMIT.Driver
hermitVersion :: String
ghcFlags :: [String]

-- | Entry point for HERMIT driver executable. First String in list is
--   expected to be target file name.
hermitDriver :: [String] -> IO ()
usage :: IO ()
usageOutput :: String

module HERMIT.Utilities

-- | Determine if a list contains no duplicated elements.
nodups :: Eq a => [a] -> Bool

-- | Discard the last occurrence of each element in the list. Thus the
--   returned list contains only the duplicated elements.
dups :: Eq a => [a] -> [a]

-- | Generalisation of <a>dups</a> to an arbitrary equality predicate.
dupsBy :: (a -> a -> Bool) -> [a] -> [a]
soleElement :: Monad m => [a] -> m a

-- | A generalisation of <a>equivalent</a> to any equivalence relation.
--   <tt>equivalent = equivalentBy (==)</tt>
equivalentBy :: (a -> a -> Bool) -> [a] -> Bool

-- | Determine if all elements of a list are equal.
equivalent :: Eq a => [a] -> Bool

-- | Perform the monadic action only in the <a>Just</a> case.
whenJust :: Monad m => (a -> m ()) -> Maybe a -> m ()

-- | Lift a <a>Maybe</a> into an arbitrary monad, using <a>return</a> or
--   <a>fail</a>.
maybeM :: Monad m => String -> Maybe a -> m a

module HERMIT.GHC

-- | Pretty-print an identifier.
ppIdInfo :: Id -> IdInfo -> SDoc

-- | Erase all <a>OccInfo</a> in a variable if it is is an <a>Id</a>, or do
--   nothing if it's a <a>TyVar</a> or <a>CoVar</a> (which have no
--   <a>OccInfo</a>).
zapVarOccInfo :: Var -> Var
thRdrNameGuesses :: Name -> [RdrName]

-- | Rename this namespace, as <a>varName</a> is already a function in Var.
varNameNS :: NameSpace
isQualified :: String -> Bool

-- | Compare a <a>String</a> to a <a>Name</a> for equality. Strings
--   containing a period are assumed to be fully qualified names. (Except
--   for ".", which is an unqualified reference to composition.)
cmpString2Name :: String -> Name -> Bool

-- | Compare a <a>String</a> to a <a>Var</a> for equality. See
--   <a>cmpString2Name</a>.
cmpString2Var :: String -> Var -> Bool

-- | Get the fully qualified name from a <a>Name</a>.
qualifiedName :: Name -> String

-- | Get the unqualified name from a <a>NamedThing</a>.
unqualifiedName :: NamedThing nm => nm -> String
alphaTyVars :: [TyVar]

-- | The key representation of types within the compiler
data Type :: *

-- | Vanilla type or kind variable (*never* a coercion variable)
TyVarTy :: Var -> Type

-- | Type application to something other than a <a>TyCon</a>. Parameters:
--   
--   1) Function: must <i>not</i> be a <a>TyConApp</a>, must be another
--   <a>AppTy</a>, or <a>TyVarTy</a>
--   
--   2) Argument type
AppTy :: Type -> Type -> Type

-- | Application of a <a>TyCon</a>, including newtypes <i>and</i> synonyms.
--   Invariant: saturated appliations of <tt>FunTyCon</tt> must use
--   <a>FunTy</a> and saturated synonyms must use their own constructors.
--   However, <i>unsaturated</i> <tt>FunTyCon</tt>s do appear as
--   <a>TyConApp</a>s. Parameters:
--   
--   1) Type constructor being applied to.
--   
--   2) Type arguments. Might not have enough type arguments here to
--   saturate the constructor. Even type synonyms are not necessarily
--   saturated; for example unsaturated type synonyms can appear as the
--   right hand side of a type synonym.
TyConApp :: TyCon -> [KindOrType] -> Type

-- | Special case of <a>TyConApp</a>: <tt>TyConApp FunTyCon [t1, t2]</tt>
--   See Note [Equality-constrained types]
FunTy :: Type -> Type -> Type

-- | A polymorphic type
ForAllTy :: Var -> Type -> Type

-- | Type literals are similar to type constructors.
LitTy :: TyLit -> Type
data TyLit :: *
NumTyLit :: Integer -> TyLit
StrTyLit :: FastString -> TyLit

-- | GHC's own exception type error messages all take the form:
--   
--   <pre>
--   <a>location</a>: <a>error</a>
--   
--   </pre>
--   
--   If the location is on the command line, or in GHC itself, then
--   <a>location</a>="ghc". All of the error types below correspond to a
--   <a>location</a> of "ghc", except for ProgramError (where the string is
--   assumed to contain a location already, so we don't print one).
data GhcException :: *
PhaseFailed :: String -> ExitCode -> GhcException

-- | Some other fatal signal (SIGHUP,SIGTERM)
Signal :: Int -> GhcException

-- | Prints the short usage msg after the error
UsageError :: String -> GhcException

-- | A problem with the command line arguments, but don't print usage.
CmdLineError :: String -> GhcException

-- | The <tt>impossible</tt> happened.
Panic :: String -> GhcException
PprPanic :: String -> SDoc -> GhcException

-- | The user tickled something that's known not to work yet, but we're not
--   counting it as a bug.
Sorry :: String -> GhcException
PprSorry :: String -> SDoc -> GhcException

-- | An installation problem.
InstallationError :: String -> GhcException

-- | An error in the user's code, probably.
ProgramError :: String -> GhcException
PprProgramError :: String -> SDoc -> GhcException
throwGhcException :: GhcException -> a

-- | Also copied from GHC because it is not exposed.
throwCmdLineErrorS :: DynFlags -> SDoc -> IO a

-- | An approximate, fast, version of <a>exprEtaExpandArity</a>
exprArity :: CoreExpr -> Arity
occurAnalyseExpr_NoBinderSwap :: CoreExpr -> CoreExpr

-- | Is this a kind (i.e. a type-of-types)?
isKind :: Kind -> Bool
isLiftedTypeKindCon :: TyCon -> Bool

-- | Determine if a <a>Var</a> is not an element of a <a>VarSet</a>.
notElemVarSet :: Var -> VarSet -> Bool

-- | Convert a <a>VarSet</a> to a list of user-readable strings.
varSetToStrings :: VarSet -> [String]

-- | Show a human-readable version of a <a>VarSet</a>.
showVarSet :: VarSet -> String
data Pair a :: * -> *
Pair :: a -> a -> Pair a
pFst :: Pair a -> a
pSnd :: Pair a -> a
bndrRuleAndUnfoldingVars :: Var -> VarSet
coAxiomName :: CoAxiom br -> Name
type BranchIndex = Int

-- | A <a>CoAxiom</a> is a "coercion constructor", i.e. a named equality
--   axiom.
data CoAxiom br :: * -> *
data Branched :: *
foldBag :: (r -> r -> r) -> (a -> r) -> r -> Bag a -> r
eqExprX :: IdUnfoldingFun -> RnEnv2 -> CoreExpr -> CoreExpr -> Bool

-- | Loads a system interface and throws an exception if it fails
loadSysInterface :: SDoc -> Module -> IfM lcl ModIface

-- | Finds the <a>Name</a> corresponding to the given <a>RdrName</a> in the
--   context of the <a>ModuleName</a>. Returns <tt>Nothing</tt> if no such
--   <a>Name</a> could be found. Any other condition results in an
--   exception:
--   
--   <ul>
--   <li>If the module could not be found</li>
--   <li>If we could not determine the imports of the module</li>
--   </ul>
--   
--   This is adapted from GHC's function called
--   lookupRdrNameInModuleForPlugins, but using initTcFromModGuts instead
--   of initTcInteractive. Also, we ImportBySystem instead of
--   ImportByPlugin, so the EPS gets populated with RULES and instances
--   from the loaded module.
--   
--   TODO: consider importing by plugin first, then only importing by
--   system when a name is successfully found... as written we will load
--   RULES/instances if the module loads successfully, even if the name is
--   not found.
lookupRdrNameInModule :: HscEnv -> ModGuts -> ModuleName -> RdrName -> IO (Maybe Name)

-- | Populate the EPS with a module, as if it were imported in the target
--   program.
injectDependency :: HscEnv -> ModGuts -> ModuleName -> IO ()
reportAllUnsolved :: WantedConstraints -> TcM ()
zEncodeString :: UserString -> EncodedString
getHscEnvCoreM :: CoreM HscEnv

module HERMIT.Core

-- | A program is a telescope of nested binding groups. That is, each
--   binding scopes over the remainder of the program. In GHC Core,
--   programs are encoded as [<a>CoreBind</a>]. This data type is
--   isomorphic.
data CoreProg

-- | An empty program.
ProgNil :: CoreProg

-- | A binding group and the program it scopes over.
ProgCons :: CoreBind -> CoreProg -> CoreProg

-- | A (potentially recursive) definition is an identifier and an
--   expression. In GHC Core, recursive definitions are encoded as
--   (<a>Id</a>, <a>CoreExpr</a>) pairs. This data type is isomorphic.
data CoreDef
Def :: Id -> CoreExpr -> CoreDef

-- | Unlike everything else, there is no synonym for <a>Tickish</a>
--   <a>Id</a> provided by GHC, so we define one.
type CoreTickish = Tickish Id

-- | Syntactic Equality of programs.
progSyntaxEq :: CoreProg -> CoreProg -> Bool

-- | Syntactic Equality of binding groups.
bindSyntaxEq :: CoreBind -> CoreBind -> Bool

-- | Syntactic Equality of recursive definitions.
defSyntaxEq :: CoreDef -> CoreDef -> Bool

-- | Syntactic Equality of expressions.
exprSyntaxEq :: CoreExpr -> CoreExpr -> Bool

-- | Syntactic Equality of case alternatives.
altSyntaxEq :: CoreAlt -> CoreAlt -> Bool

-- | Syntactic Equality of <a>Type</a>s.
typeSyntaxEq :: Type -> Type -> Bool

-- | Syntactic Equality of <a>Coercion</a>s.
coercionSyntaxEq :: Coercion -> Coercion -> Bool

-- | Alpha equality of programs.
progAlphaEq :: CoreProg -> CoreProg -> Bool

-- | Alpha equality of binding groups.
bindAlphaEq :: CoreBind -> CoreBind -> Bool

-- | Alpha equality of recursive definitions.
defAlphaEq :: CoreDef -> CoreDef -> Bool

-- | Alpha equality of expressions.
exprAlphaEq :: CoreExpr -> CoreExpr -> Bool

-- | Alpha equality of case alternatives.
altAlphaEq :: CoreAlt -> CoreAlt -> Bool

-- | Alpha equality of types.
typeAlphaEq :: Type -> Type -> Bool

-- | Alpha equality of coercions.
coercionAlphaEq :: Coercion -> Coercion -> Bool

-- | Convert a list of recursive definitions into an (isomorphic) recursive
--   binding group.
defsToRecBind :: [CoreDef] -> CoreBind

-- | Convert a definition to an identifier/expression pair.
defToIdExpr :: CoreDef -> (Id, CoreExpr)

-- | Get the list of bindings in a program.
progToBinds :: CoreProg -> [CoreBind]

-- | Build a program from a list of bindings. Note that bindings earlier in
--   the list are considered scope over bindings later in the list.
bindsToProg :: [CoreBind] -> CoreProg

-- | Extract the list of variable/expression pairs from a binding group.
bindToVarExprs :: CoreBind -> [(Var, CoreExpr)]

-- | List all identifiers bound at the top-level in a program.
progIds :: CoreProg -> [Id]

-- | List all variables bound in a binding group.
bindVars :: CoreBind -> [Var]

-- | Return the identifier bound by a recursive definition.
defId :: CoreDef -> Id

-- | List the variables bound by a case alternative.
altVars :: CoreAlt -> [Var]

-- | Find all free variables in a program.
freeVarsProg :: CoreProg -> VarSet

-- | Find all free identifiers in a binding group, which excludes any
--   variables bound in the group.
freeVarsBind :: CoreBind -> VarSet

-- | Find all free variables in a recursive definition, which excludes the
--   bound variable.
freeVarsDef :: CoreDef -> VarSet

-- | Find all free variables in an expression.
freeVarsExpr :: CoreExpr -> VarSet

-- | Find all free variables in a case alternative, which excludes any
--   variables bound in the alternative.
freeVarsAlt :: CoreAlt -> VarSet

-- | Find all free variables on a binder. Equivalent to idFreeVars, but
--   safe to call on type bindings.
freeVarsVar :: Var -> VarSet

-- | Find all free local variables in a case alternative, which excludes
--   any variables bound in the alternative.
localFreeVarsAlt :: CoreAlt -> VarSet

-- | Find all free variables in a type.
freeVarsType :: Type -> TyVarSet

-- | Find all free variables in a coercion.
freeVarsCoercion :: Coercion -> VarSet

-- | Find all locally defined free variables in an expression.
localFreeVarsExpr :: CoreExpr -> VarSet

-- | Find all free identifiers in an expression.
freeIdsExpr :: CoreExpr -> IdSet

-- | Find all locally defined free identifiers in an expression.
localFreeIdsExpr :: CoreExpr -> VarSet

-- | Returns <tt>True</tt> iff the expression is a <a>Coercion</a>
--   expression at its top level.
isCoArg :: CoreExpr -> Bool

-- | GHC's <a>exprType</a> function throws an error if applied to a
--   <a>Type</a>. This function returns the <a>Kind</a> of a <a>Type</a>,
--   but otherwise behaves as <a>exprType</a>.
exprKindOrType :: CoreExpr -> KindOrType

-- | GHC's <a>exprType</a> function throws an error if applied to a
--   <a>Type</a>. This function catches that case as failure in an
--   arbitrary monad.
exprTypeM :: Monad m => CoreExpr -> m Type

-- | Return the domain/codomain type of an endofunction type.
endoFunTypeM :: MonadCatch m => Type -> m ([TyVar], Type)

-- | As <a>splitTyConApp</a>, catching failure in a monad.
splitTyConAppM :: Monad m => Type -> m (TyCon, [Type])

-- | Get the quantified variables, domain, and codomain of a function type.
splitFunTypeM :: MonadCatch m => Type -> m ([TyVar], Type, Type)

-- | Return the domain/codomain type of an endofunction expression.
endoFunExprTypeM :: MonadCatch m => CoreExpr -> m ([TyVar], Type)

-- | Return the domain and codomain types of a function expression.
funExprArgResTypesM :: MonadCatch m => CoreExpr -> m ([TyVar], Type, Type)

-- | Check two expressions have types <tt>a -&gt; b</tt> and <tt>b -&gt;
--   a</tt>, returning <tt>(a,b)</tt>.
funExprsWithInverseTypes :: MonadCatch m => CoreExpr -> CoreExpr -> m (Type, Type)

-- | Count the number of nested applications.
appCount :: CoreExpr -> Int

-- | Map a function over the RHS of each case alternative.
mapAlts :: (CoreExpr -> CoreExpr) -> [CoreAlt] -> [CoreAlt]

-- | Substitute all occurrences of a variable with an expression, in a case
--   alternative.
substCoreAlt :: Var -> CoreExpr -> CoreAlt -> CoreAlt

-- | Substitute all occurrences of a variable with an expression, in an
--   expression.
substCoreExpr :: Var -> CoreExpr -> (CoreExpr -> CoreExpr)

-- | Beta-reduce as many lambda-binders as possible.
betaReduceAll :: CoreExpr -> [CoreExpr] -> (CoreExpr, [CoreExpr])

-- | Build a constructor application. Accepts a list of types to which the
--   type constructor is instantiated. Ex.
--   
--   <pre>
--   data T a b = C a b Int
--   </pre>
--   
--   Pseudocode:
--   
--   <pre>
--   mkDataConApp [a',b'] C [x,y,z] ==&gt; C a' b' (x::a') (y::b') (z::Int) :: T a' b'
--   </pre>
mkDataConApp :: [Type] -> DataCon -> [Var] -> CoreExpr

-- | Crumbs record a path through the tree, using descriptive constructor
--   names.
data Crumb
ModGuts_Prog :: Crumb
ProgCons_Head :: Crumb
ProgCons_Tail :: Crumb
NonRec_RHS :: Crumb
NonRec_Var :: Crumb
Rec_Def :: Int -> Crumb
Def_Id :: Crumb
Def_RHS :: Crumb
Var_Id :: Crumb
Lit_Lit :: Crumb
App_Fun :: Crumb
App_Arg :: Crumb
Lam_Var :: Crumb
Lam_Body :: Crumb
Let_Bind :: Crumb
Let_Body :: Crumb
Case_Scrutinee :: Crumb
Case_Binder :: Crumb
Case_Type :: Crumb
Case_Alt :: Int -> Crumb
Cast_Expr :: Crumb
Cast_Co :: Crumb
Tick_Tick :: Crumb
Tick_Expr :: Crumb
Type_Type :: Crumb
Co_Co :: Crumb
Alt_Con :: Crumb
Alt_Var :: Int -> Crumb
Alt_RHS :: Crumb
TyVarTy_TyVar :: Crumb
LitTy_TyLit :: Crumb
AppTy_Fun :: Crumb
AppTy_Arg :: Crumb
TyConApp_TyCon :: Crumb
TyConApp_Arg :: Int -> Crumb
FunTy_Dom :: Crumb
FunTy_CoDom :: Crumb
ForAllTy_Var :: Crumb
ForAllTy_Body :: Crumb
Refl_Type :: Crumb
TyConAppCo_TyCon :: Crumb
TyConAppCo_Arg :: Int -> Crumb
AppCo_Fun :: Crumb
AppCo_Arg :: Crumb
ForAllCo_TyVar :: Crumb
ForAllCo_Body :: Crumb
CoVarCo_CoVar :: Crumb
AxiomInstCo_Axiom :: Crumb
AxiomInstCo_Index :: Crumb
AxiomInstCo_Arg :: Int -> Crumb
UnsafeCo_Left :: Crumb
UnsafeCo_Right :: Crumb
SymCo_Co :: Crumb
TransCo_Left :: Crumb
TransCo_Right :: Crumb
NthCo_Int :: Crumb
NthCo_Co :: Crumb
InstCo_Co :: Crumb
InstCo_Type :: Crumb
LRCo_LR :: Crumb
LRCo_Co :: Crumb
Forall_Body :: Crumb
Conj_Lhs :: Crumb
Conj_Rhs :: Crumb
Disj_Lhs :: Crumb
Disj_Rhs :: Crumb
Impl_Lhs :: Crumb
Impl_Rhs :: Crumb
Eq_Lhs :: Crumb
Eq_Rhs :: Crumb
showCrumbs :: [Crumb] -> String

-- | Converts a <a>Crumb</a> into the <a>Crumb</a> pointing to its
--   left-sibling, if a such a <a>Crumb</a> exists. This is used for moving
--   <tt>left</tt> in the shell.
leftSibling :: Crumb -> Maybe Crumb

-- | Converts a <a>Crumb</a> into the <a>Crumb</a> pointing to its
--   right-sibling, if a such a <a>Crumb</a> exists. This is used for
--   moving <tt>right</tt> in the shell.
rightSibling :: Crumb -> Maybe Crumb
instance Eq Crumb
instance Read Crumb
instance Show Crumb

module HERMIT.Lemma
data Clause
Forall :: [CoreBndr] -> Clause -> Clause
Conj :: Clause -> Clause -> Clause
Disj :: Clause -> Clause -> Clause

-- | name for the antecedent when it is in scope
Impl :: LemmaName -> Clause -> Clause -> Clause
Equiv :: CoreExpr -> CoreExpr -> Clause
CTrue :: Clause

-- | Build a Clause from a list of universally quantified binders and two
--   expressions. If the head of either expression is a lambda expression,
--   it's binder will become a universally quantified binder over both
--   sides. It is assumed the two expressions have the same type.
--   
--   Ex. mkClause [] (x. foo x) bar === forall x. foo x = bar x mkClause []
--   (baz y z) (x. foo x x) === forall x. baz y z x = foo x x mkClause []
--   (x. foo x) (y. bar y) === forall x. foo x = bar x
mkClause :: [CoreBndr] -> CoreExpr -> CoreExpr -> Clause
mkForall :: [CoreBndr] -> Clause -> Clause
forallQs :: Clause -> [CoreBndr]

-- | Instantiate one of the universally quantified variables in a
--   <a>Clause</a>. Note: assumes implicit ordering of variables, such that
--   substitution happens to the right as it does in case alternatives.
--   Only first variable that matches predicate is instantiated.
instClause :: MonadCatch m => VarSet -> (Var -> Bool) -> CoreExpr -> Clause -> m Clause

-- | Instantiate a set of universally quantified variables in a
--   <a>Clause</a>. It is important that all type variables appear before
--   any value-level variables in the first argument.
instsClause :: MonadCatch m => VarSet -> [(Var, CoreExpr)] -> Clause -> m Clause
discardUniVars :: Clause -> Clause
freeVarsClause :: Clause -> VarSet

-- | Syntactic Equality of clauses.
clauseSyntaxEq :: Clause -> Clause -> Bool

-- | Assumes Var is free in Clause. If not, no substitution will happen,
--   though uniques might be freshened.
substClause :: Var -> CoreArg -> Clause -> Clause
substClauses :: [(Var, CoreArg)] -> Clause -> Clause
dropBinders :: Clause -> Clause
redundantDicts :: Clause -> Clause

-- | A name for lemmas. Use a newtype so we can tab-complete in shell.
newtype LemmaName
LemmaName :: String -> LemmaName

-- | An equality with a proven/used status.
data Lemma
Lemma :: Clause -> Proven -> Used -> Lemma
lemmaC :: Lemma -> Clause
lemmaP :: Lemma -> Proven
lemmaU :: Lemma -> Used
data Proven
Proven :: Proven

-- | Assumed by user
Assumed :: Proven

-- | Assumed by library/HERMIT
BuiltIn :: Proven
NotProven :: Proven
andP :: Proven -> Proven -> Proven
orP :: Proven -> Proven -> Proven
data Used

-- | this MUST be proven immediately
Obligation :: Used

-- | used, but can be proven later (only introduced in unsafe shell)
UnsafeUsed :: Used
NotUsed :: Used

-- | A collection of named lemmas.
type Lemmas = Map LemmaName Lemma

-- | A LemmaName, Lemma pair.
type NamedLemma = (LemmaName, Lemma)
instance Typeable LemmaName
instance Typeable Proven
instance Typeable Used
instance Eq LemmaName
instance Ord LemmaName
instance Eq Proven
instance Eq Used
instance Show Used
instance Ord Proven
instance Enum Proven
instance Show Proven
instance Show LemmaName
instance IsString LemmaName
instance Monoid LemmaName

module HERMIT.Context
type AbsolutePathH = AbsolutePath Crumb
type LocalPathH = LocalPath Crumb

-- | The HERMIT context, containing all bindings in scope and the current
--   location in the AST. The bindings here are lazy by choice, so that we
--   can avoid the cost of building the context if we never use it.
data HermitC

-- | A special HERMIT context intended for use only when focussed on
--   ModGuts. All top-level bindings are considered to be in scope at depth
--   0.
topLevelHermitC :: ModGuts -> HermitC

-- | Build a HermitC out of any context that has the capabilities.
toHermitC :: (HasCoreRules c, LemmaContext c, ReadBindings c, ReadPath c Crumb) => c -> HermitC

-- | HERMIT's representation of variable bindings. Bound expressions cannot
--   be inlined without checking for shadowing issues (using the depth
--   information).
data HermitBindingSite

-- | A lambda-bound variable.
LAM :: HermitBindingSite

-- | A non-recursive binding of an expression.
NONREC :: CoreExpr -> HermitBindingSite

-- | A recursive binding that does not depend on the current expression
--   (i.e. we're not in the binding group of that binding).
REC :: CoreExpr -> HermitBindingSite

-- | A recursive binding of a superexpression of the current node (i.e.
--   we're in the RHS of that binding).
SELFREC :: HermitBindingSite

-- | A recursive binding that is mutually recursive with the binding under
--   consideration (i.e. we're in another definition in the same recursive
--   binding group.).
MUTUALREC :: CoreExpr -> HermitBindingSite

-- | A variable bound in a case alternative.
CASEALT :: HermitBindingSite

-- | A case binder. We store both the scrutinised expression, and the case
--   alternative <a>AltCon</a> and variables.
CASEBINDER :: CoreExpr -> (AltCon, [Var]) -> HermitBindingSite

-- | A universally quantified type variable.
FORALL :: HermitBindingSite

-- | A special case. When we're focussed on ModGuts, we treat all top-level
--   bindings as being in scope at depth 0.
TOPLEVEL :: CoreExpr -> HermitBindingSite

-- | The depth of a binding. Used, for example, to detect shadowing when
--   inlining.
type BindingDepth = Int
data HermitBinding
hbDepth :: HermitBinding -> BindingDepth
hbSite :: HermitBinding -> HermitBindingSite
hbPath :: HermitBinding -> AbsolutePathH

-- | Retrieve the expression in a <a>HermitBindingSite</a>, if there is
--   one.
hermitBindingSiteExpr :: HermitBindingSite -> KureM CoreExpr
hermitBindingSummary :: HermitBinding -> String

-- | Retrieve the expression in a <a>HermitBinding</a>, if there is one.
hermitBindingExpr :: HermitBinding -> KureM CoreExpr

-- | A class of contexts that can have HERMIT bindings added to them.
class AddBindings c
addHermitBindings :: AddBindings c => [(Var, HermitBindingSite, AbsolutePathH)] -> c -> c

-- | Add all bindings in a binding group to a context.
addBindingGroup :: (AddBindings c, ReadPath c Crumb) => CoreBind -> c -> c

-- | Add the binding for a recursive definition currently under
--   examination. Note that because the expression may later be modified,
--   the context only records the identifier, not the expression.
addDefBinding :: (AddBindings c, ReadPath c Crumb) => Id -> c -> c

-- | Add a list of recursive bindings to the context, except the nth
--   binding in the list. The idea is to exclude the definition being
--   descended into.
addDefBindingsExcept :: (AddBindings c, ReadPath c Crumb) => Int -> [(Id, CoreExpr)] -> c -> c

-- | Add a lambda bound variable to a context. All that is known is the
--   variable, which may shadow something. If so, we don't worry about that
--   here, it is instead checked during inlining.
addLambdaBinding :: (AddBindings c, ReadPath c Crumb) => Var -> c -> c

-- | Add the variables bound by a <a>DataCon</a> in a case. They are all
--   bound at the same depth.
addAltBindings :: (AddBindings c, ReadPath c Crumb) => [Var] -> c -> c

-- | Add the case binder for a specific case alternative.
addCaseBinderBinding :: (AddBindings c, ReadPath c Crumb) => (Id, CoreExpr, CoreAlt) -> c -> c

-- | Add a universally quantified type variable to a context.
addForallBinding :: (AddBindings c, ReadPath c Crumb) => TyVar -> c -> c

-- | A class of contexts that stores the set of variables in scope that
--   have been bound during the traversal.
class BoundVars c
boundVars :: BoundVars c => c -> VarSet

-- | Determine if a variable is bound in a context.
boundIn :: ReadBindings c => Var -> c -> Bool

-- | List all variables bound in the context that match the given
--   predicate.
findBoundVars :: BoundVars c => (Var -> Bool) -> c -> VarSet

-- | A class of contexts from which HERMIT bindings can be retrieved.
class BoundVars c => ReadBindings c
hermitDepth :: ReadBindings c => c -> BindingDepth
hermitBindings :: ReadBindings c => c -> Map Var HermitBinding

-- | Lookup the binding for a variable in a context.
lookupHermitBinding :: (ReadBindings c, Monad m) => Var -> c -> m HermitBinding

-- | Lookup the depth of a variable's binding in a context.
lookupHermitBindingDepth :: (ReadBindings c, Monad m) => Var -> c -> m BindingDepth

-- | Lookup the binding for a variable in a context, ensuring it was bound
--   at the specified depth.
lookupHermitBindingSite :: (ReadBindings c, Monad m) => Var -> BindingDepth -> c -> m HermitBindingSite

-- | Determine whether a variable is in scope.
inScope :: BoundVars c => c -> Var -> Bool

-- | A class of contexts that store GHC rewrite rules.
class HasCoreRules c
hermitCoreRules :: HasCoreRules c => c -> [CoreRule]

-- | A class of contexts that can store local Lemmas as we descend past
--   implications.
class LemmaContext c
addAntecedent :: LemmaContext c => LemmaName -> Lemma -> c -> c
getAntecedents :: LemmaContext c => c -> Lemmas

-- | A class of contexts that provide an empty context.
class HasEmptyContext c
setEmptyContext :: HasEmptyContext c => c -> c
instance LemmaContext HermitC
instance HasCoreRules HermitC
instance ReadBindings HermitC
instance BoundVars HermitC
instance AddBindings HermitC
instance ExtendPath HermitC Crumb
instance ReadPath HermitC Crumb
instance HasEmptyContext HermitC
instance LemmaContext c => LemmaContext (ExtendContext c e)
instance HasCoreRules [CoreRule]
instance BoundVars VarSet
instance (AddBindings c, AddBindings e) => AddBindings (ExtendContext c e)
instance ReadPath c Crumb => ReadPath (ExtendContext c e) Crumb
instance AddBindings (SnocPath crumb)

module HERMIT.Kure.Universes

-- | Core is a KURE universe for traversing GHC Core, excluding types and
--   coercions. Core = ModGuts + CoreProg + CoreBind + CoreDef + CoreExpr +
--   CoreAlt
data Core

-- | The module.
GutsCore :: ModGuts -> Core

-- | A program (a telescope of top-level binding groups).
ProgCore :: CoreProg -> Core

-- | A binding group.
BindCore :: CoreBind -> Core

-- | A recursive definition.
DefCore :: CoreDef -> Core

-- | An expression.
ExprCore :: CoreExpr -> Core

-- | A case alternative.
AltCore :: CoreAlt -> Core

-- | TyCo is a KURE universe for traversing types and coercions. TyCo =
--   Type + Coercion
data TyCo

-- | A type.
TypeCore :: Type -> TyCo

-- | A coercion.
CoercionCore :: Coercion -> TyCo

-- | LCore is a KURE universe for traversing HERMIT lemmas and the Core
--   expressions they contain. Types and coercions are not traversed (for
--   that, use <a>LCoreTC</a>). LCore = Core + Clause
data LCore
LClause :: Clause -> LCore
LCore :: Core -> LCore

-- | LCoreTC is a KURE universe for traversing HERMIT lemmas and the Core
--   expressions they contain. Unlike <a>LCore</a>, types and coercions are
--   also traversed. LCore = LCore + TyCo
data LCoreTC
LTCCore :: LCore -> LCoreTC
LTCTyCo :: TyCo -> LCoreTC

-- | Core is a KURE universe for traversing GHC Core, including types and
--   coercions. CoreTC = Core + TyCo
data CoreTC
Core :: Core -> CoreTC
TyCo :: TyCo -> CoreTC

-- | Syntactic equality of <a>Core</a> fragments.
coreSyntaxEq :: Core -> Core -> Bool

-- | Syntactic equality of <a>TyCo</a> fragments.
tyCoSyntaxEq :: TyCo -> TyCo -> Bool

-- | Syntactic equality of <a>CoreTC</a> fragments.
coreTCSyntaxEq :: CoreTC -> CoreTC -> Bool

-- | Syntactic equality of <a>LCore</a> fragments.
lcoreSyntaxEq :: LCore -> LCore -> Bool

-- | Syntactic equality of <a>LCoreTC</a> fragments.
lcoreTCSyntaxEq :: LCoreTC -> LCoreTC -> Bool

-- | Alpha equality of <a>Core</a> fragments.
coreAlphaEq :: Core -> Core -> Bool

-- | Alpha equality of <a>TyCo</a> fragments.
tyCoAlphaEq :: TyCo -> TyCo -> Bool

-- | Alpha equality of <a>CoreTC</a> fragments.
coreTCAlphaEq :: CoreTC -> CoreTC -> Bool

-- | Find all free variables in a <a>Core</a> node.
freeVarsCore :: Core -> VarSet

-- | Find all free variables in a <a>TyCo</a> node.
freeVarsTyCo :: TyCo -> VarSet

-- | Find all free variables in a <a>CoreTC</a> node.
freeVarsCoreTC :: CoreTC -> VarSet

-- | Promote a translate on <a>ModGuts</a>.
promoteModGutsT :: (Monad m, Injection ModGuts g) => Transform c m ModGuts b -> Transform c m g b

-- | Promote a translate on <a>CoreProg</a>.
promoteProgT :: (Monad m, Injection CoreProg g) => Transform c m CoreProg b -> Transform c m g b

-- | Promote a translate on <a>CoreBind</a>.
promoteBindT :: (Monad m, Injection CoreBind g) => Transform c m CoreBind b -> Transform c m g b

-- | Promote a translate on <a>CoreDef</a>.
promoteDefT :: (Monad m, Injection CoreDef g) => Transform c m CoreDef b -> Transform c m g b

-- | Promote a translate on <a>CoreExpr</a>.
promoteExprT :: (Monad m, Injection CoreExpr g) => Transform c m CoreExpr b -> Transform c m g b

-- | Promote a translate on <a>CoreAlt</a>.
promoteAltT :: (Monad m, Injection CoreAlt g) => Transform c m CoreAlt b -> Transform c m g b

-- | Promote a translate on <a>Type</a>.
promoteTypeT :: (Monad m, Injection Type g) => Transform c m Type b -> Transform c m g b

-- | Promote a translate on <a>Coercion</a>.
promoteCoercionT :: (Monad m, Injection Coercion g) => Transform c m Coercion b -> Transform c m g b

-- | Promote a translate on <a>Clause</a>.
promoteClauseT :: (Monad m, Injection Clause g) => Transform c m Clause b -> Transform c m g b

-- | Promote a translate on <a>Core</a>.
promoteCoreT :: (Monad m, Injection Core g) => Transform c m Core b -> Transform c m g b

-- | Promote a translate on <a>LCore</a>.
promoteLCoreT :: (Monad m, Injection LCore g) => Transform c m LCore b -> Transform c m g b

-- | Promote a translate on <a>CoreTC</a>.
promoteCoreTCT :: (Monad m, Injection CoreTC g) => Transform c m CoreTC b -> Transform c m g b

-- | Promote a rewrite on <a>ModGuts</a>.
promoteModGutsR :: (Monad m, Injection ModGuts g) => Rewrite c m ModGuts -> Rewrite c m g

-- | Promote a rewrite on <a>CoreProg</a>.
promoteProgR :: (Monad m, Injection CoreProg g) => Rewrite c m CoreProg -> Rewrite c m g

-- | Promote a rewrite on <a>CoreBind</a>.
promoteBindR :: (Monad m, Injection CoreBind g) => Rewrite c m CoreBind -> Rewrite c m g

-- | Promote a rewrite on <a>CoreDef</a>.
promoteDefR :: (Monad m, Injection CoreDef g) => Rewrite c m CoreDef -> Rewrite c m g

-- | Promote a rewrite on <a>CoreExpr</a>.
promoteExprR :: (Monad m, Injection CoreExpr g) => Rewrite c m CoreExpr -> Rewrite c m g

-- | Promote a rewrite on <a>CoreAlt</a>.
promoteAltR :: (Monad m, Injection CoreAlt g) => Rewrite c m CoreAlt -> Rewrite c m g

-- | Promote a rewrite on <a>Type</a>.
promoteTypeR :: (Monad m, Injection Type g) => Rewrite c m Type -> Rewrite c m g

-- | Promote a rewrite on <a>Coercion</a>.
promoteCoercionR :: (Monad m, Injection Coercion g) => Rewrite c m Coercion -> Rewrite c m g

-- | Promote a rewrite on <a>Clause</a>.
promoteClauseR :: (Monad m, Injection Clause g) => Rewrite c m Clause -> Rewrite c m g

-- | Promote a rewrite on <a>Core</a>.
promoteCoreR :: (Monad m, Injection Core g) => Rewrite c m Core -> Rewrite c m g

-- | Promote a rewrite on <a>Core</a>.
promoteLCoreR :: (Monad m, Injection LCore g) => Rewrite c m LCore -> Rewrite c m g

-- | Promote a rewrite on <a>CoreTC</a>.
promoteCoreTCR :: (Monad m, Injection CoreTC g) => Rewrite c m CoreTC -> Rewrite c m g

-- | Promote a bidirectional rewrite on <a>CoreExpr</a>.
promoteExprBiR :: (Monad m, Injection CoreExpr g) => BiRewrite c m CoreExpr -> BiRewrite c m g
instance Injection CoreTC LCoreTC
instance Injection Coercion CoreTC
instance Injection Type CoreTC
instance Injection CoreExpr CoreTC
instance Injection CoreAlt CoreTC
instance Injection CoreDef CoreTC
instance Injection CoreBind CoreTC
instance Injection CoreProg CoreTC
instance Injection ModGuts CoreTC
instance Injection TyCo CoreTC
instance Injection Core CoreTC
instance Injection Coercion LCoreTC
instance Injection Type LCoreTC
instance Injection CoreAlt LCoreTC
instance Injection CoreDef LCoreTC
instance Injection CoreBind LCoreTC
instance Injection CoreExpr LCoreTC
instance Injection CoreProg LCoreTC
instance Injection ModGuts LCoreTC
instance Injection Core LCoreTC
instance Injection Clause LCoreTC
instance Injection CoreAlt LCore
instance Injection CoreDef LCore
instance Injection CoreBind LCore
instance Injection CoreExpr LCore
instance Injection CoreProg LCore
instance Injection ModGuts LCore
instance Injection TyCo LCoreTC
instance Injection LCore LCoreTC
instance Injection Clause LCore
instance Injection Core LCore
instance Injection Coercion TyCo
instance Injection Type TyCo
instance Injection CoreExpr Core
instance Injection CoreAlt Core
instance Injection CoreDef Core
instance Injection CoreBind Core
instance Injection CoreProg Core
instance Injection ModGuts Core

module HERMIT.Monad

-- | The HERMIT monad is kept abstract.
--   
--   It provides a reader for ModGuts, state for Lemmas, and access to a
--   debugging channel.
data HermitM a

-- | Eliminator for <a>HermitM</a>.
runHM :: HermitMEnv -> (HermitMResult a -> CoreM b) -> (String -> CoreM b) -> HermitM a -> CoreM b

-- | Allow HermitM to be embedded in another monad with proper
--   capabilities.
embedHermitM :: (HasHermitMEnv m, HasLemmas m, LiftCoreM m) => HermitM a -> m a

-- | The HermitM environment.
data HermitMEnv

-- | The HermitM result record.
data HermitMResult a
HermitMResult :: Bool -> Lemmas -> a -> HermitMResult a

-- | Whether Lemmas have changed
hResChanged :: HermitMResult a -> Bool
hResLemmas :: HermitMResult a -> Lemmas
hResult :: HermitMResult a -> a
class Monad m => LiftCoreM m
liftCoreM :: LiftCoreM m => CoreM a -> m a
getHscEnv :: LiftCoreM m => m HscEnv
runTcM :: (HasDynFlags m, HasHermitMEnv m, LiftCoreM m, MonadIO m) => TcM a -> m a
runDsM :: (HasDynFlags m, HasHermitMEnv m, LiftCoreM m, MonadIO m) => DsM a -> m a
class HasLemmas m
getLemmas :: HasLemmas m => m Lemmas
putLemmas :: HasLemmas m => Lemmas -> m ()

-- | Only adds a lemma if doesn't already exist.
addLemma :: (HasLemmas m, Monad m) => LemmaName -> Lemma -> m ()

-- | Find a lemma by name. Fails if lemma does not exist.
findLemma :: (HasLemmas m, Monad m) => LemmaName -> m Lemma

-- | Insert or replace a lemma.
insertLemma :: (HasLemmas m, Monad m) => LemmaName -> Lemma -> m ()
deleteLemma :: (HasLemmas m, Monad m) => LemmaName -> m ()
class HasHermitMEnv m
getHermitMEnv :: HasHermitMEnv m => m HermitMEnv
mkEnv :: DebugChan -> ModGuts -> Lemmas -> HermitMEnv
getModGuts :: (HasHermitMEnv m, Monad m) => m ModGuts
getDebugChan :: (HasHermitMEnv m, Monad m) => m DebugChan

-- | A message packet.
data KEnvMessage :: *
DebugTick :: String -> KEnvMessage
DebugCore :: String -> c -> LCoreTC -> KEnvMessage
AddObligation :: HermitC -> LemmaName -> Lemma -> KEnvMessage
sendKEnvMessage :: (HasHermitMEnv m, HasLemmas m, LiftCoreM m) => KEnvMessage -> m ()
instance LiftCoreM HermitM
instance HasLemmas HermitM
instance HasHermitMEnv HermitM
instance HasDynFlags HermitM
instance MonadThings HermitM
instance MonadUnique HermitM
instance MonadIO HermitM
instance MonadCatch HermitM
instance Monad HermitM
instance Applicative HermitM
instance Functor HermitM

module HERMIT.Kure
type TransformH a b = Transform HermitC HermitM a b
type RewriteH a = Rewrite HermitC HermitM a
type BiRewriteH a = BiRewrite HermitC HermitM a
type LensH a b = Lens HermitC HermitM a b
type PathH = Path Crumb
inContextM :: c -> Transform c m () a -> m a

-- | Transform a module. Slightly different to the other congruence
--   combinators: it passes in <i>all</i> of the original to the
--   reconstruction function.
modGutsT :: (ExtendPath c Crumb, HasEmptyContext c, Monad m) => Transform c m CoreProg a -> (ModGuts -> a -> b) -> Transform c m ModGuts b

-- | Rewrite the <a>CoreProg</a> child of a module.
modGutsR :: (ExtendPath c Crumb, HasEmptyContext c, Monad m) => Rewrite c m CoreProg -> Rewrite c m ModGuts

-- | Transform an empty list.
progNilT :: Monad m => b -> Transform c m CoreProg b

-- | Transform a program of the form: (<a>CoreBind</a> <tt>:</tt>
--   <a>CoreProg</a>)
progConsT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => Transform c m CoreBind a1 -> Transform c m CoreProg a2 -> (a1 -> a2 -> b) -> Transform c m CoreProg b

-- | Rewrite all children of a program of the form: (<a>CoreBind</a>
--   <tt>:</tt> <a>CoreProg</a>)
progConsAllR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => Rewrite c m CoreBind -> Rewrite c m CoreProg -> Rewrite c m CoreProg

-- | Rewrite any children of a program of the form: (<a>CoreBind</a>
--   <tt>:</tt> <a>CoreProg</a>)
progConsAnyR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => Rewrite c m CoreBind -> Rewrite c m CoreProg -> Rewrite c m CoreProg

-- | Rewrite one child of a program of the form: (<a>CoreBind</a>
--   <tt>:</tt> <a>CoreProg</a>)
progConsOneR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => Rewrite c m CoreBind -> Rewrite c m CoreProg -> Rewrite c m CoreProg

-- | Transform a binding group of the form: <tt>NonRec</tt> <a>Var</a>
--   <a>CoreExpr</a>
nonRecT :: (ExtendPath c Crumb, Monad m) => Transform c m Var a1 -> Transform c m CoreExpr a2 -> (a1 -> a2 -> b) -> Transform c m CoreBind b

-- | Rewrite all children of a binding group of the form: <tt>NonRec</tt>
--   <a>Var</a> <a>CoreExpr</a>
nonRecAllR :: (ExtendPath c Crumb, Monad m) => Rewrite c m Var -> Rewrite c m CoreExpr -> Rewrite c m CoreBind

-- | Rewrite any children of a binding group of the form: <tt>NonRec</tt>
--   <a>Var</a> <a>CoreExpr</a>
nonRecAnyR :: (ExtendPath c Crumb, MonadCatch m) => Rewrite c m Var -> Rewrite c m CoreExpr -> Rewrite c m CoreBind

-- | Rewrite one child of a binding group of the form: <tt>NonRec</tt>
--   <a>Var</a> <a>CoreExpr</a>
nonRecOneR :: (ExtendPath c Crumb, MonadCatch m) => Rewrite c m Var -> Rewrite c m CoreExpr -> Rewrite c m CoreBind

-- | Transform a binding group of the form: <tt>Rec</tt> [<a>CoreDef</a>]
recT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => (Int -> Transform c m CoreDef a) -> ([a] -> b) -> Transform c m CoreBind b

-- | Rewrite all children of a binding group of the form: <tt>Rec</tt>
--   [<a>CoreDef</a>]
recAllR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => (Int -> Rewrite c m CoreDef) -> Rewrite c m CoreBind

-- | Rewrite any children of a binding group of the form: <tt>Rec</tt>
--   [<a>CoreDef</a>]
recAnyR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => (Int -> Rewrite c m CoreDef) -> Rewrite c m CoreBind

-- | Rewrite one child of a binding group of the form: <tt>Rec</tt>
--   [<a>CoreDef</a>]
recOneR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => (Int -> Rewrite c m CoreDef) -> Rewrite c m CoreBind

-- | Transform a recursive definition of the form: <tt>Def</tt> <a>Id</a>
--   <a>CoreExpr</a>
defT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => Transform c m Id a1 -> Transform c m CoreExpr a2 -> (a1 -> a2 -> b) -> Transform c m CoreDef b

-- | Rewrite all children of a recursive definition of the form:
--   <tt>Def</tt> <a>Id</a> <a>CoreExpr</a>
defAllR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => Rewrite c m Id -> Rewrite c m CoreExpr -> Rewrite c m CoreDef

-- | Rewrite any children of a recursive definition of the form:
--   <tt>Def</tt> <a>Id</a> <a>CoreExpr</a>
defAnyR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => Rewrite c m Id -> Rewrite c m CoreExpr -> Rewrite c m CoreDef

-- | Rewrite one child of a recursive definition of the form: <tt>Def</tt>
--   <a>Id</a> <a>CoreExpr</a>
defOneR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => Rewrite c m Id -> Rewrite c m CoreExpr -> Rewrite c m CoreDef

-- | Transform a case alternative of the form: (<a>AltCon</a>,
--   [<a>Var</a>], <a>CoreExpr</a>)
altT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => Transform c m AltCon a1 -> (Int -> Transform c m Var a2) -> Transform c m CoreExpr a3 -> (a1 -> [a2] -> a3 -> b) -> Transform c m CoreAlt b

-- | Rewrite all children of a case alternative of the form:
--   (<a>AltCon</a>, <a>Id</a>, <a>CoreExpr</a>)
altAllR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => Rewrite c m AltCon -> (Int -> Rewrite c m Var) -> Rewrite c m CoreExpr -> Rewrite c m CoreAlt

-- | Rewrite any children of a case alternative of the form:
--   (<a>AltCon</a>, <a>Id</a>, <a>CoreExpr</a>)
altAnyR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => Rewrite c m AltCon -> (Int -> Rewrite c m Var) -> Rewrite c m CoreExpr -> Rewrite c m CoreAlt

-- | Rewrite one child of a case alternative of the form: (<a>AltCon</a>,
--   <a>Id</a>, <a>CoreExpr</a>)
altOneR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => Rewrite c m AltCon -> (Int -> Rewrite c m Var) -> Rewrite c m CoreExpr -> Rewrite c m CoreAlt

-- | Transform an expression of the form: <tt>Var</tt> <a>Id</a>
varT :: (ExtendPath c Crumb, Monad m) => Transform c m Id b -> Transform c m CoreExpr b

-- | Rewrite the <a>Id</a> child in an expression of the form: <tt>Var</tt>
--   <a>Id</a>
varR :: (ExtendPath c Crumb, Monad m) => Rewrite c m Id -> Rewrite c m CoreExpr

-- | Transform an expression of the form: <tt>Lit</tt> <a>Literal</a>
litT :: (ExtendPath c Crumb, Monad m) => Transform c m Literal b -> Transform c m CoreExpr b

-- | Rewrite the <a>Literal</a> child in an expression of the form:
--   <tt>Lit</tt> <a>Literal</a>
litR :: (ExtendPath c Crumb, Monad m) => Rewrite c m Literal -> Rewrite c m CoreExpr

-- | Transform an expression of the form: <tt>App</tt> <a>CoreExpr</a>
--   <a>CoreExpr</a>
appT :: (ExtendPath c Crumb, Monad m) => Transform c m CoreExpr a1 -> Transform c m CoreExpr a2 -> (a1 -> a2 -> b) -> Transform c m CoreExpr b

-- | Rewrite all children of an expression of the form: <tt>App</tt>
--   <a>CoreExpr</a> <a>CoreExpr</a>
appAllR :: (ExtendPath c Crumb, Monad m) => Rewrite c m CoreExpr -> Rewrite c m CoreExpr -> Rewrite c m CoreExpr

-- | Rewrite any children of an expression of the form: <tt>App</tt>
--   <a>CoreExpr</a> <a>CoreExpr</a>
appAnyR :: (ExtendPath c Crumb, MonadCatch m) => Rewrite c m CoreExpr -> Rewrite c m CoreExpr -> Rewrite c m CoreExpr

-- | Rewrite one child of an expression of the form: <tt>App</tt>
--   <a>CoreExpr</a> <a>CoreExpr</a>
appOneR :: (ExtendPath c Crumb, MonadCatch m) => Rewrite c m CoreExpr -> Rewrite c m CoreExpr -> Rewrite c m CoreExpr

-- | Transform an expression of the form: <tt>Lam</tt> <a>Var</a>
--   <a>CoreExpr</a>
lamT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => Transform c m Var a1 -> Transform c m CoreExpr a2 -> (a1 -> a2 -> b) -> Transform c m CoreExpr b

-- | Rewrite all children of an expression of the form: <tt>Lam</tt>
--   <a>Var</a> <a>CoreExpr</a>
lamAllR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => Rewrite c m Var -> Rewrite c m CoreExpr -> Rewrite c m CoreExpr

-- | Rewrite any children of an expression of the form: <tt>Lam</tt>
--   <a>Var</a> <a>CoreExpr</a>
lamAnyR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => Rewrite c m Var -> Rewrite c m CoreExpr -> Rewrite c m CoreExpr

-- | Rewrite one child of an expression of the form: <tt>Lam</tt>
--   <a>Var</a> <a>CoreExpr</a>
lamOneR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => Rewrite c m Var -> Rewrite c m CoreExpr -> Rewrite c m CoreExpr

-- | Transform an expression of the form: <tt>Let</tt> <a>CoreBind</a>
--   <a>CoreExpr</a>
letT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => Transform c m CoreBind a1 -> Transform c m CoreExpr a2 -> (a1 -> a2 -> b) -> Transform c m CoreExpr b

-- | Rewrite all children of an expression of the form: <tt>Let</tt>
--   <a>CoreBind</a> <a>CoreExpr</a>
letAllR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => Rewrite c m CoreBind -> Rewrite c m CoreExpr -> Rewrite c m CoreExpr

-- | Rewrite any children of an expression of the form: <tt>Let</tt>
--   <a>CoreBind</a> <a>CoreExpr</a>
letAnyR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => Rewrite c m CoreBind -> Rewrite c m CoreExpr -> Rewrite c m CoreExpr

-- | Rewrite one child of an expression of the form: <tt>Let</tt>
--   <a>CoreBind</a> <a>CoreExpr</a>
letOneR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => Rewrite c m CoreBind -> Rewrite c m CoreExpr -> Rewrite c m CoreExpr

-- | Transform an expression of the form: <tt>Case</tt> <a>CoreExpr</a>
--   <a>Id</a> <a>Type</a> [<a>CoreAlt</a>]
caseT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => Transform c m CoreExpr e -> Transform c m Id w -> Transform c m Type ty -> (Int -> Transform c m CoreAlt alt) -> (e -> w -> ty -> [alt] -> b) -> Transform c m CoreExpr b

-- | Rewrite all children of an expression of the form: <tt>Case</tt>
--   <a>CoreExpr</a> <a>Id</a> <a>Type</a> [<a>CoreAlt</a>]
caseAllR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => Rewrite c m CoreExpr -> Rewrite c m Id -> Rewrite c m Type -> (Int -> Rewrite c m CoreAlt) -> Rewrite c m CoreExpr

-- | Rewrite any children of an expression of the form: <tt>Case</tt>
--   <a>CoreExpr</a> <a>Id</a> <a>Type</a> [<a>CoreAlt</a>]
caseAnyR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => Rewrite c m CoreExpr -> Rewrite c m Id -> Rewrite c m Type -> (Int -> Rewrite c m CoreAlt) -> Rewrite c m CoreExpr

-- | Rewrite one child of an expression of the form: <tt>Case</tt>
--   <a>CoreExpr</a> <a>Id</a> <a>Type</a> [<a>CoreAlt</a>]
caseOneR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => Rewrite c m CoreExpr -> Rewrite c m Id -> Rewrite c m Type -> (Int -> Rewrite c m CoreAlt) -> Rewrite c m CoreExpr

-- | Transform an expression of the form: <tt>Cast</tt> <a>CoreExpr</a>
--   <a>Coercion</a>
castT :: (ExtendPath c Crumb, Monad m) => Transform c m CoreExpr a1 -> Transform c m Coercion a2 -> (a1 -> a2 -> b) -> Transform c m CoreExpr b

-- | Rewrite all children of an expression of the form: <tt>Cast</tt>
--   <a>CoreExpr</a> <a>Coercion</a>
castAllR :: (ExtendPath c Crumb, Monad m) => Rewrite c m CoreExpr -> Rewrite c m Coercion -> Rewrite c m CoreExpr

-- | Rewrite any children of an expression of the form: <tt>Cast</tt>
--   <a>CoreExpr</a> <a>Coercion</a>
castAnyR :: (ExtendPath c Crumb, MonadCatch m) => Rewrite c m CoreExpr -> Rewrite c m Coercion -> Rewrite c m CoreExpr

-- | Rewrite one child of an expression of the form: <tt>Cast</tt>
--   <a>CoreExpr</a> <a>Coercion</a>
castOneR :: (ExtendPath c Crumb, MonadCatch m) => Rewrite c m CoreExpr -> Rewrite c m Coercion -> Rewrite c m CoreExpr

-- | Transform an expression of the form: <tt>Tick</tt> <a>CoreTickish</a>
--   <a>CoreExpr</a>
tickT :: (ExtendPath c Crumb, Monad m) => Transform c m CoreTickish a1 -> Transform c m CoreExpr a2 -> (a1 -> a2 -> b) -> Transform c m CoreExpr b

-- | Rewrite all children of an expression of the form: <tt>Tick</tt>
--   <a>CoreTickish</a> <a>CoreExpr</a>
tickAllR :: (ExtendPath c Crumb, Monad m) => Rewrite c m CoreTickish -> Rewrite c m CoreExpr -> Rewrite c m CoreExpr

-- | Rewrite any children of an expression of the form: <tt>Tick</tt>
--   <a>CoreTickish</a> <a>CoreExpr</a>
tickAnyR :: (ExtendPath c Crumb, MonadCatch m) => Rewrite c m CoreTickish -> Rewrite c m CoreExpr -> Rewrite c m CoreExpr

-- | Rewrite any children of an expression of the form: <tt>Tick</tt>
--   <a>CoreTickish</a> <a>CoreExpr</a>
tickOneR :: (ExtendPath c Crumb, MonadCatch m) => Rewrite c m CoreTickish -> Rewrite c m CoreExpr -> Rewrite c m CoreExpr

-- | Transform an expression of the form: <tt>Type</tt> <a>Type</a>
typeT :: (ExtendPath c Crumb, Monad m) => Transform c m Type b -> Transform c m CoreExpr b

-- | Rewrite the <a>Type</a> child in an expression of the form:
--   <tt>Type</tt> <a>Type</a>
typeR :: (ExtendPath c Crumb, Monad m) => Rewrite c m Type -> Rewrite c m CoreExpr

-- | Transform an expression of the form: <tt>Coercion</tt> <a>Coercion</a>
coercionT :: (ExtendPath c Crumb, Monad m) => Transform c m Coercion b -> Transform c m CoreExpr b

-- | Rewrite the <a>Coercion</a> child in an expression of the form:
--   <tt>Coercion</tt> <a>Coercion</a>
coercionR :: (ExtendPath c Crumb, Monad m) => Rewrite c m Coercion -> Rewrite c m CoreExpr

-- | Transform a definition of the form <tt>NonRec <a>Var</a>
--   <a>CoreExpr</a></tt> or <tt>Def <a>Id</a> <a>CoreExpr</a></tt>
defOrNonRecT :: (Injection CoreBind g, Injection CoreDef g, ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => Transform c m Var a1 -> Transform c m CoreExpr a2 -> (a1 -> a2 -> b) -> Transform c m g b

-- | Rewrite all children of a definition of the form <tt>NonRec <a>Var</a>
--   <a>CoreExpr</a></tt> or <tt>Def <a>Id</a> <a>CoreExpr</a></tt>
defOrNonRecAllR :: (Injection CoreBind g, Injection CoreDef g, ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => Rewrite c m Var -> Rewrite c m CoreExpr -> Rewrite c m g

-- | Rewrite any children of a definition of the form <tt>NonRec <a>Var</a>
--   <a>CoreExpr</a></tt> or <tt>Def <a>Id</a> <a>CoreExpr</a></tt>
defOrNonRecAnyR :: (Injection CoreBind g, Injection CoreDef g, ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => Rewrite c m Var -> Rewrite c m CoreExpr -> Rewrite c m g

-- | Rewrite one child of a definition of the form <tt>NonRec <a>Var</a>
--   <a>CoreExpr</a></tt> or <tt>Def <a>Id</a> <a>CoreExpr</a></tt>
defOrNonRecOneR :: (Injection CoreBind g, Injection CoreDef g, ExtendPath c Crumb, AddBindings c, MonadCatch m) => Rewrite c m Var -> Rewrite c m CoreExpr -> Rewrite c m g

-- | Transform a binding group of the form: <tt>Rec</tt> [(<a>Id</a>,
--   <a>CoreExpr</a>)]
recDefT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => (Int -> (Transform c m Id a1, Transform c m CoreExpr a2)) -> ([(a1, a2)] -> b) -> Transform c m CoreBind b

-- | Rewrite all children of a binding group of the form: <tt>Rec</tt>
--   [(<a>Id</a>, <a>CoreExpr</a>)]
recDefAllR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => (Int -> (Rewrite c m Id, Rewrite c m CoreExpr)) -> Rewrite c m CoreBind

-- | Rewrite any children of a binding group of the form: <tt>Rec</tt>
--   [(<a>Id</a>, <a>CoreExpr</a>)]
recDefAnyR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => (Int -> (Rewrite c m Id, Rewrite c m CoreExpr)) -> Rewrite c m CoreBind

-- | Rewrite one child of a binding group of the form: <tt>Rec</tt>
--   [(<a>Id</a>, <a>CoreExpr</a>)]
recDefOneR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => (Int -> (Rewrite c m Id, Rewrite c m CoreExpr)) -> Rewrite c m CoreBind

-- | Transform an expression of the form: <tt>Let</tt> (<tt>NonRec</tt>
--   <a>Var</a> <a>CoreExpr</a>) <a>CoreExpr</a>
letNonRecT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => Transform c m Var a1 -> Transform c m CoreExpr a2 -> Transform c m CoreExpr a3 -> (a1 -> a2 -> a3 -> b) -> Transform c m CoreExpr b

-- | Rewrite all children of an expression of the form: <tt>Let</tt>
--   (<tt>NonRec</tt> <a>Var</a> <a>CoreExpr</a>) <a>CoreExpr</a>
letNonRecAllR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => Rewrite c m Var -> Rewrite c m CoreExpr -> Rewrite c m CoreExpr -> Rewrite c m CoreExpr

-- | Rewrite any children of an expression of the form: <tt>Let</tt>
--   (<tt>NonRec</tt> <a>Var</a> <a>CoreExpr</a>) <a>CoreExpr</a>
letNonRecAnyR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => Rewrite c m Var -> Rewrite c m CoreExpr -> Rewrite c m CoreExpr -> Rewrite c m CoreExpr

-- | Rewrite one child of an expression of the form: <tt>Let</tt>
--   (<tt>NonRec</tt> <a>Var</a> <a>CoreExpr</a>) <a>CoreExpr</a>
letNonRecOneR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => Rewrite c m Var -> Rewrite c m CoreExpr -> Rewrite c m CoreExpr -> Rewrite c m CoreExpr

-- | Transform an expression of the form: <tt>Let</tt> (<tt>Rec</tt>
--   [<a>CoreDef</a>]) <a>CoreExpr</a>
letRecT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => (Int -> Transform c m CoreDef a1) -> Transform c m CoreExpr a2 -> ([a1] -> a2 -> b) -> Transform c m CoreExpr b

-- | Rewrite all children of an expression of the form: <tt>Let</tt>
--   (<tt>Rec</tt> [<a>CoreDef</a>]) <a>CoreExpr</a>
letRecAllR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => (Int -> Rewrite c m CoreDef) -> Rewrite c m CoreExpr -> Rewrite c m CoreExpr

-- | Rewrite any children of an expression of the form: <tt>Let</tt>
--   (<tt>Rec</tt> [<a>CoreDef</a>]) <a>CoreExpr</a>
letRecAnyR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => (Int -> Rewrite c m CoreDef) -> Rewrite c m CoreExpr -> Rewrite c m CoreExpr

-- | Rewrite one child of an expression of the form: <tt>Let</tt>
--   (<tt>Rec</tt> [<a>CoreDef</a>]) <a>CoreExpr</a>
letRecOneR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => (Int -> Rewrite c m CoreDef) -> Rewrite c m CoreExpr -> Rewrite c m CoreExpr

-- | Transform an expression of the form: <tt>Let</tt> (<tt>Rec</tt>
--   [(<a>Id</a>, <a>CoreExpr</a>)]) <a>CoreExpr</a>
letRecDefT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => (Int -> (Transform c m Id a1, Transform c m CoreExpr a2)) -> Transform c m CoreExpr a3 -> ([(a1, a2)] -> a3 -> b) -> Transform c m CoreExpr b

-- | Rewrite all children of an expression of the form: <tt>Let</tt>
--   (<tt>Rec</tt> [(<a>Id</a>, <a>CoreExpr</a>)]) <a>CoreExpr</a>
letRecDefAllR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => (Int -> (Rewrite c m Id, Rewrite c m CoreExpr)) -> Rewrite c m CoreExpr -> Rewrite c m CoreExpr

-- | Rewrite any children of an expression of the form: <tt>Let</tt>
--   (<tt>Rec</tt> [(<a>Id</a>, <a>CoreExpr</a>)]) <a>CoreExpr</a>
letRecDefAnyR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => (Int -> (Rewrite c m Id, Rewrite c m CoreExpr)) -> Rewrite c m CoreExpr -> Rewrite c m CoreExpr

-- | Rewrite one child of an expression of the form: <tt>Let</tt>
--   (<tt>Rec</tt> [(<a>Id</a>, <a>CoreExpr</a>)]) <a>CoreExpr</a>
letRecDefOneR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => (Int -> (Rewrite c m Id, Rewrite c m CoreExpr)) -> Rewrite c m CoreExpr -> Rewrite c m CoreExpr

-- | Transform a program of the form: (<tt>NonRec</tt> <a>Var</a>
--   <a>CoreExpr</a>) <tt>:</tt> <a>CoreProg</a>
consNonRecT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => Transform c m Var a1 -> Transform c m CoreExpr a2 -> Transform c m CoreProg a3 -> (a1 -> a2 -> a3 -> b) -> Transform c m CoreProg b

-- | Rewrite all children of an expression of the form: (<tt>NonRec</tt>
--   <a>Var</a> <a>CoreExpr</a>) <tt>:</tt> <a>CoreProg</a>
consNonRecAllR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => Rewrite c m Var -> Rewrite c m CoreExpr -> Rewrite c m CoreProg -> Rewrite c m CoreProg

-- | Rewrite any children of an expression of the form: (<tt>NonRec</tt>
--   <a>Var</a> <a>CoreExpr</a>) <tt>:</tt> <a>CoreProg</a>
consNonRecAnyR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => Rewrite c m Var -> Rewrite c m CoreExpr -> Rewrite c m CoreProg -> Rewrite c m CoreProg

-- | Rewrite one child of an expression of the form: (<tt>NonRec</tt>
--   <a>Var</a> <a>CoreExpr</a>) <tt>:</tt> <a>CoreProg</a>
consNonRecOneR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => Rewrite c m Var -> Rewrite c m CoreExpr -> Rewrite c m CoreProg -> Rewrite c m CoreProg

-- | Transform an expression of the form: (<tt>Rec</tt> [<a>CoreDef</a>])
--   <tt>:</tt> <a>CoreProg</a>
consRecT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => (Int -> Transform c m CoreDef a1) -> Transform c m CoreProg a2 -> ([a1] -> a2 -> b) -> Transform c m CoreProg b

-- | Rewrite all children of an expression of the form: (<tt>Rec</tt>
--   [<a>CoreDef</a>]) <tt>:</tt> <a>CoreProg</a>
consRecAllR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => (Int -> Rewrite c m CoreDef) -> Rewrite c m CoreProg -> Rewrite c m CoreProg

-- | Rewrite any children of an expression of the form: (<tt>Rec</tt>
--   [<a>CoreDef</a>]) <tt>:</tt> <a>CoreProg</a>
consRecAnyR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => (Int -> Rewrite c m CoreDef) -> Rewrite c m CoreProg -> Rewrite c m CoreProg

-- | Rewrite one child of an expression of the form: (<tt>Rec</tt>
--   [<a>CoreDef</a>]) <tt>:</tt> <a>CoreProg</a>
consRecOneR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => (Int -> Rewrite c m CoreDef) -> Rewrite c m CoreProg -> Rewrite c m CoreProg

-- | Transform an expression of the form: (<tt>Rec</tt> [(<a>Id</a>,
--   <a>CoreExpr</a>)]) <tt>:</tt> <a>CoreProg</a>
consRecDefT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => (Int -> (Transform c m Id a1, Transform c m CoreExpr a2)) -> Transform c m CoreProg a3 -> ([(a1, a2)] -> a3 -> b) -> Transform c m CoreProg b

-- | Rewrite all children of an expression of the form: (<tt>Rec</tt>
--   [(<a>Id</a>, <a>CoreExpr</a>)]) <tt>:</tt> <a>CoreProg</a>
consRecDefAllR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => (Int -> (Rewrite c m Id, Rewrite c m CoreExpr)) -> Rewrite c m CoreProg -> Rewrite c m CoreProg

-- | Rewrite any children of an expression of the form: (<tt>Rec</tt>
--   [(<a>Id</a>, <a>CoreExpr</a>)]) <tt>:</tt> <a>CoreProg</a>
consRecDefAnyR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => (Int -> (Rewrite c m Id, Rewrite c m CoreExpr)) -> Rewrite c m CoreProg -> Rewrite c m CoreProg

-- | Rewrite one child of an expression of the form: (<tt>Rec</tt>
--   [(<a>Id</a>, <a>CoreExpr</a>)]) <tt>:</tt> <a>CoreProg</a>
consRecDefOneR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => (Int -> (Rewrite c m Id, Rewrite c m CoreExpr)) -> Rewrite c m CoreProg -> Rewrite c m CoreProg

-- | Transform an expression of the form: <tt>Case</tt> <a>CoreExpr</a>
--   <a>Id</a> <a>Type</a> [(<a>AltCon</a>, [<a>Var</a>], <a>CoreExpr</a>)]
caseAltT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => Transform c m CoreExpr sc -> Transform c m Id w -> Transform c m Type ty -> (Int -> (Transform c m AltCon con, Int -> Transform c m Var v, Transform c m CoreExpr rhs)) -> (sc -> w -> ty -> [(con, [v], rhs)] -> b) -> Transform c m CoreExpr b

-- | Rewrite all children of an expression of the form: <tt>Case</tt>
--   <a>CoreExpr</a> <a>Id</a> <a>Type</a> [(<a>AltCon</a>, [<a>Var</a>],
--   <a>CoreExpr</a>)]
caseAltAllR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => Rewrite c m CoreExpr -> Rewrite c m Id -> Rewrite c m Type -> (Int -> (Rewrite c m AltCon, Int -> Rewrite c m Var, Rewrite c m CoreExpr)) -> Rewrite c m CoreExpr

-- | Rewrite any children of an expression of the form: <tt>Case</tt>
--   <a>CoreExpr</a> <a>Id</a> <a>Type</a> [(<a>AltCon</a>, [<a>Var</a>],
--   <a>CoreExpr</a>)]
caseAltAnyR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => Rewrite c m CoreExpr -> Rewrite c m Id -> Rewrite c m Type -> (Int -> (Rewrite c m AltCon, Int -> Rewrite c m Var, Rewrite c m CoreExpr)) -> Rewrite c m CoreExpr

-- | Rewrite one child of an expression of the form: <tt>Case</tt>
--   <a>CoreExpr</a> <a>Id</a> <a>Type</a> [(<a>AltCon</a>, [<a>Var</a>],
--   <a>CoreExpr</a>)]
caseAltOneR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => Rewrite c m CoreExpr -> Rewrite c m Id -> Rewrite c m Type -> (Int -> (Rewrite c m AltCon, Int -> Rewrite c m Var, Rewrite c m CoreExpr)) -> Rewrite c m CoreExpr

-- | Transform all top-level binding groups in a program.
progBindsT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => (Int -> Transform c m CoreBind a) -> ([a] -> b) -> Transform c m CoreProg b

-- | Rewrite all top-level binding groups in a program.
progBindsAllR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => (Int -> Rewrite c m CoreBind) -> Rewrite c m CoreProg

-- | Rewrite any top-level binding groups in a program.
progBindsAnyR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => (Int -> Rewrite c m CoreBind) -> Rewrite c m CoreProg

-- | Rewrite any top-level binding groups in a program.
progBindsOneR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => (Int -> Rewrite c m CoreBind) -> Rewrite c m CoreProg

-- | Transform a type of the form: <tt>TyVarTy</tt> <a>TyVar</a>
tyVarT :: (ExtendPath c Crumb, Monad m) => Transform c m TyVar b -> Transform c m Type b

-- | Rewrite the <a>TyVar</a> child of a type of the form: <tt>TyVarTy</tt>
--   <a>TyVar</a>
tyVarR :: (ExtendPath c Crumb, Monad m) => Rewrite c m TyVar -> Rewrite c m Type

-- | Transform a type of the form: <tt>LitTy</tt> <a>TyLit</a>
litTyT :: (ExtendPath c Crumb, Monad m) => Transform c m TyLit b -> Transform c m Type b

-- | Rewrite the <a>TyLit</a> child of a type of the form: <tt>LitTy</tt>
--   <a>TyLit</a>
litTyR :: (ExtendPath c Crumb, Monad m) => Rewrite c m TyLit -> Rewrite c m Type

-- | Transform a type of the form: <tt>AppTy</tt> <a>Type</a> <a>Type</a>
appTyT :: (ExtendPath c Crumb, Monad m) => Transform c m Type a1 -> Transform c m Type a2 -> (a1 -> a2 -> b) -> Transform c m Type b

-- | Rewrite all children of a type of the form: <tt>AppTy</tt> <a>Type</a>
--   <a>Type</a>
appTyAllR :: (ExtendPath c Crumb, Monad m) => Rewrite c m Type -> Rewrite c m Type -> Rewrite c m Type

-- | Rewrite any children of a type of the form: <tt>AppTy</tt> <a>Type</a>
--   <a>Type</a>
appTyAnyR :: (ExtendPath c Crumb, MonadCatch m) => Rewrite c m Type -> Rewrite c m Type -> Rewrite c m Type

-- | Rewrite one child of a type of the form: <tt>AppTy</tt> <a>Type</a>
--   <a>Type</a>
appTyOneR :: (ExtendPath c Crumb, MonadCatch m) => Rewrite c m Type -> Rewrite c m Type -> Rewrite c m Type

-- | Transform a type of the form: <tt>FunTy</tt> <a>Type</a> <a>Type</a>
funTyT :: (ExtendPath c Crumb, Monad m) => Transform c m Type a1 -> Transform c m Type a2 -> (a1 -> a2 -> b) -> Transform c m Type b

-- | Rewrite all children of a type of the form: <tt>FunTy</tt> <a>Type</a>
--   <a>Type</a>
funTyAllR :: (ExtendPath c Crumb, Monad m) => Rewrite c m Type -> Rewrite c m Type -> Rewrite c m Type

-- | Rewrite any children of a type of the form: <tt>FunTy</tt> <a>Type</a>
--   <a>Type</a>
funTyAnyR :: (ExtendPath c Crumb, MonadCatch m) => Rewrite c m Type -> Rewrite c m Type -> Rewrite c m Type

-- | Rewrite one child of a type of the form: <tt>FunTy</tt> <a>Type</a>
--   <a>Type</a>
funTyOneR :: (ExtendPath c Crumb, MonadCatch m) => Rewrite c m Type -> Rewrite c m Type -> Rewrite c m Type

-- | Transform a type of the form: <tt>ForAllTy</tt> <a>Var</a> <a>Type</a>
forAllTyT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => Transform c m Var a1 -> Transform c m Type a2 -> (a1 -> a2 -> b) -> Transform c m Type b

-- | Rewrite all children of a type of the form: <tt>ForAllTy</tt>
--   <a>Var</a> <a>Type</a>
forAllTyAllR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => Rewrite c m Var -> Rewrite c m Type -> Rewrite c m Type

-- | Rewrite any children of a type of the form: <tt>ForAllTy</tt>
--   <a>Var</a> <a>Type</a>
forAllTyAnyR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => Rewrite c m Var -> Rewrite c m Type -> Rewrite c m Type

-- | Rewrite one child of a type of the form: <tt>ForAllTy</tt> <a>Var</a>
--   <a>Type</a>
forAllTyOneR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => Rewrite c m Var -> Rewrite c m Type -> Rewrite c m Type

-- | Transform a type of the form: <tt>TyConApp</tt> <a>TyCon</a>
--   [<a>KindOrType</a>]
tyConAppT :: (ExtendPath c Crumb, Monad m) => Transform c m TyCon a1 -> (Int -> Transform c m KindOrType a2) -> (a1 -> [a2] -> b) -> Transform c m Type b

-- | Rewrite all children of a type of the form: <tt>TyConApp</tt>
--   <a>TyCon</a> [<a>KindOrType</a>]
tyConAppAllR :: (ExtendPath c Crumb, Monad m) => Rewrite c m TyCon -> (Int -> Rewrite c m KindOrType) -> Rewrite c m Type

-- | Rewrite any children of a type of the form: <tt>TyConApp</tt>
--   <a>TyCon</a> [<a>KindOrType</a>]
tyConAppAnyR :: (ExtendPath c Crumb, MonadCatch m) => Rewrite c m TyCon -> (Int -> Rewrite c m KindOrType) -> Rewrite c m Type

-- | Rewrite one child of a type of the form: <tt>TyConApp</tt>
--   <a>TyCon</a> [<a>KindOrType</a>]
tyConAppOneR :: (ExtendPath c Crumb, MonadCatch m) => Rewrite c m TyCon -> (Int -> Rewrite c m KindOrType) -> Rewrite c m Type

-- | Transform a coercion of the form: <tt>Refl</tt> <a>Role</a>
--   <a>Type</a>
reflT :: (ExtendPath c Crumb, Monad m) => Transform c m Type a1 -> (Role -> a1 -> b) -> Transform c m Coercion b

-- | Rewrite the <a>Type</a> child of a coercion of the form: <tt>Refl</tt>
--   <a>Role</a> <a>Type</a>
reflR :: (ExtendPath c Crumb, Monad m) => Rewrite c m Type -> Rewrite c m Coercion

-- | Transform a coercion of the form: <tt>TyConAppCo</tt> <a>Role</a>
--   <a>TyCon</a> [<a>Coercion</a>]
tyConAppCoT :: (ExtendPath c Crumb, Monad m) => Transform c m TyCon a1 -> (Int -> Transform c m Coercion a2) -> (Role -> a1 -> [a2] -> b) -> Transform c m Coercion b

-- | Rewrite all children of a coercion of the form: <tt>TyConAppCo</tt>
--   <a>TyCon</a> [<a>Coercion</a>]
tyConAppCoAllR :: (ExtendPath c Crumb, Monad m) => Rewrite c m TyCon -> (Int -> Rewrite c m Coercion) -> Rewrite c m Coercion

-- | Rewrite any children of a coercion of the form: <tt>TyConAppCo</tt>
--   <a>TyCon</a> [<a>Coercion</a>]
tyConAppCoAnyR :: (ExtendPath c Crumb, MonadCatch m) => Rewrite c m TyCon -> (Int -> Rewrite c m Coercion) -> Rewrite c m Coercion

-- | Rewrite one child of a coercion of the form: <tt>TyConAppCo</tt>
--   <a>TyCon</a> [<a>Coercion</a>]
tyConAppCoOneR :: (ExtendPath c Crumb, MonadCatch m) => Rewrite c m TyCon -> (Int -> Rewrite c m Coercion) -> Rewrite c m Coercion

-- | Transform a coercion of the form: <tt>AppCo</tt> <a>Coercion</a>
--   <a>Coercion</a>
appCoT :: (ExtendPath c Crumb, Monad m) => Transform c m Coercion a1 -> Transform c m Coercion a2 -> (a1 -> a2 -> b) -> Transform c m Coercion b

-- | Rewrite all children of a coercion of the form: <tt>AppCo</tt>
--   <a>Coercion</a> <a>Coercion</a>
appCoAllR :: (ExtendPath c Crumb, Monad m) => Rewrite c m Coercion -> Rewrite c m Coercion -> Rewrite c m Coercion

-- | Rewrite any children of a coercion of the form: <tt>AppCo</tt>
--   <a>Coercion</a> <a>Coercion</a>
appCoAnyR :: (ExtendPath c Crumb, MonadCatch m) => Rewrite c m Coercion -> Rewrite c m Coercion -> Rewrite c m Coercion

-- | Rewrite one child of a coercion of the form: <tt>AppCo</tt>
--   <a>Coercion</a> <a>Coercion</a>
appCoOneR :: (ExtendPath c Crumb, MonadCatch m) => Rewrite c m Coercion -> Rewrite c m Coercion -> Rewrite c m Coercion

-- | Transform a coercion of the form: <tt>ForAllCo</tt> <a>TyVar</a>
--   <a>Coercion</a>
forAllCoT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => Transform c m TyVar a1 -> Transform c m Coercion a2 -> (a1 -> a2 -> b) -> Transform c m Coercion b

-- | Rewrite all children of a coercion of the form: <tt>ForAllCo</tt>
--   <a>TyVar</a> <a>Coercion</a>
forAllCoAllR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => Rewrite c m TyVar -> Rewrite c m Coercion -> Rewrite c m Coercion

-- | Rewrite any children of a coercion of the form: <tt>ForAllCo</tt>
--   <a>TyVar</a> <a>Coercion</a>
forAllCoAnyR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => Rewrite c m TyVar -> Rewrite c m Coercion -> Rewrite c m Coercion

-- | Rewrite one child of a coercion of the form: <tt>ForAllCo</tt>
--   <a>TyVar</a> <a>Coercion</a>
forAllCoOneR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => Rewrite c m TyVar -> Rewrite c m Coercion -> Rewrite c m Coercion

-- | Transform a coercion of the form: <tt>CoVarCo</tt> <a>CoVar</a>
coVarCoT :: (ExtendPath c Crumb, Monad m) => Transform c m CoVar b -> Transform c m Coercion b

-- | Rewrite the <a>CoVar</a> child of a coercion of the form:
--   <tt>CoVarCo</tt> <a>CoVar</a>
coVarCoR :: (ExtendPath c Crumb, Monad m) => Rewrite c m CoVar -> Rewrite c m Coercion

-- | Transform a coercion of the form: <tt>AxiomInstCo</tt> (<a>CoAxiom</a>
--   <a>Branched</a>) <a>BranchIndex</a> [<a>Coercion</a>]
axiomInstCoT :: (ExtendPath c Crumb, Monad m) => Transform c m (CoAxiom Branched) a1 -> Transform c m BranchIndex a2 -> (Int -> Transform c m Coercion a3) -> (a1 -> a2 -> [a3] -> b) -> Transform c m Coercion b

-- | Rewrite all children of a coercion of the form: <tt>AxiomInstCo</tt>
--   (<a>CoAxiom</a> <a>Branched</a>) <a>BranchIndex</a> [<a>Coercion</a>]
axiomInstCoAllR :: (ExtendPath c Crumb, Monad m) => Rewrite c m (CoAxiom Branched) -> Rewrite c m BranchIndex -> (Int -> Rewrite c m Coercion) -> Rewrite c m Coercion

-- | Rewrite any children of a coercion of the form: <tt>AxiomInstCo</tt>
--   (<a>CoAxiom</a> <a>Branched</a>) <a>BranchIndex</a> [<a>Coercion</a>]
axiomInstCoAnyR :: (ExtendPath c Crumb, MonadCatch m) => Rewrite c m (CoAxiom Branched) -> Rewrite c m BranchIndex -> (Int -> Rewrite c m Coercion) -> Rewrite c m Coercion

-- | Rewrite one child of a coercion of the form: <tt>AxiomInstCo</tt>
--   (<a>CoAxiom</a> <a>Branched</a>) <a>BranchIndex</a> [<a>Coercion</a>]
axiomInstCoOneR :: (ExtendPath c Crumb, MonadCatch m) => Rewrite c m (CoAxiom Branched) -> Rewrite c m BranchIndex -> (Int -> Rewrite c m Coercion) -> Rewrite c m Coercion

-- | Transform a coercion of the form: <tt>SymCo</tt> <a>Coercion</a>
symCoT :: (ExtendPath c Crumb, Monad m) => Transform c m Coercion b -> Transform c m Coercion b

-- | Rewrite the <a>Coercion</a> child of a coercion of the form:
--   <tt>SymCo</tt> <a>Coercion</a>
symCoR :: (ExtendPath c Crumb, Monad m) => Rewrite c m Coercion -> Rewrite c m Coercion

-- | Transform a coercion of the form: <tt>TransCo</tt> <a>Coercion</a>
--   <a>Coercion</a>
transCoT :: (ExtendPath c Crumb, Monad m) => Transform c m Coercion a1 -> Transform c m Coercion a2 -> (a1 -> a2 -> b) -> Transform c m Coercion b

-- | Rewrite all children of a coercion of the form: <tt>TransCo</tt>
--   <a>Coercion</a> <a>Coercion</a>
transCoAllR :: (ExtendPath c Crumb, Monad m) => Rewrite c m Coercion -> Rewrite c m Coercion -> Rewrite c m Coercion

-- | Rewrite any children of a coercion of the form: <tt>TransCo</tt>
--   <a>Coercion</a> <a>Coercion</a>
transCoAnyR :: (ExtendPath c Crumb, MonadCatch m) => Rewrite c m Coercion -> Rewrite c m Coercion -> Rewrite c m Coercion

-- | Rewrite one child of a coercion of the form: <tt>TransCo</tt>
--   <a>Coercion</a> <a>Coercion</a>
transCoOneR :: (ExtendPath c Crumb, MonadCatch m) => Rewrite c m Coercion -> Rewrite c m Coercion -> Rewrite c m Coercion

-- | Transform a coercion of the form: <tt>NthCo</tt> <a>Int</a>
--   <a>Coercion</a>
nthCoT :: (ExtendPath c Crumb, Monad m) => Transform c m Int a1 -> Transform c m Coercion a2 -> (a1 -> a2 -> b) -> Transform c m Coercion b

-- | Rewrite all children of a coercion of the form: <tt>NthCo</tt>
--   <a>Int</a> <a>Coercion</a>
nthCoAllR :: (ExtendPath c Crumb, Monad m) => Rewrite c m Int -> Rewrite c m Coercion -> Rewrite c m Coercion

-- | Rewrite any children of a coercion of the form: <tt>NthCo</tt>
--   <a>Int</a> <a>Coercion</a>
nthCoAnyR :: (ExtendPath c Crumb, MonadCatch m) => Rewrite c m Int -> Rewrite c m Coercion -> Rewrite c m Coercion

-- | Rewrite one child of a coercion of the form: <tt>NthCo</tt> <a>Int</a>
--   <a>Coercion</a>
nthCoOneR :: (ExtendPath c Crumb, MonadCatch m) => Rewrite c m Int -> Rewrite c m Coercion -> Rewrite c m Coercion

-- | Transform a coercion of the form: <tt>InstCo</tt> <a>Coercion</a>
--   <a>Type</a>
instCoT :: (ExtendPath c Crumb, Monad m) => Transform c m Coercion a1 -> Transform c m Type a2 -> (a1 -> a2 -> b) -> Transform c m Coercion b

-- | Rewrite all children of a coercion of the form: <tt>InstCo</tt>
--   <a>Coercion</a> <a>Type</a>
instCoAllR :: (ExtendPath c Crumb, Monad m) => Rewrite c m Coercion -> Rewrite c m Type -> Rewrite c m Coercion

-- | Rewrite any children of a coercion of the form: <tt>InstCo</tt>
--   <a>Coercion</a> <a>Type</a>
instCoAnyR :: (ExtendPath c Crumb, MonadCatch m) => Rewrite c m Coercion -> Rewrite c m Type -> Rewrite c m Coercion

-- | Rewrite one child of a coercion of the form: <tt>InstCo</tt>
--   <a>Coercion</a> <a>Type</a>
instCoOneR :: (ExtendPath c Crumb, MonadCatch m) => Rewrite c m Coercion -> Rewrite c m Type -> Rewrite c m Coercion

-- | Transform a coercion of the form: <tt>LRCo</tt> <a>LeftOrRight</a>
--   <a>Coercion</a>
lrCoT :: (ExtendPath c Crumb, Monad m) => Transform c m LeftOrRight a1 -> Transform c m Coercion a2 -> (a1 -> a2 -> b) -> Transform c m Coercion b

-- | Transform all children of a coercion of the form: <tt>LRCo</tt>
--   <a>LeftOrRight</a> <a>Coercion</a>
lrCoAllR :: (ExtendPath c Crumb, Monad m) => Rewrite c m LeftOrRight -> Rewrite c m Coercion -> Rewrite c m Coercion

-- | Transform any children of a coercion of the form: <tt>LRCo</tt>
--   <a>LeftOrRight</a> <a>Coercion</a>
lrCoAnyR :: (ExtendPath c Crumb, MonadCatch m) => Rewrite c m LeftOrRight -> Rewrite c m Coercion -> Rewrite c m Coercion

-- | Transform one child of a coercion of the form: <tt>LRCo</tt>
--   <a>LeftOrRight</a> <a>Coercion</a>
lrCoOneR :: (ExtendPath c Crumb, MonadCatch m) => Rewrite c m LeftOrRight -> Rewrite c m Coercion -> Rewrite c m Coercion

-- | Transform a clause of the form: <tt>Conj</tt> <a>Clause</a>
--   <a>Clause</a>
conjT :: (ExtendPath c Crumb, Monad m) => Transform c m Clause a1 -> Transform c m Clause a2 -> (a1 -> a2 -> b) -> Transform c m Clause b

-- | Rewrite all children of a clause of the form: : <tt>Conj</tt>
--   <a>Clause</a> <a>Clause</a>
conjAllR :: (ExtendPath c Crumb, Monad m) => Rewrite c m Clause -> Rewrite c m Clause -> Rewrite c m Clause

-- | Transform a clause of the form: <tt>Disj</tt> <a>Clause</a>
--   <a>Clause</a>
disjT :: (ExtendPath c Crumb, Monad m) => Transform c m Clause a1 -> Transform c m Clause a2 -> (a1 -> a2 -> b) -> Transform c m Clause b

-- | Rewrite all children of a clause of the form: : <tt>Disj</tt>
--   <a>Clause</a> <a>Clause</a>
disjAllR :: (ExtendPath c Crumb, Monad m) => Rewrite c m Clause -> Rewrite c m Clause -> Rewrite c m Clause

-- | Transform a clause of the form: <tt>Impl</tt> <a>LemmaName</a>
--   <a>Clause</a> <a>Clause</a>
implT :: (ExtendPath c Crumb, LemmaContext c, Monad m) => Transform c m Clause a1 -> Transform c m Clause a2 -> (LemmaName -> a1 -> a2 -> b) -> Transform c m Clause b

-- | Rewrite all children of a clause of the form: : <tt>Impl</tt>
--   <a>Clause</a> <a>Clause</a>
implAllR :: (ExtendPath c Crumb, LemmaContext c, Monad m) => Rewrite c m Clause -> Rewrite c m Clause -> Rewrite c m Clause

-- | Transform a clause of the form: <tt>Equiv</tt> <a>CoreExpr</a>
--   <a>CoreExpr</a>
equivT :: (ExtendPath c Crumb, Monad m) => Transform c m CoreExpr a1 -> Transform c m CoreExpr a2 -> (a1 -> a2 -> b) -> Transform c m Clause b

-- | Rewrite all children of a clause of the form: : <tt>Equiv</tt>
--   <a>CoreExpr</a> <a>CoreExpr</a>
equivAllR :: (ExtendPath c Crumb, Monad m) => Rewrite c m CoreExpr -> Rewrite c m CoreExpr -> Rewrite c m Clause

-- | Transform a clause of the form: <tt>Forall</tt> '[CoreBndr]'
--   <a>Clause</a>
forallT :: (ExtendPath c Crumb, AddBindings c, ReadPath c Crumb, Monad m) => Transform c m [CoreBndr] a1 -> Transform c m Clause a2 -> (a1 -> a2 -> b) -> Transform c m Clause b

-- | Rewrite the a clause of the form: <tt>Forall</tt> '[CoreBndr]'
--   <a>Clause</a>
forallR :: (ExtendPath c Crumb, AddBindings c, ReadPath c Crumb, Monad m) => Rewrite c m [CoreBndr] -> Rewrite c m Clause -> Rewrite c m Clause
(<$>) :: Monad m => (a -> b) -> m a -> m b
(<*>) :: Monad m => m (a -> b) -> m a -> m b
instance HasDynFlags m => HasDynFlags (Transform c m a)
instance (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, HasEmptyContext c) => Walker c CoreTC
instance (AddBindings c, ExtendPath c Crumb, HasEmptyContext c, LemmaContext c, ReadPath c Crumb) => Walker c LCoreTC
instance (AddBindings c, ExtendPath c Crumb, HasEmptyContext c, LemmaContext c, ReadPath c Crumb) => Walker c LCore
instance (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c) => Walker c TyCo
instance (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c) => Walker c Coercion
instance (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c) => Walker c Type
instance (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, HasEmptyContext c) => Walker c Core

module HERMIT.External

-- | An <a>External</a> is a <a>Dynamic</a> value with some associated
--   meta-data (name, help string and tags).
data External

-- | <a>External</a> names are just strings.
type ExternalName = String

-- | Help information for <a>External</a>s is stored as a list of strings,
--   designed for multi-line displaying.
type ExternalHelp = [String]

-- | Get the name of an <a>External</a>.
externName :: External -> ExternalName

-- | Get the <a>Dynamic</a> value stored in an <a>External</a>.
externDyn :: External -> Dynamic

-- | Get the list of help <a>String</a>s for an <a>External</a>.
externHelp :: External -> ExternalHelp

-- | Get a string representation of the (monomorphic) type of an
--   <a>External</a>
externTypeString :: External -> String
externTypeArgResString :: External -> ([String], String)
splitFunTyArgs :: TypeRep -> ([TypeRep], TypeRep)

-- | Build a <a>Map</a> from names to help information.
toHelp :: [External] -> Map ExternalName ExternalHelp

-- | The primitive way to build an <a>External</a>.
external :: Extern a => ExternalName -> a -> ExternalHelp -> External

-- | The class of things that can be made into <a>External</a>s. To be an
--   <a>Extern</a> there must exist an isomorphic <a>Box</a> type that is
--   an instance of <a>Typeable</a>.
class Typeable (Box a) => Extern a where type family Box a
box :: Extern a => a -> Box a
unbox :: Extern a => Box a -> a

-- | Get all the <a>External</a>s which match a given tag predicate and box
--   a Transform of the appropriate type.
matchingExternals :: (Extern tr, Tag t) => t -> [External] -> [(External, tr)]

-- | Requirement: commands cannot have the same name as any <a>CmdTag</a>
--   (or the help function will not find it). These should be <i>user
--   facing</i>, because they give the user a way of sub-dividing our
--   confusing array of commands.
data CmdTag

-- | Shell-specific command.
Shell :: CmdTag

-- | The arrow of evaluation (reduces a term).
Eval :: CmdTag

-- | <a>KURE</a> command.
KURE :: CmdTag

-- | Command may operate multiple times.
Loop :: CmdTag

-- | Command may make a deep change, can be O(n).
Deep :: CmdTag

-- | Command operates on local nodes only, O(1).
Shallow :: CmdTag

-- | Uses <a>Path</a> or <a>Lens</a> to focus onto something.
Navigation :: CmdTag

-- | Extract information from an expression.
Query :: CmdTag

-- | Something that passes or fails.
Predicate :: CmdTag

-- | Introduce something, like a new name.
Introduce :: CmdTag

-- | Commute is when you swap nested terms.
Commute :: CmdTag

-- | Operation has a (perhaps undocumented) precondition.
PreCondition :: CmdTag

-- | Alters the strictness of the expression.
Strictness :: CmdTag

-- | Commands specifically to help debugging.
Debug :: CmdTag

-- | Version control for Core syntax.
VersionControl :: CmdTag

-- | A command that uses its context, such as inlining.
Context :: CmdTag

-- | Commands that are not type safe (may cause Core Lint to fail), or may
--   otherwise change the semantics of the program. Only available in
--   unsafe mode!
Unsafe :: CmdTag

-- | Include in Strict Safety mode (currently unused)
Safe :: CmdTag

-- | Commands related to proving lemmas.
Proof :: CmdTag

-- | An incomplete or potentially buggy command.
TODO :: CmdTag

-- | Things we are trying out.
Experiment :: CmdTag

-- | A command that will be removed in a future release; it has probably
--   been renamed or subsumed by another command.
Deprecated :: CmdTag

-- | A data type of logical operations on tags.
data TagE :: *

-- | Tags are meta-data that we add to <a>External</a>s to make them
--   sortable and searchable.
class Tag a
(.+) :: Tag a => External -> a -> External
remTag :: Tag a => a -> External -> External
tagMatch :: Tag a => a -> External -> Bool

-- | An "and" on <a>Tag</a>s.
(.&) :: (Tag a, Tag b) => a -> b -> TagE

-- | An "or" on <a>Tag</a>s.
(.||) :: (Tag a, Tag b) => a -> b -> TagE

-- | A "not" on <a>Tag</a>s.
notT :: Tag a => a -> TagE

-- | List all the <a>CmdTag</a>s associated with an <a>External</a>
externTags :: External -> [CmdTag]

-- | Lists all the tags paired with a short description of what they're
--   about.
dictionaryOfTags :: [(CmdTag, String)]
newtype CoreString
CoreString :: String -> CoreString
unCoreString :: CoreString -> String
data CrumbBox
CrumbBox :: Crumb -> CrumbBox
data IntBox
IntBox :: Int -> IntBox
data IntListBox
IntListBox :: [Int] -> IntListBox
data PathBox
PathBox :: LocalPathH -> PathBox
data StringBox
StringBox :: String -> StringBox
data StringListBox
StringListBox :: [String] -> StringListBox
data TagBox
TagBox :: TagE -> TagBox
data TransformLCoreStringBox
TransformLCoreStringBox :: (TransformH LCore String) -> TransformLCoreStringBox
data TransformLCoreUnitBox
TransformLCoreUnitBox :: (TransformH LCore ()) -> TransformLCoreUnitBox
data TransformLCorePathBox
TransformLCorePathBox :: (TransformH LCore LocalPathH) -> TransformLCorePathBox
data RewriteLCoreBox
RewriteLCoreBox :: (RewriteH LCore) -> RewriteLCoreBox
data BiRewriteLCoreBox
BiRewriteLCoreBox :: (BiRewriteH LCore) -> BiRewriteLCoreBox
data RewriteLCoreListBox
RewriteLCoreListBox :: [RewriteH LCore] -> RewriteLCoreListBox
data TransformLCoreTCStringBox
TransformLCoreTCStringBox :: (TransformH LCoreTC String) -> TransformLCoreTCStringBox
data TransformLCoreTCUnitBox
TransformLCoreTCUnitBox :: (TransformH LCoreTC ()) -> TransformLCoreTCUnitBox
data TransformLCoreTCLCoreBox
TransformLCoreTCLCoreBox :: (TransformH LCoreTC LCore) -> TransformLCoreTCLCoreBox
data TransformLCoreTCPathBox
TransformLCoreTCPathBox :: (TransformH LCoreTC LocalPathH) -> TransformLCoreTCPathBox
data RewriteLCoreTCBox
RewriteLCoreTCBox :: (RewriteH LCoreTC) -> RewriteLCoreTCBox
data BiRewriteLCoreTCBox
BiRewriteLCoreTCBox :: (BiRewriteH LCoreTC) -> BiRewriteLCoreTCBox
data RewriteLCoreTCListBox
RewriteLCoreTCListBox :: [RewriteH LCoreTC] -> RewriteLCoreTCListBox
instance Typeable TagBox
instance Typeable IntBox
instance Typeable CrumbBox
instance Typeable PathBox
instance Typeable CoreString
instance Typeable StringBox
instance Typeable StringListBox
instance Typeable IntListBox
instance Typeable RewriteLCoreBox
instance Typeable TransformLCoreStringBox
instance Typeable TransformLCoreUnitBox
instance Typeable TransformLCorePathBox
instance Typeable BiRewriteLCoreBox
instance Typeable RewriteLCoreListBox
instance Typeable RewriteLCoreTCBox
instance Typeable TransformLCoreTCStringBox
instance Typeable TransformLCoreTCUnitBox
instance Typeable TransformLCoreTCLCoreBox
instance Typeable TransformLCoreTCPathBox
instance Typeable BiRewriteLCoreTCBox
instance Typeable RewriteLCoreTCListBox
instance Eq CmdTag
instance Show CmdTag
instance Read CmdTag
instance Bounded CmdTag
instance Enum CmdTag
instance Extern [RewriteH LCoreTC]
instance Extern (BiRewriteH LCoreTC)
instance Extern (TransformH LCoreTC LocalPathH)
instance Extern (TransformH LCoreTC LCore)
instance Extern (TransformH LCoreTC ())
instance Extern (TransformH LCoreTC String)
instance Extern (RewriteH LCoreTC)
instance Extern [RewriteH LCore]
instance Extern (BiRewriteH LCore)
instance Extern (TransformH LCore LocalPathH)
instance Extern (TransformH LCore ())
instance Extern (TransformH LCore String)
instance Extern (RewriteH LCore)
instance Extern LemmaName
instance Extern [Int]
instance Extern [String]
instance Extern String
instance Extern CoreString
instance Extern LocalPathH
instance Extern Crumb
instance Extern Int
instance Extern TagE
instance (Extern a, Extern b) => Extern (a -> b)
instance Tag CmdTag
instance Tag TagE

module HERMIT.Dictionary.Debug

-- | Exposed debugging <a>External</a>s.
externals :: [External]

-- | Show before and after a rewrite.
bracketR :: (Injection a LCoreTC, LemmaContext c, ReadBindings c, ReadPath c Crumb, HasHermitMEnv m, HasLemmas m, LiftCoreM m, MonadCatch m) => String -> Rewrite c m a -> Rewrite c m a

-- | Print out the <a>Core</a>, with a message.
observeR :: (Injection a LCoreTC, LemmaContext c, ReadBindings c, ReadPath c Crumb, HasHermitMEnv m, HasLemmas m, LiftCoreM m) => String -> Rewrite c m a

-- | If the <a>Rewrite</a> fails, print out the <a>Core</a>, with a
--   message.
observeFailureR :: (Injection a LCoreTC, LemmaContext c, ReadBindings c, ReadPath c Crumb, HasHermitMEnv m, HasLemmas m, LiftCoreM m, MonadCatch m) => String -> Rewrite c m a -> Rewrite c m a

-- | Just say something, every time the rewrite is done.
traceR :: (HasHermitMEnv m, HasLemmas m, LiftCoreM m) => String -> Rewrite c m a

module HERMIT.Dictionary.Kure

-- | <ul>
--   <li>- This list contains reflections of the KURE strategies as
--   <a>External</a>s.</li>
--   </ul>
externals :: [External]

-- | Top-down traversal tuned to matching function calls.
anyCallR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, HasEmptyContext c, MonadCatch m) => Rewrite c m Core -> Rewrite c m Core

-- | betweenR x y rr -&gt; perform rr at least x times and at most y times.
betweenR :: MonadCatch m => Int -> Int -> Rewrite c m a -> Rewrite c m a

module HERMIT.Dictionary.Navigation.Crumbs

-- | <a>External</a>s for individual <a>Crumb</a>s.
crumbExternals :: [External]

module HERMIT.Name

-- | A <a>HermitName</a> is an optionally fully-qualified name, like GHC's
--   <a>RdrName</a>, but without specifying which <a>NameSpace</a> the name
--   is found in.
data HermitName
cmpHN2Name :: HermitName -> Name -> Bool

-- | Compare a HermitName to a Var.
--   
--   Only compare module names if the HermitName is fully qualified.
--   Otherwise match variables from any module with appropriate occurrence
--   name.
cmpHN2Var :: HermitName -> Var -> Bool

-- | Make a HermitName from a RdrName
fromRdrName :: RdrName -> HermitName

-- | Make a RdrName for the given NameSpace and HermitName
toRdrName :: NameSpace -> HermitName -> RdrName

-- | Make a RdrName for each given NameSpace.
toRdrNames :: [NameSpace] -> HermitName -> [RdrName]
hnModuleName :: HermitName -> Maybe ModuleName
hnUnqualified :: HermitName -> FastString

-- | Parse a HermitName from a String.
parseName :: String -> HermitName

-- | Turn a HermitName into a (possibly fully-qualified) String.
showName :: HermitName -> String
newtype OccurrenceName
OccurrenceName :: HermitName -> OccurrenceName
unOccurrenceName :: OccurrenceName -> HermitName
newtype OccurrenceNameListBox
OccurrenceNameListBox :: [OccurrenceName] -> OccurrenceNameListBox
mkOccPred :: OccurrenceName -> Var -> Bool
newtype BindingName
BindingName :: HermitName -> BindingName
unBindingName :: BindingName -> HermitName
mkBindingPred :: BindingName -> Var -> Bool
newtype RhsOfName
RhsOfName :: HermitName -> RhsOfName
unRhsOfName :: RhsOfName -> HermitName
mkRhsOfPred :: RhsOfName -> Var -> Bool

-- | Possible results from name lookup. Invariant: One constructor for each
--   NameSpace.
data Named
NamedId :: Id -> Named
NamedDataCon :: DataCon -> Named
NamedTyCon :: TyCon -> Named
NamedTyVar :: Var -> Named
varToNamed :: Var -> Named
allNameSpaces :: [NameSpace]
dataConNS :: NameSpace
tyConClassNS :: NameSpace
tyVarNS :: NameSpace
varNS :: NameSpace

-- | Make a unique global identifier for a specified type, using a provided
--   name.
newGlobalIdH :: MonadUnique m => String -> Type -> m Id

-- | Make a unique identifier for a specified type, using a provided name.
newIdH :: MonadUnique m => String -> Type -> m Id

-- | Make a unique type variable for a specified kind, using a provided
--   name.
newTyVarH :: MonadUnique m => String -> Kind -> m TyVar

-- | Make a unique coercion variable for a specified type, using a provided
--   name.
newCoVarH :: MonadUnique m => String -> Type -> m TyVar

-- | Experimental, use at your own risk.
newVarH :: MonadUnique m => String -> KindOrType -> m Var

-- | Make a new variable of the same type, with a modified textual name.
cloneVarH :: MonadUnique m => (String -> String) -> Var -> m Var

-- | Make a new variable of the same type, with a modified textual name.
cloneVarFSH :: MonadUnique m => (FastString -> FastString) -> Var -> m Var
findId :: (BoundVars c, LiftCoreM m, HasHermitMEnv m, MonadCatch m, MonadIO m, MonadThings m) => HermitName -> c -> m Id
findVar :: (BoundVars c, LiftCoreM m, HasHermitMEnv m, MonadCatch m, MonadIO m, MonadThings m) => HermitName -> c -> m Var
findTyCon :: (BoundVars c, LiftCoreM m, HasHermitMEnv m, MonadCatch m, MonadIO m, MonadThings m) => HermitName -> c -> m TyCon
findType :: (BoundVars c, LiftCoreM m, HasHermitMEnv m, MonadCatch m, MonadIO m, MonadThings m) => HermitName -> c -> m Type
findInNameSpace :: (BoundVars c, LiftCoreM m, HasHermitMEnv m, MonadIO m, MonadThings m) => NameSpace -> HermitName -> c -> m Named
findInNameSpaces :: (BoundVars c, LiftCoreM m, HasHermitMEnv m, MonadCatch m, MonadIO m, MonadThings m) => [NameSpace] -> HermitName -> c -> m Named
instance Typeable HermitName
instance Typeable BindingName
instance Typeable OccurrenceName
instance Typeable OccurrenceNameListBox
instance Typeable RhsOfName
instance Eq HermitName
instance (MonadThings m, BoundVars c) => MonadThings (Transform c m a)
instance Extern RhsOfName
instance Extern [OccurrenceName]
instance Extern OccurrenceName
instance Extern BindingName
instance Show HermitName
instance IsString HermitName
instance Extern HermitName
instance Show Named


-- | Note: this module should NOT export externals. It is for common
--   transformations needed by the other primitive modules.
module HERMIT.Dictionary.Common

-- | apply a transformation to a value in the current context.
applyInContextT :: Transform c m a b -> a -> Transform c m x b

-- | Lift GHC's collectArgs
callT :: Monad m => Transform c m CoreExpr (CoreExpr, [CoreExpr])

-- | Succeeds if we are looking at an application matching the given
--   predicate.
callPredT :: Monad m => (Id -> [CoreExpr] -> Bool) -> Transform c m CoreExpr (CoreExpr, [CoreExpr])

-- | Succeeds if we are looking at an application of given function
--   returning zero or more arguments to which it is applied.
--   
--   Note: comparison is performed with cmpHN2Var.
callNameT :: MonadCatch m => HermitName -> Transform c m CoreExpr (CoreExpr, [CoreExpr])

-- | Succeeds if we are looking at a fully saturated function call.
callSaturatedT :: Monad m => Transform c m CoreExpr (CoreExpr, [CoreExpr])

-- | Succeeds if we are looking at an application of given function
callNameG :: MonadCatch m => HermitName -> Transform c m CoreExpr ()

-- | Succeeds if we are looking at an application of a data constructor.
callDataConT :: MonadCatch m => Transform c m CoreExpr (DataCon, [Type], [CoreExpr])

-- | Succeeds if we are looking at an application of a named data
--   constructor.
callDataConNameT :: MonadCatch m => String -> Transform c m CoreExpr (DataCon, [Type], [CoreExpr])

-- | List the identifiers bound by the top-level binding group at the head
--   of the program.
progConsIdsT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => Transform c m CoreProg [Id]

-- | List the identifiers bound by a recursive top-level binding group at
--   the head of the program.
progConsRecIdsT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => Transform c m CoreProg [Id]

-- | Return the identifier bound by a non-recursive top-level binding at
--   the head of the program.
progConsNonRecIdT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => Transform c m CoreProg Id

-- | Return the variable bound by a non-recursive let expression.
nonRecVarT :: (ExtendPath c Crumb, Monad m) => Transform c m CoreBind Var

-- | List all identifiers bound in a recursive binding group.
recIdsT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => Transform c m CoreBind [Id]

-- | Return the variable bound by a lambda expression.
lamVarT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => Transform c m CoreExpr Var

-- | List the variables bound by a let expression.
letVarsT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => Transform c m CoreExpr [Var]

-- | List the identifiers bound by a recursive let expression.
letRecIdsT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => Transform c m CoreExpr [Id]

-- | Return the variable bound by a non-recursive let expression.
letNonRecVarT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => Transform c m CoreExpr Var

-- | List all variables bound by a case expression (in the alternatives and
--   the case binder).
caseVarsT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => Transform c m CoreExpr [Var]

-- | Return the case binder.
caseBinderIdT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => Transform c m CoreExpr Id

-- | List the variables bound by all alternatives in a case expression.
caseAltVarsT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, Monad m) => Transform c m CoreExpr [[Var]]

-- | Lifted version of <a>boundVars</a>.
boundVarsT :: (BoundVars c, Monad m) => Transform c m a VarSet

-- | Find the unique variable bound in the context that matches the given
--   name, failing if it is not unique.
findBoundVarT :: (BoundVars c, MonadCatch m) => (Var -> Bool) -> Transform c m a Var

-- | Lookup the name in the context first, then, failing that, in GHC's
--   global reader environment.
findIdT :: (BoundVars c, HasHermitMEnv m, LiftCoreM m, MonadCatch m, MonadIO m, MonadThings m) => HermitName -> Transform c m a Id

-- | Lookup the name in the context first, then, failing that, in GHC's
--   global reader environment.
findVarT :: (BoundVars c, HasHermitMEnv m, LiftCoreM m, MonadCatch m, MonadIO m, MonadThings m) => HermitName -> Transform c m a Var

-- | Lookup the name in the context first, then, failing that, in GHC's
--   global reader environment.
findTyConT :: (BoundVars c, HasHermitMEnv m, LiftCoreM m, MonadCatch m, MonadIO m, MonadThings m) => HermitName -> Transform c m a TyCon

-- | Lookup the name in the context first, then, failing that, in GHC's
--   global reader environment.
findTypeT :: (BoundVars c, HasHermitMEnv m, LiftCoreM m, MonadCatch m, MonadIO m, MonadThings m) => HermitName -> Transform c m a Type

-- | Find the depth of a variable's binding.
varBindingDepthT :: (ReadBindings c, Monad m) => Var -> Transform c m g BindingDepth

-- | Determine if the current variable matches the given variable, and is
--   bound at the specified depth (helpful to detect shadowing).
varIsOccurrenceOfT :: (ExtendPath c Crumb, ReadBindings c, Monad m) => Var -> BindingDepth -> Transform c m Var Bool

-- | Determine if the current expression is an occurrence of the given
--   variable, bound at the specified depth (helpful to detect shadowing).
exprIsOccurrenceOfT :: (ExtendPath c Crumb, ReadBindings c, Monad m) => Var -> BindingDepth -> Transform c m CoreExpr Bool

-- | Modify transformation to apply to current expression as if it were the
--   body of a lambda binding the given variables.
withVarsInScope :: (AddBindings c, ReadPath c Crumb) => [Var] -> Transform c m a b -> Transform c m a b

-- | Constructs a common error message. Argument <a>String</a> should be
--   the desired form of the expression.
wrongExprForm :: String -> String

module HERMIT.Dictionary.Local.Bind

-- | Externals for manipulating binding groups.
externals :: [External]

-- | <tt><a>NonRec</a> v e</tt> ==&gt; <tt><a>Rec</a> [(v,e)]</tt>
nonrecToRecR :: MonadCatch m => Rewrite c m CoreBind

-- | <tt><a>Rec</a> [(v,e)]</tt> ==&gt; <tt><a>NonRec</a> v e</tt>
recToNonrecR :: MonadCatch m => Rewrite c m CoreBind

module HERMIT.Dictionary.Local.Cast

-- | Externals relating to Case expressions.
externals :: [External]
castElimReflR :: MonadCatch m => Rewrite c m CoreExpr
castElimSymR :: MonadCatch m => Rewrite c m CoreExpr
castFloatAppR :: MonadCatch m => Rewrite c m CoreExpr
castFloatLamR :: MonadCatch m => Rewrite c m CoreExpr
castElimSymPlusR :: (ExtendPath c Crumb, AddBindings c, Monad m) => Rewrite c m CoreExpr

module HERMIT.Dictionary.Function
externals :: [External]

-- | Get the nth argument of an application. Arg 0 is the function being
--   applied.
appArgM :: Monad m => Int -> CoreExpr -> m CoreExpr

-- | Given expression for f and for x, build f x, figuring out the type
--   arguments.
buildAppM :: MonadCatch m => CoreExpr -> CoreExpr -> m CoreExpr
buildAppsM :: MonadCatch m => CoreExpr -> [CoreExpr] -> m CoreExpr

-- | Build composition of two functions.
buildCompositionT :: (BoundVars c, HasHermitMEnv m, LiftCoreM m, MonadCatch m, MonadIO m, MonadThings m) => CoreExpr -> CoreExpr -> Transform c m x CoreExpr

-- | Given expression for f, build fix f.
buildFixT :: (BoundVars c, LiftCoreM m, HasHermitMEnv m, MonadCatch m, MonadIO m, MonadThings m) => CoreExpr -> Transform c m x CoreExpr

-- | Build an expression that is the monomorphic id function for given
--   type.
buildIdT :: (BoundVars c, LiftCoreM m, HasHermitMEnv m, MonadCatch m, MonadIO m, MonadThings m) => Type -> Transform c m x CoreExpr

-- | Traditional Static Argument Transformation
staticArgR :: (AddBindings c, ExtendPath c Crumb, HasEmptyContext c, ReadPath c Crumb, MonadCatch m, MonadUnique m) => Rewrite c m CoreDef

-- | Static Argument Transformations which requires that arguments in the
--   given position are static.
staticArgPosR :: (AddBindings c, ExtendPath c Crumb, HasEmptyContext c, ReadPath c Crumb, MonadCatch m, MonadUnique m) => [Int] -> Rewrite c m CoreDef

-- | Generalized Static Argument Transformation, which allows static
--   arguments to be filtered.
staticArgPredR :: (AddBindings c, ExtendPath c Crumb, HasEmptyContext c, ReadPath c Crumb, MonadCatch m, MonadUnique m) => ([(Int, Var)] -> m [Int]) -> Rewrite c m CoreDef

-- | Static Argument Transformation that only considers type arguments to
--   be static.
staticArgTypesR :: (AddBindings c, ExtendPath c Crumb, HasEmptyContext c, ReadPath c Crumb, MonadCatch m, MonadUnique m) => Rewrite c m CoreDef

module HERMIT.Dictionary.GHC

-- | Externals that reflect GHC functions, or are derived from GHC
--   functions.
externals :: [External]
loadLemmaLibraryT :: HermitName -> Maybe LemmaName -> TransformH x String

-- | A LemmaLibrary is a transformation that produces a set of lemmas,
--   which are then added to the lemma store. It is not allowed to insert
--   its own lemmas directly (if it tries they are throw away), but can
--   certainly read the existing store.
type LemmaLibrary = TransformH () Lemmas
injectDependencyT :: (LiftCoreM m, MonadIO m) => ModuleName -> Transform c m ModGuts ()

-- | Substitute all occurrences of a variable with an expression, in either
--   a program, an expression, or a case alternative.
substR :: MonadCatch m => Var -> CoreExpr -> Rewrite c m Core

-- | Lifted version of <a>getDynFlags</a>.
dynFlagsT :: HasDynFlags m => Transform c m a DynFlags

-- | Try to figure out the arity of an identifier.
arityOf :: ReadBindings c => c -> Id -> Int

-- | Note: this can miss several things that a whole-module core lint will
--   find. For instance, running this on the RHS of a binding, the type of
--   the RHS will not be checked against the type of the binding. Running
--   on the whole let expression will catch that however.
lintExprT :: (BoundVars c, Monad m, HasDynFlags m) => Transform c m CoreExpr String

-- | Run the Core Lint typechecker. Fails on errors, with error messages.
--   Succeeds returning warnings.
lintModuleT :: TransformH ModGuts String
lintClauseT :: (AddBindings c, BoundVars c, ExtendPath c Crumb, HasEmptyContext c, LemmaContext c, ReadPath c Crumb, HasDynFlags m, MonadCatch m) => Transform c m Clause String

-- | Apply <tt>occurAnalyseExprR</tt> to all sub-expressions.
occurAnalyseR :: (Injection CoreExpr u, Walker c u, MonadCatch m) => Rewrite c m u

-- | Occurrence analyse all sub-expressions, failing if the result is
--   syntactically equal to the initial expression.
occurAnalyseChangedR :: (AddBindings c, ExtendPath c Crumb, HasEmptyContext c, LemmaContext c, ReadPath c Crumb, MonadCatch m) => Rewrite c m LCore

-- | Occurrence analyse an expression, failing if the result is
--   syntactically equal to the initial expression.
occurAnalyseExprChangedR :: MonadCatch m => Rewrite c m CoreExpr

-- | Run GHC's occurrence analyser, and also eliminate any zombies.
occurAnalyseAndDezombifyR :: (AddBindings c, ExtendPath c Crumb, ReadPath c Crumb, HasEmptyContext c, MonadCatch m, Walker c u, Injection CoreExpr u) => Rewrite c m u

-- | Zap the <a>OccInfo</a> in a zombie identifier.
dezombifyR :: (ExtendPath c Crumb, Monad m) => Rewrite c m CoreExpr

-- | Build a dictionary for the given
buildDictionary :: (HasDynFlags m, HasHermitMEnv m, LiftCoreM m, MonadIO m) => Id -> m (Id, [CoreBind])
buildDictionaryT :: (HasDynFlags m, HasHermitMEnv m, LiftCoreM m, MonadCatch m, MonadIO m, MonadUnique m) => Transform c m Type CoreExpr
buildTypeable :: (HasDynFlags m, HasHermitMEnv m, LiftCoreM m, MonadIO m) => Type -> m (Id, [CoreBind])

module HERMIT.Dictionary.AlphaConversion

-- | Externals for alpha-renaming.
externals :: [External]

-- | Alpha rename any bindings at this node. Note: does not rename case
--   alternatives unless invoked on the alternative.
alphaR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, BoundVars c, MonadCatch m, MonadUnique m) => Rewrite c m Core

-- | Alpha rename a lambda binder. Optionally takes a suggested new name.
alphaLamR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, BoundVars c, MonadCatch m, MonadUnique m) => Maybe String -> Rewrite c m CoreExpr

-- | Alpha rename a case binder. Optionally takes a suggested new name.
alphaCaseBinderR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, BoundVars c, MonadCatch m, MonadUnique m) => Maybe String -> Rewrite c m CoreExpr

-- | Rename the variables bound in a case alternative with the given list
--   of suggested names.
alphaAltWithR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, BoundVars c, MonadCatch m, MonadUnique m) => [String] -> Rewrite c m CoreAlt

-- | Rename the specified variables in a case alternative.
alphaAltVarsR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, BoundVars c, MonadCatch m, MonadUnique m) => [Var] -> Rewrite c m CoreAlt

-- | Rename all identifiers bound in a case alternative.
alphaAltR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, BoundVars c, MonadCatch m, MonadUnique m) => Rewrite c m CoreAlt

-- | Rename all identifiers bound in a case expression.
alphaCaseR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, BoundVars c, MonadCatch m, MonadUnique m) => Rewrite c m CoreExpr

-- | Rename the identifiers bound in a Let with the given list of suggested
--   names.
alphaLetWithR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, BoundVars c, MonadCatch m, MonadUnique m) => [String] -> Rewrite c m CoreExpr

-- | Rename the specified variables bound in a let.
alphaLetVarsR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, BoundVars c, MonadCatch m, MonadUnique m) => [Var] -> Rewrite c m CoreExpr

-- | Rename all identifiers bound in a Let.
alphaLetR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, BoundVars c, MonadCatch m, MonadUnique m) => Rewrite c m CoreExpr

-- | Rename the identifiers bound in the top-level binding at the head of
--   the program with the given list of suggested names.
alphaProgConsWithR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, BoundVars c, MonadCatch m, MonadUnique m) => [String] -> Rewrite c m CoreProg

-- | Rename the specified variables bound in the top-level binding at the
--   head of the program.
alphaProgConsIdsR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, BoundVars c, MonadCatch m, MonadUnique m) => [Id] -> Rewrite c m CoreProg

-- | Rename all identifiers bound in the top-level binding at the head of
--   the program.
alphaProgConsR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, BoundVars c, MonadCatch m, MonadUnique m) => Rewrite c m CoreProg

-- | Rename all identifiers bound at the top-level.
alphaProgR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, BoundVars c, MonadCatch m, MonadUnique m) => Rewrite c m CoreProg

-- | Rename local variables with manifestly unique names (x, x0, x1, ...).
--   Does not rename top-level definitions.
unshadowR :: (AddBindings c, BoundVars c, ExtendPath c Crumb, HasEmptyContext c, ReadPath c Crumb, MonadCatch m, MonadUnique m) => Rewrite c m Core
unshadowExprR :: (AddBindings c, BoundVars c, ExtendPath c Crumb, ReadPath c Crumb, MonadCatch m, MonadUnique m) => Rewrite c m CoreExpr
unshadowAltR :: (AddBindings c, BoundVars c, ExtendPath c Crumb, ReadPath c Crumb, MonadCatch m, MonadUnique m) => Rewrite c m CoreAlt
unshadowProgR :: (AddBindings c, BoundVars c, ExtendPath c Crumb, ReadPath c Crumb, MonadCatch m, MonadUnique m) => Rewrite c m CoreProg

-- | Collect all visible variables (in the expression or the context).
visibleVarsT :: (BoundVars c, Monad m) => Transform c m CoreTC VarSet

-- | If a name is provided, use that as the name of the new variable.
--   Otherwise modify the variable name making sure to <i>not</i> clash
--   with the given variables or any visible variables.
cloneVarAvoidingT :: (BoundVars c, MonadUnique m) => Var -> Maybe String -> [Var] -> Transform c m CoreTC Var

-- | Use the optional argument if given, otherwise generate a new name
--   avoiding clashes with the set of variables.
freshNameGenAvoiding :: Maybe String -> VarSet -> (String -> String)

-- | Shadows are any duplicates in the list, or any occurrences of the list
--   elements in the set.
detectShadowsM :: Monad m => [Var] -> VarSet -> m VarSet

-- | Replace all occurrences of a specified variable. Arguments are the
--   variable to replace and the replacement variable, respectively.
replaceVarR :: (Injection a Core, MonadCatch m) => Var -> Var -> Rewrite c m a

module HERMIT.Dictionary.Inline

-- | <a>External</a>s for inlining variables.
externals :: [External]
data InlineConfig
CaseBinderOnly :: CaseBinderInlineOption -> InlineConfig
AllBinders :: InlineConfig
data CaseBinderInlineOption
Scrutinee :: CaseBinderInlineOption
Alternative :: CaseBinderInlineOption

-- | Return the unfolding of an identifier, and a predicate over the
--   binding depths of all variables within that unfolding to determine if
--   they have been captured in their new location.
getUnfoldingT :: (ReadBindings c, MonadCatch m) => InlineConfig -> Transform c m Id (CoreExpr, BindingDepth -> Bool)
getUnfoldingsT :: (ReadBindings c, MonadCatch m) => InlineConfig -> Transform c m Id [(CoreExpr, BindingDepth -> Bool)]

-- | Check that all free variables in an expression are bound. Fails,
--   listing unbound variables if not.
ensureBoundT :: (Monad m, ReadBindings c) => Transform c m CoreExpr ()

-- | Inline the current variable.
inlineR :: (AddBindings c, ExtendPath c Crumb, HasEmptyContext c, ReadBindings c, ReadPath c Crumb, MonadCatch m) => Rewrite c m CoreExpr

-- | If the current variable matches the given name, then inline it.
inlineNameR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, ReadBindings c, HasEmptyContext c, MonadCatch m) => String -> Rewrite c m CoreExpr

-- | If the current variable matches any of the given names, then inline
--   it.
inlineNamesR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, ReadBindings c, HasEmptyContext c, MonadCatch m) => [String] -> Rewrite c m CoreExpr

-- | If the current variable satisifies the predicate, then inline it.
inlineMatchingPredR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, ReadBindings c, HasEmptyContext c, MonadCatch m) => (Id -> Bool) -> Rewrite c m CoreExpr

-- | Inline the current identifier if it is a case binder, using the
--   scrutinee rather than the case-alternative pattern.
inlineCaseScrutineeR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, ReadBindings c, HasEmptyContext c, MonadCatch m) => Rewrite c m CoreExpr

-- | Inline the current identifier if is a case binder, using the
--   case-alternative pattern rather than the scrutinee.
inlineCaseAlternativeR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, ReadBindings c, HasEmptyContext c, MonadCatch m) => Rewrite c m CoreExpr

-- | The implementation of inline, an important transformation. This *only*
--   works if the current expression has the form <tt>Var v</tt> (it does
--   not traverse the expression). It can trivially be prompted to more
--   general cases using traversal strategies.
configurableInlineR :: (AddBindings c, ExtendPath c Crumb, HasEmptyContext c, ReadBindings c, ReadPath c Crumb, MonadCatch m) => InlineConfig -> (Transform c m Id Bool) -> Rewrite c m CoreExpr

-- | Get list of possible inline targets. Used by shell for completion.
inlineTargetsT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, HasEmptyContext c, LemmaContext c, ReadBindings c, MonadCatch m) => Transform c m LCore [String]
instance Eq CaseBinderInlineOption
instance Show CaseBinderInlineOption
instance Eq InlineConfig
instance Show InlineConfig

module HERMIT.Dictionary.Navigation

-- | <a>External</a>s involving navigating to named entities.
externals :: [External]

-- | Find the path to the first occurrence of a variable.
occurrenceOfT :: (AddBindings c, ExtendPath c Crumb, ReadPath c Crumb, HasEmptyContext c, LemmaContext c, MonadCatch m) => (Var -> Bool) -> Transform c m LCoreTC LocalPathH

-- | Find the path to the binding of a variable.
bindingOfT :: (AddBindings c, ExtendPath c Crumb, ReadPath c Crumb, HasEmptyContext c, LemmaContext c, MonadCatch m) => (Var -> Bool) -> Transform c m LCoreTC LocalPathH

-- | Find the path to the binding group of a variable.
bindingGroupOfT :: (AddBindings c, ExtendPath c Crumb, ReadPath c Crumb, HasEmptyContext c, LemmaContext c, MonadCatch m) => (Var -> Bool) -> Transform c m LCoreTC LocalPathH

-- | Find the path to the RHS of a binding.
rhsOfT :: (AddBindings c, ExtendPath c Crumb, ReadPath c Crumb, HasEmptyContext c, LemmaContext c, MonadCatch m) => (Var -> Bool) -> Transform c m LCoreTC LocalPathH

-- | Discard the last crumb of a non-empty <a>LocalPathH</a>.
parentOfT :: MonadCatch m => Transform c m g LocalPathH -> Transform c m g LocalPathH

-- | Find all possible targets of <a>occurrenceOfT</a>.
occurrenceOfTargetsT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, HasEmptyContext c, LemmaContext c, MonadCatch m) => Transform c m LCoreTC VarSet

-- | Find all possible targets of <a>bindingOfT</a>.
bindingOfTargetsT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, HasEmptyContext c, LemmaContext c, MonadCatch m) => Transform c m LCoreTC VarSet

-- | Find all possible targets of <a>bindingGroupOfT</a>.
bindingGroupOfTargetsT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, HasEmptyContext c, LemmaContext c, MonadCatch m) => Transform c m LCoreTC VarSet

-- | Find all possible targets of <a>rhsOfT</a>.
rhsOfTargetsT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, HasEmptyContext c, LemmaContext c, MonadCatch m) => Transform c m LCoreTC VarSet

-- | Language constructs that can be zoomed to.
data Considerable
Binding :: Considerable
Definition :: Considerable
CaseAlt :: Considerable
Variable :: Considerable
Literal :: Considerable
Application :: Considerable
Lambda :: Considerable
LetExpr :: Considerable
CaseOf :: Considerable
Casty :: Considerable
Ticky :: Considerable
TypeExpr :: Considerable
CoercionExpr :: Considerable

-- | Lookup table for constructs that can be considered; the keys are the
--   arguments the user can give to the "consider" command.
considerables :: [(String, Considerable)]

-- | Find the path to the first matching construct.
considerConstructT :: (AddBindings c, ExtendPath c Crumb, ReadPath c Crumb, HasEmptyContext c, LemmaContext c, MonadCatch m) => Considerable -> Transform c m LCore LocalPathH

-- | Construct a path to the (n-1)th argument in a nested sequence of
--   <a>App</a>s.
nthArgPath :: Monad m => Int -> Transform c m CoreExpr LocalPathH
string2considerable :: String -> Maybe Considerable
instance Typeable Considerable
instance HasEmptyContext c => HasEmptyContext (ExtendContext c (LocalPath Crumb))
instance Extern Considerable

module HERMIT.Dictionary.Query

-- | Externals that reflect GHC functions, or are derived from GHC
--   functions.
externals :: [External]
infoT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, ReadBindings c, BoundVars c, HasEmptyContext c, HasDynFlags m, MonadCatch m) => Transform c m CoreTC String

-- | Compare the core fragments at the end of the specified
--   <a>LocalPathH</a>s.
compareCoreAtT :: (ExtendPath c Crumb, AddBindings c, ReadBindings c, ReadPath c Crumb, HasEmptyContext c, LemmaContext c, MonadCatch m) => Transform c m LCoreTC LocalPathH -> Transform c m LCoreTC LocalPathH -> Transform c m LCoreTC ()

-- | Compare the definitions of two identifiers for alpha-equality.
compareBoundIdsT :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, ReadBindings c) => Id -> Id -> Transform c HermitM x ()

module HERMIT.Dictionary.Unfold
externals :: [External]

-- | Perform one or more beta reductions.
betaReducePlusR :: MonadCatch m => Rewrite c m CoreExpr

-- | A more powerful <tt>inline</tt>. Matches two cases: Var ==&gt; inlines
--   App ==&gt; inlines the head of the function call for the app tree
unfoldR :: (AddBindings c, ExtendPath c Crumb, HasEmptyContext c, ReadBindings c, ReadPath c Crumb, MonadCatch m) => Rewrite c m CoreExpr
unfoldPredR :: (AddBindings c, ExtendPath c Crumb, HasEmptyContext c, ReadBindings c, ReadPath c Crumb, MonadCatch m) => (Id -> [CoreExpr] -> Bool) -> Rewrite c m CoreExpr
unfoldNameR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, ReadBindings c, HasEmptyContext c, MonadCatch m) => HermitName -> Rewrite c m CoreExpr
unfoldNamesR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, ReadBindings c, HasEmptyContext c, MonadCatch m) => [HermitName] -> Rewrite c m CoreExpr
unfoldSaturatedR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, ReadBindings c, HasEmptyContext c) => Rewrite c HermitM CoreExpr
specializeR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, ReadBindings c, HasEmptyContext c) => Rewrite c HermitM CoreExpr

module HERMIT.ParserCore
parseCore :: ReadBindings c => CoreString -> c -> HermitM CoreExpr

-- | Parse a <a>CoreString</a> to a <a>CoreExpr</a>, using the current
--   context.
parseCoreExprT :: (ReadBindings c, HasHermitMEnv m, HasLemmas m, LiftCoreM m) => CoreString -> Transform c m a CoreExpr
parse2BeforeT :: (ReadBindings c, HasHermitMEnv m, HasLemmas m, LiftCoreM m) => (CoreExpr -> CoreExpr -> Translate c m a b) -> CoreString -> CoreString -> Translate c m a b
parse3BeforeT :: (ReadBindings c, HasHermitMEnv m, HasLemmas m, LiftCoreM m) => (CoreExpr -> CoreExpr -> CoreExpr -> Translate c m a b) -> CoreString -> CoreString -> CoreString -> Translate c m a b
parse2beforeBiR :: (CoreExpr -> CoreExpr -> BiRewriteH a) -> CoreString -> CoreString -> BiRewriteH a
parse3beforeBiR :: (CoreExpr -> CoreExpr -> CoreExpr -> BiRewriteH a) -> CoreString -> CoreString -> CoreString -> BiRewriteH a
parse4beforeBiR :: (CoreExpr -> CoreExpr -> CoreExpr -> CoreExpr -> BiRewriteH a) -> CoreString -> CoreString -> CoreString -> CoreString -> BiRewriteH a
parse5beforeBiR :: (CoreExpr -> CoreExpr -> CoreExpr -> CoreExpr -> CoreExpr -> BiRewriteH a) -> CoreString -> CoreString -> CoreString -> CoreString -> CoreString -> BiRewriteH a
data Token
Tforall :: Token
Trec :: Token
Tlet :: Token
Tin :: Token
Tcase :: Token
Tof :: Token
Tcast :: Token
Tnote :: Token
Texternal :: Token
Tlocal :: Token
Twild :: Token
Toparen :: Token
Tcparen :: Token
Tobrace :: Token
Tcbrace :: Token
Thash :: Token
Teq :: Token
Tcolon :: Token
Tcoloncolon :: Token
Tcoloneqcolon :: Token
Tstar :: Token
Tarrow :: Token
Tdoublearrow :: Token
Tlambda :: Token
Tat :: Token
Tdot :: Token
Tquestion :: Token
Tsemicolon :: Token
Tname :: String -> Token
Tcname :: String -> Token
Tinteger :: Integer -> Token
Trational :: Float -> Token
Tstring :: String -> Token
Tchar :: Char -> Token
parseError :: Monad m => [Token] -> m a
lexer :: String -> Either String [Token]
instance Eq Token
instance Show Token

module HERMIT.Dictionary.Unsafe
externals :: [External]
unsafeReplaceR :: CoreString -> RewriteH CoreExpr

module HERMIT.PrettyPrinter.Common
type DocH = MDoc HermitMark
data Attr
BndrAttr :: AbsolutePathH -> Attr
Color :: SyntaxForColor -> Attr
PathAttr :: AbsolutePathH -> Attr
SpecialFont :: Attr
attrP :: AbsolutePathH -> DocH -> DocH
newtype HTML
HTML :: String -> HTML
newtype ASCII
ASCII :: String -> ASCII
coercionColor :: DocH -> DocH
idColor :: DocH -> DocH
keywordColor :: DocH -> DocH
syntaxColor :: DocH -> DocH
markBindingSite :: Var -> PrettyC -> DocH -> DocH
markColor :: SyntaxForColor -> DocH -> DocH
typeColor :: DocH -> DocH
data ShowOption
Show :: ShowOption
Abstract :: ShowOption
Detailed :: ShowOption
Omit :: ShowOption
Kind :: ShowOption
specialFont :: DocH -> DocH
data SpecialSymbol
LambdaSymbol :: SpecialSymbol
TypeOfSymbol :: SpecialSymbol
RightArrowSymbol :: SpecialSymbol
CastSymbol :: SpecialSymbol
CoercionSymbol :: SpecialSymbol
CoercionBindSymbol :: SpecialSymbol
TypeSymbol :: SpecialSymbol
TypeBindSymbol :: SpecialSymbol
ForallSymbol :: SpecialSymbol
ConjSymbol :: SpecialSymbol
DisjSymbol :: SpecialSymbol
ImplSymbol :: SpecialSymbol
EquivSymbol :: SpecialSymbol
data SyntaxForColor
KeywordColor :: SyntaxForColor
SyntaxColor :: SyntaxForColor
IdColor :: SyntaxForColor
CoercionColor :: SyntaxForColor
TypeColor :: SyntaxForColor
LitColor :: SyntaxForColor
WarningColor :: SyntaxForColor
specialSymbol :: AbsolutePathH -> SpecialSymbol -> DocH
symbol :: AbsolutePathH -> Char -> DocH
keyword :: AbsolutePathH -> String -> DocH
coreRenders :: [(String, PrettyOptions -> DocH -> String)]
renderCode :: RenderCode a => PrettyOptions -> DocH -> a
class (RenderSpecial a, Monoid a) => RenderCode a where rStart = mempty rEnd = mempty
rStart :: RenderCode a => a
rEnd :: RenderCode a => a
rDoHighlight :: RenderCode a => Maybe Attr -> [Attr] -> a
rPutStr :: RenderCode a => String -> a
class RenderSpecial a
renderSpecial :: RenderSpecial a => SpecialSymbol -> a
newtype Unicode
Unicode :: Char -> Unicode
data PrettyPrinter
PP :: PrettyH [Var] -> PrettyH CoreTC -> PrettyOptions -> PrettyPrinter
pForall :: PrettyPrinter -> PrettyH [Var]
pCoreTC :: PrettyPrinter -> PrettyH CoreTC
pOptions :: PrettyPrinter -> PrettyOptions
type PrettyH a = Transform PrettyC HermitM a DocH
data PrettyHLCoreBox
PrettyHLCoreBox :: (PrettyH LCore) -> PrettyHLCoreBox
data PrettyHLCoreTCBox
PrettyHLCoreTCBox :: (PrettyH LCoreTC) -> PrettyHLCoreTCBox
data TransformLCoreDocHBox
TransformLCoreDocHBox :: (TransformH LCore DocH) -> TransformLCoreDocHBox
data TransformLCoreTCDocHBox
TransformLCoreTCDocHBox :: (TransformH LCoreTC DocH) -> TransformLCoreTCDocHBox
liftPrettyH :: (LemmaContext c, ReadBindings c, ReadPath c Crumb) => PrettyOptions -> Transform PrettyC HermitM a b -> Transform c HermitM a b

-- | Context for PrettyH translations.
data PrettyC
PrettyC :: AbsolutePathH -> Map Var AbsolutePathH -> PrettyOptions -> Lemmas -> PrettyC
prettyC_path :: PrettyC -> AbsolutePathH
prettyC_vars :: PrettyC -> Map Var AbsolutePathH
prettyC_options :: PrettyC -> PrettyOptions
prettyC_lemmas :: PrettyC -> Lemmas
initPrettyC :: PrettyOptions -> PrettyC
liftPrettyC :: (LemmaContext c, ReadBindings c, ReadPath c Crumb) => PrettyOptions -> c -> PrettyC
data PrettyOptions
PrettyOptions :: Bool -> ShowOption -> ShowOption -> ShowOption -> Bool -> Maybe PathH -> Maybe Int -> Bool -> Float -> Int -> PrettyOptions

-- | Do you show fully qualified names?
po_fullyQualified :: PrettyOptions -> Bool

-- | Do you hide types, and type arguments, as &lt;&gt;?
po_exprTypes :: PrettyOptions -> ShowOption

-- | Do you hide coercions?
po_coercions :: PrettyOptions -> ShowOption

-- | Do you give the types for all bindings?
po_typesForBinders :: PrettyOptions -> ShowOption

-- | Append uniques to OccNames? (Like GHC does)
po_showUniques :: PrettyOptions -> Bool

-- | This region should be highlighted (is the current focus)
po_focus :: PrettyOptions -> Maybe PathH

-- | below this depth are ..., Nothing =&gt; infinite
po_depth :: PrettyOptions -> Maybe Int

-- | notes might be added to output
po_notes :: PrettyOptions -> Bool
po_ribbon :: PrettyOptions -> Float
po_width :: PrettyOptions -> Int
updateCoShowOption :: ShowOption -> PrettyOptions -> PrettyOptions
updateTypeShowOption :: ShowOption -> PrettyOptions -> PrettyOptions
updateWidthOption :: Int -> PrettyOptions -> PrettyOptions

-- | wrap a document in spaces
pad :: MDoc a -> MDoc a

-- | like vcat and hcat, only make the list syntax explicit
hlist :: [MDoc a] -> MDoc a

-- | like vcat and hcat, only make the list syntax explicit
vlist :: [MDoc a] -> MDoc a
showRole :: Role -> String
instance Typeable TransformLCoreDocHBox
instance Typeable TransformLCoreTCDocHBox
instance Typeable PrettyHLCoreTCBox
instance Typeable PrettyHLCoreBox
instance Typeable PrettyPrinter
instance Eq SyntaxForColor
instance Show SyntaxForColor
instance Eq Attr
instance Show Attr
instance Show HermitMark
instance Eq ShowOption
instance Ord ShowOption
instance Show ShowOption
instance Read ShowOption
instance Show PrettyOptions
instance Show SpecialSymbol
instance Eq SpecialSymbol
instance Ord SpecialSymbol
instance Bounded SpecialSymbol
instance Enum SpecialSymbol
instance RenderCode DebugPretty
instance Monoid DebugPretty
instance RenderSpecial DebugPretty
instance RenderCode ASCII
instance RenderCode HTML
instance RenderCode LaTeX
instance RenderSpecial HTML
instance Monoid HTML
instance RenderSpecial LaTeX
instance Monoid LaTeX
instance RenderSpecial Unicode
instance RenderSpecial ASCII
instance Monoid ASCII
instance RenderSpecial Char
instance Default PrettyOptions
instance LemmaContext PrettyC
instance HasEmptyContext PrettyC
instance BoundVars PrettyC
instance AddBindings PrettyC
instance ExtendPath PrettyC Crumb
instance ReadPath PrettyC Crumb
instance Extern (TransformH LCoreTC DocH)
instance Extern (PrettyH LCoreTC)
instance Extern (TransformH LCore DocH)
instance Extern (PrettyH LCore)
instance Extern PrettyPrinter

module HERMIT.Dictionary.Fold
externals :: [External]
foldR :: (ReadBindings c, HasHermitMEnv m, LiftCoreM m, MonadCatch m, MonadIO m, MonadThings m, MonadUnique m) => HermitName -> Rewrite c m CoreExpr
foldVarR :: (ReadBindings c, MonadCatch m, MonadUnique m) => Maybe BindingDepth -> Var -> Rewrite c m CoreExpr
foldVarConfigR :: (ReadBindings c, MonadCatch m, MonadUnique m) => InlineConfig -> Maybe BindingDepth -> Var -> Rewrite c m CoreExpr

-- | Rewrite using a compiled fold. Useful inside traversal strategies like
--   anytdR, because you can compile the fold once outside the traversal,
--   then apply it everywhere in the tree.
runFoldR :: (BoundVars c, Monad m) => CompiledFold -> Rewrite c m CoreExpr

-- | Attempt to apply a list of Equalitys to the given expression, folding
--   the left-hand side into an application of the right-hand side. This
--   implementation depends on <a>Equality</a> being well-formed. That is,
--   both the LHS and RHS are NOT lambda expressions. Always use
--   <a>mkEquality</a> to ensure this is the case.
fold :: BoundVars c => [Equality] -> c -> CoreExpr -> Maybe CoreExpr

-- | Compile a list of Equality's into a single fold matcher.
compileFold :: [Equality] -> CompiledFold

-- | Attempt to fold an expression using a matcher in a given context.
runFold :: BoundVars c => CompiledFold -> c -> CoreExpr -> Maybe CoreExpr

-- | Attempt to fold an expression using a matcher in a given context.
--   Return resulting expression and a map of what when in the holes in the
--   pattern.
runFoldMatches :: BoundVars c => CompiledFold -> c -> CoreExpr -> Maybe (CoreExpr, VarEnv CoreExpr)
data CompiledFold

-- | Determine if the left Clause <a>proves</a> the right Clause. Here,
--   <a>proves</a> means that the clause is a substitution instance of the
--   left one, where the top-level binders of the left clause are the
--   holes.
proves :: Clause -> Clause -> Bool

-- | Determine if the right Clause is a substitution instance of the left
--   Clause (which is a pattern with a given set of holes).
lemmaMatch :: [Var] -> Clause -> Clause -> Maybe (VarEnv CoreExpr)

-- | An equality is represented as a set of universally quantified binders,
--   and the LHS and RHS of the equality.
data Equality
Equality :: [CoreBndr] -> CoreExpr -> CoreExpr -> Equality
toEqualities :: Clause -> [Equality]

-- | Flip the LHS and RHS of a <a>Equality</a>.
flipEquality :: Equality -> Equality
freeVarsEquality :: Equality -> VarSet
ppEqualityT :: PrettyPrinter -> PrettyH Equality
instance Typeable RewriteEqualityBox
instance Typeable TransformEqualityStringBox
instance Typeable TransformEqualityUnitBox
instance Extern (TransformH Equality ())
instance Extern (TransformH Equality String)
instance Extern (RewriteH Equality)
instance Fold CLMap
instance Fold AMap
instance Fold m => Fold (ListMap m)
instance Fold EMap
instance Fold TyLitMap
instance Fold TyMap
instance Fold VMap


-- | Output the raw Expr constructors. Helpful for writing pattern matching
--   rewrites.
module HERMIT.PrettyPrinter.AST
externals :: [External]
pretty :: PrettyPrinter

-- | Pretty print a fragment of GHC Core using HERMIT's "AST" pretty
--   printer. This displays the tree of constructors using nested
--   indentation.
ppCoreTC :: PrettyH CoreTC
ppModGuts :: PrettyH ModGuts
ppCoreProg :: PrettyH CoreProg
ppCoreBind :: PrettyH CoreBind
ppCoreExpr :: PrettyH CoreExpr
ppCoreAlt :: PrettyH CoreAlt
ppKindOrType :: PrettyH Type
ppCoercion :: PrettyH Coercion
ppForallQuantification :: PrettyH [Var]

module HERMIT.PrettyPrinter.Clean
externals :: [External]
pretty :: PrettyPrinter

-- | Pretty print a fragment of GHC Core using HERMIT's "Clean" pretty
--   printer.
ppCoreTC :: PrettyH CoreTC
ppModGuts :: PrettyH ModGuts
ppCoreProg :: PrettyH CoreProg
ppCoreBind :: PrettyH CoreBind
ppCoreExpr :: PrettyH CoreExpr
ppCoreAlt :: PrettyH CoreAlt
ppKindOrType :: PrettyH KindOrType
ppCoercion :: PrettyH Coercion
ppForallQuantification :: PrettyH [Var]
instance Eq ArrowType
instance Show ArrowType


-- | Output the raw Expr constructors. Helpful for writing pattern matching
--   rewrites.
module HERMIT.PrettyPrinter.GHC
externals :: [External]
pretty :: PrettyPrinter

-- | This pretty printer is just a reflection of GHC's standard pretty
--   printer.
ppCoreTC :: PrettyH CoreTC
ppModGuts :: PrettyH ModGuts
ppCoreProg :: PrettyH CoreProg
ppCoreBind :: PrettyH CoreBind
ppCoreExpr :: PrettyH CoreExpr
ppCoreAlt :: PrettyH CoreAlt
ppKindOrType :: PrettyH Type
ppCoercion :: PrettyH Coercion
ppForallQuantification :: PrettyH [Var]

module HERMIT.Shell.Dictionary

-- | Create a dictionary from a list of <a>External</a>s.
mkDictionary :: [External] -> Dictionary
addToDictionary :: External -> Dictionary -> Dictionary

-- | The pretty-printing dictionaries.
pp_dictionary :: Map String PrettyPrinter

module HERMIT.Dictionary.Local.Let

-- | Externals relating to <a>Let</a> expressions.
externals :: [External]

-- | <tt>Let (NonRec v e) body</tt> ==&gt; <tt>body[e/v]</tt>
letNonRecSubstR :: MonadCatch m => Rewrite c m CoreExpr

-- | Currently we always substitute types and coercions, and use a
--   heuristic to decide whether to substitute expressions. This may need
--   revisiting.
letNonRecSubstSafeR :: (AddBindings c, ExtendPath c Crumb, ReadPath c Crumb, ReadBindings c, HasEmptyContext c, MonadCatch m) => Rewrite c m CoreExpr

-- | (let x = e1 in e2) ==&gt; (e2[e1/x]), (x must not be free in e1)
letSubstR :: (AddBindings c, ExtendPath c Crumb, ReadPath c Crumb, MonadCatch m) => Rewrite c m CoreExpr

-- | As <a>letNonRecSubstSafeR</a>, but attempting to convert a singleton
--   recursive binding to a non-recursive binding first.
letSubstSafeR :: (AddBindings c, ExtendPath c Crumb, ReadPath c Crumb, ReadBindings c, HasEmptyContext c, MonadCatch m) => Rewrite c m CoreExpr
letElimR :: (ExtendPath c Crumb, AddBindings c, MonadCatch m) => Rewrite c m CoreExpr

-- | Remove an unused non-recursive let binding. <tt>let v = E1 in E2</tt>
--   ==&gt; <tt>E2</tt>, if <tt>v</tt> is not free in <tt>E2</tt>
letNonRecElimR :: MonadCatch m => Rewrite c m CoreExpr

-- | Remove all unused recursive let bindings in the current group.
letRecElimR :: MonadCatch m => Rewrite c m CoreExpr
progBindElimR :: MonadCatch m => Rewrite c m CoreProg
progBindNonRecElimR :: MonadCatch m => Rewrite c m CoreProg

-- | Remove all unused bindings at the top level.
progBindRecElimR :: MonadCatch m => Rewrite c m CoreProg

-- | <tt>e</tt> ==&gt; <tt>let v = e in v</tt>
letIntroR :: (MonadCatch m, MonadUnique m) => String -> Rewrite c m CoreExpr

-- | <tt>body</tt> ==&gt; <tt>let v = e in body</tt>
letNonRecIntroR :: (MonadCatch m, MonadUnique m) => String -> CoreExpr -> Rewrite c m CoreExpr

-- | <tt>prog</tt> ==&gt; <tt><a>ProgCons</a> (v = e) prog</tt>
progNonRecIntroR :: (MonadCatch m, MonadUnique m) => String -> CoreExpr -> Rewrite c m CoreProg

-- | nonRecIntroR nm e = 'letNonRecIntroR nm e' &lt;+ 'progNonRecIntroR nm
--   e'
nonRecIntroR :: (MonadCatch m, MonadUnique m) => String -> CoreExpr -> Rewrite c m Core

-- | Introduce a local definition for a (possibly imported) identifier.
--   Rewrites occurences of the identifier to point to this new local
--   definiton.
letIntroUnfoldingR :: (BoundVars c, ReadBindings c, HasDynFlags m, HasHermitMEnv m, LiftCoreM m, MonadCatch m, MonadIO m, MonadThings m, MonadUnique m) => HermitName -> Rewrite c m CoreExpr

-- | <tt>(let v = ev in e) x</tt> ==&gt; <tt>let v = ev in e x</tt>
letFloatAppR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, BoundVars c, MonadCatch m, MonadUnique m) => Rewrite c m CoreExpr

-- | <tt>f (let v = ev in e)</tt> ==&gt; <tt>let v = ev in f e</tt>
letFloatArgR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, BoundVars c, MonadCatch m, MonadUnique m) => Rewrite c m CoreExpr

-- | <tt>let v = (let bds in e1) in e2</tt> ==&gt; <tt>let bds in let v =
--   e1 in e2</tt>
letFloatLetR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, BoundVars c, MonadCatch m, MonadUnique m) => Rewrite c m CoreExpr

-- | <tt>( v -&gt; let binds in e2)</tt> ==&gt; <tt>let binds in ( v1 -&gt;
--   e2)</tt> Fails if <tt>v</tt> occurs in the RHS of <tt>binds</tt>. If
--   <tt>v</tt> is shadowed in binds, then <tt>v</tt> will be
--   alpha-renamed.
letFloatLamR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, BoundVars c, MonadCatch m, MonadUnique m) => Rewrite c m CoreExpr

-- | <tt>case (let bnds in e) of bndr alts</tt> ==&gt; <tt>let bnds in
--   (case e of bndr alts)</tt> Fails if any variables bound in
--   <tt>bnds</tt> occurs in <tt>alts</tt>.
letFloatCaseR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, BoundVars c, MonadCatch m, MonadUnique m) => Rewrite c m CoreExpr

-- | case e of w { ... ; p -&gt; let b = rhs in body ; ... } ==&gt; let b =
--   rhs in case e of { ... ; p -&gt; body ; ... }
--   
--   where no variable in <tt>p</tt> or <tt>w</tt> occurs freely in
--   <tt>rhs</tt>, and where <tt>b</tt> does not capture a free variable in
--   the overall case, and where <tt>w</tt> is not rebound in <tt>b</tt>.
letFloatCaseAltR :: MonadCatch m => Maybe Int -> Rewrite c m CoreExpr

-- | <tt>cast (let bnds in e) co</tt> ==&gt; <tt>let bnds in cast e co</tt>
letFloatCastR :: MonadCatch m => Rewrite c m CoreExpr

-- | Float a <a>Let</a> through an expression, whatever the context.
letFloatExprR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, BoundVars c, MonadCatch m, MonadUnique m) => Rewrite c m CoreExpr

-- | <tt><a>ProgCons</a> (<a>NonRec</a> v (<a>Let</a> bds e)) p</tt> ==&gt;
--   <tt><a>ProgCons</a> bds (<a>ProgCons</a> (<a>NonRec</a> v e) p)</tt>
letFloatTopR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, BoundVars c, MonadCatch m, MonadUnique m) => Rewrite c m CoreProg

-- | Float in a <a>Let</a> if possible.
letFloatInR :: (AddBindings c, BoundVars c, ExtendPath c Crumb, ReadPath c Crumb, MonadCatch m, MonadUnique m) => Rewrite c m CoreExpr

-- | <tt>let v = ev in f a</tt> ==&gt; <tt>(let v = ev in f) (let v = ev in
--   a)</tt>
letFloatInAppR :: (AddBindings c, BoundVars c, ExtendPath c Crumb, ReadPath c Crumb, MonadCatch m, MonadUnique m) => Rewrite c m CoreExpr

-- | <tt>let v = ev in case s of p -&gt; e</tt> ==&gt; <tt>case (let v = ev
--   in s) of p -&gt; let v = ev in e</tt>, if <tt>v</tt> does not shadow a
--   pattern binder in <tt>p</tt>
letFloatInCaseR :: (AddBindings c, BoundVars c, ExtendPath c Crumb, ReadPath c Crumb, MonadCatch m, MonadUnique m) => Rewrite c m CoreExpr

-- | <tt>let v = ev in x -&gt; e</tt> ==&gt; <tt>x -&gt; let v = ev in
--   e</tt> if <tt>v</tt> does not shadow <tt>x</tt>
letFloatInLamR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => Rewrite c m CoreExpr

-- | Re-order a sequence of nested non-recursive let bindings. The argument
--   list should contain the let-bound variables, in the desired order.
reorderNonRecLetsR :: MonadCatch m => [String] -> Rewrite c m CoreExpr

-- | Combine nested non-recursive lets into case of a tuple. E.g. let {v1 =
--   e1 ; v2 = e2 ; v3 = e3} in body ==&gt; case (e1,e2,e3) of {(v1,v2,v3)
--   -&gt; body}
letTupleR :: (MonadCatch m, MonadUnique m) => String -> Rewrite c m CoreExpr

-- | <tt>let v = ev in e</tt> ==&gt; <tt>case ev of v -&gt; e</tt>
letToCaseR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, ReadBindings c, MonadCatch m, MonadUnique m) => Rewrite c m CoreExpr

module HERMIT.Dictionary.New
externals :: [External]

-- | Test if the current expression is an identifier matching the given
--   name.
isVar :: (ExtendPath c Crumb, AddBindings c, MonadCatch m) => String -> Transform c m CoreExpr ()

-- | <tt>prog</tt> ==&gt; <tt><a>ProgCons</a> (v = e) prog</tt>
nonRecIntro :: String -> CoreString -> RewriteH Core

module HERMIT.ParserType

-- | Parse a CoreString into a Type, where all type variables must be
--   bound.
parseType :: CoreString -> HermitC -> HermitM Type

-- | Parse a <a>CoreString</a> to a <a>Type</a>, using the current context.
parseTypeT :: CoreString -> TransformH a Type

-- | Parse a CoreString into a Type, any unbound variables are returned.
parseTypeWithHoles :: CoreString -> HermitC -> HermitM (Type, [TyVar])

-- | Parse a <a>CoreString</a> to a <a>Type</a>, using the current context,
--   returning unbound type variables.
parseTypeWithHolesT :: CoreString -> TransformH a (Type, [TyVar])

module HERMIT.Dictionary.Reasoning
externals :: [External]
type EqualityProof c m = (Rewrite c m CoreExpr, Rewrite c m CoreExpr)

-- | <tt>e</tt> ==&gt; <tt>let v = lhs in e</tt>
eqLhsIntroR :: Clause -> Rewrite c HermitM Core

-- | <tt>e</tt> ==&gt; <tt>let v = rhs in e</tt>
eqRhsIntroR :: Clause -> Rewrite c HermitM Core

-- | Create a <a>BiRewrite</a> from a <a>Clause</a>.
birewrite :: (AddBindings c, ExtendPath c Crumb, HasEmptyContext c, ReadBindings c, ReadPath c Crumb, MonadCatch m, MonadUnique m) => Clause -> BiRewrite c m CoreExpr

-- | f == g ==&gt; forall x. f x == g x
extensionalityR :: (AddBindings c, ExtendPath c Crumb, ReadPath c Crumb) => Maybe String -> Rewrite c HermitM Clause
getLemmasT :: (LemmaContext c, HasLemmas m, Monad m) => Transform c m x Lemmas
getLemmaByNameT :: (LemmaContext c, HasLemmas m, Monad m) => LemmaName -> Transform c m x Lemma
insertLemmaT :: (HasLemmas m, Monad m) => LemmaName -> Lemma -> Transform c m a ()
insertLemmasT :: (HasLemmas m, Monad m) => [NamedLemma] -> Transform c m a ()
lemmaBiR :: (AddBindings c, ExtendPath c Crumb, HasEmptyContext c, LemmaContext c, ReadBindings c, ReadPath c Crumb, HasLemmas m, MonadCatch m, MonadUnique m) => Used -> LemmaName -> BiRewrite c m CoreExpr
lemmaConsequentR :: (AddBindings c, ExtendPath c Crumb, HasEmptyContext c, LemmaContext c, ReadBindings c, ReadPath c Crumb, HasLemmas m, MonadCatch m, MonadUnique m) => Used -> LemmaName -> Rewrite c m Clause
markLemmaUsedT :: (LemmaContext c, HasLemmas m, MonadCatch m) => LemmaName -> Used -> Transform c m a ()
markLemmaProvenT :: (LemmaContext c, HasLemmas m, MonadCatch m) => LemmaName -> Proven -> Transform c m a ()
modifyLemmaT :: (LemmaContext c, HasLemmas m, Monad m) => LemmaName -> (LemmaName -> LemmaName) -> Rewrite c m Clause -> (Proven -> Proven) -> (Used -> Used) -> Transform c m a ()
showLemmaT :: LemmaName -> PrettyPrinter -> PrettyH a
showLemmasT :: Maybe LemmaName -> PrettyPrinter -> PrettyH a
ppLemmaT :: PrettyPrinter -> LemmaName -> PrettyH Lemma
ppClauseT :: PrettyPrinter -> PrettyH Clause
ppLCoreTCT :: PrettyPrinter -> PrettyH LCoreTC

-- | Lift a transformation over <a>LCoreTC</a> into a transformation over
--   the left-hand side of a <a>Clause</a>.
lhsT :: (AddBindings c, HasEmptyContext c, LemmaContext c, ReadPath c Crumb, ExtendPath c Crumb, MonadCatch m) => Transform c m LCore a -> Transform c m Clause a

-- | Lift a transformation over <a>LCoreTC</a> into a transformation over
--   the right-hand side of a <a>Clause</a>.
rhsT :: (AddBindings c, HasEmptyContext c, LemmaContext c, ReadPath c Crumb, ExtendPath c Crumb, MonadCatch m) => Transform c m LCore a -> Transform c m Clause a

-- | Lift a transformation over <a>LCoreTC</a> into a transformation over
--   both sides of a <a>Clause</a>.
bothT :: (AddBindings c, HasEmptyContext c, LemmaContext c, ReadPath c Crumb, ExtendPath c Crumb, MonadCatch m) => Transform c m LCore a -> Transform c m Clause (a, a)

-- | Lift a rewrite over <a>LCoreTC</a> into a rewrite over the left-hand
--   side of a <a>Clause</a>.
lhsR :: (AddBindings c, HasEmptyContext c, LemmaContext c, ReadPath c Crumb, ExtendPath c Crumb, MonadCatch m) => Rewrite c m LCore -> Rewrite c m Clause

-- | Lift a rewrite over <a>LCoreTC</a> into a rewrite over the right-hand
--   side of a <a>Clause</a>.
rhsR :: (AddBindings c, HasEmptyContext c, LemmaContext c, ReadPath c Crumb, ExtendPath c Crumb, MonadCatch m) => Rewrite c m LCore -> Rewrite c m Clause

-- | Lift a rewrite over <a>LCoreTC</a> into a rewrite over both sides of a
--   <a>Clause</a>.
bothR :: (AddBindings c, HasEmptyContext c, LemmaContext c, ReadPath c Crumb, ExtendPath c Crumb, MonadCatch m) => Rewrite c m LCore -> Rewrite c m Clause
verifyClauseT :: (AddBindings c, ReadPath c Crumb, ExtendPath c Crumb, MonadCatch m) => Transform c m Clause ()
lemmaR :: (LemmaContext c, HasLemmas m, MonadCatch m) => Used -> LemmaName -> Rewrite c m Clause
quantIdentitiesR :: MonadCatch m => Rewrite c m Clause
verifyOrCreateT :: (AddBindings c, ExtendPath c Crumb, HasCoreRules c, LemmaContext c, ReadBindings c, ReadPath c Crumb, HasHermitMEnv m, HasLemmas m, LiftCoreM m, MonadCatch m) => Used -> LemmaName -> Clause -> Transform c m a ()

-- | Given two expressions, and a rewrite from the former to the latter,
--   verify that rewrite.
verifyEqualityLeftToRightT :: MonadCatch m => CoreExpr -> CoreExpr -> Rewrite c m CoreExpr -> Transform c m a ()

-- | Given two expressions, and a rewrite to apply to each, verify that the
--   resulting expressions are equal.
verifyEqualityCommonTargetT :: MonadCatch m => CoreExpr -> CoreExpr -> EqualityProof c m -> Transform c m a ()

-- | Given f :: X -&gt; Y and g :: Y -&gt; X, verify that f (g y) ==&gt; y
--   and g (f x) ==&gt; x.
verifyIsomorphismT :: CoreExpr -> CoreExpr -> Rewrite c HermitM CoreExpr -> Rewrite c HermitM CoreExpr -> Transform c HermitM a ()

-- | Given f :: X -&gt; Y and g :: Y -&gt; X, verify that f (g y) ==&gt; y.
verifyRetractionT :: CoreExpr -> CoreExpr -> Rewrite c HermitM CoreExpr -> Transform c HermitM a ()
reflexivityR :: Monad m => Rewrite c m Clause
simplifyClauseR :: (AddBindings c, ExtendPath c Crumb, HasEmptyContext c, LemmaContext c, ReadPath c Crumb, MonadCatch m) => Rewrite c m LCore

-- | Given f :: X -&gt; Y and g :: Y -&gt; X, and a proof that f (g y)
--   ==&gt; y, then f (g y) <a>==</a> y.
retractionBR :: Maybe (Rewrite c HermitM CoreExpr) -> CoreExpr -> CoreExpr -> BiRewrite c HermitM CoreExpr
unshadowClauseR :: MonadUnique m => Rewrite c m Clause
instantiateDictsR :: RewriteH Clause
instantiateClauseVarR :: (Var -> Bool) -> CoreString -> RewriteH Clause

-- | Replace all occurrences of the given expression with a new quantified
--   variable.
abstractClauseR :: (AddBindings c, BoundVars c, ExtendPath c Crumb, HasEmptyContext c, ReadBindings c, ReadPath c Crumb, LemmaContext c, HasHermitMEnv m, HasLemmas m, LiftCoreM m, MonadCatch m, MonadUnique m) => String -> Transform c m Clause CoreExpr -> Rewrite c m Clause
($$) :: (ToCoreExpr a, ToCoreExpr b, MonadCatch m) => a -> b -> m CoreExpr
($$$) :: (ToCoreExpr a, ToCoreExpr b, MonadCatch m) => a -> [b] -> m CoreExpr
(==>) :: (LemmaName, Clause) -> Clause -> Clause
(-->) :: Type -> Type -> Type
(===) :: (ToCoreExpr a, ToCoreExpr b) => a -> b -> Clause
(/\) :: Clause -> Clause -> Clause
(\/) :: Clause -> Clause -> Clause
class ToCoreExpr a
toCE :: ToCoreExpr a => a -> CoreExpr
newLemma :: LemmaName -> Clause -> Map LemmaName Lemma
instance ToCoreExpr Type
instance ToCoreExpr Var
instance ToCoreExpr CoreExpr

module HERMIT.Dictionary.Remembered
externals :: [External]
prefixRemembered :: LemmaName -> LemmaName

-- | Remember a binding with a name for later use. Allows us to look at
--   past definitions.
rememberR :: (AddBindings c, ExtendPath c Crumb, ReadPath c Crumb, HasLemmas m, MonadCatch m) => LemmaName -> Transform c m Core ()

-- | Unfold a remembered definition (like unfoldR, but looks in stash
--   instead of context).
unfoldRememberedR :: (AddBindings c, ExtendPath c Crumb, HasEmptyContext c, LemmaContext c, ReadBindings c, ReadPath c Crumb, HasLemmas m, MonadCatch m, MonadUnique m) => Used -> LemmaName -> Rewrite c m CoreExpr

-- | Fold a remembered definition (like foldR, but looks in stash instead
--   of context).
foldRememberedR :: (AddBindings c, ExtendPath c Crumb, HasEmptyContext c, LemmaContext c, ReadBindings c, ReadPath c Crumb, HasLemmas m, MonadCatch m, MonadUnique m) => Used -> LemmaName -> Rewrite c m CoreExpr

-- | Fold any of the remembered definitions.
foldAnyRememberedR :: (AddBindings c, ExtendPath c Crumb, HasEmptyContext c, LemmaContext c, ReadBindings c, ReadPath c Crumb, HasLemmas m, MonadCatch m, MonadUnique m) => Rewrite c m CoreExpr

-- | Compile all remembered definitions into something that can be run with
--   <a>runFoldR</a>
compileRememberedT :: (LemmaContext c, HasLemmas m, Monad m) => Transform c m x CompiledFold

module HERMIT.Dictionary.Rules

-- | Externals dealing with GHC rewrite rules.
externals :: [External]
newtype RuleName
RuleName :: String -> RuleName
newtype RuleNameListBox
RuleNameListBox :: [RuleName] -> RuleNameListBox

-- | Lookup a rule by name, attempt to apply it left-to-right. If
--   successful, record it as an unproven lemma.
foldRuleR :: (AddBindings c, ExtendPath c Crumb, HasCoreRules c, HasEmptyContext c, LemmaContext c, ReadBindings c, ReadPath c Crumb, HasDynFlags m, HasHermitMEnv m, HasLemmas m, LiftCoreM m, MonadCatch m, MonadIO m, MonadThings m, MonadUnique m) => Used -> RuleName -> Rewrite c m CoreExpr

-- | Lookup a set of rules by name, attempt to apply them left-to-right.
--   Record an unproven lemma for the one that succeeds.
foldRulesR :: (AddBindings c, ExtendPath c Crumb, HasCoreRules c, HasEmptyContext c, LemmaContext c, ReadBindings c, ReadPath c Crumb, HasDynFlags m, HasHermitMEnv m, HasLemmas m, LiftCoreM m, MonadCatch m, MonadIO m, MonadThings m, MonadUnique m) => Used -> [RuleName] -> Rewrite c m CoreExpr

-- | Lookup a rule by name, attempt to apply it left-to-right. If
--   successful, record it as an unproven lemma.
unfoldRuleR :: (AddBindings c, ExtendPath c Crumb, HasCoreRules c, HasEmptyContext c, LemmaContext c, ReadBindings c, ReadPath c Crumb, HasDynFlags m, HasHermitMEnv m, HasLemmas m, LiftCoreM m, MonadCatch m, MonadIO m, MonadThings m, MonadUnique m) => Used -> RuleName -> Rewrite c m CoreExpr

-- | Lookup a set of rules by name, attempt to apply them left-to-right.
--   Record an unproven lemma for the one that succeeds.
unfoldRulesR :: (AddBindings c, ExtendPath c Crumb, HasCoreRules c, HasEmptyContext c, LemmaContext c, ReadBindings c, ReadPath c Crumb, HasDynFlags m, HasHermitMEnv m, HasLemmas m, LiftCoreM m, MonadCatch m, MonadIO m, MonadThings m, MonadUnique m) => Used -> [RuleName] -> Rewrite c m CoreExpr

-- | Can be used with runFoldR. Note: currently doesn't create a lemma for
--   the rule used.
compileRulesT :: (BoundVars c, HasCoreRules c, HasHermitMEnv m, LiftCoreM m, MonadCatch m, MonadIO m, MonadThings m) => [RuleName] -> Transform c m a CompiledFold

-- | Transform GHC's CoreRule into an Clause.
ruleToClauseT :: (BoundVars c, HasHermitMEnv m, MonadThings m, MonadCatch m) => Transform c m CoreRule Clause

-- | Build an Clause from a named GHC rewrite rule.
ruleNameToClauseT :: (BoundVars c, HasCoreRules c, HasDynFlags m, HasHermitMEnv m, LiftCoreM m, MonadCatch m, MonadIO m, MonadThings m) => RuleName -> Transform c m a Clause

-- | Get a GHC CoreRule by name.
getHermitRuleT :: (HasCoreRules c, HasHermitMEnv m, LiftCoreM m, MonadIO m) => RuleName -> Transform c m a CoreRule

-- | Return all in-scope CoreRules (including specialization RULES on
--   binders), with their names.
getHermitRulesT :: (HasCoreRules c, HasHermitMEnv m, LiftCoreM m, MonadIO m) => Transform c m a [(RuleName, CoreRule)]

-- | Run GHC's specConstr pass, and apply any rules generated.
specConstrR :: RewriteH ModGuts

-- | Run GHC's specialisation pass, and apply any rules generated.
specialiseR :: RewriteH ModGuts
instance Typeable RuleName
instance Typeable RuleNameListBox
instance Eq RuleName
instance Extern [RuleName]
instance Show RuleName
instance IsString RuleName
instance Extern RuleName

module HERMIT.Dictionary.Undefined
externals :: [External]

-- | Add a lemma for the strictness of a function. Note: assumes added
--   lemma has been used
buildStrictnessLemmaT :: (AddBindings c, ExtendPath c Crumb, HasCoreRules c, LemmaContext c, ReadBindings c, ReadPath c Crumb, HasDynFlags m, LiftCoreM m, HasHermitMEnv m, HasLemmas m, MonadCatch m, MonadIO m, MonadThings m) => Used -> LemmaName -> CoreExpr -> Transform c m x ()

-- | Verify that the given rewrite is a proof that the given expression is
--   a strict function.
verifyStrictT :: (BoundVars c, MonadCatch m, HasHermitMEnv m, HasDynFlags m, LiftCoreM m, MonadIO m, MonadThings m) => CoreExpr -> Rewrite c m CoreExpr -> Transform c m a ()

-- | Apply the given expression to undefined, at the proper type.
applyToUndefinedT :: (BoundVars c, HasDynFlags m, LiftCoreM m, HasHermitMEnv m, MonadCatch m, MonadIO m, MonadThings m) => CoreExpr -> Transform c m x CoreExpr

-- | Make an undefined value of the given type.
mkUndefinedValT :: (BoundVars c, MonadCatch m, HasHermitMEnv m, HasDynFlags m, LiftCoreM m, MonadIO m, MonadThings m) => Type -> Transform c m a CoreExpr

-- | Check if the current expression is an undefined value.
isUndefinedValT :: (BoundVars c, MonadCatch m, HasHermitMEnv m, HasDynFlags m, LiftCoreM m, MonadIO m, MonadThings m) => Transform c m CoreExpr ()

-- | Set the current expression to <a>undefined</a>.
replaceCurrentExprWithUndefinedR :: (BoundVars c, MonadCatch m, HasHermitMEnv m, HasDynFlags m, LiftCoreM m, MonadIO m, MonadThings m) => Rewrite c m CoreExpr

-- | Replace all occurrences of the specified identifier with
--   <a>undefined</a>.
replaceIdWithUndefinedR :: (BoundVars c, MonadCatch m, HasHermitMEnv m, HasDynFlags m, LiftCoreM m, MonadIO m, MonadThings m) => Id -> Rewrite c m Core

-- | error ty string ==&gt; undefined ty
errorToUndefinedR :: (BoundVars c, MonadCatch m, HasHermitMEnv m, HasDynFlags m, LiftCoreM m, MonadIO m, MonadThings m) => Rewrite c m CoreExpr

-- | undefinedExprR = undefinedAppR &lt;+ undefinedLamR &lt;+ undefinedLetR
--   &lt;+ undefinedCastR &lt;+ undefinedTickR &lt;+ undefinedCaseR
undefinedExprR :: (AddBindings c, BoundVars c, ExtendPath c Crumb, ReadPath c Crumb, MonadCatch m, HasHermitMEnv m, HasDynFlags m, LiftCoreM m, MonadIO m, MonadThings m) => Rewrite c m CoreExpr

-- | <tt>(undefined ty1) e</tt> ==&gt; <tt>undefined ty2</tt>
undefinedAppR :: (BoundVars c, ExtendPath c Crumb, MonadCatch m, HasHermitMEnv m, HasDynFlags m, LiftCoreM m, MonadIO m, MonadThings m) => Rewrite c m CoreExpr

-- | <tt>( v -&gt; undefined ty1)</tt> ==&gt; <tt>undefined ty2</tt> (where
--   v is not a <a>TyVar</a>)
undefinedLamR :: (AddBindings c, BoundVars c, ExtendPath c Crumb, ReadPath c Crumb, MonadCatch m, HasHermitMEnv m, HasDynFlags m, LiftCoreM m, MonadIO m, MonadThings m) => Rewrite c m CoreExpr

-- | let bds in (undefined ty) ==&gt; undefined ty
undefinedLetR :: (AddBindings c, BoundVars c, ExtendPath c Crumb, ReadPath c Crumb, MonadCatch m, HasHermitMEnv m, HasDynFlags m, LiftCoreM m, MonadIO m, MonadThings m) => Rewrite c m CoreExpr

-- | case (undefined ty) of alts ==&gt; undefined ty
undefinedCaseScrutineeR :: (AddBindings c, BoundVars c, ExtendPath c Crumb, ReadPath c Crumb, MonadCatch m, HasHermitMEnv m, HasDynFlags m, LiftCoreM m, MonadIO m, MonadThings m) => Rewrite c m CoreExpr

-- | case e of {pat_1 -&gt; undefined ty ; pat_2 -&gt; undefined ty ; ... ;
--   pat_n -&gt; undefined ty} ==&gt; undefined ty
undefinedCaseAltsR :: (AddBindings c, BoundVars c, ExtendPath c Crumb, ReadPath c Crumb, MonadCatch m, HasHermitMEnv m, HasDynFlags m, LiftCoreM m, MonadIO m, MonadThings m) => Rewrite c m CoreExpr

-- | undefinedCaseR = undefinedCaseScrutineeR &lt;+ undefinedCaseAltsR
undefinedCaseR :: (AddBindings c, BoundVars c, ExtendPath c Crumb, ReadPath c Crumb, MonadCatch m, HasHermitMEnv m, HasDynFlags m, LiftCoreM m, MonadIO m, MonadThings m) => Rewrite c m CoreExpr

-- | Cast (undefined ty1) co ==&gt; undefined ty2
undefinedCastR :: (BoundVars c, ExtendPath c Crumb, MonadCatch m, HasHermitMEnv m, HasDynFlags m, LiftCoreM m, MonadIO m, MonadThings m) => Rewrite c m CoreExpr

-- | Tick tick (undefined ty1) ==&gt; undefined ty1
undefinedTickR :: (BoundVars c, ExtendPath c Crumb, MonadCatch m, HasHermitMEnv m, HasDynFlags m, LiftCoreM m, MonadIO m, MonadThings m) => Rewrite c m CoreExpr

module HERMIT.Dictionary.FixPoint

-- | Externals for manipulating fixed points.
externals :: [External]
fixIntroR :: (AddBindings c, BoundVars c, ExtendPath c Crumb, HasEmptyContext c, ReadBindings c, ReadPath c Crumb, HasHermitMEnv m, LiftCoreM m, MonadCatch m, MonadIO m, MonadThings m, MonadUnique m) => Rewrite c m Core
fixIntroNonRecR :: (AddBindings c, BoundVars c, ExtendPath c Crumb, HasEmptyContext c, ReadBindings c, ReadPath c Crumb, HasHermitMEnv m, LiftCoreM m, MonadCatch m, MonadIO m, MonadThings m, MonadUnique m) => Rewrite c m CoreBind

-- | <tt>f = e</tt> ==&gt; <tt>f = fix (\ f -&gt; e)</tt>
fixIntroRecR :: (AddBindings c, BoundVars c, ExtendPath c Crumb, HasEmptyContext c, ReadBindings c, ReadPath c Crumb, HasHermitMEnv m, LiftCoreM m, MonadCatch m, MonadIO m, MonadThings m, MonadUnique m) => Rewrite c m CoreDef

-- | <tt>fix ty f</tt> &lt;==&gt; <tt>f (fix ty f)</tt>
fixComputationRuleBR :: BiRewriteH CoreExpr

-- | <tt>fix tyA (\ a -&gt; f (g a))</tt> &lt;==&gt; <tt>f (fix tyB (\ b
--   -&gt; g (f b))</tt>
fixRollingRuleBR :: BiRewriteH CoreExpr

-- | If <tt>f</tt> is strict, then (<tt>f (g a)</tt> == <tt>h (f a)</tt>)
--   ==&gt; (<tt>f (fix g)</tt> == <tt>fix h</tt>)
fixFusionRuleBR :: Maybe (EqualityProof HermitC HermitM) -> Maybe (RewriteH CoreExpr) -> CoreExpr -> CoreExpr -> CoreExpr -> BiRewriteH CoreExpr

-- | Check that the expression has the form "fix t (f :: t -&gt; t)",
--   returning "t" and "f".
isFixExprT :: TransformH CoreExpr (Type, CoreExpr)

module HERMIT.Dictionary.Local.Case

-- | Externals relating to Case expressions.
externals :: [External]

-- | (case s of alt1 -&gt; e1; alt2 -&gt; e2) v ==&gt; case s of alt1 -&gt;
--   e1 v; alt2 -&gt; e2 v
caseFloatAppR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, ReadBindings c, MonadCatch m, MonadUnique m) => Rewrite c m CoreExpr

-- | <tt>f (case s of alt1 -&gt; e1; alt2 -&gt; e2)</tt> ==&gt; <tt>case s
--   of alt1 -&gt; f e1; alt2 -&gt; f e2</tt> Only safe if <tt>f</tt> is
--   strict.
caseFloatArgR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, BoundVars c, HasDynFlags m, HasHermitMEnv m, LiftCoreM m, MonadCatch m, MonadIO m, MonadThings m, MonadUnique m) => Maybe CoreExpr -> Maybe (Rewrite c m CoreExpr) -> Rewrite c m CoreExpr

-- | <tt>f (case s of alt1 -&gt; e1; alt2 -&gt; e2)</tt> ==&gt; <tt>case s
--   of alt1 -&gt; f e1; alt2 -&gt; f e2</tt> Only safe if <tt>f</tt> is
--   strict, so introduces a lemma to prove.
caseFloatArgLemmaR :: (AddBindings c, ExtendPath c Crumb, HasCoreRules c, LemmaContext c, ReadBindings c, ReadPath c Crumb, HasHermitMEnv m, LiftCoreM m, HasDynFlags m, HasLemmas m, MonadCatch m, MonadIO m, MonadThings m, MonadUnique m) => Used -> LemmaName -> Rewrite c m CoreExpr

-- | case (case s1 of alt11 -&gt; e11; alt12 -&gt; e12) of alt21 -&gt; e21;
--   alt22 -&gt; e22 ==&gt; case s1 of alt11 -&gt; case e11 of alt21 -&gt;
--   e21; alt22 -&gt; e22 alt12 -&gt; case e12 of alt21 -&gt; e21; alt22
--   -&gt; e22
caseFloatCaseR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, ReadBindings c, MonadCatch m, MonadUnique m) => Rewrite c m CoreExpr

-- | cast (case s of p -&gt; e) co ==&gt; case s of p -&gt; cast e co
caseFloatCastR :: MonadCatch m => Rewrite c m CoreExpr

-- | let v = case s of alt1 -&gt; e1 in e ==&gt; case s of alt1 -&gt; let v
--   = e1 in e
caseFloatLetR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, ReadBindings c, MonadCatch m, MonadUnique m) => Rewrite c m CoreExpr

-- | caseFloatR = caseFloatAppR &lt;+ caseFloatCaseR &lt;+ caseFloatLetR
--   &lt;+ caseFloatCastR Note: does NOT include caseFloatArg
caseFloatR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, ReadBindings c, MonadCatch m, MonadUnique m) => Rewrite c m CoreExpr

-- | Float in a Case whatever the context.
caseFloatInR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => Rewrite c m CoreExpr

-- | Unimplemented!
caseFloatInAppR :: Monad m => Rewrite c m CoreExpr
caseFloatInArgsR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, MonadCatch m) => Rewrite c m CoreExpr

-- | Case of Known Constructor. Eliminate a case if the scrutinee is a data
--   constructor or a literal. If first argument is True, perform
--   substitution in RHS, if False, build let expressions.
caseReduceR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, ReadBindings c, MonadCatch m, MonadUnique m) => Bool -> Rewrite c m CoreExpr

-- | Case of Known Constructor. Eliminate a case if the scrutinee is a data
--   constructor. If first argument is True, perform substitution in RHS,
--   if False, build let expressions.
caseReduceDataconR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, ReadBindings c, MonadCatch m, MonadUnique m) => Bool -> Rewrite c m CoreExpr

-- | Case of Known Constructor. Eliminate a case if the scrutinee is a
--   literal. If first argument is True, perform substitution in RHS, if
--   False, build let expressions. NB: LitAlt cases don't do evaluation
caseReduceLiteralR :: MonadCatch m => Bool -> Rewrite c m CoreExpr

-- | Unfold the case scrutinee and then perform case reduction. If first
--   argument is True, perform substitution in RHS, if False, build let
--   expressions.
caseReduceUnfoldR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, ReadBindings c, HasEmptyContext c, MonadCatch m, MonadUnique m) => Bool -> Rewrite c m CoreExpr
casesForM :: MonadUnique m => CoreExpr -> m [(DataCon, [Id])]
caseExprsForM :: MonadUnique m => CoreExpr -> m [CoreExpr]

-- | Case split on an arbitrary scrutinee s. All free variables in s should
--   be in scope.
--   
--   E.g. If s has type [a], then case-split s:
--   
--   e ==&gt; case s of w [] -&gt; e[w/s] (a:as) -&gt; e[w/s]
--   
--   Note that occurrences of s in e are replaced with the case binder.
caseSplitR :: (AddBindings c, BoundVars c, ExtendPath c Crumb, HasEmptyContext c, ReadPath c Crumb, MonadCatch m, MonadUnique m) => CoreExpr -> Rewrite c m CoreExpr

-- | Like caseSplit, but additionally inlines the constructor applications
--   for each occurance of the named variable.
--   
--   <pre>
--   caseSplitInline idPred = caseSplit idPred &gt;&gt;&gt; caseInlineAlternativeR
--   </pre>
caseSplitInlineR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, ReadBindings c, HasEmptyContext c, MonadCatch m, MonadUnique m) => CoreExpr -> Rewrite c m CoreExpr

-- | Inline the case binder as the case scrutinee everywhere in the case
--   alternatives.
caseInlineScrutineeR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, ReadBindings c, HasEmptyContext c, MonadCatch m, MonadUnique m) => Rewrite c m CoreExpr

-- | Inline the case binder as the case-alternative pattern everywhere in
--   the case alternatives.
caseInlineAlternativeR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, ReadBindings c, HasEmptyContext c, MonadCatch m, MonadUnique m) => Rewrite c m CoreExpr

-- | Merge all case alternatives into a single default case. The RHS of
--   each alternative must be the same. <tt>case s of {pat1 -&gt; e ; pat2
--   -&gt; e ; ... ; patn -&gt; e}</tt> ==&gt; <tt>case s of {_ -&gt;
--   e}</tt>
caseMergeAltsR :: MonadCatch m => Rewrite c m CoreExpr

-- | A cleverer version of <tt>mergeCaseAlts</tt> that first attempts to
--   abstract out any occurrences of the alternative pattern using the case
--   binder.
caseMergeAltsWithBinderR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, ReadBindings c, HasEmptyContext c, MonadCatch m, MonadUnique m) => Rewrite c m CoreExpr

-- | case s of w; C vs -&gt; e ==&gt; e if w and vs are not free in e
caseElimR :: MonadCatch m => Rewrite c m CoreExpr

-- | Eliminate a case, inlining any occurrences of the case binder as the
--   scrutinee.
caseElimInlineScrutineeR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, ReadBindings c, HasEmptyContext c, MonadCatch m, MonadUnique m) => Rewrite c m CoreExpr

-- | Eliminate a case, merging the case alternatives into a single default
--   alternative and inlining the case binder as the scrutinee (if
--   possible).
caseElimMergeAltsR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, ReadBindings c, HasEmptyContext c, MonadCatch m, MonadUnique m) => Rewrite c m CoreExpr

-- | Force evaluation of an identifier by introducing a case. This is
--   equivalent to adding <tt>(seq v)</tt> in the source code.
--   
--   e -&gt; case v of v _ -&gt; e
caseIntroSeqR :: (MonadCatch m, MonadUnique m) => (Id -> Bool) -> Rewrite c m CoreExpr

-- | Eliminate a case that corresponds to a pointless <a>seq</a>.
caseElimSeqR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, ReadBindings c, HasEmptyContext c, MonadCatch m, MonadUnique m) => Rewrite c m CoreExpr

module HERMIT.Dictionary.Induction
externals :: [External]
caseSplitOnR :: Bool -> (Id -> Bool) -> RewriteH Clause

module HERMIT.Dictionary.Local

-- | Externals for local structural manipulations. (Many taken from Chapter
--   3 of Andre Santos' dissertation.)
externals :: [External]

-- | Abstract over a variable using a lambda. e ==&gt; ( x. e) x
abstractR :: (ReadBindings c, MonadCatch m, MonadUnique m) => (Var -> Bool) -> Rewrite c m CoreExpr

-- | Push a function through a Case or Let expression. Unsafe if the
--   function is not strict.
pushR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, ReadBindings c) => Maybe (Rewrite c HermitM CoreExpr) -> (Id -> Bool) -> Rewrite c HermitM CoreExpr

-- | <tt>((\ v -&gt; e1) e2)</tt> ==&gt; <tt>(let v = e2 in e1)</tt> This
--   form of beta-reduction is safe if e2 is an arbitrary expression (won't
--   duplicate work).
betaReduceR :: MonadCatch m => Rewrite c m CoreExpr

-- | (let v = e1 in e2) ==&gt; (\ v -&gt; e2) e1
betaExpandR :: MonadCatch m => Rewrite c m CoreExpr

-- | (\ v -&gt; f v) ==&gt; f
etaReduceR :: MonadCatch m => Rewrite c m CoreExpr

-- | e1 ==&gt; (\ v -&gt; e1 v)
etaExpandR :: String -> Rewrite c HermitM CoreExpr

-- | Perform multiple eta-expansions.
multiEtaExpandR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c) => [String] -> Rewrite c HermitM CoreExpr

-- | Flatten all the top-level binding groups in the module to a single
--   recursive binding group.
flattenModuleR :: (ExtendPath c Crumb, HasEmptyContext c, Monad m) => Rewrite c m ModGuts

-- | Flatten all the top-level binding groups in a program to a program
--   containing a single recursive binding group.
flattenProgramR :: Monad m => Rewrite c m CoreProg

-- | Flatten all the top-level binding groups in a program to a single
--   recursive binding group.
flattenProgramT :: Monad m => Transform c m CoreProg CoreBind

module HERMIT.Dictionary.Composite
externals :: [External]

-- | Unfold the current expression if it is one of the basic combinators:
--   (<a>$</a>), (<a>.</a>), <a>id</a>, <a>flip</a>, <a>const</a>,
--   <a>fst</a>, <a>snd</a>, <a>curry</a>, and <a>uncurry</a>. This is
--   intended to be used as a component of simplification traversals such
--   as <a>simplifyR</a> or <a>bashR</a>.
unfoldBasicCombinatorR :: (AddBindings c, ExtendPath c Crumb, HasEmptyContext c, ReadBindings c, ReadPath c Crumb, MonadCatch m) => Rewrite c m CoreExpr
simplifyR :: (AddBindings c, ExtendPath c Crumb, HasEmptyContext c, LemmaContext c, ReadBindings c, ReadPath c Crumb, MonadCatch m, MonadUnique m) => Rewrite c m LCore

-- | Perform the <tt>bash</tt> algorithm with a given list of rewrites.
bashUsingR :: (AddBindings c, ExtendPath c Crumb, HasEmptyContext c, LemmaContext c, ReadPath c Crumb, MonadCatch m) => [Rewrite c m LCore] -> Rewrite c m LCore

-- | Bash is intended as a general-purpose cleanup/simplification command.
--   It performs rewrites such as let floating, case floating, and case
--   elimination, when safe. It also performs dead binding elimination and
--   case reduction, and unfolds a number of basic combinators. See
--   <a>bashComponents</a> for a list of rewrites performed. Bash also
--   performs occurrence analysis and de-zombification on the result, to
--   update IdInfo attributes relied-upon by GHC.
bashR :: (AddBindings c, ExtendPath c Crumb, HasEmptyContext c, LemmaContext c, ReadBindings c, ReadPath c Crumb, MonadCatch m, MonadUnique m) => Rewrite c m LCore

-- | An extensible bash. Given rewrites are performed before normal bash
--   rewrites.
bashExtendedWithR :: (AddBindings c, ExtendPath c Crumb, HasEmptyContext c, LemmaContext c, ReadBindings c, ReadPath c Crumb, MonadCatch m, MonadUnique m) => [Rewrite c m LCore] -> Rewrite c m LCore

-- | Like <a>bashR</a>, but outputs name of each successful sub-rewrite,
--   providing a log. Also performs core lint on the result of a successful
--   sub-rewrite. If core lint fails, shows core fragment before and after
--   the sub-rewrite which introduced the problem. Note: core fragment
--   which fails linting is still returned! Otherwise would behave
--   differently than bashR. Useful for debugging the bash command itself.
bashDebugR :: (AddBindings c, ExtendPath c Crumb, HasEmptyContext c, LemmaContext c, ReadBindings c, ReadPath c Crumb, HasDynFlags m, HasHermitMEnv m, HasLemmas m, LiftCoreM m, MonadCatch m, MonadUnique m) => Rewrite c m LCore

-- | Smash is a more powerful but less efficient version of bash. Unlike
--   bash, smash is not concerned with whether it duplicates work, and is
--   intended for use during proving tasks.
smashR :: (AddBindings c, ExtendPath c Crumb, HasEmptyContext c, LemmaContext c, ReadBindings c, ReadPath c Crumb, HasDynFlags m, HasHermitMEnv m, LiftCoreM m, MonadCatch m, MonadIO m, MonadThings m, MonadUnique m) => Rewrite c m LCore
smashUsingR :: (ExtendPath c Crumb, ReadPath c Crumb, AddBindings c, HasEmptyContext c, LemmaContext c, MonadCatch m) => [Rewrite c m LCore] -> [Rewrite c m LCore] -> Rewrite c m LCore
smashExtendedWithR :: (AddBindings c, ExtendPath c Crumb, HasEmptyContext c, LemmaContext c, ReadBindings c, ReadPath c Crumb, HasDynFlags m, HasHermitMEnv m, LiftCoreM m, MonadCatch m, MonadIO m, MonadThings m, MonadUnique m) => [Rewrite c m LCore] -> Rewrite c m LCore

module HERMIT.Dictionary.WorkerWrapper.Common

-- | New Worker/Wrapper-related externals.
externals :: [External]
data WWAssumptionTag
A :: WWAssumptionTag
B :: WWAssumptionTag
C :: WWAssumptionTag
data WWAssumption
WWAssumption :: WWAssumptionTag -> (RewriteH CoreExpr) -> WWAssumption
assumptionAClauseT :: (BoundVars c, HasHermitMEnv m, LiftCoreM m, MonadCatch m, MonadIO m, MonadThings m) => CoreExpr -> CoreExpr -> Transform c m x Clause
assumptionBClauseT :: (BoundVars c, HasHermitMEnv m, LiftCoreM m, MonadCatch m, MonadIO m, MonadThings m) => CoreExpr -> CoreExpr -> CoreExpr -> Transform c m x Clause
assumptionCClauseT :: (BoundVars c, HasHermitMEnv m, LiftCoreM m, MonadCatch m, MonadIO m, MonadThings m) => CoreExpr -> CoreExpr -> CoreExpr -> Transform c m x Clause
split1BetaR :: (AddBindings c, ExtendPath c Crumb, HasCoreRules c, LemmaContext c, ReadBindings c, ReadPath c Crumb, HasHermitMEnv m, LiftCoreM m, HasLemmas m, MonadCatch m, MonadIO m, MonadThings m, MonadUnique m) => Used -> LemmaName -> CoreExpr -> CoreExpr -> Rewrite c m CoreExpr
split2BetaR :: (AddBindings c, ExtendPath c Crumb, HasCoreRules c, LemmaContext c, ReadBindings c, ReadPath c Crumb, HasHermitMEnv m, LiftCoreM m, HasLemmas m, MonadCatch m, MonadIO m, MonadThings m, MonadUnique m) => Used -> LemmaName -> CoreExpr -> CoreExpr -> Rewrite c m CoreExpr
workLabel :: LemmaName
instance Typeable WWAssumptionTag
instance Eq WWAssumptionTag
instance Ord WWAssumptionTag
instance Show WWAssumptionTag
instance Read WWAssumptionTag
instance Extern WWAssumptionTag

module HERMIT.Dictionary.WorkerWrapper.Fix

-- | Externals for manipulating fixed points, and for the worker/wrapper
--   transformation.
externals :: [External]

-- | For any <tt>f :: A -&gt; A</tt>, and given <tt>wrap :: B -&gt; A</tt>
--   and <tt>unwrap :: A -&gt; B</tt> as arguments, then <tt>fix A f</tt>
--   &lt;==&gt; <tt>wrap (fix B (\ b -&gt; unwrap (f (wrap b))))</tt>
wwFacBR :: Maybe WWAssumption -> CoreExpr -> CoreExpr -> BiRewriteH CoreExpr

-- | \ wrap unwrap -&gt; (<tt>prog = expr</tt> ==&gt; <tt>prog = let f = \
--   prog -&gt; expr in let work = unwrap (f (wrap work)) in wrap
--   work)</tt>
wwSplitR :: Maybe WWAssumption -> CoreExpr -> CoreExpr -> RewriteH CoreDef

-- | As <a>wwSplit</a> but performs the static-argument transformation for
--   <tt>n</tt> static arguments first, and optionally provides some of
--   those arguments (specified by index) to all calls of wrap and unwrap.
--   This is useful if, for example, the expression, and wrap and unwrap,
--   all have a <tt>forall</tt> type.
wwSplitStaticArg :: Int -> [Int] -> Maybe WWAssumption -> CoreString -> CoreString -> RewriteH CoreDef

-- | Save the recursive definition of work in the stash, so that we can
--   later verify uses of <a>wwFusionBR</a>. Must be applied to a
--   definition of the form: <tt>work = unwrap (f (wrap work))</tt> Note
--   that this is performed automatically as part of <a>wwSplitR</a>.
wwGenerateFusionT :: Maybe WWAssumption -> TransformH LCore ()

-- | Given <tt>wrap :: B -&gt; A</tt>, <tt>unwrap :: A -&gt; B</tt> and
--   <tt>work :: B</tt> as arguments, then <tt>unwrap (wrap work)</tt>
--   &lt;==&gt; <tt>work</tt>
wwFusionBR :: BiRewriteH CoreExpr

-- | <tt>wrap (unwrap a)</tt> &lt;==&gt; <tt>a</tt>
wwAssA :: Maybe (RewriteH CoreExpr) -> CoreExpr -> CoreExpr -> BiRewriteH CoreExpr

-- | <tt>wrap (unwrap (f a))</tt> &lt;==&gt; <tt>f a</tt>
wwAssB :: Maybe (RewriteH CoreExpr) -> CoreExpr -> CoreExpr -> CoreExpr -> BiRewriteH CoreExpr

-- | <tt>fix A ( a -&gt; wrap (unwrap (f a)))</tt> &lt;==&gt; <tt>fix A
--   f</tt>
wwAssC :: Maybe (RewriteH CoreExpr) -> CoreExpr -> CoreExpr -> CoreExpr -> BiRewriteH CoreExpr

module HERMIT.Dictionary.WorkerWrapper.FixResult

-- | Externals for manipulating fixed points, and for the worker/wrapper
--   transformation.
externals :: [External]

-- | For any <tt>f :: (X -&gt; A) -&gt; (X -&gt; A)</tt>, and given <tt>abs
--   :: B -&gt; A</tt> and <tt>rep :: A -&gt; B</tt> as arguments, then
--   <tt>fix A f</tt> &lt;==&gt; <tt>\ x1 -&gt; abs (fix (X-&gt;B) (\ h x2
--   -&gt; rep (f (\ x3 -&gt; abs (h x3)) x2)) x1)</tt>
wwResultFacBR :: Maybe WWAssumption -> CoreExpr -> CoreExpr -> BiRewriteH CoreExpr

-- | \ abs rep -&gt; (<tt>prog = expr</tt> ==&gt; <tt>prog = let f = \ prog
--   -&gt; expr in let work = \ x1 -&gt; rep (f (\ x2 -&gt; abs (work x2))
--   x1) in \ x0 -&gt; abs (work x0)</tt>)
wwResultSplitR :: Maybe WWAssumption -> CoreExpr -> CoreExpr -> RewriteH CoreDef

-- | As <a>wwSplit</a> but performs the static-argument transformation for
--   <tt>n</tt> static arguments first, and optionally provides some of
--   those arguments (specified by index) to all calls of abs and rep. This
--   is useful if, for example, the expression, and abs and rep, all have a
--   <tt>forall</tt> type.
wwResultSplitStaticArg :: Int -> [Int] -> Maybe WWAssumption -> CoreString -> CoreString -> RewriteH CoreDef

-- | Save the recursive definition of work in the stash, so that we can
--   later verify uses of <a>wwResultFusionBR</a>. Must be applied to a
--   definition of the form: <tt>work = \ x1 -&gt; rep (f (\ x2 -&gt; abs
--   (work x2)) x1)</tt> Note that this is performed automatically as part
--   of <a>wwResultSplitR</a>.
wwResultGenerateFusionT :: Maybe WWAssumption -> TransformH LCore ()

-- | Given <tt>abs :: B -&gt; A</tt>, <tt>rep :: A -&gt; B</tt> and
--   <tt>work :: X -&gt; B</tt> as arguments, then <tt>rep (abs (work
--   x))</tt> &lt;==&gt; <tt>work x</tt>
wwResultFusionBR :: BiRewriteH CoreExpr

-- | <tt>abs (rep a)</tt> &lt;==&gt; <tt>a</tt>
wwResultAssA :: Maybe (RewriteH CoreExpr) -> CoreExpr -> CoreExpr -> BiRewriteH CoreExpr

-- | <tt>abs (rep (f h x))</tt> &lt;==&gt; <tt>f h x</tt>
wwResultAssB :: Maybe (RewriteH CoreExpr) -> CoreExpr -> CoreExpr -> CoreExpr -> BiRewriteH CoreExpr

-- | <tt>fix (X-&gt;A) ( h x -&gt; abs (rep (f h x)))</tt> &lt;==&gt;
--   <tt>fix (X-&gt;A) f</tt>
wwResultAssC :: Maybe (RewriteH CoreExpr) -> CoreExpr -> CoreExpr -> CoreExpr -> BiRewriteH CoreExpr

module HERMIT.Dictionary

-- | List of all <a>External</a>s provided by HERMIT.
externals :: [External]

module HERMIT.Kernel

-- | A <i>handle</i> for a specific version of the <a>ModGuts</a>.
data AST
firstAST :: AST
data ASTMap

-- | A <a>Kernel</a> is a repository for complete Core syntax trees
--   (<a>ModGuts</a>) and Lemmas.
data Kernel
data KernelEnv
KernelEnv :: (KEnvMessage -> HermitM ()) -> KernelEnv
kEnvChan :: KernelEnv -> KEnvMessage -> HermitM ()

-- | Start a HERMIT client by providing an IO callback that takes the
--   initial <a>Kernel</a> and inital <a>AST</a> handle. The callback is
--   only ever called once. The 'Modguts -&gt; CoreM Modguts' function
--   required by GHC Plugins is returned.
hermitKernel :: IORef (Maybe (AST, ASTMap)) -> String -> (Kernel -> AST -> IO ()) -> ModGuts -> CoreM ModGuts
data CommitMsg
Always :: String -> CommitMsg
Changed :: String -> CommitMsg
Never :: CommitMsg

-- | Halt the <a>Kernel</a> and return control to GHC, which compiles the
--   specified <a>AST</a>.
resumeK :: Kernel -> forall m. MonadIO m => AST -> m ()

-- | Halt the <a>Kernel</a> and abort GHC without compiling.
abortK :: Kernel -> forall m. MonadIO m => m ()

-- | Apply a <a>Rewrite</a> to the specified <a>AST</a> and return a handle
--   to the resulting <a>AST</a>.
applyK :: Kernel -> forall m. (MonadIO m, MonadCatch m) => RewriteH ModGuts -> CommitMsg -> KernelEnv -> AST -> m AST

-- | Apply a <a>TransformH</a> to the <a>AST</a>, return the resulting
--   value, and potentially a new <a>AST</a>.
queryK :: Kernel -> forall m a. (MonadIO m, MonadCatch m) => TransformH ModGuts a -> CommitMsg -> KernelEnv -> AST -> m (AST, a)

-- | Delete the internal record of the specified <a>AST</a>.
deleteK :: Kernel -> forall m. MonadIO m => AST -> m ()

-- | List all the <a>AST</a>s tracked by the <a>Kernel</a>, including
--   version data.
listK :: Kernel -> forall m. MonadIO m => m [(AST, Maybe String, Maybe AST)]

-- | Log a new AST with same Lemmas/ModGuts as given AST.
tellK :: Kernel -> forall m. (MonadIO m, MonadCatch m) => String -> AST -> m AST
instance Typeable AST
instance Eq AST
instance Ord AST
instance Extern AST
instance Read AST
instance Show AST
instance Enum AST

module HERMIT.Plugin.Builder

-- | Given a list of <a>CommandLineOption</a>s, produce the <a>ModGuts</a>
--   to <a>ModGuts</a> function required to build a plugin.
type HERMITPass = IORef (Maybe (AST, ASTMap)) -> PassInfo -> [CommandLineOption] -> ModGuts -> CoreM ModGuts

-- | Build a plugin. This mainly handles the per-module options.
buildPlugin :: HERMITPass -> Plugin

-- | An enumeration type for GHC's passes.
data CorePass
CSE :: CorePass
Desugar :: CorePass
DesugarOpt :: CorePass
FloatInwards :: CorePass
FloatOutwards :: CorePass
LiberateCase :: CorePass
Prep :: CorePass
PrintCore :: CorePass
RuleCheck :: CorePass
Simplify :: CorePass
SpecConstr :: CorePass
Specialising :: CorePass
StaticArgs :: CorePass
Strictness :: CorePass
Tidy :: CorePass
Vectorisation :: CorePass
WorkerWrapper :: CorePass
Passes :: CorePass
PluginPass :: String -> CorePass
NoOp :: CorePass
Unknown :: CorePass
getCorePass :: CoreToDo -> CorePass
ghcPasses :: [(CorePass, CoreToDo)]
data PassInfo
PassInfo :: Int -> [CorePass] -> [CorePass] -> PassInfo
passNum :: PassInfo -> Int
passesDone :: PassInfo -> [CorePass]
passesLeft :: PassInfo -> [CorePass]

-- | If HERMIT user specifies the -pN flag, get the N TODO: as written will
--   discard other flags that start with -p
getPassFlag :: [CommandLineOption] -> Maybe (Int, [CommandLineOption])
instance Read CorePass
instance Show CorePass
instance Eq CorePass
instance Read PassInfo
instance Show PassInfo
instance Eq PassInfo

module HERMIT.Plugin.Types
type PluginM = PluginT IO
newtype PluginT m a
PluginT :: ExceptT PException (ReaderT PluginReader (StateT PluginState m)) a -> PluginT m a
unPluginT :: PluginT m a -> ExceptT PException (ReaderT PluginReader (StateT PluginState m)) a
runPluginT :: PluginReader -> PluginState -> PluginT m a -> m (Either PException a, PluginState)
data PluginState
PluginState :: AST -> PrettyPrinter -> (Handle -> PrettyOptions -> Either String DocH -> IO ()) -> TVar (Map String Int) -> Bool -> PluginState

-- | the current AST
ps_cursor :: PluginState -> AST

-- | which pretty printer to use
ps_pretty :: PluginState -> PrettyPrinter

-- | the way of outputing to the screen
ps_render :: PluginState -> Handle -> PrettyOptions -> Either String DocH -> IO ()

-- | the list of ticked messages
ps_tick :: PluginState -> TVar (Map String Int)

-- | if true, run Core Lint on module after each rewrite
ps_corelint :: PluginState -> Bool
data PluginReader
PluginReader :: Kernel -> PassInfo -> PluginReader
pr_kernel :: PluginReader -> Kernel
pr_pass :: PluginReader -> PassInfo
data PException
PAbort :: PException
PResume :: AST -> PException
PError :: String -> PException
newtype PSBox
PSBox :: PluginState -> PSBox
tick :: TVar (Map String Int) -> String -> IO Int
mkKernelEnv :: PluginState -> KernelEnv
instance Typeable PluginState
instance Typeable PluginReader
instance Typeable PSBox
instance Functor m => Functor (PluginT m)
instance (Monad m, Functor m) => Applicative (PluginT m)
instance MonadIO m => MonadIO (PluginT m)
instance Monad m => MonadError PException (PluginT m)
instance Monad m => MonadState PluginState (PluginT m)
instance Monad m => MonadReader PluginReader (PluginT m)
instance Extern PluginState
instance Monad m => MonadCatch (PluginT m)
instance MonadTrans PluginT
instance Monad m => Monad (PluginT m)

module HERMIT.Plugin.Display
display :: Maybe Handle -> Maybe PathH -> PluginM ()
ps_putStr :: (MonadIO m, MonadState PluginState m) => String -> m ()
ps_putStrLn :: (MonadIO m, MonadState PluginState m) => String -> m ()

module HERMIT.Plugin.Renderer
changeRenderer :: String -> PluginM ()
shellRenderers :: [(String, Handle -> PrettyOptions -> Either String DocH -> IO ())]
newtype UnicodeTerminal
UnicodeTerminal :: (Handle -> Maybe PathH -> IO ()) -> UnicodeTerminal
unicodeConsole :: Handle -> PrettyOptions -> Either String DocH -> IO ()
doSGR :: [SGR] -> UnicodeTerminal
undoSGRWith :: [SGR] -> [Attr] -> UnicodeTerminal
setHighlight :: PathH -> Handle -> Maybe PathH -> IO ()
diffDocH :: (MonadCatch m, MonadIO m) => PrettyPrinter -> DocH -> DocH -> m String
diffR :: Injection a CoreTC => PrettyPrinter -> String -> RewriteH a -> RewriteH a
instance RenderCode UnicodeTerminal
instance Monoid UnicodeTerminal
instance RenderSpecial UnicodeTerminal

module HERMIT.Shell.Types
data QueryFun :: *
QueryString :: TransformH a String -> QueryFun
QueryDocH :: TransformH a DocH -> QueryFun
QueryPrettyH :: PrettyH a -> QueryFun
Diff :: AST -> AST -> QueryFun
Inquiry :: (PluginReader -> CommandLineState -> IO String) -> QueryFun
QueryUnit :: TransformH a () -> QueryFun
message :: String -> QueryFun
performQuery :: (MonadCatch m, CLMonad m) => QueryFun -> ExprH -> m ()
ppWholeProgram :: (CLMonad m, MonadCatch m) => AST -> m DocH
type TagName = String
data VersionCmd
Back :: VersionCmd
Step :: VersionCmd
Goto :: AST -> VersionCmd
GotoTag :: TagName -> VersionCmd
Tag :: TagName -> VersionCmd
data CLException
CLAbort :: CLException
CLResume :: AST -> CLException
CLContinue :: CommandLineState -> CLException
CLError :: String -> CLException
abort :: MonadError CLException m => m a
resume :: MonadError CLException m => AST -> m a
continue :: MonadError CLException m => CommandLineState -> m a
rethrowCLE :: CLException -> PluginM a
rethrowPE :: MonadError CLException m => PException -> m a

-- | This type is similiar to PluginM, except that its exception and state
--   types are supersets of those for PluginM, and it is a transformer.
--   There are two functions: <a>clm</a> and <a>pluginM</a> for converting
--   between the two. The reason we do this is to obtain a clean separation
--   of plugin state from commandline state without nesting state
--   transformers. Nesting StateT leads to a lot of awkward lifting and
--   manual state management in the command line code.
--   
--   NB: an alternative to monad transformers, like Oleg's Extensible
--   Effects, might be useful here.
newtype CLT m a
CLT :: ExceptT CLException (ReaderT PluginReader (StateT CommandLineState m)) a -> CLT m a
unCLT :: CLT m a -> ExceptT CLException (ReaderT PluginReader (StateT CommandLineState m)) a
type CLMonad m = (MonadIO m, MonadState CommandLineState m, MonadReader PluginReader m, MonadError CLException m)

-- | Our own custom instance of Monad for CLT so we don't have to depend on
--   newtype deriving to do the right thing for fail.

-- | Run a CLT computation.
runCLT :: PluginReader -> CommandLineState -> CLT m a -> m (Either CLException a, CommandLineState)

-- | Lift a CLT IO computation into a computation in an arbitrary CLMonad.
clm2clt :: CLMonad m => CLT IO a -> m a

-- | Lift a CLM computation into the PluginM monad.
clm :: CLT IO a -> PluginM a

-- | Lift a PluginM computation into the CLM monad.
pluginM :: CLMonad m => PluginM a -> m a
data CommandLineState
CommandLineState :: PluginState -> Int -> [(ScriptName, Script)] -> Bool -> Map AST PathStack -> Map AST [String] -> Map AST [ProofTodo] -> PathH -> [External] -> Maybe Script -> Safety -> TVar [(HermitC, LemmaName, Lemma)] -> Bool -> Bool -> CommandLineState

-- | Access to the enclosing plugin state. This is propagated back to the
--   plugin after the CLT computation ends. We do it this way because
--   nested StateT is a pain.
cl_pstate :: CommandLineState -> PluginState

-- | console height, in lines
cl_height :: CommandLineState -> Int
cl_scripts :: CommandLineState -> [(ScriptName, Script)]

-- | keyboard input the nav panel
cl_nav :: CommandLineState -> Bool

-- | focus assigned to each AST
cl_foci :: CommandLineState -> Map AST PathStack

-- | list of tags on an AST
cl_tags :: CommandLineState -> Map AST [String]

-- | stack of todos for the proof shell
cl_proofstack :: CommandLineState -> Map AST [ProofTodo]

-- | path to beginning of window, always a prefix of focus path in kernel
cl_window :: CommandLineState -> PathH

-- | Currently visible externals
cl_externals :: CommandLineState -> [External]

-- | Nothing = no script running, otherwise the remaining script commands
cl_running_script :: CommandLineState -> Maybe Script

-- | which level of safety we are running in
cl_safety :: CommandLineState -> Safety

-- | updated by kernel env with temporary obligations
cl_templemmas :: CommandLineState -> TVar [(HermitC, LemmaName, Lemma)]

-- | Any exception will cause an abort.
cl_failhard :: CommandLineState -> Bool

-- | Print diffs instead of full focus.
cl_diffonly :: CommandLineState -> Bool
type PathStack = ([LocalPathH], LocalPathH)
data ProofTodo
Unproven :: LemmaName -> Lemma -> HermitC -> PathStack -> ProofTodo

-- | lemma we are proving
ptName :: ProofTodo -> LemmaName
ptLemma :: ProofTodo -> Lemma

-- | context in which lemma is being proved
ptContext :: ProofTodo -> HermitC

-- | path into lemma to focus on
ptPath :: ProofTodo -> PathStack
data Safety
StrictSafety :: Safety
NormalSafety :: Safety
NoSafety :: Safety
filterSafety :: Safety -> [External] -> [External]
cl_corelint :: CommandLineState -> Bool
setCoreLint :: CommandLineState -> Bool -> CommandLineState
cl_cursor :: CommandLineState -> AST
setCursor :: AST -> CommandLineState -> CommandLineState
cl_kernel_env :: CommandLineState -> KernelEnv
cl_pretty :: CommandLineState -> PrettyPrinter
setPretty :: CommandLineState -> PrettyPrinter -> CommandLineState
cl_pretty_opts :: CommandLineState -> PrettyOptions
setPrettyOpts :: CommandLineState -> PrettyOptions -> CommandLineState
cl_render :: CommandLineState -> (Handle -> PrettyOptions -> Either String DocH -> IO ())

-- | Create default CommandLineState from PluginState. Note: the dictionary
--   (cl_dict) will be empty, and should be populated if needed.
mkCLS :: PluginM CommandLineState
getTermDimensions :: IO (Int, Int)
newtype CLSBox
CLSBox :: CommandLineState -> CLSBox
type ScriptName = String
tick :: TVar (Map String Int) -> String -> IO Int
cl_putStr :: CLMonad m => String -> m ()
cl_putStrLn :: CLMonad m => String -> m ()
isRunningScript :: MonadState CommandLineState m => m Bool
setRunningScript :: MonadState CommandLineState m => Maybe Script -> m ()
putStrToConsole :: CLMonad m => String -> m ()
pathStack2Path :: ([LocalPath crumb], LocalPath crumb) -> Path crumb

-- | A primitive means of denoting navigation of a tree (within a local
--   scope).
data Direction

-- | Up
U :: Direction

-- | Top
T :: Direction
pathStackToLens :: (Injection a g, Walker HermitC g) => [LocalPathH] -> LocalPathH -> LensH a g
getPathStack :: CLMonad m => m ([LocalPathH], LocalPathH)
getFocusPath :: CLMonad m => m PathH
addFocusT :: (Injection a g, Walker HermitC g, CLMonad m) => TransformH g b -> m (TransformH a b)
addFocusR :: (Injection a g, Walker HermitC g, CLMonad m) => RewriteH g -> m (RewriteH a)
addAST :: CLMonad m => AST -> m ()
modifyLocalPath :: (MonadCatch m, CLMonad m) => (LocalPathH -> LocalPathH) -> ExprH -> m ()
requireDifferent :: Monad m => LocalPathH -> LocalPathH -> m ()
copyPathStack :: CLMonad m => AST -> m ()
copyProofStack :: CLMonad m => AST -> m ()
pushProofStack :: CLMonad m => ProofTodo -> m ()
popProofStack :: CLMonad m => m ProofTodo
announceUnprovens :: (MonadCatch m, CLMonad m) => m ()

-- | Always returns a non-empty list.
getProofStack :: CLMonad m => m [ProofTodo]
getProofStackEmpty :: CLMonad m => m [ProofTodo]
fixWindow :: CLMonad m => m ()
showWindow :: (MonadCatch m, CLMonad m) => Maybe Handle -> m ()
showWindowAlways :: (MonadCatch m, CLMonad m) => Maybe Handle -> m ()
printLemma :: (MonadCatch m, CLMonad m) => Handle -> HermitC -> PathStack -> (LemmaName, Lemma) -> m ()
queryInFocus :: (Walker HermitC g, Injection ModGuts g, MonadCatch m, CLMonad m) => TransformH g b -> CommitMsg -> m b
inProofFocusT :: ProofTodo -> TransformH LCoreTC b -> TransformH Core b
inProofFocusR :: ProofTodo -> RewriteH LCoreTC -> TransformH Core Clause
queryInContext :: (MonadCatch m, CLMonad m) => TransformH LCoreTC b -> CommitMsg -> m b
instance Typeable Safety
instance Typeable CommandLineState
instance Typeable CLSBox
instance Typeable QueryFun
instance Show VersionCmd
instance Read Safety
instance Show Safety
instance Eq Safety
instance Functor m => Functor (CLT m)
instance (Monad m, Functor m) => Applicative (CLT m)
instance MonadIO m => MonadIO (CLT m)
instance Monad m => MonadError CLException (CLT m)
instance Monad m => MonadState CommandLineState (CLT m)
instance Monad m => MonadReader PluginReader (CLT m)
instance Eq Direction
instance Show Direction
instance Extern CommandLineState
instance Monad m => MonadCatch (CLT m)
instance Monad m => Monad (CLT m)
instance MonadTrans CLT
instance MonadException m => MonadException (StateT s m)
instance MonadException m => MonadException (CLT m)
instance MonadException m => MonadException (ExceptT e m)
instance Extern QueryFun

module HERMIT.Shell.Interpreter

-- | An <a>Interp</a> <tt>cmd</tt> is a <i>possible</i> means of converting
--   a <a>Typeable</a> value to a value of type <tt>cmd</tt>.
data Interp :: (* -> *) -> * -> *

-- | An <a>Interp</a> with no effects.
interp :: (Monad m, Typeable b) => (b -> a) -> Interp m a

-- | An <a>Interp</a> which can affect the shell.
interpM :: (CLMonad m, Typeable b) => (b -> m a) -> Interp m a

-- | Like <tt>InterpM</tt>, but with access to the original expression.
interpEM :: (CLMonad m, Typeable b) => (b -> ExprH -> m a) -> Interp m a

-- | Execute an <a>ExprH</a> using a given interpreter. The given
--   interpretations are tried in order. The first one to match (have the
--   proper type) will be executed.
interpExprH :: CLMonad m => [Interp m b] -> ExprH -> m b
exprToDyns :: MonadState CommandLineState m => ExprH -> m [Dynamic]
instance Monad m => Functor (Interp m)

module HERMIT.Shell.KernelEffect

-- | KernelEffects are things that affect the state of the Kernel
data KernelEffect
Direction :: Direction -> KernelEffect
BeginScope :: KernelEffect
EndScope :: KernelEffect
Delete :: AST -> KernelEffect
performKernelEffect :: (MonadCatch m, CLMonad m) => ExprH -> KernelEffect -> m ()
applyRewrite :: (MonadCatch m, CLMonad m) => RewriteH LCoreTC -> ExprH -> m ()
setPath :: (Injection a LCoreTC, MonadCatch m, CLMonad m) => TransformH a LocalPathH -> ExprH -> m ()
instance Typeable KernelEffect
instance Extern KernelEffect

module HERMIT.Shell.ShellEffect
data ShellEffect :: *
Abort :: ShellEffect
CLSModify :: CLT IO () -> ShellEffect
PluginComp :: PluginM () -> ShellEffect
Continue :: ShellEffect
Resume :: ShellEffect
performShellEffect :: (MonadCatch m, CLMonad m) => ShellEffect -> m ()
dumpT :: FilePath -> PrettyPrinter -> String -> Int -> TransformH DocH ()
dump :: FilePath -> PrettyPrinter -> String -> Int -> CLT IO ()
instance Typeable ShellEffect
instance Extern ShellEffect

module HERMIT.Shell.ScriptToRewrite

-- | Insert a script into the <tt>Dictionary</tt>.
addScriptToDict :: CLMonad m => ScriptName -> Script -> m ()

-- | A composite meta-command for running a loaded script immediately. The
--   script is given the same name as the filepath.
loadAndRun :: FilePath -> ScriptEffect
lookupScript :: MonadState CommandLineState m => ScriptName -> m Script
parseScriptCLT :: Monad m => String -> m Script
performScriptEffect :: (MonadCatch m, CLMonad m) => ScriptEffect -> m ()
popScriptLine :: MonadState CommandLineState m => m (Maybe ExprH)
pushScriptLine :: MonadState CommandLineState m => ExprH -> m ()
pushScript :: MonadState CommandLineState m => Script -> m ()
fileToScript :: CLMonad m => FilePath -> m Script
scriptToRewrite :: CLMonad m => Script -> m (RewriteH LCore)
data ScriptEffect
DefineScript :: ScriptName -> String -> ScriptEffect
LoadFile :: ScriptName -> FilePath -> ScriptEffect
RunScript :: ScriptName -> ScriptEffect
SaveFile :: Bool -> FilePath -> ScriptEffect
SaveScript :: FilePath -> ScriptName -> ScriptEffect
ScriptToRewrite :: RewriteName -> ScriptName -> ScriptEffect
SeqMeta :: [ScriptEffect] -> ScriptEffect
instance Typeable ScriptEffect
instance Extern ScriptEffect

module HERMIT.Shell.Proof

-- | Externals that get us into the prover shell.
externals :: [External]
data UserProofTechnique
userProofTechnique :: TransformH LCoreTC () -> UserProofTechnique
withProofExternals :: (MonadError CLException m, MonadState CommandLineState m) => m a -> m a
performProofShellCommand :: (MonadCatch m, CLMonad m) => ProofShellCommand -> ExprH -> m ()
forceProofs :: (MonadCatch m, CLMonad m) => m ()
data ProofShellCommand
PCEnd :: ProofReason -> ProofShellCommand
data ProofReason

-- | Run the technique, mark Proven if succeeds
UserProof :: UserProofTechnique -> ProofReason
instance Typeable UserProofTechnique
instance Typeable ProofShellCommand
instance Extern UserProofTechnique
instance Extern ProofShellCommand

module HERMIT.Shell.Completion
completer :: (MonadCatch m, CLMonad m) => String -> String -> m [Completion]

module HERMIT.Shell.Externals
shell_externals :: [External]
gc :: CLT IO ()
setWindow :: CLT IO ()
showRenderers :: QueryFun
versionCmd :: VersionCmd -> CLT IO ()
showDerivationTree :: PluginReader -> CommandLineState -> IO String
showRefactorTrail :: (Eq a, Show a) => [(a, [String], a)] -> a -> a -> [String]
displayScripts :: QueryFun
showScripts :: [(ScriptName, Script)] -> String
testAllT :: CommandLineState -> TransformH LCore String
testRewrites :: Bool -> [(ExternalName, RewriteH LCore)] -> TransformH LCore String

module HERMIT.Shell.Command

-- | The first argument includes a list of files to load.
commandLine :: (MonadCatch m, MonadException m, CLMonad m) => [CommandLineOption] -> [External] -> m ()

-- | Interpret a boxed thing as one of the four possible shell command
--   types.
interpShell :: (MonadCatch m, CLMonad m) => [Interp m ()]
unicodeConsole :: Handle -> PrettyOptions -> Either String DocH -> IO ()
diffDocH :: (MonadCatch m, MonadIO m) => PrettyPrinter -> DocH -> DocH -> m String
diffR :: Injection a CoreTC => PrettyPrinter -> String -> RewriteH a -> RewriteH a
performQuery :: (MonadCatch m, CLMonad m) => QueryFun -> ExprH -> m ()
cl_kernel_env :: CommandLineState -> KernelEnv
getFocusPath :: CLMonad m => m PathH
evalScript :: (MonadCatch m, CLMonad m) => String -> m ()

module HERMIT.Plugin
hermitPlugin :: ([CommandLineOption] -> PluginM ()) -> Plugin
abort :: PluginM a
resume :: PluginM a
query :: (Injection ModGuts g, Walker HermitC g) => CommitMsg -> TransformH g a -> PluginM a
apply :: (Injection ModGuts g, Walker HermitC g) => CommitMsg -> RewriteH g -> PluginM ()
delete :: AST -> PluginM ()
list :: PluginM [(AST, Maybe String, Maybe AST)]
tell :: String -> PluginM ()
interactive :: [External] -> [CommandLineOption] -> PluginM ()
display :: PluginM ()
setPretty :: PrettyPrinter -> PluginM ()
setPrettyOptions :: PrettyOptions -> PluginM ()
pass :: Int -> PluginM () -> PluginM ()
after :: CorePass -> PluginM () -> PluginM ()
before :: CorePass -> PluginM () -> PluginM ()
until :: CorePass -> PluginM () -> PluginM ()
allPasses :: PluginM () -> PluginM ()
firstPass :: PluginM () -> PluginM ()
lastPass :: PluginM () -> PluginM ()
getPassInfo :: PluginM PassInfo
getKernel :: PluginM Kernel
defPS :: AST -> IO PluginState

module HERMIT.Libraries.Int
lemmas :: LemmaLibrary

module HERMIT
plugin :: Plugin
