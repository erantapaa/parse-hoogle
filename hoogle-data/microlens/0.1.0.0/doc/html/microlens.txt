-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A tiny part of the ‘lens’ library which you can depend upon.
--   
@package microlens
@version 0.1.0.0

module Lens.Micro

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
(&) :: a -> (a -> b) -> b

-- | <tt>ASetter s t a b</tt> is something that turns a function modifying
--   a value into a function modifying a <i>structure</i>. If you ignore
--   <a>Identity</a> (as <tt>Identity a</tt> is the same thing as
--   <tt>a</tt>), the type is:
--   
--   <pre>
--   type ASetter s t a b = (a -&gt; b) -&gt; s -&gt; t
--   </pre>
--   
--   This means that examples of setters you might've already seen are:
--   
--   <ul>
--   <li><pre><a>map</a> :: (a -&gt; b) -&gt; [a] -&gt; [b]</pre>(which
--   corresponds to <a>mapped</a>)</li>
--   <li><pre><a>fmap</a> :: <a>Functor</a> f =&gt; (a -&gt; b) -&gt; f a
--   -&gt; f b</pre>(which corresponds to <a>mapped</a> as well)</li>
--   <li><pre><a>first</a> :: (a -&gt; b) -&gt; (a, x) -&gt; (b,
--   x)</pre>(which corresponds to <a>_1</a>)</li>
--   <li><pre><a>left</a> :: (a -&gt; b) -&gt; Either a x -&gt; Either b
--   x</pre>(which corresponds to <a>_Left</a>)</li>
--   </ul>
--   
--   The reason <a>Identity</a> is used here is for <a>ASetter</a> to be
--   composable with other types, such as <a>Lens</a>.
--   
--   Technically, if you're writing a library, you shouldn't use this type
--   for setters you are exporting from your library; the right type to use
--   is <tt>Setter</tt>, but it is not provided by microlens. It's
--   completely alright, however, to export functions which take an
--   <a>ASetter</a> as an argument.
type ASetter s t a b = (a -> Identity b) -> s -> Identity t

-- | <a>sets</a> creates an <a>ASetter</a> from an ordinary function. (The
--   only thing it does is wrapping and unwrapping <a>Identity</a>.)
sets :: ((a -> b) -> s -> t) -> ASetter s t a b

-- | (<a>%~</a>) applies a function to the target; an alternative
--   explanation is that it is an inverse of <a>sets</a>, which turns a
--   setter into an ordinary function. <tt><a>mapped</a> <a>%~</a>
--   reverse</tt> is the same thing as <tt><a>fmap</a> reverse</tt>.
--   
--   See <a>over</a> if you want a non-operator synonym.
--   
--   Negating the 1st element of a pair:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; _1 %~ negate
--   (-1,2)
--   </pre>
--   
--   Turning all <tt>Left</tt>s in a list to upper case:
--   
--   <pre>
--   &gt;&gt;&gt; (mapped._Left.mapped %~ toUpper) [Left "foo", Right "bar"]
--   [Left "FOO",Right "bar"]
--   </pre>
(%~) :: ASetter s t a b -> (a -> b) -> s -> t

-- | <a>over</a> is a synonym for (<a>%~</a>).
--   
--   Getting <a>fmap</a> in a roundabout way:
--   
--   <pre>
--   <a>over</a> <a>mapped</a> :: <a>Functor</a> f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
--   <a>over</a> <a>mapped</a> = <a>fmap</a>
--   </pre>
--   
--   Applying a function to both components of a pair:
--   
--   <pre>
--   <a>over</a> <a>both</a> :: (a -&gt; b) -&gt; (a, a) -&gt; (b, b)
--   <a>over</a> <a>both</a> = \f t -&gt; (f (fst t), f (snd t))
--   </pre>
--   
--   Using <tt><a>over</a> <a>_2</a></tt> as a replacement for
--   <a>second</a>:
--   
--   <pre>
--   &gt;&gt;&gt; over _2 show (10,20)
--   (10,"20")
--   </pre>
over :: ASetter s t a b -> (a -> b) -> s -> t

-- | (<a>.~</a>) assigns a value to the target. These are equivalent:
--   
--   <pre>
--   l <a>.~</a> x
--   l <a>%~</a> <a>const</a> x
--   </pre>
--   
--   See <a>set</a> if you want a non-operator synonym.
--   
--   Here it is used to change 2 fields of a 3-tuple:
--   
--   <pre>
--   &gt;&gt;&gt; (0,0,0) &amp; _1 .~ 1 &amp; _3 .~ 3
--   (1,0,3)
--   </pre>
(.~) :: ASetter s t a b -> b -> s -> t

-- | <a>set</a> is a synonym for (<a>.~</a>).
--   
--   Setting the 1st component of a pair:
--   
--   <pre>
--   <a>set</a> <a>_1</a> :: x -&gt; (a, b) -&gt; (x, b)
--   <a>set</a> <a>_1</a> = \x t -&gt; (x, snd t)
--   </pre>
--   
--   Using it to rewrite (<a>&lt;$</a>):
--   
--   <pre>
--   <a>set</a> <a>mapped</a> :: <a>Functor</a> f =&gt; a -&gt; f b -&gt; f a
--   <a>set</a> <a>mapped</a> = (<a>&lt;$</a>)
--   </pre>
set :: ASetter s t a b -> b -> s -> t

-- | <a>mapped</a> is a setter for everything contained in a functor. You
--   can use it to map over lists, <tt>Maybe</tt>, or even <tt>IO</tt>
--   (which is something you can't do with <tt>traversed</tt> or
--   <tt>each</tt>).
--   
--   Here <a>mapped</a> is used to turn a value to all non-<a>Nothing</a>
--   values in a list:
--   
--   <pre>
--   &gt;&gt;&gt; [Just 3,Nothing,Just 5] &amp; mapped.mapped .~ 0
--   [Just 0,Nothing,Just 0]
--   </pre>
--   
--   Keep in mind that while <a>mapped</a> is a more powerful setter than
--   <tt>each</tt>, it can't be used as a getter! This won't work (and will
--   fail with a type error):
--   
--   <pre>
--   [(1,2),(3,4),(5,6)] <a>^..</a> <a>mapped</a> . <a>both</a>
--   </pre>
mapped :: Functor f => ASetter (f a) (f b) a b

-- | <tt>Getting r s a</tt> is, in a way, equivalent to <tt>s -&gt; a</tt>.
--   Since <tt><a>Const</a> r a</tt> is the same as <tt>r</tt>,
--   <a>Getting</a> is actually <tt>(a -&gt; r) -&gt; s -&gt; r</tt>, which
--   is just CPS-transformed <tt>s -&gt; a</tt>. The reason <a>Const</a>
--   and CPS are used is that we want getters to have the same shape as
--   lenses (which we achieve because <a>Const</a> is a functor).
type Getting r s a = (a -> Const r a) -> s -> Const r s

-- | (<a>^.</a>) applies a getter to a value; in other words, it gets a
--   value out of a structure using a getter (which can be a lens,
--   traversal, fold, etc.).
--   
--   Getting 1st field of a tuple:
--   
--   <pre>
--   (<a>^.</a> <a>_1</a>) :: (a, b) -&gt; a
--   (<a>^.</a> <a>_1</a>) = <a>fst</a>
--   </pre>
--   
--   When (<a>^.</a>) is used with a traversal, it combines all results
--   using the <a>Monoid</a> instance for the resulting type. For instance,
--   for lists it would be simple concatenation:
--   
--   <pre>
--   &gt;&gt;&gt; ("str","ing") ^. each
--   "string"
--   </pre>
--   
--   The reason for this is that traversals use <a>Applicative</a>, and the
--   <a>Applicative</a> instance for <a>Const</a> uses monoid concatenation
--   to combine “effects” of <a>Const</a>.
(^.) :: s -> Getting a s a -> a

-- | <tt>s ^.. t</tt> returns the list of all values that <tt>t</tt> gets
--   from <tt>s</tt>.
--   
--   A <a>Maybe</a> contains either 0 or 1 values:
--   
--   <pre>
--   &gt;&gt;&gt; Just 3 ^.. _Just
--   [3]
--   </pre>
--   
--   Gathering all values in a list of tuples:
--   
--   <pre>
--   &gt;&gt;&gt; [(1,2),(3,4)] ^.. each.each
--   [1,2,3,4]
--   </pre>
(^..) :: s -> Getting (Endo [a]) s a -> [a]

-- | <a>toListOf</a> is a synonym for (<a>^..</a>).
toListOf :: Getting (Endo [a]) s a -> s -> [a]

-- | <tt>s ^? t</tt> returns the 1st element <tt>t</tt> returns, or
--   <a>Nothing</a> if <tt>t</tt> doesn't return anything. It's trivially
--   implemented by passing the <a>First</a> monoid to the getter.
--   
--   Safe <a>head</a>:
--   
--   <pre>
--   &gt;&gt;&gt; [] ^? each
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1..3] ^? each
--   Just 1
--   </pre>
--   
--   Converting <a>Either</a> to <a>Maybe</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Left 1 ^? _Right
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 1 ^? _Right
--   Just 1
--   </pre>
(^?) :: s -> Getting (First a) s a -> Maybe a

-- | (<a>^?!</a>) is an unsafe variant of (<a>^?</a>) – instead of using
--   <a>Nothing</a> to indicate that there were no elements returned, it
--   throws an exception.
(^?!) :: s -> Getting (Endo a) s a -> a

-- | <a>folded</a> is a fold for anything <a>Foldable</a>. In a way, it's
--   an opposite of <a>mapped</a> – the most powerful getter, but can't be
--   used as a setter.
folded :: (Foldable f, Applicative (Const r)) => Getting r (f a) a

-- | <a>has</a> checks whether a getter (any getter, including lenses,
--   traversals, and folds) returns at least 1 value.
--   
--   Checking whether a list is non-empty:
--   
--   <pre>
--   &gt;&gt;&gt; has each []
--   False
--   </pre>
--   
--   You can also use it with e.g. <a>_Left</a> (and other 0-or-1
--   traversals) as a replacement for <a>isNothing</a>, <a>isJust</a> and
--   other <tt>isConstructorName</tt> functions:
--   
--   <pre>
--   &gt;&gt;&gt; has _Left (Left 1)
--   True
--   </pre>
has :: Getting Any s a -> s -> Bool

-- | Lenses in a nutshell: use (<a>^.</a>) to get, (<a>.~</a>) to set,
--   (<a>%~</a>) to modify. (<a>.</a>) composes lenses (i.e. if a
--   <tt>B</tt> is a part of <tt>A</tt>, and a <tt>C</tt> is a part of in
--   <tt>B</tt>, then <tt>b.c</tt> lets you operate on <tt>C</tt> inside
--   <tt>A</tt>). You can create lenses with <a>lens</a>, or you can write
--   them by hand (see below).
--   
--   <tt>Lens s t a b</tt> is the lowest common denominator of a setter and
--   a getter, something that has the power of both; it has a
--   <a>Functor</a> constraint, and since both <a>Const</a> and
--   <a>Identity</a> are functors, it can be used whenever a getter or a
--   setter is needed.
--   
--   <ul>
--   <li><tt>a</tt> is the type of the value inside of structure</li>
--   <li><tt>b</tt> is the type of the replaced value</li>
--   <li><tt>s</tt> is the type of the whole structure</li>
--   <li><tt>t</tt> is the type of the structure after replacing <tt>a</tt>
--   in it with <tt>b</tt></li>
--   </ul>
--   
--   A <a>Lens</a> can only point at a single value inside a structure
--   (unlike a <a>Traversal</a>).
--   
--   It is easy to write lenses manually. The generic template is:
--   
--   <pre>
--   somelens :: Lens s t a b
--   
--   -- “f” is the “a -&gt; f b” function, “s” is the structure.
--   somelens f s =
--     let
--       a = ...                 -- Extract the value from “s”.
--       rebuildWith b = ...     -- Write a function which would
--                               -- combine “s” and modified value
--                               -- to produce new structure.
--     in
--       rebuildWith <a>&lt;$&gt;</a> f a     -- Apply the structure-producing
--                               -- function to the modified value.
--   </pre>
--   
--   Here's the <a>_1</a> lens:
--   
--   <pre>
--   _1 :: Lens (a, x) (b, x) a b
--   _1 f (a, x) = (\b -&gt; (b, x)) <a>&lt;$&gt;</a> f a
--   </pre>
--   
--   Here's a more complicated lens, which extracts <i>several</i> values
--   from a structure (in a tuple):
--   
--   <pre>
--   type Age     = Int
--   type City    = String
--   type Country = String
--   
--   data Person = Person Age City Country
--   
--   -- This lens lets you access all location-related information about a person.
--   location :: <a>Lens'</a> Person (City, Country)
--   location f (Person age city country) =
--     (\(city', country') -&gt; Person age city' country') <a>&lt;$&gt;</a> f (city, country)
--   </pre>
--   
--   You even can choose to use a lens to present <i>all</i> information
--   contained in the structure (in a different way). Such lenses are
--   called <tt>Iso</tt> in lens's terminology. For instance (assuming you
--   don't mind functions that can error out), here's a lens which lets you
--   act on the string representation of a value:
--   
--   <pre>
--   string :: (Read a, Show a) =&gt; <a>Lens'</a> a String
--   string f s = read <a>&lt;$&gt;</a> f (show s)
--   </pre>
--   
--   Using it to reverse a number:
--   
--   <pre>
--   &gt;&gt;&gt; 123 <a>&amp;</a> string <a>%~</a> reverse
--   321
--   </pre>
type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t

-- | This is a type alias for monomorphic lenses which don't change the
--   type of the container (or of the value inside).
type Lens' s a = Lens s s a a

-- | <a>lens</a> creates a <a>Lens</a> from a getter and a setter. The
--   resulting lens isn't the most effective one (because of having to
--   traverse the structure twice when modifying), but it shouldn't matter
--   much.
--   
--   A (partial) lens for list indexing:
--   
--   <pre>
--   ix :: Int -&gt; <a>Lens'</a> [a] a
--   ix i = <a>lens</a> (<a>!!</a> i)                                   -- getter
--               (\s b -&gt; take i s ++ b : drop (i+1) s)   -- setter
--   </pre>
--   
--   Usage:
--   
--   <pre>
--   &gt;&gt;&gt; [1..9] <a>^.</a> ix 3
--   4
--   
--   &gt;&gt;&gt; [1..9] &amp; ix 3 <a>%~</a> negate
--   [1,2,3,-4,5,6,7,8,9]
--   </pre>
--   
--   When getting, the setter is completely unused. When setting, the
--   getter is unused. Both are used only when the value is being modified.
--   
--   Here's an example of using a lens targeting the head of a list. The
--   getter is replaced with <a>undefined</a> to make sure it's not used:
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &amp; lens undefined (\s b -&gt; b : tail s) .~ 10
--   [10,2,3]
--   </pre>
lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b

-- | Traversals in a nutshell: they're like lenses but they can point at
--   multiple values. Use (<a>^..</a>) (not <a>^.</a>) to get all values,
--   (<a>^?</a>) to get the 1st value, (<a>.~</a>) to set values,
--   (<a>%~</a>) to modify them. (<a>.</a>) composes traversals just as it
--   composes lenses.
--   
--   <tt>Traversal s t a b</tt> is a generalisation of <a>Lens</a> which
--   allows many targets (possibly 0). It's achieved by changing the
--   constraint to <a>Applicative</a> instead of <a>Functor</a> – indeed,
--   the point of <a>Applicative</a> is that you can combine effects, which
--   is just what we need to have many targets.
--   
--   Traversals don't differ from lenses when it comes to setting – you can
--   use usual (<a>%~</a>) and (<a>.~</a>) to modify and set values.
--   Getting is a bit different, because you have to decide what to do in
--   the case of multiple values. In particular, you can use these
--   combinators (as well as everything else in the “Folds” section):
--   
--   <ul>
--   <li>(<a>^..</a>) gets a list of values</li>
--   <li>(<a>^?</a>) gets the 1st value (or <a>Nothing</a> if there are no
--   values)</li>
--   <li>(<a>^?!</a>) gets the 1st value and throws an exception if there
--   are no values</li>
--   </ul>
--   
--   In addition, (<a>^.</a>) works for traversals as well – it combines
--   traversed values using the (<a>&lt;&gt;</a>) operation (if the values
--   are instances of <a>Monoid</a>).
--   
--   Traversing any value twice is a violation of traversal laws. You can,
--   however, traverse values in any order.
--   
--   Ultimately, traversals should follow 2 laws:
--   
--   <pre>
--   t pure ≡ pure
--   fmap (t f) . t g ≡ getCompose . t (Compose . fmap f . g)
--   </pre>
--   
--   The 1st law states that you can't change the shape of the structure or
--   do anything funny with elements (traverse elements which aren't in the
--   structure, create new elements out of thin air, etc.). The 2nd law
--   states that you should be able to fuse 2 identical traversals into
--   one. For a more detailed explanation of the laws, see <a>this blog
--   post</a> (if you prefer rambling blog posts), or <a>The Essence Of The
--   Iterator Pattern</a> (if you prefer papers).
type Traversal s t a b = forall f. Applicative f => (a -> f b) -> s -> f t

-- | This is a type alias for monomorphic traversals which don't change the
--   type of the container (or of the values inside).
type Traversal' s a = Traversal s s a a

-- | <a>both</a> traverses both fields of a tuple. Unlike <tt>both</tt>
--   from lens, it only works for pairs – not for triples or <a>Either</a>.
--   
--   <pre>
--   &gt;&gt;&gt; ("str","ing") ^. both
--   "string"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ("str","ing") &amp; both %~ reverse
--   ("rts","gni")
--   </pre>
both :: Traversal (a, a) (b, b) a b

-- | <a>_Left</a> targets the value contained in an <a>Either</a>, provided
--   it's a <a>Left</a>.
--   
--   Gathering all <tt>Left</tt>s in a structure (like the <a>lefts</a>
--   function):
--   
--   <pre>
--   <a>toListOf</a> (<tt>each</tt> . <a>_Left</a>) :: [<a>Either</a> a b] -&gt; [a]
--   <a>toListOf</a> (<tt>each</tt> . <a>_Left</a>) = <a>lefts</a>
--   </pre>
--   
--   Checking whether an <a>Either</a> is a <a>Left</a> (like
--   <a>isLeft</a>):
--   
--   <pre>
--   &gt;&gt;&gt; has _Left (Left 1)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; has _Left (Right 1)
--   False
--   </pre>
--   
--   Extracting a value (if you're sure it's a <a>Left</a>):
--   
--   <pre>
--   &gt;&gt;&gt; Left 1 ^?! _Left
--   1
--   </pre>
--   
--   Mapping over all <tt>Left</tt>s:
--   
--   <pre>
--   &gt;&gt;&gt; (each._Left %~ map toUpper) [Left "foo", Right "bar"]
--   [Left "FOO",Right "bar"]
--   </pre>
--   
--   Implementation:
--   
--   <pre>
--   <a>_Left</a> f (Left a)  = <a>Left</a> <a>&lt;$&gt;</a> f a
--   <a>_Left</a> _ (Right b) = <a>pure</a> (<a>Right</a> b)
--   </pre>
_Left :: Traversal (Either a b) (Either a' b) a a'

-- | <a>_Right</a> targets the value contained in an <a>Either</a>,
--   provided it's a <a>Right</a>.
--   
--   See documentation for <a>_Left</a>.
_Right :: Traversal (Either a b) (Either a b') b b'

-- | <a>_Just</a> targets the value contained in a <a>Maybe</a>, provided
--   it's a <a>Just</a>.
--   
--   See documentation for <a>_Left</a> (as these 2 are pretty similar). In
--   particular, it can be used to write these:
--   
--   <ul>
--   <li>Unsafely extracting a value from a
--   <a>Just</a>:<pre><a>fromJust</a> = (<a>^?!</a> <a>_Just</a>)
--   </pre></li>
--   <li>Checking whether a value is a <a>Just</a>:<pre><a>isJust</a> =
--   <a>has</a> <a>_Just</a> </pre></li>
--   <li>Converting a <a>Maybe</a> to a list (empty or consisting of a
--   single element):<pre><a>maybeToList</a> = (<a>^..</a> <a>_Just</a>)
--   </pre></li>
--   <li>Gathering all <tt>Just</tt>s in a list:<pre><a>catMaybes</a> =
--   (<a>^..</a> <tt>each</tt> . <a>_Just</a>) </pre></li>
--   </ul>
_Just :: Traversal (Maybe a) (Maybe a') a a'

-- | <a>_Nothing</a> targets a <tt>()</tt> if the <a>Maybe</a> is a
--   <a>Nothing</a>, and doesn't target anything otherwise:
--   
--   <pre>
--   &gt;&gt;&gt; Just 1 ^.. _Nothing
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing ^.. _Nothing
--   [()]
--   </pre>
--   
--   It's not particularly useful (unless you want to use <tt><a>has</a>
--   <a>_Nothing</a></tt> as a replacement for <a>isNothing</a>), and
--   provided mainly for consistency.
--   
--   Implementation:
--   
--   <pre>
--   <a>_Nothing</a> f Nothing = <a>const</a> <a>Nothing</a> <a>&lt;$&gt;</a> f ()
--   <a>_Nothing</a> _ j       = <a>pure</a> j
--   </pre>
_Nothing :: Traversal' (Maybe a) ()
class Field1 s t a b | s -> a, t -> b, s b -> t, t a -> s
_1 :: Field1 s t a b => Lens s t a b
class Field2 s t a b | s -> a, t -> b, s b -> t, t a -> s
_2 :: Field2 s t a b => Lens s t a b
class Field3 s t a b | s -> a, t -> b, s b -> t, t a -> s
_3 :: Field3 s t a b => Lens s t a b
class Field4 s t a b | s -> a, t -> b, s b -> t, t a -> s
_4 :: Field4 s t a b => Lens s t a b
class Field5 s t a b | s -> a, t -> b, s b -> t, t a -> s
_5 :: Field5 s t a b => Lens s t a b
instance Field5 (a, b, c, d, e) (a, b, c, d, e') e e'
instance Field4 (a, b, c, d, e) (a, b, c, d', e) d d'
instance Field4 (a, b, c, d) (a, b, c, d') d d'
instance Field3 (a, b, c, d, e) (a, b, c', d, e) c c'
instance Field3 (a, b, c, d) (a, b, c', d) c c'
instance Field3 (a, b, c) (a, b, c') c c'
instance Field2 (a, b, c, d, e) (a, b', c, d, e) b b'
instance Field2 (a, b, c, d) (a, b', c, d) b b'
instance Field2 (a, b, c) (a, b', c) b b'
instance Field2 (a, b) (a, b') b b'
instance Field1 (a, b, c, d, e) (a', b, c, d, e) a a'
instance Field1 (a, b, c, d) (a', b, c, d) a a'
instance Field1 (a, b, c) (a', b, c) a a'
instance Field1 (a, b) (a', b) a a'
instance Applicative (Const r) => Monoid (Folding (Const r) a)

module Lens.Micro.Extras
(+~) :: Num a => ASetter s t a a -> a -> s -> t
(-~) :: Num a => ASetter s t a a -> a -> s -> t
(*~) :: Num a => ASetter s t a a -> a -> s -> t
(//~) :: Fractional a => ASetter s t a a -> a -> s -> t
