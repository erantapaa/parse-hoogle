-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | An XMPP client library
--   
@package pontarius-xmpp
@version 0.4.2.1


-- | (More than just) Van Laarhoven lenses for XMPP types. The accessors in
--   here are designed to work with an optics library like lens or
--   lens-family. This module also provides a few simple functions
--   (<tt>view</tt>, <a>modify</a>, <tt>set</tt> and <a>getAll</a>) so you
--   don't need to pull in another library to get some use out of them.
--   
--   <ul>
--   <li>The name of the lenses corresponds to the field name of the data
--   types with an upper-case L appended. For documentation of the fields
--   refer to the documentation of the data types (linked in the section
--   header)</li>
--   <li>Same goes for Traversals, except they are suffixed with a 'T'</li>
--   <li>Prism generally start with an underscore</li>
--   </ul>
--   
--   <i>NB</i> you do not need to import this module to get access to the
--   optics defined herein. They are also exported from Network.Xmpp. You
--   only need to import this module if you want to use the complementary
--   accessor functions without using an optics library like lens or
--   lens-family
module Network.Xmpp.Lens

-- | Van-Laarhoven lenses.

-- | <i>Deprecated: Use Lens' from lens-family or lens</i>
type Lens a b = Functor f => (b -> f b) -> a -> f a

-- | <i>Deprecated: Use Traversal' from lens-family or lens</i>
type Traversal a b = Applicative f => (b -> f b) -> a -> f a
type Prism a b = forall p f. (Choice p, Applicative f) => p b (f b) -> p a (f a)
type Iso a b = forall p f. (Profunctor p, Functor f) => p b (f b) -> p a (f a)

-- | <pre>
--   view :: Getter a a' b b' -&gt; a -&gt; b
--   </pre>
--   
--   Demote a lens or getter to a projection function.
--   
--   <pre>
--   view :: Monoid b =&gt; Fold a a' b b' -&gt; a -&gt; b
--   </pre>
--   
--   Returns the monoidal summary of a traversal or a fold.
view :: FoldLike b a a' b b' -> a -> b

-- | <i>Deprecated: use over (lens-family, lens)</i>
modify :: Traversal a b -> (b -> b) -> a -> a

-- | Set all referenced fields to the given value.
set :: Setter a a' b b' -> b' -> a -> a'

-- | Return all the values a Traversal is pointing to in a list

-- | <i>Deprecated: use toListOf (lens-family), partsOf (lens) or
--   similar</i>
getAll :: Traversal a b -> a -> [b]
prism' :: (b -> s) -> (s -> Maybe b) -> Prism s b
mkLens :: (a -> b) -> (b -> a -> a) -> Lens a b
mkIso :: (a -> b) -> (b -> a) -> Iso a b
_JidText :: Prism Text Jid
_isFull :: Prism Jid Jid
_isBare :: Prism Jid Jid
_IQRequest :: Prism Stanza IQRequest
_IQResult :: Prism Stanza IQResult
_IQError :: Prism Stanza IQError
_Message :: Prism Stanza Message
_MessageError :: Prism Stanza MessageError
_Presence :: Prism Stanza Presence
_PresenceError :: Prism Stanza PresenceError
class IsStanza s
from :: IsStanza s => Lens s (Maybe Jid)
to :: IsStanza s => Lens s (Maybe Jid)
lang :: IsStanza s => Lens s (Maybe LangTag)
sid :: IsStanza s => Lens s (Maybe Text)
payloadT :: IsStanza s => Traversal s Element
class HasStanzaPayload s p | s -> p
payload :: HasStanzaPayload s p => Lens s p
class IsErrorStanza s
stanzaError :: IsErrorStanza s => Lens s StanzaError
messageTypeL :: Lens Message MessageType
presenceTypeL :: Lens Presence PresenceType
iqRequestTypeL :: Lens IQRequest IQRequestType
stanzaErrorTypeL :: Lens StanzaError StanzaErrorType
stanzaErrorConditionL :: Lens StanzaError StanzaErrorCondition
stanzaErrorTextL :: Lens StanzaError (Maybe (Maybe LangTag, NonemptyText))
stanzaErrorApplL :: Lens StanzaError (Maybe Element)
preferredLangL :: Lens StreamConfiguration (Maybe LangTag)
toJidL :: Lens StreamConfiguration (Maybe (Jid, Bool))
connectionDetailsL :: Lens StreamConfiguration ConnectionDetails
resolvConfL :: Lens StreamConfiguration ResolvConf
establishSessionL :: Lens StreamConfiguration Bool
tlsBehaviourL :: Lens StreamConfiguration TlsBehaviour
tlsParamsL :: Lens StreamConfiguration ClientParams
clientServerIdentificationL :: Lens ClientParams (String, ByteString)

-- | Access clientServerIdentification inside tlsParams inside
--   streamConfiguration
tlsServerIdentificationL :: Lens SessionConfiguration (String, ByteString)
clientSupportedL :: Lens ClientParams Supported
supportedCiphersL :: Lens Supported [Cipher]
supportedVersionsL :: Lens Supported [Version]

-- | Access supportedCiphers inside clientSupported inside tlsParams
tlsSupportedCiphersL :: Lens SessionConfiguration [Cipher]

-- | Access supportedVersions inside clientSupported inside tlsParams
tlsSupportedVersionsL :: Lens SessionConfiguration [Version]
clientUseServerNameIndicationL :: Lens ClientParams Bool

-- | Access clientUseServerNameIndication inside tlsParams
tlsUseNameIndicationL :: Lens SessionConfiguration Bool
streamConfigurationL :: Lens SessionConfiguration StreamConfiguration
onConnectionClosedL :: Lens SessionConfiguration (Session -> XmppFailure -> IO ())
sessionStanzaIDsL :: Lens SessionConfiguration (IO (IO Text))
ensableRosterL :: Lens SessionConfiguration Bool
pluginsL :: Lens SessionConfiguration [Plugin]
onPresenceChangeL :: Lens SessionConfiguration (Maybe (Jid -> PeerStatus -> PeerStatus -> IO ()))
verL :: Lens Roster (Maybe Text)
itemsL :: Lens Roster (Map Jid Item)
riApprovedL :: Lens Item Bool
riAskL :: Lens Item Bool
riJidL :: Lens Item Jid
riNameL :: Lens Item (Maybe Text)
riSubscriptionL :: Lens Item Subscription
riGroupsL :: Lens Item [Text]
qiApprovedL :: Lens QueryItem (Maybe Bool)
qiAskL :: Lens QueryItem Bool
qiJidL :: Lens QueryItem Jid
qiNameL :: Lens QueryItem (Maybe Text)
qiSubscriptionL :: Lens QueryItem (Maybe Subscription)
qiGroupsL :: Lens QueryItem [Text]
queryVerL :: Lens Query (Maybe Text)
queryItemsL :: Lens Query [QueryItem]
bodyLangL :: Lens MessageBody (Maybe LangTag)
bodyContentL :: Lens MessageBody Text
threadIdL :: Lens MessageThread Text
threadParentL :: Lens MessageThread (Maybe Text)
subjectLangL :: Lens MessageSubject (Maybe LangTag)
subjectContentL :: Lens MessageSubject Text
imThreadL :: Lens InstantMessage (Maybe MessageThread)
imSubjectL :: Lens InstantMessage [MessageSubject]
imBodyL :: Lens InstantMessage [MessageBody]
showStatusL :: Lens IMPresence (Maybe ShowStatus)
statusL :: Lens IMPresence (Maybe Text)
priorityL :: Lens IMPresence (Maybe Int)
instance Functor (Collect a)
instance HasStanzaPayload PresenceError [Element]
instance HasStanzaPayload Presence [Element]
instance HasStanzaPayload MessageError [Element]
instance HasStanzaPayload Message [Element]
instance HasStanzaPayload IQError (Maybe Element)
instance HasStanzaPayload IQResult (Maybe Element)
instance HasStanzaPayload IQRequest Element
instance IsErrorStanza PresenceError
instance IsErrorStanza MessageError
instance IsErrorStanza IQError
instance IsStanza Stanza
instance IsStanza IQError
instance IsStanza IQResult
instance IsStanza IQRequest
instance IsStanza PresenceError
instance IsStanza Presence
instance IsStanza MessageError
instance IsStanza Message
instance Applicative (Collect a)


-- | RFC 6121: Instant Messaging and Presence
module Network.Xmpp.IM

-- | The instant message (IM) specific part of a message.
data InstantMessage
InstantMessage :: Maybe MessageThread -> [MessageSubject] -> [MessageBody] -> InstantMessage
imThread :: InstantMessage -> Maybe MessageThread
imSubject :: InstantMessage -> [MessageSubject]
imBody :: InstantMessage -> [MessageBody]
data MessageBody
MessageBody :: Maybe LangTag -> Text -> MessageBody
bodyLang :: MessageBody -> Maybe LangTag
bodyContent :: MessageBody -> Text
data MessageThread
MessageThread :: Text -> Maybe Text -> MessageThread
threadID :: MessageThread -> Text
threadParent :: MessageThread -> Maybe Text
data MessageSubject
MessageSubject :: Maybe LangTag -> Text -> MessageSubject
subjectLang :: MessageSubject -> Maybe LangTag
subjectContent :: MessageSubject -> Text
data Subscription
None :: Subscription
To :: Subscription
From :: Subscription
Both :: Subscription

-- | Empty instant message.
instantMessage :: InstantMessage

-- | Generate a simple message
simpleIM :: Jid -> Text -> Message

-- | Get the IM specific parts of a message. Returns <a>Nothing</a> when
--   the received payload is not valid IM data.
getIM :: Message -> Maybe InstantMessage

-- | Append IM data to a message. Additional IM bodies with the same
--   Langtag are discarded.
withIM :: Message -> InstantMessage -> Message

-- | Generate an answer from a received message. The recepient is taken
--   from the original sender, the sender is set to <a>Nothing</a>, message
--   ID, language tag, message type as well as subject and thread are
--   inherited.
--   
--   Additional IM bodies with the same Langtag are discarded.
answerIM :: [MessageBody] -> Message -> Maybe Message
data ShowStatus
StatusAway :: ShowStatus
StatusChat :: ShowStatus
StatusDnd :: ShowStatus
StatusXa :: ShowStatus
data IMPresence
IMP :: Maybe ShowStatus -> Maybe Text -> Maybe Int -> IMPresence
showStatus :: IMPresence -> Maybe ShowStatus
status :: IMPresence -> Maybe Text
priority :: IMPresence -> Maybe Int
imPresence :: IMPresence

-- | Try to extract RFC6121 IM presence information from presence stanza.
--   Returns Nothing when the data is malformed, (Just IMPresence)
--   otherwise.
getIMPresence :: Presence -> Maybe IMPresence
withIMPresence :: IMPresence -> Presence -> Presence
data Roster
Roster :: Maybe Text -> Map Jid Item -> Roster
ver :: Roster -> Maybe Text
items :: Roster -> Map Jid Item

-- | Roster Items
data Item
Item :: Bool -> Bool -> Jid -> Maybe Text -> Subscription -> [Text] -> Item
riApproved :: Item -> Bool
riAsk :: Item -> Bool
riJid :: Item -> Jid
riName :: Item -> Maybe Text
riSubscription :: Item -> Subscription
riGroups :: Item -> [Text]

-- | Retrieve the current Roster state
getRoster :: Session -> IO Roster

-- | Retrieve the current Roster state (STM version)
getRosterSTM :: Session -> STM Roster

-- | Synonym to rosterSet
rosterAdd :: Jid -> Maybe Text -> [Text] -> Session -> IO (Either IQSendError (Annotated IQResponse))

-- | Remove an item from the roster. Return <a>True</a> when the item is
--   sucessfully removed or if it wasn't in the roster to begin with.
rosterRemove :: Jid -> Session -> IO Bool
data PeerStatus
PeerAvailable :: (Maybe IMPresence) -> PeerStatus
PeerUnavailable :: PeerStatus

-- | Check whether a given jid is available
isPeerAvailable :: Jid -> Session -> STM Bool

-- | Get status of given full JID
getEntityStatus :: Jid -> Session -> STM PeerStatus

-- | Get list of (bare) Jids with available entities
getAvailablePeers :: Session -> STM [Jid]

-- | Get all available full JIDs to the given JID
getPeerEntities :: Jid -> Session -> STM (Map Jid (Maybe IMPresence))


-- | This module allows for low-level access to Pontarius XMPP. Generally,
--   the <a>Network.Xmpp</a> module should be used instead.
--   
--   The <a>Stream</a> object provides the most low-level access to the
--   XMPP stream: a simple and single-threaded interface which exposes the
--   conduit <tt>Event</tt> source, as well as the input and output byte
--   streams. Custom stateful <a>Stream</a> functions can be executed using
--   <a>withStream</a>.
--   
--   The TLS, SASL, and <a>Session</a> functionalities of Pontarius XMPP
--   are built on top of this API.
module Network.Xmpp.Internal

-- | Run an XmppConMonad action in isolation. Reader and writer workers
--   will be temporarily stopped and resumed with the new session details
--   once the action returns. The action will run in the calling thread.
--   Any uncaught exceptions will be interpreted as connection failure.
--   withConnection :: XmppConMonad a -&gt; Context -&gt; IO (Either
--   StreamError a)
withConnection :: (Stream -> IO (b, Stream)) -> Session -> IO (Either XmppFailure b)

-- | Executes a function to update the event handlers.
modifyHandlers :: (EventHandlers -> EventHandlers) -> Session -> IO ()

-- | Changes the handler to be executed when the server connection is
--   closed. To avoid race conditions the initial value should be set in
--   the configuration when creating the session
setConnectionClosedHandler :: (XmppFailure -> Session -> IO ()) -> Session -> IO ()
runConnectionClosedHandler :: Session -> XmppFailure -> IO ()

-- | Run an event handler.
runHandler :: (EventHandlers -> IO a) -> Session -> IO a

-- | End the current XMPP session. Kills the associated threads and closes
--   the connection.
--   
--   Note that XMPP clients (that have signalled availability) should send
--   "Unavailable" presence prior to disconnecting.
--   
--   The connectionClosedHandler will not be called (to avoid possibly
--   reestablishing the connection).
endSession :: Session -> IO ()

-- | Close the connection to the server. Closes the stream (by enforcing a
--   write lock and sending a &lt;/stream:stream&gt; element), waits
--   (blocks) for three seconds, and then closes the connection.
closeConnection :: Session -> IO ()
readWorker :: (Stanza -> IO ()) -> (XmppFailure -> IO ()) -> TMVar Stream -> IO a

-- | Runs thread in XmppState monad. Returns channel of incoming and
--   outgoing stances, respectively, and an Action to stop the Threads and
--   close the connection.
startThreadsWith :: TMVar (ByteString -> IO (Either XmppFailure ())) -> (Stanza -> IO ()) -> TMVar EventHandlers -> Stream -> Maybe Int -> IO (Either XmppFailure (IO (), TMVar Stream, ThreadId))

-- | Sends a blank space every 30 seconds to keep the connection alive.
connPersist :: Maybe Int -> TMVar (ByteString -> IO a) -> IO ()
semWrite :: WriteSemaphore -> ByteString -> IO (Either XmppFailure ())
writeStanza :: WriteSemaphore -> Stanza -> IO (Either XmppFailure ())

-- | Send a stanza to the server without running plugins. (The stanza is
--   sent as is)
sendRawStanza :: Stanza -> Session -> IO (Either XmppFailure ())

-- | Send a stanza to the server, managed by plugins
sendStanza :: Stanza -> Session -> IO (Either XmppFailure ())

-- | Get the channel of incoming stanzas.
getStanzaChan :: Session -> TChan (Stanza, [Annotation])

-- | Get the next incoming stanza
getStanza :: Session -> IO (Stanza, [Annotation])

-- | Duplicate the inbound channel of the session object. Most receiving
--   functions discard stanzas they are not interested in from the inbound
--   channel. Duplicating the channel ensures that those stanzas can aren't
--   lost and can still be handled somewhere else.
dupSession :: Session -> IO Session

-- | Return the JID assigned to us by the server
getJid :: Session -> IO (Maybe Jid)

-- | Return the JID assigned to us by the server
getFeatures :: Session -> IO StreamFeatures

-- | Wait until the connection of the stream is re-established
waitForStream :: Session -> IO ()
streamState :: Session -> STM ConnectionState
type StanzaHandler = (Stanza -> IO (Either XmppFailure ())) -> Stanza -> [Annotation] -> IO [(Stanza, [Annotation])]
type Resource = Text

-- | SASL handlers and the desired JID resource
--   
--   Nothing to disable authentication
--   
--   The allowed SASL mecahnism can depend on the connection state. For
--   example, <tt>plain</tt> should be avoided unless the connection state
--   is <a>Secured</a>
--   
--   It is recommended to leave the resource up to the server
type AuthData = Maybe (ConnectionState -> [SaslHandler], Maybe Resource)

-- | Annotations are auxiliary data attached to received stanzas by
--   <a>Plugin</a>s to convey information regarding their operation. For
--   example, a plugin for encryption might attach information about
--   whether a received stanza was encrypted and which algorithm was used.
data Annotation
Annotation :: f -> Annotation
fromAnnotation :: Annotation -> f
type Annotated a = (a, [Annotation])

-- | Retrieve the first matching annotation
getAnnotation :: Typeable b => Annotated a -> Maybe b
data Plugin'
Plugin' :: (Stanza -> [Annotation] -> IO [(Stanza, [Annotation])]) -> (Stanza -> IO (Either XmppFailure ())) -> (Session -> IO ()) -> Plugin'

-- | Resulting stanzas and additional Annotations
inHandler :: Plugin' -> Stanza -> [Annotation] -> IO [(Stanza, [Annotation])]
outHandler :: Plugin' -> Stanza -> IO (Either XmppFailure ())

-- | In order to allow plugins to tie the knot (Plugin / Session) we pass
--   the plugin the completed Session once it exists
onSessionUp :: Plugin' -> Session -> IO ()
type Plugin = (Stanza -> IO (Either XmppFailure ())) -> ErrorT XmppFailure IO Plugin'

-- | Configuration for the <tt>Session</tt> object.
data SessionConfiguration
SessionConfiguration :: StreamConfiguration -> (Session -> XmppFailure -> IO ()) -> IO (IO Text) -> [Plugin] -> Bool -> Bool -> Maybe (Jid -> PeerStatus -> PeerStatus -> IO ()) -> Maybe Int -> SessionConfiguration

-- | Configuration for the <tt>Stream</tt> object.
sessionStreamConfiguration :: SessionConfiguration -> StreamConfiguration

-- | Handler to be run when the conection to the XMPP server is closed. See
--   also <tt>reconnect</tt> and 'reconnect\'' for easy reconnection. The
--   default does nothing
onConnectionClosed :: SessionConfiguration -> Session -> XmppFailure -> IO ()

-- | Function to generate new stanza identifiers.
sessionStanzaIDs :: SessionConfiguration -> IO (IO Text)

-- | Plugins can modify incoming and outgoing stanzas, for example to en-
--   and decrypt them, respectively
plugins :: SessionConfiguration -> [Plugin]

-- | Enable roster handling according to rfc 6121. See <tt>getRoster</tt>
--   to acquire the current roster
enableRoster :: SessionConfiguration -> Bool

-- | Track incomming presence stancas.
enablePresenceTracking :: SessionConfiguration -> Bool

-- | Callback that is invoked when the presence status of a peer changes,
--   i.e. it comes online, goes offline or its IM presence changes. The
--   arguments are the (full) JID of the peer, the old state and the new
--   state. The function is called in a new thread to avoid blocking
--   handling stanzas
onPresenceChange :: SessionConfiguration -> Maybe (Jid -> PeerStatus -> PeerStatus -> IO ())

-- | How often to send keep-alives <a>Nothing</a> disables keep-alive
keepAlive :: SessionConfiguration -> Maybe Int

-- | Handlers to be run when the Xmpp session ends and when the Xmpp
--   connection is closed.
data EventHandlers
EventHandlers :: (XmppFailure -> IO ()) -> EventHandlers
connectionClosedHandler :: EventHandlers -> XmppFailure -> IO ()

-- | Interrupt is used to signal to the reader thread that it should stop.
--   Th contained semphore signals the reader to resume it's work.
data Interrupt
Interrupt :: (TMVar ()) -> Interrupt
type WriteSemaphore = TMVar (ByteString -> IO (Either XmppFailure ()))

-- | The Session object represents a single session with an XMPP server.
--   You can use <tt>session</tt> to establish a session
data Session
Session :: TChan (Stanza, [Annotation]) -> TVar IQHandlers -> WriteSemaphore -> ThreadId -> IO Text -> TMVar Stream -> TMVar EventHandlers -> IO () -> TVar Roster -> TVar Peers -> SessionConfiguration -> (Stanza -> IO (Either XmppFailure ())) -> HostName -> Maybe (ConnectionState -> [SaslHandler], Maybe Text) -> TVar Int -> Session
stanzaCh :: Session -> TChan (Stanza, [Annotation])
iqHandlers :: Session -> TVar IQHandlers
writeSemaphore :: Session -> WriteSemaphore
readerThread :: Session -> ThreadId
idGenerator :: Session -> IO Text

-- | Lock (used by withStream) to make sure that a maximum of one Stream
--   action is executed at any given time.
streamRef :: Session -> TMVar Stream
eventHandlers :: Session -> TMVar EventHandlers
stopThreads :: Session -> IO ()
rosterRef :: Session -> TVar Roster
presenceRef :: Session -> TVar Peers
conf :: Session -> SessionConfiguration
sendStanza' :: Session -> Stanza -> IO (Either XmppFailure ())
sRealm :: Session -> HostName
sSaslCredentials :: Session -> Maybe (ConnectionState -> [SaslHandler], Maybe Text)
reconnectWait :: Session -> TVar Int

-- | IQHandlers holds the registered channels for incoming IQ requests and
--   TMVars of and TMVars for expected IQ responses (the second Text
--   represent a stanza identifier.
type IQHandlers = (Map (IQRequestType, Text) (TChan IQRequestTicket), Map Text (Either (Maybe Jid) Jid, TMVar (Maybe (Annotated IQResponse))))

-- | A received and wrapped up IQ request. Prevents you from (illegally)
--   answering a single IQ request multiple times
data IQRequestTicket
IQRequestTicket :: (Either StanzaError (Maybe Element) -> [ExtendedAttribute] -> IO (Maybe (Either XmppFailure ()))) -> IQRequest -> [Annotation] -> IQRequestTicket

-- | Send an answer to an IQ request once. Subsequent calls will do nothing
--   and return Nothing
answerTicket :: IQRequestTicket -> Either StanzaError (Maybe Element) -> [ExtendedAttribute] -> IO (Maybe (Either XmppFailure ()))

-- | The actual IQ request that created this ticket.
iqRequestBody :: IQRequestTicket -> IQRequest

-- | Annotations set by plugins in receive
iqRequestAnnotations :: IQRequestTicket -> [Annotation]

-- | Error that can occur during sendIQ'
data IQSendError
IQSendError :: XmppFailure -> IQSendError
IQTimeOut :: IQSendError

-- | Draw and discard stanzas from the inbound channel until a message or
--   message error is found. Returns the message or message error with
--   annotations.
pullMessageA :: Session -> IO (Either (Annotated MessageError) (Annotated Message))

-- | Draw and discard stanzas from the inbound channel until a message or
--   message error is found. Returns the message or message error.
pullMessage :: Session -> IO (Either MessageError Message)

-- | Draw and discard stanzas from the inbound channel until a message is
--   found. Returns the message with annotations.
getMessageA :: Session -> IO (Annotated Message)

-- | Draw and discard stanzas from the inbound channel until a message is
--   found. Returns the message.
getMessage :: Session -> IO Message

-- | Draw and discard stanzas from the inbound channel until a message
--   matching the given predicate is found. Returns the matching message
--   with annotations.
waitForMessageA :: (Annotated Message -> Bool) -> Session -> IO (Annotated Message)

-- | Draw and discard stanzas from the inbound channel until a message
--   matching the given predicate is found. Returns the matching message.
waitForMessage :: (Message -> Bool) -> Session -> IO Message

-- | Draw and discard stanzas from the inbound channel until a message
--   error matching the given predicate is found. Returns the matching
--   message error with annotations.
waitForMessageErrorA :: (Annotated MessageError -> Bool) -> Session -> IO (Annotated MessageError)

-- | Draw and discard stanzas from the inbound channel until a message
--   error matching the given predicate is found. Returns the matching
--   message error
waitForMessageError :: (MessageError -> Bool) -> Session -> IO MessageError

-- | Draw and discard stanzas from the inbound channel until a message or
--   message error matching the given respective predicate is found.
--   Returns the matching message or message error with annotations
filterMessagesA :: (Annotated MessageError -> Bool) -> (Annotated Message -> Bool) -> Session -> IO (Either (Annotated MessageError) (Annotated Message))

-- | Draw and discard stanzas from the inbound channel until a message or
--   message error matching the given respective predicate is found.
--   Returns the matching message or message error.
filterMessages :: (MessageError -> Bool) -> (Message -> Bool) -> Session -> IO (Either MessageError Message)

-- | Send a message stanza. Returns <tt>False</tt> when the <a>Message</a>
--   could not be sent.
sendMessage :: Message -> Session -> IO (Either XmppFailure ())

-- | Read a presence stanza from the inbound stanza channel, discards any
--   other stanzas. Returns the presence stanza with annotations.
pullPresenceA :: Session -> IO (Either (Annotated PresenceError) (Annotated Presence))

-- | Read a presence stanza from the inbound stanza channel, discards any
--   other stanzas. Returns the presence stanza.
pullPresence :: Session -> IO (Either PresenceError Presence)

-- | Draw and discard stanzas from the inbound channel until a presence
--   stanza matching the given predicate is found. Return the presence
--   stanza with annotations.
waitForPresenceA :: (Annotated Presence -> Bool) -> Session -> IO (Annotated Presence)

-- | Draw and discard stanzas from the inbound channel until a presence
--   stanza matching the given predicate is found. Return the presence
--   stanza with annotations.
waitForPresence :: (Presence -> Bool) -> Session -> IO Presence

-- | Send a presence stanza.
sendPresence :: Presence -> Session -> IO (Either XmppFailure ())

-- | Sends an IQ, returns an STM action that returns the first inbound IQ
--   with a matching ID that has type <tt>result</tt> or <tt>error</tt> or
--   Nothing if the timeout was reached.
--   
--   When sending the action fails, an XmppFailure is returned.
sendIQ :: Maybe Integer -> Maybe Jid -> IQRequestType -> Maybe LangTag -> Element -> [ExtendedAttribute] -> Session -> IO (Either XmppFailure (STM (Maybe (Annotated IQResponse))))

-- | Like <a>sendIQ</a>, but waits for the answer IQ.
sendIQA' :: Maybe Integer -> Maybe Jid -> IQRequestType -> Maybe LangTag -> Element -> [ExtendedAttribute] -> Session -> IO (Either IQSendError (Annotated IQResponse))

-- | Like <a>sendIQ</a>, but waits for the answer IQ. Discards plugin
--   Annotations
sendIQ' :: Maybe Integer -> Maybe Jid -> IQRequestType -> Maybe LangTag -> Element -> [ExtendedAttribute] -> Session -> IO (Either IQSendError IQResponse)

-- | Register your interest in inbound IQ stanzas of a specific type and
--   namespace. The returned STM action yields the received, matching IQ
--   stanzas.
--   
--   If a handler for IQ stanzas with the given type and namespace is
--   already registered, the producer will be wrapped in Left. In this case
--   the returned request tickets may already be processed elsewhere.
listenIQ :: IQRequestType -> Text -> Session -> IO (Either (STM IQRequestTicket) (STM IQRequestTicket))

-- | Unregister a previously registered IQ handler. No more IQ stanzas will
--   be delivered to any of the returned producers.
unlistenIQ :: IQRequestType -> Text -> Session -> IO ()

-- | Answer an IQ request. Only the first answer ist sent and Just True is
--   returned when the answer is sucessfully sent. If an error occured
--   during sending Just False is returned (and another attempt can be
--   undertaken). Subsequent answers after the first sucessful one are
--   dropped and (False is returned in that case)
answerIQ :: IQRequestTicket -> Either StanzaError (Maybe Element) -> [ExtendedAttribute] -> IO (Maybe (Either XmppFailure ()))
class IQRequestClass a where data family IQResponseType a
pickleRequest :: IQRequestClass a => PU Element a
pickleResponse :: IQRequestClass a => PU [Element] (IQResponseType a)
requestType :: IQRequestClass a => a -> IQRequestType
requestNamespace :: IQRequestClass a => a -> Text
data IQRequestError
IQRequestSendError :: XmppFailure -> IQRequestError
IQRequestTimeout :: IQRequestError
IQRequestUnpickleError :: UnpickleError -> IQRequestError

-- | Send an IQ request. May throw IQSendError, UnpickleError,
sendIQRequest :: (IQRequestClass a, MonadError IQRequestError m, MonadIO m) => Maybe Integer -> Maybe Jid -> a -> Session -> m (Either IQError (IQResponseType a))
type IQRequestHandler a = a -> IO (Either StanzaError (IQResponseType a))
runIQHandler :: IQRequestClass a => IQRequestHandler a -> Session -> IO ()

-- | Creates and initializes a new Xmpp context.
newSession :: Stream -> SessionConfiguration -> HostName -> Maybe (ConnectionState -> [SaslHandler], Maybe Text) -> IO (Either XmppFailure Session)

-- | Creates a <a>Session</a> object by setting up a connection with an
--   XMPP server.
--   
--   Will connect to the specified host with the provided configuration. If
--   the third parameter is a <a>Just</a> value, <tt>session</tt> will
--   attempt to authenticate and acquire an XMPP resource.
session :: HostName -> AuthData -> SessionConfiguration -> IO (Either XmppFailure Session)

-- | Generates a new stanza identifier based on the <a>sessionStanzaIDs</a>
--   field of <a>SessionConfiguration</a>.
newStanzaID :: Session -> IO Text

-- | Reconnect with the stored settings.
--   
--   Waits a random amount of seconds (between 0 and 60 inclusive) before
--   the first attempt and an increasing amount after each attempt after
--   that. Caps out at 2-5 minutes.
--   
--   This function does not set your presence to online, so you will have
--   to do this yourself.
reconnect :: Integer -> Session -> IO (Bool, [XmppFailure])

-- | Reconnect with the stored settings with an unlimited number of
--   retries.
--   
--   Waits a random amount of seconds (between 0 and 60 inclusive) before
--   the first attempt and an increasing amount after each attempt after
--   that. Caps out at 2-5 minutes.
--   
--   This function does not set your presence to online, so you will have
--   to do this yourself.
reconnect' :: Session -> IO Integer

-- | Reconnect immediately with the stored settings. Returns <tt>Just</tt>
--   the error when the reconnect attempt fails and Nothing when no failure
--   was encountered.
--   
--   This function does not set your presence to online, so you will have
--   to do this yourself.
reconnectNow :: Session -> IO (Maybe XmppFailure)

-- | Authenticate using, in order of preference, <a>scramSha1</a>,
--   <a>digestMd5</a> and finally, if both of those are not support and the
--   stream is <a>Secured</a> with TLS, try <a>plain</a>
--   
--   The resource will be decided by the server
simpleAuth :: Username -> Password -> AuthData
semWrite :: WriteSemaphore -> ByteString -> IO (Either XmppFailure ())
writeStanza :: WriteSemaphore -> Stanza -> IO (Either XmppFailure ())

-- | Send a stanza to the server without running plugins. (The stanza is
--   sent as is)
sendRawStanza :: Stanza -> Session -> IO (Either XmppFailure ())

-- | Send a stanza to the server, managed by plugins
sendStanza :: Stanza -> Session -> IO (Either XmppFailure ())

-- | Get the channel of incoming stanzas.
getStanzaChan :: Session -> TChan (Stanza, [Annotation])

-- | Get the next incoming stanza
getStanza :: Session -> IO (Stanza, [Annotation])

-- | Duplicate the inbound channel of the session object. Most receiving
--   functions discard stanzas they are not interested in from the inbound
--   channel. Duplicating the channel ensures that those stanzas can aren't
--   lost and can still be handled somewhere else.
dupSession :: Session -> IO Session

-- | Return the JID assigned to us by the server
getJid :: Session -> IO (Maybe Jid)

-- | Return the JID assigned to us by the server
getFeatures :: Session -> IO StreamFeatures

-- | Wait until the connection of the stream is re-established
waitForStream :: Session -> IO ()
streamState :: Session -> STM ConnectionState

-- | Sends an IQ, returns an STM action that returns the first inbound IQ
--   with a matching ID that has type <tt>result</tt> or <tt>error</tt> or
--   Nothing if the timeout was reached.
--   
--   When sending the action fails, an XmppFailure is returned.
sendIQ :: Maybe Integer -> Maybe Jid -> IQRequestType -> Maybe LangTag -> Element -> [ExtendedAttribute] -> Session -> IO (Either XmppFailure (STM (Maybe (Annotated IQResponse))))

-- | Like <a>sendIQ</a>, but waits for the answer IQ.
sendIQA' :: Maybe Integer -> Maybe Jid -> IQRequestType -> Maybe LangTag -> Element -> [ExtendedAttribute] -> Session -> IO (Either IQSendError (Annotated IQResponse))

-- | Like <a>sendIQ</a>, but waits for the answer IQ. Discards plugin
--   Annotations
sendIQ' :: Maybe Integer -> Maybe Jid -> IQRequestType -> Maybe LangTag -> Element -> [ExtendedAttribute] -> Session -> IO (Either IQSendError IQResponse)

-- | Register your interest in inbound IQ stanzas of a specific type and
--   namespace. The returned STM action yields the received, matching IQ
--   stanzas.
--   
--   If a handler for IQ stanzas with the given type and namespace is
--   already registered, the producer will be wrapped in Left. In this case
--   the returned request tickets may already be processed elsewhere.
listenIQ :: IQRequestType -> Text -> Session -> IO (Either (STM IQRequestTicket) (STM IQRequestTicket))

-- | Unregister a previously registered IQ handler. No more IQ stanzas will
--   be delivered to any of the returned producers.
unlistenIQ :: IQRequestType -> Text -> Session -> IO ()

-- | Answer an IQ request. Only the first answer ist sent and Just True is
--   returned when the answer is sucessfully sent. If an error occured
--   during sending Just False is returned (and another attempt can be
--   undertaken). Subsequent answers after the first sucessful one are
--   dropped and (False is returned in that case)
answerIQ :: IQRequestTicket -> Either StanzaError (Maybe Element) -> [ExtendedAttribute] -> IO (Maybe (Either XmppFailure ()))
class IQRequestClass a where data family IQResponseType a
pickleRequest :: IQRequestClass a => PU Element a
pickleResponse :: IQRequestClass a => PU [Element] (IQResponseType a)
requestType :: IQRequestClass a => a -> IQRequestType
requestNamespace :: IQRequestClass a => a -> Text
data IQRequestError
IQRequestSendError :: XmppFailure -> IQRequestError
IQRequestTimeout :: IQRequestError
IQRequestUnpickleError :: UnpickleError -> IQRequestError

-- | Send an IQ request. May throw IQSendError, UnpickleError,
sendIQRequest :: (IQRequestClass a, MonadError IQRequestError m, MonadIO m) => Maybe Integer -> Maybe Jid -> a -> Session -> m (Either IQError (IQResponseType a))
type IQRequestHandler a = a -> IO (Either StanzaError (IQResponseType a))
runIQHandler :: IQRequestClass a => IQRequestHandler a -> Session -> IO ()

-- | Draw and discard stanzas from the inbound channel until a message or
--   message error is found. Returns the message or message error with
--   annotations.
pullMessageA :: Session -> IO (Either (Annotated MessageError) (Annotated Message))

-- | Draw and discard stanzas from the inbound channel until a message or
--   message error is found. Returns the message or message error.
pullMessage :: Session -> IO (Either MessageError Message)

-- | Draw and discard stanzas from the inbound channel until a message is
--   found. Returns the message with annotations.
getMessageA :: Session -> IO (Annotated Message)

-- | Draw and discard stanzas from the inbound channel until a message is
--   found. Returns the message.
getMessage :: Session -> IO Message

-- | Draw and discard stanzas from the inbound channel until a message
--   matching the given predicate is found. Returns the matching message
--   with annotations.
waitForMessageA :: (Annotated Message -> Bool) -> Session -> IO (Annotated Message)

-- | Draw and discard stanzas from the inbound channel until a message
--   matching the given predicate is found. Returns the matching message.
waitForMessage :: (Message -> Bool) -> Session -> IO Message

-- | Draw and discard stanzas from the inbound channel until a message
--   error matching the given predicate is found. Returns the matching
--   message error with annotations.
waitForMessageErrorA :: (Annotated MessageError -> Bool) -> Session -> IO (Annotated MessageError)

-- | Draw and discard stanzas from the inbound channel until a message
--   error matching the given predicate is found. Returns the matching
--   message error
waitForMessageError :: (MessageError -> Bool) -> Session -> IO MessageError

-- | Draw and discard stanzas from the inbound channel until a message or
--   message error matching the given respective predicate is found.
--   Returns the matching message or message error with annotations
filterMessagesA :: (Annotated MessageError -> Bool) -> (Annotated Message -> Bool) -> Session -> IO (Either (Annotated MessageError) (Annotated Message))

-- | Draw and discard stanzas from the inbound channel until a message or
--   message error matching the given respective predicate is found.
--   Returns the matching message or message error.
filterMessages :: (MessageError -> Bool) -> (Message -> Bool) -> Session -> IO (Either MessageError Message)

-- | Send a message stanza. Returns <tt>False</tt> when the <a>Message</a>
--   could not be sent.
sendMessage :: Message -> Session -> IO (Either XmppFailure ())

-- | Run an XmppConMonad action in isolation. Reader and writer workers
--   will be temporarily stopped and resumed with the new session details
--   once the action returns. The action will run in the calling thread.
--   Any uncaught exceptions will be interpreted as connection failure.
--   withConnection :: XmppConMonad a -&gt; Context -&gt; IO (Either
--   StreamError a)
withConnection :: (Stream -> IO (b, Stream)) -> Session -> IO (Either XmppFailure b)

-- | Executes a function to update the event handlers.
modifyHandlers :: (EventHandlers -> EventHandlers) -> Session -> IO ()

-- | Changes the handler to be executed when the server connection is
--   closed. To avoid race conditions the initial value should be set in
--   the configuration when creating the session
setConnectionClosedHandler :: (XmppFailure -> Session -> IO ()) -> Session -> IO ()
runConnectionClosedHandler :: Session -> XmppFailure -> IO ()

-- | Run an event handler.
runHandler :: (EventHandlers -> IO a) -> Session -> IO a

-- | End the current XMPP session. Kills the associated threads and closes
--   the connection.
--   
--   Note that XMPP clients (that have signalled availability) should send
--   "Unavailable" presence prior to disconnecting.
--   
--   The connectionClosedHandler will not be called (to avoid possibly
--   reestablishing the connection).
endSession :: Session -> IO ()

-- | Close the connection to the server. Closes the stream (by enforcing a
--   write lock and sending a &lt;/stream:stream&gt; element), waits
--   (blocks) for three seconds, and then closes the connection.
closeConnection :: Session -> IO ()

-- | Read a presence stanza from the inbound stanza channel, discards any
--   other stanzas. Returns the presence stanza with annotations.
pullPresenceA :: Session -> IO (Either (Annotated PresenceError) (Annotated Presence))

-- | Read a presence stanza from the inbound stanza channel, discards any
--   other stanzas. Returns the presence stanza.
pullPresence :: Session -> IO (Either PresenceError Presence)

-- | Draw and discard stanzas from the inbound channel until a presence
--   stanza matching the given predicate is found. Return the presence
--   stanza with annotations.
waitForPresenceA :: (Annotated Presence -> Bool) -> Session -> IO (Annotated Presence)

-- | Draw and discard stanzas from the inbound channel until a presence
--   stanza matching the given predicate is found. Return the presence
--   stanza with annotations.
waitForPresence :: (Presence -> Bool) -> Session -> IO Presence

-- | Send a presence stanza.
sendPresence :: Presence -> Session -> IO (Either XmppFailure ())
readWorker :: (Stanza -> IO ()) -> (XmppFailure -> IO ()) -> TMVar Stream -> IO a

-- | Runs thread in XmppState monad. Returns channel of incoming and
--   outgoing stances, respectively, and an Action to stop the Threads and
--   close the connection.
startThreadsWith :: TMVar (ByteString -> IO (Either XmppFailure ())) -> (Stanza -> IO ()) -> TMVar EventHandlers -> Stream -> Maybe Int -> IO (Either XmppFailure (IO (), TMVar Stream, ThreadId))

-- | Sends a blank space every 30 seconds to keep the connection alive.
connPersist :: Maybe Int -> TMVar (ByteString -> IO a) -> IO ()
type StanzaHandler = (Stanza -> IO (Either XmppFailure ())) -> Stanza -> [Annotation] -> IO [(Stanza, [Annotation])]
type Resource = Text

-- | SASL handlers and the desired JID resource
--   
--   Nothing to disable authentication
--   
--   The allowed SASL mecahnism can depend on the connection state. For
--   example, <tt>plain</tt> should be avoided unless the connection state
--   is <a>Secured</a>
--   
--   It is recommended to leave the resource up to the server
type AuthData = Maybe (ConnectionState -> [SaslHandler], Maybe Resource)

-- | Annotations are auxiliary data attached to received stanzas by
--   <a>Plugin</a>s to convey information regarding their operation. For
--   example, a plugin for encryption might attach information about
--   whether a received stanza was encrypted and which algorithm was used.
data Annotation
Annotation :: f -> Annotation
fromAnnotation :: Annotation -> f
type Annotated a = (a, [Annotation])

-- | Retrieve the first matching annotation
getAnnotation :: Typeable b => Annotated a -> Maybe b
data Plugin'
Plugin' :: (Stanza -> [Annotation] -> IO [(Stanza, [Annotation])]) -> (Stanza -> IO (Either XmppFailure ())) -> (Session -> IO ()) -> Plugin'

-- | Resulting stanzas and additional Annotations
inHandler :: Plugin' -> Stanza -> [Annotation] -> IO [(Stanza, [Annotation])]
outHandler :: Plugin' -> Stanza -> IO (Either XmppFailure ())

-- | In order to allow plugins to tie the knot (Plugin / Session) we pass
--   the plugin the completed Session once it exists
onSessionUp :: Plugin' -> Session -> IO ()
type Plugin = (Stanza -> IO (Either XmppFailure ())) -> ErrorT XmppFailure IO Plugin'

-- | Configuration for the <tt>Session</tt> object.
data SessionConfiguration
SessionConfiguration :: StreamConfiguration -> (Session -> XmppFailure -> IO ()) -> IO (IO Text) -> [Plugin] -> Bool -> Bool -> Maybe (Jid -> PeerStatus -> PeerStatus -> IO ()) -> Maybe Int -> SessionConfiguration

-- | Configuration for the <tt>Stream</tt> object.
sessionStreamConfiguration :: SessionConfiguration -> StreamConfiguration

-- | Handler to be run when the conection to the XMPP server is closed. See
--   also <tt>reconnect</tt> and 'reconnect\'' for easy reconnection. The
--   default does nothing
onConnectionClosed :: SessionConfiguration -> Session -> XmppFailure -> IO ()

-- | Function to generate new stanza identifiers.
sessionStanzaIDs :: SessionConfiguration -> IO (IO Text)

-- | Plugins can modify incoming and outgoing stanzas, for example to en-
--   and decrypt them, respectively
plugins :: SessionConfiguration -> [Plugin]

-- | Enable roster handling according to rfc 6121. See <tt>getRoster</tt>
--   to acquire the current roster
enableRoster :: SessionConfiguration -> Bool

-- | Track incomming presence stancas.
enablePresenceTracking :: SessionConfiguration -> Bool

-- | Callback that is invoked when the presence status of a peer changes,
--   i.e. it comes online, goes offline or its IM presence changes. The
--   arguments are the (full) JID of the peer, the old state and the new
--   state. The function is called in a new thread to avoid blocking
--   handling stanzas
onPresenceChange :: SessionConfiguration -> Maybe (Jid -> PeerStatus -> PeerStatus -> IO ())

-- | How often to send keep-alives <a>Nothing</a> disables keep-alive
keepAlive :: SessionConfiguration -> Maybe Int

-- | Handlers to be run when the Xmpp session ends and when the Xmpp
--   connection is closed.
data EventHandlers
EventHandlers :: (XmppFailure -> IO ()) -> EventHandlers
connectionClosedHandler :: EventHandlers -> XmppFailure -> IO ()

-- | Interrupt is used to signal to the reader thread that it should stop.
--   Th contained semphore signals the reader to resume it's work.
data Interrupt
Interrupt :: (TMVar ()) -> Interrupt
type WriteSemaphore = TMVar (ByteString -> IO (Either XmppFailure ()))

-- | The Session object represents a single session with an XMPP server.
--   You can use <tt>session</tt> to establish a session
data Session
Session :: TChan (Stanza, [Annotation]) -> TVar IQHandlers -> WriteSemaphore -> ThreadId -> IO Text -> TMVar Stream -> TMVar EventHandlers -> IO () -> TVar Roster -> TVar Peers -> SessionConfiguration -> (Stanza -> IO (Either XmppFailure ())) -> HostName -> Maybe (ConnectionState -> [SaslHandler], Maybe Text) -> TVar Int -> Session
stanzaCh :: Session -> TChan (Stanza, [Annotation])
iqHandlers :: Session -> TVar IQHandlers
writeSemaphore :: Session -> WriteSemaphore
readerThread :: Session -> ThreadId
idGenerator :: Session -> IO Text

-- | Lock (used by withStream) to make sure that a maximum of one Stream
--   action is executed at any given time.
streamRef :: Session -> TMVar Stream
eventHandlers :: Session -> TMVar EventHandlers
stopThreads :: Session -> IO ()
rosterRef :: Session -> TVar Roster
presenceRef :: Session -> TVar Peers
conf :: Session -> SessionConfiguration
sendStanza' :: Session -> Stanza -> IO (Either XmppFailure ())
sRealm :: Session -> HostName
sSaslCredentials :: Session -> Maybe (ConnectionState -> [SaslHandler], Maybe Text)
reconnectWait :: Session -> TVar Int

-- | IQHandlers holds the registered channels for incoming IQ requests and
--   TMVars of and TMVars for expected IQ responses (the second Text
--   represent a stanza identifier.
type IQHandlers = (Map (IQRequestType, Text) (TChan IQRequestTicket), Map Text (Either (Maybe Jid) Jid, TMVar (Maybe (Annotated IQResponse))))

-- | A received and wrapped up IQ request. Prevents you from (illegally)
--   answering a single IQ request multiple times
data IQRequestTicket
IQRequestTicket :: (Either StanzaError (Maybe Element) -> [ExtendedAttribute] -> IO (Maybe (Either XmppFailure ()))) -> IQRequest -> [Annotation] -> IQRequestTicket

-- | Send an answer to an IQ request once. Subsequent calls will do nothing
--   and return Nothing
answerTicket :: IQRequestTicket -> Either StanzaError (Maybe Element) -> [ExtendedAttribute] -> IO (Maybe (Either XmppFailure ()))

-- | The actual IQ request that created this ticket.
iqRequestBody :: IQRequestTicket -> IQRequest

-- | Annotations set by plugins in receive
iqRequestAnnotations :: IQRequestTicket -> [Annotation]

-- | Error that can occur during sendIQ'
data IQSendError
IQSendError :: XmppFailure -> IQSendError
IQTimeOut :: IQSendError
data MessageBody
MessageBody :: Maybe LangTag -> Text -> MessageBody
bodyLang :: MessageBody -> Maybe LangTag
bodyContent :: MessageBody -> Text
data MessageThread
MessageThread :: Text -> Maybe Text -> MessageThread
threadID :: MessageThread -> Text
threadParent :: MessageThread -> Maybe Text
data MessageSubject
MessageSubject :: Maybe LangTag -> Text -> MessageSubject
subjectLang :: MessageSubject -> Maybe LangTag
subjectContent :: MessageSubject -> Text

-- | The instant message (IM) specific part of a message.
data InstantMessage
InstantMessage :: Maybe MessageThread -> [MessageSubject] -> [MessageBody] -> InstantMessage
imThread :: InstantMessage -> Maybe MessageThread
imSubject :: InstantMessage -> [MessageSubject]
imBody :: InstantMessage -> [MessageBody]

-- | Empty instant message.
instantMessage :: InstantMessage

-- | Get the IM specific parts of a message. Returns <a>Nothing</a> when
--   the received payload is not valid IM data.
getIM :: Message -> Maybe InstantMessage
sanitizeIM :: InstantMessage -> InstantMessage

-- | Append IM data to a message. Additional IM bodies with the same
--   Langtag are discarded.
withIM :: Message -> InstantMessage -> Message
imToElements :: InstantMessage -> [Element]

-- | Generate a simple message
simpleIM :: Jid -> Text -> Message

-- | Generate an answer from a received message. The recepient is taken
--   from the original sender, the sender is set to <a>Nothing</a>, message
--   ID, language tag, message type as well as subject and thread are
--   inherited.
--   
--   Additional IM bodies with the same Langtag are discarded.
answerIM :: [MessageBody] -> Message -> Maybe Message
xpIM :: PU [Element] InstantMessage
xpMessageSubject :: PU [Element] [MessageSubject]
xpMessageBody :: PU [Element] [MessageBody]
xpMessageThread :: PU [Element] (Maybe MessageThread)
data ShowStatus
StatusAway :: ShowStatus
StatusChat :: ShowStatus
StatusDnd :: ShowStatus
StatusXa :: ShowStatus
data IMPresence
IMP :: Maybe ShowStatus -> Maybe Text -> Maybe Int -> IMPresence
showStatus :: IMPresence -> Maybe ShowStatus
status :: IMPresence -> Maybe Text
priority :: IMPresence -> Maybe Int
imPresence :: IMPresence

-- | Try to extract RFC6121 IM presence information from presence stanza.
--   Returns Nothing when the data is malformed, (Just IMPresence)
--   otherwise.
getIMPresence :: Presence -> Maybe IMPresence
withIMPresence :: IMPresence -> Presence -> Presence
xpIMPresence :: PU [Element] IMPresence
xpShow :: PU Text ShowStatus

-- | Timeout to use with IQ requests
timeout :: Maybe Integer

-- | Add or update an item to the roster.
--   
--   To update the item just send the complete set of new data.
rosterSet :: Jid -> Maybe Text -> [Text] -> Session -> IO (Either IQSendError (Annotated IQResponse))

-- | Synonym to rosterSet
rosterAdd :: Jid -> Maybe Text -> [Text] -> Session -> IO (Either IQSendError (Annotated IQResponse))

-- | Remove an item from the roster. Return <a>True</a> when the item is
--   sucessfully removed or if it wasn't in the roster to begin with.
rosterRemove :: Jid -> Session -> IO Bool

-- | Retrieve the current Roster state (STM version)
getRosterSTM :: Session -> STM Roster

-- | Retrieve the current Roster state
getRoster :: Session -> IO Roster

-- | Get the initial roster or refresh the roster. You don't need to call
--   this on your own.
initRoster :: Session -> IO ()
handleRoster :: Maybe Jid -> TVar Roster -> StanzaHandler
retrieveRoster :: Maybe Roster -> Session -> IO (Maybe Roster)
toItem :: QueryItem -> Item
fromItem :: Item -> QueryItem
xpItems :: PU [Node] [QueryItem]
xpQuery :: PU [Node] Query
xpSubscription :: PU Text Subscription
data Subscription
None :: Subscription
To :: Subscription
From :: Subscription
Both :: Subscription
Remove :: Subscription
data Roster
Roster :: Maybe Text -> Map Jid Item -> Roster
ver :: Roster -> Maybe Text
items :: Roster -> Map Jid Item

-- | Roster Items
data Item
Item :: Bool -> Bool -> Jid -> Maybe Text -> Subscription -> [Text] -> Item
riApproved :: Item -> Bool
riAsk :: Item -> Bool
riJid :: Item -> Jid
riName :: Item -> Maybe Text
riSubscription :: Item -> Subscription
riGroups :: Item -> [Text]
data QueryItem
QueryItem :: Maybe Bool -> Bool -> Jid -> Maybe Text -> Maybe Subscription -> [Text] -> QueryItem
qiApproved :: QueryItem -> Maybe Bool
qiAsk :: QueryItem -> Bool
qiJid :: QueryItem -> Jid
qiName :: QueryItem -> Maybe Text
qiSubscription :: QueryItem -> Maybe Subscription
qiGroups :: QueryItem -> [Text]
data Query
Query :: Maybe Text -> [QueryItem] -> Query
queryVer :: Query -> Maybe Text
queryItems :: Query -> [QueryItem]
xpNonemptyText :: PU Text NonemptyText
xpStreamStanza :: PU [Node] (Either StreamErrorInfo Stanza)
xpExtendedAttrs :: PU [Attribute] [ExtendedAttribute]
xpStanza :: PU [Node] Stanza
xpMessage :: PU [Node] (Message)
xpPresence :: PU [Node] Presence
xpIQRequest :: PU [Node] IQRequest
xpIQResult :: PU [Node] IQResult
xpStanzaErrorCondition :: PU [Node] StanzaErrorCondition
xpStanzaError :: PU [Node] StanzaError
xpMessageError :: PU [Node] (MessageError)
xpPresenceError :: PU [Node] PresenceError
xpIQError :: PU [Node] IQError
xpStreamError :: PU [Node] StreamErrorInfo
xpLangTag :: PU [Attribute] (Maybe LangTag)
xpLang :: PU Text LangTag
xmlLang :: Name
pickleElem :: PU [Node] a -> a -> Element
unpickleElem :: PU [Node] a -> Element -> Either UnpickleError a
xpNodeElem :: PU [Node] a -> PU Element a
mbl :: Maybe [a] -> [a]
lmb :: [t] -> Maybe [t]
xpStream :: PU [Node] (Text, Maybe Jid, Maybe Jid, Maybe Text, Maybe LangTag)
xpStreamFeatures :: PU [Node] StreamFeatures
xpJid :: PU Text Jid
xpIQRequestType :: PU Text IQRequestType
xpMessageType :: PU Text MessageType
xpPresenceType :: PU Text PresenceType
xpStanzaErrorType :: PU Text StanzaErrorType
xpStreamErrorCondition :: PU Text StreamErrorCondition

-- | Uses the first supported mechanism to authenticate, if any. Updates
--   the state with non-password credentials and restarts the stream upon
--   success. Returns <a>Nothing</a> on success, an <a>AuthFailure</a> if
--   authentication fails, or an <a>XmppFailure</a> if anything else fails.
xmppSasl :: [SaslHandler] -> Stream -> IO (Either XmppFailure (Maybe AuthFailure))
digestMd5 :: Username -> Maybe AuthZID -> Password -> SaslHandler
scramSha1 :: Username -> Maybe AuthZID -> Password -> SaslHandler
plain :: Username -> Maybe AuthZID -> Password -> SaslHandler

-- | Authenticate to the server using the first matching method and bind a
--   resource.
auth :: [SaslHandler] -> Maybe Text -> Stream -> IO (Either XmppFailure (Maybe AuthFailure))
makeNonce :: IO ByteString
saslInitE :: Text -> Maybe Text -> Element
saslResponseE :: Maybe Text -> Element
xpSuccess :: PU [Node] (Maybe Text)
pairs :: ByteString -> Either String Pairs
xpFailure :: PU [Node] SaslFailure
xpSaslError :: PU Text SaslError
xpChallenge :: PU [Node] (Maybe Text)

-- | Pickler for SaslElement.
xpSaslElement :: PU [Node] SaslElement

-- | Add quotationmarks around a byte string.
quote :: ByteString -> ByteString
saslInit :: Text -> Maybe ByteString -> ErrorT AuthFailure (StateT StreamState IO) ()

-- | Pull the next element.
pullSaslElement :: ErrorT AuthFailure (StateT StreamState IO) SaslElement

-- | Pull the next element, checking that it is a challenge.
pullChallenge :: ErrorT AuthFailure (StateT StreamState IO) (Maybe ByteString)

-- | Extract value from Just, failing with AuthOtherFailure on Nothing.
saslFromJust :: Maybe a -> ErrorT AuthFailure (StateT StreamState IO) a

-- | Pull the next element and check that it is success.
pullSuccess :: ErrorT AuthFailure (StateT StreamState IO) (Maybe Text)

-- | Pull the next element. When it's success, return it's payload. If it's
--   a challenge, send an empty response and pull success.
pullFinalMessage :: ErrorT AuthFailure (StateT StreamState IO) (Maybe ByteString)

-- | Extract p=q pairs from a challenge.
toPairs :: ByteString -> ErrorT AuthFailure (StateT StreamState IO) Pairs

-- | Send a SASL response element. The content will be base64-encoded.
respond :: Maybe ByteString -> ErrorT AuthFailure (StateT StreamState IO) ()

-- | Run the appropriate stringprep profiles on the credentials. May fail
--   with <tt>AuthStringPrepFailure</tt>
prepCredentials :: Text -> Maybe Text -> Text -> ErrorT AuthFailure (StateT StreamState IO) (Text, Maybe Text, Text)

-- | Bit-wise xor of byte strings
xorBS :: ByteString -> ByteString -> ByteString

-- | Join byte strings with ","
merge :: [ByteString] -> ByteString

-- | Infix concatenation of byte strings
(+++) :: ByteString -> ByteString -> ByteString
digestMd5 :: Username -> Maybe AuthZID -> Password -> SaslHandler
scramSha1 :: Username -> Maybe AuthZID -> Password -> SaslHandler
plain :: Username -> Maybe AuthZID -> Password -> SaslHandler
digestMd5 :: Username -> Maybe AuthZID -> Password -> SaslHandler
plain :: Username -> Maybe AuthZID -> Password -> SaslHandler

-- | A nicer name for undefined, for use as a dummy token to determin the
--   hash function to use
hashToken :: Hash ctx hash => hash

-- | Salted Challenge Response Authentication Mechanism (SCRAM) SASL
--   mechanism according to RFC 5802.
--   
--   This implementation is independent and polymorphic in the used hash
--   function.
scram :: Hash ctx hash => hash -> Text -> Maybe Text -> Text -> ErrorT AuthFailure (StateT StreamState IO) ()
scramSha1 :: Username -> Maybe AuthZID -> Password -> SaslHandler
nonAsciiSpaces :: Set Char
toSpace :: Char -> Text
saslPrepQuery :: StringPrepProfile
saslPrepStore :: StringPrepProfile
normalizePassword :: Text -> Maybe Text
normalizeUsername :: Text -> Maybe Text
type Username = Text
type Password = Text
type AuthZID = Text
data SaslElement
SaslSuccess :: (Maybe Text) -> SaslElement
SaslChallenge :: (Maybe Text) -> SaslElement
type Pairs = [(ByteString, ByteString)]

-- | Tuple defining the SASL Handler's name, and a SASL mechanism
--   computation. The SASL mechanism is a stateful <tt>Stream</tt>
--   computation, which has the possibility of resulting in an
--   authentication error.
type SaslHandler = (Text, StateT StreamState IO (Either XmppFailure (Maybe AuthFailure)))

-- | Request subscription with an entity.
presenceSubscribe :: Jid -> Presence

-- | Approve a subscripton of an entity.
presenceSubscribed :: Jid -> Presence

-- | End a subscription with an entity.
presenceUnsubscribe :: Jid -> Presence

-- | Deny a not-yet approved or terminate a previously approved
--   subscription of an entity
presenceUnsubscribed :: Jid -> Presence

-- | Signal to the server that the client is available for communication.
presenceOnline :: Presence

-- | Signal to the server that the client is no longer available for
--   communication.
presenceOffline :: Presence

-- | Produce an answer message with the given payload, setting "from" to
--   the "to" attributes in the original message. Produces a <a>Nothing</a>
--   value of the provided message message has no "from" attribute. Sets
--   the "from" attribute to <a>Nothing</a> to let the server assign one.
answerMessage :: Message -> [Element] -> Maybe Message

-- | Add a recipient to a presence notification.
presTo :: Presence -> Jid -> Presence

-- | Create a StanzaError with <tt>condition</tt> and the
--   <a>associatedErrorType</a>. Leave the error text and the application
--   specific condition empty
mkStanzaError :: StanzaErrorCondition -> StanzaError

-- | Create an IQ error response to an IQ request using the given
--   condition. The error type is derived from the condition using
--   <a>associatedErrorType</a> and both text and the application specific
--   condition are left empty
iqError :: StanzaErrorCondition -> IQRequest -> IQError

-- | Create an IQ Result matching an IQ request
iqResult :: Maybe Element -> IQRequest -> IQResult

-- | The RECOMMENDED error type associated with an error condition. The
--   following conditions allow for multiple types
--   
--   <ul>
--   <li><a>FeatureNotImplemented</a>: <a>Cancel</a> or <a>Modify</a>
--   (returns <a>Cancel</a>)</li>
--   <li><a>PolicyViolation</a>: <a>Modify</a> or <a>Wait</a>
--   (<a>Modify</a>)</li>
--   <li><a>RemoteServerTimeout</a>: <a>Wait</a> or unspecified other
--   (<a>Wait</a>)</li>
--   <li><a>UndefinedCondition</a>: Any condition (<a>Cancel</a>)</li>
--   </ul>
associatedErrorType :: StanzaErrorCondition -> StanzaErrorType
readMaybe_ :: Read a => String -> Maybe a
mbl :: Maybe [a] -> [a]
lmb :: [t] -> Maybe [t]
streamUnpickleElem :: PU [Node] a -> Element -> StreamSink a
type StreamSink a = ConduitM Event Void (ErrorT XmppFailure IO) a
throwOutJunk :: Monad m => ConduitM Event a m ()
openElementFromEvents :: StreamSink Element
startStream :: StateT StreamState IO (Either XmppFailure ())
flattenAttrs :: [(Name, [Content])] -> [(Name, Text)]
restartStream :: StateT StreamState IO (Either XmppFailure ())
sourceStreamHandle :: (MonadIO m, MonadError XmppFailure m) => StreamHandle -> ConduitM i ByteString m ()
bufferSrc :: Source (ErrorT XmppFailure IO) o -> IO (ConduitM i o (ErrorT XmppFailure IO) ())
streamS :: Maybe Jid -> StreamSink (Either Element (Text, Maybe Jid, Maybe Jid, Maybe Text, Maybe LangTag, StreamFeatures))

-- | Connects to the XMPP server and opens the XMPP stream against the
--   given realm.
openStream :: HostName -> StreamConfiguration -> IO (Either XmppFailure (Stream))

-- | Send "<a>/stream:stream</a>" and wait for the server to finish
--   processing and to close the connection. Any remaining elements from
--   the server are returned. Surpresses <a>StreamEndFailure</a>
--   exceptions, but may throw a <a>StreamCloseError</a>.
closeStreams :: Stream -> IO ()
closeStreams' :: StateT StreamState IO ()
debugOut :: MonadIO m => ByteString -> m ()
wrapIOException :: MonadIO m => IO a -> m (Either XmppFailure a)
pushElement :: Element -> StateT StreamState IO (Either XmppFailure ())
nsHack :: Element -> Element

-- | Encode and send stanza
pushStanza :: Stanza -> Stream -> IO (Either XmppFailure ())
pushXmlDecl :: StateT StreamState IO (Either XmppFailure ())
pushOpenElement :: Element -> StateT StreamState IO (Either XmppFailure ())
runEventsSink :: Sink Event (ErrorT XmppFailure IO) b -> StateT StreamState IO (Either XmppFailure b)
pullElement :: StateT StreamState IO (Either XmppFailure Element)
pullUnpickle :: PU [Node] a -> StateT StreamState IO (Either XmppFailure a)

-- | Pulls a stanza (or stream error) from the stream.
pullStanza :: Stream -> IO (Either XmppFailure Stanza)
catchPush :: IO () -> IO (Either XmppFailure ())
zeroHandle :: StreamHandle
xmppNoStream :: StreamState
zeroSource :: Source (ErrorT XmppFailure IO) a
handleToStreamHandle :: Handle -> StreamHandle
createStream :: HostName -> StreamConfiguration -> ErrorT XmppFailure IO (Stream)
connect :: HostName -> StreamConfiguration -> ErrorT XmppFailure IO (Maybe StreamHandle)
connectSrv :: ResolvConf -> String -> ErrorT XmppFailure IO (Maybe Handle)
showPort :: PortID -> String
connectTcp :: [(HostName, PortID)] -> IO (Maybe Handle)
fixDnsResult :: Either e a -> Maybe a
resolvAndConnectTcp :: ResolvSeed -> Domain -> Int -> IO (Maybe Handle)
resolvSrvsAndConnectTcp :: ResolvSeed -> [(Domain, Int)] -> IO (Maybe Handle)
rethrowErrorCall :: IO a -> IO a
srvLookup :: Text -> ResolvSeed -> ErrorT XmppFailure IO (Maybe [(Domain, Int)])

-- | Close the connection and updates the XmppConMonad Stream state. Does
--   not send the stream end tag.
killStream :: Stream -> IO (Either XmppFailure ())
pushIQ :: Text -> Maybe Jid -> IQRequestType -> Maybe LangTag -> Element -> Stream -> IO (Either XmppFailure (Either IQError IQResult))
debugConduit :: (Show o, MonadIO m) => ConduitM o o m b
elements :: MonadError XmppFailure m => Conduit Event m Element
withStream :: StateT StreamState IO a -> Stream -> IO a
withStream' :: StateT StreamState IO a -> Stream -> IO a
mkStream :: StreamState -> IO Stream
tryIOError :: IO a -> IO (Either IOError a)
mkBackend :: StreamHandle -> Backend
starttlsE :: Element

-- | Checks for TLS support and run starttls procedure if applicable
tls :: Stream -> IO (Either XmppFailure ())
client :: (MonadIO m, CPRG rng) => ClientParams -> rng -> Backend -> m Context
tlsinit :: (MonadIO m, MonadIO m1) => ClientParams -> Backend -> m (Source m1 ByteString, Sink ByteString m1 (), ByteString -> IO (), Int -> m1 ByteString, Context)
mkReadBuffer :: IO ByteString -> IO (Int -> IO ByteString)

-- | Connect to an XMPP server and secure the connection with TLS before
--   starting the XMPP streams
--   
--   <i>NB</i> RFC 6120 does not specify this method, but some servers,
--   notably GCS, seem to use it.
connectTls :: ResolvConf -> ClientParams -> String -> ErrorT XmppFailure IO StreamHandle
wrapExceptions :: IO a -> IO (Either XmppFailure a)

-- | Type of Texts that contain at least on non-space character
newtype NonemptyText
Nonempty :: Text -> NonemptyText
fromNonempty :: NonemptyText -> Text

-- | Check that Text contains at least one non-space character and wrap it
nonEmpty :: Text -> Maybe NonemptyText

-- | Same as <a>fromNonempty</a>
text :: NonemptyText -> Text

-- | The answer to an IQ request that generated an error.
data IQError
IQError :: !Text -> !(Maybe Jid) -> !(Maybe Jid) -> !(Maybe LangTag) -> !StanzaError -> !(Maybe Element) -> ![ExtendedAttribute] -> IQError
iqErrorID :: IQError -> !Text
iqErrorFrom :: IQError -> !(Maybe Jid)
iqErrorTo :: IQError -> !(Maybe Jid)
iqErrorLangTag :: IQError -> !(Maybe LangTag)
iqErrorStanzaError :: IQError -> !StanzaError
iqErrorPayload :: IQError -> !(Maybe Element)
iqErrorAttributes :: IQError -> ![ExtendedAttribute]

-- | A "request" Info/Query (IQ) stanza is one with either "get" or "set"
--   as type. It always contains an xml payload.
data IQRequest
IQRequest :: !Text -> !(Maybe Jid) -> !(Maybe Jid) -> !(Maybe LangTag) -> !IQRequestType -> !Element -> ![ExtendedAttribute] -> IQRequest
iqRequestID :: IQRequest -> !Text
iqRequestFrom :: IQRequest -> !(Maybe Jid)
iqRequestTo :: IQRequest -> !(Maybe Jid)
iqRequestLangTag :: IQRequest -> !(Maybe LangTag)
iqRequestType :: IQRequest -> !IQRequestType
iqRequestPayload :: IQRequest -> !Element
iqRequestAttributes :: IQRequest -> ![ExtendedAttribute]

-- | The type of IQ request that is made.
data IQRequestType
Get :: IQRequestType
Set :: IQRequestType

-- | A "response" Info/Query (IQ) stanza is either an <a>IQError</a>, an IQ
--   stanza of type "result" (<a>IQResult</a>)
data IQResponse
IQResponseError :: IQError -> IQResponse
IQResponseResult :: IQResult -> IQResponse

-- | The (non-error) answer to an IQ request.
data IQResult
IQResult :: !Text -> !(Maybe Jid) -> !(Maybe Jid) -> !(Maybe LangTag) -> !(Maybe Element) -> ![ExtendedAttribute] -> IQResult
iqResultID :: IQResult -> !Text
iqResultFrom :: IQResult -> !(Maybe Jid)
iqResultTo :: IQResult -> !(Maybe Jid)
iqResultLangTag :: IQResult -> !(Maybe LangTag)
iqResultPayload :: IQResult -> !(Maybe Element)
iqResultAttributes :: IQResult -> ![ExtendedAttribute]

-- | The language tag in accordance with RFC 5646 (in the form of "en-US").
--   It has a primary tag and a number of subtags. Two language tags are
--   considered equal if and only if they contain the same tags
--   (case-insensitive).
data LangTag
LangTag :: !Text -> ![Text] -> LangTag
primaryTag :: LangTag -> !Text
subtags :: LangTag -> ![Text]
langTagQ :: QuasiQuoter

-- | Parses, validates, and possibly constructs a <a>LangTag</a> object.
langTagFromText :: Text -> Maybe LangTag
langTagToText :: LangTag -> Text
parseLangTag :: String -> LangTag
type ExtendedAttribute = (Name, Text)

-- | The message stanza. Used for <i>push</i> type communication.
data Message
Message :: !(Maybe Text) -> !(Maybe Jid) -> !(Maybe Jid) -> !(Maybe LangTag) -> !MessageType -> ![Element] -> ![ExtendedAttribute] -> Message
messageID :: Message -> !(Maybe Text)
messageFrom :: Message -> !(Maybe Jid)
messageTo :: Message -> !(Maybe Jid)
messageLangTag :: Message -> !(Maybe LangTag)
messageType :: Message -> !MessageType
messagePayload :: Message -> ![Element]
messageAttributes :: Message -> ![ExtendedAttribute]

-- | An empty message
--   
--   <pre>
--   message = Message { messageID      = Nothing
--                     , messageFrom    = Nothing
--                     , messageTo      = Nothing
--                     , messageLangTag = Nothing
--                     , messageType    = Normal
--                     , messagePayload = []
--                     }
--   </pre>
message :: Message

-- | An error stanza generated in response to a <a>Message</a>.
data MessageError
MessageError :: !(Maybe Text) -> !(Maybe Jid) -> !(Maybe Jid) -> !(Maybe LangTag) -> !StanzaError -> ![Element] -> ![ExtendedAttribute] -> MessageError
messageErrorID :: MessageError -> !(Maybe Text)
messageErrorFrom :: MessageError -> !(Maybe Jid)
messageErrorTo :: MessageError -> !(Maybe Jid)
messageErrorLangTag :: MessageError -> !(Maybe LangTag)
messageErrorStanzaError :: MessageError -> !StanzaError
messageErrorPayload :: MessageError -> ![Element]
messageErrorAttributes :: MessageError -> ![ExtendedAttribute]
messageError :: MessageError

-- | The type of a Message being sent
--   (<a>http://xmpp.org/rfcs/rfc6121.html#message-syntax-type</a>)
data MessageType

-- | The message is sent in the context of a one-to-one chat session.
--   Typically an interactive client will present a message of type
--   <i>chat</i> in an interface that enables one-to-one chat between the
--   two parties, including an appropriate conversation history.
Chat :: MessageType

-- | The message is sent in the context of a multi-user chat environment
--   (similar to that of <tt>IRC</tt>). Typically a receiving client will
--   present a message of type <i>groupchat</i> in an interface that
--   enables many-to-many chat between the parties, including a roster of
--   parties in the chatroom and an appropriate conversation history.
GroupChat :: MessageType

-- | The message provides an alert, a notification, or other transient
--   information to which no reply is expected (e.g., news headlines,
--   sports updates, near-real-time market data, or syndicated content).
--   Because no reply to the message is expected, typically a receiving
--   client will present a message of type <i>headline</i> in an interface
--   that appropriately differentiates the message from standalone
--   messages, chat messages, and groupchat messages (e.g., by not
--   providing the recipient with the ability to reply).
Headline :: MessageType

-- | The message is a standalone message that is sent outside the context
--   of a one-to-one conversation or groupchat, and to which it is expected
--   that the recipient will reply. Typically a receiving client will
--   present a message of type <i>normal</i> in an interface that enables
--   the recipient to reply, but without a conversation history.
--   
--   This is the <i>default</i> value.
Normal :: MessageType

-- | The presence stanza. Used for communicating status updates.
data Presence
Presence :: !(Maybe Text) -> !(Maybe Jid) -> !(Maybe Jid) -> !(Maybe LangTag) -> !PresenceType -> ![Element] -> ![ExtendedAttribute] -> Presence
presenceID :: Presence -> !(Maybe Text)
presenceFrom :: Presence -> !(Maybe Jid)
presenceTo :: Presence -> !(Maybe Jid)
presenceLangTag :: Presence -> !(Maybe LangTag)
presenceType :: Presence -> !PresenceType
presencePayload :: Presence -> ![Element]
presenceAttributes :: Presence -> ![ExtendedAttribute]

-- | An empty presence.
presence :: Presence

-- | An error stanza generated in response to a <a>Presence</a>.
data PresenceError
PresenceError :: !(Maybe Text) -> !(Maybe Jid) -> !(Maybe Jid) -> !(Maybe LangTag) -> !StanzaError -> ![Element] -> ![ExtendedAttribute] -> PresenceError
presenceErrorID :: PresenceError -> !(Maybe Text)
presenceErrorFrom :: PresenceError -> !(Maybe Jid)
presenceErrorTo :: PresenceError -> !(Maybe Jid)
presenceErrorLangTag :: PresenceError -> !(Maybe LangTag)
presenceErrorStanzaError :: PresenceError -> !StanzaError
presenceErrorPayload :: PresenceError -> ![Element]
presenceErrorAttributes :: PresenceError -> ![ExtendedAttribute]

-- | <tt>PresenceType</tt> holds Xmpp presence types. The "error" message
--   type is left out as errors are using <tt>PresenceError</tt>.
data PresenceType

-- | Sender wants to subscribe to presence
Subscribe :: PresenceType

-- | Sender has approved the subscription
Subscribed :: PresenceType

-- | Sender is unsubscribing from presence
Unsubscribe :: PresenceType

-- | Sender has denied or cancelled a subscription
Unsubscribed :: PresenceType

-- | Sender requests current presence; should only be used by servers
Probe :: PresenceType

-- | Sender wants to express availability (no type attribute is defined)
Available :: PresenceType
Unavailable :: PresenceType
data SaslError

-- | Client aborted.
SaslAborted :: SaslError

-- | The account has been temporarily disabled.
SaslAccountDisabled :: SaslError

-- | The authentication failed because the credentials have expired.
SaslCredentialsExpired :: SaslError

-- | The mechanism requested cannot be used the confidentiality and
--   integrity of the underlying stream is protected (typically with TLS).
SaslEncryptionRequired :: SaslError

-- | The base64 encoding is incorrect.
SaslIncorrectEncoding :: SaslError

-- | The authzid has an incorrect format or the initiating entity does not
--   have the appropriate permissions to authorize that ID.
SaslInvalidAuthzid :: SaslError

-- | The mechanism is not supported by the receiving entity.
SaslInvalidMechanism :: SaslError

-- | Invalid syntax.
SaslMalformedRequest :: SaslError

-- | The receiving entity policy requires a stronger mechanism.
SaslMechanismTooWeak :: SaslError

-- | Invalid credentials provided, or some generic authentication failure
--   has occurred.
SaslNotAuthorized :: SaslError

-- | There receiving entity reported a temporary error condition; the
--   initiating entity is recommended to try again later.
SaslTemporaryAuthFailure :: SaslError
data SaslFailure
SaslFailure :: SaslError -> Maybe (Maybe LangTag, Text) -> SaslFailure
saslFailureCondition :: SaslFailure -> SaslError
saslFailureText :: SaslFailure -> Maybe (Maybe LangTag, Text)
data StreamFeatures
StreamFeatures :: !(Maybe Bool) -> ![Text] -> !(Maybe Bool) -> ![Element] -> StreamFeatures
streamTls :: StreamFeatures -> !(Maybe Bool)
streamSaslMechanisms :: StreamFeatures -> ![Text]

-- | <tt>Nothing</tt> for no roster versioning, <tt>Just False</tt> for
--   roster versioning and <tt>Just True</tt> when the server sends the
--   non-standard "optional" element (observed with prosody).
rosterVer :: StreamFeatures -> !(Maybe Bool)
streamOtherFeatures :: StreamFeatures -> ![Element]

-- | The Xmpp communication primities (Message, Presence and Info/Query)
--   are called stanzas.
data Stanza
IQRequestS :: !IQRequest -> Stanza
IQResultS :: !IQResult -> Stanza
IQErrorS :: !IQError -> Stanza
MessageS :: !Message -> Stanza
MessageErrorS :: !MessageError -> Stanza
PresenceS :: !Presence -> Stanza
PresenceErrorS :: !PresenceError -> Stanza

-- | Empty message stanza
--   
--   <pre>
--   messageS = <a>MessageS</a> <a>message</a>
--   </pre>
messageS :: Stanza
messageErrorS :: Stanza

-- | Empty presence stanza
presenceS :: Stanza

-- | All stanzas (IQ, message, presence) can cause errors, which in the
--   Xmpp stream looks like <tt>&lt;stanza-kind to='sender'
--   type='error'&gt;</tt> . These errors are wrapped in the
--   <tt>StanzaError</tt> type. TODO: Sender XML is (optional and is) not
--   yet included.
data StanzaError
StanzaError :: StanzaErrorType -> StanzaErrorCondition -> Maybe (Maybe LangTag, NonemptyText) -> Maybe Element -> StanzaError
stanzaErrorType :: StanzaError -> StanzaErrorType
stanzaErrorCondition :: StanzaError -> StanzaErrorCondition
stanzaErrorText :: StanzaError -> Maybe (Maybe LangTag, NonemptyText)
stanzaErrorApplicationSpecificCondition :: StanzaError -> Maybe Element

-- | Stanza errors are accommodated with one of the error conditions listed
--   below.
data StanzaErrorCondition

-- | Malformed XML.
BadRequest :: StanzaErrorCondition

-- | Resource or session with name already exists.
Conflict :: StanzaErrorCondition
FeatureNotImplemented :: StanzaErrorCondition

-- | Insufficient permissions.
Forbidden :: StanzaErrorCondition

-- | Entity can no longer be contacted at this address.
Gone :: (Maybe NonemptyText) -> StanzaErrorCondition
InternalServerError :: StanzaErrorCondition
ItemNotFound :: StanzaErrorCondition
JidMalformed :: StanzaErrorCondition

-- | Does not meet policy criteria.
NotAcceptable :: StanzaErrorCondition

-- | No entity may perform this action.
NotAllowed :: StanzaErrorCondition

-- | Must provide proper credentials.
NotAuthorized :: StanzaErrorCondition

-- | The entity has violated some local service policy (e.g., a message
--   contains words that are prohibited by the service)
PolicyViolation :: StanzaErrorCondition

-- | Temporarily unavailable.
RecipientUnavailable :: StanzaErrorCondition

-- | Redirecting to other entity, usually temporarily.
Redirect :: (Maybe NonemptyText) -> StanzaErrorCondition
RegistrationRequired :: StanzaErrorCondition
RemoteServerNotFound :: StanzaErrorCondition
RemoteServerTimeout :: StanzaErrorCondition

-- | Entity lacks the necessary system resources.
ResourceConstraint :: StanzaErrorCondition
ServiceUnavailable :: StanzaErrorCondition
SubscriptionRequired :: StanzaErrorCondition

-- | Application-specific condition.
UndefinedCondition :: StanzaErrorCondition

-- | Badly timed request.
UnexpectedRequest :: StanzaErrorCondition

-- | <tt>StanzaError</tt>s always have one of these types.
data StanzaErrorType

-- | Error is unrecoverable - do not retry
Cancel :: StanzaErrorType

-- | Conditition was a warning - proceed
Continue :: StanzaErrorType

-- | Change the data and retry
Modify :: StanzaErrorType

-- | Provide credentials and retry
Auth :: StanzaErrorType

-- | Error is temporary - wait and retry
Wait :: StanzaErrorType

-- | Signals an XMPP stream error or another unpredicted stream-related
--   situation. This error is fatal, and closes the XMPP stream.
data XmppFailure

-- | An error XML stream element has been encountered.
StreamErrorFailure :: StreamErrorInfo -> XmppFailure

-- | The stream has been closed. This exception is caught by the concurrent
--   implementation, and will thus not be visible through use of
--   <tt>Session</tt>.
StreamEndFailure :: XmppFailure

-- | When an XmppFailure is encountered in closeStreams, this constructor
--   wraps the elements collected so far.
StreamCloseError :: ([Element], XmppFailure) -> XmppFailure

-- | All attempts to TCP connect to the server failed.
TcpConnectionFailure :: XmppFailure

-- | The TCP details provided did not validate.
XmppIllegalTcpDetails :: XmppFailure

-- | An error occurred in the TLS layer
TlsError :: XmppTlsError -> XmppFailure

-- | The server does not support the use of TLS
TlsNoServerSupport :: XmppFailure

-- | An action that required an active stream were performed when the
--   <a>StreamState</a> was <a>Closed</a>
XmppNoStream :: XmppFailure

-- | Authentication with the server failed (unrecoverably)
XmppAuthFailure :: AuthFailure -> XmppFailure

-- | Connection already secured
TlsStreamSecured :: XmppFailure

-- | Undefined condition. More information should be available in the log.
XmppOtherFailure :: XmppFailure

-- | An <a>IOException</a> occurred
XmppIOException :: IOException -> XmppFailure

-- | Received data is not valid XML
XmppInvalidXml :: String -> XmppFailure
data XmppTlsError
XmppTlsError :: TLSError -> XmppTlsError
XmppTlsException :: TLSException -> XmppTlsError
data StreamErrorCondition

-- | The entity has sent XML that cannot be processed.
StreamBadFormat :: StreamErrorCondition

-- | The entity has sent a namespace prefix that is unsupported, or has
--   sent no namespace prefix on an element that needs such a prefix
StreamBadNamespacePrefix :: StreamErrorCondition

-- | The server either (1) is closing the existing stream for this entity
--   because a new stream has been initiated that conflicts with the
--   existing stream, or (2) is refusing a new stream for this entity
--   because allowing the new stream would conflict with an existing stream
--   (e.g., because the server allows only a certain number of connections
--   from the same IP address or allows only one server-to-server stream
--   for a given domain pair as a way of helping to ensure in-order
--   processing
StreamConflict :: StreamErrorCondition

-- | One party is closing the stream because it has reason to believe that
--   the other party has permanently lost the ability to communicate over
--   the stream.
StreamConnectionTimeout :: StreamErrorCondition

-- | The value of the <tt>to</tt> attribute provided in the initial stream
--   header corresponds to an FQDN that is no longer serviced by the
--   receiving entity
StreamHostGone :: StreamErrorCondition

-- | The value of the <tt>to</tt> attribute provided in the initial stream
--   header does not correspond to an FQDN that is serviced by the
--   receiving entity.
StreamHostUnknown :: StreamErrorCondition

-- | A stanza sent between two servers lacks a <tt>to</tt> or <tt>from</tt>
--   attribute, the <tt>from</tt> or <tt>to</tt> attribute has no value, or
--   the value violates the rules for XMPP addresses
StreamImproperAddressing :: StreamErrorCondition

-- | The server has experienced a misconfiguration or other internal error
--   that prevents it from servicing the stream.
StreamInternalServerError :: StreamErrorCondition

-- | The data provided in a <tt>from</tt> attribute does not match an
--   authorized JID or validated domain as negotiated (1) between two
--   servers using SASL or Server Dialback, or (2) between a client and a
--   server via SASL authentication and resource binding.
StreamInvalidFrom :: StreamErrorCondition

-- | The stream namespace name is something other than
--   "http:/<i>etherx.jabber.org</i>streams" (see Section 11.2) or the
--   content namespace declared as the default namespace is not supported
--   (e.g., something other than "jabber:client" or "jabber:server").
StreamInvalidNamespace :: StreamErrorCondition

-- | The entity has sent invalid XML over the stream to a server that
--   performs validation
StreamInvalidXml :: StreamErrorCondition

-- | The entity has attempted to send XML stanzas or other outbound data
--   before the stream has been authenticated, or otherwise is not
--   authorized to perform an action related to stream negotiation; the
--   receiving entity MUST NOT process the offending data before sending
--   the stream error.
StreamNotAuthorized :: StreamErrorCondition

-- | The initiating entity has sent XML that violates the well-formedness
--   rules of [XML] or [XML‑NAMES].
StreamNotWellFormed :: StreamErrorCondition

-- | The entity has violated some local service policy (e.g., a stanza
--   exceeds a configured size limit); the server MAY choose to specify the
--   policy in the &lt;text/&gt; element or in an application-specific
--   condition element.
StreamPolicyViolation :: StreamErrorCondition

-- | The server is unable to properly connect to a remote entity that is
--   needed for authentication or authorization (e.g., in certain scenarios
--   related to Server Dialback [XEP‑0220]); this condition is not to be
--   used when the cause of the error is within the administrative domain
--   of the XMPP service provider, in which case the
--   &lt;internal-server-error /&gt; condition is more appropriate.
StreamRemoteConnectionFailed :: StreamErrorCondition

-- | The server is closing the stream because it has new (typically
--   security-critical) features to offer, because the keys or certificates
--   used to establish a secure context for the stream have expired or have
--   been revoked during the life of the stream , because the TLS sequence
--   number has wrapped, etc. The reset applies to the stream and to any
--   security context established for that stream (e.g., via TLS and SASL),
--   which means that encryption and authentication need to be negotiated
--   again for the new stream (e.g., TLS session resumption cannot be used)
StreamReset :: StreamErrorCondition

-- | The server lacks the system resources necessary to service the stream.
StreamResourceConstraint :: StreamErrorCondition

-- | he entity has attempted to send restricted XML features such as a
--   comment, processing instruction, DTD subset, or XML entity reference
StreamRestrictedXml :: StreamErrorCondition

-- | The server will not provide service to the initiating entity but is
--   redirecting traffic to another host under the administrative control
--   of the same service provider.
StreamSeeOtherHost :: StreamErrorCondition

-- | The server is being shut down and all active streams are being closed.
StreamSystemShutdown :: StreamErrorCondition

-- | The error condition is not one of those defined by the other
--   conditions in this list
StreamUndefinedCondition :: StreamErrorCondition

-- | The initiating entity has encoded the stream in an encoding that is
--   not supported by the server or has otherwise improperly encoded the
--   stream (e.g., by violating the rules of the [UTF‑8] encoding).
StreamUnsupportedEncoding :: StreamErrorCondition

-- | The receiving entity has advertised a mandatory-to-negotiate stream
--   feature that the initiating entity does not support, and has offered
--   no other mandatory-to-negotiate feature alongside the unsupported
--   feature.
StreamUnsupportedFeature :: StreamErrorCondition

-- | The initiating entity has sent a first-level child of the stream that
--   is not supported by the server, either because the receiving entity
--   does not understand the namespace or because the receiving entity does
--   not understand the element name for the applicable namespace (which
--   might be the content namespace declared as the default namespace)
StreamUnsupportedStanzaType :: StreamErrorCondition

-- | The <tt>version</tt> attribute provided by the initiating entity in
--   the stream header specifies a version of XMPP that is not supported by
--   the server.
StreamUnsupportedVersion :: StreamErrorCondition

-- | XMPP version number. Displayed as "&lt;major&gt;.&lt;minor&gt;". 2.4
--   is lesser than 2.13, which in turn is lesser than 12.3.
data Version
Version :: !Integer -> !Integer -> Version
majorVersion :: Version -> !Integer
minorVersion :: Version -> !Integer
versionFromText :: Text -> Maybe Version

-- | Defines operations for sending, receiving, flushing, and closing on a
--   stream.
data StreamHandle
StreamHandle :: (ByteString -> IO (Either XmppFailure ())) -> (Int -> IO (Either XmppFailure ByteString)) -> IO () -> IO () -> StreamHandle

-- | Sends may not interleave
streamSend :: StreamHandle -> ByteString -> IO (Either XmppFailure ())
streamReceive :: StreamHandle -> Int -> IO (Either XmppFailure ByteString)
streamFlush :: StreamHandle -> IO ()
streamClose :: StreamHandle -> IO ()
newtype Stream
Stream :: TMVar StreamState -> Stream
unStream :: Stream -> TMVar StreamState
data StreamState
StreamState :: !ConnectionState -> StreamHandle -> Source (ErrorT XmppFailure IO) Event -> !StreamFeatures -> !(Maybe Text) -> !(Maybe Jid) -> !(Maybe Text) -> !(Maybe LangTag) -> !(Maybe Jid) -> StreamConfiguration -> StreamState

-- | State of the stream - <a>Closed</a>, <a>Plain</a>, or <a>Secured</a>
streamConnectionState :: StreamState -> !ConnectionState

-- | Functions to send, receive, flush, and close the stream
streamHandle :: StreamState -> StreamHandle

-- | Event conduit source, and its associated finalizer
streamEventSource :: StreamState -> Source (ErrorT XmppFailure IO) Event

-- | Stream features advertised by the server
streamFeatures :: StreamState -> !StreamFeatures

-- | The hostname or IP specified for the connection
streamAddress :: StreamState -> !(Maybe Text)

-- | The hostname specified in the server's stream element's <tt>from</tt>
--   attribute
streamFrom :: StreamState -> !(Maybe Jid)

-- | The identifier specified in the server's stream element's <a>id</a>
--   attribute
streamId :: StreamState -> !(Maybe Text)

-- | The language tag value specified in the server's stream element's
--   <tt>langtag</tt> attribute; will be a <a>Just</a> value once connected
--   to the server TODO: Verify
streamLang :: StreamState -> !(Maybe LangTag)

-- | Our JID as assigned by the server
streamJid :: StreamState -> !(Maybe Jid)

-- | Configuration settings for the stream
streamConfiguration :: StreamState -> StreamConfiguration

-- | Signals the state of the stream connection.
data ConnectionState

-- | Stream has not been established yet
Closed :: ConnectionState

-- | Stream established, but not secured via TLS
Plain :: ConnectionState

-- | Stream established and secured via TLS
Secured :: ConnectionState

-- | Stream was closed
Finished :: ConnectionState

-- | Encapsulates information about an XMPP stream error.
data StreamErrorInfo
StreamErrorInfo :: !StreamErrorCondition -> !(Maybe (Maybe LangTag, NonemptyText)) -> !(Maybe Element) -> StreamErrorInfo
errorCondition :: StreamErrorInfo -> !StreamErrorCondition
errorText :: StreamErrorInfo -> !(Maybe (Maybe LangTag, NonemptyText))
errorXml :: StreamErrorInfo -> !(Maybe Element)

-- | Specify the method with which the connection is (re-)established
data ConnectionDetails

-- | Use realm to resolv host. This is the default.
UseRealm :: ConnectionDetails

-- | Use this hostname for a SRV lookup
UseSrv :: HostName -> ConnectionDetails

-- | Use specified host
UseHost :: HostName -> PortID -> ConnectionDetails

-- | Use a custom method to create a StreamHandle. This will also be used
--   by reconnect. For example, to establish TLS before starting the stream
--   as done by GCM, see <tt>connectTls</tt>. You can also return an
--   already established connection. This method should also return a
--   hostname that is used for TLS signature verification. If startTLS is
--   not used it can be left empty
UseConnection :: (ErrorT XmppFailure IO StreamHandle) -> ConnectionDetails

-- | Configuration settings related to the stream.
data StreamConfiguration
StreamConfiguration :: !(Maybe LangTag) -> !(Maybe (Jid, Bool)) -> ConnectionDetails -> ResolvConf -> Bool -> TlsBehaviour -> ClientParams -> StreamConfiguration

-- | Default language when no language tag is set
preferredLang :: StreamConfiguration -> !(Maybe LangTag)

-- | JID to include in the stream element's <tt>to</tt> attribute when the
--   connection is secured; if the boolean is set to <a>True</a>, then the
--   JID is also included when the <a>ConnectionState</a> is <a>Plain</a>
toJid :: StreamConfiguration -> !(Maybe (Jid, Bool))

-- | By settings this field, clients can specify the network interface to
--   use, override the SRV lookup of the realm, as well as specify the use
--   of a non-standard port when connecting by IP or connecting to a domain
--   without SRV records.
connectionDetails :: StreamConfiguration -> ConnectionDetails

-- | DNS resolver configuration
resolvConf :: StreamConfiguration -> ResolvConf

-- | Whether or not to perform the legacy session bind as defined in the
--   (outdated) RFC 3921 specification
establishSession :: StreamConfiguration -> Bool

-- | How the client should behave in regards to TLS.
tlsBehaviour :: StreamConfiguration -> TlsBehaviour

-- | Settings to be used for TLS negotitation
tlsParams :: StreamConfiguration -> ClientParams

-- | Default parameters for TLS
xmppDefaultParams :: ClientParams

-- | Default parameters for TLS restricted to strong ciphers
xmppDefaultParamsStrong :: ClientParams

-- | A JID is XMPP's native format for addressing entities in the network.
--   It is somewhat similar to an e-mail address but contains three parts
--   instead of two: localpart, domainpart, and resourcepart.
--   
--   The <tt>localpart</tt> of a JID is an optional identifier placed
--   before the domainpart and separated from the latter by a '@'
--   character. Typically a localpart uniquely identifies the entity
--   requesting and using network access provided by a server (i.e., a
--   local account), although it can also represent other kinds of entities
--   (e.g., a chat room associated with a multi-user chat service). The
--   entity represented by an XMPP localpart is addressed within the
--   context of a specific domain (i.e., <tt>localpart@domainpart</tt>).
--   
--   The domainpart typically identifies the <i>home</i> server to which
--   clients connect for XML routing and data management functionality.
--   However, it is not necessary for an XMPP domainpart to identify an
--   entity that provides core XMPP server functionality (e.g., a
--   domainpart can identify an entity such as a multi-user chat service, a
--   publish-subscribe service, or a user directory).
--   
--   The resourcepart of a JID is an optional identifier placed after the
--   domainpart and separated from the latter by the '/' character. A
--   resourcepart can modify either a <tt>localpart@domainpart</tt> address
--   or a mere <tt>domainpart</tt> address. Typically a resourcepart
--   uniquely identifies a specific connection (e.g., a device or location)
--   or object (e.g., an occupant in a multi-user chat room) belonging to
--   the entity associated with an XMPP localpart at a domain (i.e.,
--   <tt>localpart@domainpart/resourcepart</tt>).
--   
--   For more details see RFC 6122 <a>http://xmpp.org/rfcs/rfc6122.html</a>
data Jid
Jid :: !(Maybe NonemptyText) -> !NonemptyText -> !(Maybe NonemptyText) -> Jid
localpart_ :: Jid -> !(Maybe NonemptyText)
domainpart_ :: Jid -> !NonemptyText
resourcepart_ :: Jid -> !(Maybe NonemptyText)

-- | Synonym for <a>jid</a>
jidQ :: QuasiQuoter

-- | Constructs and validates a <tt>Jid</tt> at compile time.
--   
--   Syntax: <tt> [jid|localpart@domainpart/resourcepart|] </tt>
--   
--   <pre>
--   &gt;&gt;&gt; [jid|foo@bar/quux|]
--   parseJid "foo@bar/quux"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just [jid|foo@bar/quux|] == jidFromTexts (Just "foo") "bar" (Just "quux")
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just [jid|foo@bar/quux|] == jidFromText "foo@bar/quux"
--   True
--   </pre>
--   
--   See also <a>jidFromText</a>
jid :: QuasiQuoter

-- | Returns <a>True</a> if the JID is <i>bare</i>, that is, it doesn't
--   have a resource part, and <a>False</a> otherwise.
--   
--   <pre>
--   &gt;&gt;&gt; isBare [jid|foo@bar|]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBare [jid|foo@bar/quux|]
--   False
--   </pre>
isBare :: Jid -> Bool

-- | Returns <a>True</a> if the JID is <i>full</i>, and <a>False</a>
--   otherwise.
--   
--   <pre>
--   isFull = not . isBare
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBare [jid|foo@bar|]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBare [jid|foo@bar/quux|]
--   False
--   </pre>
isFull :: Jid -> Bool

-- | Parse a JID
--   
--   <pre>
--   &gt;&gt;&gt; localpart &lt;$&gt; jidFromText "foo@bar/quux"
--   Just (Just "foo")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; domainpart &lt;$&gt; jidFromText "foo@bar/quux"
--   Just "bar"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; resourcepart &lt;$&gt; jidFromText "foo@bar/quux"
--   Just (Just "quux")
--   </pre>
--   
--   <ul>
--   <li>Counterexamples</li>
--   </ul>
--   
--   A JID must only have one '@':
--   
--   <pre>
--   &gt;&gt;&gt; jidFromText "foo@bar@quux"
--   Nothing
--   </pre>
--   
--   '@' must come before '/':
--   
--   <pre>
--   &gt;&gt;&gt; jidFromText "foo/bar@quux"
--   Nothing
--   </pre>
--   
--   The domain part can't be empty:
--   
--   <pre>
--   &gt;&gt;&gt; jidFromText "foo@/quux"
--   Nothing
--   </pre>
--   
--   Both the local part and the resource part can be omitted (but the '@'
--   and '/', must also be removed):
--   
--   <pre>
--   &gt;&gt;&gt; jidToTexts &lt;$&gt; jidFromText "bar"
--   Just (Nothing,"bar",Nothing)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; jidToTexts &lt;$&gt; jidFromText "@bar"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; jidToTexts &lt;$&gt; jidFromText "bar/"
--   Nothing
--   </pre>
jidFromText :: Text -> Maybe Jid

-- | Convert localpart, domainpart, and resourcepart to a JID. Runs the
--   appropriate stringprep profiles and validates the parts.
--   
--   <pre>
--   &gt;&gt;&gt; jidFromTexts (Just "foo") "bar" (Just "baz") == jidFromText "foo@bar/baz"
--   True
--   </pre>
--   
--   <pre>
--   jidFromTexts (localpart j) (domainpart j) (resourcepart j) == Just j
--   </pre>
jidFromTexts :: Maybe Text -> Text -> Maybe Text -> Maybe Jid

-- | The partial order of "definiteness". JID1 is less than or equal JID2
--   iff the domain parts are equal and JID1's local part and resource part
--   each are either Nothing or equal to Jid2's
(<~) :: Jid -> Jid -> Bool

-- | The <tt>nodeprep</tt> StringPrep profile.
nodeprepProfile :: StringPrepProfile

-- | The <tt>resourceprep</tt> StringPrep profile.
resourceprepProfile :: StringPrepProfile

-- | Converts a JID to a Text.
jidToText :: Jid -> Text

-- | Converts a JID to up to three Text values: (the optional) localpart,
--   the domainpart, and (the optional) resourcepart.
--   
--   <pre>
--   &gt;&gt;&gt; jidToTexts [jid|foo@bar/quux|]
--   (Just "foo","bar",Just "quux")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; jidToTexts [jid|bar/quux|]
--   (Nothing,"bar",Just "quux")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; jidToTexts [jid|foo@bar|]
--   (Just "foo","bar",Nothing)
--   </pre>
--   
--   <pre>
--   jidToTexts j == (localpart j, domainpart j, resourcepart j)
--   </pre>
jidToTexts :: Jid -> (Maybe Text, Text, Maybe Text)

-- | Returns the <tt>Jid</tt> without the resourcepart (if any).
--   
--   <pre>
--   &gt;&gt;&gt; toBare [jid|foo@bar/quux|] == [jid|foo@bar|]
--   True
--   </pre>
toBare :: Jid -> Jid

-- | Returns the localpart of the <tt>Jid</tt> (if any).
--   
--   <pre>
--   &gt;&gt;&gt; localpart [jid|foo@bar/quux|]
--   Just "foo"
--   </pre>
localpart :: Jid -> Maybe Text

-- | Returns the domainpart of the <tt>Jid</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; domainpart [jid|foo@bar/quux|]
--   "bar"
--   </pre>
domainpart :: Jid -> Text

-- | Returns the resourcepart of the <tt>Jid</tt> (if any).
--   
--   <pre>
--   &gt;&gt;&gt; resourcepart [jid|foo@bar/quux|]
--   Just "quux"
--   </pre>
resourcepart :: Jid -> Maybe Text

-- | Parses a JID string.
--   
--   Note: This function is only meant to be used to reverse <tt>Jid</tt>
--   Show operations; it will produce an <a>undefined</a> value if the JID
--   does not validate; please refer to <tt>jidFromText</tt> for a safe
--   equivalent.
parseJid :: String -> Jid

-- | How the client should behave in regards to TLS.
data TlsBehaviour

-- | Require the use of TLS; disconnect if it's not offered.
RequireTls :: TlsBehaviour

-- | Negotitate TLS if it's available.
PreferTls :: TlsBehaviour

-- | Negotitate TLS only if the server requires it
PreferPlain :: TlsBehaviour

-- | Never secure the stream with TLS.
RefuseTls :: TlsBehaviour

-- | Signals a SASL authentication error condition.
data AuthFailure

-- | No mechanism offered by the server was matched by the provided
--   acceptable mechanisms; wraps the mechanisms offered by the server
AuthNoAcceptableMechanism :: [Text] -> AuthFailure
AuthStreamFailure :: XmppFailure -> AuthFailure

-- | A SASL failure element was encountered
AuthSaslFailure :: SaslFailure -> AuthFailure

-- | The credentials provided did not conform to the SASLprep Stringprep
--   profile
AuthIllegalCredentials :: AuthFailure

-- | Other failure; more information is available in the log
AuthOtherFailure :: AuthFailure
openElementToEvents :: Element -> [Event]
renderOpenElement :: Element -> ByteString
renderElement :: Element -> ByteString

-- | Validates the hostname string in accordance with RFC 1123.
checkHostName :: Text -> Maybe Text

-- | Apply f with the content of tv as state, restoring the original value
--   when an exception occurs
withTMVar :: TMVar a -> (a -> IO (c, a)) -> IO c


-- | The Extensible Messaging and Presence Protocol (XMPP) is an open
--   technology for near-real-time communication, which powers a wide range
--   of applications including instant messaging, presence, multi-party
--   chat, voice and video calls, collaboration, lightweight middleware,
--   content syndication, and generalized routing of XML data. XMPP
--   provides a technology for the asynchronous, end-to-end exchange of
--   structured data by means of direct, persistent XML streams among a
--   distributed network of globally addressable, presence-aware clients
--   and servers.
--   
--   Pontarius XMPP is an XMPP client library, implementing the core
--   capabilities of XMPP (RFC 6120): setup and tear-down of XML streams,
--   channel encryption, authentication, error handling, and communication
--   primitives for messaging.
--   
--   For low-level access to Pontarius XMPP, see the
--   <a>Network.Xmpp.Internal</a> module.
--   
--   Getting Started
--   
--   We use <a>session</a> to create a session object and connect to a
--   server. Here we use the default <a>SessionConfiguration</a>.
--   
--   <pre>
--   sess &lt;- session realm (simpleAuth "myUsername" "mypassword") def
--   </pre>
--   
--   Defining <a>AuthData</a> can be a bit unwieldy, so <a>simpleAuth</a>
--   gives us a reasonable default. Though, for improved security, we
--   should consider restricting the mechanisms to <a>scramSha1</a>
--   whenever we can.
--   
--   Next we have to set the presence to online, otherwise we won't be able
--   to send or receive stanzas to/from other entities.
--   
--   <pre>
--   sendPresence presenceOnline sess
--   </pre>
module Network.Xmpp

-- | The Session object represents a single session with an XMPP server.
--   You can use <tt>session</tt> to establish a session
data Session

-- | Creates a <a>Session</a> object by setting up a connection with an
--   XMPP server.
--   
--   Will connect to the specified host with the provided configuration. If
--   the third parameter is a <a>Just</a> value, <tt>session</tt> will
--   attempt to authenticate and acquire an XMPP resource.
session :: HostName -> AuthData -> SessionConfiguration -> IO (Either XmppFailure Session)

-- | Changes the handler to be executed when the server connection is
--   closed. To avoid race conditions the initial value should be set in
--   the configuration when creating the session
setConnectionClosedHandler :: (XmppFailure -> Session -> IO ()) -> Session -> IO ()

-- | Reconnect with the stored settings.
--   
--   Waits a random amount of seconds (between 0 and 60 inclusive) before
--   the first attempt and an increasing amount after each attempt after
--   that. Caps out at 2-5 minutes.
--   
--   This function does not set your presence to online, so you will have
--   to do this yourself.
reconnect :: Integer -> Session -> IO (Bool, [XmppFailure])

-- | Reconnect with the stored settings with an unlimited number of
--   retries.
--   
--   Waits a random amount of seconds (between 0 and 60 inclusive) before
--   the first attempt and an increasing amount after each attempt after
--   that. Caps out at 2-5 minutes.
--   
--   This function does not set your presence to online, so you will have
--   to do this yourself.
reconnect' :: Session -> IO Integer

-- | Reconnect immediately with the stored settings. Returns <tt>Just</tt>
--   the error when the reconnect attempt fails and Nothing when no failure
--   was encountered.
--   
--   This function does not set your presence to online, so you will have
--   to do this yourself.
reconnectNow :: Session -> IO (Maybe XmppFailure)

-- | Configuration settings related to the stream.
data StreamConfiguration
StreamConfiguration :: !(Maybe LangTag) -> !(Maybe (Jid, Bool)) -> ConnectionDetails -> ResolvConf -> Bool -> TlsBehaviour -> ClientParams -> StreamConfiguration

-- | Default language when no language tag is set
preferredLang :: StreamConfiguration -> !(Maybe LangTag)

-- | JID to include in the stream element's <tt>to</tt> attribute when the
--   connection is secured; if the boolean is set to <a>True</a>, then the
--   JID is also included when the <a>ConnectionState</a> is <a>Plain</a>
toJid :: StreamConfiguration -> !(Maybe (Jid, Bool))

-- | By settings this field, clients can specify the network interface to
--   use, override the SRV lookup of the realm, as well as specify the use
--   of a non-standard port when connecting by IP or connecting to a domain
--   without SRV records.
connectionDetails :: StreamConfiguration -> ConnectionDetails

-- | DNS resolver configuration
resolvConf :: StreamConfiguration -> ResolvConf

-- | Whether or not to perform the legacy session bind as defined in the
--   (outdated) RFC 3921 specification
establishSession :: StreamConfiguration -> Bool

-- | How the client should behave in regards to TLS.
tlsBehaviour :: StreamConfiguration -> TlsBehaviour

-- | Settings to be used for TLS negotitation
tlsParams :: StreamConfiguration -> ClientParams

-- | Configuration for the <tt>Session</tt> object.
data SessionConfiguration
SessionConfiguration :: StreamConfiguration -> (Session -> XmppFailure -> IO ()) -> IO (IO Text) -> [Plugin] -> Bool -> Bool -> Maybe (Jid -> PeerStatus -> PeerStatus -> IO ()) -> Maybe Int -> SessionConfiguration

-- | Configuration for the <tt>Stream</tt> object.
sessionStreamConfiguration :: SessionConfiguration -> StreamConfiguration

-- | Handler to be run when the conection to the XMPP server is closed. See
--   also <tt>reconnect</tt> and 'reconnect\'' for easy reconnection. The
--   default does nothing
onConnectionClosed :: SessionConfiguration -> Session -> XmppFailure -> IO ()

-- | Function to generate new stanza identifiers.
sessionStanzaIDs :: SessionConfiguration -> IO (IO Text)

-- | Plugins can modify incoming and outgoing stanzas, for example to en-
--   and decrypt them, respectively
plugins :: SessionConfiguration -> [Plugin]

-- | Enable roster handling according to rfc 6121. See <tt>getRoster</tt>
--   to acquire the current roster
enableRoster :: SessionConfiguration -> Bool

-- | Track incomming presence stancas.
enablePresenceTracking :: SessionConfiguration -> Bool

-- | Callback that is invoked when the presence status of a peer changes,
--   i.e. it comes online, goes offline or its IM presence changes. The
--   arguments are the (full) JID of the peer, the old state and the new
--   state. The function is called in a new thread to avoid blocking
--   handling stanzas
onPresenceChange :: SessionConfiguration -> Maybe (Jid -> PeerStatus -> PeerStatus -> IO ())

-- | How often to send keep-alives <a>Nothing</a> disables keep-alive
keepAlive :: SessionConfiguration -> Maybe Int

-- | Specify the method with which the connection is (re-)established
data ConnectionDetails

-- | Use realm to resolv host. This is the default.
UseRealm :: ConnectionDetails

-- | Use this hostname for a SRV lookup
UseSrv :: HostName -> ConnectionDetails

-- | Use specified host
UseHost :: HostName -> PortID -> ConnectionDetails

-- | Use a custom method to create a StreamHandle. This will also be used
--   by reconnect. For example, to establish TLS before starting the stream
--   as done by GCM, see <tt>connectTls</tt>. You can also return an
--   already established connection. This method should also return a
--   hostname that is used for TLS signature verification. If startTLS is
--   not used it can be left empty
UseConnection :: (ErrorT XmppFailure IO StreamHandle) -> ConnectionDetails

-- | Signals the state of the stream connection.
data ConnectionState

-- | Stream has not been established yet
Closed :: ConnectionState

-- | Stream established, but not secured via TLS
Plain :: ConnectionState

-- | Stream established and secured via TLS
Secured :: ConnectionState

-- | Stream was closed
Finished :: ConnectionState

-- | Close the connection to the server. Closes the stream (by enforcing a
--   write lock and sending a &lt;/stream:stream&gt; element), waits
--   (blocks) for three seconds, and then closes the connection.
closeConnection :: Session -> IO ()

-- | End the current XMPP session. Kills the associated threads and closes
--   the connection.
--   
--   Note that XMPP clients (that have signalled availability) should send
--   "Unavailable" presence prior to disconnecting.
--   
--   The connectionClosedHandler will not be called (to avoid possibly
--   reestablishing the connection).
endSession :: Session -> IO ()

-- | Wait until the connection of the stream is re-established
waitForStream :: Session -> IO ()
streamState :: Session -> STM ConnectionState

-- | Tuple defining the SASL Handler's name, and a SASL mechanism
--   computation. The SASL mechanism is a stateful <tt>Stream</tt>
--   computation, which has the possibility of resulting in an
--   authentication error.
type SaslHandler = (Text, StateT StreamState IO (Either XmppFailure (Maybe AuthFailure)))

-- | SASL handlers and the desired JID resource
--   
--   Nothing to disable authentication
--   
--   The allowed SASL mecahnism can depend on the connection state. For
--   example, <tt>plain</tt> should be avoided unless the connection state
--   is <a>Secured</a>
--   
--   It is recommended to leave the resource up to the server
type AuthData = Maybe (ConnectionState -> [SaslHandler], Maybe Resource)
type Username = Text
type Password = Text
type AuthZID = Text

-- | Authenticate using, in order of preference, <a>scramSha1</a>,
--   <a>digestMd5</a> and finally, if both of those are not support and the
--   stream is <a>Secured</a> with TLS, try <a>plain</a>
--   
--   The resource will be decided by the server
simpleAuth :: Username -> Password -> AuthData
scramSha1 :: Username -> Maybe AuthZID -> Password -> SaslHandler
plain :: Username -> Maybe AuthZID -> Password -> SaslHandler
digestMd5 :: Username -> Maybe AuthZID -> Password -> SaslHandler

-- | A JID is XMPP's native format for addressing entities in the network.
--   It is somewhat similar to an e-mail address but contains three parts
--   instead of two: localpart, domainpart, and resourcepart.
--   
--   The <tt>localpart</tt> of a JID is an optional identifier placed
--   before the domainpart and separated from the latter by a '@'
--   character. Typically a localpart uniquely identifies the entity
--   requesting and using network access provided by a server (i.e., a
--   local account), although it can also represent other kinds of entities
--   (e.g., a chat room associated with a multi-user chat service). The
--   entity represented by an XMPP localpart is addressed within the
--   context of a specific domain (i.e., <tt>localpart@domainpart</tt>).
--   
--   The domainpart typically identifies the <i>home</i> server to which
--   clients connect for XML routing and data management functionality.
--   However, it is not necessary for an XMPP domainpart to identify an
--   entity that provides core XMPP server functionality (e.g., a
--   domainpart can identify an entity such as a multi-user chat service, a
--   publish-subscribe service, or a user directory).
--   
--   The resourcepart of a JID is an optional identifier placed after the
--   domainpart and separated from the latter by the '/' character. A
--   resourcepart can modify either a <tt>localpart@domainpart</tt> address
--   or a mere <tt>domainpart</tt> address. Typically a resourcepart
--   uniquely identifies a specific connection (e.g., a device or location)
--   or object (e.g., an occupant in a multi-user chat room) belonging to
--   the entity associated with an XMPP localpart at a domain (i.e.,
--   <tt>localpart@domainpart/resourcepart</tt>).
--   
--   For more details see RFC 6122 <a>http://xmpp.org/rfcs/rfc6122.html</a>
data Jid

-- | Constructs and validates a <tt>Jid</tt> at compile time.
--   
--   Syntax: <tt> [jid|localpart@domainpart/resourcepart|] </tt>
--   
--   <pre>
--   &gt;&gt;&gt; [jid|foo@bar/quux|]
--   parseJid "foo@bar/quux"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just [jid|foo@bar/quux|] == jidFromTexts (Just "foo") "bar" (Just "quux")
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Just [jid|foo@bar/quux|] == jidFromText "foo@bar/quux"
--   True
--   </pre>
--   
--   See also <a>jidFromText</a>
jid :: QuasiQuoter

-- | Synonym for <a>jid</a>
jidQ :: QuasiQuoter

-- | Returns <a>True</a> if the JID is <i>bare</i>, that is, it doesn't
--   have a resource part, and <a>False</a> otherwise.
--   
--   <pre>
--   &gt;&gt;&gt; isBare [jid|foo@bar|]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBare [jid|foo@bar/quux|]
--   False
--   </pre>
isBare :: Jid -> Bool

-- | Returns <a>True</a> if the JID is <i>full</i>, and <a>False</a>
--   otherwise.
--   
--   <pre>
--   isFull = not . isBare
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBare [jid|foo@bar|]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; isBare [jid|foo@bar/quux|]
--   False
--   </pre>
isFull :: Jid -> Bool

-- | Parse a JID
--   
--   <pre>
--   &gt;&gt;&gt; localpart &lt;$&gt; jidFromText "foo@bar/quux"
--   Just (Just "foo")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; domainpart &lt;$&gt; jidFromText "foo@bar/quux"
--   Just "bar"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; resourcepart &lt;$&gt; jidFromText "foo@bar/quux"
--   Just (Just "quux")
--   </pre>
--   
--   <ul>
--   <li>Counterexamples</li>
--   </ul>
--   
--   A JID must only have one '@':
--   
--   <pre>
--   &gt;&gt;&gt; jidFromText "foo@bar@quux"
--   Nothing
--   </pre>
--   
--   '@' must come before '/':
--   
--   <pre>
--   &gt;&gt;&gt; jidFromText "foo/bar@quux"
--   Nothing
--   </pre>
--   
--   The domain part can't be empty:
--   
--   <pre>
--   &gt;&gt;&gt; jidFromText "foo@/quux"
--   Nothing
--   </pre>
--   
--   Both the local part and the resource part can be omitted (but the '@'
--   and '/', must also be removed):
--   
--   <pre>
--   &gt;&gt;&gt; jidToTexts &lt;$&gt; jidFromText "bar"
--   Just (Nothing,"bar",Nothing)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; jidToTexts &lt;$&gt; jidFromText "@bar"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; jidToTexts &lt;$&gt; jidFromText "bar/"
--   Nothing
--   </pre>
jidFromText :: Text -> Maybe Jid

-- | Convert localpart, domainpart, and resourcepart to a JID. Runs the
--   appropriate stringprep profiles and validates the parts.
--   
--   <pre>
--   &gt;&gt;&gt; jidFromTexts (Just "foo") "bar" (Just "baz") == jidFromText "foo@bar/baz"
--   True
--   </pre>
--   
--   <pre>
--   jidFromTexts (localpart j) (domainpart j) (resourcepart j) == Just j
--   </pre>
jidFromTexts :: Maybe Text -> Text -> Maybe Text -> Maybe Jid

-- | Converts a JID to a Text.
jidToText :: Jid -> Text

-- | Converts a JID to up to three Text values: (the optional) localpart,
--   the domainpart, and (the optional) resourcepart.
--   
--   <pre>
--   &gt;&gt;&gt; jidToTexts [jid|foo@bar/quux|]
--   (Just "foo","bar",Just "quux")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; jidToTexts [jid|bar/quux|]
--   (Nothing,"bar",Just "quux")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; jidToTexts [jid|foo@bar|]
--   (Just "foo","bar",Nothing)
--   </pre>
--   
--   <pre>
--   jidToTexts j == (localpart j, domainpart j, resourcepart j)
--   </pre>
jidToTexts :: Jid -> (Maybe Text, Text, Maybe Text)

-- | Returns the <tt>Jid</tt> without the resourcepart (if any).
--   
--   <pre>
--   &gt;&gt;&gt; toBare [jid|foo@bar/quux|] == [jid|foo@bar|]
--   True
--   </pre>
toBare :: Jid -> Jid

-- | Returns the localpart of the <tt>Jid</tt> (if any).
--   
--   <pre>
--   &gt;&gt;&gt; localpart [jid|foo@bar/quux|]
--   Just "foo"
--   </pre>
localpart :: Jid -> Maybe Text

-- | Returns the domainpart of the <tt>Jid</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; domainpart [jid|foo@bar/quux|]
--   "bar"
--   </pre>
domainpart :: Jid -> Text

-- | Returns the resourcepart of the <tt>Jid</tt> (if any).
--   
--   <pre>
--   &gt;&gt;&gt; resourcepart [jid|foo@bar/quux|]
--   Just "quux"
--   </pre>
resourcepart :: Jid -> Maybe Text

-- | Parses a JID string.
--   
--   Note: This function is only meant to be used to reverse <tt>Jid</tt>
--   Show operations; it will produce an <a>undefined</a> value if the JID
--   does not validate; please refer to <tt>jidFromText</tt> for a safe
--   equivalent.
parseJid :: String -> Jid

-- | Return the JID assigned to us by the server
getJid :: Session -> IO (Maybe Jid)

-- | Get the next incoming stanza
getStanza :: Session -> IO (Stanza, [Annotation])

-- | Get the channel of incoming stanzas.
getStanzaChan :: Session -> TChan (Stanza, [Annotation])

-- | Generates a new stanza identifier based on the <a>sessionStanzaIDs</a>
--   field of <a>SessionConfiguration</a>.
newStanzaID :: Session -> IO Text

-- | The message stanza. Used for <i>push</i> type communication.
data Message
Message :: !(Maybe Text) -> !(Maybe Jid) -> !(Maybe Jid) -> !(Maybe LangTag) -> !MessageType -> ![Element] -> ![ExtendedAttribute] -> Message
messageID :: Message -> !(Maybe Text)
messageFrom :: Message -> !(Maybe Jid)
messageTo :: Message -> !(Maybe Jid)
messageLangTag :: Message -> !(Maybe LangTag)
messageType :: Message -> !MessageType
messagePayload :: Message -> ![Element]
messageAttributes :: Message -> ![ExtendedAttribute]

-- | An empty message
--   
--   <pre>
--   message = Message { messageID      = Nothing
--                     , messageFrom    = Nothing
--                     , messageTo      = Nothing
--                     , messageLangTag = Nothing
--                     , messageType    = Normal
--                     , messagePayload = []
--                     }
--   </pre>
message :: Message

-- | An error stanza generated in response to a <a>Message</a>.
data MessageError
MessageError :: !(Maybe Text) -> !(Maybe Jid) -> !(Maybe Jid) -> !(Maybe LangTag) -> !StanzaError -> ![Element] -> ![ExtendedAttribute] -> MessageError
messageErrorID :: MessageError -> !(Maybe Text)
messageErrorFrom :: MessageError -> !(Maybe Jid)
messageErrorTo :: MessageError -> !(Maybe Jid)
messageErrorLangTag :: MessageError -> !(Maybe LangTag)
messageErrorStanzaError :: MessageError -> !StanzaError
messageErrorPayload :: MessageError -> ![Element]
messageErrorAttributes :: MessageError -> ![ExtendedAttribute]

-- | The type of a Message being sent
--   (<a>http://xmpp.org/rfcs/rfc6121.html#message-syntax-type</a>)
data MessageType

-- | The message is sent in the context of a one-to-one chat session.
--   Typically an interactive client will present a message of type
--   <i>chat</i> in an interface that enables one-to-one chat between the
--   two parties, including an appropriate conversation history.
Chat :: MessageType

-- | The message is sent in the context of a multi-user chat environment
--   (similar to that of <tt>IRC</tt>). Typically a receiving client will
--   present a message of type <i>groupchat</i> in an interface that
--   enables many-to-many chat between the parties, including a roster of
--   parties in the chatroom and an appropriate conversation history.
GroupChat :: MessageType

-- | The message provides an alert, a notification, or other transient
--   information to which no reply is expected (e.g., news headlines,
--   sports updates, near-real-time market data, or syndicated content).
--   Because no reply to the message is expected, typically a receiving
--   client will present a message of type <i>headline</i> in an interface
--   that appropriately differentiates the message from standalone
--   messages, chat messages, and groupchat messages (e.g., by not
--   providing the recipient with the ability to reply).
Headline :: MessageType

-- | The message is a standalone message that is sent outside the context
--   of a one-to-one conversation or groupchat, and to which it is expected
--   that the recipient will reply. Typically a receiving client will
--   present a message of type <i>normal</i> in an interface that enables
--   the recipient to reply, but without a conversation history.
--   
--   This is the <i>default</i> value.
Normal :: MessageType

-- | Produce an answer message with the given payload, setting "from" to
--   the "to" attributes in the original message. Produces a <a>Nothing</a>
--   value of the provided message message has no "from" attribute. Sets
--   the "from" attribute to <a>Nothing</a> to let the server assign one.
answerMessage :: Message -> [Element] -> Maybe Message

-- | Send a message stanza. Returns <tt>False</tt> when the <a>Message</a>
--   could not be sent.
sendMessage :: Message -> Session -> IO (Either XmppFailure ())

-- | Draw and discard stanzas from the inbound channel until a message or
--   message error is found. Returns the message or message error.
pullMessage :: Session -> IO (Either MessageError Message)

-- | Draw and discard stanzas from the inbound channel until a message is
--   found. Returns the message.
getMessage :: Session -> IO Message

-- | Draw and discard stanzas from the inbound channel until a message is
--   found. Returns the message with annotations.
getMessageA :: Session -> IO (Annotated Message)

-- | Draw and discard stanzas from the inbound channel until a message
--   matching the given predicate is found. Returns the matching message.
waitForMessage :: (Message -> Bool) -> Session -> IO Message

-- | Draw and discard stanzas from the inbound channel until a message
--   matching the given predicate is found. Returns the matching message
--   with annotations.
waitForMessageA :: (Annotated Message -> Bool) -> Session -> IO (Annotated Message)

-- | Draw and discard stanzas from the inbound channel until a message
--   error matching the given predicate is found. Returns the matching
--   message error
waitForMessageError :: (MessageError -> Bool) -> Session -> IO MessageError

-- | Draw and discard stanzas from the inbound channel until a message
--   error matching the given predicate is found. Returns the matching
--   message error with annotations.
waitForMessageErrorA :: (Annotated MessageError -> Bool) -> Session -> IO (Annotated MessageError)

-- | Draw and discard stanzas from the inbound channel until a message or
--   message error matching the given respective predicate is found.
--   Returns the matching message or message error.
filterMessages :: (MessageError -> Bool) -> (Message -> Bool) -> Session -> IO (Either MessageError Message)

-- | Draw and discard stanzas from the inbound channel until a message or
--   message error matching the given respective predicate is found.
--   Returns the matching message or message error with annotations
filterMessagesA :: (Annotated MessageError -> Bool) -> (Annotated Message -> Bool) -> Session -> IO (Either (Annotated MessageError) (Annotated Message))

-- | The presence stanza. Used for communicating status updates.
data Presence
Presence :: !(Maybe Text) -> !(Maybe Jid) -> !(Maybe Jid) -> !(Maybe LangTag) -> !PresenceType -> ![Element] -> ![ExtendedAttribute] -> Presence
presenceID :: Presence -> !(Maybe Text)
presenceFrom :: Presence -> !(Maybe Jid)
presenceTo :: Presence -> !(Maybe Jid)
presenceLangTag :: Presence -> !(Maybe LangTag)
presenceType :: Presence -> !PresenceType
presencePayload :: Presence -> ![Element]
presenceAttributes :: Presence -> ![ExtendedAttribute]

-- | <tt>PresenceType</tt> holds Xmpp presence types. The "error" message
--   type is left out as errors are using <tt>PresenceError</tt>.
data PresenceType

-- | Sender wants to subscribe to presence
Subscribe :: PresenceType

-- | Sender has approved the subscription
Subscribed :: PresenceType

-- | Sender is unsubscribing from presence
Unsubscribe :: PresenceType

-- | Sender has denied or cancelled a subscription
Unsubscribed :: PresenceType

-- | Sender requests current presence; should only be used by servers
Probe :: PresenceType

-- | Sender wants to express availability (no type attribute is defined)
Available :: PresenceType
Unavailable :: PresenceType

-- | An error stanza generated in response to a <a>Presence</a>.
data PresenceError
PresenceError :: !(Maybe Text) -> !(Maybe Jid) -> !(Maybe Jid) -> !(Maybe LangTag) -> !StanzaError -> ![Element] -> ![ExtendedAttribute] -> PresenceError
presenceErrorID :: PresenceError -> !(Maybe Text)
presenceErrorFrom :: PresenceError -> !(Maybe Jid)
presenceErrorTo :: PresenceError -> !(Maybe Jid)
presenceErrorLangTag :: PresenceError -> !(Maybe LangTag)
presenceErrorStanzaError :: PresenceError -> !StanzaError
presenceErrorPayload :: PresenceError -> ![Element]
presenceErrorAttributes :: PresenceError -> ![ExtendedAttribute]

-- | An empty presence.
presence :: Presence

-- | Signal to the server that the client is no longer available for
--   communication.
presenceOffline :: Presence

-- | Signal to the server that the client is available for communication.
presenceOnline :: Presence

-- | Request subscription with an entity.
presenceSubscribe :: Jid -> Presence

-- | Approve a subscripton of an entity.
presenceSubscribed :: Jid -> Presence

-- | End a subscription with an entity.
presenceUnsubscribe :: Jid -> Presence

-- | Deny a not-yet approved or terminate a previously approved
--   subscription of an entity
presenceUnsubscribed :: Jid -> Presence

-- | Add a recipient to a presence notification.
presTo :: Presence -> Jid -> Presence

-- | Send a presence stanza.
sendPresence :: Presence -> Session -> IO (Either XmppFailure ())

-- | Read a presence stanza from the inbound stanza channel, discards any
--   other stanzas. Returns the presence stanza.
pullPresence :: Session -> IO (Either PresenceError Presence)

-- | Draw and discard stanzas from the inbound channel until a presence
--   stanza matching the given predicate is found. Return the presence
--   stanza with annotations.
waitForPresence :: (Presence -> Bool) -> Session -> IO Presence

-- | A "request" Info/Query (IQ) stanza is one with either "get" or "set"
--   as type. It always contains an xml payload.
data IQRequest
IQRequest :: !Text -> !(Maybe Jid) -> !(Maybe Jid) -> !(Maybe LangTag) -> !IQRequestType -> !Element -> ![ExtendedAttribute] -> IQRequest
iqRequestID :: IQRequest -> !Text
iqRequestFrom :: IQRequest -> !(Maybe Jid)
iqRequestTo :: IQRequest -> !(Maybe Jid)
iqRequestLangTag :: IQRequest -> !(Maybe LangTag)
iqRequestType :: IQRequest -> !IQRequestType
iqRequestPayload :: IQRequest -> !Element
iqRequestAttributes :: IQRequest -> ![ExtendedAttribute]

-- | A received and wrapped up IQ request. Prevents you from (illegally)
--   answering a single IQ request multiple times
data IQRequestTicket

-- | The actual IQ request that created this ticket.
iqRequestBody :: IQRequestTicket -> IQRequest

-- | The type of IQ request that is made.
data IQRequestType
Get :: IQRequestType
Set :: IQRequestType

-- | The (non-error) answer to an IQ request.
data IQResult
IQResult :: !Text -> !(Maybe Jid) -> !(Maybe Jid) -> !(Maybe LangTag) -> !(Maybe Element) -> ![ExtendedAttribute] -> IQResult
iqResultID :: IQResult -> !Text
iqResultFrom :: IQResult -> !(Maybe Jid)
iqResultTo :: IQResult -> !(Maybe Jid)
iqResultLangTag :: IQResult -> !(Maybe LangTag)
iqResultPayload :: IQResult -> !(Maybe Element)
iqResultAttributes :: IQResult -> ![ExtendedAttribute]

-- | The answer to an IQ request that generated an error.
data IQError
IQError :: !Text -> !(Maybe Jid) -> !(Maybe Jid) -> !(Maybe LangTag) -> !StanzaError -> !(Maybe Element) -> ![ExtendedAttribute] -> IQError
iqErrorID :: IQError -> !Text
iqErrorFrom :: IQError -> !(Maybe Jid)
iqErrorTo :: IQError -> !(Maybe Jid)
iqErrorLangTag :: IQError -> !(Maybe LangTag)
iqErrorStanzaError :: IQError -> !StanzaError
iqErrorPayload :: IQError -> !(Maybe Element)
iqErrorAttributes :: IQError -> ![ExtendedAttribute]

-- | A "response" Info/Query (IQ) stanza is either an <a>IQError</a>, an IQ
--   stanza of type "result" (<a>IQResult</a>)
data IQResponse
IQResponseError :: IQError -> IQResponse
IQResponseResult :: IQResult -> IQResponse
class IQRequestClass a where data family IQResponseType a
pickleRequest :: IQRequestClass a => PU Element a
pickleResponse :: IQRequestClass a => PU [Element] (IQResponseType a)
requestType :: IQRequestClass a => a -> IQRequestType
requestNamespace :: IQRequestClass a => a -> Text
type IQRequestHandler a = a -> IO (Either StanzaError (IQResponseType a))

-- | Sends an IQ, returns an STM action that returns the first inbound IQ
--   with a matching ID that has type <tt>result</tt> or <tt>error</tt> or
--   Nothing if the timeout was reached.
--   
--   When sending the action fails, an XmppFailure is returned.
sendIQ :: Maybe Integer -> Maybe Jid -> IQRequestType -> Maybe LangTag -> Element -> [ExtendedAttribute] -> Session -> IO (Either XmppFailure (STM (Maybe (Annotated IQResponse))))

-- | Like <a>sendIQ</a>, but waits for the answer IQ. Discards plugin
--   Annotations
sendIQ' :: Maybe Integer -> Maybe Jid -> IQRequestType -> Maybe LangTag -> Element -> [ExtendedAttribute] -> Session -> IO (Either IQSendError IQResponse)

-- | Send an IQ request. May throw IQSendError, UnpickleError,
sendIQRequest :: (IQRequestClass a, MonadError IQRequestError m, MonadIO m) => Maybe Integer -> Maybe Jid -> a -> Session -> m (Either IQError (IQResponseType a))

-- | Answer an IQ request. Only the first answer ist sent and Just True is
--   returned when the answer is sucessfully sent. If an error occured
--   during sending Just False is returned (and another attempt can be
--   undertaken). Subsequent answers after the first sucessful one are
--   dropped and (False is returned in that case)
answerIQ :: IQRequestTicket -> Either StanzaError (Maybe Element) -> [ExtendedAttribute] -> IO (Maybe (Either XmppFailure ()))

-- | Create an IQ Result matching an IQ request
iqResult :: Maybe Element -> IQRequest -> IQResult

-- | Register your interest in inbound IQ stanzas of a specific type and
--   namespace. The returned STM action yields the received, matching IQ
--   stanzas.
--   
--   If a handler for IQ stanzas with the given type and namespace is
--   already registered, the producer will be wrapped in Left. In this case
--   the returned request tickets may already be processed elsewhere.
listenIQ :: IQRequestType -> Text -> Session -> IO (Either (STM IQRequestTicket) (STM IQRequestTicket))
runIQHandler :: IQRequestClass a => IQRequestHandler a -> Session -> IO ()

-- | Unregister a previously registered IQ handler. No more IQ stanzas will
--   be delivered to any of the returned producers.
unlistenIQ :: IQRequestType -> Text -> Session -> IO ()

-- | <tt>StanzaError</tt>s always have one of these types.
data StanzaErrorType

-- | Error is unrecoverable - do not retry
Cancel :: StanzaErrorType

-- | Conditition was a warning - proceed
Continue :: StanzaErrorType

-- | Change the data and retry
Modify :: StanzaErrorType

-- | Provide credentials and retry
Auth :: StanzaErrorType

-- | Error is temporary - wait and retry
Wait :: StanzaErrorType

-- | All stanzas (IQ, message, presence) can cause errors, which in the
--   Xmpp stream looks like <tt>&lt;stanza-kind to='sender'
--   type='error'&gt;</tt> . These errors are wrapped in the
--   <tt>StanzaError</tt> type. TODO: Sender XML is (optional and is) not
--   yet included.
data StanzaError
StanzaError :: StanzaErrorType -> StanzaErrorCondition -> Maybe (Maybe LangTag, NonemptyText) -> Maybe Element -> StanzaError
stanzaErrorType :: StanzaError -> StanzaErrorType
stanzaErrorCondition :: StanzaError -> StanzaErrorCondition
stanzaErrorText :: StanzaError -> Maybe (Maybe LangTag, NonemptyText)
stanzaErrorApplicationSpecificCondition :: StanzaError -> Maybe Element

-- | The RECOMMENDED error type associated with an error condition. The
--   following conditions allow for multiple types
--   
--   <ul>
--   <li><a>FeatureNotImplemented</a>: <a>Cancel</a> or <a>Modify</a>
--   (returns <a>Cancel</a>)</li>
--   <li><a>PolicyViolation</a>: <a>Modify</a> or <a>Wait</a>
--   (<a>Modify</a>)</li>
--   <li><a>RemoteServerTimeout</a>: <a>Wait</a> or unspecified other
--   (<a>Wait</a>)</li>
--   <li><a>UndefinedCondition</a>: Any condition (<a>Cancel</a>)</li>
--   </ul>
associatedErrorType :: StanzaErrorCondition -> StanzaErrorType

-- | Create a StanzaError with <tt>condition</tt> and the
--   <a>associatedErrorType</a>. Leave the error text and the application
--   specific condition empty
mkStanzaError :: StanzaErrorCondition -> StanzaError

-- | Stanza errors are accommodated with one of the error conditions listed
--   below.
data StanzaErrorCondition

-- | Malformed XML.
BadRequest :: StanzaErrorCondition

-- | Resource or session with name already exists.
Conflict :: StanzaErrorCondition
FeatureNotImplemented :: StanzaErrorCondition

-- | Insufficient permissions.
Forbidden :: StanzaErrorCondition

-- | Entity can no longer be contacted at this address.
Gone :: (Maybe NonemptyText) -> StanzaErrorCondition
InternalServerError :: StanzaErrorCondition
ItemNotFound :: StanzaErrorCondition
JidMalformed :: StanzaErrorCondition

-- | Does not meet policy criteria.
NotAcceptable :: StanzaErrorCondition

-- | No entity may perform this action.
NotAllowed :: StanzaErrorCondition

-- | Must provide proper credentials.
NotAuthorized :: StanzaErrorCondition

-- | The entity has violated some local service policy (e.g., a message
--   contains words that are prohibited by the service)
PolicyViolation :: StanzaErrorCondition

-- | Temporarily unavailable.
RecipientUnavailable :: StanzaErrorCondition

-- | Redirecting to other entity, usually temporarily.
Redirect :: (Maybe NonemptyText) -> StanzaErrorCondition
RegistrationRequired :: StanzaErrorCondition
RemoteServerNotFound :: StanzaErrorCondition
RemoteServerTimeout :: StanzaErrorCondition

-- | Entity lacks the necessary system resources.
ResourceConstraint :: StanzaErrorCondition
ServiceUnavailable :: StanzaErrorCondition
SubscriptionRequired :: StanzaErrorCondition

-- | Application-specific condition.
UndefinedCondition :: StanzaErrorCondition

-- | Badly timed request.
UnexpectedRequest :: StanzaErrorCondition
data SaslFailure
SaslFailure :: SaslError -> Maybe (Maybe LangTag, Text) -> SaslFailure
saslFailureCondition :: SaslFailure -> SaslError
saslFailureText :: SaslFailure -> Maybe (Maybe LangTag, Text)

-- | Error that can occur during sendIQ'
data IQSendError
IQSendError :: XmppFailure -> IQSendError
IQTimeOut :: IQSendError
data IQRequestError
IQRequestSendError :: XmppFailure -> IQRequestError
IQRequestTimeout :: IQRequestError
IQRequestUnpickleError :: UnpickleError -> IQRequestError

-- | Duplicate the inbound channel of the session object. Most receiving
--   functions discard stanzas they are not interested in from the inbound
--   channel. Duplicating the channel ensures that those stanzas can aren't
--   lost and can still be handled somewhere else.
dupSession :: Session -> IO Session
type Annotated a = (a, [Annotation])

-- | Annotations are auxiliary data attached to received stanzas by
--   <a>Plugin</a>s to convey information regarding their operation. For
--   example, a plugin for encryption might attach information about
--   whether a received stanza was encrypted and which algorithm was used.
data Annotation
Annotation :: f -> Annotation
fromAnnotation :: Annotation -> f
type Plugin = (Stanza -> IO (Either XmppFailure ())) -> ErrorT XmppFailure IO Plugin'
data Plugin'
Plugin' :: (Stanza -> [Annotation] -> IO [(Stanza, [Annotation])]) -> (Stanza -> IO (Either XmppFailure ())) -> (Session -> IO ()) -> Plugin'

-- | Resulting stanzas and additional Annotations
inHandler :: Plugin' -> Stanza -> [Annotation] -> IO [(Stanza, [Annotation])]
outHandler :: Plugin' -> Stanza -> IO (Either XmppFailure ())

-- | In order to allow plugins to tie the knot (Plugin / Session) we pass
--   the plugin the completed Session once it exists
onSessionUp :: Plugin' -> Session -> IO ()

-- | The language tag in accordance with RFC 5646 (in the form of "en-US").
--   It has a primary tag and a number of subtags. Two language tags are
--   considered equal if and only if they contain the same tags
--   (case-insensitive).
data LangTag

-- | Parses, validates, and possibly constructs a <a>LangTag</a> object.
langTagFromText :: Text -> Maybe LangTag
langTagToText :: LangTag -> Text
parseLangTag :: String -> LangTag

-- | Signals an XMPP stream error or another unpredicted stream-related
--   situation. This error is fatal, and closes the XMPP stream.
data XmppFailure

-- | An error XML stream element has been encountered.
StreamErrorFailure :: StreamErrorInfo -> XmppFailure

-- | The stream has been closed. This exception is caught by the concurrent
--   implementation, and will thus not be visible through use of
--   <tt>Session</tt>.
StreamEndFailure :: XmppFailure

-- | When an XmppFailure is encountered in closeStreams, this constructor
--   wraps the elements collected so far.
StreamCloseError :: ([Element], XmppFailure) -> XmppFailure

-- | All attempts to TCP connect to the server failed.
TcpConnectionFailure :: XmppFailure

-- | The TCP details provided did not validate.
XmppIllegalTcpDetails :: XmppFailure

-- | An error occurred in the TLS layer
TlsError :: XmppTlsError -> XmppFailure

-- | The server does not support the use of TLS
TlsNoServerSupport :: XmppFailure

-- | An action that required an active stream were performed when the
--   <a>StreamState</a> was <a>Closed</a>
XmppNoStream :: XmppFailure

-- | Authentication with the server failed (unrecoverably)
XmppAuthFailure :: AuthFailure -> XmppFailure

-- | Connection already secured
TlsStreamSecured :: XmppFailure

-- | Undefined condition. More information should be available in the log.
XmppOtherFailure :: XmppFailure

-- | An <a>IOException</a> occurred
XmppIOException :: IOException -> XmppFailure

-- | Received data is not valid XML
XmppInvalidXml :: String -> XmppFailure

-- | Encapsulates information about an XMPP stream error.
data StreamErrorInfo
StreamErrorInfo :: !StreamErrorCondition -> !(Maybe (Maybe LangTag, NonemptyText)) -> !(Maybe Element) -> StreamErrorInfo
errorCondition :: StreamErrorInfo -> !StreamErrorCondition
errorText :: StreamErrorInfo -> !(Maybe (Maybe LangTag, NonemptyText))
errorXml :: StreamErrorInfo -> !(Maybe Element)
data StreamErrorCondition

-- | The entity has sent XML that cannot be processed.
StreamBadFormat :: StreamErrorCondition

-- | The entity has sent a namespace prefix that is unsupported, or has
--   sent no namespace prefix on an element that needs such a prefix
StreamBadNamespacePrefix :: StreamErrorCondition

-- | The server either (1) is closing the existing stream for this entity
--   because a new stream has been initiated that conflicts with the
--   existing stream, or (2) is refusing a new stream for this entity
--   because allowing the new stream would conflict with an existing stream
--   (e.g., because the server allows only a certain number of connections
--   from the same IP address or allows only one server-to-server stream
--   for a given domain pair as a way of helping to ensure in-order
--   processing
StreamConflict :: StreamErrorCondition

-- | One party is closing the stream because it has reason to believe that
--   the other party has permanently lost the ability to communicate over
--   the stream.
StreamConnectionTimeout :: StreamErrorCondition

-- | The value of the <tt>to</tt> attribute provided in the initial stream
--   header corresponds to an FQDN that is no longer serviced by the
--   receiving entity
StreamHostGone :: StreamErrorCondition

-- | The value of the <tt>to</tt> attribute provided in the initial stream
--   header does not correspond to an FQDN that is serviced by the
--   receiving entity.
StreamHostUnknown :: StreamErrorCondition

-- | A stanza sent between two servers lacks a <tt>to</tt> or <tt>from</tt>
--   attribute, the <tt>from</tt> or <tt>to</tt> attribute has no value, or
--   the value violates the rules for XMPP addresses
StreamImproperAddressing :: StreamErrorCondition

-- | The server has experienced a misconfiguration or other internal error
--   that prevents it from servicing the stream.
StreamInternalServerError :: StreamErrorCondition

-- | The data provided in a <tt>from</tt> attribute does not match an
--   authorized JID or validated domain as negotiated (1) between two
--   servers using SASL or Server Dialback, or (2) between a client and a
--   server via SASL authentication and resource binding.
StreamInvalidFrom :: StreamErrorCondition

-- | The stream namespace name is something other than
--   "http:/<i>etherx.jabber.org</i>streams" (see Section 11.2) or the
--   content namespace declared as the default namespace is not supported
--   (e.g., something other than "jabber:client" or "jabber:server").
StreamInvalidNamespace :: StreamErrorCondition

-- | The entity has sent invalid XML over the stream to a server that
--   performs validation
StreamInvalidXml :: StreamErrorCondition

-- | The entity has attempted to send XML stanzas or other outbound data
--   before the stream has been authenticated, or otherwise is not
--   authorized to perform an action related to stream negotiation; the
--   receiving entity MUST NOT process the offending data before sending
--   the stream error.
StreamNotAuthorized :: StreamErrorCondition

-- | The initiating entity has sent XML that violates the well-formedness
--   rules of [XML] or [XML‑NAMES].
StreamNotWellFormed :: StreamErrorCondition

-- | The entity has violated some local service policy (e.g., a stanza
--   exceeds a configured size limit); the server MAY choose to specify the
--   policy in the &lt;text/&gt; element or in an application-specific
--   condition element.
StreamPolicyViolation :: StreamErrorCondition

-- | The server is unable to properly connect to a remote entity that is
--   needed for authentication or authorization (e.g., in certain scenarios
--   related to Server Dialback [XEP‑0220]); this condition is not to be
--   used when the cause of the error is within the administrative domain
--   of the XMPP service provider, in which case the
--   &lt;internal-server-error /&gt; condition is more appropriate.
StreamRemoteConnectionFailed :: StreamErrorCondition

-- | The server is closing the stream because it has new (typically
--   security-critical) features to offer, because the keys or certificates
--   used to establish a secure context for the stream have expired or have
--   been revoked during the life of the stream , because the TLS sequence
--   number has wrapped, etc. The reset applies to the stream and to any
--   security context established for that stream (e.g., via TLS and SASL),
--   which means that encryption and authentication need to be negotiated
--   again for the new stream (e.g., TLS session resumption cannot be used)
StreamReset :: StreamErrorCondition

-- | The server lacks the system resources necessary to service the stream.
StreamResourceConstraint :: StreamErrorCondition

-- | he entity has attempted to send restricted XML features such as a
--   comment, processing instruction, DTD subset, or XML entity reference
StreamRestrictedXml :: StreamErrorCondition

-- | The server will not provide service to the initiating entity but is
--   redirecting traffic to another host under the administrative control
--   of the same service provider.
StreamSeeOtherHost :: StreamErrorCondition

-- | The server is being shut down and all active streams are being closed.
StreamSystemShutdown :: StreamErrorCondition

-- | The error condition is not one of those defined by the other
--   conditions in this list
StreamUndefinedCondition :: StreamErrorCondition

-- | The initiating entity has encoded the stream in an encoding that is
--   not supported by the server or has otherwise improperly encoded the
--   stream (e.g., by violating the rules of the [UTF‑8] encoding).
StreamUnsupportedEncoding :: StreamErrorCondition

-- | The receiving entity has advertised a mandatory-to-negotiate stream
--   feature that the initiating entity does not support, and has offered
--   no other mandatory-to-negotiate feature alongside the unsupported
--   feature.
StreamUnsupportedFeature :: StreamErrorCondition

-- | The initiating entity has sent a first-level child of the stream that
--   is not supported by the server, either because the receiving entity
--   does not understand the namespace or because the receiving entity does
--   not understand the element name for the applicable namespace (which
--   might be the content namespace declared as the default namespace)
StreamUnsupportedStanzaType :: StreamErrorCondition

-- | The <tt>version</tt> attribute provided by the initiating entity in
--   the stream header specifies a version of XMPP that is not supported by
--   the server.
StreamUnsupportedVersion :: StreamErrorCondition

-- | Signals a SASL authentication error condition.
data AuthFailure

-- | No mechanism offered by the server was matched by the provided
--   acceptable mechanisms; wraps the mechanisms offered by the server
AuthNoAcceptableMechanism :: [Text] -> AuthFailure

-- | A SASL failure element was encountered
AuthSaslFailure :: SaslFailure -> AuthFailure

-- | The credentials provided did not conform to the SASLprep Stringprep
--   profile
AuthIllegalCredentials :: AuthFailure

-- | Other failure; more information is available in the log
AuthOtherFailure :: AuthFailure

-- | Connect to an XMPP server and secure the connection with TLS before
--   starting the XMPP streams
--   
--   <i>NB</i> RFC 6120 does not specify this method, but some servers,
--   notably GCS, seem to use it.
connectTls :: ResolvConf -> ClientParams -> String -> ErrorT XmppFailure IO StreamHandle

-- | The default value for this type.
def :: Default a => a
