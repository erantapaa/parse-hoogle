-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Crit-bit maps and sets
--   
--   This package implements crit-bit trees, a key-value container type for
--   storing keys that can be treated as bitstrings (e.g. <a>ByteString</a>
--   and <a>Text</a>).
--   
--   Compared to the data structures from the containers and
--   unordered-containers packages, you will find that sometimes the
--   functions implemented in this package are faster, sometimes slower.
--   
--   In many cases, a <a>CritBit</a> tree provides performance close to
--   that of a <a>HashMap</a>, while providing ordered storage and
--   traversal like a <a>Map</a>.
@package critbit
@version 0.2.0.0


-- | A set type that uses crit-bit trees internally.
--   
--   For every <i>n</i> key-value pairs stored, a crit-bit tree uses
--   <i>n</i>-1 internal nodes, for a total of 2<i>n</i>-1 internal nodes
--   and leaves.
module Data.CritBit.Set

-- | A set based on crit-bit trees.
data Set a

-- | Same as <a>difference</a>.
(\\) :: CritBitKey a => Set a -> Set a -> Set a

-- | <i>O(1)</i>. Is the set empty?
--   
--   <pre>
--   null (empty)         == True
--   null (singleton "a") == False
--   </pre>
null :: Set a -> Bool

-- | <i>O(n)</i>. The number of elements in the set.
--   
--   <pre>
--   size empty                      == 0
--   size (singleton "a")            == 1
--   size (fromList ["a", "c", "b"]) == 3
--   </pre>
size :: Set a -> Int

-- | <i>O(k)</i>. Is the element in the set?
--   
--   <pre>
--   member "a" (fromList ["a", "b"]) == True
--   member "c" (fromList ["a", "b"]) == False
--   </pre>
--   
--   See also <a>notMember</a>.
member :: CritBitKey a => a -> Set a -> Bool

-- | <i>O(k)</i>. Is the element not in the set?
--   
--   <pre>
--   notMember "a" (fromList ["a", "b"]) == False
--   notMember "c" (fromList ["a", "b"]) == True
--   </pre>
--   
--   See also <a>member</a>.
notMember :: CritBitKey a => a -> Set a -> Bool

-- | <i>O(k)</i>. Find largest element smaller than the given one.
--   
--   <pre>
--   lookupLT "b"  (fromList ["a", "b"]) == Just "a"
--   lookupLT "aa" (fromList ["a", "b"]) == Just "a"
--   lookupLT "a"  (fromList ["a", "b"]) == Nothing
--   </pre>
lookupLT :: CritBitKey a => a -> Set a -> Maybe a

-- | <i>O(k)</i>. Find smallest element greater than the given one.
--   
--   <pre>
--   lookupGT "b"  (fromList ["a", "b"]) == Nothing
--   lookupGT "aa" (fromList ["a", "b"]) == Just "b"
--   lookupGT "a"  (fromList ["a", "b"]) == Just "b"
--   </pre>
lookupGT :: CritBitKey a => a -> Set a -> Maybe a

-- | <i>O(k)</i>. Find largest element smaller than or equal to the given
--   one.
--   
--   <pre>
--   lookupGE "b"  (fromList ["a", "b"]) == Just "b"
--   lookupGE "aa" (fromList ["a", "b"]) == Just "b"
--   lookupGE "a"  (fromList ["a", "b"]) == Just "a"
--   lookupGE ""   (fromList ["a", "b"]) == Nothing
--   </pre>
lookupLE :: CritBitKey a => a -> Set a -> Maybe a

-- | <i>O(k)</i>. Find smallest element greater than or equal to the given
--   one.
--   
--   <pre>
--   lookupGE "aa" (fromList ["a", "b"]) == Just "b"
--   lookupGE "b"  (fromList ["a", "b"]) == Just "b"
--   lookupGE "bb" (fromList ["a", "b"]) == Nothing
--   </pre>
lookupGE :: CritBitKey a => a -> Set a -> Maybe a

-- | <i>O(n+m)</i>. Is this a subset? <tt>(s1 <a>isSubsetOf</a> s2)</tt>
--   tells whether <tt>s1</tt> is a subset of <tt>s2</tt>.
isSubsetOf :: CritBitKey a => Set a -> Set a -> Bool

-- | <i>O(n+m)</i>. Is this a proper subset (ie. a subset but not equal)?
--   <tt>(s1 <a>isSubsetOf</a> s2)</tt> tells whether <tt>s1</tt> is a
--   proper subset of <tt>s2</tt>.
isProperSubsetOf :: CritBitKey a => Set a -> Set a -> Bool

-- | <i>O(1)</i>. The empty set.
--   
--   <pre>
--   empty      == fromList []
--   size empty == 0
--   </pre>
empty :: Set a

-- | <i>O(1)</i>. A set with a single element.
--   
--   <pre>
--   singleton "a"        == fromList ["a"]
--   </pre>
singleton :: a -> Set a

-- | <i>O(k)</i>. Insert an element in a set. If the set already contains
--   an element equal to the given value, it is replaced with the new
--   value.
insert :: CritBitKey a => a -> Set a -> Set a

-- | <i>O(k)</i>. Delete an element from a set.
delete :: CritBitKey a => a -> Set a -> Set a

-- | <i>O(k)</i>. The union of two sets, preferring the first set when
--   equal elements are encountered.
union :: CritBitKey a => Set a -> Set a -> Set a

-- | The union of a list of sets: (<tt><a>unions</a> == <a>foldl</a>
--   <a>union</a> <a>empty</a></tt>).
unions :: CritBitKey a => [Set a] -> Set a

-- | <i>O(k)</i>. The difference of two sets.
difference :: CritBitKey a => Set a -> Set a -> Set a

-- | <i>O(k)</i>. The intersection of two sets. Elements of the result come
--   from the first set.
intersection :: CritBitKey a => Set a -> Set a -> Set a

-- | <i>O(n)</i>. Filter all elements that satisfy the predicate.
--   
--   <pre>
--   filter (&gt; "a") (fromList ["a", "b"]) == fromList [("3","b")]
--   filter (&gt; "x") (fromList ["a", "b"]) == empty
--   filter (&lt; "a") (fromList ["a", "b"]) == empty
--   </pre>
filter :: (a -> Bool) -> Set a -> Set a

-- | <i>O(n)</i>. Partition the set into two sets, one with all elements
--   that satisfy the predicate and one with all elements that don't
--   satisfy the predicate. See also <a>split</a>.
partition :: CritBitKey a => (a -> Bool) -> Set a -> (Set a, Set a)

-- | <i>O(k)</i>. The expression (<tt><a>split</a> x set</tt>) is a pair
--   <tt>(set1,set2)</tt> where <tt>set1</tt> comprises the elements of
--   <tt>set</tt> less than <tt>x</tt> and <tt>set2</tt> comprises the
--   elements of <tt>set</tt> greater than <tt>x</tt>.
--   
--   <pre>
--   split "a" (fromList ["b", "d"]) == (empty, fromList ["b", "d")])
--   split "b" (fromList ["b", "d"]) == (empty, singleton "d")
--   split "c" (fromList ["b", "d"]) == (singleton "b", singleton "d")
--   split "d" (fromList ["b", "d"]) == (singleton "b", empty)
--   split "e" (fromList ["b", "d"]) == (fromList ["b", "d"], empty)
--   </pre>
split :: CritBitKey a => a -> Set a -> (Set a, Set a)

-- | <i>O(k)</i>. Performs a <a>split</a> but also returns whether the
--   pivot element was found in the original set.
--   
--   <pre>
--   splitMember "a" (fromList ["b", "d"]) == (empty, False, fromList ["b", "d"])
--   splitMember "b" (fromList ["b", "d"]) == (empty, True, singleton "d")
--   splitMember "c" (fromList ["b", "d"]) == (singleton "b", False, singleton "d")
--   splitMember "d" (fromList ["b", "d"]) == (singleton "b", True, empty)
--   splitMember "e" (fromList ["b", "d"]) == (fromList ["b", "d"], False, empty)
--   </pre>
splitMember :: CritBitKey a => a -> Set a -> (Set a, Bool, Set a)

-- | <i>O(k)</i>. <tt><a>map</a> f s</tt> is the set obtained by applying
--   <tt>f</tt> to each element of <tt>s</tt>.
--   
--   It's worth noting that the size of the result may be smaller if, for
--   some <tt>(x,y)</tt>, <tt>x /= y &amp;&amp; f x == f y</tt>
map :: CritBitKey a2 => (a1 -> a2) -> Set a1 -> Set a2

-- | <i>O(n)</i>. The <tt><a>mapMonotonic</a> f s == <a>map</a> f s</tt>,
--   but works only when <tt>f</tt> is monotonic. <i>The precondition is
--   not checked.</i> Semi-formally, we have:
--   
--   <pre>
--   and [x &lt; y ==&gt; f x &lt; f y | x &lt;- ls, y &lt;- ls]
--                       ==&gt; mapMonotonic f s == map f s
--       where ls = toList s
--   </pre>
mapMonotonic :: CritBitKey a2 => (a1 -> a2) -> Set a1 -> Set a2

-- | <i>O(n)</i>. Fold the elements in the set using the given
--   right-associative binary operator, such that <tt><a>foldr</a> f z ==
--   <a>foldr</a> f z . <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   toAscList set = foldr (:) [] set
--   </pre>
foldr :: (a -> b -> b) -> b -> Set a -> b

-- | <i>O(n)</i>. Fold the elements in the set using the given
--   left-associative binary operator, such that <tt><a>foldl</a> f z ==
--   <a>foldl</a> f z . <a>toAscList</a></tt>.
--   
--   For example,
--   
--   <pre>
--   toDescList set = foldl (flip (:)) [] set
--   </pre>
foldl :: (a -> b -> a) -> a -> Set b -> a

-- | <i>O(n)</i>. A strict version of <a>foldr</a>. Each application of the
--   operator is evaluated before using the result in the next application.
--   This function is strict in the starting value.
foldr' :: (a -> b -> b) -> b -> Set a -> b

-- | <i>O(n)</i>. A strict version of <a>foldl</a>. Each application of the
--   operator is evaluated before using the result in the next application.
--   This function is strict in the starting value.
foldl' :: (a -> b -> a) -> a -> Set b -> a

-- | <i>O(k')</i>. The minimal element of a set.
findMin :: Set a -> a

-- | <i>O(k)</i>. The maximal element of a set.
findMax :: Set a -> a

-- | <i>O(k')</i>. Delete the minimal element. Returns an empty set if the
--   set is empty.
deleteMin :: Set a -> Set a

-- | <i>O(k)</i>. Delete the maximal element. Returns an empty set if the
--   set is empty.
deleteMax :: Set a -> Set a

-- | <i>O(k')</i>. Delete and find the minimal element.
--   
--   <pre>
--   deleteFindMin set = (findMin set, deleteMin set)
--   </pre>
deleteFindMin :: Set a -> (a, Set a)

-- | <i>O(k)</i>. Delete and find the maximal element.
--   
--   <pre>
--   deleteFindMax set = (findMax set, deleteMax set)
--   </pre>
deleteFindMax :: Set a -> (a, Set a)

-- | <i>O(k)</i>. Retrieves the maximal key of the set, and the set
--   stripped of that element, or <a>Nothing</a> if passed an empty set.
maxView :: Set a -> Maybe (a, Set a)

-- | <i>O(k')</i>. Retrieves the minimal key of the set, and the set
--   stripped of that element, or <a>Nothing</a> if passed an empty set.
minView :: Set a -> Maybe (a, Set a)

-- | <i>O(n)</i>. An alias of <a>toList</a>.
--   
--   Returns the elements of a set in ascending order.
elems :: Set a -> [a]

-- | <i>O(n)</i>. Convert the set to a list of values. The list returned
--   will be sorted in lexicographically ascending order.
--   
--   <pre>
--   toList (fromList ["b", "a"]) == ["a", "b"]
--   toList empty == []
--   </pre>
toList :: Set a -> [a]

-- | <i>O(k)</i>. Build a set from a list of values.
--   
--   <pre>
--   fromList [] == empty
--   fromList ["a", "b", "a"] == fromList ["a", "b"]
--   </pre>
fromList :: CritBitKey a => [a] -> Set a

-- | <i>O(n)</i>. Convert the set to an ascending list of elements.
toAscList :: Set a -> [a]

-- | <i>O(n)</i>. Convert the set to a descending list of elements.
toDescList :: Set a -> [a]

-- | <i>O(n)</i>. Build a set from an ascending list in linear time. <i>The
--   precondition (input list is ascending) is not checked.</i>
fromAscList :: CritBitKey a => [a] -> Set a

-- | <i>O(n)</i>. Build a set from an ascending list in linear time. <i>The
--   precondition (input list is ascending) is not checked.</i>
fromDistinctAscList :: CritBitKey a => [a] -> Set a
instance Foldable Set
instance CritBitKey k => Monoid (Set k)
instance Show a => Show (Set a)


-- | A crit-bit tree that does not evaluate its values by default.
--   
--   For every <i>n</i> key-value pairs stored, a crit-bit tree uses
--   <i>n</i>-1 internal nodes, for a total of 2<i>n</i>-1 internal nodes
--   and leaves.
module Data.CritBit.Map.Lazy

-- | A type that can be used as a key in a crit-bit tree.
--   
--   We use 9 bits to represent 8-bit bytes so that we can distinguish
--   between an interior byte that is zero (which must have the 9th bit
--   set) and a byte past the end of the input (which must <i>not</i> have
--   the 9th bit set).
--   
--   Without this trick, the critical bit calculations would fail on zero
--   bytes <i>within</i> a string, and our tree would be unable to handle
--   arbitrary binary data.
class Eq k => CritBitKey k
byteCount :: CritBitKey k => k -> Int
getByte :: CritBitKey k => k -> Int -> Word16

-- | A crit-bit tree.
data CritBit k v

-- | <i>O(k)</i>. Find the value at a key. Calls <a>error</a> when the
--   element can not be found.
--   
--   <pre>
--   fromList [("a",5), ("b",3)] ! "c"    Error: element not in the map
--   fromList [("a",5), ("b",3)] ! "a" == 5
--   </pre>
(!) :: CritBitKey k => CritBit k v -> k -> v

-- | Same as <a>difference</a>.
(\\) :: CritBitKey k => CritBit k v -> CritBit k w -> CritBit k v

-- | <i>O(1)</i>. Is the map empty?
--   
--   <pre>
--   null (empty)           == True
--   null (singleton 1 'a') == False
--   </pre>
null :: CritBit k v -> Bool

-- | <i>O(n)</i>. The number of elements in the map.
--   
--   <pre>
--   size empty                                  == 0
--   size (singleton "a" 1)                      == 1
--   size (fromList [("a",1), ("c",2), ("b",3)]) == 3
--   </pre>
size :: CritBit k v -> Int

-- | <i>O(k)</i>. Is the key a member of the map?
--   
--   <pre>
--   member "a" (fromList [("a",5), ("b",3)]) == True
--   member "c" (fromList [("a",5), ("b",3)]) == False
--   </pre>
--   
--   See also <a>notMember</a>.
member :: CritBitKey k => k -> CritBit k v -> Bool

-- | <i>O(k)</i>. Is the key not a member of the map?
--   
--   <pre>
--   notMember "a" (fromList [("a",5), ("b",3)]) == False
--   notMember "c" (fromList [("a",5), ("b",3)]) == True
--   </pre>
--   
--   See also <a>member</a>.
notMember :: CritBitKey k => k -> CritBit k v -> Bool

-- | <i>O(k)</i>. Lookup the value at a key in the map.
--   
--   The function will return the corresponding value as <tt>(<a>Just</a>
--   value)</tt>, or <a>Nothing</a> if the key isn't in the map.
--   
--   An example of using <tt>lookup</tt>:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   import Data.Text
--   import Prelude hiding (lookup)
--   import Data.CritBit.Map.Lazy
--   
--   employeeDept, deptCountry, countryCurrency :: CritBit Text Text
--   employeeDept = fromList [("John","Sales"), ("Bob","IT")]
--   deptCountry = fromList [("IT","USA"), ("Sales","France")]
--   countryCurrency = fromList [("USA", "Dollar"), ("France", "Euro")]
--   
--   employeeCurrency :: Text -&gt; Maybe Text
--   employeeCurrency name = do
--     dept &lt;- lookup name employeeDept
--     country &lt;- lookup dept deptCountry
--     lookup country countryCurrency
--   
--   main = do
--     putStrLn $ "John's currency: " ++ show (employeeCurrency "John")
--     putStrLn $ "Pete's currency: " ++ show (employeeCurrency "Pete")
--   </pre>
--   
--   The output of this program:
--   
--   <pre>
--   John's currency: Just "Euro"
--   Pete's currency: Nothing
--   </pre>
lookup :: CritBitKey k => k -> CritBit k v -> Maybe v

-- | <i>O(k)</i>. Returns the value associated with the given key, or the
--   given default value if the key is not in the map.
--   
--   <pre>
--   findWithDefault 1 "x" (fromList [("a",5), ("b",3)]) == 1
--   findWithDefault 1 "a" (fromList [("a",5), ("b",3)]) == 5
--   </pre>
findWithDefault :: CritBitKey k => v -> k -> CritBit k v -> v

-- | <i>O(k)</i>. Find smallest key greater than the given one and return
--   the corresponding (key, value) pair.
--   
--   <pre>
--   lookupGT "aa" (fromList [("a",3), ("b",5)]) == Just ("b",5)
--   lookupGT "b"  (fromList [("a",3), ("b",5)]) == Nothing
--   </pre>
lookupGT :: CritBitKey k => k -> CritBit k v -> Maybe (k, v)

-- | <i>O(k)</i>. Find smallest key greater than or equal to the given one
--   and return the corresponding (key, value) pair.
--   
--   <pre>
--   lookupGE "aa" (fromList [("a",3), ("b",5)]) == Just("b",5)
--   lookupGE "b"  (fromList [("a",3), ("b",5)]) == Just("b",5)
--   lookupGE "bb" (fromList [("a",3), ("b",5)]) == Nothing
--   </pre>
lookupGE :: CritBitKey k => k -> CritBit k v -> Maybe (k, v)

-- | <i>O(k)</i>. Find largest key smaller than the given one and return
--   the corresponding (key, value) pair.
--   
--   <pre>
--   lookupLT "aa" (fromList [("a",3), ("b",5)]) == Just ("a",3)
--   lookupLT "a"  (fromList [("a",3), ("b",5)]) == Nothing
--   </pre>
lookupLT :: CritBitKey k => k -> CritBit k v -> Maybe (k, v)

-- | <i>O(k)</i>. Find largest key smaller than or equal to the given one
--   and return the corresponding (key, value) pair.
--   
--   <pre>
--   lookupGE "bb" (fromList [("aa",3), ("b",5)]) == Just("b",5)
--   lookupGE "aa" (fromList [("aa",3), ("b",5)]) == Just("aa",5)
--   lookupGE "a"  (fromList [("aa",3), ("b",5)]) == Nothing
--   </pre>
lookupLE :: CritBitKey k => k -> CritBit k v -> Maybe (k, v)

-- | <i>O(1)</i>. The empty map.
--   
--   <pre>
--   empty      == fromList []
--   size empty == 0
--   </pre>
empty :: CritBit k v

-- | <i>O(1)</i>. A map with a single element.
--   
--   <pre>
--   singleton "a" 1        == fromList [("a",1)]
--   </pre>
singleton :: k -> v -> CritBit k v

-- | <i>O(k)</i>. Insert a new key and value in the map. If the key is
--   already present in the map, the associated value is replaced with the
--   supplied value. <a>insert</a> is equivalent to <tt><a>insertWith</a>
--   <a>const</a></tt>.
--   
--   <pre>
--   insert "b" 7 (fromList [("a",5), ("b",3)]) == fromList [("a",5), ("b",7)]
--   insert "x" 7 (fromList [("a",5), ("b",3)]) == fromList [("a",5), ("b",3), ("x",7)]
--   insert "x" 5 empty                         == singleton "x" 5
--   </pre>
insert :: CritBitKey k => k -> v -> CritBit k v -> CritBit k v

-- | <i>O(k)</i>. Insert with a function, combining new value and old
--   value. <tt><a>insertWith</a> f key value cb</tt> will insert the pair
--   (key, value) into <tt>cb</tt> if key does not exist in the map. If the
--   key does exist, the function will insert the pair <tt>(key, f
--   new_value old_value)</tt>.
--   
--   <pre>
--   insertWith (+) "a" 1 (fromList [("a",5), ("b",3)]) == fromList [("a",6), ("b",3)]
--   insertWith (+) "c" 7 (fromList [("a",5), ("b",3)]) == fromList [("a",5), ("b",3), ("c",7)]
--   insertWith (+) "x" 5 empty                         == singleton "x" 5
--   </pre>
insertWith :: CritBitKey k => (v -> v -> v) -> k -> v -> CritBit k v -> CritBit k v

-- | <i>O(k)</i>. Insert with a function, combining key, new value and old
--   value. <tt><a>insertWithKey</a> f key value cb</tt> will insert the
--   pair (key, value) into cb if key does not exist in the map. If the key
--   does exist, the function will insert the pair <tt>(key,f key new_value
--   old_value)</tt>. Note that the key passed to f is the same key passed
--   to insertWithKey.
--   
--   <pre>
--   let f key new_value old_value = byteCount key + new_value + old_value
--   insertWithKey f "a" 1 (fromList [("a",5), ("b",3)]) == fromList [("a",7), ("b",3)]
--   insertWithKey f "c" 1 (fromList [("a",5), ("b",3)]) == fromList [("a",5), ("b",3), ("c",1)]
--   insertWithKey f "a" 1 empty                         == singleton "a" 1
--   </pre>
insertWithKey :: CritBitKey k => (k -> v -> v -> v) -> k -> v -> CritBit k v -> CritBit k v

-- | <i>O(k)</i>. Combines insert operation with old value retrieval. The
--   expression (<tt><a>insertLookupWithKey</a> f k x map</tt>) is a pair
--   where the first element is equal to (<tt><a>lookup</a> k map</tt>) and
--   the second element equal to (<tt><a>insertWithKey</a> f k x map</tt>).
--   
--   <pre>
--   let f key new_value old_value = length key + old_value + new_value
--   insertLookupWithKey f "a" 2 (fromList [("a",5), ("b",3)]) == (Just 5, fromList [("a",8), ("b",3)])
--   insertLookupWithKey f "c" 2 (fromList [(5,"a"), (3,"b")]) == (Nothing, fromList [("a",5), ("b",3), ("c",2)])
--   insertLookupWithKey f "a" 2 empty                         == (Nothing, singleton "a" 2)
--   </pre>
--   
--   This is how to define <tt>insertLookup</tt> using
--   <tt>insertLookupWithKey</tt>:
--   
--   <pre>
--   let insertLookup kx x t = insertLookupWithKey (\_ a _ -&gt; a) kx x t
--   insertLookup "a" 1 (fromList [("a",5), ("b",3)]) == (Just 5, fromList [("a",1), ("b",3)])
--   insertLookup "c" 1 (fromList [("a",5), ("b",3)]) == (Nothing,  fromList [("a",5), ("b",3), ("c",1)])
--   </pre>
insertLookupWithKey :: CritBitKey k => (k -> v -> v -> v) -> k -> v -> CritBit k v -> (Maybe v, CritBit k v)

-- | <i>O(k)</i>. Delete a key and its value from the map. When the key is
--   not a member of the map, the original map is returned.
--   
--   <pre>
--   delete "a" (fromList [("a",5), ("b",3)]) == singleton "b" 3
--   delete "c" (fromList [("a",5), ("b",3)]) == fromList [("a",5), ("b",3)]
--   delete "a" empty                         == empty
--   </pre>
delete :: CritBitKey k => k -> CritBit k v -> CritBit k v

-- | <i>O(k)</i>. Update a value at a specific key with the result of the
--   provided function. When the key is not a member of the map, the
--   original map is returned.
--   
--   <pre>
--   let f k x = x + 1
--   adjustWithKey f "a" (fromList [("b",3), ("a",5)]) == fromList [("a", 6), ("b",3)]
--   adjustWithKey f "c" (fromList [("a",5), ("b",3)]) == fromList [("a",5), ("b",3)]
--   adjustWithKey f "c" empty                         == empty
--   </pre>
adjust :: CritBitKey k => (v -> v) -> k -> CritBit k v -> CritBit k v

-- | <i>O(k)</i>. Adjust a value at a specific key. When the key is not a
--   member of the map, the original map is returned.
--   
--   <pre>
--   let f k x = x + fromEnum (k &lt; "d")
--   adjustWithKey f "a" (fromList [("b",3), ("a",5)]) == fromList [("a", 6), ("b",3)]
--   adjustWithKey f "c" (fromList [("a",5), ("b",3)]) == fromList [("a",5), ("b",3)]
--   adjustWithKey f "c" empty                         == empty
--   </pre>
adjustWithKey :: CritBitKey k => (k -> v -> v) -> k -> CritBit k v -> CritBit k v

-- | <i>O(k)</i>. The expression (<tt><a>update</a> f k map</tt> updates
--   the value <tt>x</tt> at <tt>k</tt> (if it is in the map). If (<tt>f
--   x</tt>) is <a>Nothing</a>, the element is deleted. If it is
--   (<tt><a>Just</a> y</tt>), the key <tt>k</tt> is bound to the new value
--   <tt>y</tt>.
--   
--   <pre>
--   let f x = if x == 5 then Just 50 else Nothing
--   update f "a" (fromList [("b",3), ("a",5)]) == fromList [("a", 50), ("b",3)]
--   update f "c" (fromList [("b",3), ("a",5)]) == fromList [("a", 50), ("b",3)]
--   update f "b" (fromList [("b",3), ("a",5)]) == singleton "a" 5
--   </pre>
update :: CritBitKey k => (v -> Maybe v) -> k -> CritBit k v -> CritBit k v

-- | <i>O(log n)</i>. The expression (<tt><a>updateWithKey</a> f k
--   map</tt>) updates the value <tt>x</tt> at <tt>k</tt> (if it is in the
--   map). If (<tt>f k x</tt>) is <a>Nothing</a>, the element is deleted.
--   If it is (<tt><a>Just</a> y</tt>), the key <tt>k</tt> is bound to the
--   new value <tt>y</tt>.
--   
--   <pre>
--   let f k x = if x == 5 then Just (x + fromEnum (k &lt; "d")) else Nothing
--   updateWithKey f "a" (fromList [("b",3), ("a",5)]) == fromList [("a", 6), ("b",3)]
--   updateWithKey f "c" (fromList [("a",5), ("b",3)]) == fromList [("a",5), ("b",3)]
--   updateWithKey f "b" (fromList [("a",5), ("b",3)]) == singleton "a" 5
--   </pre>
updateWithKey :: CritBitKey k => (k -> v -> Maybe v) -> k -> CritBit k v -> CritBit k v

-- | <i>O(k)</i>. Lookup and update; see also <tt>updateWithKey</tt>. This
--   function returns the changed value if it is updated, or the original
--   value if the entry is deleted.
--   
--   <pre>
--   let f k x = if x == 5 then Just (x + fromEnum (k &lt; "d")) else Nothing
--   updateLookupWithKey f "a" (fromList [("b",3), ("a",5)]) == (Just 6, fromList [("a", 6), ("b",3)])
--   updateLookupWithKey f "c" (fromList [("a",5), ("b",3)]) == (Nothing, fromList [("a",5), ("b",3)])
--   updateLookupWithKey f "b" (fromList [("a",5), ("b",3)]) == (Just 3, singleton "a" 5)
--   </pre>
updateLookupWithKey :: CritBitKey k => (k -> v -> Maybe v) -> k -> CritBit k v -> (Maybe v, CritBit k v)

-- | <i>O(k)</i>. The expression (<tt><a>alter</a> f k map</tt>) alters the
--   value <tt>x</tt> at <tt>k</tt>, or absence thereof. <a>alter</a> can
--   be used to insert, delete, or update a value in a <a>CritBit</a>. In
--   short : <tt><a>lookup</a> k (<a>alter</a> f k m) = f (<a>lookup</a> k
--   m)</tt>.
--   
--   <pre>
--   let f _ = Nothing
--   alter f "c" (fromList [("a",5), ("b",3)]) == fromList [("a",5), ("b",3)]
--   alter f "a" (fromList [("a",5), ("b",3)]) == fromList [("b",3)]
--   
--   let f _ = Just 1
--   alter f "c" (fromList [("a",5), ("b",3)]) == fromList [("a",5), ("b",3), ("c",1)]
--   alter f "a" (fromList [(5,"a"), (3,"b")]) == fromList [("a",1), ("b",3)]
--   </pre>
alter :: CritBitKey k => (Maybe v -> Maybe v) -> k -> CritBit k v -> CritBit k v

-- | <i>O(n+m)</i>. The expression (<tt><a>union</a> t1 t2</tt>) takes the
--   left-biased union of <tt>t1</tt> and <tt>t2</tt>.
--   
--   It prefers <tt>t1</tt> when duplicate keys are encountered, i.e.
--   (<tt><a>union</a> == <a>unionWith</a> <a>const</a></tt>).
--   
--   <pre>
--   union (fromList [("a", 5), ("b", 3)]) (fromList [("a", 4), ("c", 7)]) == fromList [("a", 5), ("b", "3"), ("c", 7)]
--   </pre>
union :: CritBitKey k => CritBit k v -> CritBit k v -> CritBit k v

-- | Union with a combining function.
--   
--   <pre>
--   let l = fromList [("a", 5), ("b", 3)]
--   let r = fromList [("A", 5), ("b", 7)]
--   unionWith (+) l r == fromList [("A",5),("a",5),("b",10)]
--   </pre>
unionWith :: CritBitKey k => (v -> v -> v) -> CritBit k v -> CritBit k v -> CritBit k v

-- | Union with a combining function.
--   
--   <pre>
--   let f key new_value old_value = byteCount key + new_value + old_value
--   let l = fromList [("a", 5), ("b", 3)]
--   let r = fromList [("A", 5), ("C", 7)]
--   unionWithKey f l r == fromList [("A",5),("C",7),("a",5),("b",3)]
--   </pre>
unionWithKey :: CritBitKey k => (k -> v -> v -> v) -> CritBit k v -> CritBit k v -> CritBit k v

-- | The union of a list of maps: (<tt><a>unions</a> == <a>foldl</a>
--   <a>union</a> <a>empty</a></tt>).
--   
--   <pre>
--   unions [(fromList [("a", 5), ("b", 3)]), (fromList [("a", 6), ("c", 7)]), (fromList [("a", 9), ("b", 5)])]
--       == fromList [("a", 5), ("b", 4), (c, 7)]
--   unions [(fromList [("a", 9), ("b", 8)]), (fromList [("ab", 5), ("c",7)]), (fromList [("a", 5), ("b", 3)])]
--       == fromList [("a", 9), ("ab", 5), ("b", 8), ("c", 7)]
--   </pre>
unions :: CritBitKey k => [CritBit k v] -> CritBit k v

-- | The union of a list of maps, with a combining operation:
--   (<tt><a>unionsWith</a> f == <a>foldl</a> (<a>unionWith</a> f)
--   <a>empty</a></tt>).
--   
--   <pre>
--   unionsWith (+) [(fromList [("a",5), ("b", 3)]), (fromList [("a", 3), ("c", 7)]), (fromList [("a", 5), ("b", 5)])]
--       == fromList [("a", 12), ("b", 8), ("c")]
--   </pre>
unionsWith :: CritBitKey k => (v -> v -> v) -> [CritBit k v] -> CritBit k v
unionL :: CritBitKey k => CritBit k v -> CritBit k v -> CritBit k v
unionR :: CritBitKey k => CritBit k v -> CritBit k v -> CritBit k v

-- | <i>O(n+m)</i>. Difference of two maps. | Return data in the first map
--   not existing in the second map.
--   
--   <pre>
--   let l = fromList [("a", 5), ("b", 3)]
--   let r = fromList [("A", 2), ("b", 7)]
--   difference l r == fromList [("a", 5)]
--   </pre>
difference :: CritBitKey k => CritBit k v -> CritBit k w -> CritBit k v

-- | <i>O(n+m)</i>. Difference with a combining function. | When two equal
--   keys are encountered, the combining function is applied | to the
--   values of theese keys. If it returns <a>Nothing</a>, the element is |
--   discarded (proper set difference). If it returns (<tt><a>Just</a>
--   y</tt>), | the element is updated with a new value <tt>y</tt>.
--   
--   <pre>
--   let f av bv = if av == 3 then Just (av + bv) else Nothing
--   let l = fromList [(pack "a", 5), (pack "b", 3), (pack "c", 8)]
--   let r = fromList [(pack "a", 2), (pack "b", 7), (pack "d", 8)]
--   differenceWith f l r == fromList [(pack "b", 10), (pack "c", 8)]
--   </pre>
differenceWith :: CritBitKey k => (v -> w -> Maybe v) -> CritBit k v -> CritBit k w -> CritBit k v

-- | <i>O(n+m)</i>. Difference with a combining function. | When two equal
--   keys are encountered, the combining function is applied | to the key
--   and both values. If it returns <a>Nothing</a>, the element is |
--   discarded (proper set difference). If it returns (<tt><a>Just</a>
--   y</tt>), | the element is updated with a new value <tt>y</tt>.
--   
--   <pre>
--   let f k av bv = if k == "b" then Just (length k + av + bv) else Nothing
--   let l = fromList [("a", 5), ("b", 3), ("c", 8)]
--   let r = fromList [("a", 2), ("b", 7), ("d", 8)]
--   differenceWithKey f l r == fromList [("b", 11), ("c", 8)]
--   </pre>
differenceWithKey :: CritBitKey k => (k -> v -> w -> Maybe v) -> CritBit k v -> CritBit k w -> CritBit k v

-- | <i>O(n+m)</i>. Intersection of two maps. | Return data in the first
--   map for the keys existing in both maps.
--   
--   <pre>
--   let l = fromList [("a", 5), ("b", 3)]
--   let r = fromList [("A", 2), ("b", 7)]
--   intersection l r == fromList [("b", 3)]
--   </pre>
intersection :: CritBitKey k => CritBit k v -> CritBit k w -> CritBit k v

-- | <i>O(n+m)</i>. Intersection with a combining function.
--   
--   <pre>
--   let l = fromList [("a", 5), ("b", 3)]
--   let r = fromList [("A", 2), ("b", 7)]
--   intersectionWith (+) l r == fromList [("b", 10)]
--   </pre>
intersectionWith :: CritBitKey k => (v -> w -> x) -> CritBit k v -> CritBit k w -> CritBit k x

-- | <i>O(n+m)</i>. Intersection with a combining function.
--   
--   <pre>
--   let f key new_value old_value = length key + new_value + old_value
--   let l = fromList [("a", 5), ("b", 3)]
--   let r = fromList [("A", 2), ("b", 7)]
--   intersectionWithKey f l r == fromList [("b", 11)]
--   </pre>
intersectionWithKey :: CritBitKey k => (k -> v -> w -> x) -> CritBit k v -> CritBit k w -> CritBit k x

-- | <i>O(n)</i>. Apply a function to all values.
--   
--   <pre>
--   map show (fromList [("b",5), ("a",3)]) == fromList [("b","5"), ("a","3")]
--   </pre>
map :: CritBitKey k => (v -> w) -> CritBit k v -> CritBit k w

-- | <i>O(n)</i>. Apply a function to all values.
--   
--   <pre>
--   let f key x = show key ++ ":" ++ show x
--   mapWithKey f (fromList [("a",5), ("b",3)]) == fromList [("a","a:5"), ("b","b:3")]
--   </pre>
mapWithKey :: (k -> v -> w) -> CritBit k v -> CritBit k w

-- | <i>O(n)</i>. <tt><a>traverseWithKey</a> f s == <a>fromList</a>
--   <a>$</a> <a>traverse</a> ((k, v) -&gt; (,) k <a>$</a> f k v)
--   (<a>toList</a> m)</tt>
--   
--   That is, behaves exactly like a regular <a>traverse</a> except that
--   the traversing function also has access to the key associated with a
--   value.
--   
--   <pre>
--   let f key value = show key ++ ":" ++ show value
--   traverseWithKey (\k v -&gt; if odd v then Just (f k v) else Nothing) (fromList [("a",3), ("b",5)]) == Just (fromList [("a","a:3"), ("b","b:5")])
--   traverseWithKey (\k v -&gt; if odd v then Just (f k v) else Nothing) (fromList [("c", 2)])           == Nothing
--   </pre>
traverseWithKey :: (CritBitKey k, Applicative t) => (k -> v -> t w) -> CritBit k v -> t (CritBit k w)

-- | <i>O(n)</i>. The function <a>mapAccum</a> threads an accumulating
--   argument through the map in ascending order of keys.
--   
--   <pre>
--   let f a b = (a ++ show b, show b ++ "X")
--   mapAccum f "Everything: " (fromList [("a",5), ("b",3)]) == ("Everything: 53", fromList [("a","5X"), ("b","3X")])
--   </pre>
mapAccum :: CritBitKey k => (a -> v -> (a, w)) -> a -> CritBit k v -> (a, CritBit k w)

-- | <i>O(n)</i>. The function <a>mapAccumWithKey</a> threads an
--   accumulating argument through the map in ascending order of keys.
--   
--   <pre>
--   let f a k b = (a ++ " " ++ show k ++ "-" ++ show b, show b ++ "X")
--   mapAccumWithKey f "Everything: " (fromList [("a",5), ("b",3)]) == ("Everything: a-5 b-3", fromList [("a","5X"), ("b","3X")])
--   </pre>
mapAccumWithKey :: CritBitKey k => (a -> k -> v -> (a, w)) -> a -> CritBit k v -> (a, CritBit k w)

-- | <i>O(n)</i>. The function <a>mapAccumRWithKey</a> threads an
--   accumulating argument through the map in descending order of keys.
mapAccumRWithKey :: CritBitKey k => (a -> k -> v -> (a, w)) -> a -> CritBit k v -> (a, CritBit k w)

-- | <i>O(k)</i>. <tt>mapKeys f</tt> applies the function <tt>f</tt> to the
--   keys of the map.
--   
--   If <tt>f</tt> maps multiple keys to the same new key, the new key is
--   associated with the value of the greatest of the original keys.
--   
--   <pre>
--   let f = fromString . (++ "1") . show
--   mapKeys f (fromList [("a", 5), ("b", 3)])            == fromList ([("a1", 5), ("b1", 3)])
--   mapKeys (\ _ -&gt; "a") (fromList [("a", 5), ("b", 3)]) == singleton "a" 3
--   </pre>
mapKeys :: CritBitKey k2 => (k1 -> k2) -> CritBit k1 v -> CritBit k2 v

-- | <i>O(k)</i>. <tt><a>mapKeysWith</a> c f s</tt> is the map obtained by
--   applying <tt>f</tt> to each key of <tt>s</tt>.
--   
--   The size of the result may be smaller if <tt>f</tt> maps two or more
--   distinct keys to the same new key. In this case the associated values
--   will be combined using <tt>c</tt>.
--   
--   <pre>
--   mapKeysWith (+) (\ _ -&gt; "a") (fromList [("b",1), ("a",2), ("d",3), ("c",4)]) == singleton "a" 10
--   </pre>
mapKeysWith :: CritBitKey k2 => (v -> v -> v) -> (k1 -> k2) -> CritBit k1 v -> CritBit k2 v

-- | <i>O(k)</i>. <tt><a>mapKeysMonotonic</a> f s == <a>mapKeys</a> f
--   s</tt>, but works only when <tt>f</tt> is strictly monotonic. That is,
--   for any values <tt>x</tt> and <tt>y</tt>, if <tt>x</tt> &lt;
--   <tt>y</tt> then <tt>f x</tt> &lt; <tt>f y</tt>. <i>The precondition is
--   not checked.</i> Semi-formally, we have:
--   
--   <pre>
--   and [x &lt; y ==&gt; f x &lt; f y | x &lt;- ls, y &lt;- ls]
--                       ==&gt; mapKeysMonotonic f s == mapKeys f s
--       where ls = keys s
--   </pre>
--   
--   This means that <tt>f</tt> maps distinct original keys to distinct
--   resulting keys. This function has slightly better performance than
--   <a>mapKeys</a>.
--   
--   <pre>
--   mapKeysMonotonic (\ k -&gt; succ k) (fromList [("a",5), ("b",3)]) == fromList [("b",5), ("c",3)]
--   </pre>
mapKeysMonotonic :: CritBitKey k => (a -> k) -> CritBit a v -> CritBit k v

-- | <i>O(n)</i>. Fold the values in the map using the given
--   left-associative function, such that <tt><a>foldl</a> f z ==
--   <a>foldl</a> f z . <a>elems</a></tt>.
--   
--   Examples:
--   
--   <pre>
--   elems = reverse . foldl (flip (:)) []
--   </pre>
--   
--   <pre>
--   foldl (+) 0 (fromList [("a",5), ("bbb",3)]) == 8
--   </pre>
foldl :: (a -> v -> a) -> a -> CritBit k v -> a

-- | <i>O(n)</i>. Fold the values in the map using the given
--   right-associative function, such that <tt><a>foldr</a> f z ==
--   <a>foldr</a> f z . <a>elems</a></tt>.
--   
--   Example:
--   
--   <pre>
--   elems map = foldr (:) [] map
--   </pre>
foldr :: (v -> a -> a) -> a -> CritBit k v -> a

-- | <i>O(n)</i>. Fold the keys and values in the map using the given
--   left-associative function, such that <tt><a>foldlWithKey</a> f z ==
--   <a>foldl</a> (\z' (kx, x) -&gt; f z' kx x) z .
--   <tt>toAscList</tt></tt>.
--   
--   Examples:
--   
--   <pre>
--   keys = reverse . foldlWithKey (\ks k x -&gt; k:ks) []
--   </pre>
--   
--   <pre>
--   let f result k a = result ++ "(" ++ show k ++ ":" ++ a ++ ")"
--   foldlWithKey f "Map: " (fromList [("a",5), ("b",3)]) == "Map: (b:3)(a:5)"
--   </pre>
foldlWithKey :: (a -> k -> v -> a) -> a -> CritBit k v -> a

-- | <i>O(n)</i>. Fold the keys and values in the map using the given
--   right-associative function, such that <tt><a>foldrWithKey</a> f z ==
--   <a>foldr</a> (<a>uncurry</a> f) z . <tt>toAscList</tt></tt>.
--   
--   Examples:
--   
--   <pre>
--   keys map = foldrWithKey (\k x ks -&gt; k:ks) [] map
--   </pre>
--   
--   <pre>
--   let f k a result = result ++ "(" ++ show k ++ ":" ++ a ++ ")"
--   foldrWithKey f "Map: " (fromList [("a",5), ("b",3)]) == "Map: (a:5)(b:3)"
--   </pre>
foldrWithKey :: (k -> v -> a -> a) -> a -> CritBit k v -> a

-- | <i>O(n)</i>. A strict version of <a>foldl</a>. Each application of the
--   function is evaluated before using the result in the next application.
--   This function is strict in the starting value.
foldl' :: (a -> v -> a) -> a -> CritBit k v -> a

-- | <i>O(n)</i>. A strict version of <a>foldr</a>. Each application of the
--   function is evaluated before using the result in the next application.
--   This function is strict in the starting value.
foldr' :: (v -> a -> a) -> a -> CritBit k v -> a

-- | <i>O(n)</i>. A strict version of <a>foldlWithKey</a>. Each application
--   of the function is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldlWithKey' :: (a -> k -> v -> a) -> a -> CritBit k v -> a

-- | <i>O(n)</i>. A strict version of <a>foldrWithKey</a>. Each application
--   of the function is evaluated before using the result in the next
--   application. This function is strict in the starting value.
foldrWithKey' :: (k -> v -> a -> a) -> a -> CritBit k v -> a

-- | <i>O(n)</i>. Return all the elements of the map in ascending order of
--   their keys.
--   
--   <pre>
--   elems (fromList [("b",5), ("a",3)]) == [3,5]
--   elems empty == []
--   </pre>
elems :: CritBit k v -> [v]

-- | <i>O(n)</i>. Return all keys of the map in ascending order.
--   
--   <pre>
--   keys (fromList [("b",5), ("a",3)]) == ["a","b"]
--   keys empty == []
--   </pre>
keys :: CritBit k v -> [k]

-- | <i>O(n)</i>. An alias for <a>toAscList</a>. Return all key/value pairs
--   in the map in ascending order.
--   
--   <pre>
--   assocs (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
--   assocs empty == []
--   </pre>
assocs :: CritBit k v -> [(k, v)]

-- | <i>O(n)</i>. Return set of all keys of the map.
--   
--   <pre>
--   keysSet (fromList [("b",5), ("a",3)]) == Set.fromList ["a", "b"]
--   keysSet empty == []
--   </pre>
keysSet :: CritBit k v -> Set k

-- | <i>O(n)</i>. Build a map from a set of keys and a function which for
--   each key computes its value.
--   
--   <pre>
--   fromSet (\k -&gt; length k) (Data.IntSet.fromList ["a", "bb"]) == fromList [("a",1), ("bb",2)]
--   fromSet undefined Data.IntSet.empty == empty
--   </pre>
fromSet :: (k -> v) -> Set k -> CritBit k v

-- | <i>O(n)</i>. Convert the map to a list of key/value pairs. The list
--   returned will be sorted in lexicographically ascending order.
--   
--   <pre>
--   toList (fromList [("b",3), ("a",5)]) == [("a",5),("b",3)]
--   toList empty == []
--   </pre>
toList :: CritBit k v -> [(k, v)]

-- | <i>O(k)</i>. Build a map from a list of key/value pairs. If the list
--   contains more than one value for the same key, the last value for the
--   key is retained.
--   
--   <pre>
--   fromList [] == empty
--   fromList [("a",5), ("b",3), ("a",2)] == fromList [("a",2), ("b",3)]
--   </pre>
fromList :: CritBitKey k => [(k, v)] -> CritBit k v

-- | <i>O(k)</i>. Build a map from a list of key/value pairs with a
--   combining function. See also <a>fromAscListWith</a>.
--   
--   <pre>
--   fromListWith (+) [("a",5), ("b",5), ("b",3), ("a",3), ("a",5)] ==
--                          fromList [("a",13), ("b",8)]
--   fromListWith (+) [] == empty
--   </pre>
fromListWith :: CritBitKey k => (v -> v -> v) -> [(k, v)] -> CritBit k v

-- | <i>O(k)</i>. Build a map from a list of key/value pairs with a
--   combining function. See also <a>fromAscListWithKey</a>.
--   
--   <pre>
--   let f key a1 a2 = byteCount key + a1 + a2
--   fromListWithKey f [("a",5), ("b",5), ("b",3), ("a",3), ("a",5)] ==
--                          fromList [("a",16), ("b",10)]
--   fromListWithKey f [] == empty
--   </pre>
fromListWithKey :: CritBitKey k => (k -> v -> v -> v) -> [(k, v)] -> CritBit k v

-- | <i>O(n)</i>. Convert the map to a list of key/value pairs where the
--   keys are in ascending order.
--   
--   <pre>
--   toAscList (fromList [(5,"a"), (3,"b")]) == [(3,"b"), (5,"a")]
--   </pre>
toAscList :: CritBit k v -> [(k, v)]

-- | <i>O(n)</i>. Convert the map to a list of key/value pairs where the
--   keys are in descending order.
--   
--   <pre>
--   toDescList (fromList [(5,"a"), (3,"b")]) == [(5,"a"), (3,"b")]
--   </pre>
toDescList :: CritBit k v -> [(k, v)]

-- | <i>O(n)</i>. Build a tree from an ascending list in linear time.
--   <i>The precondition (input list is ascending) is not checked.</i>
--   
--   <pre>
--   fromAscList [(3,"b"), (5,"a")]          == fromList [(3, "b"), (5, "a")]
--   fromAscList [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "b")]
--   valid (fromAscList [(3,"b"), (5,"a"), (5,"b")]) == True
--   valid (fromAscList [(5,"a"), (3,"b"), (5,"b")]) == False
--   </pre>
fromAscList :: CritBitKey k => [(k, a)] -> CritBit k a

-- | <i>O(n)</i>. Build a tree from an ascending list in linear time with a
--   combining function for equal keys. <i>The precondition (input list is
--   ascending) is not checked.</i>
--   
--   <pre>
--   fromAscListWith (++) [(3,"b"), (5,"a"), (5,"b")] == fromList [(3, "b"), (5, "ba")]
--   valid (fromAscListWith (++) [(3,"b"), (5,"a"), (5,"b")]) == True
--   valid (fromAscListWith (++) [(5,"a"), (3,"b"), (5,"b")]) == False
--   </pre>
fromAscListWith :: CritBitKey k => (a -> a -> a) -> [(k, a)] -> CritBit k a

-- | <i>O(n)</i>. Build a map from an ascending list in linear time with a
--   combining function for equal keys. <i>The precondition (input list is
--   ascending) is not checked.</i>
--   
--   <pre>
--   let f k a1 a2 = (show k) ++ ":" ++ a1 ++ a2
--   fromAscListWithKey f [(3,"b"), (5,"a"), (5,"b"), (5,"b")] == fromList [(3, "b"), (5, "5:b5:ba")]
--   valid (fromAscListWithKey f [(3,"b"), (5,"a"), (5,"b"), (5,"b")]) == True
--   valid (fromAscListWithKey f [(5,"a"), (3,"b"), (5,"b"), (5,"b")]) == False
--   </pre>
fromAscListWithKey :: CritBitKey k => (k -> a -> a -> a) -> [(k, a)] -> CritBit k a

-- | <i>O(n)</i>. Build a tree from an ascending list of distinct elements
--   in linear time. <i>The precondition is not checked.</i>
--   
--   <pre>
--   fromDistinctAscList [(3,"b"), (5,"a")] == fromList [(3, "b"), (5, "a")]
--   valid (fromDistinctAscList [(3,"b"), (5,"a")])          == True
--   valid (fromDistinctAscList [(3,"b"), (5,"a"), (5,"b")]) == False
--   </pre>
fromDistinctAscList :: CritBitKey k => [(k, a)] -> CritBit k a

-- | <i>O(n)</i>. Filter all values that satisfy the predicate.
--   
--   <pre>
--   filter (&gt; "a") (fromList [("5","a"), ("3","b")]) == fromList [("3","b")]
--   filter (&gt; "x") (fromList [("5","a"), ("3","b")]) == empty
--   filter (&lt; "a") (fromList [("5","a"), ("3","b")]) == empty
--   </pre>
filter :: (v -> Bool) -> CritBit k v -> CritBit k v

-- | <i>O(n)</i>. Filter all keys/values that satisfy the predicate.
--   
--   <pre>
--   filterWithKey (\k _ -&gt; k &gt; "4") (fromList [("5","a"), ("3","b")]) == fromList[("5","a")]
--   </pre>
filterWithKey :: (k -> v -> Bool) -> CritBit k v -> CritBit k v

-- | <i>O(n)</i>. Partition the map according to a predicate. The first map
--   contains all elements that satisfy the predicate, the second all
--   elements that fail the predicate. See also <a>split</a>.
--   
--   <pre>
--   partition (&gt; 4) (fromList [("a",5), ("b",3)]) == (fromList [("a",5)], fromList [("b",3)])
--   partition (&lt; 6) (fromList [("a",5), ("b",3)]) == (fromList [("a",5), ("b",3)], empty)
--   partition (&gt; 6) (fromList [("a",5), ("b",3)]) == (empty, fromList [("a",5), ("b",3)])
--   </pre>
partition :: CritBitKey k => (v -> Bool) -> CritBit k v -> (CritBit k v, CritBit k v)

-- | <i>O(n)</i>. Partition the map according to a predicate. The first map
--   contains all elements that satisfy the predicate, the second all
--   elements that fail the predicate. See also <a>split</a>.
--   
--   <pre>
--   partitionWithKey (\ k _ -&gt; k &lt; "b") (fromList [("a",5), ("b",3)]) == (fromList [("a",5)], fromList [("b",3)])
--   partitionWithKey (\ k _ -&gt; k &lt; "c") (fromList [(5,"a"), (3,"b")]) == (fromList [("a",5), ("b",3)], empty)
--   partitionWithKey (\ k _ -&gt; k &gt; "c") (fromList [(5,"a"), (3,"b")]) == (empty, fromList [("a",5), ("b",3)])
--   </pre>
partitionWithKey :: CritBitKey k => (k -> v -> Bool) -> CritBit k v -> (CritBit k v, CritBit k v)

-- | <i>O(n)</i>. Map values and collect the <a>Just</a> results.
--   
--   <pre>
--   let f x = if x == 5 then Just 10 else Nothing
--   mapMaybe f (fromList [("a",5), ("b",3)]) == singleton "a" 10
--   </pre>
mapMaybe :: (a -> Maybe b) -> CritBit k a -> CritBit k b

-- | <i>O(n)</i>. Map keys/values and collect the <a>Just</a> results.
--   
--   <pre>
--   let f k v = if k == "a" then Just ("k,v: " ++ show k ++ "," ++ show v) else Nothing
--   mapMaybeWithKey f (fromList [("a",5), ("b",3)]) == singleton "a" "k,v: \"a\",3"
--   </pre>
mapMaybeWithKey :: (k -> v -> Maybe v') -> CritBit k v -> CritBit k v'

-- | <i>O(n)</i>. Map values and separate the <a>Left</a> and <a>Right</a>
--   results.
--   
--   <pre>
--   let f a = if a &lt; 5 then Left a else Right a
--   mapEither f (fromList [("a",5), ("b",3), ("x",1), ("z",7)])
--       == (fromList [("b",3), ("x",1)], fromList [("a",5), ("z",7)])
--   
--   mapEither (\ a -&gt; Right a) (fromList [("a",5), ("b",3), ("x",1), ("z",7)])
--       == (empty, fromList [("a",5), ("b",3), ("x",1), ("z",7)])
--   </pre>
mapEither :: (a -> Either b c) -> CritBit k a -> (CritBit k b, CritBit k c)

-- | <i>O(n)</i>. Map keys/values and separate the <a>Left</a> and
--   <a>Right</a> results.
--   
--   <pre>
--   let f k a = if k &lt; "c" then Left (k ++ k) else Right (a * 2)
--   mapEitherWithKey f (fromList [("a",5), ("b",3), ("x",1), ("z",7)])
--       == (fromList [("a","aa"), ("b","bb")], fromList [("x",2), ("z",14)])
--   
--   mapEitherWithKey (\_ a -&gt; Right a) (fromList [("a",5), ("b",3), ("x",1), ("z",7)])
--       == (empty, fromList [("x",1), ("b",3), ("a",5), ("z",7)])
--   </pre>
mapEitherWithKey :: (k -> v -> Either v1 v2) -> CritBit k v -> (CritBit k v1, CritBit k v2)

-- | <i>O(k)</i>. The expression (<tt><a>split</a> k map</tt>) is a pair
--   <tt>(map1,map2)</tt> where the keys in <tt>map1</tt> are smaller than
--   <tt>k</tt> and the keys in <tt>map2</tt> larger than <tt>k</tt>. Any
--   key equal to <tt>k</tt> is found in neither <tt>map1</tt> nor
--   <tt>map2</tt>.
--   
--   <pre>
--   split "a" (fromList [("b",1), ("d",2)]) == (empty, fromList [("b",1), ("d",2)])
--   split "b" (fromList [("b",1), ("d",2)]) == (empty, singleton "d" 2)
--   split "c" (fromList [("b",1), ("d",2)]) == (singleton "b" 1, singleton "d" 2)
--   split "d" (fromList [("b",1), ("d",2)]) == (singleton "b" 1, empty)
--   split "e" (fromList [("b",1), ("d",2)]) == (fromList [("b",1), ("d",2)], empty)
--   </pre>
split :: CritBitKey k => k -> CritBit k v -> (CritBit k v, CritBit k v)

-- | <i>O(k)</i>. The expression (<tt><a>splitLookup</a> k map</tt>) splits
--   a map just like <a>split</a> but also returns <tt><a>lookup</a> k
--   map</tt>.
--   
--   <pre>
--   splitLookup "a" (fromList [("b",1), ("d",2)]) == (empty, Nothing, fromList [("b",1), ("d",2)])
--   splitLookup "b" (fromList [("b",1), ("d",2)]) == (empty, Just 1, singleton "d" 2)
--   splitLookup "c" (fromList [("b",1), ("d",2)]) == (singleton "b" 1, Nothing, singleton "d" 2)
--   splitLookup "d" (fromList [("b",1), ("d",2)]) == (singleton "b" 1, Just 2, empty)
--   splitLookup "e" (fromList [("b",1), ("d",2)]) == (fromList [("b",1), ("d",2)], Nothing, empty)
--   </pre>
splitLookup :: CritBitKey k => k -> CritBit k v -> (CritBit k v, Maybe v, CritBit k v)

-- | <i>O(n+m)</i>. This function is defined as (<tt><a>isSubmapOf</a> =
--   <a>isSubmapOfBy</a> (==)</tt>).
isSubmapOf :: (CritBitKey k, Eq v) => CritBit k v -> CritBit k v -> Bool

-- | <i>O(n+m)</i>. The expression (<tt><a>isSubmapOfBy</a> f t1 t2</tt>)
--   returns <a>True</a> if all keys in <tt>t1</tt> are in map <tt>t2</tt>,
--   and when <tt>f</tt> returns <a>True</a> when applied to their
--   respective values. For example, the following expressions are all
--   <a>True</a>:
--   
--   <pre>
--   isSubmapOfBy (==) (fromList [("a",1)]) (fromList [("a",1),("b",2)])
--   isSubmapOfBy (&lt;=) (fromList [("a",1)]) (fromList [("a",1),("b",2)])
--   isSubmapOfBy (==) (fromList [("a",1),("b",2)]) (fromList [("a",1),("b",2)])
--   </pre>
--   
--   But the following are all <a>False</a>:
--   
--   <pre>
--   isSubmapOfBy (==) (fromList [("a",2)]) (fromList [("a",1),("b",2)])
--   isSubmapOfBy (&lt;)  (fromList [("a",1)]) (fromList [("a",1),("b",2)])
--   isSubmapOfBy (==) (fromList [("a",1),("b",2)]) (fromList [("a",1)])
--   </pre>
isSubmapOfBy :: CritBitKey k => (a -> b -> Bool) -> CritBit k a -> CritBit k b -> Bool

-- | <i>O(n+m)</i>. Is this a proper submap? (ie. a submap but not equal).
--   Defined as (<tt><a>isProperSubmapOf</a> = <a>isProperSubmapOfBy</a>
--   (==)</tt>).
isProperSubmapOf :: (CritBitKey k, Eq v) => CritBit k v -> CritBit k v -> Bool

-- | <i>O(n+m)</i>. Is this a proper submap? (ie. a submap but not equal).
--   The expression (<tt><a>isProperSubmapOfBy</a> f m1 m2</tt>) returns
--   <a>True</a> when <tt>m1</tt> and <tt>m2</tt> are not equal, all keys
--   in <tt>m1</tt> are in <tt>m2</tt>, and when <tt>f</tt> returns
--   <a>True</a> when applied to their respective values. For example, the
--   following expressions are all <a>True</a>:
--   
--   <pre>
--   isProperSubmapOfBy (==) (fromList [("a",1)]) (fromList [("a",1),("b",2)])
--   isProperSubmapOfBy (&lt;=) (fromList [("a",0)]) (fromList [("a",1),("b",2)])
--   </pre>
--   
--   But the following are all <a>False</a>:
--   
--   <pre>
--   isProperSubmapOfBy (==) (fromList [("a",1),("b",2)]) (fromList [("a",1),("b",2)])
--   isProperSubmapOfBy (==) (fromList ["a",1),("b",2)])  (fromList [("a",1)])
--   isProperSubmapOfBy (&lt;)  (fromList [("a",1)])         (fromList [("a",1),("b",2)])
--   </pre>
isProperSubmapOfBy :: CritBitKey k => (a -> b -> Bool) -> CritBit k a -> CritBit k b -> Bool

-- | <i>O(minimum K)</i>. The minimal key of the map. Calls <a>error</a> if
--   the map is empty.
--   
--   <pre>
--   findMin (fromList [("b",3), ("a",5)]) == ("a",5)
--   findMin empty                       Error: empty map has no minimal element
--   </pre>
findMin :: CritBit k v -> (k, v)

-- | <i>O(k)</i>. The maximal key of the map. Calls <a>error</a> if the map
--   is empty.
--   
--   <pre>
--   findMax empty                       Error: empty map has no minimal element
--   </pre>
findMax :: CritBit k v -> (k, v)

-- | <i>O(k')</i>. Delete the minimal key. Returns an empty map if the map
--   is empty.
--   
--   <pre>
--   deleteMin (fromList [("a",5), ("b",3), ("c",7)]) == fromList [("b",3), ("c",7)]
--   deleteMin empty == empty
--   </pre>
deleteMin :: CritBit k v -> CritBit k v

-- | <i>O(k)</i>. Delete the maximal key. Returns an empty map if the map
--   is empty.
--   
--   <pre>
--   deleteMin (fromList [("a",5), ("b",3), ("c",7)]) == fromList [("a",5), ("b","3")]
--   deleteMin empty == empty
--   </pre>
deleteMax :: CritBit k v -> CritBit k v

-- | <i>O(k')</i>. Delete and find the minimal element.
--   
--   <pre>
--   deleteFindMin (fromList [("a",5), ("b",3), ("c",10)]) == (("a",5), fromList[("b",3), ("c",10)])
--   deleteFindMin     Error: can not return the minimal element of an empty map
--   </pre>
deleteFindMin :: CritBit k v -> ((k, v), CritBit k v)

-- | <i>O(k)</i>. Delete and find the maximal element.
--   
--   <pre>
--   deleteFindMax (fromList [("a",5), ("b",3), ("c",10)]) == (("c",10), fromList[("a",5), ("b",3)])
--   deleteFindMax     Error: can not return the maximal element of an empty map
--   </pre>
deleteFindMax :: CritBit k v -> ((k, v), CritBit k v)

-- | <i>O(k')</i>. Update the value at the minimal key.
--   
--   <pre>
--   updateMin (\ a -&gt; Just (a + 7)) (fromList [("a",5), ("b",3)]) == fromList [("a",12), ("b",3)]
--   updateMin (\ _ -&gt; Nothing)      (fromList [("a",5), ("b",3)]) == fromList [("b",3)]
--   </pre>
updateMin :: (v -> Maybe v) -> CritBit k v -> CritBit k v

-- | <i>O(k)</i>. Update the value at the maximal key.
--   
--   <pre>
--   updateMax (\ a -&gt; Just (a + 7)) (fromList [("a",5), ("b",3)]) == fromList [("a",5), ("b",10)]
--   updateMax (\ _ -&gt; Nothing)      (fromList [("a",5), ("b",3)]) == fromList [("a",5)]
--   </pre>
updateMax :: (v -> Maybe v) -> CritBit k v -> CritBit k v

-- | <i>O(k')</i>. Update the value at the minimal key.
--   
--   <pre>
--   updateMinWithKey (\ k a -&gt; Just (length k + a)) (fromList [("a",5), ("b",3)]) == fromList [("a",6), ("b",3)]
--   updateMinWithKey (\ _ _ -&gt; Nothing)             (fromList [("a",5), ("b",3)]) == fromList [("b",3)]
--   </pre>
updateMinWithKey :: (k -> v -> Maybe v) -> CritBit k v -> CritBit k v

-- | <i>O(k)</i>. Update the value at the maximal key.
--   
--   <pre>
--   updateMaxWithKey (\ k a -&gt; Just (length k + a)) (fromList [("a",5), ("b",3)]) == fromList [("a",5), ("b",4)]
--   updateMaxWithKey (\ _ _ -&gt; Nothing)             (fromList [("a",5), ("b",3)]) == fromList [("a",5)]
--   </pre>
updateMaxWithKey :: (k -> v -> Maybe v) -> CritBit k v -> CritBit k v

-- | <i>O(k')</i>. Retrieves the value associated with minimal key of the
--   map, and the map stripped of that element, or <a>Nothing</a> if passed
--   an empty map.
--   
--   <pre>
--   minView (fromList [("a",5), ("b",3)]) == Just (5, fromList [("b",3)])
--   minView empty == Nothing
--   </pre>
minView :: CritBit k v -> Maybe (v, CritBit k v)

-- | <i>O(k)</i>. Retrieves the value associated with maximal key of the
--   map, and the map stripped of that element, or <a>Nothing</a> if passed
--   an empty map.
--   
--   <pre>
--   maxView (fromList [("a",5), ("b",3)]) == Just (3, fromList [("a",5)])
--   maxView empty == Nothing
--   </pre>
maxView :: CritBit k v -> Maybe (v, CritBit k v)

-- | <i>O(k')</i>. Retrieves the minimal (key,value) pair of the map, and
--   the map stripped of that element, or <a>Nothing</a> if passed an empty
--   map.
--   
--   <pre>
--   minViewWithKey (fromList [("a",5), ("b",3)]) == Just (("a",5), fromList [("b",3)])
--   minViewWithKey empty == Nothing
--   </pre>
minViewWithKey :: CritBit k v -> Maybe ((k, v), CritBit k v)

-- | <i>O(k)</i>. Retrieves the maximal (key,value) pair of the map, and
--   the map stripped of that element, or <a>Nothing</a> if passed an empty
--   map.
--   
--   <pre>
--   maxViewWithKey (fromList [("a",5), ("b",3)]) == Just (("b",3), fromList [("a",5)])
--   maxViewWithKey empty == Nothing
--   </pre>
maxViewWithKey :: CritBit k v -> Maybe ((k, v), CritBit k v)
