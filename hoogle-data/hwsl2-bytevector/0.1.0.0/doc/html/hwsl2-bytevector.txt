-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A hashed byte-vector based on algebraic hashes and finger trees
--   
@package hwsl2-bytevector
@version 0.1.0.0

module Data.Hash.SL2.ByteVector
data ByteVector

-- | <i>O(1)</i> Creates a vector from a single chunk.
singleton :: Chunk -> ByteVector

-- | <i>O(n)</i> Creates a vector from a list of chunks.
fromList :: [Chunk] -> ByteVector

-- | <i>O(1)</i> The empty vector. Alias for <a>mempty</a>.
empty :: ByteVector

-- | <i>O(n)</i> Concatenates two vectors together. Alias for
--   <a>mappend</a>.
append :: ByteVector -> ByteVector -> ByteVector

-- | <i>O(1)</i> Adds a chunk to the left end of the vector.
cons :: Chunk -> ByteVector -> ByteVector

-- | <i>O(1)</i> Adds a chunk to the right end of the vector.
snoc :: ByteVector -> Chunk -> ByteVector

-- | <i>O(1)</i> Is this the empty vector?
null :: ByteVector -> Bool

-- | <i>O(1)</i> Returns the hash of the vector.
hash :: ByteVector -> Hash

-- | <i>O(1)</i> Returns the number of bytes in the vector.
length :: ByteVector -> Integer
data ViewL
EmptyL :: ViewL
MostL :: Chunk -> ByteVector -> ViewL

-- | <i>O(1)</i> Creates a view of the left end of the vector.
viewl :: ByteVector -> ViewL

-- | <i>O(1)</i> Creates a view of the left end of the vector. The single
--   chunk is guaranteed to never be empty.
viewl1 :: ByteVector -> ViewL
data ViewR
EmptyR :: ViewR
MostR :: ByteVector -> Chunk -> ViewR

-- | <i>O(1)</i> Creates a view of the right end of the vector.
viewr :: ByteVector -> ViewR

-- | <i>O(1)</i> Creates a view of the right end of the vector. The single
--   chunk is guaranteed to never be empty.
viewr1 :: ByteVector -> ViewR

-- | <i>O(log(min(i,n-i)))</i> Splits the vector at the chunk where the
--   accumulated length equals the provided integer <i>i</i>. The resulting
--   left side has a length smaller <i>i</i>.
splitBefore :: Integer -> ByteVector -> (ByteVector, ByteVector)

-- | <i>O(log(min(i,n-i)))</i> Splits the vector at the byte where the
--   accumulated length equals the provided integer <i>i</i>. The resulting
--   left side has a length of <i>min(i,n)</i>.
--   
--   This is potentially less efficient than <a>splitBefore</a> because it
--   has to re-hash parts of the vector.
splitAt :: Integer -> ByteVector -> (ByteVector, ByteVector)

-- | <i>O(n)</i> Reverses the vector.
reverse :: ByteVector -> ByteVector

-- | <i>O(n)</i> Applies a function to every chunk in the vector.
map :: (Chunk -> Chunk) -> ByteVector -> ByteVector

-- | <i>O(n)</i> Folds the vector from left to right.
foldl :: (a -> Chunk -> a) -> a -> ByteVector -> a

-- | <i>O(n)</i> Folds the vector from right to left.
foldr :: (Chunk -> a -> a) -> a -> ByteVector -> a

-- | <i>O(n)</i> Folds the vector from left to right, with strict
--   application.
foldl' :: (a -> Chunk -> a) -> a -> ByteVector -> a

-- | <i>O(n)</i> Folds the vector from right to left, with strict
--   application.
foldr' :: (Chunk -> a -> a) -> a -> ByteVector -> a
instance Eq MeasuredChunk
instance Ord MeasuredChunk
instance Monoid ByteVector
instance Eq ViewL
instance Ord ViewL
instance Eq ViewR
instance Ord ViewR
instance Ord ByteVector
instance Eq ByteVector
instance Measured Measure MeasuredChunk
instance Monoid Measure
