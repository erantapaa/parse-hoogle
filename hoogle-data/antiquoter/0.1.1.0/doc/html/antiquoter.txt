-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Combinator library for quasi- and anti-quoting.
--   
--   A combinator library to improve the building of anti-quoters.
--   Especially aimed at removing copy-and-paste programming from their
--   definition. Other antiquoting related features could be included in
--   the future.
--   
--   The modules are
--   
--   <ul>
--   <li><a>Language.Haskell.AntiQuoter.Base</a> basic types for building
--   antiquoters. It also contains the most detailed example of the basic
--   usage.</li>
--   <li><a>Language.Haskell.AntiQuoter.ExpPat</a> making antiquoters which
--   can antiquote both expressions and patters. Therefore only one
--   antiquoter has to be defined in stead of two.</li>
--   <li><a>Language.Haskell.AntiQuoter.Combinators</a> more useful
--   combinators to use with the functions from
--   <a>Language.Haskell.AntiQuoter.ExpPat</a>.</li>
--   </ul>
@package antiquoter
@version 0.1.1.0


-- | Base module for <a>AntiQuoter</a>s, defining some basic type-aliases
--   and and combinators for antiquoting.
--   
--   To for examples in the documentation of this library the following
--   data types defining the untyped lambda calculus syntax:
--   
--   <pre>
--   data Expr
--       = VarE Var
--       | Lam  Var Expr
--       | App  Expr Expr
--       | AntiExpr String
--       deriving (Typeable, Data)
--   data Var
--       = Var     String
--       | AntiVar String
--       deriving (Typeable, Data)
--   </pre>
--   
--   (note: the idea for using lambda calculus comes from the original
--   paper on quasi-quoting
--   <a>http://www.eecs.harvard.edu/~mainland/ghc-quasiquoting/mainland07quasiquoting.pdf</a>)
--   
--   A simple quasi-quoter without support for antiquoting can be defined
--   by:
--   
--   <pre>
--   lExp = QuasiQuoter
--       { quoteExp  = dataToExpQ (const Nothing) . parseExpr
--       , quotePat  = dataToPatQ (const Nothing) . parseExpr
--       , quoteType = error "No type quoter"
--       , quoteDec  = error "No declaration quoter"
--       }
--   parseExpr :: String -&gt; Expr
--   parseExpr = undefined -- implementation omitted
--   </pre>
--   
--   Now to add antiquoting it is needed to treat the AntiExpr and AntiVar
--   constructors as special and translate them ourselves. This introduces
--   an <tt><a>AntiQuoterPass</a> e p</tt>, which is a specific translation
--   rule from source syntax <tt>e</tt> to template haskell type
--   <tt>p</tt>. In the example this can be used to defined:
--   
--   <pre>
--   antiExprE :: AntiQuoterPass Expr Exp
--   antiExprE (AntiExpr s) = Just . varE $ mkName s
--   antiExprE _            = Nothing
--   antiVarE :: AntiQuoterPass Var Exp
--   antiVarE (AntiVar s) = Just . varE $ mkName s
--   antiVarE _           = Nothing
--   
--   antiExprP :: AntiQuoterPass Expr Pat
--   antiExprP (AntiExpr s) = Just . varP $ mkName s
--   antiExprP _            = Nothing
--   antiVarP :: AntiQuoterPass Var Pat
--   antiVarP (AntiVar s) = Just . varP $ mkName s
--   antiVarP _           = Nothing
--   </pre>
--   
--   Both rules should be used when antiquoting as an exception to the base
--   case (using the default translation, <tt>const Nothing</tt>). Which
--   can be done using <tt>(<a>&lt;&gt;&gt;</a>)</tt>, creating an
--   <a>AntiQuoter</a>. Where an <a>AntiQuoter</a> represents a combination
--   of <a>AntiQuoterPass</a>es which can be used to antiquote multiple
--   datatypes. In the example this would result in
--   
--   <pre>
--   lExp = QuasiQuoter
--       { quoteExp  = dataToExpQ antiE . parseExpr
--       , quotePat  = dataToPatQ antiP . parseExpr
--       , quoteType = error "No type quoter"
--       , quoteDec  = error "No declaration quoter"
--       }
--       where
--           antiE :: AntiQuoter Exp
--           antiE = antiExprE &lt;&gt;&gt; antiVarE &lt;&gt;&gt; const Nothing
--           antiP :: AntiQuoter Pat
--           antiP = antiExprP &lt;&gt;&gt; antiVarP &lt;&gt;&gt; const Nothing
--   </pre>
--   
--   Two little improvements could be made, <tt>const Nothing</tt> could be
--   replaced by <a>noAntiQuoter</a> and the building of the
--   <a>QuasiQuoter</a> could be simplified by using <a>mkQuasiQuoter</a>.
module Language.Haskell.AntiQuoter.Base

-- | A single antiquotation for a specific source type. Usually <tt>e</tt>
--   is a type from the parsed language and <tt>q</tt> is the target type
--   (usually <a>Pat</a> or <a>Exp</a>). A <tt>Just result</tt> indicates
--   that the input should be antiquoted into <tt>result</tt> while
--   <tt>Nothing</tt> indicates that there is no special antiquotation.
type AntiQuoterPass e q = e -> Maybe (Q q)

-- | An <a>AntiQuoter</a> is the combination of several
--   <a>AntiQuoterPass</a>es, which could have different source types. In
--   the example the <tt>AntiQuoterPass Expr Exp</tt> and
--   <tt>AntiQuoterPass Var Exp</tt> were combined into a single
--   <tt>AntiQuoter Exp</tt>, which antiquoted both <tt>Expr</tt> and
--   <tt>Pat</tt>.
type AntiQuoter q = forall e. Typeable e => AntiQuoterPass e q

-- | Result of an <a>AntiQuoterPass</a> (AntiQuoterPass e q = e -&gt;
--   AQResult q). This type-alias is mostly used for combinators which only
--   provides the result of the antiquotation and the usecase (thus the
--   pattern to match) should be filled in by the user.
--   
--   See <a>AntiQuoterPass</a> on what <tt>Nothing</tt> and <tt>Just</tt>
--   mean.
type AQResult q = Maybe (Q q)

-- | Create an QuasiQuoter for expressions and patterns from a parser and
--   two antiquoters. The quasiquoter from the example could also have been
--   constructed by using <tt>mkQuasiQuoter (return . parse) antiE antiP
--   </tt>.
mkQuasiQuoter :: Data a => (String -> Q a) -> AntiQuoter Exp -> AntiQuoter Pat -> QuasiQuoter

-- | Create an <a>AntiQuoter</a> from an single pass.
fromPass :: Typeable e => AntiQuoterPass e q -> AntiQuoter q

-- | An <tt>AnitQuoter</tt> that does no antiquoting by only return
--   Nothing,
--   
--   <pre>
--   noAntiQuoter = const Nothing
--   </pre>
noAntiQuoter :: AntiQuoter q

-- | Combines two <a>AntiQuoter</a>s with the same result. It is left
--   biased, thus if the first antiquoter returns <tt>Just result</tt> that
--   is used, otherwise the second AntiQuoter is tried. Together with
--   <a>noAntiQuoter</a> this forms a monoid, but as AntiQuoter is a type
--   synonyme no instance is declared.
(<<>>) :: AntiQuoter q -> AntiQuoter q -> AntiQuoter q

-- | Create an <a>AntiQuoter</a> by combining an <a>AntiQuoter</a> and an
--   <a>AntiQuoterPass</a>. This is left biased, see
--   (<a>&lt;&lt;&gt;&gt;</a>).
(<<>) :: Typeable e => AntiQuoter q -> AntiQuoterPass e q -> AntiQuoter q

-- | Create an <a>AntiQuoter</a> by combining an <a>AntiQuoterPass</a> and
--   an <a>AntiQuoter</a>. This is left biased, see
--   (<a>&lt;&lt;&gt;&gt;</a>).
(<>>) :: Typeable e => AntiQuoterPass e q -> AntiQuoter q -> AntiQuoter q

-- | Extend a generic query by a type-specific case
extQ :: (Typeable a, Typeable b) => (a -> q) -> (b -> q) -> a -> q

-- | Wrapper for <a>AQResult</a>, needed for the typechecker.
newtype WrappedAQResult q
AQRW :: AQResult q -> WrappedAQResult q
unAQRW :: WrappedAQResult q -> AQResult q


-- | <a>Exp</a> and <a>Pat</a> are for most part used in simmilar fashion.
--   Most AntiQuoter(Pass)es have to be written for both datatypes and
--   their implementation is more or less identical in structure. To reduce
--   copy-and-paste programming it would be best if it would only need one
--   AntiQuoter(Pass) that works on both <a>Exp</a> and <a>Pat</a>.
--   
--   This module defines the <a>EP</a> typeclass expressing the similarity
--   between <a>Exp</a> and <a>Pat</a> and some basic functions to use them
--   with <a>AntiQuoterPass</a>es. The
--   <a>Language.Haskell.AntiQuoter.Combinators</a> defines the combinator
--   functions on top of these functions, which are probably more suitable
--   for users.
--   
--   As an example of the problem take the antiquoters in
--   <a>Language.Haskell.AntiQuoter.Base</a> where there are two
--   AntiQuoterPasses for each source type, for Var they are
--   
--   <pre>
--   antiVarE :: AntiQuoterPass Var Exp
--   antiVarE (AV v ) = Just $ varE $ mkName v
--   antiVarE _ = Nothing
--   antiVarP :: AntiQuoterPass Var Pat
--   antiVarP (AV v ) = Just $ varP $ mkName v
--   antiVarP _ = Nothing
--   </pre>
--   
--   The problem is that the definition for the pattern antiquoter is
--   almost a duplicate of the one for expressions. This similarity between
--   antiquoting expressions and patterns is captured in the <a>EP</a>
--   class which can be used to write antiquoters which an yield both
--   expressions and patterns. Using the combinators defined on top of this
--   class (see <a>Language.Haskell.AntiQuoter.Combinators</a>) the example
--   can be rewritten as
--   
--   <pre>
--   antiVar :: EP q =&gt; AntiQuoterPass Var q -- equivalent to antiVar :: EPAntiQuoterPass Var
--   antiVar (AV v) = Just $ varQ $ mkName v
--   antiVar _      = Nothing
--   </pre>
module Language.Haskell.AntiQuoter.ExpPat

-- | Typeclass with the common constructors of <a>Exp</a> and <a>Pat</a>,
--   useful for building <a>EPAntiQuoter</a>s.
class EP q
var :: EP q => Name -> q
con :: EP q => Name -> [q] -> q
lit :: EP q => Lit -> q
tup :: EP q => [q] -> q
list :: EP q => [q] -> q
fromEPV :: EP q => EPV f -> f q

-- | An <a>AntiQuoter</a> that works for <a>Exp</a> and <a>Pat</a> results.
type EPAntiQuoter = forall q. EP q => AntiQuoter q

-- | An <a>AntiQuoterPass</a> that works for <a>Exp</a> and <a>Pat</a>
--   results.
type EPAntiQuoterPass e = forall q. EP q => AntiQuoterPass e q

-- | As <a>mkQuasiQuoter</a> but uses an generalized <a>AntiQuoter</a>.
mkEPQuasiQuoter :: Data a => (String -> Q a) -> EPAntiQuoter -> QuasiQuoter

-- | Combine two <a>AntiQuoterPass</a>es, one for expression context and
--   another for pattern context, into a single pass which can be used in
--   both contexts.
epPass :: Typeable e => AntiQuoterPass e Exp -> AntiQuoterPass e Pat -> EPAntiQuoterPass e

-- | See <a>epPass</a>.
epPass' :: Typeable e => (e -> Maybe (Q Exp, Q Pat)) -> EPAntiQuoterPass e

-- | See <a>epPass</a>.
epPass'' :: Typeable e => AntiQuoterPass e (Exp, Pat) -> EPAntiQuoterPass e

-- | Make a context dependent result for expression and pattern contexts.
epResult :: EP q => AQResult Exp -> AQResult Pat -> AQResult q

-- | Make an context dependent value for expression and pattern contexts.
epValue :: EP q => Q Exp -> Q Pat -> Q q

-- | Constructs an <a>EP</a> value by choosing from an <a>Exp</a> of
--   <a>Pat</a> as appropriate in the context.
epPure :: EP q => Exp -> Pat -> q

-- | Container for a <tt>f</tt> of both an <a>Exp</a> and a <a>Pat</a>.
--   Used internally when the result for <a>Exp</a> and <a>Pat</a> differ.
data EPV f
EPV :: f Exp -> f Pat -> EPV f
eep :: EPV f -> f Exp
pep :: EPV f -> f Pat
instance EP Pat
instance EP Exp


-- | Several combinators for <tt>AntiQuoters</tt>, mainly <a>EP</a>
--   related.
module Language.Haskell.AntiQuoter.Combinators

-- | Generalized <a>varE</a>/<a>varP</a>.
varQ :: EP q => Name -> Q q

-- | Generalized <a>conP</a> or combination of <a>conE</a> and <a>appE</a>.
conQ :: EP q => Name -> [Q q] -> Q q

-- | Generalized <a>litE</a>/<a>litP</a>.
litQ :: EP q => Lit -> Q q

-- | Generalized <a>tupE</a>/<a>tupP</a>.
tupQ :: EP q => [Q q] -> Q q

-- | Generalized <a>listE</a>/<a>listP</a>.
listQ :: EP q => [Q q] -> Q q

-- | An results that does not output anything.
ignore :: AQResult q

-- | Yielding only a result for expressions and ignoring in patterns.
ignorePat :: EP q => AQResult Exp -> AQResult q

-- | Alias for <a>ignorePat</a>.
--   
--   Yielding only a result for expressions and ignoring in patterns.
onlyExp :: EP q => AQResult Exp -> AQResult q

-- | Yielding only a result for patterns and ignoring in expressions.
ignoreExp :: EP q => AQResult Pat -> AQResult q

-- | Alias for <a>ignoreExp</a>.
--   
--   Yielding only a result for patterns and ignoring in expressions.
onlyPat :: EP q => AQResult Pat -> AQResult q

-- | Uses/Binds a variable of the given name.
--   
--   <pre>
--   splice = varQ . mkName
--   </pre>
splice :: EP q => String -> Q q

-- | Use a wildcard in pattern context and the given expression in
--   expression contexts. Consider for example the folowing constructor
--   
--   <pre>
--   EX SrcLoc OtherType
--   </pre>
--   
--   When pattern matching the pattern should look like <tt>EX _ x</tt>,
--   using a wildcard for the source location. On the other hand making an
--   expression should use some result say resulting in <tt>EX someSrcLoc
--   x</tt>. With the <a>wild</a> function this general quoter can be
--   written as
--   
--   <pre>
--   con ''EX [wild someSrcLoc', splice "x"]
--   </pre>
--   
--   Assuming that <tt>someSrcLoc' :: ExpQ</tt> and that its result is of
--   type <tt>SrcLoc</tt>.
wild :: EP q => Q Exp -> Q q

-- | A <a>fail</a>ing result for patterns, useful for when a the pattern
--   matched by the using functions should never happen when antiquoting
--   patterns.
nonsenseP :: EP q => String -> AQResult Exp -> AQResult q

-- | See <a>nonsenseP</a> but failing on expresions.
nonsenseE :: EP q => String -> AQResult Pat -> AQResult q


-- | Simple reexport of all modules hiding the exports marked as internal.
module Language.Haskell.AntiQuoter
