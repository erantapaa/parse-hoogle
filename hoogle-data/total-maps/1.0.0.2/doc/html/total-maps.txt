-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Dense and sparse total maps.
--   
@package total-maps
@version 1.0.0.2


-- | Bounded, dense, total map implemented as a vector.
module Data.Total.Array

-- | A total map from keys k to values a, represented as an immutable
--   vector.
--   
--   Warning: the number of keys MUST fit into an Int.
--   
--   n is equal to the number of keys.
newtype TotalArray k a
TotalArray :: (Vector a) -> TotalArray k a
instance Eq a => Eq (TotalArray k a)
instance Ord a => Ord (TotalArray k a)
instance Show a => Show (TotalArray k a)
instance Read a => Read (TotalArray k a)
instance Functor (TotalArray k)
instance Foldable (TotalArray k)
instance Traversable (TotalArray k)
instance (Enum k, Bounded k) => Representable (TotalArray k)
instance (Enum k, Bounded k) => Distributive (TotalArray k)
instance (Enum k, Bounded k, Serial a) => Serial (TotalArray k a)
instance (Enum k, Bounded k) => Serial1 (TotalArray k)
instance (Enum k, Bounded k) => Metric (TotalArray k)
instance (Enum k, Bounded k) => Additive (TotalArray k)
instance (Enum k, Bounded k) => TraversableWithKey (TotalArray k)
instance (Enum k, Bounded k) => FoldableWithKey (TotalArray k)
instance (Enum k, Bounded k) => Adjustable (TotalArray k)
instance (Enum k, Bounded k) => Indexable (TotalArray k)
instance (Enum k, Bounded k) => Lookup (TotalArray k)
instance (Enum k, Bounded k) => ZipWithKey (TotalArray k)
instance Zip (TotalArray k)
instance (Enum k, Bounded k) => Keyed (TotalArray k)
instance (Enum k, Bounded k) => Applicative (TotalArray k)


module Data.Total.Internal.SparseFold

-- | `mpower x n` raises x to the power n taking advantage of
--   associativity.
mpower :: Monoid m => m -> Integer -> m

-- | A semigroup used to quickly fold a sparse finite domain.
data SparseFold s m
SparseFold :: (Min Integer) -> m -> (Max Integer) -> SparseFold s m
foldPoint :: Integer -> a -> Option (SparseFold s a)
runSparseFold :: Monoid m => m -> (forall s. Reifies s m => Proxy s -> Option (SparseFold s m)) -> m
instance Typeable SparseFold
instance (Reifies s m, Monoid m) => Semigroup (SparseFold s m)


-- | Dense, total, maps for bounded types.
module Data.Total.Map

-- | A total map from keys k to values a.
--   
--   Most functions are derived from <a>Map</a>.
--   
--   n is equal to the number of keys.
--   
--   Unfortunately I cannot find any law linking Enum with Ord, so we
--   cannot be sure that <tt>[minBound .. maxBound]</tt> is sorted. Because
--   of that functions like <a>pure</a> and <a>tabulate</a> have complexity
--   O(n * log n), while they could be O(n).
newtype TotalMap k a
TotalMap :: (Map k a) -> TotalMap k a

-- | Zippy applicative. Complexity: <a>pure</a> O(n * log n),
--   <a>&lt;*&gt;</a> O(n).

-- | Complexity: <a>traverseWithKey</a> O(n)

-- | Complexity: <a>zero</a> O(n * log n), rest O(n)

-- | Complexity: all O(n)

-- | Complexity: <a>serializeWith</a> O(n), <a>deserializeWith</a> O(n *
--   log n)

-- | Complexity: <a>serialize</a> O(n), <a>deserialize</a> O(n * log n)

-- | Complexity: <a>distribute</a> O(n * log n + n * fmap)

-- | Convert from and to a <tt>(k -&gt; a)</tt> function.
--   
--   Complexity: tabulate O(n * log n), index O(log n)
instance Ord k => FoldableWithKey (TotalMap k)
instance Ord k => Adjustable (TotalMap k)
instance Ord k => Indexable (TotalMap k)
instance Ord k => Lookup (TotalMap k)
instance Ord k => ZipWithKey (TotalMap k)
instance Ord k => Zip (TotalMap k)
instance Keyed (TotalMap k)
instance (Eq k, Eq a) => Eq (TotalMap k a)
instance (Ord k, Ord a) => Ord (TotalMap k a)
instance (Show k, Show a) => Show (TotalMap k a)
instance (Ord k, Read k, Read a) => Read (TotalMap k a)
instance Functor (TotalMap k)
instance Foldable (TotalMap k)
instance Traversable (TotalMap k)
instance (Ord k, Enum k, Bounded k) => Representable (TotalMap k)
instance (Ord k, Enum k, Bounded k) => Distributive (TotalMap k)
instance (Ord k, Enum k, Bounded k, Serial a) => Serial (TotalMap k a)
instance (Ord k, Enum k, Bounded k) => Serial1 (TotalMap k)
instance (Ord k, Enum k, Bounded k) => Metric (TotalMap k)
instance (Ord k, Enum k, Bounded k) => Additive (TotalMap k)
instance Ord k => TraversableWithKey (TotalMap k)
instance (Ord k, Enum k, Bounded k) => Applicative (TotalMap k)


-- | Sparse, total maps for bounded types.
module Data.Total.Map.Sparse

-- | A total sparse map from keys k to values a. This map is implemented as
--   a partial map and a default value. <a>pure</a> creates an all-default
--   values map with the given default value.
--   
--   n is equal to the number of keys, k is the number of non-default
--   values. If there are two maps involved k is taken to be the number of
--   non-default values of their union.
data TotalSparseMap k a
TotalSparseMap :: (Map k a) -> a -> TotalSparseMap k a

-- | Complexity: O(k * log (n/k)) - arises from fold

-- | Complexity: O(k * log (n/k)) - arises from fold

-- | Zippy applicative. Complexity: <a>pure</a> O(1), <a>&lt;*&gt;</a> O(k1
--   + k2)

-- | Folds over the whole domain, including the default values.
--   
--   <pre>
--   &gt;&gt;&gt; sum (pure 1 :: TotalSparseMap Int Integer)
--   18446744073709551616
--   </pre>
--   
--   Complexity: foldMap O(k * log (n/k)), the rest are defined using
--   foldMap

-- | Complexity: <a>lookup</a> O(log k)

-- | Complexity: <a>index</a> O(log k)

-- | Complexity: all O(log k)

-- | Complexity: all O(k1 + k2)

-- | Complexity: <a>zero</a> O(1), rest O(k1 + k2)

-- | Complexity: all O(k * log (n/k)) - arises from fold

-- | Complexity: <a>serializeWith</a> O(n), <a>deserializeWith</a> O(n)

-- | Complexity: <a>serialize</a> O(n), <a>deserialize</a> O(n)

-- | Convert the sparse map to a dense one.
--   
--   Complexity: O(n * log n)
toDenseMap :: (Ord k, Enum k, Bounded k) => TotalSparseMap k a -> TotalMap k a
instance (Show k, Show a) => Show (TotalSparseMap k a)
instance (Ord k, Read k, Read a) => Read (TotalSparseMap k a)
instance Functor (TotalSparseMap k)
instance (Ord k, Enum k, Bounded k, Serial k, Serial a) => Serial (TotalSparseMap k a)
instance (Ord k, Enum k, Bounded k, Serial k) => Serial1 (TotalSparseMap k)
instance (Ord k, Enum k, Bounded k) => Metric (TotalSparseMap k)
instance Ord k => Additive (TotalSparseMap k)
instance Ord k => Zip (TotalSparseMap k)
instance Ord k => Adjustable (TotalSparseMap k)
instance Ord k => Indexable (TotalSparseMap k)
instance Ord k => Lookup (TotalSparseMap k)
instance (Ord k, Enum k, Bounded k) => Foldable (TotalSparseMap k)
instance Ord k => Applicative (TotalSparseMap k)
instance (Ord k, Enum k, Bounded k, Ord a) => Ord (TotalSparseMap k a)
instance (Ord k, Enum k, Bounded k, Eq a) => Eq (TotalSparseMap k a)


-- | Subset relation.
module Data.Total.Subset

-- | <tt>Subset s k</tt> means that <tt>s</tt> reifies a subset of
--   <tt>k</tt>.
type Subset s k = Reifies s (Set k)


-- | Dense, total, maps parametrized by a set of keys.
module Data.Total.Map.Subset

-- | <tt>Subset s k</tt> means that <tt>s</tt> reifies a subset of
--   <tt>k</tt>.
type Subset s k = Reifies s (Set k)

-- | A total map from a subset s of keys k to values a, e.g. a restriction
--   of a partial function <tt>k -&gt; a</tt> to a subset of its domain on
--   which the function is defined.
--   
--   Most functions are derived from <a>Map</a>.
--   
--   n is equal to the size of the key set.
newtype TotalSubsetMap s k a
TotalSubsetMap :: (Map k a) -> TotalSubsetMap s k a

-- | Restrict a partial map to a total map.
--   
--   Complexity: O(n)
restrict :: Map k a -> (forall s. Subset s k => TotalSubsetMap s k a -> r) -> r
instance Ord k => FoldableWithKey (TotalSubsetMap s k)
instance Ord k => Adjustable (TotalSubsetMap s k)
instance Ord k => Indexable (TotalSubsetMap s k)
instance Ord k => Lookup (TotalSubsetMap s k)
instance Ord k => ZipWithKey (TotalSubsetMap s k)
instance Ord k => Zip (TotalSubsetMap s k)
instance Keyed (TotalSubsetMap s k)
instance (Eq k, Eq a) => Eq (TotalSubsetMap s k a)
instance (Ord k, Ord a) => Ord (TotalSubsetMap s k a)
instance (Show k, Show a) => Show (TotalSubsetMap s k a)
instance (Ord k, Read k, Read a) => Read (TotalSubsetMap s k a)
instance Functor (TotalSubsetMap s k)
instance Foldable (TotalSubsetMap s k)
instance Traversable (TotalSubsetMap s k)
instance (Ord k, Subset s k) => Representable (TotalSubsetMap s k)
instance (Ord k, Subset s k) => Distributive (TotalSubsetMap s k)
instance (Ord k, Subset s k, Serial a) => Serial (TotalSubsetMap s k a)
instance (Ord k, Subset s k) => Serial1 (TotalSubsetMap s k)
instance (Ord k, Subset s k) => Metric (TotalSubsetMap s k)
instance (Ord k, Subset s k) => Additive (TotalSubsetMap s k)
instance Ord k => TraversableWithKey (TotalSubsetMap s k)
instance (Ord k, Subset s k) => Applicative (TotalSubsetMap s k)


-- | Subset, dense, total map implemented as a vector.
module Data.Total.Array.Subset

-- | <tt>Subset s k</tt> means that <tt>s</tt> reifies a subset of
--   <tt>k</tt>.
type Subset s k = Reifies s (Set k)

-- | A total map from a subset s of keys k to values a, e.g. a restriction
--   of a partial function <tt>k -&gt; a</tt> to a subset of its domain on
--   which the function is defined. Implemented as a vector.
--   
--   n is equal to the number of keys.
newtype TotalSubsetArray s k a
TotalSubsetArray :: (Vector a) -> TotalSubsetArray s k a
instance Eq a => Eq (TotalSubsetArray s k a)
instance Ord a => Ord (TotalSubsetArray s k a)
instance Show a => Show (TotalSubsetArray s k a)
instance Read a => Read (TotalSubsetArray s k a)
instance Functor (TotalSubsetArray s k)
instance Foldable (TotalSubsetArray s k)
instance Traversable (TotalSubsetArray s k)
instance (Ord k, Subset s k) => Representable (TotalSubsetArray s k)
instance Subset s k => Distributive (TotalSubsetArray s k)
instance (Subset s k, Serial a) => Serial (TotalSubsetArray s k a)
instance Subset s k => Serial1 (TotalSubsetArray s k)
instance Subset s k => Metric (TotalSubsetArray s k)
instance Subset s k => Additive (TotalSubsetArray s k)
instance Subset s k => TraversableWithKey (TotalSubsetArray s k)
instance Subset s k => FoldableWithKey (TotalSubsetArray s k)
instance (Ord k, Subset s k) => Adjustable (TotalSubsetArray s k)
instance (Ord k, Subset s k) => Indexable (TotalSubsetArray s k)
instance (Ord k, Subset s k) => Lookup (TotalSubsetArray s k)
instance Subset s k => ZipWithKey (TotalSubsetArray s k)
instance Zip (TotalSubsetArray s k)
instance Subset s k => Keyed (TotalSubsetArray s k)
instance Subset s k => Applicative (TotalSubsetArray s k)
